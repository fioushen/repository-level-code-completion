{"filename": ".erb/configs/webpack.paths.ts", "chunked_list": ["const path = require('path');\n\nconst rootPath = path.join(__dirname, '../..');\n\nconst dllPath = path.join(__dirname, '../dll');\n\nconst srcPath = path.join(rootPath, 'src');\nconst srcMainPath = path.join(srcPath, 'main');\nconst srcRendererPath = path.join(srcPath, 'renderer');\n", "const srcRendererPath = path.join(srcPath, 'renderer');\n\nconst releasePath = path.join(rootPath, 'release');\nconst appPath = path.join(releasePath, 'app');\nconst appPackagePath = path.join(appPath, 'package.json');\nconst appNodeModulesPath = path.join(appPath, 'node_modules');\nconst srcNodeModulesPath = path.join(srcPath, 'node_modules');\n\nconst distPath = path.join(appPath, 'dist');\nconst distMainPath = path.join(distPath, 'main');", "const distPath = path.join(appPath, 'dist');\nconst distMainPath = path.join(distPath, 'main');\nconst distRendererPath = path.join(distPath, 'renderer');\n\nconst buildPath = path.join(releasePath, 'build');\n\nexport default {\n  rootPath,\n  dllPath,\n  srcPath,", "  dllPath,\n  srcPath,\n  srcMainPath,\n  srcRendererPath,\n  releasePath,\n  appPath,\n  appPackagePath,\n  appNodeModulesPath,\n  srcNodeModulesPath,\n  distPath,", "  srcNodeModulesPath,\n  distPath,\n  distMainPath,\n  distRendererPath,\n  buildPath,\n};\n"]}
{"filename": ".erb/configs/webpack.config.base.ts", "chunked_list": ["/**\n * Base webpack config used across other specific configs\n */\n\nimport webpack from 'webpack';\nimport TsconfigPathsPlugins from 'tsconfig-paths-webpack-plugin';\nimport webpackPaths from './webpack.paths';\nimport { dependencies as externals } from '../../release/app/package.json';\n\nconst configuration: webpack.Configuration = {", "\nconst configuration: webpack.Configuration = {\n  externals: [...Object.keys(externals || {})],\n\n  stats: 'errors-only',\n\n  module: {\n    rules: [\n      {\n        test: /\\.[jt]sx?$/,", "      {\n        test: /\\.[jt]sx?$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'ts-loader',\n          options: {\n            // Remove this line to enable type checking in webpack builds\n            transpileOnly: true,\n            compilerOptions: {\n              module: 'esnext',\n            },\n          },\n        },\n      },\n    ],\n  },\n\n  output: {\n    path: webpackPaths.srcPath,\n    // https://github.com/webpack/webpack/issues/1114\n    library: {\n      type: 'commonjs2',\n    },\n  },\n\n  /**\n   * Determine the array of extensions that should be used to resolve modules.\n   */\n  resolve: {\n    extensions: ['.js', '.jsx', '.json', '.ts', '.tsx'],\n    modules: [webpackPaths.srcPath, 'node_modules'],\n    // There is no need to add aliases here, the paths in tsconfig get mirrored\n    plugins: [new TsconfigPathsPlugins()],\n  },\n\n  plugins: [\n    new webpack.EnvironmentPlugin({\n      NODE_ENV: 'production',\n    }),\n  ],\n};\n\nexport default configuration;\n"]}
{"filename": ".erb/configs/webpack.config.renderer.dev.dll.ts", "chunked_list": ["/**\n * Builds the DLL for development electron renderer process\n */\n\nimport webpack from 'webpack';\nimport path from 'path';\nimport { merge } from 'webpack-merge';\nimport baseConfig from './webpack.config.base';\nimport webpackPaths from './webpack.paths';\nimport { dependencies } from '../../package.json';", "import webpackPaths from './webpack.paths';\nimport { dependencies } from '../../package.json';\n\nconst dist = webpackPaths.dllPath;\n\nconst configuration: webpack.Configuration = {\n  context: webpackPaths.rootPath,\n\n  devtool: 'eval',\n", "  devtool: 'eval',\n\n  mode: 'development',\n\n  target: 'electron-renderer',\n\n  externals: ['fsevents', 'crypto-browserify'],\n\n  /**\n   * Use `module` from `webpack.config.renderer.dev.js`", "  /**\n   * Use `module` from `webpack.config.renderer.dev.js`\n   */\n  module: require('./webpack.config.renderer.dev').default.module,\n\n  entry: {\n    renderer: Object.keys(dependencies || {}),\n  },\n\n  output: {", "\n  output: {\n    path: dist,\n    filename: '[name].dev.dll.js',\n    library: {\n      name: 'renderer',\n      type: 'var',\n    },\n  },\n", "  },\n\n  plugins: [\n    new webpack.DllPlugin({\n      path: path.join(dist, '[name].json'),\n      name: '[name]',\n    }),\n\n    /**\n     * Create global constants which can be configured at compile time.", "    /**\n     * Create global constants which can be configured at compile time.\n     *\n     * Useful for allowing different behaviour between development builds and\n     * release builds\n     *\n     * NODE_ENV should be production so that modules do not perform certain\n     * development checks\n     */\n    new webpack.EnvironmentPlugin({", "     */\n    new webpack.EnvironmentPlugin({\n      NODE_ENV: 'development',\n    }),\n\n    new webpack.LoaderOptionsPlugin({\n      debug: true,\n      options: {\n        context: webpackPaths.srcPath,\n        output: {", "        context: webpackPaths.srcPath,\n        output: {\n          path: webpackPaths.dllPath,\n        },\n      },\n    }),\n  ],\n};\n\nexport default merge(baseConfig, configuration);", "\nexport default merge(baseConfig, configuration);\n"]}
{"filename": ".erb/configs/webpack.config.renderer.dev.ts", "chunked_list": ["import 'webpack-dev-server';\nimport path from 'path';\nimport fs from 'fs';\nimport webpack from 'webpack';\nimport HtmlWebpackPlugin from 'html-webpack-plugin';\nimport { merge } from 'webpack-merge';\nimport { execSync, spawn } from 'child_process';\nimport ReactRefreshWebpackPlugin from '@pmmmwh/react-refresh-webpack-plugin';\nimport baseConfig from './webpack.config.base';\nimport webpackPaths from './webpack.paths';", "import baseConfig from './webpack.config.base';\nimport webpackPaths from './webpack.paths';\n\nconst port = process.env.PORT || 1212;\nconst manifest = path.resolve(webpackPaths.dllPath, 'renderer.json');\nconst skipDLLs =\n  module.parent?.filename.includes('webpack.config.renderer.dev.dll') ||\n  module.parent?.filename.includes('webpack.config.eslint');\n\n/**", "\n/**\n * Warn if the DLL is not built\n */\nif (\n  !skipDLLs &&\n  !(fs.existsSync(webpackPaths.dllPath) && fs.existsSync(manifest))\n) {\n  execSync('npm run postinstall');\n}\n\nconst configuration: webpack.Configuration = {\n  devtool: false,\n\n  mode: 'development',\n\n  target: ['web', 'electron-renderer'],\n\n  entry: [\n    `webpack-dev-server/client?http://localhost:${port}/dist`,\n    'webpack/hot/only-dev-server',\n    path.join(webpackPaths.srcRendererPath, 'index.tsx'),\n  ],\n\n  output: {\n    path: webpackPaths.distRendererPath,\n    publicPath: '/',\n    filename: 'renderer.dev.js',\n    library: {\n      type: 'umd',\n    },\n  },\n\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          'style-loader',\n          {\n            loader: 'css-loader',\n            options: {\n              modules: true,\n              sourceMap: true,\n              importLoaders: 1,\n            },\n          },\n        ],\n        include: /\\.module\\.css$/,\n      },\n      {\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader'],\n        exclude: /\\.module\\.css$/,\n      },\n      // Fonts\n      {\n        test: /\\.(woff|woff2|eot|ttf|otf)$/i,\n        type: 'asset/resource',\n      },\n      // Images\n      {\n        test: /\\.(png|jpg|jpeg|gif)$/i,\n        type: 'asset/resource',\n      },\n      // SVG\n      {\n        test: /\\.svg$/,\n        use: [\n          {\n            loader: '@svgr/webpack',\n            options: {\n              prettier: false,\n              svgo: false,\n              svgoConfig: {\n                plugins: [{ removeViewBox: false }],\n              },\n              titleProp: true,\n              ref: true,\n            },\n          },\n          'file-loader',\n        ],\n      },\n    ],\n  },\n  plugins: [\n    ...(skipDLLs\n      ? []\n      : [\n          new webpack.DllReferencePlugin({\n            context: webpackPaths.dllPath,\n            manifest: require(manifest),\n            sourceType: 'var',\n          }),\n        ]),\n\n    new webpack.NoEmitOnErrorsPlugin(),\n\n    /**\n     * Create global constants which can be configured at compile time.\n     *\n     * Useful for allowing different behaviour between development builds and\n     * release builds\n     *\n     * NODE_ENV should be production so that modules do not perform certain\n     * development checks\n     *\n     * By default, use 'development' as NODE_ENV. This can be overriden with\n     * 'staging', for example, by changing the ENV variables in the npm scripts\n     */\n    new webpack.EnvironmentPlugin({\n      NODE_ENV: 'development',\n    }),\n\n    new webpack.LoaderOptionsPlugin({\n      debug: true,\n    }),\n\n    new ReactRefreshWebpackPlugin(),\n\n    new HtmlWebpackPlugin({\n      filename: path.join('index.html'),\n      template: path.join(webpackPaths.srcRendererPath, 'index.html'),\n      minify: {\n        collapseWhitespace: true,\n        removeAttributeQuotes: true,\n        removeComments: true,\n      },\n      isBrowser: false,\n      env: process.env.NODE_ENV,\n      isDevelopment: process.env.NODE_ENV !== 'production',\n      nodeModules: webpackPaths.appNodeModulesPath,\n    }),\n  ],\n\n  node: {\n    __dirname: false,\n    __filename: false,\n  },\n\n  devServer: {\n    port,\n    compress: true,\n    hot: true,\n    headers: { 'Access-Control-Allow-Origin': '*' },\n    static: {\n      publicPath: '/',\n    },\n    historyApiFallback: {\n      verbose: true,\n    },\n    setupMiddlewares(middlewares) {\n      console.log('Starting preload.js builder...');\n      const preloadProcess = spawn('npm', ['run', 'start:preload'], {\n        shell: true,\n        stdio: 'inherit',\n      })\n        .on('close', (code: number) => process.exit(code!))\n        .on('error', (spawnError) => console.error(spawnError));\n\n      console.log('Starting Main Process...');\n      let args = ['run', 'start:main'];", "      if (process.env.MAIN_ARGS) {\n        args = args.concat(\n          ['--', ...process.env.MAIN_ARGS.matchAll(/\"[^\"]+\"|[^\\s\"]+/g)].flat()\n        );\n      }\n      spawn('npm', args, {\n        shell: true,\n        stdio: 'inherit',\n      })\n        .on('close', (code: number) => {\n          preloadProcess.kill();\n          process.exit(code!);\n        })\n        .on('error', (spawnError) => console.error(spawnError));\n      return middlewares;\n    },\n  },\n};\n\nexport default merge(baseConfig, configuration);\n"]}
{"filename": ".erb/configs/webpack.config.renderer.prod.ts", "chunked_list": ["/**\n * Build config for electron renderer process\n */\n\nimport path from 'path';\nimport webpack from 'webpack';\nimport HtmlWebpackPlugin from 'html-webpack-plugin';\nimport MiniCssExtractPlugin from 'mini-css-extract-plugin';\nimport { merge } from 'webpack-merge';\nimport baseConfig from './webpack.config.base';", "import { merge } from 'webpack-merge';\nimport baseConfig from './webpack.config.base';\nimport webpackPaths from './webpack.paths';\n\nconst configuration: webpack.Configuration = {\n  devtool: false,\n\n  mode: 'production',\n\n  target: ['web', 'electron-renderer'],", "\n  target: ['web', 'electron-renderer'],\n\n  entry: [path.join(webpackPaths.srcRendererPath, 'index.tsx')],\n\n  output: {\n    path: webpackPaths.distRendererPath,\n    publicPath: './',\n    filename: 'renderer.js',\n    library: {", "    filename: 'renderer.js',\n    library: {\n      type: 'umd',\n    },\n  },\n\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,", "      {\n        test: /\\.css$/,\n        use: [\n          MiniCssExtractPlugin.loader,\n          {\n            loader: 'css-loader',\n            options: {\n              modules: true,\n              sourceMap: true,\n              importLoaders: 1,", "              sourceMap: true,\n              importLoaders: 1,\n            },\n          },\n        ],\n        include: /\\.module\\.css$/,\n      },\n      {\n        test: /\\.css$/,\n        use: [MiniCssExtractPlugin.loader, 'css-loader'],", "        test: /\\.css$/,\n        use: [MiniCssExtractPlugin.loader, 'css-loader'],\n        exclude: /\\.module\\.css$/,\n      },\n      // Fonts\n      {\n        test: /\\.(woff|woff2|eot|ttf|otf)$/i,\n        type: 'asset/resource',\n      },\n      // Images", "      },\n      // Images\n      {\n        test: /\\.(png|jpg|jpeg|gif)$/i,\n        type: 'asset/resource',\n      },\n      // SVG\n      {\n        test: /\\.svg$/,\n        use: [", "        test: /\\.svg$/,\n        use: [\n          {\n            loader: '@svgr/webpack',\n            options: {\n              prettier: false,\n              svgo: false,\n              svgoConfig: {\n                plugins: [{ removeViewBox: false }],\n              },", "                plugins: [{ removeViewBox: false }],\n              },\n              titleProp: true,\n              ref: true,\n            },\n          },\n          'file-loader',\n        ],\n      },\n    ],", "      },\n    ],\n  },\n\n  optimization: {\n    minimize: false,\n  },\n\n  plugins: [\n    /**", "  plugins: [\n    /**\n     * Create global constants which can be configured at compile time.\n     *\n     * Useful for allowing different behaviour between development builds and\n     * release builds\n     *\n     * NODE_ENV should be production so that modules do not perform certain\n     * development checks\n     */", "     * development checks\n     */\n    new webpack.EnvironmentPlugin({\n      NODE_ENV: 'production',\n      DEBUG_PROD: false,\n    }),\n\n    new MiniCssExtractPlugin({\n      filename: 'style.css',\n    }),", "      filename: 'style.css',\n    }),\n\n    new HtmlWebpackPlugin({\n      filename: 'index.html',\n      template: path.join(webpackPaths.srcRendererPath, 'index.html'),\n      minify: {\n        collapseWhitespace: true,\n        removeAttributeQuotes: true,\n        removeComments: true,", "        removeAttributeQuotes: true,\n        removeComments: true,\n      },\n      isBrowser: false,\n      isDevelopment: process.env.NODE_ENV !== 'production',\n    }),\n\n    new webpack.DefinePlugin({\n      'process.type': '\"renderer\"',\n    }),", "      'process.type': '\"renderer\"',\n    }),\n  ],\n};\n\nexport default merge(baseConfig, configuration);\n"]}
{"filename": ".erb/configs/webpack.config.eslint.ts", "chunked_list": ["module.exports = require('./webpack.config.renderer.dev').default;\n"]}
{"filename": ".erb/configs/webpack.config.preload.dev.ts", "chunked_list": ["import path from 'path';\nimport webpack from 'webpack';\nimport { merge } from 'webpack-merge';\nimport baseConfig from './webpack.config.base';\nimport webpackPaths from './webpack.paths';\n\nconst configuration: webpack.Configuration = {\n  devtool: false,\n\n  mode: 'development',", "\n  mode: 'development',\n\n  target: 'electron-preload',\n\n  entry: path.join(webpackPaths.srcMainPath, 'preload.ts'),\n\n  output: {\n    path: webpackPaths.dllPath,\n    filename: 'preload.js',", "    path: webpackPaths.dllPath,\n    filename: 'preload.js',\n    library: {\n      type: 'umd',\n    },\n  },\n\n  plugins: [\n    /**\n     * Create global constants which can be configured at compile time.", "    /**\n     * Create global constants which can be configured at compile time.\n     *\n     * Useful for allowing different behaviour between development builds and\n     * release builds\n     *\n     * NODE_ENV should be production so that modules do not perform certain\n     * development checks\n     *\n     * By default, use 'development' as NODE_ENV. This can be overriden with", "     *\n     * By default, use 'development' as NODE_ENV. This can be overriden with\n     * 'staging', for example, by changing the ENV variables in the npm scripts\n     */\n    new webpack.EnvironmentPlugin({\n      NODE_ENV: 'development',\n    }),\n\n    new webpack.LoaderOptionsPlugin({\n      debug: true,", "    new webpack.LoaderOptionsPlugin({\n      debug: true,\n    }),\n  ],\n\n  /**\n   * Disables webpack processing of __dirname and __filename.\n   * If you run the bundle in node.js it falls back to these values of node.js.\n   * https://github.com/webpack/webpack/issues/2010\n   */", "   * https://github.com/webpack/webpack/issues/2010\n   */\n  node: {\n    __dirname: false,\n    __filename: false,\n  },\n\n  watch: true,\n};\n", "};\n\nexport default merge(baseConfig, configuration);\n"]}
{"filename": ".erb/configs/webpack.config.main.prod.ts", "chunked_list": ["/**\n * Webpack config for production electron main process\n */\n\nimport path from 'path';\nimport webpack from 'webpack';\nimport { merge } from 'webpack-merge';\nimport baseConfig from './webpack.config.base';\nimport webpackPaths from './webpack.paths';\n", "import webpackPaths from './webpack.paths';\n\nconst configuration: webpack.Configuration = {\n  devtool: false,\n\n  mode: 'production',\n\n  target: 'electron-main',\n\n  entry: {", "\n  entry: {\n    main: path.join(webpackPaths.srcMainPath, 'main.ts'),\n    preload: path.join(webpackPaths.srcMainPath, 'preload.ts'),\n  },\n\n  output: {\n    path: webpackPaths.distMainPath,\n    filename: '[name].js',\n    library: {", "    filename: '[name].js',\n    library: {\n      type: 'umd',\n    },\n  },\n\n  optimization: {\n    minimize: false,\n  },\n", "  },\n\n  plugins: [\n    /**\n     * Create global constants which can be configured at compile time.\n     *\n     * Useful for allowing different behaviour between development builds and\n     * release builds\n     *\n     * NODE_ENV should be production so that modules do not perform certain", "     *\n     * NODE_ENV should be production so that modules do not perform certain\n     * development checks\n     */\n    new webpack.EnvironmentPlugin({\n      NODE_ENV: 'production',\n      DEBUG_PROD: false,\n      START_MINIMIZED: false,\n    }),\n", "    }),\n\n    new webpack.DefinePlugin({\n      'process.type': '\"browser\"',\n    }),\n  ],\n\n  /**\n   * Disables webpack processing of __dirname and __filename.\n   * If you run the bundle in node.js it falls back to these values of node.js.", "   * Disables webpack processing of __dirname and __filename.\n   * If you run the bundle in node.js it falls back to these values of node.js.\n   * https://github.com/webpack/webpack/issues/2010\n   */\n  node: {\n    __dirname: false,\n    __filename: false,\n  },\n  module: {\n    rules: [", "  module: {\n    rules: [\n      // Images\n      {\n        test: /\\.(svg)$/i,\n        type: 'asset/resource',\n      },\n    ],\n  },\n};", "  },\n};\n\nexport default merge(baseConfig, configuration);\n"]}
{"filename": ".erb/scripts/link-modules.ts", "chunked_list": ["import fs from 'fs';\nimport webpackPaths from '../configs/webpack.paths';\n\nconst { srcNodeModulesPath } = webpackPaths;\nconst { appNodeModulesPath } = webpackPaths;\n\nif (!fs.existsSync(srcNodeModulesPath) && fs.existsSync(appNodeModulesPath)) {\n  fs.symlinkSync(appNodeModulesPath, srcNodeModulesPath, 'junction');\n}\n"]}
{"filename": ".erb/scripts/check-build-exists.ts", "chunked_list": ["// Check if the renderer and main bundles are built\nimport path from 'path';\nimport fs from 'fs';\nimport webpackPaths from '../configs/webpack.paths';\n\nconst mainPath = path.join(webpackPaths.distMainPath, 'main.js');\nconst rendererPath = path.join(webpackPaths.distRendererPath, 'renderer.js');\n\nif (!fs.existsSync(mainPath)) {\n  throw new Error(\n    'The main process is not built yet. Build it by running \"npm run build:main\"'\n  );\n}\n", "if (!fs.existsSync(mainPath)) {\n  throw new Error(\n    'The main process is not built yet. Build it by running \"npm run build:main\"'\n  );\n}\n\nif (!fs.existsSync(rendererPath)) {\n  throw new Error(\n    'The renderer process is not built yet. Build it by running \"npm run build:renderer\"'\n  );\n}\n"]}
{"filename": "assets/assets.d.ts", "chunked_list": ["type Styles = Record<string, string>;\n\ndeclare module '*.svg' {\n  import React = require('react');\n\n  export const ReactComponent: React.FC<React.SVGProps<SVGSVGElement>>;\n\n  const content: string;\n  export default content;\n}\n\ndeclare module '*.png' {\n  const content: string;\n  export default content;\n}\n\ndeclare module '*.jpg' {\n  const content: string;\n  export default content;\n}\n\ndeclare module '*.css' {\n  const content: Styles;\n  export default content;\n}\n"]}
{"filename": "src/config.ts", "chunked_list": ["import { z } from 'zod';\n\nexport const DappSchema = z\n  .object({\n    id: z.string(),\n    label: z.string(),\n    icon: z.string(),\n    ens: z.string().optional(),\n    ipns: z.string().optional(),\n    qm: z.string().optional(),", "    ipns: z.string().optional(),\n    qm: z.string().optional(),\n    bafy: z.string().optional(),\n    url: z.string().optional(),\n  })\n  .strict()\n  .refine((obj) => Boolean(obj.ens || obj.ipns), {\n    message: 'ens or ipns must be defined',\n    path: ['ens'],\n  });", "    path: ['ens'],\n  });\n\nexport const DappsSchema = z.array(DappSchema);\n\nexport const ConfigSchema = z\n  .object({\n    dapps: DappsSchema,\n  })\n  .strict();", "  })\n  .strict();\n\nexport type DappType = z.infer<typeof DappSchema>;\n"]}
{"filename": "src/const.ts", "chunked_list": ["export const SYNTHETIX_IPNS =\n  'k51qzi5uqu5dj0vqsuc4wyyj93tpaurdfjtulpx0w45q8eqd7uay49zodimyh7';\n\nexport const SYNTHETIX_NODE_APP_CONFIG =\n  'k2k4r8jhn5r54sf708bnlxun971q0pteab82iw98544sj1e0hi3hp9q6';\n"]}
{"filename": "src/config-check.ts", "chunked_list": ["import { ConfigSchema } from './config';\nimport config from '../config.json';\n\nConfigSchema.parse(config);\n"]}
{"filename": "src/scripts/follower-install.ts", "chunked_list": ["import {\n  downloadFollower,\n  followerDaemon,\n  followerKill,\n} from '../main/follower';\n\nasync function main() {\n  await downloadFollower();\n  await followerDaemon();\n}\n\nprocess.on('beforeExit', followerKill);\nmain();\n"]}
{"filename": "src/scripts/ipfs-install.ts", "chunked_list": ["import { downloadIpfs, ipfsDaemon, ipfsKill } from '../main/ipfs';\n\nasync function main() {\n  await downloadIpfs();\n  await ipfsDaemon();\n}\n\nprocess.on('beforeExit', ipfsKill);\nmain();\n"]}
{"filename": "src/renderer/preload.d.ts", "chunked_list": ["import { ElectronHandler } from 'main/preload';\n\ndeclare global {\n  // eslint-disable-next-line no-unused-vars\n  interface Window {\n    electron: ElectronHandler;\n  }\n}\n\nexport {};\n"]}
{"filename": "src/renderer/DApps/useDapp.ts", "chunked_list": ["import { useQuery } from '@tanstack/react-query';\n\nconst { ipcRenderer } = window?.electron || {};\n\nexport function useDapp(id: string) {\n  return useQuery({\n    queryKey: ['dapp', id],\n    queryFn: async () => {\n      const url = await ipcRenderer.invoke('dapp', id);\n      if (!url) {\n        return null;\n      }\n      return url;\n    },\n    initialData: () => null,\n    placeholderData: null,\n    enabled: Boolean(ipcRenderer),\n  });\n}\n", "      if (!url) {\n        return null;\n      }\n      return url;\n    },\n    initialData: () => null,\n    placeholderData: null,\n    enabled: Boolean(ipcRenderer),\n  });\n}\n"]}
{"filename": "src/renderer/DApps/index.ts", "chunked_list": ["export * from './Dapps';\n"]}
{"filename": "src/renderer/DApps/useDapps.ts", "chunked_list": ["import { useQuery } from '@tanstack/react-query';\nimport { DappsSchema } from '../../config';\n\nconst { ipcRenderer } = window?.electron || {};\n\nexport function useDapps() {\n  return useQuery({\n    queryKey: ['dapps'],\n    queryFn: async () => {\n      return DappsSchema.parse(await ipcRenderer.invoke('dapps'));\n    },\n    initialData: () => [],\n    placeholderData: [],\n    enabled: Boolean(ipcRenderer),\n  });\n}\n"]}
{"filename": "src/renderer/Ipfs/useRepoStat.ts", "chunked_list": ["import { useQuery } from '@tanstack/react-query';\nimport { useIsIpfsRunning } from './useIsIpfsRunning';\n\nconst { ipcRenderer } = window?.electron || {};\n\nexport function useRepoStat() {\n  const { data: isRunning } = useIsIpfsRunning();\n  return useQuery({\n    queryKey: ['ipfs', 'repo stat'],\n    queryFn: async () => {\n      const stats = await ipcRenderer.invoke('ipfs-repo-stat');", "      if (!stats) {\n        return '';\n      }\n      return stats;\n    },\n    initialData: () => '',\n    placeholderData: '',\n    enabled: Boolean(ipcRenderer && isRunning),\n  });\n}\n"]}
{"filename": "src/renderer/Ipfs/useHostingSize.ts", "chunked_list": ["import React from 'react';\nimport { useRepoStat } from './useRepoStat';\n\nexport function useHostingSize() {\n  const { data: repoStat } = useRepoStat();\n  return React.useMemo(() => {\n    if (!repoStat) {\n      return 0;\n    }\n    const numBytes = parseInt(repoStat.split('\\n')[1].split(':')[1].trim(), 10);\n    const numMegabytes = numBytes / 1024 / 1024;\n    return numMegabytes;\n  }, [repoStat]);\n}\n"]}
{"filename": "src/renderer/Ipfs/useIsIpfsInstalled.ts", "chunked_list": ["import { useQuery } from '@tanstack/react-query';\n\nconst { ipcRenderer } = window?.electron || {};\n\nexport function useIsIpfsInstalled() {\n  return useQuery({\n    queryKey: ['ipfs', 'isInstalled'],\n    queryFn: () => ipcRenderer.invoke('ipfs-isInstalled'),\n    initialData: () => false,\n    placeholderData: false,\n    enabled: Boolean(ipcRenderer),\n  });\n}\n"]}
{"filename": "src/renderer/Ipfs/useRateIn.ts", "chunked_list": ["import React from 'react';\nimport { useStatsBw } from './useStatsBw';\n\nexport function useRateIn() {\n  const { data: statsBw } = useStatsBw();\n  return React.useMemo(() => {\n    return statsBw ? statsBw.split('\\n')[3].split(':')[1].trim() : '';\n  }, [statsBw]);\n}\n"]}
{"filename": "src/renderer/Ipfs/usePeers.ts", "chunked_list": ["import { useQuery } from '@tanstack/react-query';\nimport { useIsIpfsRunning } from './useIsIpfsRunning';\n\nconst { ipcRenderer } = window?.electron || {};\n\nexport function usePeers() {\n  const { data: isRunning } = useIsIpfsRunning();\n  return useQuery({\n    queryKey: ['ipfs', 'peers'],\n    queryFn: async () => {\n      const peers = await ipcRenderer.invoke('peers');", "      if (!peers) {\n        return [];\n      }\n      return peers;\n    },\n    initialData: () => [],\n    placeholderData: [],\n    enabled: Boolean(ipcRenderer && isRunning),\n    refetchInterval: 30_000,\n    refetchOnWindowFocus: true,\n  });\n}\n"]}
{"filename": "src/renderer/Ipfs/useFollowerInfo.ts", "chunked_list": ["import { useQuery } from '@tanstack/react-query';\nimport { useIsFollowerRunning } from './useIsFollowerRunning';\n\nconst { ipcRenderer } = window?.electron || {};\n\nexport function useFollowerInfo() {\n  const { data: isRunning } = useIsFollowerRunning();\n  return useQuery({\n    queryKey: ['follower', 'info'],\n    queryFn: async () => {\n      const state = await ipcRenderer.invoke('ipfs-follower-info');\n      return {\n        ipfs: state?.includes('IPFS peer online: true'),\n        cluster: state?.includes('Cluster Peer online: true'),\n      };\n    },\n    initialData: () => ({\n      ipfs: false,\n      cluster: false,\n    }),\n    placeholderData: {\n      ipfs: false,\n      cluster: false,\n    },\n    enabled: Boolean(ipcRenderer && isRunning),\n    refetchInterval: 30_000,\n  });\n}\n"]}
{"filename": "src/renderer/Ipfs/useIsFollowerRunning.ts", "chunked_list": ["import { useQuery } from '@tanstack/react-query';\nimport { useIsFollowerInstalled } from './useIsFollowerInstalled';\n\nconst { ipcRenderer } = window?.electron || {};\n\nexport function useIsFollowerRunning() {\n  const { data: isInstalled } = useIsFollowerInstalled();\n  return useQuery({\n    queryKey: ['follower', 'isRunning'],\n    queryFn: () => ipcRenderer.invoke('follower-isRunning'),\n    initialData: () => false,\n    placeholderData: false,\n    enabled: Boolean(ipcRenderer && isInstalled),\n  });\n}\n"]}
{"filename": "src/renderer/Ipfs/useIsFollowerInstalled.ts", "chunked_list": ["import { useQuery } from '@tanstack/react-query';\n\nconst { ipcRenderer } = window?.electron || {};\n\nexport function useIsFollowerInstalled() {\n  return useQuery({\n    queryKey: ['follower', 'isInstalled'],\n    queryFn: () => ipcRenderer.invoke('follower-isInstalled'),\n    initialData: () => false,\n    placeholderData: false,\n    enabled: Boolean(ipcRenderer),\n  });\n}\n"]}
{"filename": "src/renderer/Ipfs/usePeerId.ts", "chunked_list": ["import { useQuery } from '@tanstack/react-query';\nimport { useIsIpfsRunning } from './useIsIpfsRunning';\n\nconst { ipcRenderer } = window?.electron || {};\n\nexport function usePeerId() {\n  const { data: isRunning } = useIsIpfsRunning();\n  return useQuery({\n    queryKey: ['ipfs', 'id'],\n    queryFn: async () => {\n      const id = await ipcRenderer.invoke('ipfs-id');", "      if (!id) {\n        return '';\n      }\n      return id;\n    },\n    initialData: () => '',\n    placeholderData: '',\n    enabled: Boolean(ipcRenderer && isRunning),\n  });\n}\n"]}
{"filename": "src/renderer/Ipfs/index.ts", "chunked_list": ["export * from './Ipfs';\n"]}
{"filename": "src/renderer/Ipfs/useIsIpfsRunning.ts", "chunked_list": ["import { useQuery } from '@tanstack/react-query';\nimport { useIsIpfsInstalled } from './useIsIpfsInstalled';\n\nconst { ipcRenderer } = window?.electron || {};\n\nexport function useIsIpfsRunning() {\n  const { data: isInstalled } = useIsIpfsInstalled();\n  return useQuery({\n    queryKey: ['ipfs', 'isRunning'],\n    queryFn: () => ipcRenderer.invoke('ipfs-isRunning'),\n    initialData: () => false,\n    placeholderData: false,\n    enabled: Boolean(ipcRenderer && isInstalled),\n  });\n}\n"]}
{"filename": "src/renderer/Ipfs/useRateOut.ts", "chunked_list": ["import React from 'react';\nimport { useStatsBw } from './useStatsBw';\n\nexport function useRateOut() {\n  const { data: statsBw } = useStatsBw();\n  return React.useMemo(() => {\n    return statsBw ? statsBw.split('\\n')[4].split(':')[1].trim() : '';\n  }, [statsBw]);\n}\n"]}
{"filename": "src/renderer/Ipfs/useStatsBw.ts", "chunked_list": ["import { useQuery } from '@tanstack/react-query';\nimport { useIsIpfsRunning } from './useIsIpfsRunning';\n\nconst { ipcRenderer } = window?.electron || {};\n\nexport function useStatsBw() {\n  const { data: isRunning } = useIsIpfsRunning();\n  return useQuery({\n    queryKey: ['ipfs', 'stats bw'],\n    queryFn: async () => {\n      const stats = await ipcRenderer.invoke('ipfs-stats-bw');", "      if (!stats) {\n        return '';\n      }\n      return stats;\n    },\n    initialData: () => '',\n    placeholderData: '',\n    enabled: Boolean(ipcRenderer && isRunning),\n  });\n}\n"]}
{"filename": "src/main/dapps.ts", "chunked_list": ["import logger from 'electron-log';\nimport fetch from 'node-fetch';\nimport { createPublicClient, http } from 'viem';\nimport { mainnet } from 'viem/chains';\nimport { namehash, normalize } from 'viem/ens';\n// @ts-ignore\nimport * as contentHash from '@ensdomains/content-hash';\nimport { ipfs } from './ipfs';\nimport { getPid } from './pid';\nimport { DappType } from '../config';", "import { getPid } from './pid';\nimport { DappType } from '../config';\n\nObject.assign(global, { fetch });\n\nexport const DAPPS: DappType[] = [];\n\nconst client = createPublicClient({\n  chain: mainnet,\n  transport: http(),", "  chain: mainnet,\n  transport: http(),\n});\n\nconst resolverAbi = [\n  {\n    constant: true,\n    inputs: [{ internalType: 'bytes32', name: 'node', type: 'bytes32' }],\n    name: 'contenthash',\n    outputs: [{ internalType: 'bytes', name: '', type: 'bytes' }],", "    name: 'contenthash',\n    outputs: [{ internalType: 'bytes', name: '', type: 'bytes' }],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function',\n  },\n];\n\nexport async function resolveEns(\n  dapp: DappType\n): Promise<{ codec: string; hash: string }> {", "export async function resolveEns(\n  dapp: DappType\n): Promise<{ codec: string; hash: string }> {\n  if (dapp.ipns) {\n    return {\n      codec: 'ipns-ns',\n      hash: dapp.ipns,\n    };\n  }\n  if (!dapp.ens) {\n    throw new Error('Neither ipns nor ens was set, cannot resolve');\n  }\n  const name = normalize(dapp.ens);\n  const resolverAddress = await client.getEnsResolver({ name });\n  const hash = await client.readContract({\n    address: resolverAddress,\n    abi: resolverAbi,\n    functionName: 'contenthash',\n    args: [namehash(name)],\n  });\n  const codec = contentHash.getCodec(hash);\n  return {\n    codec,\n    hash: contentHash.decode(hash),\n  };\n}\n", "  if (!dapp.ens) {\n    throw new Error('Neither ipns nor ens was set, cannot resolve');\n  }\n  const name = normalize(dapp.ens);\n  const resolverAddress = await client.getEnsResolver({ name });\n  const hash = await client.readContract({\n    address: resolverAddress,\n    abi: resolverAbi,\n    functionName: 'contenthash',\n    args: [namehash(name)],\n  });\n  const codec = contentHash.getCodec(hash);\n  return {\n    codec,\n    hash: contentHash.decode(hash),\n  };\n}\n", "export async function resolveQm(ipns: string): Promise<string> {\n  const ipfsPath = await ipfs(`resolve /ipns/${ipns}`);\n  const qm = ipfsPath.slice(6); // remove /ipfs/\n  return qm; // Qm\n}\n\nexport async function convertCid(qm: string): Promise<string> {\n  return await ipfs(`cid base32 ${qm}`);\n}\n\nexport async function isPinned(qm: string): Promise<boolean> {", "export async function isPinned(qm: string): Promise<boolean> {\n  try {\n    const result = await ipfs(`pin ls --type recursive ${qm}`);\n    return result.includes(qm);\n  } catch (e) {\n    return false;\n  }\n}\n\nexport async function resolveDapp(dapp: DappType): Promise<void> {\n  try {\n    const { codec, hash } = await resolveEns(dapp);\n    logger.log(dapp.id, 'resolved', codec, hash);\n    const qm =\n      codec === 'ipns-ns'\n        ? await resolveQm(hash)\n        : codec === 'ipfs-ns'\n        ? hash\n        : undefined;", "export async function resolveDapp(dapp: DappType): Promise<void> {\n  try {\n    const { codec, hash } = await resolveEns(dapp);\n    logger.log(dapp.id, 'resolved', codec, hash);\n    const qm =\n      codec === 'ipns-ns'\n        ? await resolveQm(hash)\n        : codec === 'ipfs-ns'\n        ? hash\n        : undefined;\n    if (qm) {\n      Object.assign(dapp, { qm });\n    }", "    if (qm) {\n      Object.assign(dapp, { qm });\n    }\n    if (qm !== hash) {\n      logger.log(dapp.id, 'resolved CID', qm);\n    }\n    if (!qm) {\n      throw new Error(`Codec \"${codec}\" not supported`);\n    }\n    if (await getPid(`pin add --progress ${qm}`)) {\n      logger.log(dapp.id, 'pinning already in progres...');\n      return;\n    }\n    const isDappPinned = await isPinned(qm);", "    if (await getPid(`pin add --progress ${qm}`)) {\n      logger.log(dapp.id, 'pinning already in progres...');\n      return;\n    }\n    const isDappPinned = await isPinned(qm);\n    if (!isDappPinned) {\n      logger.log(dapp.id, 'pinning...', qm);\n      await ipfs(`pin add --progress ${qm}`);\n    }\n    const bafy = await convertCid(qm);\n    Object.assign(dapp, { bafy });\n\n    const url = `${bafy}.ipfs.localhost`;\n    Object.assign(dapp, { url });\n\n    logger.log(dapp.id, 'local IPFS host:', url);", "  } catch (e) {\n    logger.error(e);\n    return;\n  }\n}\n\nexport async function cleanupOldDapps() {\n  const hashes = DAPPS.map((dapp) => dapp.qm);\n  logger.log('Current DAPPs hashes', hashes);\n  if (hashes.length < 1 || hashes.some((hash) => !hash)) {\n    // We only want to cleanup when all the dapps aer resolved\n    return;\n  }", "  if (hashes.length < 1 || hashes.some((hash) => !hash)) {\n    // We only want to cleanup when all the dapps aer resolved\n    return;\n  }\n  try {\n    const pins = JSON.parse(await ipfs('pin ls --enc=json --type=recursive'));\n    const pinnedHashes = Object.keys(pins.Keys);\n    logger.log('Existing IPFS pins', pinnedHashes);\n    const toUnpin = pinnedHashes.filter((hash) => !hashes.includes(hash));\n    logger.log('Hashes to unpin', toUnpin);\n    if (toUnpin.length > 0) {", "    if (toUnpin.length > 0) {\n      for (const hash of toUnpin) {\n        logger.log(`Unpinning ${hash}`);\n        await ipfs(`pin rm ${hash}`);\n      }\n      const pinsAfter = JSON.parse(\n        await ipfs('pin ls --enc=json --type=recursive')\n      );\n      logger.log('Updated IPFS pins', pinsAfter);\n      // Clenup the repo\n      await ipfs('repo gc');\n    }", "  } catch (e) {\n    // do nothing\n  }\n}\n"]}
{"filename": "src/main/main.ts", "chunked_list": ["/**\n * This module executes inside of electron's main process. You can start\n * electron renderer process from here and communicate with the other processes\n * through IPC.\n *\n * When running `npm run build` or `npm run build:main`, this file is compiled to\n * `./src/main.js` using webpack. This gives us some performance wins.\n */\nimport path from 'path';\nimport { app, BrowserWindow, ipcMain, Menu, shell, Tray } from 'electron';\n// import { autoUpdater } from 'electron-updater';\nimport logger from 'electron-log';\nimport { resolveHtmlPath } from './util';\nimport {\n  configureIpfs,\n  downloadIpfs,\n  ipfs,\n  ipfsDaemon,\n  ipfsIsInstalled,\n  ipfsIsRunning,\n  ipfsKill,\n  waitForIpfs,\n} from './ipfs';\nimport {\n  configureFollower,\n  downloadFollower,\n  follower,\n  followerDaemon,\n  followerId,\n  followerIsInstalled,\n  followerKill,\n  followerPid,\n} from './follower';\nimport { DAPPS, resolveDapp } from './dapps';\nimport { fetchPeers } from './peers';\nimport { SYNTHETIX_NODE_APP_CONFIG } from '../const';\nimport * as settings from './settings';\nimport http from 'http';\nimport { proxy } from './proxy';\n\nlogger.transports.file.level = 'info';\n\nconst isDebug =\n  process.env.NODE_ENV === 'development' || process.env.DEBUG_PROD === 'true';\n", "// class AppUpdater {\n//   constructor() {\n//     log.transports.file.level = 'info';\n//     autoUpdater.logger = log;\n//     autoUpdater.checkForUpdatesAndNotify();\n//   }\n// }\n\nlet tray: Tray | null = null;\nlet mainWindow: BrowserWindow | null = null;\n", "if (process.env.NODE_ENV === 'production') {\n  const sourceMapSupport = require('source-map-support');\n  sourceMapSupport.install();\n}\n\nconst RESOURCES_PATH = app.isPackaged\n  ? path.join(process.resourcesPath, 'assets')\n  : path.join(__dirname, '../../assets');\n\nconst getAssetPath = (...paths: string[]): string => {\n  return path.join(RESOURCES_PATH, ...paths);\n};\n", "function updateContextMenu() {\n  const menu = generateMenuItems();\n  if (tray && !tray.isDestroyed()) {\n    tray.setContextMenu(\n      Menu.buildFromTemplate([\n        menu.app,\n        menu.autoStart,\n        menu.devTools,\n        menu.dock,\n        { type: 'separator' },\n        ...menu.dapps,\n        { type: 'separator' },\n        menu.quit,\n      ])\n    );\n  }\n  app.dock.setMenu(\n    Menu.buildFromTemplate([\n      menu.app,\n      menu.autoStart,\n      menu.devTools,\n      menu.tray,\n      { type: 'separator' },\n      ...menu.dapps,\n    ])\n  );\n}\n", "function createWindow() {\n  mainWindow = new BrowserWindow({\n    show: true,\n    useContentSize: true,\n    center: true,\n    minWidth: 600,\n    minHeight: 470,\n    skipTaskbar: true,\n    fullscreen: false,\n    fullscreenable: false,\n    width: 600,\n    height: 470,\n    // frame: false,\n    icon: getAssetPath('icon.icns'),\n    webPreferences: {\n      preload: app.isPackaged\n        ? path.join(__dirname, 'preload.js')\n        : path.join(__dirname, '../../.erb/dll/preload.js'),\n    },\n  });\n", "  if (isDebug) {\n    mainWindow.webContents.openDevTools({ mode: 'detach' });\n  }\n\n  mainWindow.loadURL(resolveHtmlPath('index.html'));\n  mainWindow.on('closed', () => {\n    mainWindow = null;\n  });\n\n  // Open urls in the user's browser\n  mainWindow.webContents.setWindowOpenHandler((edata) => {\n    shell.openExternal(edata.url);\n    return { action: 'deny' };\n  });\n\n  mainWindow.webContents.on('devtools-opened', updateContextMenu);\n  mainWindow.webContents.on('devtools-closed', updateContextMenu);\n  mainWindow.on('hide', updateContextMenu);\n  mainWindow.on('show', updateContextMenu);\n\n  // Remove this if your app does not use auto updates\n  // eslint-disable-next-line\n  // new AppUpdater();\n}\n", "function generateMenuItems() {\n  return {\n    app: {\n      label: mainWindow?.isVisible() ? 'Hide App' : 'Open App',\n      click: () => {\n        if (mainWindow?.isVisible()) {\n          mainWindow.hide();\n          if (mainWindow.webContents.isDevToolsOpened()) {\n            mainWindow.webContents.closeDevTools();\n          }\n          return;\n        }", "        if (!mainWindow) {\n          createWindow();\n        } else {\n          mainWindow.show();\n        }\n        updateContextMenu();\n      },\n    },\n    autoStart: {\n      label: app.getLoginItemSettings().openAtLogin\n        ? 'Disable AutoStart'\n        : 'Enable AutoStart',\n      click: () => {\n        const settings = app.getLoginItemSettings();\n        settings.openAtLogin = !settings.openAtLogin;\n        app.setLoginItemSettings(settings);\n        updateContextMenu();\n      },\n    },\n    devTools: {\n      label:\n        mainWindow && mainWindow.webContents.isDevToolsOpened()\n          ? 'Close DevTools'\n          : 'Open DevTools',\n      click: () => {", "        if (mainWindow) {\n          if (mainWindow.webContents.isDevToolsOpened()) {\n            mainWindow.webContents.closeDevTools();\n          } else {\n            mainWindow.webContents.openDevTools({ mode: 'detach' });\n          }\n        }\n        updateContextMenu();\n      },\n    },\n    dock: {\n      label: app.dock && app.dock.isVisible() ? 'Hide Dock' : 'Show Dock',\n      click: async () => {", "        if (app.dock) {\n          if (app.dock.isVisible()) {\n            await settings.set('dock', false);\n            app.dock.hide();\n          } else {\n            await settings.set('dock', true);\n            app.dock.show();\n          }\n        }\n        updateContextMenu();\n      },\n    },\n    tray: {\n      label: tray && !tray.isDestroyed() ? 'Hide Tray icon' : 'Show Tray icon',\n      click: async () => {", "        if (tray && !tray.isDestroyed()) {\n          await settings.set('tray', false);\n          tray.destroy();\n        } else {\n          await settings.set('tray', true);\n          createTray();\n        }\n        updateContextMenu();\n      },\n    },\n    separator: {\n      type: 'separator',\n    },\n    dapps: DAPPS.map((dapp) => {\n      return {\n        enabled: Boolean(dapp.url),\n        label: dapp.label,\n        click: () => shell.openExternal(`http://${dapp.id}.localhost:8888`),\n      };\n    }),\n    quit: {\n      label: 'Quit',\n      click: () => {\n        app.quit();\n      },\n    },\n  };\n}\n\napp.once('ready', async () => {\n  // Hide the app from the dock", "  if (app.dock && !(await settings.get('dock'))) {\n    app.dock.hide();\n  }\n\n  if (await settings.get('tray')) {\n    createTray();\n  }\n\n  updateContextMenu();\n});\n", "function createTray() {\n  // Create a Tray instance with the icon you want to use for the menu bar\n  tray = new Tray(getAssetPath('tray@3x.png'));\n  tray.on('mouse-down', (_event) => {\n    if (mainWindow?.isVisible()) {\n      mainWindow?.focus();\n    }\n  });\n}\n\n/**\n * Add event listeners...\n */\n\napp.on('window-all-closed', () => {\n  // Respect the OSX convention of having the application in memory even\n  // after all windows have been closed", "  if (process.platform !== 'darwin') {\n    app.quit();\n  }\n});\n\napp\n  .whenReady()\n  .then(() => {\n    createWindow();\n    app.on('activate', () => {\n      // On macOS it's common to re-create a window in the app when the\n      // dock icon is clicked and there are no other windows open.", "      if (mainWindow === null) {\n        createWindow();\n      }\n    });\n  })\n  .catch(logger.error);\n\nipcMain.handle('install-ipfs', downloadIpfs);\nipcMain.handle('install-follower', downloadFollower);\n\nipcMain.handle('ipfs-isInstalled', ipfsIsInstalled);\nipcMain.handle('follower-isInstalled', followerIsInstalled);\nipcMain.handle('ipfs-isRunning', ipfsIsRunning);\nipcMain.handle('follower-isRunning', followerPid);\n\nipcMain.handle('run-ipfs', async () => {\n  await configureIpfs();\n  await ipfsDaemon();\n});\n\nipcMain.handle('run-follower', async () => {\n  await configureFollower();\n  await followerDaemon();\n});\n\nipcMain.handle('ipfs-peers', () => ipfs('swarm peers'));\nipcMain.handle('ipfs-id', () => followerId());\nipcMain.handle('ipfs-repo-stat', () => ipfs('repo stat'));\nipcMain.handle('ipfs-stats-bw', () => ipfs('stats bw'));\nipcMain.handle('ipfs-follower-info', () => follower('synthetix info'));\n\napp.on('will-quit', ipfsKill);\napp.on('will-quit', followerKill);\n\ndownloadIpfs();\nipfsDaemon();\nconst ipfsCheck = setInterval(ipfsDaemon, 10_000);\napp.on('will-quit', () => clearInterval(ipfsCheck));\n\ndownloadFollower();\nfollowerDaemon();\nconst followerCheck = setInterval(followerDaemon, 10_000);\napp.on('will-quit', () => clearInterval(followerCheck));\n\nipcMain.handle('dapps', async () => {\n  return DAPPS.map((dapp) => ({\n    ...dapp,\n    url: dapp.url ? `http://${dapp.id}.localhost:8888` : null,\n  }));\n});\nipcMain.handle('dapp', async (_event, id: string) => {\n  const dapp = DAPPS.find((dapp) => dapp.id === id);\n  return dapp && dapp.url ? `http://${dapp.id}.localhost:8888` : null;\n});\n", "async function resolveAllDapps() {\n  DAPPS.forEach((dapp) => resolveDapp(dapp).then(updateContextMenu));\n}\n\nconst dappsResolver = setInterval(resolveAllDapps, 600_000); // 10 minutes\napp.on('will-quit', () => clearInterval(dappsResolver));\nwaitForIpfs().then(resolveAllDapps).catch(logger.error);\n\nasync function updateConfig() {\n  const config = JSON.parse(\n    await ipfs(`cat /ipns/${SYNTHETIX_NODE_APP_CONFIG}`)\n  );\n  logger.log('App config fetched', config);", "async function updateConfig() {\n  const config = JSON.parse(\n    await ipfs(`cat /ipns/${SYNTHETIX_NODE_APP_CONFIG}`)\n  );\n  logger.log('App config fetched', config);\n  if (config.dapps) {\n    const oldDapps = DAPPS.splice(0);\n    for (const dapp of config.dapps) {\n      const oldDapp = oldDapps.find((d) => d.id === dapp.id);\n      if (oldDapp) {\n        DAPPS.push(Object.assign({}, oldDapp, dapp));\n      } else {\n        DAPPS.push(dapp);\n      }\n    }\n    logger.log('Dapps updated', DAPPS);\n    await resolveAllDapps();\n  }\n}\n\nconst dappsUpdater = setInterval(updateConfig, 600_000); // 10 minutes\napp.on('will-quit', () => clearInterval(dappsUpdater));", "      if (oldDapp) {\n        DAPPS.push(Object.assign({}, oldDapp, dapp));\n      } else {\n        DAPPS.push(dapp);\n      }\n    }\n    logger.log('Dapps updated', DAPPS);\n    await resolveAllDapps();\n  }\n}\n\nconst dappsUpdater = setInterval(updateConfig, 600_000); // 10 minutes\napp.on('will-quit', () => clearInterval(dappsUpdater));", "waitForIpfs().then(updateConfig).catch(logger.error);\n\nipcMain.handle('peers', async () => fetchPeers());\n\nhttp\n  .createServer((req, res) => {\n    const id = `${req.headers.host}`.replace('.localhost:8888', '');\n    const dapp = DAPPS.find((dapp) => dapp.id === id);\n    if (dapp && dapp.url) {\n      req.headers.host = dapp.url;\n      proxy({ host: '127.0.0.1', port: 8080 }, req, res);\n      return;\n    }\n    res.writeHead(404);\n    res.end('Not found');\n  })\n  .listen(8888, '0.0.0.0');\n", "    if (dapp && dapp.url) {\n      req.headers.host = dapp.url;\n      proxy({ host: '127.0.0.1', port: 8080 }, req, res);\n      return;\n    }\n    res.writeHead(404);\n    res.end('Not found');\n  })\n  .listen(8888, '0.0.0.0');\n"]}
{"filename": "src/main/ipfs.ts", "chunked_list": ["import { exec, spawn } from 'child_process';\nimport https from 'https';\nimport {\n  createReadStream,\n  createWriteStream,\n  promises as fs,\n  rmSync,\n} from 'fs';\nimport { pipeline } from 'stream/promises';\nimport os from 'os';", "import { pipeline } from 'stream/promises';\nimport os from 'os';\nimport zlib from 'zlib';\nimport tar from 'tar';\nimport http from 'http';\nimport path from 'path';\nimport type { IpcMainInvokeEvent } from 'electron';\nimport { getPid, getPidsSync } from './pid';\nimport { ROOT } from './settings';\nimport logger from 'electron-log';", "import { ROOT } from './settings';\nimport logger from 'electron-log';\n\nconst HOME = os.homedir();\n// Change if we ever want IPFS to store its data in non-standart path\nconst IPFS_PATH = path.join(HOME, '.ipfs');\n\nexport function ipfsKill() {\n  try {\n    getPidsSync('.synthetix/go-ipfs/ipfs').forEach((pid) => {\n      logger.log('Killing ipfs', pid);\n      process.kill(pid);\n    });\n    logger.log('Removing .ipfs/repo.lock');\n    rmSync(path.join(IPFS_PATH, 'repo.lock'), { recursive: true });", "  try {\n    getPidsSync('.synthetix/go-ipfs/ipfs').forEach((pid) => {\n      logger.log('Killing ipfs', pid);\n      process.kill(pid);\n    });\n    logger.log('Removing .ipfs/repo.lock');\n    rmSync(path.join(IPFS_PATH, 'repo.lock'), { recursive: true });\n  } catch (_e) {\n    // whatever\n  }\n}\n", "export async function ipfsPid() {\n  return await getPid('.synthetix/go-ipfs/ipfs daemon');\n}\n\nexport async function ipfsIsInstalled() {\n  try {\n    await fs.access(path.join(ROOT, 'go-ipfs/ipfs'), fs.constants.F_OK);\n    return true;\n  } catch (_e) {\n    return false;\n  }\n}\n", "  } catch (_e) {\n    return false;\n  }\n}\n\nexport async function ipfsDaemon() {\n  const isInstalled = await ipfsIsInstalled();\n  if (!isInstalled) {\n    return;\n  }\n  const pid = await getPid('.synthetix/go-ipfs/ipfs daemon');", "  if (!pid) {\n    await configureIpfs();\n    spawn(path.join(ROOT, 'go-ipfs/ipfs'), ['daemon'], {\n      stdio: 'inherit',\n      detached: true,\n      env: { IPFS_PATH },\n    });\n  }\n}\n\nexport async function ipfs(arg: string): Promise<string> {\n  return new Promise((resolve, reject) => {\n    exec(\n      `${path.join(ROOT, 'go-ipfs/ipfs')} ${arg}`,\n      { encoding: 'utf8', env: { IPFS_PATH } },\n      (error, stdout, stderr) => {", "export async function ipfs(arg: string): Promise<string> {\n  return new Promise((resolve, reject) => {\n    exec(\n      `${path.join(ROOT, 'go-ipfs/ipfs')} ${arg}`,\n      { encoding: 'utf8', env: { IPFS_PATH } },\n      (error, stdout, stderr) => {\n        if (error) {\n          error.message = `${error.message} (${stderr})`;\n          reject(error);\n        } else {\n          resolve(stdout.trim());\n        }\n      }\n    );\n  });\n}\n", "export async function getLatestVersion(): Promise<string> {\n  return new Promise((resolve, reject) => {\n    https\n      .get('https://dist.ipfs.tech/go-ipfs/versions', (res) => {\n        let data = '';\n        res.on('data', (chunk) => {\n          data += chunk;\n        });\n        res.on('end', () => {\n          resolve(data.trim().split('\\n').pop() || '');\n        });\n      })\n      .on('error', (err) => {\n        reject(err);\n      });\n  });\n}\n", "export async function getInstalledVersion() {\n  try {\n    const ipfsVersion = await ipfs('--version');\n    const [, , installedVersion] = ipfsVersion.split(' ');\n    return installedVersion;\n  } catch (_error) {\n    return null;\n  }\n}\n\nexport async function downloadIpfs(\n  _e?: IpcMainInvokeEvent,\n  { log = logger.log } = {}\n) {\n  const arch = os.arch();\n  const targetArch = arch === 'x64' ? 'amd64' : 'arm64';\n\n  log('Checking for existing ipfs installation...');\n\n  const latestVersion = await getLatestVersion();\n  const latestVersionNumber = latestVersion.slice(1);\n  const installedVersion = await getInstalledVersion();\n", "export async function downloadIpfs(\n  _e?: IpcMainInvokeEvent,\n  { log = logger.log } = {}\n) {\n  const arch = os.arch();\n  const targetArch = arch === 'x64' ? 'amd64' : 'arm64';\n\n  log('Checking for existing ipfs installation...');\n\n  const latestVersion = await getLatestVersion();\n  const latestVersionNumber = latestVersion.slice(1);\n  const installedVersion = await getInstalledVersion();\n", "  if (installedVersion === latestVersionNumber) {\n    log(`ipfs version ${installedVersion} is already installed.`);\n    return;\n  }\n\n  if (installedVersion) {\n    log(\n      `Updating ipfs from version ${installedVersion} to ${latestVersionNumber}`\n    );\n  } else {\n    log(`Installing ipfs version ${latestVersionNumber}`);\n  }\n\n  const downloadUrl = `https://dist.ipfs.tech/go-ipfs/${latestVersion}/go-ipfs_${latestVersion}_darwin-${targetArch}.tar.gz`;\n  log(`IPFS package: ${downloadUrl}`);\n\n  await fs.rm(path.join(IPFS_PATH, 'config'), { recursive: true });\n  await fs.mkdir(ROOT, { recursive: true });\n  await new Promise((resolve, reject) => {\n    const file = createWriteStream(path.join(ROOT, 'ipfs.tar.gz'));\n    https.get(downloadUrl, (response) =>", "      pipeline(response, file).then(resolve).catch(reject)\n    );\n  });\n\n  await new Promise((resolve, reject) => {\n    createReadStream(path.join(ROOT, 'ipfs.tar.gz'))\n      .pipe(zlib.createGunzip())\n      .pipe(tar.extract({ cwd: ROOT }))\n      .on('error', reject)\n      .on('end', resolve);\n  });\n\n  const installedVersionCheck = await getInstalledVersion();", "  if (installedVersionCheck) {\n    log(`ipfs version ${installedVersionCheck} installed successfully.`);\n  } else {\n    throw new Error('IPFS installation failed.');\n  }\n\n  return installedVersionCheck;\n}\n\nexport async function configureIpfs({ log = logger.log } = {}) {\n  try {\n    log(await ipfs('init'));\n    log(\n      await ipfs(\n        'config --json API.HTTPHeaders.Access-Control-Allow-Origin \\'[\"*\"]\\''\n      )\n    );\n    log(\n      await ipfs(\n        'config --json API.HTTPHeaders.Access-Control-Allow-Methods \\'[\"PUT\", \"POST\", \"GET\"]\\''\n      )\n    );\n    // log(await ipfs('config profile apply lowpower'));", "export async function configureIpfs({ log = logger.log } = {}) {\n  try {\n    log(await ipfs('init'));\n    log(\n      await ipfs(\n        'config --json API.HTTPHeaders.Access-Control-Allow-Origin \\'[\"*\"]\\''\n      )\n    );\n    log(\n      await ipfs(\n        'config --json API.HTTPHeaders.Access-Control-Allow-Methods \\'[\"PUT\", \"POST\", \"GET\"]\\''\n      )\n    );\n    // log(await ipfs('config profile apply lowpower'));", "  } catch (_error) {\n    // whatever\n  }\n}\n\nexport async function ipfsIsRunning() {\n  return new Promise((resolve, _reject) => {\n    http\n      .get('http://127.0.0.1:5001', (res) => {\n        const { statusCode } = res;\n        if (statusCode === 404) {\n          resolve(true);\n        } else {\n          resolve(false);\n        }\n        res.resume();\n      })\n      .once('error', (_error) => resolve(false));\n  });\n}\n", "        if (statusCode === 404) {\n          resolve(true);\n        } else {\n          resolve(false);\n        }\n        res.resume();\n      })\n      .once('error', (_error) => resolve(false));\n  });\n}\n", "export async function waitForIpfs() {\n  let isRunning = await ipfsIsRunning();\n  while (!isRunning) {\n    await new Promise((resolve) => setTimeout(resolve, 1000));\n    isRunning = await ipfsIsRunning();\n  }\n}\n"]}
{"filename": "src/main/proxy.ts", "chunked_list": ["import http, { IncomingMessage, ServerResponse } from 'http';\nimport logger from 'electron-log';\n\nexport function proxy(\n  upstream: {\n    host: string;\n    port: number;\n  },\n  req: IncomingMessage,\n  res: ServerResponse\n) {\n  const options = {\n    hostname: upstream.host,\n    port: upstream.port,\n    path: req.url,\n    method: req.method,\n    headers: req.headers,\n  };\n\n  const proxyReq = http.request(options, (proxyRes: IncomingMessage) => {\n    res.writeHead(proxyRes.statusCode!, proxyRes.headers);\n    proxyRes.pipe(res, { end: true });\n  });\n\n  req.pipe(proxyReq, { end: true });\n\n  proxyReq.once('error', (err) => {\n    logger.error(`Error in proxy request: ${err.message}`);\n    res.writeHead(500, { 'Content-Type': 'text/plain' });\n    res.end('Error occurred while processing the request.');\n  });\n}\n"]}
{"filename": "src/main/peers.ts", "chunked_list": ["import logger from 'electron-log';\nimport fetch from 'node-fetch';\n\nObject.assign(global, { fetch });\n\nexport type Peer = {\n  id: string;\n  version: string;\n};\n\nexport async function fetchPeers(): Promise<Peer[]> {", "export async function fetchPeers(): Promise<Peer[]> {\n  try {\n    const response = await fetch('https://ipfs.synthetix.io/dash/api');\n    if (response.ok) {\n      const state = (await response.json()) as { peers: Peer[] };\n      return state.peers.sort((a, b) => a.id.localeCompare(b.id));\n    }\n    return [];\n  } catch (e) {\n    logger.error(e);\n    return [];\n  }\n}\n", "  } catch (e) {\n    logger.error(e);\n    return [];\n  }\n}\n"]}
{"filename": "src/main/follower.ts", "chunked_list": ["import { exec, spawn } from 'child_process';\nimport https from 'https';\nimport { createReadStream, createWriteStream, promises as fs } from 'fs';\nimport { pipeline } from 'stream/promises';\nimport os from 'os';\nimport zlib from 'zlib';\nimport tar from 'tar';\nimport path from 'path';\nimport type { IpcMainInvokeEvent } from 'electron';\nimport logger from 'electron-log';", "import type { IpcMainInvokeEvent } from 'electron';\nimport logger from 'electron-log';\nimport { SYNTHETIX_IPNS } from '../const';\nimport { ROOT } from './settings';\nimport { getPid, getPidsSync } from './pid';\n\n// Change if we ever want to store all follower info in a custom folder\nconst HOME = os.homedir();\nconst IPFS_FOLLOW_PATH = path.join(HOME, '.ipfs-cluster-follow');\n\nexport function followerKill() {", "const IPFS_FOLLOW_PATH = path.join(HOME, '.ipfs-cluster-follow');\n\nexport function followerKill() {\n  try {\n    getPidsSync('.synthetix/ipfs-cluster-follow/ipfs-cluster-follow').forEach(\n      (pid) => {\n        logger.log('Killing ipfs-cluster-follow', pid);\n        process.kill(pid);\n      }\n    );\n  } catch (_e) {\n    // whatever\n  }\n}\n", "  } catch (_e) {\n    // whatever\n  }\n}\n\nexport async function followerPid() {\n  return await getPid(\n    '.synthetix/ipfs-cluster-follow/ipfs-cluster-follow synthetix run'\n  );\n}\n", "export async function followerIsInstalled() {\n  try {\n    await fs.access(\n      path.join(ROOT, 'ipfs-cluster-follow/ipfs-cluster-follow'),\n      fs.constants.F_OK\n    );\n    return true;\n  } catch (_e) {\n    return false;\n  }\n}\n", "export async function followerDaemon() {\n  const isInstalled = await followerIsInstalled();\n  if (!isInstalled) {\n    return;\n  }\n  const pid = await getPid(\n    '.synthetix/ipfs-cluster-follow/ipfs-cluster-follow synthetix run'\n  );\n  if (!pid) {\n    await configureFollower();\n", "  if (!pid) {\n    await configureFollower();\n\n    try {\n      // Cleanup locks in case of a previous crash\n      await Promise.all([\n        fs.rm(path.join(IPFS_FOLLOW_PATH, 'synthetix/badger'), {\n          recursive: true,\n          force: true,\n        }),\n        fs.rm(path.join(IPFS_FOLLOW_PATH, 'synthetix/api-socket'), {\n          recursive: true,\n          force: true,\n        }),\n      ]);", "    } catch (e) {\n      logger.error(e);\n      // whatever\n    }\n\n    spawn(\n      path.join(ROOT, 'ipfs-cluster-follow/ipfs-cluster-follow'),\n      ['synthetix', 'run'],\n      {\n        stdio: 'inherit',\n        detached: true,\n        env: { HOME },\n      }\n    );\n  }\n}\n", "export async function follower(arg: string): Promise<string> {\n  return new Promise((resolve, reject) => {\n    exec(\n      `${path.join(ROOT, 'ipfs-cluster-follow/ipfs-cluster-follow')} ${arg}`,\n      { encoding: 'utf8', env: { HOME } },\n      (error, stdout, stderr) => {\n        if (error) {\n          error.message = `${error.message} (${stderr})`;\n          reject(error);\n        } else {\n          resolve(stdout.trim());\n        }\n      }\n    );\n  });\n}\n", "export async function getLatestVersion(): Promise<string> {\n  return new Promise((resolve, reject) => {\n    https\n      .get('https://dist.ipfs.tech/ipfs-cluster-follow/versions', (res) => {\n        let data = '';\n        res.on('data', (chunk) => {\n          data += chunk;\n        });\n        res.on('end', () => {\n          resolve(data.trim().split('\\n').pop() || '');\n        });\n      })\n      .on('error', (err) => {\n        reject(err);\n      });\n  });\n}\n", "export async function getInstalledVersion() {\n  try {\n    const version = await follower('--version');\n    const [, , installedVersion] = version.split(' ');\n    return installedVersion;\n  } catch (_error) {\n    return null;\n  }\n}\n\nexport async function downloadFollower(\n  _e?: IpcMainInvokeEvent,\n  { log = logger.log } = {}\n) {\n  const arch = os.arch();\n  const targetArch = arch === 'x64' ? 'amd64' : 'arm64';\n\n  log('Checking for existing ipfs-cluster-follow installation...');\n\n  const latestVersion = await getLatestVersion();\n  const latestVersionNumber = latestVersion.slice(1);\n  const installedVersion = await getInstalledVersion();\n", "export async function downloadFollower(\n  _e?: IpcMainInvokeEvent,\n  { log = logger.log } = {}\n) {\n  const arch = os.arch();\n  const targetArch = arch === 'x64' ? 'amd64' : 'arm64';\n\n  log('Checking for existing ipfs-cluster-follow installation...');\n\n  const latestVersion = await getLatestVersion();\n  const latestVersionNumber = latestVersion.slice(1);\n  const installedVersion = await getInstalledVersion();\n", "  if (installedVersion === latestVersionNumber) {\n    log(\n      `ipfs-cluster-follow version ${installedVersion} is already installed.`\n    );\n    return;\n  }\n\n  if (installedVersion) {\n    log(\n      `Updating ipfs-cluster-follow from version ${installedVersion} to ${latestVersionNumber}`\n    );\n  } else {\n    log(`Installing ipfs-cluster-follow version ${latestVersionNumber}`);\n  }\n\n  const downloadUrl = `https://dist.ipfs.tech/ipfs-cluster-follow/${latestVersion}/ipfs-cluster-follow_${latestVersion}_darwin-${targetArch}.tar.gz`;\n  log(`ipfs-cluster-follow package: ${downloadUrl}`);\n\n  await fs.mkdir(ROOT, { recursive: true });\n  await new Promise((resolve, reject) => {\n    const file = createWriteStream(\n      path.join(ROOT, 'ipfs-cluster-follow.tar.gz')\n    );\n    https.get(downloadUrl, (response) =>", "      pipeline(response, file).then(resolve).catch(reject)\n    );\n  });\n\n  await new Promise((resolve, reject) => {\n    createReadStream(path.join(ROOT, 'ipfs-cluster-follow.tar.gz'))\n      .pipe(zlib.createGunzip())\n      .pipe(tar.extract({ cwd: ROOT }))\n      .on('error', reject)\n      .on('end', resolve);\n  });\n\n  const installedVersionCheck = await getInstalledVersion();", "  if (installedVersionCheck) {\n    log(\n      `ipfs-cluster-follow version ${installedVersionCheck} installed successfully.`\n    );\n  } else {\n    throw new Error('ipfs-cluster-follow installation failed.');\n  }\n\n  return installedVersionCheck;\n}\n", "export async function isConfigured() {\n  try {\n    const service = await fs.readFile(\n      path.join(IPFS_FOLLOW_PATH, 'synthetix/service.json'),\n      'utf8'\n    );\n    return service.includes(SYNTHETIX_IPNS);\n  } catch (_error) {\n    return false;\n  }\n}\n", "export async function followerId() {\n  try {\n    const identity = JSON.parse(\n      await fs.readFile(\n        path.join(IPFS_FOLLOW_PATH, 'synthetix/identity.json'),\n        'utf8'\n      )\n    );\n    return identity.id;\n  } catch (_error) {\n    return '';\n  }\n}\n", "  } catch (_error) {\n    return '';\n  }\n}\n\nexport async function configureFollower({ log = logger.log } = {}) {\n  if (await isConfigured()) {\n    return;\n  }\n  try {\n    log(\n      await follower(\n        `synthetix init \"http://127.0.0.1:8080/ipns/${SYNTHETIX_IPNS}\"`\n      )\n    );", "  try {\n    log(\n      await follower(\n        `synthetix init \"http://127.0.0.1:8080/ipns/${SYNTHETIX_IPNS}\"`\n      )\n    );\n  } catch (_error) {\n    // ignore\n  }\n}\n"]}
{"filename": "src/main/pid.ts", "chunked_list": ["import { exec, execSync } from 'child_process';\n\nexport function extractPids(processes: string): number[] {\n  return processes\n    .trim()\n    .split('\\n')\n    .filter((line) => !line.includes('grep'))\n    .map((line) => {\n      const [raw] = line.trim().split(' ');\n      return parseInt(raw, 10);\n    });\n}\n", "export function findPid(processes: string): number | undefined {\n  const [ipfsProcess] = extractPids(processes);\n  return ipfsProcess;\n}\n\nexport function getPidSync(search: string): number | undefined {\n  try {\n    const processes = execSync(`ps -ax | grep \"${search}\"`, {\n      encoding: 'utf8',\n    });\n    return findPid(processes);", "  } catch (_e) {\n    // whatever\n  }\n}\n\nexport function getPidsSync(search: string): number[] {\n  try {\n    const processes = execSync(`ps -ax | grep '${search}'`, {\n      encoding: 'utf8',\n    });\n    return extractPids(processes);", "  } catch (_e) {\n    return [];\n  }\n}\n\nfunction execCommand(command: string): Promise<string> {\n  return new Promise((resolve, reject) => {\n    exec(command, { encoding: 'utf8' }, (error, stdout, stderr) => {\n      if (error) {\n        error.message = `${error.message} (${stderr})`;\n        reject(error);\n      } else {\n        resolve(stdout.trim());\n      }\n    });\n  });\n}\n", "      if (error) {\n        error.message = `${error.message} (${stderr})`;\n        reject(error);\n      } else {\n        resolve(stdout.trim());\n      }\n    });\n  });\n}\n\nexport async function getPid(search: string): Promise<number | undefined> {", "export async function getPid(search: string): Promise<number | undefined> {\n  try {\n    const processes = await execCommand(`ps -ax | grep '${search}'`);\n    return findPid(processes);\n  } catch (_e) {\n    // whatever\n  }\n}\n"]}
{"filename": "src/main/util.ts", "chunked_list": ["import { URL } from 'url';\nimport path from 'path';\n\nexport function resolveHtmlPath(htmlFileName: string) {\n  if (process.env.NODE_ENV === 'development') {\n    const port = process.env.PORT || 1212;\n    const url = new URL(`http://localhost:${port}`);\n    url.pathname = htmlFileName;\n    return url.href;\n  }\n  return `file://${path.resolve(__dirname, '../renderer/', htmlFileName)}`;\n}\n"]}
{"filename": "src/main/preload.ts", "chunked_list": ["// Disable no-unused-vars, broken for spread args\nimport type { IpcRendererEvent } from 'electron';\n/* eslint no-unused-vars: off */\nimport { contextBridge, ipcRenderer } from 'electron';\n\nconst electronHandler = {\n  ipcRenderer: {\n    invoke: (func: string, ...args: any[]) => ipcRenderer.invoke(func, ...args),\n    send: (channel: string, ...args: any[]) => {\n      ipcRenderer.send(channel, ...args);", "    send: (channel: string, ...args: any[]) => {\n      ipcRenderer.send(channel, ...args);\n    },\n    on: (\n      channel: string,\n      listener: (event: IpcRendererEvent, ...args: any[]) => void\n    ) => {\n      ipcRenderer.on(channel, listener);\n    },\n    removeListener: (", "    },\n    removeListener: (\n      channel: string,\n      listener: (event: IpcRendererEvent, ...args: any[]) => void\n    ) => {\n      ipcRenderer.removeListener(channel, listener);\n    },\n  },\n};\n", "};\n\ncontextBridge.exposeInMainWorld('electron', electronHandler);\n\nexport type ElectronHandler = typeof electronHandler;\n"]}
{"filename": "src/main/settings.ts", "chunked_list": ["import { promises as fs } from 'fs';\nimport os from 'os';\nimport path from 'path';\n\nexport const ROOT = path.join(os.homedir(), '.synthetix');\nconst DEFAULTS = Object.freeze({\n  tray: true,\n  dock: true,\n});\n\nexport async function read() {", "});\n\nexport async function read() {\n  try {\n    return JSON.parse(\n      await fs.readFile(path.join(ROOT, 'setting.json'), 'utf8')\n    );\n  } catch (_error) {\n    return DEFAULTS;\n  }\n}\n", "export async function write(settings: typeof DEFAULTS) {\n  try {\n    await fs.writeFile(\n      path.join(ROOT, 'setting.json'),\n      JSON.stringify(settings, null, 2),\n      'utf8'\n    );\n  } catch (_error) {\n    // whatever\n  }\n  return settings;\n}\n", "export async function get(key: string) {\n  const all = await read();\n  return all[key];\n}\n\nexport async function set(key: string, value: boolean) {\n  const all = await read();\n  return await write({ ...all, [key]: value });\n}\n"]}
