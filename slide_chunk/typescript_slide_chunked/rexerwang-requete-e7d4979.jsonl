{"filename": "vitest.config.ts", "chunked_list": ["import { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    globals: true,\n    setupFiles: ['./test/setup'],\n    alias: {\n      'requete/shared': './src/shared.ts',\n      'requete/adapter': './src/adapter.ts',\n      'requete/middleware': './src/middleware.ts',", "      'requete/adapter': './src/adapter.ts',\n      'requete/middleware': './src/middleware.ts',\n      requete: './src/index.ts',\n    },\n  },\n})\n"]}
{"filename": "test/setup.ts", "chunked_list": ["import { vi } from 'vitest'\n\n// @ts-ignore\nglobal.XMLHttpRequest = vi.fn()\n"]}
{"filename": "test/utils.ts", "chunked_list": ["export function toAny(v: any) {\n  return v as any\n}\n\nexport function sleep(ms: number) {\n  return new Promise((r) => setTimeout(r, ms))\n}\n"]}
{"filename": "src/shared.ts", "chunked_list": ["export * from './shared/headers'\nexport * from './shared/logger'\nexport * from './shared/pick'\nexport * from './shared/progress'\nexport * from './shared/RequestError'\nexport * from './shared/transform'\nexport * from './shared/url'\n"]}
{"filename": "src/index.ts", "chunked_list": ["import { create } from './core/create'\n\nexport default create()\n\nexport * from './core/AbortController'\nexport * from './core/create'\nexport * from './core/Requete'\nexport { FetchAdapter, XhrAdapter } from 'requete/adapter'\nexport { RequestError } from 'requete/shared'\n", "export { RequestError } from 'requete/shared'\n"]}
{"filename": "src/middleware.ts", "chunked_list": ["export * from './middleware/timestamp'\n"]}
{"filename": "src/adapter.ts", "chunked_list": ["export * from './adapter/Adapter'\nexport * from './adapter/create'\nexport * from './adapter/FetchAdapter'\nexport * from './adapter/XhrAdapter'\n"]}
{"filename": "src/shared/url.ts", "chunked_list": ["import type { IRequest, RequestQuery } from 'requete'\n\nexport function stringifyUrl(url: string, query: RequestQuery, append = true) {\n  let searchParams: URLSearchParams\n\n  if (query instanceof URLSearchParams) {\n    searchParams = query\n  } else if (typeof query === 'string' || Array.isArray(query)) {\n    searchParams = new URLSearchParams(query)\n  } else {\n    searchParams = new URLSearchParams()\n    Object.entries(query).forEach(([key, value]) => {", "      if (Array.isArray(value)) {\n        value.forEach((val) => searchParams.append(key, val.toString()))\n      } else if (value != null) {\n        searchParams.set(key, value.toString())\n      }\n    })\n  }\n\n  const qIndex = url.indexOf('?')\n\n  if (qIndex === -1) return url + '?' + searchParams.toString()", "  if (qIndex === -1) return url + '?' + searchParams.toString()\n  if (append) return url + '&' + searchParams.toString()\n  else {\n    const params = new URLSearchParams(url.slice(qIndex))\n    searchParams.forEach((value, key) => params.set(key, value.toString()))\n    return url.slice(0, qIndex) + '?' + params.toString()\n  }\n}\n\nfunction isAbsolute(url: string) {\n  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url)\n}\n", "function isAbsolute(url: string) {\n  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url)\n}\n\nexport function getUri(config: IRequest) {\n  let url = config.url\n\n  const hashIndex = url.indexOf('#')\n  if (hashIndex > -1) url = url.slice(0, hashIndex)\n\n  if (!isAbsolute(url) && config.baseURL) {\n    url = config.baseURL.replace(/\\/+$/, '') + '/' + url.replace(/^\\/+/, '')\n  }\n", "  if (hashIndex > -1) url = url.slice(0, hashIndex)\n\n  if (!isAbsolute(url) && config.baseURL) {\n    url = config.baseURL.replace(/\\/+$/, '') + '/' + url.replace(/^\\/+/, '')\n  }\n\n  if (config.params) {\n    url = stringifyUrl(url, config.params)\n  }\n\n  return url\n}\n"]}
{"filename": "src/shared/transform.ts", "chunked_list": ["import type { RequestBody } from 'requete'\n\nexport function transformRequestBody(data?: RequestBody) {\n  const toString = Object.prototype.toString.call(data)\n\n  let requestBody: any = data\n  let contentType = ''\n\n  switch (toString) {\n    case '[object Undefined]':\n    case '[object Null]':\n      break\n    case '[object String]':\n    case '[object URLSearchParams]':\n      contentType = 'application/x-www-form-urlencoded;charset=utf-8'\n      break\n    case '[object FormData]':\n    case '[object Blob]':\n    case '[object ReadableStream]':\n    case '[object ArrayBuffer]':\n    case '[object DataView]':\n    case '[object BigInt64Array]':\n    case '[object BigUint64Array]':\n    case '[object Float32Array]':\n    case '[object Float64Array]':\n    case '[object Int8Array]':\n    case '[object Int16Array]':\n    case '[object Int32Array]':\n    case '[object Uint8Array]':\n    case '[object Uint8ClampedArray]':\n    case '[object Uint16Array]':\n    case '[object Uint32Array]':\n      contentType = 'multipart/form-data;charset=utf-8'\n      break\n    case '[object Object]':\n    case '[object Array]':\n      requestBody = JSON.stringify(data)\n      contentType = 'application/json;charset=utf-8'\n      break\n    default:\n      throw new TypeError('Invalid request body type: ' + toString)\n  }\n\n  return { requestBody, contentType }\n}\n"]}
{"filename": "src/shared/progress.ts", "chunked_list": ["import type { IProgressEvent } from 'requete/adapter'\n\n/**\n * Calculate data maxRate\n *\n * Forked: https://github.com/axios/axios/blob/6f360a2531d8d70363fd9becef6a45a323f170e2/lib/helpers/speedometer.js\n */\nfunction speedometer(samplesCount = 10, min = 1000) {\n  const bytes = new Array(samplesCount)\n  const timestamps = new Array(samplesCount)\n  let head = 0\n  let tail = 0\n  let firstSampleTS: number\n", "  return function push(chunkLength: number) {\n    const now = Date.now()\n\n    const startedAt = timestamps[tail]\n\n    if (!firstSampleTS) {\n      firstSampleTS = now\n    }\n\n    bytes[head] = chunkLength\n    timestamps[head] = now\n\n    let i = tail\n    let bytesCount = 0\n", "    while (i !== head) {\n      bytesCount += bytes[i++]\n      i = i % samplesCount\n    }\n\n    head = (head + 1) % samplesCount\n\n    if (head === tail) {\n      tail = (tail + 1) % samplesCount\n    }\n", "    if (now - firstSampleTS < min) {\n      return\n    }\n\n    const passed = startedAt && now - startedAt\n\n    return passed ? Math.round((bytesCount * 1000) / passed) : undefined\n  }\n}\n\n/**\n * Forked: https://github.com/axios/axios/blob/6f360a2531d8d70363fd9becef6a45a323f170e2/lib/adapters/xhr.js#L17\n */", "export function progressEventReducer(\n  listener: (e: IProgressEvent) => void,\n  isDownload?: boolean\n) {\n  let bytesNotified = 0\n  const _speedometer = speedometer(50, 250)\n\n  return (e: any) => {\n    const loaded = e.loaded\n    const total = e.lengthComputable ? e.total : undefined\n    const progressBytes = loaded - bytesNotified\n    const rate = _speedometer(progressBytes)\n    const inRange = loaded <= total\n\n    bytesNotified = loaded\n\n    listener({\n      download: !!isDownload,\n      upload: !isDownload,\n      loaded,\n      total,\n      progress: total ? loaded / total : undefined,\n      bytes: progressBytes,\n      rate: rate ? rate : undefined,\n      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,\n      event: e,\n    })\n  }\n}\n"]}
{"filename": "src/shared/logger.ts", "chunked_list": ["import type { IContext } from 'requete'\n\nimport { RequestError } from './RequestError'\n\nexport class Logger {\n  constructor(private name: string, private level: number) {\n    this.name = name && `[${name}]`\n  }\n\n  res(ctx: IContext) {\n    const headers = (headers?: Headers) => {", "      if (headers) {\n        const obj: any = {}\n        headers.forEach((value, key) => {\n          obj[key] = value\n        })\n        return obj\n      }\n    }\n\n    return {\n      request: {\n        data: ctx.request.data,\n        params: ctx.request.params,\n        headers: headers(ctx.request.headers),\n      },\n      response: {\n        data: ctx.data,\n        headers: headers(ctx.headers),\n        responseText: ctx.responseText,\n      },\n    }\n  }\n\n  info(...message: any[]) {", "    if (this.level < 2) return\n\n    console.log(this.name, ...message)\n  }\n\n  error(e: Error | string) {\n    if (this.level < 1) return\n    if (!(e instanceof RequestError)) return console.error(e)\n\n    const { ctx } = e as RequestError\n    const { request, url, status, statusText } = ctx\n\n    console.error(\n      `${this.name} ${request.method} ${url} ${status} (${\n        status === -1 ? 'Before Request' : statusText\n      })\\n%o\\n${e.stack}`,\n      this.res(ctx)\n    )\n  }\n\n  request(ctx: IContext) {\n    this.info(`${ctx.request.method} ${ctx.url}`, this.res(ctx).request)\n  }\n\n  response(ctx: IContext) {\n    this.info(\n      `${ctx.request.method} ${ctx.url} ${ctx.status} (${ctx.statusText})`,\n      this.res(ctx).response\n    )\n  }\n}\n"]}
{"filename": "src/shared/pick.ts", "chunked_list": ["export function pick<T extends object, K extends keyof T>(\n  object: T,\n  keys: K[]\n): Pick<T, K> {\n  const partial: any = {}\n  keys.forEach((key) => {\n    partial[key] = object[key]\n  })\n\n  return partial\n}\n"]}
{"filename": "src/shared/headers.ts", "chunked_list": ["export function mergeHeaders(...headers: (HeadersInit | undefined)[]) {\n  return headers.filter(Boolean).reduce((res: Headers, header) => {\n    new Headers(header).forEach((value, key) => res.set(key, value))\n    return res\n  }, new Headers())\n}\n\nexport function parseHeaders(rawText?: string) {\n  const headers = new Headers()\n  if (!rawText) return headers\n\n  rawText\n    .trim()\n    .split(/[\\r\\n]+/)\n    .forEach((header) => {\n      const [key, value] = header.split(': ').map((s) => s.trim())\n      headers.append(key, value)\n    })\n\n  return headers\n}\n", "  if (!rawText) return headers\n\n  rawText\n    .trim()\n    .split(/[\\r\\n]+/)\n    .forEach((header) => {\n      const [key, value] = header.split(': ').map((s) => s.trim())\n      headers.append(key, value)\n    })\n\n  return headers\n}\n"]}
{"filename": "src/shared/RequestError.ts", "chunked_list": ["import type { IContext } from 'requete'\n\nexport class RequestError extends Error {\n  name = 'RequestError'\n\n  ctx: IContext\n\n  constructor(errMsg: string | Error, ctx: IContext) {\n    const isError = typeof errMsg !== 'string'\n\n    super(isError ? errMsg.message : errMsg)\n", "    if (isError) {\n      this.stack = errMsg.stack\n      this.cause = errMsg.cause\n    }\n\n    this.ctx = ctx\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Error'\n  }\n}\n"]}
{"filename": "src/shared/__tests__/headers.test.ts", "chunked_list": ["import { mergeHeaders, parseHeaders } from '../headers'\n\ndescribe('headers specs', () => {\n  it('mergeHeaders', () => {\n    expect(\n      mergeHeaders(\n        {\n          'content-type': 'text/html; charset=utf-8',\n          'content-length': '1024',\n        },", "          'content-length': '1024',\n        },\n        undefined,\n        {\n          'x-xss-protection': '1; mode=block',\n          'content-type': 'application/json',\n        }\n      )\n    ).toEqual(\n      new Headers({", "    ).toEqual(\n      new Headers({\n        'x-xss-protection': '1; mode=block',\n        'content-type': 'application/json',\n        'content-length': '1024',\n      })\n    )\n  })\n\n  it('parseHeaders', () => {", "\n  it('parseHeaders', () => {\n    const rawHeader = `x-frame-options: DENY\\r\\n\n      content-type: text/html; charset=utf-8\\r\\n\n      content-length: 1024\\r\\n\n      x-xss-protection: 1; mode=block\\r\\n`\n\n    expect(parseHeaders(rawHeader)).toEqual(\n      new Headers({\n        'x-frame-options': 'DENY',", "      new Headers({\n        'x-frame-options': 'DENY',\n        'content-type': 'text/html; charset=utf-8',\n        'content-length': '1024',\n        'x-xss-protection': '1; mode=block',\n      })\n    )\n  })\n})\n", "})\n"]}
{"filename": "src/shared/__tests__/logger.test.ts", "chunked_list": ["import { toAny } from 'test/utils'\n\nimport { Logger } from '../logger'\nimport { RequestError } from '../RequestError'\n\ndescribe('Logger specs', () => {\n  const logSpy = vi.spyOn(console, 'log').mockImplementation(toAny(vi.fn()))\n  const errorSpy = vi.spyOn(console, 'error').mockImplementation(toAny(vi.fn()))\n\n  beforeEach(() => {", "\n  beforeEach(() => {\n    logSpy.mockClear()\n    errorSpy.mockClear()\n  })\n\n  it('should output both info & error log when given level == 2', () => {\n    const logger = new Logger('logger', 2)\n\n    logger.info('info')", "\n    logger.info('info')\n    logger.error('error')\n\n    expect(logSpy).toBeCalled()\n    expect(errorSpy).toBeCalled()\n  })\n\n  it('should output only error log when given level == 1', () => {\n    const logger = new Logger('logger', 1)", "  it('should output only error log when given level == 1', () => {\n    const logger = new Logger('logger', 1)\n\n    logger.info('info')\n    logger.error('error')\n\n    expect(logSpy).not.toBeCalled()\n    expect(errorSpy).toBeCalled()\n  })\n", "  })\n\n  it('should not output when given level == 0', () => {\n    const logger = new Logger('logger', 0)\n\n    logger.info('info')\n    logger.error('error')\n\n    expect(logSpy).not.toBeCalled()\n    expect(errorSpy).not.toBeCalled()", "    expect(logSpy).not.toBeCalled()\n    expect(errorSpy).not.toBeCalled()\n  })\n\n  it('should output info log with formatted message', () => {\n    const logger = new Logger('logger', 2)\n\n    logger.info('info')\n\n    expect(logSpy).toBeCalledWith('[logger]', 'info')", "\n    expect(logSpy).toBeCalledWith('[logger]', 'info')\n  })\n\n  it('should output request log with formatted message', () => {\n    const logger = new Logger('logger', 2)\n\n    logger.request(\n      toAny({\n        request: {", "      toAny({\n        request: {\n          method: 'GET',\n          data: null,\n          params: undefined,\n          headers: new Headers({ 'x-header-a': 'a' }),\n        },\n        url: '/do-mock',\n        data: null,\n        headers: new Headers({ 'Content-Type': 'application/json' }),", "        data: null,\n        headers: new Headers({ 'Content-Type': 'application/json' }),\n        responseText: 'null',\n      })\n    )\n\n    expect(logSpy).toBeCalledWith('[logger]', 'GET /do-mock', {\n      data: null,\n      params: undefined,\n      headers: { 'x-header-a': 'a' },", "      params: undefined,\n      headers: { 'x-header-a': 'a' },\n    })\n  })\n\n  it('should output response log with formatted message', () => {\n    const logger = new Logger('logger', 2)\n\n    logger.response(\n      toAny({", "    logger.response(\n      toAny({\n        request: {\n          method: 'GET',\n          data: null,\n          params: undefined,\n          headers: new Headers({ 'x-header-a': 'a' }),\n        },\n        url: '/do-mock',\n        status: 200,", "        url: '/do-mock',\n        status: 200,\n        statusText: 'OK',\n        data: null,\n        headers: new Headers({ 'Content-Type': 'application/json' }),\n        responseText: 'null',\n      })\n    )\n\n    expect(logSpy).toBeCalledWith('[logger]', 'GET /do-mock 200 (OK)', {", "\n    expect(logSpy).toBeCalledWith('[logger]', 'GET /do-mock 200 (OK)', {\n      data: null,\n      responseText: 'null',\n      headers: { 'content-type': 'application/json' },\n    })\n  })\n\n  it('should output error log with formatted message when given a RequestError', () => {\n    const logger = new Logger('logger', 2)", "  it('should output error log with formatted message when given a RequestError', () => {\n    const logger = new Logger('logger', 2)\n\n    const ctx = toAny({\n      request: {\n        method: 'GET',\n        data: null,\n        params: undefined,\n        headers: new Headers({ 'x-header-a': 'a' }),\n      },", "        headers: new Headers({ 'x-header-a': 'a' }),\n      },\n      url: '/do-mock',\n      status: 500,\n      statusText: 'Internal Server Error',\n      data: null,\n      headers: new Headers({ 'Content-Type': 'application/json' }),\n      responseText: 'null',\n    })\n    const error = new RequestError('error', ctx)", "    })\n    const error = new RequestError('error', ctx)\n\n    logger.error(error)\n\n    expect(errorSpy).toBeCalledWith(\n      '[logger] GET /do-mock 500 (Internal Server Error)\\n%o\\n' + error.stack,\n      {\n        request: {\n          data: null,", "        request: {\n          data: null,\n          headers: {\n            'x-header-a': 'a',\n          },\n          params: undefined,\n        },\n        response: {\n          data: null,\n          headers: {", "          data: null,\n          headers: {\n            'content-type': 'application/json',\n          },\n          responseText: 'null',\n        },\n      }\n    )\n  })\n", "  })\n\n  it('should output error log with formatted message when before request', () => {\n    const logger = new Logger('logger', 2)\n\n    const ctx = toAny({\n      request: {\n        method: 'GET',\n        data: null,\n        params: undefined,", "        data: null,\n        params: undefined,\n        headers: new Headers({ 'x-header-a': 'a' }),\n      },\n      url: '/do-mock',\n      status: -1,\n    })\n\n    const error = new RequestError('error', ctx)\n", "    const error = new RequestError('error', ctx)\n\n    logger.error(error)\n\n    expect(errorSpy).toBeCalledWith(\n      '[logger] GET /do-mock -1 (Before Request)\\n%o\\n' + error.stack,\n      {\n        request: {\n          data: null,\n          headers: {", "          data: null,\n          headers: {\n            'x-header-a': 'a',\n          },\n          params: undefined,\n        },\n        response: {\n          data: undefined,\n          headers: undefined,\n          responseText: undefined,", "          headers: undefined,\n          responseText: undefined,\n        },\n      }\n    )\n  })\n\n  it('should output error log with formatted message when given an other error', () => {\n    const logger = new Logger('logger', 2)\n", "    const logger = new Logger('logger', 2)\n\n    logger.error('error')\n    expect(errorSpy).toBeCalledWith('error')\n\n    const error = new Error('error')\n    logger.error(error)\n    expect(errorSpy).toBeCalledWith(error)\n  })\n})", "  })\n})\n"]}
{"filename": "src/shared/__tests__/progress.test.ts", "chunked_list": ["import { progressEventReducer } from '../progress'\n\ndescribe('progress specs', () => {\n  it('should calc progress rate correctly', () => {\n    // mock progress interval\n    let times = 0\n    vi.spyOn(Date, 'now').mockImplementation(() => ++times * 250)\n\n    let progress: any = {}\n    const reducedListener = progressEventReducer((v) => {", "    let progress: any = {}\n    const reducedListener = progressEventReducer((v) => {\n      progress = v\n    })\n\n    // 1st load\n    const event: any = { loaded: 50, total: 10240, lengthComputable: true }\n    reducedListener(event)\n    expect(progress).toMatchInlineSnapshot(`\n      {", "    expect(progress).toMatchInlineSnapshot(`\n      {\n        \"bytes\": 50,\n        \"download\": false,\n        \"estimated\": undefined,\n        \"event\": {\n          \"lengthComputable\": true,\n          \"loaded\": 50,\n          \"total\": 10240,\n        },", "          \"total\": 10240,\n        },\n        \"loaded\": 50,\n        \"progress\": 0.0048828125,\n        \"rate\": undefined,\n        \"total\": 10240,\n        \"upload\": true,\n      }\n    `)\n", "    `)\n\n    // 2nd load\n    event.loaded = 1500\n    reducedListener(event)\n    expect(progress).toMatchInlineSnapshot(`\n      {\n        \"bytes\": 1450,\n        \"download\": false,\n        \"estimated\": 43.7,", "        \"download\": false,\n        \"estimated\": 43.7,\n        \"event\": {\n          \"lengthComputable\": true,\n          \"loaded\": 1500,\n          \"total\": 10240,\n        },\n        \"loaded\": 1500,\n        \"progress\": 0.146484375,\n        \"rate\": 200,", "        \"progress\": 0.146484375,\n        \"rate\": 200,\n        \"total\": 10240,\n        \"upload\": true,\n      }\n    `)\n\n    // disable lengthComputable\n    event.lengthComputable = false\n    event.total = undefined", "    event.lengthComputable = false\n    event.total = undefined\n    reducedListener(event)\n    expect(progress).toMatchInlineSnapshot(`\n      {\n        \"bytes\": 0,\n        \"download\": false,\n        \"estimated\": undefined,\n        \"event\": {\n          \"lengthComputable\": false,", "        \"event\": {\n          \"lengthComputable\": false,\n          \"loaded\": 1500,\n          \"total\": undefined,\n        },\n        \"loaded\": 1500,\n        \"progress\": undefined,\n        \"rate\": 3000,\n        \"total\": undefined,\n        \"upload\": true,", "        \"total\": undefined,\n        \"upload\": true,\n      }\n    `)\n  })\n})\n"]}
{"filename": "src/shared/__tests__/url.test.ts", "chunked_list": ["import { getUri, stringifyUrl } from '../url'\n\ndescribe('getUri specs', () => {\n  it('should not join when given a absolute url', () => {\n    expect(\n      getUri({\n        baseURL: 'https://example.com',\n        url: 'https://api.com/api/v1/posts',\n      })\n    ).toBe('https://api.com/api/v1/posts')", "      })\n    ).toBe('https://api.com/api/v1/posts')\n\n    expect(\n      getUri({\n        baseURL: 'https://example.com',\n        url: '//api.com/api/v1/posts',\n      })\n    ).toBe('//api.com/api/v1/posts')\n  })", "    ).toBe('//api.com/api/v1/posts')\n  })\n\n  it('should not join when baseURL is falsy', () => {\n    expect(\n      getUri({\n        baseURL: undefined,\n        url: '/api/v1/posts',\n      })\n    ).toBe('/api/v1/posts')", "      })\n    ).toBe('/api/v1/posts')\n\n    expect(\n      getUri({\n        baseURL: '',\n        url: '/api/v1/posts',\n      })\n    ).toBe('/api/v1/posts')\n  })", "    ).toBe('/api/v1/posts')\n  })\n\n  it('should join with baseURL with separator', () => {\n    expect(\n      getUri({\n        baseURL: 'https://example.com/',\n        url: '/api/v1/posts#t=1',\n      })\n    ).toBe('https://example.com/api/v1/posts')", "      })\n    ).toBe('https://example.com/api/v1/posts')\n\n    expect(\n      getUri({\n        baseURL: 'https://example.com//',\n        url: '/api/v1/posts/',\n      })\n    ).toBe('https://example.com/api/v1/posts/')\n  })", "    ).toBe('https://example.com/api/v1/posts/')\n  })\n\n  it('should join url with query-string when given string params', () => {\n    expect(\n      getUri({\n        url: 'https://example.com/api/v1/posts',\n        params: 'a=1',\n      })\n    ).toBe('https://example.com/api/v1/posts?a=1')", "      })\n    ).toBe('https://example.com/api/v1/posts?a=1')\n\n    expect(\n      getUri({\n        url: 'https://example.com/api/v1/posts?t=123',\n        params: '?a=1',\n      })\n    ).toBe('https://example.com/api/v1/posts?t=123&a=1')\n  })", "    ).toBe('https://example.com/api/v1/posts?t=123&a=1')\n  })\n\n  it('should join url with query-string when given object params', () => {\n    expect(\n      getUri({\n        url: 'https://example.com/api/v1/posts',\n        params: {\n          a: '1+1',\n          b: '2 1',", "          a: '1+1',\n          b: '2 1',\n          c: null,\n          d: undefined,\n          arr: [1, 2, 3],\n        },\n      })\n    ).toBe('https://example.com/api/v1/posts?a=1%2B1&b=2+1&arr=1&arr=2&arr=3')\n  })\n", "  })\n\n  it('should join url with query-string when given the URLSearchParams', () => {\n    expect(\n      getUri({\n        url: 'https://example.com/api/v1/posts',\n        params: new URLSearchParams({ a: '1', b: '2' }),\n      })\n    ).toBe('https://example.com/api/v1/posts?a=1&b=2')\n  })", "    ).toBe('https://example.com/api/v1/posts?a=1&b=2')\n  })\n})\n\ndescribe('stringifyUrl specs', () => {\n  it('should overwrite the duplicated key-values when given a url having search-params if not append', () => {\n    expect(\n      stringifyUrl(\n        'https://example.com?a=a&b=b&t=1',\n        { a: 1, b: 2, c: 3 },", "        'https://example.com?a=a&b=b&t=1',\n        { a: 1, b: 2, c: 3 },\n        false\n      )\n    ).toBe('https://example.com?a=1&b=2&t=1&c=3')\n  })\n})\n"]}
{"filename": "src/shared/__tests__/RequestError.test.ts", "chunked_list": ["import { toAny } from 'test/utils'\n\nimport { RequestError } from '../RequestError'\n\ndescribe('RequestError specs', () => {\n  it('should return [object RequestError] when called with Object.prototype.toString', () => {\n    expect(\n      Object.prototype.toString.call(new RequestError('test', toAny({})))\n    ).toBe('[object Error]')\n  })", "    ).toBe('[object Error]')\n  })\n})\n"]}
{"filename": "src/shared/__tests__/transform.test.ts", "chunked_list": ["import { transformRequestBody } from '../transform'\n\ndescribe('transform specs', () => {\n  it.each([\n    undefined,\n    null,\n    '1',\n    new FormData(),\n    new Blob(['1']),\n    new ArrayBuffer(1),", "    new Blob(['1']),\n    new ArrayBuffer(1),\n    { a: 1 },\n    [{ a: 1 }],\n  ])('should transform requestBody correctly when given `%o`', (data) => {\n    expect(transformRequestBody(data)).toMatchSnapshot()\n  })\n\n  it('should thrown TypeError when given a number', () => {\n    expect(() => transformRequestBody(1 as any)).toThrow(TypeError)", "  it('should thrown TypeError when given a number', () => {\n    expect(() => transformRequestBody(1 as any)).toThrow(TypeError)\n    expect(() => transformRequestBody(1 as any)).toThrow(\n      /Invalid request body type/\n    )\n  })\n})\n"]}
{"filename": "src/core/AbortController.ts", "chunked_list": ["export class TimeoutAbortController {\n  static readonly supported = typeof AbortController !== 'undefined'\n\n  private controller: AbortController\n  private timeoutId: ReturnType<typeof setTimeout> | null = null\n\n  constructor(timeout: number) {\n    if (!TimeoutAbortController.supported)\n      throw new ReferenceError(\n        'Not support AbortController in current environment.'\n      )\n\n    this.controller = new AbortController()", "    if (timeout > 0) {\n      this.timeoutId = setTimeout(\n        () => this.controller.abort('timeout'),\n        timeout\n      )\n    }\n  }\n\n  get signal() {\n    return this.controller.signal\n  }\n\n  abort(reason?: any) {\n    this.controller.abort(reason)\n    this.clear()\n  }\n\n  clear() {", "    if (this.timeoutId) {\n      clearTimeout(this.timeoutId)\n      this.timeoutId = null\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'TimeoutAbortController'\n  }\n}\n"]}
{"filename": "src/core/Requete.ts", "chunked_list": ["import { Adapter, createAdapter } from 'requete/adapter'\nimport {\n  getUri,\n  Logger,\n  mergeHeaders,\n  pick,\n  RequestError,\n  stringifyUrl,\n} from 'requete/shared'\n", "} from 'requete/shared'\n\nimport { TimeoutAbortController } from './AbortController'\nimport { compose } from './compose'\n\nexport type Method =\n  | 'GET'\n  | 'DELETE'\n  | 'HEAD'\n  | 'OPTIONS'\n  | 'POST'\n  | 'PUT'\n  | 'PATCH'\n", "export type RequestBody =\n  | BodyInit\n  | null\n  | Record<string, any>\n  | Record<string, any>[]\n\nexport type RequestQueryRecord = Record<\n  string,\n  | string\n  | number\n  | boolean\n  | null\n  | undefined\n  | Array<string | number | boolean>\n>\n", "export type RequestQuery = string | URLSearchParams | RequestQueryRecord\n\nexport interface RequestConfig {\n  baseURL?: string\n  /** request timeout (ms) */\n  timeout?: number\n  /** response body type */\n  responseType?: 'json' | 'formData' | 'text' | 'blob' | 'arrayBuffer'\n  /** A string indicating how the request will interact with the browser's cache to set request's cache. */\n  cache?: RequestCache\n  /** A string indicating whether credentials will be sent with the request always, never, or only when sent to a same-origin URL. Sets request's credentials. */\n  credentials?: RequestCredentials\n  /** A Headers object, an object literal, or an array of two-item arrays to set request's headers. */\n  headers?: HeadersInit\n  /** A cryptographic hash of the resource to be fetched by request. Sets request's integrity. */\n  integrity?: string\n  /** A boolean to set request's keepalive. */\n  keepalive?: boolean\n  /** A string to indicate whether the request will use CORS, or will be restricted to same-origin URLs. Sets request's mode. */\n  mode?: RequestMode\n  /** A string indicating whether request follows redirects, results in an error upon encountering a redirect, or returns the redirect (in an opaque fashion). Sets request's redirect. */\n  redirect?: RequestRedirect\n  /** A string whose value is a same-origin URL, \"about:client\", or the empty string, to set request's referrer. */\n  referrer?: string\n  /** A referrer policy to set request's referrerPolicy. */\n  referrerPolicy?: ReferrerPolicy\n  /** enable logger or set logger level # */\n  verbose?: boolean | number\n  /**\n   * parse json function\n   * (for transform response)\n   * @default JSON.parse\n   */\n  toJSON?(body: string): any\n}\n", "export interface IRequest extends Omit<RequestConfig, 'verbose'> {\n  url: string\n  /**\n   * A string to set request's method.\n   * @default GET\n   */\n  method?: Method\n  /** A string or object to set querystring of url */\n  params?: RequestQuery\n  /** request`s body */\n  data?: RequestBody\n  /**\n   * A TimeoutAbortController to set request's signal.\n   * @default TimeoutAbortController\n   */\n  abort?: TimeoutAbortController | null\n  /** specify request adapter */\n  adapter?: Adapter\n  /** flexible custom field */\n  custom?: Record<string, any>\n}\n\n/** {@link https://developer.mozilla.org/en-US/docs/Web/API/Response} */", "export interface IResponse<Data = any> {\n  headers: Headers\n  ok: boolean\n  redirected: boolean\n  status: number\n  statusText: string\n  type: ResponseType\n  url: string\n  data: Data\n  responseText?: string\n}\n", "export interface IContext<Data = any> extends IResponse<Data> {\n  /**\n   * request config.\n   * and empty `Headers` object as default\n   */\n  request: IRequest & { method: Method; headers: Headers }\n  /**\n   * set `ctx.request.headers`\n   *\n   * *And header names are matched by case-insensitive byte sequence.*\n   *\n   * @example\n   * ```ts\n   * // set a header\n   * ctx.set('name', '<value>')\n   *\n   * // remove a header\n   * ctx.set('name', null)\n   * ctx.set('name')\n   *\n   * // set headers\n   * ctx.set({ name1: '<value>', name2: '<value>' })\n   * ```\n   */\n  set(headerOrName: HeadersInit | string, value?: string | null): this\n\n  /**\n   * Add extra params to `request.url`.\n   * If there are duplicate keys, then the original key-values will be removed.\n   */\n  params(params: RequestQuery): this\n\n  /**\n   * get `ctx.request.abort`,\n   * and **create one if not exist**\n   * @throws {RequestError}\n   */\n  abort(): TimeoutAbortController\n\n  /** throw {@link RequestError} */\n  throw(e: string | Error): void\n\n  /**\n   * Assign to current context\n   */\n  assign(context: Partial<IContext>): void\n\n  /**\n   * Replay current request\n   * And assign new context to current, with replay`s response\n   */\n  replay(): Promise<void>\n}\n", "export type Middleware = (\n  ctx: IContext,\n  next: () => Promise<void>\n) => Promise<void>\n\ntype AliasConfig = Omit<IRequest, 'url' | 'data'>\n\nexport class Requete {\n  static defaults: RequestConfig = {\n    timeout: 0,\n    responseType: 'json',\n    headers: {\n      Accept: 'application/json, text/plain, */*',\n    },\n    verbose: 1,\n    toJSON: (text: string | null | undefined) => {", "      if (text) return JSON.parse(text)\n    },\n  }\n\n  private configs?: RequestConfig\n  private adapter: Adapter\n  private middlewares: Middleware[] = []\n\n  logger: Logger\n\n  constructor(config?: RequestConfig) {\n    this.configs = Object.assign({ method: 'GET' }, Requete.defaults, config)\n    this.adapter = createAdapter()\n\n    this.logger = new Logger(\n      'Requete',\n      this.configs.verbose === true ? 2 : Number(this.configs.verbose ?? 0)\n    )\n  }\n\n  /**\n   * add middleware function\n   *\n   * @attention\n   * - The calling order of middleware should follow the **Onion Model**.\n   *   like {@link https://github.com/koajs/koa/blob/master/docs/guide.md#writing-middleware Koajs}.\n   * - `next()` must be called asynchronously in middleware\n   *\n   * @example\n   * ```ts\n   * http.use(async (ctx, next) => {\n   *   // set request header\n   *   ctx.set('Authorization', '<token>')\n   *\n   *   // wait for request responding\n   *   await next()\n   *\n   *   // transformed response body\n   *   console.log(ctx.data)\n   *\n   *   // throw a request error", "   *   if (!ctx.data) ctx.throw('no response data')\n   * })\n   * ```\n   */\n  use(middleware: Middleware) {\n    this.middlewares.push(middleware)\n    this.logger.info(\n      `Use middleware #${this.middlewares.length}:`,\n      middleware.name || middleware\n    )\n    return this\n  }\n\n  private createRequest(config: IRequest) {\n    const request: IRequest = Object.assign({}, this.configs, config)\n\n    request.url = getUri(request)\n    request.headers = mergeHeaders(\n      Requete.defaults.headers,\n      this.configs?.headers,\n      config.headers\n    )\n\n    // add default AbortController for timeout", "    if (!request.abort && request.timeout && TimeoutAbortController.supported) {\n      request.abort = new TimeoutAbortController(request.timeout)\n    }\n\n    return request as IContext['request']\n  }\n\n  private createContext<D>(config: IRequest) {\n    const request = this.createRequest(config)\n    const doRequest = this.request.bind(this)\n\n    const ctx: IContext<D> = {\n      request,\n      status: -1,\n      data: undefined as D,\n      ok: false,\n      redirected: false,\n      headers: undefined as unknown as Headers,\n      statusText: undefined as unknown as string,\n      type: undefined as unknown as ResponseType,\n      url: request.url,\n      set(headerOrName, value) {", "        if (this.status !== -1)\n          this.throw('Cannot set request headers after next().')\n\n        let headers = this.request.headers\n\n        if (typeof headerOrName === 'string') {\n          value == null\n            ? headers.delete(headerOrName)\n            : headers.set(headerOrName, value)\n        } else {\n          headers = mergeHeaders(headers, headerOrName)\n        }\n\n        this.request.headers = headers\n\n        return this\n      },\n      params(params) {\n        this.request.url = stringifyUrl(this.request.url, params, false)\n        return this\n      },\n      abort() {", "        if (!this.request.abort) {\n          if (this.status !== -1)\n            this.throw('Cannot set abortSignal after next().')\n\n          this.request.abort = new TimeoutAbortController(\n            this.request.timeout ?? 0\n          )\n        }\n\n        return this.request.abort\n      },\n      throw(e) {", "        if (e instanceof RequestError) throw e\n        throw new RequestError(e, this)\n      },\n      assign(context) {\n        Object.assign(this, context)\n      },\n      async replay() {\n        // count replay #\n        this.request.custom = Object.assign({}, this.request.custom, {\n          replay: (this.request.custom?.replay ?? 0) + 1,\n        })\n\n        const context = await doRequest(this.request)\n        this.assign(context)\n      },\n    }\n\n    return ctx\n  }\n\n  private async invoke(ctx: IContext) {\n    this.logger.request(ctx)\n\n    const adapter = ctx.request.adapter ?? this.adapter\n    const response = await adapter.request(ctx)\n\n    // assign to ctx\n    Object.assign(\n      ctx,\n      pick(response, [\n        'ok',\n        'status',\n        'statusText',\n        'headers',\n        'data',\n        'responseText',\n        'redirected',\n        'type',\n        'url',\n      ])\n    )\n", "    if (ctx.request.responseType === 'json') {\n      ctx.data = ctx.request.toJSON!(response.data)\n    }\n  }\n\n  async request<D = any>(config: IRequest) {\n    // create context\n    const context = this.createContext<D>(config)\n\n    // exec middleware\n    try {\n      await compose(this.middlewares)(context, this.invoke.bind(this))\n", "    try {\n      await compose(this.middlewares)(context, this.invoke.bind(this))\n\n      if (!context.ok) {\n        context.throw(\n          `${context.request.method} ${context.url} ${context.status} (${context.statusText})`\n        )\n      }\n\n      this.logger.response(context)\n      return context", "    } catch (e: any) {\n      this.logger.error(e)\n      throw e\n    } finally {\n      context.request.abort?.clear()\n    }\n  }\n\n  get<D = any>(url: string, config?: AliasConfig) {\n    return this.request<D>({ ...config, url, method: 'GET' })\n  }\n  delete<D = any>(url: string, config?: AliasConfig) {\n    return this.request<D>({ ...config, url, method: 'DELETE' })\n  }\n  head<D = any>(url: string, config?: AliasConfig) {\n    return this.request<D>({ ...config, url, method: 'HEAD' })\n  }\n  options<D = any>(url: string, config?: AliasConfig) {\n    return this.request<D>({ ...config, url, method: 'OPTIONS' })\n  }\n  post<D = any>(url: string, data?: RequestBody, config?: AliasConfig) {\n    return this.request<D>({ ...config, url, data, method: 'POST' })\n  }\n  put<D = any>(url: string, data?: RequestBody, config?: AliasConfig) {\n    return this.request<D>({ ...config, url, data, method: 'PUT' })\n  }\n  patch<D = any>(url: string, data?: RequestBody, config?: AliasConfig) {\n    return this.request<D>({ ...config, url, data, method: 'PATCH' })\n  }\n}\n"]}
{"filename": "src/core/create.ts", "chunked_list": ["import { RequestConfig, Requete } from './Requete'\n\nexport function create(config?: RequestConfig) {\n  return new Requete(config)\n}\n"]}
{"filename": "src/core/compose.ts", "chunked_list": ["import type { IContext, Middleware } from './Requete'\n\nexport function compose(middlewares: Middleware[]) {\n  return (context: IContext, next: Middleware) => {\n    // last called middleware #\n    let index = -1\n    return dispatch(0).catch((e) => context.throw(e))\n    async function dispatch(i: number): Promise<void> {\n      if (i <= index) throw new Error('next() called multiple times')\n\n      index = i\n\n      const middleware = i === middlewares.length ? next : middlewares[i]", "      if (i <= index) throw new Error('next() called multiple times')\n\n      index = i\n\n      const middleware = i === middlewares.length ? next : middlewares[i]\n      if (middleware) return await middleware(context, () => dispatch(i + 1))\n    }\n  }\n}\n"]}
{"filename": "src/core/__tests__/AbortController.test.ts", "chunked_list": ["import { TimeoutAbortController } from '../AbortController'\n\ndescribe('TimeoutAbortController specs', () => {\n  it('should thrown a ReferenceError when AbortController not supported', () => {\n    // @ts-ignore\n    TimeoutAbortController.supported = false\n\n    expect(() => new TimeoutAbortController(0)).toThrow(ReferenceError)\n    expect(() => new TimeoutAbortController(0)).toThrow(\n      'Not support AbortController in current environment.'", "    expect(() => new TimeoutAbortController(0)).toThrow(\n      'Not support AbortController in current environment.'\n    )\n\n    // @ts-ignore\n    TimeoutAbortController.supported = true\n  })\n\n  it('should return [object TimeoutAbortController] when called with Object.prototype.toString', () => {\n    expect(Object.prototype.toString.call(new TimeoutAbortController(0))).toBe(", "  it('should return [object TimeoutAbortController] when called with Object.prototype.toString', () => {\n    expect(Object.prototype.toString.call(new TimeoutAbortController(0))).toBe(\n      '[object TimeoutAbortController]'\n    )\n  })\n})\n"]}
{"filename": "src/core/__tests__/requete-request.test.ts", "chunked_list": ["import { FetchAdapter } from 'requete/adapter'\n\nimport { Method, Requete } from '../Requete'\n\ndescribe('Requete request configs', () => {\n  beforeEach(() => {\n    vi.spyOn(FetchAdapter.prototype, 'request').mockImplementation(\n      vi.fn().mockResolvedValue({\n        ok: true,\n        status: 200,", "        ok: true,\n        status: 200,\n        statusText: 'OK',\n        url: '/do-mock',\n        data: 'null',\n      })\n    )\n  })\n\n  it.each([", "\n  it.each([\n    'get',\n    'head',\n    'delete',\n    'options',\n    'post',\n    'patch',\n    'put',\n  ] as Lowercase<Method>[])(", "    'put',\n  ] as Lowercase<Method>[])(\n    'should make request by %s alias func',\n    async (method) => {\n      const requete = new Requete()\n      const ctx = await requete[method]('/do-mock')\n\n      expect(ctx.request.url).toBe('/do-mock')\n      expect(ctx.request.method).toBe(method.toUpperCase())\n    }", "      expect(ctx.request.method).toBe(method.toUpperCase())\n    }\n  )\n\n  it('should make a request with correct url', async () => {\n    const requete = new Requete({ baseURL: 'https://api.mock.com/api/v1/' })\n\n    let ctx = await requete.post('https://api.mock.com/api/v2/do-mock?id=1')\n    expect(ctx.request.url).toBe('https://api.mock.com/api/v2/do-mock?id=1')\n", "    expect(ctx.request.url).toBe('https://api.mock.com/api/v2/do-mock?id=1')\n\n    ctx = await requete.get('do-mock?id=1', { params: { id: '2' } })\n    expect(ctx.request.url).toBe(\n      'https://api.mock.com/api/v1/do-mock?id=1&id=2'\n    )\n\n    ctx = await requete.get('do-mock', { params: 'id=2' })\n    expect(ctx.request.url).toBe('https://api.mock.com/api/v1/do-mock?id=2')\n  })", "    expect(ctx.request.url).toBe('https://api.mock.com/api/v1/do-mock?id=2')\n  })\n})\n"]}
{"filename": "src/core/__tests__/requete-exceptions.test.ts", "chunked_list": ["import { FetchAdapter } from 'requete/adapter'\nimport { RequestError } from 'requete/shared'\nimport { toAny } from 'test/utils'\n\nimport { Requete } from '../Requete'\n\ndescribe('Requete exceptions specs', () => {\n  beforeEach(() => {\n    vi.spyOn(FetchAdapter.prototype, 'request').mockImplementation(\n      vi.fn().mockResolvedValue({", "    vi.spyOn(FetchAdapter.prototype, 'request').mockImplementation(\n      vi.fn().mockResolvedValue({\n        ok: true,\n        status: 200,\n        statusText: 'OK',\n        url: '/do-mock',\n        data: 'null',\n      })\n    )\n", "    )\n\n    // disable console.error\n    vi.spyOn(global.console, 'error').mockImplementation(toAny(vi.fn()))\n  })\n\n  it('should caught RequestError when response`s status != 200', async () => {\n    vi.spyOn(FetchAdapter.prototype, 'request').mockImplementation(\n      vi.fn().mockResolvedValue({\n        ok: false,", "      vi.fn().mockResolvedValue({\n        ok: false,\n        status: 500,\n        statusText: 'Internal Server Error',\n        url: '/do-mock',\n        data: 'null',\n      })\n    )\n\n    const requete = new Requete()", "\n    const requete = new Requete()\n\n    await expect(requete.get('https:api.com/do-mock')).rejects.toThrow(\n      RequestError\n    )\n    await expect(requete.get('/do-mock')).rejects.toThrow(\n      'GET /do-mock 500 (Internal Server Error)'\n    )\n  })", "    )\n  })\n\n  it('should caught RequestError when middleware throws', async () => {\n    const requete = new Requete().use(async (ctx, next) => {\n      if (ctx.request.method === 'GET') throw new Error('not allowed')\n      await next()\n      if (ctx.request.method === 'POST') throw new Error('post error')\n    })\n\n    await expect(requete.get('/do-mock')).rejects.toThrow(RequestError)\n    await expect(requete.get('/do-mock')).rejects.toThrow('not allowed')\n    await expect(requete.post('/do-mock')).rejects.toThrow(RequestError)\n    await expect(requete.post('/do-mock')).rejects.toThrow('post error')\n  })\n\n  it('should caught when call ctx funcs in wrong way', async () => {\n    // ctx.abort()\n    await expect(\n      new Requete()\n        .use(async (ctx, next) => {\n          await next()\n          ctx.abort()\n        })\n        .get('/do-mock')\n    ).rejects.toThrow('Cannot set abortSignal after next().')\n\n    // ctx.set()\n    await expect(\n      new Requete()\n        .use(async (ctx, next) => {\n          await next()\n          ctx.set('a', 'b')\n        })\n        .get('/do-mock')\n    ).rejects.toThrow('Cannot set request headers after next().')\n  })\n\n  it('should caught when request aborted', async () => {\n    vi.spyOn(FetchAdapter.prototype, 'request').mockImplementation(\n      async (ctx) => {\n        const abort = ctx.abort()", "        if (abort.signal.aborted) {\n          throw new Error(abort.signal.reason)\n        }\n\n        return toAny({\n          ok: false,\n          status: 500,\n          statusText: 'Internal Server Error',\n          url: '/do-mock',\n          data: 'null',\n        })\n      }\n    )\n\n    const requete = new Requete().use(async (ctx, next) => {\n      ctx.abort().abort('abort request')\n      await next()\n    })\n\n    await expect(requete.get('/do-mock', { timeout: 1000 })).rejects.toThrow(\n      'abort request'\n    )\n  })\n\n  it('should caught RequestError when parse body with throws', async () => {\n    vi.spyOn(FetchAdapter.prototype, 'request').mockImplementation(\n      vi.fn().mockResolvedValue({\n        ok: true,\n        status: 200,\n        statusText: 'OK',\n        url: '/do-mock',\n        data: 'bad',\n      })\n    )\n\n    const requete = new Requete()\n    await expect(requete.get('/do-mock')).rejects.toThrow(RequestError)\n    await expect(requete.get('/do-mock')).rejects.toThrow(/Unexpected token/)\n  })\n})\n"]}
{"filename": "src/core/__tests__/requete-response.test.ts", "chunked_list": ["import { toAny } from 'test/utils'\n\nimport { Requete } from '../Requete'\n\ndescribe('Requete response specs', () => {\n  beforeEach(() => {\n    vi.clearAllMocks()\n  })\n\n  it.each([", "\n  it.each([\n    { data: { data: 'mockData' }, dataType: 'json' },\n    { data: new FormData(), dataType: 'formData' },\n    { data: new Blob(), dataType: 'blob' },\n    { data: new ArrayBuffer(0), dataType: 'arrayBuffer' },\n    { data: 'text', dataType: 'text' },\n  ])(\n    'should respond $dataType type when request successfully',\n    async ({ data, dataType }) => {\n      const response: any = {\n        ok: true,\n        status: 200,\n        statusText: 'ok',\n        [dataType]: vi.fn().mockResolvedValue(data),\n        url: '/do-mock',\n      }\n\n      // add text func for json type", "    'should respond $dataType type when request successfully',\n    async ({ data, dataType }) => {\n      const response: any = {\n        ok: true,\n        status: 200,\n        statusText: 'ok',\n        [dataType]: vi.fn().mockResolvedValue(data),\n        url: '/do-mock',\n      }\n\n      // add text func for json type", "      if (dataType === 'json') {\n        response.text = vi.fn().mockResolvedValue(JSON.stringify(data))\n      }\n\n      // mock fetch api\n      vi.spyOn(global, 'fetch').mockImplementation(\n        toAny(vi.fn().mockResolvedValue(response))\n      )\n\n      const res = await new Requete().get('/do-mock', {\n        responseType: dataType as any,\n      })\n\n      expect(res.data).toEqual(data)\n    }\n  )\n})\n"]}
{"filename": "src/core/__tests__/requete-middleware.test.ts", "chunked_list": ["import { FetchAdapter } from 'requete/adapter'\nimport { toAny } from 'test/utils'\n\nimport { Requete } from '../Requete'\n\ndescribe('Requete middleware specs', () => {\n  const spy = vi.spyOn(FetchAdapter.prototype, 'request').mockImplementation(\n    vi.fn().mockResolvedValue({\n      ok: true,\n      status: 200,", "      ok: true,\n      status: 200,\n      statusText: 'OK',\n      url: '/do-mock',\n      data: 'null',\n    })\n  )\n\n  beforeEach(() => {\n    spy.mockClear()", "  beforeEach(() => {\n    spy.mockClear()\n  })\n\n  it('should execute middleware in order according to the onion model with request context', async () => {\n    const before = vi.fn()\n    const after = vi.fn()\n\n    const requete = new Requete()\n      .use(async (ctx, next) => {", "    const requete = new Requete()\n      .use(async (ctx, next) => {\n        before(ctx.request)\n        await next()\n        after(ctx.data)\n      })\n      .use(async (ctx, next) => {\n        before(2)\n        await next()\n        after(2)", "        await next()\n        after(2)\n      })\n      .use(async (ctx, next) => {\n        before(3)\n        await next()\n        after(3)\n      })\n\n    const res = await requete.post('/do-mock')", "\n    const res = await requete.post('/do-mock')\n\n    expect(res.request).toBeDefined()\n    expect(res.data).toBeDefined()\n\n    expect(before).nthCalledWith(1, res.request)\n    expect(before).nthCalledWith(2, 2)\n    expect(before).nthCalledWith(3, 3)\n", "    expect(before).nthCalledWith(3, 3)\n\n    expect(after).nthCalledWith(1, 3)\n    expect(after).nthCalledWith(2, 2)\n    expect(after).nthCalledWith(3, res.data)\n  })\n\n  it('should throws when call next() duplicated', async () => {\n    vi.spyOn(console, 'error').mockImplementation(toAny(vi.fn()))\n", "    vi.spyOn(console, 'error').mockImplementation(toAny(vi.fn()))\n\n    const requete = new Requete()\n    requete.use(async (ctx, next) => {\n      await next()\n      await next()\n    })\n\n    await expect(requete.post('/do-mock')).rejects.toThrow(\n      'next() called multiple times'", "    await expect(requete.post('/do-mock')).rejects.toThrow(\n      'next() called multiple times'\n    )\n  })\n\n  it('should set request header correctly in middleware', async () => {\n    const requete = new Requete()\n    requete.use(async (ctx, next) => {\n      ctx.set('Authorization', 'mock')\n      ctx.set({ 'x-client-by': 'mock' })", "      ctx.set('Authorization', 'mock')\n      ctx.set({ 'x-client-by': 'mock' })\n      ctx.set('x')\n      await next()\n    })\n\n    const res = await requete.post('/do-mock')\n    expect(res.request.headers).toEqual(\n      new Headers({\n        Accept: 'application/json, text/plain, */*',", "      new Headers({\n        Accept: 'application/json, text/plain, */*',\n        Authorization: 'mock',\n        'x-client-by': 'mock',\n      })\n    )\n  })\n\n  it('should set params correctly in middleware', async () => {\n    const requete = new Requete()", "  it('should set params correctly in middleware', async () => {\n    const requete = new Requete()\n    requete.use(async (ctx, next) => {\n      ctx.params({ a: 1, b: 2 })\n      await next()\n    })\n\n    const res = await requete.post('/do-mock', { params: { b: 1 } })\n    expect(res.request.url).toBe('/do-mock?a=1&b=2')\n  })", "    expect(res.request.url).toBe('/do-mock?a=1&b=2')\n  })\n\n  it('should set abortSignal correctly in middleware', async () => {\n    const requete = new Requete()\n    let controller: any\n    requete.use(async (ctx, next) => {\n      controller = ctx.abort()\n      await next()\n    })", "      await next()\n    })\n\n    const res = await requete.post('/do-mock', undefined)\n    expect(res.request.abort).toEqual(controller)\n  })\n\n  it('should replay the request in middleware', async () => {\n    const requete = new Requete()\n", "    const requete = new Requete()\n\n    requete.use(async (ctx, next) => {\n      await next()\n\n      if (!ctx.request.custom?.replay) {\n        await ctx.replay()\n      }\n    })\n\n    const { request } = await requete.post('/do-mock')\n    expect(spy).toBeCalledTimes(2)\n    expect(request.custom?.replay).toBe(1)\n  })\n})\n"]}
{"filename": "src/adapter/create.ts", "chunked_list": ["import { FetchAdapter } from './FetchAdapter'\nimport { XhrAdapter } from './XhrAdapter'\n\nexport function createAdapter() {\n  const SupportedAdapter = [FetchAdapter, XhrAdapter].find((i) => i.supported)\n  if (!SupportedAdapter)\n    throw new ReferenceError('No adapter supported in current environment.')\n  return new SupportedAdapter()\n}\n"]}
{"filename": "src/adapter/FetchAdapter.ts", "chunked_list": ["import type { IContext, IResponse } from 'requete'\nimport { pick, transformRequestBody } from 'requete/shared'\n\nimport { Adapter } from './Adapter'\n\nexport class FetchAdapter extends Adapter {\n  static readonly supported = typeof fetch !== 'undefined'\n\n  private transformRequest(request: IContext['request']) {\n    const supports = [\n      'method',\n      'cache',\n      'credentials',\n      'headers',\n      'integrity',\n      'keepalive',\n      'mode',\n      'redirect',\n      'referrer',\n      'referrerPolicy',\n    ] as const\n\n    const init: RequestInit = supports.reduce((req, key) => {\n      const value: any = request[key]", "      if (value !== undefined) {\n        req[key] = value\n      }\n      return req\n    }, {} as RequestInit)\n\n    // Content-Type header\n    const headers = init.headers as Headers\n    if (/^(POST|PUT|PATCH)$/i.test(request.method!)) {\n      const { requestBody, contentType } = transformRequestBody(request.data)\n      init.body = requestBody", "    if (/^(POST|PUT|PATCH)$/i.test(request.method!)) {\n      const { requestBody, contentType } = transformRequestBody(request.data)\n      init.body = requestBody\n      if (contentType && !headers.has('Content-Type')) {\n        headers.set('Content-Type', contentType)\n      }\n    }\n    if (init.body == null) {\n      headers.delete('Content-Type')\n    }\n    init.headers = headers\n", "    if (request.abort) init.signal = request.abort.signal\n\n    return init\n  }\n\n  async request(ctx: IContext) {\n    if (!FetchAdapter.supported) {\n      throw new ReferenceError('Not support fetch api in current environment.')\n    }\n\n    const response = await fetch(\n      ctx.request.url,\n      this.transformRequest(ctx.request)\n    )\n\n    const res = pick(response, [\n      'ok',\n      'status',\n      'statusText',\n      'headers',\n      'redirected',\n      'type',\n      'url',\n    ]) as IResponse\n\n    switch (ctx.request.responseType) {\n      case 'formData':\n        res.data = await response.formData()\n        break\n      case 'blob':\n        res.data = await response.blob()\n        break\n      case 'arrayBuffer':\n        res.data = await response.arrayBuffer()\n        break\n      default:\n        res.data = res.responseText = await response.text()\n    }\n\n    return res\n  }\n}\n"]}
{"filename": "src/adapter/XhrAdapter.ts", "chunked_list": ["import { IContext, IResponse } from 'requete'\nimport {\n  parseHeaders,\n  progressEventReducer,\n  RequestError,\n  transformRequestBody,\n} from 'requete/shared'\n\nimport { Adapter } from './Adapter'\n\nexport interface IProgressEvent {\n  loaded: number\n  total?: number\n  progress?: number\n  bytes: number\n  rate?: number\n  estimated?: number\n  upload?: boolean\n  download?: boolean\n  event?: any\n}\n", "import { Adapter } from './Adapter'\n\nexport interface IProgressEvent {\n  loaded: number\n  total?: number\n  progress?: number\n  bytes: number\n  rate?: number\n  estimated?: number\n  upload?: boolean\n  download?: boolean\n  event?: any\n}\n", "export type XhrAdapterOptions = {\n  onDownloadProgress?(e: IProgressEvent): void\n  onUploadProgress?(e: IProgressEvent): void\n}\n\nexport class XhrAdapter extends Adapter {\n  static readonly supported = typeof XMLHttpRequest !== 'undefined'\n\n  constructor(private options?: XhrAdapterOptions) {\n    super()\n  }\n\n  private transformRequest(xhr: XMLHttpRequest, ctx: IContext) {\n    const { request } = ctx\n    const { headers } = request\n", "    if (request.timeout) {\n      xhr.timeout = request.timeout\n    }\n\n    // Add withCredentials to xhr\n    if (request.credentials === 'include') {\n      xhr.withCredentials = true\n    }\n\n    // Content-Type header to xhr\n    let requestBody: any", "    if (/^(POST|PUT|PATCH)$/i.test(request.method!)) {\n      const body = transformRequestBody(request.data)\n      requestBody = body.requestBody\n\n      if (body.contentType && !request.headers.has('Content-Type')) {\n        headers.set('Content-Type', body.contentType)\n      }\n    }\n    if (requestBody == null) {\n      headers.delete('Content-Type')\n    }\n\n    // Add headers to xhr\n    headers.forEach((value, key) => {\n      xhr.setRequestHeader(key, value)\n    })\n\n    return requestBody\n  }\n\n  private transformResponse(xhr: XMLHttpRequest, ctx: IContext) {\n    const response: IResponse = {\n      ok: !!xhr.status && xhr.status >= 200 && xhr.status < 300,\n      status: xhr.status,\n      statusText: xhr.statusText,\n      headers: parseHeaders(xhr.getAllResponseHeaders()),\n      redirected: false,\n      type: 'default',\n      url: xhr.responseURL,\n      data: ['json', 'text', undefined].includes(ctx.request.responseType)\n        ? xhr.responseText\n        : xhr.response,\n      responseText: xhr.responseText,\n    }\n\n    return response\n  }\n\n  request(ctx: IContext) {\n    return new Promise<IResponse>((resolve, reject) => {", "    if (requestBody == null) {\n      headers.delete('Content-Type')\n    }\n\n    // Add headers to xhr\n    headers.forEach((value, key) => {\n      xhr.setRequestHeader(key, value)\n    })\n\n    return requestBody\n  }\n\n  private transformResponse(xhr: XMLHttpRequest, ctx: IContext) {\n    const response: IResponse = {\n      ok: !!xhr.status && xhr.status >= 200 && xhr.status < 300,\n      status: xhr.status,\n      statusText: xhr.statusText,\n      headers: parseHeaders(xhr.getAllResponseHeaders()),\n      redirected: false,\n      type: 'default',\n      url: xhr.responseURL,\n      data: ['json', 'text', undefined].includes(ctx.request.responseType)\n        ? xhr.responseText\n        : xhr.response,\n      responseText: xhr.responseText,\n    }\n\n    return response\n  }\n\n  request(ctx: IContext) {\n    return new Promise<IResponse>((resolve, reject) => {", "      if (!XhrAdapter.supported) {\n        throw new ReferenceError(\n          'Not support XMLHttpRequest api in current environment.'\n        )\n      }\n\n      let xhr: null | XMLHttpRequest = new XMLHttpRequest()\n      xhr.open(ctx.request.method!, ctx.request.url, true)\n\n      const abort = (abortReq?: boolean) => {\n        reject(\n          new RequestError(ctx.request.abort!.signal.reason ?? 'aborted', ctx)\n        )\n\n        abortReq && xhr!.abort()\n        xhr = null\n      }\n\n      const onabort = () => {", "        if (!xhr) return\n        abort(true)\n      }\n\n      // add abortSignal\n      if (ctx.request.abort) {\n        const { signal } = ctx.request.abort\n        if (signal.aborted) {\n          // no need to send request\n          return abort()\n        }\n\n        signal.addEventListener('abort', onabort)\n      }\n\n      xhr.onloadend = () => {", "        if (!xhr) return\n\n        resolve(this.transformResponse(xhr, ctx))\n\n        ctx.request.abort?.signal.removeEventListener('abort', onabort)\n        xhr = null\n      }\n\n      xhr.onerror = () => {\n        if (!xhr) return\n        reject(new RequestError('Network Error', ctx))\n        xhr = null\n      }\n\n      xhr.ontimeout = () => {", "        if (!xhr) return\n        reject(new RequestError('Network Error', ctx))\n        xhr = null\n      }\n\n      xhr.ontimeout = () => {\n        if (!xhr) return\n        reject(new RequestError('timeout', ctx))\n        xhr = null\n      }\n", "      if (this.options?.onDownloadProgress) {\n        xhr.addEventListener(\n          'progress',\n          progressEventReducer(this.options.onDownloadProgress, true)\n        )\n      }\n\n      // Not all browsers support upload events\n      if (this.options?.onUploadProgress && xhr.upload) {\n        xhr.addEventListener(\n          'progress',\n          progressEventReducer(this.options.onUploadProgress)\n        )\n      }\n\n      xhr.send(this.transformRequest(xhr, ctx) ?? null)\n    })\n  }\n}\n", "      if (this.options?.onUploadProgress && xhr.upload) {\n        xhr.addEventListener(\n          'progress',\n          progressEventReducer(this.options.onUploadProgress)\n        )\n      }\n\n      xhr.send(this.transformRequest(xhr, ctx) ?? null)\n    })\n  }\n}\n"]}
{"filename": "src/adapter/Adapter.ts", "chunked_list": ["import type { IContext, IResponse } from 'requete'\n\nexport abstract class Adapter {\n  static readonly supported: boolean\n  abstract request(ctx: IContext): Promise<IResponse>\n}\n"]}
{"filename": "src/adapter/__tests__/FetchAdapter.test.ts", "chunked_list": ["import { Method, TimeoutAbortController } from 'requete'\nimport { toAny } from 'test/utils'\n\nimport { FetchAdapter } from '../FetchAdapter'\n\ndescribe('FetchAdapter specs', () => {\n  const supported = FetchAdapter.supported\n\n  beforeEach(() => {\n    vi.clearAllMocks()", "  beforeEach(() => {\n    vi.clearAllMocks()\n  })\n\n  it.each([\n    'GET',\n    'HEAD',\n    'DELETE',\n    'OPTIONS',\n    'POST',", "    'OPTIONS',\n    'POST',\n    'PUT',\n    'PATCH',\n  ] as Method[])('should make a %s by fetch', (method) => {\n    const spy = vi.spyOn(global, 'fetch').mockImplementation(toAny(vi.fn()))\n    const headers = new Headers()\n\n    new FetchAdapter()\n      .request(", "    new FetchAdapter()\n      .request(\n        toAny({\n          request: { url: '/do-mock', method, headers },\n        })\n      )\n      .catch(vi.fn())\n\n    expect(spy).toBeCalledWith('/do-mock', {\n      method,\n      headers, // headers is required in ctx\n    })\n  })\n\n  it('should set Content-Type header when given a POST request with payload', () => {\n    const spy = vi.spyOn(global, 'fetch').mockImplementation(toAny(vi.fn()))\n    const data = { a: 1 }\n\n    new FetchAdapter()\n      .request(\n        toAny({\n          request: {\n            url: '/do-mock',\n            method: 'POST',\n            headers: new Headers(),\n            data,\n          },\n        })\n      )", "      .catch(vi.fn())\n\n    expect(spy).toBeCalledWith('/do-mock', {\n      method: 'POST',\n      headers: new Headers({\n        'Content-Type': 'application/json;charset=utf-8',\n      }),\n      body: JSON.stringify(data),\n    })\n  })\n\n  it('should remove Content-Type header when given a POST request without payload', () => {\n    const spy = vi.spyOn(global, 'fetch').mockImplementation(toAny(vi.fn()))\n\n    new FetchAdapter()\n      .request(\n        toAny({\n          request: {\n            url: '/do-mock',\n            method: 'POST',\n            headers: new Headers({\n              'Content-Type': 'application/json',\n            }),\n          },\n        })\n      )", "      .catch(vi.fn())\n\n    expect(spy).toBeCalledWith('/do-mock', {\n      method: 'POST',\n      headers: new Headers(),\n    })\n  })\n\n  it('should add abortSignal when given ctx with `abort` field', () => {\n    const spy = vi.spyOn(global, 'fetch').mockImplementation(toAny(vi.fn()))\n\n    const abort = new TimeoutAbortController(0)\n    new FetchAdapter()\n      .request(\n        toAny({\n          request: {\n            url: '/do-mock',\n            method: 'POST',\n            headers: new Headers(),\n            abort,\n          },\n        })\n      )", "      .catch(vi.fn())\n\n    expect(spy).toBeCalledWith('/do-mock', {\n      method: 'POST',\n      headers: new Headers(),\n      signal: abort.signal,\n    })\n  })\n\n  it('should thrown ReferenceError when fetch api not supported', async () => {\n    // @ts-ignore\n    FetchAdapter.supported = false\n\n    await expect(new FetchAdapter().request(toAny({}))).rejects.toThrow(\n      ReferenceError\n    )\n    await expect(new FetchAdapter().request(toAny({}))).rejects.toThrow(\n      'Not support fetch api in current environment.'\n    )\n\n    // @ts-ignore\n    FetchAdapter.supported = supported\n  })\n})\n"]}
{"filename": "src/adapter/__tests__/create.test.ts", "chunked_list": ["import { createAdapter } from '../create'\nimport { FetchAdapter } from '../FetchAdapter'\nimport { XhrAdapter } from '../XhrAdapter'\n\ndescribe('createAdapter specs', () => {\n  it('should thrown a ReferenceError when all adapters are not supported', () => {\n    // @ts-ignore\n    FetchAdapter.supported = false\n    // @ts-ignore\n    XhrAdapter.supported = false", "    // @ts-ignore\n    XhrAdapter.supported = false\n\n    expect(createAdapter).toThrow(ReferenceError)\n    expect(createAdapter).toThrow(\n      'No adapter supported in current environment.'\n    )\n  })\n\n  it('should return FetchAdapter instance when it supported', () => {", "\n  it('should return FetchAdapter instance when it supported', () => {\n    // @ts-ignore\n    FetchAdapter.supported = true\n\n    expect(createAdapter()).toBeInstanceOf(FetchAdapter)\n  })\n\n  it('should return XhrAdapter instance when it supported & FetchAdapter not supported', () => {\n    // @ts-ignore", "  it('should return XhrAdapter instance when it supported & FetchAdapter not supported', () => {\n    // @ts-ignore\n    FetchAdapter.supported = false\n    // @ts-ignore\n    XhrAdapter.supported = true\n\n    expect(createAdapter()).toBeInstanceOf(XhrAdapter)\n  })\n})\n", "})\n"]}
{"filename": "src/adapter/__tests__/XhrAdapter.test.ts", "chunked_list": ["import { Method, TimeoutAbortController } from 'requete'\nimport { sleep, toAny } from 'test/utils'\n\nimport * as progress from '../../shared/progress'\nimport { XhrAdapter } from '../XhrAdapter'\n\ndescribe('XhrAdapter specs', () => {\n  const supported = XhrAdapter.supported\n\n  beforeEach(() => {", "\n  beforeEach(() => {\n    vi.clearAllMocks()\n  })\n\n  it('should thrown ReferenceError when fetch api not supported', async () => {\n    // @ts-ignore\n    XhrAdapter.supported = false\n\n    await expect(new XhrAdapter().request(toAny({}))).rejects.toThrow(", "\n    await expect(new XhrAdapter().request(toAny({}))).rejects.toThrow(\n      ReferenceError\n    )\n    await expect(new XhrAdapter().request(toAny({}))).rejects.toThrow(\n      'Not support XMLHttpRequest api in current environment.'\n    )\n\n    // @ts-ignore\n    XhrAdapter.supported = supported", "    // @ts-ignore\n    XhrAdapter.supported = supported\n  })\n\n  describe('XhrAdapter: request config specs', () => {\n    it.each([\n      'GET',\n      'HEAD',\n      'DELETE',\n      'OPTIONS',", "      'DELETE',\n      'OPTIONS',\n      'POST',\n      'PUT',\n      'PATCH',\n    ] as Method[])('should make a %s by XMLHttpRequest', (method) => {\n      const openStub = vi.fn()\n\n      vi.spyOn(global, 'XMLHttpRequest').mockImplementation(\n        toAny(", "      vi.spyOn(global, 'XMLHttpRequest').mockImplementation(\n        toAny(\n          vi.fn().mockReturnValue({\n            open: openStub,\n          })\n        )\n      )\n\n      expect(XhrAdapter.supported).toBe(true)\n", "      expect(XhrAdapter.supported).toBe(true)\n\n      new XhrAdapter()\n        .request(\n          toAny({\n            request: { url: '/do-mock', method },\n          })\n        )\n        .catch(vi.fn())\n\n      expect(openStub).toBeCalledWith(method, '/do-mock', true)\n    })\n\n    it('should set Content-Type header when given a POST request with payload', () => {\n      const setRequestHeaderStub = vi.fn()\n      const sendStub = vi.fn()\n\n      vi.spyOn(global, 'XMLHttpRequest').mockImplementation(\n        toAny(\n          vi.fn().mockReturnValue({\n            open: vi.fn(),\n            setRequestHeader: setRequestHeaderStub,\n            send: sendStub,\n          })\n        )\n      )\n\n      const data = { a: 1 }\n\n      new XhrAdapter().request(\n        toAny({\n          request: {\n            url: '/do-mock',\n            method: 'POST',\n            headers: new Headers(),\n            data,\n          },\n        })\n      )\n\n      expect(setRequestHeaderStub).toBeCalledWith(\n        'content-type', // lower-case by `Headers`\n        'application/json;charset=utf-8'\n      )\n      expect(sendStub).toBeCalledWith(JSON.stringify(data))\n    })\n\n    it('should remove Content-Type header when given a POST request without payload', () => {\n      const setRequestHeaderStub = vi.fn()\n      const sendStub = vi.fn()\n\n      vi.spyOn(global, 'XMLHttpRequest').mockImplementation(\n        toAny(\n          vi.fn().mockReturnValue({\n            open: vi.fn(),\n            setRequestHeader: setRequestHeaderStub,\n            send: sendStub,\n          })\n        )\n      )\n\n      new XhrAdapter().request(\n        toAny({\n          request: {\n            url: '/do-mock',\n            method: 'POST',\n            headers: new Headers({\n              'Content-Type': 'application/json',\n            }),\n          },\n        })\n      )\n\n      expect(setRequestHeaderStub).not.toBeCalled()\n      expect(sendStub).toBeCalledWith(null)\n    })\n\n    it('should set timeout to xhr when given timeout in ctx', () => {\n      const setterStub = vi.fn()\n      vi.spyOn(global, 'XMLHttpRequest').mockImplementation(\n        toAny(\n          vi.fn().mockReturnValue({\n            open: vi.fn(),\n            send: vi.fn(),\n            set timeout(v: any) {\n              setterStub(v)\n            },\n          })\n        )\n      )\n\n      new XhrAdapter().request(\n        toAny({\n          request: {\n            url: '/do-mock',\n            method: 'POST',\n            headers: new Headers(),\n            timeout: 1,\n          },\n        })\n      )\n\n      expect(setterStub).toBeCalledWith(1)\n    })\n\n    it('should set withCredentials to xhr when given credentials == `include` in ctx', () => {\n      const setterStub = vi.fn()\n      vi.spyOn(global, 'XMLHttpRequest').mockImplementation(\n        toAny(\n          vi.fn().mockReturnValue({\n            open: vi.fn(),\n            send: vi.fn(),\n            set withCredentials(v: any) {\n              setterStub(v)\n            },\n          })\n        )\n      )\n\n      new XhrAdapter().request(\n        toAny({\n          request: {\n            url: '/do-mock',\n            method: 'POST',\n            headers: new Headers(),\n            credentials: 'include',\n          },\n        })\n      )\n\n      expect(setterStub).toBeCalledWith(true)\n    })\n  })\n\n  describe('XhrAdapter: response specs', () => {\n    it('should transform response for ctx when the request is onloadend', async () => {\n      vi.spyOn(global, 'XMLHttpRequest').mockImplementation(() => {", "        .catch(vi.fn())\n\n      expect(openStub).toBeCalledWith(method, '/do-mock', true)\n    })\n\n    it('should set Content-Type header when given a POST request with payload', () => {\n      const setRequestHeaderStub = vi.fn()\n      const sendStub = vi.fn()\n\n      vi.spyOn(global, 'XMLHttpRequest').mockImplementation(\n        toAny(\n          vi.fn().mockReturnValue({\n            open: vi.fn(),\n            setRequestHeader: setRequestHeaderStub,\n            send: sendStub,\n          })\n        )\n      )\n\n      const data = { a: 1 }\n\n      new XhrAdapter().request(\n        toAny({\n          request: {\n            url: '/do-mock',\n            method: 'POST',\n            headers: new Headers(),\n            data,\n          },\n        })\n      )\n\n      expect(setRequestHeaderStub).toBeCalledWith(\n        'content-type', // lower-case by `Headers`\n        'application/json;charset=utf-8'\n      )\n      expect(sendStub).toBeCalledWith(JSON.stringify(data))\n    })\n\n    it('should remove Content-Type header when given a POST request without payload', () => {\n      const setRequestHeaderStub = vi.fn()\n      const sendStub = vi.fn()\n\n      vi.spyOn(global, 'XMLHttpRequest').mockImplementation(\n        toAny(\n          vi.fn().mockReturnValue({\n            open: vi.fn(),\n            setRequestHeader: setRequestHeaderStub,\n            send: sendStub,\n          })\n        )\n      )\n\n      new XhrAdapter().request(\n        toAny({\n          request: {\n            url: '/do-mock',\n            method: 'POST',\n            headers: new Headers({\n              'Content-Type': 'application/json',\n            }),\n          },\n        })\n      )\n\n      expect(setRequestHeaderStub).not.toBeCalled()\n      expect(sendStub).toBeCalledWith(null)\n    })\n\n    it('should set timeout to xhr when given timeout in ctx', () => {\n      const setterStub = vi.fn()\n      vi.spyOn(global, 'XMLHttpRequest').mockImplementation(\n        toAny(\n          vi.fn().mockReturnValue({\n            open: vi.fn(),\n            send: vi.fn(),\n            set timeout(v: any) {\n              setterStub(v)\n            },\n          })\n        )\n      )\n\n      new XhrAdapter().request(\n        toAny({\n          request: {\n            url: '/do-mock',\n            method: 'POST',\n            headers: new Headers(),\n            timeout: 1,\n          },\n        })\n      )\n\n      expect(setterStub).toBeCalledWith(1)\n    })\n\n    it('should set withCredentials to xhr when given credentials == `include` in ctx', () => {\n      const setterStub = vi.fn()\n      vi.spyOn(global, 'XMLHttpRequest').mockImplementation(\n        toAny(\n          vi.fn().mockReturnValue({\n            open: vi.fn(),\n            send: vi.fn(),\n            set withCredentials(v: any) {\n              setterStub(v)\n            },\n          })\n        )\n      )\n\n      new XhrAdapter().request(\n        toAny({\n          request: {\n            url: '/do-mock',\n            method: 'POST',\n            headers: new Headers(),\n            credentials: 'include',\n          },\n        })\n      )\n\n      expect(setterStub).toBeCalledWith(true)\n    })\n  })\n\n  describe('XhrAdapter: response specs', () => {\n    it('should transform response for ctx when the request is onloadend', async () => {\n      vi.spyOn(global, 'XMLHttpRequest').mockImplementation(() => {", "        class FakeXhr {\n          onloadend = vi.fn()\n          open = vi.fn()\n          send() {\n            this.onloadend()\n          }\n          getAllResponseHeaders = () => undefined\n        }\n\n        return new FakeXhr() as any\n      })\n\n      const response = await new XhrAdapter().request(\n        toAny({\n          request: {\n            url: '/do-mock',\n            method: 'POST',\n            headers: new Headers(),\n            abort: new TimeoutAbortController(0),\n          },\n        })\n      )\n\n      expect(response).toEqual({\n        ok: false,\n        status: undefined,\n        statusText: undefined,\n        headers: new Headers(),\n        redirected: false,\n        type: 'default',\n        url: undefined,\n        data: undefined,\n      })\n    })\n\n    it.each([\n      { status: 200, expected: true },\n      { status: 201, expected: true },\n      { status: 301, expected: false },\n      { status: 404, expected: false },\n      { status: 500, expected: false },\n    ])(\n      'should set response.ok is $expected when response status is $status',\n      async ({ status, expected }) => {\n        vi.spyOn(global, 'XMLHttpRequest').mockImplementation(() => {", "          class FakeXhr {\n            status = status\n            onloadend = vi.fn()\n            open = vi.fn()\n            send() {\n              this.onloadend()\n            }\n            getAllResponseHeaders = () => undefined\n          }\n\n          return new FakeXhr() as any\n        })\n\n        const { ok } = await new XhrAdapter().request(\n          toAny({\n            request: {\n              url: '/do-mock',\n              method: 'POST',\n              headers: new Headers(),\n            },\n          })\n        )\n\n        expect(ok).toBe(expected)\n      }\n    )\n\n    it.each([\n      { responseType: 'blob', resIndex: 1 },\n      { responseType: 'arrayBuffer', resIndex: 1 },\n      { responseType: 'formData', resIndex: 1 },\n      { responseType: 'json', resIndex: 0 },\n      { responseType: 'text', resIndex: 0 },\n    ])(\n      'should get response data after loadend when given then responseType is $responseType',\n      async ({ responseType, resIndex }) => {\n        const mockRes = ['mock responseText', 'mock response']\n\n        vi.spyOn(global, 'XMLHttpRequest').mockImplementation(() => {", "          class FakeXhr {\n            responseText = mockRes[0]\n            response = mockRes[1]\n\n            onloadend = vi.fn()\n            open = vi.fn()\n            send() {\n              this.onloadend()\n            }\n            getAllResponseHeaders = () => undefined\n          }\n\n          return new FakeXhr() as any\n        })\n\n        const { data } = await new XhrAdapter().request(\n          toAny({\n            request: {\n              url: '/do-mock',\n              method: 'POST',\n              headers: new Headers(),\n              responseType,\n            },\n          })\n        )\n\n        expect(data).toBe(mockRes[resIndex])\n      }\n    )\n  })\n\n  describe('XhrAdapter: exception specs', () => {\n    it('should thrown a error when request onerror', async () => {\n      vi.spyOn(global, 'XMLHttpRequest').mockImplementation(() => {", "        class FakeXhr {\n          onerror = vi.fn()\n          open = vi.fn()\n          send() {\n            this.onerror()\n          }\n          getAllResponseHeaders = () => undefined\n        }\n\n        return new FakeXhr() as any\n      })\n\n      await expect(\n        new XhrAdapter().request(toAny({ request: { headers: new Headers() } }))\n      ).rejects.toThrow('Network Error')\n    })\n\n    it('should thrown a error when request ontimeout', async () => {\n      vi.spyOn(global, 'XMLHttpRequest').mockImplementation(() => {", "        class FakeXhr {\n          ontimeout = vi.fn()\n          open = vi.fn()\n          send() {\n            this.ontimeout()\n          }\n          getAllResponseHeaders = () => undefined\n        }\n\n        return new FakeXhr() as any\n      })\n\n      await expect(\n        new XhrAdapter().request(toAny({ request: { headers: new Headers() } }))\n      ).rejects.toThrow('timeout')\n    })\n  })\n\n  describe('XhrAdapter: abort specs', () => {\n    it('should thrown error & don`t send request when given a aborted AbortController in ctx', async () => {\n      const sendStub = vi.fn()\n\n      vi.spyOn(global, 'XMLHttpRequest').mockImplementation(() => {", "        class FakeXhr {\n          open = vi.fn()\n          send = sendStub\n          getAllResponseHeaders = () => undefined\n        }\n\n        return new FakeXhr() as any\n      })\n\n      const adapter = new XhrAdapter()\n\n      let controller = new TimeoutAbortController(0)\n      controller.abort()\n\n      await expect(\n        adapter.request(\n          toAny({ request: { headers: new Headers(), abort: controller } })\n        )\n      ).rejects.toThrow('aborted')\n\n      expect(sendStub).not.toBeCalled()\n\n      controller = new TimeoutAbortController(0)\n      controller.abort('canceled')\n\n      await expect(\n        adapter.request(\n          toAny({ request: { headers: new Headers(), abort: controller } })\n        )\n      ).rejects.toThrow('canceled')\n    })\n\n    it('should abort the pending request by AbortController', async () => {\n      const abortStub = vi.fn()\n      const onloadendStub = vi.fn()\n\n      vi.spyOn(global, 'XMLHttpRequest').mockImplementation(() => {", "        class FakeXhr {\n          open = vi.fn()\n          getAllResponseHeaders = () => undefined\n          onloadend = vi.fn()\n          send = () => sleep(1000).then(() => this.onloadend)\n          abort = abortStub\n        }\n\n        return new FakeXhr() as any\n      })\n\n      const adapter = new XhrAdapter()\n      const controller = new TimeoutAbortController(0)\n      const request = adapter.request(\n        toAny({ request: { headers: new Headers(), abort: controller } })\n      )\n\n      controller.abort('why abort?')\n\n      await expect(request).rejects.toThrow('why abort?')\n      expect(abortStub).toBeCalled()\n      expect(onloadendStub).not.toBeCalled()\n    })\n  })\n\n  describe('XhrAdapter: with progress options', () => {\n    it('should not set `onDownloadProgress` to xhr when given the option', () => {\n      const handleStub = vi.fn()\n      const spy = vi\n        .spyOn(progress, 'progressEventReducer')\n        .mockImplementation(toAny(vi.fn().mockReturnValue(handleStub)))\n\n      const addEventListenerStub = vi.fn()\n      vi.spyOn(global, 'XMLHttpRequest').mockImplementation(() => {", "        class FakeXhr {\n          open = vi.fn()\n          send = vi.fn()\n          addEventListener = addEventListenerStub\n        }\n\n        return new FakeXhr() as any\n      })\n\n      const onDownloadProgress = vi.fn()\n      new XhrAdapter({ onDownloadProgress }).request(\n        toAny({ request: { headers: new Headers() } })\n      )\n\n      expect(spy).toBeCalledWith(onDownloadProgress, true)\n      expect(addEventListenerStub).toBeCalledWith('progress', handleStub)\n    })\n\n    it('should set `onUploadProgress` to xhr when given the option & it support upload', () => {\n      const handleStub = vi.fn()\n      const spy = vi\n        .spyOn(progress, 'progressEventReducer')\n        .mockImplementation(toAny(vi.fn().mockReturnValue(handleStub)))\n\n      const addEventListenerStub = vi.fn()\n      vi.spyOn(global, 'XMLHttpRequest').mockImplementation(() => {", "        class FakeXhr {\n          open = vi.fn()\n          send = vi.fn()\n          addEventListener = addEventListenerStub\n          upload = true\n        }\n\n        return new FakeXhr() as any\n      })\n\n      const onUploadProgress = vi.fn()\n      new XhrAdapter({ onUploadProgress }).request(\n        toAny({ request: { headers: new Headers() } })\n      )\n\n      expect(spy).toBeCalledWith(onUploadProgress)\n      expect(addEventListenerStub).toBeCalledWith('progress', handleStub)\n    })\n\n    it('should not set `onUploadProgress` to xhr when it not support upload', () => {\n      const spy = vi\n        .spyOn(progress, 'progressEventReducer')\n        .mockImplementation(toAny(vi.fn()))\n\n      const addEventListenerStub = vi.fn()\n      vi.spyOn(global, 'XMLHttpRequest').mockImplementation(() => {", "        class FakeXhr {\n          open = vi.fn()\n          send = vi.fn()\n          addEventListener = addEventListenerStub\n        }\n\n        return new FakeXhr() as any\n      })\n\n      new XhrAdapter({ onUploadProgress: vi.fn() }).request(\n        toAny({ request: { headers: new Headers() } })\n      )\n\n      expect(spy).not.toBeCalled()\n      expect(addEventListenerStub).not.toBeCalled()\n    })\n  })\n})\n"]}
{"filename": "src/middleware/timestamp.ts", "chunked_list": ["import type { Method, Middleware } from 'requete'\n\nexport function timestamp(key = '_', methods: Method[] = ['GET']): Middleware {\n  return async function addTimestamp(ctx, next) {\n    if (methods.includes(ctx.request.method)) {\n      ctx.params({ [key]: Date.now() })\n    }\n\n    await next()\n  }\n}\n"]}
