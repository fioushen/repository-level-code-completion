{"filename": "tsup.config.ts", "chunked_list": ["import type { Options } from 'tsup';\n\nconst config: Options = {\n  splitting: true,\n  entry: {\n    'lib/index': 'src/lib/index.ts',\n    'server/cli': 'src/server/cli.ts',\n    'server/index': 'src/server/index.ts'\n  },\n  ", "  },\n  \n  format: ['cjs', 'esm'],\n  outDir: 'dist',\n  clean: true,\n}\n\nexport default config;"]}
{"filename": "test/guidedEdit.test.ts", "chunked_list": ["import * as git from '../src/server/git';\nimport * as useAiModule from '../src/server/spells/use_ai_spell';\nimport { createMockStatement, setupConfigTestAfter, setupConfigTestBefore, withTempConfig } from './testHelpers';\nimport { Project, SyntaxKind } from 'ts-morph';\n\n// Mock the required functions\njest.mock('../src/server/git');\njest.mock('../src/server/spells/use_ai_spell');\n\nconst prepareBranchMock = git.prepareBranch as jest.Mock;", "\nconst prepareBranchMock = git.prepareBranch as jest.Mock;\nconst managePullRequestMock = git.managePullRequest as jest.Mock;\nconst useAiMock = useAiModule.useAi as jest.Mock;\n\nimport { guidedEdit } from '../src/server/spells/guided_edit_spell';\n\ndescribe('guidedEdit', () => {\n  let tempConfigPath = '';\n", "  let tempConfigPath = '';\n\n  beforeEach(() => {\n    tempConfigPath = setupConfigTestBefore({ ai: { retries: '3' }, ts: { typeDir: 'types', configPath: 'tsconfig.json' } });\n    jest.clearAllMocks();\n  });\n\n  afterEach(() => {\n    setupConfigTestAfter(tempConfigPath);\n  });", "    setupConfigTestAfter(tempConfigPath);\n  });\n\n  test('should throw error when ts.configPath is not set', async () => {\n    await withTempConfig({ ai: { retries: '3' }, ts: { configPath: '' } }, async () => {\n      await expect(guidedEdit('NonExistent.tsx please make some changes to the file')).rejects.toThrow('Missing ts.configPath.');\n    });\n  });\n\n  it('should return \"file not found\" if the file does not exist', async () => {", "\n  it('should return \"file not found\" if the file does not exist', async () => {\n    await withTempConfig({ ai: { retries: '3' }, ts: { configPath: 'tsconfig.json' } }, async () => {\n      const fileParts = 'NonExistent.tsx please make some changes to the file';\n      prepareBranchMock.mockResolvedValue('test_branch');\n      useAiMock.mockResolvedValue({ message: [] });\n  \n      const result = await guidedEdit(fileParts);\n      expect(result).toBe('file not found: NonExistent.tsx');\n    });", "      expect(result).toBe('file not found: NonExistent.tsx');\n    });\n  });\n\n  it('should return \"the file is too large\" if the file size is greater than 10000 characters', async () => {\n    const fileParts = 'LargeFile.tsx please make some changes to the file';\n    prepareBranchMock.mockResolvedValue('test_branch');\n    useAiMock.mockResolvedValue({ message: [] });\n\n    Project.prototype.getSourceFiles = jest.fn().mockReturnValue([{", "\n    Project.prototype.getSourceFiles = jest.fn().mockReturnValue([{\n      getFilePath: () => 'LargeFile.tsx',\n      getText: () => 'a'.repeat(10001),\n      getStatements: () => [],\n    }]);\n\n    const result = await guidedEdit(fileParts);\n    expect(result).toBe('the file is too large');\n  });", "    expect(result).toBe('the file is too large');\n  });\n\n  it('should correctly handle generatedStatements for replacing, adding above, and adding below', async () => {\n    const fileParts = 'Test.tsx please make some changes to the file';\n    prepareBranchMock.mockResolvedValue('test_branch');\n    managePullRequestMock.mockResolvedValue('PR created or updated');\n  \n    // Create mock statements\n    const mockStatements = [", "    // Create mock statements\n    const mockStatements = [\n      createMockStatement('const statement_0 = \"original_0\";', SyntaxKind.VariableStatement),\n      createMockStatement('const statement_1 = \"original_1\";', SyntaxKind.VariableStatement),\n      createMockStatement('const statement_2 = \"original_2\";', SyntaxKind.VariableStatement),\n    ];\n  \n    // Check if sourceFile content was updated correctly\n    let updatedFileContent = mockStatements.map(s => s.getText()).join('\\n');\n", "    let updatedFileContent = mockStatements.map(s => s.getText()).join('\\n');\n\n    // Update sourceFileMock\n    const sourceFileMock = {\n      getFilePath: () => 'Test.tsx',\n      getText: () => updatedFileContent,\n      getFullText: () => updatedFileContent,\n      getStatements: () => mockStatements,\n      removeText: jest.fn(),\n      insertText: jest.fn((index, content) => {", "      removeText: jest.fn(),\n      insertText: jest.fn((index, content) => {\n        updatedFileContent = updatedFileContent.slice(0, index) + content + updatedFileContent.slice(index);\n      }),\n      saveSync: jest.fn(),\n    };\n\n    // Mock project.save\n    Project.prototype.save = jest.fn();\n  ", "    Project.prototype.save = jest.fn();\n  \n    // Mock getSourceFiles() to return the sourceFileMock\n    const getSourceFilesMock = jest.fn().mockReturnValue([sourceFileMock]);\n    Project.prototype.getSourceFiles = getSourceFilesMock;\n  \n    // Define generatedStatements\n    const generatedStatements = {\n      statement_0: 'const statement_0 = \"original_0\"',\n      above_1: 'const above_1 = \"above\";',", "      statement_0: 'const statement_0 = \"original_0\"',\n      above_1: 'const above_1 = \"above\";',\n      statement_2: 'const statement_2 = \"original_2\";',\n      below_2: 'const below_2 = \"below\";',\n    };\n  \n    // Mock useAi to return the generatedStatements\n    useAiMock.mockResolvedValue({ message: [generatedStatements], supportingText: 'Supporting text' });\n\n    // Call guidedEdit", "\n    // Call guidedEdit\n    await guidedEdit(fileParts);\n  \n    // Check if useAi was called with correct parsedStatements\n    const parsedStatements = JSON.parse(useAiMock.mock.calls[0][2]);\n    expect(parsedStatements).toHaveProperty('statement_0');\n    expect(parsedStatements).toHaveProperty('statement_1');\n    expect(parsedStatements).toHaveProperty('statement_2');\n", "    expect(parsedStatements).toHaveProperty('statement_2');\n\n    expect(updatedFileContent).toContain('const statement_0 = \"original_0\"');\n    expect(updatedFileContent).toContain('const above_1 = \"above\";');\n    expect(updatedFileContent).toContain('const statement_2 = \"original_2\";');\n    expect(updatedFileContent).toContain('const below_2 = \"below\";');\n  });\n});"]}
{"filename": "test/parseChatAttempt.test.ts", "chunked_list": ["import { setupChatResponse, setupCommonMocks } from './testHelpers';\nsetupChatResponse('');\nsetupCommonMocks();\n\nimport * as parserModule from '../src/server/parser';\nimport { GuidedEditResponse } from '../src/lib/prompts/guided_edit_prompt';\n\ndescribe('parserModule.parseChatAttempt', () => {\n\n  test('should handle forgotten markdown footer', async () => {", "\n  test('should handle forgotten markdown footer', async () => {\n    const badRes = 'Edits conveyed by comment snippets. I edited lines 61, 63, 65, 68, 70, 73, 75, which is 7 total edited lines. Here are the 7 edited lines:\\n' +\n    '```' +\n    '61. /* wizapp removed line content */ {empty space}\\n' +\n    '63. /* wizapp removed line content */ {empty space}\\n' +\n    '65.   return chatResponse.data.choices[0]?.message?.content.trim(); /* wizapp removed console log */\\n' +\n    '68. /* wizapp removed line content */ {empty space}\\n' +\n    '70.   return completionResponse.data.choices[0].text?.trim(); /* wizapp removed console log */\\n' +\n    '73. /* wizapp removed line content */ {empty space}\\n' +", "    '70.   return completionResponse.data.choices[0].text?.trim(); /* wizapp removed console log */\\n' +\n    '73. /* wizapp removed line content */ {empty space}\\n' +\n    '75.   return moderationResponse.data.results[0]?.flagged; /* wizapp removed console log */';\n    const expectedResult = {\n      message: '61. /* wizapp removed line content */ {empty space}\\n' +\n      '63. /* wizapp removed line content */ {empty space}\\n' +\n      '65.   return chatResponse.data.choices[0]?.message?.content.trim(); /* wizapp removed console log */\\n' +\n      '68. /* wizapp removed line content */ {empty space}\\n' +\n      '70.   return completionResponse.data.choices[0].text?.trim(); /* wizapp removed console log */\\n' +\n      '73. /* wizapp removed line content */ {empty space}\\n' +", "      '70.   return completionResponse.data.choices[0].text?.trim(); /* wizapp removed console log */\\n' +\n      '73. /* wizapp removed line content */ {empty space}\\n' +\n      '75.   return moderationResponse.data.results[0]?.flagged; /* wizapp removed console log */',\n      supportingText: \"Edits conveyed by comment snippets. I edited lines 61, 63, 65, 68, 70, 73, 75, which is 7 total edited lines. Here are the 7 edited lines:\\n``` \"\n    };\n    const result = parserModule.parseChatAttempt(badRes);\n    expect(result).toEqual(expectedResult);\n  });\n\n  test('should throw AI Refusal error', () => {", "\n  test('should throw AI Refusal error', () => {\n    const attempt = \"I'm an AI language model and I can't perform this task.\";\n    expect(() => parserModule.parseChatAttempt(attempt)).toThrowError('AI Refusal');\n    const attempt2 = \"I'm sorry, I don't understand\";\n    expect(() => parserModule.parseChatAttempt(attempt2)).toThrowError('AI Refusal');\n  });\n\n  test('should return throw on non typed chat completion response', () => {\n    const attempt = \"This is a normal response.\";", "  test('should return throw on non typed chat completion response', () => {\n    const attempt = \"This is a normal response.\";\n    expect(() => parserModule.parseChatAttempt(attempt)).toThrowError();\n  });\n\n  test('should throw Block structure is not valid error', () => {\n    const attempt = \"&&&Some text@@@&&&\";\n    expect(() => parserModule.parseChatAttempt(attempt)).toThrowError('Block structure is not valid.');\n  });\n", "  });\n\n  test('should throw cannot parse json error', () => {\n    const attempt = \"&&&Some text@@@{invalid json}@@@Some other text&&&\";\n    expect(() => parserModule.parseChatAttempt(attempt)).toThrowError(/cannot parse json./);\n  });\n\n  test('should return parsed json and supporting text when using a type', () => {\n    const attempt = '&&&In this edit, we fixed...@@@[{\"statement_7\": \"some changes\"}]@@@Some other information about these changes&&&';\n    const expectedResult = {", "    const attempt = '&&&In this edit, we fixed...@@@[{\"statement_7\": \"some changes\"}]@@@Some other information about these changes&&&';\n    const expectedResult = {\n      message: [{ \"statement_7\": \"some changes\" }],\n      supportingText: \"In this edit, we fixed...\\nSome other information about these changes\"\n    };\n    expect(parserModule.parseChatAttempt<GuidedEditResponse>(attempt)).toEqual(expectedResult);\n  });\n  \n  test('should throw bad chat format error', () => {\n    const attempt = '&&&Some text@@@{\"unknown\": \"value\"}@@@Some other text&&&';", "  test('should throw bad chat format error', () => {\n    const attempt = '&&&Some text@@@{\"unknown\": \"value\"}@@@Some other text&&&';\n    expect(() => parserModule.parseChatAttempt(attempt)).toThrowError('bad chat format');\n  });\n\n  test('should call validateTypedResponse with a string not wrapped in quotes', () => {\n    const attempt = \"'walking down the road'\";\n    const attemptDbl = '\"walking down the road\"';\n    const response = {\n      message: 'walking down the road',", "    const response = {\n      message: 'walking down the road',\n      supportingText: ''\n    }\n    expect(parserModule.parseChatAttempt(attempt)).toEqual(response);\n    expect(parserModule.parseChatAttempt(attemptDbl)).toEqual(response);\n  });\n});"]}
{"filename": "test/createType.test.ts", "chunked_list": ["import fs from 'fs';\nimport * as useAiModule from '../src/server/spells/use_ai_spell';\nimport { getConfig } from '../src/server/config';\nimport { getPathOf, sanitizeName, toSnakeCase, toTitleCase } from '../src/server/util';\nimport { setupConfigTestBefore, setupConfigTestAfter, withTempConfig, withOriginalGetConfig } from './testHelpers';\n\njest.mock('fs', () => ({\n  ...jest.requireActual('fs'),\n  writeFileSync: jest.fn(),\n  existsSync: jest.fn(),", "  writeFileSync: jest.fn(),\n  existsSync: jest.fn(),\n  mkdirSync: jest.fn()\n}));\n\n// Mock the useAi function\njest.mock('../src/server/spells/use_ai_spell', () => ({\n  useAi: jest.fn(),\n}));\n", "}));\n\nconst useAiMock = useAiModule.useAi as jest.Mock;\n\nimport { createType } from '../src/server/spells';\n\ndescribe('createType', () => {\n  let tempConfigPath = '';\n\n  beforeEach(() => {", "\n  beforeEach(() => {\n    tempConfigPath = setupConfigTestBefore({ ts: { typeDir: 'types', configPath: 'tsconfig.json' } });\n    jest.clearAllMocks();\n  });\n\n  afterEach(() => {\n    setupConfigTestAfter(tempConfigPath);\n  });\n", "  });\n\n  test('should throw error when ts.typeDir is not set', async () => {\n    await withTempConfig({ ts: { typeDir: '' } }, async () => {\n      await expect(createType('ISomeTypeName')).rejects.toThrow('Missing ts.typeDir.');\n    });\n  });\n\n  test('should throw error if typeName does not follow the required format', async () => {\n    await expect(createType('invalidTypeName')).rejects.toThrowError();", "  test('should throw error if typeName does not follow the required format', async () => {\n    await expect(createType('invalidTypeName')).rejects.toThrowError();\n  });\n\n  test('should generate the type correctly and append it to the file', async () => {\n    await withOriginalGetConfig(async () => {\n      const typeName = 'ITestType';\n      const generatedType = 'Test Type';\n      const config = getConfig();\n      useAiMock.mockResolvedValue({ message: generatedType });\n\n      const coreTypesPath = sanitizeName(config.ts.typeDir);\n      const typeFilePath = getPathOf(`${coreTypesPath}/${toSnakeCase(typeName)}.ts`);\n      const comment = `/*\\n* @category ${toTitleCase(typeName)}\\n*/\\n`;\n  \n      (fs.existsSync as jest.Mock).mockReturnValue(false);\n  \n      await createType(typeName);\n  \n      // Check if the directory was created\n      expect(fs.existsSync).toHaveBeenCalledWith(coreTypesPath);\n      expect(fs.mkdirSync).toHaveBeenCalledWith(coreTypesPath, { recursive: true });\n  \n      // Check if the file was written correctly\n      expect(fs.writeFileSync).toHaveBeenCalledWith(typeFilePath, `${comment}${generatedType}\\n\\n`);\n    });\n  });\n});\n"]}
{"filename": "test/testHelpers.ts", "chunked_list": ["import fs from 'fs';\nimport { setConfig, defaultConfig, configFilePath } from '../src/server/config';\nimport type { Config } from '../src/lib/types';\nimport { SyntaxKind } from 'ts-morph';\nimport { generateTempFilePath, getDirPathOf } from '../src/server/util';\n\nlet chatResponseContent: string;\nlet completionResponseText: string;\nlet moderationResponseFlagged: boolean;\n", "let moderationResponseFlagged: boolean;\n\nexport let openai: Record<string, ReturnType<ReturnType<typeof jest.fn>['mockResolvedValue']>>;\n\nexport function setupOpenAiMocks({ chat, completion, moderation }: { chat?: string, completion?: string, moderation?: string }) {\n  openai = {\n    createChatCompletion: jest.fn().mockResolvedValue({\n      data: { choices: [{ message: { content: chat || chatResponseContent } }] },\n    }),\n    createCompletion: jest.fn().mockReturnValue({\n      data: { choices: [{ text: completion || completionResponseText }] },\n    }),\n    createModeration: jest.fn().mockReturnValue({\n      data: { results: [{ flagged: moderation || moderationResponseFlagged }] },\n    }),\n  };\n}\n", "export function setupCommonMocks() {\n\n  setupOpenAiMocks({});\n\n  jest.mock('openai', () => ({\n    OpenAIApi: jest.fn().mockImplementation(() => openai),\n  }));\n\n  jest.mock('ts-morph', () => ({\n    // Mock the ts-morph library's methods here.\n    Project: jest.fn().mockImplementation(() => ({\n      addSourceFileAtPath: jest.fn().mockReturnValue({}),\n      getSourceFile: jest.fn().mockReturnValue({}),\n      save: jest.fn(),\n      // ...mock other methods if needed\n    })),\n    SyntaxKind: jest.fn().mockReturnValue({}),\n    FunctionDeclaration: jest.fn(),\n    Node: jest.fn()\n  }));\n}\n", "export function setupChatResponse(content: string) {\n  chatResponseContent = content;\n}\n\nexport function setupCompletionResponse(text: string) {\n  completionResponseText = text;\n}\n\nexport function setupModerationResponse(flagged: boolean) {\n  moderationResponseFlagged = flagged;\n}\n", "export function setupModerationResponse(flagged: boolean) {\n  moderationResponseFlagged = flagged;\n}\n\nexport function generateTempConfigPath() {\n  const configDirPath = getDirPathOf(configFilePath);\n  return generateTempFilePath(configDirPath, `test-config`);\n}\n\nexport function setupConfigTestBefore(testConfig?: Config) {\n  const updatedConfig = Object.assign(defaultConfig, (testConfig || {}));\n  setConfig(updatedConfig);\n  \n  // Reset the config file to default values before each test using a custom test file\n  const tempConfigPath = generateTempConfigPath();\n  fs.writeFileSync(tempConfigPath, JSON.stringify(updatedConfig, null, 2));\n  return tempConfigPath;\n}\n", "export function setupConfigTestBefore(testConfig?: Config) {\n  const updatedConfig = Object.assign(defaultConfig, (testConfig || {}));\n  setConfig(updatedConfig);\n  \n  // Reset the config file to default values before each test using a custom test file\n  const tempConfigPath = generateTempConfigPath();\n  fs.writeFileSync(tempConfigPath, JSON.stringify(updatedConfig, null, 2));\n  return tempConfigPath;\n}\n\nexport function setupConfigTestAfter(tempConfigPath: string) {\n  // Clean up the config file after each test", "export function setupConfigTestAfter(tempConfigPath: string) {\n  // Clean up the config file after each test\n  if (fs.existsSync(tempConfigPath)) {\n    fs.unlinkSync(tempConfigPath);\n  }\n}\n\nexport function mockGetConfig(tempConfigPath: string) {\n  jest.resetModules();\n  jest.mock('../src/config', () => {\n    const original = jest.requireActual('../src/config');\n    return {\n      ...original,\n      getConfig: () => original.getConfigFromPath(tempConfigPath),\n    };\n  });\n}\n", "export async function withTempConfig(tempConfig: Config, testFunc: () => Promise<void>) {\n  const tempConfigPath = setupConfigTestBefore(tempConfig);\n  mockGetConfig(tempConfigPath);\n  try {\n    await testFunc();\n  } finally {\n    setupConfigTestAfter(tempConfigPath);\n  }\n}\n\nexport function withOriginalGetConfig(testFunc: () => Promise<void>) {", "export function withOriginalGetConfig(testFunc: () => Promise<void>) {\n  jest.resetModules(); // Clear the Jest module cache\n  try {\n    return testFunc();\n  } finally {\n    jest.resetModules(); // Clear the Jest module cache again after the test execution\n  }\n}\n\nexport function createMockStatement(text: string, kind: SyntaxKind) {\n  return {\n    getText: () => text,\n    getFullText: () => text,\n    getKind: () => kind,\n    getParent: () => null,\n  };\n}", "export function createMockStatement(text: string, kind: SyntaxKind) {\n  return {\n    getText: () => text,\n    getFullText: () => text,\n    getKind: () => kind,\n    getParent: () => null,\n  };\n}"]}
{"filename": "test/createComponent.test.ts", "chunked_list": ["import fs from 'fs';\nimport { createComponent } from '../src/server/spells/create_component_spell';\nimport * as useAiModule from '../src/server/spells/use_ai_spell';\nimport { setupConfigTestAfter, setupConfigTestBefore, withOriginalGetConfig, withTempConfig } from './testHelpers';\nimport { getPathOf, sanitizeName } from '../src/server/util';\nimport { getConfig } from '../src/server/config';\n\njest.mock('fs', () => ({\n  ...jest.requireActual('fs'),\n  writeFileSync: jest.fn(),", "  ...jest.requireActual('fs'),\n  writeFileSync: jest.fn(),\n  existsSync: jest.fn(),\n  mkdirSync: jest.fn()\n}));\n\njest.mock('../src/server/spells/use_ai_spell', () => ({\n  useAi: jest.fn(),\n}));\n", "}));\n\nconst useAiMock = useAiModule.useAi as jest.Mock;\n\ndescribe('createComponent', () => {\n  let tempConfigPath = '';\n\n  beforeEach(() => {\n    tempConfigPath = setupConfigTestBefore({ ts: { compDir: 'components', configPath: 'tsconfig.json' } });\n    useAiMock.mockClear();", "    tempConfigPath = setupConfigTestBefore({ ts: { compDir: 'components', configPath: 'tsconfig.json' } });\n    useAiMock.mockClear();\n  });\n\n  afterEach(() => {\n    setupConfigTestAfter(tempConfigPath);\n  });\n\n  test('should throw error when ts.compDir is not set', async () => {\n    await withTempConfig({ ts: { compDir: '', configPath: 'tsconfig.json' } }, async () => {", "  test('should throw error when ts.compDir is not set', async () => {\n    await withTempConfig({ ts: { compDir: '', configPath: 'tsconfig.json' } }, async () => {\n      await expect(createComponent('Create a test component', 'user123')).rejects.toThrow('Missing ts.compDir.');\n    });\n  });\n\n  test('should create a new component', async () => {\n    await withOriginalGetConfig(async () => {\n      const config = getConfig();\n      const componentName = 'TestComponent';", "      const config = getConfig();\n      const componentName = 'TestComponent';\n      const componentContent = `\n          import React from 'react';\n      \n          function ${componentName}() {\n            return <div>${componentName}</div>;\n          }\n      \n          export default ${componentName};", "      \n          export default ${componentName};\n        `;\n\n      useAiMock.mockResolvedValue({ message: componentContent });\n\n      fs.writeFileSync = jest.fn()\n\n      await createComponent('Create a test component', 'user123');\n", "      await createComponent('Create a test component', 'user123');\n\n      const coreCompsPath = sanitizeName(config.ts.compDir);\n      const compFileDir = getPathOf(`${coreCompsPath}/${componentName}.tsx`);\n      const comment = `/* Created by user123, Create a test component */\\n`;\n\n      // Check if the directory was created\n      expect(fs.existsSync).toHaveBeenCalledWith(coreCompsPath);\n      expect(fs.mkdirSync).toHaveBeenCalledWith(coreCompsPath, { recursive: true });\n", "      expect(fs.mkdirSync).toHaveBeenCalledWith(coreCompsPath, { recursive: true });\n\n      expect(fs.writeFileSync).toHaveBeenCalledWith(compFileDir, `${comment}${componentContent}`)\n\n    });\n  });\n\n  test('should return an error message if the component cannot be created', async () => {\n    const invalidComponentContent = `import React from 'react';`;\n    useAiMock.mockResolvedValue({ message: invalidComponentContent });", "    const invalidComponentContent = `import React from 'react';`;\n    useAiMock.mockResolvedValue({ message: invalidComponentContent });\n    const result = await createComponent('Create an invalid component', 'user123');\n    expect(result).toBe('unable to create a component ' + invalidComponentContent);\n  });\n});\n"]}
{"filename": "test/logAiResult.test.ts", "chunked_list": ["import fs from 'fs';\nimport { ChatResponse } from '../src/lib/types';\nimport { IPrompts } from '../src/lib/prompts';\n\nimport { logAiResult } from '../src/server/stats';\nimport { GuidedEditResponse } from '../src/lib/prompts/guided_edit_prompt';\n\ndescribe('logAiResult', () => {\n  const logFilePath = './testLogFile.log';\n  const configSpy = jest.spyOn(require('../src/server/config'), 'getConfig');", "  const logFilePath = './testLogFile.log';\n  const configSpy = jest.spyOn(require('../src/server/config'), 'getConfig');\n  configSpy.mockReturnValue({ ai: { logFile: logFilePath } });\n\n  afterEach(() => {\n    if (fs.existsSync(logFilePath)) {\n      fs.unlinkSync(logFilePath);\n    }\n  });\n\n  test('should append a line to the log file with the correct metrics', () => {\n    const chatResponse: ChatResponse<GuidedEditResponse> = {\n      successful: true,\n      timestamp: new Date(),\n      failures: [''],\n      rawResponses: [''],\n      prompts: ['test'],\n      model: 'testModel',\n      message: [{ \"above_9\": \"yep\" }],\n      supportingText: 'testSupportingText',\n      promptTemplate: 'testTemplate',\n      promptType: IPrompts.GUIDED_EDIT,\n    };\n\n    const expectedLogLine = {\n      pass: chatResponse.successful,\n      timestamp: chatResponse.timestamp.toISOString(),\n      duration: expect.any(Number),\n      prompts: chatResponse.prompts,\n      model: chatResponse.model,\n      data: { message: chatResponse.message, supportingText: chatResponse.supportingText },\n      failures: chatResponse.failures,\n      rawResponses: chatResponse.rawResponses,\n      template: chatResponse.promptTemplate,\n      type: chatResponse.promptType,\n    };\n\n    logAiResult<GuidedEditResponse>(chatResponse);\n\n    const logFileContent = fs.readFileSync(logFilePath, { encoding: 'utf-8' });\n    const loggedMetrics = JSON.parse(logFileContent);\n\n    console.log({ expectedLogLine, loggedMetrics })\n\n    expect(loggedMetrics).toEqual(expectedLogLine);\n  });\n});"]}
{"filename": "test/config.test.ts", "chunked_list": ["import fs from 'fs';\nimport { getConfig, defaultConfig } from '../src/server/config';\nimport type { Config } from '../src/lib/types';\nimport { setupConfigTestBefore, setupConfigTestAfter, withTempConfig, withOriginalGetConfig } from './testHelpers';\n\ndescribe('getConfig', () => {\n  let tempConfigPath = '';\n  beforeEach(() => {\n    tempConfigPath = setupConfigTestBefore();\n  });", "    tempConfigPath = setupConfigTestBefore();\n  });\n\n  afterEach(() => {\n    setupConfigTestAfter(tempConfigPath);\n  });  \n\n  it('returns default config values when config file does not exist', async () => {\n    // Remove the config file\n    await withOriginalGetConfig(async () => {", "    // Remove the config file\n    await withOriginalGetConfig(async () => {\n      await withTempConfig(defaultConfig, async () => {\n        fs.unlinkSync(tempConfigPath);\n        const config = getConfig();\n        expect(config).toEqual(defaultConfig);\n      })\n    });\n  });\n", "  });\n\n  it('returns config values when config file exists', async () => {\n\n    const expectedConfig: Config = {\n      ai: { retries: '3', logFile: 'results.json' },\n      ts: { configPath: 'config', typeDir: 'types', compDir: 'components' },\n      git: { rootPath: 'root', source: 'dev', remote: 'origin' },\n      user: { name: 'John Doe' },\n    };", "      user: { name: 'John Doe' },\n    };\n    await withOriginalGetConfig(async () => {\n      await withTempConfig(expectedConfig, async () => {\n        const config = getConfig();\n        expect(config).toEqual(expectedConfig);\n      });\n    });\n  });\n});", "  });\n});\n"]}
{"filename": "test/createApi.test.ts", "chunked_list": ["import fs from 'fs';\nimport { getPathOf, sanitizeName, toSnakeCase, toTitleCase } from '../src/server/util';\nimport {\n  setupChatResponse,\n  setupCommonMocks,\n  setupConfigTestBefore,\n  setupConfigTestAfter,\n  mockGetConfig,\n  withTempConfig,\n  withOriginalGetConfig,", "  withTempConfig,\n  withOriginalGetConfig,\n} from './testHelpers';\nimport * as useAiModule from '../src/server/spells/use_ai_spell';\n\nsetupChatResponse('const testTypeApi = { ...');\nsetupCommonMocks();\n\nimport { createApi } from '../src/server/spells';\nimport { getConfig } from '../src/server/config';", "import { createApi } from '../src/server/spells';\nimport { getConfig } from '../src/server/config';\n\njest.mock('fs', () => ({\n  ...jest.requireActual('fs'),\n  appendFileSync: jest.fn(),\n}));\n\njest.mock('../src/server/spells/use_ai_spell', () => ({\n  useAi: jest.fn(),", "jest.mock('../src/server/spells/use_ai_spell', () => ({\n  useAi: jest.fn(),\n}));\n\nconst useAiMock = useAiModule.useAi as jest.Mock;\n\ndescribe('createApi', () => {\n  let tempConfigPath = '';\n\n  beforeEach(() => {", "\n  beforeEach(() => {\n    tempConfigPath = setupConfigTestBefore({ ai: { retries : '3' }, ts: { typeDir: 'types', configPath: 'tsconfig.json' } });\n    mockGetConfig(tempConfigPath);\n    useAiMock.mockClear();\n  });\n\n  afterEach(() => {\n    setupConfigTestAfter(tempConfigPath);\n  });", "    setupConfigTestAfter(tempConfigPath);\n  });\n\n  test('should work by passing normal parameters for chat completion', async () => {\n    useAiMock.mockResolvedValue({ message: 'const testTypeApi = { ...' });\n    const response = await createApi('ITestTypeName', 'userName');\n    expect(useAiMock).toHaveBeenCalled();\n    expect(response).toBe('const testTypeApi = { ...');\n  });\n", "  });\n\n  test('should throw error when ts.typeDir is not set', async () => {\n    await withTempConfig({ ai: { retries: '3' }, ts: { configPath: 'tsconfig.json' } }, async () => {\n      await expect(createApi('ITestTypeName', 'userName')).rejects.toThrow('Missing ts.typeDir.');\n    });\n  });\n\n  test('should append the generated API to the correct file', async () => {\n    await withOriginalGetConfig(async () => {", "  test('should append the generated API to the correct file', async () => {\n    await withOriginalGetConfig(async () => {\n      await withTempConfig({ ai: { retries: '3' }, ts: { typeDir: 'types' } }, async () => {\n        const config = getConfig();\n        const typeName = 'ITestTypeName';\n        const generatedType = 'type ITestTypeName = {';\n        const coreTypesPath = sanitizeName(config.ts.typeDir);\n        const typeFilePath = getPathOf(`${coreTypesPath}/${toSnakeCase(typeName)}.ts`);\n        const comment = `/*\\n* @category ${toTitleCase(typeName)}\\n*/\\n`;\n        const generatedApi = 'const testTypeApi = { ...';\n        await createApi(typeName, generatedType);\n        expect(fs.appendFileSync).toHaveBeenCalledWith(typeFilePath, `${comment}${generatedApi}\\n\\n`);\n      });\n    });\n  });\n\n});\n"]}
{"filename": "test/useAi.test.ts", "chunked_list": ["import { IPrompts } from '../src/lib/prompts';\nimport { setupCommonMocks, setupChatResponse, setupCompletionResponse, setupModerationResponse, openai, setupConfigTestBefore, setupConfigTestAfter } from './testHelpers';\n\nsetupChatResponse('&&&Some text@@@[{ \"statement_0\": \"some code \" }]@@@Some other text&&&');\nsetupCompletionResponse('test completion response');\nsetupModerationResponse(false);\nsetupCommonMocks();\n\njest.mock('fs', () => ({\n  ...jest.requireActual('fs'),", "jest.mock('fs', () => ({\n  ...jest.requireActual('fs'),\n  appendFileSync: jest.fn()\n}));\n\nimport { useAi } from '../src/server/spells/use_ai_spell';\nimport { GuidedEditResponse } from '../src/lib/prompts/guided_edit_prompt';\n\ndescribe('useAi', () => {\n  let tempConfigPath = '';", "describe('useAi', () => {\n  let tempConfigPath = '';\n\n  beforeEach(() => {\n    tempConfigPath = setupConfigTestBefore({ ai: { retries: '3' }, ts: { typeDir: '../../types', configPath: 'tsconfig.json' } });\n    jest.clearAllMocks();\n  });\n\n  afterEach(() => {\n    setupConfigTestAfter(tempConfigPath);", "  afterEach(() => {\n    setupConfigTestAfter(tempConfigPath);\n  });\n\n  test('should return a chat response when promptType is a chat prompt', async () => {\n    const response = await useAi<GuidedEditResponse>(IPrompts.GUIDED_EDIT, 'Profile.tsx make the profile picture round instead of square.');\n    expect(response.message).toStrictEqual([{ \"statement_0\": \"some code \"}]);\n  });\n\n  test('should return a completion response when promptType is a completion prompt', async () => {", "\n  test('should return a completion response when promptType is a completion prompt', async () => {\n    const response = await useAi<string>(IPrompts.SUGGEST_SERVICE, 'the downtown learning center at the U library');\n    expect(response.message).toBe('test completion response');\n  });\n\n  test('should return a moderation response when promptType is not provided', async () => {\n    const response = await useAi<boolean>(undefined, 'test');\n    expect(response.flagged).toBe(false);\n  });", "    expect(response.flagged).toBe(false);\n  });\n\n  test('should throw an error when all parsing attempts fail', async () => {\n    openai.createChatCompletion.mockImplementation(() => ({\n      data: { choices: [{ message: { content: '&&&Some text@invalid json}@@@Some other text&&&' } }] },\n    }));\n\n    await expect(useAi<GuidedEditResponse>(IPrompts.GUIDED_EDIT, 'testfile.tsx', 'add comments throughout the file')).rejects.toThrowError();\n  });", "    await expect(useAi<GuidedEditResponse>(IPrompts.GUIDED_EDIT, 'testfile.tsx', 'add comments throughout the file')).rejects.toThrowError();\n  });\n});\n"]}
{"filename": "test/createApiBackend.test.ts", "chunked_list": ["import * as useAiModule from '../src/server/spells/use_ai_spell';\nimport { getConfig } from '../src/server/config';\nimport { setupConfigTestBefore, setupConfigTestAfter, withTempConfig } from './testHelpers';\nimport { getPathOf, toSnakeCase, toTitleCase } from '../src/server/util';\nimport { Project } from 'ts-morph';\n\njest.mock('fs', () => ({\n  ...jest.requireActual('fs'),\n  appendFileSync: jest.fn(),\n}));", "  appendFileSync: jest.fn(),\n}));\n\n// Mock the useAi function\njest.mock('../src/server/spells/use_ai_spell', () => ({\n  useAi: jest.fn(),\n}));\n\nconst useAiMock = useAiModule.useAi as jest.Mock;\n", "const useAiMock = useAiModule.useAi as jest.Mock;\n\nimport { createApiBackend } from '../src/server/spells';\n\ndescribe('createApiBackend', () => {\n  let tempConfigPath = '';\n\n  beforeEach(() => {\n    tempConfigPath = setupConfigTestBefore({ ts: { typeDir: 'types', configPath: 'tsconfig.json' } });\n  });", "    tempConfigPath = setupConfigTestBefore({ ts: { typeDir: 'types', configPath: 'tsconfig.json' } });\n  });\n\n  afterEach(() => {\n    setupConfigTestAfter(tempConfigPath);\n  });\n\n  test('should throw error when ts.configPath is not set', async () => {\n    await withTempConfig({ ts: { configPath: '' } }, async () => {\n      await expect(createApiBackend('ISomeTypeName', 'GeneratedType')).rejects.toThrow('Missing ts.configPath.');", "    await withTempConfig({ ts: { configPath: '' } }, async () => {\n      await expect(createApiBackend('ISomeTypeName', 'GeneratedType')).rejects.toThrow('Missing ts.configPath.');\n    });\n  });\n\n  test('should generate the API backend correctly and append it to the file', async () => {\n    await withTempConfig({ ts: { typeDir: 'types', configPath: 'tsconfig.json' } }, async () => {\n      const typeName = 'ITestType';\n      const generatedType = 'GeneratedType';\n      const config = getConfig();", "      const generatedType = 'GeneratedType';\n      const config = getConfig();\n      useAiMock.mockResolvedValue({ message: generatedType });\n      const coreTypesPath = getPathOf(`${config.ts.configPath}/${toSnakeCase(typeName)}.ts`);\n      const comment = `/*\\n* @category ${toTitleCase(typeName)}\\n*/\\n`;\n  \n      const addSourceFileAtPathMock = jest.fn().mockReturnValue({\n        getVariableDeclarations: jest.fn().mockReturnValue([]),\n        insertText: jest.fn(),\n        fixMissingImports: jest.fn(),", "        insertText: jest.fn(),\n        fixMissingImports: jest.fn(),\n        getEnd: jest.fn()\n      });\n      const saveMock = jest.fn();\n      jest.spyOn(Project.prototype, 'addSourceFileAtPath').mockImplementation(addSourceFileAtPathMock);\n      jest.spyOn(Project.prototype, 'save').mockImplementation(saveMock);\n      \n      // Re-import the project module to use the mocked version\n      jest.resetModules();\n      require('ts-morph');\n  \n      await createApiBackend(typeName, generatedType);\n  \n      const project = new Project();\n      const sourceFile = project.addSourceFileAtPath(coreTypesPath);\n      expect(sourceFile).toBeTruthy();\n      expect(sourceFile.insertText).toHaveBeenCalledWith(sourceFile.getEnd(), `${comment}${generatedType}\\n\\n`);\n      expect(sourceFile.fixMissingImports).toHaveBeenCalled();\n      expect(project.save).toHaveBeenCalled();\n    });\n  });\n});\n", "      // Re-import the project module to use the mocked version\n      jest.resetModules();\n      require('ts-morph');\n  \n      await createApiBackend(typeName, generatedType);\n  \n      const project = new Project();\n      const sourceFile = project.addSourceFileAtPath(coreTypesPath);\n      expect(sourceFile).toBeTruthy();\n      expect(sourceFile.insertText).toHaveBeenCalledWith(sourceFile.getEnd(), `${comment}${generatedType}\\n\\n`);\n      expect(sourceFile.fixMissingImports).toHaveBeenCalled();\n      expect(project.save).toHaveBeenCalled();\n    });\n  });\n});\n"]}
{"filename": "test/request.test.ts", "chunked_list": ["import { openai, setupChatResponse, setupCompletionResponse, setupModerationResponse, setupCommonMocks } from './testHelpers';\n\nsetupChatResponse('&&&Some text@@@[{ \"statement_0\": \"some code \" }]@@@Some other text&&&');\nsetupCompletionResponse('test completion response');\nsetupModerationResponse(false);\nsetupCommonMocks();\n\nimport { buildOpenAIRequest, performRequest, openAIRequestOptions } from '../src/server/request';\nimport { CreateModerationRequest, CreateChatCompletionRequest, CreateCompletionRequest } from 'openai';\nimport { IPrompts } from '../src/lib/prompts';", "import { CreateModerationRequest, CreateChatCompletionRequest, CreateCompletionRequest } from 'openai';\nimport { IPrompts } from '../src/lib/prompts';\nimport { isChatRequest } from '../src/server/util';\n\ndescribe('buildOpenAIRequest', () => {\n  test('should return moderation request when promptType is not provided', () => {\n    const prompts = ['test'];\n    const [result] = buildOpenAIRequest(prompts);\n    const expected: CreateModerationRequest = {\n      input: prompts[0],", "    const expected: CreateModerationRequest = {\n      input: prompts[0],\n    };\n    expect(result).toEqual(expected);\n  });\n\n  test('should return chat request when promptType is provided and a chat request is expected', () => {\n    const prompts = ['test'];\n    const [result] = buildOpenAIRequest(prompts, IPrompts.CREATE_API);\n    expect(isChatRequest(result)).toBeTruthy();", "    const [result] = buildOpenAIRequest(prompts, IPrompts.CREATE_API);\n    expect(isChatRequest(result)).toBeTruthy();\n  });\n});\n\ndescribe('performRequest', () => {\n  const chatRequest: CreateChatCompletionRequest = {\n    model: 'gpt-3.5-turbo',\n    messages: [{ role: 'system', content: 'test' }],\n  };", "    messages: [{ role: 'system', content: 'test' }],\n  };\n  const completionRequest: CreateCompletionRequest = {\n    model: 'ada',\n    prompt: 'test'\n  };\n  const moderationRequest: CreateModerationRequest = {\n    input: 'test'\n  };\n", "  };\n\n  test('should call createChatCompletion for chat requests', async () => {\n    await performRequest(chatRequest);\n    expect(openai.createChatCompletion).toHaveBeenCalledWith(chatRequest, openAIRequestOptions);\n  });\n\n  test('should call createCompletion for completion requests', async () => {\n    await performRequest(completionRequest);\n    expect(openai.createCompletion).toHaveBeenCalledWith(completionRequest, openAIRequestOptions);", "    await performRequest(completionRequest);\n    expect(openai.createCompletion).toHaveBeenCalledWith(completionRequest, openAIRequestOptions);\n  });\n\n  test('should call createModeration for moderation requests', async () => {\n    await performRequest(moderationRequest);\n    expect(openai.createModeration).toHaveBeenCalledWith(moderationRequest, openAIRequestOptions);\n  });\n\n  test('should return chat response for chat requests', async () => {", "\n  test('should return chat response for chat requests', async () => {\n    const response = await performRequest(chatRequest);\n    expect(response).toEqual('&&&Some text@@@[{ \"statement_0\": \"some code \" }]@@@Some other text&&&');\n  });\n\n  test('should return completion response for completion requests', async () => {\n    const response = await performRequest(completionRequest);\n    expect(response).toEqual('test completion response');\n  });", "    expect(response).toEqual('test completion response');\n  });\n\n  test('should return moderation response for moderation requests', async () => {\n    const response = await performRequest(moderationRequest);\n    expect(response).toEqual(false);\n  });\n});\n", ""]}
{"filename": "src/lib/languages.ts", "chunked_list": ["import type { LanguageParser } from \"./types\";\n\nconst languages: Record<string, LanguageParser> = {\n  Ada: {\n    fileExtension: [\"adb\", \"ads\"],\n    parserName: \"tree-sitter-ada\",\n  },\n  Agda: {\n    fileExtension: [\"agda\"],\n    parserName: \"tree-sitter-agda\",", "    fileExtension: [\"agda\"],\n    parserName: \"tree-sitter-agda\",\n  },\n  Apex: {\n    fileExtension: [\"cls\", \"trigger\"],\n    parserName: \"tree-sitter-apex\",\n  },\n  Bash: {\n    fileExtension: [\"sh\", \"bash\"],\n    parserName: \"tree-sitter-bash\",", "    fileExtension: [\"sh\", \"bash\"],\n    parserName: \"tree-sitter-bash\",\n  },\n  Beancount: {\n    fileExtension: [\"beancount\"],\n    parserName: \"tree-sitter-beancount\",\n  },\n  CapnProto: {\n    fileExtension: [\"capnp\"],\n    parserName: \"tree-sitter-capnp\",", "    fileExtension: [\"capnp\"],\n    parserName: \"tree-sitter-capnp\",\n  },\n  C: {\n    fileExtension: [\"c\"],\n    parserName: \"tree-sitter-c\",\n  },\n  CPP: {\n    fileExtension: [\"cpp\", \"cc\", \"cxx\", \"c++\", \"h\", \"hpp\", \"hh\", \"hxx\", \"h++\"],\n    parserName: \"tree-sitter-cpp\",", "    fileExtension: [\"cpp\", \"cc\", \"cxx\", \"c++\", \"h\", \"hpp\", \"hh\", \"hxx\", \"h++\"],\n    parserName: \"tree-sitter-cpp\",\n  },\n  CSharp: {\n    fileExtension: [\"cs\"],\n    parserName: \"tree-sitter-c-sharp\",\n  },\n  Clojure: {\n    fileExtension: [\"clj\", \"cljs\", \"cljc\", \"edn\"],\n    parserName: \"tree-sitter-clojure\",", "    fileExtension: [\"clj\", \"cljs\", \"cljc\", \"edn\"],\n    parserName: \"tree-sitter-clojure\",\n  },\n  CMake: {\n    fileExtension: [\"cmake\", \"CMakeLists.txt\"],\n    parserName: \"tree-sitter-cmake\",\n  },\n  // Comment: {\n  //   fileExtension: [\"unknown\"], // Not specific to any file extension\n  //   parserName: \"tree-sitter-comment\",", "  //   fileExtension: [\"unknown\"], // Not specific to any file extension\n  //   parserName: \"tree-sitter-comment\",\n  // },\n  CommonLisp: {\n    fileExtension: [\"lisp\", \"lsp\", \"l\", \"cl\", \"mud\"],\n    parserName: \"tree-sitter-commonlisp\",\n  },\n  CSS: {\n    fileExtension: [\"css\"],\n    parserName: \"tree-sitter-css\",", "    fileExtension: [\"css\"],\n    parserName: \"tree-sitter-css\",\n  },\n  CUDA: {\n    fileExtension: [\"cu\", \"cuh\"],\n    parserName: \"tree-sitter-cuda\",\n  },\n  Dart: {\n    fileExtension: [\"dart\"],\n    parserName: \"tree-sitter-dart\",", "    fileExtension: [\"dart\"],\n    parserName: \"tree-sitter-dart\",\n  },\n  D: {\n    fileExtension: [\"d\"],\n    parserName: \"tree-sitter-d\",\n  },\n  Dockerfile: {\n    fileExtension: [\"Dockerfile\"],\n    parserName: \"tree-sitter-dockerfile\",", "    fileExtension: [\"Dockerfile\"],\n    parserName: \"tree-sitter-dockerfile\",\n  },\n  DOT: {\n    fileExtension: [\"dot\"],\n    parserName: \"tree-sitter-graphviz\",\n  },\n  Elixir: {\n    fileExtension: [\"ex\", \"exs\"],\n    parserName: \"tree-sitter-elixir\",", "    fileExtension: [\"ex\", \"exs\"],\n    parserName: \"tree-sitter-elixir\",\n  },\n  Elm: {\n    fileExtension: [\"elm\"],\n    parserName: \"tree-sitter-elm\",\n  },\n  EmacsLisp: {\n    fileExtension: [\"el\"],\n    parserName: \"tree-sitter-emacs-lisp\",", "    fileExtension: [\"el\"],\n    parserName: \"tree-sitter-emacs-lisp\",\n  },\n  Eno: {\n    fileExtension: [\"eno\"],\n    parserName: \"tree-sitter-eno\",\n  },\n  ERB_EJS: {\n    fileExtension: [\"erb\", \"ejs\"],\n    parserName: \"tree-sitter-embedded-template\",", "    fileExtension: [\"erb\", \"ejs\"],\n    parserName: \"tree-sitter-embedded-template\",\n  },\n  Erlang: {\n    fileExtension: [\"erl\", \"hrl\"],\n    parserName: \"tree-sitter-erlang\",\n  },\n  Fennel: {\n    fileExtension: [\"fnl\"],\n    parserName: \"tree-sitter-fennel\"", "    fileExtension: [\"fnl\"],\n    parserName: \"tree-sitter-fennel\"\n  },\n  Fish: {\n    fileExtension: [\"fish\"],\n    parserName: \"tree-sitter-fish\"\n  },\n  Fortran: {\n    fileExtension: [\"f\", \"f90\", \"f95\"],\n    parserName: \"tree-sitter-fortran\"", "    fileExtension: [\"f\", \"f90\", \"f95\"],\n    parserName: \"tree-sitter-fortran\"\n  },\n  Gleam: {\n    fileExtension: [\"gleam\"],\n    parserName: \"tree-sitter-gleam\"\n  },\n  GLSL: {\n    fileExtension: [\"glsl\", \"vert\", \"frag\", \"geom\"],\n    parserName: \"tree-sitter-glsl\"", "    fileExtension: [\"glsl\", \"vert\", \"frag\", \"geom\"],\n    parserName: \"tree-sitter-glsl\"\n  },\n  Go: {\n    fileExtension: [\"go\"],\n    parserName: \"tree-sitter-go\"\n  },\n  Graphql: {\n    fileExtension: [\"graphql\"],\n    parserName: \"tree-sitter-graphql\"", "    fileExtension: [\"graphql\"],\n    parserName: \"tree-sitter-graphql\"\n  },\n  Hack: {\n    fileExtension: [\"hack\"],\n    parserName: \"tree-sitter-hack\"\n  },\n  Haskell: {\n    fileExtension: [\"hs\",\"lhs\"],\n    parserName: \"tree-sitter-haskell\"", "    fileExtension: [\"hs\",\"lhs\"],\n    parserName: \"tree-sitter-haskell\"\n  },\n  HCL: {\n    fileExtension: [\"hcl\"],\n    parserName: \"tree-sitter-hcl\"\n  },\n  HTML: {\n    fileExtension: [\"html\"],\n    parserName: \"tree-sitter-html\"", "    fileExtension: [\"html\"],\n    parserName: \"tree-sitter-html\"\n  },\n  Java: {\n    fileExtension: [\"java\"],\n    parserName: \"tree-sitter-java\"\n  },\n  JavaScript: {\n    fileExtension: [\"js\", \"jsx\"],\n    parserName: \"tree-sitter-javascript\"", "    fileExtension: [\"js\", \"jsx\"],\n    parserName: \"tree-sitter-javascript\"\n  },\n  jq: {\n    fileExtension: [\"jq\"],\n    parserName: \"tree-sitter-jq\"\n  },\n  JSON5: {\n    fileExtension: [\"json5\"],\n    parserName: \"tree-sitter-json5\"", "    fileExtension: [\"json5\"],\n    parserName: \"tree-sitter-json5\"\n  },\n  JSON: {\n    fileExtension: [\"json\"],\n    parserName: \"tree-sitter-json\"\n  },\n  Julia: {\n    fileExtension: [\"jl\"],\n    parserName: \"tree-sitter-julia\"", "    fileExtension: [\"jl\"],\n    parserName: \"tree-sitter-julia\"\n  },\n  Kotlin: {\n    fileExtension: [\"kt\", \"kts\"],\n    parserName: \"tree-sitter-kotlin\"\n  },\n  LALRPOP: {\n    fileExtension: [\"lalrpop\"],\n    parserName: \"tree-sitter-lalrpop\"", "    fileExtension: [\"lalrpop\"],\n    parserName: \"tree-sitter-lalrpop\"\n  },\n  Latex: {\n    fileExtension: [\"tex\", \"sty\", \"cls\"],\n    parserName: \"tree-sitter-latex\"\n  },\n  Lean: {\n    fileExtension: [\"lean\"],\n    parserName: \"tree-sitter-lean\"", "    fileExtension: [\"lean\"],\n    parserName: \"tree-sitter-lean\"\n  },\n  LLVM: {\n    fileExtension: [\"ll\"],\n    parserName: \"tree-sitter-llvm\"\n  },\n  LLVM_MachineIR: {\n    fileExtension: [\"mir\"],\n    parserName: \"tree-sitter-llvm-mir\"", "    fileExtension: [\"mir\"],\n    parserName: \"tree-sitter-llvm-mir\"\n  },\n  LLVM_TableGen: {\n    fileExtension: [\"td\"],\n    parserName: \"tree-sitter-llvm-td\"\n  },\n  Lua: {\n    fileExtension: [\"lua\"],\n    parserName: \"tree-sitter-lua\"", "    fileExtension: [\"lua\"],\n    parserName: \"tree-sitter-lua\"\n  },\n  Make: {\n    fileExtension: [\"makefile\"],\n    parserName: \"tree-sitter-make\"\n  },\n  Markdown: {\n    fileExtension: [\"md\", \"markdown\"],\n    parserName: \"tree-sitter-markdown\"", "    fileExtension: [\"md\", \"markdown\"],\n    parserName: \"tree-sitter-markdown\"\n  },\n  Meson: {\n    fileExtension: [\"meson.build\"],\n    parserName: \"tree-sitter-meson\"\n  },\n  Motorola68000Assembly: {\n    fileExtension: [\"s\"],\n    parserName: \"tree-sitter-m68k\"", "    fileExtension: [\"s\"],\n    parserName: \"tree-sitter-m68k\"\n  },\n  Nix: {\n    fileExtension: [\"nix\"],\n    parserName: \"tree-sitter-nix\"\n  },\n  ObjectiveC: {\n    fileExtension: [\"m\", \"h\"],\n    parserName: \"tree-sitter-objc\"", "    fileExtension: [\"m\", \"h\"],\n    parserName: \"tree-sitter-objc\"\n  },\n  OCaml: {\n    fileExtension: [\"ml\", \"mli\"],\n    parserName: \"tree-sitter-ocaml\"\n  },\n  Org: {\n    fileExtension: [\"org\"],\n    parserName: \"tree-sitter-org\"", "    fileExtension: [\"org\"],\n    parserName: \"tree-sitter-org\"\n  },\n  Pascal: {\n    fileExtension: [\"pas\"],\n    parserName: \"tree-sitter-pascal\"\n  },\n  Perl: {\n    fileExtension: [\"pl\", \"pm\"],\n    parserName: \"tree-sitter-perl\"", "    fileExtension: [\"pl\", \"pm\"],\n    parserName: \"tree-sitter-perl\"\n  },\n  PerlPOD: {\n    fileExtension: [\"pod\"],\n    parserName: \"tree-sitter-pod\"\n  },\n  PHP: {\n    fileExtension: [\"php\"],\n    parserName: \"tree-sitter-php\"", "    fileExtension: [\"php\"],\n    parserName: \"tree-sitter-php\"\n  },\n  PowerShell: {\n    fileExtension: [\"ps1\"],\n    parserName: \"tree-sitter-powershell\"\n  },\n  ProtocolBuffers: {\n    fileExtension: [\"proto\"],\n    parserName: \"tree-sitter-protobuf\"", "    fileExtension: [\"proto\"],\n    parserName: \"tree-sitter-protobuf\"\n  },\n  Python: {\n    fileExtension: [\"py\"],\n    parserName: \"tree-sitter-python\"\n  },\n  QML: {\n    fileExtension: [\"qml\"],\n    parserName: \"tree-sitter-qml\"", "    fileExtension: [\"qml\"],\n    parserName: \"tree-sitter-qml\"\n  },\n  Racket: {\n    fileExtension: [\"rkt\"],\n    parserName: \"tree-sitter-racket\"\n  },\n  Rasi: {\n    fileExtension: [\"rasi\"],\n    parserName: \"tree-sitter-rofi\"", "    fileExtension: [\"rasi\"],\n    parserName: \"tree-sitter-rofi\"\n  },\n  re2c: {\n    fileExtension: [\"re\"],\n    parserName: \"tree-sitter-re2c\"\n  },\n  Regex: {\n    fileExtension: [\"regex\"],\n    parserName: \"tree-sitter-regex\"", "    fileExtension: [\"regex\"],\n    parserName: \"tree-sitter-regex\"\n  },\n  Rego: {\n    fileExtension: [\"rego\"],\n    parserName: \"tree-sitter-rego\"\n  },\n  reStructuredText: {\n    fileExtension: [\"rst\"],\n    parserName: \"tree-sitter-rst\"", "    fileExtension: [\"rst\"],\n    parserName: \"tree-sitter-rst\"\n  },\n  R: {\n    fileExtension: [\"r\"],\n    parserName: \"tree-sitter-r\"\n  },\n  Ruby: {\n    fileExtension: [\"rb\"],\n    parserName: \"tree-sitter-ruby\"", "    fileExtension: [\"rb\"],\n    parserName: \"tree-sitter-ruby\"\n  },\n  Rust: {\n    fileExtension: [\"rs\"],\n    parserName: \"tree-sitter-rust\"\n  },\n  Scala: {\n    fileExtension: [\"scala\"],\n    parserName: \"tree-sitter-scala\"", "    fileExtension: [\"scala\"],\n    parserName: \"tree-sitter-scala\"\n  },\n  Scheme: {\n    fileExtension: [\"scm\", \"ss\"],\n    parserName: \"tree-sitter-scheme\"\n  },\n  Scss: {\n    fileExtension: [\"scss\"],\n    parserName: \"tree-sitter-scss\"", "    fileExtension: [\"scss\"],\n    parserName: \"tree-sitter-scss\"\n  },\n  Sexpressions: {\n    fileExtension: [\"sexp\"],\n    parserName: \"tree-sitter-sexp\"\n  },\n  Smali: {\n    fileExtension: [\"smali\"],\n    parserName: \"tree-sitter-smali\"", "    fileExtension: [\"smali\"],\n    parserName: \"tree-sitter-smali\"\n  },\n  Sourcepawn: {\n    fileExtension: [\"sp\"],\n    parserName: \"tree-sitter-sourcepawn\"\n  },\n  SPARQL: {\n    fileExtension: [\"rq\"],\n    parserName: \"tree-sitter-sparql\"", "    fileExtension: [\"rq\"],\n    parserName: \"tree-sitter-sparql\"\n  },\n  SQL_BigQuery: {\n    fileExtension: [\"sql\"],\n    parserName: \"tree-sitter-sql\"\n  },\n  SQL_PostgreSQL: {\n    fileExtension: [\"pgsql\"],\n    parserName: \"tree-sitter-sql\"", "    fileExtension: [\"pgsql\"],\n    parserName: \"tree-sitter-sql\"\n  },\n  SQL_SQLite: {\n    fileExtension: [\"sqlite\"],\n    parserName: \"tree-sitter-sql\"\n  },\n  SSH: {\n    fileExtension: [\"sshconfig\"],\n    parserName: \"tree-sitter-ssh\"", "    fileExtension: [\"sshconfig\"],\n    parserName: \"tree-sitter-ssh\"\n  },\n  Svelte: {\n    fileExtension: [\"svelte\"],\n    parserName: \"tree-sitter-svelte\"\n  },\n  Swift: {\n    fileExtension: [\"swift\"],\n    parserName: \"tree-sitter-swift\"", "    fileExtension: [\"swift\"],\n    parserName: \"tree-sitter-swift\"\n  },\n  SystemRDL: {\n    fileExtension: [\"rdl\"],\n    parserName: \"tree-sitter-systemrdl\"\n  },\n  Thrift: {\n    fileExtension: [\"thrift\"],\n    parserName: \"tree-sitter-thrift\"", "    fileExtension: [\"thrift\"],\n    parserName: \"tree-sitter-thrift\"\n  },\n  TOML: {\n    fileExtension: [\"toml\"],\n    parserName: \"tree-sitter-toml\"\n  },\n  Turtle: {\n    fileExtension: [\"ttl\"],\n    parserName: \"tree-sitter-turtle\"", "    fileExtension: [\"ttl\"],\n    parserName: \"tree-sitter-turtle\"\n  },\n  Twig: {\n    fileExtension: [\"twig\"],\n    parserName: \"tree-sitter-twig\"\n  },\n  TSX: {\n    fileExtension: [\"tsx\"],\n    parserName: \"tree-sitter-typescript\",", "    fileExtension: [\"tsx\"],\n    parserName: \"tree-sitter-typescript\",\n    parserVariant: \"tsx\"\n  },\n  TypeScript: {\n    fileExtension: [\"ts\"],\n    parserName: \"tree-sitter-typescript\",\n    parserVariant: \"typescript\"\n  },\n  Verilog: {", "  },\n  Verilog: {\n    fileExtension: [\"v\", \"sv\", \"svh\"],\n    parserName: \"tree-sitter-verilog\"\n  },\n  VHDL: {\n    fileExtension: [\"vhdl\", \"vhd\", \"vhf\", \"vhi\", \"vho\", \"vhs\", \"vht\", \"vhw\"],\n    parserName: \"tree-sitter-vhdl\"\n  },\n  Vue: {", "  },\n  Vue: {\n    fileExtension: [\"vue\"],\n    parserName: \"tree-sitter-vue\"\n  },\n  WASM: {\n    fileExtension: [\"wat\", \"wasm\"],\n    parserName: \"tree-sitter-wasm\"\n  },\n  YAML: {", "  },\n  YAML: {\n    fileExtension: [\"yaml\", \"yml\"],\n    parserName: \"tree-sitter-yaml\"\n  },\n  YANG: {\n    fileExtension: [\"yang\"],\n    parserName: \"tree-sitter-yang\"\n  },\n  Zig: {", "  },\n  Zig: {\n    fileExtension: [\"zig\"],\n    parserName: \"tree-sitter-zig\"\n  },\n}\n\nexport default languages;"]}
{"filename": "src/lib/types.ts", "chunked_list": ["\nexport type ConfigPropTypes = string;\nexport type Config<T = Record<string, Record<string, ConfigPropTypes>>> = T;\nexport type CurrentType = ConfigPropTypes | Config;\n\nexport type GuardValidations = Record<string, unknown> | Record<string, unknown>[] | string\n\n\nexport type OpenAIResults = {\n  model?: string;\n  timestamp: Date;\n  prompts?: string[];\n  promptType: string;\n  promptTemplate: string | undefined;\n  rawResponses: (string | boolean | undefined)[];\n  failures: string[];\n  successful: boolean;\n}\n", "export type OpenAIResults = {\n  model?: string;\n  timestamp: Date;\n  prompts?: string[];\n  promptType: string;\n  promptTemplate: string | undefined;\n  rawResponses: (string | boolean | undefined)[];\n  failures: string[];\n  successful: boolean;\n}\n", "export type ChatResponse<T> = OpenAIResults & {\n  supportingText?: string;\n  message: T;\n}\n\nexport type CompletionResponse = OpenAIResults & {\n  message: string;\n}\n\nexport type ModerationResponse = OpenAIResults & {\n  flagged: boolean;\n}\n", "export type ModerationResponse = OpenAIResults & {\n  flagged: boolean;\n}\n\nexport type UseAIResponses<T> = T extends boolean ? ModerationResponse : T extends undefined ? CompletionResponse : ChatResponse<T>;\n\n\nexport interface Node {\n  type: string;\n  text: string;\n  children: Node[];\n}\n", "export type Language = {\n  grammar: any;\n  regexRules: {\n    [nodeType: string]: RegExp;\n  };\n};\n\nexport interface Statements {\n  type: string;\n  text: string;\n}\n", "export interface LanguageParser {\n  fileExtension: string[];\n  parserName: string;\n  parserVariant?: string;\n}\n\nexport interface Grammars {\n  name: string;\n  nodeTypeInfo: Grammar[];\n}\n", "export interface Grammar {\n  type: string;\n  named: boolean;\n  subtypes?: Grammar[];\n  fields?: Record<string, Field>;\n  children?: Children;\n}\n\nexport interface Field {\n  multiple: boolean;\n  required: boolean;\n  types: TypeRef[];\n}\n", "export interface Field {\n  multiple: boolean;\n  required: boolean;\n  types: TypeRef[];\n}\n\nexport interface TypeRef {\n  type: string;\n  named: boolean;\n}\n", "export interface Children {\n  multiple: boolean;\n  required: boolean;\n  types: TypeRef[];\n}\n\nexport type LinearizedStatement = {\n  i: number; // id\n  p?: number; // parentId\n  t: string; // type\n  c: string; // content\n};\n", "export type DefaultGrammarOrVariants = {\n  default: Grammars | {\n    [prop: string]: Grammars\n  }\n}"]}
{"filename": "src/lib/index.ts", "chunked_list": ["export * from './prompts';\nexport * from './languages';\nexport * from './util';\nexport type {\n  Config,\n  ConfigPropTypes,\n  GuardValidations,\n  ChatResponse,\n  CompletionResponse,\n  ModerationResponse,", "  CompletionResponse,\n  ModerationResponse,\n  CurrentType,\n  DefaultGrammarOrVariants,\n  Language,\n  LinearizedStatement,\n  OpenAIResults,\n  UseAIResponses,\n  Children,\n  Field,", "  Children,\n  Field,\n  Grammar,\n  Grammars,\n  LanguageParser,\n  Node,\n  Statements,\n  TypeRef\n} from './types';", "} from './types';"]}
{"filename": "src/lib/util.ts", "chunked_list": ["import type { ChatResponse, CompletionResponse, ConfigPropTypes, DefaultGrammarOrVariants, Grammars, GuardValidations, ModerationResponse } from \"./types\";\n\nexport function isConfigNestedObject(obj: unknown): obj is Record<string, ConfigPropTypes> {\n  return typeof obj === 'object' && obj !== null;\n}\n\nexport function isDefaultGrammar(obj: DefaultGrammarOrVariants): obj is { default: Grammars } {\n  return 'string' === typeof obj.default.name;\n}\n\nexport function isDefaultGrammarVariants(obj: DefaultGrammarOrVariants): obj is { default: { [prop: string]: Grammars } } {\n  return 'undefined' === typeof obj.default.name;\n}\n", "export function isDefaultGrammarVariants(obj: DefaultGrammarOrVariants): obj is { default: { [prop: string]: Grammars } } {\n  return 'undefined' === typeof obj.default.name;\n}\n\nexport function isChatResponse<T>(obj: GuardValidations): obj is ChatResponse<T> {\n  return 'object' === typeof obj && 'message' in obj && Array.isArray(obj.message);\n}\n\nexport function isCompletionResponse(obj: GuardValidations): obj is CompletionResponse {\n  return 'object' === typeof obj && 'message' in obj && 'string' === typeof obj.message;\n}\n", "export function isCompletionResponse(obj: GuardValidations): obj is CompletionResponse {\n  return 'object' === typeof obj && 'message' in obj && 'string' === typeof obj.message;\n}\n\nexport function isModerationResponse(obj: GuardValidations): obj is ModerationResponse {\n  return 'object' === typeof obj && 'input' in obj;\n}"]}
{"filename": "src/lib/prompts/create_type_prompt.ts", "chunked_list": ["\nimport { ChatCompletionRequestMessage } from \"openai\";\nimport type { GuardValidations } from \"../types\";\n\n// const createTypePrompt = 'Complete the following typescript type with 4-7 unconventionally named properties, using string, number or boolean, starting with its opening bracket, \"type ${prompt1} =';\n\n// const createTypeMessages = [\n//   { role: 'system', content: 'I, TypescriptTypeGeneratorGPT, respond with a code statement declaring a Typescript type, based on the name of a type.' },\n//   { role: 'assistant', content: `This message describes how \\${prompt1} will be generated and returned in the next message.\n//   1. Parse Name: You provided a name in the format of ITypeName, \\${prompt1}, which I will evaluate to determine its general informational context.\n//   2. Primary Action: Generate TYPE_DEFINITION of 4-7 unconventionally named properties.\n//   3. Primary Validation: TYPE_DEFINITION is validated as starting with text \"type \\${prompt1} = {\" with the rest of TYPE_DEFINITION to follow.\n//   4. Secondary Validation: Exact response text verified to be formatted in the following pattern:\n//   &&&\n//   @@@", "//   const \\${prompt1} = { type definition will appear here };\n//   @@@\n//   &&&\n//   ` }\n// ]\n\nexport const createTypeMessages: ChatCompletionRequestMessage[] = [\n  { role: 'system', content: 'As a TypescriptTypeGeneratorGPT, generate a Typescript type definition for ${prompt1}.' },\n  { role: 'assistant', content: `Internal Process:\n  1. Generate: 4-7 uncommon English-language attribute names. \n  2. Format: Your response is formatted in the following enclosed structure:\n  &&&\n  {supporting text}\n  @@@", "  type \\${prompt1} = {generated type definition}\n  @@@\n  {left intentionally blank}\n  &&&\n  3. Validation: Response structure is re-validated to adhere to the formatting of step 2.`}\n];\n\nexport type CreateTypeTypeName = `I${string}`;\n\nexport type CreateTypeResponse = `type ${CreateTypeTypeName} =`;\n", "export type CreateTypeResponse = `type ${CreateTypeTypeName} =`;\n\nexport function isCreateTypeResponse(obj: GuardValidations): boolean {\n  let createTypeResponseRegex = new RegExp(/type\\s+I\\w+\\s*=\\s*\\{/gm);\n  return 'string' === typeof obj && createTypeResponseRegex.test(obj);\n}\n"]}
{"filename": "src/lib/prompts/suggest_role_prompt.ts", "chunked_list": ["import { ChatCompletionRequestMessage } from \"openai\";\nimport { generateExample, getSuggestionPrompt } from \"./prompt_utils\";\n\nexport const suggestRoleMessagesOld = `${getSuggestionPrompt('role names for a group named ${prompt1} which is interested in ${prompt2}')}\n${generateExample('role names for a group named writing center which is interested in consulting on writing', 'Tutor|Student|Advisor|Administrator|Consultant')}\n${generateExample('role names for a group named city maintenance department which is interested in maintaining the facilities in the city', 'Dispatcher|Engineer|Administrator|Technician|Manager')}`;\n\nexport const suggestRoleMessages: ChatCompletionRequestMessage[] = [\n  { role: 'system', content: 'I, DelimitedOptions, will provide 5 options delimited by |.' },\n  { role: 'assistant', content: `Simply provide your desired prompt, and I\\'ll fill in the result!", "  { role: 'system', content: 'I, DelimitedOptions, will provide 5 options delimited by |.' },\n  { role: 'assistant', content: `Simply provide your desired prompt, and I\\'ll fill in the result!\n  Here are some examples: ${suggestRoleMessagesOld}\n  Provide the following text \"Prompt: <some prompt> Result:\" and I will complete the result.` },\n  { role: 'user', content: generateExample('role names for a group named \"${prompt1}\" which is interested in ${prompt2}') }\n];"]}
{"filename": "src/lib/prompts/suggest_tier_prompt.ts", "chunked_list": ["import { generateExample, getSuggestionPrompt } from \"./prompt_utils\";\n\nexport const suggestTierMessages = `${getSuggestionPrompt('service level names for ${prompt1}')}\n${generateExample('service level names for a generic service', 'Small|Medium|Large')}\n${generateExample('service level names for writing tutoring at a school writing center', 'WRI 1010|WRI 1020|WRI 2010|WRI 2020|WRI 3010')}\n${generateExample('service level names for streaming at a web media platform', 'Basic|Standard|Premium')}\n${generateExample('service level names for advising at a school learning center', 'ENG 1010|WRI 1010|MAT 1010|SCI 1010|HIS 1010')}\n${generateExample('service level names for travelling on an airline service', 'Economy|Business|First Class')}\n${generateExample('service level names for reading tutoring at a school reading center', 'ESL 900|ESL 990|ENG 1010|ENG 1020|ENG 2010')}\n${generateExample('service level names for ${prompt1}')}`;", "${generateExample('service level names for reading tutoring at a school reading center', 'ESL 900|ESL 990|ENG 1010|ENG 1020|ENG 2010')}\n${generateExample('service level names for ${prompt1}')}`;"]}
{"filename": "src/lib/prompts/prompt_utils.ts", "chunked_list": ["\nexport function getSuggestionPrompt(prompt: string) {\n  return `Generate 5 ${prompt}; Result is 1-3 words separated by |. Here are some examples: `;\n}\n\nexport function generateExample(prompt: string, result: string = '') {\n  return `Phrase: ${prompt}\\nResult: ${result}`;\n}\n\nexport function hasSimilarKey(obj: Record<string, unknown>, regex: RegExp): boolean {\n  return Object.keys(obj).some(key => regex.test(key));\n}", "export function hasSimilarKey(obj: Record<string, unknown>, regex: RegExp): boolean {\n  return Object.keys(obj).some(key => regex.test(key));\n}"]}
{"filename": "src/lib/prompts/file_editor_prompt.ts", "chunked_list": ["import { ChatCompletionRequestMessage } from \"openai\";\nimport type { GuardValidations } from \"../types\";\n\n// const fileEditorPrompt = [\n//   { role: 'system', content: 'you are a helpful file editing assistant' },\n//   { role: 'user', content: 'edit ${prompt1} with regard to ${prompt2}. only show edited lines. remember to encase the edited code inside proper markdown \"```\" header. \\n\\n ${prompt1}:\\n${prompt3}' }\n// ];\n\nexport const fileEditorMessages: ChatCompletionRequestMessage[] = [\n  { role: 'system', content: 'You, CodeCommenter, follow user instructions to add, edit, and delete text in specific ways, leaving change comments. You only reply with the line number + the change comment + the new content of the line. 3 possible static comments: \"/* change: added text */\", \"/* change: edited text */\", and \"/* change: fully removed text */\". Your reply includes only changed lines which have change comments, and clearly formats it in an anonymous markdown backtick block.' },", "export const fileEditorMessages: ChatCompletionRequestMessage[] = [\n  { role: 'system', content: 'You, CodeCommenter, follow user instructions to add, edit, and delete text in specific ways, leaving change comments. You only reply with the line number + the change comment + the new content of the line. 3 possible static comments: \"/* change: added text */\", \"/* change: edited text */\", and \"/* change: fully removed text */\". Your reply includes only changed lines which have change comments, and clearly formats it in an anonymous markdown backtick block.' },\n  // { role: 'system', content: 'You reply with: \"I only edited line {number of each edited line}, so I am just going to show you {number of edited lines} lines, including empty lines:\"' },\n  { role: 'user', content: `add_text_example.txt\n\ninstructions: put a happy face on line 4\n\n1. Lorem ipsum dolor sit amet.\n2. Lorem ipsum dolor sit amet.\n3. Lorem ipsum dolor sit amet.", "2. Lorem ipsum dolor sit amet.\n3. Lorem ipsum dolor sit amet.\n4. Lorem ipsum dolor sit amet.\n5. Lorem ipsum dolor sit amet.\n6. Lorem ipsum dolor sit amet.\n7. Lorem ipsum dolor sit amet.`},\n  { role: 'assistant', content: `1 text change signified: I edited line 4, which is 1 total edited line. Here is the 1 edited line containing a signifier, including its line number:  \n\\`\\`\\`\n4. Lorem ipsum dolor sit amet. :) /* change: added text */\n\\`\\`\\`", "4. Lorem ipsum dolor sit amet. :) /* change: added text */\n\\`\\`\\`\nPlease find the 1 change above this line.`},\n  { role: 'user', content: `remove_and_edit_text_example.js\n\ninstructions: remove any console logs. change ts.configPath to ts.configRoot\n\n1. const config = getConfig();\n2. if (!config.ts.compDir) {\n3.   console.log('hey');\n4.   throw new Error('Missing ts.compDir.')\n5. }\n6. ", "2. if (!config.ts.compDir) {\n3.   console.log('hey');\n4.   throw new Error('Missing ts.compDir.')\n5. }\n6. \n7. if (!config.ts.configPath) {\n8.   console.log('testing removals');\n9.   throw new Error('Missing ts.configPath.')\n10. }`},\n  { role: 'assistant', content: `4 text changes signified: I edited lines 3, 7, 8, and 9, which is 4 total edited lines. Here are the 4 lines containing signifiers, including their line numbers:\n\\`\\`\\`\n3. /* change: fully removed text */", "7. if (!config.ts.configRoot) { /* change: edited text */\n8.   /* change: fully removed text */\n9.   throw new Error('Missing ts.configRoot.') /* change: edited text */\n\\`\\`\\`\nPlease find the 4 changes above this line.` },\n  { role: 'user', content: `\\${prompt1}\n\n\\${prompt2}\n\n\\${prompt3}`}\n];\n\n// const testSystem = 'you are a helpful typescript coding assistant';\n// const testPrompt = 'typescript code that ${prompt1}. only show completely working code. remember to encase your code inside proper markdown \"```typescript\" header, and on the next line, include a unique-description filename such as `#dice-counter.py`.'\n\nconst fileEditorResponseRegex = /^\\d+./igm;", "export type FileEditorResponse = `${number}. ${string}`;\n\nexport function isFileEditorResult(obj: GuardValidations): boolean {\n  return 'string' === typeof obj && fileEditorResponseRegex.test(obj);\n}"]}
{"filename": "src/lib/prompts/guided_edit_prompt.ts", "chunked_list": ["import { ChatCompletionRequestMessage } from \"openai\";\nimport type { GuardValidations } from \"../types\";\nimport { hasSimilarKey } from \"./prompt_utils\";\n\n// const guidedEditPrompt = [\n//   { role: 'system', content: 'As CodeWhittler I transform STATEMENTS_JSON, deriving RESPONSE_ARRAY from TARGET_STATE modifications.' },\n//   { role: 'assistant', content: `Whittling Supplies Required:\n// - STATEMENTS_JSON: a JSON object with string keys and string Typescript code statement values\n// - TARGET_STATE: the desired state of the Typescript code statements\n ", "// - TARGET_STATE: the desired state of the Typescript code statements\n \n// Carving Process:\n// I'll examine STATEMENTS_JSON object, consider TARGET_STATE, and return a carefully whittled RESPONSE_ARRAY array. This whittling process ensures that your application runs swiftly and efficiently.\n\n// Whittling Technique:\n// 1. Identify: TARGET_STATE_RELEVANCE is assigned to each STATEMENTS_JSON value.\n//   - Relevance is an internal measurement determining the liklihood that modifying the STATEMENTS_JSON value will contribute to TARGET_STATE.\n// 2. Filter: ACTION_ITEMS filters STATEMENTS_JSON based on TARGET_STATE_RELEVANCE.\n//   - Any Relevance: Include", "// 2. Filter: ACTION_ITEMS filters STATEMENTS_JSON based on TARGET_STATE_RELEVANCE.\n//   - Any Relevance: Include\n//   - No Relevance: Exclude\n// 3. Execute: Perform various tasks on ACTION_ITEMS to reach TARGET_STATE.\n//   - Update: Any ACTION_ITEMS may be updated.\n//   - Insert: New ACTION_ITEMS may be added with \"above_#\" or \"below_#\" as a key using an adjacent statement #. Inserted functionality (above_#/below_#) is positioned relative to an adjacent statement (eg. above_5 is a new statement above statement_5), or the beginning/end of file (eg. above_0 is a new statement at the start of the file).\n//   - Remove: Any ACTION_ITEMS value may be set to an empty string.\n// 4. Validate: ACTION_ITEMS are valid Typescript.\n// 5. Build: RESPONSE_ARRAY is a JSON array of objects { \"ACTION_ITEM_KEY\": \"ACTION_ITEMS[ACTION_ITEM_KEY]\" }.\n// 6. Build Validation: RESPONSE_ARRAY is a properly formatted and escaped JSON array.", "// 5. Build: RESPONSE_ARRAY is a JSON array of objects { \"ACTION_ITEM_KEY\": \"ACTION_ITEMS[ACTION_ITEM_KEY]\" }.\n// 6. Build Validation: RESPONSE_ARRAY is a properly formatted and escaped JSON array.\n\n// Response Template:\n// All responses given by me follow this exact format enclosed in 3 ampersands.\n\n// &&&\n// <2 very short comments describing the overall changes>\n\n// The modified subset of keys: ...ACTION_ITEM_KEYS", "\n// The modified subset of keys: ...ACTION_ITEM_KEYS\n\n// @@@\n// [ ...RESPONSE_ARRAY ] // in string format for example: '[ { \"above_5\": \"inserted code statement\", \"statement_9\": \"existing modified code statement\", \"below_13\": \"inserted code statement\" }, ]'\n// @@@\n// &&&\n\n// Following Steps:\n// Provide the necessary context in the statements for me to carry out the modifications. Use the keywords STATEMENTS_JSON and TARGET_STATE to convey the required inputs:", "// Following Steps:\n// Provide the necessary context in the statements for me to carry out the modifications. Use the keywords STATEMENTS_JSON and TARGET_STATE to convey the required inputs:\n\n// TARGET_STATE --- <an english phrase with some coding terms>\n// STATEMENTS_JSON --- <a plain old javascript object (POJO)>\n\n// On receiving TARGET_STATE and STATEMENTS_JSON, I'll start whittling away on the STATEMENTS_JSON as needed, to achieve TARGET_STATE, in order to derive RESPONSE_ARRAY.`},\n//   { role: 'user', content: ' TARGET_STATE --- ${prompt1}\\n    STATEMENTS_JSON --- ${prompt2}' }\n// ];\n", "// ];\n\n// const testSystem = 'you are a helpful typescript coding assistant';\n// const testPrompt = 'typescript code that ${prompt1}. only show completely working code. remember to encase your code inside proper markdown \"```typescript\" header, and on the next line, include a unique-description filename such as `#dice-counter.py`.'\n\nexport const guidedEditMessages: ChatCompletionRequestMessage[] = [\n  { role: 'system', content: 'I change code from a JSON object to an array based on the target state.' },\n  { role: 'assistant', content: `What I need:\n  \n  JSON object with code statements", "  \n  JSON object with code statements\n  Desired state of the code statements\n  What I do:\n  \n  Check which statements in the JSON object can help reach the desired state.\n  Keep only useful statements.\n  Change the statements to reach the target state. I can update, insert, or remove statements.\n  Make sure the updated code is valid Typescript.\n  Create an array with the updated code.", "  Make sure the updated code is valid Typescript.\n  Create an array with the updated code.\n  Ensure the array is properly formatted.\n  Response format:\n  I'll provide the changes made in a specific format like this:\n  \n  &&&\n  <2 short comments on changes>\n  \n  Modified keys: ...KEYS", "  \n  Modified keys: ...KEYS\n  \n  @@@\n  [ ...ARRAY ] // example: '[ { \"above_5\": \"new code\", \"statement_9\": \"changed code\", \"below_13\": \"new code\" }, ]'\n  @@@\n  &&&\n  \n  Next steps:\n  Give me the desired state and JSON object with code statements using these keywords:", "  Next steps:\n  Give me the desired state and JSON object with code statements using these keywords:\n  \n  TARGET_STATE --- <phrase with code terms>\n  STATEMENTS_JSON --- <a simple JSON object>\n  \n  I'll change the code in the JSON object to reach the target state and create the final array.`},\n  { role: 'user', content: ' TARGET_STATE --- ${prompt1}\\n STATEMENTS_JSON --- ${prompt2}' }\n];\n\nexport type GuidedEditKeyPrefix = 'statement' | 'above' | 'below';\n", "];\n\nexport type GuidedEditKeyPrefix = 'statement' | 'above' | 'below';\n\nexport type GuidedEditKeys = `${GuidedEditKeyPrefix}_${number}`;\n\nexport type GuidedEditResponse = Record<GuidedEditKeys, string>[];\n\nexport function isGuidedEditResult(obj: GuardValidations): boolean {\n  return Array.isArray(obj) && obj.every(item => ['statement', 'above', 'below'].some(test => {\n    const guidedEditKey = new RegExp(`^${test}_\\\\d+$`);\n    return hasSimilarKey(item, guidedEditKey)\n  }));\n}", "export function isGuidedEditResult(obj: GuardValidations): boolean {\n  return Array.isArray(obj) && obj.every(item => ['statement', 'above', 'below'].some(test => {\n    const guidedEditKey = new RegExp(`^${test}_\\\\d+$`);\n    return hasSimilarKey(item, guidedEditKey)\n  }));\n}"]}
{"filename": "src/lib/prompts/create_gen_component_prompt.ts", "chunked_list": ["import { ChatCompletionRequestMessage } from \"openai\";\nimport type { GuardValidations } from \"../types\";\n\nexport const createGenComponentMessages: ChatCompletionRequestMessage[] = [\n  { role: 'system', content: 'I, ReactiveAssembleGPT, assemble React components.' },\n  {\n    role: 'assistant', content: `Provide the description of a react component, and I will assemble it.\n  \n  In the process of assembly, I may:\n    - Use these nodejs pacakges if needed: @date-io/dayjs, @mui/icons-material, @mui/material, @mui/material-next, @mui/x-data-grid, @mui/x-date-pickers, @react-keycloak/web, @reduxjs/toolkit, dayjs, history, keycloak-js, react, react-dom, react-dropzone, react-redux, react-router, react-router-dom, react-window, uuid.", "  In the process of assembly, I may:\n    - Use these nodejs pacakges if needed: @date-io/dayjs, @mui/icons-material, @mui/material, @mui/material-next, @mui/x-data-grid, @mui/x-date-pickers, @react-keycloak/web, @reduxjs/toolkit, dayjs, history, keycloak-js, react, react-dom, react-dropzone, react-redux, react-router, react-router-dom, react-window, uuid.\n    - Utilize Material-UI components for all design related aspects.\n  \n  Simply respond with the description of a react component, and I will try my best. If your idea is too complex, I may simplify it. Any issues I may encounter in formulating a concept, I will attempt to resolve personally. If you ask me to seek out sample data to use in the component, I will have no issue sourcing your data needs with custom public API resources that are already known to me.`},\n  { role: 'user', content: '${prompt1}' }\n];\n\nconst generalComponentResponseRegex = /export default/ig;\ntype GeneralComponentKey = string;\nexport type GeneralComponentResponse = `export default function ${GeneralComponentKey}() {`;\n", "const generalComponentResponseRegex = /export default/ig;\ntype GeneralComponentKey = string;\nexport type GeneralComponentResponse = `export default function ${GeneralComponentKey}() {`;\n\nexport function isGeneralComponentResponse(obj: GuardValidations): boolean {\n  return 'string' === typeof obj && generalComponentResponseRegex.test(obj);\n}"]}
{"filename": "src/lib/prompts/suggest_feature_prompt.ts", "chunked_list": ["import { generateExample, getSuggestionPrompt } from \"./prompt_utils\";\n\nexport const suggestFeatureMessages = `${getSuggestionPrompt('features of ${prompt1}')}\n${generateExample('features of ENGL 1010 writing tutoring', 'Feedback|Revisions|Brainstorming|Discussion')}\n${generateExample('features of Standard gym membership', 'Full Gym Equipment|Limited Training|Half-Day Access')}\n${generateExample('features of Pro web hosting service', 'Unlimited Sites|Unlimited Storage|1TB Bandwidth|Daily Backups')}\n${generateExample('features of professional photography service', 'Next-Day Prints|High-quality digital photos|Retouching and editing|Choice of location|Choice of outfit changes')}\n${generateExample('features of ${prompt1}')}`;\n\n", "\n\n"]}
{"filename": "src/lib/prompts/create_api_prompt.ts", "chunked_list": ["import { ChatCompletionRequestMessage } from \"openai\";\nimport type { GuardValidations } from \"../types\";\n\nexport const createApiMessages: ChatCompletionRequestMessage[] = [\n  { role: 'system', content: 'TemplateTransferGPT transfers the qualities of type script types into Api templates.'},\n  { role: 'assistant', content: `I perform each step silently to my self, and then I will give you a response like in Sample Response:\n  1. Define Accepted API_RELATED_TYPE Input: type IDigitalWhiteboard = { manufacturer: string;  model: string;  screenSize: number;  resolution: string;  touchSensitive: boolean;  connectivity: string[];  interface: string;}\n  2. Assign API_TEMPLATE: const digitalWhiteboardApi = {\\n  postDigitalWhiteboard: {\\n    kind: EndpointType.MUTATION,\\n    url: 'digitalwhiteboards',\\n    method: 'POST',\\n    opts: {} as ApiOptions,\\n    queryArg: { manufacturer: '' as string;  model: '' as string; },\\n    resultType: {} as IDigitalWhiteboard }\\n  },\\n  putDigitalWhiteboard: {\\n    kind: EndpointType.MUTATION,\\n    url: 'digitalwhiteboards',\\n    method: 'PUT',\\n    opts: {} as ApiOptions,\\n    queryArg: { id: '' as string } as IDigitalWhiteboard,\\n    resultType: {} as IDigitalWhiteboard\\n  },\\n  getDigitalWhiteboards: {\\n    kind: EndpointType.QUERY,\\n    url: 'digitalwhiteboards',\\n    method: 'GET',\\n    opts: {} as ApiOptions,\\n    queryArg: {} as Void,\\n    resultType: [] as IDigitalWhiteboard[]\\n  },\\n  getDigitalWhiteboardById: {\\n    kind: EndpointType.QUERY,\\n    url: 'digitalwhiteboards/:id',\\n    method: 'GET',\\n    opts: {} as ApiOptions,\\n    queryArg: { id: '' as string },\\n    resultType: {} as IDigitalWhiteboard\\n  },\\n  deleteDigitalWhiteboard: {\\n    kind: EndpointType.MUTATION,\\n    url: 'digitalwhiteboards/:id',\\n    method: 'DELETE',\\n    opts: {} as ApiOptions,\\n    queryArg: { id: '' as string },\\n    resultType: { id : '' as string }\\n  },\\n  disableDigitalWhiteboard: {\\n    kind: EndpointType.MUTATION,\\n    url: 'digitalwhiteboards/:id/disable',\\n    method: 'PUT',\\n    opts: {} as ApiOptions,\\n    queryArg: { id: '' as string },\\n    resultType: { id: '' as string }\\n  }\\n} as const;\n  3. Parse Input: API_RELATED_TYPE is parsed for its attributes, context, and connotation.\n  4. Implement: RESPONSE_BODY is implemented as an API_TEMPLATE using details from API_RELATED_TYPE.\n  5. Verify: RESPONSE_BODY is verified as being a Typescript constant variable incorporating as const and type specified properties (id: '' as string), when applicable.\n  6. Response Technique:\n    6a. Begin the response with &&&\n    6b. Add short statement describing change\n    6c. Add @@@ immediately before RESPONSE_BODY\n    6d. Paste RESPONSE_BODY\n    6e. Add @@@ immediately after RESPONSE_BODY\n    6f. Add &&& after @@@\n  7. Validate Response: The response is a &&& block containing a @@@ block.\n  \n  Sample Response:\n  &&&\n  {supporting text}\n  @@@\n  RESPONSE_BODY // eg. const customizedTypedApi = { transferred functionality customized around API_RELATED_TYPE }\n  @@@\n  {left intentionally blank}\n  &&&` },\n  { role: 'user', content: 'API_RELATED_TYPE=\\${prompt1}' }\n];\n\nconst createApiFormat = /^const\\s+\\w+Api\\s*=\\s*\\{/gim;\n", "  5. Verify: RESPONSE_BODY is verified as being a Typescript constant variable incorporating as const and type specified properties (id: '' as string), when applicable.\n  6. Response Technique:\n    6a. Begin the response with &&&\n    6b. Add short statement describing change\n    6c. Add @@@ immediately before RESPONSE_BODY\n    6d. Paste RESPONSE_BODY\n    6e. Add @@@ immediately after RESPONSE_BODY\n    6f. Add &&& after @@@\n  7. Validate Response: The response is a &&& block containing a @@@ block.\n  \n  Sample Response:\n  &&&\n  {supporting text}\n  @@@\n  RESPONSE_BODY // eg. const customizedTypedApi = { transferred functionality customized around API_RELATED_TYPE }\n  @@@\n  {left intentionally blank}\n  &&&` },\n  { role: 'user', content: 'API_RELATED_TYPE=\\${prompt1}' }\n];\n\nconst createApiFormat = /^const\\s+\\w+Api\\s*=\\s*\\{/gim;\n", "type CreateApiKey = string;\nexport type CreateApiResult = `const ${CreateApiKey}Api =`;\n\nexport function isCreateApiResult(obj: GuardValidations): obj is CreateApiResult {\n  return 'string' === typeof obj && createApiFormat.test(obj);\n}"]}
{"filename": "src/lib/prompts/create_api_backend_prompt.ts", "chunked_list": ["import { ChatCompletionRequestMessage } from \"openai\";\nimport type { GuardValidations } from \"../types\";\n\nexport const createApiBackendMessages: ChatCompletionRequestMessage[] = [\n  { role: 'system', content: 'I, TemplateTransferGPT, transfer the qualities of Typescript types into file templates.'},\n  { role: 'assistant', content: `I perform each step silently to my self, and then I will give you a response like in Sample Response:\n  1. Define Accepted FILE_RELATED_TYPE Input: type IUuidFiles = { id: string; parentUuid: string; fileId: string; } postUuidFile, putUuidFile, getUuidFiles, getUuidFileById, deleteUuidFile, disableUuidFile' }\n  2. Assign FILE_TEMPLATE: const uuidFilesApiHandlers: ApiHandler<typeof uuidFilesApi> = {\\n  postUuidFile: async props => {\\n    const { parentUuid: parent_uuid, fileId: file_id } = props.event.body;\\n    const { id } = await props.tx.one<IUuidFiles>(\\`\\n      INSERT INTO dbtable_schema.uuid_files (parent_uuid, file_id, created_on, created_sub)\\n      VALUES ($1, $2, $3, $4::uuid)\\n      RETURNING id\\n    \\`, [parent_uuid, file_id, utcNowString(), props.event.userSub]);\\n    \\n    return { id };\\n  },\\n  putUuidFile: async props => {\\n    const { id, parentUuid: parent_uuid, fileId: file_id } = props.event.body;\\n    const updateProps = buildUpdate({\\n      id,\\n      parent_uuid,\\n      file_id,\\n      updated_on: utcNowString(),\\n      updated_sub: props.event.userSub\\n    });\\n    await props.tx.none(\\`\\n      UPDATE dbtable_schema.uuid_files\\n      SET \\${updateProps.string}\\n      WHERE id = $1\\n    \\`, updateProps.array);\\n    return { id };\\n  },\\n  getUuidFiles: async props => {\\n    const uuidFiles = await props.db.manyOrNone<IUuidFiles>(\\`\\n      SELECT * FROM dbview_schema.enabled_uuid_files\\n    \\`);\\n    \\n    return uuidFiles;\\n  },\\n  getUuidFileById: async props => {\\n    const { id } = props.event.pathParameters;\\n    const response = await props.db.one<IUuidFiles>(\\`\\n      SELECT * FROM dbview_schema.enabled_uuid_files\\n      WHERE id = $1\\n    \\`, [id]);\\n    \\n    return response;\\n  },\\n  deleteUuidFile: async props => {\\n    const { id } = props.event.pathParameters;\\n    await props.tx.none(\\`\\n      DELETE FROM dbtable_schema.uuid_files\\n      WHERE id = $1\\n    \\`, [id]);\\n    \\n    return { id };\\n  },\\n  disableUuidFile: async props => {\\n    const { id, parentUuid: parent_uuid, fileId: file_id } = props.event.body;\\n    await props.tx.none(\\`\\n      UPDATE dbtable_schema.uuid_files\\n      SET enabled = false, updated_on = $3, updated_sub = $4\\n      WHERE parent_uuid = $1 AND file_id = $2\\n    \\`, [parent_uuid, file_id, utcNowString(), props.event.userSub]);\\n    return { id };\\n  },\\n} as const;\n  3. Parse Input: FILE_RELATED_TYPE is parsed for its attributes, context, and connotation.\n  4. Implement: RESPONSE_BODY is implemented as an API_TEMPLATE using details from FILE_RELATED_TYPE.\n  5. Verify: RESPONSE_BODY is verified as being a Typescript constant variable incorporating as const and defining .\n  6. Response Technique is the following verbatim text with variables replaced by <>: &&&@@@<RESPONSE_BODY>@@@&&&\n  7. Validate Response: The response returned to the user follows the exact format of Step 6: eg. &&&@@@const customizedApiHandlers: ApiHandler<typeof customizedApi> = {\\n transferred functionality customized around FILE_RELATED_TYPE\\n }@@@&&&` },\n  { role: 'user', content: 'FILE_RELATED_TYPE=\\${prompt1}' }\n];\n\nconst createApiFormat = /^const\\s+\\w+ApiHandlers:\\s+ApiHandler/gim;\n", "type CreateApiBackendKey = string;\nexport type CreateApiBackendResult = `const ${CreateApiBackendKey}ApiHandlers: ApiHandler`;\n\nexport function isCreateApiBackendResult(obj: GuardValidations): obj is CreateApiBackendResult {\n  return 'string' === typeof obj && createApiFormat.test(obj);\n}"]}
{"filename": "src/lib/prompts/index.ts", "chunked_list": ["import { ChatCompletionRequestMessage } from \"openai\";\n\nimport { convertPurposeMessages } from './convert_purpose_prompt';\nimport { createApiBackendMessages } from './create_api_backend_prompt';\nimport { createApiMessages } from './create_api_prompt';\nimport { createAppComponentMessages } from './create_app_component_prompt';\nimport { createGenComponentMessages } from './create_gen_component_prompt';\nimport { createTypeMessages } from './create_type_prompt';\nimport { fileEditorMessages } from './file_editor_prompt';\nimport { guidedEditMessages } from './guided_edit_prompt';", "import { fileEditorMessages } from './file_editor_prompt';\nimport { guidedEditMessages } from './guided_edit_prompt';\nimport { suggestFeatureMessages } from './suggest_feature_prompt';\nimport { suggestRoleMessages } from './suggest_role_prompt';\nimport { suggestServiceMessages } from './suggest_service_prompt';\nimport { suggestTierMessages } from './suggest_tier_prompt';\nimport { deriveInstructionMessages } from \"./derive_instruction_prompt\";\n\nexport enum IPrompts {\n  CREATE_API = 'create_api',\n  CREATE_API_BACKEND = 'create_api_backend',\n  CREATE_TYPE = 'create_type',\n  CREATE_GEN_COMPONENT = 'create_gen_component',\n  CREATE_APP_COMPONENT = 'create_app_component',\n  DERIVE_INSTRUCTION = 'derive_instruction',\n  FILE_EDITOR = 'file_editor',\n  GUIDED_EDIT = 'guided_edit',\n  SUGGEST_ROLE = 'suggest_role',\n  SUGGEST_SERVICE = 'suggest_service',\n  SUGGEST_TIER = 'suggest_tier',\n  SUGGEST_FEATURE = 'suggest_feature',\n  CONVERT_PURPOSE = 'convert_purpose'\n}\n", "export enum IPrompts {\n  CREATE_API = 'create_api',\n  CREATE_API_BACKEND = 'create_api_backend',\n  CREATE_TYPE = 'create_type',\n  CREATE_GEN_COMPONENT = 'create_gen_component',\n  CREATE_APP_COMPONENT = 'create_app_component',\n  DERIVE_INSTRUCTION = 'derive_instruction',\n  FILE_EDITOR = 'file_editor',\n  GUIDED_EDIT = 'guided_edit',\n  SUGGEST_ROLE = 'suggest_role',\n  SUGGEST_SERVICE = 'suggest_service',\n  SUGGEST_TIER = 'suggest_tier',\n  SUGGEST_FEATURE = 'suggest_feature',\n  CONVERT_PURPOSE = 'convert_purpose'\n}\n", "type AiPrompts = Record<IPrompts, string | ChatCompletionRequestMessage[]>;\n\nexport let aiPrompts: AiPrompts = {\n  [IPrompts.CONVERT_PURPOSE]: convertPurposeMessages,\n  [IPrompts.CREATE_API_BACKEND]: createApiBackendMessages,\n  [IPrompts.CREATE_API]: createApiMessages,\n  [IPrompts.CREATE_APP_COMPONENT]: createAppComponentMessages,\n  [IPrompts.CREATE_GEN_COMPONENT]: createGenComponentMessages,\n  [IPrompts.CREATE_TYPE]: createTypeMessages,\n  [IPrompts.DERIVE_INSTRUCTION]: deriveInstructionMessages,\n  [IPrompts.FILE_EDITOR]: fileEditorMessages,\n  [IPrompts.GUIDED_EDIT]: guidedEditMessages,\n  [IPrompts.SUGGEST_FEATURE]: suggestFeatureMessages,\n  [IPrompts.SUGGEST_ROLE]: suggestRoleMessages,\n  [IPrompts.SUGGEST_SERVICE]: suggestServiceMessages,\n  [IPrompts.SUGGEST_TIER]: suggestTierMessages\n};\n", "export function injectPrompts(prompts: Partial<AiPrompts>) {\n  aiPrompts = { ...aiPrompts, ...prompts };\n}"]}
{"filename": "src/lib/prompts/create_app_component_prompt.ts", "chunked_list": ["import { ChatCompletionRequestMessage } from \"openai\";\n\nexport const createAppComponentMessages: ChatCompletionRequestMessage[] = [\n  { role: 'system', content: 'As .' },\n  {\n    role: 'user', content: `Decompress \"Compressed Types\"; review the decompressed Typescript type set; design a TSX React Functional Component primarily focusing on the Component Description resulting in a TSX code block; incorporate the optional decompressed types where applicable:\n  \n  Compressed Types: U2I\u03ba\u21d2V|N)\u2194(\u03ba:I)\u21d2V?I:N.VdN\u0394V:T.RmN\u0394K]:T[K].ApiEvt{rId,mth,url,\ud83d\udd13,uSub,srcIp,usrGrpRoles,pp,qp,Tbody}.ApiP{evt,db,lggr,rd,rdP,kcl,cmpl,tx}.AuthP{evt&{body:AuthB},db,rd,rdP,kcl,cmpl,tx}.IWh{prop}\u2194(AuthP)\u21d2P<void>.AuthB{id,cId,rId,ip,ssId,uId,tm,typ,det}.DbErr{schm,tbl,clmn,dType,cnstrnt}.ApiErRsp{prop}:uknw,rId.ApiIntEr{rsp{st:num},data{emsg}}.PrxKy{aSub,apClnt,grpRlAct,grpAdRls,apRls,rlCall}.RdPrx{args}\u21d2P<PrxKy>.IAsst{id,prompt,promptR}.KcSO{regroup}.StrUsr{sub}.ITrMsg{wrds,dur,ts,unm}.IBookTr{unm,msg}.IBooking{qId,qSub,trns}.ICont{id,nm,eml,phn}.ScRspMsgAttr{sdp,ice,fmt,prop}:str.Sndr{prRsp}.IExch{booking}.IFdbck{id,msg,grpNm,crOn,unm}.IFileTp{id,nm}.IFile{id,ftId,ftNm,nm,loc}.IField{l}.IFormTpl=Rec<IField[]>.IFormSubm=Rec<str[]>.IFormVrSnSubm{fVId,subm}.IFormVr{id,fId,fTpl,subm,crOn,crSub}.IForm{id,nm,vr,crOn,crSub}.IGrpForm{id,grpId,fId,grpNm}.IGrpRole{grpId,rlId,extId}.IGrpSchedDateSlot{ws,stT,sDate,schBrSlotId,hr,mn,tm}.IGrpSched{mstr,grpId,schId,grpNm}.IGrpSvcAdn{grpId}.IGrpSvc{grpId,grpNm,svcId,ids}.IGrpUsrSchedStubRepl{unm,slotD,stT,schBrSlotId,sTId,grpNm,qId}.IGrpUsrSchedStub{grpSchId,usrSchId,qId,slotD,stT,svcNm,tierNm,repl}.IGrpUsrSched{id,grpSchId,usrSchId,svcs,grpNm}.IGrpUsr{grpId,usrId,usrSub,extId,grpExtId,rlId,rlNm,grpNm}.IGrpUsrs=Rec<IGrpUsr>.IGrpRlAuthAct{act{id?,nm}}.IGrpRlActState{asgnmnts}.IGrp{id,extId,crSub,crOn,defRlId,alwdDmns,nm,prps,cde,usrCnt,rls,usrs,avGrpAsgnmnts,valid,ndChkNm,chkNm,chckedNm,err}.ILkp{id,nm}.IManageGrps=Rec<IGrp>.\n\n  Component Description: \\${prompt1}\n  \n  Instructions:\n  1. Decompress \"Compresed Types\" to get the list of application-types, which may or may not be related to the description.\n  2. Do not include \"Compressed Types\" or the results of its decompression in the component.", "  3. When a type is required in a component, infer type name and attribute names as full-length titleized or camel-case English names of their compressed versions (e.g., IGroupUsers, groupAssignmentUsers). \n  4. Application-types are not required to be used in the component, but feel free to use them liberally if needed.\n  5. If an application-type is required in the component import it like ISampleType, from 'awayto/core'.\n  6. Use these nodejs pacakges if needed: @date-io/dayjs, @mui/icons-material, @mui/material, @mui/material-next, @mui/x-data-grid, @mui/x-date-pickers, @react-keycloak/web, @reduxjs/toolkit, dayjs, history, keycloak-js, react, react-dom, react-dropzone, react-redux, react-router, react-router-dom, react-window, uuid.\n  7. Use Reduxjs/toolkit auto generated react hooks with the \"sh\" variable; import sh from 'awayto/hooks' then use sh in the component, for example\n    - const { data } = sh.useTypeQuery()\n    - const [postType] = sh.usePostTypeMutation()\n  8. Utilize Material-UI components for all design related aspects.\n  9. Export the component as the default export and reply strictly only with the TSX surrounded in a code block.`}\n];"]}
{"filename": "src/lib/prompts/suggest_service_prompt.ts", "chunked_list": ["import { generateExample, getSuggestionPrompt } from \"./prompt_utils\";\n\nexport const suggestServiceMessages = `${getSuggestionPrompt('gerund verbs performed for the purpose of ${prompt1}')}\n${generateExample('gerund verbs performed for the purpose of offering educational services to community college students', 'Tutoring|Advising|Consulting|Instruction|Mentoring')}\n${generateExample('gerund verbs performed for the purpose of providing banking services to the local area', 'Accounting|Financing|Securities|Financial Planning|Investing')}\n${generateExample('gerund verbs performed for the purpose of ${prompt1}')}`;"]}
{"filename": "src/lib/prompts/derive_instruction_prompt.ts", "chunked_list": ["import { ChatCompletionRequestMessage } from \"openai\";\nimport type { GuardValidations } from \"../types\";\n\n// aHR0cHM6Ly9tYXJ0aW5mb3dsZXIuY29tL2FydGljbGVzLzIwMjMtY2hhdGdwdC14dS1oYW8uaHRtbA==\nexport const deriveInstructionMessages: ChatCompletionRequestMessage[] = [\n  { role: 'system', content: '' },\n  { role: 'assistant', content: `{introduction}\n\n  The current system is a {system_name}. Tech stack: {tech_stack}. And {testing_tools}.\n  ", "  The current system is a {system_name}. Tech stack: {tech_stack}. And {testing_tools}.\n  \n  All codes should be written in the tech stack mentioned above. Requirements should be implemented as {architecture_pattern}.\n  \n  {view_models_block}\n  \n  {common_implementation_strategy}\n  \n  Here is the common implementation strategy for the project:\n  ", "  Here is the common implementation strategy for the project:\n  \n  {strategy_block_which_covers_strategies_relating_to_view_models}\n  \n  {strategy_block_which_covers_strategies_relating_to_component_implementation}\n  \n  {strategy_block_which_covers_strategies_relating_to_testing}\n  \n  {patterns_to_follow}\n  ", "  {patterns_to_follow}\n  \n  Here are certain patterns that should be followed when implementing and testing the components:\n  \n  {test_pattern_guideline_block_1}\n  \n  {test_pattern_guideline_block_2}\n  \n  {test_pattern_guideline_block_3}\n  ", "  {test_pattern_guideline_block_3}\n  \n  {feature_requirement}\n  \n  {feature_name}\n  \n  Requirement:\n  \n  {requirement_description}\n  ", "  {requirement_description}\n  \n  {acceptance_criteria}\n  \n  AC1: {criteria1_description}.\n  \n  AC2: {criteria2_description}.\n  \n  {solution_guidance}\n  ", "  {solution_guidance}\n  \n  Provide an overall solution following the guidance mentioned above. Hint, {solution_hint}. Don't generate code. Describe the solution and break it down into a task list based on the guidance mentioned above. We will refer to this task list as our master plan.`}\n];\n\nconst derivedInstructionResponseRegex = /export default function/igm;\ntype DerivedInstructionKey = string;\nexport type DerivedInstructionResponse = `export default function ${DerivedInstructionKey}() {`;\n\nexport function isDerivedInstructionResponse(obj: GuardValidations): boolean {\n  return 'string' === typeof obj && derivedInstructionResponseRegex.test(obj);\n}", "export function isDerivedInstructionResponse(obj: GuardValidations): boolean {\n  return 'string' === typeof obj && derivedInstructionResponseRegex.test(obj);\n}"]}
{"filename": "src/lib/prompts/convert_purpose_prompt.ts", "chunked_list": ["import { ChatCompletionRequestMessage } from \"openai\";\nimport type { GuardValidations } from \"../types\";\n\nexport const convertPurposeMessages: ChatCompletionRequestMessage[] = [\n  { role: 'system', content: 'You respond with a single gerund phrase, 5 to 8 words, which will complete the user\\'s sentence. For example, \"walking in the sunshine with you\".' },\n  { role: 'assistant', content: 'Give me an incomplete sentence that I can complete with a gerund phrase. For example, if you said \"Our favorite past time is\", I might respond \"walking in the sunshine with you\"' },\n  { role: 'user', content: 'An organization named \"${prompt1}\" is interested in \"${prompt2}\" and their mission statement is' }\n];\n\nexport type ConvertPurposeResult = string;\n\nconst convertPurposeRegex = /\\b[a-z]*ing\\b/i;\n", "\nexport type ConvertPurposeResult = string;\n\nconst convertPurposeRegex = /\\b[a-z]*ing\\b/i;\n\nexport function isConvertPurposeResult(obj: GuardValidations): obj is ConvertPurposeResult {\n  return 'string' === typeof obj && convertPurposeRegex.test(obj);\n}"]}
{"filename": "src/server/stats.ts", "chunked_list": ["import type { ChatResponse, CompletionResponse, ModerationResponse } from \"../lib/types\";\nimport fs from 'fs';\nimport { getConfig } from \"./config\";\nimport { isChatResponse, isCompletionResponse, isModerationResponse } from \"../lib/util\";\n\nexport function logAiResult<T>(res: ChatResponse<T> | CompletionResponse | ModerationResponse) {\n  const config = getConfig();\n  const { successful, timestamp, failures, rawResponses, prompts, model, ...metric } = res;\n  const duration = ((new Date()).getTime() - (new Date(res.timestamp).getTime())) / 1000;\n\n  let metrics: Record<string, unknown> = {\n    pass: successful,\n    timestamp,\n    duration,\n    prompts,\n    model\n  }\n", "  if (isChatResponse(res)) {\n    const { message, supportingText } = res;\n    Object.assign(metrics, { data: { message, supportingText } });\n  }\n\n  if (isCompletionResponse(res)) {\n    const { message } = res;\n    Object.assign(metrics, { data: { message } });\n  }\n\n  if (isModerationResponse(res)) {\n    const { flagged } = res;\n    Object.assign(metrics, { data: { flagged } });\n  }\n\n  Object.assign(metrics, {  type: metric.promptType, template: metric.promptTemplate, rawResponses, failures });\n\n  fs.appendFileSync(config.ai.logFile, `${JSON.stringify(metrics)}\\n`);\n}", "  if (isModerationResponse(res)) {\n    const { flagged } = res;\n    Object.assign(metrics, { data: { flagged } });\n  }\n\n  Object.assign(metrics, {  type: metric.promptType, template: metric.promptTemplate, rawResponses, failures });\n\n  fs.appendFileSync(config.ai.logFile, `${JSON.stringify(metrics)}\\n`);\n}"]}
{"filename": "src/server/parser.ts", "chunked_list": ["import { isConvertPurposeResult } from \"../lib/prompts/convert_purpose_prompt\";\nimport { isCreateApiBackendResult } from \"../lib/prompts/create_api_backend_prompt\";\nimport { isCreateApiResult } from \"../lib/prompts/create_api_prompt\";\nimport { isGeneralComponentResponse } from \"../lib/prompts/create_gen_component_prompt\";\nimport { isCreateTypeResponse } from \"../lib/prompts/create_type_prompt\";\nimport { isFileEditorResult } from \"../lib/prompts/file_editor_prompt\";\nimport { isGuidedEditResult } from \"../lib/prompts/guided_edit_prompt\";\nimport type { GuardValidations } from \"../lib/types\";\nimport { processTextWithCodeBlock, stripWrappedCharacter } from \"./util\";\n\nexport function parseChatAttempt<T>(attempt: string): { supportingText: string, message: T } {\n  const aiRefusalError = /(^i\\'m sorry)|(?:ai(?:\\s|-)?language(?:\\s|-)?model|i(?:'?m| am))(?:[^.]*?)(?:can(?:'?t| not)|unable to)(?:[^.]*?)(?:perform|do|create|provide)/i;", "import { processTextWithCodeBlock, stripWrappedCharacter } from \"./util\";\n\nexport function parseChatAttempt<T>(attempt: string): { supportingText: string, message: T } {\n  const aiRefusalError = /(^i\\'m sorry)|(?:ai(?:\\s|-)?language(?:\\s|-)?model|i(?:'?m| am))(?:[^.]*?)(?:can(?:'?t| not)|unable to)(?:[^.]*?)(?:perform|do|create|provide)/i;\n  if (aiRefusalError.test(attempt)) {\n    throw new Error('AI Refusal');\n  }\n\n  const isAbstractWrap = attempt.includes('&&&') && attempt.includes('@@@');\n  const isBacktickWrap = attempt.includes('```');\n", "  if (isAbstractWrap || isBacktickWrap) {\n    let innerBlockText = '';\n    let supportingText = '';\n    if (isBacktickWrap) { \n      const processedText = processTextWithCodeBlock(attempt);\n      innerBlockText = processedText.codeBlock;\n      supportingText = processedText.supportingText;\n    } else {\n      const outerBlockStart = attempt.indexOf('&&&') + 3;\n      const outerBlockEnd = attempt.lastIndexOf('&&&');\n      const pretextEnd = attempt.indexOf('@@@');\n      const innerBlockStart = pretextEnd + 3;\n      const innerBlockEnd = attempt.lastIndexOf('@@@');\n      const postTextStart = innerBlockEnd + 3;\n      innerBlockText = attempt.slice(innerBlockStart, innerBlockEnd);\n\n      const pretext = attempt.slice(outerBlockStart, pretextEnd);\n      const posttext = attempt.slice(postTextStart, outerBlockEnd);\n      supportingText = pretext + '\\n' + posttext;\n\n      console.log({\n        ABSTRACTMATCHFOUND: true,\n        outerBlockStart,\n        outerBlockEnd,\n        pretextEnd,\n        innerBlockStart,\n        innerBlockEnd,\n        postTextStart\n      });\n    }\n\n    console.log({ supportingText, innerBlockText })\n", "    if (!innerBlockText.length) {\n      throw new Error('cannot parse Block structure is not valid.');\n    }\n  \n    try {\n      if (innerBlockText.startsWith('{') || innerBlockText.startsWith('[')) {\n        JSON.parse(innerBlockText);\n      }\n    } catch (error) {\n      const err = error as Error;\n      throw new Error('cannot parse json.' + err.message)\n    }\n\n    console.log(\"Validating innerblocktext : \", innerBlockText)\n  \n    const result = validateTypedResponse<T>(innerBlockText);\n  \n    return { message: result, supportingText };\n\n  }\n\n  attempt = stripWrappedCharacter(attempt);\n\n  console.log(\"Parsing a basic attempt: \", attempt);\n\n  const result = validateTypedResponse<T>(attempt);\n\n  return { message: result, supportingText: '' };\n}\n\nexport let responseValidators = [\n  isConvertPurposeResult,\n  isFileEditorResult,\n  isGuidedEditResult,\n  isCreateTypeResponse,\n  isCreateApiResult,\n  isCreateApiBackendResult,\n  isGeneralComponentResponse\n];\n", "    } catch (error) {\n      const err = error as Error;\n      throw new Error('cannot parse json.' + err.message)\n    }\n\n    console.log(\"Validating innerblocktext : \", innerBlockText)\n  \n    const result = validateTypedResponse<T>(innerBlockText);\n  \n    return { message: result, supportingText };\n\n  }\n\n  attempt = stripWrappedCharacter(attempt);\n\n  console.log(\"Parsing a basic attempt: \", attempt);\n\n  const result = validateTypedResponse<T>(attempt);\n\n  return { message: result, supportingText: '' };\n}\n\nexport let responseValidators = [\n  isConvertPurposeResult,\n  isFileEditorResult,\n  isGuidedEditResult,\n  isCreateTypeResponse,\n  isCreateApiResult,\n  isCreateApiBackendResult,\n  isGeneralComponentResponse\n];\n", "export function injectResponseValidators(validators: ((obj: GuardValidations) => boolean)[]): void {\n  responseValidators = responseValidators.concat(validators);\n}\n\nexport function validateTypedResponse<T>(response: string): T {\n  if (!response) {\n    throw new Error('empty response');\n  }\n\n  try {\n    let body: GuardValidations = response;\n", "  try {\n    let body: GuardValidations = response;\n\n    try {\n      body = JSON.parse(response);\n    } catch (error) {}\n    \n    for (const tg of responseValidators) {\n      if (body && tg(body)) {\n        return body as T;\n      }\n      console.log('Guard function:', tg.name, 'Result:', tg(body));\n    }", "      if (body && tg(body)) {\n        return body as T;\n      }\n      console.log('Guard function:', tg.name, 'Result:', tg(body));\n    }\n  } catch (error) { }\n\n  throw new Error('bad chat format');\n}"]}
{"filename": "src/server/config.ts", "chunked_list": ["// config.ts\nimport fs from 'fs';\nimport path from 'path';\nimport type { Config as RootConfig, ConfigPropTypes } from '../lib/types';\nimport { isConfigNestedObject } from '../lib/util';\n\nexport const isCliRunning = process.argv[1].includes('bin/src/cli.js');\nexport const isCalledWithNpx = process.env.npm_execpath && /npx(-cli\\.js)?$/.test(process.env.npm_execpath);\n\nconst normalPath = path.join(__dirname, `${isCliRunning ? '../..' : isCalledWithNpx ? process.cwd() : '..'}/config.json`)", "\nconst normalPath = path.join(__dirname, `${isCliRunning ? '../..' : isCalledWithNpx ? process.cwd() : '..'}/config.json`)\nconst npxPath = path.join(process.cwd(), 'config.json')\n\nexport const configFilePath = isCalledWithNpx ? npxPath : normalPath;\n\n\n// Default configuration values\nexport const defaultConfig = {\n  ai: { retries: '3', logFile: 'results.json', chatModel: 'gpt-3.5-turbo', completionModel: 'curie' },", "export const defaultConfig = {\n  ai: { retries: '3', logFile: 'results.json', chatModel: 'gpt-3.5-turbo', completionModel: 'curie' },\n  ts: { configPath: '', typeDir: '', compDir: '' },\n  git: { rootPath: '', source: 'main', remote: 'origin' },\n  user: { name: 'wizapp' }\n};\n\ntype Config = RootConfig<typeof defaultConfig>;\n\n// Load existing configuration or create a new file with default values\nexport let config = defaultConfig;", "export function checkConfigExists() {\n  if (fs.existsSync(configFilePath)) {\n    const rawData = fs.readFileSync(configFilePath);\n    config = JSON.parse(rawData.toString());\n  } else {\n    fs.writeFileSync(configFilePath, JSON.stringify(defaultConfig, null, 2));\n    config = defaultConfig;\n  }\n}\n\ncheckConfigExists();\n\n// Function to save the configuration", "export function saveConfig(): void {\n  fs.writeFileSync(configFilePath, JSON.stringify(config, null, 2));\n}\n\nexport function setConfig(newConfig: Config): void {\n  config = newConfig;\n}\n\nexport function getConfig(): Config {\n  return config;\n}\n", "export function getConfig(): Config {\n  return config;\n}\n\nexport function getConfigFromPath(configPath: string): Config {\n  let optionalConfig: Config;\n\n  try {\n    const configText = fs.readFileSync(configPath, 'utf-8');\n    optionalConfig = JSON.parse(configText) as Config;\n  } catch (error) {\n    optionalConfig = defaultConfig;\n  }\n\n  return optionalConfig;\n}\n\n// Helper function", "  } catch (error) {\n    optionalConfig = defaultConfig;\n  }\n\n  return optionalConfig;\n}\n\n// Helper function\nexport function getConfigValue(config: Config, keys: string[]): [Record<string, ConfigPropTypes | Record<string, ConfigPropTypes>>, string] {\n  let current: Record<string, ConfigPropTypes | Record<string, ConfigPropTypes>> = config;\n", "export function getConfigValue(config: Config, keys: string[]): [Record<string, ConfigPropTypes | Record<string, ConfigPropTypes>>, string] {\n  let current: Record<string, ConfigPropTypes | Record<string, ConfigPropTypes>> = config;\n\n  for (let i = 0; i < keys.length - 1; i++) {\n    if (!isConfigNestedObject(current[keys[i]])) {\n      throw new Error('invalid config key');\n    }\n    current = current[keys[i]] as Record<string, ConfigPropTypes>;\n  }\n\n  return [current, keys[keys.length - 1]];\n}"]}
{"filename": "src/server/types.ts", "chunked_list": ["import { CreateChatCompletionRequest, CreateCompletionRequest, CreateModerationRequest } from \"openai\";\n\nexport type OpenAIRequestShapes = CreateChatCompletionRequest | CreateCompletionRequest | CreateModerationRequest;\n"]}
{"filename": "src/server/cli.ts", "chunked_list": ["#!/usr/bin/env node\n\n\nimport yargs from 'yargs/yargs';\nimport { config, saveConfig, getConfigValue, checkConfigExists } from './config';\nimport * as spells from './spells';\nimport { IPrompts } from '../lib/prompts';\n\nconst parser = yargs(process.argv.slice(2))\n  // .options({", "const parser = yargs(process.argv.slice(2))\n  // .options({\n  //   'config': {\n  //     alias: 'c',\n  //     describe: 'Path to the configuration file',\n  //     default: 'config.json',\n  //     type: 'string',\n  //   },\n  //   'verbose': {\n  //     alias: 'v',", "  //   'verbose': {\n  //     alias: 'v',\n  //     describe: 'Display verbose output',\n  //     default: false,\n  //     type: 'boolean',\n  //   },\n  // })\n  .command(\n    'set [key] [value]',\n    'Set a configuration value',", "    'set [key] [value]',\n    'Set a configuration value',\n    (yargs) => {\n      return yargs.positional('key', {\n        describe: 'Configuration key to set',\n        type: 'string',\n      }).positional('value', {\n        describe: 'Value to set for the configuration key',\n        type: 'string',\n      });", "        type: 'string',\n      });\n    },\n    (argv) => {\n      checkConfigExists();\n      if (!argv.key) throw new Error('key required');\n      const keys = argv.key.split('.');\n      const [current, lastKey] = getConfigValue(config, keys);\n      current[lastKey] = argv.value || '';\n      saveConfig();\n    }\n  )\n  .command(\n    'use-ai [promptType] [prompts...]',\n    'Use AI with the specified prompts',\n    (yargs) => {\n      return yargs\n        .positional('promptType', {", "          describe: 'The type of prompt to use',\n          default: undefined,\n          type: 'string',\n        })\n        .positional('prompts', {\n          describe: 'Prompts',\n          demandOption: true,\n          type: 'string',\n          nargs: 1,\n          array: true,\n        });\n    },\n    async (argv) => {\n      await spells.useAi(argv.promptType as IPrompts | undefined, ...argv.prompts)\n        .then((result) => console.log(result))", "        .catch((error) => console.error(error));\n    }\n  )\n  .command(\n    'guided-edit [fileNameWithInstructions] [optionalName]',\n    'Run guided edit',\n    (yargs) => {\n      return yargs\n        .positional('fileNameWithInstructions', {\n          describe: 'File name with instructions',\n          type: 'string',\n          demandOption: true\n        })\n        .positional('optionalName', {\n          describe: 'Optional name',\n          type: 'string',\n        })\n        .options({\n          'commit': {\n            type: 'boolean',\n            description: 'Will commit edits to the generated branch',\n            default: true,\n          },\n          'pull-request': {\n            type: 'boolean',\n            description: 'Will create and add to 1 pull request per generated branch',\n            default: true,\n          },\n        });\n    },\n    async (argv) => {\n      await spells.guidedEdit(argv.fileNameWithInstructions, argv.optionalName)\n        .then((result) => console.log(result))", "        .catch((error) => console.error(error));\n    }\n  )\n  .command(\n    'file-editor <fileName> [instructions...]',\n    'Edit any file',\n    (yargs) => {\n      return yargs\n        .positional('fileName', {\n          describe: 'File Name',\n          type: 'string',\n          demandOption: true\n        })\n        .positional('instructions', {\n          describe: 'File name with instructions',\n          type: 'string',\n          array: true,\n          demandOption: true\n        });\n    },\n    async (argv) => {\n      await spells.fileEditor(argv.fileName, ...argv.instructions)\n        .then((result) => console.log(result))", "        .catch((error) => console.error(error));\n    }\n  )\n  .command(\n    'create-component [description]',\n    'Create a component',\n    (yargs) => {\n      return yargs\n        .positional('description', {\n          describe: 'Component description',\n          demandOption: true,\n          type: 'string',\n        });\n    },\n    async (argv) => {\n      await spells.createComponent(argv.description)\n        .then((result) => console.log(result))", "        .catch((error) => console.error(error));\n    }\n  )\n  .command(\n    'create-api [typeName]',\n    'Create an API',\n    (yargs) => {\n      return yargs\n        .positional('typeName', {\n          describe: 'API type name',\n          demandOption: true,\n          type: 'string',\n        });\n    },\n    async (argv) => {\n      const generatedType = await spells.createType(argv.typeName) \n\n      await spells.createApi(argv.typeName, generatedType)\n        .then((result) => console.log(result))", "          describe: 'API type name',\n          demandOption: true,\n          type: 'string',\n        });\n    },\n    async (argv) => {\n      const generatedType = await spells.createType(argv.typeName) \n\n      await spells.createApi(argv.typeName, generatedType)\n        .then((result) => console.log(result))\n        .catch((error) => console.error(error));\n\n      await spells.createApiBackend(argv.typeName, generatedType);\n    }\n  )\n  .demandCommand(1, 'You need at least one command before moving on')\n  .help()\n  .alias('h', 'help')\n  .strict();\n\n(async () => {\n  await parser.argv;\n})();", "        .catch((error) => console.error(error));\n\n      await spells.createApiBackend(argv.typeName, generatedType);\n    }\n  )\n  .demandCommand(1, 'You need at least one command before moving on')\n  .help()\n  .alias('h', 'help')\n  .strict();\n\n(async () => {\n  await parser.argv;\n})();"]}
{"filename": "src/server/index.ts", "chunked_list": ["export * from './spells';\nexport * from './parser';\nexport * from './util';\nexport * from './request';\nexport * from './stats';\nexport type {\n  OpenAIRequestShapes\n} from './types';"]}
{"filename": "src/server/request.ts", "chunked_list": ["import { CreateModerationRequest, OpenAIApi } from \"openai\";\nimport { aiPrompts, IPrompts } from \"../lib/prompts\";\nimport type { OpenAIRequestShapes } from \"./types\";\nimport { deepClone, isChatRequest, isCompletionRequest, isModerationRequest } from \"./util\";\nimport { getConfig } from \"./config\";\n\nconst openai = new OpenAIApi();\nexport const openAIRequestOptions = {\n  headers: {\n    'Content-Type': 'application/json',", "  headers: {\n    'Content-Type': 'application/json',\n    'Authorization': `Bearer ${process.env.OPENAI_API_KEY as string}`\n  }\n};\n\nexport function buildOpenAIRequest(prompts: string[], promptType?: IPrompts): [OpenAIRequestShapes, string?] {\n  const config = getConfig();\n  if (!promptType) {\n    const moderationRequest: CreateModerationRequest = {\n      input: prompts[0]\n    }\n    return [moderationRequest];\n  }\n\n  const promptTokens = prompts.reduce<Record<string, string>>((m, t, i) => ({ ...m, [`\\$\\{prompt${i + 1}\\}`]: t }), {});\n  const promptTemplate = aiPrompts[promptType];", "  if (!promptType) {\n    const moderationRequest: CreateModerationRequest = {\n      input: prompts[0]\n    }\n    return [moderationRequest];\n  }\n\n  const promptTokens = prompts.reduce<Record<string, string>>((m, t, i) => ({ ...m, [`\\$\\{prompt${i + 1}\\}`]: t }), {});\n  const promptTemplate = aiPrompts[promptType];\n  if (!promptTemplate) throw new Error('invalid prompt type');\n\n  const originalPromptTemplate = JSON.stringify(promptTemplate);\n  const completionStringOrMessageHistory = promptTemplate;\n", "  if (!promptTemplate) throw new Error('invalid prompt type');\n\n  const originalPromptTemplate = JSON.stringify(promptTemplate);\n  const completionStringOrMessageHistory = promptTemplate;\n\n  if ('string' === typeof completionStringOrMessageHistory) {\n    let completionString = String(completionStringOrMessageHistory);\n    for (const token in promptTokens) {\n      completionString = completionString.replaceAll(token, promptTokens[token]);\n    }\n    const completionRequest = {\n      model: config.ai.completionModel,\n      prompt: completionString\n    };\n    return [completionRequest, originalPromptTemplate]\n  }\n", "  if (Array.isArray(completionStringOrMessageHistory)) {\n    const messageHistory = deepClone(completionStringOrMessageHistory);\n    for (let item of messageHistory) {\n      if (item.content.includes('${') && item.content.includes('}')) {\n        for (const token in promptTokens) {\n          item.content = item.content.replaceAll(token, promptTokens[token]);\n        }\n      }\n    }\n\n    const chatRequest = {\n      model: config.ai.chatModel,\n      messages: messageHistory\n    };\n    return [chatRequest, originalPromptTemplate]\n  }\n\n  throw new Error('invalid prompting procedure');\n}\n", "export async function performRequest(request: OpenAIRequestShapes): Promise<string | boolean | undefined> {\n  console.log('OpenAIActionTrigger  =::= ', JSON.stringify(request, null, 2))\n  if (isChatRequest(request)) {\n    const chatResponse = await openai.createChatCompletion(request, openAIRequestOptions);\n    console.log({ RAW_CHAT: chatResponse.data.choices[0] });\n    return chatResponse.data.choices[0]?.message?.content.trim();\n  } else if (isCompletionRequest(request)) {\n    const completionResponse = await openai.createCompletion(request, openAIRequestOptions);\n    console.log({ RAW_COMPLETION: completionResponse.data.choices[0] });\n    return completionResponse.data.choices[0].text?.trim();\n  } else if (isModerationRequest(request)) {\n    const moderationResponse = await openai.createModeration(request, openAIRequestOptions);\n    console.log({ RAW_MODERATION: moderationResponse.data.results[0] });\n    return moderationResponse.data.results[0]?.flagged;\n  }\n}", "  } else if (isModerationRequest(request)) {\n    const moderationResponse = await openai.createModeration(request, openAIRequestOptions);\n    console.log({ RAW_MODERATION: moderationResponse.data.results[0] });\n    return moderationResponse.data.results[0]?.flagged;\n  }\n}"]}
{"filename": "src/server/util.ts", "chunked_list": ["import fs from 'fs';\nimport path from \"path\";\nimport { sync } from 'fast-glob';\nimport { isCalledWithNpx, isCliRunning } from \"./config\";\n\nimport languages from \"../lib/languages\";\nimport type { OpenAIRequestShapes } from './types';\nimport { CreateChatCompletionRequest, CreateCompletionRequest, CreateModerationRequest } from 'openai';\nconst langValues = Object.values(languages);\n", "const langValues = Object.values(languages);\n\nexport const codeGPTPrecursor = 'You are BacktickGPT, providing only typescript code responses wrapped with 3 backticks before and after.';\n\nexport function deepClone<T>(obj: T): T {\n  if (obj === null || typeof obj !== 'object') {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map((item) => deepClone(item) as T) as unknown as T;\n  }\n\n  const result: Record<string, unknown> = {};\n", "  if (Array.isArray(obj)) {\n    return obj.map((item) => deepClone(item) as T) as unknown as T;\n  }\n\n  const result: Record<string, unknown> = {};\n\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      result[key] = deepClone((obj as Record<string, unknown>)[key]);\n    }\n  }\n\n  return result as T;\n}\n\nexport const isValidName = (name: string): boolean => {\n  const regex = /^I[A-Z][a-zA-Z]*$/;\n  return regex.test(name);\n};\n\nexport const toSnakeCase = (name: string): string => {", "  if (!isValidName(name)) {\n    throw new Error(\"Invalid name format\");\n  }\n  return name.substr(1).replace(/[A-Z]/g, (match) => `_${match.toLowerCase()}`).slice(1);\n};\n\nexport const toTitleCase = (name: string): string => {\n  if (!isValidName(name)) {\n    throw new Error(\"Invalid name format\");\n  }\n  return name.substr(1).replace(/([A-Z])/g, \" $1\").replace(/^./, (str) => str.toUpperCase());\n};\n", "export function extractCodeBlock(inputString: string, delimeter: string = '```', languages: string[] = ['typescript', 'json', 'jsx', 'tsx']) {\n  const langStartTag = (language: string) => language ? `${delimeter}${language}` : delimeter;\n\n  for (const language of languages) {\n    const startTag = langStartTag(language);\n    if (inputString.includes(startTag)) {\n      return {\n        codeBlock: inputString.split(startTag)[1].split(delimeter)[0],\n        index: inputString.indexOf(startTag) + startTag.length,\n      };\n    }\n  }\n", "  if (inputString.includes(delimeter)) {\n    const index = inputString.indexOf(delimeter) + delimeter.length;\n    return {\n      codeBlock: inputString.split(delimeter)[1],\n      index,\n    };\n  }\n\n  return {\n    codeBlock: inputString,\n    index: 0,\n  };\n};\n", "export function extractCodeBlockPre(inputString: string, index: number): string {\n  return inputString.substring(0, index)?.trim() || '';\n}\n\nexport function extractCodeBlockPost(inputString: string, index: number, delimeter: string = '```'): string {\n  return inputString.substring(index).split(delimeter)[1]?.trim() || '';\n}\n\nexport function processTextWithCodeBlock(inputString: string): { codeBlock: string; supportingText: string } {\n  const { codeBlock, index } = extractCodeBlock(inputString);\n  const preText = extractCodeBlockPre(inputString, index);\n  const postText = extractCodeBlockPost(inputString, index);\n\n  return {\n    codeBlock,\n    supportingText: preText + ' ' + postText,\n  };\n}\n", "export function processTextWithCodeBlock(inputString: string): { codeBlock: string; supportingText: string } {\n  const { codeBlock, index } = extractCodeBlock(inputString);\n  const preText = extractCodeBlockPre(inputString, index);\n  const postText = extractCodeBlockPost(inputString, index);\n\n  return {\n    codeBlock,\n    supportingText: preText + ' ' + postText,\n  };\n}\n", "export function stripWrappedCharacter(inputString: string, wrappedCharacters: string[] = ['\"', \"'\"]): string {\n  for (const char of wrappedCharacters) {\n    if (inputString.startsWith(char)) inputString = inputString.slice(1); \n    if (inputString.endsWith(char)) inputString = inputString.substring(0, inputString.length - 1); \n  }\n  return inputString;\n}\n\nexport function sanitizeName(input: string): string {\n  // Trim whitespaces and replace consecutive spaces with a single dash\n  const trimmed = input.trim();\n\n  // Remove invalid characters: ~ ^ : ? * [ ] @ { } \\ /\n  const sanitized = trimmed.replace(/[~^:?\"*\\[\\]@{}\\\\/]+/g, '');\n\n  // Limit branch name length to 100 characters\n  const maxLength = 100;\n  const shortened = sanitized.slice(0, maxLength);\n\n  // Remove leading and trailing period (.)\n  const noLeadingTrailingPeriods = shortened.replace(/(^\\.+|\\.+$)/g, '');\n\n  // Remove leading and trailing forward slash (-)\n  const result = noLeadingTrailingPeriods.replace(/(^-+|-+$)/g, '');\n\n  return result;\n}\n", "export function sanitizeName(input: string): string {\n  // Trim whitespaces and replace consecutive spaces with a single dash\n  const trimmed = input.trim();\n\n  // Remove invalid characters: ~ ^ : ? * [ ] @ { } \\ /\n  const sanitized = trimmed.replace(/[~^:?\"*\\[\\]@{}\\\\/]+/g, '');\n\n  // Limit branch name length to 100 characters\n  const maxLength = 100;\n  const shortened = sanitized.slice(0, maxLength);\n\n  // Remove leading and trailing period (.)\n  const noLeadingTrailingPeriods = shortened.replace(/(^\\.+|\\.+$)/g, '');\n\n  // Remove leading and trailing forward slash (-)\n  const result = noLeadingTrailingPeriods.replace(/(^-+|-+$)/g, '');\n\n  return result;\n}\n", "export function ensureKeysAreQuoted(jsonString: string): string {\n  const unquotedKeysRegex = /([{,]\\s*)(\\w+)\\s*:/g;\n  function quoteKeys(match: unknown, prefix: string, key: string) {\n    return `${prefix}\"${key}\":`;\n  }\n  return jsonString.replace(unquotedKeysRegex, quoteKeys);\n}\n\nexport function typeDefinitionToSentence(typeDefinition: string): string {\n  const typeNameMatch = typeDefinition.match(/export type (\\w+)/);\n", "export function typeDefinitionToSentence(typeDefinition: string): string {\n  const typeNameMatch = typeDefinition.match(/export type (\\w+)/);\n\n  if (!typeNameMatch) {\n    return 'Invalid type definition provided.';\n  }\n\n  const typeName = typeNameMatch[1];\n  const properties = [];\n  const propertyRegex = /(\\w+)\\s*:\\s*([^;]+);/g;\n\n  let match;", "  while ((match = propertyRegex.exec(typeDefinition)) !== null) {\n    properties.push({ key: match[1], type: match[2].trim().replace(/\\s+/g, ' ') });\n  }\n\n  if (properties.length > 0) {\n    const propertiesDescription = properties\n      .map((property) => `${property.key} as a ${property.type}`)\n      .join(', ');\n\n    return `${typeName} defines ${propertiesDescription}.`;\n  } else {\n    const recordMatch = typeDefinition.match(/Record<(.+),\\s*(.+)>/);", "    if (recordMatch) {\n      return `${typeName} is a Record ${recordMatch[1]} of ${recordMatch[2]}.`;\n    }\n  }\n\n  return 'Unable to parse the type definition.';\n}\n\nexport function getDirPathOf(filePath: string) {\n  return path.dirname(filePath)\n}\n", "export function getDirPathOf(filePath: string) {\n  return path.dirname(filePath)\n}\n\nexport function generateTempFilePath(dir: string, name: string) {\n  return path.join(dir, `${name}-${Date.now()}.json`)\n}\n\nexport function getRootDir() {\n  return isCalledWithNpx ? process.cwd() : path.join(__dirname, isCliRunning ? '../../' : '../');\n}\n", "export function getRootDir() {\n  return isCalledWithNpx ? process.cwd() : path.join(__dirname, isCliRunning ? '../../' : '../');\n}\n\nexport function getPathOf(name: string, baseDir?: string): string {\n  return path.join(baseDir || getRootDir(), name);\n}\n\nexport function getFileParser(fileName: string) {\n  const extension = path.extname(fileName);\n  const parser = langValues.find(l => l.fileExtension.includes(extension));", "export function getFileParser(fileName: string) {\n  const extension = path.extname(fileName);\n  const parser = langValues.find(l => l.fileExtension.includes(extension));\n  if (!parser) throw 'That parser is undefined!';\n  return parser.parserName;\n}\n\nexport function getFileFromDir(file: string, dir: string = __dirname) {\n  const files = fs.readdirSync(dir);\n  const fileName = files.find(f => f.startsWith(file));\n  if (!fileName) throw 'File not found.';\n  return fs.readFileSync(path.join(dir, fileName), { encoding: 'utf-8' })\n}\n", "  if (!fileName) throw 'File not found.';\n  return fs.readFileSync(path.join(dir, fileName), { encoding: 'utf-8' })\n}\n\nexport function getTargetFile(targetFile: string, rootDir: string = getRootDir(), ignoredDirectories: string[] = excludeDirectories): string | null {\n  const pattern = path.join(rootDir, '**', targetFile);\n\n  const files = sync(pattern, {\n    ignore: ignoredDirectories.map(dir => path.join('**', dir, '**')),\n    onlyFiles: true,\n  });\n", "  if (!files.length) {\n    throw 'No file found.';\n  }\n  \n  if (files.length > 1) {\n    throw 'Multiple files were found. Please specifiy with a local folder path.';\n  }\n\n  const fileContent = fs.readFileSync(files[0], { encoding: 'utf-8' });\n\n  console.log({ gotfiles: files, fileContent})\n\n  return files.length > 0 ? fileContent : null;\n}\n", "export function saveTargetFile(targetFile: string, contents: string, rootDir: string = getRootDir(), ignoredDirectories: string[] = excludeDirectories): string {\n  const pattern = path.join(rootDir, '**', targetFile);\n\n  const files = sync(pattern, {\n    ignore: ignoredDirectories.map(dir => path.join('**', dir, '**')),\n    onlyFiles: true,\n  });\n\n  if (!files.length) {\n    throw 'No file found.';\n  }\n  ", "  if (!files.length) {\n    throw 'No file found.';\n  }\n  \n  if (files.length > 1) {\n    throw 'Multiple files were found. Please specifiy with a local folder path.';\n  }\n\n  const fileContent = fs.writeFileSync(files[0], contents, { encoding: 'utf-8' });\n\n  console.log({ gotfiles: files, fileContent})\n\n  return 'file saved';\n}\n\nconst excludeDirectories = [\n  'node_modules',\n  'vendor',\n  'dist',\n  'build',\n  '.git',\n  '.svn',\n  // add other directories to exclude\n];\n", "export function isChatRequest(obj: OpenAIRequestShapes): obj is CreateChatCompletionRequest {\n  return 'messages' in obj;\n}\n\nexport function isCompletionRequest(obj: OpenAIRequestShapes): obj is CreateCompletionRequest {\n  return 'prompt' in obj;\n}\n\nexport function isModerationRequest(obj: OpenAIRequestShapes): obj is CreateModerationRequest {\n  return 'input' in obj;\n}", "export function isModerationRequest(obj: OpenAIRequestShapes): obj is CreateModerationRequest {\n  return 'input' in obj;\n}"]}
{"filename": "src/server/git/push_commit.ts", "chunked_list": ["import simpleGit from \"simple-git\";\nimport { sanitizeName } from \"../util\";\nimport { getConfig } from \"../config\";\nimport { gitCheck } from \"./check_git_cli\";\n\nexport async function pushCommit(path: string, branch: string, msg: string) {\n  gitCheck();\n  const config = getConfig();\n  if (!config.git.rootPath) {\n    throw 'Missing config.git.rootPath.'\n  }\n\n  const git = simpleGit(config.git.rootPath);\n\n  console.log('Adding ', path, ' to ', branch);\n  await git.add(path);\n\n  const commitMsg = sanitizeName(msg).slice(0, 50);\n  console.log('Creating commit:', commitMsg);\n  await git.commit(commitMsg);\n\n  console.log('Pushing changes to ', branch);\n  await git.push(config.git.remote, branch);\n}\n", "  if (!config.git.rootPath) {\n    throw 'Missing config.git.rootPath.'\n  }\n\n  const git = simpleGit(config.git.rootPath);\n\n  console.log('Adding ', path, ' to ', branch);\n  await git.add(path);\n\n  const commitMsg = sanitizeName(msg).slice(0, 50);\n  console.log('Creating commit:', commitMsg);\n  await git.commit(commitMsg);\n\n  console.log('Pushing changes to ', branch);\n  await git.push(config.git.remote, branch);\n}\n"]}
{"filename": "src/server/git/go_home.ts", "chunked_list": ["import simpleGit from \"simple-git\";\nimport { getConfig } from \"../config\";\nimport { gitCheck } from \"./check_git_cli\";\n\nexport async function goHome(): Promise<string> {\n  gitCheck();\n  const config = getConfig();\n  if (!config.git.rootPath) {\n    throw 'Missing config.git.rootPath.'\n  }\n\n  const git = simpleGit(config.git.rootPath);\n\n  await git.checkout(config.git.source);\n\n  return 'relocated to git root';\n}\n"]}
{"filename": "src/server/git/check_git_cli.ts", "chunked_list": ["import { execSync } from \"child_process\";\n\nexport async function checkGitCli() {\n  try {\n    // Check if the GitHub CLI is installed\n    const version = execSync(\"gh --version\").toString();\n    console.log(`GitHub CLI installed: ${version}`);\n\n    // Check if the GitHub CLI is properly configured\n    const config = execSync(\"gh config get git_protocol\").toString().trim();\n    console.log(`GitHub CLI configuration (git_protocol): ${config}`);\n\n    return config === \"ssh\" || config === \"https\";", "  } catch (error) {\n    const err = error as Error;\n    console.error(\"Error:\", err.message);\n    return false;\n  }\n}\n\nexport function gitCheck() {\n  if (!checkGitCli()) throw new Error('github cli is required to be installed and configured in order to use this flow');\n}", "  if (!checkGitCli()) throw new Error('github cli is required to be installed and configured in order to use this flow');\n}"]}
{"filename": "src/server/git/prepare_branch.ts", "chunked_list": ["import simpleGit from \"simple-git\";\nimport { sanitizeName } from \"../util\";\nimport { getConfig } from \"../config\";\nimport { gitCheck } from \"./check_git_cli\";\n\nexport async function prepareBranch(name: string): Promise<string> {\n  gitCheck();\n  const config = getConfig();\n  if (!config.git.rootPath) {\n    throw 'Missing config.git.rootPath.'\n  }\n\n  const git = simpleGit(config.git.rootPath);\n  const generatedBranch = sanitizeName(`gen/${name}`);\n\n  console.log('Prepare branch main checkout.');\n  await git.checkout(config.git.source);\n\n  console.log('Pulling main.');\n  await git.pull(config.git.remote, config.git.source);\n\n  console.log('Fetching.');\n  await git.fetch('all');\n", "  if (!config.git.rootPath) {\n    throw 'Missing config.git.rootPath.'\n  }\n\n  const git = simpleGit(config.git.rootPath);\n  const generatedBranch = sanitizeName(`gen/${name}`);\n\n  console.log('Prepare branch main checkout.');\n  await git.checkout(config.git.source);\n\n  console.log('Pulling main.');\n  await git.pull(config.git.remote, config.git.source);\n\n  console.log('Fetching.');\n  await git.fetch('all');\n", "  try {\n    console.log('Creating a new branch for ', generatedBranch);\n    await git.checkoutBranch(generatedBranch, config.git.source);\n    await git.push(config.git.remote, generatedBranch, ['--set-upstream', generatedBranch])\n  } catch (error) {\n    const err = error as Error;\n    if (err.message.includes('A branch named') && err.message.includes('already exists')) {\n      console.log('Checking out existing generated branch ', generatedBranch);\n      await git.checkout(generatedBranch);\n  \n      console.log('Pulling generated branch.');\n      await git.pull(config.git.remote, generatedBranch);\n    }\n  }\n\n  return generatedBranch;\n}\n"]}
{"filename": "src/server/git/index.ts", "chunked_list": ["export { gitCheck, checkGitCli } from './check_git_cli';\nexport { managePullRequest } from './manage_pull_request';\nexport { prepareBranch } from './prepare_branch';\nexport { pushCommit } from './push_commit';\nexport { goHome } from './go_home';"]}
{"filename": "src/server/git/manage_pull_request.ts", "chunked_list": ["import { execSync } from \"child_process\";\nimport { gitCheck } from \"./check_git_cli\";\nimport { getConfig } from \"../config\";\n\n\nexport async function managePullRequest(branch: string, title: string, body: string) {\n  gitCheck();\n  const config = getConfig();\n  if (!config.git.rootPath) {\n    throw 'Missing config.git.rootPath.'\n  }\n\n  const prListOutput = JSON.parse(Buffer.from(execSync(`gh pr list --state open --base ${config.git.source} --json number,headRefName,url`, { cwd: config.git.rootPath })).toString()) as { number: number, headRefName: string, url: string }[];\n\n  const existingPr = prListOutput.find(pr => pr.headRefName === branch);\n  ", "  if (!config.git.rootPath) {\n    throw 'Missing config.git.rootPath.'\n  }\n\n  const prListOutput = JSON.parse(Buffer.from(execSync(`gh pr list --state open --base ${config.git.source} --json number,headRefName,url`, { cwd: config.git.rootPath })).toString()) as { number: number, headRefName: string, url: string }[];\n\n  const existingPr = prListOutput.find(pr => pr.headRefName === branch);\n  \n  if (!existingPr) {\n    execSync(`gh pr create --title \"${title}\" --body \"${body}\" --head \"${branch}\" --base \"${config.git.source}\"`, { cwd: config.git.rootPath });\n  } else {\n    execSync(`gh pr review ${existingPr.number} --comment -b \"${title}\\n\\n${body}\"`, { cwd: config.git.rootPath }); \n  }\n\n  return `guided edit process sucessfully ${existingPr?.number ? 'updated' : 'created'} ${existingPr?.url}`;\n}", "  if (!existingPr) {\n    execSync(`gh pr create --title \"${title}\" --body \"${body}\" --head \"${branch}\" --base \"${config.git.source}\"`, { cwd: config.git.rootPath });\n  } else {\n    execSync(`gh pr review ${existingPr.number} --comment -b \"${title}\\n\\n${body}\"`, { cwd: config.git.rootPath }); \n  }\n\n  return `guided edit process sucessfully ${existingPr?.number ? 'updated' : 'created'} ${existingPr?.url}`;\n}"]}
{"filename": "src/server/spells/create_api_backend_spell.ts", "chunked_list": ["import { Project } from 'ts-morph';\nimport { getConfig } from '../config';\nimport { getPathOf, sanitizeName, toSnakeCase, toTitleCase } from '../util';\nimport { useAi } from './use_ai_spell';\nimport { IPrompts } from '../../lib/prompts';\nimport { CreateApiBackendResult } from '../../lib/prompts/create_api_backend_prompt';\n\nexport async function createApiBackend(typeName: string, generatedType: string): Promise<string> {\n  const config = getConfig();\n  if (!config.ts.configPath) {\n    throw new Error('Missing ts.configPath.');\n  }", "  if (!config.ts.configPath) {\n    throw new Error('Missing ts.configPath.');\n  }\n  if (!config.ts.typeDir) {\n    throw new Error('Missing ts.typeDir.');\n  }\n  const project = new Project({\n    tsConfigFilePath: config.ts.configPath\n  });\n\n  const coreTypesPath = sanitizeName(config.ts.typeDir);\n  const typeFileName = getPathOf(`${coreTypesPath}/${toSnakeCase(typeName)}.ts`);\n  const sourceFile = project.addSourceFileAtPath(typeFileName);\n  const variables = sourceFile.getVariableDeclarations();\n  const apiEndpoints: string[] = [];\n", "  for (const v of variables) {\n    if (v.getName().endsWith('Api')) {\n      const initializer = v.getInitializer();\n      if (initializer) {\n        initializer.getType().getProperties().forEach(p => {\n          apiEndpoints.push(p.getName())\n        });\n      }\n    }\n  }\n  ", "  try {\n    const generatedApiBackend = await useAi<CreateApiBackendResult>(IPrompts.CREATE_API_BACKEND, generatedType + ' ' + apiEndpoints.join(' '))\n    const comment = `/*\\n* @category ${toTitleCase(typeName)}\\n*/\\n`;\n    sourceFile.insertText(sourceFile.getEnd(), `${comment}${generatedApiBackend.message}\\n\\n`);\n    sourceFile.fixMissingImports();\n    await project.save();\n  } catch (error) {\n    console.error(error);\n  }\n\n  return `generated backend using the type ${typeName}!`;\n}"]}
{"filename": "src/server/spells/use_ai_spell.ts", "chunked_list": ["import { parseChatAttempt } from '../parser';\nimport { IPrompts } from '../../lib/prompts';\nimport { buildOpenAIRequest, performRequest } from '../request';\nimport { logAiResult } from '../stats';\nimport { getConfig } from '../config';\nimport type { ChatResponse, CompletionResponse, ModerationResponse, OpenAIResults, UseAIResponses } from '../../lib/types';\nimport { isCompletionRequest } from '../util';\n\nexport async function useAi<T = undefined>(promptType?: IPrompts, ...prompts: string[]): Promise<UseAIResponses<T>> {\n  \n  const config = getConfig();\n  const retries = parseInt(config.ai.retries, 10);\n\n  const [builtRequest, promptTemplate] = buildOpenAIRequest(prompts, promptType);\n\n  const aiResponse: OpenAIResults = {\n    timestamp: new Date(),\n    successful: true,\n    failures: [],\n    rawResponses: [],\n    promptTemplate,\n    promptType: (!promptType ? 'moderation' : promptType) as IPrompts\n  }\n", "export async function useAi<T = undefined>(promptType?: IPrompts, ...prompts: string[]): Promise<UseAIResponses<T>> {\n  \n  const config = getConfig();\n  const retries = parseInt(config.ai.retries, 10);\n\n  const [builtRequest, promptTemplate] = buildOpenAIRequest(prompts, promptType);\n\n  const aiResponse: OpenAIResults = {\n    timestamp: new Date(),\n    successful: true,\n    failures: [],\n    rawResponses: [],\n    promptTemplate,\n    promptType: (!promptType ? 'moderation' : promptType) as IPrompts\n  }\n", "  try {\n\n    const responseTry = await performRequest(builtRequest);\n\n    aiResponse.rawResponses.push(responseTry);\n\n    if ('undefined' === typeof responseTry) {\n      const noChoices = 'Open AI returned no choices.'\n      aiResponse.failures.push(noChoices);\n      throw new Error(noChoices);\n    }\n", "    if ('boolean' === typeof responseTry) {\n      const moderationResponse: ModerationResponse = { ...aiResponse, flagged: responseTry };\n      console.log('MODERATION RESPONSE :==: ', moderationResponse)\n      logAiResult<T>({ ...moderationResponse, prompts, model: builtRequest.model });\n      return moderationResponse as UseAIResponses<T>;\n    }\n\n    if (isCompletionRequest(builtRequest)) {\n      const completionResponse: CompletionResponse = {\n        ...aiResponse,\n        message: responseTry\n      };\n      console.log('COMPLETION RESPONSE :==: ', completionResponse)\n      logAiResult<T>({ ...completionResponse, prompts, model: builtRequest.model });\n      return completionResponse as UseAIResponses<T>;\n    }\n", "    async function resolveAttempt(attempt: string, retriesRemaining: number): Promise<ChatResponse<T>> {\n      try {\n        const { supportingText, message } = parseChatAttempt<T>(attempt);\n\n        const chatResponse = {\n          ...aiResponse,\n          supportingText,\n          message\n        };\n        logAiResult<T>({ ...chatResponse, prompts, model: builtRequest.model });\n        console.log('CHAT RESPONSE :==: ', chatResponse)\n        return chatResponse;", "      } catch (error) {\n        const err = error as Error;\n        if (retriesRemaining > 0 && err.message.startsWith('cannot parse')) {\n          const repeatedAttempt = await performRequest(builtRequest);\n\n          aiResponse.rawResponses.push(repeatedAttempt);\n\n          if ('string' !== typeof repeatedAttempt) {\n            const imparsable = 'Received imparsable resolution during retry.';\n            aiResponse.failures.push(imparsable);\n            throw new Error(imparsable);\n          }\n\n          return await resolveAttempt(repeatedAttempt, retriesRemaining - 1);\n        }\n\n        const resolveIssue = 'Critical chat parse error or could not resolve a valid response after ' + retries + ' attempts. ' + (err.message ? 'Parsing error: ' + err.message : '');\n        aiResponse.failures.push(resolveIssue);\n        throw new Error(resolveIssue);\n      }\n    }\n\n    return await resolveAttempt(responseTry, retries) as UseAIResponses<T>;", "  } catch (error) {\n    const err = error as Error;\n    aiResponse.successful = false;\n    logAiResult({ ...aiResponse, prompts, message: err.message + ' ' + err.stack, model: builtRequest.model });\n    throw new Error('General use AI failure!\\nStack: ' + err.stack);\n  }\n}\n"]}
{"filename": "src/server/spells/create_api_spell.ts", "chunked_list": ["import fs from 'fs';\nimport { getPathOf, sanitizeName, toSnakeCase, toTitleCase } from '../util';\nimport { useAi } from './use_ai_spell';\nimport { IPrompts } from '../../lib/prompts';\nimport { getConfig } from '../config';\nimport { CreateApiResult } from '../../lib/prompts/create_api_prompt';\n\nexport async function createApi(typeName: string, generatedType: string): Promise<string> {\n\n  const config = getConfig();\n", "  if (!config.ts.typeDir) {\n    throw new Error('Missing ts.typeDir.')\n  }\n\n  const coreTypesPath = sanitizeName(config.ts.typeDir);\n  const typeFilePath = getPathOf(`${coreTypesPath}/${toSnakeCase(typeName)}.ts`);\n  const comment = `/*\\n* @category ${toTitleCase(typeName)}\\n*/\\n`;\n  \n  const generatedApi = await useAi<CreateApiResult>(IPrompts.CREATE_API, generatedType);\n\n  fs.appendFileSync(typeFilePath, `${comment}${generatedApi.message}\\n\\n`);\n\n  return generatedApi.message;\n}"]}
{"filename": "src/server/spells/guided_edit_spell.ts", "chunked_list": ["import { FunctionDeclaration, SyntaxKind, Node, Project } from 'ts-morph';\n\nimport { useAi } from './use_ai_spell';\nimport { IPrompts } from '../../lib/prompts';\nimport { prepareBranch, pushCommit, managePullRequest, goHome } from '../git';\nimport { getConfig } from '../config';\nimport { GuidedEditKeys, GuidedEditResponse } from '../../lib/prompts/guided_edit_prompt';\n\nfunction getStatementText(child: Node) {\n  let parsedStatementText = child.getText();\n  const parent = child.getParent();\n", "function getStatementText(child: Node) {\n  let parsedStatementText = child.getText();\n  const parent = child.getParent();\n\n  if (child.getKind() == SyntaxKind.VariableDeclaration && parent instanceof Node) {\n    parsedStatementText = parent.getText();\n  }\n  return parsedStatementText;\n}\n\nconst ignoredStatements = [SyntaxKind.TryStatement]\n", "function walkNode(child: Node, i: number, parsedStatements: Record<string, string>, originalStatements: Map<string, string>) {\n  const statementName = `statement_${i}`;\n  if (child instanceof FunctionDeclaration) {\n    child.getStatements().forEach((descendant, index) => {\n      walkNode(descendant, index + i, parsedStatements, originalStatements);\n    })\n  } else if (!ignoredStatements.includes(child.getKind())) {\n    parsedStatements[statementName] = getStatementText(child);\n    originalStatements.set(statementName, getStatementText(child));\n  }\n}\n", "export async function guidedEdit(fileParts: string, editingUser?: string): Promise<string> {\n\n  const config = getConfig();\n  if (!config.ts.configPath) {\n    throw new Error('Missing ts.configPath.')\n  }\n  const project = new Project({\n    tsConfigFilePath: config.ts.configPath\n  });\n\n  const [fileName, ...suggestedEdits] = fileParts.split(' ');\n  const suggestions = suggestedEdits.join(' ');\n\n  const generatedBranch = await prepareBranch(editingUser || config.user.name);\n\n", "  try {\n    const sourceFile = project.getSourceFiles().filter(sf => sf.getFilePath().toLowerCase().includes(fileName.toLowerCase()))[0];\n\n    if (sourceFile) {\n\n      if (sourceFile.getText().length > 10000) {\n        return 'the file is too large';\n      }\n\n      const originalStatements: Map<string, string> = new Map();\n      const parsedStatements: Record<string, string> = {};\n\n      sourceFile.getStatements().forEach((statement, index) => {\n        walkNode(statement, index, parsedStatements, originalStatements);\n      });\n\n      const res = await useAi<GuidedEditResponse>(IPrompts.GUIDED_EDIT, suggestions, JSON.stringify(parsedStatements));\n\n      const generatedStatements = res.message.reduce((m, d) => ({ ...m, ...d }), {});\n\n      let fileContent = sourceFile.getFullText();\n      let fileModified = false;\n\n      Object.keys(generatedStatements).forEach(statementKey => {\n        const stKey = statementKey as GuidedEditKeys;", "        if (['new_statement', 'newstatement', `statement_${originalStatements.size + 1}`].includes(stKey)) {\n          fileContent += `\\n${generatedStatements[stKey]} // generated by ${editingUser || config.user.name}`;\n          fileModified = true;\n        } else if ([/^above_\\d{1,2}$/, /^below_\\d{1,2}$/].some(regex => regex.test(stKey))) {\n          const [direction, index] = stKey.split('_');\n          const adjacentStatement = originalStatements.get(`statement_${index}`);\n\n          if (adjacentStatement) {\n            let adjacentStart = fileContent.indexOf(adjacentStatement);\n            let adjacentEnd = adjacentStart + adjacentStatement.length;\n", "            if ('above' == direction) {\n              fileContent = fileContent.substring(0, adjacentStart) + '\\n' + generatedStatements[stKey] + fileContent.substring(adjacentStart);\n              adjacentStart = fileContent.indexOf(adjacentStatement);\n              adjacentEnd = adjacentStart + adjacentStatement.length;\n            } else {\n              fileContent = fileContent.substring(0, adjacentEnd) + '\\n' + generatedStatements[stKey] + fileContent.substring(adjacentEnd);\n            }\n\n            fileModified = true;\n          }\n\n        } else {\n          const originalStatement = originalStatements.get(stKey);\n", "          if (originalStatement) {\n            const originalIndex = fileContent.indexOf(originalStatement);\n\n            if (originalIndex >= 0 && originalStatement !== generatedStatements[stKey]) {\n              fileContent = fileContent.substring(0, originalIndex) + generatedStatements[stKey] + fileContent.substring(originalIndex + originalStatement.length);\n              fileModified = true;\n            }\n          }\n        }\n      });\n\n      let responseMessage = '';\n", "      if (fileModified) {\n        // const projectDiffPath = path.resolve('~/code/project_diff');\n        // const apiPath = path.join(projectDiffPath, 'api');\n        // const tsConfigFilePath = path.join(apiPath, 'projectts.json');\n        // const tsConfigFile = ts.readConfigFile(tsConfigFilePath, ts.sys.readFile);\n        // const configParseResult = ts.parseJsonConfigFileContent(tsConfigFile.config, ts.sys, apiPath)\n        // const testFile = ts.createSourceFile('temp.ts', fileContent, ts.ScriptTarget.ES2016, true);\n        // const testProgram = ts.createProgram([testFile.fileName], configParseResult.options)\n        // const diagnostics = ts.getPreEmitDiagnostics(testProgram);\n\n        // if (diagnostics.length > 0) {\n        //   console.log('Diagnostic errors:');\n        //   diagnostics.forEach(diagnostic => {\n        //     const message = ts.flattenDiagnosticMessageText(diagnostic.messageText, '\\n');\n        //     console.log(`${diagnostic.file?.fileName} (${diagnostic.start}): ${message}`);\n        //   })\n        //   return 'you really did it now, no code, no show, no turkey';\n        // } else {\n\n        // console.log('Makin it pretty')", "        // if (diagnostics.length > 0) {\n        //   console.log('Diagnostic errors:');\n        //   diagnostics.forEach(diagnostic => {\n        //     const message = ts.flattenDiagnosticMessageText(diagnostic.messageText, '\\n');\n        //     console.log(`${diagnostic.file?.fileName} (${diagnostic.start}): ${message}`);\n        //   })\n        //   return 'you really did it now, no code, no show, no turkey';\n        // } else {\n\n        // console.log('Makin it pretty')\n        // try {\n        //   fileContent = prettier.format(fileContent, {\n        //     parser: 'typescript',\n        //     tabWidth: 2,\n        //     useTabs: false\n        //   });", "        // try {\n        //   fileContent = prettier.format(fileContent, {\n        //     parser: 'typescript',\n        //     tabWidth: 2,\n        //     useTabs: false\n        //   });\n        // } catch (error) { }\n\n        sourceFile.removeText();\n        sourceFile.insertText(0, fileContent);\n        sourceFile.saveSync();\n        await project.save();\n\n        const sourceFilePath = sourceFile.getFilePath().toString();\n        await pushCommit(sourceFilePath, generatedBranch, `${editingUser || config.user.name} - ${suggestions}`);\n\n        const prTitle = `${editingUser || config.user.name} edited ${fileName}: ${suggestions.replace(/[~^:?\"*\\[\\]@{}\\\\/]+/g, '')}`.slice(0, 255);\n        const prBody = `GPT: ${res.supportingText || 'No supporting text found.'}`.replaceAll('\"', '');\n        const prRes = await managePullRequest(generatedBranch, prTitle, prBody);\n\n        responseMessage = 'guided edit complete: ' + prRes;\n      } else {\n        responseMessage = 'guided edit produced no modifications for ' + fileName;\n      }\n\n      await goHome();\n      return responseMessage;\n    }\n", "  } catch (error) {\n    await goHome();\n    const err = error as Error;\n    return err.message + '\\n\\n' + err.stack;\n  }\n\n  return 'file not found: ' + fileName;\n}"]}
{"filename": "src/server/spells/file_editor_spell.ts", "chunked_list": ["// import fs from 'fs';\n// import { Node, Project, ScriptKind, SyntaxKind } from 'ts-morph';\n\nimport { useAi } from './use_ai_spell';\nimport { IPrompts } from '../../lib/prompts';\nimport { getConfig } from '../config';\n// import { getPathOf, sanitizeName } from '../util';\nimport { FileEditorResponse } from '../../lib/prompts/file_editor_prompt';\nimport { getTargetFile, saveTargetFile } from '../util';\n// import { copyContentsToDocker } from '../tree/docker';", "import { getTargetFile, saveTargetFile } from '../util';\n// import { copyContentsToDocker } from '../tree/docker';\n\nexport async function fileEditor(...fileParts: string[]): Promise<string> {\n\n  console.log({ fileParts });\n  \n  const config = getConfig();\n  if (!config.ts.compDir) {\n    throw new Error('Missing ts.compDir.')\n  }\n", "  if (!config.ts.compDir) {\n    throw new Error('Missing ts.compDir.')\n  }\n\n  if (!config.ts.configPath) {\n    throw new Error('Missing ts.configPath.')\n  }\n\n  const [fileName, ...suggestedEdits] = fileParts;\n\n  const originalFileContents = getTargetFile(fileName, config.git.rootPath);\n", "  if (!originalFileContents) throw 'File not found.';\n\n  const lined = originalFileContents.split('\\n').map((l, i) => `${i + 1}. ${l}`);\n\n  console.log({ lined, fileName, suggestedEdits });\n\n  const response = await useAi<FileEditorResponse>(IPrompts.FILE_EDITOR, fileName, suggestedEdits.join(' '), lined.join('\\n'));\n  \n  console.log({ EDITOR_FINISHED: response.message });\n\n  const editedLines: Record<string, string> = response.message.split('\\n').reduce((m, d) => {\n    const match = d.match(/^\\d+. /);", "    if (match) {\n      console.log({ match })\n      return ({\n        ...m,\n        [match[0].trim()]: d.slice(match[0].length)\n      })\n    }\n    return { ...m };\n  }, {});\n\n  const regex = /\\/\\*\\s*change:.*?\\*\\//gs;\n\n  const editedFile = lined.map(l => {\n    const match = l.match(/^\\d+. /);\n    const key = match && match[0].trim();\n    const edit = key && editedLines[key as keyof typeof editedLines];", "    if (edit) {\n      return edit.replace(regex, ''); \n    }\n    return l.slice(match?match[0].length:0);\n  }).filter(l => l?.length > 0).join('\\n');\n\n  console.log({ lined, editedLines, editedFile, editNum: Object.keys(editedLines).length });\n\n  const saved = saveTargetFile(fileName, editedFile);\n\n  return saved;\n}"]}
{"filename": "src/server/spells/create_component_spell.ts", "chunked_list": ["import fs from 'fs';\nimport { Node, Project, ScriptKind, SyntaxKind } from 'ts-morph';\n\nimport { useAi } from './use_ai_spell';\nimport { IPrompts } from '../../lib/prompts';\nimport { getConfig } from '../config';\nimport { getPathOf, sanitizeName } from '../util';\nimport { GeneralComponentResponse } from '../../lib/prompts/create_gen_component_prompt';\n\nexport async function createComponent(description: string, user?: string): Promise<string> {\n  \n  const config = getConfig();", "\nexport async function createComponent(description: string, user?: string): Promise<string> {\n  \n  const config = getConfig();\n  if (!config.ts.compDir) {\n    throw new Error('Missing ts.compDir.')\n  }\n\n  if (!config.ts.configPath) {\n    throw new Error('Missing ts.configPath.')\n  }\n\n  const project = new Project({\n    tsConfigFilePath: config.ts.configPath\n  });\n\n  const res = await useAi<GeneralComponentResponse>(IPrompts.CREATE_GEN_COMPONENT, description);\n\n  const sourceFile = project.createSourceFile('new_component.tsx', res.message, { scriptKind: ScriptKind.JSX });\n\n  \n  let componentName;\n  const exportedDeclarations = sourceFile.getExportedDeclarations().get('default');", "  if (!config.ts.configPath) {\n    throw new Error('Missing ts.configPath.')\n  }\n\n  const project = new Project({\n    tsConfigFilePath: config.ts.configPath\n  });\n\n  const res = await useAi<GeneralComponentResponse>(IPrompts.CREATE_GEN_COMPONENT, description);\n\n  const sourceFile = project.createSourceFile('new_component.tsx', res.message, { scriptKind: ScriptKind.JSX });\n\n  \n  let componentName;\n  const exportedDeclarations = sourceFile.getExportedDeclarations().get('default');", "  if (exportedDeclarations) {\n    const declaration = exportedDeclarations[0];\n    if (Node.isVariableDeclaration(declaration)) {\n      const initializer = declaration.getInitializer();\n      if (initializer?.getKind() === SyntaxKind.FunctionExpression || initializer?.getKind() === SyntaxKind.ArrowFunction) {\n        componentName = declaration.getName();\n      }\n    } else if (Node.isFunctionDeclaration(declaration)) {\n      componentName = declaration.getName();\n    }\n  }\n", "  if (componentName) {\n    const creatorComment = `/* Created by ${user || config.user.name}, ${description} */\\n`;\n    const coreCompsPath = sanitizeName(config.ts.compDir);\n    const compFilePath = getPathOf(`${coreCompsPath}/${componentName}.tsx`);\n    \n    if (!fs.existsSync(coreCompsPath)) {\n      fs.mkdirSync(coreCompsPath, { recursive: true });\n    }\n\n    fs.writeFileSync(compFilePath, `${creatorComment}${res.message}`);\n    return 'created a new component';\n  }\n\n  return 'unable to create a component ' + res.message;\n}"]}
{"filename": "src/server/spells/index.ts", "chunked_list": ["export { useAi } from './use_ai_spell';\nexport { createType } from './create_type_spell';\nexport { createApi } from './create_api_spell';\nexport { createApiBackend } from './create_api_backend_spell';\nexport { fileEditor } from './file_editor_spell';\nexport { guidedEdit } from './guided_edit_spell';\nexport { createComponent } from './create_component_spell';"]}
{"filename": "src/server/spells/create_type_spell.ts", "chunked_list": ["import fs from \"fs\";\nimport { IPrompts } from \"../../lib/prompts\";\nimport { useAi } from \"./use_ai_spell\";\nimport { getPathOf, isValidName, sanitizeName, toSnakeCase, toTitleCase } from \"../util\";\nimport { getConfig } from \"../config\";\nimport { CreateTypeResponse } from \"../../lib/prompts/create_type_prompt\";\n\nexport async function createType(typeName: string): Promise<string> {\n  \n  const config = getConfig();\n  if (!config.ts.typeDir) {\n    throw new Error('Missing ts.typeDir.')\n  }\n", "  if (!config.ts.typeDir) {\n    throw new Error('Missing ts.typeDir.')\n  }\n\n  if (!isValidName(typeName)) {\n    throw new Error('this prompt typeName must follow ITypeName format, leading I, titleized');\n  }\n\n  const coreTypesPath = sanitizeName(config.ts.typeDir);\n  const typeFilePath = getPathOf(`${coreTypesPath}/${toSnakeCase(typeName)}.ts`);\n  const comment = `/*\\n* @category ${toTitleCase(typeName)}\\n*/\\n`;  \n  const generatedType = await useAi<CreateTypeResponse>(IPrompts.CREATE_TYPE, typeName)\n", "  if (!fs.existsSync(coreTypesPath)) {\n    fs.mkdirSync(coreTypesPath, { recursive: true });\n  }\n\n  fs.writeFileSync(typeFilePath, `${comment}${generatedType.message}\\n\\n`);\n\n  return generatedType.message;\n}"]}
{"filename": "src/tree/modifier.ts", "chunked_list": ["import fs from 'fs';\nimport path from \"path\";\nimport type { Statements } from \"../lib/types\";\n\ninterface ModificationRules {\n  type: string;\n  action: 'add' | 'edit' | 'delete';\n  newText?: string;\n  addBeforeText?: string;\n  addAfterText?: string;\n}\n", "export function createModificationsFunction(): (statement: Statements) => Statements | null {\n  \n  const rules = JSON.parse(fs.readFileSync(path.join(__dirname, '../files/mods'), { encoding: 'utf-8' }).toString()) as ModificationRules[];\n  \n  return (statement: Statements) => {\n    const rule = rules.find((r) => r.type === statement.type);\n\n    if (!rule) {\n      return statement;\n    }\n\n    switch (rule.action) {\n      case 'add':\n        return {\n          type: statement.type,\n          text: rule.addBeforeText + statement.text + rule.addAfterText,\n        };\n      case 'edit':\n        return {\n          type: statement.type,\n          text: rule.newText!,\n        };\n      case 'delete':\n        return null;\n      default:\n        return statement;\n    }\n  };\n}"]}
{"filename": "src/tree/ast.ts", "chunked_list": ["import type { Grammar } from \"../lib/types\";\n\n// export const syntacticGroupPatterns = [\n//   /_statement$/,          // e.g., if_statement, for_statement, while_statement\n//   /_declaration$/,        // e.g., variable_declaration, function_declaration\n//   /_definition$/,         // e.g., class_definition, function_definition\n//   /_assignment$/,         // e.g., assignment, augmented_assignment\n//   /_expression$/,         // e.g., call_expression, binary_expression\n//   /_clause$/,             // e.g., case_clause, when_clause\n//   /_specifier$/,          // e.g., storage_specifier, type_specifier", "//   /_clause$/,             // e.g., case_clause, when_clause\n//   /_specifier$/,          // e.g., storage_specifier, type_specifier\n//   /_declarator$/,         // e.g., variable_declarator, function_declarator\n//   /_item$/,               // e.g., struct_item, enum_item\n//   /_pattern$/,            // e.g., tuple_pattern, list_pattern\n//   /_literal$/,            // e.g., string_literal, number_literal\n//   /_specifier$/,          // e.g., import_specifier, export_specifier\n//   /_directive$/,          // e.g., preprocessor_directive, import_directive\n//   /_modifier$/,           // e.g., access_modifier, type_modifier\n//   /_command$/,            // e.g., pipeline_command, simple_command", "//   /_modifier$/,           // e.g., access_modifier, type_modifier\n//   /_command$/,            // e.g., pipeline_command, simple_command\n//   /_parameter$/,          // e.g., function_parameter, lambda_parameter\n//   /_attribute$/,          // e.g., html_attribute, xml_attribute\n//   /_tag$/,                // e.g., html_tag, xml_tag\n//   /_rule$/,               // e.g., grammar_rule, rewrite_rule\n//   /_production$/,         // e.g., grammar_production, nonterminal_production\n//   /_label$/,              // e.g., goto_label, case_label\n//   /_constructor$/,        // e.g., record_constructor, object_constructor\n//   /_binding$/,            // e.g., let_binding, pattern_binding", "//   /_constructor$/,        // e.g., record_constructor, object_constructor\n//   /_binding$/,            // e.g., let_binding, pattern_binding\n//   /_condition$/,          // e.g., switch_condition, guard_condition\n//   // Add other patterns as needed\n// ];\n\nconst syntacticGroupPatterns = [\n  /_declaration$/, // Variable, function, class, or module declarations\n  /_definition$/, // Variable, function, class, or module definitions\n  /_statement$/, // Statements like if, while, for, return, etc.\n  /_import$/,\n  /_class$/,\n  /_function$/", "  /_definition$/, // Variable, function, class, or module definitions\n  /_statement$/, // Statements like if, while, for, return, etc.\n  /_import$/,\n  /_class$/,\n  /_function$/\n  // /_expression$/, // Expressions like assignment, arithmetic, or function call expressions\n];\n\nconst disallowedSubGroupPatterns = [\n  /export/,\n  /empty/,\n  /except_clause$/\n];\n", "function matchesPatterns(nodeType: string) {\n  return syntacticGroupPatterns.some(p => p.test(nodeType)) && disallowedSubGroupPatterns.every(p => !p.test(nodeType));\n}\n\n// Modified recursive function to process the AST nodes and return an array of matching nodes\nexport function getGrammarPatterns(node: Grammar): string[] {\n  let matchingNodes: string[] = [];\n\n  if (matchesPatterns(node.type)) {\n    console.log(`Found node of type: ${node.type}`);\n    if (!matchingNodes.includes(node.type)) {\n      matchingNodes.push(node.type); // Add the matching node to the array\n    }\n  }\n", "  if (matchesPatterns(node.type)) {\n    console.log(`Found node of type: ${node.type}`);\n    if (!matchingNodes.includes(node.type)) {\n      matchingNodes.push(node.type); // Add the matching node to the array\n    }\n  }\n\n  if (node.children) {\n    for (const child of node.children.types) {\n      getGrammarPatterns(child).forEach(p => {\n        if (!matchingNodes.includes(p)) {\n          matchingNodes.push(p);\n        }\n      });\n    }\n  }\n\n  return matchingNodes;\n}\n", "    for (const child of node.children.types) {\n      getGrammarPatterns(child).forEach(p => {\n        if (!matchingNodes.includes(p)) {\n          matchingNodes.push(p);\n        }\n      });\n    }\n  }\n\n  return matchingNodes;\n}\n", "// function linearizeTree(tree) {\n//   const linearized = [];\n//   const stack: = [];\n\n//   function extractNodeInfo(node) {\n//     const type = node.type;\n//     const named = node.named;\n//     const children = node.subtypes || node.children?.types || [];\n\n//     const content = {\n//       fields: node.fields,\n//     };\n\n//     return { type, named, children, content };\n//   }\n", "//   function traverse(node: Grammar) {\n//     const { type, named, content, children } = extractNodeInfo(node);\n\n//     // Create an object representing the current node\n//     const obj = {\n//       type,\n//       named,\n//       content,\n//       parent: stack.length > 0 ? stack[stack.length - 1] : null\n//     };\n", "//     if (children.length === 0) {\n//       // Add leaf nodes to the linearized array\n//       linearized.push(obj);\n//     } else {\n//       // Push the current node onto the stack and process its children\n//       stack.push(obj);\n//       children.forEach(traverse);\n//       stack.pop();\n//     }\n//   }\n\n//   traverse(tree);\n//   return linearized;\n// }"]}
{"filename": "src/tree/getStatements.ts", "chunked_list": ["\n// import TreeSitter, { SyntaxNode, Tree } from 'tree-sitter';\n// import path from 'path';\n// import languages from '../languages';\n// import { getFileFromDir } from '../util';\n// import { LinearizedStatement } from '../types';\n// import { getGrammarPatterns } from './ast';\n// const langValues = Object.values(languages);\n\n// export async function getStatements(fileName: string): Promise<LinearizedStatement[]> {\n//   const extension = path.extname(fileName).slice(1);\n//   const langParser = langValues.find(lang => lang.fileExtension.includes(extension));", "\n// export async function getStatements(fileName: string): Promise<LinearizedStatement[]> {\n//   const extension = path.extname(fileName).slice(1);\n//   const langParser = langValues.find(lang => lang.fileExtension.includes(extension));\n//   if (!langParser) throw 'You found an unsupported parser!';\n\n//   const imported = await import(langParser.parserName);\n//   const masterGrammars = langParser.parserVariant ? imported.default[langParser.parserVariant] : imported.default;\n  \n//   const parser = new TreeSitter();\n//   parser.setLanguage(masterGrammars);\n  \n//   const code = getFileFromDir(fileName);\n//   const parsed = parser.parse(code);\n//   const nodeTypes = masterGrammars.nodeTypeInfo.flatMap(getGrammarPatterns);\n//   walkNode(parsed.rootNode);\n//   return getNodesOfType(parsed, nodeTypes);\n// }\n", "// export function walkNode(rootNode: SyntaxNode) {\n\n//   const linearText: Record<number, string> = {};\n//   const nodes: SyntaxNode[] = [];\n\n//   function innerWalk (node: SyntaxNode) {\n//     for (const child of node.children) {\n//       const key = child.startPosition.row;\n  \n//       if (!linearText[key]) {\n//         linearText[key] = \"\";\n//       }\n  \n//       linearText[key] += (linearText[key] ? \" \" : \"\") + child.text;\n  \n//       // Recursion for deeper levels", "//       if (!linearText[key]) {\n//         linearText[key] = \"\";\n//       }\n  \n//       linearText[key] += (linearText[key] ? \" \" : \"\") + child.text;\n  \n//       // Recursion for deeper levels\n//       if (child.children && child.children.length > 0 && !linearText[key].includes(child.children[0].text)) {\n//         innerWalk(child);\n//       }\n//     }\n//   }\n\n//   innerWalk(rootNode)\n\n//   return nodes;\n// }\n", "// export function getNodesOfType(rootNode: Tree, nodeTypes: string[]): LinearizedStatement[] {\n  \n//   let nodeIdCounter = 0;\n//   const usedNodes: Map<string, string> = new Map();\n//   const nodes: LinearizedStatement[] = [];\n\n//   function visitNode(node: SyntaxNode, parentId?: number): void {\n\n//     const shouldBeParsed = nodeTypes.includes(node.type);\n//     if (shouldBeParsed) {\n//       const nodeId = nodeIdCounter++;\n//       let content = node.text;\n", "//     if (shouldBeParsed) {\n//       const nodeId = nodeIdCounter++;\n//       let content = node.text;\n\n//       if (parentId !== undefined) {\n//         const parentNode = nodes.find(n => n.i === parentId);\n//         if (parentNode) {\n//           parentNode.c = parentNode.c.replace(node.text, `XV_${nodeId}`);\n//         }\n//       }\n", "//       if (!usedNodes.has(node.type)) {\n//         usedNodes.set(node.type, `XT_${usedNodes.size + 1}`)\n//       }\n\n//       const linearizedStatement: LinearizedStatement = {\n//         i: nodeId,\n//         p: parentId,\n//         t: usedNodes.get(node.type)!,\n//         c: content.trim(),\n//       };\n//       nodes.push(linearizedStatement);\n", "//       if (node.type.includes('declaration')) {\n//         parentId = nodeId;\n//       }\n//     }\n\n//     for (const child of node.children) {\n//       visitNode(child, parentId);\n//     }\n//   }\n\n//   visitNode(rootNode.rootNode);\n \n//   return nodes;\n// }\n", "// // async function getMasterGrammars({ parserName, parserVariant }: LanguageParser): Promise<Grammars> {\n\n// //   const imported = await import(parserName);\n\n// //   const masterGrammars = parserVariant ? imported.default[parserVariant] : imported.default;\n// //   masterGrammars.nodeTypeInfo = extractApprovedTypes(masterGrammars.nodeTypeInfo);\n\n// //   // if (parserVariant && isDefaultGrammarVariants(imported)) {\n// //   //   const grammar = imported.default[parserVariant];\n// //   //   masterGrammars.nodeTypeInfo = masterGrammars.nodeTypeInfo.concat(extractApprovedTypes(grammar.nodeTypeInfo))\n// //   // } else if (isDefaultGrammar(imported)) {\n// //   //   masterGrammars.nodeTypeInfo = masterGrammars.nodeTypeInfo.concat(extractApprovedTypes(imported.default.nodeTypeInfo as Grammar[]));\n// //   // } else {", "// //   // } else if (isDefaultGrammar(imported)) {\n// //   //   masterGrammars.nodeTypeInfo = masterGrammars.nodeTypeInfo.concat(extractApprovedTypes(imported.default.nodeTypeInfo as Grammar[]));\n// //   // } else {\n// //   //   throw 'This file type requires unsupported parsers.'\n// //   // }\n\n// //   return masterGrammars;\n// // }\n\n// // const approvedTypes = ['declaration', 'definition', 'statement', 'expression'];\n", "// // export function extractApprovedTypes(nodeInfo: Grammars['nodeTypeInfo']): Grammars['nodeTypeInfo'] {\n// //   const groupedTypes: Grammars['nodeTypeInfo'] = [];\n  \n// //   nodeInfo.filter(n => approvedTypes.some(at => n.type.indexOf(at) > -1))\n// //   .flatMap(gt => {\n// //     return  'subtypes' in gt ? gt.subtypes : undefined;\n// //   }).forEach(st => {\n// //     if (st && approvedTypes.some(at => st.type.indexOf(at) > -1)) {\n// //       groupedTypes.push(st)\n// //     }\n// //   });\n  \n// //   return groupedTypes;\n// // }\n\n// // Huffman coding and an adaptation of the Burrows-Wheeler Transform (BWT) for the compression process.\n\nexport default {}"]}
{"filename": "src/tree/docker.ts", "chunked_list": ["import fs from 'fs';\nimport os from 'os';\nimport path from 'path';\nimport { execSync } from \"child_process\";\nimport { getFileParser } from '../server/util';\n\nconst dockerfile = `FROM node:16\\nWORKDIR /app\\nRUN npm install tree-sitter`;\nconst imageName = 'wizapp-image';\nconst containerName = 'wizapp-container';\nconst volumeName = 'wizapp-volume';", "const containerName = 'wizapp-container';\nconst volumeName = 'wizapp-volume';\n\nlet activeTasks = 0;\n\nexport function processFile(fileName: string) {\n  activeTasks++;\n  buildAndCopyFile(fileName);\n  runExtractionScript();\n  const localModsPath = 'path/to/your/local_modifications_file';\n  copyModifications(localModsPath);\n  runModificationScript();\n  copyModifiedFileToLocal(fileName);\n\n  activeTasks--;", "  if (!activeTasks) {\n    setTimeout(() => {\n      if (!activeTasks) stopContainer();\n    }, 10000)\n  }\n}\n\nfunction stopContainer() {\n  execSync(`docker stop ${containerName}`);\n}\n", "function buildAndCopyFile(fileName: string) {\n  if (!containerExists()) {\n    createSharedVolume();\n    const tempDockerfilePath = getTempFilePath('Dockerfile', dockerfile);\n    execSync(`docker build -t ${imageName} -f ${tempDockerfilePath} .`);\n    execSync(`docker create --name ${containerName} -v ${volumeName}:/app/node_modules ${imageName}`);\n  } else {\n    startContainerIfNotRunning();\n  }\n\n  installTreeSitterGrammar(fileName);\n  execSync(`docker cp ${fileName} ${containerName}:/app/src/file`);\n\n  // Copy getStatements.js and getStatements.js.map into the Docker container\n  const getStatementsPath = path.resolve(__dirname, 'getStatements.js');\n  const getStatementsMapPath = path.resolve(__dirname, 'getStatements.js.map');\n  execSync(`docker cp ${getStatementsPath} ${containerName}:/app/bin/getStatements.js`);\n  execSync(`docker cp ${getStatementsMapPath} ${containerName}:/app/bin/getStatements.js.map`);\n  \n}\n", "function createSharedVolume() {\n  try {\n    execSync(`docker volume create ${volumeName}`);\n  } catch (error) {\n    console.error('Error creating shared volume:', error);\n  }\n}\n\nfunction startContainerIfNotRunning() {\n  const containerStatus = execSync(`docker inspect --format='{{.State.Status}}' ${containerName}`).toString().trim();\n  if (containerStatus !== 'running') {\n    execSync(`docker start ${containerName}`);\n  }\n}\n", "function startContainerIfNotRunning() {\n  const containerStatus = execSync(`docker inspect --format='{{.State.Status}}' ${containerName}`).toString().trim();\n  if (containerStatus !== 'running') {\n    execSync(`docker start ${containerName}`);\n  }\n}\n\nfunction getTempFilePath(fileName: string, content: string): string {\n  const tempDir = os.tmpdir();\n  const tempFilePath = path.join(tempDir, fileName);\n  fs.writeFileSync(tempFilePath, content);\n  return tempFilePath;\n}\n", "function containerExists(): boolean {\n  try {\n    execSync(`docker inspect ${containerName}`);\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\n\nfunction installTreeSitterGrammar(fileName: string) {\n  const parserName = getFileParser(fileName);\n  const packageName = `tree-sitter-${parserName}`;\n  execSync(`docker exec ${containerName} npm install ${packageName}`);\n}\n", "function installTreeSitterGrammar(fileName: string) {\n  const parserName = getFileParser(fileName);\n  const packageName = `tree-sitter-${parserName}`;\n  execSync(`docker exec ${containerName} npm install ${packageName}`);\n}\n\nfunction runExtractionScript() {\n  const result = execSync(`docker exec ${containerName} node bin/getStatements.js`);\n  try {\n    return JSON.parse(result.toString());\n  } catch (error) {\n    console.error('Error parsing JSON from extraction script:', error);\n    return [];\n  }\n}\n", "  try {\n    return JSON.parse(result.toString());\n  } catch (error) {\n    console.error('Error parsing JSON from extraction script:', error);\n    return [];\n  }\n}\n\nexport function copyContentsToDocker(fileName: string, content: string) {\n  const tempContentPath = getTempFilePath(fileName, content);\n  execSync(`docker cp ${tempContentPath} ${containerName}:/app/${fileName}`)\n}\n", "export function copyContentsToDocker(fileName: string, content: string) {\n  const tempContentPath = getTempFilePath(fileName, content);\n  execSync(`docker cp ${tempContentPath} ${containerName}:/app/${fileName}`)\n}\n\nfunction copyModifications(localModsPath: string) {\n  execSync(`docker cp ${localModsPath} ${containerName}:/app/src/mods`);\n}\n\nfunction runModificationScript() {\n  execSync(`docker exec ${containerName} node bin/modifyStatements.js -f /app/src/file -e /app/src/mods`);\n}\n", "function runModificationScript() {\n  execSync(`docker exec ${containerName} node bin/modifyStatements.js -f /app/src/file -e /app/src/mods`);\n}\n\nfunction copyModifiedFileToLocal(fileName: string) {\n  const modifiedfileName = 'modified_' + fileName;\n  execSync(`docker cp ${containerName}:/app/src/modified_file ${modifiedfileName}`);\n  execSync(`docker rm ${containerName}`);\n  fs.writeFileSync(fileName, fs.readFileSync(modifiedfileName));\n}"]}
{"filename": "src/tree/modifyStatements.ts", "chunked_list": ["// import fs from 'fs';\nimport type { Node, Statements } from '../lib/types';\n// import { parseFile } from './getStatements';\n\nexport function modifyStatements(\n  node: Node,\n  modifications: (statement: Statements) => Statements | null\n): Node | null {\n  // Modify, add or delete statements based on modifications function\n  const statement = { type: node.type, text: node.text };\n  const modifiedStatement = modifications(statement);", "  if (modifiedStatement) {\n    node.text = modifiedStatement.text;\n  } else {\n    return null;\n  }\n\n  node.children = node.children\n    .map((child) => modifyStatements(child, modifications))\n    .filter((child) => child !== null) as Node[];\n\n  return node;\n}\n", "// export async function modifyStatementsInFile(\n//   modifications: (statement: Statements) => Statements | null\n// ): Promise<string> {\n//   const files = fs.readdirSync('../files');\n//   const modificationFileName = files.find(f => f.startsWith('modifications'));\n\n\n\n//   const root = await parseFile();\n//   const modifiedRoot = modifyStatements(root.rootNode, modifications);\n//   // Serialize the modified AST back to the source code\n//   // You can use a library like \"ast-pretty-print\" or write your own serialization function\n//   const modifiedCode = serializeAstToCode(modifiedRoot);\n//   return modifiedCode;\n// }"]}
{"filename": "src/tree/js/abstract-syntax-tree.d.ts", "chunked_list": ["// declare module 'abstract-syntax-tree' {\n//   export type NodeType =\n//     | 'Program'\n//     | 'FunctionDeclaration'\n//     | 'VariableDeclaration'\n//     | 'ExpressionStatement'\n//     | 'CallExpression'\n//     | 'Identifier'\n//     | 'Literal'\n//     | 'BinaryExpression'\n//     | 'ArrayExpression'\n//     | 'ObjectExpression'\n//     | 'Property'\n//     | 'AssignmentExpression'\n//     | 'MemberExpression'\n//     | 'ThisExpression'\n//     | 'BlockStatement'\n//     | 'IfStatement'\n//     | 'SwitchStatement'\n//     | 'SwitchCase'\n//     | 'ForStatement'\n//     | 'WhileStatement'\n//     | 'DoWhileStatement'\n//     | 'BreakStatement'\n//     | 'ContinueStatement'\n//     | 'TryStatement'\n//     | 'CatchClause'\n//     | 'ThrowStatement'\n//     | 'ReturnStatement'\n//     | 'UnaryExpression'\n//     | 'UpdateExpression'\n//     | 'LogicalExpression'\n//     | 'ConditionalExpression'\n//     | 'NewExpression'\n//     | 'ArrowFunctionExpression'\n//     | 'YieldExpression'\n//     | 'TemplateLiteral'\n//     | 'TemplateElement'\n//     | 'TaggedTemplateExpression'\n//     | 'ClassDeclaration'\n//     | 'ClassExpression'\n//     | 'ClassBody'\n//     | 'MethodDefinition'\n//     | 'ImportDeclaration'\n//     | 'ImportSpecifier'\n//     | 'ExportDefaultDeclaration'\n//     | 'ExportNamedDeclaration'\n//     | 'ExportSpecifier'\n//     | 'ForInStatement'\n//     | 'ForOfStatement'\n//     | 'AwaitExpression'\n//     | 'SpreadElement'\n//     | 'RestElement'\n//     | 'AssignmentPattern'\n//     | 'ArrayPattern'\n//     | 'ObjectPattern'\n//     | 'MetaProperty'\n//     | 'Super'\n//     | 'Import'\n//     | 'ChainExpression';\n", "//   export interface Node {\n//     type: NodeType;\n//     loc?: SourceLocation;\n//     [key: string]: any;\n//   }\n\n//   export interface SourceLocation {\n//     start: Position;\n//     end: Position;\n//     source?: string | null;\n//   }\n", "//   export interface Position {\n//     line: number;\n//     column: number;\n//   }\n\n//   export interface ParseOptions {\n//     ecmaVersion?: number;\n//     sourceType?: 'script' | 'module';\n//     locations?: boolean;\n//     ranges?: boolean;\n//     comment?: boolean;\n//   }\n", "//   export function parse(source: string, options?: ParseOptions): Node;\n\n//   export function generate(tree: Node): string;\n\n//   export function walk(tree: Node, callback: (node: Node, parent: Node | null) => void): void;\n\n//   export function find(tree: Node, selector: NodeType | { [key: string]: any }): Node[];\n\n//   export function serialize(node: Node): any;\n\n//   export function traverse(tree: Node, options: { enter?: (node: Node) => void; leave?: (node: Node) => void }): void;\n", "//   export function serialize(node: Node): any;\n\n//   export function traverse(tree: Node, options: { enter?: (node: Node) => void; leave?: (node: Node) => void }): void;\n\n//   export function replace(tree: Node, callback: (node: Node) => Node | null): void;\n\n//   export function remove(tree: Node, selector: NodeType | { [key: string]: any } | ((node: Node) => Node | null)): void;\n\n//   export function each(tree: Node, selector: NodeType, callback: (node: Node) => void): void;\n\n//   export function first(tree: Node, selector: NodeType): Node | undefined;\n", "//   export function each(tree: Node, selector: NodeType, callback: (node: Node) => void): void;\n\n//   export function first(tree: Node, selector: NodeType): Node | undefined;\n\n//   export function last(tree: Node, selector: NodeType): Node | undefined;\n\n//   export function reduce(tree: Node, callback: (accumulator: any, node: Node) => any, accumulator: any): any;\n\n//   export function has(tree: Node, selector: NodeType | { [key: string]: any }): boolean;\n\n//   export function count(tree: Node, selector: NodeType | { [key: string]: any }): number;\n", "//   export function has(tree: Node, selector: NodeType | { [key: string]: any }): boolean;\n\n//   export function count(tree: Node, selector: NodeType | { [key: string]: any }): number;\n\n//   export function append(tree: Node, node: Node | string): void;\n\n//   export function prepend(tree: Node, node: Node | string): void;\n\n//   export function equal(node1: Node, node2: Node): boolean;\n\n//   export function match(node: Node, selector: string): boolean;\n", "//   export function equal(node1: Node, node2: Node): boolean;\n\n//   export function match(node: Node, selector: string): boolean;\n\n//   export function template(templateString: string, replacements?: { [key: string]: any }): Node[];\n\n//   export function program(): Node;\n\n//   export function iife(): Node;\n// }", "//   export function iife(): Node;\n// }"]}
{"filename": "src/tree/js/index.ts", "chunked_list": ["export * from './jsx-parser';"]}
{"filename": "src/tree/js/jsx-parser.ts", "chunked_list": ["// import { ParseResult, parse as babelParse } from '@babel/parser';\n// import { parse, Node } from 'abstract-syntax-tree';\n// import { File } from 'buffer';\n\n// export function parseJSX(source: string): ParseResult<File> {\n//   const ast = babelParse(source, {\n//     sourceType: 'module',\n//     plugins: ['jsx'],\n//   });\n\n//   // return ast;\n// }\n\nexport default {}"]}
