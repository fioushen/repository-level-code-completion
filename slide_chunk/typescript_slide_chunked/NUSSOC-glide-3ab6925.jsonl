{"filename": "src/declaration.d.ts", "chunked_list": ["declare module '*.svg' {\n  import { SVGProps, VFC } from 'react';\n\n  const SVG: VFC<SVGProps<SVGSVGElement>>;\n  export default SVG;\n}\n\ndeclare module '*.svg?url' {\n  const svg: string;\n  export default svg;", "  const svg: string;\n  export default svg;\n}\n\ndeclare module '*.py' {\n  const script: string;\n  export default script;\n}\n\ndeclare const __VERSION__: string;", "\ndeclare const __VERSION__: string;\n"]}
{"filename": "src/store/hooks.ts", "chunked_list": ["import type { TypedUseSelectorHook } from 'react-redux';\nimport { useDispatch, useSelector } from 'react-redux';\n\nimport type { AppDispatch, RootState } from '../store';\n\nexport const useAppDispatch: () => AppDispatch = useDispatch;\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\n"]}
{"filename": "src/store/vaultSlice.ts", "chunked_list": ["import { createSelector, PayloadAction } from '@reduxjs/toolkit';\nimport { createSlice } from '@reduxjs/toolkit';\n\nimport { RootState } from '.';\n\ninterface File {\n  name: string;\n  content: string;\n}\n\ninterface VaultState {\n  files: Record<string, string>;\n  list: string[];\n}\n\nconst initialState: VaultState = {\n  files: {},\n  list: [],\n};\n\nexport const vaultSlice = createSlice({\n  name: 'vault',\n  initialState,\n  reducers: {\n    save: (state, action: PayloadAction<File>) => {\n      const { name, content } = action.payload;\n", "interface VaultState {\n  files: Record<string, string>;\n  list: string[];\n}\n\nconst initialState: VaultState = {\n  files: {},\n  list: [],\n};\n\nexport const vaultSlice = createSlice({\n  name: 'vault',\n  initialState,\n  reducers: {\n    save: (state, action: PayloadAction<File>) => {\n      const { name, content } = action.payload;\n", "      if (state.files[name] === undefined) state.list.push(name);\n      state.files[name] = content;\n    },\n    destroy: (state, action: PayloadAction<string>) => {\n      const name = action.payload;\n      delete state.files[name];\n      state.list = state.list.filter((file) => file !== name);\n    },\n    rename: (state, action: PayloadAction<{ from: string; to: string }>) => {\n      const { from: oldName, to: newName } = action.payload;\n      const isOldNameExist = state.files[oldName] !== undefined;\n      const isNewNameExist = state.files[newName] !== undefined;", "      if (!isOldNameExist || isNewNameExist) return;\n\n      state.files[newName] = state.files[oldName];\n      delete state.files[oldName];\n      state.list = state.list.map((name) =>\n        name === oldName ? newName : name,\n      );\n    },\n  },\n});\n\nconst selectVault = (state: RootState) => state.vault;\n\nexport const getFileNames = createSelector(selectVault, (vault) => vault.list);\n\nexport const getFileContent = (name: string) =>\n  createSelector(selectVault, (vault) => vault.files[name]);\n\nexport const vaultActions = vaultSlice.actions;\nexport default vaultSlice.reducer;\n"]}
{"filename": "src/store/filesSlice.ts", "chunked_list": ["import { createSelector, PayloadAction } from '@reduxjs/toolkit';\nimport { createSlice } from '@reduxjs/toolkit';\n\nimport { RootState } from '.';\n\ninterface FilesState {\n  files: Record<string, string>;\n  list: string[];\n  selected?: string;\n}\n\nconst initialState: FilesState = {\n  files: {},\n  list: [],\n};\n\nconst findSuitableName = (\n  name: string,\n  list: string[],\n  transformer: (counter: number) => string,\n) => {\n  const names = new Set(list);\n  let counter = 0;\n  let newName = name;\n", "  while (names.has(newName)) {\n    newName = transformer(counter);\n    counter += 1;\n  }\n\n  return newName;\n};\n\nexport const filesSlice = createSlice({\n  name: 'files',\n  initialState,\n  reducers: {\n    rehydrate: (\n      state,\n      action: PayloadAction<Pick<FilesState, 'files' | 'list'>>,\n    ) => {\n      state.files = action.payload.files;\n      state.list = action.payload.list;\n    },\n    draft: (state, action: PayloadAction<boolean | undefined>) => {\n      const name = findSuitableName(\n        'untitled.py',\n        state.list,\n        (counter) => `untitled-${counter + 1}.py`,\n      );\n\n      state.files[name] = '';\n      state.list.push(name);\n\n      const select = action.payload;", "      if (select) state.selected = name;\n    },\n    create: (\n      state,\n      action: PayloadAction<{ name: string; content: string }>,\n    ) => {\n      const { name, content } = action.payload;\n      const newName = findSuitableName(\n        name,\n        state.list,\n        (counter) => `Copy${counter ? ` ${counter}` : ''} of ${name}`,\n      );\n\n      state.files[newName] = content;\n      state.list.push(newName);\n      state.selected = newName;\n    },\n    updateSelected: (state, action: PayloadAction<string>) => {", "      if (state.selected === undefined) return;\n\n      state.files[state.selected] = action.payload;\n    },\n    destroy: (state, action: PayloadAction<string>) => {\n      const name = action.payload;\n      delete state.files[name];\n      state.list = state.list.filter((file) => file !== name);\n      if (state.selected === name) state.selected = undefined;\n    },\n    select: (state, action: PayloadAction<string>) => {\n      const name = action.payload;", "      if (state.selected === name) state.selected = undefined;\n    },\n    select: (state, action: PayloadAction<string>) => {\n      const name = action.payload;\n      if (state.files[name] === undefined) return;\n\n      state.selected = name;\n    },\n    rename: (state, action: PayloadAction<{ from: string; to: string }>) => {\n      const { from: oldName, to: newName } = action.payload;\n      const isOldNameExist = state.files[oldName] !== undefined;\n      const isNewNameExist = state.files[newName] !== undefined;", "      if (!isOldNameExist || isNewNameExist) return;\n\n      state.files[newName] = state.files[oldName];\n      delete state.files[oldName];\n      state.list = state.list.map((name) =>\n        name === oldName ? newName : name,\n      );\n\n      if (state.selected === oldName) state.selected = newName;\n    },\n  },\n});\n\nconst selectFiles = (state: RootState) => state.files;\n\nexport const getSelectedFileName = createSelector(\n  selectFiles,\n  (files) => files.selected,\n);\n\nexport const getSelectedFile = createSelector(selectFiles, (files) =>\n  files.selected\n    ? { name: files.selected, content: files.files[files.selected] }\n    : { name: undefined, content: undefined },\n);\n\nexport const filesActions = filesSlice.actions;\nexport default filesSlice.reducer;\n", "      if (state.selected === oldName) state.selected = newName;\n    },\n  },\n});\n\nconst selectFiles = (state: RootState) => state.files;\n\nexport const getSelectedFileName = createSelector(\n  selectFiles,\n  (files) => files.selected,\n);\n\nexport const getSelectedFile = createSelector(selectFiles, (files) =>\n  files.selected\n    ? { name: files.selected, content: files.files[files.selected] }\n    : { name: undefined, content: undefined },\n);\n\nexport const filesActions = filesSlice.actions;\nexport default filesSlice.reducer;\n"]}
{"filename": "src/store/index.ts", "chunked_list": ["import { configureStore } from '@reduxjs/toolkit';\nimport localforage from 'localforage';\nimport {\n  FLUSH,\n  PAUSE,\n  PERSIST,\n  persistCombineReducers,\n  persistStore,\n  PURGE,\n  REGISTER,", "  PURGE,\n  REGISTER,\n  REHYDRATE,\n} from 'redux-persist';\n\nimport filesReducer, { filesActions } from './filesSlice';\nimport vaultReducer from './vaultSlice';\n\nconst persistConfig = {\n  key: 'root',", "const persistConfig = {\n  key: 'root',\n  storage: localforage,\n  whitelist: ['vault'],\n};\n\nconst rootReducer = persistCombineReducers(persistConfig, {\n  files: filesReducer,\n  vault: vaultReducer,\n});", "  vault: vaultReducer,\n});\n\nexport const store = configureStore({\n  reducer: rootReducer,\n  middleware: (getDefaultMiddleware) =>\n    getDefaultMiddleware({\n      serializableCheck: {\n        ignoredActions: [FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER],\n      },", "        ignoredActions: [FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER],\n      },\n    }),\n});\n\nexport const persistor = persistStore(store, null, () => {\n  const vault = store.getState().vault;\n  store.dispatch(filesActions.rehydrate(vault));\n});\n", "});\n\nexport const getState = store.getState;\n\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppDispatch = typeof store.dispatch;\n"]}
{"filename": "src/hooks/useFilesMutations.ts", "chunked_list": ["import { persistor } from '../store';\nimport { filesActions } from '../store/filesSlice';\nimport { useAppDispatch } from '../store/hooks';\nimport { vaultActions } from '../store/vaultSlice';\n\ninterface UseFilesMutationsHook {\n  /**\n   * For performance reasons, the caller should ensure that the new\n   * name is not already in use in *both* the files and vault stores.\n   */\n  rename: (from: string, to: string) => void;\n  save: (name: string, content: string) => void;\n  destroy: (name: string) => void;\n  draft: (autoSelect?: boolean) => void;\n  select: (name: string) => void;\n  update: (content: string) => void;\n  create: (name: string, content: string) => void;\n}\n\nconst useFilesMutations = (): UseFilesMutationsHook => {\n  const dispatch = useAppDispatch();\n\n  return {\n    save: (name: string, content: string) => {\n      dispatch(filesActions.updateSelected(content));\n      dispatch(vaultActions.save({ name, content }));\n      persistor.flush();\n    },\n    rename: (from: string, to: string) => {", "      if (from === to) return;\n\n      dispatch(filesActions.rename({ from, to }));\n      dispatch(vaultActions.rename({ from, to }));\n      persistor.flush();\n    },\n    destroy: (name: string) => {\n      dispatch(filesActions.destroy(name));\n      dispatch(vaultActions.destroy(name));\n      persistor.flush();\n    },\n    draft: (autoSelect?: boolean) => {\n      dispatch(filesActions.draft(autoSelect));\n    },\n    select: (name: string) => {\n      dispatch(filesActions.select(name));\n    },\n    update: (content: string) => {\n      dispatch(filesActions.updateSelected(content));\n    },\n    create: (name: string, content: string) => {\n      dispatch(filesActions.create({ name, content }));\n      dispatch(vaultActions.save({ name, content }));\n      persistor.flush();\n    },\n  };\n};\n\nexport default useFilesMutations;\n"]}
{"filename": "src/hooks/useFile.ts", "chunked_list": ["import { getState } from '../store';\nimport { getSelectedFile, getSelectedFileName } from '../store/filesSlice';\nimport { useAppSelector } from '../store/hooks';\n\nconst Selected = () => useAppSelector(getSelectedFile);\n\nconst SelectedName = () => useAppSelector(getSelectedFileName);\n\nconst NamesSet = () =>\n  useAppSelector(({ files, vault }) => new Set(files.list.concat(vault.list)));", "const NamesSet = () =>\n  useAppSelector(({ files, vault }) => new Set(files.list.concat(vault.list)));\n\nconst NamesWithUnsaved = () =>\n  useAppSelector(({ files, vault }) =>\n    files.list.map((name) => {\n      const fileInFiles = files.files[name];\n      const fileInVault = vault.files[name];\n\n      return { name, unsaved: fileInFiles !== fileInVault };", "\n      return { name, unsaved: fileInFiles !== fileInVault };\n    }),\n  );\n\nconst IsUnsavedOf = (name?: string) =>\n  useAppSelector(({ files, vault }) => {\n    if (!name) return true;\n\n    const fileInFiles = files.files[name];\n    const fileInVault = vault.files[name];\n\n    return fileInFiles !== fileInVault;\n  });\n\nconst Exports = () => {\n  const { files, list } = getState().vault;\n  return list.map((name) => ({ name, content: files[name] }));\n};\n\nconst useFile = {\n  SelectedName,\n  Selected,\n  NamesSet,\n  NamesWithUnsaved,\n  IsUnsavedOf,\n  Exports,\n};\n\nexport default useFile;\n"]}
{"filename": "src/hooks/useInterpreter.ts", "chunked_list": ["import { useEffect, useRef } from 'react';\n\ninterface Interpreter {\n  run: (code: string) => void;\n  stop: () => void;\n  execute: (command: string) => void;\n  restart: () => void;\n}\n\ninterface Callbacks {\n  write: (text: string) => void;\n  writeln: (text: string) => void;\n  error: (text: string) => void;\n  system: (text: string) => void;\n  exports?: () => { name: string; content: string }[];\n  lock: () => void;\n  unlock: () => void;\n}\n", "interface Callbacks {\n  write: (text: string) => void;\n  writeln: (text: string) => void;\n  error: (text: string) => void;\n  system: (text: string) => void;\n  exports?: () => { name: string; content: string }[];\n  lock: () => void;\n  unlock: () => void;\n}\n\ninterface Message<L extends Record<string, any>> {\n  type: keyof L;\n  payload: any;\n}\n\nconst useInterpreter = (callbacks: Callbacks): Interpreter => {\n  const workerRef = useRef<Worker>();\n  const interruptBufferRef = useRef<Uint8Array>();\n\n  const setUpInterpreterWorker = () => {\n    const worker = new Worker(\n      new URL('../workers/interpreter.worker.ts', import.meta.url),\n    );\n\n    worker.onmessage = (event: MessageEvent<Message<Callbacks>>) => {\n      callbacks[event.data.type]?.(event.data.payload);\n    };\n\n    let interruptBuffer: Uint8Array | null = null;\n", "interface Message<L extends Record<string, any>> {\n  type: keyof L;\n  payload: any;\n}\n\nconst useInterpreter = (callbacks: Callbacks): Interpreter => {\n  const workerRef = useRef<Worker>();\n  const interruptBufferRef = useRef<Uint8Array>();\n\n  const setUpInterpreterWorker = () => {\n    const worker = new Worker(\n      new URL('../workers/interpreter.worker.ts', import.meta.url),\n    );\n\n    worker.onmessage = (event: MessageEvent<Message<Callbacks>>) => {\n      callbacks[event.data.type]?.(event.data.payload);\n    };\n\n    let interruptBuffer: Uint8Array | null = null;\n", "    if (typeof SharedArrayBuffer !== 'undefined') {\n      interruptBuffer = new Uint8Array(new SharedArrayBuffer(1));\n      interruptBufferRef.current = interruptBuffer;\n    }\n\n    worker.postMessage({ type: 'initialize', payload: interruptBuffer });\n\n    workerRef.current = worker;\n  };\n\n  useEffect(() => {", "    if (workerRef.current) return;\n\n    setUpInterpreterWorker();\n  }, []);\n\n  const resetInterruptBuffer = () => {\n    if (!interruptBufferRef.current) return;\n    interruptBufferRef.current[0] = 0;\n  };\n\n  const restartInterpreter = () => {\n    workerRef.current?.terminate();\n    setUpInterpreterWorker();\n  };\n\n  return {\n    run: (code) => {\n      resetInterruptBuffer();\n      workerRef.current?.postMessage({\n        type: 'run',\n        payload: { code, exports: callbacks.exports?.() },\n      });\n    },\n    stop: () => {", "      if (interruptBufferRef.current) {\n        interruptBufferRef.current[0] = 2;\n        workerRef.current?.postMessage({ type: 'replClear' });\n      } else {\n        callbacks.system(\n          \"\\nDue to browser incompatibility, we can't stop your code execution gracefully. Instead, we'll restart the interpreter for you. Hold on yah...\\n\",\n        );\n        restartInterpreter();\n      }\n    },\n    execute: (code) => {\n      resetInterruptBuffer();\n      workerRef.current?.postMessage({\n        type: 'replInput',\n        payload: { code, exports: callbacks.exports?.() },\n      });\n    },\n    restart: () => {\n      callbacks.system('\\nOkies! Restarting interpreter...\\n');\n      restartInterpreter();\n    },\n  };\n};\n\nexport default useInterpreter;\n"]}
{"filename": "src/hooks/useCommandHistory.ts", "chunked_list": ["import { useRef, useState } from 'react';\nimport produce from 'immer';\n\ninterface CommandHistory {\n  push: (command: string) => void;\n  previous: () => string | undefined;\n  next: () => string | undefined;\n}\n\nconst MAX_HISTORY_LENGTH = 100 as const;\n\nconst useCommandHistory = (): CommandHistory => {\n  const [history, setHistory] = useState<string[]>([]);\n  const position = useRef(0);\n\n  return {\n    push: (command: string) => {\n      position.current = 0;\n\n      setHistory(\n        produce((draft) => {", "          if (draft.length >= MAX_HISTORY_LENGTH) draft.splice(0, 1);\n          draft.push(command);\n        }),\n      );\n    },\n    previous: () => {\n      if (!history.length) return undefined;\n\n      position.current = Math.max(position.current - 1, -history.length);\n      return history.at(position.current);\n    },\n    next: () => {", "      if (!history.length) return undefined;\n\n      position.current = Math.min(position.current + 1, 0);\n      return position.current ? history.at(position.current) : undefined;\n    },\n  };\n};\n\nexport default useCommandHistory;\n"]}
{"filename": "src/workers/interpreter.worker.ts", "chunked_list": ["import {\n  loadPyodide,\n  PyodideInterface,\n  PyProxy,\n  PyProxyAwaitable,\n  PyProxyCallable,\n  PyProxyDict,\n} from 'pyodide';\n\nimport consoleScript from '../assets/console.py';", "\nimport consoleScript from '../assets/console.py';\n\n/**\n * @see https://pyodide.org/en/stable/usage/api/python-api/console.html#pyodide.console.ConsoleFuture.syntax_check\n */\ntype SyntaxCheck = 'syntax-error' | 'incomplete' | 'complete';\n\ninterface Message<T extends Record<string, unknown>> {\n  type: keyof T;\n  payload: any;\n}\n", "interface Message<T extends Record<string, unknown>> {\n  type: keyof T;\n  payload: any;\n}\n\ninterface RunExportableData {\n  code: string;\n  exports?: { name: string; content: string }[];\n}\n\nlet pyodide: PyodideInterface;\nlet interruptBuffer: Uint8Array | null;\n\nlet await_fut: PyProxyCallable;\nlet repr_shorten: PyProxyCallable;\nlet pyconsole: PyProxy;\nlet clear_console: PyProxyCallable;\nlet create_console: PyProxyCallable;\n\nconst PS1 = '\\u001b[32;1m>>> \\u001b[0m' as const;\nconst PS2 = '\\u001b[32m... \\u001b[0m' as const;\nconst RUN_CODE = '\\u001b[3m\\u001b[32m<run code>\\u001b[0m' as const;\n\nconst post = {\n  write: (text: string) => postMessage({ type: 'write', payload: text }),\n  writeln: (line: string) => postMessage({ type: 'writeln', payload: line }),\n  error: (message: string) => postMessage({ type: 'error', payload: message }),\n  system: (message: string) =>\n    postMessage({ type: 'system', payload: message }),\n  lock: () => postMessage({ type: 'lock' }),\n  unlock: () => postMessage({ type: 'unlock' }),\n  prompt: (newLine = true) => post.write(`${newLine ? '\\n' : ''}${PS1}`),\n  promptPending: () => post.write(PS2),\n};\n\nconst setUpConsole = (globals?: PyProxyDict) => {\n  pyconsole?.destroy();\n  pyconsole = create_console(globals);\n};\n\nconst setUpREPLEnvironment = () => {\n  const globals = pyodide.globals.get('dict')();\n\n  pyodide.runPython(consoleScript, { globals });\n\n  repr_shorten = globals.get('repr_shorten');\n  await_fut = globals.get('await_fut');\n  create_console = globals.get('create_console');\n  clear_console = globals.get('clear_console');\n\n  setUpConsole();\n\n  return globals.get('BANNER') as string;\n};\n\nconst preparePyodide = async () => {\n  const newPyodide = await loadPyodide();\n  newPyodide.setStdout({ batched: post.writeln });\n  newPyodide.setStderr({ batched: post.error });\n  pyodide = newPyodide;\n", "  if (interruptBuffer) pyodide.setInterruptBuffer(interruptBuffer);\n\n  /**\n   * Replaces Pyodide's `js` import with a stub `object`. This must also be\n   * paired with some `del sys.modules['js']` in Pyodide's initialisation.\n   */\n  pyodide.registerJsModule('js', {});\n\n  const banner = setUpREPLEnvironment();\n  post.writeln(banner);\n  post.prompt(false);\n  post.unlock();\n\n  return newPyodide;\n};\n\nconst prepareExports = (exports?: { name: string; content: string }[]) => {\n  let newExports = new Set<string>();\n  exports?.forEach(({ name, content }) => {\n    pyodide.FS.writeFile(name, content, { encoding: 'utf-8' });\n    newExports.add(name);\n  });\n\n  const oldExports = pyodide.FS.readdir('.') as string[];\n  oldExports.forEach((name) => {", "    if (name === '.' || name === '..' || newExports.has(name)) return;\n\n    pyodide.FS.unlink(name);\n  });\n};\n\n/**\n * Pyodide may sometimes not catch `RecursionError`s and excessively\n * recursive code spills as JavaScript `RangeError`, causing Pyodide to\n * fatally crash. We need to restart Pyodide in this case.\n * @see https://github.com/pyodide/pyodide/issues/951\n */\nconst handleRangeErrorAndRestartPyodide = async (error: unknown) => {", "  if (!(error instanceof RangeError)) return;\n\n  post.system(\n    '\\nOops, something happened and we have to restart the interpreter. ' +\n      \"Don't worry, it's not your fault. \" +\n      'You may continue once you see the prompt again.\\n',\n  );\n\n  await preparePyodide();\n};\n\nconst listeners = {\n  initialize: async (newInterruptBuffer?: Uint8Array) => {\n    pyodide ??= await preparePyodide();", "    if (!newInterruptBuffer) return;\n\n    pyodide.setInterruptBuffer(newInterruptBuffer);\n    interruptBuffer = newInterruptBuffer;\n  },\n\n  run: async ({ code, exports }: RunExportableData) => {\n    pyodide ??= await preparePyodide();\n\n    post.writeln(RUN_CODE);\n", "    try {\n      post.lock();\n      prepareExports(exports);\n      await pyodide.loadPackagesFromImports(code);\n\n      const globals = pyodide.globals.get('dict')();\n\n      /**\n       * `await pyodide.runPythonAsync(code)` is not used because it raises\n       * an uncatchable `PythonError` when Pyodide emits a `KeyboardInterrupt`.\n       * @see https://github.com/pyodide/pyodide/issues/2141\n       */\n      const result = pyodide.runPython(code, { globals });\n\n      setUpConsole(globals);\n\n      post.writeln(result?.toString());", "    } catch (error) {\n      if (!(error instanceof Error)) throw error;\n\n      post.error(error.message);\n      handleRangeErrorAndRestartPyodide(error);\n    } finally {\n      post.prompt();\n      post.unlock();\n    }\n  },\n\n  replClear: async () => {", "    try {\n      clear_console(pyconsole);\n      await await_fut(pyconsole.push(''));\n    } finally {\n      post.error('\\nKeyboardInterrupt');\n      post.prompt();\n    }\n  },\n\n  replInput: async ({ code, exports }: RunExportableData) => {\n    post.writeln(code);\n\n    const future = pyconsole.push(code) as PyProxy;\n\n    const status = future.syntax_check as SyntaxCheck;\n    switch (status) {\n      case 'syntax-error':\n        post.error(future.formatted_error.trimEnd());\n        post.prompt();\n        return;\n\n      case 'incomplete':\n        post.promptPending();\n        return;\n\n      case 'complete':\n        break;\n\n      default:\n        throw new Error(`Unexpected type: ${status}`);\n    }\n\n    prepareExports(exports);\n    const wrapped = await_fut(future) as PyProxyAwaitable;\n", "    try {\n      const [value] = await wrapped;\n      if (value !== undefined) {\n        const repr = repr_shorten.callKwargs(value, {\n          separator: '\\n<long output truncated>\\n',\n        }) as string;\n\n        post.writeln(repr);\n      }\n\n      if (pyodide.isPyProxy(value)) value.destroy();", "      if (pyodide.isPyProxy(value)) value.destroy();\n    } catch (error) {\n      if (!(error instanceof Error)) throw error;\n\n      const message = future.formatted_error || error.message;\n      post.error(message.trimEnd());\n\n      handleRangeErrorAndRestartPyodide(error);\n    } finally {\n      post.prompt();\n      future.destroy();\n      wrapped.destroy();\n    }\n  },\n};\n\nonmessage = async (event: MessageEvent<Message<typeof listeners>>) => {\n  listeners[event.data.type]?.(event.data.payload);\n};\n", "    } finally {\n      post.prompt();\n      future.destroy();\n      wrapped.destroy();\n    }\n  },\n};\n\nonmessage = async (event: MessageEvent<Message<typeof listeners>>) => {\n  listeners[event.data.type]?.(event.data.payload);\n};\n"]}
