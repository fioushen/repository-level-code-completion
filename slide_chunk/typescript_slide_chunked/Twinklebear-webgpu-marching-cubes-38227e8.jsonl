{"filename": "src/marching_cubes.ts", "chunked_list": ["import {ExclusiveScan} from \"./exclusive_scan\";\nimport {MC_CASE_TABLE} from \"./mc_case_table\";\nimport {StreamCompactIDs} from \"./stream_compact_ids\";\nimport {Volume} from \"./volume\";\nimport {compileShader} from \"./util\";\n\nimport computeVoxelValuesWgsl from \"./compute_voxel_values.wgsl\";\nimport markActiveVoxelsWgsl from \"./mark_active_voxel.wgsl\";\nimport computeNumVertsWgsl from \"./compute_num_verts.wgsl\";\nimport computeVerticesWgsl from \"./compute_vertices.wgsl\";", "import computeNumVertsWgsl from \"./compute_num_verts.wgsl\";\nimport computeVerticesWgsl from \"./compute_vertices.wgsl\";\nimport {PushConstants} from \"./push_constant_builder\";\n\nexport class MarchingCubesResult\n{\n    count: number;\n    buffer: GPUBuffer;\n\n    constructor(count: number, buffer: GPUBuffer)\n    {\n        this.count = count;\n        this.buffer = buffer;\n    }\n};\n\n/* Marching Cubes execution has 5 steps\n * 1. Compute active voxels\n * 2. Stream compact active voxel IDs\n *    - Scan is done on isActive buffer to get compaction offsets\n * 3. Compute # of vertices output by active voxels\n * 4. Scan # vertices buffer to produce vertex output offsets\n * 5. Compute and output vertices\n */", "export class MarchingCubes\n{\n    #device: GPUDevice;\n\n    #volume: Volume;\n\n    #exclusiveScan: ExclusiveScan;\n\n    #streamCompactIds: StreamCompactIDs;\n\n    // Compute pipelines for each stage of the compute \n    #markActiveVoxelPipeline: GPUComputePipeline;\n    #computeNumVertsPipeline: GPUComputePipeline;\n    #computeVerticesPipeline: GPUComputePipeline;\n\n    #triCaseTable: GPUBuffer;\n\n    #volumeInfo: GPUBuffer;\n\n    #voxelActive: GPUBuffer;\n\n    #volumeInfoBG: GPUBindGroup;\n\n    #markActiveBG: GPUBindGroup;\n\n    // Timestamp queries and query output buffer\n    #timestampQuerySupport: boolean;\n    #timestampQuerySet: GPUQuerySet;\n    #timestampBuffer: GPUBuffer;\n    #timestampReadbackBuffer: GPUBuffer;\n\n    // Performance stats\n    computeActiveVoxelsTime = 0;\n    markActiveVoxelsKernelTime = -1;\n    computeActiveVoxelsScanTime = 0;\n    computeActiveVoxelsCompactTime = 0;\n\n    computeVertexOffsetsTime = 0;\n    computeNumVertsKernelTime = -1;\n    computeVertexOffsetsScanTime = 0;\n\n    computeVerticesTime = 0;\n    computeVerticesKernelTime = -1;\n\n    private constructor(volume: Volume, device: GPUDevice)\n    {\n        this.#device = device;\n        this.#volume = volume;\n        this.#timestampQuerySupport = device.features.has(\"timestamp-query\");\n    }\n\n    static async create(volume: Volume, device: GPUDevice)\n    {\n        let mc = new MarchingCubes(volume, device);\n\n        mc.#exclusiveScan = await ExclusiveScan.create(device);\n        mc.#streamCompactIds = await StreamCompactIDs.create(device);\n\n        // Upload the case table\n        // TODO: Can optimize the size of this buffer to store each case value", "        // as an int8, but since WGSL doesn't have an i8 type we then need some\n        // bit unpacking in the shader to do that. Will add this after the initial\n        // implementation.\n        mc.#triCaseTable = device.createBuffer({\n            size: MC_CASE_TABLE.byteLength,\n            usage: GPUBufferUsage.STORAGE,\n            mappedAtCreation: true,\n        });\n        new Int32Array(mc.#triCaseTable.getMappedRange()).set(MC_CASE_TABLE);\n        mc.#triCaseTable.unmap();\n\n        mc.#volumeInfo = device.createBuffer({\n            size: 8 * 4,\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n            mappedAtCreation: true\n        });\n        new Uint32Array(mc.#volumeInfo.getMappedRange()).set(volume.dims);\n        mc.#volumeInfo.unmap();\n\n        // Allocate the voxel active buffer. This buffer's size is fixed for\n        // the entire pipeline, we need to store a flag for each voxel if it's\n        // active or not. We'll run a scan on this buffer so it also needs to be\n        // aligned to the scan size.\n        mc.#voxelActive = device.createBuffer({\n            size: mc.#exclusiveScan.getAlignedSize(volume.dualGridNumVoxels) * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n        });\n\n        // Compile shaders for our compute kernels\n        let markActiveVoxel = await compileShader(device,\n            computeVoxelValuesWgsl + \"\\n\" + markActiveVoxelsWgsl, \"mark_active_voxel.wgsl\");\n        let computeNumVerts = await compileShader(device,\n            computeVoxelValuesWgsl + \"\\n\" + computeNumVertsWgsl, \"compute_num_verts.wgsl\");\n        let computeVertices = await compileShader(device,\n            computeVoxelValuesWgsl + \"\\n\" + computeVerticesWgsl, \"compute_vertices.wgsl\");\n\n        // Bind group layout for the volume parameters, shared by all pipelines in group 0\n        let volumeInfoBGLayout = device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.COMPUTE,\n                    texture: {\n                        viewDimension: \"3d\",\n                    }\n                },\n                {\n                    binding: 1,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: \"uniform\"\n                    }\n                }\n            ]\n        });\n\n        mc.#volumeInfoBG = device.createBindGroup({\n            layout: volumeInfoBGLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: mc.#volume.texture.createView(),\n                },\n                {\n                    binding: 1,\n                    resource: {\n                        buffer: mc.#volumeInfo,\n                    }\n                }\n            ]\n        });\n\n        let markActiveVoxelBGLayout = device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: \"storage\",\n                    }\n                }\n            ]\n        });\n\n        mc.#markActiveBG = device.createBindGroup({\n            layout: markActiveVoxelBGLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: mc.#voxelActive,\n                    }\n                }\n            ]\n        });\n\n        let computeNumVertsBGLayout = device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: \"read-only-storage\",\n                    }\n                },\n                {\n                    binding: 1,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: \"storage\",\n                    }\n                },\n                {\n                    binding: 2,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: \"storage\",\n                    }\n                }\n            ]\n        });\n\n        let computeVerticesBGLayout = device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: \"read-only-storage\",\n                    }\n                },\n                {\n                    binding: 1,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: \"storage\",\n                    }\n                },\n                {\n                    binding: 2,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: \"storage\",\n                    }\n                },\n                {\n                    binding: 3,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: \"storage\",\n                    }\n                }\n            ]\n        });\n\n        // Push constants BG layout\n        let pushConstantsBGLayout = device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: \"uniform\",\n                        hasDynamicOffset: true\n                    }\n                }\n            ]\n        });\n\n        // Create pipelines\n        mc.#markActiveVoxelPipeline = device.createComputePipeline({\n            layout: device.createPipelineLayout(\n                {bindGroupLayouts: [volumeInfoBGLayout, markActiveVoxelBGLayout]}),\n            compute: {\n                module: markActiveVoxel,\n                entryPoint: \"main\"\n            }\n        });\n\n\n        mc.#computeNumVertsPipeline = device.createComputePipeline({\n            layout: device.createPipelineLayout({\n                bindGroupLayouts: [\n                    volumeInfoBGLayout,\n                    computeNumVertsBGLayout,\n                    pushConstantsBGLayout\n                ]\n            }),\n            compute: {\n                module: computeNumVerts,\n                entryPoint: \"main\"\n            }\n        });\n\n        mc.#computeVerticesPipeline = device.createComputePipeline({\n            layout: device.createPipelineLayout({\n                bindGroupLayouts: [\n                    volumeInfoBGLayout,\n                    computeVerticesBGLayout,\n                    pushConstantsBGLayout\n                ]\n            }),\n            compute: {\n                module: computeVertices,\n                entryPoint: \"main\"\n            }\n        });\n", "        if (mc.#timestampQuerySupport) {\n            // We store 6 timestamps, for the start/end of each compute pass we run\n            mc.#timestampQuerySet = device.createQuerySet({\n                type: \"timestamp\",\n                count: 6\n            });\n            mc.#timestampBuffer = device.createBuffer({\n                size: 6 * 8,\n                usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC\n            });\n            mc.#timestampReadbackBuffer = device.createBuffer({\n                size: mc.#timestampBuffer.size,\n                usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n            });\n        }\n\n        return mc;\n    }\n\n    // Computes the surface for the provided isovalue, returning the number of triangles\n    // in the surface and the GPUBuffer containing their vertices\n    async computeSurface(isovalue: number)\n    {\n        this.uploadIsovalue(isovalue);\n\n        let start = performance.now();\n        let activeVoxels = await this.computeActiveVoxels();\n        let end = performance.now();\n        this.computeActiveVoxelsTime = end - start;", "        if (activeVoxels.count == 0) {\n            return new MarchingCubesResult(0, null);\n        }\n\n        start = performance.now();\n        let vertexOffsets = await this.computeVertexOffsets(activeVoxels);\n        end = performance.now();\n        this.computeVertexOffsetsTime = end - start;\n        if (vertexOffsets.count == 0) {\n            return new MarchingCubesResult(0, null);\n        }\n\n        start = performance.now();\n        let vertices = await this.computeVertices(activeVoxels, vertexOffsets);\n        end = performance.now();\n        this.computeVerticesTime = end - start;\n        activeVoxels.buffer.destroy();\n        vertexOffsets.buffer.destroy();\n\n        // Map back the timestamps and get performance statistics", "        if (vertexOffsets.count == 0) {\n            return new MarchingCubesResult(0, null);\n        }\n\n        start = performance.now();\n        let vertices = await this.computeVertices(activeVoxels, vertexOffsets);\n        end = performance.now();\n        this.computeVerticesTime = end - start;\n        activeVoxels.buffer.destroy();\n        vertexOffsets.buffer.destroy();\n\n        // Map back the timestamps and get performance statistics", "        if (this.#timestampQuerySupport) {\n            await this.#timestampReadbackBuffer.mapAsync(GPUMapMode.READ);\n            let times = new BigUint64Array(this.#timestampReadbackBuffer.getMappedRange());\n\n            // Timestamps are in nanoseconds\n            this.markActiveVoxelsKernelTime = Number(times[1] - times[0]) * 1.0e-6;\n            this.computeNumVertsKernelTime = Number(times[3] - times[2]) * 1.0e-6;\n            this.computeVerticesKernelTime = Number(times[5] - times[4]) * 1.0e-6;\n\n            this.#timestampReadbackBuffer.unmap();\n        }\n\n        return new MarchingCubesResult(vertexOffsets.count, vertices);\n    }\n\n    private uploadIsovalue(isovalue: number)\n    {\n        let uploadIsovalue = this.#device.createBuffer({\n            size: 4,\n            usage: GPUBufferUsage.COPY_SRC,\n            mappedAtCreation: true\n        });\n        new Float32Array(uploadIsovalue.getMappedRange()).set([isovalue]);\n        uploadIsovalue.unmap();\n\n        var commandEncoder = this.#device.createCommandEncoder();\n        commandEncoder.copyBufferToBuffer(uploadIsovalue, 0, this.#volumeInfo, 16, 4);\n        this.#device.queue.submit([commandEncoder.finish()]);\n    }\n\n    private async computeActiveVoxels()\n    {\n        let dispatchSize = [\n            Math.ceil(this.#volume.dualGridDims[0] / 4),\n            Math.ceil(this.#volume.dualGridDims[1] / 4),\n            Math.ceil(this.#volume.dualGridDims[2] / 2)\n        ];\n\n        let activeVoxelOffsets = this.#device.createBuffer({\n            size: this.#voxelActive.size,\n            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC | GPUBufferUsage.STORAGE\n        });\n\n        var commandEncoder = this.#device.createCommandEncoder();\n", "        if (this.#timestampQuerySupport) {\n            commandEncoder.writeTimestamp(this.#timestampQuerySet, 0);\n        }\n        var pass = commandEncoder.beginComputePass();\n\n        pass.setPipeline(this.#markActiveVoxelPipeline);\n        pass.setBindGroup(0, this.#volumeInfoBG);\n        pass.setBindGroup(1, this.#markActiveBG);\n        pass.dispatchWorkgroups(dispatchSize[0], dispatchSize[1], dispatchSize[2]);\n\n        pass.end();", "        if (this.#timestampQuerySupport) {\n            commandEncoder.writeTimestamp(this.#timestampQuerySet, 1);\n        }\n\n        // Copy the active voxel info to the offsets buffer that we're going to scan,\n        // since scan happens in place\n        commandEncoder.copyBufferToBuffer(this.#voxelActive, 0, activeVoxelOffsets, 0, activeVoxelOffsets.size);\n\n        this.#device.queue.submit([commandEncoder.finish()]);\n        await this.#device.queue.onSubmittedWorkDone();\n\n        let start = performance.now();\n        // Scan the active voxel buffer to get offsets to output the active voxel IDs too\n        let nActive = await this.#exclusiveScan.scan(activeVoxelOffsets, this.#volume.dualGridNumVoxels);\n        let end = performance.now();\n        this.computeActiveVoxelsScanTime = end - start;", "        if (nActive == 0) {\n            return new MarchingCubesResult(0, null);\n        }\n\n        let activeVoxelIDs = this.#device.createBuffer({\n            size: nActive * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC\n        });\n\n        start = performance.now();\n        // Output the compact buffer of active voxel IDs\n        await this.#streamCompactIds.compactActiveIDs(this.#voxelActive,\n            activeVoxelOffsets,\n            activeVoxelIDs,\n            this.#volume.dualGridNumVoxels);\n        end = performance.now();\n        this.computeActiveVoxelsCompactTime = end - start;\n\n        activeVoxelOffsets.destroy();\n\n        return new MarchingCubesResult(nActive, activeVoxelIDs);\n    }\n\n    private async computeVertexOffsets(activeVoxels: MarchingCubesResult)\n    {\n        let vertexOffsets = this.#device.createBuffer({\n            size: this.#exclusiveScan.getAlignedSize(activeVoxels.count) * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC\n        });\n\n        let bindGroup = this.#device.createBindGroup({\n            layout: this.#computeNumVertsPipeline.getBindGroupLayout(1),\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: this.#triCaseTable\n                    }\n                },\n                {\n                    binding: 1,\n                    resource: {\n                        buffer: activeVoxels.buffer,\n                    }\n                },\n                {\n                    binding: 2,\n                    resource: {\n                        buffer: vertexOffsets\n                    }\n                }\n            ]\n        });\n\n        let pushConstantsArg = new Uint32Array([activeVoxels.count]);\n        let pushConstants = new PushConstants(\n            this.#device, Math.ceil(activeVoxels.count / 32), pushConstantsArg.buffer);\n\n        let pushConstantsBG = this.#device.createBindGroup({\n            layout: this.#computeNumVertsPipeline.getBindGroupLayout(2),\n            entries: [{\n                binding: 0,\n                resource: {\n                    buffer: pushConstants.pushConstantsBuffer,\n                    size: 12,\n                }\n            }]\n        });\n\n        let commandEncoder = this.#device.createCommandEncoder();", "        if (this.#timestampQuerySupport) {\n            commandEncoder.writeTimestamp(this.#timestampQuerySet, 2);\n        }\n\n        let pass = commandEncoder.beginComputePass();\n        pass.setPipeline(this.#computeNumVertsPipeline);\n        pass.setBindGroup(0, this.#volumeInfoBG);\n        pass.setBindGroup(1, bindGroup);\n        for (let i = 0; i < pushConstants.numDispatches(); ++i) {\n            pass.setBindGroup(2, pushConstantsBG, [i * pushConstants.stride]);\n            pass.dispatchWorkgroups(pushConstants.dispatchSize(i), 1, 1);\n        }\n        pass.end();", "        for (let i = 0; i < pushConstants.numDispatches(); ++i) {\n            pass.setBindGroup(2, pushConstantsBG, [i * pushConstants.stride]);\n            pass.dispatchWorkgroups(pushConstants.dispatchSize(i), 1, 1);\n        }\n        pass.end();\n        if (this.#timestampQuerySupport) {\n            commandEncoder.writeTimestamp(this.#timestampQuerySet, 3);\n        }\n        this.#device.queue.submit([commandEncoder.finish()]);\n        await this.#device.queue.onSubmittedWorkDone();\n\n        let start = performance.now();\n        let nVertices = await this.#exclusiveScan.scan(vertexOffsets, activeVoxels.count);\n        let end = performance.now();\n        this.computeVertexOffsetsScanTime = end - start;\n\n        return new MarchingCubesResult(nVertices, vertexOffsets);\n    }\n\n    private async computeVertices(activeVoxels: MarchingCubesResult, vertexOffsets: MarchingCubesResult)\n    {\n        // We'll output a float4 per vertex\n        let vertices = this.#device.createBuffer({\n            size: vertexOffsets.count * 4 * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC\n        });\n\n        let bindGroup = this.#device.createBindGroup({\n            layout: this.#computeVerticesPipeline.getBindGroupLayout(1),\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: this.#triCaseTable\n                    }\n                },\n                {\n                    binding: 1,\n                    resource: {\n                        buffer: activeVoxels.buffer,\n                    }\n                },\n                {\n                    binding: 2,\n                    resource: {\n                        buffer: vertexOffsets.buffer\n                    }\n                },\n                {\n                    binding: 3,\n                    resource: {\n                        buffer: vertices\n                    }\n                }\n            ]\n        });\n\n        let pushConstantsArg = new Uint32Array([activeVoxels.count]);\n        let pushConstants = new PushConstants(\n            this.#device, Math.ceil(activeVoxels.count / 32), pushConstantsArg.buffer);\n\n        let pushConstantsBG = this.#device.createBindGroup({\n            layout: this.#computeNumVertsPipeline.getBindGroupLayout(2),\n            entries: [{\n                binding: 0,\n                resource: {\n                    buffer: pushConstants.pushConstantsBuffer,\n                    size: 12,\n                }\n            }]\n        });\n\n        let commandEncoder = this.#device.createCommandEncoder();", "        if (this.#timestampQuerySupport) {\n            commandEncoder.writeTimestamp(this.#timestampQuerySet, 4);\n        }\n\n        let pass = commandEncoder.beginComputePass();\n        pass.setPipeline(this.#computeVerticesPipeline);\n        pass.setBindGroup(0, this.#volumeInfoBG);\n        pass.setBindGroup(1, bindGroup);\n        for (let i = 0; i < pushConstants.numDispatches(); ++i) {\n            pass.setBindGroup(2, pushConstantsBG, [i * pushConstants.stride]);\n            pass.dispatchWorkgroups(pushConstants.dispatchSize(i), 1, 1);\n        }\n        pass.end();\n", "        for (let i = 0; i < pushConstants.numDispatches(); ++i) {\n            pass.setBindGroup(2, pushConstantsBG, [i * pushConstants.stride]);\n            pass.dispatchWorkgroups(pushConstants.dispatchSize(i), 1, 1);\n        }\n        pass.end();\n\n        if (this.#timestampQuerySupport) {\n            commandEncoder.writeTimestamp(this.#timestampQuerySet, 5);\n\n            // This is our last compute pass to compute the surface, so resolve the\n            // timestamp queries now as well\n            commandEncoder.resolveQuerySet(this.#timestampQuerySet, 0, 6, this.#timestampBuffer, 0);\n            commandEncoder.copyBufferToBuffer(this.#timestampBuffer,\n                0,\n                this.#timestampReadbackBuffer,\n                0,\n                this.#timestampBuffer.size);\n        }\n\n        this.#device.queue.submit([commandEncoder.finish()]);\n        await this.#device.queue.onSubmittedWorkDone();\n\n        return vertices;\n    }\n};\n"]}
{"filename": "src/mc_case_table.ts", "chunked_list": ["// Edge and triangle tables for the cases of marching cubes\n// From http://paulbourke.net/geometry/polygonise/ and\n// https://graphics.stanford.edu/~mdfisher/MarchingCubes.html\nexport const MC_CASE_TABLE = new Int32Array([\n    -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 8, 3, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    1, 9, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    8, 1, 9, 8, 3, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    2, 10, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 8, 3, 1, 2, 10, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,", "    2, 10, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 8, 3, 1, 2, 10, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    9, 2, 10, 9, 0, 2, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    3, 2, 10, 3, 10, 8, 8, 10, 9, -1, 0, 0, 0, 0, 0, 0,\n    2, 3, 11, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    11, 0, 8, 11, 2, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    1, 9, 0, 2, 3, 11, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    2, 1, 9, 2, 9, 11, 11, 9, 8, -1, 0, 0, 0, 0, 0, 0,\n    3, 10, 1, 3, 11, 10, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    1, 0, 8, 1, 8, 10, 10, 8, 11, -1, 0, 0, 0, 0, 0, 0,", "    3, 10, 1, 3, 11, 10, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    1, 0, 8, 1, 8, 10, 10, 8, 11, -1, 0, 0, 0, 0, 0, 0,\n    0, 3, 11, 0, 11, 9, 9, 11, 10, -1, 0, 0, 0, 0, 0, 0,\n    11, 10, 9, 11, 9, 8, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    4, 7, 8, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    4, 3, 0, 4, 7, 3, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    4, 7, 8, 9, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    9, 4, 7, 9, 7, 1, 1, 7, 3, -1, 0, 0, 0, 0, 0, 0,\n    4, 7, 8, 1, 2, 10, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    4, 3, 0, 4, 7, 3, 2, 10, 1, -1, 0, 0, 0, 0, 0, 0,", "    4, 7, 8, 1, 2, 10, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    4, 3, 0, 4, 7, 3, 2, 10, 1, -1, 0, 0, 0, 0, 0, 0,\n    2, 9, 0, 2, 10, 9, 4, 7, 8, -1, 0, 0, 0, 0, 0, 0,\n    3, 2, 7, 7, 9, 4, 7, 2, 9, 9, 2, 10, -1, 0, 0, 0,\n    8, 4, 7, 3, 11, 2, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    7, 11, 2, 7, 2, 4, 4, 2, 0, -1, 0, 0, 0, 0, 0, 0,\n    2, 3, 11, 1, 9, 0, 8, 4, 7, -1, 0, 0, 0, 0, 0, 0,\n    2, 1, 9, 2, 9, 4, 2, 4, 11, 11, 4, 7, -1, 0, 0, 0,\n    10, 3, 11, 10, 1, 3, 8, 4, 7, -1, 0, 0, 0, 0, 0, 0,\n    4, 7, 0, 0, 10, 1, 7, 10, 0, 7, 11, 10, -1, 0, 0, 0,", "    10, 3, 11, 10, 1, 3, 8, 4, 7, -1, 0, 0, 0, 0, 0, 0,\n    4, 7, 0, 0, 10, 1, 7, 10, 0, 7, 11, 10, -1, 0, 0, 0,\n    8, 4, 7, 0, 3, 11, 0, 11, 9, 9, 11, 10, -1, 0, 0, 0,\n    7, 9, 4, 7, 11, 9, 9, 11, 10, -1, 0, 0, 0, 0, 0, 0,\n    4, 9, 5, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    8, 3, 0, 4, 9, 5, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 5, 4, 0, 1, 5, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    4, 8, 3, 4, 3, 5, 5, 3, 1, -1, 0, 0, 0, 0, 0, 0,\n    1, 2, 10, 9, 5, 4, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    4, 9, 5, 8, 3, 0, 1, 2, 10, -1, 0, 0, 0, 0, 0, 0,", "    1, 2, 10, 9, 5, 4, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    4, 9, 5, 8, 3, 0, 1, 2, 10, -1, 0, 0, 0, 0, 0, 0,\n    10, 5, 4, 10, 4, 2, 2, 4, 0, -1, 0, 0, 0, 0, 0, 0,\n    4, 8, 3, 4, 3, 2, 4, 2, 5, 5, 2, 10, -1, 0, 0, 0,\n    2, 3, 11, 5, 4, 9, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    11, 0, 8, 11, 2, 0, 9, 5, 4, -1, 0, 0, 0, 0, 0, 0,\n    5, 0, 1, 5, 4, 0, 3, 11, 2, -1, 0, 0, 0, 0, 0, 0,\n    11, 2, 8, 8, 5, 4, 2, 5, 8, 2, 1, 5, -1, 0, 0, 0,\n    3, 10, 1, 3, 11, 10, 5, 4, 9, -1, 0, 0, 0, 0, 0, 0,\n    9, 5, 4, 1, 0, 8, 1, 8, 10, 10, 8, 11, -1, 0, 0, 0,", "    3, 10, 1, 3, 11, 10, 5, 4, 9, -1, 0, 0, 0, 0, 0, 0,\n    9, 5, 4, 1, 0, 8, 1, 8, 10, 10, 8, 11, -1, 0, 0, 0,\n    10, 5, 11, 11, 0, 3, 11, 5, 0, 0, 5, 4, -1, 0, 0, 0,\n    4, 10, 5, 4, 8, 10, 10, 8, 11, -1, 0, 0, 0, 0, 0, 0,\n    7, 9, 5, 7, 8, 9, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 9, 5, 0, 5, 3, 3, 5, 7, -1, 0, 0, 0, 0, 0, 0,\n    8, 0, 1, 8, 1, 7, 7, 1, 5, -1, 0, 0, 0, 0, 0, 0,\n    3, 1, 5, 3, 5, 7, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    7, 9, 5, 7, 8, 9, 1, 2, 10, -1, 0, 0, 0, 0, 0, 0,\n    1, 2, 10, 0, 9, 5, 0, 5, 3, 3, 5, 7, -1, 0, 0, 0,", "    7, 9, 5, 7, 8, 9, 1, 2, 10, -1, 0, 0, 0, 0, 0, 0,\n    1, 2, 10, 0, 9, 5, 0, 5, 3, 3, 5, 7, -1, 0, 0, 0,\n    7, 8, 5, 5, 2, 10, 8, 2, 5, 8, 0, 2, -1, 0, 0, 0,\n    10, 3, 2, 10, 5, 3, 3, 5, 7, -1, 0, 0, 0, 0, 0, 0,\n    9, 7, 8, 9, 5, 7, 11, 2, 3, -1, 0, 0, 0, 0, 0, 0,\n    0, 9, 2, 2, 7, 11, 2, 9, 7, 7, 9, 5, -1, 0, 0, 0,\n    3, 11, 2, 8, 0, 1, 8, 1, 7, 7, 1, 5, -1, 0, 0, 0,\n    2, 7, 11, 2, 1, 7, 7, 1, 5, -1, 0, 0, 0, 0, 0, 0,\n    11, 1, 3, 11, 10, 1, 7, 8, 9, 7, 9, 5, -1, 0, 0, 0,\n    11, 10, 1, 11, 1, 7, 7, 1, 0, 7, 0, 9, 7, 9, 5, -1,", "    11, 1, 3, 11, 10, 1, 7, 8, 9, 7, 9, 5, -1, 0, 0, 0,\n    11, 10, 1, 11, 1, 7, 7, 1, 0, 7, 0, 9, 7, 9, 5, -1,\n    5, 7, 8, 5, 8, 10, 10, 8, 0, 10, 0, 3, 10, 3, 11, -1,\n    11, 10, 5, 11, 5, 7, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    10, 6, 5, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 8, 3, 10, 6, 5, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    9, 0, 1, 5, 10, 6, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    8, 1, 9, 8, 3, 1, 10, 6, 5, -1, 0, 0, 0, 0, 0, 0,\n    6, 1, 2, 6, 5, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    6, 1, 2, 6, 5, 1, 0, 8, 3, -1, 0, 0, 0, 0, 0, 0,", "    6, 1, 2, 6, 5, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    6, 1, 2, 6, 5, 1, 0, 8, 3, -1, 0, 0, 0, 0, 0, 0,\n    5, 9, 0, 5, 0, 6, 6, 0, 2, -1, 0, 0, 0, 0, 0, 0,\n    6, 5, 2, 2, 8, 3, 5, 8, 2, 5, 9, 8, -1, 0, 0, 0,\n    2, 3, 11, 10, 6, 5, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 11, 2, 0, 8, 11, 6, 5, 10, -1, 0, 0, 0, 0, 0, 0,\n    0, 1, 9, 3, 11, 2, 10, 6, 5, -1, 0, 0, 0, 0, 0, 0,\n    10, 6, 5, 2, 1, 9, 2, 9, 11, 11, 9, 8, -1, 0, 0, 0,\n    11, 6, 5, 11, 5, 3, 3, 5, 1, -1, 0, 0, 0, 0, 0, 0,\n    11, 6, 8, 8, 1, 0, 8, 6, 1, 1, 6, 5, -1, 0, 0, 0,", "    11, 6, 5, 11, 5, 3, 3, 5, 1, -1, 0, 0, 0, 0, 0, 0,\n    11, 6, 8, 8, 1, 0, 8, 6, 1, 1, 6, 5, -1, 0, 0, 0,\n    0, 3, 11, 0, 11, 6, 0, 6, 9, 9, 6, 5, -1, 0, 0, 0,\n    5, 11, 6, 5, 9, 11, 11, 9, 8, -1, 0, 0, 0, 0, 0, 0,\n    7, 8, 4, 6, 5, 10, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    3, 4, 7, 3, 0, 4, 5, 10, 6, -1, 0, 0, 0, 0, 0, 0,\n    6, 5, 10, 7, 8, 4, 9, 0, 1, -1, 0, 0, 0, 0, 0, 0,\n    5, 10, 6, 9, 4, 7, 9, 7, 1, 1, 7, 3, -1, 0, 0, 0,\n    1, 6, 5, 1, 2, 6, 7, 8, 4, -1, 0, 0, 0, 0, 0, 0,\n    7, 0, 4, 7, 3, 0, 6, 5, 1, 6, 1, 2, -1, 0, 0, 0,", "    1, 6, 5, 1, 2, 6, 7, 8, 4, -1, 0, 0, 0, 0, 0, 0,\n    7, 0, 4, 7, 3, 0, 6, 5, 1, 6, 1, 2, -1, 0, 0, 0,\n    4, 7, 8, 5, 9, 0, 5, 0, 6, 6, 0, 2, -1, 0, 0, 0,\n    2, 6, 5, 2, 5, 3, 3, 5, 9, 3, 9, 4, 3, 4, 7, -1,\n    4, 7, 8, 5, 10, 6, 11, 2, 3, -1, 0, 0, 0, 0, 0, 0,\n    6, 5, 10, 7, 11, 2, 7, 2, 4, 4, 2, 0, -1, 0, 0, 0,\n    4, 7, 8, 9, 0, 1, 6, 5, 10, 3, 11, 2, -1, 0, 0, 0,\n    6, 5, 10, 11, 4, 7, 11, 2, 4, 4, 2, 9, 9, 2, 1, -1,\n    7, 8, 4, 11, 6, 5, 11, 5, 3, 3, 5, 1, -1, 0, 0, 0,\n    0, 4, 7, 0, 7, 1, 1, 7, 11, 1, 11, 6, 1, 6, 5, -1,", "    7, 8, 4, 11, 6, 5, 11, 5, 3, 3, 5, 1, -1, 0, 0, 0,\n    0, 4, 7, 0, 7, 1, 1, 7, 11, 1, 11, 6, 1, 6, 5, -1,\n    4, 7, 8, 9, 6, 5, 9, 0, 6, 6, 0, 11, 11, 0, 3, -1,\n    7, 11, 4, 11, 9, 4, 11, 5, 9, 11, 6, 5, -1, 0, 0, 0,\n    10, 4, 9, 10, 6, 4, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    10, 4, 9, 10, 6, 4, 8, 3, 0, -1, 0, 0, 0, 0, 0, 0,\n    1, 10, 6, 1, 6, 0, 0, 6, 4, -1, 0, 0, 0, 0, 0, 0,\n    4, 8, 6, 6, 1, 10, 6, 8, 1, 1, 8, 3, -1, 0, 0, 0,\n    9, 1, 2, 9, 2, 4, 4, 2, 6, -1, 0, 0, 0, 0, 0, 0,\n    0, 8, 3, 9, 1, 2, 9, 2, 4, 4, 2, 6, -1, 0, 0, 0,", "    9, 1, 2, 9, 2, 4, 4, 2, 6, -1, 0, 0, 0, 0, 0, 0,\n    0, 8, 3, 9, 1, 2, 9, 2, 4, 4, 2, 6, -1, 0, 0, 0,\n    0, 2, 6, 0, 6, 4, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    3, 4, 8, 3, 2, 4, 4, 2, 6, -1, 0, 0, 0, 0, 0, 0,\n    4, 10, 6, 4, 9, 10, 2, 3, 11, -1, 0, 0, 0, 0, 0, 0,\n    8, 2, 0, 8, 11, 2, 4, 9, 10, 4, 10, 6, -1, 0, 0, 0,\n    2, 3, 11, 1, 10, 6, 1, 6, 0, 0, 6, 4, -1, 0, 0, 0,\n    8, 11, 2, 8, 2, 4, 4, 2, 1, 4, 1, 10, 4, 10, 6, -1,\n    3, 11, 1, 1, 4, 9, 11, 4, 1, 11, 6, 4, -1, 0, 0, 0,\n    6, 4, 9, 6, 9, 11, 11, 9, 1, 11, 1, 0, 11, 0, 8, -1,", "    3, 11, 1, 1, 4, 9, 11, 4, 1, 11, 6, 4, -1, 0, 0, 0,\n    6, 4, 9, 6, 9, 11, 11, 9, 1, 11, 1, 0, 11, 0, 8, -1,\n    11, 0, 3, 11, 6, 0, 0, 6, 4, -1, 0, 0, 0, 0, 0, 0,\n    8, 11, 6, 8, 6, 4, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    6, 7, 8, 6, 8, 10, 10, 8, 9, -1, 0, 0, 0, 0, 0, 0,\n    3, 0, 7, 7, 10, 6, 0, 10, 7, 0, 9, 10, -1, 0, 0, 0,\n    1, 10, 6, 1, 6, 7, 1, 7, 0, 0, 7, 8, -1, 0, 0, 0,\n    6, 1, 10, 6, 7, 1, 1, 7, 3, -1, 0, 0, 0, 0, 0, 0,\n    9, 1, 8, 8, 6, 7, 8, 1, 6, 6, 1, 2, -1, 0, 0, 0,\n    7, 3, 0, 7, 0, 6, 6, 0, 9, 6, 9, 1, 6, 1, 2, -1,", "    9, 1, 8, 8, 6, 7, 8, 1, 6, 6, 1, 2, -1, 0, 0, 0,\n    7, 3, 0, 7, 0, 6, 6, 0, 9, 6, 9, 1, 6, 1, 2, -1,\n    8, 6, 7, 8, 0, 6, 6, 0, 2, -1, 0, 0, 0, 0, 0, 0,\n    2, 6, 7, 2, 7, 3, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    11, 2, 3, 6, 7, 8, 6, 8, 10, 10, 8, 9, -1, 0, 0, 0,\n    9, 10, 6, 9, 6, 0, 0, 6, 7, 0, 7, 11, 0, 11, 2, -1,\n    3, 11, 2, 0, 7, 8, 0, 1, 7, 7, 1, 6, 6, 1, 10, -1,\n    6, 7, 10, 7, 1, 10, 7, 2, 1, 7, 11, 2, -1, 0, 0, 0,\n    1, 3, 11, 1, 11, 9, 9, 11, 6, 9, 6, 7, 9, 7, 8, -1,\n    6, 7, 11, 9, 1, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,", "    1, 3, 11, 1, 11, 9, 9, 11, 6, 9, 6, 7, 9, 7, 8, -1,\n    6, 7, 11, 9, 1, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    8, 0, 7, 0, 6, 7, 0, 11, 6, 0, 3, 11, -1, 0, 0, 0,\n    6, 7, 11, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    6, 11, 7, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    3, 0, 8, 11, 7, 6, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    6, 11, 7, 9, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    1, 8, 3, 1, 9, 8, 7, 6, 11, -1, 0, 0, 0, 0, 0, 0,\n    11, 7, 6, 2, 10, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    1, 2, 10, 0, 8, 3, 11, 7, 6, -1, 0, 0, 0, 0, 0, 0,", "    11, 7, 6, 2, 10, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    1, 2, 10, 0, 8, 3, 11, 7, 6, -1, 0, 0, 0, 0, 0, 0,\n    9, 2, 10, 9, 0, 2, 11, 7, 6, -1, 0, 0, 0, 0, 0, 0,\n    11, 7, 6, 3, 2, 10, 3, 10, 8, 8, 10, 9, -1, 0, 0, 0,\n    2, 7, 6, 2, 3, 7, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    8, 7, 6, 8, 6, 0, 0, 6, 2, -1, 0, 0, 0, 0, 0, 0,\n    7, 2, 3, 7, 6, 2, 1, 9, 0, -1, 0, 0, 0, 0, 0, 0,\n    8, 7, 9, 9, 2, 1, 9, 7, 2, 2, 7, 6, -1, 0, 0, 0,\n    6, 10, 1, 6, 1, 7, 7, 1, 3, -1, 0, 0, 0, 0, 0, 0,\n    6, 10, 1, 6, 1, 0, 6, 0, 7, 7, 0, 8, -1, 0, 0, 0,", "    6, 10, 1, 6, 1, 7, 7, 1, 3, -1, 0, 0, 0, 0, 0, 0,\n    6, 10, 1, 6, 1, 0, 6, 0, 7, 7, 0, 8, -1, 0, 0, 0,\n    7, 6, 3, 3, 9, 0, 6, 9, 3, 6, 10, 9, -1, 0, 0, 0,\n    6, 8, 7, 6, 10, 8, 8, 10, 9, -1, 0, 0, 0, 0, 0, 0,\n    8, 6, 11, 8, 4, 6, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    11, 3, 0, 11, 0, 6, 6, 0, 4, -1, 0, 0, 0, 0, 0, 0,\n    6, 8, 4, 6, 11, 8, 0, 1, 9, -1, 0, 0, 0, 0, 0, 0,\n    1, 9, 3, 3, 6, 11, 9, 6, 3, 9, 4, 6, -1, 0, 0, 0,\n    8, 6, 11, 8, 4, 6, 10, 1, 2, -1, 0, 0, 0, 0, 0, 0,\n    2, 10, 1, 11, 3, 0, 11, 0, 6, 6, 0, 4, -1, 0, 0, 0,", "    8, 6, 11, 8, 4, 6, 10, 1, 2, -1, 0, 0, 0, 0, 0, 0,\n    2, 10, 1, 11, 3, 0, 11, 0, 6, 6, 0, 4, -1, 0, 0, 0,\n    11, 4, 6, 11, 8, 4, 2, 10, 9, 2, 9, 0, -1, 0, 0, 0,\n    4, 6, 11, 4, 11, 9, 9, 11, 3, 9, 3, 2, 9, 2, 10, -1,\n    3, 8, 4, 3, 4, 2, 2, 4, 6, -1, 0, 0, 0, 0, 0, 0,\n    2, 0, 4, 2, 4, 6, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 1, 9, 3, 8, 4, 3, 4, 2, 2, 4, 6, -1, 0, 0, 0,\n    9, 2, 1, 9, 4, 2, 2, 4, 6, -1, 0, 0, 0, 0, 0, 0,\n    6, 10, 4, 4, 3, 8, 4, 10, 3, 3, 10, 1, -1, 0, 0, 0,\n    1, 6, 10, 1, 0, 6, 6, 0, 4, -1, 0, 0, 0, 0, 0, 0,", "    6, 10, 4, 4, 3, 8, 4, 10, 3, 3, 10, 1, -1, 0, 0, 0,\n    1, 6, 10, 1, 0, 6, 6, 0, 4, -1, 0, 0, 0, 0, 0, 0,\n    10, 9, 0, 10, 0, 6, 6, 0, 3, 6, 3, 8, 6, 8, 4, -1,\n    10, 9, 4, 10, 4, 6, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    6, 11, 7, 5, 4, 9, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 8, 3, 9, 5, 4, 7, 6, 11, -1, 0, 0, 0, 0, 0, 0,\n    0, 5, 4, 0, 1, 5, 6, 11, 7, -1, 0, 0, 0, 0, 0, 0,\n    7, 6, 11, 4, 8, 3, 4, 3, 5, 5, 3, 1, -1, 0, 0, 0,\n    2, 10, 1, 11, 7, 6, 5, 4, 9, -1, 0, 0, 0, 0, 0, 0,\n    0, 8, 3, 1, 2, 10, 4, 9, 5, 11, 7, 6, -1, 0, 0, 0,", "    2, 10, 1, 11, 7, 6, 5, 4, 9, -1, 0, 0, 0, 0, 0, 0,\n    0, 8, 3, 1, 2, 10, 4, 9, 5, 11, 7, 6, -1, 0, 0, 0,\n    6, 11, 7, 10, 5, 4, 10, 4, 2, 2, 4, 0, -1, 0, 0, 0,\n    6, 11, 7, 5, 2, 10, 5, 4, 2, 2, 4, 3, 3, 4, 8, -1,\n    2, 7, 6, 2, 3, 7, 4, 9, 5, -1, 0, 0, 0, 0, 0, 0,\n    4, 9, 5, 8, 7, 6, 8, 6, 0, 0, 6, 2, -1, 0, 0, 0,\n    3, 6, 2, 3, 7, 6, 0, 1, 5, 0, 5, 4, -1, 0, 0, 0,\n    1, 5, 4, 1, 4, 2, 2, 4, 8, 2, 8, 7, 2, 7, 6, -1,\n    5, 4, 9, 6, 10, 1, 6, 1, 7, 7, 1, 3, -1, 0, 0, 0,\n    4, 9, 5, 7, 0, 8, 7, 6, 0, 0, 6, 1, 1, 6, 10, -1,", "    5, 4, 9, 6, 10, 1, 6, 1, 7, 7, 1, 3, -1, 0, 0, 0,\n    4, 9, 5, 7, 0, 8, 7, 6, 0, 0, 6, 1, 1, 6, 10, -1,\n    3, 7, 6, 3, 6, 0, 0, 6, 10, 0, 10, 5, 0, 5, 4, -1,\n    4, 8, 5, 8, 10, 5, 8, 6, 10, 8, 7, 6, -1, 0, 0, 0,\n    5, 6, 11, 5, 11, 9, 9, 11, 8, -1, 0, 0, 0, 0, 0, 0,\n    0, 9, 5, 0, 5, 6, 0, 6, 3, 3, 6, 11, -1, 0, 0, 0,\n    8, 0, 11, 11, 5, 6, 11, 0, 5, 5, 0, 1, -1, 0, 0, 0,\n    11, 5, 6, 11, 3, 5, 5, 3, 1, -1, 0, 0, 0, 0, 0, 0,\n    10, 1, 2, 5, 6, 11, 5, 11, 9, 9, 11, 8, -1, 0, 0, 0,\n    2, 10, 1, 3, 6, 11, 3, 0, 6, 6, 0, 5, 5, 0, 9, -1,", "    10, 1, 2, 5, 6, 11, 5, 11, 9, 9, 11, 8, -1, 0, 0, 0,\n    2, 10, 1, 3, 6, 11, 3, 0, 6, 6, 0, 5, 5, 0, 9, -1,\n    0, 2, 10, 0, 10, 8, 8, 10, 5, 8, 5, 6, 8, 6, 11, -1,\n    11, 3, 6, 3, 5, 6, 3, 10, 5, 3, 2, 10, -1, 0, 0, 0,\n    2, 3, 6, 6, 9, 5, 3, 9, 6, 3, 8, 9, -1, 0, 0, 0,\n    5, 0, 9, 5, 6, 0, 0, 6, 2, -1, 0, 0, 0, 0, 0, 0,\n    6, 2, 3, 6, 3, 5, 5, 3, 8, 5, 8, 0, 5, 0, 1, -1,\n    6, 2, 1, 6, 1, 5, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    8, 9, 5, 8, 5, 3, 3, 5, 6, 3, 6, 10, 3, 10, 1, -1,\n    1, 0, 10, 0, 6, 10, 0, 5, 6, 0, 9, 5, -1, 0, 0, 0,", "    8, 9, 5, 8, 5, 3, 3, 5, 6, 3, 6, 10, 3, 10, 1, -1,\n    1, 0, 10, 0, 6, 10, 0, 5, 6, 0, 9, 5, -1, 0, 0, 0,\n    0, 3, 8, 10, 5, 6, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    10, 5, 6, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    11, 5, 10, 11, 7, 5, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    5, 11, 7, 5, 10, 11, 3, 0, 8, -1, 0, 0, 0, 0, 0, 0,\n    11, 5, 10, 11, 7, 5, 9, 0, 1, -1, 0, 0, 0, 0, 0, 0,\n    9, 3, 1, 9, 8, 3, 5, 10, 11, 5, 11, 7, -1, 0, 0, 0,\n    2, 11, 7, 2, 7, 1, 1, 7, 5, -1, 0, 0, 0, 0, 0, 0,\n    3, 0, 8, 2, 11, 7, 2, 7, 1, 1, 7, 5, -1, 0, 0, 0,", "    2, 11, 7, 2, 7, 1, 1, 7, 5, -1, 0, 0, 0, 0, 0, 0,\n    3, 0, 8, 2, 11, 7, 2, 7, 1, 1, 7, 5, -1, 0, 0, 0,\n    2, 11, 0, 0, 5, 9, 0, 11, 5, 5, 11, 7, -1, 0, 0, 0,\n    9, 8, 3, 9, 3, 5, 5, 3, 2, 5, 2, 11, 5, 11, 7, -1,\n    10, 2, 3, 10, 3, 5, 5, 3, 7, -1, 0, 0, 0, 0, 0, 0,\n    5, 10, 7, 7, 0, 8, 10, 0, 7, 10, 2, 0, -1, 0, 0, 0,\n    1, 9, 0, 10, 2, 3, 10, 3, 5, 5, 3, 7, -1, 0, 0, 0,\n    7, 5, 10, 7, 10, 8, 8, 10, 2, 8, 2, 1, 8, 1, 9, -1,\n    7, 5, 1, 7, 1, 3, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    8, 1, 0, 8, 7, 1, 1, 7, 5, -1, 0, 0, 0, 0, 0, 0,", "    7, 5, 1, 7, 1, 3, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    8, 1, 0, 8, 7, 1, 1, 7, 5, -1, 0, 0, 0, 0, 0, 0,\n    0, 5, 9, 0, 3, 5, 5, 3, 7, -1, 0, 0, 0, 0, 0, 0,\n    7, 5, 9, 7, 9, 8, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    4, 5, 10, 4, 10, 8, 8, 10, 11, -1, 0, 0, 0, 0, 0, 0,\n    11, 3, 10, 10, 4, 5, 10, 3, 4, 4, 3, 0, -1, 0, 0, 0,\n    9, 0, 1, 4, 5, 10, 4, 10, 8, 8, 10, 11, -1, 0, 0, 0,\n    3, 1, 9, 3, 9, 11, 11, 9, 4, 11, 4, 5, 11, 5, 10, -1,\n    8, 4, 11, 11, 1, 2, 4, 1, 11, 4, 5, 1, -1, 0, 0, 0,\n    5, 1, 2, 5, 2, 4, 4, 2, 11, 4, 11, 3, 4, 3, 0, -1,", "    8, 4, 11, 11, 1, 2, 4, 1, 11, 4, 5, 1, -1, 0, 0, 0,\n    5, 1, 2, 5, 2, 4, 4, 2, 11, 4, 11, 3, 4, 3, 0, -1,\n    11, 8, 4, 11, 4, 2, 2, 4, 5, 2, 5, 9, 2, 9, 0, -1,\n    2, 11, 3, 5, 9, 4, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    4, 5, 10, 4, 10, 2, 4, 2, 8, 8, 2, 3, -1, 0, 0, 0,\n    10, 4, 5, 10, 2, 4, 4, 2, 0, -1, 0, 0, 0, 0, 0, 0,\n    0, 1, 9, 8, 2, 3, 8, 4, 2, 2, 4, 10, 10, 4, 5, -1,\n    10, 2, 5, 2, 4, 5, 2, 9, 4, 2, 1, 9, -1, 0, 0, 0,\n    4, 3, 8, 4, 5, 3, 3, 5, 1, -1, 0, 0, 0, 0, 0, 0,\n    0, 4, 5, 0, 5, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,", "    4, 3, 8, 4, 5, 3, 3, 5, 1, -1, 0, 0, 0, 0, 0, 0,\n    0, 4, 5, 0, 5, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 3, 9, 3, 5, 9, 3, 4, 5, 3, 8, 4, -1, 0, 0, 0,\n    4, 5, 9, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    7, 4, 9, 7, 9, 11, 11, 9, 10, -1, 0, 0, 0, 0, 0, 0,\n    8, 3, 0, 7, 4, 9, 7, 9, 11, 11, 9, 10, -1, 0, 0, 0,\n    0, 1, 4, 4, 11, 7, 1, 11, 4, 1, 10, 11, -1, 0, 0, 0,\n    10, 11, 7, 10, 7, 1, 1, 7, 4, 1, 4, 8, 1, 8, 3, -1,\n    2, 11, 7, 2, 7, 4, 2, 4, 1, 1, 4, 9, -1, 0, 0, 0,\n    0, 8, 3, 1, 4, 9, 1, 2, 4, 4, 2, 7, 7, 2, 11, -1,", "    2, 11, 7, 2, 7, 4, 2, 4, 1, 1, 4, 9, -1, 0, 0, 0,\n    0, 8, 3, 1, 4, 9, 1, 2, 4, 4, 2, 7, 7, 2, 11, -1,\n    7, 2, 11, 7, 4, 2, 2, 4, 0, -1, 0, 0, 0, 0, 0, 0,\n    7, 4, 11, 4, 2, 11, 4, 3, 2, 4, 8, 3, -1, 0, 0, 0,\n    7, 4, 3, 3, 10, 2, 3, 4, 10, 10, 4, 9, -1, 0, 0, 0,\n    2, 0, 8, 2, 8, 10, 10, 8, 7, 10, 7, 4, 10, 4, 9, -1,\n    4, 0, 1, 4, 1, 7, 7, 1, 10, 7, 10, 2, 7, 2, 3, -1,\n    4, 8, 7, 1, 10, 2, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    9, 7, 4, 9, 1, 7, 7, 1, 3, -1, 0, 0, 0, 0, 0, 0,\n    8, 7, 0, 7, 1, 0, 7, 9, 1, 7, 4, 9, -1, 0, 0, 0,", "    9, 7, 4, 9, 1, 7, 7, 1, 3, -1, 0, 0, 0, 0, 0, 0,\n    8, 7, 0, 7, 1, 0, 7, 9, 1, 7, 4, 9, -1, 0, 0, 0,\n    4, 0, 3, 4, 3, 7, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    4, 8, 7, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    8, 9, 10, 8, 10, 11, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 11, 3, 0, 9, 11, 11, 9, 10, -1, 0, 0, 0, 0, 0, 0,\n    1, 8, 0, 1, 10, 8, 8, 10, 11, -1, 0, 0, 0, 0, 0, 0,\n    3, 1, 10, 3, 10, 11, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    2, 9, 1, 2, 11, 9, 9, 11, 8, -1, 0, 0, 0, 0, 0, 0,\n    0, 9, 3, 9, 11, 3, 9, 2, 11, 9, 1, 2, -1, 0, 0, 0,", "    2, 9, 1, 2, 11, 9, 9, 11, 8, -1, 0, 0, 0, 0, 0, 0,\n    0, 9, 3, 9, 11, 3, 9, 2, 11, 9, 1, 2, -1, 0, 0, 0,\n    11, 8, 0, 11, 0, 2, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    2, 11, 3, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    3, 10, 2, 3, 8, 10, 10, 8, 9, -1, 0, 0, 0, 0, 0, 0,\n    9, 10, 2, 9, 2, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    3, 8, 2, 8, 10, 2, 8, 1, 10, 8, 0, 1, -1, 0, 0, 0,\n    2, 1, 10, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    8, 9, 1, 8, 1, 3, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    1, 0, 9, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,", "    8, 9, 1, 8, 1, 3, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    1, 0, 9, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 3, 8, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n]);\n\n"]}
{"filename": "src/wgsl.d.ts", "chunked_list": ["declare module \"*.wgsl\"\n{\n    const content: string;\n    export default content;\n}\n"]}
{"filename": "src/app.ts", "chunked_list": ["import {ArcballCamera} from \"arcball_camera\";\nimport {Controller} from \"ez_canvas_controller\";\nimport {mat4, vec3} from \"gl-matrix\";\n\nimport {Volume, volumes} from \"./volume\";\nimport {MarchingCubes} from \"./marching_cubes\";\nimport renderMeshShaders from \"./render_mesh.wgsl\";\nimport {compileShader, fillSelector} from \"./util\";\n\n(async () =>", "\n(async () =>\n{\n    if (navigator.gpu === undefined) {\n        document.getElementById(\"webgpu-canvas\").setAttribute(\"style\", \"display:none;\");\n        document.getElementById(\"no-webgpu\").setAttribute(\"style\", \"display:block;\");\n        return;\n    }\n\n    // Get a GPU device to render with\n    let adapter = await navigator.gpu.requestAdapter();\n    console.log(adapter.limits);\n\n    let deviceRequiredFeatures: GPUFeatureName[] = [];\n    const timestampSupport = adapter.features.has(\"timestamp-query\");\n    // Enable timestamp queries if the device supports them", "    if (timestampSupport) {\n        deviceRequiredFeatures.push(\"timestamp-query\");\n    } else {\n        console.log(\"Device does not support timestamp queries\");\n    }\n    let deviceDescriptor = {\n        requiredFeatures: deviceRequiredFeatures,\n        requiredLimits: {\n            maxBufferSize: adapter.limits.maxBufferSize,\n            maxStorageBufferBindingSize: adapter.limits.maxStorageBufferBindingSize,\n        }\n    };\n\n    let device = await adapter.requestDevice(deviceDescriptor);\n\n    // Get a context to display our rendered image on the canvas\n    let canvas = document.getElementById(\"webgpu-canvas\") as HTMLCanvasElement;\n    let context = canvas.getContext(\"webgpu\");\n\n    let volumePicker = document.getElementById(\"volumeList\") as HTMLSelectElement;\n    fillSelector(volumePicker, volumes);\n\n    let isovalueSlider = document.getElementById(\"isovalueSlider\") as HTMLInputElement;\n    // Force computing the surface on the initial load\n    let currentIsovalue = -1;\n\n    let perfDisplay = document.getElementById(\"stats\") as HTMLElement;\n    let timestampDisplay = document.getElementById(\"timestamp-stats\") as HTMLElement;\n\n    // Setup shader modules\n    let shaderModule = await compileShader(device, renderMeshShaders, \"renderMeshShaders\");\n", "    if (window.location.hash) {\n        let linkedDataset = decodeURI(window.location.hash.substring(1));\n        if (volumes.has(linkedDataset)) {\n            volumePicker.value = linkedDataset;\n        }\n    }\n\n    let currentVolume = volumePicker.value;\n    let volume = await Volume.load(volumes.get(currentVolume), device);\n    let mc = await MarchingCubes.create(volume, device);\n    let isosurface = null;\n\n    // Vertex attribute state and shader stage\n    let vertexState = {\n        // Shader stage info\n        module: shaderModule,\n        entryPoint: \"vertex_main\",\n        // Vertex buffer info\n        buffers: [{\n            arrayStride: 4 * 4,\n            attributes: [\n                {format: \"float32x4\" as GPUVertexFormat, offset: 0, shaderLocation: 0}\n            ]\n        }]\n    };\n\n    // Setup render outputs\n    let swapChainFormat = \"bgra8unorm\" as GPUTextureFormat;\n    context.configure(\n        {device: device, format: swapChainFormat, usage: GPUTextureUsage.RENDER_ATTACHMENT});\n\n    let depthFormat = \"depth24plus-stencil8\" as GPUTextureFormat;\n    let depthTexture = device.createTexture({\n        size: {width: canvas.width, height: canvas.height, depthOrArrayLayers: 1},\n        format: depthFormat,\n        usage: GPUTextureUsage.RENDER_ATTACHMENT\n    });\n\n    let fragmentState = {\n        // Shader info\n        module: shaderModule,\n        entryPoint: \"fragment_main\",\n        // Output render target info\n        targets: [{format: swapChainFormat}]\n    };\n\n    let bindGroupLayout = device.createBindGroupLayout({\n        entries: [{binding: 0, visibility: GPUShaderStage.VERTEX, buffer: {type: \"uniform\"}}]\n    });\n\n    // Create render pipeline\n    let layout = device.createPipelineLayout({bindGroupLayouts: [bindGroupLayout]});\n\n    let renderPipeline = device.createRenderPipeline({\n        layout: layout,\n        vertex: vertexState,\n        fragment: fragmentState,\n        depthStencil: {format: depthFormat, depthWriteEnabled: true, depthCompare: \"less\"}\n    });\n\n    let renderPassDesc = {\n        colorAttachments: [{\n            view: null as GPUTextureView,\n            loadOp: \"clear\" as GPULoadOp,\n            clearValue: [0.3, 0.3, 0.3, 1],\n            storeOp: \"store\" as GPUStoreOp\n        }],\n        depthStencilAttachment: {\n            view: depthTexture.createView(),\n            depthLoadOp: \"clear\" as GPULoadOp,\n            depthClearValue: 1.0,\n            depthStoreOp: \"store\" as GPUStoreOp,\n            stencilLoadOp: \"clear\" as GPULoadOp,\n            stencilClearValue: 0,\n            stencilStoreOp: \"store\" as GPUStoreOp\n        }\n    };\n\n    let viewParamsBuffer = device.createBuffer({\n        size: (4 * 4 + 4) * 4,\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n        mappedAtCreation: false,\n    });\n\n    let uploadBuffer = device.createBuffer({\n        size: viewParamsBuffer.size,\n        usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC,\n        mappedAtCreation: false,\n    });\n\n    let bindGroup = device.createBindGroup({\n        layout: bindGroupLayout,\n        entries: [{binding: 0, resource: {buffer: viewParamsBuffer}}]\n    });\n\n    // Setup camera and camera controls\n    const defaultEye = vec3.set(vec3.create(), 0.0, 0.0, volume.dims[2] * 0.75);\n    const center = vec3.set(vec3.create(), 0.0, 0.0, 0.5);\n    const up = vec3.set(vec3.create(), 0.0, 1.0, 0.0);\n    let camera = new ArcballCamera(defaultEye, center, up, 2, [canvas.width, canvas.height]);\n    let proj = mat4.perspective(\n        mat4.create(), 50 * Math.PI / 180.0, canvas.width / canvas.height, 0.1, 1000);\n    let projView = mat4.create();\n\n    // Register mouse and touch listeners\n    var controller = new Controller();\n    controller.mousemove = function (prev: Array<number>, cur: Array<number>, evt: MouseEvent)\n    {", "        if (evt.buttons == 1) {\n            camera.rotate(prev, cur);\n\n        } else if (evt.buttons == 2) {\n            camera.pan([cur[0] - prev[0], prev[1] - cur[1]]);\n        }\n    };\n    controller.wheel = function (amt: number)\n    {\n        camera.zoom(amt);\n    };\n    controller.pinch = controller.wheel;\n    controller.twoFingerDrag = function (drag: number)\n    {\n        camera.pan(drag);\n    };\n    controller.registerForCanvas(canvas);\n\n    let animationFrame = function ()\n    {\n        let resolve = null;\n        let promise = new Promise(r => resolve = r);\n        window.requestAnimationFrame(resolve);\n        return promise\n    };\n    requestAnimationFrame(animationFrame);\n\n    // Render!", "    while (true) {\n        await animationFrame();\n        if (document.hidden) {\n            continue;\n        }\n\n        let sliderValue = parseFloat(isovalueSlider.value) / 255.0;\n        let recomputeSurface = sliderValue != currentIsovalue;\n\n        // When a new volume is selected, recompute the surface and reposition the camera\n        if (volumePicker.value != currentVolume) {", "        if (volumePicker.value != currentVolume) {\n            if (isosurface.buffer) {\n                isosurface.buffer.destroy();\n            }\n            currentVolume = volumePicker.value;\n            history.replaceState(history.state, \"#\" + currentVolume, \"#\" + currentVolume);\n\n            volume = await Volume.load(volumes.get(currentVolume), device);\n            mc = await MarchingCubes.create(volume, device);\n            isovalueSlider.value = \"128\";\n            sliderValue = parseFloat(isovalueSlider.value) / 255.0;\n            recomputeSurface = true;\n\n            const defaultEye = vec3.set(vec3.create(), 0.0, 0.0, volume.dims[2] * 0.75);\n            camera = new ArcballCamera(defaultEye, center, up, 2, [canvas.width, canvas.height]);\n        }\n", "        if (recomputeSurface) {\n            if (isosurface && isosurface.buffer) {\n                isosurface.buffer.destroy();\n            }\n\n            currentIsovalue = sliderValue;\n            let start = performance.now();\n            isosurface = await mc.computeSurface(currentIsovalue);\n            let end = performance.now();\n\n            perfDisplay.innerHTML =\n                `<p>Compute Time: ${(end - start).toFixed((2))}ms<br/># Triangles: ${isosurface.count / 3}</p>`\n\n            timestampDisplay.innerHTML =\n                `<h4>Timing Breakdown</h4>\n                    <p>Note: if timestamp-query is not supported, -1 is shown for kernel times</p>\n\n                    Compute Active Voxels: ${mc.computeActiveVoxelsTime.toFixed(2)}ms\n                    <ul>\n                    <li>\n                    Mark Active Voxels Kernel: ${mc.markActiveVoxelsKernelTime.toFixed(2)}ms\n                    </li>\n                    <li>\n                    Exclusive Scan: ${mc.computeActiveVoxelsScanTime.toFixed(2)}ms\n                    </li>\n                    <li>\n                    Stream Compact: ${mc.computeActiveVoxelsCompactTime.toFixed(2)}ms\n                    </li>\n                    </ul>\n\n                    Compute Vertex Offsets: ${mc.computeVertexOffsetsTime.toFixed(2)}ms\n                    <ul>\n                    <li>\n                    Compute # of Vertices Kernel: ${mc.computeNumVertsKernelTime.toFixed(2)}ms\n                    </li>\n                    <li>\n                    Exclusive Scan: ${mc.computeVertexOffsetsScanTime.toFixed(2)}ms\n                    </li>\n                    </ul>\n\n                    Compute Vertices: ${mc.computeVerticesTime.toFixed(2)}ms\n                    <ul>\n                    <li>\n                    Compute Vertices Kernel: ${mc.computeVerticesKernelTime.toFixed(2)}ms\n                    </li>\n                    </ul>`;\n        }\n\n        projView = mat4.mul(projView, proj, camera.camera);\n        {\n            await uploadBuffer.mapAsync(GPUMapMode.WRITE);\n            let map = uploadBuffer.getMappedRange();\n            new Float32Array(map).set(projView);\n            new Uint32Array(map, 16 * 4, 4).set(volume.dims);\n            uploadBuffer.unmap();\n        }\n\n        renderPassDesc.colorAttachments[0].view = context.getCurrentTexture().createView();\n\n        let commandEncoder = device.createCommandEncoder();\n\n        commandEncoder.copyBufferToBuffer(\n            uploadBuffer, 0, viewParamsBuffer, 0, viewParamsBuffer.size);\n\n        let renderPass = commandEncoder.beginRenderPass(renderPassDesc);\n", "        if (isosurface.count > 0) {\n            renderPass.setBindGroup(0, bindGroup);\n            renderPass.setPipeline(renderPipeline);\n            renderPass.setVertexBuffer(0, isosurface.buffer);\n            renderPass.draw(isosurface.count, 1, 0, 0);\n        }\n\n        renderPass.end();\n        device.queue.submit([commandEncoder.finish()]);\n    }\n})();\n"]}
{"filename": "src/arcball_camera.d.ts", "chunked_list": ["// TODO: typescript type bindings for this repo\ndeclare module \"arcball_camera\";\n"]}
{"filename": "src/volume.ts", "chunked_list": ["import {alignTo} from \"./util\";\n\nexport const volumes = new Map<string, string>([\n    [\"Fuel\", \"fuel_64x64x64_uint8.raw\"],\n    [\"Neghip\", \"neghip_64x64x64_uint8.raw\"],\n    [\"Hydrogen Atom\", \"hydrogen_atom_128x128x128_uint8.raw\"],\n    [\"Bonsai\", \"bonsai_256x256x256_uint8.raw\"],\n    [\"Foot\", \"foot_256x256x256_uint8.raw\"],\n    [\"Skull\", \"skull_256x256x256_uint8.raw\"],\n    [\"Aneurysm\", \"aneurism_256x256x256_uint8.raw\"]", "    [\"Skull\", \"skull_256x256x256_uint8.raw\"],\n    [\"Aneurysm\", \"aneurism_256x256x256_uint8.raw\"]\n]);\n\nexport enum VoxelType\n{\n    UINT8,\n    UINT16,\n    UINT32,\n    FLOAT32\n};\n", "export function parseVoxelType(str: string)\n{\n    if (str == \"uint8\") {\n        return VoxelType.UINT8;\n    }\n    if (str == \"uint16\") {\n        return VoxelType.UINT16;\n    }\n    if (str == \"UINT32\") {\n        return VoxelType.UINT32;\n    }", "    if (str == \"UINT32\") {\n        return VoxelType.UINT32;\n    }\n    if (str == \"FLOAT32\") {\n        return VoxelType.FLOAT32;\n    }\n    throw Error(`Unsupported/invalid voxel type string ${str}`);\n}\n\nexport function voxelTypeSize(ty: VoxelType)\n{\n    switch (ty) {\n        case VoxelType.UINT8:\n            return 1;\n        case VoxelType.UINT16:\n            return 2;\n        case VoxelType.UINT32:\n        case VoxelType.FLOAT32:\n            return 4;\n    }\n}\n", "export function voxelTypeSize(ty: VoxelType)\n{\n    switch (ty) {\n        case VoxelType.UINT8:\n            return 1;\n        case VoxelType.UINT16:\n            return 2;\n        case VoxelType.UINT32:\n        case VoxelType.FLOAT32:\n            return 4;\n    }\n}\n", "export function voxelTypeToTextureType(ty: VoxelType)\n{\n    switch (ty) {\n        case VoxelType.UINT8:\n            // TODO: should use the non-normalized types later\n            return \"r8unorm\";\n        case VoxelType.UINT16:\n            return \"r16uint\";\n        case VoxelType.UINT32:\n            return \"r32uint\";\n        case VoxelType.FLOAT32:\n            return \"r32float\";\n    }\n}\n", "export class Volume\n{\n    readonly #dimensions: Array<number>;\n\n    readonly #dataType: VoxelType;\n\n    readonly #file: string;\n\n    #data: Uint8Array;\n\n    #texture: GPUTexture;\n\n    private constructor(file: string)\n    {\n        let fileRegex = /(\\w+)_(\\d+)x(\\d+)x(\\d+)_(\\w+)\\.*/;\n        let m = file.match(fileRegex);\n\n        this.#dimensions = [parseInt(m[2]), parseInt(m[3]), parseInt(m[4])];\n        this.#dataType = parseVoxelType(m[5]);\n        this.#file = file;\n    }\n\n    static async load(file: string, device: GPUDevice)\n    {\n        let volume = new Volume(file);\n        await volume.fetch();\n        await volume.upload(device);\n        return volume;\n    }\n\n    async upload(device: GPUDevice)\n    {\n        this.#texture = device.createTexture({\n            size: this.#dimensions,\n            format: voxelTypeToTextureType(this.#dataType),\n            dimension: \"3d\",\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST\n        });\n\n        // TODO: might need to chunk the upload to support very large volumes?\n        // I had some note about hitting some timeout or hang issues with 512^3 in the past?\n        let uploadBuf = device.createBuffer(\n            {size: this.#data.byteLength, usage: GPUBufferUsage.COPY_SRC, mappedAtCreation: true});\n        new Uint8Array(uploadBuf.getMappedRange()).set(this.#data);\n        uploadBuf.unmap();\n\n        let commandEncoder = device.createCommandEncoder();\n\n        let src = {\n            buffer: uploadBuf,\n            // Volumes must be aligned to 256 bytes per row, fetchVolume does this padding\n            bytesPerRow: alignTo(this.#dimensions[0] * voxelTypeSize(this.#dataType), 256),\n            rowsPerImage: this.#dimensions[1]\n        };\n        let dst = {texture: this.#texture};\n        commandEncoder.copyBufferToTexture(src, dst, this.#dimensions);\n\n        device.queue.submit([commandEncoder.finish()]);\n        await device.queue.onSubmittedWorkDone();\n    }\n\n    get dims()\n    {\n        return this.#dimensions;\n    }\n\n    get dualGridDims()\n    {\n        return [this.#dimensions[0] - 1, this.#dimensions[1] - 1, this.#dimensions[2] - 1];\n    }\n\n    get voxelType()\n    {\n        return this.#dataType;\n    }\n\n    get texture()\n    {\n        return this.#texture;\n    }\n\n    get numVoxels()\n    {\n        return this.#dimensions[0] * this.#dimensions[1] * this.#dimensions[2];\n    }\n\n    get dualGridNumVoxels()\n    {\n        return (this.#dimensions[0] - 1) * (this.#dimensions[1] - 1) * (this.#dimensions[2] - 1);\n    }\n\n    private pad(buf: Uint8Array)\n    {\n        const voxelSize = voxelTypeSize(this.#dataType);\n\n        const paddedByteDims = [\n            alignTo(this.#dimensions[0] * voxelSize, 256),\n            this.#dimensions[1] * voxelSize,\n            this.#dimensions[2] * voxelSize\n        ];\n        let padded =\n            new Uint8Array(paddedByteDims[0] * paddedByteDims[1] * paddedByteDims[2]);\n\n        // Copy each row into the padded volume buffer\n        const nrows = this.#dimensions[1] * this.#dimensions[2];", "        for (let i = 0; i < nrows; ++i) {\n            let inrow = buf.subarray(i * this.#dimensions[0] * voxelSize,\n                i * this.#dimensions[0] * voxelSize + this.#dimensions[0] * voxelSize);\n            padded.set(inrow, i * paddedByteDims[0]);\n        }\n        return padded;\n    }\n\n    private async fetch()\n    {\n        const voxelSize = voxelTypeSize(this.#dataType);\n\n        const volumeSize = this.#dimensions[0] * this.#dimensions[1]\n            * this.#dimensions[2] * voxelSize;\n\n        let loadingProgressText = document.getElementById(\"loadingText\");\n        let loadingProgressBar = document.getElementById(\"loadingProgressBar\");\n        loadingProgressText.innerHTML = \"Loading Volume...\";\n        loadingProgressBar.setAttribute(\"style\", \"width: 0%\");\n\n        let url = \"https://cdn.willusher.io/demo-volumes/\" + this.#file;", "        try {\n            let response = await fetch(url);\n            let reader = response.body.getReader();\n\n            let receivedSize = 0;\n            let buf = new Uint8Array(volumeSize);\n            while (true) {\n                let {done, value} = await reader.read();\n                if (done) {\n                    break;\n                }\n                buf.set(value, receivedSize);\n                receivedSize += value.length;\n                let percentLoaded = receivedSize / volumeSize * 100;\n                loadingProgressBar.setAttribute(\"style\",\n                    `width: ${percentLoaded.toFixed(2)}%`);\n            }\n            loadingProgressText.innerHTML = \"Volume Loaded\";\n\n            // WebGPU requires that bytes per row = 256, so we need to pad volumes\n            // that are smaller than this", "                if (done) {\n                    break;\n                }\n                buf.set(value, receivedSize);\n                receivedSize += value.length;\n                let percentLoaded = receivedSize / volumeSize * 100;\n                loadingProgressBar.setAttribute(\"style\",\n                    `width: ${percentLoaded.toFixed(2)}%`);\n            }\n            loadingProgressText.innerHTML = \"Volume Loaded\";\n\n            // WebGPU requires that bytes per row = 256, so we need to pad volumes\n            // that are smaller than this", "            if ((this.#dimensions[0] * voxelSize) % 256 != 0) {\n                this.#data = this.pad(buf);\n            } else {\n                this.#data = buf;\n            }\n        } catch (err) {\n            loadingProgressText.innerHTML = \"Error loading volume\";\n            throw Error(`Error loading volume data ${err}`);\n        }\n    }\n};\n"]}
{"filename": "src/push_constant_builder.ts", "chunked_list": ["import {alignTo} from \"./util\";\n\n// Generate the work group ID offset buffer and the dynamic offset buffer to use for chunking\n// up a large compute dispatch. The start of the push constants data will be:\n// {\n//      u32: work group id offset\n//      u32: totalWorkGroups\n//      ...: optional additional data (if any)\n// }\nexport class PushConstants\n{\n    // The GPU buffer containing the push constant data, to be used\n    // as a uniform buffer with a dynamic offset\n    pushConstantsBuffer: GPUBuffer;\n    // Stride in bytes between push constants\n    // will be a multiple of device.minUniformBufferOffsetAlignment\n    stride: number;\n    // The total number of work groups that were chunked up into smaller\n    // dispatches for this set of push constants\n    totalWorkGroups: number;\n\n    #maxWorkgroupsPerDimension: number;\n\n    constructor(device: GPUDevice, totalWorkGroups: number, appPushConstants?: ArrayBuffer)\n    {\n        this.#maxWorkgroupsPerDimension = device.limits.maxComputeWorkgroupsPerDimension;\n        this.totalWorkGroups = totalWorkGroups;\n\n        let nDispatches =\n            Math.ceil(totalWorkGroups / device.limits.maxComputeWorkgroupsPerDimension);\n\n        // Determine if we have some additional push constant data and align the push constant\n        // stride accordingly\n        this.stride = device.limits.minUniformBufferOffsetAlignment;\n        let appPushConstantsView = null;", "// }\nexport class PushConstants\n{\n    // The GPU buffer containing the push constant data, to be used\n    // as a uniform buffer with a dynamic offset\n    pushConstantsBuffer: GPUBuffer;\n    // Stride in bytes between push constants\n    // will be a multiple of device.minUniformBufferOffsetAlignment\n    stride: number;\n    // The total number of work groups that were chunked up into smaller\n    // dispatches for this set of push constants\n    totalWorkGroups: number;\n\n    #maxWorkgroupsPerDimension: number;\n\n    constructor(device: GPUDevice, totalWorkGroups: number, appPushConstants?: ArrayBuffer)\n    {\n        this.#maxWorkgroupsPerDimension = device.limits.maxComputeWorkgroupsPerDimension;\n        this.totalWorkGroups = totalWorkGroups;\n\n        let nDispatches =\n            Math.ceil(totalWorkGroups / device.limits.maxComputeWorkgroupsPerDimension);\n\n        // Determine if we have some additional push constant data and align the push constant\n        // stride accordingly\n        this.stride = device.limits.minUniformBufferOffsetAlignment;\n        let appPushConstantsView = null;", "        if (appPushConstants) {\n            this.stride = alignTo(8 + appPushConstants.byteLength,\n                device.limits.minUniformBufferOffsetAlignment);\n            appPushConstantsView = new Uint8Array(appPushConstants);\n        }\n\n        if (this.stride * nDispatches > device.limits.maxUniformBufferBindingSize) {\n            console.log(\"Error! PushConstants uniform buffer is too big for a uniform buffer\");\n            throw Error(\"PushConstants uniform buffer is too big for a uniform buffer\");\n        }\n\n        this.pushConstantsBuffer = device.createBuffer({\n            size: this.stride * nDispatches,\n            usage: GPUBufferUsage.UNIFORM,\n            mappedAtCreation: true,\n        });\n\n        let mapping = this.pushConstantsBuffer.getMappedRange();", "        for (let i = 0; i < nDispatches; ++i) {\n            // Write the work group offset push constants data\n            let u32view = new Uint32Array(mapping, i * this.stride, 2);\n            u32view[0] = device.limits.maxComputeWorkgroupsPerDimension * i;\n            u32view[1] = totalWorkGroups;\n\n            // Copy in any additional push constants data if provided\n            if (appPushConstantsView) {\n                var u8view =\n                    new Uint8Array(mapping, i * this.stride + 8, appPushConstants.byteLength);\n                u8view.set(appPushConstantsView);\n            }\n        }\n        this.pushConstantsBuffer.unmap();\n    }\n\n    // Get the total number of dispatches that must be performed to run the total set\n    // of workgroups, obeying the maxComputeWorkgroupsPerDimension restriction of the device.\n    numDispatches()\n    {\n        return this.pushConstantsBuffer.size / this.stride;\n    }\n\n    // Get the offset to use for the pushConstants for a given dispatch index\n    pushConstantsOffset(dispatchIndex: number)\n    {\n        return this.stride * dispatchIndex;\n    }\n\n    // Get the number of workgroups to launch for the given dispatch index\n    dispatchSize(dispatchIndex: number)\n    {\n        let remainder = this.totalWorkGroups % this.#maxWorkgroupsPerDimension;", "        if (remainder == 0 || dispatchIndex + 1 < this.numDispatches()) {\n            return this.#maxWorkgroupsPerDimension;\n        }\n        return remainder;\n    }\n};\n"]}
{"filename": "src/util.ts", "chunked_list": ["export function alignTo(val: number, align: number)\n{\n    return Math.floor((val + align - 1) / align) * align;\n};\n\n// Compute the shader and print any error log\nexport async function compileShader(device: GPUDevice, src: string, debugLabel?: string)\n{\n    let shaderModule = device.createShaderModule({code: src});\n    let compilationInfo = await shaderModule.getCompilationInfo();\n    if (compilationInfo.messages.length > 0) {\n        let hadError = false;", "    if (compilationInfo.messages.length > 0) {\n        let hadError = false;\n        if (debugLabel) {\n            console.log(`Shader compilation log for ${debugLabel}:`);\n        } else {\n            console.log(`Shader compilation log:`);\n        }\n        let lines = src.split(\"\\n\");\n        for (let i = 0; i < compilationInfo.messages.length; ++i) {\n            let msg = compilationInfo.messages[i];\n            console.log(`${msg.lineNum}:${msg.linePos} - ${msg.message}`);\n            // TODO: Could use length/offset here but they seem to always be 0?\n            // Same for linepos, but the error in the console has a valid linepos.\n            // it seems to be lost?\n            console.log(`    ${lines[msg.lineNum - 1]}`);\n            hadError = hadError || msg.type == \"error\";\n        }", "        for (let i = 0; i < compilationInfo.messages.length; ++i) {\n            let msg = compilationInfo.messages[i];\n            console.log(`${msg.lineNum}:${msg.linePos} - ${msg.message}`);\n            // TODO: Could use length/offset here but they seem to always be 0?\n            // Same for linepos, but the error in the console has a valid linepos.\n            // it seems to be lost?\n            console.log(`    ${lines[msg.lineNum - 1]}`);\n            hadError = hadError || msg.type == \"error\";\n        }\n        if (hadError) {\n            console.log(\"Shader failed to compile\");\n            throw Error(\"Shader failed to compile\");\n        }\n    }\n    return shaderModule;\n}\n", "        if (hadError) {\n            console.log(\"Shader failed to compile\");\n            throw Error(\"Shader failed to compile\");\n        }\n    }\n    return shaderModule;\n}\n\nexport function fillSelector(selector: HTMLSelectElement, dict: Map<string, string>)\n{\n    for (let v of dict.keys()) {\n        let opt = document.createElement(\"option\") as HTMLOptionElement;\n        opt.value = v;\n        opt.innerHTML = v;\n        selector.appendChild(opt);\n    }\n}\n", "export function fillSelector(selector: HTMLSelectElement, dict: Map<string, string>)\n{\n    for (let v of dict.keys()) {\n        let opt = document.createElement(\"option\") as HTMLOptionElement;\n        opt.value = v;\n        opt.innerHTML = v;\n        selector.appendChild(opt);\n    }\n}\n"]}
{"filename": "src/exclusive_scan.ts", "chunked_list": ["import addBlockSums from \"./exclusive_scan_add_block_sums.wgsl\";\nimport prefixSum from \"./exclusive_scan_prefix_sum.wgsl\";\nimport prefixSumBlocks from \"./exclusive_scan_prefix_sum_blocks.wgsl\";\nimport {alignTo, compileShader} from \"./util\";\n\n// Note: This also means the min size we can scan is 128 elements\nconst SCAN_BLOCK_SIZE = 512;\n\n// Serial scan for validation\nexport function serialExclusiveScan(array: Uint32Array, output: Uint32Array)\n{\n    output[0] = 0;", "// Serial scan for validation\nexport function serialExclusiveScan(array: Uint32Array, output: Uint32Array)\n{\n    output[0] = 0;\n    for (let i = 1; i < array.length; ++i) {\n        output[i] = array[i - 1] + output[i - 1];\n    }\n    return output[array.length - 1] + array[array.length - 1];\n}\n\nexport class ExclusiveScan\n{\n    #device: GPUDevice;\n\n    // The max # of elements that can be scanned without carry in/out\n    readonly #maxScanSize = SCAN_BLOCK_SIZE * SCAN_BLOCK_SIZE;\n\n    // Pipeline for scanning the individual blocks of ScanBlockSize elements\n    #scanBlocksPipeline: GPUComputePipeline;\n\n    // Pipeline for scanning the block scan results which will then be added back to\n    // the individual block scan results\n    #scanBlockResultsPipeline: GPUComputePipeline;\n\n    // Pipeline that adds the block scan results back to each individual block so\n    // that its scan result is globally correct based on the elements preceeding the block\n    #addBlockSumsPipeline: GPUComputePipeline;\n\n    private constructor(device: GPUDevice)\n    {\n        this.#device = device;\n    }\n\n    static async create(device: GPUDevice)\n    {\n        let self = new ExclusiveScan(device);\n\n        let scanAddBGLayout = device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {type: \"storage\", hasDynamicOffset: true}\n                },\n                {\n                    binding: 1,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: \"storage\",\n                    }\n                },\n            ],\n        });\n\n        let scanBlockBGLayout = device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: \"storage\",\n                    }\n                },\n                {\n                    binding: 1,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: \"storage\",\n                    }\n                },\n            ],\n        });\n\n        self.#scanBlocksPipeline = device.createComputePipeline({\n            layout: device.createPipelineLayout({\n                bindGroupLayouts: [scanAddBGLayout],\n            }),\n            compute: {\n                module: await compileShader(device, prefixSum, \"ExclusiveScan::prefixSum\"),\n                entryPoint: \"main\",\n                constants: {\"0\": SCAN_BLOCK_SIZE}\n            }\n        });\n\n        self.#scanBlockResultsPipeline = device.createComputePipeline({\n            layout: device.createPipelineLayout({\n                bindGroupLayouts: [scanBlockBGLayout],\n            }),\n            compute: {\n                module: await compileShader(\n                    device, prefixSumBlocks, \"ExclusiveScan::prefixSumBlocks\"),\n                entryPoint: \"main\",\n                constants: {\"0\": SCAN_BLOCK_SIZE}\n            }\n        });\n\n        self.#addBlockSumsPipeline = device.createComputePipeline({\n            layout: device.createPipelineLayout({\n                bindGroupLayouts: [scanAddBGLayout],\n            }),\n            compute: {\n                module:\n                    await compileShader(device, addBlockSums, \"ExclusiveScan::addBlockSums\"),\n                entryPoint: \"main\",\n                constants: {\"0\": SCAN_BLOCK_SIZE}\n            }\n        });\n        return self;\n    }\n\n    getAlignedSize(size: number)\n    {\n        return alignTo(size, SCAN_BLOCK_SIZE);\n    }\n\n    async scan(buffer: GPUBuffer, size: number)\n    {\n        const bufferTotalSize = buffer.size / 4;", "export class ExclusiveScan\n{\n    #device: GPUDevice;\n\n    // The max # of elements that can be scanned without carry in/out\n    readonly #maxScanSize = SCAN_BLOCK_SIZE * SCAN_BLOCK_SIZE;\n\n    // Pipeline for scanning the individual blocks of ScanBlockSize elements\n    #scanBlocksPipeline: GPUComputePipeline;\n\n    // Pipeline for scanning the block scan results which will then be added back to\n    // the individual block scan results\n    #scanBlockResultsPipeline: GPUComputePipeline;\n\n    // Pipeline that adds the block scan results back to each individual block so\n    // that its scan result is globally correct based on the elements preceeding the block\n    #addBlockSumsPipeline: GPUComputePipeline;\n\n    private constructor(device: GPUDevice)\n    {\n        this.#device = device;\n    }\n\n    static async create(device: GPUDevice)\n    {\n        let self = new ExclusiveScan(device);\n\n        let scanAddBGLayout = device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {type: \"storage\", hasDynamicOffset: true}\n                },\n                {\n                    binding: 1,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: \"storage\",\n                    }\n                },\n            ],\n        });\n\n        let scanBlockBGLayout = device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: \"storage\",\n                    }\n                },\n                {\n                    binding: 1,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: \"storage\",\n                    }\n                },\n            ],\n        });\n\n        self.#scanBlocksPipeline = device.createComputePipeline({\n            layout: device.createPipelineLayout({\n                bindGroupLayouts: [scanAddBGLayout],\n            }),\n            compute: {\n                module: await compileShader(device, prefixSum, \"ExclusiveScan::prefixSum\"),\n                entryPoint: \"main\",\n                constants: {\"0\": SCAN_BLOCK_SIZE}\n            }\n        });\n\n        self.#scanBlockResultsPipeline = device.createComputePipeline({\n            layout: device.createPipelineLayout({\n                bindGroupLayouts: [scanBlockBGLayout],\n            }),\n            compute: {\n                module: await compileShader(\n                    device, prefixSumBlocks, \"ExclusiveScan::prefixSumBlocks\"),\n                entryPoint: \"main\",\n                constants: {\"0\": SCAN_BLOCK_SIZE}\n            }\n        });\n\n        self.#addBlockSumsPipeline = device.createComputePipeline({\n            layout: device.createPipelineLayout({\n                bindGroupLayouts: [scanAddBGLayout],\n            }),\n            compute: {\n                module:\n                    await compileShader(device, addBlockSums, \"ExclusiveScan::addBlockSums\"),\n                entryPoint: \"main\",\n                constants: {\"0\": SCAN_BLOCK_SIZE}\n            }\n        });\n        return self;\n    }\n\n    getAlignedSize(size: number)\n    {\n        return alignTo(size, SCAN_BLOCK_SIZE);\n    }\n\n    async scan(buffer: GPUBuffer, size: number)\n    {\n        const bufferTotalSize = buffer.size / 4;", "        if (bufferTotalSize != this.getAlignedSize(bufferTotalSize)) {\n            throw Error(`Error: GPU input buffer size (${bufferTotalSize}) must be aligned to ExclusiveScan::getAlignedSize, expected ${this.getAlignedSize(bufferTotalSize)}`)\n        }\n\n        let readbackBuf = this.#device.createBuffer({\n            size: 4,\n            usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n        });\n\n        let blockSumBuf = this.#device.createBuffer({\n            size: SCAN_BLOCK_SIZE * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n        });\n\n        let carryBuf = this.#device.createBuffer({\n            size: 8,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n        })\n        let carryIntermediateBuf = this.#device.createBuffer({\n            size: 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n        })\n\n        let scanBlockResultsBG = this.#device.createBindGroup({\n            layout: this.#scanBlockResultsPipeline.getBindGroupLayout(0),\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: blockSumBuf,\n                    },\n                },\n                {\n                    binding: 1,\n                    resource: {\n                        buffer: carryBuf,\n                    },\n                },\n            ],\n        });\n\n        const numChunks = Math.ceil(size / this.#maxScanSize);\n\n        let scanBlocksBG = null;\n        let scanRemainderBlocksBG = null;", "        if (numChunks > 1) {\n            scanBlocksBG = this.#device.createBindGroup({\n                layout: this.#scanBlocksPipeline.getBindGroupLayout(0),\n                entries: [\n                    {\n                        binding: 0,\n                        resource: {\n                            buffer: buffer,\n                            size: this.#maxScanSize * 4,\n                        }\n                    },\n                    {\n                        binding: 1,\n                        resource: {\n                            buffer: blockSumBuf,\n                        },\n                    },\n                ],\n            });\n", "            if (bufferTotalSize % this.#maxScanSize != 0) {\n                scanRemainderBlocksBG = this.#device.createBindGroup({\n                    layout: this.#scanBlocksPipeline.getBindGroupLayout(0),\n                    entries: [\n                        {\n                            binding: 0,\n                            resource: {\n                                buffer: buffer,\n                                size: (bufferTotalSize % this.#maxScanSize) * 4,\n                            }\n                        },\n                        {\n                            binding: 1,\n                            resource: {\n                                buffer: blockSumBuf,\n                            },\n                        },\n                    ],\n                });\n            } else {\n                scanRemainderBlocksBG = scanBlocksBG;\n            }\n        } else {\n            scanBlocksBG = this.#device.createBindGroup({\n                layout: this.#scanBlocksPipeline.getBindGroupLayout(0),\n                entries: [\n                    {\n                        binding: 0,\n                        resource: {\n                            buffer: buffer,\n                            size: Math.min(this.#maxScanSize, bufferTotalSize) * 4,\n                        }\n                    },\n                    {\n                        binding: 1,\n                        resource: {\n                            buffer: blockSumBuf,\n                        },\n                    },\n                ],\n            });\n            scanRemainderBlocksBG = scanBlocksBG;\n        }\n\n        let commandEncoder = this.#device.createCommandEncoder();\n        commandEncoder.clearBuffer(blockSumBuf);\n        commandEncoder.clearBuffer(carryBuf);\n        // If the size being scanned is less than the buffer size, clear the end of it\n        // so we don't pull down invalid values", "        if (size < bufferTotalSize) {\n            // TODO: Later the scan should support not reading these values by doing proper\n            // range checking so that we don't have to touch regions of the buffer you don't\n            // tell us to\n            commandEncoder.clearBuffer(buffer, size * 4, 4);\n        }\n\n        // Record the scan commands\n        for (let i = 0; i < numChunks; ++i) {\n            let currentScanBlocksBG = scanBlocksBG;\n            if (i + 1 == numChunks) {\n                currentScanBlocksBG = scanRemainderBlocksBG;\n            }\n\n            let nWorkGroups = Math.min(\n                (bufferTotalSize - i * this.#maxScanSize) / SCAN_BLOCK_SIZE, SCAN_BLOCK_SIZE);\n\n            // Clear the previous block sums\n            commandEncoder.clearBuffer(blockSumBuf);\n\n            let computePass = commandEncoder.beginComputePass();\n\n            computePass.setPipeline(this.#scanBlocksPipeline);\n            computePass.setBindGroup(0, currentScanBlocksBG, [i * this.#maxScanSize * 4]);\n            computePass.dispatchWorkgroups(nWorkGroups, 1, 1);\n\n            computePass.setPipeline(this.#scanBlockResultsPipeline);\n            computePass.setBindGroup(0, scanBlockResultsBG);\n            computePass.dispatchWorkgroups(1, 1, 1);\n\n            computePass.setPipeline(this.#addBlockSumsPipeline);\n            computePass.setBindGroup(0, currentScanBlocksBG, [i * this.#maxScanSize * 4]);\n            computePass.dispatchWorkgroups(nWorkGroups, 1, 1);\n\n            computePass.end();\n\n            // Update the carry in value for the next chunk, copy carry out to carry in\n            commandEncoder.copyBufferToBuffer(carryBuf, 4, carryIntermediateBuf, 0, 4);\n            commandEncoder.copyBufferToBuffer(carryIntermediateBuf, 0, carryBuf, 0, 4);\n        }\n\n        // Copy the final scan result back to the readback buffer", "        for (let i = 0; i < numChunks; ++i) {\n            let currentScanBlocksBG = scanBlocksBG;\n            if (i + 1 == numChunks) {\n                currentScanBlocksBG = scanRemainderBlocksBG;\n            }\n\n            let nWorkGroups = Math.min(\n                (bufferTotalSize - i * this.#maxScanSize) / SCAN_BLOCK_SIZE, SCAN_BLOCK_SIZE);\n\n            // Clear the previous block sums\n            commandEncoder.clearBuffer(blockSumBuf);\n\n            let computePass = commandEncoder.beginComputePass();\n\n            computePass.setPipeline(this.#scanBlocksPipeline);\n            computePass.setBindGroup(0, currentScanBlocksBG, [i * this.#maxScanSize * 4]);\n            computePass.dispatchWorkgroups(nWorkGroups, 1, 1);\n\n            computePass.setPipeline(this.#scanBlockResultsPipeline);\n            computePass.setBindGroup(0, scanBlockResultsBG);\n            computePass.dispatchWorkgroups(1, 1, 1);\n\n            computePass.setPipeline(this.#addBlockSumsPipeline);\n            computePass.setBindGroup(0, currentScanBlocksBG, [i * this.#maxScanSize * 4]);\n            computePass.dispatchWorkgroups(nWorkGroups, 1, 1);\n\n            computePass.end();\n\n            // Update the carry in value for the next chunk, copy carry out to carry in\n            commandEncoder.copyBufferToBuffer(carryBuf, 4, carryIntermediateBuf, 0, 4);\n            commandEncoder.copyBufferToBuffer(carryIntermediateBuf, 0, carryBuf, 0, 4);\n        }\n\n        // Copy the final scan result back to the readback buffer", "        if (size < bufferTotalSize) {\n            commandEncoder.copyBufferToBuffer(buffer, size * 4, readbackBuf, 0, 4);\n        } else {\n            commandEncoder.copyBufferToBuffer(carryBuf, 4, readbackBuf, 0, 4);\n        }\n\n        this.#device.queue.submit([commandEncoder.finish()]);\n        await this.#device.queue.onSubmittedWorkDone();\n\n        await readbackBuf.mapAsync(GPUMapMode.READ);\n        let mapping = new Uint32Array(readbackBuf.getMappedRange());\n        let sum = mapping[0];\n        readbackBuf.unmap();\n\n        return sum;\n    }\n};\n"]}
{"filename": "src/ez_canvas_controller.d.ts", "chunked_list": ["// TODO: typescript type bindings for this repo\ndeclare module \"ez_canvas_controller\";\n"]}
{"filename": "src/stream_compact_ids.ts", "chunked_list": ["import {PushConstants} from \"./push_constant_builder\";\nimport streamCompactIDs from \"./stream_compact_ids.wgsl\";\nimport {compileShader} from \"./util\";\n\n// Serial version for validation\nexport function serialStreamCompactIDs(\n    isActiveBuffer: Uint32Array, offsetBuffer: Uint32Array, idOutputBuffer: Uint32Array)\n{\n    for (let i = 0; i < isActiveBuffer.length; ++i) {\n        if (isActiveBuffer[i] != 0) {\n            idOutputBuffer[offsetBuffer[i]] = i;\n        }\n    }\n}\n", "    for (let i = 0; i < isActiveBuffer.length; ++i) {\n        if (isActiveBuffer[i] != 0) {\n            idOutputBuffer[offsetBuffer[i]] = i;\n        }\n    }\n}\n\nexport class StreamCompactIDs\n{\n    #device: GPUDevice;\n\n    // Should be at least 64 so that we process elements\n    // in 256b blocks with each WG. This will ensure that our\n    // dynamic offsets meet the 256b alignment requirement\n    readonly WORKGROUP_SIZE: number = 64;\n\n    readonly #maxDispatchSize: number;\n\n    #computePipeline: GPUComputePipeline;\n\n    private constructor(device: GPUDevice)\n    {\n        this.#device = device;\n\n        this.#maxDispatchSize = device.limits.maxComputeWorkgroupsPerDimension;\n    }\n\n    static async create(device: GPUDevice)\n    {\n        let self = new StreamCompactIDs(device);\n\n        let paramsBGLayout = device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: \"storage\",\n                        hasDynamicOffset: true,\n                    }\n                },\n                {\n                    binding: 1,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: \"storage\",\n                        hasDynamicOffset: true,\n                    }\n                },\n                {\n                    binding: 2,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: \"storage\",\n                    }\n                },\n            ],\n        });\n\n        let pushConstantsBGLayout = device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {type: \"uniform\", hasDynamicOffset: true}\n                },\n            ]\n        });\n\n        self.#computePipeline = device.createComputePipeline({\n            layout: device.createPipelineLayout(\n                {bindGroupLayouts: [paramsBGLayout, pushConstantsBGLayout]}),\n            compute: {\n                module: await compileShader(device, streamCompactIDs, \"StreamCompactIDs\"),\n                entryPoint: \"main\",\n                constants: {\"0\": self.WORKGROUP_SIZE}\n            }\n        });\n\n        return self;\n    }\n\n    async compactActiveIDs(isActiveBuffer: GPUBuffer,\n        offsetBuffer: GPUBuffer,\n        idOutputBuffer: GPUBuffer,\n        size: number)\n    {\n        // Build the push constants\n        let pushConstantsArg = new Uint32Array([size]);\n        let pushConstants = new PushConstants(\n            this.#device, Math.ceil(size / this.WORKGROUP_SIZE), pushConstantsArg.buffer);\n\n        let pushConstantsBG = this.#device.createBindGroup({\n            layout: this.#computePipeline.getBindGroupLayout(1),\n            entries: [{\n                binding: 0,\n                resource: {\n                    buffer: pushConstants.pushConstantsBuffer,\n                    size: 12,\n                }\n            }]\n        });\n\n        // # of elements we can compact in a single dispatch.\n        const elementsPerDispatch = this.#maxDispatchSize * this.WORKGROUP_SIZE;\n\n        // Ensure we won't break the dynamic offset alignment rules", "        if (pushConstants.numDispatches() > 1 && (elementsPerDispatch * 4) % 256 != 0) {\n            throw Error(\n                \"StreamCompactIDs: Buffer dynamic offsets will not be 256b aligned! Set WORKGROUP_SIZE = 64\");\n        }\n\n        // With dynamic offsets the size/offset validity checking means we still need to\n        // create a separate bind group for the remainder elements that don't evenly fall into\n        // a full size dispatch\n        let paramsBG = this.#device.createBindGroup({\n            layout: this.#computePipeline.getBindGroupLayout(0),\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: isActiveBuffer,\n                        size: Math.min(size, elementsPerDispatch) * 4,\n                    }\n                },\n                {\n                    binding: 1,\n                    resource: {\n                        buffer: offsetBuffer,\n                        size: Math.min(size, elementsPerDispatch) * 4,\n                    }\n                },\n                {\n                    binding: 2,\n                    resource: {\n                        buffer: idOutputBuffer,\n                    }\n                }\n            ]\n        });\n\n        // Make a remainder elements bindgroup if we have some remainder to make sure\n        // we don't bind out of bounds regions of the buffer. If there's no remiander we\n        // just set remainderParamsBG to paramsBG so that on our last dispatch we can just\n        // always bindg remainderParamsBG\n        let remainderParamsBG = paramsBG;\n        const remainderElements = size % elementsPerDispatch;", "        if (remainderElements != 0) {\n            // Note: We don't set the offset here, as that will still be handled by the\n            // dynamic offsets. We just need to set the right size, so that\n            // dynamic offset + binding size is >= buffer size\n            remainderParamsBG = this.#device.createBindGroup({\n                layout: this.#computePipeline.getBindGroupLayout(0),\n                entries: [\n                    {\n                        binding: 0,\n                        resource: {\n                            buffer: isActiveBuffer,\n                            size: remainderElements * 4,\n                        }\n                    },\n                    {\n                        binding: 1,\n                        resource: {\n                            buffer: offsetBuffer,\n                            size: remainderElements * 4,\n                        }\n                    },\n                    {\n                        binding: 2,\n                        resource: {\n                            buffer: idOutputBuffer,\n                        }\n                    }\n                ]\n            });\n        }\n\n        let commandEncoder = this.#device.createCommandEncoder();\n        let pass = commandEncoder.beginComputePass();\n        pass.setPipeline(this.#computePipeline);", "        for (let i = 0; i < pushConstants.numDispatches(); ++i) {\n            let dispatchParamsBG = paramsBG;\n            if (i + 1 == pushConstants.numDispatches()) {\n                dispatchParamsBG = remainderParamsBG;\n            }\n            pass.setBindGroup(0,\n                dispatchParamsBG,\n                [i * elementsPerDispatch * 4, i * elementsPerDispatch * 4]);\n            pass.setBindGroup(1, pushConstantsBG, [i * pushConstants.stride]);\n            pass.dispatchWorkgroups(pushConstants.dispatchSize(i), 1, 1);\n        }\n        pass.end();\n        this.#device.queue.submit([commandEncoder.finish()]);\n        await this.#device.queue.onSubmittedWorkDone();\n    }\n}\n"]}
