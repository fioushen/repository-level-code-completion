{"filename": "vitest.config.ts", "chunked_list": ["/// <reference types=\"vitest\" />\nimport { defineConfig } from \"vite\"\n\nexport default defineConfig({\n  test: {\n    include: [\"./test/**/*.{js,mjs,cjs,ts,mts,cts,jsx,tsx}\"],\n    exclude: [],\n    globals: true,\n    coverage: {\n      provider: \"v8\"", "    coverage: {\n      provider: \"v8\"\n    }\n  }\n})\n"]}
{"filename": "tsup.config.ts", "chunked_list": ["import { defineConfig } from \"tsup\"\n\nexport default defineConfig({\n  entry: [\"src/bin.ts\"],\n  clean: true,\n  publicDir: true,\n  noExternal: [/(effect|@effect|chalk)/]\n})\n", ""]}
{"filename": "test/Markdown.ts", "chunked_list": ["import * as assert from \"assert\"\nimport { Option } from \"effect\"\nimport { flow } from \"effect/Function\"\nimport {\n  createClass,\n  createConstant,\n  createDocumentable,\n  createExport,\n  createFunction,\n  createInterface,", "  createFunction,\n  createInterface,\n  createMethod,\n  createModule,\n  createProperty,\n  createTypeAlias\n} from \"../src/Domain\"\nimport * as _ from \"../src/Markdown\"\n\nconst testCases = {", "\nconst testCases = {\n  class: createClass(\n    createDocumentable(\n      \"A\",\n      Option.some(\"a class\"),\n      Option.some(\"1.0.0\"),\n      false,\n      [\"example 1\"],\n      Option.some(\"category\")", "      [\"example 1\"],\n      Option.some(\"category\")\n    ),\n    \"declare class A { constructor() }\",\n    [\n      createMethod(\n        createDocumentable(\n          \"hasOwnProperty\",\n          Option.none(),\n          Option.some(\"1.0.0\"),\n          false,\n          [],\n          Option.none()\n        ),\n        [\"hasOwnProperty(): boolean\"]\n      )\n    ],\n    [\n      createMethod(\n        createDocumentable(\n          \"staticTest\",\n          Option.none(),\n          Option.some(\"1.0.0\"),\n          false,\n          [],\n          Option.none()\n        ),\n        [\"static testStatic(): string;\"]\n      )\n    ],\n    [\n      createProperty(\n        createDocumentable(\n          \"foo\",\n          Option.none(),\n          Option.some(\"1.0.0\"),\n          false,\n          [],\n          Option.none()\n        ),\n        \"foo: string\"\n      )\n    ]\n  ),\n  constant: createConstant(\n    createDocumentable(\n      \"test\",\n      Option.some(\"the test\"),\n      Option.some(\"1.0.0\"),\n      false,\n      [],\n      Option.some(\"constants\")\n    ),\n    \"declare const test: string\"\n  ),\n  export: createExport(\n    createDocumentable(\n      \"test\",\n      Option.none(),\n      Option.some(\"1.0.0\"),\n      false,\n      [],\n      Option.none()\n    ),\n    \"export declare const test: typeof test\"\n  ),\n  function: createFunction(\n    createDocumentable(\n      \"func\",\n      Option.some(\"a function\"),\n      Option.some(\"1.0.0\"),\n      true,\n      [\"example 1\"],\n      Option.none()\n    ),\n    [\"declare const func: (test: string) => string\"]\n  ),\n  interface: createInterface(\n    createDocumentable(\n      \"A\",\n      Option.none(),\n      Option.some(\"1.0.0\"),\n      false,\n      [],\n      Option.none()\n    ),", "    \"export interface A extends Record<string, unknown> {}\"\n  ),\n  typeAlias: createTypeAlias(\n    createDocumentable(\n      \"A\",\n      Option.none(),\n      Option.some(\"1.0.0\"),\n      false,\n      [],\n      Option.none()\n    ),", "    \"export type A = number\"\n  )\n}\n\ndescribe.concurrent(\"Markdown\", () => {\n  const print = flow(_.fromPrintable, _.prettify)\n\n  it(\"fromClass\", () => {\n    assert.strictEqual(\n      print(testCases.class),\n      `## A (class)\n\na class\n\n**Signature**\n\n\\`\\`\\`ts", "declare class A {\n  constructor()\n}\n\\`\\`\\`\n\n**Example**\n\n\\`\\`\\`ts\nexample 1\n\\`\\`\\`\n\nAdded in v1.0.0\n\n### staticTest (static method)\n\n**Signature**\n\n\\`\\`\\`ts\nstatic testStatic(): string;\n\\`\\`\\`\n\nAdded in v1.0.0\n\n### hasOwnProperty (function) (method)\n\n**Signature**\n\n\\`\\`\\`ts\nhasOwnProperty(): boolean\n\\`\\`\\`\n\nAdded in v1.0.0\n\n### foo (property)\n\n**Signature**\n\n\\`\\`\\`ts\nfoo: string\n\\`\\`\\`\n\nAdded in v1.0.0\n`\n    )\n  })\n\n  it(\"printConstant\", () => {\n    assert.strictEqual(\n      print(testCases.constant),\n      `## test\n\nthe test\n\n**Signature**\n\n\\`\\`\\`ts\ndeclare const test: string\n\\`\\`\\`\n\nAdded in v1.0.0\n`\n    )\n  })\n\n  it(\"printExport\", () => {\n    assert.strictEqual(\n      print(testCases.export),\n      `## test\n\n**Signature**\n\n\\`\\`\\`ts\nexport declare const test: typeof test\n\\`\\`\\`\n\nAdded in v1.0.0\n`\n    )\n  })\n\n  it(\"printFunction\", () => {\n    assert.strictEqual(\n      print(testCases.function),\n      `## ~~func~~\n\na function\n\n**Signature**\n\n\\`\\`\\`ts\ndeclare const func: (test: string) => string\n\\`\\`\\`\n\n**Example**\n\n\\`\\`\\`ts\nexample 1\n\\`\\`\\`\n\nAdded in v1.0.0\n`\n    )\n  })\n\n  it(\"printInterface\", () => {\n    assert.strictEqual(\n      print(testCases.interface),\n      `## A (interface)\n\n**Signature**\n\n\\`\\`\\`ts", "export interface A extends Record<string, unknown> {}\n\\`\\`\\`\n\nAdded in v1.0.0\n`\n    )\n  })\n\n  it(\"printTypeAlias\", () => {\n    assert.strictEqual(\n      print(testCases.typeAlias),", "      `## A (type alias)\n\n**Signature**\n\n\\`\\`\\`ts\nexport type A = number\n\\`\\`\\`\n\nAdded in v1.0.0\n`\n    )\n\n    assert.strictEqual(\n      print({ ...testCases.typeAlias, since: Option.none() }),", "      `## A (type alias)\n\n**Signature**\n\n\\`\\`\\`ts\nexport type A = number\n\\`\\`\\`\n`\n    )\n  })\n\n  it(\"printModule\", () => {\n    const documentation = createDocumentable(\n      \"tests\",\n      Option.none(),\n      Option.some(\"1.0.0\"),\n      false,\n      [],\n      Option.none()\n    )\n    assert.strictEqual(\n      _.printModule(\n        createModule(\n          documentation,\n          [\"src\", \"tests.ts\"],\n          [testCases.class],\n          [testCases.interface],\n          [testCases.function],\n          [testCases.typeAlias],\n          [testCases.constant],\n          [testCases.export]\n        ),\n        1\n      ),\n      `---\ntitle: tests.ts\nnav_order: 1\nparent: Modules\n---\n\n## tests overview\n\nAdded in v1.0.0\n\n---\n\n<h2 class=\"text-delta\">Table of contents</h2>\n\n- [category](#category)\n  - [A (class)](#a-class)\n    - [staticTest (static method)](#statictest-static-method)\n    - [hasOwnProperty (function) (method)](#hasownproperty-function-method)\n    - [foo (property)](#foo-property)\n- [constants](#constants)\n  - [test](#test)\n- [utils](#utils)\n  - [A (interface)](#a-interface)", "  - [A (type alias)](#a-type-alias)\n  - [~~func~~](#func)\n  - [test](#test-1)\n\n---\n\n# category\n\n## A (class)\n\na class\n\n**Signature**\n\n\\`\\`\\`ts", "declare class A {\n  constructor()\n}\n\\`\\`\\`\n\n**Example**\n\n\\`\\`\\`ts\nexample 1\n\\`\\`\\`\n\nAdded in v1.0.0\n\n### staticTest (static method)\n\n**Signature**\n\n\\`\\`\\`ts\nstatic testStatic(): string;\n\\`\\`\\`\n\nAdded in v1.0.0\n\n### hasOwnProperty (function) (method)\n\n**Signature**\n\n\\`\\`\\`ts\nhasOwnProperty(): boolean\n\\`\\`\\`\n\nAdded in v1.0.0\n\n### foo (property)\n\n**Signature**\n\n\\`\\`\\`ts\nfoo: string\n\\`\\`\\`\n\nAdded in v1.0.0\n\n# constants\n\n## test\n\nthe test\n\n**Signature**\n\n\\`\\`\\`ts\ndeclare const test: string\n\\`\\`\\`\n\nAdded in v1.0.0\n\n# utils\n\n## A (interface)\n\n**Signature**\n\n\\`\\`\\`ts", "export interface A extends Record<string, unknown> {}\n\\`\\`\\`\n\nAdded in v1.0.0\n\n## A (type alias)\n\n**Signature**\n\n\\`\\`\\`ts\nexport type A = number\n\\`\\`\\`\n\nAdded in v1.0.0\n\n## ~~func~~\n\na function\n\n**Signature**\n\n\\`\\`\\`ts\ndeclare const func: (test: string) => string\n\\`\\`\\`\n\n**Example**\n\n\\`\\`\\`ts\nexample 1\n\\`\\`\\`\n\nAdded in v1.0.0\n\n## test\n\n**Signature**\n\n\\`\\`\\`ts\nexport declare const test: typeof test\n\\`\\`\\`\n\nAdded in v1.0.0\n`\n    )\n\n    const empty = createModule(\n      documentation,\n      [\"src\", \"tests.ts\"],\n      [],\n      [],\n      [],\n      [],\n      [],\n      []\n    )\n\n    assert.strictEqual(\n      _.printModule(empty, 1),\n      `---\ntitle: tests.ts\nnav_order: 1\nparent: Modules\n---\n\n## tests overview\n\nAdded in v1.0.0\n\n---\n\n<h2 class=\"text-delta\">Table of contents</h2>\n\n---\n`\n    )\n  })\n})\n", "export type A = number\n\\`\\`\\`\n\nAdded in v1.0.0\n\n## ~~func~~\n\na function\n\n**Signature**\n\n\\`\\`\\`ts\ndeclare const func: (test: string) => string\n\\`\\`\\`\n\n**Example**\n\n\\`\\`\\`ts\nexample 1\n\\`\\`\\`\n\nAdded in v1.0.0\n\n## test\n\n**Signature**\n\n\\`\\`\\`ts\nexport declare const test: typeof test\n\\`\\`\\`\n\nAdded in v1.0.0\n`\n    )\n\n    const empty = createModule(\n      documentation,\n      [\"src\", \"tests.ts\"],\n      [],\n      [],\n      [],\n      [],\n      [],\n      []\n    )\n\n    assert.strictEqual(\n      _.printModule(empty, 1),\n      `---\ntitle: tests.ts\nnav_order: 1\nparent: Modules\n---\n\n## tests overview\n\nAdded in v1.0.0\n\n---\n\n<h2 class=\"text-delta\">Table of contents</h2>\n\n---\n`\n    )\n  })\n})\n"]}
{"filename": "test/Domain.ts", "chunked_list": ["import * as assert from \"assert\"\nimport { Option, ReadonlyArray } from \"effect\"\nimport * as Domain from \"../src/Domain\"\n\nconst documentable = (name: string) =>\n  Domain.createDocumentable(\n    name,\n    Option.none(),\n    Option.some(\"1.0.0\"),\n    false,", "    Option.some(\"1.0.0\"),\n    false,\n    [],\n    Option.none()\n  )\n\ndescribe.concurrent(\"Domain\", () => {\n  describe.concurrent(\"constructors\", () => {\n    it(\"Documentable\", () => {\n      assert.deepStrictEqual(documentable(\"A\"), {", "    it(\"Documentable\", () => {\n      assert.deepStrictEqual(documentable(\"A\"), {\n        name: \"A\",\n        description: Option.none(),\n        since: Option.some(\"1.0.0\"),\n        deprecated: false,\n        examples: [],\n        category: Option.none()\n      })\n    })", "      })\n    })\n\n    it(\"Module\", () => {\n      const m = Domain.createModule(\n        documentable(\"test\"),\n        [\"src\", \"index.ts\"],\n        [],\n        [],\n        [],", "        [],\n        [],\n        [],\n        [],\n        []\n      )\n\n      assert.deepStrictEqual(m, {\n        ...documentable(\"test\"),\n        path: [\"src\", \"index.ts\"],", "        ...documentable(\"test\"),\n        path: [\"src\", \"index.ts\"],\n        classes: [],\n        interfaces: [],\n        functions: [],\n        typeAliases: [],\n        constants: [],\n        exports: []\n      })\n    })", "      })\n    })\n\n    it(\"Class\", () => {\n      const c = Domain.createClass(\n        documentable(\"A\"),\n        \"declare class A { constructor() }\",\n        [],\n        [],\n        []\n      )\n\n      assert.deepStrictEqual(c, {\n        _tag: \"Class\",\n        ...documentable(\"A\"),", "        signature: \"declare class A { constructor() }\",\n        methods: [],\n        staticMethods: [],\n        properties: []\n      })\n    })\n\n    it(\"Constant\", () => {\n      const c = Domain.createConstant(\n        documentable(\"foo\"),\n        \"declare const foo: string\"\n      )\n\n      assert.deepStrictEqual(c, {\n        _tag: \"Constant\",\n        ...documentable(\"foo\"),\n        signature: \"declare const foo: string\"\n      })\n    })\n\n    it(\"Method\", () => {\n      const m = Domain.createMethod(documentable(\"foo\"), [\"foo(): string\"])\n\n      assert.deepStrictEqual(m, {\n        ...documentable(\"foo\"),\n        signatures: [\"foo(): string\"]\n      })\n    })\n\n    it(\"Property\", () => {\n      const p = Domain.createProperty(documentable(\"foo\"), \"foo: string\")\n\n      assert.deepStrictEqual(p, {\n        ...documentable(\"foo\"),\n        signature: \"foo: string\"\n      })\n    })\n\n    it(\"Interface\", () => {", "      const i = Domain.createInterface(documentable(\"A\"), \"interface A {}\")\n\n      assert.deepStrictEqual(i, {\n        _tag: \"Interface\",\n        ...documentable(\"A\"),\n        signature: \"interface A {}\"\n      })\n    })\n\n    it(\"Function\", () => {\n      const f = Domain.createFunction(documentable(\"func\"), [", "        \"declare function func(): string\"\n      ])\n\n      assert.deepStrictEqual(f, {\n        _tag: \"Function\",\n        ...documentable(\"func\"),\n        signatures: [\"declare function func(): string\"]\n      })\n    })\n\n    it(\"TypeAlias\", () => {", "      const ta = Domain.createTypeAlias(documentable(\"A\"), \"type A = string\")\n\n      assert.deepStrictEqual(ta, {\n        _tag: \"TypeAlias\",\n        ...documentable(\"A\"),\n        signature: \"type A = string\"\n      })\n    })\n\n    it(\"Export\", () => {\n      const e = Domain.createExport(\n        documentable(\"foo\"),\n        \"export declare const foo: string\"\n      )\n\n      assert.deepStrictEqual(e, {\n        _tag: \"Export\",\n        ...documentable(\"foo\"),\n        signature: \"export declare const foo: string\"\n      })\n    })\n  })\n\n  describe.concurrent(\"instances\", () => {\n    it(\"ordModule\", () => {\n      const m1 = Domain.createModule(\n        documentable(\"test1\"),\n        [\"src\", \"test1.ts\"],\n        [],\n        [],\n        [],\n        [],\n        [],\n        []\n      )\n\n      const m2 = Domain.createModule(\n        documentable(\"test1\"),\n        [\"src\", \"test1.ts\"],\n        [],\n        [],\n        [],\n        [],\n        [],\n        []\n      )\n\n      const sorted = ReadonlyArray.sort([m2, m1], Domain.Order)\n\n      assert.deepStrictEqual(sorted, [m1, m2])\n    })\n  })\n})\n"]}
{"filename": "test/FileSystem.ts", "chunked_list": ["import * as assert from \"assert\"\nimport { Effect, Exit } from \"effect\"\nimport * as FileSystem from \"../src/FileSystem\"\n\ndescribe.concurrent(\"FileSystem\", () => {\n  describe.concurrent(\"readFile\", () => {\n    it(\"should error out on non existing files\", async () => {\n      const program = Effect.flatMap(\n        FileSystem.FileSystem,\n        (fileSystem) => fileSystem.readFile(\"non-existent.txt\")", "        FileSystem.FileSystem,\n        (fileSystem) => fileSystem.readFile(\"non-existent.txt\")\n      ).pipe(\n        Effect.mapError(({ error }) => error.message),\n        Effect.provideLayer(FileSystem.FileSystemLive)\n      )\n      assert.deepStrictEqual(\n        Exit.unannotate(await Effect.runPromiseExit(program)),\n        Exit.fail(\"ENOENT: no such file or directory, open 'non-existent.txt'\")\n      )", "        Exit.fail(\"ENOENT: no such file or directory, open 'non-existent.txt'\")\n      )\n    })\n  })\n})\n"]}
{"filename": "test/Parser.ts", "chunked_list": ["import * as assert from \"assert\"\nimport chalk from \"chalk\"\nimport { Effect, Exit, Option, String } from \"effect\"\nimport * as ast from \"ts-morph\"\nimport * as Config from \"../src/Config\"\nimport * as FileSystem from \"../src/FileSystem\"\nimport * as Parser from \"../src/Parser\"\n\nlet testCounter = 0\n", "let testCounter = 0\n\nconst project = new ast.Project({\n  compilerOptions: { strict: true },\n  useInMemoryFileSystem: true\n})\n\nconst defaultConfig: Config.Config = {\n  projectName: \"docgen\",\n  projectHomepage: \"https://github.com/effect-ts/docgen\",", "  projectName: \"docgen\",\n  projectHomepage: \"https://github.com/effect-ts/docgen\",\n  srcDir: \"src\",\n  outDir: \"docs\",\n  theme: \"pmarsceill/just-the-docs\",\n  enableSearch: true,\n  enforceDescriptions: false,\n  enforceExamples: false,\n  enforceVersion: true,\n  exclude: [],", "  enforceVersion: true,\n  exclude: [],\n  parseCompilerOptions: {},\n  examplesCompilerOptions: {}\n}\n\nconst getParser = (sourceText: string): Parser.Source => ({\n  path: [\"test\"],\n  sourceFile: project.createSourceFile(`test-${testCounter++}.ts`, sourceText)\n})", "  sourceFile: project.createSourceFile(`test-${testCounter++}.ts`, sourceText)\n})\n\nconst expectFailure = <E, A>(\n  sourceText: string,\n  eff: Effect.Effect<Parser.Source | Config.Config, E, A>,\n  failure: E,\n  config?: Partial<Config.Config>\n) => {\n  expect(", ") => {\n  expect(\n    eff.pipe(\n      Effect.provideService(Parser.Source, getParser(sourceText)),\n      Effect.provideService(Config.Config, { ...defaultConfig, ...config }),\n      Effect.runSyncExit,\n      Exit.unannotate\n    )\n  ).toEqual(Exit.fail(failure))\n}", "  ).toEqual(Exit.fail(failure))\n}\n\nconst expectSuccess = <E, A>(\n  sourceText: string,\n  eff: Effect.Effect<Parser.Source | Config.Config, E, A>,\n  a: A,\n  config?: Partial<Config.Config>\n) => {\n  expect(", ") => {\n  expect(\n    eff\n      .pipe(\n        Effect.provideService(Parser.Source, getParser(sourceText)),\n        Effect.provideService(Config.Config, { ...defaultConfig, ...config }),\n        Effect.runSyncExit\n      )\n  ).toEqual(Exit.succeed(a))\n}", "  ).toEqual(Exit.succeed(a))\n}\n\ndescribe.concurrent(\"Parser\", () => {\n  describe.concurrent(\"parsers\", () => {\n    describe.concurrent(\"parseInterfaces\", () => {\n      it(\"should return no `Interface`s if the file is empty\", () => {\n        expectSuccess(\"\", Parser.parseInterfaces, [])\n      })\n", "      })\n\n      it(\"should return no `Interface`s if there are no exported interfaces\", () => {\n        expectSuccess(\"interface A {}\", Parser.parseInterfaces, [])\n      })\n\n      it(\"should return an `Interface`\", () => {\n        expectSuccess(\n          `/**\n        * a description...\n        * @since 1.0.0\n        * @deprecated\n        */", "        export interface A {}`,\n          Parser.parseInterfaces,\n          [\n            {\n              _tag: \"Interface\",\n              deprecated: true,\n              description: Option.some(\"a description...\"),\n              name: \"A\",\n              signature: \"export interface A {}\",\n              since: Option.some(\"1.0.0\"),\n              examples: [],\n              category: Option.none()\n            }\n          ]\n        )\n      })\n\n      it(\"should return interfaces sorted by name\", () => {\n        expectSuccess(\n          `\n        /**\n         * @since 1.0.0\n         */", "              signature: \"export interface A {}\",\n              since: Option.some(\"1.0.0\"),\n              examples: [],\n              category: Option.none()\n            }\n          ]\n        )\n      })\n\n      it(\"should return interfaces sorted by name\", () => {\n        expectSuccess(\n          `\n        /**\n         * @since 1.0.0\n         */", "        export interface B {}\n        /**\n         * @since 1.0.0\n         */\n        export interface A {}\n        `,\n          Parser.parseInterfaces,\n          [\n            {\n              _tag: \"Interface\",\n              name: \"A\",\n              description: Option.none(),\n              since: Option.some(\"1.0.0\"),\n              deprecated: false,\n              category: Option.none(),\n              examples: [],", "              signature: \"export interface A {}\"\n            },\n            {\n              _tag: \"Interface\",\n              name: \"B\",\n              description: Option.none(),\n              since: Option.some(\"1.0.0\"),\n              deprecated: false,\n              category: Option.none(),\n              examples: [],\n              signature: \"export interface B {}\"\n            }\n          ]\n        )\n      })\n    })\n\n    describe.concurrent(\"parseFunctions\", () => {", "              signature: \"export interface B {}\"\n            }\n          ]\n        )\n      })\n    })\n\n    describe.concurrent(\"parseFunctions\", () => {\n      it(\"should raise an error if the function is anonymous\", () => {\n        expectFailure(\n          `export function(a: number, b: number): number { return a + b }`,\n          Parser.parseFunctions,", "      it(\"should raise an error if the function is anonymous\", () => {\n        expectFailure(\n          `export function(a: number, b: number): number { return a + b }`,\n          Parser.parseFunctions,\n          [\"Missing function name in module test\"]\n        )\n      })\n\n      it(\"should not return private function declarations\", () => {\n        expectSuccess(\n          `function sum(a: number, b: number): number { return a + b }`,\n          Parser.parseFunctions,\n          []\n        )\n      })\n", "      it(\"should not return private function declarations\", () => {\n        expectSuccess(\n          `function sum(a: number, b: number): number { return a + b }`,\n          Parser.parseFunctions,\n          []\n        )\n      })\n\n      it(\"should not return ignored function declarations\", () => {\n        expectSuccess(\n          `/**\n        * @ignore\n        */", "      it(\"should not return ignored function declarations\", () => {\n        expectSuccess(\n          `/**\n        * @ignore\n        */\n        export function sum(a: number, b: number): number { return a + b }`,\n          Parser.parseFunctions,\n          []\n        )\n      })\n", "      it(\"should not return ignored function declarations with overloads\", () => {\n        expectSuccess(\n          `/**\n            * @ignore\n            */\n            export function sum(a: number, b: number)\n            export function sum(a: number, b: number): number { return a + b }`,\n          Parser.parseFunctions,\n          []\n        )\n      })\n", "      it(\"should not return internal function declarations\", () => {\n        expectSuccess(\n          `/**\n            * @internal\n            */\n            export function sum(a: number, b: number): number { return a + b }`,\n          Parser.parseFunctions,\n          []\n        )\n      })\n", "      it(\"should not return internal function declarations even with overloads\", () => {\n        expectSuccess(\n          `/**\n            * @internal\n            */\n            export function sum(a: number, b: number)\n            export function sum(a: number, b: number): number { return a + b }`,\n          Parser.parseFunctions,\n          []\n        )\n      })\n", "      it(\"should not return private const function declarations\", () => {\n        expectSuccess(\n          `const sum = (a: number, b: number): number => a + b `,\n          Parser.parseFunctions,\n          []\n        )\n      })\n\n      it(\"should not return internal const function declarations\", () => {\n        expectSuccess(\n          `/**\n            * @internal\n            */\n            export const sum = (a: number, b: number): number => a + b `,\n          Parser.parseFunctions,\n          []\n        )\n      })\n\n      it(\"should account for nullable polymorphic return types\", () => {\n        expectSuccess(\n          `/**\n            * @since 1.0.0\n            */\n           export const toNullable = <A>(ma: A | null): A | null => ma`,\n          Parser.parseFunctions,\n          [\n            {\n              _tag: \"Function\",\n              deprecated: false,\n              description: Option.none(),\n              name: \"toNullable\",\n              signatures: [\n                \"export declare const toNullable: <A>(ma: A | null) => A | null\"\n              ],\n              since: Option.some(\"1.0.0\"),\n              examples: [],\n              category: Option.none()\n            }\n          ]\n        )\n      })\n", "      it(\"should not return internal const function declarations\", () => {\n        expectSuccess(\n          `/**\n            * @internal\n            */\n            export const sum = (a: number, b: number): number => a + b `,\n          Parser.parseFunctions,\n          []\n        )\n      })\n\n      it(\"should account for nullable polymorphic return types\", () => {\n        expectSuccess(\n          `/**\n            * @since 1.0.0\n            */\n           export const toNullable = <A>(ma: A | null): A | null => ma`,\n          Parser.parseFunctions,\n          [\n            {\n              _tag: \"Function\",\n              deprecated: false,\n              description: Option.none(),\n              name: \"toNullable\",\n              signatures: [\n                \"export declare const toNullable: <A>(ma: A | null) => A | null\"\n              ],\n              since: Option.some(\"1.0.0\"),\n              examples: [],\n              category: Option.none()\n            }\n          ]\n        )\n      })\n", "      it(\"should return a const function declaration\", () => {\n        expectSuccess(\n          `/**\n            * a description...\n            * @since 1.0.0\n            * @example\n            * assert.deepStrictEqual(f(1, 2), { a: 1, b: 2 })\n            * @example\n            * assert.deepStrictEqual(f(3, 4), { a: 3, b: 4 })\n            * @deprecated\n            */\n            export const f = (a: number, b: number): { [key: string]: number } => ({ a, b })`,\n          Parser.parseFunctions,\n          [\n            {\n              _tag: \"Function\",\n              deprecated: true,\n              description: Option.some(\"a description...\"),\n              name: \"f\",\n              signatures: [\n                \"export declare const f: (a: number, b: number) => { [key: string]: number; }\"\n              ],\n              since: Option.some(\"1.0.0\"),\n              examples: [\n                \"assert.deepStrictEqual(f(1, 2), { a: 1, b: 2 })\",\n                \"assert.deepStrictEqual(f(3, 4), { a: 3, b: 4 })\"\n              ],\n              category: Option.none()\n            }\n          ]\n        )\n      })\n", "      it(\"should return a function declaration\", () => {\n        expectSuccess(\n          `/**\n            * @since 1.0.0\n            */\n            export function f(a: number, b: number): { [key: string]: number } { return { a, b } }`,\n          Parser.parseFunctions,\n          [\n            {\n              _tag: \"Function\",\n              deprecated: false,\n              description: Option.none(),\n              name: \"f\",\n              signatures: [", "                \"export declare function f(a: number, b: number): { [key: string]: number }\"\n              ],\n              since: Option.some(\"1.0.0\"),\n              examples: [],\n              category: Option.none()\n            }\n          ]\n        )\n      })\n\n      it(\"should return a function with comments\", () => {\n        expectSuccess(\n          `/**\n            * a description...\n            * @since 1.0.0\n            * @deprecated\n            */", "      it(\"should return a function with comments\", () => {\n        expectSuccess(\n          `/**\n            * a description...\n            * @since 1.0.0\n            * @deprecated\n            */\n            export function f(a: number, b: number): { [key: string]: number } { return { a, b } }`,\n          Parser.parseFunctions,\n          [\n            {\n              _tag: \"Function\",\n              deprecated: true,\n              description: Option.some(\"a description...\"),\n              name: \"f\",\n              signatures: [", "                \"export declare function f(a: number, b: number): { [key: string]: number }\"\n              ],\n              since: Option.some(\"1.0.0\"),\n              examples: [],\n              category: Option.none()\n            }\n          ]\n        )\n      })\n\n      it(\"should handle overloadings\", () => {\n        expectSuccess(\n          `/**\n            * a description...\n            * @since 1.0.0\n            * @deprecated\n            */", "            export function f(a: Int, b: Int): { [key: string]: number }\n            export function f(a: number, b: number): { [key: string]: number }\n            export function f(a: any, b: any): { [key: string]: number } { return { a, b } }`,\n          Parser.parseFunctions,\n          [\n            {\n              _tag: \"Function\",\n              name: \"f\",\n              description: Option.some(\"a description...\"),\n              since: Option.some(\"1.0.0\"),\n              deprecated: true,\n              category: Option.none(),\n              examples: [],\n              signatures: [", "                \"export declare function f(a: Int, b: Int): { [key: string]: number }\",\n                \"export declare function f(a: number, b: number): { [key: string]: number }\"\n              ]\n            }\n          ]\n        )\n      })\n    })\n\n    describe.concurrent(\"parseTypeAlias\", () => {\n      it(\"should return a `TypeAlias`\", () => {\n        expectSuccess(\n          `/**\n            * a description...\n            * @since 1.0.0\n            * @deprecated\n            */", "            export type Option<A> = None<A> | Some<A>`,\n          Parser.parseTypeAliases,\n          [\n            {\n              _tag: \"TypeAlias\",\n              name: \"Option\",\n              description: Option.some(\"a description...\"),\n              since: Option.some(\"1.0.0\"),\n              deprecated: true,\n              category: Option.none(),\n              signature: \"export type Option<A> = None<A> | Some<A>\",\n              examples: []\n            }\n          ]\n        )\n      })\n    })\n\n    describe.concurrent(\"parseConstants\", () => {\n      it(\"should handle a constant value\", () => {\n        expectSuccess(\n          `/**\n            * a description...\n            * @since 1.0.0\n            * @deprecated\n            */\n            export const s: string = ''`,\n          Parser.parseConstants,\n          [\n            {\n              _tag: \"Constant\",\n              name: \"s\",\n              description: Option.some(\"a description...\"),\n              since: Option.some(\"1.0.0\"),\n              deprecated: true,\n              category: Option.none(),\n              signature: \"export declare const s: string\",\n              examples: []\n            }\n          ]\n        )\n      })\n", "              signature: \"export type Option<A> = None<A> | Some<A>\",\n              examples: []\n            }\n          ]\n        )\n      })\n    })\n\n    describe.concurrent(\"parseConstants\", () => {\n      it(\"should handle a constant value\", () => {\n        expectSuccess(\n          `/**\n            * a description...\n            * @since 1.0.0\n            * @deprecated\n            */\n            export const s: string = ''`,\n          Parser.parseConstants,\n          [\n            {\n              _tag: \"Constant\",\n              name: \"s\",\n              description: Option.some(\"a description...\"),\n              since: Option.some(\"1.0.0\"),\n              deprecated: true,\n              category: Option.none(),\n              signature: \"export declare const s: string\",\n              examples: []\n            }\n          ]\n        )\n      })\n", "      it(\"should support constants with default type parameters\", () => {\n        expectSuccess(\n          `/**\n            * @since 1.0.0\n            */\n            export const left: <E = never, A = never>(l: E) => string = T.left`,\n          Parser.parseConstants,\n          [\n            {\n              _tag: \"Constant\",\n              name: \"left\",\n              description: Option.none(),\n              since: Option.some(\"1.0.0\"),\n              deprecated: false,\n              category: Option.none(),\n              signature: \"export declare const left: <E = never, A = never>(l: E) => string\",\n              examples: []\n            }\n          ]\n        )\n      })\n\n      it(\"should support untyped constants\", () => {\n        expectSuccess(\n          `", "        class A {}\n      /**\n        * @since 1.0.0\n        */\n        export const empty = new A()`,\n          Parser.parseConstants,\n          [\n            {\n              _tag: \"Constant\",\n              name: \"empty\",\n              description: Option.none(),\n              since: Option.some(\"1.0.0\"),\n              deprecated: false,\n              category: Option.none(),\n              signature: \"export declare const empty: A\",\n              examples: []\n            }\n          ]\n        )\n      })\n\n      it(\"should handle constants with typeof annotations\", () => {\n        expectSuccess(\n          ` const task: { a: number } = {\n          a: 1\n        }\n        /**\n        * @since 1.0.0\n        */\n        export const taskSeq: typeof task = {\n          ...task,\n          ap: (mab, ma) => () => mab().then(f => ma().then(a => f(a)))\n        }`,\n          Parser.parseConstants,\n          [\n            {\n              _tag: \"Constant\",\n              deprecated: false,\n              description: Option.none(),\n              name: \"taskSeq\",\n              signature: \"export declare const taskSeq: { a: number; }\",\n              since: Option.some(\"1.0.0\"),\n              examples: [],\n              category: Option.none()\n            }\n          ]\n        )\n      })\n\n      it(\"should not include variables declared in for loops\", () => {\n        expectSuccess(\n          ` const object = { a: 1, b: 2, c: 3 };\n", "        for (const property in object) {\n          console.log(property);\n        }`,\n          Parser.parseConstants,\n          []\n        )\n      })\n    })\n\n    describe.concurrent(\"parseClasses\", () => {\n      it(\"should raise an error if the class is anonymous\", () => {\n        expectFailure(`export class {}`, Parser.parseClasses, [", "      it(\"should raise an error if the class is anonymous\", () => {\n        expectFailure(`export class {}`, Parser.parseClasses, [\n          \"Missing class name in module test\"\n        ])\n      })\n\n      it(\"should raise an error if an `@since` tag is missing in a module\", () => {\n        expectFailure(`export class MyClass {}`, Parser.parseClasses, [\n          `Missing ${chalk.bold(\"@since\")} tag in ${chalk.bold(\"test#MyClass\")} documentation`\n        ])\n      })\n\n      it(\"should ignore internal classes\", () => {", "        expectSuccess(`/** @internal */export class MyClass {}`, Parser.parseClasses, [])\n      })\n\n      it(\"should ignore `@ignore`d classes\", () => {\n        expectSuccess(`/** @ignore */export class MyClass {}`, Parser.parseClasses, [])\n      })\n\n      it(\"should raise an error if `@since` is missing in a property\", () => {\n        expectFailure(\n          `/**\n            * @since 1.0.0\n            */", "            export class MyClass<A> {\n              readonly _A!: A\n            }`,\n          Parser.parseClasses,\n          [`Missing ${chalk.bold(\"@since\")} tag in ${chalk.bold(\"test#MyClass#_A\")} documentation`]\n        )\n      })\n\n      it(\"should skip ignored properties\", () => {\n        expectSuccess(\n          `/**\n        * @since 1.0.0\n        */", "        export class MyClass<A> {\n          /**\n           * @ignore\n           */\n          readonly _A!: A\n        }`,\n          Parser.parseClasses,\n          [\n            {\n              _tag: \"Class\",\n              name: \"MyClass\",\n              description: Option.none(),\n              since: Option.some(\"1.0.0\"),\n              deprecated: false,\n              category: Option.none(),\n              examples: [],", "              signature: \"export declare class MyClass<A>\",\n              methods: [],\n              staticMethods: [],\n              properties: []\n            }\n          ]\n        )\n      })\n\n      it(\"should skip the constructor body\", () => {\n        expectSuccess(\n          `/**\n        * description\n        * @since 1.0.0\n        */", "        export class C { constructor() {} }`,\n          Parser.parseClasses,\n          [\n            {\n              _tag: \"Class\",\n              name: \"C\",\n              description: Option.some(\"description\"),\n              since: Option.some(\"1.0.0\"),\n              deprecated: false,\n              category: Option.none(),\n              examples: [],", "              signature: \"export declare class C { constructor() }\",\n              methods: [],\n              staticMethods: [],\n              properties: []\n            }\n          ]\n        )\n      })\n\n      it(\"should get a constructor declaration signature\", () => {\n        const sourceFile = project.createSourceFile(\n          `test-${testCounter++}.ts`,\n          `\n        /**\n         * @since 1.0.0\n         */", "        declare class A {\n          constructor()\n        }\n      `\n        )\n\n        const constructorDeclaration = sourceFile\n          .getClass(\"A\")!\n          .getConstructors()[0]\n\n        assert.deepStrictEqual(\n          Parser.getConstructorDeclarationSignature(constructorDeclaration),\n          \"constructor()\"\n        )\n      })\n\n      it(\"should handle non-readonly properties\", () => {\n        expectSuccess(\n          `/**\n        * description\n        * @since 1.0.0\n        */", "        export class C {\n          /**\n           * @since 1.0.0\n           */\n          a: string\n        }`,\n          Parser.parseClasses,\n          [\n            {\n              _tag: \"Class\",\n              name: \"C\",\n              description: Option.some(\"description\"),\n              since: Option.some(\"1.0.0\"),\n              deprecated: false,\n              category: Option.none(),\n              examples: [],", "              signature: \"export declare class C\",\n              methods: [],\n              staticMethods: [],\n              properties: [\n                {\n                  name: \"a\",\n                  description: Option.none(),\n                  since: Option.some(\"1.0.0\"),\n                  deprecated: false,\n                  category: Option.none(),\n                  examples: [],\n                  signature: \"a: string\"\n                }\n              ]\n            }\n          ]\n        )\n      })\n\n      it(\"should return a `Class`\", () => {\n        expectSuccess(\n          `/**", "        * a class description...\n        * @since 1.0.0\n        * @deprecated\n        */\n        export class Test {\n          /**\n           * a property...\n           * @since 1.1.0\n           * @deprecated\n           */\n          readonly a: string\n          private readonly b: number\n          /**\n           * a static method description...\n           * @since 1.1.0\n           * @deprecated\n           */\n          static f(): void {}\n          constructor(readonly value: string) { }\n          /**\n           * a method description...\n           * @since 1.1.0\n           * @deprecated\n           */\n          g(a: number, b: number): { [key: string]: number } {\n            return { a, b }\n          }\n        }`,\n          Parser.parseClasses,\n          [\n            {\n              _tag: \"Class\",\n              name: \"Test\",", "              description: Option.some(\"a class description...\"),\n              since: Option.some(\"1.0.0\"),\n              deprecated: true,\n              category: Option.none(),\n              examples: [],\n              signature: \"export declare class Test { constructor(readonly value: string) }\",\n              methods: [\n                {\n                  name: \"g\",\n                  description: Option.some(\"a method description...\"),\n                  since: Option.some(\"1.1.0\"),\n                  deprecated: true,\n                  category: Option.none(),\n                  examples: [],\n                  signatures: [\n                    \"g(a: number, b: number): { [key: string]: number }\"\n                  ]\n                }\n              ],\n              staticMethods: [\n                {\n                  name: \"f\",\n                  description: Option.some(\"a static method description...\"),\n                  since: Option.some(\"1.1.0\"),\n                  deprecated: true,\n                  category: Option.none(),\n                  examples: [],\n                  signatures: [\"static f(): void\"]\n                }\n              ],\n              properties: [\n                {\n                  name: \"a\",\n                  description: Option.some(\"a property...\"),\n                  since: Option.some(\"1.1.0\"),\n                  deprecated: true,\n                  category: Option.none(),\n                  signature: \"readonly a: string\",\n                  examples: []\n                }\n              ]\n            }\n          ]\n        )\n      })\n\n      it(\"should handle method overloadings\", () => {\n        expectSuccess(\n          `/**", "        * a class description...\n        * @since 1.0.0\n        * @deprecated\n        */\n        export class Test<A> {\n          /**\n           * a static method description...\n           * @since 1.1.0\n           * @deprecated\n           */\n          static f(x: number): number\n          static f(x: string): string\n          static f(x: any): any {}\n          constructor(readonly value: A) { }\n          /**\n           * a method description...\n           * @since 1.1.0\n           * @deprecated\n           */\n          map(f: (a: number) => number): Test\n          map(f: (a: string) => string): Test\n          map(f: (a: any) => any): any {\n            return new Test(f(this.value))\n          }\n        }`,\n          Parser.parseClasses,\n          [\n            {\n              _tag: \"Class\",\n              name: \"Test\",", "              description: Option.some(\"a class description...\"),\n              since: Option.some(\"1.0.0\"),\n              deprecated: true,\n              category: Option.none(),\n              examples: [],\n              signature: \"export declare class Test<A> { constructor(readonly value: A) }\",\n              methods: [\n                {\n                  name: \"map\",\n                  description: Option.some(\"a method description...\"),\n                  since: Option.some(\"1.1.0\"),\n                  deprecated: true,\n                  category: Option.none(),\n                  examples: [],\n                  signatures: [\n                    \"map(f: (a: number) => number): Test\",\n                    \"map(f: (a: string) => string): Test\"\n                  ]\n                }\n              ],\n              staticMethods: [\n                {\n                  name: \"f\",\n                  description: Option.some(\"a static method description...\"),\n                  since: Option.some(\"1.1.0\"),\n                  deprecated: true,\n                  category: Option.none(),\n                  examples: [],\n                  signatures: [\n                    \"static f(x: number): number\",\n                    \"static f(x: string): string\"\n                  ]\n                }\n              ],\n              properties: []\n            }\n          ]\n        )\n      })\n\n      it(\"should ignore internal/ignored methods (#42)\", () => {\n        expectSuccess(\n          `/**", "        * a class description...\n        * @since 1.0.0\n        */\n        export class Test<A> {\n          /**\n           * @since 0.0.1\n           * @internal\n           **/\n          private foo(): void {}\n          /**\n           * @since 0.0.1\n           * @ignore\n           **/\n          private bar(): void {}\n        }`,\n          Parser.parseClasses,\n          [\n            {\n              _tag: \"Class\",\n              name: \"Test\",", "              description: Option.some(\"a class description...\"),\n              since: Option.some(\"1.0.0\"),\n              deprecated: false,\n              category: Option.none(),\n              examples: [],\n              signature: \"export declare class Test<A>\",\n              methods: [],\n              staticMethods: [],\n              properties: []\n            }\n          ]\n        )\n      })\n    })\n\n    describe.concurrent(\"parseModuleDocumentation\", () => {\n      it(\"should return a description field and a deprecated field\", () => {\n        expectSuccess(\n          `/**\n            * Manages the configuration settings for the widget\n            * @deprecated\n            * @since 1.0.0\n            */\n            /**\n             * @since 1.2.0\n             */\n            export const a: number = 1`,\n          Parser.parseModuleDocumentation,\n          {\n            name: \"test\",\n            description: Option.some(\n              \"Manages the configuration settings for the widget\"\n            ),\n            since: Option.some(\"1.0.0\"),\n            deprecated: true,\n            category: Option.none(),\n            examples: []\n          }\n        )\n      })\n\n      it(\"should return an error when documentation is enforced but no documentation is provided\", () => {\n        expectFailure(\n          \"export const a: number = 1\",\n          Parser.parseModuleDocumentation,\n          \"Missing documentation in test module\"\n        )\n      })\n", "      it(\"should support absence of module documentation when no documentation is enforced\", () => {\n        expectSuccess(\n          \"export const a: number = 1\",\n          Parser.parseModuleDocumentation,\n          {\n            name: \"test\",\n            description: Option.none(),\n            since: Option.none(),\n            deprecated: false,\n            category: Option.none(),\n            examples: []\n          },\n          { enforceVersion: false }\n        )\n      })\n    })\n\n    describe.concurrent(\"parseExports\", () => {\n      it(\"should return no `Export`s if the file is empty\", () => {\n        expectSuccess(\"\", Parser.parseExports, [])\n      })\n\n      it(\"should handle renamimg\", () => {\n        expectSuccess(\n          `const a = 1;\n          export {\n            /**\n             * @since 1.0.0\n             */\n            a as b\n          }`,\n          Parser.parseExports,\n          [\n            {\n              _tag: \"Export\",\n              name: \"b\",\n              description: Option.none(),\n              deprecated: false,\n              since: Option.some(\"1.0.0\"),\n              category: Option.none(),\n              examples: [],\n              signature: \"export declare const b: 1\"\n            }\n          ]\n        )\n      })\n\n      it(\"should return an `Export`\", () => {\n        expectSuccess(\n          `export {\n            /**\n             * description_of_a\n             * @since 1.0.0\n             */\n            a,\n            /**\n             * description_of_b\n             * @since 2.0.0\n             */\n            b\n          }`,\n          Parser.parseExports,\n          [\n            {\n              _tag: \"Export\",\n              name: \"a\",\n              description: Option.some(\"description_of_a\"),\n              since: Option.some(\"1.0.0\"),\n              deprecated: false,\n              category: Option.none(),\n              signature: \"export declare const a: any\",\n              examples: []\n            },\n            {\n              _tag: \"Export\",\n              name: \"b\",\n              description: Option.some(\"description_of_b\"),\n              since: Option.some(\"2.0.0\"),\n              deprecated: false,\n              category: Option.none(),\n              signature: \"export declare const b: any\",\n              examples: []\n            }\n          ]\n        )\n      })\n\n      it(\"should raise an error if `@since` tag is missing in export\", () => {\n        expectFailure(\"export { a }\", Parser.parseExports, [\n          \"Missing a documentation in test\"\n        ])\n      })\n\n      it(\"should retrieve an export signature\", () => {\n        project.createSourceFile(\"a.ts\", `export const a = 1`)\n        const sourceFile = project.createSourceFile(\n          \"b.ts\",\n          `import { a } from './a'\n          const b = a\n          export {\n            /**\n              * @since 1.0.0\n              */\n            b\n          }`\n        )\n        const actual = Parser.parseExports.pipe(\n          Effect.provideService(Parser.Source, {\n            path: [\"test\"],\n            sourceFile\n          }),\n          Effect.provideService(Config.Config, defaultConfig),\n          Effect.runSyncExit\n        )\n        expect(actual).toEqual(\n          Exit.succeed([\n            {\n              _tag: \"Export\",\n              name: \"b\",\n              description: Option.none(),\n              since: Option.some(\"1.0.0\"),\n              deprecated: false,\n              signature: \"export declare const b: 1\",\n              category: Option.none(),\n              examples: []\n            }\n          ])\n        )\n      })\n    })\n\n    describe.concurrent(\"parseModule\", () => {\n      it(\"should raise an error if `@since` tag is missing\", async () => {\n        expectFailure(`import * as assert from 'assert'`, Parser.parseModule, [\n          \"Missing documentation in test module\"\n        ])\n      })\n\n      it(\"should not require an example for modules when `enforceExamples` is set to true (#38)\", () => {\n        expectSuccess(\n          `/**\n* This is the assert module.\n*\n* @since 1.0.0\n*/\nimport * as assert from 'assert'\n\n/**\n * This is the foo export.\n *\n * @example\n * import { foo } from 'test'\n *\n * console.log(foo)\n *\n * @category foo\n * @since 1.0.0\n */\nexport const foo = 'foo'`,\n          Parser.parseModule,\n          {\n            name: \"test\",\n            description: Option.some(\"This is the assert module.\"),\n            since: Option.some(\"1.0.0\"),\n            deprecated: false,\n            examples: [],\n            category: Option.none(),\n            path: [\"test\"],\n            classes: [],\n            interfaces: [],\n            functions: [],\n            typeAliases: [],\n            constants: [\n              {\n                _tag: \"Constant\",\n                name: \"foo\",\n                description: Option.some(\"This is the foo export.\"),\n                since: Option.some(\"1.0.0\"),\n                deprecated: false,\n                examples: [`import { foo } from 'test'\\n\\nconsole.log(foo)`],\n                category: Option.some(\"foo\"),\n                signature: \"export declare const foo: \\\"foo\\\"\"\n              }\n            ],\n            exports: []\n          },\n          { enforceExamples: true }\n        )\n      })\n    })\n\n    describe.concurrent(\"parseFile\", () => {\n      it(\"should not parse a non-existent file\", async () => {\n        const file = FileSystem.makeFile(\"non-existent.ts\", \"\")\n        const project = new ast.Project({ useInMemoryFileSystem: true })\n\n        assert.deepStrictEqual(\n          Parser.parseFile(project)(file).pipe(\n            Effect.provideService(Config.Config, defaultConfig),\n            Effect.runSyncExit,\n            Exit.unannotate\n          ),\n          Exit.fail([\"Unable to locate file: non-existent.ts\"])\n        )\n      })\n    })\n  })\n\n  describe.concurrent(\"utils\", () => {\n    describe.concurrent(\"getCommentInfo\", () => {\n      it(\"should parse comment information\", () => {\n        const text = String.stripMargin(\n          `|/**\n           | * description\n           | * @category instances\n           | * @since 1.0.0\n           | */`\n        )\n        expectSuccess(\"\", Parser.getCommentInfo(\"name\")(text), {\n          description: Option.some(\"description\"),\n          since: Option.some(\"1.0.0\"),\n          category: Option.some(\"instances\"),\n          deprecated: false,\n          examples: []\n        })\n      })\n\n      it(\"should fail if an empty comment tag is provided\", () => {\n        const text = String.stripMargin(\n          `|/**\n           | * @category\n           | * @since 1.0.0\n           | */`\n        )\n        expectFailure(\n          \"\",\n          Parser.getCommentInfo(\"name\")(text),\n          `Missing ${chalk.bold(\"@category\")} tag in ${chalk.bold(\"test#name\")} documentation`\n        )\n      })\n\n      it(\"should require a description if `enforceDescriptions` is set to true\", () => {\n        const text = String.stripMargin(\n          `|/**\n           | * @category instances\n           | * @since 1.0.0\n           | */`\n        )\n        expectFailure(\n          \"\",\n          Parser.getCommentInfo(\"name\")(text),\n          `Missing ${chalk.bold(\"description\")} in ${chalk.bold(\"test#name\")} documentation`,\n          {\n            enforceDescriptions: true\n          }\n        )\n      })\n\n      it(\"should require at least one example if `enforceExamples` is set to true\", () => {\n        const text = String.stripMargin(\n          `|/**\n           | * description\n           | * @category instances\n           | * @since 1.0.0\n           | */`\n        )\n        expectFailure(\n          \"\",\n          Parser.getCommentInfo(\"name\")(text),\n          `Missing ${chalk.bold(\"@example\")} tag in ${chalk.bold(\"test#name\")} documentation`,\n          {\n            enforceExamples: true\n          }\n        )\n      })\n\n      it(\"should require at least one non-empty example if `enforceExamples` is set to true\", () => {\n        const text = String.stripMargin(\n          `|/**\n           | * description\n           | * @example\n           | * @category instances\n           | * @since 1.0.0\n           | */`\n        )\n        expectFailure(\n          \"\",\n          Parser.getCommentInfo(\"name\")(text),\n          `Missing ${chalk.bold(\"@example\")} tag in ${chalk.bold(\"test#name\")} documentation`,\n          {\n            enforceExamples: true\n          }\n        )\n      })\n\n      it(\"should allow no since tag if `enforceVersion` is set to false\", () => {\n        const text = `/**\n* description\n* @category instances\n*/`\n\n        expectSuccess(\n          \"\",\n          Parser.getCommentInfo(\"name\")(text),\n          {\n            description: Option.some(\"description\"),\n            since: Option.none(),\n            category: Option.some(\"instances\"),\n            deprecated: false,\n            examples: []\n          },\n          { enforceVersion: false }\n        )\n      })\n    })\n\n    it(\"parseComment\", () => {\n      assert.deepStrictEqual(Parser.parseComment(\"\"), {\n        description: Option.none(),\n        tags: {}\n      })\n\n      assert.deepStrictEqual(Parser.parseComment(\"/** description */\"), {\n        description: Option.some(\"description\"),\n        tags: {}\n      })\n\n      assert.deepStrictEqual(\n        Parser.parseComment(\"/** description\\n * @since 1.0.0\\n */\"),\n        {\n          description: Option.some(\"description\"),\n          tags: {\n            since: [Option.some(\"1.0.0\")]\n          }\n        }\n      )\n\n      assert.deepStrictEqual(\n        Parser.parseComment(\"/** description\\n * @deprecated\\n */\"),\n        {\n          description: Option.some(\"description\"),\n          tags: {\n            deprecated: [Option.none()]\n          }\n        }\n      )\n\n      assert.deepStrictEqual(\n        Parser.parseComment(\"/** description\\n * @category instance\\n */\"),\n        {\n          description: Option.some(\"description\"),\n          tags: {\n            category: [Option.some(\"instance\")]\n          }\n        }\n      )\n    })\n\n    it(\"stripImportTypes\", () => {\n      assert.deepStrictEqual(\n        Parser.stripImportTypes(\n          \"{ <E, A, B>(refinement: import(\\\"/Users/giulio/Documents/Projects/github/fp-ts/src/function\\\").Refinement<A, B>, onFalse: (a: A) => E): (ma: Either<E, A>) => Either<E, B>; <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): (ma: Either<E, A>) => Either<E, A>; }\"\n        ),\n        \"{ <E, A, B>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (ma: Either<E, A>) => Either<E, B>; <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): (ma: Either<E, A>) => Either<E, A>; }\"\n      )\n      assert.deepStrictEqual(\n        Parser.stripImportTypes(\n          \"{ <A, B>(refinementWithIndex: import(\\\"/Users/giulio/Documents/Projects/github/fp-ts/src/FilterableWithIndex\\\").RefinementWithIndex<number, A, B>): (fa: A[]) => B[]; <A>(predicateWithIndex: import(\\\"/Users/giulio/Documents/Projects/github/fp-ts/src/FilterableWithIndex\\\").PredicateWithIndex<number, A>): (fa: A[]) => A[]; }\"\n        ),\n        \"{ <A, B>(refinementWithIndex: RefinementWithIndex<number, A, B>): (fa: A[]) => B[]; <A>(predicateWithIndex: PredicateWithIndex<number, A>): (fa: A[]) => A[]; }\"\n      )\n    })\n  })\n})\n"]}
{"filename": "scripts/copy-package-json.ts", "chunked_list": ["import { Effect, ReadonlyRecord } from \"effect\"\nimport * as path from \"node:path\"\nimport * as FileSystem from \"../src/FileSystem\"\n\nconst excludedPrefixes = [\"@effect\", \"effect\", \"chalk\"]\n\nconst excludeEffectPackages = (\n  deps: Record<string, string>\n): Record<string, string> => {\n  return ReadonlyRecord.filter(", "): Record<string, string> => {\n  return ReadonlyRecord.filter(\n    deps,\n    (_, k) => !excludedPrefixes.some((_) => k.startsWith(_))\n  )\n}\n\nconst read = FileSystem.FileSystem.pipe(\n  Effect.flatMap((fileSystem) => fileSystem.readJsonFile(\"package.json\")),\n  Effect.map((json: any) => ({", "  Effect.flatMap((fileSystem) => fileSystem.readJsonFile(\"package.json\")),\n  Effect.map((json: any) => ({\n    name: json.name,\n    version: json.version,\n    description: json.description,\n    main: \"bin.js\",\n    bin: \"bin.js\",\n    engines: json.engines,\n    dependencies: excludeEffectPackages(json.dependencies),\n    peerDependencies: excludeEffectPackages(json.peerDependencies),", "    dependencies: excludeEffectPackages(json.dependencies),\n    peerDependencies: excludeEffectPackages(json.peerDependencies),\n    repository: json.repository,\n    author: json.author,\n    license: json.license,\n    bugs: json.bugs,\n    homepage: json.homepage,\n    tags: json.tags,\n    keywords: json.keywords\n  }))", "    keywords: json.keywords\n  }))\n)\n\nconst pathTo = path.join(\"dist\", \"package.json\")\n\nconst write = (pkg: object) =>\n  Effect.flatMap(\n    FileSystem.FileSystem,\n    (fileSystem) => fileSystem.writeFile(pathTo, JSON.stringify(pkg, null, 2))", "    FileSystem.FileSystem,\n    (fileSystem) => fileSystem.writeFile(pathTo, JSON.stringify(pkg, null, 2))\n  )\n\nconst program = Effect.sync(() => console.log(`copying package.json to ${pathTo}...`)).pipe(\n  Effect.zipRight(read),\n  Effect.flatMap(write),\n  Effect.provideLayer(FileSystem.FileSystemLive)\n)\n", ")\n\nEffect.runPromise(program)\n"]}
{"filename": "src/ChildProcess.ts", "chunked_list": ["/**\n * @since 1.0.0\n */\nimport { Context, Data, Effect, Layer } from \"effect\"\nimport * as NodeChildProcess from \"node:child_process\"\n\n/**\n * Represents an entity that is capable of spawning child processes.\n *\n * @category model", " *\n * @category model\n * @since 1.0.0\n */\nexport interface ChildProcess {\n  /**\n   * Executes a command like:\n   *\n   * ```sh\n   * ts-node docs/examples/index.ts\n   * ```\n   *\n   * where `command = ts-node` and `executable = docs/examples/index.ts`\n   */\n  spawn(\n    command: string,\n    executable: string\n  ): Effect.Effect<never, ExecutionError | SpawnError, void>\n}\n\n/**\n * Represents an error that occurs when trying to spawn a child process.\n *\n * @category model\n * @since 1.0.0\n */", "export interface SpawnError extends Data.Case {\n  readonly _tag: \"SpawnError\"\n  readonly command: string\n  readonly args: ReadonlyArray<string>\n  readonly error: Error\n}\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const SpawnError = Data.tagged<SpawnError>(\"SpawnError\")\n\n/**\n * Represents an error that occurs within a child process during execution.\n *\n * @category model\n * @since 1.0.0\n */", "export interface ExecutionError extends Data.Case {\n  readonly _tag: \"ExecutionError\"\n  readonly command: string\n  readonly stderr: string\n}\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const ExecutionError = Data.tagged<ExecutionError>(\"ExecutionError\")\n\n/**\n * @category service\n * @since 1.0.0\n */\nexport const ChildProcess = Context.Tag<ChildProcess>()\n\n/**\n * @category service\n * @since 1.0.0\n */\nexport const ChildProcessLive = Layer.succeed(\n  ChildProcess,\n  ChildProcess.of({\n    spawn: (command, executable) =>\n      Effect.try({\n        try: () =>\n          NodeChildProcess.spawnSync(command, [executable], {\n            stdio: \"pipe\",\n            encoding: \"utf8\"\n          }),\n        catch: (error) =>\n          SpawnError({\n            command,\n            args: [executable],\n            error: error instanceof Error ? error : new Error(String(error))\n          })\n      }).pipe(\n        Effect.flatMap(({ status, stderr }) =>\n          status === 0\n            ? Effect.unit\n            : Effect.fail(ExecutionError({ command, stderr }))\n        )\n      )\n  })\n)\n"]}
{"filename": "src/Markdown.ts", "chunked_list": ["/**\n * @since 1.0.0\n */\nimport { Option, Order, pipe, ReadonlyArray, ReadonlyRecord, String } from \"effect\"\nimport * as Prettier from \"prettier\"\nimport type * as Domain from \"./Domain\"\n\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst toc = require(\"markdown-toc\")\n\ntype Printable =\n  | Domain.Class\n  | Domain.Constant\n  | Domain.Export\n  | Domain.Function\n  | Domain.Interface\n  | Domain.TypeAlias\n\nconst bold = (s: string) => `**${s}**`\n\nconst fence = (language: string, content: string) =>\n  \"```\" + language + \"\\n\" + content + \"\\n\" + \"```\\n\\n\"\n\nconst paragraph = (...content: ReadonlyArray<string>) => \"\\n\" + content.join(\"\") + \"\\n\\n\"\n\nconst strikethrough = (content: string) => `~~${content}~~`\n\nconst createHeader = (level: number) => (content: string): string =>\n  \"#\".repeat(level) + \" \" + content + \"\\n\\n\"\n\nconst h1 = createHeader(1)\n\nconst h2 = createHeader(2)\n\nconst h3 = createHeader(3)\n\nconst getSince: (v: Option.Option<string>) => string = Option.match({\n  onNone: () => \"\",\n  onSome: (v) => paragraph(`Added in v${v}`)\n})\n\nconst getTitle = (s: string, deprecated: boolean, type?: string): string => {\n  const name = s.trim() === \"hasOwnProperty\" ? `${s} (function)` : s\n  const title = deprecated ? strikethrough(name) : name\n  return Option.fromNullable(type).pipe(\n    Option.match({\n      onNone: () => title,\n      onSome: (t) => title + ` ${t}`\n    })\n  )\n}\n\nconst getDescription = (d: Option.Option<string>): string =>\n  paragraph(Option.getOrElse(d, () => \"\"))\n\nconst getSignature = (s: string): string => paragraph(bold(\"Signature\")) + paragraph(fence(\"ts\", s))\n\nconst getSignatures = (ss: ReadonlyArray<string>): string =>\n  paragraph(bold(\"Signature\")) + paragraph(fence(\"ts\", ss.join(\"\\n\")))\n\nconst getExamples = (es: ReadonlyArray<string>): string =>\n  es\n    .map((code) => paragraph(bold(\"Example\")) + paragraph(fence(\"ts\", code)))\n    .join(\"\\n\\n\")\n\nconst getStaticMethod = (m: Domain.Method): string =>\n  paragraph(\n    h3(getTitle(m.name, m.deprecated, \"(static method)\")),\n    getDescription(m.description),\n    getSignatures(m.signatures),\n    getExamples(m.examples),\n    getSince(m.since)\n  )\n\nconst getMethod = (m: Domain.Method): string =>\n  paragraph(\n    h3(getTitle(m.name, m.deprecated, \"(method)\")),\n    getDescription(m.description),\n    getSignatures(m.signatures),\n    getExamples(m.examples),\n    getSince(m.since)\n  )\n\nconst getProperty = (p: Domain.Property): string =>\n  paragraph(\n    h3(getTitle(p.name, p.deprecated, \"(property)\")),\n    getDescription(p.description),\n    getSignature(p.signature),\n    getExamples(p.examples),\n    getSince(p.since)\n  )\n\nconst getStaticMethods = (methods: ReadonlyArray<Domain.Method>): string =>\n  ReadonlyArray.map(methods, (method) => getStaticMethod(method) + \"\\n\\n\").join(\n    \"\"\n  )\n\nconst getMethods = (methods: ReadonlyArray<Domain.Method>): string =>\n  ReadonlyArray.map(methods, (method) => getMethod(method) + \"\\n\\n\").join(\"\")\n\nconst getProperties = (properties: ReadonlyArray<Domain.Property>): string =>\n  ReadonlyArray.map(\n    properties,\n    (property) => getProperty(property) + \"\\n\\n\"\n  ).join(\"\")\n\nconst getModuleDescription = (module: Domain.Module): string =>\n  paragraph(\n    h2(getTitle(module.name, module.deprecated, \"overview\")),\n    getDescription(module.description),\n    getExamples(module.examples),\n    getSince(module.since)\n  )\n\nconst getMeta = (title: string, order: number): string =>\n  paragraph(\n    \"---\",\n    `\\n`,\n    `title: ${title}`,\n    `\\n`,\n    `nav_order: ${order}`,\n    `\\n`,\n    `parent: Modules`,\n    `\\n`,\n    \"---\"\n  )\n\nconst fromClass = (c: Domain.Class): string =>\n  paragraph(\n    paragraph(\n      h2(getTitle(c.name, c.deprecated, \"(class)\")),\n      getDescription(c.description),\n      getSignature(c.signature),\n      getExamples(c.examples),\n      getSince(c.since)\n    ),\n    getStaticMethods(c.staticMethods),\n    getMethods(c.methods),\n    getProperties(c.properties)\n  )\n\nconst fromConstant = (c: Domain.Constant): string =>\n  paragraph(\n    h2(getTitle(c.name, c.deprecated)),\n    getDescription(c.description),\n    getSignature(c.signature),\n    getExamples(c.examples),\n    getSince(c.since)\n  )\n\nconst fromExport = (e: Domain.Export): string =>\n  paragraph(\n    h2(getTitle(e.name, e.deprecated)),\n    getDescription(e.description),\n    getSignature(e.signature),\n    getExamples(e.examples),\n    getSince(e.since)\n  )\n\nconst fromFunction = (f: Domain.Function): string =>\n  paragraph(\n    h2(getTitle(f.name, f.deprecated)),\n    getDescription(f.description),\n    getSignatures(f.signatures),\n    getExamples(f.examples),\n    getSince(f.since)\n  )\n\nconst fromInterface = (i: Domain.Interface): string =>\n  paragraph(\n    h2(getTitle(i.name, i.deprecated, \"(interface)\")),\n    getDescription(i.description),\n    getSignature(i.signature),\n    getExamples(i.examples),\n    getSince(i.since)\n  )\n\nconst fromTypeAlias = (ta: Domain.TypeAlias): string =>\n  paragraph(", "const toc = require(\"markdown-toc\")\n\ntype Printable =\n  | Domain.Class\n  | Domain.Constant\n  | Domain.Export\n  | Domain.Function\n  | Domain.Interface\n  | Domain.TypeAlias\n\nconst bold = (s: string) => `**${s}**`\n\nconst fence = (language: string, content: string) =>\n  \"```\" + language + \"\\n\" + content + \"\\n\" + \"```\\n\\n\"\n\nconst paragraph = (...content: ReadonlyArray<string>) => \"\\n\" + content.join(\"\") + \"\\n\\n\"\n\nconst strikethrough = (content: string) => `~~${content}~~`\n\nconst createHeader = (level: number) => (content: string): string =>\n  \"#\".repeat(level) + \" \" + content + \"\\n\\n\"\n\nconst h1 = createHeader(1)\n\nconst h2 = createHeader(2)\n\nconst h3 = createHeader(3)\n\nconst getSince: (v: Option.Option<string>) => string = Option.match({\n  onNone: () => \"\",\n  onSome: (v) => paragraph(`Added in v${v}`)\n})\n\nconst getTitle = (s: string, deprecated: boolean, type?: string): string => {\n  const name = s.trim() === \"hasOwnProperty\" ? `${s} (function)` : s\n  const title = deprecated ? strikethrough(name) : name\n  return Option.fromNullable(type).pipe(\n    Option.match({\n      onNone: () => title,\n      onSome: (t) => title + ` ${t}`\n    })\n  )\n}\n\nconst getDescription = (d: Option.Option<string>): string =>\n  paragraph(Option.getOrElse(d, () => \"\"))\n\nconst getSignature = (s: string): string => paragraph(bold(\"Signature\")) + paragraph(fence(\"ts\", s))\n\nconst getSignatures = (ss: ReadonlyArray<string>): string =>\n  paragraph(bold(\"Signature\")) + paragraph(fence(\"ts\", ss.join(\"\\n\")))\n\nconst getExamples = (es: ReadonlyArray<string>): string =>\n  es\n    .map((code) => paragraph(bold(\"Example\")) + paragraph(fence(\"ts\", code)))\n    .join(\"\\n\\n\")\n\nconst getStaticMethod = (m: Domain.Method): string =>\n  paragraph(\n    h3(getTitle(m.name, m.deprecated, \"(static method)\")),\n    getDescription(m.description),\n    getSignatures(m.signatures),\n    getExamples(m.examples),\n    getSince(m.since)\n  )\n\nconst getMethod = (m: Domain.Method): string =>\n  paragraph(\n    h3(getTitle(m.name, m.deprecated, \"(method)\")),\n    getDescription(m.description),\n    getSignatures(m.signatures),\n    getExamples(m.examples),\n    getSince(m.since)\n  )\n\nconst getProperty = (p: Domain.Property): string =>\n  paragraph(\n    h3(getTitle(p.name, p.deprecated, \"(property)\")),\n    getDescription(p.description),\n    getSignature(p.signature),\n    getExamples(p.examples),\n    getSince(p.since)\n  )\n\nconst getStaticMethods = (methods: ReadonlyArray<Domain.Method>): string =>\n  ReadonlyArray.map(methods, (method) => getStaticMethod(method) + \"\\n\\n\").join(\n    \"\"\n  )\n\nconst getMethods = (methods: ReadonlyArray<Domain.Method>): string =>\n  ReadonlyArray.map(methods, (method) => getMethod(method) + \"\\n\\n\").join(\"\")\n\nconst getProperties = (properties: ReadonlyArray<Domain.Property>): string =>\n  ReadonlyArray.map(\n    properties,\n    (property) => getProperty(property) + \"\\n\\n\"\n  ).join(\"\")\n\nconst getModuleDescription = (module: Domain.Module): string =>\n  paragraph(\n    h2(getTitle(module.name, module.deprecated, \"overview\")),\n    getDescription(module.description),\n    getExamples(module.examples),\n    getSince(module.since)\n  )\n\nconst getMeta = (title: string, order: number): string =>\n  paragraph(\n    \"---\",\n    `\\n`,\n    `title: ${title}`,\n    `\\n`,\n    `nav_order: ${order}`,\n    `\\n`,\n    `parent: Modules`,\n    `\\n`,\n    \"---\"\n  )\n\nconst fromClass = (c: Domain.Class): string =>\n  paragraph(\n    paragraph(\n      h2(getTitle(c.name, c.deprecated, \"(class)\")),\n      getDescription(c.description),\n      getSignature(c.signature),\n      getExamples(c.examples),\n      getSince(c.since)\n    ),\n    getStaticMethods(c.staticMethods),\n    getMethods(c.methods),\n    getProperties(c.properties)\n  )\n\nconst fromConstant = (c: Domain.Constant): string =>\n  paragraph(\n    h2(getTitle(c.name, c.deprecated)),\n    getDescription(c.description),\n    getSignature(c.signature),\n    getExamples(c.examples),\n    getSince(c.since)\n  )\n\nconst fromExport = (e: Domain.Export): string =>\n  paragraph(\n    h2(getTitle(e.name, e.deprecated)),\n    getDescription(e.description),\n    getSignature(e.signature),\n    getExamples(e.examples),\n    getSince(e.since)\n  )\n\nconst fromFunction = (f: Domain.Function): string =>\n  paragraph(\n    h2(getTitle(f.name, f.deprecated)),\n    getDescription(f.description),\n    getSignatures(f.signatures),\n    getExamples(f.examples),\n    getSince(f.since)\n  )\n\nconst fromInterface = (i: Domain.Interface): string =>\n  paragraph(\n    h2(getTitle(i.name, i.deprecated, \"(interface)\")),\n    getDescription(i.description),\n    getSignature(i.signature),\n    getExamples(i.examples),\n    getSince(i.since)\n  )\n\nconst fromTypeAlias = (ta: Domain.TypeAlias): string =>\n  paragraph(", "    h2(getTitle(ta.name, ta.deprecated, \"(type alias)\")),\n    getDescription(ta.description),\n    getSignature(ta.signature),\n    getExamples(ta.examples),\n    getSince(ta.since)\n  )\n\n/** @internal */\nexport const fromPrintable = (p: Printable): string => {\n  switch (p._tag) {\n    case \"Class\":\n      return fromClass(p)\n    case \"Constant\":\n      return fromConstant(p)\n    case \"Export\":\n      return fromExport(p)\n    case \"Function\":\n      return fromFunction(p)\n    case \"Interface\":\n      return fromInterface(p)\n    case \"TypeAlias\":\n      return fromTypeAlias(p)\n  }\n}\n\nconst getPrintables = (module: Domain.Module): ReadonlyArray<Printable> =>\n  ReadonlyArray.flatten<Printable>([\n    module.classes,\n    module.constants,\n    module.exports,\n    module.functions,\n    module.interfaces,\n    module.typeAliases\n  ])\n\n/**\n * @category printers\n * @since 1.0.0\n */\nexport const printModule = (module: Domain.Module, order: number): string => {\n  const DEFAULT_CATEGORY = \"utils\"\n\n  const header = getMeta(module.path.slice(1).join(\"/\"), order)\n\n  const description = paragraph(getModuleDescription(module))\n\n  const content = pipe(\n    getPrintables(module),\n    ReadonlyArray.groupBy(({ category }) => Option.getOrElse(category, () => DEFAULT_CATEGORY)),\n    ReadonlyRecord.toEntries,\n    ReadonlyArray.sort(\n      Order.mapInput(String.Order, ([category]: [string, unknown]) => category)\n    ),\n    ReadonlyArray.map(([category, printables]) =>\n      [\n        h1(category),\n        ...pipe(\n          printables,\n          ReadonlyArray.sort(\n            Order.mapInput(\n              String.Order,\n              (printable: Printable) => printable.name\n            )\n          ),\n          ReadonlyArray.map(fromPrintable)\n        )\n      ].join(\"\\n\")\n    )\n  ).join(\"\\n\")\n\n  const tableOfContents = (content: string) =>\n    \"<h2 class=\\\"text-delta\\\">Table of contents</h2>\\n\\n\"\n    + toc(content).content\n    + \"\\n\\n\"\n\n  return prettify(\n    [\n      header,\n      description,\n      \"---\\n\",\n      tableOfContents(content),\n      \"---\\n\",\n      content\n    ].join(\"\\n\")\n  )\n}\n\nconst defaultPrettierOptions: Prettier.Options = {\n  parser: \"markdown\",\n  semi: false,\n  singleQuote: true,\n  printWidth: 120\n}\n\n/** @internal */\nexport const prettify = (s: string): string => Prettier.format(s, defaultPrettierOptions)\n"]}
{"filename": "src/Logger.ts", "chunked_list": ["/**\n * @since 1.0.0\n */\nimport chalk from \"chalk\"\nimport { Logger } from \"effect\"\n\n/**\n * @category logging\n * @since 1.0.0\n */", " * @since 1.0.0\n */\nexport const SimpleLogger = Logger.make(({ logLevel, message }) => {\n  if (logLevel._tag === \"Debug\") {\n    globalThis.console.log(chalk.gray(`[${logLevel.label}] ${message}`))\n  } else {\n    globalThis.console.log(`[${logLevel.label}] ${message}`)\n  }\n})\n"]}
{"filename": "src/Domain.ts", "chunked_list": ["/**\n * @since 1.0.0\n */\nimport { Order as order, String } from \"effect\"\nimport type { Option } from \"effect\"\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport interface Module extends Documentable {\n  readonly path: ReadonlyArray<string>\n  readonly classes: ReadonlyArray<Class>\n  readonly interfaces: ReadonlyArray<Interface>\n  readonly functions: ReadonlyArray<Function>\n  readonly typeAliases: ReadonlyArray<TypeAlias>\n  readonly constants: ReadonlyArray<Constant>\n  readonly exports: ReadonlyArray<Export>\n}\n\n/**\n * @category model\n * @since 1.0.0\n */", " * @since 1.0.0\n */\nexport interface Module extends Documentable {\n  readonly path: ReadonlyArray<string>\n  readonly classes: ReadonlyArray<Class>\n  readonly interfaces: ReadonlyArray<Interface>\n  readonly functions: ReadonlyArray<Function>\n  readonly typeAliases: ReadonlyArray<TypeAlias>\n  readonly constants: ReadonlyArray<Constant>\n  readonly exports: ReadonlyArray<Export>\n}\n\n/**\n * @category model\n * @since 1.0.0\n */", "export interface Documentable {\n  readonly name: string\n  readonly description: Option.Option<string>\n  readonly since: Option.Option<string>\n  readonly deprecated: boolean\n  readonly examples: ReadonlyArray<Example>\n  readonly category: Option.Option<string>\n}\n\n/**\n * @category model\n * @since 1.0.0\n */", "export interface Class extends Documentable {\n  readonly _tag: \"Class\"\n  readonly signature: string\n  readonly methods: ReadonlyArray<Method>\n  readonly staticMethods: ReadonlyArray<Method>\n  readonly properties: ReadonlyArray<Property>\n}\n\n/**\n * @category model\n * @since 1.0.0\n */", "export interface Method extends Documentable {\n  readonly signatures: ReadonlyArray<string>\n}\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport interface Property extends Documentable {\n  readonly signature: string\n}\n\n/**\n * @category model\n * @since 1.0.0\n */", "export interface Property extends Documentable {\n  readonly signature: string\n}\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport interface Interface extends Documentable {\n  readonly _tag: \"Interface\"\n  readonly signature: string\n}\n\n/**\n * @category model\n * @since 1.0.0\n */", "export interface Interface extends Documentable {\n  readonly _tag: \"Interface\"\n  readonly signature: string\n}\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport interface Function extends Documentable {\n  readonly _tag: \"Function\"\n  readonly signatures: ReadonlyArray<string>\n}\n\n/**\n * @category model\n * @since 1.0.0\n */", "export interface Function extends Documentable {\n  readonly _tag: \"Function\"\n  readonly signatures: ReadonlyArray<string>\n}\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport interface TypeAlias extends Documentable {\n  readonly _tag: \"TypeAlias\"\n  readonly signature: string\n}\n\n/**\n * @category model\n * @since 1.0.0\n */", "export interface TypeAlias extends Documentable {\n  readonly _tag: \"TypeAlias\"\n  readonly signature: string\n}\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport interface Constant extends Documentable {\n  readonly _tag: \"Constant\"\n  readonly signature: string\n}\n\n/**\n * @category model\n * @since 1.0.0\n */", "export interface Constant extends Documentable {\n  readonly _tag: \"Constant\"\n  readonly signature: string\n}\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport interface Export extends Documentable {\n  readonly _tag: \"Export\"\n  readonly signature: string\n}\n\n/**\n * @category model\n * @since 1.0.0\n */", "export interface Export extends Documentable {\n  readonly _tag: \"Export\"\n  readonly signature: string\n}\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport type Example = string\n\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const createDocumentable = (\n  name: string,\n  description: Option.Option<string>,\n  since: Option.Option<string>,\n  deprecated: boolean,\n  examples: ReadonlyArray<Example>,\n  category: Option.Option<string>\n): Documentable => ({\n  name,\n  description,\n  since,\n  deprecated,\n  examples,\n  category\n})\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const createModule = (\n  documentable: Documentable,\n  path: ReadonlyArray<string>,\n  classes: ReadonlyArray<Class>,\n  interfaces: ReadonlyArray<Interface>,\n  functions: ReadonlyArray<Function>,\n  typeAliases: ReadonlyArray<TypeAlias>,\n  constants: ReadonlyArray<Constant>,\n  exports: ReadonlyArray<Export>\n): Module => ({\n  ...documentable,\n  path,\n  classes,\n  interfaces,\n  functions,\n  typeAliases,\n  constants,\n  exports\n})\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const createClass = (\n  documentable: Documentable,\n  signature: string,\n  methods: ReadonlyArray<Method>,\n  staticMethods: ReadonlyArray<Method>,\n  properties: ReadonlyArray<Property>\n): Class => ({\n  _tag: \"Class\",\n  ...documentable,\n  signature,\n  methods,\n  staticMethods,\n  properties\n})\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const createConstant = (\n  documentable: Documentable,\n  signature: string\n): Constant => ({\n  _tag: \"Constant\",\n  ...documentable,\n  signature\n})\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const createMethod = (\n  documentable: Documentable,\n  signatures: ReadonlyArray<string>\n): Method => ({\n  ...documentable,\n  signatures\n})\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const createProperty = (\n  documentable: Documentable,\n  signature: string\n): Property => ({\n  ...documentable,\n  signature\n})\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const createInterface = (\n  documentable: Documentable,\n  signature: string\n): Interface => ({\n  _tag: \"Interface\",\n  ...documentable,\n  signature\n})\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const createFunction = (\n  documentable: Documentable,\n  signatures: ReadonlyArray<string>\n): Function => ({\n  _tag: \"Function\",\n  ...documentable,\n  signatures\n})\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const createTypeAlias = (\n  documentable: Documentable,\n  signature: string\n): TypeAlias => ({\n  _tag: \"TypeAlias\",\n  ...documentable,\n  signature\n})\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const createExport = (\n  documentable: Documentable,\n  signature: string\n): Export => ({\n  _tag: \"Export\",\n  ...documentable,\n  signature\n})\n\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Order: order.Order<Module> = order.mapInput(\n  String.Order,\n  (module: Module) => module.path.join(\"/\").toLowerCase()\n)\n", "export type Example = string\n\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const createDocumentable = (\n  name: string,\n  description: Option.Option<string>,\n  since: Option.Option<string>,\n  deprecated: boolean,\n  examples: ReadonlyArray<Example>,\n  category: Option.Option<string>\n): Documentable => ({\n  name,\n  description,\n  since,\n  deprecated,\n  examples,\n  category\n})\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const createModule = (\n  documentable: Documentable,\n  path: ReadonlyArray<string>,\n  classes: ReadonlyArray<Class>,\n  interfaces: ReadonlyArray<Interface>,\n  functions: ReadonlyArray<Function>,\n  typeAliases: ReadonlyArray<TypeAlias>,\n  constants: ReadonlyArray<Constant>,\n  exports: ReadonlyArray<Export>\n): Module => ({\n  ...documentable,\n  path,\n  classes,\n  interfaces,\n  functions,\n  typeAliases,\n  constants,\n  exports\n})\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const createClass = (\n  documentable: Documentable,\n  signature: string,\n  methods: ReadonlyArray<Method>,\n  staticMethods: ReadonlyArray<Method>,\n  properties: ReadonlyArray<Property>\n): Class => ({\n  _tag: \"Class\",\n  ...documentable,\n  signature,\n  methods,\n  staticMethods,\n  properties\n})\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const createConstant = (\n  documentable: Documentable,\n  signature: string\n): Constant => ({\n  _tag: \"Constant\",\n  ...documentable,\n  signature\n})\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const createMethod = (\n  documentable: Documentable,\n  signatures: ReadonlyArray<string>\n): Method => ({\n  ...documentable,\n  signatures\n})\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const createProperty = (\n  documentable: Documentable,\n  signature: string\n): Property => ({\n  ...documentable,\n  signature\n})\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const createInterface = (\n  documentable: Documentable,\n  signature: string\n): Interface => ({\n  _tag: \"Interface\",\n  ...documentable,\n  signature\n})\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const createFunction = (\n  documentable: Documentable,\n  signatures: ReadonlyArray<string>\n): Function => ({\n  _tag: \"Function\",\n  ...documentable,\n  signatures\n})\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const createTypeAlias = (\n  documentable: Documentable,\n  signature: string\n): TypeAlias => ({\n  _tag: \"TypeAlias\",\n  ...documentable,\n  signature\n})\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const createExport = (\n  documentable: Documentable,\n  signature: string\n): Export => ({\n  _tag: \"Export\",\n  ...documentable,\n  signature\n})\n\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Order: order.Order<Module> = order.mapInput(\n  String.Order,\n  (module: Module) => module.path.join(\"/\").toLowerCase()\n)\n"]}
{"filename": "src/FileSystem.ts", "chunked_list": ["/**\n * @since 1.0.0\n */\nimport { Context, Data, Effect, Layer } from \"effect\"\nimport * as NodeFS from \"fs-extra\"\nimport * as Glob from \"glob\"\nimport * as Rimraf from \"rimraf\"\n\n/**\n * Represents a file system which can be read from and written to.", "/**\n * Represents a file system which can be read from and written to.\n *\n * @category model\n * @since 1.0.0\n */\nexport interface FileSystem {\n  /**\n   * Read a file from the file system at the specified `path`.\n   */\n  readFile(path: string): Effect.Effect<never, ReadFileError, string>\n  /**\n   * Read a `.json` file from the file system at the specified `path` and parse\n   * the contents.\n   */\n  readJsonFile(path: string): Effect.Effect<never, ReadFileError | ParseJsonError, unknown>\n  /**\n   * Write a file to the specified `path` containing the specified `content`.\n   */\n  writeFile(path: string, content: string): Effect.Effect<never, WriteFileError, void>\n  /**\n   * Removes a file from the file system at the specified `path`.\n   */\n  removeFile(path: string): Effect.Effect<never, RemoveFileError, void>\n  /**\n   * Checks if the specified `path` exists on the file system.\n   */\n  pathExists(path: string): Effect.Effect<never, ReadFileError, boolean>\n  /**\n   * Find all files matching the specified `glob` pattern, optionally excluding\n   * files matching the provided `exclude` patterns.\n   */\n  glob(\n    pattern: string,\n    exclude?: ReadonlyArray<string>\n  ): Effect.Effect<never, GlobError, ReadonlyArray<string>>\n}\n\n/**\n * Represents an error that occurs when attempting to read a file from the\n * file system.\n *\n * @category model\n * @since 1.0.0\n */", "export interface ReadFileError extends Data.Case {\n  readonly _tag: \"ReadFileError\"\n  readonly path: string\n  readonly error: Error\n}\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const ReadFileError = Data.tagged<ReadFileError>(\"ReadFileError\")\n\n/**\n * Represents an error that occurs when attempting to write a file to the\n * file system.\n *\n * @category model\n * @since 1.0.0\n */", "export interface WriteFileError extends Data.Case {\n  readonly _tag: \"WriteFileError\"\n  readonly path: string\n  readonly error: Error\n}\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const WriteFileError = Data.tagged<WriteFileError>(\"WriteFileError\")\n\n/**\n * Represents an error that occurs when attempting to remove a file from the\n * file system.\n *\n * @category model\n * @since 1.0.0\n */", "export interface RemoveFileError extends Data.Case {\n  readonly _tag: \"RemoveFileError\"\n  readonly path: string\n  readonly error: Error\n}\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const RemoveFileError = Data.tagged<RemoveFileError>(\"RemoveFileError\")\n\n/**\n * Represents an error that occurs when attempting to parse JSON content.\n *\n * @category model\n * @since 1.0.0\n */", "export interface ParseJsonError extends Data.Case {\n  readonly _tag: \"ParseJsonError\"\n  readonly content: string\n  readonly error: Error\n}\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const ParseJsonError = Data.tagged<ParseJsonError>(\"ParseJsonError\")\n\n/**\n * Represents an error that occurs when attempting to execute a glob pattern to\n * find multiple files on the file system.\n *\n * @category model\n * @since 1.0.0\n */", "export interface GlobError extends Data.Case {\n  readonly _tag: \"GlobError\"\n  readonly pattern: string\n  readonly exclude: ReadonlyArray<string>\n  readonly error: Error\n}\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const GlobError = Data.tagged<GlobError>(\"GlobError\")\n\n/**\n * @category service\n * @since 1.0.0\n */\nexport const FileSystem = Context.Tag<FileSystem>()\n\n/**\n * @category service\n * @since 1.0.0\n */\nexport const FileSystemLive = Layer.effect(\n  FileSystem,\n  Effect.sync(() => {\n    const readFile = (path: string): Effect.Effect<never, ReadFileError, string> =>\n      Effect.async((resume) =>\n        NodeFS.readFile(path, \"utf8\", (error, data) => {", "          if (error) {\n            resume(Effect.fail(ReadFileError({ path, error })))\n          } else {\n            resume(Effect.succeed(data))\n          }\n        })\n      )\n    const readJsonFile = (\n      path: string\n    ): Effect.Effect<never, ReadFileError | ParseJsonError, unknown> =>\n      Effect.flatMap(readFile(path), (content) =>\n        Effect.try({\n          try: () => JSON.parse(content),\n          catch: (error) =>\n            ParseJsonError({\n              content,\n              error: error instanceof Error ? error : new Error(String(error))\n            })\n        }))\n    const writeFile = (path: string, content: string): Effect.Effect<never, WriteFileError, void> =>\n      Effect.async((resume) =>\n        NodeFS.outputFile(path, content, \"utf8\", (error) => {", "          if (error) {\n            resume(Effect.fail(WriteFileError({ path, error })))\n          } else {\n            resume(Effect.unit)\n          }\n        })\n      )\n    const removeFile = (path: string): Effect.Effect<never, RemoveFileError, void> =>\n      Effect.tryPromise({\n        try: () => Rimraf.rimraf(path),\n        catch: (error) =>\n          RemoveFileError({\n            error: error instanceof Error ? error : new Error(String(error)),\n            path\n          })\n      })\n\n    const pathExists = (path: string): Effect.Effect<never, ReadFileError, boolean> =>\n      Effect.async((resume) =>\n        NodeFS.pathExists(path, (error, data) => {", "          if (error) {\n            resume(Effect.fail(ReadFileError({ error, path })))\n          } else {\n            resume(Effect.succeed(data))\n          }\n        })\n      )\n    const glob = (\n      pattern: string,\n      exclude: Array<string> = []\n    ): Effect.Effect<never, GlobError, Array<string>> =>\n      Effect.tryPromise({\n        try: () => Glob.glob(pattern, { ignore: exclude, withFileTypes: false }),\n        catch: (error) =>\n          GlobError({\n            error: error instanceof Error ? error : new Error(String(error)),\n            exclude,\n            pattern\n          })\n      })\n    return FileSystem.of({\n      readFile,\n      readJsonFile,\n      writeFile,\n      removeFile,\n      pathExists,\n      glob\n    })\n  })\n)\n\n/**\n * Represents a file which can be optionally overwriteable.\n *\n * @category model\n * @since 1.0.0\n */", "export interface File extends\n  Data.Data<{\n    readonly path: string\n    readonly content: string\n    readonly overwrite: boolean\n  }>\n{}\n\n/**\n * By default files are readonly (`overwrite = false`).\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const makeFile = (\n  path: string,\n  content: string,\n  overwrite = false\n): File =>\n  Data.struct({\n    path,\n    content,\n    overwrite\n  })\n"]}
{"filename": "src/Config.ts", "chunked_list": ["/**\n * @since 1.0.0\n */\nimport * as Schema from \"@effect/schema/Schema\"\nimport * as TreeFormatter from \"@effect/schema/TreeFormatter\"\nimport chalk from \"chalk\"\nimport { Context, Data, Effect, Layer, Option } from \"effect\"\nimport * as NodePath from \"node:path\"\nimport * as FileSystem from \"./FileSystem\"\nimport * as Process from \"./Process\"", "import * as FileSystem from \"./FileSystem\"\nimport * as Process from \"./Process\"\n\nconst PACKAGE_JSON_FILE_NAME = \"package.json\"\nconst CONFIG_FILE_NAME = \"docgen.json\"\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport interface Config {\n  readonly projectName: string\n  readonly projectHomepage: string\n  readonly srcDir: string\n  readonly outDir: string\n  readonly theme: string\n  readonly enableSearch: boolean\n  readonly enforceDescriptions: boolean\n  readonly enforceExamples: boolean\n  readonly enforceVersion: boolean\n  readonly exclude: ReadonlyArray<string>\n  readonly parseCompilerOptions: Record<string, unknown>\n  readonly examplesCompilerOptions: Record<string, unknown>\n}\n\n/**\n * @category model\n * @since 1.0.0\n */", " * @since 1.0.0\n */\nexport interface Config {\n  readonly projectName: string\n  readonly projectHomepage: string\n  readonly srcDir: string\n  readonly outDir: string\n  readonly theme: string\n  readonly enableSearch: boolean\n  readonly enforceDescriptions: boolean\n  readonly enforceExamples: boolean\n  readonly enforceVersion: boolean\n  readonly exclude: ReadonlyArray<string>\n  readonly parseCompilerOptions: Record<string, unknown>\n  readonly examplesCompilerOptions: Record<string, unknown>\n}\n\n/**\n * @category model\n * @since 1.0.0\n */", "export interface ConfigError extends Data.Case {\n  readonly _tag: \"ConfigError\"\n  readonly message: string\n}\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const ConfigError = Data.tagged<ConfigError>(\"ConfigError\")\n\n/**\n * @category service\n * @since 1.0.0\n */\nexport const Config = Context.Tag<Config>()\n\nconst ConfigSchema = Schema.struct({\n  projectHomepage: Schema.string,\n  srcDir: Schema.string,\n  outDir: Schema.string,\n  theme: Schema.string,\n  enableSearch: Schema.boolean,\n  enforceDescriptions: Schema.boolean,\n  enforceExamples: Schema.boolean,\n  enforceVersion: Schema.boolean,\n  exclude: Schema.array(Schema.string),\n  parseCompilerOptions: Schema.record(Schema.string, Schema.unknown),\n  examplesCompilerOptions: Schema.record(Schema.string, Schema.unknown)\n})\n\nconst PartialConfigSchema = Schema.partial(ConfigSchema)\n\nconst PackageJsonSchema = Schema.struct({\n  name: Schema.string,\n  homepage: Schema.string\n})\n\nconst parseJsonFile = <I, A>(\n  schema: Schema.Schema<I, A>,\n  path: string,\n  fileSystem: FileSystem.FileSystem\n): Effect.Effect<never, ConfigError | FileSystem.ReadFileError | FileSystem.ParseJsonError, A> =>\n  fileSystem.readJsonFile(path).pipe(\n    Effect.flatMap((content) =>\n      Schema.parse(schema)(content).pipe(\n        Effect.mapError((e) => ConfigError({ message: TreeFormatter.formatErrors(e.errors) }))\n      )\n    )\n  )\n\nconst getDefaultConfig = (projectName: string, projectHomepage: string): Config => ({\n  projectName,\n  projectHomepage,\n  srcDir: \"src\",\n  outDir: \"docs\",\n  theme: \"pmarsceill/just-the-docs\",\n  enableSearch: true,\n  enforceDescriptions: false,\n  enforceExamples: false,\n  enforceVersion: true,\n  exclude: [],\n  parseCompilerOptions: {},\n  examplesCompilerOptions: {}\n})\n\nconst loadConfig = (\n  path: string,\n  fileSystem: FileSystem.FileSystem\n): Effect.Effect<\n  never,\n  ConfigError | FileSystem.ReadFileError | FileSystem.ParseJsonError,\n  Option.Option<Schema.To<typeof PartialConfigSchema>>\n> =>", "  Effect.if(fileSystem.pathExists(path), {\n    onTrue: Effect.logInfo(chalk.bold(\"Configuration file found\")).pipe(\n      Effect.zipRight(parseJsonFile(PartialConfigSchema, path, fileSystem)),\n      Effect.asSome\n    ),\n    onFalse: Effect.as(\n      Effect.logInfo(\n        chalk.bold(\"No configuration file detected, using default configuration\")\n      ),\n      Option.none()\n    )\n  })\n\n/**\n * @category service\n * @since 1.0.0\n */\nexport const ConfigLive = Layer.effect(\n  Config,\n  Effect.gen(function*($) {\n    // Extract the requisite services\n    const process = yield* $(Process.Process)\n    const fileSystem = yield* $(FileSystem.FileSystem)\n    const cwd = yield* $(process.cwd)\n\n    // Read and parse the package.json\n    const packageJsonPath = NodePath.join(cwd, PACKAGE_JSON_FILE_NAME)\n    const packageJson = yield* $(parseJsonFile(PackageJsonSchema, packageJsonPath, fileSystem))\n\n    // Read and resolve the configuration\n    const defaultConfig = getDefaultConfig(packageJson.name, packageJson.homepage)\n    const configPath = NodePath.join(cwd, CONFIG_FILE_NAME)\n    const maybeConfig = yield* $(loadConfig(configPath, fileSystem))\n\n    return Config.of(\n      Option.match(maybeConfig, {\n        onNone: () => defaultConfig,\n        onSome: (loadedConfig) => ({ ...defaultConfig, ...loadedConfig })\n      })\n    )\n  })\n)\n"]}
{"filename": "src/index.ts", "chunked_list": ["/**\n * @since 1.0.0\n */\nimport { Effect } from \"effect\"\nimport * as Core from \"./Core\"\n\n/**\n * @category main\n * @since 1.0.0\n */", " * @since 1.0.0\n */\nexport const main = Effect.tapErrorCause(Core.main, Effect.logError)\n"]}
{"filename": "src/Parser.ts", "chunked_list": ["/**\n * @since 1.0.0\n */\nimport chalk from \"chalk\"\nimport * as doctrine from \"doctrine\"\nimport {\n  Context,\n  Effect,\n  Option,\n  Order,", "  Option,\n  Order,\n  pipe,\n  Predicate,\n  ReadonlyArray,\n  ReadonlyRecord,\n  String\n} from \"effect\"\nimport { flow } from \"effect/Function\"\nimport * as NodePath from \"node:path\"", "import { flow } from \"effect/Function\"\nimport * as NodePath from \"node:path\"\nimport * as ast from \"ts-morph\"\nimport * as Config from \"./Config\"\nimport * as Domain from \"./Domain\"\nimport type * as FileSystem from \"./FileSystem\"\n\n/** @internal */\nexport interface Source {\n  readonly path: ReadonlyArray.NonEmptyReadonlyArray<string>\n  readonly sourceFile: ast.SourceFile\n}\n\n/** @internal */\nexport const Source = Context.Tag<Source>()\n", "export interface Source {\n  readonly path: ReadonlyArray.NonEmptyReadonlyArray<string>\n  readonly sourceFile: ast.SourceFile\n}\n\n/** @internal */\nexport const Source = Context.Tag<Source>()\n\ninterface Comment {\n  readonly description: Option.Option<string>\n  readonly tags: ReadonlyRecord.ReadonlyRecord<\n    ReadonlyArray.NonEmptyReadonlyArray<Option.Option<string>>\n  >\n}\n", "interface Comment {\n  readonly description: Option.Option<string>\n  readonly tags: ReadonlyRecord.ReadonlyRecord<\n    ReadonlyArray.NonEmptyReadonlyArray<Option.Option<string>>\n  >\n}\n\ninterface CommentInfo {\n  readonly description: Option.Option<string>\n  readonly since: Option.Option<string>\n  readonly deprecated: boolean\n  readonly examples: ReadonlyArray<Domain.Example>\n  readonly category: Option.Option<string>\n}\n\nconst createCommentInfo = (\n  description: Option.Option<string>,\n  since: Option.Option<string>,\n  deprecated: boolean,\n  examples: ReadonlyArray<Domain.Example>,\n  category: Option.Option<string>\n): CommentInfo => ({\n  description,\n  since,\n  deprecated,\n  examples,\n  category\n})\n\nconst every = <A>(predicates: ReadonlyArray<Predicate.Predicate<A>>) => (a: A): boolean =>\n  predicates.every((p) => p(a))\n\nconst some = <A>(predicates: ReadonlyArray<Predicate.Predicate<A>>) => (a: A): boolean =>\n  predicates.some((p) => p(a))\n\nconst byName = pipe(\n  String.Order,\n  Order.mapInput(({ name }: { name: string }) => name)\n)\n\nconst sortModules = ReadonlyArray.sort(Domain.Order)\n\nconst isNonEmptyString = (s: string) => s.length > 0\n\n/**\n * @internal\n */\nexport const stripImportTypes = (s: string): string => s.replace(/import\\(\"((?!\").)*\"\\)./g, \"\")\n\nconst getJSDocText: (jsdocs: ReadonlyArray<ast.JSDoc>) => string = ReadonlyArray.matchRight({\n  onEmpty: () => \"\",\n  onNonEmpty: (_, last) => last.getText()\n})\n\nconst hasTag = (tag: string) => (comment: Comment) =>\n  pipe(comment.tags, ReadonlyRecord.get(tag), Option.isSome)\n\nconst hasInternalTag = hasTag(\"internal\")\n\nconst hasIgnoreTag = hasTag(\"ignore\")\n\nconst shouldIgnore: Predicate.Predicate<Comment> = some([hasInternalTag, hasIgnoreTag])\n\nconst isVariableDeclarationList = (\n  u: ast.VariableDeclarationList | ast.CatchClause\n): u is ast.VariableDeclarationList => u.getKind() === ast.ts.SyntaxKind.VariableDeclarationList\n\nconst isVariableStatement = (\n  u:\n    | ast.VariableStatement\n    | ast.ForStatement\n    | ast.ForOfStatement\n    | ast.ForInStatement\n): u is ast.VariableStatement => u.getKind() === ast.ts.SyntaxKind.VariableStatement\n\nconst getMissingError = (\n  what: string,\n  path: ReadonlyArray<string>,\n  name: string\n): string =>\n  `Missing ${chalk.bold(what)} in ${\n    chalk.bold(\n      path.join(\"/\") + \"#\" + name\n    )\n  } documentation`\n\nconst getMissingTagError = (\n  tag: string,\n  path: ReadonlyArray<string>,\n  name: string\n): string =>\n  `Missing ${chalk.bold(tag)} tag in ${\n    chalk.bold(\n      path.join(\"/\") + \"#\" + name\n    )\n  } documentation`\n\nconst getSinceTag = (name: string, comment: Comment) =>\n  pipe(\n    Effect.all([Config.Config, Source]),\n    Effect.flatMap(([config, source]) =>\n      pipe(\n        comment.tags,\n        ReadonlyRecord.get(\"since\"),\n        Option.flatMap(ReadonlyArray.headNonEmpty),\n        Effect.asSome,\n        Effect.catchAll(() =>\n          config.enforceVersion\n            ? Effect.fail(getMissingTagError(\"@since\", source.path, name))\n            : Effect.succeed(Option.none<string>())\n        )\n      )\n    )\n  )\n\nconst getCategoryTag = (name: string, comment: Comment) =>\n  Effect.flatMap(Source, (source) =>\n    pipe(\n      comment.tags,\n      ReadonlyRecord.get(\"category\"),\n      Option.flatMap(ReadonlyArray.headNonEmpty),\n      Effect.asSome,\n      Effect.catchAll(() =>\n        ReadonlyRecord.has(comment.tags, \"category\")\n          ? Effect.fail(getMissingTagError(\"@category\", source.path, name))\n          : Effect.succeed(Option.none<string>())\n      )\n    ))\n\nconst getDescription = (name: string, comment: Comment) =>\n  pipe(\n    Effect.all([Config.Config, Source]),\n    Effect.flatMap(([config, source]) =>\n      pipe(\n        comment.description,\n        Option.match({\n          onNone: () =>\n            config.enforceDescriptions\n              ? Effect.fail(getMissingError(\"description\", source.path, name))\n              : Effect.succeed(Option.none()),\n          onSome: (description) => Effect.succeed(Option.some(description))\n        })\n      )\n    )\n  )\n\nconst getExamples = (name: string, comment: Comment, isModule: boolean) =>\n  pipe(\n    Effect.all([Config.Config, Source]),\n    Effect.flatMap(([config, source]) =>\n      pipe(\n        comment.tags,\n        ReadonlyRecord.get(\"example\"),\n        Option.map(ReadonlyArray.compact),\n        Option.match({\n          onNone: () =>\n            config.enforceExamples && !isModule\n              ? Effect.fail(getMissingTagError(\"@example\", source.path, name))\n              : Effect.succeed([]),\n          onSome: (examples) =>\n            config.enforceExamples &&\n              ReadonlyArray.isEmptyArray(examples) &&\n              !isModule\n              ? Effect.fail(getMissingTagError(\"@example\", source.path, name))\n              : Effect.succeed(examples)\n        })\n      )\n    )\n  )\n\n/**\n * @internal\n */\nexport const getCommentInfo = (name: string, isModule = false) => (text: string) =>\n  pipe(\n    Effect.Do,\n    Effect.let(\"comment\", () => parseComment(text)),\n    Effect.bind(\"since\", ({ comment }) => getSinceTag(name, comment)),\n    Effect.bind(\"category\", ({ comment }) => getCategoryTag(name, comment)),\n    Effect.bind(\"description\", ({ comment }) => getDescription(name, comment)),\n    Effect.bind(\"examples\", ({ comment }) => getExamples(name, comment, isModule)),\n    Effect.bind(\"deprecated\", ({ comment }) =>\n      Effect.succeed(\n        pipe(comment.tags, ReadonlyRecord.get(\"deprecated\"), Option.isSome)\n      )),\n    Effect.map(({ category, deprecated, description, examples, since }) => {\n      return createCommentInfo(\n        description,\n        since,\n        deprecated,\n        examples,\n        category\n      )\n    })\n  )\n\n/**\n * @internal\n */\nexport const parseComment = (text: string): Comment => {\n  const annotation: doctrine.Annotation = doctrine.parse(text, {\n    unwrap: true\n  })\n  const tags = pipe(\n    annotation.tags,\n    ReadonlyArray.groupBy((tag) => tag.title),\n    ReadonlyRecord.map(\n      ReadonlyArray.mapNonEmpty((tag) =>\n        pipe(\n          Option.fromNullable(tag.description),\n          Option.filter(isNonEmptyString)\n        )\n      )\n    )\n  )\n  const description = pipe(\n    Option.fromNullable(annotation.description),\n    Option.filter(isNonEmptyString)\n  )\n  return { description, tags }\n}\n\n// -------------------------------------------------------------------------------------\n// interfaces\n// -------------------------------------------------------------------------------------\n\nconst parseInterfaceDeclaration = (id: ast.InterfaceDeclaration) =>\n  pipe(\n    getJSDocText(id.getJsDocs()),\n    getCommentInfo(id.getName()),\n    Effect.map((info) =>\n      Domain.createInterface(\n        Domain.createDocumentable(\n          id.getName(),\n          info.description,\n          info.since,\n          info.deprecated,\n          info.examples,\n          info.category\n        ),\n        id.getText()\n      )\n    )\n  )\n\n/**\n * @category parsers\n * @since 1.0.0\n */\nexport const parseInterfaces = pipe(\n  Effect.map(Source, (source) =>\n    pipe(\n      source.sourceFile.getInterfaces(),\n      ReadonlyArray.filter(\n        every<ast.InterfaceDeclaration>([\n          (id) => id.isExported(),\n          (id) =>\n            pipe(\n              id.getJsDocs(),\n              Predicate.not(flow(getJSDocText, parseComment, shouldIgnore))\n            )\n        ])\n      )\n    )),\n  Effect.flatMap((interfaceDeclarations) =>\n    pipe(\n      interfaceDeclarations,\n      Effect.validateAll(parseInterfaceDeclaration),\n      Effect.map(ReadonlyArray.sort(byName))\n    )\n  )\n)\n\n// -------------------------------------------------------------------------------------\n// functions\n// -------------------------------------------------------------------------------------\n\nconst getFunctionDeclarationSignature = (\n  f: ast.FunctionDeclaration\n): string => {\n  const text = f.getText()\n  return pipe(\n    Option.fromNullable(f.compilerNode.body),\n    Option.match({\n      onNone: () => text.replace(\"export function \", \"export declare function \"),\n      onSome: (body) => {\n        const end = body.getStart() - f.getStart() - 1\n        return text\n          .substring(0, end)\n          .replace(\"export function \", \"export declare function \")\n      }\n    })\n  )\n}\n\nconst getFunctionDeclarationJSDocs = (\n  fd: ast.FunctionDeclaration\n): Array<ast.JSDoc> =>\n  pipe(\n    fd.getOverloads(),\n    ReadonlyArray.matchLeft({\n      onEmpty: () => fd.getJsDocs(),\n      onNonEmpty: (firstOverload) => firstOverload.getJsDocs()\n    })\n  )\n\nconst parseFunctionDeclaration = (fd: ast.FunctionDeclaration) =>\n  pipe(\n    Effect.flatMap(Source, (source) =>\n      pipe(\n        Option.fromNullable(fd.getName()),\n        Option.flatMap(Option.liftPredicate((name) => name.length > 0)),\n        Effect.mapError(", "          () => `Missing function name in module ${source.path.join(\"/\")}`\n        )\n      )),\n    Effect.flatMap((name) =>\n      pipe(\n        getJSDocText(getFunctionDeclarationJSDocs(fd)),\n        getCommentInfo(name),\n        Effect.map((info) => {\n          const signatures = pipe(\n            fd.getOverloads(),\n            ReadonlyArray.matchRight({\n              onEmpty: () => [getFunctionDeclarationSignature(fd)],\n              onNonEmpty: (init, last) =>\n                pipe(\n                  init.map(getFunctionDeclarationSignature),\n                  ReadonlyArray.append(getFunctionDeclarationSignature(last))\n                )\n            })\n          )\n          return Domain.createFunction(\n            Domain.createDocumentable(\n              name,\n              info.description,\n              info.since,\n              info.deprecated,\n              info.examples,\n              info.category\n            ),\n            signatures\n          )\n        })\n      )\n    )\n  )\n\nconst parseFunctionVariableDeclaration = (vd: ast.VariableDeclaration) => {\n  const vs: any = vd.getParent().getParent()\n  const name = vd.getName()\n  return pipe(\n    getJSDocText(vs.getJsDocs()),\n    getCommentInfo(name),\n    Effect.map((info) => {\n      const signature = `export declare const ${name}: ${\n        stripImportTypes(\n          vd.getType().getText(vd)\n        )\n      }`\n      return Domain.createFunction(\n        Domain.createDocumentable(\n          name,\n          info.description,\n          info.since,\n          info.deprecated,\n          info.examples,\n          info.category\n        ),\n        [signature]\n      )\n    })\n  )\n}\n\nconst getFunctionDeclarations = pipe(\n  Effect.map(Source, (source) => ({\n    functions: pipe(\n      source.sourceFile.getFunctions(),\n      ReadonlyArray.filter(\n        every<ast.FunctionDeclaration>([\n          (fd) => fd.isExported(),\n          Predicate.not(\n            flow(\n              getFunctionDeclarationJSDocs,\n              getJSDocText,\n              parseComment,\n              shouldIgnore\n            )\n          )\n        ])\n      )\n    ),\n    arrows: pipe(\n      source.sourceFile.getVariableDeclarations(),\n      ReadonlyArray.filter(\n        every<ast.VariableDeclaration>([\n          (vd) => isVariableDeclarationList(vd.getParent()),\n          (vd) => isVariableStatement(vd.getParent().getParent() as any),\n          (vd) =>\n            pipe(\n              vd.getInitializer(),\n              every([\n                flow(\n                  Option.fromNullable,\n                  Option.flatMap(\n                    Option.liftPredicate(ast.Node.isFunctionLikeDeclaration)\n                  ),\n                  Option.isSome\n                ),\n                () =>\n                  pipe(\n                    (\n                      vd.getParent().getParent() as ast.VariableStatement\n                    ).getJsDocs(),\n                    Predicate.not(flow(getJSDocText, parseComment, shouldIgnore))\n                  ),\n                () =>\n                  (\n                    vd.getParent().getParent() as ast.VariableStatement\n                  ).isExported()\n              ])\n            )\n        ])\n      )\n    )\n  }))\n)\n\n/**\n * @category parsers\n * @since 1.0.0\n */\nexport const parseFunctions = pipe(\n  Effect.Do,\n  Effect.bind(\"getFunctionDeclarations\", () => getFunctionDeclarations),\n  Effect.bind(\"functionDeclarations\", ({ getFunctionDeclarations }) =>\n    pipe(\n      getFunctionDeclarations.functions,\n      Effect.validateAll(parseFunctionDeclaration)\n    )),\n  Effect.bind(\"variableDeclarations\", ({ getFunctionDeclarations }) =>\n    pipe(\n      getFunctionDeclarations.arrows,\n      Effect.validateAll(parseFunctionVariableDeclaration)\n    )),\n  Effect.map(({ functionDeclarations, variableDeclarations }) =>\n    functionDeclarations.concat(variableDeclarations)\n  )\n)\n\n// -------------------------------------------------------------------------------------", "// type aliases\n// -------------------------------------------------------------------------------------\n\nconst parseTypeAliasDeclaration = (ta: ast.TypeAliasDeclaration) =>\n  pipe(\n    Effect.succeed(ta.getName()),\n    Effect.flatMap((name) =>\n      pipe(\n        getJSDocText(ta.getJsDocs()),\n        getCommentInfo(name),\n        Effect.map((info) =>\n          Domain.createTypeAlias(\n            Domain.createDocumentable(\n              name,\n              info.description,\n              info.since,\n              info.deprecated,\n              info.examples,\n              info.category\n            ),\n            ta.getText()\n          )\n        )\n      )\n    )\n  )\n\n/**\n * @category parsers\n * @since 1.0.0\n */\nexport const parseTypeAliases = pipe(\n  Effect.map(Source, (source) =>\n    pipe(\n      source.sourceFile.getTypeAliases(),\n      ReadonlyArray.filter(\n        every<ast.TypeAliasDeclaration>([\n          (alias) => alias.isExported(),\n          (alias) =>\n            pipe(\n              alias.getJsDocs(),\n              Predicate.not(flow(getJSDocText, parseComment, shouldIgnore))\n            )\n        ])\n      )\n    )),\n  Effect.flatMap((typeAliasDeclarations) =>\n    pipe(typeAliasDeclarations, Effect.validateAll(parseTypeAliasDeclaration))\n  ),\n  Effect.map(ReadonlyArray.sort(byName))\n)\n\n// -------------------------------------------------------------------------------------\n// constants\n// -------------------------------------------------------------------------------------\n\nconst parseConstantVariableDeclaration = (vd: ast.VariableDeclaration) => {\n  const vs: any = vd.getParent().getParent()\n  const name = vd.getName()\n  return pipe(\n    getJSDocText(vs.getJsDocs()),\n    getCommentInfo(name),\n    Effect.map((info) => {\n      const type = stripImportTypes(vd.getType().getText(vd))\n      const signature = `export declare const ${name}: ${type}`\n      return Domain.createConstant(\n        Domain.createDocumentable(\n          name,\n          info.description,\n          info.since,\n          info.deprecated,\n          info.examples,\n          info.category\n        ),\n        signature\n      )\n    })\n  )\n}\n\n/**\n * @category parsers\n * @since 1.0.0\n */\nexport const parseConstants = pipe(\n  Effect.map(Source, (source) =>\n    pipe(\n      source.sourceFile.getVariableDeclarations(),\n      ReadonlyArray.filter(\n        every<ast.VariableDeclaration>([\n          (vd) => isVariableDeclarationList(vd.getParent()),\n          (vd) => isVariableStatement(vd.getParent().getParent() as any),\n          (vd) =>\n            pipe(\n              vd.getInitializer(),\n              every([\n                flow(\n                  Option.fromNullable,\n                  Option.flatMap(\n                    Option.liftPredicate(\n                      Predicate.not(ast.Node.isFunctionLikeDeclaration)\n                    )\n                  ),\n                  Option.isSome\n                ),\n                () =>\n                  pipe(\n                    (\n                      vd.getParent().getParent() as ast.VariableStatement\n                    ).getJsDocs(),\n                    Predicate.not(flow(getJSDocText, parseComment, shouldIgnore))\n                  ),\n                () =>\n                  (\n                    vd.getParent().getParent() as ast.VariableStatement\n                  ).isExported()\n              ])\n            )\n        ])\n      )\n    )),\n  Effect.flatMap((variableDeclarations) =>\n    pipe(\n      variableDeclarations,\n      Effect.validateAll(parseConstantVariableDeclaration)\n    )\n  )\n)\n\n// -------------------------------------------------------------------------------------\n// exports\n// -------------------------------------------------------------------------------------\n\nconst parseExportSpecifier = (es: ast.ExportSpecifier) =>\n  Effect.flatMap(Source, (source) =>\n    pipe(\n      Effect.Do,\n      Effect.bind(\"name\", () => Effect.succeed(es.compilerNode.name.text)),\n      Effect.bind(\"type\", () => Effect.succeed(stripImportTypes(es.getType().getText(es)))),\n      Effect.bind(\n        \"signature\",\n        ({ name, type }) => Effect.succeed(`export declare const ${name}: ${type}`)\n      ),\n      Effect.flatMap(({ name, signature }) =>\n        pipe(\n          es.getLeadingCommentRanges(),\n          ReadonlyArray.head,\n          Effect.mapError(\n            () => `Missing ${name} documentation in ${source.path.join(\"/\")}`\n          ),\n          Effect.flatMap((commentRange) => pipe(commentRange.getText(), getCommentInfo(name))),\n          Effect.map((info) =>\n            Domain.createExport(\n              Domain.createDocumentable(\n                name,\n                info.description,\n                info.since,\n                info.deprecated,\n                info.examples,\n                info.category\n              ),\n              signature\n            )\n          )\n        )\n      )\n    ))\n\nconst parseExportDeclaration = (ed: ast.ExportDeclaration) =>\n  pipe(ed.getNamedExports(), Effect.validateAll(parseExportSpecifier))\n\n/**\n * @category parsers\n * @since 1.0.0\n */\nexport const parseExports = pipe(\n  Effect.map(Source, (source) => source.sourceFile.getExportDeclarations()),\n  Effect.flatMap((exportDeclarations) =>\n    pipe(exportDeclarations, Effect.validateAll(parseExportDeclaration))\n  ),\n  Effect.mapBoth({\n    onFailure: ReadonlyArray.flatten,\n    onSuccess: ReadonlyArray.flatten\n  })\n)\n\n// -------------------------------------------------------------------------------------\n// classes\n// -------------------------------------------------------------------------------------\n\nconst getTypeParameters = (\n  tps: ReadonlyArray<ast.TypeParameterDeclaration>\n): string => tps.length === 0 ? \"\" : `<${tps.map((p) => p.getName()).join(\", \")}>`\n\nconst getMethodSignature = (md: ast.MethodDeclaration): string =>\n  pipe(\n    Option.fromNullable(md.compilerNode.body),\n    Option.match({\n      onNone: () => md.getText(),\n      onSome: (body) => {\n        const end = body.getStart() - md.getStart() - 1\n        return md.getText().substring(0, end)\n      }\n    })\n  )\n\nconst parseMethod = (md: ast.MethodDeclaration) =>\n  pipe(\n    Effect.Do,\n    Effect.bind(\"name\", () => Effect.succeed(md.getName())),\n    Effect.bind(\"overloads\", () => Effect.succeed(md.getOverloads())),\n    Effect.bind(\"jsdocs\", ({ overloads }) =>\n      Effect.succeed(\n        pipe(\n          overloads,\n          ReadonlyArray.matchLeft({\n            onEmpty: () => md.getJsDocs(),\n            onNonEmpty: (x) => x.getJsDocs()\n          })\n        )\n      )),\n    Effect.flatMap(({ jsdocs, name, overloads }) =>\n      shouldIgnore(parseComment(getJSDocText(jsdocs)))\n        ? Effect.succeed(Option.none())\n        : pipe(\n          getJSDocText(jsdocs),\n          getCommentInfo(name),\n          Effect.map((info) => {\n            const signatures = pipe(\n              overloads,\n              ReadonlyArray.matchRight({\n                onEmpty: () => [getMethodSignature(md)],\n                onNonEmpty: (init, last) =>\n                  pipe(\n                    init.map((md) => md.getText()),\n                    ReadonlyArray.append(getMethodSignature(last))\n                  )\n              })\n            )\n            return Option.some(\n              Domain.createMethod(\n                Domain.createDocumentable(\n                  name,\n                  info.description,\n                  info.since,\n                  info.deprecated,\n                  info.examples,\n                  info.category\n                ),\n                signatures\n              )\n            )\n          })\n        )\n    )\n  )\n\nconst parseProperty = (classname: string) => (pd: ast.PropertyDeclaration) => {\n  const name = pd.getName()\n  return pipe(\n    getJSDocText(pd.getJsDocs()),\n    getCommentInfo(`${classname}#${name}`),\n    Effect.map((info) => {\n      const type = stripImportTypes(pd.getType().getText(pd))\n      const readonly = pipe(\n        Option.fromNullable(\n          pd.getFirstModifierByKind(ast.ts.SyntaxKind.ReadonlyKeyword)\n        ),\n        Option.match({\n          onNone: () => \"\",\n          onSome: () => \"readonly \"\n        })\n      )\n      const signature = `${readonly}${name}: ${type}`\n      return Domain.createProperty(\n        Domain.createDocumentable(\n          name,\n          info.description,\n          info.since,\n          info.deprecated,\n          info.examples,\n          info.category\n        ),\n        signature\n      )\n    })\n  )\n}\n\nconst parseProperties = (name: string, c: ast.ClassDeclaration) =>\n  pipe(\n    c.getProperties(),\n    ReadonlyArray.filter(\n      every<ast.PropertyDeclaration>([\n        (prop) => !prop.isStatic(),\n        (prop) =>\n          pipe(\n            prop.getFirstModifierByKind(ast.ts.SyntaxKind.PrivateKeyword),\n            Option.fromNullable,\n            Option.isNone\n          ),\n        (prop) =>\n          pipe(\n            prop.getJsDocs(),\n            Predicate.not(flow(getJSDocText, parseComment, shouldIgnore))\n          )\n      ])\n    ),\n    (propertyDeclarations) => pipe(propertyDeclarations, Effect.validateAll(parseProperty(name)))\n  )\n\n/**\n * @internal\n */\nexport const getConstructorDeclarationSignature = (\n  c: ast.ConstructorDeclaration\n): string =>\n  pipe(\n    Option.fromNullable(c.compilerNode.body),\n    Option.match({\n      onNone: () => c.getText(),\n      onSome: (body) => {\n        const end = body.getStart() - c.getStart() - 1\n        return c.getText().substring(0, end)\n      }\n    })\n  )\n\nconst getClassName = (c: ast.ClassDeclaration) =>\n  Effect.flatMap(Source, (source) =>\n    Effect.mapError(\n      Option.fromNullable(c.getName()),", "      () => `Missing class name in module ${source.path.join(\"/\")}`\n    ))\n\nconst getClassCommentInfo = (name: string, c: ast.ClassDeclaration) =>\n  pipe(c.getJsDocs(), getJSDocText, getCommentInfo(name))\n\nconst getClassDeclarationSignature = (name: string, c: ast.ClassDeclaration) =>\n  pipe(\n    Effect.succeed(getTypeParameters(c.getTypeParameters())),\n    Effect.map((typeParameters) =>\n      pipe(\n        c.getConstructors(),\n        ReadonlyArray.matchLeft({\n          onEmpty: () => `export declare class ${name}${typeParameters}`,\n          onNonEmpty: (head) =>\n            `export declare class ${name}${typeParameters} { ${\n              getConstructorDeclarationSignature(\n                head\n              )\n            } }`\n        })\n      )\n    )\n  )\n\nconst parseClass = (c: ast.ClassDeclaration) =>\n  pipe(\n    Effect.Do,\n    Effect.bind(\"name\", () => Effect.mapError(getClassName(c), (e) => [e])),\n    Effect.bind(\"info\", ({ name }) => Effect.mapError(getClassCommentInfo(name, c), (e) => [e])),\n    Effect.bind(\"signature\", ({ name }) => getClassDeclarationSignature(name, c)),\n    Effect.bind(\"methods\", () =>\n      pipe(\n        c.getInstanceMethods(),\n        Effect.validateAll(parseMethod),\n        Effect.map(ReadonlyArray.compact)\n      )),\n    Effect.bind(\"staticMethods\", () =>\n      pipe(\n        c.getStaticMethods(),\n        Effect.validateAll(parseMethod),\n        Effect.map(ReadonlyArray.compact)\n      )),\n    Effect.bind(\"properties\", ({ name }) => parseProperties(name, c)),\n    Effect.map(\n      ({ info, methods, name, properties, signature, staticMethods }) =>\n        Domain.createClass(\n          Domain.createDocumentable(\n            name,\n            info.description,\n            info.since,\n            info.deprecated,\n            info.examples,\n            info.category\n          ),\n          signature,\n          methods,\n          staticMethods,\n          properties\n        )\n    )\n  )\n\n/**\n * @category parsers\n * @since 1.0.0\n */\nexport const parseClasses = pipe(\n  Effect.map(Source, (source) =>\n    pipe(\n      source.sourceFile.getClasses(),\n      ReadonlyArray.filter(every<ast.ClassDeclaration>([\n        (id) => id.isExported(),\n        (id) =>\n          pipe(\n            id.getJsDocs(),\n            Predicate.not(flow(getJSDocText, parseComment, shouldIgnore))\n          )\n      ]))\n    )),\n  Effect.flatMap((classDeclarations) =>\n    pipe(\n      classDeclarations,\n      Effect.validateAll(parseClass),\n      Effect.mapBoth({\n        onFailure: ReadonlyArray.flatten,\n        onSuccess: ReadonlyArray.sort(byName)\n      })\n    )\n  )\n)\n\n// -------------------------------------------------------------------------------------\n// modules\n// -------------------------------------------------------------------------------------\n\nconst getModuleName = (\n  path: ReadonlyArray.NonEmptyReadonlyArray<string>\n): string => NodePath.parse(ReadonlyArray.lastNonEmpty(path)).name\n\n/**\n * @internal\n */\nexport const parseModuleDocumentation = pipe(\n  Effect.all([Config.Config, Source]),\n  Effect.flatMap(([config, source]) => {\n    const name = getModuleName(source.path)\n    // if any of the settings enforcing documentation are set to `true`, then", "    // a module should have associated documentation\n    const isDocumentationRequired = config.enforceDescriptions || config.enforceVersion\n    const onMissingDocumentation = () =>\n      isDocumentationRequired\n        ? Effect.fail(\n          `Missing documentation in ${source.path.join(\"/\")} module`\n        )\n        : Effect.succeed(\n          Domain.createDocumentable(\n            name,\n            Option.none(),\n            Option.none(),\n            false,\n            [],\n            Option.none()\n          )\n        )\n    return ReadonlyArray.matchLeft(source.sourceFile.getStatements(), {\n      onEmpty: onMissingDocumentation,\n      onNonEmpty: (statement) =>\n        ReadonlyArray.matchLeft(statement.getLeadingCommentRanges(), {\n          onEmpty: onMissingDocumentation,\n          onNonEmpty: (commentRange) =>\n            pipe(\n              getCommentInfo(name, true)(commentRange.getText()),\n              Effect.map((info) =>\n                Domain.createDocumentable(\n                  name,\n                  info.description,\n                  info.since,\n                  info.deprecated,\n                  info.examples,\n                  info.category\n                )\n              )\n            )\n        })\n    })\n  })\n)\n\n/**\n * @category parsers\n * @since 1.0.0\n */\nexport const parseModule = pipe(\n  Effect.flatMap(Source, (source) =>\n    pipe(\n      Effect.Do,\n      Effect.bind(\"documentation\", () => Effect.mapError(parseModuleDocumentation, (e) => [e])),\n      Effect.bind(\"interfaces\", () => parseInterfaces),\n      Effect.bind(\"functions\", () => parseFunctions),\n      Effect.bind(\"typeAliases\", () => parseTypeAliases),\n      Effect.bind(\"classes\", () => parseClasses),\n      Effect.bind(\"constants\", () => parseConstants),\n      Effect.bind(\"exports\", () => parseExports),\n      Effect.map(\n        ({\n          classes,\n          constants,\n          documentation,\n          exports,\n          functions,\n          interfaces,\n          typeAliases\n        }) =>\n          Domain.createModule(\n            documentation,\n            source.path,\n            classes,\n            interfaces,\n            functions,\n            typeAliases,\n            constants,\n            exports\n          )\n      )\n    ))\n)\n\n/**\n * @internal\n */\nexport const parseFile = (project: ast.Project) =>\n(\n  file: FileSystem.File\n): Effect.Effect<Config.Config, Array<string>, Domain.Module> => {\n  const path = file.path.split(\n    NodePath.sep\n  ) as any as ReadonlyArray.NonEmptyReadonlyArray<string>\n  const sourceFile = project.getSourceFile(file.path)", "  if (sourceFile !== undefined) {\n    return pipe(\n      parseModule,\n      Effect.provideService(Source, { path, sourceFile })\n    )\n  }\n  return Effect.fail([`Unable to locate file: ${file.path}`])\n}\n\nconst createProject = (files: ReadonlyArray<FileSystem.File>) =>\n  pipe(\n    Config.Config,\n    Effect.map((config) => {\n      const options: ast.ProjectOptions = {\n        compilerOptions: {\n          strict: true,\n          ...config.parseCompilerOptions\n        }\n      }\n      const project = new ast.Project(options)", "      for (const file of files) {\n        project.addSourceFileAtPath(file.path)\n      }\n      return project\n    })\n  )\n\n/**\n * @category parsers\n * @since 1.0.0\n */\nexport const parseFiles = (files: ReadonlyArray<FileSystem.File>) =>\n  pipe(\n    createProject(files),\n    Effect.flatMap((project) =>\n      pipe(\n        files,\n        Effect.validateAll(parseFile(project)),\n        Effect.map(\n          flow(\n            ReadonlyArray.filter((module) => !module.deprecated),\n            sortModules\n          )\n        )\n      )\n    )\n  )\n"]}
{"filename": "src/bin.ts", "chunked_list": ["#!/usr/bin/env node\n\n/**\n * CLI\n *\n * @since 1.0.0\n */\n\nimport chalk from \"chalk\"\nimport { Effect } from \"effect\"", "import chalk from \"chalk\"\nimport { Effect } from \"effect\"\nimport { main } from \"./index\"\n\nEffect.runPromise(main).catch((defect) => {\n  console.error(chalk.bold.red(\"Unexpected Error\"))\n  console.error(defect)\n  process.exit(1)\n})\n"]}
{"filename": "src/Core.ts", "chunked_list": ["/**\n * @since 1.0.0\n */\n\nimport chalk from \"chalk\"\nimport { Data, Effect, Layer, Logger, LoggerLevel, pipe, ReadonlyArray, String } from \"effect\"\nimport * as NodePath from \"path\"\nimport * as ChildProcess from \"./ChildProcess\"\nimport * as Config from \"./Config\"\nimport type * as Domain from \"./Domain\"", "import * as Config from \"./Config\"\nimport type * as Domain from \"./Domain\"\nimport * as FileSystem from \"./FileSystem\"\nimport { SimpleLogger } from \"./Logger\"\nimport { printModule } from \"./Markdown\"\nimport * as Parser from \"./Parser\"\nimport * as Process from \"./Process\"\n\n// -------------------------------------------------------------------------------------\n// readFiles", "// -------------------------------------------------------------------------------------\n// readFiles\n// -------------------------------------------------------------------------------------\n\nconst join = (...paths: Array<string>): string => NodePath.normalize(NodePath.join(...paths))\n\nconst readFiles = Effect.all([Config.Config, FileSystem.FileSystem]).pipe(\n  Effect.flatMap(([config, fileSystem]) =>\n    fileSystem.glob(join(config.srcDir, \"**\", \"*.ts\"), config.exclude).pipe(\n      Effect.tap((paths) => Effect.logInfo(chalk.bold(`${paths.length} module(s) found`))),", "    fileSystem.glob(join(config.srcDir, \"**\", \"*.ts\"), config.exclude).pipe(\n      Effect.tap((paths) => Effect.logInfo(chalk.bold(`${paths.length} module(s) found`))),\n      Effect.flatMap(\n        Effect.forEach((path) =>\n          Effect.map(\n            fileSystem.readFile(path),\n            (content) => FileSystem.makeFile(path, content, false)\n          ), { concurrency: \"inherit\" })\n      )\n    )", "      )\n    )\n  )\n)\n\nconst writeFile = (\n  file: FileSystem.File\n): Effect.Effect<\n  Config.Config | FileSystem.FileSystem | Process.Process,\n  FileSystem.ReadFileError | FileSystem.WriteFileError,", "  Config.Config | FileSystem.FileSystem | Process.Process,\n  FileSystem.ReadFileError | FileSystem.WriteFileError,\n  void\n> =>\n  Effect.all([Config.Config, FileSystem.FileSystem, Process.Process]).pipe(\n    Effect.flatMap(([config, fileSystem, process]) =>\n      process.cwd.pipe(\n        Effect.map((cwd) => NodePath.relative(NodePath.join(cwd, config.outDir), file.path)),\n        Effect.flatMap((fileName) => {\n          const overwrite = Effect.flatMap(", "        Effect.flatMap((fileName) => {\n          const overwrite = Effect.flatMap(\n            Effect.logDebug(`overwriting file ${chalk.black(fileName)}`),\n            () => fileSystem.writeFile(file.path, file.content)\n          )\n\n          const skip = Effect.logDebug(\n            `file ${chalk.black(fileName)} already exists, skipping creation`\n          )\n", "          )\n\n          const write = fileSystem.writeFile(file.path, file.content)\n\n          return Effect.if(fileSystem.pathExists(file.path), {\n            onTrue: file.overwrite ? overwrite : skip,\n            onFalse: write\n          })\n        })\n      )\n    )\n  )\n\n// -------------------------------------------------------------------------------------\n// parse\n// -------------------------------------------------------------------------------------\n\n/**\n * Represents errors that occurred during parsing of TypeScript source files.\n *\n * @category model\n * @since 1.0.0\n */", "export interface ParseError extends Data.Case {\n  readonly _tag: \"ParseError\"\n  readonly message: string\n}\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const ParseError = Data.tagged<ParseError>(\"ParseError\")\n\nconst getModules = (files: ReadonlyArray<FileSystem.File>) =>\n  Parser.parseFiles(files).pipe(\n    Effect.mapError((errors) =>\n      ParseError({\n        message: errors\n          .map((errors) => errors.join(\"\\n\"))\n          .join(\"\\n\")\n      })\n    )\n  )\n\n// -------------------------------------------------------------------------------------\n// typeCheckExamples\n// -------------------------------------------------------------------------------------\n\nconst typeCheckExamples = (modules: ReadonlyArray<Domain.Module>) =>\n  getExampleFiles(modules)\n    .pipe(\n      Effect.flatMap(handleImports),\n      Effect.flatMap((examples) =>\n        examples.length === 0\n          ? cleanExamples\n          : writeExamples(examples).pipe(\n            Effect.zipRight(writeTsConfigJson),\n            Effect.zipRight(spawnTsNode),\n            Effect.zipRight(cleanExamples)\n          )\n      )\n    )\n\nconst getExampleFiles = (modules: ReadonlyArray<Domain.Module>) =>\n  Effect.map(Config.Config, (config) =>\n    ReadonlyArray.flatMap(modules, (module) => {\n      const prefix = module.path.join(\"-\")\n\n      const getDocumentableExamples = (id: string) =>\n      (\n        documentable: Domain.Documentable\n      ): ReadonlyArray<FileSystem.File> =>\n        ReadonlyArray.map(\n          documentable.examples,\n          (content, i) =>\n            FileSystem.makeFile(\n              join(\n                config.outDir,\n                \"examples\",\n                `${prefix}-${id}-${documentable.name}-${i}.ts`\n              ),\n              `${content}\\n`,\n              true\n            )\n        )\n\n      const moduleExamples = getDocumentableExamples(\"module\")(module)\n      const methods = ReadonlyArray.flatMap(module.classes, (c) =>\n        ReadonlyArray.flatten([\n          ReadonlyArray.flatMap(\n            c.methods,\n            getDocumentableExamples(`${c.name}-method`)\n          ),\n          ReadonlyArray.flatMap(\n            c.staticMethods,\n            getDocumentableExamples(`${c.name}-staticmethod`)\n          )\n        ]))\n      const interfaces = ReadonlyArray.flatMap(\n        module.interfaces,\n        getDocumentableExamples(\"interface\")\n      )\n      const typeAliases = ReadonlyArray.flatMap(\n        module.typeAliases,\n        getDocumentableExamples(\"typealias\")\n      )\n      const constants = ReadonlyArray.flatMap(\n        module.constants,\n        getDocumentableExamples(\"constant\")\n      )\n      const functions = ReadonlyArray.flatMap(\n        module.functions,\n        getDocumentableExamples(\"function\")\n      )\n\n      return ReadonlyArray.flatten([\n        moduleExamples,\n        methods,\n        interfaces,\n        typeAliases,\n        constants,\n        functions\n      ])\n    }))\n\nconst addAssertImport = (code: string): string =>\n  code.indexOf(\"assert.\") !== -1\n    ? `import * as assert from 'assert'\\n${code}`\n    : code\n\nconst replaceProjectName = (source: string) =>\n  Effect.map(Config.Config, (config) => {\n    const importRegex = (projectName: string) =>\n      new RegExp(\n        `from (?<quote>['\"])${projectName}(?:/lib)?(?:/(?<path>.*))?\\\\k<quote>`,\n        \"g\"\n      )\n\n    const out = source.replace(importRegex(config.projectName), (...args) => {\n      const groups: { path?: string } = args[args.length - 1]\n      return `from '../../src${groups.path ? `/${groups.path}` : \"\"}'`\n    })\n\n    return out\n  })\n\nconst handleImports = (files: ReadonlyArray<FileSystem.File>) =>\n  Effect.forEach(files, (file) =>\n    replaceProjectName(file.content).pipe(\n      Effect.map(addAssertImport),\n      Effect.map((content) => FileSystem.makeFile(file.path, content, file.overwrite))\n    ))\n\nconst getExampleIndex = (examples: ReadonlyArray<FileSystem.File>) => {\n  const content = pipe(\n    examples,\n    ReadonlyArray.map(\n      (example) => `import './${NodePath.basename(example.path, \".ts\")}'`\n    ),\n    ReadonlyArray.join(\"\\n\")\n  )\n  return Effect.map(Config.Config, (config) =>\n    FileSystem.makeFile(\n      join(config.outDir, \"examples\", \"index.ts\"),\n      `${content}\\n`,\n      true\n    ))\n}\n\nconst cleanExamples = Effect.flatMap(\n  Effect.all([Config.Config, FileSystem.FileSystem]),\n  ([config, fileSystem]) => fileSystem.removeFile(join(config.outDir, \"examples\"))\n)\n\nconst spawnTsNode = Effect.logDebug(\"Type checking examples...\").pipe(\n  Effect.flatMap(() => Effect.all([ChildProcess.ChildProcess, Config.Config, Process.Process])),\n  Effect.flatMap(([childProcess, config, process]) =>\n    Effect.all([process.cwd, process.platform]).pipe(\n      Effect.flatMap(([cwd, platform]) => {\n        const command = platform === \"win32\" ? \"ts-node.cmd\" : \"ts-node\"\n        const executable = join(cwd, config.outDir, \"examples\", \"index.ts\")\n        return childProcess.spawn(command, executable)\n      })\n    )\n  )\n)\n\nconst writeFiles = (\n  files: ReadonlyArray<FileSystem.File>\n) => Effect.forEach(files, writeFile, { discard: true })\n\nconst writeExamples = (examples: ReadonlyArray<FileSystem.File>) =>\n  Effect.logDebug(\"Writing examples...\").pipe(\n    Effect.flatMap(() => getExampleIndex(examples)),\n    Effect.map((index) => pipe(examples, ReadonlyArray.prepend(index))),\n    Effect.flatMap(writeFiles)\n  )\n\nconst writeTsConfigJson = Effect.logDebug(\"Writing examples tsconfig...\").pipe(\n  Effect.flatMap(() => Effect.all([Config.Config, Process.Process])),\n  Effect.flatMap(([config, process]) =>\n    process.cwd.pipe(\n      Effect.flatMap((cwd) =>\n        writeFile(\n          FileSystem.makeFile(\n            join(cwd, config.outDir, \"examples\", \"tsconfig.json\"),\n            JSON.stringify({ compilerOptions: config.examplesCompilerOptions }, null, 2),\n            true\n          )\n        )\n      )\n    )\n  )\n)\n\n// -------------------------------------------------------------------------------------\n// getMarkdown\n// -------------------------------------------------------------------------------------\n\nconst getMarkdown = (modules: ReadonlyArray<Domain.Module>) =>\n  Effect.Do.pipe(\n    Effect.bind(\"home\", () => getHome),\n    Effect.bind(\"index\", () => getModulesIndex),\n    Effect.bind(\"yml\", () => getConfigYML),\n    Effect.flatMap(({ home, index, yml }) =>\n      pipe(\n        getModuleMarkdownFiles(modules),\n        Effect.map((files) => [home, index, yml].concat(files))\n      )\n    )\n  )\n\nconst getHome = Effect.all([Config.Config, Process.Process]).pipe(\n  Effect.flatMap(([config, process]) =>\n    process.cwd.pipe(\n      Effect.map((cwd) =>\n        FileSystem.makeFile(\n          join(cwd, config.outDir, \"index.md\"),\n          String.stripMargin(\n            `|---\n             |title: Home\n             |nav_order: 1\n             |---\n             |`\n          ),\n          false\n        )\n      )\n    )\n  )\n)\n\nconst getModulesIndex = Effect.all([Config.Config, Process.Process]).pipe(\n  Effect.flatMap(([config, process]) =>\n    process.cwd\n      .pipe(\n        Effect.map((cwd) =>\n          FileSystem.makeFile(\n            join(cwd, config.outDir, \"modules\", \"index.md\"),\n            String.stripMargin(\n              `|---\n             |title: Modules\n             |has_children: true\n             |permalink: /docs/modules\n             |nav_order: 2\n             |---\n             |`\n            ),\n            false\n          )\n        )\n      )\n  )\n)\n\nconst replace = (\n  searchValue: string | RegExp,\n  replaceValue: string\n): (s: string) => string =>\n(s) => s.replace(searchValue, replaceValue)\n\nconst resolveConfigYML = (\n  previousContent: string,\n  config: Config.Config\n): string =>\n  pipe(\n    previousContent,\n    replace(/^remote_theme:.*$/m, `remote_theme: ${config.theme}`),\n    replace(/^search_enabled:.*$/m, `search_enabled: ${config.enableSearch}`),\n    replace(\n      /^ {2}'\\S* on GitHub':\\n {4}- '.*'/m,\n      `  '${config.projectName} on GitHub':\\n    - '${config.projectHomepage}'`\n    )\n  )\n\nconst getHomepageNavigationHeader = (config: Config.Config): string => {\n  const isGitHub = config.projectHomepage.toLowerCase().includes(\"github\")\n  return isGitHub ? config.projectName + \" on GitHub\" : \"Homepage\"\n}\n\nconst getConfigYML = Effect.all([Config.Config, FileSystem.FileSystem, Process.Process]).pipe(\n  Effect.flatMap(([config, fileSystem, process]) =>\n    Effect.flatMap(process.cwd, (cwd) => {\n      const filePath = join(cwd, config.outDir, \"_config.yml\")\n      return fileSystem.pathExists(filePath).pipe(\n        Effect.flatMap((exists) =>\n          exists\n            ? Effect.map(\n              fileSystem.readFile(filePath),\n              (content) =>\n                FileSystem.makeFile(\n                  filePath,\n                  resolveConfigYML(content, config),\n                  true\n                )\n            )\n            : Effect.succeed(\n              FileSystem.makeFile(\n                filePath,\n                String.stripMargin(\n                  `|remote_theme: ${config.theme}\n                   |\n                   |# Enable or disable the site search\n                   |search_enabled: ${config.enableSearch}\n                   |\n                   |# Aux links for the upper right navigation\n                   |aux_links:\n                   |'${getHomepageNavigationHeader(config)}':\n                   |  - '${config.projectHomepage}'`\n                ),\n                false\n              )\n            )\n        )\n      )\n    })\n  )\n)\n\nconst getMarkdownOutputPath = (module: Domain.Module) =>\n  Effect.map(Config.Config, (config) =>\n    join(\n      config.outDir,\n      \"modules\",\n      `${module.path.slice(1).join(NodePath.sep)}.md`\n    ))\n\nconst getModuleMarkdownFiles = (modules: ReadonlyArray<Domain.Module>) =>\n  Effect.forEach(modules, (module, order) =>\n    Effect.Do\n      .pipe(\n        Effect.bind(\"outputPath\", () => getMarkdownOutputPath(module)),\n        Effect.bind(\"content\", () => Effect.succeed(printModule(module, order + 1))),\n        Effect.map(({ content, outputPath }) => FileSystem.makeFile(outputPath, content, true))\n      ))\n\n// -------------------------------------------------------------------------------------\n// writeMarkdown\n// -------------------------------------------------------------------------------------\n\nconst writeMarkdown = (files: ReadonlyArray<FileSystem.File>) =>\n  Effect.map(Config.Config, (config) => join(config.outDir, \"**/*.ts.md\")).pipe(\n    Effect.tap((pattern) => Effect.logDebug(`deleting ${chalk.black(pattern)}`)),\n    Effect.flatMap((pattern) =>\n      Effect.flatMap(FileSystem.FileSystem, (fileSystem) => fileSystem.removeFile(pattern))\n    ),\n    Effect.flatMap(() => writeFiles(files))\n  )\n\nconst MainLayer = Logger.replace(Logger.defaultLogger, SimpleLogger).pipe(\n  Layer.merge(ChildProcess.ChildProcessLive),\n  Layer.merge(FileSystem.FileSystemLive),\n  Layer.merge(Process.ProcessLive),\n  Layer.provideMerge(Config.ConfigLive)\n)\n\n/**\n * @category main\n * @since 1.0.0\n */\nexport const main: Effect.Effect<never, never, void> = Effect.logInfo(\"reading modules...\").pipe(\n  Effect.zipRight(readFiles),\n  Effect.zipLeft(Effect.logInfo(\"parsing modules...\")),\n  Effect.flatMap(getModules),\n  Effect.zipLeft(Effect.logInfo(\"typechecking examples...\")),\n  Effect.tap(typeCheckExamples),\n  Effect.zipLeft(Effect.logInfo(\"creating markdown files...\")),\n  Effect.flatMap(getMarkdown),\n  Effect.zipLeft(Effect.logInfo(\"writing markdown files...\")),\n  Effect.flatMap(writeMarkdown),\n  Effect.zipLeft(Effect.logInfo(chalk.bold.green(\"Docs generation succeeded!\"))),\n  Logger.withMinimumLogLevel(LoggerLevel.Debug),\n  Effect.provideLayer(MainLayer),\n  Effect.catchTags({\n    // Configuration errors\n    ConfigError: ({ message }) => Effect.dieMessage(message),\n    // File system errors\n    ReadFileError: ({ path }) => Effect.dieMessage(`Unable to read file from: '${path}'`),\n    WriteFileError: ({ path }) => Effect.dieMessage(`Unable to write file to: '${path}'`),\n    RemoveFileError: ({ path }) => Effect.dieMessage(`Unable to remove file from: '${path}'`),\n    GlobError: ({ exclude, pattern }) =>\n      Effect.dieMessage(\n        `Unable to execute glob pattern '${pattern}' excluding files matching '${exclude}'`\n      ),\n    // Child process errors\n    ExecutionError: ({ command, stderr }) =>\n      Effect.dieMessage(\n        `During execution of '${command}', the following error occurred:\\n${stderr}`\n      ),\n    SpawnError: ({ args, command, error }) =>\n      Effect.dieMessage(\n        `Unable to spawn child process for command: '${command} ${args.join(\" \")}'\\n${error}`\n      ),\n    // Parsing errors\n    ParseJsonError: ({ content }) => Effect.dieMessage(`Unable to parse JSON: ${content}`),\n    ParseError: ({ message }) =>\n      Effect.dieMessage(\n        `The following error(s) occurred while parsing the TypeScript source files:\\n${message}`\n      )\n  })\n)\n"]}
{"filename": "src/Process.ts", "chunked_list": ["/**\n * @since 1.0.0\n */\n\nimport { Context, Effect, Layer } from \"effect\"\n\n/**\n * Represents a handle to the currently executing process.\n *\n * @category model", " *\n * @category model\n * @since 1.0.0\n */\nexport interface Process {\n  readonly cwd: Effect.Effect<never, never, string>\n  readonly platform: Effect.Effect<never, never, string>\n}\n\n/**\n * @category service\n * @since 1.0.0\n */\nexport const Process = Context.Tag<Process>()\n\n/**\n * @category service\n * @since 1.0.0\n */\nexport const ProcessLive = Layer.succeed(\n  Process,\n  Process.of({\n    cwd: Effect.sync(() => process.cwd()),\n    platform: Effect.sync(() => process.platform)\n  })\n)\n"]}
