{"filename": "src/util.ts", "chunked_list": ["import * as fs from \"fs\";\nimport fetch from \"node-fetch\";\n\nexport function base64ToFile(dataurl: string, filename: string) {\n  // Extract the base64 data portion\n  let base64Data = dataurl.split(\",\")[1];\n\n  // Write the base64 string to a file\n  fs.writeFileSync(filename, base64Data, { encoding: \"base64\" });\n}\n", "async function convertImageUrlToBuffer(\n  imageUrl: string\n): Promise<Buffer | null> {\n  try {\n    const response = await fetch(imageUrl);\n    if (!response.ok) {\n      throw new Error(\"Failed to download the image\");\n    }\n    return await response.buffer();\n  } catch (error) {\n    console.error(\"Failed to convert image URL to file:\", error);\n    return null;\n  }\n}\n", "  } catch (error) {\n    console.error(\"Failed to convert image URL to file:\", error);\n    return null;\n  }\n}\n"]}
{"filename": "src/pages/api/images.ts", "chunked_list": ["import { getImageCount } from \"@/data/storage\";\nimport type { NextApiHandler } from \"next\";\n\nconst handler: NextApiHandler = async (request, response) => {\n  const numberOfImages = await getImageCount();\n  return response.json({ numberOfImages });\n};\n\nexport default handler;\n", "export default handler;\n"]}
{"filename": "src/pages/api/edit.ts", "chunked_list": ["import { incrementImageCount } from \"@/data/storage\";\nimport FormData from \"form-data\";\nimport type { NextApiHandler } from \"next\";\nimport fetch from \"node-fetch\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nconst EDIT_FUNCTION_URL = process.env.NEXT_PUBLIC_EDIT_FUNCTION_URL;\n\nconst falToken = process.env.FAL_TOKEN;\n", "const falToken = process.env.FAL_TOKEN;\n\nconst handler: NextApiHandler = async (request, response) => {\n  if (request.method !== \"POST\" && request.method !== \"OPTIONS\") {\n    response.status(405).json({ message: \"Method not allowed\" });\n    return;\n  }\n  if (!EDIT_FUNCTION_URL) {\n    response.status(500).json({ message: \"EDIT_FUNCTION_URL not set\" });\n    return;\n  }\n\n  const uuid = uuidv4();\n\n  const maskFileBuffer = await convertImageUrlToBuffer(request.body.mask_url);\n\n  let base64ImageWithoutPrefix = request.body.image_url.data\n    .split(\";base64,\")\n    .pop();\n\n  const formData = new FormData();\n\n  formData.append(\n    \"image_file\",\n    Buffer.from(base64ImageWithoutPrefix, \"base64\"),\n    \"image_file.png\"\n  );\n  formData.append(\"mask_file\", maskFileBuffer, \"mask_file.png\");\n\n  formData.append(\"fal_token\", falToken);\n  formData.append(\"prompt\", request.body.prompt);\n\n  const res = await fetch(EDIT_FUNCTION_URL, {\n    method: \"POST\",\n    body: formData,\n  });", "  if (!res.ok) {\n    response.status(res.status).send(res.statusText);\n    return;\n  }\n  await incrementImageCount();\n  response.json(await res.json());\n};\n\nasync function convertImageUrlToBuffer(\n  imageUrl: string\n): Promise<Buffer | null> {", "async function convertImageUrlToBuffer(\n  imageUrl: string\n): Promise<Buffer | null> {\n  try {\n    const response = await fetch(imageUrl);\n    if (!response.ok) {\n      throw new Error(\"Failed to download the image\");\n    }\n    return await response.buffer();\n  } catch (error) {\n    console.error(\"Failed to convert image URL to file:\", error);\n    return null;\n  }\n}\n\nexport default handler;\n", "  } catch (error) {\n    console.error(\"Failed to convert image URL to file:\", error);\n    return null;\n  }\n}\n\nexport default handler;\n"]}
{"filename": "src/pages/api/controlnet.ts", "chunked_list": ["import { incrementImageCount } from \"@/data/storage\";\nimport fetch from \"node-fetch\";\nimport FormData from \"form-data\";\nimport type { NextApiHandler } from \"next\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nconst CONTROLNET_URL = process.env.NEXT_PUBLIC_CONTROLNET_URL;\n\nconst falToken = process.env.FAL_TOKEN;\n", "const falToken = process.env.FAL_TOKEN;\n\nconst handler: NextApiHandler = async (request, response) => {\n  if (request.method !== \"POST\" && request.method !== \"OPTIONS\") {\n    response.status(405).json({ message: \"Method not allowed\" });\n    return;\n  }\n  if (!CONTROLNET_URL) {\n    response.status(500).json({ message: \"CONTROLNET_URL not set\" });\n    return;\n  }\n  // save file\n  const uuid = uuidv4();\n  let base64ImageWithoutPrefix = request.body.base64Image\n    .split(\";base64,\")\n    .pop();\n\n  let formData = new FormData();\n  formData.append(\n    \"file\",\n    Buffer.from(base64ImageWithoutPrefix, \"base64\"),\n    `base_${uuid}.png`\n  );\n  // TODO: these need to change\n  formData.append(\"fal_token\", falToken);\n  formData.append(\"num_samples\", \"1\");\n  formData.append(\"prompt\", request.body.prompt);\n  const res = await fetch(CONTROLNET_URL, {\n    method: \"POST\",\n    body: formData,\n  });", "  if (!res.ok) {\n    console.log(res.status);\n    response.status(res.status).send(res.statusText);\n    return;\n  }\n  await incrementImageCount();\n  const data: any = await res.json();\n  response.json({ imageUrl: data[0] });\n};\n\nexport default handler;\n"]}
{"filename": "src/pages/api/remove.ts", "chunked_list": ["import { incrementImageCount } from \"@/data/storage\";\nimport FormData from \"form-data\";\nimport type { NextApiHandler } from \"next\";\nimport fetch from \"node-fetch\";\n\nconst REMOVE_FUNCTION_URL = process.env.NEXT_PUBLIC_REMOVE_FUNCTION_URL;\n\nconst falToken = process.env.FAL_TOKEN;\n\nconst handler: NextApiHandler = async (request, response) => {\n  if (request.method !== \"POST\" && request.method !== \"OPTIONS\") {\n    response.status(405).json({ message: \"Method not allowed\" });\n    return;\n  }", "\nconst handler: NextApiHandler = async (request, response) => {\n  if (request.method !== \"POST\" && request.method !== \"OPTIONS\") {\n    response.status(405).json({ message: \"Method not allowed\" });\n    return;\n  }\n  if (!REMOVE_FUNCTION_URL) {\n    response.status(500).json({ message: \"REMOVE_FUNCTION_URL not set\" });\n    return;\n  }\n\n  const maskFileBuffer = convertImageUrlToBuffer(request.body.mask_url);\n\n  let base64ImageWithoutPrefix = request.body.image_url.data\n    .split(\";base64,\")\n    .pop();\n\n  const formData = new FormData();\n  formData.append(\n    \"image_file\",\n    Buffer.from(base64ImageWithoutPrefix, \"base64\"),\n    \"image_file.png\"\n  );\n  formData.append(\"mask_file\", maskFileBuffer, \"mask_file.png\");\n\n  formData.append(\"fal_token\", falToken);\n  formData.append(\"prompt\", request.body.prompt);\n  const res = await fetch(REMOVE_FUNCTION_URL, {\n    method: \"POST\",\n    body: formData,\n  });", "  if (!res.ok) {\n    response.status(res.status).send(res.statusText);\n    return;\n  }\n  await incrementImageCount();\n  response.json(await res.json());\n};\n\nexport default handler;\nfunction convertImageUrlToBuffer(mask_url: any) {\n  throw new Error(\"Function not implemented.\");\n}\n", "function convertImageUrlToBuffer(mask_url: any) {\n  throw new Error(\"Function not implemented.\");\n}\n"]}
{"filename": "src/pages/api/masks.ts", "chunked_list": ["import { incrementImageCount } from \"@/data/storage\";\nimport FormData from \"form-data\";\nimport type { NextApiHandler, PageConfig } from \"next\";\nimport fetch from \"node-fetch\";\n\nconst falToken = process.env.FAL_TOKEN;\n\nconst MASK_FUNCTION_URL = process.env.NEXT_PUBLIC_MASK_FUNCTION_URL;\nconst handler: NextApiHandler = async (request, response) => {\n  if (request.method !== \"POST\" && request.method !== \"OPTIONS\") {\n    response.status(405).json({ message: \"Method not allowed\" });\n    return;\n  }", "const handler: NextApiHandler = async (request, response) => {\n  if (request.method !== \"POST\" && request.method !== \"OPTIONS\") {\n    response.status(405).json({ message: \"Method not allowed\" });\n    return;\n  }\n  if (!MASK_FUNCTION_URL) {\n    response.status(500).json({ message: \"MASK_FUNCTION_URL not set\" });\n    return;\n  }\n  let base64ImageWithoutPrefix = request.body.image.split(\";base64,\").pop();\n\n  const formData = new FormData();\n  formData.append(\n    \"file\",\n    Buffer.from(base64ImageWithoutPrefix, \"base64\"),\n    \"base.png\"\n  );\n\n  formData.append(\"fal_token\", falToken);\n  formData.append(\"x\", request.body.x);\n  formData.append(\"y\", request.body.y);\n  formData.append(\"extension\", request.body.extension);\n  formData.append(\"dilation\", request.body.dilation);\n  const res = await fetch(MASK_FUNCTION_URL, {\n    method: \"POST\",\n    body: formData,\n  });", "  if (!res.ok) {\n    response.status(res.status).send(res.statusText);\n    return;\n  }\n  await incrementImageCount({ by: 3 });\n  const imagesList: string[] = (await res.json()) as string[];\n\n  // masks are returned as the 3rd, 6th, and 9th images\n  const images = {\n    displayMasks: [imagesList[2], imagesList[5], imagesList[8]],\n    masks: [imagesList[0], imagesList[3], imagesList[6]],\n  };\n  response.json(images);\n};\n\nexport const config: PageConfig = {\n  api: {\n    bodyParser: {\n      sizeLimit: \"10mb\",\n    },\n  },\n};\n\nexport default handler;\n"]}
{"filename": "src/pages/api/fill.ts", "chunked_list": ["import { incrementImageCount } from \"@/data/storage\";\nimport FormData from \"form-data\";\nimport type { NextApiHandler } from \"next\";\nimport fetch from \"node-fetch\";\n\nconst FILL_FUNCTION_URL = process.env.NEXT_PUBLIC_FILL_FUNCTION_URL;\n\nconst falToken = process.env.FAL_TOKEN;\n\nconst handler: NextApiHandler = async (request, response) => {\n  if (request.method !== \"POST\" && request.method !== \"OPTIONS\") {\n    response.status(405).json({ message: \"Method not allowed\" });\n    return;\n  }", "\nconst handler: NextApiHandler = async (request, response) => {\n  if (request.method !== \"POST\" && request.method !== \"OPTIONS\") {\n    response.status(405).json({ message: \"Method not allowed\" });\n    return;\n  }\n  if (!FILL_FUNCTION_URL) {\n    response.status(500).json({ message: \"FILL_FUNCTION_URL not set\" });\n    return;\n  }\n\n  const maskFileBuffer = convertImageUrlToBuffer(request.body.mask_url);\n\n  let base64ImageWithoutPrefix = request.body.image_url.data\n    .split(\";base64,\")\n    .pop();\n\n  const formData = new FormData();\n  formData.append(\n    \"image_file\",\n    Buffer.from(base64ImageWithoutPrefix, \"base64\"),\n    \"image_file.png\"\n  );\n  formData.append(\"mask_file\", maskFileBuffer, \"mask_file.png\");\n  formData.append(\"fal_token\", falToken);\n  formData.append(\"prompt\", request.body.prompt);\n\n  const res = await fetch(FILL_FUNCTION_URL, {\n    method: \"POST\",\n    body: formData,\n  });", "  if (!res.ok) {\n    response.status(res.status).send(res.statusText);\n    return;\n  }\n  await incrementImageCount();\n  response.json(await res.json());\n};\n\nexport default handler;\nfunction convertImageUrlToBuffer(mask_url: any) {\n  throw new Error(\"Function not implemented.\");\n}\n", "function convertImageUrlToBuffer(mask_url: any) {\n  throw new Error(\"Function not implemented.\");\n}\n"]}
{"filename": "src/pages/api/rembg.ts", "chunked_list": ["import { incrementImageCount } from \"@/data/storage\";\n\nimport axios from \"axios\";\nimport FormData from \"form-data\";\nimport type { NextApiHandler } from \"next\";\n\nconst REMBG_URL = process.env.NEXT_PUBLIC_REMBG_URL;\n\nconst falToken = process.env.FAL_TOKEN;\n", "const falToken = process.env.FAL_TOKEN;\n\nconst handler: NextApiHandler = async (request, response) => {\n  if (request.method !== \"POST\" && request.method !== \"OPTIONS\") {\n    response.status(405).json({ message: \"Method not allowed\" });\n    return;\n  }\n  if (!REMBG_URL) {\n    response.status(500).json({ message: \"REMBG_URL not set\" });\n    return;\n  }\n  // save file\n  let base64ImageWithoutPrefix = request.body.base64Image\n    .split(\";base64,\")\n    .pop();\n\n  let formData = new FormData();\n  formData.append(\n    \"file\",\n    Buffer.from(base64ImageWithoutPrefix, \"base64\"),\n    \"anything.png\"\n  );\n  formData.append(\"fal_token\", falToken);\n\n  axios\n    .post(`${REMBG_URL}/remove`, formData)\n    .then(async (res) => {", "      if (res.status == 200) {\n        await incrementImageCount({ by: 1 });\n        const result = await res.data;\n        response.status(res.status).send({ imageUrl: res.data });\n      }\n    })\n    .catch((error) => console.error(error));\n};\n\nexport default handler;\n"]}
{"filename": "src/data/image.ts", "chunked_list": ["export interface ImageFile {\n  filename: string;\n  data: string;\n  size: {\n    width: number;\n    height: number;\n  };\n}\n"]}
{"filename": "src/data/storage.ts", "chunked_list": ["import kv from \"@vercel/kv\";\n\nconst NUMBER_OF_IMAGES_KEY = \"numberOfImages\";\n\nexport function isAvailable(): boolean {\n  return process.env.KV_REST_API_URL !== undefined;\n}\n\ntype IncrementArgs = {\n  by: number;\n};\n", "type IncrementArgs = {\n  by: number;\n};\n\nexport function incrementImageCount(\n  { by }: IncrementArgs = { by: 1 }\n): Promise<number> {\n  if (!isAvailable()) {\n    console.warn(\"KV storage is disabled.\");\n    return Promise.resolve(0);\n  }", "  if (by < 1) {\n    throw new Error(\"Increment cannot be less than 1\");\n  }\n  return kv.incrby(NUMBER_OF_IMAGES_KEY, by);\n}\n\nexport function getImageCount(): Promise<number | null> {\n  if (!isAvailable()) {\n    console.warn(\"KV storage is disabled.\");\n    return Promise.resolve(null);\n  }\n  return kv.get(NUMBER_OF_IMAGES_KEY);\n}\n"]}
{"filename": "src/data/modelMetadata.ts", "chunked_list": ["export type Model = {\n  id: string;\n  name: string;\n  apiEndpoint: string;\n  pythonCode: string;\n  jsCode: string;\n  curlCode: string;\n};\n\nconst regmbModel: Model = {\n  id: \"rembg\",\n  name: \"Rembg\",\n  apiEndpoint: process.env.NEXT_PUBLIC_REMBG_URL || \"\",\n  pythonCode: `\nimport requests\n\nrembg_base_url = \"${process.env.NEXT_PUBLIC_REMBG_URL}\"\nfal_token = \"<YOUR_TOKEN_HERE>\"\nrembg_response = requests.post(\n    f\"{rembg_base_url}/remove\",\n    files={\"file\": open(\"image.png\", \"rb\")},\n    data={\"fal_token\": fal_token},\n)\n    `,\n  jsCode: \"\",\n  curlCode: \"\",\n};\n\nconst segmentAnything: Model = {\n  id: \"sam\",\n  name: \"Segment Anything\",\n  apiEndpoint: process.env.NEXT_PUBLIC_MASK_FUNCTION_URL || \"\",\n  pythonCode: `\nimport requests\n\nsam_base_url = \"${process.env.NEXT_PUBLIC_MASK_FUNCTION_URL}\"\nfal_token = \"<YOUR_TOKEN_HERE>\"\nsam_response = requests.post(\n    f\"{sam_base_url}/masks\",\n    files={\"file\": open(\"image.png\", \"rb\")},\n    data={\"fal_token\": fal_token},\n)\n`,\n  jsCode: \"\",\n  curlCode: \"\",\n};\n\nconst controlnet: Model = {\n  id: \"controlnet\",\n  name: \"lllyasviel/sd-controlnet-scribble\",\n  apiEndpoint: process.env.NEXT_PUBLIC_CONTROLNET_SCRIBBLE_URL || \"\",\n  pythonCode: `\nimport requests\n\nurl = \"${process.env.NEXT_PUBLIC_CONTROLNET_SCRIBBLE_URL}\"\n\nresponse = requests.post(\n    f\"{url}/generate\",\n    files={\"file\": open(\"turtle.png\", \"rb\")},\n    data={\n        \"prompt\": \"turle on the sky\",\n        \"num_samples\": 1,\n        \"fal_token\": \"fal_token\",\n    },\n)\n`,\n  jsCode: \"\",\n  curlCode: \"\",\n};\n", "type ModelRegistry = {\n  [key: string]: Model;\n};\n\nexport const models: ModelRegistry = {\n  rembg: regmbModel,\n  sam: segmentAnything,\n  controlnet: controlnet,\n};\n"]}
