{"filename": "__init__.py", "chunked_list": [""]}
{"filename": "OrderService/run.py", "chunked_list": ["#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-03-20 22:57:08", "  $Author: Anders Wiklund\n    $Date: 2023-03-20 22:57:08\n     $Rev: 24\n\"\"\"\n\n# Third party modules\nimport uvicorn\n\n# Local modules\nfrom src.web.main import app", "# Local modules\nfrom src.web.main import app\n\n\nif __name__ == \"__main__\":\n\n    uv_config = {'app': 'src.web.main:app', 'port': 8000,\n                 'log_level': app.level, 'reload': True,\n                 'log_config': {\"disable_existing_loggers\": False, \"version\": 1}}\n    uvicorn.run(**uv_config)", ""]}
{"filename": "OrderService/queue_test_sender.py", "chunked_list": ["#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-03-25 00:01:55", "  $Author: Anders Wiklund\n    $Date: 2023-03-25 00:01:55\n     $Rev: 41\n\"\"\"\n\n# BUILTIN modules\nimport asyncio\n\n# Local modules\nfrom src.config.setup import config", "# Local modules\nfrom src.config.setup import config\nfrom src.tools.rabbit_client import RabbitClient\n\n# Constants\nSERVICE = 'TestService'\nCLIENT = RabbitClient(config.rabbit_url)\n\n\n# ---------------------------------------------------------", "\n# ---------------------------------------------------------\n#\nasync def sender():\n\n    for idx in range(1, 11):\n        msg = {\"title\": f\"message no {idx}\"}\n        await CLIENT.send_message(msg, SERVICE)\n        print(f'Sent message: {msg}')\n", "\n\n# ---------------------------------------------------------\n\nif __name__ == \"__main__\":\n\n    asyncio.run(sender())\n"]}
{"filename": "OrderService/redis_order_viewer.py", "chunked_list": ["#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-03-25 00:01:55", "  $Author: Anders Wiklund\n    $Date: 2023-03-25 00:01:55\n     $Rev: 41\n\"\"\"\n\n# BUILTIN modules\nimport json\nimport asyncio\nimport argparse\nfrom pprint import pprint", "import argparse\nfrom pprint import pprint\n\n# Third party modules\nfrom aioredis import from_url\n\n# Local modules\nfrom src.config.setup import config\n\n", "\n\n# ---------------------------------------------------------\n#\nasync def viewer(args: argparse.Namespace):\n    \"\"\" Show cached Redis order.\n\n    :param args: Command line arguments.\n    \"\"\"\n    client = from_url(config.redis_url)", "    \"\"\"\n    client = from_url(config.redis_url)\n\n    if response := await client.get(args.order_id):\n        pprint(json.loads(response.decode()), width=120)\n\n    else:\n        print(f'NOT CACHED: {args.order_id}')\n\n", "\n\n# ---------------------------------------------------------\n\nif __name__ == \"__main__\":\n    Form = argparse.ArgumentDefaultsHelpFormatter\n    description = 'A utility script that let you view cached order data.'\n    parser = argparse.ArgumentParser(description=description, formatter_class=Form)\n    parser.add_argument(\"order_id\", type=str, help=\"Specify Order ID\")\n    arguments = parser.parse_args()\n\n    asyncio.run(viewer(arguments))", ""]}
{"filename": "OrderService/__init__.py", "chunked_list": [""]}
{"filename": "OrderService/queue_test_receiver.py", "chunked_list": ["#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-03-25 00:01:55", "  $Author: Anders Wiklund\n    $Date: 2023-03-25 00:01:55\n     $Rev: 41\n\"\"\"\n\n# BUILTIN modules\nimport asyncio\nimport contextlib\n\n# Local modules", "\n# Local modules\nfrom src.config.setup import config\nfrom src.tools.rabbit_client import RabbitClient\n\n# Constants\nSERVICE = 'TestService'\n\n\n# ---------------------------------------------------------", "\n# ---------------------------------------------------------\n#\nasync def process_incoming_message(message: dict):\n    print(f'Received: {message}')\n\n\n# ---------------------------------------------------------\n#\nasync def receiver():", "#\nasync def receiver():\n    print('Started RabbitMQ message queue subscription...')\n    client = RabbitClient(config.rabbit_url, SERVICE, process_incoming_message)\n    connection = await asyncio.create_task(client.consume())\n\n    try:\n        # Wait until terminate\n        await asyncio.Future()\n\n    finally:\n        await connection.close()", "\n\n# ---------------------------------------------------------\n\nif __name__ == \"__main__\":\n\n    with contextlib.suppress(KeyboardInterrupt):\n        asyncio.run(receiver())\n", ""]}
{"filename": "OrderService/db_url_creator.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-03-24 23:50:19\n     $Rev: 40", "    $Date: 2023-03-24 23:50:19\n     $Rev: 40\n\"\"\"\n\n# BUILTIN modules\nimport asyncio\n\n# Local modules\nfrom src.repository.db import Engine\n", "from src.repository.db import Engine\n\n# Constants\nURLS = {'CustomerService': 'http://127.0.0.1:8002',\n        'DeliveryService': 'http://127.0.0.1:8003',\n        'KitchenService': 'http://127.0.0.1:8004',\n        'PaymentService': 'http://127.0.0.1:8001'}\n\n\n# ---------------------------------------------------------", "\n# ---------------------------------------------------------\n#\nasync def creator():\n    \"\"\" Insert URL in api_db.service_urls collection.\n\n    Drop the collection if it already exists, before the insertion.\n    \"\"\"\n    await Engine.connect_to_mongo()\n", "    await Engine.connect_to_mongo()\n\n    await Engine.db.service_urls.drop()\n    print(\"Dropped api_db.service_urls collection.\")\n\n    response = [{'_id': key, 'url': item} for key, item in URLS.items()]\n\n    await Engine.db.service_urls.insert_many(response)\n    result = await Engine.db.service_urls.count_documents({})\n    print(result, \"MicroService URLs are inserted in api_db.service_urls.\")", "    result = await Engine.db.service_urls.count_documents({})\n    print(result, \"MicroService URLs are inserted in api_db.service_urls.\")\n\n    await Engine.close_mongo_connection()\n\n\n# ---------------------------------------------------------\n\nif __name__ == \"__main__\":\n\n    asyncio.run(creator())", "if __name__ == \"__main__\":\n\n    asyncio.run(creator())\n"]}
{"filename": "OrderService/redis_url_cleaner.py", "chunked_list": ["#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-03-25 00:01:55", "  $Author: Anders Wiklund\n    $Date: 2023-03-25 00:01:55\n     $Rev: 41\n\"\"\"\n\n# BUILTIN modules\nimport asyncio\n\n# Third party modules\nfrom aioredis import from_url", "# Third party modules\nfrom aioredis import from_url\n\n# Local modules\nfrom src.config.setup import config\n\n# Constants\nURLS = {'PaymentService': 'http://127.0.0.1:8001',\n        'KitchenService': 'http://127.0.0.1:8004',\n        'DeliveryService': 'http://127.0.0.1:8003',", "        'KitchenService': 'http://127.0.0.1:8004',\n        'DeliveryService': 'http://127.0.0.1:8003',\n        'CustomerService': 'http://127.0.0.1:8002'}\n\n\n# ---------------------------------------------------------\n#\nasync def cleaner():\n    client = from_url(config.redis_url)\n\n    for key in URLS:\n        await client.delete(key)", "    client = from_url(config.redis_url)\n\n    for key in URLS:\n        await client.delete(key)\n\n\n# ---------------------------------------------------------\n\nif __name__ == \"__main__\":\n\n    asyncio.run(cleaner())", "if __name__ == \"__main__\":\n\n    asyncio.run(cleaner())\n"]}
{"filename": "OrderService/response_test_sender.py", "chunked_list": ["#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-03-25 00:01:55", "  $Author: Anders Wiklund\n    $Date: 2023-03-25 00:01:55\n     $Rev: 41\n\"\"\"\n\n# BUILTIN modules\nimport asyncio\nimport argparse\n\n# Local modules", "\n# Local modules\nfrom src.config.setup import config\nfrom src.tools.rabbit_client import RabbitClient\n\n# Constants\nPAYLOAD = {\n    \"DeliveryService\": {\n        \"delivery_id\": \"76d019f-5937-4a14-8091-1d9f18666c93\",\n        \"metadata\":", "        \"delivery_id\": \"76d019f-5937-4a14-8091-1d9f18666c93\",\n        \"metadata\":\n            {\n                \"receiver\": \"OrderService\",\n                \"customer_id\": \"f2861560-e9ed-4463-955f-0c55c3b416fb\"\n            }\n    },\n    \"KitchenService\": {\n        \"kitchen_id\": \"b4d7bb48-7b56-45c8-9eb3-dc6e96c09172\",\n        \"metadata\":", "        \"kitchen_id\": \"b4d7bb48-7b56-45c8-9eb3-dc6e96c09172\",\n        \"metadata\":\n            {\n                \"receiver\": \"OrderService\",\n                \"customer_id\": \"f2861560-e9ed-4463-955f-0c55c3b416fb\"\n            }\n    }\n}\n\"\"\" Service response payload messages. \"\"\"\n", "\"\"\" Service response payload messages. \"\"\"\n\n\n# ---------------------------------------------------------\n#\ndef _build_message(pid: int, order_id: str) -> dict:\n    \"\"\" Build response message\n\n    :param pid: Payload ID\n    :param order_id: Order ID", "    :param pid: Payload ID\n    :param order_id: Order ID\n    :return: response message.\n    \"\"\"\n    message = None\n\n    match pid:\n        case 1:\n            message = PAYLOAD['DeliveryService']\n            message['status'] = 'driverAvailable'", "            message = PAYLOAD['DeliveryService']\n            message['status'] = 'driverAvailable'\n        case 2:\n            message = PAYLOAD['KitchenService']\n            message['status'] = 'cookingMeal'\n        case 3:\n            message = PAYLOAD['KitchenService']\n            message['status'] = 'cookingDone'\n        case 4:\n            message = PAYLOAD['KitchenService']", "        case 4:\n            message = PAYLOAD['KitchenService']\n            message['status'] = 'pickedUp'\n        case 5:\n            message = PAYLOAD['DeliveryService']\n            message['status'] = 'inTransit'\n        case 6:\n            message = PAYLOAD['DeliveryService']\n            message['status'] = 'delivered'\n", "            message['status'] = 'delivered'\n\n    message['metadata']['order_id'] = order_id\n    return message\n\n\n# ---------------------------------------------------------\n#\nasync def sender(args: argparse.Namespace):\n    \"\"\" Send RabbitMQ payload test message.", "async def sender(args: argparse.Namespace):\n    \"\"\" Send RabbitMQ payload test message.\n\n    :param args: Command line arguments.\n    \"\"\"\n    client = RabbitClient(config.rabbit_url)\n    message = _build_message(args.pid, args.order_id)\n    await client.send_message(message, message['metadata']['receiver'])\n    print(f\"message sent to '{message['metadata']['receiver']}'\\n{message}\")\n", "    print(f\"message sent to '{message['metadata']['receiver']}'\\n{message}\")\n\n\n# ---------------------------------------------------------\n\nif __name__ == \"__main__\":\n    Form = argparse.ArgumentDefaultsHelpFormatter\n    description = 'A utility script that let you start the app choosing topic or queue handling.'\n    parser = argparse.ArgumentParser(description=description, formatter_class=Form)\n    parser.add_argument(\"order_id\", type=str, help=\"Specify Order ID\")", "    parser = argparse.ArgumentParser(description=description, formatter_class=Form)\n    parser.add_argument(\"order_id\", type=str, help=\"Specify Order ID\")\n    parser.add_argument(\"pid\", type=int, choices=list(range(1, 7)),\n                        help=\"Specify payload ID\")\n    arguments = parser.parse_args()\n    asyncio.run(sender(arguments))\n"]}
{"filename": "OrderService/src/tools/rabbit_client.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-03-30 17:41:49\n     $Rev: 50", "    $Date: 2023-03-30 17:41:49\n     $Rev: 50\n\"\"\"\n\n# BUILTIN modules\nimport asyncio\nfrom typing import Callable, Optional\n\n# Third party modules\nimport ujson as json", "# Third party modules\nimport ujson as json\nfrom aio_pika import connect, connect_robust, Message, DeliveryMode\nfrom aio_pika.abc import AbstractIncomingMessage, AbstractRobustConnection\n\n\n# -----------------------------------------------------------------------------\n#\nclass RabbitClient:\n    \"\"\" This class handles the communication with the RabbitMQ server.\n\n    Note: the queue mechanism is implemented to take advantage of good\n    horizontal message scaling when needed.\n\n    Both Publisher and Consumer async handling is implemented.\n    \"\"\"\n    rabbit_url: str = None\n\n    # ---------------------------------------------------------\n    #\n    def __init__(self, rabbit_url: str, service: Optional[str] = None,\n                 incoming_message_handler: Optional[Callable] = None):\n        \"\"\" The class initializer.\n\n        :param rabbit_url: RabbitMQ's connection string.\n        :param service: Name of receiving service (when using consume).\n        :param incoming_message_handler: Incoming message callback method.\n        \"\"\"\n\n        # Unique parameters.\n        self.rabbit_url = rabbit_url\n        self.service_name = service\n        self.message_handler = incoming_message_handler\n\n    # ---------------------------------------------------------\n    #\n    async def _process_incoming_message(self, message: AbstractIncomingMessage):\n        \"\"\" Processing incoming message from RabbitMQ.\n\n        :param message: Received message.\n        \"\"\"\n        if body := message.body:\n            await self.message_handler(json.loads(body))\n\n        await message.ack()\n\n    # ---------------------------------------------------------\n    #\n    async def consume(self) -> AbstractRobustConnection:\n        \"\"\" Setup message listener with the current running asyncio loop. \"\"\"\n        loop = asyncio.get_running_loop()\n\n        # Perform receive connection.\n        connection = await connect_robust(loop=loop, url=self.rabbit_url)\n\n        # Creating receive channel and setting quality of service.\n        channel = await connection.channel()\n\n        # To make sure the load is evenly distributed between the workers.\n        await channel.set_qos(1)\n\n        # Creating a receive queue.\n        queue = await channel.declare_queue(name=self.service_name, durable=True)\n\n        # Start consumption of existing and future messages.\n        await queue.consume(self._process_incoming_message, no_ack=False)\n\n        return connection\n\n    # ---------------------------------------------------------\n    #\n    @classmethod\n    async def send_message(cls, message: dict, queue: str):\n        \"\"\" Send message to RabbitMQ Publisher queue.\n\n        If the topic is defined, topic message routing is used, otherwise\n        queue message routing is used.\n\n        :param message: Message to be sent.\n        :param queue: Message queue to use for message sending.\n        :raise AssertionError: Parameters 'topic' and 'queue' are mutually exclusive.\n        \"\"\"\n        connection = await connect(url=cls.rabbit_url)\n        channel = await connection.channel()\n\n        message_body = Message(\n            content_type='application/json',\n            body=json.dumps(message, ensure_ascii=False).encode(),\n            delivery_mode=DeliveryMode.PERSISTENT)\n        await channel.default_exchange.publish(\n            routing_key=queue, message=message_body)", "class RabbitClient:\n    \"\"\" This class handles the communication with the RabbitMQ server.\n\n    Note: the queue mechanism is implemented to take advantage of good\n    horizontal message scaling when needed.\n\n    Both Publisher and Consumer async handling is implemented.\n    \"\"\"\n    rabbit_url: str = None\n\n    # ---------------------------------------------------------\n    #\n    def __init__(self, rabbit_url: str, service: Optional[str] = None,\n                 incoming_message_handler: Optional[Callable] = None):\n        \"\"\" The class initializer.\n\n        :param rabbit_url: RabbitMQ's connection string.\n        :param service: Name of receiving service (when using consume).\n        :param incoming_message_handler: Incoming message callback method.\n        \"\"\"\n\n        # Unique parameters.\n        self.rabbit_url = rabbit_url\n        self.service_name = service\n        self.message_handler = incoming_message_handler\n\n    # ---------------------------------------------------------\n    #\n    async def _process_incoming_message(self, message: AbstractIncomingMessage):\n        \"\"\" Processing incoming message from RabbitMQ.\n\n        :param message: Received message.\n        \"\"\"\n        if body := message.body:\n            await self.message_handler(json.loads(body))\n\n        await message.ack()\n\n    # ---------------------------------------------------------\n    #\n    async def consume(self) -> AbstractRobustConnection:\n        \"\"\" Setup message listener with the current running asyncio loop. \"\"\"\n        loop = asyncio.get_running_loop()\n\n        # Perform receive connection.\n        connection = await connect_robust(loop=loop, url=self.rabbit_url)\n\n        # Creating receive channel and setting quality of service.\n        channel = await connection.channel()\n\n        # To make sure the load is evenly distributed between the workers.\n        await channel.set_qos(1)\n\n        # Creating a receive queue.\n        queue = await channel.declare_queue(name=self.service_name, durable=True)\n\n        # Start consumption of existing and future messages.\n        await queue.consume(self._process_incoming_message, no_ack=False)\n\n        return connection\n\n    # ---------------------------------------------------------\n    #\n    @classmethod\n    async def send_message(cls, message: dict, queue: str):\n        \"\"\" Send message to RabbitMQ Publisher queue.\n\n        If the topic is defined, topic message routing is used, otherwise\n        queue message routing is used.\n\n        :param message: Message to be sent.\n        :param queue: Message queue to use for message sending.\n        :raise AssertionError: Parameters 'topic' and 'queue' are mutually exclusive.\n        \"\"\"\n        connection = await connect(url=cls.rabbit_url)\n        channel = await connection.channel()\n\n        message_body = Message(\n            content_type='application/json',\n            body=json.dumps(message, ensure_ascii=False).encode(),\n            delivery_mode=DeliveryMode.PERSISTENT)\n        await channel.default_exchange.publish(\n            routing_key=queue, message=message_body)", ""]}
{"filename": "OrderService/src/tools/custom_logging.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-03-25 17:47:36\n     $Rev: 42", "    $Date: 2023-03-25 17:47:36\n     $Rev: 42\n\"\"\"\n\n# BUILTIN modules\nimport sys\nimport logging\nfrom typing import cast\nfrom types import FrameType\n", "from types import FrameType\n\n# Third party modules\nfrom loguru import logger\n\n\n# ---------------------------------------------------------\n#\nclass InterceptHandler(logging.Handler):\n    \"\"\" Logs to loguru from Python logging module. \"\"\"\n\n    def emit(self, record: logging.LogRecord):\n        try:\n            level = logger.level(record.levelname).name\n\n        except ValueError:\n            level = str(record.levelno)\n\n        frame, depth = logging.currentframe(), 2\n\n        while frame.f_code.co_filename == logging.__file__:\n            frame = cast(FrameType, frame.f_back)\n            depth += 1\n\n        logger.opt(\n            depth=depth,\n            exception=record.exc_info).log(\n            level,\n            record.getMessage()\n        )", "class InterceptHandler(logging.Handler):\n    \"\"\" Logs to loguru from Python logging module. \"\"\"\n\n    def emit(self, record: logging.LogRecord):\n        try:\n            level = logger.level(record.levelname).name\n\n        except ValueError:\n            level = str(record.levelno)\n\n        frame, depth = logging.currentframe(), 2\n\n        while frame.f_code.co_filename == logging.__file__:\n            frame = cast(FrameType, frame.f_back)\n            depth += 1\n\n        logger.opt(\n            depth=depth,\n            exception=record.exc_info).log(\n            level,\n            record.getMessage()\n        )", "\n\n# ---------------------------------------------------------\n#\ndef create_unified_logger(log_level: str) -> tuple:\n    \"\"\" Return unified Loguru logger object.\n\n    :return: unified Loguru logger object.\n    \"\"\"\n\n    level = log_level\n\n    # Remove all existing loggers.\n    logger.remove()\n\n    # Create a basic Loguru logging config.\n    logger.add(\n        diagnose=True,\n        backtrace=True,\n        sink=sys.stderr,\n        level=level.upper(),\n    )\n\n    # Prepare to incorporate python standard logging.\n    seen = set()\n    logging.basicConfig(handlers=[InterceptHandler()], level=0)\n\n    for logger_name in logging.root.manager.loggerDict.keys():\n\n        if logger_name not in seen:\n            seen.add(logger_name.split(\".\")[0])\n            mod_logger = logging.getLogger(logger_name)\n            mod_logger.handlers = [InterceptHandler(level=level.upper())]\n            mod_logger.propagate = False\n\n    return level, logger.bind(request_id=None, method=None)", ""]}
{"filename": "OrderService/src/business/response_handler.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-04-01 17:51:19\n     $Rev: 55", "    $Date: 2023-04-01 17:51:19\n     $Rev: 55\n\"\"\"\n\n# BUILTIN modules\nfrom uuid import UUID\n\n# Third party modules\nfrom loguru import logger\nfrom httpx import AsyncClient, ConnectTimeout", "from loguru import logger\nfrom httpx import AsyncClient, ConnectTimeout\n\n# Local modules\nfrom ..config.setup import config\nfrom ..repository.url_cache import UrlCache\nfrom .schemas import KitchenPayload, DeliveryPayload\nfrom ..repository.order_data_adapter import OrdersRepository\nfrom ..repository.models import Status, OrderModel, StateUpdateSchema\n", "from ..repository.models import Status, OrderModel, StateUpdateSchema\n\n\n# ------------------------------------------------------------------------\n#\nclass OrderResponseLogic:\n    \"\"\"\n    This class implements the OrderService business logic layer\n    for RabbitMQ response messages.\n    \"\"\"\n\n    # ---------------------------------------------------------\n    #\n    def __init__(self, cache: UrlCache, repository: OrdersRepository):\n        \"\"\" The class initializer.\n\n        :param repository: Data layer handler object.\n        \"\"\"\n        self.cache = cache\n        self.repo = repository\n\n    # ---------------------------------------------------------\n    #\n    async def _update_order_in_db(self, order: OrderModel):\n        \"\"\" Update Order in DB.\n\n        :param order: Current Order.\n        \"\"\"\n        successful = await self.repo.update(order)\n\n        if not successful:\n            errmsg = f\"Failed updating {order.id=} in api_db.orders\"\n            raise RuntimeError(errmsg)\n\n        log = getattr(logger, ('error' if order.status == 'paymentFailed' else 'info'))\n        log(f'Stored {order.status=} in DB for {order.id=}.')\n\n    # ---------------------------------------------------------\n    #\n    async def _handle_successful_payment(self, message: dict, order: OrderModel):\n        \"\"\" Payment was successful so get Customer Address and request DeliveryService work.\n\n        :param message: PaymentService response message.\n        :param order: Current Order.\n        \"\"\"\n        try:\n            root = await self.cache.get('CustomerService')\n\n            # Get Customer Address information.\n            async with AsyncClient() as client:\n                service = 'CustomerService'\n                url = f\"{root}/v1/customers/{order.customer_id}/address\"\n                resp = await client.get(url=url, timeout=config.url_timeout)\n\n            if resp.status_code != 200:\n                errmsg = f\"Failed {service} POST request for URL {url} - \" \\\n                         f\"[{resp.status_code}: {resp.json()['detail']}].\"\n                raise RuntimeError(errmsg)\n\n            payload = DeliveryPayload(metadata=message['metadata'],\n                                      address=resp.json(), **order.dict())\n\n            root = await self.cache.get('DeliveryService')\n\n            # Request DeliveryService work.\n            async with AsyncClient() as client:\n                service = 'DeliveryService'\n                url = f\"{root}/v1/deliveries\"\n                resp = await client.post(url=url, json=payload.dict(),\n                                         timeout=config.url_timeout)\n\n            if resp.status_code != 202:\n                errmsg = f\"Failed {service} POST request for URL {url} - \" \\\n                         f\"[{resp.status_code}: {resp.json()['detail']}].\"\n                raise RuntimeError(errmsg)\n\n            data = resp.json()\n            order.status = data['status']\n            order.delivery_id = data['delivery_id']\n            order.updated.append(StateUpdateSchema(status=order.status))\n            await self._update_order_in_db(order)\n\n        except ConnectTimeout:\n            errmsg = f'No connection with {service} on URL {url}'\n            raise ConnectionError(errmsg)\n\n    # ---------------------------------------------------------\n    #\n    async def _handle_delivery_ready(self, message: dict, order: OrderModel):\n        \"\"\" Delivery is ready for pickup so request KitchenService work.\n\n        :param message: DeliveryService metadata response message.\n        :param order: Current Order.\n        \"\"\"\n        payload = KitchenPayload(metadata=message['metadata'], **order.dict())\n\n        try:\n            root = await self.cache.get('KitchenService')\n\n            # Request KitchenService work.\n            async with AsyncClient() as client:\n                url = f\"{root}/v1/kitchen\"\n                resp = await client.post(url=url, json=payload.dict(),\n                                         timeout=config.url_timeout)\n\n            if resp.status_code != 202:\n                errmsg = f\"Failed KitchenService POST request for URL {url} \" \\\n                         f\"- [{resp.status_code}: {resp.json()['detail']}].\"\n                raise RuntimeError(errmsg)\n\n            data = resp.json()\n            order.status = data['status']\n            order.kitchen_id = data['kitchen_id']\n            order.updated.append(StateUpdateSchema(status=order.status))\n            await self._update_order_in_db(order)\n\n        except ConnectTimeout:\n            errmsg = f'No connection with KitchenService on URL {url}'\n            raise ConnectionError(errmsg)\n\n    # ---------------------------------------------------------\n    #\n    async def process_response(self, message: dict):\n        \"\"\" Process response message data.\n\n        Implemented business logic:\n          - Every received message state is updated in DB.\n          - When status is 'paymentPaid':\n              - Trigger DeliveryService work.\n          - When status is 'driverAvailable':\n              - Trigger KitchenService work.\n\n        :param message: Response message data.\n        \"\"\"\n        status = message['status']\n        order_id = UUID(message['metadata']['order_id'])\n\n        try:\n            # Read specified Order from DB.\n            order = await self.repo.read(order_id)\n\n            if not order:\n                raise RuntimeError(f'{order_id=} is unknown')\n\n            order.status = status\n            order.updated.append(StateUpdateSchema(status=order.status))\n            await self._update_order_in_db(order)\n\n            if status == Status.PAID:\n                await self._handle_successful_payment(message, order)\n\n            elif status == Status.DRAV:\n                await self._handle_delivery_ready(message, order)\n\n        except RuntimeError as why:\n            logger.error(f'{why}')\n\n        except ConnectionError as why:\n            logger.critical(f'{why}')\n\n        except BaseException as why:\n            logger.critical(f'Failed processing response {status=} => {why}')", ""]}
{"filename": "OrderService/src/business/schemas.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-04-02 14:01:36\n     $Rev: 57", "    $Date: 2023-04-02 14:01:36\n     $Rev: 57\n\"\"\"\n\n# BUILTIN modules\nfrom uuid import UUID\n\n# Third party modules\nfrom pydantic import BaseModel, validator\n", "from pydantic import BaseModel, validator\n\n# Local modules\nfrom ..repository.models import OrderItems, Status\n\n\n# ---------------------------------------------------------\n#\nclass MetadataSchema(BaseModel):\n    \"\"\" Representation of Order metadata in the system. \"\"\"\n    receiver: str\n    order_id: str\n    customer_id: str\n\n    @validator('*', pre=True)\n    def decode_values(cls, value):\n        \"\"\" Decode UUID value into a str. \"\"\"\n        return str(value) if isinstance(value, UUID) else value", "class MetadataSchema(BaseModel):\n    \"\"\" Representation of Order metadata in the system. \"\"\"\n    receiver: str\n    order_id: str\n    customer_id: str\n\n    @validator('*', pre=True)\n    def decode_values(cls, value):\n        \"\"\" Decode UUID value into a str. \"\"\"\n        return str(value) if isinstance(value, UUID) else value", "\n\n# ---------------------------------------------------------\n#\nclass PaymentPayload(OrderItems):\n    \"\"\" Representation of a payment payload in the system. \"\"\"\n    metadata: MetadataSchema\n\n\n# ---------------------------------------------------------", "\n# ---------------------------------------------------------\n#\nclass PaymentResponse(BaseModel):\n    \"\"\" Representation of a payment response in the system. \"\"\"\n    metadata: MetadataSchema\n    status: Status\n\n\n# ---------------------------------------------------------", "\n# ---------------------------------------------------------\n#\nclass KitchenPayload(OrderItems):\n    \"\"\" Representation of a Kitchen payload in the system. \"\"\"\n    metadata: MetadataSchema\n\n\n# ---------------------------------------------------------\n#\nclass CustomerAddressSchema(BaseModel):\n    \"\"\" Representation of Customer Address Information in the system. \"\"\"\n    name: str\n    city: str\n    street: str\n    zipcode: str", "# ---------------------------------------------------------\n#\nclass CustomerAddressSchema(BaseModel):\n    \"\"\" Representation of Customer Address Information in the system. \"\"\"\n    name: str\n    city: str\n    street: str\n    zipcode: str\n\n", "\n\n# ---------------------------------------------------------\n#\nclass DeliveryPayload(OrderItems):\n    \"\"\" Representation of a Delivery payload in the system. \"\"\"\n    metadata: MetadataSchema\n    address: CustomerAddressSchema\n", ""]}
{"filename": "OrderService/src/business/request_handler.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-03-30 13:14:04\n     $Rev: 48", "    $Date: 2023-03-30 13:14:04\n     $Rev: 48\n\"\"\"\n\n# BUILTIN modules\nfrom datetime import datetime\nfrom typing import Optional, List\n\n# Third party modules\nfrom pydantic import UUID4", "# Third party modules\nfrom pydantic import UUID4\nfrom fastapi import HTTPException\nfrom httpx import AsyncClient, ConnectTimeout\n\n# Local modules\nfrom ..config.setup import config\nfrom ..repository.url_cache import UrlCache\nfrom ..web.api.schemas import OrderResponse\nfrom .schemas import PaymentPayload, MetadataSchema", "from ..web.api.schemas import OrderResponse\nfrom .schemas import PaymentPayload, MetadataSchema\nfrom ..repository.order_data_adapter import OrdersRepository\nfrom ..repository.models import Status, OrderItems, OrderModel, StateUpdateSchema\n\n\n# ------------------------------------------------------------------------\n#\nclass OrderApiLogic:\n    \"\"\"\n    This class implements the OrderService web API business logic layer.\n    \"\"\"\n\n    # ---------------------------------------------------------\n    #\n    def __init__(\n            self,\n            id: UUID4,\n            created: datetime,\n            items: OrderItems,\n            repository: OrdersRepository,\n            updated: List[StateUpdateSchema],\n            status: Status, customer_id: UUID4,\n            kitchen_id: Optional[UUID4] = None,\n            delivery_id: Optional[UUID4] = None,\n    ):\n        \"\"\" The class initializer.\n\n        :param id: Order id.\n        :param created: Order created timestamp.\n        :param items: Ordered items.\n        :param status: Current order status.\n        :param customer_id: The individual that created the order.\n        :param kitchen_id: Does not exist before the scheduled state.\n        :param delivery_id: Does not exist before the dispatched state.\n        \"\"\"\n        self._id = id\n        self.items = items\n        self._status = status\n        self.updated = updated\n        self._created = created\n        self.kitchen_id = kitchen_id\n        self.delivery_id = delivery_id\n        self.customer_id = customer_id\n\n        # Initialize objects.\n        self.repo = repository\n        self.cache = UrlCache(config.redis_url)\n\n    # ---------------------------------------------------------\n    #\n    @property\n    def id(self) -> UUID4:\n        \"\"\" Return order id.\n\n        :return: order id.\n        \"\"\"\n        return self._id\n\n    # ---------------------------------------------------------\n    #\n    @property\n    def created(self) -> datetime:\n        \"\"\" Return current order creation time.\n\n        :return: datetime when the order was created.\n        \"\"\"\n        return self._created\n\n    # ---------------------------------------------------------\n    #\n    @property\n    def status(self) -> Status:\n        \"\"\" Return current order status.\n\n        :return: current status\n        \"\"\"\n        return self._status\n\n    # ---------------------------------------------------------\n    #\n    async def _pay(self) -> None:\n        \"\"\" Trigger payment of ordered items.\n\n        :raise HTTPException [400]: when PaymentService response code != 202.\n        :raise HTTPException [500]: when connection with PaymentService failed.\n        \"\"\"\n        meta = MetadataSchema(order_id=self.id,\n                              customer_id=self.customer_id,\n                              receiver=f'{config.service_name}')\n        payment = PaymentPayload(metadata=meta, **self.dict())\n\n        try:\n            root = await self.cache.get('PaymentService')\n\n            async with AsyncClient() as client:\n                url = f\"{root}/v1/payments\"\n                response = await client.post(url=url,\n                                             json=payment.dict(),\n                                             timeout=config.url_timeout)\n\n            if response.status_code != 202:\n                errmsg = f\"Failed PaymentService POST request for URL {url} with Order ID \"  \\\n                         f\"{self.id} - [{response.status_code}: {response.json()['detail']}].\"\n                raise HTTPException(status_code=400, detail=errmsg)\n\n        except ConnectTimeout:\n            errmsg = f'No connection with PaymentService on URL {url}'\n            raise HTTPException(status_code=500, detail=errmsg)\n\n    # ---------------------------------------------------------\n    #\n    async def _reimburse(self) -> None:\n        \"\"\" Trigger reimbursement of cancelled order items.\n\n        :raise HTTPException [400]: when PaymentService response code != 202.\n        :raise HTTPException [500]: when connection with PaymentService failed.\n        \"\"\"\n        meta = MetadataSchema(order_id=self.id,\n                              customer_id=self.customer_id,\n                              receiver=f'{config.service_name}')\n        payment = PaymentPayload(metadata=meta, **self.dict())\n\n        try:\n            root = await self.cache.get('PaymentService')\n\n            async with AsyncClient() as client:\n                url = f\"{root}/v1/payments/reimburse\"\n                response = await client.post(url=url,\n                                             json=payment.dict(),\n                                             timeout=config.url_timeout)\n\n            if response.status_code != 202:\n                errmsg = f\"Failed PaymentService POST request for URL {url} with Order ID \"  \\\n                         f\"{self.id} - [{response.status_code}: {response.json()['detail']}].\"\n                raise HTTPException(status_code=400, detail=errmsg)\n\n        except ConnectTimeout:\n            errmsg = f'No connection with PaymentService on URL {url}'\n            raise HTTPException(status_code=500, detail=errmsg)\n\n    # ---------------------------------------------------------\n    #\n    async def create(self) -> OrderResponse:\n        \"\"\" Charge the Customers Credit Card and create a new order in DB.\n\n        :raise HTTPException [400]: when PaymentService response code != 202.\n        :raise HTTPException [500]: when connection with PaymentService failed.\n        :raise HTTPException [400]: when create order in DB api_db.orders failed.\n        \"\"\"\n        await self._pay()\n\n        # Create a new Order document in DB.\n        db_order = OrderModel(**self.dict())\n        successful = await self.repo.create(db_order)\n\n        if not successful:\n            errmsg = f\"Create failed for {self.id=} in api_db.orders\"\n            raise HTTPException(status_code=400, detail=errmsg)\n\n        return OrderResponse(**db_order.dict())\n\n    # ---------------------------------------------------------\n    #\n    async def cancel(self) -> OrderResponse:\n        \"\"\" Cancel current order.\n\n        NOTE: this can only be done before a driver is available (status DRAV).\n\n        :raise HTTPException [400]: when cancel request came too late.\n        :raise HTTPException [400]: when Order update in DB api_db.orders failed.\n        \"\"\"\n        await self._reimburse()\n\n        if self.status != Status.DESC:\n            errmsg = f'Could not cancel order with id {self.id} and {self.status=}'\n            raise HTTPException(status_code=400, detail=errmsg)\n\n        # Prepare order update.\n        db_order = OrderModel(**self.dict())\n        db_order.status = Status.ORCA\n        db_order.updated.append(StateUpdateSchema(status=db_order.status))\n\n        # Update Order status in DB.\n        successful = await self.repo.update(db_order)\n\n        if not successful:\n            errmsg = f\"Failed updating {self.id=} in api_db.orders\"\n            raise HTTPException(status_code=400, detail=errmsg)\n\n        return OrderResponse(**db_order.dict())\n\n    # ---------------------------------------------------------\n    #\n    async def delete(self) -> None:\n        \"\"\" Delete current order.\n\n        :raise HTTPException [404]: when Order not found in DB api_db.orders.\n        \"\"\"\n        response = await self.repo.delete(self.id)\n\n        if response.deleted_count == 0:\n            errmsg = f\"{self.id=} not found in api_db.orders\"\n            raise HTTPException(status_code=404, detail=errmsg)\n\n    # ---------------------------------------------------------\n    #\n    def dict(self) -> dict:\n        \"\"\" Return essential class parameters using base class types.\n\n        :return: Base class types representation of the class.\n        \"\"\"\n        return {\n            'id': str(self.id),\n            'items': self.items,\n            'status': self.status,\n            'created': str(self.created),\n            'customer_id': str(self.customer_id),\n            'kitchen_id': (str(self.kitchen_id) if self.kitchen_id else None),\n            'delivery_id': (str(self.delivery_id) if self.delivery_id else None),\n            'updated': list(map(lambda elem: {'status': elem['status'],\n                                              'when': str(elem['when'])}, self.updated))}", "class OrderApiLogic:\n    \"\"\"\n    This class implements the OrderService web API business logic layer.\n    \"\"\"\n\n    # ---------------------------------------------------------\n    #\n    def __init__(\n            self,\n            id: UUID4,\n            created: datetime,\n            items: OrderItems,\n            repository: OrdersRepository,\n            updated: List[StateUpdateSchema],\n            status: Status, customer_id: UUID4,\n            kitchen_id: Optional[UUID4] = None,\n            delivery_id: Optional[UUID4] = None,\n    ):\n        \"\"\" The class initializer.\n\n        :param id: Order id.\n        :param created: Order created timestamp.\n        :param items: Ordered items.\n        :param status: Current order status.\n        :param customer_id: The individual that created the order.\n        :param kitchen_id: Does not exist before the scheduled state.\n        :param delivery_id: Does not exist before the dispatched state.\n        \"\"\"\n        self._id = id\n        self.items = items\n        self._status = status\n        self.updated = updated\n        self._created = created\n        self.kitchen_id = kitchen_id\n        self.delivery_id = delivery_id\n        self.customer_id = customer_id\n\n        # Initialize objects.\n        self.repo = repository\n        self.cache = UrlCache(config.redis_url)\n\n    # ---------------------------------------------------------\n    #\n    @property\n    def id(self) -> UUID4:\n        \"\"\" Return order id.\n\n        :return: order id.\n        \"\"\"\n        return self._id\n\n    # ---------------------------------------------------------\n    #\n    @property\n    def created(self) -> datetime:\n        \"\"\" Return current order creation time.\n\n        :return: datetime when the order was created.\n        \"\"\"\n        return self._created\n\n    # ---------------------------------------------------------\n    #\n    @property\n    def status(self) -> Status:\n        \"\"\" Return current order status.\n\n        :return: current status\n        \"\"\"\n        return self._status\n\n    # ---------------------------------------------------------\n    #\n    async def _pay(self) -> None:\n        \"\"\" Trigger payment of ordered items.\n\n        :raise HTTPException [400]: when PaymentService response code != 202.\n        :raise HTTPException [500]: when connection with PaymentService failed.\n        \"\"\"\n        meta = MetadataSchema(order_id=self.id,\n                              customer_id=self.customer_id,\n                              receiver=f'{config.service_name}')\n        payment = PaymentPayload(metadata=meta, **self.dict())\n\n        try:\n            root = await self.cache.get('PaymentService')\n\n            async with AsyncClient() as client:\n                url = f\"{root}/v1/payments\"\n                response = await client.post(url=url,\n                                             json=payment.dict(),\n                                             timeout=config.url_timeout)\n\n            if response.status_code != 202:\n                errmsg = f\"Failed PaymentService POST request for URL {url} with Order ID \"  \\\n                         f\"{self.id} - [{response.status_code}: {response.json()['detail']}].\"\n                raise HTTPException(status_code=400, detail=errmsg)\n\n        except ConnectTimeout:\n            errmsg = f'No connection with PaymentService on URL {url}'\n            raise HTTPException(status_code=500, detail=errmsg)\n\n    # ---------------------------------------------------------\n    #\n    async def _reimburse(self) -> None:\n        \"\"\" Trigger reimbursement of cancelled order items.\n\n        :raise HTTPException [400]: when PaymentService response code != 202.\n        :raise HTTPException [500]: when connection with PaymentService failed.\n        \"\"\"\n        meta = MetadataSchema(order_id=self.id,\n                              customer_id=self.customer_id,\n                              receiver=f'{config.service_name}')\n        payment = PaymentPayload(metadata=meta, **self.dict())\n\n        try:\n            root = await self.cache.get('PaymentService')\n\n            async with AsyncClient() as client:\n                url = f\"{root}/v1/payments/reimburse\"\n                response = await client.post(url=url,\n                                             json=payment.dict(),\n                                             timeout=config.url_timeout)\n\n            if response.status_code != 202:\n                errmsg = f\"Failed PaymentService POST request for URL {url} with Order ID \"  \\\n                         f\"{self.id} - [{response.status_code}: {response.json()['detail']}].\"\n                raise HTTPException(status_code=400, detail=errmsg)\n\n        except ConnectTimeout:\n            errmsg = f'No connection with PaymentService on URL {url}'\n            raise HTTPException(status_code=500, detail=errmsg)\n\n    # ---------------------------------------------------------\n    #\n    async def create(self) -> OrderResponse:\n        \"\"\" Charge the Customers Credit Card and create a new order in DB.\n\n        :raise HTTPException [400]: when PaymentService response code != 202.\n        :raise HTTPException [500]: when connection with PaymentService failed.\n        :raise HTTPException [400]: when create order in DB api_db.orders failed.\n        \"\"\"\n        await self._pay()\n\n        # Create a new Order document in DB.\n        db_order = OrderModel(**self.dict())\n        successful = await self.repo.create(db_order)\n\n        if not successful:\n            errmsg = f\"Create failed for {self.id=} in api_db.orders\"\n            raise HTTPException(status_code=400, detail=errmsg)\n\n        return OrderResponse(**db_order.dict())\n\n    # ---------------------------------------------------------\n    #\n    async def cancel(self) -> OrderResponse:\n        \"\"\" Cancel current order.\n\n        NOTE: this can only be done before a driver is available (status DRAV).\n\n        :raise HTTPException [400]: when cancel request came too late.\n        :raise HTTPException [400]: when Order update in DB api_db.orders failed.\n        \"\"\"\n        await self._reimburse()\n\n        if self.status != Status.DESC:\n            errmsg = f'Could not cancel order with id {self.id} and {self.status=}'\n            raise HTTPException(status_code=400, detail=errmsg)\n\n        # Prepare order update.\n        db_order = OrderModel(**self.dict())\n        db_order.status = Status.ORCA\n        db_order.updated.append(StateUpdateSchema(status=db_order.status))\n\n        # Update Order status in DB.\n        successful = await self.repo.update(db_order)\n\n        if not successful:\n            errmsg = f\"Failed updating {self.id=} in api_db.orders\"\n            raise HTTPException(status_code=400, detail=errmsg)\n\n        return OrderResponse(**db_order.dict())\n\n    # ---------------------------------------------------------\n    #\n    async def delete(self) -> None:\n        \"\"\" Delete current order.\n\n        :raise HTTPException [404]: when Order not found in DB api_db.orders.\n        \"\"\"\n        response = await self.repo.delete(self.id)\n\n        if response.deleted_count == 0:\n            errmsg = f\"{self.id=} not found in api_db.orders\"\n            raise HTTPException(status_code=404, detail=errmsg)\n\n    # ---------------------------------------------------------\n    #\n    def dict(self) -> dict:\n        \"\"\" Return essential class parameters using base class types.\n\n        :return: Base class types representation of the class.\n        \"\"\"\n        return {\n            'id': str(self.id),\n            'items': self.items,\n            'status': self.status,\n            'created': str(self.created),\n            'customer_id': str(self.customer_id),\n            'kitchen_id': (str(self.kitchen_id) if self.kitchen_id else None),\n            'delivery_id': (str(self.delivery_id) if self.delivery_id else None),\n            'updated': list(map(lambda elem: {'status': elem['status'],\n                                              'when': str(elem['when'])}, self.updated))}", ""]}
{"filename": "OrderService/src/repository/models.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-04-01 17:51:19\n     $Rev: 55", "    $Date: 2023-04-01 17:51:19\n     $Rev: 55\n\"\"\"\n\n# BUILTIN modules\nfrom enum import Enum\nfrom uuid import uuid4\nfrom datetime import datetime\nfrom typing import Optional, Callable, List\n", "from typing import Optional, Callable, List\n\n# Third party modules\nfrom pydantic import (BaseModel, BaseConfig,\n                      Field, UUID4, conlist, conint)\n\n# Local modules\nfrom .documentation import (order_documentation as order_doc)\n\n", "\n\n# ---------------------------------------------------------\n#\nclass Status(str, Enum):\n    \"\"\" Order status changes.\n\n    CREA -> PAID/FAIL -> DISC -> DRAV -> SHED -> COOK -> PROD -> PICK -> TRAN -> DONE\n\n    An Order can be cancelled before DRAV status has been reached (finding an available\n    driver sometimes take time, so the Customer is unwilling to wait any longer).\n    \"\"\"\n    CREA = 'created'            # OrderService\n    ORCA = 'orderCancelled'     # OrderService\n    PAID = 'paymentPaid'        # PaymentService\n    REIM = 'reimbursed'         # PaymentService\n    FAIL = 'paymentFailed'      # PaymentService\n    DESC = 'deliveryScheduled'  # DeliveryService\n    DRAV = 'driverAvailable'    # DeliveryService\n    SHED = 'cookingScheduled'   # KitchenService\n    COOK = 'cookingMeal'        # KitchenService\n    PROD = 'cookingDone'        # KitchenService\n    PICK = 'pickedUp'           # KitchenService\n    TRAN = 'inTransit'          # DeliveryService\n    DONE = 'delivered'          # DeliveryService", "\n\n# ---------------------------------------------------------\n#\nclass Products(str, Enum):\n    \"\"\" Representation of valid products in the system. \"\"\"\n    lasagna = 'Lasagna'\n    cheese_burger = 'Double Cheeseburger'\n    veil = 'Veil with glazed onions and blue cheese'\n    vego_salad = 'Vegetarian Salad with healthy produce'", "\n\nclass OrderItem(BaseModel):\n    \"\"\" Required order item parameters. \"\"\"\n    product: Products\n    quantity: Optional[conint(ge=1, strict=True)] = 1\n\n\nclass OrderItems(BaseModel):\n    \"\"\" A list of the ordered items. \"\"\"\n    items: conlist(OrderItem, min_items=1)", "class OrderItems(BaseModel):\n    \"\"\" A list of the ordered items. \"\"\"\n    items: conlist(OrderItem, min_items=1)\n\n\n# ------------------------------------------------------------------------\n#\nclass MongoBase(BaseModel):\n    \"\"\"\n    Class that handles conversions between MongoDB '_id' key\n    and our own 'id' key.\n\n    MongoDB uses `_id` as an internal default index key.\n    We can use that to our advantage.\n    \"\"\"\n\n    class Config(BaseConfig):\n        \"\"\" basic config. \"\"\"\n        orm_mode = True\n        allow_population_by_field_name = True\n\n    # noinspection PyArgumentList\n    @classmethod\n    def from_mongo(cls, data: dict) -> Callable:\n        \"\"\" Convert \"_id\" (str object) into \"id\" (UUID object). \"\"\"\n\n        if not data:\n            return data\n\n        mongo_id = data.pop('_id', None)\n        return cls(**dict(data, id=mongo_id))\n\n    def to_mongo(self, **kwargs) -> dict:\n        \"\"\" Convert \"id\" (UUID object) into \"_id\" (str object). \"\"\"\n        parsed = self.dict(**kwargs)\n\n        if '_id' not in parsed and 'id' in parsed:\n            parsed['_id'] = str(parsed.pop('id'))\n\n        return parsed", "\n\n# ---------------------------------------------------------\n#\nclass StateUpdateSchema(BaseModel):\n    \"\"\" Representation of an Order status history in the system. \"\"\"\n    status: Status = Field(**order_doc['status'])\n    when: datetime = Field(default_factory=datetime.utcnow, **order_doc['when'])\n\n\nclass OrderUpdateModel(MongoBase):\n    \"\"\" Representation of an Order in the system. \"\"\"\n    items: conlist(OrderItem, min_items=1)\n    customer_id: UUID4 = Field(**order_doc['customer_id'])\n    kitchen_id: Optional[UUID4] = Field(**order_doc['kitchen_id'])\n    delivery_id: Optional[UUID4] = Field(**order_doc['delivery_id'])\n    status: Status = Field(default=Status.CREA, **order_doc['status'])\n    updated: Optional[List[StateUpdateSchema]] = Field(**order_doc['updated'])\n    created: datetime = Field(default_factory=datetime.utcnow, **order_doc['created'])", "\n\nclass OrderUpdateModel(MongoBase):\n    \"\"\" Representation of an Order in the system. \"\"\"\n    items: conlist(OrderItem, min_items=1)\n    customer_id: UUID4 = Field(**order_doc['customer_id'])\n    kitchen_id: Optional[UUID4] = Field(**order_doc['kitchen_id'])\n    delivery_id: Optional[UUID4] = Field(**order_doc['delivery_id'])\n    status: Status = Field(default=Status.CREA, **order_doc['status'])\n    updated: Optional[List[StateUpdateSchema]] = Field(**order_doc['updated'])\n    created: datetime = Field(default_factory=datetime.utcnow, **order_doc['created'])", "\n\nclass OrderModel(OrderUpdateModel):\n    \"\"\" Representation of an Order in the system. \"\"\"\n    id: UUID4 = Field(default_factory=uuid4)\n\n\n# ---------------------------------------------------------\n#\ndef dict_of(payload: OrderModel) -> dict:\n    \"\"\"  Return a dict representation of an OrderModel that json.dumps will accept.\n\n    All datatime and UUID objects are converted to str.\n\n    :param payload: Current Order object.\n    :return: Serializable dict representation of an Order.\n    \"\"\"\n\n    return {\n        key: (\n            # This row converts datetime values to str within a list of dicts.\n            list(map(lambda elem: {'status': elem['status'],\n                                   'when': str(elem['when'])}, value))\n            if key == 'updated'\n\n            # This row handles values that don't need a conversion.\n            else value if key in {'items', 'status'}\n\n            # This row converts all base (not in a structure) UUID and datetime values to str.\n            else str(value) if value else None)\n\n        # Iterate over all elements in the payload.\n        for key, value in payload.dict().items()}", "#\ndef dict_of(payload: OrderModel) -> dict:\n    \"\"\"  Return a dict representation of an OrderModel that json.dumps will accept.\n\n    All datatime and UUID objects are converted to str.\n\n    :param payload: Current Order object.\n    :return: Serializable dict representation of an Order.\n    \"\"\"\n\n    return {\n        key: (\n            # This row converts datetime values to str within a list of dicts.\n            list(map(lambda elem: {'status': elem['status'],\n                                   'when': str(elem['when'])}, value))\n            if key == 'updated'\n\n            # This row handles values that don't need a conversion.\n            else value if key in {'items', 'status'}\n\n            # This row converts all base (not in a structure) UUID and datetime values to str.\n            else str(value) if value else None)\n\n        # Iterate over all elements in the payload.\n        for key, value in payload.dict().items()}", ""]}
{"filename": "OrderService/src/repository/db.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-03-20 22:57:08\n     $Rev: 24", "    $Date: 2023-03-20 22:57:08\n     $Rev: 24\n\"\"\"\n\n# Third party modules\nfrom motor.motor_asyncio import AsyncIOMotorClient, AsyncIOMotorDatabase\n\n# Local program modules\nfrom ..config.setup import config\n", "from ..config.setup import config\n\n\n# ---------------------------------------------------------\n#\nclass Engine:\n    \"\"\" MongoDb database async engine class.\n\n\n    :type db: C{motor.motor_asyncio.AsyncIOMotorDatabase}\n    :ivar db: AsyncIOMotorDatabase class instance.\n    :type connection: C{motor.motor_asyncio.AsyncIOMotorClient}\n    :ivar connection: AsyncIOMotorClient class instance.\n    \"\"\"\n\n    db: AsyncIOMotorDatabase = None\n    connection: AsyncIOMotorClient = None\n\n    # ---------------------------------------------------------\n    #\n    @classmethod\n    async def connect_to_mongo(cls):\n        \"\"\" Initialize DB connection to MongoDb and database.\n\n        Setting server connection timeout to 5 (default is 30) seconds.\n        \"\"\"\n\n        cls.connection = AsyncIOMotorClient(config.mongo_url,\n                                            uuidRepresentation='standard',\n                                            serverSelectionTimeoutMS=5000)\n        cls.db = cls.connection.api_db\n\n    # ---------------------------------------------------------\n    #\n    @classmethod\n    async def close_mongo_connection(cls):\n        \"\"\" Close DB connection. \"\"\"\n\n        cls.connection.close()", ""]}
{"filename": "OrderService/src/repository/documentation.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-03-21 22:20:47\n     $Rev: 27", "    $Date: 2023-03-21 22:20:47\n     $Rev: 27\n\"\"\"\n\norder_documentation = {\n    \"status\": {'description': 'Order workflow status.'},\n    \"updated\": {'example': [{\"`2023-03-10T12:15:23.123234`\", \"paymentPaid\"}],\n                'default': [], 'description': 'Order status change history.'},\n    \"when\": {'example': \"`2023-03-10T12:15:23.123234`\",\n             'description': 'Timestamp for the Order status change.'},", "    \"when\": {'example': \"`2023-03-10T12:15:23.123234`\",\n             'description': 'Timestamp for the Order status change.'},\n    \"created\": {'example': \"`2023-03-10T12:15:23.123234`\",\n                'description': 'Timestamp when the Order was created.'},\n    \"id\": {'example': \"`dbb86c27-2eed-410d-881e-ad47487dd228`\",\n           'description': '**Order ID**: A unique identifier for an existing Order.'},\n    \"kitchen_id\": {'default': None, 'example': 'b76d019f-5937-4a14-8091-1d9f18666c93',\n                   'description': 'Kitchen ID for the Order meal being produced.'},\n    \"delivery_id\": {'default': None, 'example': 'f2861560-e9ed-4463-955f-0c55c3b416fb',\n                    'description': 'Delivery ID for the Order during delivered.'},", "    \"delivery_id\": {'default': None, 'example': 'f2861560-e9ed-4463-955f-0c55c3b416fb',\n                    'description': 'Delivery ID for the Order during delivered.'},\n    \"customer_id\": {'example': 'f2861560-e9ed-4463-955f-0c55c3b416fb',\n                    'description': 'Customer ID for the person that created the Order.'},\n}\n"]}
{"filename": "OrderService/src/repository/url_cache.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-03-24 23:18:27\n     $Rev: 38", "    $Date: 2023-03-24 23:18:27\n     $Rev: 38\n\"\"\"\n\n# Third party modules\nfrom aioredis import from_url\n\n# Local modules\nfrom .db import Engine\n", "from .db import Engine\n\n# Constants\nEXPIRE = 60*60*24\n\"\"\" Redis keys expire after 24h. \"\"\"\n\n\n# ------------------------------------------------------------------------\n#\nclass UrlCache:\n    \"\"\" This class handles Redis URL cache.\n\n    Is automatically populated from MongoDB api_db.service_urls collection.\n    \"\"\"\n\n    # ---------------------------------------------------------\n    #\n    def __init__(self, url: str):\n        \"\"\"  The class initializer.\n\n        :param url: Redis connection URL.\n        \"\"\"\n        self.client = from_url(url)\n\n    # ---------------------------------------------------------\n    #\n    async def get(self, key: str) -> str:\n        \"\"\" Get MicroService URL from Redis.\n\n        Populate from MongoDB api_db.service_urls collection if needed.\n        All URL Keys expire after 24h in the cache.\n\n        :param key: MicroService name.\n        :return: MicroService URL.\n        \"\"\"\n        value = await self.client.get(key)\n\n        if not value:\n            value = await Engine.db.service_urls.find_one({\"_id\": key})\n            await self.client.set(key, value['url'], ex=EXPIRE)\n\n        return value.decode() if isinstance(value, bytes) else value['url']", "#\nclass UrlCache:\n    \"\"\" This class handles Redis URL cache.\n\n    Is automatically populated from MongoDB api_db.service_urls collection.\n    \"\"\"\n\n    # ---------------------------------------------------------\n    #\n    def __init__(self, url: str):\n        \"\"\"  The class initializer.\n\n        :param url: Redis connection URL.\n        \"\"\"\n        self.client = from_url(url)\n\n    # ---------------------------------------------------------\n    #\n    async def get(self, key: str) -> str:\n        \"\"\" Get MicroService URL from Redis.\n\n        Populate from MongoDB api_db.service_urls collection if needed.\n        All URL Keys expire after 24h in the cache.\n\n        :param key: MicroService name.\n        :return: MicroService URL.\n        \"\"\"\n        value = await self.client.get(key)\n\n        if not value:\n            value = await Engine.db.service_urls.find_one({\"_id\": key})\n            await self.client.set(key, value['url'], ex=EXPIRE)\n\n        return value.decode() if isinstance(value, bytes) else value['url']", ""]}
{"filename": "OrderService/src/repository/order_data_adapter.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-03-24 23:18:27\n     $Rev: 38", "    $Date: 2023-03-24 23:18:27\n     $Rev: 38\n\"\"\"\n\n# BUILTIN modules\nfrom typing import List\n\n# Third party modules\nimport ujson\nfrom pydantic import UUID4", "import ujson\nfrom pydantic import UUID4\nfrom aioredis import from_url\nfrom pymongo import DESCENDING\nfrom pymongo.results import DeleteResult\n\n# Local modules\nfrom .db import Engine\nfrom ..config.setup import config\nfrom .models import OrderModel, OrderUpdateModel, dict_of", "from ..config.setup import config\nfrom .models import OrderModel, OrderUpdateModel, dict_of\n\n# Constants\nEXPIRE = 60*30\n\"\"\" Order objects expire after 30 minutes. \"\"\"\n\n\n# ------------------------------------------------------------------------\n#\nclass OrdersRepository:\n    \"\"\" This class implements the data layer adapter (the CRUD operations).\n\n    The Order object is cached in Redis. This is handled by the read, update\n    and delete methods.\n    \"\"\"\n    client = from_url(config.redis_url)\n\n    # ---------------------------------------------------------\n    #\n    @staticmethod\n    async def _read(key: UUID4) -> OrderModel:\n        \"\"\" Read Order for matching index key from DB collection api_db.orders.\n\n        :param key: Index key.\n        :return: Found Order.\n        \"\"\"\n\n        response = await Engine.db.orders.find_one({\"_id\": str(key)})\n\n        return OrderModel.from_mongo(response)\n\n    # ---------------------------------------------------------\n    #\n    @staticmethod\n    async def _update(payload: OrderModel) -> bool:\n        \"\"\" Update Order in DB collection api_db.orders.\n\n        :param payload: Updated Order payload.\n        :return: DB update result.\n        \"\"\"\n        base = OrderUpdateModel(**payload.dict()).to_mongo()\n        response = await Engine.db.orders.update_one({\"_id\": str(payload.id)},\n                                                     {\"$set\": {**base}})\n\n        return response.raw_result['updatedExisting']\n\n    # ---------------------------------------------------------\n    #\n    @staticmethod\n    async def connection_info() -> dict:\n        \"\"\" Return DB connection information.\n\n        :return: DB connection information.\n        \"\"\"\n        return await Engine.connection.server_info()\n\n    # ---------------------------------------------------------\n    #\n    @staticmethod\n    async def create(payload: OrderModel) -> bool:\n        \"\"\" Create Order in DB collection api_db.orders.\n\n        :param payload: New Order payload.\n        :return: DB create result.\n        \"\"\"\n        response = await Engine.db.orders.insert_one(payload.to_mongo())\n\n        return response.acknowledged\n\n    # ---------------------------------------------------------\n    #\n    @staticmethod\n    async def read_all() -> List[OrderModel]:\n        \"\"\" Read all existing Orders in DB collection api_db.orders.\n\n        Sorted on creation timestamp in descending order.\n\n        :return: List of found Orders.\n        \"\"\"\n        result = []\n\n        async for item in Engine.db.orders.find({}).sort('created', DESCENDING):\n            result.append(OrderModel.from_mongo(item))\n\n        return result\n\n    # ---------------------------------------------------------\n    #\n    async def read(self, key: UUID4) -> OrderModel:\n        \"\"\"\n        Read Order for matching index key from the cache. If it does not exist\n        there, read it from DB collection api_db.orders and update the cache.\n\n        :param key: Index key.\n        :return: Found Order.\n        \"\"\"\n        value = await self.client.get(str(key))\n\n        if not value:\n            payload = await self._read(key)\n            value = ujson.dumps(dict_of(payload))\n            await self.client.set(str(key), value, ex=EXPIRE)\n\n        return OrderModel(**ujson.loads(value))\n\n    # ---------------------------------------------------------\n    #\n    async def update(self, payload: OrderModel) -> bool:\n        \"\"\" Update Order in DB collection api_db.orders and in the cache.\n\n        :param payload: Updated Order payload.\n        :return: DB update result.\n        \"\"\"\n        response = await self._update(payload)\n\n        if response:\n            value = ujson.dumps(dict_of(payload))\n            await self.client.set(str(payload.id), value, ex=EXPIRE)\n\n        return response\n\n    # ---------------------------------------------------------\n    #\n    async def delete(self, key: UUID4) -> DeleteResult:\n        \"\"\"\n        Delete Order for matching index key from DB collection api_db.orders\n        and the cache.\n\n        :param key: Index key.\n\n        :return: DB delete result.\n        \"\"\"\n        response = await Engine.db.orders.delete_one({\"_id\": str(key)})\n\n        if response.deleted_count == 1:\n            await self.client.delete(str(key))\n\n        return response", "# ------------------------------------------------------------------------\n#\nclass OrdersRepository:\n    \"\"\" This class implements the data layer adapter (the CRUD operations).\n\n    The Order object is cached in Redis. This is handled by the read, update\n    and delete methods.\n    \"\"\"\n    client = from_url(config.redis_url)\n\n    # ---------------------------------------------------------\n    #\n    @staticmethod\n    async def _read(key: UUID4) -> OrderModel:\n        \"\"\" Read Order for matching index key from DB collection api_db.orders.\n\n        :param key: Index key.\n        :return: Found Order.\n        \"\"\"\n\n        response = await Engine.db.orders.find_one({\"_id\": str(key)})\n\n        return OrderModel.from_mongo(response)\n\n    # ---------------------------------------------------------\n    #\n    @staticmethod\n    async def _update(payload: OrderModel) -> bool:\n        \"\"\" Update Order in DB collection api_db.orders.\n\n        :param payload: Updated Order payload.\n        :return: DB update result.\n        \"\"\"\n        base = OrderUpdateModel(**payload.dict()).to_mongo()\n        response = await Engine.db.orders.update_one({\"_id\": str(payload.id)},\n                                                     {\"$set\": {**base}})\n\n        return response.raw_result['updatedExisting']\n\n    # ---------------------------------------------------------\n    #\n    @staticmethod\n    async def connection_info() -> dict:\n        \"\"\" Return DB connection information.\n\n        :return: DB connection information.\n        \"\"\"\n        return await Engine.connection.server_info()\n\n    # ---------------------------------------------------------\n    #\n    @staticmethod\n    async def create(payload: OrderModel) -> bool:\n        \"\"\" Create Order in DB collection api_db.orders.\n\n        :param payload: New Order payload.\n        :return: DB create result.\n        \"\"\"\n        response = await Engine.db.orders.insert_one(payload.to_mongo())\n\n        return response.acknowledged\n\n    # ---------------------------------------------------------\n    #\n    @staticmethod\n    async def read_all() -> List[OrderModel]:\n        \"\"\" Read all existing Orders in DB collection api_db.orders.\n\n        Sorted on creation timestamp in descending order.\n\n        :return: List of found Orders.\n        \"\"\"\n        result = []\n\n        async for item in Engine.db.orders.find({}).sort('created', DESCENDING):\n            result.append(OrderModel.from_mongo(item))\n\n        return result\n\n    # ---------------------------------------------------------\n    #\n    async def read(self, key: UUID4) -> OrderModel:\n        \"\"\"\n        Read Order for matching index key from the cache. If it does not exist\n        there, read it from DB collection api_db.orders and update the cache.\n\n        :param key: Index key.\n        :return: Found Order.\n        \"\"\"\n        value = await self.client.get(str(key))\n\n        if not value:\n            payload = await self._read(key)\n            value = ujson.dumps(dict_of(payload))\n            await self.client.set(str(key), value, ex=EXPIRE)\n\n        return OrderModel(**ujson.loads(value))\n\n    # ---------------------------------------------------------\n    #\n    async def update(self, payload: OrderModel) -> bool:\n        \"\"\" Update Order in DB collection api_db.orders and in the cache.\n\n        :param payload: Updated Order payload.\n        :return: DB update result.\n        \"\"\"\n        response = await self._update(payload)\n\n        if response:\n            value = ujson.dumps(dict_of(payload))\n            await self.client.set(str(payload.id), value, ex=EXPIRE)\n\n        return response\n\n    # ---------------------------------------------------------\n    #\n    async def delete(self, key: UUID4) -> DeleteResult:\n        \"\"\"\n        Delete Order for matching index key from DB collection api_db.orders\n        and the cache.\n\n        :param key: Index key.\n\n        :return: DB delete result.\n        \"\"\"\n        response = await Engine.db.orders.delete_one({\"_id\": str(key)})\n\n        if response.deleted_count == 1:\n            await self.client.delete(str(key))\n\n        return response", ""]}
{"filename": "OrderService/src/config/setup.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-04-01 21:09:57\n     $Rev: 56", "    $Date: 2023-04-01 21:09:57\n     $Rev: 56\n\"\"\"\n\n# BUILTIN modules\nimport site\n\n# Third party modules\nfrom dotenv import load_dotenv\nfrom pydantic import BaseSettings", "from dotenv import load_dotenv\nfrom pydantic import BaseSettings\n\n# Constants\nMISSING_SECRET = '>>> missing SECRETS file <<<'\n\"\"\" Error message for missing secrets file. \"\"\"\nMISSING_ENV = '>>> missing ENV value <<<'\n\"\"\" Error message for missing values in the .env file. \"\"\"\n\n", "\n\n# ---------------------------------------------------------\n#\nclass Configuration(BaseSettings):\n    \"\"\" Configuration parameters. \"\"\"\n\n    # OpenAPI documentation.\n    name: str = MISSING_ENV\n    version: str = MISSING_ENV\n\n    # Service parameters.\n    service_name: str = MISSING_ENV\n    service_log_level: str = MISSING_ENV\n\n    # External resource parameters.\n    url_timeout: tuple = (1.0, 5.0)\n    mongo_url: str = MISSING_SECRET\n    redis_url: str = MISSING_SECRET\n    rabbit_url: str = MISSING_SECRET\n\n    # Handles both local and Docker environments.\n    class Config:\n        secrets_dir = f'{site.USER_BASE}/secrets'", "\n\n# ---------------------------------------------------------\n\n# Note that the \".env\" file is always implicitly loaded.\nload_dotenv()\n\nconfig = Configuration()\n\"\"\" Configuration parameters instance. \"\"\"\n", "\"\"\" Configuration parameters instance. \"\"\"\n"]}
{"filename": "OrderService/src/web/main.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-03-30 17:38:58\n     $Rev: 49", "    $Date: 2023-03-30 17:38:58\n     $Rev: 49\n\"\"\"\n\n# BUILTIN modules\nimport asyncio\nfrom pathlib import Path\nfrom contextlib import asynccontextmanager\n\n# Third party modules", "\n# Third party modules\nfrom fastapi import FastAPI\nfrom fastapi.responses import JSONResponse\nfrom fastapi.staticfiles import StaticFiles\n\n# Local modules\nfrom .api import api\nfrom ..config.setup import config\nfrom ..repository.db import Engine", "from ..config.setup import config\nfrom ..repository.db import Engine\nfrom .health_manager import HealthManager\nfrom ..repository.url_cache import UrlCache\nfrom ..tools.custom_logging import create_unified_logger\nfrom ..business.response_handler import OrderResponseLogic\nfrom .api.documentation import (servers, license_info,\n                                tags_metadata, description)\nfrom ..repository.order_data_adapter import OrdersRepository\nfrom .api.schemas import HealthSchema, ValidStatus, HealthStatusError", "from ..repository.order_data_adapter import OrdersRepository\nfrom .api.schemas import HealthSchema, ValidStatus, HealthStatusError\nfrom ..tools.rabbit_client import AbstractRobustConnection, RabbitClient\n\n\n# ---------------------------------------------------------\n#\nclass Service(FastAPI):\n    connection: AbstractRobustConnection = None\n\n    def __init__(self, *args, **kwargs):\n        \"\"\" This class adds RabbitMQ message consumption and unified logging.\n\n        :param args: named arguments.\n        :param kwargs: key-value pair arguments.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n\n        self.rabbit_client = RabbitClient(config.rabbit_url,\n                                          config.service_name,\n                                          self.process_response_message)\n        self.level, self.logger = create_unified_logger(\n            config.service_log_level\n        )\n\n    # ---------------------------------------------------------\n    #\n    async def process_response_message(self, message: dict):\n        \"\"\" Send response message to a separate asyncio task for processing.\n\n        Note that the message is discarded when:\n          - required metadata structure is missing in the message.\n          - status is unknown.\n\n        :param message: MicroService response message.\n        \"\"\"\n\n        try:\n            if 'metadata' not in message:\n                raise RuntimeError('Message is discarded since it is '\n                                   'missing required metadata structure.')\n\n            # Verify that message status is valid.\n            ValidStatus(status=message.get('status'))\n\n            worker = OrderResponseLogic(repository=OrdersRepository(),\n                                        cache=UrlCache(config.redis_url))\n            await asyncio.create_task(worker.process_response(message))\n\n        except RuntimeError as why:\n            self.logger.error(f'{why}')\n\n        except ValueError as why:\n            raw = f'{why}'.split('\\n')\n            errmsg = ' '.join([item.split('(type=')[0].strip()\n                               for item in raw[1:]])\n            self.logger.error(f\"Message is discarded since {errmsg}.\")", "\n\n# ---------------------------------------------------------\n#\n@asynccontextmanager\nasync def lifespan(service: Service):\n    await startup(service)\n    yield\n    await shutdown(service)\n", "    await shutdown(service)\n\n\n# ---------------------------------------------------------\n\napp = Service(\n    servers=servers,\n    lifespan=lifespan,\n    title=config.name,\n    version=config.version,", "    title=config.name,\n    version=config.version,\n    description=description,\n    license_info=license_info,\n    openapi_tags=tags_metadata,\n)\napp.include_router(api.router)\n\n# Needed for OpenAPI Markdown images to be displayed.\nstatic_path = Path(__file__).parent.parent.parent.parent / 'design_docs'", "# Needed for OpenAPI Markdown images to be displayed.\nstatic_path = Path(__file__).parent.parent.parent.parent / 'design_docs'\napp.mount(\"/static\", StaticFiles(directory=static_path))\n\n\n# ---------------------------------------------------------\n#\n@app.get(\n    '/health',\n    response_model=HealthSchema,", "    '/health',\n    response_model=HealthSchema,\n    tags=[\"health check endpoint\"],\n    responses={500: {\"model\": HealthStatusError}},\n)\nasync def health_check() -> HealthSchema:\n    \"\"\" **Health check endpoint.** \"\"\"\n\n    content = await HealthManager(app.connection,\n                                  UrlCache(config.redis_url),", "    content = await HealthManager(app.connection,\n                                  UrlCache(config.redis_url),\n                                  OrdersRepository()).get_status()\n    response_code = (200 if content.status else 500)\n\n    return JSONResponse(status_code=response_code, content=content.dict())\n\n\n# ---------------------------------------------------------\n#", "# ---------------------------------------------------------\n#\nasync def startup(service: Service):\n    \"\"\" Initialize RabbitMQ and DB connection. \"\"\"\n\n    service.logger.info('Establishing RabbitMQ message queue consumer...')\n    service.connection = await asyncio.create_task(\n        service.rabbit_client.consume()\n    )\n", "    )\n\n    service.logger.info('Establishing MongoDB connection...')\n    await Engine.connect_to_mongo()\n\n\n# ---------------------------------------------------------\n#\nasync def shutdown(service: Service):\n    \"\"\" Close RabbitMQ and DB connection. \"\"\"", "async def shutdown(service: Service):\n    \"\"\" Close RabbitMQ and DB connection. \"\"\"\n\n    if service.connection:\n        service.logger.info('Disconnecting from RabbitMQ...')\n        await service.connection.close()\n\n    if Engine.connection:\n        service.logger.info('Disconnecting from MongoDB...')\n        await Engine.close_mongo_connection()", ""]}
{"filename": "OrderService/src/web/health_manager.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-03-23 19:52:08\n     $Rev: 36", "    $Date: 2023-03-23 19:52:08\n     $Rev: 36\n\"\"\"\n\n# BUILTIN modules\nfrom typing import List\n\n# Third party modules\nfrom loguru import logger\nfrom httpx import AsyncClient, ConnectTimeout", "from loguru import logger\nfrom httpx import AsyncClient, ConnectTimeout\n\n# local modules\nfrom ..config.setup import config\nfrom ..repository.url_cache import UrlCache\nfrom ..tools.rabbit_client import AbstractRobustConnection\nfrom ..web.api.schemas import ResourceSchema, HealthSchema\nfrom ..repository.order_data_adapter import OrdersRepository\n", "from ..repository.order_data_adapter import OrdersRepository\n\n# Constants\nURLS = {'PaymentService', 'KitchenService',\n        'DeliveryService', 'CustomerService'}\n\"\"\" Used internal MicroService(s). \"\"\"\n\n\n# -----------------------------------------------------------------------------\n#\nclass HealthManager:\n    \"\"\" This class handles health status reporting on used resources. \"\"\"\n\n    # ---------------------------------------------------------\n    #\n    def __init__(self, connection: AbstractRobustConnection,\n                 cache: UrlCache, repository: OrdersRepository):\n        \"\"\" Class initializer.\n\n        :param cache: Redis URL cache.\n        :param repository: Data layer handler object.\n        :param connection: RabbitMQ's connection object.\n        \"\"\"\n        self.cache = cache\n        self.repo = repository\n        self.connection = connection\n\n    # ---------------------------------------------------------\n    #\n    async def _get_mongo_status(self) -> List[ResourceSchema]:\n        \"\"\" Return MongoDb connection status.\n\n        :return: MongoDb connection status.\n        \"\"\"\n\n        try:\n            status = True\n            await self.repo.connection_info()\n\n        except BaseException as why:\n            logger.critical(f'MongoDB: {why}')\n            status = False\n\n        return [ResourceSchema(name='MongoDb', status=status)]\n\n    # ---------------------------------------------------------\n    #\n    async def _get_rabbit_status(self) -> List[ResourceSchema]:\n        \"\"\" Return RabbitMQ connection status.\n\n        :return: RabbitMQ connection status.\n        \"\"\"\n\n        try:\n            status = not self.connection.is_closed\n\n        except BaseException as why:\n            logger.critical(f'RabbitMQ: {why}')\n            status = False\n\n        return [ResourceSchema(name='RabbitMQ', status=status)]\n\n    # ---------------------------------------------------------\n    #\n    async def _get_service_status(self) -> List[ResourceSchema]:\n        \"\"\" Return RabbitMQ connection status.\n\n        :return: Service connection status.\n        \"\"\"\n        result = []\n\n        async with AsyncClient() as client:\n            for service in URLS:\n                try:\n                    root = await self.cache.get(service)\n                    url = f'{root}/health'\n                    status = False\n\n                    # Request used Microservice health status.\n                    response = await client.get(url=url, timeout=(1.0, 5.0))\n\n                    if response.status_code == 200:\n                        status = response.json()['status']\n\n                except ConnectTimeout:\n                    logger.critical(f'No connection with {service} on URL {url}')\n\n                result.append(ResourceSchema(name=service, status=status))\n\n        return result\n\n    # ---------------------------------------------------------\n    #\n    async def get_status(self) -> HealthSchema:\n        \"\"\" Return Health status for used resources.\n\n        :return: Service health status.\n        \"\"\"\n        resource_items = []\n        resource_items += await self._get_mongo_status()\n        resource_items += await self._get_rabbit_status()\n        resource_items += await self._get_service_status()\n        total_status = all(key.status for key in resource_items)\n\n        return HealthSchema(status=total_status,\n                            version=config.version,\n                            name=config.service_name,\n                            resources=resource_items)", "# -----------------------------------------------------------------------------\n#\nclass HealthManager:\n    \"\"\" This class handles health status reporting on used resources. \"\"\"\n\n    # ---------------------------------------------------------\n    #\n    def __init__(self, connection: AbstractRobustConnection,\n                 cache: UrlCache, repository: OrdersRepository):\n        \"\"\" Class initializer.\n\n        :param cache: Redis URL cache.\n        :param repository: Data layer handler object.\n        :param connection: RabbitMQ's connection object.\n        \"\"\"\n        self.cache = cache\n        self.repo = repository\n        self.connection = connection\n\n    # ---------------------------------------------------------\n    #\n    async def _get_mongo_status(self) -> List[ResourceSchema]:\n        \"\"\" Return MongoDb connection status.\n\n        :return: MongoDb connection status.\n        \"\"\"\n\n        try:\n            status = True\n            await self.repo.connection_info()\n\n        except BaseException as why:\n            logger.critical(f'MongoDB: {why}')\n            status = False\n\n        return [ResourceSchema(name='MongoDb', status=status)]\n\n    # ---------------------------------------------------------\n    #\n    async def _get_rabbit_status(self) -> List[ResourceSchema]:\n        \"\"\" Return RabbitMQ connection status.\n\n        :return: RabbitMQ connection status.\n        \"\"\"\n\n        try:\n            status = not self.connection.is_closed\n\n        except BaseException as why:\n            logger.critical(f'RabbitMQ: {why}')\n            status = False\n\n        return [ResourceSchema(name='RabbitMQ', status=status)]\n\n    # ---------------------------------------------------------\n    #\n    async def _get_service_status(self) -> List[ResourceSchema]:\n        \"\"\" Return RabbitMQ connection status.\n\n        :return: Service connection status.\n        \"\"\"\n        result = []\n\n        async with AsyncClient() as client:\n            for service in URLS:\n                try:\n                    root = await self.cache.get(service)\n                    url = f'{root}/health'\n                    status = False\n\n                    # Request used Microservice health status.\n                    response = await client.get(url=url, timeout=(1.0, 5.0))\n\n                    if response.status_code == 200:\n                        status = response.json()['status']\n\n                except ConnectTimeout:\n                    logger.critical(f'No connection with {service} on URL {url}')\n\n                result.append(ResourceSchema(name=service, status=status))\n\n        return result\n\n    # ---------------------------------------------------------\n    #\n    async def get_status(self) -> HealthSchema:\n        \"\"\" Return Health status for used resources.\n\n        :return: Service health status.\n        \"\"\"\n        resource_items = []\n        resource_items += await self._get_mongo_status()\n        resource_items += await self._get_rabbit_status()\n        resource_items += await self._get_service_status()\n        total_status = all(key.status for key in resource_items)\n\n        return HealthSchema(status=total_status,\n                            version=config.version,\n                            name=config.service_name,\n                            resources=resource_items)", ""]}
{"filename": "OrderService/src/web/api/schemas.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-04-01 17:51:19\n     $Rev: 55", "    $Date: 2023-04-01 17:51:19\n     $Rev: 55\n\"\"\"\n\n# BUILTIN modules\nfrom datetime import datetime\nfrom typing import Optional, List\n\n# Third party modules\nfrom pydantic import (BaseModel, Field, UUID4)", "# Third party modules\nfrom pydantic import (BaseModel, Field, UUID4)\n\n# Local modules\nfrom ..api.documentation import resource_example\nfrom ...repository.models import Status, OrderItems\nfrom ...repository.documentation import order_documentation as order_doc\n\n\n# -----------------------------------------------------------------------------", "\n# -----------------------------------------------------------------------------\n#\nclass NotFoundError(BaseModel):\n    \"\"\" Define model for a http 404 exception (Not Found). \"\"\"\n    detail: str = \"Order not found in DB\"\n\n\nclass FailedUpdateError(BaseModel):\n    \"\"\" Define model for a http 400 exception (Unprocessable Entity). \"\"\"\n    detail: str = \"Failed updating Order in DB\"", "class FailedUpdateError(BaseModel):\n    \"\"\" Define model for a http 400 exception (Unprocessable Entity). \"\"\"\n    detail: str = \"Failed updating Order in DB\"\n\n\nclass ConnectError(BaseModel):\n    \"\"\" Define model for a http 500 exception (INTERNAL_SERVER_ERROR). \"\"\"\n    detail: str = \"Failed to connect to internal MicroService\"\n\n\nclass HealthStatusError(BaseModel):\n    \"\"\" Define model for a http 500 exception (INTERNAL_SERVER_ERROR). \"\"\"\n    detail: str = \"HEALTH: resource connection(s) are down\"", "\n\nclass HealthStatusError(BaseModel):\n    \"\"\" Define model for a http 500 exception (INTERNAL_SERVER_ERROR). \"\"\"\n    detail: str = \"HEALTH: resource connection(s) are down\"\n\n\n# ---------------------------------------------------------\n#\nclass OrderPayload(OrderItems):\n    \"\"\" Payload parameters required when creating an order. \"\"\"\n    customer_id: UUID4 = Field(**order_doc['customer_id'])", "#\nclass OrderPayload(OrderItems):\n    \"\"\" Payload parameters required when creating an order. \"\"\"\n    customer_id: UUID4 = Field(**order_doc['customer_id'])\n\n\n# ---------------------------------------------------------\n#\nclass OrderResponse(OrderItems):\n    \"\"\" Expected default order response parameters. \"\"\"\n    id: UUID4 = Field(**order_doc['id'])\n    status: Status = Field(**order_doc['status'])\n    created: datetime = Field(**order_doc['created'])\n    customer_id: UUID4 = Field(**order_doc['customer_id'])\n    kitchen_id: Optional[UUID4] = Field(**order_doc['kitchen_id'])\n    delivery_id: Optional[UUID4] = Field(**order_doc['delivery_id'])", "class OrderResponse(OrderItems):\n    \"\"\" Expected default order response parameters. \"\"\"\n    id: UUID4 = Field(**order_doc['id'])\n    status: Status = Field(**order_doc['status'])\n    created: datetime = Field(**order_doc['created'])\n    customer_id: UUID4 = Field(**order_doc['customer_id'])\n    kitchen_id: Optional[UUID4] = Field(**order_doc['kitchen_id'])\n    delivery_id: Optional[UUID4] = Field(**order_doc['delivery_id'])\n\n", "\n\n# ------------------------------------------------------------------------\n#\nclass ValidStatus(BaseModel):\n    \"\"\" Used for validation of received status responses. \"\"\"\n    status: Status\n\n\n# -----------------------------------------------------------------------------", "\n# -----------------------------------------------------------------------------\n#\nclass ResourceSchema(BaseModel):\n    \"\"\" Representation of a  health resources response.\n\n    :ivar name: Resource name.\n    :ivar status: Resource status\n    \"\"\"\n\n    name: str\n    status: bool", "\n\n# -----------------------------------------------------------------------------\n#\nclass HealthSchema(BaseModel):\n    \"\"\" Representation of a  health response.\n\n    :ivar name: Service name.\n    :ivar status: Overall health status\n    :ivar version: Service version.\n    :ivar resources: Status for individual resources..\n    \"\"\"\n\n    status: bool\n    version: str\n    name: str\n    resources: List[ResourceSchema]\n\n    class Config:\n        schema_extra = {\"example\": resource_example}", ""]}
{"filename": "OrderService/src/web/api/api.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-03-30 12:13:57\n     $Rev: 47", "    $Date: 2023-03-30 12:13:57\n     $Rev: 47\n\"\"\"\n\n# BUILTIN modules\nfrom typing import List\n\n# Third party modules\nfrom pydantic import UUID4\nfrom fastapi.responses import Response", "from pydantic import UUID4\nfrom fastapi.responses import Response\nfrom fastapi import APIRouter, status\n\n# Local modules\nfrom .order_api_adapter import OrdersApi\nfrom .documentation import order_id_documentation\nfrom ...repository.order_data_adapter import OrdersRepository\nfrom .schemas import (OrderPayload, OrderResponse,\n                      NotFoundError, FailedUpdateError, ConnectError)", "from .schemas import (OrderPayload, OrderResponse,\n                      NotFoundError, FailedUpdateError, ConnectError)\n\n# Constants\nrouter = APIRouter(prefix=f\"/v1/orders\", tags=[f\"Orders\"])\n\"\"\" Order API endpoint router. \"\"\"\n\n\n# ---------------------------------------------------------\n#", "# ---------------------------------------------------------\n#\n@router.post(\n    '',\n    response_model=OrderResponse,\n    status_code=status.HTTP_202_ACCEPTED,\n    responses={\n        500: {'model': ConnectError},\n        400: {\"model\": FailedUpdateError}}\n)", "        400: {\"model\": FailedUpdateError}}\n)\nasync def create_order(payload: OrderPayload) -> OrderResponse:\n    \"\"\" **Create a new Order in the DB and trigger a payment.** \"\"\"\n    service = OrdersApi(OrdersRepository())\n    return await service.create_order(payload)\n\n\n# ---------------------------------------------------------\n#", "# ---------------------------------------------------------\n#\n@router.post(\n    \"/{order_id}/cancel\",\n    response_model=OrderResponse,\n    status_code=status.HTTP_202_ACCEPTED,\n    responses={\n        500: {'model': ConnectError},\n        404: {\"model\": NotFoundError},\n        400: {\"model\": FailedUpdateError}}", "        404: {\"model\": NotFoundError},\n        400: {\"model\": FailedUpdateError}}\n)\nasync def cancel_order(order_id: UUID4 = order_id_documentation) -> OrderResponse:\n    \"\"\"\n    **Cancel Order for matching order_id in the DB and trigger a reimbursement.**\n    \"\"\"\n    service = OrdersApi(OrdersRepository())\n    return await service.cancel_order(order_id)\n", "    return await service.cancel_order(order_id)\n\n\n# ---------------------------------------------------------\n#\n@router.get(\n    \"\",\n    response_model=List[OrderResponse]\n)\nasync def get_all_orders() -> List[OrderResponse]:", ")\nasync def get_all_orders() -> List[OrderResponse]:\n    \"\"\" **Read all Orders from the DB sorted on created timestamp.** \"\"\"\n    service = OrdersApi(OrdersRepository())\n    return await service.list_orders()\n\n\n# ---------------------------------------------------------\n#\n@router.get(", "#\n@router.get(\n    \"/{order_id}\",\n    response_model=OrderResponse,\n    responses={404: {\"model\": NotFoundError}},\n)\nasync def get_order(order_id: UUID4 = order_id_documentation) -> OrderResponse:\n    \"\"\" **Read Order for matching order_id from the DB.** \"\"\"\n    service = OrdersApi(OrdersRepository())\n    return await service.get_order(order_id)", "    service = OrdersApi(OrdersRepository())\n    return await service.get_order(order_id)\n\n\n# ---------------------------------------------------------\n#\n@router.delete(\n    \"/{order_id}\",\n    status_code=status.HTTP_204_NO_CONTENT,\n    responses={404: {\"model\": NotFoundError}},", "    status_code=status.HTTP_204_NO_CONTENT,\n    responses={404: {\"model\": NotFoundError}},\n    response_description='Order was successfully deleted in the DB.'\n)\nasync def delete_order(order_id: UUID4 = order_id_documentation) -> Response:\n    \"\"\" **Delete Order for matching order_id from the DB.** \"\"\"\n    service = OrdersApi(OrdersRepository())\n    await service.delete_order(order_id)\n    return Response(status_code=status.HTTP_204_NO_CONTENT)\n", "    return Response(status_code=status.HTTP_204_NO_CONTENT)\n"]}
{"filename": "OrderService/src/web/api/documentation.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-04-02 14:01:36\n     $Rev: 57", "    $Date: 2023-04-02 14:01:36\n     $Rev: 57\n\"\"\"\n\nfrom fastapi import Path\n\n# Local modules\nfrom ...config.setup import config\n\n", "\n\norder_id_documentation = Path(\n    ...,\n    description='**Order ID**: *Example `dbb86c27-2eed-410d-881e-ad47487dd228`*. '\n                'A unique identifier for an existing Order.',\n)\n\nresource_example = {\n    \"status\": True,", "resource_example = {\n    \"status\": True,\n    \"version\": f\"{config.version}\",\n    \"name\": f\"{config.service_name}\",\n    \"resources\": [\n        {\n            \"name\": \"MongoDb\",\n            \"status\": True\n        },\n        {", "        },\n        {\n            \"name\": \"RabbitMq\",\n            \"status\": True\n        },\n        {\n            \"name\": \"PaymentService\",\n            \"status\": True\n        },\n        {", "        },\n        {\n            \"name\": \"KitchenService\",\n            \"status\": True\n        },\n        {\n            \"name\": \"DeliveryService\",\n            \"status\": True\n        },\n        {", "        },\n        {\n            \"name\": \"CustomerService\",\n            \"status\": True\n        },\n    ]\n}\n\ntags_metadata = [\n    {", "tags_metadata = [\n    {\n        \"name\": \"Orders\",\n        \"description\": f\"The ***{config.service_name}*** handle Orders for the Fictitious Company.\",\n    }\n]\n\nlicense_info = {\n    \"name\": \"License: Apache 2.0\",\n    \"url\": \"https://www.apache.org/licenses/LICENSE-2.0.html\",", "    \"name\": \"License: Apache 2.0\",\n    \"url\": \"https://www.apache.org/licenses/LICENSE-2.0.html\",\n}\n\nservers = [\n    {\n        \"url\": \"http://127.0.0.1:8000\",\n        \"description\": \"URL for local development and testing\"\n    },\n    {", "    },\n    {\n        \"url\": \"https://coffeemesh-staging.com\",\n        \"description\": \"staging server for testing purposes only\"\n    },\n    {\n        \"url\": \"https://coffeemesh.com\",\n        \"description\": \"main production server\"\n    },\n]", "    },\n]\n\ndescription = \"\"\"\n<img width=\"65%\" align=\"right\" src=\"/static/order_container_diagram.png\"/>\n**An example on how to use FastAPI and RabbitMQ asynchronously to create a RESTful API for responses that \ntakes a bit more time to process.** \n\nThis service implements a Facade pattern to simplify the complexity between the MicroServices in the system \nand the WEB GUI program (it only has to work against one API).", "This service implements a Facade pattern to simplify the complexity between the MicroServices in the system \nand the WEB GUI program (it only has to work against one API).\n\nThe OrderService handles multiple status updates from several services during the lifecycle of an Order. These \nresponses are asynchronous events spread out over time and to be able to handle this type of dynamic the RabbitMQ \nmessage broker is used. The RabbitMQ queue routing technique is used since it is designed to scale with the growing \nneeds of the service.\n\nThe key to this design is that a metadata structure is part of every message that is sent between the services in \nthe system. This `MetaDataSchema` structure is described in the Schemas section for the ", "The key to this design is that a metadata structure is part of every message that is sent between the services in \nthe system. This `MetaDataSchema` structure is described in the Schemas section for the \n[PaymentService](http://127.0.0.1:8001/docs). \n\n<br>**The following HTTP status codes are returned:**\n  * `200:` Successful GET response.\n  * `202:` Successful POST response.\n  * `204:` Successful DELETE response.\n  * `400:` Failed updating Order in DB.\n  * `404:` Order not found in DB.", "  * `400:` Failed updating Order in DB.\n  * `404:` Order not found in DB.\n  * `422:` Validation error, supplied parameter(s) are incorrect.\n  * `500:` Failed to connect to internal MicroService.\n  * `500:` Failed Health response.\n<br><br>\n---\n\"\"\"\n", ""]}
{"filename": "OrderService/src/web/api/order_api_adapter.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-03-30 13:14:04\n     $Rev: 48", "    $Date: 2023-03-30 13:14:04\n     $Rev: 48\n\"\"\"\n\n# BUILTIN modules\nfrom typing import List\n\n# Third party modules\nfrom pydantic import UUID4\nfrom fastapi import HTTPException", "from pydantic import UUID4\nfrom fastapi import HTTPException\n\n# Local modules\nfrom ...repository.models import OrderModel\nfrom .schemas import OrderResponse, OrderPayload\nfrom ...business.request_handler import OrderApiLogic\nfrom ...repository.order_data_adapter import OrdersRepository\n\n", "\n\n# ------------------------------------------------------------------------\n#\nclass OrdersApi:\n    \"\"\"\n    This class implements the web API layer adapter.\n    \"\"\"\n\n    # ---------------------------------------------------------\n    #\n    def __init__(self, repository: OrdersRepository):\n        \"\"\" The class initializer.\n\n        :param repository: Data layer handler object.\n        \"\"\"\n        self.repo = repository\n\n    # ---------------------------------------------------------\n    #\n    async def _order_of(self, order_id: UUID4) -> OrderModel:\n        \"\"\" Return specified order.\n\n        :param order_id: Order id for order to find.\n        :return: Found Order object.\n        :raise HTTPException [404]: when Order not found in DB api_db.orders.\n        \"\"\"\n        db_order = await self.repo.read(order_id)\n\n        if not db_order:\n            errmsg = f\"{order_id=} not found in DB api_db.orders\"\n            raise HTTPException(status_code=404, detail=errmsg)\n\n        return db_order\n\n    # ---------------------------------------------------------\n    #\n    async def list_orders(self) -> List[OrderResponse]:\n        \"\"\" List all existing orders in DB api_db.orders.\n\n        Sorted on creation timestamp in descending order.\n\n        :return: List of found orders.\n        \"\"\"\n        return await self.repo.read_all()\n\n    # ---------------------------------------------------------\n    #\n    async def get_order(self, order_id: UUID4) -> OrderResponse:\n        \"\"\" Return specified order.\n\n        :param order_id: Order id for order to find.\n        :return: Found Order object.\n        :raise HTTPException [404]: when Order not found in DB api_db.orders.\n        \"\"\"\n        db_order = await self._order_of(order_id)\n        return OrderResponse(**db_order.dict())\n\n    # ---------------------------------------------------------\n    #\n    async def create_order(self, payload: OrderPayload) -> OrderResponse:\n        \"\"\" Create a new order in DB and make a payment request.\n\n        :param payload: Incoming Order request.\n        :return: Created Order object.\n        :raise HTTPException [400]: when PaymentService response code != 202.\n        :raise HTTPException [500]: when connection with PaymentService failed.\n        :raise HTTPException [400]: when create order in DB api_db.orders failed.\n        \"\"\"\n        db_order = OrderModel(**payload.dict())\n        order = OrderApiLogic(repository=self.repo, **db_order.dict())\n        return await order.create()\n\n    # ---------------------------------------------------------\n    #\n    async def cancel_order(self, order_id: UUID4) -> OrderResponse:\n        \"\"\" Cancel specified order.\n\n        :param order_id: id for order to cancel.\n        :return: Found Order object.\n        :raise HTTPException [400]: when failed to update DB api_db.orders.\n        :raise HTTPException [404]: when Order not found in DB api_db.orders.\n        \"\"\"\n        db_order = await self._order_of(order_id)\n        order = OrderApiLogic(repository=self.repo, **db_order.dict())\n        return await order.cancel()\n\n    # ---------------------------------------------------------\n    #\n    async def delete_order(self, order_id: UUID4) -> None:\n        \"\"\" Delete specified order.\n\n        :param order_id: id for order to delete.\n        :raise HTTPException [404]: when Order not found in DB api_db.orders.\n        \"\"\"\n        db_order = await self._order_of(order_id)\n        order = OrderApiLogic(repository=self.repo, **db_order.dict())\n        await order.delete()", ""]}
{"filename": "PaymentService/run.py", "chunked_list": ["#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-03-20 22:57:08", "  $Author: Anders Wiklund\n    $Date: 2023-03-20 22:57:08\n     $Rev: 24\n\"\"\"\n\n# Third party modules\nimport uvicorn\n\n# Local modules\nfrom src.web.main import app", "# Local modules\nfrom src.web.main import app\n\n\nif __name__ == \"__main__\":\n\n    uv_config = {'app': 'src.web.main:app', 'port': 8001,\n                 'log_level': app.level, 'reload': True,\n                 'log_config': {\"disable_existing_loggers\": False, \"version\": 1}}\n\n    uvicorn.run(**uv_config)", ""]}
{"filename": "PaymentService/__init__.py", "chunked_list": [""]}
{"filename": "PaymentService/src/__init__.py", "chunked_list": [""]}
{"filename": "PaymentService/src/tools/rabbit_client.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-03-30 17:41:49\n     $Rev: 50", "    $Date: 2023-03-30 17:41:49\n     $Rev: 50\n\"\"\"\n\n# BUILTIN modules\nimport asyncio\nfrom typing import Callable, Optional\n\n# Third party modules\nimport ujson as json", "# Third party modules\nimport ujson as json\nfrom aio_pika import connect, connect_robust, Message, DeliveryMode\nfrom aio_pika.abc import AbstractIncomingMessage, AbstractRobustConnection\n\n\n# -----------------------------------------------------------------------------\n#\nclass RabbitClient:\n    \"\"\" This class handles the communication with the RabbitMQ server.\n\n    Note: the queue mechanism is implemented to take advantage of good\n    horizontal message scaling when needed.\n\n    Both Publisher and Consumer async handling is implemented.\n    \"\"\"\n    rabbit_url: str = None\n\n    # ---------------------------------------------------------\n    #\n    def __init__(self, rabbit_url: str, service: Optional[str] = None,\n                 incoming_message_handler: Optional[Callable] = None):\n        \"\"\" The class initializer.\n\n        :param rabbit_url: RabbitMQ's connection string.\n        :param service: Name of receiving service (when using consume).\n        :param incoming_message_handler: Incoming message callback method.\n        \"\"\"\n\n        # Unique parameters.\n        self.rabbit_url = rabbit_url\n        self.service_name = service\n        self.message_handler = incoming_message_handler\n\n    # ---------------------------------------------------------\n    #\n    async def _process_incoming_message(self, message: AbstractIncomingMessage):\n        \"\"\" Processing incoming message from RabbitMQ.\n\n        :param message: Received message.\n        \"\"\"\n        if body := message.body:\n            await self.message_handler(json.loads(body))\n\n        await message.ack()\n\n    # ---------------------------------------------------------\n    #\n    async def consume(self) -> AbstractRobustConnection:\n        \"\"\" Setup message listener with the current running asyncio loop. \"\"\"\n        loop = asyncio.get_running_loop()\n\n        # Perform receive connection.\n        connection = await connect_robust(loop=loop, url=self.rabbit_url)\n\n        # Creating receive channel and setting quality of service.\n        channel = await connection.channel()\n\n        # To make sure the load is evenly distributed between the workers.\n        await channel.set_qos(1)\n\n        # Creating a receive queue.\n        queue = await channel.declare_queue(name=self.service_name, durable=True)\n\n        # Start consumption of existing and future messages.\n        await queue.consume(self._process_incoming_message, no_ack=False)\n\n        return connection\n\n    # ---------------------------------------------------------\n    #\n    @classmethod\n    async def send_message(cls, message: dict, queue: str):\n        \"\"\" Send message to RabbitMQ Publisher queue.\n\n        If the topic is defined, topic message routing is used, otherwise\n        queue message routing is used.\n\n        :param message: Message to be sent.\n        :param queue: Message queue to use for message sending.\n        :raise AssertionError: Parameters 'topic' and 'queue' are mutually exclusive.\n        \"\"\"\n        connection = await connect(url=cls.rabbit_url)\n        channel = await connection.channel()\n\n        message_body = Message(\n            content_type='application/json',\n            body=json.dumps(message, ensure_ascii=False).encode(),\n            delivery_mode=DeliveryMode.PERSISTENT)\n        await channel.default_exchange.publish(\n            routing_key=queue, message=message_body)", "class RabbitClient:\n    \"\"\" This class handles the communication with the RabbitMQ server.\n\n    Note: the queue mechanism is implemented to take advantage of good\n    horizontal message scaling when needed.\n\n    Both Publisher and Consumer async handling is implemented.\n    \"\"\"\n    rabbit_url: str = None\n\n    # ---------------------------------------------------------\n    #\n    def __init__(self, rabbit_url: str, service: Optional[str] = None,\n                 incoming_message_handler: Optional[Callable] = None):\n        \"\"\" The class initializer.\n\n        :param rabbit_url: RabbitMQ's connection string.\n        :param service: Name of receiving service (when using consume).\n        :param incoming_message_handler: Incoming message callback method.\n        \"\"\"\n\n        # Unique parameters.\n        self.rabbit_url = rabbit_url\n        self.service_name = service\n        self.message_handler = incoming_message_handler\n\n    # ---------------------------------------------------------\n    #\n    async def _process_incoming_message(self, message: AbstractIncomingMessage):\n        \"\"\" Processing incoming message from RabbitMQ.\n\n        :param message: Received message.\n        \"\"\"\n        if body := message.body:\n            await self.message_handler(json.loads(body))\n\n        await message.ack()\n\n    # ---------------------------------------------------------\n    #\n    async def consume(self) -> AbstractRobustConnection:\n        \"\"\" Setup message listener with the current running asyncio loop. \"\"\"\n        loop = asyncio.get_running_loop()\n\n        # Perform receive connection.\n        connection = await connect_robust(loop=loop, url=self.rabbit_url)\n\n        # Creating receive channel and setting quality of service.\n        channel = await connection.channel()\n\n        # To make sure the load is evenly distributed between the workers.\n        await channel.set_qos(1)\n\n        # Creating a receive queue.\n        queue = await channel.declare_queue(name=self.service_name, durable=True)\n\n        # Start consumption of existing and future messages.\n        await queue.consume(self._process_incoming_message, no_ack=False)\n\n        return connection\n\n    # ---------------------------------------------------------\n    #\n    @classmethod\n    async def send_message(cls, message: dict, queue: str):\n        \"\"\" Send message to RabbitMQ Publisher queue.\n\n        If the topic is defined, topic message routing is used, otherwise\n        queue message routing is used.\n\n        :param message: Message to be sent.\n        :param queue: Message queue to use for message sending.\n        :raise AssertionError: Parameters 'topic' and 'queue' are mutually exclusive.\n        \"\"\"\n        connection = await connect(url=cls.rabbit_url)\n        channel = await connection.channel()\n\n        message_body = Message(\n            content_type='application/json',\n            body=json.dumps(message, ensure_ascii=False).encode(),\n            delivery_mode=DeliveryMode.PERSISTENT)\n        await channel.default_exchange.publish(\n            routing_key=queue, message=message_body)", ""]}
{"filename": "PaymentService/src/tools/custom_logging.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-03-25 17:47:36\n     $Rev: 42", "    $Date: 2023-03-25 17:47:36\n     $Rev: 42\n\"\"\"\n\n# BUILTIN modules\nimport sys\nimport logging\nfrom typing import cast\nfrom types import FrameType\n", "from types import FrameType\n\n# Third party modules\nfrom loguru import logger\n\n\n# ---------------------------------------------------------\n#\nclass InterceptHandler(logging.Handler):\n    \"\"\" Logs to loguru from Python logging module. \"\"\"\n\n    def emit(self, record: logging.LogRecord):\n        try:\n            level = logger.level(record.levelname).name\n\n        except ValueError:\n            level = str(record.levelno)\n\n        frame, depth = logging.currentframe(), 2\n\n        while frame.f_code.co_filename == logging.__file__:\n            frame = cast(FrameType, frame.f_back)\n            depth += 1\n\n        logger.opt(\n            depth=depth,\n            exception=record.exc_info).log(\n            level,\n            record.getMessage()\n        )", "class InterceptHandler(logging.Handler):\n    \"\"\" Logs to loguru from Python logging module. \"\"\"\n\n    def emit(self, record: logging.LogRecord):\n        try:\n            level = logger.level(record.levelname).name\n\n        except ValueError:\n            level = str(record.levelno)\n\n        frame, depth = logging.currentframe(), 2\n\n        while frame.f_code.co_filename == logging.__file__:\n            frame = cast(FrameType, frame.f_back)\n            depth += 1\n\n        logger.opt(\n            depth=depth,\n            exception=record.exc_info).log(\n            level,\n            record.getMessage()\n        )", "\n\n# ---------------------------------------------------------\n#\ndef create_unified_logger(log_level: str) -> tuple:\n    \"\"\" Return unified Loguru logger object.\n\n    :return: unified Loguru logger object.\n    \"\"\"\n\n    level = log_level\n\n    # Remove all existing loggers.\n    logger.remove()\n\n    # Create a basic Loguru logging config.\n    logger.add(\n        diagnose=True,\n        backtrace=True,\n        sink=sys.stderr,\n        level=level.upper(),\n    )\n\n    # Prepare to incorporate python standard logging.\n    seen = set()\n    logging.basicConfig(handlers=[InterceptHandler()], level=0)\n\n    for logger_name in logging.root.manager.loggerDict.keys():\n\n        if logger_name not in seen:\n            seen.add(logger_name.split(\".\")[0])\n            mod_logger = logging.getLogger(logger_name)\n            mod_logger.handlers = [InterceptHandler(level=level.upper())]\n            mod_logger.propagate = False\n\n    return level, logger.bind(request_id=None, method=None)", ""]}
{"filename": "PaymentService/src/business/schemas.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-03-21 22:20:47\n     $Rev: 27", "    $Date: 2023-03-21 22:20:47\n     $Rev: 27\n\"\"\"\n\n# Third party modules\nfrom pydantic import BaseModel, Field\n\n# Local modules\nfrom ..repository.models import Status\nfrom ..web.api.schemas import MetadataSchema", "from ..repository.models import Status\nfrom ..web.api.schemas import MetadataSchema\n\n\n# ---------------------------------------------------------\n#\nclass PaymentResponse(BaseModel):\n    \"\"\" Representation of a Payment Response in the system. \"\"\"\n    metadata: MetadataSchema\n    status: Status = Field(send_example=Status.PAID)", ""]}
{"filename": "PaymentService/src/business/payment_handler.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-04-01 17:51:19\n     $Rev: 55", "    $Date: 2023-04-01 17:51:19\n     $Rev: 55\n\"\"\"\n\n\n# BUILTIN modules\nimport contextlib\nfrom uuid import UUID, uuid4\n\n# Third party modules", "\n# Third party modules\nfrom loguru import logger\nfrom fastapi import HTTPException\nfrom httpx import AsyncClient, ConnectError, ConnectTimeout\n\n# Local modules\nfrom ..config.setup import config\nfrom .schemas import PaymentResponse\nfrom ..repository.url_cache import UrlCache", "from .schemas import PaymentResponse\nfrom ..repository.url_cache import UrlCache\nfrom ..repository.models import PaymentModel\nfrom ..tools.rabbit_client import RabbitClient\nfrom ..repository.payment_data_adapter import PaymentsRepository\nfrom ..web.api.schemas import BillingCallback, BillingPayload, PaymentPayload\n\n\n# -----------------------------------------------------------------------------\n#\nclass PaymentLogic:\n    \"\"\"\n    This class implements the PaymentService business logic layer.\n    \"\"\"\n\n    # ---------------------------------------------------------\n    #\n    def __init__(self, repository: PaymentsRepository,\n                 cache: UrlCache, client: RabbitClient):\n        \"\"\" The class initializer.\n\n        :param repository: Data layer handler object.\n        :param cache: Redis URL cache.\n        :param client: RabbitMQ client.\n        \"\"\"\n        self.cache = cache\n        self.client = client\n        self.repo = repository\n\n    # ---------------------------------------------------------\n    #\n    @staticmethod\n    async def _charge_credit_card(payload: BillingPayload) -> UUID:\n        \"\"\" Simulate doing the Credit Card billing.\n\n        :param payload: Data needed for Billing.\n        :return: Credit Card Company transaction ID.\n        :raise RuntimeError: when Post response status != 202.\n        \"\"\"\n\n        # Fake the billing work (URL is fake, so it will never connect).\n        with contextlib.suppress(ConnectError):\n            async with AsyncClient() as client:\n                url = \"http://fakeCreditCardCompany.com/billings\"\n                resp = await client.post(url=url, json=payload.dict(),\n                                         timeout=config.url_timeout)\n\n            if resp.status_code != 202:\n                errmsg = f\"Failed sending POST request to Credit Card Company \" \\\n                             f\"URL {url} - [{resp.status_code}: {resp.text}].\"\n                raise RuntimeError(errmsg)\n\n        logger.info(f\"Sent Billing request with caller_id '{payload.caller_id}'.\")\n\n        # This should be something like: return resp.json()['tracking_id']\n        # but since we fake it, we need an id.\n        return uuid4()\n\n    # ---------------------------------------------------------\n    #\n    @staticmethod\n    async def _reimburse_credit_card(payload: BillingPayload) -> None:\n        \"\"\" Simulate doing the Credit Card reimbursement.\n\n        :param payload: Data needed for reimbursement.\n        :raise RuntimeError: when Post response status != 202.\n        \"\"\"\n\n        # Fake the reimbursement work (URL is fake, so it will never connect).\n        with contextlib.suppress(ConnectError):\n            async with AsyncClient() as client:\n                url = \"http://fakeCreditCardCompany.com/billings/reimburse\"\n                resp = await client.post(url=url, json=payload.dict(),\n                                         timeout=config.url_timeout)\n\n            if resp.status_code != 202:\n                errmsg = f\"Failed sending POST request to Credit Card Company \" \\\n                             f\"URL {url} - [{resp.status_code}: {resp.text}].\"\n                raise RuntimeError(errmsg)\n\n        logger.info(f\"Sent reimbursement request with caller_id '{payload.caller_id}'.\")\n\n    # ---------------------------------------------------------\n    #\n    async def process_payment_request(self, payload: PaymentPayload):\n        \"\"\" Process payment request.\n\n         Implemented logic:\n           - Get customer billing data and amount-to-pay from the CustomerService.\n           - Send the payment request to the external Credit Card Company.\n           - Store payment in DB collection api_db.payments.\n\n        :param payload: Payment request data.\n        :raise HTTPException [500]: when processing request failed.\n        :raise HTTPException [400]: when HTTP POST response != 201 or 202.\n        :raise HTTPException [500]: when connection with CustomerService failed.\n        \"\"\"\n        url = None\n\n        try:\n            meta = payload.metadata\n            root = await self.cache.get('CustomerService')\n            items = [item.dict() for item in payload.items]\n\n            # Get Customer Credit Card information.\n            async with AsyncClient() as client:\n                url = f\"{root}/v1/customers/{meta.customer_id}/billing\"\n                resp = await client.post(url=url, json=items,\n                                         timeout=config.url_timeout)\n\n            if resp.status_code != 201:\n                errmsg = f\"Failed CustomerService POST request for URL \" \\\n                         f\"{url} - [{resp.status_code}: {resp.json()['detail']}].\"\n                raise RuntimeError(errmsg)\n\n            # Charge the Customer credit card.\n            url = \"http://fictitious.com/v1/payments/callback\"\n            billing = BillingPayload(caller_id=meta.order_id,\n                                     callback_url=url, **resp.json())\n            trans_id = await self._charge_credit_card(billing)\n\n            # Store payment in DB.\n            payment = PaymentModel(metadata=meta,\n                                   id=meta.order_id,\n                                   transaction_id=trans_id)\n            await self.repo.create(payment)\n\n        except RuntimeError as why:\n            logger.error(f'{why}')\n            raise HTTPException(status_code=400, detail=f'{why}')\n\n        except ConnectTimeout:\n            errmsg = f'No connection with CustomerService on URL {url}'\n            logger.critical(errmsg)\n            raise HTTPException(status_code=500, detail=errmsg)\n\n        except BaseException as why:\n            logger.critical(f'Failed processing payment request => {why}')\n            raise HTTPException(status_code=500, detail=f'{why}')\n\n    # ---------------------------------------------------------\n    #\n    async def process_reimbursement_request(self, payload: PaymentPayload):\n        \"\"\" Process reimbursement request.\n\n         Implemented logic:\n           - Get customer billing data and amount-to-reimburse from the CustomerService.\n           - Send the reimbursement request to the external Credit Card Company.\n           - Update payment status in DB collection api_db.payments.\n\n        :param payload: Reimbursement request data.\n        :raise HTTPException [500]: when processing request failed.\n        :raise HTTPException [400]: when HTTP POST response != 201 or 202.\n        :raise HTTPException [500]: when connection with CustomerService failed.\n        \"\"\"\n        url = None\n\n        try:\n            meta = payload.metadata\n            root = await self.cache.get('CustomerService')\n            items = [item.dict() for item in payload.items]\n\n            # Get Customer Credit Card information.\n            async with AsyncClient() as client:\n                url = f\"{root}/v1/customers/{meta.customer_id}/billing\"\n                resp = await client.post(url=url, json=items,\n                                         timeout=config.url_timeout)\n\n            if resp.status_code != 201:\n                errmsg = f\"Failed CustomerService POST request for URL \" \\\n                         f\"{url} - [{resp.status_code}: {resp.json()['detail']}].\"\n                raise RuntimeError(errmsg)\n\n            # Reimburse the Customer credit card.\n            url = \"http://fictitious.com/v1/payments/callback\"\n            billing = BillingPayload(caller_id=meta.order_id,\n                                     callback_url=url, **resp.json())\n            await self._reimburse_credit_card(billing)\n\n        except RuntimeError as why:\n            logger.error(f'{why}')\n            raise HTTPException(status_code=400, detail=f'{why}')\n\n        except ConnectTimeout:\n            errmsg = f'No connection with CustomerService on URL {url}'\n            logger.critical(errmsg)\n            raise HTTPException(status_code=500, detail=errmsg)\n\n        except BaseException as why:\n            logger.critical(f'Failed processing payment request => {why}')\n            raise HTTPException(status_code=500, detail=f'{why}')\n\n    # ---------------------------------------------------------\n    #\n    async def process_response(self, payload: BillingCallback) -> BillingCallback:\n        \"\"\" Process payment/reimbursement callback response.\n\n         Implemented logic:\n           - Extract payment Order from DB using payload caller_id.\n           - Store updated billing data in DB collection api_db.payments.\n           - Send the billing response to the metadata requester using RabbitMQ.\n\n        :param payload: Payment callback response data.\n        :return: Received payload.\n        :raise HTTPException [404]: when caller_id does not exist in DB.\n        \"\"\"\n        try:\n            payment = await self.repo.read(payload.caller_id)\n\n            if not payment:\n                errmsg = f\"Caller ID '{payload.caller_id}' does \" \\\n                         f\"not exist in DB api_db.payments.\"\n                raise RuntimeError(errmsg)\n\n            # Prepare payment response.\n            response = PaymentResponse(status=payload.status, metadata=payment.metadata)\n\n            # Update payment in DB.\n            payment.status = payload.status\n            await self.repo.update(payment)\n\n            # Send response message to requester.\n            await self.client.send_message(message=response.dict(),\n                                           queue=payment.metadata.receiver)\n\n            logger.info(f\"Sent Payment response to {payment.metadata.receiver} \"\n                        f\"with status '{payload.status}' for Order '{payload.caller_id}'.\")\n\n            return payload\n\n        except RuntimeError as why:\n            logger.error(f'{why}')\n            raise HTTPException(status_code=404, detail=f'{why}')", "# -----------------------------------------------------------------------------\n#\nclass PaymentLogic:\n    \"\"\"\n    This class implements the PaymentService business logic layer.\n    \"\"\"\n\n    # ---------------------------------------------------------\n    #\n    def __init__(self, repository: PaymentsRepository,\n                 cache: UrlCache, client: RabbitClient):\n        \"\"\" The class initializer.\n\n        :param repository: Data layer handler object.\n        :param cache: Redis URL cache.\n        :param client: RabbitMQ client.\n        \"\"\"\n        self.cache = cache\n        self.client = client\n        self.repo = repository\n\n    # ---------------------------------------------------------\n    #\n    @staticmethod\n    async def _charge_credit_card(payload: BillingPayload) -> UUID:\n        \"\"\" Simulate doing the Credit Card billing.\n\n        :param payload: Data needed for Billing.\n        :return: Credit Card Company transaction ID.\n        :raise RuntimeError: when Post response status != 202.\n        \"\"\"\n\n        # Fake the billing work (URL is fake, so it will never connect).\n        with contextlib.suppress(ConnectError):\n            async with AsyncClient() as client:\n                url = \"http://fakeCreditCardCompany.com/billings\"\n                resp = await client.post(url=url, json=payload.dict(),\n                                         timeout=config.url_timeout)\n\n            if resp.status_code != 202:\n                errmsg = f\"Failed sending POST request to Credit Card Company \" \\\n                             f\"URL {url} - [{resp.status_code}: {resp.text}].\"\n                raise RuntimeError(errmsg)\n\n        logger.info(f\"Sent Billing request with caller_id '{payload.caller_id}'.\")\n\n        # This should be something like: return resp.json()['tracking_id']\n        # but since we fake it, we need an id.\n        return uuid4()\n\n    # ---------------------------------------------------------\n    #\n    @staticmethod\n    async def _reimburse_credit_card(payload: BillingPayload) -> None:\n        \"\"\" Simulate doing the Credit Card reimbursement.\n\n        :param payload: Data needed for reimbursement.\n        :raise RuntimeError: when Post response status != 202.\n        \"\"\"\n\n        # Fake the reimbursement work (URL is fake, so it will never connect).\n        with contextlib.suppress(ConnectError):\n            async with AsyncClient() as client:\n                url = \"http://fakeCreditCardCompany.com/billings/reimburse\"\n                resp = await client.post(url=url, json=payload.dict(),\n                                         timeout=config.url_timeout)\n\n            if resp.status_code != 202:\n                errmsg = f\"Failed sending POST request to Credit Card Company \" \\\n                             f\"URL {url} - [{resp.status_code}: {resp.text}].\"\n                raise RuntimeError(errmsg)\n\n        logger.info(f\"Sent reimbursement request with caller_id '{payload.caller_id}'.\")\n\n    # ---------------------------------------------------------\n    #\n    async def process_payment_request(self, payload: PaymentPayload):\n        \"\"\" Process payment request.\n\n         Implemented logic:\n           - Get customer billing data and amount-to-pay from the CustomerService.\n           - Send the payment request to the external Credit Card Company.\n           - Store payment in DB collection api_db.payments.\n\n        :param payload: Payment request data.\n        :raise HTTPException [500]: when processing request failed.\n        :raise HTTPException [400]: when HTTP POST response != 201 or 202.\n        :raise HTTPException [500]: when connection with CustomerService failed.\n        \"\"\"\n        url = None\n\n        try:\n            meta = payload.metadata\n            root = await self.cache.get('CustomerService')\n            items = [item.dict() for item in payload.items]\n\n            # Get Customer Credit Card information.\n            async with AsyncClient() as client:\n                url = f\"{root}/v1/customers/{meta.customer_id}/billing\"\n                resp = await client.post(url=url, json=items,\n                                         timeout=config.url_timeout)\n\n            if resp.status_code != 201:\n                errmsg = f\"Failed CustomerService POST request for URL \" \\\n                         f\"{url} - [{resp.status_code}: {resp.json()['detail']}].\"\n                raise RuntimeError(errmsg)\n\n            # Charge the Customer credit card.\n            url = \"http://fictitious.com/v1/payments/callback\"\n            billing = BillingPayload(caller_id=meta.order_id,\n                                     callback_url=url, **resp.json())\n            trans_id = await self._charge_credit_card(billing)\n\n            # Store payment in DB.\n            payment = PaymentModel(metadata=meta,\n                                   id=meta.order_id,\n                                   transaction_id=trans_id)\n            await self.repo.create(payment)\n\n        except RuntimeError as why:\n            logger.error(f'{why}')\n            raise HTTPException(status_code=400, detail=f'{why}')\n\n        except ConnectTimeout:\n            errmsg = f'No connection with CustomerService on URL {url}'\n            logger.critical(errmsg)\n            raise HTTPException(status_code=500, detail=errmsg)\n\n        except BaseException as why:\n            logger.critical(f'Failed processing payment request => {why}')\n            raise HTTPException(status_code=500, detail=f'{why}')\n\n    # ---------------------------------------------------------\n    #\n    async def process_reimbursement_request(self, payload: PaymentPayload):\n        \"\"\" Process reimbursement request.\n\n         Implemented logic:\n           - Get customer billing data and amount-to-reimburse from the CustomerService.\n           - Send the reimbursement request to the external Credit Card Company.\n           - Update payment status in DB collection api_db.payments.\n\n        :param payload: Reimbursement request data.\n        :raise HTTPException [500]: when processing request failed.\n        :raise HTTPException [400]: when HTTP POST response != 201 or 202.\n        :raise HTTPException [500]: when connection with CustomerService failed.\n        \"\"\"\n        url = None\n\n        try:\n            meta = payload.metadata\n            root = await self.cache.get('CustomerService')\n            items = [item.dict() for item in payload.items]\n\n            # Get Customer Credit Card information.\n            async with AsyncClient() as client:\n                url = f\"{root}/v1/customers/{meta.customer_id}/billing\"\n                resp = await client.post(url=url, json=items,\n                                         timeout=config.url_timeout)\n\n            if resp.status_code != 201:\n                errmsg = f\"Failed CustomerService POST request for URL \" \\\n                         f\"{url} - [{resp.status_code}: {resp.json()['detail']}].\"\n                raise RuntimeError(errmsg)\n\n            # Reimburse the Customer credit card.\n            url = \"http://fictitious.com/v1/payments/callback\"\n            billing = BillingPayload(caller_id=meta.order_id,\n                                     callback_url=url, **resp.json())\n            await self._reimburse_credit_card(billing)\n\n        except RuntimeError as why:\n            logger.error(f'{why}')\n            raise HTTPException(status_code=400, detail=f'{why}')\n\n        except ConnectTimeout:\n            errmsg = f'No connection with CustomerService on URL {url}'\n            logger.critical(errmsg)\n            raise HTTPException(status_code=500, detail=errmsg)\n\n        except BaseException as why:\n            logger.critical(f'Failed processing payment request => {why}')\n            raise HTTPException(status_code=500, detail=f'{why}')\n\n    # ---------------------------------------------------------\n    #\n    async def process_response(self, payload: BillingCallback) -> BillingCallback:\n        \"\"\" Process payment/reimbursement callback response.\n\n         Implemented logic:\n           - Extract payment Order from DB using payload caller_id.\n           - Store updated billing data in DB collection api_db.payments.\n           - Send the billing response to the metadata requester using RabbitMQ.\n\n        :param payload: Payment callback response data.\n        :return: Received payload.\n        :raise HTTPException [404]: when caller_id does not exist in DB.\n        \"\"\"\n        try:\n            payment = await self.repo.read(payload.caller_id)\n\n            if not payment:\n                errmsg = f\"Caller ID '{payload.caller_id}' does \" \\\n                         f\"not exist in DB api_db.payments.\"\n                raise RuntimeError(errmsg)\n\n            # Prepare payment response.\n            response = PaymentResponse(status=payload.status, metadata=payment.metadata)\n\n            # Update payment in DB.\n            payment.status = payload.status\n            await self.repo.update(payment)\n\n            # Send response message to requester.\n            await self.client.send_message(message=response.dict(),\n                                           queue=payment.metadata.receiver)\n\n            logger.info(f\"Sent Payment response to {payment.metadata.receiver} \"\n                        f\"with status '{payload.status}' for Order '{payload.caller_id}'.\")\n\n            return payload\n\n        except RuntimeError as why:\n            logger.error(f'{why}')\n            raise HTTPException(status_code=404, detail=f'{why}')", ""]}
{"filename": "PaymentService/src/repository/models.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-03-29 19:37:08\n     $Rev: 45", "    $Date: 2023-03-29 19:37:08\n     $Rev: 45\n\"\"\"\n\n# BUILTIN modules\nfrom uuid import UUID\nfrom enum import Enum\nfrom typing import Callable\nfrom datetime import datetime\n", "from datetime import datetime\n\n# Third party modules\nfrom pydantic import BaseModel, BaseConfig, Field, UUID4, validator\n\n# Local modules\nfrom .documentation import payment_documentation as pay_doc\nfrom ..web.api.documentation import (metadata_example,\n                                     metadata_documentation as meta_doc)\n", "                                     metadata_documentation as meta_doc)\n\n\n# ---------------------------------------------------------\n#\nclass MetadataSchema(BaseModel):\n    \"\"\" Representation of Order metadata in the system. \"\"\"\n    receiver: str = Field(**meta_doc['receiver'])\n    order_id: str = Field(**meta_doc['order_id'])\n    customer_id: str = Field(**meta_doc['customer_id'])\n\n    class Config:\n        schema_extra = {\"example\": metadata_example}\n\n    @validator('*', pre=True)\n    def decode_values(cls, value):\n        \"\"\" Decode UUID value into a str. \"\"\"\n        return str(value) if isinstance(value, UUID) else value", "\n\n# ---------------------------------------------------------\n#\nclass Status(str, Enum):\n    \"\"\" Payment result status. \"\"\"\n    PEND = 'pending'\n    REIM = 'reimbursed'\n    PAID = 'paymentPaid'\n    FAIL = 'paymentFailed'", "\n\n# ------------------------------------------------------------------------\n#\nclass MongoBase(BaseModel):\n    \"\"\"\n    Class that handles conversions between MongoDB '_id' key\n    and our own 'id' key.\n\n    MongoDB uses `_id` as an internal default index key.\n    We can use that to our advantage.\n    \"\"\"\n\n    class Config(BaseConfig):\n        \"\"\" basic config. \"\"\"\n        orm_mode = True\n        allow_population_by_field_name = True\n\n    # noinspection PyArgumentList\n    @classmethod\n    def from_mongo(cls, data: dict) -> Callable:\n        \"\"\" Convert \"_id\" (str object) into \"id\" (UUID object). \"\"\"\n\n        if not data:\n            return data\n\n        mongo_id = data.pop('_id', None)\n        return cls(**dict(data, id=mongo_id))\n\n    def to_mongo(self, **kwargs) -> dict:\n        \"\"\" Convert \"id\" (UUID object) into \"_id\" (str object). \"\"\"\n        parsed = self.dict(**kwargs)\n\n        if '_id' not in parsed and 'id' in parsed:\n            parsed['_id'] = str(parsed.pop('id'))\n\n        return parsed", "\n\n# ---------------------------------------------------------\n#\nclass PaymentUpdateModel(MongoBase):\n    \"\"\" Representation of an Order in the system. \"\"\"\n    metadata: MetadataSchema\n    transaction_id: UUID4 = Field(**pay_doc['transaction_id'])\n    status: Status = Field(default=Status.PEND, **pay_doc['status'])\n    created: datetime = Field(default_factory=datetime.utcnow, **pay_doc['created'])", "\n\n# ---------------------------------------------------------\n#\nclass PaymentModel(PaymentUpdateModel):\n    \"\"\" Representation of a Payment in the system. \"\"\"\n    id: UUID4 = Field(**pay_doc['id'])\n"]}
{"filename": "PaymentService/src/repository/payment_data_adapter.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-03-23 19:52:08\n     $Rev: 36", "    $Date: 2023-03-23 19:52:08\n     $Rev: 36\n\"\"\"\n\n# Third party modules\nfrom pydantic import UUID4\n\n# Local modules\nfrom .db import Engine\nfrom .models import (PaymentModel, PaymentUpdateModel)", "from .db import Engine\nfrom .models import (PaymentModel, PaymentUpdateModel)\n\n\n# ------------------------------------------------------------------------\n#\nclass PaymentsRepository:\n    \"\"\"\n    This class implements the PaymentService data layer adapter (the CRUD operations).\n    \"\"\"\n\n    # ---------------------------------------------------------\n    #\n    @staticmethod\n    async def connection_info() -> dict:\n        \"\"\" Return DB connection information.\n\n        :return: DB connection information.\n        \"\"\"\n        return await Engine.connection.server_info()\n\n    # ---------------------------------------------------------\n    #\n    @staticmethod\n    async def create(payload: PaymentModel) -> bool:\n        \"\"\" Create Payment in DB collection api_db.payments.\n\n        :param payload: New Payment payload.\n        :return: DB create result.\n        \"\"\"\n        response = await Engine.db.payments.insert_one(payload.to_mongo())\n\n        return response.acknowledged\n\n    # ---------------------------------------------------------\n    #\n    @staticmethod\n    async def read(key: UUID4) -> PaymentModel:\n        \"\"\" Read Payment for matching index key from DB collection api_db.payments.\n\n        :param key: Index key.\n        :return: Found Payment.\n        \"\"\"\n\n        response = await Engine.db.payments.find_one({\"_id\": str(key)})\n\n        return PaymentModel.from_mongo(response)\n\n    # ---------------------------------------------------------\n    #\n    @staticmethod\n    async def update(payload: PaymentModel) -> bool:\n        \"\"\" Update Payment in DB collection api_db.payments.\n\n        :param payload: Updated Order payload.\n        :return: DB update result.\n        \"\"\"\n\n        base = PaymentUpdateModel(**payload.dict()).to_mongo()\n        response = await Engine.db.payments.update_one({\"_id\": str(payload.id)},\n                                                       {\"$set\": {**base}})\n\n        return response.raw_result['updatedExisting']", ""]}
{"filename": "PaymentService/src/repository/db.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-03-21 02:16:53\n     $Rev: 26", "    $Date: 2023-03-21 02:16:53\n     $Rev: 26\n\"\"\"\n\n# Third party modules\nfrom motor.motor_asyncio import AsyncIOMotorClient, AsyncIOMotorDatabase\n\n# Local program modules\nfrom ..config.setup import config\n", "from ..config.setup import config\n\n\n# ---------------------------------------------------------\n#\nclass Engine:\n    \"\"\" MongoDb database async engine class.\n\n\n    :type db: C{motor.motor_asyncio.AsyncIOMotorDatabase}\n    :ivar db: AsyncIOMotorDatabase class instance.\n    :type connection: C{motor.motor_asyncio.AsyncIOMotorClient}\n    :ivar connection: AsyncIOMotorClient class instance.\n    \"\"\"\n\n    db: AsyncIOMotorDatabase = None\n    connection: AsyncIOMotorClient = None\n\n    # ---------------------------------------------------------\n    #\n    @classmethod\n    async def connect_to_mongo(cls):\n        \"\"\" Initialize DB connection to MongoDb and database.\n\n        Setting server connection timeout to 5 (default is 30) seconds.\n        \"\"\"\n\n        cls.connection = AsyncIOMotorClient(config.mongo_url,\n                                            uuidRepresentation='standard',\n                                            serverSelectionTimeoutMS=5000)\n        cls.db = cls.connection.api_db\n\n    # ---------------------------------------------------------\n    #\n    @classmethod\n    async def close_mongo_connection(cls):\n        \"\"\" Close DB connection. \"\"\"\n\n        cls.connection.close()", ""]}
{"filename": "PaymentService/src/repository/documentation.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-03-21 22:20:47\n     $Rev: 27", "    $Date: 2023-03-21 22:20:47\n     $Rev: 27\n\"\"\"\n\npayment_documentation = {\n    \"receiver\": {'example': 'OrderService',\n                 'description': 'Requesting service.'},\n    \"status\": {'description': 'Payment workflow status.'},\n    \"created\": {'example': \"`2023-03-10T12:15:23.123234`\",\n                'description': 'Timestamp when the Payment was created.'},", "    \"created\": {'example': \"`2023-03-10T12:15:23.123234`\",\n                'description': 'Timestamp when the Payment was created.'},\n    \"id\": {'example': \"`dbb86c27-2eed-410d-881e-ad47487dd228`\",\n           'description': 'Order ID: A unique identifier for an existing Order.'},\n    \"transaction_id\": {'example': 'f2861560-e9ed-4463-955f-0c55c3b416fb',\n                       'description': 'Transaction ID for the Credit Card company for the current Order.'},\n}\n"]}
{"filename": "PaymentService/src/repository/url_cache.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-03-24 23:18:27\n     $Rev: 38", "    $Date: 2023-03-24 23:18:27\n     $Rev: 38\n\"\"\"\n\n# Third party modules\nfrom aioredis import from_url\n\n# Local modules\nfrom .db import Engine\n", "from .db import Engine\n\n# Constants\nEXPIRE = 60*60*24\n\"\"\" Redis keys expire after 24h. \"\"\"\n\n\n# ------------------------------------------------------------------------\n#\nclass UrlCache:\n    \"\"\" This class handles Redis URL cache.\n\n    Is automatically populated from MongoDB api_db.service_urls collection.\n    \"\"\"\n\n    # ---------------------------------------------------------\n    #\n    def __init__(self, url: str):\n        \"\"\"  The class initializer.\n\n        :param url: Redis connection URL.\n        \"\"\"\n        self.client = from_url(url)\n\n    # ---------------------------------------------------------\n    #\n    async def get(self, key: str) -> str:\n        \"\"\" Get MicroService URL from Redis.\n\n        Populate from MongoDB api_db.service_urls collection if needed.\n        All URL Keys expire after 24h in the cache.\n\n        :param key: MicroService name.\n        :return: MicroService URL.\n        \"\"\"\n        value = await self.client.get(key)\n\n        if not value:\n            value = await Engine.db.service_urls.find_one({\"_id\": key})\n            await self.client.set(key, value['url'], ex=EXPIRE)\n\n        return value.decode() if isinstance(value, bytes) else value['url']", "#\nclass UrlCache:\n    \"\"\" This class handles Redis URL cache.\n\n    Is automatically populated from MongoDB api_db.service_urls collection.\n    \"\"\"\n\n    # ---------------------------------------------------------\n    #\n    def __init__(self, url: str):\n        \"\"\"  The class initializer.\n\n        :param url: Redis connection URL.\n        \"\"\"\n        self.client = from_url(url)\n\n    # ---------------------------------------------------------\n    #\n    async def get(self, key: str) -> str:\n        \"\"\" Get MicroService URL from Redis.\n\n        Populate from MongoDB api_db.service_urls collection if needed.\n        All URL Keys expire after 24h in the cache.\n\n        :param key: MicroService name.\n        :return: MicroService URL.\n        \"\"\"\n        value = await self.client.get(key)\n\n        if not value:\n            value = await Engine.db.service_urls.find_one({\"_id\": key})\n            await self.client.set(key, value['url'], ex=EXPIRE)\n\n        return value.decode() if isinstance(value, bytes) else value['url']", ""]}
{"filename": "PaymentService/src/config/setup.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-04-01 21:09:57\n     $Rev: 56", "    $Date: 2023-04-01 21:09:57\n     $Rev: 56\n\"\"\"\n\n# BUILTIN modules\nimport site\n\n# Third party modules\nfrom dotenv import load_dotenv\nfrom pydantic import BaseSettings", "from dotenv import load_dotenv\nfrom pydantic import BaseSettings\n\n# Constants\nMISSING_SECRET = '>>> missing SECRETS file <<<'\n\"\"\" Error message for missing secrets file. \"\"\"\nMISSING_ENV = '>>> missing ENV value <<<'\n\"\"\" Error message for missing values in the .env file. \"\"\"\n\n", "\n\n# ---------------------------------------------------------\n#\nclass Configuration(BaseSettings):\n    \"\"\" Configuration parameters. \"\"\"\n\n    # OpenAPI documentation.\n    name: str = MISSING_ENV\n    version: str = MISSING_ENV\n\n    # Service parameters.\n    service_name: str = MISSING_ENV\n    service_log_level: str = MISSING_ENV\n\n    # External resource parameters.\n    url_timeout: tuple = (1.0, 5.0)\n    mongo_url: str = MISSING_SECRET\n    redis_url: str = MISSING_SECRET\n    rabbit_url: str = MISSING_SECRET\n\n    # Handles both local and Docker environments.\n    class Config:\n        secrets_dir = f'{site.USER_BASE}/secrets'", "\n\n# ---------------------------------------------------------\n\n# Note that the \".env\" file is always implicitly loaded.\nload_dotenv()\n\nconfig = Configuration()\n\"\"\" Configuration parameters instance. \"\"\"\n", "\"\"\" Configuration parameters instance. \"\"\"\n"]}
{"filename": "PaymentService/src/web/main.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-03-29 19:37:08\n     $Rev: 45", "    $Date: 2023-03-29 19:37:08\n     $Rev: 45\n\"\"\"\n\n# BUILTIN modules\nfrom pathlib import Path\nfrom contextlib import asynccontextmanager\n\n# Third party modules\nfrom fastapi import FastAPI", "# Third party modules\nfrom fastapi import FastAPI\nfrom fastapi.responses import JSONResponse\nfrom fastapi.staticfiles import StaticFiles\n\n# Local modules\nfrom .api import api\nfrom ..config.setup import config\nfrom ..repository.db import Engine\nfrom .health_manager import HealthManager", "from ..repository.db import Engine\nfrom .health_manager import HealthManager\nfrom ..repository.url_cache import UrlCache\nfrom .api.schemas import HealthSchema, HealthStatusError\nfrom ..tools.custom_logging import create_unified_logger\nfrom .api.documentation import (servers, license_info,\n                                tags_metadata, description)\nfrom ..repository.payment_data_adapter import PaymentsRepository\n\n", "\n\n# ---------------------------------------------------------\n#\nclass Service(FastAPI):\n\n    def __init__(self, *args, **kwargs):\n        \"\"\" This class adds RabbitMQ message consumption and unified logging.\n\n        :param args: named arguments.\n        :param kwargs: key-value pair arguments.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n\n        self.level, self.logger = create_unified_logger(config.service_log_level)", "\n\n# ---------------------------------------------------------\n#\n@asynccontextmanager\nasync def lifespan(service: Service):\n    await startup(service)\n    yield\n    await shutdown(service)\n", "    await shutdown(service)\n\n\n# ---------------------------------------------------------\n\napp = Service(\n    servers=servers,\n    lifespan=lifespan,\n    title=config.name,\n    version=config.version,", "    title=config.name,\n    version=config.version,\n    description=description,\n    license_info=license_info,\n    openapi_tags=tags_metadata,\n)\napp.include_router(api.router)\n\n# Needed for OpenAPI Markdown images to be displayed.\nstatic_path = Path(__file__).parent.parent.parent.parent / 'design_docs'", "# Needed for OpenAPI Markdown images to be displayed.\nstatic_path = Path(__file__).parent.parent.parent.parent / 'design_docs'\napp.mount(\"/static\", StaticFiles(directory=static_path))\n\n\n# ---------------------------------------------------------\n#\n@app.get(\n    '/health',\n    response_model=HealthSchema,", "    '/health',\n    response_model=HealthSchema,\n    tags=[\"health check endpoint\"],\n    responses={500: {\"model\": HealthStatusError}},\n)\nasync def health_check() -> HealthSchema:\n    \"\"\" **Health check endpoint.** \"\"\"\n\n    content = await HealthManager(UrlCache(config.redis_url),\n                                  PaymentsRepository()).get_status()", "    content = await HealthManager(UrlCache(config.redis_url),\n                                  PaymentsRepository()).get_status()\n    response_code = (200 if content.status else 500)\n\n    return JSONResponse(status_code=response_code, content=content.dict())\n\n\n# ---------------------------------------------------------\n#\nasync def startup(service: Service):", "#\nasync def startup(service: Service):\n    \"\"\" Initialize MongoDB connection. \"\"\"\n\n    service.logger.info('Establishing MongoDB connection...')\n    await Engine.connect_to_mongo()\n\n\n# ---------------------------------------------------------\n#", "# ---------------------------------------------------------\n#\nasync def shutdown(service: Service):\n    \"\"\" Close MongoDB connection. \"\"\"\n\n    service.logger.info('Disconnecting from MongoDB...')\n    await Engine.close_mongo_connection()\n"]}
{"filename": "PaymentService/src/web/health_manager.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-03-23 19:52:08\n     $Rev: 36", "    $Date: 2023-03-23 19:52:08\n     $Rev: 36\n\"\"\"\n\n# BUILTIN modules\nfrom typing import List\n\n# Third party modules\nfrom loguru import logger\nfrom httpx import AsyncClient, ConnectTimeout", "from loguru import logger\nfrom httpx import AsyncClient, ConnectTimeout\n\n# local modules\nfrom ..config.setup import config\nfrom ..repository.url_cache import UrlCache\nfrom ..web.api.schemas import ResourceSchema, HealthSchema\nfrom ..repository.payment_data_adapter import PaymentsRepository\n\n# Constants", "\n# Constants\nURLS = {'CustomerService'}\n\"\"\" Used internal MicroService(s). \"\"\"\n\n\n# -----------------------------------------------------------------------------\n#\nclass HealthManager:\n    \"\"\"\n    This class handles PaymentService health status reporting on used resources.\n    \"\"\"\n\n    # ---------------------------------------------------------\n    #\n    def __init__(self, cache: UrlCache, repository: PaymentsRepository):\n        \"\"\" The class initializer.\n\n        :param cache: Redis URL cache.\n        :param repository: Data layer handler object.\n        \"\"\"\n        self.cache = cache\n        self.repo = repository\n\n    # ---------------------------------------------------------\n    #\n    async def _get_mongo_status(self) -> List[ResourceSchema]:\n        \"\"\" Return MongoDb connection status.\n\n        :return: MongoDb connection status.\n        \"\"\"\n\n        try:\n            status = True\n            await self.repo.connection_info()\n\n        except BaseException as why:\n            logger.critical(f'MongoDB: {why}')\n            status = False\n\n        return [ResourceSchema(name='MongoDb', status=status)]\n\n    # ---------------------------------------------------------\n    #\n    async def _get_service_status(self) -> List[ResourceSchema]:\n        \"\"\" Return RabbitMQ connection status.\n\n        :return: Service connection status.\n        \"\"\"\n        result = []\n\n        async with AsyncClient() as client:\n            for service in URLS:\n                try:\n                    root = await self.cache.get(service)\n                    url = f'{root}/health'\n                    status = False\n\n                    # Request used Microservice health status.\n                    response = await client.get(url=url, timeout=(1.0, 5.0))\n\n                    if response.status_code == 200:\n                        status = response.json()['status']\n\n                except ConnectTimeout:\n                    logger.critical(f'No connection with {service} on URL {url}')\n\n                result.append(ResourceSchema(name=service, status=status))\n\n        return result\n\n    # ---------------------------------------------------------\n    #\n    async def get_status(self) -> HealthSchema:\n        \"\"\" Return Health status for used resources.\n\n        :return: Service health status.\n        \"\"\"\n        resource_items = []\n        resource_items += await self._get_mongo_status()\n        resource_items += await self._get_service_status()\n        total_status = all(key.status for key in resource_items)\n\n        return HealthSchema(status=total_status,\n                            version=config.version,\n                            name=config.service_name,\n                            resources=resource_items)", "class HealthManager:\n    \"\"\"\n    This class handles PaymentService health status reporting on used resources.\n    \"\"\"\n\n    # ---------------------------------------------------------\n    #\n    def __init__(self, cache: UrlCache, repository: PaymentsRepository):\n        \"\"\" The class initializer.\n\n        :param cache: Redis URL cache.\n        :param repository: Data layer handler object.\n        \"\"\"\n        self.cache = cache\n        self.repo = repository\n\n    # ---------------------------------------------------------\n    #\n    async def _get_mongo_status(self) -> List[ResourceSchema]:\n        \"\"\" Return MongoDb connection status.\n\n        :return: MongoDb connection status.\n        \"\"\"\n\n        try:\n            status = True\n            await self.repo.connection_info()\n\n        except BaseException as why:\n            logger.critical(f'MongoDB: {why}')\n            status = False\n\n        return [ResourceSchema(name='MongoDb', status=status)]\n\n    # ---------------------------------------------------------\n    #\n    async def _get_service_status(self) -> List[ResourceSchema]:\n        \"\"\" Return RabbitMQ connection status.\n\n        :return: Service connection status.\n        \"\"\"\n        result = []\n\n        async with AsyncClient() as client:\n            for service in URLS:\n                try:\n                    root = await self.cache.get(service)\n                    url = f'{root}/health'\n                    status = False\n\n                    # Request used Microservice health status.\n                    response = await client.get(url=url, timeout=(1.0, 5.0))\n\n                    if response.status_code == 200:\n                        status = response.json()['status']\n\n                except ConnectTimeout:\n                    logger.critical(f'No connection with {service} on URL {url}')\n\n                result.append(ResourceSchema(name=service, status=status))\n\n        return result\n\n    # ---------------------------------------------------------\n    #\n    async def get_status(self) -> HealthSchema:\n        \"\"\" Return Health status for used resources.\n\n        :return: Service health status.\n        \"\"\"\n        resource_items = []\n        resource_items += await self._get_mongo_status()\n        resource_items += await self._get_service_status()\n        total_status = all(key.status for key in resource_items)\n\n        return HealthSchema(status=total_status,\n                            version=config.version,\n                            name=config.service_name,\n                            resources=resource_items)", ""]}
{"filename": "PaymentService/src/web/api/schemas.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-03-29 19:37:08\n     $Rev: 45", "    $Date: 2023-03-29 19:37:08\n     $Rev: 45\n\"\"\"\n\n# BUILTIN modules\nfrom enum import Enum\nfrom typing import List, Optional\n\n# Third party modules\nfrom pydantic import (BaseModel, conint, conlist,", "# Third party modules\nfrom pydantic import (BaseModel, conint, conlist,\n                      AnyHttpUrl, Field, UUID4, PositiveFloat)\n\n# Local modules\nfrom ...repository.models import Status, MetadataSchema\nfrom .documentation import (resource_example, billing_example,\n                            metadata_documentation as meta_doc,\n                            callback_documentation as callback)\n", "                            callback_documentation as callback)\n\n\n# ---------------------------------------------------------\n#\nclass ApiError(BaseModel):\n    \"\"\" Define model for a http 400 exception (Unprocessable Entity). \"\"\"\n    detail: str = \"Failed internal Microservice API call\"\n\n\nclass ConnectError(BaseModel):\n    \"\"\" Define model for a http 500 exception (INTERNAL_SERVER_ERROR). \"\"\"\n    detail: str = \"Failed to connect to internal MicroService\"", "\n\nclass ConnectError(BaseModel):\n    \"\"\" Define model for a http 500 exception (INTERNAL_SERVER_ERROR). \"\"\"\n    detail: str = \"Failed to connect to internal MicroService\"\n\n\nclass HealthStatusError(BaseModel):\n    \"\"\" Define model for a http 500 exception (INTERNAL_SERVER_ERROR). \"\"\"\n    detail: str = \"HEALTH: resource connection(s) are down\"", "\n\n# ---------------------------------------------------------\n#\nclass Products(str, Enum):\n    \"\"\" Representation of valid products in the system. \"\"\"\n    lasagna = 'Lasagna'\n    cheese_burger = 'Double Cheeseburger'\n    veil = 'Veil with glazed onions and blue cheese'\n    vego_salad = 'Vegetarian Salad with healthy produce'", "\n\nclass OrderItem(BaseModel):\n    \"\"\" Required order item parameters. \"\"\"\n    product: Products\n    quantity: Optional[conint(ge=1, strict=True)] = 1\n\n\nclass OrderItems(BaseModel):\n    \"\"\" A list of the ordered items. \"\"\"\n    items: conlist(OrderItem, min_items=1)", "class OrderItems(BaseModel):\n    \"\"\" A list of the ordered items. \"\"\"\n    items: conlist(OrderItem, min_items=1)\n\n\n# ---------------------------------------------------------\n#\nclass PaymentPayload(OrderItems):\n    \"\"\" Representation of a payment payload in the system. \"\"\"\n    metadata: MetadataSchema", "\n\n# ---------------------------------------------------------\n#\nclass PaymentAcknowledge(BaseModel):\n    \"\"\" Representation of a payment Acknowledge response in the system. \"\"\"\n    status: str = 'requestReceived'\n    order_id: UUID4 = Field(**meta_doc['order_id'])\n\n", "\n\n# ---------------------------------------------------------\n#\nclass CreditCardSchema(BaseModel):\n    \"\"\" Representation of Credit Card Billing Information in the system. \"\"\"\n    CVV: str\n    Bank: str\n    Name: str\n    Expiry: str\n    Address: str\n    Country: str\n    MoneyRange: str\n    CardNumber: str\n    IssuingNetwork: str\n\n    class Config:\n        schema_extra = {\"example\": billing_example}", "\n\n# ---------------------------------------------------------\n#\nclass BillingPayload(BaseModel):\n    \"\"\" Representation of an external Billing payload in the system. \"\"\"\n    callback_url: AnyHttpUrl\n    billing_info: CreditCardSchema\n    amount: PositiveFloat = Field(example=9.54)\n    caller_id: str = Field(**callback['caller_id'])", "\n\n# ---------------------------------------------------------\n#\nclass BillingCallback(BaseModel):\n    \"\"\" Representation of an external Billing Callback in the system. \"\"\"\n    status: Status = Field(**callback['status'])\n    caller_id: UUID4 = Field(**callback['caller_id'])\n    transaction_id: UUID4 = Field(**callback['transaction_id'])\n", "\n\n# -----------------------------------------------------------------------------\n#\nclass ResourceSchema(BaseModel):\n    \"\"\" Representation of a  health resources response.\n\n    :ivar name: Resource name.\n    :ivar status: Resource status\n    \"\"\"\n    name: str\n    status: bool", "\n\n# -----------------------------------------------------------------------------\n#\nclass HealthSchema(BaseModel):\n    \"\"\" Representation of a  health response.\n\n    :ivar name: Service name.\n    :ivar version: Service version.\n    :ivar status: Overall health status\n    :ivar resources: Status for individual resources..\n    \"\"\"\n    name: str\n    version: str\n    status: bool\n    resources: List[ResourceSchema]\n\n    class Config:\n        schema_extra = {\"example\": resource_example}", ""]}
{"filename": "PaymentService/src/web/api/api.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-03-31 20:31:23\n     $Rev: 53", "    $Date: 2023-03-31 20:31:23\n     $Rev: 53\n\"\"\"\n\n# Third party modules\nfrom fastapi import APIRouter, status\n\n# Local modules\nfrom ...config.setup import config\nfrom ...repository.url_cache import UrlCache", "from ...config.setup import config\nfrom ...repository.url_cache import UrlCache\nfrom ...tools.rabbit_client import RabbitClient\nfrom ...business.payment_handler import PaymentLogic\nfrom .schemas import (PaymentAcknowledge, BillingCallback,\n                      ApiError, ConnectError, PaymentPayload)\nfrom ...repository.payment_data_adapter import PaymentsRepository\n\n# Constants\nrouter = APIRouter(prefix=f\"/v1/payments\", tags=[f\"Payments\"])", "# Constants\nrouter = APIRouter(prefix=f\"/v1/payments\", tags=[f\"Payments\"])\n\"\"\" Payments API endpoint router. \"\"\"\n\n\n# ---------------------------------------------------------\n#\n@router.post(\n    '',\n    response_model=PaymentAcknowledge,", "    '',\n    response_model=PaymentAcknowledge,\n    status_code=status.HTTP_202_ACCEPTED,\n    responses={\n        400: {\"model\": ApiError},\n        500: {'model': ConnectError}}\n)\nasync def create_payment(payload: PaymentPayload) -> PaymentAcknowledge:\n    \"\"\" **Process payment request.** \"\"\"\n    worker = PaymentLogic(repository=PaymentsRepository(),", "    \"\"\" **Process payment request.** \"\"\"\n    worker = PaymentLogic(repository=PaymentsRepository(),\n                          cache=UrlCache(config.redis_url),\n                          client=RabbitClient(config.rabbit_url))\n    await worker.process_payment_request(payload)\n    return PaymentAcknowledge(order_id=payload.metadata.order_id)\n\n\n# ---------------------------------------------------------\n#", "# ---------------------------------------------------------\n#\n@router.post(\n    '/reimburse',\n    response_model=PaymentAcknowledge,\n    status_code=status.HTTP_202_ACCEPTED,\n    responses={\n        400: {\"model\": ApiError},\n        500: {'model': ConnectError}}\n)", "        500: {'model': ConnectError}}\n)\nasync def reimburse_payment(payload: PaymentPayload) -> PaymentAcknowledge:\n    \"\"\" **Process reimbursement request.** \"\"\"\n    worker = PaymentLogic(repository=PaymentsRepository(),\n                          cache=UrlCache(config.redis_url),\n                          client=RabbitClient(config.rabbit_url))\n    await worker.process_reimbursement_request(payload)\n    return PaymentAcknowledge(order_id=payload.metadata.order_id)\n", "    return PaymentAcknowledge(order_id=payload.metadata.order_id)\n\n\n# ---------------------------------------------------------\n#\n@router.post(\n    '/callback',\n    response_model=BillingCallback,\n    status_code=status.HTTP_201_CREATED,\n)", "    status_code=status.HTTP_201_CREATED,\n)\nasync def billing_response(payload: BillingCallback) -> BillingCallback:\n    \"\"\" **Process callback response.** \"\"\"\n    worker = PaymentLogic(repository=PaymentsRepository(),\n                          cache=UrlCache(config.redis_url),\n                          client=RabbitClient(config.rabbit_url))\n    return await worker.process_response(payload)\n", ""]}
{"filename": "PaymentService/src/web/api/documentation.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\"\"\"\nCopyright: Wilde Consulting\n  License: Apache 2.0\n\nVERSION INFO::\n    $Repo: fastapi_messaging\n  $Author: Anders Wiklund\n    $Date: 2023-03-31 18:44:42\n     $Rev: 51", "    $Date: 2023-03-31 18:44:42\n     $Rev: 51\n\"\"\"\n\n\n# Local modules\nfrom ...config.setup import config\n\n\nresource_example = {", "\nresource_example = {\n    \"status\": True,\n    \"version\": f\"{config.version}\",\n    \"name\": f\"{config.service_name}\",\n    \"resources\": [\n        {\n            \"name\": \"MongoDb\",\n            \"status\": True\n        },", "            \"status\": True\n        },\n        {\n            \"name\": \"CustomerService\",\n            \"status\": True\n        },\n    ]\n}\n\nbilling_example = {", "\nbilling_example = {\n        \"IssuingNetwork\": \"MASTERCARD\",\n        \"CardNumber\": \"5485848512008744\",\n        \"Bank\": \"NORDEA BANK AB\",\n        \"Name\": \"Barirah Chou\",\n        \"Address\": \"Stallstigen 30\",\n        \"Country\": \"SWEDEN\",\n        \"MoneyRange\": \"$804\",\n        \"CVV\": \"808\",", "        \"MoneyRange\": \"$804\",\n        \"CVV\": \"808\",\n        \"Expiry\": \"07/2030\",\n}\n\nmetadata_example = {\n    \"receiver\": \"OrderService\",\n    \"order_id\": 'b76d019f-5937-4a14-8091-1d9f18666c93',\n    \"customer_id\": 'f2861560-e9ed-4463-955f-0c55c3b416fb',\n}", "    \"customer_id\": 'f2861560-e9ed-4463-955f-0c55c3b416fb',\n}\n\nmetadata_documentation = {\n    \"receiver\": {'example': 'OrderService',\n                 'description': 'Requesting service.'},\n    \"order_id\": {'example': 'b76d019f-5937-4a14-8091-1d9f18666c93',\n                 'description': 'Order ID of the Order currently being handled.'},\n    \"customer_id\": {'example': 'f2861560-e9ed-4463-955f-0c55c3b416fb',\n                    'description': 'Customer ID for the Order currently being handled.'},", "    \"customer_id\": {'example': 'f2861560-e9ed-4463-955f-0c55c3b416fb',\n                    'description': 'Customer ID for the Order currently being handled.'},\n}\n\ncallback_documentation = {\n    \"status\": {'example': 'paymentPaid',\n               'description': 'Credit Card billing/reimburse result.'},\n    \"caller_id\": {'example': 'b76d019f-5937-4a14-8091-1d9f18666c93',\n                  'description': 'Internal Order ID of the billed Order.'},\n    \"transaction_id\": {'example': 'f2861560-e9ed-4463-955f-0c55c3b416fb',", "                  'description': 'Internal Order ID of the billed Order.'},\n    \"transaction_id\": {'example': 'f2861560-e9ed-4463-955f-0c55c3b416fb',\n                       'description': 'Credit Card company transaction ID.'},\n}\n\ntags_metadata = [\n    {\n        \"name\": \"Payments\",\n        \"description\": f\"The ***{config.service_name}*** handle payments for the \"\n                       f\"following Credit Cards: `VISA`, `Mastercard`, `Eurocard`.\",", "        \"description\": f\"The ***{config.service_name}*** handle payments for the \"\n                       f\"following Credit Cards: `VISA`, `Mastercard`, `Eurocard`.\",\n    }\n]\n\nlicense_info = {\n    \"name\": \"License: Apache 2.0\",\n    \"url\": \"https://www.apache.org/licenses/LICENSE-2.0.html\",\n}\n", "}\n\nservers = [\n    {\n        \"url\": \"http://127.0.0.1:8001\",\n        \"description\": \"URL for local development and testing\"\n    },\n    {\n        \"url\": \"https://coffeemesh-staging.com\",\n        \"description\": \"staging server for testing purposes only\"", "        \"url\": \"https://coffeemesh-staging.com\",\n        \"description\": \"staging server for testing purposes only\"\n    },\n    {\n        \"url\": \"https://coffeemesh.com\",\n        \"description\": \"main production server\"\n    },\n]\n\ndescription = \"\"\"", "\ndescription = \"\"\"\n<img width=\"65%\" align=\"right\" src=\"/static/order_container_diagram.png\"/>\n**An example on how to use FastAPI and RabbitMQ to create a RESTful API for responses that takes some time to \nprocess.** \n\nThis service handles Customer Credit Card payments using external Credit Card Companies. Required payload is \n `PaymentPayload` and the response is `PaymentResponse`. Both schemas are described in detail under Schemas below.\n\n<br>**The following HTTP status codes are returned:**", "\n<br>**The following HTTP status codes are returned:**\n  * `200:` Successful Health response.\n  * `201:` Successful POST callback response.\n  * `202:` Successful POST response.\n  * `400:` Failed internal Microservice API call.\n  * `422:` Validation error, supplied payload is incorrect.\n  * `500:` Failed to connect to internal MicroService.\n  * `500:` Failed Health response.\n<br><br>", "  * `500:` Failed Health response.\n<br><br>\n---\n\"\"\"\n"]}
