{"filename": "rayen/constraint_module.py", "chunked_list": ["# --------------------------------------------------------------------------\n# Jesus Tordesillas Torres, Robotic Systems Lab, ETH Z\u00fcrich \n# See LICENSE file for the license information\n# -------------------------------------------------------------------------- \n\nimport torch\nimport torch.nn as nn\nfrom . import utils\nimport numpy as np\nimport cvxpy as cp", "import numpy as np\nimport cvxpy as cp\nimport math\nfrom cvxpylayers.torch import CvxpyLayer\nimport random\nimport copy\nimport time\n\nclass ConstraintModule(torch.nn.Module):\n\tdef __init__(self, cs, input_dim=None, method='RAYEN', create_map=True, args_DC3=None):\n\t\tsuper().__init__()\n\n\n\t\tself.method=method\n\n\t\tif(self.method=='Bar' and cs.has_quadratic_constraints):\n\t\t\traise Exception(f\"Method {self.method} cannot be used with quadratic constraints\")\n\n\t\tif(self.method=='DC3' and (cs.has_soc_constraints or cs.has_lmi_constraints)):\n\t\t\traise NotImplementedError\n\n\t\tif(self.method=='DC3'):\n\t\t\tutils.verify(args_DC3 is not None)\n\t\t\tself.args_DC3=args_DC3\n\n\t\tself.cs=cs\n\t\tself.k=cs.k #Dimension of the ambient space\n\t\tself.n=cs.n #Dimension of the embedded space\n\n\t\tD=cs.A_p/((cs.b_p-cs.A_p@cs.z0)@np.ones((1,cs.n)))\n\t\t\t\n\t\tall_P, all_q, all_r = utils.getAllPqrFromQcs(cs.qcs)\n\t\tall_M, all_s, all_c, all_d= utils.getAllMscdFromSocs(cs.socs)\n\n\t\tif(cs.has_lmi_constraints):\n\t\t\tall_F=copy.deepcopy(cs.lmic.all_F)\n\t\t\tH=all_F[-1]\n\t\t\tfor i in range(cs.lmic.dim()):\n\t\t\t\tH += cs.y0[i,0]*cs.lmic.all_F[i]\n\t\t\tHinv=np.linalg.inv(H)\n\t\t\tmHinv=-Hinv;\n\t\t\tL=np.linalg.cholesky(Hinv) # Hinv = L @ L^T \n\t\t\tself.register_buffer(\"mHinv\", torch.Tensor(mHinv))\n\t\t\tself.register_buffer(\"L\", torch.Tensor(L))\n\n\t\telse:\n\t\t\tall_F=[]\n\n\t\t#See https://discuss.pytorch.org/t/model-cuda-does-not-convert-all-variables-to-cuda/114733/9\n\t\t# and https://discuss.pytorch.org/t/keeping-constant-value-in-module-on-correct-device/10129\n\t\tself.register_buffer(\"D\", torch.Tensor(D))\n\t\tself.register_buffer(\"all_P\", torch.Tensor(np.array(all_P)))\n\t\tself.register_buffer(\"all_q\", torch.Tensor(np.array(all_q)))\n\t\tself.register_buffer(\"all_r\", torch.Tensor(np.array(all_r)))\n\t\tself.register_buffer(\"all_M\", torch.Tensor(np.array(all_M)))\n\t\tself.register_buffer(\"all_s\", torch.Tensor(np.array(all_s)))\n\t\tself.register_buffer(\"all_c\", torch.Tensor(np.array(all_c)))\n\t\tself.register_buffer(\"all_d\", torch.Tensor(np.array(all_d)))\n\t\t# self.register_buffer(\"all_F\", torch.Tensor(np.array(all_F))) #This one dies (probably because out of memory) when all_F contains more than 7000 matrices 500x500 approx\n\t\tself.register_buffer(\"all_F\", torch.Tensor(all_F))\n\t\tself.register_buffer(\"A_p\", torch.Tensor(cs.A_p))\n\t\tself.register_buffer(\"b_p\", torch.Tensor(cs.b_p))\n\t\tself.register_buffer(\"yp\", torch.Tensor(cs.yp))\n\t\tself.register_buffer(\"NA_E\", torch.Tensor(cs.NA_E))\n\t\tself.register_buffer(\"z0\", torch.Tensor(cs.z0))\n\t\tself.register_buffer(\"y0\", torch.Tensor(cs.y0))\n\n\t\tif(self.method=='PP' or self.method=='UP'):\n\t\t\t#Section 8.1.1 of https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf\n\t\t\tself.z_projected = cp.Variable((self.n,1))         #projected point\n\t\t\tself.z_to_be_projected = cp.Parameter((self.n,1))  #original point\n\t\t\tconstraints= self.cs.getConstraintsInSubspaceCvxpy(self.z_projected)\n\n\t\t\t#First option.\n\t\t\tobjective = cp.Minimize(cp.sum_squares(self.z_projected - self.z_to_be_projected))\n\n\t\t\t#Second option. Sometimes this may be preferred because of this: http://cvxr.com/cvx/doc/advanced.html#eliminating-quadratic-forms This may solve cases of (\"Solver ecos returned status Infeasible\" or \"Solver SCS returned status Infeasible\")\n\t\t\t# objective = cp.Minimize(cp.norm(self.z_projected - self.z_to_be_projected))\n\n\t\t\tself.prob_projection = cp.Problem(objective, constraints)\n\n\t\t\tassert self.prob_projection.is_dpp()\n\t\t\tself.proj_layer = CvxpyLayer(self.prob_projection, parameters=[self.z_to_be_projected], variables=[self.z_projected])\n\n\t\t\tif(self.cs.has_lmi_constraints):\n\t\t\t\tself.solver_projection='SCS' #slower, less accurate, supports LMI constraints\n\t\t\telse:\n\t\t\t\tself.solver_projection='ECOS' #fast, accurate, does not support LMI constraints\n\n\n\t\tif(self.method=='RAYEN' or self.method=='RAYEN_old'):\n\n\t\t\tif(cs.has_quadratic_constraints):\n\t\t\t\tall_delta=[]\n\t\t\t\tall_phi=[]\n\n\t\t\t\tfor i in range(self.all_P.shape[0]): #for each of the quadratic constraints\n\t\t\t\t\tP=self.all_P[i,:,:]\n\t\t\t\t\tq=self.all_q[i,:,:]\n\t\t\t\t\tr=self.all_r[i,:,:]\n\t\t\t\t\ty0=self.y0\n\n\t\t\t\t\tsigma=2*(0.5*y0.T@P@y0 + q.T@y0 + r)\n\t\t\t\t\tphi = -(y0.T@P + q.T)/sigma\n\t\t\t\t\tdelta= ( (y0.T@P + q.T).T@(y0.T@P + q.T) - 4*(0.5*y0.T@P@y0 + q.T@y0 + r)*0.5*P         )/torch.square(sigma)\n\n\t\t\t\t\tall_delta.append(delta)\n\t\t\t\t\tall_phi.append(phi)\n\n\t\t\t\tall_delta = torch.stack(all_delta)\n\t\t\t\tall_phi = torch.stack(all_phi)\n\n\t\t\t\tself.register_buffer(\"all_delta\", all_delta)\n\t\t\t\tself.register_buffer(\"all_phi\", all_phi)\n\n\t\tif(self.method=='Bar'):\n\t\t\tprint(\"Computing vertices and rays...\")\n\t\t\tV, R = utils.H_to_V(cs.A_p, cs.b_p);\n\t\t\tself.register_buffer(\"V\", torch.Tensor(V))\n\t\t\tself.register_buffer(\"R\", torch.Tensor(R))\n\t\t\tself.num_vertices=self.V.shape[1];\n\t\t\tself.num_rays=self.R.shape[1];\n\t\t\tassert (self.num_vertices+self.num_rays)>0\n\t\t\tprint(f\"Found {self.num_vertices} vertices and {self.num_rays} rays\")\n\n\t\tif(self.method=='DC3'):\n\n\t\t\tA2_DC3, b2_DC3=utils.removeRedundantEquationsFromEqualitySystem(cs.A_E, cs.b_E) \n\n\t\t\tself.register_buffer(\"A2_DC3\", torch.Tensor(A2_DC3))\n\t\t\tself.register_buffer(\"b2_DC3\", torch.Tensor(b2_DC3))\n\t\t\tself.register_buffer(\"A1_DC3\", torch.Tensor(cs.A_I))\n\t\t\tself.register_buffer(\"b1_DC3\", torch.Tensor(cs.b_I))\n\n\t\t\t#Constraints are now \n\t\t\t# A2_DC3 y = b2_DC3\n\t\t\t# A1_DC3 y <= b1_DC3\n\n\t\t\tself.neq_DC3 = self.A2_DC3.shape[0]\n\n\t\t\t#################################### Find partial_vars and other_vars\n\n\t\t\tif(A2_DC3.shape[0]==0): #There are no equality constraints\n\t\t\t\tself.partial_vars=np.arange(self.k)\n\t\t\t\tself.other_vars=np.setdiff1d( np.arange(self.k), self.partial_vars)\n\t\t\telse:\n\t\t\t\t# This is a more efficient way to do https://github.com/locuslab/DC3/blob/35437af7f22390e4ed032d9eef90cc525764d26f/utils.py#L67\n\t\t\t\t# Here, we follow  https://stackoverflow.com/a/27907936\n\t\t\t\t(A2_DC3_rref, pivots_pos, row_exchanges) = utils.rref(A2_DC3);\n\t\t\t\tself.other_vars = [i[1] for i in pivots_pos];\n\t\t\t\tself.partial_vars = np.setdiff1d( np.arange(self.k), self.other_vars)\n\n\t\t\t#######################################################\n\n\t\t\tA2p = self.A2_DC3[:, self.partial_vars]\n\t\t\tA2o = self.A2_DC3[:, self.other_vars]\n\n\t\t\t# assert np.linalg.matrix_rank(A2_DC3) == np.linalg.matrix_rank(A2o) == A2o.shape[-1]\n\n\t\t\tA2oi = torch.inverse(A2o)\t\t\t\n\n\t\t\t####################################################\n\t\t\t####################################################\n\n\t\t\tA1p=self.A1_DC3[:, self.partial_vars];\n\t\t\tA1o=self.A1_DC3[:, self.other_vars];\n\n\t\t\tA1_effective = A1p - A1o @ (A2oi @ A2p)\n\t\t\tb1_effective = self.b1_DC3 - A1o @ A2oi @ self.b2_DC3;\n\n\t\t\tall_P_effective=torch.Tensor(self.all_P.shape[0], len(self.partial_vars), len(self.partial_vars) )\n\t\t\tall_q_effective=torch.Tensor(self.all_q.shape[0], len(self.partial_vars), 1 )\n\t\t\tall_r_effective=torch.Tensor(self.all_q.shape[0], 1, 1 )\n\n\t\t\tself.register_buffer(\"A2oi\", A2oi)\n\t\t\tself.register_buffer(\"A2p\", A2p)\n\t\t\tself.register_buffer(\"A1_effective\", A1_effective)\n\t\t\tself.register_buffer(\"b1_effective\", b1_effective)\n\n\t\t\t####################\n\t\t\tfor i in range(self.all_P.shape[0]): #for each of the quadratic constraints\n\t\t\t\tP=self.all_P[i,:,:]\n\t\t\t\tq=self.all_q[i,:,:]\n\t\t\t\tr=self.all_r[i,:,:]\n\n\t\t\t\tPo=P[np.ix_(self.other_vars,self.other_vars)].view(len(self.other_vars),len(self.other_vars))\n\t\t\t\tPp=P[np.ix_(self.partial_vars,self.partial_vars)].view(len(self.partial_vars),len(self.partial_vars))\n\t\t\t\tPop=P[np.ix_(self.other_vars,self.partial_vars)].view(len(self.other_vars),len(self.partial_vars))\n\n\t\t\t\tqo=q[self.other_vars,0:1]\n\t\t\t\tqp=q[self.partial_vars,0:1]\n\n\t\t\t\tb2=self.b2_DC3\n\n\t\t\t\tP_effective=2*(-A2p.T@A2oi.T@Pop + 0.5*A2p.T@A2oi.T@Po@A2oi@A2p + 0.5*Pp)\n\t\t\t\tq_effective=(b2.T@A2oi.T@Pop + qp.T - qo.T@A2oi@A2p - b2.T@A2oi.T@Po@A2oi@A2p).T\n\t\t\t\tr_effective=qo.T@A2oi@b2 + 0.5*b2.T@A2oi.T@Po@A2oi@b2 + r\n\n\t\t\t\t###### QUICK CHECK\n\t\t\t\t# tmp=random.randint(1, 100) #number of elements in the batch\n\t\t\t\t# yp=torch.rand(tmp, len(self.partial_vars), 1) \n\n\t\t\t\t# y = torch.zeros((tmp, self.k, 1))\n\t\t\t\t# y[:, self.partial_vars, :] = yp\n\t\t\t\t# y[:, self.other_vars, :] = self.obtainyoFromypDC3(yp)\n\n\t\t\t\t# using_effective=utils.quadExpression(yp, P_effective, q_effective, r_effective)\n\t\t\t\t# using_original=utils.quadExpression(y, P, q, r)\n\n\t\t\t\t# assert torch.allclose(using_effective, using_original, atol=1e-05) \n\n\t\t\t\t###################\n\n\t\t\t\tall_P_effective[i,:,:]=P_effective\n\t\t\t\tall_q_effective[i,:,:]=q_effective\n\t\t\t\tall_r_effective[i,:,:]=r_effective\n\n\t\t\tself.register_buffer(\"all_P_effective\", all_P_effective)\n\t\t\tself.register_buffer(\"all_q_effective\", all_q_effective)\n\t\t\tself.register_buffer(\"all_r_effective\", all_r_effective)\n\n\t\t\t####################################################\n\t\t\t####################################################\n\n\n\t\tif(self.method=='RAYEN_old'):\n\t\t\tself.forwardForMethod=self.forwardForRAYENOld\n\t\t\tself.dim_after_map=(self.n+1)\n\t\telif(self.method=='RAYEN'):\n\t\t\tself.forwardForMethod=self.forwardForRAYEN\n\t\t\tself.dim_after_map=self.n\n\t\telif(self.method=='UU'):\n\t\t\tself.forwardForMethod=self.forwardForUU\n\t\t\tself.dim_after_map=self.k\n\t\telif(self.method=='Bar'):\n\t\t\tself.forwardForMethod=self.forwardForBar\n\t\t\tself.dim_after_map=(self.num_vertices + self.num_rays)\n\t\telif(self.method=='PP'):\n\t\t\tself.forwardForMethod=self.forwardForPP\n\t\t\tself.dim_after_map=(self.n)\n\t\telif(self.method=='UP'):\n\t\t\tself.forwardForMethod=self.forwardForUP\n\t\t\tself.dim_after_map=(self.n)\n\t\telif(self.method=='DC3'):\n\t\t\tself.forwardForMethod=self.forwardForDC3\n\t\t\tself.dim_after_map=(self.k - self.neq_DC3)\n\t\t\tassert (self.dim_after_map==self.n)\n\t\telse:\n\t\t\traise NotImplementedError\n\n\t\tif(create_map):\n\t\t\tutils.verify(input_dim is not None, \"input_dim needs to be provided\")\n\t\t\tself.mapper=nn.Linear(input_dim, self.dim_after_map);\n\t\telse:\n\t\t\tself.mapper=nn.Sequential(); #Mapper does nothing\n\n\tdef obtainyoFromypDC3(self, yp):\n\t\treturn self.A2oi @ (self.b2_DC3 - self.A2p @ yp)\n\n\n\tdef forwardForDC3(self, q):\n\t\t\n\t\t#### Complete partial\n\t\ty = torch.zeros((q.shape[0], self.k, 1), device=q.device)\n\t\ty[:, self.partial_vars, :] = q\n\t\ty[:, self.other_vars, :] = self.obtainyoFromypDC3(q)\n\n\t\t#### Grad steps all\n\n\t\ty_new = y\n\t\tstep_index = 0\n\t\told_y_step = 0\n\n\t\tif(self.training):\n\t\t\tmax_steps=self.args_DC3['max_steps_training'] #This is called corrTrainSteps in DC3 original code\n\t\telse:\n\t\t\tmax_steps=self.args_DC3['max_steps_testing'] #float(\"inf\") #This is called corrTestMaxSteps in DC3 original code\n\n\t\twhile True:\n\n\t\t\t################################################\n\t\t\t################################################ COMPUTE y_step\n\n\t\t\typ=y_new[:, self.partial_vars,:]\n\t\t\typT=torch.transpose(yp,1,2);\n\n\t\t\tgrad = 2 * self.A1_effective.T @ torch.relu(self.A1_effective@yp - self.b1_effective)\n\n\t\t\tfor i in range(self.all_P_effective.shape[0]): #for each of the quadratic constraints\n\t\t\t\tP_effective=self.all_P_effective[i,:,:]\n\t\t\t\tq_effective=self.all_q_effective[i,:,:]\n\t\t\t\tr_effective=self.all_r_effective[i,:,:]\n\n\t\t\t\ttmp1=(P_effective@yp + q_effective)\n\t\t\t\ttmp2=torch.relu(utils.quadExpression(yp, P_effective, q_effective, r_effective))\n\n\t\t\t\tgrad += 2*tmp1@tmp2 #The 2 is because of the squared norm\n\n\t\t\ty_step = torch.zeros_like(y)\n\t\t\ty_step[:, self.partial_vars, :] = grad\n\t\t\ty_step[:, self.other_vars, :] = - self.A2oi @ self.A2p @ grad\n\t\t\t################################################\n\t\t\t################################################\n\t\t\t\n\t\t\tnew_y_step = self.args_DC3['lr'] * y_step + self.args_DC3['momentum'] * old_y_step\n\t\t\ty_new = y_new - new_y_step\n\t\t\told_y_step = new_y_step\n\t\t\tstep_index += 1\n\n\t\t\t################################################\n\t\t\t################################################ COMPUTE current violation\n\t\t\tstacked=self.A1_DC3@y_new - self.b1_DC3\n\t\t\tfor i in range(self.all_P.shape[0]): #for each of the quadratic constraints\n\t\t\t\tstacked=torch.cat((stacked,utils.quadExpression(y_new, self.all_P[i,:,:], self.all_q[i,:,:], self.all_r[i,:,:])), dim=1)\n\t\t\tviolation=torch.max(torch.relu(stacked))\n\t\t\t################################################\n\t\t\t################################################\n\n\t\t\tconverged_ineq = (violation < self.args_DC3['eps_converge'])\n\t\t\tmax_iter_reached = (step_index >= max_steps)\n\n\t\t\tif(max_iter_reached):\n\t\t\t\tbreak\n\n\t\t\tif(converged_ineq):\n\t\t\t\tbreak\n\n\t\treturn y_new\n\n\n\tdef solveSecondOrderEq(self, a, b, c, is_quad_constraint):\n\t\tdiscriminant = torch.square(b) - 4*(a)*(c)\n\n\t\tassert torch.all(discriminant >= 0), f\"Smallest element is {torch.min(discriminant)}\"\n\t\tsol1=torch.div(  -(b)  - torch.sqrt(discriminant) , 2*a)  #note that for quad constraints the positive solution has the minus: (... - sqrt(...))/(...)\n\t\tif(is_quad_constraint):\n\t\t\treturn sol1\n\t\telse:\n\t\t\tsol2=torch.div(  -(b)  +  torch.sqrt(discriminant) , 2*a) \n\t\t\treturn torch.relu(torch.maximum(sol1, sol2))\n\n\n\tdef computeKappa(self,v_bar):\n\n\t\tkappa=torch.relu( torch.max(self.D@v_bar, dim=1, keepdim=True).values  )\n\n\t\tif(len(self.all_P)>0 or len(self.all_M)>0 or len(self.all_F)>0):\n\t\t\trho = self.NA_E@v_bar\n\t\t\trhoT=torch.transpose(rho,dim0=1, dim1=2)\n\t\t\tall_kappas_positives=torch.empty((v_bar.shape[0],0,1), device=v_bar.device)\n\n\t\t\tfor i in range(self.all_P.shape[0]): #for each of the quadratic constraints\n\n\t\t\t\t#FIRST WAY (slower, easier to understand)\n\t\t\t\t# P=self.all_P[i,:,:]\n\t\t\t\t# q=self.all_q[i,:,:]\n\t\t\t\t# r=self.all_r[i,:,:]\n\t\t\t\t\n\t\t\t\t# c_prime=0.5*rhoT@P@rho;\n\t\t\t\t# b_prime=(self.y0.T@P+ q.T)@rho;\n\t\t\t\t# a_prime=(0.5*self.y0.T@P@self.y0 + q.T@self.y0 +r) \n\n\t\t\t\t# kappa_positive_i_first_way=self.solveSecondOrderEq(a_prime, b_prime, c_prime, True) \n\n\t\t\t\t#SECOND WAY (faster)\n\t\t\t\tkappa_positive_i = self.all_phi[i,:,:]@rho + torch.sqrt(rhoT@self.all_delta[i,:,:]@rho)\n\n\n\t\t\t\t# assert torch.allclose(kappa_positive_i,kappa_positive_i_first_way, atol=1e-06), f\"{torch.max(torch.abs(kappa_positive_i-kappa_positive_i_first_way))}\"\n\n\n\t\t\t\tassert torch.all(kappa_positive_i >= 0), f\"Smallest element is {kappa_positive_i}\" #If not, then Z may not be feasible (note that z0 is in the interior of Z)\n\t\t\t\tall_kappas_positives = torch.cat((all_kappas_positives, kappa_positive_i), dim=1)\n\n\t\t\tfor i in range(self.all_M.shape[0]): #for each of the SOC constraints\n\t\t\t\tM=self.all_M[i,:,:]\n\t\t\t\ts=self.all_s[i,:,:]\n\t\t\t\tc=self.all_c[i,:,:]\n\t\t\t\td=self.all_d[i,:,:]\n\n\t\t\t\tbeta=M@self.y0+s\n\t\t\t\ttau=c.T@self.y0+d\n\n\t\t\t\tc_prime=rhoT@M.T@M@rho - torch.square(c.T@rho)\n\t\t\t\tb_prime=2*rhoT@M.T@beta - 2*(c.T@rho)@tau\n\t\t\t\ta_prime=beta.T@beta - torch.square(tau)\n\n\t\t\t\tkappa_positive_i=self.solveSecondOrderEq(a_prime, b_prime, c_prime, False)\n\n\t\t\t\tassert torch.all(kappa_positive_i >= 0) #If not, then either the feasible set is infeasible (note that z0 is inside the feasible set)\n\t\t\t\tall_kappas_positives = torch.cat((all_kappas_positives, kappa_positive_i), dim=1)\n\n\t\t\tif(len(self.all_F)>0): #If there are LMI constraints:\n\n\t\t\t\t############# OBTAIN S\n\t\t\t\t# First option (much slower)\n\t\t\t\t# S=self.all_F[0,:,:]*rho[:,0:(0+1),0:1]\n\t\t\t\t# for i in range(1,len(self.all_F)-1):\n\t\t\t\t# \t#See https://discuss.pytorch.org/t/scalar-matrix-multiplication-for-a-tensor-and-an-array-of-scalars/100174/2\t\n\t\t\t\t# \tS += self.all_F[i,:,:]*rho[:,i:(i+1),0:1] \n\n\n\t\t\t\t# Second option (much faster)\n\t\t\t\tS=torch.einsum('ajk,ial->ijk', [self.all_F[0:-1,:,:], rho]) #See the tutorial https://rockt.github.io/2018/04/30/einsum\n\t\t\t\t\n\t\t\t\t############# COMPUTE THE EIGENVALUES\n\n\t\t\t\t## Option 1: (compute whole spectrum of the matrix, using the non-symmetric matrix self.mHinv@S)\n\t\t\t\t# eigenvalues = torch.unsqueeze(torch.linalg.eigvals(self.mHinv@S),2) #Note that mHinv@M is not symmetric but always have real eigenvalues\n\t\t\t\t# assert (torch.all(torch.isreal(eigenvalues)))\n\t\t\t\t# largest_eigenvalue = torch.max(eigenvalues.real, dim=1, keepdim=True).values \n\t\t\t\t\n\t\t\t\tLTmSL=self.L.T @ (-S) @ self.L #This matrix is symmetric\n\n\t\t\t\t## Option 2: (compute whole spectrum of the matrix, using the symmetric matrix LTmSL). Much faster than Option 1\n\t\t\t\teigenvalues = torch.unsqueeze(torch.linalg.eigvalsh(LTmSL),2) #Note that L^T (-S) L is a symmetric matrix\n\t\t\t\tlargest_eigenvalue = torch.max(eigenvalues, dim=1, keepdim=True).values \n\n\t\t\t\t## Option 3: Use LOBPCG with A=LTmSL and B=I. The advantage of this method is that only the largest eigenvalue is computed. But, empirically, this option is faster than option 2 only for very big matrices (>1000x1000)\n\t\t\t\t# guess_lobpcg=torch.rand(1, H.shape[0], 1);\n\t\t\t\t# size_batch=v_bar.shape[0]\n\t\t\t\t# largest_eigenvalue, _ = torch.lobpcg(A=LTmSL, k=1, B=None, niter=-1) #, X=guess_lobpcg.expand(size_batch, -1, -1)\n\t\t\t\t# largest_eigenvalue=torch.unsqueeze(largest_eigenvalue, 1)\n\n\t\t\t\t## Option 4: Use power iteration to compute the largest eigenvalue. Often times is slower than just computing the whole spectrum, and sometimes it does not converge\n\t\t\t\t# guess_v = torch.nn.functional.normalize(torch.rand(S.shape[1],1), dim=0)\n\t\t\t\t# largest_eigenvalue=utils.findLargestEigenvalueUsingPowerIteration(self.mHinv@S, guess_v)\n\n\n\t\t\t\t## Option 5: Use LOBPCG with A=-S and B=H. There are two problems though:\n\t\t\t\t# --> This issue: https://github.com/pytorch/pytorch/issues/101075\n\t\t\t\t# --> Backward is not implemented for B!=I, see: https://github.com/pytorch/pytorch/blob/d54fcd571af48685b0699f6ac1e31b6871d0d768/torch/_lobpcg.py#L329 \n\n\t\t\t\t## Option 6: Use https://github.com/rfeinman/Torch-ARPACK with LTmSL. The problem is that backward() is not implemented yet \n\n\t\t\t\t## Option 7: Use https://github.com/buwantaiji/DominantSparseEigenAD. But it does not have support for batched matrices, see https://github.com/buwantaiji/DominantSparseEigenAD/issues/1\n\n\t\t\t\tkappa_positive_i = torch.relu( largest_eigenvalue )\n\n\t\t\t\t\n\t\t\t\tall_kappas_positives = torch.cat((all_kappas_positives, kappa_positive_i), dim=1)\n\n\n\t\t\tkappa_nonlinear_constraints=(torch.max(all_kappas_positives, dim=1, keepdim=True).values)\n\t\t\tkappa = torch.maximum(kappa, kappa_nonlinear_constraints)\n\n\n\t\tassert torch.all(kappa >= 0)\n\n\t\treturn kappa\n\n\tdef forwardForRAYENOld(self, q):\n\t\tv = q[:,  0:self.n,0:1]\n\t\tv_bar=torch.nn.functional.normalize(v, dim=1)\n\t\tkappa=self.computeKappa(v_bar)\n\t\tbeta= q[:, self.n:(self.n+1),0:1]\n\t\talpha=1/(torch.exp(beta) + kappa) \n\t\treturn self.getyFromz(self.z0 + alpha*v_bar)\n\n\tdef forwardForRAYEN(self, q):\n\t\tv = q[:,  0:self.n,0:1]\n\t\tv_bar=torch.nn.functional.normalize(v, dim=1)\n\t\tkappa=self.computeKappa(v_bar)\n\t\tnorm_v=torch.linalg.vector_norm(v, dim=(1,2), keepdim=True)\n\t\talpha=torch.minimum( 1/kappa , norm_v )\n\t\treturn self.getyFromz(self.z0 + alpha*v_bar)\n\n\tdef forwardForUU(self, q):\n\t\treturn q\n\n\tdef forwardForBar(self, q):\n\t\ttmp1 = q[:,  0:self.num_vertices,0:1] #0:1 to keep the dimension. \n\t\ttmp2 = q[:,  self.num_vertices:(self.num_vertices+self.num_rays),0:1] #0:1 to keep the dimension. \n\t\t\n\t\tlambdas=nn.functional.softmax(tmp1, dim=1)\n\t\tmus=torch.abs(tmp2)\n\n\t\treturn self.getyFromz(self.V@lambdas + self.R@mus)\n\n\tdef project(self, q):\n\t\t#If you use ECOS, you can set solver_args={'eps': 1e-6} (or smaller) for better solutions, see https://github.com/cvxpy/cvxpy/issues/880#issuecomment-557278620\n\t\tz, = self.proj_layer(q, solver_args={'solve_method':self.solver_projection}) # \"max_iters\": 10000\n\t\treturn z\n\n\tdef forwardForPP(self, q):\n\t\tz=self.project(q)\n\t\treturn self.getyFromz(z)\n\n\n\tdef forwardForUP(self, q):\n\t\tif(self.training==False):\n\t\t\tz=self.project(q)\n\t\telse:\n\t\t\tz = q\n\n\t\treturn self.getyFromz(z)\n\n\tdef getDimAfterMap(self):\n\t\treturn self.dim_after_map\n\n\tdef gety0(self):\n\t\treturn self.getyFromz(self.z0)\n\n\tdef getyFromz(self, z):\n\t\ty=self.NA_E@z + self.yp\n\t\treturn y\n\n\tdef getzFromy(self, y):\n\t\tz=self.NA_E.T@(y - self.yp)\n\t\treturn z\n\n\tdef forward(self, x):\n\n\t\t##################  MAPPER LAYER ####################\n\t\t#nsib denotes the number of samples in the batch\n\t\t# x has dimensions [nsib, numel_input_mapper, 1]. nsib is the number of samples in the batch (i.e., x.shape[0]=x.shape[0])\n\t\tq = self.mapper(x.view(x.size(0), -1)) #After this, q has dimensions [nsib, numel_output_mapper]\n\t\tq = torch.unsqueeze(q,dim=2)  #After this, q has dimensions [nsib, numel_output_mapper, 1]\n\t\t####################################################\n\n\t\ty=self.forwardForMethod(q)\n\n\t\tassert (torch.isnan(y).any())==False, f\"If you are using DC3, try reducing args_DC3[lr]. Right now it's {self.args_DC3['lr']}\"\n\n\t\treturn y", "class ConstraintModule(torch.nn.Module):\n\tdef __init__(self, cs, input_dim=None, method='RAYEN', create_map=True, args_DC3=None):\n\t\tsuper().__init__()\n\n\n\t\tself.method=method\n\n\t\tif(self.method=='Bar' and cs.has_quadratic_constraints):\n\t\t\traise Exception(f\"Method {self.method} cannot be used with quadratic constraints\")\n\n\t\tif(self.method=='DC3' and (cs.has_soc_constraints or cs.has_lmi_constraints)):\n\t\t\traise NotImplementedError\n\n\t\tif(self.method=='DC3'):\n\t\t\tutils.verify(args_DC3 is not None)\n\t\t\tself.args_DC3=args_DC3\n\n\t\tself.cs=cs\n\t\tself.k=cs.k #Dimension of the ambient space\n\t\tself.n=cs.n #Dimension of the embedded space\n\n\t\tD=cs.A_p/((cs.b_p-cs.A_p@cs.z0)@np.ones((1,cs.n)))\n\t\t\t\n\t\tall_P, all_q, all_r = utils.getAllPqrFromQcs(cs.qcs)\n\t\tall_M, all_s, all_c, all_d= utils.getAllMscdFromSocs(cs.socs)\n\n\t\tif(cs.has_lmi_constraints):\n\t\t\tall_F=copy.deepcopy(cs.lmic.all_F)\n\t\t\tH=all_F[-1]\n\t\t\tfor i in range(cs.lmic.dim()):\n\t\t\t\tH += cs.y0[i,0]*cs.lmic.all_F[i]\n\t\t\tHinv=np.linalg.inv(H)\n\t\t\tmHinv=-Hinv;\n\t\t\tL=np.linalg.cholesky(Hinv) # Hinv = L @ L^T \n\t\t\tself.register_buffer(\"mHinv\", torch.Tensor(mHinv))\n\t\t\tself.register_buffer(\"L\", torch.Tensor(L))\n\n\t\telse:\n\t\t\tall_F=[]\n\n\t\t#See https://discuss.pytorch.org/t/model-cuda-does-not-convert-all-variables-to-cuda/114733/9\n\t\t# and https://discuss.pytorch.org/t/keeping-constant-value-in-module-on-correct-device/10129\n\t\tself.register_buffer(\"D\", torch.Tensor(D))\n\t\tself.register_buffer(\"all_P\", torch.Tensor(np.array(all_P)))\n\t\tself.register_buffer(\"all_q\", torch.Tensor(np.array(all_q)))\n\t\tself.register_buffer(\"all_r\", torch.Tensor(np.array(all_r)))\n\t\tself.register_buffer(\"all_M\", torch.Tensor(np.array(all_M)))\n\t\tself.register_buffer(\"all_s\", torch.Tensor(np.array(all_s)))\n\t\tself.register_buffer(\"all_c\", torch.Tensor(np.array(all_c)))\n\t\tself.register_buffer(\"all_d\", torch.Tensor(np.array(all_d)))\n\t\t# self.register_buffer(\"all_F\", torch.Tensor(np.array(all_F))) #This one dies (probably because out of memory) when all_F contains more than 7000 matrices 500x500 approx\n\t\tself.register_buffer(\"all_F\", torch.Tensor(all_F))\n\t\tself.register_buffer(\"A_p\", torch.Tensor(cs.A_p))\n\t\tself.register_buffer(\"b_p\", torch.Tensor(cs.b_p))\n\t\tself.register_buffer(\"yp\", torch.Tensor(cs.yp))\n\t\tself.register_buffer(\"NA_E\", torch.Tensor(cs.NA_E))\n\t\tself.register_buffer(\"z0\", torch.Tensor(cs.z0))\n\t\tself.register_buffer(\"y0\", torch.Tensor(cs.y0))\n\n\t\tif(self.method=='PP' or self.method=='UP'):\n\t\t\t#Section 8.1.1 of https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf\n\t\t\tself.z_projected = cp.Variable((self.n,1))         #projected point\n\t\t\tself.z_to_be_projected = cp.Parameter((self.n,1))  #original point\n\t\t\tconstraints= self.cs.getConstraintsInSubspaceCvxpy(self.z_projected)\n\n\t\t\t#First option.\n\t\t\tobjective = cp.Minimize(cp.sum_squares(self.z_projected - self.z_to_be_projected))\n\n\t\t\t#Second option. Sometimes this may be preferred because of this: http://cvxr.com/cvx/doc/advanced.html#eliminating-quadratic-forms This may solve cases of (\"Solver ecos returned status Infeasible\" or \"Solver SCS returned status Infeasible\")\n\t\t\t# objective = cp.Minimize(cp.norm(self.z_projected - self.z_to_be_projected))\n\n\t\t\tself.prob_projection = cp.Problem(objective, constraints)\n\n\t\t\tassert self.prob_projection.is_dpp()\n\t\t\tself.proj_layer = CvxpyLayer(self.prob_projection, parameters=[self.z_to_be_projected], variables=[self.z_projected])\n\n\t\t\tif(self.cs.has_lmi_constraints):\n\t\t\t\tself.solver_projection='SCS' #slower, less accurate, supports LMI constraints\n\t\t\telse:\n\t\t\t\tself.solver_projection='ECOS' #fast, accurate, does not support LMI constraints\n\n\n\t\tif(self.method=='RAYEN' or self.method=='RAYEN_old'):\n\n\t\t\tif(cs.has_quadratic_constraints):\n\t\t\t\tall_delta=[]\n\t\t\t\tall_phi=[]\n\n\t\t\t\tfor i in range(self.all_P.shape[0]): #for each of the quadratic constraints\n\t\t\t\t\tP=self.all_P[i,:,:]\n\t\t\t\t\tq=self.all_q[i,:,:]\n\t\t\t\t\tr=self.all_r[i,:,:]\n\t\t\t\t\ty0=self.y0\n\n\t\t\t\t\tsigma=2*(0.5*y0.T@P@y0 + q.T@y0 + r)\n\t\t\t\t\tphi = -(y0.T@P + q.T)/sigma\n\t\t\t\t\tdelta= ( (y0.T@P + q.T).T@(y0.T@P + q.T) - 4*(0.5*y0.T@P@y0 + q.T@y0 + r)*0.5*P         )/torch.square(sigma)\n\n\t\t\t\t\tall_delta.append(delta)\n\t\t\t\t\tall_phi.append(phi)\n\n\t\t\t\tall_delta = torch.stack(all_delta)\n\t\t\t\tall_phi = torch.stack(all_phi)\n\n\t\t\t\tself.register_buffer(\"all_delta\", all_delta)\n\t\t\t\tself.register_buffer(\"all_phi\", all_phi)\n\n\t\tif(self.method=='Bar'):\n\t\t\tprint(\"Computing vertices and rays...\")\n\t\t\tV, R = utils.H_to_V(cs.A_p, cs.b_p);\n\t\t\tself.register_buffer(\"V\", torch.Tensor(V))\n\t\t\tself.register_buffer(\"R\", torch.Tensor(R))\n\t\t\tself.num_vertices=self.V.shape[1];\n\t\t\tself.num_rays=self.R.shape[1];\n\t\t\tassert (self.num_vertices+self.num_rays)>0\n\t\t\tprint(f\"Found {self.num_vertices} vertices and {self.num_rays} rays\")\n\n\t\tif(self.method=='DC3'):\n\n\t\t\tA2_DC3, b2_DC3=utils.removeRedundantEquationsFromEqualitySystem(cs.A_E, cs.b_E) \n\n\t\t\tself.register_buffer(\"A2_DC3\", torch.Tensor(A2_DC3))\n\t\t\tself.register_buffer(\"b2_DC3\", torch.Tensor(b2_DC3))\n\t\t\tself.register_buffer(\"A1_DC3\", torch.Tensor(cs.A_I))\n\t\t\tself.register_buffer(\"b1_DC3\", torch.Tensor(cs.b_I))\n\n\t\t\t#Constraints are now \n\t\t\t# A2_DC3 y = b2_DC3\n\t\t\t# A1_DC3 y <= b1_DC3\n\n\t\t\tself.neq_DC3 = self.A2_DC3.shape[0]\n\n\t\t\t#################################### Find partial_vars and other_vars\n\n\t\t\tif(A2_DC3.shape[0]==0): #There are no equality constraints\n\t\t\t\tself.partial_vars=np.arange(self.k)\n\t\t\t\tself.other_vars=np.setdiff1d( np.arange(self.k), self.partial_vars)\n\t\t\telse:\n\t\t\t\t# This is a more efficient way to do https://github.com/locuslab/DC3/blob/35437af7f22390e4ed032d9eef90cc525764d26f/utils.py#L67\n\t\t\t\t# Here, we follow  https://stackoverflow.com/a/27907936\n\t\t\t\t(A2_DC3_rref, pivots_pos, row_exchanges) = utils.rref(A2_DC3);\n\t\t\t\tself.other_vars = [i[1] for i in pivots_pos];\n\t\t\t\tself.partial_vars = np.setdiff1d( np.arange(self.k), self.other_vars)\n\n\t\t\t#######################################################\n\n\t\t\tA2p = self.A2_DC3[:, self.partial_vars]\n\t\t\tA2o = self.A2_DC3[:, self.other_vars]\n\n\t\t\t# assert np.linalg.matrix_rank(A2_DC3) == np.linalg.matrix_rank(A2o) == A2o.shape[-1]\n\n\t\t\tA2oi = torch.inverse(A2o)\t\t\t\n\n\t\t\t####################################################\n\t\t\t####################################################\n\n\t\t\tA1p=self.A1_DC3[:, self.partial_vars];\n\t\t\tA1o=self.A1_DC3[:, self.other_vars];\n\n\t\t\tA1_effective = A1p - A1o @ (A2oi @ A2p)\n\t\t\tb1_effective = self.b1_DC3 - A1o @ A2oi @ self.b2_DC3;\n\n\t\t\tall_P_effective=torch.Tensor(self.all_P.shape[0], len(self.partial_vars), len(self.partial_vars) )\n\t\t\tall_q_effective=torch.Tensor(self.all_q.shape[0], len(self.partial_vars), 1 )\n\t\t\tall_r_effective=torch.Tensor(self.all_q.shape[0], 1, 1 )\n\n\t\t\tself.register_buffer(\"A2oi\", A2oi)\n\t\t\tself.register_buffer(\"A2p\", A2p)\n\t\t\tself.register_buffer(\"A1_effective\", A1_effective)\n\t\t\tself.register_buffer(\"b1_effective\", b1_effective)\n\n\t\t\t####################\n\t\t\tfor i in range(self.all_P.shape[0]): #for each of the quadratic constraints\n\t\t\t\tP=self.all_P[i,:,:]\n\t\t\t\tq=self.all_q[i,:,:]\n\t\t\t\tr=self.all_r[i,:,:]\n\n\t\t\t\tPo=P[np.ix_(self.other_vars,self.other_vars)].view(len(self.other_vars),len(self.other_vars))\n\t\t\t\tPp=P[np.ix_(self.partial_vars,self.partial_vars)].view(len(self.partial_vars),len(self.partial_vars))\n\t\t\t\tPop=P[np.ix_(self.other_vars,self.partial_vars)].view(len(self.other_vars),len(self.partial_vars))\n\n\t\t\t\tqo=q[self.other_vars,0:1]\n\t\t\t\tqp=q[self.partial_vars,0:1]\n\n\t\t\t\tb2=self.b2_DC3\n\n\t\t\t\tP_effective=2*(-A2p.T@A2oi.T@Pop + 0.5*A2p.T@A2oi.T@Po@A2oi@A2p + 0.5*Pp)\n\t\t\t\tq_effective=(b2.T@A2oi.T@Pop + qp.T - qo.T@A2oi@A2p - b2.T@A2oi.T@Po@A2oi@A2p).T\n\t\t\t\tr_effective=qo.T@A2oi@b2 + 0.5*b2.T@A2oi.T@Po@A2oi@b2 + r\n\n\t\t\t\t###### QUICK CHECK\n\t\t\t\t# tmp=random.randint(1, 100) #number of elements in the batch\n\t\t\t\t# yp=torch.rand(tmp, len(self.partial_vars), 1) \n\n\t\t\t\t# y = torch.zeros((tmp, self.k, 1))\n\t\t\t\t# y[:, self.partial_vars, :] = yp\n\t\t\t\t# y[:, self.other_vars, :] = self.obtainyoFromypDC3(yp)\n\n\t\t\t\t# using_effective=utils.quadExpression(yp, P_effective, q_effective, r_effective)\n\t\t\t\t# using_original=utils.quadExpression(y, P, q, r)\n\n\t\t\t\t# assert torch.allclose(using_effective, using_original, atol=1e-05) \n\n\t\t\t\t###################\n\n\t\t\t\tall_P_effective[i,:,:]=P_effective\n\t\t\t\tall_q_effective[i,:,:]=q_effective\n\t\t\t\tall_r_effective[i,:,:]=r_effective\n\n\t\t\tself.register_buffer(\"all_P_effective\", all_P_effective)\n\t\t\tself.register_buffer(\"all_q_effective\", all_q_effective)\n\t\t\tself.register_buffer(\"all_r_effective\", all_r_effective)\n\n\t\t\t####################################################\n\t\t\t####################################################\n\n\n\t\tif(self.method=='RAYEN_old'):\n\t\t\tself.forwardForMethod=self.forwardForRAYENOld\n\t\t\tself.dim_after_map=(self.n+1)\n\t\telif(self.method=='RAYEN'):\n\t\t\tself.forwardForMethod=self.forwardForRAYEN\n\t\t\tself.dim_after_map=self.n\n\t\telif(self.method=='UU'):\n\t\t\tself.forwardForMethod=self.forwardForUU\n\t\t\tself.dim_after_map=self.k\n\t\telif(self.method=='Bar'):\n\t\t\tself.forwardForMethod=self.forwardForBar\n\t\t\tself.dim_after_map=(self.num_vertices + self.num_rays)\n\t\telif(self.method=='PP'):\n\t\t\tself.forwardForMethod=self.forwardForPP\n\t\t\tself.dim_after_map=(self.n)\n\t\telif(self.method=='UP'):\n\t\t\tself.forwardForMethod=self.forwardForUP\n\t\t\tself.dim_after_map=(self.n)\n\t\telif(self.method=='DC3'):\n\t\t\tself.forwardForMethod=self.forwardForDC3\n\t\t\tself.dim_after_map=(self.k - self.neq_DC3)\n\t\t\tassert (self.dim_after_map==self.n)\n\t\telse:\n\t\t\traise NotImplementedError\n\n\t\tif(create_map):\n\t\t\tutils.verify(input_dim is not None, \"input_dim needs to be provided\")\n\t\t\tself.mapper=nn.Linear(input_dim, self.dim_after_map);\n\t\telse:\n\t\t\tself.mapper=nn.Sequential(); #Mapper does nothing\n\n\tdef obtainyoFromypDC3(self, yp):\n\t\treturn self.A2oi @ (self.b2_DC3 - self.A2p @ yp)\n\n\n\tdef forwardForDC3(self, q):\n\t\t\n\t\t#### Complete partial\n\t\ty = torch.zeros((q.shape[0], self.k, 1), device=q.device)\n\t\ty[:, self.partial_vars, :] = q\n\t\ty[:, self.other_vars, :] = self.obtainyoFromypDC3(q)\n\n\t\t#### Grad steps all\n\n\t\ty_new = y\n\t\tstep_index = 0\n\t\told_y_step = 0\n\n\t\tif(self.training):\n\t\t\tmax_steps=self.args_DC3['max_steps_training'] #This is called corrTrainSteps in DC3 original code\n\t\telse:\n\t\t\tmax_steps=self.args_DC3['max_steps_testing'] #float(\"inf\") #This is called corrTestMaxSteps in DC3 original code\n\n\t\twhile True:\n\n\t\t\t################################################\n\t\t\t################################################ COMPUTE y_step\n\n\t\t\typ=y_new[:, self.partial_vars,:]\n\t\t\typT=torch.transpose(yp,1,2);\n\n\t\t\tgrad = 2 * self.A1_effective.T @ torch.relu(self.A1_effective@yp - self.b1_effective)\n\n\t\t\tfor i in range(self.all_P_effective.shape[0]): #for each of the quadratic constraints\n\t\t\t\tP_effective=self.all_P_effective[i,:,:]\n\t\t\t\tq_effective=self.all_q_effective[i,:,:]\n\t\t\t\tr_effective=self.all_r_effective[i,:,:]\n\n\t\t\t\ttmp1=(P_effective@yp + q_effective)\n\t\t\t\ttmp2=torch.relu(utils.quadExpression(yp, P_effective, q_effective, r_effective))\n\n\t\t\t\tgrad += 2*tmp1@tmp2 #The 2 is because of the squared norm\n\n\t\t\ty_step = torch.zeros_like(y)\n\t\t\ty_step[:, self.partial_vars, :] = grad\n\t\t\ty_step[:, self.other_vars, :] = - self.A2oi @ self.A2p @ grad\n\t\t\t################################################\n\t\t\t################################################\n\t\t\t\n\t\t\tnew_y_step = self.args_DC3['lr'] * y_step + self.args_DC3['momentum'] * old_y_step\n\t\t\ty_new = y_new - new_y_step\n\t\t\told_y_step = new_y_step\n\t\t\tstep_index += 1\n\n\t\t\t################################################\n\t\t\t################################################ COMPUTE current violation\n\t\t\tstacked=self.A1_DC3@y_new - self.b1_DC3\n\t\t\tfor i in range(self.all_P.shape[0]): #for each of the quadratic constraints\n\t\t\t\tstacked=torch.cat((stacked,utils.quadExpression(y_new, self.all_P[i,:,:], self.all_q[i,:,:], self.all_r[i,:,:])), dim=1)\n\t\t\tviolation=torch.max(torch.relu(stacked))\n\t\t\t################################################\n\t\t\t################################################\n\n\t\t\tconverged_ineq = (violation < self.args_DC3['eps_converge'])\n\t\t\tmax_iter_reached = (step_index >= max_steps)\n\n\t\t\tif(max_iter_reached):\n\t\t\t\tbreak\n\n\t\t\tif(converged_ineq):\n\t\t\t\tbreak\n\n\t\treturn y_new\n\n\n\tdef solveSecondOrderEq(self, a, b, c, is_quad_constraint):\n\t\tdiscriminant = torch.square(b) - 4*(a)*(c)\n\n\t\tassert torch.all(discriminant >= 0), f\"Smallest element is {torch.min(discriminant)}\"\n\t\tsol1=torch.div(  -(b)  - torch.sqrt(discriminant) , 2*a)  #note that for quad constraints the positive solution has the minus: (... - sqrt(...))/(...)\n\t\tif(is_quad_constraint):\n\t\t\treturn sol1\n\t\telse:\n\t\t\tsol2=torch.div(  -(b)  +  torch.sqrt(discriminant) , 2*a) \n\t\t\treturn torch.relu(torch.maximum(sol1, sol2))\n\n\n\tdef computeKappa(self,v_bar):\n\n\t\tkappa=torch.relu( torch.max(self.D@v_bar, dim=1, keepdim=True).values  )\n\n\t\tif(len(self.all_P)>0 or len(self.all_M)>0 or len(self.all_F)>0):\n\t\t\trho = self.NA_E@v_bar\n\t\t\trhoT=torch.transpose(rho,dim0=1, dim1=2)\n\t\t\tall_kappas_positives=torch.empty((v_bar.shape[0],0,1), device=v_bar.device)\n\n\t\t\tfor i in range(self.all_P.shape[0]): #for each of the quadratic constraints\n\n\t\t\t\t#FIRST WAY (slower, easier to understand)\n\t\t\t\t# P=self.all_P[i,:,:]\n\t\t\t\t# q=self.all_q[i,:,:]\n\t\t\t\t# r=self.all_r[i,:,:]\n\t\t\t\t\n\t\t\t\t# c_prime=0.5*rhoT@P@rho;\n\t\t\t\t# b_prime=(self.y0.T@P+ q.T)@rho;\n\t\t\t\t# a_prime=(0.5*self.y0.T@P@self.y0 + q.T@self.y0 +r) \n\n\t\t\t\t# kappa_positive_i_first_way=self.solveSecondOrderEq(a_prime, b_prime, c_prime, True) \n\n\t\t\t\t#SECOND WAY (faster)\n\t\t\t\tkappa_positive_i = self.all_phi[i,:,:]@rho + torch.sqrt(rhoT@self.all_delta[i,:,:]@rho)\n\n\n\t\t\t\t# assert torch.allclose(kappa_positive_i,kappa_positive_i_first_way, atol=1e-06), f\"{torch.max(torch.abs(kappa_positive_i-kappa_positive_i_first_way))}\"\n\n\n\t\t\t\tassert torch.all(kappa_positive_i >= 0), f\"Smallest element is {kappa_positive_i}\" #If not, then Z may not be feasible (note that z0 is in the interior of Z)\n\t\t\t\tall_kappas_positives = torch.cat((all_kappas_positives, kappa_positive_i), dim=1)\n\n\t\t\tfor i in range(self.all_M.shape[0]): #for each of the SOC constraints\n\t\t\t\tM=self.all_M[i,:,:]\n\t\t\t\ts=self.all_s[i,:,:]\n\t\t\t\tc=self.all_c[i,:,:]\n\t\t\t\td=self.all_d[i,:,:]\n\n\t\t\t\tbeta=M@self.y0+s\n\t\t\t\ttau=c.T@self.y0+d\n\n\t\t\t\tc_prime=rhoT@M.T@M@rho - torch.square(c.T@rho)\n\t\t\t\tb_prime=2*rhoT@M.T@beta - 2*(c.T@rho)@tau\n\t\t\t\ta_prime=beta.T@beta - torch.square(tau)\n\n\t\t\t\tkappa_positive_i=self.solveSecondOrderEq(a_prime, b_prime, c_prime, False)\n\n\t\t\t\tassert torch.all(kappa_positive_i >= 0) #If not, then either the feasible set is infeasible (note that z0 is inside the feasible set)\n\t\t\t\tall_kappas_positives = torch.cat((all_kappas_positives, kappa_positive_i), dim=1)\n\n\t\t\tif(len(self.all_F)>0): #If there are LMI constraints:\n\n\t\t\t\t############# OBTAIN S\n\t\t\t\t# First option (much slower)\n\t\t\t\t# S=self.all_F[0,:,:]*rho[:,0:(0+1),0:1]\n\t\t\t\t# for i in range(1,len(self.all_F)-1):\n\t\t\t\t# \t#See https://discuss.pytorch.org/t/scalar-matrix-multiplication-for-a-tensor-and-an-array-of-scalars/100174/2\t\n\t\t\t\t# \tS += self.all_F[i,:,:]*rho[:,i:(i+1),0:1] \n\n\n\t\t\t\t# Second option (much faster)\n\t\t\t\tS=torch.einsum('ajk,ial->ijk', [self.all_F[0:-1,:,:], rho]) #See the tutorial https://rockt.github.io/2018/04/30/einsum\n\t\t\t\t\n\t\t\t\t############# COMPUTE THE EIGENVALUES\n\n\t\t\t\t## Option 1: (compute whole spectrum of the matrix, using the non-symmetric matrix self.mHinv@S)\n\t\t\t\t# eigenvalues = torch.unsqueeze(torch.linalg.eigvals(self.mHinv@S),2) #Note that mHinv@M is not symmetric but always have real eigenvalues\n\t\t\t\t# assert (torch.all(torch.isreal(eigenvalues)))\n\t\t\t\t# largest_eigenvalue = torch.max(eigenvalues.real, dim=1, keepdim=True).values \n\t\t\t\t\n\t\t\t\tLTmSL=self.L.T @ (-S) @ self.L #This matrix is symmetric\n\n\t\t\t\t## Option 2: (compute whole spectrum of the matrix, using the symmetric matrix LTmSL). Much faster than Option 1\n\t\t\t\teigenvalues = torch.unsqueeze(torch.linalg.eigvalsh(LTmSL),2) #Note that L^T (-S) L is a symmetric matrix\n\t\t\t\tlargest_eigenvalue = torch.max(eigenvalues, dim=1, keepdim=True).values \n\n\t\t\t\t## Option 3: Use LOBPCG with A=LTmSL and B=I. The advantage of this method is that only the largest eigenvalue is computed. But, empirically, this option is faster than option 2 only for very big matrices (>1000x1000)\n\t\t\t\t# guess_lobpcg=torch.rand(1, H.shape[0], 1);\n\t\t\t\t# size_batch=v_bar.shape[0]\n\t\t\t\t# largest_eigenvalue, _ = torch.lobpcg(A=LTmSL, k=1, B=None, niter=-1) #, X=guess_lobpcg.expand(size_batch, -1, -1)\n\t\t\t\t# largest_eigenvalue=torch.unsqueeze(largest_eigenvalue, 1)\n\n\t\t\t\t## Option 4: Use power iteration to compute the largest eigenvalue. Often times is slower than just computing the whole spectrum, and sometimes it does not converge\n\t\t\t\t# guess_v = torch.nn.functional.normalize(torch.rand(S.shape[1],1), dim=0)\n\t\t\t\t# largest_eigenvalue=utils.findLargestEigenvalueUsingPowerIteration(self.mHinv@S, guess_v)\n\n\n\t\t\t\t## Option 5: Use LOBPCG with A=-S and B=H. There are two problems though:\n\t\t\t\t# --> This issue: https://github.com/pytorch/pytorch/issues/101075\n\t\t\t\t# --> Backward is not implemented for B!=I, see: https://github.com/pytorch/pytorch/blob/d54fcd571af48685b0699f6ac1e31b6871d0d768/torch/_lobpcg.py#L329 \n\n\t\t\t\t## Option 6: Use https://github.com/rfeinman/Torch-ARPACK with LTmSL. The problem is that backward() is not implemented yet \n\n\t\t\t\t## Option 7: Use https://github.com/buwantaiji/DominantSparseEigenAD. But it does not have support for batched matrices, see https://github.com/buwantaiji/DominantSparseEigenAD/issues/1\n\n\t\t\t\tkappa_positive_i = torch.relu( largest_eigenvalue )\n\n\t\t\t\t\n\t\t\t\tall_kappas_positives = torch.cat((all_kappas_positives, kappa_positive_i), dim=1)\n\n\n\t\t\tkappa_nonlinear_constraints=(torch.max(all_kappas_positives, dim=1, keepdim=True).values)\n\t\t\tkappa = torch.maximum(kappa, kappa_nonlinear_constraints)\n\n\n\t\tassert torch.all(kappa >= 0)\n\n\t\treturn kappa\n\n\tdef forwardForRAYENOld(self, q):\n\t\tv = q[:,  0:self.n,0:1]\n\t\tv_bar=torch.nn.functional.normalize(v, dim=1)\n\t\tkappa=self.computeKappa(v_bar)\n\t\tbeta= q[:, self.n:(self.n+1),0:1]\n\t\talpha=1/(torch.exp(beta) + kappa) \n\t\treturn self.getyFromz(self.z0 + alpha*v_bar)\n\n\tdef forwardForRAYEN(self, q):\n\t\tv = q[:,  0:self.n,0:1]\n\t\tv_bar=torch.nn.functional.normalize(v, dim=1)\n\t\tkappa=self.computeKappa(v_bar)\n\t\tnorm_v=torch.linalg.vector_norm(v, dim=(1,2), keepdim=True)\n\t\talpha=torch.minimum( 1/kappa , norm_v )\n\t\treturn self.getyFromz(self.z0 + alpha*v_bar)\n\n\tdef forwardForUU(self, q):\n\t\treturn q\n\n\tdef forwardForBar(self, q):\n\t\ttmp1 = q[:,  0:self.num_vertices,0:1] #0:1 to keep the dimension. \n\t\ttmp2 = q[:,  self.num_vertices:(self.num_vertices+self.num_rays),0:1] #0:1 to keep the dimension. \n\t\t\n\t\tlambdas=nn.functional.softmax(tmp1, dim=1)\n\t\tmus=torch.abs(tmp2)\n\n\t\treturn self.getyFromz(self.V@lambdas + self.R@mus)\n\n\tdef project(self, q):\n\t\t#If you use ECOS, you can set solver_args={'eps': 1e-6} (or smaller) for better solutions, see https://github.com/cvxpy/cvxpy/issues/880#issuecomment-557278620\n\t\tz, = self.proj_layer(q, solver_args={'solve_method':self.solver_projection}) # \"max_iters\": 10000\n\t\treturn z\n\n\tdef forwardForPP(self, q):\n\t\tz=self.project(q)\n\t\treturn self.getyFromz(z)\n\n\n\tdef forwardForUP(self, q):\n\t\tif(self.training==False):\n\t\t\tz=self.project(q)\n\t\telse:\n\t\t\tz = q\n\n\t\treturn self.getyFromz(z)\n\n\tdef getDimAfterMap(self):\n\t\treturn self.dim_after_map\n\n\tdef gety0(self):\n\t\treturn self.getyFromz(self.z0)\n\n\tdef getyFromz(self, z):\n\t\ty=self.NA_E@z + self.yp\n\t\treturn y\n\n\tdef getzFromy(self, y):\n\t\tz=self.NA_E.T@(y - self.yp)\n\t\treturn z\n\n\tdef forward(self, x):\n\n\t\t##################  MAPPER LAYER ####################\n\t\t#nsib denotes the number of samples in the batch\n\t\t# x has dimensions [nsib, numel_input_mapper, 1]. nsib is the number of samples in the batch (i.e., x.shape[0]=x.shape[0])\n\t\tq = self.mapper(x.view(x.size(0), -1)) #After this, q has dimensions [nsib, numel_output_mapper]\n\t\tq = torch.unsqueeze(q,dim=2)  #After this, q has dimensions [nsib, numel_output_mapper, 1]\n\t\t####################################################\n\n\t\ty=self.forwardForMethod(q)\n\n\t\tassert (torch.isnan(y).any())==False, f\"If you are using DC3, try reducing args_DC3[lr]. Right now it's {self.args_DC3['lr']}\"\n\n\t\treturn y"]}
{"filename": "rayen/__init__.py", "chunked_list": [""]}
{"filename": "rayen/utils.py", "chunked_list": ["# --------------------------------------------------------------------------\n# Jesus Tordesillas Torres, Robotic Systems Lab, ETH Z\u00fcrich \n# See LICENSE file for the license information\n# -------------------------------------------------------------------------- \nimport cdd\nimport numpy as np\nimport torch\nfrom colorama import Fore, Back, Style\nimport torch.nn as nn\n\ndef printInBoldBlue(data_string):\n\tprint(Style.BRIGHT+Fore.BLUE+data_string+Style.RESET_ALL)", "import torch.nn as nn\n\ndef printInBoldBlue(data_string):\n\tprint(Style.BRIGHT+Fore.BLUE+data_string+Style.RESET_ALL)\ndef printInBoldRed(data_string):\n\tprint(Style.BRIGHT+Fore.RED+data_string+Style.RESET_ALL)\ndef printInBoldGreen(data_string):\n\tprint(Style.BRIGHT+Fore.GREEN+data_string+Style.RESET_ALL)\ndef printInBoldWhite(data_string):\n\tprint(Style.BRIGHT+Fore.WHITE+data_string+Style.RESET_ALL)", "def printInBoldWhite(data_string):\n\tprint(Style.BRIGHT+Fore.WHITE+data_string+Style.RESET_ALL)\n\n\ndef verify(condition, message=\"Condition not satisfied\"):\n\tif(condition==False):\n\t\traise RuntimeError(message)\n\ndef getAllPqrFromQcs(qcs):\n\t\tall_P=[]\n\t\tall_q=[]\n\t\tall_r=[]\n\t\tfor qc in qcs:\n\t\t\tall_P.append(qc.P)\n\t\t\tall_q.append(qc.q)\n\t\t\tall_r.append(qc.r)\t\n\t\treturn all_P, all_q, all_r", "def getAllPqrFromQcs(qcs):\n\t\tall_P=[]\n\t\tall_q=[]\n\t\tall_r=[]\n\t\tfor qc in qcs:\n\t\t\tall_P.append(qc.P)\n\t\t\tall_q.append(qc.q)\n\t\t\tall_r.append(qc.r)\t\n\t\treturn all_P, all_q, all_r\n\ndef getAllMscdFromSocs(socs):\n\t\tall_M=[]\n\t\tall_s=[]\n\t\tall_c=[]\n\t\tall_d=[]\n\t\tfor soc in socs:\n\t\t\tall_M.append(soc.M)\n\t\t\tall_s.append(soc.s)\n\t\t\tall_c.append(soc.c)\n\t\t\tall_d.append(soc.d)\n\n\t\treturn all_M, all_s, all_c, all_d", "\ndef getAllMscdFromSocs(socs):\n\t\tall_M=[]\n\t\tall_s=[]\n\t\tall_c=[]\n\t\tall_d=[]\n\t\tfor soc in socs:\n\t\t\tall_M.append(soc.M)\n\t\t\tall_s.append(soc.s)\n\t\t\tall_c.append(soc.c)\n\t\t\tall_d.append(soc.d)\n\n\t\treturn all_M, all_s, all_c, all_d", "\n\nclass CudaTimer():\n\tdef __init__(self):\n\t\t\tpass\n\tdef start(self):\n\t\t\t#See https://discuss.pytorch.org/t/how-to-measure-time-in-pytorch/26964\n\t\t\tself.start_event = torch.cuda.Event(enable_timing=True)\n\t\t\tself.end_event = torch.cuda.Event(enable_timing=True)\n\t\t\tself.start_event.record()\n\n\tdef endAndGetTimeSeconds(self):\n\t\t\tself.end_event.record()\n\t\t\ttorch.cuda.synchronize()\n\t\t\treturn  (1e-3)*self.start_event.elapsed_time(self.end_event) #Note that elapsed_time returns the time in milliseconds", "\n\n########################################################\n########################################################\n\n# Inspired by https://github.com/rfeinman/Torch-ARPACK/blob/master/arpack/power_iteration.py\n# See also https://ergodic.ugr.es/cphys/LECCIONES/FORTRAN/power_method.pdf\n# Note that powerIteration find the eigenvalue with largest absolute value (i.e., the dominant eigenvalue)\n# v is the initial guess of the eigenvector associated with the dominant eigenvalue\n# A should have shape [size_batch, n, n]", "# v is the initial guess of the eigenvector associated with the dominant eigenvalue\n# A should have shape [size_batch, n, n]\n# v should have shape [n, 1]\n# Everything in Pytorch\ndef powerIteration(A, v, tol=1e-5, max_iter=100000, eps=1e-12, check_freq=2):\n\t\tn_iter = 0\n\t\tv = torch.nn.functional.normalize(v)\n\t\twhile n_iter < max_iter:\n\t\t\t\tn_iter += 1\n\t\t\t\tu = torch.nn.functional.normalize(A@v, dim=1)\n\n\t\t\t\tif n_iter>1 and ((n_iter % check_freq) == 0):\n\t\t\t\t\t\tdistance=torch.mean(torch.abs(1 - torch.abs(  torch.transpose(v,1,2)@u ))) #Note: one disadvantage of this is that it will keep iterating until ALL the elements of the batch have converged\n\t\t\t\t\t\tif distance<tol:\n\t\t\t\t\t\t\t\tv = u\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\tv = u\n\t\telse:\n\t\t\t\tprint(f\"distance={distance}\")\n\t\t\t\tprint('Power iteration did not converge')\n\n\t\tlamb =  torch.transpose(v,1,2)@A@v #torch.dot(v, torch.mv(A, v))\n\n\t\treturn lamb", "\n#See https://math.stackexchange.com/a/835568 (note that there are some signs wrong in that answer, but otherwise is good)\n# v is the initial guess for the power iteration\n# A should have shape [size_batch, n, n]\n# v should have shape [n, 1]\n# Everything in Pytorch\ndef findLargestEigenvalueUsingPowerIteration(A, v):\n\t\tlamb = powerIteration(A, v)\n\t\tcondition=(lamb.flatten()<0)\n\t\tif (torch.all(condition == False)):\n\t\t\t\treturn lamb\n\t\tlamb[condition,:,:]+=powerIteration(A[condition,:,:]-lamb[condition,:,:]*torch.eye(A.shape[1]), v)\n\t\treturn lamb", "\n\n# Other links: \n# --> https://github.com/pytorch/pytorch/blob/main/torch/nn/utils/spectral_norm.py#L80\n\n\ndef isZero(A):\n\treturn (not np.any(A))\n\ndef checkMatrixisNotZero(A):\n\tverify(not isZero(A))", "\ndef checkMatrixisNotZero(A):\n\tverify(not isZero(A))\n\ndef checkMatrixisSymmetric(A):\n\tverify(A.shape[0]==A.shape[1])\n\tverify(np.allclose(A, A.T))\n\ndef checkMatrixisPsd(A, tol=0.0):\n\tcheckMatrixisSymmetric(A)\n\teigenvalues=np.linalg.eigvals(A);\n\tverify(np.all(eigenvalues >= -tol), f\"Matrix is not PSD, min eigenvalue is {np.amin(eigenvalues)}\")", "def checkMatrixisPsd(A, tol=0.0):\n\tcheckMatrixisSymmetric(A)\n\teigenvalues=np.linalg.eigvals(A);\n\tverify(np.all(eigenvalues >= -tol), f\"Matrix is not PSD, min eigenvalue is {np.amin(eigenvalues)}\")\n\ndef checkMatrixisPd(A):\n\tcheckMatrixisSymmetric(A)\n\teigenvalues=np.linalg.eigvals(A);\n\tverify(np.all(eigenvalues > 0.0), f\"Matrix is not PD, min eigenvalue is {np.amin(eigenvalues)}\")\n\ndef isMatrixSingular(A):\n\treturn (np.linalg.matrix_rank(A) < self.E.shape[0])", "\ndef isMatrixSingular(A):\n\treturn (np.linalg.matrix_rank(A) < self.E.shape[0])\n\n#Taken from https://gist.github.com/sgsfak/77a1c08ac8a9b0af77393b24e44c9547\n#Compute the Reduced Row Echelon Form (RREF) in Python\ndef rref(B, tol=1e-8):\n\tA = B.copy()\n\trows, cols = A.shape\n\tr = 0\n\tpivots_pos = []\n\trow_exchanges = np.arange(rows)\n\tfor c in range(cols):\n\n\t\t## Find the pivot row:\n\t\tpivot = np.argmax (np.abs (A[r:rows,c])) + r\n\t\tm = np.abs(A[pivot, c])\n\t\tif m <= tol:\n\t\t\t## Skip column c, making sure the approximately zero terms are\n\t\t\t## actually zero.\n\t\t\tA[r:rows, c] = np.zeros(rows-r)\n\t\telse:\n\t\t\t## keep track of bound variables\n\t\t\tpivots_pos.append((r,c))\n\n\t\t\tif pivot != r:\n\t\t\t\t## Swap current row and pivot row\n\t\t\t\tA[[pivot, r], c:cols] = A[[r, pivot], c:cols]\n\t\t\t\trow_exchanges[[pivot,r]] = row_exchanges[[r,pivot]]\n\n\t\t\t## Normalize pivot row\n\t\t\tA[r, c:cols] = A[r, c:cols] / A[r, c];\n\n\t\t\t## Eliminate the current column\n\t\t\tv = A[r, c:cols]\n\t\t\t## Above (before row r):\n\t\t\tif r > 0:\n\t\t\t\tridx_above = np.arange(r)\n\t\t\t\tA[ridx_above, c:cols] = A[ridx_above, c:cols] - np.outer(v, A[ridx_above, c]).T\n\t\t\t## Below (after row r):\n\t\t\tif r < rows-1:\n\t\t\t\tridx_below = np.arange(r+1,rows)\n\t\t\t\tA[ridx_below, c:cols] = A[ridx_below, c:cols] - np.outer(v, A[ridx_below, c]).T\n\t\t\tr += 1\n\t\t## Check if done\n\t\tif r == rows:\n\t\t\tbreak;\n\treturn (A, pivots_pos, row_exchanges)", "\n# Input is the matrices (A,b) that define the system Ax=b\n# Ouput is the matrices (A',b') such that A'x=b' has the same solutions as Ax=b, and (A',b') have the smallest possible number of rows\n# See https://mathoverflow.net/a/48867  and the row echelon form in https://en.wikipedia.org/wiki/Gaussian_elimination#General_algorithm_to_compute_ranks_and_bases\ndef removeRedundantEquationsFromEqualitySystem(A, b):\n\n\tA_b=np.concatenate((A, b), axis=1)\n\n\tA_b_new, pivots_pos, row_exchanges = rref(A_b)\n\n\t##### Now remove the rows that are zero\n\trows_that_are_zero=[]\n\tfor i in range(A_b_new.shape[0]):\n\t\tif(np.linalg.norm(A_b_new[i,:])<1e-7):\n\t\t\trows_that_are_zero.append(i)\n\n\tA_b_new = np.delete(A_b_new, rows_that_are_zero, axis=0)\n\t#####################################\n\n\t##### Now get A_new and b_new from A_b_new\n\tA_new=A_b_new[:,:-1].reshape((-1, A.shape[1]))\n\tb_new=A_b_new[:,-1].reshape((-1, 1))\n\t#####################################\n\n\tif(A_b_new.shape[0]>0):\n\t\tassert np.linalg.matrix_rank(A_b_new)==A_b_new.shape[0]\n\n\treturn A_new, b_new", "\n\n\n#Everything in numpy\n#Ellipsoid is defined as {x | (x-c)'E(x-c)<=1}\n#Where E is a positive semidefinite matrix\nclass Ellipsoid():\n\tdef __init__(self, E, c):\n\n\t\tcheckMatrixisPsd(E);\n\t\tself.E=E;\n\t\tself.c=c;\n\n\tdef convertToQuadraticConstraint(self):\n\t\tP=2*self.E;\n\t\tq=(-2*self.E@self.c)\n\t\tr=self.c.T@self.E@self.c-1\n\t\treturn convexQuadraticConstraint(P,q,r)", "\n#Pytorch\ndef quadExpression(y, P, q, r):\n\n\tP = P.to(y.device)\n\tq = q.to(y.device)\n\tr = r.to(y.device)\n\n\tif (q.ndim==2):\n\t\tqT=q.T\n\telse: #q is a batch\n\t\tassert q.ndim==3 \n\t\tqT=torch.transpose(q,1,2)\n\n\tresult=0.5*torch.transpose(y,1,2)@P@y + qT@y + r;\n\tassert result.shape==(y.shape[0],1,1)\n\treturn result", "\n#https://stackoverflow.com/a/3844832\ndef all_equal(iterator):\n\titerator = iter(iterator)\n\ttry:\n\t\tfirst = next(iterator)\n\texcept StopIteration:\n\t\treturn True\n\treturn all(first == x for x in iterator)\n\ndef loadpickle(name_file):\n\timport pickle\n\twith open(name_file, \"rb\") as input_file:\n\t\tresult = pickle.load(input_file)\n\treturn result\t", "\ndef loadpickle(name_file):\n\timport pickle\n\twith open(name_file, \"rb\") as input_file:\n\t\tresult = pickle.load(input_file)\n\treturn result\t\n\ndef savepickle(variable, name_file):\n\timport pickle\n\twith open(name_file, 'wb') as output_file:\n\t\tpickle.dump(variable, output_file, pickle.HIGHEST_PROTOCOL)\t", "\n#https://stackoverflow.com/questions/65154622/sample-uniformly-at-random-from-a-simplex-in-python\ndef runif_in_simplex(n):\n\t''' Return uniformly random vector in the n-simplex '''\n\n\tk = np.random.exponential(scale=1.0, size=n)\n\treturn k / sum(k)\n\n#This function is taken from https://github.com/tfrerix/constrained-nets\ndef H_to_V(A, b):\n\t\"\"\"\n\tConverts a polyhedron in H-representation to\n\tone in V-representation using pycddlib.\n\t\"\"\"\n\t# define cdd problem and convert representation\n\tif len(b.shape) == 1:\n\t\tb = np.expand_dims(b, axis=1)\n\tmat_np = np.concatenate([b, -A], axis=1)\n\tif mat_np.dtype in [np.int32, np.int64]:\n\t\tnt = 'fraction'\n\telse:\n\t\tnt = 'float'\n\tmat_list = mat_np.tolist()\n\n\tmat_cdd = cdd.Matrix(mat_list, number_type=nt)\n\tmat_cdd.rep_type = cdd.RepType.INEQUALITY\n\tpoly = cdd.Polyhedron(mat_cdd)\n\tgen = poly.get_generators()\n\n\t# convert the cddlib output data structure to numpy\n\tV_list = []\n\tR_list = []\n\tlin_set = gen.lin_set\n\tV_lin_idx = []\n\tR_lin_idx = []\n\tfor i in range(gen.row_size):\n\t\tg = gen[i]\n\t\tg_type = g[0]\n\t\tg_vec = g[1:]\n\t\tif i in lin_set:\n\t\t\tis_linear = True\n\t\telse:\n\t\t\tis_linear = False\n\t\tif g_type == 1:\n\t\t\tV_list.append(g_vec)\n\t\t\tif is_linear:\n\t\t\t\tV_lin_idx.append(len(V_list) - 1)\n\t\telif g_type == 0:\n\t\t\tR_list.append(g_vec)\n\t\t\tif is_linear:\n\t\t\t\tR_lin_idx.append(len(R_list) - 1)\n\t\telse:\n\t\t\traise ValueError('Generator data structure is not valid.')\n\n\tV = np.asarray(V_list)\n\tR = np.asarray(R_list)\n\n\t# by convention of cddlib, those rays associated with R_lin_idx\n\t# are not constrained to non-negative coefficients\n\tif len(R) > 0:\n\t\tR = np.concatenate([R, -R[R_lin_idx, :]], axis=0)\n\n\tV=V.T; \n\tR=R.T;\n\n\tif(R.size==0):\n\t\tR=np.array([[]])#Simply add a dimension, so that both V and R are 2D matrices\n\n\tif(V.size==0):\n\t\tV=np.array([[]])#Simply add a dimension, so that both V and R are 2D matrices\n\n\t#Each column of V is a vertex\n\t#Each column of R is a ray\n\n\treturn V, R", "#This function is taken from https://github.com/tfrerix/constrained-nets\ndef H_to_V(A, b):\n\t\"\"\"\n\tConverts a polyhedron in H-representation to\n\tone in V-representation using pycddlib.\n\t\"\"\"\n\t# define cdd problem and convert representation\n\tif len(b.shape) == 1:\n\t\tb = np.expand_dims(b, axis=1)\n\tmat_np = np.concatenate([b, -A], axis=1)\n\tif mat_np.dtype in [np.int32, np.int64]:\n\t\tnt = 'fraction'\n\telse:\n\t\tnt = 'float'\n\tmat_list = mat_np.tolist()\n\n\tmat_cdd = cdd.Matrix(mat_list, number_type=nt)\n\tmat_cdd.rep_type = cdd.RepType.INEQUALITY\n\tpoly = cdd.Polyhedron(mat_cdd)\n\tgen = poly.get_generators()\n\n\t# convert the cddlib output data structure to numpy\n\tV_list = []\n\tR_list = []\n\tlin_set = gen.lin_set\n\tV_lin_idx = []\n\tR_lin_idx = []\n\tfor i in range(gen.row_size):\n\t\tg = gen[i]\n\t\tg_type = g[0]\n\t\tg_vec = g[1:]\n\t\tif i in lin_set:\n\t\t\tis_linear = True\n\t\telse:\n\t\t\tis_linear = False\n\t\tif g_type == 1:\n\t\t\tV_list.append(g_vec)\n\t\t\tif is_linear:\n\t\t\t\tV_lin_idx.append(len(V_list) - 1)\n\t\telif g_type == 0:\n\t\t\tR_list.append(g_vec)\n\t\t\tif is_linear:\n\t\t\t\tR_lin_idx.append(len(R_list) - 1)\n\t\telse:\n\t\t\traise ValueError('Generator data structure is not valid.')\n\n\tV = np.asarray(V_list)\n\tR = np.asarray(R_list)\n\n\t# by convention of cddlib, those rays associated with R_lin_idx\n\t# are not constrained to non-negative coefficients\n\tif len(R) > 0:\n\t\tR = np.concatenate([R, -R[R_lin_idx, :]], axis=0)\n\n\tV=V.T; \n\tR=R.T;\n\n\tif(R.size==0):\n\t\tR=np.array([[]])#Simply add a dimension, so that both V and R are 2D matrices\n\n\tif(V.size==0):\n\t\tV=np.array([[]])#Simply add a dimension, so that both V and R are 2D matrices\n\n\t#Each column of V is a vertex\n\t#Each column of R is a ray\n\n\treturn V, R", "\n\n\n\n"]}
{"filename": "rayen/constraints.py", "chunked_list": ["# --------------------------------------------------------------------------\n# Jesus Tordesillas Torres, Robotic Systems Lab, ETH Z\u00fcrich \n# See LICENSE file for the license information\n# -------------------------------------------------------------------------- \n\nfrom . import utils\nimport cvxpy as cp\nimport numpy as np\nfrom tqdm import tqdm\nimport scipy", "from tqdm import tqdm\nimport scipy\nimport math\n\n\n################### CONSTRAINTS\n#everything is numpy\n\nclass LinearConstraint():\n\t#Constraint is A1<=b1, A2=b2\n\tdef __init__(self, A1, b1, A2, b2):\n\t\tself.A1 = A1\n\t\tself.b1 = b1\n\t\tself.A2 = A2\n\t\tself.b2 = b2\n\n\t\tutils.verify(self.hasEqConstraints() or self.hasIneqConstraints())\n\n\t\tif (self.hasIneqConstraints()):\n\t\t\tutils.verify(A1.ndim == 2)\n\t\t\tutils.verify(b1.ndim == 2)\n\t\t\tutils.verify(b1.shape[1] ==1)\n\t\t\tutils.verify(A1.shape[0] == b1.shape[0])\n\n\t\tif (self.hasEqConstraints()):\n\t\t\tutils.verify(A2.ndim == 2)\n\t\t\tutils.verify(b2.ndim == 2)\n\t\t\tutils.verify(b2.shape[1] ==1)\n\t\t\tutils.verify(A2.shape[0] == b2.shape[0])\n\n\t\tif (self.hasIneqConstraints() and self.hasEqConstraints()):\n\t\t\tutils.verify(A1.shape[1] == A2.shape[1])\n\n\tdef hasEqConstraints(self):\n\t\treturn (self.A2 is not None and self.b2 is not None)\n\n\tdef hasIneqConstraints(self): \n\t\treturn (self.A1 is not None and self.b1 is not None)\n\n\tdef dim(self):\n\t\tif (self.A1 is not None and self.b1 is not None):\n\t\t\treturn self.A1.shape[1]\n\t\telse:\n\t\t\treturn self.A2.shape[1]\n\n\tdef asCvxpy(self, y, epsilon=0.0):\n\t\tconstraints=[];\n\t\tif self.hasIneqConstraints():\n\t\t\tconstraints.append(self.A1@y<=self.b1)\n\t\tif self.hasEqConstraints():\n\t\t\tconstraints.append(self.A2@y==self.b2)\n\n\t\treturn constraints", "class LinearConstraint():\n\t#Constraint is A1<=b1, A2=b2\n\tdef __init__(self, A1, b1, A2, b2):\n\t\tself.A1 = A1\n\t\tself.b1 = b1\n\t\tself.A2 = A2\n\t\tself.b2 = b2\n\n\t\tutils.verify(self.hasEqConstraints() or self.hasIneqConstraints())\n\n\t\tif (self.hasIneqConstraints()):\n\t\t\tutils.verify(A1.ndim == 2)\n\t\t\tutils.verify(b1.ndim == 2)\n\t\t\tutils.verify(b1.shape[1] ==1)\n\t\t\tutils.verify(A1.shape[0] == b1.shape[0])\n\n\t\tif (self.hasEqConstraints()):\n\t\t\tutils.verify(A2.ndim == 2)\n\t\t\tutils.verify(b2.ndim == 2)\n\t\t\tutils.verify(b2.shape[1] ==1)\n\t\t\tutils.verify(A2.shape[0] == b2.shape[0])\n\n\t\tif (self.hasIneqConstraints() and self.hasEqConstraints()):\n\t\t\tutils.verify(A1.shape[1] == A2.shape[1])\n\n\tdef hasEqConstraints(self):\n\t\treturn (self.A2 is not None and self.b2 is not None)\n\n\tdef hasIneqConstraints(self): \n\t\treturn (self.A1 is not None and self.b1 is not None)\n\n\tdef dim(self):\n\t\tif (self.A1 is not None and self.b1 is not None):\n\t\t\treturn self.A1.shape[1]\n\t\telse:\n\t\t\treturn self.A2.shape[1]\n\n\tdef asCvxpy(self, y, epsilon=0.0):\n\t\tconstraints=[];\n\t\tif self.hasIneqConstraints():\n\t\t\tconstraints.append(self.A1@y<=self.b1)\n\t\tif self.hasEqConstraints():\n\t\t\tconstraints.append(self.A2@y==self.b2)\n\n\t\treturn constraints", "\nclass ConvexQuadraticConstraint():\n\t# Constraint is (1/2)x'Px + q'x +r <=0\n\tdef __init__(self, P, q, r, do_checks_P=True):\n\t\tself.P=P;\n\t\tself.q=q;\n\t\tself.r=r;\n\n\t\tif(do_checks_P==True):\n\t\t\t\n\t\t\tutils.checkMatrixisNotZero(self.P);\n\t\t\tutils.checkMatrixisSymmetric(self.P)\n\t\t\n\t\t\teigenvalues=np.linalg.eigvalsh(self.P);\n\t\t\tsmallest_eigenvalue= (np.amin(eigenvalues))\n\n\t\t\t######## Check that the matrix is PSD up to a tolerance\n\t\t\ttol=1e-7\n\t\t\tutils.verify(smallest_eigenvalue>-tol, f\"Matrix P is not PSD, smallest eigenvalue is {smallest_eigenvalue}\")\n\t\t\t#########################\n\n\t\t\t#Note: All the code assummes that P is a PSD matrix. This is specially important when:\n\t\t\t#--> Using  cp.quad_form(...) You can use the argument assume_PSD=True (see https://github.com/cvxpy/cvxpy/issues/407)\n\t\t\t#--> Computting kappa (if P is not a PSD matrix, you end up with a negative discriminant when solving the 2nd order equation)\n\n\t\t\t######### Correct for possible numerical errors\n\t\t\tif( (-tol)<=smallest_eigenvalue<0  ):\n\t\t\t\t#Correction due to numerical errors\n\t\t\t\t\n\t\t\t\t##Option 1\n\t\t\t\tself.P = self.P +np.abs(smallest_eigenvalue)*np.eye(self.P.shape[0]) \n\n\t\t\t\t##Option 2 https://stackoverflow.com/a/63131250  and https://math.stackexchange.com/a/1380345\n\t\t\t\t# C = (self.P + self.P.T)/2  #https://en.wikipedia.org/wiki/Symmetric_matrix#Decomposition_into_symmetric_and_skew-symmetric\n\t\t\t\t# eigval, eigvec = np.linalg.eigh(C)\n\t\t\t\t# eigval[eigval < 0] = 0\n\t\t\t\t# self.P=eigvec.dot(np.diag(eigval)).dot(eigvec.T)\n\t\t\t##########\n\n\tdef dim(self):\n\t\treturn self.P.shape[1]\n\n\tdef asCvxpy(self, y, epsilon=0.0):\n\n\t\treturn [0.5*cp.quad_form(y, self.P, assume_PSD=True) + self.q.T@y + self.r <= -epsilon]  #assume_PSD needs to be True because of this: https://github.com/cvxpy/cvxpy/issues/407. We have already checked that it is Psd within a tolerance", "\nclass SOCConstraint():\n\t#Constraint is ||My+s||<=c'y+d\n\tdef __init__(self, M, s, c, d):\n\t\tutils.checkMatrixisNotZero(M);\n\t\tutils.checkMatrixisNotZero(c);\n\n\t\tutils.verify(M.shape[1]==c.shape[0])\n\t\tutils.verify(M.shape[0]==s.shape[0])\n\t\tutils.verify(s.shape[1]==1)\n\t\tutils.verify(c.shape[1]==1)\n\t\tutils.verify(d.shape[0]==1)\n\t\tutils.verify(d.shape[1]==1)\n\n\t\tself.M = M\n\t\tself.s = s\n\t\tself.c = c\n\t\tself.d = d\n\n\tdef dim(self):\n\t\treturn self.M.shape[1]\n\n\tdef asCvxpy(self, y, epsilon=0.0):\n\t\treturn [cp.norm(self.M@y + self.s) - self.c.T@y - self.d <= -epsilon]", "\n\nclass LMIConstraint():\n\t#Constraint is y0 F0 + y1 F1 + ... + ykm1 Fkm1 + Fk >=0\n\tdef __init__(self, all_F):\n\t\tfor F in all_F:\n\t\t\tutils.checkMatrixisSymmetric(F);\n\t\t\n\t\tfor F_i in all_F:\n\t\t\tutils.verify(F_i.shape==all_F[0].shape)\n\n\t\tself.all_F=all_F\n\n\tdef dim(self):\n\t\treturn (len(self.all_F)-1)\n\n\tdef asCvxpy(self, y, epsilon=0.0):\n\t\tlmi_left_hand_side=0;\n\t\tk=self.dim()\n\t\ttmp=self.all_F[0].shape[0]\n\t\tfor i in range(k):\n\t\t\tlmi_left_hand_side += y[i,0]*self.all_F[i]\n\t\tlmi_left_hand_side += self.all_F[k]\n\n\t\treturn [lmi_left_hand_side  >>  epsilon*np.eye(tmp)]", "\n######################################\n\nclass ConvexConstraints():\n\t# y0 (a point in the relative interior of the feasible set) can be provided or not\n\t# If it's not provided, this code will find one point in the relative interior of the feasible set\n\t# If it's provided, this code does not check whether or not that point is in the relative interior of the set. It's the user's responsibility to do that \n\n\t# do_preprocessing_linear can be set to True ONLY when the user knows beforehand that affine_hull{y:A1y<=b1} = R^k  . Again, it's the user's responsibility to ensure that that is actually the case \n\tdef __init__(self, lc=None, qcs=[], socs=[], lmic=None, y0=None, do_preprocessing_linear=True, print_debug_info=False):\n\n\t\tif(lc is not None):\n\t\t\tself.has_linear_eq_constraints=lc.hasEqConstraints();\n\t\t\tself.has_linear_ineq_constraints=lc.hasIneqConstraints();\n\t\t\tself.has_linear_constraints=self.has_linear_eq_constraints or self.has_linear_ineq_constraints;\n\t\telse:\n\t\t\tself.has_linear_eq_constraints=False\n\t\t\tself.has_linear_ineq_constraints=False\n\t\t\tself.has_linear_constraints=False\n\n\n\t\tself.has_quadratic_constraints=(len(qcs)>0)\n\t\tself.has_soc_constraints=(len(socs)>0)\n\t\tself.has_lmi_constraints=(lmic is not None)\n\n\t\tself.lc=lc\n\t\tself.qcs=qcs\n\t\tself.socs=socs\n\t\tself.lmic=lmic\n\n\n\t\tutils.verify((self.has_quadratic_constraints or self.has_linear_constraints or self.has_soc_constraints or self.has_lmi_constraints), \"There are no constraints!\")\n\n\n\t\t#Check that the dimensions of all the constraints are the same\n\t\tall_dim=[]\n\t\tif(self.has_linear_constraints):\n\t\t\tall_dim.append(lc.dim())\n\t\tfor qc in qcs:\n\t\t\tall_dim.append(qc.dim())\n\t\tfor soc in socs:\n\t\t\tall_dim.append(soc.dim())\n\t\tif(self.has_lmi_constraints):\n\t\t\tall_dim.append(lmic.dim())\n\n\t\tutils.verify(utils.all_equal(all_dim))\n\t\t#####################################3\n\n\t\tself.k=all_dim[0]\n\n\t\t##################### CHOOSE SOLVER\n\t\t###################################################\n\t\tinstalled_solvers=cp.installed_solvers();\n\t\tif ('GUROBI' in installed_solvers) and self.has_lmi_constraints==False:\n\t\t\tself.solver='GUROBI' #You need to do `python -m pip install gurobipy`\n\t\telif ('ECOS' in installed_solvers) and self.has_lmi_constraints==False:\n\t\t\tself.solver='ECOS'\n\t\telif ('SCS' in installed_solvers):\n\t\t\tself.solver='SCS'\n\t\t# elif 'OSQP' in installed_solvers:\n\t\t# \tself.solver='OSQP'\n\t\t# elif 'CVXOPT' in installed_solvers:\t\n\t\t# \tself.solver='CVXOPT'\n\t\telse:\n\t\t\t#TODO: There are more solvers, see https://www.cvxpy.org/tutorial/advanced/index.html#choosing-a-solver\n\t\t\traise Exception(f\"Which solver do you have installed?\")\n\t\t###################################################\n\n\t\tif(y0 is None):\n\t\t\t###########################################\n\t\t\t# Ensure that the feasible set is not empty\n\t\t\tz = cp.Variable((self.k,1))\n\t\t\tobjective = cp.Minimize(0.0)\n\t\t\tconstraints_cvxpy = self.getConstraintsCvxpy(z)\n\t\t\tprob = cp.Problem(objective, constraints_cvxpy)\n\t\t\tresult = prob.solve(verbose=False, solver=self.solver);\n\t\t\tif(prob.status != 'optimal'):\n\t\t\t\traise Exception(\"The feasible set is empty\")\n\t\t\t############################################\n\n\t\tif(self.has_linear_constraints):\n\n\n\t\t\t######################################## Stack the matrices so that the linear constraints look like Ax<=b \n\t\t\tif(self.has_linear_ineq_constraints):\n\t\t\t\tA=self.lc.A1;\n\t\t\t\tb=self.lc.b1;\n\t\t\t\tif(self.has_linear_eq_constraints): \n\t\t\t\t\t#Add the equality constraints as inequality constraints\n\t\t\t\t\tA=np.concatenate((A,self.lc.A2,-self.lc.A2), axis=0);\n\t\t\t\t\tb=np.concatenate((b,self.lc.b2,-self.lc.b2), axis=0);\t\t\t\t\n\t\t\telse:\n\t\t\t\t#Add the equality constraints as inequality constraints\n\t\t\t\tA=np.concatenate((self.lc.A2,-self.lc.A2), axis=0);\n\t\t\t\tb=np.concatenate((self.lc.b2,-self.lc.b2), axis=0);\n\n\t\t\tif(print_debug_info):\n\t\t\t\tutils.printInBoldGreen(f\"A is {A.shape} and b is {b.shape}\")\n\t\t\t########################################\n\n\t\t\tif(do_preprocessing_linear):\n\n\t\t\t\tTOL=1e-7;\n\t\t\t\tz = cp.Variable((self.k,1))\n\t\t\t\tif(A.shape[0]>1): #If there is more than one constraint\n\t\t\t\t\t#Remove redundant constraints\n\t\t\t\t\t################################################\n\t\t\t\t\t#Eq 1.5 of https://www.research-collection.ethz.ch/bitstream/handle/20.500.11850/167108/1/thesisFinal_MaySzedlak.pdf\n\t\t\t\t\t#See also https://mathoverflow.net/a/69667\n\t\t\t\t\tif(print_debug_info):\n\t\t\t\t\t\tutils.printInBoldBlue(\"Removing redundant constraints...\")\n\t\t\t\t\tindexes_const_removed=[]\n\t\t\t\t\treversed_indexes=list(reversed(range(A.shape[0])));\n\t\t\t\t\tfor i in tqdm(reversed_indexes):\n\t\t\t\t\t\tall_rows_but_i=[x for x in range(A.shape[0]) if x != i]\n\t\t\t\t\t\tobjective = cp.Maximize(A[i,:]@z)\n\t\t\t\t\t\tconstraints=[A[all_rows_but_i,:]@z<=b[all_rows_but_i,:],   A[i,:]@z<=(b[i,0]+1)]\n\t\t\t\t\t\tprob = cp.Problem(objective, constraints)\n\t\t\t\t\t\tresult = prob.solve(verbose=False, solver=self.solver);\n\t\t\t\t\t\tif(prob.status != 'optimal' and prob.status!='optimal_inaccurate'):\n\t\t\t\t\t\t\traise Exception(\"Value is not optimal\")\n\n\t\t\t\t\t\tif ((objective.value-b[i,0])<=TOL):\n\t\t\t\t\t\t\tindexes_const_removed.append(i)\n\t\t\t\t\t\t\tA = np.delete(A, (i), axis=0)\n\t\t\t\t\t\t\tb = np.delete(b, (i), axis=0)\n\n\t\t\t\t\tif(print_debug_info):\n\t\t\t\t\t\tutils.printInBoldBlue(f\"Removed {len(indexes_const_removed)} constraints \")\n\t\t\t\t\t\tutils.printInBoldGreen(f\"A is {A.shape} and b is {b.shape}\")\n\t\t\t\t\t################################################\n\n\n\n\t\t\t\t#Find equality set\n\t\t\t\t################################################\n\t\t\t\t# Section 5.2 of https://www.researchgate.net/publication/268373838_Polyhedral_Tools_for_Control\n\t\t\t\t# See also Definition 2.16 of https://sites.math.washington.edu/~thomas/teaching/m583_s2008_web/main.pdf\n\n\t\t\t\tE=[] #contains the indexes of the constraints in the equality set\n\n\t\t\t\tif(print_debug_info):\n\t\t\t\t\tutils.printInBoldBlue(\"Finding Affine Hull and projecting...\")\n\n\t\t\t\tfor i in tqdm(range(A.shape[0])):\n\t\t\t\t\tobjective = cp.Minimize(A[i,:]@z-b[i,0]) #I try to go far from the constraint, into the feasible set\n\t\t\t\t\tconstraints=[A@z<=b]\n\t\t\t\t\tprob = cp.Problem(objective, constraints)\n\t\t\t\t\tif(self.solver=='GUROBI'):\n\t\t\t\t\t\tresult = prob.solve(verbose=False, solver=self.solver, reoptimize=True)\n\t\t\t\t\telse:\n\t\t\t\t\t\tTOL=1e-5;\n\t\t\t\t\t\tresult = prob.solve(verbose=False, solver=self.solver)                # When using Gurobi, we need the reoptimize parameter because if not the solver cannot distinguish between infeasible or unbounded. This is the error you get:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  #   The problem is either infeasible or unbounded, but the solver\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  #   cannot tell which. Disable any solver-specific presolve methods\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  #   and re-solve to determine the precise problem status.\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  #   For GUROBI and CPLEX you can automatically perform this re-solve\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  #   with the keyword argument prob.solve(reoptimize=True, ...).\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t    \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  #   warnings.warn(INF_OR_UNB_MESSAGE)\n\n\t\t\t\t\tobj_value=objective.value;\n\n\t\t\t\t\tif(prob.status=='unbounded'):\n\t\t\t\t\t\tobj_value=-math.inf #note that we are minimizing\n\n\t\t\t\t\tif(prob.status != 'optimal' and prob.status!='unbounded' and prob.status!='optimal_inaccurate'):\n\t\t\t\t\t\traise Exception(f\"prob.status={prob.status}\")\n\n\t\t\t\t\tutils.verify(obj_value<TOL, f\"The objective should be negative. It's {obj_value} right now\")\n\n\t\t\t\t\tif (obj_value>-TOL): #if the objective value is zero (I tried to go far from the constraint, but I couldn't)\n\t\t\t\t\t\tE.append(i)\n\n\t\t\telse:\n\t\t\t\t#Here we simply choose E such that\n\t\t\t\t# A_E == A2, b_E == b_2\n\t\t\t\t# A_I == A1, b_I == b_1\n\t\t\t\tif(self.has_linear_ineq_constraints):\n\t\t\t\t\tstart=self.lc.A1.shape[0]\n\t\t\t\telse:\n\t\t\t\t\tstart=0\n\t\t\t\tE=list(range(start, A.shape[0]))\n\n\t\t\tif(print_debug_info):\n\t\t\t\tutils.printInBoldGreen(f\"E={E}\")\n\n\t\t\tI=[i for i in range(A.shape[0]) if i not in E];\n\n\n\t\t\t#Obtain A_E, b_E and A_I, b_I\n\t\t\tif(len(E)>0):\n\t\t\t\tA_E=A[E,:];\n\t\t\t\tb_E=b[E,:];\n\t\t\telse:\n\t\t\t\tA_E=np.zeros((1,A.shape[1]));\n\t\t\t\tb_E=np.zeros((1,1));\t\n\n\t\t\tif(len(I)>0):\n\t\t\t\tA_I=A[I,:];\n\t\t\t\tb_I=b[I,:];\n\t\t\telse:\n\t\t\t\tA_I=np.zeros((1,A.shape[1])); # 0z<=1\n\t\t\t\tb_I=np.ones((1,1));\t\n\n\t\t\t#At this point, A_E, b_E, A_I, and b_I have at least one row\n\n\t\t\t#Project into the nullspace of A_E\n\t\t\t################################################\n\t\t\tNA_E=scipy.linalg.null_space(A_E);\n\t\t\t# n=NA_E.shape[1] #dimension of the subspace\n\t\t\typ=np.linalg.pinv(A_E)@b_E\n\t\t\tA_p=A_I@NA_E;\n\t\t\tb_p=b_I-A_I@yp\n\t\t\t\t\t\n\n\t\t\tutils.verify(A_p.ndim == 2, f\"A_p.shape={A_p.shape}\")\n\t\t\tutils.verify(b_p.ndim == 2, f\"b_p.shape={b_p.shape}\")\n\t\t\tutils.verify(b_p.shape[1] ==1)\n\t\t\tutils.verify(A_p.shape[0] == b_p.shape[0])\n\n\t\t\tif(print_debug_info):\n\t\t\t\tutils.printInBoldGreen(f\"A_p is {A_p.shape} and b_p is {b_p.shape}\")\n\n\t\t\tself.n=A_p.shape[1] #dimension of the linear subspace\n\n\t\telse:\n\t\t\tself.n=self.k\n\t\t\tNA_E=np.eye(self.n);\n\t\t\typ=np.zeros((self.n,1));\n\t\t\tA_p=np.zeros((1,self.n)) # 0z<=1\n\t\t\tb_p=np.ones((1,1))\n\n\t\t\tA_E=np.zeros((1,self.k)); # 0y=0\n\t\t\tb_E=np.zeros((1,1));\t\n\n\t\t\tA_I=np.zeros((1,self.k)); # 0y<=1\n\t\t\tb_I=np.ones((1,1));\t\n\n\n\t\tself.A_E=A_E\n\t\tself.b_E=b_E\n\t\tself.A_I=A_I\n\t\tself.b_I=b_I\n\n\t\tself.A_p=A_p\t\n\t\tself.b_p=b_p\t\n\t\tself.yp=yp\t\n\t\tself.NA_E=NA_E\t\n\n\t\tutils.verify(self.n==(self.k-np.linalg.matrix_rank(self.A_E)))\n\n\t\t#############Obtain a strictly feasible point z0\n\t\t###################################################\n\n\t\tif(y0 is None):\n\t\t\tepsilon=cp.Variable()\n\t\t\tz0 = cp.Variable((self.n,1))\n\n\t\t\tconstraints=self.getConstraintsInSubspaceCvxpy(z0, epsilon)\n\n\t\t\tconstraints.append(epsilon>=0)\n\t\t\tconstraints.append(epsilon<=0.5) #This constraint is needed for the case where the set is unbounded. Any positive value is valid\n\t\t\t\n\t\t\tobjective = cp.Minimize(-epsilon)\n\t\t\tprob = cp.Problem(objective, constraints)\n\n\t\t\tresult = prob.solve(verbose=False, solver=self.solver);\n\t\t\tif(prob.status != 'optimal' and prob.status!='optimal_inaccurate'):\n\t\t\t\traise Exception(f\"Value is not optimal, prob_status={prob.status}\")\n\n\t\t\tutils.verify(epsilon.value>1e-8) #If not, there are no strictly feasible points in the subspace\n\t\t\t\t\t\t\t\t\t  \t\t #TODO: change hand-coded tolerance\n\n\t\t\tself.z0 = z0.value\n\t\t\tself.y0 = self.NA_E@self.z0 + self.yp\t\n\n\t\telse:\n\t\t\tself.y0 = y0\n\t\t\tself.z0 = self.NA_E.T@(self.y0-self.yp)\n\n\t\tutils.verify(np.allclose(NA_E.T@NA_E, np.eye(NA_E.shape[1]))) #By definition, N'*N=I\n\n\t\t###################### SET UP PROBLEM FOR PROJECTION\n\t\t###################################################\n\t\t#Section 8.1.1 of https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf\n\t\tself.y_projected = cp.Variable((self.k,1))         #projected point\n\t\tself.y_to_be_projected = cp.Parameter((self.k,1))  #original point\n\t\tconstraints=self.getConstraintsCvxpy(self.y_projected)\n\t\tobjective = cp.Minimize(cp.sum_squares(self.y_projected - self.y_to_be_projected))\n\t\tself.prob_projection = cp.Problem(objective, constraints)\n\t\t###################################################\n\n\n\tdef getDataAsDict(self):\n\n\t\tif self.has_linear_eq_constraints:\n\t\t\tA2=self.lc.A2;\n\t\t\tb2=self.lc.b2;\n\t\telse:\n\t\t\tA2=np.zeros((1, self.k))\n\t\t\tb2=np.array([[0]])\t\t\t #0==0 (i.e., no constraint)\n\n\t\tif self.has_linear_ineq_constraints:\n\t\t\tA1=self.lc.A1;\n\t\t\tb1=self.lc.b1;\n\t\telse:\n\t\t\tA1=np.zeros((1, self.k))\n\t\t\tb1=np.array([[1]])\t          #0<=0 (i.e., no constraint)\n\n\t\tif self.has_quadratic_constraints:\n\t\t\tall_P, all_q, all_r = utils.getAllPqrFromQcs(self.qcs)\t\n\t\telse:\n\t\t\tall_P=[np.zeros((self.k, self.k))]\n\t\t\tall_q=[np.zeros((self.k, 1))]\n\t\t\tall_r=[-np.ones((1, 1))]                    # -1<=0 (i.e., no constraint)\n\n\t\tif self.has_soc_constraints:\n\t\t\tall_M, all_s, all_c, all_d = utils.getAllMscdFromSocs(self.socs)\n\t\telse:\n\t\t\tall_M=[np.zeros((self.k, self.k))]\n\t\t\tall_s=[np.zeros((self.k, 1))]\n\t\t\tall_c=[np.zeros((self.k, 1))]                 \n\t\t\tall_d=[np.ones((1, 1))]                    # 0<=1 (i.e., no constraint)\n\n\t\tif(self.has_lmi_constraints):\n\t\t\tall_F=self.lmic.all_F\n\t\telse:\n\t\t\tall_F=[]\n\t\t\tfor i in range(self.k):\n\t\t\t\tall_F.append(np.zeros((self.k, self.k)))\n\t\t\tall_F.append(np.eye((self.k)))            # I<=0 (i.e., no constraint)\n\n\n\t\treturn dict(A2=A2, b2=b2, A1=A1, b1=b1, \n\t\t\t\t\tall_P=all_P, all_q=all_q, all_r=all_r, \n\t\t\t\t\tall_M=all_M, all_s=all_s, all_c=all_c, all_d=all_d,\n\t\t\t\t\tall_F=all_F)\n\n\n\n\t######################### CONSTRAINTS IN THE SUBSPACE\n\tdef getConstraintsInSubspaceCvxpy(self, z, epsilon=0.0):\n\n\t\tconstraints = [self.A_p@z - self.b_p <= -epsilon*np.ones((self.A_p.shape[0],1))]\n\n\t\ty=self.NA_E@z + self.yp\n\n\t\tconstraints+=self.getNonLinearConstraintsCvxpy(y, epsilon)\n\n\t\treturn constraints\n\t###########################################################################\n\n\tdef getNonLinearConstraintsCvxpy(self, y, epsilon=0.0):\n\n\t\tconstraints=[]\n\n\t\tfor qc in self.qcs:   \n\t\t\tconstraints += qc.asCvxpy(y, epsilon) \n\n\t\tfor soc in self.socs:   \n\t\t\tconstraints += soc.asCvxpy(y, epsilon) \n\n\t\tif(self.has_lmi_constraints):\n\t\t\tconstraints += self.lmic.asCvxpy(y, epsilon) \t\n\n\t\treturn constraints\t\n\n\tdef getConstraintsCvxpy(self, y, epsilon=0.0):\n\n\t\tconstraints=[]\n\n\t\tif(self.has_linear_constraints):\n\t\t\tconstraints += self.lc.asCvxpy(y, epsilon) \n\n\t\tconstraints+=self.getNonLinearConstraintsCvxpy(y, epsilon)\n\n\t\treturn constraints\n\n\n\t#######################################3\n\n\tdef project(self, y_to_be_projected):\n\n\t\tself.y_to_be_projected.value=y_to_be_projected;\n\t\tobj_value = self.prob_projection.solve(verbose=False, solver=self.solver);\n\n\t\tif(self.prob_projection.status != 'optimal' and self.prob_projection.status != 'optimal_inaccurate'):\n\t\t\traise Exception(f\"Value is not optimal, prob_status={self.prob_projection.status}\")\n\n\t\treturn self.y_projected.value, obj_value\t\n\n\tdef getViolation(self, y_to_be_projected):\n\n\t\tif(y_to_be_projected.ndim==1):\n\t\t\t#convert to a column vector\n\t\t\ty_to_be_projected=np.expand_dims(y_to_be_projected, axis=1)\n\n\t\t_, violation = self.project(y_to_be_projected)\n\n\t\t# assert violation>=0  #violation is nonnegative by definition\n\n\t\treturn violation;"]}
{"filename": "examples/cost_computer.py", "chunked_list": ["# --------------------------------------------------------------------------\n# Jesus Tordesillas Torres, Robotic Systems Lab, ETH Z\u00fcrich \n# See LICENSE file for the license information\n# -------------------------------------------------------------------------- \n\nimport torch\nimport torch.nn as nn\nimport numpy as np\nimport scipy\nimport cvxpy as cp", "import scipy\nimport cvxpy as cp\nimport math\nfrom cvxpylayers.torch import CvxpyLayer\nimport random\nimport copy\n\nimport fixpath #Following this example: https://github.com/tartley/colorama/blob/master/demos/demo01.py\nfrom rayen import utils\n", "from rayen import utils\n\n\n\nclass CostComputer(nn.Module): #Using nn.Module to be able to use register_buffer (and hence to be able to have the to() method)\n\tdef __init__(self, cs):\n\t\tsuper().__init__()\n\n\t\tif(cs.has_quadratic_constraints):\n\t\t\tall_P, all_q, all_r = utils.getAllPqrFromQcs(cs.qcs)\n\t\t\tself.register_buffer(\"all_P\", torch.Tensor(np.array(all_P)))\n\t\t\tself.register_buffer(\"all_q\", torch.Tensor(np.array(all_q)))\n\t\t\tself.register_buffer(\"all_r\", torch.Tensor(np.array(all_r)))\n\n\t\tif(cs.has_soc_constraints):\n\t\t\tall_M, all_s, all_c, all_d = utils.getAllMscdFromSocs(cs.socs)\n\t\t\tself.register_buffer(\"all_M\", torch.Tensor(np.array(all_M)))\n\t\t\tself.register_buffer(\"all_s\", torch.Tensor(np.array(all_s)))\n\t\t\tself.register_buffer(\"all_c\", torch.Tensor(np.array(all_c)))\n\t\t\tself.register_buffer(\"all_d\", torch.Tensor(np.array(all_d)))\n\n\t\t#See https://discuss.pytorch.org/t/model-cuda-does-not-convert-all-variables-to-cuda/114733/9\n\t\t# and https://discuss.pytorch.org/t/keeping-constant-value-in-module-on-correct-device/10129\n\t\tself.register_buffer(\"A_p\", torch.Tensor(cs.A_p))\n\t\tself.register_buffer(\"b_p\", torch.Tensor(cs.b_p))\n\t\tself.register_buffer(\"yp\", torch.Tensor(cs.yp))\n\t\tself.register_buffer(\"NA_E\", torch.Tensor(cs.NA_E))\n\t\tself.register_buffer(\"z0\", torch.Tensor(cs.z0))\n\n\t\tself.has_linear_ineq_constraints=cs.has_linear_ineq_constraints\n\t\tself.has_linear_eq_constraints=cs.has_linear_eq_constraints\n\t\tself.has_quadratic_constraints=cs.has_quadratic_constraints\n\t\tself.has_soc_constraints=cs.has_soc_constraints\n\t\tself.has_lmi_constraints=cs.has_lmi_constraints\n\n\t\tif self.has_linear_ineq_constraints:\n\t\t\tself.register_buffer(\"A1\", torch.Tensor(cs.lc.A1))\n\t\t\tself.register_buffer(\"b1\", torch.Tensor(cs.lc.b1))\n\n\t\tif self.has_linear_eq_constraints:\n\t\t\tself.register_buffer(\"A2\", torch.Tensor(cs.lc.A2))\n\t\t\tself.register_buffer(\"b2\", torch.Tensor(cs.lc.b2))\n\n\tdef getyFromz(self, z):\n\t\ty=self.NA_E@z + self.yp\n\t\treturn y\n\n\t#This function below assumes that y is in the plane spanned by the columns of NA_E!!\n\t# def getzFromy(self, y):\n\t# \tz=self.NA_E.T@(y - self.yp)\n\t# \treturn z\n\n\tdef getSumSoftCostAllSamples(self, y):\n\t\t################## STACK THE VALUES OF ALL THE INEQUALITIES\n\t\tall_inequalities=torch.empty((y.shape[0],0,1), device=y.device)\n\t\t##### Ap*z<=bp\n\t\t# z=self.getzFromy(y); #I cannot use this function, since this function assumes that y lies in \\mathcal{Y}_L\n\t\t\t\t\t\t\t   #I could use it for DC3, but not for the \"UU method\"\n\t\t# all_inequalities=torch.cat((all_inequalities, self.A_p@z-self.b_p), dim=1);\n\t\t##### A1*y<=b1\n\t\tif self.has_linear_ineq_constraints:\n\t\t\tall_inequalities=torch.cat((all_inequalities, self.A1@y-self.b1), dim=1);\n\n\t\t##### g(y)<=0\n\t\tif(self.has_quadratic_constraints):\n\t\t\tfor i in range(self.all_P.shape[0]):\n\t\t\t\tP=self.all_P[i,:,:]\n\t\t\t\tq=self.all_q[i,:,:]\n\t\t\t\tr=self.all_r[i,:,:]\n\t\t\t\tall_inequalities=torch.cat((all_inequalities, utils.quadExpression(y=y,P=P,q=q,r=r)), dim=1)\n\n\t\tif(self.has_soc_constraints):\n\t\t\tfor i in range(self.all_M.shape[0]):\n\t\t\t\tM=self.all_M[i,:,:]\n\t\t\t\ts=self.all_s[i,:,:]\n\t\t\t\tc=self.all_c[i,:,:]\n\t\t\t\td=self.all_d[i,:,:]\n\n\t\t\t\tlhs=torch.linalg.vector_norm(M@y + s, dim=1, keepdim=True) - c.T@y - d\n\n\t\t\t\tall_inequalities=torch.cat((all_inequalities, lhs), dim=1)\n\n\t\tif(self.has_lmi_constraints):\n\t\t\traise NotImplementedError \n\n\t\tsoft_cost = torch.sum(torch.square(torch.nn.functional.relu(all_inequalities)))\n\n\t\tif self.has_linear_eq_constraints:\n\t\t\tsoft_cost_equalities = torch.sum(torch.square(self.A2@y-self.b2)); #This is zero for the DC3 method, and nonzero for the UU method\n\t\t\tsoft_cost += soft_cost_equalities\n\n\t\t########################################################################\n\n\t\treturn soft_cost\n\n\n\tdef getSumObjCostAllSamples(self, y, Pobj, qobj, robj):\n\t\ttmp=utils.quadExpression(y=y,P=Pobj,q=qobj,r=robj)\n\t\tassert tmp.shape==(y.shape[0], 1, 1)\n\n\t\treturn torch.sum(tmp)\n\n\tdef getSumSupervisedCostAllSamples(self, y, y_predicted):\n\t\treturn torch.sum(torch.square(y-y_predicted))\n\n\tdef getSumLossAllSamples(self, params, y, y_predicted, Pobj, qobj, robj, isTesting=False):\n\n\t\tloss=0.0;\n\n\t\tif(params['use_supervised']):\n\t\t\tloss += self.getSumSupervisedCostAllSamples(y, y_predicted)\n\t\telse:\n\t\t\tloss += self.getSumObjCostAllSamples(y_predicted, Pobj, qobj, robj)\n\n\t\tif (isTesting==False and params['weight_soft_cost']>0): #I need the term params['weight_soft_cost']>0 because the soft cost is not implemented for LMI constraints yet\n\t\t\tloss += params['weight_soft_cost']*self.getSumSoftCostAllSamples(y_predicted)\n\n\t\t# loss=params['use_supervised']*self.getSumSupervisedCostAllSamples(y, y_predicted) + \\\n\t\t# \t (1-isTesting)*params['weight_soft_cost']*self.getSumSoftCostAllSamples(y_predicted) + \\\n\t\t# \t (1-params['use_supervised'])*self.getSumObjCostAllSamples(y_predicted, Pobj, qobj, robj)\n\n\t\treturn loss", ""]}
{"filename": "examples/other_utils.py", "chunked_list": ["# --------------------------------------------------------------------------\n# Jesus Tordesillas Torres, Robotic Systems Lab, ETH Z\u00fcrich \n# See LICENSE file for the license information\n# -------------------------------------------------------------------------- \n\n#It operates on numpy stuff \n#polytope defined as Ax<=b\ndef largestBallInPolytope(A,b, max_radius=None):\n\n\tif len(b.shape) == 1:\n\t\tb = np.expand_dims(b, axis=1) #Make b a column vector\n\n\tn=A.shape[1];\n\tr = cp.Variable()#A scalar\n\tx0 = cp.Variable((n,1))\n\tconstraints=[]\n\n\t#https://programtalk.com/vs2/python/2718/cvxpy/examples/chebyshev.py/\n\t#See also https://dkenefake.github.io/blog/ChebBall for when there are equality constraints\n\tfor i in range(A.shape[0]):\n\t\ta_i=A[i,:].T\n\t\tconstraints.append(r*cp.norm(a_i)+a_i.T@x0<=b[i,0])\n\n\tif(max_radius is not None):\n\t\tconstraints.append(r<=max_radius)\n\n\tobjective = cp.Minimize(-r) #This is just a linear program\n\tprob = cp.Problem(objective, constraints)\n\tprint(\"Calling solve...\")\n\tresult = prob.solve(verbose=False);\n\tprint(\"Solved!\")\n\tif(prob.status != 'optimal'):\n\t\traise Exception(\"Value is not optimal\")\n\n\tB=r*np.eye(n)\n\n\tprintInBoldGreen(f\"Found ball of radius r={r.value}\")\n\n\treturn B.value, x0.value", "\n\n# E representation --> {x s.t. (x-x0)'E(x-x0) <= 1}. Here, E is a psd matrix\n# B representation --> {x s.t. x=B*p_bar + x0, ||p_bar||<=1} \\equiv {x s.t. ||inv(B)(x-x0)||<=1} \\equiv {x s.t. (x-x0)'*inv(B)'*inv(B)*(x-x0)<=1}. \n# B is \\in R^nxn (although Boyd's book says we can assume B is psd (and therefore also symmetric) without loss of generality, see section 8.4.1\n# More info about the B representation: https://ieeexplore.ieee.org/abstract/document/7839930\n\n#It returns the ellipsoid in B representation\n#It operates on numpy stuff \ndef largestEllipsoidBInPolytope(A,b):\n\n\tif len(b.shape) == 1:\n\t\tb = np.expand_dims(b, axis=1) #Make b a column vector\n\n\tn=A.shape[1];\n\tB = cp.Variable((n,n), symmetric=True)\n\tx0 = cp.Variable((n,1))\n\tconstraints=[]\n\n\t#Eq. 8.15 of https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf\n\t#Also http://web.cvxr.com/cvx/examples/cvxbook/Ch08_geometric_probs/html/max_vol_ellip_in_polyhedra.html\n\tfor i in range(A.shape[0]):\n\t\ta_i=A[i,:].T\n\t\tconstraints.append(cp.norm(B@a_i)+a_i.T@x0<=b[i,0])\n\n\tobjective = cp.Minimize(-cp.atoms.log_det(B))\n\tprob = cp.Problem(objective, constraints)\n\tprint(\"Calling solve...\")\n\tresult = prob.solve(verbose=True);\n\tprint(\"Solved!\")\n\n\treturn B.value, x0.value", "#It operates on numpy stuff \ndef largestEllipsoidBInPolytope(A,b):\n\n\tif len(b.shape) == 1:\n\t\tb = np.expand_dims(b, axis=1) #Make b a column vector\n\n\tn=A.shape[1];\n\tB = cp.Variable((n,n), symmetric=True)\n\tx0 = cp.Variable((n,1))\n\tconstraints=[]\n\n\t#Eq. 8.15 of https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf\n\t#Also http://web.cvxr.com/cvx/examples/cvxbook/Ch08_geometric_probs/html/max_vol_ellip_in_polyhedra.html\n\tfor i in range(A.shape[0]):\n\t\ta_i=A[i,:].T\n\t\tconstraints.append(cp.norm(B@a_i)+a_i.T@x0<=b[i,0])\n\n\tobjective = cp.Minimize(-cp.atoms.log_det(B))\n\tprob = cp.Problem(objective, constraints)\n\tprint(\"Calling solve...\")\n\tresult = prob.solve(verbose=True);\n\tprint(\"Solved!\")\n\n\treturn B.value, x0.value", "\n\n\ndef makeColumnVector(a):\n\treturn a[:,None]\n\n#Operates on torch stuff\ndef squared_norm_of_each_row(D):\n\t# print(f\"D**2.shape={(D**2).shape}\")\n\tresult=torch.sum(D**2, dim=2, keepdim=True)\n\t# print(f\"result.shape={result.shape}\")\n\n\treturn result  #@torch.ones((D.shape[1],1),device=D.device)", "\n#Operates on torch stuff\ndef scaleEllipsoidB(B,A,b,x0):\n\n\t# print(\"\\n\\n\")\n\t# # #====================First way==========================\n\t# # ========================================================\n\t# minimum_so_far=torch.Tensor([float(\"inf\")])\n\t# for i in range(torch.numel(b)):\n\t# \t# print(A[i,:])\n\t# \ta_i=makeColumnVector(A[i,:])\n\t\t\n\t# \ttmp=(b[i,0]-a_i.mT@x0)**2/(a_i.mT@B@B.T@a_i);\n\t# \t# print(f\"numerator={(b[i,0]-a_i.mT@x0)**2}, denominator={a_i.mT@B@B.T@a_i}, result={tmp}\")\n\t# \t# print(f\"tmp is {tmp}\")\n\t# \t# print(f\"tmp[0,0] is {tmp[0]}\")\n\t# \tminimum_so_far=torch.minimum(minimum_so_far, tmp[0,0])\n\n\t# # print(f\"-------> minimum so far={minimum_so_far}\")\n\n\t# result = B*torch.sqrt(minimum_so_far);\n\t# print(f\"First way: \\n {result}\")\n\n\t# # #===================Second way==========================\n\t# # ========================================================\n\t# c=squared_norm_of_each_row(A@B)\n\t# e=torch.min(((b-A@x0)**2)/c)\n\t# result=B*torch.sqrt(e)\n\t# print(f\"Second way: \\n {result}\")\n\t\n\t# #===================Third way==========================\n\t# ========================================================\n\t\n\tsqrt_c=torch.sqrt(squared_norm_of_each_row(A@B)) #This could be computed in the constructor (and not in each forward call)\n\n\t# print(f\"sqrt_c={sqrt_c}\")\n\n\n\tAx0=A@x0;\n\tb_minus_Ax0=torch.sub(torch.unsqueeze(b,dim=0),Ax0)\n\tabs_b_minus_Ax0=torch.abs(b_minus_Ax0) #Note that if x0 is inside the ellipsoid, then I don't need the abs(), since Ax0<=b --> b-Ax0>=0\n\tabs_b_minus_Ax0_divided_by_sqrt_c=torch.div(abs_b_minus_Ax0,sqrt_c)\n\ttmp=torch.min(abs_b_minus_Ax0_divided_by_sqrt_c,dim=1,keepdim=True)\n\tsqrt_e=tmp.values\n\tresult=B*sqrt_e\n\t# print(f\"Third way: \\n {result}\")\n\n\treturn result;", "\n\n\t# sqrt\n\n\t# print(f\"sqrt_e={sqrt_e}\")\n\n\n\t# print(f\"sqrt_e.shape={sqrt_e.shape}\")\n\t# print(f\"B.shape={B.shape}\")\n", "\t# print(f\"B.shape={B.shape}\")\n\n\n\t# print(\"-------------\\n\")\n\t# print(f\"x0.shape={x0.shape}\")\n\t\n\t# print(f\"B.shape={B.shape}\")\n\t# print(f\"A.shape={A.shape}\")\n\t# print(f\"A@B.shape={(A@B).shape}\")\n\t# print(f\"b.shape={b.shape}\")", "\t# print(f\"A@B.shape={(A@B).shape}\")\n\t# print(f\"b.shape={b.shape}\")\n\n\n\t# print(\"==============================\")\n\t# print(f\"A={A}\")\n\t# print(f\"B={B}\")\n\t# print(f\"b={b}\")\n\t# print(f\"x0={x0}\\n\")\n", "\t# print(f\"x0={x0}\\n\")\n\n\ndef plot2DEllipsoidB(B,x0,ax):\n\tx1, x2 = sympy.symbols('x1 x2')\n\tx=np.array([[x1],[x2]])\n\ttry:\n\t\tB_inv=np.linalg.inv(B);\n\texcept np.linalg.LinAlgError as err:\n\t\tprint(str(err))\n\t\treturn\n\ttmp=(x-x0).T@B_inv.T@B_inv@(x-x0)-1 #This is [[scalar]]\n\texpression=tmp[0,0]; \n\tf=sympy.lambdify([x1,x2], expression)\n\n\teigenvalues=np.linalg.eigvals(B)\n\ttmp_eig=np.amax(eigenvalues);\n\txx = np.linspace(x0[0,0]-tmp_eig, x0[0,0]+tmp_eig, 600)\n\tyy = np.linspace(x0[1,0]-tmp_eig, x0[1,0]+tmp_eig, 600)\n\txxx, yyy = np.meshgrid(xx, yy)\n\tresult=f(xxx, yyy)\n\tax.contour(xxx, yyy, result, levels=[0])", "\n\t#OTHER OPTION, but you run into this visualization issue: https://github.com/sympy/sympy/issues/20056\n\t# tmp=sympy.plot_implicit(expression,show=True,points=300, adaptive=False, depth = 2)\n\t# move_sympyplot_to_axes(tmp, ax)\n\t# pts = tmp.get_points()\n\t# plt.plot(pts[0], pts[1])"]}
{"filename": "examples/main.py", "chunked_list": ["# --------------------------------------------------------------------------\n# Jesus Tordesillas Torres, Robotic Systems Lab, ETH Z\u00fcrich \n# See LICENSE file for the license information\n# -------------------------------------------------------------------------- \n\nimport sys\nimport os\nimport time\nimport numpy as np\nimport torch", "import numpy as np\nimport torch\nimport torch.nn as nn\nimport argparse\nimport itertools\nimport pandas as pd\nfrom torch.utils.data import DataLoader\nfrom early_stopping import EarlyStopping\n\nfrom cost_computer import CostComputer", "\nfrom cost_computer import CostComputer\nfrom create_dataset import createProjectionDataset, getCorridorDatasets, getCorridorConstraints\nfrom examples_sets import getExample\n\nimport tqdm\n\nimport waitGPU\n\nimport random", "\nimport random\nimport time\n\nfrom torch.utils.tensorboard import SummaryWriter\n\nimport uuid\nimport scipy\n\n", "\n\nimport fixpath #Following this example: https://github.com/tartley/colorama/blob/master/demos/demo01.py\nfrom rayen import constraints, constraint_module, utils\n\nclass SplittedDatasetAndGenerator():\n\tdef __init__(self, dataset, percent_train, percent_val, batch_size):\n\t\tassert percent_train<=1\n\t\tassert percent_val<=1\n\t\tassert (percent_train+percent_val)<=1\n\n\t\ttrain_size = int(percent_train * len(dataset))\n\t\tval_size = int(percent_val * len(dataset))\n\t\ttest_size = len(dataset) - train_size - val_size\n\n\t\t# train_size = 1\n\t\t# val_size = 1\n\t\t# test_size = 1\n\n\t\t#First option\n\t\t# self.train_dataset, self.val_dataset, self.test_dataset = torch.utils.data.random_split(dataset, [train_size, val_size, test_size])\n\n\t\t#Second option (Matlab is already doing the randomness). Don't randomize here so that all the methods use the same datasets\n\t\t#See https://stackoverflow.com/a/70278974\n\t\tself.train_dataset = torch.utils.data.Subset(dataset, range(train_size))\n\t\tself.val_dataset = torch.utils.data.Subset(dataset, range(train_size, train_size + val_size))\n\t\tself.test_dataset = torch.utils.data.Subset(dataset, range(train_size + val_size, train_size + val_size + test_size))\n\n\n\t\t# assert len(self.train_dataset)>0\n\t\t# assert len(self.val_dataset)>0\n\t\t# assert len(self.test_dataset)>0\n\n\t\tutils.printInBoldRed(f\"Elements [train, val, test]={[len(self.train_dataset), len(self.val_dataset), len(self.test_dataset)]}\")\n\n\t\tself.batch_size=batch_size\n\n\t\tif(len(self.train_dataset)>0):\n\t\t\tself.train_generator = DataLoader(self.train_dataset, batch_size=batch_size, shuffle=True)\n\t\t\tutils.printInBoldRed(f\"Train batches {len(self.train_generator)}\")\n\n\n\t\tif(len(self.val_dataset)>0):\n\t\t\tself.val_generator = DataLoader(self.val_dataset, batch_size=batch_size, shuffle=False)\n\t\t\tutils.printInBoldRed(f\"Val batches {len(self.val_generator)}\")\n\n\n\t\tif(len(self.test_dataset)>0): #len(self.test_dataset)\n\t\t\tself.test_generator = DataLoader(self.test_dataset, batch_size=len(self.test_dataset), shuffle=False) #One batch only for testing [better inference time estimation]\n\t\t\tutils.printInBoldRed(f\"Test batches {len(self.test_generator)}\")", "\n\n\ndef onePassOverDataset(model, params, sdag, my_type):\n\n\tcs=model[-1].cs\n\n\tcost_computer=CostComputer(cs)\n\n\tdevice = torch.device(params['device'])\n\tmodel = model.to(device)\n\tcost_computer = cost_computer.to(device)\n\n\tif(my_type=='train'):\n\t\tmodel.train()\n\t\tgenerator=sdag.train_generator\n\t\tenable_grad=True;\n\t\toptimizer = torch.optim.Adam(model.parameters(),lr=params['learning_rate'])\n\n\telif(my_type=='val'):\n\t\tmodel.eval()\n\t\tgenerator=sdag.val_generator\n\t\tenable_grad=False;\n\telif(my_type=='test'):\n\t\tmodel.eval()\n\t\tgenerator=sdag.test_generator\n\t\tenable_grad=False;\n\telse:\n\t\traise NotImplementedError\n\n\tsum_all_losses=0.0\n\tsum_time_s=0.0\n\n\tif(my_type=='test'):\n\t\tsum_all_violations=0.0\n\t\tsum_all_losses_optimization=0.0\n\t\tsum_all_time_s_optimization=0.0\n\t\tsum_all_violations_optimization=0.0\n\n\n\tcuda_timer=utils.CudaTimer()\n\n\tall_x=[]\n\tall_y=[]\n\tall_y_predicted=[]\n\n\tnum_nan_samples= 0\n\n\twith torch.set_grad_enabled(enable_grad):\n\t\tfor x, y, Pobj, qobj, robj, opt_time_s, cost in generator: #For each of the batches\t\n\n\t\t\t#----------------------\n\t\t\tx = x.to(device)\n\t\t\ty = y.to(device)\n\t\t\t\n\t\t\tcuda_timer.start()\n\t\t\ty_predicted = model(x)\n\t\t\tsum_time_s += cuda_timer.endAndGetTimeSeconds()\n\n\t\t\t#Remove samples that generated nans (happens sometimes in DC3)\n\t\t\tis_nan=torch.squeeze(torch.any(y_predicted.isnan(),dim=1)).cpu();\n\t\t\tnum_nan_samples += torch.sum(is_nan==True).item()\n\t\t\tx = x[~is_nan,:,:]\n\t\t\ty = y[~is_nan,:,:]\n\t\t\tPobj = Pobj[~is_nan,:,:]\n\t\t\tqobj = qobj[~is_nan,:,:]\n\t\t\trobj = robj[~is_nan,:,:]\n\t\t\topt_time_s = opt_time_s[~is_nan,:,:]\n\t\t\tcost = cost[~is_nan,:,:]\n\t\t\ty_predicted = y_predicted[~is_nan,:,:]\n\n\n\t\t\tloss=cost_computer.getSumLossAllSamples(params, y, y_predicted, Pobj, qobj, robj, isTesting=(my_type=='test'))\n\t\t\t# print(f\"Loss={loss.item()}\")\n\t\t\tsum_all_losses +=  loss.item();\n\n\t\t\t# Save all the values\n\t\t\tall_x.append(x.cpu().detach().numpy()) #Could also be accessed directly from the dataset\n\t\t\tall_y.append(y.cpu().detach().numpy()) #Could also be accessed directly from the dataset\n\t\t\tall_y_predicted.append(y_predicted.cpu().detach().numpy())\n\n\t\t\t#----------------------\n\n\t\t\tif(my_type=='train'):\n\t\t\t\tnum_samples_this_batch=x.shape[0];\n\t\t\t\tloss_per_sample_in_batch=loss/num_samples_this_batch;\n\t\t\t\toptimizer.zero_grad()\n\t\t\t\tloss_per_sample_in_batch.backward()\n\t\t\t\toptimizer.step()\n\n\n\t\t\tif(my_type=='test'):\n\t\t\t\tprint(\"Computing violations...\")\n\t\t\t\tsum_all_violations += np.sum(np.apply_along_axis(cs.getViolation,axis=1, arr=y_predicted.cpu().numpy())).item()\n\t\t\t\tprint(\"Violations computed\")\n\n\t\t\t\t###### compute the results from the optimization. TODO: Change to a different place?\n\t\t\t\ty_predicted=y\n\t\t\t\tloss_optimization=cost_computer.getSumLossAllSamples(params, y, y_predicted, Pobj, qobj, robj, isTesting=True)\n\t\t\t\tsum_all_losses_optimization += loss_optimization.item();\n\t\t\t\t# print(f\"Loss Opt={loss_optimization.item()}\")\n\t\t\t\t# print(f\"Original Loss Opt={torch.sum(cost).item()}\")\n\t\t\t\tassert abs(loss_optimization.item()-torch.sum(cost).item())<0.001\n\n\t\t\t\tprint(\"Computing violations optimization...\")\n\t\t\t\tsum_all_violations_optimization += np.sum(np.apply_along_axis(cs.getViolation,axis=1, arr=y_predicted.cpu().numpy())).item()\n\t\t\t\tprint(\"Violations computed\")\n\t\t\t\tsum_all_time_s_optimization += torch.sum(opt_time_s).item()\n\t\t\t\t#########################################################\n\n\n\tnum_samples_dataset=len(generator.dataset) - num_nan_samples;\n\n\t#############################\n\n\tresults={};\n\tresults['loss']=sum_all_losses/num_samples_dataset\n\n\tif(my_type=='test'):\n\t\tresults['violation']=                    sum_all_violations/num_samples_dataset\n\t\tresults['time_s']=                       sum_time_s/num_samples_dataset\n\t\tresults[\"optimization_loss\"]=            sum_all_losses_optimization/num_samples_dataset\n\t\tresults[\"optimization_violation\"]=       sum_all_violations_optimization/num_samples_dataset\n\t\tresults[\"optimization_time_s\"]=    sum_all_time_s_optimization/num_samples_dataset\n\t\tresults[\"all_x\"]=    all_x\n\t\tresults[\"all_y\"]=    all_y\n\t\tresults[\"all_y_predicted\"]=    all_y_predicted\n\t\tresults[\"percentage_converged\"]=    100*(1-num_nan_samples/len(generator.dataset))\n\n\t#############################\n\n\treturn results", "\n\n\ndef train_model(model, params, sdag, tensorboard_writer, cs):\n\tmodel = model.to(torch.device(params['device']))\n\toptimizer = torch.optim.Adam(model.parameters(),lr=params['learning_rate'])\n\n\tresults_all_epochs = {'train_loss': [], 'val_loss': []}\n\t\n\tmy_early_stopping = EarlyStopping(patience=1e100, verbose=False)\n\n\t#See https://pytorch.org/tutorials/beginner/blitz/cifar10_tutorial.html\n\n\t# with tqdm.trange(params['num_epochs'], ncols=120) as pbar:\n\t\t# for epoch in pbar:\n\n\t# scheduler = torch.optim.lr_scheduler.ReduceLROnPlateau(optimizer, 'min')\n\n\tfor epoch in range(params['num_epochs']):\n\n\t\t# pbar.set_description(f\"Epoch {epoch}\")\n\n\t\tresults_training_this_epoch = onePassOverDataset(model, params, sdag, 'train')\n\t\tresults_validation_this_epoch = onePassOverDataset(model, params, sdag, 'val')\n\t\tmy_early_stopping(results_validation_this_epoch['loss'], model)\n\n\t\tresults_all_epochs['train_loss'].append(results_training_this_epoch['loss']) \n\t\tresults_all_epochs['val_loss'].append(results_validation_this_epoch['loss']) \n\t\t\n\t\tif epoch % params['verbosity'] == 0:\n\t\t\tprint(f\"[{params['method']}, w={params['weight_soft_cost']}] {epoch}: train: {results_all_epochs['train_loss'][-1]:.4}, val: {results_all_epochs['val_loss'][-1]:.4}, best_val={my_early_stopping.val_loss_min:.4}\")\n\n\t\t# scheduler.step(results_validation_this_epoch['loss'])\n\n\t\t#This creates two separate plots\n\t\t# tensorboard_writer.add_scalar(\"Loss/train\", results_all_epochs['train_loss'][-1], epoch)\n\t\t# tensorboard_writer.add_scalar(\"Loss/val\", results_all_epochs['val_loss'][-1], epoch)\n\n\t\t#This createst one plot\n\t\ttensorboard_writer.add_scalars('loss', {'train':results_all_epochs['train_loss'][-1], 'val':results_all_epochs['val_loss'][-1]}, epoch)\n\n\t\t# pbar.set_postfix(loss=results_all_epochs['train_loss'][-1], val=results_all_epochs['val_loss'][-1])\n\n\t\t# if my_early_stopping.early_stop:\n\t\t# \tprint(\"Early stopping\")\n\t\t# \t#Delete the last elements, see https://stackoverflow.com/a/15715924\n\t\t# \tdel results_all_epochs['train_loss'][-my_early_stopping.patience:]\n\t\t# \tdel results_all_epochs['val_loss'][-my_early_stopping.patience:]\n\t\t# \tbreak\n\n\tmy_early_stopping.load_best_model(model)\n\n\t# results_validation_this_epoch = onePassOverDataset(model, params, sdag, 'val')\n\t# print(f\"results_validation_this_epoch={results_validation_this_epoch}\")\n\n\ttensorboard_writer.flush()\n\n\treturn results_all_epochs", "\n\ndef main(params):\n\n\n\t################# To launch tensorboard directly\n\t# import os\n\t# import subprocess\n\t# folder=\"runs\"\n\t# os.system(\"pkill -f tensorboard\")\n\t# os.system(\"rm -rf \"+folder)\n\t# proc1 = subprocess.Popen([\"tensorboard\",\"--logdir\",folder,\"--bind_all\"], stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)\n\t# proc2 = subprocess.Popen([\"google-chrome\",\"http://localhost:6006/\"], stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)\n\t############################################\n\n\ttorch.set_default_dtype(torch.float64) #This is very important. If you use float32, you may end up with a \"large\" negative discriminant (like -0.000259) in solveSecondOrderEq \n\t\t\t\t\t\t\t\t\t\t   #This is also related to the fact that the P matrices need to be PSD matrices (while numerically this is sometimes difficult to achieve)\n\n\ttensorboard_writer = SummaryWriter()\n\n\tmy_dataset, my_dataset_out_dist=getCorridorDatasets(params['dimension_dataset'])\n\n\tsdag=SplittedDatasetAndGenerator(my_dataset, percent_train=0.5045, percent_val=0.2, batch_size=params['batch_size'])\n\tsdag_out_dist=SplittedDatasetAndGenerator(my_dataset_out_dist, percent_train=0.0, percent_val=0.0, batch_size=params['batch_size'])\n\n\tif(params['method']=='DC3'):\n\t\targs_DC3={}\n\t\targs_DC3['lr'] = params['DC3_lr']\n\t\targs_DC3['eps_converge'] = params['DC3_eps_converge']\n\t\targs_DC3['momentum'] = params['DC3_momentum']\n\t\targs_DC3['max_steps_training'] = params['DC3_max_steps_training']\n\t\targs_DC3['max_steps_testing'] = params['DC3_max_steps_testing']\n\telse:\n\t\targs_DC3 = None\n\n\tfolder=\"./scripts/results/\"\n\tname_file='dataset'+str(params['dimension_dataset'])+'d_'+params['method']+\"_weight_soft_cost_\"+str(params[\"weight_soft_cost\"])    #+uuid.uuid4().hex #https://stackoverflow.com/a/62277811\n\tpath_policy = folder + name_file +\".pt\"\n\tpath_training_results = folder + \"results_train_\" + name_file +\".mat\"\n\tpath_testing_in_dist_results = folder + \"results_test_in_dist_\" + name_file +\".mat\"\n\tpath_testing_out_dist_results = folder + \"results_test_out_dist_\" + name_file +\".mat\"\n\n\tfor i in range(torch.cuda.device_count()):\n\t   print(torch.cuda.get_device_properties(i).name)\n\n\tsleep_time=random.randint(0,20)\n\tprint(f\"Sleeping for {sleep_time} s\")\n\ttime.sleep(sleep_time) #Without this, you get the errors CUBLAS_STATUS_NOT_INITIALIZED or CUDA out of memory when running several training processes in parallel\n\twaitGPU.wait(utilization=50, memory_ratio=0.5, interval=random.randint(1, 20), available_memory=2000) #This is to avoid errors like \"CUDA error: CUBLAS_STATUS_NOT_INITIALIZED\" when launching many trainings in parallel\n\tprint(\"Done waiting for GPU\")\n  \n\n\tif(params['train']==True):\n\n\t\t## PROJECTION EXAMPLES\n\t\t# cs=getExample(4)\n\t\t# my_dataset=createProjectionDataset(200, cs, 4.0);\n\t\t# my_dataset_out_dist=createProjectionDataset(200, cs, 7.0);\n\n\t\t## CORRIDOR EXAMPLES\n\t\t\n\t\tcs=getCorridorConstraints(params['dimension_dataset'])\n\n\t\t#Slide 4 of https://fleuret.org/dlc/materials/dlc-handout-4-6-writing-a-module.pdf\n\t\tmodel = nn.Sequential(nn.Flatten(),\n\t\t\t\t\t\t\t  # nn.BatchNorm1d(my_dataset.getNumelX()),\n\t\t\t\t\t\t\t  nn.Linear(my_dataset.getNumelX(), 64), \n\t\t\t\t\t\t\t  nn.ReLU(),\n\t\t\t\t\t\t\t  nn.BatchNorm1d(64),\n\t\t\t\t\t\t\t  nn.Linear(64, 64),\n\t\t\t\t\t\t\t  nn.ReLU(),\n\t\t\t\t\t\t\t  nn.Linear(64, 64),\n\t\t\t\t\t\t\t  constraint_module.ConstraintModule(cs, input_dim=64, method=params['method'], create_map=True, args_DC3=args_DC3)) \n\n\t\ttraining_results = train_model(model, params, sdag, tensorboard_writer, cs)\n\n\t\t# utils.savepickle(training_results, path_training_results)\n\t\tscipy.io.savemat(path_training_results, training_results)\n\n\t\t# torch.save(model.state_dict(), path_policy)  #Save only weights. Will not work properly if the value of any class variable of ConstraintModule changes between different calls\n\t\ttorch.save(model, path_policy)                 #Save entire model, see https://pytorch.org/tutorials/beginner/saving_loading_models.html#save-load-entire-model\n\n\n\n\tif(params['test']==True):\n\n\t\t# model.load_state_dict(torch.load(path_policy)) #See explanation in the save() function above\n\t\tmodel = torch.load(path_policy) #See # https://pytorch.org/tutorials/beginner/saving_loading_models.html#save-load-entire-model\n\t\t\n\t\tutils.printInBoldGreen(\"Warming up GPU for a better estimate of the computation time...\")\n\t\tx_dummy=torch.Tensor(500, my_dataset.getNumelX(), 1).uniform_(-5.0, 5.0) #Just run some dummy operations on the GPU to warm it up\n\t\tx_dummy=x_dummy.to(torch.device(params['device']))\n\t\t_ = model(x_dummy)\n\n\t\tutils.printInBoldGreen(\"Testing model inside dist...\")\n\t\ttesting_results_in_dist = onePassOverDataset(model, params, sdag, 'test')\n\t\tutils.printInBoldGreen(\"Testing model outside dist...\")\n\t\ttesting_results_out_dist = onePassOverDataset(model, params, sdag_out_dist, 'test')\n\n\t\t# utils.savepickle(testing_results_in_dist, path_testing_in_dist_results)\n\t\t# utils.savepickle(testing_results_out_dist, path_testing_out_dist_results)\n\n\t\tscipy.io.savemat(path_testing_in_dist_results, testing_results_in_dist)\n\t\tscipy.io.savemat(path_testing_out_dist_results, testing_results_out_dist)\n\n\t\tnum_trainable_params=sum(\tp.numel() for p in model.parameters() if p.requires_grad)\n\n\t\td = {'method': \t\t\t\t              [name_file,                                       'dataset'+str(params['dimension_dataset'])+'d_'+'Optimization'],\n\t\t\t 'num_trainable_params':              [num_trainable_params,         \t                0], \n\t\t\t'[In dist] loss':                     [testing_results_in_dist['loss'],      \t        testing_results_in_dist['optimization_loss']      ], \n\t\t\t'[In dist] violation':                [testing_results_in_dist['violation'], \t        testing_results_in_dist['optimization_violation'] ],\n\t\t\t'[In dist] percentage_converged':     [testing_results_in_dist['percentage_converged'], 100 ],\n\t\t\t'[In dist] time_us':                  [1e6*testing_results_in_dist['time_s'],           1e6*testing_results_in_dist['optimization_time_s'] ],\n\t\t\t#\n\t\t\t'[Out dist] loss':                    [testing_results_out_dist['loss'],      \t  testing_results_out_dist['optimization_loss']      ], \n\t\t\t'[Out dist] violation':               [testing_results_out_dist['violation'], \t  testing_results_out_dist['optimization_violation'] ],\n\t\t\t'[Out dist] percentage_converged':    [testing_results_out_dist['percentage_converged'], 100 ],\n\t\t\t'[Out dist] time_us':                 [1e6*testing_results_out_dist['time_s'],     1e6*testing_results_out_dist['optimization_time_s'] ]}\n\n\n\t\tdf = pd.DataFrame(data=d)\n\n\t\tpd.set_option('display.max_columns', None)\n\t\tprint(df)\n\n\t\tpath_pkl = folder + name_file +\".pkl\"\n\n\t\tdf.to_pickle(path_pkl) \t\n\n\ttensorboard_writer.close()", "\n#See https://stackoverflow.com/a/43357954/6057617\ndef str2bool(v):\n\tif isinstance(v, bool):\n\t\treturn v\n\tif v.lower() in ('yes', 'true', 't', 'y', '1'):\n\t\treturn True\n\telif v.lower() in ('no', 'false', 'f', 'n', '0'):\n\t\treturn False\n\telse:\n\t\traise argparse.ArgumentTypeError('Boolean value expected.')", "\n\nif __name__ == '__main__':\n\n\tutils.printInBoldGreen(\"\\n\\n\\n==========================================\")\n\n\tparser = argparse.ArgumentParser()\n\tparser.add_argument('--method', type=str, default='Bar') #RAYEN_old, RAYEN, Bar, UU, PP, UP, DC3\n\tparser.add_argument('--dimension_dataset', type=int, default=2)\n\tparser.add_argument('--use_supervised', type=str2bool, default=False)\n\tparser.add_argument('--weight_soft_cost', type=float, default=0.0)\n\tparser.add_argument('--device', type=str, default='cuda:0')\n\tparser.add_argument('--num_epochs', type=int, default=2000)\n\tparser.add_argument('--batch_size', type=int, default=256)\n\tparser.add_argument('--verbosity', type=int, default=1)\n\tparser.add_argument('--learning_rate', type=float, default=1e-4)\n\tparser.add_argument('--train', type=str2bool, default=True)\n\tparser.add_argument('--test', type=str2bool, default=True)\n\t#Parameters specific to DC3\n\tparser.add_argument('--DC3_lr', type=float, default=1e-5)            #Sometimes the DC3 inner gradient correction does not converge if this lr is high \n\tparser.add_argument('--DC3_eps_converge', type=float, default=4e-7)\n\tparser.add_argument('--DC3_momentum', type=float, default=0.5)\n\tparser.add_argument('--DC3_max_steps_training', type=int, default=10)\n\tparser.add_argument('--DC3_max_steps_testing', type=int, default=500) #float(\"inf\")\n\n\n\targs = parser.parse_args()\n\tparams = vars(args)\n\n\tshouldnt_have_soft_cost=(params['method']=='RAYEN_old' or params['method']=='RAYEN' or params['method']=='Bar' or params['method']=='PP')\n\t\n\n\t# should_have_soft_cost=(\n\t# \t\t\t\t\t\t#Note that DC3 should have soft cost when training, see third paragraph of Section 3.2 of the DC3 paper\n\t# \t\t\t\t\t\t(params['method']=='DC3') or\n\t# \t\t\t\t\t\t(params['method']=='UP' and params['use_supervised']==False) or\n\t# \t\t\t\t\t\t(params['method']=='UU' and params['use_supervised']==False)\n\t# \t\t\t\t\t\t)\n\n\t# if(should_have_soft_cost):\n\t# \tassert params['weight_soft_cost']>0\n\n\tif(shouldnt_have_soft_cost):\n\t\tassert params['weight_soft_cost']==0\n\n\tprint('Parameters:\\n', params)\n\n\n\tmain(params)"]}
{"filename": "examples/examples_sets.py", "chunked_list": ["# --------------------------------------------------------------------------\n# Jesus Tordesillas Torres, Robotic Systems Lab, ETH Z\u00fcrich \n# See LICENSE file for the license information\n# -------------------------------------------------------------------------- \n\nimport numpy as np\n# import sys, os\n# sys.path.insert(1, os.path.join(sys.path[0], '..'))  #See first comment of this answer: https://stackoverflow.com/a/11158224\n# import constraints\nimport fixpath", "# import constraints\nimport fixpath\nfrom rayen import constraints\n\n\ndef getCube():\n\tA1=np.array([ [1.0, 0, 0],\n\t\t\t\t  [0, 1.0, 0],\n\t\t\t\t  [0, 0, 1.0],\n\t\t\t\t  [-1.0, 0, 0],\n\t\t\t\t  [0, -1.0, 0],\n\t\t\t\t  [0, 0, -1.0]]);\n\n\tb1=np.array([[1.0],\n\t\t\t\t[1.0],\n\t\t\t\t[1.0],\n\t\t\t\t[0],\n\t\t\t\t[0],\n\t\t\t\t[0]])\n\n\treturn A1, b1", "\n#Ellipsoid is defined as {x | (x-c)'E(x-c)<=1}\n#Where E is a positive semidefinite matrix\ndef getEllipsoidConstraint(E, c):\n\t#Convert to (1/2)x'P_ix + q_i'x +r_i <=0\n\tP=2*E;\n\tq=(-2*E@c)\n\tr=c.T@E@c-1\n\treturn constraints.ConvexQuadraticConstraint(P, q, r)\n", "\n#Sphere of radius r centered around c\ndef getSphereConstraint(r, c):\n\treturn getEllipsoidConstraint((1/(r*r))*np.eye(c.shape[0]),c)\n\ndef getParaboloid3DConstraint():\n\tP=np.array([[1.0, 0.0, 0.0],\n\t\t\t\t[0.0, 1.0, 0.0],\n\t\t\t\t[0.0, 0.0, 0.0]])\n\tq=np.array([[0.0],[0.0],[-1.0]])\n\tr=np.array([[0.0]])\n\n\treturn constraints.ConvexQuadraticConstraint(P,q,r)", "\ndef getSOC3DConstraint():\n\tM=np.array([[1.0, 0.0, 0.0],\n\t\t\t\t[0.0, 1.0, 0.0],\n\t\t\t\t[0.0, 0.0, 0.0]])\n\ts=np.array([[0.0],[0.0],[0.0]])\n\tc=np.array([[0.0],[0.0],[1.0]])\n\td=np.array([[0.0]])\n\n\treturn constraints.SOCConstraint(M, s, c, d)", "\ndef getPSDCone3DConstraint():\n\t#[x y;y z] >> 0\n\tF0=np.array([[1.0, 0.0],\n\t\t\t\t [0.0, 0.0]])\n\n\tF1=np.array([[0.0, 1.0],\n\t\t\t\t [1.0, 0.0]])\n\n\tF2=np.array([[0.0, 0.0],\n\t\t\t\t [0.0, 1.0]])\n\n\tF3=np.array([[0.0, 0.0],\n\t\t\t\t [0.0, 0.0]])\n\n\treturn constraints.LMIConstraint([F0, F1, F2, F3])", "\ndef getNoneLinearConstraints():\n\treturn None, None, None, None\n\ndef getNoneQuadraticConstraints():\n\treturn [], [], []\n\ndef getExample(example):\n\n\t# A1, b1, A2, b2 = getNoneLinearConstraints()\n\t# all_P, all_q, all_r = getNoneQuadraticConstraints()\n\tlc=None\n\tqcs=[]\n\tsocs=[]\n\tlmic=None\n\n\tif example==0: #A 2D polygon embeded in 3D\n\t\tA1, b1=getCube()\n\t\tA2=np.array([[1.0, 1.0, 1.0]]);\n\t\tb2=np.array([[1.0]]);\n\t\tlc=constraints.LinearConstraint(A1, b1, A2, b2)\n\n\telif example==1: #A polygon embeded in 3D with an sphere\n\n\t\tA1, b1=getCube()\n\t\tA2=np.array([[1.0, 1.0, 1.0]]);\n\t\tb2=np.array([[1.0]]);\n\t\tlc=constraints.LinearConstraint(A1, b1, A2, b2)\n\t\tqcs.append(getSphereConstraint(0.8,np.zeros((3,1))))\n\n\n\telif example==2: #Just a sphere\n\n\t\tqcs.append(getSphereConstraint(2.0,np.zeros((3,1))))\n\n\telif example==3: #Just a paraboloid\n\n\t\tqcs.append(getParaboloid3DConstraint())\n\n\t#A 2d polyhedron \n\telif (example==4  \n\t#A 2d polyhedron with a cirle\n\t     or example==5):   \n\t\tA1=np.array([[-1,0],\n\t\t\t\t\t [0, -1.0],\n\t\t\t\t\t [0, 1.0],\n\t\t\t\t\t [0.6,    0.9701]]);\n\n\t\tb1=np.array([[0],\n\t\t\t\t\t[0],\n\t\t\t\t\t[1],\n\t\t\t\t\t[1.2127]])\n\n\t\tlc=constraints.LinearConstraint(A1, b1, None, None)\n\n\t\tif(example==5):\n\t\t\tqcs.append(getSphereConstraint(1.25,np.zeros((2,1))))\n\n\telif example==6: #The intersection between a cube and two planes \n\t\tA1, b1=getCube()\n\t\tA2=np.array([[1.0, 1.0, 1.0],\n\t\t\t\t\t  [-1.0, 1.0, 1.0] ]);\n\t\tb2=np.array([[1.0],[0.1]]);\n\t\tlc=constraints.LinearConstraint(A1, b1, A2, b2)\n\n\telif example==7: #Just a plane\n\t\tA2=np.array([[1.0, 1.0, 1.0]]);\n\t\tb2=np.array([[1.0]]);\t\n\t\tlc=constraints.LinearConstraint(None, None, A2, b2)\n\n\n\telif example==8: #Unbounded 2d polyhedron. It has two vertices and two rays\n\n\t\tA1=np.array([[0.0,-1.0], [2.0,-4.0], [-2.0,1.0]]);\n\t\tb1=np.array([[-2.0], [1.0], [-5.0]]);\n\t\tlc=constraints.LinearConstraint(A1, b1, None, None)\n\n\telif example==9: #A paraboloid and a plane\n\t\tqcs.append(getParaboloid3DConstraint())\n\n\t\tA2=np.array([[1.0, 1.0, 3.0]]);\n\t\tb2=np.array([[1.0]]);\t\n\t\tlc=constraints.LinearConstraint(None, None, A2, b2)\t\n\n\telif example==10: #A paraboloid and a shpere\n\t\tqcs.append(getParaboloid3DConstraint())\n\t\tqcs.append(getSphereConstraint(2.0,np.zeros((3,1))))\t\n\n\telif example==11: #A second-order cone \n\t\tsocs.append(getSOC3DConstraint())\n\n\telif example==12: #The PSD cone in 3D\n\t\tlmic = getPSDCone3DConstraint()\n\n\telif example==13: #Many of them\n\t\tA1=np.array([[-1.0,-1.0,-1.0]])\n\t\tb1=np.array([[-1.0]])\n\t\tlc=constraints.LinearConstraint(A1, b1, None, None)\n\t\tE_ellipsoid=np.array([[0.1,0,0],\n\t\t\t\t\t\t\t  [0.0,1.0,0.0],\n\t\t\t\t\t\t\t  [0.0,0.0,1.0]])\n\t\tqcs.append(getEllipsoidConstraint(E_ellipsoid, np.zeros((3,1))))\n\t\tsocs.append(getSOC3DConstraint())\n\t\tlmic = getPSDCone3DConstraint()\n\n\telif example==14: #Many of them\n\t\tA1=np.array([[-1.0,-1.0,-1.0],\n\t\t\t         [-1.0,2.0,2.0]])\n\t\tb1=np.array([[-1.0],[1.0]])\n\t\tlc=constraints.LinearConstraint(A1, b1, None, None)\n\t\tE_ellipsoid=np.array([[0.6,0,0],\n\t\t\t\t\t\t\t  [0.0,1.0,0.0],\n\t\t\t\t\t\t\t  [0.0,0.0,1.0]])\n\t\tqcs.append(getEllipsoidConstraint(E_ellipsoid, np.zeros((3,1))))\n\t\t# qcs.append(getParaboloid3DConstraint())\n\t\t# socs.append(getSOC3DConstraint())\n\t\t# lmic = getPSDCone3DConstraint()\n\n\telse:\n\t\traise Exception(\"Not implemented yet\")\n\n\n\treturn constraints.ConvexConstraints(lc=lc, qcs=qcs, socs=socs, lmic=lmic, print_debug_info=False)"]}
{"filename": "examples/__init__.py", "chunked_list": [""]}
{"filename": "examples/create_dataset.py", "chunked_list": ["# --------------------------------------------------------------------------\n# Jesus Tordesillas Torres, Robotic Systems Lab, ETH Z\u00fcrich \n# See LICENSE file for the license information\n# -------------------------------------------------------------------------- \n\n# Import libraries\nimport torch\nfrom torch.utils.data import Dataset, DataLoader\nfrom examples_sets import getExample\nimport numpy as np", "from examples_sets import getExample\nimport numpy as np\nimport cvxpy as cp\nimport matplotlib.pyplot as plt\nimport scipy.io\nimport time\n\nimport fixpath #Following this example: https://github.com/tartley/colorama/blob/master/demos/demo01.py\nfrom rayen import constraints, utils\n", "from rayen import constraints, utils\n\n# create custom dataset class\nclass CustomDataset(Dataset):\n\tdef __init__(self, all_x, all_y, all_Pobj, all_qobj, all_robj, all_times_s, all_costs):\n\t\tself.all_x = [torch.Tensor(item) for item in all_x] \n\t\tself.all_y = [torch.Tensor(item) for item in all_y] \n\t\tself.all_Pobj = [torch.Tensor(item) for item in all_Pobj] \n\t\tself.all_qobj = [torch.Tensor(item) for item in all_qobj] \n\t\tself.all_robj = [torch.Tensor(item) for item in all_robj] \n\t\tself.all_times_s = [torch.Tensor(item) for item in all_times_s]\n\t\tself.all_costs = [torch.Tensor(item) for item in all_costs] \n\n\n\tdef __len__(self):\n\t\treturn len(self.all_y)\n\n\tdef __getitem__(self, idx):\n\t\treturn self.all_x[idx], self.all_y[idx], self.all_Pobj[idx], self.all_qobj[idx], self.all_robj[idx], self.all_times_s[idx], self.all_costs[idx]\n\n\tdef getNumelX(self):\n\t\treturn self.all_x[0].shape[0] #Using the first element\n\n\tdef getNumelY(self):\n\t\treturn self.all_y[0].shape[0] #Using the first element", "\n\t# def plot(self, ax):\n\t# \tdim=self.all_x[0].shape[0]\n\n\t# \t# print(f\"x[0]={x[0]}\")\n\n\t# \tall_x_np=np.concatenate(self.all_x, axis=1 )\n\t# \tall_y_np=np.concatenate(self.all_y, axis=1 )\n\n\t# \tprint(f\"dim={dim}\")", "\n\t# \tprint(f\"dim={dim}\")\n\t# \tprint(f\"dim={dim}\")\n\n\n\t# \tif(dim==3):\n\t# \t\tax.scatter3D(all_x_np[0,:], all_x_np[1,:], all_x_np[2,:],color='red')\n\t# \t\tax.scatter3D(all_y_np[0,:], all_y_np[1,:], all_y_np[2,:],color='blue')\n\n\t# \t\tprint(f\"all_x_np={all_x_np}\")", "\n\t# \t\tprint(f\"all_x_np={all_x_np}\")\n\n\t# \tif(dim==2):\n\t# \t\tax.scatter(all_x_np[0,:], all_x_np[1,:],color='red')\n\t# \t\tax.scatter(all_y_np[0,:], all_y_np[1,:],color='blue')\n\ndef createProjectionDataset(num_samples, cs, bbox_half_side): \n\n\tall_x=[];\n\tall_y=[];\n\tall_Pobj=[];\n\tall_qobj=[];\n\tall_robj=[];\n\tall_times_s=[];\n\tall_costs=[];\n\n\tfor i in range(num_samples):\n\t\tx=np.random.uniform(low=-bbox_half_side, high=bbox_half_side, size=(cs.k,1))\n\t\tall_x.append(x)\n\t\tstart=time.time();\n\t\ty, cost = cs.project(x)\n\t\tall_times_s.append(time.time()-start)\n\t\tall_costs.append(cost)\n\t\tall_y.append(y)\n\n\t\tassert x.shape[1]==1\n\n\t\t# ||x-y||^2 = y'*y  -2x'*y + x'*x\n\t\t# Match with 0.5*y'*P_obj*y + q_obj'*y + r_obj \n\t\tPobj=2*np.eye(x.shape[0])\n\t\tqobj=-2*x\n\t\trobj=x.T@x\n\n\t\tassert qobj.shape[1]==1\n\t\tassert robj.shape[1]==1, f\"robj.shape={robj.shape}\"\n\n\t\tall_Pobj.append(Pobj)\n\t\tall_qobj.append(qobj)\n\t\tall_robj.append(robj)\n\n\tmy_dataset = CustomDataset(all_x, all_y, all_Pobj, all_qobj, all_robj, all_times_s, all_costs)\n\n\n\t###plotting stuff\n\t# fig = plt.figure()\n\t# if(dim_ambient_space==3):\n\t# \tax = fig.add_subplot(111, projection=\"3d\")\n\t# else:\n\t# \tax = fig.add_subplot(111)\n\t# my_dataset.plot(ax);\n\t# plt.show()\n\t#######\n\t# exit()\n\n\treturn my_dataset", "\ndef getCorridorConstraints(dimension):\n\tmat = scipy.io.loadmat('./scripts/matlab/corridor_dim'+str(dimension)+'.mat')\n\n\tA1=mat['A1'];\n\tb1=mat['b1'];\n\n\tA2=mat['A2'];\n\tb2=mat['b2'];\n\n\tif(len(mat[\"all_P\"])>0):\n\t\tall_P=list(mat[\"all_P\"][0])\n\t\tall_q=list(mat[\"all_q\"][0])\n\t\tall_r=list(mat[\"all_r\"][0])\n\telse:\n\t\tall_P=[]\n\t\tall_q=[]\n\t\tall_r=[]\n\n\tassert A1.ndim==2\n\tassert b1.ndim==2\n\n\tassert A2.ndim==2\n\tassert b2.ndim==2\n\n\tlc=constraints.LinearConstraint(A1=A1, b1=b1, A2=A2, b2=b2);\n\n\tqcs=[];\n\tfor i in range(len(all_P)):\n\t\tqc=constraints.ConvexQuadraticConstraint(P=all_P[i], q=all_q[i], r=all_r[i]);\n\t\tqcs.append(qc)\n\n\tcs=constraints.ConvexConstraints(lc=lc, qcs=qcs, socs=[], lmic=None)\n\n\treturn cs", "\ndef getCorridorDatasets(dimension):\n\n\tmat = scipy.io.loadmat('./scripts/matlab/corridor_dim'+str(dimension)+'.mat')\n\n\tall_x=list(mat[\"all_x\"][0])\n\tall_y=list(mat[\"all_y\"][0])\n\tall_Pobj=list(mat[\"all_Pobj\"][0])\n\tall_qobj=list(mat[\"all_qobj\"][0])\n\tall_robj=list(mat[\"all_robj\"][0])\n\tall_times_s=list(mat[\"all_times_s\"][0])\n\tall_costs=list(mat[\"all_costs\"][0])\n\n\tall_x_out_dist=list(mat[\"all_x_out_dist\"][0])\n\tall_y_out_dist=list(mat[\"all_y_out_dist\"][0])\n\tall_Pobj_out_dist=list(mat[\"all_Pobj_out_dist\"][0])\n\tall_qobj_out_dist=list(mat[\"all_qobj_out_dist\"][0])\n\tall_robj_out_dist=list(mat[\"all_robj_out_dist\"][0])\n\tall_times_s_out_dist=list(mat[\"all_times_s_out_dist\"][0])\n\tall_costs_out_dist=list(mat[\"all_costs_out_dist\"][0])\n\n\t# polyhedron=mat[\"polyhedron\"]\n\n\t# A1=polyhedron['A1'][0,0];\n\t# b1=polyhedron['b1'][0,0];\n\n\t# polyhedron=mat[\"polyhedron\"]\n\n\t# A1=polyhedron['A1'][0,0];\n\t# b1=polyhedron['b1'][0,0];\n\n\n\n\tassert all_y[0].shape[1]==1\n\tassert all_x[0].shape[1]==1\n\tassert all_x_out_dist[0].shape[1]==1\n\tassert all_y_out_dist[0].shape[1]==1\n\n\n\tmy_dataset = CustomDataset(all_x, all_y, all_Pobj, all_qobj, all_robj, all_times_s, all_costs)\n\tmy_dataset_out_dist = CustomDataset(all_x_out_dist, all_y_out_dist, all_Pobj_out_dist, all_qobj_out_dist, all_robj_out_dist, all_times_s_out_dist, all_costs_out_dist)\n\n\n\treturn my_dataset, my_dataset_out_dist", "\n\n\n\n"]}
{"filename": "examples/utils_examples.py", "chunked_list": ["# --------------------------------------------------------------------------\n# Jesus Tordesillas Torres, Robotic Systems Lab, ETH Z\u00fcrich \n# See LICENSE file for the license information\n# -------------------------------------------------------------------------- \n\nimport matplotlib.pyplot as plt\nimport cvxpy as cp\nimport numpy as np\nimport cdd\nimport fixpath", "import cdd\nimport fixpath\nfrom rayen import utils\n\n########################################################\n########################################################\n\n#Ellisoid is represented by {x | x'*E*x <=1}\ndef plotEllipsoid(E, x0, ax):\n\t#Partly taken from https://github.com/CircusMonkey/covariance-ellipsoid/blob/master/ellipsoid.py\n\t\"\"\"\n\tReturn the 3d points representing the covariance matrix\n\tcov centred at mu and scaled by the factor nstd.\n\tPlot on your favourite 3d axis. \n\tExample 1:  ax.plot_wireframe(X,Y,Z,alpha=0.1)\n\tExample 2:  ax.plot_surface(X,Y,Z,alpha=0.1)\n\t\"\"\"\n\n\tassert E.shape==(3,3)\n\n\tB=np.linalg.inv(scipy.linalg.sqrtm(E))\n\n\t#Ellisoid is now represented by { Bp+x0 | ||p|| <=1}\n\t# Find and sort eigenvalues \n\teigvals, eigvecs = np.linalg.eigh(B)\n\tidx = np.sum(B,axis=0).argsort()\n\teigvals_temp = eigvals[idx]\n\tidx = eigvals_temp.argsort()\n\teigvals = eigvals[idx]\n\teigvecs = eigvecs[:,idx]\n\n\t# Set of all spherical angles to draw our ellipsoid\n\tn_points = 100\n\ttheta = np.linspace(0, 2*np.pi, n_points)\n\tphi = np.linspace(0, np.pi, n_points)\n\n\t# Width, height and depth of ellipsoid\n\trx, ry, rz = np.sqrt(eigvals)\n\n\t# Get the xyz points for plotting\n\t# Cartesian coordinates that correspond to the spherical angles:\n\tX = rx * np.outer(np.cos(theta), np.sin(phi))\n\tY = ry * np.outer(np.sin(theta), np.sin(phi))\n\tZ = rz * np.outer(np.ones_like(theta), np.cos(phi))\n\n\t# Rotate ellipsoid for off axis alignment\n\told_shape = X.shape\n\t# Flatten to vectorise rotation\n\tX,Y,Z = X.flatten(), Y.flatten(), Z.flatten()\n\tX,Y,Z = np.matmul(eigvecs, np.array([X,Y,Z]))\n\tX,Y,Z = X.reshape(old_shape), Y.reshape(old_shape), Z.reshape(old_shape)\n\t \n\t# Add in offsets for the center\n\tX = X + x0[0]\n\tY = Y + x0[1]\n\tZ = Z + x0[2]\n\n\tax.plot_wireframe(X,Y,Z, color='r', alpha=0.1)", "def plotEllipsoid(E, x0, ax):\n\t#Partly taken from https://github.com/CircusMonkey/covariance-ellipsoid/blob/master/ellipsoid.py\n\t\"\"\"\n\tReturn the 3d points representing the covariance matrix\n\tcov centred at mu and scaled by the factor nstd.\n\tPlot on your favourite 3d axis. \n\tExample 1:  ax.plot_wireframe(X,Y,Z,alpha=0.1)\n\tExample 2:  ax.plot_surface(X,Y,Z,alpha=0.1)\n\t\"\"\"\n\n\tassert E.shape==(3,3)\n\n\tB=np.linalg.inv(scipy.linalg.sqrtm(E))\n\n\t#Ellisoid is now represented by { Bp+x0 | ||p|| <=1}\n\t# Find and sort eigenvalues \n\teigvals, eigvecs = np.linalg.eigh(B)\n\tidx = np.sum(B,axis=0).argsort()\n\teigvals_temp = eigvals[idx]\n\tidx = eigvals_temp.argsort()\n\teigvals = eigvals[idx]\n\teigvecs = eigvecs[:,idx]\n\n\t# Set of all spherical angles to draw our ellipsoid\n\tn_points = 100\n\ttheta = np.linspace(0, 2*np.pi, n_points)\n\tphi = np.linspace(0, np.pi, n_points)\n\n\t# Width, height and depth of ellipsoid\n\trx, ry, rz = np.sqrt(eigvals)\n\n\t# Get the xyz points for plotting\n\t# Cartesian coordinates that correspond to the spherical angles:\n\tX = rx * np.outer(np.cos(theta), np.sin(phi))\n\tY = ry * np.outer(np.sin(theta), np.sin(phi))\n\tZ = rz * np.outer(np.ones_like(theta), np.cos(phi))\n\n\t# Rotate ellipsoid for off axis alignment\n\told_shape = X.shape\n\t# Flatten to vectorise rotation\n\tX,Y,Z = X.flatten(), Y.flatten(), Z.flatten()\n\tX,Y,Z = np.matmul(eigvecs, np.array([X,Y,Z]))\n\tX,Y,Z = X.reshape(old_shape), Y.reshape(old_shape), Z.reshape(old_shape)\n\t \n\t# Add in offsets for the center\n\tX = X + x0[0]\n\tY = Y + x0[1]\n\tZ = Z + x0[2]\n\n\tax.plot_wireframe(X,Y,Z, color='r', alpha=0.1)", "\n\ndef plot3DPolytopeHRepresentation(A,b, limits, ax):\n\tpoints, R=utils.H_to_V(A,b)\n\tif(R.shape[1]>0):\n\t\tutils.printInBoldRed(\"Plotting 3D unbounded polyhedron not implemented yet\")\n\t\treturn\n\tplotConvexHullOf3DPoints(points, limits, ax)\n\ndef plotConvexHullOf3DPoints(V, limits, ax):\n\tpoints=V.T\n\n\t## https://stackoverflow.com/a/71544694/6057617\n\n\t# to get the convex hull with cdd, one has to prepend a column of ones\n\tvertices = np.hstack((np.ones((points.shape[0],1)), points))\n\n\t# do the polyhedron\n\tmat = cdd.Matrix(vertices, linear=False, number_type=\"fraction\") \n\tmat.rep_type = cdd.RepType.GENERATOR\n\tpoly = cdd.Polyhedron(mat)\n\n\t# get the adjacent vertices of each vertex\n\tadjacencies = [list(x) for x in poly.get_input_adjacency()]\n\n\t# store the edges in a matrix (giving the indices of the points)\n\tedges = [None]*(8-1)\n\tfor i,indices in enumerate(adjacencies[:-1]):\n\t\tindices = list(filter(lambda x: x>i, indices))\n\t\tl = len(indices)\n\t\tcol1 = np.full((l, 1), i)\n\t\tindices = np.reshape(indices, (l, 1))\n\t\tedges[i] = np.hstack((col1, indices))\n\tEdges = np.vstack(tuple(edges))\n\n\t# plot\n\t# fig = plt.figure()\n\t# ax = fig.add_subplot(111, projection=\"3d\")\n\n\tstart = points[Edges[:,0]]\n\tend = points[Edges[:,1]]\n\n\tfor i in range(12):\n\t\tax.plot(\n\t\t\t[start[i,0], end[i,0]], \n\t\t\t[start[i,1], end[i,1]], \n\t\t\t[start[i,2], end[i,2]],\n\t\t\t\"blue\"\n\t\t)", "\ndef plotConvexHullOf3DPoints(V, limits, ax):\n\tpoints=V.T\n\n\t## https://stackoverflow.com/a/71544694/6057617\n\n\t# to get the convex hull with cdd, one has to prepend a column of ones\n\tvertices = np.hstack((np.ones((points.shape[0],1)), points))\n\n\t# do the polyhedron\n\tmat = cdd.Matrix(vertices, linear=False, number_type=\"fraction\") \n\tmat.rep_type = cdd.RepType.GENERATOR\n\tpoly = cdd.Polyhedron(mat)\n\n\t# get the adjacent vertices of each vertex\n\tadjacencies = [list(x) for x in poly.get_input_adjacency()]\n\n\t# store the edges in a matrix (giving the indices of the points)\n\tedges = [None]*(8-1)\n\tfor i,indices in enumerate(adjacencies[:-1]):\n\t\tindices = list(filter(lambda x: x>i, indices))\n\t\tl = len(indices)\n\t\tcol1 = np.full((l, 1), i)\n\t\tindices = np.reshape(indices, (l, 1))\n\t\tedges[i] = np.hstack((col1, indices))\n\tEdges = np.vstack(tuple(edges))\n\n\t# plot\n\t# fig = plt.figure()\n\t# ax = fig.add_subplot(111, projection=\"3d\")\n\n\tstart = points[Edges[:,0]]\n\tend = points[Edges[:,1]]\n\n\tfor i in range(12):\n\t\tax.plot(\n\t\t\t[start[i,0], end[i,0]], \n\t\t\t[start[i,1], end[i,1]], \n\t\t\t[start[i,2], end[i,2]],\n\t\t\t\"blue\"\n\t\t)", "\n\t# ax.set_xlabel(\"x\")\n\t# ax.set_ylabel(\"y\")\n\t# ax.set_zlabel(\"z\")\n\n\t# ax.set_xlim3d(limits[0],limits[1])\n\t# ax.set_ylim3d(limits[2],limits[3])\n\t# ax.set_zlim3d(limits[4],limits[5])\n\n", "\n\n\nfrom mpl_toolkits.mplot3d import axes3d\n\n#Taken from here: https://stackoverflow.com/a/4687582/6057617\ndef plot_implicit(fn, limits):\n\t''' create a plot of an implicit function\n\tfn  ...implicit function (plot where fn==0)\n\tbbox ..the x,y,and z limits of plotted interval'''\n\t# xmin, xmax, ymin, ymax, zmin, zmax = bbox*3\n\tfig = plt.figure()\n\tax = fig.add_subplot(111, projection='3d')\n\tA = np.linspace(limits[0],limits[1], 100) # resolution of the contour\n\tB = np.linspace(limits[0],limits[1], 15) # number of slices\n\tA1,A2 = np.meshgrid(A,A) # grid on which the contour is plotted\n\n\tfor z in B: # plot contours in the XY plane\n\t\tX,Y = A1,A2\n\t\tZ = fn(X,Y,z)\n\t\tcset = ax.contour(X, Y, Z+z, [z], zdir='z')\n\t\t# [z] defines the only level to plot for this contour for this value of z\n\n\tfor y in B: # plot contours in the XZ plane\n\t\tX,Z = A1,A2\n\t\tY = fn(X,y,Z)\n\t\tcset = ax.contour(X, Y+y, Z, [y], zdir='y')\n\n\tfor x in B: # plot contours in the YZ plane\n\t\tY,Z = A1,A2\n\t\tX = fn(x,Y,Z)\n\t\tcset = ax.contour(X+x, Y, Z, [x], zdir='x')\n\n\t# must set plot limits because the contour will likely extend\n\t# way beyond the displayed level.  Otherwise matplotlib extends the plot limits\n\t# to encompass all values in the contour.\n\tax.set_xlim3d(limits[0],limits[1])\n\tax.set_ylim3d(limits[2],limits[3])\n\tax.set_zlim3d(limits[4],limits[5])\n\n\tplt.show()", "\n\ndef getVertexesRaysFromAb(A, b):\n\tbmA= np.concatenate([b, -A], axis=1) # See https://pycddlib.readthedocs.io/en/latest/matrix.html\n\tbmA_cdd = cdd.Matrix(bmA.tolist(), number_type='float')\n\tbmA_cdd.rep_type = cdd.RepType.INEQUALITY\n\tpoly = cdd.Polyhedron(bmA_cdd)\n\tgen = poly.get_generators()\n\t# print(gen)\n\tvertices, rays = getVertexesRaysFromGenerators(gen)\n\treturn vertices, rays ", "\ndef getVertexesRaysFromGenerators(gen):\n\tgenerators=list(gen)\n\tvertices=np.array([[],[]]);\n\trays=np.array([[],[]]);\n\tfor i in range(len(generators)):\n\t\tgen_i=generators[i];\n\t\ttmp=np.asarray(gen_i[1:]).reshape((-1,1));\n\n\t\tif(gen_i[0]==1):\n\t\t\tvertices=np.append(vertices,tmp, axis=1)\n\t\telse: #it is zero\n\t\t\trays=np.append(rays,tmp, axis=1)\n\n\treturn vertices, rays", "\ndef uniformSampleInUnitSphere(dim):\n\t#Method 19 of http://extremelearning.com.au/how-to-generate-uniformly-random-points-on-n-spheres-and-n-balls/\n\n\tu = np.random.normal(loc=0.0, scale=1.0, size=(dim,1))\n\tu_normalized= u / np.linalg.norm(u)\n\n\treturn u_normalized\n\n# https://stackoverflow.com/a/69427715/6057617", "\n# https://stackoverflow.com/a/69427715/6057617\n# def move_sympyplot_to_axes(p, ax):\n#     backend = p.backend(p)\n#     backend.ax = ax\n#     backend._process_series(backend.parent._series, ax, backend.parent)\n#     backend.ax.spines['right'].set_color('none')\n#     backend.ax.spines['top'].set_color('none')\n#     backend.ax.spines['bottom'].set_position('zero')\n#     plt.close(backend.fig)", "#     backend.ax.spines['bottom'].set_position('zero')\n#     plt.close(backend.fig)\n\ndef plot2DPolyhedron(A, b, ax):\n\t##FIRST WAY\n\t# npoints=300\n\t# d = np.linspace(-2,16,npoints)\n\t# x1,x2 = np.meshgrid(d,d)\n\n\t# tmp=1;\n\t# for i in range(A.shape[0]):\n\t# \ttmp=tmp & (A[i,0]*x1 + A[i,1]*x2 <=b[i,0]);\n\n\t# plt.imshow( tmp.astype(int), extent=(x1.min(),x1.max(),x2.min(),x2.max()),origin=\"lower\", cmap=\"Greys\", alpha = 0.3);\n\n\t# #second way, right now it only works if there are no rays\n\t# from scipy.spatial import ConvexHull \n\t# vertices, rays = getVertexesRaysFromAb(A, b)\n\t# #See example from https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.ConvexHull.html\n\t# coord = vertices.T\n\t# hull = ConvexHull(coord)\n\t# for simplex in hull.simplices:\n\t# \tax.plot(coord[simplex, 0], coord[simplex, 1], 'r-')\n\n\t#third way\n\tnpoints=300\n\td = np.linspace(-2,16,npoints)\n\tx1,x2 = np.meshgrid(d,d)\n\n\ttmp=1;\n\tfor i in range(A.shape[0]):\n\t\ttmp=tmp & (A[i,0]*x1 + A[i,1]*x2 <=b[i,0]);\n\n\tplt.imshow( tmp.astype(int), extent=(x1.min(),x1.max(),x2.min(),x2.max()),origin=\"lower\", cmap=\"Greys\", alpha = 0.3);", "\n\n\n\t"]}
{"filename": "examples/early_stopping.py", "chunked_list": ["#Code taken from https://github.com/Bjarten/early-stopping-pytorch/blob/master/pytorchtools.py\n#Some minor modifications by jtorde@mit.edu\n\nimport numpy as np\nimport torch\nimport uuid\nimport os\n\nclass EarlyStopping:\n    \"\"\"Early stops the training if validation loss doesn't improve after a given patience.\"\"\"\n    def __init__(self, patience=20, verbose=False, delta=0, trace_func=print):\n        \"\"\"\n        Args:\n            patience (int): How long to wait after last time validation loss improved.\n                            Default: 7\n            verbose (bool): If True, prints a message for each validation loss improvement. \n                            Default: False\n            delta (float): Minimum change in the monitored quantity to qualify as an improvement.\n                            Default: 0\n            path (str): Path for the checkpoint to be saved to.\n                            Default: 'checkpoint.pt'\n            trace_func (function): trace print function.\n                            Default: print            \n        \"\"\"\n        self.patience = patience\n        self.verbose = verbose\n        self.counter = 0\n        self.best_score = None\n        self.early_stop = False\n        self.val_loss_min = np.Inf\n        self.delta = delta\n        folder=\"./early_stopping_checkpoints/\"\n        os.system(\"mkdir -p \"+folder)\n        self.path = folder+\"checkpoint_\"+uuid.uuid4().hex+\".pt\" #https://stackoverflow.com/a/62277811\n        self.trace_func = trace_func\n    def __call__(self, val_loss, model):\n\n        score = -val_loss\n\n        if self.best_score is None:\n            self.best_score = score\n            self.save_checkpoint(val_loss, model)\n        elif score < self.best_score + self.delta:\n            self.counter += 1\n            if self.verbose:\n                self.trace_func(f'EarlyStopping counter: {self.counter} out of {self.patience}')\n            if self.counter >= self.patience:\n                self.early_stop = True\n        else:\n            self.best_score = score\n            self.save_checkpoint(val_loss, model)\n            self.counter = 0\n\n    def save_checkpoint(self, val_loss, model):\n        '''Saves model when validation loss decrease.'''\n        if self.verbose:\n            # self.trace_func(f'Validation loss decreased ({self.val_loss_min:.6f} --> {val_loss:.6f}).  Saving model ...')\n            self.trace_func(f'Best validation loss so far: {self.val_loss_min:.6f}.  Saving model ...')\n        torch.save(model.state_dict(), self.path)\n        self.val_loss_min = val_loss\n\n    #Added by jtorde\n    def load_best_model(self, model):\n        model.load_state_dict(torch.load(self.path))\n\n    def __del__(self):\n        os.system(\"rm \"+self.path)", "class EarlyStopping:\n    \"\"\"Early stops the training if validation loss doesn't improve after a given patience.\"\"\"\n    def __init__(self, patience=20, verbose=False, delta=0, trace_func=print):\n        \"\"\"\n        Args:\n            patience (int): How long to wait after last time validation loss improved.\n                            Default: 7\n            verbose (bool): If True, prints a message for each validation loss improvement. \n                            Default: False\n            delta (float): Minimum change in the monitored quantity to qualify as an improvement.\n                            Default: 0\n            path (str): Path for the checkpoint to be saved to.\n                            Default: 'checkpoint.pt'\n            trace_func (function): trace print function.\n                            Default: print            \n        \"\"\"\n        self.patience = patience\n        self.verbose = verbose\n        self.counter = 0\n        self.best_score = None\n        self.early_stop = False\n        self.val_loss_min = np.Inf\n        self.delta = delta\n        folder=\"./early_stopping_checkpoints/\"\n        os.system(\"mkdir -p \"+folder)\n        self.path = folder+\"checkpoint_\"+uuid.uuid4().hex+\".pt\" #https://stackoverflow.com/a/62277811\n        self.trace_func = trace_func\n    def __call__(self, val_loss, model):\n\n        score = -val_loss\n\n        if self.best_score is None:\n            self.best_score = score\n            self.save_checkpoint(val_loss, model)\n        elif score < self.best_score + self.delta:\n            self.counter += 1\n            if self.verbose:\n                self.trace_func(f'EarlyStopping counter: {self.counter} out of {self.patience}')\n            if self.counter >= self.patience:\n                self.early_stop = True\n        else:\n            self.best_score = score\n            self.save_checkpoint(val_loss, model)\n            self.counter = 0\n\n    def save_checkpoint(self, val_loss, model):\n        '''Saves model when validation loss decrease.'''\n        if self.verbose:\n            # self.trace_func(f'Validation loss decreased ({self.val_loss_min:.6f} --> {val_loss:.6f}).  Saving model ...')\n            self.trace_func(f'Best validation loss so far: {self.val_loss_min:.6f}.  Saving model ...')\n        torch.save(model.state_dict(), self.path)\n        self.val_loss_min = val_loss\n\n    #Added by jtorde\n    def load_best_model(self, model):\n        model.load_state_dict(torch.load(self.path))\n\n    def __del__(self):\n        os.system(\"rm \"+self.path)", "      # body of destructor\n\n"]}
{"filename": "examples/test_layer.py", "chunked_list": ["# --------------------------------------------------------------------------\n# Jesus Tordesillas Torres, Robotic Systems Lab, ETH Z\u00fcrich \n# See LICENSE file for the license information\n# -------------------------------------------------------------------------- \n\nimport numpy as np\nimport torch\nimport torch.nn as nn\nimport math\nimport matplotlib.pyplot as plt", "import math\nimport matplotlib.pyplot as plt\nimport mpl_toolkits.mplot3d as a3\nimport matplotlib.colors as colors\nimport numpy as np\nimport scipy\nimport os\nimport time\n\nfrom examples_sets import getExample", "\nfrom examples_sets import getExample\nimport utils_examples\n\nimport fixpath #Following this example: https://github.com/tartley/colorama/blob/master/demos/demo01.py\nfrom rayen import constraints, constraint_module, utils\n\nmethods=['RAYEN_old', 'RAYEN', 'Bar', 'UU', 'PP', 'UP', 'DC3']\nindex_examples_to_run=list(range(15))\n###############", "index_examples_to_run=list(range(15))\n###############\n\nnum_of_examples=len(index_examples_to_run)\nrows=math.ceil(math.sqrt(num_of_examples))\ncols=rows\n\nfor method in methods:\n\tutils.printInBoldRed(f\"==================== METHOD: {method} ==========================\")\n\tfig = plt.figure()\n\tfig.suptitle(method, fontsize=10)\n\tfor i in range(num_of_examples):\n\t\tindex_example=index_examples_to_run[i]\n\t\tutils.printInBoldGreen(f\"==================== Example: {index_example} \")\n\n\n\t\tconstraint=getExample(index_example)\n\n\t\tif(method=='Bar' and (constraint.has_quadratic_constraints or constraint.has_soc_constraints or constraint.has_lmi_constraints)):\n\t\t\tcontinue\n\n\t\tif(method=='DC3' and (constraint.has_soc_constraints or constraint.has_lmi_constraints)):\n\t\t\tcontinue\n\n\t\t# fig = plt.figure()\n\t\tif(constraint.k==3):\n\t\t\tax = fig.add_subplot(rows,cols,i+1, projection=\"3d\")\n\t\t\tif(constraint.has_linear_ineq_constraints):\n\t\t\t\tutils_examples.plot3DPolytopeHRepresentation(constraint.lc.A1,constraint.lc.b1,[-1, 2, -1, 2, -1, 2], ax)\n\n\n\t\telse:\n\t\t\tax = fig.add_subplot(rows,cols,i+1) \n\n\t\tif(method=='DC3'):\n\t\t\targs_DC3={}\n\t\t\targs_DC3['lr'] = 1e-4\n\t\t\targs_DC3['eps_converge'] = 1e-4\n\t\t\targs_DC3['momentum'] = 0.5\n\t\t\targs_DC3['max_steps_training'] = 10\n\t\t\targs_DC3['max_steps_testing'] = 50000 #float(\"inf\")\n\t\telse:\n\t\t\targs_DC3 = None\n\n\n\t\tmy_layer=constraint_module.ConstraintModule(constraint, method=method, create_map=False, args_DC3=args_DC3)\n\n\t\tnumel_output_mapper=my_layer.getDimAfterMap()\n\n\t\tnum_samples=500 #12000\n\t\tx_batched=torch.Tensor(num_samples, numel_output_mapper, 1).uniform_(-5.0, 5.0)\n\n\t\t# mapper=nn.Sequential(nn.Linear(x_batched.shape[1], numel_output_mapper))\n\t\t# mapper=nn.Sequential() #do nothing.\n\t\t# my_layer.setMapper(mapper)\n\n\t\tmy_layer.eval() #This changes the self.training variable of the module\n\n\t\ttime_start=time.time()\n\t\tresult=my_layer(x_batched)\n\t\ttotal_time_per_sample= (time.time()-time_start)/num_samples\n\n\t\tresult=result.detach().numpy();\n\n\t\ty0=my_layer.gety0();\n\n\t\tif(constraint.k==3):\n\t\t\tax.scatter(y0[0,0], y0[1,0], y0[2,0],color='r',s=500)\n\t\t\tax.scatter(result[:,0,0], result[:,1,0], result[:,2,0])\n\n\n\t\tif(constraint.k==2):\n\t\t\tax.scatter(result[:,0,0], result[:,1,0])\n\t\t\tutils_examples.plot2DPolyhedron(constraint.lc.A1,constraint.lc.b1,ax)\n\t\t\t\n\t\t\tax.scatter(y0[0,0], y0[1,0])\n\t\t\t# utils_examples.plot2DEllipsoidB(my_layer.B.numpy(),my_layer.z0.numpy(),ax)\n\t\t\tax.set_aspect('equal')\n\n\t\t\tax.set_xlim(-0.5,8)\n\t\t\tax.set_ylim(-0.5,8)\n\n\n\t\tif method=='RAYEN':\n\t\t\tmy_dict=constraint.getDataAsDict();\n\t\t\tmy_dict[\"result\"]=result\n\t\t\tmy_dict[\"total_time_per_sample\"]=total_time_per_sample\n\t\t\tdirectory='./examples_mat'\n\t\t\tif not os.path.exists(directory):\n\t\t\t\tos.makedirs(directory)\n\t\t\tscipy.io.savemat(directory+'/example_'+str(index_example)+'.mat', my_dict)\n\n\t\tutils.printInBoldBlue(f\"Example {index_example}, total_time_per_sample={total_time_per_sample}\")", "\n\nplt.show()\n\n\n\n\n\n######OLD\n##This samples different angles", "######OLD\n##This samples different angles\n# all_angles = np.arange(0,2*math.pi, 0.01)\n# x_batched=torch.empty(len(all_angles), numel_output_mapper, 1)\n\n# for i in range(x_batched.shape[0]): #for each element of the batch\n# \ttheta=all_angles[i]\n# \tif(my_layer.dim==2):\n# \t\ttmp=torch.Tensor(np.array([[math.cos(theta)],[math.sin(theta)],[3000]])); #Assumming my_layer.dim==2 here\n# \telse:", "# \t\ttmp=torch.Tensor(np.array([[math.cos(theta)],[math.sin(theta)],[3000]])); #Assumming my_layer.dim==2 here\n# \telse:\n# \t\traise(\"Not implemented yet\")\n# \ttmp=torch.unsqueeze(tmp, dim=0)\n# \tprint(f\"tmp.shape={tmp.shape}\")\n# \tx_batched[i,:,:]=tmp\n\n\n# E=1.7*np.eye(constraint.k)\n# ellipsoid=utils.Ellipsoid(E=E, c=np.zeros((constraint.k,1)))", "# E=1.7*np.eye(constraint.k)\n# ellipsoid=utils.Ellipsoid(E=E, c=np.zeros((constraint.k,1)))\n# cqc_list=[ellipsoid.convertToQuadraticConstraint()]\n\n# print(f\"P={cqc_list[0].P}\")\n# print(f\"q={cqc_list[0].q}\")\n# print(f\"r={cqc_list[0].r}\")\n\n\n# if(method=='RAYEN'):", "\n# if(method=='RAYEN'):\n# \tnum_directions=500; #for each direction you have several samples\n# \tx_batched=torch.empty(0, numel_output_mapper, 1)\n# \tfor i in range(num_directions): #for each direction\n# \t\tdirection=utils.uniformSampleInUnitSphere(my_layer.dim)\n# \t\tfor scalar in list(np.linspace(-8.0, 8.0, num=100)):\n# \t\t\tscalar_np=np.array([[scalar]])\n# \t\t\tdirection_and_scalar=np.concatenate((direction,scalar_np), axis=0);\n# \t\t\ttmp=torch.Tensor(direction_and_scalar)", "# \t\t\tdirection_and_scalar=np.concatenate((direction,scalar_np), axis=0);\n# \t\t\ttmp=torch.Tensor(direction_and_scalar)\n# \t\t\ttmp=torch.unsqueeze(tmp, dim=0)\n# \t\t\t# print(f\"direction_and_scalar={direction_and_scalar}\")\n# \t\t\tx_batched=torch.cat((x_batched, tmp), axis=0)\n\n# if(method=='Bar' or method=='PP' or method=='UP'):\n# \tx_batched=torch.empty(0, numel_output_mapper, 1)\n\n# \tfor i in range(1000):", "\n# \tfor i in range(1000):\n# \t\t# sample_lambda = utils.runif_in_simplex(my_layer.num_vertices);\n# \t\t# sample_mu = np.random.uniform(0.0,2.5,my_layer.num_rays);\n# \t\t# sample=np.concatenate((sample_lambda, sample_mu));\n# \t\tsample=np.random.uniform(-5,5,numel_output_mapper);\n# \t\tsample=torch.Tensor(np.expand_dims(sample, axis=1))\n# \t\tsample=torch.unsqueeze(sample, dim=0) \n# \t\tx_batched=torch.cat((x_batched, sample), axis=0) \n", "# \t\tx_batched=torch.cat((x_batched, sample), axis=0) \n"]}
{"filename": "examples/fixpath.py", "chunked_list": ["# --------------------------------------------------------------------------\n# Jesus Tordesillas Torres, Robotic Systems Lab, ETH Z\u00fcrich \n# See LICENSE file for the license information\n# -------------------------------------------------------------------------- \n\n#https://github.com/tartley/colorama/blob/master/demos/fixpath.py\nimport sys\nfrom os.path import normpath, dirname, join\nsys.path.insert(0, normpath(join(dirname(__file__), '..')))", "sys.path.insert(0, normpath(join(dirname(__file__), '..')))"]}
{"filename": "examples/first_figure.py", "chunked_list": ["# --------------------------------------------------------------------------\n# Jesus Tordesillas Torres, Robotic Systems Lab, ETH Z\u00fcrich \n# See LICENSE file for the license information\n# -------------------------------------------------------------------------- \n\nimport numpy as np\nimport torch\nimport torch.nn as nn\nimport math\nimport matplotlib.pyplot as plt", "import math\nimport matplotlib.pyplot as plt\nimport mpl_toolkits.mplot3d as a3\nimport matplotlib.colors as colors\nimport numpy as np\nimport scipy\nimport os\nimport time\n\nfrom examples_sets import getExample", "\nfrom examples_sets import getExample\nimport utils_examples\n\nimport fixpath #Following this example: https://github.com/tartley/colorama/blob/master/demos/demo01.py\nfrom rayen import constraints, constraint_module, utils\n\nmethod='RAYEN'\nindex_example=13\n", "index_example=13\n\n\nfig = plt.figure()\nfig.suptitle(method, fontsize=10)\n\ntmp=getExample(index_example)\n\nconstraint=constraints.ConvexConstraints(lc=tmp.lc, qcs=tmp.qcs, socs=tmp.socs, lmic=tmp.lmic, y0=np.array([[0.5], [0.0], [0.8]]))\n", "constraint=constraints.ConvexConstraints(lc=tmp.lc, qcs=tmp.qcs, socs=tmp.socs, lmic=tmp.lmic, y0=np.array([[0.5], [0.0], [0.8]]))\n\nax = fig.add_subplot(1,1,1, projection=\"3d\")\n\nmy_layer=constraint_module.ConstraintModule(constraint, method=method, create_map=False)\n\nnum_samples=500 #12000\nv_batched_x=torch.Tensor(num_samples, 1, 1).uniform_(-0.5, 0.6)\nv_batched_y=torch.Tensor(num_samples, 1, 1).uniform_(-0.55, 0.47)\nv_batched_z=torch.Tensor(num_samples, 1, 1).uniform_(-0.4, 0.3)", "v_batched_y=torch.Tensor(num_samples, 1, 1).uniform_(-0.55, 0.47)\nv_batched_z=torch.Tensor(num_samples, 1, 1).uniform_(-0.4, 0.3)\nv_batched = torch.cat((v_batched_x, v_batched_y, v_batched_z),1)\n\nmy_layer.eval() #This changes the self.training variable of the module\n\ntime_start=time.time()\nresult=my_layer(v_batched)\ntotal_time_per_sample= (time.time()-time_start)/num_samples\n", "total_time_per_sample= (time.time()-time_start)/num_samples\n\nresult=result.detach().numpy();\n\ny0=my_layer.gety0();\n\n\nax.scatter(y0[0,0], y0[1,0], y0[2,0],color='r',s=500)\nax.scatter(result[:,0,0], result[:,1,0], result[:,2,0])\n", "ax.scatter(result[:,0,0], result[:,1,0], result[:,2,0])\n\n\nmy_dict=constraint.getDataAsDict();\nmy_dict[\"result\"]=result\nmy_dict[\"total_time_per_sample\"]=total_time_per_sample\nmy_dict[\"y0\"]=constraint.y0\nmy_dict[\"v\"]=v_batched.detach().numpy()\ndirectory='./first_figure'\nif not os.path.exists(directory):\n\tos.makedirs(directory)", "directory='./first_figure'\nif not os.path.exists(directory):\n\tos.makedirs(directory)\nscipy.io.savemat(directory+'/first_figure.mat', my_dict)\n\nutils.printInBoldBlue(f\"Example {index_example}, total_time_per_sample={total_time_per_sample}\")\n\nplt.show()"]}
{"filename": "examples/scripts/time_analysis.py", "chunked_list": ["# --------------------------------------------------------------------------\n# Jesus Tordesillas Torres, Robotic Systems Lab, ETH Z\u00fcrich \n# See LICENSE file for the license information\n# -------------------------------------------------------------------------- \n\nimport numpy as np\nimport torch\nimport time\nfrom joblib import Parallel, delayed\nimport pandas as pd", "from joblib import Parallel, delayed\nimport pandas as pd\nimport sys\nimport os\n\n\nsys.path.insert(1, os.path.join(sys.path[0], '..'))  #See first comment of this answer: https://stackoverflow.com/a/11158224\n\nfrom examples_sets import getExample\nimport fixpath #Following this example: https://github.com/tartley/colorama/blob/master/demos/demo01.py", "from examples_sets import getExample\nimport fixpath #Following this example: https://github.com/tartley/colorama/blob/master/demos/demo01.py\nfrom rayen import constraints, constraint_module, utils\n\npath=\"./results/\"\nif not os.path.exists(path):\n   os.makedirs(path)\n\ntorch.set_default_dtype(torch.float64)\n\ndef getTime_sMethod(cs, num_samples):\n\tprint(\"Calling constructor for the layer...\")\n\tmy_layer=constraint_module.ConstraintModule(cs, method=\"RAYEN\", create_map=False)\n\tprint(\"Called\")\n\n\t\n\n\tnumel_output_mapper=my_layer.getDimAfterMap()\n\tx_batched=torch.Tensor(num_samples, numel_output_mapper, 1).uniform_(-1.0, 1.0)\n\tx_batched.to(torch.device('cuda:0'))\n\tprint(\"Calling method...\")\n\t\n\tcuda_timer=utils.CudaTimer()\n\tcuda_timer.start()\n\tresult=my_layer(x_batched)\n\ttotal_s_per_sample= cuda_timer.endAndGetTimeSeconds()/num_samples\n\tprint(\"Called\")\n\n\tprint(f\"total_s_per_sample={total_s_per_sample} s\")\n\treturn total_s_per_sample", "torch.set_default_dtype(torch.float64)\n\ndef getTime_sMethod(cs, num_samples):\n\tprint(\"Calling constructor for the layer...\")\n\tmy_layer=constraint_module.ConstraintModule(cs, method=\"RAYEN\", create_map=False)\n\tprint(\"Called\")\n\n\t\n\n\tnumel_output_mapper=my_layer.getDimAfterMap()\n\tx_batched=torch.Tensor(num_samples, numel_output_mapper, 1).uniform_(-1.0, 1.0)\n\tx_batched.to(torch.device('cuda:0'))\n\tprint(\"Calling method...\")\n\t\n\tcuda_timer=utils.CudaTimer()\n\tcuda_timer.start()\n\tresult=my_layer(x_batched)\n\ttotal_s_per_sample= cuda_timer.endAndGetTimeSeconds()/num_samples\n\tprint(\"Called\")\n\n\tprint(f\"total_s_per_sample={total_s_per_sample} s\")\n\treturn total_s_per_sample", "\n# all_k = [1, 10, 100, 1000, 10000]\n\n############################################ WARM UP THE GPU (for more accurate computation time)\nmy_layer=constraint_module.ConstraintModule(getExample(12), method=\"RAYEN\", create_map=False)\nx_dummy=torch.Tensor(300, my_layer.getDimAfterMap(), 1).uniform_(-5.0, 5.0)\n_ = my_layer(x_dummy)\n\n#######################################################\n", "#######################################################\n\nnum_samples=2000\n\n# ########################################### Linear CONSTRAINTS\ntimes_lin = []\n\nall_k = [1, 10, 100, 1000, 2000, 3000, 4000, 5000, 10000]\nall_r_A1 = [1, 10, 100, 500, 1000, 2000, 3000] \n\nfor r_A1 in all_r_A1:\n\tfor k in all_k:\n\t\tutils.printInBoldRed(f\"r_A1 = {r_A1}, k={k}\")\n\t\tA1=np.random.uniform(low=-1.0, high=1.0, size=(r_A1,k))\n\t\tb1=np.random.uniform(low= 0.1, high=1.0, size=(r_A1,1)) #In this way, y=0 is always a feasible solution\n\n\t\tlc=constraints.LinearConstraint(A1=A1, b1=b1, A2=None, b2=None);\n\t\tcs=constraints.ConvexConstraints(lc=lc, qcs=[], socs=[], lmic=None, y0=np.zeros((k,1)), do_preprocessing_linear=False)\n\t\ttotal_s=getTime_sMethod(cs, num_samples)\n\t\ttimes_lin.append({'k': k,'r_A1': r_A1,'Time': total_s})", "all_r_A1 = [1, 10, 100, 500, 1000, 2000, 3000] \n\nfor r_A1 in all_r_A1:\n\tfor k in all_k:\n\t\tutils.printInBoldRed(f\"r_A1 = {r_A1}, k={k}\")\n\t\tA1=np.random.uniform(low=-1.0, high=1.0, size=(r_A1,k))\n\t\tb1=np.random.uniform(low= 0.1, high=1.0, size=(r_A1,1)) #In this way, y=0 is always a feasible solution\n\n\t\tlc=constraints.LinearConstraint(A1=A1, b1=b1, A2=None, b2=None);\n\t\tcs=constraints.ConvexConstraints(lc=lc, qcs=[], socs=[], lmic=None, y0=np.zeros((k,1)), do_preprocessing_linear=False)\n\t\ttotal_s=getTime_sMethod(cs, num_samples)\n\t\ttimes_lin.append({'k': k,'r_A1': r_A1,'Time': total_s})", "\ntimes_lin=pd.DataFrame(times_lin)\n# utils.savepickle(times_lin, path+\"times_lin.pkl\")\ntimes_lin.to_csv(path+\"times_lin.csv\",index=False)\n\n\n# ########################################### QP CONSTRAINTS\ntimes_qp = []\nall_eta = [1, 10, 50, 100, 500, 1000] #np.power(10, np.array([0,1,2,3]))\nall_k = [1, 10, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000]\nfor eta in all_eta:\n\tfor k in all_k:\n\t\tutils.printInBoldRed(f\"QP constraints, eta = {eta}, k={k}\")\n\n\t\tqcs=[]\n\n\t\tdef createRandomQPConstraint(i):\n\t\t\ttmp=np.random.uniform(low=-1.0, high=1.0, size=(k,k))\n\t\t\t# tmp=(torch.empty((k,k), device=\"cuda:0\").uniform_(-1.0, 1.0)).cpu().numpy() #\n\n\t\t\tP=tmp@tmp.T #To make sure it's a (symmetric) PSD matrix\n\t\t\tq=np.random.uniform(low=-1.0, high=1.0, size=(k,1))\n\t\t\tr=np.random.uniform(low=-1.0, high=0.0, size=(1,1))\n\t\t\tqc=constraints.ConvexQuadraticConstraint(P=P, q=q, r=r, do_checks_P=False);\n\t\t\treturn qc\n\n\t\tprint(\"Creating random constraints\")\n\t\tqcs = Parallel(n_jobs=15)(delayed(createRandomQPConstraint)(i) for i in range(eta))\n\t\tprint(\"Created\")\n\n\t\tassert len(qcs)==eta\n\t\t\n\t\tcs=constraints.ConvexConstraints(lc=None, qcs=qcs, socs=[], lmic=None, y0=np.zeros((k,1)))\n\t\ttotal_s=getTime_sMethod(cs, num_samples)\n\t\ttimes_qp.append({'k': k,'eta': eta,'Time': total_s})", "all_eta = [1, 10, 50, 100, 500, 1000] #np.power(10, np.array([0,1,2,3]))\nall_k = [1, 10, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000]\nfor eta in all_eta:\n\tfor k in all_k:\n\t\tutils.printInBoldRed(f\"QP constraints, eta = {eta}, k={k}\")\n\n\t\tqcs=[]\n\n\t\tdef createRandomQPConstraint(i):\n\t\t\ttmp=np.random.uniform(low=-1.0, high=1.0, size=(k,k))\n\t\t\t# tmp=(torch.empty((k,k), device=\"cuda:0\").uniform_(-1.0, 1.0)).cpu().numpy() #\n\n\t\t\tP=tmp@tmp.T #To make sure it's a (symmetric) PSD matrix\n\t\t\tq=np.random.uniform(low=-1.0, high=1.0, size=(k,1))\n\t\t\tr=np.random.uniform(low=-1.0, high=0.0, size=(1,1))\n\t\t\tqc=constraints.ConvexQuadraticConstraint(P=P, q=q, r=r, do_checks_P=False);\n\t\t\treturn qc\n\n\t\tprint(\"Creating random constraints\")\n\t\tqcs = Parallel(n_jobs=15)(delayed(createRandomQPConstraint)(i) for i in range(eta))\n\t\tprint(\"Created\")\n\n\t\tassert len(qcs)==eta\n\t\t\n\t\tcs=constraints.ConvexConstraints(lc=None, qcs=qcs, socs=[], lmic=None, y0=np.zeros((k,1)))\n\t\ttotal_s=getTime_sMethod(cs, num_samples)\n\t\ttimes_qp.append({'k': k,'eta': eta,'Time': total_s})", "\ntimes_qp=pd.DataFrame(times_qp)\n# utils.savepickle(times_qp, path+\"times_qp.pkl\")\ntimes_qp.to_csv(path+\"times_qp.csv\",index=False)\n\n\n########################################### SOC CONSTRAINTS\ntimes_soc = []\nall_r_M = [10, 100, 200, 300]\nall_mu = [10, 100, 300, 500]", "all_r_M = [10, 100, 200, 300]\nall_mu = [10, 100, 300, 500]\nall_k = [10, 100, 500, 1000] \n\nfor r_M in all_r_M:\n\tfor mu in all_mu:\n\t\tfor k in all_k:\n\t\t\tutils.printInBoldRed(f\"r_M = {r_M}, mu={mu}, k={k}\")\n\n\t\t\tdef createRandomSOCConstraint(i):\n\t\t\t\tM = np.random.uniform(low=-1.0, high=1.0, size=(r_M,k))\n\t\t\t\ts = np.random.uniform(low=-1.0, high=1.0, size=(r_M,1))\n\t\t\t\tc = np.random.uniform(low=-1.0, high=1.0, size=(k,1))\n\t\t\t\td = np.linalg.norm(s)+np.array([[0.5]]) #This ensures that 0 will always be a point in the interior of the feasible set\n\t\t\t\treturn M, s, c, d\n\n\t\t\tprint(\"Creating random constraints\")\n\t\t\tall_Mscd = Parallel(n_jobs=15)(delayed(createRandomSOCConstraint)(i) for i in range(k))\n\t\t\tprint(\"Created\")\n\n\t\t\tsocs=[]\n\t\t\tfor Mscd in all_Mscd:\n\t\t\t\tsocs.append(constraints.SOCConstraint(Mscd[0], Mscd[1], Mscd[2], Mscd[3]))\n\n\t\t\tprint(\"Creating cs\")\n\t\t\tcs=constraints.ConvexConstraints(lc=None, qcs=[], socs=socs, lmic=None, y0=np.zeros((k,1)))\n\t\t\tprint(\"Created\")\n\n\t\t\ttotal_s=getTime_sMethod(cs, num_samples)\n\n\t\t\ttimes_soc.append({'k': k,'r_M': r_M,'mu': mu,'Time': total_s})", "\ntimes_soc=pd.DataFrame(times_soc)\n# utils.savepickle(times_soc, path+\"times_soc.pkl\")\ntimes_soc.to_csv(path+\"times_soc.csv\",index=False)\n\nprint(times_soc)\n\n\n########################################### LMI CONSTRAINTS\ntimes_lmi = []", "########################################### LMI CONSTRAINTS\ntimes_lmi = []\nall_r_F = [10, 100, 200, 300]\nall_k = [100, 500, 1000, 2000, 5000, 7000, 10000]\n\nfor r_F in all_r_F:\n\tfor k in all_k:\n\t\tutils.printInBoldRed(f\"r_F = {r_F}, k={k}\")\n\n\t\tdef createRandomSymmetricMatrix(i):\n\t\t\ttmp=np.random.uniform(low=-1.0, high=1.0, size=(r_F,r_F))\n\t\t\treturn (tmp + tmp.T)/2 #To ensure that it is symmetric\n\n\t\tprint(\"Creating random constraints\")\n\t\tall_F = Parallel(n_jobs=15)(delayed(createRandomSymmetricMatrix)(i) for i in range(k))\n\n\t\ttmp = np.random.uniform(-1, 1, (r_F, r_F))\n\t\tF_k = np.dot(tmp, tmp.transpose()) + 0.5*np.eye(r_F) #F_k is symmetric positive definite by construction\n\t\tall_F.append(F_k)\n\t\tprint(\"Created\")\n\n\t\tprint(\"Creating lmic\")\n\t\tlmic=constraints.LMIConstraint(all_F)\n\t\tprint(\"Created lmic\")\n\n\t\tprint(\"Creating cs\")\n\t\tcs=constraints.ConvexConstraints(lc=None, qcs=[], socs=[], lmic=lmic, y0=np.zeros((k,1)))\n\t\tprint(\"Created\")\n\n\t\ttotal_s=getTime_sMethod(cs, num_samples)\n\n\t\ttimes_lmi.append({'k': k,'r_F': r_F,'Time': total_s})", "\ntimes_lmi=pd.DataFrame(times_lmi)\n# utils.savepickle(times_lmi, path+\"times_lmi.pkl\")\ntimes_lmi.to_csv(path+\"times_lmi.csv\",index=False)\n\nprint(times_lmi)"]}
{"filename": "examples/scripts/merge_all_results.py", "chunked_list": ["# --------------------------------------------------------------------------\n# Jesus Tordesillas Torres, Robotic Systems Lab, ETH Z\u00fcrich \n# See LICENSE file for the license information\n# -------------------------------------------------------------------------- \n\nimport glob, os\nimport pandas as pd\n\nos.chdir(\"./results\")\nall_pkl=[]\nfor file in glob.glob(\"dataset*.pkl\"):\n    all_pkl.append(file)", "os.chdir(\"./results\")\nall_pkl=[]\nfor file in glob.glob(\"dataset*.pkl\"):\n    all_pkl.append(file)\nall_pkl = sorted(all_pkl)\nall_dataframes=[]\nfor file in all_pkl:\n    all_dataframes.append(pd.read_pickle(file))\n\n", "\n\ndf = pd.concat(all_dataframes)\n\n\ndf=df.drop_duplicates(subset=['method'])\n# print(df)\n\n\nresults2d = df[df['method'].str.startswith('dataset2d')]", "\nresults2d = df[df['method'].str.startswith('dataset2d')]\nresults3d = df[df['method'].str.startswith('dataset3d')]\n\nresults2d=results2d.set_index('method')\nresults3d=results3d.set_index('method')\n\nprint(results2d)\nprint(results3d)\n", "print(results3d)\n\n\nresults2d[\"[In dist] loss\"]/=(results2d.loc[\"dataset2d_Optimization\"].at[\"[In dist] loss\"]) #Normalize the cost\nresults2d[\"[Out dist] loss\"]/=(results2d.loc[\"dataset2d_Optimization\"].at[\"[Out dist] loss\"]) #Normalize the cost\n\nresults3d[\"[In dist] loss\"]/=(results3d.loc[\"dataset3d_Optimization\"].at[\"[In dist] loss\"]) #Normalize the cost\nresults3d[\"[Out dist] loss\"]/=(results3d.loc[\"dataset3d_Optimization\"].at[\"[Out dist] loss\"]) #Normalize the cost\n\n", "\n\n\ndf = pd.concat([results2d, results3d])\n\ndf=df.rename(columns={\"[In dist] loss\": \"[In dist] n.loss\", \"[Out dist] loss\": \"[Out dist] n.loss\"})\n\n\nprint(df)\n", "print(df)\n\n# results2d['[In dist] loss']=results2d['[In dist] loss']/results2d[ results2d['method']=='dataset2d_Optimization'  ]\n\ndf.to_csv('./merged.csv')  \n"]}
{"filename": "examples/other/test_bug_logpcg.py", "chunked_list": ["import numpy as np\nimport torch\nimport scipy\n\n# def using_power_iteration(C):\n\t  \n#     b_k = np.random.rand(C.shape[0],1)\n\t  \n#     tol = 1e-6\n#     max_iter = 100", "#     tol = 1e-6\n#     max_iter = 100\n\t  \n#     for i in range(max_iter):\n#         b_k1 = C @ b_k\n#         b_k1 = b_k1 / np.linalg.norm(b_k1)\n\n#         lam=(b_k1.T @ b_k)/(b_k.T @ b_k)\n#         print(lam)\n#         # x = C @ x / np.linalg.norm(C @ x)", "#         print(lam)\n#         # x = C @ x / np.linalg.norm(C @ x)\n#         # lam = (x.T @ C @ x) / (x.T @ x)\n#         # # print(lam)\n#         # if np.abs(lam - lam_prev) < tol:\n#         #     break\n#         # lam_prev = lam\n\t  \n#     return lam\n\ndef eigenvalue(A, v):\n\tAv = A.dot(v)\n\treturn v.dot(Av)", "#     return lam\n\ndef eigenvalue(A, v):\n\tAv = A.dot(v)\n\treturn v.dot(Av)\n\ndef power_iteration(A):\n\tn, d = A.shape\n\n\tv = np.ones(d) / np.sqrt(d)\n\tev = eigenvalue(A, v)\n\n\twhile True:\n\t\tAv = A.dot(v)\n\t\tv_new = Av / np.linalg.norm(Av)\n\n\t\tev_new = eigenvalue(A, v_new) #v_new.dot(A.dot(v_new)) #\n\t\tif np.abs(ev - ev_new) < 1e-12:\n\t\t\tbreak\n\n\t\tv = v_new\n\t\tev = ev_new\n\n\treturn ev_new #, v_new", "\n\ndim=3\n\nwhile True:\n\tprint(\"\\n\\n-------\")\n\n\t#Random generation of matrices A and B\n\ttmp = np.random.uniform(-1, 1, (dim, dim))\n\tA=(tmp+tmp.T)/2.0  #A is symmetric by construction", "\ttmp = np.random.uniform(-1, 1, (dim, dim))\n\tA=(tmp+tmp.T)/2.0  #A is symmetric by construction\n\n\ttmp = np.random.uniform(-1, 1, (dim, dim))\n\tB = np.dot(tmp, tmp.transpose()) + np.eye(dim) #B is symmetric positive definite by construction\n\n\tprint(f\"A={A}\\n\")\n\tprint(f\"B={B}\\n\")\n\n", "\n\n\tX=np.random.rand(A.shape[0], 1) #Initial guess for the eigenvector\n\n\t#### USING lobpcg\n\tlambda_lobpcg, _ = torch.lobpcg(A=torch.from_numpy(A), k=1, B=torch.from_numpy(B), niter=-1, X=torch.from_numpy(X), tol=1e-12)\n\tlambda_lobpcg = lambda_lobpcg.item()\n\tprint(f\"lambda_lobpcg={lambda_lobpcg}\")\n\n\t# #### USING Scipy", "\n\t# #### USING Scipy\n\tlambda_scipy, _ =scipy.sparse.linalg.lobpcg(A=A, B=B, X=X, maxiter=10000)\n\tlambda_scipy=lambda_scipy[0]\n\tprint(f\"lambda_scipy={lambda_scipy}\")\n\n\t#### USING normal eigendecomposition\n\tall_lambdas, _=np.linalg.eig(np.linalg.inv(B)@A); \n\t# print(f\"all_lambdas={all_lambdas}\")\n\tlambda_eig=np.max(all_lambdas)", "\t# print(f\"all_lambdas={all_lambdas}\")\n\tlambda_eig=np.max(all_lambdas)\n\tprint(f\"lambda_eig={lambda_eig}\")\n\n\t#### USING Power iteration\n\tlambda_power_iter=power_iteration(np.linalg.inv(B)@A)\n\tprint(f\"lambda_power_iter={lambda_power_iter}\")\n\n\tassert abs(lambda_lobpcg-lambda_eig)<1e-6\n\tassert abs(lambda_scipy-lambda_eig)<1e-6", "\tassert abs(lambda_lobpcg-lambda_eig)<1e-6\n\tassert abs(lambda_scipy-lambda_eig)<1e-6\n\tassert abs(lambda_power_iter-lambda_eig)<1e-6\n\n\n\n\n\n", ""]}
{"filename": "examples/other/testing_sdp.py", "chunked_list": ["# Import packages.\nimport cvxpy as cp\nimport numpy as np\nfrom numpy import linalg as LA\nimport utils\nimport torch\nimport scipy\n\n\nA=torch.Tensor([", "\nA=torch.Tensor([\n\n                [[2.0, -12.0],\n                 [1.0, -5.0]],\n\n                [[-7.0, 0.0],\n                 [0.0, 5.0]],\n\n                [[-2.0, 0.0],", "\n                [[-2.0, 0.0],\n                 [0.0, 6.0]]\n\n                ])\n\nguess_v = torch.nn.functional.normalize(torch.rand(A.shape[1],1), dim=0)\n\nlamb = utils.findLargestEigenvalue(A, guess_v)\n", "lamb = utils.findLargestEigenvalue(A, guess_v)\n\nL, V = torch.linalg.eig(A)\nprint(L)\n\nprint(f\"Found lambda={lamb}\")\n\nexit()\n\ndim=3", "\ndim=3\n\nfor trial in range(200):\n\n    # Generate a random SDP.\n    tmp = np.random.rand(dim, dim)\n    # tmp = np.random.randint(0, 20, size=(dim, dim))\n    H = np.dot(tmp, tmp.transpose()) + np.eye(dim) #H is psd by construction\n\n    tmp = np.random.rand(dim, dim)\n    # tmp = np.random.randint(0, 20, size=(dim, dim))\n    S=(tmp+tmp.T)/2.0  #M is symmetric by construction\n\n    # tmp = np.random.rand(dim, dim)\n    # M = np.dot(tmp, tmp.transpose()) #H is psd by construction\n\n    Hinv=np.linalg.inv(H)\n\n    print(\"\\n\\n-------\")\n    print(\"-------\")\n\n    print(f\"H={H}\\n\")\n    print(f\"S={S}\\n\")\n\n\n\n    # kappa_opt = cp.Variable()\n    # constraints = [(kappa_opt*H+S) >> 0, kappa_opt>=0]\n\n    # prob = cp.Problem(cp.Minimize(kappa_opt), constraints)\n    # prob.solve(solver=cp.SCS, verbose=True, eps=1e-7)\n\n    # if(prob.status=='unbounded'):\n    #     utils.printInBoldRed(\"Unbounded!!!!\") #When kappa is the decision variable, there is no way the result is unbounded\n    # else:\n    #     kappa_opt=kappa_opt.value\n    #     utils.printInBoldBlue(f\"kappa_opt={kappa_opt}\")\n\n\n    X=np.random.rand(S.shape[0], 1)\n\n    #### USING lobpcg\n    kappa_lobpcg, _ = torch.lobpcg(A=torch.from_numpy(-S), k=1, B=torch.from_numpy(H), niter=-1, X=torch.from_numpy(X))\n    # kappa_lobpcg = torch.relu(kappa_lobpcg).item()\n    kappa_lobpcg = kappa_lobpcg.item()\n    utils.printInBoldBlue(f\"kappa_lobpcg={kappa_lobpcg}\")\n\n    # #### USING Scipy\n    # kappa_scipy, _ =scipy.sparse.linalg.lobpcg(A=-S, B=H, X=X, maxiter=-1)\n    # kappa_scipy=kappa_scipy[0]\n    # utils.printInBoldBlue(f\"kappa_scipy={kappa_scipy}\")\n\n    #### USING normal eigendecomposition\n    all_kappas, _ = np.linalg.eig(-Hinv@S); #Be careful because Hinv@M is NOT symmetric (Hinv and M is)\n    print(f\"all_kappas={all_kappas}\")\n    # kappa_eig=np.maximum(np.max(all_kappas),0.0)\n    kappa_eig=np.max(all_kappas)\n    utils.printInBoldBlue(f\"kappa_eig={kappa_eig}\")\n\n    tol=1e-6\n    assert abs(kappa_lobpcg-kappa_eig)<tol", "    # assert abs(kappa_scipy-kappa_eig)<tol\n    # assert abs(kappa_opt-kappa_eig)<tol #This one sometimes fails due to inaccuracies in the optimization\n\n\n\n# LPBPCG algorithm is not applicable when the number of A rows (=2) is smaller than 3 x the number of requested eigenpairs (=1)\n\n\n\n#This should be zero", "\n#This should be zero\n# print(np.linalg.det(H+lam.value*M))\n\n# print(np.linalg.det(Minv@H+lam.value*np.eye(2)))\n\n# for i in range(all_kappas.shape[0]):\n#     tmp=all_kappas[i]\n\n#     # print(np.linalg.det(-Hinv@M-tmp*np.eye(dim)))", "\n#     # print(np.linalg.det(-Hinv@M-tmp*np.eye(dim)))\n#     print(f\"tmp={tmp}\")\n#     eigenvals,_=np.linalg.eig(tmp*H+S)\n#     print(eigenvals)\n\n\n# print(\"-------\")\n# print(\"Eigen Decomposition of H\")\n", "# print(\"Eigen Decomposition of H\")\n\n# wH, vH = LA.eig(H)\n# print(f\"Eigenvalues={wH}\")\n# print(f\"Eigenvectors=\\n{vH}\")\n\n# print(\"-------\")\n# print(\"Eigen Decomposition of M\")\n\n# wM, vM = LA.eig(M)", "\n# wM, vM = LA.eig(M)\n# print(f\"Eigenvalues={wM}\")\n# print(f\"Eigenvectors=\\n{vM}\\n\")\n\n# for i in range(wH.shape[0]):\n#     for j in range(wM.shape[0]):\n#         print(wH[i]/wM[j])\n#         print(wM[j]/wH[i])\n#         print(wH[i]*wM[j])", "#         print(wM[j]/wH[i])\n#         print(wH[i]*wM[j])\n\n# beta = cp.Variable()\n# constraints = [H >> beta*M]\n\n# prob = cp.Problem(cp.Minimize(beta), constraints)\n# prob.solve()\n# print(f\"beta={beta.value}\")\n", "# print(f\"beta={beta.value}\")\n\n# Hinv=np.linalg.inv(H)\n# constraints = [(np.eye(2)+lam*Hinv@M) >> 0]\n# prob = cp.Problem(cp.Maximize(lam), constraints)\n# prob.solve()\n# print(f\"lam={lam.value}\")\n\n# L = np.linalg.cholesky(H)\n# # print(L@L.T-H) #good", "# L = np.linalg.cholesky(H)\n# # print(L@L.T-H) #good\n\n# Y=np.linalg.inv(L)@M@(np.linalg.inv(L).T)\n\n# constraints = [(Y+lam*np.eye(2)) >> 0]\n\n# prob = cp.Problem(cp.Maximize(lam), constraints)\n# prob.solve()\n# print(f\"lam={lam.value}\")", "# prob.solve()\n# print(f\"lam={lam.value}\")\n\n\n\n\n\n#Inspired by https://github.com/rfeinman/Torch-ARPACK/blob/master/arpack/power_iteration.py\n# def power_iteration(A, tol=1e-20, max_iter=10000, eps=1e-12, check_freq=2):\n", "# def power_iteration(A, tol=1e-20, max_iter=10000, eps=1e-12, check_freq=2):\n\n#     v = torch.nn.functional.normalize(torch.rand(A.shape[1],1), dim=0)\n\n#     n_iter = 0\n#     converging = torch.ones(A.shape[0], dtype=torch.bool)# [True True True ...]\n#     print(converging)\n#     while n_iter < max_iter:\n#         n_iter += 1\n#         if(n_iter==1):", "#         n_iter += 1\n#         if(n_iter==1):\n#             u = torch.nn.functional.normalize(A@v, dim=1)\n#             v = u\n#             continue\n\n#         else:\n\n#             print(f\"converging before={converging}\")\n", "#             print(f\"converging before={converging}\")\n\n#             u[converging,:,:] = torch.nn.functional.normalize(A[converging,:,:]@v[converging,:,:], dim=1)\n                \n#             distance=torch.abs(1 - torch.abs(  torch.transpose(v,1,2)@u ))\n#             print(f\"distance={distance}\")\n            \n#             v[converging,:,:] = u[converging,:,:]\n\n#             converging = (distance>tol).flatten()", "\n#             converging = (distance>tol).flatten()\n\n#             print(f\"converging after={converging}\")\n\n\n#             if (torch.all(converging == False)): #All of them converged\n#                 break\n\n#     else:", "\n#     else:\n#         warnings.warn('power iteration did not converge')\n\n        \n\n#     lamb =  torch.transpose(v,1,2)@A@v #torch.dot(v, torch.mv(A, v))\n\n#     return lamb", "#     return lamb"]}
{"filename": "examples/other/plot_examples_with_mayavi.py", "chunked_list": ["import numpy as np\nfrom mayavi import mlab\nimport utils\nimport examples_sets\nimport random   \nimport copy \nfrom joblib import Parallel, delayed\n\nindex_example=1\n", "index_example=1\n\ncs=examples_sets.getExample(index_example)\n\n# @np.vectorize\ndef get_conditions(x):\n    conditions=[];\n    all_is_ineq_condition=[]\n\n    if(cs.has_linear_ineq_constraints):\n        for i in range(cs.lc.A1.shape[0]):\n            expression=cs.lc.A1[i,:]@x-cs.lc.b1[i,0]\n            conditions.append(expression[0])\n            all_is_ineq_condition.append(True)\n\n    if(cs.has_linear_eq_constraints):\n        for i in range(cs.lc.A2.shape[0]):\n            expression=cs.lc.A2[i,:]@x-cs.lc.b2[i,0]\n            conditions.append(expression[0])\n            all_is_ineq_condition.append(False)\n\n\n    if(cs.has_quadratic_constraints):\n        for qc in cs.qcs:\n            expression=0.5*x.T@qc.P@x + qc.q.T@x + qc.r \n            conditions.append(expression[0,0])\n            all_is_ineq_condition.append(True)\n\n\n    if(cs.has_soc_constraints):\n        for soc in cs.socs:\n            expression=np.linalg.norm(soc.M@x +soc.s) -soc.c.T@x  - soc.d \n            conditions.append(expression[0,0])\n            all_is_ineq_condition.append(True)\n\n\n    return conditions, all_is_ineq_condition", "\nnum_points=100j\ndist_min=0\ndist_max=2\nall_x, all_y, all_z = np.mgrid[-dist_min:dist_max:num_points, -dist_min:dist_max:num_points, -dist_min:dist_max:num_points]\n\nnum_points=int(num_points.imag)\n\ntmp, all_is_ineq_condition=get_conditions(np.zeros((3,1)))\nnum_of_conditions=len(tmp)", "tmp, all_is_ineq_condition=get_conditions(np.zeros((3,1)))\nnum_of_conditions=len(tmp)\n\n### Create dummy list of numpy arrays\nconditions=[];\nfor i in range(num_of_conditions):\n    zero_tensor=np.zeros((num_points,num_points,num_points))\n    conditions.append(zero_tensor)\n\ndef my_function(i, j, k, conditions):\n    print((i,j,k))\n    x=np.array([[all_x[i,j,k]],[all_y[i,j,k]],[all_z[i,j,k]]]);\n    tmp,_=get_conditions(x)\n    return tmp", "\ndef my_function(i, j, k, conditions):\n    print((i,j,k))\n    x=np.array([[all_x[i,j,k]],[all_y[i,j,k]],[all_z[i,j,k]]]);\n    tmp,_=get_conditions(x)\n    return tmp\n\n\nresult=Parallel(n_jobs=40)(delayed(my_function)(i, j, k, conditions) for i in range(all_x.shape[0]) for j in range(all_x.shape[1]) for k in range(all_x.shape[2]))\n", "result=Parallel(n_jobs=40)(delayed(my_function)(i, j, k, conditions) for i in range(all_x.shape[0]) for j in range(all_x.shape[1]) for k in range(all_x.shape[2]))\n\nprint(len(result))\nprint(len(result[0]))\n\nindex=0;\nfor i in range(all_x.shape[0]):\n    for j in range(all_x.shape[1]):\n        for k in range(all_x.shape[2]):\n\n            for index_cond in range(num_of_conditions):#For each condition\n                conditions[index_cond][i,j,k]=result[index][index_cond]\n\n            index+=1", "\n\nconditions_processed=[]\nfor i in range(len(conditions)):\n\n    cond_i=copy.deepcopy(conditions[i])\n    for j in range(len(conditions)):\n        if (i==j):\n            continue\n        cond_j=conditions[j]\n        \n        cond_j_is_ineq=all_is_ineq_condition[j]\n\n        if(cond_j_is_ineq):\n            cond_i[cond_j>0.0]=None #See https://stackoverflow.com/questions/40461045/mayavi-combining-two-implicit-3d-surfaces\n        else:\n            cond_i[cond_j>0.0]=None\n            cond_i[cond_j<0.0]=None\n\n    conditions_processed.append(cond_i)", "\n\nfor i in range(len(conditions_processed)):\n    # print(i)\n    cond_i=conditions_processed[i]\n    # print(cond_i)\n    if(np.isnan(cond_i).all()):\n        continue\n    maximum=np.nanmax(cond_i)\n    minimum=np.nanmin(cond_i)\n    if(maximum<0 or minimum>0):\n        print(\"Continue\")\n        continue;\n    color=tuple(random.random() for _ in range(3))\n    tmp=mlab.contour3d(all_x,all_y,all_z,cond_i, contours = [0], color=color, opacity=1.0) ", "    # tmp.actor.property.interpolation = 'phong' #https://stackoverflow.com/a/31754643\n    # tmp.actor.property.specular = 0.9\n    # tmp.actor.property.specular_power = 128\n\nlensoffset=0.0\nxx = yy = zz = np.arange(0.0,1.5,0.1)\nxy = xz = yx = yz = zx = zy = np.zeros_like(xx)    \nmlab.plot3d(yx,yy+lensoffset,yz,line_width=0.01,tube_radius=0.02)\nmlab.plot3d(zx,zy+lensoffset,zz,line_width=0.01,tube_radius=0.02)\nmlab.plot3d(xx,xy+lensoffset,xz,line_width=0.01,tube_radius=0.02)", "mlab.plot3d(zx,zy+lensoffset,zz,line_width=0.01,tube_radius=0.02)\nmlab.plot3d(xx,xy+lensoffset,xz,line_width=0.01,tube_radius=0.02)\n\nprint(\"Showing!\")\nmlab.show()\n"]}
