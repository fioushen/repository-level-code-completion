{"filename": "setup.py", "chunked_list": ["#!/usr/bin/env python\n\n# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n# SPDX-License-Identifier: Apache-2.0\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0", "#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n", "\n\nfrom setuptools import setup\n\nsetup(\n    name=\"holoscan_test_suite\",\n    version=\"0.1\",\n    author=\"Patrick O'Grady\",\n    author_email=\"pogrady@nvidia.com\",\n    description=\"Tools used by Holoscan Test Suite.\",", "    author_email=\"pogrady@nvidia.com\",\n    description=\"Tools used by Holoscan Test Suite.\",\n    packages=[\"holoscan_test_suite\"],\n    include_package_data = True,\n    package_data = {\"\": [\"test_image.png\"]},\n    entry_points=dict(\n        console_scripts=[\"show_test_pattern=holoscan_test_suite.show_test_pattern:main\"]\n    ),\n    install_requires=[\n        \"opencv-python\",", "    install_requires=[\n        \"opencv-python\",\n        \"pyyaml\",\n    ],\n    zip_safe=False,\n)\n"]}
{"filename": "holoscan_test_suite/controls.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n# SPDX-License-Identifier: Apache-2.0\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software", "#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n#\n# See README.md for detailed information.\n", "# See README.md for detailed information.\n\n# This module provides support for a few HTML UI elements, using a websocket and\n# JS to 1) send UI selections to the server and 2) for the server to provide\n# updated data for the UI.  All these controls write their values using\n# websocket broadcast requests, so any number of clients can connect and they'll\n# always see synchonized state.\n\n\nimport flask_socketio", "\nimport flask_socketio\nfrom . import html_render\nimport os\nimport subprocess\nimport traceback\n\n\nclass Runner:\n    \"\"\"\n    Runner manages a subprocess that is invoked by the UI, providing a way\n    for the user to start and stop the command and for stdout and stderr\n    from the process to appear on the UI.  Once the runner is constructed,\n    be sure and call \"(runner).set_control(ui_element)\" in order for stderr\n    and stdout to be displayed as expected.\n    \"\"\"\n\n    def __init__(self, reactor, app, command, env_update={}, cwd=None):\n        self._app = app\n        self._command = command\n        self._process = None\n        self._env_update = env_update\n        self._cwd = cwd\n        self._reactor = reactor\n\n    def set_control(self, control):\n        \"\"\"I don't set self._control in the\n        constructor so we're sure to get an\n        error if someone doesn't call set_control.\n        \"\"\"\n        self._control = control\n        self._control_name = control._control_name\n\n    def start(self):\n        if self._process is None:\n            # Clear the stdout/stderr displayed on the page\n            with self._app.test_request_context(\"/\"):\n                flask_socketio.emit(\n                    \"%s-reset\" % self._control_name,\n                    {\"control\": self._control_name},\n                    broadcast=True,\n                    namespace=\"/\",\n                )\n            self._start()\n        else:\n            print('Already started \"%s\" -- ignoring' % (self._command,))\n\n    def _start(self):\n        print('Starting \"%s\"' % (self._command,))\n        env = {}\n        env.update(os.environ)  # make a copy of the current environment\n        env.update(self._env_update)  # update it according to our prefs\n        self._stdout_r, self._stdout_w = os.pipe()\n        self._stderr_r, self._stderr_w = os.pipe()\n        self._reactor.register(self._stdout_r, self.stdout)\n        self._reactor.register(self._stderr_r, self.stderr)\n        try:\n            self._process = subprocess.Popen(\n                args=self._command,\n                env=env,\n                stdout=self._stdout_w,\n                stderr=self._stderr_w,\n                cwd=self._cwd,\n                bufsize=0,\n            )\n        except Exception as e:\n            s = traceback.format_exception(e)\n            l = \"\".join(s)\n            os.write(self._stderr_w, l.encode(\"utf-8\"))\n            print(l)\n        os.close(self._stdout_w)\n        self._stdout_w = -1\n        os.close(self._stderr_w)\n        self._stderr_w = -1\n\n    def stop(self):\n        if self._process is not None:\n            self._stop()\n        else:\n            print('Not currently running \"%s\" -- ignoring' % (self._command,))\n\n    def _stop(self):\n        process = self._process\n        self._process = None\n        print('Stopping \"%s\"' % (self._command,))\n        process.terminate()\n        timeout_s = 20\n        process.communicate(timeout=timeout_s)\n        if self._stdout_w != -1:\n            os.close(self._stdout_w)\n            self._stdout_w = -1\n        if self._stderr_w != -1:\n            os.close(self._stderr_w)\n            self._stderr_w = -1\n        self._control.stopped()\n\n    def update(self, state):\n        if state:\n            self.start()\n        else:\n            self.stop()\n        return self._process is not None\n\n    def stderr(self, event):\n        value = os.read(self._stderr_r, 8192).decode()\n        if len(value) == 0:\n            print(\"stderr closed.\")\n            self._reactor.unregister(self._stderr_r)\n            os.close(self._stderr_r)\n            if self._process is not None:\n                self.stop()\n            return\n        with self._app.test_request_context(\"/\"):\n            flask_socketio.emit(\n                \"%s-stderr\" % self._control_name,\n                {\"control\": self._control_name, \"value\": value},\n                broadcast=True,\n                namespace=\"/\",\n            )\n\n    def stdout(self, event):\n        value = os.read(self._stdout_r, 8192).decode()\n        if len(value) == 0:\n            print(\"stdout closed.\")\n            self._reactor.unregister(self._stdout_r)\n            os.close(self._stdout_r)\n            if self._process is not None:\n                self.stop()\n            return\n        with self._app.test_request_context(\"/\"):\n            flask_socketio.emit(\n                \"%s-stdout\" % self._control_name,\n                {\"control\": self._control_name, \"value\": value},\n                broadcast=True,\n                namespace=\"/\",\n            )", "class Runner:\n    \"\"\"\n    Runner manages a subprocess that is invoked by the UI, providing a way\n    for the user to start and stop the command and for stdout and stderr\n    from the process to appear on the UI.  Once the runner is constructed,\n    be sure and call \"(runner).set_control(ui_element)\" in order for stderr\n    and stdout to be displayed as expected.\n    \"\"\"\n\n    def __init__(self, reactor, app, command, env_update={}, cwd=None):\n        self._app = app\n        self._command = command\n        self._process = None\n        self._env_update = env_update\n        self._cwd = cwd\n        self._reactor = reactor\n\n    def set_control(self, control):\n        \"\"\"I don't set self._control in the\n        constructor so we're sure to get an\n        error if someone doesn't call set_control.\n        \"\"\"\n        self._control = control\n        self._control_name = control._control_name\n\n    def start(self):\n        if self._process is None:\n            # Clear the stdout/stderr displayed on the page\n            with self._app.test_request_context(\"/\"):\n                flask_socketio.emit(\n                    \"%s-reset\" % self._control_name,\n                    {\"control\": self._control_name},\n                    broadcast=True,\n                    namespace=\"/\",\n                )\n            self._start()\n        else:\n            print('Already started \"%s\" -- ignoring' % (self._command,))\n\n    def _start(self):\n        print('Starting \"%s\"' % (self._command,))\n        env = {}\n        env.update(os.environ)  # make a copy of the current environment\n        env.update(self._env_update)  # update it according to our prefs\n        self._stdout_r, self._stdout_w = os.pipe()\n        self._stderr_r, self._stderr_w = os.pipe()\n        self._reactor.register(self._stdout_r, self.stdout)\n        self._reactor.register(self._stderr_r, self.stderr)\n        try:\n            self._process = subprocess.Popen(\n                args=self._command,\n                env=env,\n                stdout=self._stdout_w,\n                stderr=self._stderr_w,\n                cwd=self._cwd,\n                bufsize=0,\n            )\n        except Exception as e:\n            s = traceback.format_exception(e)\n            l = \"\".join(s)\n            os.write(self._stderr_w, l.encode(\"utf-8\"))\n            print(l)\n        os.close(self._stdout_w)\n        self._stdout_w = -1\n        os.close(self._stderr_w)\n        self._stderr_w = -1\n\n    def stop(self):\n        if self._process is not None:\n            self._stop()\n        else:\n            print('Not currently running \"%s\" -- ignoring' % (self._command,))\n\n    def _stop(self):\n        process = self._process\n        self._process = None\n        print('Stopping \"%s\"' % (self._command,))\n        process.terminate()\n        timeout_s = 20\n        process.communicate(timeout=timeout_s)\n        if self._stdout_w != -1:\n            os.close(self._stdout_w)\n            self._stdout_w = -1\n        if self._stderr_w != -1:\n            os.close(self._stderr_w)\n            self._stderr_w = -1\n        self._control.stopped()\n\n    def update(self, state):\n        if state:\n            self.start()\n        else:\n            self.stop()\n        return self._process is not None\n\n    def stderr(self, event):\n        value = os.read(self._stderr_r, 8192).decode()\n        if len(value) == 0:\n            print(\"stderr closed.\")\n            self._reactor.unregister(self._stderr_r)\n            os.close(self._stderr_r)\n            if self._process is not None:\n                self.stop()\n            return\n        with self._app.test_request_context(\"/\"):\n            flask_socketio.emit(\n                \"%s-stderr\" % self._control_name,\n                {\"control\": self._control_name, \"value\": value},\n                broadcast=True,\n                namespace=\"/\",\n            )\n\n    def stdout(self, event):\n        value = os.read(self._stdout_r, 8192).decode()\n        if len(value) == 0:\n            print(\"stdout closed.\")\n            self._reactor.unregister(self._stdout_r)\n            os.close(self._stdout_r)\n            if self._process is not None:\n                self.stop()\n            return\n        with self._app.test_request_context(\"/\"):\n            flask_socketio.emit(\n                \"%s-stdout\" % self._control_name,\n                {\"control\": self._control_name, \"value\": value},\n                broadcast=True,\n                namespace=\"/\",\n            )", "\n\nclass Control:\n    \"\"\"\n    Superclass for UI elements that have these methods:\n    - render: creates the HTML (including the JS),\n    - request: callback when the UI requests the current value,\n    - update: callback when the UI wishes to change the value\n    - stopped: runner calls this when the process terminates\n    \"\"\"\n\n    def __init__(self, app, label, control_name):\n        self._app = app\n        self._label = label\n        self._control_name = control_name\n\n    def render(self, r):\n        \"\"\"\n        This method is used to create the HTML that\n        renders the control, along with javascript\n        support (e.g. so that this control can call\n        request() or update()).  The HTML this guy\n        generates is to be appended to the list\n        given in the parameter 'r'.\n        \"\"\"\n        pass\n\n    def request(self, control_name):\n        \"\"\"\n        When the UI wants to know what the\n        state of this control is, the framework\n        generates a call to request.\n        @returns a dict with a \"value\" field\n        that controls the state of the item\n        in the UI.  For example, a Checkbox\n        expects the value to be True or False:\n        @code\n            return {\n                \"value\": True # or False as appropriate\n            }\n        @endcode\n        Other control types may expect strings or\n        other data types.\n        \"\"\"\n        pass\n\n    def update(self, control_name, value):\n        \"\"\"\n        The framework calls this method\n        when the user changes the value\n        on the UI.  This method returns\n        a dict following the same spec\n        as the request method.\n        \"\"\"\n        pass\n\n    def stopped(self):\n        \"\"\"\n        Runner calls this when it detects the program\n        it's supervising has terminated; e.g. Checkbox uses\n        this to set the UI value to False (unchecking\n        the box on the UI).\n        \"\"\"\n        pass", "\n\nclass Checkbox(Control):\n    \"\"\"\n    Provides a Control which is rendered as a checkbox\n    and the value is \"True\" or \"False\"\n    \"\"\"\n\n    def __init__(\n        self, app, label, control_name, value=False, update=lambda value: value\n    ):\n        super(Checkbox, self).__init__(app, label, control_name)\n        self._value = value\n        self._update = update\n\n    def render(self, r):\n        \"\"\"\n        Provide the HTML that implements the checkbox, including\n        the Checkbox control and Javascript support code to keep\n        the value shown in the browser up to date.\n\n        \"\"\"\n        r.append(\n            [\n                # Render the input element itself in a disabled (grayed out) mode;\n                # we'll enable it when we get the current value from the server via js.\n                html_render.checkbox(\n                    self._label,\n                    attributes={\n                        \"disabled\": None,\n                        \"id\": self._control_name,\n                    },\n                ),\n                # Render a table--which is normally hidden--where we'll put the\n                # stdout and stderr generated when this control is activated.\n                html_render.table(\n                    [\n                        [\n                            \"stdout\",\n                            html_render.pre(\n                                html_render.div(\n                                    \"\",\n                                    attributes={\"id\": \"%s_stdout\" % self._control_name},\n                                ),\n                            ),\n                        ],\n                        [\n                            \"stderr\",\n                            html_render.pre(\n                                html_render.div(\n                                    \"\",\n                                    attributes={\"id\": \"%s_stderr\" % self._control_name},\n                                ),\n                            ),\n                        ],\n                    ],\n                    attributes={\"id\": f\"{self._control_name}_output\", \"hidden\": None},\n                ),\n                # Javascript support\n                html_render.javascript(\n                    f\"\"\"\n                // Make js variables that point to the checkbox and it's stdout/stderr fields.\n                const {self._control_name} = document.getElementById(\"{self._control_name}\");\n                const {self._control_name}_stdout = document.getElementById(\"{self._control_name}_stdout\");\n                const {self._control_name}_stderr = document.getElementById(\"{self._control_name}_stderr\");\n                const {self._control_name}_output = document.getElementById(\"{self._control_name}_output\");\n                // Request the initial value from the server.\n                socket.on(\"connect\", (event) => {{\n                    console.log(\"Requesting status: {self._control_name}\");\n                    socket.emit(\"request\", {{control: \"{self._control_name}\"}});\n                }});\n                // Handle updates (incl the initial value) from the server;\n                // update the control per the value and enable the control.\n                socket.on(\"{self._control_name}-value\", (event) => {{\n                    value = event.value;\n                    console.log(\"Value received, {self._control_name}=\" + value);\n                    {self._control_name}.checked = value;\n                    {self._control_name}.disabled = !event.enable;\n                }});\n                // When the user clicks this thing, send the new value to the server.\n                {self._control_name}.onclick = function() {{\n                    socket.emit(\"update\", {{value: this.checked, control: \"{self._control_name}\"}});\n                }};\n                // When the websocket closes, gray this thing out.\n                socket.on(\"disconnect\", (event) => {{\n                    console.log(\"Closing {self._control_name}\");\n                    {self._control_name}.disabled = true;\n                }});\n                // add to stdout\n                socket.on(\"{self._control_name}-stdout\", (event) => {{\n                    value = event.value;\n                    console.log(\"stdout received, {self._control_name}=\" + value);\n                    {self._control_name}_stdout.append(value);\n                    {self._control_name}_output.hidden = false;\n                }});\n                // add to stderr\n                socket.on(\"{self._control_name}-stderr\", (event) => {{\n                    value = event.value;\n                    console.log(\"stderr received, {self._control_name}=\" + value);\n                    {self._control_name}_stderr.append(value);\n                    {self._control_name}_output.hidden = false;\n                }});\n                // clear both stdout and stderr\n                socket.on(\"{self._control_name}-reset\", (event) => {{\n                    {self._control_name}_stdout.innerHTML = \"\";\n                    {self._control_name}_stderr.innerHTML = \"\";\n                    {self._control_name}_output.hidden = true;\n                }});\n            \"\"\"\n                ),\n            ]\n        )\n\n    def update(self, control_name, value):\n        r = self._update(value)\n        self._value = r\n        return {\n            \"control\": control_name,\n            \"value\": self._value,\n            \"enable\": True,\n        }\n\n    def request(self, control_name):\n        return {\n            \"control\": control_name,\n            \"value\": self._value,\n            \"enable\": True,\n        }\n\n    def stopped(self):\n        reply = self.update(self._control_name, False)\n        with self._app.test_request_context(\"/\"):\n            flask_socketio.emit(\n                \"%s-value\" % self._control_name,\n                reply,\n                broadcast=True,\n                namespace=\"/\",\n            )", "\n\nclass Status(Control):\n    \"\"\"\n    Renders as a static <div> where a value can be displayed.\n    Calling \"publish\" on this object will update the UI.\n    @code\n        value = \"whatever new value you want to display\"\n        status_object.publish({\"value\": value})\n    @endcode\n\n    \"\"\"\n\n    def __init__(self, app, label, control_name):\n        super(Status, self).__init__(app, label, control_name)\n\n    def render(self, r):\n        attributes = {\n            \"id\": self._control_name,\n            \"disabled\": None,\n        }\n        r.append(\n            [\n                self._label,\n                [\n                    html_render.pre(html_render.div(\"\", attributes=attributes)),\n                    # Javascript support\n                    html_render.javascript(\n                        f\"\"\"\n                    // Make a js variable that points to the checkbox.\n                    const {self._control_name} = document.getElementById(\"{self._control_name}\");\n                    // Request the initial value from the server.\n                    socket.on(\"connect\", (event) => {{\n                        console.log(\"Requesting status: {self._control_name}\");\n                        socket.emit(\"request\", {{control: \"{self._control_name}\"}});\n                    }});\n                    // Handle updates (incl the initial value) from the server;\n                    // update the control per the value and enable the control.\n                    socket.on(\"{self._control_name}-value\", (event) => {{\n                        value = event.value;\n                        console.log(\"Value received, {self._control_name}=\" + value);\n                        {self._control_name}.innerHTML = value;\n                        {self._control_name}.disabled = false;\n                    }});\n                    // When the websocket closes, gray this thing out.\n                    socket.on(\"disconnect\", (event) => {{\n                        console.log(\"Closing {self._control_name}\");\n                        {self._control_name}.disabled = true;\n                    }});\n                \"\"\"\n                    ),\n                ],\n            ]\n        )\n\n    def publish(self, value):\n        reply = {\n            \"control\": self._control_name,\n            \"enable\": True,\n        }\n        reply.update(value)\n        with self._app.test_request_context(\"/\"):\n            flask_socketio.emit(\n                \"%s-value\" % self._control_name,\n                reply,\n                broadcast=True,\n                namespace=\"/\",\n            )\n\n    def stopped(self):\n        pass", ""]}
{"filename": "holoscan_test_suite/html_render.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n# SPDX-License-Identifier: Apache-2.0\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software", "#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n#\n# See README.md for detailed information.\n#", "# See README.md for detailed information.\n#\n# html_render is a simple tool that creates e.g. HTML pages.  The idea is that\n# content is represented as a list of lists (which is really a tree) which is\n# flattened out at the very end, when the page is rendered.  In this way,\n# almost any content can be the content of other tags.  For example::\n#\n#       content = italic(\"Hello, world!\")\n#\n# content is now a list of [\"<i>\", \"Hello, world!\", \"</i>\"].  Use \"append\" to", "#\n# content is now a list of [\"<i>\", \"Hello, world!\", \"</i>\"].  Use \"append\" to\n# add to that content:\n#\n#       content.append(\"This is normal\")\n#       content.append(bold(\"This is bold\"))\n#\n# content is now [\"<i>\", \"Hello, world!\", \"</i>\", \"This is normal\", [\"<b>\",\n# \"This is bold\", \"</b>\"]].  To make a well-formed HTML page out of this:\n#", "# \"This is bold\", \"</b>\"]].  To make a well-formed HTML page out of this:\n#\n#       doc = html(body(content))\n#\n# doc is now [\"<html>\", [\"<body>\", [\"<i>\", \"Hello, world!\", \"</i>\", \"This is\n# normal\", [\"<b>\", \"This is bold\", \"</b>\"]], \"</body>\"], \"</html>\"] The flatten\n# routine adds each element from the given tree as found by a depth-first\n# traversal:\n#\n#       l = flatten([], doc)", "#\n#       l = flatten([], doc)\n#\n# l is now [\"<html>\", \"<body>\", \"<i>\", \"Hello, world!\", \"</i>\", \"This is\n# normal\", \"<b>\", \"This is bold\", \"</b>\", \"</body>\", \"</html>\"].  More commonly,\n# use render to flatten then join the results into a single string:\n#\n#       r = render(doc)\n#\n# r is now", "#\n# r is now\n# \"<html><body><i>Hello, world!</i>This is normal<b>This is bold</b></body></html>\"\n# Note that render(l) and render(doc) produce the same result,\n# because render does a flatten step first, which would have no effect on\n# an already-flattened list.\n#\n\nfrom html import escape\nimport yaml", "from html import escape\nimport yaml\n\n\n#\n# HTML Support\n#\ndef flatten(r, tree):\n    \"\"\"Given a tree, append to list r the elements in a depth-first traversal.\n    Application code doesn't normally call this method; just use render.\n    \"\"\"\n    for element in tree:\n        if hasattr(element, \"html\"):\n            v = element.html()\n            flatten(r, v)\n            continue\n        if isinstance(element, list):\n            flatten(r, element)\n        else:\n            r.append(str(element))\n    return r", "\n\ndef render(tree):\n    \"\"\"Flatten the given tree then return it, joined together into a single\n    string.\n    \"\"\"\n    out = \"\".join(flatten([], tree))\n    return out\n\n\ndef tag(tag_name, style=None, attributes=None):\n    \"\"\"Return content for \"<tag attribute(s)... style=style(s)...>\"\n    with the given elements from the maps for style or attributes.\n    style or attributes can be None or {}, in which case\n    the relevant section is omitted.\n    \"\"\"\n    r = [\"<\", tag_name]\n    if (attributes is not None) and len(attributes):\n        for k, v in attributes.items():\n            if v is None:\n                r.append(\" %s\" % k)\n            else:\n                r.append(' %s=\"%s\"' % (k, escape(v)))\n    if (style is not None) and len(style):\n        r.append(' style=\"')\n        r.append(\";\".join(\"%s:%s\" % (k, v) for k, v in style.items()))\n        r.append('\"')\n    r.append(\">\")\n    return r", "\n\ndef tag(tag_name, style=None, attributes=None):\n    \"\"\"Return content for \"<tag attribute(s)... style=style(s)...>\"\n    with the given elements from the maps for style or attributes.\n    style or attributes can be None or {}, in which case\n    the relevant section is omitted.\n    \"\"\"\n    r = [\"<\", tag_name]\n    if (attributes is not None) and len(attributes):\n        for k, v in attributes.items():\n            if v is None:\n                r.append(\" %s\" % k)\n            else:\n                r.append(' %s=\"%s\"' % (k, escape(v)))\n    if (style is not None) and len(style):\n        r.append(' style=\"')\n        r.append(\";\".join(\"%s:%s\" % (k, v) for k, v in style.items()))\n        r.append('\"')\n    r.append(\">\")\n    return r", "\n\ndef link(content, url, style=None, attributes=None):\n    href = dict(attributes) if attributes is not None else {}\n    href[\"href\"] = url\n    return [tag(\"a\", style=style, attributes=href), content, \"</a>\"]\n\n\ndef paragraph(content, style=None):\n    return [tag(\"p\", style=style), content, \"</p>\"]", "def paragraph(content, style=None):\n    return [tag(\"p\", style=style), content, \"</p>\"]\n\n\ndef horizontal_rule():\n    return \"<hr/>\"\n\n\ndef pre(content, style=None):\n    return [tag(\"pre\", style=style), content, \"</pre>\"]", "def pre(content, style=None):\n    return [tag(\"pre\", style=style), content, \"</pre>\"]\n\n\ndef italic(content):\n    return [\"<i>\", content, \"</i>\"]\n\n\ndef bold(content):\n    return [\"<b>\", content, \"</b>\"]", "def bold(content):\n    return [\"<b>\", content, \"</b>\"]\n\n\n# Stop chrome from trying to translate from Maltese\ndefault_html_attributes = {\n    \"lang\": \"en-US\",\n}\n\n\ndef html_start(attributes=default_html_attributes):\n    return [tag(\"html\", attributes=attributes)]", "\n\ndef html_start(attributes=default_html_attributes):\n    return [tag(\"html\", attributes=attributes)]\n\n\ndef html_end():\n    return [\"</html>\"]\n\n\ndef html(content, attributes=default_html_attributes):\n    return [html_start(attributes), content, html_end()]", "\n\ndef html(content, attributes=default_html_attributes):\n    return [html_start(attributes), content, html_end()]\n\n\ndef body_start(attributes={}):\n    return [tag(\"body\", attributes=attributes)]\n\n\ndef body_end():\n    return [\"</body>\"]", "\n\ndef body_end():\n    return [\"</body>\"]\n\n\ndef body(content, attributes={}):\n    return [body_start(attributes), content, body_end()]\n\n\ndef ul(items):\n    r = [\"<ul>\"]\n    for i in items:\n        r.append([\"<li>\", i, \"</li>\"])\n    r.append(\"</ul>\")\n    return r", "\n\ndef ul(items):\n    r = [\"<ul>\"]\n    for i in items:\n        r.append([\"<li>\", i, \"</li>\"])\n    r.append(\"</ul>\")\n    return r\n\n\ndef header(level, content, style=None, attributes=None):\n    return [\n        tag(\"h%s\" % level, style=style, attributes=attributes),\n        content,\n        \"</h%s>\" % level,\n    ]", "\n\ndef header(level, content, style=None, attributes=None):\n    return [\n        tag(\"h%s\" % level, style=style, attributes=attributes),\n        content,\n        \"</h%s>\" % level,\n    ]\n\n", "\n\ndefault_col_style = {\n    \"border\": \"1px solid #CCCCCC\",\n    \"padding-left\": \"5px\",\n    \"padding-right\": \"5px\",\n}\ndefault_table_style = {\n    \"border-collapse\": \"collapse\",\n}", "    \"border-collapse\": \"collapse\",\n}\n\n\ndef table(\n    rows, style=default_table_style, col_style=default_col_style, attributes=None\n):\n    r = []\n    for cols in rows:\n        this_row = [[tag(\"td\", col_style), c, \"</td>\"] for c in cols]\n        r.append([tag(\"tr\"), this_row, \"</tr>\"])\n    return [tag(\"table\", style=style, attributes=attributes), r, \"</table>\"]", "\n\ndef div(content, style=None, attributes=None):\n    return [tag(\"div\", style=style, attributes=attributes), content, \"</div>\"]\n\n\ndef script(content, style=None, attributes=None):\n    return [tag(\"script\", style=style, attributes=attributes), content, \"</script>\"]\n\n\ndef javascript(content, style=None, attributes={}):\n    u = {\"type\": \"text/javascript\", \"charset\": \"utf-8\"}\n    u.update(attributes)\n    return script(content, style, u)", "\n\ndef javascript(content, style=None, attributes={}):\n    u = {\"type\": \"text/javascript\", \"charset\": \"utf-8\"}\n    u.update(attributes)\n    return script(content, style, u)\n\n\ndef checkbox(content, style=None, attributes={}):\n    t = {\n        \"type\": \"checkbox\",\n    }\n    t.update(attributes)\n    return [\n        tag(\"label\"),\n        tag(\"input\", style=style, attributes=t),\n        content,\n        \"</label>\",\n    ]", "def checkbox(content, style=None, attributes={}):\n    t = {\n        \"type\": \"checkbox\",\n    }\n    t.update(attributes)\n    return [\n        tag(\"label\"),\n        tag(\"input\", style=style, attributes=t),\n        content,\n        \"</label>\",\n    ]", "\n\ndef _option(value, content, attributes={}):\n    n = {}\n    n.update(attributes)\n    n.update({\"value\": value})\n    return [\n        tag(\"option\", attributes=n),\n        content,\n        \"</option>\",\n    ]", "\n\ndef select(name, options, style=None, attributes={}):\n    options = [_option(value, content) for value, content in options.items()]\n    return [\n        tag(\"select\", style=style, attributes=attributes),\n        options,\n        \"</select>\",\n    ]\n", "\n\ndef _rtable(m):\n    \"\"\"Do a depth-first search of m, returning a list of rows for all\n    name/value pairs found in m.  If a particular value is a dict, then\n    recursively call _rtable on that value, then add the first row from that\n    with a new td showing the current name, rowspan'd for the length of the\n    inner table; then extend the current row list with the inner list.  IOW\n    you'll get a list returned with one element for each row, with extra\n    columns (with appropriate rowspans) to serve as headers as appropriate.\n    \"\"\"\n    rows = []\n    for name, value in m.items():\n        if isinstance(value, dict):\n            ir = _rtable(value)\n            if len(ir):\n                h = tag(\"td\", default_col_style, attributes={\"rowspan\": \"%d\" % len(ir)})\n                this_row = [h, name, \"</td>\", ir[0]]\n                rows.append(this_row)\n                rows.extend(ir[1:])\n            continue\n        elif isinstance(value, list):\n            for n, v in enumerate(value):\n                ir = _rtable(v)\n                h = tag(\"td\", default_col_style, attributes={\"rowspan\": \"%d\" % len(ir)})\n                this_row = [h, \"%s %s\" % (name, n), \"</td>\", ir[0]]\n                rows.append(this_row)\n                rows.extend(ir[1:])\n            continue\n        this_row = [[tag(\"td\", default_col_style), c, \"</td>\"] for c in (name, value)]\n        rows.append(this_row)\n    return rows", "\n\ndef rtable(m):\n    \"\"\"Given a multi-level map, e.g. {\"a\": {\"b\": \"YES\", \"c\": \"NO\"}}, produces an HTML\n    table where the higher level keys (\"a\" in this case) will rowspan in front\n    of the lower levels in the map (\"b\" and \"c\").\n    \"\"\"\n    rows = [[tag(\"tr\"), this_row, \"</tr>\"] for this_row in _rtable(m)]\n    table = [tag(\"table\", style=default_table_style), rows, \"</table>\"]\n    return table", "\n\ndef head(content):\n    return [\n        tag(\"head\"),\n        content,\n        \"</head>\",\n    ]\n\n\ndef style(element, options):\n    nv = [\"%s:%s;\" % (k, v) for k, v in options.items()]\n    return [\n        tag(\"style\"),\n        \"%s {\" % element,\n        nv,\n        \"}\",\n        \"</style>\",\n    ]", "\n\ndef style(element, options):\n    nv = [\"%s:%s;\" % (k, v) for k, v in options.items()]\n    return [\n        tag(\"style\"),\n        \"%s {\" % element,\n        nv,\n        \"}\",\n        \"</style>\",\n    ]", "\n\n#\n# Test report support\n#\ndef na(context, style=None):\n    return paragraph(\n        italic(\n            \"N/A: %s\" % context,\n        ),\n        style,\n    )", "\n\nclass Div:\n    def __init__(self, content=[], style=None, attributes=None):\n        self._content = content\n        self._style = style\n        self._attributes = attributes\n\n    def html(self):\n        return div(self._content, style=self._style, attributes=self._attributes)\n\n    def __str__(self):\n        return \"%s\" % self._content\n\n    def yaml(self, dumper):\n        return dumper.represent_data(self._content)", "\n\nyaml.add_representer(Div, lambda dumper, data: data.yaml(dumper))\n\n\nclass Link:\n    def __init__(self, content, url, style=None, attributes=None):\n        self._content = content\n        self._url = url\n        self._style = style\n        self._attributes = attributes\n\n    def html(self):\n        return link(\n            self._content, self._url, style=self._style, attributes=self._attributes\n        )\n\n    def __str__(self):\n        return \"%s\" % self._content\n\n    def yaml(self, dumper):\n        return dumper.represent_data(self._content)", "\n\nyaml.add_representer(Link, lambda dumper, data: data.yaml(dumper))\n\n# Include this guy in your doc to pull in websocket support.\nsocket_io_js = script(\n    attributes={\n        \"src\": \"https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js\",\n        \"integrity\": \"sha512-q/dWJ3kcmjBLU4Qc47E4A9kTB4m3wuTY7vkFJDTZKjTs8jhyGQnaUrxa0Ytd0ssMZhbNua9hE+E7Qv1j+DyZwA==\",\n        \"crossorigin\": \"anonymous\",", "        \"integrity\": \"sha512-q/dWJ3kcmjBLU4Qc47E4A9kTB4m3wuTY7vkFJDTZKjTs8jhyGQnaUrxa0Ytd0ssMZhbNua9hE+E7Qv1j+DyZwA==\",\n        \"crossorigin\": \"anonymous\",\n    },\n    content=\"\",\n)\n"]}
{"filename": "holoscan_test_suite/show_test_pattern.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n# SPDX-License-Identifier: Apache-2.0\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software", "#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# See README.md for detailed information.\n\nimport argparse", "\nimport argparse\nimport cv2\nimport holoscan_test_suite\nimport os\nimport signal\nimport time\n\ndone = False\n", "done = False\n\n\ndef set_done(*args):\n    global done\n    done = True\n\n\nsignal.signal(signal.SIGTERM, set_done)\n", "signal.signal(signal.SIGTERM, set_done)\n\n\ndef show_test_pattern(filename, display):\n    # We may be restarted via control_app.py\n    global done\n    done = False\n\n    # We only support 1920x1080.\n    columns = 1920\n    rows = 1080\n\n    #\n    image = cv2.imread(filename)  # BGRA\n    image_rows, image_columns, image_width = image.shape\n    assert image_rows == rows\n    assert image_columns == columns\n\n    # Mount an overlayfs so we can temporarily patch /etc/X11/xorg.conf.d.\n    print(\"Setting up overlayfs.\")\n    os.makedirs(\"/tmp/overlay/etc\", exist_ok=True)\n    os.makedirs(\"/tmp/overlay/work\", exist_ok=True)\n    s = \"/bin/mount -t overlay overlay -o lowerdir=/etc,upperdir=/tmp/overlay/etc,workdir=/tmp/overlay/work /etc\"\n    assert os.system(s) == 0\n    try:\n        # Write our special xorg.conf stanza that sets us up for 1920x1080 mode.\n        s = \"\"\"\nSection \"Screen\"\n    Identifier     \"Screen0\"\n    Device         \"Device0\"\n    Monitor        \"Monitor0\"\n    DefaultDepth    24\n    SubSection     \"Display\"\n        Depth       24\n    EndSubSection\n    Option \"ConnectedMonitor\" \"GPU-0.DP-7\"\n    Option \"CustomEDID\" \"GPU-0.DP-7:/etc/X11/edid.bin\"\n    Option \"MetaModes\" \"GPU-0.DP-7:1920x1080+0+0\"\nEndSection\n\"\"\"\n        with open(\"/etc/X11/xorg.conf.d/mgx.conf\", \"wt\") as f:\n            f.write(s)\n        # That stanza relies on /etc/X11/edid.bin.  Write that now.\n        # fmt: off\n        # (Without fmt:off, black will spread this out to one byte per line.)\n        # This EDID data was recorded using \"xrandr --props\" when the port\n        # was connected to a powered-on P3785.\n        edid = bytes([\n            0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x4D, 0xD9, 0x06, 0x5A, 0x01, 0x01, 0x01, 0x01,\n            0x1E, 0x1E, 0x01, 0x03, 0x80, 0x6F, 0x3E, 0x78, 0x0A, 0xEE, 0x91, 0xA3, 0x54, 0x4C, 0x99, 0x26,\n            0x0F, 0x50, 0x54, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 0x58, 0x2C,\n            0x45, 0x00, 0x50, 0x1D, 0x74, 0x00, 0x00, 0x1E, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40,\n            0x58, 0x2C, 0x45, 0x00, 0x50, 0x1D, 0x74, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x18,\n            0x4B, 0x0F, 0x87, 0x3C, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC,\n            0x00, 0x4C, 0x54, 0x36, 0x39, 0x31, 0x31, 0x55, 0x58, 0x43, 0x0A, 0x20, 0x20, 0x20, 0x00, 0x22,\n        ])\n        # fmt: on\n        with open(\"/etc/X11/edid.bin\", \"wb\") as f:\n            f.write(edid)\n        # Now restart X so that it sees this new EDID.\n        print(\"Restarting display-manager.\")\n        assert os.system(\"/bin/systemctl restart display-manager\") == 0\n        # Let it start up.\n        time.sleep(5)\n\n        # Ask xrandr to change the display for us\n        os.environ[\"DISPLAY\"] = display\n        s = \"/usr/bin/xrandr --size %sx%s\" % (columns, rows)\n        assert os.system(s) == 0\n\n        # Deactivate the screen saver.  This works to bring\n        # up the display if we've been sitting around and it's\n        # gone off.\n        s = \"/usr/bin/xset -dpms s off s noblank s 0 0 s noexpose\"\n        assert os.system(s) == 0\n\n        #\n        cv2.namedWindow(filename, cv2.WND_PROP_FULLSCREEN)\n        cv2.setWindowProperty(filename, cv2.WND_PROP_FULLSCREEN, 1)\n        cv2.imshow(filename, image)\n        # Let cv2 update the display.\n        cv2.waitKey(10)\n        print(\"Image displayed.\")\n        while not done:\n            cv2.waitKey(100)\n        return 0\n\n    finally:\n        # Don't leave our /etc overlay sitting around.\n        print(\"Removing overlayfs.\")\n        s = \"/bin/umount /etc\"\n        r = os.system(s)\n        print(\"umount returned %s\" % (r,))\n        # Now restart X to go back to normal\n        print(\"Restarting display-manager.\")\n        os.system(\"/bin/systemctl restart display-manager\")", "\n\ndef main():\n    parser = argparse.ArgumentParser(\n        description=\"Tool to display a .png file in fullscreen mode.\"\n    )\n    parser.add_argument(\n        \"--filename\",\n        default=holoscan_test_suite.default_test_image,\n        help=\"Name of .png file to display.\",\n    )\n    parser.add_argument(\n        \"--display\",\n        default=\":0\",\n        help=\"Display to use\",\n    )\n    args = parser.parse_args()\n    show_test_pattern(args.filename, args.display)", "\n\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "holoscan_test_suite/__init__.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n# SPDX-License-Identifier: Apache-2.0\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software", "#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport os\n\ndefault_test_image = os.path.join(os.path.dirname(__file__), \"test_image.png\")", "\ndefault_test_image = os.path.join(os.path.dirname(__file__), \"test_image.png\")\n"]}
{"filename": "holoscan_test_suite/reactor.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n# SPDX-License-Identifier: Apache-2.0\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software", "#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n#\n# See README.md for detailed information.\n", "# See README.md for detailed information.\n\n# Reactor provides a runtime environment for event handlers; where\n# events typically come from file descriptors that are ready to read.\n# Reactors also call handlers based on single-shot or periodic alarms.\n\nimport collections\nimport os\nimport select\nimport threading", "import select\nimport threading\nimport time\nimport traceback\n\n# Reactor has a list of alarms that are\n# instances of this.\nReactorAlarm = collections.namedtuple(\n    \"ReactorAlarm\", [\"deadline\", \"period_s\", \"callback\"]\n)", "    \"ReactorAlarm\", [\"deadline\", \"period_s\", \"callback\"]\n)\n\n\nclass Reactor:\n    \"\"\"\n    Reactor provides a runtime environment for\n    handlers that are called when either a file\n    descriptor has data to read or if a timeout\n    expires.  Any number of file descriptors or\n    alarms can be connected to a reactor instance.\n    Handlers should not block; all reactor activity\n    is serialized, so the next handler will wait\n    until the currently executing handler is done.\n\n    @code\n        reactor = Reactor()\n        # Start the reactor in a daemon thread\n        reactor.start()\n        # Example usage\n        r_fd, w_fd = os.pipe()\n        def pipe_handler():\n            value = os.read(r_fd, 8192)\n        reactor.register(r_fd, pipe_handler)\n        # So now when someone calls\n        os.write(w_fd, b\"HELLO\")\n        # the reactor will call pipe_handler in its\n        # background thread; pipe_handler's call\n        # to os.read will complete immediately\n        # because there is data to be read.\n    @endcode\n\n    Reactor also supports alarms, with a deadline\n    that is compared to \"time.monotonic()\".\n    @code\n        def alarm():\n            print(\"Alarm expired!\")\n        timeout_s = 5\n        reactor.alarm(time.monotonic() + timeout_s, alarm)\n    @endcode\n    In (at least) 5 seconds from now, the background thread will\n    call alarm().\n    \"\"\"\n\n    ALARM_UPDATE = b\"ALARM_UPDATE\"\n    DONE = b\"DONE\"\n\n    def __init__(self):\n        self._alarms = []  # [ReactorAlarm, ...]; sorted earliest deadline first\n        self._alarms_lock = threading.Lock()\n        self._control_r, self._control_w = os.pipe()\n        self._epoll = select.epoll()\n        self._epoll_map = {}\n        self._done = False\n        self.register(self._control_r, self._control_ready)\n\n    def start(self):\n        self._thread = threading.Thread(\n            target=self._run,\n            daemon=True,\n        )\n        self._thread.start()\n\n    def _run(self):\n        while not self._done:\n            # Call all expired timeouts.\n            timeout_s = None\n            while True:\n                with self._alarms_lock:\n                    if len(self._alarms) < 1:\n                        break\n                    # self._alarms is always sorted, earliest deadline first\n                    reactor_alarm = self._alarms[0]\n                    now = time.monotonic()\n                    if reactor_alarm.deadline > now:\n                        timeout_s = reactor_alarm.deadline - now\n                        break\n                    # So this deadline has been reached.\n                    if reactor_alarm.period_s is None:\n                        self._alarms.pop(0)\n                    else:\n                        # Update the deadline and reorder\n                        self._alarms[0] = ReactorAlarm(\n                            deadline=reactor_alarm.deadline + reactor_alarm.period_s,\n                            period_s=reactor_alarm.period_s,\n                            callback=reactor_alarm.callback,\n                        )\n                        self._alarms.sort()\n                # Now self._alarms isn't locked anymore.\n                try:\n                    reactor_alarm.callback()\n                except Exception as e:\n                    print(\"Ignoring %s (%s)\" % (e, type(e)))\n                    traceback.print_exception(e)\n            # We've handled all our timeouts; timeout_s will\n            # either be None (because the alarms list was empty)\n            # or be the number of seconds until the next deadline.\n            events = self._epoll.poll(timeout=timeout_s)\n            for fileno, event in events:\n                try:\n                    handler = self._epoll_map[fileno]\n                    handler(event)\n                except Exception as e:\n                    print(\"Ignoring %s (%s)\" % (e, type(e)))\n                    traceback.print_exception(e)\n\n    def register(self, fd, handler, event=select.EPOLLIN | select.EPOLLHUP):\n        \"\"\"Set a callback on a ready filedescriptor.\"\"\"\n        self._epoll_map[fd] = handler\n        self._epoll.register(fd, event)\n\n    def unregister(self, fd):\n        \"\"\"Remove a previously registered handler.\"\"\"\n        self._epoll.unregister(fd)\n        del self._epoll_map[fd]\n\n    def alarm(self, deadline, callback):\n        \"\"\"Queue up a callback to execute once the\n        given deadline has passed.\n        \"\"\"\n        reactor_alarm = ReactorAlarm(deadline, None, callback)\n        with self._alarms_lock:\n            self._alarms.append(reactor_alarm)\n            self._alarms.sort()\n        # wake up the polling thread\n        self._signal(self.ALARM_UPDATE)\n        return reactor_alarm\n\n    def periodic_alarm(self, period_s, callback):\n        \"\"\"Queue up a callback to be executed periodically.\"\"\"\n        now = time.monotonic()\n        deadline = now + period_s\n        reactor_alarm = ReactorAlarm(deadline, period_s, callback)\n        with self._alarms_lock:\n            self._alarms.append(reactor_alarm)\n            self._alarms.sort()\n        # wake up the polling thread\n        self._signal(self.ALARM_UPDATE)\n        return reactor_alarm\n\n    def _control_ready(self, event):\n        \"\"\"\n        Callback when _control_r has data to read.\n        For now, we don't actually use the values\n        sent over the control pipe; it's really just\n        to bump the thread and reevaluate timeouts or\n        termination flags.\n        \"\"\"\n        value = os.read(self._control_r, 8192)\n\n    def _signal(self, message):\n        \"\"\"Send a message to the reactor, causing it\n        to wake up and reevaluate its alarm list.\n        \"\"\"\n        os.write(self._control_w, message)\n\n    def close(self):\n        \"\"\"Initiate shutdown of the reactor thread.\n        We don't actually wait for that here--\n        this way you can close the reactor\n        from within a handler itself.\n        \"\"\"\n        self._done = True\n        self._signal(self.DONE)", ""]}
{"filename": "src/ajantv2_util.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n# SPDX-License-Identifier: Apache-2.0\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software", "#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# See README.md for detailed information.\n\nimport ajantv2", "\nimport ajantv2\nimport util\n\n\ndef aja_board_information():\n    # Find the devices on PCI.  pci_devices is indexed by pci-id\n    # (e.g. \"f1d0:eb1f\") and is a list of boards found with that\n    # id.\n    command = [\"/usr/bin/lspci\", \"-n\", \"-d\", \"f1d0::0400\"]\n    pci_devices = {}\n    for l in util.run_command(command):\n        pci_rev = util.Na(\"No value given\")\n        try:\n            pci_bus_address, pci_class, pci_id, pci_rev = l.split(None, 3)\n        except ValueError:\n            pci_bus_address, pci_class, pci_id = l.split(None, 2)\n        r = {\n            \"pci_bus_address\": pci_bus_address,\n            \"pci_class\": pci_class,\n            \"pci_id\": pci_id,\n            \"pci_rev\": pci_rev,\n        }\n        pci_devices.setdefault(pci_id, []).append(r)\n    #\n    device_scanner = ajantv2.CNTV2DeviceScanner()\n    device_count = device_scanner.GetNumDevices()\n    #\n    for i in range(device_count):\n        card = ajantv2.CNTV2Card(i)\n        serial_number_status, serial_number_string = card.GetSerialNumberString()\n        pci_device_id_status, pci_device_id = card.GetPCIDeviceID()\n        (\n            firmware_status,\n            firmware_bytes,\n            firmware_date,\n            firmware_time,\n        ) = card.GetInstalledBitfileInfo()\n        firmware_info = util.Na(\"No bitfile info provided\")\n        if firmware_status:\n            firmware_info = \"firmware_bytes=%s firmware_date=%s firmware_time=%s\" % (\n                firmware_bytes,\n                firmware_date,\n                firmware_time,\n            )\n        (\n            failsafe_firmware_status,\n            failsafe_firmware_loaded,\n        ) = card.IsFailSafeBitfileLoaded()\n        pci_device_id_information = util.Na(\"Not provided\")\n        if pci_device_id_status:\n            pci_device_id_information = util.Hex(pci_device_id)\n        failsafe_firmware_loaded_information = util.Na(\"Not provided\")\n        if failsafe_firmware_status:\n            failsafe_firmware_loaded_information = failsafe_firmware_loaded\n        serial_number_information = util.Na(\"Not provided\")\n        if serial_number_status:\n            serial_number_information = serial_number_string\n        board_information = {\n            \"device_id\": util.Hex(card.GetDeviceID()),\n            \"model\": card.GetModelName(),\n            \"device_version\": card.GetDeviceVersion(),\n            \"driver_version\": card.GetDriverVersionString(),\n            \"serial_number\": serial_number_information,\n            \"pci_device_id\": pci_device_id_information,\n            \"breakout_hardware\": card.GetBreakoutHardware(),\n            \"firmware_info\": firmware_info,\n            \"failsafe_firmware\": failsafe_firmware_loaded_information,\n            \"fpga_version\": card.GetPCIFPGAVersionString(),\n        }\n        # The information from GetPCIDeviceID isn't enough to point us to\n        # a specific instance-- so if the length of devices in pci_devices[...]\n        # is 1, then we'll use that.  Otherwise we can't tell.\n        if pci_device_id_status:\n            pci_device = pci_devices.get(\"f1d0:%04x\" % pci_device_id, {})\n            if len(pci_device) == 1:\n                board_information.update(pci_device[0])\n        yield board_information", "\n\ndef aja_driver_information():\n    r = {\n        \"sdk_version\": \"%s.%s.%s (0x%08X) build %s; %s\"\n        % (\n            ajantv2.AJA_NTV2_SDK_VERSION_MAJOR,\n            ajantv2.AJA_NTV2_SDK_VERSION_MINOR,\n            ajantv2.AJA_NTV2_SDK_VERSION_POINT,\n            ajantv2.AJA_NTV2_SDK_VERSION,\n            ajantv2.AJA_NTV2_SDK_BUILD_NUMBER,\n            ajantv2.AJA_NTV2_SDK_BUILD_DATETIME,\n        ),\n    }\n    device_scanner = ajantv2.CNTV2DeviceScanner()\n    device_count = device_scanner.GetNumDevices()\n    r[\"device_count\"] = device_count\n    return r", ""]}
{"filename": "src/test_dgpu.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n# SPDX-License-Identifier: Apache-2.0\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software", "#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# See README.md for detailed information.\n\nimport pytest", "\nimport pytest\n\n\n@pytest.mark.igx_orin_devkit_only\ndef test_dgpu_igx_orin_devkit(script):\n    assert script.run(\"bringup_dgpu_igx_orin_devkit.sh\") == 0\n\n\n@pytest.mark.clara_agx_devkit_only\ndef test_dgpu_clara_agx_devkit(script):\n    assert script.run(\"bringup_dgpu_clara_agx_devkit.sh\") == 0", "\n@pytest.mark.clara_agx_devkit_only\ndef test_dgpu_clara_agx_devkit(script):\n    assert script.run(\"bringup_dgpu_clara_agx_devkit.sh\") == 0\n"]}
{"filename": "src/nvidia_util.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n# SPDX-License-Identifier: Apache-2.0\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software", "#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# See README.md for detailed information.\n\nimport argparse", "\nimport argparse\nimport ctypes\nimport re\nimport smbus2\nimport sys\nimport util\nimport yaml\n\n# Tests use this with pytest.mark.skip.", "\n# Tests use this with pytest.mark.skip.\nigx_orin_devkit = [\"p3701\"]\nclara_agx_devkit = [\"p2888\"]\n\n\nRESERVED = \"reserved_\"\n\n\n# Adapts the EEPROM layout described here:", "\n# Adapts the EEPROM layout described here:\n# https://docs.nvidia.com/jetson/archives/r34.1/DeveloperGuide/text/HR/JetsonEepromLayout.html\n# to the name/[array_]ctype list that ctypes.Structure wants.\ndef jetson_eeprom_to_ctypes(field_list):\n    \"\"\"field_list is a list of (first_byte_offset, last_byte_offset,\n    field_name, ctype) the number of bytes should always be an even multiple of\n    the ctype size; for a multiple of greater than one then we'll make an array\n    out of that here.\n    \"\"\"\n    # order by first_byte_offset\n    l = sorted(field_list)\n    address = 0\n    r = []\n    for first_byte_offset, last_byte_offset, field_name, ct in l:\n        # No overlapping data is allowed.\n        assert first_byte_offset >= address\n        # Do we need to fill with \"reserved\" bytes?\n        if address < first_byte_offset:\n            n = first_byte_offset - address\n            r.append((\"%s%s\" % (RESERVED, len(r)), ctypes.c_uint8 * n))\n            address += n\n        # How many of these data are here?\n        n = last_byte_offset - address + 1\n        count = n // ctypes.sizeof(ct)\n        # has to be an even number of elements\n        assert (count * ctypes.sizeof(ct)) == n\n        if count == 1:\n            r.append((field_name, ct))\n        else:\n            r.append((field_name, ct * count))\n        address += n\n    return r", "\n\n# https://docs.nvidia.com/jetson/archives/r34.1/DeveloperGuide/text/HR/JetsonEepromLayout.html\n# (also https://docs.nvidia.com/jetson/archives/l4t-archived/l4t-3231/index.html#page/Tegra%20Linux%20Driver%20Package%20Development%20Guide/jetson_eeprom_layout.html)\nclass JetsonEepromCtypesAdapter(ctypes.Structure):\n    _pack_ = 1\n    _fields_ = jetson_eeprom_to_ctypes(\n        [\n            (0, 0, \"major_version\", ctypes.c_uint8),\n            (1, 1, \"minor_version\", ctypes.c_uint8),\n            (2, 3, \"id_data_bytes\", ctypes.c_uint16),\n            (4, 5, \"board_number\", ctypes.c_uint16),\n            (6, 7, \"sku\", ctypes.c_uint16),\n            (8, 8, \"fab\", ctypes.c_uint8),\n            (9, 9, \"rev\", ctypes.c_uint8),\n            (10, 10, \"minor_rev\", ctypes.c_uint8),\n            (11, 11, \"memory_type\", ctypes.c_uint8),\n            (12, 12, \"power_configuration\", ctypes.c_uint8),\n            (13, 13, \"miscellaneous_configuration\", ctypes.c_uint8),\n            (16, 16, \"display_configuration\", ctypes.c_uint8),\n            (17, 17, \"rework_level\", ctypes.c_uint8),\n            (19, 19, \"gigabit_mac_ids\", ctypes.c_uint8),\n            (20, 49, \"board_id\", ctypes.c_char),\n            (50, 55, \"wifi_mac_id\", ctypes.c_uint8),\n            (56, 61, \"bluetooth_mac_id\", ctypes.c_uint8),\n            (62, 67, \"secondary_wifi_mac_id\", ctypes.c_uint8),\n            (68, 73, \"gigabit_mac_id\", ctypes.c_uint8),\n            (74, 88, \"serial_number\", ctypes.c_char),\n            (150, 153, \"customer_block_signature\", ctypes.c_char),\n            (154, 155, \"customer_block_length\", ctypes.c_uint16),\n            (156, 157, \"customer_block_type\", ctypes.c_char),\n            (158, 159, \"customer_block_version\", ctypes.c_uint16),\n            (160, 165, \"customer_block_wifi_mac_id\", ctypes.c_uint8),\n            (166, 171, \"customer_block_bluetooth_mac_id\", ctypes.c_uint8),\n            (172, 177, \"customer_block_gigabit_mac_id\", ctypes.c_uint8),\n            (178, 178, \"customer_block_gigabit_mac_ids\", ctypes.c_uint8),\n            (200, 220, \"orin_system_part_number\", ctypes.c_char),\n            (221, 235, \"orin_serial_number\", ctypes.c_char),\n            (255, 255, \"crc8\", ctypes.c_uint8),\n        ]\n    )", "\n\ndef compute_crc8(b, crc=0):\n    \"\"\"See https://docs.nvidia.com/jetson/archives/r34.1/DeveloperGuide/text/HR/JetsonEepromLayout.html\"\"\"\n    for c in b:\n        assert c >= 0\n        assert c < 256\n        for bit in range(8):\n            odd = ((c ^ crc) & 1) == 1\n            crc >>= 1\n            c >>= 1\n            if odd:\n                crc ^= 0x8C\n    return crc", "\n\nclass EepromStr(str):\n    \"\"\"Some ASCII printable data is stored in eeprom with fill characters (\\x00\n    or \\xFF); use this adapter to get a printable string without that filler.\n    By subclassing str (and using __new__ to set immutable fields) we hide the\n    fact that we're adapting the value here from something else.  We'd use a str\n    directly if we didn't want to have special yaml or html handling.\n    \"\"\"\n\n    def __new__(cls, b, strip=b\"\\x00\"):\n        s = b.rstrip(strip).decode(\"utf-8\")\n        obj = str.__new__(cls, s)\n        obj._s = s\n        obj._present = len(obj._s) > 0\n        return obj\n\n    def yaml(self, dumper):\n        if self._present:\n            return dumper.represent_str(self._s)\n        return dumper.represent_none(None)\n\n    def html(self):\n        if self._present:\n            return self._s\n        return util.Na(\"Not specified\").html()", "\n\nyaml.add_representer(EepromStr, lambda dumper, data: data.yaml(dumper))\n\n\nclass EepromMac:\n    def __init__(self, b):\n        self._s = \":\".join([\"%02X\" % c for c in b])\n\n    def __str__(self):\n        return self._s\n\n    def yaml(self, dumper):\n        return dumper.represent_str(self._s)\n\n    def html(self):\n        return self._s", "\n\nyaml.add_representer(EepromMac, lambda dumper, data: data.yaml(dumper))\n\n\ndef _jetson_eeprom_information(device=0, address=0x50):\n    \"\"\"NOTE this returns the JetsonEeprom instance AND the computed CRC of\n    EEPROM data.  You really want to use jetson_eeprom_information() instead.\n    \"\"\"\n    with smbus2.SMBus(device) as bus:\n        bs = 16\n        r = bytearray()\n        for a in range(0, 256, bs):\n            assert (a >> 8) == 0\n            wr = smbus2.i2c_msg.write(address, [a & 0xFF])\n            rd = smbus2.i2c_msg.read(address, bs)\n            bus.i2c_rdwr(wr, rd)\n            r.extend(list(rd))\n    eeprom = JetsonEepromCtypesAdapter.from_buffer(r)\n    computed_crc = compute_crc8(r[:-1])\n    jetson_eeprom = {\n        \"version\": \"%d.%d\" % (eeprom.major_version, eeprom.minor_version),\n        \"board_number\": eeprom.board_number,\n        \"sku\": eeprom.sku,\n        \"fab\": eeprom.fab,\n        \"rev\": \"%d.%d\" % (eeprom.rev, eeprom.minor_rev),\n        \"memory_type\": eeprom.memory_type,\n        \"power_configuration\": eeprom.power_configuration,\n        \"miscellaneous_configuration\": eeprom.miscellaneous_configuration,\n        \"display_configuration\": eeprom.display_configuration,\n        \"rework_level\": eeprom.rework_level,\n        \"gigabit_mac_ids\": eeprom.gigabit_mac_ids,\n        \"board_id\": EepromStr(eeprom.board_id, strip=b\"\\x00\\xFF\"),\n        \"wifi_mac_id\": EepromMac(eeprom.wifi_mac_id),\n        \"bluetooth_mac_id\": EepromMac(eeprom.bluetooth_mac_id),\n        \"secondary_wifi_mac_id\": EepromMac(eeprom.secondary_wifi_mac_id),\n        \"gigabit_mac_id\": EepromMac(eeprom.gigabit_mac_id),\n        \"serial_number\": EepromStr(eeprom.serial_number),\n        \"customer_block_signature\": EepromStr(eeprom.customer_block_signature),\n        \"customer_block_length\": eeprom.customer_block_length,\n        \"customer_block_type\": EepromStr(eeprom.customer_block_type),\n        \"customer_block_version\": util.Hex(eeprom.customer_block_version),\n        \"customer_block_wifi_mac_id\": EepromMac(eeprom.customer_block_wifi_mac_id),\n        \"customer_block_bluetooth_mac_id\": EepromMac(\n            eeprom.customer_block_bluetooth_mac_id\n        ),\n        \"customer_block_gigabit_mac_id\": EepromMac(\n            eeprom.customer_block_gigabit_mac_id\n        ),\n        \"customer_block_gigabit_mac_ids\": eeprom.customer_block_gigabit_mac_ids,\n        \"orin_system_part_number\": EepromStr(eeprom.orin_system_part_number),\n        \"orin_serial_number\": EepromStr(eeprom.orin_serial_number),\n        \"crc8\": util.Hex(eeprom.crc8),\n    }\n    return jetson_eeprom, computed_crc", "\n\ndef jetson_eeprom_information(device=0, address=0x50):\n    \"\"\"Returns a dict with the data found in the on-board IDROM.\"\"\"\n    eeprom, computed_crc = _jetson_eeprom_information(device, address)\n    eeprom_crc = eeprom[\"crc8\"]\n    # If the EEPROM CRC doesn't match, let the user know.\n    eeprom[\"computed_crc\"] = util.Hex(computed_crc)\n    eeprom[\"crc_check\"] = \"CRC VALUES DO NOT MATCH\"\n    if eeprom_crc == computed_crc:\n        eeprom[\"crc_check\"] = \"Check ok\"\n    return eeprom", "\n\ndef model():\n    eeprom = jetson_eeprom_information()\n    board_id = eeprom[\"board_id\"]\n    g = re.match(\"699-(.)(....)-(....)-(...) (...)\", board_id)\n    assert g is not None\n    board_class, module_id, sku, version, revision = (\n        g.group(1),\n        g.group(2),\n        g.group(3),\n        g.group(4),\n        g.group(5),\n    )\n    return \"p\" + module_id", "\n\ndef main():\n    #\n    parser = argparse.ArgumentParser(\n        description=\"Tool to query NVIDIA configuration.\",\n    )\n    parser.add_argument(\n        \"--is-model\",\n        help=\"exits with a 0 if the given model is present.\",\n    )\n    parser.add_argument(\n        \"--model\",\n        action=\"store_true\",\n        help=\"Display the current board model.\",\n    )\n    args = parser.parse_args()\n    #\n    if args.is_model:\n        if model() == args.is_model:\n            return 0\n        else:\n            return 1\n    #\n    if args.model:\n        print(\"model=%s\" % (model(),))\n        return 0\n    # By default, just dump the contents.\n    eeprom = _jetson_eeprom_information()\n    return 0", "\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n"]}
{"filename": "src/test_p3785.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n# SPDX-License-Identifier: Apache-2.0\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software", "#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# See README.md for detailed information.\n\nimport cv2", "\nimport cv2\nimport holoscan_test_suite\nimport numpy as np\nimport pytest\nimport subprocess\nimport sys\nimport time\n\n", "\n\n# Check for video ingress on P3785;\n# relies on\n#   - a working P3785\n#   - Test image at 1920x1080,60fps\n#       presented to the HDMI input--\n#       show_test_pattern.py does this\n# \"capsys\" here is how we save our stdout/stderr\n# into the generated report.", "# \"capsys\" here is how we save our stdout/stderr\n# into the generated report.\n@pytest.mark.igx_orin_devkit_only\ndef test_p3785(capsys):\n    print(\"Test IGX Orin Devkit P3785.\")\n    # We only support 1920x1080 images.\n    columns = 1920\n    rows = 1080\n    pixel_format = \"BGRA\"\n    bytes_per_pixel = 4\n    device = \"/dev/video0\"\n    frames_per_sec = 60\n    record_filename = \"/tmp/video.raw\"\n    pixels_per_image = columns * rows\n    bytes_per_image = pixels_per_image * bytes_per_pixel\n    # Load up our test image; this is the same\n    # image that's expected to be recorded\n    test_image_filename = holoscan_test_suite.default_test_image\n    test_image_bgr = cv2.imread(test_image_filename)  # cv2.imread always returns BGR\n    # We acquire BGRA data, so convert our test image to that\n    test_image_bgra = cv2.cvtColor(test_image_bgr, cv2.COLOR_BGR2BGRA)\n    image_rows, image_columns, image_width = test_image_bgra.shape\n    assert image_rows == rows\n    assert image_columns == columns\n    # Run \"show_test_pattern\" to bring up the test image on X\n    command = f\"show_test_pattern --filename {test_image_filename}\"\n    print('Running \"%s\"' % (command,))\n    show_test_pattern = subprocess.Popen(\n        command.split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE\n    )\n    try:\n        # Let show_test_pattern start up\n        time.sleep(5)\n\n        # Run the recorder for 1 second at 60fps.\n        # Note that we impose the timeoverlay on the image--\n        # this way we see changes in the image itself and\n        # a difference from the test image that is greater\n        # than 0 but less than a relatively small threshold.\n        assert pixel_format == \"BGRA\"\n        command = f\"/usr/bin/gst-launch-1.0 v4l2src io-mode=mmap device={device} ! video/x-raw,format={pixel_format},width={columns},height={rows},framerate={frames_per_sec}/1 ! timeoverlay ! videoconvert ! filesink location={record_filename}\"\n        print('Running \"%s\"' % (command,))\n        gst = subprocess.Popen(\n            command.split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE\n        )\n        try:\n            # Record a few frames\n            time.sleep(5)\n        finally:\n            gst.kill()\n            time.sleep(2)\n        out, err = gst.communicate()\n        for l in out.decode(\"utf-8\").split(\"\\n\"):\n            print(l)\n        for l in err.decode(\"utf-8\").split(\"\\n\"):\n            print(l, file=sys.stderr)\n    finally:\n        show_test_pattern.terminate()\n        time.sleep(2)\n        out, err = show_test_pattern.communicate()\n        for l in out.decode(\"utf-8\").split(\"\\n\"):\n            print(l)\n        for l in err.decode(\"utf-8\").split(\"\\n\"):\n            print(l, file=sys.stderr)\n    # Load our actual recorded data.\n    with open(record_filename, \"rb\") as f:\n        # How many frames did we record?\n        SEEK_END = 2\n        f.seek(0, SEEK_END)\n        video_byte_length = f.tell()\n        # frames may have a fraction given that we kill gst without\n        # respect to where it was writing data.\n        frames = video_byte_length / bytes_per_image\n        print(\"video_byte_length=%s frames=%s\" % (video_byte_length, frames))\n        assert frames > 1\n        # Load the last frame.\n        last_whole_frame = int(frames) - 1\n        f.seek(last_whole_frame * bytes_per_image)\n        np_raw_data = np.fromfile(f, dtype=np.uint8, count=bytes_per_image)\n        last_acquired_image_bgra = np_raw_data.reshape(\n            rows, columns, bytes_per_pixel\n        )  # this is BGRA per pixel_format above\n        # How different is this from our test image?\n        diff = cv2.absdiff(test_image_bgra, last_acquired_image_bgra)\n        # Now many pixels are different?\n        gray_diff = cv2.cvtColor(diff, cv2.COLOR_BGRA2GRAY)\n        differences = np.count_nonzero(gray_diff)\n        percent = (differences / pixels_per_image) * 100.0\n        print(\n            \"differences, test_image_bgra to last_acquired_image_bgra=%s (%.1f%%)\"\n            % (differences, percent)\n        )\n        # gstreamer superimposed the timestamp on the test image,\n        # so it has have some differences; the display stream is also\n        # mathematically lossy, so some difference is expected.\n        assert percent > 0.1\n        # but not TOO different.\n        assert percent < 10.0", ""]}
{"filename": "src/test_wifi.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n# SPDX-License-Identifier: Apache-2.0\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software", "#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n#\n# See README.md for detailed information.\n", "# See README.md for detailed information.\n\nimport pytest\n\n\n@pytest.mark.igx_orin_devkit_only\ndef test_wifi(script):\n    assert script.run(\"bringup_wifi_igx_orin_devkit.sh\") == 0\n", ""]}
{"filename": "src/test_aja.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n# SPDX-License-Identifier: Apache-2.0\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software", "#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n#\n# See README.md for detailed information.\n", "# See README.md for detailed information.\n\n\ndef test_aja(script):\n    assert script.run(\"bringup_aja.sh\") == 0\n"]}
{"filename": "src/infiniband_util.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n# SPDX-License-Identifier: Apache-2.0\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software", "#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# See README.md for detailed information.\n\nimport os.path", "\nimport os.path\nimport subprocess\nimport util\n\n\ndef infiniband_information():\n    pci_devices = util.list_pci_devices([\"15b3::\"])\n    # What devices are there?\n    command = [\"/usr/sbin/ibstat\", \"--list_of_cas\"]\n    try:\n        result = subprocess.run(\n            command,\n            capture_output=True,\n        )\n        # Parse the output into an information table.\n        s = result.stdout\n        devices = []\n        for device in s.decode(\"utf-8\").split(\"\\n\"):\n            if len(device):\n                devices.append(device)\n    except FileNotFoundError:\n        return\n    for device in devices:\n        command = [\"/usr/sbin/ibstat\", \"--short\", device]\n        try:\n            result = subprocess.run(\n                command,\n                capture_output=True,\n            )\n            # Parse the output into an information table.\n            s = result.stdout\n            l = s.decode(\"utf-8\").split(\"\\n\")\n            information = {}\n            category = None\n            for i in l:\n                if len(i) == 0:\n                    continue\n                # We already know what device this is\n                if i == (\"CA '%s'\" % device):\n                    continue\n                name_value_pair = i.split(\":\", 1)\n                name = name_value_pair[0].strip()\n                value = \"\"\n                if len(name_value_pair) > 1:\n                    value = name_value_pair[1].strip()\n                if len(value) == 0:\n                    value = util.Na(\"No value given\")\n                information[util.to_snake(name)] = value\n            # Can we map this back to a PCI slot?\n            path = \"/sys/class/infiniband/%s/device\" % device\n            realpath = os.path.realpath(path)\n            _, slot = os.path.split(realpath)\n            if slot in pci_devices:\n                information.update(pci_devices[slot])\n            yield information\n        except FileNotFoundError:\n            information = {\"status\": util.Na(\"V4L2 driver not available\")}\n            yield information", ""]}
{"filename": "src/holoscan_test_controls.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n# SPDX-License-Identifier: Apache-2.0\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software", "#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# See README.md for detailed information.\n\n# holoscan_test_controls.py creates the web UI that allows users to execute a list of", "\n# holoscan_test_controls.py creates the web UI that allows users to execute a list of\n# commands on demand.  See HoloscanTestControls.setup() below.\n\nimport engineio.payload\nimport flask\nimport flask_socketio\nfrom holoscan_test_suite import controls\nfrom holoscan_test_suite import html_render\nfrom holoscan_test_suite import reactor", "from holoscan_test_suite import html_render\nfrom holoscan_test_suite import reactor\nimport os\nimport re\nimport subprocess\n\n# When the UI requests the initial state, we get\n# a number of small requests-- don't limit the number\n# of requests we're allowed to queue up.\nengineio.payload.Payload.max_decode_packets = 100", "# of requests we're allowed to queue up.\nengineio.payload.Payload.max_decode_packets = 100\n\n\nclass HoloscanTestControls:\n    \"\"\"\n    HoloscanTestControls is a webapp where an HTML UI displays\n    - status values that are dynamically updated from the server\n    - actions that the user can perform.\n    The values shown on the display are dynamically updated\n    by snippets of javascript included in the HTML that\n    coordinate with a websocket server running here.\n    \"\"\"\n\n    def __init__(self, app):\n        self._app = app\n        self._actions = []\n        self._status = []\n        self._request = {}\n        self._update = {}\n        self._proc_stat = {}\n        #\n        self._reactor = reactor.Reactor()\n        self._reactor.start()\n        #\n        self.setup()\n        # Generate the index HTML page from the controls initialized by\n        # setup().  We always publish the same page so let's just cache that\n        # for whoever wants it.  (The controls update themselves dynamically.)\n        self._index_cache = self._index()\n\n    def setup(self):\n        # Control: show the test pattern\n        self.checkbox_command(\n            control_name=\"show_test_pattern\",\n            label=\"Enable 1920x1080 video test pattern\",\n            command=\"show_test_pattern\",\n        )\n        # Control: show the endoscopy demo from a recorded video input.\n        self.checkbox_command(\n            control_name=\"recorded_endoscopy_demo\",\n            label=\"Run the tool tracking demo (with recorded input)\",\n            command=\"./applications/endoscopy_tool_tracking/cpp/endoscopy_tool_tracking\",\n            env_update={\"DISPLAY\": \":0\"},\n            cwd=\"/opt/nvidia/holohub\",\n        )\n        # Control: run iperf3, the server that supports network performance testing\n        self.checkbox_command(\n            control_name=\"enable_iperf3\",\n            label=\"Run iperf server, listening to TCP and UDP port 5201 on all ethernets including WIFI\",\n            command=\"iperf3 -s\",\n        )\n        # Control: run \"e2fsck\" on nvme0n1\n        e2fsck_command = \"e2fsck -c -y /dev/nvme0n1\"\n        self.checkbox_command(\n            control_name=\"e2fsck_nvme0n1\",\n            label='Filesystem check of envme0n1 (via \"%s\")' % e2fsck_command,\n            command=e2fsck_command,\n        )\n        # Control: run \"mke2fs\" on nvme0n1; e2fsck won't work until\n        # we have a filesystem there.\n        mke2fs_command = \"mke2fs /dev/nvme0n1\"\n        self.checkbox_command(\n            control_name=\"mke2fs_nvme0n1\",\n            label='Make a ext2 filesystem on nvme0n1 (via \"%s\")' % mke2fs_command,\n            command=mke2fs_command,\n        )\n        # Control: run memtest on each core.\n        mb = 1024 * 1024\n        gb = 1024 * mb\n        memory_test_size = 2 * gb\n        for cpu in os.sched_getaffinity(0):\n            command = \"taskset -c %s memtester %sM\" % (cpu, (memory_test_size // mb))\n            self.checkbox_command(\n                control_name=\"memtest_with_cpu_%s\" % cpu,\n                label='Run memtest on CPU %s (via \"%s\")' % (cpu, command),\n                command=command,\n            )\n        # Control: disable the X-windows screen saver.\n        disable_screen_saver_command = (\n            \"/usr/bin/xset -dpms s off s noblank s 0 0 s noexpose\"\n        )\n        self.checkbox_command(\n            control_name=\"disable_screensaver\",\n            label='Disable X screen saver (via \"%s\")' % disable_screen_saver_command,\n            command=disable_screen_saver_command,\n            env_update={\"DISPLAY\": \":0\"},\n        )\n\n        # Status: Available RAM\n        def memory_free_status(control_name):\n            meminfo = self.get_meminfo()\n            r = {\n                \"value\": \"%sM\" % (meminfo[\"MemFree\"] // mb),\n            }\n            return r\n\n        memory_status = self.status(\n            control_name=\"memory_status\",\n            label=\"Memory free (MB)\",\n            requester=memory_free_status,\n        )\n        self._reactor.periodic_alarm(\n            period_s=5, callback=lambda: memory_status.publish(memory_free_status(None))\n        )\n\n        # Status: Thermal zones.\n        def get_thermal_zone(control_name, filename):\n            with open(filename, \"rt\") as f:\n                s = f.read()\n            v = int(s)\n            c = v / 1000\n            r = \"%.2fC\" % (c,)\n            # print(\"%s=%s\" % (self._control_name, r))\n            return {\n                \"value\": r,\n            }\n\n        for type_name, filename in self.thermal_zones():\n            requester = lambda control_name, filename=filename: get_thermal_zone(\n                control_name, filename\n            )\n            status = self.status(\n                control_name=type_name.lower().replace(\"-\", \"_\"),\n                label=\"Thermal zone: %s\" % type_name,\n                requester=requester,\n            )\n            self._reactor.periodic_alarm(\n                period_s=5,\n                callback=lambda status=status, requester=requester: status.publish(\n                    requester(None)\n                ),\n            )\n        # Status: CPU usage\n        self.update_proc_stat()\n\n        def get_cpu_usage(cpu_name):\n            r = \"Offline\"\n            with open(\"/sys/devices/system/cpu/%s/online\" % cpu_name, \"rt\") as f:\n                s = f.read()\n            online = int(s)\n            if online > 0:\n                u = self._proc_stat[cpu_name]\n                stat = [int(s) for s in u.split()]\n                last_cpu_name = \"last_%s\" % cpu_name\n                last_stat = self._proc_stat.get(last_cpu_name, None)\n                if last_stat:\n                    delta = [b - a for a, b in zip(last_stat, stat)]\n                else:\n                    delta = [\"N/A\" for a in stat]\n                self._proc_stat[last_cpu_name] = stat\n                r = \"user=%s nice=%s system=%s idle=%s iowait=%s irq=%s softirq=%s\" % (\n                    *delta[:7],\n                )\n            return {\n                \"value\": r,\n            }\n\n        # cpu_usage_update is set up so that it first calls\n        # self.update_proc_stat, then calls get_cpu_usage (which\n        # reads self._proc_stat) for each processor.  This way we\n        # don't get aliasing around the CPU usage on the display.\n        cpu_usage_update = [self.update_proc_stat]\n        for cpu_name in self.cpus():\n            requester = lambda control_name, cpu_name=cpu_name: get_cpu_usage(cpu_name)\n            status = self.status(\n                control_name=\"cpu_usage_%s\" % cpu_name,\n                label=\"CPU usage: %s\" % cpu_name,\n                requester=requester,\n            )\n            updater = lambda status=status, cpu_name=cpu_name: status.publish(\n                get_cpu_usage(cpu_name)\n            )\n            cpu_usage_update.append(updater)\n        self._reactor.periodic_alarm(\n            period_s=5,\n            callback=lambda cpu_usage_update=cpu_usage_update: [\n                u() for u in cpu_usage_update\n            ],\n        )\n        # Status: dGPU usage\n        dgpu_usage_command = \"/usr/bin/nvidia-smi pmon -c 1\"\n        dgpu_usage_status = controls.Status(\n            self._app, label=\"dGPU Usage\", control_name=\"dgpu_usage\"\n        )\n        self._status.append(dgpu_usage_status)\n\n        def update_dgpu_usage():\n            process = subprocess.Popen(\n                args=dgpu_usage_command.split(),\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE,\n            )\n            outs, errs = process.communicate(timeout=2)\n            stdout_value = outs.decode(\"utf-8\")\n            dgpu_usage_status.publish({\"value\": stdout_value})\n\n        self._reactor.periodic_alarm(period_s=5, callback=update_dgpu_usage)\n        self._request[dgpu_usage_status._control_name] = lambda control_name: {\n            \"value\": \"N/A\"\n        }\n        # Control: run gst, NVIDIA GPU stress test (https://github.com/NVIDIA/GPUStressTest)\n        self.checkbox_command(\n            control_name=\"gst\",\n            label=\"Run GST, the NVIDIA GPU Stress test\",\n            command=\"/usr/bin/gst\",\n        )\n        #\n\n    def checkbox_command(self, control_name, label, command, cwd=None, env_update={}):\n        \"\"\"\n        Creates an HTML UI element that is a checkbox; when the\n        user clicks it, we'll start the given command in the background.\n        If that program terminates, we'll drive the UI back to the\n        unchecked state; if it's checked and the user unchecks it,\n        we'll kill the background program.\n        \"\"\"\n        # runner is what supervises the command that this checkbox runs.\n        runner = controls.Runner(\n            self._reactor, self._app, command.split(), cwd=cwd, env_update=env_update\n        )\n        # control is how the checkbox and stdout/stderr is displayed\n        control = controls.Checkbox(\n            self._app, label, control_name, update=runner.update\n        )\n        # runner has asynchronous stdout/stderr data that it wants to pass up to UI\n        runner.set_control(control)\n        # when the control calls \"request\" (to fetch the current status), here's the handler for it\n        self._request[control_name] = control.request\n        # when the control calls \"update\" (to provide a new value), here's the handler for it\n        self._update[control_name] = control.update\n        # this is the list of items that are displayed on the page.\n        self._actions.append(control)\n        return runner\n\n    def status(self, control_name, label, requester):\n        \"\"\"\n        Creates an HTML UI item (which is really just a PRE section) that\n        we can write stuff to via websocket.\n        @returns the status object, call \"status.publish(dict)\" to update\n        the value displayed on the UI there.  For details on the dict to\n        be published, @see request() below.\n        @param requester fetches the value to be displayed and\n        takes control_name as a parameter.\n        \"\"\"\n        status = controls.Status(self._app, label, control_name)\n        # when the control calls \"request\" (to fetch the current status on startup), here's the handler for it\n        self._request[control_name] = requester\n        # add ourselves to the list of status displayed on the page.\n        self._status.append(status)\n        return status\n\n    def index(self):\n        \"\"\"\n        Called when a user requests the index page.  We've already\n        created (and cached) the index page so just publish that.\n        \"\"\"\n        return self._index_cache\n\n    def _index(self):\n        \"\"\"\n        Actually render the index page.  We sort the status\n        items for display at the top of the page, then sort\n        actions (which the user can enable or disable) and display\n        them next.  Items are sorted using \"naturally_sorted\"\n        below so that UI shows items in a consistent order.\n        \"\"\"\n        # Status comes first\n        rendered_status = []\n        for a in self.naturally_sorted(self._status):\n            a.render(rendered_status)\n        # Actions are next\n        rendered_actions = []\n        for a in self.naturally_sorted(self._actions):\n            a.render(rendered_actions)\n        # Here's the page itself\n        doc = [\n            html_render.socket_io_js,\n            html_render.javascript(\"var socket = io();\"),\n            self._reload_on_server_update(),\n            html_render.header(3, \"Status\"),\n            html_render.table(rendered_status),\n            html_render.horizontal_rule(),\n            html_render.header(3, \"Actions\"),\n            html_render.ul(rendered_actions),\n            html_render.horizontal_rule(),\n        ]\n        # Enable auto-wrapping of PRE sections\n        styles = [\n            html_render.style(\n                \"pre\",\n                {\n                    \"overflow-x\": \"auto\",\n                    \"white-space\": \"pre-wrap\",\n                    \"word-wrap\": \"break-word\",\n                },\n            )\n        ]\n        head = html_render.head(styles)\n        body = html_render.body(doc)\n        html = html_render.html([head, body])\n        # Send it.\n        r = html_render.render(html)\n        return r\n\n    def naturally_sorted(self, l):\n        \"\"\"\n        Sort the given list in a natural way, so that \"CPU_10\" comes after \"CPU_2\"\n        \"\"\"\n        extract_parts = re.compile(\"[^0-9]+|[0-9]+\")\n\n        def maybe_int(s):\n            try:\n                return int(s)\n            except ValueError:\n                return s\n\n        def key(control):\n            parts = extract_parts.findall(control._label)\n            r = [maybe_int(s) for s in parts]\n            return r\n\n        return sorted(l, key=key)\n\n    def _reload_on_server_update(self):\n        \"\"\"\n        Returns HTML that instructs the page\n        to reload itself if the server restarts.\n        This works by the server passing us\n        a \"reload\" instruction with it's PID;\n        if that PID is different than the one the\n        client is currently displaying, then\n        the client will reload to get the current\n        server's page (with it's new PID).  See\n        \"connection()\" below.\n        \"\"\"\n        return html_render.javascript(\n            \"\"\"\n            socket.on(\"reload\", (event) => {\n                console.log(\"event.id=\" + event.id);\n                if (event.id != %s) {\n                    location.reload();\n                }\n            });\n        \"\"\"\n            % os.getpid()\n        )\n\n    def request(self, message):\n        \"\"\"\n        Handle a UI \"request\", which reports the control's\n        current value.  We broadcast the result to make sure\n        all clients show a consistent state.\n        \"\"\"\n        control_name = message[\"control\"]\n        reply = {\n            \"control\": control_name,\n            \"enable\": True,\n        }\n        strategy = self._request.get(control_name, self._bad_request)\n        value = strategy(control_name)\n        reply.update(value)\n        flask_socketio.emit(\n            \"%s-value\" % control_name,\n            reply,\n            broadcast=True,\n        )\n\n    def _bad_request(self, control_name):\n        print('No request strategy for \"%s\"' % (control_name,))\n        return {\n            \"control_name\": control_name,\n            \"enable\": False,\n            \"value\": \"N/A\",\n        }\n\n    def update(self, message):\n        \"\"\"\n        Handle a UI \"update\", which changes the value of a control.\n        We call the given control's update callback, which returns\n        a new value to report to the user.  Send that new\n        value out in broadcast mode so everyone sees it.\n        \"\"\"\n        control_name = message[\"control\"]\n        requested_value = message[\"value\"]\n        reply = {\n            \"control\": control_name,\n            \"enable\": True,\n        }\n        strategy = self._update.get(control_name, self._bad_update)\n        value = strategy(control_name, requested_value)\n        reply.update(value)\n        flask_socketio.emit(\n            \"%s-value\" % control_name,\n            reply,\n            broadcast=True,\n        )\n\n    def _bad_update(self, control_name, new_value):\n        print('No update strategy for \"%s\"' % (control_name,))\n        return {\n            \"control_name\": control_name,\n            \"enable\": False,\n            \"value\": \"N/A\",\n        }\n\n    def get_meminfo(self):\n        \"\"\"\n        Returns a map of name/value pairs,\n        where the names and values are read from\n        \"/proc/meminfo\".  We use this to\n        e.g. figure out how much RAM is in use.\n        \"\"\"\n        r = {}\n        kb_match = re.compile(\"([a-zA-Z0-9_]+):[ ]+([0-9]+) kB\")\n        with open(\"/proc/meminfo\", \"rt\") as f:\n            for l in f:\n                m = kb_match.match(l)\n                if m:\n                    r[m.group(1)] = 1024 * int(m.group(2))\n        return r\n\n    def thermal_zones(self):\n        \"\"\"\n        yields the thermal zone's \"type\" and the filename where that zone's\n        temperature can be read.\n        \"\"\"\n        thermal = \"/sys/class/thermal\"\n        for zone_name in os.listdir(thermal):\n            temp = os.path.join(thermal, zone_name, \"temp\")\n            type_ = os.path.join(thermal, zone_name, \"type\")\n            if not os.path.isfile(temp):\n                continue\n            if not os.path.isfile(type_):\n                continue\n            with open(type_, \"rt\") as f:\n                type_name = f.read().strip()\n            yield type_name, temp\n\n    def update_proc_stat(self):\n        \"\"\"\n        Get a list of name/value pairs from \"/proc/stat\" and\n        save that to self._proc_stat.\n        \"\"\"\n        r = {}\n        with open(\"/proc/stat\", \"rt\") as f:\n            for l in f:\n                s = l.split(\" \", 1)\n                r[s[0]] = s[1]\n        self._proc_stat.update(r)\n\n    def cpus(self):\n        \"\"\"\n        Yields \"cpu0\", \"cpu1\", ...\n        \"\"\"\n        cpu_directory = \"/sys/devices/system/cpu\"\n        cpu_match = re.compile(\"(cpu[0-9]+)\")\n        for cpu_file in os.listdir(cpu_directory):\n            m = cpu_match.match(cpu_file)\n            if not m:\n                continue\n            yield m.group(1)", "\n\napp = flask.Flask(__name__)\nsocketio = flask_socketio.SocketIO(app, cors_allowed_origins=\"*\")\nholoscan_test_controls = HoloscanTestControls(app)\n\n\n@app.route(\"/\")\ndef index():\n    return holoscan_test_controls.index()", "def index():\n    return holoscan_test_controls.index()\n\n\n@socketio.on(\"update\")\ndef update(message):\n    holoscan_test_controls.update(message)\n\n\n@socketio.on(\"request\")\ndef request(message):\n    holoscan_test_controls.request(message)", "\n@socketio.on(\"request\")\ndef request(message):\n    holoscan_test_controls.request(message)\n\n\n@socketio.on(\"connect\")\ndef connection():\n    \"\"\"\n    Support for telling the client to reload itself when the server\n    restarts.  The page itself includes our PID (via\n    _reload_on_server_update).  This callback--which we get when the client\n    reconnects to us--tells the client to reload itself if the PID they\n    have is different than ours.\n    \"\"\"\n    flask_socketio.emit(\"reload\", {\"id\": os.getpid()})", "\n\ndef main():\n    socketio.run(app, host=\"0.0.0.0\", port=8767)\n\n\nif __name__ == \"__main__\":\n    main()\n", ""]}
{"filename": "src/dgpu_util.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n# SPDX-License-Identifier: Apache-2.0\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software", "#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport subprocess\nimport util\nimport xml.etree.ElementTree as ET", "import util\nimport xml.etree.ElementTree as ET\n\n\ndef dgpu_board_information():\n    # Find all NVIDIA Video controller devices on the PCI bus.\n    command = [\"/usr/bin/lspci\", \"-n\", \"-d\", \"10de::0300\"]\n    for l in util.run_command(command):\n        pci_bus_address, pci_class, pci_id, rev = l.split(None, 3)\n        r = {\n            \"pci_bus_address\": pci_bus_address,\n            \"pci_class\": pci_class,\n            \"pci_id\": pci_id,\n            \"rev\": rev,\n        }\n        # Get nvidia-smi's output in XML format\n        command = [\"nvidia-smi\", \"-q\", \"--xml-format\", \"-i\", pci_bus_address]\n        try:\n            result = subprocess.run(\n                command,\n                capture_output=True,\n            )\n            xml_data = result.stdout\n            root = ET.fromstring(xml_data)\n            gpus = root.findall(\"./gpu\")\n            assert len(gpus) == 1\n            gpu = gpus[0]\n            r.update(\n                {\n                    \"serial\": gpu.find(\"serial\").text,\n                    \"uuid\": gpu.find(\"uuid\").text,\n                    \"vbios_version\": gpu.find(\"vbios_version\").text,\n                    \"board_id\": util.Hex(int(gpu.find(\"board_id\").text, 0)),\n                    \"gpu_part_number\": gpu.find(\"gpu_part_number\").text,\n                    \"img_version\": gpu.find(\"inforom_version\").find(\"img_version\").text,\n                }\n            )\n        except FileNotFoundError:\n            r[\"driver_status\"] = util.Na(\"DGPU driver not available\")\n        yield r", "\n\ndef dgpu_driver_information():\n    # Get nvidia-smi's output in XML format\n    command = [\"nvidia-smi\", \"-q\", \"--xml-format\"]\n    try:\n        result = subprocess.run(\n            command,\n            capture_output=True,\n        )\n        xml_data = result.stdout\n        root = ET.fromstring(xml_data)\n        information = {\n            \"driver_version\": root.find(\"driver_version\").text,\n            \"cuda_version\": root.find(\"cuda_version\").text,\n            \"attached_dgpus\": int(root.find(\"./attached_gpus\").text),\n        }\n    except FileNotFoundError:\n        information = {\"status\": util.Na(\"DGPU driver not available\")}\n    return information", ""]}
{"filename": "src/util.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n# SPDX-License-Identifier: Apache-2.0\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software", "#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n#\n# See README.md for detailed information.\n#", "# See README.md for detailed information.\n#\n\nimport os\nimport holoscan_test_suite.html_render as html_render\nimport json\nimport os.path\nimport re\nimport subprocess\nimport yaml", "import subprocess\nimport yaml\n\n\ndef run_command(command, not_found_callback=None):\n    \"\"\"Runs the command (e.g. [\"/usr/sbin/ethtool\", \"-i\", \"wlan0\"]) in a\n    subshell, assert fails if there's anything on stderr or if the returncode\n    isn't 0, and yields back each line of stdout converted to a string (from\n    bytes).  If the command fails with a FileNotFoundError, we'll call\n    not_found_callback(command) unless it's None, in which case we'll propogate\n    the FileNotFoundError.\"\"\"\n    try:\n        result = subprocess.run(\n            command,\n            capture_output=True,\n        )\n    except FileNotFoundError:\n        if not_found_callback is None:\n            raise\n        not_found_callback(command)\n        return\n    if len(result.stderr) != 0:\n        print('ignoring \"%s\"' % (result.stderr,))\n    for s in result.stdout.decode(\"utf-8\").split(\"\\n\"):\n        # don't bother with blank lines.\n        if len(s) == 0:\n            continue\n        yield s\n    return result.returncode", "\n\ndef fetch(*path):\n    \"\"\"Shorthand that makes it easy to fetch the\n    contents of a file.  Typically used to fetch\n    e.g. /sys/class/net/(ethernet)/(setting)\"\"\"\n    with open(os.path.join(*path), \"rt\") as f:\n        v = f.read()\n    return v.strip()\n", "\n\nclass Hex(int):\n    \"\"\"Wraps int so that YAML and HTML will display it using hex.  NOTE that\n    because int's __new__ method stores the value that is used when this is\n    used in an int context, we don't need to worry about how that works here.\n    We just cache it for our own purposes.\"\"\"\n\n    def __init__(self, i, width=\"\"):\n        self._i = i\n        self._format = \"0x%%%sX\" % (width,)\n\n    def html(self):\n        return str(self)\n\n    def __str__(self):\n        return self._format % self._i", "\n\nyaml.add_representer(Hex, lambda dumper, data: dumper.represent_int(str(data)))\n\n\nclass Na:\n    \"\"\"Wraps a e.g. string value so that when it's rendered as HTML,\n    it uses the html_render.na style (e.g. italic).\"\"\"\n\n    def __init__(self, context):\n        self._context = context\n\n    def html(self):\n        return html_render.na(self._context)\n\n    def __str__(self):\n        return \"N/A: %s\" % self._context", "\n\nyaml.add_representer(Na, lambda dumper, data: dumper.represent_str(str(data)))\n\n\ndef emmc_information(path):\n    \"\"\"Fish around in e.g. /sys/block/mmcblk0 to\n    acquire data about the given device.\"\"\"\n    information = {\n        \"path\": path,\n        \"name\": fetch(path, \"device\", \"name\"),\n        \"rev\": Hex(int(fetch(path, \"device\", \"rev\"), 0)),\n        \"date\": fetch(path, \"device\", \"date\"),\n        \"fwrev\": fetch(path, \"device\", \"fwrev\"),\n        \"hwrev\": Hex(int(fetch(path, \"device\", \"hwrev\"), 0)),\n        \"serial\": int(fetch(path, \"device\", \"serial\"), 0),\n        \"type\": fetch(path, \"device\", \"type\"),\n        \"oemid\": Hex(int(fetch(path, \"device\", \"oemid\"), 0)),\n    }\n    return information", "\n\ndef list_pci_devices(device_ids):\n    # Find the devices on PCI.  pci_devices is indexed bus ID\n    # (e.g. \"0001:04:00.0\").  device_ids is a list of \"vendor:device:class\"\n    # per the lspci command-- leave a section blank to match all,\n    # (e.g. \"::0280\" will find all wifi devices).\n    pci_devices = {}\n    for device_id in device_ids:\n        # Sorry, we're not following the man page's instructions\n        # to use the \"machine readable\" format-- those values have\n        # quotes and stuff in them that make them hard to deal with.\n        command = [\"/usr/bin/lspci\", \"-n\", \"-d\", device_id]\n        for l in run_command(command):\n            pci_rev = Na(\"No value given\")\n            try:\n                pci_bus_address, pci_class, pci_id, pci_rev = l.split(None, 3)\n            except ValueError:\n                pci_bus_address, pci_class, pci_id = l.split(None, 2)\n            pci_devices[pci_bus_address] = {\n                \"pci_bus_address\": pci_bus_address,\n                \"pci_class\": pci_class,\n                \"pci_id\": pci_id,\n                \"pci_rev\": pci_rev,\n            }\n    return pci_devices", "\n\ndef nvme_information(path):\n    \"\"\"Use the \"nvme\" tool to fetch information about\n    this device.\"\"\"\n    # TO DO: Add PCI mapping information.\n    command = [\"/usr/sbin/nvme\", \"id-ctrl\", \"--output-format=json\", path]\n    information = {\"tool_status\": Na(\"nvme tool not found\")}\n    try:\n        result = subprocess.run(\n            command,\n            capture_output=True,\n        )\n        if len(result.stderr) != 0:\n            print(\"ignoring %s\" % (result.stderr,))\n        if result.returncode == 0:\n            m = json.loads(result.stdout)\n            information = {\n                \"path\": path,\n                \"vendor_oui\": m[\"ieee\"],\n                \"model_number\": m[\"mn\"].strip(),\n                \"serial_number\": m[\"sn\"].strip(),\n                \"firmware_revision\": m[\"fr\"].strip(),\n                \"pci_vendor_id\": m[\"vid\"],\n                \"pci_subsystem_vendor_id\": m[\"ssvid\"],\n                \"total_capacity_bytes\": m[\"tnvmcap\"],\n                \"total_capacity_gb\": round(m[\"tnvmcap\"] / (1024 * 1024 * 1024), 1),\n            }\n    except FileNotFoundError:\n        pass\n    return information", "\n\ndef sata_information(path):\n    \"\"\"Use hdparam to find information about this device (e.g. \"/dev/sda\").\"\"\"\n    command = [\"/sbin/hdparm\", \"-I\", path]\n    result = subprocess.run(\n        command,\n        capture_output=True,\n    )\n    binary_data = result.stdout\n    if len(result.stderr) != 0:\n        print(\"Ignoring stderr=%s\" % (result.stderr,))\n    if result.returncode != 0:\n        return {\"status\": Na(\"No device detected.\")}\n    data = binary_data.decode(\"utf-8\")\n\n    def match_group(rexp, group):\n        m = re.search(rexp, data, flags=re.MULTILINE)\n        return m.group(group)\n\n    # These regular expressions collect all the data, including spaces, in the\n    # line starting with e.g. \"Model Number:\"; but scraps spaces on either side of\n    # the model number string.\n    r = {\n        \"model_number\": match_group(\"Model Number:[ ]+(.+?)[ ]*$\", 1),\n        \"serial_number\": match_group(\"Serial Number:[ ]+(.+?)[ ]*$\", 1),\n        \"firmware_revision\": match_group(\"Firmware Revision:[ ]+(.+?)[ ]*$\", 1),\n    }\n    return r", "\n\ndef pci_network_device_information():\n    pci_devices = list_pci_devices([\"::0200\", \"::0280\"])\n    \"\"\"Look in /sys/class/net to learn about network devices.\"\"\"\n    network_path = \"/sys/class/net\"\n    interfaces = os.listdir(network_path)\n    for interface in interfaces:\n        # Can we map this back to a PCI slot?\n        path = \"/sys/class/net/%s/device\" % interface\n        realpath = os.path.realpath(path)\n        _, slot = os.path.split(realpath)\n        if slot not in pci_devices:\n            continue\n        information = {\n            \"interface\": interface,\n            \"mac_address\": fetch(network_path, interface, \"address\"),\n        }\n        information.update(pci_devices[slot])\n        command = [\"/usr/sbin/ethtool\", \"-i\", interface]\n        result = subprocess.run(\n            command,\n            capture_output=True,\n        )\n        if len(result.stderr) > 0:\n            # lo produces this error; don't include it at all.\n            assert b\"Operation not supported\" in result.stderr\n            continue\n        assert result.returncode == 0\n        for binary_line in result.stdout.split(b\"\\n\"):\n            if len(binary_line) == 0:\n                continue\n            l = binary_line.decode(\"utf-8\")\n            name, value = l.split(\": \", 1)\n            # don't clutter the report with irrelevant \"supports-...\" stuff\n            if name.startswith(\"supports-\"):\n                continue\n            name = name.replace(\"-\", \"_\")  # ethtool uses '-' to split up words in name\n            value = value if len(value) else Na(\"No value given\")\n            information[name] = value\n        yield information", "\n\ndef test_information(timestamp):\n    # What is our git revision\n    version = Na(\"Version not available.\")\n    try:\n        with open(\"project-version\", \"rt\") as f:\n            version = f.read().strip()\n    except FileNotFoundError:\n        pass\n    #\n    return {\n        \"device_time\": timestamp.isoformat(),\n        \"version\": version,\n    }", "\n\ndef to_snake(s):\n    l = \"_\".join(s.lower().split(\" \"))\n    return l\n\n\ndef v4l2_information(device):\n    try:\n        information = {}\n        category = None\n        for s in run_command([\"/usr/bin/v4l2-ctl\", \"--device\", device, \"--info\"]):\n            name_value_pair = s.split(\":\", 1)\n            name = name_value_pair[0].strip()\n            value = \"\"\n            if len(name_value_pair) > 1:\n                value = name_value_pair[1].strip()\n            if len(value) == 0:\n                value = Na(\"No value given\")\n            if s.startswith(\"\\t\\t\"):\n                continue\n            if s.startswith(\"\\t\"):\n                information[\"%s.%s\" % (category, to_snake(name))] = value\n                continue\n            category = to_snake(name)\n    except FileNotFoundError:\n        information = {\"status\": Na('V4L2 device \"%s\" not available' % device)}\n    return information", ""]}
{"filename": "src/test_sata.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n# SPDX-License-Identifier: Apache-2.0\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software", "#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# See README.md for detailed information.\n\nimport pytest", "\nimport pytest\n\n\n@pytest.mark.clara_agx_devkit_only\ndef test_sata_clara_agx_devkit(script):\n    assert script.run(\"bringup_sata_clara_agx_devkit.sh\") == 0\n"]}
{"filename": "src/flask_wrapper.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n# SPDX-License-Identifier: Apache-2.0\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software", "#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n#\n# See README.md for detailed information.\n", "# See README.md for detailed information.\n\n# This program configures the python flask framework to implement a simple web\n# application that wraps calls to pytest, possibly with a \"-k (test)\"\n# filter option.  The main program configures a web server that has URLs to\n# each of the tests established in the given script, and a special \"/test_all\"\n# URL and the \"/\" default URL are also added.\n#\n# The default URL (\"/\") produces an HTML page with a configuration report and\n# links to \"/test_all\" and each of the tests in the current directory.", "# The default URL (\"/\") produces an HTML page with a configuration report and\n# links to \"/test_all\" and each of the tests in the current directory.\n#\n# The \"/test_all\" URL results in running pytest on the all tests and accumulate\n# the results.  An HTML page is generated that includes the configuration\n# report above, a quick list of each test and it's pass/fail/skipped status,\n# and detail (stdout and stderr for each test) for each executed test, sorted\n# in test-name alphabetic order.\n#\n# Tests can be specifically marked as appropriate for IGX Orin Devkit or Clara", "#\n# Tests can be specifically marked as appropriate for IGX Orin Devkit or Clara\n# AGX devkit only, by prefixing the test with\n# \"@pytest.mark.igx_orin_devkit_only\" or \"@pytest.mark.clara_agx_devkit_only\":\n#\n#   import pytest\n#   @pytest.mark.clara_agx_devkit_only\n#   def test_sata_clara_agx_devkit(script):\n#       assert script.run(\"bringup_sata_clara_agx_devkit.sh\") == 0\n#", "#       assert script.run(\"bringup_sata_clara_agx_devkit.sh\") == 0\n#\n# In this case, when run on an IGX Orin Devkit, this test will be skipped with an\n# appropriate message supplied.\n#\n# To run this program, tell it how to generate a configuration report:\n#\n#   python3 flask_wrapper.py demo_report\n#\n# This tells flask_wrapper.py to load demo_report.py.  This module provides an", "#\n# This tells flask_wrapper.py to load demo_report.py.  This module provides an\n# \"identify()\" routine that returns a map of name/value pairs that describes\n# the system with sufficient detail to prove repeatability with a validated\n# configuration.\n#\n# Once the test cases are loaded, flask_wrapper sets up a web server on the\n# localhost at port 8765.\n\nimport argparse", "\nimport argparse\nimport datetime\nfrom holoscan_test_suite.html_render import *\nimport flask\nimport importlib\nimport os\nimport pytest\nimport sys\nimport time", "import sys\nimport time\nimport yaml\n\nREPORT_CACHE = \"/tmp/holoscan-test-suite-reports\"\n\n\ndef run_application(configuration, name):\n    \"\"\"Configure flask_wrapper with a server on port 8765.\"\"\"\n    # Get all the tests we know about.\n    test_name_accumulator = TestNameAccumulator()\n    pytest.main([\"--collect-only\"], plugins=[test_name_accumulator])\n    # Create and configure the flask application.\n    app = flask.Flask(name)\n    app.add_url_rule(\n        \"/\",\n        view_func=lambda: index_page(configuration, test_name_accumulator),\n        endpoint=\"/\",\n    )\n    app.add_url_rule(\n        \"/test_all\",\n        view_func=lambda: test_all(configuration, test_name_accumulator),\n        endpoint=\"/test_all\",\n    )\n    # Add /(testscript) pages\n    for test_script in test_name_accumulator.names():\n        app.add_url_rule(\n            \"/%s\" % test_script,\n            view_func=lambda test_script=test_script: run_script(\n                configuration, test_script\n            ),\n            endpoint=test_script,\n        )\n    app.add_url_rule(\n        \"/report\",\n        view_func=get_report,\n        endpoint=\"/report\",\n    )\n    # Allow the report to add pages\n    configuration.configure_app(app)\n    # Don't cache these pages on the browser side\n    app.after_request(disable_cache)\n    #\n    return app", "\n\nclass TestNameAccumulator:\n    \"\"\"This class listens to pytest for the tests\n    it finds.  Get that list of names by calling the\n    names() method.\n    \"\"\"\n\n    def __init__(self):\n        self._names = []\n\n    def pytest_collection_modifyitems(self, session, config, items):\n        \"\"\"Hooks into pytest to observe all the tests we're aware of.\"\"\"\n        for i in items:\n            self._names.append(i.name)\n        # we'll always run in a consistent order.\n        self._names.sort()\n\n    def names(self):\n        \"\"\"Fetch the list of test names we've found.\"\"\"\n        for name in self._names:\n            yield name", "\n\ndef index_page(configuration, test_name_accumulator):\n    \"\"\"Generate the index page.\"\"\"\n    #\n    now = time.time()\n    timestamp = datetime.datetime.fromtimestamp(now, tz=datetime.timezone.utc)\n    # Start with the configuration report\n    information = configuration.information()\n    # Save it.\n    configuration_report_name = timestamp.strftime(\n        \"configuration-report-%Y-%m-%d-%H-%M-%S.yaml\"\n    )\n    s = yaml.dump(information, default_flow_style=False)\n    os.makedirs(REPORT_CACHE, exist_ok=True)\n    with open(os.path.join(REPORT_CACHE, configuration_report_name), \"wt\") as f:\n        f.write(s)\n    # Reports.\n    doc = [\n        header(3, \"Reports\"),\n        rtable(\n            {\n                \"Configuration report\": Link(\n                    configuration_report_name,\n                    \"/report?report_name=%s\" % (escape(configuration_report_name),),\n                ),\n            }\n        ),\n        horizontal_rule(),\n    ]\n    # Actions.\n    include_timestamp = {\n        \"onclick\": 'now=new Date();this.href+=\"?iso_time_utc=\"+now.toISOString()+\"&local_time=\"+now.toLocaleString()+\" (\"+Intl.DateTimeFormat().resolvedOptions().timeZone+\")\"'\n    }\n    doc.append(\n        [\n            header(3, \"Actions\"),\n            ul([link(\"Run all tests\", \"test_all\", attributes=include_timestamp)]),\n            ul(\n                [\n                    link(\"Run %s\" % s, s, attributes=include_timestamp)\n                    for s in test_name_accumulator.names()\n                ]\n            ),\n            configuration.actions(),  # This configuration may have special controls.\n            horizontal_rule(),\n        ]\n    )\n    # Configuration.\n    doc.append(\n        [\n            header(3, \"Configuration\"),\n            rtable(information),\n            horizontal_rule(),\n        ]\n    )\n    # Send it.\n    r = render(html(body(doc)))\n    return r", "\n\nclass HoloscanTestSuitePlugin:\n    def __init__(self):\n        self._start = time.time()\n        self._information = {}\n\n    @pytest.hookimpl(tryfirst=True, hookwrapper=True)\n    def pytest_runtest_makereport(self, item, call):\n        # get the test report object; this is called\n        # after each test is run.\n        outcome = yield\n        report = outcome.get_result()\n        script = item.funcargs.get(\"script\", None)\n        capsys = item.funcargs.get(\"capsys\", None)\n        #\n        passed_style = {}\n        failed_style = {\"color\": \"red\"}\n        if (report.when == \"setup\") and report.skipped:\n            r = {\n                \"passed\": report.passed,\n                \"outcome\": report.outcome,\n                \"skipped\": report.skipped,\n                \"reason\": call.excinfo.value.msg,\n                \"pytest_output\": report.longreprtext,\n                \"stdout\": \"\",\n                \"stderr\": \"\",\n            }\n            self._information[item.name] = r\n            return\n        if report.when == \"call\":\n            r = {\n                \"passed\": report.passed,\n                \"outcome\": report.outcome,\n                \"skipped\": report.skipped,\n                \"duration\": report.duration,\n                \"pytest_output\": report.longreprtext,\n            }\n            # script._result is the output from the shell scripts.\n            if script is not None:\n                result = script._result\n                r.update(\n                    {\n                        \"stdout\": result.stdout.decode(\"utf-8\"),\n                        \"stderr\": result.stderr.decode(\"utf-8\"),\n                    }\n                )\n            elif capsys is not None:\n                outerr = capsys.readouterr()\n                r.update(\n                    {\n                        \"stdout\": outerr.out,\n                        \"stderr\": outerr.err,\n                    }\n                )\n            else:\n                r.update(\n                    {\n                        \"stdout\": \"N/A\",\n                        \"stderr\": \"N/A\",\n                    }\n                )\n            #\n            self._information[item.name] = r\n            return\n        # we ignore any other reports.\n\n    def information(self):\n        return self._information", "\n\n_passed_style = {}\n_failed_style = {\"color\": \"red\"}\n\n\ndef _test_status(status):\n    if status[\"skipped\"]:\n        return div(\"SKIPPED\")\n    if status[\"passed\"]:\n        return div(\"Passed\", style=_passed_style)\n    return div(\"FAILED\", style=_failed_style)", "\n\ndef html_results(results):\n    document = []\n    passed_style = {}\n    failed_style = {\"color\": \"red\"}\n    output_style = {\n        \"margin-left\": \"40px\",\n        \"background-color\": \"#EEEEEE\",\n    }\n    na_style = {\n        \"margin-left\": \"40px\",\n    }\n    # Include specific test data\n    items = []\n    for test_name, status in results.items():\n        #\n        detail = header(4, test_name, attributes={\"id\": test_name})\n        t = [(\"passed\", _test_status(status))]\n        if \"duration\" in status:\n            t.append((\"duration\", \"%.2fs\" % status[\"duration\"]))\n        if \"reason\" in status:\n            t.append((\"reason\", status[\"reason\"]))\n        detail.append(table(t))\n        pytest_output = status[\"pytest_output\"]\n        detail.append(paragraph(\"pytest output\"))\n        if len(pytest_output):\n            detail.append(pre(pytest_output, style=output_style))\n        else:\n            detail.append(na(\"No pytest output generated\", style=na_style))\n        #\n        standard_output = status[\"stdout\"]\n        detail.append(paragraph(\"Standard output\"))\n        if len(standard_output):\n            detail.append(pre(standard_output, style=output_style))\n        else:\n            detail.append(na(\"No standard output captured.\", style=na_style))\n        #\n        standard_error = status[\"stderr\"]\n        detail.append(paragraph(\"Standard error\"))\n        if len(standard_error):\n            detail.append(pre(standard_error, style=output_style))\n        else:\n            detail.append(na(\"No standard error captured.\", style=na_style))\n        detail.append(horizontal_rule())\n        items.append(detail)\n    document.append(ul(items))\n    return document", "\n\ndef _run_tests(configuration, test_names):\n    def generate(args):\n        now = time.time()\n        timestamp = datetime.datetime.fromtimestamp(now, tz=datetime.timezone.utc)\n        # Generate the output we can\n        information = configuration.information()\n        information[\"test\"][\"browser_iso_time_utc\"] = args[\"iso_time_utc\"]\n        information[\"test\"][\"browser_local_time\"] = args[\"local_time\"]\n        # Save the configuration report.\n        configuration_report_name = timestamp.strftime(\n            \"configuration-report-%Y-%m-%d-%H-%M-%S.yaml\"\n        )\n        report_name = timestamp.strftime(\"test-report-%Y-%m-%d-%H-%M-%S.yaml\")\n        s = yaml.dump(information, default_flow_style=False)\n        os.makedirs(REPORT_CACHE, exist_ok=True)\n        with open(os.path.join(REPORT_CACHE, configuration_report_name), \"wt\") as f:\n            f.write(s)\n        #\n        summary_rows = []\n        for test_name in test_names:\n            attributes = {\"id\": \"status_%s\" % test_name}\n            summary_rows.append(\n                [\n                    link(test_name, url=\"#%s\" % test_name),\n                    div(\"UNTESTED\", attributes=attributes),\n                ]\n            )\n        document_part = [\n            header(3, \"Testing Summary\"),\n            table(summary_rows),\n            horizontal_rule(),\n            header(3, \"Reports\"),\n            rtable(\n                {\n                    \"Configuration report\": Link(\n                        configuration_report_name,\n                        \"/report?report_name=%s\" % (escape(configuration_report_name),),\n                    ),\n                    \"Test results report\": Link(\n                        report_name, \"/report?report_name=%s\" % (escape(report_name),)\n                    ),\n                }\n            ),\n            horizontal_rule(),\n            header(3, \"Configuration\"),\n            rtable(information),\n            horizontal_rule(),\n            header(3, \"Testing Detail\"),\n        ]\n        html_out = render([html_start(), body_start(), document_part])\n        yield html_out\n        #\n        # Run it.\n        accumulated_results = {}\n        for test_name in test_names:\n            # We're underway\n            document_part = [\n                script(\n                    'document.getElementById(\"status_%s\").innerText = \"UNDERWAY\"'\n                    % test_name\n                ),\n            ]\n            html_out = render(document_part)\n            yield html_out\n            holoscan_test_suite_plugin = HoloscanTestSuitePlugin()\n            pytest_command_line = [\n                \"-p\",\n                \"no:cacheprovider\",\n                \"-k\",\n                test_name,\n            ]\n            pytest.main(\n                pytest_command_line,\n                plugins=[\n                    holoscan_test_suite_plugin,\n                ],\n            )\n            # Report it.\n            results = holoscan_test_suite_plugin.information()\n            accumulated_results.update(results)\n            # YAML\n            yaml_result = {\n                \"identification\": information,\n                \"results\": accumulated_results,\n            }\n            s = yaml.dump(yaml_result, default_flow_style=False)\n            os.makedirs(REPORT_CACHE, exist_ok=True)\n            with open(os.path.join(REPORT_CACHE, report_name), \"wt\") as f:\n                f.write(s)\n            # HTML\n            document_part = [html_results(results)]\n            for result_test_name, result_status in results.items():\n                if result_status[\"skipped\"]:\n                    s = \"SKIPPED\"\n                elif result_status[\"passed\"]:\n                    s = \"PASSED\"\n                else:\n                    s = \"FAILED\"\n                document_part.append(\n                    [\n                        script(\n                            'document.getElementById(\"status_%s\").innerText = \"%s\"'\n                            % (result_test_name, s)\n                        )\n                    ],\n                )\n            html_out = render(document_part)\n            yield html_out\n        document_part = [body_end(), html_end()]\n        html_out = render(document_part)\n        yield html_out\n\n    args = flask.request.args\n    return flask.Response(generate(args), mimetype=\"text/html\")", "\n\ndef test_all(configuration, test_name_accumulator):\n    \"\"\"Runs all the tests that test_name_accumulator knows about.\"\"\"\n    return _run_tests(configuration, list(test_name_accumulator.names()))\n\n\ndef run_script(configuration, test_script):\n    return _run_tests(configuration, [test_script])\n", "\n\ndef get_report():\n    args = flask.request.args\n    report_name = args[\"report_name\"]\n    print(\"REPORT_CACHE=%s report_name=%s\" % (REPORT_CACHE, report_name))\n    return flask.send_from_directory(REPORT_CACHE, report_name, as_attachment=True)\n\n\ndef disable_cache(response):\n    \"\"\"This hook (\"app.after_request\") allows us to tell\n    flask to include the html header that disables the\n    client browser cache.\n    \"\"\"\n    response.cache_control.no_cache = True\n    return response", "\ndef disable_cache(response):\n    \"\"\"This hook (\"app.after_request\") allows us to tell\n    flask to include the html header that disables the\n    client browser cache.\n    \"\"\"\n    response.cache_control.no_cache = True\n    return response\n\n\ndef main():\n    #\n    parser = argparse.ArgumentParser(\n        description=\"Run a test application with the given configuration\",\n    )\n    parser.add_argument(\"configuration\", help=\"Name of configuration module\")\n    parser.add_argument(\n        \"factory\", help=\"Name of method that returns a Configuration object\"\n    )\n    args = parser.parse_args()\n    #\n    configuration_module = importlib.import_module(args.configuration)\n    factory = getattr(configuration_module, args.factory)\n    configuration = factory()\n    app = run_application(configuration, __name__)\n    app.run(host=\"0.0.0.0\", port=8765)\n    return 0", "\n\ndef main():\n    #\n    parser = argparse.ArgumentParser(\n        description=\"Run a test application with the given configuration\",\n    )\n    parser.add_argument(\"configuration\", help=\"Name of configuration module\")\n    parser.add_argument(\n        \"factory\", help=\"Name of method that returns a Configuration object\"\n    )\n    args = parser.parse_args()\n    #\n    configuration_module = importlib.import_module(args.configuration)\n    factory = getattr(configuration_module, args.factory)\n    configuration = factory()\n    app = run_application(configuration, __name__)\n    app.run(host=\"0.0.0.0\", port=8765)\n    return 0", "\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n"]}
{"filename": "src/conftest.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n# SPDX-License-Identifier: Apache-2.0\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software", "#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# See README.md for detailed information.\n\n#", "\n#\n# This file provides pytest with the \"script\" fixture.  Calling \"script.run\"\n# provides the convenient mechanism for executing a shell script and preserving\n# the returncode, stdout, and stderr.  flask_wrapper.py then knows how to fetch the\n# results from script instances and put those in the HTML generated output.\n#\n\nimport pytest\nimport nvidia_util", "import pytest\nimport nvidia_util\nimport subprocess\n\n\nclass Script:\n    \"\"\"\n    The \"script\" fixture fetches an instance of\n    this object; use the \"run\" method here to run\n    the given script in the current directory\n    and save the data written to stdout and stderr.\n    In the nominal case, flask_wrapper.py will\n    write that data to the HTML page passed to\n    the calling browser.\n    \"\"\"\n\n    def __init__(self):\n        self._result = None\n\n    def run(self, script):\n        command = [\"bash\", script]\n        r = subprocess.run(\n            command,\n            capture_output=True,\n        )\n        self._result = r\n        return r.returncode", "\n\n@pytest.fixture\ndef script():\n    r = Script()\n    return r\n\n\ndef pytest_collection_modifyitems(items):\n    model = nvidia_util.model()\n    igx_orin_devkit = model in nvidia_util.igx_orin_devkit\n    clara_agx_devkit = model in nvidia_util.clara_agx_devkit\n    for item in items:\n        if \"igx_orin_devkit_only\" in item.keywords:\n            skip = pytest.mark.skip(\n                reason=\"%s isn't appropriate for %s\" % (item.name, model)\n            )\n            if not igx_orin_devkit:\n                item.add_marker(skip)\n        if \"clara_agx_devkit_only\" in item.keywords:\n            skip = pytest.mark.skip(\n                reason=\"%s isn't appropriate for %s\" % (item.name, model)\n            )\n            if not clara_agx_devkit:\n                item.add_marker(skip)", "def pytest_collection_modifyitems(items):\n    model = nvidia_util.model()\n    igx_orin_devkit = model in nvidia_util.igx_orin_devkit\n    clara_agx_devkit = model in nvidia_util.clara_agx_devkit\n    for item in items:\n        if \"igx_orin_devkit_only\" in item.keywords:\n            skip = pytest.mark.skip(\n                reason=\"%s isn't appropriate for %s\" % (item.name, model)\n            )\n            if not igx_orin_devkit:\n                item.add_marker(skip)\n        if \"clara_agx_devkit_only\" in item.keywords:\n            skip = pytest.mark.skip(\n                reason=\"%s isn't appropriate for %s\" % (item.name, model)\n            )\n            if not clara_agx_devkit:\n                item.add_marker(skip)", ""]}
{"filename": "src/test_nvme.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n# SPDX-License-Identifier: Apache-2.0\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software", "#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# See README.md for detailed information.\n\nimport pytest", "\nimport pytest\n\n\n@pytest.mark.igx_orin_devkit_only\ndef test_nvme(script):\n    assert script.run(\"bringup_nvme_igx_orin_devkit.sh\") == 0\n"]}
{"filename": "src/configuration.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n# SPDX-License-Identifier: Apache-2.0\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software", "#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# See README.md for detailed information.\n\nimport ajantv2_util", "\nimport ajantv2_util\nimport datetime\nimport dgpu_util\nimport infiniband_util\nimport nvidia_util\nimport os\nimport time\nimport util\nimport yaml", "import util\nimport yaml\n\n\nclass Configuration:\n    def __init__(self, information):\n        self._information = information\n\n    def information(self):\n        return self._information\n\n    def configure_app(self, flask_app):\n        pass\n\n    def actions(self):\n        return []", "\n\nfrom holoscan_test_suite.html_render import *\n\npci_id_fixup = str.maketrans(\":.\", \"__\")\n\n\ndef by_pci_bus_address(prefix, iterable):\n    r = {}\n    for i in iterable:\n        r[prefix % i[\"pci_bus_address\"].translate(pci_id_fixup)] = i\n    return r", "\n\nclass IgxOrinDevkitConfiguration(Configuration):\n    def __init__(self):\n        self._now = time.time()\n        self._timestamp = datetime.datetime.fromtimestamp(\n            self._now, tz=datetime.timezone.utc\n        )\n        no_dgpus = [util.Na(\"No dGPU found\")]\n        no_ajas = [util.Na(\"No AJA video adapter found\")]\n        configuration = {\n            \"test\": util.test_information(self._timestamp),\n            \"idrom\": nvidia_util.jetson_eeprom_information(),\n            \"dgpu_driver\": dgpu_util.dgpu_driver_information(),\n            **by_pci_bus_address(\"dgpu_%s\", dgpu_util.dgpu_board_information()),\n            \"aja_driver\": ajantv2_util.aja_driver_information(),\n            **by_pci_bus_address(\"aja_%s\", ajantv2_util.aja_board_information()),\n            \"mmcblk0\": util.emmc_information(\"/sys/block/mmcblk0\"),\n            \"nvme0n1\": util.nvme_information(\"/dev/nvme0n1\"),\n            \"sata_sda\": util.sata_information(\"/dev/sda\"),\n            \"video_0\": util.v4l2_information(\"/dev/video0\"),\n            **by_pci_bus_address(\n                \"mellanox_%s\", infiniband_util.infiniband_information()\n            ),\n            **by_pci_bus_address(\"net_%s\", util.pci_network_device_information()),\n        }\n        sorted_dict = lambda d: {k: d[k] for k in sorted(d)}\n        super(IgxOrinDevkitConfiguration, self).__init__(sorted_dict(configuration))", "\n\ndef igx_orin_devkit_configuration():\n    return IgxOrinDevkitConfiguration()\n\n\n# Produce the YAML report if we're just run at the command line.\ndef main():\n    configuration = igx_orin_devkit_configuration()\n    information = configuration.information()\n    s = yaml.dump(information, default_flow_style=False)\n    print(s)", "\n\nif __name__ == \"__main__\":\n    main()\n"]}
