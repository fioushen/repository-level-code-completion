{"filename": "scripts/export_onnx_model.py", "chunked_list": ["# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport argparse\nimport warnings\n\nimport torch", "\nimport torch\nfrom onnxruntime import InferenceSession\nfrom onnxruntime.quantization import QuantType\nfrom onnxruntime.quantization.quantize import quantize_dynamic\n\nfrom metaseg.generator import build_sam, build_sam_vit_b, build_sam_vit_l\nfrom metaseg.utils.onnx import SamOnnxModel\n\nparser = argparse.ArgumentParser(", "\nparser = argparse.ArgumentParser(\n    description=\"Export the SAM prompt encoder and mask decoder to an ONNX model.\"\n)\n\nparser.add_argument(\n    \"--checkpoint\",\n    type=str,\n    required=True,\n    help=\"The path to the SAM model checkpoint.\",", "    required=True,\n    help=\"The path to the SAM model checkpoint.\",\n)\n\nparser.add_argument(\n    \"--output\", type=str, required=True, help=\"The filename to save the ONNX model to.\"\n)\n\nparser.add_argument(\n    \"--model-type\",", "parser.add_argument(\n    \"--model-type\",\n    type=str,\n    default=\"default\",\n    help=\"In ['default', 'vit_b', 'vit_l']. Which type of SAM model to export.\",\n)\n\nparser.add_argument(\n    \"--return-single-mask\",\n    action=\"store_true\",", "    \"--return-single-mask\",\n    action=\"store_true\",\n    help=(\n        \"If true, the exported ONNX model will only return the best mask, \"\n        \"instead of returning multiple masks. For high resolution images \"\n        \"this can improve runtime when upscaling masks is expensive.\"\n    ),\n)\n\nparser.add_argument(", "\nparser.add_argument(\n    \"--opset\",\n    type=int,\n    default=17,\n    help=\"The ONNX opset version to use. Must be >=11\",\n)\n\nparser.add_argument(\n    \"--quantize-out\",", "parser.add_argument(\n    \"--quantize-out\",\n    type=str,\n    default=None,\n    help=(\n        \"If set, will quantize the model and save it with this name. \"\n        \"Quantization is performed with quantize_dynamic \"\n        \"from onnxruntime.quantization.quantize.\"\n    ),\n)", "    ),\n)\n\nparser.add_argument(\n    \"--gelu-approximate\",\n    action=\"store_true\",\n    help=(\n        \"Replace GELU operations with approximations using tanh. Useful \"\n        \"for some runtimes that have slow or unimplemented erf ops, used in GELU.\"\n    ),", "        \"for some runtimes that have slow or unimplemented erf ops, used in GELU.\"\n    ),\n)\n\nparser.add_argument(\n    \"--use-stability-score\",\n    action=\"store_true\",\n    help=(\n        \"Replaces the model's predicted mask quality score with the stability \"\n        \"score calculated on the low resolution masks using an offset of 1.0. \"", "        \"Replaces the model's predicted mask quality score with the stability \"\n        \"score calculated on the low resolution masks using an offset of 1.0. \"\n    ),\n)\n\nparser.add_argument(\n    \"--return-extra-metrics\",\n    action=\"store_true\",\n    help=(\n        \"The model will return five results: (masks, scores, stability_scores, \"", "    help=(\n        \"The model will return five results: (masks, scores, stability_scores, \"\n        \"areas, low_res_logits) instead of the usual three. This can be \"\n        \"significantly slower for high resolution outputs.\"\n    ),\n)\n\n\ndef run_export(\n    model_type: str,\n    checkpoint: str,\n    output: str,\n    opset: int,\n    return_single_mask: bool,\n    gelu_approximate: bool = False,\n    use_stability_score: bool = False,\n    return_extra_metrics=False,\n):\n    print(\"Loading model...\")\n    if model_type == \"vit_b\":\n        sam = build_sam_vit_b(checkpoint)\n    elif model_type == \"vit_l\":\n        sam = build_sam_vit_l(checkpoint)\n    else:\n        sam = build_sam(checkpoint)\n\n    onnx_model = SamOnnxModel(\n        model=sam,\n        return_single_mask=return_single_mask,\n        use_stability_score=use_stability_score,\n        return_extra_metrics=return_extra_metrics,\n    )\n\n    if gelu_approximate:\n        for n, m in onnx_model.named_modules():\n            if isinstance(m, torch.nn.GELU):\n                m.approximate = \"tanh\"\n\n    dynamic_axes = {\n        \"point_coords\": {1: \"num_points\"},\n        \"point_labels\": {1: \"num_points\"},\n    }\n\n    embed_dim = sam.prompt_encoder.embed_dim\n    embed_size = sam.prompt_encoder.image_embedding_size\n    mask_input_size = [4 * x for x in embed_size]\n    dummy_inputs = {\n        \"image_embeddings\": torch.randn(1, embed_dim, *embed_size, dtype=torch.float),\n        \"point_coords\": torch.randint(\n            low=0, high=1024, size=(1, 5, 2), dtype=torch.float\n        ),\n        \"point_labels\": torch.randint(low=0, high=4, size=(1, 5), dtype=torch.float),\n        \"mask_input\": torch.randn(1, 1, *mask_input_size, dtype=torch.float),\n        \"has_mask_input\": torch.tensor([1], dtype=torch.float),\n        \"orig_im_size\": torch.tensor([1500, 2250], dtype=torch.float),\n    }\n\n    _ = onnx_model(**dummy_inputs)\n\n    output_names = [\"masks\", \"iou_predictions\", \"low_res_masks\"]\n\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\"ignore\", category=torch.jit.TracerWarning)\n        warnings.filterwarnings(\"ignore\", category=UserWarning)\n        with open(output, \"wb\") as f:\n            print(f\"Exporing onnx model to {output}...\")\n            torch.onnx.export(\n                onnx_model,\n                tuple(dummy_inputs.values()),\n                f,\n                export_params=True,\n                verbose=False,\n                opset_version=opset,\n                do_constant_folding=True,\n                input_names=list(dummy_inputs.keys()),\n                output_names=output_names,\n                dynamic_axes=dynamic_axes,\n            )\n\n    ort_inputs = {k: to_numpy(v) for k, v in dummy_inputs.items()}\n    ort_session = InferenceSession(output)\n    _ = ort_session.run(None, ort_inputs)\n    print(\"Model has successfully been run with ONNXRuntime.\")", "def run_export(\n    model_type: str,\n    checkpoint: str,\n    output: str,\n    opset: int,\n    return_single_mask: bool,\n    gelu_approximate: bool = False,\n    use_stability_score: bool = False,\n    return_extra_metrics=False,\n):\n    print(\"Loading model...\")\n    if model_type == \"vit_b\":\n        sam = build_sam_vit_b(checkpoint)\n    elif model_type == \"vit_l\":\n        sam = build_sam_vit_l(checkpoint)\n    else:\n        sam = build_sam(checkpoint)\n\n    onnx_model = SamOnnxModel(\n        model=sam,\n        return_single_mask=return_single_mask,\n        use_stability_score=use_stability_score,\n        return_extra_metrics=return_extra_metrics,\n    )\n\n    if gelu_approximate:\n        for n, m in onnx_model.named_modules():\n            if isinstance(m, torch.nn.GELU):\n                m.approximate = \"tanh\"\n\n    dynamic_axes = {\n        \"point_coords\": {1: \"num_points\"},\n        \"point_labels\": {1: \"num_points\"},\n    }\n\n    embed_dim = sam.prompt_encoder.embed_dim\n    embed_size = sam.prompt_encoder.image_embedding_size\n    mask_input_size = [4 * x for x in embed_size]\n    dummy_inputs = {\n        \"image_embeddings\": torch.randn(1, embed_dim, *embed_size, dtype=torch.float),\n        \"point_coords\": torch.randint(\n            low=0, high=1024, size=(1, 5, 2), dtype=torch.float\n        ),\n        \"point_labels\": torch.randint(low=0, high=4, size=(1, 5), dtype=torch.float),\n        \"mask_input\": torch.randn(1, 1, *mask_input_size, dtype=torch.float),\n        \"has_mask_input\": torch.tensor([1], dtype=torch.float),\n        \"orig_im_size\": torch.tensor([1500, 2250], dtype=torch.float),\n    }\n\n    _ = onnx_model(**dummy_inputs)\n\n    output_names = [\"masks\", \"iou_predictions\", \"low_res_masks\"]\n\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\"ignore\", category=torch.jit.TracerWarning)\n        warnings.filterwarnings(\"ignore\", category=UserWarning)\n        with open(output, \"wb\") as f:\n            print(f\"Exporing onnx model to {output}...\")\n            torch.onnx.export(\n                onnx_model,\n                tuple(dummy_inputs.values()),\n                f,\n                export_params=True,\n                verbose=False,\n                opset_version=opset,\n                do_constant_folding=True,\n                input_names=list(dummy_inputs.keys()),\n                output_names=output_names,\n                dynamic_axes=dynamic_axes,\n            )\n\n    ort_inputs = {k: to_numpy(v) for k, v in dummy_inputs.items()}\n    ort_session = InferenceSession(output)\n    _ = ort_session.run(None, ort_inputs)\n    print(\"Model has successfully been run with ONNXRuntime.\")", "\n\ndef to_numpy(tensor):\n    return tensor.cpu().numpy()\n\n\nif __name__ == \"__main__\":\n    args = parser.parse_args()\n    run_export(\n        model_type=args.model_type,\n        checkpoint=args.checkpoint,\n        output=args.output,\n        opset=args.opset,\n        return_single_mask=args.return_single_mask,\n        gelu_approximate=args.gelu_approximate,\n        use_stability_score=args.use_stability_score,\n        return_extra_metrics=args.return_extra_metrics,\n    )\n\n    print(f\"Quantizing model and writing to {args.quantize_out}...\")\n    quantize_dynamic(\n        model_input=args.output,\n        model_output=args.quantize_out,\n        optimize_model=True,\n        per_channel=False,\n        reduce_range=False,\n        weight_type=QuantType.QUInt8,\n    )\n    print(\"Done!\")", ""]}
{"filename": "scripts/amg.py", "chunked_list": ["# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport argparse\nimport json\nimport os\nfrom typing import Any, Dict, List", "import os\nfrom typing import Any, Dict, List\n\nimport cv2\n\nfrom metaseg.generator import SamAutomaticMaskGenerator, sam_model_registry\n\nparser = argparse.ArgumentParser(\n    description=(\n        \"Runs automatic mask generation on an input image or directory of images, \"", "    description=(\n        \"Runs automatic mask generation on an input image or directory of images, \"\n        \"and outputs masks as either PNGs or COCO-style RLEs. Requires open-cv, \"\n        \"as well as pycocotools if saving in RLE format.\"\n    )\n)\n\nparser.add_argument(\n    \"--input\",\n    type=str,", "    \"--input\",\n    type=str,\n    required=True,\n    help=\"Path to either a single input image or folder of images.\",\n)\n\nparser.add_argument(\n    \"--output\",\n    type=str,\n    required=True,", "    type=str,\n    required=True,\n    help=(\n        \"Path to the directory where masks will be output. \"\n        \"Output will be either a folder \"\n        \"of PNGs per image or a single json with COCO-style masks.\"\n    ),\n)\n\nparser.add_argument(", "\nparser.add_argument(\n    \"--model-type\",\n    type=str,\n    default=\"default\",\n    help=\"The type of model to load, in ['default', 'vit_l', 'vit_b']\",\n)\n\nparser.add_argument(\n    \"--checkpoint\",", "parser.add_argument(\n    \"--checkpoint\",\n    type=str,\n    required=True,\n    help=\"The path to the SAM checkpoint to use for mask generation.\",\n)\n\nparser.add_argument(\n    \"--device\", type=str, default=\"cuda\", help=\"The device to run generation on.\"\n)", "    \"--device\", type=str, default=\"cuda\", help=\"The device to run generation on.\"\n)\n\nparser.add_argument(\n    \"--convert-to-rle\",\n    action=\"store_true\",\n    help=(\n        \"Save masks as COCO RLEs in a single json \"\n        \"instead of as a folder of PNGs. \"\n        \"Requires pycocotools.\"", "        \"instead of as a folder of PNGs. \"\n        \"Requires pycocotools.\"\n    ),\n)\n\namg_settings = parser.add_argument_group(\"AMG Settings\")\n\namg_settings.add_argument(\n    \"--points-per-side\",\n    type=int,", "    \"--points-per-side\",\n    type=int,\n    default=None,\n    help=\"Generate masks by sampling a grid over \"\n    \"the image with this many points to a side.\",\n)\n\namg_settings.add_argument(\n    \"--points-per-batch\",\n    type=int,", "    \"--points-per-batch\",\n    type=int,\n    default=None,\n    help=\"How many input points to process \" \"simultaneously in one batch.\",\n)\n\namg_settings.add_argument(\n    \"--pred-iou-thresh\",\n    type=float,\n    default=None,", "    type=float,\n    default=None,\n    help=\"Exclude masks with a predicted score from \"\n    \"the model that is lower than this threshold.\",\n)\n\namg_settings.add_argument(\n    \"--stability-score-thresh\",\n    type=float,\n    default=None,", "    type=float,\n    default=None,\n    help=\"Exclude masks with a stability \" \"score lower than this threshold.\",\n)\n\namg_settings.add_argument(\n    \"--stability-score-offset\",\n    type=float,\n    default=None,\n    help=\"Larger values perturb the mask \" \"more when measuring stability score.\",", "    default=None,\n    help=\"Larger values perturb the mask \" \"more when measuring stability score.\",\n)\n\namg_settings.add_argument(\n    \"--box-nms-thresh\",\n    type=float,\n    default=None,\n    help=\"The overlap threshold for excluding a duplicate mask.\",\n)", "    help=\"The overlap threshold for excluding a duplicate mask.\",\n)\n\namg_settings.add_argument(\n    \"--crop-n-layers\",\n    type=int,\n    default=None,\n    help=(\n        \"If >0, mask generation is run on smaller \"\n        \"crops of the image to generate more masks. \"", "        \"If >0, mask generation is run on smaller \"\n        \"crops of the image to generate more masks. \"\n        \"The value sets how many different scales to crop at.\"\n    ),\n)\n\namg_settings.add_argument(\n    \"--crop-nms-thresh\",\n    type=float,\n    default=None,", "    type=float,\n    default=None,\n    help=\"The overlap threshold for excluding \"\n    \"duplicate masks across different crops.\",\n)\n\namg_settings.add_argument(\n    \"--crop-overlap-ratio\",\n    type=int,\n    default=None,", "    type=int,\n    default=None,\n    help=\"Larger numbers mean image crops will overlap more.\",\n)\n\namg_settings.add_argument(\n    \"--crop-n-points-downscale-factor\",\n    type=int,\n    default=None,\n    help=\"The number of points-per-side in each \"", "    default=None,\n    help=\"The number of points-per-side in each \"\n    \"layer of crop is reduced by this factor.\",\n)\n\namg_settings.add_argument(\n    \"--min-mask-region-area\",\n    type=int,\n    default=None,\n    help=(", "    default=None,\n    help=(\n        \"Disconnected mask regions or holes with \"\n        \"area smaller than this value \"\n        \"in pixels are removed by postprocessing.\"\n    ),\n)\n\n\ndef write_masks_to_folder(masks: List[Dict[str, Any]], path: str) -> None:\n    header = (\n        \"id,area,bbox_x0,bbox_y0,bbox_w,bbox_h,\"\n        \"point_input_x,point_input_y,predicted_iou,\"\n        \"stability_score,crop_box_x0,crop_box_y0,\"\n        \"crop_box_w,crop_box_h\"\n    )\n    metadata = [header]\n    for i, mask_data in enumerate(masks):\n        mask = mask_data[\"segmentation\"]\n        filename = f\"{i}.png\"\n        cv2.imwrite(os.path.join(path, filename), mask * 255)\n        mask_metadata = [\n            str(i),\n            str(mask_data[\"area\"]),\n            *[str(x) for x in mask_data[\"bbox\"]],\n            *[str(x) for x in mask_data[\"point_coords\"][0]],\n            str(mask_data[\"predicted_iou\"]),\n            str(mask_data[\"stability_score\"]),\n            *[str(x) for x in mask_data[\"crop_box\"]],\n        ]\n        row = \",\".join(mask_metadata)\n        metadata.append(row)\n    metadata_path = os.path.join(path, \"metadata.csv\")\n    with open(metadata_path, \"w\") as f:\n        f.write(\"\\n\".join(metadata))\n\n    return", "\ndef write_masks_to_folder(masks: List[Dict[str, Any]], path: str) -> None:\n    header = (\n        \"id,area,bbox_x0,bbox_y0,bbox_w,bbox_h,\"\n        \"point_input_x,point_input_y,predicted_iou,\"\n        \"stability_score,crop_box_x0,crop_box_y0,\"\n        \"crop_box_w,crop_box_h\"\n    )\n    metadata = [header]\n    for i, mask_data in enumerate(masks):\n        mask = mask_data[\"segmentation\"]\n        filename = f\"{i}.png\"\n        cv2.imwrite(os.path.join(path, filename), mask * 255)\n        mask_metadata = [\n            str(i),\n            str(mask_data[\"area\"]),\n            *[str(x) for x in mask_data[\"bbox\"]],\n            *[str(x) for x in mask_data[\"point_coords\"][0]],\n            str(mask_data[\"predicted_iou\"]),\n            str(mask_data[\"stability_score\"]),\n            *[str(x) for x in mask_data[\"crop_box\"]],\n        ]\n        row = \",\".join(mask_metadata)\n        metadata.append(row)\n    metadata_path = os.path.join(path, \"metadata.csv\")\n    with open(metadata_path, \"w\") as f:\n        f.write(\"\\n\".join(metadata))\n\n    return", "\n\ndef get_amg_kwargs(args):\n    amg_kwargs = {\n        \"points_per_side\": args.points_per_side,\n        \"points_per_batch\": args.points_per_batch,\n        \"pred_iou_thresh\": args.pred_iou_thresh,\n        \"stability_score_thresh\": args.stability_score_thresh,\n        \"stability_score_offset\": args.stability_score_offset,\n        \"box_nms_thresh\": args.box_nms_thresh,\n        \"crop_n_layers\": args.crop_n_layers,\n        \"crop_nms_thresh\": args.crop_nms_thresh,\n        \"crop_overlap_ratio\": args.crop_overlap_ratio,\n        \"crop_n_points_downscale_factor\": args.crop_n_points_downscale_factor,\n        \"min_mask_region_area\": args.min_mask_region_area,\n    }\n    amg_kwargs = {k: v for k, v in amg_kwargs.items() if v is not None}\n    return amg_kwargs", "\n\ndef main(args: argparse.Namespace) -> None:\n    print(\"Loading model...\")\n    sam = sam_model_registry[args.model_type](checkpoint=args.checkpoint)\n    _ = sam.to(device=args.device)\n    output_mode = \"coco_rle\" if args.convert_to_rle else \"binary_mask\"\n    amg_kwargs = get_amg_kwargs(args)\n    generator = SamAutomaticMaskGenerator(sam, output_mode=output_mode, **amg_kwargs)\n\n    if not os.path.isdir(args.input):\n        targets = [args.input]\n    else:\n        targets = [\n            f\n            for f in os.listdir(args.input)\n            if not os.path.isdir(os.path.join(args.input, f))\n        ]\n        targets = [os.path.join(args.input, f) for f in targets]\n\n    os.makedirs(args.output, exist_ok=True)\n\n    for t in targets:\n        print(f\"Processing '{t}'...\")\n        image = cv2.imread(t)\n        if image is None:\n            print(f\"Could not load '{t}' as an image, skipping...\")\n            continue\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n\n        masks = generator.generate(image)\n\n        base = os.path.basename(t)\n        base = os.path.splitext(base)[0]\n        save_base = os.path.join(args.output, base)\n        if output_mode == \"binary_mask\":\n            os.makedirs(save_base, exist_ok=False)\n            write_masks_to_folder(masks, save_base)\n        else:\n            save_file = save_base + \".json\"\n            with open(save_file, \"w\") as f:\n                json.dump(masks, f)\n    print(\"Done!\")", "\n\nif __name__ == \"__main__\":\n    args = parser.parse_args()\n    main(args)\n"]}
{"filename": "metaseg/sahi_predictor.py", "chunked_list": ["from typing import Union\n\nimport cv2\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport torch\nfrom cv2 import Mat\nfrom PIL import Image\n\nfrom metaseg.generator import SamPredictor, sam_model_registry", "\nfrom metaseg.generator import SamPredictor, sam_model_registry\nfrom metaseg.utils import (\n    download_model,\n    load_image,\n    multi_boxes,\n    plt_load_box,\n    plt_load_mask,\n)\n", ")\n\n\ndef sahi_sliced_predict(\n    image_path,\n    detection_model_type,\n    detection_model_path,\n    conf_th,\n    image_size,\n    slice_height,\n    slice_width,\n    overlap_height_ratio,\n    overlap_width_ratio,\n):\n    try:\n        from sahi import AutoDetectionModel\n        from sahi.predict import get_prediction, get_sliced_prediction\n    except ImportError:\n        raise ImportError(\"Please install SAHI library using 'pip install sahi'.\")\n\n    device = \"cuda\" if torch.cuda.is_available() else \"cpu\"\n\n    detection_model = AutoDetectionModel.from_pretrained(\n        image_size=image_size,\n        model_type=detection_model_type,\n        model_path=detection_model_path,\n        confidence_threshold=conf_th,\n        device=device,\n    )\n    result = get_sliced_prediction(\n        image_path,\n        detection_model,\n        slice_height=slice_height,\n        slice_width=slice_width,\n        overlap_height_ratio=overlap_height_ratio,\n        overlap_width_ratio=overlap_width_ratio,\n    )\n\n    result = get_prediction(image_path, detection_model)\n    output = result.object_prediction_list\n    boxes = []\n    for i in output:\n        boxes.append(i.bbox.to_xyxy())\n\n    return boxes", "\n\nclass SahiAutoSegmentation:\n    def __init__(self):\n        self.model = None\n        self.device = \"cuda\" if torch.cuda.is_available() else \"cpu\"\n\n    def load_model(self, model_type):\n        if self.model is None:\n            self.model_path = download_model(model_type)\n            self.model = sam_model_registry[model_type](checkpoint=self.model_path)\n            self.model.to(device=self.device)\n\n        return self.model\n\n    def image_predict(\n        self,\n        source: Union[str, Mat],\n        model_type,\n        input_box=None,\n        input_point=None,\n        input_label=None,\n        multimask_output=False,\n        random_color=False,\n        show=False,\n        save=False,\n    ):\n        read_image = load_image(source)\n        model = self.load_model(model_type)\n        predictor = SamPredictor(model)\n        predictor.set_image(read_image)\n\n        if type(input_box[0]) == list:\n            input_boxes, new_boxes = multi_boxes(input_box, predictor, read_image)\n\n            masks, _, _ = predictor.predict_torch(\n                point_coords=None,\n                point_labels=None,\n                boxes=new_boxes,\n                multimask_output=False,\n            )\n\n        elif type(input_box[0]) == int:\n            input_boxes = np.array(input_box)[None, :]\n\n            masks, _, _ = predictor.predict(\n                point_coords=input_point,\n                point_labels=input_label,\n                box=input_boxes,\n                multimask_output=multimask_output,\n            )\n\n        plt.figure(figsize=(10, 10))\n        plt.imshow(read_image)\n        for mask in masks:\n            plt_load_mask(mask.cpu().numpy(), plt.gca(), random_color=random_color)\n        for box in input_boxes:\n            plt_load_box(box.cpu().numpy(), plt.gca())\n        plt.axis(\"off\")\n        if save:\n            plt.savefig(\"output.png\", bbox_inches=\"tight\")\n            output_image = cv2.imread(\"output.png\")\n            output_image = Image.fromarray(output_image)\n            return output_image\n        if show:\n            plt.show()\n\n        return masks", ""]}
{"filename": "metaseg/sam_predictor.py", "chunked_list": ["from typing import Union\n\nimport cv2\nimport numpy as np\nimport torch\nfrom cv2 import Mat\nfrom tqdm import tqdm\n\nfrom metaseg.generator.automatic_mask_generator import SamAutomaticMaskGenerator\nfrom metaseg.generator.build_sam import sam_model_registry", "from metaseg.generator.automatic_mask_generator import SamAutomaticMaskGenerator\nfrom metaseg.generator.build_sam import sam_model_registry\nfrom metaseg.generator.predictor import SamPredictor\nfrom metaseg.utils import (\n    download_model,\n    load_box,\n    load_image,\n    load_mask,\n    load_video,\n    multi_boxes,", "    load_video,\n    multi_boxes,\n    show_image,\n)\n\n\nclass SegAutoMaskPredictor:\n    def __init__(self):\n        self.model = None\n        self.device = \"cuda\" if torch.cuda.is_available() else \"cpu\"\n\n    def load_model(self, model_type):\n        if self.model is None:\n            self.model_path = download_model(model_type)\n            self.model = sam_model_registry[model_type](checkpoint=self.model_path)\n            self.model.to(device=self.device)\n\n        return self.model\n\n    def image_predict(\n        self,\n        source: Union[str, Mat],\n        model_type,\n        points_per_side,\n        points_per_batch,\n        min_area,\n        output_path=\"output.png\",\n        show=False,\n        save=False,\n    ):\n        read_image = load_image(source)\n        model = self.load_model(model_type)\n        mask_generator = SamAutomaticMaskGenerator(\n            model,\n            points_per_side=points_per_side,\n            points_per_batch=points_per_batch,\n            min_mask_region_area=min_area,\n        )\n\n        masks = mask_generator.generate(read_image)\n\n        sorted_anns = sorted(masks, key=(lambda x: x[\"area\"]), reverse=True)\n        mask_image = np.zeros(\n            (masks[0][\"segmentation\"].shape[0], masks[0][\"segmentation\"].shape[1], 3),\n            dtype=np.uint8,\n        )\n        colors = np.random.randint(0, 255, size=(256, 3), dtype=np.uint8)\n        for i, ann in enumerate(sorted_anns):\n            m = ann[\"segmentation\"]\n            img = np.ones((m.shape[0], m.shape[1], 3), dtype=np.uint8)\n            color = colors[i % 256]\n            for i in range(3):\n                img[:, :, 0] = color[0]\n                img[:, :, 1] = color[1]\n                img[:, :, 2] = color[2]\n            img = cv2.bitwise_and(img, img, mask=m.astype(np.uint8))\n            img = cv2.addWeighted(img, 0.35, np.zeros_like(img), 0.65, 0)\n            mask_image = cv2.add(mask_image, img)\n\n        combined_mask = cv2.add(read_image, mask_image)\n        self.combined_mask = combined_mask\n        if show:\n            show_image(combined_mask)\n\n        if save:\n            cv2.imwrite(output_path, combined_mask)\n\n        return masks\n\n    def video_predict(\n        self,\n        source,\n        model_type,\n        points_per_side,\n        points_per_batch,\n        min_area,\n        output_path=\"output.mp4\",\n    ):\n        cap, out = load_video(source, output_path)\n        length = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))\n        colors = np.random.randint(0, 255, size=(256, 3), dtype=np.uint8)\n\n        for _ in tqdm(range(length)):\n            ret, frame = cap.read()\n            if not ret:\n                break\n\n            model = self.load_model(model_type)\n            mask_generator = SamAutomaticMaskGenerator(\n                model,\n                points_per_side=points_per_side,\n                points_per_batch=points_per_batch,\n                min_mask_region_area=min_area,\n            )\n            masks = mask_generator.generate(frame)\n\n            if len(masks) == 0:\n                continue\n\n            sorted_anns = sorted(masks, key=(lambda x: x[\"area\"]), reverse=True)\n            mask_image = np.zeros(\n                (\n                    masks[0][\"segmentation\"].shape[0],\n                    masks[0][\"segmentation\"].shape[1],\n                    3,\n                ),\n                dtype=np.uint8,\n            )\n\n            for i, ann in enumerate(sorted_anns):\n                m = ann[\"segmentation\"]\n                color = colors[i % 256]\n                img = np.zeros((m.shape[0], m.shape[1], 3), dtype=np.uint8)\n                img[:, :, 0] = color[0]\n                img[:, :, 1] = color[1]\n                img[:, :, 2] = color[2]\n                img = cv2.bitwise_and(img, img, mask=m.astype(np.uint8))\n                img = cv2.addWeighted(img, 0.35, np.zeros_like(img), 0.65, 0)\n                mask_image = cv2.add(mask_image, img)\n\n            combined_mask = cv2.add(frame, mask_image)\n            out.write(combined_mask)\n\n        out.release()\n        cap.release()\n        cv2.destroyAllWindows()\n\n        return output_path", "\n\nclass SegManualMaskPredictor:\n    def __init__(self):\n        self.model = None\n        self.device = \"cuda\" if torch.cuda.is_available() else \"cpu\"\n\n    def load_model(self, model_type):\n        if self.model is None:\n            self.model_path = download_model(model_type)\n            self.model = sam_model_registry[model_type](checkpoint=self.model_path)\n            self.model.to(device=self.device)\n\n        return self.model\n\n    def image_predict(\n        self,\n        source: Union[str, Mat],\n        model_type,\n        input_box=None,\n        input_point=None,\n        input_label=None,\n        multimask_output=False,\n        output_path=\"output.png\",\n        random_color=False,\n        show=False,\n        save=False,\n    ):\n        image = load_image(source)\n        model = self.load_model(model_type)\n        predictor = SamPredictor(model)\n        predictor.set_image(image)\n\n        if type(input_box[0]) == list:\n            input_boxes, new_boxes = multi_boxes(input_box, predictor, image)\n\n            masks, _, _ = predictor.predict_torch(\n                point_coords=None,\n                point_labels=None,\n                boxes=new_boxes,\n                multimask_output=False,\n            )\n            for mask in masks:\n                mask_image = load_mask(mask.cpu().numpy(), random_color)\n\n            for box in input_boxes:\n                image = load_box(box.cpu().numpy(), image)\n\n        elif type(input_box[0]) == int:\n            input_boxes = np.array(input_box)[None, :]\n\n            masks, _, _ = predictor.predict(\n                point_coords=input_point,\n                point_labels=input_label,\n                box=input_boxes,\n                multimask_output=multimask_output,\n            )\n            mask_image = load_mask(masks, random_color)\n            image = load_box(input_box, image)\n\n        combined_mask = cv2.add(image, mask_image)\n        if save:\n            cv2.imwrite(output_path, combined_mask)\n\n        if show:\n            show_image(combined_mask)\n\n        return masks\n\n    def video_predict(\n        self,\n        source,\n        model_type,\n        input_box=None,\n        input_point=None,\n        input_label=None,\n        multimask_output=False,\n        output_path=\"output.mp4\",\n        random_color=False,\n    ):\n        cap, out = load_video(source, output_path)\n        length = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))\n\n        for _ in tqdm(range(length)):\n            ret, frame = cap.read()\n            if not ret:\n                break\n\n            model = self.load_model(model_type)\n            predictor = SamPredictor(model)\n            predictor.set_image(frame)\n\n            if type(input_box[0]) == list:\n                input_boxes, new_boxes = multi_boxes(input_box, predictor, frame)\n\n                masks, _, _ = predictor.predict_torch(\n                    point_coords=None,\n                    point_labels=None,\n                    boxes=new_boxes,\n                    multimask_output=False,\n                )\n                for mask in masks:\n                    mask_image = load_mask(mask.cpu().numpy(), random_color)\n\n                for box in input_boxes:\n                    frame = load_box(box.cpu().numpy(), frame)\n\n            elif type(input_box[0]) == int:\n                input_boxes = np.array(input_box)[None, :]\n\n                masks, _, _ = predictor.predict(\n                    point_coords=input_point,\n                    point_labels=input_label,\n                    box=input_boxes,\n                    multimask_output=multimask_output,\n                )\n                mask_image = load_mask(masks, random_color)\n                frame = load_box(input_box, frame)\n\n            combined_mask = cv2.add(frame, mask_image)\n            out.write(combined_mask)\n\n        out.release()\n        cap.release()\n        cv2.destroyAllWindows()\n        return output_path", ""]}
{"filename": "metaseg/__init__.py", "chunked_list": ["# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom .falai_predictor import automask_image as automask_image\nfrom .falai_predictor import falai_automask_image as falai_automask_image\nfrom .falai_predictor import falai_manuelmask_image as falai_manuelmask_image\nfrom .falai_predictor import manuelmask_image as manuelmask_image", "from .falai_predictor import falai_manuelmask_image as falai_manuelmask_image\nfrom .falai_predictor import manuelmask_image as manuelmask_image\nfrom .sahi_predictor import SahiAutoSegmentation as SahiAutoSegmentation\nfrom .sahi_predictor import sahi_sliced_predict as sahi_sliced_predict\nfrom .sam_predictor import SegAutoMaskPredictor as SegAutoMaskPredictor\nfrom .sam_predictor import SegManualMaskPredictor as SegManualMaskPredictor\n\n__version__ = \"0.7.8\"\n", ""]}
{"filename": "metaseg/falai_predictor.py", "chunked_list": ["from io import BytesIO\n\nfrom PIL import Image\n\nfrom .sam_predictor import SegAutoMaskPredictor, SegManualMaskPredictor\nfrom .utils.data_utils import load_server_image\n\ntry:\n    from fal_serverless import isolated\nexcept ImportError:\n    raise ImportError(\n        \"Please install FalAI library using 'pip install fal_serverless'.\"\n    )", "\n\n@isolated(requirements=[\"metaseg\"], keep_alive=1800, machine_type=\"GPU-T4\")\ndef automask_image(\n    data, model_type=\"vit_b\", points_per_side=16, points_per_batch=32, min_area=0\n):\n    image_path, output_path = load_server_image(data)\n    SegAutoMaskPredictor().image_predict(\n        source=image_path,\n        model_type=model_type,\n        points_per_side=points_per_side,\n        points_per_batch=points_per_batch,\n        min_area=min_area,\n        output_path=output_path,\n        show=False,\n        save=True,\n    )\n    with open(output_path, \"rb\") as f:\n        result = f.read()\n\n    return result", "\n\n@isolated(requirements=[\"metaseg\"], keep_alive=1800, machine_type=\"GPU-T4\")\ndef manuelmask_image(\n    data,\n    model_type=\"vit_b\",\n    input_point=[[100, 100], [200, 200]],\n    input_label=[0, 1],\n    input_box=[100, 100, 200, 200],\n    multimask_output=False,\n    random_color=False,\n    min_area=0,\n):\n    image_path, output_path = load_server_image(data)\n    SegManualMaskPredictor().image_predict(\n        source=image_path,\n        model_type=model_type,\n        input_point=input_point,\n        input_label=input_label,\n        input_box=input_box,  #\n        multimask_output=multimask_output,\n        random_color=random_color,\n        min_area=min_area,  #\n        output_path=output_path,\n        show=False,\n        save=True,\n    )\n    with open(output_path, \"rb\") as f:\n        result = f.read()\n\n    return result", "\n\ndef falai_automask_image(\n    image_path, model_type=\"vit_b\", points_per_side=16, points_per_batch=32, min_area=0\n):\n    with open(image_path, \"rb\") as f:\n        data = f.read()\n\n    image = automask_image(\n        data=data,\n        model_type=model_type,\n        points_per_side=points_per_side,\n        points_per_batch=points_per_batch,\n        min_area=min_area,\n    )\n    image = Image.open(BytesIO(image))\n    return image", "\n\ndef falai_manuelmask_image(\n    image_path,\n    model_type=\"vit_b\",\n    input_point=[[100, 100], [200, 200]],\n    input_label=[0, 1],\n    input_box=[100, 100, 200, 200],\n    multimask_output=False,\n    random_color=False,\n    min_area=0,\n):\n    with open(image_path, \"rb\") as f:\n        data = f.read()\n\n    image = manuelmask_image(\n        data=data,\n        model_type=model_type,\n        input_point=input_point,\n        input_label=input_label,\n        input_box=input_box,\n        multimask_output=multimask_output,\n        random_color=random_color,\n        min_area=min_area,\n    )\n    image = Image.open(BytesIO(image))\n    return image", ""]}
{"filename": "metaseg/modeling/prompt_encoder.py", "chunked_list": ["# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom typing import Any, Optional, Tuple, Type\n\nimport numpy as np\nimport torch", "import numpy as np\nimport torch\nfrom torch import nn\n\nfrom metaseg.modeling.common import LayerNorm2d\n\n\nclass PromptEncoder(nn.Module):\n    def __init__(\n        self,\n        embed_dim: int,\n        image_embedding_size: Tuple[int, int],\n        input_image_size: Tuple[int, int],\n        mask_in_chans: int,\n        activation: Type[nn.Module] = nn.GELU,\n    ) -> None:\n        \"\"\"\n        Encodes prompts for input to SAM's mask decoder.\n\n        Arguments:\n          embed_dim (int): The prompts' embedding dimension\n          image_embedding_size (tuple(int, int)): The spatial size of the\n            image embedding, as (H, W).\n          input_image_size (int): The padded size of the image as input\n            to the image encoder, as (H, W).\n          mask_in_chans (int): The number of hidden channels used for\n            encoding input masks.\n          activation (nn.Module): The activation to use when encoding\n            input masks.\n        \"\"\"\n        super().__init__()\n        self.embed_dim = embed_dim\n        self.input_image_size = input_image_size\n        self.image_embedding_size = image_embedding_size\n        self.pe_layer = PositionEmbeddingRandom(embed_dim // 2)\n\n        self.num_point_embeddings: int = 4  # pos/neg point + 2 box corners\n        point_embeddings = [\n            nn.Embedding(1, embed_dim) for i in range(self.num_point_embeddings)\n        ]\n        self.point_embeddings = nn.ModuleList(point_embeddings)\n        self.not_a_point_embed = nn.Embedding(1, embed_dim)\n\n        self.mask_input_size = (\n            4 * image_embedding_size[0],\n            4 * image_embedding_size[1],\n        )\n        self.mask_downscaling = nn.Sequential(\n            nn.Conv2d(1, mask_in_chans // 4, kernel_size=2, stride=2),\n            LayerNorm2d(mask_in_chans // 4),\n            activation(),\n            nn.Conv2d(mask_in_chans // 4, mask_in_chans, kernel_size=2, stride=2),\n            LayerNorm2d(mask_in_chans),\n            activation(),\n            nn.Conv2d(mask_in_chans, embed_dim, kernel_size=1),\n        )\n        self.no_mask_embed = nn.Embedding(1, embed_dim)\n\n    def get_dense_pe(self) -> torch.Tensor:\n        \"\"\"\n        Returns the positional encoding used to encode point prompts,\n        applied to a dense set of points the shape of the image encoding.\n\n        Returns:\n          torch.Tensor: Positional encoding with shape\n            1x(embed_dim)x(embedding_h)x(embedding_w)\n        \"\"\"\n        return self.pe_layer(self.image_embedding_size).unsqueeze(0)\n\n    def _embed_points(\n        self,\n        points: torch.Tensor,\n        labels: torch.Tensor,\n        pad: bool,\n    ) -> torch.Tensor:\n        \"\"\"Embeds point prompts.\"\"\"\n        points = points + 0.5  # Shift to center of pixel\n        if pad:\n            padding_point = torch.zeros((points.shape[0], 1, 2), device=points.device)\n            padding_label = -torch.ones((labels.shape[0], 1), device=labels.device)\n            points = torch.cat([points, padding_point], dim=1)\n            labels = torch.cat([labels, padding_label], dim=1)\n        point_embedding = self.pe_layer.forward_with_coords(\n            points, self.input_image_size\n        )\n        point_embedding[labels == -1] = 0.0\n        point_embedding[labels == -1] += self.not_a_point_embed.weight\n        point_embedding[labels == 0] += self.point_embeddings[0].weight\n        point_embedding[labels == 1] += self.point_embeddings[1].weight\n        return point_embedding\n\n    def _embed_boxes(self, boxes: torch.Tensor) -> torch.Tensor:\n        \"\"\"Embeds box prompts.\"\"\"\n        boxes = boxes + 0.5  # Shift to center of pixel\n        coords = boxes.reshape(-1, 2, 2)\n        corner_embedding = self.pe_layer.forward_with_coords(\n            coords, self.input_image_size\n        )\n        corner_embedding[:, 0, :] += self.point_embeddings[2].weight\n        corner_embedding[:, 1, :] += self.point_embeddings[3].weight\n        return corner_embedding\n\n    def _embed_masks(self, masks: torch.Tensor) -> torch.Tensor:\n        \"\"\"Embeds mask inputs.\"\"\"\n        mask_embedding = self.mask_downscaling(masks)\n        return mask_embedding\n\n    def _get_batch_size(\n        self,\n        points: Optional[Tuple[torch.Tensor, torch.Tensor]],\n        boxes: Optional[torch.Tensor],\n        masks: Optional[torch.Tensor],\n    ) -> int:\n        \"\"\"\n        Gets the batch size of the output given the batch size of the input prompts.\n        \"\"\"\n        if points is not None:\n            return points[0].shape[0]\n        elif boxes is not None:\n            return boxes.shape[0]\n        elif masks is not None:\n            return masks.shape[0]\n        else:\n            return 1\n\n    def _get_device(self) -> torch.device:\n        return self.point_embeddings[0].weight.device\n\n    def forward(\n        self,\n        points: Optional[Tuple[torch.Tensor, torch.Tensor]],\n        boxes: Optional[torch.Tensor],\n        masks: Optional[torch.Tensor],\n    ) -> Tuple[torch.Tensor, torch.Tensor]:\n        \"\"\"\n        Embeds different types of prompts, returning both sparse and dense\n        embeddings.\n\n        Arguments:\n          points (tuple(torch.Tensor, torch.Tensor) or none): point coordinates\n            and labels to embed.\n          boxes (torch.Tensor or none): boxes to embed\n          masks (torch.Tensor or none): masks to embed\n\n        Returns:\n          torch.Tensor: sparse embeddings for the points and boxes, with shape\n            BxNx(embed_dim), where N is determined by the number of input points\n            and boxes.\n          torch.Tensor: dense embeddings for the masks, in the shape\n            Bx(embed_dim)x(embed_H)x(embed_W)\n        \"\"\"\n        bs = self._get_batch_size(points, boxes, masks)\n        sparse_embeddings = torch.empty(\n            (bs, 0, self.embed_dim), device=self._get_device()\n        )\n        if points is not None:\n            coords, labels = points\n            point_embeddings = self._embed_points(coords, labels, pad=(boxes is None))\n            sparse_embeddings = torch.cat([sparse_embeddings, point_embeddings], dim=1)\n        if boxes is not None:\n            box_embeddings = self._embed_boxes(boxes)\n            sparse_embeddings = torch.cat([sparse_embeddings, box_embeddings], dim=1)\n\n        if masks is not None:\n            dense_embeddings = self._embed_masks(masks)\n        else:\n            dense_embeddings = self.no_mask_embed.weight.reshape(1, -1, 1, 1).expand(\n                bs, -1, self.image_embedding_size[0], self.image_embedding_size[1]\n            )\n\n        return sparse_embeddings, dense_embeddings", "\n\nclass PositionEmbeddingRandom(nn.Module):\n    \"\"\"\n    Positional encoding using random spatial frequencies.\n    \"\"\"\n\n    def __init__(self, num_pos_feats: int = 64, scale: Optional[float] = None) -> None:\n        super().__init__()\n        if scale is None or scale <= 0.0:\n            scale = 1.0\n        self.register_buffer(\n            \"positional_encoding_gaussian_matrix\",\n            scale * torch.randn((2, num_pos_feats)),\n        )\n\n    def _pe_encoding(self, coords: torch.Tensor) -> torch.Tensor:\n        \"\"\"Positionally encode points that are normalized to [0,1].\"\"\"\n        # assuming coords are in [0, 1]^2 square and have d_1 x ... x d_n x 2 shape\n        coords = 2 * coords - 1\n        coords = coords @ self.positional_encoding_gaussian_matrix\n        coords = 2 * np.pi * coords\n        # outputs d_1 x ... x d_n x C shape\n        return torch.cat([torch.sin(coords), torch.cos(coords)], dim=-1)\n\n    def forward(self, size: Tuple[int, int]) -> torch.Tensor:\n        \"\"\"Generate positional encoding for a grid of the specified size.\"\"\"\n        h, w = size\n        device: Any = self.positional_encoding_gaussian_matrix.device\n        grid = torch.ones((h, w), device=device, dtype=torch.float32)\n        y_embed = grid.cumsum(dim=0) - 0.5\n        x_embed = grid.cumsum(dim=1) - 0.5\n        y_embed = y_embed / h\n        x_embed = x_embed / w\n\n        pe = self._pe_encoding(torch.stack([x_embed, y_embed], dim=-1))\n        return pe.permute(2, 0, 1)  # C x H x W\n\n    def forward_with_coords(\n        self, coords_input: torch.Tensor, image_size: Tuple[int, int]\n    ) -> torch.Tensor:\n        \"\"\"Positionally encode points that are not normalized to [0,1].\"\"\"\n        coords = coords_input.clone()\n        coords[:, :, 0] = coords[:, :, 0] / image_size[1]\n        coords[:, :, 1] = coords[:, :, 1] / image_size[0]\n        return self._pe_encoding(coords.to(torch.float))  # B x N x C", ""]}
{"filename": "metaseg/modeling/mask_decoder.py", "chunked_list": ["# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom typing import List, Tuple, Type\n\nimport torch\nfrom torch import nn", "import torch\nfrom torch import nn\nfrom torch.nn import functional as F\n\nfrom metaseg.modeling.common import LayerNorm2d\n\n\nclass MaskDecoder(nn.Module):\n    def __init__(\n        self,\n        *,\n        transformer_dim: int,\n        transformer: nn.Module,\n        num_multimask_outputs: int = 3,\n        activation: Type[nn.Module] = nn.GELU,\n        iou_head_depth: int = 3,\n        iou_head_hidden_dim: int = 256,\n    ) -> None:\n        \"\"\"\n        Predicts masks given an image and prompt embeddings, using a\n        tranformer architecture.\n\n        Arguments:\n          transformer_dim (int): the channel dimension of the transformer\n          transformer (nn.Module): the transformer used to predict masks\n          num_multimask_outputs (int): the number of masks to predict\n            when disambiguating masks\n          activation (nn.Module): the type of activation to use when\n            upscaling masks\n          iou_head_depth (int): the depth of the MLP used to predict\n            mask quality\n          iou_head_hidden_dim (int): the hidden dimension of the MLP\n            used to predict mask quality\n        \"\"\"\n        super().__init__()\n        self.transformer_dim = transformer_dim\n        self.transformer = transformer\n\n        self.num_multimask_outputs = num_multimask_outputs\n\n        self.iou_token = nn.Embedding(1, transformer_dim)\n        self.num_mask_tokens = num_multimask_outputs + 1\n        self.mask_tokens = nn.Embedding(self.num_mask_tokens, transformer_dim)\n\n        self.output_upscaling = nn.Sequential(\n            nn.ConvTranspose2d(\n                transformer_dim, transformer_dim // 4, kernel_size=2, stride=2\n            ),\n            LayerNorm2d(transformer_dim // 4),\n            activation(),\n            nn.ConvTranspose2d(\n                transformer_dim // 4, transformer_dim // 8, kernel_size=2, stride=2\n            ),\n            activation(),\n        )\n        self.output_hypernetworks_mlps = nn.ModuleList(\n            [\n                MLP(transformer_dim, transformer_dim, transformer_dim // 8, 3)\n                for i in range(self.num_mask_tokens)\n            ]\n        )\n\n        self.iou_prediction_head = MLP(\n            transformer_dim, iou_head_hidden_dim, self.num_mask_tokens, iou_head_depth\n        )\n\n    def forward(\n        self,\n        image_embeddings: torch.Tensor,\n        image_pe: torch.Tensor,\n        sparse_prompt_embeddings: torch.Tensor,\n        dense_prompt_embeddings: torch.Tensor,\n        multimask_output: bool,\n    ) -> Tuple[torch.Tensor, torch.Tensor]:\n        \"\"\"\n        Predict masks given image and prompt embeddings.\n\n        Arguments:\n          image_embeddings (torch.Tensor): the embeddings from the image encoder\n          image_pe (torch.Tensor): positional encoding\n            with the shape of image_embeddings\n          sparse_prompt_embeddings (torch.Tensor): the embeddings\n            of the points and boxes\n          dense_prompt_embeddings (torch.Tensor): the embeddings\n            of the mask inputs\n          multimask_output (bool): Whether to return\n            multiple masks or a single mask.\n\n        Returns:\n          torch.Tensor: batched predicted masks\n          torch.Tensor: batched predictions of mask quality\n        \"\"\"\n        masks, iou_pred = self.predict_masks(\n            image_embeddings=image_embeddings,\n            image_pe=image_pe,\n            sparse_prompt_embeddings=sparse_prompt_embeddings,\n            dense_prompt_embeddings=dense_prompt_embeddings,\n        )\n\n        # Select the correct mask or masks for outptu\n        if multimask_output:\n            mask_slice = slice(1, None)\n        else:\n            mask_slice = slice(0, 1)\n        masks = masks[:, mask_slice, :, :]\n        iou_pred = iou_pred[:, mask_slice]\n\n        # Prepare output\n        return masks, iou_pred\n\n    def predict_masks(\n        self,\n        image_embeddings: torch.Tensor,\n        image_pe: torch.Tensor,\n        sparse_prompt_embeddings: torch.Tensor,\n        dense_prompt_embeddings: torch.Tensor,\n    ) -> Tuple[torch.Tensor, torch.Tensor]:\n        \"\"\"Predicts masks. See 'forward' for more details.\"\"\"\n        # Concatenate output tokens\n        output_tokens = torch.cat(\n            [self.iou_token.weight, self.mask_tokens.weight], dim=0\n        )\n        output_tokens = output_tokens.unsqueeze(0).expand(\n            sparse_prompt_embeddings.size(0), -1, -1\n        )\n        tokens = torch.cat((output_tokens, sparse_prompt_embeddings), dim=1)\n\n        # Expand per-image data in batch direction to be per-mask\n        src = torch.repeat_interleave(image_embeddings, tokens.shape[0], dim=0)\n        src = src + dense_prompt_embeddings\n        pos_src = torch.repeat_interleave(image_pe, tokens.shape[0], dim=0)\n        b, c, h, w = src.shape\n\n        # Run the transformer\n        hs, src = self.transformer(src, pos_src, tokens)\n        iou_token_out = hs[:, 0, :]\n        mask_tokens_out = hs[:, 1 : (1 + self.num_mask_tokens), :]\n\n        # Upscale mask embeddings and predict masks using the mask tokens\n        src = src.transpose(1, 2).view(b, c, h, w)\n        upscaled_embedding = self.output_upscaling(src)\n        hyper_in_list: List[torch.Tensor] = []\n        for i in range(self.num_mask_tokens):\n            hyper_in_list.append(\n                self.output_hypernetworks_mlps[i](mask_tokens_out[:, i, :])\n            )\n        hyper_in = torch.stack(hyper_in_list, dim=1)\n        b, c, h, w = upscaled_embedding.shape\n        masks = (hyper_in @ upscaled_embedding.view(b, c, h * w)).view(b, -1, h, w)\n\n        # Generate mask quality predictions\n        iou_pred = self.iou_prediction_head(iou_token_out)\n\n        return masks, iou_pred", "\n\n# Lightly adapted from\n# https://github.com/facebookresearch/MaskFormer/blob/main/mask_former/modeling/transformer/transformer_predictor.py # noqa\nclass MLP(nn.Module):\n    def __init__(\n        self,\n        input_dim: int,\n        hidden_dim: int,\n        output_dim: int,\n        num_layers: int,\n        sigmoid_output: bool = False,\n    ) -> None:\n        super().__init__()\n        self.num_layers = num_layers\n        h = [hidden_dim] * (num_layers - 1)\n        self.layers = nn.ModuleList(\n            nn.Linear(n, k) for n, k in zip([input_dim] + h, h + [output_dim])\n        )\n        self.sigmoid_output = sigmoid_output\n\n    def forward(self, x):\n        for i, layer in enumerate(self.layers):\n            x = F.relu(layer(x)) if i < self.num_layers - 1 else layer(x)\n        if self.sigmoid_output:\n            x = F.sigmoid(x)\n        return x", ""]}
{"filename": "metaseg/modeling/image_encoder.py", "chunked_list": ["# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom typing import Optional, Tuple, Type\n\nimport torch\nimport torch.nn as nn", "import torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nfrom metaseg.modeling.common import LayerNorm2d, MLPBlock\n\n\n# This class and its supporting functions below lightly adapted from the\n# ViTDet backbone available at:\n# https://github.com/facebookresearch/detectron2/blob/main/detectron2/modeling/backbone/vit.py\nclass ImageEncoderViT(nn.Module):\n    def __init__(\n        self,\n        img_size: int = 1024,\n        patch_size: int = 16,\n        in_chans: int = 3,\n        embed_dim: int = 768,\n        depth: int = 12,\n        num_heads: int = 12,\n        mlp_ratio: float = 4.0,\n        out_chans: int = 256,\n        qkv_bias: bool = True,\n        norm_layer: Type[nn.Module] = nn.LayerNorm,\n        act_layer: Type[nn.Module] = nn.GELU,\n        use_abs_pos: bool = True,\n        use_rel_pos: bool = False,\n        rel_pos_zero_init: bool = True,\n        window_size: int = 0,\n        global_attn_indexes: Tuple[int, ...] = (),\n    ) -> None:\n        \"\"\"\n        Args:\n            img_size (int): Input image size.\n            patch_size (int): Patch size.\n            in_chans (int): Number of input image channels.\n            embed_dim (int): Patch embedding dimension.\n            depth (int): Depth of ViT.\n            num_heads (int): Number of attention heads in each ViT block.\n            mlp_ratio (float): Ratio of mlp hidden dim to embedding dim.\n            qkv_bias (bool): If True, add a learnable bias to query, key, value.\n            norm_layer (nn.Module): Normalization layer.\n            act_layer (nn.Module): Activation layer.\n            use_abs_pos (bool): If True, use absolute\n                positional embeddings.\n            use_rel_pos (bool): If True, add relative\n                positional embeddings to the attention map.\n            rel_pos_zero_init (bool): If True, zero initialize\n                relative positional parameters.\n            window_size (int): Window size for window\n                attention blocks.\n            global_attn_indexes (list): Indexes for\n                blocks using global attention.\n        \"\"\"\n        super().__init__()\n        self.img_size = img_size\n\n        self.patch_embed = PatchEmbed(\n            kernel_size=(patch_size, patch_size),\n            stride=(patch_size, patch_size),\n            in_chans=in_chans,\n            embed_dim=embed_dim,\n        )\n\n        self.pos_embed: Optional[nn.Parameter] = None\n        if use_abs_pos:\n            # Initialize absolute positional embedding with pretrain image size.\n            self.pos_embed = nn.Parameter(\n                torch.zeros(\n                    1, img_size // patch_size, img_size // patch_size, embed_dim\n                )\n            )\n\n        self.blocks = nn.ModuleList()\n        for i in range(depth):\n            block = Block(\n                dim=embed_dim,\n                num_heads=num_heads,\n                mlp_ratio=mlp_ratio,\n                qkv_bias=qkv_bias,\n                norm_layer=norm_layer,\n                act_layer=act_layer,\n                use_rel_pos=use_rel_pos,\n                rel_pos_zero_init=rel_pos_zero_init,\n                window_size=window_size if i not in global_attn_indexes else 0,\n                input_size=(img_size // patch_size, img_size // patch_size),\n            )\n            self.blocks.append(block)\n\n        self.neck = nn.Sequential(\n            nn.Conv2d(\n                embed_dim,\n                out_chans,\n                kernel_size=1,\n                bias=False,\n            ),\n            LayerNorm2d(out_chans),\n            nn.Conv2d(\n                out_chans,\n                out_chans,\n                kernel_size=3,\n                padding=1,\n                bias=False,\n            ),\n            LayerNorm2d(out_chans),\n        )\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        x = self.patch_embed(x)\n        if self.pos_embed is not None:\n            x = x + self.pos_embed\n\n        for blk in self.blocks:\n            x = blk(x)\n\n        x = self.neck(x.permute(0, 3, 1, 2))\n\n        return x", "# ViTDet backbone available at:\n# https://github.com/facebookresearch/detectron2/blob/main/detectron2/modeling/backbone/vit.py\nclass ImageEncoderViT(nn.Module):\n    def __init__(\n        self,\n        img_size: int = 1024,\n        patch_size: int = 16,\n        in_chans: int = 3,\n        embed_dim: int = 768,\n        depth: int = 12,\n        num_heads: int = 12,\n        mlp_ratio: float = 4.0,\n        out_chans: int = 256,\n        qkv_bias: bool = True,\n        norm_layer: Type[nn.Module] = nn.LayerNorm,\n        act_layer: Type[nn.Module] = nn.GELU,\n        use_abs_pos: bool = True,\n        use_rel_pos: bool = False,\n        rel_pos_zero_init: bool = True,\n        window_size: int = 0,\n        global_attn_indexes: Tuple[int, ...] = (),\n    ) -> None:\n        \"\"\"\n        Args:\n            img_size (int): Input image size.\n            patch_size (int): Patch size.\n            in_chans (int): Number of input image channels.\n            embed_dim (int): Patch embedding dimension.\n            depth (int): Depth of ViT.\n            num_heads (int): Number of attention heads in each ViT block.\n            mlp_ratio (float): Ratio of mlp hidden dim to embedding dim.\n            qkv_bias (bool): If True, add a learnable bias to query, key, value.\n            norm_layer (nn.Module): Normalization layer.\n            act_layer (nn.Module): Activation layer.\n            use_abs_pos (bool): If True, use absolute\n                positional embeddings.\n            use_rel_pos (bool): If True, add relative\n                positional embeddings to the attention map.\n            rel_pos_zero_init (bool): If True, zero initialize\n                relative positional parameters.\n            window_size (int): Window size for window\n                attention blocks.\n            global_attn_indexes (list): Indexes for\n                blocks using global attention.\n        \"\"\"\n        super().__init__()\n        self.img_size = img_size\n\n        self.patch_embed = PatchEmbed(\n            kernel_size=(patch_size, patch_size),\n            stride=(patch_size, patch_size),\n            in_chans=in_chans,\n            embed_dim=embed_dim,\n        )\n\n        self.pos_embed: Optional[nn.Parameter] = None\n        if use_abs_pos:\n            # Initialize absolute positional embedding with pretrain image size.\n            self.pos_embed = nn.Parameter(\n                torch.zeros(\n                    1, img_size // patch_size, img_size // patch_size, embed_dim\n                )\n            )\n\n        self.blocks = nn.ModuleList()\n        for i in range(depth):\n            block = Block(\n                dim=embed_dim,\n                num_heads=num_heads,\n                mlp_ratio=mlp_ratio,\n                qkv_bias=qkv_bias,\n                norm_layer=norm_layer,\n                act_layer=act_layer,\n                use_rel_pos=use_rel_pos,\n                rel_pos_zero_init=rel_pos_zero_init,\n                window_size=window_size if i not in global_attn_indexes else 0,\n                input_size=(img_size // patch_size, img_size // patch_size),\n            )\n            self.blocks.append(block)\n\n        self.neck = nn.Sequential(\n            nn.Conv2d(\n                embed_dim,\n                out_chans,\n                kernel_size=1,\n                bias=False,\n            ),\n            LayerNorm2d(out_chans),\n            nn.Conv2d(\n                out_chans,\n                out_chans,\n                kernel_size=3,\n                padding=1,\n                bias=False,\n            ),\n            LayerNorm2d(out_chans),\n        )\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        x = self.patch_embed(x)\n        if self.pos_embed is not None:\n            x = x + self.pos_embed\n\n        for blk in self.blocks:\n            x = blk(x)\n\n        x = self.neck(x.permute(0, 3, 1, 2))\n\n        return x", "\n\nclass Block(nn.Module):\n    \"\"\"Transformer blocks with support of window\n    attention and residual propagation blocks\"\"\"\n\n    def __init__(\n        self,\n        dim: int,\n        num_heads: int,\n        mlp_ratio: float = 4.0,\n        qkv_bias: bool = True,\n        norm_layer: Type[nn.Module] = nn.LayerNorm,\n        act_layer: Type[nn.Module] = nn.GELU,\n        use_rel_pos: bool = False,\n        rel_pos_zero_init: bool = True,\n        window_size: int = 0,\n        input_size: Optional[Tuple[int, int]] = None,\n    ) -> None:\n        \"\"\"\n        Args:\n            dim (int): Number of input channels.\n            num_heads (int): Number of attention heads in each ViT block.\n            mlp_ratio (float): Ratio of mlp hidden dim to embedding dim.\n            qkv_bias (bool): If True, add a learnable bias to query, key, value.\n            norm_layer (nn.Module): Normalization layer.\n            act_layer (nn.Module): Activation layer.\n            use_rel_pos (bool): If True, add relative\n            positional embeddings to the attention map.\n            rel_pos_zero_init (bool): If True, zero\n            initialize relative positional parameters.\n            window_size (int): Window size for\n            window attention blocks. If it equals 0, then\n            use global attention.\n            input_size (int or None): Input resolution for\n            calculating the relative positional parameter size.\n        \"\"\"\n        super().__init__()\n        self.norm1 = norm_layer(dim)\n        self.attn = Attention(\n            dim,\n            num_heads=num_heads,\n            qkv_bias=qkv_bias,\n            use_rel_pos=use_rel_pos,\n            rel_pos_zero_init=rel_pos_zero_init,\n            input_size=input_size if window_size == 0 else (window_size, window_size),\n        )\n\n        self.norm2 = norm_layer(dim)\n        self.mlp = MLPBlock(\n            embedding_dim=dim, mlp_dim=int(dim * mlp_ratio), act=act_layer\n        )\n\n        self.window_size = window_size\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        shortcut = x\n        x = self.norm1(x)\n        # Window partition\n        if self.window_size > 0:\n            H, W = x.shape[1], x.shape[2]\n            x, pad_hw = window_partition(x, self.window_size)\n\n        x = self.attn(x)\n        # Reverse window partition\n        if self.window_size > 0:\n            x = window_unpartition(x, self.window_size, pad_hw, (H, W))\n\n        x = shortcut + x\n        x = x + self.mlp(self.norm2(x))\n\n        return x", "\n\nclass Attention(nn.Module):\n    \"\"\"Multi-head Attention block with relative position embeddings.\"\"\"\n\n    def __init__(\n        self,\n        dim: int,\n        num_heads: int = 8,\n        qkv_bias: bool = True,\n        use_rel_pos: bool = False,\n        rel_pos_zero_init: bool = True,\n        input_size: Optional[Tuple[int, int]] = None,\n    ) -> None:\n        \"\"\"\n        Args:\n            dim(int): Number of input channels.\n            num_heads(int): Number of attention heads.\n            qkv_bias(bool): If True, add a learnable\n                bias to query, key, value.\n            rel_pos(bool): If True, add relative\n                positional embeddings to the attention map.\n            rel_pos_zero_init(bool): If True, zero initialize\n                relative positional parameters.\n            input_size(int or None): Input resolution for\n                calculating the relative positional\n                parameter size.\n        \"\"\"\n        super().__init__()\n        self.num_heads = num_heads\n        head_dim = dim // num_heads\n        self.scale = head_dim**-0.5\n\n        self.qkv = nn.Linear(dim, dim * 3, bias=qkv_bias)\n        self.proj = nn.Linear(dim, dim)\n\n        self.use_rel_pos = use_rel_pos\n        if self.use_rel_pos:\n            assert (\n                input_size is not None\n            ), \"Input size must be provided if using relative positional encoding.\"\n            # initialize relative positional embeddings\n            self.rel_pos_h = nn.Parameter(torch.zeros(2 * input_size[0] - 1, head_dim))\n            self.rel_pos_w = nn.Parameter(torch.zeros(2 * input_size[1] - 1, head_dim))\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        B, H, W, _ = x.shape\n        # qkv with shape (3, B, nHead, H * W, C)\n        qkv = (\n            self.qkv(x).reshape(B, H * W, 3, self.num_heads, -1).permute(2, 0, 3, 1, 4)\n        )\n        # q, k, v with shape (B * nHead, H * W, C)\n        q, k, v = qkv.reshape(3, B * self.num_heads, H * W, -1).unbind(0)\n\n        attn = (q * self.scale) @ k.transpose(-2, -1)\n\n        if self.use_rel_pos:\n            attn = add_decomposed_rel_pos(\n                attn, q, self.rel_pos_h, self.rel_pos_w, (H, W), (H, W)\n            )\n\n        attn = attn.softmax(dim=-1)\n        x = (\n            (attn @ v)\n            .view(B, self.num_heads, H, W, -1)\n            .permute(0, 2, 3, 1, 4)\n            .reshape(B, H, W, -1)\n        )\n        x = self.proj(x)\n\n        return x", "\n\ndef window_partition(\n    x: torch.Tensor, window_size: int\n) -> Tuple[torch.Tensor, Tuple[int, int]]:\n    \"\"\"\n    Partition into non-overlapping windows with padding if needed.\n    Args:\n        x (tensor): input tokens with [B, H, W, C].\n        window_size (int): window size.\n\n    Returns:\n        windows: windows after partition with\n            [B * num_windows, window_size, window_size, C].\n        (Hp, Wp): padded height and width before partition\n    \"\"\"\n    B, H, W, C = x.shape\n\n    pad_h = (window_size - H % window_size) % window_size\n    pad_w = (window_size - W % window_size) % window_size\n    if pad_h > 0 or pad_w > 0:\n        x = F.pad(x, (0, 0, 0, pad_w, 0, pad_h))\n    Hp, Wp = H + pad_h, W + pad_w\n\n    x = x.view(B, Hp // window_size, window_size, Wp // window_size, window_size, C)\n    windows = (\n        x.permute(0, 1, 3, 2, 4, 5).contiguous().view(-1, window_size, window_size, C)\n    )\n    return windows, (Hp, Wp)", "\n\ndef window_unpartition(\n    windows: torch.Tensor,\n    window_size: int,\n    pad_hw: Tuple[int, int],\n    hw: Tuple[int, int],\n) -> torch.Tensor:\n    \"\"\"\n    Window unpartition into original sequences and removing padding.\n    Args:\n        x (tensor): input tokens with [B * num_windows, window_size, window_size, C].\n        window_size (int): window size.\n        pad_hw (Tuple): padded height and width (Hp, Wp).\n        hw (Tuple): original height and width (H, W) before padding.\n\n    Returns:\n        x: unpartitioned sequences with [B, H, W, C].\n    \"\"\"\n    Hp, Wp = pad_hw\n    H, W = hw\n    B = windows.shape[0] // (Hp * Wp // window_size // window_size)\n    x = windows.view(\n        B, Hp // window_size, Wp // window_size, window_size, window_size, -1\n    )\n    x = x.permute(0, 1, 3, 2, 4, 5).contiguous().view(B, Hp, Wp, -1)\n\n    if Hp > H or Wp > W:\n        x = x[:, :H, :W, :].contiguous()\n    return x", "\n\ndef get_rel_pos(q_size: int, k_size: int, rel_pos: torch.Tensor) -> torch.Tensor:\n    \"\"\"\n    Get relative positional embeddings according to the relative positions of\n        query and key sizes.\n    Args:\n        q_size (int): size of query q.\n        k_size (int): size of key k.\n        rel_pos (Tensor): relative position embeddings (L, C).\n\n    Returns:\n        Extracted positional embeddings according to relative positions.\n    \"\"\"\n    max_rel_dist = int(2 * max(q_size, k_size) - 1)\n    # Interpolate rel pos if needed.\n    if rel_pos.shape[0] != max_rel_dist:\n        # Interpolate rel pos.\n        rel_pos_resized = F.interpolate(\n            rel_pos.reshape(1, rel_pos.shape[0], -1).permute(0, 2, 1),\n            size=max_rel_dist,\n            mode=\"linear\",\n        )\n        rel_pos_resized = rel_pos_resized.reshape(-1, max_rel_dist).permute(1, 0)\n    else:\n        rel_pos_resized = rel_pos\n\n    # Scale the coords with short length if shapes for q and k are different.\n    q_coords = torch.arange(q_size)[:, None] * max(k_size / q_size, 1.0)\n    k_coords = torch.arange(k_size)[None, :] * max(q_size / k_size, 1.0)\n    relative_coords = (q_coords - k_coords) + (k_size - 1) * max(q_size / k_size, 1.0)\n\n    return rel_pos_resized[relative_coords.long()]", "\n\ndef add_decomposed_rel_pos(\n    attn: torch.Tensor,\n    q: torch.Tensor,\n    rel_pos_h: torch.Tensor,\n    rel_pos_w: torch.Tensor,\n    q_size: Tuple[int, int],\n    k_size: Tuple[int, int],\n) -> torch.Tensor:\n    \"\"\"\n    Calculate decomposed Relative Positional Embeddings from :paper:`mvitv2`.\n    commit_sha: 19786631e330df9f3622e5402b4a419a263a2c80\n    https://github.com/facebookresearch/mvit/blob/main/mvit/models/attention.py\n    Args:\n        attn (Tensor): attention map.\n        q (Tensor): query q in the attention layer with shape (B, q_h * q_w, C).\n        rel_pos_h (Tensor): relative position embeddings (Lh, C) for height axis.\n        rel_pos_w (Tensor): relative position embeddings (Lw, C) for width axis.\n        q_size (Tuple): spatial sequence size of query q with (q_h, q_w).\n        k_size (Tuple): spatial sequence size of key k with (k_h, k_w).\n\n    Returns:\n        attn (Tensor): attention map with added relative positional embeddings.\n    \"\"\"\n    q_h, q_w = q_size\n    k_h, k_w = k_size\n    Rh = get_rel_pos(q_h, k_h, rel_pos_h)\n    Rw = get_rel_pos(q_w, k_w, rel_pos_w)\n\n    B, _, dim = q.shape\n    r_q = q.reshape(B, q_h, q_w, dim)\n    rel_h = torch.einsum(\"bhwc,hkc->bhwk\", r_q, Rh)\n    rel_w = torch.einsum(\"bhwc,wkc->bhwk\", r_q, Rw)\n\n    attn = (\n        attn.view(B, q_h, q_w, k_h, k_w)\n        + rel_h[:, :, :, :, None]\n        + rel_w[:, :, :, None, :]\n    ).view(B, q_h * q_w, k_h * k_w)\n\n    return attn", "\n\nclass PatchEmbed(nn.Module):\n    \"\"\"\n    Image to Patch Embedding.\n    \"\"\"\n\n    def __init__(\n        self,\n        kernel_size: Tuple[int, int] = (16, 16),\n        stride: Tuple[int, int] = (16, 16),\n        padding: Tuple[int, int] = (0, 0),\n        in_chans: int = 3,\n        embed_dim: int = 768,\n    ) -> None:\n        \"\"\"\n        Args:\n            kernel_size (Tuple): kernel size of the projection layer.\n            stride (Tuple): stride of the projection layer.\n            padding (Tuple): padding size of the projection layer.\n            in_chans (int): Number of input image channels.\n            embed_dim (int):  embed_dim (int): Patch embedding dimension.\n        \"\"\"\n        super().__init__()\n\n        self.proj = nn.Conv2d(\n            in_chans, embed_dim, kernel_size=kernel_size, stride=stride, padding=padding\n        )\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        x = self.proj(x)\n        # B C H W -> B H W C\n        x = x.permute(0, 2, 3, 1)\n        return x", ""]}
{"filename": "metaseg/modeling/transformer.py", "chunked_list": ["# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport math\nfrom typing import Tuple, Type\n\nimport torch", "\nimport torch\nfrom torch import Tensor, nn\n\nfrom metaseg.modeling.common import MLPBlock\n\n\nclass TwoWayTransformer(nn.Module):\n    def __init__(\n        self,\n        depth: int,\n        embedding_dim: int,\n        num_heads: int,\n        mlp_dim: int,\n        activation: Type[nn.Module] = nn.ReLU,\n        attention_downsample_rate: int = 2,\n    ) -> None:\n        \"\"\"\n        A transformer decoder that attends to an input image using\n        queries whose positional embedding is supplied.\n\n        Args:\n          depth (int): number of layers in the transformer\n          embedding_dim (int): the channel dimension for the input embeddings\n          num_heads (int): the number of heads for multihead attention. Must\n            divide embedding_dim\n          mlp_dim (int): the channel dimension internal to the MLP block\n          activation (nn.Module): the activation to use in the MLP block\n        \"\"\"\n        super().__init__()\n        self.depth = depth\n        self.embedding_dim = embedding_dim\n        self.num_heads = num_heads\n        self.mlp_dim = mlp_dim\n        self.layers = nn.ModuleList()\n\n        for i in range(depth):\n            self.layers.append(\n                TwoWayAttentionBlock(\n                    embedding_dim=embedding_dim,\n                    num_heads=num_heads,\n                    mlp_dim=mlp_dim,\n                    activation=activation,\n                    attention_downsample_rate=attention_downsample_rate,\n                    skip_first_layer_pe=(i == 0),\n                )\n            )\n\n        self.final_attn_token_to_image = Attention(\n            embedding_dim, num_heads, downsample_rate=attention_downsample_rate\n        )\n        self.norm_final_attn = nn.LayerNorm(embedding_dim)\n\n    def forward(\n        self,\n        image_embedding: Tensor,\n        image_pe: Tensor,\n        point_embedding: Tensor,\n    ) -> Tuple[Tensor, Tensor]:\n        \"\"\"\n        Args:\n          image_embedding (torch.Tensor): image to attend to. Should be shape\n            B x embedding_dim x h x w for any h and w.\n          image_pe (torch.Tensor): the positional encoding to add to the image. Must\n            have the same shape as image_embedding.\n          point_embedding (torch.Tensor): the embedding to add to the query points.\n            Must have shape B x N_points x embedding_dim for any N_points.\n\n        Returns:\n          torch.Tensor: the processed point_embedding\n          torch.Tensor: the processed image_embedding\n        \"\"\"\n        # BxCxHxW -> BxHWxC == B x N_image_tokens x C\n        bs, c, h, w = image_embedding.shape\n        image_embedding = image_embedding.flatten(2).permute(0, 2, 1)\n        image_pe = image_pe.flatten(2).permute(0, 2, 1)\n\n        # Prepare queries\n        queries = point_embedding\n        keys = image_embedding\n\n        # Apply transformer blocks and final layernorm\n        for layer in self.layers:\n            queries, keys = layer(\n                queries=queries,\n                keys=keys,\n                query_pe=point_embedding,\n                key_pe=image_pe,\n            )\n\n        # Apply the final attenion layer from the points to the image\n        q = queries + point_embedding\n        k = keys + image_pe\n        attn_out = self.final_attn_token_to_image(q=q, k=k, v=keys)\n        queries = queries + attn_out\n        queries = self.norm_final_attn(queries)\n\n        return queries, keys", "\n\nclass TwoWayAttentionBlock(nn.Module):\n    def __init__(\n        self,\n        embedding_dim: int,\n        num_heads: int,\n        mlp_dim: int = 2048,\n        activation: Type[nn.Module] = nn.ReLU,\n        attention_downsample_rate: int = 2,\n        skip_first_layer_pe: bool = False,\n    ) -> None:\n        \"\"\"\n        A transformer block with four layers: (1) self-attention of sparse\n        inputs, (2) cross attention of sparse inputs to dense inputs, (3) mlp\n        block on sparse inputs, and (4) cross attention of dense inputs to sparse\n        inputs.\n\n        Arguments:\n          embedding_dim (int): the channel dimension of the embeddings\n          num_heads (int): the number of heads in the attention layers\n          mlp_dim (int): the hidden dimension of the mlp block\n          activation (nn.Module): the activation of the mlp block\n          skip_first_layer_pe (bool): skip the PE on the first layer\n        \"\"\"\n        super().__init__()\n        self.self_attn = Attention(embedding_dim, num_heads)\n        self.norm1 = nn.LayerNorm(embedding_dim)\n\n        self.cross_attn_token_to_image = Attention(\n            embedding_dim, num_heads, downsample_rate=attention_downsample_rate\n        )\n        self.norm2 = nn.LayerNorm(embedding_dim)\n\n        self.mlp = MLPBlock(embedding_dim, mlp_dim, activation)\n        self.norm3 = nn.LayerNorm(embedding_dim)\n\n        self.norm4 = nn.LayerNorm(embedding_dim)\n        self.cross_attn_image_to_token = Attention(\n            embedding_dim, num_heads, downsample_rate=attention_downsample_rate\n        )\n\n        self.skip_first_layer_pe = skip_first_layer_pe\n\n    def forward(\n        self, queries: Tensor, keys: Tensor, query_pe: Tensor, key_pe: Tensor\n    ) -> Tuple[Tensor, Tensor]:\n        # Self attention block\n        if self.skip_first_layer_pe:\n            queries = self.self_attn(q=queries, k=queries, v=queries)\n        else:\n            q = queries + query_pe\n            attn_out = self.self_attn(q=q, k=q, v=queries)\n            queries = queries + attn_out\n        queries = self.norm1(queries)\n\n        # Cross attention block, tokens attending to image embedding\n        q = queries + query_pe\n        k = keys + key_pe\n        attn_out = self.cross_attn_token_to_image(q=q, k=k, v=keys)\n        queries = queries + attn_out\n        queries = self.norm2(queries)\n\n        # MLP block\n        mlp_out = self.mlp(queries)\n        queries = queries + mlp_out\n        queries = self.norm3(queries)\n\n        # Cross attention block, image embedding attending to tokens\n        q = queries + query_pe\n        k = keys + key_pe\n        attn_out = self.cross_attn_image_to_token(q=k, k=q, v=queries)\n        keys = keys + attn_out\n        keys = self.norm4(keys)\n\n        return queries, keys", "\n\nclass Attention(nn.Module):\n    \"\"\"\n    An attention layer that allows for downscaling the size of the embedding\n    after projection to queries, keys, and values.\n    \"\"\"\n\n    def __init__(\n        self,\n        embedding_dim: int,\n        num_heads: int,\n        downsample_rate: int = 1,\n    ) -> None:\n        super().__init__()\n        self.embedding_dim = embedding_dim\n        self.internal_dim = embedding_dim // downsample_rate\n        self.num_heads = num_heads\n        assert (\n            self.internal_dim % num_heads == 0\n        ), \"num_heads must divide embedding_dim.\"\n\n        self.q_proj = nn.Linear(embedding_dim, self.internal_dim)\n        self.k_proj = nn.Linear(embedding_dim, self.internal_dim)\n        self.v_proj = nn.Linear(embedding_dim, self.internal_dim)\n        self.out_proj = nn.Linear(self.internal_dim, embedding_dim)\n\n    def _separate_heads(self, x: Tensor, num_heads: int) -> Tensor:\n        b, n, c = x.shape\n        x = x.reshape(b, n, num_heads, c // num_heads)\n        return x.transpose(1, 2)  # B x N_heads x N_tokens x C_per_head\n\n    def _recombine_heads(self, x: Tensor) -> Tensor:\n        b, n_heads, n_tokens, c_per_head = x.shape\n        x = x.transpose(1, 2)\n        return x.reshape(b, n_tokens, n_heads * c_per_head)  # B x N_tokens x C\n\n    def forward(self, q: Tensor, k: Tensor, v: Tensor) -> Tensor:\n        # Input projections\n        q = self.q_proj(q)\n        k = self.k_proj(k)\n        v = self.v_proj(v)\n\n        # Separate into heads\n        q = self._separate_heads(q, self.num_heads)\n        k = self._separate_heads(k, self.num_heads)\n        v = self._separate_heads(v, self.num_heads)\n\n        # Attention\n        _, _, _, c_per_head = q.shape\n        attn = q @ k.permute(0, 1, 3, 2)  # B x N_heads x N_tokens x N_tokens\n        attn = attn / math.sqrt(c_per_head)\n        attn = torch.softmax(attn, dim=-1)\n\n        # Get output\n        out = attn @ v\n        out = self._recombine_heads(out)\n        out = self.out_proj(out)\n\n        return out", ""]}
{"filename": "metaseg/modeling/sam.py", "chunked_list": ["# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom typing import Any, Dict, List, Tuple\n\nimport torch\nfrom torch import nn", "import torch\nfrom torch import nn\nfrom torch.nn import functional as F\n\nfrom metaseg.modeling.image_encoder import ImageEncoderViT\nfrom metaseg.modeling.mask_decoder import MaskDecoder\nfrom metaseg.modeling.prompt_encoder import PromptEncoder\n\n\nclass Sam(nn.Module):\n    mask_threshold: float = 0.0\n    image_format: str = \"RGB\"\n\n    def __init__(\n        self,\n        image_encoder: ImageEncoderViT,\n        prompt_encoder: PromptEncoder,\n        mask_decoder: MaskDecoder,\n        pixel_mean: List[float] = [123.675, 116.28, 103.53],\n        pixel_std: List[float] = [58.395, 57.12, 57.375],\n    ) -> None:\n        \"\"\"\n        SAM predicts object masks from an image and input prompts.\n\n        Arguments:\n          image_encoder (ImageEncoderViT): The backbone used to encode the\n            image into image embeddings that allow for efficient mask prediction.\n          prompt_encoder (PromptEncoder): Encodes various types of input prompts.\n          mask_decoder (MaskDecoder): Predicts masks from the image embeddings\n            and encoded prompts.\n          pixel_mean (list(float)): Mean values for normalizing\n            pixels in the input image.\n          pixel_std (list(float)): Std values for normalizing\n            pixels in the input image.\n        \"\"\"\n        super().__init__()\n        self.image_encoder = image_encoder\n        self.prompt_encoder = prompt_encoder\n        self.mask_decoder = mask_decoder\n        self.register_buffer(\n            \"pixel_mean\", torch.Tensor(pixel_mean).view(-1, 1, 1), False\n        )\n        self.register_buffer(\"pixel_std\", torch.Tensor(pixel_std).view(-1, 1, 1), False)\n\n    @property\n    def device(self) -> Any:\n        return self.pixel_mean.device\n\n    @torch.no_grad()\n    def forward(\n        self,\n        batched_input: List[Dict[str, Any]],\n        multimask_output: bool,\n    ) -> List[Dict[str, torch.Tensor]]:\n        \"\"\"\n        Predicts masks end-to-end from provided images and prompts.\n        If prompts are not known in advance, using SamPredictor is\n        recommended over calling the model directly.\n\n        Arguments:\n          batched_input (list(dict)): A list over input images, each a\n            dictionary with the following keys. A prompt key can be\n            excluded if it is not present.\n              'image': The image as a torch tensor in 3xHxW format,\n                already transformed for input to the model.\n              'original_size': (tuple(int, int)) The original size of\n                the image before transformation, as (H, W).\n              'point_coords': (torch.Tensor) Batched point prompts for\n                this image, with shape BxNx2. Already transformed to the\n                input frame of the model.\n              'point_labels': (torch.Tensor) Batched labels for point prompts,\n                with shape BxN.\n              'boxes': (torch.Tensor) Batched box inputs, with shape Bx4.\n                Already transformed to the input frame of the model.\n              'mask_inputs': (torch.Tensor) Batched mask inputs to the model,\n                in the form Bx1xHxW.\n          multimask_output (bool): Whether the model should predict multiple\n            disambiguating masks, or return a single mask.\n\n        Returns:\n          (list(dict)): A list over input images, where each element is\n            as dictionary with the following keys.\n              'masks': (torch.Tensor) Batched binary mask predictions,\n                with shape BxCxHxW, where B is the number of input promts,\n                C is determiend by multimask_output, and (H, W) is the\n                original size of the image.\n              'iou_predictions': (torch.Tensor) The model's predictions\n                of mask quality, in shape BxC.\n              'low_res_logits': (torch.Tensor) Low resolution logits with\n                shape BxCxHxW, where H=W=256. Can be passed as mask input\n                to subsequent iterations of prediction.\n        \"\"\"\n        input_images = torch.stack(\n            [self.preprocess(x[\"image\"]) for x in batched_input], dim=0\n        )\n        image_embeddings = self.image_encoder(input_images)\n\n        outputs = []\n        for image_record, curr_embedding in zip(batched_input, image_embeddings):\n            if \"point_coords\" in image_record:\n                points = (image_record[\"point_coords\"], image_record[\"point_labels\"])\n            else:\n                points = None\n            sparse_embeddings, dense_embeddings = self.prompt_encoder(\n                points=points,\n                boxes=image_record.get(\"boxes\", None),\n                masks=image_record.get(\"mask_inputs\", None),\n            )\n            low_res_masks, iou_predictions = self.mask_decoder(\n                image_embeddings=curr_embedding.unsqueeze(0),\n                image_pe=self.prompt_encoder.get_dense_pe(),\n                sparse_prompt_embeddings=sparse_embeddings,\n                dense_prompt_embeddings=dense_embeddings,\n                multimask_output=multimask_output,\n            )\n            masks = self.postprocess_masks(\n                low_res_masks,\n                input_size=image_record[\"image\"].shape[-2:],\n                original_size=image_record[\"original_size\"],\n            )\n            masks = masks > self.mask_threshold\n            outputs.append(\n                {\n                    \"masks\": masks,\n                    \"iou_predictions\": iou_predictions,\n                    \"low_res_logits\": low_res_masks,\n                }\n            )\n        return outputs\n\n    def postprocess_masks(\n        self,\n        masks: torch.Tensor,\n        input_size: Tuple[int, ...],\n        original_size: Tuple[int, ...],\n    ) -> torch.Tensor:\n        \"\"\"\n        Remove padding and upscale masks to the original image size.\n\n        Arguments:\n          masks (torch.Tensor): Batched masks from the mask_decoder,\n            in BxCxHxW format.\n          input_size (tuple(int, int)): The size of the image input to the\n            model, in (H, W) format. Used to remove padding.\n          original_size (tuple(int, int)): The original size of the image\n            before resizing for input to the model, in (H, W) format.\n\n        Returns:\n          (torch.Tensor): Batched masks in BxCxHxW format, where (H, W)\n            is given by original_size.\n        \"\"\"\n        masks = F.interpolate(\n            masks,\n            (self.image_encoder.img_size, self.image_encoder.img_size),\n            mode=\"bilinear\",\n            align_corners=False,\n        )\n        masks = masks[..., : input_size[0], : input_size[1]]\n        masks = F.interpolate(\n            masks, original_size, mode=\"bilinear\", align_corners=False\n        )\n        return masks\n\n    def preprocess(self, x: torch.Tensor) -> torch.Tensor:\n        \"\"\"Normalize pixel values and pad to a square input.\"\"\"\n        # Normalize colors\n        x = (x - self.pixel_mean) / self.pixel_std\n\n        # Pad\n        h, w = x.shape[-2:]\n        padh = self.image_encoder.img_size - h\n        padw = self.image_encoder.img_size - w\n        x = F.pad(x, (0, padw, 0, padh))\n        return x", "\nclass Sam(nn.Module):\n    mask_threshold: float = 0.0\n    image_format: str = \"RGB\"\n\n    def __init__(\n        self,\n        image_encoder: ImageEncoderViT,\n        prompt_encoder: PromptEncoder,\n        mask_decoder: MaskDecoder,\n        pixel_mean: List[float] = [123.675, 116.28, 103.53],\n        pixel_std: List[float] = [58.395, 57.12, 57.375],\n    ) -> None:\n        \"\"\"\n        SAM predicts object masks from an image and input prompts.\n\n        Arguments:\n          image_encoder (ImageEncoderViT): The backbone used to encode the\n            image into image embeddings that allow for efficient mask prediction.\n          prompt_encoder (PromptEncoder): Encodes various types of input prompts.\n          mask_decoder (MaskDecoder): Predicts masks from the image embeddings\n            and encoded prompts.\n          pixel_mean (list(float)): Mean values for normalizing\n            pixels in the input image.\n          pixel_std (list(float)): Std values for normalizing\n            pixels in the input image.\n        \"\"\"\n        super().__init__()\n        self.image_encoder = image_encoder\n        self.prompt_encoder = prompt_encoder\n        self.mask_decoder = mask_decoder\n        self.register_buffer(\n            \"pixel_mean\", torch.Tensor(pixel_mean).view(-1, 1, 1), False\n        )\n        self.register_buffer(\"pixel_std\", torch.Tensor(pixel_std).view(-1, 1, 1), False)\n\n    @property\n    def device(self) -> Any:\n        return self.pixel_mean.device\n\n    @torch.no_grad()\n    def forward(\n        self,\n        batched_input: List[Dict[str, Any]],\n        multimask_output: bool,\n    ) -> List[Dict[str, torch.Tensor]]:\n        \"\"\"\n        Predicts masks end-to-end from provided images and prompts.\n        If prompts are not known in advance, using SamPredictor is\n        recommended over calling the model directly.\n\n        Arguments:\n          batched_input (list(dict)): A list over input images, each a\n            dictionary with the following keys. A prompt key can be\n            excluded if it is not present.\n              'image': The image as a torch tensor in 3xHxW format,\n                already transformed for input to the model.\n              'original_size': (tuple(int, int)) The original size of\n                the image before transformation, as (H, W).\n              'point_coords': (torch.Tensor) Batched point prompts for\n                this image, with shape BxNx2. Already transformed to the\n                input frame of the model.\n              'point_labels': (torch.Tensor) Batched labels for point prompts,\n                with shape BxN.\n              'boxes': (torch.Tensor) Batched box inputs, with shape Bx4.\n                Already transformed to the input frame of the model.\n              'mask_inputs': (torch.Tensor) Batched mask inputs to the model,\n                in the form Bx1xHxW.\n          multimask_output (bool): Whether the model should predict multiple\n            disambiguating masks, or return a single mask.\n\n        Returns:\n          (list(dict)): A list over input images, where each element is\n            as dictionary with the following keys.\n              'masks': (torch.Tensor) Batched binary mask predictions,\n                with shape BxCxHxW, where B is the number of input promts,\n                C is determiend by multimask_output, and (H, W) is the\n                original size of the image.\n              'iou_predictions': (torch.Tensor) The model's predictions\n                of mask quality, in shape BxC.\n              'low_res_logits': (torch.Tensor) Low resolution logits with\n                shape BxCxHxW, where H=W=256. Can be passed as mask input\n                to subsequent iterations of prediction.\n        \"\"\"\n        input_images = torch.stack(\n            [self.preprocess(x[\"image\"]) for x in batched_input], dim=0\n        )\n        image_embeddings = self.image_encoder(input_images)\n\n        outputs = []\n        for image_record, curr_embedding in zip(batched_input, image_embeddings):\n            if \"point_coords\" in image_record:\n                points = (image_record[\"point_coords\"], image_record[\"point_labels\"])\n            else:\n                points = None\n            sparse_embeddings, dense_embeddings = self.prompt_encoder(\n                points=points,\n                boxes=image_record.get(\"boxes\", None),\n                masks=image_record.get(\"mask_inputs\", None),\n            )\n            low_res_masks, iou_predictions = self.mask_decoder(\n                image_embeddings=curr_embedding.unsqueeze(0),\n                image_pe=self.prompt_encoder.get_dense_pe(),\n                sparse_prompt_embeddings=sparse_embeddings,\n                dense_prompt_embeddings=dense_embeddings,\n                multimask_output=multimask_output,\n            )\n            masks = self.postprocess_masks(\n                low_res_masks,\n                input_size=image_record[\"image\"].shape[-2:],\n                original_size=image_record[\"original_size\"],\n            )\n            masks = masks > self.mask_threshold\n            outputs.append(\n                {\n                    \"masks\": masks,\n                    \"iou_predictions\": iou_predictions,\n                    \"low_res_logits\": low_res_masks,\n                }\n            )\n        return outputs\n\n    def postprocess_masks(\n        self,\n        masks: torch.Tensor,\n        input_size: Tuple[int, ...],\n        original_size: Tuple[int, ...],\n    ) -> torch.Tensor:\n        \"\"\"\n        Remove padding and upscale masks to the original image size.\n\n        Arguments:\n          masks (torch.Tensor): Batched masks from the mask_decoder,\n            in BxCxHxW format.\n          input_size (tuple(int, int)): The size of the image input to the\n            model, in (H, W) format. Used to remove padding.\n          original_size (tuple(int, int)): The original size of the image\n            before resizing for input to the model, in (H, W) format.\n\n        Returns:\n          (torch.Tensor): Batched masks in BxCxHxW format, where (H, W)\n            is given by original_size.\n        \"\"\"\n        masks = F.interpolate(\n            masks,\n            (self.image_encoder.img_size, self.image_encoder.img_size),\n            mode=\"bilinear\",\n            align_corners=False,\n        )\n        masks = masks[..., : input_size[0], : input_size[1]]\n        masks = F.interpolate(\n            masks, original_size, mode=\"bilinear\", align_corners=False\n        )\n        return masks\n\n    def preprocess(self, x: torch.Tensor) -> torch.Tensor:\n        \"\"\"Normalize pixel values and pad to a square input.\"\"\"\n        # Normalize colors\n        x = (x - self.pixel_mean) / self.pixel_std\n\n        # Pad\n        h, w = x.shape[-2:]\n        padh = self.image_encoder.img_size - h\n        padw = self.image_encoder.img_size - w\n        x = F.pad(x, (0, padw, 0, padh))\n        return x", ""]}
{"filename": "metaseg/modeling/__init__.py", "chunked_list": ["# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom .common import LayerNorm2d as LayerNorm2d\nfrom .common import MLPBlock as MLPBlock\nfrom .image_encoder import ImageEncoderViT as ImageEncoderViT\nfrom .mask_decoder import MaskDecoder as MaskDecoder", "from .image_encoder import ImageEncoderViT as ImageEncoderViT\nfrom .mask_decoder import MaskDecoder as MaskDecoder\nfrom .prompt_encoder import PositionEmbeddingRandom as PositionEmbeddingRandom\nfrom .prompt_encoder import PromptEncoder as PromptEncoder\nfrom .sam import Sam as Sam\nfrom .transformer import Attention as Attention\nfrom .transformer import TwoWayAttentionBlock as TwoWayAttentionBlock\nfrom .transformer import TwoWayTransformer as TwoWayTransformer\n", ""]}
{"filename": "metaseg/modeling/common.py", "chunked_list": ["# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom typing import Type\n\nimport torch\nimport torch.nn as nn", "import torch\nimport torch.nn as nn\n\n\nclass MLPBlock(nn.Module):\n    def __init__(\n        self,\n        embedding_dim: int,\n        mlp_dim: int,\n        act: Type[nn.Module] = nn.GELU,\n    ) -> None:\n        super().__init__()\n        self.lin1 = nn.Linear(embedding_dim, mlp_dim)\n        self.lin2 = nn.Linear(mlp_dim, embedding_dim)\n        self.act = act()\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        return self.lin2(self.act(self.lin1(x)))", "\n\n# From https://github.com/facebookresearch/detectron2/blob/main/detectron2/layers/batch_norm.py # noqa\n# Itself from https://github.com/facebookresearch/ConvNeXt/blob/d1fa8f6fef0a165b27399986cc2bdacc92777e40/models/convnext.py#L119  # noqa\nclass LayerNorm2d(nn.Module):\n    def __init__(self, num_channels: int, eps: float = 1e-6) -> None:\n        super().__init__()\n        self.weight = nn.Parameter(torch.ones(num_channels))\n        self.bias = nn.Parameter(torch.zeros(num_channels))\n        self.eps = eps\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        u = x.mean(1, keepdim=True)\n        s = (x - u).pow(2).mean(1, keepdim=True)\n        x = (x - u) / torch.sqrt(s + self.eps)\n        x = self.weight[:, None, None] * x + self.bias[:, None, None]\n        return x", ""]}
{"filename": "metaseg/utils/model_file_downloader.py", "chunked_list": ["import os\nfrom functools import partial\nfrom hashlib import md5\nfrom pathlib import Path\nfrom shutil import copyfileobj\n\nfrom requests import Response, get\nfrom tqdm.auto import tqdm\n\n# A dictionary containing model types as keys and their respective URLs as values", "\n# A dictionary containing model types as keys and their respective URLs as values\nMODEL_URLS: dict[str : tuple[str]] = {\n    \"vit_h\": (\n        \"https://dl.fbaipublicfiles.com/segment_anything/sam_vit_h_4b8939.pth\",\n        \"green\",\n        \"01ec64d29a2fca3f0661936605ae66f8\",\n    ),\n    \"vit_l\": (\n        \"https://dl.fbaipublicfiles.com/segment_anything/sam_vit_l_0b3195.pth\",", "    \"vit_l\": (\n        \"https://dl.fbaipublicfiles.com/segment_anything/sam_vit_l_0b3195.pth\",\n        \"red\",\n        \"0b3195507c641ddb6910d2bb5adee89c\",\n    ),\n    \"vit_b\": (\n        \"https://dl.fbaipublicfiles.com/segment_anything/sam_vit_b_01ec64.pth\",\n        \"cyan\",\n        \"4b8939a88964f0f4ff5f5b2642c598a6\",\n    ),", "        \"4b8939a88964f0f4ff5f5b2642c598a6\",\n    ),\n}\n\n\n# md5 check function\ndef _check_md5(filename: str, orig_md5: str) -> bool:\n    \"\"\"\n    filename: str, A string representing the path to the file.\n    orig_md5: str, A string representing the original md5 hash.\n    \"\"\"\n    if not os.path.exists(filename):\n        return False\n    with open(filename, \"rb\") as file_to_check:\n        # read contents of the file\n        data = file_to_check.read()\n        # pipe contents of the file through\n        md5_returned = md5(data).hexdigest()\n        # Return True if the computed hash matches the original one\n        if md5_returned == orig_md5:\n            return True\n        return False", "\n\ndef download_model(model_type):\n    \"\"\"\n    model_type: str, A string representing the model type.\n    It can be 'vit_h', 'vit_l', or 'vit_b'.\n    \"\"\"\n\n    # Check if the model file already exists and model_type is in MODEL_URLS\n    filename = f\"{model_type}.pth\"\n    if not os.path.exists(filename) and model_type in MODEL_URLS:\n        print(f\"Downloading {filename} model \\n\")\n        res: Response = get(\n            MODEL_URLS[model_type][0], stream=True, allow_redirects=True\n        )\n        if res.status_code != 200:\n            res.raise_for_status()\n            raise RuntimeError(\n                f\"Request to {MODEL_URLS[model_type][0]} \"\n                f\"returned status code {res.status_code}\"\n            )\n\n        file_size: int = int(res.headers.get(\"Content-Length\", 0))\n        folder_path: Path = Path(filename).expanduser().resolve()\n        folder_path.parent.mkdir(parents=True, exist_ok=True)\n\n        desc = \"(Unknown total file size)\" if file_size == 0 else \"\"\n        res.raw.read = partial(\n            res.raw.read, decode_content=True\n        )  # Decompress if needed\n        with tqdm.wrapattr(\n            res.raw,\n            \"read\",\n            total=file_size,\n            desc=desc,\n            colour=MODEL_URLS[model_type][1],\n        ) as r_raw:\n            with folder_path.open(\"wb\") as f:\n                copyfileobj(r_raw, f)\n\n    elif os.path.exists(filename):\n        if not _check_md5(filename, MODEL_URLS[model_type][2]):\n            print(\"File corrupted. Re-downloading... \\n\")\n            os.remove(filename)\n            download_model(model_type)\n\n        print(f\"{filename} model download complete. \\n\")\n    else:\n        raise ValueError(\n            \"Invalid model type. It should be 'vit_h', 'vit_l', or 'vit_b'.\"\n        )\n\n    return filename", ""]}
{"filename": "metaseg/utils/transforms.py", "chunked_list": ["# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom copy import deepcopy\nfrom typing import Tuple\n\nimport numpy as np", "\nimport numpy as np\nimport torch\nfrom torch.nn import functional as F\nfrom torchvision.transforms.functional import resize, to_pil_image  # type: ignore\n\n\nclass ResizeLongestSide:\n    \"\"\"\n    Resizes images to longest side 'target_length', as well as provides\n    methods for resizing coordinates and boxes. Provides methods for\n    transforming both numpy array and batched torch tensors.\n    \"\"\"\n\n    def __init__(self, target_length: int) -> None:\n        self.target_length = target_length\n\n    def apply_image(self, image: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Expects a numpy array with shape HxWxC in uint8 format.\n        \"\"\"\n        target_size = self.get_preprocess_shape(\n            image.shape[0], image.shape[1], self.target_length\n        )\n        return np.array(resize(to_pil_image(image), target_size))\n\n    def apply_coords(\n        self, coords: np.ndarray, original_size: Tuple[int, ...]\n    ) -> np.ndarray:\n        \"\"\"\n        Expects a numpy array of length 2 in the final dimension. Requires the\n        original image size in (H, W) format.\n        \"\"\"\n        old_h, old_w = original_size\n        new_h, new_w = self.get_preprocess_shape(\n            original_size[0], original_size[1], self.target_length\n        )\n        coords = deepcopy(coords).astype(float)\n        coords[..., 0] = coords[..., 0] * (new_w / old_w)\n        coords[..., 1] = coords[..., 1] * (new_h / old_h)\n        return coords\n\n    def apply_boxes(\n        self, boxes: np.ndarray, original_size: Tuple[int, ...]\n    ) -> np.ndarray:\n        \"\"\"\n        Expects a numpy array shape Bx4. Requires the original image size\n        in (H, W) format.\n        \"\"\"\n        boxes = self.apply_coords(boxes.reshape(-1, 2, 2), original_size)\n        return boxes.reshape(-1, 4)\n\n    def apply_image_torch(self, image: torch.Tensor) -> torch.Tensor:\n        \"\"\"\n        Expects batched images with shape BxCxHxW and float format. This\n        transformation may not exactly match apply_image. apply_image is\n        the transformation expected by the model.\n        \"\"\"\n        # Expects an image in BCHW format. May not exactly match apply_image.\n        target_size = self.get_preprocess_shape(\n            image.shape[0], image.shape[1], self.target_length\n        )\n        return F.interpolate(\n            image, target_size, mode=\"bilinear\", align_corners=False, antialias=True\n        )\n\n    def apply_coords_torch(\n        self, coords: torch.Tensor, original_size: Tuple[int, ...]\n    ) -> torch.Tensor:\n        \"\"\"\n        Expects a torch tensor with length 2 in the last dimension. Requires the\n        original image size in (H, W) format.\n        \"\"\"\n        old_h, old_w = original_size\n        new_h, new_w = self.get_preprocess_shape(\n            original_size[0], original_size[1], self.target_length\n        )\n        coords = deepcopy(coords).to(torch.float)\n        coords[..., 0] = coords[..., 0] * (new_w / old_w)\n        coords[..., 1] = coords[..., 1] * (new_h / old_h)\n        return coords\n\n    def apply_boxes_torch(\n        self, boxes: torch.Tensor, original_size: Tuple[int, ...]\n    ) -> torch.Tensor:\n        \"\"\"\n        Expects a torch tensor with shape Bx4. Requires the original image\n        size in (H, W) format.\n        \"\"\"\n        boxes = self.apply_coords_torch(boxes.reshape(-1, 2, 2), original_size)\n        return boxes.reshape(-1, 4)\n\n    @staticmethod\n    def get_preprocess_shape(\n        oldh: int, oldw: int, long_side_length: int\n    ) -> Tuple[int, int]:\n        \"\"\"\n        Compute the output size given input size and target long side length.\n        \"\"\"\n        scale = long_side_length * 1.0 / max(oldh, oldw)\n        newh, neww = oldh * scale, oldw * scale\n        neww = int(neww + 0.5)\n        newh = int(newh + 0.5)\n        return (newh, neww)", ""]}
{"filename": "metaseg/utils/data_utils.py", "chunked_list": ["from io import BytesIO\nfrom os import system\nfrom os.path import isfile as isfile\nfrom typing import Union\nfrom uuid import uuid4\n\nimport cv2\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom cv2 import Mat", "import numpy as np\nfrom cv2 import Mat\nfrom PIL import Image\nfrom torch import tensor\n\n\ndef load_image(image: Union[str, Mat]) -> Mat:\n    \"\"\"\n    Load image from path\n    :param image_path: path to image file or image as Mat or np.ndarray\n    :return: image as Mat\n    \"\"\"\n    if isfile(image):\n        image = cv2.imread(image)\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        return image\n    elif isinstance(image, Mat) or isinstance(image, np.ndarray):\n        return image\n    else:\n        raise ValueError(\"image must be a path or cv2.Mat\")", "\n\ndef load_server_image(image_path):\n    imagedir = str(uuid4())\n    system(f\"mkdir -p {imagedir}\")\n    image = Image.open(BytesIO(image_path))\n    if image.mode != \"RGB\":\n        image = image.convert(\"RGB\")\n\n    image_path = f\"{imagedir}/base_image_v0.png\"\n    output_path = f\"{imagedir}/output_v0.png\"\n    image.save(image_path, format=\"PNG\")\n    return image_path, output_path", "\n\ndef load_video(video_path, output_path=\"output.mp4\"):\n    cap = cv2.VideoCapture(video_path)\n    frame_width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))\n    frame_height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))\n    fourcc = cv2.VideoWriter_fourcc(*\"XVID\")\n    fps = int(cap.get(cv2.CAP_PROP_FPS))\n    out = cv2.VideoWriter(output_path, fourcc, fps, (frame_width, frame_height))\n    return cap, out", "\n\ndef load_mask(mask, random_color):\n    if random_color:\n        color = np.random.rand(3) * 255\n    else:\n        color = np.array([100, 50, 0])\n\n    h, w = mask.shape[-2:]\n    mask_image = mask.reshape(h, w, 1) * color.reshape(1, 1, -1)\n    mask_image = mask_image.astype(np.uint8)\n    return mask_image", "\n\ndef load_box(box, image):\n    x, y, w, h = int(box[0]), int(box[1]), int(box[2]), int(box[3])\n    cv2.rectangle(image, (x, y), (w, h), (0, 255, 0), 2)\n    return image\n\n\ndef plt_load_mask(mask, ax, random_color=False):\n    if random_color:\n        color = np.concatenate([np.random.random(3), np.array([0.6])], axis=0)\n    else:\n        color = np.array([30 / 255, 144 / 255, 255 / 255, 0.6])\n    h, w = mask.shape[-2:]\n    mask_image = mask.reshape(h, w, 1) * color.reshape(1, 1, -1)\n    ax.imshow(mask_image)", "def plt_load_mask(mask, ax, random_color=False):\n    if random_color:\n        color = np.concatenate([np.random.random(3), np.array([0.6])], axis=0)\n    else:\n        color = np.array([30 / 255, 144 / 255, 255 / 255, 0.6])\n    h, w = mask.shape[-2:]\n    mask_image = mask.reshape(h, w, 1) * color.reshape(1, 1, -1)\n    ax.imshow(mask_image)\n\n\ndef plt_load_box(box, ax):\n    x0, y0 = box[0], box[1]\n    w, h = box[2] - box[0], box[3] - box[1]\n    ax.add_patch(\n        plt.Rectangle((x0, y0), w, h, edgecolor=\"green\", facecolor=(0, 0, 0, 0), lw=2)\n    )", "\n\ndef plt_load_box(box, ax):\n    x0, y0 = box[0], box[1]\n    w, h = box[2] - box[0], box[3] - box[1]\n    ax.add_patch(\n        plt.Rectangle((x0, y0), w, h, edgecolor=\"green\", facecolor=(0, 0, 0, 0), lw=2)\n    )\n\n\ndef multi_boxes(boxes, predictor, image):\n    input_boxes = tensor(boxes, device=predictor.device)\n    transformed_boxes = predictor.transform.apply_boxes_torch(\n        input_boxes, image.shape[:2]\n    )\n    return input_boxes, transformed_boxes", "\n\ndef multi_boxes(boxes, predictor, image):\n    input_boxes = tensor(boxes, device=predictor.device)\n    transformed_boxes = predictor.transform.apply_boxes_torch(\n        input_boxes, image.shape[:2]\n    )\n    return input_boxes, transformed_boxes\n\n\ndef show_image(output_image):\n    cv2.imshow(\"output\", output_image)\n    cv2.waitKey(0)\n    cv2.destroyAllWindows()", "\n\ndef show_image(output_image):\n    cv2.imshow(\"output\", output_image)\n    cv2.waitKey(0)\n    cv2.destroyAllWindows()\n"]}
{"filename": "metaseg/utils/__init__.py", "chunked_list": ["# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom .data_utils import load_box as load_box\nfrom .data_utils import load_image as load_image\nfrom .data_utils import load_mask as load_mask\nfrom .data_utils import load_server_image as load_server_image", "from .data_utils import load_mask as load_mask\nfrom .data_utils import load_server_image as load_server_image\nfrom .data_utils import load_video as load_video\nfrom .data_utils import multi_boxes as multi_boxes\nfrom .data_utils import plt_load_box as plt_load_box\nfrom .data_utils import plt_load_mask as plt_load_mask\nfrom .data_utils import show_image as show_image\nfrom .model_file_downloader import download_model as download_model\nfrom .onnx import SamOnnxModel as SamOnnxModel\nfrom .transforms import ResizeLongestSide as ResizeLongestSide", "from .onnx import SamOnnxModel as SamOnnxModel\nfrom .transforms import ResizeLongestSide as ResizeLongestSide\n"]}
{"filename": "metaseg/utils/onnx.py", "chunked_list": ["# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom typing import Tuple\n\nimport torch\nimport torch.nn as nn", "import torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\n\nfrom metaseg.modeling import Sam\nfrom metaseg.utils.amg import calculate_stability_score\n\n\nclass SamOnnxModel(nn.Module):\n    \"\"\"\n    This model should not be called directly, but is used in ONNX export.\n    It combines the prompt encoder, mask decoder, and mask postprocessing of Sam,\n    with some functions modified to enable model tracing. Also supports extra\n    options controlling what information. See the ONNX export script for details.\n    \"\"\"\n\n    def __init__(\n        self,\n        model: Sam,\n        return_single_mask: bool,\n        use_stability_score: bool = False,\n        return_extra_metrics: bool = False,\n    ) -> None:\n        super().__init__()\n        self.mask_decoder = model.mask_decoder\n        self.model = model\n        self.img_size = model.image_encoder.img_size\n        self.return_single_mask = return_single_mask\n        self.use_stability_score = use_stability_score\n        self.stability_score_offset = 1.0\n        self.return_extra_metrics = return_extra_metrics\n\n    @staticmethod\n    def resize_longest_image_size(\n        input_image_size: torch.Tensor, longest_side: int\n    ) -> torch.Tensor:\n        input_image_size = input_image_size.to(torch.float32)\n        scale = longest_side / torch.max(input_image_size)\n        transformed_size = scale * input_image_size\n        transformed_size = torch.floor(transformed_size + 0.5).to(torch.int64)\n        return transformed_size\n\n    def _embed_points(\n        self, point_coords: torch.Tensor, point_labels: torch.Tensor\n    ) -> torch.Tensor:\n        point_coords = point_coords + 0.5\n        point_coords = point_coords / self.img_size\n        point_embedding = self.model.prompt_encoder.pe_layer._pe_encoding(point_coords)\n        point_labels = point_labels.unsqueeze(-1).expand_as(point_embedding)\n\n        point_embedding = point_embedding * (point_labels != -1)\n        point_embedding = (\n            point_embedding\n            + self.model.prompt_encoder.not_a_point_embed.weight * (point_labels == -1)\n        )\n\n        for i in range(self.model.prompt_encoder.num_point_embeddings):\n            point_embedding = (\n                point_embedding\n                + self.model.prompt_encoder.point_embeddings[i].weight\n                * (point_labels == i)\n            )\n\n        return point_embedding\n\n    def _embed_masks(\n        self, input_mask: torch.Tensor, has_mask_input: torch.Tensor\n    ) -> torch.Tensor:\n        mask_embedding = has_mask_input * self.model.prompt_encoder.mask_downscaling(\n            input_mask\n        )\n        mask_embedding = mask_embedding + (\n            1 - has_mask_input\n        ) * self.model.prompt_encoder.no_mask_embed.weight.reshape(1, -1, 1, 1)\n        return mask_embedding\n\n    def mask_postprocessing(\n        self, masks: torch.Tensor, orig_im_size: torch.Tensor\n    ) -> torch.Tensor:\n        masks = F.interpolate(\n            masks,\n            size=(self.img_size, self.img_size),\n            mode=\"bilinear\",\n            align_corners=False,\n        )\n\n        prepadded_size = self.resize_longest_image_size(orig_im_size, self.img_size)\n        masks = masks[..., : int(prepadded_size[0]), : int(prepadded_size[1])]\n\n        orig_im_size = orig_im_size.to(torch.int64)\n        h, w = orig_im_size[0], orig_im_size[1]\n        masks = F.interpolate(masks, size=(h, w), mode=\"bilinear\", align_corners=False)\n        return masks\n\n    def select_masks(\n        self, masks: torch.Tensor, iou_preds: torch.Tensor, num_points: int\n    ) -> Tuple[torch.Tensor, torch.Tensor]:\n        # Determine if we should return the multi click\n        # mask or not from the number of points.\n        # The reweighting is used to avoid control flow.\n        score_reweight = torch.tensor(\n            [[1000] + [0] * (self.model.mask_decoder.num_mask_tokens - 1)]\n        ).to(iou_preds.device)\n        score = iou_preds + (num_points - 2.5) * score_reweight\n        best_idx = torch.argmax(score, dim=1)\n        masks = masks[torch.arange(masks.shape[0]), best_idx, :, :].unsqueeze(1)\n        iou_preds = iou_preds[torch.arange(masks.shape[0]), best_idx].unsqueeze(1)\n\n        return masks, iou_preds\n\n    @torch.no_grad()\n    def forward(\n        self,\n        image_embeddings: torch.Tensor,\n        point_coords: torch.Tensor,\n        point_labels: torch.Tensor,\n        mask_input: torch.Tensor,\n        has_mask_input: torch.Tensor,\n        orig_im_size: torch.Tensor,\n    ):\n        sparse_embedding = self._embed_points(point_coords, point_labels)\n        dense_embedding = self._embed_masks(mask_input, has_mask_input)\n\n        masks, scores = self.model.mask_decoder.predict_masks(\n            image_embeddings=image_embeddings,\n            image_pe=self.model.prompt_encoder.get_dense_pe(),\n            sparse_prompt_embeddings=sparse_embedding,\n            dense_prompt_embeddings=dense_embedding,\n        )\n\n        if self.use_stability_score:\n            scores = calculate_stability_score(\n                masks, self.model.mask_threshold, self.stability_score_offset\n            )\n\n        if self.return_single_mask:\n            masks, scores = self.select_masks(masks, scores, point_coords.shape[1])\n\n        upscaled_masks = self.mask_postprocessing(masks, orig_im_size)\n\n        if self.return_extra_metrics:\n            stability_scores = calculate_stability_score(\n                upscaled_masks, self.model.mask_threshold, self.stability_score_offset\n            )\n            areas = (upscaled_masks > self.model.mask_threshold).sum(-1).sum(-1)\n            return upscaled_masks, scores, stability_scores, areas, masks\n\n        return upscaled_masks, scores, masks", "class SamOnnxModel(nn.Module):\n    \"\"\"\n    This model should not be called directly, but is used in ONNX export.\n    It combines the prompt encoder, mask decoder, and mask postprocessing of Sam,\n    with some functions modified to enable model tracing. Also supports extra\n    options controlling what information. See the ONNX export script for details.\n    \"\"\"\n\n    def __init__(\n        self,\n        model: Sam,\n        return_single_mask: bool,\n        use_stability_score: bool = False,\n        return_extra_metrics: bool = False,\n    ) -> None:\n        super().__init__()\n        self.mask_decoder = model.mask_decoder\n        self.model = model\n        self.img_size = model.image_encoder.img_size\n        self.return_single_mask = return_single_mask\n        self.use_stability_score = use_stability_score\n        self.stability_score_offset = 1.0\n        self.return_extra_metrics = return_extra_metrics\n\n    @staticmethod\n    def resize_longest_image_size(\n        input_image_size: torch.Tensor, longest_side: int\n    ) -> torch.Tensor:\n        input_image_size = input_image_size.to(torch.float32)\n        scale = longest_side / torch.max(input_image_size)\n        transformed_size = scale * input_image_size\n        transformed_size = torch.floor(transformed_size + 0.5).to(torch.int64)\n        return transformed_size\n\n    def _embed_points(\n        self, point_coords: torch.Tensor, point_labels: torch.Tensor\n    ) -> torch.Tensor:\n        point_coords = point_coords + 0.5\n        point_coords = point_coords / self.img_size\n        point_embedding = self.model.prompt_encoder.pe_layer._pe_encoding(point_coords)\n        point_labels = point_labels.unsqueeze(-1).expand_as(point_embedding)\n\n        point_embedding = point_embedding * (point_labels != -1)\n        point_embedding = (\n            point_embedding\n            + self.model.prompt_encoder.not_a_point_embed.weight * (point_labels == -1)\n        )\n\n        for i in range(self.model.prompt_encoder.num_point_embeddings):\n            point_embedding = (\n                point_embedding\n                + self.model.prompt_encoder.point_embeddings[i].weight\n                * (point_labels == i)\n            )\n\n        return point_embedding\n\n    def _embed_masks(\n        self, input_mask: torch.Tensor, has_mask_input: torch.Tensor\n    ) -> torch.Tensor:\n        mask_embedding = has_mask_input * self.model.prompt_encoder.mask_downscaling(\n            input_mask\n        )\n        mask_embedding = mask_embedding + (\n            1 - has_mask_input\n        ) * self.model.prompt_encoder.no_mask_embed.weight.reshape(1, -1, 1, 1)\n        return mask_embedding\n\n    def mask_postprocessing(\n        self, masks: torch.Tensor, orig_im_size: torch.Tensor\n    ) -> torch.Tensor:\n        masks = F.interpolate(\n            masks,\n            size=(self.img_size, self.img_size),\n            mode=\"bilinear\",\n            align_corners=False,\n        )\n\n        prepadded_size = self.resize_longest_image_size(orig_im_size, self.img_size)\n        masks = masks[..., : int(prepadded_size[0]), : int(prepadded_size[1])]\n\n        orig_im_size = orig_im_size.to(torch.int64)\n        h, w = orig_im_size[0], orig_im_size[1]\n        masks = F.interpolate(masks, size=(h, w), mode=\"bilinear\", align_corners=False)\n        return masks\n\n    def select_masks(\n        self, masks: torch.Tensor, iou_preds: torch.Tensor, num_points: int\n    ) -> Tuple[torch.Tensor, torch.Tensor]:\n        # Determine if we should return the multi click\n        # mask or not from the number of points.\n        # The reweighting is used to avoid control flow.\n        score_reweight = torch.tensor(\n            [[1000] + [0] * (self.model.mask_decoder.num_mask_tokens - 1)]\n        ).to(iou_preds.device)\n        score = iou_preds + (num_points - 2.5) * score_reweight\n        best_idx = torch.argmax(score, dim=1)\n        masks = masks[torch.arange(masks.shape[0]), best_idx, :, :].unsqueeze(1)\n        iou_preds = iou_preds[torch.arange(masks.shape[0]), best_idx].unsqueeze(1)\n\n        return masks, iou_preds\n\n    @torch.no_grad()\n    def forward(\n        self,\n        image_embeddings: torch.Tensor,\n        point_coords: torch.Tensor,\n        point_labels: torch.Tensor,\n        mask_input: torch.Tensor,\n        has_mask_input: torch.Tensor,\n        orig_im_size: torch.Tensor,\n    ):\n        sparse_embedding = self._embed_points(point_coords, point_labels)\n        dense_embedding = self._embed_masks(mask_input, has_mask_input)\n\n        masks, scores = self.model.mask_decoder.predict_masks(\n            image_embeddings=image_embeddings,\n            image_pe=self.model.prompt_encoder.get_dense_pe(),\n            sparse_prompt_embeddings=sparse_embedding,\n            dense_prompt_embeddings=dense_embedding,\n        )\n\n        if self.use_stability_score:\n            scores = calculate_stability_score(\n                masks, self.model.mask_threshold, self.stability_score_offset\n            )\n\n        if self.return_single_mask:\n            masks, scores = self.select_masks(masks, scores, point_coords.shape[1])\n\n        upscaled_masks = self.mask_postprocessing(masks, orig_im_size)\n\n        if self.return_extra_metrics:\n            stability_scores = calculate_stability_score(\n                upscaled_masks, self.model.mask_threshold, self.stability_score_offset\n            )\n            areas = (upscaled_masks > self.model.mask_threshold).sum(-1).sum(-1)\n            return upscaled_masks, scores, stability_scores, areas, masks\n\n        return upscaled_masks, scores, masks", ""]}
{"filename": "metaseg/utils/amg.py", "chunked_list": ["# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport math\nfrom copy import deepcopy\nfrom itertools import product\nfrom typing import Any, Dict, Generator, ItemsView, List, Tuple", "from itertools import product\nfrom typing import Any, Dict, Generator, ItemsView, List, Tuple\n\nimport cv2\nimport numpy as np\nimport torch\nfrom pycocotools import mask as mask_utils\n\n\nclass MaskData:\n    \"\"\"\n    A structure for storing masks and their related data in batched format.\n    Implements basic filtering and concatenation.\n    \"\"\"\n\n    def __init__(self, **kwargs) -> None:\n        for v in kwargs.values():\n            assert isinstance(\n                v, (list, np.ndarray, torch.Tensor)\n            ), \"MaskData only supports list, numpy arrays, and torch tensors.\"\n        self._stats = dict(**kwargs)\n\n    def __setitem__(self, key: str, item: Any) -> None:\n        assert isinstance(\n            item, (list, np.ndarray, torch.Tensor)\n        ), \"MaskData only supports list, numpy arrays, and torch tensors.\"\n        self._stats[key] = item\n\n    def __delitem__(self, key: str) -> None:\n        del self._stats[key]\n\n    def __getitem__(self, key: str) -> Any:\n        return self._stats[key]\n\n    def items(self) -> ItemsView[str, Any]:\n        return self._stats.items()\n\n    def filter(self, keep: torch.Tensor) -> None:\n        for k, v in self._stats.items():\n            if v is None:\n                self._stats[k] = None\n            elif isinstance(v, torch.Tensor):\n                self._stats[k] = v[torch.as_tensor(keep, device=v.device)]\n            elif isinstance(v, np.ndarray):\n                self._stats[k] = v[keep.detach().cpu().numpy()]\n            elif isinstance(v, list) and keep.dtype == torch.bool:\n                self._stats[k] = [a for i, a in enumerate(v) if keep[i]]\n            elif isinstance(v, list):\n                self._stats[k] = [v[i] for i in keep]\n            else:\n                raise TypeError(f\"MaskData key {k} has an unsupported type {type(v)}.\")\n\n    def cat(self, new_stats: \"MaskData\") -> None:\n        for k, v in new_stats.items():\n            if k not in self._stats or self._stats[k] is None:\n                self._stats[k] = deepcopy(v)\n            elif isinstance(v, torch.Tensor):\n                self._stats[k] = torch.cat([self._stats[k], v], dim=0)\n            elif isinstance(v, np.ndarray):\n                self._stats[k] = np.concatenate([self._stats[k], v], axis=0)\n            elif isinstance(v, list):\n                self._stats[k] = self._stats[k] + deepcopy(v)\n            else:\n                raise TypeError(f\"MaskData key {k} has an unsupported type {type(v)}.\")\n\n    def to_numpy(self) -> None:\n        for k, v in self._stats.items():\n            if isinstance(v, torch.Tensor):\n                self._stats[k] = v.detach().cpu().numpy()", "\nclass MaskData:\n    \"\"\"\n    A structure for storing masks and their related data in batched format.\n    Implements basic filtering and concatenation.\n    \"\"\"\n\n    def __init__(self, **kwargs) -> None:\n        for v in kwargs.values():\n            assert isinstance(\n                v, (list, np.ndarray, torch.Tensor)\n            ), \"MaskData only supports list, numpy arrays, and torch tensors.\"\n        self._stats = dict(**kwargs)\n\n    def __setitem__(self, key: str, item: Any) -> None:\n        assert isinstance(\n            item, (list, np.ndarray, torch.Tensor)\n        ), \"MaskData only supports list, numpy arrays, and torch tensors.\"\n        self._stats[key] = item\n\n    def __delitem__(self, key: str) -> None:\n        del self._stats[key]\n\n    def __getitem__(self, key: str) -> Any:\n        return self._stats[key]\n\n    def items(self) -> ItemsView[str, Any]:\n        return self._stats.items()\n\n    def filter(self, keep: torch.Tensor) -> None:\n        for k, v in self._stats.items():\n            if v is None:\n                self._stats[k] = None\n            elif isinstance(v, torch.Tensor):\n                self._stats[k] = v[torch.as_tensor(keep, device=v.device)]\n            elif isinstance(v, np.ndarray):\n                self._stats[k] = v[keep.detach().cpu().numpy()]\n            elif isinstance(v, list) and keep.dtype == torch.bool:\n                self._stats[k] = [a for i, a in enumerate(v) if keep[i]]\n            elif isinstance(v, list):\n                self._stats[k] = [v[i] for i in keep]\n            else:\n                raise TypeError(f\"MaskData key {k} has an unsupported type {type(v)}.\")\n\n    def cat(self, new_stats: \"MaskData\") -> None:\n        for k, v in new_stats.items():\n            if k not in self._stats or self._stats[k] is None:\n                self._stats[k] = deepcopy(v)\n            elif isinstance(v, torch.Tensor):\n                self._stats[k] = torch.cat([self._stats[k], v], dim=0)\n            elif isinstance(v, np.ndarray):\n                self._stats[k] = np.concatenate([self._stats[k], v], axis=0)\n            elif isinstance(v, list):\n                self._stats[k] = self._stats[k] + deepcopy(v)\n            else:\n                raise TypeError(f\"MaskData key {k} has an unsupported type {type(v)}.\")\n\n    def to_numpy(self) -> None:\n        for k, v in self._stats.items():\n            if isinstance(v, torch.Tensor):\n                self._stats[k] = v.detach().cpu().numpy()", "\n\ndef is_box_near_crop_edge(\n    boxes: torch.Tensor, crop_box: List[int], orig_box: List[int], atol: float = 20.0\n) -> torch.Tensor:\n    \"\"\"Filter masks at the edge of a crop, but not at the edge of the original image.\"\"\"\n    crop_box_torch = torch.as_tensor(crop_box, dtype=torch.float, device=boxes.device)\n    orig_box_torch = torch.as_tensor(orig_box, dtype=torch.float, device=boxes.device)\n    boxes = uncrop_boxes_xyxy(boxes, crop_box).float()\n    near_crop_edge = torch.isclose(boxes, crop_box_torch[None, :], atol=atol, rtol=0)\n    near_image_edge = torch.isclose(boxes, orig_box_torch[None, :], atol=atol, rtol=0)\n    near_crop_edge = torch.logical_and(near_crop_edge, ~near_image_edge)\n    return torch.any(near_crop_edge, dim=1)", "\n\ndef box_xyxy_to_xywh(box_xyxy: torch.Tensor) -> torch.Tensor:\n    box_xywh = deepcopy(box_xyxy)\n    box_xywh[2] = box_xywh[2] - box_xywh[0]\n    box_xywh[3] = box_xywh[3] - box_xywh[1]\n    return box_xywh\n\n\ndef batch_iterator(batch_size: int, *args) -> Generator[List[Any], None, None]:\n    assert len(args) > 0 and all(\n        len(a) == len(args[0]) for a in args\n    ), \"Batched iteration must have inputs of all the same size.\"\n    n_batches = len(args[0]) // batch_size + int(len(args[0]) % batch_size != 0)\n    for b in range(n_batches):\n        yield [arg[b * batch_size : (b + 1) * batch_size] for arg in args]", "\ndef batch_iterator(batch_size: int, *args) -> Generator[List[Any], None, None]:\n    assert len(args) > 0 and all(\n        len(a) == len(args[0]) for a in args\n    ), \"Batched iteration must have inputs of all the same size.\"\n    n_batches = len(args[0]) // batch_size + int(len(args[0]) % batch_size != 0)\n    for b in range(n_batches):\n        yield [arg[b * batch_size : (b + 1) * batch_size] for arg in args]\n\n\ndef mask_to_rle_pytorch(tensor: torch.Tensor) -> List[Dict[str, Any]]:\n    \"\"\"\n    Encodes masks to an uncompressed RLE, in the format expected by\n    pycoco tools.\n    \"\"\"\n    # Put in fortran order and flatten h,w\n    b, h, w = tensor.shape\n    tensor = tensor.permute(0, 2, 1).flatten(1)\n\n    # Compute change indices\n    diff = tensor[:, 1:] ^ tensor[:, :-1]\n    change_indices = diff.nonzero()\n\n    # Encode run length\n    out = []\n    for i in range(b):\n        cur_idxs = change_indices[change_indices[:, 0] == i, 1]\n        cur_idxs = torch.cat(\n            [\n                torch.tensor([0], dtype=cur_idxs.dtype, device=cur_idxs.device),\n                cur_idxs + 1,\n                torch.tensor([h * w], dtype=cur_idxs.dtype, device=cur_idxs.device),\n            ]\n        )\n        btw_idxs = cur_idxs[1:] - cur_idxs[:-1]\n        counts = [] if tensor[i, 0] == 0 else [0]\n        counts.extend(btw_idxs.detach().cpu().tolist())\n        out.append({\"size\": [h, w], \"counts\": counts})\n    return out", "\n\ndef mask_to_rle_pytorch(tensor: torch.Tensor) -> List[Dict[str, Any]]:\n    \"\"\"\n    Encodes masks to an uncompressed RLE, in the format expected by\n    pycoco tools.\n    \"\"\"\n    # Put in fortran order and flatten h,w\n    b, h, w = tensor.shape\n    tensor = tensor.permute(0, 2, 1).flatten(1)\n\n    # Compute change indices\n    diff = tensor[:, 1:] ^ tensor[:, :-1]\n    change_indices = diff.nonzero()\n\n    # Encode run length\n    out = []\n    for i in range(b):\n        cur_idxs = change_indices[change_indices[:, 0] == i, 1]\n        cur_idxs = torch.cat(\n            [\n                torch.tensor([0], dtype=cur_idxs.dtype, device=cur_idxs.device),\n                cur_idxs + 1,\n                torch.tensor([h * w], dtype=cur_idxs.dtype, device=cur_idxs.device),\n            ]\n        )\n        btw_idxs = cur_idxs[1:] - cur_idxs[:-1]\n        counts = [] if tensor[i, 0] == 0 else [0]\n        counts.extend(btw_idxs.detach().cpu().tolist())\n        out.append({\"size\": [h, w], \"counts\": counts})\n    return out", "\n\ndef rle_to_mask(rle: Dict[str, Any]) -> np.ndarray:\n    \"\"\"Compute a binary mask from an uncompressed RLE.\"\"\"\n    h, w = rle[\"size\"]\n    mask = np.empty(h * w, dtype=bool)\n    idx = 0\n    parity = False\n    for count in rle[\"counts\"]:\n        mask[idx : idx + count] = parity\n        idx += count\n        parity ^= True\n    mask = mask.reshape(w, h)\n    return mask.transpose()  # Put in C order", "\n\ndef area_from_rle(rle: Dict[str, Any]) -> int:\n    return sum(rle[\"counts\"][1::2])\n\n\ndef calculate_stability_score(\n    masks: torch.Tensor, mask_threshold: float, threshold_offset: float\n) -> torch.Tensor:\n    \"\"\"\n    Computes the stability score for a batch of masks. The stability\n    score is the IoU between the binary masks obtained by thresholding\n    the predicted mask logits at high and low values.\n    \"\"\"\n    # One mask is always contained inside the other.\n    # Save memory by preventing unnecesary cast to torch.int64\n    intersections = (\n        (masks > (mask_threshold + threshold_offset))\n        .sum(-1, dtype=torch.int16)\n        .sum(-1, dtype=torch.int32)\n    )\n    unions = (\n        (masks > (mask_threshold - threshold_offset))\n        .sum(-1, dtype=torch.int16)\n        .sum(-1, dtype=torch.int32)\n    )\n    return intersections / unions", "\n\ndef build_point_grid(n_per_side: int) -> np.ndarray:\n    \"\"\"Generates a 2D grid of points evenly spaced in [0,1]x[0,1].\"\"\"\n    offset = 1 / (2 * n_per_side)\n    points_one_side = np.linspace(offset, 1 - offset, n_per_side)\n    points_x = np.tile(points_one_side[None, :], (n_per_side, 1))\n    points_y = np.tile(points_one_side[:, None], (1, n_per_side))\n    points = np.stack([points_x, points_y], axis=-1).reshape(-1, 2)\n    return points", "\n\ndef build_all_layer_point_grids(\n    n_per_side: int, n_layers: int, scale_per_layer: int\n) -> List[np.ndarray]:\n    \"\"\"Generates point grids for all crop layers.\"\"\"\n    points_by_layer = []\n    for i in range(n_layers + 1):\n        n_points = int(n_per_side / (scale_per_layer**i))\n        points_by_layer.append(build_point_grid(n_points))\n    return points_by_layer", "\n\ndef generate_crop_boxes(\n    im_size: Tuple[int, ...], n_layers: int, overlap_ratio: float\n) -> Tuple[List[List[int]], List[int]]:\n    \"\"\"\n    Generates a list of crop boxes of different sizes. Each layer\n    has (2**i)**2 boxes for the ith layer.\n    \"\"\"\n    crop_boxes, layer_idxs = [], []\n    im_h, im_w = im_size\n    short_side = min(im_h, im_w)\n\n    # Original image\n    crop_boxes.append([0, 0, im_w, im_h])\n    layer_idxs.append(0)\n\n    def crop_len(orig_len, n_crops, overlap):\n        return int(math.ceil((overlap * (n_crops - 1) + orig_len) / n_crops))\n\n    for i_layer in range(n_layers):\n        n_crops_per_side = 2 ** (i_layer + 1)\n        overlap = int(overlap_ratio * short_side * (2 / n_crops_per_side))\n\n        crop_w = crop_len(im_w, n_crops_per_side, overlap)\n        crop_h = crop_len(im_h, n_crops_per_side, overlap)\n\n        crop_box_x0 = [int((crop_w - overlap) * i) for i in range(n_crops_per_side)]\n        crop_box_y0 = [int((crop_h - overlap) * i) for i in range(n_crops_per_side)]\n\n        # Crops in XYWH format\n        for x0, y0 in product(crop_box_x0, crop_box_y0):\n            box = [x0, y0, min(x0 + crop_w, im_w), min(y0 + crop_h, im_h)]\n            crop_boxes.append(box)\n            layer_idxs.append(i_layer + 1)\n\n    return crop_boxes, layer_idxs", "\n\ndef uncrop_boxes_xyxy(boxes: torch.Tensor, crop_box: List[int]) -> torch.Tensor:\n    x0, y0, _, _ = crop_box\n    offset = torch.tensor([[x0, y0, x0, y0]], device=boxes.device)\n    # Check if boxes has a channel dimension\n    if len(boxes.shape) == 3:\n        offset = offset.unsqueeze(1)\n    return boxes + offset\n", "\n\ndef uncrop_points(points: torch.Tensor, crop_box: List[int]) -> torch.Tensor:\n    x0, y0, _, _ = crop_box\n    offset = torch.tensor([[x0, y0]], device=points.device)\n    # Check if points has a channel dimension\n    if len(points.shape) == 3:\n        offset = offset.unsqueeze(1)\n    return points + offset\n", "\n\ndef uncrop_masks(\n    masks: torch.Tensor, crop_box: List[int], orig_h: int, orig_w: int\n) -> torch.Tensor:\n    x0, y0, x1, y1 = crop_box\n    if x0 == 0 and y0 == 0 and x1 == orig_w and y1 == orig_h:\n        return masks\n    # Coordinate transform masks\n    pad_x, pad_y = orig_w - (x1 - x0), orig_h - (y1 - y0)\n    pad = (x0, pad_x - x0, y0, pad_y - y0)\n    return torch.nn.functional.pad(masks, pad, value=0)", "\n\ndef remove_small_regions(\n    mask: np.ndarray, area_thresh: float, mode: str\n) -> Tuple[np.ndarray, bool]:\n    \"\"\"\n    Removes small disconnected regions and holes in a mask. Returns the\n    mask and an indicator of if the mask has been modified.\n    \"\"\"\n\n    assert mode in [\"holes\", \"islands\"]\n    correct_holes = mode == \"holes\"\n    working_mask = (correct_holes ^ mask).astype(np.uint8)\n    n_labels, regions, stats, _ = cv2.connectedComponentsWithStats(working_mask, 8)\n    sizes = stats[:, -1][1:]  # Row 0 is background label\n    small_regions = [i + 1 for i, s in enumerate(sizes) if s < area_thresh]\n    if len(small_regions) == 0:\n        return mask, False\n    fill_labels = [0] + small_regions\n    if not correct_holes:\n        fill_labels = [i for i in range(n_labels) if i not in fill_labels]\n        # If every region is below threshold, keep largest\n        if len(fill_labels) == 0:\n            fill_labels = [int(np.argmax(sizes)) + 1]\n    mask = np.isin(regions, fill_labels)\n    return mask, True", "\n\ndef coco_encode_rle(uncompressed_rle: Dict[str, Any]) -> Dict[str, Any]:\n    h, w = uncompressed_rle[\"size\"]\n    rle = mask_utils.frPyObjects(uncompressed_rle, h, w)\n    rle[\"counts\"] = rle[\"counts\"].decode(\"utf-8\")  # Necessary to serialize with json\n    return rle\n\n\ndef batched_mask_to_box(masks: torch.Tensor) -> torch.Tensor:\n    \"\"\"\n    Calculates boxes in XYXY format around masks. Return [0,0,0,0] for\n    an empty mask. For input shape C1xC2x...xHxW, the output shape is C1xC2x...x4.\n    \"\"\"\n    # torch.max below raises an error on empty inputs, just skip in this case\n    if torch.numel(masks) == 0:\n        return torch.zeros(*masks.shape[:-2], 4, device=masks.device)\n\n    # Normalize shape to CxHxW\n    shape = masks.shape\n    h, w = shape[-2:]\n    if len(shape) > 2:\n        masks = masks.flatten(0, -3)\n    else:\n        masks = masks.unsqueeze(0)\n\n    # Get top and bottom edges\n    in_height, _ = torch.max(masks, dim=-1)\n    in_height_coords = in_height * torch.arange(h, device=in_height.device)[None, :]\n    bottom_edges, _ = torch.max(in_height_coords, dim=-1)\n    in_height_coords = in_height_coords + h * (~in_height)\n    top_edges, _ = torch.min(in_height_coords, dim=-1)\n\n    # Get left and right edges\n    in_width, _ = torch.max(masks, dim=-2)\n    in_width_coords = in_width * torch.arange(w, device=in_width.device)[None, :]\n    right_edges, _ = torch.max(in_width_coords, dim=-1)\n    in_width_coords = in_width_coords + w * (~in_width)\n    left_edges, _ = torch.min(in_width_coords, dim=-1)\n\n    # If the mask is empty the right edge will be to the left of the left edge.\n    # Replace these boxes with [0, 0, 0, 0]\n    empty_filter = (right_edges < left_edges) | (bottom_edges < top_edges)\n    out = torch.stack([left_edges, top_edges, right_edges, bottom_edges], dim=-1)\n    out = out * (~empty_filter).unsqueeze(-1)\n\n    # Return to original shape\n    if len(shape) > 2:\n        out = out.reshape(*shape[:-2], 4)\n    else:\n        out = out[0]\n\n    return out", "\ndef batched_mask_to_box(masks: torch.Tensor) -> torch.Tensor:\n    \"\"\"\n    Calculates boxes in XYXY format around masks. Return [0,0,0,0] for\n    an empty mask. For input shape C1xC2x...xHxW, the output shape is C1xC2x...x4.\n    \"\"\"\n    # torch.max below raises an error on empty inputs, just skip in this case\n    if torch.numel(masks) == 0:\n        return torch.zeros(*masks.shape[:-2], 4, device=masks.device)\n\n    # Normalize shape to CxHxW\n    shape = masks.shape\n    h, w = shape[-2:]\n    if len(shape) > 2:\n        masks = masks.flatten(0, -3)\n    else:\n        masks = masks.unsqueeze(0)\n\n    # Get top and bottom edges\n    in_height, _ = torch.max(masks, dim=-1)\n    in_height_coords = in_height * torch.arange(h, device=in_height.device)[None, :]\n    bottom_edges, _ = torch.max(in_height_coords, dim=-1)\n    in_height_coords = in_height_coords + h * (~in_height)\n    top_edges, _ = torch.min(in_height_coords, dim=-1)\n\n    # Get left and right edges\n    in_width, _ = torch.max(masks, dim=-2)\n    in_width_coords = in_width * torch.arange(w, device=in_width.device)[None, :]\n    right_edges, _ = torch.max(in_width_coords, dim=-1)\n    in_width_coords = in_width_coords + w * (~in_width)\n    left_edges, _ = torch.min(in_width_coords, dim=-1)\n\n    # If the mask is empty the right edge will be to the left of the left edge.\n    # Replace these boxes with [0, 0, 0, 0]\n    empty_filter = (right_edges < left_edges) | (bottom_edges < top_edges)\n    out = torch.stack([left_edges, top_edges, right_edges, bottom_edges], dim=-1)\n    out = out * (~empty_filter).unsqueeze(-1)\n\n    # Return to original shape\n    if len(shape) > 2:\n        out = out.reshape(*shape[:-2], 4)\n    else:\n        out = out[0]\n\n    return out", ""]}
{"filename": "metaseg/generator/build_sam.py", "chunked_list": ["# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom functools import partial\n\nimport torch\n", "import torch\n\nfrom metaseg.modeling import (\n    ImageEncoderViT,\n    MaskDecoder,\n    PromptEncoder,\n    Sam,\n    TwoWayTransformer,\n)\n", ")\n\n\ndef build_sam_vit_h(checkpoint=None):\n    return _build_sam(\n        encoder_embed_dim=1280,\n        encoder_depth=32,\n        encoder_num_heads=16,\n        encoder_global_attn_indexes=[7, 15, 23, 31],\n        checkpoint=checkpoint,\n    )", "\n\nbuild_sam = build_sam_vit_h\n\n\ndef build_sam_vit_l(checkpoint=None):\n    return _build_sam(\n        encoder_embed_dim=1024,\n        encoder_depth=24,\n        encoder_num_heads=16,\n        encoder_global_attn_indexes=[5, 11, 17, 23],\n        checkpoint=checkpoint,\n    )", "\n\ndef build_sam_vit_b(checkpoint=None):\n    return _build_sam(\n        encoder_embed_dim=768,\n        encoder_depth=12,\n        encoder_num_heads=12,\n        encoder_global_attn_indexes=[2, 5, 8, 11],\n        checkpoint=checkpoint,\n    )", "\n\nbuild_sam_vit_h = {\n    \"default\": build_sam,\n    \"vit_h\": build_sam,\n    \"vit_l\": build_sam_vit_l,\n    \"vit_b\": build_sam_vit_b,\n}\n\nsam_model_registry = {", "\nsam_model_registry = {\n    \"default\": build_sam,\n    \"vit_h\": build_sam,\n    \"vit_l\": build_sam_vit_l,\n    \"vit_b\": build_sam_vit_b,\n}\n\n\ndef _build_sam(\n    encoder_embed_dim,\n    encoder_depth,\n    encoder_num_heads,\n    encoder_global_attn_indexes,\n    checkpoint=None,\n):\n    prompt_embed_dim = 256\n    image_size = 1024\n    vit_patch_size = 16\n    image_embedding_size = image_size // vit_patch_size\n    sam = Sam(\n        image_encoder=ImageEncoderViT(\n            depth=encoder_depth,\n            embed_dim=encoder_embed_dim,\n            img_size=image_size,\n            mlp_ratio=4,\n            norm_layer=partial(torch.nn.LayerNorm, eps=1e-6),\n            num_heads=encoder_num_heads,\n            patch_size=vit_patch_size,\n            qkv_bias=True,\n            use_rel_pos=True,\n            global_attn_indexes=encoder_global_attn_indexes,\n            window_size=14,\n            out_chans=prompt_embed_dim,\n        ),\n        prompt_encoder=PromptEncoder(\n            embed_dim=prompt_embed_dim,\n            image_embedding_size=(image_embedding_size, image_embedding_size),\n            input_image_size=(image_size, image_size),\n            mask_in_chans=16,\n        ),\n        mask_decoder=MaskDecoder(\n            num_multimask_outputs=3,\n            transformer=TwoWayTransformer(\n                depth=2,\n                embedding_dim=prompt_embed_dim,\n                mlp_dim=2048,\n                num_heads=8,\n            ),\n            transformer_dim=prompt_embed_dim,\n            iou_head_depth=3,\n            iou_head_hidden_dim=256,\n        ),\n        pixel_mean=[123.675, 116.28, 103.53],\n        pixel_std=[58.395, 57.12, 57.375],\n    )\n    sam.eval()\n    if checkpoint is not None:\n        with open(checkpoint, \"rb\") as f:\n            state_dict = torch.load(f)\n        sam.load_state_dict(state_dict)\n    return sam", "\ndef _build_sam(\n    encoder_embed_dim,\n    encoder_depth,\n    encoder_num_heads,\n    encoder_global_attn_indexes,\n    checkpoint=None,\n):\n    prompt_embed_dim = 256\n    image_size = 1024\n    vit_patch_size = 16\n    image_embedding_size = image_size // vit_patch_size\n    sam = Sam(\n        image_encoder=ImageEncoderViT(\n            depth=encoder_depth,\n            embed_dim=encoder_embed_dim,\n            img_size=image_size,\n            mlp_ratio=4,\n            norm_layer=partial(torch.nn.LayerNorm, eps=1e-6),\n            num_heads=encoder_num_heads,\n            patch_size=vit_patch_size,\n            qkv_bias=True,\n            use_rel_pos=True,\n            global_attn_indexes=encoder_global_attn_indexes,\n            window_size=14,\n            out_chans=prompt_embed_dim,\n        ),\n        prompt_encoder=PromptEncoder(\n            embed_dim=prompt_embed_dim,\n            image_embedding_size=(image_embedding_size, image_embedding_size),\n            input_image_size=(image_size, image_size),\n            mask_in_chans=16,\n        ),\n        mask_decoder=MaskDecoder(\n            num_multimask_outputs=3,\n            transformer=TwoWayTransformer(\n                depth=2,\n                embedding_dim=prompt_embed_dim,\n                mlp_dim=2048,\n                num_heads=8,\n            ),\n            transformer_dim=prompt_embed_dim,\n            iou_head_depth=3,\n            iou_head_hidden_dim=256,\n        ),\n        pixel_mean=[123.675, 116.28, 103.53],\n        pixel_std=[58.395, 57.12, 57.375],\n    )\n    sam.eval()\n    if checkpoint is not None:\n        with open(checkpoint, \"rb\") as f:\n            state_dict = torch.load(f)\n        sam.load_state_dict(state_dict)\n    return sam", ""]}
{"filename": "metaseg/generator/__init__.py", "chunked_list": ["from .automatic_mask_generator import (\n    SamAutomaticMaskGenerator as SamAutomaticMaskGenerator,\n)\nfrom .build_sam import build_sam as build_sam\nfrom .build_sam import build_sam_vit_b as build_sam_vit_b\nfrom .build_sam import build_sam_vit_h as build_sam_vit_h\nfrom .build_sam import build_sam_vit_l as build_sam_vit_l\nfrom .build_sam import sam_model_registry as sam_model_registry\nfrom .predictor import SamPredictor as SamPredictor\n", "from .predictor import SamPredictor as SamPredictor\n"]}
{"filename": "metaseg/generator/predictor.py", "chunked_list": ["# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom typing import Optional, Tuple\n\nimport numpy as np\nimport torch", "import numpy as np\nimport torch\n\nfrom metaseg.modeling import Sam\nfrom metaseg.utils.transforms import ResizeLongestSide\n\n\nclass SamPredictor:\n    def __init__(\n        self,\n        sam_model: Sam,\n    ) -> None:\n        \"\"\"\n        Uses SAM to calculate the image embedding for an image, and then\n        allow repeated, efficient mask prediction given prompts.\n\n        Arguments:\n          sam_model (Sam): The model to use for mask prediction.\n        \"\"\"\n        super().__init__()\n        self.model = sam_model\n        self.transform = ResizeLongestSide(sam_model.image_encoder.img_size)\n        self.reset_image()\n\n    def set_image(\n        self,\n        image: np.ndarray,\n        image_format: str = \"RGB\",\n    ) -> None:\n        \"\"\"\n        Calculates the image embeddings for the provided image, allowing\n        masks to be predicted with the 'predict' method.\n\n        Arguments:\n          image (np.ndarray): The image for calculating masks. Expects an\n            image in HWC uint8 format, with pixel values in [0, 255].\n          image_format (str): The color format of the image, in ['RGB', 'BGR'].\n        \"\"\"\n        assert image_format in [\n            \"RGB\",\n            \"BGR\",\n        ], f\"image_format must be in ['RGB', 'BGR'], is {image_format}.\"\n        if image_format != self.model.image_format:\n            image = image[..., ::-1]\n\n        # Transform the image to the form expected by the model\n        input_image = self.transform.apply_image(image)\n        input_image_torch = torch.as_tensor(input_image, device=self.device)\n        input_image_torch = input_image_torch.permute(2, 0, 1).contiguous()[\n            None, :, :, :\n        ]\n\n        self.set_torch_image(input_image_torch, image.shape[:2])\n\n    @torch.no_grad()\n    def set_torch_image(\n        self,\n        transformed_image: torch.Tensor,\n        original_image_size: Tuple[int, ...],\n    ) -> None:\n        \"\"\"\n        Calculates the image embeddings for the provided image, allowing\n        masks to be predicted with the 'predict' method. Expects the input\n        image to be already transformed to the format expected by the model.\n\n        Arguments:\n          transformed_image (torch.Tensor): The input image, with shape\n            1x3xHxW, which has been transformed with ResizeLongestSide.\n          original_image_size (tuple(int, int)): The size of the image\n            before transformation, in (H, W) format.\n        \"\"\"\n        assert (\n            len(transformed_image.shape) == 4\n            and transformed_image.shape[1] == 3\n            and max(*transformed_image.shape[2:]) == self.model.image_encoder.img_size\n        ), (\n            f\"set_torch_image input must be BCHW with long side \"\n            f\"{self.model.image_encoder.img_size}.\"\n        )\n        self.reset_image()\n\n        self.original_size = original_image_size\n        self.input_size = tuple(transformed_image.shape[-2:])\n        input_image = self.model.preprocess(transformed_image)\n        self.features = self.model.image_encoder(input_image)\n        self.is_image_set = True\n\n    def predict(\n        self,\n        point_coords: Optional[np.ndarray] = None,\n        point_labels: Optional[np.ndarray] = None,\n        box: Optional[np.ndarray] = None,\n        mask_input: Optional[np.ndarray] = None,\n        multimask_output: bool = True,\n        return_logits: bool = False,\n    ) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n        \"\"\"\n        Predict masks for the given input prompts, using the currently set image.\n\n        Arguments:\n          point_coords (np.ndarray or None): A Nx2 array of point prompts to the\n            model. Each point is in (X,Y) in pixels.\n          point_labels (np.ndarray or None): A length N array of labels for the\n            point prompts. 1 indicates a foreground point and 0 indicates a\n            background point.\n          box (np.ndarray or None): A length 4 array given a box prompt to the\n            model, in XYXY format.\n          mask_input (np.ndarray): A low resolution mask input to the model, typically\n            coming from a previous prediction iteration. Has form 1xHxW, where\n            for SAM, H=W=256.\n          multimask_output (bool): If true, the model will return three masks.\n            For ambiguous input prompts (such as a single click), this will often\n            produce better masks than a single prediction. If only a single\n            mask is needed, the model's predicted quality score can be used\n            to select the best mask. For non-ambiguous prompts, such as multiple\n            input prompts, multimask_output=False can give better results.\n          return_logits (bool): If true, returns un-thresholded masks logits\n            instead of a binary mask.\n\n        Returns:\n          (np.ndarray): The output masks in CxHxW format, where C is the\n            number of masks, and (H, W) is the original image size.\n          (np.ndarray): An array of length C containing the model's\n            predictions for the quality of each mask.\n          (np.ndarray): An array of shape CxHxW, where C is the number\n            of masks and H=W=256. These low resolution logits can be passed to\n            a subsequent iteration as mask input.\n        \"\"\"\n        if not self.is_image_set:\n            raise RuntimeError(\n                \"An image must be set with .set_image(...) before mask prediction.\"\n            )\n\n        # Transform input prompts\n        coords_torch, labels_torch, box_torch, mask_input_torch = None, None, None, None\n        if point_coords is not None:\n            assert (\n                point_labels is not None\n            ), \"point_labels must be supplied if point_coords is supplied.\"\n            point_coords = self.transform.apply_coords(point_coords, self.original_size)\n            coords_torch = torch.as_tensor(\n                point_coords, dtype=torch.float, device=self.device\n            )\n            labels_torch = torch.as_tensor(\n                point_labels, dtype=torch.int, device=self.device\n            )\n            coords_torch, labels_torch = coords_torch[None, :, :], labels_torch[None, :]\n        if box is not None:\n            box = self.transform.apply_boxes(box, self.original_size)\n            box_torch = torch.as_tensor(box, dtype=torch.float, device=self.device)\n            box_torch = box_torch[None, :]\n        if mask_input is not None:\n            mask_input_torch = torch.as_tensor(\n                mask_input, dtype=torch.float, device=self.device\n            )\n            mask_input_torch = mask_input_torch[None, :, :, :]\n\n        masks, iou_predictions, low_res_masks = self.predict_torch(\n            coords_torch,\n            labels_torch,\n            box_torch,\n            mask_input_torch,\n            multimask_output,\n            return_logits=return_logits,\n        )\n\n        masks = masks[0].detach().cpu().numpy()\n        iou_predictions = iou_predictions[0].detach().cpu().numpy()\n        low_res_masks = low_res_masks[0].detach().cpu().numpy()\n        return masks, iou_predictions, low_res_masks\n\n    @torch.no_grad()\n    def predict_torch(\n        self,\n        point_coords: Optional[torch.Tensor],\n        point_labels: Optional[torch.Tensor],\n        boxes: Optional[torch.Tensor] = None,\n        mask_input: Optional[torch.Tensor] = None,\n        multimask_output: bool = True,\n        return_logits: bool = False,\n    ) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n        \"\"\"\n        Predict masks for the given input prompts, using the currently set image.\n        Input prompts are batched torch tensors and are expected to already be\n        transformed to the input frame using ResizeLongestSide.\n\n        Arguments:\n          point_coords (torch.Tensor or None): A BxNx2 array of point prompts to the\n            model. Each point is in (X,Y) in pixels.\n          point_labels (torch.Tensor or None): A BxN array of labels for the\n            point prompts. 1 indicates a foreground point and 0 indicates a\n            background point.\n          box (np.ndarray or None): A Bx4 array given a box prompt to the\n            model, in XYXY format.\n          mask_input (np.ndarray): A low resolution mask input to the model, typically\n            coming from a previous prediction iteration. Has form Bx1xHxW, where\n            for SAM, H=W=256. Masks returned by a previous iteration of the\n            predict method do not need further transformation.\n          multimask_output (bool): If true, the model will return three masks.\n            For ambiguous input prompts (such as a single click), this will often\n            produce better masks than a single prediction. If only a single\n            mask is needed, the model's predicted quality score can be used\n            to select the best mask. For non-ambiguous prompts, such as multiple\n            input prompts, multimask_output=False can give better results.\n          return_logits (bool): If true, returns un-thresholded masks logits\n            instead of a binary mask.\n\n        Returns:\n          (torch.Tensor): The output masks in BxCxHxW format, where C is the\n            number of masks, and (H, W) is the original image size.\n          (torch.Tensor): An array of shape BxC containing the model's\n            predictions for the quality of each mask.\n          (torch.Tensor): An array of shape BxCxHxW, where C is the number\n            of masks and H=W=256. These low res logits can be passed to\n            a subsequent iteration as mask input.\n        \"\"\"\n        if not self.is_image_set:\n            raise RuntimeError(\n                \"An image must be set with .set_image(...) before mask prediction.\"\n            )\n\n        if point_coords is not None:\n            points = (point_coords, point_labels)\n        else:\n            points = None\n\n        # Embed prompts\n        sparse_embeddings, dense_embeddings = self.model.prompt_encoder(\n            points=points,\n            boxes=boxes,\n            masks=mask_input,\n        )\n\n        # Predict masks\n        low_res_masks, iou_predictions = self.model.mask_decoder(\n            image_embeddings=self.features,\n            image_pe=self.model.prompt_encoder.get_dense_pe(),\n            sparse_prompt_embeddings=sparse_embeddings,\n            dense_prompt_embeddings=dense_embeddings,\n            multimask_output=multimask_output,\n        )\n\n        # Upscale the masks to the original image resolution\n        masks = self.model.postprocess_masks(\n            low_res_masks, self.input_size, self.original_size\n        )\n\n        if not return_logits:\n            masks = masks > self.model.mask_threshold\n\n        return masks, iou_predictions, low_res_masks\n\n    def get_image_embedding(self) -> torch.Tensor:\n        \"\"\"\n        Returns the image embeddings for the currently set image, with\n        shape 1xCxHxW, where C is the embedding dimension and (H,W) are\n        the embedding spatial dimension of SAM (typically C=256, H=W=64).\n        \"\"\"\n        if not self.is_image_set:\n            raise RuntimeError(\n                \"An image must be set with .set_image(...) to generate an embedding.\"\n            )\n        assert (\n            self.features is not None\n        ), \"Features must exist if an image has been set.\"\n        return self.features\n\n    @property\n    def device(self) -> torch.device:\n        return self.model.device\n\n    def reset_image(self) -> None:\n        \"\"\"Resets the currently set image.\"\"\"\n        self.is_image_set = False\n        self.features = None\n        self.orig_h = None\n        self.orig_w = None\n        self.input_h = None\n        self.input_w = None", ""]}
{"filename": "metaseg/generator/automatic_mask_generator.py", "chunked_list": ["# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom typing import Any, Dict, List, Optional, Tuple\n\nimport numpy as np\nimport torch", "import numpy as np\nimport torch\nfrom torchvision.ops.boxes import batched_nms, box_area  # type: ignore\n\nfrom metaseg.generator.predictor import SamPredictor\nfrom metaseg.modeling import Sam\nfrom metaseg.utils.amg import (\n    MaskData,\n    area_from_rle,\n    batch_iterator,", "    area_from_rle,\n    batch_iterator,\n    batched_mask_to_box,\n    box_xyxy_to_xywh,\n    build_all_layer_point_grids,\n    calculate_stability_score,\n    coco_encode_rle,\n    generate_crop_boxes,\n    is_box_near_crop_edge,\n    mask_to_rle_pytorch,", "    is_box_near_crop_edge,\n    mask_to_rle_pytorch,\n    remove_small_regions,\n    rle_to_mask,\n    uncrop_boxes_xyxy,\n    uncrop_masks,\n    uncrop_points,\n)\n\n\nclass SamAutomaticMaskGenerator:\n    def __init__(\n        self,\n        model: Sam,\n        points_per_side: Optional[int] = 32,\n        points_per_batch: int = 64,\n        pred_iou_thresh: float = 0.88,\n        stability_score_thresh: float = 0.95,\n        stability_score_offset: float = 1.0,\n        box_nms_thresh: float = 0.7,\n        crop_n_layers: int = 0,\n        crop_nms_thresh: float = 0.7,\n        crop_overlap_ratio: float = 512 / 1500,\n        crop_n_points_downscale_factor: int = 1,\n        point_grids: Optional[List[np.ndarray]] = None,\n        min_mask_region_area: int = 0,\n        output_mode: str = \"binary_mask\",\n    ) -> None:\n        \"\"\"\n        Using a SAM model, generates masks for the entire image.\n        Generates a grid of point prompts over the image, then filters\n        low quality and duplicate masks. The default settings are chosen\n        for SAM with a ViT-H backbone.\n\n        Arguments:\n          model (Sam): The SAM model to use for mask prediction.\n          points_per_side (int or None): The number of points to be sampled\n            along one side of the image. The total number of points is\n            points_per_side**2. If None, 'point_grids' must provide explicit\n            point sampling.\n          points_per_batch (int): Sets the number of points run simultaneously\n            by the model. Higher numbers may be faster but use more GPU memory.\n          pred_iou_thresh (float): A filtering threshold in [0,1], using the\n            model's predicted mask quality.\n          stability_score_thresh (float): A filtering threshold in [0,1], using\n            the stability of the mask under changes to the cutoff used to binarize\n            the model's mask predictions.\n          stability_score_offset (float): The amount to shift the cutoff when\n            calculated the stability score.\n          box_nms_thresh (float): The box IoU cutoff used by non-maximal\n            suppression to filter duplicate masks.\n          crops_n_layers (int): If >0, mask prediction will be run again on\n            crops of the image. Sets the number of layers to run, where each\n            layer has 2**i_layer number of image crops.\n          crops_nms_thresh (float): The box IoU cutoff used by non-maximal\n            suppression to filter duplicate masks between different crops.\n          crop_overlap_ratio (float): Sets the degree to which crops overlap.\n            In the first crop layer, crops will overlap by this fraction of\n            the image length. Later layers with more crops scale down this overlap.\n          crop_n_points_downscale_factor (int): The number of points-per-side\n            sampled in layer n is scaled down by crop_n_points_downscale_factor**n.\n          point_grids (list(np.ndarray) or None): A list over explicit grids\n            of points used for sampling, normalized to [0,1]. The nth grid in the\n            list is used in the nth crop layer. Exclusive with points_per_side.\n          min_mask_region_area (int): If >0, postprocessing will be applied\n            to remove disconnected regions and holes in masks with area smaller\n            than min_mask_region_area. Requires opencv.\n          output_mode (str): The form masks are returned in. Can be 'binary_mask',\n            'uncompressed_rle', or 'coco_rle'. 'coco_rle' requires pycocotools.\n            For large resolutions, 'binary_mask' may consume large amounts of\n            memory.\n        \"\"\"\n\n        assert (points_per_side is None) != (\n            point_grids is None\n        ), \"Exactly one of points_per_side or point_grid must be provided.\"\n        if points_per_side is not None:\n            self.point_grids = build_all_layer_point_grids(\n                points_per_side,\n                crop_n_layers,\n                crop_n_points_downscale_factor,\n            )\n        elif point_grids is not None:\n            self.point_grids = point_grids\n        else:\n            raise ValueError(\"Can't have both points_per_side and point_grid be None.\")\n\n        assert output_mode in [\n            \"binary_mask\",\n            \"uncompressed_rle\",\n            \"coco_rle\",\n        ], f\"Unknown output_mode {output_mode}.\"\n        if output_mode == \"coco_rle\":\n            from pycocotools import mask as mask_utils  # type: ignore # noqa: F401\n\n        if min_mask_region_area > 0:\n            import cv2  # type: ignore # noqa: F401\n\n        self.predictor = SamPredictor(model)\n        self.points_per_batch = points_per_batch\n        self.pred_iou_thresh = pred_iou_thresh\n        self.stability_score_thresh = stability_score_thresh\n        self.stability_score_offset = stability_score_offset\n        self.box_nms_thresh = box_nms_thresh\n        self.crop_n_layers = crop_n_layers\n        self.crop_nms_thresh = crop_nms_thresh\n        self.crop_overlap_ratio = crop_overlap_ratio\n        self.crop_n_points_downscale_factor = crop_n_points_downscale_factor\n        self.min_mask_region_area = min_mask_region_area\n        self.output_mode = output_mode\n\n    @torch.no_grad()\n    def generate(self, image: np.ndarray) -> List[Dict[str, Any]]:\n        \"\"\"\n        Generates masks for the given image.\n\n        Arguments:\n          image (np.ndarray): The image to generate masks for, in HWC uint8 format.\n\n        Returns:\n           list(dict(str, any)): A list over records for masks. Each record is\n             a dict containing the following keys:\n               segmentation (dict(str, any) or np.ndarray): The mask. If\n                 output_mode='binary_mask', is an array of shape HW. Otherwise,\n                 is a dictionary containing the RLE.\n               bbox (list(float)): The box around the mask, in XYWH format.\n               area (int): The area in pixels of the mask.\n               predicted_iou (float): The model's own prediction of the mask's\n                 quality. This is filtered by the pred_iou_thresh parameter.\n               point_coords (list(list(float))): The point coordinates input\n                 to the model to generate this mask.\n               stability_score (float): A measure of the mask's quality. This\n                 is filtered on using the stability_score_thresh parameter.\n               crop_box (list(float)): The crop of the image used to generate\n                 the mask, given in XYWH format.\n        \"\"\"\n\n        # Generate masks\n        mask_data = self._generate_masks(image)\n\n        # Filter small disconnected regions and holes in masks\n        if self.min_mask_region_area > 0:\n            mask_data = self.postprocess_small_regions(\n                mask_data,\n                self.min_mask_region_area,\n                max(self.box_nms_thresh, self.crop_nms_thresh),\n            )\n\n        # Encode masks\n        if self.output_mode == \"coco_rle\":\n            mask_data[\"segmentations\"] = [\n                coco_encode_rle(rle) for rle in mask_data[\"rles\"]\n            ]\n        elif self.output_mode == \"binary_mask\":\n            mask_data[\"segmentations\"] = [rle_to_mask(rle) for rle in mask_data[\"rles\"]]\n        else:\n            mask_data[\"segmentations\"] = mask_data[\"rles\"]\n\n        # Write mask records\n        curr_anns = []\n        for idx in range(len(mask_data[\"segmentations\"])):\n            ann = {\n                \"segmentation\": mask_data[\"segmentations\"][idx],\n                \"area\": area_from_rle(mask_data[\"rles\"][idx]),\n                \"bbox\": box_xyxy_to_xywh(mask_data[\"boxes\"][idx]).tolist(),\n                \"predicted_iou\": mask_data[\"iou_preds\"][idx].item(),\n                \"point_coords\": [mask_data[\"points\"][idx].tolist()],\n                \"stability_score\": mask_data[\"stability_score\"][idx].item(),\n                \"crop_box\": box_xyxy_to_xywh(mask_data[\"crop_boxes\"][idx]).tolist(),\n            }\n            curr_anns.append(ann)\n\n        return curr_anns\n\n    def _generate_masks(self, image: np.ndarray) -> MaskData:\n        orig_size = image.shape[:2]\n        crop_boxes, layer_idxs = generate_crop_boxes(\n            orig_size, self.crop_n_layers, self.crop_overlap_ratio\n        )\n\n        # Iterate over image crops\n        data = MaskData()\n        for crop_box, layer_idx in zip(crop_boxes, layer_idxs):\n            crop_data = self._process_crop(image, crop_box, layer_idx, orig_size)\n            data.cat(crop_data)\n\n        # Remove duplicate masks between crops\n        if len(crop_boxes) > 1:\n            # Prefer masks from smaller crops\n            scores = 1 / box_area(data[\"crop_boxes\"])\n            scores = scores.to(data[\"boxes\"].device)\n            keep_by_nms = batched_nms(\n                data[\"boxes\"].float(),\n                scores,\n                torch.zeros(len(data[\"boxes\"])),  # categories\n                iou_threshold=self.crop_nms_thresh,\n            )\n            data.filter(keep_by_nms)\n\n        data.to_numpy()\n        return data\n\n    def _process_crop(\n        self,\n        image: np.ndarray,\n        crop_box: List[int],\n        crop_layer_idx: int,\n        orig_size: Tuple[int, ...],\n    ) -> MaskData:\n        # Crop the image and calculate embeddings\n        x0, y0, x1, y1 = crop_box\n        cropped_im = image[y0:y1, x0:x1, :]\n        cropped_im_size = cropped_im.shape[:2]\n        self.predictor.set_image(cropped_im)\n\n        # Get points for this crop\n        points_scale = np.array(cropped_im_size)[None, ::-1]\n        points_for_image = self.point_grids[crop_layer_idx] * points_scale\n\n        # Generate masks for this crop in batches\n        data = MaskData()\n        for (points,) in batch_iterator(self.points_per_batch, points_for_image):\n            batch_data = self._process_batch(\n                points, cropped_im_size, crop_box, orig_size\n            )\n            data.cat(batch_data)\n            del batch_data\n        self.predictor.reset_image()\n\n        # Remove duplicates within this crop.\n        keep_by_nms = batched_nms(\n            data[\"boxes\"].float(),\n            data[\"iou_preds\"],\n            torch.zeros(len(data[\"boxes\"])),  # categories\n            iou_threshold=self.box_nms_thresh,\n        )\n        data.filter(keep_by_nms)\n\n        # Return to the original image frame\n        data[\"boxes\"] = uncrop_boxes_xyxy(data[\"boxes\"], crop_box)\n        data[\"points\"] = uncrop_points(data[\"points\"], crop_box)\n        data[\"crop_boxes\"] = torch.tensor([crop_box for _ in range(len(data[\"rles\"]))])\n\n        return data\n\n    def _process_batch(\n        self,\n        points: np.ndarray,\n        im_size: Tuple[int, ...],\n        crop_box: List[int],\n        orig_size: Tuple[int, ...],\n    ) -> MaskData:\n        orig_h, orig_w = orig_size\n\n        # Run model on this batch\n        transformed_points = self.predictor.transform.apply_coords(points, im_size)\n        in_points = torch.as_tensor(transformed_points, device=self.predictor.device)\n        in_labels = torch.ones(\n            in_points.shape[0], dtype=torch.int, device=in_points.device\n        )\n        masks, iou_preds, _ = self.predictor.predict_torch(\n            in_points[:, None, :],\n            in_labels[:, None],\n            multimask_output=True,\n            return_logits=True,\n        )\n\n        # Serialize predictions and store in MaskData\n        data = MaskData(\n            masks=masks.flatten(0, 1),\n            iou_preds=iou_preds.flatten(0, 1),\n            points=torch.as_tensor(points.repeat(masks.shape[1], axis=0)),\n        )\n        del masks\n\n        # Filter by predicted IoU\n        if self.pred_iou_thresh > 0.0:\n            keep_mask = data[\"iou_preds\"] > self.pred_iou_thresh\n            data.filter(keep_mask)\n\n        # Calculate stability score\n        data[\"stability_score\"] = calculate_stability_score(\n            data[\"masks\"],\n            self.predictor.model.mask_threshold,\n            self.stability_score_offset,\n        )\n        if self.stability_score_thresh > 0.0:\n            keep_mask = data[\"stability_score\"] >= self.stability_score_thresh\n            data.filter(keep_mask)\n\n        # Threshold masks and calculate boxes\n        data[\"masks\"] = data[\"masks\"] > self.predictor.model.mask_threshold\n        data[\"boxes\"] = batched_mask_to_box(data[\"masks\"])\n\n        # Filter boxes that touch crop boundaries\n        keep_mask = ~is_box_near_crop_edge(\n            data[\"boxes\"], crop_box, [0, 0, orig_w, orig_h]\n        )\n        if not torch.all(keep_mask):\n            data.filter(keep_mask)\n\n        # Compress to RLE\n        data[\"masks\"] = uncrop_masks(data[\"masks\"], crop_box, orig_h, orig_w)\n        data[\"rles\"] = mask_to_rle_pytorch(data[\"masks\"])\n        del data[\"masks\"]\n\n        return data\n\n    @staticmethod\n    def postprocess_small_regions(\n        mask_data: MaskData, min_area: int, nms_thresh: float\n    ) -> MaskData:\n        \"\"\"\n        Removes small disconnected regions and holes in masks, then reruns\n        box NMS to remove any new duplicates.\n\n        Edits mask_data in place.\n\n        Requires open-cv as a dependency.\n        \"\"\"\n        if len(mask_data[\"rles\"]) == 0:\n            return mask_data\n\n        # Filter small disconnected regions and holes\n        new_masks = []\n        scores = []\n        for rle in mask_data[\"rles\"]:\n            mask = rle_to_mask(rle)\n\n            mask, changed = remove_small_regions(mask, min_area, mode=\"holes\")\n            unchanged = not changed\n            mask, changed = remove_small_regions(mask, min_area, mode=\"islands\")\n            unchanged = unchanged and not changed\n\n            new_masks.append(torch.as_tensor(mask).unsqueeze(0))\n            # Give score=0 to changed masks and score=1 to unchanged masks\n            # so NMS will prefer ones that didn't need postprocessing\n            scores.append(float(unchanged))\n\n        # Recalculate boxes and remove any new duplicates\n        masks = torch.cat(new_masks, dim=0)\n        boxes = batched_mask_to_box(masks)\n        keep_by_nms = batched_nms(\n            boxes.float(),\n            torch.as_tensor(scores),\n            torch.zeros(len(boxes)),  # categories\n            iou_threshold=nms_thresh,\n        )\n\n        # Only recalculate RLEs for masks that have changed\n        for i_mask in keep_by_nms:\n            if scores[i_mask] == 0.0:\n                mask_torch = masks[i_mask].unsqueeze(0)\n                mask_data[\"rles\"][i_mask] = mask_to_rle_pytorch(mask_torch)[0]\n                mask_data[\"boxes\"][i_mask] = boxes[i_mask]  # update res directly\n        mask_data.filter(keep_by_nms)\n\n        return mask_data", "\n\nclass SamAutomaticMaskGenerator:\n    def __init__(\n        self,\n        model: Sam,\n        points_per_side: Optional[int] = 32,\n        points_per_batch: int = 64,\n        pred_iou_thresh: float = 0.88,\n        stability_score_thresh: float = 0.95,\n        stability_score_offset: float = 1.0,\n        box_nms_thresh: float = 0.7,\n        crop_n_layers: int = 0,\n        crop_nms_thresh: float = 0.7,\n        crop_overlap_ratio: float = 512 / 1500,\n        crop_n_points_downscale_factor: int = 1,\n        point_grids: Optional[List[np.ndarray]] = None,\n        min_mask_region_area: int = 0,\n        output_mode: str = \"binary_mask\",\n    ) -> None:\n        \"\"\"\n        Using a SAM model, generates masks for the entire image.\n        Generates a grid of point prompts over the image, then filters\n        low quality and duplicate masks. The default settings are chosen\n        for SAM with a ViT-H backbone.\n\n        Arguments:\n          model (Sam): The SAM model to use for mask prediction.\n          points_per_side (int or None): The number of points to be sampled\n            along one side of the image. The total number of points is\n            points_per_side**2. If None, 'point_grids' must provide explicit\n            point sampling.\n          points_per_batch (int): Sets the number of points run simultaneously\n            by the model. Higher numbers may be faster but use more GPU memory.\n          pred_iou_thresh (float): A filtering threshold in [0,1], using the\n            model's predicted mask quality.\n          stability_score_thresh (float): A filtering threshold in [0,1], using\n            the stability of the mask under changes to the cutoff used to binarize\n            the model's mask predictions.\n          stability_score_offset (float): The amount to shift the cutoff when\n            calculated the stability score.\n          box_nms_thresh (float): The box IoU cutoff used by non-maximal\n            suppression to filter duplicate masks.\n          crops_n_layers (int): If >0, mask prediction will be run again on\n            crops of the image. Sets the number of layers to run, where each\n            layer has 2**i_layer number of image crops.\n          crops_nms_thresh (float): The box IoU cutoff used by non-maximal\n            suppression to filter duplicate masks between different crops.\n          crop_overlap_ratio (float): Sets the degree to which crops overlap.\n            In the first crop layer, crops will overlap by this fraction of\n            the image length. Later layers with more crops scale down this overlap.\n          crop_n_points_downscale_factor (int): The number of points-per-side\n            sampled in layer n is scaled down by crop_n_points_downscale_factor**n.\n          point_grids (list(np.ndarray) or None): A list over explicit grids\n            of points used for sampling, normalized to [0,1]. The nth grid in the\n            list is used in the nth crop layer. Exclusive with points_per_side.\n          min_mask_region_area (int): If >0, postprocessing will be applied\n            to remove disconnected regions and holes in masks with area smaller\n            than min_mask_region_area. Requires opencv.\n          output_mode (str): The form masks are returned in. Can be 'binary_mask',\n            'uncompressed_rle', or 'coco_rle'. 'coco_rle' requires pycocotools.\n            For large resolutions, 'binary_mask' may consume large amounts of\n            memory.\n        \"\"\"\n\n        assert (points_per_side is None) != (\n            point_grids is None\n        ), \"Exactly one of points_per_side or point_grid must be provided.\"\n        if points_per_side is not None:\n            self.point_grids = build_all_layer_point_grids(\n                points_per_side,\n                crop_n_layers,\n                crop_n_points_downscale_factor,\n            )\n        elif point_grids is not None:\n            self.point_grids = point_grids\n        else:\n            raise ValueError(\"Can't have both points_per_side and point_grid be None.\")\n\n        assert output_mode in [\n            \"binary_mask\",\n            \"uncompressed_rle\",\n            \"coco_rle\",\n        ], f\"Unknown output_mode {output_mode}.\"\n        if output_mode == \"coco_rle\":\n            from pycocotools import mask as mask_utils  # type: ignore # noqa: F401\n\n        if min_mask_region_area > 0:\n            import cv2  # type: ignore # noqa: F401\n\n        self.predictor = SamPredictor(model)\n        self.points_per_batch = points_per_batch\n        self.pred_iou_thresh = pred_iou_thresh\n        self.stability_score_thresh = stability_score_thresh\n        self.stability_score_offset = stability_score_offset\n        self.box_nms_thresh = box_nms_thresh\n        self.crop_n_layers = crop_n_layers\n        self.crop_nms_thresh = crop_nms_thresh\n        self.crop_overlap_ratio = crop_overlap_ratio\n        self.crop_n_points_downscale_factor = crop_n_points_downscale_factor\n        self.min_mask_region_area = min_mask_region_area\n        self.output_mode = output_mode\n\n    @torch.no_grad()\n    def generate(self, image: np.ndarray) -> List[Dict[str, Any]]:\n        \"\"\"\n        Generates masks for the given image.\n\n        Arguments:\n          image (np.ndarray): The image to generate masks for, in HWC uint8 format.\n\n        Returns:\n           list(dict(str, any)): A list over records for masks. Each record is\n             a dict containing the following keys:\n               segmentation (dict(str, any) or np.ndarray): The mask. If\n                 output_mode='binary_mask', is an array of shape HW. Otherwise,\n                 is a dictionary containing the RLE.\n               bbox (list(float)): The box around the mask, in XYWH format.\n               area (int): The area in pixels of the mask.\n               predicted_iou (float): The model's own prediction of the mask's\n                 quality. This is filtered by the pred_iou_thresh parameter.\n               point_coords (list(list(float))): The point coordinates input\n                 to the model to generate this mask.\n               stability_score (float): A measure of the mask's quality. This\n                 is filtered on using the stability_score_thresh parameter.\n               crop_box (list(float)): The crop of the image used to generate\n                 the mask, given in XYWH format.\n        \"\"\"\n\n        # Generate masks\n        mask_data = self._generate_masks(image)\n\n        # Filter small disconnected regions and holes in masks\n        if self.min_mask_region_area > 0:\n            mask_data = self.postprocess_small_regions(\n                mask_data,\n                self.min_mask_region_area,\n                max(self.box_nms_thresh, self.crop_nms_thresh),\n            )\n\n        # Encode masks\n        if self.output_mode == \"coco_rle\":\n            mask_data[\"segmentations\"] = [\n                coco_encode_rle(rle) for rle in mask_data[\"rles\"]\n            ]\n        elif self.output_mode == \"binary_mask\":\n            mask_data[\"segmentations\"] = [rle_to_mask(rle) for rle in mask_data[\"rles\"]]\n        else:\n            mask_data[\"segmentations\"] = mask_data[\"rles\"]\n\n        # Write mask records\n        curr_anns = []\n        for idx in range(len(mask_data[\"segmentations\"])):\n            ann = {\n                \"segmentation\": mask_data[\"segmentations\"][idx],\n                \"area\": area_from_rle(mask_data[\"rles\"][idx]),\n                \"bbox\": box_xyxy_to_xywh(mask_data[\"boxes\"][idx]).tolist(),\n                \"predicted_iou\": mask_data[\"iou_preds\"][idx].item(),\n                \"point_coords\": [mask_data[\"points\"][idx].tolist()],\n                \"stability_score\": mask_data[\"stability_score\"][idx].item(),\n                \"crop_box\": box_xyxy_to_xywh(mask_data[\"crop_boxes\"][idx]).tolist(),\n            }\n            curr_anns.append(ann)\n\n        return curr_anns\n\n    def _generate_masks(self, image: np.ndarray) -> MaskData:\n        orig_size = image.shape[:2]\n        crop_boxes, layer_idxs = generate_crop_boxes(\n            orig_size, self.crop_n_layers, self.crop_overlap_ratio\n        )\n\n        # Iterate over image crops\n        data = MaskData()\n        for crop_box, layer_idx in zip(crop_boxes, layer_idxs):\n            crop_data = self._process_crop(image, crop_box, layer_idx, orig_size)\n            data.cat(crop_data)\n\n        # Remove duplicate masks between crops\n        if len(crop_boxes) > 1:\n            # Prefer masks from smaller crops\n            scores = 1 / box_area(data[\"crop_boxes\"])\n            scores = scores.to(data[\"boxes\"].device)\n            keep_by_nms = batched_nms(\n                data[\"boxes\"].float(),\n                scores,\n                torch.zeros(len(data[\"boxes\"])),  # categories\n                iou_threshold=self.crop_nms_thresh,\n            )\n            data.filter(keep_by_nms)\n\n        data.to_numpy()\n        return data\n\n    def _process_crop(\n        self,\n        image: np.ndarray,\n        crop_box: List[int],\n        crop_layer_idx: int,\n        orig_size: Tuple[int, ...],\n    ) -> MaskData:\n        # Crop the image and calculate embeddings\n        x0, y0, x1, y1 = crop_box\n        cropped_im = image[y0:y1, x0:x1, :]\n        cropped_im_size = cropped_im.shape[:2]\n        self.predictor.set_image(cropped_im)\n\n        # Get points for this crop\n        points_scale = np.array(cropped_im_size)[None, ::-1]\n        points_for_image = self.point_grids[crop_layer_idx] * points_scale\n\n        # Generate masks for this crop in batches\n        data = MaskData()\n        for (points,) in batch_iterator(self.points_per_batch, points_for_image):\n            batch_data = self._process_batch(\n                points, cropped_im_size, crop_box, orig_size\n            )\n            data.cat(batch_data)\n            del batch_data\n        self.predictor.reset_image()\n\n        # Remove duplicates within this crop.\n        keep_by_nms = batched_nms(\n            data[\"boxes\"].float(),\n            data[\"iou_preds\"],\n            torch.zeros(len(data[\"boxes\"])),  # categories\n            iou_threshold=self.box_nms_thresh,\n        )\n        data.filter(keep_by_nms)\n\n        # Return to the original image frame\n        data[\"boxes\"] = uncrop_boxes_xyxy(data[\"boxes\"], crop_box)\n        data[\"points\"] = uncrop_points(data[\"points\"], crop_box)\n        data[\"crop_boxes\"] = torch.tensor([crop_box for _ in range(len(data[\"rles\"]))])\n\n        return data\n\n    def _process_batch(\n        self,\n        points: np.ndarray,\n        im_size: Tuple[int, ...],\n        crop_box: List[int],\n        orig_size: Tuple[int, ...],\n    ) -> MaskData:\n        orig_h, orig_w = orig_size\n\n        # Run model on this batch\n        transformed_points = self.predictor.transform.apply_coords(points, im_size)\n        in_points = torch.as_tensor(transformed_points, device=self.predictor.device)\n        in_labels = torch.ones(\n            in_points.shape[0], dtype=torch.int, device=in_points.device\n        )\n        masks, iou_preds, _ = self.predictor.predict_torch(\n            in_points[:, None, :],\n            in_labels[:, None],\n            multimask_output=True,\n            return_logits=True,\n        )\n\n        # Serialize predictions and store in MaskData\n        data = MaskData(\n            masks=masks.flatten(0, 1),\n            iou_preds=iou_preds.flatten(0, 1),\n            points=torch.as_tensor(points.repeat(masks.shape[1], axis=0)),\n        )\n        del masks\n\n        # Filter by predicted IoU\n        if self.pred_iou_thresh > 0.0:\n            keep_mask = data[\"iou_preds\"] > self.pred_iou_thresh\n            data.filter(keep_mask)\n\n        # Calculate stability score\n        data[\"stability_score\"] = calculate_stability_score(\n            data[\"masks\"],\n            self.predictor.model.mask_threshold,\n            self.stability_score_offset,\n        )\n        if self.stability_score_thresh > 0.0:\n            keep_mask = data[\"stability_score\"] >= self.stability_score_thresh\n            data.filter(keep_mask)\n\n        # Threshold masks and calculate boxes\n        data[\"masks\"] = data[\"masks\"] > self.predictor.model.mask_threshold\n        data[\"boxes\"] = batched_mask_to_box(data[\"masks\"])\n\n        # Filter boxes that touch crop boundaries\n        keep_mask = ~is_box_near_crop_edge(\n            data[\"boxes\"], crop_box, [0, 0, orig_w, orig_h]\n        )\n        if not torch.all(keep_mask):\n            data.filter(keep_mask)\n\n        # Compress to RLE\n        data[\"masks\"] = uncrop_masks(data[\"masks\"], crop_box, orig_h, orig_w)\n        data[\"rles\"] = mask_to_rle_pytorch(data[\"masks\"])\n        del data[\"masks\"]\n\n        return data\n\n    @staticmethod\n    def postprocess_small_regions(\n        mask_data: MaskData, min_area: int, nms_thresh: float\n    ) -> MaskData:\n        \"\"\"\n        Removes small disconnected regions and holes in masks, then reruns\n        box NMS to remove any new duplicates.\n\n        Edits mask_data in place.\n\n        Requires open-cv as a dependency.\n        \"\"\"\n        if len(mask_data[\"rles\"]) == 0:\n            return mask_data\n\n        # Filter small disconnected regions and holes\n        new_masks = []\n        scores = []\n        for rle in mask_data[\"rles\"]:\n            mask = rle_to_mask(rle)\n\n            mask, changed = remove_small_regions(mask, min_area, mode=\"holes\")\n            unchanged = not changed\n            mask, changed = remove_small_regions(mask, min_area, mode=\"islands\")\n            unchanged = unchanged and not changed\n\n            new_masks.append(torch.as_tensor(mask).unsqueeze(0))\n            # Give score=0 to changed masks and score=1 to unchanged masks\n            # so NMS will prefer ones that didn't need postprocessing\n            scores.append(float(unchanged))\n\n        # Recalculate boxes and remove any new duplicates\n        masks = torch.cat(new_masks, dim=0)\n        boxes = batched_mask_to_box(masks)\n        keep_by_nms = batched_nms(\n            boxes.float(),\n            torch.as_tensor(scores),\n            torch.zeros(len(boxes)),  # categories\n            iou_threshold=nms_thresh,\n        )\n\n        # Only recalculate RLEs for masks that have changed\n        for i_mask in keep_by_nms:\n            if scores[i_mask] == 0.0:\n                mask_torch = masks[i_mask].unsqueeze(0)\n                mask_data[\"rles\"][i_mask] = mask_to_rle_pytorch(mask_torch)[0]\n                mask_data[\"boxes\"][i_mask] = boxes[i_mask]  # update res directly\n        mask_data.filter(keep_by_nms)\n\n        return mask_data", ""]}
{"filename": "metaseg/webapp/app.py", "chunked_list": ["import gradio as gr\nfrom demo import automask_image_app, automask_video_app, sahi_autoseg_app\n\n\ndef image_app():\n    with gr.Blocks():\n        with gr.Row():\n            with gr.Column():\n                seg_automask_image_file = gr.Image(type=\"filepath\").style(height=260)\n                with gr.Row():\n                    with gr.Column():\n                        seg_automask_image_model_type = gr.Dropdown(\n                            choices=[\n                                \"vit_h\",\n                                \"vit_l\",\n                                \"vit_b\",\n                            ],\n                            value=\"vit_l\",\n                            label=\"Model Type\",\n                        )\n\n                        seg_automask_image_min_area = gr.Number(\n                            value=0,\n                            label=\"Min Area\",\n                        )\n                    with gr.Row():\n                        with gr.Column():\n                            seg_automask_image_points_per_side = gr.Slider(\n                                minimum=0,\n                                maximum=32,\n                                step=2,\n                                value=16,\n                                label=\"Points per Side\",\n                            )\n\n                            seg_automask_image_points_per_batch = gr.Slider(\n                                minimum=0,\n                                maximum=64,\n                                step=2,\n                                value=64,\n                                label=\"Points per Batch\",\n                            )\n\n                seg_automask_image_predict = gr.Button(value=\"Generator\")\n\n            with gr.Column():\n                output_image = gr.Image()\n\n        seg_automask_image_predict.click(\n            fn=automask_image_app,\n            inputs=[\n                seg_automask_image_file,\n                seg_automask_image_model_type,\n                seg_automask_image_points_per_side,\n                seg_automask_image_points_per_batch,\n                seg_automask_image_min_area,\n            ],\n            outputs=[output_image],\n        )", "\n\ndef video_app():\n    with gr.Blocks():\n        with gr.Row():\n            with gr.Column():\n                seg_automask_video_file = gr.Video().style(height=260)\n                with gr.Row():\n                    with gr.Column():\n                        seg_automask_video_model_type = gr.Dropdown(\n                            choices=[\n                                \"vit_h\",\n                                \"vit_l\",\n                                \"vit_b\",\n                            ],\n                            value=\"vit_l\",\n                            label=\"Model Type\",\n                        )\n                        seg_automask_video_min_area = gr.Number(\n                            value=1000,\n                            label=\"Min Area\",\n                        )\n\n                    with gr.Row():\n                        with gr.Column():\n                            seg_automask_video_points_per_side = gr.Slider(\n                                minimum=0,\n                                maximum=32,\n                                step=2,\n                                value=16,\n                                label=\"Points per Side\",\n                            )\n\n                            seg_automask_video_points_per_batch = gr.Slider(\n                                minimum=0,\n                                maximum=64,\n                                step=2,\n                                value=64,\n                                label=\"Points per Batch\",\n                            )\n\n                seg_automask_video_predict = gr.Button(value=\"Generator\")\n            with gr.Column():\n                output_video = gr.Video()\n\n        seg_automask_video_predict.click(\n            fn=automask_video_app,\n            inputs=[\n                seg_automask_video_file,\n                seg_automask_video_model_type,\n                seg_automask_video_points_per_side,\n                seg_automask_video_points_per_batch,\n                seg_automask_video_min_area,\n            ],\n            outputs=[output_video],\n        )", "\n\ndef sahi_app():\n    with gr.Blocks():\n        with gr.Row():\n            with gr.Column():\n                sahi_image_file = gr.Image(type=\"filepath\").style(height=260)\n                sahi_autoseg_model_type = gr.Dropdown(\n                    choices=[\n                        \"vit_h\",\n                        \"vit_l\",\n                        \"vit_b\",\n                    ],\n                    value=\"vit_l\",\n                    label=\"Sam Model Type\",\n                )\n\n                with gr.Row():\n                    with gr.Column():\n                        sahi_model_type = gr.Dropdown(\n                            choices=[\n                                \"yolov5\",\n                                \"yolov8\",\n                            ],\n                            value=\"yolov5\",\n                            label=\"Detector Model Type\",\n                        )\n                        sahi_image_size = gr.Slider(\n                            minimum=0,\n                            maximum=1600,\n                            step=32,\n                            value=640,\n                            label=\"Image Size\",\n                        )\n\n                        sahi_overlap_width = gr.Slider(\n                            minimum=0,\n                            maximum=1,\n                            step=0.1,\n                            value=0.2,\n                            label=\"Overlap Width\",\n                        )\n\n                        sahi_slice_width = gr.Slider(\n                            minimum=0,\n                            maximum=640,\n                            step=32,\n                            value=256,\n                            label=\"Slice Width\",\n                        )\n\n                    with gr.Row():\n                        with gr.Column():\n                            sahi_model_path = gr.Dropdown(\n                                choices=[\n                                    \"yolov5l.pt\",\n                                    \"yolov5l6.pt\",\n                                    \"yolov8l.pt\",\n                                    \"yolov8x.pt\",\n                                ],\n                                value=\"yolov5l6.pt\",\n                                label=\"Detector Model Path\",\n                            )\n\n                            sahi_conf_th = gr.Slider(\n                                minimum=0,\n                                maximum=1,\n                                step=0.1,\n                                value=0.2,\n                                label=\"Confidence Threshold\",\n                            )\n                            sahi_overlap_height = gr.Slider(\n                                minimum=0,\n                                maximum=1,\n                                step=0.1,\n                                value=0.2,\n                                label=\"Overlap Height\",\n                            )\n                            sahi_slice_height = gr.Slider(\n                                minimum=0,\n                                maximum=640,\n                                step=32,\n                                value=256,\n                                label=\"Slice Height\",\n                            )\n                sahi_image_predict = gr.Button(value=\"Generator\")\n\n            with gr.Column():\n                output_image = gr.Image()\n\n        sahi_image_predict.click(\n            fn=sahi_autoseg_app,\n            inputs=[\n                sahi_image_file,\n                sahi_autoseg_model_type,\n                sahi_model_type,\n                sahi_model_path,\n                sahi_conf_th,\n                sahi_image_size,\n                sahi_slice_height,\n                sahi_slice_width,\n                sahi_overlap_height,\n                sahi_overlap_width,\n            ],\n            outputs=[output_image],\n        )", "\n\ndef metaseg_app():\n    app = gr.Blocks()\n    with app:\n        with gr.Row():\n            with gr.Column():\n                with gr.Tab(\"Image\"):\n                    image_app()\n                with gr.Tab(\"Video\"):\n                    video_app()\n                with gr.Tab(\"SAHI\"):\n                    sahi_app()\n\n    app.queue(concurrency_count=1)\n    app.launch(debug=True, enable_queue=True)", "\n\nif __name__ == \"__main__\":\n    metaseg_app()\n"]}
{"filename": "metaseg/webapp/__init__.py", "chunked_list": ["from .app import metaseg_app as metaseg_app\n"]}
{"filename": "metaseg/webapp/demo.py", "chunked_list": ["from metaseg import (\n    SahiAutoSegmentation,\n    SegAutoMaskPredictor,\n    SegManualMaskPredictor,\n    sahi_sliced_predict,\n)\n\n# For image\n\n\ndef automask_image_app(\n    image_path, model_type, points_per_side, points_per_batch, min_area\n):\n    SegAutoMaskPredictor().image_predict(\n        source=image_path,\n        model_type=model_type,  # vit_l, vit_h, vit_b\n        points_per_side=points_per_side,\n        points_per_batch=points_per_batch,\n        min_area=min_area,\n        output_path=\"output.png\",\n        show=False,\n        save=True,\n    )\n    return \"output.png\"", "\n\ndef automask_image_app(\n    image_path, model_type, points_per_side, points_per_batch, min_area\n):\n    SegAutoMaskPredictor().image_predict(\n        source=image_path,\n        model_type=model_type,  # vit_l, vit_h, vit_b\n        points_per_side=points_per_side,\n        points_per_batch=points_per_batch,\n        min_area=min_area,\n        output_path=\"output.png\",\n        show=False,\n        save=True,\n    )\n    return \"output.png\"", "\n\n# For video\n\n\ndef automask_video_app(\n    video_path, model_type, points_per_side, points_per_batch, min_area\n):\n    SegAutoMaskPredictor().video_predict(\n        source=video_path,\n        model_type=model_type,  # vit_l, vit_h, vit_b\n        points_per_side=points_per_side,\n        points_per_batch=points_per_batch,\n        min_area=min_area,\n        output_path=\"output.mp4\",\n    )\n    return \"output.mp4\"", "\n\n# For manuel box and point selection\n\n\ndef manual_app(\n    image_path,\n    model_type,\n    input_point,\n    input_label,\n    input_box,\n    multimask_output,\n    random_color,\n):\n    SegManualMaskPredictor().image_predict(\n        source=image_path,\n        model_type=model_type,  # vit_l, vit_h, vit_b\n        input_point=input_point,\n        input_label=input_label,\n        input_box=input_box,\n        multimask_output=multimask_output,\n        random_color=random_color,\n        output_path=\"output.png\",\n        show=False,\n        save=True,\n    )\n    return \"output.png\"", "\n\n# For sahi sliced prediction\n\n\ndef sahi_autoseg_app(\n    image_path,\n    sam_model_type,\n    detection_model_type,\n    detection_model_path,\n    conf_th,\n    image_size,\n    slice_height,\n    slice_width,\n    overlap_height_ratio,\n    overlap_width_ratio,\n):\n    boxes = sahi_sliced_predict(\n        image_path=image_path,\n        # yolov8, detectron2, mmdetection, torchvision\n        detection_model_type=detection_model_type,\n        detection_model_path=detection_model_path,\n        conf_th=conf_th,\n        image_size=image_size,\n        slice_height=slice_height,\n        slice_width=slice_width,\n        overlap_height_ratio=overlap_height_ratio,\n        overlap_width_ratio=overlap_width_ratio,\n    )\n\n    SahiAutoSegmentation().image_predict(\n        source=image_path,\n        model_type=sam_model_type,\n        input_box=boxes,\n        multimask_output=False,\n        random_color=False,\n        show=False,\n        save=True,\n    )\n\n    return \"output.png\"", ""]}
{"filename": "examples/image_segautomask.py", "chunked_list": ["from metaseg import SegAutoMaskPredictor\n\n# If gpu memory is not enough, reduce the points_per_side and points_per_batch.\n\n\ndef main(src: str = \"image.png\") -> None:\n    SegAutoMaskPredictor().image_predict(\n        source=src,\n        model_type=\"vit_l\",  # vit_l, vit_h, vit_b\n        points_per_side=16,\n        points_per_batch=64,\n        min_area=0,\n        output_path=\"output.jpg\",\n        show=True,\n        save=False,\n    )", "\n\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "examples/video_segautomask.py", "chunked_list": ["from metaseg import SegAutoMaskPredictor\n\n# If gpu memory is not enough, reduce the points_per_side and points_per_batch.\n\n\n# For video\ndef main(src: str = \"video.mp4\") -> None:\n    SegAutoMaskPredictor().video_predict(\n        source=src,\n        model_type=\"vit_l\",  # vit_l, vit_h, vit_b\n        points_per_side=16,\n        points_per_batch=64,\n        min_area=1000,\n        output_path=\"output.mp4\",\n    )", "\n\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "examples/video_segmanualmask.py", "chunked_list": ["from metaseg import SegManualMaskPredictor\n\n# If gpu memory is not enough, reduce the points_per_side and points_per_batch.\n\n\ndef main(src: str = \"video.mp4\") -> None:\n    SegManualMaskPredictor().video_predict(\n        source=src,\n        model_type=\"vit_l\",  # vit_l, vit_h, vit_b\n        input_point=[0, 0, 100, 100],\n        input_label=[0, 1],\n        input_box=None,\n        multimask_output=False,\n        random_color=False,\n        output_path=\"output.mp4\",\n    )", "\n\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "examples/image_sahi_slice_predict.py", "chunked_list": ["from metaseg import SahiAutoSegmentation, sahi_sliced_predict\n\n\ndef main(src: str = \"image.png\") -> None:\n    img_path = src\n    boxes = sahi_sliced_predict(\n        image_path=img_path,\n        detection_model_type=\"yolov5\",  # yolov8, detectron2, mmdetection, torchvision\n        detection_model_path=\"yolov5l6.pt\",\n        conf_th=0.25,\n        image_size=1280,\n        slice_height=256,\n        slice_width=256,\n        overlap_height_ratio=0.2,\n        overlap_width_ratio=0.2,\n    )\n\n    SahiAutoSegmentation().image_predict(\n        source=img_path,\n        model_type=\"vit_b\",\n        input_box=boxes,\n        multimask_output=False,\n        random_color=False,\n        show=True,\n        save=False,\n    )", "\n\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "examples/image_segmanualmask.py", "chunked_list": ["from metaseg import SegManualMaskPredictor\n\n# If gpu memory is not enough, reduce the points_per_side and points_per_batch.\n\n\ndef main(src: str = \"image.png\") -> None:\n    SegManualMaskPredictor().image_predict(\n        source=src,\n        model_type=\"vit_l\",  # vit_l, vit_h, vit_b\n        input_point=[[100, 100], [200, 200]],\n        input_label=[0, 1],\n        input_box=[\n            100,\n            100,\n            200,\n            200,\n        ],  # or [[100, 100, 200, 200], [100, 100, 200, 200]]\n        multimask_output=False,\n        random_color=False,\n        show=True,\n        save=False,\n    )", "\n\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "examples/image_cv_segautomask.py", "chunked_list": ["from cv2 import COLOR_BGR2RGB, Mat\nfrom cv2 import cvtColor as cv_cvtColor\nfrom cv2 import imread as cv_imread\n\nfrom metaseg import SegAutoMaskPredictor\n\n\n# If gpu memory is not enough, reduce the points_per_side and points_per_batch.\ndef main(src: Mat) -> None:\n    SegAutoMaskPredictor().image_predict(\n        source=src,\n        model_type=\"vit_l\",  # vit_l, vit_h, vit_b\n        points_per_side=16,\n        points_per_batch=64,\n        min_area=0,\n        output_path=\"output.jpg\",\n        show=True,\n        save=False,\n    )", "def main(src: Mat) -> None:\n    SegAutoMaskPredictor().image_predict(\n        source=src,\n        model_type=\"vit_l\",  # vit_l, vit_h, vit_b\n        points_per_side=16,\n        points_per_batch=64,\n        min_area=0,\n        output_path=\"output.jpg\",\n        show=True,\n        save=False,\n    )", "\n\nif __name__ == \"__main__\":\n    image = cv_imread(\"image.png\")\n    image = cv_cvtColor(image, COLOR_BGR2RGB)\n    main(image)\n"]}
