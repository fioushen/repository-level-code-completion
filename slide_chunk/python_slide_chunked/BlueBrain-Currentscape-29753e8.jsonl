{"filename": "setup.py", "chunked_list": ["#!/usr/bin/env python\n\n# Copyright 2023 Blue Brain Project / EPFL\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n", "#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport sys\n", "import sys\n\nfrom setuptools import setup, find_packages\n\nif sys.version_info < (3, 8):\n    sys.exit(\"Sorry, Python < 3.8 is not supported\")\n\n# read the contents of the README file\nwith open(\"README.rst\", encoding=\"utf-8\") as f:\n    README = f.read()", "with open(\"README.rst\", encoding=\"utf-8\") as f:\n    README = f.read()\n\nEXTRA_EXAMPLE = [\"scipy\", \"bluepyopt\", \"emodelrunner>=1.1.5\"]\n\nsetup(\n    name=\"currentscape\",\n    author=\"Blue Brain Project, EPFL\",\n    use_scm_version={\n        \"version_scheme\": \"python-simplified-semver\",", "    use_scm_version={\n        \"version_scheme\": \"python-simplified-semver\",\n        \"local_scheme\": \"no-local-version\",\n    },\n    setup_requires=[\"setuptools_scm\"],\n    description=\"Module to easily plot currentscape.\",\n    long_description=README,\n    long_description_content_type=\"text/x-rst\",\n    url=\"https://github.com/BlueBrain/Currentscape\",\n    project_urls={", "    url=\"https://github.com/BlueBrain/Currentscape\",\n    project_urls={\n        \"Tracker\": \"https://github.com/BlueBrain/Currentscape\",\n        \"Source\": \"https://github.com/BlueBrain/Currentscape\",\n    },\n    license=\"Apache 2.0\",\n    install_requires=[\n        \"numpy\",\n        \"matplotlib\",\n        \"palettable\",", "        \"matplotlib\",\n        \"palettable\",\n    ],\n    packages=find_packages(exclude=[\"tests\"]),\n    python_requires=\">=3.8\",\n    extras_require={\n        \"docs\": [\"sphinx\", \"sphinx-bluebrain-theme\"],\n        \"example\": EXTRA_EXAMPLE,\n    },\n    classifiers=[", "    },\n    classifiers=[\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Science/Research\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",", "        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Topic :: Scientific/Engineering :: Bio-Informatics\",\n    ],\n)\n"]}
{"filename": "extra/spack/var/spack/repos/builtin/packages/py-currentscape/package.py", "chunked_list": ["# Copyright 2013-2020 Lawrence Livermore National Security, LLC and other\n# Spack Project Developers. See the top-level COPYRIGHT file for details.\n#\n# SPDX-License-Identifier: (Apache-2.0 OR MIT)\n\nfrom spack import *\n\n\nclass PyCurrentscape(PythonPackage):\n    \"\"\"Module to easily plot currentscape.\"\"\"\n\n    homepage = \"https://bbpcode.epfl.ch/code/#/admin/projects/cells/currentscape\"\n    url = \"ssh://bbpcode.epfl.ch/cells/currentscape\"\n    git = \"ssh://bbpcode.epfl.ch/cells/currentscape\"\n\n    version(\"develop\", branch=\"master\")\n    version(\"0.0.1\", tag=\"currentscape-v0.0.1\")\n\n    depends_on(\"py-setuptools\", type=\"build\")\n    depends_on(\"py-numpy\", type=\"run\")\n    depends_on(\"py-matplotlib\", type=\"run\")\n    depends_on(\"py-scipy\", type=\"run\")", "class PyCurrentscape(PythonPackage):\n    \"\"\"Module to easily plot currentscape.\"\"\"\n\n    homepage = \"https://bbpcode.epfl.ch/code/#/admin/projects/cells/currentscape\"\n    url = \"ssh://bbpcode.epfl.ch/cells/currentscape\"\n    git = \"ssh://bbpcode.epfl.ch/cells/currentscape\"\n\n    version(\"develop\", branch=\"master\")\n    version(\"0.0.1\", tag=\"currentscape-v0.0.1\")\n\n    depends_on(\"py-setuptools\", type=\"build\")\n    depends_on(\"py-numpy\", type=\"run\")\n    depends_on(\"py-matplotlib\", type=\"run\")\n    depends_on(\"py-scipy\", type=\"run\")", ""]}
{"filename": "doc/source/conf.py", "chunked_list": ["# Configuration file for the Sphinx documentation builder.\n#\n# This file only contains a selection of the most common options. For a full\n# list see the documentation:\n# https://www.sphinx-doc.org/en/master/usage/configuration.html\n\n# -- Path setup --------------------------------------------------------------\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the", "# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#\n# import os\n# import sys\n# sys.path.insert(0, os.path.abspath(\".\"))\n\nfrom pkg_resources import get_distribution\n", "from pkg_resources import get_distribution\n\n# -- Project information -----------------------------------------------------\n\nproject = \"currentscape\"\n\n# The short X.Y version\nversion = get_distribution(\"currentscape\").version\n\n# The full version, including alpha/beta/rc tags", "\n# The full version, including alpha/beta/rc tags\nrelease = version\n\n\n# -- General configuration ---------------------------------------------------\n\n# Add any Sphinx extension module names here, as strings. They can be extensions\n# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.\nextensions = [", "# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.\nextensions = [\n    \"sphinx.ext.autodoc\",\n    \"sphinx.ext.autosummary\",\n    \"sphinx.ext.doctest\",\n    \"sphinx.ext.coverage\",\n    \"sphinx.ext.ifconfig\",\n    \"sphinx.ext.viewcode\",\n    \"sphinx.ext.napoleon\",\n]", "    \"sphinx.ext.napoleon\",\n]\n\n# Add any paths that contain templates here, relative to this directory.\n# templates_path = ['_templates']\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This pattern also affects html_static_path and html_extra_path.\nexclude_patterns = []", "# This pattern also affects html_static_path and html_extra_path.\nexclude_patterns = []\n\n# A list of ignored prefixes for module index sorting.\n# modindex_common_prefix = []\n\nautosummary_generate = True\nautodoc_default_options = {\"members\": True, \"show-inheritance\": True}\n\n", "\n\n# -- Options for HTML output -------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = \"sphinx-bluebrain-theme\"\n\n# Add any paths that contain custom static files (such as style sheets) here,", "\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\n# html_static_path = ['_static']\n\nhtml_theme_options = {\n    \"metadata_distribution\": \"currentscape\",\n}\n", "}\n\nhtml_title = u\"currentscape\"\n\n# If true, links to the reST sources are added to the pages.\nhtml_show_sourcelink = False\n"]}
{"filename": "tests/test_currentscape_mapper.py", "chunked_list": ["\"\"\"Test currentscape mapper functions.\"\"\"\n\nfrom hypothesis import given, strategies as st\nimport numpy as np\n\nfrom currentscape.mapper import (\n    has_common_divisor,\n    create_mapper,\n    map_colors,\n    map_patterns,", "    map_colors,\n    map_patterns,\n)\n\n\ndef test_has_common_divisor():\n    \"\"\"Test has_common_divisor function.\"\"\"\n    assert has_common_divisor(4, 7, 7)\n    assert has_common_divisor(4, 5, 12)\n    assert not has_common_divisor(4, 5, 13)\n    assert not has_common_divisor(3, 7, 20)", "\n\ndef test_create_mapper():\n    \"\"\"Test create_mapper function.\"\"\"\n    assert create_mapper(4, 7) == 9\n    assert create_mapper(4, 5) == 7\n    assert create_mapper(6, 7) == 11\n\n\ndef test_map_colors():\n    \"\"\"Test map_colors function.\"\"\"\n    assert map_colors(1, 4, 7) == 3\n    assert np.array_equal(map_colors(np.arange(5), 3, 5), [0, 2, 1, 0, 2])", "\ndef test_map_colors():\n    \"\"\"Test map_colors function.\"\"\"\n    assert map_colors(1, 4, 7) == 3\n    assert np.array_equal(map_colors(np.arange(5), 3, 5), [0, 2, 1, 0, 2])\n\n\ndef test_map_patterns():\n    \"\"\"Test map_patterns function.\"\"\"\n    assert map_patterns(13, 4, 5, 7) == 2\n    assert np.array_equal(map_patterns(np.arange(5), 3, 2, 5), [0, 1, 1, 1, 0])", "\n\n@given(\n    st.tuples(\n        # do not use overly unrealistic values.\n        # test can take too much time if a very large value is used.\n        st.integers(min_value=1, max_value=100),\n        st.integers(min_value=1, max_value=100),\n        st.integers(min_value=1, max_value=10000),\n    ).filter(lambda x: x[0] * x[1] >= x[2])", "        st.integers(min_value=1, max_value=10000),\n    ).filter(lambda x: x[0] * x[1] >= x[2])\n)\ndef test_mapper_with_hypothesis(values):\n    \"\"\"Test create_mapper, map_colors and map_patterns with automatically generated input.\n\n    The mapper should behave as described in create_mapper docstring,\n    producing unique pairs of color / pattern.\n    \"\"\"\n    n_colors = values[0]\n    n_patterns = values[1]\n    n_currents = values[2]\n\n    mapper = create_mapper(n_colors, n_patterns)\n\n    curr_idxs = np.arange(n_currents)\n    colors = map_colors(curr_idxs, n_colors, mapper)\n    patterns = map_patterns(curr_idxs, n_colors, n_patterns, mapper)\n    combinations = list(zip(colors, patterns))\n\n    # This should be valid for any number as long as n_currents <= n_colors * n_patterns\n    assert len(combinations) == len(set(combinations))", ""]}
{"filename": "tests/test_currentscape_dataprocessing.py", "chunked_list": ["\"\"\"Test currentscape dataprocessing functions.\"\"\"\n\nimport numpy as np\n\nfrom currentscape.data_processing import (\n    autoscale_ticks_and_ylim,\n    sum_chunks,\n    check_chunksize,\n    remove_zero_arrays,\n    reorder,", "    remove_zero_arrays,\n    reorder,\n    order_of_mag,\n    round_down_sig_digit,\n)\n\n\ndef compare_floats(n1, n2, err=1e-10):\n    \"\"\"Assert that two floats are closer than a given uncertainty.\"\"\"\n    assert (n1 - n2) / n1 < err", "\n\ndef test_order_of_mag():\n    \"\"\"Test function returning order of magnitude of a number.\"\"\"\n    assert order_of_mag(1234) == 1000\n    assert order_of_mag(0.0456) == 0.01\n\n\ndef test_round_down_sig_digit():\n    \"\"\"Test function rounding down a number to one (or more) significant digit(s).\"\"\"\n    assert round_down_sig_digit(0.0456) == 0.04\n    assert round_down_sig_digit(723) == 700\n    assert round_down_sig_digit(0.5) == 0.5\n    assert round_down_sig_digit(1234, 100) == 1200", "def test_round_down_sig_digit():\n    \"\"\"Test function rounding down a number to one (or more) significant digit(s).\"\"\"\n    assert round_down_sig_digit(0.0456) == 0.04\n    assert round_down_sig_digit(723) == 700\n    assert round_down_sig_digit(0.5) == 0.5\n    assert round_down_sig_digit(1234, 100) == 1200\n\n\ndef test_autoscale():\n    \"\"\"Test autoscale function.\"\"\"\n    config_key = \"test\"\n    test_dict = {\"ylim\": (0, 0), \"ticks\": [0, 0]}\n    c = {config_key: test_dict}\n\n    max_ = 654321\n    autoscale_ticks_and_ylim(c, max_, 0, config_key)\n\n    compare_floats(c[config_key][\"ylim\"][0], 0.3271605)\n    compare_floats(c[config_key][\"ylim\"][1], 3271605)\n\n    compare_floats(c[config_key][\"ticks\"][2], 60000)\n    compare_floats(c[config_key][\"ticks\"][1], 600)\n    compare_floats(c[config_key][\"ticks\"][0], 6)\n\n    max_ = 0.723\n    autoscale_ticks_and_ylim(c, 0, max_, config_key)\n\n    compare_floats(c[config_key][\"ylim\"][0], 0.0000003615)\n    compare_floats(c[config_key][\"ylim\"][1], 3.615)\n\n    compare_floats(c[config_key][\"ticks\"][2], 0.07)\n    compare_floats(c[config_key][\"ticks\"][1], 0.0007)\n    compare_floats(c[config_key][\"ticks\"][0], 0.000007)", "def test_autoscale():\n    \"\"\"Test autoscale function.\"\"\"\n    config_key = \"test\"\n    test_dict = {\"ylim\": (0, 0), \"ticks\": [0, 0]}\n    c = {config_key: test_dict}\n\n    max_ = 654321\n    autoscale_ticks_and_ylim(c, max_, 0, config_key)\n\n    compare_floats(c[config_key][\"ylim\"][0], 0.3271605)\n    compare_floats(c[config_key][\"ylim\"][1], 3271605)\n\n    compare_floats(c[config_key][\"ticks\"][2], 60000)\n    compare_floats(c[config_key][\"ticks\"][1], 600)\n    compare_floats(c[config_key][\"ticks\"][0], 6)\n\n    max_ = 0.723\n    autoscale_ticks_and_ylim(c, 0, max_, config_key)\n\n    compare_floats(c[config_key][\"ylim\"][0], 0.0000003615)\n    compare_floats(c[config_key][\"ylim\"][1], 3.615)\n\n    compare_floats(c[config_key][\"ticks\"][2], 0.07)\n    compare_floats(c[config_key][\"ticks\"][1], 0.0007)\n    compare_floats(c[config_key][\"ticks\"][0], 0.000007)", "\n\ndef test_sum_chunks():\n    \"\"\"Test reshaping in sum chunks function.\"\"\"\n    arr1 = np.array([1, 1, 2, 2, 3, 3])\n    arr2 = np.array([0, 1, 2, 0, 1, 2])\n    arr = np.array([arr1, arr2])\n\n    assert np.array_equal(sum_chunks(arr, 1), [[1, 1, 2, 2, 3, 3], [0, 1, 2, 0, 1, 2]])\n    assert np.array_equal(sum_chunks(arr, 2), [[1, 2, 3], [0.5, 1, 1.5]])\n    assert np.array_equal(sum_chunks(arr, 3), [[4 / 3.0, 8 / 3.0], [1, 1]])", "\n\ndef test_check_chunksize():\n    \"\"\"Test common divisor finder.\"\"\"\n    # chunksize < 1 case\n    assert check_chunksize(0, 3000) == 1\n    # chunksize > data size case\n    assert check_chunksize(3333, 3000) == 3000\n    # chunksize divisor of data size case\n    assert check_chunksize(50, 3000) == 50\n    # chunksize not a divisor of data size case\n    assert check_chunksize(49, 3000) == 40", "\n\ndef test_remove_zero_arrays():\n    \"\"\"Test remove zero array function.\"\"\"\n    arr = np.array([np.array([0, 1]), np.array([0, 0]), np.array([np.nan, 0])])\n    new_arr, new_idx = remove_zero_arrays(arr)\n\n    assert np.array_equal(new_arr, [[0, 1]])\n    assert new_idx == 0\n", "\n\ndef test_reorder():\n    \"\"\"Test reorder function.\n\n    The function removes null arrays, reorders from largest sum to smallest,\n    and returns reordered list and reordered indexes.\n    \"\"\"\n    arr1 = np.array([1, 1, 2, 2, 3, 3])\n    arr2 = np.array([0, 1, 2, 0, 1, 2])\n    arr3 = np.array([0, 0, 0, 0, 0, 0])\n    arr4 = np.array([1, 1, 2, 9, 3, 3])\n    arr = np.array([arr1, arr2, arr3, arr4])\n\n    new_arr, new_idx = reorder(arr)\n    assert np.array_equal(\n        new_arr, [[1, 1, 2, 9, 3, 3], [1, 1, 2, 2, 3, 3], [0, 1, 2, 0, 1, 2]]\n    )\n    assert np.array_equal(new_idx, [3, 0, 1])", ""]}
{"filename": "tests/test_currentscape_currents.py", "chunked_list": ["\"\"\"Test currents methods.\"\"\"\n\nimport numpy as np\n\nfrom currentscape.currents import Currents\n\n\ndef test_currents_init():\n    \"\"\"Test Currents constructor.\"\"\"\n    config = {\n        \"current\": {\"reorder\": False, \"black_line_thickness\": 2, \"names\": [\"Na\", \"Ca\"]},\n        \"currentscape\": {\"y_resolution\": 1000, \"legacy_method\": False},\n        \"pattern\": {\"use\": False, \"patterns\": [\"\", \"//\"]},\n        \"xaxis\": {\"xticks\": None},\n        \"colormap\": {\"n_colors\": 4},\n    }\n\n    currs = Currents([[0, 1], [2, 3]], config)\n    assert config[\"colormap\"][\"n_colors\"] == 2\n    assert currs.image is None\n    assert currs.mapper == 3\n\n    config[\"currentscape\"][\"legacy_method\"] = True\n    currs = Currents([[0, 1], [2, 3]], config)\n    assert np.array_equal(currs.data, [[0, 1], [2, 3]])\n    assert np.array_equal(currs.names, [\"Na\", \"Ca\"])\n    assert currs.mapper is None\n    assert currs.image is not None\n\n    config[\"pattern\"][\"use\"] = True\n    currs = Currents([[0, 1], [2, 3]], config)\n    assert config[\"colormap\"][\"n_colors\"] == 2\n    assert currs.image is None\n    assert currs.mapper == 3\n\n    # this part is a Currents.data_processing() unit test\n    currs = Currents([[-1, 1, -1], [-1, 0, 1], [2, 3, -4]], config)\n    assert np.array_equal(currs.pos_sum, [2, 4, 1])\n    assert np.array_equal(currs.neg_sum, [2, 0, 5])\n    assert np.array_equal(currs.pos_norm.idxs, [0, 1, 2])\n    assert np.array_equal(currs.neg_norm.idxs, [0, 1, 2])\n    assert np.array_equal(currs.pos_norm.data, [[0, 0.25, 0], [0, 0, 1], [1, 0.75, 0]])\n    assert np.array_equal(\n        currs.neg_norm.data, [[-0.5, 0, -0.2], [-0.5, 0, 0], [0, 0, -0.8]]\n    )\n\n    # test data_processing() with zero array\n    currs = Currents([[-1, 1, -1], [-1, 0, -3], [2, 3, 4]], config)\n    assert np.array_equal(currs.pos_sum, [2, 4, 4])\n    assert np.array_equal(currs.neg_sum, [2, 0, 4])\n    assert np.array_equal(currs.pos_norm.idxs, [0, 2])\n    assert np.array_equal(currs.neg_norm.idxs, [0, 1])\n    assert np.array_equal(currs.pos_norm.data, [[0, 0.25, 0], [1, 0.75, 1]])\n    assert np.array_equal(currs.neg_norm.data, [[-0.5, 0, -0.25], [-0.5, 0, -0.75]])\n\n    # test data_processing() with reorder\n    config[\"current\"][\"reorder\"] = True\n    currs = Currents([[-1, 1, -1], [-1, 0, -3], [2, 3, 4]], config)\n    assert np.array_equal(currs.pos_sum, [2, 4, 4])\n    assert np.array_equal(currs.neg_sum, [2, 0, 4])\n    assert np.array_equal(currs.pos_norm.idxs, [2, 0])\n    assert np.array_equal(currs.neg_norm.idxs, [1, 0])\n    assert np.array_equal(currs.pos_norm.data, [[1, 0.75, 1], [0, 0.25, 0]])\n    assert np.array_equal(currs.neg_norm.data, [[-0.5, 0, -0.75], [-0.5, 0, -0.25]])", "\n\ndef test_reorder_currents_and_names():\n    \"\"\"Test reorder_currents_and_names method.\"\"\"\n    config = {\n        \"current\": {\"reorder\": False, \"black_line_thickness\": 2, \"names\": [\"Na\", \"Ca\"]},\n        \"currentscape\": {\"y_resolution\": 1000, \"legacy_method\": False},\n        \"pattern\": {\"use\": True, \"patterns\": [\"\", \"//\"]},\n        \"xaxis\": {\"xticks\": None},\n        \"colormap\": {\"n_colors\": 4},\n    }\n    currs = Currents([[-1, 1, -1], [-1, 0, -3], [2, 3, 4]], config)\n    assert np.array_equal(currs.idxs, [0, 1, 2])\n    cnorm_pos = np.array([[0, 0.25, 0], [0, 0, 0], [1, 0.75, 1]])\n    cnorm_neg = np.array([[-0.5, 0, -0.75], [-0.5, 0, -0.25], [0, 0, 0]])\n    currs.reorder_currents_and_names(cnorm_pos, cnorm_neg)\n    assert np.array_equal(currs.idxs, [2, 0, 1])", "\n\ndef test_create_black_line():\n    \"\"\"Test create_black_line method.\"\"\"\n    config = {\n        \"current\": {\"reorder\": False, \"black_line_thickness\": 2, \"names\": [\"Na\", \"Ca\"]},\n        \"currentscape\": {\"y_resolution\": 1000, \"legacy_method\": False},\n        \"pattern\": {\"use\": False, \"patterns\": [\"\", \"//\"]},\n        \"xaxis\": {\"xticks\": None},\n        \"colormap\": {\"n_colors\": 4},\n    }\n    currs = Currents([[0, 1, 2], [2, 3, 4]], config)\n    # case line_thickness < 1\n    line = currs.create_black_line(10, 2)\n    assert np.array_equal(line, [[2, 2, 2]])\n    assert line.dtype == np.int8\n\n    # case line_thickness > 1 (here: 3)\n    line = currs.create_black_line(100, 3)\n    assert np.array_equal(line, [[2, 2, 2], [2, 2, 2], [2, 2, 2]])\n    assert line.dtype == np.int8", "\n\ndef test_create_cscape_image():\n    \"\"\"Test create_cscape_image method.\"\"\"\n    config = {\n        \"current\": {\"reorder\": False, \"black_line_thickness\": 2, \"names\": [\"Na\", \"Ca\"]},\n        \"currentscape\": {\"y_resolution\": 1000, \"legacy_method\": True},\n        \"pattern\": {\"use\": False, \"patterns\": [\"\", \"//\"]},\n        \"xaxis\": {\"xticks\": None},\n        \"colormap\": {\"n_colors\": 4},\n    }\n\n    currs = Currents([[-1, 1, -1], [-1, 0, -3], [2, 3, 4]], config)\n    # assert dtype is np.int8\n    image = currs.create_cscape_image(8, 2)\n    assert image.dtype == np.int8\n    assert np.array_equal(\n        image,\n        [\n            [2, 0, 2],  # positive curents\n            [2, 0, 2],\n            [2, 2, 2],\n            [2, 2, 2],\n            [2, 2, 2],\n            [2, 2, 2],\n            [2, 2, 2],\n            [2, 2, 2],\n            [3, 3, 3],  # black line\n            [0, 4, 0],  # negative currents\n            [0, 4, 0],\n            [0, 4, 1],\n            [0, 4, 1],\n            [1, 4, 1],\n            [1, 4, 1],\n            [1, 4, 1],\n            [1, 4, 1],\n        ],\n    )\n\n    # try with reorder\n    currs.idxs = [2, 0, 1]\n    image = currs.create_cscape_image(8, 2)\n    assert np.array_equal(\n        image,\n        [\n            [0, 1, 0],  # positive curents\n            [0, 1, 0],\n            [0, 0, 0],\n            [0, 0, 0],\n            [0, 0, 0],\n            [0, 0, 0],\n            [0, 0, 0],\n            [0, 0, 0],\n            [3, 3, 3],  # black line\n            [1, 4, 1],  # negative currents\n            [1, 4, 1],\n            [1, 4, 2],\n            [1, 4, 2],\n            [2, 4, 2],\n            [2, 4, 2],\n            [2, 4, 2],\n            [2, 4, 2],\n        ],\n    )", ""]}
{"filename": "tests/test_currentscape_datasets.py", "chunked_list": ["\"\"\"Test datasets methods.\"\"\"\n\nimport numpy as np\n\nfrom currentscape.datasets import DataSet\n\n\ndef test_dataset_init():\n    \"\"\"Test Dataset constructor.\"\"\"\n    ds = DataSet(data=None)\n    assert ds.data is None\n    assert ds.N is None\n    assert ds.idxs is None\n    assert ds.x_size is None\n\n    ds = DataSet(data=[])\n    assert np.array_equal(ds.data, [])\n    assert ds.N == 0\n    assert np.array_equal(ds.idxs, [])\n    assert ds.x_size == 0\n\n    ds = DataSet(data=[[0, 1, 2], [1, 2, 3]])\n    assert isinstance(ds.data, np.ndarray)\n    assert np.array_equal(ds.data, [[0, 1, 2], [1, 2, 3]])\n    assert ds.N == 2\n    assert np.array_equal(ds.idxs, [0, 1])\n    assert ds.x_size == 3\n    assert np.array_equal(ds.time, [0, 1, 2])\n\n    ds = DataSet(data=None, names=[\"Ca\", \"Na\"])\n    assert np.array_equal(ds.names, [\"Ca\", \"Na\"])\n\n    ds = DataSet(data=None, time=[4, 5, 6])\n    assert np.array_equal(ds.time, [4, 5, 6])\n\n    ds = DataSet(data=None, xticks=[10, 20])\n    assert np.array_equal(ds.xticks, [10, 20])", "\n\ndef test_get_negative_data():\n    \"\"\"Test get_negative_data method.\"\"\"\n    ds = DataSet(data=[[-1, 1], [2, -3]])\n    assert np.array_equal(ds.get_negative_data(), [[-1, 0], [0, -3]])\n\n\ndef test_get_positive_data():\n    \"\"\"Test get_positive_data method.\"\"\"\n    ds = DataSet(data=[[-1, 1], [2, -3]])\n    assert np.array_equal(ds.get_positive_data(), [[0, 1], [2, 0]])", "def test_get_positive_data():\n    \"\"\"Test get_positive_data method.\"\"\"\n    ds = DataSet(data=[[-1, 1], [2, -3]])\n    assert np.array_equal(ds.get_positive_data(), [[0, 1], [2, 0]])\n\n\ndef test_dataset_xticks():\n    \"\"\"Test the DataSet function that automatically sets xticks.\"\"\"\n    ds0 = DataSet(data=None, time=None)\n    assert ds0.xticks is None\n\n    ds0 = DataSet(data=None, time=[])\n    assert ds0.xticks is None\n\n    ds0 = DataSet(data=None, time=[1.234])\n    assert np.array_equal(ds0.xticks, [1.234])\n\n    ds1 = DataSet(data=None, time=np.arange(0, 2000, 10))\n    assert np.array_equal(\n        ds1.xticks, [0.0, 250.0, 500.0, 750.0, 1000.0, 1250.0, 1500.0, 1750.0]\n    )\n\n    ds2 = DataSet(data=None, time=np.arange(0, 2001, 10))\n    assert np.array_equal(ds2.xticks, [0, 500, 1000, 1500, 2000])\n\n    ds3 = DataSet(data=None, time=np.array([0, 0.51]))\n    # round to avoid floating errors\n    ds3ticks = np.around(ds3.xticks, decimals=1)\n    expected_ds3 = np.around([0.0, 0.1, 0.2, 0.3, 0.4, 0.5], decimals=1)\n    assert np.array_equal(ds3ticks, expected_ds3)\n\n    ds4 = DataSet(data=None, time=np.arange(1002, 1055, 1))\n    assert np.array_equal(ds4.xticks, [1010, 1020, 1030, 1040, 1050])\n\n    ds5 = DataSet(data=None, time=np.arange(999, 1005, 1))\n    assert np.array_equal(ds5.xticks, [999, 1000, 1001, 1002, 1003, 1004])", "\n\ndef test_xticks_for_imshow():\n    \"\"\"Test xticks_for_imshow method.\"\"\"\n    ds = DataSet(data=None, time=[0, 1], xticks=[0, 1])\n    assert ds.xticks_for_imshow() is None\n\n    ds = DataSet(data=[[1], [2]], time=[0], xticks=[0])\n    assert np.array_equal(ds.xticks_for_imshow(), [0])\n\n    ds = DataSet(data=[[0, 1, 2], [2, 3, 4]], time=[1, 3], xticks=[1.5, 2.5])\n    assert np.array_equal(ds.xticks_for_imshow(), [0.75, 2.25])", ""]}
{"filename": "tests/test_currentscape_config_parser.py", "chunked_list": ["\"\"\"Test currentscape config parser.\"\"\"\n\nfrom logging import WARNING\n\nfrom pytest import LogCaptureFixture\n\nfrom currentscape.config_parser import check_config, replace_defaults\n\n\ndef test_check_config(caplog: LogCaptureFixture):\n    \"\"\"Test that check_config warns when discrepancy between patterns and line styles.\"\"\"\n    config = {\n        \"pattern\": {\"use\": True, \"patterns\": [\"\", \"/\", \"\\\\\"]},\n        \"show\": {\"all_currents\": True},\n        \"line\": {\"styles\": [\"solid\", (0, (1, 1))]},\n    }\n\n    caplog.set_level(WARNING)\n    check_config(config)\n    assert (\n        \"currentscape.config_parser\",\n        WARNING,\n        \"line:styles should have as many items as pattern:patterns.\",\n    ) in caplog.record_tuples", "\ndef test_check_config(caplog: LogCaptureFixture):\n    \"\"\"Test that check_config warns when discrepancy between patterns and line styles.\"\"\"\n    config = {\n        \"pattern\": {\"use\": True, \"patterns\": [\"\", \"/\", \"\\\\\"]},\n        \"show\": {\"all_currents\": True},\n        \"line\": {\"styles\": [\"solid\", (0, (1, 1))]},\n    }\n\n    caplog.set_level(WARNING)\n    check_config(config)\n    assert (\n        \"currentscape.config_parser\",\n        WARNING,\n        \"line:styles should have as many items as pattern:patterns.\",\n    ) in caplog.record_tuples", "\n\ndef test_replace_defaults():\n    \"\"\"Test replace_defaults function.\"\"\"\n    # replace non-dict\n    default_config = {\"test\": 1}\n    user_config = {\"test\": 2}\n    new_config = replace_defaults(default_config, user_config)\n    assert new_config == {\"test\": 2}\n\n    # add non-dict\n    default_config = {}\n    user_config = {\"test\": 2}\n    new_config = replace_defaults(default_config, user_config)\n    assert new_config == {\"test\": 2}\n\n    # no input\n    default_config = {\"test\": 1}\n    user_config = {}\n    new_config = replace_defaults(default_config, user_config)\n    assert new_config == {\"test\": 1}\n\n    # replace in dict\n    default_config = {\"test\": {\"inner\": 1}}\n    user_config = {\"test\": {\"inner\": 2}}\n    new_config = replace_defaults(default_config, user_config)\n    assert new_config == {\"test\": {\"inner\": 2}}\n\n    # add item to dict\n    default_config = {\"test\": {\"inner\": 1}}\n    user_config = {\"test\": {\"new\": 2}}\n    new_config = replace_defaults(default_config, user_config)\n    assert new_config == {\"test\": {\"inner\": 1, \"new\": 2}}", ""]}
{"filename": "tests/test_currentscape_from_paper.py", "chunked_list": ["\"\"\"Test that example produces a figure.\"\"\"\nimport os\nimport sys\nfrom tests.utils import cwd\n\nEXAMPLE_FOLDER = os.path.join(\"examples\", \"original_paper_plot\")\nsys.path.insert(0, os.path.abspath(EXAMPLE_FOLDER))\n\n\ndef test_example_original_paper():\n    with cwd(EXAMPLE_FOLDER):\n        from integrate_single_compartment_and_plot_currentscape import (\n            plot_from_original_paper,\n        )\n\n        _ = plot_from_original_paper(tf=2500.0, dt=1.0)\n\n    assert os.path.isfile(os.path.join(EXAMPLE_FOLDER, \"output\", \"example.png\"))", "\ndef test_example_original_paper():\n    with cwd(EXAMPLE_FOLDER):\n        from integrate_single_compartment_and_plot_currentscape import (\n            plot_from_original_paper,\n        )\n\n        _ = plot_from_original_paper(tf=2500.0, dt=1.0)\n\n    assert os.path.isfile(os.path.join(EXAMPLE_FOLDER, \"output\", \"example.png\"))", ""]}
{"filename": "tests/__init__.py", "chunked_list": [""]}
{"filename": "tests/test_currentscape_ions.py", "chunked_list": ["\"\"\"Test ions methods.\"\"\"\n\nimport numpy as np\n\nfrom currentscape.ions import IonConcentrations\n\n\ndef test_ionconcentrations_init():\n    \"\"\"Test IonConcentrations constructor.\"\"\"\n    # data is None case\n    config = {\n        \"ions\": {\"reorder\": False, \"names\": [\"Ca\", \"Na\"]},\n        \"pattern\": {\"use\": True, \"patterns\": [\"\", \"//\"]},\n        \"xaxis\": {\"xticks\": None},\n        \"colormap\": {\"n_colors\": 3},\n    }\n    ions = IonConcentrations(None, config)\n    assert ions.data is None\n    assert np.array_equal(ions.names, [\"Ca\", \"Na\"])\n    assert ions.mapper is None\n\n    # data is not None but patter use is False case\n    config[\"pattern\"][\"use\"] = False\n    ions = IonConcentrations([[1, 2], [3, 4]], config)\n    assert ions.mapper is None\n    assert np.array_equal(ions.idxs, [0, 1])\n\n    # data not None, pattern use True, and n_colors > len(data) case\n    config[\"pattern\"][\"use\"] = True\n    ions = IonConcentrations([[1, 2], [3, 4]], config)\n    assert ions.mapper == 3\n\n    # data not None, pattern use True, and n_colors < len(data) case\n    ions = IonConcentrations([[1, 2], [3, 4], [5, 6], [7, 8], [9, 0]], config)\n    assert ions.mapper == 5\n\n    # data not None and reorder True\n    config[\"ions\"][\"reorder\"] = True\n    ions = IonConcentrations([[1, 2], [3, 4]], config)\n    assert np.array_equal(ions.idxs, [1, 0])", ""]}
{"filename": "tests/utils.py", "chunked_list": ["\"\"\"Utils.\"\"\"\nimport os\nfrom contextlib import contextmanager\n\n\n@contextmanager\ndef cwd(path):\n    \"\"\"Cwd function that can be used in a context manager.\"\"\"\n    old_dir = os.getcwd()\n    os.chdir(path)\n    yield\n    os.chdir(old_dir)", ""]}
{"filename": "tests/test_currentscape_plotting.py", "chunked_list": ["\"\"\"Test currentscape plotting functions.\"\"\"\n\nfrom logging import WARNING\nimport os\n\nimport matplotlib\n\nmatplotlib.use(\"agg\")  # to avoid tkinter error\nimport matplotlib.pyplot as plt\nimport numpy as np", "import matplotlib.pyplot as plt\nimport numpy as np\nfrom pytest import LogCaptureFixture\n\nfrom currentscape.ions import IonConcentrations\nfrom currentscape.plotting import (\n    configure_mpl_rcParams,\n    get_rows_tot,\n    get_colors,\n    get_colormap,", "    get_colors,\n    get_colormap,\n    select_color,\n    get_colors_hatches_lines_lists,\n    save_figure,\n)\n\n\ndef test_configure_mpl_rcParams():\n    \"\"\"Test configure_mpl_rcParams function.\"\"\"\n    config = {\n        \"textsize\": 6,\n        \"legend\": {\"textsize\": 4, \"handlelength\": 1.4},\n        \"pattern\": {\"use\": False, \"linewidth\": 0.2},\n    }\n\n    configure_mpl_rcParams(config)\n    assert plt.rcParams[\"axes.labelsize\"] == 6\n    assert plt.rcParams[\"xtick.labelsize\"] == 6\n    assert plt.rcParams[\"ytick.labelsize\"] == 6\n    assert plt.rcParams[\"legend.fontsize\"] == 4\n    assert plt.rcParams[\"legend.handletextpad\"] == 0\n    assert plt.rcParams[\"legend.labelspacing\"] == 0\n    assert plt.rcParams[\"legend.handlelength\"] == 0\n\n    config[\"pattern\"][\"use\"] = True\n    configure_mpl_rcParams(config)\n    assert plt.rcParams[\"axes.labelsize\"] == 6\n    assert plt.rcParams[\"xtick.labelsize\"] == 6\n    assert plt.rcParams[\"ytick.labelsize\"] == 6\n    assert plt.rcParams[\"legend.fontsize\"] == 4\n    assert plt.rcParams[\"hatch.linewidth\"] == 0.2\n    assert plt.rcParams[\"legend.handlelength\"] == 1.4", "def test_configure_mpl_rcParams():\n    \"\"\"Test configure_mpl_rcParams function.\"\"\"\n    config = {\n        \"textsize\": 6,\n        \"legend\": {\"textsize\": 4, \"handlelength\": 1.4},\n        \"pattern\": {\"use\": False, \"linewidth\": 0.2},\n    }\n\n    configure_mpl_rcParams(config)\n    assert plt.rcParams[\"axes.labelsize\"] == 6\n    assert plt.rcParams[\"xtick.labelsize\"] == 6\n    assert plt.rcParams[\"ytick.labelsize\"] == 6\n    assert plt.rcParams[\"legend.fontsize\"] == 4\n    assert plt.rcParams[\"legend.handletextpad\"] == 0\n    assert plt.rcParams[\"legend.labelspacing\"] == 0\n    assert plt.rcParams[\"legend.handlelength\"] == 0\n\n    config[\"pattern\"][\"use\"] = True\n    configure_mpl_rcParams(config)\n    assert plt.rcParams[\"axes.labelsize\"] == 6\n    assert plt.rcParams[\"xtick.labelsize\"] == 6\n    assert plt.rcParams[\"ytick.labelsize\"] == 6\n    assert plt.rcParams[\"legend.fontsize\"] == 4\n    assert plt.rcParams[\"hatch.linewidth\"] == 0.2\n    assert plt.rcParams[\"legend.handlelength\"] == 1.4", "\n\ndef test_get_rows_tot():\n    \"\"\"Test get_rows_tot function.\"\"\"\n    config = {\n        \"pattern\": {\"use\": False, \"patterns\": []},\n        \"show\": {\"all_currents\": False, \"total_contribution\": False},\n        \"ions\": {\"reorder\": False, \"names\": None},\n        \"xaxis\": {\"xticks\": None},\n        \"currentscape\": {\"legacy_method\": True},\n    }\n    ions = IonConcentrations(None, config)\n\n    rows = get_rows_tot(config, ions)\n    assert rows == 7\n\n    config[\"pattern\"][\"use\"] = True\n    rows = get_rows_tot(config, ions)\n    assert rows == 8\n\n    config[\"pattern\"][\"use\"] = False\n    config[\"currentscape\"][\"legacy_method\"] = False\n    rows = get_rows_tot(config, ions)\n    assert rows == 8\n\n    config[\"pattern\"][\"use\"] = False\n    config[\"show\"][\"all_currents\"] = True\n    rows = get_rows_tot(config, ions)\n    assert rows == 10\n\n    config[\"show\"][\"all_currents\"] = False\n    config[\"show\"][\"total_contribution\"] = True\n    rows = get_rows_tot(config, ions)\n    assert rows == 10\n\n    config[\"show\"][\"total_contribution\"] = False\n    ions.data = [[1, 2], [3, 4]]\n    rows = get_rows_tot(config, ions)\n    assert rows == 9\n\n    config[\"pattern\"][\"use\"] = True\n    config[\"show\"][\"all_currents\"] = True\n    config[\"show\"][\"total_contribution\"] = True\n    rows = get_rows_tot(config, ions)\n    assert rows == 13", "\n\ndef test_get_colors():\n    \"\"\"Test get_colors function.\n\n    Check that matplotlib and palettable cmap are acepted.\n    Check the bool indicating a number of colors too big.\n    \"\"\"\n    # matplotlib, enough colors\n    l, cmap_too_small = get_colors(\"Set1\", 8)\n    assert not cmap_too_small\n    assert len(l) == len(set(tuple(item) for item in l))  # no duplicates\n\n    # matplotlib, not enough colors\n    l, cmap_too_small = get_colors(\"Set1\", 30)\n    assert cmap_too_small\n    assert len(l) > len(set(tuple(item) for item in l))  # no duplicates\n\n    # palettable, enough colors\n    _, cmap_too_small = get_colors(\"cartocolors.qualitative.Antique_8\", 8)\n    assert not cmap_too_small\n\n    # palettable, not enough colors\n    _, cmap_too_small = get_colors(\"cartocolors.qualitative.Antique_8\", 9)\n    assert cmap_too_small", "\n\ndef test_get_colormap(caplog: LogCaptureFixture):\n    \"\"\"Test get_colormap function.\n\n    Check that black and white colors are present at the end of colormap.\n    Check that warnings are launched.\n    \"\"\"\n    cmap = get_colormap(\n        cmap=\"Set1\", n_colors=6, use_patterns=False, N_curr=6, N_ion=None\n    )\n    assert len(cmap.colors) == 8\n    assert np.array_equal(cmap.colors[-2], [0, 0, 0, 1])\n    assert np.array_equal(cmap.colors[-1], [1, 1, 1, 1])\n\n    caplog.set_level(WARNING)\n    get_colormap(cmap=\"Set1\", n_colors=6, use_patterns=False, N_curr=30, N_ion=None)\n    assert (\n        \"currentscape.plotting\",\n        WARNING,\n        \"The number of colors in the colormap \"\n        \"is smaller than the number of currents. \"\n        \"Please, choose a colormap with more colors \"\n        \"or use patterns for optimal display.\",\n    ) in caplog.record_tuples\n\n    get_colormap(cmap=\"Set1\", n_colors=25, use_patterns=True, N_curr=30, N_ion=None)\n    assert (\n        \"currentscape.plotting\",\n        WARNING,\n        \"'n_colors' in 'colormap' in config is larger than \"\n        \"the number of colors in the colormap. \"\n        \"Please, choose a colormap with more colors \"\n        \"or decrease n_colors for optimal display.\",\n    ) in caplog.record_tuples", "\n\ndef test_select_color():\n    \"\"\"Test select_color function.\"\"\"\n    # colormap with 2 colors + black + white\n    cmap = get_colormap(\n        cmap=\"Set1\", n_colors=None, use_patterns=False, N_curr=2, N_ion=None\n    )\n    assert len(cmap.colors) == 4\n\n    # assert the two colors are different\n    assert select_color(cmap, 0, 2) != select_color(cmap, 1, 2)\n    # assert 3rd is black\n    assert np.array_equal(select_color(cmap, 2, 2), (0, 0, 0, 1))\n    # assert 4th is white\n    assert np.array_equal(select_color(cmap, 3, 2), (1, 1, 1, 1))", "\n\ndef to_tuple(lst):\n    return tuple(to_tuple(i) if isinstance(i, list) else i for i in lst)\n\n\ndef test_get_colors_hatches_lines_lists():\n    \"\"\"Test get_colors_and_hatches_lists function.\"\"\"\n    linestyles = [\n        \"solid\",\n        [0, [1, 1]],\n        [0, [2, 1]],\n        [0, [2, 1, 1, 1]],\n        [0, [2, 1, 1, 1, 1, 1]],\n        [0, [2, 1, 2, 1, 1, 1]],\n        [0, [2, 1, 2, 1, 1, 1, 1, 1]],\n    ]\n    # do not use pattern case\n    config = {\"pattern\": {\"use\": False}}\n    curr_idxs = np.arange(4)\n    cmap = get_colormap(\n        cmap=\"Set1\", n_colors=None, use_patterns=False, N_curr=4, N_ion=None\n    )\n    colors, hatches, lines = get_colors_hatches_lines_lists(\n        config, curr_idxs, cmap, mapper=None\n    )\n    assert len(colors) == 4\n    assert hatches is None\n    assert np.array_equal(lines, np.full(4, \"solid\"))\n\n    # use pattern case\n    config = {\n        \"pattern\": {\n            \"use\": True,\n            \"density\": 5,\n            \"patterns\": [\"\", \"/\", \"\\\\\", \"x\", \".\", \"o\", \"+\"],\n        },\n        \"colormap\": {\"n_colors\": 4},\n        \"line\": {\"styles\": linestyles},\n    }\n    cmap = get_colormap(\n        cmap=\"Set1\", n_colors=4, use_patterns=True, N_curr=4, N_ion=None\n    )\n    colors, hatches, lines = get_colors_hatches_lines_lists(\n        config, curr_idxs, cmap, mapper=9\n    )\n    assert len(colors) == 4\n    assert len(hatches) == 4\n    assert len(lines) == 4\n    # no repetition because N_curr <= n_colors, and N_curr <= len(patterns)\n    assert len(colors) == len(set(tuple(color) for color in colors))\n    assert len(hatches) == len(set(tuple(hatch) for hatch in hatches))\n    assert len(lines) == len(set(to_tuple(lines)))\n\n    # now with n_curr > n_colors, n_currs > len(patterns)\n    cmap = get_colormap(\n        cmap=\"Set1\", n_colors=4, use_patterns=True, N_curr=20, N_ion=None\n    )\n    curr_idxs = np.arange(20)\n    colors, hatches, lines = get_colors_hatches_lines_lists(\n        config, curr_idxs, cmap, mapper=9\n    )\n    assert len(colors) == 20\n    assert len(hatches) == 20\n    assert len(lines) == 20\n\n    # colors and hatches get combined with (colors[i], hatches[i])\n    # all combinations should be unique\n    combinations = []\n    for col, hatch in zip(colors, hatches):\n        combinations.append((tuple(col), hatch))\n    assert len(combinations) == len(set(combinations)) == 20\n    combinations = []\n    for col, line in zip(colors, lines):\n        combinations.append((tuple(col), to_tuple(line)))\n    assert len(combinations) == len(set(combinations)) == 20", "\n\ndef test_save_figure():\n    \"\"\"Test save_figure function.\"\"\"\n    fpath = \"tests/output/test_savefig.png\"\n    config = {\n        \"output\": {\n            \"dir\": \"tests/output\",\n            \"fname\": \"test_savefig\",\n            \"extension\": \"png\",\n            \"dpi\": 100,\n            \"transparent\": False,\n        }\n    }\n\n    fig = plt.figure()\n    save_figure(fig, config)\n    assert os.path.isfile(fpath)", ""]}
{"filename": "tests/test_use_case_example.py", "chunked_list": ["\"\"\"Test that example produces a figure.\"\"\"\nimport os\nimport subprocess\nimport sys\nfrom tests.utils import cwd\n\nEXAMPLE_FOLDER = os.path.join(\"examples\", \"use_case\")\nsys.path.insert(0, os.path.abspath(EXAMPLE_FOLDER))\n\n\ndef test_extraction_and_plot():\n    with cwd(EXAMPLE_FOLDER):\n        from run import run\n        from plot import plot\n\n        subprocess.call([\"nrnivmodl\", \"mechanisms\"])\n        run()\n        outputs = [\n            \"cai.dat\",\n            \"i_pas.dat\",\n            \"ica_Ca_HVA2.dat\",\n            \"ica_Ca_LVAst.dat\",\n            \"ihcn_Ih.dat\",\n            \"ik_K_Pst.dat\",\n            \"ik_K_Tst.dat\",\n            \"ik_SK_E2.dat\",\n            \"ik_SKv3_1.dat\",\n            \"ina_NaTg.dat\",\n            \"ki.dat\",\n            \"nai.dat\",\n            \"v.dat\",\n        ]\n\n    for output in outputs:\n        assert os.path.isfile(os.path.join(EXAMPLE_FOLDER, \"python_recordings\", output))\n\n    fig = plot()\n    assert len(fig.axes) == 6", "\n\ndef test_extraction_and_plot():\n    with cwd(EXAMPLE_FOLDER):\n        from run import run\n        from plot import plot\n\n        subprocess.call([\"nrnivmodl\", \"mechanisms\"])\n        run()\n        outputs = [\n            \"cai.dat\",\n            \"i_pas.dat\",\n            \"ica_Ca_HVA2.dat\",\n            \"ica_Ca_LVAst.dat\",\n            \"ihcn_Ih.dat\",\n            \"ik_K_Pst.dat\",\n            \"ik_K_Tst.dat\",\n            \"ik_SK_E2.dat\",\n            \"ik_SKv3_1.dat\",\n            \"ina_NaTg.dat\",\n            \"ki.dat\",\n            \"nai.dat\",\n            \"v.dat\",\n        ]\n\n    for output in outputs:\n        assert os.path.isfile(os.path.join(EXAMPLE_FOLDER, \"python_recordings\", output))\n\n    fig = plot()\n    assert len(fig.axes) == 6", ""]}
{"filename": "currentscape/mapper.py", "chunked_list": ["\"\"\"Mappers.\"\"\"\n\n# Copyright 2023 Blue Brain Project / EPFL\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n", "#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# pylint: disable=deprecated-method\ntry:\n    # python 3\n    from math import gcd\nexcept ImportError:\n    # python 2\n    from fractions import gcd", "# pylint: disable=deprecated-method\ntry:\n    # python 3\n    from math import gcd\nexcept ImportError:\n    # python 2\n    from fractions import gcd\n\n\ndef has_common_divisor(n1, n2, n):\n    \"\"\"Return True if n has a common divisor with either n1 or n2.\"\"\"\n    if gcd(n, n1) == 1 and gcd(n, n2) == 1:\n        return False\n    return True", "\ndef has_common_divisor(n1, n2, n):\n    \"\"\"Return True if n has a common divisor with either n1 or n2.\"\"\"\n    if gcd(n, n1) == 1 and gcd(n, n2) == 1:\n        return False\n    return True\n\n\ndef create_mapper(n_colors, n_patterns):\n    \"\"\"Find a number n that will be useful to find pairs (color, pattern).\n\n    Those pairs should not have the same color in a row and the same pattern in a row.\n    n should work as in the following example.\n\n    Example:\n        for i in range(n_currents):\n            color = (n*i) % n_colors\n            pattern = ( (n*i) // n_colors) % n_patterns\n\n    Constraints:\n        * For two patterns to be different in a row: n>=n_patterns\n        * n should not have a common divisor with either n_colors or n_patterns.\n    \"\"\"\n    mapper = n_patterns\n    while has_common_divisor(n_colors, n_patterns, mapper):\n        mapper += 1\n    return mapper", "def create_mapper(n_colors, n_patterns):\n    \"\"\"Find a number n that will be useful to find pairs (color, pattern).\n\n    Those pairs should not have the same color in a row and the same pattern in a row.\n    n should work as in the following example.\n\n    Example:\n        for i in range(n_currents):\n            color = (n*i) % n_colors\n            pattern = ( (n*i) // n_colors) % n_patterns\n\n    Constraints:\n        * For two patterns to be different in a row: n>=n_patterns\n        * n should not have a common divisor with either n_colors or n_patterns.\n    \"\"\"\n    mapper = n_patterns\n    while has_common_divisor(n_colors, n_patterns, mapper):\n        mapper += 1\n    return mapper", "\n\ndef map_colors(curr_idxs, n_colors, mapper):\n    \"\"\"Get color index(es) s.t. a color / pattern index pair cannot be produced twice.\n\n    Args:\n        curr_idxs (int or ndarray of ints): index(es) of the current(s).\n            should be smaller than number of currents\n        n_colors (int): total number of colors\n        mapper (int): number used to mix colors and patterns\n    \"\"\"\n    return (mapper * curr_idxs) % n_colors", "\n\ndef map_patterns(curr_idxs, n_colors, n_patterns, mapper):\n    \"\"\"Get pattern index(es) s.t. a color / pattern index pair cannot be produced twice.\n\n    Args:\n        curr_idxs (int or ndarray of ints): index(es) of the current(s).\n            should be smaller than number of currents\n        n_colors (int): total number of colors\n        n_patterns (int): total number of patterns\n        mapper (int): number used to mix colors and patterns\n    \"\"\"\n    return ((mapper * curr_idxs) // n_colors) % n_patterns", ""]}
{"filename": "currentscape/voltages.py", "chunked_list": ["\"\"\"Voltages class.\"\"\"\n\n# Copyright 2023 Blue Brain Project / EPFL\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n", "#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# pylint: disable=wrong-import-position, super-with-arguments\nimport numpy as np", "# pylint: disable=wrong-import-position, super-with-arguments\nimport numpy as np\nimport matplotlib\n\nmatplotlib.use(\"agg\")  # to avoid tkinter error\nimport matplotlib.pyplot as plt\n\nfrom currentscape.datasets import DataSet\nfrom currentscape.plotting import remove_ticks_and_frame, show_xgridlines\n", "from currentscape.plotting import remove_ticks_and_frame, show_xgridlines\n\n\nclass Voltages(DataSet):\n    \"\"\"Class containing voltage data.\"\"\"\n\n    def __init__(self, data, c, time):\n        \"\"\"Constructor.\n\n        Args:\n            data (list): data\n            c (dict): config\n            time (list): time of the data\n        \"\"\"\n        # DataSet expect a list of lists as data\n        super(Voltages, self).__init__(\n            data=[data], names=None, time=time, xticks=c[\"xaxis\"][\"xticks\"]\n        )\n\n    def plot(self, c, row, rows_tot):\n        \"\"\"Plot voltage trace.\n\n        Args:\n            c (dict): config\n            row (int): row of subplot\n            rows_tot (int): total number of subplots in the figure\n        \"\"\"\n        ax = plt.subplot2grid((rows_tot, 1), (row, 0), rowspan=2)\n\n        ax.plot(self.time, self.data[0], color=c[\"voltage\"][\"color\"], lw=c[\"lw\"])\n\n        ax.plot(\n            self.time,\n            np.ones(self.x_size) * c[\"voltage\"][\"ticks\"][0],\n            ls=\"dashed\",\n            color=\"black\",\n            lw=0.75,\n        )\n\n        ax.vlines(\n            1, c[\"voltage\"][\"ticks\"][0], c[\"voltage\"][\"ticks\"][-1], lw=1, color=\"black\"\n        )\n\n        ax.set_ylim(c[\"voltage\"][\"ylim\"])\n        ax.set_xlim([self.time[0], self.time[-1]])\n\n        # show x axis gridline\n        if c[\"show\"][\"xgridlines\"]:\n            show_xgridlines(ax, c, self.xticks, c[\"voltage\"][\"ylim\"])\n\n        if c[\"show\"][\"ylabels\"]:\n            ax.set_ylabel(c[\"voltage\"][\"units\"], labelpad=c[\"labelpad\"])\n        if c[\"show\"][\"yticklabels\"]:\n            ax.set_yticks(c[\"voltage\"][\"ticks\"])\n\n        remove_ticks_and_frame(ax)", ""]}
{"filename": "currentscape/plotting.py", "chunked_list": ["\"\"\"Plotting-related functions.\"\"\"\n\n# Copyright 2023 Blue Brain Project / EPFL\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n", "#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# pylint: disable=too-many-locals, wrong-import-position\nimport logging", "# pylint: disable=too-many-locals, wrong-import-position\nimport logging\nfrom pathlib import Path\n\nimport numpy as np\nimport matplotlib\n\nmatplotlib.use(\"agg\")  # to avoid tkinter error\nimport matplotlib.pyplot as plt\n", "import matplotlib.pyplot as plt\n\nimport palettable as pltb\n\nfrom currentscape.data_processing import sum_chunks\nfrom currentscape.mapper import map_colors, map_patterns\n\nlogger = logging.getLogger(__name__)\n\n\ndef configure_mpl_rcParams(c):\n    \"\"\"Configure matplotlib rcParams.\n\n    Args:\n        c (dict): config\n    \"\"\"\n    # set text size\n    plt.rcParams[\"axes.labelsize\"] = c[\"textsize\"]\n    plt.rcParams[\"xtick.labelsize\"] = c[\"textsize\"]\n    plt.rcParams[\"ytick.labelsize\"] = c[\"textsize\"]\n    plt.rcParams[\"legend.fontsize\"] = c[\"legend\"][\"textsize\"]\n    if c[\"pattern\"][\"use\"]:\n        plt.rcParams[\"hatch.linewidth\"] = c[\"pattern\"][\"linewidth\"]\n        plt.rcParams[\"legend.handlelength\"] = c[\"legend\"][\"handlelength\"]\n    else:\n        # remove legend handles\n        plt.rcParams[\"legend.handletextpad\"] = 0\n        plt.rcParams[\"legend.labelspacing\"] = 0\n        plt.rcParams[\"legend.handlelength\"] = 0", "\n\ndef configure_mpl_rcParams(c):\n    \"\"\"Configure matplotlib rcParams.\n\n    Args:\n        c (dict): config\n    \"\"\"\n    # set text size\n    plt.rcParams[\"axes.labelsize\"] = c[\"textsize\"]\n    plt.rcParams[\"xtick.labelsize\"] = c[\"textsize\"]\n    plt.rcParams[\"ytick.labelsize\"] = c[\"textsize\"]\n    plt.rcParams[\"legend.fontsize\"] = c[\"legend\"][\"textsize\"]\n    if c[\"pattern\"][\"use\"]:\n        plt.rcParams[\"hatch.linewidth\"] = c[\"pattern\"][\"linewidth\"]\n        plt.rcParams[\"legend.handlelength\"] = c[\"legend\"][\"handlelength\"]\n    else:\n        # remove legend handles\n        plt.rcParams[\"legend.handletextpad\"] = 0\n        plt.rcParams[\"legend.labelspacing\"] = 0\n        plt.rcParams[\"legend.handlelength\"] = 0", "\n\ndef get_rows_tot(c, ions):\n    \"\"\"Return the total number of rows cumulated by all the subplots.\n\n    Args:\n        c (dict): config\n        ions (IonConcentrations): ion concentration dataset\n    \"\"\"\n    rows_tot = 7\n    if not c[\"currentscape\"][\"legacy_method\"] or c[\"pattern\"][\"use\"]:\n        rows_tot += 1\n    if c[\"show\"][\"all_currents\"]:\n        rows_tot += 2\n    if ions.data is not None:\n        rows_tot += 1\n    if c[\"show\"][\"total_contribution\"]:\n        rows_tot += 2\n\n    return rows_tot", "\n\ndef get_colors_hatches_lines_lists(c, curr_idxs, cmap, mapper=None):\n    \"\"\"Get colors and hatches and lines lists from color indexes list.\n\n    Args:\n        c (dict): config\n        curr_idxs (ndarray of ints or int): list of indexes of currents\n        cmap (matplotlib.colors.Colormap): colormap\n        mapper (int): number used to mix colors and patterns\n    \"\"\"\n    if c[\"pattern\"][\"use\"]:\n        n_colors = c[\"colormap\"][\"n_colors\"]\n        patterns = np.array(\n            [x * c[\"pattern\"][\"density\"] for x in c[\"pattern\"][\"patterns\"]]\n        )\n        ls = np.array(c[\"line\"][\"styles\"], dtype=object)\n\n        colors = cmap(map_colors(curr_idxs, n_colors, mapper))\n        hatches = patterns[map_patterns(curr_idxs, n_colors, len(patterns), mapper)]\n        lines = ls[map_patterns(curr_idxs, n_colors, len(ls), mapper)]\n    else:\n        colors = cmap(curr_idxs)\n        hatches = None\n        lines = \"solid\"\n        if not np.isscalar(curr_idxs):\n            lines = np.full(curr_idxs.size, \"solid\")\n\n    return colors, hatches, lines", "\n\ndef stackplot_with_bars(\n    ax,\n    cnorm,\n    inames,\n    cmap,\n    c,\n    N_curr,\n    mapper=None,\n    top_to_bottom=True,\n):\n    \"\"\"Plot currentscape using bars instead of imshow.\n\n    That way, hatches (patterns) can be used.\n\n    Args:\n        ax (matplotlib.axes): currentscape axis\n        cnorm (DataSet): object containing data (e.g. currents data and idxs)\n        inames (ndarray of ints): indexes to new name order (new_names = names[inames])\n        cmap (matplotlib.colors.Colormap): colormap\n        c (dict): config\n        N_curr (int): total number of currents\n        mapper (int): number used to mix colors and patterns\n        top_to_bottom (bool): if True, plot from top to bottom. if False, plot from bottom to top\n\n    Returns the size modified by sum chunks (reduced x resolution)\n    \"\"\"\n    chunksize = c[\"stackplot\"][\"x_chunksize\"]\n\n    currs = sum_chunks(np.abs(cnorm.data), chunksize)  # reduce data x resolution\n\n    imap = np.zeros(N_curr, dtype=int)\n    imap[inames] = np.arange(N_curr)\n\n    size = len(currs[0])\n    step = float(cnorm.time[-1] - cnorm.time[0]) / size\n    x = np.arange(cnorm.time[0], cnorm.time[-1], step)\n\n    if top_to_bottom:\n        # stack from the top to bottom, like in create_cscape_image func.\n        bottom = np.ones(size)\n    else:\n        bottom = np.zeros(size)\n\n    for idx, curr in zip(cnorm.idxs, currs):\n        if not np.all(curr == 0):\n            color, hatch, _ = get_colors_hatches_lines_lists(c, imap[idx], cmap, mapper)\n\n            if top_to_bottom:\n                bottom -= curr\n\n            ax.bar(\n                x,\n                curr,\n                color=color,\n                edgecolor=c[\"pattern\"][\"color\"],\n                linewidth=0,  # do not draw edges\n                width=step,  # fill all the space between two bars\n                hatch=hatch,\n                bottom=bottom,\n                align=\"edge\",  # Align the left edges of the bars with the x positions.\n                zorder=2,\n            )\n\n            if not top_to_bottom:\n                bottom += curr", "\n\ndef stackplot_with_fill_between(\n    ax,\n    cnorm,\n    inames,\n    cmap,\n    c,\n    N_curr,\n    mapper=None,\n    top_to_bottom=True,\n):\n    \"\"\"Plot currentscape using fill_between.\n\n    Args:\n        ax (matplotlib.axes): currentscape axis\n        cnorm (DataSet): object containing data (e.g. currents data and idxs)\n        inames (ndarray of ints): indexes to new name order (new_names = names[inames])\n        cmap (matplotlib.colors.Colormap): colormap\n        c (dict): config\n        N_curr (int): total number of currents\n        mapper (int): number used to mix colors and patterns\n        top_to_bottom (bool): if True, plot from top to bottom. if False, plot from bottom to top\n    \"\"\"\n    currs = np.abs(cnorm.data)\n\n    imap = np.zeros(N_curr, dtype=int)\n    imap[inames] = np.arange(N_curr)\n\n    if top_to_bottom:\n        # stack from the top to bottom, like in create_cscape_image func.\n        bottom = np.ones(cnorm.x_size)\n    else:\n        bottom = np.zeros(cnorm.x_size)\n    curr_stack = np.copy(bottom)\n\n    for idx, curr in zip(cnorm.idxs, currs):\n        if not np.all(curr == 0):\n            color, hatch, _ = get_colors_hatches_lines_lists(c, imap[idx], cmap, mapper)\n\n            if top_to_bottom:\n                curr_stack = np.copy(bottom)\n                bottom -= curr\n            else:\n                curr_stack += curr\n\n            ax.fill_between(\n                cnorm.time,\n                curr_stack,\n                bottom,\n                color=color,\n                edgecolor=c[\"pattern\"][\"color\"],\n                lw=0.0,\n                hatch=hatch,\n                zorder=2,\n            )\n\n            if not top_to_bottom:\n                bottom = np.copy(curr_stack)", "\n\ndef black_line_log_scale(ax, ylim, xlim, bl_thickness):\n    \"\"\"Produce a black line meant to distinguish between 2 plots in log scales.\n\n    The black line is plotted at the bottom of the upper plot.\n    This is a trick to avoid frames masking some of the data.\n\n    Args:\n        ax (matplotlib.axes): currentscape axis\n        ylim (list of 2 floats): limits of the y axis\n        xlim (list of 2 floats): limits of the x axis\n        bl_thickness (float): thickness of the black line separating the two plots,\n            in percentage of the y axis size\n\n    Returns ylim, because the bottom y limit is changing by adding the black line.\n    \"\"\"\n    # should produce a black line with a thickness approaching\n    # the one in the currentscape (non log scale) black line\n    percent_to_log = abs(ylim[1] / ylim[0]) ** (bl_thickness / 64.0)\n    y_bottom = ylim[0] / (percent_to_log)\n\n    ax.fill_between(\n        xlim,\n        [y_bottom, y_bottom],\n        [ylim[0], ylim[0]],\n        color=\"black\",\n        lw=0,\n        zorder=3,\n    )\n    ylim[0] = y_bottom\n\n    return ylim", "\n\ndef remove_ticks_and_frame(ax):\n    \"\"\"Remove ticks (but not ytick label) and frame.\n\n    Args:\n        ax (matplotlib.axes): axis\n    \"\"\"\n    ax.tick_params(\n        axis=\"x\",  # changes apply to the x-axis\n        which=\"both\",  # both major and minor ticks are affected\n        bottom=False,  # ticks along the bottom edge are off\n        top=False,  # ticks along the top edge are off\n        labelbottom=False,  # labels along the bottom edge are off\n    )\n    ax.tick_params(\n        axis=\"y\",  # changes apply to the x-axis\n        which=\"both\",  # both major and minor ticks are affected\n        left=False,  # ticks along the left edge are off\n        right=False,  # ticks along the right edge are off\n        pad=0,\n    )\n    ax.spines[\"top\"].set_visible(False)\n    ax.spines[\"right\"].set_visible(False)\n    ax.spines[\"bottom\"].set_visible(False)\n    ax.spines[\"left\"].set_visible(False)", "\n\ndef remove_ticks_and_frame_for_bar_plot(ax):\n    \"\"\"Remove all ticks (including ytick label) and top & bottom frames.\n\n    Args:\n        ax (matplotlib.axes): axis\n    \"\"\"\n    ax.tick_params(\n        axis=\"x\",  # changes apply to the x-axis\n        which=\"both\",  # both major and minor ticks are affected\n        bottom=False,  # ticks along the bottom edge are off\n        top=False,  # ticks along the top edge are off\n        labelbottom=False,  # labels along the bottom edge are off\n    )\n    ax.tick_params(\n        axis=\"y\",  # changes apply to the x-axis\n        which=\"both\",  # both major and minor ticks are affected\n        left=False,  # ticks along the left edge are off\n        right=False,  # ticks along the right edge are off\n        labelleft=False,  # labels along left edge are off\n    )\n    ax.spines[\"top\"].set_visible(False)\n    ax.spines[\"bottom\"].set_visible(False)", "\n\ndef adjust(adjust_left, adjust_right, adjust_top, adjust_bottom):\n    \"\"\"Adjust Subplots.\n\n    Args:\n        adjust_left (float or None): position of the left edge of the subplots,\n            None to use matplotlib default\n        adjust_right (float or None): position of the right edge of the subplots,\n            None ot use matplotlib default\n        adjust_top (float or None): position of the top edge of the subplots,\n            None to use matplotlib default\n        adjust_bottom (float or None): position of the bottom edge of the subplots,\n            None to use matplotlib default\n    \"\"\"\n    plt.subplots_adjust(wspace=0, hspace=0)\n    if adjust_left is not None:\n        plt.subplots_adjust(left=adjust_left)\n    if adjust_right is not None:\n        plt.subplots_adjust(right=adjust_right)\n    if adjust_top is not None:\n        plt.subplots_adjust(top=adjust_top)\n    if adjust_bottom is not None:\n        plt.subplots_adjust(bottom=adjust_bottom)", "\n\ndef set_label(ax, x, y, label, textsize):\n    \"\"\"Set text as label on the y axis.\n\n    Args:\n        ax (matplotlib.axes): axis\n        x (float): x position of the label\n        y (float): y position of the label\n        label (str): text to be displayed as label\n        textsize (int): text size in pixels\n    \"\"\"\n    ax.text(\n        x,\n        y,\n        label,\n        horizontalalignment=\"right\",\n        verticalalignment=\"center\",\n        rotation=\"vertical\",\n        size=textsize,\n    )", "\n\ndef show_xgridlines(ax, c, xticks, ylim=None):\n    \"\"\"Show vertical gridlines corresponding to the x ticks.\n\n    Args:\n        ax (matplotlib.axes): axis\n        c (dict): config\n        xticks (list): tick positions on the x axis\n        ylim (list of 2 floats): limits of y axis\n    \"\"\"\n    lw = c[\"xaxis\"][\"gridline_width\"]\n    ls = c[\"xaxis\"][\"gridline_style\"]\n    color = c[\"xaxis\"][\"gridline_color\"]\n\n    # plot on top of everything else\n    ax.vlines(xticks, ylim[0], ylim[1], lw=lw, color=color, zorder=5, ls=ls)", "\n\ndef apply_labels_ticks_and_lims(\n    ax, c, xticks, xlim, ylim, positive=True, config_key=\"current\"\n):\n    \"\"\"Apply labels, ticks, xlim and ylim to current / ion concentration plots.\n\n    Args:\n        ax (matplotlib.axes): currentscape axis\n        c (dict): config\n        xticks (list): tick positions on the x axis\n        xlim (list of 2 floats): limits of x axis\n        ylim (list of 2 floats): limits of y axis (can be different from ylim from config)\n        positive (bool): True for positive data, False for negative data\n        config_key (str): key for getting data from config. Should be 'current' or 'ions'\n    \"\"\"\n    # plot the horizontal dotted lines\n    for tick in c[config_key][\"ticks\"]:\n        ax.axhline(tick, color=\"black\", ls=\":\", lw=1, zorder=1)\n\n    ax.set_yscale(\"log\")\n\n    # labels\n    if c[\"show\"][\"ylabels\"]:\n        if positive:\n            ax.set_ylabel(c[config_key][\"units\"], labelpad=c[\"labelpad\"])\n        else:\n            ax.set_ylabel(\"-\" + c[config_key][\"units\"], labelpad=c[\"labelpad\"])\n\n    # ticks\n    if c[\"show\"][\"yticklabels\"]:\n        ax.set_yticks(c[config_key][\"ticks\"])\n        ax.get_yaxis().set_major_formatter(matplotlib.ticker.FormatStrFormatter(\"%g\"))\n        ax.get_yaxis().set_minor_formatter(matplotlib.ticker.NullFormatter())\n    remove_ticks_and_frame(ax)\n\n    # show x axis gridline\n    if c[\"show\"][\"xgridlines\"]:\n        show_xgridlines(ax, c, xticks, ylim)\n\n    # somehow, set_ylim is not taken into account if it is set before set_yticks\n    ax.set_xlim(xlim)\n    if positive:\n        ax.set_ylim(ylim[0], ylim[1])\n    else:\n        ax.set_ylim(ylim[1], ylim[0])", "\n\ndef plot_x_labels(ax, c, xticks):\n    \"\"\"Plot x labels and x ticklabels.\n\n    Args:\n        ax (matplotlib.axes): axis\n        c (dict): config\n        xticks (list): tick positions on the x axis\n    \"\"\"\n    if c[\"show\"][\"xlabels\"]:\n        ax.set_xlabel(c[\"xaxis\"][\"units\"], labelpad=c[\"labelpad\"])\n\n    if c[\"show\"][\"xticklabels\"]:\n        # enable label bottom\n        ax.tick_params(\n            axis=\"x\",  # changes apply to the x-axis\n            which=\"both\",  # both major and minor ticks are affected\n            pad=0,\n            labelbottom=True,\n        )\n        ax.set_xticks(xticks)\n        ax.get_xaxis().set_major_formatter(matplotlib.ticker.FormatStrFormatter(\"%g\"))", "\n\ndef select_color(cmap, i, N_col):\n    \"\"\"Select color of the ith element when not using patterns.\n\n    There is a +2 in the formula to account for the black and white in colormap.\n\n    Args:\n        cmap (matplotlib.colors.Colormap): colormap\n        i (int): index of element (current/ion)\n        N_col (int): total number of elements\n    \"\"\"\n    return cmap(i / float(N_col + 2))", "\n\ndef get_colors(cmap, n_col):\n    \"\"\"Get colors from colormap, depending on maximum number of colors.\n\n    Args:\n        cmap (str): colormap name\n        n_col (int): number of colors to extract\n    Returns:\n        a list of matplotlib colors\n        launch_warning (bool): True to warn that colormap lacks colors\n    \"\"\"\n    # is from palettable module\n    if \".\" in cmap:\n        x = pltb\n        # we want to retrieve e.g. pltb.cartocolors.qualitative.Antique_8.mpl_colors\n        # from string \"cartocolors.qualitative.Antique_8\"\n        for attr in cmap.split(\".\"):\n            x = getattr(x, attr)\n\n        # if colormap lacks colors\n        if len(x.mpl_colors) < n_col:\n            return (\n                list(x.mpl_colormap(np.array(range(n_col)) / float(n_col))),\n                True,\n            )\n\n        return x.mpl_colors[:n_col], False\n\n    # is from matplotlib\n    new_cmap = matplotlib.cm.get_cmap(cmap, n_col)\n    # check number of colors\n    if matplotlib.cm.get_cmap(cmap).N < n_col:\n        return list(new_cmap(range(n_col))), True\n\n    return list(new_cmap(range(n_col))), False", "\n\ndef get_colormap(cmap, n_colors, use_patterns, N_curr, N_ion):\n    \"\"\"Get colormap according to input, and add black then white colors at the end.\n\n    The black color is used to create a black line separating currentscapes plots,\n    and the white color is used when there is no data (e.g. no inward or outward current).\n\n    Args:\n        cmap (str): colormap name\n        n_colors (int): number of colors to extract IF use_patterns and n_colors>N_curr\n        use_patterns (bool): True if currentscape plot uses bars and mixes color and pattern\n        N_curr (int): number of currents\n        N_ion (int): number of ion concentrations\n    \"\"\"\n    # choose the right number of colors for the colormap\n    if N_ion is not None and N_ion > N_curr:\n        N_max = N_ion\n    else:\n        N_max = N_curr\n\n    if use_patterns and N_max > n_colors:\n        N_colormap = n_colors\n    else:\n        N_colormap = N_max\n\n    # get colors from colormap\n    colors, launch_warning = get_colors(cmap, N_colormap)\n\n    # append black, for black line separating currentscapes\n    colors.append(np.array([0.0, 0.0, 0.0, 1.0]))\n    # append white. default color when there is no current.\n    colors.append(np.array([1.0, 1.0, 1.0, 1.0]))\n\n    # display warning if the colormap lacks colors\n    if launch_warning:\n        if use_patterns:\n            logger.warning(\n                \"'n_colors' in 'colormap' in config is larger than \"\n                \"the number of colors in the colormap. \"\n                \"Please, choose a colormap with more colors \"\n                \"or decrease n_colors for optimal display.\"\n            )\n        else:\n            logger.warning(\n                \"The number of colors in the colormap \"\n                \"is smaller than the number of currents. \"\n                \"Please, choose a colormap with more colors \"\n                \"or use patterns for optimal display.\"\n            )\n\n    return matplotlib.colors.ListedColormap(colors)", "\n\ndef save_figure(fig, c):\n    \"\"\"Save figure in output according to config file.\n\n    Args:\n        fig (matplotlib.figure.Figure): figure\n        c (dict): config\n    \"\"\"\n    Path(c[\"output\"][\"dir\"]).mkdir(parents=True, exist_ok=True)\n    out_path = (\n        f\"{Path(c['output']['dir']) / c['output']['fname']}.{c['output']['extension']}\"\n    )\n\n    fig.savefig(\n        out_path, dpi=c[\"output\"][\"dpi\"], transparent=c[\"output\"][\"transparent\"]\n    )", ""]}
{"filename": "currentscape/__init__.py", "chunked_list": ["\"\"\"Currentscape.\"\"\"\n\n# Copyright 2023 Blue Brain Project / EPFL\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n", "#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom currentscape.currentscape import plot_currentscape as plot\n", "from currentscape.currentscape import plot_currentscape as plot\n"]}
{"filename": "currentscape/legends.py", "chunked_list": ["\"\"\"Legends related functions.\"\"\"\n\n# Copyright 2023 Blue Brain Project / EPFL\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n", "#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# pylint: disable=wrong-import-position\n", "# pylint: disable=wrong-import-position\n\nimport matplotlib\n\nmatplotlib.use(\"agg\")  # to avoid tkinter error\nfrom matplotlib.legend_handler import HandlerTuple\n\nfrom currentscape.mapper import map_colors\nfrom currentscape.plotting import get_colors_hatches_lines_lists, select_color\n", "from currentscape.plotting import get_colors_hatches_lines_lists, select_color\n\n\ndef base_legend(\n    ax, curr_names, bg_color, ypos, idx_names=None, handlelength=None, lines=False\n):\n    \"\"\"Returns a legend with all current names.\n\n    Args:\n        ax (matplotlib.axes): currentscape axis\n        curr_names (list of str): legend labels / current names\n        bg_color (color): background color for legend box\n        ypos (float): y-axis position of legend box. 1 is top of axis.\n        idx_names (ndarray of ints): indexes to new name order (new_names = names[idx_names])\n        handlelength (float): size of the handles.\n            Takes default value if None. No handles displayed if 0.\n        lines (bool): if True, get lines as handles. if False, get patches as handles.\n    \"\"\"\n    if idx_names is None:\n        idx_names = range(len(curr_names))\n    # create a patch (proxy artist) or a line for every current\n    if lines:\n        handles = [\n            matplotlib.lines.Line2D([], [], label=curr_names[i]) for i in idx_names\n        ]\n    else:\n        handles = [matplotlib.patches.Patch(label=curr_names[i]) for i in idx_names]\n    # put those patched as legend-handles into the legend\n    leg = ax.legend(\n        handles=handles,\n        bbox_to_anchor=(1.01, ypos),\n        loc=2,\n        borderaxespad=0.0,\n        facecolor=bg_color,\n        edgecolor=\"black\",\n        fancybox=False,  # disable round edges\n        handlelength=handlelength,\n    )\n    leg.get_frame().set_linewidth(0.5)  # set border thickness\n\n    return leg", "\n\ndef set_legend(ax, cmap, curr_names, bg_color, ypos, idx_names=None, handlelength=0):\n    \"\"\"Set each current name color-coded in legend.\n\n    Args:\n        ax (matplotlib.axes): currentscape axis\n        cmap (matplotlib.colors.Colormap): colormap\n        curr_names (list of str): legend labels / current names\n        bg_color (color): background color for legend box\n        ypos (float): y-axis position of legend box. 1 is top of axis.\n        idx_names (ndarray of ints): indexes to new name order (new_names = names[idx_names])\n        handlelength (float): size of the handles.\n            Takes default value if None. No handles displayed if 0.\n    \"\"\"\n    leg = base_legend(ax, curr_names, bg_color, ypos, idx_names, handlelength)\n\n    # set legend label color & boldness\n    for i_color, text in enumerate(leg.texts):\n        # + 2 because there is black and white at the end of cmap\n        text.set_color(select_color(cmap, i_color, len(curr_names)))\n        text.set_weight(\"bold\")", "\n\ndef set_legend_with_hatches(ax, cmap, mapper, c, idx_names):\n    \"\"\"Create legend and color each current name, and set handles color and pattern.\n\n    Args:\n        ax (matplotlib.axes): currentscape axis\n        cmap (matplotlib.colors.Colormap): colormap\n        mapper (int): number used to mix color and patterns\n        c (dict): config\n        idx_names (ndarray of ints): indexes to new name order (new_names = names[idx_names])\n    \"\"\"\n    curr_names = c[\"current\"][\"names\"]\n    bg_color = c[\"legend\"][\"bgcolor\"]\n    ypos = c[\"legend\"][\"ypos\"]\n\n    leg = base_legend(ax, curr_names, bg_color, ypos, idx_names)\n\n    # set legend label color & boldness, and handles color&pattern\n    for i_color, (text, handle) in enumerate(zip(leg.texts, leg.legendHandles)):\n        color, hatch, _ = get_colors_hatches_lines_lists(c, i_color, cmap, mapper)\n        text.set_color(color)\n        text.set_weight(\"bold\")\n\n        handle.set_facecolor(color)\n        handle.set_hatch(hatch)", "\n\ndef set_legend_with_lines(ax, cmap, mapper, c, idx_names, names):\n    \"\"\"Create legend and color each current name, and set handles color and pattern.\n\n    Args:\n        ax (matplotlib.axes): currentscape axis\n        cmap (matplotlib.colors.Colormap): colormap\n        mapper (int): number used to mix color and patterns\n        c (dict): config\n        idx_names (ndarray of ints): indexes to new name order (new_names = names[idx_names])\n        names (list of str): legend labels\n    \"\"\"\n    bg_color = c[\"legend\"][\"bgcolor\"]\n    ypos = c[\"legend\"][\"ypos\"]\n\n    leg = base_legend(ax, names, bg_color, ypos, idx_names, lines=True)\n\n    # set legend label color & boldness, and handles color&pattern\n    lw = c[\"lw\"]\n    for i_color, (text, handle) in enumerate(zip(leg.texts, leg.legendHandles)):\n        color, _, line = get_colors_hatches_lines_lists(c, i_color, cmap, mapper)\n        text.set_color(color)\n        text.set_weight(\"bold\")\n\n        handle.set_color(color)\n        handle.set_linestyle(line)\n        handle.set_linewidth(lw)", "\n\ndef get_handles_with_hatches_and_linestyles(c, cmap, mapper, N_curr):\n    \"\"\"Return handles as a list of tuples (patch, line).\n\n    With patch showing color and hatch and line showing the linestyle.\n\n    Args:\n        c (dict): config\n        cmap (matplotlib.colors.Colormap): colormap\n        mapper (int): number used to mix color and patterns\n        N_curr (int): number of currents\n    \"\"\"\n    lw = c[\"lw\"]\n\n    # create a patch (proxy artist) for every current\n    handles = []\n    for i in range(N_curr):\n        color, hatch, line = get_colors_hatches_lines_lists(c, i, cmap, mapper)\n        handles.append(\n            (\n                matplotlib.patches.Patch(facecolor=color, hatch=hatch),\n                matplotlib.lines.Line2D([], [], color=color, ls=line, lw=lw),\n            )\n        )\n\n    return handles", "\n\ndef set_legend_with_hatches_and_linestyles(ax, cmap, mapper, c, idx_names):\n    \"\"\"Create legend and color each current name, and set handles color and pattern.\n\n    Args:\n        ax (matplotlib.axes): currentscape axis\n        cmap (matplotlib.colors.Colormap): colormap\n        mapper (int): number used to mix color and patterns\n        c (dict): config\n        idx_names (ndarray of ints): indexes to new name order (new_names = names[idx_names])\n    \"\"\"\n    bg_color = c[\"legend\"][\"bgcolor\"]\n    ypos = c[\"legend\"][\"ypos\"]\n\n    curr_names = c[\"current\"][\"names\"]\n    n_col = c[\"colormap\"][\"n_colors\"]\n    handlelength = c[\"legend\"][\"handlelength\"]\n\n    handles = get_handles_with_hatches_and_linestyles(c, cmap, mapper, len(idx_names))\n\n    # put those patched as legend-handles into the legend\n    leg = ax.legend(\n        handles=handles,\n        labels=[curr_names[i] for i in idx_names],\n        bbox_to_anchor=(1.01, ypos),\n        loc=2,\n        borderaxespad=0.0,\n        facecolor=bg_color,\n        edgecolor=\"black\",\n        fancybox=False,  # disable round edges\n        handler_map={tuple: HandlerTuple(ndivide=None, pad=0.2)},\n        handlelength=2 * handlelength,\n    )\n    leg.get_frame().set_linewidth(0.5)  # set border thickness\n\n    # set legend label color & boldness, and handles color&pattern\n    for i_color, text in enumerate(leg.texts):\n        text.set_color(cmap(map_colors(i_color, n_col, mapper)))\n        text.set_weight(\"bold\")", ""]}
{"filename": "currentscape/config_parser.py", "chunked_list": ["\"\"\"Config-related functions.\"\"\"\n\n# Copyright 2023 Blue Brain Project / EPFL\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n", "#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# pylint: disable=too-many-statements, too-many-locals\nimport logging", "# pylint: disable=too-many-statements, too-many-locals\nimport logging\n\nimport json\n\nlogger = logging.getLogger(__name__)\n\n\ndef check_config(c):\n    \"\"\"Output a warning if something is wrong with the config.\n\n    Args:\n        c (dict): config\n    \"\"\"\n    if (\n        c[\"pattern\"][\"use\"]\n        and c[\"show\"][\"all_currents\"]\n        and len(c[\"line\"][\"styles\"]) != len(c[\"pattern\"][\"patterns\"])\n    ):\n        logger.warning(\"line:styles should have as many items as pattern:patterns.\")", "def check_config(c):\n    \"\"\"Output a warning if something is wrong with the config.\n\n    Args:\n        c (dict): config\n    \"\"\"\n    if (\n        c[\"pattern\"][\"use\"]\n        and c[\"show\"][\"all_currents\"]\n        and len(c[\"line\"][\"styles\"]) != len(c[\"pattern\"][\"patterns\"])\n    ):\n        logger.warning(\"line:styles should have as many items as pattern:patterns.\")", "\n\ndef replace_defaults(config, new_config):\n    \"\"\"Recursive fct. Replace defaults value with user input.\n\n    Args:\n        config (dict): default config\n        new_config (dict): dict containing config items to be updated\n    \"\"\"\n    for key, item in new_config.items():\n        if isinstance(item, dict):\n            item = replace_defaults(config[key], item)\n        config[key] = item\n\n    return config", "\n\ndef set_default_config(c):\n    \"\"\"Set non-specified values in config to default.\n\n    Args:\n        c (str or dict): config dict or path to json config.\n            values from c are added or replace those from default config.\n    \"\"\"\n    if c is None:\n        c = {}\n    elif isinstance(c, str):\n        with open(c, \"r\", encoding=\"utf-8\") as f:\n            c = json.load(f)\n\n    config = {}\n    show = {}\n    show[\"currentscape\"] = True\n    show[\"ylabels\"] = True\n    show[\"yticklabels\"] = True\n    show[\"xlabels\"] = False\n    show[\"xticklabels\"] = False\n    show[\"xgridlines\"] = False\n    show[\"legend\"] = True\n    show[\"all_currents\"] = False\n    show[\"total_contribution\"] = False\n    config[\"show\"] = show\n\n    current = {}\n    # if True, reorder currents with decreasing order of %.\n    current[\"reorder\"] = True\n    # if True, do not take into account ticks and ylim below.\n    current[\"autoscale_ticks_and_ylim\"] = True\n    # only taken into account if autoscale_ticks_and_ylim is False\n    current[\"ticks\"] = [5, 50, 500]\n    # only taken into account if autoscale_ticks_and_ylim is False\n    current[\"ylim\"] = (0.01, 1500)\n    current[\"units\"] = \"[pA]\"\n    # color for summed currents.\n    current[\"color\"] = \"black\"\n    # True to plot absolute currents with stackplots, False to plot them with lines\n    current[\"stackplot\"] = False\n    current[\"names\"] = None\n    # thickness of black line\n    # separating the two inward & outward currentscapes / current stackplot.\n    # in %age of y size of plot.\n    current[\"black_line_thickness\"] = 2\n    current[\"legacy_method\"] = False\n    config[\"current\"] = current\n\n    currentscape = {}\n    currentscape[\"in_label\"] = \"inward %\"\n    currentscape[\"out_label\"] = \"outward %\"\n    # Used with imshow.\n    # if too low, white pixels can appear at the bottom of currentscape plots\n    # because of rounding errors.\n    currentscape[\"y_resolution\"] = 10000\n    currentscape[\"legacy_method\"] = False\n    config[\"currentscape\"] = currentscape\n\n    ions = {}\n    ions[\"autoscale_ticks_and_ylim\"] = True\n    ions[\"ticks\"] = [0.0005, 0.05, 5]\n    ions[\"ylim\"] = (0.00001, 100)\n    ions[\"units\"] = \"[mM]\"\n    ions[\"reorder\"] = True\n    ions[\"names\"] = None\n    config[\"ions\"] = ions\n\n    colormap = {}\n    colormap[\"name\"] = \"Set1\"\n    # color number. Taken into account only if pattern use is True\n    colormap[\"n_colors\"] = 8\n    config[\"colormap\"] = colormap\n\n    # data along x axis are summed up into chunks when pattern use is True. Put to 1 to disable.\n    config[\"stackplot\"] = {\"x_chunksize\": 50}\n\n    pattern = {}\n    pattern[\"use\"] = False\n    pattern[\"patterns\"] = [\"\", \"/\", \"\\\\\", \"x\", \".\", \"o\", \"+\"]\n    pattern[\"density\"] = 5\n    pattern[\"linewidth\"] = 0.2\n    # since the pattern color is defined by the edgecolor,\n    # this parameter also changes the edgecolor of the pie charts\n    pattern[\"color\"] = \"black\"\n    config[\"pattern\"] = pattern\n\n    # is used when pattern:use and show:all_currents are True and current:stackplot is False\n    # Should have the same length as pattern:patterns\n    line = {\n        \"styles\": [\n            \"solid\",\n            (0, (1, 1)),\n            (0, (2, 1)),\n            (0, (2, 1, 1, 1)),\n            (0, (2, 1, 1, 1, 1, 1)),\n            (0, (2, 1, 2, 1, 1, 1)),\n            (0, (2, 1, 2, 1, 1, 1, 1, 1)),\n        ]\n    }\n    config[\"line\"] = line\n\n    voltage = {}\n    voltage[\"ticks\"] = (-50, -20)\n    voltage[\"ylim\"] = (-90, 30)\n    voltage[\"units\"] = \"[mV]\"\n    voltage[\"color\"] = \"black\"\n    voltage[\"horizontal_lines\"] = True\n    config[\"voltage\"] = voltage\n\n    xaxis = {}\n    xaxis[\"units\"] = \"[ms]\"\n    # if None, xticks are generated automatically. Can put a list of xticks to force custom xticks.\n    xaxis[\"xticks\"] = None\n    xaxis[\"gridline_width\"] = 1\n    xaxis[\"gridline_color\"] = \"black\"\n    xaxis[\"gridline_style\"] = \"--\"\n    config[\"xaxis\"] = xaxis\n\n    output = {}\n    output[\"savefig\"] = False\n    output[\"dir\"] = \".\"\n    output[\"fname\"] = \"fig\"\n    output[\"extension\"] = \"pdf\"\n    output[\"dpi\"] = 400\n    output[\"transparent\"] = False\n    config[\"output\"] = output\n\n    legend = {}\n    legend[\"textsize\"] = 4\n    legend[\"bgcolor\"] = \"lightgrey\"\n    # 1. : top of legend is at the same level as top of currentscape plot.\n    # higher value put legend higher in figure.\n    legend[\"ypos\"] = 1.0\n    # forced to 0 if pattern:use is False and current:stackplot is False\n    legend[\"handlelength\"] = 1.4\n    config[\"legend\"] = legend\n\n    adjust_ = {}\n    adjust_[\"left\"] = 0.15\n    adjust_[\"right\"] = 0.85\n    adjust_[\"top\"] = 0.95\n    adjust_[\"bottom\"] = 0.0\n    config[\"adjust\"] = adjust_\n\n    config[\"title\"] = None\n    config[\"figsize\"] = (3, 4)\n    config[\"labelpad\"] = 1\n    config[\"textsize\"] = 6\n    config[\"titlesize\"] = 12\n    config[\"lw\"] = 0.5\n\n    new_config = replace_defaults(config, c)\n\n    # for compatibility with older versions\n    if \"cmap\" in new_config[\"currentscape\"]:\n        new_config[\"colormap\"][\"name\"] = new_config[\"currentscape\"][\"cmap\"]\n    if \"legendtextsize\" in new_config:\n        new_config[\"legend\"][\"textsize\"] = new_config[\"legendtextsize\"]\n    if \"legendbgcolor\" in config:\n        new_config[\"legend\"][\"bgcolor\"] = new_config[\"legendbgcolor\"]\n    if \"x_chunksize\" in new_config[\"currentscape\"]:\n        new_config[\"stackplot\"][\"x_chunksize\"] = new_config[\"currentscape\"][\n            \"x_chunksize\"\n        ]\n    if \"black_line_thickness\" in new_config[\"currentscape\"]:\n        new_config[\"current\"][\"black_line_thickness\"] = new_config[\"currentscape\"][\n            \"black_line_thickness\"\n        ]\n    if \"labels\" in new_config[\"show\"]:\n        new_config[\"show\"][\"ylabels\"] = new_config[\"show\"][\"labels\"]\n    if \"ticklabels\" in new_config[\"show\"]:\n        new_config[\"show\"][\"yticklabels\"] = new_config[\"show\"][\"ticklabels\"]\n\n    check_config(new_config)\n\n    return new_config", ""]}
{"filename": "currentscape/ions.py", "chunked_list": ["\"\"\"Ion concentrations class.\"\"\"\n\n# Copyright 2023 Blue Brain Project / EPFL\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n", "#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# pylint: disable=wrong-import-position, super-with-arguments\nimport numpy as np", "# pylint: disable=wrong-import-position, super-with-arguments\nimport numpy as np\nimport matplotlib\n\nmatplotlib.use(\"agg\")  # to avoid tkinter error\nimport matplotlib.pyplot as plt\n\nfrom currentscape.datasets import DataSet\nfrom currentscape.data_processing import reorder\nfrom currentscape.plotting import (", "from currentscape.data_processing import reorder\nfrom currentscape.plotting import (\n    get_colors_hatches_lines_lists,\n    apply_labels_ticks_and_lims,\n    select_color,\n)\nfrom currentscape.legends import (\n    set_legend,\n    set_legend_with_lines,\n)", "    set_legend_with_lines,\n)\nfrom currentscape.mapper import create_mapper\n\n\nclass IonConcentrations(DataSet):\n    \"\"\"Class containing ion concentrations data.\"\"\"\n\n    def __init__(self, data, c, time=None):\n        \"\"\"Constructor.\n\n        Args:\n            data (list of lists): data\n                all lists are expected to have the same size.\n            c (dict): config\n            time (list): time of the data\n\n        Attributes:\n            mapper (int): number used to mix colors and patterns / linestyles\n        \"\"\"\n        reorder_ = c[\"ions\"][\"reorder\"]\n        use_patterns = c[\"pattern\"][\"use\"]\n        n_patterns = len(c[\"pattern\"][\"patterns\"])\n\n        super(IonConcentrations, self).__init__(\n            data=data, names=c[\"ions\"][\"names\"], time=time, xticks=c[\"xaxis\"][\"xticks\"]\n        )\n\n        self.mapper = None\n\n        if self.data is not None:\n            if reorder_:\n                _, self.idxs = reorder(self.data)\n\n            if use_patterns:\n                n_colors = min([c[\"colormap\"][\"n_colors\"], self.N])\n                self.mapper = create_mapper(n_colors, n_patterns)\n\n    def plot_with_linestyles(self, c, row, rows_tot, cmap):\n        \"\"\"Plot all the ion concentration with linestyles.\n\n        Args:\n            c (dict): config\n            row (int): row of subplot\n            rows_tot (int): total number of subplots in the figure\n            cmap (matplotlib.colors.Colormap): colormap\n        \"\"\"\n        lw = c[\"lw\"]\n\n        ylim = list(c[\"ions\"][\"ylim\"])\n\n        ax = plt.subplot2grid((rows_tot, 1), (row, 0), rowspan=1)\n\n        x = np.arange(self.x_size)\n\n        # here, use currs.idxs to have the same colors as in currs.names\n        # can do it because selected_currs have same shape as self (no zero arrays removed)\n        for i, ion in enumerate(self.data[self.idxs]):\n            if not np.all(ion == 0):\n                color, _, linestyle = get_colors_hatches_lines_lists(\n                    c, i, cmap, self.mapper\n                )\n                ax.plot(x, ion, color=color, ls=linestyle, lw=lw, zorder=2)\n\n        # legend\n        # place legend here so that legend top is at the level of share plot top\n        if c[\"show\"][\"legend\"]:\n            set_legend_with_lines(\n                ax, cmap, self.mapper, c, self.idxs, c[\"ions\"][\"names\"]\n            )\n\n        apply_labels_ticks_and_lims(\n            ax,\n            c,\n            self.xticks,\n            [self.time[0], self.time[-1]],\n            ylim,\n            True,\n            \"ions\",\n        )\n\n    def plot(self, c, row, rows_tot, cmap):\n        \"\"\"Plot positive (or negative) ionic concentration.\n\n        Args:\n            c (dict): config\n            row (int): row of subplot\n            rows_tot (int): total number of subplots in the figure\n            cmap (matplotlib.colors.Colormap): colormap\n        \"\"\"\n        ax = plt.subplot2grid((rows_tot, 1), (row, 0), rowspan=1)\n\n        # plot ion concentrations with lines.\n        for i, ion in enumerate(self.data[self.idxs]):\n            if not np.all(ion == 0):\n                color = select_color(cmap, i, self.N)\n\n                ax.plot(\n                    self.time,\n                    ion,\n                    color=color,\n                    ls=\"solid\",\n                    lw=c[\"lw\"],\n                    zorder=2,\n                )\n\n        # legend\n        # place legend here so that legend top is at the level of share plot top\n        if c[\"show\"][\"legend\"]:\n            set_legend(\n                ax,\n                cmap,\n                c[\"ions\"][\"names\"],\n                c[\"legend\"][\"bgcolor\"],\n                c[\"legend\"][\"ypos\"],\n                self.idxs,\n            )\n\n        apply_labels_ticks_and_lims(\n            ax,\n            c,\n            self.xticks,\n            [self.time[0], self.time[-1]],\n            list(c[\"ions\"][\"ylim\"]),\n            True,\n            \"ions\",\n        )", ""]}
{"filename": "currentscape/datasets.py", "chunked_list": ["\"\"\"Base class Dataset.\"\"\"\n\n# Copyright 2023 Blue Brain Project / EPFL\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n", "#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport numpy as np\n", "import numpy as np\n\nfrom currentscape.data_processing import round_down_sig_digit, order_of_mag\n\n\nclass DataSet:\n    \"\"\"Base class containing data and data-handling methods.\"\"\"\n\n    def __init__(self, data, names=None, time=None, xticks=None):\n        \"\"\"Constructor.\n\n        Args:\n            data (list of lists): data\n                all lists are expected to have the same size.\n            names (list of str): names corresponding to the data,\n                in the same order\n            time (list): time of the data\n            xticks (list): ticks on the x axis. Determined automatically if None.\n\n        Attributes:\n            data (ndarray of ndarray): data\n            names (ndarray of str): names corresponding to the data,\n                in the same order\n            time (ndarray): time of the data\n            N (int): size of data\n            x_size (int): size of one element of data\n            idxs (ndarray of ints): arr containing indexes after a reordering\n                s.t. reordered_data = self.data[self.idxs]\n            xticks (ndarray): ticks on the x axis. Determined automatically if None.\n        \"\"\"\n        self.data = None\n        self.N = None\n        self.x_size = None\n        self.idxs = None\n\n        self.names = None\n\n        self.time = None\n        self.xticks = None\n\n        if data is not None:\n            self.data = np.asarray(data)\n\n            self.N = len(self.data)\n            self.idxs = range(self.N)\n\n            if self.N > 0:\n                self.x_size = len(self.data[0])\n            else:\n                self.x_size = 0\n\n        if names is not None:\n            self.names = np.asarray(names)\n\n        if time is not None:\n            self.time = np.asarray(time)\n        elif self.x_size:\n            self.time = np.arange(self.x_size)\n\n        if xticks is not None:\n            self.xticks = np.asarray(xticks)\n        elif self.time is not None:\n            self.xticks = self.set_xticks()\n\n    def get_negative_data(self):\n        \"\"\"Returns a copy of data keeping only negative ones.\"\"\"\n        selected_currs = self.data.copy()\n        selected_currs[self.data > 0] = 0\n\n        return selected_currs\n\n    def get_positive_data(self):\n        \"\"\"Returns a copy of data keeping only positive ones.\"\"\"\n        selected_currs = self.data.copy()\n        selected_currs[self.data < 0] = 0\n\n        return selected_currs\n\n    def set_xticks(self):\n        \"\"\"Generate x ticks values depending on time.\"\"\"\n        if self.time is None or len(self.time) == 0:\n            return None\n        # a diff == 0 would make this function crash.\n        # Returning the only xticks making any sense in that case.\n        elif len(self.time) == 1:\n            return self.time.copy()\n\n        tmin = self.time[0]\n        tmax = self.time[-1]\n        diff = tmax - tmin\n\n        # order of magnitude\n        mag_order = order_of_mag(diff)\n        sig = round_down_sig_digit(diff, mag_order)\n\n        if sig / mag_order >= 5:\n            step = mag_order\n        elif sig / mag_order >= 2:\n            step = mag_order / 2.0\n        else:\n            step = mag_order / 4.0\n\n        if tmin == 0:\n            start = 0\n        # xticks can begin before tmin. this is corrected afterwards\n        else:\n            start = round_down_sig_digit(tmin, mag_order)\n\n        # if last step end up on tmax when the list to be returned is created\n        # make 'stop' higher than tmax to include tmax in returned value.\n        if (tmax - start) % step == 0:\n            stop = tmax + step / 2.0\n        else:\n            stop = tmax\n\n        xticks = np.arange(start, stop, step)\n\n        # remove values lower than the 1st time.\n        xticks = [x for x in xticks if x >= tmin]\n\n        return np.array(xticks)\n\n    def xticks_for_imshow(self):\n        \"\"\"Return xticks when the xaxis goes from 0 to x_size.\"\"\"\n        if self.xticks is None or self.time is None or self.x_size is None:\n            return None\n        elif len(self.time) == 1:\n            return self.time\n\n        tmin = self.time[0]\n        tmax = self.time[-1]\n        diff = tmax - tmin\n\n        return (self.xticks - tmin) / diff * self.x_size", ""]}
{"filename": "currentscape/data_processing.py", "chunked_list": ["\"\"\"Functions processing data.\"\"\"\n\n# Copyright 2023 Blue Brain Project / EPFL\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n", "#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# pylint: disable=too-many-statements\nimport logging", "# pylint: disable=too-many-statements\nimport logging\nfrom math import floor, log10\n\nimport numpy as np\n\nlogger = logging.getLogger(__name__)\n\n\ndef chunksize_warning(cs, len_curr, new_cs):\n    \"\"\"Warns that chunksize has been re-set.\n\n    Args:\n        cs (int): chunksize of data\n        len_curr (int): data size (length of one current list)\n        new_cs (int): new chunksize to be used\n    \"\"\"\n    logger.warning(\n        \"x-chunksize (%d) should be a divisor of data size (%d).\"\n        \" x-chunksize has been reset to %d.\",\n        cs,\n        len_curr,\n        new_cs,\n    )", "\ndef chunksize_warning(cs, len_curr, new_cs):\n    \"\"\"Warns that chunksize has been re-set.\n\n    Args:\n        cs (int): chunksize of data\n        len_curr (int): data size (length of one current list)\n        new_cs (int): new chunksize to be used\n    \"\"\"\n    logger.warning(\n        \"x-chunksize (%d) should be a divisor of data size (%d).\"\n        \" x-chunksize has been reset to %d.\",\n        cs,\n        len_curr,\n        new_cs,\n    )", "\n\ndef check_chunksize(cs, len_curr):\n    \"\"\"Set chunksize to a divisor of the data size if not the case.\n\n    Args:\n        cs (int): chunksize of data to check\n        len_curr (int): data size (length of one current list)\n    \"\"\"\n    if cs > len_curr:\n        chunksize_warning(cs, len_curr, len_curr)\n        return len_curr\n    elif cs < 1:\n        chunksize_warning(cs, len_curr, 1)\n        return 1\n\n    # if chunksize is a divisor: end of loop.\n    # else: decrement chunksize by one and retest until a divisor is found.\n    i = 0\n    len_curr = float(len_curr)\n    while len_curr // (cs - i) != len_curr / (cs - i):\n        i += 1\n\n    if i != 0:\n        chunksize_warning(cs, len_curr, cs - i)\n    return cs - i", "\n\ndef sum_chunks(x, chunk_size):\n    \"\"\"Compute the sums of parts of an array, then divide values by chunk size.\n\n    Taken from https://stackoverflow.com/questions/18582544/sum-parts-of-numpy-array.\n\n    Args:\n        x (ndarray): data to sum into chunks\n        chunk_size (int): chunk size of the data to be output\n    \"\"\"\n    chunk_size = check_chunksize(int(chunk_size), len(x[0]))\n\n    rows, cols = x.shape\n    x = x.reshape(int(x.size / chunk_size), chunk_size)\n    x = x.sum(axis=1).reshape(rows, int(cols / chunk_size))\n    return x / chunk_size", "\n\ndef remove_zero_arrays(arr, idx=None):\n    \"\"\"Removes all arrays made only of zeros.\n\n    Returns new array and indexes to previous array indexes.\n\n    Args:\n        arr (ndarray of ndarrays): array\n        idx (ndarray): indices of the array\n    \"\"\"\n    if idx is None:\n        idx = np.arange(len(arr))\n\n    # do not take nan values into account\n    arr_tmp = arr[:, ~np.isnan(arr).any(axis=0)]\n    selection = ~np.all(arr_tmp == 0, axis=1)\n\n    return arr[selection], idx[selection]", "\n\ndef reordered_idx(arr):\n    \"\"\"Returns indexes of sorted currents %age from smaller to larger absolute summed values.\n\n    Args:\n        arr (ndarray of ndarrays): array\n    \"\"\"\n    # do not take nan values into account\n    arr = arr[:, ~np.isnan(arr).any(axis=0)]\n    return np.argsort(np.sum(np.abs(arr), axis=1))", "\n\ndef reorder(arr):\n    \"\"\"Remove zeros, reorder data and also return data's original indexes.\n\n    Args:\n        arr (ndarray of ndarrays): array\n    \"\"\"\n    arr, idx = remove_zero_arrays(arr)\n    new_i = reordered_idx(arr)[::-1]  # reorder from larger to smaller\n    arr = arr[new_i]\n    idx = idx[new_i]\n\n    return arr, idx", "\n\ndef order_of_mag(n):\n    \"\"\"Get order of magnitude of a (absolute value of a) number.\n\n    e.g. for 1234 -> 1000, or 0.0456 -> 0.01\n\n    Args:\n        n (float or int): number\n    \"\"\"\n    return pow(10, floor(log10(abs(n))))", "\n\ndef round_down_sig_digit(n, mag_order=None):\n    \"\"\"Round down to a given number (default: 1) of significant digit.\n\n    e.g. 0.0456 -> 0.04, 723 -> 700\n\n    Args:\n        n (float or int): number to be rounded down\n        mag_order (float or int): 10 to the power of the desired order of magnitude\n            (e.g. 1000 to round the thousands)\n            if None: n is rounded to 1 sig digit\n    \"\"\"\n    if mag_order is None:\n        mag_order = order_of_mag(n)\n\n    # when dealing with floats, floating point errors can happen (e.g. 0.5 // 0.1 -> 0.4)\n    # this can happen when n is already its own sig (sig = rounded down one significant digit nmb)\n    # (if it's bigger, usually n - sig is bigger than (float(n) - true n value) error\n    # so the error does not influence the result of n // mag_order when n != sig(n))\n    # -> if (dealing with floats) and (n == sig(n)), then return n\n    if mag_order < 1 and len(str(abs(n))) == len(str(mag_order)):\n        return n\n\n    return float(mag_order * (n // mag_order))", "\n\ndef autoscale_ticks_and_ylim(c, pos, neg, config_key=\"current\"):\n    \"\"\"Autoscale ticks and ylim and put the result in config.\n\n    No need to return config, since dict are mutable in python.\n\n    Args:\n        c (dict): config\n        pos (ndarray or float): positive values or max of positive values\n        neg (ndarray or float): absolute values of negative values or\n            absolute value of minimum of negative values\n        config_key (str): key for getting data from config. Should be 'current' or 'ions'\n    \"\"\"\n    max_pos = np.max(pos)\n    max_neg = np.max(neg)\n    maxi = max_pos if max_pos > max_neg else max_neg\n\n    c[config_key][\"ylim\"] = (5.0 * maxi / 1e7, 5.0 * maxi)\n\n    # e.g. 0.0456 -> 0.04, 723 -> 700\n    sig = round_down_sig_digit(maxi)\n\n    c[config_key][\"ticks\"] = [sig * 0.00001, sig * 0.001, sig * 0.1]", ""]}
{"filename": "currentscape/currentscape.py", "chunked_list": ["\"\"\"Module to plot currentscapes.\n\nAs in https://datadryad.org/stash/dataset/doi:10.5061/dryad.d0779mb.\nThe main function is based on scripts from the susmentioned article,\nthat are under the CC0 1.0 Universal (CC0 1.0) Public Domain Dedication license.\n\"\"\"\n\n# Copyright 2023 Blue Brain Project / EPFL\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");", "\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# pylint: disable=too-many-statements, wrong-import-position\nimport logging\nimport numpy as np\nimport matplotlib\n", "import matplotlib\n\nmatplotlib.use(\"agg\")  # to avoid tkinter error\nimport matplotlib.pyplot as plt\n\nfrom currentscape.data_processing import (\n    autoscale_ticks_and_ylim,\n)\nfrom currentscape.plotting import (\n    configure_mpl_rcParams,", "from currentscape.plotting import (\n    configure_mpl_rcParams,\n    get_colormap,\n    adjust,\n    save_figure,\n    get_rows_tot,\n    plot_x_labels,\n)\nfrom currentscape.voltages import Voltages\nfrom currentscape.currents import Currents", "from currentscape.voltages import Voltages\nfrom currentscape.currents import Currents\nfrom currentscape.ions import IonConcentrations\nfrom currentscape.config_parser import set_default_config\n\nlogger = logging.getLogger(__name__)\n\n\ndef create_figure(voltage, currs, c, ions):\n    \"\"\"Create the currentscape figure.\n\n    Args:\n        voltage (list of floats): voltage data\n        currs (Currents): object containing currents data\n        c (dict): config\n        ions (IonConcentrations): object containing ionic concentration data\n    \"\"\"\n    configure_mpl_rcParams(c)\n    use_patterns = c[\"pattern\"][\"use\"]\n\n    cmap = get_colormap(\n        c[\"colormap\"][\"name\"], c[\"colormap\"][\"n_colors\"], use_patterns, currs.N, ions.N\n    )\n\n    # get adequate ticks and ylim\n    # put into classes\n    if c[\"current\"][\"autoscale_ticks_and_ylim\"]:\n        autoscale_ticks_and_ylim(c, currs.pos_sum, currs.neg_sum)\n    if ions.data is not None and c[\"ions\"][\"autoscale_ticks_and_ylim\"]:\n        autoscale_ticks_and_ylim(c, np.max(ions.data), abs(np.min(ions.data)), \"ions\")\n\n    rows_tot = get_rows_tot(c, ions)\n    row = 0\n\n    # START PLOT\n    fig = plt.figure(figsize=c[\"figsize\"])\n    if c[\"title\"]:\n        fig.suptitle(c[\"title\"], fontsize=c[\"titlesize\"])\n\n    # PLOT OVERALL CONTRIBUTIONS\n    # plot this first.\n    # cannot be at the bottom, because it would plot on top of xlabels if enabled.\n    if c[\"show\"][\"total_contribution\"]:\n        currs.plot_overall_contributions(c, row, rows_tot, cmap)\n        row += 2\n\n    # PLOT VOLTAGE TRACE\n    voltage.plot(c, row, rows_tot)\n    row += 2\n\n    # PLOT TOTAL INWARD CURRENT IN LOG SCALE\n    currs.plot_sum(c, row, rows_tot, True)\n    row += 1\n\n    # PLOT CURRENT SHARES\n    if (\n        c[\"show\"][\"currentscape\"]\n        and c[\"currentscape\"][\"legacy_method\"]\n        and not use_patterns\n    ):\n        currs.plot_shares_with_imshow(c, row, rows_tot, cmap)\n        row += 3\n    elif c[\"show\"][\"currentscape\"]:\n        currs.plot_shares(c, row, rows_tot, cmap)\n        row += 4\n\n    # PLOT TOTAL OUTWARD CURRENT IN LOG SCALE\n    currs.plot_sum(c, row, rows_tot, False)\n    row += 1\n\n    # PLOT ALL CURRENTS\n    if c[\"show\"][\"all_currents\"]:\n        # plot all positive currents\n        currs.plot(c, row, rows_tot, cmap, True)\n        row += 1\n        # plot all negative currents\n        currs.plot(c, row, rows_tot, cmap, False)\n        row += 1\n\n    # PLOT IONIC CONCENTRATIONS\n    if ions.data is not None:\n        if use_patterns:\n            ions.plot_with_linestyles(c, row, rows_tot, cmap)\n        else:\n            ions.plot(c, row, rows_tot, cmap)\n        row += 1\n\n    # ADD X LABEL & X TICK LABELS\n    # add labels only on bottom subplot\n    # time is identical for every dataset here, so currs can be used, even for ions xticks.\n    plot_x_labels(fig.axes[-1], c, currs.xticks)\n\n    adjust(\n        c[\"adjust\"][\"left\"],\n        c[\"adjust\"][\"right\"],\n        c[\"adjust\"][\"top\"],\n        c[\"adjust\"][\"bottom\"],\n    )\n\n    return fig", "def create_figure(voltage, currs, c, ions):\n    \"\"\"Create the currentscape figure.\n\n    Args:\n        voltage (list of floats): voltage data\n        currs (Currents): object containing currents data\n        c (dict): config\n        ions (IonConcentrations): object containing ionic concentration data\n    \"\"\"\n    configure_mpl_rcParams(c)\n    use_patterns = c[\"pattern\"][\"use\"]\n\n    cmap = get_colormap(\n        c[\"colormap\"][\"name\"], c[\"colormap\"][\"n_colors\"], use_patterns, currs.N, ions.N\n    )\n\n    # get adequate ticks and ylim\n    # put into classes\n    if c[\"current\"][\"autoscale_ticks_and_ylim\"]:\n        autoscale_ticks_and_ylim(c, currs.pos_sum, currs.neg_sum)\n    if ions.data is not None and c[\"ions\"][\"autoscale_ticks_and_ylim\"]:\n        autoscale_ticks_and_ylim(c, np.max(ions.data), abs(np.min(ions.data)), \"ions\")\n\n    rows_tot = get_rows_tot(c, ions)\n    row = 0\n\n    # START PLOT\n    fig = plt.figure(figsize=c[\"figsize\"])\n    if c[\"title\"]:\n        fig.suptitle(c[\"title\"], fontsize=c[\"titlesize\"])\n\n    # PLOT OVERALL CONTRIBUTIONS\n    # plot this first.\n    # cannot be at the bottom, because it would plot on top of xlabels if enabled.\n    if c[\"show\"][\"total_contribution\"]:\n        currs.plot_overall_contributions(c, row, rows_tot, cmap)\n        row += 2\n\n    # PLOT VOLTAGE TRACE\n    voltage.plot(c, row, rows_tot)\n    row += 2\n\n    # PLOT TOTAL INWARD CURRENT IN LOG SCALE\n    currs.plot_sum(c, row, rows_tot, True)\n    row += 1\n\n    # PLOT CURRENT SHARES\n    if (\n        c[\"show\"][\"currentscape\"]\n        and c[\"currentscape\"][\"legacy_method\"]\n        and not use_patterns\n    ):\n        currs.plot_shares_with_imshow(c, row, rows_tot, cmap)\n        row += 3\n    elif c[\"show\"][\"currentscape\"]:\n        currs.plot_shares(c, row, rows_tot, cmap)\n        row += 4\n\n    # PLOT TOTAL OUTWARD CURRENT IN LOG SCALE\n    currs.plot_sum(c, row, rows_tot, False)\n    row += 1\n\n    # PLOT ALL CURRENTS\n    if c[\"show\"][\"all_currents\"]:\n        # plot all positive currents\n        currs.plot(c, row, rows_tot, cmap, True)\n        row += 1\n        # plot all negative currents\n        currs.plot(c, row, rows_tot, cmap, False)\n        row += 1\n\n    # PLOT IONIC CONCENTRATIONS\n    if ions.data is not None:\n        if use_patterns:\n            ions.plot_with_linestyles(c, row, rows_tot, cmap)\n        else:\n            ions.plot(c, row, rows_tot, cmap)\n        row += 1\n\n    # ADD X LABEL & X TICK LABELS\n    # add labels only on bottom subplot\n    # time is identical for every dataset here, so currs can be used, even for ions xticks.\n    plot_x_labels(fig.axes[-1], c, currs.xticks)\n\n    adjust(\n        c[\"adjust\"][\"left\"],\n        c[\"adjust\"][\"right\"],\n        c[\"adjust\"][\"top\"],\n        c[\"adjust\"][\"bottom\"],\n    )\n\n    return fig", "\n\ndef plot_currentscape(voltage_data, currents_data, config, ions_data=None, time=None):\n    \"\"\"Returns a figure containing current scapes.\n\n    Args:\n        voltage_data (list): voltage data\n        currents_data (list of lists): currents data\n        config (dict or str): dict or path to json file containing config\n        ions_data (list of lists): ion concentrations data\n        time (list): time data\n    \"\"\"\n    # load config and set default to unspecified terms\n    c = set_default_config(config)\n\n    # currenscape data processing\n    logger.info(\"processing data\")\n\n    voltage = Voltages(voltage_data, c, time)\n    currs = Currents(currents_data, c, time)\n    ions = IonConcentrations(ions_data, c, time)\n\n    # plot currentscape\n    logger.info(\"producing figure\")\n    fig = create_figure(voltage, currs, c, ions)\n\n    # saving matplotlib figure needs a lot of memory\n    # so delete data that will not be used anymore before\n    currs = None\n    voltage = None\n    ions = None\n\n    if c[\"output\"][\"savefig\"]:\n        save_figure(fig, c)\n\n    return fig", ""]}
{"filename": "currentscape/currents.py", "chunked_list": ["\"\"\"Currents class.\n\nAs in https://datadryad.org/stash/dataset/doi:10.5061/dryad.d0779mb.\nSome functions are based on scripts from the susmentioned article,\nthat are under the CC0 1.0 Universal (CC0 1.0) Public Domain Dedication license.\n\"\"\"\n\n# Copyright 2023 Blue Brain Project / EPFL\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");", "\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# pylint: disable=wrong-import-position, super-with-arguments\nimport math\nimport numpy as np\nimport matplotlib\n", "import matplotlib\n\nmatplotlib.use(\"agg\")  # to avoid tkinter error\nimport matplotlib.pyplot as plt\n\nfrom currentscape.datasets import DataSet\nfrom currentscape.data_processing import (\n    reordered_idx,\n    reorder,\n    remove_zero_arrays,", "    reorder,\n    remove_zero_arrays,\n)\nfrom currentscape.plotting import (\n    remove_ticks_and_frame_for_bar_plot,\n    set_label,\n    apply_labels_ticks_and_lims,\n    stackplot_with_bars,\n    stackplot_with_fill_between,\n    black_line_log_scale,", "    stackplot_with_fill_between,\n    black_line_log_scale,\n    get_colors_hatches_lines_lists,\n    show_xgridlines,\n)\nfrom currentscape.legends import (\n    set_legend_with_hatches,\n    set_legend_with_hatches_and_linestyles,\n    set_legend_with_lines,\n    set_legend,", "    set_legend_with_lines,\n    set_legend,\n)\nfrom currentscape.mapper import create_mapper\n\n\nclass CurrentPlottingMixin:\n    \"\"\"All current plotting methods to be inherited by the Currents class.\"\"\"\n\n    def plot_sum(self, c, row, rows_tot, positive=True):\n        \"\"\"Plot outward or inward current sum in log scale.\n\n        Args:\n            c (dict): config\n            row (int): row of subplot\n            rows_tot (int): total number of subplots in the figure\n            positive (bool): True to plot positive currents subplot.\n                False to plot negative currents subplot\n        \"\"\"\n        if positive:\n            curr = self.pos_sum\n        else:\n            curr = self.neg_sum\n\n        ax = plt.subplot2grid((rows_tot, 1), (row, 0), rowspan=1)\n        ax.fill_between(\n            self.time,\n            curr,\n            color=c[\"current\"][\"color\"],\n            lw=c[\"lw\"],\n            zorder=2,\n        )\n\n        apply_labels_ticks_and_lims(\n            ax,\n            c,\n            self.xticks,\n            [self.time[0], self.time[-1]],\n            list(c[\"current\"][\"ylim\"]),\n            positive,\n            \"current\",\n        )\n\n    def plot_shares(self, c, row, rows_tot, cmap):\n        \"\"\"Plot current percentages.\n\n        Args:\n            c (dict): config\n            row (int): row of subplot\n            rows_tot (int): total number of subplots in the figure\n            cmap (matplotlib.colors.Colormap): colormap\n        \"\"\"\n        # outward currents\n        ax = plt.subplot2grid((rows_tot, 1), (row, 0), rowspan=2)\n        if c[\"currentscape\"][\"legacy_method\"]:\n            stackplot_with_bars(\n                ax, self.pos_norm, self.idxs, cmap, c, self.N, self.mapper\n            )\n        else:\n            stackplot_with_fill_between(\n                ax, self.pos_norm, self.idxs, cmap, c, self.N, self.mapper\n            )\n\n        # add at black line a the bottom of the plot.\n        # cannot use spines because with subplot_adjust(h=0),\n        # spines overlap on neighboor plot and hide part of the data\n        y_bottom = -c[\"current\"][\"black_line_thickness\"] / 100.0\n        ax.fill_between(\n            [self.time[0], self.time[-1]],\n            [y_bottom, y_bottom],\n            color=\"black\",\n            lw=0,\n        )\n\n        ylim = [y_bottom, 1]\n        ax.set_ylim(ylim)\n        ax.set_xlim([self.time[0], self.time[-1]])\n        remove_ticks_and_frame_for_bar_plot(ax)\n\n        # show x axis gridline\n        if c[\"show\"][\"xgridlines\"]:\n            show_xgridlines(ax, c, self.xticks, ylim)\n\n        # labels\n        if c[\"show\"][\"ylabels\"]:\n            ax.set_ylabel(c[\"currentscape\"][\"out_label\"], labelpad=c[\"labelpad\"])\n\n        # legend\n        # place legend here so that legend top is at the level of share plot top\n        if c[\"show\"][\"legend\"]:\n            if not c[\"pattern\"][\"use\"]:\n                set_legend(\n                    ax,\n                    cmap,\n                    c[\"current\"][\"names\"],\n                    c[\"legend\"][\"bgcolor\"],\n                    c[\"legend\"][\"ypos\"],\n                    self.idxs,\n                )\n            elif c[\"show\"][\"all_currents\"] and not c[\"current\"][\"stackplot\"]:\n                set_legend_with_hatches_and_linestyles(\n                    ax, cmap, self.mapper, c, self.idxs\n                )\n            else:\n                set_legend_with_hatches(ax, cmap, self.mapper, c, self.idxs)\n\n        # inward currents\n        ax = plt.subplot2grid((rows_tot, 1), (row + 2, 0), rowspan=2)\n        if c[\"currentscape\"][\"legacy_method\"]:\n            stackplot_with_bars(\n                ax, self.neg_norm, self.idxs, cmap, c, self.N, self.mapper\n            )\n        else:\n            stackplot_with_fill_between(\n                ax, self.neg_norm, self.idxs, cmap, c, self.N, self.mapper\n            )\n\n        ylim = [0, 1]\n        ax.set_ylim(ylim)\n        ax.set_xlim([self.time[0], self.time[-1]])\n        remove_ticks_and_frame_for_bar_plot(ax)\n\n        # show x axis gridline\n        if c[\"show\"][\"xgridlines\"]:\n            show_xgridlines(ax, c, self.xticks, ylim)\n\n        # labels\n        if c[\"show\"][\"ylabels\"]:\n            ax.set_ylabel(c[\"currentscape\"][\"in_label\"], labelpad=c[\"labelpad\"])\n\n    def plot_shares_with_imshow(self, c, row, rows_tot, cmap):\n        \"\"\"Plot current percentage using imshow.\n\n        Args:\n            c (dict): config\n            row (int): row of subplot\n            rows_tot (int): total number of subplots in the figure\n            cmap (matplotlib.colors.Colormap): colormap\n        \"\"\"\n        resy = c[\"currentscape\"][\"y_resolution\"]\n        black_line_size = int(resy * c[\"current\"][\"black_line_thickness\"] / 100.0)\n\n        ax = plt.subplot2grid((rows_tot, 1), (row, 0), rowspan=3)\n        im = ax.imshow(\n            self.image[::1, ::1],\n            interpolation=\"nearest\",\n            aspect=\"auto\",\n            cmap=cmap,\n        )\n\n        plt.gca().xaxis.set_major_locator(plt.NullLocator())\n        plt.gca().yaxis.set_major_locator(plt.NullLocator())\n\n        # set limits\n        ylim = [2 * resy + black_line_size, 0]\n        ax.set_ylim(ylim)\n        ax.set_xlim(0, self.x_size)\n\n        # show x axis gridline\n        if c[\"show\"][\"xgridlines\"]:\n            show_xgridlines(ax, c, self.xticks_for_imshow(), ylim)\n\n        # set number of colors\n        # data + black for separating line + white for empty data = (N-1)+1+1\n        im.set_clim(0, self.N + 1)\n\n        # remove top and bottom frame that hide some data\n        ax.spines[\"top\"].set_visible(False)\n        ax.spines[\"bottom\"].set_visible(False)\n\n        # labels\n        if c[\"show\"][\"ylabels\"]:\n            # cheat to set two labels at the right places for 1 axis\n            set_label(\n                ax,\n                x=0,\n                y=3 * resy / 2,\n                label=c[\"currentscape\"][\"in_label\"],\n                textsize=c[\"textsize\"],\n            )\n            set_label(\n                ax,\n                x=0,\n                y=resy / 2,\n                label=c[\"currentscape\"][\"out_label\"],\n                textsize=c[\"textsize\"],\n            )\n\n        # legend\n        if c[\"show\"][\"legend\"]:\n            set_legend(\n                ax,\n                im.cmap,\n                c[\"current\"][\"names\"],\n                c[\"legend\"][\"bgcolor\"],\n                c[\"legend\"][\"ypos\"],\n                self.idxs,\n            )\n\n    def plot_with_lines(self, ax, selected_currs, c, cmap):\n        \"\"\"Plot all the positive (or negative) currents with lines.\n\n        Args:\n            ax (matplotlib.axes): current axis\n            selected_currs (ndarray of ndarrays): positive or negative currents data\n            c (dict): config\n            cmap (matplotlib.colors.Colormap): colormap\n        \"\"\"\n        lw = c[\"lw\"]\n\n        # here, use currs.idxs to have the same colors as in currs.names\n        # can do it because selected_currs have same shape as self (no zero arrays removed)\n        for i, curr in enumerate(selected_currs[self.idxs]):\n            if not np.all(curr == 0):\n                color, _, linestyle = get_colors_hatches_lines_lists(\n                    c, i, cmap, self.mapper\n                )\n\n                ax.plot(self.time, curr, color=color, ls=linestyle, lw=lw, zorder=2)\n\n    def plot(self, c, row, rows_tot, cmap, positive=True):\n        \"\"\"Plot all the positive (or negative) currents.\n\n        Args:\n            c (dict): config\n            row (int): row of subplot\n            rows_tot (int): total number of subplots in the figure\n            cmap (matplotlib.colors.Colormap): colormap\n            positive (bool): True to plot positive currents subplot.\n                False to plot negative currents subplot\n        \"\"\"\n        ylim = list(c[\"current\"][\"ylim\"])\n\n        ax = plt.subplot2grid((rows_tot, 1), (row, 0), rowspan=1)\n\n        # select currents (positive or negative)\n        if positive:\n            selected_currs = self.get_positive_data()\n        else:\n            selected_currs = np.abs(self.get_negative_data())\n\n        # plot selected currents, either with stackplot or with lines.\n        if c[\"current\"][\"stackplot\"]:\n            # create dataset from reordered selected currents\n            sorted_idxs = reordered_idx(selected_currs)\n            sel_currs = DataSet(\n                data=selected_currs[sorted_idxs],\n                names=self.names,\n                time=self.time,\n                xticks=self.xticks,\n            )\n            sel_currs.idxs = sorted_idxs\n\n            if c[\"current\"][\"legacy_method\"]:\n                stackplot_with_bars(\n                    ax, sel_currs, self.idxs, cmap, c, self.N, self.mapper, False\n                )\n            else:\n                stackplot_with_fill_between(\n                    ax, sel_currs, self.idxs, cmap, c, self.N, self.mapper, False\n                )\n        else:\n            self.plot_with_lines(ax, selected_currs, c, cmap)\n\n        # add black line separating positive currents from negative currents\n        if positive and c[\"current\"][\"stackplot\"]:\n            ylim = black_line_log_scale(\n                ax,\n                ylim,\n                [self.time[0], self.time[-1]],\n                c[\"current\"][\"black_line_thickness\"],\n            )\n\n        # show legend if not shown in currentscape\n        if not c[\"show\"][\"currentscape\"] and c[\"show\"][\"legend\"] and positive:\n            # regular colors\n            if not c[\"pattern\"][\"use\"]:\n                set_legend(\n                    ax,\n                    cmap,\n                    c[\"current\"][\"names\"],\n                    c[\"legend\"][\"bgcolor\"],\n                    c[\"legend\"][\"ypos\"],\n                    self.idxs,\n                )\n            # colors & hatches\n            elif c[\"current\"][\"stackplot\"]:\n                set_legend_with_hatches(ax, cmap, self.mapper, c, self.idxs)\n            # linestyles & hatches\n            elif c[\"show\"][\"total_contribution\"]:\n                set_legend_with_hatches_and_linestyles(\n                    ax, cmap, self.mapper, c, self.idxs\n                )\n            # linestyles only\n            else:\n                set_legend_with_lines(\n                    ax,\n                    cmap,\n                    self.mapper,\n                    c,\n                    self.idxs,\n                    c[\"current\"][\"names\"],\n                )\n\n        apply_labels_ticks_and_lims(\n            ax,\n            c,\n            self.xticks,\n            [self.time[0], self.time[-1]],\n            ylim,\n            positive,\n            \"current\",\n        )\n\n    def plot_overall_contribution(self, ax, data, c, cmap):\n        \"\"\"Plot one pie chart of either positive or negative currents contribution.\n\n        Args:\n            ax (matplotlib.axes): pie chart axis\n            data (ndarray of ndarrays): positive or negative currents data\n            c (dict): config\n            cmap (matplotlib.colors.Colormap): colormap\n        \"\"\"\n        # bar plot in polar coordinates -> pie chart\n        radius = 1\n        size = 0.5\n\n        # process data to be polar coordinates compatible\n        valsnorm = np.sum(data / np.sum(data) * 2 * np.pi, axis=1)\n        valsleft = np.cumsum(np.append(0, valsnorm[:-1]))\n\n        # current indexes\n        curr_idxs = np.arange(self.N)\n        # set colors and patterns\n        colors, hatches, _ = get_colors_hatches_lines_lists(\n            c, curr_idxs, cmap, self.mapper\n        )\n\n        bars = ax.bar(\n            x=valsleft,\n            width=valsnorm,\n            bottom=radius - size,\n            height=size,\n            color=colors,\n            edgecolor=c[\"pattern\"][\"color\"],\n            linewidth=c[\"lw\"],\n            align=\"edge\",\n        )\n        # for loop, because hatches cannot be passed as a list\n        if hatches is not None:\n            for bar_, hatch in zip(bars, hatches):\n                bar_.set_hatch(hatch)\n\n        ax.set_axis_off()\n\n    def plot_overall_contributions(self, c, row, rows_tot, cmap):\n        \"\"\"Plot positive and negative pie charts of currents summed over the whole simulation.\n\n        Args:\n            c (dict): config\n            row (int): row of subplot\n            rows_tot (int): total number of subplots in the figure\n            cmap (matplotlib.colors.Colormap): colormap\n        \"\"\"\n        textsize = c[\"textsize\"]\n        labelpad = c[\"labelpad\"]\n        # POSITIVE\n        # trick: bar plot in polar coord. to do a pie chart.\n        ax = plt.subplot2grid((rows_tot, 2), (row, 0), rowspan=2, polar=True)\n\n        # get positive data and reorder them\n        pos_data = self.get_positive_data()[self.idxs]\n        self.plot_overall_contribution(ax, pos_data, c, cmap)\n\n        # pi is left in x polar coordinates, 1 is height of bars -> outside pie chart\n        # labelpad / 4 : looks close to labelpad in regular plot, but is not rigorous\n        if c[\"show\"][\"ylabels\"]:\n            set_label(ax, math.pi, 1 + labelpad / 4.0, \"outward\", textsize)\n\n        # NEGATIVE\n        # trick: bar plot in polar coord. to do a pie chart.\n        ax = plt.subplot2grid((rows_tot, 2), (row, 1), rowspan=2, polar=True)\n\n        # get positive data and reorder them\n        neg_data = self.get_negative_data()[self.idxs]\n        self.plot_overall_contribution(ax, neg_data, c, cmap)\n\n        # pi is left in x polar coordinates, 1 is height of bars -> outside pie chart\n        # labelpad / 4 : looks close to labelpad in regular plot, but is not rigorous\n        if c[\"show\"][\"ylabels\"]:\n            set_label(ax, math.pi, 1 + labelpad / 4.0, \"inward\", textsize)", "\n\nclass Currents(CurrentPlottingMixin, DataSet):\n    \"\"\"Class containing current data.\"\"\"\n\n    def __init__(self, data, c, time=None):\n        \"\"\"Constructor.\n\n        Args:\n            data (list of lists): data\n                all lists are expected to have the same size.\n            c (dict): config\n            time (list): time of the data\n\n        Attributes:\n            pos_norm (ndarray of ndarrays): norm of positive data\n            neg_norm (ndarray of ndarrays): - norm of negative data\n            pos_sum (ndarray of floats): summed positive data along axis=0\n            neg_sum (ndarray of floats): summed negative data along axis=0\n            image (ndarray of ndarrays): currentscape image to be shown with imshow\n            mapper (int): number used to mix colors and patterns\n        \"\"\"\n        reorder_ = c[\"current\"][\"reorder\"]\n        resy = c[\"currentscape\"][\"y_resolution\"]\n        lw = c[\"current\"][\"black_line_thickness\"]\n        use_pattern = c[\"pattern\"][\"use\"]\n        n_patterns = len(c[\"pattern\"][\"patterns\"])\n        legacy = c[\"currentscape\"][\"legacy_method\"]\n\n        super(Currents, self).__init__(\n            data=data,\n            names=c[\"current\"][\"names\"],\n            time=time,\n            xticks=c[\"xaxis\"][\"xticks\"],\n        )\n\n        # self.idxs may be modified in the method below\n        self.pos_norm, self.neg_norm, self.pos_sum, self.neg_sum = self.data_processing(\n            reorder_\n        )\n\n        if not legacy or use_pattern:\n            # check this before creating mapper\n            # this change should persist even outside the class\n            if c[\"colormap\"][\"n_colors\"] > self.N:\n                c[\"colormap\"][\"n_colors\"] = self.N\n\n            self.image = None\n            self.mapper = create_mapper(c[\"colormap\"][\"n_colors\"], n_patterns)\n        else:\n            self.image = self.create_cscape_image(resy, lw)\n            self.mapper = None\n\n    def data_processing(self, reorder_):\n        \"\"\"Separate into positive and negative currents.\n\n        Remove 0s arrays. Reorder if asked. Record reordered name indexes.\n        Return the sum and the fraction with its reordered indexes.\n\n        Args:\n            reorder_ (bool): whether to reorder the currents or not\n\n        Returns: A tuple (pos_norm, neg_norm, normapos, normaneg), with\n            pos_norm (ndarray of ndarrays): arrays containing norm of positive currents\n\n            neg_norm (ndarray of ndarrays): arrays containing (-1)* norm of negative currents\n\n            normapos (ndarray): summed positive currents\n\n            normaneg (ndarray): summed (absolute values of) negative currents\n        \"\"\"\n        cpos = self.get_positive_data()\n        cneg = self.get_negative_data()\n\n        normapos = np.sum(np.abs(np.asarray(cpos)), axis=0)\n        normaneg = np.sum(np.abs(np.asarray(cneg)), axis=0)\n\n        # replace 0s by 1s in norma* to avoid 0/0 error.\n        # When norma* is 0, all values it divides are 0s, so even when replaced by 1s,\n        #   the result is 0.\n        # We want the result to be 0 in that case because there is no current.\n        cnorm_pos = np.abs(cpos) / [x if x != 0 else 1.0 for x in normapos]\n        cnorm_neg = -(np.abs(cneg) / [x if x != 0 else 1.0 for x in normaneg])\n\n        # memory optimisation\n        cpos = None\n        cneg = None\n\n        if reorder_:\n            cnorm_pos, cnorm_neg, idx_pos, idx_neg = self.reorder_currents_and_names(\n                cnorm_pos, cnorm_neg\n            )\n        else:\n            cnorm_pos, idx_pos = remove_zero_arrays(cnorm_pos)\n            cnorm_neg, idx_neg = remove_zero_arrays(cnorm_neg)\n\n        pos_norm = DataSet(cnorm_pos, time=self.time, xticks=self.xticks)\n        pos_norm.idxs = idx_pos\n        neg_norm = DataSet(cnorm_neg, time=self.time, xticks=self.xticks)\n        neg_norm.idxs = idx_neg\n\n        return (\n            pos_norm,\n            neg_norm,\n            normapos,\n            normaneg,\n        )\n\n    def reorder_currents_and_names(self, cnorm_pos, cnorm_neg):\n        \"\"\"Reorder positive currents, negative currents, and current names.\n\n        Reorder from overall largest contribution to smallest contribution.\n        Reordering the current names (for legend display) is not essential,\n        but is more pleasant to the eye.\n\n        Args:\n            cnorm_pos (ndarray of ndarrays): arrays containing norm\n                of positive currents\n            cnorm_neg (ndarray of ndarrays): arrays containing (-1)* norm\n                of negative currents\n\n        Returns:\n            trimmed and reordered positive currents array\n            trimmed and reordered negative currents array\n            indexes that currents (in the pos array) used to have in the original curr array\n            indexes that currents (in the neg array) used to have in the original curr array\n        \"\"\"\n        cnorm_pos, idx_pos = reorder(cnorm_pos)\n        cnorm_neg, idx_neg = reorder(cnorm_neg)\n\n        # for the order of names, just stack the positive and negative order,\n        # then removing duplicates (while conserving order).\n        # also stack arange in case a current is zero for all the sim -> avoid index errors later\n        idx_names = np.concatenate((idx_pos, idx_neg, np.arange(self.N)))\n        _, i = np.unique(idx_names, return_index=True)\n        self.idxs = idx_names[\n            np.sort(i)\n        ]  # pylint: disable=attribute-defined-outside-init\n\n        return cnorm_pos, cnorm_neg, idx_pos, idx_neg\n\n    def create_black_line(self, resy, lw):\n        \"\"\"Create a black line to separate inward and outward current shares.\n\n        Args:\n            resy (int): y-axis resolution\n                (must be high >>1000 or else rounding errors produce white pixels)\n            lw (int): black line (separating the two currentscape plots) thickness\n                in percentage of the plot height.\n        \"\"\"\n        line_thickness = int(resy * lw / 100.0)\n        if line_thickness < 1:\n            line = np.full((1, self.x_size), self.N, dtype=np.int8)\n        else:\n            line = np.full((line_thickness, self.x_size), self.N, dtype=np.int8)\n\n        return line\n\n    def create_cscape_image(self, resy, lw):\n        \"\"\"Create currentscape image.\n\n        Args:\n            resy (int): y-axis resolution\n                (must be high >>1000 or else rounding errors produce white pixels)\n            lw (int): black line (separating the two currentscape plots) thickness\n                in percentage of the plot height.\n        \"\"\"\n        # idexes to map to re-ordered current names\n        # interchange index and values of self.idxs (name indexes) to create imap\n        # that way, imap[idx] gives index in self.idxs\n        imap = np.zeros(self.N, dtype=int)\n        imap[self.idxs] = np.arange(self.N)\n\n        times = np.arange(0, self.x_size)\n        # using int8 not to take too much memory\n        impos = np.full((resy, self.x_size), self.N + 1, dtype=np.int8)\n        imneg = np.full((resy, self.x_size), self.N + 1, dtype=np.int8)\n\n        for t in times:\n            lastpercent = 0\n            for idx, curr in zip(self.pos_norm.idxs, self.pos_norm.data):\n                if curr[t] > 0:\n                    numcurr = imap[idx]\n                    percent = int(abs(curr[t]) * (resy))\n                    impos[lastpercent : lastpercent + percent, t] = numcurr\n                    lastpercent = lastpercent + percent\n        for t in times:\n            lastpercent = 0\n            for idx, curr in zip(self.neg_norm.idxs, self.neg_norm.data):\n                if curr[t] < 0:\n                    numcurr = imap[idx]\n                    percent = int(abs(curr[t]) * (resy))\n                    imneg[lastpercent : lastpercent + percent, t] = numcurr\n                    lastpercent = lastpercent + percent\n\n        # append fake data to produce a black line separating inward & outward\n        # cannot draw with plot, because that would hide data because of adjust (h=0)\n        line = self.create_black_line(resy, lw)\n\n        return np.vstack((impos, line, imneg))", ""]}
{"filename": "examples/use_case/run.py", "chunked_list": ["\"\"\"Run the cell to record currents and ionic concentrations.\"\"\"\n\n# Copyright 2023 Blue Brain Project / EPFL\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n", "#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport logging\nfrom pathlib import Path", "import logging\nfrom pathlib import Path\n\nfrom bluepyopt import ephys\nfrom emodelrunner.load import load_emodel_params\nfrom emodelrunner.load import load_mechanisms\nfrom emodelrunner.load import load_unoptimized_parameters\nfrom emodelrunner.morphology.morphology import SSCXNrnFileMorphology\nfrom emodelrunner.output import write_responses\nfrom emodelrunner.recordings import RecordingCustom", "from emodelrunner.output import write_responses\nfrom emodelrunner.recordings import RecordingCustom\n\nlogger = logging.getLogger(__name__)\n\n\ndef absolute_path(path):\n    path_to_dir = Path( __file__ ).parent.absolute()\n    return str(path_to_dir / path)\n", "\n\ndef create_cell():\n    unopt_params_path = absolute_path(\"config/params/pyr.json\")\n\n    mechs = load_mechanisms(unopt_params_path)\n\n    params = load_unoptimized_parameters(unopt_params_path, v_init=-80, celsius=34)\n\n    morph_path = absolute_path(\n        \"morphology/dend-C231296A-P4B2_axon-C200897C-P2_-_Scale_x1.000_y0.975_z1.000.asc\"\n    )\n    morph = SSCXNrnFileMorphology(\n        morphology_path=morph_path,\n        do_replace_axon=True,\n    )\n\n    return ephys.models.CellModel(\n        name=\"cADpyr_L4UPC\",\n        morph=morph,\n        mechs=mechs,\n        params=params,\n    )", "\n\ndef create_recordings(soma_loc):\n    recs = []\n    currents = [\n        \"i_pas\",\n        \"ihcn_Ih\",\n        \"ica_Ca_HVA2\",\n        \"ica_Ca_LVAst\",\n        \"ik_SK_E2\",\n        \"ik_SKv3_1\",\n        \"ik_K_Pst\",\n        \"ik_K_Tst\",\n        \"ina_NaTg\",\n    ]\n    ionic_concentrations = [\"cai\", \"ki\", \"nai\"]\n\n    recs.append(RecordingCustom(name=\"v\", location=soma_loc, variable=\"v\"))\n\n    for var in currents:\n        recs.append(RecordingCustom(name=var, location=soma_loc, variable=var))\n\n    for var in ionic_concentrations:\n        recs.append(RecordingCustom(name=var, location=soma_loc, variable=var))\n\n    return recs", "\ndef create_stimuli(soma_loc):\n    # create step stimulus\n    stim = ephys.stimuli.NrnSquarePulse(\n        step_amplitude=0.34859375,\n        step_delay=70.0,\n        step_duration=200.0,\n        location=soma_loc,\n        total_duration=300.0,\n    )\n\n    # create holding stimulus\n    hold_stim = ephys.stimuli.NrnSquarePulse(\n        step_amplitude=-0.0896244038173676,\n        step_delay=0.0,\n        step_duration=300.0,\n        location=soma_loc,\n        total_duration=300.0,\n    )\n\n    return [stim, hold_stim]", "\n\ndef run():\n    cell = create_cell()\n\n    release_params = load_emodel_params(\n        params_path=absolute_path(\"config/params/final.json\"), emodel=\"cADpyr_L4UPC\"\n    )\n\n    sim = ephys.simulators.NrnSimulator(dt=0.025, cvode_active=False)\n\n    soma_loc = ephys.locations.NrnSeclistCompLocation(\n        name=\"soma\", seclist_name=\"somatic\", sec_index=0, comp_x=0.5\n    )\n\n    recs = create_recordings(soma_loc)\n\n    stims = create_stimuli(soma_loc)\n\n    protocol = ephys.protocols.SweepProtocol(\"step_protocol\", stims, recs, cvode_active=False)\n\n    logger.info(\"Python Recordings Running...\")\n    responses = protocol.run(\n        cell_model=cell, param_values=release_params, sim=sim, isolate=False\n    )\n\n    write_responses(responses, absolute_path(\"python_recordings\"))\n\n    logger.info(\"Python Recordings Done\")", "\n\nif __name__ == \"__main__\":\n    run()\n"]}
{"filename": "examples/use_case/plot.py", "chunked_list": ["\"\"\"Plot currentscape.\"\"\"\n\n# Copyright 2023 Blue Brain Project / EPFL\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n", "#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom pathlib import Path\nimport numpy as np", "from pathlib import Path\nimport numpy as np\n\nimport currentscape\n\nfrom run import absolute_path\n\ndef plot():\n    data_dir = absolute_path(\"python_recordings\")\n    currs = [\n        \"i_pas\",\n        \"ihcn_Ih\",\n        \"ica_Ca_HVA2\",\n        \"ica_Ca_LVAst\",\n        \"ik_SK_E2\",\n        \"ik_SKv3_1\",\n        \"ik_K_Pst\",\n        \"ik_K_Tst\",\n        \"ina_NaTg\",\n    ]\n    ionic_concentrations = [\"cai\", \"ki\", \"nai\"]\n\n    # load voltage data\n    v_path = Path(data_dir) / \"v.dat\"\n    voltage = np.loadtxt(v_path)[:, 1] # load 2nd column. 1st column is time.\n\n    # load currents from files\n    currents = []\n    for curr in currs:\n        file_path = Path(data_dir) / f\"{curr}.dat\"\n        currents.append(np.loadtxt(file_path)[:, 1]) # load 2nd column. 1st column is time.\n    currents = np.array(currents)\n\n    # load ionic concentrations from files\n    ions = []\n    for ion in ionic_concentrations:\n        file_path = Path(data_dir) / f\"{ion}.dat\"\n        ions.append(np.loadtxt(file_path)[:, 1]) # load 2nd column. 1st column is time.\n    ions = np.array(ions)\n\n\n    # define config\n    # can pass a config file\n    # config = absolute_path(\"path/to/config\")\n    # can also pass config as a dictionnary\n    curr_names = [\"pas\", \"Ih\", \"Ca_HVA2\", \"Ca_LVAst\", \"SK_E2\", \"SKv3_1\", \"K_Pst\", \"K_Tst\", \"NaTg\"]\n    config = {\n        \"current\": {\"names\": curr_names},\n        \"ions\":{\"names\": [\"ca\", \"k\", \"na\"]},\n        \"legendtextsize\": 5,\n    }\n\n\n    # produce currentscape figure\n    fig = currentscape.plot(voltage, currents, config, ions)\n    return fig", "\nif __name__ == \"__main__\":\n    fig = plot()\n    fig.show()\n"]}
{"filename": "examples/use_case/__init__.py", "chunked_list": [""]}
{"filename": "examples/original_paper_plot/integrate_single_compartment_and_plot_currentscape.py", "chunked_list": ["\"\"\"Script based from https://datadryad.org/stash/dataset/doi:10.5061/dryad.d0779mb\n    under the CC0 1.0 Universal (CC0 1.0) Public Domain Dedication license.\n\"\"\"\n# Preliminaries and Modules\nimport numpy as np\nfrom scipy.integrate import odeint\nfrom single_compartment import single_compartment\nfrom get_currents import model\nimport currentscape\n", "import currentscape\n\n\ndef plot_from_original_paper(t0=0.0, tf=10000.0, dt=0.1):\n    \"\"\"Plot currentscape using original paper data.\n\n    Args:\n        t0 (float): begin time of simulation (in ms)\n        tf (float): end time of simulation (in ms)\n        dt (float): time step (in ms)\n    \"\"\"\n    # specify the path to initial conditions and paramters files\n    config = \"config.json\"\n\n    pathtocis = (\n        \"parameters-and-initial-conditions/initial-conditions.txt\"\n    )\n    pathtoparameters = (\n        \"parameters-and-initial-conditions/model-A-name-HZFTSB.txt\"\n    )\n\n    # load initialconditions and parameters\n\n    y0 = np.genfromtxt(pathtocis)\n    parameters = np.genfromtxt(pathtoparameters)\n\n    # define temperature (set to 10 C)\n    temp = 10\n\n    # define integration interval and temporal resolution\n    t = np.arange(t0, tf, dt)\n\n    # integration is performed using odeint, a built-in python package to integrate Ordinary Differential Equations\n    fullsolution = odeint(\n        single_compartment,\n        y0,\n        t,\n        args=(\n            parameters,\n            temp,\n        ),\n    )\n\n    # define voltage and currents for currentscape plotting\n    voltage = fullsolution[:, 0]\n    currents = model(fullsolution, parameters, temp)\n\n    # plot currentscape (full temporal range)\n    fig = currentscape.plot(voltage, currents, config)", "\n\nif __name__ == \"__main__\":\n    plot_from_original_paper()\n"]}
{"filename": "examples/original_paper_plot/get_currents.py", "chunked_list": ["\"\"\"Script taken from https://datadryad.org/stash/dataset/doi:10.5061/dryad.d0779mb\n    under the CC0 1.0 Universal (CC0 1.0) Public Domain Dedication license.\"\"\"\n\nfrom numpy import *\nimport numpy as np\n\n\n# Time constant functions\ndef tauX(Volt, CT, DT, AT, BT):\n    timeconst = CT - DT / (1.0 + np.exp((Volt + AT) / BT))\n    return timeconst", "def tauX(Volt, CT, DT, AT, BT):\n    timeconst = CT - DT / (1.0 + np.exp((Volt + AT) / BT))\n    return timeconst\n\n\n# Special time constant function (spectau)\ndef spectau(Volt, CT, DT, AT, BT, AT2, BT2):\n    spec = CT + DT / (np.exp((Volt + AT) / BT) + np.exp((Volt + AT2) / BT2))\n    return spec\n", "\n\n# Ionic currents\n# q is the exponent of the activation variable m\ndef iIonic(g, m, h, q, Volt, Erev):\n    flux = g * pow(m, q) * h * (Volt - Erev)\n    return flux\n\n\n# Concentration dependent Ca reversal potential\ndef CaNernst(CaIn, temp):\n    R = 8.314 * pow(10, 3)  # Ideal Gas Constant (*10^3 to put into mV)\n    T = 273.15 + temp  # Temperature in Kelvin\n    z = 2.0  # Valence of Caclium Ions\n    Far = 96485.33  # Faraday's Constant\n    CaOut = 3000.0  # Outer Ca Concentration (uM)\n    CalRev = ((R * T) / (z * Far)) * np.log(CaOut / CaIn)\n    # print 'calrev ', CalRev\n    return CalRev", "\n# Concentration dependent Ca reversal potential\ndef CaNernst(CaIn, temp):\n    R = 8.314 * pow(10, 3)  # Ideal Gas Constant (*10^3 to put into mV)\n    T = 273.15 + temp  # Temperature in Kelvin\n    z = 2.0  # Valence of Caclium Ions\n    Far = 96485.33  # Faraday's Constant\n    CaOut = 3000.0  # Outer Ca Concentration (uM)\n    CalRev = ((R * T) / (z * Far)) * np.log(CaOut / CaIn)\n    # print 'calrev ', CalRev\n    return CalRev", "\n\ndef model(v, p, temp):\n    reftemp = 10\n    V = v[:, 0]\n    NaM = v[:, 1]\n    NaH = v[:, 2]\n    CaTM = v[:, 3]\n    CaTH = v[:, 4]\n    CaSM = v[:, 5]\n    CaSH = v[:, 6]\n    HM = v[:, 7]\n    KdM = v[:, 8]\n    KCaM = v[:, 9]\n    AM = v[:, 10]\n    AH = v[:, 11]\n    IntCa = v[:, 12]\n\n    CaRev = CaNernst(IntCa, temp)\n    tauIntCa = p[35]  # Calcium buffer time constant (ms)\n    # Maximal Conductances\n    gNa = p[0]  # Transient Sodium Maximal Conductance\n    gCaT = p[1]  # Low Threshold Calcium Maximal Conductance\n    gCaS = p[2]  # Slow Calcium Maximal Conductance\n    gA = p[3]  # Transient Potassium Maximal Conductance\n    gKCa = p[4]  # Calcium Dependent Potassium Maximal Conductance\n    gKd = p[5]  # Potassium Maximal Conductance\n    gH = p[6]  # Hyperpolarization Activated Cation Maximal Conductance\n    gL = p[7]  # Leak Maximal Conductance\n\n    # p_Erev = [e_leak,e_na,e_k,e_h]\n    EL = p[8]  # Leak Reversal Potential\n    ENa = p[9]  # Sodium Reversal Potential\n    ECaT = CaRev  # Low Threshold Calcium Reversal Potential\n    ECaS = CaRev  # Slow Calcium Reversal Potential\n\n    EKd = p[10]  # Potassium Reversal Potential\n    EKCa = p[10]  # Calcium Dependent Potassium Reversal Potential\n    EA = p[10]  # Transient Potassium Reversal Potential\n\n    EH = p[11]  # Hyperpolarization Activated Cation Reversal Potential\n\n    q10_gNa = p[12]\n    q10_gNa_m = p[13]\n    q10_gNa_h = p[14]\n\n    q10_gCaT = p[15]\n    q10_gCaT_m = p[16]\n    q10_gCaT_h = p[17]\n\n    q10_gCaS = p[18]\n    q10_gCaS_m = p[19]\n    q10_gCaS_h = p[20]\n\n    q10_gA = p[21]\n    q10_gA_m = p[22]\n    q10_gA_h = p[23]\n\n    q10_gKCa = p[24]\n    q10_gKCa_m = p[25]\n\n    q10_gKdr = p[27]\n    q10_gKdr_m = p[28]\n\n    q10_gH = p[30]\n    q10_gH_m = p[31]\n\n    q10_g_leak = p[33]\n    q10_tau_Ca = p[34]\n\n    # Time Constants (ms)\n    tauNaM = tauX(V, 1.32, 1.26, 120.0, -25.0)\n    tauNaM = tauNaM * pow(q10_gNa_m, -(temp - reftemp) / 10.0)\n    tauNaH = tauX(V, 0.0, -0.67, 62.9, -10.0) * tauX(V, 1.50, -1.00, 34.9, 3.60)\n    tauNaH = tauNaH * pow(q10_gNa_h, -(temp - reftemp) / 10.0)\n    tauCaTM = tauX(V, 21.7, 21.3, 68.1, -20.5)\n    tauCaTM = tauCaTM * pow(q10_gCaT_m, -(temp - reftemp) / 10.0)\n    tauCaTH = tauX(V, 105.0, 89.8, 55.0, -16.9)\n    tauCaTH = tauCaTH * pow(q10_gCaT_h, -(temp - reftemp) / 10.0)\n    tauCaSM = spectau(V, 1.40, 7.00, 27.0, 10.0, 70.0, -13.0)\n    tauCaSM = tauCaSM * pow(q10_gCaS_m, -(temp - reftemp) / 10.0)\n    tauCaSH = spectau(V, 60.0, 150.0, 55.0, 9.00, 65.0, -16.0)\n    tauCaSH = tauCaSH * pow(q10_gCaS_h, -(temp - reftemp) / 10.0)\n    tauHM = tauX(V, 272.0, -1499.0, 42.2, -8.73)\n    tauHM = tauHM * pow(q10_gH_m, -(temp - reftemp) / 10.0)\n    tauKdM = tauX(V, 7.20, 6.40, 28.3, -19.2)\n    tauKdM = tauKdM * pow(q10_gKdr_m, -(temp - reftemp) / 10.0)\n    tauKCaM = tauX(V, 90.3, 75.1, 46.0, -22.7)\n    tauKCaM = tauKCaM * pow(q10_gKCa_m, -(temp - reftemp) / 10.0)\n    tauAM = tauX(V, 11.6, 10.4, 32.9, -15.2)\n    tauAM = tauAM * pow(q10_gA_m, -(temp - reftemp) / 10.0)\n    tauAH = tauX(V, 38.6, 29.2, 38.9, -26.5)\n    tauAH = tauAH * pow(q10_gA_h, -(temp - reftemp) / 10.0)\n\n    gNa = gNa * pow(q10_gNa, (temp - reftemp) / 10.0)\n    gCaT = gCaT * pow(q10_gCaT, (temp - reftemp) / 10.0)\n    gCaS = gCaS * pow(q10_gCaS, (temp - reftemp) / 10.0)\n    gA = gA * pow(q10_gA, (temp - reftemp) / 10.0)\n    gKCa = gKCa * pow(q10_gKCa, (temp - reftemp) / 10.0)\n    gKd = gKd * pow(q10_gKdr, (temp - reftemp) / 10.0)\n    gH = gH * pow(q10_gH, (temp - reftemp) / 10.0)\n    gL = gL * pow(q10_g_leak, (temp - reftemp) / 10.0)\n\n    tauIntCa = tauIntCa * pow(q10_tau_Ca, -(temp - reftemp) / 10.0)\n\n    # Ionic Currents (mV / ms)\n\n    iNa = iIonic(gNa, NaM, NaH, 3, V, ENa)\n    iCaT = iIonic(gCaT, CaTM, CaTH, 3, V, ECaT)\n    iCaS = iIonic(gCaS, CaSM, CaSH, 3, V, ECaS)\n    iH = iIonic(gH, HM, 1, 1, V, EH)\n    iKd = iIonic(gKd, KdM, 1, 4, V, EKd)\n    iKCa = iIonic(gKCa, KCaM, 1, 4, V, EKCa)\n    iA = iIonic(gA, AM, AH, 3, V, EA)\n    iL = iIonic(gL, 1, 1, 1, V, EL)\n\n    r = [iNa, iCaT, iCaS, iA, iKCa, iKd, iH, iL]\n    return r", ""]}
{"filename": "examples/original_paper_plot/__init__.py", "chunked_list": [""]}
{"filename": "examples/original_paper_plot/single_compartment.py", "chunked_list": ["\"\"\"Script taken from https://datadryad.org/stash/dataset/doi:10.5061/dryad.d0779mb\n    under the CC0 1.0 Universal (CC0 1.0) Public Domain Dedication license.\"\"\"\nimport numpy as np\n\n\ndef single_compartment(v, t, p, temp):\n\n    V = v[0]\n    NaM = v[1]\n    NaH = v[2]\n    CaTM = v[3]\n    CaTH = v[4]\n    CaSM = v[5]\n    CaSH = v[6]\n    HM = v[7]\n    KdM = v[8]\n    KCaM = v[9]\n    AM = v[10]\n    AH = v[11]\n    IntCa = v[12]\n    CaRev = CaNernst(IntCa, temp)\n\n    C = 1.0 * 10  #  // Capacitance (uF / cm^2)\n\n    #    // Ionic Currents (mV / ms)\n    #    // double caF = p.get(17);  // Current (nA) to Concentration (uM) Conversion Factor (uM / nA)\n    #    // double Ca0 = p.get(18);  // Background Intracellular Calcium Concentration (uM)\n    #    // these numbers below convert calcium current to calcium concentration and have not been measured so people change them.\n\n    caF = 0.94\n    Ca0 = 0.05\n    reftemp = 10\n\n    #     //activation timescale of imi appears to be constant (golowash92)\n\n    tauIntCa = p[35]  # // Calcium buffer time constant (ms)\n\n    #     // Equilibrium Points of Calcium Sensors\n    #     // p_g=[gNa, gCaT,gCaS,gA,gKCa,gKd,gH,g_leak]\n    #     // Fixed Maximal Conductances\n\n    gNa = p[0]  # // Transient Sodium Maximal Conductance\n    gCaT = p[1]  # // Low Threshold Calcium Maximal Conductance\n    gCaS = p[2]  # // Slow Calcium Maximal Conductance\n    gA = p[3]  # // Transient Potassium Maximal Conductance\n    gKCa = p[4]  # // Calcium Dependent Potassium Maximal Conductance\n    gKd = p[5]  # // Potassium Maximal Conductance\n    gH = p[6]  # // Hyperpolarization Activated Cation Maximal Conductance\n    gL = p[7]  # // Leak Maximal Conductance\n\n    EL = p[8]  #   // Leak Reversal Potential\n    ENa = p[9]  #  // Sodium Reversal Potential\n    ECaT = CaRev  #    // Low Threshold Calcium Reversal Potential\n    ECaS = CaRev  #   // Slow Calcium Reversal Potential\n\n    EKd = p[10]  #   // Potassium Reversal Potential\n    EKCa = p[10]  #  // Calcium Dependent Potassium Reversal Potential\n    EA = p[10]  #    // Transient Potassium Reversal Potential\n    EH = p[11]  #    // Hyperpolarization Activated Cation Reversal Potential\n\n    q10_gNa = p[12]\n    q10_gNa_m = p[13]\n    q10_gNa_h = p[14]\n\n    q10_gCaT = p[15]\n    q10_gCaT_m = p[16]\n    q10_gCaT_h = p[17]\n\n    q10_gCaS = p[18]\n    q10_gCaS_m = p[19]\n    q10_gCaS_h = p[20]\n\n    q10_gA = p[21]\n    q10_gA_m = p[22]\n    q10_gA_h = p[23]\n\n    q10_gKCa = p[24]\n    q10_gKCa_m = p[25]\n\n    q10_gKdr = p[27]\n    q10_gKdr_m = p[28]\n\n    q10_gH = p[30]\n    q10_gH_m = p[31]\n\n    q10_g_leak = p[33]\n    q10_tau_Ca = p[34]\n\n    #     Applied Current\n    Iapp = p[36]\n\n    #     Steady State Gating Variables\n    NaMinf = boltzSS(V, 25.5, -5.29)  # ;  // m^3\n    NaHinf = boltzSS(V, 48.9, 5.18)  # ;  // h\n    CaTMinf = boltzSS(V, 27.1, -7.20)  # ;  // m^3\n    CaTHinf = boltzSS(V, 32.1, 5.50)  # ;  // h\n    CaSMinf = boltzSS(V, 33.0, -8.1)  # ;  // m^3\n    CaSHinf = boltzSS(V, 60.0, 6.20)  # ;  // h\n    HMinf = boltzSS(V, 70.0, 6.0)  # ;  // m\n    KdMinf = boltzSS(V, 12.3, -11.8)  # ;  // m^4\n    KCaMinf = (IntCa / (IntCa + 3.0)) * boltzSS(V, 28.3, -12.6)  # ;  // m^4\n    AMinf = boltzSS(V, 27.2, -8.70)  # ;  // m^3\n    AHinf = boltzSS(V, 56.9, 4.90)  # ;  // h\n\n    # // Time Constants (ms)\n    tauNaM = tauX(V, 1.32, 1.26, 120.0, -25.0)\n    tauNaM = tauNaM * pow(q10_gNa_m, -(temp - reftemp) / 10.0)\n    tauNaH = tauX(V, 0.0, -0.67, 62.9, -10.0) * tauX(V, 1.50, -1.00, 34.9, 3.60)\n    tauNaH = tauNaH * pow(q10_gNa_h, -(temp - reftemp) / 10.0)\n    tauCaTM = tauX(V, 21.7, 21.3, 68.1, -20.5)\n    tauCaTM = tauCaTM * pow(q10_gCaT_m, -(temp - reftemp) / 10.0)\n    tauCaTH = tauX(V, 105.0, 89.8, 55.0, -16.9)\n    tauCaTH = tauCaTH * pow(q10_gCaT_h, -(temp - reftemp) / 10.0)\n    tauCaSM = spectau(V, 1.40, 7.00, 27.0, 10.0, 70.0, -13.0)\n    tauCaSM = tauCaSM * pow(q10_gCaS_m, -(temp - reftemp) / 10.0)\n    tauCaSH = spectau(V, 60.0, 150.0, 55.0, 9.00, 65.0, -16.0)\n    tauCaSH = tauCaSH * pow(q10_gCaS_h, -(temp - reftemp) / 10.0)\n    tauHM = tauX(V, 272.0, -1499.0, 42.2, -8.73)\n    tauHM = tauHM * pow(q10_gH_m, -(temp - reftemp) / 10.0)\n    tauKdM = tauX(V, 7.20, 6.40, 28.3, -19.2)\n    tauKdM = tauKdM * pow(q10_gKdr_m, -(temp - reftemp) / 10.0)\n    tauKCaM = tauX(V, 90.3, 75.1, 46.0, -22.7)\n    tauKCaM = tauKCaM * pow(q10_gKCa_m, -(temp - reftemp) / 10.0)\n    tauAM = tauX(V, 11.6, 10.4, 32.9, -15.2)\n    tauAM = tauAM * pow(q10_gA_m, -(temp - reftemp) / 10.0)\n    tauAH = tauX(V, 38.6, 29.2, 38.9, -26.5)\n    tauAH = tauAH * pow(q10_gA_h, -(temp - reftemp) / 10.0)\n\n    gNa = gNa * pow(q10_gNa, (temp - reftemp) / 10.0)\n    gCaT = gCaT * pow(q10_gCaT, (temp - reftemp) / 10.0)\n    gCaS = gCaS * pow(q10_gCaS, (temp - reftemp) / 10.0)\n    gA = gA * pow(q10_gA, (temp - reftemp) / 10.0)\n    gKCa = gKCa * pow(q10_gKCa, (temp - reftemp) / 10.0)\n    gH = gH * pow(q10_gH, (temp - reftemp) / 10.0)\n    gKd = gKd * pow(q10_gKdr, (temp - reftemp) / 10.0)\n    gL = gL * pow(q10_g_leak, (temp - reftemp) / 10.0)\n\n    tauIntCa = tauIntCa * pow(q10_tau_Ca, -(temp - reftemp) / 10.0)\n\n    iNa = iIonic(gNa, NaM, NaH, 3, V, ENa)\n    iCaT = iIonic(gCaT, CaTM, CaTH, 3, V, ECaT)\n    iCaS = iIonic(gCaS, CaSM, CaSH, 3, V, ECaS)\n    iH = iIonic(gH, HM, 1, 1, V, EH)\n    iKd = iIonic(gKd, KdM, 1, 4, V, EKd)\n    iKCa = iIonic(gKCa, KCaM, 1, 4, V, EKCa)\n    iA = iIonic(gA, AM, AH, 3, V, EA)\n    iL = iIonic(gL, 1, 1, 1, V, EL)\n\n    #    // State Equations\n    #    // Voltage Time Evolution: C*dV/dt = -I_ionic + I_applied; I_ionic = sum(g_i*m^q*h*(V - E_i))\n    # // double dV = (-(iNa + iCaT + iCaS + iH + iKd + iKCa + iA + iL) + iSyns + Iapp)/C;\n    # // double intrinsic_currents = iNa + iCaT + iCaS + iH + iKd + iKCa + iA + iL;\n    # // cout << intrinsic_currents <<endl;\n    dV = (-(iNa + iCaT + iCaS + iH + iKd + iKCa + iA + iL) + Iapp) / C\n\n    # // Gating Variable Time Evolution: dX/dt = (X_inf - X)/tau_X\n    dNaM = (NaMinf - NaM) / tauNaM\n    dNaH = (NaHinf - NaH) / tauNaH\n    dCaTM = (CaTMinf - CaTM) / tauCaTM\n    dCaTH = (CaTHinf - CaTH) / tauCaTH\n    dCaSM = (CaSMinf - CaSM) / tauCaSM\n    dCaSH = (CaSHinf - CaSH) / tauCaSH\n    dHM = (HMinf - HM) / tauHM\n    dKdM = (KdMinf - KdM) / tauKdM\n    dKCaM = (KCaMinf - KCaM) / tauKCaM\n    dAM = (AMinf - AM) / tauAM\n    dAH = (AHinf - AH) / tauAH\n\n    dIntCa = (-caF * (iCaT + iCaS) - IntCa + Ca0) / tauIntCa\n    y_dot = np.zeros(13)\n    y_dot[0] = dV\n    y_dot[1] = dNaM\n    y_dot[2] = dNaH\n    y_dot[3] = dCaTM\n    y_dot[4] = dCaTH\n    y_dot[5] = dCaSM\n    y_dot[6] = dCaSH\n    y_dot[7] = dHM\n    y_dot[8] = dKdM\n    y_dot[9] = dKCaM\n    y_dot[10] = dAM\n    y_dot[11] = dAH\n    y_dot[12] = dIntCa\n    return y_dot", "\n\ndef boltzSS(Volt, A, B):\n    act = 1.0 / (1.0 + np.exp((Volt + A) / B))\n    return act\n\n\n# // Time constants of activation-inactivation\ndef tauX(Volt, CT, DT, AT, BT):\n    timeconst = CT - DT / (1.0 + np.exp((Volt + AT) / BT))\n    return timeconst", "def tauX(Volt, CT, DT, AT, BT):\n    timeconst = CT - DT / (1.0 + np.exp((Volt + AT) / BT))\n    return timeconst\n\n\n# // Some currents require a special time constant function\ndef spectau(Volt, CT, DT, AT, BT, AT2, BT2):\n    spec = CT + DT / (np.exp((Volt + AT) / BT) + np.exp((Volt + AT2) / BT2))\n    return spec\n", "\n\ndef iIonic(g, m, h, q, Volt, Erev):\n    flux = g * pow(m, q) * h * (Volt - Erev)\n    return flux\n\n\n# // Concentration dependent Ca reversal potential\ndef CaNernst(CaIn, temp):\n    R = 8.314 * pow(10, 3)  # Ideal Gas Constant (*10^3 to put into mV)\n    T = 273.15 + temp  # Temperature in Kelvin\n    z = 2.0  # Valence of Calcium Ions\n    Far = 96485.33  # Faraday's Constant\n    CaOut = 3000.0  # Outer Ca Concentration (uM)\n    CalRev = ((R * T) / (z * Far)) * np.log10(CaOut / CaIn)\n    return CalRev", "def CaNernst(CaIn, temp):\n    R = 8.314 * pow(10, 3)  # Ideal Gas Constant (*10^3 to put into mV)\n    T = 273.15 + temp  # Temperature in Kelvin\n    z = 2.0  # Valence of Calcium Ions\n    Far = 96485.33  # Faraday's Constant\n    CaOut = 3000.0  # Outer Ca Concentration (uM)\n    CalRev = ((R * T) / (z * Far)) * np.log10(CaOut / CaIn)\n    return CalRev\n", ""]}
