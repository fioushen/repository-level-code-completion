{"filename": "Home.py", "chunked_list": ["from gptravel.prototype.pages import home as home_page\nimport streamlit as st\n\nst.set_page_config(page_title=\"GPTravel\", page_icon=\"\u2708\ufe0f\")\n\nif __name__ == \"__main__\":\n    home_page.main()"]}
{"filename": "prototype.py", "chunked_list": ["from gptravel.prototype.pages import home as home_page\nimport streamlit as st\n\nst.set_page_config(page_title=\"GPTravel\", page_icon=\"\u2708\ufe0f\")\n\nif __name__ == \"__main__\":\n    home_page.main()"]}
{"filename": "pages/About.py", "chunked_list": ["import streamlit as st\n\nst.set_page_config(page_title=\"GPTravel\", page_icon=\"\u2708\ufe0f\")\n\nst.title(\"About\")\n\nst.markdown(\"\"\"\nGPTravel is a Web App that generates a travel plan based on Large-Language Models (LLMs). It helps users create personalized itineraries giving the best destinations, activities, and routes.\n\nThis is a simple web app that uses the power of Large Language Models to help you plan your next trip. By leveraging the GPT API, the app generates a personalized itinerary for your trip based on your destination.", "\nThis is a simple web app that uses the power of Large Language Models to help you plan your next trip. By leveraging the GPT API, the app generates a personalized itinerary for your trip based on your destination.\nTo use the app, simply fill out the form on the Home page with your travel details and let GPT do the rest. You'll receive a customized travel plan that includes recommended destinations, activities, accommodations, and other useful information.\nWhether you're an experienced traveler or just looking for some inspiration, this app is a fun and easy way to explore new places and ideas. So why not give it a try and see where your next journey takes you?\n\n### Code Repository\nThe code for this web app is available on GitHub. You can find it [here](https://github.com/RobertoCorti/gptravel). Feel free to explore the code, contribute, and provide feedback.\n\n### Authors\n- Roberto Corti [![LinkedIn](https://img.shields.io/badge/LinkedIn-Connect-blue?logo=linkedin)](https://www.linkedin.com/in/roberto-corti-723346181/) [![GitHub](https://img.shields.io/badge/GitHub-Follow-black?logo=github)](https://github.com/robertocorti)", "### Authors\n- Roberto Corti [![LinkedIn](https://img.shields.io/badge/LinkedIn-Connect-blue?logo=linkedin)](https://www.linkedin.com/in/roberto-corti-723346181/) [![GitHub](https://img.shields.io/badge/GitHub-Follow-black?logo=github)](https://github.com/robertocorti)\n  \n- Stefano Polo [![LinkedIn](https://img.shields.io/badge/LinkedIn-Connect-blue?logo=linkedin)](https://www.linkedin.com/in/stefanopolo) [![GitHub](https://img.shields.io/badge/GitHub-Follow-black?logo=github)](https://github.com/stefano-polo)\n\n\n\"\"\", unsafe_allow_html=True)\n"]}
{"filename": "tests/conftest.py", "chunked_list": ["from typing import Any, Dict, List\n\nimport pytest\n\nfrom gptravel.core.travel_planner.prompt import PromptFactory\nfrom gptravel.core.travel_planner.travel_engine import TravelPlanJSON\n\n\n@pytest.fixture\ndef travel_plan_single_city_per_day() -> TravelPlanJSON:\n    json_travel_plan = TravelPlanJSON(\n        destination_place=\"Thailand\",\n        departure_place=\"Milan\",\n        n_days=3,\n        json_keys_depth_map={\"day\": 0, \"city\": 1},\n        travel_plan_json={\n            \"Day 1\": {\n                \"Bangkok\": [\n                    \"Visit Wat Phra Kaew and the Grand Palace\",\n                    \"Explore the Wat Pho Temple\",\n                    \"Ride a boat in the Chao Phraya River\",\n                    \"Shop at Chatuchak weekend market\",\n                ]\n            },\n            \"Day 2\": {\n                \"Phuket\": [\n                    \"Spend time at the Patong Beach\",\n                    \"Visit Big Buddha Phuket\",\n                    \"Explore the Phuket Old Town\",\n                    \"Enjoy local street food at night markets\",\n                ]\n            },\n            \"Day 3\": {\n                \"Krabi\": [\n                    \"Visit Railay Beach and the Phra Nang Cave\",\n                    \"Island hopping tour to Phi Phi Islands\",\n                    \"Hike to the Tiger Cave Temple\",\n                    \"Relax at Ao Nang Beach\",\n                ]\n            },\n        },\n    )\n    return json_travel_plan", "@pytest.fixture\ndef travel_plan_single_city_per_day() -> TravelPlanJSON:\n    json_travel_plan = TravelPlanJSON(\n        destination_place=\"Thailand\",\n        departure_place=\"Milan\",\n        n_days=3,\n        json_keys_depth_map={\"day\": 0, \"city\": 1},\n        travel_plan_json={\n            \"Day 1\": {\n                \"Bangkok\": [\n                    \"Visit Wat Phra Kaew and the Grand Palace\",\n                    \"Explore the Wat Pho Temple\",\n                    \"Ride a boat in the Chao Phraya River\",\n                    \"Shop at Chatuchak weekend market\",\n                ]\n            },\n            \"Day 2\": {\n                \"Phuket\": [\n                    \"Spend time at the Patong Beach\",\n                    \"Visit Big Buddha Phuket\",\n                    \"Explore the Phuket Old Town\",\n                    \"Enjoy local street food at night markets\",\n                ]\n            },\n            \"Day 3\": {\n                \"Krabi\": [\n                    \"Visit Railay Beach and the Phra Nang Cave\",\n                    \"Island hopping tour to Phi Phi Islands\",\n                    \"Hike to the Tiger Cave Temple\",\n                    \"Relax at Ao Nang Beach\",\n                ]\n            },\n        },\n    )\n    return json_travel_plan", "\n\n@pytest.fixture\ndef travel_plan_multiple_city_per_day_and_wrong_n_days() -> TravelPlanJSON:\n    json_travel_plan = TravelPlanJSON(\n        departure_place=\"Milan\",\n        destination_place=\"Thailand\",\n        n_days=3,\n        json_keys_depth_map={\"day\": 0, \"city\": 1},\n        travel_plan_json={\n            \"Day 1\": {\n                \"Bangkok\": [\n                    \"Visit Wat Phra Kaew and the Grand Palace\",\n                    \"Explore the Wat Pho Temple\",\n                    \"Ride a boat in the Chao Phraya River\",\n                    \"Shop at Chatuchak weekend market\",\n                ],\n                \"Phuket\": [\n                    \"Spend time at the Patong Beach\",\n                    \"Visit Big Buddha Phuket\",\n                    \"Explore the Phuket Old Town\",\n                    \"Enjoy local street food at night markets\",\n                ],\n            },\n            \"Day 2\": {\n                \"Krabi\": [\n                    \"Visit Railay Beach and the Phra Nang Cave\",\n                    \"Island hopping tour to Phi Phi Islands\",\n                    \"Hike to the Tiger Cave Temple\",\n                    \"Relax at Ao Nang Beach\",\n                ]\n            },\n        },\n    )\n    return json_travel_plan", "\n\n@pytest.fixture\ndef travel_plan_multiple_city_per_day_and_wrong_city_per_country() -> TravelPlanJSON:\n    json_travel_plan = TravelPlanJSON(\n        departure_place=\"Milan\",\n        destination_place=\"Thailand\",\n        n_days=2,\n        json_keys_depth_map={\"day\": 0, \"city\": 1},\n        travel_plan_json={\n            \"Day 1\": {\n                \"Bangkok\": [\n                    \"Visit Wat Phra Kaew and the Grand Palace\",\n                    \"Explore the Wat Pho Temple\",\n                    \"Ride a boat in the Chao Phraya River\",\n                    \"Shop at Chatuchak weekend market\",\n                ],\n                \"Milan\": [\n                    \"Spend time at the Patong Beach\",\n                    \"Visit Big Buddha Phuket\",\n                    \"Explore the Phuket Old Town\",\n                    \"Enjoy local street food at night markets\",\n                ],\n            },\n            \"Day 2\": {\n                \"Krabi\": [\n                    \"Visit Railay Beach and the Phra Nang Cave\",\n                    \"Island hopping tour to Phi Phi Islands\",\n                    \"Hike to the Tiger Cave Temple\",\n                    \"Relax at Ao Nang Beach\",\n                ]\n            },\n        },\n    )\n    return json_travel_plan", "\n\n@pytest.fixture\ndef travel_plan_fake_city() -> TravelPlanJSON:\n    json_travel_plan = TravelPlanJSON(\n        departure_place=\"Milan\",\n        destination_place=\"Thailand\",\n        n_days=2,\n        json_keys_depth_map={\"day\": 0, \"city\": 1},\n        travel_plan_json={\n            \"Day 1\": {\n                \"Bangkok\": [\n                    \"Visit Wat Phra Kaew and the Grand Palace\",\n                    \"Explore the Wat Pho Temple\",\n                    \"Ride a boat in the Chao Phraya River\",\n                    \"Shop at Chatuchak weekend market\",\n                ],\n                \"ChromeCastFrancesco\": [\n                    \"Spend time at the Patong Beach\",\n                    \"Visit Big Buddha Phuket\",\n                    \"Explore the Phuket Old Town\",\n                    \"Enjoy local street food at night markets\",\n                ],\n            },\n            \"Day 2\": {\n                \"Krabi\": [\n                    \"Visit Railay Beach and the Phra Nang Cave\",\n                    \"Island hopping tour to Phi Phi Islands\",\n                    \"Hike to the Tiger Cave Temple\",\n                    \"Relax at Ao Nang Beach\",\n                ]\n            },\n        },\n    )\n    return json_travel_plan", "\n\n@pytest.fixture\ndef italian_travel_plan() -> TravelPlanJSON:\n    return TravelPlanJSON(\n        destination_place=\"Italy\",\n        departure_place=\"Paris\",\n        n_days=4,\n        travel_plan_json={\n            \"Day 1\": {\n                \"Paris\": [\n                    \"Take flight to Venice\",\n                ]\n            },\n            \"Day 2\": {\n                \"Venice\": [\n                    \"See San Marco\",\n                ]\n            },\n            \"Day 3\": {\n                \"Venice\": [\n                    \"Take a ride on gondola\",\n                ],\n                \"Palermo\": [\"Eat an arancina\"],\n            },\n            \"Day 4\": {\"Florence\": [\"Eat fiorentina\"], \"Paris\": [\"Return back home\"]},\n        },\n        json_keys_depth_map={\"city\": 1, \"day\": 0},\n    )", "\n\n@pytest.fixture\ndef travel_properties() -> Dict[str, Any]:\n    return {\n        \"departure_place\": \"Milan\",\n        \"destination_place\": \"Thailand\",\n        \"n_travel_days\": 10,\n    }\n", "\n\n@pytest.fixture\ndef prompt_factory() -> PromptFactory:\n    return PromptFactory()\n\n\n@pytest.fixture()\ndef labels_activities() -> List[str]:\n    return [\n        \"mountain\",\n        \"sea\",\n        \"museum\",\n        \"monument\",\n        \"food\",\n        \"relax\",\n        \"sport\",\n        \"culture\",\n        \"shopping\",\n        \"transport\",\n    ]", "def labels_activities() -> List[str]:\n    return [\n        \"mountain\",\n        \"sea\",\n        \"museum\",\n        \"monument\",\n        \"food\",\n        \"relax\",\n        \"sport\",\n        \"culture\",\n        \"shopping\",\n        \"transport\",\n    ]", ""]}
{"filename": "tests/test_gptravel/test_app_streamlit/test_pages/test_home.py", "chunked_list": ["import datetime\nimport os\n\nimport dotenv\nimport pytest\n\nfrom gptravel.prototype.pages import home\n\ndotenv.load_dotenv()\n", "dotenv.load_dotenv()\n\n\n@pytest.fixture\ndef departure_date():\n    return datetime.datetime(2023, 6, 15)\n\n\n@pytest.fixture\ndef return_date():\n    return datetime.datetime(2023, 6, 20)", "@pytest.fixture\ndef return_date():\n    return datetime.datetime(2023, 6, 20)\n\n\n@pytest.fixture\ndef openai_key():\n    return os.environ.get(\"OPENAI_API_KEY\")\n\n", "\n\n@pytest.fixture\ndef departure_place():\n    return \"Milan\"\n\n\n@pytest.fixture\ndef destination_place():\n    return \"New York\"", "def destination_place():\n    return \"New York\"\n\n\n@pytest.mark.parametrize(\n    \"departure, destination\",\n    [\n        (\"Milan\", \"India\"),\n        (\"New York\", \"Italy\"),\n        (\"Japan\", \"United States\"),", "        (\"New York\", \"Italy\"),\n        (\"Japan\", \"United States\"),\n    ],\n)\ndef test_is_valid_input_correct(\n    departure, destination, departure_date, return_date, openai_key\n):\n    assert home._is_valid_input(\n        departure=departure,\n        destination=destination,\n        departure_date=departure_date,\n        return_date=return_date,\n        openai_key=openai_key,\n    )", "\n\ndef test_is_valid_input_wrong_dates(departure_place, destination_place, openai_key):\n    departure_date = datetime.date(2023, 1, 1)\n    return_date = datetime.date(2022, 11, 1)\n\n    assert not home._is_valid_input(\n        departure=departure_place,\n        destination=destination_place,\n        departure_date=departure_date,\n        return_date=return_date,\n        openai_key=openai_key,\n    )", "\n\n@pytest.mark.parametrize(\n    \"departure, destination\",\n    [\n        (\"Milan\", \"Pippo\"),\n        (\"New York\", \"Pluto\"),\n    ],\n)\ndef test_is_valid_input_wrong_places(\n    departure, destination, departure_date, return_date, openai_key\n):\n    assert not home._is_valid_input(\n        departure=departure,\n        destination=destination,\n        departure_date=departure_date,\n        return_date=return_date,\n        openai_key=openai_key,\n    )", ")\ndef test_is_valid_input_wrong_places(\n    departure, destination, departure_date, return_date, openai_key\n):\n    assert not home._is_valid_input(\n        departure=departure,\n        destination=destination,\n        departure_date=departure_date,\n        return_date=return_date,\n        openai_key=openai_key,\n    )", "\n\ndef test_is_valid_input_wrong_openai_key(\n    departure_place, destination_place, departure_date, return_date, openai_key\n):\n    assert not home._is_valid_input(\n        departure=departure_place,\n        destination=destination_place,\n        departure_date=departure_date,\n        return_date=return_date,\n        openai_key=\"a\",\n    )", ""]}
{"filename": "tests/test_gptravel/test_app_streamlit/test_utils/test_general_streamlit_utils.py", "chunked_list": ["import datetime\nimport os\nfrom typing import List\n\nimport openai\nimport pytest\n\nfrom gptravel.core.travel_planner.travel_engine import TravelPlanJSON\nfrom gptravel.prototype.utils import (\n    get_cities_coordinates_of_same_country_destionation,", "from gptravel.prototype.utils import (\n    get_cities_coordinates_of_same_country_destionation,\n    get_score_map,\n    is_departure_before_return,\n    is_valid_openai_key,\n)\n\n\ndef test_is_valid_openai_key():\n    from dotenv import load_dotenv\n\n    load_dotenv()\n    valid_key = os.environ.get(\"OPENAI_API_KEY\")\n    invalid_key = \"pippo\"\n\n    openai.api_key = valid_key\n    assert is_valid_openai_key(valid_key) == True\n\n    openai.api_key = invalid_key\n    assert is_valid_openai_key(invalid_key) == False", "def test_is_valid_openai_key():\n    from dotenv import load_dotenv\n\n    load_dotenv()\n    valid_key = os.environ.get(\"OPENAI_API_KEY\")\n    invalid_key = \"pippo\"\n\n    openai.api_key = valid_key\n    assert is_valid_openai_key(valid_key) == True\n\n    openai.api_key = invalid_key\n    assert is_valid_openai_key(invalid_key) == False", "\n\n@pytest.mark.parametrize(\n    \"departure_date, return_date, expected_result\",\n    [\n        (datetime.date(2023, 6, 1), datetime.date(2023, 6, 2), True),\n        (datetime.date(2023, 6, 3), datetime.date(2023, 6, 2), False),\n        (datetime.date(2023, 6, 2), datetime.date(2023, 6, 2), True),\n        (datetime.date(2023, 5, 31), datetime.date(2023, 6, 2), True),\n    ],", "        (datetime.date(2023, 5, 31), datetime.date(2023, 6, 2), True),\n    ],\n)\ndef test_is_departure_before_return(departure_date, return_date, expected_result):\n    assert is_departure_before_return(departure_date, return_date) == expected_result\n\n\n@pytest.mark.parametrize(\n    \"cities, destination, expected_coordinates\",\n    [", "    \"cities, destination, expected_coordinates\",\n    [\n        (\n            [\"New York\", \"Los Angeles\"],\n            \"United States\",\n            {\n                \"New York\": (40.7127281, -74.0060152),\n                \"Los Angeles\": (34.0536909, -118.242766),\n            },\n        ),", "            },\n        ),\n        (\n            [\"London\"],\n            \"London\",\n            {\n                \"London\": (51.5073359, -0.12765),\n            },\n        ),\n        (", "        ),\n        (\n            [\"London\", \"Manchester\"],\n            \"United Kingdom\",\n            {\"London\": (51.5073359, -0.12765), \"Manchester\": (53.4794892, -2.2451148)},\n        ),\n        ([\"Paris\", \"Rome\"], \"France\", {\"Paris\": (48.8588897, 2.3200410217200766)}),\n    ],\n)\ndef test_get_cities_coordinates(cities, destination, expected_coordinates):\n    coordinates_cities_dict = get_cities_coordinates_of_same_country_destionation(\n        cities, destination\n    )\n    for city, coordinates in coordinates_cities_dict.items():\n        assert coordinates[0] == pytest.approx(expected_coordinates[city][0], abs=0.1)\n        assert coordinates[1] == pytest.approx(expected_coordinates[city][1], abs=0.1)", ")\ndef test_get_cities_coordinates(cities, destination, expected_coordinates):\n    coordinates_cities_dict = get_cities_coordinates_of_same_country_destionation(\n        cities, destination\n    )\n    for city, coordinates in coordinates_cities_dict.items():\n        assert coordinates[0] == pytest.approx(expected_coordinates[city][0], abs=0.1)\n        assert coordinates[1] == pytest.approx(expected_coordinates[city][1], abs=0.1)\n\n\ndef test_get_score_map_on_travel_plan(\n    travel_plan_single_city_per_day: TravelPlanJSON, labels_activities: List[str]\n):\n    score_map = get_score_map(travel_plan_single_city_per_day).score_map\n\n    assert isinstance(score_map, dict)\n    assert \"Activities Variety\" in set(score_map.keys())\n\n    assert set(score_map[\"Activities Variety\"].keys()) == {\n        \"score_value\",\n        \"score_weight\",\n        \"activities_distribution\",\n        \"labeled_activities\",\n    }\n\n    assert isinstance(score_map[\"Activities Variety\"][\"score_value\"], float)\n    assert 0 <= score_map[\"Activities Variety\"][\"score_value\"] <= 1\n\n    assert isinstance(score_map[\"Activities Variety\"][\"score_weight\"], float)\n    assert 0 <= score_map[\"Activities Variety\"][\"score_weight\"] <= 1\n\n    assert isinstance(score_map[\"Activities Variety\"][\"activities_distribution\"], dict)\n\n    assert set(\n        score_map[\"Activities Variety\"][\"activities_distribution\"].keys()\n    ) == set(labels_activities)\n    for key in score_map[\"Activities Variety\"][\"activities_distribution\"].keys():\n        assert isinstance(\n            score_map[\"Activities Variety\"][\"activities_distribution\"][key], float\n        )\n        assert 0 <= score_map[\"Activities Variety\"][\"activities_distribution\"][key] <= 1\n\n    assert isinstance(score_map[\"Activities Variety\"][\"labeled_activities\"], dict)\n    assert set(score_map[\"Activities Variety\"][\"labeled_activities\"].keys()) == set(\n        travel_plan_single_city_per_day.travel_activities\n    )\n\n    for key in score_map[\"Activities Variety\"][\"labeled_activities\"].keys():\n        assert isinstance(\n            score_map[\"Activities Variety\"][\"labeled_activities\"][key], dict\n        )\n        assert set(\n            score_map[\"Activities Variety\"][\"labeled_activities\"][key].keys()\n        ) == set(labels_activities)\n        assert all(\n            isinstance(\n                score_map[\"Activities Variety\"][\"labeled_activities\"][key][label], float\n            )\n            for label in labels_activities\n        )\n        assert all(\n            0 <= score_map[\"Activities Variety\"][\"labeled_activities\"][key][label] <= 1\n            for label in labels_activities\n        )", "\n\ndef test_get_score_map_on_travel_plan(\n    travel_plan_single_city_per_day: TravelPlanJSON, labels_activities: List[str]\n):\n    score_map = get_score_map(travel_plan_single_city_per_day).score_map\n\n    assert isinstance(score_map, dict)\n    assert \"Activities Variety\" in set(score_map.keys())\n\n    assert set(score_map[\"Activities Variety\"].keys()) == {\n        \"score_value\",\n        \"score_weight\",\n        \"activities_distribution\",\n        \"labeled_activities\",\n    }\n\n    assert isinstance(score_map[\"Activities Variety\"][\"score_value\"], float)\n    assert 0 <= score_map[\"Activities Variety\"][\"score_value\"] <= 1\n\n    assert isinstance(score_map[\"Activities Variety\"][\"score_weight\"], float)\n    assert 0 <= score_map[\"Activities Variety\"][\"score_weight\"] <= 1\n\n    assert isinstance(score_map[\"Activities Variety\"][\"activities_distribution\"], dict)\n\n    assert set(\n        score_map[\"Activities Variety\"][\"activities_distribution\"].keys()\n    ) == set(labels_activities)\n    for key in score_map[\"Activities Variety\"][\"activities_distribution\"].keys():\n        assert isinstance(\n            score_map[\"Activities Variety\"][\"activities_distribution\"][key], float\n        )\n        assert 0 <= score_map[\"Activities Variety\"][\"activities_distribution\"][key] <= 1\n\n    assert isinstance(score_map[\"Activities Variety\"][\"labeled_activities\"], dict)\n    assert set(score_map[\"Activities Variety\"][\"labeled_activities\"].keys()) == set(\n        travel_plan_single_city_per_day.travel_activities\n    )\n\n    for key in score_map[\"Activities Variety\"][\"labeled_activities\"].keys():\n        assert isinstance(\n            score_map[\"Activities Variety\"][\"labeled_activities\"][key], dict\n        )\n        assert set(\n            score_map[\"Activities Variety\"][\"labeled_activities\"][key].keys()\n        ) == set(labels_activities)\n        assert all(\n            isinstance(\n                score_map[\"Activities Variety\"][\"labeled_activities\"][key][label], float\n            )\n            for label in labels_activities\n        )\n        assert all(\n            0 <= score_map[\"Activities Variety\"][\"labeled_activities\"][key][label] <= 1\n            for label in labels_activities\n        )", ""]}
{"filename": "tests/test_gptravel/test_core/test_utils/test_regex_tool.py", "chunked_list": ["import json\nfrom inspect import cleandoc\n\nfrom gptravel.core.utils.regex_tool import JsonExtractor\n\n\nclass TestJsonExtractor:\n    def test_simple_json(self, extractor: JsonExtractor):\n        text = '{\"name\": \"John\", \"age\": 30}'\n        expected_output = [text]\n        assert json.loads(extractor(text)[0]) == json.loads(expected_output[0])\n\n    def test_nested_json(self, extractor):\n        text = '{\"name\": \"John\", \"age\": 30, \"address\": {\"street\": \"123 Main St\", \"city\": \"Anytown USA\"}}'\n        expected_output = [text, '{\"street\": \"123 Main St\", \"city\": \"Anytown USA\"}']\n        assert json.loads(extractor(text)[0]) == json.loads(expected_output[0])\n\n    def test_no_json(self, extractor):\n        text = \"This is not a JSON string\"\n        expected_output = []\n        assert extractor(text) == expected_output\n\n    def test_output_gpt(self, extractor):\n        text_gpt = cleandoc(\n            \"\"\"Sure! Here a json\n                      {\n                        \"Day 1\": {\n                            \"Bangkok\": [\n                            \"Visit Grand Palace\",\n                            \"Take a boat trip along the Chao Phraya River\",\n                            \"Shop at Chatuchak Weekend Market\"\n                            ]\n                        },\n                        \"Day 2\": {\n                            \"Chiang Mai\": [\n                            \"Explore Doi Suthep temple\",\n                            \"Experience the traditional Thai massage\",\n                            \"Visit Elephant Nature Park\"\n                            ]\n                        },\n                        \"Day 3\": {\n                            \"Phuket\": [\n                            \"Relax on the beautiful beaches of Phuket\",\n                            \"Take a speedboat cruise to visit Koh Phi Phi\",\n                            \"Watch the sunset at Promthep Cape\"\n                            ]\n                        }\n                        }\n\n                        Note: Keep in mind that this is just a sample travel plan and activities can be customized according to individual preferences.\"\"\"\n        )\n        expected_output = '{\\n\"Day 1\": {\\n    \"Bangkok\": [\\n    \"Visit Grand Palace\",\\n    \"Take a boat trip along the Chao Phraya River\",\\n    \"Shop at Chatuchak Weekend Market\"\\n    ]\\n},\\n\"Day 2\": {\\n    \"Chiang Mai\": [\\n    \"Explore Doi Suthep temple\",\\n    \"Experience the traditional Thai massage\",\\n    \"Visit Elephant Nature Park\"\\n    ]\\n},\\n\"Day 3\": {\\n    \"Phuket\": [\\n    \"Relax on the beautiful beaches of Phuket\",\\n    \"Take a speedboat cruise to visit Koh Phi Phi\",\\n    \"Watch the sunset at Promthep Cape\"\\n    ]\\n}\\n}'\n        assert json.loads(extractor(text_gpt)[0]) == json.loads(expected_output)", ""]}
{"filename": "tests/test_gptravel/test_core/test_utils/test_general.py", "chunked_list": ["import json\n\nfrom gptravel.core.utils.general import (\n    extract_inner_lists_from_json,\n    extract_keys_by_depth_from_json,\n)\n\n\ndef test_extract_keys_by_depth():\n    json_str = '{\"a\": {\"b\": {\"c\": 1, \"d\": 2}, \"e\": 3}, \"f\": {\"g\": {\"h\": {\"i\": 4}}}}'\n    json_obj = json.loads(json_str)\n\n    assert extract_keys_by_depth_from_json(json_obj, 0) == [\"a\", \"f\"]\n    assert extract_keys_by_depth_from_json(json_obj, 1) == [\"b\", \"e\", \"g\"]\n    assert extract_keys_by_depth_from_json(json_obj, 2) == [\"c\", \"d\", \"h\"]\n    assert extract_keys_by_depth_from_json(json_obj, 3) == [\"i\"]\n\n    json_str = '{\"a\": {\"b\": {\"c\": {\"d\": {\"e\": {\"f\": {\"g\": 1}}}}}}}'\n    json_obj = json.loads(json_str)\n\n    assert extract_keys_by_depth_from_json(json_obj, 0) == [\"a\"]\n    assert extract_keys_by_depth_from_json(json_obj, 1) == [\"b\"]\n    assert extract_keys_by_depth_from_json(json_obj, 2) == [\"c\"]\n    assert extract_keys_by_depth_from_json(json_obj, 3) == [\"d\"]\n    assert extract_keys_by_depth_from_json(json_obj, 4) == [\"e\"]\n    assert extract_keys_by_depth_from_json(json_obj, 5) == [\"f\"]\n    assert extract_keys_by_depth_from_json(json_obj, 6) == [\"g\"]\n\n    json_str = '{\"a\": 1, \"b\": 2, \"c\": 3}'\n    json_obj = json.loads(json_str)\n\n    assert extract_keys_by_depth_from_json(json_obj, 0) == [\"a\", \"b\", \"c\"]\n    assert not extract_keys_by_depth_from_json(json_obj, 1)", "def test_extract_keys_by_depth():\n    json_str = '{\"a\": {\"b\": {\"c\": 1, \"d\": 2}, \"e\": 3}, \"f\": {\"g\": {\"h\": {\"i\": 4}}}}'\n    json_obj = json.loads(json_str)\n\n    assert extract_keys_by_depth_from_json(json_obj, 0) == [\"a\", \"f\"]\n    assert extract_keys_by_depth_from_json(json_obj, 1) == [\"b\", \"e\", \"g\"]\n    assert extract_keys_by_depth_from_json(json_obj, 2) == [\"c\", \"d\", \"h\"]\n    assert extract_keys_by_depth_from_json(json_obj, 3) == [\"i\"]\n\n    json_str = '{\"a\": {\"b\": {\"c\": {\"d\": {\"e\": {\"f\": {\"g\": 1}}}}}}}'\n    json_obj = json.loads(json_str)\n\n    assert extract_keys_by_depth_from_json(json_obj, 0) == [\"a\"]\n    assert extract_keys_by_depth_from_json(json_obj, 1) == [\"b\"]\n    assert extract_keys_by_depth_from_json(json_obj, 2) == [\"c\"]\n    assert extract_keys_by_depth_from_json(json_obj, 3) == [\"d\"]\n    assert extract_keys_by_depth_from_json(json_obj, 4) == [\"e\"]\n    assert extract_keys_by_depth_from_json(json_obj, 5) == [\"f\"]\n    assert extract_keys_by_depth_from_json(json_obj, 6) == [\"g\"]\n\n    json_str = '{\"a\": 1, \"b\": 2, \"c\": 3}'\n    json_obj = json.loads(json_str)\n\n    assert extract_keys_by_depth_from_json(json_obj, 0) == [\"a\", \"b\", \"c\"]\n    assert not extract_keys_by_depth_from_json(json_obj, 1)", "\n\ndef test_extract_inner_lists_from_json():\n    # Simple example with only one level of nesting\n    data = {\n        \"Day 1\": {\n            \"City 1\": [\"activity 1\", \"activity 2\"],\n            \"City 2\": [\"activity 3\", \"activity 4\"],\n        }\n    }\n    assert extract_inner_lists_from_json(data) == [\n        \"activity 1\",\n        \"activity 2\",\n        \"activity 3\",\n        \"activity 4\",\n    ]", "\n\ndef test_extract_inner_lists_more_depth():\n    # Simple example with only one level of nesting\n    data = {\n        \"Day 1\": {\n            \"City 1\": {\"feet\": [\"activity 1\", \"activity 2\"]},\n            \"City 2\": {\"moto\": [\"activity 3\", \"activity 4\"]},\n        },\n        \"Day 2\": {\n            \"City 1\": {\"car\": [\"activity 5\", \"activity 6\"]},\n            \"City 2\": {\"boat\": [\"activity 7\", \"activity 8\"]},\n        },\n    }\n    assert extract_inner_lists_from_json(data) == [\n        \"activity 1\",\n        \"activity 2\",\n        \"activity 3\",\n        \"activity 4\",\n        \"activity 5\",\n        \"activity 6\",\n        \"activity 7\",\n        \"activity 8\",\n    ]", "\n\ndef test_extract_inner_list_nested():\n    # Example with nested dictionaries and lists\n    data = {\n        \"Day 1\": {\n            \"City 1\": [\"activity 1\", \"activity 2\"],\n            \"City 2\": [\"activity 3\", \"activity 4\"],\n        },\n        \"Day 2\": {\n            \"City 3\": [\"activity 5\", \"activity 6\"],\n            \"City 4\": [\n                {\"Subcity 1\": [\"activity 7\", \"activity 8\"]},\n                {\"Subcity 2\": [\"activity 9\", \"activity 10\"]},\n            ],\n        },\n    }\n    assert extract_inner_lists_from_json(data) == [\n        \"activity 1\",\n        \"activity 2\",\n        \"activity 3\",\n        \"activity 4\",\n        \"activity 5\",\n        \"activity 6\",\n        {\"Subcity 1\": [\"activity 7\", \"activity 8\"]},\n        {\"Subcity 2\": [\"activity 9\", \"activity 10\"]},\n    ]", "\n\ndef test_extract_inner_list_empty():\n    # Example with empty data\n    data = {}\n    assert not extract_inner_lists_from_json(data)\n\n\ndef test_extract_inner_list_wrong_input():\n    # Example with wrong input type\n    data = \"wrong input type\"\n    assert not extract_inner_lists_from_json(data)", "def test_extract_inner_list_wrong_input():\n    # Example with wrong input type\n    data = \"wrong input type\"\n    assert not extract_inner_lists_from_json(data)\n"]}
{"filename": "tests/test_gptravel/test_core/test_utils/conftest.py", "chunked_list": ["import pytest\n\nfrom gptravel.core.utils.regex_tool import JsonExtractor\n\n\n@pytest.fixture\ndef extractor() -> JsonExtractor:\n    return JsonExtractor()\n", ""]}
{"filename": "tests/test_gptravel/test_core/test_services/test_geocoder.py", "chunked_list": ["import pytest\n\nfrom gptravel.core.services.geocoder import GeoCoder\n\n\nclass TestGeoCoder:\n    def test_country_from_location_name(self, geo_coder: GeoCoder):\n        assert geo_coder.country_from_location_name(\"Paris, France\") == \"France\"\n        assert geo_coder.country_from_location_name(\"London, UK\") == \"United Kingdom\"\n        assert (\n            geo_coder.country_from_location_name(\"Los Angeles, US\") == \"United States\"\n        )\n        assert geo_coder.country_from_location_name(\"Mumbai, India\") == \"India\"\n        assert geo_coder.country_from_location_name(\"PortaSigrar\") is None\n\n    def test_location_coordinates(self, geo_coder: GeoCoder):\n        assert geo_coder.location_coordinates(\"kolkata\") == {\n            \"lat\": 22.5726459,\n            \"lon\": 88.3638953,\n        }\n        output = geo_coder.location_coordinates(\"delhi\")\n        assert output[\"lat\"] == pytest.approx(28.6, 0.1)\n        assert output[\"lon\"] == pytest.approx(77.2, 0.1)\n        assert geo_coder.location_coordinates(\"PortaSigrar\") == {\n            \"lat\": None,\n            \"lon\": None,\n        }\n\n    def test_location_distance(self, geo_coder: GeoCoder):\n        assert geo_coder.location_distance(\"kolkata\", \"delhi\") == pytest.approx(\n            1305.106, 0.001\n        )\n        assert geo_coder.location_distance(\"delhi\", \"delhi\") == pytest.approx(\n            0.0, 0.001\n        )\n\n    @pytest.mark.parametrize(\n        \"location_name, expected_result\",\n        [\n            (\"United States\", True),\n            (\"California\", True),\n            (\"New York\", True),\n            (\"Italy\", True),\n            (\"Rome\", True),\n            (\"Berlin\", True),\n            (\"Milan\", True),\n            (\"Pippo\", False),\n        ],\n    )\n    def test_is_location_country_city_state(\n        self, geo_coder, location_name, expected_result\n    ):\n        assert (\n            geo_coder.is_location_country_city_state(location_name) == expected_result\n        )\n\n    @pytest.mark.parametrize(\n        \"location_name, expected_result\",\n        [\n            (\"United States\", True),\n            (\"California\", True),\n            (\"New York\", False),\n            (\"Italy\", True),\n            (\"Rome\", False),\n            (\"Berlin\", False),\n            (\"Milan\", False),\n            (\"Pippo\", False),\n        ],\n    )\n    def test_is_location_country(self, geo_coder, location_name, expected_result):\n        assert geo_coder.is_a_country(location_name) == expected_result", ""]}
{"filename": "tests/test_gptravel/test_core/test_services/test_checker.py", "chunked_list": ["import os\n\nimport pytest\n\nfrom gptravel.core.services.checker import DaysChecker, ExistingDestinationsChecker\nfrom gptravel.core.services.geocoder import GeoCoder\nfrom gptravel.core.travel_planner.travel_engine import TravelPlanJSON\n\n\n@pytest.fixture\ndef existing_cities_checker(geo_coder: GeoCoder) -> ExistingDestinationsChecker:\n    return ExistingDestinationsChecker(geo_coder)", "\n@pytest.fixture\ndef existing_cities_checker(geo_coder: GeoCoder) -> ExistingDestinationsChecker:\n    return ExistingDestinationsChecker(geo_coder)\n\n\n@pytest.fixture\ndef days_checker() -> DaysChecker:\n    return DaysChecker()\n", "\n\nuat_test = pytest.mark.skipif(\n    os.getenv(\"ENV\", \"UAT\") == \"PROD\",\n    reason=\"Only run in UAT environment\",\n)\n\n\nclass TestExistinCityChecker:\n    def test_existing_destinations(\n        self,\n        existing_cities_checker: ExistingDestinationsChecker,\n        travel_plan_single_city_per_day: TravelPlanJSON,\n    ) -> None:\n        assert existing_cities_checker.check(travel_plan_single_city_per_day)\n\n    def test_not_existing_destinations(\n        self,\n        existing_cities_checker: ExistingDestinationsChecker,\n        travel_plan_fake_city: TravelPlanJSON,\n    ) -> None:\n        assert existing_cities_checker.check(travel_plan_fake_city) is False", "class TestExistinCityChecker:\n    def test_existing_destinations(\n        self,\n        existing_cities_checker: ExistingDestinationsChecker,\n        travel_plan_single_city_per_day: TravelPlanJSON,\n    ) -> None:\n        assert existing_cities_checker.check(travel_plan_single_city_per_day)\n\n    def test_not_existing_destinations(\n        self,\n        existing_cities_checker: ExistingDestinationsChecker,\n        travel_plan_fake_city: TravelPlanJSON,\n    ) -> None:\n        assert existing_cities_checker.check(travel_plan_fake_city) is False", "\n\nclass TestDaysChecker:\n    def test_correct_number_of_days(\n        self, days_checker: DaysChecker, travel_plan_single_city_per_day: TravelPlanJSON\n    ) -> None:\n        assert days_checker.check(travel_plan_single_city_per_day)\n        assert days_checker.travel_days == travel_plan_single_city_per_day.n_days\n\n    def test_no_same_number_of_days(\n        self,\n        days_checker: DaysChecker,\n        travel_plan_multiple_city_per_day_and_wrong_n_days: TravelPlanJSON,\n    ) -> None:\n        assert not days_checker.check(\n            travel_plan_multiple_city_per_day_and_wrong_n_days\n        )\n        assert days_checker.travel_days == 2", ""]}
{"filename": "tests/test_gptravel/test_core/test_services/test_filters.py", "chunked_list": ["from copy import deepcopy\n\nimport pytest\n\nfrom gptravel.core.services.filters import DeparturePlaceFilter, TravelPlanJSON\n\n\n@pytest.fixture\ndef departure_place_filter() -> DeparturePlaceFilter:\n    return DeparturePlaceFilter()", "def departure_place_filter() -> DeparturePlaceFilter:\n    return DeparturePlaceFilter()\n\n\nclass TestDeparturePlaceFilter:\n    def test_on_travel_plan_with_departure(\n        self,\n        departure_place_filter: DeparturePlaceFilter,\n        italian_travel_plan: TravelPlanJSON,\n    ):\n        before_removal = deepcopy(italian_travel_plan)\n        departure_place_filter.filter(italian_travel_plan)\n        assert before_removal.travel_plan != italian_travel_plan.travel_plan\n        assert (\n            italian_travel_plan.departure_place not in italian_travel_plan.travel_cities\n        )\n        assert italian_travel_plan.get_key_values_by_name(\"day\") == [\n            \"Day 1\",\n            \"Day 2\",\n            \"Day 3\",\n        ]\n        assert italian_travel_plan.travel_activities == [\n            \"See San Marco\",\n            \"Take a ride on gondola\",\n            \"Eat an arancina\",\n            \"Eat fiorentina\",\n        ]\n\n    def test_on_travel_plan_with_nodeparture(\n        self,\n        departure_place_filter: DeparturePlaceFilter,\n        travel_plan_single_city_per_day: TravelPlanJSON,\n    ):\n        before_removal = deepcopy(travel_plan_single_city_per_day)\n        departure_place_filter.filter(travel_plan_single_city_per_day)\n        assert (\n            travel_plan_single_city_per_day.departure_place\n            not in travel_plan_single_city_per_day.travel_cities\n        )\n        assert before_removal.travel_plan == travel_plan_single_city_per_day.travel_plan", ""]}
{"filename": "tests/test_gptravel/test_core/test_services/test_scorer.py", "chunked_list": ["import os\n\nimport pytest\n\nfrom gptravel.core.services.scorer import (\n    CitiesCountryScorer,\n    DayGenerationScorer,\n    OptimizedItineraryScorer,\n    TravelPlanScore,\n)", "    TravelPlanScore,\n)\nfrom gptravel.core.travel_planner.travel_engine import TravelPlanJSON\n\nuat_test = pytest.mark.skipif(\n    os.getenv(\"ENV\", \"UAT\") == \"PROD\",\n    reason=\"Only run in UAT environment\",\n)\n\n\nclass TestTravelPlanScore:\n    def test_add_score(self, score_container: TravelPlanScore):\n        score_container.add_score(\n            \"type score\", {\"score_value\": 100, \"score_weight\": 0.11}\n        )\n        score_container.add_score(\n            \"score livel\", {\"score_value\": 80, \"score_weight\": 0.23}\n        )\n        score_container.add_score(\n            \"score basso\", {\"score_value\": 60, \"score_weight\": 0.15}\n        )\n        score_container.add_score(\n            \"score extra\", {\"score_value\": 90, \"score_weight\": 0.10}\n        )\n        assert score_container.score_map[\"score extra\"] == {\n            \"score_value\": 90,\n            \"score_weight\": 0.10,\n        }\n\n    def test_weighted_score(self, score_container: TravelPlanScore):\n        score_container.add_score(\n            \"type score\", {\"score_value\": 100, \"score_weight\": 0.11}\n        )\n        score_container.add_score(\n            \"score livel\", {\"score_value\": 80, \"score_weight\": 0.23}\n        )\n        score_container.add_score(\n            \"score basso\", {\"score_value\": 60, \"score_weight\": 0.15}\n        )\n        assert score_container.weighted_score == pytest.approx(78.367, 0.001)\n\n    def test_weighted_score_empty(self, score_container: TravelPlanScore):\n        assert not score_container.weighted_score\n\n    def test_add_score_missing_key(self):\n        score = TravelPlanScore()\n        with pytest.raises(AssertionError):\n            score.add_score(\"score extra\", {\"score_value\": 90})", "\n\nclass TestTravelPlanScore:\n    def test_add_score(self, score_container: TravelPlanScore):\n        score_container.add_score(\n            \"type score\", {\"score_value\": 100, \"score_weight\": 0.11}\n        )\n        score_container.add_score(\n            \"score livel\", {\"score_value\": 80, \"score_weight\": 0.23}\n        )\n        score_container.add_score(\n            \"score basso\", {\"score_value\": 60, \"score_weight\": 0.15}\n        )\n        score_container.add_score(\n            \"score extra\", {\"score_value\": 90, \"score_weight\": 0.10}\n        )\n        assert score_container.score_map[\"score extra\"] == {\n            \"score_value\": 90,\n            \"score_weight\": 0.10,\n        }\n\n    def test_weighted_score(self, score_container: TravelPlanScore):\n        score_container.add_score(\n            \"type score\", {\"score_value\": 100, \"score_weight\": 0.11}\n        )\n        score_container.add_score(\n            \"score livel\", {\"score_value\": 80, \"score_weight\": 0.23}\n        )\n        score_container.add_score(\n            \"score basso\", {\"score_value\": 60, \"score_weight\": 0.15}\n        )\n        assert score_container.weighted_score == pytest.approx(78.367, 0.001)\n\n    def test_weighted_score_empty(self, score_container: TravelPlanScore):\n        assert not score_container.weighted_score\n\n    def test_add_score_missing_key(self):\n        score = TravelPlanScore()\n        with pytest.raises(AssertionError):\n            score.add_score(\"score extra\", {\"score_value\": 90})", "\n\nclass TestDayGenerationScorer:\n    def test_day_generation_scorer_with_correct_days_travel_plan(\n        self,\n        score_container: TravelPlanScore,\n        travel_plan_single_city_per_day: TravelPlanJSON,\n        day_generation_scorer: DayGenerationScorer,\n    ) -> None:\n        day_generation_scorer.score(\n            travel_plan=travel_plan_single_city_per_day,\n            travel_plan_scores=score_container,\n        )\n        assert list(score_container.score_map.keys()) == [\n            day_generation_scorer.service_name\n        ]\n        score_dict = score_container.score_map[day_generation_scorer.service_name]\n        assert score_dict[\"score_value\"] == 1.0\n        assert score_dict[\"score_weight\"] == 0.4\n        assert score_dict[\"misaligned_days\"][\"extra_days\"] == []\n        assert score_dict[\"misaligned_days\"][\"missing_days\"] == []\n\n    def test_day_generation_scorer_with_no_correct_days_travel_plan(\n        self,\n        score_container: TravelPlanScore,\n        travel_plan_multiple_city_per_day_and_wrong_n_days: TravelPlanJSON,\n        day_generation_scorer: DayGenerationScorer,\n    ) -> None:\n        day_generation_scorer.score(\n            travel_plan=travel_plan_multiple_city_per_day_and_wrong_n_days,\n            travel_plan_scores=score_container,\n        )\n        assert list(score_container.score_map.keys()) == [\n            day_generation_scorer.service_name\n        ]\n        score_dict = score_container.score_map[day_generation_scorer.service_name]\n        assert score_dict[\"score_value\"] == pytest.approx(0.67, 0.01)\n        assert score_dict[\"score_weight\"] == pytest.approx(0.6, 0.01)\n        assert score_dict[\"misaligned_days\"][\"extra_days\"] == []\n        assert score_dict[\"misaligned_days\"][\"missing_days\"] == [3]", "\n\nclass TestCitiesCountryScorer:\n    def test_with_correct_travel_plan(\n        self,\n        cities_country_scorer: CitiesCountryScorer,\n        travel_plan_multiple_city_per_day_and_wrong_n_days: TravelPlanJSON,\n        score_container: TravelPlanScore,\n    ) -> None:\n        cities_country_scorer.score(\n            travel_plan_multiple_city_per_day_and_wrong_n_days, score_container\n        )\n        score_dict = score_container.score_map[cities_country_scorer.service_name]\n        assert score_dict[\"score_value\"] == pytest.approx(1.0, 0.01)\n        assert score_dict[\"latitude_check\"][\"score\"] == pytest.approx(1.0, 0.01)\n        assert score_dict[\"country_check\"][\"score\"] == pytest.approx(1.0, 0.01)\n\n    def test_with_wrong_city_travel_plan(\n        self,\n        cities_country_scorer: CitiesCountryScorer,\n        travel_plan_multiple_city_per_day_and_wrong_city_per_country: TravelPlanJSON,\n        score_container: TravelPlanScore,\n    ) -> None:\n        cities_country_scorer.score(\n            travel_plan_multiple_city_per_day_and_wrong_city_per_country,\n            score_container,\n        )\n        score_dict = score_container.score_map[cities_country_scorer.service_name]\n        assert score_dict[\"score_value\"] == pytest.approx(0.8, 0.01)\n        assert score_dict[\"latitude_check\"][\"score\"] == pytest.approx(1.0, 0.01)\n        assert score_dict[\"country_check\"][\"score\"] == pytest.approx(0.666, 0.01)", "\n\nclass TestOptimizedItineraryScorer:\n    def test_with_different_cities(\n        self,\n        itinerary_scorer: OptimizedItineraryScorer,\n        travel_plan_multiple_city_per_day_and_wrong_n_days: TravelPlanJSON,\n        score_container: TravelPlanScore,\n    ) -> None:\n        itinerary_scorer.score(\n            travel_plan_multiple_city_per_day_and_wrong_n_days, score_container\n        )\n        score_dict = score_container.score_map[itinerary_scorer.service_name]\n        assert score_dict[\"score_value\"] == pytest.approx(0.95181, 0.0001)\n        assert score_dict[\"tsp_solution\"][\"solution\"] == [\"bangkok\", \"krabi\", \"phuket\"]\n        assert score_dict[\"tsp_solution\"][\"open_problem\"]\n        assert score_dict[\"tsp_solution\"][\"distance\"] == pytest.approx(727.7, 0.1)\n        assert score_dict[\"itinerary\"][\"distance\"] == pytest.approx(770.2, 0.1)\n        assert score_dict[\"itinerary\"][\"solution\"] == [\"bangkok\", \"phuket\", \"krabi\"]\n\n    def test_with_departure_place_in_tp(\n        self,\n        itinerary_scorer: OptimizedItineraryScorer,\n        italian_travel_plan: TravelPlanJSON,\n        score_container: TravelPlanScore,\n    ) -> None:\n        itinerary_scorer.score(italian_travel_plan, score_container)\n        score_dict = score_container.score_map[itinerary_scorer.service_name]\n        assert score_dict[\"score_value\"] == pytest.approx(0.58256, 0.0001)\n        assert score_dict[\"tsp_solution\"][\"solution\"] == [\n            \"venice\",\n            \"florence\",\n            \"palermo\",\n        ]\n        assert score_dict[\"tsp_solution\"][\"open_problem\"]\n        assert score_dict[\"tsp_solution\"][\"distance\"] == pytest.approx(856.79, 0.1)\n        assert score_dict[\"itinerary\"][\"distance\"] == pytest.approx(1470.73, 0.1)\n        assert score_dict[\"itinerary\"][\"solution\"] == [\"venice\", \"palermo\", \"florence\"]", ""]}
{"filename": "tests/test_gptravel/test_core/test_services/test_utils.py", "chunked_list": ["import os\n\nimport numpy as np\nimport pytest\n\nfrom gptravel.core.services.utils import (\n    is_location_a_country,\n    remove_consecutive_duplicates,\n    theil_diversity_entropy_index,\n)", "    theil_diversity_entropy_index,\n)\n\n\ndef test_entropy_score():\n    input_list = [0.2, 0.2, 0.2, 0.2, 0.2]\n    expected_output = 0.0\n    assert np.isclose(\n        theil_diversity_entropy_index(input_list), expected_output, rtol=1e-6\n    )\n\n    input_list = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    input_list = [item / sum(input_list) for item in input_list]\n    expected_output = 0.0\n    assert np.isclose(\n        theil_diversity_entropy_index(input_list), expected_output, rtol=1e-6\n    )\n\n    input_list = [100, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    input_list = [item / sum(input_list) for item in input_list]\n    expected_output = 0.7634496077289633\n    assert np.isclose(\n        theil_diversity_entropy_index(input_list), expected_output, rtol=1e-6\n    )\n\n    input_list = [100, 0.0, 0.0, 0, 0.0]\n    expected_output = 1.0\n    assert np.isclose(\n        theil_diversity_entropy_index(input_list), expected_output, rtol=1e-6\n    )\n\n    input_list = [0.9, 0.05, 0.05, 0.01, 0.01]\n    expected_output = 0.6913428710325702\n    assert np.isclose(\n        theil_diversity_entropy_index(input_list), expected_output, rtol=1e-6\n    )\n\n    input_list = [0.2, 0.3, 0.1, 0.2, 0.2]\n    expected_output = 0.03251123511643821\n    assert np.isclose(\n        theil_diversity_entropy_index(input_list), expected_output, rtol=1e-6\n    )", "\n\n@pytest.mark.skipif(\n    os.getenv(\"HUGGING_FACE_KEY\", \"\") == \"\", reason=\"no api key available\"\n)\ndef test_is_location_a_country():\n    assert is_location_a_country(\"Thailand\")\n    assert not is_location_a_country(\"Bangkok\")\n    assert is_location_a_country(\"United States\")\n    assert not is_location_a_country(\"Milan\")\n    assert is_location_a_country(\"Russia\")", "\n\ndef test_remove_consecutive_duplicates():\n    assert remove_consecutive_duplicates([]) == []\n    assert remove_consecutive_duplicates([1]) == [1]\n    assert remove_consecutive_duplicates([1, 1, 1, 1]) == [1]\n    assert remove_consecutive_duplicates([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert remove_consecutive_duplicates([1, 1, 2, 2, 3, 4, 4]) == [1, 2, 3, 4]\n    assert remove_consecutive_duplicates([1, 1, 2, 2, 3, 4, 4, 1]) == [1, 2, 3, 4, 1]\n    assert remove_consecutive_duplicates([1, 1, 2, 2, 3, 4, 4, 1, 1]) == [1, 2, 3, 4, 1]\n    assert remove_consecutive_duplicates([1, 1, 2, 2, 3, 4, 1, 4, 1]) == [\n        1,\n        2,\n        3,\n        4,\n        1,\n        4,\n        1,\n    ]\n    assert remove_consecutive_duplicates([1, \"a\", \"a\", 2, 2, \"b\", \"c\", \"c\", 4]) == [\n        1,\n        \"a\",\n        2,\n        \"b\",\n        \"c\",\n        4,\n    ]", ""]}
{"filename": "tests/test_gptravel/test_core/test_services/conftest.py", "chunked_list": ["import pytest\n\nfrom gptravel.core.services.geocoder import GeoCoder\nfrom gptravel.core.services.scorer import (\n    CitiesCountryScorer,\n    DayGenerationScorer,\n    OptimizedItineraryScorer,\n    TravelPlanScore,\n)\n", ")\n\n\n@pytest.fixture(autouse=True)\ndef geo_coder() -> GeoCoder:\n    return GeoCoder()\n\n\n@pytest.fixture\ndef score_container() -> TravelPlanScore:\n    return TravelPlanScore()", "@pytest.fixture\ndef score_container() -> TravelPlanScore:\n    return TravelPlanScore()\n\n\n@pytest.fixture\ndef cities_country_scorer(geo_coder: GeoCoder) -> CitiesCountryScorer:\n    return CitiesCountryScorer(geo_coder)\n\n", "\n\n@pytest.fixture\ndef day_generation_scorer() -> DayGenerationScorer:\n    return DayGenerationScorer()\n\n\n@pytest.fixture\ndef itinerary_scorer(geo_coder: GeoCoder) -> OptimizedItineraryScorer:\n    return OptimizedItineraryScorer(geo_coder)", "def itinerary_scorer(geo_coder: GeoCoder) -> OptimizedItineraryScorer:\n    return OptimizedItineraryScorer(geo_coder)\n"]}
{"filename": "tests/test_gptravel/test_core/test_services/test_engine.py/test_tsp_solver.py", "chunked_list": ["import os\n\nimport pytest\n\nfrom gptravel.core.services.engine.tsp_solver import TSPSolver\nfrom gptravel.core.services.geocoder import GeoCoder\n\n\n@pytest.fixture\ndef tsp_solver(geo_coder: GeoCoder) -> TSPSolver:\n    return TSPSolver(geo_coder)", "@pytest.fixture\ndef tsp_solver(geo_coder: GeoCoder) -> TSPSolver:\n    return TSPSolver(geo_coder)\n\n\nuat_test = pytest.mark.skipif(\n    os.getenv(\"ENV\", \"UAT\") == \"PROD\",\n    reason=\"Only run in UAT environment\",\n)\n", ")\n\n\nclass TestTSPSolver:\n    def test_single_city(self, tsp_solver: TSPSolver) -> None:\n        cities = [\"Rome\"]\n        solution, distance = tsp_solver.solve(cities)\n        assert solution == cities\n        assert distance == 0.0\n\n    def test_closed_tsp(self, tsp_solver: TSPSolver) -> None:\n        cities = [\n            \"Milan\",\n            \"Rome\",\n            \"Venice\",\n            \"New York\",\n            \"Verona\",\n            \"Bologna\",\n        ]\n        solution, distance = tsp_solver.solve(cities=cities, open_problem=False)\n        assert solution == [\"Milan\", \"New York\", \"Rome\", \"Bologna\", \"Venice\", \"Verona\"]\n        assert distance == pytest.approx(14068.795, 0.001)\n\n    def test_open_tsp(self, tsp_solver: TSPSolver) -> None:\n        cities = [\n            \"Milan\",\n            \"Rome\",\n            \"Venice\",\n            \"New York\",\n            \"Verona\",\n            \"Bologna\",\n        ]\n        solution, distance = tsp_solver.solve(cities=cities, open_problem=True)\n        assert solution == [\"Milan\", \"Verona\", \"Venice\", \"Bologna\", \"Rome\", \"New York\"]\n        assert distance == pytest.approx(7587.457, 0.001)", ""]}
{"filename": "tests/test_gptravel/test_core/test_services/test_engine.py/test_classifier.py", "chunked_list": ["import os\n\nimport pytest\n\nfrom gptravel.core.services.engine.classifier import ZeroShotTextClassifier\n\n\n@pytest.fixture()\ndef classifier() -> ZeroShotTextClassifier:\n    return ZeroShotTextClassifier(multi_label=True)", "def classifier() -> ZeroShotTextClassifier:\n    return ZeroShotTextClassifier(multi_label=True)\n\n\n@pytest.mark.skipif(\n    os.getenv(\"HUGGING_FACE_KEY\", \"\") == \"\", reason=\"no api key available\"\n)\nclass TestZeroShotClassified:\n    def test_property(self, classifier: ZeroShotTextClassifier):\n        assert classifier.multi_label\n        classifier.multi_label = False\n        assert not classifier.multi_label\n\n    def test_prediction(self, classifier: ZeroShotTextClassifier):\n        labels = [\"sea\", \"land\", \"city\"]\n        input_text = [\"fish\"]\n        out = classifier.predict(input_text_list=input_text, label_classes=labels)[\n            input_text[0]\n        ]\n        for label in labels:\n            assert (out[label] < 1) & (out[label] >= 0)\n        assert max(out, key=out.get) == \"sea\"", ""]}
{"filename": "tests/test_gptravel/test_core/test_travel_planner/test_travel_engine.py", "chunked_list": ["from gptravel.core.travel_planner.travel_engine import TravelPlanJSON\n\n\nclass TestTravelPlanJSON:\n    def test_travel_plan_properties(\n        self, travel_plan_single_city_per_day: TravelPlanJSON\n    ):\n        assert travel_plan_single_city_per_day.n_days == 3\n        assert travel_plan_single_city_per_day.departure_place == \"Milan\"\n        assert travel_plan_single_city_per_day.destination_place == \"Thailand\"\n        assert travel_plan_single_city_per_day.keys_map == {\"day\": 0, \"city\": 1}\n        assert travel_plan_single_city_per_day.travel_plan == {\n            \"Day 1\": {\n                \"Bangkok\": [\n                    \"Visit Wat Phra Kaew and the Grand Palace\",\n                    \"Explore the Wat Pho Temple\",\n                    \"Ride a boat in the Chao Phraya River\",\n                    \"Shop at Chatuchak weekend market\",\n                ]\n            },\n            \"Day 2\": {\n                \"Phuket\": [\n                    \"Spend time at the Patong Beach\",\n                    \"Visit Big Buddha Phuket\",\n                    \"Explore the Phuket Old Town\",\n                    \"Enjoy local street food at night markets\",\n                ]\n            },\n            \"Day 3\": {\n                \"Krabi\": [\n                    \"Visit Railay Beach and the Phra Nang Cave\",\n                    \"Island hopping tour to Phi Phi Islands\",\n                    \"Hike to the Tiger Cave Temple\",\n                    \"Relax at Ao Nang Beach\",\n                ]\n            },\n        }\n\n    def test_travel_plan_single_city_per_day(\n        self,\n        travel_plan_single_city_per_day: TravelPlanJSON,\n    ):\n        days = travel_plan_single_city_per_day.get_key_values_by_name(key_name=\"day\")\n        assert days == [\"Day 1\", \"Day 2\", \"Day 3\"]\n        cities = travel_plan_single_city_per_day.get_key_values_by_name(key_name=\"city\")\n        assert cities == [\"Bangkok\", \"Phuket\", \"Krabi\"]\n        activities = travel_plan_single_city_per_day.travel_activities\n        assert activities == [\n            \"Visit Wat Phra Kaew and the Grand Palace\",\n            \"Explore the Wat Pho Temple\",\n            \"Ride a boat in the Chao Phraya River\",\n            \"Shop at Chatuchak weekend market\",\n            \"Spend time at the Patong Beach\",\n            \"Visit Big Buddha Phuket\",\n            \"Explore the Phuket Old Town\",\n            \"Enjoy local street food at night markets\",\n            \"Visit Railay Beach and the Phra Nang Cave\",\n            \"Island hopping tour to Phi Phi Islands\",\n            \"Hike to the Tiger Cave Temple\",\n            \"Relax at Ao Nang Beach\",\n        ]\n\n    def test_travel_plan_multiple_city_per_day(\n        self,\n        travel_plan_multiple_city_per_day_and_wrong_n_days: TravelPlanJSON,\n    ):\n        days = (\n            travel_plan_multiple_city_per_day_and_wrong_n_days.get_key_values_by_name(\n                key_name=\"day\"\n            )\n        )\n        assert days == [\"Day 1\", \"Day 2\"]\n        cities = (\n            travel_plan_multiple_city_per_day_and_wrong_n_days.get_key_values_by_name(\n                key_name=\"city\"\n            )\n        )\n        assert cities == [\"Bangkok\", \"Phuket\", \"Krabi\"]\n        activities = (\n            travel_plan_multiple_city_per_day_and_wrong_n_days.travel_activities\n        )\n        assert activities == [\n            \"Visit Wat Phra Kaew and the Grand Palace\",\n            \"Explore the Wat Pho Temple\",\n            \"Ride a boat in the Chao Phraya River\",\n            \"Shop at Chatuchak weekend market\",\n            \"Spend time at the Patong Beach\",\n            \"Visit Big Buddha Phuket\",\n            \"Explore the Phuket Old Town\",\n            \"Enjoy local street food at night markets\",\n            \"Visit Railay Beach and the Phra Nang Cave\",\n            \"Island hopping tour to Phi Phi Islands\",\n            \"Hike to the Tiger Cave Temple\",\n            \"Relax at Ao Nang Beach\",\n        ]", ""]}
{"filename": "tests/test_gptravel/test_core/test_travel_planner/test_tokenizer.py", "chunked_list": ["import pytest\n\nfrom gptravel.core.travel_planner.token_manager import ChatGptTokenManager\n\n\n@pytest.fixture\ndef chatgpt_token_manager() -> ChatGptTokenManager:\n    return ChatGptTokenManager()\n\n", "\n\n@pytest.mark.parametrize(\n    \"n_days, distance, expected\",\n    [(10, 100, 757), (0, 0, 383), (10, 5000, 756), (-100000000, 5, 383)],\n)\ndef test_chatgpt_token_manager(\n    chatgpt_token_manager: ChatGptTokenManager,\n    n_days: int,\n    distance: float,\n    expected: int,\n):\n    result = chatgpt_token_manager.get_number_tokens(n_days=n_days, distance=distance)\n    assert result == pytest.approx(expected, 1)", ""]}
{"filename": "tests/test_gptravel/test_core/test_travel_planner/test_prompt.py", "chunked_list": ["from typing import Any, Dict\n\nfrom gptravel.core.travel_planner.prompt import (\n    CompletionTravelPrompt,\n    PlainTravelPrompt,\n    PromptFactory,\n    ThematicTravelPrompt,\n)\nfrom gptravel.core.travel_planner.travel_engine import TravelPlanJSON\n", "from gptravel.core.travel_planner.travel_engine import TravelPlanJSON\n\n\nclass TestPrompt:\n    def test_plain_prompt_from_factory(\n        self, travel_properties: Dict[str, Any], prompt_factory: PromptFactory\n    ):\n        prompt_class = prompt_factory.build_prompt(**travel_properties)\n        assert isinstance(prompt_class, PlainTravelPrompt)\n        travel_properties[\"travel_theme\"] = None\n        prompt_class = prompt_factory.build_prompt(**travel_properties)\n        assert isinstance(prompt_class, PlainTravelPrompt)\n\n    def test_thematic_prompt_from_factory(\n        self, travel_properties: Dict[str, Any], prompt_factory: PromptFactory\n    ):\n        travel_properties[\"travel_theme\"] = \"romantic\"\n        prompt_class = prompt_factory.build_prompt(**travel_properties)\n        assert isinstance(prompt_class, ThematicTravelPrompt)\n        assert prompt_class.json_keys == {\"day\": 0, \"city\": 1}\n\n    def test_completion_travel_prompt_from_factory(\n        self,\n        travel_properties: Dict[str, Any],\n        prompt_factory: PromptFactory,\n        travel_plan_single_city_per_day: TravelPlanJSON,\n    ):\n        travel_properties[\"complention_travel_plan\"] = True\n        travel_properties[\"n_days_to_add\"] = 1\n        travel_properties[\"travel_plan\"] = travel_plan_single_city_per_day.travel_plan\n        prompt_class = prompt_factory.build_prompt(**travel_properties)\n        assert prompt_class.json_keys == {\"day\": 0, \"city\": 1}\n        assert isinstance(prompt_class, CompletionTravelPrompt)\n        travel_properties[\"complention_travel_plan\"] = False\n        prompt_class = prompt_factory.build_prompt(**travel_properties)\n        assert not isinstance(prompt_class, CompletionTravelPrompt)\n\n    def test_properties(\n        self, travel_properties: Dict[str, Any], prompt_factory: PromptFactory\n    ):\n        prompt = prompt_factory.build_prompt(**travel_properties)\n        assert prompt.departure_place == travel_properties[\"departure_place\"]\n        assert prompt.destination_place == travel_properties[\"destination_place\"]\n        assert prompt.n_travel_days == travel_properties[\"n_travel_days\"]", ""]}
{"filename": "src/gptravel/main.py", "chunked_list": ["import json\nimport os\nimport time\nfrom typing import Optional\n\nimport openai\nfrom dotenv import load_dotenv\n\nfrom gptravel.core.services.checker import DaysChecker, ExistingDestinationsChecker\nfrom gptravel.core.services.engine.classifier import ZeroShotTextClassifier", "from gptravel.core.services.checker import DaysChecker, ExistingDestinationsChecker\nfrom gptravel.core.services.engine.classifier import ZeroShotTextClassifier\nfrom gptravel.core.services.filters import DeparturePlaceFilter\nfrom gptravel.core.services.geocoder import GeoCoder\nfrom gptravel.core.services.score_builder import ScorerOrchestrator\nfrom gptravel.core.services.scorer import TravelPlanScore\nfrom gptravel.core.travel_planner.openai_engine import ChatGPTravelEngine\nfrom gptravel.core.travel_planner.prompt import PromptFactory\n\n# from gptravel.core.travel_planner.travel_engine import TravelPlanJSON", "\n# from gptravel.core.travel_planner.travel_engine import TravelPlanJSON\n\nload_dotenv()\n\nopenai.api_key = os.getenv(\"OPENAI_API_KEY\")\n\n\ndef main(\n    destination_place: str,\n    departure_place: str,\n    n_days: int,\n    travel_theme: Optional[str] = None,\n):\n    start_time = time.time()\n    travel_parameters = {\n        \"departure_place\": departure_place,\n        \"destination_place\": destination_place,\n        \"n_travel_days\": n_days,\n        \"travel_theme\": travel_theme,\n    }\n\n    prompt_factory = PromptFactory()\n\n    prompt = prompt_factory.build_prompt(**travel_parameters)\n\n    engine = ChatGPTravelEngine(max_tokens=350)\n    travel_plan_in_json_format = engine.get_travel_plan_json(prompt)\n    travel_plan_in_json_format = engine.get_travel_plan_json(prompt)\n    print(\n        \"** Execution time for travel generation\", time.time() - start_time, \"seconds\"\n    )\n    with open(\n        \"trave-l_plan_{}_{}.json\".format(destination_place, n_days), \"w\"\n    ) as jfile:\n        json.dump(travel_plan_in_json_format.travel_plan, jfile)\n\n    \"\"\"travel_plan_in_json_format = TravelPlanJSON(\n        destination_place=\"Malaysia\",\n        departure_place=\"Rome\",\n        n_days=4,\n        travel_plan_json={\n            \"Day 1\": {\n                \"Kuala Lumpur\": [\n                    \"Visit Petronas Towers\",\n                    \"Explore Batu Caves\",\n                    \"Shop at Central Market\",\n                    \"Try local street food at Jalan Alor\",\n                ]\n            },\n            \"Day 2\": {\n                \"Kuala Lumpur\": [\n                    \"Visit Islamic Arts Museum\",\n                    \"Explore Merdeka Square\",\n                    \"Enjoy panoramic views from KL Tower\",\n                ]\n            },\n            \"Day 3\": {\n                \"Penang\": [\n                    \"Discover George Town's street art\",\n                    \"Visit Kek Lok Si Temple\",\n                    \"Try local food at Gurney Drive Hawker Centre\",\n                ]\n            },\n        },\n        json_keys_depth_map={\"city\": 1, \"day\": 0},\n    )\"\"\"\n    filter_service = DeparturePlaceFilter()\n    filter_service.filter(travel_plan=travel_plan_in_json_format)\n    checker = DaysChecker()\n    is_ok = checker.check(travel_plan=travel_plan_in_json_format)\n    if not is_ok:\n        travel_parameters[\"complention_travel_plan\"] = True\n        travel_parameters[\"n_days_to_add\"] = (\n            travel_plan_in_json_format.n_days - checker.travel_days\n        )\n        travel_parameters[\"travel_plan\"] = travel_plan_in_json_format.travel_plan\n        prompt_completion = prompt_factory.build_prompt(**travel_parameters)\n        travel_plan_in_json_format = engine.get_travel_plan_json(prompt_completion)\n    middle_time = time.time()\n    zs_classifier = ZeroShotTextClassifier(True)\n    geo_decoder = GeoCoder()\n    score_container = TravelPlanScore()\n    city_checker = ExistingDestinationsChecker(geo_decoder)\n    city_checker.check(travel_plan_in_json_format)\n    scorers_orchestrator = ScorerOrchestrator(\n        geocoder=geo_decoder, text_classifier=zs_classifier\n    )\n    scorers_orchestrator.run(\n        travel_plan_json=travel_plan_in_json_format, scores_container=score_container\n    )\n    print(\n        \"** Execution time for scores computation\", time.time() - middle_time, \"seconds\"\n    )\n    print(\"** Total execution time\", time.time() - start_time, \"seconds\")\n    print(\"** Travel plan overall scores\", score_container.weighted_score)\n    with open(\n        \"trave-l_plan_{}_{}_scores.json\".format(destination_place, n_days), \"w\"\n    ) as jfile:\n        json.dump(score_container.score_map, jfile)", "def main(\n    destination_place: str,\n    departure_place: str,\n    n_days: int,\n    travel_theme: Optional[str] = None,\n):\n    start_time = time.time()\n    travel_parameters = {\n        \"departure_place\": departure_place,\n        \"destination_place\": destination_place,\n        \"n_travel_days\": n_days,\n        \"travel_theme\": travel_theme,\n    }\n\n    prompt_factory = PromptFactory()\n\n    prompt = prompt_factory.build_prompt(**travel_parameters)\n\n    engine = ChatGPTravelEngine(max_tokens=350)\n    travel_plan_in_json_format = engine.get_travel_plan_json(prompt)\n    travel_plan_in_json_format = engine.get_travel_plan_json(prompt)\n    print(\n        \"** Execution time for travel generation\", time.time() - start_time, \"seconds\"\n    )\n    with open(\n        \"trave-l_plan_{}_{}.json\".format(destination_place, n_days), \"w\"\n    ) as jfile:\n        json.dump(travel_plan_in_json_format.travel_plan, jfile)\n\n    \"\"\"travel_plan_in_json_format = TravelPlanJSON(\n        destination_place=\"Malaysia\",\n        departure_place=\"Rome\",\n        n_days=4,\n        travel_plan_json={\n            \"Day 1\": {\n                \"Kuala Lumpur\": [\n                    \"Visit Petronas Towers\",\n                    \"Explore Batu Caves\",\n                    \"Shop at Central Market\",\n                    \"Try local street food at Jalan Alor\",\n                ]\n            },\n            \"Day 2\": {\n                \"Kuala Lumpur\": [\n                    \"Visit Islamic Arts Museum\",\n                    \"Explore Merdeka Square\",\n                    \"Enjoy panoramic views from KL Tower\",\n                ]\n            },\n            \"Day 3\": {\n                \"Penang\": [\n                    \"Discover George Town's street art\",\n                    \"Visit Kek Lok Si Temple\",\n                    \"Try local food at Gurney Drive Hawker Centre\",\n                ]\n            },\n        },\n        json_keys_depth_map={\"city\": 1, \"day\": 0},\n    )\"\"\"\n    filter_service = DeparturePlaceFilter()\n    filter_service.filter(travel_plan=travel_plan_in_json_format)\n    checker = DaysChecker()\n    is_ok = checker.check(travel_plan=travel_plan_in_json_format)\n    if not is_ok:\n        travel_parameters[\"complention_travel_plan\"] = True\n        travel_parameters[\"n_days_to_add\"] = (\n            travel_plan_in_json_format.n_days - checker.travel_days\n        )\n        travel_parameters[\"travel_plan\"] = travel_plan_in_json_format.travel_plan\n        prompt_completion = prompt_factory.build_prompt(**travel_parameters)\n        travel_plan_in_json_format = engine.get_travel_plan_json(prompt_completion)\n    middle_time = time.time()\n    zs_classifier = ZeroShotTextClassifier(True)\n    geo_decoder = GeoCoder()\n    score_container = TravelPlanScore()\n    city_checker = ExistingDestinationsChecker(geo_decoder)\n    city_checker.check(travel_plan_in_json_format)\n    scorers_orchestrator = ScorerOrchestrator(\n        geocoder=geo_decoder, text_classifier=zs_classifier\n    )\n    scorers_orchestrator.run(\n        travel_plan_json=travel_plan_in_json_format, scores_container=score_container\n    )\n    print(\n        \"** Execution time for scores computation\", time.time() - middle_time, \"seconds\"\n    )\n    print(\"** Total execution time\", time.time() - start_time, \"seconds\")\n    print(\"** Travel plan overall scores\", score_container.weighted_score)\n    with open(\n        \"trave-l_plan_{}_{}_scores.json\".format(destination_place, n_days), \"w\"\n    ) as jfile:\n        json.dump(score_container.score_map, jfile)", "\n\nif __name__ == \"__main__\":\n    main(\n        destination_place=\"Malaysia\",\n        departure_place=\"Milan\",\n        n_days=4,\n        travel_theme=None,\n    )\n", ""]}
{"filename": "src/gptravel/__init__.py", "chunked_list": [""]}
{"filename": "src/gptravel/prototype/help.py", "chunked_list": ["OPENAI_KEY_HELP = (\n    \"Enter your OpenAI key. If you don't have one, \"\n    \"you can sign up at https://openai.com/ to get your API key.\"\n)\n\nDEPARTURE_DATE_HELP = \"Choose the date of departure.\"\n\nRETURN_DATE_HELP = \"Choose the date of return.\"\n\nDEPARTURE_LOC_HELP = \"Enter the departure location.\"", "\nDEPARTURE_LOC_HELP = \"Enter the departure location.\"\n\nDESTINATION_LOC_HELP = \"Enter the destination location.\"\n\nTRAVEL_REASON_HELP = \"Select the reason for your travel.\"\n\nTRAVEL_SCORE_HELP = (\n    \"This is a rating from 0 to 100 that indicates the diversity of your travel experience.\"\n    \" It measures the balance of activities such as monuments, culture, transport, museums, relaxation, sports, food, shopping, mountains, and sea. \"", "    \"This is a rating from 0 to 100 that indicates the diversity of your travel experience.\"\n    \" It measures the balance of activities such as monuments, culture, transport, museums, relaxation, sports, food, shopping, mountains, and sea. \"\n    \"Aim for a high score to ensure a well-rounded trip with unforgettable memories and a deep connection to your destinations.\"\n)\n"]}
{"filename": "src/gptravel/prototype/__init__.py", "chunked_list": [""]}
{"filename": "src/gptravel/prototype/utils.py", "chunked_list": ["from datetime import date\nfrom typing import Dict, List, Tuple, Union\n\nimport openai\n\nfrom gptravel.core.io.loggerconfig import logger\nfrom gptravel.core.services.engine import classifier\nfrom gptravel.core.services.geocoder import GeoCoder\nfrom gptravel.core.services.score_builder import ScorerOrchestrator\nfrom gptravel.core.services.scorer import TravelPlanScore", "from gptravel.core.services.score_builder import ScorerOrchestrator\nfrom gptravel.core.services.scorer import TravelPlanScore\nfrom gptravel.core.travel_planner.travel_engine import TravelPlanJSON\n\n\ndef is_valid_openai_key(openai_key: str) -> bool:\n    \"\"\"\n    Checks if the provided OpenAI API key is valid by performing a test request.\n\n    Parameters\n    ----------\n    openai_key : str\n        The OpenAI API key to be tested.\n\n    Returns\n    -------\n    bool\n        True if the OpenAI API key is valid and the test request succeeds,\n        False otherwise.\n\n    Raises\n    ------\n    None\n\n    Examples\n    --------\n    >>> is_valid_openai_key(\"<OPENAI_API_KEY>\")\n    True\n\n    >>> is_valid_openai_key(\"foo\")\n    False\n    \"\"\"\n    openai.api_key = openai_key\n\n    try:\n        openai.Completion.create(engine=\"ada\", prompt=\"Hello, World!\", max_tokens=5)\n    except openai.error.InvalidRequestError:\n        return False\n    except openai.error.AuthenticationError:\n        return False\n\n    return True", "\n\ndef is_departure_before_return(departure_date: date, return_date: date) -> bool:\n    \"\"\"\n    Parameters\n    ----------\n    departure_date : np.datetime64\n        The date of departure.\n    return_date : np.datetime64\n        The date of return.\n\n    Returns\n    -------\n    bool_\n        True if the departure date is before or equal to the return date, False otherwise.\n    \"\"\"\n    return departure_date <= return_date", "\n\ndef get_score_map(\n    travel_plan_json: TravelPlanJSON,\n) -> TravelPlanScore:\n    \"\"\"\n    Calculates the score map for a given travel plan.\n\n    Parameters\n    ----------\n    travel_plan_json : TravelPlanJSON\n        The JSON representation of the travel plan.\n\n    Returns\n    -------\n    Dict[str, Dict[str, Union[float, int]]]\n        A dictionary containing the score map for the travel plan.\n    \"\"\"\n    geo_decoder = GeoCoder()\n    zs_classifier = classifier.ZeroShotTextClassifier(True)\n    score_container = TravelPlanScore()\n    logger.info(\"Score Engines: Start\")\n    scorers_orchestrator = ScorerOrchestrator(\n        geocoder=geo_decoder, text_classifier=zs_classifier\n    )\n    scorers_orchestrator.run(\n        travel_plan_json=travel_plan_json, scores_container=score_container\n    )\n    logger.info(\"Score Engines: End\")\n    return score_container", "\n\ndef get_cities_coordinates_of_same_country_destionation(\n    cities: Union[List[str], Tuple[str]], destination: str\n) -> Dict[str, Tuple]:\n    geo_coder = GeoCoder()\n    logger.info(\"Get Cities coordinates: Start\")\n    logger.debug(\"Get Cities coordinates: cities to analyze = {}\".format(cities))\n    logger.debug(\"Get Cities coordinates: destination = {}\".format(destination))\n    destination_country = destination.lower()\n    if not is_a_country(destination):\n        destination_country = geo_coder.country_from_location_name(destination).lower()\n        logger.debug(\n            \"Get Cities coordinates: destination country = {}\".format(\n                destination_country\n            )\n        )\n    cities_coordinates = {\n        city: tuple(coord for coord in geo_coder.location_coordinates(city).values())\n        for city in cities\n        if geo_coder.country_from_location_name(city).lower() == destination_country\n    }\n    logger.debug(\"Computed cities coordinates = {}\".format(cities_coordinates))\n    logger.info(\"Get Cities coordinates: End\")\n    return cities_coordinates", "\n\ndef is_a_country(place: str):\n    geo_coder = GeoCoder()\n    return geo_coder.is_a_country(place)\n"]}
{"filename": "src/gptravel/prototype/style.py", "chunked_list": ["COLOR_LABEL_ACTIVITY_DICT = {\n    \"culture\": \"#8dd3c7\",\n    \"monument\": \"#ff9900\",\n    \"transport\": \"#bebada\",\n    \"sport\": \"#fb8072\",\n    \"food\": \"#80b1d3\",\n    \"museum\": \"#fdb462\",\n    \"sea\": \"#b3de69\",\n    \"mountain\": \"#fccde5\",\n    \"relax\": \"#d9d9d9\",", "    \"mountain\": \"#fccde5\",\n    \"relax\": \"#d9d9d9\",\n    \"shopping\": \"#0066cc\",\n}\n\nLABEL_BOX_STYLE = (\n    \"font-family: 'Roboto', sans-serif; font-size: 14px;\"\n    \" color: black; border: 1px solid black; padding: 5px; \"\n    \"border-radius: 5px; padding: 2px;\"\n)", "    \"border-radius: 5px; padding: 2px;\"\n)\n"]}
{"filename": "src/gptravel/prototype/pages/home.py", "chunked_list": ["from datetime import datetime\n\nimport streamlit as st\n\nfrom gptravel.core.io.loggerconfig import logger\nfrom gptravel.core.services.geocoder import GeoCoder\nfrom gptravel.prototype import help as prototype_help\nfrom gptravel.prototype import utils as prototype_utils\nfrom gptravel.prototype.pages import travel as travel_page\n", "from gptravel.prototype.pages import travel as travel_page\n\n\ndef main():\n    \"\"\"\n    Main function for running GPTravel.\n\n    It allows users to input travel parameters and generates a travel plan when the \"Let's go!\" button is clicked.\n    \"\"\"\n    st.title(\"GPTravel \u2708\ufe0f\")\n    st.write(\"\\n\\n\")\n\n    openai_key = st.sidebar.text_input(\n        \"OpenAI API Key\",\n        help=prototype_help.OPENAI_KEY_HELP,\n        placeholder=\"Enter your OpenAI key here\",\n    )\n\n    departure_date = st.sidebar.date_input(\n        \"Select a date\", help=prototype_help.DEPARTURE_DATE_HELP\n    )\n\n    return_date = st.sidebar.date_input(\n        label=\"Select a return date\",\n        key=\"return_date\",\n        help=prototype_help.RETURN_DATE_HELP,\n    )\n\n    departure = st.sidebar.text_input(\n        label=\"Departure\",\n        placeholder=\"Select a departure\",\n        help=prototype_help.DEPARTURE_LOC_HELP,\n    )\n\n    destination = st.sidebar.text_input(\n        label=\"Destination\",\n        placeholder=\"Select a destination\",\n        help=prototype_help.DESTINATION_LOC_HELP,\n    )\n\n    travel_reason = st.sidebar.selectbox(\n        \"Select a travel reason\",\n        options=[\"\", \"Business\", \"Romantic\", \"Solo\", \"Friends\", \"Family\"],\n        help=prototype_help.TRAVEL_REASON_HELP,\n    )\n    travel_reason_strp = travel_reason.strip()\n    input_options = {\n        \"openai_key\": openai_key,\n        \"departure_date\": departure_date,\n        \"return_date\": return_date,\n        \"departure\": departure,\n        \"destination\": destination,\n        \"travel_reason\": None if travel_reason_strp == \"\" else travel_reason_strp,\n    }\n\n    if st.sidebar.button(\"Let's go!\"):\n        if _is_valid_input(\n            openai_key=openai_key,\n            departure_date=departure_date,\n            return_date=return_date,\n            departure=departure,\n            destination=destination,\n        ):\n            with st.spinner(\"Preparing your travel plan...\"):\n                travel_page.main(**input_options)", "\n\ndef _is_valid_input(\n    departure: str,\n    destination: str,\n    departure_date: datetime,\n    return_date: datetime,\n    openai_key: str,\n) -> bool:\n    \"\"\"\n    Check if the input parameters are valid.\n\n    Parameters\n    ----------\n    departure : str\n        Departure location.\n    destination : str\n        Destination location.\n    departure_date : datetime\n        Departure date.\n    return_date : datetime\n        Return date.\n    openai_key : str\n        OpenAI API key.\n\n    Returns\n    -------\n    bool\n        True if the input parameters are valid, False otherwise.\n    \"\"\"\n    geo_coder = GeoCoder()\n    if (not geo_coder.is_location_country_city_state(departure)) or (\n        not geo_coder.is_location_country_city_state(destination)\n    ):\n        warn_message = \"Travel destination or/and departure is not valid.\"\n        st.sidebar.warning(warn_message)\n        logger.warning(warn_message)\n        return False\n    if not prototype_utils.is_departure_before_return(\n        departure_date=departure_date, return_date=return_date\n    ):\n        warn_message = (\n            \"Travel dates are not correct. Departure should be before return.\"\n        )\n        st.sidebar.warning(warn_message)\n        logger.warning(warn_message)\n        return False\n    if not prototype_utils.is_valid_openai_key(openai_key):\n        warn_message = \"Not valid OpenAI API Access Key\"\n        st.sidebar.warning(warn_message)\n        logger.warning(warn_message)\n        return False\n\n    return True", ""]}
{"filename": "src/gptravel/prototype/pages/__init__.py", "chunked_list": ["from gptravel.core.services.geocoder import GeoCoder\n\ngeo_coder = GeoCoder()\n"]}
{"filename": "src/gptravel/prototype/pages/travel.py", "chunked_list": ["import os\nfrom datetime import datetime, timedelta\nfrom typing import Any, Dict, Tuple\n\nimport folium\nimport numpy as np\nimport streamlit as st\nfrom openai.error import RateLimitError\nfrom streamlit_folium import st_folium\n", "from streamlit_folium import st_folium\n\nfrom gptravel.core.io.loggerconfig import logger\nfrom gptravel.core.services.checker import DaysChecker, ExistingDestinationsChecker\nfrom gptravel.core.services.filters import DeparturePlaceFilter\nfrom gptravel.core.services.geocoder import GeoCoder\nfrom gptravel.core.travel_planner import openai_engine\nfrom gptravel.core.travel_planner.prompt import Prompt, PromptFactory\nfrom gptravel.core.travel_planner.token_manager import ChatGptTokenManager\nfrom gptravel.core.travel_planner.travel_engine import TravelPlanJSON", "from gptravel.core.travel_planner.token_manager import ChatGptTokenManager\nfrom gptravel.core.travel_planner.travel_engine import TravelPlanJSON\nfrom gptravel.prototype import help as prototype_help\nfrom gptravel.prototype import style as prototype_style\nfrom gptravel.prototype import utils as prototype_utils\n\n\ndef main(\n    openai_key: str,\n    departure: str,\n    destination: str,\n    departure_date: datetime,\n    return_date: datetime,\n    travel_reason: str,\n):\n    \"\"\"\n     Main function for running travel plan in GPTravel.\n     It generates a travel page and display all functionalities of the page.\n\n    Parameters\n    ----------\n    openai_key : str\n        OpenAI API key.\n    departure : str\n        Departure place.\n    destination : str\n        Destination place.\n    departure_date : datetime\n        Departure date.\n    return_date : datetime\n        Return date.\n    travel_reason : str\n        Reason for travel.\n    \"\"\"\n    try:\n        travel_plan_dict, score_dict = _get_travel_plan(\n            openai_key=openai_key,\n            departure=departure,\n            destination=destination,\n            departure_date=departure_date,\n            return_date=return_date,\n            travel_reason=travel_reason,\n        )\n    except RateLimitError as openai_rate_limit_error:\n        st.error(openai_rate_limit_error)\n\n    _show_travel_itinerary(travel_plan_dict, destination)\n\n    st.markdown(\n        f\"#### Overall Travel Score: \\t\\t\\t\\t\"\n        f\"{score_dict.weighted_score * 100:.0f} / 100\",\n        help=prototype_help.TRAVEL_SCORE_HELP,\n    )\n    _create_expanders_travel_plan(departure_date, score_dict, travel_plan_dict)", "\n\ndef _show_travel_itinerary(travel_plan_dict: Dict[str, Any], destination: str) -> None:\n    logger.info(\"Show travel itinerary map: Start\")\n    travel_plan_cities_names = tuple(\n        city for day in travel_plan_dict.keys() for city in travel_plan_dict[day].keys()\n    )\n    cities_coordinates = (\n        prototype_utils.get_cities_coordinates_of_same_country_destionation(\n            cities=travel_plan_cities_names, destination=destination\n        )\n    )\n    logger.debug(\"Computed coordinates = {}\".format(cities_coordinates))\n    coordinates_array = np.array(\n        [[coords[0], coords[1]] for coords in cities_coordinates.values()]\n    )\n    mean_point_coordinates = np.median(coordinates_array, axis=0)\n    zoom_start = 6 if prototype_utils.is_a_country(destination) else 8\n    m = folium.Map(location=mean_point_coordinates, zoom_start=zoom_start)\n\n    for city, coordinates in cities_coordinates.items():\n        folium.Marker(coordinates, popup=city, tooltip=city).add_to(m)\n\n    # call to render Folium map in Streamlit\n    st_folium(m, height=400, width=1000, returned_objects=[])\n    logger.info(\"Show travel itinerary map: Start\")", "\n\n@st.cache_data(show_spinner=False)\ndef _get_travel_plan(\n    openai_key: str,\n    departure: str,\n    destination: str,\n    departure_date: datetime,\n    return_date: datetime,\n    travel_reason: str,\n) -> Tuple[Dict[Any, Any], prototype_utils.TravelPlanScore]:\n    \"\"\"\n    Get the travel plan and score dictionary.\n\n    Parameters\n    ----------\n    openai_key : str\n        OpenAI API key.\n    departure : str\n        Departure place.\n    destination : str\n        Destination place.\n    departure_date : datetime\n        Departure date.\n    return_date : datetime\n        Return date.\n    travel_reason : str\n        Reason for travel.\n\n    Returns\n    -------\n    Tuple[Dict[Any, Any], TravelPlanScore]\n        A tuple containing the travel plan dictionary and the travel plan score.\n    \"\"\"\n    os.environ[\"OPENAI_API_KEY\"] = openai_key\n    n_days = (return_date - departure_date).days + 1\n    travel_parameters = {\n        \"departure_place\": departure,\n        \"destination_place\": destination,\n        \"n_travel_days\": n_days,\n        \"travel_theme\": travel_reason,\n    }\n    token_manager = ChatGptTokenManager()\n    geocoder = GeoCoder()\n    travel_distance = geocoder.location_distance(departure, destination)\n    max_number_tokens = token_manager.get_number_tokens(\n        n_days=n_days, distance=travel_distance\n    )\n    travel_plan_json = _get_travel_plan_json(\n        travel_parameters=travel_parameters, max_tokens=max_number_tokens\n    )\n    checker = ExistingDestinationsChecker(geocoder)\n    checker.check(travel_plan_json)\n    travel_plan_dict = travel_plan_json.travel_plan\n\n    score_dict = prototype_utils.get_score_map(travel_plan_json)\n\n    return travel_plan_dict, score_dict", "\n\ndef _get_travel_plan_json(\n    travel_parameters: Dict[str, Any], max_tokens: int\n) -> TravelPlanJSON:\n    \"\"\"\n    Retrieves the travel plan JSON based on the provided prompt.\n\n    Args:\n        travel_parameters (Dict[str, Any]): travel parameters for plan generation.\n\n    Returns:\n        TravelPlanJSON: Travel plan JSON.\n    \"\"\"\n    logger.info(\"Building Prompt with travel parameters\")\n    prompt = _build_prompt(travel_parameters)\n    logger.info(\"Prompt Built successfully\")\n    logger.info(\"Generating Travel Plan: Start\")\n    engine = openai_engine.ChatGPTravelEngine(max_tokens=max_tokens)\n    generated_travel_plan = engine.get_travel_plan_json(prompt)\n    logger.info(\"Generating Travel Plan: End\")\n    travel_filter = DeparturePlaceFilter()\n    travel_filter.filter(generated_travel_plan)\n    days_checker = DaysChecker()\n    if not days_checker.check(generated_travel_plan):\n        logger.warning(\"Completing Travel Plan due to missing days\")\n        travel_parameters[\"complention_travel_plan\"] = True\n        travel_parameters[\"n_days_to_add\"] = (\n            generated_travel_plan.n_days - days_checker.travel_days\n        )\n        travel_parameters[\"travel_plan\"] = generated_travel_plan.travel_plan\n        completion_prompt = _build_prompt(travel_parameters)\n        generated_travel_plan = engine.get_travel_plan_json(completion_prompt)\n    return generated_travel_plan", "\n\ndef _build_prompt(travel_parameters: Dict[str, Any]) -> Prompt:\n    \"\"\"\n    Builds the prompt for the travel plan based on the travel parameters.\n\n    Args:\n        travel_parameters (Dict[str, Any]): Travel parameters.\n\n    Returns:\n        Prompt: Prompt for the travel plan.\n    \"\"\"\n    prompt_factory = PromptFactory()\n    logger.debug(\"Building Prompt with parameters = {}\".format(travel_parameters))\n    prompt = prompt_factory.build_prompt(**travel_parameters)\n    return prompt", "\n\ndef _create_expanders_travel_plan(\n    departure_date: datetime,\n    score_dict: prototype_utils.TravelPlanScore,\n    travel_plan_dict: Dict[Any, Any],\n) -> None:\n    \"\"\"\n    Create expanders for displaying the travel plan.\n\n    Parameters\n    ----------\n    departure_date : datetime\n        Departure date.\n    score_dict : prototype_utils.TravelPlanScore\n        Score container object.\n    travel_plan_dict : Dict[Any, Any]\n        Travel plan dictionary.\n    \"\"\"\n    for day_num, (day_key, places_dict) in enumerate(travel_plan_dict.items()):\n        date_str = (departure_date + timedelta(days=int(day_num))).strftime(\"%d-%m-%Y\")\n        expander_day_num = st.expander(f\"{day_key} ({date_str})\", expanded=True)\n        for place, activities in places_dict.items():\n            expander_day_num.markdown(f\"**{place}**\")\n            for activity in activities:\n                activity_descr = f\" {activity}\"\n                ### TODO (RC): add an if when filtered activities is empty; take the argmax\n                filtered_activities = filter(\n                    lambda x: x[1] > 0.5,\n                    score_dict.score_map[\"Activities Variety\"][\"labeled_activities\"][\n                        activity\n                    ].items(),\n                )\n                sorted_filtered_activities = sorted(\n                    filtered_activities, key=lambda x: x[1], reverse=True\n                )\n                activity_label = \" \".join(\n                    f'<span style=\"background-color:{prototype_style.COLOR_LABEL_ACTIVITY_DICT[label]}; {prototype_style.LABEL_BOX_STYLE}\">\\t\\t<b>{label.upper()}</b></span>'\n                    for label, _ in sorted_filtered_activities\n                )\n                expander_day_num.markdown(\n                    f\"- {activity_label} {activity_descr}\\n\", unsafe_allow_html=True\n                )", ""]}
{"filename": "src/gptravel/core/io/loggerconfig.py", "chunked_list": ["import logging\nimport os\n\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nLOGLEVEL = os.environ.get(\"LOGLEVEL\", \"INFO\").upper()\nFORMAT = \"[%(asctime)s - %(levelname)s] %(message)s\"\nlogger = logging.getLogger(__name__)", "FORMAT = \"[%(asctime)s - %(levelname)s] %(message)s\"\nlogger = logging.getLogger(__name__)\nlogger.setLevel(LOGLEVEL)\nhandler = logging.StreamHandler()\nhandler.setLevel(LOGLEVEL)\nformatter = logging.Formatter(FORMAT)\nhandler.setFormatter(formatter)\nlogger.addHandler(handler)\n", ""]}
{"filename": "src/gptravel/core/utils/general.py", "chunked_list": ["from typing import Any, Dict, List\n\n\ndef extract_keys_by_depth_from_json(json_obj: Dict[Any, Any], ndepth: int) -> List[Any]:\n    keys = []\n\n    def _extract_keys(json_obj: Dict[Any, Any], curr_depth: int) -> None:\n        for key, value in json_obj.items():\n            if curr_depth == ndepth:\n                keys.append(key)\n            elif isinstance(value, dict):\n                _extract_keys(value, curr_depth + 1)\n\n    _extract_keys(json_obj, 0)\n    return keys", "\n\ndef extract_inner_lists_from_json(json_obj: Dict[Any, Any]) -> List[Any]:\n    activities = []\n    if isinstance(json_obj, dict):\n        for value in json_obj.values():\n            activities.extend(extract_inner_lists_from_json(value))\n    elif isinstance(json_obj, list):\n        activities.extend(json_obj)\n    return activities", ""]}
{"filename": "src/gptravel/core/utils/regex_tool.py", "chunked_list": ["from typing import List\n\nimport regex\n\n\nclass JsonExtractor:\n    def __init__(self) -> None:\n        self._pattern = regex.compile(r\"\\{(?:[^{}]|(?R))*\\}\")\n\n    def __call__(self, text: str) -> List[str]:\n        return self._pattern.findall(text)", ""]}
{"filename": "src/gptravel/core/travel_planner/token_manager.py", "chunked_list": ["from abc import ABC, abstractmethod\n\nimport numpy as np\n\nfrom gptravel.core.io.loggerconfig import logger\n\n\nclass TokenManager(ABC):\n    @abstractmethod\n    def get_number_tokens(self, **kwargs) -> int:\n        pass", "\n\nclass ChatGptTokenManager(TokenManager):\n    def __init__(self) -> None:\n        self._intercept = 382.889143408946\n        self._ndays_coef = 37.3394858556992\n        self._distance_coef = -0.000176874844641827\n\n    def get_number_tokens(self, **kwargs) -> int:\n        logger.debug(\"Computing max number of tokens for chatgpt engine\")\n        logger.debug(\n            \"Token Manager inputs: n_days = {}, travel_distance = {}\".format(\n                kwargs[\"n_days\"], kwargs[\"distance\"]\n            )\n        )\n        n_tokens = int(\n            np.ceil(\n                max(\n                    self._intercept\n                    + self._ndays_coef * kwargs[\"n_days\"]\n                    + self._distance_coef * kwargs[\"distance\"],\n                    self._intercept,\n                )\n            )\n        )\n        logger.debug(\"Max number of tokens computed = {}\".format(n_tokens))\n        return n_tokens", ""]}
{"filename": "src/gptravel/core/travel_planner/prompt.py", "chunked_list": ["import json\nfrom abc import ABC, abstractmethod\nfrom collections import defaultdict\nfrom inspect import cleandoc\nfrom typing import Any, Dict\n\n\nclass Prompt(ABC):\n    def __init__(\n        self,\n        prompt: str,\n        departure_place: str,\n        destination_place: str,\n        n_travel_days: int,\n    ) -> None:\n        self._prompt = prompt\n        self._departure_place = departure_place\n        self._destination_place = destination_place\n        self._n_travel_days = n_travel_days\n\n    @property\n    def prompt(self) -> str:\n        return cleandoc(self._prompt)\n\n    @property\n    def departure_place(self) -> str:\n        return self._departure_place\n\n    @property\n    def destination_place(self) -> str:\n        return self._destination_place\n\n    @property\n    def n_travel_days(self) -> int:\n        return self._n_travel_days\n\n    @property\n    @abstractmethod\n    def json_keys(self) -> Dict[str, int]:\n        pass", "\n\nclass PlainTravelPrompt(Prompt):\n    def __init__(\n        self,\n        departure_place: str,\n        destination_place: str,\n        n_travel_days: int,\n        **kwargs,\n    ) -> None:\n        prompt = f\"\"\"Generate a JSON with inside a travel plan of {n_travel_days} days for a person who wants to visit {destination_place} from\n          {departure_place}. The structure of the JSON must be the following:\n          {{\"Day x\": {{\"City\": [\"activity 1\", \"activity2\",...], \"City\": [\"activity 1\", ...]}} , \"Day x+1\": {{\"City\": [...], \"City\": [...]}} }} \n          where City field is the city visited in the corresponding Day.\"\"\"\n        super().__init__(prompt, departure_place, destination_place, n_travel_days)\n\n    @property\n    def json_keys(self) -> Dict[str, int]:\n        return {\"day\": 0, \"city\": 1}", "\n\nclass ThematicTravelPrompt(Prompt):\n    def __init__(\n        self,\n        departure_place: str,\n        destination_place: str,\n        n_travel_days: int,\n        travel_theme: str,\n        **kwargs,\n    ) -> None:\n        prompt = f\"\"\"Generate a JSON with inside a travel plan of {n_travel_days} days for a person who wants to visit {destination_place} from\n          {departure_place}. The theme of the travel is {travel_theme}.\n          The structure of the JSON must be the following:\n          {{\"Day x\": {{\"City\": [\"activity 1\", \"activity2\",...], \"City\": [\"activity 1\", ...]}} , \"Day x+1\": {{\"City\": [...], \"City\": [...]}} }} \n          where City field is the city visited in the corresponding Day.\"\"\"\n        super().__init__(prompt, departure_place, destination_place, n_travel_days)\n\n    @property\n    def json_keys(self) -> Dict[str, int]:\n        return {\"day\": 0, \"city\": 1}", "\n\nclass CompletionTravelPrompt(Prompt):\n    def __init__(\n        self,\n        departure_place: str,\n        destination_place: str,\n        n_travel_days: int,\n        n_days_to_add: int,\n        travel_plan: Dict[Any, Any],\n        **kwargs,\n    ) -> None:\n        dumped_json = json.dumps(travel_plan)\n        prompt = f\"\"\"Rewrite the following travel plan where the destination is {destination_place} by adding {n_days_to_add} days:\n                     {dumped_json}\"\"\"\n        super().__init__(prompt, departure_place, destination_place, n_travel_days)\n\n    @property\n    def json_keys(self) -> Dict[str, int]:\n        return {\"day\": 0, \"city\": 1}", "\n\nclass PromptFactory:\n    def __init__(self) -> None:\n        pass\n\n    @staticmethod\n    def build_prompt(**kwargs) -> Prompt:\n        kwargs = defaultdict(str, kwargs)\n        if kwargs[\"complention_travel_plan\"]:\n            return CompletionTravelPrompt(**kwargs)\n        if kwargs[\"travel_theme\"]:\n            return ThematicTravelPrompt(**kwargs)\n        return PlainTravelPrompt(**kwargs)", ""]}
{"filename": "src/gptravel/core/travel_planner/openai_engine.py", "chunked_list": ["import json\nfrom abc import ABC, abstractmethod\nfrom typing import Any, Dict, Optional\n\nimport openai\n\nfrom gptravel.core.io.loggerconfig import logger\nfrom gptravel.core.travel_planner.prompt import Prompt\nfrom gptravel.core.travel_planner.travel_engine import TravelEngine, TravelPlanJSON\n", "from gptravel.core.travel_planner.travel_engine import TravelEngine, TravelPlanJSON\n\n\nclass OpenAITravelEngine(TravelEngine, ABC):\n    def __init__(\n        self,\n        model: str,\n        max_tokens: int,\n        temperature: float,\n        top_p: float,\n        frequency_penalty: float,\n        presence_penalty: float,\n    ) -> None:\n        super().__init__()\n        assert (presence_penalty >= 0.0) & (presence_penalty <= 2.0)\n        assert (frequency_penalty >= 0.0) & (frequency_penalty <= 2.0)\n        self._model = model\n        self._temperature = temperature\n        self._max_tokens = max_tokens\n        self._top_p = top_p\n        self._frequency_penalty = frequency_penalty\n        self._presence_penalty = presence_penalty\n        self._finish_reason: Optional[str] = None\n        self._total_tokens: Optional[int] = None\n\n    @abstractmethod\n    def _openai_call(self, prompt: Prompt) -> Dict[Any, Any]:\n        pass\n\n    def get_travel_plan_json(self, prompt: Prompt) -> TravelPlanJSON:\n        response = self._openai_call(prompt)\n        message_response = response[\"choices\"][0][\"message\"][\"content\"]\n        logger.debug(\"Applying regex on OpenAI GPT response\")\n        json_parsed_list = self._regex(message_response)\n        if len(json_parsed_list) > 1:\n            logger.warning(\"Found multiple json in travel planner response\")\n        logger.debug(\"Regex complete successfully\")\n        try:\n            json_object = json.loads(json_parsed_list[0])\n        except json.decoder.JSONDecodeError:\n            json_object = json.loads(\n                r\"{}\".format(json_parsed_list[0].replace(\"'\", '\"'))\n            )\n        return TravelPlanJSON(\n            departure_place=prompt.departure_place,\n            destination_place=prompt.destination_place,\n            n_days=prompt.n_travel_days,\n            travel_plan_json=json_object,\n            json_keys_depth_map=prompt.json_keys,\n        )\n\n    @property\n    def finish_reason(self) -> Optional[str]:\n        return self._finish_reason\n\n    @property\n    def total_tokens(self) -> Optional[int]:\n        return self._total_tokens", "\n\nclass ChatGPTravelEngine(OpenAITravelEngine):\n    def __init__(\n        self,\n        temperature: float = 1.0,\n        top_p: float = 1.0,\n        frequency_penalty: float = 0.0,\n        presence_penalty: float = 0.0,\n        number_chat_completions: int = 1,\n        max_tokens: int = 280,\n    ) -> None:\n        model = \"gpt-3.5-turbo\"\n        super().__init__(\n            model, max_tokens, temperature, top_p, frequency_penalty, presence_penalty\n        )\n        self._max_tokens = min(self._max_tokens, 4096)  # max token for this engine\n        self._n = number_chat_completions\n\n    def _openai_call(self, prompt: Prompt) -> Dict[Any, Any]:\n        logger.debug(\"Fetching travel plan with ChatGpt engine API: Start\")\n        api_output = openai.ChatCompletion.create(\n            model=self._model,\n            messages=[\n                {\"role\": \"system\", \"content\": \"You are an expert travel planner.\"},\n                {\"role\": \"user\", \"content\": prompt.prompt},\n            ],\n            temperature=self._temperature,\n            max_tokens=self._max_tokens,\n            top_p=self._top_p,\n            presence_penalty=self._presence_penalty,\n            frequency_penalty=self._frequency_penalty,\n            n=self._n,\n        )\n        logger.debug(\"Fetching travel plan with ChatGpt engine API: Complete\")\n        self._finish_reason = api_output[\"choices\"][0][\"finish_reason\"]\n        self._total_tokens = api_output[\"usage\"][\"total_tokens\"]\n        logger.debug(\"OpenAI API: finish reason= {}\".format(self._finish_reason))\n        logger.debug(\"OpenAI API: total tokens = {}\".format(self._total_tokens))\n        return api_output", "\n\nclass CompletionGPTravelEngine(OpenAITravelEngine):\n    def __init__(\n        self,\n        model: str,\n        temperature: float = 1.0,\n        top_p: float = 1.0,\n        frequency_penalty: float = 0.0,\n        presence_penalty: float = 0.0,\n        max_tokens: int = 280,\n    ) -> None:\n        super().__init__(\n            model, max_tokens, temperature, top_p, frequency_penalty, presence_penalty\n        )\n\n    def _openai_call(self, prompt: Prompt) -> Dict[Any, Any]:\n        logger.debug(\"Fetching travel plan with ChatGpt engine API: Start\")\n        api_output = openai.Completion.create(\n            model=self._model,\n            prompt=prompt.prompt,\n            temperature=self._temperature,\n            max_tokens=self._max_tokens,\n            top_p=self._top_p,\n            presence_penalty=self._presence_penalty,\n            frequency_penalty=self._frequency_penalty,\n        )\n        logger.debug(\"Fetching travel plan with ChatGpt engine API: Complete\")\n        self._finish_reason = api_output[\"choices\"][0][\"finish_reason\"]\n        self._total_tokens = api_output[\"usage\"][\"total_tokens\"]\n        logger.debug(\"OpenAI API: finish reason= {}\".format(self._finish_reason))\n        logger.debug(\"OpenAI API: total tokens = {}\".format(self._total_tokens))\n        return api_output", ""]}
{"filename": "src/gptravel/core/travel_planner/travel_engine.py", "chunked_list": ["from abc import ABC, abstractmethod\nfrom typing import Any, Dict, List\n\nfrom gptravel.core.travel_planner.prompt import Prompt\nfrom gptravel.core.utils.general import (\n    extract_inner_lists_from_json,\n    extract_keys_by_depth_from_json,\n)\nfrom gptravel.core.utils.regex_tool import JsonExtractor\n", "from gptravel.core.utils.regex_tool import JsonExtractor\n\n\nclass TravelPlanJSON:\n    def __init__(\n        self,\n        departure_place: str,\n        destination_place: str,\n        n_days: int,\n        travel_plan_json: Dict[Any, Any],\n        json_keys_depth_map: Dict[str, int],\n        **kwargs\n    ) -> None:\n        self._n_days = n_days\n        self._departure_place = departure_place\n        self._destination_place = destination_place\n        self._travel_plan = travel_plan_json\n        self._keys_map = json_keys_depth_map\n\n    @property\n    def departure_place(self) -> str:\n        return self._departure_place\n\n    @property\n    def destination_place(self) -> str:\n        return self._destination_place\n\n    @property\n    def n_days(self) -> int:\n        return self._n_days\n\n    @property\n    def travel_plan(self) -> Dict[Any, Any]:\n        return self._travel_plan\n\n    @property\n    def keys_map(self) -> Dict[str, int]:\n        return self._keys_map\n\n    @property\n    def travel_activities(self) -> List[str]:\n        return extract_inner_lists_from_json(self._travel_plan)\n\n    def get_key_values_by_depth(self, depth: int) -> List[Any]:\n        return extract_keys_by_depth_from_json(json_obj=self._travel_plan, ndepth=depth)\n\n    def get_key_values_by_name(self, key_name: str) -> List[Any]:\n        try:\n            return self.get_key_values_by_depth(self._keys_map[key_name])\n        except KeyError:\n            return []\n\n    @property\n    def travel_cities(self) -> List[str]:\n        return self.get_key_values_by_name(\"city\")", "\n\nclass TravelEngine(ABC):\n    def __init__(self) -> None:\n        self._regex = JsonExtractor()\n\n    @abstractmethod\n    def get_travel_plan_json(self, prompt: Prompt) -> TravelPlanJSON:\n        pass\n", ""]}
{"filename": "src/gptravel/core/services/score_builder.py", "chunked_list": ["from gptravel.core.services.engine.classifier import TextClassifier\nfrom gptravel.core.services.geocoder import GeoCoder\nfrom gptravel.core.services.scorer import (\n    ActivitiesDiversityScorer,\n    CitiesCountryScorer,\n    DayGenerationScorer,\n    OptimizedItineraryScorer,\n    TravelPlanScore,\n)\nfrom gptravel.core.travel_planner.travel_engine import TravelPlanJSON", ")\nfrom gptravel.core.travel_planner.travel_engine import TravelPlanJSON\n\n\nclass ScorerOrchestrator:\n    def __init__(self, geocoder: GeoCoder, text_classifier: TextClassifier) -> None:\n        self._scorers = [\n            ActivitiesDiversityScorer(text_classifier),\n            DayGenerationScorer(),\n            CitiesCountryScorer(geolocator=geocoder),\n            OptimizedItineraryScorer(geolocator=geocoder),\n        ]\n\n    def run(\n        self, travel_plan_json: TravelPlanJSON, scores_container: TravelPlanScore\n    ) -> None:\n        for scorer in self._scorers:\n            scorer.score(\n                travel_plan=travel_plan_json, travel_plan_scores=scores_container\n            )", ""]}
{"filename": "src/gptravel/core/services/config.py", "chunked_list": ["ACTIVITIES_LABELS = [\n    \"mountain\",\n    \"sea\",\n    \"museum\",\n    \"monument\",\n    \"food\",\n    \"relax\",\n    \"sport\",\n    \"culture\",\n    \"shopping\",", "    \"culture\",\n    \"shopping\",\n    \"transport\",\n]\n"]}
{"filename": "src/gptravel/core/services/utils.py", "chunked_list": ["import math\nfrom typing import Any, List, Union\n\nfrom gptravel.core.services.engine.classifier import ZeroShotTextClassifier\n\n\ndef theil_diversity_entropy_index(groups: List[Union[float, int]]) -> float:\n    total_population = sum(groups)\n    proportions = [group_size / total_population for group_size in groups]\n    entropy = -sum(\n        [\n            proportion * math.log(proportion)\n            for proportion in proportions\n            if proportion != 0\n        ]\n    )\n    max_entropy = math.log(len(groups))\n    return (max_entropy - entropy) / max_entropy", "\n\ndef weighted_average(\n    values: List[Union[int, float]], weights: List[Union[int, float]]\n) -> float:\n    assert len(values) == len(weights)\n    return sum([values[i] * weights[i] for i in range(len(values))]) / sum(weights)\n\n\ndef is_location_a_country(location: str) -> bool:\n    country_value = \"country\"\n    key_with_max_value = \"\"\n    if \"milan\" not in location.lower():\n        classifier = ZeroShotTextClassifier(False)\n        labels = [country_value, \"city\", \"continent\"]\n        prediction = classifier.predict(\n            input_text_list=[location], label_classes=labels\n        )\n        key_with_max_value = max(\n            prediction[location], key=lambda key: prediction[location][key]\n        )\n    return True if key_with_max_value == country_value else False", "\ndef is_location_a_country(location: str) -> bool:\n    country_value = \"country\"\n    key_with_max_value = \"\"\n    if \"milan\" not in location.lower():\n        classifier = ZeroShotTextClassifier(False)\n        labels = [country_value, \"city\", \"continent\"]\n        prediction = classifier.predict(\n            input_text_list=[location], label_classes=labels\n        )\n        key_with_max_value = max(\n            prediction[location], key=lambda key: prediction[location][key]\n        )\n    return True if key_with_max_value == country_value else False", "\n\ndef remove_consecutive_duplicates(input_list: List[Any]) -> List[Any]:\n    return [\n        elem for i, elem in enumerate(input_list) if i == 0 or input_list[i - 1] != elem\n    ]\n"]}
{"filename": "src/gptravel/core/services/filters.py", "chunked_list": ["from abc import ABC, abstractmethod\n\nfrom gptravel.core.io.loggerconfig import logger\nfrom gptravel.core.travel_planner.travel_engine import TravelPlanJSON\n\n\nclass Filter(ABC):\n    def __init__(self, **kwargs):\n        pass\n\n    @abstractmethod\n    def filter(self, travel_plan: TravelPlanJSON) -> None:\n        pass", "\n\nclass DeparturePlaceFilter(Filter):\n    def filter(self, travel_plan: TravelPlanJSON) -> None:\n        logger.debug(\"DeparturePlaceFilter: Start\")\n        departure_place = travel_plan.departure_place.lower()\n        # if the departure place is present in the travel plan then remove it\n        if departure_place in [city.lower() for city in travel_plan.travel_cities]:\n            logger.debug(\"Found {} inside the travel plan\".format(departure_place))\n            day_depth = travel_plan.keys_map[\"day\"]\n            if day_depth == 0:\n                days_to_drop = []\n                for day in travel_plan.travel_plan.keys():\n                    key_to_remove = [\n                        city\n                        for city in travel_plan.travel_plan[day].keys()\n                        if city.lower() == departure_place\n                    ]\n                    if key_to_remove:\n                        logger.debug(\n                            \"Removed {} from the travel plan for {}\".format(\n                                departure_place, day\n                            )\n                        )\n                        del travel_plan.travel_plan[day][key_to_remove[0]]\n                    # if the day container is empty then remove it\n                    if travel_plan.travel_plan[day] == {}:\n                        days_to_drop.append(day)\n                        logger.debug(\n                            \"Removed {} completely from the travel plan\".format(day)\n                        )\n                if days_to_drop:\n                    for day_to_delete in days_to_drop:\n                        del travel_plan.travel_plan[day_to_delete]\n                    # fix the order of the\n                    day_first_word = days_to_drop[0].split(\" \")[0]\n                    day_keys = list(travel_plan.travel_plan.keys())\n                    n = 1\n                    for old_key in day_keys:\n                        new_key = day_first_word + \" \" + str(n)\n                        travel_plan.travel_plan[new_key] = travel_plan.travel_plan.pop(\n                            old_key\n                        )\n                        n += 1\n            else:\n                key_to_remove = [\n                    city\n                    for city in travel_plan.travel_plan.keys()\n                    if city.lower() == departure_place\n                ][0]\n                del travel_plan.travel_plan[key_to_remove]\n        logger.debug(\"DeparturePlaceFilter: End\")", ""]}
{"filename": "src/gptravel/core/services/scorer.py", "chunked_list": ["from abc import ABC, abstractmethod\nfrom typing import Any, Dict, Optional, Union\n\nfrom gptravel.core.io.loggerconfig import logger\nfrom gptravel.core.services.config import ACTIVITIES_LABELS\nfrom gptravel.core.services.engine.classifier import TextClassifier\nfrom gptravel.core.services.engine.tsp_solver import TSPSolver\nfrom gptravel.core.services.geocoder import GeoCoder\nfrom gptravel.core.services.utils import (\n    remove_consecutive_duplicates,", "from gptravel.core.services.utils import (\n    remove_consecutive_duplicates,\n    theil_diversity_entropy_index,\n    weighted_average,\n)\nfrom gptravel.core.travel_planner.travel_engine import TravelPlanJSON\n\n\nclass TravelPlanScore:\n    def __init__(self) -> None:\n        self._score_map: Dict[str, Dict[str, Union[float, int]]] = {}\n        self._score_value_key = \"score_value\"\n        self._score_weight_key = \"score_weight\"\n        self._required_keys = set([self._score_value_key, self._score_weight_key])\n\n    def add_score(self, score_type: str, score_dict: Dict[str, Any]) -> None:\n        assert set(score_dict.keys()).intersection(self._required_keys) == set(\n            self._required_keys\n        )\n        self._score_map.update({score_type: score_dict})\n\n    @property\n    def score_value_key(self) -> str:\n        return self._score_value_key\n\n    @property\n    def score_weight_key(self) -> str:\n        return self._score_weight_key\n\n    @property\n    def score_map(self) -> Dict[str, Dict[str, Union[float, int]]]:\n        return self._score_map\n\n    @property\n    def weighted_score(self) -> Optional[float]:\n        if self._score_map:\n            weights = [\n                score[self._score_weight_key] for score in self._score_map.values()\n            ]\n            values = [\n                score[self._score_value_key] for score in self._score_map.values()\n            ]\n            return weighted_average(values=values, weights=weights)\n        return None", "class TravelPlanScore:\n    def __init__(self) -> None:\n        self._score_map: Dict[str, Dict[str, Union[float, int]]] = {}\n        self._score_value_key = \"score_value\"\n        self._score_weight_key = \"score_weight\"\n        self._required_keys = set([self._score_value_key, self._score_weight_key])\n\n    def add_score(self, score_type: str, score_dict: Dict[str, Any]) -> None:\n        assert set(score_dict.keys()).intersection(self._required_keys) == set(\n            self._required_keys\n        )\n        self._score_map.update({score_type: score_dict})\n\n    @property\n    def score_value_key(self) -> str:\n        return self._score_value_key\n\n    @property\n    def score_weight_key(self) -> str:\n        return self._score_weight_key\n\n    @property\n    def score_map(self) -> Dict[str, Dict[str, Union[float, int]]]:\n        return self._score_map\n\n    @property\n    def weighted_score(self) -> Optional[float]:\n        if self._score_map:\n            weights = [\n                score[self._score_weight_key] for score in self._score_map.values()\n            ]\n            values = [\n                score[self._score_value_key] for score in self._score_map.values()\n            ]\n            return weighted_average(values=values, weights=weights)\n        return None", "\n\nclass ScoreService(ABC):\n    def __init__(self, service_name: str, score_weight: float) -> None:\n        self._service_name = service_name\n        self.score_weight = score_weight\n\n    @abstractmethod\n    def score(\n        self, travel_plan: TravelPlanJSON, travel_plan_scores: TravelPlanScore\n    ) -> None:\n        pass\n\n    @property\n    def score_weight(self) -> float:\n        return self._score_weight\n\n    @score_weight.setter\n    def score_weight(self, score_weight: float) -> None:\n        assert (score_weight >= 0.0) & (score_weight <= 1.0)\n        self._score_weight = score_weight\n\n    @property\n    def service_name(self) -> str:\n        return self._service_name", "\n\nclass ActivitiesDiversityScorer(ScoreService):\n    def __init__(\n        self, text_classifier: TextClassifier, score_weight: float = 0.8\n    ) -> None:\n        service_name = \"Activities Variety\"\n        super().__init__(service_name, score_weight)\n        self._classifier = text_classifier\n        self._activities_labels = ACTIVITIES_LABELS\n\n    def score(\n        self, travel_plan: TravelPlanJSON, travel_plan_scores: TravelPlanScore\n    ) -> None:\n        logger.debug(\"ActivitiesDiversityScorer: Start\")\n        activities_list = travel_plan.travel_activities\n        labeled_activities = self._classifier.predict(\n            input_text_list=activities_list, label_classes=self._activities_labels\n        )\n        aggregated_scores = {\n            key: sum(item[key] for item in labeled_activities.values())\n            for key in self._activities_labels\n        }\n        sum_scores = sum(aggregated_scores.values())\n        aggregated_scores_normalized = {\n            key: item / sum_scores for key, item in aggregated_scores.items()\n        }\n        score = 1.0 - theil_diversity_entropy_index(\n            list(aggregated_scores_normalized.values())\n        )\n        logger.debug(\"ActivitiesDiversityScorer: score value = {}\".format(score))\n        logger.debug(\n            \"ActivitiesDiversityScorer: score weight = {}\".format(self._score_weight)\n        )\n        travel_plan_scores.add_score(\n            score_type=self._service_name,\n            score_dict={\n                travel_plan_scores.score_value_key: score,\n                travel_plan_scores.score_weight_key: self._score_weight,\n                \"activities_distribution\": aggregated_scores_normalized,\n                \"labeled_activities\": labeled_activities,\n            },\n        )\n        logger.debug(\"ActivitiesDiversityScorer: Complete\")", "\n\nclass DayGenerationScorer(ScoreService):\n    def __init__(self, score_weight: float = 0.4, day_key: str = \"Day\") -> None:\n        service_name = \"Day Coherence\"\n        super().__init__(service_name, score_weight)\n        self._day_key = day_key\n\n    def score(\n        self, travel_plan: TravelPlanJSON, travel_plan_scores: TravelPlanScore\n    ) -> None:\n        logger.debug(\"DayGenerationScorer: Start\")\n        required_days_by_the_user = travel_plan.n_days\n        travel_plan_day_list = list(\n            set(travel_plan.get_key_values_by_name(self._day_key.lower()))\n        )\n        travel_plan_days = [\n            int(item.split(self._day_key)[-1]) for item in travel_plan_day_list\n        ]\n        min_day = min(travel_plan_days)\n        tot_planned_days = len(travel_plan_days)\n        score = (\n            1.0\n            - abs(required_days_by_the_user - tot_planned_days)\n            / required_days_by_the_user\n        )\n        logger.debug(\"DayGenerationScorer: score value = {}\".format(score))\n        logger.debug(\n            \"DayGenerationScorer: score weight = {}\".format(self._score_weight)\n        )\n        if score < 1:\n            self.score_weight = min(self.score_weight * 1.5, 1)\n            logger.debug(\n                \"DayGenerationScorer: modified score weight = {}\".format(\n                    self._score_weight\n                )\n            )\n        expected_list = [min_day + item for item in range(required_days_by_the_user)]\n        extra_days_in_travel = set(travel_plan_days) - set(expected_list).intersection(\n            travel_plan_days\n        )\n        missing_days_in_travel = set(expected_list) - set(expected_list).intersection(\n            travel_plan_days\n        )\n        if len(missing_days_in_travel):\n            logger.debug(\n                \"DayGenerationScorer: missing days in travel plan = {}\".format(\n                    missing_days_in_travel\n                )\n            )\n        travel_plan_scores.add_score(\n            score_type=self._service_name,\n            score_dict={\n                travel_plan_scores.score_value_key: score,\n                travel_plan_scores.score_weight_key: self._score_weight,\n                \"misaligned_days\": {\n                    \"extra_days\": list(extra_days_in_travel),\n                    \"missing_days\": list(missing_days_in_travel),\n                },\n            },\n        )\n        logger.debug(\"DayGenerationScorer: End\")", "\n\nclass CitiesCountryScorer(ScoreService):\n    def __init__(self, geolocator: GeoCoder, score_weight: float = 1.0) -> None:\n        service_name = \"City Countries\"\n        super().__init__(service_name, score_weight)\n        self._geolocator = geolocator\n\n    def score(\n        self, travel_plan: TravelPlanJSON, travel_plan_scores: TravelPlanScore\n    ) -> None:\n        logger.debug(\"CitiesCountryScorer: Start\")\n        # remove departure place: check the consistence among the visiting cities\n        unique_cities = list(\n            set(travel_plan.travel_cities) - set(travel_plan.departure_place)\n        )\n        # Check that all the cities are in the same emisphere as first start element\n        weight_for_latitude = 0.4\n        latitude_signs = [\n            1 if self._geolocator.location_coordinates(city)[\"lat\"] > 0 else -1\n            for city in unique_cities\n        ]\n        latitude_score = abs(sum(latitude_signs)) / len(unique_cities)\n        # Check cities are in the same country of the destination place\n        destination_country = self._geolocator.country_from_location_name(\n            location_name=travel_plan.destination_place\n        )\n        logger.debug(\n            \"CitiesCountryScorer: computed destination country = {}\".format(\n                destination_country\n            )\n        )\n        city_countries = [\n            self._geolocator.country_from_location_name(city) for city in unique_cities\n        ]\n        logger.debug(\"CitiesCountryScorer: analyzed cities = {}\".format(unique_cities))\n        logger.debug(\n            \"CitiesCountryScorer: predicted countries = {}\".format(city_countries)\n        )\n        scores = [\n            1 if city_country == destination_country else 0\n            for city_country in city_countries\n        ]\n        country_score = sum(scores) / len(unique_cities)\n        weight_for_country = 0.6\n        score = weighted_average(\n            values=[latitude_score, country_score],\n            weights=[weight_for_latitude, weight_for_country],\n        )\n        logger.debug(\"CitiesCountryScorer: score value = {}\".format(score))\n        logger.debug(\n            \"CitiesCountryScorer: score weight = {}\".format(self._score_weight)\n        )\n        travel_plan_scores.add_score(\n            score_type=self._service_name,\n            score_dict={\n                travel_plan_scores.score_value_key: score,\n                travel_plan_scores.score_weight_key: self._score_weight,\n                \"latitude_check\": {\n                    \"weight\": weight_for_latitude,\n                    \"score\": latitude_score,\n                },\n                \"country_check\": {\"weight\": weight_for_country, \"score\": country_score},\n                \"city_countries\": city_countries,\n                \"latitude_signs\": latitude_signs,\n                \"destination_country\": destination_country,\n            },\n        )\n        logger.debug(\"CitiesCountryScorer: End\")", "\n\nclass OptimizedItineraryScorer(ScoreService):\n    def __init__(self, geolocator: GeoCoder, score_weight: float = 1.0) -> None:\n        service_name = \"City Countries\"\n        super().__init__(service_name, score_weight)\n        self._geolocator = geolocator\n\n    def score(\n        self, travel_plan: TravelPlanJSON, travel_plan_scores: TravelPlanScore\n    ) -> None:\n        cities = remove_consecutive_duplicates(\n            [city.lower() for city in travel_plan.travel_cities]\n        )\n        if len(cities) > 2:\n            logger.debug(\"CitiesCountryScorer: Start\")\n            departure_place = travel_plan.departure_place\n            cities = cities[1:] if cities[0] == departure_place.lower() else cities\n            cities = cities[:-1] if cities[-1] == departure_place.lower() else cities\n            logger.debug(\n                \"CitiesCountryScorer: cities eligible for optimiaztion computation =  {}\".format(\n                    cities\n                )\n            )\n            # the scorer evaluates the itinerary only if there are\n            # more than two different visited city excluded the departure place\n            if len(set(cities)) > 2:\n                open_problem = True if cities[0] != cities[-1] else False\n                cities = cities[:-1] if not open_problem else cities\n                solver = TSPSolver(geocoder=self._geolocator)\n                optimal_solution, optimal_distance = solver.solve(cities, open_problem)\n                current_distance = sum(\n                    [solver.distance_matrix[i, i + 1] for i in range(len(cities) - 1)]\n                )\n                if not open_problem:\n                    current_distance += solver.distance_matrix[0, -1]\n                score = optimal_distance / current_distance\n                logger.debug(\"CitiesCountryScorer: score value = {}\".format(score))\n                logger.debug(\n                    \"CitiesCountryScorer: score weight = {}\".format(self._score_weight)\n                )\n                logger.debug(\n                    \"CitiesCountryScorer: current distance = {}\".format(\n                        current_distance\n                    )\n                )\n                logger.debug(\n                    \"CitiesCountryScorer: optimal distance = {}\".format(\n                        optimal_distance\n                    )\n                )\n                logger.debug(\n                    \"CitiesCountryScorer: optimal solution = {}\".format(\n                        optimal_solution\n                    )\n                )\n                travel_plan_scores.add_score(\n                    score_type=self._service_name,\n                    score_dict={\n                        travel_plan_scores.score_value_key: score,\n                        travel_plan_scores.score_weight_key: self._score_weight,\n                        \"tsp_solution\": {\n                            \"solution\": optimal_solution,\n                            \"distance\": optimal_distance,\n                            \"open_problem\": open_problem,\n                        },\n                        \"itinerary\": {\n                            \"solution\": cities,\n                            \"distance\": current_distance,\n                        },\n                    },\n                )\n                logger.debug(\"CitiesCountryScorer: End\")\n            else:\n                logger.debug(\"CitiesCountryScorer: End -- No Computation needed\")", ""]}
{"filename": "src/gptravel/core/services/geocoder.py", "chunked_list": ["import os\nfrom functools import partial\nfrom typing import Dict, List, Optional\n\nfrom geopy import Location\nfrom geopy.distance import geodesic as GRC\nfrom geopy.extra.rate_limiter import RateLimiter\nfrom geopy.geocoders import Photon\n\nfrom gptravel.core.io.loggerconfig import logger", "\nfrom gptravel.core.io.loggerconfig import logger\n\nLOCATION_CACHE: Dict[str, Location] = {}\n\n\nclass GeoCoder:\n    def __init__(self, language: str = \"en\") -> None:\n        self._geocoder = partial(\n            Photon().geocode,\n            language=language,\n        )\n        if os.getenv(\"ENV\", \"PROD\") == \"TEST\":\n            self._geocoder = partial(\n                RateLimiter(Photon().geocode, min_delay_seconds=1.2), language=language\n            )\n\n    def _query(self, location_name: str) -> Optional[Location]:\n        loc_name = location_name.lower()\n        logger.debug(\"Querying coordinates for {}\".format(loc_name))\n        if loc_name in LOCATION_CACHE:\n            logger.debug(\"Using cached coordinates\")\n            return LOCATION_CACHE[loc_name]\n        logger.debug(\"Downloading new Location for {}: Start\".format(loc_name))\n        qry_obj = self._geocoder(location_name)\n        logger.debug(\"Downloading new Location for {}: Complete\".format(loc_name))\n        LOCATION_CACHE[loc_name] = qry_obj\n        return qry_obj\n\n    def _location_type(self, location_name: str) -> Optional[List[str]]:\n        fetched_location = self._query(location_name)\n        location_type = None\n        if fetched_location is not None:\n            location_type = fetched_location.raw[\"properties\"][\"type\"]\n        logger.debug(\n            \"GeoCoder: type for {} is: {}\".format(location_name, location_type)\n        )\n        return location_type\n\n    def country_from_location_name(self, location_name: str) -> Optional[str]:\n        fetched_location = self._query(location_name)\n        if fetched_location:\n            return fetched_location.raw[\"properties\"][\"country\"]\n        return fetched_location\n\n    def location_coordinates(self, location_name: str) -> Dict[str, Optional[float]]:\n        fetched_location = self._query(location_name)\n        if fetched_location:\n            return {\"lat\": fetched_location.latitude, \"lon\": fetched_location.longitude}\n        return {\"lat\": None, \"lon\": None}\n\n    def location_distance(self, location_name_1: str, location_name_2: str) -> float:\n        if location_name_1.lower() == location_name_2.lower():\n            return 0.0\n        location1_coords = self.location_coordinates(location_name_1)\n        location2_coords = self.location_coordinates(location_name_2)\n        return GRC(\n            (location1_coords[\"lat\"], location1_coords[\"lon\"]),\n            (location2_coords[\"lat\"], location2_coords[\"lon\"]),\n        ).km\n\n    def is_location_country_city_state(self, location_name: str) -> bool:\n        location_type = self._location_type(location_name)\n        if location_type:\n            return location_type in [\"country\", \"state\", \"city\"]\n        return False\n\n    def is_a_country(self, location_name: str) -> bool:\n        location_type = self._location_type(location_name)\n        if location_type:\n            return location_type in [\"country\", \"state\"]\n        return False", ""]}
{"filename": "src/gptravel/core/services/checker.py", "chunked_list": ["from abc import ABC, abstractmethod\n\nfrom gptravel.core.io.loggerconfig import logger\nfrom gptravel.core.services.geocoder import GeoCoder\nfrom gptravel.core.travel_planner.travel_engine import TravelPlanJSON\n\n\nclass Checker(ABC):\n    @abstractmethod\n    def check(self, travel_plan: TravelPlanJSON) -> bool:\n        pass", "\n\nclass ExistingDestinationsChecker(Checker):\n    def __init__(self, geolocator: GeoCoder) -> None:\n        self._geolocator = geolocator\n\n    def check(self, travel_plan: TravelPlanJSON) -> bool:\n        city_list = list(set(travel_plan.travel_cities))\n        logger.debug(\"Check the existence of cities in the generated travel\")\n        logger.debug(\"Check performed on cities: {}\".format(city_list))\n        existing_cities = [\n            True\n            if self._geolocator.location_coordinates(city)[\"lat\"] is not None\n            else False\n            for city in city_list\n        ]\n        all_exists = all(existing_cities)\n        if all_exists:\n            logger.debug(\"Check passed\")\n        else:\n            logger.warning(\"Check not passed\")\n        return all_exists", "\n\nclass DaysChecker(Checker):\n    def __init__(self, day_key: str = \"Day\") -> None:\n        self._travel_days = 0\n        self._day_key = day_key\n\n    @property\n    def travel_days(self) -> int:\n        return self._travel_days\n\n    def check(self, travel_plan: TravelPlanJSON) -> bool:\n        user_n_days = travel_plan.n_days\n        logger.debug(\"Check the number of days generated in the travel plan\")\n        self._travel_days = len(\n            set(travel_plan.get_key_values_by_name(self._day_key.lower()))\n        )\n        check = user_n_days == self._travel_days\n        if check:\n            logger.debug(\"Check passed\")\n        else:\n            missing_days = user_n_days - self._travel_days\n            logger.warning(\"Found missing {} days\".format(missing_days))\n        return check", ""]}
{"filename": "src/gptravel/core/services/engine/exception.py", "chunked_list": ["class HuggingFaceError(Exception):\n    pass\n"]}
{"filename": "src/gptravel/core/services/engine/tsp_solver.py", "chunked_list": ["from typing import List, Tuple\n\nimport numpy as np\nfrom python_tsp.exact import solve_tsp_dynamic_programming\nfrom python_tsp.heuristics import solve_tsp_simulated_annealing\n\nfrom gptravel.core.io.loggerconfig import logger\nfrom gptravel.core.services.geocoder import GeoCoder\n\n\nclass TSPSolver:\n    def __init__(self, geocoder: GeoCoder) -> None:\n        self._geocoder = geocoder\n        self._distance_matrix: np.ndarray = np.empty([2, 2])\n\n    @property\n    def distance_matrix(self) -> np.ndarray:\n        return self._distance_matrix\n\n    def solve(\n        self, cities: List[str], open_problem: bool = False\n    ) -> Tuple[List[str], float]:\n        if len(cities) > 1:\n            logger.debug(\"TSP solver: start\")\n            logger.debug(\"TSP solver: solve the problem for cities = {}\".format(cities))\n            logger.debug(\"TSP solver: open problem = {}\".format(open_problem))\n            if len(cities) < 10:\n                solver = solve_tsp_dynamic_programming\n                logger.debug(\"TSP solver: use dynamic programming\")\n            else:\n                solver = solve_tsp_simulated_annealing\n                logger.debug(\"TSP solver: use simulated annealing\")\n            self._distance_matrix = np.array(\n                [\n                    [\n                        0.0\n                        if i == j\n                        else self._geocoder.location_distance(cities[i], cities[j])\n                        for j in range(len(cities))\n                    ]\n                    for i in range(len(cities))\n                ]\n            )\n            dist_mat = np.copy(self._distance_matrix)\n            if open_problem:\n                dist_mat[:, 0] = 0.0\n            solution_indexes, solution_distance = solver(distance_matrix=dist_mat)\n            return [cities[index] for index in solution_indexes], solution_distance\n        logger.debug(\"TSP solver: only one city provided -- no computation needed\")\n        return cities, 0.0", "\n\nclass TSPSolver:\n    def __init__(self, geocoder: GeoCoder) -> None:\n        self._geocoder = geocoder\n        self._distance_matrix: np.ndarray = np.empty([2, 2])\n\n    @property\n    def distance_matrix(self) -> np.ndarray:\n        return self._distance_matrix\n\n    def solve(\n        self, cities: List[str], open_problem: bool = False\n    ) -> Tuple[List[str], float]:\n        if len(cities) > 1:\n            logger.debug(\"TSP solver: start\")\n            logger.debug(\"TSP solver: solve the problem for cities = {}\".format(cities))\n            logger.debug(\"TSP solver: open problem = {}\".format(open_problem))\n            if len(cities) < 10:\n                solver = solve_tsp_dynamic_programming\n                logger.debug(\"TSP solver: use dynamic programming\")\n            else:\n                solver = solve_tsp_simulated_annealing\n                logger.debug(\"TSP solver: use simulated annealing\")\n            self._distance_matrix = np.array(\n                [\n                    [\n                        0.0\n                        if i == j\n                        else self._geocoder.location_distance(cities[i], cities[j])\n                        for j in range(len(cities))\n                    ]\n                    for i in range(len(cities))\n                ]\n            )\n            dist_mat = np.copy(self._distance_matrix)\n            if open_problem:\n                dist_mat[:, 0] = 0.0\n            solution_indexes, solution_distance = solver(distance_matrix=dist_mat)\n            return [cities[index] for index in solution_indexes], solution_distance\n        logger.debug(\"TSP solver: only one city provided -- no computation needed\")\n        return cities, 0.0", ""]}
{"filename": "src/gptravel/core/services/engine/classifier.py", "chunked_list": ["import os\nfrom abc import ABC, abstractmethod\nfrom typing import Any, Dict, List\n\nimport requests\nfrom dotenv import load_dotenv\n\nfrom gptravel.core.io.loggerconfig import logger\nfrom gptravel.core.services.engine.exception import HuggingFaceError\n", "from gptravel.core.services.engine.exception import HuggingFaceError\n\nload_dotenv()\n\n\nclass TextClassifier(ABC):\n    def __init__(self, multi_label: bool) -> None:\n        self.multi_label = multi_label\n\n    @property\n    def multi_label(self) -> bool:\n        return self._multi_label\n\n    @multi_label.setter\n    def multi_label(self, multi_label: bool) -> None:\n        self._multi_label = multi_label\n\n    @abstractmethod\n    def predict(\n        self, input_text_list: List[str], label_classes: List[str]\n    ) -> Dict[str, Dict[str, float]]:\n        pass", "\n\nclass ZeroShotTextClassifier(TextClassifier):\n    def __init__(self, multi_label: bool = True) -> None:\n        super().__init__(multi_label)\n        self._api_token = os.getenv(\"HUGGING_FACE_KEY\")\n        self._api_url = (\n            \"https://api-inference.huggingface.co/models/facebook/bart-large-mnli\"\n        )\n\n    def _query(self, payload: Dict[str, Any]) -> Dict[str, Any]:\n        headers = {\"Authorization\": f\"Bearer {self._api_token}\"}\n        logger.debug(\"HuggingFace API fetching response: start\")\n        response = requests.post(self._api_url, headers=headers, json=payload).json()\n        logger.debug(\"HuggingFace API fetching response: complete\")\n        return response\n\n    def predict(\n        self,\n        input_text_list: List[str],\n        label_classes: List[str],\n    ) -> Dict[str, Dict[str, float]]:\n        payload = {\n            \"inputs\": input_text_list,\n            \"parameters\": {\n                \"candidate_labels\": label_classes,\n                \"multi_label\": self._multi_label,\n            },\n        }\n        try:\n            response = self._query(payload=payload)\n            return {\n                item[\"sequence\"]: {\n                    label: float(value)\n                    for label, value in zip(item[\"labels\"], item[\"scores\"])\n                }\n                for item in response\n            }\n        except:\n            logger.error(\"Hugging Face classifier: error in retrieving API response\")\n            raise HuggingFaceError", ""]}
