{"filename": "tests/test_query.py", "chunked_list": ["import pytest\n\nfrom tests.conftest import FirstEntity, SecondEntity\nfrom xtdb.query import InvalidField, Query\n\n\ndef test_basic_field_where_clause():\n    query = Query(FirstEntity).where(FirstEntity, name=\"test\")\n    assert (\n        query.format()\n        == \"\"\"{:query {:find [(pull FirstEntity [*])] :where [\n    [ FirstEntity :FirstEntity/name \"test\" ]\n    [ FirstEntity :type \"FirstEntity\" ]]}}\"\"\"\n    )\n\n    query = query.limit(4)\n    assert (\n        query.format()\n        == \"\"\"{:query {:find [(pull FirstEntity [*])] :where [\n    [ FirstEntity :FirstEntity/name \"test\" ]\n    [ FirstEntity :type \"FirstEntity\" ]] :limit 4}}\"\"\"\n    )\n\n    query = query.offset(0)\n    assert (\n        query.format()\n        == \"\"\"{:query {:find [(pull FirstEntity [*])] :where [\n    [ FirstEntity :FirstEntity/name \"test\" ]\n    [ FirstEntity :type \"FirstEntity\" ]] :limit 4 :offset 0}}\"\"\"\n    )\n\n    query = query.timeout(40)\n    assert (\n        query.format()\n        == \"\"\"{:query {:find [(pull FirstEntity [*])] :where [\n    [ FirstEntity :FirstEntity/name \"test\" ]\n    [ FirstEntity :type \"FirstEntity\" ]] :limit 4 :offset 0 :timeout 40}}\"\"\"\n    )\n\n    query = query.order_by([(\"FirstEntity/name\", \"asc\")])\n    assert (\n        query.format()\n        == \"\"\"{:query {:find [(pull FirstEntity [*])] :where [\n    [ FirstEntity :FirstEntity/name \"test\" ]\n    [ FirstEntity :type \"FirstEntity\" ]] :order-by [[FirstEntity/name :asc]] :limit 4 :offset 0 :timeout 40}}\"\"\"\n    )", "\n\ndef test_reference_field_where_clause():\n    query = Query(FirstEntity).where(SecondEntity, first_entity=FirstEntity)\n    assert (\n        query.format()\n        == \"\"\"{:query {:find [(pull FirstEntity [*])] :where [\n    [ FirstEntity :type \"FirstEntity\" ]\n    [ SecondEntity :SecondEntity/first_entity FirstEntity ]]}}\"\"\"\n    )", "\n\ndef test_remove_duplicates():\n    query = Query(FirstEntity).where(SecondEntity, first_entity=FirstEntity)\n    assert query == query.where(SecondEntity, first_entity=FirstEntity)\n\n\ndef test_invalid_fields_name():\n    with pytest.raises(InvalidField) as ctx:\n        Query(FirstEntity).where(FirstEntity, wrong=FirstEntity)\n\n    assert ctx.exconly() == 'xtdb.exceptions.InvalidField: \"wrong\" is not a field of FirstEntity'\n\n    with pytest.raises(InvalidField) as ctx:\n        Query(FirstEntity).where(FirstEntity, abc=\"def\")\n\n    assert ctx.exconly() == 'xtdb.exceptions.InvalidField: \"abc\" is not a field of FirstEntity'", "\n\ndef test_escaping_quotes():\n    query = Query(FirstEntity).where(SecondEntity, first_entity=FirstEntity).where(FirstEntity, name='test \" name')\n    assert (\n        query.format()\n        == \"\"\"{:query {:find [(pull FirstEntity [*])] :where [\n    [ FirstEntity :FirstEntity/name \"test \\\\\" name\" ]\n    [ FirstEntity :type \"FirstEntity\" ]\n    [ SecondEntity :SecondEntity/first_entity FirstEntity ]]}}\"\"\"\n    )", "\n\ndef test_invalid_field_types():\n    with pytest.raises(InvalidField) as ctx:\n        Query(FirstEntity).where(SecondEntity, test=InvalidField)\n\n    assert ctx.exconly() == 'xtdb.exceptions.InvalidField: \"test\" is not a field of SecondEntity'\n\n    with pytest.raises(InvalidField) as ctx:\n        Query(FirstEntity).where(FirstEntity, name=FirstEntity)\n\n    assert ctx.exconly() == 'xtdb.exceptions.InvalidField: \"name\" is not a relation of FirstEntity'", "\n\ndef test_allow_string_for_foreign_keys():\n    query = Query(FirstEntity).where(SecondEntity, first_entity=\"FirstEntity|internet\")\n\n    assert (\n        query.format()\n        == \"\"\"{:query {:find [(pull FirstEntity [*])] :where [\n    [ FirstEntity :type \"FirstEntity\" ]\n    [ SecondEntity :SecondEntity/first_entity \"FirstEntity|internet\" ]]}}\"\"\"\n    )", ""]}
{"filename": "tests/test_datalog.py", "chunked_list": ["import pytest\n\nfrom xtdb.datalog import (\n    Expression,\n    Find,\n    In,\n    Limit,\n    NotJoin,\n    OrderBy,\n    OrJoin,", "    OrderBy,\n    OrJoin,\n    Sample,\n    Sum,\n    Timeout,\n    Where,\n    WherePredicate,\n    _BaseAggregate,\n)\nfrom xtdb.exceptions import XTDBException", ")\nfrom xtdb.exceptions import XTDBException\n\n\ndef test_where_clauses():\n    statement = Where(\"a\", \"b\", \"c\")\n    assert statement.compile() == \":where [[ a :b c ]]\"\n\n    statement = Where(\"a\", \"b\")\n    assert statement.compile() == \":where [[ a :b  ]]\"\n\n    statement = Where(\"a\", \"b\", \"c\") & Where(\"1\", \"2\", \"3\")\n    assert statement.compile() == \":where [ [ 1 :2 3 ] [ a :b c ]]\"\n\n    statement = Where(\"a\", \"b\", \"c\") & Where(\"1\", \"2\", \"3\") & Where(\"1\", \"2\", \"3\")\n    assert statement.compile() == \":where [ [ 1 :2 3 ] [ a :b c ]]\"\n\n    statement = Where(\"a\", \"b\", \"c\") & Where(\"1\", \"2\", \"3\") & Where(\"x\", \"y\", \"z\")\n    assert statement.compile() == \":where [ [ 1 :2 3 ] [ a :b c ] [ x :y z ]]\"\n\n    statement = Where(\"a\", \"b\", \"c\") & Where(\"1\", \"2\", \"3\") & Where(\"1\", \"2\", \"3\") & Where(\"a\", \"b\", \"c\")\n    assert statement.compile() == \":where [ [ 1 :2 3 ] [ a :b c ]]\"\n\n    statement = Where(\"a\", \"b\", \"c\") & Where(\"1\", \"2\", \"3\") & Where(\"x\", \"y\", \"z\")\n    assert statement.compile() == \":where [ [ 1 :2 3 ] [ a :b c ] [ x :y z ]]\"\n    assert str(statement) == statement.compile()", "\n\ndef test_or_clauses():\n    statement = Where(\"a\", \"b\", \"c\") | Where(\"1\", \"2\", \"3\")\n    assert statement.compile() == \":where [(or [ 1 :2 3 ] [ a :b c ])]\"\n\n    statement = Where(\"a\", \"b\", \"c\") | Where(\"1\", \"2\", \"3\") | Where(\"1\", \"2\", \"3\")\n    assert statement.compile() == \":where [(or [ 1 :2 3 ] [ a :b c ])]\"\n\n\ndef test_not_clauses():\n    statement = ~Where(\"a\", \"b\", \"c\")\n    assert statement.compile() == \":where [(not [ a :b c ])]\"\n\n    statement = ~(Where(\"a\", \"b\", \"c\") & Where(\"1\", \"2\", \"3\"))\n    assert statement.compile() == \":where [(not [ 1 :2 3 ] [ a :b c ])]\"\n\n    statement = ~(Where(\"a\", \"b\", \"c\") & Where(\"1\", \"2\", \"3\") & Where(\"x\", \"y\"))\n    assert statement.compile() == \":where [(not [ 1 :2 3 ] [ a :b c ] [ x :y  ])]\"", "\n\ndef test_not_clauses():\n    statement = ~Where(\"a\", \"b\", \"c\")\n    assert statement.compile() == \":where [(not [ a :b c ])]\"\n\n    statement = ~(Where(\"a\", \"b\", \"c\") & Where(\"1\", \"2\", \"3\"))\n    assert statement.compile() == \":where [(not [ 1 :2 3 ] [ a :b c ])]\"\n\n    statement = ~(Where(\"a\", \"b\", \"c\") & Where(\"1\", \"2\", \"3\") & Where(\"x\", \"y\"))\n    assert statement.compile() == \":where [(not [ 1 :2 3 ] [ a :b c ] [ x :y  ])]\"", "\n\ndef test_where_or_clauses():\n    statement = Where(\"a\", \"b\", \"c\") & Where(\"1\", \"2\", \"3\") | Where(\"x\", \"y\", \"z\") & Where(\"9\", \"8\", \"7\")\n    assert statement.compile() == \":where [(or (and [ 1 :2 3 ] [ a :b c ]) (and [ 9 :8 7 ] [ x :y z ]))]\"\n\n    statement = Where(\"a\", \"b\", \"c\") & (Where(\"1\", \"2\", \"3\") | Where(\"x\", \"y\", \"z\"))\n    assert statement.compile() == \":where [ (or [ 1 :2 3 ] [ x :y z ]) [ a :b c ]]\"\n\n    # The & operator takes precedence over the | operator\n    statement = (Where(\"a\", \"b\", \"c\") | Where(\"1\", \"2\", \"3\")) & Where(\"x\", \"y\", \"z\")\n    assert statement.compile() == \":where [ (or [ 1 :2 3 ] [ a :b c ]) [ x :y z ]]\"\n\n    statement = (Where(\"a\", \"b\", \"c\") | Where(\"1\", \"2\", \"3\")) & (Where(\"x\", \"y\", \"z\") | Where(\"9\", \"8\", \"7\"))\n    assert statement.compile() == \":where [ (or [ 1 :2 3 ] [ a :b c ]) (or [ 9 :8 7 ] [ x :y z ])]\"\n\n    with pytest.raises(XTDBException):\n        Where(\"a\", \"b\", \"c\") & Where(\"1\", \"2\", \"3\") | Where(\"x\", \"y\", \"z\")\n\n    with pytest.raises(XTDBException):\n        Where(\"a\", \"b\", \"c\") | Where(\"1\", \"2\", \"3\") & Where(\"x\", \"y\", \"z\")", "\n\ndef test_find_clauses():\n    statement = Find(\"a\")\n    assert statement.compile() == \":find [a]\"\n\n    statement = Find(\"a\") & Find(\"b\")\n    assert statement.compile() == \":find [ a b]\"\n\n    statement = Find(\"pull(*)\") & Find(\"b\") & Find(Expression(\"(sum ?heads)\"))\n    assert statement.compile() == \":find [ pull(*) b (sum ?heads)]\"\n\n    with pytest.raises(XTDBException) as ctx:\n        Find(\"pull(*)\") | Find(\"b\")\n\n    assert ctx.exconly() == \"xtdb.exceptions.XTDBException: Cannot use | on query keys\"", "\n\ndef test_aggregates():\n    statement = Find(\"a\") & Find(_BaseAggregate(\"sum\", \"field\"))\n    assert statement.compile() == \":find [ a (sum field)]\"\n\n    statement = Find(\"a\") & Find(_BaseAggregate(\"sample\", \"field\", \"12\"))\n    assert statement.compile() == \":find [ a (sample 12 field)]\"\n\n    with pytest.raises(XTDBException) as ctx:\n        Find(\"a\") & Find(_BaseAggregate(\"wrong\", \"field\"))\n\n    assert ctx.exconly() == \"xtdb.exceptions.XTDBException: Invalid aggregate function\"\n\n    with pytest.raises(XTDBException) as ctx:\n        Find(\"a\") & Find(_BaseAggregate(\"rand\", \"field\"))\n\n    assert ctx.exconly() == \"xtdb.exceptions.XTDBException: Invalid arguments to aggregate, it needs one argument: N\"", "\n\ndef test_concrete_aggregates():\n    statement = Find(\"a\") & Sum(\"field\")\n    assert statement.compile() == \":find [ a (sum field)]\"\n\n    statement = Find(\"a\") & Sum(\"field\") & Sum(\"field\")\n    assert statement.compile() == \":find [ a (sum field) (sum field)]\"\n\n    statement = Find(\"a\") & Sample(\"field\", 12)\n    assert statement.compile() == \":find [ a (sample 12 field)]\"\n\n    with pytest.raises(XTDBException):\n        Sample(\"field\", 12) | Sum(\"field\")", "\n\ndef test_find_where():\n    statement = Find(\"a\") & Where(\"a\", \"b\", \"c\")\n    assert statement.compile() == \"{:query {:find [a] :where [[ a :b c ]]}}\"\n\n    statement = Find(\"a\") & (Where(\"a\", \"b\", \"c\") & Where(\"1\", \"2\", \"3\"))\n    assert statement.compile() == \"{:query {:find [a] :where [ [ 1 :2 3 ] [ a :b c ]]}}\"\n\n    statement = Find(\"a\") & (Where(\"a\", \"b\", \"c\") | Where(\"1\", \"2\", \"3\"))\n    assert statement.compile() == \"{:query {:find [a] :where [(or [ 1 :2 3 ] [ a :b c ])]}}\"\n\n    statement = Find(\"a\") & Find(\"b\") & (Where(\"a\", \"b\", \"c\") | Where(\"1\", \"2\", \"3\"))\n    assert statement.compile() == \"{:query {:find [ a b] :where [(or [ 1 :2 3 ] [ a :b c ])]}}\"\n\n    statement = (\n        Find(\"a\")\n        & Sample(\"field\", 12)\n        & Sum(\"field\")\n        & ((Where(\"a\", \"b\", \"c\") | Where(\"1\", \"2\", \"3\")) & Where(\"x\", \"y\", \"z\"))\n    )\n    assert (\n        statement.compile()\n        == \"{:query {:find [ a (sample 12 field) (sum field)] :where [ (or [ 1 :2 3 ] [ a :b c ]) [ x :y z ]]}}\"\n    )\n\n    statement = Sum(\"a\") & Where(\"a\", \"b\", \"c\")\n    assert statement.compile() == \"{:query {:find [(sum a)] :where [[ a :b c ]]}}\"\n\n    statement = Sum(\"a\") & Sum(\"b\") & Where(\"a\", \"b\", \"c\")\n    assert statement.compile() == \"{:query {:find [ (sum a) (sum b)] :where [[ a :b c ]]}}\"", "\n\ndef test_find_where_not():\n    statement = Sum(\"a\") & Sum(\"b\") & ~(Where(\"a\", \"b\", \"c\") & Where(\"x\", \"y\", \"z\"))\n    assert statement.compile() == \"{:query {:find [ (sum a) (sum b)] :where [(not [ a :b c ] [ x :y z ])]}}\"\n\n\ndef test_find_where_in_complete():\n    statement = Find(\"a\") & Where(\"a\", \"b\", \"c\") & Limit(2) & Timeout(29) & OrderBy([(\"b\", \"asc\")]) & In(\"c\", \"d\")\n\n    # Scalar binding\n    assert (\n        statement.compile()\n        == '{:query {:find [a] :where [[ a :b c ]] :in [c] :order-by [[b :asc]] :limit 2 :timeout 29} :in-args [\"d\"]}'\n    )\n\n    # Collection binding\n    statement = Find(\"a\") & Where(\"a\", \"b\", \"c\") & Limit(2) & OrderBy([(\"b\", \"asc\")]) & In([\"c\", \"...\"], [\"d\", \"e\"])\n    assert (\n        statement.compile()\n        == '{:query {:find [a] :where [[ a :b c ]] :in [[c ...]] :order-by [[b :asc]] :limit 2} :in-args [[\"d\" \"e\"]]}'\n    )\n\n    # Tuple binding\n    statement = Find(\"a\") & Where(\"a\", \"b\", \"c\") & Limit(2) & OrderBy([(\"b\", \"asc\")]) & In([\"c\", \"z\"], [\"d\", \"e\"])\n    assert (\n        statement.compile()\n        == '{:query {:find [a] :where [[ a :b c ]] :in [[c z]] :order-by [[b :asc]] :limit 2} :in-args [[\"d\" \"e\"]]}'\n    )\n\n    # Relation binding\n    statement = Find(\"a\") & Where(\"a\", \"b\", \"c\") & Limit(2) & In([[\"c\", \"z\"]], [[\"d\", \"e\"], [\"f\", \"g\"]])\n    assert (\n        statement.compile()\n        == '{:query {:find [a] :where [[ a :b c ]] :in [[[c z]]] :limit 2} :in-args [[[\"d\" \"e\"] [\"f\" \"g\"]]]}'\n    )", "\n\ndef test_find_where_wrong_order():\n    with pytest.raises(XTDBException):\n        Find(\"a\") & Where(\"a\", \"b\", \"c\") & Where(\"1\", \"2\", \"3\")\n\n    with pytest.raises(XTDBException):\n        Where(\"a\", \"b\", \"c\") & Find(\"a\")\n\n    with pytest.raises(XTDBException):\n        (Where(\"a\", \"b\", \"c\") | Where(\"1\", \"2\", \"3\")) & Find(\"a\")", "\n\ndef test_in():\n    statement = In([\"field\", \"other-field\"], [\"value\", \"other-value\"])\n    assert statement.compile() == \" :in [[field other-field]]\"\n    assert statement.compile_values() == ' :in-args [[\"value\" \"other-value\"]]'\n\n    statement = In([\"field\", \"...\"], [\"value\", \"other-value\"])\n    assert statement.compile() == \" :in [[field ...]]\"\n    assert statement.compile_values() == ' :in-args [[\"value\" \"other-value\"]]'", "\n\ndef test_order_by():\n    statement = OrderBy([(\"field_name\", \"asc\"), (\"test-name\", \"desc\")])\n    assert statement.compile() == \" :order-by [[field_name :asc] [test-name :desc]]\"\n\n    with pytest.raises(XTDBException):\n        OrderBy([(\"field_name\", \"asc\"), (\"test-name\", \"esc\")])\n\n\ndef test_where_predicate():\n    statement = WherePredicate(\"odd?\", \"b\")\n    assert statement.compile() == \":where [[ (odd? b) ]]\"\n\n    statement = WherePredicate(\"+\", \"1\", \"2\", \"b\")\n    assert statement.compile() == \":where [[ (+ 1 2 b) ]]\"\n\n    # From the docs\n    statement = WherePredicate(\"identity\", \"2\", bind=\"x\") & WherePredicate(\"+\", \"x\", \"2\", bind=\"y\")\n    assert statement.compile() == \":where [ [ (+ x 2) y] [ (identity 2) x]]\"\n\n    statement = Find(\"a\") & (Where(\"a\", \"b\", \"c\") & WherePredicate(\"odd?\", \"c\"))\n    assert statement.compile() == \"{:query {:find [a] :where [ [ (odd? c) ] [ a :b c ]]}}\"", "\n\ndef test_where_predicate():\n    statement = WherePredicate(\"odd?\", \"b\")\n    assert statement.compile() == \":where [[ (odd? b) ]]\"\n\n    statement = WherePredicate(\"+\", \"1\", \"2\", \"b\")\n    assert statement.compile() == \":where [[ (+ 1 2 b) ]]\"\n\n    # From the docs\n    statement = WherePredicate(\"identity\", \"2\", bind=\"x\") & WherePredicate(\"+\", \"x\", \"2\", bind=\"y\")\n    assert statement.compile() == \":where [ [ (+ x 2) y] [ (identity 2) x]]\"\n\n    statement = Find(\"a\") & (Where(\"a\", \"b\", \"c\") & WherePredicate(\"odd?\", \"c\"))\n    assert statement.compile() == \"{:query {:find [a] :where [ [ (odd? c) ] [ a :b c ]]}}\"", "\n\ndef test_range_predicate():\n    # From the docs\n    statement = WherePredicate(\">\", 18, \"a\")\n    assert statement.compile() == \":where [[ (> 18 a) ]]\"\n\n\ndef test_unification_predicate():\n    # From the docs\n    statement = WherePredicate(\"==\", \"a\", \"a2\")\n    assert statement.compile() == \":where [[ (== a a2) ]]\"\n\n    # From the docs\n    statement = WherePredicate(\"!=\", \"a\", \"a2\")\n    assert statement.compile() == \":where [[ (!= a a2) ]]\"", "def test_unification_predicate():\n    # From the docs\n    statement = WherePredicate(\"==\", \"a\", \"a2\")\n    assert statement.compile() == \":where [[ (== a a2) ]]\"\n\n    # From the docs\n    statement = WherePredicate(\"!=\", \"a\", \"a2\")\n    assert statement.compile() == \":where [[ (!= a a2) ]]\"\n\n\ndef test_not_join():\n    # From the docs\n    statement = Where(\"e\", \"xt/id\") & (NotJoin(\"e\") & Where(\"e\", \"last-name\", \"n\"))\n    assert statement.compile() == \":where [ (not-join [e] [ e :last-name n ]) [ e :xt/id  ]]\"\n\n    statement = Where(\"e\", \"xt/id\") & (NotJoin(\"e\") & (Where(\"e\", \"last-name\", \"n\") & Where(\"e\", \"name\", \"n\")))\n    assert statement.compile() == \":where [ (not-join [e]  [ e :last-name n ] [ e :name n ]) [ e :xt/id  ]]\"\n\n    statement = Where(\"e\", \"xt/id\") & (NotJoin(\"e\") & Where(\"e\", \"last-name\", \"n\") & Where(\"e\", \"name\", \"n\"))\n    assert statement.compile() == \":where [ (not-join [e] [ e :last-name n ] [ e :name n ]) [ e :xt/id  ]]\"\n\n    statement = Where(\"e\", \"xt/id\") & NotJoin(\"e\") & Where(\"e\", \"last-name\", \"n\") & Where(\"e\", \"name\", \"n\")\n    assert statement.compile() == \":where [ (not-join [e] ) [ e :last-name n ] [ e :name n ] [ e :xt/id  ]]\"", "\n\ndef test_not_join():\n    # From the docs\n    statement = Where(\"e\", \"xt/id\") & (NotJoin(\"e\") & Where(\"e\", \"last-name\", \"n\"))\n    assert statement.compile() == \":where [ (not-join [e] [ e :last-name n ]) [ e :xt/id  ]]\"\n\n    statement = Where(\"e\", \"xt/id\") & (NotJoin(\"e\") & (Where(\"e\", \"last-name\", \"n\") & Where(\"e\", \"name\", \"n\")))\n    assert statement.compile() == \":where [ (not-join [e]  [ e :last-name n ] [ e :name n ]) [ e :xt/id  ]]\"\n\n    statement = Where(\"e\", \"xt/id\") & (NotJoin(\"e\") & Where(\"e\", \"last-name\", \"n\") & Where(\"e\", \"name\", \"n\"))\n    assert statement.compile() == \":where [ (not-join [e] [ e :last-name n ] [ e :name n ]) [ e :xt/id  ]]\"\n\n    statement = Where(\"e\", \"xt/id\") & NotJoin(\"e\") & Where(\"e\", \"last-name\", \"n\") & Where(\"e\", \"name\", \"n\")\n    assert statement.compile() == \":where [ (not-join [e] ) [ e :last-name n ] [ e :name n ] [ e :xt/id  ]]\"", "\n\ndef test_or_join():\n    statement = Where(\"e\", \"xt/id\") & (OrJoin(\"e\") & Where(\"e\", \"last-name\", \"n\"))\n    assert statement.compile() == \":where [ (or-join [e] [ e :last-name n ]) [ e :xt/id  ]]\"\n\n    statement = Where(\"e\", \"xt/id\") & (OrJoin(\"e\") & (Where(\"e\", \"last-name\", \"n\") & Where(\"e\", \"name\", \"n\")))\n    assert statement.compile() == \":where [ (or-join [e]  [ e :last-name n ] [ e :name n ]) [ e :xt/id  ]]\"\n\n    statement = Where(\"e\", \"xt/id\") & (OrJoin(\"e\") & Where(\"e\", \"last-name\", \"n\") & Where(\"e\", \"name\", \"n\"))\n    assert statement.compile() == \":where [ (or-join [e] [ e :last-name n ] [ e :name n ]) [ e :xt/id  ]]\"\n\n    statement = Where(\"e\", \"xt/id\") & OrJoin(\"e\") & Where(\"e\", \"last-name\", \"n\") & Where(\"e\", \"name\", \"n\")\n    assert statement.compile() == \":where [ (or-join [e] ) [ e :last-name n ] [ e :name n ] [ e :xt/id  ]]\"", ""]}
{"filename": "tests/__init__.py", "chunked_list": [""]}
{"filename": "tests/test_orm.py", "chunked_list": ["from tests.conftest import FirstEntity, SecondEntity\n\n\ndef test_proper_dict_format():\n    entity = FirstEntity(name=\"test\")\n\n    d = entity.dict()\n\n    assert d == {\n        \"xt/id\": entity.id,\n        \"type\": \"FirstEntity\",\n        \"FirstEntity/name\": \"test\",\n    }\n    assert FirstEntity.from_dict(d).name == entity.name\n\n    entity2 = SecondEntity(first_entity=entity, age=12)\n    d2 = entity2.dict()\n\n    assert d2 == {\n        \"xt/id\": entity2.id,\n        \"type\": \"SecondEntity\",\n        \"SecondEntity/first_entity\": entity.id,\n        \"SecondEntity/age\": 12,\n    }\n    assert SecondEntity.from_dict(d2).age == entity2.age\n    assert SecondEntity.from_dict(d2).first_entity == entity2.first_entity.id", ""]}
{"filename": "tests/test_transaction.py", "chunked_list": ["import json\n\nfrom xtdb.session import Operation, OperationType, Transaction\n\n\ndef test_transaction_json(valid_time):\n    transaction = Transaction()\n    transaction.add(Operation(type=OperationType.MATCH, value={\"xt/id\": \"value\"}, valid_time=valid_time))\n    transaction.add(Operation(type=OperationType.DELETE, value=\"value\", valid_time=valid_time))\n    transaction.add(Operation(type=OperationType.PUT, value={\"xt/id\": \"value\"}, valid_time=valid_time))\n    transaction.add(Operation(type=OperationType.EVICT, value=\"value\", valid_time=valid_time))\n\n    assert json.loads(transaction.json()) == json.loads(\n        f\"\"\"{{\"tx-ops\": [\n        [\"match\", \"value\", {{\"xt/id\": \"value\"}}, \"{valid_time.isoformat()}\"],\n        [\"delete\", \"value\", \"{valid_time.isoformat()}\"],\n        [\"put\", {{\"xt/id\": \"value\"}}, \"{valid_time.isoformat()}\"],\n        [\"evict\", \"value\", \"{valid_time.isoformat()}\"]\n]}}\"\"\"\n    )", "\n\ndef test_transaction_json_with_methods(valid_time):\n    transaction = Transaction()\n    transaction.add(Operation.match({\"xt/id\": \"value\"}, valid_time))\n    transaction.add(Operation.delete(\"value\", valid_time))\n    transaction.add(Operation.put({\"xt/id\": \"value\"}, valid_time))\n    transaction.add(Operation.evict(\"value\", valid_time))\n\n    assert json.loads(transaction.json()) == json.loads(\n        f\"\"\"{{\"tx-ops\": [\n        [\"match\", \"value\", {{\"xt/id\": \"value\"}}, \"{valid_time.isoformat()}\"],\n        [\"delete\", \"value\", \"{valid_time.isoformat()}\"],\n        [\"put\", {{\"xt/id\": \"value\"}}, \"{valid_time.isoformat()}\"],\n        [\"evict\", \"value\", \"{valid_time.isoformat()}\"]\n]}}\"\"\"\n    )", ""]}
{"filename": "tests/conftest.py", "chunked_list": ["import os\nfrom dataclasses import dataclass\nfrom datetime import datetime, timezone\n\nimport pytest\nfrom requests.adapters import HTTPAdapter\nfrom urllib3 import Retry\n\nfrom xtdb.orm import Base\nfrom xtdb.session import XTDBSession", "from xtdb.orm import Base\nfrom xtdb.session import XTDBSession\n\n\n@dataclass\nclass FirstEntity(Base):\n    name: str\n\n\n@dataclass\nclass SecondEntity(Base):\n    age: int\n    first_entity: FirstEntity", "\n@dataclass\nclass SecondEntity(Base):\n    age: int\n    first_entity: FirstEntity\n\n\n@dataclass\nclass ThirdEntity(Base):\n    first_entity: FirstEntity\n    second_entity: SecondEntity", "class ThirdEntity(Base):\n    first_entity: FirstEntity\n    second_entity: SecondEntity\n\n\n@dataclass\nclass FourthEntity(Base):\n    third_entity: ThirdEntity\n    value: float\n", "\n\n@pytest.fixture\ndef valid_time() -> datetime:\n    return datetime.now(timezone.utc)\n\n\n@pytest.fixture\ndef xtdb_session() -> XTDBSession:\n    session = XTDBSession(os.environ[\"XTDB_URI\"])\n    session.client._session.mount(\"http://\", HTTPAdapter(max_retries=Retry(total=5, backoff_factor=1)))\n\n    return session", "def xtdb_session() -> XTDBSession:\n    session = XTDBSession(os.environ[\"XTDB_URI\"])\n    session.client._session.mount(\"http://\", HTTPAdapter(max_retries=Retry(total=5, backoff_factor=1)))\n\n    return session\n"]}
{"filename": "tests/integration/test_xtdb_session.py", "chunked_list": ["import os\nfrom datetime import datetime, timedelta, timezone\n\nimport pytest\n\nfrom tests.conftest import FirstEntity, FourthEntity, SecondEntity, ThirdEntity\nfrom xtdb.datalog import Count, Find, In, Limit, Sum, Timeout, Where\nfrom xtdb.exceptions import XTDBException\nfrom xtdb.orm import Fn\nfrom xtdb.query import Query, Var", "from xtdb.orm import Fn\nfrom xtdb.query import Query, Var\nfrom xtdb.session import XTDBSession\n\nif os.environ.get(\"CI\") != \"1\":\n    pytest.skip(\"Needs XTDB container.\", allow_module_level=True)\n\n#\n# def test_status(xtdb_session: XTDBSession):\n", "# def test_status(xtdb_session: XTDBSession):\n\n\ndef test_query_no_results(xtdb_session: XTDBSession):\n    query = Query(FirstEntity).where(FirstEntity, name=\"test\")\n\n    result = xtdb_session.query(query)\n    assert result == []\n\n\ndef test_query_simple_filter(xtdb_session: XTDBSession):\n    entity = FirstEntity(name=\"test\")\n    xtdb_session.put(entity)\n\n    query = Query(FirstEntity).where(FirstEntity, name=\"test\")\n    result = xtdb_session.query(query)\n    assert result == []\n\n    xtdb_session.commit()\n\n    query = Query(FirstEntity).where(FirstEntity, name=\"wrong\")\n    result = xtdb_session.query(query)\n    assert result == []\n\n    query = Query(FirstEntity).where(FirstEntity, name=\"test\")\n    result = xtdb_session.query(query)\n    assert result[0].dict() == {\"FirstEntity/name\": \"test\", \"type\": \"FirstEntity\", \"xt/id\": entity.id}\n\n    result = xtdb_session.query(query, tx_time=datetime.now(timezone.utc) - timedelta(seconds=1))\n    assert result == []\n\n    result = xtdb_session.query(query, tx_id=-1)\n    assert result == []\n\n    result = xtdb_session.query(query, tx_id=0)\n    assert result[0].dict() == {\"FirstEntity/name\": \"test\", \"type\": \"FirstEntity\", \"xt/id\": entity.id}\n\n    result = xtdb_session.query(query.timeout(200), tx_id=0)\n    assert result[0].dict() == {\"FirstEntity/name\": \"test\", \"type\": \"FirstEntity\", \"xt/id\": entity.id}\n\n    result = xtdb_session.query(query.limit(0), tx_id=0)\n    assert result == []\n\n    xtdb_session.client.sync()\n\n    xtdb_session.delete(entity)\n    xtdb_session.commit()", "\n\ndef test_query_simple_filter(xtdb_session: XTDBSession):\n    entity = FirstEntity(name=\"test\")\n    xtdb_session.put(entity)\n\n    query = Query(FirstEntity).where(FirstEntity, name=\"test\")\n    result = xtdb_session.query(query)\n    assert result == []\n\n    xtdb_session.commit()\n\n    query = Query(FirstEntity).where(FirstEntity, name=\"wrong\")\n    result = xtdb_session.query(query)\n    assert result == []\n\n    query = Query(FirstEntity).where(FirstEntity, name=\"test\")\n    result = xtdb_session.query(query)\n    assert result[0].dict() == {\"FirstEntity/name\": \"test\", \"type\": \"FirstEntity\", \"xt/id\": entity.id}\n\n    result = xtdb_session.query(query, tx_time=datetime.now(timezone.utc) - timedelta(seconds=1))\n    assert result == []\n\n    result = xtdb_session.query(query, tx_id=-1)\n    assert result == []\n\n    result = xtdb_session.query(query, tx_id=0)\n    assert result[0].dict() == {\"FirstEntity/name\": \"test\", \"type\": \"FirstEntity\", \"xt/id\": entity.id}\n\n    result = xtdb_session.query(query.timeout(200), tx_id=0)\n    assert result[0].dict() == {\"FirstEntity/name\": \"test\", \"type\": \"FirstEntity\", \"xt/id\": entity.id}\n\n    result = xtdb_session.query(query.limit(0), tx_id=0)\n    assert result == []\n\n    xtdb_session.client.sync()\n\n    xtdb_session.delete(entity)\n    xtdb_session.commit()", "\n\ndef test_match(xtdb_session: XTDBSession, valid_time: datetime):\n    entity = FirstEntity(name=\"test\")\n    second_entity = FirstEntity(name=\"test2\")\n\n    xtdb_session.put(entity)\n    xtdb_session.put(second_entity)\n    xtdb_session.commit()\n\n    query = Query(FirstEntity).where(FirstEntity, name=\"test\")\n    result = xtdb_session.query(query)\n    assert result[0].dict() == {\"FirstEntity/name\": \"test\", \"type\": \"FirstEntity\", \"xt/id\": entity.id}\n\n    xtdb_session.delete(entity)\n    xtdb_session.commit()\n\n    third_entity = FirstEntity(name=\"test3\")\n\n    xtdb_session.put(third_entity)\n    xtdb_session.match(entity)  # transaction will fail because `entity` is not matched\n    xtdb_session.commit()\n\n    query = Query(FirstEntity).where(FirstEntity, name=\"test3\")\n    assert xtdb_session.query(query) == []\n\n    xtdb_session.put(third_entity)\n    xtdb_session.match(second_entity)  # transaction will succeed because `second_entity` is matched\n    xtdb_session.commit()\n\n    assert xtdb_session.query(query)[0].dict() == {\n        \"FirstEntity/name\": \"test3\",\n        \"type\": \"FirstEntity\",\n        \"xt/id\": third_entity.id,\n    }\n\n    assert xtdb_session.query(query, valid_time=valid_time) == []\n\n    xtdb_session.delete(second_entity)\n    xtdb_session.delete(third_entity)\n    xtdb_session.commit()", "\n\ndef test_deleted_and_evicted(xtdb_session: XTDBSession, valid_time: datetime):\n    entity = FirstEntity(name=\"test\")\n\n    xtdb_session.put(entity, valid_time)\n    xtdb_session.commit()\n\n    xtdb_session.delete(entity)\n    xtdb_session.commit()\n\n    query = Query(FirstEntity).where(FirstEntity, name=\"test\")\n    result = xtdb_session.query(query)\n    assert result == []\n\n    result_entity = xtdb_session.query(query, valid_time=valid_time)[0].dict()\n    assert result_entity == {\"FirstEntity/name\": \"test\", \"type\": \"FirstEntity\", \"xt/id\": entity.id}\n\n    xtdb_session.evict(entity)\n    xtdb_session.commit()\n\n    result = xtdb_session.query(query)\n    assert result == []\n\n    result = xtdb_session.query(query, valid_time=valid_time)\n    assert result == []", "\n\ndef test_query_not_empty_on_reference_filter_for_entity(xtdb_session: XTDBSession):\n    test = FirstEntity(name=\"test\")\n    second1 = SecondEntity(first_entity=test, age=1)\n    second2 = SecondEntity(first_entity=test, age=2)\n\n    xtdb_session.put(test)\n    xtdb_session.put(second1)\n    xtdb_session.put(second2)\n    xtdb_session.commit()\n\n    query = Query(FirstEntity).where(SecondEntity, age=1).where(SecondEntity, first_entity=FirstEntity)\n    result = xtdb_session.query(query)\n\n    assert result[0].dict() == {\"FirstEntity/name\": \"test\", \"type\": \"FirstEntity\", \"xt/id\": test.id}\n\n    query = query.where(FirstEntity, name=\"test\")\n    result = xtdb_session.query(query)\n    assert result[0].dict() == {\"FirstEntity/name\": \"test\", \"type\": \"FirstEntity\", \"xt/id\": test.id}\n\n    xtdb_session.delete(test)\n    xtdb_session.delete(second1)\n    xtdb_session.delete(second2)\n    xtdb_session.commit()", "\n\ndef test_deep_queries(xtdb_session: XTDBSession):\n    test = FirstEntity(name=\"test\")\n    second = SecondEntity(first_entity=test, age=1)\n    second2 = SecondEntity(first_entity=test, age=4)\n    third = ThirdEntity(second_entity=second2, first_entity=test)\n    fourth = FourthEntity(third_entity=third, value=15.3)\n\n    xtdb_session.put(test)\n    xtdb_session.put(second)\n    xtdb_session.put(second2)\n    xtdb_session.put(third)\n    xtdb_session.put(fourth)\n    xtdb_session.commit()\n\n    query = Query(SecondEntity)\n    result = xtdb_session.query(query)\n\n    assert len(result) == 2\n    results = [x.dict() for x in result]\n\n    assert {\n        \"SecondEntity/age\": 4,\n        \"type\": \"SecondEntity\",\n        \"xt/id\": second2.id,\n        \"SecondEntity/first_entity\": test.id,\n    } in results\n    assert {\n        \"SecondEntity/age\": 1,\n        \"type\": \"SecondEntity\",\n        \"xt/id\": second.id,\n        \"SecondEntity/first_entity\": test.id,\n    } in results\n\n    query = Query(SecondEntity).where(SecondEntity, age=Var(\"age\")).avg(Var(\"age\"))\n    avg_result = xtdb_session.client.query(query)\n    assert avg_result == [[2.5]]\n\n    query = (\n        Query(SecondEntity)\n        .where(FourthEntity, third_entity=ThirdEntity, value=15.3)\n        .where(ThirdEntity, second_entity=SecondEntity)\n    )\n    result = xtdb_session.query(query)\n    assert result[0].dict() == {\n        \"SecondEntity/age\": 4,\n        \"type\": \"SecondEntity\",\n        \"xt/id\": second2.id,\n        \"SecondEntity/first_entity\": test.id,\n    }\n\n    attribute_stats = xtdb_session.client.get_attribute_stats()\n    assert attribute_stats == {\n        \"FourthEntity/third_entity\": 1,\n        \"FourthEntity/value\": 1,\n        \"SecondEntity/age\": 4,\n        \"SecondEntity/first_entity\": 4,\n        \"FirstEntity/name\": 8,\n        \"ThirdEntity/second_entity\": 1,\n        \"ThirdEntity/first_entity\": 1,\n        \"type\": 14,\n        \"xt/id\": 14,\n    }\n\n    xtdb_session.delete(fourth)\n    xtdb_session.delete(third)\n    xtdb_session.delete(second2)\n    xtdb_session.delete(second)\n    xtdb_session.delete(test)\n    xtdb_session.commit()", "\n\ndef test_aggregates(xtdb_session: XTDBSession):\n    test = FirstEntity(name=\"test\")\n    second = SecondEntity(first_entity=test, age=1)\n    second2 = SecondEntity(first_entity=test, age=4)\n\n    xtdb_session.put(test)\n    xtdb_session.put(second)\n    xtdb_session.put(second2)\n    xtdb_session.commit()\n\n    query = Query(SecondEntity).count(SecondEntity)\n\n    with pytest.raises(XTDBException):\n        xtdb_session.query(query)\n\n    count_result = xtdb_session.client.query(query)\n    assert count_result == [[2]]\n\n    count_result = xtdb_session.client.query(query.count(SecondEntity))\n    assert count_result == [[2, 2]]\n\n    query = Query(SecondEntity).where(SecondEntity, age=Var(\"age\")).avg(Var(\"age\"))\n    avg_result = xtdb_session.client.query(query)\n    assert avg_result == [[2.5]]\n\n    query = Query(SecondEntity).where(SecondEntity, age=Var(\"age\")).sum(Var(\"age\"))\n    sum_result = xtdb_session.client.query(query)\n    assert sum_result == [[5]]\n\n    query = Query(SecondEntity).where(SecondEntity, age=Var(\"age\")).min(Var(\"age\"))\n    min_result = xtdb_session.client.query(query)\n    assert min_result == [[1]]\n\n    query = Query(SecondEntity).where(SecondEntity, age=Var(\"age\")).max(Var(\"age\"))\n    max_result = xtdb_session.client.query(query)\n    assert max_result == [[4]]\n\n    query = Query(SecondEntity).where(SecondEntity, age=Var(\"age\")).median(Var(\"age\"))\n    median_result = xtdb_session.client.query(query)\n    assert median_result == [[2.5]]\n\n    query = Query(SecondEntity).where(SecondEntity, age=Var(\"age\")).variance(Var(\"age\"))\n    variance_result = xtdb_session.client.query(query)\n    assert variance_result == [[2.25]]  # As the average is 2.5, the variance is sqrt((1 - 2.5)^2 * (4 - 2.5)^2) = 2.25\n\n    xtdb_session.delete(second2)\n    xtdb_session.delete(second)\n    xtdb_session.delete(test)\n    xtdb_session.commit()", "\n\ndef test_query_empty_on_reference_filter_for_wrong_entity(xtdb_session: XTDBSession):\n    test = FirstEntity(name=\"test\")\n    test2 = FirstEntity(name=\"test2\")\n    second = SecondEntity(first_entity=test2, age=12)\n\n    xtdb_session.put(test)\n    xtdb_session.put(test2)\n    xtdb_session.put(second)\n    xtdb_session.commit()\n\n    query = Query(FirstEntity).where(FirstEntity, name=\"test\").where(SecondEntity, age=12)  # No foreign key\n    result = xtdb_session.query(query)\n    assert result[0].dict() == {\"FirstEntity/name\": \"test\", \"type\": \"FirstEntity\", \"xt/id\": test.id}\n\n    query = query.where(SecondEntity, first_entity=FirstEntity)  # Add foreign key constraint\n    assert xtdb_session.query(query) == []\n    assert len(xtdb_session.query(Query(FirstEntity))) == 2\n\n    xtdb_session.delete(test)\n    xtdb_session.delete(test2)\n    xtdb_session.delete(second)\n    xtdb_session.commit()", "\n\ndef test_submit_and_trigger_fn(xtdb_session: XTDBSession):\n    test = FirstEntity(name=\"test\")\n    second = SecondEntity(first_entity=test, age=12)\n    increment_age_fn = Fn(\n        function=\"(fn [ctx eid] (let [db (xtdb.api/db ctx) entity (xtdb.api/entity db eid)] \"\n        \"[[:xtdb.api/put (update entity :SecondEntity/age inc)]]))\",\n        identifier=\"increment_age\",\n    )\n\n    xtdb_session.put(test)\n    xtdb_session.put(second)\n    xtdb_session.put(increment_age_fn)\n    xtdb_session.commit()\n\n    result = xtdb_session.get(second.id)\n    assert result[\"SecondEntity/age\"] == 12\n\n    with pytest.raises(XTDBException):\n        xtdb_session.get(second.id, tx_time=datetime.now(timezone.utc) - timedelta(seconds=10))\n\n    xtdb_session.fn(increment_age_fn, second.id)\n    xtdb_session.commit()\n\n    result = xtdb_session.get(second.id)\n    assert result[\"SecondEntity/age\"] == 13\n\n    xtdb_session.fn(increment_age_fn, second.id)\n    xtdb_session.fn(increment_age_fn, second.id)\n    xtdb_session.commit()\n\n    result = xtdb_session.get(second.id)\n    assert result[\"SecondEntity/age\"] == 15\n\n    xtdb_session.delete(test)\n    xtdb_session.delete(second)\n    xtdb_session.delete(increment_age_fn)\n    xtdb_session.commit()", "\n\ndef test_get_entity_history(xtdb_session: XTDBSession):\n    test = FirstEntity(name=\"test\")\n    xtdb_session.put(test, datetime(1000, 10, 10))\n    xtdb_session.commit()\n\n    test.name = \"new name\"\n    xtdb_session.put(test, datetime(1000, 10, 10))\n    xtdb_session.commit()\n\n    test.name = \"new name 2\"\n    xtdb_session.put(test, datetime(1000, 10, 11))\n    xtdb_session.commit()\n\n    result = xtdb_session.client.get_entity_history(test.id)\n    assert len(result) == 2\n\n    assert list(result[0].keys()) == [\"txTime\", \"txId\", \"validTime\", \"contentHash\"]\n    assert list(result[1].keys()) == [\"txTime\", \"txId\", \"validTime\", \"contentHash\"]\n\n    assert result[0][\"validTime\"] == \"1000-10-10T00:00:00Z\"\n    assert result[1][\"validTime\"] == \"1000-10-11T00:00:00Z\"\n\n    assert xtdb_session.client.get_entity_history(test.id, sort_order=\"desc\")[1] == result[0]\n\n    assert len(xtdb_session.client.get_entity_history(test.id, start_tx_id=result[1][\"txId\"])) == 1\n    assert len(xtdb_session.client.get_entity_history(test.id, end_tx_id=result[1][\"txId\"])) == 1\n    assert len(xtdb_session.client.get_entity_history(test.id, start_valid_time=datetime(1000, 10, 10, 10))) == 1\n    assert len(xtdb_session.client.get_entity_history(test.id, end_valid_time=datetime(1000, 10, 10, 10))) == 1\n\n    result = xtdb_session.client.get_entity_history(test.id, with_docs=True, with_corrections=True)\n    assert len(result) == 3\n\n    assert list(result[0].keys()) == [\"txTime\", \"txId\", \"validTime\", \"contentHash\", \"doc\"]\n    assert result[0][\"doc\"][\"xt/id\"] == test.id\n    assert result[0][\"doc\"][\"FirstEntity/name\"] == \"test\"\n\n    assert result[1][\"doc\"][\"FirstEntity/name\"] == \"new name\"\n    assert result[2][\"doc\"][\"FirstEntity/name\"] == \"new name 2\"\n\n    xtdb_session.delete(test)\n    xtdb_session.commit()", "\n\ndef test_get_entity_transactions(xtdb_session: XTDBSession):\n    test = FirstEntity(name=\"test\")\n\n    xtdb_session.put(test, datetime(1000, 10, 10))\n    xtdb_session.commit()\n\n    test.name = \"new name\"\n    xtdb_session.put(test, datetime(1000, 10, 10))\n    xtdb_session.commit()\n\n    test.name = \"new name 2\"\n    xtdb_session.put(test, datetime(1000, 10, 11))\n    xtdb_session.commit()\n\n    result = xtdb_session.client.get_entity_transactions(test.id)\n\n    assert list(result.keys()) == [\"id\", \"contentHash\", \"validTime\", \"txTime\", \"txId\"]\n    assert result[\"validTime\"] == \"1000-10-11T00:00:00Z\"\n\n    result = xtdb_session.client.get_entity_transactions(test.id, tx_id=result[\"txId\"] - 1)\n    assert result[\"validTime\"] == \"1000-10-10T00:00:00Z\"\n\n    # TODO: check transaction time\n\n    result = xtdb_session.client.get_entity_transactions(test.id, valid_time=datetime(1000, 10, 10))\n    assert result[\"validTime\"] == \"1000-10-10T00:00:00Z\"\n\n    xtdb_session.delete(test)\n    xtdb_session.commit()", "\n\ndef test_transaction_api(xtdb_session: XTDBSession):\n    test = FirstEntity(name=\"test\")\n    second = SecondEntity(first_entity=test, age=1)\n    second2 = SecondEntity(first_entity=test, age=4)\n\n    xtdb_session.put(test)\n    xtdb_session.put(second)\n    xtdb_session.put(second2)\n    xtdb_session.commit()\n\n    result = xtdb_session.client.get_transaction_log()\n    assert len(result) == 30\n    assert list(result[0].keys()) == [\"txId\", \"txTime\", \"txEvents\"]\n\n    result = xtdb_session.client.get_transaction_log(10)\n    assert len(result) == 20\n\n    result = xtdb_session.client.get_transaction_log(10, True)\n    assert len(result) == 20\n    assert list(result[0].keys()) == [\"txId\", \"txTime\", \"txOps\"]\n\n    result = xtdb_session.client.get_transaction_committed(10)\n    assert result == {\"txCommitted?\": True}\n\n    result = xtdb_session.client.get_latest_completed_transaction()\n    assert result[\"txId\"] == 30\n\n    result = xtdb_session.client.get_latest_submitted_transaction()\n    assert result[\"txId\"] == 30\n\n    result = xtdb_session.client.get_active_queries()\n    assert result == []\n\n    query = Query(SecondEntity).where(SecondEntity, age=1)\n    xtdb_session.query(query)\n\n    result = xtdb_session.client.get_recent_queries()\n    assert result[0][\"error\"] is None\n    assert (\n        result[0][\"query\"] == \"{:find [(pull SecondEntity [*])], :where [[SecondEntity :SecondEntity/age 1] \"\n        '[SecondEntity :type \"SecondEntity\"]]}'\n    )\n\n    result = xtdb_session.client.get_slowest_queries()\n    assert result == []\n\n    xtdb_session.delete(second2)\n    xtdb_session.delete(second)\n    xtdb_session.delete(test)\n    xtdb_session.commit()", "\n\ndef test_query_limit_timeout_where_in(xtdb_session: XTDBSession):\n    with xtdb_session:\n        entity = FirstEntity(name=\"test\")\n        xtdb_session.put(entity)\n\n    query = (\n        Find(\"FirstEntity\")\n        & Where(\"FirstEntity\", \"FirstEntity/name\", \"name\")\n        & Limit(2)\n        & Timeout(29)\n        & In(\"name\", \"test\")\n    )\n    result = xtdb_session.client.query(query)\n    assert result == [[entity.id]]\n\n    with xtdb_session:\n        xtdb_session.delete(entity)", "\n\ndef test_sum_count_where_with_exceptions(xtdb_session: XTDBSession):\n    with xtdb_session:\n        entity = FirstEntity(name=\"test\")\n        second = FirstEntity(name=\"test2\")\n        third = SecondEntity(age=3, first_entity=entity)\n        fourth = SecondEntity(age=5, first_entity=entity)\n        xtdb_session.put(entity)\n        xtdb_session.put(second)\n        xtdb_session.put(third)\n        xtdb_session.put(fourth)\n\n    result = xtdb_session.client.query(Count(\"x\") & Where(\"x\", \"type\", '\"FirstEntity\"'))\n    assert result == [[2]]\n\n    result = xtdb_session.client.query(Sum(\"age\") & Where(\"x\", \"SecondEntity/age\", \"age\"))\n    assert result == [[8]]\n\n    with pytest.raises(XTDBException):\n        xtdb_session.client.query(Sum(\"x\") & Where(\"x\", \"type\", '\"FirstEntity\"'))\n\n    with pytest.raises(XTDBException):\n        xtdb_session.client.query(Sum(\"x\") & Where(\"x\", \"type\", '\"FirstEntity\"'))\n\n    with pytest.raises(XTDBException):\n        xtdb_session.client.query(Sum(\"x\") & Where(\"x\", \"type\", '\"FirstEntity\"'))\n\n    result = xtdb_session.client.query(Count(\"x\") & Where(\"x\", \"type\", '\"FirstEntity\"'))\n    assert result == [[2]]\n\n    with pytest.raises(XTDBException):\n        xtdb_session.client.query(Sum(\"x\") & Where(\"x\", \"type\", '\"FirstEntity\"'))\n\n    with xtdb_session:\n        xtdb_session.delete(entity)\n        xtdb_session.delete(second)\n        xtdb_session.delete(third)\n        xtdb_session.delete(fourth)", ""]}
{"filename": "tests/integration/__init__.py", "chunked_list": [""]}
{"filename": "xtdb/__main__.py", "chunked_list": ["import json\nimport os\nimport sys\n\nfrom xtdb.session import XTDBClient\n\nif __name__ == \"__main__\":\n    output = XTDBClient(os.environ[\"XTDB_URI\"]).query(sys.stdin.read())\n    sys.stdout.write(json.dumps(output))\n", ""]}
{"filename": "xtdb/query.py", "chunked_list": ["\"\"\"\nA module containing the logic to generate XTDB queries using the ORM models.\n\"\"\"\n\nfrom dataclasses import dataclass\nfrom typing import List, Literal, Optional, Tuple, Type, Union\n\nfrom xtdb.datalog import (\n    Avg,\n    Clause,", "    Avg,\n    Clause,\n    Count,\n    CountDistinct,\n    Distinct,\n    Find,\n    Limit,\n    Max,\n    Median,\n    Min,", "    Median,\n    Min,\n    Offset,\n    Or,\n    OrderBy,\n    Rand,\n    Sample,\n    Stddev,\n    Sum,\n    Timeout,", "    Sum,\n    Timeout,\n    Variance,\n    Where,\n)\nfrom xtdb.exceptions import InvalidField\nfrom xtdb.orm import TYPE_FIELD, Base\n\n\n@dataclass\nclass Var:\n    val: str\n\n    def __str__(self):\n        return f\"?{self.val}\"", "\n@dataclass\nclass Var:\n    val: str\n\n    def __str__(self):\n        return f\"?{self.val}\"\n\n\n@dataclass\nclass Query:\n    \"\"\"\n    Example usage:\n\n    >>> query = Query(Object1).where(Object1, name=\"test\")\n    >>> query = query.where(Object2, object_one_reference=Object1)\n    >>> query.format()\n    '\n    {:query {:find [(pull Object1 [*])] :where [\n        [ Object1 :Object1/name \"test\" ]\n        [ Object2 :Object2/object_one_reference Object1 ]\n    ]}}\n    '\n    \"\"\"\n\n    result_type: Type[Base]\n\n    _find: Optional[Clause] = None\n    _where: Optional[Clause] = None\n    _limit: Optional[Limit] = None\n    _order_by: Optional[OrderBy] = None\n    _offset: Optional[Offset] = None\n    _timeout: Optional[Timeout] = None\n\n    _preserved_return_type: bool = True\n\n    def where(self, object_type: Type[Base], **kwargs) -> \"Query\":\n        for field_name, value in kwargs.items():\n            self._where_field_is(object_type, field_name, value)\n\n        return self\n\n    def format(self) -> str:\n        return self._compile(separator=\"\\n    \")\n\n    def count(self, var: Union[Type[Base], Var]) -> \"Query\":\n        self._preserved_return_type = False\n\n        if isinstance(var, Var):\n            self._find = self._find & Count(str(var))\n            return self\n\n        self._find = self._find & Count(var.alias())\n        return self\n\n    def avg(self, var: Var) -> \"Query\":\n        self._preserved_return_type = False\n        self._find = self._find & Avg(str(var))\n\n        return self\n\n    def max(self, var: Var) -> \"Query\":\n        self._preserved_return_type = False\n        self._find = self._find & Max(str(var))\n\n        return self\n\n    def min(self, var: Var) -> \"Query\":\n        self._preserved_return_type = False\n        self._find = self._find & Min(str(var))\n\n        return self\n\n    def count_distinct(self, var: Var) -> \"Query\":\n        self._preserved_return_type = False\n        self._find = self._find & CountDistinct(str(var))\n\n        return self\n\n    def sum(self, var: Var) -> \"Query\":\n        self._preserved_return_type = False\n        self._find = self._find & Sum(str(var))\n\n        return self\n\n    def median(self, var: Var) -> \"Query\":\n        self._preserved_return_type = False\n        self._find = self._find & Median(str(var))\n\n        return self\n\n    def variance(self, var: Var) -> \"Query\":\n        self._preserved_return_type = False\n        self._find = self._find & Variance(str(var))\n\n        return self\n\n    def stddev(self, var: Var) -> \"Query\":\n        self._preserved_return_type = False\n        self._find = self._find & Stddev(str(var))\n\n        return self\n\n    def distinct(self, var: Var) -> \"Query\":\n        self._preserved_return_type = False\n        self._find = self._find & Distinct(str(var))\n\n        return self\n\n    def rand(self, var: Var, N: int) -> \"Query\":\n        self._preserved_return_type = False\n        self._find = self._find & Rand(str(var), N)\n\n        return self\n\n    def sample(self, var: Var, N: int) -> \"Query\":\n        self._preserved_return_type = False\n        self._find = self._find & Sample(str(var), N)\n\n        return self\n\n    def order_by(self, fields: List[Tuple[str, Literal[\"asc\", \"desc\"]]]) -> \"Query\":\n        self._order_by = OrderBy(fields)\n\n        return self\n\n    def limit(self, limit: int) -> \"Query\":\n        self._limit = Limit(limit)\n\n        return self\n\n    def offset(self, offset: int) -> \"Query\":\n        self._offset = Offset(offset)\n\n        return self\n\n    def timeout(self, timeout: int) -> \"Query\":\n        self._timeout = Timeout(timeout)\n\n        return self\n\n    def _where_field_is(\n        self, object_type: Type[Base], field_name: str, value: Union[Type[Base], Var, str, None]\n    ) -> None:\n        if field_name not in object_type.fields():\n            raise InvalidField(f'\"{field_name}\" is not a field of {object_type.alias()}')\n\n        if isinstance(value, str):\n            value = value.replace('\"', r\"\\\"\")\n            return self._add_where_statement(object_type, field_name, f'\"{value}\"')\n\n        if isinstance(value, (int, float, bool, Var)):\n            return self._add_where_statement(object_type, field_name, f\"{str(value).lower()}\")\n\n        if value is None:\n            return self._add_where_statement(object_type, field_name, \"nil\")\n\n        # TODO: support for list and dict?\n        if not isinstance(value, type):\n            raise InvalidField(f\"value '{value}' should be a string or a Base Type\")\n        if not issubclass(value, Base):\n            raise InvalidField(f\"{value} is not an Base Type\")\n        if field_name not in object_type.relations():\n            raise InvalidField(f'\"{field_name}\" is not a relation of {object_type.alias()}')\n\n        if object_type.subclasses():\n            return self._add_or_statement(object_type, field_name, value.alias())\n\n        self._add_where_statement(object_type, field_name, value.alias())\n\n    def _add_where_statement(self, object_type: Type[Base], field_name: str, to_alias: str) -> None:\n        self._where = self._where & Where(object_type.alias(), f\"{object_type.alias()}/{field_name}\", to_alias)\n\n    def _add_or_statement(self, object_type: Type[Base], field_name: str, to_alias: str) -> None:\n        clauses = [\n            Where(object_type.alias(), f\"{sc.alias()}/{field_name}\", to_alias) for sc in object_type.subclasses()\n        ]\n        self._where = self._where & Or(clauses)  # type: ignore\n\n    def _compile(self, *, separator=\" \") -> str:\n        where = self._where & Where(self.result_type.alias(), TYPE_FIELD, f'\"{self.result_type.alias()}\"')\n        find = Find(f\"(pull {self.result_type.alias()} [*])\") if self._find is None else self._find\n        find_where = find & where & self._order_by & self._limit & self._offset & self._timeout\n\n        return find_where.compile(separator=separator)\n\n    def __str__(self) -> str:\n        return self._compile()\n\n    def __eq__(self, other):\n        return str(self) == str(other)", "\n@dataclass\nclass Query:\n    \"\"\"\n    Example usage:\n\n    >>> query = Query(Object1).where(Object1, name=\"test\")\n    >>> query = query.where(Object2, object_one_reference=Object1)\n    >>> query.format()\n    '\n    {:query {:find [(pull Object1 [*])] :where [\n        [ Object1 :Object1/name \"test\" ]\n        [ Object2 :Object2/object_one_reference Object1 ]\n    ]}}\n    '\n    \"\"\"\n\n    result_type: Type[Base]\n\n    _find: Optional[Clause] = None\n    _where: Optional[Clause] = None\n    _limit: Optional[Limit] = None\n    _order_by: Optional[OrderBy] = None\n    _offset: Optional[Offset] = None\n    _timeout: Optional[Timeout] = None\n\n    _preserved_return_type: bool = True\n\n    def where(self, object_type: Type[Base], **kwargs) -> \"Query\":\n        for field_name, value in kwargs.items():\n            self._where_field_is(object_type, field_name, value)\n\n        return self\n\n    def format(self) -> str:\n        return self._compile(separator=\"\\n    \")\n\n    def count(self, var: Union[Type[Base], Var]) -> \"Query\":\n        self._preserved_return_type = False\n\n        if isinstance(var, Var):\n            self._find = self._find & Count(str(var))\n            return self\n\n        self._find = self._find & Count(var.alias())\n        return self\n\n    def avg(self, var: Var) -> \"Query\":\n        self._preserved_return_type = False\n        self._find = self._find & Avg(str(var))\n\n        return self\n\n    def max(self, var: Var) -> \"Query\":\n        self._preserved_return_type = False\n        self._find = self._find & Max(str(var))\n\n        return self\n\n    def min(self, var: Var) -> \"Query\":\n        self._preserved_return_type = False\n        self._find = self._find & Min(str(var))\n\n        return self\n\n    def count_distinct(self, var: Var) -> \"Query\":\n        self._preserved_return_type = False\n        self._find = self._find & CountDistinct(str(var))\n\n        return self\n\n    def sum(self, var: Var) -> \"Query\":\n        self._preserved_return_type = False\n        self._find = self._find & Sum(str(var))\n\n        return self\n\n    def median(self, var: Var) -> \"Query\":\n        self._preserved_return_type = False\n        self._find = self._find & Median(str(var))\n\n        return self\n\n    def variance(self, var: Var) -> \"Query\":\n        self._preserved_return_type = False\n        self._find = self._find & Variance(str(var))\n\n        return self\n\n    def stddev(self, var: Var) -> \"Query\":\n        self._preserved_return_type = False\n        self._find = self._find & Stddev(str(var))\n\n        return self\n\n    def distinct(self, var: Var) -> \"Query\":\n        self._preserved_return_type = False\n        self._find = self._find & Distinct(str(var))\n\n        return self\n\n    def rand(self, var: Var, N: int) -> \"Query\":\n        self._preserved_return_type = False\n        self._find = self._find & Rand(str(var), N)\n\n        return self\n\n    def sample(self, var: Var, N: int) -> \"Query\":\n        self._preserved_return_type = False\n        self._find = self._find & Sample(str(var), N)\n\n        return self\n\n    def order_by(self, fields: List[Tuple[str, Literal[\"asc\", \"desc\"]]]) -> \"Query\":\n        self._order_by = OrderBy(fields)\n\n        return self\n\n    def limit(self, limit: int) -> \"Query\":\n        self._limit = Limit(limit)\n\n        return self\n\n    def offset(self, offset: int) -> \"Query\":\n        self._offset = Offset(offset)\n\n        return self\n\n    def timeout(self, timeout: int) -> \"Query\":\n        self._timeout = Timeout(timeout)\n\n        return self\n\n    def _where_field_is(\n        self, object_type: Type[Base], field_name: str, value: Union[Type[Base], Var, str, None]\n    ) -> None:\n        if field_name not in object_type.fields():\n            raise InvalidField(f'\"{field_name}\" is not a field of {object_type.alias()}')\n\n        if isinstance(value, str):\n            value = value.replace('\"', r\"\\\"\")\n            return self._add_where_statement(object_type, field_name, f'\"{value}\"')\n\n        if isinstance(value, (int, float, bool, Var)):\n            return self._add_where_statement(object_type, field_name, f\"{str(value).lower()}\")\n\n        if value is None:\n            return self._add_where_statement(object_type, field_name, \"nil\")\n\n        # TODO: support for list and dict?\n        if not isinstance(value, type):\n            raise InvalidField(f\"value '{value}' should be a string or a Base Type\")\n        if not issubclass(value, Base):\n            raise InvalidField(f\"{value} is not an Base Type\")\n        if field_name not in object_type.relations():\n            raise InvalidField(f'\"{field_name}\" is not a relation of {object_type.alias()}')\n\n        if object_type.subclasses():\n            return self._add_or_statement(object_type, field_name, value.alias())\n\n        self._add_where_statement(object_type, field_name, value.alias())\n\n    def _add_where_statement(self, object_type: Type[Base], field_name: str, to_alias: str) -> None:\n        self._where = self._where & Where(object_type.alias(), f\"{object_type.alias()}/{field_name}\", to_alias)\n\n    def _add_or_statement(self, object_type: Type[Base], field_name: str, to_alias: str) -> None:\n        clauses = [\n            Where(object_type.alias(), f\"{sc.alias()}/{field_name}\", to_alias) for sc in object_type.subclasses()\n        ]\n        self._where = self._where & Or(clauses)  # type: ignore\n\n    def _compile(self, *, separator=\" \") -> str:\n        where = self._where & Where(self.result_type.alias(), TYPE_FIELD, f'\"{self.result_type.alias()}\"')\n        find = Find(f\"(pull {self.result_type.alias()} [*])\") if self._find is None else self._find\n        find_where = find & where & self._order_by & self._limit & self._offset & self._timeout\n\n        return find_where.compile(separator=separator)\n\n    def __str__(self) -> str:\n        return self._compile()\n\n    def __eq__(self, other):\n        return str(self) == str(other)", ""]}
{"filename": "xtdb/__init__.py", "chunked_list": [""]}
{"filename": "xtdb/session.py", "chunked_list": ["\"\"\"\nA module containing all logic related to connecting to an XTDB node and managing transactional scope.\n\"\"\"\n\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom datetime import datetime, timezone\nfrom enum import Enum\nfrom json import JSONDecodeError", "from enum import Enum\nfrom json import JSONDecodeError\nfrom typing import Any, Dict, List, Literal, Optional, Type, Union\n\nfrom requests import HTTPError, Response, Session\nfrom requests.adapters import DEFAULT_POOLBLOCK, DEFAULT_POOLSIZE, HTTPAdapter\nfrom requests.exceptions import ConnectionError\nfrom urllib3 import Retry\n\nfrom xtdb.datalog import Clause, FindWhere", "\nfrom xtdb.datalog import Clause, FindWhere\nfrom xtdb.exceptions import XTDBException\nfrom xtdb.orm import Base, Fn\nfrom xtdb.query import Query\n\nlogger = logging.getLogger(\"XTDB\")\n\n\n@dataclass\nclass XTDBStatus:\n    version: Optional[str]\n    revision: Optional[str]\n    indexVersion: Optional[int]\n    consumerState: Optional[str]\n    kvStore: Optional[str]\n    estimateNumKeys: Optional[int]\n    size: Optional[int]", "\n@dataclass\nclass XTDBStatus:\n    version: Optional[str]\n    revision: Optional[str]\n    indexVersion: Optional[int]\n    consumerState: Optional[str]\n    kvStore: Optional[str]\n    estimateNumKeys: Optional[int]\n    size: Optional[int]", "\n\nclass OperationType(Enum):\n    PUT = \"put\"\n    DELETE = \"delete\"\n    MATCH = \"match\"\n    EVICT = \"evict\"\n    FN = \"fn\"\n\n", "\n\n@dataclass\nclass Operation:\n    type: OperationType\n    value: Union[str, Dict[str, Any]]\n    valid_time: Optional[datetime] = field(default_factory=lambda: datetime.now(timezone.utc))\n\n    def to_list(self):\n        if self.valid_time is None:\n            self.valid_time = datetime.now(timezone.utc)\n\n        if self.type is OperationType.MATCH:\n            return [self.type.value, self.value[\"xt/id\"], self.value, self.valid_time.isoformat()]\n        if self.type is OperationType.FN:\n            return [self.type.value, self.value[\"identifier\"], *self.value[\"args\"]]\n        if self.type is OperationType.PUT and \"xt/fn\" in self.value:\n            return [self.type.value, self.value]\n\n        return [self.type.value, self.value, self.valid_time.isoformat()]\n\n    @classmethod\n    def put(cls, document: Dict, valid_time: Optional[datetime] = None) -> \"Operation\":\n        return cls(OperationType.PUT, document, valid_time)\n\n    @classmethod\n    def delete(cls, pk: str, valid_time: Optional[datetime] = None) -> \"Operation\":\n        return cls(OperationType.DELETE, pk, valid_time)\n\n    @classmethod\n    def match(cls, document: Dict, valid_time: Optional[datetime] = None) -> \"Operation\":\n        return cls(OperationType.MATCH, document, valid_time)\n\n    @classmethod\n    def evict(cls, pk: str, valid_time: Optional[datetime] = None) -> \"Operation\":\n        return cls(OperationType.EVICT, pk, valid_time)\n\n    @classmethod\n    def fn(cls, identifier: str, *args) -> \"Operation\":\n        return cls(OperationType.FN, {\"identifier\": identifier, \"args\": args})", "\n\n@dataclass\nclass Transaction:\n    operations: List[Operation] = field(default_factory=list)\n\n    def add(self, operation: Operation):\n        self.operations.append(operation)\n\n    def json(self, **kwargs):\n        return json.dumps({\"tx-ops\": [op.to_list() for op in self.operations]}, **kwargs)", "\n\nclass XTDBClient:\n    def __init__(\n        self,\n        base_url: str,\n        pool_connections: int = DEFAULT_POOLSIZE,\n        pool_maxsize: int = DEFAULT_POOLSIZE,\n        pool_block: bool = DEFAULT_POOLBLOCK,\n        retries: int = 6,\n        backoff_factor: float = 0.5,\n    ):\n        self.base_url = base_url\n        self.adapter = HTTPAdapter(\n            pool_connections=pool_connections,\n            pool_maxsize=pool_maxsize,\n            pool_block=pool_block,\n            max_retries=Retry(total=retries, backoff_factor=backoff_factor, connect=3),\n        )\n        self._session = self.get_session()\n\n    def get_session(self) -> Session:\n        session = Session()\n\n        session.mount(\"http://\", self.adapter)\n        session.mount(\"https://\", self.adapter)\n        session.headers[\"Accept\"] = \"application/json\"\n        session.hooks[\"response\"] = self._verify_response\n\n        logger.debug(\"Initialized new HTTP session\")\n\n        return session\n\n    def refresh(self):\n        self._session = self.get_session()\n\n    @staticmethod\n    def _verify_response(response: Response, *args, **kwargs) -> None:\n        logger.debug('\"%s %s\" %s', response.request.method, response.request.url, response.status_code)\n\n        try:\n            response.raise_for_status()\n        except HTTPError as e:\n            logger.exception(\"Request failed\")\n\n            raise XTDBException from e\n\n    def status(self) -> XTDBStatus:\n        return XTDBStatus(**self._session.get(f\"{self.base_url}/status\").json())\n\n    def get_entity(\n        self,\n        eid: str,\n        *,\n        valid_time: Optional[datetime] = None,\n        tx_time: Optional[datetime] = None,\n        tx_id: Optional[int] = None,\n    ) -> Dict:\n        params = self._format_parameter(\"eid\", eid)\n        params = self._format_parameter(\"valid-time\", valid_time, params)\n        params = self._format_parameter(\"tx-time\", tx_time, params)\n        params = self._format_parameter(\"tx-id\", tx_id, params)\n\n        res = self._session.get(f\"{self.base_url}/entity\", params=params)\n        return res.json()\n\n    def get_entity_transactions(\n        self,\n        eid: str,\n        *,\n        valid_time: Optional[datetime] = None,\n        tx_time: Optional[datetime] = None,\n        tx_id: Optional[int] = None,\n    ) -> Dict:\n        params = self._format_parameter(\"eid\", eid)\n        params = self._format_parameter(\"valid-time\", valid_time, params)\n        params = self._format_parameter(\"tx-time\", tx_time, params)\n        params = self._format_parameter(\"tx-id\", tx_id, params)\n\n        return self._session.get(f\"{self.base_url}/entity-tx\", params=params).json()\n\n    def get_entity_history(\n        self,\n        eid: str,\n        *,\n        sort_order: Literal[\"asc\", \"desc\"] = \"asc\",\n        with_corrections: bool = False,\n        with_docs: bool = False,\n        start_valid_time: Optional[datetime] = None,\n        start_tx_time: Optional[datetime] = None,\n        start_tx_id: Optional[int] = None,\n        end_valid_time: Optional[datetime] = None,\n        end_tx_time: Optional[datetime] = None,\n        end_tx_id: Optional[int] = None,\n    ) -> Dict:\n        params = self._format_parameter(\"eid\", eid)\n        params = self._format_parameter(\"history\", True, params)\n        params = self._format_parameter(\"sort-order\", sort_order, params)\n        params = self._format_parameter(\"with-corrections\", with_corrections, params)\n        params = self._format_parameter(\"with-docs\", with_docs, params)\n        params = self._format_parameter(\"start-valid-time\", start_valid_time, params)\n        params = self._format_parameter(\"start-tx-time\", start_tx_time, params)\n        params = self._format_parameter(\"start-tx-id\", start_tx_id, params)\n        params = self._format_parameter(\"end-valid-time\", end_valid_time, params)\n        params = self._format_parameter(\"end-tx-time\", end_tx_time, params)\n        params = self._format_parameter(\"end-tx-id\", end_tx_id, params)\n\n        return self._session.get(f\"{self.base_url}/entity\", params=params).json()\n\n    def get_attribute_stats(self):\n        return self._session.get(f\"{self.base_url}/attribute-stats\").json()\n\n    def sync(self, timeout: Optional[int] = None):\n        return self._session.get(f\"{self.base_url}/sync\", params=self._format_parameter(\"timeout\", timeout)).json()\n\n    def query(\n        self,\n        query: Union[str, Query, Clause],\n        *,\n        valid_time: Optional[datetime] = None,\n        tx_time: Optional[datetime] = None,\n        tx_id: Optional[int] = None,\n        tries: int = 0,\n    ) -> Union[List, Dict]:\n        if not isinstance(query, (str, Query)) and not issubclass(type(query), FindWhere):\n            raise XTDBException(\"Cannot query using incomplete clause\")\n\n        params = self._format_parameter(\"valid-time\", valid_time)\n        params = self._format_parameter(\"tx-time\", tx_time, params)\n        params = self._format_parameter(\"tx-id\", tx_id, params)\n\n        try:\n            return self._session.post(\n                f\"{self.base_url}/query\", str(query), params=params, headers={\"Content-Type\": \"application/edn\"}\n            ).json()\n        except JSONDecodeError as e:\n            if e.msg == \"Expecting value\":\n                # Empty bodies are returned when you do strange queries such as Sum(x) where x is not numerical.\n                raise XTDBException(\"Bad XTDB response: query probably failed\") from e\n            raise\n        except ConnectionError:\n            if tries > 0:\n                raise\n\n            # Bad queries cleave connections in a bad state, which is fixed by creating a new requests.Session()\n            self.refresh()\n            return self.query(query, valid_time=valid_time, tx_time=tx_time, tx_id=tx_id, tries=1)\n\n    def await_transaction(self, tx_id: int, timeout: Optional[int] = None) -> None:\n        params = self._format_parameter(\"timeout\", timeout)\n        params = self._format_parameter(\"tx-id\", tx_id, params)\n\n        self._session.get(f\"{self.base_url}/await-tx\", params=params)\n\n    def await_transaction_time(self, tx_time: datetime, timeout: Optional[int] = None) -> None:\n        params = self._format_parameter(\"tx-time\", tx_time)\n        params = self._format_parameter(\"timeout\", timeout, params)\n\n        self._session.get(f\"{self.base_url}/await-tx-time\", params=params)\n\n    def get_transaction_log(self, after_tx_id: Optional[int] = None, with_ops: Optional[bool] = None):\n        params = self._format_parameter(\"after-tx-id\", after_tx_id)\n        params = self._format_parameter(\"with-ops?\", with_ops, params)\n\n        return self._session.get(f\"{self.base_url}/tx-log\", params=params).json()\n\n    def submit_tx(self, transaction: Union[Transaction, List], tries: int = 0) -> None:\n        if isinstance(transaction, list):\n            transaction = Transaction(operations=transaction)\n\n        try:\n            res = self._session.post(\n                f\"{self.base_url}/submit-tx\", transaction.json(), headers={\"Content-Type\": \"application/json\"}\n            )\n        except ConnectionError:\n            if tries > 0:\n                raise\n\n            # Bad queries cleave connections in a bad state, which is fixed by creating a new requests.Session()\n            self.refresh()\n            return self.submit_tx(transaction, tries=1)\n\n        self.await_transaction(res.json()[\"txId\"])\n\n    def get_transaction_committed(self, tx_id: int):\n        return self._session.get(f\"{self.base_url}/tx-committed\", params=self._format_parameter(\"tx-id\", tx_id)).json()\n\n    def get_latest_completed_transaction(self):\n        return self._session.get(f\"{self.base_url}/latest-completed-tx\").json()\n\n    def get_latest_submitted_transaction(self):\n        return self._session.get(f\"{self.base_url}/latest-submitted-tx\").json()\n\n    def get_active_queries(self):\n        return self._session.get(f\"{self.base_url}/active-queries\").json()\n\n    def get_recent_queries(self):\n        return self._session.get(f\"{self.base_url}/recent-queries\").json()\n\n    def get_slowest_queries(self):\n        return self._session.get(f\"{self.base_url}/slowest-queries\").json()\n\n    @staticmethod\n    def _format_parameter(\n        key: str, parameter: Union[None, datetime, int, str, bool], current_params: Optional[Dict] = None\n    ) -> Dict:\n        if current_params is None:\n            current_params = {}\n\n        if isinstance(parameter, datetime):\n            current_params[key] = parameter.isoformat()\n        if isinstance(parameter, (int, str, bool)):\n            current_params[key] = str(parameter).lower()\n\n        return current_params", "\n\nclass XTDBSession:\n    def __init__(self, base_url: str):\n        self.client = XTDBClient(base_url)\n        self._transaction = Transaction()\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, _exc_type: Type[Exception], _exc_value: str, _exc_traceback: str) -> None:\n        self.commit()\n\n    def query(self, query: Query, **kwargs) -> List[Base]:\n        if not query._preserved_return_type:\n            raise XTDBException(\n                \"XTDBSession.query() only supports queries with preserved return types. Use XTDBClient.query() instead.\"\n            )\n        result = self.client.query(query, **kwargs)\n\n        return [query.result_type.from_dict(document[0]) for document in result]\n\n    def get(self, eid: str, **kwargs) -> Dict:\n        return self.client.get_entity(eid, **kwargs)\n\n    def put(self, document: Base, valid_time: Optional[datetime] = None) -> None:\n        self._transaction.add(Operation.put(document.dict(), valid_time))\n\n    def delete(self, document: Base, valid_time: Optional[datetime] = None) -> None:\n        self._transaction.add(Operation.delete(document.id, valid_time))\n\n    def match(self, document: Base, valid_time: Optional[datetime] = None) -> None:\n        self._transaction.add(Operation.match(document.dict(), valid_time))\n\n    def evict(self, document: Base, valid_time: Optional[datetime] = None) -> None:\n        self._transaction.add(Operation.evict(document.id, valid_time))\n\n    def fn(self, function: Fn, *args) -> None:\n        self._transaction.add(Operation.fn(function.identifier, *args))\n\n    def commit(self) -> None:\n        if operation_count := len(self._transaction.operations) == 0:\n            return\n\n        try:\n            self.client.submit_tx(self._transaction)\n            logger.debug(\"Committed %s operations\", operation_count)\n        finally:\n            self._transaction = Transaction()", ""]}
{"filename": "xtdb/orm.py", "chunked_list": ["\"\"\"\nThis module contains base classes for the creation of ORM models.\n\"\"\"\n\nimport uuid\nfrom dataclasses import asdict, dataclass\nfrom typing import Dict, List, Type\n\nTYPE_FIELD = \"type\"\n", "TYPE_FIELD = \"type\"\n\n\n@dataclass\nclass Base:\n    @property\n    def id(self):\n        if not hasattr(self, \"_pk_proxy\"):\n            self._pk_proxy = str(uuid.uuid4())\n\n        return self._pk_proxy\n\n    @classmethod\n    def fields(cls):\n        return cls.__dataclass_fields__\n\n    @classmethod\n    def relations(cls) -> List[str]:\n        return [key for key, value in cls.fields().items() if issubclass(value.type, Base)]\n\n    @classmethod\n    def subclasses(cls) -> List[Type[\"Base\"]]:\n        return cls.__subclasses__()\n\n    @classmethod\n    def alias(cls):\n        return cls.__name__\n\n    def dict(self) -> Dict:\n        result = {\"xt/id\": self.id, \"type\": self.alias()}\n\n        for key, value in asdict(self).items():\n            if issubclass(self.fields().get(key).type, Base):\n                field = self.__getattribute__(key)\n\n                # Foreign keys are not always hydrated\n                result[f\"{self.alias()}/{key}\"] = field.id if isinstance(field, Base) else field\n            else:\n                result[f\"{self.alias()}/{key}\"] = value\n\n        return result\n\n    @classmethod\n    def from_dict(cls, document: Dict) -> \"Base\":\n        doc = {key.replace(f\"{cls.alias()}/\", \"\"): value for key, value in document.items()}\n        pk = doc.pop(\"xt/id\")\n\n        del doc[\"type\"]\n\n        instance = cls(**doc)\n        instance._pk_proxy = pk\n\n        return instance", "\n\n@dataclass\nclass Fn(Base):\n    function: str\n    identifier: str\n\n    @property\n    def id(self):\n        return self.identifier\n\n    def dict(self) -> Dict:\n        return {\"xt/id\": self.identifier, \"xt/fn\": self.function}", ""]}
{"filename": "xtdb/exceptions.py", "chunked_list": ["\"\"\"\nException documentation. Note: all exceptions from the package inherit from the XTDBException class.\n\"\"\"\n\n\nclass XTDBException(Exception):\n    \"\"\"Base exception for XTDB errors.\"\"\"\n\n\nclass InvalidField(XTDBException):\n    \"\"\"Exception indicating an invalid field was passed during query creation in the ORM.\"\"\"", "\nclass InvalidField(XTDBException):\n    \"\"\"Exception indicating an invalid field was passed during query creation in the ORM.\"\"\"\n"]}
{"filename": "xtdb/datalog.py", "chunked_list": ["\"\"\"\nThe Datalog module contains all logic to declaratively create XTDB queries.\n\"\"\"\n\nfrom typing import Any, List, Literal, Optional, Tuple, Union\n\nfrom xtdb.exceptions import XTDBException\n\n\nclass Clause:\n    commutative = True\n    idempotent = True\n\n    def compile(self, root: bool = True, *, separator=\" \") -> str:\n        raise NotImplementedError\n\n    def format(self) -> str:\n        return self.compile(separator=\"\\n    \")\n\n    def _collect(self, *, separator=\" \") -> List:\n        return [self.compile(root=False, separator=separator)]\n\n    def __str__(self) -> str:\n        return self.compile()\n\n    def __and__(self, other: Optional[\"Clause\"]) -> \"Clause\":\n        if other is None:\n            return self\n\n        return self._and(other)\n\n    def _and(self, other: \"Clause\") -> \"Clause\":\n        if issubclass(type(other), Find):\n            raise XTDBException(\"Cannot perform a where-find. User find-where instead.\")\n\n        return And([self, other])\n\n    def __or__(self, other: Optional[\"Clause\"]) -> \"Clause\":\n        if other is None:\n            return self\n\n        return self._or(other)\n\n    def _or(self, other: \"Clause\") -> \"Clause\":\n        raise NotImplementedError\n\n    def __ror__(self, other: Optional[\"Clause\"]) -> \"Clause\":\n        if other is None:\n            return self\n\n        raise NotImplementedError\n\n    def __rand__(self, other: Optional[\"Clause\"]) -> \"Clause\":\n        if other is None:\n            return self\n\n        raise NotImplementedError\n\n    def __invert__(self):\n        raise NotImplementedError", "\nclass Clause:\n    commutative = True\n    idempotent = True\n\n    def compile(self, root: bool = True, *, separator=\" \") -> str:\n        raise NotImplementedError\n\n    def format(self) -> str:\n        return self.compile(separator=\"\\n    \")\n\n    def _collect(self, *, separator=\" \") -> List:\n        return [self.compile(root=False, separator=separator)]\n\n    def __str__(self) -> str:\n        return self.compile()\n\n    def __and__(self, other: Optional[\"Clause\"]) -> \"Clause\":\n        if other is None:\n            return self\n\n        return self._and(other)\n\n    def _and(self, other: \"Clause\") -> \"Clause\":\n        if issubclass(type(other), Find):\n            raise XTDBException(\"Cannot perform a where-find. User find-where instead.\")\n\n        return And([self, other])\n\n    def __or__(self, other: Optional[\"Clause\"]) -> \"Clause\":\n        if other is None:\n            return self\n\n        return self._or(other)\n\n    def _or(self, other: \"Clause\") -> \"Clause\":\n        raise NotImplementedError\n\n    def __ror__(self, other: Optional[\"Clause\"]) -> \"Clause\":\n        if other is None:\n            return self\n\n        raise NotImplementedError\n\n    def __rand__(self, other: Optional[\"Clause\"]) -> \"Clause\":\n        if other is None:\n            return self\n\n        raise NotImplementedError\n\n    def __invert__(self):\n        raise NotImplementedError", "\n\nclass And(Clause):\n    def __init__(self, clauses: List[Clause], query_section: str = \"where\"):\n        self.clauses = clauses\n        self.query_section = query_section\n\n    def compile(self, root: bool = True, *, separator=\" \") -> str:\n        compiled_clauses = self._collect(separator=separator)\n        expression = separator + separator.join(compiled_clauses)\n\n        if root:\n            return f\":{self.query_section} [{expression}]\"\n\n        return expression\n\n    def _collect(self, *, separator=\" \") -> List:\n        collected = []\n\n        for clause in self.clauses:\n            collected.extend(clause._collect(separator=separator))\n\n        if all(clause.idempotent for clause in self.clauses):\n            collected = list(set(collected))\n        if all(clause.commutative for clause in self.clauses):\n            collected = sorted(collected)\n\n        return collected\n\n    def _or(self, other: Clause) -> \"Clause\":\n        if isinstance(other, (Where, WherePredicate)):\n            raise XTDBException(\"Cannot | on a single where, use & instead\")\n\n        return Or([self, other])\n\n    def _and(self, other: Clause) -> Clause:\n        if self.query_section != \"find\" and issubclass(type(other), Find):\n            raise XTDBException(\"Cannot perform a where-find. User find-where instead.\")\n        if self.query_section == \"find\" and isinstance(other, And) and other.query_section != \"find\":\n            return FindWhere(self, other)\n        if self.query_section == \"find\" and isinstance(other, (Where, Or, Not, NotJoin, WherePredicate)):\n            return FindWhere(self, other)\n\n        return And(self.clauses + [other], self.query_section)\n\n    def __invert__(self):\n        return Not(self.clauses)", "\n\nclass Or(Clause):\n    def __init__(self, clauses: List[Clause]):\n        self.clauses = clauses\n\n    def compile(self, root: bool = True, *, separator=\" \") -> str:\n        collected = []\n\n        for clause in self.clauses:\n            if isinstance(clause, And):\n                collected.append(f\"(and{clause.compile(root=False, separator=separator)})\")\n            else:\n                collected.append(clause.compile(root=False, separator=separator))\n\n        if all(clause.idempotent for clause in self.clauses):\n            collected = list(set(collected))\n\n        if all(clause.commutative for clause in self.clauses):\n            collected = sorted(collected)\n\n        if root:\n            return f\":where [(or{separator}{separator.join(collected)})]\"\n\n        return f\"(or{separator}{separator.join(collected)})\"\n\n    def _or(self, other: Clause) -> Clause:\n        return Or(self.clauses + [other])\n\n    def __invert__(self):\n        raise XTDBException(\"Cannot use ~ on or clauses\")", "\n\nclass Not(Clause):\n    def __init__(self, clauses: List[Clause]):\n        self.clauses = clauses\n\n    def compile(self, root: bool = True, *, separator=\" \") -> str:\n        collected = []\n\n        for clause in self.clauses:\n            collected.append(clause.compile(root=False, separator=separator))\n\n        if all(clause.idempotent for clause in self.clauses):\n            collected = list(set(collected))\n\n        if all(clause.commutative for clause in self.clauses):\n            collected = sorted(collected)\n\n        if root:\n            return f\":where [(not{separator}{separator.join(collected)})]\"\n\n        return f\"(not{separator}{separator.join(collected)})\"\n\n    def _or(self, other: Clause) -> Clause:\n        return Or(self.clauses + [other])\n\n    def __invert__(self):\n        return And(self.clauses)", "\n\nclass NotJoin(Clause):\n    def __init__(self, variable: str, clauses: Optional[List] = None):\n        self.variable = variable\n        self.clauses = clauses or []\n\n    def compile(self, root: bool = True, *, separator=\" \") -> str:\n        collected = []\n\n        for clause in self.clauses:\n            collected.append(clause.compile(root=False, separator=separator))\n\n        if all(clause.idempotent for clause in self.clauses):\n            collected = list(set(collected))\n\n        if all(clause.commutative for clause in self.clauses):\n            collected = sorted(collected)\n\n        if root:\n            return f\":where [(not-join{separator}[{self.variable}] {separator.join(collected)})]\"\n\n        return f\"(not-join{separator}[{self.variable}] {separator.join(collected)})\"\n\n    def _and(self, other: Clause) -> Clause:\n        return NotJoin(self.variable, self.clauses + [other])\n\n    def __invert__(self):\n        raise XTDBException(\"Cannot use ~ on not-join\")", "\n\nclass OrJoin(Clause):\n    def __init__(self, variable: str, clauses: Optional[List] = None):\n        self.variable = variable\n        self.clauses = clauses or []\n\n    def compile(self, root: bool = True, *, separator=\" \") -> str:\n        collected = []\n\n        for clause in self.clauses:\n            collected.append(clause.compile(root=False, separator=separator))\n\n        if all(clause.idempotent for clause in self.clauses):\n            collected = list(set(collected))\n\n        if all(clause.commutative for clause in self.clauses):\n            collected = sorted(collected)\n\n        if root:\n            return f\":where [(or-join{separator}[{self.variable}] {separator.join(collected)})]\"\n\n        return f\"(or-join{separator}[{self.variable}] {separator.join(collected)})\"\n\n    def _and(self, other: Clause) -> Clause:\n        return OrJoin(self.variable, self.clauses + [other])\n\n    def __invert__(self):\n        raise XTDBException(\"Cannot use ~ on or-join\")", "\n\nclass Where(Clause):\n    def __init__(self, document: str, field: str, value: Any = \"\"):\n        self.document = document\n        self.field = field\n        self.value = value\n\n    def compile(self, root: bool = True, *, separator=\" \") -> str:\n        if root:\n            return f\":where [[ {self.document} :{self.field} {self.value} ]]\"\n\n        return f\"[ {self.document} :{self.field} {self.value} ]\"\n\n    def _or(self, other: Clause) -> Clause:\n        if isinstance(other, And):\n            raise XTDBException(\"Cannot | on a single where, use & instead\")\n\n        return Or([self, other])\n\n    def __invert__(self):\n        return Not([self])", "\n\nclass WherePredicate(Clause):\n    def __init__(self, operation: str, *args, bind: Optional[str] = None):\n        self.args = args\n        self.operation = operation\n        self.bind = bind\n\n    def compile(self, root: bool = True, *, separator=\" \") -> str:\n        bind = self.bind or \"\"\n\n        if root:\n            return f\":where [[ ({self.operation} {' '.join([str(arg) for arg in self.args])}) {bind}]]\"\n\n        return f\"[ ({self.operation} {' '.join(self.args)}) {bind}]\"\n\n    def _or(self, other: Clause) -> Clause:\n        if isinstance(other, And):\n            raise XTDBException(\"Cannot | on a single predicate, use & instead\")\n\n        return Or([self, other])\n\n    def __invert__(self):\n        return Not([self])", "\n\nclass Expression:\n    def __init__(self, statement: str):\n        self.statement = statement\n\n    def __str__(self):\n        return self.statement\n\n\nclass _BaseAggregate(Expression):\n    supported_aggregates = [\"sum\", \"min\", \"max\", \"count\", \"avg\", \"median\", \"variance\", \"stddev\", \"distinct\"]\n    supported_aggregates_with_arg = [\"rand\", \"sample\"]\n\n    def __init__(self, function: str, expression: str, *args):\n        if function not in self.supported_aggregates + self.supported_aggregates_with_arg:\n            raise XTDBException(\"Invalid aggregate function\")\n\n        if function in self.supported_aggregates:\n            super().__init__(f\"({function} {expression})\")\n\n        if function in self.supported_aggregates_with_arg:\n            if len(args) != 1:\n                raise XTDBException(\"Invalid arguments to aggregate, it needs one argument: N\")\n\n            super().__init__(f\"({function} {' '.join(args)} {expression})\")", "\n\nclass _BaseAggregate(Expression):\n    supported_aggregates = [\"sum\", \"min\", \"max\", \"count\", \"avg\", \"median\", \"variance\", \"stddev\", \"distinct\"]\n    supported_aggregates_with_arg = [\"rand\", \"sample\"]\n\n    def __init__(self, function: str, expression: str, *args):\n        if function not in self.supported_aggregates + self.supported_aggregates_with_arg:\n            raise XTDBException(\"Invalid aggregate function\")\n\n        if function in self.supported_aggregates:\n            super().__init__(f\"({function} {expression})\")\n\n        if function in self.supported_aggregates_with_arg:\n            if len(args) != 1:\n                raise XTDBException(\"Invalid arguments to aggregate, it needs one argument: N\")\n\n            super().__init__(f\"({function} {' '.join(args)} {expression})\")", "\n\nclass QueryKey(Clause):\n    def compile(self, root: bool = True, *, separator=\" \") -> str:\n        raise NotImplementedError\n\n    def _or(self, other: Clause) -> Clause:\n        raise XTDBException(\"Cannot use | on query keys\")\n\n    def _and(self, other: Clause) -> Clause:\n        return And([self, other])\n\n    def __invert__(self):\n        raise XTDBException(\"Cannot use ~ on query keys\")", "\n\nclass Find(QueryKey):\n    commutative = False\n    idempotent = False\n\n    def __init__(self, expression: Union[str, Expression]):\n        self.expression = expression\n\n    def compile(self, root: bool = True, *, separator=\" \") -> str:\n        if root:\n            return f\":find [{self.expression}]\"\n\n        return str(self.expression)\n\n    def _and(self, other: Clause) -> Clause:\n        if isinstance(other, And) and other.query_section != \"find\":\n            return FindWhere(self, other)\n        if isinstance(other, (Where, Or, Not, WherePredicate)):\n            return FindWhere(self, other)\n\n        return And([self, other], \"find\")", "\n\nclass In(QueryKey):\n    def __init__(self, in_args: Union[str, List[str], List[List[str]]], values: Union[str, List[str], List[List[str]]]):\n        if not in_args:\n            raise XTDBException(\"No in_arg supplied: cannot be empty\")\n        if not values:\n            raise XTDBException(\"No values supplied: cannot be empty\")\n\n        self.in_args = in_args\n        self.values = values\n\n    def compile(self, root: bool = True, *, separator=\" \") -> str:\n        if isinstance(self.in_args, str):\n            return f\" :in [{self.in_args}]\"\n\n        if isinstance(self.in_args[0], str):\n            expression = \" \".join([in_arg for in_arg in self.in_args if isinstance(in_arg, str)])\n            return f\" :in [[{expression}]]\"\n\n        nested_args = [\" \".join(in_arg) for in_arg in self.in_args if isinstance(in_arg, List)]\n        expression = \" \".join(nested_args)\n\n        return f\" :in [[[{expression}]]]\"\n\n    def compile_values(self) -> str:\n        if not isinstance(self.values, List):\n            return f' :in-args [\"{self.values}\"]'\n\n        if not isinstance(self.values[0], List):\n            expression = \" \".join([f'\"{value}\"' for value in self.values])\n            return f\" :in-args [[{expression}]]\"\n\n        nested_values = [\"[\" + \" \".join([f'\"{value}\"' for value in values]) + \"]\" for values in self.values]\n        expression = \" \".join(nested_values)\n        return f\" :in-args [[{expression}]]\"", "\n\nclass OrderBy(QueryKey):\n    def __init__(self, fields: List[Tuple[str, Literal[\"asc\", \"desc\"]]]):\n        if not all([field[1] in [\"asc\", \"desc\"] for field in fields]):\n            raise XTDBException(\"Only 'asc' and 'desc' allowed as ordering functions.\")\n\n        self.fields = fields\n\n    def compile(self, root: bool = True, *, separator=\" \") -> str:\n        expression = \" \".join([self.compile_field(field) for field in self.fields])\n\n        return f\" :order-by [{expression}]\"\n\n    def compile_field(self, field: Tuple[str, Literal[\"asc\", \"desc\"]]):\n        return f\"[{field[0]} :{field[1]}]\"", "\n\nclass Limit(QueryKey):\n    def __init__(self, limit: int):\n        self.limit = limit\n\n    def compile(self, root: bool = True, *, separator=\" \") -> str:\n        return f\" :limit {self.limit}\"\n\n\nclass Offset(QueryKey):\n    def __init__(self, offset: int):\n        self.offset = offset\n\n    def compile(self, root: bool = True, *, separator=\" \") -> str:\n        return f\" :offset {self.offset}\"", "\n\nclass Offset(QueryKey):\n    def __init__(self, offset: int):\n        self.offset = offset\n\n    def compile(self, root: bool = True, *, separator=\" \") -> str:\n        return f\" :offset {self.offset}\"\n\n\nclass Timeout(QueryKey):\n    def __init__(self, timeout: int):\n        self.timeout = timeout\n\n    def compile(self, root: bool = True, *, separator=\" \") -> str:\n        return f\" :timeout {self.timeout}\"", "\n\nclass Timeout(QueryKey):\n    def __init__(self, timeout: int):\n        self.timeout = timeout\n\n    def compile(self, root: bool = True, *, separator=\" \") -> str:\n        return f\" :timeout {self.timeout}\"\n\n\nclass FindWhere(QueryKey):\n    def __init__(\n        self,\n        find: Clause,\n        where: Clause,\n        in_args: Optional[In] = None,\n        order_by: Optional[OrderBy] = None,\n        limit: Optional[Limit] = None,\n        offset: Optional[Offset] = None,\n        timeout: Optional[Timeout] = None,\n    ):\n        self.find = find\n        self.where = where\n        self.in_args = in_args\n        self.order_by = order_by\n        self.limit = limit\n        self.offset = offset\n        self.timeout = timeout\n\n    def compile(self, root: bool = True, *, separator=\" \") -> str:\n        q = f\"{{:query {{{self.find.compile(separator=separator)} {self.where.compile(separator=separator)}\"\n\n        if self.in_args is not None:\n            q += self.in_args.compile(separator=separator)\n\n        if self.order_by is not None:\n            q += self.order_by.compile(separator=separator)\n\n        if self.limit is not None:\n            q += self.limit.compile(separator=separator)\n\n        if self.offset is not None:\n            q += self.offset.compile(separator=separator)\n\n        if self.timeout is not None:\n            q += self.timeout.compile(separator=separator)\n\n        if self.in_args is not None:\n            return q + f\"}}{self.in_args.compile_values()}}}\"\n\n        return q + \"}}\"\n\n    def _and(self, other: Clause) -> Clause:\n        if isinstance(other, In):\n            return FindWhere(self.find, self.where, other, self.order_by, self.limit, self.offset, self.timeout)\n        if isinstance(other, OrderBy):\n            return FindWhere(self.find, self.where, self.in_args, other, self.limit, self.offset, self.timeout)\n        if isinstance(other, Limit):\n            return FindWhere(self.find, self.where, self.in_args, self.order_by, other, self.offset, self.timeout)\n        if isinstance(other, Offset):\n            return FindWhere(self.find, self.where, self.in_args, self.order_by, self.limit, other, self.timeout)\n        if isinstance(other, Timeout):\n            return FindWhere(self.find, self.where, self.in_args, self.order_by, self.limit, self.offset, other)\n\n        raise XTDBException(\"And operator is not supported for find-where clauses\")", "\n\nclass FindWhere(QueryKey):\n    def __init__(\n        self,\n        find: Clause,\n        where: Clause,\n        in_args: Optional[In] = None,\n        order_by: Optional[OrderBy] = None,\n        limit: Optional[Limit] = None,\n        offset: Optional[Offset] = None,\n        timeout: Optional[Timeout] = None,\n    ):\n        self.find = find\n        self.where = where\n        self.in_args = in_args\n        self.order_by = order_by\n        self.limit = limit\n        self.offset = offset\n        self.timeout = timeout\n\n    def compile(self, root: bool = True, *, separator=\" \") -> str:\n        q = f\"{{:query {{{self.find.compile(separator=separator)} {self.where.compile(separator=separator)}\"\n\n        if self.in_args is not None:\n            q += self.in_args.compile(separator=separator)\n\n        if self.order_by is not None:\n            q += self.order_by.compile(separator=separator)\n\n        if self.limit is not None:\n            q += self.limit.compile(separator=separator)\n\n        if self.offset is not None:\n            q += self.offset.compile(separator=separator)\n\n        if self.timeout is not None:\n            q += self.timeout.compile(separator=separator)\n\n        if self.in_args is not None:\n            return q + f\"}}{self.in_args.compile_values()}}}\"\n\n        return q + \"}}\"\n\n    def _and(self, other: Clause) -> Clause:\n        if isinstance(other, In):\n            return FindWhere(self.find, self.where, other, self.order_by, self.limit, self.offset, self.timeout)\n        if isinstance(other, OrderBy):\n            return FindWhere(self.find, self.where, self.in_args, other, self.limit, self.offset, self.timeout)\n        if isinstance(other, Limit):\n            return FindWhere(self.find, self.where, self.in_args, self.order_by, other, self.offset, self.timeout)\n        if isinstance(other, Offset):\n            return FindWhere(self.find, self.where, self.in_args, self.order_by, self.limit, other, self.timeout)\n        if isinstance(other, Timeout):\n            return FindWhere(self.find, self.where, self.in_args, self.order_by, self.limit, self.offset, other)\n\n        raise XTDBException(\"And operator is not supported for find-where clauses\")", "\n\ndef _build_find_aggregation_class(name: str):\n    class Extended(Find):\n        def __init__(self, expression: str):\n            super().__init__(_BaseAggregate(name, expression))\n\n    return Extended\n\n\ndef _build_find_aggregation_class_with_argument(name: str):\n    class Extended(Find):\n        def __init__(self, expression: str, N: int):\n            super().__init__(_BaseAggregate(name, expression, str(N)))\n\n    return Extended", "\n\ndef _build_find_aggregation_class_with_argument(name: str):\n    class Extended(Find):\n        def __init__(self, expression: str, N: int):\n            super().__init__(_BaseAggregate(name, expression, str(N)))\n\n    return Extended\n\n", "\n\n# Dynamically create classes extending the Find clause but do aggregations\nSum = _build_find_aggregation_class(\"sum\")\nMin = _build_find_aggregation_class(\"min\")\nMax = _build_find_aggregation_class(\"max\")\nCount = _build_find_aggregation_class(\"count\")\nCountDistinct = _build_find_aggregation_class(\"count-distinct\")\nAvg = _build_find_aggregation_class(\"avg\")\nMedian = _build_find_aggregation_class(\"median\")", "Avg = _build_find_aggregation_class(\"avg\")\nMedian = _build_find_aggregation_class(\"median\")\nVariance = _build_find_aggregation_class(\"variance\")\nStddev = _build_find_aggregation_class(\"stddev\")\nDistinct = _build_find_aggregation_class(\"distinct\")\nRand = _build_find_aggregation_class_with_argument(\"rand\")\nSample = _build_find_aggregation_class_with_argument(\"sample\")\n"]}
{"filename": "examples/cities/queries_without_orm.py", "chunked_list": ["import os\nfrom pprint import pprint\n\nfrom xtdb.datalog import Find, Where\nfrom xtdb.session import XTDBClient\n\nclient = XTDBClient(os.environ[\"XTDB_URI\"])\n\n\nprint(\"\\nCountry of the user named bA\\n\")", "\nprint(\"\\nCountry of the user named bA\\n\")\nquery = Find(\"(pull Country [*])\") & (\n    Where(\"City\", \"City/country\", \"Country\")\n    & Where(\"Country\", \"type\", '\"Country\"')\n    & Where(\"User\", \"User/city\", \"City\")\n    & Where(\"User\", \"User/name\", '\"bA\"')\n)\nresult = client.query(query)\npprint(result)", "result = client.query(query)\npprint(result)\n"]}
{"filename": "examples/cities/models.py", "chunked_list": ["from dataclasses import dataclass\n\nfrom xtdb.orm import Base\n\n\n@dataclass\nclass Country(Base):\n    name: str\n\n", "\n\n@dataclass\nclass City(Base):\n    country: Country\n\n    population: int\n    name: str\n\n", "\n\n@dataclass\nclass User(Base):\n    city: City\n    country: Country\n\n    name: str\n", ""]}
{"filename": "examples/cities/seed.py", "chunked_list": ["import os\nimport random\nfrom pathlib import Path\n\nfrom models import City, Country, User\n\nfrom xtdb.session import XTDBSession\n\ncountries = [\n    \"Andorra\",", "countries = [\n    \"Andorra\",\n    \"Afghanistan\",\n    \"Antigua and Barbuda\",\n    \"Albania\",\n    \"Armenia\",\n    \"Angola\",\n    \"Argentina\",\n    \"Austria\",\n    \"Australia\",", "    \"Austria\",\n    \"Australia\",\n    \"Azerbaijan\",\n    \"Barbados\",\n    \"Bangladesh\",\n    \"Belgium\",\n    \"Burkina Faso\",\n    \"Bulgaria\",\n    \"Bahrain\",\n    \"Burundi\",", "    \"Bahrain\",\n    \"Burundi\",\n    \"Benin\",\n    \"Brunei Darussalam\",\n    \"Bolivia\",\n    \"Brazil\",\n    \"Bahamas\",\n    \"Bhutan\",\n    \"Botswana\",\n    \"Belarus\",", "    \"Botswana\",\n    \"Belarus\",\n    \"Belize\",\n    \"Canada\",\n    \"Democratic Republic of the Congo\",\n    \"Republic of the Congo\",\n    \"d'Ivoire\",\n    \"Chile\",\n    \"Cameroon\",\n    \"People's Republic of China\",", "    \"Cameroon\",\n    \"People's Republic of China\",\n    \"Colombia\",\n    \"Costa Rica\",\n    \"Cuba\",\n    \"Cape Verde\",\n    \"Cyprus\",\n    \"Czech Republic\",\n    \"Germany\",\n    \"Djibouti\",", "    \"Germany\",\n    \"Djibouti\",\n    \"Denmark\",\n    \"Dominica\",\n    \"Dominican Republic\",\n    \"Ecuador\",\n    \"Estonia\",\n    \"Egypt\",\n    \"Eritrea\",\n    \"Ethiopia\",", "    \"Eritrea\",\n    \"Ethiopia\",\n    \"Finland\",\n    \"Fiji\",\n    \"France\",\n    \"Gabon\",\n    \"Georgia\",\n    \"Ghana\",\n    \"The Gambia\",\n    \"Guinea\",", "    \"The Gambia\",\n    \"Guinea\",\n    \"Greece\",\n    \"Guatemala\",\n    \"Haiti\",\n    \"Guinea-Bissau\",\n    \"Guyana\",\n    \"Honduras\",\n    \"Hungary\",\n    \"Indonesia\",", "    \"Hungary\",\n    \"Indonesia\",\n    \"Ireland\",\n    \"Israel\",\n    \"India\",\n    \"Iraq\",\n    \"Iran\",\n    \"Iceland\",\n    \"Italy\",\n    \"Jamaica\",", "    \"Italy\",\n    \"Jamaica\",\n    \"Jordan\",\n    \"Japan\",\n    \"Kenya\",\n    \"Kyrgyzstan\",\n    \"Kiribati\",\n    \"North Korea\",\n    \"South Korea\",\n    \"Kuwait\",", "    \"South Korea\",\n    \"Kuwait\",\n    \"Lebanon\",\n    \"Liechtenstein\",\n    \"Liberia\",\n    \"Lesotho\",\n    \"Lithuania\",\n    \"Luxembourg\",\n    \"Latvia\",\n    \"Libya\",", "    \"Latvia\",\n    \"Libya\",\n    \"Madagascar\",\n    \"Marshall Islands\",\n    \"Macedonia\",\n    \"Mali\",\n    \"Myanmar\",\n    \"Mongolia\",\n    \"Mauritania\",\n    \"Malta\",", "    \"Mauritania\",\n    \"Malta\",\n    \"Mauritius\",\n    \"Maldives\",\n    \"Malawi\",\n    \"Mexico\",\n    \"Malaysia\",\n    \"Mozambique\",\n    \"Namibia\",\n    \"Niger\",", "    \"Namibia\",\n    \"Niger\",\n    \"Nigeria\",\n    \"Nicaragua\",\n    \"Netherlands\",\n    \"Norway\",\n    \"Nepal\",\n    \"Nauru\",\n    \"New Zealand\",\n    \"Oman\",", "    \"New Zealand\",\n    \"Oman\",\n    \"Panama\",\n    \"Peru\",\n    \"Papua New Guinea\",\n    \"Philippines\",\n    \"Pakistan\",\n    \"Poland\",\n    \"Portugal\",\n    \"Palau\",", "    \"Portugal\",\n    \"Palau\",\n    \"Paraguay\",\n    \"Qatar\",\n    \"Romania\",\n    \"Russia\",\n    \"Rwanda\",\n    \"Saudi Arabia\",\n    \"Solomon Islands\",\n    \"Seychelles\",", "    \"Solomon Islands\",\n    \"Seychelles\",\n    \"Sudan\",\n    \"Sweden\",\n    \"Singapore\",\n    \"Slovenia\",\n    \"Slovakia\",\n    \"Sierra Leone\",\n    \"San Marino\",\n    \"Senegal\",", "    \"San Marino\",\n    \"Senegal\",\n    \"Somalia\",\n    \"Suriname\",\n    \"Syria\",\n    \"Togo\",\n    \"Thailand\",\n    \"Tajikistan\",\n    \"Turkmenistan\",\n    \"Tunisia\",", "    \"Turkmenistan\",\n    \"Tunisia\",\n    \"Tonga\",\n    \"Turkey\",\n    \"Trinidad and Tobago\",\n    \"Tuvalu\",\n    \"Tanzania\",\n    \"Ukraine\",\n    \"Uganda\",\n    \"United States\",", "    \"Uganda\",\n    \"United States\",\n    \"Uruguay\",\n    \"Uzbekistan\",\n    \"Vatican City\",\n    \"Venezuela\",\n    \"Vietnam\",\n    \"Vanuatu\",\n    \"Yemen\",\n    \"Zambia\",", "    \"Yemen\",\n    \"Zambia\",\n    \"Zimbabwe\",\n    \"Algeria\",\n    \"Bosnia and Herzegovina\",\n    \"Cambodia\",\n    \"Central African Republic\",\n    \"Chad\",\n    \"Comoros\",\n    \"Croatia\",", "    \"Comoros\",\n    \"Croatia\",\n    \"East Timor\",\n    \"El Salvador\",\n    \"Equatorial Guinea\",\n    \"Grenada\",\n    \"Kazakhstan\",\n    \"Laos\",\n    \"Federated States of Micronesia\",\n    \"Moldova\",", "    \"Federated States of Micronesia\",\n    \"Moldova\",\n    \"Monaco\",\n    \"Montenegro\",\n    \"Morocco\",\n    \"Saint Kitts and Nevis\",\n    \"Saint Lucia\",\n    \"Saint Vincent and the Grenadines\",\n    \"Samoa\",\n    \"Serbia\",", "    \"Samoa\",\n    \"Serbia\",\n    \"South Africa\",\n    \"Spain\",\n    \"Sri Lanka\",\n    \"Swaziland\",\n    \"Switzerland\",\n    \"United Arab Emirates\",\n    \"United Kingdom\",\n]", "    \"United Kingdom\",\n]\n\n\ndef main():\n    cities = [\n        [city.split(\",\")[0], int(city.split(\",\")[1]), city.split(\",\")[2]]\n        for city in (Path() / \"cities.csv\").read_text().splitlines()[1:]\n    ]\n\n    country_map = {}\n    xtdb_session = XTDBSession(os.environ[\"XTDB_URI\"])\n\n    with xtdb_session:\n        for country in countries:\n            country_entity = Country(name=country)\n            xtdb_session.put(country_entity)\n            country_map[country] = country_entity\n\n    city_map = {}\n\n    with xtdb_session:\n        for name, population, country_name in cities:\n            city_entity = City(name=name, population=population, country=country_map[str(country_name)])\n            xtdb_session.put(city_entity)\n            city_map[name] = city_entity\n\n    alfabet = \"abcdefghijklmnopqrstuvwxyz\"\n    alfabet += alfabet.upper()\n\n    with xtdb_session:\n        for x in alfabet:\n            for y in alfabet:\n                city = list(city_map.values())[random.randint(0, len(city_map) - 1)]\n                xtdb_session.put(User(name=x + y, city=city, country=city.country))", "\n\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "examples/cities/__init__.py", "chunked_list": [""]}
{"filename": "examples/cities/queries.py", "chunked_list": ["import os\nfrom pprint import pprint\n\nfrom models import City, Country, User\n\nfrom xtdb.query import Query\nfrom xtdb.session import XTDBSession\n\nsession = XTDBSession(os.environ[\"XTDB_URI\"])\n", "session = XTDBSession(os.environ[\"XTDB_URI\"])\n\n\nprint(\"\\nCountry of the user named bA\\n\")\nresult = session.query(Query(Country).where(City, country=Country).where(User, city=City, name=\"bA\"))\nprint(Query(Country).where(City, country=Country).where(User, city=City, name=\"bA\"))\npprint(result)\n\nprint(\"\\nCity of the user named bA\\n\")\nresult = session.query(Query(City).where(City, country=Country).where(User, city=City, name=\"bA\"))", "print(\"\\nCity of the user named bA\\n\")\nresult = session.query(Query(City).where(City, country=Country).where(User, city=City, name=\"bA\"))\npprint(result)\n\nprint(\"\\n2 users in Ireland\\n\")\nresult = session.query(\n    Query(User).where(City, country=Country).where(User, city=City).where(Country, name=\"Ireland\").limit(2)\n)\npprint(result)\n", "pprint(result)\n\nprint(\"\\nAll cities in Ireland\\n\")\nresult = session.query(Query(City).where(City, country=Country).where(Country, name=\"Ireland\"))\npprint(result)\n"]}
{"filename": "docs/source/conf.py", "chunked_list": ["# Configuration file for the Sphinx documentation builder.\n#\n# For the full list of built-in configuration values, see the documentation:\n# https://www.sphinx-doc.org/en/master/usage/configuration.html\n\nimport subprocess\n\nbranch = subprocess.check_output([\"git\", \"rev-parse\", \"--abbrev-ref\", \"HEAD\"]).decode(\"utf-8\")\ncommit_date = subprocess.check_output([\"git\", \"log\", \"--format=#%h %cs\", \"-n 1\"]).decode(\"utf-8\")\n", "commit_date = subprocess.check_output([\"git\", \"log\", \"--format=#%h %cs\", \"-n 1\"]).decode(\"utf-8\")\n\n# -- Project information -----------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/configuration.html#project-information\n\nproject = \"XTDB-Python\"\ncopyright = \"Donny Peeters (MIT License)\"\nauthor = \"Donny Peeters\"\nversion = branch\nrelease = version", "version = branch\nrelease = version\n\n# -- General configuration ---------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/configuration.html#general-configuration\n\nextensions = [\n    \"sphinx.ext.napoleon\",\n    \"sphinx.ext.viewcode\",\n    \"sphinx.ext.githubpages\",", "    \"sphinx.ext.viewcode\",\n    \"sphinx.ext.githubpages\",\n    \"sphinx.ext.autosectionlabel\",\n    \"sphinx.ext.autodoc\",\n    \"sphinx.ext.autosummary\",\n    \"sphinx_rtd_theme\",\n    \"myst_parser\",\n]\n\nmyst_enable_extensions = [\"tasklist\"]", "\nmyst_enable_extensions = [\"tasklist\"]\n\ntemplates_path = [\"_templates\"]\n\n# -- Options for HTML output -------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-html-output\n\nhtml_theme = \"sphinx_rtd_theme\"\nhtml_logo = \"_static/logo.png\"", "html_theme = \"sphinx_rtd_theme\"\nhtml_logo = \"_static/logo.png\"\nhtml_favicon = \"_static/favicon.svg\"\nhtml_context = {\n    \"display_github\": True,\n    \"github_user\": \"DonnyPe\",\n    \"github_repo\": \"xtdb-py\",\n    \"github_version\": \"main\",\n    \"conf_py_path\": \"/docs/source/\",\n}", "    \"conf_py_path\": \"/docs/source/\",\n}\n\nhtml_static_path = [\"_static\"]\n"]}
