{"filename": "setup.py", "chunked_list": ["from setuptools import setup, find_packages\nimport os\n\n# Read the contents of your README file\nthis_directory = os.path.dirname(os.path.realpath(__file__))\nreadme_path = os.path.join(this_directory, \"docs\", \"README.md\")\n\n# Read the contents of the README file\nwith open(readme_path, encoding=\"utf-8\") as f:\n    long_description = f.read()", "with open(readme_path, encoding=\"utf-8\") as f:\n    long_description = f.read()\n\n# Get requirements from requirements.txt to a list\nwith open(os.path.join(this_directory, \"requirements.txt\"), encoding=\"utf-8\") as f:\n    install_requires = f.read().splitlines()\nrequirements = []\nfor reqs in install_requires:\n    if \"--\" not in reqs and \":\" not in reqs and \"#\" not in reqs:\n        requirements.append(reqs)", "# Get version from version file in agixt/version\nwith open(os.path.join(this_directory, \"agixt/version\"), encoding=\"utf-8\") as f:\n    version = f.read().strip()\n\nsetup(\n    name=\"agixt\",\n    version=version,\n    description=\"An Artificial Intelligence Automation Platform. AI Instruction management from various providers, has an adaptive memory, and a versatile plugin system with many commands including web browsing. Supports many AI providers and models and growing support every day.\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",  # This should match the format of your README", "    long_description=long_description,\n    long_description_content_type=\"text/markdown\",  # This should match the format of your README\n    author=\"Josh XT\",\n    author_email=\"josh@devxt.com\",\n    packages=find_packages(),\n    python_requires=\">=3.10\",\n    install_requires=requirements,\n)\n", ""]}
{"filename": "agixt/Hub.py", "chunked_list": ["import io\nimport os\nimport time\nimport stat\nimport shutil\nimport requests\nimport zipfile\nimport hashlib\nfrom dotenv import load_dotenv\n", "from dotenv import load_dotenv\n\nload_dotenv()\n\ndb_connected = True if os.getenv(\"DB_CONNECTED\", \"false\").lower() == \"true\" else False\n\nif db_connected:\n    from db.imports import (\n        import_extensions,\n        import_prompts,\n        import_providers,\n        import_agents,\n        import_chains,\n        import_conversations,\n    )\nelse:\n    import_extensions = lambda: None\n    import_prompts = lambda: None\n    import_providers = lambda: None\n    import_agents = lambda: None\n    import_chains = lambda: None\n    import_conversations = lambda: None", "\n\ndef import_agixt_hub():\n    github_user = os.getenv(\"GITHUB_USER\")\n    github_token = os.getenv(\"GITHUB_TOKEN\")\n    github_repo = os.getenv(\"AGIXT_HUB\", \"AGiXT/light-hub\")\n    repo_name = github_repo.split(\"/\")[1]\n    repo_url = f\"https://github.com/{github_repo}/archive/refs/heads/main.zip\"\n    zip_file_name = f\"{repo_name}_main.zip\"\n\n    try:\n        response = requests.get(repo_url, auth=(github_user, github_token))\n        response.raise_for_status()\n\n        new_zip_hash = hashlib.sha256(response.content).hexdigest()\n        if os.path.exists(zip_file_name):\n            with open(zip_file_name, \"rb\") as f:\n                old_zip_hash = hashlib.sha256(f.read()).hexdigest()\n            if old_zip_hash == new_zip_hash:\n                print(\n                    f\"No changes detected in the AGiXT Hub at {github_repo}, moving on...\"\n                )\n                return\n\n        with open(zip_file_name, \"wb\") as f:\n            f.write(response.content)\n\n        zip_ref = zipfile.ZipFile(io.BytesIO(response.content))\n        zip_ref.extractall(\".\")\n        zip_ref.close()\n\n        for root, dirs, files in os.walk(f\"{repo_name}-main\"):\n            for dir_name in dirs:\n                dir_path = os.path.join(root, dir_name)\n                os.chmod(dir_path, stat.S_IRWXU | stat.S_IRWXG | stat.S_IRWXO)\n            for file_name in files:\n                file_path = os.path.join(root, file_name)\n                os.chmod(\n                    file_path, stat.S_IRUSR | stat.S_IWUSR | stat.S_IRGRP | stat.S_IROTH\n                )\n\n        print(f\"Updating AGiXT Hub from {github_repo}\")\n\n        for file in os.listdir(f\"{repo_name}-main\"):\n            src_file = os.path.join(f\"{repo_name}-main\", file)\n            dest_file = os.path.join(\".\", file)\n\n            if os.path.isdir(src_file):\n                if not os.path.exists(dest_file):\n                    os.makedirs(dest_file, exist_ok=True)\n                for item in os.listdir(src_file):\n                    src_item = os.path.join(src_file, item)\n                    dest_item = os.path.join(dest_file, item)\n                    if os.path.isdir(src_item):\n                        if not os.path.exists(dest_item):\n                            os.makedirs(dest_item, exist_ok=True)\n                        for dirpath, dirnames, filenames in os.walk(src_item):\n                            destination = dirpath.replace(src_item, dest_item, 1)\n                            if not os.path.exists(destination):\n                                os.makedirs(destination)\n                            for filename in filenames:\n                                if filename != \"config.json\" or not os.path.exists(\n                                    os.path.join(destination, filename)\n                                ):\n                                    shutil.copy2(\n                                        os.path.join(dirpath, filename), destination\n                                    )\n                    else:\n                        if not (\n                            dest_item.endswith(\"config.json\")\n                            and os.path.exists(dest_item)\n                        ):\n                            shutil.copy2(src_item, dest_item)\n            else:\n                if not (\n                    dest_file.endswith(\"config.json\") and os.path.exists(dest_file)\n                ):\n                    shutil.move(src_file, dest_file)\n\n        shutil.rmtree(f\"{repo_name}-main\")\n        print(f\"Updated AGiXT Hub from {github_repo}\")\n    except Exception as e:\n        print(f\"AGiXT Hub Import Error: {e}\")\n    if db_connected:\n        print(f\"DB Connected: {db_connected}\")\n        time.sleep(5)\n        import_extensions()\n        import_prompts()\n        import_providers()\n        import_agents()\n        import_chains()\n        import_conversations()", "\n\nif __name__ == \"__main__\":\n    import_agixt_hub()\n"]}
{"filename": "agixt/Websearch.py", "chunked_list": ["import os\nimport re\nimport json\nimport random\nimport requests\nimport logging\nimport asyncio\nfrom urllib.parse import urlparse\nfrom playwright.async_api import async_playwright\nfrom Embedding import get_tokens", "from playwright.async_api import async_playwright\nfrom Embedding import get_tokens\nfrom Memories import Memories\nfrom bs4 import BeautifulSoup\nfrom agixtsdk import AGiXTSDK\nfrom typing import List\nfrom dotenv import load_dotenv\n\nload_dotenv()\nAGIXT_API_KEY = os.getenv(\"AGIXT_API_KEY\")", "load_dotenv()\nAGIXT_API_KEY = os.getenv(\"AGIXT_API_KEY\")\ndb_connected = True if os.getenv(\"DB_CONNECTED\", \"false\").lower() == \"true\" else False\nif db_connected:\n    from db.Agent import Agent\nelse:\n    from fb.Agent import Agent\n\nApiClient = AGiXTSDK(\n    base_uri=\"http://localhost:7437\", api_key=os.getenv(\"AGIXT_API_KEY\")", "ApiClient = AGiXTSDK(\n    base_uri=\"http://localhost:7437\", api_key=os.getenv(\"AGIXT_API_KEY\")\n)\n\n\nclass Websearch:\n    def __init__(\n        self,\n        agent: Agent,\n        memories: Memories,\n        **kwargs,\n    ):\n        self.agent = agent\n        self.memories = memories\n        self.agent_name = self.agent.agent_name\n        try:\n            self.max_tokens = self.agent.PROVIDER_SETTINGS[\"MAX_TOKENS\"]\n        except:\n            self.max_tokens = 2048\n        self.searx_instance_url = (\n            self.agent.PROVIDER_SETTINGS[\"SEARXNG_INSTANCE_URL\"]\n            if \"SEARXNG_INSTANCE_URL\" in self.agent.PROVIDER_SETTINGS\n            else \"\"\n        )\n        self.requirements = [\"agixtsdk\"]\n        self.failures = []\n        self.browsed_links = []\n        self.tasks = []\n\n    async def get_web_content(self, url):\n        try:\n            async with async_playwright() as p:\n                browser = await p.chromium.launch()\n                context = await browser.new_context()\n                page = await context.new_page()\n                await page.goto(url)\n                content = await page.content()\n\n                # Scrape links and their titles\n                links = await page.query_selector_all(\"a\")\n                link_list = []\n                for link in links:\n                    title = await page.evaluate(\"(link) => link.textContent\", link)\n                    title = title.replace(\"\\n\", \"\")\n                    title = title.replace(\"\\t\", \"\")\n                    title = title.replace(\"  \", \"\")\n                    href = await page.evaluate(\"(link) => link.href\", link)\n                    link_list.append((title, href))\n\n                await browser.close()\n                soup = BeautifulSoup(content, \"html.parser\")\n                text_content = soup.get_text()\n                text_content = \" \".join(text_content.split())\n                return text_content, link_list\n        except:\n            return None, None\n\n    async def resursive_browsing(self, user_input, links):\n        chunk_size = int(int(self.max_tokens) / 3)\n        try:\n            words = links.split()\n            links = [\n                word for word in words if urlparse(word).scheme in [\"http\", \"https\"]\n            ]\n        except:\n            links = links\n        if links is not None:\n            for link in links:\n                if \"href\" in link:\n                    try:\n                        url = link[\"href\"]\n                    except:\n                        url = link\n                else:\n                    url = link\n                url = re.sub(r\"^.*?(http)\", r\"http\", url)\n                if url in self.browsed_links:\n                    continue\n                # Check if url is an actual url\n                if url.startswith(\"http\"):\n                    logging.info(f\"Scraping: {url}\")\n                    if url not in self.browsed_links:\n                        self.browsed_links.append(url)\n                        (\n                            collected_data,\n                            link_list,\n                        ) = await self.get_web_content(url=url)\n                        # Split the collected data into agent max tokens / 3 character chunks\n                        if collected_data is not None:\n                            if len(collected_data) > 0:\n                                tokens = get_tokens(collected_data)\n                                chunks = [\n                                    collected_data[i : i + chunk_size]\n                                    for i in range(\n                                        0,\n                                        int(tokens),\n                                        chunk_size,\n                                    )\n                                ]\n                                for chunk in chunks:\n                                    summarized_content = ApiClient.prompt_agent(\n                                        agent_name=self.agent_name,\n                                        prompt_name=\"Summarize Web Content\",\n                                        prompt_args={\n                                            \"link\": url,\n                                            \"chunk\": chunk,\n                                            \"user_input\": user_input,\n                                            \"browse_links\": False,\n                                            \"disable_memory\": True,\n                                        },\n                                    )\n                                    if not summarized_content.startswith(\"None\"):\n                                        await self.memories.store_result(\n                                            input=url,\n                                            result=summarized_content,\n                                            external_source_name=url,\n                                        )\n        if links is not None:\n            for link in links:\n                if \"href\" in link:\n                    try:\n                        url = link[\"href\"]\n                    except:\n                        url = link\n                else:\n                    url = link\n                url = re.sub(r\"^.*?(http)\", r\"http\", url)\n                if url in self.browsed_links:\n                    continue\n                # Check if url is an actual url\n                if url.startswith(\"http\"):\n                    logging.info(f\"Scraping: {url}\")\n                    if url not in self.browsed_links:\n                        self.browsed_links.append(url)\n                        (\n                            collected_data,\n                            link_list,\n                        ) = await self.get_web_content(url=url)\n                        if link_list is not None:\n                            if len(link_list) > 0:\n                                if len(link_list) > 5:\n                                    link_list = link_list[:3]\n                                try:\n                                    pick_a_link = ApiClient.prompt_agent(\n                                        agent_name=self.agent_name,\n                                        prompt_name=\"Pick-a-Link\",\n                                        prompt_args={\n                                            \"url\": url,\n                                            \"links\": link_list,\n                                            \"visited_links\": self.browsed_links,\n                                            \"disable_memory\": True,\n                                            \"browse_links\": False,\n                                            \"user_input\": user_input,\n                                            \"context_results\": 0,\n                                        },\n                                    )\n                                    if not pick_a_link.startswith(\"None\"):\n                                        logging.info(\n                                            f\"AI has decided to click: {pick_a_link}\"\n                                        )\n                                        await self.resursive_browsing(\n                                            user_input=user_input, links=pick_a_link\n                                        )\n                                except:\n                                    logging.info(f\"Issues reading {url}. Moving on...\")\n\n    async def search(self, query: str) -> List[str]:\n        if self.searx_instance_url == \"\":\n            try:  # SearXNG - List of these at https://searx.space/\n                response = requests.get(\"https://searx.space/data/instances.json\")\n                data = json.loads(response.text)\n                if self.failures != []:\n                    for failure in self.failures:\n                        if failure in data[\"instances\"]:\n                            del data[\"instances\"][failure]\n                servers = list(data[\"instances\"].keys())\n                random_index = random.randint(0, len(servers) - 1)\n                self.searx_instance_url = servers[random_index]\n            except:  # Select default remote server that typically works if unable to get list.\n                self.searx_instance_url = \"https://search.us.projectsegfau.lt\"\n        server = self.searx_instance_url.rstrip(\"/\")\n        endpoint = f\"{server}/search\"\n        try:\n            logging.info(f\"Trying to connect to SearXNG Search at {endpoint}...\")\n            response = requests.get(\n                endpoint,\n                params={\n                    \"q\": query,\n                    \"language\": \"en\",\n                    \"safesearch\": 1,\n                    \"format\": \"json\",\n                },\n            )\n            results = response.json()\n            summaries = [\n                result[\"title\"] + \" - \" + result[\"url\"] for result in results[\"results\"]\n            ]\n            if len(summaries) < 1:\n                self.failures.append(self.searx_instance_url)\n                self.searx_instance_url = \"\"\n                return await self.search(query=query)\n            return summaries\n        except:\n            self.failures.append(self.searx_instance_url)\n            self.searx_instance_url = \"\"\n            # The SearXNG server is down or refusing connection, so we will use the default one.\n            return await self.search(query=query)\n\n    async def websearch_agent(\n        self,\n        user_input: str = \"What are the latest breakthroughs in AI?\",\n        depth: int = 3,\n        timeout: int = 0,\n    ):\n        results = ApiClient.prompt_agent(\n            agent_name=self.agent_name,\n            prompt_name=\"WebSearch\",\n            prompt_args={\n                \"user_input\": user_input,\n                \"disable_memory\": True,\n            },\n        )\n        results = results.split(\"\\n\")\n        if len(results) > 0:\n            for result in results:\n                links = []\n                search_string = result.lstrip(\"0123456789. \")\n                logging.info(f\"Searching for: {search_string}\")\n                links = await self.search(query=search_string)\n                logging.info(f\"Found {len(links)} results for {search_string}\")\n                if len(links) > depth:\n                    links = links[:depth]\n                if links is not None and len(links) > 0:\n                    task = asyncio.create_task(\n                        self.resursive_browsing(user_input=user_input, links=links)\n                    )\n                    self.tasks.append(task)\n\n            if int(timeout) == 0:\n                await asyncio.gather(*self.tasks)\n            else:\n                logging.info(f\"Web searching for {timeout} seconds... Please wait...\")\n                await asyncio.sleep(int(timeout))\n                logging.info(\"Websearch tasks completed.\")\n        else:\n            logging.info(\"No results found.\")", ""]}
{"filename": "agixt/app.py", "chunked_list": ["import uvicorn\nimport os\nimport logging\nimport base64\nimport string\nimport random\nimport time\nfrom fastapi import FastAPI, HTTPException, Depends, Request, Header\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom pydantic import BaseModel", "from fastapi.middleware.cors import CORSMiddleware\nfrom pydantic import BaseModel\nfrom Interactions import Interactions\nfrom Embedding import Embedding\nfrom dotenv import load_dotenv\n\nload_dotenv()\nAGIXT_API_KEY = os.getenv(\"AGIXT_API_KEY\")\ndb_connected = True if os.getenv(\"DB_CONNECTED\", \"false\").lower() == \"true\" else False\nif db_connected:\n    from db.Agent import Agent, add_agent, delete_agent, rename_agent, get_agents\n    from db.Chain import Chain\n    from db.Prompts import Prompts\n    from db.History import (\n        get_conversation,\n        delete_history,\n        delete_message,\n        get_conversations,\n        new_conversation,\n    )\nelse:\n    from fb.Agent import Agent, add_agent, delete_agent, rename_agent, get_agents\n    from fb.Chain import Chain\n    from fb.Prompts import Prompts\n    from fb.History import (\n        get_conversation,\n        delete_history,\n        delete_message,\n        get_conversations,\n        new_conversation,\n    )", "db_connected = True if os.getenv(\"DB_CONNECTED\", \"false\").lower() == \"true\" else False\nif db_connected:\n    from db.Agent import Agent, add_agent, delete_agent, rename_agent, get_agents\n    from db.Chain import Chain\n    from db.Prompts import Prompts\n    from db.History import (\n        get_conversation,\n        delete_history,\n        delete_message,\n        get_conversations,\n        new_conversation,\n    )\nelse:\n    from fb.Agent import Agent, add_agent, delete_agent, rename_agent, get_agents\n    from fb.Chain import Chain\n    from fb.Prompts import Prompts\n    from fb.History import (\n        get_conversation,\n        delete_history,\n        delete_message,\n        get_conversations,\n        new_conversation,\n    )", "\n\nfrom typing import Optional, Dict, List, Any\nfrom Providers import get_provider_options, get_providers\nfrom Embedding import get_embedding_providers, get_tokens\nfrom Extensions import Extensions\n\n\nos.environ[\"TOKENIZERS_PARALLELISM\"] = \"false\"\n", "os.environ[\"TOKENIZERS_PARALLELISM\"] = \"false\"\n\nthis_directory = os.path.abspath(os.path.dirname(__file__))\nwith open(os.path.join(this_directory, \"version\"), encoding=\"utf-8\") as f:\n    version = f.read().strip()\n\nlogging.basicConfig(\n    level=os.environ.get(\"LOGLEVEL\", \"INFO\"),\n    format=\"%(asctime)s | %(levelname)s | %(message)s\",\n)", "    format=\"%(asctime)s | %(levelname)s | %(message)s\",\n)\n\napp = FastAPI(\n    title=\"AGiXT\",\n    description=\"AGiXT is an Artificial Intelligence Automation platform for creating and managing AI agents. Visit the GitHub repo for more information or to report issues. https://github.com/Josh-XT/AGiXT/\",\n    version=version,\n    docs_url=\"/\",\n)\n", ")\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n", ")\n\n\nasync def get_api_key(authorization: str = Header(None)):\n    if AGIXT_API_KEY:\n        if authorization is None:\n            raise HTTPException(\n                status_code=400, detail=\"Authorization header is missing\"\n            )\n        scheme, _, api_key = authorization.partition(\" \")\n        if scheme.lower() != \"bearer\":\n            raise HTTPException(\n                status_code=400, detail=\"Authorization scheme is not Bearer\"\n            )\n        return api_key\n    else:\n        return None", "\n\ndef verify_api_key(api_key: str = Depends(get_api_key)):\n    if AGIXT_API_KEY and api_key != AGIXT_API_KEY:\n        raise HTTPException(status_code=403, detail=\"Invalid API Key\")\n    return api_key\n\n\nclass AgentName(BaseModel):\n    agent_name: str", "class AgentName(BaseModel):\n    agent_name: str\n\n\nclass AgentNewName(BaseModel):\n    new_name: str\n\n\nclass AgentPrompt(BaseModel):\n    prompt_name: str\n    prompt_args: dict", "class AgentPrompt(BaseModel):\n    prompt_name: str\n    prompt_args: dict\n\n\nclass Objective(BaseModel):\n    objective: str\n\n\nclass Prompt(BaseModel):\n    prompt: str", "\nclass Prompt(BaseModel):\n    prompt: str\n\n\nclass PromptName(BaseModel):\n    prompt_name: str\n\n\nclass PromptList(BaseModel):\n    prompts: List[str]", "\nclass PromptList(BaseModel):\n    prompts: List[str]\n\n\nclass Completions(BaseModel):\n    # Everything in this class except prompt, n, and model (agent_name) are unused currently.\n    prompt: str\n    max_tokens: int = 100\n    temperature: float = 0.9\n    top_p: float = 1.0\n    n: int = 1\n    stream: bool = False\n    logprobs: int = None\n    stop: List[str] = None\n    presence_penalty: float = 0.0\n    frequency_penalty: float = 0.0\n    best_of: int = 1\n    echo: bool = False\n    user: str = None\n    model: str = None  # Model is actually the agent_name\n    stop_sequence: List[str] = None\n    metadata: Dict[str, str] = None", "\n\nclass ChainNewName(BaseModel):\n    new_name: str\n\n\nclass ChainName(BaseModel):\n    chain_name: str\n\n\nclass ChainData(BaseModel):\n    chain_name: str\n    steps: Dict[str, Any]", "\n\nclass ChainData(BaseModel):\n    chain_name: str\n    steps: Dict[str, Any]\n\n\nclass RunChain(BaseModel):\n    prompt: str\n    agent_override: Optional[str] = \"\"\n    all_responses: Optional[bool] = False\n    from_step: Optional[int] = 1", "\n\nclass RunChainStep(BaseModel):\n    prompt: str\n    agent_override: Optional[str] = \"\"\n\n\nclass StepInfo(BaseModel):\n    step_number: int\n    agent_name: str\n    prompt_type: str\n    prompt: dict", "\n\nclass RunChainResponse(BaseModel):\n    response: str\n    agent_name: str\n    prompt: dict\n    prompt_type: str\n\n\nclass ChainStep(BaseModel):\n    step_number: int\n    agent_name: str\n    prompt_type: str\n    prompt: dict", "\nclass ChainStep(BaseModel):\n    step_number: int\n    agent_name: str\n    prompt_type: str\n    prompt: dict\n\n\nclass ChainStepNewInfo(BaseModel):\n    old_step_number: int\n    new_step_number: int", "class ChainStepNewInfo(BaseModel):\n    old_step_number: int\n    new_step_number: int\n\n\nclass ResponseMessage(BaseModel):\n    message: str\n\n\nclass UrlInput(BaseModel):\n    url: str", "\nclass UrlInput(BaseModel):\n    url: str\n\n\nclass EmbeddingModel(BaseModel):\n    input: str\n    model: str\n\n\nclass FileInput(BaseModel):\n    file_name: str\n    file_content: str", "\n\nclass FileInput(BaseModel):\n    file_name: str\n    file_content: str\n\n\nclass TaskOutput(BaseModel):\n    output: str\n    message: Optional[str] = None", "\n\nclass ToggleCommandPayload(BaseModel):\n    command_name: str\n    enable: bool\n\n\nclass CustomPromptModel(BaseModel):\n    prompt_name: str\n    prompt: str", "\n\nclass AgentSettings(BaseModel):\n    agent_name: str\n    settings: Dict[str, Any]\n\n\nclass AgentConfig(BaseModel):\n    agent_name: str\n    settings: Dict[str, Any]\n    commands: Dict[str, Any]", "\n\nclass AgentCommands(BaseModel):\n    agent_name: str\n    commands: Dict[str, Any]\n\n\nclass HistoryModel(BaseModel):\n    agent_name: str\n    conversation_name: str\n    limit: int = 100\n    page: int = 1", "\n\nclass ConversationHistoryModel(BaseModel):\n    agent_name: str\n    conversation_name: str\n\n\nclass ConversationHistoryMessageModel(BaseModel):\n    agent_name: str\n    conversation_name: str\n    message: str", "\n\n@app.get(\"/api/provider\", tags=[\"Provider\"], dependencies=[Depends(verify_api_key)])\nasync def getproviders():\n    providers = get_providers()\n    return {\"providers\": providers}\n\n\n@app.get(\n    \"/api/provider/{provider_name}\",", "@app.get(\n    \"/api/provider/{provider_name}\",\n    tags=[\"Provider\"],\n    dependencies=[Depends(verify_api_key)],\n)\nasync def get_provider_settings(provider_name: str):\n    settings = get_provider_options(provider_name=provider_name)\n    return {\"settings\": settings}\n\n", "\n\n@app.get(\n    \"/api/embedding_providers\",\n    tags=[\"Provider\"],\n    dependencies=[Depends(verify_api_key)],\n)\nasync def get_embed_providers():\n    providers = get_embedding_providers()\n    return {\"providers\": providers}", "    providers = get_embedding_providers()\n    return {\"providers\": providers}\n\n\n@app.post(\"/api/agent\", tags=[\"Agent\"], dependencies=[Depends(verify_api_key)])\nasync def addagent(agent: AgentSettings) -> Dict[str, str]:\n    return add_agent(agent_name=agent.agent_name, provider_settings=agent.settings)\n\n\n@app.post(\"/api/agent/import\", tags=[\"Agent\"], dependencies=[Depends(verify_api_key)])", "\n@app.post(\"/api/agent/import\", tags=[\"Agent\"], dependencies=[Depends(verify_api_key)])\nasync def import_agent(agent: AgentConfig) -> Dict[str, str]:\n    return add_agent(\n        agent_name=agent.agent_name,\n        provider_settings=agent.settings,\n        commands=agent.commands,\n    )\n\n", "\n\n@app.patch(\n    \"/api/agent/{agent_name}\", tags=[\"Agent\"], dependencies=[Depends(verify_api_key)]\n)\nasync def renameagent(agent_name: str, new_name: AgentNewName) -> ResponseMessage:\n    rename_agent(agent_name=agent_name, new_name=new_name.new_name)\n    return ResponseMessage(message=\"Agent renamed.\")\n\n", "\n\n@app.put(\n    \"/api/agent/{agent_name}\", tags=[\"Agent\"], dependencies=[Depends(verify_api_key)]\n)\nasync def update_agent_settings(\n    agent_name: str, settings: AgentSettings\n) -> ResponseMessage:\n    update_config = Agent(agent_name=agent_name).update_agent_config(\n        new_config=settings.settings, config_key=\"settings\"", "    update_config = Agent(agent_name=agent_name).update_agent_config(\n        new_config=settings.settings, config_key=\"settings\"\n    )\n    return ResponseMessage(message=update_config)\n\n\n@app.post(\n    \"/api/agent/{agent_name}/learn/file\",\n    tags=[\"Agent\"],\n    dependencies=[Depends(verify_api_key)],", "    tags=[\"Agent\"],\n    dependencies=[Depends(verify_api_key)],\n)\nasync def learn_file(agent_name: str, file: FileInput) -> ResponseMessage:\n    # Strip any path information from the file name\n    file.file_name = os.path.basename(file.file_name)\n    base_path = os.path.join(os.getcwd(), \"WORKSPACE\")\n    file_path = os.path.normpath(os.path.join(base_path, file.file_name))\n    if not file_path.startswith(base_path):\n        raise Exception(\"Path given not allowed\")", "    if not file_path.startswith(base_path):\n        raise Exception(\"Path given not allowed\")\n    file_content = base64.b64decode(file.file_content)\n    with open(file_path, \"wb\") as f:\n        f.write(file_content)\n    try:\n        memories = Agent(agent_name=agent_name).get_memories()\n        await memories.read_file(file_path=file_path)\n        try:\n            os.remove(file_path)\n        except Exception:\n            pass\n        return ResponseMessage(message=\"Agent learned the content from the file.\")\n    except Exception as e:\n        try:\n            os.remove(file_path)\n        except Exception:\n            pass\n        raise HTTPException(status_code=500, detail=str(e))", "\n\n@app.post(\n    \"/api/agent/{agent_name}/learn/url\",\n    tags=[\"Agent\"],\n    dependencies=[Depends(verify_api_key)],\n)\nasync def learn_url(agent_name: str, url: UrlInput) -> ResponseMessage:\n    try:\n        memories = Agent(agent_name=agent_name).get_memories()\n        await memories.read_website(url=url.url)\n        return ResponseMessage(message=\"Agent learned the content from the url.\")\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))", "    try:\n        memories = Agent(agent_name=agent_name).get_memories()\n        await memories.read_website(url=url.url)\n        return ResponseMessage(message=\"Agent learned the content from the url.\")\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n\n@app.put(\n    \"/api/agent/{agent_name}/commands\",", "@app.put(\n    \"/api/agent/{agent_name}/commands\",\n    tags=[\"Agent\"],\n    dependencies=[Depends(verify_api_key)],\n)\nasync def update_agent_commands(\n    agent_name: str, commands: AgentCommands\n) -> ResponseMessage:\n    update_config = Agent(agent_name=agent_name).update_agent_config(\n        new_config=commands.commands, config_key=\"commands\"", "    update_config = Agent(agent_name=agent_name).update_agent_config(\n        new_config=commands.commands, config_key=\"commands\"\n    )\n    return ResponseMessage(message=update_config)\n\n\n@app.delete(\n    \"/api/agent/{agent_name}\", tags=[\"Agent\"], dependencies=[Depends(verify_api_key)]\n)\nasync def deleteagent(agent_name: str) -> ResponseMessage:", ")\nasync def deleteagent(agent_name: str) -> ResponseMessage:\n    delete_agent(agent_name=agent_name)\n    return ResponseMessage(message=f\"Agent {agent_name} deleted.\")\n\n\n@app.get(\"/api/agent\", tags=[\"Agent\"])\nasync def getagents():\n    agents = get_agents()\n    return {\"agents\": agents}", "    agents = get_agents()\n    return {\"agents\": agents}\n\n\n@app.get(\n    \"/api/agent/{agent_name}\", tags=[\"Agent\"], dependencies=[Depends(verify_api_key)]\n)\nasync def get_agentconfig(agent_name: str):\n    agent_config = Agent(agent_name=agent_name).get_agent_config()\n    return {\"agent\": agent_config}", "    agent_config = Agent(agent_name=agent_name).get_agent_config()\n    return {\"agent\": agent_config}\n\n\n@app.get(\n    \"/api/{agent_name}/conversations\",\n    tags=[\"Agent\"],\n    dependencies=[Depends(verify_api_key)],\n)\nasync def get_conversations_list(agent_name: str):", ")\nasync def get_conversations_list(agent_name: str):\n    conversations = get_conversations(\n        agent_name=agent_name,\n    )\n    if conversations is None:\n        conversations = []\n    return {\"conversations\": conversations}\n\n", "\n\n@app.get(\"/api/conversation\", tags=[\"Agent\"], dependencies=[Depends(verify_api_key)])\nasync def get_conversation_history(history: HistoryModel):\n    conversation_history = get_conversation(\n        agent_name=history.agent_name,\n        conversation_name=history.conversation_name,\n        limit=history.limit,\n        page=history.page,\n    )", "        page=history.page,\n    )\n\n    if conversation_history is None:\n        conversation_history = []\n    if \"interactions\" in conversation_history:\n        conversation_history = conversation_history[\"interactions\"]\n    return {\"conversation_history\": conversation_history}\n\n", "\n\n@app.post(\"/api/conversation\", tags=[\"Agent\"], dependencies=[Depends(verify_api_key)])\nasync def new_conversation_history(history: ConversationHistoryModel):\n    new_conversation(\n        agent_name=history.agent_name,\n        conversation_name=history.conversation_name,\n    )\n    return {\"conversation_history\": []}\n", "    return {\"conversation_history\": []}\n\n\n@app.delete(\n    \"/api/conversation\",\n    tags=[\"Agent\"],\n    dependencies=[Depends(verify_api_key)],\n)\nasync def delete_conversation_history(\n    history: ConversationHistoryModel,", "async def delete_conversation_history(\n    history: ConversationHistoryModel,\n) -> ResponseMessage:\n    delete_history(\n        agent_name=history.agent_name, conversation_name=history.conversation_name\n    )\n    return ResponseMessage(\n        message=f\"Conversation `{history.conversation_name}` for agent {history.agent_name} deleted.\"\n    )\n", "    )\n\n\n@app.delete(\n    \"/api/conversation/message\",\n    tags=[\"Agent\"],\n    dependencies=[Depends(verify_api_key)],\n)\nasync def delete_history_message(\n    history: ConversationHistoryMessageModel,", "async def delete_history_message(\n    history: ConversationHistoryMessageModel,\n) -> ResponseMessage:\n    delete_message(\n        agent_name=history.agent_name,\n        message=history.message,\n        conversation_name=f\"{history.agent_name} History\",\n    )\n    return ResponseMessage(message=f\"Message deleted.\")\n", "    return ResponseMessage(message=f\"Message deleted.\")\n\n\n@app.delete(\n    \"/api/agent/{agent_name}/memory\",\n    tags=[\"Agent\"],\n    dependencies=[Depends(verify_api_key)],\n)\nasync def wipe_agent_memories(agent_name: str) -> ResponseMessage:\n    Agent(agent_name=agent_name).wipe_agent_memories()", "async def wipe_agent_memories(agent_name: str) -> ResponseMessage:\n    Agent(agent_name=agent_name).wipe_agent_memories()\n    return ResponseMessage(message=f\"Memories for agent {agent_name} deleted.\")\n\n\n@app.post(\n    \"/api/agent/{agent_name}/prompt\",\n    tags=[\"Agent\"],\n    dependencies=[Depends(verify_api_key)],\n)", "    dependencies=[Depends(verify_api_key)],\n)\nasync def prompt_agent(agent_name: str, agent_prompt: AgentPrompt):\n    agent = Interactions(agent_name=agent_name)\n    response = await agent.run(\n        prompt=agent_prompt.prompt_name,\n        **agent_prompt.prompt_args,\n    )\n    return {\"response\": str(response)}\n", "    return {\"response\": str(response)}\n\n\n@app.post(\"/api/v1/completions\", tags=[\"Agent\"], dependencies=[Depends(verify_api_key)])\nasync def completion(prompt: Completions):\n    # prompt.model is the agent name\n    agent = Interactions(agent_name=prompt.model)\n    agent_config = Agent(agent_name=prompt.model).get_agent_config()\n    if \"settings\" in agent_config:\n        if \"AI_MODEL\" in agent_config[\"settings\"]:\n            model = agent_config[\"settings\"][\"AI_MODEL\"]\n        else:\n            model = \"undefined\"\n    else:\n        model = \"undefined\"", "    if \"settings\" in agent_config:\n        if \"AI_MODEL\" in agent_config[\"settings\"]:\n            model = agent_config[\"settings\"][\"AI_MODEL\"]\n        else:\n            model = \"undefined\"\n    else:\n        model = \"undefined\"\n    response = await agent.run(\n        user_input=prompt.prompt,\n        prompt=\"Custom Input\",", "        user_input=prompt.prompt,\n        prompt=\"Custom Input\",\n        context_results=3,\n        shots=prompt.n,\n    )\n    characters = string.ascii_letters + string.digits\n    prompt_tokens = get_tokens(prompt.prompt)\n    completion_tokens = get_tokens(response)\n    total_tokens = int(prompt_tokens) + int(completion_tokens)\n    random_chars = \"\".join(random.choice(characters) for _ in range(15))", "    total_tokens = int(prompt_tokens) + int(completion_tokens)\n    random_chars = \"\".join(random.choice(characters) for _ in range(15))\n    res_model = {\n        \"id\": f\"cmpl-{random_chars}\",\n        \"object\": \"text_completion\",\n        \"created\": int(time.time()),\n        \"model\": model,\n        \"choices\": [\n            {\n                \"text\": response,", "            {\n                \"text\": response,\n                \"index\": 0,\n                \"logprobs\": None,\n                \"finish_reason\": \"stop\",\n            }\n        ],\n        \"usage\": {\n            \"prompt_tokens\": prompt_tokens,\n            \"completion_tokens\": completion_tokens,", "            \"prompt_tokens\": prompt_tokens,\n            \"completion_tokens\": completion_tokens,\n            \"total_tokens\": total_tokens,\n        },\n    }\n    return res_model\n\n\n@app.post(\n    \"/api/v1/chat/completions\", tags=[\"Agent\"], dependencies=[Depends(verify_api_key)]", "@app.post(\n    \"/api/v1/chat/completions\", tags=[\"Agent\"], dependencies=[Depends(verify_api_key)]\n)\nasync def chat_completion(prompt: Completions):\n    # prompt.model is the agent name\n    agent = Interactions(agent_name=prompt.model)\n    agent_config = Agent(agent_name=prompt.model).get_agent_config()\n    if \"settings\" in agent_config:\n        if \"AI_MODEL\" in agent_config[\"settings\"]:\n            model = agent_config[\"settings\"][\"AI_MODEL\"]\n        else:\n            model = \"undefined\"\n    else:\n        model = \"undefined\"", "    response = await agent.run(\n        user_input=prompt.prompt,\n        prompt=\"Custom Input\",\n        context_results=3,\n        shots=prompt.n,\n    )\n    characters = string.ascii_letters + string.digits\n    prompt_tokens = get_tokens(prompt.prompt)\n    completion_tokens = get_tokens(response)\n    total_tokens = int(prompt_tokens) + int(completion_tokens)", "    completion_tokens = get_tokens(response)\n    total_tokens = int(prompt_tokens) + int(completion_tokens)\n    random_chars = \"\".join(random.choice(characters) for _ in range(15))\n    res_model = {\n        \"id\": f\"chatcmpl-{random_chars}\",\n        \"object\": \"chat.completion\",\n        \"created\": int(time.time()),\n        \"model\": model,\n        \"choices\": [\n            {", "        \"choices\": [\n            {\n                \"index\": 0,\n                \"message\": [\n                    {\n                        \"role\": \"assistant\",\n                        \"content\": response,\n                    },\n                ],\n                \"finish_reason\": \"stop\",", "                ],\n                \"finish_reason\": \"stop\",\n            }\n        ],\n        \"usage\": {\n            \"prompt_tokens\": prompt_tokens,\n            \"completion_tokens\": completion_tokens,\n            \"total_tokens\": total_tokens,\n        },\n    }", "        },\n    }\n    return res_model\n\n\n# Use agent name in the model field to use embedding.\n@app.post(\"/api/v1/embedding\", tags=[\"Agent\"], dependencies=[Depends(verify_api_key)])\nasync def embedding(embedding: EmbeddingModel):\n    agent_name = embedding.model\n    agent_config = Agent(agent_name=agent_name).get_agent_config()", "    agent_name = embedding.model\n    agent_config = Agent(agent_name=agent_name).get_agent_config()\n    tokens = get_tokens(embedding.input)\n    embedding = Embedding(AGENT_CONFIG=agent_config).embed_text(embedding.input)\n    return {\n        \"data\": [{\"embedding\": embedding, \"index\": 0, \"object\": \"embedding\"}],\n        \"model\": agent_name,\n        \"object\": \"list\",\n        \"usage\": {\"prompt_tokens\": tokens, \"total_tokens\": tokens},\n    }", "        \"usage\": {\"prompt_tokens\": tokens, \"total_tokens\": tokens},\n    }\n\n\n@app.get(\n    \"/api/agent/{agent_name}/command\",\n    tags=[\"Agent\"],\n    dependencies=[Depends(verify_api_key)],\n)\nasync def get_commands(agent_name: str):", ")\nasync def get_commands(agent_name: str):\n    agent = Agent(agent_name=agent_name)\n    return {\"commands\": agent.AGENT_CONFIG[\"commands\"]}\n\n\n@app.patch(\n    \"/api/agent/{agent_name}/command\",\n    tags=[\"Agent\"],\n    dependencies=[Depends(verify_api_key)],", "    tags=[\"Agent\"],\n    dependencies=[Depends(verify_api_key)],\n)\nasync def toggle_command(\n    agent_name: str, payload: ToggleCommandPayload\n) -> ResponseMessage:\n    agent = Agent(agent_name=agent_name)\n    try:\n        if payload.command_name == \"*\":\n            for each_command_name in agent.AGENT_CONFIG[\"commands\"]:\n                agent.AGENT_CONFIG[\"commands\"][each_command_name] = payload.enable\n\n            agent.update_agent_config(\n                new_config=agent.AGENT_CONFIG[\"commands\"], config_key=\"commands\"\n            )\n            return ResponseMessage(\n                message=f\"All commands enabled for agent '{agent_name}'.\"\n            )\n        else:\n            agent.AGENT_CONFIG[\"commands\"][payload.command_name] = payload.enable\n            agent.update_agent_config(\n                new_config=agent.AGENT_CONFIG[\"commands\"], config_key=\"commands\"\n            )\n            return ResponseMessage(\n                message=f\"Command '{payload.command_name}' toggled for agent '{agent_name}'.\"\n            )\n    except Exception as e:\n        logging.info(e)\n        raise HTTPException(\n            status_code=500,\n            detail=f\"Error enabling all commands for agent '{agent_name}': {str(e)}\",\n        )", "\n\n@app.get(\"/api/chain\", tags=[\"Chain\"], dependencies=[Depends(verify_api_key)])\nasync def get_chains():\n    chains = Chain().get_chains()\n    return chains\n\n\n@app.get(\n    \"/api/chain/{chain_name}\", tags=[\"Chain\"], dependencies=[Depends(verify_api_key)]", "@app.get(\n    \"/api/chain/{chain_name}\", tags=[\"Chain\"], dependencies=[Depends(verify_api_key)]\n)\nasync def get_chain(chain_name: str):\n    # try:\n    chain_data = Chain().get_chain(chain_name=chain_name)\n    return {\"chain\": chain_data}\n    # except:\n    #    raise HTTPException(status_code=404, detail=\"Chain not found\")\n", "    #    raise HTTPException(status_code=404, detail=\"Chain not found\")\n\n\n@app.get(\"/api/chain/{chain_name}/responses\", tags=[\"Chain\"])\nasync def get_chain_responses(chain_name: str):\n    try:\n        chain_data = Chain().get_step_response(chain_name=chain_name, step_number=\"all\")\n        return {\"chain\": chain_data}\n    except:\n        raise HTTPException(status_code=404, detail=\"Chain not found\")", "\n\n@app.post(\n    \"/api/chain/{chain_name}/run\",\n    tags=[\"Chain\"],\n    dependencies=[Depends(verify_api_key)],\n)\nasync def run_chain(chain_name: str, user_input: RunChain):\n    chain_response = await Chain().run_chain(\n        chain_name=chain_name,", "    chain_response = await Chain().run_chain(\n        chain_name=chain_name,\n        user_input=user_input.prompt,\n        agent_override=user_input.agent_override,\n        all_responses=user_input.all_responses,\n        from_step=user_input.from_step,\n    )\n    return chain_response\n\n", "\n\n@app.post(\n    \"/api/chain/{chain_name}/run/step/{step_number}\",\n    tags=[\"Chain\"],\n    dependencies=[Depends(verify_api_key)],\n)\nasync def run_chain_step(chain_name: str, step_number: str, user_input: RunChainStep):\n    chain = Chain()\n    chain_steps = chain.get_chain(chain_name=chain_name)\n    try:\n        step = chain_steps[\"step\"][step_number]\n    except Exception as e:\n        raise HTTPException(\n            status_code=404, detail=f\"Step {step_number} not found. {e}\"\n        )", "    chain = Chain()\n    chain_steps = chain.get_chain(chain_name=chain_name)\n    try:\n        step = chain_steps[\"step\"][step_number]\n    except Exception as e:\n        raise HTTPException(\n            status_code=404, detail=f\"Step {step_number} not found. {e}\"\n        )\n    chain_step_response = await chain.run_chain_step(\n        step=step,", "    chain_step_response = await chain.run_chain_step(\n        step=step,\n        chain_name=chain_name,\n        user_input=user_input.prompt,\n        agent_override=user_input.agent_override,\n    )\n    return chain_step_response\n\n\n@app.post(\"/api/chain\", tags=[\"Chain\"], dependencies=[Depends(verify_api_key)])", "\n@app.post(\"/api/chain\", tags=[\"Chain\"], dependencies=[Depends(verify_api_key)])\nasync def add_chain(chain_name: ChainName) -> ResponseMessage:\n    Chain().add_chain(chain_name=chain_name.chain_name)\n    return ResponseMessage(message=f\"Chain '{chain_name.chain_name}' created.\")\n\n\n@app.post(\"/api/chain/import\", tags=[\"Chain\"], dependencies=[Depends(verify_api_key)])\nasync def importchain(chain: ChainData) -> ResponseMessage:\n    response = Chain().import_chain(chain_name=chain.chain_name, steps=chain.steps)", "async def importchain(chain: ChainData) -> ResponseMessage:\n    response = Chain().import_chain(chain_name=chain.chain_name, steps=chain.steps)\n    return ResponseMessage(message=response)\n\n\n@app.put(\n    \"/api/chain/{chain_name}\", tags=[\"Chain\"], dependencies=[Depends(verify_api_key)]\n)\nasync def rename_chain(chain_name: str, new_name: ChainNewName) -> ResponseMessage:\n    Chain().rename_chain(chain_name=chain_name, new_name=new_name.new_name)", "async def rename_chain(chain_name: str, new_name: ChainNewName) -> ResponseMessage:\n    Chain().rename_chain(chain_name=chain_name, new_name=new_name.new_name)\n    return ResponseMessage(\n        message=f\"Chain '{chain_name}' renamed to '{new_name.new_name}'.\"\n    )\n\n\n@app.delete(\n    \"/api/chain/{chain_name}\", tags=[\"Chain\"], dependencies=[Depends(verify_api_key)]\n)", "    \"/api/chain/{chain_name}\", tags=[\"Chain\"], dependencies=[Depends(verify_api_key)]\n)\nasync def delete_chain(chain_name: str) -> ResponseMessage:\n    Chain().delete_chain(chain_name=chain_name)\n    return ResponseMessage(message=f\"Chain '{chain_name}' deleted.\")\n\n\n@app.post(\n    \"/api/chain/{chain_name}/step\",\n    tags=[\"Chain\"],", "    \"/api/chain/{chain_name}/step\",\n    tags=[\"Chain\"],\n    dependencies=[Depends(verify_api_key)],\n)\nasync def add_step(chain_name: str, step_info: StepInfo) -> ResponseMessage:\n    Chain().add_chain_step(\n        chain_name=chain_name,\n        step_number=step_info.step_number,\n        prompt_type=step_info.prompt_type,\n        prompt=step_info.prompt,", "        prompt_type=step_info.prompt_type,\n        prompt=step_info.prompt,\n        agent_name=step_info.agent_name,\n    )\n    return {\"message\": f\"Step {step_info.step_number} added to chain '{chain_name}'.\"}\n\n\n@app.put(\n    \"/api/chain/{chain_name}/step/{step_number}\",\n    tags=[\"Chain\"],", "    \"/api/chain/{chain_name}/step/{step_number}\",\n    tags=[\"Chain\"],\n    dependencies=[Depends(verify_api_key)],\n)\nasync def update_step(\n    chain_name: str, step_number: int, chain_step: ChainStep\n) -> ResponseMessage:\n    Chain().update_step(\n        chain_name=chain_name,\n        step_number=chain_step.step_number,", "        chain_name=chain_name,\n        step_number=chain_step.step_number,\n        prompt_type=chain_step.prompt_type,\n        prompt=chain_step.prompt,\n        agent_name=chain_step.agent_name,\n    )\n    return {\n        \"message\": f\"Step {chain_step.step_number} updated for chain '{chain_name}'.\"\n    }\n", "    }\n\n\n@app.patch(\n    \"/api/chain/{chain_name}/step/move\",\n    tags=[\"Chain\"],\n    dependencies=[Depends(verify_api_key)],\n)\nasync def move_step(\n    chain_name: str, chain_step_new_info: ChainStepNewInfo", "async def move_step(\n    chain_name: str, chain_step_new_info: ChainStepNewInfo\n) -> ResponseMessage:\n    Chain().move_step(\n        chain_name=chain_name,\n        current_step_number=chain_step_new_info.old_step_number,\n        new_step_number=chain_step_new_info.new_step_number,\n    )\n    return {\n        \"message\": f\"Step {chain_step_new_info.old_step_number} moved to {chain_step_new_info.new_step_number} in chain '{chain_name}'.\"", "    return {\n        \"message\": f\"Step {chain_step_new_info.old_step_number} moved to {chain_step_new_info.new_step_number} in chain '{chain_name}'.\"\n    }\n\n\n@app.delete(\n    \"/api/chain/{chain_name}/step/{step_number}\",\n    tags=[\"Chain\"],\n    dependencies=[Depends(verify_api_key)],\n)", "    dependencies=[Depends(verify_api_key)],\n)\nasync def delete_step(chain_name: str, step_number: int) -> ResponseMessage:\n    Chain().delete_step(chain_name=chain_name, step_number=step_number)\n    return {\"message\": f\"Step {step_number} deleted from chain '{chain_name}'.\"}\n\n\n@app.post(\"/api/prompt\", tags=[\"Prompt\"], dependencies=[Depends(verify_api_key)])\nasync def add_prompt(prompt: CustomPromptModel) -> ResponseMessage:\n    try:\n        Prompts().add_prompt(prompt_name=prompt.prompt_name, prompt=prompt.prompt)\n        return ResponseMessage(message=f\"Prompt '{prompt.prompt_name}' added.\")\n    except Exception as e:\n        raise HTTPException(status_code=400, detail=str(e))", "async def add_prompt(prompt: CustomPromptModel) -> ResponseMessage:\n    try:\n        Prompts().add_prompt(prompt_name=prompt.prompt_name, prompt=prompt.prompt)\n        return ResponseMessage(message=f\"Prompt '{prompt.prompt_name}' added.\")\n    except Exception as e:\n        raise HTTPException(status_code=400, detail=str(e))\n\n\n@app.get(\n    \"/api/prompt/{prompt_name}\",", "@app.get(\n    \"/api/prompt/{prompt_name}\",\n    tags=[\"Prompt\"],\n    response_model=CustomPromptModel,\n    dependencies=[Depends(verify_api_key)],\n)\nasync def get_prompt(prompt_name: str):\n    # try:\n    prompt_content = Prompts().get_prompt(prompt_name=prompt_name)\n    return {\"prompt_name\": prompt_name, \"prompt\": prompt_content}", "    prompt_content = Prompts().get_prompt(prompt_name=prompt_name)\n    return {\"prompt_name\": prompt_name, \"prompt\": prompt_content}\n    # except Exception as e:\n    #    raise HTTPException(status_code=404, detail=str(e))\n\n\n@app.get(\n    \"/api/prompt\",\n    response_model=PromptList,\n    tags=[\"Prompt\"],", "    response_model=PromptList,\n    tags=[\"Prompt\"],\n    dependencies=[Depends(verify_api_key)],\n)\nasync def get_prompts():\n    prompts = Prompts().get_prompts()\n    return {\"prompts\": prompts}\n\n\n@app.delete(", "\n@app.delete(\n    \"/api/prompt/{prompt_name}\", tags=[\"Prompt\"], dependencies=[Depends(verify_api_key)]\n)\nasync def delete_prompt(prompt_name: str) -> ResponseMessage:\n    try:\n        Prompts().delete_prompt(prompt_name=prompt_name)\n        return ResponseMessage(message=f\"Prompt '{prompt_name}' deleted.\")\n    except Exception as e:\n        raise HTTPException(status_code=404, detail=str(e))", "\n\n# Rename prompt\n@app.patch(\n    \"/api/prompt/{prompt_name}\", tags=[\"Prompt\"], dependencies=[Depends(verify_api_key)]\n)\nasync def rename_prompt(prompt_name: str, new_name: PromptName) -> ResponseMessage:\n    try:\n        Prompts().rename_prompt(prompt_name=prompt_name, new_name=new_name.prompt_name)\n        return ResponseMessage(\n            message=f\"Prompt '{prompt_name}' renamed to '{new_name.prompt_name}'.\"\n        )\n    except Exception as e:\n        raise HTTPException(status_code=404, detail=str(e))", "\n\n@app.put(\n    \"/api/prompt/{prompt_name}\", tags=[\"Prompt\"], dependencies=[Depends(verify_api_key)]\n)\nasync def update_prompt(prompt: CustomPromptModel) -> ResponseMessage:\n    try:\n        Prompts().update_prompt(prompt_name=prompt.prompt_name, prompt=prompt.prompt)\n        return ResponseMessage(message=f\"Prompt '{prompt.prompt_name}' updated.\")\n    except Exception as e:\n        raise HTTPException(status_code=404, detail=str(e))", "\n\n@app.get(\n    \"/api/prompt/{prompt_name}/args\",\n    tags=[\"Prompt\"],\n    dependencies=[Depends(verify_api_key)],\n)\nasync def get_prompt_arg(prompt_name: str):\n    prompt_name = prompt_name.replace(\"%20\", \" \")\n    prompt = Prompts().get_prompt(prompt_name=prompt_name)", "    prompt_name = prompt_name.replace(\"%20\", \" \")\n    prompt = Prompts().get_prompt(prompt_name=prompt_name)\n    return {\"prompt_args\": Prompts().get_prompt_args(prompt)}\n\n\n@app.get(\n    \"/api/extensions/settings\",\n    tags=[\"Extensions\"],\n    dependencies=[Depends(verify_api_key)],\n)", "    dependencies=[Depends(verify_api_key)],\n)\nasync def get_extension_settings():\n    try:\n        return {\"extension_settings\": Extensions().get_extension_settings()}\n    except Exception:\n        raise HTTPException(status_code=400, detail=\"Unable to retrieve settings.\")\n\n\n@app.get(", "\n@app.get(\n    \"/api/extensions/{command_name}/args\",\n    tags=[\"Extension\"],\n    dependencies=[Depends(verify_api_key)],\n)\nasync def get_command_args(command_name: str):\n    return {\"command_args\": Extensions().get_command_args(command_name=command_name)}\n\n", "\n\n@app.get(\"/api/extensions\", tags=[\"Extension\"], dependencies=[Depends(verify_api_key)])\nasync def get_extensions():\n    extensions = Extensions().get_extensions()\n    return {\"extensions\": extensions}\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"0.0.0.0\", port=7437)", "if __name__ == \"__main__\":\n    uvicorn.run(app, host=\"0.0.0.0\", port=7437)\n"]}
{"filename": "agixt/Interactions.py", "chunked_list": ["import re\nimport os\nimport regex\nimport json\nimport time\nimport logging\nimport asyncio\nfrom datetime import datetime\nfrom dotenv import load_dotenv\n", "from dotenv import load_dotenv\n\nload_dotenv()\n\ndb_connected = True if os.getenv(\"DB_CONNECTED\", \"false\").lower() == \"true\" else False\nif db_connected:\n    from db.Agent import Agent\n    from db.Prompts import Prompts\n    from db.Chain import Chain\n    from db.History import log_interaction\nelse:\n    from fb.Agent import Agent\n    from fb.Prompts import Prompts\n    from fb.Chain import Chain\n    from fb.History import log_interaction", "\nfrom Embedding import get_tokens\nfrom concurrent.futures import Future\nfrom agixtsdk import AGiXTSDK\nfrom Websearch import Websearch\n\nApiClient = AGiXTSDK(\n    base_uri=\"http://localhost:7437\", api_key=os.getenv(\"AGIXT_API_KEY\")\n)\nchain = Chain()", ")\nchain = Chain()\ncp = Prompts()\n\n\nclass Interactions:\n    def __init__(self, agent_name: str = \"\"):\n        if agent_name != \"\":\n            self.agent_name = agent_name\n            self.agent = Agent(self.agent_name)\n            self.agent_commands = self.agent.get_commands_string()\n            self.memories = self.agent.get_memories()\n            self.websearch = Websearch(agent=self.agent, memories=self.memories)\n        else:\n            self.agent_name = \"\"\n            self.agent = None\n            self.agent_commands = \"\"\n            self.memories = None\n        self.stop_running_event = None\n        self.browsed_links = []\n        self.failures = 0\n\n    def custom_format(self, string, **kwargs):\n        if isinstance(string, list):\n            string = \"\".join(str(x) for x in string)\n\n        def replace(match):\n            key = match.group(1)\n            value = kwargs.get(key, match.group(0))\n            if isinstance(value, list):\n                return \"\".join(str(x) for x in value)\n            else:\n                return str(value)\n\n        pattern = r\"(?<!{){([^{}\\n]+)}(?!})\"\n        result = re.sub(pattern, replace, string)\n        return result\n\n    async def format_prompt(\n        self,\n        user_input: str = \"\",\n        top_results: int = 5,\n        prompt=\"\",\n        chain_name=\"\",\n        step_number=0,\n        **kwargs,\n    ):\n        if prompt == \"\":\n            prompt = user_input\n        else:\n            try:\n                prompt = cp.get_prompt(\n                    prompt_name=prompt,\n                    prompt_category=self.agent.AGENT_CONFIG[\"settings\"][\"AI_MODEL\"],\n                )\n            except:\n                prompt = prompt\n        logging.info(f\"CONTEXT RESULTS: {top_results}\")\n        if top_results == 0:\n            context = \"\"\n        else:\n            # try:\n            context = await self.memories.context_agent(\n                query=user_input, top_results_num=top_results\n            )\n            # except:\n            # context = \"\"\n        command_list = self.agent.get_commands_string()\n        if chain_name != \"\":\n            try:\n                for arg, value in kwargs.items():\n                    if \"{STEP\" in value:\n                        # get the response from the step number\n                        step_response = chain.get_step_response(\n                            chain_name=chain_name, step_number=step_number\n                        )\n                        # replace the {STEPx} with the response\n                        value = value.replace(f\"{{STEP{step_number}}}\", step_response)\n                        kwargs[arg] = value\n            except:\n                logging.info(\"No args to replace.\")\n            if \"{STEP\" in prompt:\n                step_response = chain.get_step_response(\n                    chain_name=chain_name, step_number=step_number\n                )\n                prompt = prompt.replace(f\"{{STEP{step_number}}}\", step_response)\n            if \"{STEP\" in user_input:\n                step_response = chain.get_step_response(\n                    chain_name=chain_name, step_number=step_number\n                )\n                user_input = user_input.replace(f\"{{STEP{step_number}}}\", step_response)\n        try:\n            working_directory = self.agent.AGENT_CONFIG[\"settings\"][\"WORKING_DIRECTORY\"]\n        except:\n            working_directory = \"./WORKSPACE\"\n        if \"helper_agent_name\" not in kwargs:\n            if \"helper_agent_name\" in self.agent.AGENT_CONFIG[\"settings\"]:\n                helper_agent_name = self.agent.AGENT_CONFIG[\"settings\"][\n                    \"helper_agent_name\"\n                ]\n            else:\n                helper_agent_name = self.agent_name\n        formatted_prompt = self.custom_format(\n            string=prompt,\n            user_input=user_input,\n            agent_name=self.agent_name,\n            COMMANDS=self.agent_commands,\n            context=context,\n            command_list=command_list,\n            date=datetime.now().strftime(\"%B %d, %Y %I:%M %p\"),\n            working_directory=working_directory,\n            helper_agent_name=helper_agent_name,\n            **kwargs,\n        )\n\n        tokens = get_tokens(formatted_prompt)\n        logging.info(f\"FORMATTED PROMPT: {formatted_prompt}\")\n        return formatted_prompt, prompt, tokens\n\n    async def run(\n        self,\n        user_input: str = \"\",\n        prompt: str = \"\",\n        context_results: int = 5,\n        websearch: bool = False,\n        websearch_depth: int = 3,\n        chain_name: str = \"\",\n        step_number: int = 0,\n        shots: int = 1,\n        disable_memory: bool = False,\n        conversation_name: str = \"\",\n        browse_links: bool = False,\n        **kwargs,\n    ):\n        shots = int(shots)\n        disable_memory = True if str(disable_memory).lower() == \"true\" else False\n        browse_links = True if str(browse_links).lower() == \"true\" else False\n        if conversation_name != \"\":\n            conversation_name = f\"{self.agent_name} History\"\n        if \"WEBSEARCH_TIMEOUT\" in self.agent.PROVIDER_SETTINGS:\n            try:\n                websearch_timeout = int(\n                    self.agent.PROVIDER_SETTINGS[\"WEBSEARCH_TIMEOUT\"]\n                )\n            except:\n                websearch_timeout = 0\n        else:\n            websearch_timeout = 0\n        if browse_links != False:\n            links = re.findall(r\"(?P<url>https?://[^\\s]+)\", user_input)\n            if links is not None and len(links) > 0:\n                for link in links:\n                    if link not in self.websearch.browsed_links:\n                        logging.info(f\"Browsing link: {link}\")\n                        self.websearch.browsed_links.append(link)\n                        text_content, link_list = await self.memories.read_website(\n                            url=link\n                        )\n                        if link_list is not None and len(link_list) > 0:\n                            i = 0\n                            for sublink in link_list:\n                                if sublink[1] not in self.websearch.browsed_links:\n                                    logging.info(f\"Browsing link: {sublink[1]}\")\n                                    if i <= 10:\n                                        (\n                                            text_content,\n                                            link_list,\n                                        ) = await self.memories.read_website(\n                                            url=sublink[1]\n                                        )\n                                        i = i + 1\n        if websearch:\n            if user_input == \"\":\n                if \"primary_objective\" in kwargs and \"task\" in kwargs:\n                    search_string = f\"Primary Objective: {kwargs['primary_objective']}\\n\\nTask: {kwargs['task']}\"\n                else:\n                    search_string = \"\"\n            else:\n                search_string = user_input\n            if search_string != \"\":\n                await self.websearch.websearch_agent(\n                    user_input=search_string,\n                    depth=websearch_depth,\n                    timeout=websearch_timeout,\n                )\n        formatted_prompt, unformatted_prompt, tokens = await self.format_prompt(\n            user_input=user_input,\n            top_results=int(context_results),\n            prompt=prompt,\n            chain_name=chain_name,\n            step_number=step_number,\n            **kwargs,\n        )\n        try:\n            # Workaround for non-threaded providers\n            run_response = await self.agent.instruct(formatted_prompt, tokens=tokens)\n            self.response = (\n                run_response.result()\n                if isinstance(run_response, Future)\n                else run_response\n            )\n        except Exception as e:\n            logging.info(f\"Error: {e}\")\n            logging.info(f\"PROMPT CONTENT: {formatted_prompt}\")\n            logging.info(f\"TOKENS: {tokens}\")\n            self.failures += 1\n            if self.failures == 5:\n                self.failures == 0\n                logging.info(\"Failed to get a response 5 times in a row.\")\n                return None\n            logging.info(f\"Retrying in 10 seconds...\")\n            time.sleep(10)\n            if context_results > 0:\n                context_results = context_results - 1\n            self.response = ApiClient.prompt_agent(\n                agent_name=self.agent_name,\n                prompt_name=prompt,\n                prompt_args={\n                    \"chain_name\": chain_name,\n                    \"step_number\": step_number,\n                    \"shots\": shots,\n                    \"disable_memory\": disable_memory,\n                    \"user_input\": user_input,\n                    \"context_results\": context_results,\n                    \"conversation_name\": conversation_name,\n                    **kwargs,\n                },\n            )\n\n        # Handle commands if the prompt contains the {COMMANDS} placeholder\n        # We handle command injection that DOESN'T allow command execution by using {command_list} in the prompt\n        if \"{COMMANDS}\" in unformatted_prompt:\n            execution_response = await self.execution_agent(\n                execution_response=self.response,\n                user_input=user_input,\n                context_results=context_results,\n                **kwargs,\n            )\n            return_response = \"\"\n            if \"AUTONOMOUS_EXECUTION\" in self.agent.AGENT_CONFIG[\"settings\"]:\n                autonomous = (\n                    True\n                    if self.agent.AGENT_CONFIG[\"settings\"][\"AUTONOMOUS_EXECUTION\"]\n                    == True\n                    else False\n                )\n            else:\n                autonomous = False\n\n            if autonomous == True:\n                try:\n                    self.response = json.loads(self.response)\n                    if \"response\" in self.response:\n                        return_response = self.response[\"response\"]\n                    if \"commands\" in self.response:\n                        if self.response[\"commands\"] != {}:\n                            return_response += (\n                                f\"\\n\\nCommands Executed:\\n{self.response['commands']}\"\n                            )\n                    if execution_response:\n                        return_response += (\n                            f\"\\n\\nCommand Execution Response:\\n{execution_response}\"\n                        )\n                except:\n                    return_response = self.response\n            else:\n                return_response = f\"{self.response}\\n\\n{execution_response}\"\n            self.response = return_response\n        logging.info(f\"Response: {self.response}\")\n        if self.response != \"\" and self.response != None:\n            if disable_memory != True:\n                try:\n                    await self.memories.store_result(\n                        input=user_input, result=self.response\n                    )\n                except:\n                    pass\n            if user_input != \"\":\n                log_interaction(\n                    agent_name=self.agent_name,\n                    conversation_name=conversation_name,\n                    role=\"USER\",\n                    message=user_input,\n                )\n            else:\n                log_interaction(\n                    agent_name=self.agent_name,\n                    conversation_name=conversation_name,\n                    role=\"USER\",\n                    message=formatted_prompt,\n                )\n            log_interaction(\n                agent_name=self.agent_name,\n                conversation_name=conversation_name,\n                role=self.agent_name,\n                message=self.response,\n            )\n\n        if shots > 1:\n            responses = [self.response]\n            for shot in range(shots - 1):\n                shot_response = ApiClient.prompt_agent(\n                    agent_name=self.agent_name,\n                    prompt_name=prompt,\n                    prompt_args={\n                        \"chain_name\": chain_name,\n                        \"step_number\": step_number,\n                        \"user_input\": user_input,\n                        \"context_results\": context_results,\n                        \"conversation_name\": conversation_name,\n                        **kwargs,\n                    },\n                )\n                time.sleep(1)\n                responses.append(shot_response)\n            return \"\\n\".join(\n                [\n                    f\"Response {shot + 1}:\\n{response}\"\n                    for shot, response in enumerate(responses)\n                ]\n            )\n        return self.response\n\n    # Worker Sub-Agents\n    async def validation_agent(\n        self, user_input, execution_response, context_results, **kwargs\n    ):\n        try:\n            pattern = regex.compile(r\"\\{(?:[^{}]|(?R))*\\}\")\n            cleaned_json = pattern.findall(execution_response)\n            if len(cleaned_json) == 0:\n                return {}\n            if isinstance(cleaned_json, list):\n                cleaned_json = cleaned_json[0]\n            response = json.loads(cleaned_json)\n            return response\n        except:\n            logging.info(\"INVALID JSON RESPONSE\")\n            logging.info(execution_response)\n            logging.info(\"... Trying again.\")\n            if context_results != 0:\n                context_results = context_results - 1\n            else:\n                context_results = 0\n            execution_response = ApiClient.prompt_agent(\n                agent_name=self.agent_name,\n                prompt_name=\"JSONFormatter\",\n                prompt_args={\n                    \"user_input\": user_input,\n                    \"context_results\": context_results,\n                    **kwargs,\n                },\n            )\n            return await self.validation_agent(\n                user_input=user_input,\n                execution_response=execution_response,\n                context_results=context_results,\n                **kwargs,\n            )\n\n    def create_command_suggestion_chain(self, agent_name, command_name, command_args):\n        chains = ApiClient.get_chains()\n        chain_name = f\"{agent_name} Command Suggestions\"\n        if chain_name in chains:\n            step = (\n                int(ApiClient.get_chain(chain_name=chain_name)[\"steps\"][-1][\"step\"]) + 1\n            )\n        else:\n            ApiClient.add_chain(chain_name=chain_name)\n            step = 1\n        ApiClient.add_step(\n            chain_name=chain_name,\n            agent_name=agent_name,\n            step_number=step,\n            prompt_type=\"Command\",\n            prompt={\n                \"command_name\": command_name,\n                **command_args,\n            },\n        )\n        return f\"The command has been added to a chain called '{agent_name} Command Suggestions' for you to review and execute manually.\"\n\n    async def execution_agent(\n        self, execution_response, user_input, context_results, **kwargs\n    ):\n        validated_response = await self.validation_agent(\n            user_input=user_input,\n            execution_response=execution_response,\n            context_results=context_results,\n            **kwargs,\n        )\n        if \"commands\" in validated_response:\n            for command_name, command_args in validated_response[\"commands\"].items():\n                # Search for the command in the available_commands list, and if found, use the command's name attribute for execution\n                if command_name is not None:\n                    for available_command in self.agent.available_commands:\n                        if command_name == available_command[\"friendly_name\"]:\n                            # Check if the command is a valid command in the self.avent.available_commands list\n                            try:\n                                if bool(self.agent.AUTONOMOUS_EXECUTION) == True:\n                                    command_output = await self.agent.execute(\n                                        command_name=command_name,\n                                        command_args=command_args,\n                                    )\n                                else:\n                                    command_output = (\n                                        self.create_command_suggestion_chain(\n                                            agent_name=self.agent_name,\n                                            command_name=command_name,\n                                            command_args=command_args,\n                                        )\n                                    )\n                            except Exception as e:\n                                logging.info(\"Command validation failed, retrying...\")\n                                validate_command = ApiClient.prompt_agent(\n                                    agent_name=self.agent_name,\n                                    prompt_name=\"ValidationFailed\",\n                                    prompt_args={\n                                        \"command_name\": command_name,\n                                        \"command_args\": command_args,\n                                        \"command_output\": e,\n                                        \"user_input\": user_input,\n                                        \"context_results\": context_results,\n                                        **kwargs,\n                                    },\n                                )\n                                return await self.execution_agent(\n                                    execution_response=validate_command,\n                                    user_input=user_input,\n                                    context_results=context_results,\n                                    **kwargs,\n                                )\n                            logging.info(\n                                f\"Command {command_name} executed successfully with args {command_args}. Command Output: {command_output}\"\n                            )\n                            response = f\"\\nExecuted Command:{command_name} with args {command_args}.\\nCommand Output: {command_output}\\n\"\n                            return response\n                else:\n                    if command_name == \"None.\":\n                        return \"\\nNo commands were executed.\\n\"\n                    else:\n                        return f\"\\Command not recognized: `{command_name}`.\"\n        else:\n            return \"\\nNo commands were executed.\\n\"", ""]}
{"filename": "agixt/Providers.py", "chunked_list": ["import importlib\nimport subprocess\nimport pkg_resources\nimport glob\nimport os\nimport inspect\n\n\ndef get_providers():\n    providers = []\n    for provider in glob.glob(\"providers/*.py\"):\n        if \"__init__.py\" not in provider:\n            providers.append(os.path.splitext(os.path.basename(provider))[0])\n    return providers", "def get_providers():\n    providers = []\n    for provider in glob.glob(\"providers/*.py\"):\n        if \"__init__.py\" not in provider:\n            providers.append(os.path.splitext(os.path.basename(provider))[0])\n    return providers\n\n\ndef get_provider_options(provider_name):\n    provider_name = provider_name.lower()\n    module = importlib.import_module(f\"providers.{provider_name}\")\n    provider_class = getattr(module, f\"{provider_name.capitalize()}Provider\")\n    signature = inspect.signature(provider_class.__init__)\n    options = {\n        name: param.default if param.default is not inspect.Parameter.empty else None\n        for name, param in signature.parameters.items()\n        if name != \"self\" and name != \"kwargs\"\n    }\n    options[\"provider\"] = provider_name\n    return options", "def get_provider_options(provider_name):\n    provider_name = provider_name.lower()\n    module = importlib.import_module(f\"providers.{provider_name}\")\n    provider_class = getattr(module, f\"{provider_name.capitalize()}Provider\")\n    signature = inspect.signature(provider_class.__init__)\n    options = {\n        name: param.default if param.default is not inspect.Parameter.empty else None\n        for name, param in signature.parameters.items()\n        if name != \"self\" and name != \"kwargs\"\n    }\n    options[\"provider\"] = provider_name\n    return options", "\n\nclass Providers:\n    def __init__(self, name, **kwargs):\n        try:\n            module = importlib.import_module(f\"providers.{name}\")\n            provider_class = getattr(module, f\"{name.capitalize()}Provider\")\n            self.instance = provider_class(**kwargs)\n\n            # Install the requirements if any\n            self.install_requirements()\n\n        except (ModuleNotFoundError, AttributeError) as e:\n            raise AttributeError(f\"module {__name__} has no attribute {name}\") from e\n\n    def __getattr__(self, attr):\n        return getattr(self.instance, attr)\n\n    def get_providers(self):\n        providers = []\n        for provider in glob.glob(\"providers/*.py\"):\n            if \"__init__.py\" not in provider:\n                providers.append(os.path.splitext(os.path.basename(provider))[0])\n        return providers\n\n    def install_requirements(self):\n        requirements = getattr(self.instance, \"requirements\", [])\n        installed_packages = {pkg.key: pkg.version for pkg in pkg_resources.working_set}\n        for requirement in requirements:\n            if requirement.lower() not in installed_packages:\n                subprocess.run([\"pip\", \"install\", requirement], check=True)", "\n\ndef __getattr__(name):\n    return Providers(name)\n"]}
{"filename": "agixt/Extensions.py", "chunked_list": ["import importlib\nimport os\nimport glob\nfrom inspect import signature, Parameter\nimport logging\nimport inspect\n\n\nclass Extensions:\n    def __init__(self, agent_config=None, load_commands_flag: bool = True):\n        self.agent_config = agent_config\n        if load_commands_flag:\n            self.commands = self.load_commands()\n        else:\n            self.commands = []\n        if agent_config != None:\n            if \"commands\" not in self.agent_config:\n                self.agent_config[\"commands\"] = {}\n            if self.agent_config[\"commands\"] == None:\n                self.agent_config[\"commands\"] = {}\n            self.available_commands = self.get_available_commands()\n\n    def get_available_commands(self):\n        if self.commands == []:\n            return []\n        available_commands = []\n        for command in self.commands:\n            friendly_name, command_module, command_name, command_args = command\n            if (\n                \"commands\" in self.agent_config\n                and friendly_name in self.agent_config[\"commands\"]\n            ):\n                if (\n                    self.agent_config[\"commands\"][friendly_name] == \"true\"\n                    or self.agent_config[\"commands\"][friendly_name] == True\n                ):\n                    # Add command to list of commands to return\n                    available_commands.append(\n                        {\n                            \"friendly_name\": friendly_name,\n                            \"name\": command_name,\n                            \"args\": command_args,\n                            \"enabled\": True,\n                        }\n                    )\n        return available_commands\n\n    def get_enabled_commands(self):\n        enabled_commands = []\n        for command in self.available_commands:\n            if command[\"enabled\"]:\n                enabled_commands.append(command)\n        return enabled_commands\n\n    def get_command_args(self, command_name: str):\n        extensions = self.get_extensions()\n        for extension in extensions:\n            for command in extension[\"commands\"]:\n                if command[\"friendly_name\"] == command_name:\n                    return command[\"command_args\"]\n        return {}\n\n    def load_commands(self):\n        try:\n            settings = self.agent_config[\"settings\"]\n        except:\n            settings = {}\n        commands = []\n        command_files = glob.glob(\"extensions/*.py\")\n        for command_file in command_files:\n            module_name = os.path.splitext(os.path.basename(command_file))[0]\n            module = importlib.import_module(f\"extensions.{module_name}\")\n            if issubclass(getattr(module, module_name), Extensions):\n                command_class = getattr(module, module_name)(**settings)\n                if hasattr(command_class, \"commands\"):\n                    for (\n                        command_name,\n                        command_function,\n                    ) in command_class.commands.items():\n                        params = self.get_command_params(command_function)\n                        # Store the module along with the function name\n                        commands.append(\n                            (\n                                command_name,\n                                getattr(module, module_name),\n                                command_function.__name__,\n                                params,\n                            )\n                        )\n        # Return the commands list\n        logging.debug(f\"loaded commands: {commands}\")\n        return commands\n\n    def get_extension_settings(self):\n        settings = {}\n        command_files = glob.glob(\"extensions/*.py\")\n        for command_file in command_files:\n            module_name = os.path.splitext(os.path.basename(command_file))[0]\n            module = importlib.import_module(f\"extensions.{module_name}\")\n            if issubclass(getattr(module, module_name), Extensions):\n                command_class = getattr(module, module_name)()\n                params = self.get_command_params(command_class.__init__)\n                # Remove self and kwargs from params\n                if \"self\" in params:\n                    del params[\"self\"]\n                if \"kwargs\" in params:\n                    del params[\"kwargs\"]\n                if params != {}:\n                    settings[module_name] = params\n        return settings\n\n    def find_command(self, command_name: str):\n        for name, module, function_name, params in self.commands:\n            if name == command_name:\n                command_function = getattr(module, function_name)\n                return command_function, module, params  # Updated return statement\n        return None, None, None  # Updated return statement\n\n    def get_commands_list(self):\n        self.commands = self.load_commands()\n        commands_list = [command_name for command_name, _, _ in self.commands]\n        return commands_list\n\n    async def execute_command(self, command_name: str, command_args: dict = None):\n        command_function, module, params = self.find_command(command_name=command_name)\n        logging.info(\n            f\"Executing command: {command_name} with args: {command_args}. Command Function: {command_function}\"\n        )\n        if command_function is None:\n            logging.error(f\"Command {command_name} not found\")\n            return False\n        for param in params:\n            if param not in command_args:\n                if param != \"self\" and param != \"kwargs\":\n                    command_args[param] = None\n        args = command_args.copy()\n        for param in command_args:\n            if param not in params:\n                del args[param]\n        try:\n            output = await getattr(module(), command_function.__name__)(**args)\n        except Exception as e:\n            output = f\"Error: {str(e)}\"\n        logging.info(f\"Command Output: {output}\")\n        return output\n\n    def get_command_params(self, func):\n        params = {}\n        sig = signature(func)\n        for name, param in sig.parameters.items():\n            if name == \"self\":\n                continue\n            if param.default == Parameter.empty:\n                params[name] = \"\"\n            else:\n                params[name] = param.default\n        return params\n\n    def get_extensions(self):\n        commands = []\n        command_files = glob.glob(\"extensions/*.py\")\n        for command_file in command_files:\n            module_name = os.path.splitext(os.path.basename(command_file))[0]\n            module = importlib.import_module(f\"extensions.{module_name}\")\n            command_class = getattr(module, module_name.lower())()\n            extension_name = command_file.split(\"/\")[-1].split(\".\")[0]\n            extension_name = extension_name.replace(\"_\", \" \").title()\n            constructor = inspect.signature(command_class.__init__)\n            params = constructor.parameters\n            extension_settings = [\n                name for name in params if name != \"self\" and name != \"kwargs\"\n            ]\n            extension_commands = []\n            if hasattr(command_class, \"commands\"):\n                try:\n                    for (\n                        command_name,\n                        command_function,\n                    ) in command_class.commands.items():\n                        params = self.get_command_params(command_function)\n                        extension_commands.append(\n                            {\n                                \"friendly_name\": command_name,\n                                \"command_name\": command_function.__name__,\n                                \"command_args\": params,\n                            }\n                        )\n                except Exception as e:\n                    logging.error(f\"Error getting commands: {e}\")\n            commands.append(\n                {\n                    \"extension_name\": extension_name,\n                    \"description\": extension_name,\n                    \"settings\": extension_settings,\n                    \"commands\": extension_commands,\n                }\n            )\n        return commands", "class Extensions:\n    def __init__(self, agent_config=None, load_commands_flag: bool = True):\n        self.agent_config = agent_config\n        if load_commands_flag:\n            self.commands = self.load_commands()\n        else:\n            self.commands = []\n        if agent_config != None:\n            if \"commands\" not in self.agent_config:\n                self.agent_config[\"commands\"] = {}\n            if self.agent_config[\"commands\"] == None:\n                self.agent_config[\"commands\"] = {}\n            self.available_commands = self.get_available_commands()\n\n    def get_available_commands(self):\n        if self.commands == []:\n            return []\n        available_commands = []\n        for command in self.commands:\n            friendly_name, command_module, command_name, command_args = command\n            if (\n                \"commands\" in self.agent_config\n                and friendly_name in self.agent_config[\"commands\"]\n            ):\n                if (\n                    self.agent_config[\"commands\"][friendly_name] == \"true\"\n                    or self.agent_config[\"commands\"][friendly_name] == True\n                ):\n                    # Add command to list of commands to return\n                    available_commands.append(\n                        {\n                            \"friendly_name\": friendly_name,\n                            \"name\": command_name,\n                            \"args\": command_args,\n                            \"enabled\": True,\n                        }\n                    )\n        return available_commands\n\n    def get_enabled_commands(self):\n        enabled_commands = []\n        for command in self.available_commands:\n            if command[\"enabled\"]:\n                enabled_commands.append(command)\n        return enabled_commands\n\n    def get_command_args(self, command_name: str):\n        extensions = self.get_extensions()\n        for extension in extensions:\n            for command in extension[\"commands\"]:\n                if command[\"friendly_name\"] == command_name:\n                    return command[\"command_args\"]\n        return {}\n\n    def load_commands(self):\n        try:\n            settings = self.agent_config[\"settings\"]\n        except:\n            settings = {}\n        commands = []\n        command_files = glob.glob(\"extensions/*.py\")\n        for command_file in command_files:\n            module_name = os.path.splitext(os.path.basename(command_file))[0]\n            module = importlib.import_module(f\"extensions.{module_name}\")\n            if issubclass(getattr(module, module_name), Extensions):\n                command_class = getattr(module, module_name)(**settings)\n                if hasattr(command_class, \"commands\"):\n                    for (\n                        command_name,\n                        command_function,\n                    ) in command_class.commands.items():\n                        params = self.get_command_params(command_function)\n                        # Store the module along with the function name\n                        commands.append(\n                            (\n                                command_name,\n                                getattr(module, module_name),\n                                command_function.__name__,\n                                params,\n                            )\n                        )\n        # Return the commands list\n        logging.debug(f\"loaded commands: {commands}\")\n        return commands\n\n    def get_extension_settings(self):\n        settings = {}\n        command_files = glob.glob(\"extensions/*.py\")\n        for command_file in command_files:\n            module_name = os.path.splitext(os.path.basename(command_file))[0]\n            module = importlib.import_module(f\"extensions.{module_name}\")\n            if issubclass(getattr(module, module_name), Extensions):\n                command_class = getattr(module, module_name)()\n                params = self.get_command_params(command_class.__init__)\n                # Remove self and kwargs from params\n                if \"self\" in params:\n                    del params[\"self\"]\n                if \"kwargs\" in params:\n                    del params[\"kwargs\"]\n                if params != {}:\n                    settings[module_name] = params\n        return settings\n\n    def find_command(self, command_name: str):\n        for name, module, function_name, params in self.commands:\n            if name == command_name:\n                command_function = getattr(module, function_name)\n                return command_function, module, params  # Updated return statement\n        return None, None, None  # Updated return statement\n\n    def get_commands_list(self):\n        self.commands = self.load_commands()\n        commands_list = [command_name for command_name, _, _ in self.commands]\n        return commands_list\n\n    async def execute_command(self, command_name: str, command_args: dict = None):\n        command_function, module, params = self.find_command(command_name=command_name)\n        logging.info(\n            f\"Executing command: {command_name} with args: {command_args}. Command Function: {command_function}\"\n        )\n        if command_function is None:\n            logging.error(f\"Command {command_name} not found\")\n            return False\n        for param in params:\n            if param not in command_args:\n                if param != \"self\" and param != \"kwargs\":\n                    command_args[param] = None\n        args = command_args.copy()\n        for param in command_args:\n            if param not in params:\n                del args[param]\n        try:\n            output = await getattr(module(), command_function.__name__)(**args)\n        except Exception as e:\n            output = f\"Error: {str(e)}\"\n        logging.info(f\"Command Output: {output}\")\n        return output\n\n    def get_command_params(self, func):\n        params = {}\n        sig = signature(func)\n        for name, param in sig.parameters.items():\n            if name == \"self\":\n                continue\n            if param.default == Parameter.empty:\n                params[name] = \"\"\n            else:\n                params[name] = param.default\n        return params\n\n    def get_extensions(self):\n        commands = []\n        command_files = glob.glob(\"extensions/*.py\")\n        for command_file in command_files:\n            module_name = os.path.splitext(os.path.basename(command_file))[0]\n            module = importlib.import_module(f\"extensions.{module_name}\")\n            command_class = getattr(module, module_name.lower())()\n            extension_name = command_file.split(\"/\")[-1].split(\".\")[0]\n            extension_name = extension_name.replace(\"_\", \" \").title()\n            constructor = inspect.signature(command_class.__init__)\n            params = constructor.parameters\n            extension_settings = [\n                name for name in params if name != \"self\" and name != \"kwargs\"\n            ]\n            extension_commands = []\n            if hasattr(command_class, \"commands\"):\n                try:\n                    for (\n                        command_name,\n                        command_function,\n                    ) in command_class.commands.items():\n                        params = self.get_command_params(command_function)\n                        extension_commands.append(\n                            {\n                                \"friendly_name\": command_name,\n                                \"command_name\": command_function.__name__,\n                                \"command_args\": params,\n                            }\n                        )\n                except Exception as e:\n                    logging.error(f\"Error getting commands: {e}\")\n            commands.append(\n                {\n                    \"extension_name\": extension_name,\n                    \"description\": extension_name,\n                    \"settings\": extension_settings,\n                    \"commands\": extension_commands,\n                }\n            )\n        return commands", ""]}
{"filename": "agixt/__init__.py", "chunked_list": ["from agixtsdk import AGiXTSDK\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\nApiClient = AGiXTSDK(\n    base_uri=\"http://localhost:7437\", api_key=os.getenv(\"AGIXT_API_KEY\")\n)\n", ""]}
{"filename": "agixt/Embedding.py", "chunked_list": ["import requests\nimport inspect\nfrom chromadb.utils import embedding_functions\nfrom chromadb.api.types import Documents, EmbeddingFunction, Embeddings\nfrom semantic_kernel.connectors.ai.hugging_face import HuggingFaceTextEmbedding\nfrom semantic_kernel.connectors.ai.open_ai import (\n    AzureTextEmbedding,\n    OpenAITextEmbedding,\n)\nimport logging", ")\nimport logging\nimport spacy\n\n\nclass LlamacppEmbeddingFunction(EmbeddingFunction):\n    def __init__(self, api_host: str):\n        self._api_host = api_host\n        self._session = requests.Session()\n\n    def __call__(self, texts: Documents) -> Embeddings:\n        response = self._session.post(\n            self._api_url, json={\"content\": texts, \"threads\": 5}\n        ).json()\n        if \"data\" in response:\n            if \"embedding\" in response[\"data\"]:\n                return response[\"data\"][\"embedding\"]\n        return {}", "\n\nclass Embedding:\n    def __init__(self, AGENT_CONFIG=None):\n        self.AGENT_CONFIG = AGENT_CONFIG\n\n    async def get_embedder(self):\n        try:\n            embedder = self.AGENT_CONFIG[\"settings\"][\"embedder\"]\n            embed, chunk_size = await self.__getattribute__(embedder)()\n        except:\n            embed, chunk_size = await self.default()\n            logging.info(\"Embedder not found, using default embedder\")\n        return embed, chunk_size\n\n    async def embed_text(self, text):\n        embed, chunk_size = await self.get_embedder()\n        return await embed(text)\n\n    async def default(self):\n        chunk_size = 128\n        embed = HuggingFaceTextEmbedding(\n            model_id=\"all-mpnet-base-v2\", log=logging\n        ).generate_embeddings_async\n        return embed, chunk_size\n\n    async def large_local(self):\n        chunk_size = 500\n        embed = HuggingFaceTextEmbedding(\n            model_id=\"gtr-t5-large\", log=logging\n        ).generate_embeddings_async\n        return embed, chunk_size\n\n    async def azure(self):\n        chunk_size = 1000\n        embed = AzureTextEmbedding(\n            deployment_name=self.AGENT_CONFIG[\"settings\"][\"AZURE_DEPLOYMENT_NAME\"],\n            endpoint=self.AGENT_CONFIG[\"settings\"][\"AZURE_OPENAI_ENDPOINT\"],\n            api_key=self.AGENT_CONFIG[\"settings\"][\"AZURE_API_KEY\"],\n            logger=logging,\n        ).generate_embeddings_async\n        return embed, chunk_size\n\n    async def openai(self):\n        chunk_size = 1000\n        if \"API_URI\" in self.AGENT_CONFIG[\"settings\"]:\n            if self.AGENT_CONFIG[\"settings\"][\"API_URI\"] != \"\":\n                api_base = self.AGENT_CONFIG[\"settings\"][\"API_URI\"]\n            else:\n                api_base = None\n        else:\n            api_base = None\n        embed = OpenAITextEmbedding(\n            model_id=\"text-embedding-ada-002\",\n            api_key=self.AGENT_CONFIG[\"settings\"][\"OPENAI_API_KEY\"],\n            endpoint=api_base,\n            log=logging,\n        ).generate_embeddings_async\n        return embed, chunk_size\n\n    async def google_palm(self):\n        chunk_size = 1000\n        embed = embedding_functions.GooglePalmEmbeddingFunction(\n            api_key=self.AGENT_CONFIG[\"settings\"][\"GOOGLE_API_KEY\"],\n        )\n        return embed, chunk_size\n\n    async def google_vertex(self):\n        chunk_size = 1000\n        embed = embedding_functions.GoogleVertexEmbeddingFunction(\n            api_key=self.AGENT_CONFIG[\"settings\"][\"GOOGLE_API_KEY\"],\n            project_id=self.AGENT_CONFIG[\"settings\"][\"GOOGLE_PROJECT_ID\"],\n        )\n        return embed, chunk_size\n\n    async def cohere(self):\n        chunk_size = 500\n        embed = embedding_functions.CohereEmbeddingFunction(\n            api_key=self.AGENT_CONFIG[\"settings\"][\"COHERE_API_KEY\"],\n        )\n        return embed, chunk_size\n\n    async def llamacpp(self):\n        chunk_size = 250\n        embed = LlamacppEmbeddingFunction(\n            model_name=self.AGENT_CONFIG[\"settings\"][\"EMBEDDING_URI\"],\n        )\n        return embed, chunk_size", "\n\ndef get_embedding_providers():\n    return [\n        func\n        for func, _ in inspect.getmembers(Embedding, predicate=inspect.isfunction)\n        if not func.startswith(\"__\")\n    ]\n\n\ndef nlp(text):\n    try:\n        sp = spacy.load(\"en_core_web_sm\")\n    except:\n        spacy.cli.download(\"en_core_web_sm\")\n        sp = spacy.load(\"en_core_web_sm\")\n    sp.max_length = 99999999999999999999999\n    return sp(text)", "\n\ndef nlp(text):\n    try:\n        sp = spacy.load(\"en_core_web_sm\")\n    except:\n        spacy.cli.download(\"en_core_web_sm\")\n        sp = spacy.load(\"en_core_web_sm\")\n    sp.max_length = 99999999999999999999999\n    return sp(text)", "\n\ndef get_tokens(text):\n    return len(nlp(text))\n"]}
{"filename": "agixt/Memories.py", "chunked_list": ["from typing import List\nimport os\nfrom hashlib import sha256\nfrom Embedding import Embedding, get_tokens, nlp\nfrom datetime import datetime\nfrom collections import Counter\nimport pandas as pd\nimport docx2txt\nimport pdfplumber\nfrom playwright.async_api import async_playwright", "import pdfplumber\nfrom playwright.async_api import async_playwright\nfrom semantic_kernel.connectors.memory.chroma import ChromaMemoryStore\nfrom semantic_kernel.memory.memory_record import MemoryRecord\nfrom chromadb.config import Settings\nfrom bs4 import BeautifulSoup\nimport logging\nimport asyncio\nimport sys\n\nif sys.platform == \"win32\":\n    asyncio.set_event_loop_policy(asyncio.WindowsProactorEventLoopPolicy())", "import sys\n\nif sys.platform == \"win32\":\n    asyncio.set_event_loop_policy(asyncio.WindowsProactorEventLoopPolicy())\n\n\nclass Memories:\n    def __init__(self, agent_name: str = \"AGiXT\", agent_config=None):\n        self.agent_name = agent_name\n        self.agent_config = agent_config\n        self.chroma_client = None\n        self.collection = None\n        self.chunk_size = 128\n        memories_dir = os.path.join(os.getcwd(), \"agents\", self.agent_name, \"memories\")\n        self.chroma_client = ChromaMemoryStore(\n            persist_directory=memories_dir,\n            client_settings=Settings(\n                chroma_db_impl=\"chromadb.db.duckdb.PersistentDuckDB\",\n                persist_directory=memories_dir,\n                anonymized_telemetry=False,\n            ),\n        )\n\n    async def get_embedder(self):\n        embedder, chunk_size = await Embedding(\n            AGENT_CONFIG=self.agent_config\n        ).get_embedder()\n        return embedder, chunk_size\n\n    async def get_collection(self):\n        try:\n            memories_exist = await self.chroma_client.does_collection_exist_async(\n                \"memories\"\n            )\n            if not memories_exist:\n                await self.chroma_client.create_collection_async(\n                    collection_name=\"memories\"\n                )\n                memories = await self.chroma_client.get_collection_async(\n                    collection_name=\"memories\"\n                )\n            else:\n                memories = await self.chroma_client.get_collection_async(\n                    collection_name=\"memories\"\n                )\n            return memories\n        except Exception as e:\n            raise RuntimeError(f\"Unable to initialize chroma client: {e}\")\n\n    async def store_result(\n        self, input: str, result: str, external_source_name: str = None\n    ):\n        if result:\n            embedder, chunk_size = await self.get_embedder()\n            collection = await self.get_collection()\n            if not isinstance(result, str):\n                result = str(result)\n            chunks = await self.chunk_content(content=result, chunk_size=chunk_size)\n            for chunk in chunks:\n                record = MemoryRecord(\n                    is_reference=False,\n                    id=sha256(\n                        (chunk + datetime.now().isoformat()).encode()\n                    ).hexdigest(),\n                    text=chunk,\n                    timestamp=datetime.now().isoformat(),\n                    description=input,\n                    external_source_name=external_source_name,  # URL or File path\n                    embedding=await embedder(chunk),\n                    additional_metadata=chunk,\n                )\n                try:\n                    await self.chroma_client.upsert_async(\n                        collection_name=\"memories\",\n                        record=record,\n                    )\n                except Exception as e:\n                    logging.info(f\"Failed to store memory: {e}\")\n            self.chroma_client._client.persist()\n\n    async def context_agent(self, query: str, top_results_num: int) -> List[str]:\n        embedder, chunk_size = await self.get_embedder()\n        collection = await self.get_collection()\n        if collection == None:\n            return []\n        embed = await Embedding(AGENT_CONFIG=self.agent_config).embed_text(text=query)\n        try:\n            results = await self.chroma_client.get_nearest_matches_async(\n                collection_name=\"memories\",\n                embedding=embed,\n                limit=top_results_num,\n                min_relevance_score=0.0,\n            )\n        except:\n            return \"\"\n        context = []\n        for memory, score in results:\n            context.append(memory._text)\n        trimmed_context = []\n        total_tokens = 0\n        for item in context:\n            item_tokens = get_tokens(item)\n            if total_tokens + item_tokens <= chunk_size:\n                trimmed_context.append(item)\n                total_tokens += item_tokens\n            else:\n                break\n        logging.info(f\"Context Injected: {trimmed_context}\")\n        context_str = \"\\n\".join(trimmed_context)\n        response = (\n            f\"The user's input causes you remember these things:\\n {context_str} \\n\\n\"\n        )\n        return response\n\n    def score_chunk(self, chunk: str, keywords: set):\n        \"\"\"Score a chunk based on the number of query keywords it contains.\"\"\"\n        chunk_counter = Counter(chunk.split())\n        score = sum(chunk_counter[keyword] for keyword in keywords)\n        return score\n\n    async def chunk_content(\n        self, content: str, chunk_size: int, overlap: int = 2\n    ) -> List[str]:\n        doc = nlp(content)\n        sentences = list(doc.sents)\n        content_chunks = []\n        chunk = []\n        chunk_len = 0\n        keywords = [\n            token.text for token in doc if token.pos_ in {\"NOUN\", \"PROPN\", \"VERB\"}\n        ]\n\n        for i, sentence in enumerate(sentences):\n            sentence_tokens = len(sentence)\n            if chunk_len + sentence_tokens > chunk_size and chunk:\n                chunk_text = \" \".join(token.text for token in chunk)\n                content_chunks.append(\n                    (self.score_chunk(chunk_text, keywords), chunk_text)\n                )\n                chunk = list(sentences[i - overlap : i]) if i - overlap >= 0 else []\n                chunk_len = sum(len(s) for s in chunk)\n            chunk.extend(sentence)\n            chunk_len += sentence_tokens\n\n        if chunk:\n            chunk_text = \" \".join(token.text for token in chunk)\n            content_chunks.append((self.score_chunk(chunk_text, keywords), chunk_text))\n\n        # Sort the chunks by their score in descending order before returning them\n        content_chunks.sort(key=lambda x: x[0], reverse=True)\n        return [chunk_text for score, chunk_text in content_chunks]\n\n    async def read_file(self, file_path: str):\n        base_path = os.path.join(os.getcwd(), \"WORKSPACE\")\n        file_path = os.path.normpath(os.path.join(base_path, file_path))\n        if not file_path.startswith(base_path):\n            raise Exception(\"Path given not allowed\")\n        try:\n            # If file extension is pdf, convert to text\n            if file_path.endswith(\".pdf\"):\n                with pdfplumber.open(file_path) as pdf:\n                    content = \"\\n\".join([page.extract_text() for page in pdf.pages])\n            # If file extension is xls, convert to csv\n            elif file_path.endswith(\".xls\") or file_path.endswith(\".xlsx\"):\n                content = pd.read_excel(file_path).to_csv()\n            # If file extension is doc, convert to text\n            elif file_path.endswith(\".doc\") or file_path.endswith(\".docx\"):\n                content = docx2txt.process(file_path)\n            # TODO: If file is an image, classify it in text.\n            # Otherwise just read the file\n            else:\n                with open(file_path, \"r\") as f:\n                    content = f.read()\n            await self.store_result(\n                input=file_path, result=content, external_source_name=file_path\n            )\n            return True\n        except:\n            return False\n\n    async def read_website(self, url):\n        # try:\n        async with async_playwright() as p:\n            browser = await p.chromium.launch()\n            context = await browser.new_context()\n            page = await context.new_page()\n            await page.goto(url)\n            content = await page.content()\n\n            # Scrape links and their titles\n            links = await page.query_selector_all(\"a\")\n            link_list = []\n            for link in links:\n                title = await page.evaluate(\"(link) => link.textContent\", link)\n                href = await page.evaluate(\"(link) => link.href\", link)\n                link_list.append((title, href))\n\n            await browser.close()\n            soup = BeautifulSoup(content, \"html.parser\")\n            text_content = soup.get_text()\n            text_content = \" \".join(text_content.split())\n            if text_content:\n                await self.store_result(\n                    input=url, result=text_content, external_source_name=url\n                )\n            return text_content, link_list", "        # except:\n        #    return None, None\n"]}
{"filename": "agixt/DBConnection.py", "chunked_list": ["import os\nimport uuid\nfrom sqlalchemy import (\n    create_engine,\n    Column,\n    Text,\n    String,\n    Integer,\n    ForeignKey,\n    DateTime,", "    ForeignKey,\n    DateTime,\n    Boolean,\n)\nfrom sqlalchemy.orm import sessionmaker, relationship, declarative_base\nfrom sqlalchemy.dialects.postgresql import UUID\nfrom sqlalchemy.sql import text\nfrom dotenv import load_dotenv\n\nload_dotenv()", "\nload_dotenv()\n\n\nusername = os.getenv(\"POSTGRES_USER\", \"postgres\")\npassword = os.getenv(\"POSTGRES_PASSWORD\", \"postgres\")\nserver = os.getenv(\"POSTGRES_SERVER\", \"localhost\")\nport = os.getenv(\"POSTGRES_PORT\", \"5432\")\ndatabase_name = os.getenv(\"POSTGRES_DB\", \"postgres\")\ndb_connected = True if os.getenv(\"DB_CONNECTED\", \"false\").lower() == \"true\" else False", "database_name = os.getenv(\"POSTGRES_DB\", \"postgres\")\ndb_connected = True if os.getenv(\"DB_CONNECTED\", \"false\").lower() == \"true\" else False\nBase = declarative_base()\nif db_connected:\n    try:\n        engine = create_engine(\n            f\"postgresql://{username}:{password}@{server}:{port}/{database_name}\"\n        )\n    except Exception as e:\n        print(f\"Error connecting to database: {e}\")\n    Session = sessionmaker(bind=engine)\n    session = Session()\n    connection = engine.connect()\nelse:\n    session = None", "\n\nclass Provider(Base):\n    __tablename__ = \"provider\"\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    name = Column(Text, nullable=False)\n    provider_settings = relationship(\"ProviderSetting\", backref=\"provider\")\n\n\nclass ProviderSetting(Base):\n    __tablename__ = \"provider_setting\"\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    provider_id = Column(UUID(as_uuid=True), ForeignKey(\"provider.id\"), nullable=False)\n    name = Column(Text, nullable=False)\n    value = Column(\n        Text\n    )  # Add the 'value' column without the 'nullable=False' constraint", "\nclass ProviderSetting(Base):\n    __tablename__ = \"provider_setting\"\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    provider_id = Column(UUID(as_uuid=True), ForeignKey(\"provider.id\"), nullable=False)\n    name = Column(Text, nullable=False)\n    value = Column(\n        Text\n    )  # Add the 'value' column without the 'nullable=False' constraint\n", "\n\nclass AgentProviderSetting(Base):\n    __tablename__ = \"agent_provider_setting\"\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    provider_setting_id = Column(\n        UUID(as_uuid=True), ForeignKey(\"provider_setting.id\"), nullable=False\n    )\n    agent_provider_id = Column(\n        UUID(as_uuid=True), ForeignKey(\"agent_provider.id\"), nullable=False\n    )\n    value = Column(Text, nullable=False)", "\n\nclass AgentProvider(Base):\n    __tablename__ = \"agent_provider\"\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    provider_id = Column(UUID(as_uuid=True), ForeignKey(\"provider.id\"), nullable=False)\n    agent_id = Column(UUID(as_uuid=True), ForeignKey(\"agent.id\"), nullable=False)\n    settings = relationship(\"AgentProviderSetting\", backref=\"agent_provider\")\n\n\nclass Agent(Base):\n    __tablename__ = \"agent\"\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    name = Column(Text, nullable=False)\n    provider_id = Column(\n        UUID(as_uuid=True), ForeignKey(\"provider.id\"), nullable=True, default=None\n    )\n    settings = relationship(\"AgentSetting\", backref=\"agent\")  # One-to-many relationship", "\n\nclass Agent(Base):\n    __tablename__ = \"agent\"\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    name = Column(Text, nullable=False)\n    provider_id = Column(\n        UUID(as_uuid=True), ForeignKey(\"provider.id\"), nullable=True, default=None\n    )\n    settings = relationship(\"AgentSetting\", backref=\"agent\")  # One-to-many relationship", "\n\nclass Command(Base):\n    __tablename__ = \"command\"\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    name = Column(Text, nullable=False)\n    extension_id = Column(UUID(as_uuid=True), ForeignKey(\"extension.id\"))\n    extension = relationship(\"Extension\", backref=\"commands\")\n\n\nclass AgentCommand(Base):\n    __tablename__ = \"agent_command\"\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    command_id = Column(UUID(as_uuid=True), ForeignKey(\"command.id\"), nullable=False)\n    agent_id = Column(UUID(as_uuid=True), ForeignKey(\"agent.id\"), nullable=False)\n    state = Column(Boolean, nullable=False)\n    command = relationship(\"Command\")  # Add this line to define the relationship", "\n\nclass AgentCommand(Base):\n    __tablename__ = \"agent_command\"\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    command_id = Column(UUID(as_uuid=True), ForeignKey(\"command.id\"), nullable=False)\n    agent_id = Column(UUID(as_uuid=True), ForeignKey(\"agent.id\"), nullable=False)\n    state = Column(Boolean, nullable=False)\n    command = relationship(\"Command\")  # Add this line to define the relationship\n", "\n\nclass Conversation(Base):\n    __tablename__ = \"conversation\"\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    agent_id = Column(UUID(as_uuid=True), ForeignKey(\"agent.id\"), nullable=False)\n    name = Column(Text, nullable=False)\n\n\nclass Message(Base):\n    __tablename__ = \"message\"\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    role = Column(Text, nullable=False)\n    content = Column(Text, nullable=False)\n    timestamp = Column(DateTime, server_default=text(\"now()\"))\n    conversation_id = Column(\n        UUID(as_uuid=True), ForeignKey(\"conversation.id\"), nullable=False\n    )", "\nclass Message(Base):\n    __tablename__ = \"message\"\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    role = Column(Text, nullable=False)\n    content = Column(Text, nullable=False)\n    timestamp = Column(DateTime, server_default=text(\"now()\"))\n    conversation_id = Column(\n        UUID(as_uuid=True), ForeignKey(\"conversation.id\"), nullable=False\n    )", "\n\nclass Setting(Base):\n    __tablename__ = \"setting\"\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    name = Column(Text, nullable=False)\n    extension_id = Column(UUID(as_uuid=True), ForeignKey(\"extension.id\"))\n    value = Column(Text)\n\n\nclass AgentSetting(Base):\n    __tablename__ = \"agent_setting\"\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    agent_id = Column(UUID(as_uuid=True), ForeignKey(\"agent.id\"), nullable=False)\n    name = Column(String)\n    value = Column(String)", "\n\nclass AgentSetting(Base):\n    __tablename__ = \"agent_setting\"\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    agent_id = Column(UUID(as_uuid=True), ForeignKey(\"agent.id\"), nullable=False)\n    name = Column(String)\n    value = Column(String)\n\n\nclass Chain(Base):\n    __tablename__ = \"chain\"\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    name = Column(Text, nullable=False)\n    description = Column(Text, nullable=True)\n    steps = relationship(\n        \"ChainStep\",\n        backref=\"chain\",\n        cascade=\"all, delete\",  # Add the cascade option for deleting steps\n        passive_deletes=True,\n        foreign_keys=\"ChainStep.chain_id\",\n    )\n    target_steps = relationship(\n        \"ChainStep\", backref=\"target_chain\", foreign_keys=\"ChainStep.target_chain_id\"\n    )", "\n\nclass Chain(Base):\n    __tablename__ = \"chain\"\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    name = Column(Text, nullable=False)\n    description = Column(Text, nullable=True)\n    steps = relationship(\n        \"ChainStep\",\n        backref=\"chain\",\n        cascade=\"all, delete\",  # Add the cascade option for deleting steps\n        passive_deletes=True,\n        foreign_keys=\"ChainStep.chain_id\",\n    )\n    target_steps = relationship(\n        \"ChainStep\", backref=\"target_chain\", foreign_keys=\"ChainStep.target_chain_id\"\n    )", "\n\nclass ChainStep(Base):\n    __tablename__ = \"chain_step\"\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    chain_id = Column(\n        UUID(as_uuid=True), ForeignKey(\"chain.id\", ondelete=\"CASCADE\"), nullable=False\n    )\n    agent_id = Column(UUID(as_uuid=True), ForeignKey(\"agent.id\"), nullable=False)\n    prompt_type = Column(Text)  # Add the prompt_type field\n    prompt = Column(Text)  # Add the prompt field\n    target_chain_id = Column(\n        UUID(as_uuid=True), ForeignKey(\"chain.id\", ondelete=\"SET NULL\")\n    )\n    target_command_id = Column(\n        UUID(as_uuid=True), ForeignKey(\"command.id\", ondelete=\"SET NULL\")\n    )\n    target_prompt_id = Column(\n        UUID(as_uuid=True), ForeignKey(\"prompt.id\", ondelete=\"SET NULL\")\n    )\n    step_number = Column(Integer, nullable=False)\n    responses = relationship(\n        \"ChainStepResponse\", backref=\"chain_step\", cascade=\"all, delete\"\n    )\n\n    def add_response(self, content):\n        response = ChainStepResponse(content=content, chain_step=self)\n        session.add(response)\n        session.commit()", "\n\nclass ChainStepArgument(Base):\n    __tablename__ = \"chain_step_argument\"\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    argument_id = Column(UUID(as_uuid=True), ForeignKey(\"argument.id\"), nullable=False)\n    chain_step_id = Column(\n        UUID(as_uuid=True),\n        ForeignKey(\"chain_step.id\", ondelete=\"CASCADE\"),\n        nullable=False,  # Add the ondelete option\n    )\n    value = Column(Text, nullable=False)", "\n\nclass ChainStepResponse(Base):\n    __tablename__ = \"chain_step_response\"\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    chain_step_id = Column(\n        UUID(as_uuid=True),\n        ForeignKey(\"chain_step.id\", ondelete=\"CASCADE\"),\n        nullable=False,  # Add the ondelete option\n    )\n    timestamp = Column(DateTime, server_default=text(\"now()\"))\n    content = Column(Text, nullable=False)", "\n\nclass Extension(Base):\n    __tablename__ = \"extension\"\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    name = Column(Text, nullable=False)\n    description = Column(Text, nullable=True, default=\"\")\n\n\nclass Argument(Base):\n    __tablename__ = \"argument\"\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    prompt_id = Column(UUID(as_uuid=True), ForeignKey(\"prompt.id\"))\n    command_id = Column(UUID(as_uuid=True), ForeignKey(\"command.id\"))\n    chain_id = Column(UUID(as_uuid=True), ForeignKey(\"chain.id\"))\n    name = Column(Text, nullable=False)", "\nclass Argument(Base):\n    __tablename__ = \"argument\"\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    prompt_id = Column(UUID(as_uuid=True), ForeignKey(\"prompt.id\"))\n    command_id = Column(UUID(as_uuid=True), ForeignKey(\"command.id\"))\n    chain_id = Column(UUID(as_uuid=True), ForeignKey(\"chain.id\"))\n    name = Column(Text, nullable=False)\n\n\nclass PromptCategory(Base):\n    __tablename__ = \"prompt_category\"\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    name = Column(Text, nullable=False)\n    description = Column(Text, nullable=False)", "\n\nclass PromptCategory(Base):\n    __tablename__ = \"prompt_category\"\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    name = Column(Text, nullable=False)\n    description = Column(Text, nullable=False)\n\n\nclass Prompt(Base):\n    __tablename__ = \"prompt\"\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    prompt_category_id = Column(\n        UUID(as_uuid=True), ForeignKey(\"prompt_category.id\"), nullable=False\n    )\n    name = Column(Text, nullable=False)\n    description = Column(Text, nullable=False)\n    content = Column(Text, nullable=False)\n\n    prompt_category = relationship(\"PromptCategory\", backref=\"prompts\")", "\nclass Prompt(Base):\n    __tablename__ = \"prompt\"\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    prompt_category_id = Column(\n        UUID(as_uuid=True), ForeignKey(\"prompt_category.id\"), nullable=False\n    )\n    name = Column(Text, nullable=False)\n    description = Column(Text, nullable=False)\n    content = Column(Text, nullable=False)\n\n    prompt_category = relationship(\"PromptCategory\", backref=\"prompts\")", "\n\nif __name__ == \"__main__\":\n    Base.metadata.create_all(engine)\n"]}
{"filename": "agixt/db/History.py", "chunked_list": ["import os\nimport yaml\nfrom datetime import datetime\nfrom DBConnection import (\n    Conversation,\n    Message,\n    Agent,\n    session,\n)\n", ")\n\n\ndef export_conversation(agent_name, conversation_name=None):\n    agent = session.query(Agent).filter(Agent.name == agent_name).first()\n    if not agent:\n        print(f\"Agent '{agent_name}' not found in the database.\")\n        return\n    conversation_name = (\n        f\"{agent_name} History\" if not conversation_name else conversation_name\n    )\n    conversation = (\n        session.query(Conversation)\n        .filter(\n            Conversation.agent_id == agent.id,\n            Conversation.name == conversation_name,\n        )\n        .first()\n    )\n    if not conversation:\n        print(f\"No conversation found for agent '{agent_name}'.\")\n        return\n\n    messages = (\n        session.query(Message).filter(Message.conversation_id == conversation.id).all()\n    )\n\n    history = {\"interactions\": []}\n\n    for message in messages:\n        interaction = {\n            \"role\": message.role,\n            \"message\": message.content,\n            \"timestamp\": message.timestamp,\n        }\n        history[\"interactions\"].append(interaction)\n\n    agent_dir = os.path.join(\"agents\", agent_name)\n    os.makedirs(agent_dir, exist_ok=True)\n\n    history_file = os.path.join(agent_dir, \"history.yaml\")\n    with open(history_file, \"w\") as file:\n        yaml.dump(history, file)\n\n    print(f\"Exported conversation for agent '{agent_name}' to {history_file}.\")", "\n\ndef get_conversations(agent_name):\n    agent = session.query(Agent).filter(Agent.name == agent_name).first()\n    if not agent:\n        print(f\"Agent '{agent_name}' not found in the database.\")\n        return\n    conversations = (\n        session.query(Conversation)\n        .filter(\n            Conversation.agent_id == agent.id,\n        )\n        .all()\n    )\n    return [conversation.name for conversation in conversations]", "\n\ndef get_conversation(agent_name, conversation_name=None, limit=100, page=1):\n    agent = session.query(Agent).filter(Agent.name == agent_name).first()\n    if not agent:\n        print(f\"Agent '{agent_name}' not found in the database.\")\n        return\n    if not conversation_name:\n        conversation_name = f\"{agent_name} History\"\n    conversation = (\n        session.query(Conversation)\n        .filter(\n            Conversation.agent_id == agent.id,\n            Conversation.name == conversation_name,\n        )\n        .first()\n    )\n    if not conversation:\n        print(f\"No conversation found for agent '{agent_name}'.\")\n        return\n\n    messages = (\n        session.query(Message).filter(Message.conversation_id == conversation.id).all()\n    )\n    return_messages = []\n    for message in messages:\n        msg = {\n            \"role\": message.role,\n            \"message\": message.content,\n            \"timestamp\": message.timestamp,\n        }\n        return_messages.append(msg)\n    return return_messages", "\n\ndef new_conversation(agent_name, conversation_name):\n    agent = session.query(Agent).filter(Agent.name == agent_name).first()\n    if not agent:\n        print(f\"Agent '{agent_name}' not found in the database.\")\n        return\n\n    # Check if the conversation already exists for the agent\n    existing_conversation = (\n        session.query(Conversation)\n        .filter(\n            Conversation.agent_id == agent.id,\n            Conversation.name == conversation_name,\n        )\n        .first()\n    )\n    if existing_conversation:\n        print(\n            f\"Conversation '{conversation_name}' already exists for agent '{agent_name}'.\"\n        )\n        return\n\n    # Create a new conversation\n    conversation = Conversation(agent_id=agent.id, name=conversation_name)\n    session.add(conversation)\n    session.commit()\n\n    print(\n        f\"Created a new conversation: '{conversation_name}' for agent '{agent_name}'.\"\n    )", "\n\ndef log_interaction(agent_name, conversation_name, role, message):\n    agent = session.query(Agent).filter(Agent.name == agent_name).first()\n    if not agent:\n        print(f\"Agent '{agent_name}' not found in the database.\")\n        return\n\n    conversation = (\n        session.query(Conversation)\n        .filter(\n            Conversation.agent_id == agent.id,\n            Conversation.name == conversation_name,\n        )\n        .first()\n    )\n\n    if not conversation:\n        # Create a new conversation if it doesn't exist\n        conversation = Conversation(agent_id=agent.id, name=conversation_name)\n        session.add(conversation)\n        session.commit()\n\n    timestamp = datetime.now().strftime(\"%B %d, %Y %I:%M %p\")\n\n    new_message = Message(\n        role=role,\n        content=message,\n        timestamp=timestamp,\n        conversation_id=conversation.id,\n    )\n    session.add(new_message)\n    session.commit()\n\n    print(f\"Logged interaction: [{timestamp}] {role}: {message}\")", "\n\ndef delete_history(agent_name, conversation_name=None):\n    agent = session.query(Agent).filter(Agent.name == agent_name).first()\n    if not agent:\n        print(f\"Agent '{agent_name}' not found in the database.\")\n        return\n    if not conversation_name:\n        conversation_name = f\"{agent_name} History\"\n    conversation = (\n        session.query(Conversation)\n        .filter(\n            Conversation.agent_id == agent.id,\n            Conversation.name == conversation_name,\n        )\n        .first()\n    )\n    if not conversation:\n        print(f\"No conversation found for agent '{agent_name}'.\")\n        return\n\n    session.query(Message).filter(Message.conversation_id == conversation.id).delete()\n    session.query(Conversation).filter(Conversation.id == conversation.id).delete()\n    session.commit()\n\n    print(f\"Deleted conversation '{conversation_name}' for agent '{agent_name}'.\")", "\n\ndef delete_message(agent_name, conversation_name, message_id):\n    agent = session.query(Agent).filter(Agent.name == agent_name).first()\n    if not agent:\n        print(f\"Agent '{agent_name}' not found in the database.\")\n        return\n\n    conversation = (\n        session.query(Conversation)\n        .filter(\n            Conversation.agent_id == agent.id,\n            Conversation.name == conversation_name,\n        )\n        .first()\n    )\n\n    if not conversation:\n        print(f\"No conversation found for agent '{agent_name}'.\")\n        return\n\n    message = (\n        session.query(Message)\n        .filter(\n            Message.conversation_id == conversation.id,\n            Message.id == message_id,\n        )\n        .first()\n    )\n\n    if not message:\n        print(\n            f\"No message found with ID '{message_id}' in conversation '{conversation_name}'.\"\n        )\n        return\n\n    session.delete(message)\n    session.commit()\n\n    print(\n        f\"Deleted message with ID '{message_id}' from conversation '{conversation_name}'.\"\n    )", "\n\n# Example usage:\n# delete_history(\"Agent1\")\n# delete_message(\"Agent1\", \"Agent1 History\", 1)\n"]}
{"filename": "agixt/db/imports.py", "chunked_list": ["import os\nimport yaml\nimport json\nfrom DBConnection import (\n    session,\n    Provider,\n    ProviderSetting,\n    Conversation,\n    Message,\n    Agent,", "    Message,\n    Agent,\n    Prompt,\n    PromptCategory,\n    Argument,\n    Agent,\n    Argument,\n    Prompt,\n    Extension,\n    Setting,", "    Extension,\n    Setting,\n    Command,\n    Agent,\n    session,\n)\nfrom Providers import get_providers, get_provider_options\nfrom db.Agent import import_agent_config\n\n\ndef import_agents():\n    agent_folder = \"agents\"\n    agents = [\n        f.name\n        for f in os.scandir(agent_folder)\n        if f.is_dir() and not f.name.startswith(\"__\")\n    ]\n    existing_agents = session.query(Agent).all()\n    existing_agent_names = [agent.name for agent in existing_agents]\n\n    for agent_name in agents:\n        agent = session.query(Agent).filter_by(name=agent_name).one_or_none()\n        if agent:\n            print(f\"Updating agent: {agent_name}\")\n        else:\n            agent = Agent(name=agent_name)\n            session.add(agent)\n            session.flush()  # Save the agent object to generate an ID\n            existing_agent_names.append(agent_name)\n            print(f\"Adding agent: {agent_name}\")\n        import_agent_config(agent_name)\n    session.commit()", "\n\ndef import_agents():\n    agent_folder = \"agents\"\n    agents = [\n        f.name\n        for f in os.scandir(agent_folder)\n        if f.is_dir() and not f.name.startswith(\"__\")\n    ]\n    existing_agents = session.query(Agent).all()\n    existing_agent_names = [agent.name for agent in existing_agents]\n\n    for agent_name in agents:\n        agent = session.query(Agent).filter_by(name=agent_name).one_or_none()\n        if agent:\n            print(f\"Updating agent: {agent_name}\")\n        else:\n            agent = Agent(name=agent_name)\n            session.add(agent)\n            session.flush()  # Save the agent object to generate an ID\n            existing_agent_names.append(agent_name)\n            print(f\"Adding agent: {agent_name}\")\n        import_agent_config(agent_name)\n    session.commit()", "\n\ndef import_extensions():\n    from Extensions import Extensions\n\n    extensions_data = Extensions().get_extensions()\n    extension_settings_data = Extensions().get_extension_settings()\n\n    # Get the existing extensions and commands from the database\n    existing_extensions = session.query(Extension).all()\n    existing_commands = session.query(Command).all()\n\n    # Delete commands that don't exist in the extensions data\n    for command in existing_commands:\n        command_exists = any(\n            extension_data[\"extension_name\"] == command.extension.name\n            and any(\n                cmd[\"friendly_name\"] == command.name\n                for cmd in extension_data[\"commands\"]\n            )\n            for extension_data in extensions_data\n        )\n        if not command_exists:\n            session.delete(command)\n\n    # Add new extensions and commands, and update existing commands\n    for extension_data in extensions_data:\n        extension_name = extension_data[\"extension_name\"]\n        description = extension_data.get(\n            \"description\", \"\"\n        )  # Assign an empty string if description is missing\n\n        # Find the existing extension or create a new one\n        extension = next(\n            (ext for ext in existing_extensions if ext.name == extension_name),\n            None,\n        )\n        if extension is None:\n            extension = Extension(name=extension_name, description=description)\n            session.add(extension)\n            session.flush()\n            existing_extensions.append(extension)\n\n        commands = extension_data[\"commands\"]\n\n        for command_data in commands:\n            if \"friendly_name\" not in command_data:\n                continue\n\n            command_name = command_data[\"friendly_name\"]\n\n            # Find the existing command or create a new one\n            command = next(\n                (\n                    cmd\n                    for cmd in existing_commands\n                    if cmd.extension_id == extension.id and cmd.name == command_name\n                ),\n                None,\n            )\n            if command is None:\n                command = Command(\n                    extension_id=extension.id,\n                    name=command_name,\n                )\n                session.add(command)\n                session.flush()\n                existing_commands.append(command)\n                print(f\"Adding command: {command_name}\")\n\n            # Add command arguments\n            if \"command_args\" in command_data:\n                command_args = command_data[\"command_args\"]\n                for arg, arg_type in command_args.items():\n                    if (\n                        session.query(Argument)\n                        .filter_by(command_id=command.id, name=arg)\n                        .first()\n                    ):\n                        continue\n                    command_arg = Argument(\n                        command_id=command.id,\n                        name=arg,\n                    )\n                    session.add(command_arg)\n                    print(f\"Adding argument: {arg} to command: {command_name}\")\n\n    session.commit()\n\n    # Add extensions to the database if they don't exist\n    for extension_name in extension_settings_data.keys():\n        extension = session.query(Extension).filter_by(name=extension_name).first()\n        if not extension:\n            extension = Extension(name=extension_name)\n            session.add(extension)\n            session.flush()\n            existing_extensions.append(extension)\n            print(f\"Adding extension: {extension_name}\")\n\n    session.commit()\n\n    # Migrate extension settings\n    for extension_name, settings in extension_settings_data.items():\n        extension = session.query(Extension).filter_by(name=extension_name).first()\n        if not extension:\n            print(f\"Extension '{extension_name}' not found.\")\n            continue\n\n        for setting_name, setting_value in settings.items():\n            setting = (\n                session.query(Setting)\n                .filter_by(extension_id=extension.id, name=setting_name)\n                .first()\n            )\n            if setting:\n                setting.value = setting_value\n                print(\n                    f\"Updating setting: {setting_name} for extension: {extension_name}\"\n                )\n            else:\n                setting = Setting(\n                    extension_id=extension.id,\n                    name=setting_name,\n                    value=setting_value,\n                )\n                session.add(setting)\n                print(f\"Adding setting: {setting_name} for extension: {extension_name}\")\n\n    session.commit()", "\n\ndef import_chains():\n    chain_dir = os.path.abspath(\"chains\")\n    chain_files = [\n        file\n        for file in os.listdir(chain_dir)\n        if os.path.isfile(os.path.join(chain_dir, file)) and file.endswith(\".json\")\n    ]\n    if not chain_files:\n        print(f\"No JSON files found in chains directory.\")\n        return\n    from db.Chain import Chain\n\n    chain_importer = Chain()\n    for file in chain_files:\n        chain_name = os.path.splitext(file)[0]\n        file_path = os.path.join(chain_dir, file)\n\n        with open(file_path, \"r\") as f:\n            try:\n                chain_data = json.load(f)\n                result = chain_importer.import_chain(chain_name, chain_data)\n                print(result)\n            except json.JSONDecodeError as e:\n                print(f\"Error importing chain from '{file}': Invalid JSON format.\")\n            except Exception as e:\n                print(f\"Error importing chain from '{file}': {str(e)}\")", "\n\ndef import_prompts():\n    # Add default category if it doesn't exist\n    default_category = session.query(PromptCategory).filter_by(name=\"Default\").first()\n\n    if not default_category:\n        default_category = PromptCategory(\n            name=\"Default\", description=\"Default category\"\n        )\n        session.add(default_category)\n        session.commit()\n        print(\"Adding Default prompt category\")\n\n    # Get all prompt files in the specified folder\n    for root, dirs, files in os.walk(\"prompts\"):\n        for file in files:\n            prompt_category = None\n            if root != \"prompts\":\n                # Use subfolder name as the prompt category\n                category_name = os.path.basename(root)\n                prompt_category = (\n                    session.query(PromptCategory).filter_by(name=category_name).first()\n                )\n                if not prompt_category:\n                    prompt_category = PromptCategory(\n                        name=category_name, description=f\"{category_name} category\"\n                    )\n                    session.add(prompt_category)\n                    session.commit()\n            else:\n                # Assign to \"Uncategorized\" category if prompt is in the root folder\n                prompt_category = default_category\n\n            # Read the prompt content from the file\n            with open(os.path.join(root, file), \"r\") as f:\n                prompt_content = f.read()\n\n            # Check if prompt with the same name and category already exists\n            prompt_name = os.path.splitext(file)[0]\n            prompt = (\n                session.query(Prompt)\n                .filter_by(name=prompt_name, prompt_category=prompt_category)\n                .first()\n            )\n            prompt_args = []\n            for word in prompt_content.split():\n                if word.startswith(\"{\") and word.endswith(\"}\"):\n                    prompt_args.append(word[1:-1])\n            if not prompt:\n                # Create the prompt entry in the database\n                prompt = Prompt(\n                    name=prompt_name,\n                    description=\"\",\n                    content=prompt_content,\n                    prompt_category=prompt_category,\n                )\n                session.add(prompt)\n                session.commit()\n                print(f\"Adding prompt: {prompt_name}\")\n\n            # Populate prompt arguments\n            for arg in prompt_args:\n                if (\n                    session.query(Argument)\n                    .filter_by(prompt_id=prompt.id, name=arg)\n                    .first()\n                ):\n                    continue\n                argument = Argument(\n                    prompt_id=prompt.id,\n                    name=arg,\n                )\n                session.add(argument)\n                session.commit()\n                print(f\"Adding prompt argument: {arg} for {prompt_name}\")", "\n\ndef import_conversations():\n    agents_dir = \"agents\"  # Directory containing agent folders\n    for agent_name in os.listdir(agents_dir):\n        agent_dir = os.path.join(agents_dir, agent_name)\n        history_file = os.path.join(agent_dir, \"history.yaml\")\n\n        if not os.path.exists(history_file):\n            continue  # Skip agent if history file doesn't exist\n\n        # Get agent ID from the database based on agent name\n        agent = session.query(Agent).filter(Agent.name == agent_name).first()\n        if not agent:\n            print(f\"Agent '{agent_name}' not found in the database.\")\n            continue\n\n        # Load conversation history from the YAML file\n        with open(history_file, \"r\") as file:\n            history = yaml.safe_load(file)\n\n        # Check if the conversation already exists for the agent\n        existing_conversation = (\n            session.query(Conversation)\n            .filter(\n                Conversation.agent_id == agent.id,\n                Conversation.name == f\"{agent_name} History\",\n            )\n            .first()\n        )\n        if existing_conversation:\n            continue\n\n        # Create a new conversation\n        conversation = Conversation(agent_id=agent.id, name=f\"{agent_name} History\")\n        session.add(conversation)\n        session.commit()\n\n        for conversation_data in history[\"interactions\"]:\n            # Create a new message for the conversation\n            try:\n                role = conversation_data[\"role\"]\n                content = conversation_data[\"message\"]\n                timestamp = conversation_data[\"timestamp\"]\n            except KeyError:\n                continue\n            message = Message(\n                role=role,\n                content=content,\n                timestamp=timestamp,\n                conversation_id=conversation.id,\n            )\n            session.add(message)\n            session.commit()\n\n        print(f\"Imported `{agent_name} History` conversation for agent '{agent_name}'.\")", "\n\ndef import_providers():\n    providers = get_providers()\n    existing_providers = session.query(Provider).all()\n    existing_provider_names = [provider.name for provider in existing_providers]\n\n    for provider in existing_providers:\n        if provider.name not in providers:\n            session.delete(provider)\n\n    for provider_name in providers:\n        provider_options = get_provider_options(provider_name)\n\n        provider = session.query(Provider).filter_by(name=provider_name).one_or_none()\n\n        if provider:\n            print(f\"Updating provider: {provider_name}\")\n        else:\n            provider = Provider(name=provider_name)\n            session.add(provider)\n            existing_provider_names.append(provider_name)\n            print(f\"Adding provider: {provider_name}\")\n\n        for option_name, option_value in provider_options.items():\n            provider_setting = (\n                session.query(ProviderSetting)\n                .filter_by(provider_id=provider.id, name=option_name)\n                .one_or_none()\n            )\n            if provider_setting:\n                provider_setting.value = option_value\n                print(\n                    f\"Updating provider setting: {option_name} for provider: {provider_name}\"\n                )\n            else:\n                provider_setting = ProviderSetting(\n                    provider_id=provider.id,\n                    name=option_name,\n                    value=option_value,\n                )\n                session.add(provider_setting)\n                print(\n                    f\"Adding provider setting: {option_name} for provider: {provider_name}\"\n                )\n    session.commit()", ""]}
{"filename": "agixt/db/Agent.py", "chunked_list": ["import os\nimport json\nimport shutil\nfrom DBConnection import (\n    Agent as AgentModel,\n    AgentSetting as AgentSettingModel,\n    Command,\n    AgentCommand,\n    ProviderSetting,\n    AgentProvider,", "    ProviderSetting,\n    AgentProvider,\n    AgentProviderSetting,\n    ChainStep,\n    ChainStepArgument,\n    ChainStepResponse,\n    Provider as ProviderModel,\n    session,\n)\nfrom Providers import Providers", ")\nfrom Providers import Providers\nfrom Memories import Memories\nfrom Extensions import Extensions\n\nDEFAULT_SETTINGS = {\n    \"provider\": \"openai\",\n    \"embedder\": \"openai\",\n    \"AI_MODEL\": \"gpt-3.5-turbo-16k-0613\",\n    \"AI_TEMPERATURE\": \"0.7\",", "    \"AI_MODEL\": \"gpt-3.5-turbo-16k-0613\",\n    \"AI_TEMPERATURE\": \"0.7\",\n    \"AI_TOP_P\": \"1\",\n    \"MAX_TOKENS\": \"16000\",\n    \"helper_agent_name\": \"OpenAI\",\n    \"WEBSEARCH_TIMEOUT\": 0,\n    \"OPENAI_API_KEY\": \"YOUR_OPENAI_API_KEY_HERE\",\n    \"WAIT_BETWEEN_REQUESTS\": 1,\n    \"WAIT_AFTER_FAILURE\": 3,\n    \"stream\": False,", "    \"WAIT_AFTER_FAILURE\": 3,\n    \"stream\": False,\n    \"WORKING_DIRECTORY\": \"./WORKSPACE\",\n    \"WORKING_DIRECTORY_RESTRICTED\": True,\n    \"AUTONOMOUS_EXECUTION\": False,\n}\n\n\ndef add_agent(agent_name, provider_settings=None, commands=None):\n    if not agent_name:\n        return {\"message\": \"Agent name cannot be empty.\"}\n\n    agent = AgentModel(name=agent_name)\n    session.add(agent)\n    session.commit()\n\n    if provider_settings is None or provider_settings == \"\" or provider_settings == {}:\n        provider_settings = DEFAULT_SETTINGS\n\n    settings = {\n        \"commands\": commands,\n        \"settings\": provider_settings,\n    }\n    agent_setting = AgentSettingModel(\n        agent_id=agent.id,\n        name=\"config\",\n        value=json.dumps(settings),\n    )\n    session.add(agent_setting)\n    session.commit()\n\n    return {\"message\": f\"Agent {agent_name} created.\"}", "def add_agent(agent_name, provider_settings=None, commands=None):\n    if not agent_name:\n        return {\"message\": \"Agent name cannot be empty.\"}\n\n    agent = AgentModel(name=agent_name)\n    session.add(agent)\n    session.commit()\n\n    if provider_settings is None or provider_settings == \"\" or provider_settings == {}:\n        provider_settings = DEFAULT_SETTINGS\n\n    settings = {\n        \"commands\": commands,\n        \"settings\": provider_settings,\n    }\n    agent_setting = AgentSettingModel(\n        agent_id=agent.id,\n        name=\"config\",\n        value=json.dumps(settings),\n    )\n    session.add(agent_setting)\n    session.commit()\n\n    return {\"message\": f\"Agent {agent_name} created.\"}", "\n\ndef delete_agent(agent_name):\n    agent = session.query(AgentModel).filter_by(name=agent_name).first()\n    if not agent:\n        return {\"message\": f\"Agent {agent_name} not found.\"}, 404\n\n    # Delete associated chain steps\n    chain_steps = session.query(ChainStep).filter_by(agent_id=agent.id).all()\n    for chain_step in chain_steps:\n        # Delete associated chain step arguments\n        session.query(ChainStepArgument).filter_by(chain_step_id=chain_step.id).delete()\n        # Delete associated chain step responses\n        session.query(ChainStepResponse).filter_by(chain_step_id=chain_step.id).delete()\n        session.delete(chain_step)\n\n    # Delete associated agent commands\n    agent_commands = session.query(AgentCommand).filter_by(agent_id=agent.id).all()\n    for agent_command in agent_commands:\n        session.delete(agent_command)\n\n    # Delete associated agent_provider records\n    agent_providers = session.query(AgentProvider).filter_by(agent_id=agent.id).all()\n    for agent_provider in agent_providers:\n        # Delete associated agent_provider_settings\n        session.query(AgentProviderSetting).filter_by(\n            agent_provider_id=agent_provider.id\n        ).delete()\n        session.delete(agent_provider)\n\n    # Delete associated agent settings\n    session.query(AgentSettingModel).filter_by(agent_id=agent.id).delete()\n\n    # Delete the agent\n    session.delete(agent)\n    session.commit()\n\n    return {\"message\": f\"Agent {agent_name} deleted.\"}, 200", "\n\ndef rename_agent(agent_name, new_name):\n    agent = session.query(AgentModel).filter_by(name=agent_name).first()\n    if not agent:\n        return {\"message\": f\"Agent {agent_name} not found.\"}, 404\n\n    agent.name = new_name\n    session.commit()\n\n    return {\"message\": f\"Agent {agent_name} renamed to {new_name}.\"}, 200", "\n\ndef get_agents():\n    agents = session.query(AgentModel).all()\n    output = []\n\n    for agent in agents:\n        output.append({\"name\": agent.name, \"status\": False})\n\n    return output", "\n\ndef import_agent_config(agent_name):\n    config_path = f\"agents/{agent_name}/config.json\"\n\n    # Load the config JSON file\n    with open(config_path) as f:\n        config = json.load(f)\n\n    # Get the agent from the database\n    agent = session.query(AgentModel).filter_by(name=agent_name).first()\n\n    if not agent:\n        print(f\"Agent '{agent_name}' does not exist in the database.\")\n        return\n\n    # Get the provider ID based on the provider name in the config\n    provider_name = config[\"settings\"][\"provider\"]\n    provider = session.query(ProviderModel).filter_by(name=provider_name).first()\n\n    if not provider:\n        print(f\"Provider '{provider_name}' does not exist in the database.\")\n        return\n\n    # Update the agent's provider_id\n    agent.provider_id = provider.id\n\n    # Import agent commands\n    commands = config.get(\"commands\", {})\n    for command_name, enabled in commands.items():\n        if enabled:\n            command = session.query(Command).filter_by(name=command_name).first()\n            if command:\n                agent_command = AgentCommand(\n                    agent_id=agent.id, command_id=command.id, state=True\n                )\n                session.add(agent_command)\n\n    # Import agent settings\n    settings = config.get(\"settings\", {})\n    for setting_name, setting_value in settings.items():\n        if provider.id:\n            provider_setting = (\n                session.query(ProviderSetting)\n                .filter_by(provider_id=provider.id, name=setting_name)\n                .first()\n            )\n            if provider_setting:\n                agent_provider = (\n                    session.query(AgentProvider)\n                    .filter_by(provider_id=provider.id, agent_id=agent.id)\n                    .first()\n                )\n                if not agent_provider:\n                    agent_provider = AgentProvider(\n                        provider_id=provider.id, agent_id=agent.id\n                    )\n                    session.add(agent_provider)\n                    session.flush()  # Save the agent_provider object to generate an ID\n                if setting_value:\n                    agent_provider_setting = AgentProviderSetting(\n                        provider_setting_id=provider_setting.id,\n                        agent_provider_id=agent_provider.id,\n                        value=setting_value,\n                    )\n                    session.add(agent_provider_setting)\n            else:\n                if setting_value:\n                    agent_setting = AgentSettingModel(\n                        agent_id=agent.id, name=setting_name, value=setting_value\n                    )\n                    session.add(agent_setting)\n    session.commit()\n    print(f\"Agent config imported successfully for agent: {agent_name}\")", "\n\nclass Agent:\n    def __init__(self, agent_name=None):\n        self.agent_name = agent_name if agent_name is not None else \"AGiXT\"\n        self.AGENT_CONFIG = self.get_agent_config()\n        self.load_config_keys()\n        if \"settings\" not in self.AGENT_CONFIG:\n            self.AGENT_CONFIG[\"settings\"] = {}\n        self.PROVIDER_SETTINGS = self.AGENT_CONFIG[\"settings\"]\n        for setting in DEFAULT_SETTINGS:\n            if setting not in self.PROVIDER_SETTINGS:\n                self.PROVIDER_SETTINGS[setting] = DEFAULT_SETTINGS[setting]\n        self.AI_PROVIDER = self.AGENT_CONFIG[\"settings\"][\"provider\"]\n        self.PROVIDER = Providers(self.AI_PROVIDER, **self.PROVIDER_SETTINGS)\n        self.available_commands = Extensions(\n            agent_config=self.AGENT_CONFIG\n        ).get_available_commands()\n\n    def load_config_keys(self):\n        config_keys = [\n            \"AI_MODEL\",\n            \"AI_TEMPERATURE\",\n            \"MAX_TOKENS\",\n            \"AUTONOMOUS_EXECUTION\",\n            \"embedder\",\n        ]\n        for key in config_keys:\n            if key in self.AGENT_CONFIG:\n                setattr(self, key, self.AGENT_CONFIG[key])\n\n    def get_agent_config(self):\n        agent = (\n            session.query(AgentModel).filter(AgentModel.name == self.agent_name).first()\n        )\n        if agent:\n            agent_setting = (\n                session.query(AgentSettingModel)\n                .filter(\n                    AgentSettingModel.agent_id == agent.id,\n                    AgentSettingModel.name == \"config\",\n                )\n                .first()\n            )\n            if agent_setting:\n                config = json.loads(agent_setting.value)\n\n                # Retrieve the enabled commands for the agent\n                agent_commands = (\n                    session.query(AgentCommand)\n                    .join(Command)\n                    .filter(\n                        AgentCommand.agent_id == agent.id,\n                        AgentCommand.state == True,  # Only get enabled commands\n                    )\n                    .all()\n                )\n                enabled_commands = [ac.command.name for ac in agent_commands]\n\n                # Add the enabled commands to the config\n                config[\"enabled_commands\"] = enabled_commands\n\n                return config\n        return {}\n\n    def get_memories(self):\n        return Memories(self.agent_name, self.AGENT_CONFIG)\n\n    async def execute(self, command_name, command_args):\n        return await Extensions(agent_config=self.AGENT_CONFIG).execute_command(\n            command_name=command_name, command_args=command_args\n        )\n\n    async def instruct(self, prompt, tokens):\n        if not prompt:\n            return \"\"\n        answer = await self.PROVIDER.instruct(prompt=prompt, tokens=tokens)\n        return answer\n\n    def get_commands_string(self):\n        if len(self.available_commands) == 0:\n            return None\n\n        enabled_commands = filter(\n            lambda command: command.get(\"enabled\", True), self.available_commands\n        )\n        if not enabled_commands:\n            return None\n\n        friendly_names = map(\n            lambda command: f\"`{command['friendly_name']}` - Arguments: {command['args']}\",\n            enabled_commands,\n        )\n        command_list = \"\\n\".join(friendly_names)\n        return f\"Commands Available To Complete Task:\\n{command_list}\\n\\n\"\n\n    def update_agent_config(self, new_config, config_key):\n        agent = (\n            session.query(AgentModel).filter(AgentModel.name == self.agent_name).first()\n        )\n        if agent:\n            if config_key == \"commands\":\n                # Update AgentCommand relation\n                for command_name, enabled in new_config.items():\n                    command = (\n                        session.query(Command).filter_by(name=command_name).first()\n                    )\n                    if command:\n                        agent_command = (\n                            session.query(AgentCommand)\n                            .filter_by(agent_id=agent.id, command_id=command.id)\n                            .first()\n                        )\n                        if agent_command:\n                            agent_command.state = enabled\n                        else:\n                            agent_command = AgentCommand(\n                                agent_id=agent.id, command_id=command.id, state=enabled\n                            )\n                            session.add(agent_command)\n            else:\n                provider = (\n                    session.query(ProviderModel)\n                    .filter_by(name=self.AI_PROVIDER)\n                    .first()\n                )\n                if not provider:\n                    print(\n                        f\"Provider '{self.AI_PROVIDER}' does not exist in the database.\"\n                    )\n                    return\n\n                agent_provider = (\n                    session.query(AgentProvider)\n                    .filter_by(provider_id=provider.id, agent_id=agent.id)\n                    .first()\n                )\n                if not agent_provider:\n                    agent_provider = AgentProvider(\n                        provider_id=provider.id, agent_id=agent.id\n                    )\n                    session.add(agent_provider)\n                    session.flush()  # Save the agent_provider object to generate an ID\n\n                if config_key in [\"provider_settings\", \"settings\"]:\n                    config_dict = (\n                        agent_provider.provider_settings\n                        if config_key == \"provider_settings\"\n                        else agent_provider.settings\n                    )\n\n                    for setting_name, setting_value in new_config.items():\n                        setting = (\n                            session.query(ProviderSetting)\n                            .filter_by(provider_id=provider.id, name=setting_name)\n                            .first()\n                        )\n                        if setting:\n                            agent_provider_setting = (\n                                session.query(AgentProviderSetting)\n                                .filter_by(\n                                    provider_setting_id=setting.id,\n                                    agent_provider_id=agent_provider.id,\n                                )\n                                .first()\n                            )\n                            if agent_provider_setting:\n                                agent_provider_setting.value = setting_value\n                            else:\n                                agent_provider_setting = AgentProviderSetting(\n                                    provider_setting_id=setting.id,\n                                    agent_provider_id=agent_provider.id,\n                                    value=setting_value,\n                                )\n                                session.add(agent_provider_setting)\n                else:\n                    agent_setting = (\n                        session.query(AgentSettingModel)\n                        .filter_by(agent_id=agent.id, name=config_key)\n                        .first()\n                    )\n                    if agent_setting:\n                        agent_setting.value = new_config\n                    else:\n                        agent_setting = AgentSettingModel(\n                            agent_id=agent.id, name=config_key, value=new_config\n                        )\n                        session.add(agent_setting)\n\n            session.commit()\n            return f\"Agent {self.agent_name} configuration updated.\"\n        else:\n            return f\"Agent {self.agent_name} not found.\"\n\n    def wipe_agent_memories(self):\n        memories_folder = os.path.normpath(\n            os.path.join(os.getcwd(), self.agent_name, \"memories\")\n        )\n        if not memories_folder.startswith(os.getcwd()):\n            raise ValueError(\"Invalid path, agent name must not contain slashes.\")\n\n        if os.path.exists(memories_folder):\n            shutil.rmtree(memories_folder)", ""]}
{"filename": "agixt/db/Chain.py", "chunked_list": ["from DBConnection import (\n    session,\n    Chain as ChainDB,\n    ChainStep,\n    ChainStepResponse,\n    Agent,\n    Argument,\n    ChainStepArgument,\n    Prompt,\n    Command,", "    Prompt,\n    Command,\n)\nfrom agixtsdk import AGiXTSDK\nfrom Extensions import Extensions\nimport logging\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()", "\nload_dotenv()\nApiClient = AGiXTSDK(\n    base_uri=\"http://localhost:7437\", api_key=os.getenv(\"AGIXT_API_KEY\")\n)\n\n\nclass Chain:\n    def get_chain(self, chain_name):\n        chain_name = chain_name.replace(\"%20\", \" \")\n        chain_db = session.query(ChainDB).filter(ChainDB.name == chain_name).first()\n        if chain_db is None:\n            return None\n\n        chain_steps = (\n            session.query(ChainStep)\n            .filter(ChainStep.chain_id == chain_db.id)\n            .order_by(ChainStep.step_number)\n            .all()\n        )\n\n        steps = []\n        for step in chain_steps:\n            agent_name = session.query(Agent).get(step.agent_id).name\n            prompt = {}\n            if step.target_chain_id:\n                prompt[\"chain_name\"] = (\n                    session.query(ChainDB).get(step.target_chain_id).name\n                )\n            elif step.target_command_id:\n                prompt[\"command_name\"] = (\n                    session.query(Command).get(step.target_command_id).name\n                )\n            elif step.target_prompt_id:\n                prompt[\"prompt_name\"] = (\n                    session.query(Prompt).get(step.target_prompt_id).name\n                )\n\n            # Retrieve argument data for the step\n            arguments = (\n                session.query(Argument, ChainStepArgument)\n                .join(ChainStepArgument, ChainStepArgument.argument_id == Argument.id)\n                .filter(ChainStepArgument.chain_step_id == step.id)\n                .all()\n            )\n\n            prompt_args = {}\n            for argument, chain_step_argument in arguments:\n                prompt_args[argument.name] = chain_step_argument.value\n\n            prompt.update(prompt_args)\n\n            step_data = {\n                \"step\": step.step_number,\n                \"agent_name\": agent_name,\n                \"prompt_type\": step.prompt_type,\n                \"prompt\": prompt,\n            }\n            steps.append(step_data)\n\n        chain_data = {\n            \"chain_name\": chain_db.name,\n            \"steps\": steps,\n        }\n\n        return chain_data\n\n    def get_chains(self):\n        chains = session.query(ChainDB).all()\n        return [chain.name for chain in chains]\n\n    def add_chain(self, chain_name):\n        chain = ChainDB(name=chain_name)\n        session.add(chain)\n        session.commit()\n\n    def rename_chain(self, chain_name, new_name):\n        chain = session.query(ChainDB).filter(ChainDB.name == chain_name).first()\n        chain.name = new_name\n        session.commit()\n\n    def add_chain_step(self, chain_name, step_number, agent_name, prompt_type, prompt):\n        chain = session.query(ChainDB).filter(ChainDB.name == chain_name).first()\n        agent = session.query(Agent).filter(Agent.name == agent_name).first()\n        if \"prompt_name\" in prompt:\n            argument_key = \"prompt_name\"\n            target_id = (\n                session.query(Prompt)\n                .filter(Prompt.name == prompt[\"prompt_name\"])\n                .first()\n                .id\n            )\n            target_type = \"prompt\"\n        elif \"chain_name\" in prompt:\n            argument_key = \"chain_name\"\n            target_id = (\n                session.query(Chain)\n                .filter(Chain.name == prompt[\"chain_name\"])\n                .first()\n                .id\n            )\n            target_type = \"chain\"\n        elif \"command_name\" in prompt:\n            argument_key = \"command_name\"\n            target_id = (\n                session.query(Command)\n                .filter(Command.name == prompt[\"command_name\"])\n                .first()\n                .id\n            )\n            target_type = \"command\"\n\n        argument_value = prompt[argument_key]\n        prompt_arguments = prompt.copy()\n        del prompt_arguments[argument_key]\n\n        chain_step = ChainStep(\n            chain_id=chain.id,\n            step_number=step_number,\n            agent_id=agent.id,\n            prompt_type=prompt_type,\n            prompt=argument_value,\n            target_chain_id=target_id if target_type == \"chain\" else None,\n            target_command_id=target_id if target_type == \"command\" else None,\n            target_prompt_id=target_id if target_type == \"prompt\" else None,\n        )\n        session.add(chain_step)\n        session.commit()\n\n        for argument_name, argument_value in prompt_arguments.items():\n            argument = (\n                session.query(Argument).filter(Argument.name == argument_name).first()\n            )\n            if not argument:\n                # Handle the case where argument not found based on argument_name\n                # You can choose to skip this argument or raise an exception\n                continue\n\n            chain_step_argument = ChainStepArgument(\n                chain_step_id=chain_step.id,\n                argument_id=argument.id,\n                value=argument_value,\n            )\n            session.add(chain_step_argument)\n            session.commit()\n\n    def update_step(self, chain_name, step_number, agent_name, prompt_type, prompt):\n        chain = session.query(ChainDB).filter(ChainDB.name == chain_name).first()\n        chain_step = (\n            session.query(ChainStep)\n            .filter(\n                ChainStep.chain_id == chain.id, ChainStep.step_number == step_number\n            )\n            .first()\n        )\n\n        agent = session.query(Agent).filter(Agent.name == agent_name).first()\n        agent_id = agent.id if agent else None\n\n        target_chain_id = None\n        target_command_id = None\n        target_prompt_id = None\n\n        if prompt_type == \"Command\":\n            command_name = prompt.get(\"command_name\")\n            command_args = prompt.copy()\n            del command_args[\"command_name\"]\n            command = (\n                session.query(Command).filter(Command.name == command_name).first()\n            )\n            if command:\n                target_command_id = command.id\n        elif prompt_type == \"Prompt\":\n            prompt_name = prompt.get(\"prompt_name\")\n            prompt_args = prompt.copy()\n            del prompt_args[\"prompt_name\"]\n            prompt_obj = (\n                session.query(Prompt).filter(Prompt.name == prompt_name).first()\n            )\n            if prompt_obj:\n                target_prompt_id = prompt_obj.id\n        elif prompt_type == \"Chain\":\n            chain_name = prompt.get(\"chain_name\")\n            chain_args = prompt.copy()\n            del chain_args[\"chain_name\"]\n            chain_obj = (\n                session.query(ChainDB).filter(ChainDB.name == chain_name).first()\n            )\n            if chain_obj:\n                target_chain_id = chain_obj.id\n\n        chain_step.agent_id = agent_id\n        chain_step.prompt_type = prompt_type\n        chain_step.prompt = prompt.get(\"prompt_name\", None)\n        chain_step.target_chain_id = target_chain_id\n        chain_step.target_command_id = target_command_id\n        chain_step.target_prompt_id = target_prompt_id\n\n        session.commit()\n\n        # Update the arguments for the step\n        session.query(ChainStepArgument).filter(\n            ChainStepArgument.chain_step_id == chain_step.id\n        ).delete()\n\n        for argument_name, argument_value in prompt_args.items():\n            argument = (\n                session.query(Argument).filter(Argument.name == argument_name).first()\n            )\n            if argument:\n                chain_step_argument = ChainStepArgument(\n                    chain_step_id=chain_step.id,\n                    argument_id=argument.id,\n                    value=argument_value,\n                )\n                session.add(chain_step_argument)\n                session.commit()\n\n    def delete_step(self, chain_name, step_number):\n        chain = session.query(ChainDB).filter(ChainDB.name == chain_name).first()\n\n        if chain:\n            chain_step = (\n                session.query(ChainStep)\n                .filter(\n                    ChainStep.chain_id == chain.id, ChainStep.step_number == step_number\n                )\n                .first()\n            )\n            if chain_step:\n                session.delete(chain_step)  # Remove the chain step from the session\n                session.commit()\n            else:\n                print(\n                    f\"No step found with number {step_number} in chain '{chain_name}'\"\n                )\n        else:\n            print(f\"No chain found with name '{chain_name}'\")\n\n    def delete_chain(self, chain_name):\n        chain = session.query(ChainDB).filter(ChainDB.name == chain_name).first()\n        session.delete(chain)\n        session.commit()\n\n    def get_step(self, chain_name, step_number):\n        chain = session.query(ChainDB).filter(ChainDB.name == chain_name).first()\n        chain_step = (\n            session.query(ChainStep)\n            .filter(\n                ChainStep.chain_id == chain.id, ChainStep.step_number == step_number\n            )\n            .first()\n        )\n        return chain_step\n\n    def get_steps(self, chain_name):\n        chain = session.query(ChainDB).filter(ChainDB.name == chain_name).first()\n        chain_steps = (\n            session.query(ChainStep)\n            .filter(ChainStep.chain_id == chain.id)\n            .order_by(ChainStep.step_number)\n            .all()\n        )\n        return chain_steps\n\n    def move_step(self, chain_name, current_step_number, new_step_number):\n        chain = session.query(ChainDB).filter(ChainDB.name == chain_name).first()\n        chain_step = (\n            session.query(ChainStep)\n            .filter(\n                ChainStep.chain_id == chain.id,\n                ChainStep.step_number == current_step_number,\n            )\n            .first()\n        )\n        chain_step.step_number = new_step_number\n        if new_step_number < current_step_number:\n            session.query(ChainStep).filter(\n                ChainStep.chain_id == chain.id,\n                ChainStep.step_number >= new_step_number,\n                ChainStep.step_number < current_step_number,\n            ).update(\n                {\"step_number\": ChainStep.step_number + 1}, synchronize_session=False\n            )\n        else:\n            session.query(ChainStep).filter(\n                ChainStep.chain_id == chain.id,\n                ChainStep.step_number > current_step_number,\n                ChainStep.step_number <= new_step_number,\n            ).update(\n                {\"step_number\": ChainStep.step_number - 1}, synchronize_session=False\n            )\n        session.commit()\n\n    def get_step_response(self, chain_name, step_number=\"all\"):\n        chain = session.query(ChainDB).filter(ChainDB.name == chain_name).first()\n\n        if step_number == \"all\":\n            chain_steps = (\n                session.query(ChainStep)\n                .filter(ChainStep.chain_id == chain.id)\n                .order_by(ChainStep.step_number)\n                .all()\n            )\n\n            responses = {}\n            for step in chain_steps:\n                chain_step_responses = (\n                    session.query(ChainStepResponse)\n                    .filter(ChainStepResponse.chain_step_id == step.id)\n                    .order_by(ChainStepResponse.timestamp)\n                    .all()\n                )\n                step_responses = [response.content for response in chain_step_responses]\n                responses[str(step.step_number)] = step_responses\n\n            return responses\n        else:\n            chain_step = (\n                session.query(ChainStep)\n                .filter(\n                    ChainStep.chain_id == chain.id, ChainStep.step_number == step_number\n                )\n                .first()\n            )\n\n            if chain_step:\n                chain_step_responses = (\n                    session.query(ChainStepResponse)\n                    .filter(ChainStepResponse.chain_step_id == chain_step.id)\n                    .order_by(ChainStepResponse.timestamp)\n                    .all()\n                )\n                step_responses = [response.content for response in chain_step_responses]\n                return step_responses\n            else:\n                return None\n\n    def get_chain_responses(self, chain_name):\n        chain = session.query(ChainDB).filter(ChainDB.name == chain_name).first()\n        chain_steps = (\n            session.query(ChainStep)\n            .filter(ChainStep.chain_id == chain.id)\n            .order_by(ChainStep.step_number)\n            .all()\n        )\n        responses = {}\n        for step in chain_steps:\n            chain_step_responses = (\n                session.query(ChainStepResponse)\n                .filter(ChainStepResponse.chain_step_id == step.id)\n                .order_by(ChainStepResponse.timestamp)\n                .all()\n            )\n            step_responses = [response.content for response in chain_step_responses]\n            responses[str(step.step_number)] = step_responses\n        return responses\n\n    def import_chain(self, chain_name: str, steps: dict):\n        chain = ChainDB(name=chain_name)\n        session.add(chain)\n        session.commit()\n\n        steps = steps[\"steps\"] if \"steps\" in steps else steps\n        for step_data in steps:\n            agent_name = step_data[\"agent_name\"]\n            agent = session.query(Agent).filter(Agent.name == agent_name).first()\n            if not agent:\n                # Handle the case where agent not found based on agent_name\n                # You can choose to skip this step or raise an exception\n                continue\n\n            prompt = step_data[\"prompt\"]\n            if \"prompt_name\" in prompt:\n                argument_key = \"prompt_name\"\n                target_id = (\n                    session.query(Prompt)\n                    .filter(Prompt.name == prompt[\"prompt_name\"])\n                    .first()\n                    .id\n                )\n                target_type = \"prompt\"\n            elif \"chain_name\" in prompt:\n                argument_key = \"chain_name\"\n                target_id = (\n                    session.query(Chain)\n                    .filter(Chain.name == prompt[\"chain_name\"])\n                    .first()\n                    .id\n                )\n                target_type = \"chain\"\n            elif \"command_name\" in prompt:\n                argument_key = \"command_name\"\n                target_id = (\n                    session.query(Command)\n                    .filter(Command.name == prompt[\"command_name\"])\n                    .first()\n                    .id\n                )\n                target_type = \"command\"\n            else:\n                # Handle the case where the argument key is not found\n                # You can choose to skip this step or raise an exception\n                continue\n\n            argument_value = prompt[argument_key]\n            prompt_arguments = prompt.copy()\n            del prompt_arguments[argument_key]\n\n            chain_step = ChainStep(\n                chain_id=chain.id,\n                step_number=step_data[\"step\"],\n                agent_id=agent.id,\n                prompt_type=step_data[\"prompt_type\"],\n                prompt=argument_value,\n                target_chain_id=target_id if target_type == \"chain\" else None,\n                target_command_id=target_id if target_type == \"command\" else None,\n                target_prompt_id=target_id if target_type == \"prompt\" else None,\n            )\n            session.add(chain_step)\n            session.commit()\n\n            for argument_name, argument_value in prompt_arguments.items():\n                argument = (\n                    session.query(Argument)\n                    .filter(Argument.name == argument_name)\n                    .first()\n                )\n                if not argument:\n                    # Handle the case where argument not found based on argument_name\n                    # You can choose to skip this argument or raise an exception\n                    continue\n\n                chain_step_argument = ChainStepArgument(\n                    chain_step_id=chain_step.id,\n                    argument_id=argument.id,\n                    value=argument_value,\n                )\n                session.add(chain_step_argument)\n                session.commit()\n\n        return f\"Chain '{chain_name}' imported.\"\n\n    def get_step_content(self, chain_name, prompt_content, user_input, agent_name):\n        if isinstance(prompt_content, dict):\n            new_prompt_content = {}\n            for arg, value in prompt_content.items():\n                if isinstance(value, str):\n                    if \"{user_input}\" in value:\n                        value = value.replace(\"{user_input}\", user_input)\n                    if \"{agent_name}\" in value:\n                        value = value.replace(\"{agent_name}\", agent_name)\n                    if \"{STEP\" in value:\n                        step_count = value.count(\"{STEP\")\n                        for i in range(step_count):\n                            new_step_number = int(value.split(\"{STEP\")[1].split(\"}\")[0])\n                            step_response = self.get_step_response(\n                                chain_name=chain_name, step_number=new_step_number\n                            )\n                            if step_response:\n                                resp = (\n                                    step_response[0]\n                                    if isinstance(step_response, list)\n                                    else step_response\n                                )\n                                value = value.replace(\n                                    f\"{{STEP{new_step_number}}}\", f\"{resp}\"\n                                )\n                new_prompt_content[arg] = value\n            return new_prompt_content\n        elif isinstance(prompt_content, str):\n            new_prompt_content = prompt_content\n            if \"{user_input}\" in prompt_content:\n                new_prompt_content = new_prompt_content.replace(\n                    \"{user_input}\", user_input\n                )\n            if \"{agent_name}\" in new_prompt_content:\n                new_prompt_content = new_prompt_content.replace(\n                    \"{agent_name}\", agent_name\n                )\n            if \"{STEP\" in prompt_content:\n                step_count = prompt_content.count(\"{STEP\")\n                for i in range(step_count):\n                    new_step_number = int(\n                        prompt_content.split(\"{STEP\")[1].split(\"}\")[0]\n                    )\n                    step_response = self.get_step_response(\n                        chain_name=chain_name, step_number=new_step_number\n                    )\n                    if step_response:\n                        resp = (\n                            step_response[0]\n                            if isinstance(step_response, list)\n                            else step_response\n                        )\n                        new_prompt_content = new_prompt_content.replace(\n                            f\"{{STEP{new_step_number}}}\", f\"{resp}\"\n                        )\n            return new_prompt_content\n        else:\n            return prompt_content\n\n    async def run_chain_step(\n        self, step: dict = {}, chain_name=\"\", user_input=\"\", agent_override=\"\"\n    ):\n        if step:\n            if \"prompt_type\" in step:\n                if agent_override != \"\":\n                    agent_name = agent_override\n                else:\n                    agent_name = step[\"agent_name\"]\n                prompt_type = step[\"prompt_type\"]\n                step_number = step[\"step\"]\n                if \"prompt_name\" in step[\"prompt\"]:\n                    prompt_name = step[\"prompt\"][\"prompt_name\"]\n                else:\n                    prompt_name = \"\"\n                args = self.get_step_content(\n                    chain_name=chain_name,\n                    prompt_content=step[\"prompt\"],\n                    user_input=user_input,\n                    agent_name=step[\"agent_name\"],\n                )\n\n                if prompt_type == \"Command\":\n                    return await Extensions().execute_command(\n                        command_name=step[\"prompt\"][\"command_name\"], command_args=args\n                    )\n\n                elif prompt_type == \"Prompt\":\n                    result = ApiClient.prompt_agent(\n                        agent_name=agent_name,\n                        prompt_name=prompt_name,\n                        prompt_args={\n                            \"chain_name\": chain_name,\n                            \"step_number\": step_number,\n                            \"user_input\": user_input,\n                            **args,\n                        },\n                    )\n                elif prompt_type == \"Chain\":\n                    result = ApiClient.run_chain(\n                        chain_name=args[\"chain\"],\n                        user_input=args[\"input\"],\n                        agent_name=agent_name,\n                        all_responses=False,\n                        from_step=1,\n                    )\n        if result:\n            return result\n        else:\n            return None\n\n    async def run_chain(\n        self,\n        chain_name,\n        user_input=None,\n        all_responses=True,\n        agent_override=\"\",\n        from_step=1,\n    ):\n        chain_data = ApiClient.get_chain(chain_name=chain_name)\n        if chain_data == {}:\n            return f\"Chain `{chain_name}` not found.\"\n        logging.info(f\"Running chain '{chain_name}'\")\n        responses = {}  # Create a dictionary to hold responses.\n        last_response = \"\"\n        for step_data in chain_data[\"steps\"]:\n            if int(step_data[\"step\"]) >= int(from_step):\n                if \"prompt\" in step_data and \"step\" in step_data:\n                    step = {}\n                    step[\"agent_name\"] = (\n                        agent_override\n                        if agent_override != \"\"\n                        else step_data[\"agent_name\"]\n                    )\n                    step[\"prompt_type\"] = step_data[\"prompt_type\"]\n                    step[\"prompt\"] = step_data[\"prompt\"]\n                    logging.info(\n                        f\"Running step {step_data['step']} with agent {step['agent_name']}.\"\n                    )\n\n                    # Get the chain step based on the step number\n                    chain_step = self.get_step(chain_name, step_data[\"step\"])\n\n                    step_response = await self.run_chain_step(\n                        step=step_data,\n                        chain_name=chain_name,\n                        user_input=user_input,\n                        agent_override=agent_override,\n                    )  # Get the response of the current step.\n                    step[\"response\"] = step_response\n                    last_response = step_response\n                    responses[step_data[\"step\"]] = step  # Store the response.\n                    logging.info(f\"Response: {step_response}\")\n                    # Write the response to the json file.\n                    response_content = {\n                        \"chain_step_id\": chain_step.id,\n                        \"content\": step_response,\n                    }\n                    chain_step_response = ChainStepResponse(**response_content)\n                    session.add(chain_step_response)\n                    session.commit()\n\n        if all_responses:\n            return responses\n        else:\n            # Return only the last response in the chain.\n            return last_response", ""]}
{"filename": "agixt/db/Prompts.py", "chunked_list": ["from DBConnection import Prompt, PromptCategory, Argument, session\n\n\nclass Prompts:\n    def add_prompt(self, prompt_name, prompt, prompt_category_name=None):\n        if not prompt_category_name:\n            prompt_category_name = \"Default\"\n\n        prompt_category = (\n            session.query(PromptCategory).filter_by(name=prompt_category_name).first()\n        )\n        if not prompt_category:\n            prompt_category = PromptCategory(\n                name=prompt_category_name,\n                description=f\"{prompt_category_name} category\",\n            )\n            session.add(prompt_category)\n            session.commit()\n\n        prompt_obj = Prompt(\n            name=prompt_name,\n            description=\"\",\n            content=prompt,\n            prompt_category=prompt_category,\n        )\n        session.add(prompt_obj)\n        session.commit()\n\n        # Populate prompt arguments\n        prompt_args = self.get_prompt_args(prompt)\n        for arg in prompt_args:\n            argument = Argument(\n                prompt_id=prompt_obj.id,\n                name=arg,\n            )\n            session.add(argument)\n        session.commit()\n\n    def get_prompt(self, prompt_name, prompt_category=\"Default\"):\n        prompt = (\n            session.query(Prompt)\n            .filter_by(name=prompt_name)\n            .join(PromptCategory)\n            .filter(PromptCategory.name == prompt_category)\n            .first()\n        )\n        if not prompt and prompt_category != \"Default\":\n            # Prompt not found in specified category, try the default category\n            prompt = (\n                session.query(Prompt)\n                .filter_by(name=prompt_name)\n                .join(PromptCategory)\n                .filter(PromptCategory.name == \"Default\")\n                .first()\n            )\n        if prompt:\n            return prompt.content\n        return None\n\n    def get_prompts(self):\n        prompts = session.query(Prompt).all()\n        return [prompt.name for prompt in prompts]\n\n    def get_prompt_args(self, prompt_text):\n        prompt_args = []\n        start_index = prompt_text.find(\"{\")\n        while start_index != -1:\n            end_index = prompt_text.find(\"}\", start_index)\n            if end_index != -1:\n                prompt_args.append(prompt_text[start_index + 1 : end_index])\n                start_index = prompt_text.find(\"{\", end_index)\n            else:\n                break\n        return prompt_args\n\n    def delete_prompt(self, prompt_name):\n        prompt = session.query(Prompt).filter_by(name=prompt_name).first()\n        if prompt:\n            # Delete associated arguments\n            arguments = session.query(Argument).filter_by(prompt_id=prompt.id).all()\n            for argument in arguments:\n                session.delete(argument)\n\n            session.delete(prompt)\n            session.commit()\n\n    def update_prompt(self, prompt_name, prompt, prompt_category_name=None):\n        prompt_obj = session.query(Prompt).filter_by(name=prompt_name).first()\n        if prompt_obj:\n            if prompt_category_name:\n                prompt_category = (\n                    session.query(PromptCategory)\n                    .filter_by(name=prompt_category_name)\n                    .first()\n                )\n                if not prompt_category:\n                    prompt_category = PromptCategory(\n                        name=prompt_category_name,\n                        description=f\"{prompt_category_name} category\",\n                    )\n                    session.add(prompt_category)\n                    session.commit()\n                prompt_obj.prompt_category = prompt_category\n\n            prompt_obj.content = prompt\n            session.commit()\n\n            # Update prompt arguments\n            prompt_args = self.get_prompt_args(prompt)\n            existing_args = (\n                session.query(Argument).filter_by(prompt_id=prompt_obj.id).all()\n            )\n            existing_arg_names = {arg.name for arg in existing_args}\n\n            # Delete removed arguments\n            for arg in existing_args:\n                if arg.name not in prompt_args:\n                    session.delete(arg)\n\n            # Add new arguments\n            for arg in prompt_args:\n                if arg not in existing_arg_names:\n                    argument = Argument(\n                        prompt_id=prompt_obj.id,\n                        name=arg,\n                    )\n                    session.add(argument)\n\n            session.commit()\n\n    def rename_prompt(self, prompt_name, new_prompt_name):\n        prompt = session.query(Prompt).filter_by(name=prompt_name).first()\n        if prompt:\n            prompt.name = new_prompt_name\n            session.commit()", ""]}
{"filename": "agixt/fb/History.py", "chunked_list": ["from datetime import datetime\nimport yaml\nimport os\n\n\ndef export_conversation(agent_name, conversation_name=None):\n    if not conversation_name:\n        conversation_name = f\"{agent_name} History\"\n    history_file = os.path.join(\n        \"conversations\", agent_name, f\"{conversation_name}.yaml\"\n    )\n    if os.path.exists(history_file):\n        with open(history_file, \"r\") as file:\n            history = yaml.safe_load(file)\n        return history\n    return {\"interactions\": []}", "\n\ndef get_conversation(agent_name, conversation_name=None, limit=100, page=1):\n    if not conversation_name:\n        conversation_name = f\"{agent_name} History\"\n    history_file = os.path.join(\n        \"conversations\", agent_name, f\"{conversation_name}.yaml\"\n    )\n    os.makedirs(os.path.dirname(history_file), exist_ok=True)\n    if os.path.exists(history_file):\n        with open(history_file, \"r\") as file:\n            history = yaml.safe_load(file)\n        if not history:\n            history = {\"interactions\": []}\n        return history\n    return new_conversation(agent_name=agent_name, conversation_name=conversation_name)", "\n\ndef get_conversations(agent_name):\n    agent_dir = os.path.join(\"conversations\", agent_name)\n    if os.path.exists(agent_dir):\n        conversations = os.listdir(agent_dir)\n        return [conversation.split(\".\")[0] for conversation in conversations]\n    new_conversation(agent_name=agent_name, conversation_name=f\"{agent_name} History\")\n    return [f\"{agent_name} History\"]\n", "\n\ndef new_conversation(agent_name, conversation_name):\n    history = {\"interactions\": []}\n    history_file = os.path.join(\n        \"conversations\", agent_name, f\"{conversation_name}.yaml\"\n    )\n    os.makedirs(os.path.dirname(history_file), exist_ok=True)\n    with open(history_file, \"w\") as file:\n        yaml.safe_dump(history, file)\n    return history", "\n\ndef log_interaction(role: str, message: str, agent_name: str, conversation_name=None):\n    history = get_conversation(\n        agent_name=agent_name, conversation_name=conversation_name\n    )\n    history_file = os.path.join(\n        \"conversations\", agent_name, f\"{conversation_name}.yaml\"\n    )\n    os.makedirs(os.path.dirname(history_file), exist_ok=True)\n    if not history:\n        history = {\"interactions\": []}\n    if \"interactions\" not in history:\n        history[\"interactions\"] = []\n    history[\"interactions\"].append(\n        {\n            \"role\": role,\n            \"message\": message,\n            \"timestamp\": datetime.now().strftime(\"%B %d, %Y %I:%M %p\"),\n        }\n    )\n    with open(history_file, \"w\") as file:\n        yaml.safe_dump(history, file)", "\n\ndef delete_history(agent_name, conversation_name=None):\n    if not conversation_name:\n        conversation_name = f\"{agent_name} History\"\n    history_file = os.path.join(\n        \"conversations\", agent_name, f\"{conversation_name}.yaml\"\n    )\n\n    if os.path.exists(history_file):\n        os.remove(history_file)", "\n\ndef delete_message(agent_name, message, conversation_name=None):\n    history = get_conversation(\n        agent_name=agent_name, conversation_name=conversation_name\n    )\n    history[\"interactions\"] = [\n        interaction\n        for interaction in history[\"interactions\"]\n        if interaction[\"message\"] != message\n    ]\n    if not conversation_name:\n        conversation_name = \"history\"\n    history_file = os.path.join(\n        \"conversations\", agent_name, f\"{conversation_name}.yaml\"\n    )\n    with open(history_file, \"w\") as file:\n        yaml.safe_dump(history, file)", ""]}
{"filename": "agixt/fb/Agent.py", "chunked_list": ["import os\nimport json\nimport glob\nimport shutil\nimport importlib\nfrom inspect import signature, Parameter\nfrom Providers import Providers\nfrom Memories import Memories\nfrom Extensions import Extensions\n", "from Extensions import Extensions\n\nDEFAULT_SETTINGS = {\n    \"provider\": \"openai\",\n    \"embedder\": \"openai\",\n    \"AI_MODEL\": \"gpt-3.5-turbo-16k-0613\",\n    \"AI_TEMPERATURE\": \"0.7\",\n    \"AI_TOP_P\": \"1\",\n    \"MAX_TOKENS\": \"16000\",\n    \"helper_agent_name\": \"OpenAI\",", "    \"MAX_TOKENS\": \"16000\",\n    \"helper_agent_name\": \"OpenAI\",\n    \"WEBSEARCH_TIMEOUT\": 0,\n    \"OPENAI_API_KEY\": \"YOUR_OPENAI_API_KEY_HERE\",\n    \"WAIT_BETWEEN_REQUESTS\": 1,\n    \"WAIT_AFTER_FAILURE\": 3,\n    \"stream\": False,\n    \"WORKING_DIRECTORY\": \"./WORKSPACE\",\n    \"WORKING_DIRECTORY_RESTRICTED\": True,\n    \"AUTONOMOUS_EXECUTION\": False,", "    \"WORKING_DIRECTORY_RESTRICTED\": True,\n    \"AUTONOMOUS_EXECUTION\": False,\n}\n\n\ndef get_agent_file_paths(agent_name):\n    base_path = os.path.join(os.getcwd(), \"agents\")\n    folder_path = os.path.normpath(os.path.join(base_path, agent_name))\n    config_path = os.path.normpath(os.path.join(folder_path, \"config.json\"))\n    if not config_path.startswith(base_path) or not folder_path.startswith(base_path):\n        raise ValueError(\"Invalid path, agent name must not contain slashes.\")\n    if not os.path.exists(folder_path):\n        os.mkdir(folder_path)\n    return config_path, folder_path", "\n\ndef add_agent(agent_name, provider_settings=None, commands={}):\n    if not agent_name:\n        return \"Agent name cannot be empty.\"\n    provider_settings = (\n        DEFAULT_SETTINGS\n        if not provider_settings or provider_settings == {}\n        else provider_settings\n    )\n    config_path, folder_path = get_agent_file_paths(agent_name=agent_name)\n    if provider_settings is None or provider_settings == \"\" or provider_settings == {}:\n        provider_settings = DEFAULT_SETTINGS\n    settings = json.dumps(\n        {\n            \"commands\": commands,\n            \"settings\": provider_settings,\n        }\n    )\n    # Write the settings to the agent config file\n    with open(config_path, \"w\") as f:\n        f.write(settings)\n    return {\"message\": f\"Agent {agent_name} created.\"}", "\n\ndef delete_agent(agent_name):\n    config_path, folder_path = get_agent_file_paths(agent_name=agent_name)\n    try:\n        if os.path.exists(folder_path):\n            shutil.rmtree(folder_path)\n        return {\"message\": f\"Agent {agent_name} deleted.\"}, 200\n    except:\n        return {\"message\": f\"Agent {agent_name} could not be deleted.\"}, 400", "\n\ndef rename_agent(agent_name, new_name):\n    config_path, folder_path = get_agent_file_paths(agent_name=agent_name)\n    base_path = os.path.join(os.getcwd(), \"agents\")\n    new_agent_folder = os.path.normpath(os.path.join(base_path, new_name))\n    if not new_agent_folder.startswith(base_path):\n        raise ValueError(\"Invalid path, agent name must not contain slashes.\")\n\n    if os.path.exists(folder_path):\n        # Check if the new name is already taken\n        if os.path.exists(new_agent_folder):\n            # Add a number to the end of the new name\n            i = 1\n            while os.path.exists(new_agent_folder):\n                i += 1\n                new_name = f\"{new_name}_{i}\"\n                new_agent_folder = os.path.normpath(os.path.join(base_path, new_name))\n            if not new_agent_folder.startswith(base_path):\n                raise ValueError(\"Invalid path, agent name must not contain slashes.\")\n        os.rename(folder_path, new_agent_folder)\n        return {\"message\": f\"Agent {agent_name} renamed to {new_name}.\"}, 200", "\n\ndef get_agents():\n    agents_dir = \"agents\"\n    if not os.path.exists(agents_dir):\n        os.makedirs(agents_dir)\n    agents = [\n        dir_name\n        for dir_name in os.listdir(agents_dir)\n        if os.path.isdir(os.path.join(agents_dir, dir_name))\n    ]\n    output = []\n    if agents:\n        for agent in agents:\n            output.append({\"name\": agent, \"status\": False})\n    return output", "\n\nclass Agent:\n    def __init__(self, agent_name=None):\n        self.agent_name = agent_name if agent_name is not None else \"AGiXT\"\n        self.config_path, self.folder_path = get_agent_file_paths(\n            agent_name=self.agent_name\n        )\n        self.AGENT_CONFIG = self.get_agent_config()\n        if \"settings\" in self.AGENT_CONFIG:\n            self.PROVIDER_SETTINGS = self.AGENT_CONFIG[\"settings\"]\n            if self.PROVIDER_SETTINGS == {}:\n                self.PROVIDER_SETTINGS = DEFAULT_SETTINGS\n            if \"provider\" in self.PROVIDER_SETTINGS:\n                self.AI_PROVIDER = self.PROVIDER_SETTINGS[\"provider\"]\n                self.PROVIDER = Providers(self.AI_PROVIDER, **self.PROVIDER_SETTINGS)\n                self._load_agent_config_keys(\n                    [\"AI_MODEL\", \"AI_TEMPERATURE\", \"MAX_TOKENS\", \"AUTONOMOUS_EXECUTION\"]\n                )\n            if \"AI_MODEL\" in self.PROVIDER_SETTINGS:\n                self.AI_MODEL = self.PROVIDER_SETTINGS[\"AI_MODEL\"]\n                if self.AI_MODEL == \"\":\n                    self.AI_MODEL = \"default\"\n            else:\n                self.AI_MODEL = \"openassistant\"\n            if \"embedder\" in self.PROVIDER_SETTINGS:\n                self.EMBEDDER = self.PROVIDER_SETTINGS[\"embedder\"]\n            else:\n                if self.AI_PROVIDER == \"openai\":\n                    self.EMBEDDER = \"openai\"\n                else:\n                    self.EMBEDDER = \"default\"\n            if \"MAX_TOKENS\" in self.PROVIDER_SETTINGS:\n                self.MAX_TOKENS = self.PROVIDER_SETTINGS[\"MAX_TOKENS\"]\n            else:\n                self.MAX_TOKENS = 4000\n            if \"AUTONOMOUS_EXECUTION\" in self.PROVIDER_SETTINGS:\n                self.AUTONOMOUS_EXECUTION = self.PROVIDER_SETTINGS[\n                    \"AUTONOMOUS_EXECUTION\"\n                ]\n                if isinstance(self.AUTONOMOUS_EXECUTION, str):\n                    self.AUTONOMOUS_EXECUTION = self.AUTONOMOUS_EXECUTION.lower()\n                    self.AUTONOMOUS_EXECUTION = (\n                        True if self.AUTONOMOUS_EXECUTION == \"true\" else False\n                    )\n            else:\n                self.AUTONOMOUS_EXECUTION = True\n            self.commands = self.load_commands()\n            self.available_commands = Extensions(\n                agent_config=self.AGENT_CONFIG\n            ).get_available_commands()\n            self.clean_agent_config_commands()\n\n    def get_memories(self):\n        return Memories(self.agent_name, self.AGENT_CONFIG)\n\n    async def execute(self, command_name, command_args):\n        return await Extensions(agent_config=self.AGENT_CONFIG).execute_command(\n            command_name=command_name, command_args=command_args\n        )\n\n    async def instruct(self, prompt, tokens):\n        if not prompt:\n            return \"\"\n        answer = await self.PROVIDER.instruct(prompt=prompt, tokens=tokens)\n        return answer\n\n    def _load_agent_config_keys(self, keys):\n        for key in keys:\n            if key in self.AGENT_CONFIG:\n                setattr(self, key, self.AGENT_CONFIG[key])\n\n    def clean_agent_config_commands(self):\n        for command in self.commands:\n            friendly_name = command[0]\n            if friendly_name not in self.AGENT_CONFIG[\"commands\"]:\n                self.AGENT_CONFIG[\"commands\"][friendly_name] = False\n        for command in list(self.AGENT_CONFIG[\"commands\"]):\n            if command not in [cmd[0] for cmd in self.commands]:\n                del self.AGENT_CONFIG[\"commands\"][command]\n        with open(self.config_path, \"w\") as f:\n            json.dump(self.AGENT_CONFIG, f)\n\n    def get_commands_string(self):\n        if len(self.available_commands) == 0:\n            return None\n\n        enabled_commands = filter(\n            lambda command: command.get(\"enabled\", True), self.available_commands\n        )\n        if not enabled_commands:\n            return None\n\n        friendly_names = map(\n            lambda command: f\"`{command['friendly_name']}` - Arguments: {command['args']}\",\n            enabled_commands,\n        )\n        command_list = \"\\n\".join(friendly_names)\n        return f\"Commands Available To Complete Task:\\n{command_list}\\n\\n\"\n\n    def get_provider(self):\n        config_file = self.get_agent_config()\n        if \"provider\" in config_file:\n            return config_file[\"provider\"]\n        else:\n            return \"openai\"\n\n    def get_command_params(self, func):\n        params = {}\n        sig = signature(func)\n        for name, param in sig.parameters.items():\n            if param.default == Parameter.empty:\n                params[name] = None\n            else:\n                params[name] = param.default\n        return params\n\n    def load_commands(self):\n        commands = []\n        command_files = glob.glob(\"extensions/*.py\")\n        for command_file in command_files:\n            module_name = os.path.splitext(os.path.basename(command_file))[0]\n            module = importlib.import_module(f\"extensions.{module_name}\")\n            command_class = getattr(module, module_name.lower())()\n            if hasattr(command_class, \"commands\"):\n                for command_name, command_function in command_class.commands.items():\n                    params = self.get_command_params(command_function)\n                    commands.append((command_name, command_function.__name__, params))\n        return commands\n\n    def get_agent_config(self):\n        while True:\n            if os.path.exists(self.config_path):\n                try:\n                    with open(self.config_path, \"r\") as f:\n                        file_content = f.read().strip()\n                        if file_content:\n                            return json.loads(file_content)\n                except:\n                    None\n            add_agent(agent_name=self.agent_name)\n            return self.get_agent_config()\n\n    def update_agent_config(self, new_config, config_key):\n        if os.path.exists(self.config_path):\n            with open(self.config_path, \"r\") as f:\n                current_config = json.load(f)\n\n            # Ensure the config_key is present in the current configuration\n            if config_key not in current_config:\n                current_config[config_key] = {}\n\n            # Update the specified key with new_config while preserving other keys and values\n            for key, value in new_config.items():\n                current_config[config_key][key] = value\n\n            # Save the updated configuration back to the file\n            with open(self.config_path, \"w\") as f:\n                json.dump(current_config, f)\n            return f\"Agent {self.agent_name} configuration updated.\"\n        else:\n            return f\"Agent {self.agent_name} configuration not found.\"\n\n    def wipe_agent_memories(self):\n        memories_folder = os.path.normpath(\n            os.path.join(os.getcwd(), self.agent_name, \"memories\")\n        )\n        if not memories_folder.startswith(os.getcwd()):\n            raise ValueError(\"Invalid path, agent name must not contain slashes.\")\n\n        if os.path.exists(memories_folder):\n            shutil.rmtree(memories_folder)", ""]}
{"filename": "agixt/fb/Chain.py", "chunked_list": ["import os\nimport json\nimport logging\nfrom agixtsdk import AGiXTSDK\nfrom Extensions import Extensions\nfrom dotenv import load_dotenv\n\nload_dotenv()\nApiClient = AGiXTSDK(\n    base_uri=\"http://localhost:7437\", api_key=os.getenv(\"AGIXT_API_KEY\")", "ApiClient = AGiXTSDK(\n    base_uri=\"http://localhost:7437\", api_key=os.getenv(\"AGIXT_API_KEY\")\n)\n\n\ndef create_command_suggestion_chain(agent_name, command_name, command_args):\n    chain = Chain()\n    chains = chain.get_chains()\n    chain_name = f\"{agent_name} Command Suggestions\"\n    if chain_name in chains:\n        step = int(chain.get_chain(chain_name=chain_name)[\"steps\"][-1][\"step\"]) + 1\n    else:\n        chain.add_chain(chain_name=chain_name)\n        step = 1\n    chain.add_chain_step(\n        chain_name=chain_name,\n        agent_name=agent_name,\n        step_number=step,\n        prompt_type=\"Command\",\n        prompt={\n            \"command_name\": command_name,\n            **command_args,\n        },\n    )\n    return f\"The command has been added to a chain called '{agent_name} Command Suggestions' for you to review and execute manually.\"", "\n\ndef get_chain_file_path(chain_name):\n    base_path = os.path.join(os.getcwd(), \"chains\")\n    folder_path = os.path.normpath(os.path.join(base_path, chain_name))\n    file_path = os.path.normpath(os.path.join(base_path, f\"{chain_name}.json\"))\n    if not file_path.startswith(base_path) or not folder_path.startswith(base_path):\n        raise ValueError(\"Invalid path, chain name must not contain slashes.\")\n    if not os.path.exists(folder_path):\n        os.mkdir(folder_path)\n    return file_path", "\n\ndef get_chain_responses_file_path(chain_name):\n    base_path = os.path.join(os.getcwd(), \"chains\")\n    file_path = os.path.normpath(os.path.join(base_path, chain_name, \"responses.json\"))\n    if not file_path.startswith(base_path):\n        raise ValueError(\"Invalid path, chain name must not contain slashes.\")\n    return file_path\n\n\nclass Chain:\n    def import_chain(self, chain_name: str, steps: dict):\n        file_path = get_chain_file_path(chain_name=chain_name)\n        steps = steps[\"steps\"] if \"steps\" in steps else steps\n        with open(file_path, \"w\") as f:\n            json.dump({\"chain_name\": chain_name, \"steps\": steps}, f)\n        return f\"Chain '{chain_name}' imported.\"\n\n    def get_chain(self, chain_name):\n        try:\n            file_path = get_chain_file_path(chain_name=chain_name)\n            with open(file_path, \"r\") as f:\n                chain_data = json.load(f)\n            return chain_data\n        except:\n            return {}\n\n    def get_chains(self):\n        chains = [\n            f.replace(\".json\", \"\") for f in os.listdir(\"chains\") if f.endswith(\".json\")\n        ]\n        return chains\n\n    def add_chain(self, chain_name):\n        file_path = get_chain_file_path(chain_name=chain_name)\n        chain_data = {\"chain_name\": chain_name, \"steps\": []}\n        with open(file_path, \"w\") as f:\n            json.dump(chain_data, f)\n\n    def rename_chain(self, chain_name, new_name):\n        file_path = get_chain_file_path(chain_name=chain_name)\n        new_file_path = get_chain_file_path(chain_name=new_name)\n        os.rename(\n            os.path.join(file_path),\n            os.path.join(new_file_path),\n        )\n        chain_data = self.get_chain(chain_name=new_name)\n        chain_data[\"chain_name\"] = new_name\n        with open(new_file_path, \"w\") as f:\n            json.dump(chain_data, f)\n\n    def add_chain_step(self, chain_name, step_number, agent_name, prompt_type, prompt):\n        file_path = get_chain_file_path(chain_name=chain_name)\n        chain_data = self.get_chain(chain_name=chain_name)\n        chain_data[\"steps\"].append(\n            {\n                \"step\": step_number,\n                \"agent_name\": agent_name,\n                \"prompt_type\": prompt_type,\n                \"prompt\": prompt,\n            }\n        )\n        with open(file_path, \"w\") as f:\n            json.dump(chain_data, f)\n\n    def update_step(self, chain_name, step_number, agent_name, prompt_type, prompt):\n        file_path = get_chain_file_path(chain_name=chain_name)\n        chain_data = self.get_chain(chain_name=chain_name)\n        for step in chain_data[\"steps\"]:\n            if step[\"step\"] == step_number:\n                step[\"agent_name\"] = agent_name\n                step[\"prompt_type\"] = prompt_type\n                step[\"prompt\"] = prompt\n                break\n        with open(file_path, \"w\") as f:\n            json.dump(chain_data, f)\n\n    def delete_step(self, chain_name, step_number):\n        file_path = get_chain_file_path(chain_name=chain_name)\n        chain_data = self.get_chain(chain_name=chain_name)\n        chain_data[\"steps\"] = [\n            step for step in chain_data[\"steps\"] if step[\"step\"] != step_number\n        ]\n        with open(file_path, \"w\") as f:\n            json.dump(chain_data, f)\n\n    def delete_chain(self, chain_name):\n        file_path = get_chain_file_path(chain_name=chain_name)\n        os.remove(file_path)\n\n    def get_step(self, chain_name, step_number):\n        chain_data = self.get_chain(chain_name=chain_name)\n        for step in chain_data[\"steps\"]:\n            if step[\"step\"] == step_number:\n                return step\n        return None\n\n    def get_steps(self, chain_name):\n        chain_data = self.get_chain(chain_name=chain_name)\n        return chain_data[\"steps\"]\n\n    def move_step(self, chain_name, current_step_number, new_step_number):\n        file_path = get_chain_file_path(chain_name=chain_name)\n        chain_data = self.get_chain(chain_name=chain_name)\n        if not 1 <= new_step_number <= len(\n            chain_data[\"steps\"]\n        ) or current_step_number not in [step[\"step\"] for step in chain_data[\"steps\"]]:\n            print(f\"Error: Invalid step numbers.\")\n            return\n        moved_step = None\n        for step in chain_data[\"steps\"]:\n            if step[\"step\"] == current_step_number:\n                moved_step = step\n                chain_data[\"steps\"].remove(step)\n                break\n        for step in chain_data[\"steps\"]:\n            if new_step_number < current_step_number:\n                if new_step_number <= step[\"step\"] < current_step_number:\n                    step[\"step\"] += 1\n            else:\n                if current_step_number < step[\"step\"] <= new_step_number:\n                    step[\"step\"] -= 1\n        moved_step[\"step\"] = new_step_number\n        chain_data[\"steps\"].append(moved_step)\n        chain_data[\"steps\"] = sorted(chain_data[\"steps\"], key=lambda x: x[\"step\"])\n        with open(file_path, \"w\") as f:\n            json.dump(chain_data, f)\n\n    def get_step_response(self, chain_name, step_number=\"all\"):\n        file_path = get_chain_responses_file_path(chain_name=chain_name)\n        try:\n            with open(file_path, \"r\") as f:\n                responses = json.load(f)\n            if step_number == \"all\":\n                return responses\n            else:\n                data = responses.get(str(step_number))\n                if isinstance(data, dict) and \"response\" in data:\n                    data = data[\"response\"]\n                logging.info(f\"Step {step_number} response: {data}\")\n                return data\n        except:\n            return \"\"\n\n    def get_chain_responses(self, chain_name):\n        file_path = get_chain_responses_file_path(chain_name=chain_name)\n        try:\n            with open(file_path, \"r\") as f:\n                responses = json.load(f)\n            return responses\n        except:\n            return {}\n\n    def get_step_content(self, chain_name, prompt_content, user_input, agent_name):\n        if isinstance(prompt_content, dict):\n            new_prompt_content = {}\n            for arg, value in prompt_content.items():\n                if isinstance(value, str):\n                    if \"{user_input}\" in value:\n                        value = value.replace(\"{user_input}\", user_input)\n                    if \"{agent_name}\" in value:\n                        value = value.replace(\"{agent_name}\", agent_name)\n                    if \"{STEP\" in value:\n                        step_count = value.count(\"{STEP\")\n                        for i in range(step_count):\n                            new_step_number = int(value.split(\"{STEP\")[1].split(\"}\")[0])\n                            step_response = self.get_step_response(\n                                chain_name=chain_name, step_number=new_step_number\n                            )\n                            if step_response:\n                                resp = (\n                                    step_response[0]\n                                    if isinstance(step_response, list)\n                                    else step_response\n                                )\n                                value = value.replace(\n                                    f\"{{STEP{new_step_number}}}\", f\"{resp}\"\n                                )\n                new_prompt_content[arg] = value\n            return new_prompt_content\n        elif isinstance(prompt_content, str):\n            new_prompt_content = prompt_content\n            if \"{user_input}\" in prompt_content:\n                new_prompt_content = new_prompt_content.replace(\n                    \"{user_input}\", user_input\n                )\n            if \"{agent_name}\" in new_prompt_content:\n                new_prompt_content = new_prompt_content.replace(\n                    \"{agent_name}\", agent_name\n                )\n            if \"{STEP\" in prompt_content:\n                step_count = prompt_content.count(\"{STEP\")\n                for i in range(step_count):\n                    new_step_number = int(\n                        prompt_content.split(\"{STEP\")[1].split(\"}\")[0]\n                    )\n                    step_response = self.get_step_response(\n                        chain_name=chain_name, step_number=new_step_number\n                    )\n                    if step_response:\n                        resp = (\n                            step_response[0]\n                            if isinstance(step_response, list)\n                            else step_response\n                        )\n                        new_prompt_content = new_prompt_content.replace(\n                            f\"{{STEP{new_step_number}}}\", f\"{resp}\"\n                        )\n            return new_prompt_content\n        else:\n            return prompt_content\n\n    async def run_chain_step(\n        self, step: dict = {}, chain_name=\"\", user_input=\"\", agent_override=\"\"\n    ):\n        if step:\n            if \"prompt_type\" in step:\n                if agent_override != \"\":\n                    agent_name = agent_override\n                else:\n                    agent_name = step[\"agent_name\"]\n                prompt_type = step[\"prompt_type\"]\n                step_number = step[\"step\"]\n                if \"prompt_name\" in step[\"prompt\"]:\n                    prompt_name = step[\"prompt\"][\"prompt_name\"]\n                else:\n                    prompt_name = \"\"\n                args = self.get_step_content(\n                    chain_name=chain_name,\n                    prompt_content=step[\"prompt\"],\n                    user_input=user_input,\n                    agent_name=step[\"agent_name\"],\n                )\n                if \"conversation_name\" not in args:\n                    args[\"conversation_name\"] = f\"Chain Execution History: {chain_name}\"\n                if prompt_type == \"Command\":\n                    return await Extensions().execute_command(\n                        command_name=step[\"prompt\"][\"command_name\"], command_args=args\n                    )\n\n                elif prompt_type == \"Prompt\":\n                    result = ApiClient.prompt_agent(\n                        agent_name=agent_name,\n                        prompt_name=prompt_name,\n                        prompt_args={\n                            \"chain_name\": chain_name,\n                            \"step_number\": step_number,\n                            \"user_input\": user_input,\n                            **args,\n                        },\n                    )\n                elif prompt_type == \"Chain\":\n                    result = ApiClient.run_chain(\n                        chain_name=args[\"chain\"],\n                        user_input=args[\"input\"],\n                        agent_name=agent_name,\n                        all_responses=args[\"all_responses\"]\n                        if \"all_responses\" in args\n                        else False,\n                        from_step=args[\"from_step\"] if \"from_step\" in args else 1,\n                    )\n        if result:\n            if isinstance(result, dict) and \"response\" in result:\n                result = result[\"response\"]\n            if result == \"Unable to retrieve data.\":\n                result = None\n            return result\n        else:\n            return None\n\n    async def run_chain(\n        self,\n        chain_name,\n        user_input=None,\n        all_responses=True,\n        agent_override=\"\",\n        from_step=1,\n    ):\n        chain_data = ApiClient.get_chain(chain_name=chain_name)\n        if chain_data == {}:\n            return f\"Chain `{chain_name}` not found.\"\n        logging.info(f\"Running chain '{chain_name}'\")\n        responses = {}  # Create a dictionary to hold responses.\n        last_response = \"\"\n        for step_data in chain_data[\"steps\"]:\n            if int(step_data[\"step\"]) >= int(from_step):\n                if \"prompt\" in step_data and \"step\" in step_data:\n                    step = {}\n                    step[\"agent_name\"] = (\n                        agent_override\n                        if agent_override != \"\"\n                        else step_data[\"agent_name\"]\n                    )\n                    step[\"prompt_type\"] = step_data[\"prompt_type\"]\n                    step[\"prompt\"] = step_data[\"prompt\"]\n                    step[\"step\"] = step_data[\"step\"]\n                    logging.info(\n                        f\"Running step {step_data['step']} with agent {step['agent_name']}.\"\n                    )\n                    try:\n                        step_response = await self.run_chain_step(\n                            step=step,\n                            chain_name=chain_name,\n                            user_input=user_input,\n                            agent_override=agent_override,\n                        )  # Get the response of the current step.\n                    except Exception as e:\n                        logging.error(e)\n                        step_response = None\n                    if step_response == None:\n                        return f\"Chain failed to complete, it failed on step {step_data['step']}. You can resume by starting the chain from the step that failed.\"\n                    step[\"response\"] = step_response\n                    last_response = step_response\n                    logging.info(f\"Last response: {last_response}\")\n                    responses[step_data[\"step\"]] = step  # Store the response.\n                    logging.info(f\"Step {step_data['step']} response: {step_response}\")\n                    # Write the response to the chain responses file.\n                    file_path = get_chain_responses_file_path(chain_name=chain_name)\n                    with open(file_path, \"w\") as f:\n                        json.dump(responses, f)\n\n        if all_responses:\n            return responses\n        else:\n            # Return only the last response in the chain.\n            return last_response", "\n\nclass Chain:\n    def import_chain(self, chain_name: str, steps: dict):\n        file_path = get_chain_file_path(chain_name=chain_name)\n        steps = steps[\"steps\"] if \"steps\" in steps else steps\n        with open(file_path, \"w\") as f:\n            json.dump({\"chain_name\": chain_name, \"steps\": steps}, f)\n        return f\"Chain '{chain_name}' imported.\"\n\n    def get_chain(self, chain_name):\n        try:\n            file_path = get_chain_file_path(chain_name=chain_name)\n            with open(file_path, \"r\") as f:\n                chain_data = json.load(f)\n            return chain_data\n        except:\n            return {}\n\n    def get_chains(self):\n        chains = [\n            f.replace(\".json\", \"\") for f in os.listdir(\"chains\") if f.endswith(\".json\")\n        ]\n        return chains\n\n    def add_chain(self, chain_name):\n        file_path = get_chain_file_path(chain_name=chain_name)\n        chain_data = {\"chain_name\": chain_name, \"steps\": []}\n        with open(file_path, \"w\") as f:\n            json.dump(chain_data, f)\n\n    def rename_chain(self, chain_name, new_name):\n        file_path = get_chain_file_path(chain_name=chain_name)\n        new_file_path = get_chain_file_path(chain_name=new_name)\n        os.rename(\n            os.path.join(file_path),\n            os.path.join(new_file_path),\n        )\n        chain_data = self.get_chain(chain_name=new_name)\n        chain_data[\"chain_name\"] = new_name\n        with open(new_file_path, \"w\") as f:\n            json.dump(chain_data, f)\n\n    def add_chain_step(self, chain_name, step_number, agent_name, prompt_type, prompt):\n        file_path = get_chain_file_path(chain_name=chain_name)\n        chain_data = self.get_chain(chain_name=chain_name)\n        chain_data[\"steps\"].append(\n            {\n                \"step\": step_number,\n                \"agent_name\": agent_name,\n                \"prompt_type\": prompt_type,\n                \"prompt\": prompt,\n            }\n        )\n        with open(file_path, \"w\") as f:\n            json.dump(chain_data, f)\n\n    def update_step(self, chain_name, step_number, agent_name, prompt_type, prompt):\n        file_path = get_chain_file_path(chain_name=chain_name)\n        chain_data = self.get_chain(chain_name=chain_name)\n        for step in chain_data[\"steps\"]:\n            if step[\"step\"] == step_number:\n                step[\"agent_name\"] = agent_name\n                step[\"prompt_type\"] = prompt_type\n                step[\"prompt\"] = prompt\n                break\n        with open(file_path, \"w\") as f:\n            json.dump(chain_data, f)\n\n    def delete_step(self, chain_name, step_number):\n        file_path = get_chain_file_path(chain_name=chain_name)\n        chain_data = self.get_chain(chain_name=chain_name)\n        chain_data[\"steps\"] = [\n            step for step in chain_data[\"steps\"] if step[\"step\"] != step_number\n        ]\n        with open(file_path, \"w\") as f:\n            json.dump(chain_data, f)\n\n    def delete_chain(self, chain_name):\n        file_path = get_chain_file_path(chain_name=chain_name)\n        os.remove(file_path)\n\n    def get_step(self, chain_name, step_number):\n        chain_data = self.get_chain(chain_name=chain_name)\n        for step in chain_data[\"steps\"]:\n            if step[\"step\"] == step_number:\n                return step\n        return None\n\n    def get_steps(self, chain_name):\n        chain_data = self.get_chain(chain_name=chain_name)\n        return chain_data[\"steps\"]\n\n    def move_step(self, chain_name, current_step_number, new_step_number):\n        file_path = get_chain_file_path(chain_name=chain_name)\n        chain_data = self.get_chain(chain_name=chain_name)\n        if not 1 <= new_step_number <= len(\n            chain_data[\"steps\"]\n        ) or current_step_number not in [step[\"step\"] for step in chain_data[\"steps\"]]:\n            print(f\"Error: Invalid step numbers.\")\n            return\n        moved_step = None\n        for step in chain_data[\"steps\"]:\n            if step[\"step\"] == current_step_number:\n                moved_step = step\n                chain_data[\"steps\"].remove(step)\n                break\n        for step in chain_data[\"steps\"]:\n            if new_step_number < current_step_number:\n                if new_step_number <= step[\"step\"] < current_step_number:\n                    step[\"step\"] += 1\n            else:\n                if current_step_number < step[\"step\"] <= new_step_number:\n                    step[\"step\"] -= 1\n        moved_step[\"step\"] = new_step_number\n        chain_data[\"steps\"].append(moved_step)\n        chain_data[\"steps\"] = sorted(chain_data[\"steps\"], key=lambda x: x[\"step\"])\n        with open(file_path, \"w\") as f:\n            json.dump(chain_data, f)\n\n    def get_step_response(self, chain_name, step_number=\"all\"):\n        file_path = get_chain_responses_file_path(chain_name=chain_name)\n        try:\n            with open(file_path, \"r\") as f:\n                responses = json.load(f)\n            if step_number == \"all\":\n                return responses\n            else:\n                data = responses.get(str(step_number))\n                if isinstance(data, dict) and \"response\" in data:\n                    data = data[\"response\"]\n                logging.info(f\"Step {step_number} response: {data}\")\n                return data\n        except:\n            return \"\"\n\n    def get_chain_responses(self, chain_name):\n        file_path = get_chain_responses_file_path(chain_name=chain_name)\n        try:\n            with open(file_path, \"r\") as f:\n                responses = json.load(f)\n            return responses\n        except:\n            return {}\n\n    def get_step_content(self, chain_name, prompt_content, user_input, agent_name):\n        if isinstance(prompt_content, dict):\n            new_prompt_content = {}\n            for arg, value in prompt_content.items():\n                if isinstance(value, str):\n                    if \"{user_input}\" in value:\n                        value = value.replace(\"{user_input}\", user_input)\n                    if \"{agent_name}\" in value:\n                        value = value.replace(\"{agent_name}\", agent_name)\n                    if \"{STEP\" in value:\n                        step_count = value.count(\"{STEP\")\n                        for i in range(step_count):\n                            new_step_number = int(value.split(\"{STEP\")[1].split(\"}\")[0])\n                            step_response = self.get_step_response(\n                                chain_name=chain_name, step_number=new_step_number\n                            )\n                            if step_response:\n                                resp = (\n                                    step_response[0]\n                                    if isinstance(step_response, list)\n                                    else step_response\n                                )\n                                value = value.replace(\n                                    f\"{{STEP{new_step_number}}}\", f\"{resp}\"\n                                )\n                new_prompt_content[arg] = value\n            return new_prompt_content\n        elif isinstance(prompt_content, str):\n            new_prompt_content = prompt_content\n            if \"{user_input}\" in prompt_content:\n                new_prompt_content = new_prompt_content.replace(\n                    \"{user_input}\", user_input\n                )\n            if \"{agent_name}\" in new_prompt_content:\n                new_prompt_content = new_prompt_content.replace(\n                    \"{agent_name}\", agent_name\n                )\n            if \"{STEP\" in prompt_content:\n                step_count = prompt_content.count(\"{STEP\")\n                for i in range(step_count):\n                    new_step_number = int(\n                        prompt_content.split(\"{STEP\")[1].split(\"}\")[0]\n                    )\n                    step_response = self.get_step_response(\n                        chain_name=chain_name, step_number=new_step_number\n                    )\n                    if step_response:\n                        resp = (\n                            step_response[0]\n                            if isinstance(step_response, list)\n                            else step_response\n                        )\n                        new_prompt_content = new_prompt_content.replace(\n                            f\"{{STEP{new_step_number}}}\", f\"{resp}\"\n                        )\n            return new_prompt_content\n        else:\n            return prompt_content\n\n    async def run_chain_step(\n        self, step: dict = {}, chain_name=\"\", user_input=\"\", agent_override=\"\"\n    ):\n        if step:\n            if \"prompt_type\" in step:\n                if agent_override != \"\":\n                    agent_name = agent_override\n                else:\n                    agent_name = step[\"agent_name\"]\n                prompt_type = step[\"prompt_type\"]\n                step_number = step[\"step\"]\n                if \"prompt_name\" in step[\"prompt\"]:\n                    prompt_name = step[\"prompt\"][\"prompt_name\"]\n                else:\n                    prompt_name = \"\"\n                args = self.get_step_content(\n                    chain_name=chain_name,\n                    prompt_content=step[\"prompt\"],\n                    user_input=user_input,\n                    agent_name=step[\"agent_name\"],\n                )\n                if \"conversation_name\" not in args:\n                    args[\"conversation_name\"] = f\"Chain Execution History: {chain_name}\"\n                if prompt_type == \"Command\":\n                    return await Extensions().execute_command(\n                        command_name=step[\"prompt\"][\"command_name\"], command_args=args\n                    )\n\n                elif prompt_type == \"Prompt\":\n                    result = ApiClient.prompt_agent(\n                        agent_name=agent_name,\n                        prompt_name=prompt_name,\n                        prompt_args={\n                            \"chain_name\": chain_name,\n                            \"step_number\": step_number,\n                            \"user_input\": user_input,\n                            **args,\n                        },\n                    )\n                elif prompt_type == \"Chain\":\n                    result = ApiClient.run_chain(\n                        chain_name=args[\"chain\"],\n                        user_input=args[\"input\"],\n                        agent_name=agent_name,\n                        all_responses=args[\"all_responses\"]\n                        if \"all_responses\" in args\n                        else False,\n                        from_step=args[\"from_step\"] if \"from_step\" in args else 1,\n                    )\n        if result:\n            if isinstance(result, dict) and \"response\" in result:\n                result = result[\"response\"]\n            if result == \"Unable to retrieve data.\":\n                result = None\n            return result\n        else:\n            return None\n\n    async def run_chain(\n        self,\n        chain_name,\n        user_input=None,\n        all_responses=True,\n        agent_override=\"\",\n        from_step=1,\n    ):\n        chain_data = ApiClient.get_chain(chain_name=chain_name)\n        if chain_data == {}:\n            return f\"Chain `{chain_name}` not found.\"\n        logging.info(f\"Running chain '{chain_name}'\")\n        responses = {}  # Create a dictionary to hold responses.\n        last_response = \"\"\n        for step_data in chain_data[\"steps\"]:\n            if int(step_data[\"step\"]) >= int(from_step):\n                if \"prompt\" in step_data and \"step\" in step_data:\n                    step = {}\n                    step[\"agent_name\"] = (\n                        agent_override\n                        if agent_override != \"\"\n                        else step_data[\"agent_name\"]\n                    )\n                    step[\"prompt_type\"] = step_data[\"prompt_type\"]\n                    step[\"prompt\"] = step_data[\"prompt\"]\n                    step[\"step\"] = step_data[\"step\"]\n                    logging.info(\n                        f\"Running step {step_data['step']} with agent {step['agent_name']}.\"\n                    )\n                    try:\n                        step_response = await self.run_chain_step(\n                            step=step,\n                            chain_name=chain_name,\n                            user_input=user_input,\n                            agent_override=agent_override,\n                        )  # Get the response of the current step.\n                    except Exception as e:\n                        logging.error(e)\n                        step_response = None\n                    if step_response == None:\n                        return f\"Chain failed to complete, it failed on step {step_data['step']}. You can resume by starting the chain from the step that failed.\"\n                    step[\"response\"] = step_response\n                    last_response = step_response\n                    logging.info(f\"Last response: {last_response}\")\n                    responses[step_data[\"step\"]] = step  # Store the response.\n                    logging.info(f\"Step {step_data['step']} response: {step_response}\")\n                    # Write the response to the chain responses file.\n                    file_path = get_chain_responses_file_path(chain_name=chain_name)\n                    with open(file_path, \"w\") as f:\n                        json.dump(responses, f)\n\n        if all_responses:\n            return responses\n        else:\n            # Return only the last response in the chain.\n            return last_response", ""]}
{"filename": "agixt/fb/Prompts.py", "chunked_list": ["import os\n\n\ndef get_prompt_file_path(prompt_name, prompt_category=\"Default\"):\n    base_path = os.path.join(os.getcwd(), \"prompts\")\n    base_model_path = os.path.normpath(\n        os.path.join(os.getcwd(), \"prompts\", prompt_category)\n    )\n    model_prompt_file = os.path.normpath(\n        os.path.join(base_model_path, f\"{prompt_name}.txt\")\n    )\n    default_prompt_file = os.path.normpath(\n        os.path.join(base_path, \"Default\", f\"{prompt_name}.txt\")\n    )\n    if (\n        not base_model_path.startswith(base_path)\n        or not model_prompt_file.startswith(base_model_path)\n        or not default_prompt_file.startswith(base_path)\n    ):\n        raise ValueError(\n            \"Invalid file path. Prompt name cannot contain '/', '\\\\' or '..' in\"\n        )\n    if not os.path.exists(base_path):\n        os.mkdir(base_path)\n    if not os.path.exists(base_model_path):\n        os.mkdir(base_model_path)\n    prompt_file = (\n        model_prompt_file if os.path.isfile(model_prompt_file) else default_prompt_file\n    )\n    return prompt_file", "\n\nclass Prompts:\n    def add_prompt(self, prompt_name, prompt, prompt_category_name=\"Default\"):\n        # if prompts folder does not exist, create it\n        file_path = get_prompt_file_path(\n            prompt_name=prompt_name, prompt_category=prompt_category_name\n        )\n        # if prompt file does not exist, create it\n        if not os.path.exists(file_path):\n            with open(file_path, \"w\") as f:\n                f.write(prompt)\n\n    def get_prompt(self, prompt_name, prompt_category=\"Default\"):\n        prompt_file = get_prompt_file_path(\n            prompt_name=prompt_name, prompt_category=prompt_category\n        )\n        with open(prompt_file, \"r\") as f:\n            prompt = f.read()\n        return prompt\n\n    def get_prompts(self):\n        # Get all files in prompts folder that end in .txt and replace .txt with empty string\n        prompts = []\n        # For each folder in prompts folder, get all files that end in .txt and replace .txt with empty string\n        for folder in os.listdir(\"prompts\"):\n            if os.path.isdir(os.path.join(\"prompts\", folder)):\n                for file in os.listdir(os.path.join(\"prompts\", folder)):\n                    if file.endswith(\".txt\"):\n                        prompts.append(file.replace(\".txt\", \"\"))\n        return prompts\n\n    def get_prompt_args(self, prompt_text):\n        # Find anything in the file between { and } and add them to a list to return\n        prompt_vars = []\n        for word in prompt_text.split():\n            if word.startswith(\"{\") and word.endswith(\"}\"):\n                prompt_vars.append(word[1:-1])\n        return prompt_vars\n\n    def delete_prompt(self, prompt_name):\n        prompt_file = get_prompt_file_path(prompt_name=prompt_name)\n        os.remove(prompt_file)\n\n    def update_prompt(self, prompt_name, prompt):\n        prompt_file = get_prompt_file_path(prompt_name=prompt_name)\n        with open(prompt_file, \"w\") as f:\n            f.write(prompt)\n\n    def rename_prompt(self, prompt_name, new_prompt_name):\n        prompt_file = get_prompt_file_path(prompt_name=prompt_name)\n        new_prompt_file = get_prompt_file_path(prompt_name=new_prompt_name)\n        os.rename(prompt_file, new_prompt_file)", ""]}
