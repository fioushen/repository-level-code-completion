{"filename": "setup.py", "chunked_list": ["from setuptools import setup\nimport re\n\n\nwith open('src/xman/__init__.py') as f:\n    version_match = re.search(r'^__version__\\s*=\\s*[\\'\"]([^\\'\"]*)[\\'\"]', f.read(), re.MULTILINE)\n    if version_match:\n        version = version_match.group(1)\n    else:\n        raise RuntimeError(\"Version not found!\")", "\n\nwith open('src/requirements.txt') as f:\n    requirements = f.read().splitlines()\n\n\nsetup(\n    name='xMan',\n    version=version,\n    packages=['xman'],", "    version=version,\n    packages=['xman'],\n    package_dir={'': 'src'},\n    url='https://github.com/wolfhoundgelert/xman',\n    license='BSD 3-clause',\n    author='Andrei Polkanov',\n    author_email='andrey.polkanoff@gmail.com',\n    description='xMan - Experiment Manager, python library for effective management and organising '\n                'experiments on th\u0435 Google Colab platform with sharing and running in parallel '\n                'across different Colab accounts.',", "                'experiments on th\u0435 Google Colab platform with sharing and running in parallel '\n                'across different Colab accounts.',\n    install_requires=requirements,\n)\n\n\n# TODO https://github.com/pypi/support/issues/2738\n"]}
{"filename": "test/test_util.py", "chunked_list": ["import pytest\n\nfrom xman import util\nfrom xman.error import ArgumentsXManError\n\n\ndef test__check_has_value_in_class_public_constants():\n    class TestClass:\n        CONST1 = 'CONST1'\n        CONST2 = 'CONST2'\n    util.check_has_value_in_class_public_constants(TestClass.CONST1, TestClass)\n    util.check_has_value_in_class_public_constants(TestClass.CONST2, TestClass)\n    with pytest.raises(ArgumentsXManError, match=f\"Wrong value `{'CONST_THAT_DOES_NOT_EXISTS'}`\"):\n        util.check_has_value_in_class_public_constants('CONST_THAT_DOES_NOT_EXISTS', TestClass)", ""]}
{"filename": "test/test_filter.py", "chunked_list": ["# TODO filter.exps() and filter.groups()\n\nfrom xman import xman\nimport helper\n\n\ndef test__sorted_exps():\n    helper.make_proj_from_nothing()\n    xman.make_group('G1', 'G1 descr')\n    e1 = xman.make_exp('G1', 'G1 E1', 'G1 E1 descr')\n    e2 = xman.make_exp('G1', 'G1 E2', 'G1 E2 descr')\n    xman.make_group('G2', 'G2 descr')\n    e3 = xman.make_exp('G2', 'G2 E1', 'G2 E1 descr')\n    e4 = xman.make_exp('G2', 'G2 E2', 'G2 E2 descr')\n    exps = xman.exps()\n    assert exps == [e1, e2, e3, e4]", "\n\ndef test__sorted_groups():\n    helper.make_proj_from_nothing()\n    g1 = xman.make_group('G1', 'G1 descr')\n    g2 = xman.make_group('G2', 'G2 descr')\n    groups = xman.groups()\n    assert groups == [g1, g2]\n\n", "\n"]}
{"filename": "test/test_api.py", "chunked_list": ["\"\"\"\ndef check_api(class_one, class_two, excluding_list=None, including_list=None) -> Tuple[List, List]:\n\n- Check only public methods and properties, that everything exists in both classes.\n- For each pair check that signatures are the same.\n- Excluding list for public methods and properties that not needed to check.\n- Including list for adding protected methods and properties for the check.\n\nReturns: absentee list and list with difference in signatures\n\"\"\"", "Returns: absentee list and list with difference in signatures\n\"\"\"\nimport inspect\nfrom typing import Tuple, List, Callable, Optional\nimport re\nimport pytest\n\nfrom xman import XManAPI\nfrom xman.api import ExpAPI, ExpStructAPI, ExpGroupAPI, ExpProjAPI\nfrom xman.error import ArgumentsXManError", "from xman.api import ExpAPI, ExpStructAPI, ExpGroupAPI, ExpProjAPI\nfrom xman.error import ArgumentsXManError\nfrom xman.exp import Exp\nfrom xman.group import ExpGroup\nfrom xman.proj import ExpProj\nfrom xman.struct import ExpStruct\n\n\ndef get_public_members(cls) -> List[str]:\n    return [member for member in dir(cls) if not member.startswith(('_', '__'))]", "def get_public_members(cls) -> List[str]:\n    return [member for member in dir(cls) if not member.startswith(('_', '__'))]\n\n\ndef get_normalized_signature_str(member: Callable | property) -> str:\n    sig = str(inspect.signature(member))\n    sig = re.sub(r'\\bxman\\.\\w+\\.Exp', 'Exp', sig)\n    sig = re.sub(r'\\b(Exp\\w*)API\\b', r'\\1', sig)\n    sig = re.sub(r\"'\", '', sig)\n    return sig", "\n\ndef is_equal_signatures(member_one: Callable | property, member_two: Callable | property) -> bool:\n    one_exists = member_one is not None\n    two_exists = member_two is not None\n    if not one_exists and not two_exists:\n        raise ArgumentsXManError(\n            f\"Both `member_one` and `member_two` are None - shouldn't be like that!\")\n    if one_exists != two_exists:\n        return False\n    one_is_prop = isinstance(member_one, property)\n    two_is_prop = isinstance(member_two, property)\n    if one_is_prop != two_is_prop:\n        return False\n    if one_is_prop:\n        one_has_setter = member_one.fset is not None\n        two_has_setter = member_two.fset is not None\n        if one_has_setter != two_has_setter:\n            return False\n        if one_has_setter and \\\n                get_normalized_signature_str(member_one.fset) != \\\n                get_normalized_signature_str(member_two.fset):\n            return False\n        return get_normalized_signature_str(member_one.fget) == \\\n            get_normalized_signature_str(member_two.fget)\n    else:\n        return get_normalized_signature_str(member_one) == \\\n            get_normalized_signature_str(member_two)", "\n\n# TODO Add checking on annotation and returning value if returns smt\ndef check_api(class_one, class_two, excluding_list: List[str] = None,\n              including_list: List[str] = None) -> Optional[Tuple[str, List[str], List[str]]]:\n    one_set = set(get_public_members(class_one))\n    two_set = set(get_public_members(class_two))\n    excluding_set = set([] if excluding_list is None else excluding_list)\n    including_set = set([] if including_list is None else including_list)\n    if len(cross_set := excluding_set & including_set) > 0:\n        raise ArgumentsXManError(\n            f\"Members {cross_set} can't be in both `excluding_list` and `including_list\")\n    for member in (excluding_set | including_set) - (one_set | two_set):\n        if not hasattr(class_one, member) and not hasattr(class_two, member):\n            raise ArgumentsXManError(\n                f\"Member `{member}` doesn't exist neither in `{class_one}` or `{class_two}\")\n    existence_diff_set = (one_set ^ two_set) - excluding_set\n    common_set = (one_set & two_set) - excluding_set\n    for member in including_set:\n        one_has = hasattr(class_one, member)\n        two_has = hasattr(class_two, member)\n        if one_has == two_has == False:\n            raise ArgumentsXManError(\n                f\"`{member}` doesn't exist in either `class_one` or `class_two`!\")\n        elif one_has == two_has == True:\n            common_set.add(member)\n        else:\n            existence_diff_set.add(member)\n    signatures_diff_set = set()\n    for member in common_set:\n        is_equal = is_equal_signatures(getattr(class_one, member), getattr(class_two, member))\n        if not is_equal:\n            signatures_diff_set.add(member)\n    if len(existence_diff_set) or len(signatures_diff_set):\n        not_exist = []\n        for it in existence_diff_set:\n            it_str = f\"{(class_two if it in one_set else class_one).__name__}:{it}\"\n            not_exist.append(it_str)\n        signatures = list(signatures_diff_set)\n        info = f\"\\n\\nAPI CHECKING REPORT:\\nNot exist: {not_exist}\\n\" \\\n               f\"Different signatures: {signatures}\\n\"\n        return info, list(existence_diff_set), signatures\n    return None", "\n\ndef test__get_public_members():\n    class A:\n        @staticmethod\n        def sm(): pass\n        @staticmethod\n        def _sm(): pass\n        @staticmethod\n        def __sm(): pass\n\n        @property\n        def p(self): pass\n        @property\n        def _p(self): pass\n        @property\n        def __p(self): pass\n\n        def m(self): pass\n        def _m(self): pass\n        def __m(self): pass\n\n    lst = get_public_members(A)\n    assert len(lst) == 3 and set(lst) == set(['sm', 'p', 'm'])", "\n\ndef test__get_normalized_signature_str():\n    def foo(param1: ExpStructAPI, param2: ExpAPI) -> ExpGroupAPI: pass\n    def bar(param1: ExpStruct, param2: Exp) -> ExpGroup: pass\n    def biz(param1: ExpStructAPI, param2: ExpProjAPI) -> ExpGroupAPI: pass\n    assert get_normalized_signature_str(foo) == get_normalized_signature_str(bar)\n    assert get_normalized_signature_str(biz) != get_normalized_signature_str(bar)\n\n\ndef test__is_equal_signatures():\n    def a(): pass\n    def b(): pass\n    assert is_equal_signatures(a, b)\n\n    def a(): pass\n    def b() -> bool: pass\n    assert not is_equal_signatures(a, b)\n\n    def a(): pass\n    def b(foo: int): pass\n    assert not is_equal_signatures(a, b)\n\n    def a(bar: int): pass\n    def b(foo: int): pass\n    assert not is_equal_signatures(a, b)\n\n    def a(foo: int): pass\n    def b(foo: int): pass\n    assert is_equal_signatures(a, b)\n\n    class A:\n        @property\n        def foo(self): pass\n        @foo.setter\n        def foo(self, value): pass\n\n        @property\n        def bar(self): pass\n        @bar.setter\n        def bar(self, value): pass\n\n        @property\n        def biz(self): pass\n        @bar.setter\n        def biz(self, value): pass\n\n    class B:\n        @property\n        def foo(self): pass\n        @foo.setter\n        def foo(self, value): pass\n\n        @property\n        def bar(self): pass\n        @bar.setter\n        def bar(self, value) -> bool: pass\n\n        @property\n        def biz(self): pass\n\n    assert is_equal_signatures(A.foo, B.foo)\n    assert not is_equal_signatures(A.bar, B.bar)\n    assert not is_equal_signatures(A.biz, B.biz)\n    assert not is_equal_signatures(A.foo, None)\n    with pytest.raises(ArgumentsXManError, match=\"are None\"):\n        is_equal_signatures(None, None)", "\n\ndef test__is_equal_signatures():\n    def a(): pass\n    def b(): pass\n    assert is_equal_signatures(a, b)\n\n    def a(): pass\n    def b() -> bool: pass\n    assert not is_equal_signatures(a, b)\n\n    def a(): pass\n    def b(foo: int): pass\n    assert not is_equal_signatures(a, b)\n\n    def a(bar: int): pass\n    def b(foo: int): pass\n    assert not is_equal_signatures(a, b)\n\n    def a(foo: int): pass\n    def b(foo: int): pass\n    assert is_equal_signatures(a, b)\n\n    class A:\n        @property\n        def foo(self): pass\n        @foo.setter\n        def foo(self, value): pass\n\n        @property\n        def bar(self): pass\n        @bar.setter\n        def bar(self, value): pass\n\n        @property\n        def biz(self): pass\n        @bar.setter\n        def biz(self, value): pass\n\n    class B:\n        @property\n        def foo(self): pass\n        @foo.setter\n        def foo(self, value): pass\n\n        @property\n        def bar(self): pass\n        @bar.setter\n        def bar(self, value) -> bool: pass\n\n        @property\n        def biz(self): pass\n\n    assert is_equal_signatures(A.foo, B.foo)\n    assert not is_equal_signatures(A.bar, B.bar)\n    assert not is_equal_signatures(A.biz, B.biz)\n    assert not is_equal_signatures(A.foo, None)\n    with pytest.raises(ArgumentsXManError, match=\"are None\"):\n        is_equal_signatures(None, None)", "\n\ndef test__check_api():\n    class A:\n        @staticmethod\n        def sm(): pass\n        @property\n        def p(self): pass\n        def m(self, param: int): pass\n        def foo(self): pass\n        def _bar(self) -> str: pass\n\n    class B:\n        @staticmethod\n        def sm(): pass\n        def m(self, param: str): pass\n        def _bar(self, param: bool) -> str: pass\n\n    info, existence_diff, signatures_diff = check_api(A, B, ['foo'], ['_bar'])\n    assert info is not None\n    assert set(existence_diff) == set(['p'])\n    assert set(signatures_diff) == set(['m', '_bar'])", "\n\ndef test__ExpStruct():\n    excludes = ['parent', 'api', 'info']\n    result = check_api(ExpStruct, ExpStructAPI, excludes)\n    if result is not None:\n        info, _, _ = result\n        print(info)\n        assert False\n", "\n\ndef test__Exp():\n    excludes = ['parent', 'api', 'info']\n    result = check_api(Exp, ExpAPI, excludes)\n    if result is not None:\n        info, _, _ = result\n        print(info)\n        assert False\n", "\n\ndef test__ExpGroup():\n    excludes = ['parent', 'api', 'make_child', 'has_child', 'num_children', 'change_child_num',\n                'children_nums', 'child', 'children', 'delete_child', 'children_names', 'info']\n    result = check_api(ExpGroup, ExpGroupAPI, excludes)\n    if result is not None:\n        info, _, _ = result\n        print(info)\n        assert False", "\n\ndef test__ExpProj():\n    excludes = ['parent', 'api', 'make_child', 'has_child', 'num_children', 'change_child_num',\n                'children_nums', 'child', 'children', 'delete_child', 'children_names', 'info']\n    result = check_api(ExpProj, ExpProjAPI, excludes)\n    if result is not None:\n        info, _, _ = result\n        print(info)\n        assert False", "\n\ndef test__ExpProjAPI_vs_XManAPI():\n    excludes = ['move_exp', 'delete_dir', 'is_manual', 'name', 'make_dir', 'rename_or_move_dir',\n                'num_groups', 'descr', 'num_exps', 'note', 'dir_tree', 'make_proj', 'num',\n                'set_manual_status', 'groups_nums', 'result_viewer', 'load_proj', 'edit', 'fail',\n                'reload', 'exps_names', 'exps_nums', 'proj', 'status', 'success', 'tree',\n                'delete_manual_status', 'groups_names', 'change_group_num', 'result_stringifier']\n    result = check_api(ExpProjAPI, XManAPI, excludes)\n    if result is not None:\n        info, _, _ = result\n        print(info)\n        assert False", ""]}
{"filename": "test/test_.py", "chunked_list": ["import os\nimport sys\n\nimport pytest\n\n\n# def test__xman_init():  # Just for adding xman's `src` to paths and config `is_pytest` setting\n#     xman_path = os.path.abspath(os.path.join('src'))\n#     if xman_path not in sys.path:\n#         sys.path.insert(0, xman_path)", "#     if xman_path not in sys.path:\n#         sys.path.insert(0, xman_path)\n#         # sys.path.remove(xman_path)\n#     config.set__is_pytest(True)\n\n\nfrom xman.error import AlreadyExistsXManError\nfrom xman.exp import Exp\nfrom xman.pipeline import CheckpointsMediator\nfrom xman import xman, filesystem", "from xman.pipeline import CheckpointsMediator\nfrom xman import xman, filesystem\nfrom xman.filesystem import FileType\nfrom xman import config\nimport helper\n\n\ndef test__config():\n    config.set__is_pytest(True)\n    assert config.is_pytest\n    assert config.confirm_off", "\n\ndef test__change_exp_num():\n    exp = helper.make_exp_from_nothing()\n    group = exp.group\n    group.make_exp('New Exp', 'New exp descr')\n    with pytest.raises(AlreadyExistsXManError, match=\"is already taken by other child\"):\n        group.change_exp_num(1, 2)\n    group.change_exp_num(1, 3)\n    assert group.exp(3) is exp", "\n\ndef test__change_group_num():\n    group = helper.make_group_from_nothing()\n    proj = group.proj\n    proj.make_group('New Group', 'New group descr')\n    with pytest.raises(AlreadyExistsXManError, match=\"is already taken by other child\"):\n        proj.change_group_num(1, 2)\n    proj.change_group_num(1, 3)\n    assert proj.group(3) is group", "\n\ndef test__make_proj():\n    proj = helper.make_proj_from_nothing()\n    assert proj.name == 'Test Proj' and xman.proj.descr == 'Test proj descr'\n\n\ndef test__pipeline():\n    exp = helper.make_exp_from_nothing().make_pipeline(helper.train, helper.train_params, True).\\\n        start()\n    assert exp.result == helper.train_result", "\n\ndef test__pipeline_with_checkpoints():\n    exp = helper.make_exp_from_nothing().make_pipeline_with_checkpoints(\n        helper.train_with_mediator, helper.train_params, True).start()\n    assert exp.result == helper.train_result\n    exp = helper.make_exp_from_nothing().make_pipeline_with_checkpoints(\n        helper.train_with_mediator_replace, helper.train_params, True).start()\n    assert exp.result == helper.train_result\n    exp.delete_checkpoints(need_confirm=False)\n    assert not filesystem.has_checkpoints_dir(exp.location_dir)\n    exp = helper.make_exp_from_nothing().make_pipeline_with_checkpoints(\n        helper.train_with_mediator_custom_path, helper.train_params, True).start()\n    assert os.path.exists(os.path.join(exp.location_dir, 'custom/first.cp'))\n    assert os.path.exists(os.path.join(exp.location_dir, 'custom/second.cp'))\n    exp.delete_checkpoints(need_confirm=False, delete_custom_paths=False)\n    assert os.path.exists(os.path.join(exp.location_dir, 'custom/first.cp'))\n    assert os.path.exists(os.path.join(exp.location_dir, 'custom/second.cp'))\n    exp = helper.make_exp_from_nothing().make_pipeline_with_checkpoints(\n        helper.train_with_mediator_custom_path, helper.train_params, True).start()\n    exp.delete_checkpoints(need_confirm=False, delete_custom_paths=True)\n    assert not os.path.exists(os.path.join(exp.location_dir, 'custom/first.cp'))\n    assert not os.path.exists(os.path.join(exp.location_dir, 'custom/second.cp'))", "\n\ndef test__destroy_group():\n    config.set__is_pytest(True)\n    helper.make_exp_from_nothing()\n    xman.delete_group(1)\n    assert xman.proj.num_groups() == 0\n\n\ndef test__destroy_exp():\n    config.set__is_pytest(True)\n    helper.make_exp_from_nothing()\n    xman.group(1).delete_exp(1)\n    assert xman.group(1).num_exps() == 0", "\ndef test__destroy_exp():\n    config.set__is_pytest(True)\n    helper.make_exp_from_nothing()\n    xman.group(1).delete_exp(1)\n    assert xman.group(1).num_exps() == 0\n\n\ndef test__destroy_exp_after_pipeline_done():\n    config.set__is_pytest(True)\n    helper.make_exp_from_nothing().make_pipeline(helper.train, helper.train_params, True).start()\n    xman.group(1).delete_exp(1)\n    assert xman.group(1).num_exps() == 0", "def test__destroy_exp_after_pipeline_done():\n    config.set__is_pytest(True)\n    helper.make_exp_from_nothing().make_pipeline(helper.train, helper.train_params, True).start()\n    xman.group(1).delete_exp(1)\n    assert xman.group(1).num_exps() == 0\n\n\ndef test__getting_exp():\n    exp = helper.make_exp_from_nothing(num=10)\n    assert exp.num == 10\n    assert xman.proj.exp(1, 10) is exp\n    assert xman.proj.group(1).exp(10) is exp\n    assert xman.exp(1, 10) is exp\n    assert xman.group(1).exp(10) is exp\n    exp = helper.make_exp_from_nothing(num=10)\n    assert xman.proj.exp('Test Group', 'Test Exp') is exp\n    assert xman.proj.group('Test Group').exp('Test Exp') is exp\n    assert xman.exp('Test Group', 'Test Exp') is exp", "\n\ndef test__move_exp():\n    exp = helper.make_exp_from_nothing()\n    exp.proj.make_group('New Group', 'New group descr')\n    xman.proj.move_exp(1, 1, 2, 3)\n    assert not xman.group(1).has_exp(1) and xman.group(2).has_exp(3) and xman.group(2).exp(3) is exp\n\n\n# TODO add other params and separate on different tests (one for each param)\ndef test__filter_exps_in_group():\n    group = helper.make_group_from_nothing()\n    for i in range(3):\n        group.make_exp(f\"Exp {i + 1}\", \"Descr\")\n    exp = xman.exp(1, 2)\n\n    class MockExp(Exp):\n        is_ready_for_start = True\n\n    exp._obj.__class__ = MockExp\n    readies = group.filter_exps(is_ready_for_start=True)\n    assert len(readies) == 1 and readies[0] is exp\n\n    class MockExp(Exp):\n        is_active = True\n\n    exp._obj.__class__ = MockExp\n    actives = group.filter_exps(is_active=True)\n    assert len(actives) == 1 and actives[0] is exp\n    xman.exp(1, 1).set_manual_status('DONE', \"It's done.\")\n    manuals = xman.group(1).filter_exps(is_manual=True)\n    assert len(manuals) == 1 and manuals[0] is xman.exp(1, 1)\n    all_falses = xman.group(1).filter_exps(is_active=False, is_manual=False)\n    assert len(all_falses) == 1 and all_falses[0] is xman.exp(1, 3)", "\n# TODO add other params and separate on different tests (one for each param)\ndef test__filter_exps_in_group():\n    group = helper.make_group_from_nothing()\n    for i in range(3):\n        group.make_exp(f\"Exp {i + 1}\", \"Descr\")\n    exp = xman.exp(1, 2)\n\n    class MockExp(Exp):\n        is_ready_for_start = True\n\n    exp._obj.__class__ = MockExp\n    readies = group.filter_exps(is_ready_for_start=True)\n    assert len(readies) == 1 and readies[0] is exp\n\n    class MockExp(Exp):\n        is_active = True\n\n    exp._obj.__class__ = MockExp\n    actives = group.filter_exps(is_active=True)\n    assert len(actives) == 1 and actives[0] is exp\n    xman.exp(1, 1).set_manual_status('DONE', \"It's done.\")\n    manuals = xman.group(1).filter_exps(is_manual=True)\n    assert len(manuals) == 1 and manuals[0] is xman.exp(1, 1)\n    all_falses = xman.group(1).filter_exps(is_active=False, is_manual=False)\n    assert len(all_falses) == 1 and all_falses[0] is xman.exp(1, 3)", "\n\ndef test__filter_exps_in_proj():\n    pass  # TODO ChatGPT\n    # assert False\n\n\ndef test__filter_exps_in_xman():\n    pass  # TODO ChatGPT\n    # assert False", "    # assert False\n\n\ndef test__result_stringifier():\n    exp = helper.make_exp_from_nothing()\n    exp.set_manual_result({'foo': 123, 'bar': 'asdf', 'biz': [1, 2]})\n    exp.result_stringifier = lambda x: f\"foo={x['foo']}, bar={x['bar']}\"\n    assert exp.stringify_result() == 'foo=123, bar=asdf'\n\n\ndef test__stringify_result():\n    exp = helper.make_exp_from_nothing()\n    exp.set_manual_result({'foo': 123, 'bar': 'asdf'})\n    exp.proj.result_stringifier = lambda x: f\"foo={x['foo']}\"\n    assert exp._obj.stringify_result() == 'foo=123'\n    exp.group.result_stringifier = lambda x: f\"bar={x['bar']}\"\n    assert exp._obj.stringify_result() == 'bar=asdf'\n    exp.result_stringifier = lambda x: f\"foo={x['foo']}, bar={x['bar']}\"\n    assert exp._obj.stringify_result() == 'foo=123, bar=asdf'", "\n\ndef test__stringify_result():\n    exp = helper.make_exp_from_nothing()\n    exp.set_manual_result({'foo': 123, 'bar': 'asdf'})\n    exp.proj.result_stringifier = lambda x: f\"foo={x['foo']}\"\n    assert exp._obj.stringify_result() == 'foo=123'\n    exp.group.result_stringifier = lambda x: f\"bar={x['bar']}\"\n    assert exp._obj.stringify_result() == 'bar=asdf'\n    exp.result_stringifier = lambda x: f\"foo={x['foo']}, bar={x['bar']}\"\n    assert exp._obj.stringify_result() == 'foo=123, bar=asdf'", "\n\ndef test__result_viewer():\n    exp = helper.make_exp_from_nothing()\n    exp.set_manual_result({'foo': 123, 'bar': 'asdf', 'biz': [1, 2]})\n    rv_func = lambda result: print(f\"Result: {result}\")\n    exp.result_viewer = rv_func\n    assert exp.result_viewer == rv_func\n    exp.view_result()\n", "\n\ndef test__note():\n    config.set__is_pytest(True)\n    exp = helper.make_exp_from_nothing()\n    assert exp.note is not None\n    exp.note.pickle = 'Some object'\n    exp.note.clear()\n    assert not filesystem.has(filesystem.get_note_path(exp.location_dir, FileType.PICKLE))\n    exp.note.pickle = 'Another object'\n    exp.clear()\n    assert not filesystem.has(filesystem.get_note_path(exp.location_dir, FileType.PICKLE))", "\n\ndef test__note_txt():\n    exp = helper.make_exp_from_nothing()\n    assert not filesystem.has(filesystem.get_note_path(exp.location_dir, FileType.TXT))\n    exp.note.txt = \"This is my note.\\nNew line.\"\n    assert filesystem.has(filesystem.get_note_path(exp.location_dir, FileType.TXT))\n    assert exp.note.txt == \"This is my note.\\nNew line.\"\n    exp.note.txt = None\n    assert not filesystem.has(filesystem.get_note_path(exp.location_dir, FileType.TXT))\n    assert exp.note.txt is None\n    assert len(exp.note.get_list()) == 0\n    assert not exp.note.has_any\n    exp.note.pickle = 1\n    exp.note.txt = 'hello'\n    assert len(exp.note.get_list()) == 2\n    assert exp.note.get_existence_str() == \"txt true, json false, pickle true\"\n    assert exp.note.has_any\n    exp.note.clear()\n    assert len(exp.note.get_list()) == 0\n    assert exp.note.get_existence_str() == \"txt false, json false, pickle false\"\n    assert not exp.note.has_any", "\n\ndef test__note_json():\n    exp = helper.make_exp_from_nothing()\n    assert not filesystem.has(filesystem.get_note_path(exp.location_dir, FileType.JSON))\n    exp.note.json = {'name': 'Isaac', 'mood': 'apple'}\n    assert filesystem.has(filesystem.get_note_path(exp.location_dir, FileType.JSON))\n    assert exp.note.json['mood'] == 'apple'\n    exp.note.json = None\n    assert not filesystem.has(filesystem.get_note_path(exp.location_dir, FileType.JSON))\n    assert exp.note.json is None", "\n\ndef test__note_pickle():\n    exp = helper.make_exp_from_nothing()\n    assert not filesystem.has(filesystem.get_note_path(exp.location_dir, FileType.PICKLE))\n    exp.note.pickle = CheckpointsMediator(exp.location_dir)\n    assert filesystem.has(filesystem.get_note_path(exp.location_dir, FileType.PICKLE))\n    assert exp.note.pickle.exp_location_dir == exp.location_dir\n    exp.note.pickle = None\n    assert not filesystem.has(filesystem.get_note_path(exp.location_dir, FileType.PICKLE))\n    assert exp.note.pickle is None", ""]}
{"filename": "test/helper.py", "chunked_list": ["import os\nimport shutil\n\nfrom xman import xman\nfrom xman.api import ExpProjAPI, ExpGroupAPI, ExpAPI\nfrom xman.pipeline import CheckpointsMediator\n\n\ndef make_proj_from_nothing(proj_dir=None, name=None, descr=None) -> ExpProjAPI:\n    if proj_dir is None:\n        # proj_dir = './gitignore/testproj'  # if running by `pytest` in terminal\n        proj_dir = '../gitignore/testproj'\n    if name is None:\n        name = 'Test Proj'\n    if descr is None:\n        descr = 'Test proj descr'\n    if os.path.exists(proj_dir):\n        shutil.rmtree(proj_dir)\n    return xman.make_proj(proj_dir, name, descr)", "def make_proj_from_nothing(proj_dir=None, name=None, descr=None) -> ExpProjAPI:\n    if proj_dir is None:\n        # proj_dir = './gitignore/testproj'  # if running by `pytest` in terminal\n        proj_dir = '../gitignore/testproj'\n    if name is None:\n        name = 'Test Proj'\n    if descr is None:\n        descr = 'Test proj descr'\n    if os.path.exists(proj_dir):\n        shutil.rmtree(proj_dir)\n    return xman.make_proj(proj_dir, name, descr)", "\n\ndef make_group_from_nothing(name=None, descr=None, num=None) -> ExpGroupAPI:\n    if name is None:\n        name = 'Test Group'\n    if descr is None:\n        descr = 'Test group descr'\n    return make_proj_from_nothing().make_group(name, descr, num)\n\n\ndef make_exp_from_nothing(name=None, descr=None, num=None) -> ExpAPI:\n    if name is None:\n        name = 'Test Exp'\n    if descr is None:\n        descr = 'Test exp descr'\n    return make_group_from_nothing().make_exp(name, descr, num)", "\n\ndef make_exp_from_nothing(name=None, descr=None, num=None) -> ExpAPI:\n    if name is None:\n        name = 'Test Exp'\n    if descr is None:\n        descr = 'Test exp descr'\n    return make_group_from_nothing().make_exp(name, descr, num)\n\n\ndef train(p1, p2, np1=None, np2=None):\n    result = f\"p1={p1}, p2={p2}, np1={np1}, np2={np2}\"\n    return result", "\n\ndef train(p1, p2, np1=None, np2=None):\n    result = f\"p1={p1}, p2={p2}, np1={np1}, np2={np2}\"\n    return result\n\n\ndef train_with_mediator(mediator: CheckpointsMediator, p1, p2, np1=None, np2=None):\n    mediator.save_checkpoint('first checkpoint', False)\n    mediator.save_checkpoint('second checkpoint', False)\n    cp_list = mediator.get_checkpoint_paths_list()\n    assert len(cp_list) == 2\n    assert mediator.load_checkpoint(cp_list[0]) == 'first checkpoint'\n    assert mediator.load_checkpoint(cp_list[1]) == 'second checkpoint'\n    result = f\"p1={p1}, p2={p2}, np1={np1}, np2={np2}\"\n    return result", "\n\ndef train_with_mediator_replace(mediator: CheckpointsMediator, p1, p2, np1=None, np2=None):\n    mediator.save_checkpoint('first checkpoint', True)\n    mediator.save_checkpoint('second checkpoint', True)\n    cp_list = mediator.get_checkpoint_paths_list()\n    assert len(cp_list) == 1\n    assert mediator.load_checkpoint(cp_list[0]) == 'second checkpoint'\n    result = f\"p1={p1}, p2={p2}, np1={np1}, np2={np2}\"\n    return result", "\n\ndef train_with_mediator_custom_path(mediator: CheckpointsMediator, p1, p2, np1=None, np2=None):\n    custom_path = os.path.join(mediator.exp_location_dir, 'custom/first.cp')\n    mediator.save_checkpoint('first checkpoint', False, custom_path)\n    custom_path = os.path.join(mediator.exp_location_dir, 'custom/second.cp')\n    mediator.save_checkpoint('second checkpoint', False, custom_path)\n    cp_list = mediator.get_checkpoint_paths_list()\n    assert len(cp_list) == 2\n    assert mediator.load_checkpoint(cp_list[0]) == 'first checkpoint'\n    assert mediator.load_checkpoint(cp_list[1]) == 'second checkpoint'\n    result = f\"p1={p1}, p2={p2}, np1={np1}, np2={np2}\"\n    return result", "\n\ntrain_params = {'p1': 1, 'p2': 2, 'np1': 3, 'np2': 4}\ntrain_result = f\"p1={train_params['p1']}, p2={train_params['p2']}, np1={train_params['np1']}, \" \\\n               f\"np2={train_params['np2']}\"\n"]}
{"filename": "test/test_bug.py", "chunked_list": ["import pytest\n\nfrom xman import xman\nfrom xman.error import ArgumentsXManError\nimport helper\n\n\ndef test__exp_broken_after_setting_wrong_status():\n    exp = helper.make_exp_from_nothing()\n    with pytest.raises(ArgumentsXManError, match=\"Wrong value\"):\n        exp.set_manual_status('FAILED', \"There's no `FAILED` status - should be `FAIL`\")\n    assert exp.status.status_str == 'EMPTY'\n    exp.set_manual_status('FAIL', \"Acceptable status\")\n    assert exp.status.status_str == 'FAIL'", "\n\ndef test__setting_status_after_wrong_one():\n    \"\"\"\n    Manual status setting for ExpStructBox doesn't work after setting a wrong one.\n    \"\"\"\n    exp = helper.make_exp_from_nothing()\n    try:\n        exp.set_manual_status('FAILED', \"There's no `FAILED` status - should be `FAIL`\")\n    except:\n        pass\n    xman.proj.set_manual_status('TO_DO', None)\n    assert xman.proj.status.status_str == 'TO_DO'\n    xman.proj.group(1).set_manual_status('TO_DO', None)\n    assert xman.proj.group(1).status.status_str == 'TO_DO'", "\n\ndef test__wrong_proj_status_when_new_exp():\n    exp = helper.make_exp_from_nothing()\n    exp.set_manual_status('SUCCESS', 'Success')\n    proj = xman.proj\n    group = proj.group(1)\n    group.make_exp('Lowercase', 'Lowercase input')\n    assert group.status.status_str == 'IN_PROGRESS'\n    assert proj.status.status_str == 'IN_PROGRESS'", "\n\ndef test__wrong_proj_status_when_new_group():\n    exp = helper.make_exp_from_nothing()\n    exp.set_manual_status('SUCCESS', 'Success')\n    proj = xman.proj\n    assert proj.status.status_str == 'SUCCESS'\n    proj.make_group('Lowercase', 'Lowercase input')\n    assert proj.status.status_str == 'IN_PROGRESS'\n", ""]}
{"filename": "test/test_filesystem.py", "chunked_list": ["import os\nfrom pathlib import Path\n\nimport pytest\n\nfrom xman.error import IllegalOperationXManError\nfrom xman import xman, filesystem\nfrom xman import config\nimport helper\n", "import helper\n\n\ndef test__has_checkpoints_dir():\n    exp = helper.make_exp_from_nothing()\n    exp.make_pipeline_with_checkpoints(helper.train_with_mediator, helper.train_params)\n    xman.make_dir(os.path.join(exp.location_dir, 'checkpoints/'))\n    assert filesystem.has_checkpoints_dir(exp.location_dir)\n    with pytest.raises(IllegalOperationXManError, match=\"contains checkpoints folder\"):\n        exp.start()", "\n\ndef test__make_dir():\n    config.set__is_pytest(True)\n    test_dir = '../gitignore/fstest'\n    if os.path.exists(test_dir):\n        xman.delete_dir(test_dir)\n    xman.make_dir(test_dir)\n    assert os.path.exists(test_dir)\n    xman.delete_dir(test_dir)", "\n\ndef test__remove_dir():\n    config.set__is_pytest(True)\n    test_dir = '../gitignore/fstest'\n    if os.path.exists(test_dir):\n        xman.delete_dir(test_dir)\n        assert not os.path.exists(test_dir)\n    xman.make_dir(test_dir)\n    xman.make_dir('../gitignore/fstest/group1/exp1')\n    xman.delete_dir(test_dir)\n    assert not os.path.exists(test_dir)", "\n\ndef test__rename_or_move_dir():\n    config.set__is_pytest(True)\n    test_dir = '../gitignore/fstest'\n    if os.path.exists(test_dir):\n        xman.delete_dir(test_dir)\n    path1 = '../gitignore/fstest/group1/exp1'\n    xman.make_dir(path1)\n    path2 = '../gitignore/fstest/group2/exp1'\n    xman.rename_or_move_dir(path1, path2)\n    assert not os.path.exists(path1) and os.path.exists(path2)\n    xman.delete_dir(test_dir)", "    \n\ndef test__change_exp_num_in_path():\n    path = '../gitignore/testproj/group1/exp1'\n    new_path = '../gitignore/testproj/group1/exp2'\n    assert filesystem.change_exp_num_in_path(path, 2) == new_path\n\n    path = '../gitignore/testproj/group1/exp1/.data'\n    new_path = '../gitignore/testproj/group1/exp2/.data'\n    assert filesystem.change_exp_num_in_path(path, 2) == new_path\n\n    path = '../gitignore/testproj/group1/exp42'\n    new_path = '../gitignore/testproj/group1/exp24'\n    assert filesystem.change_exp_num_in_path(path, 24) == new_path\n\n    path = '../gitignore/testproj/group1/exp42/.data'\n    new_path = '../gitignore/testproj/group1/exp24/.data'\n    assert filesystem.change_exp_num_in_path(path, 24) == new_path", "\n\ndef test__change_group_num_in_path():\n    path = '../gitignore/testproj/group1'\n    new_path = '../gitignore/testproj/group2'\n    assert filesystem.change_group_num_in_path(path, 2) == new_path\n\n    path = '../gitignore/testproj/group1/exp1'\n    new_path = '../gitignore/testproj/group2/exp1'\n    assert filesystem.change_group_num_in_path(path, 2) == new_path\n\n    path = '../gitignore/testproj/group42'\n    new_path = '../gitignore/testproj/group24'\n    assert filesystem.change_group_num_in_path(path, 24) == new_path\n\n    path = '../gitignore/testproj/group42/exp1'\n    new_path = '../gitignore/testproj/group24/exp1'\n    assert filesystem.change_group_num_in_path(path, 24) == new_path", ""]}
{"filename": "src/tmptest.py", "chunked_list": ["import shutil\nimport os\n\nfrom xman import xman\n\n\nPROJ_DIR = '../gitignore/experiments'\n\n\ncreate_new = True", "\ncreate_new = True\n\nif create_new:\n    if os.path.exists(PROJ_DIR):\n        shutil.rmtree(PROJ_DIR)\n    xman.make_proj(PROJ_DIR, 'Test Project', \"Test project descr\")\n    xman.make_group(\"Test Group\", \"Test group descr\")\n    xman.make_exp(1, \"Test Exp\", \"Test exp descr\")\nelse:\n    xman.load_proj(PROJ_DIR)", "\nxman.exp(1, 1).info()\n"]}
{"filename": "src/xman/struct.py", "chunked_list": ["import os\nfrom typing import Optional, Type, Callable, Any, Tuple\nfrom copy import deepcopy\n\nfrom .error import NotExistsXManError, ArgumentsXManError, AlreadyExistsXManError, \\\n    IllegalOperationXManError\nfrom . import util, filesystem, tree, confirm\nfrom .note import Note\n\n\nclass ExpStructData:\n\n    def __init__(self, name: str, descr: str):\n        self.name: str = name\n        self.descr: str = descr\n        self.manual_status: str = None\n        self.manual_status_resolution: str = None\n        self.result_stringifier: Callable[[Any], str] = None\n        self.result_viewer: Callable[[Any], None] = None", "\n\nclass ExpStructData:\n\n    def __init__(self, name: str, descr: str):\n        self.name: str = name\n        self.descr: str = descr\n        self.manual_status: str = None\n        self.manual_status_resolution: str = None\n        self.result_stringifier: Callable[[Any], str] = None\n        self.result_viewer: Callable[[Any], None] = None", "\n\nclass ExpStructStatus:\n\n    EMPTY = 'EMPTY'\n    TO_DO = 'TO_DO'\n    IN_PROGRESS = 'IN_PROGRESS'\n    DONE = 'DONE'\n    ERROR = 'ERROR'\n    SUCCESS = 'SUCCESS'\n    FAIL = 'FAIL'\n\n    __WORKFLOW = (EMPTY, TO_DO, IN_PROGRESS, (DONE, ERROR), (SUCCESS, FAIL))\n\n    @staticmethod\n    def has_status(status_str: str):\n        return util.check_has_value_in_class_public_constants(status_str, ExpStructStatus)\n\n    @staticmethod\n    def _check(status_str, resolution):\n        ExpStructStatus.has_status(status_str)\n        if status_str in (ExpStructStatus.SUCCESS, ExpStructStatus.FAIL) and resolution is None:\n            raise ArgumentsXManError(f\"SUCCESS and FAIL manual statuses \"\n                                     f\"require setting resolutions!\")\n\n    @staticmethod\n    def _fit_parameters(status_obj, status_str, resolution, manual):\n        return status_obj is not None and status_obj.status_str == status_str \\\n                and status_obj.resolution == resolution and status_obj.manual == manual\n\n    @property\n    def status_str(self) -> str: return self.__status_str\n\n    @property\n    def resolution(self) -> str: return self.__resolution\n\n    @property\n    def manual(self) -> bool: return self.__manual\n\n    @property\n    def workflow(self) -> Tuple[str | Tuple[str, str]]: return deepcopy(ExpStructStatus.__WORKFLOW)\n\n    @property\n    def next(self) -> Optional[str]:\n        if ExpStructStatus.__WORKFLOW[-1] == self.status_str:\n            return None\n        for i, it in enumerate(ExpStructStatus.__WORKFLOW[:-1]):\n            if it == self.status_str or (type(it) is tuple and self.status_str in it):\n                return ExpStructStatus.__WORKFLOW[i + 1]\n\n    # Printing in jupyter notebook - https://stackoverflow.com/a/41454816/9751954\n    def _repr_pretty_(self, p, cycle):\n        p.text(str(self) if not cycle else '...')\n\n    def __init__(self, status: str, resolution: str = None, manual: bool = False):\n        ExpStructStatus._check(status, resolution)\n        self.__status_str = status\n        self.__resolution = resolution\n        self.__manual = manual\n\n    def __str__(self): return self.status_str + ' *' if self.manual else self.status_str", "\n\nclass ExpStruct:\n\n    _AUTO_STATUS_RESOLUTION = '-= auto status =-'\n\n    @property\n    def api(self): return self._api\n\n    @property\n    def location_dir(self) -> str: return self.__location_dir\n\n    @property\n    def parent(self) -> Type['ExpGroup | ExpProj']: return self._parent\n\n    @property\n    def num(self) -> int: return self.__num\n\n    @property\n    def name(self) -> str: return self._data.name\n\n    @property\n    def descr(self) -> str: return self._data.descr\n\n    @property\n    def status(self) -> ExpStructStatus: return self.__status\n\n    @property\n    def is_manual(self) -> bool: return self._data.manual_status is not None\n\n    @property\n    def result_stringifier(self) -> Callable[[Any], str]:\n        return self._data.result_stringifier\n\n    @result_stringifier.setter\n    def result_stringifier(self, value: Callable[[Any], str]):\n        self._data.result_stringifier = value\n        self._save()\n\n    @property\n    def result_viewer(self) -> Callable[[Any], None]: return self._data.result_viewer\n\n    @result_viewer.setter\n    def result_viewer(self, value: Callable[[Any], None]):\n        self._data.result_viewer = value\n        self._save()\n\n    @property\n    def note(self) -> Note:\n        if self.__note is None:\n            self.__note = Note(self.location_dir)\n        return self.__note\n\n    def tree(self, depth: int = None): tree.print_dir_tree(self.location_dir, depth)\n\n    def info(self) -> str:\n        text = str(self)\n        if self.status.resolution is not None:\n            text += util.tab(f\"\\nResolution: {self.status.resolution}\")\n        if self.note.has_any:\n            text += util.tab(f\"\\nNotes: {self.note.get_existence_str()}\")\n        return text\n\n    def set_manual_status(self, status: str, resolution: str) -> 'ExpStruct':\n        ExpStructStatus._check(status, resolution)\n        status_str = self.status.status_str\n        if status_str == ExpStructStatus.SUCCESS or status_str == ExpStructStatus.FAIL:\n            raise IllegalOperationXManError(f\"`{self}` was already finalised with status \"\n                                            f\"`{status_str}` - you need to delete it manually with \"\n                                            f\"`delete_manual_status()` method at first!\")\n        self._data.manual_status = status\n        self._data.manual_status_resolution = resolution\n        self._save()\n        return self\n\n    def success(self, resolution: str) -> Optional['ExpStruct']:\n        return self.set_manual_status(ExpStructStatus.SUCCESS, resolution)\n\n    def fail(self, resolution: str) -> Optional['ExpStruct']:\n        return self.set_manual_status(ExpStructStatus.FAIL, resolution)\n\n    def delete_manual_status(self, need_confirm: bool = True) -> Optional['ExpStruct']:\n        if not self.status.manual:\n            raise NotExistsXManError(f\"There's no manual status in the struct `{self}`\")\n        if confirm.request(need_confirm,\n                            f\"ATTENTION! Do you want to delete the manual status \"\n                            f\"`{self._data.manual_status}`\\nand its resolution \"\n                            f\"`{self._data.manual_status_resolution}`\\nof exp `{self}`?\"):\n            self._data.manual_status = None\n            self._data.manual_status_resolution = None\n            self._save()\n            return self\n        return None\n\n    def edit(self, name: str = None, descr: str = None):\n        need_save = False\n        if self.name != name:\n            if self._parent is not None and self._parent.has_child(name):\n                raise AlreadyExistsXManError(\n                    f\"There's another child with the name=`{name}` \"\n                    f\"in the parent `{self._parent}`\")\n            self._data.name = name\n            need_save = True\n        if self.descr != descr:\n            self._data.descr = descr\n            need_save = True\n        if need_save:\n            self._save()\n\n    def update(self):\n        if self.__updating:\n            return\n        self.__updating = True\n        self._data, self.__time = filesystem.load_fresh_data_and_time(self.location_dir,\n                                                                      self._data, self.__time)\n        # Status should be updated at the end of the inherited updating hierarchy\n        if type(self) == ExpStruct:\n            self._update_status()\n        self.__updating = False\n\n    def _change_location_dir(self, new_location_dir):\n        self.__location_dir = os.path.normpath(new_location_dir)\n        self.__num = filesystem.get_dir_num(new_location_dir)\n\n    def _update_status(self):\n        if self.is_manual:\n            status, resolution = self._data.manual_status, self._data.manual_status_resolution\n        else:\n            status, resolution = self._process_auto_status()\n        if not ExpStructStatus._fit_parameters(self.status, status, resolution, self.is_manual):\n            self.__status = ExpStructStatus(status, resolution, self.is_manual)\n\n    def _process_auto_status(self): util.override_it()\n\n    # Printing in jupyter notebook - https://stackoverflow.com/a/41454816/9751954\n    def _repr_pretty_(self, p, cycle): p.text(str(self) if not cycle else '...')\n\n    def _save(self): self.__time = filesystem.save_data_and_time(self.location_dir, self._data)\n\n    def _destroy(self):\n        self._api._obj = None\n        self._api = None\n        self._parent = None\n        self._data = None\n        self.__status = None\n\n    def __init__(self, location_dir, parent):\n        from .structbox import ExpStructBox\n        from .api import ExpStructAPI\n        self.__location_dir = None\n        self.__num = None\n        self._change_location_dir(location_dir)\n        self._parent: ExpStructBox = parent\n        self._data: ExpStructData = None\n        self.__time = None\n        self.__status = None\n        self.__note: Note = None\n        self.__updating = False\n        self.update()\n        self._api: ExpStructAPI = None\n\n    def __str__(self): util.override_it()", ""]}
{"filename": "src/xman/proj.py", "chunked_list": ["from typing import List, Optional, Callable\n\nfrom . import filesystem, filter, exp_helper\nfrom .error import NothingToDoXManError, NotExistsXManError, AlreadyExistsXManError, \\\n    ArgumentsXManError\nfrom .structbox import ExpStructBox\nfrom .group import ExpGroup\nfrom .exp import Exp\n\n\nclass ExpProj(ExpStructBox):\n\n    def info(self) -> str: return exp_helper.get_info_with_marked_exps(self)\n\n    def update(self):\n        if self.__updating:\n            return\n        self.__updating = True\n        super().update()\n        # Status should be updated at the end of the inherited updating hierarchy\n        if type(self) == ExpProj:\n            self._update_status()\n        self.__updating = False\n\n    def has_group(self, num_or_name: int | str) -> bool: return self.has_child(num_or_name)\n\n    def group(self, num_or_name: int | str) -> ExpGroup: return self.child(num_or_name)\n\n    def make_group(self, name: str, descr: str, num: int = None) -> ExpGroup:\n        return self.make_child(name, descr, num)\n\n    def delete_group(self, num_or_name: int | str, need_confirm: bool = True) -> bool:\n        self.group(num_or_name)._check_has_no_active_exps()\n        return self.delete_child(num_or_name, need_confirm)\n\n    def groups(self) -> List[ExpGroup]: return self.children()\n\n    def num_groups(self) -> int: return self.num_children()\n\n    def groups_nums(self) -> List[int]: return self.children_nums()\n\n    def groups_names(self) -> List[str]: return self.children_names()\n\n    def change_group_num(self, num_or_name: int | str, new_num: int):\n        self.group(num_or_name)._check_has_no_active_exps()\n        self.change_child_num(num_or_name, new_num)\n\n    def filter_groups(self,\n                      mode: str = 'AND',\n                      custom_filter: Callable[[ExpGroup], bool] = None,\n                      status_or_list: str | List[str] = None,\n                      not_status_or_list: str | List[str] = None,\n                      ) -> List[ExpGroup]:\n        return filter.groups(self.groups(), mode, custom_filter, status_or_list, not_status_or_list)\n\n    def has_exp(self, group_num_or_name: int | str, exp_num_or_name: int | str) -> bool:\n        return self.group(group_num_or_name).has_exp(exp_num_or_name)\n\n    def exp(self, group_num_or_name: int | str, exp_num_or_name: int | str) -> Exp:\n        return self.group(group_num_or_name).exp(exp_num_or_name)\n\n    def make_exp(self, group_num_or_name: int | str, name: str, descr: str, num: int = None) -> Exp:\n        return self.group(group_num_or_name).make_exp(name, descr, num)\n\n    def delete_exp(self, group_num_or_name: int | str, exp_num_or_name: int | str,\n                   need_confirm: bool = True) -> bool:\n        return self.group(group_num_or_name).delete_exp(exp_num_or_name, need_confirm)\n\n    def exps(self, group_num_or_name: int | str = None) -> List[Exp]:\n        if group_num_or_name is not None:\n            return self.group(group_num_or_name).exps()\n        result = []\n        for it in self.groups():\n            result.extend(it.exps())\n        return result\n\n    def num_exps(self, group_num_or_name: int | str = None) -> int:\n        if group_num_or_name is not None:\n            return self.group(group_num_or_name).num_exps()\n        return len(self.exps())\n\n    def exps_nums(self, group_num_or_name: int | str = None) -> List[int]:\n        if group_num_or_name is not None:\n            return self.group(group_num_or_name).exps_nums()\n        return [x.num for x in self.exps()]\n\n    def exps_names(self, group_num_or_name: int | str = None) -> List[str]:\n        if group_num_or_name is not None:\n            return self.group(group_num_or_name).exps_names()\n        return [x.name for x in self.exps()]\n\n    def filter_exps(self,\n                    group_num_or_name: int | str = None,\n                    mode: str = 'AND',\n                    custom_filter: Callable[[Exp], bool] = None,\n                    is_active: bool = None,\n                    is_manual: bool = None,\n                    is_ready_for_start: bool = None,\n                    status_or_list: str | List[str] = None,\n                    not_status_or_list: str | List[str] = None,\n                    has_marker: bool = None,\n                    marker_or_list: str | List[str] = None,\n                    ) -> List[Exp]:\n        if group_num_or_name is not None:\n            return self.group(group_num_or_name).filter_exps(mode, custom_filter, is_active,\n                                is_manual, is_ready_for_start, status_or_list, not_status_or_list,\n                                has_marker, marker_or_list)\n        return filter.exps(self.exps(), mode, custom_filter, is_active, is_manual,\n                is_ready_for_start, status_or_list, not_status_or_list, has_marker, marker_or_list)\n\n    def get_exp_for_start(self, group_num_or_name: int | str = None) -> Optional[Exp]:\n        if group_num_or_name is not None:\n            return self.group(group_num_or_name).get_exp_for_start()\n        ready_list = filter.exps(self.exps(), is_ready_for_start=True)\n        return ready_list[0] if len(ready_list) else None\n\n    def start(self, group_num_or_name: int | str = None,\n              exp_num_or_name: int | str = None, autostart_next: bool = False):\n        exp = None\n        if group_num_or_name is None and exp_num_or_name is None:\n            exp = self.get_exp_for_start()\n        elif group_num_or_name is None and exp_num_or_name is not None:\n            raise ArgumentsXManError(f\"Need to specify `group_num_or_name` if `exp_num_or_name` is \"\n                                     f\"specified!\")\n        elif group_num_or_name is not None and exp_num_or_name is None:\n            exp = self.get_exp_for_start(group_num_or_name)\n        elif group_num_or_name is not None and exp_num_or_name is not None:\n            exp = self.exp(group_num_or_name, exp_num_or_name)\n        if exp is None:\n            raise NothingToDoXManError(f\"There's nothing to start!\")\n        exp.start()\n        if autostart_next:\n            self.start(autostart_next=True)\n\n    def move_exp(self, group_num_or_name: int | str, exp_num_or_name: int | str,\n                 new_group_num_or_name: int | str, new_exp_num: int):\n        exp = self.exp(group_num_or_name, exp_num_or_name)\n        exp._check_is_not_active()\n        group = self.group(group_num_or_name)\n        if not self.has_group(new_group_num_or_name):\n            raise NotExistsXManError(f\"There's no group with number or name \"\n                                     f\"`{new_group_num_or_name}`!\")\n        new_group = self.group(new_group_num_or_name)\n        if self.has_exp(new_group_num_or_name, new_exp_num):\n            raise AlreadyExistsXManError(f\"Can't move the experiment because another experiment\"\n                                    f\"already exist in the group number `{new_group_num_or_name}`!\")\n        dir_path = exp.location_dir\n        new_path = filesystem.change_group_num_in_path(dir_path, new_group.num)\n        new_path = filesystem.change_exp_num_in_path(new_path, new_exp_num)\n        filesystem.rename_or_move_dir(dir_path, new_path)\n        group._remove_child(exp)\n        # Also changes `num` as it's processing from the path:\n        exp._change_location_dir(new_path)\n        new_group._add_child(exp)\n\n    def __init__(self, location_dir):\n        from .api import ExpProjAPI\n        self.__updating = False\n        super().__init__(location_dir, None)\n        self._api = ExpProjAPI(self)\n\n    def __str__(self): return f\"Proj [{self.status}] {self.name} - {self.descr}\"", "\n\nclass ExpProj(ExpStructBox):\n\n    def info(self) -> str: return exp_helper.get_info_with_marked_exps(self)\n\n    def update(self):\n        if self.__updating:\n            return\n        self.__updating = True\n        super().update()\n        # Status should be updated at the end of the inherited updating hierarchy\n        if type(self) == ExpProj:\n            self._update_status()\n        self.__updating = False\n\n    def has_group(self, num_or_name: int | str) -> bool: return self.has_child(num_or_name)\n\n    def group(self, num_or_name: int | str) -> ExpGroup: return self.child(num_or_name)\n\n    def make_group(self, name: str, descr: str, num: int = None) -> ExpGroup:\n        return self.make_child(name, descr, num)\n\n    def delete_group(self, num_or_name: int | str, need_confirm: bool = True) -> bool:\n        self.group(num_or_name)._check_has_no_active_exps()\n        return self.delete_child(num_or_name, need_confirm)\n\n    def groups(self) -> List[ExpGroup]: return self.children()\n\n    def num_groups(self) -> int: return self.num_children()\n\n    def groups_nums(self) -> List[int]: return self.children_nums()\n\n    def groups_names(self) -> List[str]: return self.children_names()\n\n    def change_group_num(self, num_or_name: int | str, new_num: int):\n        self.group(num_or_name)._check_has_no_active_exps()\n        self.change_child_num(num_or_name, new_num)\n\n    def filter_groups(self,\n                      mode: str = 'AND',\n                      custom_filter: Callable[[ExpGroup], bool] = None,\n                      status_or_list: str | List[str] = None,\n                      not_status_or_list: str | List[str] = None,\n                      ) -> List[ExpGroup]:\n        return filter.groups(self.groups(), mode, custom_filter, status_or_list, not_status_or_list)\n\n    def has_exp(self, group_num_or_name: int | str, exp_num_or_name: int | str) -> bool:\n        return self.group(group_num_or_name).has_exp(exp_num_or_name)\n\n    def exp(self, group_num_or_name: int | str, exp_num_or_name: int | str) -> Exp:\n        return self.group(group_num_or_name).exp(exp_num_or_name)\n\n    def make_exp(self, group_num_or_name: int | str, name: str, descr: str, num: int = None) -> Exp:\n        return self.group(group_num_or_name).make_exp(name, descr, num)\n\n    def delete_exp(self, group_num_or_name: int | str, exp_num_or_name: int | str,\n                   need_confirm: bool = True) -> bool:\n        return self.group(group_num_or_name).delete_exp(exp_num_or_name, need_confirm)\n\n    def exps(self, group_num_or_name: int | str = None) -> List[Exp]:\n        if group_num_or_name is not None:\n            return self.group(group_num_or_name).exps()\n        result = []\n        for it in self.groups():\n            result.extend(it.exps())\n        return result\n\n    def num_exps(self, group_num_or_name: int | str = None) -> int:\n        if group_num_or_name is not None:\n            return self.group(group_num_or_name).num_exps()\n        return len(self.exps())\n\n    def exps_nums(self, group_num_or_name: int | str = None) -> List[int]:\n        if group_num_or_name is not None:\n            return self.group(group_num_or_name).exps_nums()\n        return [x.num for x in self.exps()]\n\n    def exps_names(self, group_num_or_name: int | str = None) -> List[str]:\n        if group_num_or_name is not None:\n            return self.group(group_num_or_name).exps_names()\n        return [x.name for x in self.exps()]\n\n    def filter_exps(self,\n                    group_num_or_name: int | str = None,\n                    mode: str = 'AND',\n                    custom_filter: Callable[[Exp], bool] = None,\n                    is_active: bool = None,\n                    is_manual: bool = None,\n                    is_ready_for_start: bool = None,\n                    status_or_list: str | List[str] = None,\n                    not_status_or_list: str | List[str] = None,\n                    has_marker: bool = None,\n                    marker_or_list: str | List[str] = None,\n                    ) -> List[Exp]:\n        if group_num_or_name is not None:\n            return self.group(group_num_or_name).filter_exps(mode, custom_filter, is_active,\n                                is_manual, is_ready_for_start, status_or_list, not_status_or_list,\n                                has_marker, marker_or_list)\n        return filter.exps(self.exps(), mode, custom_filter, is_active, is_manual,\n                is_ready_for_start, status_or_list, not_status_or_list, has_marker, marker_or_list)\n\n    def get_exp_for_start(self, group_num_or_name: int | str = None) -> Optional[Exp]:\n        if group_num_or_name is not None:\n            return self.group(group_num_or_name).get_exp_for_start()\n        ready_list = filter.exps(self.exps(), is_ready_for_start=True)\n        return ready_list[0] if len(ready_list) else None\n\n    def start(self, group_num_or_name: int | str = None,\n              exp_num_or_name: int | str = None, autostart_next: bool = False):\n        exp = None\n        if group_num_or_name is None and exp_num_or_name is None:\n            exp = self.get_exp_for_start()\n        elif group_num_or_name is None and exp_num_or_name is not None:\n            raise ArgumentsXManError(f\"Need to specify `group_num_or_name` if `exp_num_or_name` is \"\n                                     f\"specified!\")\n        elif group_num_or_name is not None and exp_num_or_name is None:\n            exp = self.get_exp_for_start(group_num_or_name)\n        elif group_num_or_name is not None and exp_num_or_name is not None:\n            exp = self.exp(group_num_or_name, exp_num_or_name)\n        if exp is None:\n            raise NothingToDoXManError(f\"There's nothing to start!\")\n        exp.start()\n        if autostart_next:\n            self.start(autostart_next=True)\n\n    def move_exp(self, group_num_or_name: int | str, exp_num_or_name: int | str,\n                 new_group_num_or_name: int | str, new_exp_num: int):\n        exp = self.exp(group_num_or_name, exp_num_or_name)\n        exp._check_is_not_active()\n        group = self.group(group_num_or_name)\n        if not self.has_group(new_group_num_or_name):\n            raise NotExistsXManError(f\"There's no group with number or name \"\n                                     f\"`{new_group_num_or_name}`!\")\n        new_group = self.group(new_group_num_or_name)\n        if self.has_exp(new_group_num_or_name, new_exp_num):\n            raise AlreadyExistsXManError(f\"Can't move the experiment because another experiment\"\n                                    f\"already exist in the group number `{new_group_num_or_name}`!\")\n        dir_path = exp.location_dir\n        new_path = filesystem.change_group_num_in_path(dir_path, new_group.num)\n        new_path = filesystem.change_exp_num_in_path(new_path, new_exp_num)\n        filesystem.rename_or_move_dir(dir_path, new_path)\n        group._remove_child(exp)\n        # Also changes `num` as it's processing from the path:\n        exp._change_location_dir(new_path)\n        new_group._add_child(exp)\n\n    def __init__(self, location_dir):\n        from .api import ExpProjAPI\n        self.__updating = False\n        super().__init__(location_dir, None)\n        self._api = ExpProjAPI(self)\n\n    def __str__(self): return f\"Proj [{self.status}] {self.name} - {self.descr}\"", ""]}
{"filename": "src/xman/platform.py", "chunked_list": ["import sys\n\n\nis_colab = 'google.colab' in sys.modules\nis_jupyter_notebook = 'ipykernel' in sys.modules and not is_colab\n\n\nif is_colab:\n    import os\n    import re\n\n    from . import filesystem, confirm, maker\n    from . import util\n\n    def check_colab_forked_folders(exp_struct_box) -> bool:\n        \"\"\"\n        Issue with making folders under different Colab accounts in one Google Drive shared folder\n        produces folders with duplicated numbers (e.g. `group1` and `group1 (1)`, `exp2` and `exp2 (1)`.\n        It happens because there's a 20-second (or even more) lag in update the second account with the\n        information about the first one already created a folder with a such number. It can't be solved\n        for Colab, but user should be notified for solving the issue manually.\n        https://stackoverflow.com/questions/76106194/folders-created-with-python-code-from-2-colab-accounts-in-one-google-drive-share\n\n        Parameter:\n            exp_exp_struct_box (ExpStructBox): e.g. ExpProj or ExpGroup instances.\n\n        Returns:\n            (bool): `False` if forked folders were found and the response on the input was `No`, `True`\n                otherwise.\n        \"\"\"\n        dir_prefix = filesystem.dir_prefix(maker.get_child_class(exp_struct_box))\n        regex = fr'^{dir_prefix}\\d+ \\(\\d+\\)$'\n        folders = []\n        for entry in os.scandir(exp_struct_box.location_dir):\n            if entry.is_dir() and re.match(regex, entry.name):\n                folders.append(entry.name)\n        if len(folders):\n            loc = exp_struct_box.location_dir\n            message = (f\"\\nFound forked folders {folders} in the location `{loc}`.\"\n                       f\"\\nIt could be due to a delay in updating one account to the fact that a \"\n                       f\"Google Drive folder was created under a different account: \"\n                       f\"https://stackoverflow.com/questions/76106194/folders-created-with-python-code-\"\n                       f\"from-2-colab-accounts-in-one-google-drive-shareFound\"\n                       f\"\\nForked folders are not presented in the project and are essentially lost \"\n                       f\"experiments. You need to process (e.g. rename or delete) them manually.\"\n                       f\"\\nIn case of frequent occurrence of such a problem, try to take 1 minute \"\n                       f\"pauses between making experiments and groups of experiments under different \"\n                       f\"accounts. Or you can initially create new groups and experiments under only \"\n                       f\"one Colab account, then run and update experiments under different accounts.\")\n            util.warning(message)\n            if not confirm.request(True, f\"Leave it as is and proceed?\"):\n                return False\n        return True\nelif is_jupyter_notebook:\n    import os\n\n    def check_jupyter_notebook_kernel_interrupted(): return os.getenv('KERNEL_INTERRUPTED') == '1'", ""]}
{"filename": "src/xman/config.py", "chunked_list": ["from xman import util\n\n\nclass PipelineConfig:\n\n    timer_interval = 2 * util.SECOND\n    active_buffer = 5 * util.SECOND\n    active_buffer_colab = util.MINUTE\n\n", "\n\nconfirm_off = False\nis_pytest = False\n\n\ndef set__is_pytest(value):\n    global is_pytest, confirm_off\n    is_pytest = value\n    confirm_off = is_pytest", ""]}
{"filename": "src/xman/structbox.py", "chunked_list": ["from typing import Optional, Type, List\n\nfrom .error import ArgumentsXManError, NotExistsXManError, AlreadyExistsXManError\nfrom .struct import ExpStruct, ExpStructStatus\nfrom . import util, confirm, maker, filesystem\n\n\nclass ExpStructBox(ExpStruct):\n\n    def info(self) -> str:\n        text = super().info()\n        for child in self.children():\n            text += util.tab(f\"\\n\\n{child.info()}\")\n        return text\n\n    def update(self):\n        if self.__updating:\n            return\n        self.__updating = True\n        super().update()\n        nums = filesystem.get_children_nums(self)\n        for num in nums:\n            if num not in self.__num_to_child:\n                child = maker.recreate_child(self, num)\n                self._add_child(child)\n        for child in self.children():\n            if child.num not in nums:\n                self._remove_child(child)\n        for name in list(self.__name_to_child.keys()):\n            del self.__name_to_child[name]\n        for child in self.children():\n            child.update()\n            self.__name_to_child[child._data.name] = child\n        # Status should be updated at the end of the inherited updating hierarchy\n        if type(self) == ExpStructBox:\n            self._update_status()\n        self.__updating = False\n\n    def has_child(self, num_or_name):\n        if util.is_num(num_or_name):\n            return num_or_name in self.__num_to_child\n        elif util.is_name(num_or_name):\n            return num_or_name in self.__name_to_child\n        else:\n            raise ArgumentsXManError(f\"`num_or_name` should be num >= 1 (int) or name (str), \"\n                                     f\"but `{num_or_name}` was given!\")\n\n    def child(self, num_or_name):\n        if util.is_num(num_or_name) and num_or_name in self.__num_to_child:\n            return self.__num_to_child[num_or_name]\n        elif util.is_name(num_or_name) and num_or_name in self.__name_to_child:\n            return self.__name_to_child[num_or_name]\n        raise NotExistsXManError(f\"There's no child with num or name `{num_or_name}` \"\n                                 f\"in the `{self}`!\")\n\n    def make_child(self, name, descr, num=None) -> Type['Exp | ExpGroup']:\n        util.check_num(num, True)\n        if self.has_child(name):\n            raise AlreadyExistsXManError(\n                f\"A child with the name `{name}` already exists in the `{self}`!\")\n        if num is not None:\n            if self.has_child(num):\n                raise AlreadyExistsXManError(\n                    f\"A child with the num `{num}` already exists in the `{self}`!\")\n        else:\n            nums = filesystem.get_children_nums(self)\n            max_num = max(nums) if len(nums) else 0\n            num = max_num + 1\n        child = maker.make_new_child(self, name, descr, num)\n        if child is not None:\n            self._add_child(child)\n        return child\n\n    def delete_child(self, num_or_name, need_confirm=True) -> bool:\n        child = self.child(num_or_name)\n        if confirm.delete_struct_and_all_its_content(child, need_confirm):\n            self._remove_child(child)\n            maker.delete_child(child, False)\n            return True\n        return False\n\n    def children(self) -> List['Exp | ExpGroup']: return list(self.__num_to_child.values())\n\n    def num_children(self) -> int: return len(self.__num_to_child)\n\n    def children_nums(self) -> List[int]: return list(self.__num_to_child.keys())\n\n    def children_names(self) -> List[str]: return list(self.__name_to_child.keys())\n\n    def change_child_num(self, num_or_name, new_num):\n        child = self.child(num_or_name)\n        if self.has_child(new_num):\n            raise AlreadyExistsXManError(f\"Can't change number to `{new_num}` for `{child}` - \"\n                                            f\"new number is already taken by other child!\")\n        dir_path = child.location_dir\n        child_dir_pattern = filesystem.dir_prefix(maker.get_child_class(self))\n        new_path = filesystem.change_num_in_path_by_pattern(dir_path, child_dir_pattern, new_num)\n        filesystem.rename_or_move_dir(dir_path, new_path)\n        self._remove_child(child)\n        # Also changes `num` as it's processing from the path:\n        child._change_location_dir(new_path)\n        self._add_child(child)\n\n    def _add_child(self, child):\n        self.__num_to_child[child.num] = child\n        self.__name_to_child[child._data.name] = child\n        child._parent = self\n\n    def _remove_child(self, child):\n        del self.__num_to_child[child.num]\n        del self.__name_to_child[child._data.name]\n        child._parent = None\n\n    def _process_auto_status(self):\n        resolution = ExpStruct._AUTO_STATUS_RESOLUTION\n        if self.__children_has_status(ExpStructStatus.ERROR, False):\n            status = ExpStructStatus.ERROR\n        elif self.__children_has_status(ExpStructStatus.IN_PROGRESS, False):\n            status = ExpStructStatus.IN_PROGRESS\n        elif self.__children_has_status(ExpStructStatus.EMPTY, True):\n            status = ExpStructStatus.EMPTY\n        elif self.__children_has_status(ExpStructStatus.TO_DO, True):\n            status = ExpStructStatus.TO_DO\n        elif self.__children_has_status(ExpStructStatus.DONE, True):\n            status = ExpStructStatus.DONE\n        elif self.__children_has_status(ExpStructStatus.SUCCESS, True):\n            status = ExpStructStatus.SUCCESS\n        elif self.__children_has_status(ExpStructStatus.FAIL, True):\n            status = ExpStructStatus.FAIL\n        elif self.__children_has_status([ExpStructStatus.EMPTY, ExpStructStatus.TO_DO], True):\n            status = ExpStructStatus.TO_DO\n        elif self.__children_has_status([ExpStructStatus.DONE, ExpStructStatus.SUCCESS,\n                                         ExpStructStatus.FAIL], True):\n            status = ExpStructStatus.DONE\n        else:\n            status = ExpStructStatus.IN_PROGRESS\n        return status, resolution\n\n    def _destroy(self):\n        for child in self.children():\n            child._destroy()\n        self.__num_to_child.clear()\n        self.__num_to_child = None\n        self.__name_to_child.clear()\n        self.__name_to_child = None\n        super()._destroy()\n\n    def __init__(self, location_dir, parent):\n        self.__num_to_child = {}\n        self.__name_to_child = {}\n        self.__updating = False\n        super().__init__(location_dir, parent)\n\n    def __children_has_status(self, status_str_or_list, all_children: bool):\n        sl = status_str_or_list if type(status_str_or_list) is list else [status_str_or_list]\n        for child in self.children():\n            s = child.status.status_str\n            if all_children:\n                if s not in sl:\n                    return False\n            else:\n                if s in sl:\n                    return True\n        return True if all_children else False", ""]}
{"filename": "src/xman/pipeline.py", "chunked_list": ["import os\nimport threading\nfrom threading import Timer\nfrom typing import Any, Callable, Optional, List\n\nfrom . import filesystem, platform\nfrom .config import PipelineConfig\nfrom .error import get_error_str, get_error_stack_str, NotExistsXManError\n\n\nclass CheckpointsMediator:\n\n    @property\n    def exp_location_dir(self): return self.__exp_location_dir\n\n    @property\n    def default_checkpoints_dir(self): return self.__default_checkpoints_dir\n\n    def save_checkpoint(self, checkpoint: Any, replace: bool,\n                        custom_path: str = None) -> str:\n        # TODO Delete work plan or rework it to the docs\n        \"\"\"\n        + Saves all checkpoints placed inside the exp folder as relative to the folder.\n\n        + If a custom_path was placed outside the exp folder, the path will be saved as it was\n        provided.\n\n        + During loading the path will be tried first as a relative to the exp folder, then as it\n        is, if source via the relative path doesn't exist.\n\n        + If both paths aren't exist, then NotExist exception will be raised with mentioning of JSON\n        file which should be fixed manually or checkpoints folder should be deleted via special\n        method.\n\n        + Refine checkpoints on pipeline start\n\n        + Refine checkpoints on getting via mediator's method\n        \"\"\"\n        cp_list = self.get_checkpoint_paths_list(check_files_exist=True)\n        if replace and cp_list is not None:\n            for cp_path in cp_list:\n                filesystem.delete_checkpoint(self.__exp_location_dir, cp_path)\n            filesystem.delete_checkpoints_list(self.__exp_location_dir)\n            cp_list = None\n        if not filesystem.has_checkpoints_dir(self.__exp_location_dir):\n            filesystem.make_checkpoints_dir(self.__exp_location_dir)\n        cp_path = filesystem.save_checkpoint(self.__exp_location_dir, checkpoint, custom_path)\n        cp_list = [] if cp_list is None else cp_list\n        cp_list.append(cp_path)\n        filesystem.save_checkpoints_list(self.__exp_location_dir, cp_list)\n        return cp_path if custom_path is None else custom_path\n\n    def get_checkpoint_paths_list(self, check_files_exist: bool = True) -> Optional[List[str]]:\n        lst = filesystem.load_checkpoints_list(self.__exp_location_dir)\n        if lst is None or not check_files_exist:\n            return lst\n        missed = []\n        for it in lst:\n            path = filesystem.resolve_checkpoint_path(self.__exp_location_dir, it)\n            if path is None:\n                missed.append(it)\n        if len(missed):\n            json_path = filesystem.get_checkpoints_list_path(self.__exp_location_dir)\n            NotExistsXManError(f\"Can't resolve some checkpoints paths - {missed}! You can fix paths\"\n                               f\" right in the {json_path} or remove checkpoints via \"\n                               f\"`exp.delete_checkpoints()` method of the experiment structure.\")\n        return lst\n\n    def load_checkpoint(self, checkpoint_path: str) -> Optional[Any]:\n        path = filesystem.resolve_checkpoint_path(self.__exp_location_dir, checkpoint_path)\n        if path is None:\n            raise NotExistsXManError(f\"Can't find checkpoint by the path `{checkpoint_path}`!\")\n        return filesystem.load_checkpoint(path)\n\n    def __init__(self, exp_location_dir: str):\n        self.__exp_location_dir = exp_location_dir\n        self.__default_checkpoints_dir = filesystem.get_checkpoints_dir_path(exp_location_dir)\n        # Check checkpoints are ok (paths can be lost during files or folders moving:\n        self.get_checkpoint_paths_list(check_files_exist=True)", "\n\nclass CheckpointsMediator:\n\n    @property\n    def exp_location_dir(self): return self.__exp_location_dir\n\n    @property\n    def default_checkpoints_dir(self): return self.__default_checkpoints_dir\n\n    def save_checkpoint(self, checkpoint: Any, replace: bool,\n                        custom_path: str = None) -> str:\n        # TODO Delete work plan or rework it to the docs\n        \"\"\"\n        + Saves all checkpoints placed inside the exp folder as relative to the folder.\n\n        + If a custom_path was placed outside the exp folder, the path will be saved as it was\n        provided.\n\n        + During loading the path will be tried first as a relative to the exp folder, then as it\n        is, if source via the relative path doesn't exist.\n\n        + If both paths aren't exist, then NotExist exception will be raised with mentioning of JSON\n        file which should be fixed manually or checkpoints folder should be deleted via special\n        method.\n\n        + Refine checkpoints on pipeline start\n\n        + Refine checkpoints on getting via mediator's method\n        \"\"\"\n        cp_list = self.get_checkpoint_paths_list(check_files_exist=True)\n        if replace and cp_list is not None:\n            for cp_path in cp_list:\n                filesystem.delete_checkpoint(self.__exp_location_dir, cp_path)\n            filesystem.delete_checkpoints_list(self.__exp_location_dir)\n            cp_list = None\n        if not filesystem.has_checkpoints_dir(self.__exp_location_dir):\n            filesystem.make_checkpoints_dir(self.__exp_location_dir)\n        cp_path = filesystem.save_checkpoint(self.__exp_location_dir, checkpoint, custom_path)\n        cp_list = [] if cp_list is None else cp_list\n        cp_list.append(cp_path)\n        filesystem.save_checkpoints_list(self.__exp_location_dir, cp_list)\n        return cp_path if custom_path is None else custom_path\n\n    def get_checkpoint_paths_list(self, check_files_exist: bool = True) -> Optional[List[str]]:\n        lst = filesystem.load_checkpoints_list(self.__exp_location_dir)\n        if lst is None or not check_files_exist:\n            return lst\n        missed = []\n        for it in lst:\n            path = filesystem.resolve_checkpoint_path(self.__exp_location_dir, it)\n            if path is None:\n                missed.append(it)\n        if len(missed):\n            json_path = filesystem.get_checkpoints_list_path(self.__exp_location_dir)\n            NotExistsXManError(f\"Can't resolve some checkpoints paths - {missed}! You can fix paths\"\n                               f\" right in the {json_path} or remove checkpoints via \"\n                               f\"`exp.delete_checkpoints()` method of the experiment structure.\")\n        return lst\n\n    def load_checkpoint(self, checkpoint_path: str) -> Optional[Any]:\n        path = filesystem.resolve_checkpoint_path(self.__exp_location_dir, checkpoint_path)\n        if path is None:\n            raise NotExistsXManError(f\"Can't find checkpoint by the path `{checkpoint_path}`!\")\n        return filesystem.load_checkpoint(path)\n\n    def __init__(self, exp_location_dir: str):\n        self.__exp_location_dir = exp_location_dir\n        self.__default_checkpoints_dir = filesystem.get_checkpoints_dir_path(exp_location_dir)\n        # Check checkpoints are ok (paths can be lost during files or folders moving:\n        self.get_checkpoint_paths_list(check_files_exist=True)", "\n\nclass PipelineData:  # Saved in exp._data.pipeline\n\n    def __init__(self):\n        self.started: bool = False\n        self.finished: bool = False\n        self.error: str = None\n        self.error_stack: str = None\n", "\n\nclass PipelineRunData:  # Saved in `.run` file, might be really heavy (several GB)\n\n    def __init__(self, run_func: Callable[..., Any] | Callable[[CheckpointsMediator, ...], Any],\n                 with_mediator: bool, params: dict):\n        self.run_func = run_func\n        self.with_mediator = with_mediator\n        self.params = params\n", "\n\nclass Pipeline:\n\n    def start(self):\n        data = self.__data\n        run_data = self.__run_data\n        error = None\n        self.__do_timestamp()\n        try:\n            if run_data.with_mediator:\n                self.__mediator = CheckpointsMediator(self.__location_dir)\n                result = run_data.run_func(self.__mediator, **run_data.params)\n            else:\n                result = run_data.run_func(**run_data.params)\n            filesystem.save_pipeline_result(self.__location_dir, result)\n            data.finished = True\n        except Exception as e:\n            error = e\n            self.__process_error(e)\n        if error is not None:\n            raise error\n\n    def _destroy(self):\n        filesystem.delete_pipeline_run_timestamp(self.__location_dir)\n        if self.__timer is not None:\n            self.__timer.cancel()\n            self.__timer = None\n        self.__mediator = None\n        self.__data = None\n        self.__run_data = None\n\n    def __init__(self, location_dir: str, data: PipelineData, run_data: PipelineRunData):\n        self.__location_dir = os.path.normpath(location_dir)\n        self.__data = data\n        self.__run_data = run_data\n        self.__mediator: CheckpointsMediator = None\n        self.__timer: Timer = None\n\n    def __process_error(self, error):\n        data = self.__data\n        data.error = get_error_str(error)\n        data.error_stack = get_error_stack_str(error)\n\n    def __do_timestamp(self):\n        if platform.is_jupyter_notebook and platform.check_jupyter_notebook_kernel_interrupted():\n            return\n        filesystem.save_pipeline_run_timestamp(self.__location_dir)\n        self.__timer = threading.Timer(PipelineConfig.timer_interval, self.__do_timestamp)\n        self.__timer.start()", ""]}
{"filename": "src/xman/tree.py", "chunked_list": ["import os\nimport re\n\n\n__tab = '    '\n__regex = r'\\d+'\n\n\ndef __sort_by_number(name):\n    match = re.search(__regex, name)\n    return int(match.group()) if match else 0", "def __sort_by_number(name):\n    match = re.search(__regex, name)\n    return int(match.group()) if match else 0\n\n\ndef __sort_content_by_folders_and_files(target_dir, sort_numbers):\n    names = os.listdir(target_dir)\n    names = sorted(names, key=__sort_by_number) if sort_numbers else sorted(names)\n    dirs = []\n    files = []\n    for it in names:\n        p = os.path.join(target_dir, it)\n        if os.path.isdir(p):\n            dirs.append(it)\n        elif os.path.isfile(p):\n            files.append(it)\n        else:\n            continue\n    return dirs, files", "\n\ndef __dirs_part(\n        target_dir, depth, current_depth, result, files_limit, files_first, sort_numbers, dirs):\n    for d in dirs:\n        p = os.path.join(target_dir, d)\n        __process_dir(p, depth, current_depth + 1, result, files_limit, files_first, sort_numbers)\n\n\ndef __files_part(target_dir, current_depth, result, files):\n    for f in files:\n        p = os.path.join(target_dir, f)\n        if f.startswith('...'):\n            result.append(f\"{__tab * (current_depth + 1)}{f}\")\n            continue\n        result.append(f\"{__tab * (current_depth + 1)}{os.path.basename(p)}\")", "\ndef __files_part(target_dir, current_depth, result, files):\n    for f in files:\n        p = os.path.join(target_dir, f)\n        if f.startswith('...'):\n            result.append(f\"{__tab * (current_depth + 1)}{f}\")\n            continue\n        result.append(f\"{__tab * (current_depth + 1)}{os.path.basename(p)}\")\n\n\ndef __process_dir(target_dir, depth, current_depth, result, files_limit, files_first, sort_numbers):\n    if target_dir.endswith('/'):\n        target_dir = target_dir[:-1]\n    result.append(f\"{__tab * current_depth}{os.path.basename(target_dir) + '/'}\")\n    if depth is not None and current_depth > depth:\n        if len(os.listdir(target_dir)):\n            result[-1] += '...'\n        return\n    dirs, files = __sort_content_by_folders_and_files(target_dir, sort_numbers)\n    files_len = len(files)\n    if 0 < files_limit < files_len:\n        trimmed = files[:2]\n        trimmed.append(f\"... {files_len - 3} other files are hidden ... \")\n        trimmed.append(files[-1])\n        files = trimmed\n    if files_first:\n        __files_part(target_dir, current_depth, result, files)\n        __dirs_part(target_dir, depth, current_depth, result, files_limit, files_first, sort_numbers, dirs)\n    else:\n        __dirs_part(target_dir, depth, current_depth, result, files_limit, files_first, sort_numbers, dirs)\n        __files_part(target_dir, current_depth, result, files)", "\n\ndef __process_dir(target_dir, depth, current_depth, result, files_limit, files_first, sort_numbers):\n    if target_dir.endswith('/'):\n        target_dir = target_dir[:-1]\n    result.append(f\"{__tab * current_depth}{os.path.basename(target_dir) + '/'}\")\n    if depth is not None and current_depth > depth:\n        if len(os.listdir(target_dir)):\n            result[-1] += '...'\n        return\n    dirs, files = __sort_content_by_folders_and_files(target_dir, sort_numbers)\n    files_len = len(files)\n    if 0 < files_limit < files_len:\n        trimmed = files[:2]\n        trimmed.append(f\"... {files_len - 3} other files are hidden ... \")\n        trimmed.append(files[-1])\n        files = trimmed\n    if files_first:\n        __files_part(target_dir, current_depth, result, files)\n        __dirs_part(target_dir, depth, current_depth, result, files_limit, files_first, sort_numbers, dirs)\n    else:\n        __dirs_part(target_dir, depth, current_depth, result, files_limit, files_first, sort_numbers, dirs)\n        __files_part(target_dir, current_depth, result, files)", "\n\n# TODO Move prints to the API, rename to `dir_tree`\ndef print_dir_tree(target_dir: str, depth: int = None, files_limit: int = 10,\n                   files_first: bool = True, sort_numbers: bool = True):\n    print()\n    result = []\n    __process_dir(target_dir, depth, 0, result, files_limit, files_first, sort_numbers)\n    for it in result:\n        print(it)\n    print()", ""]}
{"filename": "src/xman/filter.py", "chunked_list": ["from typing import List, Callable\n\nfrom .error import ArgumentsXManError\nfrom .struct import ExpStructStatus\n\n\ndef intersect(*lists):\n    if not lists:\n        return []\n    intersection_set = set(lists[0])\n    for lst in lists[1:]:\n        intersection_set.intersection_update(lst)\n    return list(intersection_set)", "\n\ndef unite(*lists):\n    merged_list = []\n    for lst in lists:\n        merged_list.extend(lst)\n    return list(set(merged_list))\n\n\ndef __check_and_get_status_list(status_or_list):\n    lst = status_or_list if type(status_or_list) == list else [status_or_list]\n    for status in lst:\n        if not ExpStructStatus.has_status(status):\n            raise ArgumentsXManError(\n                f\"Wrong `status_or_list` param - statuses should be from the workflow \"\n                f\"`{ExpStructStatus.workflow}`, but `{status_or_list}` was given!\")\n    return lst", "\ndef __check_and_get_status_list(status_or_list):\n    lst = status_or_list if type(status_or_list) == list else [status_or_list]\n    for status in lst:\n        if not ExpStructStatus.has_status(status):\n            raise ArgumentsXManError(\n                f\"Wrong `status_or_list` param - statuses should be from the workflow \"\n                f\"`{ExpStructStatus.workflow}`, but `{status_or_list}` was given!\")\n    return lst\n", "\n\ndef __exp_key(exp): return exp.group.num, exp.num\ndef __group_key(group): return group.num\n\n\nclass Mode:\n\n    AND = 'AND'\n    OR = 'OR'\n\n    @staticmethod\n    def _check_mode(mode):\n        if mode != Mode.AND and mode != Mode.OR:\n            ArgumentsXManError(\n                f\"`mode` should be 'AND' or 'OR' string, but `{mode}` was given!\")", "\n\ndef exps(\n        exps: List['Exp'],\n        mode: str = 'AND',\n        custom_filter: Callable[['Exp'], bool] = None,\n        is_active: bool = None,\n        is_manual: bool = None,\n        is_ready_for_start: bool = None,\n        status_or_list: str | List[str] = None,\n        not_status_or_list: str | List[str] = None,\n        has_marker: bool = None,\n        marker_or_list: str | List[str] = None,\n        # TODO ??? Implement:\n        # str_in_name: str = None,\n        # str_in_descr: str = None,\n        # str_in_resolution: str = None,\n        # has_pipeline: bool = None,\n        # pipeline_started: bool = None,\n        # pipeline_error: bool = None,\n        # pipeline_finished: bool = None,\n        # has_manual_result: bool = None,\n        # has_pipeline_result: bool = None,\n        # has_result: bool = None,\n) -> List['Exp']:\n    Mode._check_mode(mode)\n    results = []\n    if custom_filter is not None:\n        results.append([x for x in exps if custom_filter(x)])\n    if is_active is not None:\n        results.append([x for x in exps if x.is_active == is_active])\n    if is_manual is not None:\n        results.append([x for x in exps if x.is_manual == is_manual])\n    if is_ready_for_start is not None:\n        results.append([x for x in exps if x.is_ready_for_start == is_ready_for_start])\n    if status_or_list is not None:\n        status_list = __check_and_get_status_list(status_or_list)\n        results.append([x for x in exps if x.status_str in status_list])\n    if not_status_or_list is not None:\n        not_status_list = __check_and_get_status_list(not_status_or_list)\n        results.append([x for x in exps if x.status_str not in not_status_list])\n    if has_marker is not None:\n        results.append([x for x in exps if (x.marker is not None) == has_marker])\n    if marker_or_list is not None:\n        lst = marker_or_list if type(marker_or_list) == list else [marker_or_list]\n        results.append([x for x in exps if x.marker in lst])\n    result = intersect(*results) if mode == Mode.AND else unite(*results)\n    return sorted(result, key=__exp_key)", "\n\ndef groups(\n        groups: List['ExpGroup'],\n        mode: str = 'AND',\n        custom_filter: Callable[['ExpGroup'], bool] = None,\n        status_or_list: str | List[str] = None,\n        not_status_or_list: str | List[str] = None,\n) -> List['ExpGroup']:\n    Mode._check_mode(mode)\n    results = []\n    if custom_filter is not None:\n        results.append([x for x in groups if custom_filter(x)])\n    if status_or_list is not None:\n        status_list = __check_and_get_status_list(status_or_list)\n        results.append([x for x in groups if x.status_str in status_list])\n    if not_status_or_list is not None:\n        not_status_list = __check_and_get_status_list(not_status_or_list)\n        results.append([x for x in groups if x.status_str not in not_status_list])\n    result = intersect(*results) if mode == Mode.AND else unite(*results)\n    return sorted(result, key=__group_key)", ""]}
{"filename": "src/xman/api.py", "chunked_list": ["from typing import Any, Optional, Callable, List\n\nfrom . import tree, maker, filesystem\nfrom .error import NotImplementedXManError, IllegalOperationXManError\nfrom .group import ExpGroup\nfrom .note import Note\nfrom .pipeline import CheckpointsMediator\nfrom .exp import Exp\nfrom .proj import ExpProj\nfrom .struct import ExpStructStatus, ExpStruct", "from .proj import ExpProj\nfrom .struct import ExpStructStatus, ExpStruct\n\n\ndef _get_apis_from_list(objs: List[Exp | ExpGroup]) -> List['ExpAPI | ExpGroupAPI']:\n    return [x.api for x in objs]\n\n\nclass ExpStructAPI:\n\n    @property\n    def location_dir(self) -> str: return self._obj.location_dir\n\n    @property\n    def num(self) -> int: return self._obj.num\n\n    @property\n    def name(self) -> str:\n        self._obj.update()\n        return self._obj.name\n\n    @property\n    def descr(self) -> str:\n        self._obj.update()\n        return self._obj.descr\n\n    @property\n    def status(self) -> ExpStructStatus:\n        self._obj.update()\n        return self._obj.status\n\n    @property\n    def is_manual(self) -> bool:\n        self._obj.update()\n        return self._obj.is_manual\n\n    @property\n    def result_stringifier(self) -> Callable[[Any], str]:\n        self._obj.update()\n        return self._obj.result_stringifier\n\n    @result_stringifier.setter\n    def result_stringifier(self, value: Callable[[Any], str]):\n        self._obj.update()\n        self._obj.result_stringifier = value\n\n    @property\n    def result_viewer(self) -> Callable[[Any], None]:\n        self._obj.update()\n        return self._obj.result_viewer\n\n    @result_viewer.setter\n    def result_viewer(self, value: Callable[[Any], None]):\n        self._obj.update()\n        self._obj.result_viewer = value\n\n    @property\n    def note(self) -> Note:\n        # self._obj.update()  # No need to update\n        return self._obj.note\n\n    def tree(self, depth: int = None):\n        self._obj.update()\n        self._obj.tree(depth)\n\n    def info(self):\n        self._obj.update()\n        text = self._obj.info()\n        print(text)\n\n    def update(self):\n        self._obj.update()\n\n    def set_manual_status(self, status: str, resolution: str) -> 'ExpStructAPI':\n        self._obj.update()\n        self._obj.set_manual_status(status, resolution)\n        return self\n\n    def delete_manual_status(self, need_confirm: bool = True) -> Optional['ExpStructAPI']:\n        self._obj.update()\n        obj = self._obj.delete_manual_status(need_confirm)\n        return None if obj is None else self\n\n    def success(self, resolution: str) -> Optional['ExpStructAPI']:\n        self._obj.update()\n        self._obj.success(resolution)\n        return self\n\n    def fail(self, resolution: str) -> Optional['ExpStructAPI']:\n        self._obj.update()\n        self._obj.fail(resolution)\n        return self\n\n    def edit(self, name: str = None, descr: str = None):\n        # Need to update parent (and all its children) to check other children on the same name:\n        self._obj.update() if self._obj.parent is None else self._obj.parent.update()\n        self._obj.edit(name, descr)\n\n    # Printing in jupyter notebook - https://stackoverflow.com/a/41454816/9751954\n    def _repr_pretty_(self, p, cycle): p.text(str(self) if not cycle else '...')\n\n    def __init__(self, obj: ExpStruct): self._obj = obj  # for autocomplete\n\n    def __str__(self):\n        self._obj.update()\n        return str(self._obj)", "class ExpStructAPI:\n\n    @property\n    def location_dir(self) -> str: return self._obj.location_dir\n\n    @property\n    def num(self) -> int: return self._obj.num\n\n    @property\n    def name(self) -> str:\n        self._obj.update()\n        return self._obj.name\n\n    @property\n    def descr(self) -> str:\n        self._obj.update()\n        return self._obj.descr\n\n    @property\n    def status(self) -> ExpStructStatus:\n        self._obj.update()\n        return self._obj.status\n\n    @property\n    def is_manual(self) -> bool:\n        self._obj.update()\n        return self._obj.is_manual\n\n    @property\n    def result_stringifier(self) -> Callable[[Any], str]:\n        self._obj.update()\n        return self._obj.result_stringifier\n\n    @result_stringifier.setter\n    def result_stringifier(self, value: Callable[[Any], str]):\n        self._obj.update()\n        self._obj.result_stringifier = value\n\n    @property\n    def result_viewer(self) -> Callable[[Any], None]:\n        self._obj.update()\n        return self._obj.result_viewer\n\n    @result_viewer.setter\n    def result_viewer(self, value: Callable[[Any], None]):\n        self._obj.update()\n        self._obj.result_viewer = value\n\n    @property\n    def note(self) -> Note:\n        # self._obj.update()  # No need to update\n        return self._obj.note\n\n    def tree(self, depth: int = None):\n        self._obj.update()\n        self._obj.tree(depth)\n\n    def info(self):\n        self._obj.update()\n        text = self._obj.info()\n        print(text)\n\n    def update(self):\n        self._obj.update()\n\n    def set_manual_status(self, status: str, resolution: str) -> 'ExpStructAPI':\n        self._obj.update()\n        self._obj.set_manual_status(status, resolution)\n        return self\n\n    def delete_manual_status(self, need_confirm: bool = True) -> Optional['ExpStructAPI']:\n        self._obj.update()\n        obj = self._obj.delete_manual_status(need_confirm)\n        return None if obj is None else self\n\n    def success(self, resolution: str) -> Optional['ExpStructAPI']:\n        self._obj.update()\n        self._obj.success(resolution)\n        return self\n\n    def fail(self, resolution: str) -> Optional['ExpStructAPI']:\n        self._obj.update()\n        self._obj.fail(resolution)\n        return self\n\n    def edit(self, name: str = None, descr: str = None):\n        # Need to update parent (and all its children) to check other children on the same name:\n        self._obj.update() if self._obj.parent is None else self._obj.parent.update()\n        self._obj.edit(name, descr)\n\n    # Printing in jupyter notebook - https://stackoverflow.com/a/41454816/9751954\n    def _repr_pretty_(self, p, cycle): p.text(str(self) if not cycle else '...')\n\n    def __init__(self, obj: ExpStruct): self._obj = obj  # for autocomplete\n\n    def __str__(self):\n        self._obj.update()\n        return str(self._obj)", "\n\nclass ExpAPI(ExpStructAPI):\n\n    @property\n    def group(self) -> 'ExpGroupAPI':\n        group = self._obj.group\n        group.update()\n        return group.api\n\n    @property\n    def proj(self) -> 'ExpProjAPI':\n        proj = self._obj.proj\n        proj.update()\n        return proj.api\n\n    @property\n    def is_active(self) -> bool:\n        self._obj.update()\n        return self._obj.is_active\n\n    @property\n    def is_ready_for_start(self) -> bool:\n        self._obj.update()\n        return self._obj.is_ready_for_start\n\n    @property\n    def state(self) -> str:\n        self._obj.update()\n        return self._obj.state\n\n    @property\n    def has_pipeline(self) -> bool:\n        self._obj.update()\n        return self._obj.has_pipeline\n\n    @property\n    def has_result(self) -> bool:\n        self._obj.update()\n        return self._obj.has_result\n\n    @property\n    def has_pipeline_result(self) -> bool:\n        self._obj.update()\n        return self._obj.has_pipeline_result\n\n    @property\n    def has_manual_result(self) -> bool:\n        self._obj.update()\n        return self._obj.has_manual_result\n\n    @property\n    def result(self) -> Optional[Any]:\n        self._obj.update()\n        return self._obj.result\n\n    @property\n    def error(self) -> Optional[str]:\n        self._obj.update()\n        return self._obj.error\n\n    @property\n    def error_stack(self) -> Optional[str]:\n        self._obj.update()\n        return self._obj.error_stack\n\n    @property\n    def checkpoints_mediator(self) -> CheckpointsMediator:\n        # self._obj.update()  # No need to update\n        return self._obj.checkpoints_mediator\n\n    @property\n    def marker(self) -> str:\n        self._obj.update()\n        return self._obj.marker\n\n    @marker.setter\n    def marker(self, value):\n        self._obj.update()\n        self._obj.marker = value\n\n    def stringify_result(self) -> str:\n        self._obj.update()\n        return self._obj.stringify_result()\n\n    def view_result(self):\n        self._obj.update()\n        self._obj.view_result()\n\n    def make_pipeline(self, run_func: Callable[..., Any],\n                      params: dict, save_on_storage: bool = False) -> 'ExpAPI':\n        self._obj.update()\n        self._obj.make_pipeline(run_func, params, save_on_storage)\n        return self\n\n    def make_pipeline_with_checkpoints(self,\n                               run_func_with_mediator: Callable[[CheckpointsMediator, ...], Any],\n                               params: dict, save_on_storage: bool = False) -> 'ExpAPI':\n        self._obj.update()\n        self._obj.make_pipeline_with_checkpoints(run_func_with_mediator, params, save_on_storage)\n        return self\n\n    def get_pipeline_result(self) -> Any:\n        self._obj.update()\n        return self._obj.get_pipeline_result()\n\n    def delete_pipeline(self, need_confirm: bool = True) -> Optional['ExpAPI']:\n        self._obj.update()\n        obj = self._obj.delete_pipeline(need_confirm)\n        return None if obj is None else self\n\n    def delete_checkpoints(self, need_confirm: bool = True,\n                           delete_custom_paths: bool = False) -> Optional['ExpAPI']:\n        self._obj.update()\n        obj = self._obj.delete_checkpoints(need_confirm, delete_custom_paths)\n        return None if obj is None else self\n\n    def start(self, force_after_error: bool = False) -> 'ExpAPI':\n        self._obj.update()\n        self._obj.start(force_after_error=force_after_error)\n        return self\n\n    def get_manual_result(self) -> Any:\n        self._obj.update()\n        return self._obj.get_manual_result()\n\n    def set_manual_result(self, result: Any) -> 'ExpAPI':\n        self._obj.update()\n        obj = self._obj.set_manual_result(result)\n        return None if obj is None else self\n\n    def delete_manual_result(self, need_confirm: bool = True) -> Optional['ExpAPI']:\n        self._obj.update()\n        obj = self._obj.delete_manual_result(need_confirm)\n        return None if obj is None else self\n\n    def delete_all_manual(self, need_confirm: bool = True) -> Optional['ExpAPI']:\n        self._obj.update()\n        obj = self._obj.delete_all_manual(need_confirm)\n        return None if obj is None else self\n\n    def clear(self, need_confirm: bool = True) -> Optional['ExpAPI']:\n        self._obj.update()\n        obj = self._obj.clear(need_confirm)\n        return None if obj is None else self\n\n    def __init__(self, obj: Exp): self._obj = obj  # for autocomplete", "\n\nclass ExpGroupAPI(ExpStructAPI):\n\n    @property\n    def proj(self) -> 'ExpProjAPI':\n        proj = self._obj.parent\n        proj.update()\n        return proj.api\n\n    def has_exp(self, num_or_name: int | str) -> bool:\n        self._obj.update()\n        return self._obj.has_exp(num_or_name)\n\n    def exp(self, num_or_name: int | str) -> ExpAPI:\n        self._obj.update()\n        exp = self._obj.exp(num_or_name)\n        return exp.api\n\n    def make_exp(self, name: str, descr: str, num: int = None) -> ExpAPI:\n        self._obj.update()\n        exp = self._obj.make_exp(name, descr, num)\n        return exp.api\n\n    def delete_exp(self, num_or_name: int | str, need_confirm: bool = True) -> bool:\n        self._obj.update()\n        return self._obj.delete_exp(num_or_name, need_confirm)\n\n    def exps(self) -> List[ExpAPI]:\n        self._obj.update()\n        exps = self._obj.exps()\n        return _get_apis_from_list(exps)\n\n    def num_exps(self) -> int:\n        self._obj.update()\n        return self._obj.num_exps()\n\n    def exps_nums(self) -> List[int]:\n        self._obj.update()\n        return self._obj.exps_nums()\n\n    def exps_names(self) -> List[str]:\n        self._obj.update()\n        return self._obj.exps_names()\n\n    def change_exp_num(self, num_or_name: int | str, new_num: int):\n        self._obj.update()\n        self._obj.change_exp_num(num_or_name, new_num)\n\n    def filter_exps(self,\n                    mode: str = 'AND',\n                    custom_filter: Callable[[Exp], bool] = None,\n                    is_active: bool = None,\n                    is_manual: bool = None,\n                    is_ready_for_start: bool = None,\n                    status_or_list: str | List[str] = None,\n                    not_status_or_list: str | List[str] = None,\n                    has_marker: bool = None,\n                    marker_or_list: str | List[str] = None,\n                    ) -> List[ExpAPI]:\n        self._obj.update()\n        exps = self._obj.filter_exps(mode, custom_filter, is_active, is_manual, is_ready_for_start,\n                                     status_or_list, not_status_or_list, has_marker, marker_or_list)\n        return _get_apis_from_list(exps)\n\n    def get_exp_for_start(self) -> Optional[ExpAPI]:\n        self._obj.update()\n        exp = self._obj.get_exp_for_start()\n        return None if exp is None else exp.api\n\n    def start(self, exp_num_or_name: int | str = None, autostart_next: bool = False):\n        self._obj.update()\n        self._obj.start(exp_num_or_name, autostart_next)\n\n    def __init__(self, obj: ExpGroup): self._obj = obj  # for autocomplete", "\n\nclass ExpProjAPI(ExpStructAPI):\n\n    @property\n    def num(self) -> int:\n        raise NotImplementedXManError(f\"`num` property isn't supported for a project!\")\n\n    def has_group(self, num_or_name: int | str) -> bool:\n        self._obj.update()\n        return self._obj.has_group(num_or_name)\n\n    def group(self, num_or_name: int | str) -> ExpGroupAPI:\n        self._obj.update()\n        group = self._obj.group(num_or_name)\n        return group.api\n\n    def make_group(self, name: str, descr: str, num: int = None) -> ExpGroupAPI:\n        self._obj.update()\n        group = self._obj.make_group(name, descr, num)\n        return group.api\n\n    def delete_group(self, num_or_name: int | str, need_confirm: bool = True) -> bool:\n        self._obj.update()\n        return self._obj.delete_group(num_or_name, need_confirm)\n\n    def groups(self) -> List[ExpGroupAPI]:\n        self._obj.update()\n        groups = self._obj.groups()\n        return _get_apis_from_list(groups)\n\n    def num_groups(self) -> int:\n        self._obj.update()\n        return self._obj.num_groups()\n\n    def groups_nums(self) -> List[int]:\n        self._obj.update()\n        return self._obj.groups_nums()\n\n    def groups_names(self) -> List[str]:\n        self._obj.update()\n        return self._obj.groups_names()\n\n    def change_group_num(self, num_or_name: int | str, new_num: int):\n        self._obj.update()\n        self._obj.change_group_num(num_or_name, new_num)\n\n    def filter_groups(self,\n                      mode: str = 'AND',\n                      custom_filter: Callable[[ExpGroup], bool] = None,\n                      status_or_list: str | List[str] = None,\n                      not_status_or_list: str | List[str] = None,\n                      ) -> List[ExpGroupAPI]:\n        self._obj.update()\n        groups = self._obj.filter_groups(mode, custom_filter, status_or_list, not_status_or_list)\n        return _get_apis_from_list(groups)\n\n    def has_exp(self, group_num_or_name: int | str, exp_num_or_name: int | str) -> bool:\n        self._obj.update()\n        return self._obj.has_exp(group_num_or_name, exp_num_or_name)\n\n    def exp(self, group_num_or_name: int | str, exp_num_or_name: int | str) -> ExpAPI:\n        self._obj.update()\n        exp = self._obj.exp(group_num_or_name, exp_num_or_name)\n        return exp.api\n\n    def make_exp(self, group_num_or_name: int | str, name: str, descr: str, num: int = None) -> ExpAPI:\n        self._obj.update()\n        exp = self._obj.make_exp(group_num_or_name, name, descr, num)\n        return exp.api\n\n    def delete_exp(self, group_num_or_name: int | str, exp_num_or_name: int | str,\n                   need_confirm: bool = True) -> bool:\n        self._obj.update()\n        return self._obj.delete_exp(group_num_or_name, exp_num_or_name, need_confirm)\n\n    def exps(self, group_num_or_name: int | str = None) -> List[ExpAPI]:\n        self._obj.update()\n        exps = self._obj.exps(group_num_or_name)\n        return _get_apis_from_list(exps)\n\n    def num_exps(self, group_num_or_name: int | str = None) -> int:\n        self._obj.update()\n        return self._obj.num_exps(group_num_or_name)\n\n    def exps_nums(self, group_num_or_name: int | str = None) -> List[int]:\n        self._obj.update()\n        return self._obj.exps_nums(group_num_or_name)\n\n    def exps_names(self, group_num_or_name: int | str = None) -> List[str]:\n        self._obj.update()\n        return self._obj.exps_names(group_num_or_name)\n\n    def filter_exps(self,\n                    group_num_or_name: int | str = None,\n                    mode: str = 'AND',\n                    custom_filter: Callable[[Exp], bool] = None,\n                    is_active: bool = None,\n                    is_manual: bool = None,\n                    is_ready_for_start: bool = None,\n                    status_or_list: str | List[str] = None,\n                    not_status_or_list: str | List[str] = None,\n                    has_marker: bool = None,\n                    marker_or_list: str | List[str] = None,\n                    ) -> List[ExpAPI]:\n        self._obj.update()\n        exps = self._obj.filter_exps(group_num_or_name, mode, custom_filter, is_active, is_manual,\n                is_ready_for_start, status_or_list, not_status_or_list, has_marker, marker_or_list)\n        return _get_apis_from_list(exps)\n\n    def get_exp_for_start(self, group_num_or_name: int | str = None) -> Optional[ExpAPI]:\n        self._obj.update()\n        exp = self._obj.get_exp_for_start(group_num_or_name)\n        return None if exp is None else exp.api\n\n    def start(self, group_num_or_name: int | str = None,\n              exp_num_or_name: int | str = None, autostart_next: bool = False):\n        self._obj.update()\n        self._obj.start(group_num_or_name, exp_num_or_name, autostart_next)\n\n    def move_exp(self, group_num_or_name: int | str, exp_num_or_name: int | str,\n                 new_group_num_or_name: int | str, new_exp_num: int):\n        self._obj.update()\n        self._obj.move_exp(group_num_or_name, exp_num_or_name, new_group_num_or_name, new_exp_num)\n\n    def __init__(self, obj: ExpProj): self._obj = obj  # for autocomplete", "\n\nclass XManAPI:\n\n    @staticmethod\n    def dir_tree(target_dir: str, depth: int = 0, files_limit: int = 10,\n                 files_first: bool = True, sort_numbers: bool = True):\n        tree.print_dir_tree(target_dir, depth, files_limit, files_first, sort_numbers)\n\n    @staticmethod\n    def make_dir(dir_path: str, exist_ok: bool = True): filesystem.make_dir(dir_path, exist_ok)\n\n    @staticmethod\n    def delete_dir(dir_path: str, need_confirm: bool = True) -> bool:\n        return filesystem.delete_dir(dir_path, need_confirm)\n\n    @staticmethod\n    def rename_or_move_dir(dir_path: str, new_path: str):\n        filesystem.rename_or_move_dir(dir_path, new_path)\n\n    @property\n    def location_dir(self) -> str:\n        self.__check_proj()\n        return self.__proj.location_dir\n\n    @property\n    def proj(self) -> ExpProjAPI:\n        self.__check_proj()\n        self.__proj.update()\n        return self.__proj\n\n    def make_proj(self, location_dir: str, name: str, descr: str) -> ExpProjAPI:\n        self.__destroy_old_proj()\n        proj = maker.make_proj(location_dir, name, descr)\n        self.__proj = proj.api\n        return self.__proj\n\n    def load_proj(self, location_dir: str) -> ExpProjAPI:\n        self.__destroy_old_proj()\n        proj = maker.recreate_proj(location_dir)\n        self.__proj = proj.api\n        return self.__proj\n\n    def reload(self):\n        self.__check_proj()\n        self.load_proj(self.__proj.location_dir)\n\n    def info(self):\n        self.__check_proj()\n        self.__proj.info()\n\n    def update(self):\n        self.__check_proj()\n        self.__proj.update()\n\n    def has_group(self, num_or_name: int | str) -> bool:\n        self.__check_proj()\n        return self.__proj.has_group(num_or_name)\n\n    def group(self, num_or_name: int | str) -> ExpGroupAPI:\n        self.__check_proj()\n        return self.__proj.group(num_or_name)\n\n    def make_group(self, name: str, descr: str, num: int = None) -> ExpGroupAPI:\n        self.__check_proj()\n        return self.__proj.make_group(name, descr, num)\n\n    def delete_group(self, num_or_name: int | str, need_confirm: bool = True) -> bool:\n        self.__check_proj()\n        return self.__proj.delete_group(num_or_name, need_confirm)\n\n    def groups(self) -> List[ExpGroupAPI]:\n        self.__check_proj()\n        return self.__proj.groups()\n\n    def filter_groups(self,\n                      mode: str = 'AND',\n                      custom_filter: Callable[[ExpGroup], bool] = None,\n                      status_or_list: str | List[str] = None,\n                      not_status_or_list: str | List[str] = None,\n                      ) -> List[ExpGroupAPI]:\n        self.__check_proj()\n        return self.__proj.filter_groups(mode, custom_filter, status_or_list, not_status_or_list)\n\n    def has_exp(self, group_num_or_name: int | str, exp_num_or_name: int | str) -> bool:\n        self.__check_proj()\n        return self.__proj.has_exp(group_num_or_name, exp_num_or_name)\n\n    def exp(self, group_num_or_name: int | str, exp_num_or_name: int | str) -> ExpAPI:\n        self.__check_proj()\n        return self.__proj.exp(group_num_or_name, exp_num_or_name)\n\n    def make_exp(self, group_num_or_name: int | str, name: str, descr: str, num: int = None) -> ExpAPI:\n        self.__check_proj()\n        return self.__proj.make_exp(group_num_or_name, name, descr, num)\n\n    def delete_exp(self, group_num_or_name: int | str, exp_num_or_name: int | str,\n                   need_confirm: bool = True) -> bool:\n        self.__check_proj()\n        return self.__proj.delete_exp(group_num_or_name, exp_num_or_name, need_confirm)\n\n    def exps(self, group_num_or_name: int | str = None) -> List[ExpAPI]:\n        self.__check_proj()\n        return self.__proj.exps(group_num_or_name)\n\n    def filter_exps(self,\n                    group_num_or_name: int | str = None,\n                    mode: str = 'AND',\n                    custom_filter: Callable[[Exp], bool] = None,\n                    is_active: bool = None,\n                    is_manual: bool = None,\n                    is_ready_for_start: bool = None,\n                    status_or_list: str | List[str] = None,\n                    not_status_or_list: str | List[str] = None,\n                    has_marker: bool = None,\n                    marker_or_list: str | List[str] = None,\n                    ) -> List[ExpAPI]:\n        self.__check_proj()\n        return self.__proj.filter_exps(group_num_or_name, mode, custom_filter, is_active, is_manual,\n                is_ready_for_start, status_or_list, not_status_or_list, has_marker, marker_or_list)\n\n    def get_exp_for_start(self, group_num_or_name: int | str = None) -> Optional[ExpAPI]:\n        self.__check_proj()\n        return self.__proj.get_exp_for_start(group_num_or_name)\n\n    def start(self, group_num_or_name: int | str = None,\n              exp_num_or_name: int | str = None, autostart_next: bool = False):\n        self.__check_proj()\n        self.__proj.start(group_num_or_name, exp_num_or_name, autostart_next)\n\n    def __init__(self): self.__proj: ExpProjAPI = None\n\n    def __check_proj(self):\n        if self.__proj is None:\n            raise IllegalOperationXManError(f\"There's no project - use `xman.make_proj(...)` or \"\n                                            f\"`xman.load_proj(...)` first!\")\n\n    def __destroy_old_proj(self):\n        if self.__proj is not None:\n            self.__proj._obj._destroy()\n            self.__proj = None", ""]}
{"filename": "src/xman/__init__.py", "chunked_list": ["__version__ = '0.2.1'\n\n\nfrom .api import XManAPI\n\n\nxman = XManAPI()\n"]}
{"filename": "src/xman/exp_helper.py", "chunked_list": ["from . import util\nfrom .structbox import ExpStructBox\n\n\ndef get_info_with_marked_exps(box: ExpStructBox) -> str:\n    from .proj import ExpProj\n    text = super(type(box), box).info()\n    lst = box.filter_exps(has_marker=True)\n    mark_num = util.TAB_NUM_SPACES * (2 if isinstance(box, ExpProj) else 1) - 1\n    mark = '>' * mark_num\n    for exp in lst:\n        exp_str = str(exp)\n        lines = text.splitlines()\n        for i, line in enumerate(lines):\n            if exp_str in line:\n                lines[i] = mark + line[mark_num:]\n                break\n        text = '\\n'.join(lines)\n    return text", ""]}
{"filename": "src/xman/filesystem.py", "chunked_list": ["import json\nimport os\nimport shutil\nimport time\nimport re\nfrom enum import Enum\nfrom pathlib import Path\nfrom typing import Optional, Any\nimport cloudpickle as pickle  # dill as pickle, cloudpickle as pickle, pickle\n", "import cloudpickle as pickle  # dill as pickle, cloudpickle as pickle, pickle\n\nfrom .error import ArgumentsXManError, IllegalOperationXManError, NotImplementedXManError, \\\n    NotExistsXManError\nfrom . import util, maker, confirm\n\n\nclass FileType(Enum):\n\n    TXT = '.txt'\n    JSON = '.json'\n    PICKLE = '.pickle'", "\n\ndef make_dir(dir_path, exist_ok=True): os.makedirs(dir_path, exist_ok=exist_ok)\n\n\ndef delete_dir(dir_path, need_confirm=True) -> bool:\n    if has(dir_path) and len(os.listdir(dir_path)) > 0 and not confirm.request(\n            need_confirm, f\"ATTENTION! Dir `{dir_path}`\\nisn't empty - delete anyway?\"):\n        return False\n    shutil.rmtree(dir_path, ignore_errors=True)\n    return True", "\n\ndef rename_or_move_dir(dir_path, new_path): shutil.move(dir_path, new_path)\n\n\ndef __get_data_path(location_dir): return os.path.join(location_dir, '.data')\ndef __get_time_path(location_dir): return os.path.join(location_dir, '.time')\n\n\ndef get_manual_result_path(location_dir): return os.path.join(location_dir, '.manual_result')", "\ndef get_manual_result_path(location_dir): return os.path.join(location_dir, '.manual_result')\n\n\ndef __get_run_path(location_dir): return os.path.join(location_dir, '.run')\ndef __get_run_time_path(location_dir): return os.path.join(location_dir, '.run_time')\n\n\ndef get_pipeline_result_path(location_dir): return os.path.join(location_dir, '.pipeline_result')\n", "def get_pipeline_result_path(location_dir): return os.path.join(location_dir, '.pipeline_result')\n\n\ndef get_checkpoints_dir_path(location_dir): return os.path.join(location_dir, 'checkpoints/')\n\n\ndef get_checkpoints_list_path(location_dir):\n    return os.path.join(get_checkpoints_dir_path(location_dir), 'list.json')\n\n\ndef __get_checkpoint_path(location_dir):\n    current_time_ns = time.time_ns()\n    current_time_s = current_time_ns // 10 ** 9  # Convert nanoseconds to seconds\n    formatted_time = time.strftime(\"%Y-%m-%d__%H_%M_%S\", time.gmtime(current_time_s))\n    fname = formatted_time + '--' + str(current_time_ns)[-9:] + '.cp'\n    return os.path.join(get_checkpoints_dir_path(location_dir), fname)", "\n\ndef __get_checkpoint_path(location_dir):\n    current_time_ns = time.time_ns()\n    current_time_s = current_time_ns // 10 ** 9  # Convert nanoseconds to seconds\n    formatted_time = time.strftime(\"%Y-%m-%d__%H_%M_%S\", time.gmtime(current_time_s))\n    fname = formatted_time + '--' + str(current_time_ns)[-9:] + '.cp'\n    return os.path.join(get_checkpoints_dir_path(location_dir), fname)\n\n\ndef get_note_path(location_dir, file_type: FileType):\n    return os.path.join(location_dir, 'note' + file_type.value)", "\n\ndef get_note_path(location_dir, file_type: FileType):\n    return os.path.join(location_dir, 'note' + file_type.value)\n\n\ndef get_dir_num(dir_path):\n    match = re.search(r'[1-9][0-9]*$', dir_path)\n    return int(match.group()) if match else None\n", "\n\ndef change_num_in_path_by_pattern(path, pattern, new_num) -> str:\n    return re.sub(fr'\\b{pattern}[1-9][0-9]*\\b', f'{pattern}{new_num}', path)\n\n\ndef change_exp_num_in_path(path: str, new_exp_num: int) -> str:\n    return change_num_in_path_by_pattern(path, 'exp', new_exp_num)\n\n\ndef change_group_num_in_path(path: str, new_group_num: int) -> str:\n    return change_num_in_path_by_pattern(path, 'group', new_group_num)", "\n\ndef change_group_num_in_path(path: str, new_group_num: int) -> str:\n    return change_num_in_path_by_pattern(path, 'group', new_group_num)\n\n\ndef __get_dir_nums_by_pattern(dir_path, dir_pattern):\n    regex = fr'^{dir_pattern}([1-9][0-9]*)$'\n    names = os.listdir(dir_path)\n    dirs = [x for x in names if os.path.isdir(os.path.join(dir_path, x))]\n    nums = []\n    for it in dirs:\n        match = re.match(regex, it)\n        if match:\n            nums.append(int(match.group(1)))\n    nums.sort()\n    return nums", "\n\ndef dir_prefix(struct_obj_or_cls):\n    from .exp import Exp\n    from .group import ExpGroup\n    from .proj import ExpProj\n    cls = util.get_cls(struct_obj_or_cls)\n    if cls == Exp:\n        return 'exp'\n    elif cls == ExpGroup:\n        return 'group'\n    elif cls == ExpProj:\n        raise NotImplementedXManError(f\"Isn't supported by logic!\")\n    else:\n        raise ArgumentsXManError(\n            f\"`struct_obj_or_cls` should be an instance of/or a final class inheriting ExpStruct - \"\n            f\"Exp, ExpGroup or ExpProj, but `{cls.__name__}` was given!\")", "\n\ndef get_child_dir(parent, child_num):\n    return os.path.join(parent.location_dir, dir_prefix(maker.get_child_class(parent)) +\n                        str(child_num))\n\n\ndef get_children_nums(parent):\n    child_class = maker.get_child_class(parent)\n    child_dir_prefix = dir_prefix(child_class)\n    return __get_dir_nums_by_pattern(parent.location_dir, child_dir_prefix)", "\n\ndef has(path) -> bool: return os.path.exists(path)\n\n\ndef prepare_dir(dir_path):\n    if has(dir_path):\n        if not os.path.isdir(dir_path):\n            raise ArgumentsXManError(f\"`{dir_path}` is not a directory!\")\n        elif len(os.listdir(dir_path)) > 0:\n            raise IllegalOperationXManError(f\"Directory `{dir_path}` should be empty!\")\n    else:\n        make_dir(dir_path)", "\n\ndef __save_to_file(obj, file_path, file_type: FileType):\n    make_dir(os.path.dirname(file_path))\n    if file_type is FileType.TXT:\n        with open(file_path, 'w') as f:\n            f.write(str(obj))\n    if file_type is FileType.JSON:\n        with open(file_path, 'w') as f:\n            json.dump(obj, f, indent=4)\n    if file_type is FileType.PICKLE:\n        with open(file_path, 'wb') as f:\n            pickle.dump(obj, f)", "\n\ndef __load_from_file(file_path, file_type: FileType) -> Optional[Any]:\n    if has(file_path):\n        if file_type is FileType.TXT:\n            with open(file_path, 'r') as f:\n                return f.read()\n        if file_type is FileType.JSON:\n            with open(file_path, 'r') as f:\n                return json.load(f)\n        if file_type is FileType.PICKLE:\n            with open(file_path, 'rb') as f:\n                return pickle.load(f)\n    return None", "\n\ndef __delete_file(file_path):\n    if has(file_path):\n        os.remove(file_path)\n\n\ndef save_data_and_time(location_dir, data) -> float:\n    __save_to_file(data, __get_data_path(location_dir), FileType.PICKLE)\n    t = time.time()\n    __save_to_file(t, __get_time_path(location_dir), FileType.PICKLE)\n    return t", "\n\ndef load_fresh_data_and_time(location_dir, last_data, last_time):\n    t = __load_from_file(__get_time_path(location_dir), FileType.PICKLE)\n    if last_time != t:\n        return __load_from_file(__get_data_path(location_dir), FileType.PICKLE), t\n    return last_data, last_time\n\n\ndef save_manual_result(location_dir, manual_result):\n    __save_to_file(manual_result, get_manual_result_path(location_dir), file_type=FileType.PICKLE)", "\ndef save_manual_result(location_dir, manual_result):\n    __save_to_file(manual_result, get_manual_result_path(location_dir), file_type=FileType.PICKLE)\n\n\ndef load_manual_result(location_dir):\n    return __load_from_file(get_manual_result_path(location_dir), file_type=FileType.PICKLE)\n\n\ndef delete_manual_result(location_dir): __delete_file(get_manual_result_path(location_dir))", "\ndef delete_manual_result(location_dir): __delete_file(get_manual_result_path(location_dir))\n\n\ndef save_pipeline_run_data(location_dir, run_data):\n    __save_to_file(run_data, __get_run_path(location_dir), FileType.PICKLE)\n\n\ndef load_pipeline_run_data(location_dir):\n    return __load_from_file(__get_run_path(location_dir), FileType.PICKLE)", "def load_pipeline_run_data(location_dir):\n    return __load_from_file(__get_run_path(location_dir), FileType.PICKLE)\n\n\ndef delete_pipeline_run_data(location_dir): __delete_file(__get_run_path(location_dir))\n\n\ndef save_pipeline_run_timestamp(location_dir):\n    __save_to_file(time.time(), __get_run_time_path(location_dir), FileType.PICKLE)\n", "\n\ndef load_pipeline_run_timestamp(location_dir):\n    return __load_from_file(__get_run_time_path(location_dir), FileType.PICKLE)\n\n\ndef delete_pipeline_run_timestamp(location_dir): __delete_file(__get_run_time_path(location_dir))\n\n\ndef save_pipeline_result(location_dir, pipeline_result):\n    __save_to_file(pipeline_result, get_pipeline_result_path(location_dir),\n                   file_type=FileType.PICKLE)", "\ndef save_pipeline_result(location_dir, pipeline_result):\n    __save_to_file(pipeline_result, get_pipeline_result_path(location_dir),\n                   file_type=FileType.PICKLE)\n\n\ndef load_pipeline_result(location_dir):\n    return __load_from_file(get_pipeline_result_path(location_dir), file_type=FileType.PICKLE)\n\n\ndef delete_pipeline_result(location_dir): __delete_file(get_pipeline_result_path(location_dir))", "\n\ndef delete_pipeline_result(location_dir): __delete_file(get_pipeline_result_path(location_dir))\n\n\ndef has_checkpoints_dir(location_dir): return has(get_checkpoints_dir_path(location_dir))\n\n\ndef make_checkpoints_dir(location_dir): make_dir(get_checkpoints_dir_path(location_dir))\n", "def make_checkpoints_dir(location_dir): make_dir(get_checkpoints_dir_path(location_dir))\n\n\ndef delete_checkpoints_dir(location_dir, need_confirm=True) -> bool:\n    return delete_dir(get_checkpoints_dir_path(location_dir), need_confirm)\n\n\ndef save_checkpoint(location_dir, checkpoint, custom_path=None) -> str:\n    loc_dir = Path(location_dir).resolve()\n    if custom_path is not None:\n        __save_to_file(checkpoint, custom_path, FileType.PICKLE)\n        path = Path(custom_path).resolve()\n        if path.is_relative_to(loc_dir):\n            path = str(path.relative_to(loc_dir).as_posix())\n        else:\n            path = custom_path\n    else:\n        path = Path(__get_checkpoint_path(location_dir)).resolve()\n        __save_to_file(checkpoint, path, FileType.PICKLE)\n        path = str(path.relative_to(loc_dir).as_posix())\n    return path", "\n\ndef load_checkpoint(cp_path): return __load_from_file(cp_path, FileType.PICKLE)\n\n\ndef delete_checkpoint(location_dir, cp_path):\n    path = resolve_checkpoint_path(location_dir, cp_path)\n    if path is None:\n        raise NotExistsXManError(f\"Can't resolve checkpoint path `{cp_path}`!\")\n    __delete_file(path)", "\n\ndef save_checkpoints_list(location_dir, cp_list):\n    __save_to_file(cp_list, get_checkpoints_list_path(location_dir), FileType.JSON)\n\n\ndef load_checkpoints_list(location_dir) -> Optional[Any]:\n    return __load_from_file(get_checkpoints_list_path(location_dir), FileType.JSON)\n\n\ndef delete_checkpoints_list(location_dir): __delete_file(get_checkpoints_list_path(location_dir))", "\n\ndef delete_checkpoints_list(location_dir): __delete_file(get_checkpoints_list_path(location_dir))\n\n\ndef resolve_checkpoint_path(location_dir: str, cp_path: str) -> Optional[str]:\n    cp_p = Path(cp_path)\n    ld_p = Path(location_dir)\n    path = ld_p / cp_p\n    if path.resolve().exists():\n        return str(path.as_posix())\n    if cp_p.resolve().exists():\n        return cp_path\n    return None", "\n\ndef save_note(location_dir, obj, file_type: FileType):\n    __save_to_file(obj, get_note_path(location_dir, file_type), file_type)\n\n\ndef load_note(location_dir, file_type: FileType):\n    return __load_from_file(get_note_path(location_dir, file_type), file_type)\n\n\ndef delete_note(location_dir, file_type): __delete_file(get_note_path(location_dir, file_type))", "\n\ndef delete_note(location_dir, file_type): __delete_file(get_note_path(location_dir, file_type))\n"]}
{"filename": "src/xman/util.py", "chunked_list": ["from .error import OverrideXManError, ArgumentsXManError\n\n\nSECOND = 1\nMINUTE = 60 * SECOND\nHOUR = 60 * MINUTE\nDAY = 24 * HOUR\n\n\nTAB_NUM_SPACES = 4", "\nTAB_NUM_SPACES = 4\n\n\ndef tab(text, deep=1):\n    t = ' ' * TAB_NUM_SPACES * deep\n    return text.replace('\\n', f'\\n{t}')\n\n\ndef is_num(num_or_name): return type(num_or_name) is int and num_or_name >= 1", "\ndef is_num(num_or_name): return type(num_or_name) is int and num_or_name >= 1\n\n\ndef is_name(num_or_name): return type(num_or_name) is str\n\n\ndef check_num(num, allow_none: bool):\n    if is_num(num):\n        return\n    if allow_none:\n        if num is None:\n            return\n        raise ArgumentsXManError(f\"num={num} should be None or an integer that greater or equal 1!\")\n    raise ArgumentsXManError(f\"num={num} should be an integer that greater or equal 1!\")", "\n\ndef get_cls(target_obj_or_cls):\n    t = type(target_obj_or_cls)\n    return target_obj_or_cls if t == type else t\n\n\ndef check_has_value_in_class_public_constants(value, instance_or_cls):\n    cls = get_cls(instance_or_cls)\n    constants = [v for it in vars(cls).items() if isinstance(v := it[1], str) and v.upper() == v\n                 and not v.startswith(('_', '__'))]\n    if value not in constants:\n        raise ArgumentsXManError(f\"Wrong value `{value}`, should be one of {constants}\")", "\n\ndef override_it(): raise OverrideXManError(\"Should be overriden!\")\n\n\ndef warning(message: str): print('\\nWARNING! ' + message + '\\n')\n"]}
{"filename": "src/xman/confirm.py", "chunked_list": ["from . import config\nfrom .struct import ExpStruct\n\n\ndef __response(question):\n    r = input(f\"{question} (y/n) \")\n    return r.lower() == \"y\"\n\n\ndef request(need_confirm, request):\n    if config.confirm_off:\n        return True\n    return __response(request) if need_confirm else True", "\ndef request(need_confirm, request):\n    if config.confirm_off:\n        return True\n    return __response(request) if need_confirm else True\n\n\ndef delete_struct_and_all_its_content(struct: ExpStruct, need_confirm):\n    p = struct.location_dir\n    return request(need_confirm,\n                    f\"ATTENTION! Remove `{struct}`\\nand its dir `{p}`\\nwith all its content?\")", ""]}
{"filename": "src/xman/note.py", "chunked_list": ["from typing import Any, List\n\nfrom . import filesystem\n\n\nclass Note:\n\n    @property\n    def txt(self) -> str:\n        return filesystem.load_note(self.__location_dir, filesystem.FileType.TXT)\n\n    @txt.setter\n    def txt(self, obj: Any):\n        file_type = filesystem.FileType.TXT\n        filesystem.delete_note(self.__location_dir, file_type) if obj is None \\\n            else filesystem.save_note(self.__location_dir, obj, file_type)\n\n    @property\n    def json(self) -> Any:\n        return filesystem.load_note(self.__location_dir, filesystem.FileType.JSON)\n\n    @json.setter\n    def json(self, obj: Any):\n        file_type = filesystem.FileType.JSON\n        filesystem.delete_note(self.__location_dir, file_type) if obj is None \\\n            else filesystem.save_note(self.__location_dir, obj, file_type)\n\n    @property\n    def pickle(self) -> Any:\n        return filesystem.load_note(self.__location_dir, filesystem.FileType.PICKLE)\n\n    @pickle.setter\n    def pickle(self, obj: Any):\n        file_type = filesystem.FileType.PICKLE\n        filesystem.delete_note(self.__location_dir, file_type) if obj is None \\\n            else filesystem.save_note(self.__location_dir, obj, file_type)\n\n    @property\n    def has_any(self):\n        for file_type in filesystem.FileType:\n            path = filesystem.get_note_path(self.__location_dir, file_type)\n            if filesystem.has(path):\n                return True\n        return False\n\n    def get_list(self) -> List[str]:\n        result = []\n        for file_type in filesystem.FileType:\n            path = filesystem.get_note_path(self.__location_dir, file_type)\n            if filesystem.has(path):\n                result.append(path)\n        return result\n\n    def get_existence_str(self) -> str:\n        result = ''\n        for file_type in filesystem.FileType:\n            path = filesystem.get_note_path(self.__location_dir, file_type)\n            result += f\"{file_type.name} {filesystem.has(path)}, \"\n        return result.removesuffix(', ').lower()\n\n    def clear(self):\n        filesystem.delete_note(self.__location_dir, filesystem.FileType.TXT)\n        filesystem.delete_note(self.__location_dir, filesystem.FileType.JSON)\n        filesystem.delete_note(self.__location_dir, filesystem.FileType.PICKLE)\n\n    def __init__(self, location_dir: str): self.__location_dir = location_dir\n\n    def __str__(self): return str(self.get_list())\n\n    def __call__(self, *args, **kwargs): print(self)", ""]}
{"filename": "src/xman/group.py", "chunked_list": ["from typing import Optional, List, Callable\n\nfrom . import filter, exp_helper\nfrom .error import NothingToDoXManError, IllegalOperationXManError\nfrom .structbox import ExpStructBox\nfrom .exp import Exp\n\n\nclass ExpGroup(ExpStructBox):\n\n    @property\n    def proj(self) -> 'ExpProj': return self.parent\n\n    def info(self) -> str: return exp_helper.get_info_with_marked_exps(self)\n\n    def update(self):\n        if self.__updating:\n            return\n        self.__updating = True\n        super().update()\n        # Status should be updated at the end of the inherited updating hierarchy\n        if type(self) == ExpGroup:\n            self._update_status()\n        self.__updating = False\n\n    def has_exp(self, num_or_name: int | str) -> bool: return self.has_child(num_or_name)\n\n    def exp(self, num_or_name: int | str) -> Exp: return self.child(num_or_name)\n\n    def make_exp(self, name: str, descr: str, num: int = None) -> Exp:\n        return self.make_child(name, descr, num)\n\n    def delete_exp(self, num_or_name: int | str, need_confirm: bool = True) -> bool:\n        self.exp(num_or_name)._check_is_not_active()\n        return self.delete_child(num_or_name, need_confirm)\n\n    def exps(self) -> List[Exp]: return self.children()\n\n    def num_exps(self) -> int: return self.num_children()\n\n    def exps_nums(self) -> List[int]: return self.children_nums()\n\n    def exps_names(self) -> List[str]: return self.children_names()\n\n    def change_exp_num(self, num_or_name: int | str, new_num: int):\n        self.exp(num_or_name)._check_is_not_active()\n        self.change_child_num(num_or_name, new_num)\n\n    def filter_exps(self,\n                    mode: str = 'AND',\n                    custom_filter: Callable[[Exp], bool] = None,\n                    is_active: bool = None,\n                    is_manual: bool = None,\n                    is_ready_for_start: bool = None,\n                    status_or_list: str | List[str] = None,\n                    not_status_or_list: str | List[str] = None,\n                    has_marker: bool = None,\n                    marker_or_list: str | List[str] = None,\n                    ) -> List[Exp]:\n        return filter.exps(self.exps(), mode, custom_filter, is_active, is_manual,\n                is_ready_for_start, status_or_list, not_status_or_list, has_marker, marker_or_list)\n\n    def get_exp_for_start(self) -> Optional[Exp]:\n        ready_list = self.filter_exps(is_ready_for_start=True)\n        return ready_list[0] if len(ready_list) else None\n\n    def start(self, exp_num_or_name: int | str = None, autostart_next: bool = False):\n        if exp_num_or_name is None:\n            exp = self.get_exp_for_start()\n            if exp is None:\n                raise NothingToDoXManError(f\"There's nothing to start in the group `{self}`!\")\n            exp.start()\n        else:\n            self.exp(exp_num_or_name).start()\n        if autostart_next:\n            self.start(autostart_next=True)\n\n    def _check_has_no_active_exps(self):\n        active_list = self.filter_exps(is_active=True)\n        if len(active_list):\n            raise IllegalOperationXManError(\n                f\"Illegal operation while there's any active experiment in the `{self}` - found:\"\n                f\"{active_list}!\")\n\n    def __init__(self, location_dir, parent):\n        from .api import ExpGroupAPI\n        self.__updating = False\n        super().__init__(location_dir, parent)\n        self._api = ExpGroupAPI(self)\n\n    def __str__(self):\n        return f\"Group {self.num} [{self.status}] {self.name} - {self.descr}\"", "class ExpGroup(ExpStructBox):\n\n    @property\n    def proj(self) -> 'ExpProj': return self.parent\n\n    def info(self) -> str: return exp_helper.get_info_with_marked_exps(self)\n\n    def update(self):\n        if self.__updating:\n            return\n        self.__updating = True\n        super().update()\n        # Status should be updated at the end of the inherited updating hierarchy\n        if type(self) == ExpGroup:\n            self._update_status()\n        self.__updating = False\n\n    def has_exp(self, num_or_name: int | str) -> bool: return self.has_child(num_or_name)\n\n    def exp(self, num_or_name: int | str) -> Exp: return self.child(num_or_name)\n\n    def make_exp(self, name: str, descr: str, num: int = None) -> Exp:\n        return self.make_child(name, descr, num)\n\n    def delete_exp(self, num_or_name: int | str, need_confirm: bool = True) -> bool:\n        self.exp(num_or_name)._check_is_not_active()\n        return self.delete_child(num_or_name, need_confirm)\n\n    def exps(self) -> List[Exp]: return self.children()\n\n    def num_exps(self) -> int: return self.num_children()\n\n    def exps_nums(self) -> List[int]: return self.children_nums()\n\n    def exps_names(self) -> List[str]: return self.children_names()\n\n    def change_exp_num(self, num_or_name: int | str, new_num: int):\n        self.exp(num_or_name)._check_is_not_active()\n        self.change_child_num(num_or_name, new_num)\n\n    def filter_exps(self,\n                    mode: str = 'AND',\n                    custom_filter: Callable[[Exp], bool] = None,\n                    is_active: bool = None,\n                    is_manual: bool = None,\n                    is_ready_for_start: bool = None,\n                    status_or_list: str | List[str] = None,\n                    not_status_or_list: str | List[str] = None,\n                    has_marker: bool = None,\n                    marker_or_list: str | List[str] = None,\n                    ) -> List[Exp]:\n        return filter.exps(self.exps(), mode, custom_filter, is_active, is_manual,\n                is_ready_for_start, status_or_list, not_status_or_list, has_marker, marker_or_list)\n\n    def get_exp_for_start(self) -> Optional[Exp]:\n        ready_list = self.filter_exps(is_ready_for_start=True)\n        return ready_list[0] if len(ready_list) else None\n\n    def start(self, exp_num_or_name: int | str = None, autostart_next: bool = False):\n        if exp_num_or_name is None:\n            exp = self.get_exp_for_start()\n            if exp is None:\n                raise NothingToDoXManError(f\"There's nothing to start in the group `{self}`!\")\n            exp.start()\n        else:\n            self.exp(exp_num_or_name).start()\n        if autostart_next:\n            self.start(autostart_next=True)\n\n    def _check_has_no_active_exps(self):\n        active_list = self.filter_exps(is_active=True)\n        if len(active_list):\n            raise IllegalOperationXManError(\n                f\"Illegal operation while there's any active experiment in the `{self}` - found:\"\n                f\"{active_list}!\")\n\n    def __init__(self, location_dir, parent):\n        from .api import ExpGroupAPI\n        self.__updating = False\n        super().__init__(location_dir, parent)\n        self._api = ExpGroupAPI(self)\n\n    def __str__(self):\n        return f\"Group {self.num} [{self.status}] {self.name} - {self.descr}\"", ""]}
{"filename": "src/xman/maker.py", "chunked_list": ["from typing import Optional\n\nfrom .error import AlreadyExistsXManError, ArgumentsXManError, IllegalOperationXManError\nfrom .exp import Exp, ExpData\nfrom .group import ExpGroup\nfrom .pipeline import PipelineData, PipelineRunData, Pipeline\nfrom . import util, filesystem, platform\nfrom .proj import ExpProj\nfrom .struct import ExpStruct, ExpStructData\n", "from .struct import ExpStruct, ExpStructData\n\n\ndef __get_data_class(obj_cls):\n    if obj_cls == Exp:\n        return ExpData\n    elif issubclass(obj_cls, ExpStruct):\n        return ExpStructData\n    else:\n        raise ArgumentsXManError(f\"`obj_cls` should inherit `ExpStruct`!\")", "\n\ndef make_proj(location_dir, name, descr) -> ExpProj:\n    make_and_save_struct_data(ExpProj, location_dir, name, descr)\n    return ExpProj(location_dir)\n\n\ndef recreate_proj(location_dir) -> Optional[ExpProj]:\n    proj = ExpProj(location_dir)\n    if platform.is_colab:\n        if not platform.check_colab_forked_folders(proj):\n            return None\n        for group in proj.groups():\n            if not platform.check_colab_forked_folders(group):\n                return None\n    return proj", "\n\ndef make_and_save_struct_data(struct_cls, location_dir, name, descr):\n    filesystem.prepare_dir(location_dir) if struct_cls == ExpProj else \\\n        filesystem.make_dir(location_dir, exist_ok=False)\n    data = __get_data_class(struct_cls)(name, descr)\n    filesystem.save_data_and_time(location_dir, data)\n\n\ndef get_child_class(parent_obj_or_cls):\n    cls = util.get_cls(parent_obj_or_cls)\n    if cls == ExpProj:\n        return ExpGroup\n    elif cls == ExpGroup:\n        return Exp\n    else:\n        raise ArgumentsXManError(f\"`parent_obj_or_cls` should be `ExpProj` or `ExpGroup`, but \"\n                                 f\"`{cls.__name__}` was given!\")", "\ndef get_child_class(parent_obj_or_cls):\n    cls = util.get_cls(parent_obj_or_cls)\n    if cls == ExpProj:\n        return ExpGroup\n    elif cls == ExpGroup:\n        return Exp\n    else:\n        raise ArgumentsXManError(f\"`parent_obj_or_cls` should be `ExpProj` or `ExpGroup`, but \"\n                                 f\"`{cls.__name__}` was given!\")", "\n\ndef make_new_child(parent, name, descr, child_num) -> Optional[Exp | ExpGroup]:\n    child_class = get_child_class(parent)\n    child_dir = filesystem.get_child_dir(parent, child_num)\n    make_and_save_struct_data(child_class, child_dir, name, descr)\n    child = child_class(child_dir, parent)\n    if platform.is_colab:\n        return child if platform.check_colab_forked_folders(parent) else None\n    return child", "\n\ndef recreate_child(parent, child_num):\n    location_dir = filesystem.get_child_dir(parent, child_num)\n    return get_child_class(parent)(location_dir, parent)\n\n\ndef delete_child(child: Exp | ExpGroup, need_confirm) -> bool:\n    if not filesystem.delete_dir(child.location_dir, need_confirm):\n        return False\n    child._destroy()\n    return True", "\n\ndef make_pipeline(exp, run_func, with_mediator, params, save_on_storage=False):\n    if exp._data.pipeline is not None:\n        raise AlreadyExistsXManError(f\"`{exp}` already has a pipeline!\")\n    exp._data.pipeline = PipelineData()\n    run_data = PipelineRunData(run_func, with_mediator, params)\n    if save_on_storage:\n        filesystem.save_pipeline_run_data(exp.location_dir, run_data)\n    return Pipeline(exp.location_dir, exp._data.pipeline, run_data)", "\n\ndef recreate_pipeline(exp):\n    run_data = filesystem.load_pipeline_run_data(exp.location_dir)\n    if run_data is None:\n        raise IllegalOperationXManError(f\"Can't recreate pipeline for exp `{exp}` - \"\n                                        f\"there's no `.run` data file! Use `save=True` for \"\n                                        f\"`make_pipeline()` method if you need to preserve \"\n                                        f\"`run_func` and `params` for other session.\")\n    return Pipeline(exp.location_dir, exp._data.pipeline, run_data)", "\n\ndef delete_pipeline(exp: Exp, pipeline: Pipeline):\n    filesystem.delete_pipeline_result(exp.location_dir)\n    exp.delete_checkpoints(need_confirm=False, delete_custom_paths=True)\n    filesystem.delete_pipeline_run_data(exp.location_dir)\n    filesystem.delete_pipeline_run_timestamp(exp.location_dir)\n    if pipeline is not None:\n        pipeline._destroy()\n    exp._data.pipeline = None", ""]}
{"filename": "src/xman/exp.py", "chunked_list": ["import time\nfrom typing import Any, Optional, Callable\n\nfrom .config import PipelineConfig\nfrom .error import NotExistsXManError, IllegalOperationXManError, AlreadyExistsXManError, \\\n    UnpredictableLogicXManError, NothingToDoXManError\nfrom .pipeline import PipelineData, CheckpointsMediator, Pipeline\nfrom .struct import ExpStructData, ExpStruct, ExpStructStatus\nfrom . import util, confirm, platform, filesystem\nfrom . import maker", "from . import util, confirm, platform, filesystem\nfrom . import maker\n\n\nclass ExpData(ExpStructData):\n\n    def __init__(self, name, descr):\n        super().__init__(name, descr)\n        self.pipeline: PipelineData = None\n        self.marker: str = None", "\n\nclass ExpState:\n\n    # Is 'IN_PROGRESS' status and executing right now ( + some buffer for the lag on Colab platform)\n    ACTIVE = 'ACTIVE'\n\n    # Any experiments except not manual in `IN_PROGRESS` status and is executing right now.\n    IDLE = 'IDLE'\n", "\n\nclass Exp(ExpStruct):\n\n    @property\n    def group(self) -> 'ExpGroup': return self.parent\n\n    @property\n    def proj(self) -> 'ExpProj': return self.parent.parent\n\n    @property\n    def state(self) -> str: return self.__state\n\n    @property\n    def has_pipeline(self) -> bool: return self._data.pipeline is not None\n\n    @property\n    def has_result(self) -> bool: return self.has_pipeline_result or self.has_manual_result\n\n    @property\n    def has_pipeline_result(self) -> bool:\n        return filesystem.has(filesystem.get_pipeline_result_path(self.location_dir))\n\n    @property\n    def has_manual_result(self) -> bool:\n        return filesystem.has(filesystem.get_manual_result_path(self.location_dir))\n\n    @property\n    def result(self) -> Optional[Any]:\n        if self.has_manual_result and self.has_pipeline_result:\n            raise IllegalOperationXManError(f\"There are two results in the `{self}` - manual result\"\n                                            f\" and pipeline result! Use `get_manual_result()` or \"\n                                            f\"`get_pipeline_result()` for checking them and delete \"\n                                            f\"manual or pipeline result.\")\n        if self.has_manual_result:\n            return self.get_manual_result()\n        if self.has_pipeline_result:\n            return self.get_pipeline_result()\n        raise IllegalOperationXManError(f\"There's no any result in the `{self}`!\")\n\n    @property\n    def error(self) -> Optional[str]:\n        return None if self._data.pipeline is None else self._data.pipeline.error\n\n    @property\n    def error_stack(self) -> Optional[str]:\n        return None if self._data.pipeline is None else self._data.pipeline.error_stack\n\n    @property\n    def is_active(self) -> bool: return self.state == ExpState.ACTIVE\n\n    @property\n    def is_ready_for_start(self) -> bool:\n        if self.is_manual:\n            return False\n        return self.status.status_str == ExpStructStatus.TO_DO or \\\n            (self.status.status_str == ExpStructStatus.IN_PROGRESS and self.state == ExpState.IDLE)\n\n    @property\n    def checkpoints_mediator(self) -> CheckpointsMediator:\n        if self.__checkpoints_mediator is None:\n            self.__checkpoints_mediator = CheckpointsMediator(self.location_dir)\n        return self.__checkpoints_mediator\n\n    @property\n    def marker(self) -> str: return self._data.marker\n\n    @marker.setter\n    def marker(self, value):\n        self._data.marker = value\n        self._save()\n\n    def info(self) -> str:\n        text = super().info()\n        if self.has_result:\n            text += util.tab(f\"\\nResult:\\n{util.tab(self.stringify_result())}\")\n        return text\n\n    def stringify_result(self) -> str:\n        rs = self.result_stringifier\n        if rs is None:\n            rs = self.parent.result_stringifier\n            if rs is None:\n                rs = self.parent.parent.result_stringifier\n        return str(self.result) if rs is None else rs(self.result)\n\n    def view_result(self):\n        rv = self.result_viewer\n        if rv is None:\n            rv = self.parent.result_viewer\n            if rv is None:\n                rv = self.parent.parent.result_viewer\n        print(self.result) if rv is None else rv(self.result)\n\n    def make_pipeline(self, run_func: Callable[..., Any],\n                      params: dict, save_on_storage: bool = False) -> 'Exp':\n        return self.__make_pipeline(run_func, False, params, save_on_storage)\n\n    def make_pipeline_with_checkpoints(self,\n                               run_func_with_mediator: Callable[[CheckpointsMediator, ...], Any],\n                               params: dict, save_on_storage: bool = False) -> 'Exp':\n        return self.__make_pipeline(run_func_with_mediator, True, params, save_on_storage)\n\n    def delete_pipeline(self, need_confirm: bool = True) -> Optional['Exp']:\n        self._check_is_not_active()\n        if self._data.pipeline is None:\n            raise NotExistsXManError(f\"There's no pipeline in exp `{self}`!\")\n        if confirm.request(need_confirm, f\"ATTENTION! Remove the pipeline of exp `{self}`\\n\"\n                f\"(it will also delete the pipeline result, all checkpoints, and data)?\"):\n            maker.delete_pipeline(self, self.__pipeline)\n            self.__pipeline = None\n            self._save()\n            return self\n        return None\n\n    def delete_checkpoints(self, need_confirm: bool = True, delete_custom_paths: bool = False) -> Optional['Exp']:\n        self._check_is_not_active()\n        if not confirm.request(need_confirm,\n                               f\"ATTENTION! Do you want to delete `{self}` checkpoints?\"):\n            return None\n        if delete_custom_paths:\n            lst = self.checkpoints_mediator.get_checkpoint_paths_list(check_files_exist=True)\n            if lst is not None:\n                for cp_path in lst:\n                    filesystem.delete_checkpoint(self.location_dir, cp_path)\n        filesystem.delete_checkpoints_dir(self.location_dir, need_confirm=False)\n        return self\n\n    def start(self, force_after_error: bool = False) -> 'Exp':\n        if self.has_manual_result:\n            raise IllegalOperationXManError(f\"The `{self}` already has a manual result - delete it \"\n                                            f\"with `delete_manual_result()` method first!\")\n        pipeline_data = self._data.pipeline\n        if self.status.status_str == ExpStructStatus.ERROR and force_after_error:\n            pipeline_data.started = False\n            pipeline_data.error = None\n            pipeline_data.error_stack = None\n            self.update()\n        if self.is_ready_for_start:\n            if filesystem.has_checkpoints_dir(self.location_dir) and \\\n                    self.status.status_str == ExpStructStatus.TO_DO:\n                raise IllegalOperationXManError(f\"`{self}` contains checkpoints folder - delete it \"\n                                                f\"first with `delete_checkpoints()` method!\")\n            if self.__pipeline is None:\n                self.__pipeline = maker.recreate_pipeline(self)\n            pipeline_data.started = True\n            self._save()\n            try:\n                self.__pipeline.start()\n            finally:\n                self._save()\n                self.__pipeline._destroy()\n                self.__pipeline = None\n                if pipeline_data.finished:\n                    filesystem.delete_pipeline_run_data(self.location_dir)\n        else:\n            self._check_is_not_active()\n            if self.is_manual:\n                raise IllegalOperationXManError(f\"Can't start the `{self}` as it's manual - use \"\n                                                f\"`delete_manual_status()` method first!\")\n            if pipeline_data is None:  # status == 'EMPTY'\n                raise NotExistsXManError(f\"`The {self}` doesn't have a pipeline!\")\n            if pipeline_data.error:  # status == 'ERROR'\n                raise IllegalOperationXManError(\n                    f\"The `{self}` has an error during the previous start! You can use \"\n                    f\"`force_after_error=True` flag.\")\n            if pipeline_data.finished:  # status == 'DONE'\n                raise IllegalOperationXManError(f\"`The {self}` was already finished!\")\n        return self\n\n    def get_pipeline_result(self) -> Any:\n        if not self.has_pipeline_result:\n            raise IllegalOperationXManError(f\"There's no pipeline result in the `{self}`!\")\n        return filesystem.load_pipeline_result(self.location_dir)\n\n    def get_manual_result(self) -> Any:\n        if not self.has_manual_result:\n            raise IllegalOperationXManError(f\"There's no manual result in the `{self}`!\")\n        return filesystem.load_manual_result(self.location_dir)\n\n    def set_manual_result(self, result: Any) -> 'Exp':\n        if self.has_manual_result:\n            raise AlreadyExistsXManError(f\"Already has a manual result! Delete it first with \"\n                                         f\"`delete_manual_result()` method.\")\n        filesystem.save_manual_result(self.location_dir, result)\n        return self\n\n    def delete_manual_result(self, need_confirm: bool = True) -> Optional['Exp']:\n        if not self.has_manual_result:\n            raise NotExistsXManError(f\"There's no manual result in the `{self}`!\")\n        if not confirm.request(need_confirm,\n                f\"ATTENTION! The manual result for the `{self}\\nwill be deleted - proceed?\"):\n            return None\n        filesystem.delete_manual_result(self.location_dir)\n        return self\n\n    def delete_all_manual(self, need_confirm: bool = True) -> Optional['Exp']:\n        if not self.is_manual and not self.has_manual_result:\n            raise NothingToDoXManError(f\"There's nothing manual to delete in the `{self}`!\")\n        if not confirm.request(need_confirm, f\"ATTENTION! Manual status and resolution, and manual\"\n                                             f\"result will be deleted - proceed?\"):\n            return None\n        self._data.manual_status = None\n        self._data.manual_status_resolution = None\n        if self.has_manual_result:\n            filesystem.delete_manual_result(self.location_dir)\n        return self\n\n    def clear(self, need_confirm: bool = True) -> Optional['Exp']:\n        self._check_is_not_active()\n        if not confirm.request(need_confirm,\n                f\"ATTENTION! The `{self}`\\nwill be cleared as it just was created - proceed?\"):\n            return None\n        if self.has_pipeline:\n            self.delete_pipeline(need_confirm=False)\n        if self.has_pipeline_result:\n            filesystem.delete_pipeline_result(self.location_dir)\n        self.delete_checkpoints(need_confirm=False, delete_custom_paths=True)\n        self.__checkpoints_mediator = None\n        if self.has_manual_result:\n            filesystem.delete_manual_result(self.location_dir)\n        self._data.manual_status = None\n        self._data.manual_status_resolution = None\n        self.result_stringifier = None\n        self.result_viewer = None\n        self.note.clear()\n        self.__note = None\n        self._save()\n        return self\n\n    def update(self):\n        if self.__updating:\n            return\n        self.__updating = True\n        super().update()\n        # Status and state should be updated at the end of the inherited updating hierarchy\n        if type(self) == Exp:\n            self._update_status()\n            self.__update_state()\n        self.__updating = False\n\n    def _process_auto_status(self):\n        resolution = ExpStruct._AUTO_STATUS_RESOLUTION\n        pipeline_data = self._data.pipeline\n        if pipeline_data is None:\n            status = ExpStructStatus.EMPTY\n        elif not pipeline_data.started:\n            status = ExpStructStatus.TO_DO\n        elif pipeline_data.error is not None:\n            status = ExpStructStatus.ERROR\n            resolution = str(pipeline_data.error)\n        elif pipeline_data.finished:\n            status = ExpStructStatus.DONE\n        else:\n            status = ExpStructStatus.IN_PROGRESS\n        return status, resolution\n\n    def _check_is_not_active(self):\n        if self.is_active:\n            raise IllegalOperationXManError(f\"Illegal operation while the experiment is active - \"\n                                            f\"has a pipeline that is executing right now!\")\n\n    def _destroy(self):\n        if self.__pipeline is not None:\n            if self.is_active:\n                raise UnpredictableLogicXManError(f\"It shouldn't be, but if you're reading this... \"\n                        f\"So, something extraordinary has happened - congrats and my condolences!)\")\n            self.__pipeline._destroy()\n        self._data.pipeline = None\n        self._data = None\n        self.__checkpoints_mediator = None\n        super()._destroy()\n\n    def __init__(self, location_dir, parent):\n        from .api import ExpAPI\n        self._data: ExpData = None\n        self.__state = None\n        self.__pipeline: Pipeline = None\n        self.__checkpoints_mediator: CheckpointsMediator = None\n        self.__updating = False\n        super().__init__(location_dir, parent)\n        self._api = ExpAPI(self)\n\n    def __str__(self):\n        state = f\": {self.state}\" if self.status.status_str == ExpStructStatus.IN_PROGRESS else ''\n        marker = '' if self.marker is None or self.marker == '' else self.marker + ' '\n        return (f\"{marker}Exp {self.group.num}.{self.num} [{self.status}{state}] \"\n                f\"{self.name} - {self.descr}\")\n\n    def __is_active_by_time_delta(self):\n        run_timestamp = filesystem.load_pipeline_run_timestamp(self.location_dir)\n        if run_timestamp is None:\n            return False\n        active_buffer = PipelineConfig.active_buffer_colab if platform.is_colab \\\n            else PipelineConfig.active_buffer\n        return time.time() - run_timestamp < PipelineConfig.timer_interval + active_buffer\n\n    def __is_active(self):\n        p_data = self._data.pipeline\n        return p_data is not None and p_data.started and not p_data.finished and \\\n            p_data.error is None and self.__is_active_by_time_delta()\n\n    def __update_state(self):\n        self.__state = ExpState.ACTIVE if self.__is_active() else ExpState.IDLE\n\n    def __make_pipeline(self, run_func, with_mediator, params, save_on_storage):\n        if self._data.pipeline is not None:\n            raise AlreadyExistsXManError(f\"`{self}` already has a pipeline!\")\n        self.__pipeline = maker.make_pipeline(self, run_func, with_mediator, params,\n                                              save_on_storage)\n        self._save()\n        return self", ""]}
{"filename": "src/xman/error.py", "chunked_list": ["import traceback\n\n\ndef get_error_str(error: Exception) -> str:\n    return f\"{error.__class__.__name__}: {error.args[0] if len(error.args) == 1 else error.args}\"\n\n\ndef get_error_stack_str(error: Exception) -> str:\n    stack = 'Traceback (most recent call last):\\n'\n    stack += ''.join(traceback.format_tb(error.__traceback__))\n    stack += 'ERROR:\\n    ' + get_error_str(error)\n    return stack", "\n\nclass XManError(Exception):  # It's better not to use this generic error\n    pass\n\n\nclass IllegalOperationXManError(XManError):\n    pass\n\n\nclass NotExistsXManError(XManError):\n    pass", "\n\nclass NotExistsXManError(XManError):\n    pass\n\n\nclass AlreadyExistsXManError(XManError):\n    pass\n\n\nclass ArgumentsXManError(XManError):\n    pass", "\n\nclass ArgumentsXManError(XManError):\n    pass\n\n\nclass OverrideXManError(XManError):\n    pass\n\n\nclass NothingToDoXManError(XManError):\n    pass", "\n\nclass NothingToDoXManError(XManError):\n    pass\n\n\nclass NotImplementedXManError(XManError):\n    pass\n\n\nclass UnpredictableLogicXManError(XManError):\n    pass", "\n\nclass UnpredictableLogicXManError(XManError):\n    pass\n"]}
