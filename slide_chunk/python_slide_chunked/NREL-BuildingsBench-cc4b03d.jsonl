{"filename": "setup.py", "chunked_list": ["import re\nimport io\nimport os\nfrom setuptools import setup, find_packages\n\nwith open('requirements.txt') as f:\n    requirements = f.read()\n\nwith open('README.md') as f:\n    readme = f.read()", "with open('README.md') as f:\n    readme = f.read()\n\n# Read the version from the __init__.py file without importing it\ndef read(*names, **kwargs):\n    with io.open(\n            os.path.join(os.path.dirname(__file__), *names),\n            encoding=kwargs.get(\"encoding\", \"utf8\")\n    ) as fp:\n        return fp.read()", "    \ndef find_version(*file_paths):\n    version_file = read(*file_paths)\n    version_match = re.search(r\"^__version__ = ['\\\"]([^'\\\"]*)['\\\"]\",\n                              version_file, re.M)\n    if version_match:\n        return version_match.group(1)\n    raise RuntimeError(\"Unable to find version string.\")\n    \nsetup(", "    \nsetup(\n      name='buildings_bench',\n      version=find_version('buildings_bench', '__init__.py'),\n      description='Large-scale pretraining and benchmarking for short-term load forecasting.',\n      author='Patrick Emami',\n      author_email='Patrick.Emami@nrel.gov',\n      url=\"https://nrel.github.io/BuildingsBench/\",\n      long_description=readme,\n      long_description_content_type='text/markdown',", "      long_description=readme,\n      long_description_content_type='text/markdown',\n      install_requires=requirements,\n      packages=find_packages(include=['buildings_bench',\n                                      'buildings_bench.data',\n                                      'buildings_bench.evaluation',\n                                      'buildings_bench.models'],\n                             exclude=['test']),\n      package_data={'buildings_bench': ['configs/*.toml']},\n      license='BSD 3-Clause',", "      package_data={'buildings_bench': ['configs/*.toml']},\n      license='BSD 3-Clause',\n      python_requires='>=3.8',\n      extras_require={\n            'benchmark': ['transformers', 'wandb', 'properscoring', 'matplotlib', 'seaborn', 'jupyterlab']\n      },\n      keywords=['forecasting', 'energy', 'buildings', 'benchmark'],\n      classifiers=[\n            \"Development Status :: 3 - Alpha\",\n            \"Intended Audience :: Science/Research\",", "            \"Development Status :: 3 - Alpha\",\n            \"Intended Audience :: Science/Research\",\n            \"License :: OSI Approved :: BSD License\",\n            \"Natural Language :: English\",\n            \"Programming Language :: Python :: 3\",\n            \"Topic :: Scientific/Engineering :: Artificial Intelligence\",\n        ]\n)\n", ""]}
{"filename": "test/test_transforms.py", "chunked_list": ["import unittest\nfrom buildings_bench import transforms\nfrom pathlib import Path\nimport os\nimport numpy as np\nimport torch\nimport pandas as pd\n\n\nclass TestStandardScaler(unittest.TestCase):\n    def setUp(self):\n\n        self.ss = transforms.StandardScalerTransform()\n        save_dir = os.environ.get('BUILDINGS_BENCH', '')\n        self.ss.load(Path(save_dir) / 'metadata' / 'transforms')\n\n\n    def test_load_standard_scaler(self):\n\n    \n        self.assertIsNotNone(self.ss.mean_, True)\n        self.assertIsNotNone(self.ss.std_, True)\n\n\n    def test_standard_scale(self):\n        \n        x = torch.FloatTensor([[100.234], [0.234], [55.523]])\n    \n        y = self.ss.transform(x)\n        z = self.ss.undo_transform(y)\n\n        self.assertTrue(torch.allclose(x, z, atol=1e-3))", "\nclass TestStandardScaler(unittest.TestCase):\n    def setUp(self):\n\n        self.ss = transforms.StandardScalerTransform()\n        save_dir = os.environ.get('BUILDINGS_BENCH', '')\n        self.ss.load(Path(save_dir) / 'metadata' / 'transforms')\n\n\n    def test_load_standard_scaler(self):\n\n    \n        self.assertIsNotNone(self.ss.mean_, True)\n        self.assertIsNotNone(self.ss.std_, True)\n\n\n    def test_standard_scale(self):\n        \n        x = torch.FloatTensor([[100.234], [0.234], [55.523]])\n    \n        y = self.ss.transform(x)\n        z = self.ss.undo_transform(y)\n\n        self.assertTrue(torch.allclose(x, z, atol=1e-3))", "\n\nclass TestBoxCox(unittest.TestCase):\n    def setUp(self):\n\n        self.bc = transforms.BoxCoxTransform()\n        metadata_dir = os.environ.get('BUILDINGS_BENCH', '')\n        self.bc.load(Path(metadata_dir) / 'metadata' / 'transforms')\n\n\n    def test_load_boxcox(self):\n        self.assertIsNotNone(self.bc.boxcox.lambdas_, True)\n\n\n    def test_boxcox(self):\n            \n        x = torch.FloatTensor([[100.234], [0.234], [55.523]])\n    \n        y = self.bc.transform(x)\n        z = self.bc.undo_transform(torch.from_numpy(y).float())\n\n        # assert allclose\n        self.assertTrue(torch.allclose(x, z, atol=1e-3))", "\n\nclass TestLatLonTransform(unittest.TestCase):\n    def setUp(self):\n        self.ll = transforms.LatLonTransform()\n\n    def test_load_latlon(self):\n        self.assertIsNotNone(self.ll.lat_means, True)\n        self.assertIsNotNone(self.ll.lon_means, True)\n        self.assertIsNotNone(self.ll.lat_stds, True)\n        self.assertIsNotNone(self.ll.lon_stds, True)\n\n    def test_latlon(self):\n        x = np.array([[100.234, 0.234], [0.234, 55.523], [55.523, 100.234]])\n        y = self.ll.transform_latlon(x)\n        z = self.ll.undo_transform(y)\n\n        self.assertTrue(np.allclose(x, z, atol=1e-3))", "\n\nclass TestTimestampTransform(unittest.TestCase):\n    def setUp(self):\n        self.tt = transforms.TimestampTransform()\n\n    def test_timestamp(self):\n        x = np.array(['2016-01-01 00:00:00', '2016-01-01 01:00:00'])\n        # convert x to dataframe\n        x = pd.DataFrame(x, columns=['timestamp'])\n        y = self.tt.transform(x.timestamp)\n        z = self.tt.undo_transform(y)\n\n        #print(x,y,z)\n        self.assertEqual(z[0,0], pd.to_datetime(x.timestamp).dt.dayofyear.values[0])\n        self.assertEqual(z[0,1], pd.to_datetime(x.timestamp).dt.dayofweek.values[0])\n        self.assertEqual(z[0,2], pd.to_datetime(x.timestamp).dt.hour.values[0])", "\n\n"]}
{"filename": "test/test_scoring_rules.py", "chunked_list": ["import unittest\nimport numpy as np\nimport torch\nfrom buildings_bench.evaluation.scoring_rules import ContinuousRankedProbabilityScore\nfrom buildings_bench.evaluation.scoring_rules import RankedProbabilityScore\n\n\nclass TestRPS(unittest.TestCase):\n    \"\"\"\n    Test the categorical ranked probability score\n    \"\"\"\n    def setUp(self):\n        np.random.seed(1984)\n\n        \n    def test_rps(self):\n        rps = RankedProbabilityScore()\n        y_true = torch.from_numpy(np.random.randint(0, 10, size=(2, 3, 1)))\n        y_pred_logits = torch.from_numpy(np.random.normal(size=(2, 3, 10)))    \n        bin_values = torch.from_numpy(np.random.normal(size=(10,)))        \n        rps(None, y_true, y_pred_logits, bin_values)\n        \n    def test_bin_widths(self):\n        rps = RankedProbabilityScore()\n        bin_values = torch.FloatTensor([1., 5., 7.])\n        y_true = torch.FloatTensor([[[0.], [1.]]]) # batch_size 1, seq_len 2, 1\n        y_pred_logits = torch.FloatTensor([[[0.9, 0.1, 0.], [0.1, 0.9, 0.]]]) # batch_size 1, seq_len 2, vocab_size 3\n        rps(None, y_true, y_pred_logits, bin_values)\n        rps.mean()\n        print(rps.value)", "\n\nclass TestContinuousRPS(unittest.TestCase):\n    \"\"\"\n    https://github.com/properscoring/properscoring/blob/master/properscoring/tests/test_crps.py\n    \"\"\"\n\n    def setUp(self):\n        np.random.seed(1983)\n        shape = (2, 3, 1)\n        self.mu = torch.from_numpy(np.random.normal(size=shape))\n        self.sig = torch.from_numpy(np.square(np.random.normal(size=shape)))\n        self.params = torch.concatenate([self.mu, self.sig], dim=-1)\n\n        self.obs = torch.from_numpy(np.random.normal(loc=self.mu, scale=self.sig, size=shape))\n        self.crps = ContinuousRankedProbabilityScore()\n\n\n    def test_continuous_rps(self):\n        self.crps(self.obs, None, self.params, None)\n        self.crps.mean()\n        print(self.crps.value)\n\n\n    def test_continuous_rps_correct(self):\n        from properscoring import crps_ensemble\n        from scipy import special\n\n        n = 1000\n        q = np.linspace(0. + 0.5 / n, 1. - 0.5 / n, n)\n        # convert to the corresponding normal deviates\n        normppf = special.ndtri\n        z = normppf(q)\n\n        sig = self.sig.squeeze(2).numpy()\n        mu = self.mu.squeeze(2).numpy()\n        forecasts = (z.reshape(-1, 1, 1) * sig) + mu\n        expected = crps_ensemble(self.obs.squeeze(2).numpy(),\n                                  forecasts, axis=0)\n        expected = expected.mean(0)\n\n        self.crps(self.obs, None, self.params, None)\n        self.crps.mean()\n        actual = self.crps.value\n\n        np.testing.assert_allclose(actual, expected, rtol=1e-4)", ""]}
{"filename": "test/test_datasets.py", "chunked_list": ["import unittest\nfrom buildings_bench import load_torch_dataset, load_pandas_dataset, load_pretraining\nfrom buildings_bench.data.datasets import PandasBuildingDatasetsFromCSV\nfrom buildings_bench import BuildingTypes\nfrom pathlib import Path\nimport torch\nimport os\n\nclass TestLoadDatasets(unittest.TestCase):\n\n    def test_dataset_not_in_registry(self):\n        with self.assertRaises(ValueError):\n            datasets = load_torch_dataset('not-a-dataset')\n\n\n    def test_load_buildings900k_test(self):\n        building_dataset_generator = load_torch_dataset('buildings-900k-test')\n        for building_name, building in building_dataset_generator:\n                print(f'building {building_name} dataset length: {len(building)}')\n                # create a dataloader for the building\n                building_dataloader = torch.utils.data.DataLoader(building, batch_size=256, shuffle=False)\n                for sample in building_dataloader:\n                    x = sample['load']\n                    break\n                break\n\n    def test_load_electricity(self):\n        building_dataset_generator = load_torch_dataset('electricity')\n        for building_name, building in building_dataset_generator:\n            print(f'building {building_name} dataset length: {len(building)}')\n            # create a dataloader for the building\n            building_dataloader = torch.utils.data.DataLoader(building, batch_size=256, shuffle=False)\n            for sample in building_dataloader:\n                x = sample['load']\n                break\n            break\n\n    def test_load_sceaux(self):\n        building_dataset_generator = load_torch_dataset('sceaux')\n        for building_name, building in building_dataset_generator:\n            print(f'building {building_name} dataset length: {len(building)}')\n            # create a dataloader for the building\n            building_dataloader = torch.utils.data.DataLoader(building, batch_size=256, shuffle=False)\n            for sample in building_dataloader:\n                x = sample['load']\n                break\n            break\n\n    def test_load_borealis(self):\n        building_dataset_generator = load_torch_dataset('borealis')\n        for building_name, building in building_dataset_generator:\n            print(f'building {building_name} dataset length: {len(building)}')\n            # create a dataloader for the building\n            building_dataloader = torch.utils.data.DataLoader(building, batch_size=256, shuffle=False)\n            for sample in building_dataloader:\n                x = sample['load']\n                break\n            break\n\n    def test_load_bdg2_panther(self):\n        building_dataset_generator = load_torch_dataset('bdg-2:panther')\n        for building_name, building in building_dataset_generator:\n            print(f'building {building_name} dataset length: {len(building)}')\n            # create a dataloader for the building\n            building_dataloader = torch.utils.data.DataLoader(building, batch_size=256, shuffle=False)\n            for sample in building_dataloader:\n                x = sample['load']\n                break\n            break\n\n    def test_load_bdg2_rat(self):\n        building_dataset_generator = load_torch_dataset('bdg-2:rat')\n        for building_name, building in building_dataset_generator:\n            print(f'building {building_name} dataset length: {len(building)}')\n            # create a dataloader for the building\n            building_dataloader = torch.utils.data.DataLoader(building, batch_size=256, shuffle=False)\n            for sample in building_dataloader:\n                x = sample['load']\n                break\n            break\n\n    def test_load_ideal(self):\n        building_dataset_generator = load_torch_dataset('ideal')\n        for building_name, building in building_dataset_generator:\n            print(f'building {building_name} dataset length: {len(building)}')\n            # create a dataloader for the building\n            building_dataloader = torch.utils.data.DataLoader(building, batch_size=256, shuffle=False)\n            for sample in building_dataloader:\n                x = sample['load']\n                break\n            break\n    \n\n    def test_load_lcl(self):\n        building_dataset_generator = load_torch_dataset('lcl')\n        for building_name, building in building_dataset_generator:\n            print(f'building {building_name} dataset length: {len(building)}')\n            # create a dataloader for the building\n            building_dataloader = torch.utils.data.DataLoader(building, batch_size=256, shuffle=False)\n            for sample in building_dataloader:\n                x = sample['load']\n                break\n            break\n\n    def test_load_smart(self):\n        building_dataset_generator = load_torch_dataset('smart')\n        for building_name, building in building_dataset_generator:\n            print(f'building {building_name} dataset length: {len(building)}')\n            # create a dataloader for the building\n            building_dataloader = torch.utils.data.DataLoader(building, batch_size=256, shuffle=False)\n            for sample in building_dataloader:\n                x = sample['load']\n                break\n            break\n\n    \n    def test_load_pandas_datasets_direct(self):\n        dataset_path = Path(os.environ['BUILDINGS_BENCH'])\n        \n        building_files = ['BDG-2/Bear_clean=2016', 'BDG-2/Bear_clean=2017']\n\n        datasets = PandasBuildingDatasetsFromCSV(\n                    dataset_path,\n                    building_files,\n                    [23.123, -32.1234],\n                    BuildingTypes.COMMERCIAL,\n                    features='transformer')\n\n        for building_name, building_dset in datasets:\n            print(f'building {building_name}, shape {len(building_dset)}')\n            break\n\n        datasets = PandasBuildingDatasetsFromCSV(\n                    dataset_path,\n                    building_files,\n                    [23.123, -32.1234],\n                    BuildingTypes.COMMERCIAL,\n                    features='engineered'\n                    )\n\n        for building_name, building_dset in datasets:\n            print(f'building {building_name}, shape {len(building_dset)}')\n            break\n\n    def test_load_pandas_datasets(self):\n        \n        datasets = load_pandas_dataset('bdg-2:bear')\n\n        for building_name, building_dset in datasets:\n            print(f'building {building_name}, shape {len(building_dset)}')\n            break", "class TestLoadDatasets(unittest.TestCase):\n\n    def test_dataset_not_in_registry(self):\n        with self.assertRaises(ValueError):\n            datasets = load_torch_dataset('not-a-dataset')\n\n\n    def test_load_buildings900k_test(self):\n        building_dataset_generator = load_torch_dataset('buildings-900k-test')\n        for building_name, building in building_dataset_generator:\n                print(f'building {building_name} dataset length: {len(building)}')\n                # create a dataloader for the building\n                building_dataloader = torch.utils.data.DataLoader(building, batch_size=256, shuffle=False)\n                for sample in building_dataloader:\n                    x = sample['load']\n                    break\n                break\n\n    def test_load_electricity(self):\n        building_dataset_generator = load_torch_dataset('electricity')\n        for building_name, building in building_dataset_generator:\n            print(f'building {building_name} dataset length: {len(building)}')\n            # create a dataloader for the building\n            building_dataloader = torch.utils.data.DataLoader(building, batch_size=256, shuffle=False)\n            for sample in building_dataloader:\n                x = sample['load']\n                break\n            break\n\n    def test_load_sceaux(self):\n        building_dataset_generator = load_torch_dataset('sceaux')\n        for building_name, building in building_dataset_generator:\n            print(f'building {building_name} dataset length: {len(building)}')\n            # create a dataloader for the building\n            building_dataloader = torch.utils.data.DataLoader(building, batch_size=256, shuffle=False)\n            for sample in building_dataloader:\n                x = sample['load']\n                break\n            break\n\n    def test_load_borealis(self):\n        building_dataset_generator = load_torch_dataset('borealis')\n        for building_name, building in building_dataset_generator:\n            print(f'building {building_name} dataset length: {len(building)}')\n            # create a dataloader for the building\n            building_dataloader = torch.utils.data.DataLoader(building, batch_size=256, shuffle=False)\n            for sample in building_dataloader:\n                x = sample['load']\n                break\n            break\n\n    def test_load_bdg2_panther(self):\n        building_dataset_generator = load_torch_dataset('bdg-2:panther')\n        for building_name, building in building_dataset_generator:\n            print(f'building {building_name} dataset length: {len(building)}')\n            # create a dataloader for the building\n            building_dataloader = torch.utils.data.DataLoader(building, batch_size=256, shuffle=False)\n            for sample in building_dataloader:\n                x = sample['load']\n                break\n            break\n\n    def test_load_bdg2_rat(self):\n        building_dataset_generator = load_torch_dataset('bdg-2:rat')\n        for building_name, building in building_dataset_generator:\n            print(f'building {building_name} dataset length: {len(building)}')\n            # create a dataloader for the building\n            building_dataloader = torch.utils.data.DataLoader(building, batch_size=256, shuffle=False)\n            for sample in building_dataloader:\n                x = sample['load']\n                break\n            break\n\n    def test_load_ideal(self):\n        building_dataset_generator = load_torch_dataset('ideal')\n        for building_name, building in building_dataset_generator:\n            print(f'building {building_name} dataset length: {len(building)}')\n            # create a dataloader for the building\n            building_dataloader = torch.utils.data.DataLoader(building, batch_size=256, shuffle=False)\n            for sample in building_dataloader:\n                x = sample['load']\n                break\n            break\n    \n\n    def test_load_lcl(self):\n        building_dataset_generator = load_torch_dataset('lcl')\n        for building_name, building in building_dataset_generator:\n            print(f'building {building_name} dataset length: {len(building)}')\n            # create a dataloader for the building\n            building_dataloader = torch.utils.data.DataLoader(building, batch_size=256, shuffle=False)\n            for sample in building_dataloader:\n                x = sample['load']\n                break\n            break\n\n    def test_load_smart(self):\n        building_dataset_generator = load_torch_dataset('smart')\n        for building_name, building in building_dataset_generator:\n            print(f'building {building_name} dataset length: {len(building)}')\n            # create a dataloader for the building\n            building_dataloader = torch.utils.data.DataLoader(building, batch_size=256, shuffle=False)\n            for sample in building_dataloader:\n                x = sample['load']\n                break\n            break\n\n    \n    def test_load_pandas_datasets_direct(self):\n        dataset_path = Path(os.environ['BUILDINGS_BENCH'])\n        \n        building_files = ['BDG-2/Bear_clean=2016', 'BDG-2/Bear_clean=2017']\n\n        datasets = PandasBuildingDatasetsFromCSV(\n                    dataset_path,\n                    building_files,\n                    [23.123, -32.1234],\n                    BuildingTypes.COMMERCIAL,\n                    features='transformer')\n\n        for building_name, building_dset in datasets:\n            print(f'building {building_name}, shape {len(building_dset)}')\n            break\n\n        datasets = PandasBuildingDatasetsFromCSV(\n                    dataset_path,\n                    building_files,\n                    [23.123, -32.1234],\n                    BuildingTypes.COMMERCIAL,\n                    features='engineered'\n                    )\n\n        for building_name, building_dset in datasets:\n            print(f'building {building_name}, shape {len(building_dset)}')\n            break\n\n    def test_load_pandas_datasets(self):\n        \n        datasets = load_pandas_dataset('bdg-2:bear')\n\n        for building_name, building_dset in datasets:\n            print(f'building {building_name}, shape {len(building_dset)}')\n            break", "\n\nif __name__ == '__main__':\n    unittest.main()\n"]}
{"filename": "test/test_metrics.py", "chunked_list": ["import unittest\nfrom buildings_bench import evaluation\nimport torch \n\n\nclass TestMetrics(unittest.TestCase):\n    def setUp(self):\n        # Test torch tensor\n        self.y_true = torch.FloatTensor([1, 2, 3]).view(1,3,1)\n        self.y_pred = torch.FloatTensor([1, 2, 3]).view(1,3,1)\n\n    def test_mae(self):\n        mae = evaluation.metrics_factory('mae', \n                                         types=[evaluation.MetricType.SCALAR])\n        self.assertEqual(len(mae), 1)\n\n        mae = mae[0]\n        self.assertEqual(mae.name, 'mae-scalar')\n        self.assertEqual(mae.type, evaluation.MetricType.SCALAR)\n        self.assertEqual(mae.UNUSED_FLAG, True)\n        # Test call\n        mae(self.y_true, self.y_pred)\n        mae.mean()\n\n        self.assertEqual(\n            mae.value,\n            torch.FloatTensor([0])\n        )\n        self.assertEqual(mae.UNUSED_FLAG, False)\n\n\n    def test_cvrmse(self):\n        cvrmse = evaluation.metrics_factory('cvrmse',\n                                            types=[evaluation.MetricType.SCALAR])\n        self.assertEqual(len(cvrmse), 1)\n        cvrmse = cvrmse[0]\n        self.assertEqual(cvrmse.name, 'cvrmse-scalar')\n        self.assertEqual(cvrmse.type, evaluation.MetricType.SCALAR)\n        self.assertEqual(cvrmse.UNUSED_FLAG, True)\n        # Test call\n        cvrmse(self.y_true, self.y_pred)\n        cvrmse.mean()\n        self.assertEqual(\n            cvrmse.value,\n            torch.FloatTensor([0])\n        )\n        self.assertEqual(cvrmse.UNUSED_FLAG, False)\n\n\n    def test_mbe(self):\n        mbe = evaluation.metrics_factory('mbe',\n                                         types=[evaluation.MetricType.SCALAR])\n        self.assertEqual(len(mbe), 1)\n        mbe = mbe[0]\n        self.assertEqual(mbe.name, 'mbe-scalar')\n        self.assertEqual(mbe.type, evaluation.MetricType.SCALAR)\n        self.assertEqual(mbe.UNUSED_FLAG, True)\n        # Test call\n        mbe(self.y_true, self.y_pred)\n        mbe.mean()\n        self.assertEqual(\n            mbe.value,\n            torch.FloatTensor([0])\n        )\n        self.assertEqual(mbe.UNUSED_FLAG, False)"]}
{"filename": "test/test_managers.py", "chunked_list": ["import unittest\nfrom buildings_bench.evaluation.managers import MetricsManager, DatasetMetricsManager\nfrom buildings_bench.evaluation import metrics_factory\nfrom buildings_bench.evaluation import scoring_rule_factory\nfrom buildings_bench import BuildingTypes\nimport torch\n\n\nclass TestMetricsManager(unittest.TestCase):\n       \n        \n    def test_create_dataset_metrics_manager_single_metric(self):\n        metrics_manager = MetricsManager(\n            metrics=metrics_factory('mae')\n        )\n\n        self.assertEqual(len(metrics_manager.metrics[BuildingTypes.RESIDENTIAL]), 1)\n        self.assertEqual(len(metrics_manager.metrics[BuildingTypes.COMMERCIAL]), 1)\n        self.assertEqual(metrics_manager.metrics[BuildingTypes.RESIDENTIAL][0].name, 'mae-scalar')\n\n    def test_create_dataset_metrics_manager_multiple_metrics(self):\n        metrics_manager = MetricsManager(\n            metrics=metrics_factory('mae') + metrics_factory('rmse')\n        )\n\n        self.assertEqual(len(metrics_manager.metrics[BuildingTypes.RESIDENTIAL]), 2)\n        self.assertEqual(len(metrics_manager.metrics[BuildingTypes.COMMERCIAL]), 2)\n        self.assertEqual(metrics_manager.metrics[BuildingTypes.RESIDENTIAL][0].name, 'mae-scalar')\n        self.assertEqual(metrics_manager.metrics[BuildingTypes.RESIDENTIAL][1].name, 'rmse-scalar')\n    \n    def test_create_dataset_metrics_manager_with_scoring_rule(self):\n        metrics_manager = MetricsManager(\n            scoring_rule=scoring_rule_factory('rps')\n        )\n\n        self.assertEqual(len(metrics_manager.scoring_rules), 2)\n        self.assertEqual(metrics_manager.scoring_rules[BuildingTypes.RESIDENTIAL].name, 'rps')\n        self.assertEqual(metrics_manager.scoring_rules[BuildingTypes.COMMERCIAL].name, 'rps')\n\n    def test_create_dataset_metrics_manager_with_scoring_rule_and_metrics(self):\n        metrics_manager = MetricsManager(\n            metrics=metrics_factory('mae'),\n            scoring_rule=scoring_rule_factory('rps')\n        )\n\n        self.assertEqual(len(metrics_manager.metrics[BuildingTypes.RESIDENTIAL]), 1)\n        self.assertEqual(len(metrics_manager.metrics[BuildingTypes.COMMERCIAL]), 1)\n        self.assertEqual(metrics_manager.metrics[BuildingTypes.RESIDENTIAL][0].name, 'mae-scalar')\n        self.assertEqual(metrics_manager.scoring_rules[BuildingTypes.RESIDENTIAL].name, 'rps')\n        self.assertEqual(metrics_manager.scoring_rules[BuildingTypes.COMMERCIAL].name, 'rps')\n\n    def test_call_dataset_metrics_manager(self):\n\n        metrics_manager = MetricsManager(\n            metrics=metrics_factory('mae')\n        )\n\n        metrics_manager(\n            y_true=torch.FloatTensor([1, 2, 3]).view(1,3,1),\n            y_pred=torch.FloatTensor([1, 2, 3]).view(1,3,1),\n            building_types_mask=torch.BoolTensor([False])\n        )\n\n        self.assertEqual(metrics_manager.metrics[BuildingTypes.RESIDENTIAL][0].name, 'mae-scalar')\n        metrics_manager.metrics[BuildingTypes.RESIDENTIAL][0].mean()\n        self.assertEqual(metrics_manager.metrics[BuildingTypes.RESIDENTIAL][0].value, 0)\n\n    def test_update_loss_and_get_ppl_from_manager(self):\n\n        metrics_manager = MetricsManager(\n            metrics=metrics_factory('mae')\n        )\n\n        loss = torch.FloatTensor([1.0])\n        metrics_manager(\n            y_true=torch.FloatTensor([1, 2, 3]).view(1,3,1),\n            y_pred=torch.FloatTensor([1, 2, 3]).view(1,3,1),\n            building_types_mask=torch.BoolTensor([False]),\n            loss=loss,\n        )\n\n        self.assertEqual(metrics_manager.metrics[BuildingTypes.RESIDENTIAL][0].name, 'mae-scalar')\n        metrics_manager.metrics[BuildingTypes.RESIDENTIAL][0].mean()\n        self.assertEqual(metrics_manager.metrics[BuildingTypes.RESIDENTIAL][0].value, 0)\n        self.assertEqual(metrics_manager.get_ppl(), torch.exp( loss * 3 ) / 3)\n\n\n    def test_summary(self):\n\n        metrics_manager = MetricsManager(\n            metrics=metrics_factory('mae')\n        )\n\n        loss = torch.FloatTensor([1.0])\n        metrics_manager(\n            y_true=torch.FloatTensor([1, 2, 3]).view(1,3,1),\n            y_pred=torch.FloatTensor([1, 2, 3]).view(1,3,1),\n            building_types_mask=torch.BoolTensor([False]),\n            loss = loss\n        )\n\n        summary = metrics_manager.summary(with_loss=True, with_ppl=True)\n\n        self.assertEqual(summary[BuildingTypes.RESIDENTIAL]['mae-scalar'].value, 0)\n        self.assertEqual(summary['ppl'], torch.exp( loss * 3 ) / 3)\n        self.assertEqual(summary['loss'], loss)\n\n    def test_reset(self):\n\n        metrics_manager = MetricsManager(\n            metrics=metrics_factory('mae')\n        )\n\n        loss = torch.FloatTensor([1.0])\n        metrics_manager(\n            y_true=torch.FloatTensor([1, 2, 3]).view(1,3,1),\n            y_pred=torch.FloatTensor([1, 2, 3]).view(1,3,1),\n            building_types_mask=torch.BoolTensor([False]),\n            loss = loss\n        )\n\n        metrics_manager.reset()\n\n        self.assertEqual(len(metrics_manager.metrics[BuildingTypes.RESIDENTIAL]), 1)\n        self.assertEqual(len(metrics_manager.metrics[BuildingTypes.COMMERCIAL]), 1)\n        self.assertEqual(metrics_manager.metrics[BuildingTypes.RESIDENTIAL][0].name, 'mae-scalar')\n        self.assertEqual(metrics_manager.accumulated_unnormalized_loss, 0)\n\n        metrics_manager.metrics[BuildingTypes.RESIDENTIAL][0].mean()\n        metrics_manager.metrics[BuildingTypes.RESIDENTIAL][0].mean()\n\n        self.assertEqual(metrics_manager.metrics[BuildingTypes.RESIDENTIAL][0].UNUSED_FLAG, True)\n        \n\n    def test_building_type(self):\n\n        metrics_manager = MetricsManager(\n            metrics=metrics_factory('mae')\n        )\n\n        metrics_manager(\n            y_true=torch.FloatTensor([1, 2, 3]).view(1,3,1),\n            y_pred=torch.FloatTensor([1, 2, 3]).view(1,3,1),\n            building_type = BuildingTypes.RESIDENTIAL_INT\n        )\n\n        self.assertEqual(metrics_manager.metrics[BuildingTypes.RESIDENTIAL][0].name, 'mae-scalar')\n        metrics_manager.metrics[BuildingTypes.RESIDENTIAL][0].mean()\n        self.assertEqual(metrics_manager.metrics[BuildingTypes.RESIDENTIAL][0].value, 0)", "class TestMetricsManager(unittest.TestCase):\n       \n        \n    def test_create_dataset_metrics_manager_single_metric(self):\n        metrics_manager = MetricsManager(\n            metrics=metrics_factory('mae')\n        )\n\n        self.assertEqual(len(metrics_manager.metrics[BuildingTypes.RESIDENTIAL]), 1)\n        self.assertEqual(len(metrics_manager.metrics[BuildingTypes.COMMERCIAL]), 1)\n        self.assertEqual(metrics_manager.metrics[BuildingTypes.RESIDENTIAL][0].name, 'mae-scalar')\n\n    def test_create_dataset_metrics_manager_multiple_metrics(self):\n        metrics_manager = MetricsManager(\n            metrics=metrics_factory('mae') + metrics_factory('rmse')\n        )\n\n        self.assertEqual(len(metrics_manager.metrics[BuildingTypes.RESIDENTIAL]), 2)\n        self.assertEqual(len(metrics_manager.metrics[BuildingTypes.COMMERCIAL]), 2)\n        self.assertEqual(metrics_manager.metrics[BuildingTypes.RESIDENTIAL][0].name, 'mae-scalar')\n        self.assertEqual(metrics_manager.metrics[BuildingTypes.RESIDENTIAL][1].name, 'rmse-scalar')\n    \n    def test_create_dataset_metrics_manager_with_scoring_rule(self):\n        metrics_manager = MetricsManager(\n            scoring_rule=scoring_rule_factory('rps')\n        )\n\n        self.assertEqual(len(metrics_manager.scoring_rules), 2)\n        self.assertEqual(metrics_manager.scoring_rules[BuildingTypes.RESIDENTIAL].name, 'rps')\n        self.assertEqual(metrics_manager.scoring_rules[BuildingTypes.COMMERCIAL].name, 'rps')\n\n    def test_create_dataset_metrics_manager_with_scoring_rule_and_metrics(self):\n        metrics_manager = MetricsManager(\n            metrics=metrics_factory('mae'),\n            scoring_rule=scoring_rule_factory('rps')\n        )\n\n        self.assertEqual(len(metrics_manager.metrics[BuildingTypes.RESIDENTIAL]), 1)\n        self.assertEqual(len(metrics_manager.metrics[BuildingTypes.COMMERCIAL]), 1)\n        self.assertEqual(metrics_manager.metrics[BuildingTypes.RESIDENTIAL][0].name, 'mae-scalar')\n        self.assertEqual(metrics_manager.scoring_rules[BuildingTypes.RESIDENTIAL].name, 'rps')\n        self.assertEqual(metrics_manager.scoring_rules[BuildingTypes.COMMERCIAL].name, 'rps')\n\n    def test_call_dataset_metrics_manager(self):\n\n        metrics_manager = MetricsManager(\n            metrics=metrics_factory('mae')\n        )\n\n        metrics_manager(\n            y_true=torch.FloatTensor([1, 2, 3]).view(1,3,1),\n            y_pred=torch.FloatTensor([1, 2, 3]).view(1,3,1),\n            building_types_mask=torch.BoolTensor([False])\n        )\n\n        self.assertEqual(metrics_manager.metrics[BuildingTypes.RESIDENTIAL][0].name, 'mae-scalar')\n        metrics_manager.metrics[BuildingTypes.RESIDENTIAL][0].mean()\n        self.assertEqual(metrics_manager.metrics[BuildingTypes.RESIDENTIAL][0].value, 0)\n\n    def test_update_loss_and_get_ppl_from_manager(self):\n\n        metrics_manager = MetricsManager(\n            metrics=metrics_factory('mae')\n        )\n\n        loss = torch.FloatTensor([1.0])\n        metrics_manager(\n            y_true=torch.FloatTensor([1, 2, 3]).view(1,3,1),\n            y_pred=torch.FloatTensor([1, 2, 3]).view(1,3,1),\n            building_types_mask=torch.BoolTensor([False]),\n            loss=loss,\n        )\n\n        self.assertEqual(metrics_manager.metrics[BuildingTypes.RESIDENTIAL][0].name, 'mae-scalar')\n        metrics_manager.metrics[BuildingTypes.RESIDENTIAL][0].mean()\n        self.assertEqual(metrics_manager.metrics[BuildingTypes.RESIDENTIAL][0].value, 0)\n        self.assertEqual(metrics_manager.get_ppl(), torch.exp( loss * 3 ) / 3)\n\n\n    def test_summary(self):\n\n        metrics_manager = MetricsManager(\n            metrics=metrics_factory('mae')\n        )\n\n        loss = torch.FloatTensor([1.0])\n        metrics_manager(\n            y_true=torch.FloatTensor([1, 2, 3]).view(1,3,1),\n            y_pred=torch.FloatTensor([1, 2, 3]).view(1,3,1),\n            building_types_mask=torch.BoolTensor([False]),\n            loss = loss\n        )\n\n        summary = metrics_manager.summary(with_loss=True, with_ppl=True)\n\n        self.assertEqual(summary[BuildingTypes.RESIDENTIAL]['mae-scalar'].value, 0)\n        self.assertEqual(summary['ppl'], torch.exp( loss * 3 ) / 3)\n        self.assertEqual(summary['loss'], loss)\n\n    def test_reset(self):\n\n        metrics_manager = MetricsManager(\n            metrics=metrics_factory('mae')\n        )\n\n        loss = torch.FloatTensor([1.0])\n        metrics_manager(\n            y_true=torch.FloatTensor([1, 2, 3]).view(1,3,1),\n            y_pred=torch.FloatTensor([1, 2, 3]).view(1,3,1),\n            building_types_mask=torch.BoolTensor([False]),\n            loss = loss\n        )\n\n        metrics_manager.reset()\n\n        self.assertEqual(len(metrics_manager.metrics[BuildingTypes.RESIDENTIAL]), 1)\n        self.assertEqual(len(metrics_manager.metrics[BuildingTypes.COMMERCIAL]), 1)\n        self.assertEqual(metrics_manager.metrics[BuildingTypes.RESIDENTIAL][0].name, 'mae-scalar')\n        self.assertEqual(metrics_manager.accumulated_unnormalized_loss, 0)\n\n        metrics_manager.metrics[BuildingTypes.RESIDENTIAL][0].mean()\n        metrics_manager.metrics[BuildingTypes.RESIDENTIAL][0].mean()\n\n        self.assertEqual(metrics_manager.metrics[BuildingTypes.RESIDENTIAL][0].UNUSED_FLAG, True)\n        \n\n    def test_building_type(self):\n\n        metrics_manager = MetricsManager(\n            metrics=metrics_factory('mae')\n        )\n\n        metrics_manager(\n            y_true=torch.FloatTensor([1, 2, 3]).view(1,3,1),\n            y_pred=torch.FloatTensor([1, 2, 3]).view(1,3,1),\n            building_type = BuildingTypes.RESIDENTIAL_INT\n        )\n\n        self.assertEqual(metrics_manager.metrics[BuildingTypes.RESIDENTIAL][0].name, 'mae-scalar')\n        metrics_manager.metrics[BuildingTypes.RESIDENTIAL][0].mean()\n        self.assertEqual(metrics_manager.metrics[BuildingTypes.RESIDENTIAL][0].value, 0)", "\n\nclass TestBenchmarkMetricsManager(unittest.TestCase):\n\n    def test_create_benchmark_metrics_manager(self):\n        metrics_manager = DatasetMetricsManager()\n\n    def test_add_building_to_dataset_if_missing(self):\n        metrics_manager = DatasetMetricsManager()\n\n        metrics_manager.add_building_to_dataset_if_missing(\n            dataset_name='test',\n            building_id='0001')\n        \n        buliding_mm = metrics_manager.get_building_from_dataset(\n            dataset_name='test',\n            building_id='0001')\n        \n        # assert building_mm type is MetricsManager\n        self.assertEqual(type(buliding_mm), MetricsManager)\n\n\n    def test_call_benchmark_metrics_manager(self):\n\n        metrics_manager = DatasetMetricsManager()\n\n        metrics_manager.add_building_to_dataset_if_missing(\n            dataset_name='test',\n            building_id='0001')\n        \n        metrics_manager(\n            dataset_name='test',\n            building_id='0001',\n            y_true=torch.FloatTensor([1, 2, 3]).view(1,3,1),\n            y_pred=torch.FloatTensor([1, 2, 3]).view(1,3,1),\n            building_types_mask=torch.BoolTensor([False])\n        )\n\n        buliding_mm = metrics_manager.get_building_from_dataset(\n            dataset_name='test',\n            building_id='0001')\n        \n        self.assertEqual(buliding_mm.metrics[BuildingTypes.RESIDENTIAL][0].name, 'cvrmse-scalar')\n        buliding_mm.metrics[BuildingTypes.RESIDENTIAL][0].mean()\n        self.assertEqual(buliding_mm.metrics[BuildingTypes.RESIDENTIAL][0].value, 0)\n\n    def test_update_loss_and_get_ppl_from_benchmark_manager(self):\n\n        metrics_manager = DatasetMetricsManager()\n\n        metrics_manager.add_building_to_dataset_if_missing(\n            dataset_name='test',\n            building_id='0001')\n        \n        loss = torch.FloatTensor([1.0])\n        metrics_manager(\n            dataset_name='test',\n            building_id='0001',\n            y_true=torch.FloatTensor([1, 2, 3]).view(1,3,1),\n            y_pred=torch.FloatTensor([1, 2, 3]).view(1,3,1),\n            building_types_mask=torch.BoolTensor([False]),\n            loss=loss,\n        )\n\n        buliding_mm = metrics_manager.get_building_from_dataset(\n            dataset_name='test',\n            building_id='0001')\n\n        self.assertEqual(buliding_mm.get_ppl(), torch.exp( loss * 3 ) / 3)\n\n    def test_benchmark_manager_summary(self):\n        import pandas as pd\n\n        metrics_manager = DatasetMetricsManager()\n\n        metrics_manager.add_building_to_dataset_if_missing(\n            dataset_name='test',\n            building_id='0001')\n        \n        metrics_manager(\n            dataset_name='test',\n            building_id='0001',\n            y_true=torch.FloatTensor([1, 2, 3]).view(1,3,1),\n            y_pred=torch.FloatTensor([1, 2, 3]).view(1,3,1),\n            building_types_mask=torch.BoolTensor([False]),\n        )\n\n        summary = metrics_manager.summary()\n\n        print(summary)", ""]}
{"filename": "test/__init__.py", "chunked_list": [""]}
{"filename": "test/test_tokenizer.py", "chunked_list": ["import unittest\nfrom buildings_bench import tokenizer\nimport os\nfrom pathlib import Path \nimport numpy as np\n\n\nclass TestTokenizer(unittest.TestCase):\n    \"\"\" Test the KMeans tokenizer\"\"\"\n\n    def test_load(self):\n        \"\"\" Test loading the tokenizer \"\"\"\n\n        transform_path = Path(os.environ.get('BUILDINGS_BENCH', '')) \\\n                              / 'metadata' / 'transforms'\n\n        load_quantizer = tokenizer.LoadQuantizer(with_merge=True, num_centroids=2274, device='cpu')\n        load_quantizer.load(transform_path)\n        self.assertEqual(load_quantizer.get_vocab_size(), 2274)\n\n\n    def test_transform_cpu(self):\n        \"\"\" Test the transform method on CPU.\"\"\"\n\n        transform_path = Path(os.environ.get('BUILDINGS_BENCH', '')) \\\n                              / 'metadata' / 'transforms'\n\n        load_quantizer = tokenizer.LoadQuantizer(with_merge=True, num_centroids=2274, device='cpu')\n        load_quantizer.load(transform_path)\n\n        x = np.array([[100.234], [0.234], [55.523]])\n        y = load_quantizer.transform(x)\n        z = load_quantizer.undo_transform(y)\n\n        #print(x,y,z)\n\n        self.assertTrue(np.allclose(x, z, atol=1))", ""]}
{"filename": "test/test_persistence.py", "chunked_list": ["import unittest\nimport torch\nimport numpy as np\n\nclass TestPersistence(unittest.TestCase):\n    def test_average_persistence(self):\n        from buildings_bench.models.persistence import AveragePersistence\n\n        context_len = 168\n        pred_len = 24\n        bsz = 10\n        seqlen = context_len + pred_len\n        x = {'load': torch.from_numpy(np.random.rand(bsz, seqlen, 1).astype(np.float32))}\n        ap = AveragePersistence(context_len=context_len, pred_len=pred_len)\n        y = ap(x)\n        y_mean = y[:, :, 0]\n        y_sigma = y[:, :, 1]\n        self.assertEqual(y_mean.shape, (bsz, pred_len))\n        self.assertEqual(y_sigma.shape, (bsz, pred_len))\n\n    def test_copy_last_persistence(self):\n        from buildings_bench.models.persistence import CopyLastDayPersistence\n\n        context_len = 168\n        pred_len = 24\n        bsz = 10\n        seqlen = context_len + pred_len\n        load = torch.from_numpy(np.random.rand(bsz, seqlen, 1).astype(np.float32))\n        last_day = load[:, -48:-24]\n        x = {'load': load}\n        ap = CopyLastDayPersistence(context_len=context_len, pred_len=pred_len)\n        y = ap(x)\n        self.assertEqual(y.shape, (bsz, pred_len, 1))\n        self.assertTrue( (last_day == y).all() )\n\n    def test_last_week_persistence(self):\n        from buildings_bench.models.persistence import CopyLastWeekPersistence\n\n        context_len = 168\n        pred_len = 24\n        bsz = 10\n        seqlen = context_len + pred_len\n        load = torch.from_numpy(np.random.rand(bsz, seqlen, 1).astype(np.float32))\n        last_week = load[:,0:24]\n        x = {'load': load}\n        ap = CopyLastWeekPersistence(context_len=context_len, pred_len=pred_len)\n        y = ap(x)\n        self.assertEqual(y.shape, (bsz, pred_len, 1))\n        self.assertTrue( (last_week == y).all() )", "\ndef test():\n    suite = unittest.TestLoader().loadTestsFromTestCase(TestPersistence)\n    unittest.TextTestRunner(verbosity=2).run(suite)\n"]}
{"filename": "scripts/pretrain.py", "chunked_list": ["import torch\nimport torch.nn as nn\nfrom pathlib import Path\nimport transformers\nimport argparse \nimport wandb\nimport os\nimport tomli\nfrom timeit import default_timer as timer\nfrom socket import gethostname", "from timeit import default_timer as timer\nfrom socket import gethostname\nfrom buildings_bench import utils\nfrom buildings_bench import BuildingTypes\nfrom buildings_bench import load_pretraining\nfrom buildings_bench.tokenizer import LoadQuantizer\nfrom buildings_bench.evaluation.managers import MetricsManager\nfrom buildings_bench.models import model_factory\nfrom buildings_bench.evaluation.metrics import MetricType\nfrom buildings_bench.evaluation import metrics_factory", "from buildings_bench.evaluation.metrics import MetricType\nfrom buildings_bench.evaluation import metrics_factory\nfrom buildings_bench.evaluation import scoring_rule_factory\n\nSCRIPT_PATH = Path(os.path.realpath(__file__)).parent\n\n@torch.no_grad()\ndef validation(model, val_dataloader, args, loss, load_transform, transform, inverse_transform, predict):\n    model.eval()\n    step = 0\n\n    if args.ignore_scoring_rules:\n        metrics_manager = MetricsManager(\n            metrics=metrics_factory('nrmse', types=[ MetricType.SCALAR, MetricType.HOUR_OF_DAY ]) \\\n                    + metrics_factory('nmae', types=[ MetricType.SCALAR, MetricType.HOUR_OF_DAY ])) \n    elif model.module.continuous_loads:\n        metrics_manager = MetricsManager(\n            metrics=metrics_factory('nrmse', types=[ MetricType.SCALAR, MetricType.HOUR_OF_DAY ]) \\\n                    + metrics_factory('nmae', types=[ MetricType.SCALAR, MetricType.HOUR_OF_DAY ]),\n            scoring_rule=scoring_rule_factory('crps')\n        ) \n    else:\n        metrics_manager = MetricsManager(\n            metrics=metrics_factory('nrmse', types=[ MetricType.SCALAR, MetricType.HOUR_OF_DAY ]) \\\n                + metrics_factory('nmae', types=[ MetricType.SCALAR, MetricType.HOUR_OF_DAY ]),\n            scoring_rule=scoring_rule_factory('rps')\n        )\n\n    for batch in val_dataloader:   \n        building_types_mask = batch['building_type'][:,0,0] == 1\n\n        for k,v in batch.items():\n           batch[k] = v.to(model.device)\n\n        continuous_load = batch['load'].clone()\n        continuous_targets = continuous_load[:, model.module.context_len:]\n\n        # Transform if needed\n        batch['load'] = transform(batch['load'])\n        targets = batch['load'][:, model.module.context_len:]\n\n        with torch.cuda.amp.autocast():\n            preds = model(batch)\n            batch_loss = loss(preds, targets)\n            predictions, distribution_params = predict(batch)\n\n        predictions = inverse_transform(predictions)\n\n        if args.apply_scaler_transform != '':\n            continuous_targets = inverse_transform(continuous_targets)\n            # unscale for crps\n            targets = inverse_transform(targets)\n            if args.apply_scaler_transform == 'standard':\n                mu = inverse_transform(distribution_params[:,:,0])\n                sigma = load_transform.undo_transform_std(distribution_params[:,:,1])\n                distribution_params = torch.cat([mu.unsqueeze(-1), sigma.unsqueeze(-1)],-1)\n            \n            elif args.apply_scaler_transform == 'boxcox':\n                ######## approximate Gaussian in unscaled space ########\n                mu = inverse_transform(distribution_params[:,:,0])\n                muplussigma = inverse_transform(torch.sum(distribution_params,-1))\n                sigma = muplussigma - mu\n                muminussigma = inverse_transform(distribution_params[:,:,0] - distribution_params[:,:,1])\n                sigma = (sigma + (mu - muminussigma)) / 2\n                distribution_params = torch.cat([mu.unsqueeze(-1), sigma.unsqueeze(-1)],-1)\n        \n        if not model.module.continuous_loads:\n            centroids = load_transform.kmeans.centroids.squeeze() \\\n                if args.tokenizer_without_merge else load_transform.merged_centroids\n        else:\n            centroids = None\n        \n        metrics_manager(\n            continuous_targets,\n            predictions,\n            building_types_mask,\n            loss=batch_loss,\n            y_categories=targets,\n            y_distribution_params=distribution_params,\n            centroids=centroids\n        )\n                    \n        step += 1\n        # don't run for too long\n        if step == 500:\n           break\n\n    model.train()\n    summary = metrics_manager.summary(with_loss=True, with_ppl=True)\n\n    return summary['loss'], summary['ppl'], summary", "\n\ndef main(args, model_args):\n\n    utils.set_seed(args.random_seed)\n\n    # When running on the CuDNN backend, two further options must be set\n    torch.backends.cudnn.deterministic = True\n    # Optimize for fixed input sizes\n    torch.backends.cudnn.benchmark = False\n\n    ######################### DDP setup  #########################\n    # SLURM_LOCALID: gpu local rank (=0 as the first gpu of the node)\n    # SLURM_PROCID: gpu global rank (=4 as the fifth gpu among the 8)\n    # MASTER_ADDR and MASTER_PORT env variables should be set when calling this script\n    gpus_per_node = torch.cuda.device_count()    \n    args.world_size    = int(os.environ[\"WORLD_SIZE\"])\n    if args.disable_slurm:\n        local_rank     = int(os.environ[\"LOCAL_RANK\"])\n        args.rank      = local_rank\n    else:\n        args.rank      = int(os.environ[\"SLURM_PROCID\"])\n        print(f\"Hello from rank {args.rank} of {args.world_size} on {gethostname()} where there are\" \\\n            f\" {gpus_per_node} allocated GPUs per node.\", flush=True)\n\n        local_rank = args.rank - gpus_per_node * (args.rank // gpus_per_node)\n\n    print(f'About to call init_process_group on rank {args.rank} with local rank {local_rank}', flush=True)\n    torch.distributed.init_process_group(backend=args.dist_backend, \n                                        init_method=args.dist_url,\n                                        world_size=args.world_size,\n                                        rank=args.rank)\n    if args.rank == 0: print(f\"Group initialized? {torch.distributed.is_initialized()}\", flush=True)\n    torch.cuda.set_device(local_rank)\n\n    print(f'rank {args.rank} torch cuda available = ', torch.cuda.is_available(), flush=True)\n    print(f'rank {args.rank} torch cuda device count = ', torch.cuda.device_count(), flush=True)\n    print(f'rank {args.rank} torch cuda current device = ', torch.cuda.current_device(), flush=True)\n    print(f'rank {args.rank} torch cuda get_device_name = ', torch.cuda.get_device_name(0), flush=True)\n    print(f'rank {args.rank} torch threads = ', torch.get_num_threads(), flush=True)\n\n    checkpoint_dir = SCRIPT_PATH / '..' / 'checkpoints'\n    transform_path = Path(os.environ.get('BUILDINGS_BENCH', '')) / 'metadata' / 'transforms'\n\n\n    if args.rank == 0:\n        if not checkpoint_dir.exists():\n            os.makedirs(checkpoint_dir)\n        \n        wandb_project = os.environ.get('WANDB_PROJECT', '')\n        if wandb_project == '':\n            print('WANDB_PROJECT environment variable not set, disabling wandb')\n            args.disable_wandb = True\n        \n        if args.disable_wandb:\n            run = wandb.init(\n                project=wandb_project,\n                mode=\"disabled\",\n                config=args)\n        elif args.resume_from_checkpoint != '':\n            run = wandb.init(\n                id=args.wandb_run_id,\n                project=wandb_project,\n                notes=args.note,\n                resume=\"allow\",\n                config=args)\n        else:\n            run = wandb.init(\n                project=wandb_project,\n                notes=args.note,\n                config=args)\n    \n    global_batch_size = args.world_size * args.batch_size\n\n    #################### Model setup ####################\n\n    model, loss, predict = model_factory(args.config, model_args)\n    model = model.to(local_rank)\n    print(f'rank {args.rank} number of trainable parameters is '\\\n          f'= {sum(p.numel() for p in model.parameters())}', flush=True)\n\n    #################### Dataset setup ####################\n\n    train_dataset = load_pretraining('buildings-900k-train',\n                                     args.num_buildings,\n                                     args.apply_scaler_transform,\n                                     transform_path)\n    \n    val_dataset = load_pretraining('buildings-900k-val',\n                                   args.num_buildings,\n                                   args.apply_scaler_transform,\n                                   transform_path)\n\n    train_sampler = torch.utils.data.distributed.DistributedSampler(\n                                     dataset=train_dataset,\n                                     num_replicas=args.world_size,\n                                     rank=args.rank, shuffle=True)\n    val_sampler = torch.utils.data.distributed.DistributedSampler(\n                                     dataset=val_dataset,\n                                     num_replicas=args.world_size,\n                                     rank=args.rank, shuffle=True)\n\n    train_dataloader = torch.utils.data.DataLoader(\n        train_dataset, batch_size=args.batch_size, sampler=train_sampler,\n        drop_last=False, worker_init_fn=utils.worker_init_fn_eulp,\n        shuffle=(train_sampler is None), num_workers=args.num_workers, pin_memory=True)\n    \n    val_dataloader = torch.utils.data.DataLoader(\n        val_dataset, batch_size=args.batch_size, sampler=val_sampler,\n        drop_last=False, worker_init_fn=utils.worker_init_fn_eulp,\n        shuffle=(val_sampler is None), num_workers=args.num_workers, pin_memory=True)\n    \n    if not model.continuous_loads:\n        load_transform = LoadQuantizer(\n            with_merge=(not args.tokenizer_without_merge),\n            num_centroids=model.vocab_size,\n            device=f'cuda:{local_rank}')\n        load_transform.load(transform_path)\n    else:\n        load_transform = train_dataset.load_transform\n\n    if not model.continuous_loads: \n        transform = load_transform.transform\n        inverse_transform = load_transform.undo_transform\n    elif args.apply_scaler_transform != '':\n        transform = lambda x: x\n        inverse_transform = load_transform.undo_transform\n    else: # Continuous unscaled values\n        transform = lambda x: x\n        inverse_transform = lambda x: x\n\n    #################### Optimizer setup ##########################\n\n    # wrap model with DistributedDataParallel\n    model = torch.nn.parallel.DistributedDataParallel(model, device_ids=[local_rank], output_device=local_rank)\n\n    print(f'rank {args.rank} wrapped model in DDP', flush=True)\n    optimizer = torch.optim.AdamW(model.parameters(), lr=args.lr, betas=(0.9, 0.98), eps=1e-9, weight_decay=0.01)\n    if args.scheduler_steps > 0:\n        scheduler_steps = args.scheduler_steps\n    else:\n        scheduler_steps = args.num_epochs * (len(train_dataset) // global_batch_size)\n    scheduler = transformers.get_cosine_schedule_with_warmup(optimizer,\n                            num_warmup_steps=args.warmup_steps,\n                            num_training_steps=scheduler_steps)\n        \n    scaler = torch.cuda.amp.GradScaler()\n\n    #################### Resume from checkpoint ####################\n\n    if args.resume_from_checkpoint != '':\n        model, optimizer, scheduler, step = utils.load_model_checkpoint(\n            checkpoint_dir / args.resume_from_checkpoint, model, optimizer, scheduler, local_rank)\n        seen_tokens = step * global_batch_size  * model.module.pred_len\n        if args.override_lr > 0.0:\n             # set the lr for every param group to the override value\n             for group in optimizer.param_groups:\n                 group['lr'] = args.override_lr\n                 group['initial_lr'] = args.override_lr\n             scheduler = transformers.get_cosine_schedule_with_warmup(optimizer,\n                             num_warmup_steps=0,\n                             num_training_steps=scheduler_steps)\n        #step -= 1\n    else:\n        step = 0\n        seen_tokens = 0\n        for p in model.parameters():\n            if p.dim() > 1:\n                nn.init.normal_(p, mean=0.0, std=args.init_scale)\n\n    #################### Training loop ##############################\n    best_val_loss = 1e9\n\n    start_epoch = step // (len(train_dataset) // global_batch_size)\n    # Save a checkpoint every 1B seen tokens\n    save_every = 1000000000 // (global_batch_size * model.module.pred_len )\n    # steps per epoch\n    steps_per_epoch = len(train_dataset) // global_batch_size\n    print(f'rank {args.rank} step {step} start_epoch {start_epoch} save_every = {save_every}', flush=True)\n    for epoch in range(start_epoch, args.num_epochs):\n        # fix sampling seed such that each gpu gets different part of dataset        \n        train_sampler.set_epoch(epoch)\n        val_sampler.set_epoch(epoch)    \n        model.train()\n        start_time = timer()\n\n        # NB step is the # of gradient updates\n        # batch_index is the number of batches processed\n        for batch in train_dataloader:\n            start_time = timer()\n            optimizer.zero_grad()\n\n            for k,v in batch.items():\n                batch[k] = v.to(model.device)\n            \n            # Apply transform to load if needed\n            batch['load'] = transform(batch['load'])\n            \n            # backwards is called in here\n            with torch.cuda.amp.autocast():\n                                \n                preds = model(batch)    \n                targets = batch['load'][:, model.module.context_len:]                \n                # preds are [bsz_sz, pred_len, vocab_size] if logits\n                # preds are [bsz_sz, pred_len, 2] if Gaussian\n                # preds are [bsz_sz, pred_len, 1] if MSE\n                # targets is [bsz_sz, pred_len, 1]\n                batch_loss = loss(preds, targets)\n            \n            # Scale Gradients\n            scaler.scale(batch_loss).backward()\n           \n            # Update Optimizer\n            scaler.step(optimizer)\n            scaler.update()\n            scheduler.step()\n            end_time = timer()\n\n            secs_per_step = end_time - start_time\n            # world_size * batch_size = global batch size with DDP training\n            seen_tokens += (global_batch_size * model.module.pred_len)\n            step += 1\n\n            ppl = torch.exp(batch_loss.detach())\n\n            if args.rank == 0 and step % 500 == 0:\n                wandb.log({\n                    'train/loss': batch_loss,\n                    'train/batch_ppl': ppl,\n                    'train/seen_tokens (M)': seen_tokens / 1000000,\n                    'train/secs_per_step': secs_per_step,\n                    'train/lr': optimizer.param_groups[0]['lr']\n                }, step=step)\n\n            if args.rank == 0 and step % min(steps_per_epoch,10000) == 0:\n                print(f'started validation at step {step}...')\n\n                val_loss, val_ppl, val_metrics = validation(model, val_dataloader, args, loss, load_transform,\n                                                            transform, inverse_transform, predict)\n                # only rank 0 needs to save model\n                if val_loss < best_val_loss:\n                    # delete old checkpoint\n                    if args.note != '':\n                        for f in checkpoint_dir.glob(f'ckpt-step-*-{args.note}-loss-{best_val_loss:.3f}.pt'):\n                            f.unlink()\n                    else:\n                        for f in checkpoint_dir.glob(f'ckpt-step-*-loss-{best_val_loss:.3f}.pt'):\n                            f.unlink()\n\n                    best_val_loss = val_loss\n                    if args.note != '':\n                        model_name = f'ckpt-step-{step}-{args.note}-loss-{best_val_loss:.3f}.pt'\n                    else:\n                        model_name = f'ckpt-step-{step}-loss-{best_val_loss:.3f}.pt'\n                    utils.save_model_checkpoint(model, optimizer, scheduler, step, checkpoint_dir / model_name)\n                for building_type in [BuildingTypes.RESIDENTIAL, BuildingTypes.COMMERCIAL]:\n                    for metric_name, metric_result in val_metrics[building_type].items():\n                        if metric_result.type == MetricType.SCALAR:\n                            wandb.log({f'val/{building_type}/{metric_name}' : metric_result.value }, step=step)\n                        else:\n                            # Create a wandb.Table for each hour of day metric then plot a line plot\n                            table = wandb.Table(columns=['time (hour)', metric_name])\n                            multi_hour_value = metric_result.value\n                            for row_idx in range(multi_hour_value.shape[0]):\n                                table.add_data(row_idx, multi_hour_value[row_idx].item())\n                            wandb.log({f'val/{building_type}/{metric_name}' : wandb.plot.line(\n                                table, \"time (hour)\", metric_name, title=f\"Time vs {metric_name}\")}, step=step)\n                        \n                wandb.log({\n                    'val/loss': val_loss,\n                    'val/ppl': val_ppl,\n                }, step=step)\n                print(f'finished validation at step {step}...')\n\n            # every 1B seen_tokens, save a checkpoint\n            if args.rank == 0 and step % save_every == 0:\n                if args.note != '':\n                    model_name = f'ckpt-step-{step}-{args.note}.pt'\n                else:\n                    model_name = f'ckpt-step-{step}.pt'\n                utils.save_model_checkpoint(model, optimizer, scheduler, step, checkpoint_dir / model_name)\n    \n    torch.distributed.destroy_process_group()        \n    run.finish()", "\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser()\n\n    # Training hyperparams. If provided in config file, these will be overridden.\n    parser.add_argument('--config', type=str, default='', required=True,\n                        help='Path to your models TOML config file.')\n    parser.add_argument('--batch_size', type=int, default=256)\n    parser.add_argument('--lr', type=float, default=0.00006)\n    parser.add_argument('--override_lr', type=float, default=0.0,\n                        help='Override the learning rate with this value on resume')\n    parser.add_argument('--warmup_steps', type=int, default=10000)\n    parser.add_argument('--scheduler_steps', type=int, default=-1,\n                        help='Number of steps to decay lr to 0. '\n                             'Set to -1 to use num_epochs instead.')\n    parser.add_argument('--random_seed', type=int, default=99)\n    parser.add_argument('--ignore_scoring_rules', action='store_true',\n                        help='Do not compute a scoring rule for this model.')\n    parser.add_argument('--num_epochs', type=int, default=1,\n                         help='Number of epochs to train for.')\n    parser.add_argument('--resume_from_checkpoint', type=str, default='')\n    parser.add_argument('--tokenizer_without_merge', action='store_true', default=False, \n                        help='Use the tokenizer without merge. Default is False.')\n    parser.add_argument('--apply_scaler_transform', type=str, default='',\n                        choices=['', 'standard', 'boxcox'], \n                        help='Apply a scaler transform to the load values.')\n    # Wandb\n    parser.add_argument('--disable_wandb', action='store_true')\n    parser.add_argument('--note', type=str, default='',\n                        help='Note to append to model checkpoint name. '\n                        'Also used for wandb notes.')    \n    parser.add_argument('--wandb_run_id', type=str, default='')\n\n    # DDP\n    parser.add_argument('--disable_slurm', action='store_true')\n    parser.add_argument('--world-size', default=-1, type=int, \n                        help='number of nodes for distributed training')\n    parser.add_argument('--rank', default=-1, type=int, \n                        help='node rank for distributed training')\n    parser.add_argument('--dist-url', default='env://', type=str, \n                        help='url used to set up distributed training')\n    parser.add_argument('--dist-backend', default='nccl', type=str, \n                        help='distributed backend')\n    #parser.add_argument('--local_rank', default=-1, type=int, \n    #                    help='local rank for distributed training')\n    #parser.add_argument('--DDP_port', type=int, default=12345)\n    parser.add_argument('--num_workers', type=int, default=8)\n\n    # Variants\n    parser.add_argument('--num_buildings', type=int, default=-1,\n                        help='Number of buildings to use for training. '\n                             'Default is -1 which uses all buildings. ' \n                             'Options {1000, 10000, 100000}.')\n    \n    args = parser.parse_args()\n\n    config_path = SCRIPT_PATH  / '..' / 'buildings_bench' / 'configs'\n    if (config_path / f'{args.config}.toml').exists():\n        toml_args = tomli.load(( config_path / f'{args.config}.toml').open('rb'))\n        model_args = toml_args['model']\n        if 'pretrain' in toml_args:\n            for k,v in toml_args['pretrain'].items():\n                if hasattr(args, k):\n                    print(f'Overriding argparse default for {k} with {v}')\n                setattr(args, k, v)\n        if not model_args['continuous_loads'] or 'apply_scaler_transform' not in args:\n            setattr(args, 'apply_scaler_transform', '')\n    else:\n        raise ValueError(f'Config {args.config}.toml not found.')\n\n\n    if not torch.cuda.is_available():\n        raise ValueError('CUDA is not available for pretraining!')\n    \n    main(args, model_args)", ""]}
{"filename": "scripts/transfer_learning_lightgbm.py", "chunked_list": ["from pathlib import Path\nimport os\nimport argparse \nfrom buildings_bench import utils\nimport pandas as pd\nimport torch\nfrom lightgbm import LGBMRegressor\nfrom skforecast.ForecasterAutoreg import ForecasterAutoreg\n\nfrom buildings_bench import BuildingTypes", "\nfrom buildings_bench import BuildingTypes\nfrom buildings_bench import load_pandas_dataset, benchmark_registry\nfrom buildings_bench.data.datasets import keep_buildings\nfrom buildings_bench import utils\nfrom buildings_bench.evaluation.managers import DatasetMetricsManager\n\n\nSCRIPT_PATH = Path(os.path.realpath(__file__)).parent\n", "SCRIPT_PATH = Path(os.path.realpath(__file__)).parent\n\n\ndef transfer_learning(args, results_path: Path):\n    global benchmark_registry\n    lag = 168\n\n    # remove synthetic\n    benchmark_registry = [b for b in benchmark_registry if b != 'buildings-900k-test']\n    if args.benchmark[0] == 'all':\n        args.benchmark = benchmark_registry\n\n    metrics_manager = DatasetMetricsManager()\n\n    target_buildings = []\n    if args.subsample_buildings:\n        metadata_dir = Path(os.environ.get('BUILDINGS_BENCH', ''), 'metadata')\n        with open(metadata_dir / 'transfer_learning_commercial_buildings.txt', 'r') as f:\n            target_buildings += f.read().splitlines()\n        with open(metadata_dir / 'transfer_learning_residential_buildings.txt', 'r') as f:\n            target_buildings += f.read().splitlines()\n\n    for dataset in args.benchmark:\n        dataset_generator = load_pandas_dataset(dataset, feature_set='engineered')\n        # Filter to target buildings\n        if len(target_buildings) > 0:\n            dataset_generator = keep_buildings(dataset_generator, target_buildings)\n\n        # For metrics management\n        if dataset_generator.building_type == BuildingTypes.COMMERCIAL:\n            building_types_mask = (BuildingTypes.COMMERCIAL_INT * torch.ones([1,24,1])).bool()\n        else:\n            building_types_mask = (BuildingTypes.RESIDENTIAL_INT * torch.ones([1,24,1])).bool()\n        \n\n        \n        for building_name, bldg_df in dataset_generator:\n\n            # if date range is less than 120 days, skip - 90 days training, 30+ days eval.\n            if len(bldg_df) < (args.num_training_days+30)*24:\n                print(f'{dataset} {building_name} has too few days {len(bldg_df)}')\n                continue\n\n            print(f'dataset {dataset} building {building_name}')\n            \n            metrics_manager.add_building_to_dataset_if_missing(\n                 dataset, f'{building_name}',\n            )\n\n            # Split into fine-tuning and evaluation set by date\n            # Get the first month of data from bldg_df by index\n            start_timestamp = bldg_df.index[0]\n            end_timestamp = start_timestamp + pd.Timedelta(days=args.num_training_days)\n            historical_date_range = pd.date_range(start=start_timestamp, end=end_timestamp, freq='H')\n\n            training_set = bldg_df.loc[historical_date_range]\n            \n            test_set = bldg_df.loc[~bldg_df.index.isin(historical_date_range)]\n            test_start_timestamp = test_set.index[0]\n            test_end_timestamp = test_start_timestamp + pd.Timedelta(days=180)\n            #test_date_range = pd.date_range(start=test_start_timestamp, end=test_end_timestamp, freq='H')\n            #test_set = test_set.loc[test_date_range]\n            test_set = test_set[test_set.index <= test_end_timestamp]\n\n            print(f'fine-tune set date range: {training_set.index[0]} {training_set.index[-1]}, '\n                  f'test set date range: {test_set.index[0]} {test_set.index[-1]}')\n\n            # train the model\n            forecaster = ForecasterAutoreg(\n                    regressor        = LGBMRegressor(max_depth=-1, n_estimators=100, n_jobs=24),\n                    lags             = lag\n                )\n            forecaster.fit(\n                y               = training_set['power'],\n                exog            = training_set[[key for key in training_set.keys() if key != 'power']]\n            )\n        \n            pred_days = (len(test_set) - lag - 24) // 24\n            for i in range(pred_days):\n                \n                seq_ptr =lag + 24 * i\n\n                last_window  = test_set.iloc[seq_ptr - lag : seq_ptr]\n                ground_truth = test_set.iloc[seq_ptr : seq_ptr + 24]\n\n                predictions = forecaster.predict(\n                    steps       = 24,\n                    last_window = last_window['power'],\n                    exog        = test_set[[key for key in test_set.keys() if key != 'power']]\n                )\n\n                metrics_manager(\n                    dataset,\n                    f'{building_name}',\n                    torch.from_numpy(ground_truth['power'].values).float().view(1,24,1),\n                    torch.from_numpy(predictions.values).float().view(1,24,1),\n                    building_types_mask\n                )\n\n    print('Generating summaries...')\n    variant_name = f':{args.variant_name}' if args.variant_name != '' else ''\n    metrics_file = results_path / f'TL_metrics_lightgbm{variant_name}.csv'\n\n    metrics_df = metrics_manager.summary()    \n    if metrics_file.exists():    \n        metrics_df.to_csv(metrics_file, mode='a', index=False, header=False)\n    else:\n        metrics_df.to_csv(metrics_file, index=False)", "\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser()\n\n    parser.add_argument('--results_path', type=str, default='results/')\n    parser.add_argument('--benchmark', nargs='+', type=str, default=['all'],\n                        help='Which datasets in the benchmark to run. Default is [\"all.\"] '\n                             'See the dataset registry in buildings_bench.data.__init__.py for options.')\n    parser.add_argument('--seed', type=int, default=1)\n    parser.add_argument('--variant_name', type=str, default='',\n                        help='Name of the variant. Optional. Used for results files.')\n\n\n    # Transfer learning - data\n    parser.add_argument('--num_training_days', type=int, default=180,\n                        help='Number of days for fine-tuning (last 30 used for early stopping)')\n    parser.add_argument('--subsample_buildings', action='store_true', default=False,\n                        help='Evaluate on a random subsample of 100 res/com buildings '\n                        ' (instead of all).')    \n\n    args = parser.parse_args()\n    utils.set_seed(args.seed)\n    \n\n    results_path = Path(args.results_path)\n    results_path.mkdir(parents=True, exist_ok=True)\n\n    transfer_learning(args, results_path)", ""]}
{"filename": "scripts/create_index_files_with_less_buildings.py", "chunked_list": ["import argparse\nfrom pathlib import Path\nimport numpy as np\nimport pyarrow.parquet as pq\nimport random\nimport glob \nimport pandas as pd\nimport os\nfrom tqdm import tqdm\n", "from tqdm import tqdm\n\n\ndef main(args):\n    random.seed(args.seed)\n    np.random.seed(args.seed)\n\n    dataset_path = Path(os.environ.get('BUILDINGS_BENCH', ''))\n            \n    # Each line in the index file indicates a building and n \n    #   <building_type_and_year> <census_region> <puma_id> <building_id> <seq ptr>\n    #  e.g. <0-4> <0-4> G17031 23023 65\n    train_idx_file = open(dataset_path / 'metadata' / f'train_weekly_{args.num_buildings}.idx', 'w')\n    val_idx_file = open(dataset_path / 'metadata' / f'val_weekly_{args.num_buildings}.idx', 'w')\n    building_years = ['comstock_tmy3_release_1', 'resstock_tmy3_release_1', 'comstock_amy2018_release_1', 'resstock_amy2018_release_1'] \n    pumas = ['by_puma_midwest', 'by_puma_south', 'by_puma_northeast', 'by_puma_west']\n\n    # withhold 1 puma from each census region (all res and com buildingss) for test only\n    # midwest, south, northeast, west\n    # read withheld pumas from file\n    with open(dataset_path / 'metadata' / 'withheld_pumas.tsv', 'r') as f:\n        # tab separated file\n        line = f.readlines()[0]\n        withheld_pumas = line.strip('\\n').split('\\t')\n    print(f'Withheld pumas: {withheld_pumas}')\n\n\n    # 2 weeks heldout for val\n    train_tmy_timerange = (pd.Timestamp('2018-01-01'), pd.Timestamp('2018-12-31'))\n    train_amy2018_timerange = (pd.Timestamp('2018-01-01'), pd.Timestamp('2018-12-17'))\n    val_timerange = (pd.Timestamp('2018-12-17'), pd.Timestamp('2018-12-31'))\n\n    bldgs_per_bty = args.num_buildings // len(building_years)\n\n    for building_type_and_year, by in enumerate(building_years):\n        num_buildings = 0\n\n        by_path = dataset_path / 'Buildings-900K' / 'end-use-load-profiles-for-us-building-stock/2021' \\\n              / by / 'timeseries_individual_buildings'\n\n        if 'amy2018' in by:\n            train_hours = int((train_amy2018_timerange[1] - train_amy2018_timerange[0]).total_seconds() / 3600)\n            print(f'AMY2018 train hours: {train_hours}')\n\n            val_hours = int((val_timerange[1] - val_timerange[0]).total_seconds() / 3600)\n            print(f'AMY2018 Val hours: {val_hours}')\n        else:\n            train_hours = int((train_tmy_timerange[1] - train_tmy_timerange[0]).total_seconds() / 3600)\n            print(f'TMY train hours: {train_hours}')\n\n        # select buildings from census regions in random order,\n        # until we have enough buildings. alternatively, we could\n        # randomly sample the census region for each building.\n        census_region_idxs = [0, 1, 2, 3]\n        random.shuffle(census_region_idxs)\n\n        for census_region_idx in census_region_idxs: # census regions\n            pum_path = by_path / pumas[census_region_idx] / 'upgrade=0'\n            pum_files = glob.glob(str(pum_path / 'puma=*'))\n\n            # shuffle order of pum_files\n            random.shuffle(pum_files)\n\n            for pum_file in tqdm(pum_files):\n                try:\n                    bldg_ids = pq.read_table(pum_file).to_pandas().columns[1:]\n                except:\n                    print(f'Failed to read {pum_file}')\n                    import pdb; pdb.set_trace()\n                    continue\n                \n                if not os.path.basename(pum_file) in withheld_pumas:\n                    # store building ids\n                    for bldg_id in bldg_ids:\n                        # train\n                        if num_buildings >= bldgs_per_bty:\n                            break\n                        bldg_id = bldg_id.zfill(6)\n                        # Sample the starting index between (0,24)\n                        s_start = np.random.randint(0, 24)\n                        for s_idx in range(s_start, train_hours - (args.context_len + args.pred_len), args.sliding_window_stride):                            \n                            seq_ptr = str(args.context_len + s_idx).zfill(4)  # largest seq ptr is < 10000\n                            # NB: We don't *need* \\n at the end of each line, but it makes it easier to count # of lines for dataloading\n                            linestr = f'{building_type_and_year}\\t{census_region_idx}\\t{os.path.basename(pum_file).split(\"=\")[1]}\\t{bldg_id}\\t{seq_ptr}\\n'\n                            assert len(linestr) == 26, f'linestr: {linestr}'\n                            train_idx_file.write(linestr)\n                        # val\n                        if 'amy2018' in by:\n                            s_start += train_hours \n                            for s_idx in range(s_start, (train_hours + val_hours) - (args.context_len + args.pred_len), args.sliding_window_stride):\n                                seq_ptr = str(args.context_len + s_idx).zfill(4)  # largest seq ptr is < 10000\n                                assert len(linestr) == 26, f'linestr: {linestr}'\n                                linestr = f'{building_type_and_year}\\t{census_region_idx}\\t{os.path.basename(pum_file).split(\"=\")[1]}\\t{bldg_id}\\t{seq_ptr}\\n'\n                                val_idx_file.write(linestr)\n                        num_buildings += 1\n                # for each puma in census region\n                if num_buildings >= bldgs_per_bty:\n                    break\n            # for each census region\n            if num_buildings >= bldgs_per_bty:\n                 break\n    # Close files\n    train_idx_file.close()\n    val_idx_file.close()", "\n\nif __name__ == '__main__':\n    args = argparse.ArgumentParser()\n\n    args.add_argument('--num_buildings', type=int, default=1000, required=False,)\n    args.add_argument('--seed', type=int, default=1, required=False,\n                        help='Random seed for KMeans and shuffling. Default: 1')\n    args.add_argument('--sliding_window_stride', type=int, default=24, required=False,\n                        help='Stride for sliding window to split timeseries into training examples. Default: 24 hours')\n    args.add_argument('--context_len', type=int, default=168, required=False,\n                                help='Length of context sequence. For handling year beginning and year end. Default: 168 hours')\n    args.add_argument('--pred_len', type=int, default=24, required=False,\n                                help='Length of prediction sequence. For handling year beginning and year end. Default: 24 hours')\n\n\n    args = args.parse_args()\n\n    main(args)", ""]}
{"filename": "scripts/fit_scaler_transforms.py", "chunked_list": ["import argparse\nfrom pathlib import Path\nimport numpy as np\nimport pyarrow.parquet as pq\nimport random\nimport glob \nimport os\n\nfrom buildings_bench.transforms import StandardScalerTransform, BoxCoxTransform \n", "from buildings_bench.transforms import StandardScalerTransform, BoxCoxTransform \n\n\ndef main(args):\n    random.seed(args.seed)\n    np.random.seed(args.seed)\n\n    output_dir = Path(os.environ.get('BUILDINGS_BENCH', ''), 'metadata')\n    # training set dir\n    time_series_dir = Path(os.environ.get('BUILDINGS_BENCH', ''), 'Buildings-900K', 'end-use-load-profiles-for-us-building-stock', '2021')\n    building_years = ['comstock_tmy3_release_1', 'resstock_tmy3_release_1', 'comstock_amy2018_release_1', 'resstock_amy2018_release_1'] \n    pumas = ['by_puma_midwest', 'by_puma_south', 'by_puma_northeast', 'by_puma_west']\n\n    all_buildings = []\n\n    for by in building_years:\n        by_path = time_series_dir / by / 'timeseries_individual_buildings'\n        for pum in pumas:\n            pum_path = by_path / pum / 'upgrade=0'\n            # subsample pumas for faster quantization\n            pum_files = glob.glob(str(pum_path / 'puma=*'))\n            random.shuffle(pum_files)\n            # limit to 10 random pumas per\n            pum_files = pum_files[:10]\n            for pum_file in pum_files:\n                # load the parquet file and convert each column to a numpy array\n                #df = spark.read.parquet(pum_file)\n                df = pq.read_table(pum_file).to_pandas()\n                #df = df.toPandas()\n                # convert each column to a numpy array and stack vertically\n                all_buildings += [np.vstack([df[col].to_numpy() for col in df.columns if col != 'timestamp'])]\n\n\n\n    print('Fitting StandardScaler...')\n    ss = StandardScalerTransform()\n    ss.train(np.vstack(all_buildings))\n    ss.save(output_dir)\n    print('StandardScaler: ', ss.mean_, ss.std_)\n\n    print('Fitting BoxCox...')\n    bc = BoxCoxTransform()\n    bc.train(np.vstack(all_buildings))\n    bc.save(output_dir)\n    print('BoxCox: ', bc.boxcox.lambdas_)", " \n\n        \nif __name__ == '__main__':\n    args = argparse.ArgumentParser()\n\n    args.add_argument('--seed', type=int, default=1, required=False,\n                        help='Random seed shuffling. Default: 1')\n\n\n    args = args.parse_args()\n\n    main(args)", ""]}
{"filename": "scripts/transfer_learning_torch.py", "chunked_list": ["from pathlib import Path\nimport os\nimport argparse \nfrom buildings_bench import utils\nimport pandas as pd\nimport torch\nimport tomli \nimport numpy as np\nfrom copy import deepcopy\n", "from copy import deepcopy\n\nfrom buildings_bench import load_pandas_dataset, benchmark_registry\nfrom buildings_bench.data.datasets import PandasTransformerDataset\nfrom buildings_bench.data.datasets import keep_buildings\nfrom buildings_bench import utils\nfrom buildings_bench.tokenizer import LoadQuantizer\nfrom buildings_bench.evaluation.managers import DatasetMetricsManager\nfrom buildings_bench.models import model_factory\nfrom buildings_bench.evaluation import scoring_rule_factory", "from buildings_bench.models import model_factory\nfrom buildings_bench.evaluation import scoring_rule_factory\n\n\nSCRIPT_PATH = Path(os.path.realpath(__file__)).parent\n\n\ndef train(df_tr, df_val, args, model, transform, loss, lr, device):\n    torch_train_set = PandasTransformerDataset(df_tr, sliding_window=24)\n    \n    train_dataloader = torch.utils.data.DataLoader(\n                                torch_train_set,\n                                batch_size=args.batch_size,\n                                num_workers=args.num_workers, \n                                shuffle=True)\n    \n    torch_val_set = PandasTransformerDataset(df_val, sliding_window=24)\n    val_dataloader = torch.utils.data.DataLoader(\n                                torch_val_set,\n                                batch_size=args.batch_size,\n                                num_workers=args.num_workers,\n                                shuffle=False)\n    # Unfreeze the layer being fine-tuned\n    # and pass to the optimizer\n    params = model.unfreeze_and_get_parameters_for_finetuning()\n    if params is None:\n        raise ValueError('No parameters provided for fine-tuning. Did you mean to run with --eval_zero_shot?')\n\n    optimizer = torch.optim.AdamW(params, lr=lr) \n\n    model.train()\n    best_val = 100000\n    patience_counter = 0\n\n    # Fine tune the loaded model with frozen weights\n    for epoch in range(args.max_epochs):\n        losses = []\n        print(f'epoch {epoch}')\n        for batch in train_dataloader:\n            optimizer.zero_grad()\n\n            for k,v in batch.items():\n                batch[k] = v.to(device)\n\n            # Apply transform to load if needed\n            batch['load'] = transform(batch['load'])\n                                \n            with torch.cuda.amp.autocast():\n                preds = model(batch)\n                targets = batch['load'][:, model.context_len:]      \n                batch_loss = loss(preds, targets)\n\n            losses.append(batch_loss.item())\n            batch_loss.backward()\n\n            optimizer.step()\n\n        # run validation\n        losses_val = []\n        model.eval()\n        with torch.no_grad():\n            for batch in val_dataloader:\n                for k,v in batch.items():\n                    batch[k] = v.to(device)\n\n                # Apply transform to load if needed\n                batch['load'] = transform(batch['load'])\n                                    \n                with torch.cuda.amp.autocast():\n                    preds = model(batch)\n                    targets = batch['load'][:, model.context_len:]\n                    batch_loss = loss(preds, targets)\n\n                losses_val.append(batch_loss.item())\n        \n        epoch_val_loss = np.mean(losses_val)\n        \n        model.train()\n        print('epoch train loss = ', np.mean(losses))\n        print('epoch val loss = ', np.mean(losses_val))\n        \n        if epoch_val_loss > best_val:\n            patience_counter += 1\n        else:\n            patience_counter = 0\n            best_val = epoch_val_loss\n        \n        if patience_counter > args.patience:\n            print(f'early stopping after epoch {epoch} with patience={args.patience}, best val loss {best_val}')\n            break\n            \n    return model", "\n\ndef transfer_learning(args, model_args, results_path: Path):\n    global benchmark_registry\n    device = args.device\n\n    # load and configure the model for transfer learning\n    model, loss, _ = model_factory(args.config, model_args)\n    model = model.to(args.device)\n    transform_path = Path(os.environ.get('BUILDINGS_BENCH', '')) / 'metadata' / 'transforms'\n\n\n    if not model.continuous_loads:\n        load_transform = LoadQuantizer(\n            with_merge=(not args.tokenizer_without_merge),\n            num_centroids=model.vocab_size,\n            device='cuda:0' if 'cuda' in device else 'cpu')\n        load_transform.load(transform_path)\n\n\n    if args.checkpoint != '':\n        # By default, fine tune all layers\n        model.load_from_checkpoint(args.checkpoint)\n    model.train()\n\n    # remove synthetic\n    benchmark_registry = [b for b in benchmark_registry if b != 'buildings-900k-test']\n    if args.benchmark[0] == 'all':\n        args.benchmark = benchmark_registry\n\n    if args.ignore_scoring_rules:\n        metrics_manager = DatasetMetricsManager()\n    elif model.continuous_loads:\n        metrics_manager = DatasetMetricsManager(scoring_rule = scoring_rule_factory('crps'))\n    else:\n        metrics_manager = DatasetMetricsManager(scoring_rule = scoring_rule_factory('rps'))\n\n    target_buildings = []\n    if not args.dont_subsample_buildings:\n        metadata_dir = Path(os.environ.get('BUILDINGS_BENCH', ''), 'metadata')\n        with open(metadata_dir / 'transfer_learning_commercial_buildings.txt', 'r') as f:\n            target_buildings += f.read().splitlines()\n        with open(metadata_dir / 'transfer_learning_residential_buildings.txt', 'r') as f:\n            target_buildings += f.read().splitlines()\n\n    for dataset in args.benchmark:\n        dataset_generator = load_pandas_dataset(dataset,\n                                                feature_set='transformer',\n                                                apply_scaler_transform=args.apply_scaler_transform,\n                                                scaler_transform_path=transform_path)\n        # Filter to target buildings\n        if len(target_buildings) > 0:\n            dataset_generator = keep_buildings(dataset_generator, target_buildings)\n\n        # Transforms\n        if not model.continuous_loads: \n            transform = load_transform.transform\n            inverse_transform = load_transform.undo_transform\n        elif args.apply_scaler_transform != '':\n            transform = lambda x: x\n            load_transform = dataset_generator.load_transform\n            inverse_transform = load_transform.undo_transform\n        else: # Continuous unscaled values\n            transform = lambda x: x\n            inverse_transform = lambda x: x\n        \n        for building_name, bldg_df in dataset_generator:\n            # if date range is less than 120 days, skip - 90 days training, 30+ days eval.\n            if len(bldg_df) < (args.num_training_days+30)*24:\n                print(f'{dataset} {building_name} has too few days {len(bldg_df)}')\n                continue\n\n            print(f'dataset {dataset} building {building_name}')\n            \n            metrics_manager.add_building_to_dataset_if_missing(\n                 dataset, building_name,\n            )\n\n            # Split into fine-tuning and evaluation set by date\n            # Get the first month of data from bldg_df by index\n            start_timestamp = bldg_df.index[0]\n            end_timestamp = start_timestamp + pd.Timedelta(days=args.num_training_days)\n            historical_date_range = pd.date_range(start=start_timestamp, end=end_timestamp, freq='H')\n\n            training_set = bldg_df.loc[historical_date_range]\n            training_start_timestamp = training_set.index[0]\n            training_end_timestamp = training_start_timestamp + pd.Timedelta(days=args.num_training_days-30)\n\n            train_date_range = pd.date_range(start=training_start_timestamp, end=training_end_timestamp, freq='H')\n            training_set_ = training_set.loc[train_date_range]\n            validation_set = training_set[~training_set.index.isin(train_date_range)]\n\n            test_set = bldg_df.loc[~bldg_df.index.isin(historical_date_range)]\n            test_start_timestamp = test_set.index[0]\n            test_end_timestamp = test_start_timestamp + pd.Timedelta(days=180)\n            #test_date_range = pd.date_range(start=test_start_timestamp, end=test_end_timestamp, freq='H')\n            #test_set = test_set.loc[test_date_range]\n            test_set = test_set[test_set.index <= test_end_timestamp]\n\n            print(f'fine-tune set date range: {training_set_.index[0]} {training_set_.index[-1]}, '\n                  f'test set date range: {test_set.index[0]} {test_set.index[-1]}')\n \n            if not args.eval_zero_shot:\n                # train the model\n                # we use deepcopy to avoid modifying the original model\n                tuned_model = train(training_set_, validation_set, args, deepcopy(model),\n                                    transform, loss, args.lr, args.device)\n            else:\n                tuned_model = deepcopy(model)\n\n            # do the evaluation on the building test data\n            torch_test_set = PandasTransformerDataset(test_set,\n                                                      sliding_window=24)\n            test_dataloader = torch.utils.data.DataLoader(\n                                        torch_test_set,\n                                        batch_size=360,\n                                        num_workers=args.num_workers,\n                                        shuffle=False)\n\n            tuned_model.eval()\n            with torch.no_grad():\n                for batch in test_dataloader:\n                    building_types_mask = batch['building_type'][:,0,0] == 1\n\n                    for k,v in batch.items():\n                        batch[k] = v.to(args.device)\n\n                    continuous_load = batch['load'].clone()\n                    continuous_targets = continuous_load[:, tuned_model.context_len:]\n\n                    # Transform if needed\n                    batch['load'] = transform(batch['load'])\n                    targets = batch['load'][:, tuned_model.context_len:]\n\n                    if args.device == 'cuda':\n                        with torch.cuda.amp.autocast():\n                            predictions, distribution_params = tuned_model.predict(batch)\n                    else:\n                        predictions, distribution_params = tuned_model.predict(batch)\n\n                    predictions = inverse_transform(predictions)\n\n                    if args.apply_scaler_transform != '':\n                        continuous_targets = inverse_transform(continuous_targets)\n                        targets = inverse_transform(targets)\n                        if args.apply_scaler_transform == 'standard':\n                            mu = inverse_transform(distribution_params[:,:,0])\n                            sigma = load_transform.undo_transform_std(distribution_params[:,:,1])\n                            distribution_params = torch.cat([mu.unsqueeze(-1), sigma.unsqueeze(-1)],-1)\n                        \n                        elif args.apply_scaler_transform == 'boxcox':\n                            ######## approximate Gaussian in unscaled space ########\n                            mu = inverse_transform(distribution_params[:,:,0])\n                            muplussigma = inverse_transform(torch.sum(distribution_params,-1))\n                            sigma = muplussigma - mu\n                            muminussigma = inverse_transform(distribution_params[:,:,0] - distribution_params[:,:,1])\n                            sigma = (sigma + (mu - muminussigma)) / 2\n                            distribution_params = torch.cat([mu.unsqueeze(-1), sigma.unsqueeze(-1)],-1)\n\n                    if not model.continuous_loads:\n                        centroids = load_transform.kmeans.centroids.squeeze() \\\n                            if args.tokenizer_without_merge else load_transform.merged_centroids\n                    else:\n                        centroids = None\n\n                    metrics_manager(\n                        dataset,\n                        building_name,\n                        continuous_targets,\n                        predictions,\n                        building_types_mask,\n                        y_categories=targets,\n                        y_distribution_params=distribution_params,\n                        centroids=centroids\n                    )\n\n    print('Generating summaries...')\n    variant_name = f':{args.variant_name}' if args.variant_name != '' else ''\n    metrics_file = results_path / f'TL_metrics_{args.config}{variant_name}.csv'\n    scoring_rule_file = results_path / f'TL_scoring_rule_{args.config}{variant_name}.csv'\n\n    if not args.ignore_scoring_rules:\n        metrics_df, scoring_rule_df = metrics_manager.summary()    \n        if metrics_file.exists():    \n            metrics_df.to_csv(metrics_file, mode='a', index=False, header=False)\n        else:\n            metrics_df.to_csv(metrics_file, index=False)\n        if scoring_rule_file.exists():\n            scoring_rule_df.to_csv(scoring_rule_file, mode='a', index=False, header=False)\n        else:\n            scoring_rule_df.to_csv(scoring_rule_file, index=False)\n    else:\n        metrics_df = metrics_manager.summary()    \n        if metrics_file.exists():    \n            metrics_df.to_csv(metrics_file, mode='a', index=False, header=False)\n        else:\n            metrics_df.to_csv(metrics_file, index=False)", "\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser()\n\n    parser.add_argument('--results_path', type=str, default='results/')\n    parser.add_argument('--config', type=str, default='', required=True)\n    parser.add_argument('--benchmark', nargs='+', type=str, default=['all'],\n                        help='Which datasets in the benchmark to run. Default is [\"all.\"] '\n                             'See the dataset registry in buildings_bench.data.__init__.py for options.')\n    parser.add_argument('--num_workers', type=int, default=2)\n    parser.add_argument('--seed', type=int, default=1)\n    parser.add_argument('--ignore_scoring_rules', action='store_true', help='Do not compute a scoring rule')\n    parser.add_argument('--variant_name', type=str, default='',\n                        help='Name of the variant. Optional. Used for results files.')\n    parser.add_argument('--device', type=str, default='cuda')\n    parser.add_argument('--tokenizer_without_merge', action='store_true', default=False, \n                        help='Use the tokenizer without merge. Default is False.')\n    parser.add_argument('--apply_scaler_transform', type=str, default='',\n                        choices=['', 'standard', 'boxcox'], \n                        help='Apply a scaler transform to the load values.')\n    \n    # Transfer Learning - model\n    parser.add_argument('--checkpoint', type=str, default='',\n                        help='Path to a checkpoint to load.')\n    parser.add_argument('--max_epochs', type=int, default=25)\n    parser.add_argument('--lr', type=float, default=1e-6) # 1e-4, 1e-5, 1e-6\n    parser.add_argument('--batch_size', type=int, default=16)\n    parser.add_argument('--patience', type=int, default=2)\n\n    # Transfer learning - data\n    parser.add_argument('--num_training_days', type=int, default=180,\n                        help='Number of days for fine-tuning (last 30 used for early stopping)')\n    parser.add_argument('--dont_subsample_buildings', action='store_true', default=False,\n                        help='Evaluate on all instead of a subsample of 100 res/com buildings')    \n    parser.add_argument('--eval_zero_shot', action='store_true', default=False,\n                        help='Evaluate on the test data without fine-tuning, '\n                             'useful for getting baseline perf')\n\n    args = parser.parse_args()\n    utils.set_seed(args.seed)\n    \n    config_path = SCRIPT_PATH  / '..' / 'buildings_bench' / 'configs'\n    if (config_path / f'{args.config}.toml').exists():\n            toml_args = tomli.load(( config_path / f'{args.config}.toml').open('rb'))\n            model_args = toml_args['model']\n            if 'transfer_learning' in toml_args:\n                for k,v in toml_args['transfer_learning'].items():\n                    setattr(args, k, v)\n            if not model_args['continuous_loads']:\n                setattr(args, 'apply_scaler_transform', '')\n    else:\n        raise ValueError(f'Config {args.config}.toml not found.')\n\n   \n    results_path = Path(args.results_path)\n    results_path.mkdir(parents=True, exist_ok=True)\n\n    transfer_learning(args, model_args, results_path)", ""]}
{"filename": "scripts/fit_tokenizer.py", "chunked_list": ["import argparse\nfrom pathlib import Path\nimport numpy as np\nimport pyarrow.parquet as pq\nimport random\nimport glob \nimport os\nfrom buildings_bench.tokenizer import LoadQuantizer\n\n\ndef main(args):\n    random.seed(args.seed)\n    np.random.seed(args.seed)\n\n    output_dir = Path(os.environ.get('BUILDINGS_BENCH', ''), 'metadata')\n    time_series_dir = Path(os.environ.get('BUILDINGS_BENCH', ''), 'Buildings-900K', 'end-use-load-profiles-for-us-building-stock', '2021')    \n    building_years = ['comstock_tmy3_release_1', 'resstock_tmy3_release_1', 'comstock_amy2018_release_1', 'resstock_amy2018_release_1'] \n    pumas = ['by_puma_midwest', 'by_puma_south', 'by_puma_northeast', 'by_puma_west']\n\n    all_buildings = []\n    num_buildings = 0\n\n    for by in building_years:\n        by_path = time_series_dir / by / 'timeseries_individual_buildings'\n        for pum in pumas:\n            pum_path = by_path / pum / 'upgrade=0'\n            pum_files = glob.glob(str(pum_path / 'puma=*'))\n            # subsample pumas for faster quantization to 10 per census region\n            random.shuffle(pum_files)\n            pum_files = pum_files[:10]\n\n            for pum_file in pum_files:\n                # load the parquet file and convert each column to a numpy array\n                df = pq.read_table(pum_file).to_pandas()\n                # convert each column to a numpy array and stack vertically\n                all_buildings += [np.vstack([df[col].to_numpy() for col in df.columns if col != 'timestamp'])]\n                num_buildings += len(all_buildings[-1])\n\n    print(f'Loaded {num_buildings} buildings for tokenization')\n\n    lq = LoadQuantizer(args.seed, \n                       num_centroids=args.num_clusters,\n                       with_merge=(not args.without_merge),\n                       merge_threshold=args.merge_threshold,\n                       device=args.device)\n    lq.train(np.vstack(all_buildings))\n    lq.save(output_dir)", "\n\ndef main(args):\n    random.seed(args.seed)\n    np.random.seed(args.seed)\n\n    output_dir = Path(os.environ.get('BUILDINGS_BENCH', ''), 'metadata')\n    time_series_dir = Path(os.environ.get('BUILDINGS_BENCH', ''), 'Buildings-900K', 'end-use-load-profiles-for-us-building-stock', '2021')    \n    building_years = ['comstock_tmy3_release_1', 'resstock_tmy3_release_1', 'comstock_amy2018_release_1', 'resstock_amy2018_release_1'] \n    pumas = ['by_puma_midwest', 'by_puma_south', 'by_puma_northeast', 'by_puma_west']\n\n    all_buildings = []\n    num_buildings = 0\n\n    for by in building_years:\n        by_path = time_series_dir / by / 'timeseries_individual_buildings'\n        for pum in pumas:\n            pum_path = by_path / pum / 'upgrade=0'\n            pum_files = glob.glob(str(pum_path / 'puma=*'))\n            # subsample pumas for faster quantization to 10 per census region\n            random.shuffle(pum_files)\n            pum_files = pum_files[:10]\n\n            for pum_file in pum_files:\n                # load the parquet file and convert each column to a numpy array\n                df = pq.read_table(pum_file).to_pandas()\n                # convert each column to a numpy array and stack vertically\n                all_buildings += [np.vstack([df[col].to_numpy() for col in df.columns if col != 'timestamp'])]\n                num_buildings += len(all_buildings[-1])\n\n    print(f'Loaded {num_buildings} buildings for tokenization')\n\n    lq = LoadQuantizer(args.seed, \n                       num_centroids=args.num_clusters,\n                       with_merge=(not args.without_merge),\n                       merge_threshold=args.merge_threshold,\n                       device=args.device)\n    lq.train(np.vstack(all_buildings))\n    lq.save(output_dir)", "\n\nif __name__ == '__main__':\n    args = argparse.ArgumentParser()\n\n    args.add_argument('--num_clusters', type=int, default=8192, required=False,\n                        help='Number of clusters for KMeans. Default: 8192')\n    args.add_argument('--without_merge', action='store_true',\n                        help='Do not merge clusters in KMeans. Default: False')\n    args.add_argument('--merge_threshold', type=float, default=0.01, required=False,\n                        help='Threshold for merging clusters during tokenization. Default: 0.01') \n    args.add_argument('--device', type=str, default='cuda:0', required=False,\n                            help='Device to use. Default: cuda:0')\n    args.add_argument('--seed', type=int, default=1, required=False,\n                        help='Random seed for KMeans and shuffling. Default: 1')\n\n    args = args.parse_args()\n\n    main(args)", ""]}
{"filename": "scripts/zero_shot.py", "chunked_list": ["import torch \nfrom pathlib import Path\nimport argparse \nimport os\nimport tomli\n\nfrom buildings_bench import load_torch_dataset, benchmark_registry\nfrom buildings_bench import utils\nfrom buildings_bench.tokenizer import LoadQuantizer\nfrom buildings_bench.evaluation.managers import DatasetMetricsManager", "from buildings_bench.tokenizer import LoadQuantizer\nfrom buildings_bench.evaluation.managers import DatasetMetricsManager\nfrom buildings_bench.models import model_factory\nfrom buildings_bench.evaluation import scoring_rule_factory\n\nSCRIPT_PATH = Path(os.path.realpath(__file__)).parent\n\n\n@torch.no_grad()\ndef zero_shot_learning(args, model_args, results_path: Path):\n    device = args.device\n\n    model, _, predict = model_factory(args.config, model_args)\n    model = model.to(device)\n\n    transform_path = Path(os.environ.get('BUILDINGS_BENCH', '')) \\\n        / 'metadata' / 'transforms'\n\n    if not model.continuous_loads:   \n        load_transform = LoadQuantizer(\n            with_merge=(not args.tokenizer_without_merge),\n              num_centroids=model.vocab_size,\n              device='cuda:0' if 'cuda' in device else 'cpu')\n        load_transform.load(transform_path)\n\n    # Load from ckpts\n    if args.checkpoint != '':\n        model.load_from_checkpoint(args.checkpoint)\n    model.eval()\n\n    if args.benchmark[0] == 'all':\n        args.benchmark = benchmark_registry\n\n    if args.ignore_scoring_rules:\n        metrics_manager = DatasetMetricsManager()\n    elif model.continuous_loads:\n        metrics_manager = DatasetMetricsManager(scoring_rule = scoring_rule_factory('crps'))\n    else:\n        metrics_manager = DatasetMetricsManager(scoring_rule = scoring_rule_factory('rps'))\n\n    print(f'Evaluating model on test datasets {args.benchmark}...')\n\n    # Iterate over each dataset in the benchmark\n    for dataset_name in args.benchmark:\n        # Load the dataset generator\n        buildings_datasets_generator = load_torch_dataset(dataset_name,\n                                                    apply_scaler_transform=args.apply_scaler_transform,\n                                                    scaler_transform_path=transform_path)\n        # For each building\n        for building_name, building_dataset in buildings_datasets_generator:\n            print(f'dataset {dataset_name} building-year {building_name} '\n                    f'day-ahead forecasts {len(building_dataset)}')\n\n            metrics_manager.add_building_to_dataset_if_missing(\n                dataset_name, building_name,\n            )\n\n            if not model.continuous_loads: # Quantized loads\n                 transform = load_transform.transform\n                 inverse_transform = load_transform.undo_transform\n            elif args.apply_scaler_transform != '': # Scaling continuous values\n                 transform = lambda x: x \n\n                 if isinstance(building_dataset, torch.utils.data.ConcatDataset):\n                     load_transform = building_dataset.datasets[0].load_transform\n                     inverse_transform = load_transform.undo_transform\n                 else:\n                     load_transform = building_dataset.load_transform\n                     inverse_transform = load_transform.undo_transform\n            else: # Continuous unscaled values\n                 transform = lambda x: x\n                 inverse_transform = lambda x: x\n        \n            # create a dataloader for the building\n            building_dataloader = torch.utils.data.DataLoader(\n                                    building_dataset,\n                                    batch_size=args.batch_size,\n                                    shuffle=False)\n            for batch in building_dataloader:\n                building_types_mask = batch['building_type'][:,0,0] == 1\n\n                for k,v in batch.items():\n                    batch[k] = v.to(device)\n\n                continuous_load = batch['load'].clone()\n                continuous_targets = continuous_load[:, model.context_len:]\n\n                # Transform if needed\n                batch['load'] = transform(batch['load'])\n                # These could be tokens or continuous\n                targets = batch['load'][:, model.context_len:]\n\n                if args.device == 'cuda':\n                    with torch.cuda.amp.autocast():\n                        predictions, distribution_params = predict(batch)\n                else:\n                    predictions, distribution_params = predict(batch)\n                    \n                predictions = inverse_transform(predictions)\n\n                if args.apply_scaler_transform != '':\n                    continuous_targets = inverse_transform(continuous_targets)\n                    # invert for crps\n                    targets = inverse_transform(targets)\n                    if args.apply_scaler_transform == 'standard':\n                        mu = inverse_transform(distribution_params[:,:,0])\n                        sigma = load_transform.undo_transform_std(distribution_params[:,:,1])\n                        distribution_params = torch.cat([mu.unsqueeze(-1), sigma.unsqueeze(-1)],-1)\n                    \n                    elif args.apply_scaler_transform == 'boxcox':\n                        ######## backproject approximate Gaussian in unscaled space ########\n                        mu = inverse_transform(distribution_params[:,:,0])\n                        muplussigma = inverse_transform(torch.sum(distribution_params,-1))\n                        sigma = muplussigma - mu\n                        muminussigma = inverse_transform(distribution_params[:,:,0] - distribution_params[:,:,1])\n                        sigma = (sigma + (mu - muminussigma)) / 2\n                        distribution_params = torch.cat([mu.unsqueeze(-1), sigma.unsqueeze(-1)],-1)\n\n                if not model.continuous_loads:\n                    centroids = load_transform.kmeans.centroids.squeeze() \\\n                        if args.tokenizer_without_merge else load_transform.merged_centroids\n                else:\n                    centroids = None\n                \n                metrics_manager(\n                    dataset_name,\n                    building_name,\n                    continuous_targets,\n                    predictions,\n                    building_types_mask,\n                    y_categories=targets,\n                    y_distribution_params=distribution_params,\n                    centroids=centroids\n                )\n    print('Generating summaries...')\n    variant_name = f':{args.variant_name}' if args.variant_name != '' else ''\n    metrics_file = results_path / f'metrics_{args.config}{variant_name}.csv'\n    scoring_rule_file = results_path / f'scoring_rule_{args.config}{variant_name}.csv'\n\n    if not args.ignore_scoring_rules:\n        metrics_df, scoring_rule_df = metrics_manager.summary()    \n        if metrics_file.exists():    \n            metrics_df.to_csv(metrics_file, mode='a', index=False, header=False)\n        else:\n            metrics_df.to_csv(metrics_file, index=False)\n        if scoring_rule_file.exists():\n            scoring_rule_df.to_csv(scoring_rule_file, mode='a', index=False, header=False)\n        else:\n            scoring_rule_df.to_csv(scoring_rule_file, index=False)\n    else:\n        metrics_df = metrics_manager.summary()    \n        if metrics_file.exists():    \n            metrics_df.to_csv(metrics_file, mode='a', index=False, header=False)\n        else:\n            metrics_df.to_csv(metrics_file, index=False)", "@torch.no_grad()\ndef zero_shot_learning(args, model_args, results_path: Path):\n    device = args.device\n\n    model, _, predict = model_factory(args.config, model_args)\n    model = model.to(device)\n\n    transform_path = Path(os.environ.get('BUILDINGS_BENCH', '')) \\\n        / 'metadata' / 'transforms'\n\n    if not model.continuous_loads:   \n        load_transform = LoadQuantizer(\n            with_merge=(not args.tokenizer_without_merge),\n              num_centroids=model.vocab_size,\n              device='cuda:0' if 'cuda' in device else 'cpu')\n        load_transform.load(transform_path)\n\n    # Load from ckpts\n    if args.checkpoint != '':\n        model.load_from_checkpoint(args.checkpoint)\n    model.eval()\n\n    if args.benchmark[0] == 'all':\n        args.benchmark = benchmark_registry\n\n    if args.ignore_scoring_rules:\n        metrics_manager = DatasetMetricsManager()\n    elif model.continuous_loads:\n        metrics_manager = DatasetMetricsManager(scoring_rule = scoring_rule_factory('crps'))\n    else:\n        metrics_manager = DatasetMetricsManager(scoring_rule = scoring_rule_factory('rps'))\n\n    print(f'Evaluating model on test datasets {args.benchmark}...')\n\n    # Iterate over each dataset in the benchmark\n    for dataset_name in args.benchmark:\n        # Load the dataset generator\n        buildings_datasets_generator = load_torch_dataset(dataset_name,\n                                                    apply_scaler_transform=args.apply_scaler_transform,\n                                                    scaler_transform_path=transform_path)\n        # For each building\n        for building_name, building_dataset in buildings_datasets_generator:\n            print(f'dataset {dataset_name} building-year {building_name} '\n                    f'day-ahead forecasts {len(building_dataset)}')\n\n            metrics_manager.add_building_to_dataset_if_missing(\n                dataset_name, building_name,\n            )\n\n            if not model.continuous_loads: # Quantized loads\n                 transform = load_transform.transform\n                 inverse_transform = load_transform.undo_transform\n            elif args.apply_scaler_transform != '': # Scaling continuous values\n                 transform = lambda x: x \n\n                 if isinstance(building_dataset, torch.utils.data.ConcatDataset):\n                     load_transform = building_dataset.datasets[0].load_transform\n                     inverse_transform = load_transform.undo_transform\n                 else:\n                     load_transform = building_dataset.load_transform\n                     inverse_transform = load_transform.undo_transform\n            else: # Continuous unscaled values\n                 transform = lambda x: x\n                 inverse_transform = lambda x: x\n        \n            # create a dataloader for the building\n            building_dataloader = torch.utils.data.DataLoader(\n                                    building_dataset,\n                                    batch_size=args.batch_size,\n                                    shuffle=False)\n            for batch in building_dataloader:\n                building_types_mask = batch['building_type'][:,0,0] == 1\n\n                for k,v in batch.items():\n                    batch[k] = v.to(device)\n\n                continuous_load = batch['load'].clone()\n                continuous_targets = continuous_load[:, model.context_len:]\n\n                # Transform if needed\n                batch['load'] = transform(batch['load'])\n                # These could be tokens or continuous\n                targets = batch['load'][:, model.context_len:]\n\n                if args.device == 'cuda':\n                    with torch.cuda.amp.autocast():\n                        predictions, distribution_params = predict(batch)\n                else:\n                    predictions, distribution_params = predict(batch)\n                    \n                predictions = inverse_transform(predictions)\n\n                if args.apply_scaler_transform != '':\n                    continuous_targets = inverse_transform(continuous_targets)\n                    # invert for crps\n                    targets = inverse_transform(targets)\n                    if args.apply_scaler_transform == 'standard':\n                        mu = inverse_transform(distribution_params[:,:,0])\n                        sigma = load_transform.undo_transform_std(distribution_params[:,:,1])\n                        distribution_params = torch.cat([mu.unsqueeze(-1), sigma.unsqueeze(-1)],-1)\n                    \n                    elif args.apply_scaler_transform == 'boxcox':\n                        ######## backproject approximate Gaussian in unscaled space ########\n                        mu = inverse_transform(distribution_params[:,:,0])\n                        muplussigma = inverse_transform(torch.sum(distribution_params,-1))\n                        sigma = muplussigma - mu\n                        muminussigma = inverse_transform(distribution_params[:,:,0] - distribution_params[:,:,1])\n                        sigma = (sigma + (mu - muminussigma)) / 2\n                        distribution_params = torch.cat([mu.unsqueeze(-1), sigma.unsqueeze(-1)],-1)\n\n                if not model.continuous_loads:\n                    centroids = load_transform.kmeans.centroids.squeeze() \\\n                        if args.tokenizer_without_merge else load_transform.merged_centroids\n                else:\n                    centroids = None\n                \n                metrics_manager(\n                    dataset_name,\n                    building_name,\n                    continuous_targets,\n                    predictions,\n                    building_types_mask,\n                    y_categories=targets,\n                    y_distribution_params=distribution_params,\n                    centroids=centroids\n                )\n    print('Generating summaries...')\n    variant_name = f':{args.variant_name}' if args.variant_name != '' else ''\n    metrics_file = results_path / f'metrics_{args.config}{variant_name}.csv'\n    scoring_rule_file = results_path / f'scoring_rule_{args.config}{variant_name}.csv'\n\n    if not args.ignore_scoring_rules:\n        metrics_df, scoring_rule_df = metrics_manager.summary()    \n        if metrics_file.exists():    \n            metrics_df.to_csv(metrics_file, mode='a', index=False, header=False)\n        else:\n            metrics_df.to_csv(metrics_file, index=False)\n        if scoring_rule_file.exists():\n            scoring_rule_df.to_csv(scoring_rule_file, mode='a', index=False, header=False)\n        else:\n            scoring_rule_df.to_csv(scoring_rule_file, index=False)\n    else:\n        metrics_df = metrics_manager.summary()    \n        if metrics_file.exists():    \n            metrics_df.to_csv(metrics_file, mode='a', index=False, header=False)\n        else:\n            metrics_df.to_csv(metrics_file, index=False)", "\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser()\n\n    parser.add_argument('--results_path', type=str, default='results/')\n    parser.add_argument('--config', type=str, default='', required=True)\n    parser.add_argument('--benchmark', nargs='+', type=str, default=['all'],\n                        help='Which datasets in the benchmark to run. Default is [\"all.\"] '\n                             'See the dataset registry in buildings_bench.data.__init__.py for options.')\n    parser.add_argument('--num_workers', type=int, default=4)\n    parser.add_argument('--batch_size', type=int, default=360)\n    parser.add_argument('--seed', type=int, default=1)\n    parser.add_argument('--ignore_scoring_rules', action='store_true', \n                        help='Do not compute a scoring rule for this model.')\n    parser.add_argument('--checkpoint', type=str, default='',\n                        help='Path to a checkpoint to load. Optional. '\n                        ' One can also load a checkpoint from Wandb by specifying the run_id.')\n    parser.add_argument('--variant_name', type=str, default='',\n                        help='Name of the variant. Optional. Used for results files.')\n    parser.add_argument('--device', type=str, default='cuda' if torch.cuda.is_available() else 'cpu',\n                        help='Device to use. Default is cuda if available else cpu.')\n    parser.add_argument('--tokenizer_without_merge', action='store_true', default=False, \n                        help='Use the tokenizer without merge. Default is False.')\n    parser.add_argument('--apply_scaler_transform', type=str, default='',\n                        choices=['', 'standard', 'boxcox'], \n                        help='Apply a scaler transform to the load values.')\n    \n    args = parser.parse_args()\n    utils.set_seed(args.seed)\n    \n    config_path = SCRIPT_PATH  / '..' / 'buildings_bench' / 'configs'\n    if (config_path / f'{args.config}.toml').exists():\n        toml_args = tomli.load(( config_path / f'{args.config}.toml').open('rb'))\n        model_args = toml_args['model']\n        if 'zero_shot' in toml_args:\n            for k,v in toml_args['zero_shot'].items():\n                setattr(args, k, v)\n        if not model_args['continuous_loads'] or 'apply_scaler_transform' not in args:\n            setattr(args, 'apply_scaler_transform', '')\n    else:\n        raise ValueError(f'Config {args.config}.toml not found.')\n\n    results_path = Path(args.results_path)\n    results_path.mkdir(parents=True, exist_ok=True)\n\n    zero_shot_learning(args, model_args, results_path)", ""]}
{"filename": "scripts/subsample_buildings_for_transfer_learning.py", "chunked_list": ["\n\"\"\"\nRandomly select 100 residential and 100 commercial buildings \nfrom BuildingsBench for transfer learning.\n\"\"\"\nfrom buildings_bench import load_pandas_dataset, benchmark_registry\nfrom pathlib import Path\nimport numpy as np\nimport random\nimport os", "import random\nimport os\n\ndataset_path = Path(os.environ.get('BUILDINGS_BENCH', ''))\ndatasets = [b for b in benchmark_registry if b != 'buildings-900k-test']\n\ndef consecutive(arr):\n    if len(arr) == 1:\n        return True\n        \n    diffs = arr[1:] - arr[:-1]\n    if (diffs>1).any():\n        return False\n    return True", "\n\nresidential_buildings = set()\ncommercial_buildings = set()\n    \nfor dataset in datasets:\n    building_datasets_generator = load_pandas_dataset(dataset, dataset_path =dataset_path)\n    for building_name, building_dataset in building_datasets_generator:\n        years = building_dataset.index.year.unique()\n        years = np.sort(years)\n                \n        # ensure the data we have across multiple years spans consecutive years,\n        # else we might try to use data from Dec 2014 and Jan 2016 for example.\n        # \n        # also ensure the building has at least ~210 days of data\n        if consecutive(years) and len(building_dataset) > (180+30)*24:\n                \n            if building_datasets_generator.building_type == 'residential':\n                residential_buildings.add(building_name)\n            elif building_datasets_generator.building_type == 'commercial':\n                commercial_buildings.add(building_name)", "\n# sample 100 residential buildings\nresidential_buildings = list(residential_buildings)\ncommercial_buildings = list(commercial_buildings)\n\nnp.random.seed(100)\nrandom.seed(100)\n\nresidential_buildings = random.sample(residential_buildings, 100)\ncommercial_buildings = random.sample(commercial_buildings, 100)", "residential_buildings = random.sample(residential_buildings, 100)\ncommercial_buildings = random.sample(commercial_buildings, 100)\n\nwith open(dataset_path / 'metadata' / 'transfer_learning_residential_buildings.txt', 'w') as f:\n    for b in residential_buildings:\n        f.write(f'{b}\\n')\n\nwith open(dataset_path / 'metadata' / 'transfer_learning_commercial_buildings.txt', 'w') as f:\n    for b in commercial_buildings:\n        f.write(f'{b}\\n')", ""]}
{"filename": "scripts/create_index_files.py", "chunked_list": ["import argparse\nfrom pathlib import Path\nimport numpy as np\nimport pyarrow.parquet as pq\nimport random\nimport glob \nimport pandas as pd\nimport os\nfrom tqdm import tqdm\n", "from tqdm import tqdm\n\n\ndef main(args):\n    random.seed(args.seed)\n    np.random.seed(args.seed)\n\n    output_dir = Path(os.environ.get('BUILDINGS_BENCH', ''), 'metadata')\n    time_series_dir = Path(os.environ.get('BUILDINGS_BENCH', ''), 'Buildings-900K', 'end-use-load-profiles-for-us-building-stock', '2021')\n    building_years = ['comstock_tmy3_release_1', 'resstock_tmy3_release_1', 'comstock_amy2018_release_1', 'resstock_amy2018_release_1'] \n    pumas = ['by_puma_midwest', 'by_puma_south', 'by_puma_northeast', 'by_puma_west']\n    \n    # Each line in the index file indicates a building and n \n    #   <building_type_and_year> <census_region> <puma_id> <building_id> <seq ptr>\n    #  e.g. <0-4> <0-4> G17031 23023 65\n    train_idx_file = open(output_dir / f'train_weekly.idx', 'w')\n    val_idx_file = open(output_dir / f'val_weekly.idx', 'w')\n\n    # withhold 1 puma from each census region (all res and com buildingss) for test only\n    # midwest, south, northeast, west\n    # read withheld pumas from file\n    with open(Path(os.environ.get('BUILDINGS_BENCH','')) / 'metadata' / 'withheld_pumas.tsv', 'r') as f:\n        # tab separated file\n        line = f.readlines()[0]\n        withheld_pumas = line.strip('\\n').split('\\t')\n    print(f'Withheld pumas: {withheld_pumas}')\n\n    # 2 weeks heldout for val\n    train_tmy_timerange = (pd.Timestamp('2018-01-01'), pd.Timestamp('2018-12-31'))\n    train_amy2018_timerange = (pd.Timestamp('2018-01-01'), pd.Timestamp('2018-12-17'))\n    val_timerange = (pd.Timestamp('2018-12-17'), pd.Timestamp('2018-12-31'))\n    \n\n    for building_type_and_year, by in enumerate(building_years):\n        by_path = time_series_dir / by / 'timeseries_individual_buildings'\n\n        if 'amy2018' in by:\n            train_hours = int((train_amy2018_timerange[1] - train_amy2018_timerange[0]).total_seconds() / 3600)\n            print(f'AMY2018 train hours: {train_hours}')\n\n            val_hours = int((val_timerange[1] - val_timerange[0]).total_seconds() / 3600)\n            print(f'AMY2018 Val hours: {val_hours}')\n\n        else:\n            train_hours = int((train_tmy_timerange[1] - train_tmy_timerange[0]).total_seconds() / 3600)\n            print(f'TMY train hours: {train_hours}')\n\n        for census_region_idx, pum in enumerate(pumas): # census regions\n            pum_path = by_path / pum / 'upgrade=0'\n            pum_files = glob.glob(str(pum_path / 'puma=*'))\n\n            for pum_file in tqdm(pum_files):\n                try:\n                    bldg_ids = pq.read_table(pum_file).to_pandas().columns[1:]\n                except:\n                    print(f'Failed to read {pum_file}')\n                    import pdb; pdb.set_trace()\n                    continue\n                    \n                # skip withheld pumas in train and val\n                if not os.path.basename(pum_file) in withheld_pumas:\n                    for bldg_id in bldg_ids:\n                        # train\n                        bldg_id = bldg_id.zfill(6)\n                        # Sample the starting index between (0,24)\n                        s_start = np.random.randint(0, 24)\n                        for s_idx in range(s_start, train_hours - (args.context_len + args.pred_len), args.sliding_window_stride):                            \n                            seq_ptr = str(args.context_len + s_idx).zfill(4)  # largest seq ptr is < 10000\n                            # NB: We don't *need* \\n at the end of each line, but it makes it easier to count # of lines for dataloading\n                            linestr = f'{building_type_and_year}\\t{census_region_idx}\\t{os.path.basename(pum_file).split(\"=\")[1]}\\t{bldg_id}\\t{seq_ptr}\\n'\n                            assert len(linestr) == 26, f'linestr: {linestr}'\n                            train_idx_file.write(linestr)\n                        # val\n                        if 'amy2018' in by:\n                            s_start += train_hours \n                            for s_idx in range(s_start, (train_hours + val_hours) - (args.context_len + args.pred_len), args.sliding_window_stride):\n                                seq_ptr = str(args.context_len + s_idx).zfill(4)  # largest seq ptr is < 10000\n                                assert len(linestr) == 26, f'linestr: {linestr}'\n                                linestr = f'{building_type_and_year}\\t{census_region_idx}\\t{os.path.basename(pum_file).split(\"=\")[1]}\\t{bldg_id}\\t{seq_ptr}\\n'\n                                val_idx_file.write(linestr)\n                        \n\n    # Close files\n    train_idx_file.close()\n    val_idx_file.close()", "\n   \nif __name__ == '__main__':\n    args = argparse.ArgumentParser()\n\n    args.add_argument('--seed', type=int, default=1, required=False,\n                        help='Random seed for KMeans and shuffling. Default: 1')\n    args.add_argument('--sliding_window_stride', type=int, default=24, required=False,\n                        help='Stride for sliding window to split timeseries into training examples. Default: 24 hours')\n    args.add_argument('--context_len', type=int, default=168, required=False,\n                                help='Length of context sequence. For handling year beginning and year end. Default: 168 hours')\n    args.add_argument('--pred_len', type=int, default=24, required=False,\n                                help='Length of prediction sequence. For handling year beginning and year end. Default: 24 hours')\n\n    args = args.parse_args()\n\n    main(args)", ""]}
{"filename": "scripts/process_raw_data/download_and_process_buildingsbench.py", "chunked_list": ["\"\"\"\nBasic preprocessing steps for real building data\n\n1. Resample sub-hourly kW data to hourly kWh data\n2. Remove buildings with more than 10% of missing values\n3. Linearly interpolate missing hour data\n4. Save to csv\n\"\"\"\nimport pandas as pd\nimport numpy as np", "import pandas as pd\nimport numpy as np\nimport glob\nfrom pathlib import Path \nimport os\nimport random\n\n    \ndef download_electricity_data(savedir):\n    url = 'https://archive.ics.uci.edu/static/public/321/electricityloaddiagrams20112014.zip'\n    os.system(f'wget {url}')\n    os.system('unzip electricityloaddiagrams20112014.zip')\n    os.system('rm electricityloaddiagrams20112014.zip')\n    os.system(f'mv LD2011_2014.txt {savedir}')", "def download_electricity_data(savedir):\n    url = 'https://archive.ics.uci.edu/static/public/321/electricityloaddiagrams20112014.zip'\n    os.system(f'wget {url}')\n    os.system('unzip electricityloaddiagrams20112014.zip')\n    os.system('rm electricityloaddiagrams20112014.zip')\n    os.system(f'mv LD2011_2014.txt {savedir}')\n\ndef download_bdg2_data(savedir):\n    url = 'https://github.com/buds-lab/building-data-genome-project-2'\n    print(f'use git lfs to download the data from the git repo {url} '\n          f' then copy it to {savedir}')", "\n\ndef download_sceaux_data(savedir):\n    url = 'https://www.kaggle.com/datasets/uciml/electric-power-consumption-data-set'\n    print(f'Log into Kaggle then download the dataset from {url}. Unzip the file archive.zip and copy '\n          f'the file household_power_consumption.txt to {savedir}')\n\ndef download_smart_data(savedir):\n    url_Homes = ['https://lass.cs.umass.edu/smarttraces/2017/HomeA-electrical.tar.gz',\n                 'https://lass.cs.umass.edu/smarttraces/2017/HomeB-electrical.tar.gz',\n                 'https://lass.cs.umass.edu/smarttraces/2017/HomeC-electrical.tar.gz',\n                 'https://lass.cs.umass.edu/smarttraces/2017/HomeD-electrical.tar.gz',\n                 'https://lass.cs.umass.edu/smarttraces/2017/HomeF-electrical.tar.gz',\n                 'https://lass.cs.umass.edu/smarttraces/2017/HomeG-electrical.tar.gz',\n                 'https://lass.cs.umass.edu/smarttraces/2017/HomeH-electrical.tar.gz',\n    ]\n    # untar each \n    for url in url_Homes:\n        os.system(f'wget {url}')\n        os.system(f'tar -xzf {url.split(\"/\")[-1]}')\n        os.system(f'rm {url.split(\"/\")[-1]}')\n        # move each to savedir\n        os.system(f'mv {url.split(\"/\")[-1].split(\"-\")[0]} {savedir}')", "\ndef download_borealis_data(savedir):\n    url = 'https://borealisdata.ca/dataset.xhtml?persistentId=doi:10.5683/SP2/R4SVBF'\n    print(f'Navigate to {url} and download the .zip datasest. Unzip the file and copy '\n          f'the folder 6secs_load_measurement_dataset to {savedir}')\n    \ndef download_ideal_data(savedir):\n    url = 'https://datashare.ed.ac.uk/bitstream/handle/10283/3647/household_sensors.zip'\n    os.system(f'wget {url}')\n    os.system(f'unzip household_sensors.zip')\n    os.system(f'rm household_sensors.zip')\n    os.system(f'mv sensordata {savedir}')", "    \ndef download_lcl_data(savedir):\n    url = 'https://data.london.gov.uk/download/smartmeter-energy-use-data-in-london-households/04feba67-f1a3-4563-98d0-f3071e3d56d1/Partitioned%20LCL%20Data.zip'\n    os.system(f'wget {url}')\n    os.system(f'unzip Partitioned\\ LCL\\ Data.zip')\n    os.system(f'rm Partitioned\\ LCL\\ Data.zip')\n    os.system(f'mv Small\\ LCL\\ Data/ {savedir}')\n\nif __name__ == '__main__':\n    dataset_dir = Path(os.environ.get('BUILDINGS_BENCH', ''))\n\n    print('WARNING: This script will try to automatically download and process the datasets in BuildingsBench.'\n          ' Please be sure to have followed the instructions for downloading the data from the following datasets, '\n          'which are not able to be automatically downloaded: ')\n    print('>>> BDG-2')\n    download_bdg2_data(dataset_dir / 'BDG-2')\n    print('>>> Sceaux')\n    download_sceaux_data(dataset_dir / 'Sceaux')\n    print('>>> Borealis')\n    download_borealis_data(dataset_dir / 'Borealis')    \n\n    ########################################################\n    print('Electricity...')\n    ########################################################       \n    (dataset_dir / 'Electricity').mkdir(parents=True, exist_ok=True)\n    download_electricity_data(dataset_dir / 'Electricity')\n\n    df = pd.read_csv(dataset_dir / 'Electricity' / 'LD2011_2014.txt', sep=';', index_col=0)\n    df.index = pd.to_datetime(df.index, format='%Y-%m-%d %H:%M:%S')\n    df = df.asfreq('15min')\n    df = df.sort_index()\n\n    # Set the type of each column to float\n    # Convert commas in each string to a period\n    for col in df.columns:\n        # if column entries are type str\n        if df[col].dtype == 'object' and col != 'index':\n            df[col] = df[col].apply(lambda x: float(x.replace(',', '.') if type(x) is str else x))\n\n    df = df.astype('float32')\n\n    # Resample 15 min -> hourly\n    df = df.resample(rule='H', closed='left', label='right').mean()\n\n    # Group buildings by year\n    years = [2011, 2012, 2013, 2014]\n    for year in years:\n        bldgs = df[df.index.year == year]\n        # Replace zeros with nan for this dataset, which uses zeros to indicate missing values\n        bldgs = bldgs.replace(0, np.nan)\n        # Drop buildings with more than 10% of missing values\n        bldgs = bldgs.dropna(thresh=len(bldgs)*0.9, axis=1)\n        # linearly interpolate nan values\n        bldgs = bldgs.interpolate(method='linear', axis=0, limit=24*7, limit_direction='both')\n        # Replace any remaining nan values with zeros (> 1 week)\n        bldgs = bldgs.fillna(0)\n        # Name the index column 'timestamp'\n        bldgs.index.name = 'timestamp'\n        bldgs = bldgs.asfreq('1H')\n        # Save to csv\n        bldgs.to_csv(dataset_dir / 'Electricity' / f'LD2011_2014_clean={year}.csv', index=True, header=True)\n\n    ########################################################\n    print('BDG-2...')\n    ########################################################\n\n    (dataset_dir / 'BDG-2').mkdir(parents=True, exist_ok=True)\n\n    try:\n        df = pd.read_csv(dataset_dir / 'electricity_cleaned.csv', sep=',')\n         # set timestamp as index\n        df = df.set_index('timestamp')\n        df.index = pd.to_datetime(df.index, format='%Y-%m-%d %H:%M:%S')\n\n        sites = ['Bear_', 'Fox_', 'Panther_', 'Rat_']\n        years = [2016, 2017]\n        for s in sites:\n            # regex filter for Panther\n            df_site = df.filter(regex=s)\n        \n            for year in years:\n                bldgs = df_site[df_site.index.year == year]\n                # Drop columns with more than 10% of missing values\n                bldgs = bldgs.dropna(thresh=len(bldgs)*0.9, axis=1)\n                # linearly interpolate nan values (1 week limit)\n                bldgs = bldgs.interpolate(method='linear', axis=0, limit=24*7, limit_direction='both')\n                # Replace any remaining nan values with zeros (> 1 week)\n                bldgs = bldgs.fillna(0)\n                sit = s.replace('_', '')\n                bldgs.to_csv(dataset_dir / 'BDG-2' / f'{sit}_clean={year}.csv', header=True, index=True)\n    except:\n        download_bdg2_data(dataset_dir / 'BDG-2')\n        print('skipping BDG-2...')\n\n\n    ########################################################\n    print('Sceaux...')\n    ########################################################\n\n    try:\n        (dataset_dir / 'Sceaux').mkdir(parents=True, exist_ok=True)\n        house = pd.read_csv(dataset_dir / 'Sceaux' / 'household_power_consumption.txt', sep=';', header=0)\n\n        # Combine Date and Time columns\n        house['timestamp'] = house['Date'] + ' ' + house['Time']\n        # Set timestamp as index\n        house = house.set_index('timestamp')\n        # Convert index to datetime\n        house.index = pd.to_datetime(house.index, format='%d/%m/%Y %H:%M:%S')\n        # Drop Date and Time columns\n        house = house.drop(['Date', 'Time'], axis=1)\n\n        # Replace ? values with NaN\n        house = house.replace('?', np.nan)\n        house = house.astype('float32')\n        house = house.asfreq('1min')\n        house = house.sort_index()\n        # resample to hourly data, ignoring nan values\n        house = house.resample(rule='H', closed='left', label='right').mean()\n        years = [2007, 2008, 2009, 2010]\n        for year in years:\n            h = house[house.index.year == year]\n            # Linearly interpolate missing values\n            h = h.interpolate(method='linear', axis=0, limit=24*7, limit_direction='both')\n            # Fill remaining missing values with zeros\n            h = h.fillna(0)\n            # Keep Global_active_power column\n            h = h[['Global_active_power']]\n            # Save to csv\n            h.to_csv(dataset_dir / 'Sceaux' / f'Sceaux_clean={year}.csv', header=True, index=True)\n    except:\n        download_sceaux_data(dataset_dir / 'Sceaux')\n        print('skipping Sceaux...')\n\n    ########################################################\n    print('SMART...')\n    ########################################################\n    \n    (dataset_dir / 'SMART').mkdir(parents=True, exist_ok=True)\n    download_smart_data(dataset_dir / 'SMART')\n    homes = [('HomeB', 'meter1'), ('HomeC', 'meter1'), ('HomeD', 'meter1'), ('HomeF', 'meter2'), ('HomeG', 'meter1'), ('HomeH', 'meter1')]\n    years = [2014, 2015, 2016]\n\n    power_column = 'use [kW]'\n\n    # Load data\n    for idx in range(len(homes)):\n        home = homes[idx][0]\n        meter = homes[idx][1]\n        for year in years:\n            try:\n                # join on timestamp index\n                house_ = pd.read_csv(dataset_dir / 'SMART' / f'{home}/{year}/{home}-{meter}_{year}.csv')\n            except:\n                continue\n            # Rename Date & Time to timestamp\n            house_ = house_.rename(columns={'Date & Time': 'timestamp'})\n            # Set timestamp as index\n            house_ = house_.set_index('timestamp')\n            # Convert index to datetime\n            house_.index = pd.to_datetime(house_.index, format='%Y-%m-%d %H:%M:%S')\n            # Replace missing values with NaN\n            house_ = house_.replace('?', np.nan)\n            # Resample to hourly\n            house_ = house_.resample(rule='H', closed='left', label='right').mean()\n\n            # only keep use [kW] column\n            if 'use [kW]' in house_.columns:\n                house_ = house_[['use [kW]']]\n                power_column = 'use [kW]'\n            if 'Usage [kW]' in house_.columns:\n                house_ = house_[['Usage [kW]']]\n                power_column = 'Usage [kW]'\n\n            house_ = house_.rename(columns={power_column: 'power'})\n            \n            missing_frac = house_['power'].isnull().sum() / house_.shape[0]\n            # Calculate fraction of missing values\n            #print(f'Fraction of NaN values in {home}-{meter} {year}: {missing_frac}')\n            # Calculate fraction of 0's\n            zeros_frac = (house_['power'] == 0.0).sum() / house_.shape[0]\n            #print(f'Fraction of 0 values in {home}-{meter} {year}: {zeros_frac}')\n\n            if missing_frac <= 0.1 and zeros_frac <= 0.1:\n                # Linearly interpolate missing values\n                house_ = house_.interpolate(method='linear', axis=0, limit=24*7, limit_direction='both') \n                # Fill remaining missing values with zeros\n                house_ = house_.fillna(0)\n                house_.to_csv(dataset_dir / 'SMART' / f'{home}_clean={year}.csv', header=True, index=True)\n\n    ########################################################\n    print('Borealis...')\n    ########################################################\n\n    (dataset_dir / 'Borealis').mkdir(parents=True, exist_ok=True)\n\n    try:\n        homes = glob.glob(str(dataset_dir / 'Borealis' / '6secs_load_measurement_dataset' / '*.csv'))\n        years = [2010, 2011, 2012]\n   \n        # Load data\n        for home in homes:\n            house_ = pd.read_csv(dataset_dir / 'Borealis'  / '6secs_load_measurement_dataset' / f'{home}.csv')\n\n            # Set timestamp as index\n            house_ = house_.set_index('timestamp')\n            # drop row 1, which has 0 value\n            house_ = house_.drop(house_.index[0])\n            # Convert index to datetime\n            house_.index = pd.to_datetime(house_.index, format='%Y-%m-%d %H:%M:%S')\n            # only keep power column\n            house_ = house_[['power']]\n            # Resample to hourly\n            house_ = house_.resample(rule='H', closed='left', label='right').mean()\n            # convert from Wh to kHh\n            house_ = house_ / 1000\n\n            for year in years:\n                h = house_[house_.index.year == year]\n                # count number of rows\n                if h.shape[0] < 168: # if < 1 week, throw out building-year\n                    continue\n                missing_frac = h[\"power\"].isnull().sum() / h.shape[0]\n\n                if missing_frac <= 0.1:\n                    # Linearly interpolate\n                    h = h.interpolate(method='linear', axis=0, limit=24*7, limit_direction='both')\n                    # Fill missing values with zeros\n                    h = h.fillna(0)\n                    # Save to csv\n                    h.to_csv(dataset_dir / 'Borealis' / f'{home}_clean={year}.csv', header=True, index=True)\n\n    except:\n        download_borealis_data(dataset_dir / 'Borealis')\n        print('skipping Borealis...')\n\n  \n    ########################################################\n    print('IDEAL...')\n    ########################################################\n    (dataset_dir / 'IDEAL').mkdir(parents=True, exist_ok=True)\n    \n    print('WARNING: the raw IDEAL dataset requires over 140GB of storage. Skip?')\n    skip = input('Skip IDEAL? (y/n): ')\n    if skip == 'y':\n        print('skipping IDEAL...')\n    else:\n        print('this may take a while...')\n        download_ideal_data(dataset_dir / 'IDEAL')\n        homes_gz = glob.glob(str(dataset_dir / 'IDEAL' / 'sensordata' / 'home*_electric-mains_electric-combined.csv.gz'))\n        # gunzip each file\n        for h in homes_gz:\n            os.system('gunzip ' + h)\n        homes = glob.glob(str(dataset_dir / 'IDEAL' / 'sensordata' / 'home*_electric-mains_electric-combined.csv'))\n\n        years = [2016, 2017, 2018]\n\n        for h in homes:\n            homeid = Path(h).name.split('_')[0]\n            home = pd.read_csv(h, names=['power'], index_col=0, header=None)\n            # drop the first row\n            home = home.drop(home.index[0])\n            # convert index to datetime\n            home.index = pd.to_datetime(home.index, format='%Y-%m-%d %H:%M:%S')\n            # convert from Wh to kHh\n            home = home / 1000\n            # resample to 1 hour\n            home = home.resample(rule='H', closed='left', label='right').mean() \n\n            for year in years:\n                ho = home[home.index.year == year]\n                if ho.shape[0] < 168: # skip empty\n                    continue\n                missing_frac = (ho['power'].isnull().sum() / ho.shape[0])\n                #print(f'{h} {year} missing frac = {missing_frac}')\n                if missing_frac <= 0.1:\n                    # linearly interpolate\n                    ho = ho.interpolate(method='linear', axis=0, limit=24*7, limit_direction='both')\n                    # Replace remaining nan with 0\n                    ho = ho.fillna(0)\n                    # save\n                    ho.to_csv( dataset_dir / 'IDEAL' / f'{homeid}_clean={year}.csv', header=True, index=True)\n            del home\n\n    ########################################################\n    print('LCL...')\n    ########################################################\n\n    all_buildings = {'MAC001964', 'MAC003533', 'MAC003527', 'MAC005461', 'MAC000339', 'MAC000767', 'MAC001706', 'MAC003238', 'MAC000065', 'MAC002146', 'MAC001945', 'MAC003968', 'MAC001764', 'MAC000710', 'MAC000712', 'MAC005444', 'MAC000699', 'MAC000677', 'MAC005101', 'MAC000790', 'MAC002841', 'MAC005496', 'MAC003511', 'MAC002290', 'MAC004665', 'MAC005116', 'MAC000774', 'MAC003366', 'MAC004672', 'MAC000702', 'MAC002227', 'MAC002143', 'MAC000051', 'MAC001953', 'MAC000633', 'MAC002141', 'MAC005494', 'MAC005129', 'MAC004906', 'MAC000451', 'MAC003915', 'MAC000761', 'MAC000470', 'MAC000783', 'MAC005441', 'MAC001954', 'MAC000354', 'MAC002121', 'MAC004631', 'MAC000467', 'MAC000779', 'MAC003807', 'MAC001576', 'MAC003526', 'MAC005094', 'MAC004667', 'MAC000722', 'MAC005464', 'MAC001566', 'MAC003360', 'MAC005499', 'MAC004659', 'MAC000765', 'MAC003548', 'MAC002872', 'MAC003198', 'MAC004997', 'MAC003185', 'MAC005567', 'MAC000044', 'MAC001740', 'MAC005469', 'MAC005089', 'MAC004664', 'MAC001826', 'MAC005107', 'MAC005438', 'MAC000141', 'MAC000106', 'MAC002292', 'MAC003298', 'MAC003516', 'MAC005500', 'MAC000690', 'MAC003540', 'MAC002247', 'MAC003517', 'MAC003315', 'MAC005467', 'MAC004919', 'MAC003977', 'MAC000706', 'MAC003338', 'MAC001651', 'MAC000725', 'MAC005113', 'MAC003852', 'MAC001814', 'MAC003848', 'MAC000402', 'MAC001963', 'MAC000384', 'MAC004662', 'MAC001694', 'MAC000383', 'MAC004905', 'MAC001547', 'MAC002219', 'MAC004634', 'MAC002242', 'MAC005133', 'MAC005430', 'MAC005443', 'MAC004923', 'MAC003510', 'MAC002876', 'MAC000788', 'MAC000755', 'MAC000766', 'MAC005439', 'MAC003782', 'MAC001614', 'MAC000751', 'MAC003268', 'MAC001602', 'MAC003895', 'MAC001682', 'MAC005505', 'MAC000082', 'MAC002300', 'MAC004635', 'MAC002124', 'MAC001856', 'MAC002232', 'MAC003321', 'MAC001758', 'MAC005112', 'MAC005456', 'MAC004991', 'MAC002153', 'MAC001949', 'MAC003256', 'MAC003823', 'MAC000713', 'MAC001970', 'MAC001979', 'MAC003530', 'MAC004914', 'MAC001754', 'MAC000328', 'MAC000794', 'MAC005097', 'MAC001645', 'MAC000707', 'MAC004653', 'MAC005501', 'MAC003557', 'MAC001947', 'MAC002838', 'MAC000401', 'MAC002847', 'MAC003954', 'MAC000679', 'MAC001655', 'MAC000701', 'MAC001975', 'MAC001958', 'MAC004983', 'MAC005561', 'MAC000048', 'MAC000693', 'MAC000772', 'MAC002875', 'MAC004663', 'MAC004936', 'MAC001778', 'MAC004994', 'MAC004650', 'MAC001755', 'MAC004993', 'MAC004928', 'MAC000640', 'MAC003553', 'MAC000695', 'MAC001737', 'MAC004646', 'MAC000683', 'MAC005462', 'MAC005007', 'MAC003542', 'MAC005003', 'MAC003951', 'MAC001743', 'MAC002866', 'MAC000700', 'MAC001536', 'MAC000680', 'MAC003247', 'MAC000786', 'MAC000757', 'MAC002160', 'MAC004916', 'MAC005485', 'MAC001966', 'MAC005447', 'MAC000666', 'MAC000344', 'MAC003827', 'MAC001944', 'MAC001823', 'MAC001766', 'MAC002281', 'MAC003897', 'MAC003379', 'MAC003211', 'MAC002222', 'MAC001667', 'MAC004637', 'MAC000793', 'MAC001760', 'MAC001715', 'MAC004643', 'MAC004973', 'MAC002240', 'MAC004652', 'MAC000046', 'MAC003334', 'MAC003769', 'MAC003973', 'MAC000773', 'MAC002867', 'MAC002842', 'MAC004927', 'MAC001960', 'MAC005450', 'MAC004992', 'MAC000754', 'MAC001950', 'MAC003546', 'MAC000692', 'MAC005555', 'MAC000676', 'MAC000787', 'MAC004989', 'MAC000406', 'MAC002268', 'MAC001948', 'MAC001806', 'MAC000768', 'MAC004907', 'MAC002873', 'MAC001739', 'MAC002151', 'MAC004999', 'MAC000408', 'MAC005104', 'MAC001830', 'MAC001735', 'MAC004638', 'MAC003532', 'MAC004998', 'MAC000641', 'MAC003259', 'MAC000776', 'MAC005460', 'MAC005123', 'MAC000703', 'MAC003170', 'MAC001959', 'MAC005004', 'MAC003512', 'MAC001825', 'MAC005562', 'MAC005454', 'MAC000665', 'MAC001768', 'MAC000464', 'MAC001773', 'MAC001738', 'MAC001718', 'MAC005001', 'MAC004644', 'MAC001751', 'MAC001693', 'MAC003783', 'MAC001556', 'MAC003522', 'MAC005431', 'MAC000763', 'MAC003257', 'MAC002238', 'MAC002852', 'MAC003892', 'MAC003919', 'MAC004912', 'MAC000681', 'MAC002230', 'MAC000109', 'MAC001554', 'MAC001777', 'MAC005502', 'MAC003788', 'MAC001761', 'MAC001965', 'MAC002277', 'MAC002850', 'MAC003869', 'MAC004904', 'MAC002125', 'MAC005504', 'MAC000675', 'MAC003507', 'MAC000708', 'MAC000014', 'MAC002123', 'MAC000716', 'MAC002870', 'MAC003347', 'MAC002139', 'MAC003508', 'MAC004647', 'MAC004913', 'MAC003515', 'MAC004666', 'MAC005092', 'MAC000447', 'MAC003865', 'MAC005119', 'MAC001750', 'MAC003178', 'MAC003535', 'MAC000760', 'MAC001744', 'MAC005475', 'MAC003358', 'MAC003816', 'MAC000461', 'MAC000052', 'MAC000369', 'MAC002346', 'MAC005096', 'MAC001769', 'MAC001542', 'MAC003372', 'MAC005437', 'MAC002225', 'MAC001973', 'MAC002138', 'MAC003771', 'MAC004908', 'MAC003501', 'MAC000739', 'MAC000762', 'MAC001956', 'MAC005471', 'MAC005491', 'MAC001650', 'MAC003916', 'MAC000678', 'MAC002860', 'MAC002264', 'MAC003808', 'MAC000682', 'MAC000689', 'MAC004654', 'MAC003829', 'MAC000352', 'MAC001978', 'MAC000782', 'MAC002849', 'MAC002159', 'MAC004673', 'MAC000698', 'MAC005125', 'MAC005476', 'MAC002324', 'MAC002162', 'MAC000336', 'MAC002878', 'MAC003514', 'MAC003552', 'MAC003337', 'MAC002236', 'MAC002883', 'MAC005459', 'MAC002336', 'MAC000758', 'MAC005098', 'MAC004911', 'MAC005497', 'MAC002846', 'MAC003538', 'MAC005131', 'MAC000764', 'MAC003975', 'MAC003333', 'MAC002856', 'MAC003165', 'MAC003201', 'MAC001746', 'MAC000342', 'MAC001564', 'MAC001770', 'MAC002880', 'MAC002163', 'MAC003272', 'MAC002265', 'MAC003331', 'MAC004656', 'MAC003556', 'MAC002882', 'MAC005117', 'MAC000694', 'MAC005455', 'MAC005457', 'MAC002334', 'MAC001612', 'MAC000771', 'MAC001943', 'MAC003221', 'MAC004931', 'MAC002280', 'MAC002862', 'MAC002877', 'MAC002851', 'MAC000792', 'MAC003269', 'MAC004630', 'MAC005484', 'MAC000017', 'MAC000653', 'MAC002854', 'MAC001855', 'MAC002155', 'MAC005005', 'MAC002840', 'MAC000784', 'MAC005103', 'MAC005132', 'MAC003551', 'MAC005481', 'MAC002246', 'MAC001955', 'MAC002157', 'MAC005472', 'MAC005466', 'MAC004915', 'MAC002136', 'MAC005453', 'MAC004934', 'MAC001636', 'MAC005487', 'MAC000795', 'MAC002344', 'MAC001700', 'MAC001849', 'MAC001974', 'MAC001968', 'MAC002127', 'MAC001765', 'MAC005128', 'MAC003180', 'MAC001586', 'MAC001941', 'MAC002150', 'MAC003286', 'MAC001686', 'MAC005451', 'MAC003277', 'MAC003519', 'MAC003504', 'MAC003914', 'MAC004922', 'MAC005118', 'MAC004660', 'MAC001680', 'MAC002130', 'MAC005120', 'MAC002144', 'MAC003862', 'MAC002149', 'MAC000366', 'MAC000421', 'MAC004651', 'MAC003521', 'MAC003509', 'MAC000064', 'MAC003899', 'MAC002129', 'MAC003960', 'MAC003982', 'MAC004987', 'MAC005126', 'MAC000107', 'MAC000672', 'MAC001772', 'MAC002858', 'MAC000635', 'MAC005433', 'MAC000456', 'MAC003988', 'MAC005446', 'MAC000770', 'MAC000075', 'MAC003520', 'MAC004626', 'MAC000778', 'MAC000418', 'MAC003202', 'MAC001972', 'MAC002152', 'MAC005090', 'MAC002226', 'MAC005440', 'MAC000711', 'MAC004925', 'MAC004978', 'MAC005088', 'MAC001767', 'MAC005442', 'MAC000686', 'MAC004929', 'MAC001707', 'MAC002133', 'MAC005503', 'MAC003262', 'MAC001749', 'MAC000738', 'MAC002120', 'MAC004975', 'MAC000709', 'MAC001851', 'MAC000714', 'MAC002291', 'MAC003518', 'MAC004649', 'MAC000071', 'MAC001736', 'MAC002853', 'MAC004671', 'MAC003308', 'MAC001741', 'MAC001977', 'MAC002145', 'MAC001734', 'MAC004933', 'MAC005109', 'MAC003285', 'MAC001840', 'MAC000392', 'MAC000684', 'MAC001853', 'MAC000728', 'MAC003911', 'MAC001763', 'MAC002843', 'MAC005436', 'MAC001961', 'MAC000005', 'MAC000696', 'MAC001626', 'MAC003245', 'MAC005479', 'MAC001642', 'MAC003534', 'MAC004645', 'MAC000769', 'MAC000015', 'MAC001762', 'MAC000781', 'MAC004629', 'MAC001660', 'MAC001742', 'MAC003890', 'MAC005130', 'MAC003175', 'MAC004974', 'MAC004976', 'MAC004627', 'MAC001833', 'MAC004924', 'MAC000697', 'MAC002137', 'MAC002128', 'MAC001704', 'MAC001946', 'MAC004636', 'MAC004918', 'MAC000777', 'MAC001980', 'MAC004642', 'MAC005115', 'MAC003967', 'MAC001610', 'MAC005099', 'MAC001967', 'MAC000687', 'MAC001688', 'MAC003984', 'MAC005000', 'MAC003506', 'MAC002217', 'MAC001747', 'MAC002857', 'MAC004632', 'MAC001771', 'MAC000705', 'MAC000685', 'MAC005480', 'MAC000780', 'MAC001835', 'MAC000139', 'MAC005452', 'MAC003547', 'MAC004909', 'MAC000031', 'MAC004984', 'MAC001748', 'MAC002871', 'MAC003537', 'MAC000688', 'MAC000433', 'MAC005095', 'MAC004658', 'MAC002865', 'MAC003989', 'MAC002135', 'MAC001658', 'MAC002863', 'MAC003543', 'MAC005468', 'MAC001745', 'MAC004920', 'MAC000759', 'MAC005490', 'MAC000124', 'MAC001596', 'MAC004981', 'MAC005566', 'MAC001733', 'MAC001753', 'MAC004628', 'MAC003365', 'MAC004986', 'MAC004996', 'MAC001940', 'MAC005483', 'MAC005425', 'MAC003947', 'MAC000303', 'MAC005114', 'MAC001597', 'MAC001712', 'MAC001559', 'MAC002142', 'MAC003554', 'MAC001731', 'MAC005486', 'MAC002243', 'MAC005108', 'MAC005435', 'MAC001732', 'MAC001752', 'MAC001756', 'MAC002318', 'MAC001847', 'MAC005087', 'MAC005428', 'MAC004995', 'MAC001538', 'MAC005105', 'MAC000076', 'MAC002117', 'MAC003265', 'MAC005458', 'MAC000704', 'MAC004648', 'MAC004930', 'MAC002161', 'MAC005463', 'MAC003820', 'MAC004980', 'MAC004985', 'MAC005478', 'MAC000691', 'MAC001962', 'MAC005002', 'MAC001759', 'MAC005100', 'MAC003529', 'MAC000465', 'MAC003274', 'MAC005493', 'MAC000673', 'MAC001590', 'MAC003549', 'MAC000719', 'MAC001971', 'MAC001730', 'MAC002844', 'MAC002859', 'MAC001757', 'MAC002158', 'MAC003500', 'MAC003196', 'MAC000146', 'MAC004982', 'MAC000439', 'MAC003903', 'MAC004935', 'MAC000088', 'MAC000395', 'MAC005426'}\n    \n    (dataset_dir / 'LCL').mkdir(parents=True, exist_ok=True)\n    download_lcl_data(dataset_dir / 'LCL')\n    all_LCL = glob.glob(str(dataset_dir / 'LCL' / 'Small LCL Data' / 'LCL-June2015v2*.csv'))\n    random.shuffle(all_LCL)\n    num_bldgs = 0\n    years = [2012, 2013]\n    for lcl_file in all_LCL:\n        df_ = pd.read_csv(lcl_file)\n        unique_bldgs = df_['LCLid'].unique()\n        # only keep buildings that are in all_buildings\n        unique_bldgs = all_buildings.intersection(set(unique_bldgs))\n        # remove buildings from all_buildings that are in unique_bldgs\n        all_buildings = all_buildings.difference(unique_bldgs)\n\n        for ub in unique_bldgs:\n            df = df_[df_.LCLid == ub].copy()\n            df['DateTime'] = pd.to_datetime(df['DateTime'])\n            # Set timestamp as index\n            df = df.set_index('DateTime')\n            df = df[~df.index.duplicated(keep='first')]\n            df = df.asfreq('30min')\n            df = df.rename(columns={'KWH/hh (per half hour) ': 'power'})\n            # only keep power column\n            df = df[['power']]\n            df = df.replace('Null', np.nan)\n            df = df.astype('float32')\n            df = df.resample(rule='H', closed='left', label='right').mean()\n             \n            for year in years:\n                dfy = df[df.index.year == year]\n                if dfy.shape[0] < 168:\n                    continue\n                missing_frac = dfy['power'].isnull().sum() / dfy.shape[0]\n                if missing_frac <= 0.1:\n                    dfy = dfy.interpolate(method='linear', axis=0, limit=24*7, limit_direction='both')\n                    dfy = dfy.fillna(0.)\n                    dfy.to_csv(dataset_dir / 'LCL' / f'{ub}_clean={year}.csv')\n                    num_bldgs += 1\n            if num_bldgs == 713:\n                print(f'num bldgs: {num_bldgs}') \n                break\n        if num_bldgs == 713:\n            break", "if __name__ == '__main__':\n    dataset_dir = Path(os.environ.get('BUILDINGS_BENCH', ''))\n\n    print('WARNING: This script will try to automatically download and process the datasets in BuildingsBench.'\n          ' Please be sure to have followed the instructions for downloading the data from the following datasets, '\n          'which are not able to be automatically downloaded: ')\n    print('>>> BDG-2')\n    download_bdg2_data(dataset_dir / 'BDG-2')\n    print('>>> Sceaux')\n    download_sceaux_data(dataset_dir / 'Sceaux')\n    print('>>> Borealis')\n    download_borealis_data(dataset_dir / 'Borealis')    \n\n    ########################################################\n    print('Electricity...')\n    ########################################################       \n    (dataset_dir / 'Electricity').mkdir(parents=True, exist_ok=True)\n    download_electricity_data(dataset_dir / 'Electricity')\n\n    df = pd.read_csv(dataset_dir / 'Electricity' / 'LD2011_2014.txt', sep=';', index_col=0)\n    df.index = pd.to_datetime(df.index, format='%Y-%m-%d %H:%M:%S')\n    df = df.asfreq('15min')\n    df = df.sort_index()\n\n    # Set the type of each column to float\n    # Convert commas in each string to a period\n    for col in df.columns:\n        # if column entries are type str\n        if df[col].dtype == 'object' and col != 'index':\n            df[col] = df[col].apply(lambda x: float(x.replace(',', '.') if type(x) is str else x))\n\n    df = df.astype('float32')\n\n    # Resample 15 min -> hourly\n    df = df.resample(rule='H', closed='left', label='right').mean()\n\n    # Group buildings by year\n    years = [2011, 2012, 2013, 2014]\n    for year in years:\n        bldgs = df[df.index.year == year]\n        # Replace zeros with nan for this dataset, which uses zeros to indicate missing values\n        bldgs = bldgs.replace(0, np.nan)\n        # Drop buildings with more than 10% of missing values\n        bldgs = bldgs.dropna(thresh=len(bldgs)*0.9, axis=1)\n        # linearly interpolate nan values\n        bldgs = bldgs.interpolate(method='linear', axis=0, limit=24*7, limit_direction='both')\n        # Replace any remaining nan values with zeros (> 1 week)\n        bldgs = bldgs.fillna(0)\n        # Name the index column 'timestamp'\n        bldgs.index.name = 'timestamp'\n        bldgs = bldgs.asfreq('1H')\n        # Save to csv\n        bldgs.to_csv(dataset_dir / 'Electricity' / f'LD2011_2014_clean={year}.csv', index=True, header=True)\n\n    ########################################################\n    print('BDG-2...')\n    ########################################################\n\n    (dataset_dir / 'BDG-2').mkdir(parents=True, exist_ok=True)\n\n    try:\n        df = pd.read_csv(dataset_dir / 'electricity_cleaned.csv', sep=',')\n         # set timestamp as index\n        df = df.set_index('timestamp')\n        df.index = pd.to_datetime(df.index, format='%Y-%m-%d %H:%M:%S')\n\n        sites = ['Bear_', 'Fox_', 'Panther_', 'Rat_']\n        years = [2016, 2017]\n        for s in sites:\n            # regex filter for Panther\n            df_site = df.filter(regex=s)\n        \n            for year in years:\n                bldgs = df_site[df_site.index.year == year]\n                # Drop columns with more than 10% of missing values\n                bldgs = bldgs.dropna(thresh=len(bldgs)*0.9, axis=1)\n                # linearly interpolate nan values (1 week limit)\n                bldgs = bldgs.interpolate(method='linear', axis=0, limit=24*7, limit_direction='both')\n                # Replace any remaining nan values with zeros (> 1 week)\n                bldgs = bldgs.fillna(0)\n                sit = s.replace('_', '')\n                bldgs.to_csv(dataset_dir / 'BDG-2' / f'{sit}_clean={year}.csv', header=True, index=True)\n    except:\n        download_bdg2_data(dataset_dir / 'BDG-2')\n        print('skipping BDG-2...')\n\n\n    ########################################################\n    print('Sceaux...')\n    ########################################################\n\n    try:\n        (dataset_dir / 'Sceaux').mkdir(parents=True, exist_ok=True)\n        house = pd.read_csv(dataset_dir / 'Sceaux' / 'household_power_consumption.txt', sep=';', header=0)\n\n        # Combine Date and Time columns\n        house['timestamp'] = house['Date'] + ' ' + house['Time']\n        # Set timestamp as index\n        house = house.set_index('timestamp')\n        # Convert index to datetime\n        house.index = pd.to_datetime(house.index, format='%d/%m/%Y %H:%M:%S')\n        # Drop Date and Time columns\n        house = house.drop(['Date', 'Time'], axis=1)\n\n        # Replace ? values with NaN\n        house = house.replace('?', np.nan)\n        house = house.astype('float32')\n        house = house.asfreq('1min')\n        house = house.sort_index()\n        # resample to hourly data, ignoring nan values\n        house = house.resample(rule='H', closed='left', label='right').mean()\n        years = [2007, 2008, 2009, 2010]\n        for year in years:\n            h = house[house.index.year == year]\n            # Linearly interpolate missing values\n            h = h.interpolate(method='linear', axis=0, limit=24*7, limit_direction='both')\n            # Fill remaining missing values with zeros\n            h = h.fillna(0)\n            # Keep Global_active_power column\n            h = h[['Global_active_power']]\n            # Save to csv\n            h.to_csv(dataset_dir / 'Sceaux' / f'Sceaux_clean={year}.csv', header=True, index=True)\n    except:\n        download_sceaux_data(dataset_dir / 'Sceaux')\n        print('skipping Sceaux...')\n\n    ########################################################\n    print('SMART...')\n    ########################################################\n    \n    (dataset_dir / 'SMART').mkdir(parents=True, exist_ok=True)\n    download_smart_data(dataset_dir / 'SMART')\n    homes = [('HomeB', 'meter1'), ('HomeC', 'meter1'), ('HomeD', 'meter1'), ('HomeF', 'meter2'), ('HomeG', 'meter1'), ('HomeH', 'meter1')]\n    years = [2014, 2015, 2016]\n\n    power_column = 'use [kW]'\n\n    # Load data\n    for idx in range(len(homes)):\n        home = homes[idx][0]\n        meter = homes[idx][1]\n        for year in years:\n            try:\n                # join on timestamp index\n                house_ = pd.read_csv(dataset_dir / 'SMART' / f'{home}/{year}/{home}-{meter}_{year}.csv')\n            except:\n                continue\n            # Rename Date & Time to timestamp\n            house_ = house_.rename(columns={'Date & Time': 'timestamp'})\n            # Set timestamp as index\n            house_ = house_.set_index('timestamp')\n            # Convert index to datetime\n            house_.index = pd.to_datetime(house_.index, format='%Y-%m-%d %H:%M:%S')\n            # Replace missing values with NaN\n            house_ = house_.replace('?', np.nan)\n            # Resample to hourly\n            house_ = house_.resample(rule='H', closed='left', label='right').mean()\n\n            # only keep use [kW] column\n            if 'use [kW]' in house_.columns:\n                house_ = house_[['use [kW]']]\n                power_column = 'use [kW]'\n            if 'Usage [kW]' in house_.columns:\n                house_ = house_[['Usage [kW]']]\n                power_column = 'Usage [kW]'\n\n            house_ = house_.rename(columns={power_column: 'power'})\n            \n            missing_frac = house_['power'].isnull().sum() / house_.shape[0]\n            # Calculate fraction of missing values\n            #print(f'Fraction of NaN values in {home}-{meter} {year}: {missing_frac}')\n            # Calculate fraction of 0's\n            zeros_frac = (house_['power'] == 0.0).sum() / house_.shape[0]\n            #print(f'Fraction of 0 values in {home}-{meter} {year}: {zeros_frac}')\n\n            if missing_frac <= 0.1 and zeros_frac <= 0.1:\n                # Linearly interpolate missing values\n                house_ = house_.interpolate(method='linear', axis=0, limit=24*7, limit_direction='both') \n                # Fill remaining missing values with zeros\n                house_ = house_.fillna(0)\n                house_.to_csv(dataset_dir / 'SMART' / f'{home}_clean={year}.csv', header=True, index=True)\n\n    ########################################################\n    print('Borealis...')\n    ########################################################\n\n    (dataset_dir / 'Borealis').mkdir(parents=True, exist_ok=True)\n\n    try:\n        homes = glob.glob(str(dataset_dir / 'Borealis' / '6secs_load_measurement_dataset' / '*.csv'))\n        years = [2010, 2011, 2012]\n   \n        # Load data\n        for home in homes:\n            house_ = pd.read_csv(dataset_dir / 'Borealis'  / '6secs_load_measurement_dataset' / f'{home}.csv')\n\n            # Set timestamp as index\n            house_ = house_.set_index('timestamp')\n            # drop row 1, which has 0 value\n            house_ = house_.drop(house_.index[0])\n            # Convert index to datetime\n            house_.index = pd.to_datetime(house_.index, format='%Y-%m-%d %H:%M:%S')\n            # only keep power column\n            house_ = house_[['power']]\n            # Resample to hourly\n            house_ = house_.resample(rule='H', closed='left', label='right').mean()\n            # convert from Wh to kHh\n            house_ = house_ / 1000\n\n            for year in years:\n                h = house_[house_.index.year == year]\n                # count number of rows\n                if h.shape[0] < 168: # if < 1 week, throw out building-year\n                    continue\n                missing_frac = h[\"power\"].isnull().sum() / h.shape[0]\n\n                if missing_frac <= 0.1:\n                    # Linearly interpolate\n                    h = h.interpolate(method='linear', axis=0, limit=24*7, limit_direction='both')\n                    # Fill missing values with zeros\n                    h = h.fillna(0)\n                    # Save to csv\n                    h.to_csv(dataset_dir / 'Borealis' / f'{home}_clean={year}.csv', header=True, index=True)\n\n    except:\n        download_borealis_data(dataset_dir / 'Borealis')\n        print('skipping Borealis...')\n\n  \n    ########################################################\n    print('IDEAL...')\n    ########################################################\n    (dataset_dir / 'IDEAL').mkdir(parents=True, exist_ok=True)\n    \n    print('WARNING: the raw IDEAL dataset requires over 140GB of storage. Skip?')\n    skip = input('Skip IDEAL? (y/n): ')\n    if skip == 'y':\n        print('skipping IDEAL...')\n    else:\n        print('this may take a while...')\n        download_ideal_data(dataset_dir / 'IDEAL')\n        homes_gz = glob.glob(str(dataset_dir / 'IDEAL' / 'sensordata' / 'home*_electric-mains_electric-combined.csv.gz'))\n        # gunzip each file\n        for h in homes_gz:\n            os.system('gunzip ' + h)\n        homes = glob.glob(str(dataset_dir / 'IDEAL' / 'sensordata' / 'home*_electric-mains_electric-combined.csv'))\n\n        years = [2016, 2017, 2018]\n\n        for h in homes:\n            homeid = Path(h).name.split('_')[0]\n            home = pd.read_csv(h, names=['power'], index_col=0, header=None)\n            # drop the first row\n            home = home.drop(home.index[0])\n            # convert index to datetime\n            home.index = pd.to_datetime(home.index, format='%Y-%m-%d %H:%M:%S')\n            # convert from Wh to kHh\n            home = home / 1000\n            # resample to 1 hour\n            home = home.resample(rule='H', closed='left', label='right').mean() \n\n            for year in years:\n                ho = home[home.index.year == year]\n                if ho.shape[0] < 168: # skip empty\n                    continue\n                missing_frac = (ho['power'].isnull().sum() / ho.shape[0])\n                #print(f'{h} {year} missing frac = {missing_frac}')\n                if missing_frac <= 0.1:\n                    # linearly interpolate\n                    ho = ho.interpolate(method='linear', axis=0, limit=24*7, limit_direction='both')\n                    # Replace remaining nan with 0\n                    ho = ho.fillna(0)\n                    # save\n                    ho.to_csv( dataset_dir / 'IDEAL' / f'{homeid}_clean={year}.csv', header=True, index=True)\n            del home\n\n    ########################################################\n    print('LCL...')\n    ########################################################\n\n    all_buildings = {'MAC001964', 'MAC003533', 'MAC003527', 'MAC005461', 'MAC000339', 'MAC000767', 'MAC001706', 'MAC003238', 'MAC000065', 'MAC002146', 'MAC001945', 'MAC003968', 'MAC001764', 'MAC000710', 'MAC000712', 'MAC005444', 'MAC000699', 'MAC000677', 'MAC005101', 'MAC000790', 'MAC002841', 'MAC005496', 'MAC003511', 'MAC002290', 'MAC004665', 'MAC005116', 'MAC000774', 'MAC003366', 'MAC004672', 'MAC000702', 'MAC002227', 'MAC002143', 'MAC000051', 'MAC001953', 'MAC000633', 'MAC002141', 'MAC005494', 'MAC005129', 'MAC004906', 'MAC000451', 'MAC003915', 'MAC000761', 'MAC000470', 'MAC000783', 'MAC005441', 'MAC001954', 'MAC000354', 'MAC002121', 'MAC004631', 'MAC000467', 'MAC000779', 'MAC003807', 'MAC001576', 'MAC003526', 'MAC005094', 'MAC004667', 'MAC000722', 'MAC005464', 'MAC001566', 'MAC003360', 'MAC005499', 'MAC004659', 'MAC000765', 'MAC003548', 'MAC002872', 'MAC003198', 'MAC004997', 'MAC003185', 'MAC005567', 'MAC000044', 'MAC001740', 'MAC005469', 'MAC005089', 'MAC004664', 'MAC001826', 'MAC005107', 'MAC005438', 'MAC000141', 'MAC000106', 'MAC002292', 'MAC003298', 'MAC003516', 'MAC005500', 'MAC000690', 'MAC003540', 'MAC002247', 'MAC003517', 'MAC003315', 'MAC005467', 'MAC004919', 'MAC003977', 'MAC000706', 'MAC003338', 'MAC001651', 'MAC000725', 'MAC005113', 'MAC003852', 'MAC001814', 'MAC003848', 'MAC000402', 'MAC001963', 'MAC000384', 'MAC004662', 'MAC001694', 'MAC000383', 'MAC004905', 'MAC001547', 'MAC002219', 'MAC004634', 'MAC002242', 'MAC005133', 'MAC005430', 'MAC005443', 'MAC004923', 'MAC003510', 'MAC002876', 'MAC000788', 'MAC000755', 'MAC000766', 'MAC005439', 'MAC003782', 'MAC001614', 'MAC000751', 'MAC003268', 'MAC001602', 'MAC003895', 'MAC001682', 'MAC005505', 'MAC000082', 'MAC002300', 'MAC004635', 'MAC002124', 'MAC001856', 'MAC002232', 'MAC003321', 'MAC001758', 'MAC005112', 'MAC005456', 'MAC004991', 'MAC002153', 'MAC001949', 'MAC003256', 'MAC003823', 'MAC000713', 'MAC001970', 'MAC001979', 'MAC003530', 'MAC004914', 'MAC001754', 'MAC000328', 'MAC000794', 'MAC005097', 'MAC001645', 'MAC000707', 'MAC004653', 'MAC005501', 'MAC003557', 'MAC001947', 'MAC002838', 'MAC000401', 'MAC002847', 'MAC003954', 'MAC000679', 'MAC001655', 'MAC000701', 'MAC001975', 'MAC001958', 'MAC004983', 'MAC005561', 'MAC000048', 'MAC000693', 'MAC000772', 'MAC002875', 'MAC004663', 'MAC004936', 'MAC001778', 'MAC004994', 'MAC004650', 'MAC001755', 'MAC004993', 'MAC004928', 'MAC000640', 'MAC003553', 'MAC000695', 'MAC001737', 'MAC004646', 'MAC000683', 'MAC005462', 'MAC005007', 'MAC003542', 'MAC005003', 'MAC003951', 'MAC001743', 'MAC002866', 'MAC000700', 'MAC001536', 'MAC000680', 'MAC003247', 'MAC000786', 'MAC000757', 'MAC002160', 'MAC004916', 'MAC005485', 'MAC001966', 'MAC005447', 'MAC000666', 'MAC000344', 'MAC003827', 'MAC001944', 'MAC001823', 'MAC001766', 'MAC002281', 'MAC003897', 'MAC003379', 'MAC003211', 'MAC002222', 'MAC001667', 'MAC004637', 'MAC000793', 'MAC001760', 'MAC001715', 'MAC004643', 'MAC004973', 'MAC002240', 'MAC004652', 'MAC000046', 'MAC003334', 'MAC003769', 'MAC003973', 'MAC000773', 'MAC002867', 'MAC002842', 'MAC004927', 'MAC001960', 'MAC005450', 'MAC004992', 'MAC000754', 'MAC001950', 'MAC003546', 'MAC000692', 'MAC005555', 'MAC000676', 'MAC000787', 'MAC004989', 'MAC000406', 'MAC002268', 'MAC001948', 'MAC001806', 'MAC000768', 'MAC004907', 'MAC002873', 'MAC001739', 'MAC002151', 'MAC004999', 'MAC000408', 'MAC005104', 'MAC001830', 'MAC001735', 'MAC004638', 'MAC003532', 'MAC004998', 'MAC000641', 'MAC003259', 'MAC000776', 'MAC005460', 'MAC005123', 'MAC000703', 'MAC003170', 'MAC001959', 'MAC005004', 'MAC003512', 'MAC001825', 'MAC005562', 'MAC005454', 'MAC000665', 'MAC001768', 'MAC000464', 'MAC001773', 'MAC001738', 'MAC001718', 'MAC005001', 'MAC004644', 'MAC001751', 'MAC001693', 'MAC003783', 'MAC001556', 'MAC003522', 'MAC005431', 'MAC000763', 'MAC003257', 'MAC002238', 'MAC002852', 'MAC003892', 'MAC003919', 'MAC004912', 'MAC000681', 'MAC002230', 'MAC000109', 'MAC001554', 'MAC001777', 'MAC005502', 'MAC003788', 'MAC001761', 'MAC001965', 'MAC002277', 'MAC002850', 'MAC003869', 'MAC004904', 'MAC002125', 'MAC005504', 'MAC000675', 'MAC003507', 'MAC000708', 'MAC000014', 'MAC002123', 'MAC000716', 'MAC002870', 'MAC003347', 'MAC002139', 'MAC003508', 'MAC004647', 'MAC004913', 'MAC003515', 'MAC004666', 'MAC005092', 'MAC000447', 'MAC003865', 'MAC005119', 'MAC001750', 'MAC003178', 'MAC003535', 'MAC000760', 'MAC001744', 'MAC005475', 'MAC003358', 'MAC003816', 'MAC000461', 'MAC000052', 'MAC000369', 'MAC002346', 'MAC005096', 'MAC001769', 'MAC001542', 'MAC003372', 'MAC005437', 'MAC002225', 'MAC001973', 'MAC002138', 'MAC003771', 'MAC004908', 'MAC003501', 'MAC000739', 'MAC000762', 'MAC001956', 'MAC005471', 'MAC005491', 'MAC001650', 'MAC003916', 'MAC000678', 'MAC002860', 'MAC002264', 'MAC003808', 'MAC000682', 'MAC000689', 'MAC004654', 'MAC003829', 'MAC000352', 'MAC001978', 'MAC000782', 'MAC002849', 'MAC002159', 'MAC004673', 'MAC000698', 'MAC005125', 'MAC005476', 'MAC002324', 'MAC002162', 'MAC000336', 'MAC002878', 'MAC003514', 'MAC003552', 'MAC003337', 'MAC002236', 'MAC002883', 'MAC005459', 'MAC002336', 'MAC000758', 'MAC005098', 'MAC004911', 'MAC005497', 'MAC002846', 'MAC003538', 'MAC005131', 'MAC000764', 'MAC003975', 'MAC003333', 'MAC002856', 'MAC003165', 'MAC003201', 'MAC001746', 'MAC000342', 'MAC001564', 'MAC001770', 'MAC002880', 'MAC002163', 'MAC003272', 'MAC002265', 'MAC003331', 'MAC004656', 'MAC003556', 'MAC002882', 'MAC005117', 'MAC000694', 'MAC005455', 'MAC005457', 'MAC002334', 'MAC001612', 'MAC000771', 'MAC001943', 'MAC003221', 'MAC004931', 'MAC002280', 'MAC002862', 'MAC002877', 'MAC002851', 'MAC000792', 'MAC003269', 'MAC004630', 'MAC005484', 'MAC000017', 'MAC000653', 'MAC002854', 'MAC001855', 'MAC002155', 'MAC005005', 'MAC002840', 'MAC000784', 'MAC005103', 'MAC005132', 'MAC003551', 'MAC005481', 'MAC002246', 'MAC001955', 'MAC002157', 'MAC005472', 'MAC005466', 'MAC004915', 'MAC002136', 'MAC005453', 'MAC004934', 'MAC001636', 'MAC005487', 'MAC000795', 'MAC002344', 'MAC001700', 'MAC001849', 'MAC001974', 'MAC001968', 'MAC002127', 'MAC001765', 'MAC005128', 'MAC003180', 'MAC001586', 'MAC001941', 'MAC002150', 'MAC003286', 'MAC001686', 'MAC005451', 'MAC003277', 'MAC003519', 'MAC003504', 'MAC003914', 'MAC004922', 'MAC005118', 'MAC004660', 'MAC001680', 'MAC002130', 'MAC005120', 'MAC002144', 'MAC003862', 'MAC002149', 'MAC000366', 'MAC000421', 'MAC004651', 'MAC003521', 'MAC003509', 'MAC000064', 'MAC003899', 'MAC002129', 'MAC003960', 'MAC003982', 'MAC004987', 'MAC005126', 'MAC000107', 'MAC000672', 'MAC001772', 'MAC002858', 'MAC000635', 'MAC005433', 'MAC000456', 'MAC003988', 'MAC005446', 'MAC000770', 'MAC000075', 'MAC003520', 'MAC004626', 'MAC000778', 'MAC000418', 'MAC003202', 'MAC001972', 'MAC002152', 'MAC005090', 'MAC002226', 'MAC005440', 'MAC000711', 'MAC004925', 'MAC004978', 'MAC005088', 'MAC001767', 'MAC005442', 'MAC000686', 'MAC004929', 'MAC001707', 'MAC002133', 'MAC005503', 'MAC003262', 'MAC001749', 'MAC000738', 'MAC002120', 'MAC004975', 'MAC000709', 'MAC001851', 'MAC000714', 'MAC002291', 'MAC003518', 'MAC004649', 'MAC000071', 'MAC001736', 'MAC002853', 'MAC004671', 'MAC003308', 'MAC001741', 'MAC001977', 'MAC002145', 'MAC001734', 'MAC004933', 'MAC005109', 'MAC003285', 'MAC001840', 'MAC000392', 'MAC000684', 'MAC001853', 'MAC000728', 'MAC003911', 'MAC001763', 'MAC002843', 'MAC005436', 'MAC001961', 'MAC000005', 'MAC000696', 'MAC001626', 'MAC003245', 'MAC005479', 'MAC001642', 'MAC003534', 'MAC004645', 'MAC000769', 'MAC000015', 'MAC001762', 'MAC000781', 'MAC004629', 'MAC001660', 'MAC001742', 'MAC003890', 'MAC005130', 'MAC003175', 'MAC004974', 'MAC004976', 'MAC004627', 'MAC001833', 'MAC004924', 'MAC000697', 'MAC002137', 'MAC002128', 'MAC001704', 'MAC001946', 'MAC004636', 'MAC004918', 'MAC000777', 'MAC001980', 'MAC004642', 'MAC005115', 'MAC003967', 'MAC001610', 'MAC005099', 'MAC001967', 'MAC000687', 'MAC001688', 'MAC003984', 'MAC005000', 'MAC003506', 'MAC002217', 'MAC001747', 'MAC002857', 'MAC004632', 'MAC001771', 'MAC000705', 'MAC000685', 'MAC005480', 'MAC000780', 'MAC001835', 'MAC000139', 'MAC005452', 'MAC003547', 'MAC004909', 'MAC000031', 'MAC004984', 'MAC001748', 'MAC002871', 'MAC003537', 'MAC000688', 'MAC000433', 'MAC005095', 'MAC004658', 'MAC002865', 'MAC003989', 'MAC002135', 'MAC001658', 'MAC002863', 'MAC003543', 'MAC005468', 'MAC001745', 'MAC004920', 'MAC000759', 'MAC005490', 'MAC000124', 'MAC001596', 'MAC004981', 'MAC005566', 'MAC001733', 'MAC001753', 'MAC004628', 'MAC003365', 'MAC004986', 'MAC004996', 'MAC001940', 'MAC005483', 'MAC005425', 'MAC003947', 'MAC000303', 'MAC005114', 'MAC001597', 'MAC001712', 'MAC001559', 'MAC002142', 'MAC003554', 'MAC001731', 'MAC005486', 'MAC002243', 'MAC005108', 'MAC005435', 'MAC001732', 'MAC001752', 'MAC001756', 'MAC002318', 'MAC001847', 'MAC005087', 'MAC005428', 'MAC004995', 'MAC001538', 'MAC005105', 'MAC000076', 'MAC002117', 'MAC003265', 'MAC005458', 'MAC000704', 'MAC004648', 'MAC004930', 'MAC002161', 'MAC005463', 'MAC003820', 'MAC004980', 'MAC004985', 'MAC005478', 'MAC000691', 'MAC001962', 'MAC005002', 'MAC001759', 'MAC005100', 'MAC003529', 'MAC000465', 'MAC003274', 'MAC005493', 'MAC000673', 'MAC001590', 'MAC003549', 'MAC000719', 'MAC001971', 'MAC001730', 'MAC002844', 'MAC002859', 'MAC001757', 'MAC002158', 'MAC003500', 'MAC003196', 'MAC000146', 'MAC004982', 'MAC000439', 'MAC003903', 'MAC004935', 'MAC000088', 'MAC000395', 'MAC005426'}\n    \n    (dataset_dir / 'LCL').mkdir(parents=True, exist_ok=True)\n    download_lcl_data(dataset_dir / 'LCL')\n    all_LCL = glob.glob(str(dataset_dir / 'LCL' / 'Small LCL Data' / 'LCL-June2015v2*.csv'))\n    random.shuffle(all_LCL)\n    num_bldgs = 0\n    years = [2012, 2013]\n    for lcl_file in all_LCL:\n        df_ = pd.read_csv(lcl_file)\n        unique_bldgs = df_['LCLid'].unique()\n        # only keep buildings that are in all_buildings\n        unique_bldgs = all_buildings.intersection(set(unique_bldgs))\n        # remove buildings from all_buildings that are in unique_bldgs\n        all_buildings = all_buildings.difference(unique_bldgs)\n\n        for ub in unique_bldgs:\n            df = df_[df_.LCLid == ub].copy()\n            df['DateTime'] = pd.to_datetime(df['DateTime'])\n            # Set timestamp as index\n            df = df.set_index('DateTime')\n            df = df[~df.index.duplicated(keep='first')]\n            df = df.asfreq('30min')\n            df = df.rename(columns={'KWH/hh (per half hour) ': 'power'})\n            # only keep power column\n            df = df[['power']]\n            df = df.replace('Null', np.nan)\n            df = df.astype('float32')\n            df = df.resample(rule='H', closed='left', label='right').mean()\n             \n            for year in years:\n                dfy = df[df.index.year == year]\n                if dfy.shape[0] < 168:\n                    continue\n                missing_frac = dfy['power'].isnull().sum() / dfy.shape[0]\n                if missing_frac <= 0.1:\n                    dfy = dfy.interpolate(method='linear', axis=0, limit=24*7, limit_direction='both')\n                    dfy = dfy.fillna(0.)\n                    dfy.to_csv(dataset_dir / 'LCL' / f'{ub}_clean={year}.csv')\n                    num_bldgs += 1\n            if num_bldgs == 713:\n                print(f'num bldgs: {num_bldgs}') \n                break\n        if num_bldgs == 713:\n            break", ""]}
{"filename": "scripts/process_raw_data/create_buildings900K.py", "chunked_list": ["import argparse\ntry:\n    import pyspark\nexcept:\n    print('please install pyspark with `pip install pyspark`')\n    exit(1)\n\nfrom pyspark import SparkContext, SparkConf\nfrom pyspark.sql import SparkSession\nimport pyspark.sql.functions as F", "from pyspark.sql import SparkSession\nimport pyspark.sql.functions as F\nimport os\nimport glob\n\nconf = SparkConf().setMaster(\"local[*]\").setAppName(\"pytorch\")\nconf.set(\"spark.executor.memory\", \"2g\")\nconf.set(\"spark.driver.memory\", \"64G\")\nconf.set(\"spark.executor.cores\", \"96\")\nconf.set(\"spark.serializer\", \"org.apache.spark.serializer.KryoSerializer\")", "conf.set(\"spark.executor.cores\", \"96\")\nconf.set(\"spark.serializer\", \"org.apache.spark.serializer.KryoSerializer\")\nconf.set(\"spark.default.parallelism\", \"96\")\nconf.set(\"spark.local.dir\", \"/tmp/scratch/tmp\")\nsc =  SparkContext.getOrCreate(conf=conf)\nspark = SparkSession(sc)\n# Set the environment variable SPARK_LOCAL_DIRS\nos.environ['SPARK_LOCAL_DIRS'] = '/tmp/scratch/tmp'\n# Set the environment variable LOCAL_DIRS\nos.environ['SPARK_LOCAL_DIRS'] = '/tmp/scratch/tmp'", "# Set the environment variable LOCAL_DIRS\nos.environ['SPARK_LOCAL_DIRS'] = '/tmp/scratch/tmp'\n\n\ndef main(args):\n\n    eulp_dir = os.path.join(args.eulp_dir, 'end-use-load-profiles-for-us-building-stock', '2021')\n    output_dir = args.output_dir\n\n    census_regions = ['by_puma_midwest', 'by_puma_northeast', 'by_puma_south', 'by_puma_west'] \n    years = ['tmy3', 'amy2018']\n    \n    for cr in census_regions:\n\n        for year in years:\n\n            for res_or_com in ['resstock', 'comstock']:\n                \n                list_of_pumas = glob.glob(os.path.join(eulp_dir,\n                                                       f'{res_or_com}_{year}_release_1',\n                                                       'timeseries_individual_buildings',\n                                                       cr,\n                                                       'upgrade=0',\n                                                       'puma=*'))\n                target_path = os.path.join(output_dir, 'end-use-load-profiles-for-us-building-stock' , '2021',\n                                            f'{res_or_com}_{year}_release_1',\n                                            'timeseries_individual_buildings',\n                                            cr,\n                                            'upgrade=0')\n                \n                for puma_id in list_of_pumas:\n                    print(f'processing {puma_id} to store buildings as a parquet file...')\n\n                    target_puma_path = os.path.join(target_path, os.path.basename(puma_id))\n                    if not os.path.isdir(target_puma_path):\n                        os.makedirs(target_puma_path)\n                    else:\n                        print(f'{target_puma_path} already exists. Skipping...')\n                        continue\n\n                    df = spark.read.parquet(puma_id)\n\n                    # Just the datapoints we need  \n                    df = df.select(['`out.site_energy.total.energy_consumption`', 'timestamp', 'bldg_id'])\n\n                    # Average 15 min out.site_energy.total.energy_consumption by hour for each bldg_id\n                    df = df.withColumn('timestamp', F.date_trunc('hour', df['timestamp']))\n                    df = df.groupBy('timestamp', 'bldg_id').agg(F.avg('`out.site_energy.total.energy_consumption`').alias('total_energy_consumption'))\n\n                    # Group by timestamp and create a new column for each bldg_id\n                    df = df.groupBy('timestamp').pivot('bldg_id').agg(F.first('total_energy_consumption'))\n                    # fill na with 0\n                    df = df.fillna(0)\n\n                    df = df.repartition(1)\n                    # Save as dataset with parquet files\n                    df.write.option('header', True).mode('overwrite').parquet(target_puma_path)", "\n\nif __name__ == '__main__':\n    args = argparse.ArgumentParser()\n\n    args.add_argument('--eulp_dir', type=str, required=True,\n                        help='Path to raw EULP data.')\n    args.add_argument('--output_dir', type=str, required=True,\n                        help='Path to store the processed data.')\n\n    args = args.parse_args()\n\n    main(args)", ""]}
{"filename": "buildings_bench/tokenizer.py", "chunked_list": ["import faiss\nimport faiss.contrib.torch_utils \nfrom typing import Union\nimport numpy as np\nfrom pathlib import Path\nimport torch\n\n\nclass LoadQuantizer:\n    \"\"\"Quantize load timeseries with KMeans. Merge centroids that are within a threshold.\"\"\"\n    def __init__(self, seed: int = 1, num_centroids: int = 2274,\n                       with_merge=False, merge_threshold=0.01, device: str = 'cpu'):\n        \"\"\"\n        Args:\n            seed (int): random seed. Default: 1.\n            num_centroids (int): number of centroids: Default: 2274.\n            with_merge (bool): whether to merge centroids that are within a threshold: Default: False.\n            merge_threshold (float): threshold for merging centroids. Default: 0.01 (kWh).\n            device (str): cpu or cuda. Default: cpu.\n        \"\"\"\n        self.seed = seed\n        self.K = num_centroids\n        self.with_merge = with_merge\n        self.merge_threshold = merge_threshold\n        self.kmeans = None\n        self.original_order_to_sorted_centroid_indices = None\n        self.original_order_to_merged_centroid_map = None\n        self.merged_centroids = None\n        self.device = device\n\n    def get_vocab_size(self) -> int:\n        if self.with_merge:\n            return len(self.merged_centroids)\n        return self.K\n\n    def train(self, sample: np.ndarray) -> None:\n        \"\"\"Fit KMeans to a subset of the data. \n        \n        Optionally, merge centroids that are within a threshold.\n\n        Args:\n            sample (np.ndarray): shape [num_samples, 1]\n        \"\"\"\n        self.kmeans = faiss.Kmeans(d=1, k=self.K, niter=300, nredo=10,\n                     seed=self.seed, verbose=True, gpu=(True if 'cuda' in self.device else False))\n        # max is 256, min is 39 per centroid by defaul\n        # https://github.com/facebookresearch/faiss/blob/d5ca6f0a79aa382bb98d2221a8f61c1a200efa25/faiss/Clustering.cpp#L2t\n        self.kmeans.train(sample.reshape(-1,1))\n        \n        if self.with_merge:\n            # sort the centroids and return the sorted indices\n            sorted_indices = np.argsort(self.kmeans.centroids.reshape(-1))\n            # sort the centroids\n            #unsorted_index_to_value_map = self.kmeans.centroids.copy()\n            index_to_value_map = self.kmeans.centroids[sorted_indices]\n            # create a map from the sorted indices to the original indices\n            self.original_order_to_sorted_centroid_indices = np.zeros_like(sorted_indices)\n            for i in range(len(sorted_indices)):\n                self.original_order_to_sorted_centroid_indices[sorted_indices[i]] = i\n\n            # Iterate over sorted centroids, merge centroids that are within a threshold\n            previous_centroid_value = index_to_value_map[0]\n            merge_classes = [0]\n            candidate_centroids = [previous_centroid_value]\n\n            # new list of centroids\n            self.merged_centroids = []\n            # list that maps the original centroid indices to the new centroid indices\n            candidate_index_list = []\n\n\n            #  Iterate over the sorted centroids.\n            for i in range(1,len(index_to_value_map)):\n                # If the current centroid is within a threshold of the previous centroid,\n                # add it to the merged class. \n                if index_to_value_map[i] - previous_centroid_value < self.merge_threshold:\n                    merge_classes += [i]\n                    candidate_centroids += [index_to_value_map[i]]\n                #  If the current centroid is not within a threshold of the previous centroid,\n                #  merge the set of candidate centroids, add the merged class indices to the\n                # candidate list, and update previous centroid value to point to current index\n                else:\n                    # I take the average of the centroids\n                    # being merged\n                    self.merged_centroids += [np.mean(candidate_centroids)]\n                    candidate_index_list += [merge_classes]\n                    # reset this with current index\n                    merge_classes = [i]\n                    candidate_centroids = [index_to_value_map[i]]\n                    previous_centroid_value = index_to_value_map[i]\n            # Add the last centroid to the new list of centroids and add the merged class to the merge list.\n            self.merged_centroids += [np.mean(candidate_centroids)]\n            candidate_index_list += [merge_classes]\n            self.merged_centroids = np.array(self.merged_centroids)\n            # Create a map from the original centroid index to the new centroid index\n            self.original_order_to_merged_centroid_map = np.zeros(len(index_to_value_map), dtype=np.int)\n            for i in range(len(candidate_index_list)):\n                for j in candidate_index_list[i]:\n                    self.original_order_to_merged_centroid_map[j] = i\n            print('Merged {} centroids to {} centroids'.format(len(index_to_value_map), len(self.merged_centroids)))\n            self.K = len(self.merged_centroids)\n            \n    def save(self, output_path: Path) -> None:\n        if 'cuda' in self.device:\n            self.kmeans.index = faiss.index_gpu_to_cpu(self.kmeans.index)\n\n        chunk = faiss.serialize_index(self.kmeans.index)\n        np.save(output_path / \"kmeans_K={}.npy\".format(self.K), chunk)\n        np.save(output_path / \"kmeans_centroids_K={}.npy\".format(self.K), self.kmeans.centroids)\n        if self.with_merge:\n            np.save(output_path / \"kmeans_original_to_sorted_indices_K={}.npy\".format(self.K),\n                    self.original_order_to_sorted_centroid_indices)\n            np.save(output_path / \"kmeans_original_to_merged_map_K={}.npy\".format(self.K),\n                    self.original_order_to_merged_centroid_map)\n            np.save(output_path / \"kmeans_merged_centers_K={}.npy\".format(self.K),\n                    self.merged_centroids)\n\n    def load(self, saved_path: Path) -> None:\n        chunk = np.load(\n            saved_path / \"kmeans_K={}.npy\".format(self.K), allow_pickle=True)\n        self.kmeans = faiss.Kmeans(d=1, k=self.K, niter=200, nredo=20,\n                     seed=self.seed, verbose=True, gpu=(True if 'cuda' in self.device else False))\n        self.kmeans.index = faiss.deserialize_index(chunk)\n        self.kmeans.centroids = np.load(\n            saved_path / \"kmeans_centroids_K={}.npy\".format(self.K), allow_pickle=True)\n\n        if self.with_merge:\n            self.original_order_to_sorted_centroid_indices = np.load(\n                saved_path / \"kmeans_original_to_sorted_indices_K={}.npy\".format(self.K), allow_pickle=True)\n            self.original_order_to_merged_centroid_map = np.load(\n                saved_path / \"kmeans_original_to_merged_map_K={}.npy\".format(self.K), allow_pickle=True)\n            self.merged_centroids = np.load(\n                saved_path / \"kmeans_merged_centers_K={}.npy\".format(self.K), allow_pickle=True)\n            \n            print(f'Loaded Kmeans quantizer with K={len(self.merged_centroids)}')\n        else:\n            print(f'Loaded Kmeans quantizer with K={self.K}')\n\n        if 'cuda' in self.device:\n            local_rank = int(self.device.split(':')[-1])\n            faiss_res = faiss.StandardGpuResources()\n            self.kmeans.index = faiss.index_cpu_to_gpu(faiss_res, local_rank, self.kmeans.index)\n            self.kmeans.centroids = torch.from_numpy(self.kmeans.centroids).float().to(self.device)\n            self.kmeans.centroids.squeeze()\n            if self.with_merge:\n                self.original_order_to_sorted_centroid_indices = torch.from_numpy( \n                    self.original_order_to_sorted_centroid_indices).long().to(self.device)\n                self.original_order_to_merged_centroid_map = torch.from_numpy(\n                    self.original_order_to_merged_centroid_map).long().to(self.device)\n                self.merged_centroids = torch.from_numpy(\n                    self.merged_centroids).float().to(self.device)\n                self.merged_centroids.squeeze()\n            print(f'Kmeans quantizer moved to GPU: {type(self.kmeans.index)}')\n\n\n    def transform(self, sample: Union[np.ndarray, torch.Tensor]) -> Union[np.ndarray, torch.Tensor]:\n        \"\"\"Quantize a sample of load values into a sequence of indices.\n        \n        Args:\n            sample Union[np.ndarray, torch.Tensor]: of shape (n, 1) or (b,n,1). \n                type is numpy if device is cpu or torch Tensor if device is cuda.\n\n        Returns:\n            sample (Union[np.ndarray, torch.Tensor]): of shape (n, 1) or (b,n,1).\n        \"\"\"\n        init_shape = sample.shape\n        sample = sample.reshape(-1,1)\n        sample = self.kmeans.index.search(sample, 1)[1].reshape(-1)\n        if self.with_merge:\n            sample = self.original_order_to_sorted_centroid_indices[sample]\n            sample = self.original_order_to_merged_centroid_map[sample]\n        sample = sample.reshape(init_shape)\n        return sample\n\n\n    def undo_transform(self, sample: Union[np.ndarray, torch.Tensor]) -> Union[np.ndarray, torch.Tensor]:\n        \"\"\"Dequantize a sample of integer indices into a sequence of load values.\n\n        Args:\n            sample Union[np.ndarray, torch.Tensor]: of shape (n, 1) or (b,n,1). \n                type is numpy if device is cpu or torch Tensor if device is cuda.\n\n        Returns:\n            sample (Union[np.ndarray, torch.Tensor]): of shape (n, 1) or (b,n,1).\n        \"\"\"\n        init_shape = sample.shape\n        sample = sample.reshape(-1)\n        if self.with_merge:\n            sample = self.merged_centroids[sample]\n        else:\n            sample = self.kmeans.centroids[sample]\n        sample = sample.reshape(init_shape)\n        return sample", "class LoadQuantizer:\n    \"\"\"Quantize load timeseries with KMeans. Merge centroids that are within a threshold.\"\"\"\n    def __init__(self, seed: int = 1, num_centroids: int = 2274,\n                       with_merge=False, merge_threshold=0.01, device: str = 'cpu'):\n        \"\"\"\n        Args:\n            seed (int): random seed. Default: 1.\n            num_centroids (int): number of centroids: Default: 2274.\n            with_merge (bool): whether to merge centroids that are within a threshold: Default: False.\n            merge_threshold (float): threshold for merging centroids. Default: 0.01 (kWh).\n            device (str): cpu or cuda. Default: cpu.\n        \"\"\"\n        self.seed = seed\n        self.K = num_centroids\n        self.with_merge = with_merge\n        self.merge_threshold = merge_threshold\n        self.kmeans = None\n        self.original_order_to_sorted_centroid_indices = None\n        self.original_order_to_merged_centroid_map = None\n        self.merged_centroids = None\n        self.device = device\n\n    def get_vocab_size(self) -> int:\n        if self.with_merge:\n            return len(self.merged_centroids)\n        return self.K\n\n    def train(self, sample: np.ndarray) -> None:\n        \"\"\"Fit KMeans to a subset of the data. \n        \n        Optionally, merge centroids that are within a threshold.\n\n        Args:\n            sample (np.ndarray): shape [num_samples, 1]\n        \"\"\"\n        self.kmeans = faiss.Kmeans(d=1, k=self.K, niter=300, nredo=10,\n                     seed=self.seed, verbose=True, gpu=(True if 'cuda' in self.device else False))\n        # max is 256, min is 39 per centroid by defaul\n        # https://github.com/facebookresearch/faiss/blob/d5ca6f0a79aa382bb98d2221a8f61c1a200efa25/faiss/Clustering.cpp#L2t\n        self.kmeans.train(sample.reshape(-1,1))\n        \n        if self.with_merge:\n            # sort the centroids and return the sorted indices\n            sorted_indices = np.argsort(self.kmeans.centroids.reshape(-1))\n            # sort the centroids\n            #unsorted_index_to_value_map = self.kmeans.centroids.copy()\n            index_to_value_map = self.kmeans.centroids[sorted_indices]\n            # create a map from the sorted indices to the original indices\n            self.original_order_to_sorted_centroid_indices = np.zeros_like(sorted_indices)\n            for i in range(len(sorted_indices)):\n                self.original_order_to_sorted_centroid_indices[sorted_indices[i]] = i\n\n            # Iterate over sorted centroids, merge centroids that are within a threshold\n            previous_centroid_value = index_to_value_map[0]\n            merge_classes = [0]\n            candidate_centroids = [previous_centroid_value]\n\n            # new list of centroids\n            self.merged_centroids = []\n            # list that maps the original centroid indices to the new centroid indices\n            candidate_index_list = []\n\n\n            #  Iterate over the sorted centroids.\n            for i in range(1,len(index_to_value_map)):\n                # If the current centroid is within a threshold of the previous centroid,\n                # add it to the merged class. \n                if index_to_value_map[i] - previous_centroid_value < self.merge_threshold:\n                    merge_classes += [i]\n                    candidate_centroids += [index_to_value_map[i]]\n                #  If the current centroid is not within a threshold of the previous centroid,\n                #  merge the set of candidate centroids, add the merged class indices to the\n                # candidate list, and update previous centroid value to point to current index\n                else:\n                    # I take the average of the centroids\n                    # being merged\n                    self.merged_centroids += [np.mean(candidate_centroids)]\n                    candidate_index_list += [merge_classes]\n                    # reset this with current index\n                    merge_classes = [i]\n                    candidate_centroids = [index_to_value_map[i]]\n                    previous_centroid_value = index_to_value_map[i]\n            # Add the last centroid to the new list of centroids and add the merged class to the merge list.\n            self.merged_centroids += [np.mean(candidate_centroids)]\n            candidate_index_list += [merge_classes]\n            self.merged_centroids = np.array(self.merged_centroids)\n            # Create a map from the original centroid index to the new centroid index\n            self.original_order_to_merged_centroid_map = np.zeros(len(index_to_value_map), dtype=np.int)\n            for i in range(len(candidate_index_list)):\n                for j in candidate_index_list[i]:\n                    self.original_order_to_merged_centroid_map[j] = i\n            print('Merged {} centroids to {} centroids'.format(len(index_to_value_map), len(self.merged_centroids)))\n            self.K = len(self.merged_centroids)\n            \n    def save(self, output_path: Path) -> None:\n        if 'cuda' in self.device:\n            self.kmeans.index = faiss.index_gpu_to_cpu(self.kmeans.index)\n\n        chunk = faiss.serialize_index(self.kmeans.index)\n        np.save(output_path / \"kmeans_K={}.npy\".format(self.K), chunk)\n        np.save(output_path / \"kmeans_centroids_K={}.npy\".format(self.K), self.kmeans.centroids)\n        if self.with_merge:\n            np.save(output_path / \"kmeans_original_to_sorted_indices_K={}.npy\".format(self.K),\n                    self.original_order_to_sorted_centroid_indices)\n            np.save(output_path / \"kmeans_original_to_merged_map_K={}.npy\".format(self.K),\n                    self.original_order_to_merged_centroid_map)\n            np.save(output_path / \"kmeans_merged_centers_K={}.npy\".format(self.K),\n                    self.merged_centroids)\n\n    def load(self, saved_path: Path) -> None:\n        chunk = np.load(\n            saved_path / \"kmeans_K={}.npy\".format(self.K), allow_pickle=True)\n        self.kmeans = faiss.Kmeans(d=1, k=self.K, niter=200, nredo=20,\n                     seed=self.seed, verbose=True, gpu=(True if 'cuda' in self.device else False))\n        self.kmeans.index = faiss.deserialize_index(chunk)\n        self.kmeans.centroids = np.load(\n            saved_path / \"kmeans_centroids_K={}.npy\".format(self.K), allow_pickle=True)\n\n        if self.with_merge:\n            self.original_order_to_sorted_centroid_indices = np.load(\n                saved_path / \"kmeans_original_to_sorted_indices_K={}.npy\".format(self.K), allow_pickle=True)\n            self.original_order_to_merged_centroid_map = np.load(\n                saved_path / \"kmeans_original_to_merged_map_K={}.npy\".format(self.K), allow_pickle=True)\n            self.merged_centroids = np.load(\n                saved_path / \"kmeans_merged_centers_K={}.npy\".format(self.K), allow_pickle=True)\n            \n            print(f'Loaded Kmeans quantizer with K={len(self.merged_centroids)}')\n        else:\n            print(f'Loaded Kmeans quantizer with K={self.K}')\n\n        if 'cuda' in self.device:\n            local_rank = int(self.device.split(':')[-1])\n            faiss_res = faiss.StandardGpuResources()\n            self.kmeans.index = faiss.index_cpu_to_gpu(faiss_res, local_rank, self.kmeans.index)\n            self.kmeans.centroids = torch.from_numpy(self.kmeans.centroids).float().to(self.device)\n            self.kmeans.centroids.squeeze()\n            if self.with_merge:\n                self.original_order_to_sorted_centroid_indices = torch.from_numpy( \n                    self.original_order_to_sorted_centroid_indices).long().to(self.device)\n                self.original_order_to_merged_centroid_map = torch.from_numpy(\n                    self.original_order_to_merged_centroid_map).long().to(self.device)\n                self.merged_centroids = torch.from_numpy(\n                    self.merged_centroids).float().to(self.device)\n                self.merged_centroids.squeeze()\n            print(f'Kmeans quantizer moved to GPU: {type(self.kmeans.index)}')\n\n\n    def transform(self, sample: Union[np.ndarray, torch.Tensor]) -> Union[np.ndarray, torch.Tensor]:\n        \"\"\"Quantize a sample of load values into a sequence of indices.\n        \n        Args:\n            sample Union[np.ndarray, torch.Tensor]: of shape (n, 1) or (b,n,1). \n                type is numpy if device is cpu or torch Tensor if device is cuda.\n\n        Returns:\n            sample (Union[np.ndarray, torch.Tensor]): of shape (n, 1) or (b,n,1).\n        \"\"\"\n        init_shape = sample.shape\n        sample = sample.reshape(-1,1)\n        sample = self.kmeans.index.search(sample, 1)[1].reshape(-1)\n        if self.with_merge:\n            sample = self.original_order_to_sorted_centroid_indices[sample]\n            sample = self.original_order_to_merged_centroid_map[sample]\n        sample = sample.reshape(init_shape)\n        return sample\n\n\n    def undo_transform(self, sample: Union[np.ndarray, torch.Tensor]) -> Union[np.ndarray, torch.Tensor]:\n        \"\"\"Dequantize a sample of integer indices into a sequence of load values.\n\n        Args:\n            sample Union[np.ndarray, torch.Tensor]: of shape (n, 1) or (b,n,1). \n                type is numpy if device is cpu or torch Tensor if device is cuda.\n\n        Returns:\n            sample (Union[np.ndarray, torch.Tensor]): of shape (n, 1) or (b,n,1).\n        \"\"\"\n        init_shape = sample.shape\n        sample = sample.reshape(-1)\n        if self.with_merge:\n            sample = self.merged_centroids[sample]\n        else:\n            sample = self.kmeans.centroids[sample]\n        sample = sample.reshape(init_shape)\n        return sample", ""]}
{"filename": "buildings_bench/transforms.py", "chunked_list": ["import numpy as np\nfrom pathlib import Path\nimport pandas as pd\nimport torch\nimport pickle as pkl\nimport os\nimport sklearn.preprocessing as preprocessing\nfrom typing import Union\n\n       \nclass BoxCoxTransform:\n    \"\"\"A class that computes and applies the Box-Cox transform to data.\n    \"\"\"\n    def __init__(self, max_datapoints=1000000):\n        \"\"\"\n        Args:\n            max_datapoints (int): If the number of datapoints is greater than this, subsample.\n        \"\"\"\n        self.boxcox = None\n        self.max_datapoints = max_datapoints\n\n    def train(self, data: np.array) -> None:\n        \"\"\"Train the Box-Cox transform on the data with sklearn.preprocessing.PowerTransformer.\n        \n        Args:\n            data (np.array): of shape (n, 1) or (b,n,1)\n        \"\"\"       \n        self.boxcox = preprocessing.PowerTransformer(method='box-cox', standardize=True)\n        data = data.flatten().reshape(-1,1)\n        if data.shape[0] > self.max_datapoints:\n            print(f'Box-Cox: subsampling {self.max_datapoints} datapoints')\n            data = data[np.random.choice(data.shape[0], self.max_datapoints, replace=False)]\n        self.boxcox.fit_transform(1e-6 + data)\n\n\n    def save(self, output_path: Path) -> None:\n        \"\"\"Save the Box-Cox transform\"\"\"\n        with open(output_path / \"boxcox.pkl\", 'wb') as f:\n            pkl.dump(self.boxcox, f)\n    \n    def load(self, saved_path: Path) -> None:\n        \"\"\"Load the Box-Cox transform\"\"\"\n        with open(saved_path / \"boxcox.pkl\", 'rb') as f:\n            self.boxcox = pkl.load(f)\n\n    def transform(self, sample: np.ndarray) -> np.ndarray:\n        \"\"\"Transform a sample via Box-Cox.\n        Not ran on the GPU, so input/output are numpy arrays.\n\n        Args:\n            sample (np.ndarray): of shape (n, 1) or (b,n,1) \n        \n        Returns:\n            transformed_sample (np.ndarray): of shape (n, 1) or (b,n,1)\n        \"\"\"\n        init_shape = sample.shape\n        return self.boxcox.transform(1e-6 + sample.flatten().reshape(-1,1)).reshape(init_shape)\n\n\n    def undo_transform(self, sample: Union[np.ndarray, torch.Tensor]) -> Union[np.ndarray, torch.Tensor]: \n        \"\"\"Undo the transformation of a sample via Box-Cox\n        \n        Args:\n            sample (np.ndarray) or (torch.LongTensor): of shape (n, 1) or (b,n,1). \n                numpy if device is cpu or torch Tensor if device is cuda.\n\n        Returns:\n            unscaled_sample (np.ndarray or torch.Tensor): of shape (n, 1) or (b,n,1).\n        \"\"\"\n        is_tensor = isinstance(sample, torch.Tensor)\n        # if torch.Tensor, convert to numpy first\n        if is_tensor:\n            device = sample.device\n            sample = sample.cpu().numpy()\n        init_shape = sample.shape       \n        sample = self.boxcox.inverse_transform(sample.flatten().reshape(-1,1)).reshape(init_shape)\n        # convert back to torch\n        if is_tensor:\n            sample = torch.from_numpy(sample).to(device)\n        return sample", "\n       \nclass BoxCoxTransform:\n    \"\"\"A class that computes and applies the Box-Cox transform to data.\n    \"\"\"\n    def __init__(self, max_datapoints=1000000):\n        \"\"\"\n        Args:\n            max_datapoints (int): If the number of datapoints is greater than this, subsample.\n        \"\"\"\n        self.boxcox = None\n        self.max_datapoints = max_datapoints\n\n    def train(self, data: np.array) -> None:\n        \"\"\"Train the Box-Cox transform on the data with sklearn.preprocessing.PowerTransformer.\n        \n        Args:\n            data (np.array): of shape (n, 1) or (b,n,1)\n        \"\"\"       \n        self.boxcox = preprocessing.PowerTransformer(method='box-cox', standardize=True)\n        data = data.flatten().reshape(-1,1)\n        if data.shape[0] > self.max_datapoints:\n            print(f'Box-Cox: subsampling {self.max_datapoints} datapoints')\n            data = data[np.random.choice(data.shape[0], self.max_datapoints, replace=False)]\n        self.boxcox.fit_transform(1e-6 + data)\n\n\n    def save(self, output_path: Path) -> None:\n        \"\"\"Save the Box-Cox transform\"\"\"\n        with open(output_path / \"boxcox.pkl\", 'wb') as f:\n            pkl.dump(self.boxcox, f)\n    \n    def load(self, saved_path: Path) -> None:\n        \"\"\"Load the Box-Cox transform\"\"\"\n        with open(saved_path / \"boxcox.pkl\", 'rb') as f:\n            self.boxcox = pkl.load(f)\n\n    def transform(self, sample: np.ndarray) -> np.ndarray:\n        \"\"\"Transform a sample via Box-Cox.\n        Not ran on the GPU, so input/output are numpy arrays.\n\n        Args:\n            sample (np.ndarray): of shape (n, 1) or (b,n,1) \n        \n        Returns:\n            transformed_sample (np.ndarray): of shape (n, 1) or (b,n,1)\n        \"\"\"\n        init_shape = sample.shape\n        return self.boxcox.transform(1e-6 + sample.flatten().reshape(-1,1)).reshape(init_shape)\n\n\n    def undo_transform(self, sample: Union[np.ndarray, torch.Tensor]) -> Union[np.ndarray, torch.Tensor]: \n        \"\"\"Undo the transformation of a sample via Box-Cox\n        \n        Args:\n            sample (np.ndarray) or (torch.LongTensor): of shape (n, 1) or (b,n,1). \n                numpy if device is cpu or torch Tensor if device is cuda.\n\n        Returns:\n            unscaled_sample (np.ndarray or torch.Tensor): of shape (n, 1) or (b,n,1).\n        \"\"\"\n        is_tensor = isinstance(sample, torch.Tensor)\n        # if torch.Tensor, convert to numpy first\n        if is_tensor:\n            device = sample.device\n            sample = sample.cpu().numpy()\n        init_shape = sample.shape       \n        sample = self.boxcox.inverse_transform(sample.flatten().reshape(-1,1)).reshape(init_shape)\n        # convert back to torch\n        if is_tensor:\n            sample = torch.from_numpy(sample).to(device)\n        return sample", "    \n\nclass StandardScalerTransform:\n    \"\"\" A class that standardizes data by removing the mean and scaling to unit variance.\n    \"\"\"\n    def __init__(self, max_datapoints=1000000, device='cpu'):\n        \"\"\"\n        Args:\n            max_datapoints (int): If the number of datapoints is greater than this, subsample.\n            device (str): 'cpu' or 'cuda'\n        \"\"\"\n        self.mean_ = None\n        self.std_ = None\n        self.max_datapoints = max_datapoints\n        self.device=device\n\n    def train(self, data: np.array) -> None:\n        \"\"\"Train the StandardScaler transform on the data.\n        \n        Args:\n            data (np.array): of shape (n, 1) or (b,n,1)\n        \"\"\"       \n        data = data.flatten().reshape(-1,1)\n        if data.shape[0] > self.max_datapoints:\n            print(f'Subsampling {self.max_datapoints} datapoints to fit StandardScalerTransform')\n            data = data[np.random.choice(data.shape[0], self.max_datapoints, replace=False)]\n        self.mean_ = torch.from_numpy(np.array([np.mean(data)])).float().to(self.device)\n        self.std_ = torch.from_numpy(np.array([np.std(data)])).float().to(self.device)\n\n\n    def save(self, output_path: Path) -> None:\n        \"\"\"Save the StandardScaler transform\"\"\"\n        mean_ = self.mean_.cpu().numpy().reshape(-1)\n        std_ = self.std_.cpu().numpy().reshape(-1)\n        np.save(output_path / \"standard_scaler.npy\", np.array([mean_, std_]))\n    \n    \n    def load(self, saved_path: Path) -> None:\n        \"\"\"Load the StandardScaler transform\"\"\"\n        x = np.load(saved_path / \"standard_scaler.npy\")\n        self.mean_ = torch.from_numpy(np.array([x[0]])).float().to(self.device)\n        self.std_ = torch.from_numpy(np.array([x[1]])).float().to(self.device)\n\n\n    def transform(self, sample: Union[np.ndarray, torch.Tensor]) -> torch.Tensor:\n        \"\"\"Transform a sample via StandardScaler\n        \n        Args:\n            sample (np.ndarray or torch.Tensor): shape (n, 1) or (b,n,1) \n        Returns:\n            transformed_samples (torch.Tensor): shape (n, 1) or (b,n,1)\n        \"\"\"\n        if isinstance(sample, np.ndarray):\n            sample = torch.from_numpy(sample).float().to(self.device)        \n        return (sample - self.mean_) / self.std_\n\n\n    def undo_transform(self, sample: Union[np.ndarray, torch.Tensor]) -> torch.Tensor:\n        \"\"\"Undo the transformation of a sample via StandardScaler\n        \n        Args:\n            sample (np.ndarray): of shape (n, 1) or (b,n,1) or torch.Tensor of shape (n, 1) or (b,n,1)\n\n        Returns:\n            unscaled_sample (torch.Tensor): of shape (n, 1) or (b,n,1)\n        \"\"\"\n        if isinstance(sample, np.ndarray):\n            sample = torch.from_numpy(sample).float().to(self.device)\n        return self.std_ * sample + self.mean_        \n\n\n    def undo_transform_std(self, scaled_std: torch.Tensor) -> torch.Tensor:\n        \"\"\"Undo transform for standard deviation.\n        \n        Args:\n            scaled_std (torch.Tensor): of shape (n, 1) or (b,n,1)\n        \n        Returns:\n            unscaled_std (torch.Tensor): of shape (n, 1) or (b,n,1)\n        \"\"\"\n        return self.std_ * scaled_std", "    \n        \nclass LatLonTransform:\n    \"\"\"Pre-processing lat,lon data with standard normalization by Buildings-900K training set.\n    \"\"\"\n    def __init__(self):\n        metadata_path = Path(os.environ.get('BUILDINGS_BENCH','')) / 'metadata'\n        # Load withheld pumas\n        with open(metadata_path / 'withheld_pumas.tsv', 'r') as f:\n            # tab separated file\n            line = f.readlines()[0]\n            self.withheld_pumas = line.split('\\t')\n\n        census_regions = ['northeast', 'midwest', 'south', 'west']\n        self.puma_to_centroid = {}\n        lat_means, lat_stds = 0, 0\n        lon_means, lon_stds = 0, 0\n        for idx,cr in enumerate(census_regions):\n            cr_df = pd.read_csv(metadata_path / f'map_of_pumas_in_census_region_{idx+1}_{cr}.csv', header=0)\n            # keys are cr_df['GISJOIN'], values are (cr_df['latitude'], cr_df['longitude'])\n            self.puma_to_centroid.update(dict(zip(cr_df['GISJOIN'], zip(cr_df['latitude'], cr_df['longitude']))))\n            # Filter out withheld pumas\n            non_withheld_df = cr_df[~cr_df['GISJOIN'].isin(self.withheld_pumas)]\n            # Compute mean and std \n            lat_means += non_withheld_df['latitude'].mean()\n            lat_stds += non_withheld_df['latitude'].std()\n            lon_means += non_withheld_df['longitude'].mean()\n            lon_stds += non_withheld_df['longitude'].std()\n\n        self.lat_means = lat_means / 4\n        self.lon_means = lon_means / 4\n        self.lat_stds = lat_stds / 4\n        self.lon_stds = lon_stds / 4\n\n        # convert self.puma_to_centroid values to np.ndarray of shape (2,)\n        for k,v in self.puma_to_centroid.items():\n            # Normalize\n            v = (np.array(v, dtype=np.float32) - np.array([self.lat_means, self.lon_means])) / np.array([self.lat_stds, self.lon_stds])\n            self.puma_to_centroid[k] = v.astype(np.float32)\n\n\n    def transform_latlon(self, latlon: np.ndarray) -> np.ndarray:\n        \"\"\"Transform a raw Lat/Lon sample into a normalized Lat/Lon sample\n\n        Args:\n            latlon (np.ndarray): of shape (2,).\n\n        Returns:\n            transformed_latlon (np.ndarray): of shape (2,).\n        \"\"\"\n        return (latlon - np.array([self.lat_means, self.lon_means])) / np.array([self.lat_stds, self.lon_stds])\n\n    def undo_transform(self, normalized_latlon: np.ndarray) -> np.ndarray:\n        \"\"\"Undo the transformation of a sample\n\n        Args:\n            normalized_latlon (np.ndarray): of shape (n, 2) or (b,n,2).\n\n        Returns:\n            unnormalized_latlon (np.ndarray): of shape (n, 2) or (b,n,2).\n        \"\"\"\n        init_shape = normalized_latlon.shape\n        normalized_latlon = normalized_latlon.reshape(-1,2)\n        lat = normalized_latlon[:,0] * self.lat_stds + self.lat_means\n        lon = normalized_latlon[:,1] * self.lon_stds + self.lon_means\n        return np.stack([lat, lon], axis=1).reshape(init_shape)\n\n    def transform(self, puma_id: str) -> np.ndarray:\n        \"\"\"Look up a PUMA ID's normalized Lat/Lon centroid.\n\n        This is used in the Buildings-900K Dataset to look up a lat/lon\n        for each building's PUMA.\n\n        Args:\n            puma_id (str): PUMA ID\n        \n        Returns:\n            centroid (np.ndarray): of shape (1,2)\n        \"\"\"\n        return self.puma_to_centroid[puma_id].reshape(1,2)", "\n\nclass TimestampTransform:\n    \"\"\"Extract timestamp features from a Pandas timestamp Series.\n    \"\"\"\n    def __init__(self, is_leap_year: bool = False):\n        \"\"\"\n        Args:\n            is_leap_year (bool): Whether the year of the building data is a leap year or not.\n        \"\"\"\n        self.day_year_normalization = 365 if is_leap_year else 364\n        self.hour_of_day_normalization = 23\n        self.day_of_week_normalization = 6\n\n    def transform(self, timestamp_series: pd.DataFrame) -> np.ndarray:\n        \"\"\"Extract timestamp features from a Pandas timestamp Series.\n\n\n        - Day of week (0-6)\n        - Day of year (0-364)\n        - Hour of day (0-23)\n\n        Args:\n            timestamp_series (pd.DataFrame): of shape (n,) or (b,n)\n        \n        Returns:\n            time_features (np.ndarray): of shape (n,3) or (b,n,3)\n        \"\"\"\n        # If the input is a DatetimeIndex\n        if isinstance(timestamp_series, pd.DatetimeIndex):\n            timestamp_series = timestamp_series.to_series()\n        # Convert to datetime\n        timestamp_series = pd.to_datetime(timestamp_series)\n        # Extract features\n        day_of_week = timestamp_series.dt.dayofweek\n        day_of_year = timestamp_series.dt.dayofyear\n        hour_of_day = timestamp_series.dt.hour\n        time_features = np.stack([day_of_year / self.day_year_normalization,\n                         day_of_week / self.day_of_week_normalization,\n                         hour_of_day / self.hour_of_day_normalization], axis=1).astype(np.float32)\n        return time_features * 2 - 1\n\n\n    def undo_transform(self, time_features: np.ndarray) -> np.ndarray:\n        \"\"\"Convert normalized time features back to original time features\n\n        Args:\n            time_features (np.ndarray): of shape (n, 3) or (b,n,3)\n        \n        Returns:\n            unnormalized_time_features (np.ndarray): of shape (n, 3) or (b,n,3)\n        \"\"\"\n        init_shape = time_features.shape\n        time_features = time_features.reshape(-1,3)\n        time_features = (time_features + 1) * 0.5\n        day_of_year = np.round(time_features[:,0] * self.day_year_normalization)\n        day_of_week = np.round(time_features[:,1] * self.day_of_week_normalization)\n        hour_of_day = np.round(time_features[:,2] * self.hour_of_day_normalization)\n        return np.stack([day_of_year, day_of_week, hour_of_day], axis=1).astype(np.int32).reshape(init_shape)", ""]}
{"filename": "buildings_bench/__init__.py", "chunked_list": ["from buildings_bench.evaluation.managers import BuildingTypes\nfrom buildings_bench.data import load_torch_dataset, load_pretraining, load_pandas_dataset\nfrom buildings_bench.data import benchmark_registry\n\n__version__ = \"0.1.0a3\""]}
{"filename": "buildings_bench/utils.py", "chunked_list": ["import numpy as np\nimport random \nimport torch \nimport os \nimport datetime \n\n\ndef set_seed(seed: int = 42) -> None:\n    \"\"\"Set random seed for reproducibility.\n    \"\"\"\n    np.random.seed(seed)\n    random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed(seed)\n    os.environ[\"PYTHONHASHSEED\"] = str(seed)\n    print(f\"Random seed set as {seed}\")", "\n\ndef save_model_checkpoint(model, optimizer, scheduler, step, path):\n    \"\"\"Save model checkpoint.\n    \"\"\"\n    checkpoint = {\n        'model': model.state_dict(),\n        'optimizer': optimizer.state_dict(),\n        'scheduler': scheduler.state_dict(),\n        'step': step\n    }\n    torch.save(checkpoint, path)\n    print(f\"Saved model checkpoint to {path}...\")", "\n\ndef load_model_checkpoint(path, model, optimizer, scheduler, local_rank):\n    \"\"\"Load model checkpoint.\n    \"\"\"\n    checkpoint = torch.load(path, map_location=f'cuda:{local_rank}')\n    model.load_state_dict(checkpoint['model'])\n    optimizer.load_state_dict(checkpoint['optimizer'])\n    scheduler.load_state_dict(checkpoint['scheduler'])\n    step = checkpoint['step']\n    print(f\"Loaded model checkpoint from {path}\")\n    return model, optimizer, scheduler, step", "\n\ndef worker_init_fn_eulp(worker_id):\n    \"\"\"Set random seed for each worker and init file pointer\n    for Buildings-900K dataset workers.\n\n    Args:\n        worker_id (int): worker id\n    \"\"\"\n    np.random.seed(np.random.get_state()[1][0] + worker_id)\n    worker_info = torch.utils.data.get_worker_info()\n    worker_info.dataset.init_fp()", "   \n\ndef time_features_to_datetime(time_features: np.ndarray,\n                              year: int) -> np.array:\n    \"\"\"\n    Convert time features to datetime objects.\n\n    Args:\n        time_features (np.ndarray): Array of time features.\n            [:,0] is day of year,\n            [:,1] is day of week,\n            [:,2] is hour of day.\n        year (int): Year to use for datetime objects.\n\n    Returns:\n        np.array: Array of datetime objects.\n    \"\"\"\n    day_of_year = time_features[:,0]\n    hour_of_day = time_features[:,2]\n    return np.array([datetime.datetime(year, 1, 1, 0, 0, 0) +   # January 1st\n                    datetime.timedelta(days=int(doy-1), hours=int(hod), minutes=0, seconds=0)\n                    for doy, hod in zip(day_of_year, hour_of_day)])   ", ""]}
{"filename": "buildings_bench/evaluation/aggregate.py", "chunked_list": ["import pandas as pd\nfrom pathlib import Path \nfrom rliable import library as rly\nimport numpy as np\nfrom buildings_bench import BuildingTypes\n\n\ndef return_aggregate_median(model_list, \n                            results_dir,\n                            experiment='zero_shot',\n                            metrics=['cvrmse'], \n                            exclude_simulated = True,\n                            only_simulated = False,\n                            oov_list = [],\n                            reps=50000):\n    \"\"\"Compute the aggregate median for a list of models and metrics over all buildings.\n    Also returns the stratified 95% boostrap CIs for the aggregate median.\n\n    Args:\n        model_list (list): List of models to compute aggregate median for.\n        results_dir (str): Path to directory containing results.\n        experiment (str, optional): Experiment type. Defaults to 'zero_shot'.\n            Options: 'zero_shot', 'transfer_learning'.\n        metrics (list, optional): List of metrics to compute aggregate median for. Defaults to ['cvrmse'].\n        exclude_simulated (bool, optional): Whether to exclude simulated data. Defaults to True.\n        only_simulated (bool, optional): Whether to only include simulated data. Defaults to False.\n        oov_list (list, optional): List of OOV buildings to exclude. Defaults to [].\n        reps (int, optional): Number of bootstrap replicates to use. Defaults to 50000.\n\n    Returns:\n        result_dict (Dict): Dictionary containing aggregate median and CIs for each metric and building type.\n    \"\"\"\n\n    result_dict = {}        \n    aggregate_func = lambda x : np.array([\n        np.median(x.reshape(-1))])\n    for building_type in [BuildingTypes.RESIDENTIAL, BuildingTypes.COMMERCIAL]:\n        result_dict[building_type] = {}\n        for metric in metrics:\n            result_dict[building_type][metric] = {}\n\n            if experiment == 'zero_shot' and (metric == 'rps' or metric == 'crps'):\n                prefix = 'scoring_rule'\n            elif experiment == 'transfer_learning' and (metric == 'rps' or metric == 'crps'):\n                prefix = 'TL_scoring_rule'\n            elif experiment == 'zero_shot':\n                prefix = 'metrics'\n            elif experiment == 'transfer_learning':\n                prefix = 'TL_metrics'\n    \n            for model in model_list:\n                df = pd.read_csv(Path(results_dir) / f'{prefix}_{model}.csv')\n\n                if len(oov_list) > 0:\n                    # Remove OOV buildings\n                    df = df[~df['building_id'].str.contains('|'.join(oov_list))]\n                \n                if exclude_simulated:\n                    # Exclude synthetic data\n                    df = df[~( (df['dataset'] == 'buildings-900k-test') | (df['dataset'] == 'buildings-1m-test') )]\n                elif only_simulated:\n                    df = df[ (df['dataset'] == 'buildings-900k-test') | (df['dataset'] == 'buildings-1m-test') ]\n                \n                # if any df values are inf or nan\n                if df.isnull().values.any() or np.isinf(df.value).values.any():\n                    print(f'Warning: {model} has inf/nan values')\n                # REmove inf/nan values\n                df = df.replace(np.inf, np.nan)\n                df = df.dropna() \n\n                if metric != 'rps' and metric != 'crps':    \n                    result_dict[building_type][metric][model] = \\\n                        df[(df['metric'] == metric) & (df['building_type'] == building_type)]['value'].values.reshape(-1,1)\n                else:\n                    result_dict[building_type][metric][model] = \\\n                        df[df['building_type'] == building_type]['value'].values.reshape(-1,1)\n\n            aggregate_scores, aggregate_score_cis = rly.get_interval_estimates(\n                result_dict[building_type][metric], aggregate_func, reps=reps)\n            result_dict[building_type][metric] = (aggregate_scores, aggregate_score_cis)\n    return result_dict"]}
{"filename": "buildings_bench/evaluation/metrics.py", "chunked_list": ["from typing import Callable\nimport torch \nimport abc\n\nclass MetricType:\n    \"\"\"Enum class for metric types.\n\n    Attributes:\n        SCALAR (str): A scalar metric.\n        HOUR_OF_DAY (str): A metric that is calculated for each hour of the day.\n    \"\"\"\n    SCALAR = 'scalar'\n    HOUR_OF_DAY = 'hour_of_day'", "\n\nclass BuildingsBenchMetric(metaclass=abc.ABCMeta):\n    \"\"\"An abstract class for all metrics.\n\n    The basic idea is to acculumate the errors etc. in a list and then\n    calculate the mean of the errors etc. at the end of the evaluation.\n\n    Calling the metric will add the error to the list of errors. Calling `.mean()`\n    will calculate the mean of the errors, populating the `.value` attribute.\n\n\n    Attributes:\n        name (str): The name of the metric.\n        type (MetricType): The type of the metric.\n        value (float): The value of the metric.\n    \"\"\"\n    def __init__(self, name: str, type: MetricType):\n        self.name = name\n        self.type = type\n        self.value = None\n\n    @abc.abstractmethod\n    def __call__(self, *args, **kwargs):\n        raise NotImplementedError()\n    \n    @abc.abstractmethod\n    def reset(self):\n        raise NotImplementedError()\n    \n    @abc.abstractmethod\n    def mean(self):\n        raise NotImplementedError()", " \n\nclass Metric(BuildingsBenchMetric):\n    \"\"\"A class that represents an error metric.  \n\n    Example:\n    \n    ```python\n    rmse = Metric('rmse', MetricType.SCALAR, squared_error, sqrt=True)\n    mae = Metric('mae', MetricType.SCALAR, absolute_error)\n    nmae = Metric('nmae', MetricType.SCALAR, absolute_error, normalize=True)\n    cvrmse = Metric('cvrmse', MetricType.SCALAR, squared_error, normalize=True, sqrt=True)\n    nmbe = Metric('nmbe', MetricType.SCALAR, bias_error, normalize=True)\n    ```\n    \"\"\"\n    def __init__(self, name: str, type: MetricType, function: Callable, **kwargs):\n        \"\"\"\n        Args:\n            name (str): The name of the metric.\n            type (MetricType): The type of the metric.\n            function (Callable): A function that takes two tensors and returns a tensor.\n        \n        Keyword Args:\n            normalize (bool): Whether to normalize the error.\n            sqrt (bool): Whether to take the square root of the error.\n        \"\"\"\n        super().__init__(name, type)\n        self.function = function\n        self.kwargs = kwargs\n        self.global_values = []\n        self.errors = []\n        self.UNUSED_FLAG = True\n\n    def __call__(self, y_true, y_pred) -> None:\n        \"\"\"\n        Args:\n            y_true (torch.Tensor): shape [batch_size, pred_len]\n            y_pred (torch.Tensor): shape [batch_size, pred_len]\n        \"\"\"\n        self.UNUSED_FLAG = False\n        self.errors += [self.function(y_true, y_pred)]\n        self.global_values += [y_true]\n\n    def reset(self) -> None:\n        \"\"\"Reset the metric.\"\"\"\n        self.global_values = []\n        self.errors = []\n        self.value = None\n        self.UNUSED_FLAG = True\n\n    def mean(self) -> None:\n        \"\"\"Calculate the mean of the error metric.\"\"\"\n        if self.UNUSED_FLAG:\n            # Returning a number >= 0 is undefined,\n            # because this metric is unused. -1\n            # is a flag to indicate this.\n            return\n        \n        # When we concatenate errors and global values\n        # we want shape errors to be shape [batches, pred_len]\n        # and global values to be 1D\n        if self.errors[0].dim() == 1:\n            self.errors = [e.unsqueeze(0) for e in self.errors]\n        if self.global_values[0].dim() == 0:\n            self.global_values = [g.unsqueeze(0) for g in self.global_values]\n    \n        all_errors = torch.concatenate(self.errors,0)\n        if self.type == MetricType.SCALAR:\n            mean = torch.mean(all_errors)\n        elif self.type == MetricType.HOUR_OF_DAY:\n            mean = torch.mean(all_errors, dim=0)\n        # for root mean error\n        if self.kwargs.get('sqrt', False):\n            mean = torch.sqrt(mean)\n        # normalize\n        if self.kwargs.get('normalize', False):\n            mean = mean / torch.mean(torch.concatenate(self.global_values,0))\n        self.value = mean", "    \n    \n################## METRICS ##################\n\ndef absolute_error(y_true: torch.Tensor, y_pred: torch.Tensor) -> torch.Tensor:\n    \"\"\"A PyTorch method that calculates the absolute error (AE) metric.\n\n    Args:\n        y_true (torch.Tensor): [batch, pred_len]\n        y_pred (torch.Tensor): [batch, pred_len]\n    \n    Returns:\n        error (torch.Tensor): [batch, pred_len]\n    \"\"\"\n    return torch.abs(y_true - y_pred)", "\n\ndef squared_error(y_true: torch.Tensor, y_pred: torch.Tensor) -> torch.Tensor:\n    \"\"\"A PyTorch method that calculates the squared error (SE) metric.\n\n    Args:\n        y_true (torch.Tensor): [batch, pred_len]\n        y_pred (torch.Tensor): [batch, pred_len]\n    \n    Returns:\n        error (torch.Tensor): [batch, pred_len]\n    \"\"\"\n    return torch.square(y_true - y_pred)", "\n \ndef bias_error(y_true: torch.Tensor, y_pred: torch.Tensor) -> torch.Tensor:\n    \"\"\"A PyTorch method that calculates the bias error (BE) metric.\n\n    Args:\n        y_true (torch.Tensor): [batch, pred_len]\n        y_pred (torch.Tensor): [batch, pred_len]\n    \n    Returns:\n        error (torch.Tensor): [batch, pred_len]    \n    \"\"\"\n    return y_true - y_pred"]}
{"filename": "buildings_bench/evaluation/__init__.py", "chunked_list": ["from buildings_bench.evaluation.metrics import Metric, MetricType\nfrom buildings_bench.evaluation.metrics import absolute_error, squared_error, bias_error\nfrom buildings_bench.evaluation.scoring_rules import ScoringRule\nfrom buildings_bench.evaluation.scoring_rules import RankedProbabilityScore\nfrom buildings_bench.evaluation.scoring_rules import ContinuousRankedProbabilityScore\nfrom typing import List\n\n\nmetrics_registry = [\n    'rmse',", "metrics_registry = [\n    'rmse',\n    'mae',\n    'nrmse',\n    'nmae',\n    'mbe',\n    'nmbe',\n    'cvrmse'\n]\n", "]\n\nscoring_rule_registry = [\n    'rps',\n    'crps'\n]\n\n\ndef metrics_factory(name: str,\n                    types: List[MetricType] = [MetricType.SCALAR]) -> List[Metric]:\n    \"\"\"\n    Create a metric from a name.\n    By default, will return a scalar metric.\n\n    Args:\n        name (str): The name of the metric.\n        types (List[MetricTypes]): The types of the metric.         \n    Returns:\n        metrics_list (List[Metric]): A list of metrics. \n    \"\"\"\n    assert name.lower() in metrics_registry, f'Invalid metric name: {name}'\n\n    if name.lower() == 'rmse':\n        return [ Metric(f'{name.lower()}-{type}', type, squared_error, sqrt=True) for type in types ]\n    elif name.lower() == 'mae':\n        return [ Metric(f'{name.lower()}-{type}', type, absolute_error) for type in types ]\n    elif name.lower() == 'nrmse':\n        return [ Metric(f'{name.lower()}-{type}', type, squared_error, normalize=True, sqrt=True) for type in types ]\n    elif name.lower() == 'nmae':\n        return [ Metric(f'{name.lower()}-{type}', type, absolute_error, normalize=True) for type in types ]\n    elif name.lower() == 'mbe':\n        return [ Metric(f'{name.lower()}-{type}', type, bias_error) for type in types ]\n    elif name.lower() == 'nmbe':\n        return [ Metric(f'{name.lower()}-{type}', type, bias_error, normalize=True) for type in types ]\n    elif name.lower() == 'cvrmse':\n        return [ Metric(f'{name.lower()}-{type}', type, squared_error, normalize=True, sqrt=True) for type in types ]", "def metrics_factory(name: str,\n                    types: List[MetricType] = [MetricType.SCALAR]) -> List[Metric]:\n    \"\"\"\n    Create a metric from a name.\n    By default, will return a scalar metric.\n\n    Args:\n        name (str): The name of the metric.\n        types (List[MetricTypes]): The types of the metric.         \n    Returns:\n        metrics_list (List[Metric]): A list of metrics. \n    \"\"\"\n    assert name.lower() in metrics_registry, f'Invalid metric name: {name}'\n\n    if name.lower() == 'rmse':\n        return [ Metric(f'{name.lower()}-{type}', type, squared_error, sqrt=True) for type in types ]\n    elif name.lower() == 'mae':\n        return [ Metric(f'{name.lower()}-{type}', type, absolute_error) for type in types ]\n    elif name.lower() == 'nrmse':\n        return [ Metric(f'{name.lower()}-{type}', type, squared_error, normalize=True, sqrt=True) for type in types ]\n    elif name.lower() == 'nmae':\n        return [ Metric(f'{name.lower()}-{type}', type, absolute_error, normalize=True) for type in types ]\n    elif name.lower() == 'mbe':\n        return [ Metric(f'{name.lower()}-{type}', type, bias_error) for type in types ]\n    elif name.lower() == 'nmbe':\n        return [ Metric(f'{name.lower()}-{type}', type, bias_error, normalize=True) for type in types ]\n    elif name.lower() == 'cvrmse':\n        return [ Metric(f'{name.lower()}-{type}', type, squared_error, normalize=True, sqrt=True) for type in types ]", "\n\ndef scoring_rule_factory(name: str) -> ScoringRule:\n    \"\"\"Create a scoring rule from a name.\n\n    Args:\n        name (str): The name of the scoring rule.\n    Returns:\n        sr (ScoringRule): A scoring rule.\n    \"\"\"\n    assert name.lower() in scoring_rule_registry, f'Invalid scoring rule name: {name}'\n    \n    if name.lower() == 'crps':\n        return ContinuousRankedProbabilityScore()\n    elif name.lower() == 'rps':\n        return RankedProbabilityScore()", "\n\ndef all_metrics_list() -> List[Metric]:\n    \"\"\"Returns all registered metrics.\n    \n    Returns:\n        metrics_list (List[Metric]): A list of metrics.\n    \"\"\"\n    metrics_list = []\n    for metric in metrics_registry:\n        metrics_list += metrics_factory(metric, types=[MetricType.SCALAR, MetricType.HOUR_OF_DAY])\n    return metrics_list", ""]}
{"filename": "buildings_bench/evaluation/scoring_rules.py", "chunked_list": ["import torch \nimport math \nfrom buildings_bench.evaluation.metrics import MetricType\nfrom buildings_bench.evaluation.metrics import BuildingsBenchMetric\n\n\nclass ScoringRule(BuildingsBenchMetric):\n    \"\"\"An abstract class for all scoring rules.\n    \"\"\"\n\n    def __init__(self, name: str):\n        super().__init__(name, MetricType.HOUR_OF_DAY)\n\n    def reset(self):\n        self.value = None\n\n    def __call__(self, **kwargs):\n        raise NotImplementedError()\n    \n    def mean(self):\n        if self.value is None:\n            return\n        value = torch.stack(self.value,0)\n        self.value = torch.mean(value, 0)    ", "\n\nclass RankedProbabilityScore(ScoringRule):\n    \"\"\"A class that calculates the ranked probability score (RPS) metric\n    for categorical distributions.\"\"\"\n\n    def __init__(self):\n        super().__init__(name='rps')\n\n    def rps(self, y_true, y_pred_logits, centroids) -> None:\n        \"\"\"A PyTorch method that calculates the ranked probability score metric\n           for categorical distributions.\n\n           Since the bin values are centroids of clusters along the real line,\n           we have to compute the width of the bins by summing the distance to\n           the left and right centroids of the bin (divided by 2), except for\n           the first and last bins, where we only need to sum the distance to\n           the right centroid of the first bin and the left centroid of the\n           last bin, respectively.\n\n        Args:\n            y_true (torch.Tensor): of shape [batch_size, seq_len, 1] categorical labels\n            y_pred_logits (torch.Tensor): of shape [batch_size, seq_len, vocab_size] logits\n            centroids (torch.Tensor): of shape [vocab_size]\n        \"\"\"\n        # Convert class labels y_true to one hot vectors [batch_size, seq_len, vocab_size]\n        y_true = torch.nn.functional.one_hot(y_true.squeeze(2).long(),\n                                             num_classes=centroids.shape[0]).to(y_pred_logits.device)\n        # Sort the values, logits, and y_true\n        centroids, indices = torch.sort(centroids, dim=-1)\n        y_pred_logits = y_pred_logits[:, :, indices]\n        y_true = y_true[:, :, indices]\n\n        softmax_preds = torch.softmax(y_pred_logits, dim=-1)\n        # Calculate the cumulative distribution function (CDF) of the predictions\n        cdf = torch.cumsum(softmax_preds, dim=-1)\n\n        y_true_cdf = torch.cumsum(y_true, dim=-1)\n        # Calculate the difference between the CDF and the true values\n        square = torch.square(cdf - y_true_cdf)\n        \n        # Calculate the widths of the bins:\n        # we need to calculate\n        # half the distance to the right centroid and left centroid.\n        centroid_dist = centroids[1:] - centroids[:-1]\n        half_dists = centroid_dist / 2\n        widths = torch.unsqueeze(half_dists[1:] + half_dists[:-1], dim=0)\n        widths = torch.cat([\n            centroids[0].view(1, 1) + half_dists[0].view(1, 1),\n            widths,\n            half_dists[-1].view(1, 1)\n        ],dim=1)\n        \n        # Calculate the RPS    \n        rps = torch.mean(torch.sum(square * widths, dim=-1), dim=0)  # [seq_len]\n        if self.value is None:\n            self.value = [rps]\n        else:\n            self.value += [rps]\n\n    def __call__(self, true_continuous, y_true, y_pred_logits, centroids):\n        self.rps(y_true, y_pred_logits, centroids)", "\n\nclass ContinuousRankedProbabilityScore(ScoringRule):\n    \"\"\"\n    A class that calculates the Gaussian continuous ranked probability score (CRPS) metric.\n    \"\"\"\n    def __init__(self):\n        super().__init__(name = 'crps')\n\n    def crps(self, true_continuous, y_pred_distribution_params) -> None:\n        \"\"\"Computes the Gaussian CRPS.\n\n        Args:\n            true_continuous (torch.Tensor): of shape [batch_size, seq_len, 1]\n            y_pred_distribution_params (torch.Tensor): of shape [batch_size, seq_len, 2]\n        \"\"\"\n        pred_mu = y_pred_distribution_params[:, :, 0].unsqueeze(-1)\n        pred_sigma = y_pred_distribution_params[:, :, 1].unsqueeze(-1)\n        \n        # standardize the true values to N(0,1)\n        true_continuous = (true_continuous - pred_mu) / pred_sigma\n        # Calculate the cumulative distribution function (CDF) of the predictions\n        cdf = 0.5 * (1 + torch.erf(true_continuous / math.sqrt(2)))\n        # Calculate the pdf of the predictions\n        pdf = torch.exp(-torch.square(true_continuous) / 2) / math.sqrt(2 * math.pi)\n        # Calculate pi inv\n        pi_inv = 1 / math.sqrt(math.pi)\n        # CRPS\n        crps = pred_sigma * ( true_continuous * (2 * cdf - 1) + 2 * pdf - pi_inv)\n        crps = torch.mean(crps, dim=0).squeeze(1)  # [seq_len]\n        if self.value is None:\n            self.value = [crps]\n        else:\n            self.value += [crps]\n\n    def __call__(self, true_continuous, y_true, y_pred_distribution_params, centroids):\n        self.crps(true_continuous, y_pred_distribution_params)", ""]}
{"filename": "buildings_bench/evaluation/managers.py", "chunked_list": ["import torch\nfrom buildings_bench.evaluation import metrics_factory\nfrom buildings_bench.evaluation.metrics import Metric, MetricType\nfrom buildings_bench.evaluation.scoring_rules import ScoringRule\nfrom typing import List\nimport pandas as pd\nfrom copy import deepcopy\n\n\nclass BuildingTypes:\n    \"\"\"Enum for supported types of buildings.\n    \n    Attributes:\n        RESIDENTIAL (str): Residential building type.\n        COMMERCIAL (str): Commercial building type.\n        RESIDENTIAL_INT (int): Integer representation of residential building type (0).\n        COMMERCIAL_INT (int): Integer representation of commercial building type (1).\n    \"\"\"\n    RESIDENTIAL = 'residential'\n    COMMERCIAL = 'commercial'\n    RESIDENTIAL_INT = 0\n    COMMERCIAL_INT = 1", "\nclass BuildingTypes:\n    \"\"\"Enum for supported types of buildings.\n    \n    Attributes:\n        RESIDENTIAL (str): Residential building type.\n        COMMERCIAL (str): Commercial building type.\n        RESIDENTIAL_INT (int): Integer representation of residential building type (0).\n        COMMERCIAL_INT (int): Integer representation of commercial building type (1).\n    \"\"\"\n    RESIDENTIAL = 'residential'\n    COMMERCIAL = 'commercial'\n    RESIDENTIAL_INT = 0\n    COMMERCIAL_INT = 1", "\n\nclass MetricsManager:\n    \"\"\"A class that keeps track of all metrics (and a scoring rule)for one or more buildings.\n    \n    Metrics are computed for each building type (residential and commercial).\n\n    Example:\n\n    ```python\n    from buildings_bench.evaluation.managers import MetricsManager\n    from buildings_bench.evaluation import metrics_factory\n    from buildings_bench import BuildingTypes\n    import torch\n\n\n    metrics_manager = MetricsManager(metrics=metrics_factory('cvrmse'))\n\n    metrics_manager(\n        y_true=torch.FloatTensor([1, 2, 3]).view(1,3,1),\n        y_pred=torch.FloatTensor([1, 2, 3]).view(1,3,1),\n        building_type = BuildingTypes.RESIDENTIAL_INT\n    )\n\n    for metric in metrics_manager.metrics[BuildingTypes.RESIDENTIAL]:\n        metric.mean()\n        print(metric.value) # prints tensor(0.)\n\n    ```\n    \"\"\"\n    def __init__(self, metrics: List[Metric] = None, scoring_rule: ScoringRule = None):\n        \"\"\"Initializes the MetricsManager.\n        \n        Args:\n            metrics (List[Metric]): A list of metrics to compute for each\n                building type.\n            scoring_rule (ScoringRule): A scoring rule to compute for each\n                building type.\n        \"\"\"\n        self.metrics = {}\n        if not metrics is None:\n            self.metrics[BuildingTypes.RESIDENTIAL] = metrics\n            self.metrics[BuildingTypes.COMMERCIAL] = deepcopy(metrics)\n        self.scoring_rules = {}\n        if not scoring_rule is None:\n            self.scoring_rules[BuildingTypes.RESIDENTIAL] = scoring_rule\n            self.scoring_rules[BuildingTypes.COMMERCIAL] = deepcopy(scoring_rule)\n        self.accumulated_unnormalized_loss = 0\n        self.total_samples = 0\n\n    def _compute_all(self, y_true: torch.Tensor,\n                     y_pred: torch.Tensor,\n                     building_types_mask: torch.Tensor, **kwargs) -> None:\n        \"\"\"Computes all metrics and scoring rules for the given batch.\n        \n        Args:\n            y_true (torch.Tensor): A tensor of shape [batch, pred_len, 1] with\n                the true values.\n            y_pred (torch.Tensor): A tensor of shape [batch, pred_len, 1] with\n                the predicted values.\n            building_types_mask (torch.Tensor): A tensor of shape [batch] with  \n                the building types of each sample.\n\n        \"\"\"\n        if len(self.metrics) > 0:\n            for building_type in [BuildingTypes.RESIDENTIAL, BuildingTypes.COMMERCIAL]:\n                \n                if building_type == BuildingTypes.RESIDENTIAL:\n                    \n                    predictions = y_pred[~building_types_mask]\n                    if predictions.shape[0] == 0:\n                        continue\n                    targets = y_true[~building_types_mask]\n                elif building_type == BuildingTypes.COMMERCIAL:\n                    predictions = y_pred[building_types_mask]\n                    if predictions.shape[0] == 0:\n                        continue\n                    targets = y_true[building_types_mask]\n\n                for metric in self.metrics[building_type]:\n                    metric(targets, predictions)\n        \n        if len(self.scoring_rules) > 0:\n            self._compute_scoring_rule(y_true,\n                                      kwargs['y_categories'],\n                                      kwargs['y_distribution_params'],\n                                      kwargs['centroids'],\n                                      building_types_mask)\n\n\n    def _compute_scoring_rule(self, \n                            true_continuous,\n                            true_categories,\n                            y_distribution_params,\n                            centroids,\n                            building_types_mask) -> None:\n        \"\"\"Compute the scoring rule.\n        \n        Args:\n            true_continuous (torch.Tensor): The true continuous load values.\n                [bsz_sz, pred_len, 1]\n            true_categories (torch.Tensor): The true quantized load values.\n            y_distribution_params are [bsz_sz, pred_len, vocab_size] if logits,\n             or are [bsz_sz, pred_len, 2] if Gaussian\n            centroids (torch.Tensor): The bin values for the quantized distribution.\n            building_types_mask (torch.Tensor): \n        \"\"\"\n        if y_distribution_params is None:\n            raise ValueError('y_distribution_params must be provided to compute scoring rule.')\n        \n        for building_type in [BuildingTypes.RESIDENTIAL, BuildingTypes.COMMERCIAL]:\n            if building_type == BuildingTypes.RESIDENTIAL:\n                true_continuous_by_type = true_continuous[~building_types_mask]\n                if true_continuous_by_type.shape[0] == 0:\n                    continue\n                self.scoring_rules[building_type](\n                    true_continuous_by_type,\n                    true_categories[~building_types_mask],\n                    y_distribution_params[~building_types_mask],\n                    centroids)\n            elif building_type == BuildingTypes.COMMERCIAL:\n                true_continuous_by_type = true_continuous[building_types_mask]\n                if true_continuous_by_type.shape[0] == 0:\n                    continue\n                self.scoring_rules[building_type](\n                    true_continuous_by_type,\n                    true_categories[building_types_mask],\n                    y_distribution_params[building_types_mask],\n                    centroids)\n\n    def _update_loss(self, loss, sample_size):\n        \"\"\"Updates the accumulated loss and total samples.\"\"\"\n        self.accumulated_unnormalized_loss += (loss * sample_size)\n        self.total_samples += sample_size\n\n    def get_ppl(self):\n        \"\"\"Returns the perplexity of the accumulated loss.\"\"\"\n        return torch.exp(self.accumulated_unnormalized_loss) / self.total_samples\n    \n    def summary(self, with_loss=False, with_ppl=False):\n        \"\"\"Return a summary of the metrics for the dataset.\n        \n        A summary maps keys to objects of type Metric or ScoringRule.\n        \"\"\"\n        summary = {}\n        for building_type in [BuildingTypes.RESIDENTIAL, BuildingTypes.COMMERCIAL]:\n            summary[building_type] = {}\n            if len(self.metrics) > 0:\n                for metric in self.metrics[building_type]:\n                    if not metric.UNUSED_FLAG:\n                        metric.mean()\n                        summary[building_type][metric.name] = metric\n            if len(self.scoring_rules) > 0: \n                if not self.scoring_rules[building_type].value is None: \n                    self.scoring_rules[building_type].mean()\n                    summary[building_type][self.scoring_rules[building_type].name] = \\\n                        self.scoring_rules[building_type]\n                \n        if with_ppl and self.total_samples > 0:\n            summary['ppl'] = self.get_ppl()\n        if with_loss and self.total_samples > 0:\n            summary['loss'] = self.accumulated_unnormalized_loss / self.total_samples\n        return summary\n\n    def reset(self, loss: bool = True) -> None:\n        \"\"\"Reset the metrics.\"\"\"\n        for building_type in [BuildingTypes.RESIDENTIAL, BuildingTypes.COMMERCIAL]:\n            for metric in self.metrics[building_type]:\n                metric.reset()\n            if len(self.scoring_rules) > 0:\n                self.scoring_rules[building_type].reset()\n        if loss:\n            self.accumulated_unnormalized_loss = 0\n            self.total_samples = 0\n\n\n    def __call__(self, \n                 y_true: torch.Tensor,\n                 y_pred: torch.Tensor,\n                 building_types_mask: torch.Tensor = None,\n                 building_type: int = BuildingTypes.COMMERCIAL_INT,\n                 **kwargs):\n        \"\"\"Compute metrics for a batch of predictions.\n        \n        Args:\n            y_true (torch.Tensor): The true (unscaled) load values. (continuous)\n                shape is [batch_size, pred_len, 1]\n            y_pred (torch.Tensor): The predicted (unscaled) load values. (continuous)\n                shape is [batch_size, pred_len, 1]\n            building_types_mask (torch.Tensor): \n                A boolean mask indicating the building type of each building.\n                True (1) if commercial, False (0). Shape is [batch_size].\n            building_type (int): The building type of the batch. Can be provided \n                instead of building_types_mask if all buildings are of the same type.\n\n        Keyword args:\n            y_categories (torch.Tensor): The true load values. (quantized)\n            y_distribution_params (torch.Tensor): logits, Gaussian params, etc.\n            centroids (torch.Tensor): The bin values for the quantized load.\n            loss (torch.Tensor): The loss for the batch.\n        \"\"\"\n        if building_types_mask is None:\n            building_types_mask = (building_type == BuildingTypes.COMMERCIAL_INT) * \\\n                                   torch.ones(y_true.shape[0], dtype=torch.bool, device=y_true.device)\n\n        self._compute_all(y_true, y_pred, building_types_mask, **kwargs)\n        if 'loss' in kwargs:\n            batch_size, pred_len, _ = y_true.shape\n            self._update_loss(kwargs['loss'], batch_size * pred_len)", "\n\nclass DatasetMetricsManager:\n    \"\"\"\n    A class that manages a MetricsManager for each building\n    in one or more benchmark datasets. \n    One DatasetMetricsManager can be used to keep track of all metrics\n    when evaluating a model on all of the benchmark's datasets.\n\n    This class wil create a Pandas Dataframe summary containing the metrics for each building.\n\n    Default metrics are NRMSE (CVRMSE), NMAE, NMBE.\n    \"\"\"\n    default_metrics = metrics_factory('cvrmse',\n                      types=[MetricType.SCALAR, MetricType.HOUR_OF_DAY]) \\\n                      + metrics_factory('nmbe', types=[MetricType.SCALAR, MetricType.HOUR_OF_DAY]) \\\n                      + metrics_factory('nmae', types=[MetricType.SCALAR, MetricType.HOUR_OF_DAY])\n\n    def __init__(self, \n                 metrics: List[Metric] = default_metrics,\n                 scoring_rule: ScoringRule = None):\n        self.metrics_list = metrics\n        self.scoring_rule = scoring_rule\n        self._metrics = {}\n\n    def get_building_from_dataset(self, dataset_name: str, building_id: str) -> None:\n        # Check if dataset exists\n        if dataset_name not in self._metrics:\n            return None\n        # Check if building exists\n        if building_id not in self._metrics[dataset_name]:\n            return None\n        return self._metrics[dataset_name][building_id]\n    \n    def add_building_to_dataset_if_missing(self, dataset_name: str, building_id: str) -> None:\n        # Check if dataset exists\n        if dataset_name not in self._metrics:\n            self._metrics[dataset_name] = {}\n        # Check if building already exists\n        if building_id not in self._metrics[dataset_name]:\n            # Use deepcopy to pass new Metric and Scoring Rule objects\n            self._metrics[dataset_name][building_id] = \\\n                MetricsManager(deepcopy(self.metrics_list), deepcopy(self.scoring_rule))\n\n\n    def summary(self, dataset_name: str = None) -> pd.DataFrame:\n        \"\"\"Return a summary of the metrics for the dataset.\n        \n        Args:\n            dataset_name (str): The name of the dataset to summarize. If None,\n                summarize all datasets.\n        Returns:\n            A Pandas dataframe with the following columns:\n\n                - dataset: The name of the dataset.\n                - building_id: The unique ID of the building.\n                - building_type: The type of the building.\n                - metric: The name of the metric.\n                - metric_type: The type of the metric. (scalar or hour_of_day)\n                - value: The value of the metric.\n        \"\"\"\n        summary = {}\n        if dataset_name is None: # summarize all datasets\n            for dataset_name in self._metrics.keys():\n                summary[dataset_name] = {}\n                for building_id in self._metrics[dataset_name].keys():\n                    summary[dataset_name][building_id] = \\\n                        self._metrics[dataset_name][building_id].summary()\n        else:\n            summary[dataset_name] = {}\n            for building_id in self._metrics[dataset_name].keys():\n                summary[dataset_name][building_id] = \\\n                    self._metrics[dataset_name][building_id].summary()\n       \n        # to Pandas dataframe\n        columns = ['dataset', 'building_id', 'building_type', 'metric', 'metric_type', 'value']\n        rows = []\n        # for each dataset\n        for dataset_name in summary.keys():\n            # for each building\n            for building_id in summary[dataset_name].keys():\n                # for the building type \n                for building_type in summary[dataset_name][building_id].keys():\n                    # for each metric\n                    for metric_name in summary[dataset_name][building_id][building_type].keys():\n                        # if scoring rule, skip\n                        if self.scoring_rule and metric_name == self.scoring_rule.name:\n                            continue\n                        # if the metric is a scalar\n                        if summary[dataset_name][building_id][building_type][metric_name].type == MetricType.SCALAR:\n                            rows.append([dataset_name, building_id, building_type,\n                                         metric_name.split('-')[0], MetricType.SCALAR,\n                                         summary[dataset_name][building_id][building_type][metric_name].value.item()])\n                        # if the metric is a list of scalars\n                        elif summary[dataset_name][building_id][building_type][metric_name].type == MetricType.HOUR_OF_DAY:\n                            multi_hour_value = summary[dataset_name][building_id][building_type][metric_name].value\n                            for hour in range(multi_hour_value.shape[0]):\n                                rows.append([dataset_name, building_id,\n                                             building_type, metric_name.split('-')[0] + '_' + str(hour), \n                                             MetricType.HOUR_OF_DAY, multi_hour_value[hour].item()])\n        \n        metric_df = pd.DataFrame(rows, columns=columns)\n\n        if self.scoring_rule:\n            columns = ['dataset', 'building_id', 'building_type', 'scoring_rule', 'value']\n            rows = []\n            for dataset_name in summary.keys():\n                for building_id in summary[dataset_name].keys():\n                    for building_type in summary[dataset_name][building_id].keys():\n                        if self.scoring_rule.name in summary[dataset_name][building_id][building_type]:\n                            score = summary[dataset_name][building_id][building_type][self.scoring_rule.name].value\n                            for hour in range(score.shape[0]):\n                                rows.append([dataset_name, building_id, building_type,\n                                            self.scoring_rule.name + '_' + str(hour), score[hour].item()])\n            scoring_rule_df = pd.DataFrame(rows, columns=columns)\n            return metric_df, scoring_rule_df\n        else:\n            return metric_df\n\n\n    def __call__(self, \n                 dataset_name: str,\n                 building_id: str,\n                 y_true: torch.Tensor, \n                 y_pred: torch.Tensor,\n                 building_types_mask: torch.Tensor = None,\n                 building_type: int = BuildingTypes.COMMERCIAL_INT,\n                 **kwargs) -> None:\n        \"\"\"Compute metrics for a batch of predictions for a single building in a dataset.\n\n        Args:\n            dataset_name (str): The name of the dataset.\n            building_id (str): The unique building identifier.\n            y_true (torch.Tensor): The true (unscaled) load values. (continuous)\n                shape is [batch_size, pred_len, 1]\n            y_pred (torch.Tensor): The predicted (unscaled) load values. (continuous)\n                shape is [batch_size, pred_len, 1]\n            building_types_mask (torch.Tensor): \n                A boolean mask indicating the building type of each building.\n                True (1) if commercial, False (0). Shape is [batch_size]. Default is None.\n            building_type (int): The building type of the batch. Can be provided \n                instead of building_types_mask if all buildings are of the same type.\n\n        Keyword args:\n            y_categories (torch.Tensor): The true load values. (quantized)\n            y_distribution_params (torch.Tensor): logits, Gaussian params, etc.\n            centroids (torch.Tensor): The bin values for the quantized load.\n            loss (torch.Tensor): The loss for the batch.        \n        \"\"\"\n        self.add_building_to_dataset_if_missing(dataset_name, building_id)\n        \n        if building_types_mask is None:\n            building_types_mask = (building_type == BuildingTypes.COMMERCIAL_INT) * \\\n                                   torch.ones(y_true.shape[0], dtype=torch.bool, device=y_true.device)\n        self._metrics[dataset_name][building_id](y_true, y_pred, building_types_mask, **kwargs)", "\n    \n"]}
{"filename": "buildings_bench/data/__init__.py", "chunked_list": ["from pathlib import Path\nimport torch\nimport tomli\nimport os\nfrom buildings_bench.data.buildings900K import Buildings900K\nfrom buildings_bench.data.datasets import TorchBuildingDatasetsFromCSV\nfrom buildings_bench.data.datasets import TorchBuildingDatasetFromParquet\nfrom buildings_bench.data.datasets import PandasBuildingDatasetsFromCSV\nfrom buildings_bench import BuildingTypes\nfrom buildings_bench import transforms", "from buildings_bench import BuildingTypes\nfrom buildings_bench import transforms\nfrom typing import List, Union\n\n\ndataset_registry = [\n    'buildings-900k-train',\n    'buildings-900k-val',\n    'buildings-900k-test',\n    'sceaux',", "    'buildings-900k-test',\n    'sceaux',\n    'borealis',\n    'ideal',\n    'bdg-2:panther',\n    'bdg-2:fox',\n    'bdg-2:rat',\n    'bdg-2:bear',\n    'electricity',\n    'smart',", "    'electricity',\n    'smart',\n    'lcl'\n]\n\nbenchmark_registry = [\n    'buildings-900k-test',\n    'sceaux',\n    'borealis',\n    'ideal',", "    'borealis',\n    'ideal',\n    'bdg-2:panther',\n    'bdg-2:fox',\n    'bdg-2:rat',\n    'bdg-2:bear',\n    'electricity',\n    'smart',\n    'lcl'\n]        ", "    'lcl'\n]        \n\ndef parse_building_years_metadata(datapath: Path, dataset_name: str):\n    with open(datapath / 'metadata' / 'building_years.txt', 'r') as f:\n        building_years = f.readlines()\n    building_years = [building_year.strip() for building_year in building_years]\n    building_years = filter(lambda building_year: dataset_name in building_year.lower(), building_years)\n    \n    return list(building_years)", "\n\ndef load_pretraining(\n        name: str,\n        num_buildings_ablation: int = -1,\n        apply_scaler_transform: str = '',\n        scaler_transform_path: Path = None,\n        context_len=168, # week\n        pred_len=24) -> torch.utils.data.Dataset:\n    r\"\"\"\n    Pre-training datasets: buildings-900k-train, buildings-900k-val\n\n    Args:\n        name (str): Name of the dataset to load.\n        num_buildings_ablation (int): Number of buildings to use for pre-training.\n                                        If -1, use all buildings.\n        apply_scaler_transform (str): If not using quantized load or unscaled loads,\n                                 applies a {boxcox,standard} scaling transform to the load. Default: ''.\n        scaler_transform_path (Path): Path to data for transform, e.g., pickled data for BoxCox transform.\n        context_len (int): Length of the context. Defaults to 168.\n        pred_len (int): Length of the prediction horizon. Defaults to 24.\n    \n    Returns:\n        torch.utils.data.Dataset: Dataset for pretraining.\n    \"\"\"\n    dataset_path = Path(os.environ.get('BUILDINGS_BENCH', ''))\n    if not dataset_path.exists():\n        raise ValueError('BUILDINGS_BENCH environment variable not set')\n\n    if num_buildings_ablation > 0:\n        idx_file_suffix = f'_{num_buildings_ablation}'\n    else:\n        idx_file_suffix = ''\n    if name.lower() == 'buildings-900k-train':\n        idx_file = f'train_weekly{idx_file_suffix}.idx'\n        dataset = Buildings900K(dataset_path,\n                               idx_file,\n                               context_len=context_len,\n                               pred_len=pred_len,\n                               apply_scaler_transform=apply_scaler_transform,\n                               scaler_transform_path = scaler_transform_path)\n    elif name.lower() == 'buildings-900k-val':\n        idx_file = f'val_weekly{idx_file_suffix}.idx'\n        dataset = Buildings900K(dataset_path,\n                               idx_file,\n                               context_len=context_len,\n                               pred_len=pred_len,\n                               apply_scaler_transform=apply_scaler_transform,\n                               scaler_transform_path = scaler_transform_path)\n    return dataset", "        \n    \ndef load_torch_dataset(\n        name: str,\n        dataset_path: Path = None,\n        apply_scaler_transform: str = '',\n        scaler_transform_path: Path = None,\n        context_len = 168,\n        pred_len = 24\n        ) -> Union[TorchBuildingDatasetsFromCSV, TorchBuildingDatasetFromParquet]:\n    r\"\"\"Load datasets by name.\n\n    Args:\n        name (str): Name of the dataset to load.\n        dataset_path (Path): Path to the benchmark data. Optional.\n        apply_scaler_transform (str): If not using quantized load or unscaled loads,\n                                 applies a {boxcox,standard} scaling transform to the load. Default: ''.\n        scaler_transform_path (Path): Path to data for transform, e.g., pickled data for BoxCox transform.\n        context_len (int): Length of the context. Defaults to 168.\n        pred_len (int): Length of the prediction horizon. Defaults to 24.\n    \n    Returns:\n        dataset (Union[TorchBuildingDatasetsFromCSV, TorchBuildingDatasetFromParquet]): Dataset for benchmarking.\n    \"\"\"\n    if not dataset_path:\n        dataset_path = Path(os.environ.get('BUILDINGS_BENCH', ''))\n        if not dataset_path.exists():\n            raise ValueError('BUILDINGS_BENCH environment variable not set')\n        \n    with open(dataset_path / 'metadata' / 'benchmark.toml', 'rb') as f:\n        metadata = tomli.load(f)['buildings_bench']\n\n    if name.lower() == 'buildings-900k-test':\n        spatial_lookup = transforms.LatLonTransform()\n        puma_files = list((dataset_path / 'Buildings-900K-test' / '2021').glob('*2018*/*/*/*/*/*.parquet'))\n        if len(puma_files) == 0:\n            raise ValueError(f'Could not find any Parquet files in '\n                             f' {str(dataset_path / \"Buildings-900K-test\" / \"2021\")}')\n        # to string\n        puma_files = [str(Path(pf).parent) for pf in puma_files]\n        puma_ids = [pf.split('puma=')[1] for pf in puma_files]\n        building_types = []\n        for pf in puma_files:\n            if 'res' in pf:\n                building_types += [BuildingTypes.RESIDENTIAL]\n            elif 'com' in pf:\n                building_types += [BuildingTypes.COMMERCIAL]\n        dataset_generator = TorchBuildingDatasetFromParquet(\n                                                         puma_files,\n                                                         [spatial_lookup.undo_transform( # pass unnormalized lat lon coords\n                                                            spatial_lookup.transform(pid)) for pid in puma_ids],\n                                                         building_types,\n                                                         context_len=context_len,\n                                                         pred_len=pred_len,\n                                                         apply_scaler_transform=apply_scaler_transform,\n                                                         scaler_transform_path = scaler_transform_path,\n                                                         leap_years=metadata['leap_years'])\n    elif ':' in name.lower():\n        name, subset = name.lower().split(':')\n        dataset_metadata = metadata[name.lower()]\n        all_by_files = parse_building_years_metadata(dataset_path, name.lower())\n        all_by_files = filter(lambda by_file: subset in by_file.lower(), all_by_files)\n\n        dataset_generator = TorchBuildingDatasetsFromCSV(dataset_path,\n                                                         all_by_files,\n                                                         dataset_metadata[subset]['latlon'],\n                                                         dataset_metadata[subset]['building_type'],\n                                                         context_len=context_len,\n                                                         pred_len=pred_len,\n                                                         apply_scaler_transform=apply_scaler_transform,\n                                                         scaler_transform_path = scaler_transform_path,\n                                                         leap_years=metadata['leap_years']) \n    elif name.lower() in benchmark_registry:\n        dataset_metadata = metadata[name.lower()]\n        all_by_files = parse_building_years_metadata(dataset_path, name.lower())\n        dataset_generator = TorchBuildingDatasetsFromCSV(dataset_path,\n                                                         all_by_files,\n                                                         dataset_metadata['latlon'],\n                                                         dataset_metadata['building_type'],\n                                                         context_len=context_len,\n                                                         pred_len=pred_len,\n                                                         apply_scaler_transform=apply_scaler_transform,\n                                                         scaler_transform_path = scaler_transform_path,\n                                                         leap_years=metadata['leap_years']) \n    \n    else:\n        raise ValueError(f'Unknown dataset {name}')\n    \n    return dataset_generator", "\n\ndef load_pandas_dataset(\n        name: str,\n        dataset_path: Path = None,\n        feature_set: str = 'engineered',\n        apply_scaler_transform: str = '',\n        scaler_transform_path: Path = None) -> PandasBuildingDatasetsFromCSV:\n    \"\"\"\n    Load datasets by name.\n\n    Args:\n        name (str): Name of the dataset to load.\n        dataset_path (Path): Path to the benchmark data. Optional.\n        feature_set (str): Feature set to use. Default: 'engineered'.\n        apply_scaler_transform (str): If not using quantized load or unscaled loads,\n                                    applies a {boxcox,standard} scaling transform to the load. Default: ''. \n        scaler_transform_path (Path): Path to data for transform, e.g., pickled data for BoxCox transform.\n\n    Returns:\n        dataset (PandasBuildingDatasetsFromCSV): Generator of Pandas datasets for benchmarking.\n    \"\"\"\n    if not dataset_path:\n        dataset_path = Path(os.environ.get('BUILDINGS_BENCH', ''))\n        if not dataset_path.exists():\n            raise ValueError('BUILDINGS_BENCH environment variable not set')\n        \n    if name.lower() == 'buildings-900k-test':\n        raise ValueError(f'{name.lower()} unavailable for now as pandas dataset')\n\n    with open(dataset_path / 'metadata' / 'benchmark.toml', 'rb') as f:\n        metadata = tomli.load(f)['buildings_bench']\n\n    if ':' in name.lower():\n        name, subset = name.lower().split(':')\n        dataset_metadata = metadata[name.lower()]\n        all_by_files = parse_building_years_metadata(dataset_path, name.lower())\n        all_by_files = filter(lambda by_file: subset in by_file.lower(), all_by_files)\n        building_type = dataset_metadata[subset]['building_type']\n        building_latlon = dataset_metadata[subset]['latlon']\n    else:\n        dataset_metadata = metadata[name.lower()]\n        all_by_files = parse_building_years_metadata(dataset_path, name.lower())\n        building_type = dataset_metadata['building_type']\n        building_latlon = dataset_metadata['latlon']\n\n    return PandasBuildingDatasetsFromCSV(\n            dataset_path,\n            all_by_files,\n            building_latlon,\n            building_type,\n            features=feature_set,\n            apply_scaler_transform = apply_scaler_transform,\n            scaler_transform_path = scaler_transform_path,\n            leap_years = metadata['leap_years'])", ""]}
{"filename": "buildings_bench/data/buildings900K.py", "chunked_list": ["import torch\nimport numpy as np\nfrom pathlib import Path\nimport pyarrow.parquet as pq\nimport buildings_bench.transforms as transforms\nfrom buildings_bench.transforms import BoxCoxTransform, StandardScalerTransform\n\n\nclass Buildings900K(torch.utils.data.Dataset):\n    r\"\"\"This is an indexed dataset for the Buildings-900K dataset.\n    It uses an index file to quickly load a sub-sequence from a time series in a multi-building\n    Parquet file. The index file is a tab separated file with the following columns:\n\n    0. Building-type-and-year (e.g., comstock_tmy3_release_1)\n    1. Census region (e.g., by_puma_midwest)\n    2. PUMA ID\n    3. Building ID\n    4. Hour of year pointer (e.g., 0070)\n\n    The sequence pointer is used to extract the slice\n    [pointer - context length : pointer + pred length] for a given building ID.\n    \n    The time series are not stored chronologically and must be sorted by timestamp after loading.\n\n    Each dataloader worker has its own file pointer to the index file. This is to avoid\n    weird multiprocessing errors from sharing a file pointer. We 'seek' to the correct\n    line in the index file for random access.\n\n    With 4 workers, data loading with an indexed dataset requires about 30GB of RAM.\n    \"\"\"\n    def __init__(self, \n                dataset_path: Path,\n                index_file: str,\n                context_len: int = 168,\n                pred_len: int = 24,\n                apply_scaler_transform: str = '',\n                scaler_transform_path: Path = None):\n        \"\"\"\n        Args:\n            dataset_path (Path): Path to the pretraining dataset.\n            index_file (str): Name of the index file\n            context_len (int, optional): Length of the context. Defaults to 168. \n                The index file has to be generated with the same context length.\n            pred_len (int, optional): Length of the prediction horizon. Defaults to 24.\n                The index file has to be generated with the same pred length.\n            apply_scaler_transform (str, optional): Apply a scaler transform to the load. Defaults to ''.\n            scaler_transform_path (Path, optional): Path to the scaler transform. Defaults to None.\n        \"\"\"\n        self.dataset_path = dataset_path / 'Buildings-900K' / 'end-use-load-profiles-for-us-building-stock' / '2021'\n        self.metadata_path = dataset_path / 'metadata'\n        self.context_len = context_len\n        self.pred_len = pred_len\n        self.building_type_and_year = ['comstock_tmy3_release_1',\n                                       'resstock_tmy3_release_1',\n                                       'comstock_amy2018_release_1',\n                                       'resstock_amy2018_release_1']\n        self.census_regions = ['by_puma_midwest', 'by_puma_south', 'by_puma_northeast', 'by_puma_west']\n        self.index_file = self.metadata_path / index_file\n        self.index_fp = None\n        self.__read_index_file(self.index_file)\n        self.time_transform = transforms.TimestampTransform()\n        self.spatial_transform = transforms.LatLonTransform()\n        self.apply_scaler_transform = apply_scaler_transform\n        if self.apply_scaler_transform == 'boxcox':\n            self.load_transform = BoxCoxTransform()\n            self.load_transform.load(scaler_transform_path)\n        elif self.apply_scaler_transform == 'standard':\n            self.load_transform = StandardScalerTransform()\n            self.load_transform.load(scaler_transform_path)\n\n\n    def init_fp(self):\n        \"\"\"Each worker needs to open its own file pointer to avoid \n        weird multiprocessing errors from sharing a file pointer.\n\n        This is not called in the main process.\n        This is called in the DataLoader worker_init_fn.\n        The file is opened in binary mode which lets us disable buffering.\n        \"\"\"\n        self.index_fp = open(self.index_file, 'rb', buffering=0)\n        self.index_fp.seek(0)\n\n    def __read_index_file(self, index_file: Path) -> None:\n        \"\"\"Extract metadata from index file.\n        \"\"\"\n        # Fast solution to get the number of time series in index file\n        # https://pynative.com/python-count-number-of-lines-in-file/\n        def _count_generator(reader):\n            b = reader(1024 * 1024)\n            while b:\n                yield b\n                b = reader(1024 * 1024)\n\n        with open(index_file, 'rb') as fp:\n            c_generator = _count_generator(fp.raw.read)\n            # count each \\n\n            self.num_time_series = sum(buffer.count(b'\\n') for buffer in c_generator)\n        \n        # Count the number of chars per line\n        with open(index_file, 'rb', buffering=0) as fp:\n            first_line = fp.readline()\n            self.chunk_size = len(first_line)\n        \n        print(f'Counted {self.num_time_series} indices in index file.')\n\n    def __del__(self):\n        if self.index_fp:\n            self.index_fp.close()\n\n    def __len__(self):\n        return self.num_time_series\n\n    def __getitem__(self, idx):\n        # Open file pointer if not already open\n        if not self.index_fp:\n           self.index_fp = open(self.index_file, 'rb', buffering=0)\n           self.index_fp.seek(0)\n\n        # Get the index of the time series\n        self.index_fp.seek(idx * self.chunk_size, 0)\n        ts_idx = self.index_fp.read(self.chunk_size).decode('utf-8')\n\n        # Parse the index\n        ts_idx = ts_idx.strip('\\n').split('\\t')\n\n        # strip loading zeros\n        seq_ptr = ts_idx[-1]\n        seq_ptr = int(seq_ptr.lstrip('0')) if seq_ptr != '0000' else 0\n        # Building ID\n        bldg_id = ts_idx[3].lstrip('0')\n\n        # Select timestamp and building column\n        df = pq.read_table(str(self.dataset_path / self.building_type_and_year[int(ts_idx[0])]\n                           / 'timeseries_individual_buildings' / self.census_regions[int(ts_idx[1])]\n                           / 'upgrade=0' / f'puma={ts_idx[2]}'), columns=['timestamp', bldg_id])\n\n        # Order by timestamp\n        df = df.to_pandas().sort_values(by='timestamp')\n        # Slice each column from seq_ptr-context_len : seq_ptr + pred_len\n        time_features = self.time_transform.transform(df['timestamp'].iloc[seq_ptr-self.context_len : seq_ptr+self.pred_len ])\n        # Running faiss on CPU is  slower than on GPU, so we quantize loads later after data loading.\n        load_features = df[bldg_id].iloc[seq_ptr-self.context_len : seq_ptr+self.pred_len ].values.astype(np.float32)  # (context_len+pred_len,)\n        # For BoxCox transform\n        if self.apply_scaler_transform != '':\n            load_features = self.load_transform.transform(load_features)\n        latlon_features = self.spatial_transform.transform(ts_idx[2]).repeat(self.context_len + self.pred_len, axis=0) \n        \n        # residential = 0 and commercial = 1\n        building_features = np.ones((self.context_len + self.pred_len,1), dtype=np.int32) * int(int(ts_idx[0]) % 2 == 0)\n\n        sample = {\n            'latitude': latlon_features[:, 0][...,None],\n            'longitude': latlon_features[:, 1][...,None],\n            'day_of_year': time_features[:, 0][...,None],\n            'day_of_week': time_features[:, 1][...,None],\n            'hour_of_day': time_features[:, 2][...,None],\n            'building_type': building_features,\n            'load': load_features[...,None]\n        }\n        return sample", "class Buildings900K(torch.utils.data.Dataset):\n    r\"\"\"This is an indexed dataset for the Buildings-900K dataset.\n    It uses an index file to quickly load a sub-sequence from a time series in a multi-building\n    Parquet file. The index file is a tab separated file with the following columns:\n\n    0. Building-type-and-year (e.g., comstock_tmy3_release_1)\n    1. Census region (e.g., by_puma_midwest)\n    2. PUMA ID\n    3. Building ID\n    4. Hour of year pointer (e.g., 0070)\n\n    The sequence pointer is used to extract the slice\n    [pointer - context length : pointer + pred length] for a given building ID.\n    \n    The time series are not stored chronologically and must be sorted by timestamp after loading.\n\n    Each dataloader worker has its own file pointer to the index file. This is to avoid\n    weird multiprocessing errors from sharing a file pointer. We 'seek' to the correct\n    line in the index file for random access.\n\n    With 4 workers, data loading with an indexed dataset requires about 30GB of RAM.\n    \"\"\"\n    def __init__(self, \n                dataset_path: Path,\n                index_file: str,\n                context_len: int = 168,\n                pred_len: int = 24,\n                apply_scaler_transform: str = '',\n                scaler_transform_path: Path = None):\n        \"\"\"\n        Args:\n            dataset_path (Path): Path to the pretraining dataset.\n            index_file (str): Name of the index file\n            context_len (int, optional): Length of the context. Defaults to 168. \n                The index file has to be generated with the same context length.\n            pred_len (int, optional): Length of the prediction horizon. Defaults to 24.\n                The index file has to be generated with the same pred length.\n            apply_scaler_transform (str, optional): Apply a scaler transform to the load. Defaults to ''.\n            scaler_transform_path (Path, optional): Path to the scaler transform. Defaults to None.\n        \"\"\"\n        self.dataset_path = dataset_path / 'Buildings-900K' / 'end-use-load-profiles-for-us-building-stock' / '2021'\n        self.metadata_path = dataset_path / 'metadata'\n        self.context_len = context_len\n        self.pred_len = pred_len\n        self.building_type_and_year = ['comstock_tmy3_release_1',\n                                       'resstock_tmy3_release_1',\n                                       'comstock_amy2018_release_1',\n                                       'resstock_amy2018_release_1']\n        self.census_regions = ['by_puma_midwest', 'by_puma_south', 'by_puma_northeast', 'by_puma_west']\n        self.index_file = self.metadata_path / index_file\n        self.index_fp = None\n        self.__read_index_file(self.index_file)\n        self.time_transform = transforms.TimestampTransform()\n        self.spatial_transform = transforms.LatLonTransform()\n        self.apply_scaler_transform = apply_scaler_transform\n        if self.apply_scaler_transform == 'boxcox':\n            self.load_transform = BoxCoxTransform()\n            self.load_transform.load(scaler_transform_path)\n        elif self.apply_scaler_transform == 'standard':\n            self.load_transform = StandardScalerTransform()\n            self.load_transform.load(scaler_transform_path)\n\n\n    def init_fp(self):\n        \"\"\"Each worker needs to open its own file pointer to avoid \n        weird multiprocessing errors from sharing a file pointer.\n\n        This is not called in the main process.\n        This is called in the DataLoader worker_init_fn.\n        The file is opened in binary mode which lets us disable buffering.\n        \"\"\"\n        self.index_fp = open(self.index_file, 'rb', buffering=0)\n        self.index_fp.seek(0)\n\n    def __read_index_file(self, index_file: Path) -> None:\n        \"\"\"Extract metadata from index file.\n        \"\"\"\n        # Fast solution to get the number of time series in index file\n        # https://pynative.com/python-count-number-of-lines-in-file/\n        def _count_generator(reader):\n            b = reader(1024 * 1024)\n            while b:\n                yield b\n                b = reader(1024 * 1024)\n\n        with open(index_file, 'rb') as fp:\n            c_generator = _count_generator(fp.raw.read)\n            # count each \\n\n            self.num_time_series = sum(buffer.count(b'\\n') for buffer in c_generator)\n        \n        # Count the number of chars per line\n        with open(index_file, 'rb', buffering=0) as fp:\n            first_line = fp.readline()\n            self.chunk_size = len(first_line)\n        \n        print(f'Counted {self.num_time_series} indices in index file.')\n\n    def __del__(self):\n        if self.index_fp:\n            self.index_fp.close()\n\n    def __len__(self):\n        return self.num_time_series\n\n    def __getitem__(self, idx):\n        # Open file pointer if not already open\n        if not self.index_fp:\n           self.index_fp = open(self.index_file, 'rb', buffering=0)\n           self.index_fp.seek(0)\n\n        # Get the index of the time series\n        self.index_fp.seek(idx * self.chunk_size, 0)\n        ts_idx = self.index_fp.read(self.chunk_size).decode('utf-8')\n\n        # Parse the index\n        ts_idx = ts_idx.strip('\\n').split('\\t')\n\n        # strip loading zeros\n        seq_ptr = ts_idx[-1]\n        seq_ptr = int(seq_ptr.lstrip('0')) if seq_ptr != '0000' else 0\n        # Building ID\n        bldg_id = ts_idx[3].lstrip('0')\n\n        # Select timestamp and building column\n        df = pq.read_table(str(self.dataset_path / self.building_type_and_year[int(ts_idx[0])]\n                           / 'timeseries_individual_buildings' / self.census_regions[int(ts_idx[1])]\n                           / 'upgrade=0' / f'puma={ts_idx[2]}'), columns=['timestamp', bldg_id])\n\n        # Order by timestamp\n        df = df.to_pandas().sort_values(by='timestamp')\n        # Slice each column from seq_ptr-context_len : seq_ptr + pred_len\n        time_features = self.time_transform.transform(df['timestamp'].iloc[seq_ptr-self.context_len : seq_ptr+self.pred_len ])\n        # Running faiss on CPU is  slower than on GPU, so we quantize loads later after data loading.\n        load_features = df[bldg_id].iloc[seq_ptr-self.context_len : seq_ptr+self.pred_len ].values.astype(np.float32)  # (context_len+pred_len,)\n        # For BoxCox transform\n        if self.apply_scaler_transform != '':\n            load_features = self.load_transform.transform(load_features)\n        latlon_features = self.spatial_transform.transform(ts_idx[2]).repeat(self.context_len + self.pred_len, axis=0) \n        \n        # residential = 0 and commercial = 1\n        building_features = np.ones((self.context_len + self.pred_len,1), dtype=np.int32) * int(int(ts_idx[0]) % 2 == 0)\n\n        sample = {\n            'latitude': latlon_features[:, 0][...,None],\n            'longitude': latlon_features[:, 1][...,None],\n            'day_of_year': time_features[:, 0][...,None],\n            'day_of_week': time_features[:, 1][...,None],\n            'hour_of_day': time_features[:, 2][...,None],\n            'building_type': building_features,\n            'load': load_features[...,None]\n        }\n        return sample", "    \n\n"]}
{"filename": "buildings_bench/data/datasets.py", "chunked_list": ["from pathlib import Path\nimport torch\nimport pandas as pd\nimport numpy as np\nfrom typing import List, Union, Iterator, Tuple\nimport buildings_bench.transforms as transforms\nfrom buildings_bench.transforms import BoxCoxTransform, StandardScalerTransform\nfrom buildings_bench import BuildingTypes\nimport pyarrow.parquet as pq\n", "import pyarrow.parquet as pq\n\n\nclass TorchBuildingDataset(torch.utils.data.Dataset):\n    \"\"\"PyTorch Dataset for a single building's Pandas Dataframe with a timestamp index and a 'power' column.\n\n    Used to iterate over mini-batches of 192-hour subsequences.\n    \"\"\"\n    def __init__(self, \n                dataframe: pd.DataFrame,\n                building_latlon: List[float],\n                building_type: BuildingTypes,\n                context_len: int = 168,\n                pred_len: int = 24,\n                sliding_window: int = 24,\n                apply_scaler_transform: str = '',\n                scaler_transform_path: Path = None,\n                is_leap_year = False):\n        \"\"\"\n        Args:\n            dataframe (pd.DataFrame): Pandas DataFrame with a timestamp index and a 'power' column.\n            building_latlon (List[float]): Latitude and longitude of the building.\n            building_type (BuildingTypes): Building type for the dataset.\n            context_len (int, optional): Length of context. Defaults to 168.\n            pred_len (int, optional): Length of prediction. Defaults to 24.\n            sliding_window (int, optional): Stride for sliding window to split timeseries into test samples. Defaults to 24.\n            apply_scaler_transform (str, optional): Apply scaler transform {boxcox,standard} to the load. Defaults to ''.\n            scaler_transform_path (Path, optional): Path to the pickled data for BoxCox transform. Defaults to None.\n            is_leap_year (bool, optional): Is the year a leap year? Defaults to False.\n        \"\"\"\n        self.df = dataframe        \n        self.building_type = building_type\n        self.context_len = context_len\n        self.pred_len = pred_len\n        self.sliding_window = sliding_window\n        self.apply_scaler_transform = apply_scaler_transform\n\n        self.normalized_latlon = transforms.LatLonTransform().transform_latlon(building_latlon)\n        self.time_transform = transforms.TimestampTransform(is_leap_year=is_leap_year)\n        if self.apply_scaler_transform == 'boxcox':\n            self.load_transform = BoxCoxTransform()\n            self.load_transform.load(scaler_transform_path)\n        elif self.apply_scaler_transform == 'standard':\n            self.load_transform = StandardScalerTransform()\n            self.load_transform.load(scaler_transform_path)\n        \n    def __len__(self):\n        return (len(self.df) - self.context_len - self.pred_len) // self.sliding_window\n\n    def __getitem__(self, idx):\n        seq_ptr = self.context_len + self.sliding_window * idx\n\n        load_features = self.df['power'].iloc[seq_ptr-self.context_len : seq_ptr+self.pred_len].values.astype(np.float32)\n        if self.apply_scaler_transform != '':\n            load_features = self.load_transform.transform(load_features)\n        time_features = self.time_transform.transform(self.df.index[seq_ptr-self.context_len : seq_ptr+self.pred_len ])\n        latlon_features = self.normalized_latlon.reshape(1,2).repeat(self.context_len + self.pred_len, axis=0).astype(np.float32) \n        if self.building_type == BuildingTypes.RESIDENTIAL:\n            building_features = BuildingTypes.RESIDENTIAL_INT * np.ones((self.context_len + self.pred_len,1), dtype=np.int32)\n        elif self.building_type == BuildingTypes.COMMERCIAL:\n            building_features = BuildingTypes.COMMERCIAL_INT * np.ones((self.context_len + self.pred_len,1), dtype=np.int32)\n\n        sample = {\n            'latitude': latlon_features[:, 0][...,None],\n            'longitude': latlon_features[:, 1][...,None],\n            'day_of_year': time_features[:, 0][...,None],\n            'day_of_week': time_features[:, 1][...,None],\n            'hour_of_day': time_features[:, 2][...,None],\n            'building_type': building_features,\n            'load': load_features[...,None]\n        }\n        return sample", "    \n\nclass TorchBuildingDatasetFromParquet:\n    \"\"\"Generate PyTorch Datasets out of Parquet files.\n    \n    Each file has multiple buildings (with same Lat/Lon and building type) and\n    each building is a column. All time series are for the same year.     \n\n    Attributes:\n        building_datasets (dict): Maps unique building ids to a TorchBuildingDataset.   \n    \"\"\"\n    def __init__(self,\n                parquet_datasets: List[str],\n                building_latlons: List[List[float]],\n                building_types: List[BuildingTypes],\n                context_len: int = 168,\n                pred_len: int = 24,\n                sliding_window: int = 24,\n                apply_scaler_transform: str = '',\n                scaler_transform_path: Path = None,\n                leap_years: List[int] = None):\n        \"\"\"\n        Args:\n            parquet_datasets (List[str]): List of paths to a parquet file, each has a timestamp index and multiple columns, one per building.\n            building_latlons (List[List[float]]): List of latlons for each parquet file.\n            building_types (List[BuildingTypes]): List of building types for each parquet file.\n            context_len (int, optional): Length of context. Defaults to 168.\n            pred_len (int, optional): Length of prediction. Defaults to 24.\n            sliding_window (int, optional): Stride for sliding window to split timeseries into test samples. Defaults to 24.\n            apply_scaler_transform (str, optional): Apply scaler transform {boxcox,standard} to the load. Defaults to ''.\n            scaler_transform_path (Path, optional): Path to the pickled data for BoxCox transform. Defaults to None.\n            leap_years (List[int], optional): List of leap years. Defaults to None.\n        \"\"\"\n        self.building_datasets = {}\n\n        for parquet_data, building_latlon, building_type in zip(parquet_datasets, building_latlons, building_types):\n            df = pq.read_table(parquet_data)\n\n            # Order by timestamp\n            df = df.to_pandas().sort_values(by='timestamp')\n            # Set timestamp as the index\n            df.set_index('timestamp', inplace=True)\n            df.index = pd.to_datetime(df.index, format='%Y-%m-%d %H:%M:%S')\n\n            # split into multiple dataframes by column, keeping the index\n            dfs = np.split(df, df.shape[1], axis=1)\n\n            # for each column in the multi_building_dataset, create a BuildingYearDatasetFromCSV\n            for building_dataframe in dfs:\n                building_name = building_dataframe.columns[0]\n                year = building_dataframe.index[0].year\n                is_leap_year = True if year in leap_years else False\n\n                # remove the year for aggregating over all years, later\n                b_file = f'{building_type}_{Path(parquet_data).stem}/{building_name}'\n                #by_file = f'{building_type}_{Path(parquet_data).stem}/{building_name}_year={year}'\n\n                # rename column 1 to power\n                building_dataframe.rename(columns={building_dataframe.columns[0]: 'power'}, inplace=True)\n                self.building_datasets[b_file] = TorchBuildingDataset(building_dataframe, \n                                                                    building_latlon, \n                                                                    building_type, \n                                                                    context_len, \n                                                                    pred_len, \n                                                                    sliding_window,\n                                                                    apply_scaler_transform,\n                                                                    scaler_transform_path,\n                                                                    is_leap_year)\n\n        \n    def __iter__(self) -> Iterator[Tuple[str, TorchBuildingDataset]]:\n        \"\"\"Generator to iterate over the building datasets.\n\n        Yields:\n            A pair of building id, TorchBuildingDataset objects. \n        \"\"\"\n        for building_name, building_dataset in self.building_datasets.items():\n            yield (building_name, building_dataset)", "\n\nclass TorchBuildingDatasetsFromCSV:\n    \"\"\"TorchBuildingDatasetsFromCSV\n    \n    Generate PyTorch Datasets from a list of CSV files.\n\n    Attributes:\n        building_datasets (dict): Maps unique building ids to a list of tuples (year, TorchBuildingDataset). \n    \"\"\"\n    def __init__(self,\n                data_path: Path,\n                building_year_files: List[str],\n                building_latlon: List[float],\n                building_type: BuildingTypes,\n                context_len: int = 168,\n                pred_len: int = 24,\n                sliding_window: int = 24,\n                apply_scaler_transform: str = '',\n                scaler_transform_path: Path = None,\n                leap_years: List[int] = None):\n        \"\"\"\n        Args:\n            data_path (Path): Path to the dataset\n            building_year_files (List[str]): List of paths to a csv file, each has a timestamp index and multiple columns, one per building.\n            building_type (BuildingTypes): Building type for the dataset.\n            context_len (int, optional): Length of context. Defaults to 168.\n            pred_len (int, optional): Length of prediction sequence for the forecasting model. Defaults to 24.\n            sliding_window (int, optional): Stride for sliding window to split timeseries into test samples. Defaults to 24.\n            apply_scaler_transform (str, optional): Apply scaler transform {boxcox,standard} to the load. Defaults to ''.\n            scaler_transform_path (Path, optional): Path to the pickled data for BoxCox transform. Defaults to None.\n            leap_years (List[int], optional): List of leap years. Defaults to None.\n        \"\"\"\n        self.building_datasets = {}\n        self.building_type = building_type\n\n        for building_year_file in building_year_files:\n            name = building_year_file.split('_')[0].split('/')[1]\n            year = int(building_year_file.split('=')[1])\n            is_leap_year = True if year in leap_years else False\n        \n            df = pd.read_csv(data_path / (building_year_file + '.csv'),\n                                                index_col=0, header=0, parse_dates=True)\n            df.index = pd.to_datetime(df.index, format='%Y-%m-%d %H:%M:%S')\n            df = df.sort_index()\n            if len(df.columns) > 1:\n                bldg_names = df.columns\n                # split into multiple dataframes by column, keeping the index\n                dfs = np.split(df, df.shape[1], axis=1)\n            else:\n                bldg_names = [name]\n                dfs = [df]\n\n            # for each bldg, create a TorchBuildingDatasetFromCSV\n            for bldg_name, bldg_df in zip(bldg_names, dfs):\n                bldg_df.rename(columns={bldg_df.columns[0]: 'power'}, inplace=True)\n\n                if not bldg_name in self.building_datasets:\n                    self.building_datasets[bldg_name] = []\n\n                self.building_datasets[bldg_name] += [(year, TorchBuildingDataset(bldg_df, \n                                                                                building_latlon, \n                                                                                building_type, \n                                                                                context_len, \n                                                                                pred_len, \n                                                                                sliding_window,\n                                                                                apply_scaler_transform,\n                                                                                scaler_transform_path,\n                                                                                is_leap_year))]\n                        \n        \n    def __iter__(self) -> Iterator[Tuple[str, torch.utils.data.ConcatDataset]]:\n        \"\"\"A Generator for TorchBuildingDataset objects.\n\n        Yields:\n            A tuple of the building id and a ConcatDataset of the TorchBuildingDataset objects for all years.    \n        \"\"\"\n        for building_name, building_year_datasets in self.building_datasets.items():\n            building_year_datasets = sorted(building_year_datasets, key=lambda x: x[0])\n            building_dataset = torch.utils.data.ConcatDataset([\n                byd[1] for byd in building_year_datasets])\n            yield (building_name, building_dataset)", "\n\nclass PandasBuildingDatasetsFromCSV:\n    \"\"\"Generate Pandas Dataframes from a list of CSV files.\n    \n    Create a dictionary of building datasets from a list of csv files.\n    Used as a generator to iterate over Pandas Dataframes for each building.\n    The Pandas Dataframe contain all of the years of data for the building.\n\n    Attributes:\n        building_datasets (dict): Maps unique building ids to a list of tuples (year, Dataframe).    \n    \"\"\"\n    def __init__(self, \n                data_path: Path,\n                building_year_files: List[str],\n                building_latlon: List[float],\n                building_type: BuildingTypes,\n                features: str = 'transformer',\n                apply_scaler_transform: str = '',\n                scaler_transform_path: Path = None,\n                leap_years: List[int] = []):\n        \"\"\"        \n        Args:\n            data_path (Path): Path to the dataset\n            building_year_files (List[str]): List of paths to a csv file, each has a timestamp index and multiple columns, one per building.\n            building_type (BuildingTypes): Building type for the dataset.\n            features (str, optional): Type of features to use. Defaults to 'transformer'. {'transformer','engineered'}\n                'transformer' features: load, latitude, longitude, hour of day, day of week, day of year, building type\n                'engineered' features are an expansive list of mainly calendar-based features, useful for traditional ML models.\n            apply_scaler_transform (str, optional): Apply scaler transform {boxcox,standard} to the load. Defaults to ''.\n            scaler_transform_path (Path, optional): Path to the pickled data for BoxCox transform. Defaults to None.\n            leap_years (List[int], optional): List of leap years. Defaults to None.\n        \"\"\"\n        self.building_type = building_type\n        self.features = features \n        self.apply_scaler_transform = apply_scaler_transform\n        self.leap_years = leap_years\n        \n        if self.features == 'transformer':\n            self.normalized_latlon = transforms.LatLonTransform().transform_latlon(building_latlon)\n            \n            if self.apply_scaler_transform == 'boxcox':\n                self.load_transform = BoxCoxTransform()\n                self.load_transform.load(scaler_transform_path)\n            elif self.apply_scaler_transform == 'standard':\n                self.load_transform = StandardScalerTransform()\n                self.load_transform.load(scaler_transform_path)\n\n        self.building_datasets = {}\n        \n        for building_year_file in building_year_files:\n            #fullname = building_year_file.split('_')[0]\n            name = building_year_file.split('_')[0].split('/')[1]\n            year = int(building_year_file.split('=')[1])\n\n            # load the csv file\n            df = pd.read_csv(data_path / (building_year_file + '.csv'),\n                             index_col=0, header=0, parse_dates=True)\n            df.index = pd.to_datetime(df.index, format='%Y-%m-%d %H:%M:%S')\n            df = df.asfreq('H')\n            df = df.sort_index()\n            \n            bldg_dfs =[]\n            # is multi-building file? \n            if len(df.columns) > 1:\n                bldg_names = df.columns\n                # split into multiple dataframes by column, keeping the index\n                bldg_dfs = np.split(df, df.shape[1], axis=1)\n            else:\n                bldg_names = [name]\n                bldg_dfs = [df]\n            \n            for bldg_name,df in zip(bldg_names, bldg_dfs):\n                if self.features == 'engineered':\n                    self._prepare_data_with_engineered_features(bldg_name, df, year)\n                elif self.features == 'transformer':\n                    self._prepare_data_transformer(bldg_name, df, year)\n            \n    def _prepare_data_with_engineered_features(self, bldg_name, df, year):\n        # rename column 1 to power\n        df.rename(columns={df.columns[0]: 'power'}, inplace=True)\n\n        # Create hour_of_day,.., etc columns\n        df[\"hour_x\"] = np.sin(np.radians((360/24) * df.index.hour))\n        df[\"hour_y\"] = np.cos(np.radians((360/24) * df.index.hour))\n        df[\"month_x\"] = np.sin(np.radians((360/12) * df.index.month))\n        df[\"month_y\"] = np.cos(np.radians((360/12) * df.index.month))\n    \n\n        # add calendar-based variables as categorical data\n        # see https://colab.research.google.com/drive/1ZWpJY03xLIsUrlOzgTNHemKyLatMgKrp?usp=sharing#scrollTo=NJABd7ow5EHC\n        df[\"day_of_week\"] = df.index.weekday\n        df[\"hour_of_day\"] = df.index.hour\n        df[\"month_of_year\"] = df.index.month\n        df[\"weekend\"] = df.index.weekday.isin([5,6])\n        df= pd.get_dummies(df, columns=[\"day_of_week\", \"hour_of_day\", \"month_of_year\", \"weekend\"])\n\n        if bldg_name in self.building_datasets:\n            self.building_datasets[bldg_name] += [(year,df)]\n        else:\n            self.building_datasets[bldg_name] = [(year,df)]\n\n\n    def _prepare_data_transformer(self, bldg_name, df, year):\n        is_leap_year = True if year in self.leap_years else False            \n        time_transform = transforms.TimestampTransform(is_leap_year)\n        \n        df.rename(columns={df.columns[0]: 'load'}, inplace=True)\n        if self.apply_scaler_transform != '':\n            df['load'] = self.load_transform.transform(df['load'].values)\n\n        # create a column called \"latitude\" and \"longitude\" with the normalized lat/lon\n        # of the same shape as 'load'\n        df[\"latitude\"] = self.normalized_latlon[0] * np.ones(df.shape[0])\n        df[\"longitude\"] = self.normalized_latlon[1] * np.ones(df.shape[0])\n        \n\n        if self.building_type == BuildingTypes.RESIDENTIAL:\n            df[\"building_type\"] = BuildingTypes.RESIDENTIAL_INT * np.ones(df.shape[0])\n        elif self.building_type == BuildingTypes.COMMERCIAL:\n            df[\"building_type\"] = BuildingTypes.COMMERCIAL_INT * np.ones(df.shape[0])\n\n\n        time_features = time_transform.transform(df.index)\n        df[\"day_of_week\"] = time_features[:,1] * np.ones(df.shape[0])\n        df[\"hour_of_day\"] = time_features[:,2] * np.ones(df.shape[0])\n        df[\"day_of_year\"] = time_features[:, 0] * np.ones(df.shape[0])\n\n        if bldg_name in self.building_datasets:\n            self.building_datasets[bldg_name] += [(year,df)]\n        else:\n            self.building_datasets[bldg_name] = [(year,df)]\n\n\n    def __iter__(self) -> Iterator[Tuple[str, pd.DataFrame]]:\n        \"\"\"Generator for iterating over the dataset.\n\n        Yields:\n            A pair of building id and Pandas dataframe. \n                The dataframe has all years concatenated.    \n        \"\"\"\n        for building_id, building_dataset in self.building_datasets.items():\n            building_dataset = sorted(building_dataset, key=lambda x: x[0])\n            df = pd.concat([df[1] for df in building_dataset])\n            # fill missing values with 0\n            df = df.fillna(0) \n            yield (building_id, df)", "\n\nclass PandasTransformerDataset(torch.utils.data.Dataset):\n    \"\"\"Create a Torch Dataset out of a Pandas DataFrame.\n\n    Used to iterate over mini-batches of 192-hour sub-sequences.\n    \"\"\"\n    def __init__(self, \n                 df: pd.DataFrame,\n                 context_len: int = 168,\n                 pred_len: int = 24,\n                 sliding_window: int = 24):\n        \"\"\"\n        Args:\n            df (pd.DataFrame): Pandas DataFrame with columns: load, latitude, longitude, hour of day, day of week, day of year, building type\n            context_len (int, optional): Length of context.. Defaults to 168.\n            pred_len (int, optional): Length of prediction sequence for the forecasting model. Defaults to 24.\n            sliding_window (int, optional): Stride for sliding window to split timeseries into test samples. Defaults to 24.\n        \"\"\"\n        self.df = df\n        self.context_len = context_len\n        self.pred_len = pred_len\n        self.sliding_window = sliding_window\n\n    def __len__(self):\n        return (len(self.df) - self.context_len - self.pred_len) // self.sliding_window\n\n    def __getitem__(self, idx):\n        seq_ptr = self.context_len + self.sliding_window * idx\n        load_features = self.df['load'].iloc[seq_ptr-self.context_len : seq_ptr+self.pred_len].values.astype(np.float32)\n        building_features = self.df['building_type'].iloc[seq_ptr-self.context_len : seq_ptr+self.pred_len].values.astype(np.int32)\n        latlon_features = self.df[['latitude', 'longitude']].iloc[seq_ptr-self.context_len : seq_ptr+self.pred_len].values.astype(np.float32)\n        time_features = self.df[['day_of_year', 'day_of_week', 'hour_of_day']].iloc[seq_ptr-self.context_len : seq_ptr+self.pred_len].values.astype(np.float32)\n        sample = {\n            'latitude': latlon_features[:, 0][...,None],\n            'longitude': latlon_features[:, 1][...,None],\n            'day_of_year': time_features[:, 0][...,None],\n            'day_of_week': time_features[:, 1][...,None],\n            'hour_of_day': time_features[:, 2][...,None],\n            'building_type': building_features[...,None],\n            'load': load_features[...,None]\n        }\n        return sample", "\n\ndef keep_buildings(dataset_generator: Union[TorchBuildingDatasetsFromCSV, TorchBuildingDatasetFromParquet],\n                     building_ids: List[str]) -> Union[TorchBuildingDatasetsFromCSV, TorchBuildingDatasetFromParquet]:\n    \"\"\"Remove all buildings *not* listed in building_ids from the building_datasets dictionary from the generator class.\n    \n    Args:\n        dataset_generator (Union[TorchBuildingDatasetsFromCSV, TorchBuildingDatasetFromParquet]): Dataset generator class.\n        building_ids (List[str]): List of building ids to keep.\n    \n    Returns:\n        dataset_generator (Union[TorchBuildingDatasetsFromCSV, TorchBuildingDatasetFromParquet]): Dataset generator \n            class with only the buildings listed in building_ids.\n    \"\"\"\n    for building_id in list(dataset_generator.building_datasets.keys()):\n        if building_id not in building_ids:\n            del dataset_generator.building_datasets[building_id]\n    return dataset_generator", ""]}
{"filename": "buildings_bench/models/linear_regression.py", "chunked_list": ["import torch\nfrom buildings_bench.models.base_model import BaseModel\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport numpy as np\n\n\nclass LinearRegression(BaseModel):\n    \"\"\"Linear regression model that does direct forecasting.\n\n    It has one weight W and one bias b. The output is computed as\n    y = Wx + b, where W is a matrix of shape [pred_len, context_len].\n    \"\"\"\n    def __init__(self, context_len=168, pred_len=24, continuous_loads=True):\n        super(LinearRegression, self).__init__(context_len, pred_len, continuous_loads)\n        self.Linear = nn.Linear(context_len, pred_len)\n\n    def forward(self, x):\n        x = x['load'][:,:self.context_len,:]\n        # src_series: [Batch, Input length, 1]\n        x = self.Linear(x.permute(0,2,1)).permute(0,2,1)\n        return x # [Batch, Output length, 1]\n    \n    def loss(self, x, y):\n        return torch.nn.functional.mse_loss(x, y)\n    \n    def predict(self, x):\n        out = self.forward(x)\n        return out, None\n\n    def unfreeze_and_get_parameters_for_finetuning(self):\n        for p in self.parameters():\n            p.requires_grad = True        \n        return self.parameters()\n    \n    def load_from_checkpoint(self, checkpoint_path):\n        return None", ""]}
{"filename": "buildings_bench/models/persistence.py", "chunked_list": ["import torch\nfrom buildings_bench.models.base_model import BaseModel\n\n\nclass AveragePersistence(BaseModel):\n    \"\"\"Predict each hour as the average over each previous day.\n    \"\"\"\n    def __init__(self, context_len=168, pred_len=24, continuous_loads=True):\n        super().__init__(context_len, pred_len, continuous_loads)\n\n    def forward(self, x):\n        # [bsz x seqlen x 1]\n        src_series = x['load'][:,:self.context_len,:]\n\n        preds = []\n        stds = []\n        for i in range(self.pred_len):\n            preds += [ torch.mean(src_series[:,i::24,:], dim=1) ]\n            stds += [ torch.clamp(\n                torch.std(src_series[:,i::24,:], dim=1),\n                min=1e-3)]\n        return torch.cat([torch.stack(preds, 1), torch.stack(stds, 1)],2)\n    \n    def loss(self, x, y):\n        return x, y\n   \n    def predict(self, x):\n        out = self.forward(x)\n        return out[:,:,0].unsqueeze(-1), out\n\n    def unfreeze_and_get_parameters_for_finetuning(self):\n        return None\n    \n    def load_from_checkpoint(self, checkpoint_path):\n        return None", "    \n\nclass CopyLastDayPersistence(BaseModel):\n    \"\"\"Predict each hour as the same hour from the previous day.\n    \"\"\"\n    def __init__(self, context_len=168, pred_len=24, continuous_loads=True):\n        super().__init__(context_len, pred_len, continuous_loads)\n        assert self.context_len >= 24\n        assert self.pred_len >= 24\n\n    def forward(self, x):\n        # [bsz x seqlen x 1]\n        src_series = x['load'][:,:self.context_len,:]\n        return src_series[:, self.context_len-24:]\n    \n    def loss(self, x, y):\n        return x, y\n    \n    def predict(self, x):\n        return self.forward(x), None\n\n    def unfreeze_and_get_parameters_for_finetuning(self):\n        return None\n    \n    def load_from_checkpoint(self, checkpoint_path):\n        return None", "\n\nclass CopyLastWeekPersistence(BaseModel):\n    \"\"\"Predict each hour as the same hour from the previous week.\n    \"\"\"\n    def __init__(self, context_len=168, pred_len=24, continuous_loads=True):\n        super().__init__(context_len, pred_len, continuous_loads)\n        assert self.context_len >= 168\n        assert self.pred_len >= 24\n\n    def forward(self, x):\n        # [bsz x seqlen x 1]\n        src_series = x['load'][:,:self.context_len,:]\n        return src_series[:, self.context_len-168 : self.context_len - 168 +24]\n\n    def loss(self, x, y):\n        return x, y\n    \n    def predict(self, x):\n        return self.forward(x), None\n    \n    def unfreeze_and_get_parameters_for_finetuning(self):\n        return None\n    \n    def load_from_checkpoint(self, checkpoint_path):\n        return None", ""]}
{"filename": "buildings_bench/models/__init__.py", "chunked_list": ["# buildings_bench.models\nimport torch\nfrom typing import Callable, Tuple, Dict\n\n# Import models here\nfrom buildings_bench.models.dlinear_regression import DLinearRegression\nfrom buildings_bench.models.linear_regression import LinearRegression\nfrom buildings_bench.models.transformers import LoadForecastingTransformer\nfrom buildings_bench.models.persistence import *\n", "from buildings_bench.models.persistence import *\n\n\n\nmodel_registry = {\n    'TransformerWithTokenizer-L': LoadForecastingTransformer,\n    'TransformerWithTokenizer-M': LoadForecastingTransformer,\n    'TransformerWithTokenizer-S': LoadForecastingTransformer,\n    'TransformerWithTokenizer-L-ignore-spatial': LoadForecastingTransformer,\n    'TransformerWithTokenizer-L-8192': LoadForecastingTransformer,", "    'TransformerWithTokenizer-L-ignore-spatial': LoadForecastingTransformer,\n    'TransformerWithTokenizer-L-8192': LoadForecastingTransformer,\n    'TransformerWithTokenizer-L-344': LoadForecastingTransformer,\n    'TransformerWithMSE': LoadForecastingTransformer,\n    'TransformerWithGaussian-L': LoadForecastingTransformer,\n    'TransformerWithGaussian-M': LoadForecastingTransformer,\n    'TransformerWithGaussian-S': LoadForecastingTransformer,\n    'AveragePersistence': AveragePersistence,\n    'CopyLastDayPersistence': CopyLastDayPersistence,\n    'CopyLastWeekPersistence': CopyLastWeekPersistence,", "    'CopyLastDayPersistence': CopyLastDayPersistence,\n    'CopyLastWeekPersistence': CopyLastWeekPersistence,\n    'LinearRegression': LinearRegression,\n    'DLinearRegression': DLinearRegression,\n\n    # Register your model here\n}\n\n\ndef model_factory(model_name: str, model_args: Dict) -> Tuple[torch.nn.Module, Callable, Callable]:\n    \"\"\"Instantiate and returns a model for the benchmark.\n\n    Returns the model itself,\n    the loss function to use, and the predict function.\n\n    The predict function should return a tuple of two tensors: \n    (point predictions, prediction distribution parameters) where\n    the distribution parameters may be, e.g., logits, or mean and variance.\n\n    Args:\n        model_name (str): Name of the model.\n        model_args (Dict): The keyword arguments for the model.\n    Returns:\n        model (torch.nn.Module): the instantiated model  \n        loss (Callable): loss function\n        predict (Callable): predict function\n    \"\"\"\n    assert model_name in model_registry.keys(), \\\n        f\"Model {model_name} not in registry: {model_registry.keys()}\"\n    \n    model = model_registry[model_name](**model_args)\n    loss = model.loss\n    predict = model.predict\n    return model, loss, predict", "\ndef model_factory(model_name: str, model_args: Dict) -> Tuple[torch.nn.Module, Callable, Callable]:\n    \"\"\"Instantiate and returns a model for the benchmark.\n\n    Returns the model itself,\n    the loss function to use, and the predict function.\n\n    The predict function should return a tuple of two tensors: \n    (point predictions, prediction distribution parameters) where\n    the distribution parameters may be, e.g., logits, or mean and variance.\n\n    Args:\n        model_name (str): Name of the model.\n        model_args (Dict): The keyword arguments for the model.\n    Returns:\n        model (torch.nn.Module): the instantiated model  \n        loss (Callable): loss function\n        predict (Callable): predict function\n    \"\"\"\n    assert model_name in model_registry.keys(), \\\n        f\"Model {model_name} not in registry: {model_registry.keys()}\"\n    \n    model = model_registry[model_name](**model_args)\n    loss = model.loss\n    predict = model.predict\n    return model, loss, predict", "\n"]}
{"filename": "buildings_bench/models/base_model.py", "chunked_list": ["import abc\nfrom typing import Tuple, Dict, Union\nfrom pathlib import Path\nimport torch\nimport torch.nn as nn\n\n\nclass BaseModel(nn.Module, metaclass=abc.ABCMeta):\n    \"\"\"Base class for all models.\"\"\"\n    def __init__(self, context_len, pred_len, continuous_loads):\n        \"\"\"Init method for BaseModel.\n\n        Args:\n            context_len (int): length of context window\n            pred_len (int): length of prediction window\n            continuous_loads (bool): whether to use continuous load values\n        \"\"\"\n        super().__init__()\n        self.context_len = context_len\n        self.pred_len = pred_len\n        self.continuous_loads = continuous_loads\n\n    @abc.abstractmethod\n    def forward(self, x: Dict) -> Tuple[torch.Tensor, torch.Tensor]:\n        \"\"\"Forward pass. \n        \n        Expected keys in x:\n\n            - 'load': torch.Tensor of shape (batch_size, seq_len, 1)\n            - 'building_type': torch.LongTensor of shape (batch_size, seq_len, 1)\n            - 'day_of_year': torch.FloatTensor of shape (batch_size, seq_len, 1)\n            - 'hour_of_day': torch.FloatTensor of shape (batch_size, seq_len, 1)\n            - 'day_of_week': torch.FloatTensor of shape (batch_size, seq_len, 1)\n            - 'latitude': torch.FloatTensor of shape (batch_size, seq_len, 1)\n            - 'longitude': torch.FloatTensor of shape (batch_size, seq_len, 1)\n\n        Args:\n            x (Dict): dictionary of input tensors\n        Returns:\n            predictions, distribution parameters (Tuple[torch.Tensor, torch.Tensor]): outputs\n        \"\"\"\n        raise NotImplementedError()\n    \n\n    @abc.abstractmethod\n    def loss(self, x: torch.Tensor, y: torch.Tensor) -> torch.Tensor:\n        \"\"\"A function for computing the loss.\n        \n        Args:\n            x (torch.Tensor): preds of shape (batch_size, seq_len, 1)\n            y (torch.Tensor): targets of shape (batch_size, seq_len, 1)\n        Returns:\n            loss (torch.Tensor): scalar loss\n        \"\"\"\n        raise NotImplementedError()\n\n    @abc.abstractmethod \n    def predict(self, x: Dict) -> Tuple[torch.Tensor, torch.Tensor]:\n        \"\"\"A function for making a forecast on x with the model.\n\n        Args:\n            x (Dict): dictionary of input tensors\n        Returns:\n            predictions (torch.Tensor): of shape (batch_size, pred_len, 1)\n            distribution_parameters (torch.Tensor): of shape (batch_size, pred_len, -1)\n        \"\"\"\n        raise NotImplementedError()\n\n\n    @abc.abstractmethod\n    def unfreeze_and_get_parameters_for_finetuning(self):\n        \"\"\"For transfer learning. \n        \n        - Set requires_grad=True for parameters being fine-tuned (if necessary)\n        - Return the parameters that should be fine-tuned.\n        \"\"\"\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    def load_from_checkpoint(self, checkpoint_path: Union[str, Path]):\n        \"\"\"Describes how to load the model from checkpoint_path.\"\"\"\n        raise NotImplementedError()", ""]}
{"filename": "buildings_bench/models/transformers.py", "chunked_list": ["import math\nimport torch\nfrom typing import Tuple, Dict\nfrom torch import nn\nimport torch.nn.functional as F\nfrom torch.nn import Transformer\nimport numpy as np\nfrom buildings_bench.models.base_model import BaseModel\n\n\nclass TokenEmbedding(nn.Module):\n    \"\"\"Helper Module to convert tensor of input\n       indices into corresponding tensor of token embeddings.\n    \"\"\"\n    def __init__(self, vocab_size: int, emb_size: int):\n        \"\"\"\n        Args:\n            vocab_size (int): number of quantized load values in the entire vocabulary.\n            emb_size (int): embedding size.\n        \"\"\"\n        super(TokenEmbedding, self).__init__()\n        self.embedding = nn.Embedding(vocab_size, emb_size)\n        self.emb_size = emb_size\n\n    def forward(self, tokens: torch.Tensor):\n        return self.embedding(tokens.long()) * math.sqrt(self.emb_size)", "\n\nclass TokenEmbedding(nn.Module):\n    \"\"\"Helper Module to convert tensor of input\n       indices into corresponding tensor of token embeddings.\n    \"\"\"\n    def __init__(self, vocab_size: int, emb_size: int):\n        \"\"\"\n        Args:\n            vocab_size (int): number of quantized load values in the entire vocabulary.\n            emb_size (int): embedding size.\n        \"\"\"\n        super(TokenEmbedding, self).__init__()\n        self.embedding = nn.Embedding(vocab_size, emb_size)\n        self.emb_size = emb_size\n\n    def forward(self, tokens: torch.Tensor):\n        return self.embedding(tokens.long()) * math.sqrt(self.emb_size)", "\n\nclass PositionalEncoding(nn.Module):\n    \"\"\"Helper Module that adds positional encoding to the token embedding to\n       introduce a notion of order within a time-series.\n    \"\"\"\n    def __init__(self,\n                 emb_size: int,\n                 dropout: float,\n                 maxlen: int = 500):\n        \"\"\"\n        Args:\n            emb_size (int): embedding size.\n            dropout (float): dropout rate.\n            maxlen (int): maximum possible length of the incoming time series.\n        \"\"\"\n        super(PositionalEncoding, self).__init__()\n        den = torch.exp(- torch.arange(0, emb_size, 2)* math.log(10000) / emb_size)\n        pos = torch.arange(0, maxlen).reshape(maxlen, 1)\n        pos_embedding = torch.zeros((maxlen, emb_size))\n        pos_embedding[:, 0::2] = torch.sin(pos * den)\n        pos_embedding[:, 1::2] = torch.cos(pos * den)\n        pos_embedding = pos_embedding.unsqueeze(-2)\n\n        self.dropout = nn.Dropout(dropout)\n        self.register_buffer('pos_embedding', pos_embedding)\n\n    def forward(self, token_embedding: torch.Tensor) -> torch.Tensor:\n        # batch first - use size(1)\n        # need to permute token embeddings from [batch_size, seqlen x emb_size] to [seqlen x batch_size, emb_size]\n        return self.dropout(token_embedding.permute(1,0,2) + self.pos_embedding[:token_embedding.size(1), :]).permute(1,0,2)", "\n\nclass TimeSeriesSinusoidalPeriodicEmbedding(nn.Module):\n    \"\"\"This module produces a sinusoidal periodic embedding for a sequence of values in [-1, +1].\"\"\"\n    def __init__(self, embedding_dim: int) -> None:\n        \"\"\"\n        Args:\n            embedding_dim (int): embedding size.\n        \"\"\"\n        super().__init__()\n        self.linear = nn.Linear(2, embedding_dim)\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        \"\"\"`x` is expected to be [batch_size, seqlen, 1].\"\"\"\n        with torch.no_grad():\n            x = torch.cat([torch.sin(np.pi * x), torch.cos(np.pi * x)], dim=2)\n        # [batch_size, seqlen x 2] --> [batch_size, seqlen, embedding_dim]\n        return self.linear(x)", "\n\nclass ZeroEmbedding(nn.Module):\n    \"\"\" Outputs zeros of the desired output dim.\"\"\"\n    def __init__(self, embedding_dim: int): \n        \"\"\"\n        Args:\n            embedding_dim (int): embedding size.\n        \"\"\"\n        super().__init__()\n        self.embedding_dim = embedding_dim\n        self.zeros_embedding = nn.Parameter(\n            torch.zeros(1, 1, embedding_dim), requires_grad=False)\n        \n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        \"\"\" `x` is expected to be [batch_size, seqlen, 1].\"\"\"\n        return self.zeros_embedding.repeat(x.shape[0], x.shape[1], 1)", "    \n\nclass LoadForecastingTransformer(BaseModel):\n    \"\"\"\n    An encoder-decoder time series Transformer. Based on PyTorch nn.Transformer.\n\n    - Uses masking in the decoder to prevent the model from peeking into the future\n    - Uses N(0, 0.02) for weight initialization\n    - Trains with teacher forcing (i.e. the target is used as the input to the decoder)\n    - continuous_loads (True) just predict target values\n                     (False) categorical over quantized load values\n    \"\"\"\n    def __init__(self,\n                 context_len: int = 168,\n                 pred_len: int = 24,\n                 vocab_size = 2274,\n                 num_encoder_layers: int = 3,\n                 num_decoder_layers: int = 3,\n                 d_model: int = 256,\n                 nhead: int = 8,\n                 dim_feedforward: int = 256,\n                 dropout: float = 0.0,\n                 activation: str = 'gelu',\n                 continuous_loads = False,\n                 continuous_head = 'mse',\n                 ignore_spatial = False):\n        \"\"\"\n        Args:\n            context_len (int): length of the input sequence.\n            pred_len (int): length of the output sequence.\n            vocab_size (int): number of quantized load values in the entire vocabulary.\n            num_encoder_layers (int): number of encoder layers.\n            num_decoder_layers (int): number of decoder layers.\n            d_model (int): number of expected features in the encoder/decoder inputs.\n            nhead (int): number of heads in the multi-head attention models.\n            dim_feedforward (int): dimension of the feedforward network model.\n            dropout (float): dropout value.\n            activation (str): the activation function of encoder/decoder intermediate layer, relu or gelu.\n            continuous_loads (bool): whether inputs are continuous/to train the model to predict continuous values.\n            continuous_head (str): 'mse' or 'gaussian_nll'.\n            ignore_spatial (bool): whether to ignore the spatial features.\n        \"\"\"\n        super().__init__(context_len, pred_len, continuous_loads)\n        \n        self.continuous_head = continuous_head\n        self.vocab_size = vocab_size\n        self.ignore_spatial = ignore_spatial\n        s = d_model // 256\n\n        self.transformer = Transformer(d_model=d_model,\n                                       nhead=nhead,\n                                       num_encoder_layers=num_encoder_layers,\n                                       num_decoder_layers=num_decoder_layers,\n                                       dim_feedforward=dim_feedforward,\n                                       dropout=dropout,\n                                       activation=activation,\n                                       batch_first=True)\n\n        if self.continuous_loads:\n            out_dim = 1 if self.continuous_head == 'mse' else 2\n            self.logits = nn.Linear(d_model, out_dim)\n            self.power_embedding = nn.Linear(1, 64 * s)\n        else:\n            self.logits = nn.Linear(d_model, self.vocab_size)\n            self.power_embedding = TokenEmbedding(self.vocab_size, 64 * s)\n        self.tgt_mask = self.transformer.generate_square_subsequent_mask(self.pred_len)\n        self.positional_encoding = PositionalEncoding(\n            d_model, dropout=dropout)\n        self.building_embedding = nn.Embedding(2, 32 * s)\n        self.lat_embedding = nn.Linear(1, 32 * s)\n        self.lon_embedding = nn.Linear(1, 32 * s)\n        if self.ignore_spatial:\n            self.lat_embedding = ZeroEmbedding(32 * s)\n            self.lon_embedding = ZeroEmbedding(32 * s)\n        self.day_of_year_encoding = TimeSeriesSinusoidalPeriodicEmbedding(32 * s) \n        self.day_of_week_encoding = TimeSeriesSinusoidalPeriodicEmbedding(32 * s)\n        self.hour_of_day_encoding = TimeSeriesSinusoidalPeriodicEmbedding(32 * s)\n        \n    def to(self, device):\n        self.tgt_mask = self.tgt_mask.to(device)\n        return super().to(device)\n\n    def forward(self, x):\n        r\"\"\"Forward pass of the time series transformer. \n\n        Args:\n            x (Dict): dictionary of input tensors.\n        Returns:\n            logits (torch.Tensor): [batch_size, pred_len, vocab_size] if not continuous_loads,\n                                   [batch_size, pred_len, 1] if continuous_loads and continuous_head == 'mse', \n                                   [batch_size, pred_len, 2] if continuous_loads and continuous_head == 'gaussian_nll'.\n        \"\"\"\n        # [batch_size, seq_len, d_model]\n        time_series_embed = torch.cat([\n            self.lat_embedding(x['latitude']),\n            self.lon_embedding(x['longitude']),\n            self.building_embedding(x['building_type']).squeeze(2),\n            self.day_of_year_encoding(x['day_of_year']),\n            self.day_of_week_encoding(x['day_of_week']),\n            self.hour_of_day_encoding(x['hour_of_day']),\n            self.power_embedding(x['load']).squeeze(2),\n        ], dim=2)\n        # [batch_size, context_len, d_model]\n        src_series_inputs = time_series_embed[:, :self.context_len, :]\n        # [batch_size, pred_len, d_model]\n        # The last element of the target sequence is not used as input\n        # The last element of the source sequence is used as the initial decoder input\n        tgt_series_inputs = time_series_embed[:, self.context_len-1 : -1, :]\n        src_series_embed = self.positional_encoding(src_series_inputs)\n        tgt_series_embed = self.positional_encoding(tgt_series_inputs) \n\n        # The output of TransformerEncoder is the sequence from the last layer\n        # The shape will be [batch_size, context_len, d_model]\n        \n        memory = self.transformer.encoder(src_series_embed, mask=None)\n        outs = self.transformer.decoder(tgt_series_embed, memory, tgt_mask=self.tgt_mask)\n        return self.logits(outs)\n\n    def predict(self, x: Dict) -> Tuple[torch.Tensor, torch.Tensor]:\n        return self.generate_sample(x, greedy=True)\n    \n    def loss(self, x, y):\n        if self.continuous_loads and self.continuous_head == 'mse':\n            return F.mse_loss(x, y)\n        elif self.continuous_loads and self.continuous_head == 'gaussian_nll':\n            return F.gaussian_nll_loss(x[:, :, 0].unsqueeze(2), y,\n                                       F.softplus(x[:, :, 1].unsqueeze(2)) **2)\n        else:\n            return F.cross_entropy(x.reshape(-1, self.vocab_size),\n                                             y.long().reshape(-1))\n                    \n    def unfreeze_and_get_parameters_for_finetuning(self):\n        # for p in self.parameters():\n        #     p.requires_grad_(False)\n        # self.logits.requires_grad_(True)\n        # return self.logits.parameters()\n        return self.parameters()\n\n    def load_from_checkpoint(self, checkpoint_path):\n        stored_ckpt = torch.load(checkpoint_path)\n        model_state_dict = stored_ckpt['model']\n        new_state_dict = {}\n        for k,v in model_state_dict.items():\n            # remove string 'module.' from the key\n            if 'module.' in k:\n                new_state_dict[k.replace('module.', '')] = v\n            else:\n                new_state_dict[k] = v\n        self.load_state_dict(new_state_dict)    \n        print(f\"Loaded model checkpoint from {checkpoint_path}...\")\n    \n\n    @torch.no_grad()\n    def generate_sample(self, \n                 x,\n                 temperature=1.0,\n                 greedy=False,\n                 num_samples=1):\n        \"\"\"Sample from the conditional distribution.\n\n        Use output of decoder at each prediction step as input to the next decoder step.\n        Implements greedy decoding and random temperature-controlled sampling.\n        \n        Top-k sampling and nucleus sampling are deprecated.\n\n        Args:\n            x (Dict): dictionary of input tensors\n            temperature (float): temperature for sampling\n            greedy (bool): whether to use greedy decoding\n            num_samples (int): number of samples to generate\n        \n        Returns:\n            predictions (torch.Tensor): of shape [batch_size, pred_len, 1] or shape [batch_size, num_samples, pred_len] if num_samples > 1.\n            distribution_parameters (torch.Tensor): of shape [batch_size, pred_len, 1]. Not returned if sampling.\n        \"\"\"\n        time_series_embed = torch.cat([\n            self.lat_embedding(x['latitude']),\n            self.lon_embedding(x['longitude']),\n            self.building_embedding(x['building_type']).squeeze(2),\n            self.day_of_year_encoding(x['day_of_year']),\n            self.day_of_week_encoding(x['day_of_week']),\n            self.hour_of_day_encoding(x['hour_of_day']),\n            self.power_embedding(x['load']).squeeze(2),\n        ], dim=2)\n        # [batch_size, context_len, d_model]\n        src_series_inputs = time_series_embed[:, :self.context_len, :]\n        tgt_series_inputs = time_series_embed[:, self.context_len-1 : -1, :]\n        src_series_embed = self.positional_encoding(src_series_inputs)\n\n        encoder_output = self.transformer.encoder(src_series_embed)\n        decoder_input = tgt_series_inputs[:, 0, :].unsqueeze(1)\n        if num_samples > 1 and not greedy:\n            # [batch_size, 1, emb_size] --> [batch_size * num_sampes, 1, emb_size]\n            decoder_input = decoder_input.repeat_interleave(num_samples, dim=0)\n            encoder_output = encoder_output.repeat_interleave(num_samples, dim=0)\n        all_preds, all_logits = [], []\n        for k in range(1, self.pred_len+1):\n            decoder_embed = self.positional_encoding(decoder_input)\n            tgt_mask = self.transformer.generate_square_subsequent_mask(k)\n            decoder_output = self.transformer.decoder(decoder_embed, encoder_output, tgt_mask.to(encoder_output.device))\n            # [batch_size, 1] if continuous (2 if head is gaussian_nll) or [batch_size, vocab_size] if not continuous_loads\n            outputs = self.logits(decoder_output[:, -1, :])\n            all_logits += [outputs.unsqueeze(1)]\n\n            if self.continuous_loads:\n                if self.continuous_head == 'mse':\n                    all_preds += [outputs] \n                elif self.continuous_head == 'gaussian_nll':\n                    if greedy:\n                        all_preds += [outputs[:, 0].unsqueeze(1)] # mean only\n                        outputs = all_preds[-1] # [batch_size, 1, 1]\n                    else:\n                        mean = outputs[:,0]\n                        std= torch.nn.functional.softplus(outputs[:,1])\n                        outputs = torch.distributions.normal.Normal(mean, std).sample().unsqueeze(1)\n                        all_preds += [outputs]    \n\n            elif not greedy:\n                # Sample from a Categorical distribution with logits outputs\n                all_preds += [torch.multinomial(torch.nn.functional.softmax(outputs/temperature, dim=1), 1)]\n                # change outputs to the predicted load tokens\n                outputs = all_preds[-1] # [batch_size * num_samples, 1]\n            else:\n                # outputs are [batch_size, vocab_size]\n                # Greedy decoding\n                all_preds += [outputs.argmax(dim=1).unsqueeze(1)]\n                # change outputs to the predicted load tokens\n                outputs = all_preds[-1]\n                \n            # [batch_size, d_model]\n            if k < self.pred_len:\n                # [batch_size, d_model]\n                next_decoder_input = tgt_series_inputs[:, k]\n                if num_samples > 1 and not greedy:\n                    # [batch_size, d_model] --> [batch_size * num_samples, d_model]\n                    next_decoder_input = next_decoder_input.repeat_interleave(num_samples, dim=0)\n                # Use the embedding predicted load instead of the ground truth load\n                embedded_pred = self.power_embedding(outputs)  \n                if not self.continuous_loads:\n                    # [batch_size, 1, 1, 64*s] --> [batch_size, 64*s]\n                    embedded_pred = embedded_pred.squeeze(2).squeeze(1)\n                next_decoder_input = torch.cat([ next_decoder_input[:, :-embedded_pred.shape[-1]], embedded_pred ], dim=1)\n                # Append the next decoder input to the decoder input\n                decoder_input = torch.cat([decoder_input, next_decoder_input.unsqueeze(1)], dim=1)\n        if num_samples == 1 or greedy:\n            if self.continuous_head == 'gaussian_nll':\n                # [batch_size, pred_len, 2]\n                gaussian_params = torch.stack(all_logits,1)[:,:,0,:]\n                means = gaussian_params[:,:,0]\n                sigma = torch.nn.functional.softplus(gaussian_params[:,:,1])\n                return torch.stack(all_preds,1), torch.cat([means.unsqueeze(2), sigma.unsqueeze(2)],2)\n            else:\n                return torch.stack(all_preds,1), torch.stack(all_logits,1)[:,:,0,:]\n        else:\n            # [batch_size, num_samples, pred_len]\n            return torch.stack(all_preds,1).reshape(-1, num_samples, self.pred_len)"]}
{"filename": "buildings_bench/models/dlinear_regression.py", "chunked_list": ["import torch\nfrom buildings_bench.models.base_model import BaseModel\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport numpy as np\n\n\nclass moving_avg(nn.Module):\n    \"\"\"Moving average block to highlight the trend of time series\n    \"\"\"\n    def __init__(self, kernel_size, stride):\n        super(moving_avg, self).__init__()\n        self.kernel_size = kernel_size\n        self.avg = nn.AvgPool1d(kernel_size=kernel_size, stride=stride, padding=0)\n\n    def forward(self, x):\n        # padding on the both ends of time series\n        front = x[:, 0:1, :].repeat(1, (self.kernel_size - 1) // 2, 1)\n        end = x[:, -1:, :].repeat(1, (self.kernel_size - 1) // 2, 1)\n        x = torch.cat([front, x, end], dim=1)\n        x = self.avg(x.permute(0, 2, 1))\n        x = x.permute(0, 2, 1)\n        return x", "\n\nclass series_decomp(nn.Module):\n    \"\"\"Series decomposition block\n    \"\"\"\n    def __init__(self, kernel_size):\n        super(series_decomp, self).__init__()\n        self.moving_avg = moving_avg(kernel_size, stride=1)\n\n    def forward(self, x):\n        moving_mean = self.moving_avg(x)\n        res = x - moving_mean\n        return res, moving_mean", "\nclass DLinearRegression(BaseModel):\n    \"\"\"\n    Decomposition-Linear\n    \"\"\"\n    def __init__(self,context_len=168, pred_len=24, continuous_loads=True):\n        super(DLinearRegression, self).__init__(context_len, pred_len, continuous_loads)\n\n        # Decompsition Kernel Size\n        kernel_size = 25\n        self.decompsition = series_decomp(kernel_size)\n        # self.individual = True\n        # self.channels = 1\n       \n        self.Linear_Seasonal = nn.Linear(context_len, self.pred_len)\n        self.Linear_Trend = nn.Linear(context_len, self.pred_len)\n        \n            # Use this two lines if you want to visualize the weights\n            # self.Linear_Seasonal.weight = nn.Parameter((1/self.seq_len)*torch.ones([self.pred_len,self.seq_len]))\n            # self.Linear_Trend.weight = nn.Parameter((1/self.seq_len)*torch.ones([self.pred_len,self.seq_len]))\n\n    def forward(self, x):\n        # x: [Batch, Input length, Channel]\n        src_series = x['load'][:,:self.context_len,:]\n        seasonal_init, trend_init = self.decompsition(src_series)\n        seasonal_init, trend_init = seasonal_init.permute(0,2,1), trend_init.permute(0,2,1)\n    \n        seasonal_output = self.Linear_Seasonal(seasonal_init)\n        trend_output = self.Linear_Trend(trend_init)\n\n        x = seasonal_output + trend_output\n        return x.permute(0,2,1) # to [Batch, Output length, Channel]\n    \n    def loss(self, x, y):\n        return torch.nn.functional.mse_loss(x,y)\n    \n    def predict(self, x):\n        return self.forward(x), None\n\n    def unfreeze_and_get_parameters_for_finetuning(self):\n        for p in self.parameters():\n            p.requires_grad = True\n        return self.parameters()\n    \n    def load_from_checkpoint(self, checkpoint_path):\n        return None", ""]}
