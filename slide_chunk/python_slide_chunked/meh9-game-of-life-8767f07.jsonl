{"filename": "python3/game_of_life.py", "chunked_list": ["\"\"\"Simple Conway's Game of Life implementation.\"\"\"\n\nfrom argparse import ArgumentParser, Namespace\nfrom gameoflife import MainGame\n\n\ndef main() -> None:\n    \"\"\"Run the game.\"\"\"\n    parser: ArgumentParser = ArgumentParser(description=\"Conway's Game of Life\")\n    parser.add_argument(\n        \"-f\",\n        \"--file\",\n        # don't use FileType here - we want a str to use a context manager with later\n        nargs=1,\n        help=\"specify a file to read initial cells from\",\n    )\n    parser.add_argument(\n        \"-w\",\n        \"--wrap\",\n        default=False,\n        action=\"store_true\",\n        help=\"change the default from using an infinite universe to instead use a universe of a \"\n        + \"fixed size which wraps around the edges, the fixed size universe will default to the \"\n        + \"size of the terminal on start and cannot be changed later\",\n    )\n    parser.add_argument(\n        \"-r\",\n        \"--rows\",\n        default=[0],\n        type=int,\n        nargs=1,\n        help=\"specify the number of rows to use when using --wrap - default is terminal height\",\n    )\n    parser.add_argument(\n        \"-c\",\n        \"--cols\",\n        default=[0],\n        type=int,\n        nargs=1,\n        help=\"specify the number of columns to use when using --wrap - default is terminal width\",\n    )\n    args: Namespace = parser.parse_args()\n    if not args.wrap and (args.rows[0] or args.cols[0]):\n        raise ValueError(\"Do not specify --rows or --cols without --wrap\")\n    file: str = args.file[0] if args.file else \"\"\n    MainGame(args.wrap, file, args.rows[0], args.cols[0]).main()", "\n\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "python3/gameoflife/main.py", "chunked_list": ["\"\"\"The main game control and run loop.\"\"\"\n\n# from sys import exit as sysexit\nfrom datetime import datetime\nfrom math import floor\nfrom os.path import isfile\nfrom time import perf_counter_ns\nfrom blessed import Terminal  # type:ignore\nfrom blessed.keyboard import Keystroke  # type:ignore\nfrom gameoflife import GameOfLife, GameOfLifeSet, GameOfLifeArrays", "from blessed.keyboard import Keystroke  # type:ignore\nfrom gameoflife import GameOfLife, GameOfLifeSet, GameOfLifeArrays\nfrom gameoflife.dataio.create_io import create_reader, create_writer\n\n\nclass MainGame:\n    \"\"\"Manage the game.\"\"\"\n\n    HEADER_ROWS: int = 2\n    FOOTER_ROWS: int = 8", "    HEADER_ROWS: int = 2\n    FOOTER_ROWS: int = 8\n\n    def __init__(\n        self, wrap: bool, file: str = \"\", wrap_rows: int = 0, wrap_cols: int = 0\n    ) -> None:\n        \"\"\"Initialise the game.\"\"\"\n        self._run: bool = True  # keep looping as long as this is true\n        self._wrap: bool = wrap\n        self._automatic: bool = False  # loop automatically and continuously when true", "        self._wrap: bool = wrap\n        self._automatic: bool = False  # loop automatically and continuously when true\n        self._sleep_time: float = 0.25  # seconds to sleep between loops in automatic\n        self._origin_row: int = 0  # top row of the game view of the universe\n        self._origin_col: int = 0  # left most cell of the game view of the universe\n        self._term_width: int = 0  # save term width/height to detect if it changes\n        self._term_height: int = 0\n        self._header_loc: int = 0  # track the header location for moving it\n        self._header_dir_left: bool = False\n        self._edit_mode = False  # are editing right now?", "        self._header_dir_left: bool = False\n        self._edit_mode = False  # are editing right now?\n        self._last_edit_location: tuple[int, int]  # save where the cursor was last\n        self._t = Terminal()\n\n        # infinite or wrapping universe\n        if wrap:\n            height: int = (\n                wrap_rows\n                if wrap_rows", "                wrap_rows\n                if wrap_rows\n                else self._t.height - MainGame.HEADER_ROWS - MainGame.FOOTER_ROWS\n            )\n            width: int = wrap_cols if wrap_cols else floor((self._t.width + 1) / 2)\n            self._gol: GameOfLife = GameOfLifeArrays(height, width)\n        else:\n            self._gol = GameOfLifeSet()\n\n        if file:", "\n        if file:\n            with create_reader(file) as reader:\n                self._gol.add_cells(reader)\n\n    def main(self) -> None:\n        \"\"\"Run the main game loop.\"\"\"\n        # centre the initial board\n        # for now, disable this and just default to terminal 0,0 == game 0,0\n        # # TO DO: do a better job of putting the initial board in the centre", "        # for now, disable this and just default to terminal 0,0 == game 0,0\n        # # TO DO: do a better job of putting the initial board in the centre\n        # # one way is actually to put the initial cells in the centre as opposed to the board\n        # # For now, place 0,0 of the game board in the centre of the view.\n        # # This defines the View of the board in the coordinates of the board.\n        # # Another way to think of it is the origin_row/col defines how far away in board coords\n        # # the top left corner of the View is from 0,0 of the board.\n        # self._origin_row = 0 - floor(\n        #     (self._t.height - MainGame.HEADER_ROWS - MainGame.FOOTER_ROWS) / 2\n        # )", "        #     (self._t.height - MainGame.HEADER_ROWS - MainGame.FOOTER_ROWS) / 2\n        # )\n        # divide in half again because we only print every other col\n        # self._origin_col = 0 - floor(self._t.width / 2 / 2)\n\n        # run the game\n        with self._t.fullscreen(), self._t.cbreak():  # , term.hidden_cursor():\n            while self._run:  # pragma: no cover\n                # check if we need to clear screen and refresh - will always happen first runthrough\n                if (", "                # check if we need to clear screen and refresh - will always happen first runthrough\n                if (\n                    self._term_width != self._t.width\n                    or self._term_height != self._t.height\n                ):\n                    self.update_screen_size()\n\n                # print the game cells, taking care not to print over the bottom text\n                self.print_game()\n", "                self.print_game()\n\n                # handle any potential keystrokes\n                if self._automatic:\n                    # progress the game a generation\n                    start: int = perf_counter_ns()\n                    live_count: int = self._gol.progress()\n                    last_gen_time: int = perf_counter_ns() - start\n                    # update the UI to reflect any changes\n                    self.print_ui_update(True, live_count, last_gen_time)", "                    # update the UI to reflect any changes\n                    self.print_ui_update(True, live_count, last_gen_time)\n                    self.process_keystroke(False)\n                else:\n                    # only progress the game if the user asked for it\n                    if self.process_keystroke(True):\n                        start = perf_counter_ns()\n                        live_count = self._gol.progress()\n                        last_gen_time = perf_counter_ns() - start\n                        # update the UI to reflect any changes", "                        last_gen_time = perf_counter_ns() - start\n                        # update the UI to reflect any changes\n                        self.print_ui_update(True, live_count, last_gen_time)\n\n    def update_screen_size(self) -> None:\n        \"\"\"Update the screen size on first run, or when the terminal size has changed.\"\"\"\n        self._term_width = self._t.width\n        self._term_height = self._t.height\n        # reset cursor and clear the screen\n        print(self._t.home + self._t.clear, end=\"\")", "        # reset cursor and clear the screen\n        print(self._t.home + self._t.clear, end=\"\")\n        # print out the minimal game UI\n        self.print_ui()\n        self._header_loc = floor(self._t.width / 2)\n        self.print_ui_update(False, self._gol.count_live_cells())\n        # init last edit location to be centre of view\n        row: int = (\n            floor(\n                # calculate the number of game rows in the view", "            floor(\n                # calculate the number of game rows in the view\n                (self._t.height - MainGame.HEADER_ROWS - MainGame.FOOTER_ROWS)\n                # find the centre of the game rows\n                / 2\n            )\n            # turn into 0-indexed terminal row\n            - 1\n            # offset down by HEADER_ROWS\n            + MainGame.HEADER_ROWS", "            # offset down by HEADER_ROWS\n            + MainGame.HEADER_ROWS\n        )\n        # find the centre of the terminal view, turn into 0-index terminal col\n        col: int = floor(self._t.width / 2) - 1\n        # column has to be even number as we only print cells in even columns\n        col = col if col % 2 == 0 else col - 1\n        self._last_edit_location = (row, col)\n\n    def process_keystroke(self, block: bool) -> bool:  # pragma: no cover", "\n    def process_keystroke(self, block: bool) -> bool:  # pragma: no cover\n        \"\"\"\n        Wait for a keystroke (with optional timeout) and process it.\n\n        Return if the game should be progressed a generation due to user input.\n        \"\"\"\n        # either block waiting for a keystroke or wait for sleep_time seconds\n        # actually only block for a short while, then fall through, causing the screen to refresh\n        # this deals with the terminal resizing", "        # actually only block for a short while, then fall through, causing the screen to refresh\n        # this deals with the terminal resizing\n        key: Keystroke = (\n            self._t.inkey(0.1) if block else self._t.inkey(timeout=self._sleep_time)\n        )\n\n        # process any potential key\n        if key.is_sequence:\n            match key.code:\n                case self._t.KEY_ESCAPE:", "            match key.code:\n                case self._t.KEY_ESCAPE:\n                    self._run = False\n                case self._t.KEY_UP:\n                    self._move_up()\n                case self._t.KEY_DOWN:\n                    self._move_down()\n                case self._t.KEY_LEFT:\n                    self._move_left()\n                case self._t.KEY_RIGHT:", "                    self._move_left()\n                case self._t.KEY_RIGHT:\n                    self._move_right()\n                case _:\n                    pass  # do nothing with unrecognised keys\n        else:\n            match key:\n                case \" \":\n                    if self._edit_mode:\n                        self._toggle_cell_state()", "                    if self._edit_mode:\n                        self._toggle_cell_state()\n                    else:\n                        # progress the game a generation\n                        return True\n                case \"a\":\n                    if not self._edit_mode:\n                        self._automatic = not self._automatic\n                case \"e\":\n                    self._toggle_edit_mode()", "                case \"e\":\n                    self._toggle_edit_mode()\n                case \"q\":\n                    self._run = False\n                case \"s\":\n                    self._save_game()\n                case \"+\" | \"=\" | \"]\":  # also accept \"=\" so we don't have use shift all the time\n                    self._increase_speed()\n                case \"-\" | \"[\":\n                    self._decrease_speed()", "                case \"-\" | \"[\":\n                    self._decrease_speed()\n                case _:\n                    pass  # do nothing with unrecognised keys\n        return False\n\n    def _save_game(self) -> None:  # pragma: no cover\n        \"\"\"Save the game to a file.\"\"\"\n        # clear any previous status message; it's a nasty hack to just clear a fixed width...\n        with self._t.location(0, self._t.height - 1):", "        # clear any previous status message; it's a nasty hack to just clear a fixed width...\n        with self._t.location(0, self._t.height - 1):\n            print(\" \" * 80, end=\"\")\n        self._automatic = False  # if we are running, stop\n        filename: str = self._prompt(\"Save game to path/filename: \")\n        if filename:\n            if isfile(filename):\n                if \"y\" != self._prompt(\n                    f\"File {filename} already exists, overwrite? (y/n): \"\n                ):", "                    f\"File {filename} already exists, overwrite? (y/n): \"\n                ):\n                    return\n            outcome: str\n            try:\n                with create_writer(filename) as writer:\n                    writer.write([], self._gol.get_live_cells())\n                timestamp: str = datetime.now().strftime(\"%H:%M:%S\")\n                outcome = f\"Saved game to file '{filename}' at {timestamp}\"\n            except ValueError as _:", "                outcome = f\"Saved game to file '{filename}' at {timestamp}\"\n            except ValueError as _:\n                outcome = \"Incorrect file extension - please use '.cells'\"\n            with self._t.location(0, self._t.height - 1):\n                print(outcome, end=\"\")\n\n    def _prompt(self, message: str) -> str:  # pragma: no cover\n        \"\"\"Prompt the user for input and return their input.\"\"\"\n        response: str = \"\"\n        # move down to the bottom of the screen", "        response: str = \"\"\n        # move down to the bottom of the screen\n        with self._t.location(0, self._t.height - 1):\n            print(message, flush=True, end=\"\")\n            stop: bool = False\n            while not stop:\n                save_key: Keystroke = self._t.inkey()\n                if save_key.is_sequence:\n                    match save_key.code:\n                        case self._t.KEY_ENTER:", "                    match save_key.code:\n                        case self._t.KEY_ENTER:\n                            stop = True\n                        case self._t.KEY_BACKSPACE | self._t.KEY_DELETE:\n                            if response:\n                                print(\n                                    self._t.move_left + \" \" + self._t.move_left,\n                                    flush=True,\n                                    end=\"\",\n                                )", "                                    end=\"\",\n                                )\n                                response = response[:-1]\n                        case _:\n                            pass  # do nothing with unrecognised keys\n                else:\n                    response += save_key\n                    print(save_key, flush=True, end=\"\")\n            print(self._t.clear_bol, end=\"\")\n        return response", "            print(self._t.clear_bol, end=\"\")\n        return response\n\n    def _move_left(self) -> None:  # pragma: no cover\n        \"\"\"Move the view or edit cursor left.\"\"\"\n        # check if we are at the left edge of the view and need to scroll instead\n        col: int = self._t.get_location()[1]\n        if self._edit_mode and col > 0:\n            print(self._t.move_left(2), end=\"\")\n        else:", "            print(self._t.move_left(2), end=\"\")\n        else:\n            self._origin_col -= 1\n        self.print_ui_update(False, self._gol.count_live_cells())\n\n    def _move_right(self) -> None:  # pragma: no cover\n        \"\"\"Move the view or edit cursor right.\"\"\"\n        # check if we are at the right edge of the view and need to scroll instead\n        col = self._t.get_location()[1]\n        if self._edit_mode and col + 2 < self._t.width:", "        col = self._t.get_location()[1]\n        if self._edit_mode and col + 2 < self._t.width:\n            print(self._t.move_right(2), end=\"\")\n        else:\n            self._origin_col += 1\n        self.print_ui_update(False, self._gol.count_live_cells())\n\n    def _move_down(self) -> None:  # pragma: no cover\n        \"\"\"Move the view or edit cursor down.\"\"\"\n        # check if we are at the bottom of the view and need to scroll instead", "        \"\"\"Move the view or edit cursor down.\"\"\"\n        # check if we are at the bottom of the view and need to scroll instead\n        row = self._t.get_location()[0]\n        if self._edit_mode and row + 1 < self._t.height - MainGame.FOOTER_ROWS:\n            print(self._t.move_down(1), end=\"\")\n        else:\n            self._origin_row += 1\n        self.print_ui_update(False, self._gol.count_live_cells())\n\n    def _move_up(self) -> None:  # pragma: no cover", "\n    def _move_up(self) -> None:  # pragma: no cover\n        \"\"\"Move the view or edit cursor up.\"\"\"\n        # check if we are at the top of the view and need to scroll instead\n        row: int = self._t.get_location()[0]\n        if self._edit_mode and row > MainGame.HEADER_ROWS:\n            print(self._t.move_up(1), end=\"\")\n        else:\n            self._origin_row -= 1\n        self.print_ui_update(False, self._gol.count_live_cells())", "            self._origin_row -= 1\n        self.print_ui_update(False, self._gol.count_live_cells())\n\n    def _toggle_cell_state(self) -> None:  # pragma: no cover\n        \"\"\"Toggle the state of a cell on the board.\"\"\"\n        row, col = self._t.get_location()\n        cell_row: int = row - MainGame.HEADER_ROWS + self._origin_row\n        cell_col: int = floor(col / 2) + self._origin_col\n        cell_state: bool | None = self._gol.get_cell(cell_row, cell_col)\n        if cell_state is not None:", "        cell_state: bool | None = self._gol.get_cell(cell_row, cell_col)\n        if cell_state is not None:\n            self._gol.set_cell(cell_row, cell_col, not cell_state)\n        self.print_game()\n\n    def _decrease_speed(self) -> None:\n        \"\"\"Decrease speed.\"\"\"\n        self._sleep_time = (\n            self._sleep_time * 2\n            if self._sleep_time > 0", "            self._sleep_time * 2\n            if self._sleep_time > 0\n            # 250ms (the default) / 128, i.e. you have to push the + key 7 times\n            else 0.001953125\n        )\n        # self._sleep_time *= 2\n        self.print_ui_update(False, self._gol.count_live_cells())\n\n    def _increase_speed(self) -> None:\n        \"\"\"Increase speed.\"\"\"", "    def _increase_speed(self) -> None:\n        \"\"\"Increase speed.\"\"\"\n        self._sleep_time /= 2\n        # once we reach a low threshold just set it to 0\n        if self._sleep_time < 0.001:\n            self._sleep_time = 0\n        self.print_ui_update(False, self._gol.count_live_cells())\n\n    def _toggle_edit_mode(self) -> None:  # pragma: no cover\n        \"\"\"Toggle edit mode.\"\"\"", "    def _toggle_edit_mode(self) -> None:  # pragma: no cover\n        \"\"\"Toggle edit mode.\"\"\"\n        if self._edit_mode:\n            self._edit_mode = False\n            # save where the last edit mode was so we can return there\n            self._last_edit_location = self._t.get_location()\n            print(self._t.move_xy(0, 0), end=\"\")\n            self.print_ui()\n        else:\n            self._automatic = False  # if we are running, stop", "        else:\n            self._automatic = False  # if we are running, stop\n            self._edit_mode = True\n            self.print_ui()\n            # return to last edit location\n            print(self._t.move_x(self._last_edit_location[1]), end=\"\")\n            print(self._t.move_y(self._last_edit_location[0]), end=\"\")\n\n    # layout model for UI top header moving text\n    # |---------------------------------|  term.width = 50", "    # layout model for UI top header moving text\n    # |---------------------------------|  term.width = 50\n    #                  h                   initial header_location = term.width / 2 = 25\n    #           |----name----|             len(name) = 8\n    #           p......h......             print location = header_location - (len(name) / 2) = 21\n    # p......h......                       print location = header_location - (len(name) / 2) = 0\n    # p......h......                       header_location = 0 + (len(name) / 2) = 4\n    #                      p......h......  print location = term.width - len(name) = 42\n    #                      p......h......  print location = header_location - (len(name) / 2) = 42\n    #                      p......h......  header_location = term.width - (len(name) / 2) = 46", "    #                      p......h......  print location = header_location - (len(name) / 2) = 42\n    #                      p......h......  header_location = term.width - (len(name) / 2) = 46\n\n    def print_ui_update(\n        self, progress: bool, live_count: int, last_gen_time: int | None = None\n    ) -> None:\n        \"\"\"Update things in the UI that needs updating; game name location, stats, etc.\"\"\"\n        # calculate moving header sectiong\n        name: str = \" \u25a0 Conways's Game of Life \u25a1 \"\n        line: str = \" ========================== \"", "        name: str = \" \u25a0 Conways's Game of Life \u25a1 \"\n        line: str = \" ========================== \"\n        # move the name and underline from side to side, manage switching directions\n        # this is pretty complicated, would be nice to do something simpler!\n        half_width: int = floor(len(name) / 2)\n        if progress:\n            if self._header_dir_left:\n                self._header_loc -= 1\n                if self._header_loc - half_width < 0:\n                    self._header_dir_left = False", "                if self._header_loc - half_width < 0:\n                    self._header_dir_left = False\n                    self._header_loc += 2\n            else:\n                self._header_loc += 1\n                if self._header_loc >= self._t.width - half_width:\n                    self._header_dir_left = True\n                    self._header_loc -= 2\n\n        with self._t.location(0, 0), self._t.hidden_cursor():", "\n        with self._t.location(0, 0), self._t.hidden_cursor():\n            # header section\n            print(self._t.move_x(self._header_loc - half_width) + self._t.bold(name))\n            print(self._t.move_x(self._header_loc - half_width) + self._t.bold(line))\n            # don't forget to update MainGame.HEADER_ROWS if making changes here!!!\n\n        footer_start_row: int = self._t.height - MainGame.FOOTER_ROWS\n        with self._t.location(0, footer_start_row), self._t.hidden_cursor():\n            print(self._t.bold(\"Info\") + self._t.move_down)", "        with self._t.location(0, footer_start_row), self._t.hidden_cursor():\n            print(self._t.bold(\"Info\") + self._t.move_down)\n            print(f\"Generation:    {self._gol.generation}\")\n            print(f\"Live cells:    {live_count}   \")\n            # intentional space on the end of \"seconds \" below\n            print(f\"Frame delay:   {self._sleep_time*1000:.4g} ms    \")\n            time_str: str = (\n                str(round(last_gen_time / 1000)) + \" \u00b5s\"\n                if last_gen_time is not None\n                else \"\"", "                if last_gen_time is not None\n                else \"\"\n            )\n            print(f\"Progress time: {time_str}   \")\n            print(\n                f\"Coords:        row:{self._origin_row} col:{self._origin_col}  \",\n                end=\"\",\n            )\n            # future stats, max total of FOOTER_ROWS-2 due to current formatting\n            # print(\"\", end=\"\")", "            # future stats, max total of FOOTER_ROWS-2 due to current formatting\n            # print(\"\", end=\"\")\n\n    def print_game(self) -> None:\n        \"\"\"Print the actual game board with cells from the GameOfLife instance.\"\"\"\n        with self._t.location(0, MainGame.HEADER_ROWS), self._t.hidden_cursor():\n            row_list: list[str] = []\n            max_rows: int = self._t.height - MainGame.HEADER_ROWS - MainGame.FOOTER_ROWS\n            # because we separate all cells by a space we can only do half the number of cols\n            max_cols: int = floor((self._t.width + 1) / 2)", "            # because we separate all cells by a space we can only do half the number of cols\n            max_cols: int = floor((self._t.width + 1) / 2)\n            for view_row in range(max_rows):\n                for view_col in range(max_cols):\n                    cell: bool | None = self._gol.get_cell(\n                        self._origin_row + view_row, self._origin_col + view_col\n                    )\n                    dead_cell_str: str = \".\" if self._wrap else \" \"\n                    if cell is None:\n                        row_list.append(\" \")", "                    if cell is None:\n                        row_list.append(\" \")\n                    else:\n                        row_list.append(\"\u25a0\" if cell else dead_cell_str)\n                        # \u25a1 \u25a0 \u25ab \u25c9 \u25cb \u25cc \u25ce \u25cf \u25ef \u2609 \u2610 \u263b \u25e6\n                print(\" \".join(row_list))\n                row_list = []\n\n    def print_ui(self) -> None:\n        \"\"\"", "    def print_ui(self) -> None:\n        \"\"\"\n        Print the main game UI.\n\n        Returns a tuple with the 1st value being the row index to start printing the game board on,\n        and the 2nd value being the maximum number of rows that the game board can print.\n        \"\"\"\n        with self._t.location(0, 0), self._t.hidden_cursor():\n            # footer section\n            print(self._t.move_xy(0, self._t.height - (MainGame.FOOTER_ROWS + 1)))", "            # footer section\n            print(self._t.move_xy(0, self._t.height - (MainGame.FOOTER_ROWS + 1)))\n            print(self._t.rjust(self._t.bold(\"Controls                   \")))\n            print(\"=\" * self._t.width)\n            # intentional misalignment as some of these are wider on a terminal\n            print(self._t.rjust(\"(\u30ce\u00ba\u76ca\u00ba)\u30ce\u5f61\u253b\u2501\u253b  q or ESC  \"))\n            if self._edit_mode:\n                print(self._t.rjust(\"Exit edit mode:  e         \"))\n                print(self._t.rjust(\"Live/dead cell:  <spacebar>\"))\n                print(self._t.rjust(\"Move cursor:     \u21e6\u21e7\u21e9\u21e8      \"))", "                print(self._t.rjust(\"Live/dead cell:  <spacebar>\"))\n                print(self._t.rjust(\"Move cursor:     \u21e6\u21e7\u21e9\u21e8      \"))\n                print(self._t.rjust(\"                           \"))\n                print(self._t.rjust(\"                           \"), end=\"\")\n            else:\n                print(self._t.rjust(\"Edit cells:      e         \"))\n                print(self._t.rjust(\"Step forward:    <spacebar>\"))\n                print(self._t.rjust(\"Autorun on/off:  a         \"))\n                print(self._t.rjust(\"Speed up/down:   +/-       \"))\n                print(self._t.rjust(\"Move the view:   \u21e6\u21e7\u21e9\u21e8      \"), end=\"\")", "                print(self._t.rjust(\"Speed up/down:   +/-       \"))\n                print(self._t.rjust(\"Move the view:   \u21e6\u21e7\u21e9\u21e8      \"), end=\"\")\n            # don't forget to update MainGame.FOOTER_ROWS if making changes here!!!\n\n    @staticmethod\n    def add_glider(gol: GameOfLife) -> None:\n        \"\"\"Add a simple glider.\"\"\"\n        gol.set_cell(0, 1, True)\n        gol.set_cell(1, 2, True)\n        gol.set_cell(2, 0, True)", "        gol.set_cell(1, 2, True)\n        gol.set_cell(2, 0, True)\n        gol.set_cell(2, 1, True)\n        gol.set_cell(2, 2, True)\n"]}
{"filename": "python3/gameoflife/coordinate.py", "chunked_list": ["\"\"\"To avoid circular dependencies we put a Coordinate type alias in a separate module.\"\"\"\n\nCoordinate = tuple[int, int]\n"]}
{"filename": "python3/gameoflife/gol_set.py", "chunked_list": ["\"\"\"Game of Life set implementation.\"\"\"\n\nfrom gameoflife import Coordinate, GameOfLife\n\n\nclass GameOfLifeSet(GameOfLife):\n    \"\"\"Implements Game of Life using a Python set implementation.\"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"Initialise the map.\"\"\"", "    def __init__(self) -> None:\n        \"\"\"Initialise the map.\"\"\"\n        super().__init__()\n        self._cells: set[Coordinate] = set()\n        self._min_row: int\n        self._max_row: int\n        self._min_col: int\n        self._max_col: int\n\n    def __str__(self) -> str:", "\n    def __str__(self) -> str:\n        \"\"\"Iterate over all the cells and return a human readable string.\"\"\"\n        str_list: list[str] = [\"Generation: \" + str(self.generation)]\n        for row in range(self._min_row, self._max_row + 1):  # add 1 to include last\n            row_list: list[str] = []\n            for col in range(self._min_col, self._max_col + 1):  # add 1 to include last\n                if (row, col) in self._cells:\n                    row_list.append(\"\u25a0 \" if (row, col) in self._cells else \"\u25a1 \")\n                else:", "                    row_list.append(\"\u25a0 \" if (row, col) in self._cells else \"\u25a1 \")\n                else:\n                    row_list.append(\"  \")\n            str_list.append(\"\".join(row_list))\n        return \"\\n\".join(str_list)\n\n    def progress(self) -> int:\n        \"\"\"Progress another generation.\"\"\"\n        old_gen: set[Coordinate] = self._cells\n        self._cells = set()", "        old_gen: set[Coordinate] = self._cells\n        self._cells = set()\n        checked_dead_cells: set[Coordinate] = set()\n        count: int = 0\n        # loop over every live cell\n        for coords in old_gen:\n            # check how many live neighbours we have\n            num_live_neighbours: int = 0\n            dead_neighbour_coords: list[Coordinate] = []\n            for cell_coord in GameOfLifeSet._compute_neighbours(coords[0], coords[1]):", "            dead_neighbour_coords: list[Coordinate] = []\n            for cell_coord in GameOfLifeSet._compute_neighbours(coords[0], coords[1]):\n                if cell_coord in old_gen:\n                    num_live_neighbours += 1\n                else:\n                    dead_neighbour_coords.append(cell_coord)\n\n            # check if the current cell being processed should live\n            match num_live_neighbours:\n                # 2. A live cell with exactly 2 neighbours is alive in the next generation.", "            match num_live_neighbours:\n                # 2. A live cell with exactly 2 neighbours is alive in the next generation.\n                case 2:\n                    self._set_cell(coords)\n                    count += 1\n                # 1. Any cell, dead or alive, with exactly 3 neighbours is alive in the\n                # next generation.\n                case 3:\n                    self._set_cell(coords)\n                    count += 1", "                    self._set_cell(coords)\n                    count += 1\n                # 3. All other cells are dead in the next generation.\n                case _:\n                    pass\n\n            # check if any of the dead neighbours should come alive\n            for coords in dead_neighbour_coords:\n                if coords not in checked_dead_cells:\n                    num_live_neighbours = 0", "                if coords not in checked_dead_cells:\n                    num_live_neighbours = 0\n                    for cell_coord in GameOfLifeSet._compute_neighbours(\n                        coords[0], coords[1]\n                    ):\n                        if cell_coord in old_gen:\n                            num_live_neighbours += 1\n                    if num_live_neighbours == 3:\n                        self._set_cell(coords)\n                        count += 1", "                        self._set_cell(coords)\n                        count += 1\n                checked_dead_cells.add(coords)\n\n        self.generation += 1\n        return count\n\n    def _set_cell(self, coord: Coordinate) -> None:\n        self.set_cell(coord[0], coord[1], True)\n", "        self.set_cell(coord[0], coord[1], True)\n\n    def set_cell(self, row: int, col: int, live: bool) -> None:\n        \"\"\"Set a cell in the map to the given live value.\"\"\"\n        # only add the cell to the map if it is live\n        if live:\n            # track the min/max of cols\n            if len(self._cells) == 0:  # just set them first time around\n                self._min_row = row\n                self._max_row = row", "                self._min_row = row\n                self._max_row = row\n                self._min_col = col\n                self._max_col = col\n            else:\n                self._min_row = row if row < self._min_row else self._min_row\n                self._max_row = row if row > self._max_row else self._max_row\n                self._min_col = col if col < self._min_col else self._min_col\n                self._max_col = col if col > self._max_col else self._max_col\n            self._cells.add((row, col))", "                self._max_col = col if col > self._max_col else self._max_col\n            self._cells.add((row, col))\n        else:\n            self._cells.remove((row, col))\n\n    def count_live_cells(self) -> int:\n        \"\"\"Count the total number of live cells in the GoL universe.\"\"\"\n        return len(self._cells)\n\n    def get_cell(self, row: int, col: int) -> bool | None:", "\n    def get_cell(self, row: int, col: int) -> bool | None:\n        \"\"\"\n        Return the live status of the given cell.\n\n        This implementation never returns None since the universe is \"infinite\".\n        \"\"\"\n        return (row, col) in self._cells\n\n    def get_live_cells(self) -> list[Coordinate]:", "\n    def get_live_cells(self) -> list[Coordinate]:\n        \"\"\"\n        Return a list of the Coordinates of all the live cells.\n\n        The list must be sorted by row top to bottom and then in the row from left to right.\n        \"\"\"\n        return sorted(self._cells)\n\n    @staticmethod", "\n    @staticmethod\n    def _compute_neighbours(row: int, col: int) -> list[Coordinate]:\n        \"\"\"Compute the coordinates of all the neighbours of the given cell.\"\"\"\n        # pre-allocating these like this is 5% faster\n        top: int = row - 1\n        bottom: int = row + 1\n        left: int = col - 1\n        right: int = col + 1\n        return [", "        right: int = col + 1\n        return [\n            (top, left),\n            (top, col),\n            (top, right),\n            (row, right),\n            (bottom, right),\n            (bottom, col),\n            (bottom, left),\n            (row, left),", "            (bottom, left),\n            (row, left),\n        ]\n"]}
{"filename": "python3/gameoflife/gol_dict.py", "chunked_list": ["\"\"\"Game of Life dict implementation.\"\"\"\n\nfrom gameoflife import Coordinate, GameOfLife\n\n\nclass GameOfLifeDict(GameOfLife):\n    \"\"\"Implements Game of Life using a Python dict implementation.\"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"Initialise the map.\"\"\"", "    def __init__(self) -> None:\n        \"\"\"Initialise the map.\"\"\"\n        super().__init__()\n        self._cells: dict[Coordinate, bool] = {}\n        self._min_row: int\n        self._max_row: int\n        self._min_col: int\n        self._max_col: int\n\n    def __str__(self) -> str:", "\n    def __str__(self) -> str:\n        \"\"\"Iterate over all the cells and return a human readable string.\"\"\"\n        str_list: list[str] = [\"Generation: \" + str(self.generation)]\n        for row in range(self._min_row, self._max_row + 1):  # add 1 to include last\n            row_list: list[str] = []\n            for col in range(self._min_col, self._max_col + 1):  # add 1 to include last\n                if (row, col) in self._cells:\n                    row_list.append(\"\u25a0 \" if self._cells.get((row, col)) else \"\u25a1 \")\n                else:", "                    row_list.append(\"\u25a0 \" if self._cells.get((row, col)) else \"\u25a1 \")\n                else:\n                    row_list.append(\"  \")\n            str_list.append(\"\".join(row_list))\n        return \"\\n\".join(str_list)\n\n    def progress(self) -> int:\n        \"\"\"Progress another generation.\"\"\"\n        old_gen: dict[Coordinate, bool] = self._cells\n        self._cells = {}", "        old_gen: dict[Coordinate, bool] = self._cells\n        self._cells = {}\n        count: int = 0\n        # loop over every tracked cell\n        for coords, live in old_gen.items():\n            match GameOfLifeDict._live_neighbours(old_gen, coords):\n                # 2. A live cell with exactly 2 neighbours is alive in the next generation.\n                case 2:\n                    if live:\n                        self.set_cell(coords[0], coords[1], live)", "                    if live:\n                        self.set_cell(coords[0], coords[1], live)\n                        count += 1\n                    else:\n                        pass  # required for code coverage? :/\n                # 1. Any cell, dead or alive, with exactly 3 neighbours is alive in the\n                # next generation.\n                case 3:\n                    self.set_cell(coords[0], coords[1], True)\n                    count += 1", "                    self.set_cell(coords[0], coords[1], True)\n                    count += 1\n                # 3. All other cells are dead in the next generation.\n                case _:\n                    pass\n        self.generation += 1\n        return count\n\n    def set_cell(self, row: int, col: int, live: bool) -> None:\n        \"\"\"Set a cell in the map to the given live value.\"\"\"", "    def set_cell(self, row: int, col: int, live: bool) -> None:\n        \"\"\"Set a cell in the map to the given live value.\"\"\"\n        # track the min/max of cols\n        if len(self._cells) == 0:  # just set them first time around\n            self._min_row = row\n            self._max_row = row\n            self._min_col = col\n            self._max_col = col\n        else:\n            self._min_row = row if row < self._min_row else self._min_row", "        else:\n            self._min_row = row if row < self._min_row else self._min_row\n            self._max_row = row if row > self._max_row else self._max_row\n            self._min_col = col if col < self._min_col else self._min_col\n            self._max_col = col if col > self._max_col else self._max_col\n        # if we are adding a live cell, also add dead neighbours if they don't already exist\n        if live:\n            self._cells[(row, col)] = live\n            # add all the dead neighbours if there is not a cell in the map already\n            for neighbour in GameOfLifeDict._compute_neighbours(row, col):", "            # add all the dead neighbours if there is not a cell in the map already\n            for neighbour in GameOfLifeDict._compute_neighbours(row, col):\n                if neighbour not in self._cells:\n                    # recurse to set min/max\n                    self.set_cell(neighbour[0], neighbour[1], False)\n        else:\n            self._cells[(row, col)] = False\n\n    def count_live_cells(self) -> int:\n        \"\"\"Count the total number of live cells in the GoL universe.\"\"\"", "    def count_live_cells(self) -> int:\n        \"\"\"Count the total number of live cells in the GoL universe.\"\"\"\n        count: int = 0\n        for cell in self._cells.values():\n            if cell:\n                count += 1\n        return count\n\n    def get_cell(self, row: int, col: int) -> bool | None:\n        \"\"\"", "    def get_cell(self, row: int, col: int) -> bool | None:\n        \"\"\"\n        Return the live status of the given cell.\n\n        This implementation never returns None since the universe is \"infinite\".\n        \"\"\"\n        live: bool | None = self._cells.get((row, col))\n        if live is None:\n            return False\n        return live", "            return False\n        return live\n\n    def get_live_cells(self) -> list[Coordinate]:\n        \"\"\"Return a list of the Coordinates of all the live cells.\"\"\"\n        # TODO: finish this some day\n        raise NotImplementedError\n\n    @staticmethod\n    def _live_neighbours(cell_map: dict[Coordinate, bool], coords: Coordinate) -> int:", "    @staticmethod\n    def _live_neighbours(cell_map: dict[Coordinate, bool], coords: Coordinate) -> int:\n        \"\"\"Count the number of live neighbours the cell at the given coords has.\"\"\"\n        live_count: int = 0\n        for cell_coord in GameOfLifeDict._compute_neighbours(coords[0], coords[1]):\n            if cell_map.get(cell_coord):\n                live_count += 1\n            # the funny thing is that doing the below actually slows the progress() down by 2.5%...\n            # if there's more than 3 we're done\n            # if live_count > 3:", "            # if there's more than 3 we're done\n            # if live_count > 3:\n            #     return live_count\n        return live_count\n\n    @staticmethod\n    def _compute_neighbours(row: int, col: int) -> list[Coordinate]:\n        \"\"\"Compute the coordinates of all the neighbours of the given cell.\"\"\"\n        # pre-allocating these like this is 5% faster\n        top: int = row - 1", "        # pre-allocating these like this is 5% faster\n        top: int = row - 1\n        bottom: int = row + 1\n        left: int = col - 1\n        right: int = col + 1\n        return [\n            (top, left),\n            (top, col),\n            (top, right),\n            (row, right),", "            (top, right),\n            (row, right),\n            (bottom, right),\n            (bottom, col),\n            (bottom, left),\n            (row, left),\n        ]\n"]}
{"filename": "python3/gameoflife/__init__.py", "chunked_list": ["\"\"\"Import all the other sources and re-export them for easier importing elsewhere.\"\"\"\n\n# pylint: disable=useless-import-alias\nfrom gameoflife.coordinate import Coordinate as Coordinate\nfrom gameoflife.gol_abc import GameOfLife as GameOfLife\nfrom gameoflife.gol_arrays import GameOfLifeArrays as GameOfLifeArrays\nfrom gameoflife.gol_dict import GameOfLifeDict as GameOfLifeDict\nfrom gameoflife.gol_set import GameOfLifeSet as GameOfLifeSet\nfrom gameoflife.main import MainGame as MainGame\n", "from gameoflife.main import MainGame as MainGame\n"]}
{"filename": "python3/gameoflife/gol_abc.py", "chunked_list": ["\"\"\"Game of Life abstract class specifying the interface.\"\"\"\n\nfrom abc import ABC, abstractmethod\nfrom gameoflife.dataio.file_reader import FileReader\nfrom gameoflife import Coordinate\n\n\nclass GameOfLife(ABC):\n    \"\"\"Abstract class to specify the interface for different implementations of Game of Life.\"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"Initialise.\"\"\"\n        self._generation: int = 0\n\n    @abstractmethod\n    def __str__(self) -> str:\n        \"\"\"Produce a human readable string to represent the state of the GoL universe.\"\"\"\n\n    @abstractmethod\n    def progress(self) -> int:\n        \"\"\"Progress another generation, return the number of live cells in the new generation.\"\"\"\n\n    @abstractmethod\n    def set_cell(self, row: int, col: int, live: bool) -> None:\n        \"\"\"Set a cell in the universe to the given live value.\"\"\"\n\n    @abstractmethod\n    def count_live_cells(self) -> int:\n        \"\"\"Count the total number of live cells in the GoL universe.\"\"\"\n\n    @abstractmethod\n    def get_cell(self, row: int, col: int) -> bool | None:\n        \"\"\"Return the live status of the given cell.\"\"\"\n\n    @property\n    def generation(self) -> int:\n        \"\"\"Return the current generation of the game.\"\"\"\n        return self._generation\n\n    @generation.setter\n    def generation(self, gen: int) -> None:\n        \"\"\"Return the current generation of the game.\"\"\"\n        self._generation = gen\n\n    def add_cells(self, reader: FileReader) -> None:\n        \"\"\"Load cells from the given reader.\"\"\"\n        for row, col in reader.cells:\n            self.set_cell(row, col, True)\n\n    @abstractmethod\n    def get_live_cells(self) -> list[Coordinate]:\n        \"\"\"\n        Return a list of the Coordinates of all the live cells.\n\n        The list must be sorted by row top to bottom and then in the row from left to right.\n        \"\"\"", ""]}
{"filename": "python3/gameoflife/gol_arrays.py", "chunked_list": ["\"\"\"Game of Life array based implementation.\"\"\"\n\nfrom gameoflife import GameOfLife, Coordinate\n\n\nclass GameOfLifeArrays(GameOfLife):\n    \"\"\"Implements Game of Life using two fixed size arrays, with universe wrap around.\"\"\"\n\n    def __init__(self, rows: int, cols: int) -> None:\n        \"\"\"Initialise the two parallel arrays.\"\"\"\n        super().__init__()\n        self._a_array: list[list[bool]] = [\n            [False for _ in range(cols)] for _ in range(rows)\n        ]\n\n    def progress(self) -> int:\n        \"\"\"Progress the game another generation.\"\"\"\n        # initialise a new array next_gen[[]] to be all False\n        next_gen: list[list[bool]] = [\n            [False for _ in range(len(self._a_array[0]))]\n            for _ in range(len(self._a_array))\n        ]\n        count: int = 0\n\n        # loop through every cell on the board and update the _b array with the next gen.\n        for row_index, row_list in enumerate(self._a_array):\n            for col_index, live in enumerate(row_list):\n                num_neighbours: int = self._count_neighbours(row_index, col_index)\n                # 1. Any cell, dead or alive, with exactly 3 neighbours is alive in next gen.\n                if num_neighbours == 3:\n                    next_gen[row_index][col_index] = True\n                    count += 1\n                # 2. A live cell with exactly 2 neighbours is alive in the next generation.\n                elif live is True and num_neighbours == 2:\n                    next_gen[row_index][col_index] = True\n                    count += 1\n                # 3. All other cells are dead in the next generation.\n                # do nothing\n\n        # swap the arrays\n        self._a_array = next_gen\n        self.generation += 1\n        return count\n\n    def set_cell(self, row: int, col: int, live: bool) -> None:\n        \"\"\"\n        Set a cell in the array to the given live value.\n\n        Cells outside of the boundaries of the array will wrap around as their coordinate will be\n        modulo the array height and width. For large patterns and small arrays (like the size of a\n        single monitor screen) this will usually simply mean that every cell in the array is set,\n        and on the first generation every cell will die.\n        \"\"\"\n        self._a_array[row % len(self._a_array)][col % len(self._a_array[0])] = live\n\n    def count_live_cells(self) -> int:\n        \"\"\"Count the total number of live cells in the GoL universe.\"\"\"\n        count: int = 0\n        for row in self._a_array:\n            for live in row:\n                if live:\n                    count += 1\n        return count\n\n    def get_cell(self, row: int, col: int) -> bool | None:\n        \"\"\"Return the live status of the given cell.\"\"\"\n        if (\n            row >= 0\n            and row < len(self._a_array)\n            and col >= 0\n            and col < len(self._a_array[0])\n        ):\n            return self._a_array[row][col]\n        else:\n            return None\n\n    def get_live_cells(self) -> list[Coordinate]:\n        \"\"\"\n        Return a list of the Coordinates of all the live cells.\n\n        The list must be sorted by row top to bottom and then in the row from left to right.\n        \"\"\"\n        live_cells: list[Coordinate] = []\n        for row_index, row in enumerate(self._a_array):\n            for col_index, cell in enumerate(row):\n                if cell:\n                    live_cells.append((row_index, col_index))\n        return live_cells\n\n    def _count_neighbours(self, row: int, col: int) -> int:\n        \"\"\"Count how many of the 8 neighbours of this cell are alive.\"\"\"\n        count = 0\n\n        # check if we need to wrap around\n        # if y==0 we can't decrement further, so wrap around to other extreme of array\n        top: int = len(self._a_array) - 1 if row == 0 else row - 1\n        # if y==a.length-1 we can't increment, so wrap around to 0\n        bottom: int = 0 if row == len(self._a_array) - 1 else row + 1\n\n        # if x==0 then we can't decrement further, so wrap around to other extreme of array\n        left: int = len(self._a_array[0]) - 1 if col == 0 else col - 1\n        # if x==a[0].length-1 we can't increment, so wrap around to 0\n        right: int = 0 if col == len(self._a_array[0]) - 1 else col + 1\n\n        # check all the neighbours\n        count += self._a_array[top][left]\n        count += self._a_array[top][col]\n        count += self._a_array[top][right]\n        count += self._a_array[row][left]\n        # we don't do a[y][x] because it's the cell we're testing\n        count += self._a_array[row][right]\n        count += self._a_array[bottom][left]\n        count += self._a_array[bottom][col]\n        count += self._a_array[bottom][right]\n        return count\n\n    def __str__(self) -> str:\n        \"\"\"Return the a array as a formatted string.\"\"\"\n        # concise but unreadable double map version\n        # return \"\\n\".join(list(map(lambda r: \"\".join(list(map(lambda c: \"\u25a0 \" if c else \"\u25a1 \", r))),\n        #   self.a)))\n        # expanded double for loop version\n        str_list: list[str] = [\"Generation: \" + str(self.generation)]\n        for row in self._a_array:\n            row_list: list[str] = []\n            for cell in row:\n                row_list.append(\"\u25a0 \" if cell else \"\u25a1 \")\n            str_list.append(\"\".join(row_list))\n        return \"\\n\".join(str_list)", ""]}
{"filename": "python3/gameoflife/dataio/plaintext_reader.py", "chunked_list": ["\"\"\"File Loader for Plain Text file types.\"\"\"\n\nfrom io import TextIOWrapper\nfrom types import TracebackType\nimport pyparsing as pp\nfrom .file_reader import FileReader, FileReaderContextManager\n\n\n# pylint: disable=pointless-string-statement\n\"\"\" ", "# pylint: disable=pointless-string-statement\n\"\"\" \n!Name: Glider\n!Author: Richard K. Guy\n!The smallest, most common, and first discovered spaceship.\n!www.conwaylife.com/wiki/index.php?title=Glider\n.O\n..O\nOOO\n\"\"\"", "OOO\n\"\"\"\n\n\nclass PlainTextReader(FileReaderContextManager):\n    \"\"\"Implements loading Plain Text data from files.\"\"\"\n\n    # !Name: Glider\n    # !Author: Richard K. Guy\n    # !The smallest, most common, and first discovered spaceship.\n    # !www.conwaylife.com/wiki/index.php?title=Glider\n    _METADATA_LINE: pp.ParserElement = pp.ZeroOrMore(\n        (\n            pp.AtLineStart(\"!\").suppress()\n            + (pp.Optional(pp.Word(pp.printables + \" \")) + pp.line_end.suppress())\n            .set_whitespace_chars(\" \\t\")\n            .set_results_name(\"metadata\", True)\n        )\n    )\n\n    _CELL_STATES: pp.ParserElement = pp.one_of(\". O\").set_whitespace_chars(\" \\t\")\n\n    # .O\n    # ..O\n    # OOO\n    _DATA_ROWS: pp.ParserElement = pp.OneOrMore(\n        (pp.ZeroOrMore(_CELL_STATES) + pp.line_end.suppress()).set_results_name(\n            \"data_rows\", True\n        )\n    )\n\n    _PARSER: pp.ParserElement = _METADATA_LINE + _DATA_ROWS\n\n    def __init__(self, file: str) -> None:\n        \"\"\"Initialise the reader.\"\"\"\n        super().__init__(file)\n        self._file: TextIOWrapper\n\n    def __enter__(self) -> FileReader:\n        \"\"\"Enter context manager which causes the file to be parsed immediately.\"\"\"\n        self._file = open(self._filename, \"r\", encoding=\"UTF-8\")\n        results: pp.ParseResults = PlainTextReader._PARSER.parse_file(self._file)\n        self.metadata = (\n            results.metadata.as_list() if results.metadata else []  # type:ignore\n        )\n        for row_index, row in enumerate(results.data_rows.as_list()):  # type:ignore\n            for col_index, cell in enumerate(row):  # type:ignore\n                if cell == \"O\":\n                    self.cells.append((row_index, col_index))\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -> None:\n        \"\"\"Exit context manager.\"\"\"\n        self._file.close()", ""]}
{"filename": "python3/gameoflife/dataio/plaintext_writer.py", "chunked_list": ["\"\"\"File Writer for Plain Text file types.\"\"\"\n\nfrom io import TextIOWrapper\nfrom types import TracebackType\nfrom gameoflife import Coordinate\nfrom .file_writer import FileWriter, FileWriterContextManager\n\n\n# pylint: disable=pointless-string-statement\n\"\"\" ", "# pylint: disable=pointless-string-statement\n\"\"\" \n!Name: Glider\n!Author: Richard K. Guy\n!The smallest, most common, and first discovered spaceship.\n!www.conwaylife.com/wiki/index.php?title=Glider\n.O\n..O\nOOO\n\"\"\"", "OOO\n\"\"\"\n\n\nclass PlainTextWriter(FileWriterContextManager):\n    \"\"\"Implements writing Plain Text data to files.\"\"\"\n\n    def __init__(self, file: str) -> None:\n        \"\"\"Initialise the reader.\"\"\"\n        super().__init__(file)\n        self._file: TextIOWrapper\n\n    def __enter__(self) -> FileWriter:\n        \"\"\"Enter context manager which causes the file to be parsed immediately.\"\"\"\n        self._file = open(self._filename, \"w\", encoding=\"UTF-8\")\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -> None:\n        \"\"\"Exit context manager.\"\"\"\n        self._file.close()\n\n    def write(self, metadata: list[str], cells: list[Coordinate]) -> None:\n        \"\"\"Write the Game of Life data to the file.\"\"\"\n        for data in metadata:\n            self._file.write(f\"!{data}\\n\")\n        if cells:\n            # find the min limits\n            min_row: int = cells[0][0]\n            min_col: int = cells[0][1]\n            for row, col in cells:\n                min_row = row if row < min_row else min_row\n                min_col = col if col < min_col else min_col\n\n            # keep track of where we wrote the last cell\n            row_index: int = min_row\n            col_index: int = min_col\n            for row, col in cells:\n                # get the difference in rows from the \"last\" cell to this one\n                # this will be 0 when we're on the same row\n                row_difference: int = row - row_index\n                if row_difference > 0:\n                    # write out the number of newlines required\n                    self._file.write(\"\\n\" * row_difference)\n                    # reset the col_index as we are on a new row\n                    col_index = min_col\n                # get the difference in cols from the \"last\" cell to this one\n                col_difference: int = col - col_index\n                # if there is a col difference then that is a dead cell gap\n                if col_difference > 0:\n                    self._file.write(\".\" * col_difference)\n                # finish by writing the live cell\n                self._file.write(\"O\")\n                # update the index to point to the last cell +1 col of the cell we just wrote\n                row_index = row\n                col_index = col + 1\n            self._file.write(\"\\n\")", ""]}
{"filename": "python3/gameoflife/dataio/file_writer.py", "chunked_list": ["\"\"\"File writer abstract class specifying the interface for writing cells to a file.\"\"\"\n\nfrom abc import ABC, abstractmethod\nfrom types import TracebackType\nfrom gameoflife import Coordinate\n\n\nclass FileWriter(ABC):\n    \"\"\"ABC for the interface of different file encoding types for cells for Game of Life.\"\"\"\n\n    def __init__(self, file: str) -> None:\n        \"\"\"Initialise.\"\"\"\n        self._filename: str = file\n\n    @abstractmethod\n    def write(self, metadata: list[str], cells: list[Coordinate]) -> None:\n        \"\"\"Write the Game of Life data to the file.\"\"\"", "\n\nclass FileWriterContextManager(FileWriter):\n    \"\"\"ABC for adding context management to FileReaders.\"\"\"\n\n    @abstractmethod\n    def __enter__(self) -> FileWriter:\n        \"\"\"Enter context manager.\"\"\"\n\n    @abstractmethod\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -> None:\n        \"\"\"Exit context manager.\"\"\"", ""]}
{"filename": "python3/gameoflife/dataio/__init__.py", "chunked_list": ["\"\"\"Data IO related code.\"\"\"\n"]}
{"filename": "python3/gameoflife/dataio/runlengthencoded_reader.py", "chunked_list": ["\"\"\"File Loader for Run Length Encoded file types.\"\"\"\n\nfrom io import TextIOWrapper\nfrom types import TracebackType\nimport pyparsing as pp\nfrom .file_reader import FileReader, FileReaderContextManager\n\n\n# pylint: disable=pointless-string-statement\n\"\"\" ", "# pylint: disable=pointless-string-statement\n\"\"\" \n#N Glider\n#O Richard K. Guy\n#C The smallest, most common, and first discovered spaceship. Diagonal, has period 4 and speed c/4.\n#C www.conwaylife.com/wiki/index.php?title=Glider\nx = 3, y = 3, rule = B3/S23\nbob$2bo$3o!\n\"\"\"\n", "\"\"\"\n\n\nclass RunLengthEncodedReader(FileReaderContextManager):\n    \"\"\"Implements loading Run Length Encoded data from files.\"\"\"\n\n    _INT_NUMBER: pp.ParserElement = pp.Word(pp.nums).set_parse_action(  # type:ignore\n        lambda t: [int(t[0])]  # type:ignore\n    )\n\n    # is there an existing pyparsing element that has all alphas separated by spaces?\n    _CELL_STATES: pp.ParserElement = pp.one_of(\" \".join(list(pp.alphas)))\n\n    # # N Glider\n    # # O Richard K. Guy\n    # #C www.conwaylife.com/wiki/index.php?title=Glider\n    # #\n    _METADATA_LINE: pp.ParserElement = pp.ZeroOrMore(\n        (\n            pp.AtLineStart(\"#\").suppress()\n            + pp.Optional(\n                pp.one_of(\" \".join(list(pp.printables)))\n            ).set_whitespace_chars(\" \\t\")\n            + pp.Optional(pp.Word(pp.printables + \" \")).set_whitespace_chars(\" \\t\")\n        ).set_results_name(\"metadata\", True)\n    )\n\n    # x = 3, y = 3, rule = B3/S23\n    # x = 3, y = 3\n    _HEADER: pp.ParserElement = (\n        pp.one_of(\"x y\") + pp.Suppress(\"=\") + _INT_NUMBER + pp.Optional(\",\").suppress()\n    ).set_results_name(\"header\", True) * 2\n\n    # Parse the actual rule in the future:\n    #   If a rule string is B34/S34:\n    #     B34 means a cell is born if it has 3 or 4 neighbors.\n    #     S34 means a cell survives if it has 3 or 4 neighbors.\n    # x = 3, y = 3, rule = B3/S23\n    # x = 3, y = 3\n    _RULE: pp.ParserElement = pp.Optional(\n        pp.Keyword(\"rule\").suppress()\n        + pp.Suppress(\"=\")\n        + pp.Word(pp.printables + \" \").set_whitespace_chars(\" \\t\")\n    ).set_results_name(\"rule\")\n\n    # bob$2bo$3o!\n    #\n    # 24bo$22bobo$12b2o6b2o12b2o$11bo3bo4b2o12b2o$2o8bo5bo3b2o$2o8bo3bob2o4b\n    # obo$10bo5bo7bo$11bo3bo$12b2o!\n    _DATA_ROWS: pp.ParserElement = pp.OneOrMore(\n        (\n            pp.ZeroOrMore(pp.Optional(_INT_NUMBER) + _CELL_STATES)\n            + (\n                _INT_NUMBER + pp.Literal(\"$\")\n                | pp.Literal(\"$\").suppress()\n                | pp.Literal(\"!\").suppress()\n            )\n        ).set_results_name(\"data_rows\", True)\n    )\n\n    _PARSER: pp.ParserElement = _METADATA_LINE + _HEADER + _RULE + _DATA_ROWS\n\n    def __init__(self, file: str) -> None:\n        \"\"\"Initialise the reader.\"\"\"\n        super().__init__(file)\n        self._file: TextIOWrapper\n        self._cols: int\n        self._rows: int\n        self._rule: str\n\n    def __enter__(self) -> FileReader:\n        \"\"\"Enter context manager which causes the file to be parsed immediately.\"\"\"\n        self._file = open(self._filename, \"r\", encoding=\"UTF-8\")\n        # start: int = perf_counter_ns()\n        results: pp.ParseResults = RunLengthEncodedReader._PARSER.parse_file(self._file)\n        # last_gen_time: int = perf_counter_ns() - start\n        # print(f\"Parsing finished in {round(last_gen_time / 1000)} \u00b5s\")\n        self.metadata = (\n            results.metadata.as_list() if results.metadata else []  # type:ignore\n        )\n        self._cols = int(results.header[0][1])  # type:ignore\n        self._rows = int(results.header[1][1])  # type:ignore\n        if results.rule:  # type: ignore\n            self._rule = results.rule[0]  # type: ignore\n\n        # print(\"Starting to process parsed data...\")\n        # start = perf_counter_ns()\n        # create iterator in order to add types\n        row_iter: enumerate[list[int | str]] = enumerate(\n            results.data_rows  # type:ignore\n        )\n        # it is necessary to keep track of an empty row offset for data like \"7$\"\n        empty_rows: int = 0\n        # iterate over the rows of data, equivalent to rows of cells\n        for row_index, data_row in row_iter:\n            col_index: int = 0\n            # create another iterator so we can add types\n            data_iter: enumerate[int | str] = enumerate(data_row)  # type:ignore\n            # iterate of the data elements - note not equivalent to cells yet\n            for data_index, data in data_iter:\n                # if we get an int then we replicate that number of cells\n                if isinstance(data, int):\n                    # is it a number of empty rows\n                    if data_row[data_index + 1] == \"$\":\n                        # track the number of empty rows, subtract 1 to avoid double counting it\n                        # because we are currently processing the first empty row\n                        empty_rows += data - 1\n                    # if it is not an empty row\n                    else:\n                        live: bool = data_row[data_index + 1] == \"o\"\n                        # if we are adding live cells add their coords to the list of cells\n                        if live:\n                            for _ in range(data):\n                                self.cells.append((row_index + empty_rows, col_index))\n                                col_index += 1\n                        # \"skip\" dead cells by adding them as an offset to the col index\n                        else:\n                            col_index += data\n                    # skip the next data value as we just \"used\" it\n                    next(data_iter, None)\n                # otherwise transform the data value to a cell value and store it\n                else:\n                    live = data_row[data_index] == \"o\"\n                    if live:\n                        self.cells.append((row_index + empty_rows, col_index))\n                    col_index += 1\n        # last_gen_time = perf_counter_ns() - start\n        # print(f\"Processing parsed data finished in {round(last_gen_time / 1000)} \u00b5s\")\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -> None:\n        \"\"\"Exit context manager.\"\"\"\n        self._file.close()\n\n    def __str__(self) -> str:\n        \"\"\"To string.\"\"\"\n        return (\n            super().__str__()\n            + f\"\\ncols: {self._cols}, rows: {self._rows}\\n\"\n            + f\"rule: {self._rule if hasattr(self, '_rule') else 'none'}\"\n        )", ""]}
{"filename": "python3/gameoflife/dataio/file_reader.py", "chunked_list": ["\"\"\"File reader abstract class specifying the interface for loading cells from a file.\"\"\"\n\nfrom abc import ABC, abstractmethod\nfrom functools import reduce\nfrom types import TracebackType\nfrom gameoflife import Coordinate\n\n\nclass FileReader(ABC):\n    \"\"\"ABC for the interface of different file encoding types for cells for Game of Life.\"\"\"\n\n    def __init__(self, file: str) -> None:\n        \"\"\"Initialise.\"\"\"\n        self._filename: str = file\n        self.cells: list[Coordinate] = []\n        self.metadata: list[list[int | bool]]\n\n    @staticmethod\n    def _coord_max(left: Coordinate, right: Coordinate) -> Coordinate:\n        \"\"\"Reduce function for getting the max bounds of cells.\"\"\"\n        left_row: int = left[0]\n        left_col: int = left[1]\n        right_row: int = right[0]\n        right_col: int = right[1]\n        return (\n            left_row if left_row > right_row else right_row,\n            left_col if left_col > right_col else right_col,\n        )\n\n    def __str__(self) -> str:\n        \"\"\"\n        To str method default implementation.\n\n        Sublasses might want to replace or augment this output.\n\n        WARNING: for large patterns this will run out of memory as it tries to print a matrix.\n        \"\"\"\n        # make a more human readable list of the cell values\n        # first get the max row and col\n        max_coords: Coordinate = reduce(FileReader._coord_max, self.cells, (0, 0))\n        # then initialise a 2d list of that size\n        cell_matrix: list[list[bool]] = [\n            [False for _ in range(max_coords[1] + 1)] for _ in range(max_coords[0] + 1)\n        ]\n        # then set all the live cells in that 2d list\n        for row, col in self.cells:\n            cell_matrix[row][col] = True\n        # then turn that 2d list into a cell board string\n        cells_str: str = \"\\n\".join(\n            [\n                \" \".join([\"\u25a0\" if cell else \".\" for cell in cell_row])\n                for cell_row in cell_matrix\n            ]\n        )\n        return (\n            f\"{type(self).__name__}\\n\"\n            + f\"file: {self._filename}\\n\"\n            + f\"metadata: {self.metadata}\\n\"\n            + f\"cells:\\n{cells_str}\"\n        )", "class FileReader(ABC):\n    \"\"\"ABC for the interface of different file encoding types for cells for Game of Life.\"\"\"\n\n    def __init__(self, file: str) -> None:\n        \"\"\"Initialise.\"\"\"\n        self._filename: str = file\n        self.cells: list[Coordinate] = []\n        self.metadata: list[list[int | bool]]\n\n    @staticmethod\n    def _coord_max(left: Coordinate, right: Coordinate) -> Coordinate:\n        \"\"\"Reduce function for getting the max bounds of cells.\"\"\"\n        left_row: int = left[0]\n        left_col: int = left[1]\n        right_row: int = right[0]\n        right_col: int = right[1]\n        return (\n            left_row if left_row > right_row else right_row,\n            left_col if left_col > right_col else right_col,\n        )\n\n    def __str__(self) -> str:\n        \"\"\"\n        To str method default implementation.\n\n        Sublasses might want to replace or augment this output.\n\n        WARNING: for large patterns this will run out of memory as it tries to print a matrix.\n        \"\"\"\n        # make a more human readable list of the cell values\n        # first get the max row and col\n        max_coords: Coordinate = reduce(FileReader._coord_max, self.cells, (0, 0))\n        # then initialise a 2d list of that size\n        cell_matrix: list[list[bool]] = [\n            [False for _ in range(max_coords[1] + 1)] for _ in range(max_coords[0] + 1)\n        ]\n        # then set all the live cells in that 2d list\n        for row, col in self.cells:\n            cell_matrix[row][col] = True\n        # then turn that 2d list into a cell board string\n        cells_str: str = \"\\n\".join(\n            [\n                \" \".join([\"\u25a0\" if cell else \".\" for cell in cell_row])\n                for cell_row in cell_matrix\n            ]\n        )\n        return (\n            f\"{type(self).__name__}\\n\"\n            + f\"file: {self._filename}\\n\"\n            + f\"metadata: {self.metadata}\\n\"\n            + f\"cells:\\n{cells_str}\"\n        )", "\n    # TO DO: add getting top-left coords, which will need new parsing too\n    # Example: #R -22 -57\n    # Gives the coordinates of the top-left corner of the pattern. RLE files produced by XLife\n    # usually have this line, and the coordinates are usually negative, with the intention of\n    # placing the centre of the pattern at the origin.\n\n\nclass FileReaderContextManager(FileReader):\n    \"\"\"ABC for adding context management to FileReaders.\"\"\"\n\n    @abstractmethod\n    def __enter__(self) -> FileReader:\n        \"\"\"Enter context manager.\"\"\"\n\n    @abstractmethod\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -> None:\n        \"\"\"Exit context manager.\"\"\"", "class FileReaderContextManager(FileReader):\n    \"\"\"ABC for adding context management to FileReaders.\"\"\"\n\n    @abstractmethod\n    def __enter__(self) -> FileReader:\n        \"\"\"Enter context manager.\"\"\"\n\n    @abstractmethod\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -> None:\n        \"\"\"Exit context manager.\"\"\"", ""]}
{"filename": "python3/gameoflife/dataio/create_io.py", "chunked_list": ["\"\"\"\nSimple function to create the different FileReaders and FileWriters.\n\nUsing separate file to avoid module import issues.\n\"\"\"\nfrom .file_reader import FileReaderContextManager\nfrom .runlengthencoded_reader import RunLengthEncodedReader\nfrom .plaintext_reader import PlainTextReader\nfrom .file_writer import FileWriterContextManager\nfrom .plaintext_writer import PlainTextWriter", "from .file_writer import FileWriterContextManager\nfrom .plaintext_writer import PlainTextWriter\n\n\ndef create_reader(file: str) -> FileReaderContextManager:\n    \"\"\"Create and return the correct FileReader.\"\"\"\n    match file.lower().split(\".\")[-1]:\n        case \"rle\":\n            return RunLengthEncodedReader(file)\n        case \"cells\":", "            return RunLengthEncodedReader(file)\n        case \"cells\":\n            return PlainTextReader(file)\n        case other:\n            raise ValueError(\n                f\"Can't tell what file type this is from its extension: '{other}', from {file}\"\n            )\n    # circumvent pylint bug where it thinks create_reader() can return a not-ContextManager\n    # just need to return a ContextManager here, even though the code can't be reached\n    # see e.g.: https://github.com/pylint-dev/pylint/issues/5273", "    # just need to return a ContextManager here, even though the code can't be reached\n    # see e.g.: https://github.com/pylint-dev/pylint/issues/5273\n    return RunLengthEncodedReader(\"\")\n\n\ndef create_writer(file: str) -> FileWriterContextManager:\n    \"\"\"Create and return the correct FileWriter.\"\"\"\n    match file.lower().split(\".\")[-1]:\n        # case \"rle\":\n        #     return RunLengthEncodedWriter(file)", "        # case \"rle\":\n        #     return RunLengthEncodedWriter(file)\n        case \"cells\":\n            return PlainTextWriter(file)\n        case other:\n            raise ValueError(\n                f\"Can't tell what file type this is from its extension: '{other}', from {file}\"\n            )\n    # circumvent pylint bug where it thinks create_reader() can return a not-ContextManager\n    # just need to return a ContextManager here, even though the code can't be reached", "    # circumvent pylint bug where it thinks create_reader() can return a not-ContextManager\n    # just need to return a ContextManager here, even though the code can't be reached\n    # see e.g.: https://github.com/pylint-dev/pylint/issues/5273\n    return PlainTextWriter(\"\")\n"]}
{"filename": "python3/tests/test_file_writers.py", "chunked_list": ["\"\"\"Tests for all the FileWriter implementations.\"\"\"\n\nfrom os import stat, remove\nfrom os.path import isfile\nfrom time import time\nfrom pytest import raises\nfrom gameoflife.dataio.create_io import create_writer, create_reader\nfrom gameoflife.dataio.file_writer import FileWriter\nfrom gameoflife.dataio.plaintext_writer import PlainTextWriter\nfrom gameoflife import Coordinate, GameOfLife, GameOfLifeSet", "from gameoflife.dataio.plaintext_writer import PlainTextWriter\nfrom gameoflife import Coordinate, GameOfLife, GameOfLifeSet\n\n\ndef test_create_writer() -> None:\n    \"\"\"Test the create_writer function.\"\"\"\n    writer: FileWriter = create_writer(\"test_file.cells\")\n    assert writer.__class__ is PlainTextWriter\n    with raises(ValueError):\n        create_writer(\"test_file.not_a_real_extension\")", "\n\ndef test_write_gosper() -> None:\n    \"\"\"Test load and writing a Gosper glider gun.\"\"\"\n    _test_load_write(\"../data/Gosper_glider_gun.cells\", 272)\n\n\ndef test_write_glider() -> None:\n    \"\"\"Test load and writing a Gosper glider gun.\"\"\"\n    _test_load_write(\"../data/glider.rle\", 50)", "\n\ndef test_write_growth() -> None:\n    \"\"\"Test load and writing a Gosper glider gun.\"\"\"\n    _test_load_write(\"../data/t1point5infinitegrowth2.rle\", 21617)\n\n\ndef _test_load_write(file_to_load: str, saved_file_size: int) -> None:\n    \"\"\"Test that we can save plaintext.\"\"\"\n    test_file_name: str = f\"{time()}_test_file.cells\"\n    gol: GameOfLife = GameOfLifeSet()\n    orig_cells: list[Coordinate]\n    with create_reader(file_to_load) as reader:\n        gol.add_cells(reader)\n        orig_cells = gol.get_live_cells()\n    with create_writer(test_file_name) as writer:\n        writer.write(\n            [\"This is a comment.\", \"And another!\", \"!\", \"\"], gol.get_live_cells()\n        )\n    assert isfile(test_file_name)\n    assert stat(test_file_name).st_size == saved_file_size\n\n    # test loading the saved data\n    gol = GameOfLifeSet()\n    with create_reader(test_file_name) as reader:\n        gol.add_cells(reader)\n    # Note that our PlainTextWriter writes the minimum it needs to, which can cause the written\n    # data to be different from what we started with.\n    # print(f\"orig: {orig_cells}\")\n    # print(f\"new:  {gol.get_live_cells()}\")\n    assert gol.get_live_cells() == orig_cells\n\n    # if the test fails then cleanup doesn't happen and the file is left in the filesystem...\n    remove(test_file_name)", "\n\ndef test_no_cells() -> None:\n    \"\"\"Test that we can save a game with no cells.\"\"\"\n    test_file_name: str = f\"{time()}_test_file.cells\"\n    with create_writer(test_file_name) as writer:\n        writer.write([\"This is a comment.\", \"And another!\", \"!\", \"\"], [])\n    assert isfile(test_file_name)\n    assert stat(test_file_name).st_size == 39\n    # if the test fails then cleanup doesn't happen and the file is left in the filesystem...\n    remove(test_file_name)", ""]}
{"filename": "python3/tests/test_file_readers.py", "chunked_list": ["\"\"\"Tests for all the FileReader implementations.\"\"\"\n\nfrom pytest import raises\nfrom gameoflife.dataio.create_io import create_reader\nfrom gameoflife.dataio.file_reader import FileReader\nfrom gameoflife.dataio.runlengthencoded_reader import RunLengthEncodedReader\nfrom gameoflife.dataio.plaintext_reader import PlainTextReader\nimport pyparsing as pp\n\n\ndef test_create_reader() -> None:\n    \"\"\"Test the create_reader function.\"\"\"\n    reader: FileReader = create_reader(\"file.rle\")\n    assert reader.__class__ is RunLengthEncodedReader\n    reader = create_reader(\"file.cells\")\n    assert reader.__class__ is PlainTextReader\n    with raises(ValueError):\n        create_reader(\"foo.bar\")", "\n\ndef test_create_reader() -> None:\n    \"\"\"Test the create_reader function.\"\"\"\n    reader: FileReader = create_reader(\"file.rle\")\n    assert reader.__class__ is RunLengthEncodedReader\n    reader = create_reader(\"file.cells\")\n    assert reader.__class__ is PlainTextReader\n    with raises(ValueError):\n        create_reader(\"foo.bar\")", "\n\n# pylint: disable=protected-access\n# pyright: reportPrivateUsage=false\nclass TestPlainText:\n    \"\"\"Tests specifically for the class PlainText.\"\"\"\n\n    def test_metadata_parser(self) -> None:\n        \"\"\"Test the METADATA parser.\"\"\"\n        results: pp.ParseResults = PlainTextReader._METADATA_LINE.parse_string(\n            \"\"\"\\\n!Name: Glider\n!Author: Richard K. Guy\n!The smallest, most common, and first discovered spaceship.\n!www.conwaylife.com/wiki/index.php?title=Glider\n.O\n..O\nOOO\n\"\"\"\n        )\n        assert results.metadata.as_list() == [  # type:ignore\n            [\"Name: Glider\"],\n            [\"Author: Richard K. Guy\"],\n            [\"The smallest, most common, and first discovered spaceship.\"],\n            [\"www.conwaylife.com/wiki/index.php?title=Glider\"],\n        ]\n\n    def test_data_rows_parser(self) -> None:\n        \"\"\"Test the CELL_ROWS parser.\"\"\"\n        results: pp.ParseResults = PlainTextReader._DATA_ROWS.parse_string(\n            \"\"\"\\\n.O\n..O\nOOO\n\"\"\"\n        )\n        assert results.data_rows.as_list() == [  # type:ignore\n            [\".\", \"O\"],\n            [\".\", \".\", \"O\"],\n            [\"O\", \"O\", \"O\"],\n            [],\n        ]\n\n        results = PlainTextReader._DATA_ROWS.parse_string(\n            \"\"\"\\\n........................O...........\n......................O.O...........\n............OO......OO............OO\n...........O...O....OO............OO\nOO........O.....O...OO..............\nOO........O...O.OO....O.O...........\n..........O.....O.......O...........\n...........O...O....................\n............OO......................\"\"\"\n        )\n        assert len(results.data_rows) == 9  # type:ignore\n        assert results.data_rows[0].as_list()[24] == \"O\"  # type:ignore\n        assert results.data_rows[6].as_list()[10] == \"O\"  # type:ignore\n        assert results.data_rows[8].as_list()[11] == \".\"  # type:ignore\n        assert results.data_rows[8].as_list()[12] == \"O\"  # type:ignore\n        assert results.data_rows[8].as_list()[13] == \"O\"  # type:ignore\n        assert results.data_rows[8].as_list()[14] == \".\"  # type:ignore\n\n    def test_plain_text(self) -> None:\n        \"\"\"Test the PlainText file type.\"\"\"\n        with create_reader(\"../data/glider.cells\") as reader:\n            assert reader.__class__ is PlainTextReader\n            assert reader.metadata  # type: ignore\n            assert reader.cells == [(0, 1), (1, 2), (2, 0), (2, 1), (2, 2)]\n            assert (\n                str(reader)\n                == \"\"\"\\\nPlainTextReader\nfile: ../data/glider.cells\nmetadata: [['Name: Glider'], ['Author: Richard K. Guy'], ['The smallest, most common, and first discovered spaceship.'], ['www.conwaylife.com/wiki/index.php?title=Glider']]\ncells:\n. \u25a0 .\n. . \u25a0\n\u25a0 \u25a0 \u25a0\"\"\"\n            )\n\n    def test_empty_data_rows(self) -> None:\n        \"\"\"Test the PlainText file type.\"\"\"\n        with create_reader(\"../data/empty_data_rows.cells\") as reader:\n            assert reader.__class__ is PlainTextReader\n            assert reader.metadata == []  # type: ignore\n            assert (\n                str(reader)\n                == \"\"\"\\\nPlainTextReader\nfile: ../data/empty_data_rows.cells\nmetadata: []\ncells:\n. . . . . . . . . . . . \u25a0 \u25a0\n. . . . . . . . . . . . . .\n. . . . . . . . . . . . . .\n. . . . . \u25a0 . . . . . . . .\n. . \u25a0 . . . . . . . . . . .\n. . . . . . . . . . . . . .\n. . . . . . . . . . . . . .\n. . . . . . . . . . . . . .\n. . . . . . . . . . . . . .\n. . . . . . . . . . . . . .\n\u25a0 . . . . . . . . . . . . .\"\"\"\n            )", "\n\n# pylint: disable=protected-access\n# pyright: reportPrivateUsage=false\nclass TestRunLengthEncoded:\n    \"\"\"Tests specifically for the class RunLengthEncoded.\"\"\"\n\n    def test_no_metadata(self) -> None:\n        \"\"\"Specific test for an RLE file with no metadata rows, and some other interesting things\n        thrown in.\"\"\"\n        with create_reader(\"../data/no_metadata_test.rle\") as reader:\n            assert reader.metadata == []\n            assert reader.cells == [\n                (0, 1),\n                (0, 3),\n                (0, 5),\n                (0, 7),\n                (2, 2),\n                (2, 3),\n                (2, 4),\n                (2, 5),\n                (2, 6),\n                (13, 0),\n                (13, 1),\n                (13, 2),\n                (13, 7),\n                (13, 8),\n                (13, 9),\n                (13, 10),\n                (13, 11),\n                (13, 12),\n                (13, 13),\n            ]\n\n    def test_empty_row_data(self) -> None:\n        \"\"\"Specific test for testing data patterns like \"7$\" and \"23$\" which specifies a number of\n        empty rows.\"\"\"\n        with create_reader(\"../data/t1point5infinitegrowth2.rle\") as reader:\n            # first two rows of data is (note \"2$\" at the end which skips a row of cells):\n            #\n            # 71b3o11b3o$70bo2bo10bo2bo$40b3o11b3o16bo4b3o6bo$40bo2bo10bo2bo15bo4bo\n            # 2bo5bo$40bo6b3o4bo17bo4bo8bo$40bo5bo2bo4bo$41bo8bo4bo2$...\n            # the skipped row is row index 7, so check it's all False\n            assert reader.cells[43] == (6, 55)\n            assert reader.cells[44] == (8, 72)\n            assert len(reader.cells) == 1186\n\n    def test_run_length_encoded(self) -> None:\n        \"\"\"Test the RunLengthEncoded file type.\"\"\"\n        # with create_reader(\"../data/Gosper_glider_gun.rle\") as reader:\n        with create_reader(\"../data/glider.rle\") as reader:\n            assert reader.__class__ is RunLengthEncodedReader\n            assert reader.metadata  # type: ignore\n            assert reader._cols  # type: ignore\n            assert reader._rows  # type: ignore\n            assert reader._rule  # type: ignore\n            assert reader.cells == [(0, 1), (1, 2), (2, 0), (2, 1), (2, 2)]\n            assert (\n                str(reader)\n                == \"\"\"\\\nRunLengthEncodedReader\nfile: ../data/glider.rle\nmetadata: [['N', 'Glider'], ['O', 'Richard K. Guy'], ['C', \\\n'The smallest, most common, and first discovered spaceship. Diagonal, has period 4 and speed \\\nc/4.'], ['C', 'www.conwaylife.com/wiki/index.php?title=Glider']]\ncells:\n. \u25a0 .\n. . \u25a0\n\u25a0 \u25a0 \u25a0\ncols: 3, rows: 3\nrule: B3/S23\"\"\"\n            )\n\n    def test_metadata_no_content(self) -> None:\n        \"\"\"Test the METADATA parser.\"\"\"\n        results: pp.ParseResults = RunLengthEncodedReader._METADATA_LINE.parse_string(\n            \"\"\"\\\n#N next row has trailing space\n#O \n#C\n#\n#C www.conwaylife.com/wiki/index.php?title=Glider\nx = 3, y = 3, rule = B3/S23\nbob$2bo$3o!\n\"\"\"\n        )\n        assert results.metadata.as_list() == [  # type:ignore\n            [\"N\", \"next row has trailing space\"],\n            [\"O\"],\n            [\"C\"],\n            [],\n            [\"C\", \"www.conwaylife.com/wiki/index.php?title=Glider\"],\n        ]\n\n    def test_metadata_parser(self) -> None:\n        \"\"\"Test the METADATA parser.\"\"\"\n        results: pp.ParseResults = RunLengthEncodedReader._METADATA_LINE.parse_string(\n            \"\"\"\\\n#N Glider\n#O Richard K. Guy\n#C The smallest, most common, and first discovered spaceship. Diagonal, has period 4 and speed c/4.\n#C www.conwaylife.com/wiki/index.php?title=Glider\nx = 3, y = 3, rule = B3/S23\nbob$2bo$3o!\n\"\"\"\n        )\n        assert results.metadata.as_list() == [  # type:ignore\n            [\"N\", \"Glider\"],\n            [\"O\", \"Richard K. Guy\"],\n            [\n                \"C\",\n                \"The smallest, most common, and first discovered spaceship. Diagonal, has period \"\n                + \"4 and speed c/4.\",\n            ],\n            [\"C\", \"www.conwaylife.com/wiki/index.php?title=Glider\"],\n        ]\n\n    def test_header_rule_parser(self) -> None:\n        \"\"\"Test the HEADER parser.\"\"\"\n        results: pp.ParseResults = (\n            RunLengthEncodedReader._HEADER + RunLengthEncodedReader._RULE\n        ).parse_string(\"x = 4, y = 5, rule = B3/S23\")\n        assert results.header.as_list() == [[\"x\", 4], [\"y\", 5]]  # type:ignore\n        assert results.rule.as_list() == [\"B3/S23\"]  # type:ignore\n\n        results = (\n            RunLengthEncodedReader._HEADER + RunLengthEncodedReader._RULE\n        ).parse_string(\"x = 4, y = 5\")\n        assert results.header.as_list() == [[\"x\", 4], [\"y\", 5]]  # type:ignore\n        assert len(results.rule) == 0  # type:ignore\n\n    def test_data_rows_parser(self) -> None:\n        \"\"\"Test the CELL_ROWS parser.\"\"\"\n        results: pp.ParseResults = RunLengthEncodedReader._DATA_ROWS.parse_string(\n            \"bob$2bo$3o!\"\n        )\n        assert results.data_rows.as_list() == [  # type:ignore\n            [\"b\", \"o\", \"b\"],\n            [2, \"b\", \"o\"],\n            [3, \"o\"],\n        ]\n\n        results = RunLengthEncodedReader._DATA_ROWS.parse_string(\n            \"\"\"\\\n24bo$22bobo$12b2o6b2o12b2o$11bo3bo4b2o12b2o$2o8bo5bo3b2o$2o8bo3bob2o4b\nobo$10bo5bo7bo$11bo3bo$12b2o!\n\"\"\"\n        )\n        assert len(results.data_rows) == 9  # type:ignore\n        assert results.data_rows[0].as_list() == [24, \"b\", \"o\"]  # type:ignore\n        assert results.data_rows[6].as_list() == [  # type:ignore\n            10,\n            \"b\",\n            \"o\",\n            5,\n            \"b\",\n            \"o\",\n            7,\n            \"b\",\n            \"o\",\n        ]\n        assert results.data_rows[8].as_list() == [12, \"b\", 2, \"o\"]  # type:ignore\n\n        # Specific test for data that starts with multiple newlines\n        results = RunLengthEncodedReader._DATA_ROWS.parse_string(\n            \"32$8b3o$7bo3bo$6bo4b2o!\"\n        )\n        assert results.data_rows.as_list() == [  # type:ignore\n            [32, \"$\"],\n            [8, \"b\", 3, \"o\"],\n            [7, \"b\", \"o\", 3, \"b\", \"o\"],\n            [6, \"b\", \"o\", 4, \"b\", 2, \"o\"],\n        ]", ""]}
{"filename": "python3/tests/test_game_of_life.py", "chunked_list": ["\"\"\"Tests for all the Conway's Game of Life implementations.\"\"\"\n\nfrom pytest import CaptureFixture, raises\nfrom gameoflife import (\n    MainGame,\n    GameOfLife,\n    GameOfLifeArrays,\n    GameOfLifeDict,\n    GameOfLifeSet,\n)", "    GameOfLifeSet,\n)\nfrom gameoflife.dataio.create_io import create_reader\n\n\ndef test_set_unset_set() -> None:\n    \"\"\"\n    Test that we can set, unset, then set a cell as live.\n\n    GameOfLifeSortedDict had an issue where this wasn't working which was fixed in\n    commit 47543a63a3364f1d00b802d74f8cc136aacc181a.\n    \"\"\"\n    gol: GameOfLife = GameOfLifeArrays(100, 200)\n    set_cell_and_assert(gol, True, 1)\n    set_cell_and_assert(gol, False, 0)\n    set_cell_and_assert(gol, True, 1)\n\n    gol = GameOfLifeDict()\n    set_cell_and_assert(gol, True, 1)\n    set_cell_and_assert(gol, False, 0)\n    set_cell_and_assert(gol, True, 1)\n\n    gol = GameOfLifeSet()\n    set_cell_and_assert(gol, True, 1)\n    set_cell_and_assert(gol, False, 0)\n    set_cell_and_assert(gol, True, 1)", "\n\ndef set_cell_and_assert(gol: GameOfLife, live: bool, num_live: int) -> None:\n    \"\"\"Set a cell and assert it stuck.\"\"\"\n    gol.set_cell(50, 55, live)\n    assert gol.get_cell(50, 55) is live\n    assert gol.count_live_cells() == num_live\n\n\nclass TestGameOfLifeSet:\n    \"\"\"Tests specifically for the class GameOfLifeSet.\"\"\"\n\n    def test_get_live_cells(self) -> None:\n        \"\"\"Test the get_live_cells method.\"\"\"\n        gol: GameOfLife = GameOfLifeSet()\n        MainGame.add_glider(gol)\n        assert gol.count_live_cells() == 5\n        assert gol.get_live_cells() == [(0, 1), (1, 2), (2, 0), (2, 1), (2, 2)]\n\n    def test_glider(self) -> None:\n        \"\"\"Test that a simple glider progresses as expected.\"\"\"\n        gol: GameOfLife = GameOfLifeSet()\n        MainGame.add_glider(gol)\n        assert gol.count_live_cells() == 5\n        for _ in range(1000):\n            gol.progress()\n            assert gol.count_live_cells() == 5\n        assert gol.get_cell(250, 251) is True\n        assert gol.get_cell(251, 252) is True\n        assert gol.get_cell(252, 250) is True\n        assert gol.get_cell(252, 251) is True\n        assert gol.get_cell(252, 252) is True\n        assert gol.generation == 1000\n\n    def test_outofbounds(self) -> None:\n        \"\"\"Test that we get False when asking for a cell out of bounds.\"\"\"\n        gol: GameOfLife = GameOfLifeSet()\n        gol.set_cell(10, 10, True)\n        assert gol.get_cell(2, 2) is False\n        assert gol.get_cell(10, 10) is True\n\n    def test_str(self) -> None:\n        \"\"\"Test the str generation.\"\"\"\n        gol: GameOfLife = GameOfLifeSet()\n        MainGame.add_glider(gol)\n        print(gol)\n        for _ in range(100):\n            gol.progress()\n            assert gol.count_live_cells() == 5\n        print(gol)\n        assert str(gol) == \"Generation: 100\\n  \u25a0   \\n    \u25a0 \\n\u25a0 \u25a0 \u25a0 \"\n\n    def test_match_case2(self) -> None:\n        \"\"\"Test a live cell with exactly 2 neighbours.\"\"\"\n        gol: GameOfLife = GameOfLifeSet()\n        gol.set_cell(0, 0, True)\n        gol.set_cell(0, 1, True)\n        gol.set_cell(0, 2, True)\n        gol.progress()\n        assert gol.get_cell(-1, 1) is True\n        assert gol.get_cell(1, 1) is True\n        assert gol.get_cell(0, 0) is False\n        assert gol.get_cell(0, 2) is False", "\nclass TestGameOfLifeSet:\n    \"\"\"Tests specifically for the class GameOfLifeSet.\"\"\"\n\n    def test_get_live_cells(self) -> None:\n        \"\"\"Test the get_live_cells method.\"\"\"\n        gol: GameOfLife = GameOfLifeSet()\n        MainGame.add_glider(gol)\n        assert gol.count_live_cells() == 5\n        assert gol.get_live_cells() == [(0, 1), (1, 2), (2, 0), (2, 1), (2, 2)]\n\n    def test_glider(self) -> None:\n        \"\"\"Test that a simple glider progresses as expected.\"\"\"\n        gol: GameOfLife = GameOfLifeSet()\n        MainGame.add_glider(gol)\n        assert gol.count_live_cells() == 5\n        for _ in range(1000):\n            gol.progress()\n            assert gol.count_live_cells() == 5\n        assert gol.get_cell(250, 251) is True\n        assert gol.get_cell(251, 252) is True\n        assert gol.get_cell(252, 250) is True\n        assert gol.get_cell(252, 251) is True\n        assert gol.get_cell(252, 252) is True\n        assert gol.generation == 1000\n\n    def test_outofbounds(self) -> None:\n        \"\"\"Test that we get False when asking for a cell out of bounds.\"\"\"\n        gol: GameOfLife = GameOfLifeSet()\n        gol.set_cell(10, 10, True)\n        assert gol.get_cell(2, 2) is False\n        assert gol.get_cell(10, 10) is True\n\n    def test_str(self) -> None:\n        \"\"\"Test the str generation.\"\"\"\n        gol: GameOfLife = GameOfLifeSet()\n        MainGame.add_glider(gol)\n        print(gol)\n        for _ in range(100):\n            gol.progress()\n            assert gol.count_live_cells() == 5\n        print(gol)\n        assert str(gol) == \"Generation: 100\\n  \u25a0   \\n    \u25a0 \\n\u25a0 \u25a0 \u25a0 \"\n\n    def test_match_case2(self) -> None:\n        \"\"\"Test a live cell with exactly 2 neighbours.\"\"\"\n        gol: GameOfLife = GameOfLifeSet()\n        gol.set_cell(0, 0, True)\n        gol.set_cell(0, 1, True)\n        gol.set_cell(0, 2, True)\n        gol.progress()\n        assert gol.get_cell(-1, 1) is True\n        assert gol.get_cell(1, 1) is True\n        assert gol.get_cell(0, 0) is False\n        assert gol.get_cell(0, 2) is False", "\n\nclass TestGameOfLifeArrays:\n    \"\"\"Tests specifically for the class GameOfLifeArrays.\"\"\"\n\n    def test_get_live_cells(self) -> None:\n        \"\"\"Test the get_live_cells method.\"\"\"\n        gol: GameOfLife = GameOfLifeArrays(12, 15)\n        MainGame.add_glider(gol)\n        assert gol.count_live_cells() == 5\n        assert gol.get_live_cells() == [(0, 1), (1, 2), (2, 0), (2, 1), (2, 2)]\n\n    def test_modulo_wrap(self) -> None:\n        \"\"\"Test that a patter larger than the array is wrapped correctly.\"\"\"\n        gol: GameOfLife = GameOfLifeArrays(12, 10)\n        with create_reader(\"../data/test_wrap.cells\") as reader:\n            gol.add_cells(reader)\n        assert (\n            str(gol)\n            == \"Generation: 0\\n\"\n            + \"\u25a1 \u25a1 \u25a0 \u25a1 \u25a1 \u25a0 \u25a1 \u25a0 \u25a1 \u25a1 \\n\"\n            + \"\u25a1 \u25a1 \u25a0 \u25a1 \u25a1 \u25a1 \u25a0 \u25a1 \u25a0 \u25a1 \\n\"\n            + \"\u25a1 \u25a1 \u25a0 \u25a1 \u25a1 \u25a1 \u25a1 \u25a0 \u25a1 \u25a1 \\n\"\n            + \"\u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a0 \u25a1 \\n\"\n            + \"\u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a0 \\n\"\n            + \"\u25a0 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \\n\"\n            + \"\u25a1 \u25a0 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \\n\"\n            + \"\u25a1 \u25a1 \u25a0 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \\n\"\n            + \"\u25a1 \u25a1 \u25a1 \u25a0 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \\n\"\n            + \"\u25a1 \u25a1 \u25a1 \u25a1 \u25a0 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \\n\"\n            + \"\u25a1 \u25a1 \u25a0 \u25a1 \u25a1 \u25a0 \u25a1 \u25a1 \u25a1 \u25a1 \\n\"\n            + \"\u25a1 \u25a1 \u25a0 \u25a1 \u25a1 \u25a1 \u25a0 \u25a1 \u25a1 \u25a1 \"\n        )\n\n    def test_glider(self) -> None:\n        \"\"\"Test that a simple glider progresses as expected.\"\"\"\n        gol: GameOfLife = GameOfLifeArrays(12, 15)\n        MainGame.add_glider(gol)\n        assert gol.count_live_cells() == 5\n        for _ in range(1000):\n            gol.progress()\n            assert gol.count_live_cells() == 5\n        assert gol.get_cell(0, 10) is True\n        assert gol.get_cell(0, 11) is True\n        assert gol.get_cell(0, 12) is True\n        assert gol.get_cell(10, 11) is True\n        assert gol.get_cell(11, 12) is True\n        assert gol.generation == 1000\n\n    def test_outofbounds(self) -> None:\n        \"\"\"Test that we get None when asking for a cell out of bounds.\"\"\"\n        gol: GameOfLife = GameOfLifeArrays(12, 15)\n        gol.set_cell(5, 6, True)\n        assert gol.get_cell(5, 6) is True\n        assert gol.get_cell(2, 2) is False\n        assert gol.get_cell(20, 20) is None\n\n    def test_str(self) -> None:\n        \"\"\"Test the str generation.\"\"\"\n        gol: GameOfLife = GameOfLifeArrays(12, 15)\n        MainGame.add_glider(gol)\n        for _ in range(100):\n            gol.progress()\n            assert gol.count_live_cells() == 5\n        assert (\n            str(gol)\n            == \"Generation: 100\\n\"\n            + \"\u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \\n\"\n            + \"\u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a0 \u25a1 \u25a1 \u25a1 \\n\"\n            + \"\u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a0 \u25a1 \u25a1 \\n\"\n            + \"\u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a0 \u25a0 \u25a0 \u25a1 \u25a1 \\n\"\n            + \"\u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \\n\"\n            + \"\u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \\n\"\n            + \"\u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \\n\"\n            + \"\u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \\n\"\n            + \"\u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \\n\"\n            + \"\u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \\n\"\n            + \"\u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \\n\"\n            + \"\u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \"\n        )", "\n\nclass TestGameOfLifeDict:\n    \"\"\"Tests specifically for the class GameOfLifeSortedDict.\"\"\"\n\n    def test_get_live_cells(self) -> None:\n        \"\"\"Test the get_live_cells method.\"\"\"\n        gol: GameOfLife = GameOfLifeDict()\n        MainGame.add_glider(gol)\n        assert gol.count_live_cells() == 5\n        with raises(NotImplementedError):\n            gol.get_live_cells()\n\n    def test_glider(self) -> None:\n        \"\"\"Test that a simple glider progresses as expected.\"\"\"\n        gol: GameOfLife = GameOfLifeDict()\n        MainGame.add_glider(gol)\n        assert gol.count_live_cells() == 5\n        for _ in range(1000):\n            gol.progress()\n            assert gol.count_live_cells() == 5\n        assert gol.get_cell(250, 251) is True\n        assert gol.get_cell(251, 252) is True\n        assert gol.get_cell(252, 250) is True\n        assert gol.get_cell(252, 251) is True\n        assert gol.get_cell(252, 252) is True\n        assert gol.generation == 1000\n\n    def test_outofbounds(self) -> None:\n        \"\"\"Test that we get False when asking for a cell out of bounds.\"\"\"\n        gol: GameOfLife = GameOfLifeDict()\n        gol.set_cell(10, 10, True)\n        assert gol.get_cell(2, 2) is False\n        assert gol.get_cell(10, 10) is True\n\n    def test_str(self) -> None:\n        \"\"\"Test the str generation.\"\"\"\n        gol: GameOfLife = GameOfLifeDict()\n        MainGame.add_glider(gol)\n        for _ in range(100):\n            gol.progress()\n            assert gol.count_live_cells() == 5\n        assert (\n            str(gol)\n            == \"Generation: 100\\n\"\n            + \"  \u25a1 \u25a1 \u25a1   \\n\"\n            + \"  \u25a1 \u25a0 \u25a1 \u25a1 \\n\"\n            + \"\u25a1 \u25a1 \u25a1 \u25a0 \u25a1 \\n\"\n            + \"\u25a1 \u25a0 \u25a0 \u25a0 \u25a1 \\n\"\n            + \"\u25a1 \u25a1 \u25a1 \u25a1 \u25a1 \"\n        )\n\n    def test_match_case2(self) -> None:\n        \"\"\"Test a live cell with exactly 2 neighbours.\"\"\"\n        gol: GameOfLife = GameOfLifeDict()\n        gol.set_cell(0, 0, True)\n        gol.set_cell(0, 1, True)\n        gol.set_cell(0, 2, True)\n        gol.progress()\n        assert gol.get_cell(-1, 1) is True\n        assert gol.get_cell(1, 1) is True\n        assert gol.get_cell(0, 0) is False\n        assert gol.get_cell(0, 2) is False", "\n\n# pylint: disable=protected-access\n# pyright: reportPrivateUsage=false\nclass TestMainGame:\n    \"\"\"\n    Tests specifically for MainGame.\n\n    Testing this is really awful and will mean changing long strings of text all the time.\n    Is there a better way to do this?\n    \"\"\"\n\n    # use string concatenation to highlight necessary trailing spaces\n    PRINT_UI_OUTPUT: str = (\n        \"\\n\"\n        + \"                                                     Controls                   \\n\"\n        + \"================================================================================\\n\"\n        + \"                                                     (\u30ce\u00ba\u76ca\u00ba)\u30ce\u5f61\u253b\u2501\u253b  q or ESC  \\n\"\n        + \"                                                     Edit cells:      e         \\n\"\n        + \"                                                     Step forward:    <spacebar>\\n\"\n        + \"                                                     Autorun on/off:  a         \\n\"\n        + \"                                                     Speed up/down:   +/-       \\n\"\n        + \"                                                     Move the view:   \u21e6\u21e7\u21e9\u21e8      \"\n    )\n\n    # use string concatenation to highlight necessary trailing spaces\n    PRINT_UI_EDIT_MODE_OUTPUT: str = (\n        \"\\n\"\n        + \"                                                     Controls                   \\n\"\n        + \"================================================================================\\n\"\n        + \"                                                     (\u30ce\u00ba\u76ca\u00ba)\u30ce\u5f61\u253b\u2501\u253b  q or ESC  \\n\"\n        + \"                                                     Exit edit mode:  e         \\n\"\n        + \"                                                     Live/dead cell:  <spacebar>\\n\"\n        + \"                                                     Move cursor:     \u21e6\u21e7\u21e9\u21e8      \\n\"\n        + \"                                                                                \\n\"\n        + \"                                                                                \"\n    )\n\n    # use string concatenation to highlight necessary trailing spaces\n    PRINT_UI_UPDATE_OUTPUT: str = (\n        \" \u25a0 Conways's Game of Life \u25a1 \\n\"\n        + \" ========================== \\n\"\n        + \"Info\\n\"\n        + \"Generation:    0\\n\"\n        + \"Live cells:    5   \\n\"\n        + \"Frame delay:   250 ms    \\n\"\n        + \"Progress time: 0 \u00b5s   \\n\"\n        + \"Coords:        row:0 col:0  \"\n    )\n\n    PRINT_GAME_OUTPUT: str = (\n        \"  \u25a0                                                                            \\n\"\n        + \"    \u25a0                                                                          \\n\"\n        + \"\u25a0 \u25a0 \u25a0                                                                          \\n\"\n        + \"                                                                               \\n\"\n        + \"                                                                               \\n\"\n        + \"                                                                               \\n\"\n        + \"                                                                               \\n\"\n        + \"                                                                               \\n\"\n        + \"                                                                               \\n\"\n        + \"                                                                               \\n\"\n        + \"                                                                               \\n\"\n        + \"                                                                               \\n\"\n        + \"                                                                               \\n\"\n        + \"                                                                               \\n\"\n        + \"                                                                               \\n\"\n    )\n\n    @staticmethod\n    def create_main_game() -> MainGame:\n        \"\"\"Create a MainGame and a Terminal and return them.\"\"\"\n        main: MainGame = MainGame(False, \"../data/glider.rle\")\n        main._run = False\n        main.main()\n        return main\n\n    def test_change_speed(self, capfd: CaptureFixture[str]) -> None:\n        \"\"\"Test the keyboard input functions.\"\"\"\n        main: MainGame = TestMainGame.create_main_game()\n        # increasing speed shorts circuits to 0\n        for _ in range(7):\n            main._increase_speed()\n            capfd.readouterr()\n        assert main._sleep_time == 0.001953125\n        main._increase_speed()\n        capfd.readouterr()\n        assert main._sleep_time == 0\n\n        # decreasing speed goes back to 250 ms\n        for _ in range(8):\n            main._decrease_speed()\n            capfd.readouterr()\n        assert main._sleep_time == 0.25\n\n        # decreasing speed goes to 64\n        for _ in range(8):\n            main._decrease_speed()\n            capfd.readouterr()\n        assert main._sleep_time == 64\n\n    def test_update_screen_size(self, capfd: CaptureFixture[str]) -> None:\n        \"\"\"Test the update_screen_size function.\"\"\"\n        main: MainGame = TestMainGame.create_main_game()\n        main.update_screen_size()\n        capfd.readouterr()\n        assert main._term_width == 80\n        assert main._term_height == 25\n        assert main._header_loc == 40\n        assert main._last_edit_location == (8, 38)\n\n    def test_initialise(self) -> None:\n        \"\"\"Test that we can even run at all.\"\"\"\n        assert MainGame(False)\n\n    def test_initialise_wrap(self) -> None:\n        \"\"\"Test that we load different class when wrapping.\"\"\"\n        main: MainGame = MainGame(True)\n        assert main\n        assert main._gol.__class__.__name__ == GameOfLifeArrays(0, 0).__class__.__name__\n\n    def test_load_rle_file(self, capfd: CaptureFixture[str]) -> None:\n        \"\"\"Test the loading of an RLE file.\"\"\"\n        main: MainGame = MainGame(False, \"../data/glider.rle\")\n        main._run = False\n        main.main()\n        main.print_game()\n        out: str = capfd.readouterr()[0]\n        assert out == TestMainGame.PRINT_GAME_OUTPUT\n\n    def test_load_plain_text_file(self, capfd: CaptureFixture[str]) -> None:\n        \"\"\"Test the loading of a Plain Text file.\"\"\"\n        main: MainGame = MainGame(True, \"../data/glider.cells\", 15, 4)\n        main._run = False\n        main.main()\n        main._origin_col = -4\n        main.print_game()\n        out: str = capfd.readouterr()[0]\n        assert (\n            out\n            == \"        . \u25a0 . .                                                                \\n\"\n            + \"        . . \u25a0 .                                                                \\n\"\n            + \"        \u25a0 \u25a0 \u25a0 .                                                                \\n\"\n            + \"        . . . .                                                                \\n\"\n            + \"        . . . .                                                                \\n\"\n            + \"        . . . .                                                                \\n\"\n            + \"        . . . .                                                                \\n\"\n            + \"        . . . .                                                                \\n\"\n            + \"        . . . .                                                                \\n\"\n            + \"        . . . .                                                                \\n\"\n            + \"        . . . .                                                                \\n\"\n            + \"        . . . .                                                                \\n\"\n            + \"        . . . .                                                                \\n\"\n            + \"        . . . .                                                                \\n\"\n            + \"        . . . .                                                                \\n\"\n        )\n\n    def test_print_ui(self, capfd: CaptureFixture[str]) -> None:\n        \"\"\"Test the print_ui method.\"\"\"\n        main: MainGame = TestMainGame.create_main_game()\n        main.print_ui()\n        out: str = capfd.readouterr()[0]\n        assert out == TestMainGame.PRINT_UI_OUTPUT\n\n    def test_print_ui_edit_mode(self, capfd: CaptureFixture[str]) -> None:\n        \"\"\"Test the print_ui method when edit mode is on.\"\"\"\n        main: MainGame = TestMainGame.create_main_game()\n        main._edit_mode = True\n        main.print_ui()\n        out: str = capfd.readouterr()[0]\n        assert out == TestMainGame.PRINT_UI_EDIT_MODE_OUTPUT\n\n    def test_print_ui_update(self, capfd: CaptureFixture[str]) -> None:\n        \"\"\"Test the print_ui_update method.\"\"\"\n        main: MainGame = TestMainGame.create_main_game()\n        main.print_ui_update(False, main._gol.count_live_cells(), 0)\n        out: str = capfd.readouterr()[0]\n        assert out == TestMainGame.PRINT_UI_UPDATE_OUTPUT\n\n    def test_print_ui_update_progress(self, capfd: CaptureFixture[str]) -> None:\n        \"\"\"Test the print_ui_update method.\"\"\"\n        main: MainGame = TestMainGame.create_main_game()\n\n        # test left edge turnaround\n        main._header_loc = 15\n        main._header_dir_left = True\n        main.print_ui_update(True, main._gol.count_live_cells(), 0)\n        capfd.readouterr()\n        assert main._header_loc == 14\n        assert main._header_dir_left is True\n        main.print_ui_update(True, main._gol.count_live_cells(), 0)\n        out: str = capfd.readouterr()[0]\n        # the output is identical to the previos test_print_ui because term control characters\n        # are not printed\n        assert out == TestMainGame.PRINT_UI_UPDATE_OUTPUT\n        assert main._header_loc == 15\n        assert main._header_dir_left is False\n        main.print_ui_update(True, main._gol.count_live_cells(), 0)\n        assert main._header_loc == 16\n        assert main._header_dir_left is False\n\n        # test right edge turnaround\n        main._header_loc = 66\n        main.print_ui_update(True, main._gol.count_live_cells(), 0)\n        assert main._header_loc == 65\n        assert main._header_dir_left is True\n\n    def test_print_game(self, capfd: CaptureFixture[str]) -> None:\n        \"\"\"Test the print_game method.\"\"\"\n        main: MainGame = TestMainGame.create_main_game()\n        main.print_game()\n        out: str = capfd.readouterr()[0]\n        assert out == TestMainGame.PRINT_GAME_OUTPUT", ""]}
{"filename": "python3/tests/test_performance.py", "chunked_list": ["\"\"\"Performance tests for all the Conway's Game of Life implementations.\"\"\"\n\nimport logging\nfrom time import perf_counter_ns\nimport pytest\nfrom gameoflife import GameOfLife, GameOfLifeDict, GameOfLifeSet\nfrom gameoflife.dataio.create_io import create_reader\n\npytestmark: pytest.MarkDecorator = pytest.mark.performance\nLOGGER: logging.Logger = logging.getLogger(__name__)", "pytestmark: pytest.MarkDecorator = pytest.mark.performance\nLOGGER: logging.Logger = logging.getLogger(__name__)\n\n\n# @pytest.mark.skip\ndef test_dict_progress_large_file() -> None:\n    \"\"\"Performance test for the GameOfLifeDict().progress() method.\"\"\"\n    gol: GameOfLife = GameOfLifeDict()\n    LOGGER.info(\"'create_reader(period59glidergun.rle)' starting...\")\n    start: int = perf_counter_ns()\n    with create_reader(\"../data/period59glidergun.rle\") as reader:\n        gol.add_cells(reader)\n    last_gen_time: int = perf_counter_ns() - start\n    LOGGER.info(\n        \"'create_reader(...)' time: %s \u00b5s\",\n        round(last_gen_time / 1000),\n    )\n\n    # measure the progress() method\n    times: int = 100\n    LOGGER.info(\"'gol.progress()' * %s starting...\", times)\n    start = perf_counter_ns()\n    for _ in range(times):\n        gol.progress()\n    last_gen_time = perf_counter_ns() - start\n    LOGGER.info(\n        \"'gol.progress()' average(%s) time: %s \u00b5s\",\n        times,\n        round(last_gen_time / 1000 / times),\n    )", "\n\n# @pytest.mark.skip\ndef test_set_progress_large_file() -> None:\n    \"\"\"Performance test for the GameOfLifeSet().progress() method.\"\"\"\n    gol: GameOfLife = GameOfLifeSet()\n    LOGGER.info(\"'create_reader(period59glidergun.rle)' starting...\")\n    start: int = perf_counter_ns()\n    with create_reader(\"../data/period59glidergun.rle\") as reader:\n        gol.add_cells(reader)\n    last_gen_time: int = perf_counter_ns() - start\n    LOGGER.info(\n        \"'create_reader(...)' time: %s \u00b5s\",\n        round(last_gen_time / 1000),\n    )\n\n    # measure the progress() method\n    times: int = 100\n    LOGGER.info(\"'gol.progress()' * %s starting...\", times)\n    start = perf_counter_ns()\n    for _ in range(times):\n        gol.progress()\n    last_gen_time = perf_counter_ns() - start\n    LOGGER.info(\n        \"'gol.progress()' average(%s) time: %s \u00b5s\",\n        times,\n        round(last_gen_time / 1000 / times),\n    )", ""]}
{"filename": "python3/tests/__init__.py", "chunked_list": [""]}
