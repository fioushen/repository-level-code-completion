{"filename": "noxfile.py", "chunked_list": ["import nox\n\n\ndef install_poetry_groups(session: nox.Session, *groups: str) -> None:\n    session.run(\"poetry\", \"install\", f\"--with={','.join(groups)}\")\n\n\n@nox.session\ndef typecheck(session: nox.Session) -> None:\n    install_poetry_groups(session, \"typing\")\n    session.run(\"mypy\", \".\")", "def typecheck(session: nox.Session) -> None:\n    install_poetry_groups(session, \"typing\")\n    session.run(\"mypy\", \".\")\n\n\n@nox.session\ndef lint(session: nox.Session) -> None:\n    install_poetry_groups(session, \"linting\")\n    session.run(\"black\", \"--check\", \".\")\n    session.run(\"ruff\", \"check\", \".\")\n    session.run(\"codespell\", \".\")", "\n\n@nox.session\ndef fix(session: nox.Session) -> None:\n    install_poetry_groups(session, \"linting\")\n    session.run(\"black\", \".\")\n    session.run(\"ruff\", \"check\", \"--fix\", \".\")\n    session.run(\"codespell\", \"-w\", \"-i2\", \".\")\n", ""]}
{"filename": "bot/manager.py", "chunked_list": ["from __future__ import annotations\n\nimport asyncio\nimport typing as t\n\nfrom bot import models\nfrom bot.providers.godbolt import GodBolt\nfrom bot.providers.piston import Piston\nfrom bot.providers.provider import Provider\n\nif t.TYPE_CHECKING:\n    from bot.app import Model", "from bot.providers.provider import Provider\n\nif t.TYPE_CHECKING:\n    from bot.app import Model\n\n\nclass Manager:\n    def __init__(self, model: Model) -> None:\n        self.piston_provider = Piston(model)\n        self.providers: list[Provider] = [GodBolt(model), self.piston_provider]\n        self.runtimes = models.RuntimeTree()\n        self.model = model\n\n    async def startup(self) -> None:\n        await asyncio.gather(\n            *(asyncio.create_task(p.startup()) for p in self.providers)\n        )\n\n    async def shutdown(self) -> None:\n        await asyncio.gather(\n            *(asyncio.create_task(p.shutdown()) for p in self.providers)\n        )\n\n    async def update_data(self) -> None:\n        await asyncio.gather(\n            *(asyncio.create_task(p.update_data()) for p in self.providers)\n        )\n\n        runtimes = models.RuntimeTree()\n        for provider in self.providers:\n            runtimes.extend(provider.runtimes)\n        runtimes.sort()\n        self.runtimes = runtimes\n\n    def unalias(self, language: str) -> str | None:\n        if language in self.runtimes.run or language in self.runtimes.asm:\n            return language\n\n        return self.piston_provider.aliases.get(language)", ""]}
{"filename": "bot/__main__.py", "chunked_list": ["from bot.app import main\n\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "bot/app.py", "chunked_list": ["import crescent\nimport hikari\n\nfrom bot.config import CONFIG\nfrom bot.manager import Manager\n\nPlugin = crescent.Plugin[hikari.GatewayBot, \"Model\"]\nINTENTS = hikari.Intents.ALL_UNPRIVILEGED | hikari.Intents.MESSAGE_CONTENT\n\n\nclass Model:\n    def __init__(self) -> None:\n        self.manager = Manager(self)\n\n    async def startup(self) -> None:\n        await self.manager.startup()\n\n    async def shutdown(self) -> None:\n        await self.manager.shutdown()", "\n\nclass Model:\n    def __init__(self) -> None:\n        self.manager = Manager(self)\n\n    async def startup(self) -> None:\n        await self.manager.startup()\n\n    async def shutdown(self) -> None:\n        await self.manager.shutdown()", "\n\ndef main() -> None:\n    app = hikari.GatewayBot(CONFIG.TOKEN, intents=INTENTS)\n    client = crescent.Client(app, model := Model())\n\n    @app.listen(hikari.StartingEvent)\n    async def _(_: hikari.StartingEvent) -> None:\n        await model.startup()\n\n    @app.listen(hikari.StoppingEvent)\n    async def _(_: hikari.StoppingEvent) -> None:\n        await model.shutdown()\n\n    client.plugins.load_folder(\"bot.plugins\")\n    app.run()", ""]}
{"filename": "bot/config.py", "chunked_list": ["import dataclasses\nimport typing as t\n\nimport dotenv\n\n\n@dataclasses.dataclass\nclass Config:\n    TOKEN: str\n    PISTON_URL: str = \"https://emkc.org/api/v2/piston/\"\n    GODBOLT_URL: str = \"https://godbolt.org/api/\"", "\n\nenv_vars: dict[str, str] = t.cast(dict[str, str], dotenv.dotenv_values())\ntry:\n    CONFIG = Config(**env_vars)\nexcept TypeError as e:\n    raise Exception(\n        \"You have an error in your .env file. Check the README for more info.\"\n    ) from e\n", ""]}
{"filename": "bot/models.py", "chunked_list": ["from __future__ import annotations\n\nimport functools\nimport re\nimport typing as t\nfrom collections import defaultdict\nfrom dataclasses import dataclass, field\nfrom enum import Enum, auto\n\nimport dahlia", "\nimport dahlia\n\nfrom bot.providers.provider import Provider\nfrom bot.utils.display import format_text\n\n\nclass Action(Enum):\n    RUN = auto()\n    ASM = auto()", "\n\n@dataclass\nclass Runtime:\n    id: str\n    name: str\n    description: str\n    provider: Provider\n\n", "\n\n@dataclass\nclass Code:\n    code: str\n    filename: t.Optional[str] = None\n    language: t.Optional[str] = None\n\n\n@dataclass\nclass Result:\n    output: str\n\n    def format(self) -> str:\n        out = format_text(self.output)\n        try:\n            out = dahlia.quantize_ansi(out, to=3)\n        except Exception:\n            pass\n        return out", "\n@dataclass\nclass Result:\n    output: str\n\n    def format(self) -> str:\n        out = format_text(self.output)\n        try:\n            out = dahlia.quantize_ansi(out, to=3)\n        except Exception:\n            pass\n        return out", "\n\nTREE_T = t.Dict[\n    str | None,  # language\n    t.Dict[\n        str | None,  # Instruction Set\n        t.Dict[\n            str | None,  # Compiler Type\n            t.Dict[\n                str | None,  # Version", "            t.Dict[\n                str | None,  # Version\n                Runtime,\n            ],\n        ],\n    ],\n]\n\n\ndef make_tree() -> TREE_T:\n    return defaultdict(lambda: defaultdict(lambda: defaultdict(dict)))", "\ndef make_tree() -> TREE_T:\n    return defaultdict(lambda: defaultdict(lambda: defaultdict(dict)))\n\n\n@dataclass\nclass RuntimeTree:\n    asm: TREE_T = field(default_factory=make_tree)\n    run: TREE_T = field(default_factory=make_tree)\n\n    def extend(self, other: RuntimeTree) -> None:\n        for this_tree, other_tree in [(self.asm, other.asm), (self.run, other.run)]:\n            for lang, tree in other_tree.items():\n                for compiler, tree2 in tree.items():\n                    for instruction, tree3 in tree2.items():\n                        for version, runtime in tree3.items():\n                            this_tree[lang][compiler][instruction][version] = runtime\n\n    def sort(self) -> None:\n        self.asm = sort(self.asm)\n        self.run = sort(self.run)", "\n\nK = t.TypeVar(\"K\")\nT = t.TypeVar(\"T\")\nSEMVER_RE = re.compile(r\"(\\d+)(\\.(\\d+))+\")\n\n\n@dataclass\n@functools.total_ordering\nclass Key:\n    semver: t.Optional[list[int]]\n    string: str\n\n    def __lt__(self, other: object) -> bool:\n        assert isinstance(other, Key)\n        if self.semver and other.semver:\n            return self.semver < other.semver\n\n        if self.string == \"piston\":\n            return True\n        elif other.string == \"piston\":\n            return False\n\n        return self.string > other.string\n\n    def __eq__(self, other: object) -> bool:\n        return False", "@functools.total_ordering\nclass Key:\n    semver: t.Optional[list[int]]\n    string: str\n\n    def __lt__(self, other: object) -> bool:\n        assert isinstance(other, Key)\n        if self.semver and other.semver:\n            return self.semver < other.semver\n\n        if self.string == \"piston\":\n            return True\n        elif other.string == \"piston\":\n            return False\n\n        return self.string > other.string\n\n    def __eq__(self, other: object) -> bool:\n        return False", "\n\ndef sort(item: dict[K, T]) -> dict[K, T]:\n    def key(item: tuple[K, object]) -> Key:\n        key = item[0]\n        if isinstance(key, str):\n            if m := SEMVER_RE.search(key):\n                version = [int(i) for i in m.group().split(\".\")]\n                return Key(version, key)\n        return Key([], str(key))\n\n    item = {k: v for k, v in sorted(item.items(), key=key, reverse=True)}\n    for k, v in item.items():\n        if isinstance(v, dict):\n            item[k] = t.cast(T, sort(v))\n\n    return item", ""]}
{"filename": "bot/lang_defaults.py", "chunked_list": ["DEFAULTS = {\n    \"python\": \"piston\",\n    \"rust\": {\"amd64\": \"rust\"},\n    \"go\": {\"amd64\": \"none\"},\n    \"typescript\": \"piston\",\n    \"c\": {\n        \"amd64\": {\n            \"clang-intel\": \"16.0.0\",\n            \"clang\": \"16.0.0\",\n        },", "            \"clang\": \"16.0.0\",\n        },\n        \"aarch64\": {\"clang\": \"16.0.0\"},\n    },\n    \"c++\": {\n        \"amd64\": {\n            \"clang-intel\": \"16.0.0\",\n            \"clang\": \"16.0.0\",\n        },\n        \"aarch64\": {", "        },\n        \"aarch64\": {\n            \"clang\": \"16.0.0\",\n        },\n    },\n}\n"]}
{"filename": "bot/__init__.py", "chunked_list": [""]}
{"filename": "bot/constants.py", "chunked_list": ["import hikari\n\nEMBED_COLOR = hikari.Color(0xF7B159)\n"]}
{"filename": "bot/plugins/instance.py", "chunked_list": ["from __future__ import annotations\n\nimport contextlib\nimport enum\nimport typing as t\nfrom dataclasses import dataclass, field\n\nimport crescent\nimport hikari\n", "import hikari\n\nfrom bot import models\nfrom bot.app import Plugin\nfrom bot.lang_defaults import DEFAULTS\nfrom bot.utils import parse\n\nplugin = Plugin()\ninstances: dict[hikari.Snowflake, Instance] = {}\n", "instances: dict[hikari.Snowflake, Instance] = {}\n\n\nK = t.TypeVar(\"K\")\nV = t.TypeVar(\"V\")\n\n\nclass ComponentID(enum.StrEnum):\n    DELETE = \"delete\"\n    REFRESH_CODE = \"refresh_code\"", "    DELETE = \"delete\"\n    REFRESH_CODE = \"refresh_code\"\n    CODE_BLOCK = \"code_block\"\n    LANGUAGE = \"language\"\n    TOGGLE_MODE = \"toggle_mode\"\n    INSTRUCTION_SET = \"instruction_set\"\n    COMPILER_TYPE = \"compiler_type\"\n    VERSION = \"version\"\n    STDIN = \"stdin\"\n", "    STDIN = \"stdin\"\n\n\nclass ModalID(enum.StrEnum):\n    LANGUAGE = \"language\"\n    STDIN = \"stdin\"\n\n\ndef next_in_default_chain(path: list[str | None]) -> str | None:\n    tree = DEFAULTS", "def next_in_default_chain(path: list[str | None]) -> str | None:\n    tree = DEFAULTS\n    for k in path:\n        if isinstance(tree, str):\n            return None\n        tree = tree.get(k)  # type: ignore\n        if not tree:\n            return None\n\n    if isinstance(tree, str):", "\n    if isinstance(tree, str):\n        return tree\n    elif isinstance(tree, dict):\n        return next(iter(tree.keys()))\n    return None\n\n\ndef get_or_first(\n    dct: dict[str | None, V], key: str | None, path: list[str | None]", "def get_or_first(\n    dct: dict[str | None, V], key: str | None, path: list[str | None]\n) -> tuple[str | None, V] | None:\n    with contextlib.suppress(KeyError):\n        return (key, dct[key])\n\n    if k := next_in_default_chain(path):\n        with contextlib.suppress(KeyError):\n            return (k, dct[k])\n", "            return (k, dct[k])\n\n    with contextlib.suppress(StopIteration):\n        return next(iter(dct.items()))\n\n    return None\n\n\n@plugin.include\n@crescent.event", "@plugin.include\n@crescent.event\nasync def on_modal_interaction(event: hikari.InteractionCreateEvent) -> None:\n    if not isinstance(event.interaction, hikari.ModalInteraction):\n        return\n\n    if not (message := event.interaction.message):\n        return\n\n    if not (inst := instances.get(message.id)):", "\n    if not (inst := instances.get(message.id)):\n        return\n\n    id = event.interaction.custom_id\n\n    match id:\n        case ModalID.LANGUAGE:\n            lang: str | None = event.interaction.components[0].components[0].value\n            if not lang:", "            lang: str | None = event.interaction.components[0].components[0].value\n            if not lang:\n                if inst.code:\n                    lang = inst.code.language\n                else:\n                    lang = None\n                inst.update_language(lang, False)\n            else:\n                inst.update_language(lang, True)\n        case ModalID.STDIN:", "                inst.update_language(lang, True)\n        case ModalID.STDIN:\n            inst.stdin = event.interaction.components[0].components[0].value\n\n    await event.app.rest.create_interaction_response(\n        event.interaction,\n        event.interaction.token,\n        hikari.ResponseType.MESSAGE_UPDATE,\n        components=inst.components(),\n        content=\"Working...\",", "        components=inst.components(),\n        content=\"Working...\",\n        attachment=None,\n    )\n    await inst.execute()\n\n\n@plugin.include\n@crescent.event\nasync def on_component_interaction(event: hikari.InteractionCreateEvent) -> None:", "@crescent.event\nasync def on_component_interaction(event: hikari.InteractionCreateEvent) -> None:\n    if not isinstance(event.interaction, hikari.ComponentInteraction):\n        return\n\n    if not (inst := instances.get(event.interaction.message.id)):\n        return\n\n    if event.interaction.user.id != inst.requester:\n        await event.app.rest.create_interaction_response(", "    if event.interaction.user.id != inst.requester:\n        await event.app.rest.create_interaction_response(\n            event.interaction,\n            event.interaction.token,\n            hikari.ResponseType.MESSAGE_CREATE,\n            flags=hikari.MessageFlag.EPHEMERAL,\n            content=\"Only the person who created this instance can edit it.\",\n        )\n        return\n", "        return\n\n    id = event.interaction.custom_id\n\n    match id:\n        case ComponentID.DELETE:\n            await inst.delete()\n            return\n        case ComponentID.REFRESH_CODE:\n            message = await plugin.app.rest.fetch_message(inst.channel, inst.message)", "        case ComponentID.REFRESH_CODE:\n            message = await plugin.app.rest.fetch_message(inst.channel, inst.message)\n            await inst.update(message)\n        case ComponentID.CODE_BLOCK:\n            if v := event.interaction.values:\n                for x, block in enumerate(inst.codes):\n                    if str(x) == v[0]:\n                        inst.update_code(block)\n                        break\n            else:", "                        break\n            else:\n                if inst.codes:\n                    inst.update_code(inst.codes[0])\n        case ComponentID.LANGUAGE:\n            await event.app.rest.create_modal_response(\n                event.interaction,\n                event.interaction.token,\n                title=\"Select Language\",\n                custom_id=ModalID.LANGUAGE,", "                title=\"Select Language\",\n                custom_id=ModalID.LANGUAGE,\n                component=event.app.rest.build_modal_action_row().add_text_input(\n                    ModalID.LANGUAGE,\n                    \"Language\",\n                    placeholder=\"Leave empty to use the default.\",\n                    required=False,\n                ),\n            )\n            return", "            )\n            return\n        case ComponentID.TOGGLE_MODE:\n            if inst.action is models.Action.RUN:\n                inst.update_action(models.Action.ASM)\n            else:\n                inst.update_action(models.Action.RUN)\n        case ComponentID.INSTRUCTION_SET:\n            if v := event.interaction.values:\n                inst.instruction_set = v[0]", "            if v := event.interaction.values:\n                inst.instruction_set = v[0]\n            else:\n                inst.instruction_set = None\n            inst.compiler_type = None\n            inst.version = None\n        case ComponentID.COMPILER_TYPE:\n            if v := event.interaction.values:\n                inst.compiler_type = v[0]\n            else:", "                inst.compiler_type = v[0]\n            else:\n                inst.compiler_type = None\n            inst.version = None\n        case ComponentID.VERSION:\n            if v := event.interaction.values:\n                inst.version = v[0]\n            else:\n                inst.version = None\n        case ComponentID.STDIN:", "                inst.version = None\n        case ComponentID.STDIN:\n            await event.app.rest.create_modal_response(\n                event.interaction,\n                event.interaction.token,\n                title=\"Set STDIN\",\n                custom_id=ModalID.STDIN,\n                component=event.app.rest.build_modal_action_row().add_text_input(\n                    ModalID.STDIN,\n                    \"Set STDIN\",", "                    ModalID.STDIN,\n                    \"Set STDIN\",\n                    value=inst.stdin or hikari.UNDEFINED,\n                    required=False,\n                    style=hikari.TextInputStyle.PARAGRAPH,\n                ),\n            )\n            return\n\n    await event.app.rest.create_interaction_response(", "\n    await event.app.rest.create_interaction_response(\n        event.interaction,\n        event.interaction.token,\n        hikari.ResponseType.MESSAGE_UPDATE,\n        content=\"Working...\",\n        attachment=None,\n        components=inst.components(),\n    )\n    await inst.execute()", "    )\n    await inst.execute()\n\n\nT = t.TypeVar(\"T\")\n\n\n@dataclass\nclass Setting(t.Generic[T]):\n    v: T", "class Setting(t.Generic[T]):\n    v: T\n    overwritten: bool = False\n\n    def update(self, v: T) -> None:\n        self.v = v\n        self.overwritten = False\n\n    def user_update(self, v: T) -> None:\n        self.v = v", "    def user_update(self, v: T) -> None:\n        self.v = v\n        self.overwritten = True\n\n    @classmethod\n    def make(cls, v: T) -> Setting[T]:\n        return field(default_factory=lambda: cls(v))\n\n\nclass Selector(t.NamedTuple):", "\nclass Selector(t.NamedTuple):\n    id: ComponentID\n    \"\"\"The custom ID for the component used to select this.\"\"\"\n    selected: str | None\n    \"\"\"The currently selected runtime.\"\"\"\n    options: list[str | None]\n    \"\"\"A list of all runtimes the user can select.\"\"\"\n\n", "\n\n@dataclass\nclass Instance:\n    channel: hikari.Snowflake\n    message: hikari.Snowflake\n    requester: hikari.Snowflake\n    codes: list[models.Code]\n\n    code: t.Optional[models.Code] = None", "\n    code: t.Optional[models.Code] = None\n    stdin: str | None = None\n    language: Setting[t.Optional[str]] = Setting.make(None)\n    action: models.Action = models.Action.RUN\n    instruction_set: str | None = None\n    compiler_type: str | None = None\n    version: str | None = None\n\n    response: t.Optional[hikari.Snowflake] = None", "\n    response: t.Optional[hikari.Snowflake] = None\n\n    def update_code(self, code: models.Code | None) -> None:\n        self.code = code\n        if (\n            code\n            and code.language\n            and plugin.model.manager.unalias(code.language.lower()) != self.language.v\n            and not self.language.overwritten", "            and plugin.model.manager.unalias(code.language.lower()) != self.language.v\n            and not self.language.overwritten\n        ):\n            self.update_language(code.language, False)\n\n    def update_language(self, language: str | None, user: bool) -> None:\n        if language:\n            language = plugin.model.manager.unalias(language.lower())\n        if user:\n            self.language.user_update(language)", "        if user:\n            self.language.user_update(language)\n        else:\n            self.language.update(language)\n\n        self.reset_selectors()\n\n    def update_action(self, action: models.Action) -> None:\n        self.action = action\n", "        self.action = action\n\n    def reset_selectors(self) -> None:\n        self.instruction_set = None\n        self.compiler_type = None\n        self.version = None\n\n    def selectors(self) -> list[Selector]:\n        if self.language.v is None:\n            return []", "        if self.language.v is None:\n            return []\n\n        selectors: list[Selector] = []\n\n        runtimes = plugin.model.manager.runtimes\n        match self.action:\n            case models.Action.RUN:\n                tree = runtimes.run\n            case models.Action.ASM:", "                tree = runtimes.run\n            case models.Action.ASM:\n                tree = runtimes.asm\n\n        path: list[str | None] = []\n        if instructions := tree.get(self.language.v):\n            path.append(self.language.v)\n            if instruction_set_select := get_or_first(\n                instructions, self.instruction_set, path\n            ):", "                instructions, self.instruction_set, path\n            ):\n                instruction_set, compilers = instruction_set_select\n                if len(instructions) > 1:\n                    selectors.append(\n                        Selector(\n                            id=ComponentID.INSTRUCTION_SET,\n                            selected=instruction_set,\n                            options=list(instructions),\n                        )", "                            options=list(instructions),\n                        )\n                    )\n                path.append(instruction_set)\n\n                if compiler_type_select := get_or_first(\n                    compilers, self.compiler_type, path\n                ):\n                    compiler, versions = compiler_type_select\n                    if len(compilers) > 1:", "                    compiler, versions = compiler_type_select\n                    if len(compilers) > 1:\n                        selectors.append(\n                            Selector(\n                                id=ComponentID.COMPILER_TYPE,\n                                selected=compiler,\n                                options=list(compilers),\n                            )\n                        )\n                    path.append(compiler)", "                        )\n                    path.append(compiler)\n\n                    if version_select := get_or_first(versions, self.version, path):\n                        version, _ = version_select\n                        selectors.append(\n                            Selector(\n                                id=ComponentID.VERSION,\n                                selected=version,\n                                options=list(versions),", "                                selected=version,\n                                options=list(versions),\n                            )\n                        )\n\n        return selectors\n\n    @property\n    def runtime(self) -> models.Runtime | None:\n        lang = self.language.v", "    def runtime(self) -> models.Runtime | None:\n        lang = self.language.v\n\n        match self.action:\n            case models.Action.RUN:\n                tree = plugin.model.manager.runtimes.run\n            case models.Action.ASM:\n                tree = plugin.model.manager.runtimes.asm\n\n        path: list[str | None] = [lang]", "\n        path: list[str | None] = [lang]\n        if not (tree2 := tree.get(lang)):\n            return None\n\n        if not (tree3 := get_or_first(tree2, self.instruction_set, path)):\n            return None\n        self.instruction_set = tree3[0]\n        path.append(tree3[0])\n        if not (tree4 := get_or_first(tree3[1], self.compiler_type, path)):", "        path.append(tree3[0])\n        if not (tree4 := get_or_first(tree3[1], self.compiler_type, path)):\n            return None\n        self.compiler_type = tree4[0]\n        path.append(tree4[0])\n        tree5 = get_or_first(tree4[1], self.version, path)\n        if tree5:\n            self.version = tree5[0]\n            return tree5[1]\n        else:", "            return tree5[1]\n        else:\n            return None\n\n    @staticmethod\n    async def from_original(\n        message: hikari.Message,\n        requester: hikari.Snowflake,\n    ) -> Instance | None:\n        codes = await parse.get_codes(message)", "    ) -> Instance | None:\n        codes = await parse.get_codes(message)\n        if not codes:\n            return None\n\n        instance = Instance(message.channel_id, message.id, requester, codes)\n        instance.update_code(codes[0])\n\n        return instance\n", "        return instance\n\n    async def delete(self) -> None:\n        if not self.response:\n            return\n        try:\n            await plugin.app.rest.delete_message(self.channel, self.response)\n        except hikari.NotFoundError:\n            pass\n        else:", "            pass\n        else:\n            del instances[self.response]\n\n    async def update(self, message: hikari.Message) -> None:\n        if not (codes := await parse.get_codes(message)):\n            await self.delete()\n            return\n\n        self.codes = codes", "\n        self.codes = codes\n        self.update_code(codes[0])\n\n    def components(self) -> list[hikari.api.MessageActionRowBuilder]:\n        rows = []\n\n        # basic buttons\n        rows.append(\n            plugin.app.rest.build_message_action_row()", "        rows.append(\n            plugin.app.rest.build_message_action_row()\n            .add_interactive_button(\n                hikari.ButtonStyle.SECONDARY, ComponentID.DELETE, label=\"Delete\"\n            )\n            .add_interactive_button(\n                hikari.ButtonStyle.SECONDARY,\n                ComponentID.REFRESH_CODE,\n                label=\"Refresh Code\",\n            )", "                label=\"Refresh Code\",\n            )\n            .add_interactive_button(\n                hikari.ButtonStyle.SECONDARY,\n                ComponentID.TOGGLE_MODE,\n                label=\"Mode: Execute\"\n                if self.action is models.Action.RUN\n                else \"Mode: ASM\",\n            )\n            .add_interactive_button(", "            )\n            .add_interactive_button(\n                hikari.ButtonStyle.SECONDARY,\n                ComponentID.LANGUAGE,\n                label=f\"Language: {self.language.v or 'Unknown'}\",\n            )\n            .add_interactive_button(\n                hikari.ButtonStyle.SECONDARY,\n                ComponentID.STDIN,\n                label=\"Set STDIN\",", "                ComponentID.STDIN,\n                label=\"Set STDIN\",\n            )\n        )\n\n        # code block selection\n        if len(self.codes) > 1:\n            select = plugin.app.rest.build_message_action_row().add_text_menu(\n                ComponentID.CODE_BLOCK,\n                placeholder=\"Select the code block to run\",", "                ComponentID.CODE_BLOCK,\n                placeholder=\"Select the code block to run\",\n            )\n            for x, block in enumerate(self.codes):\n                if block.filename:\n                    label = f\"Attachment {block.filename}\"\n                else:\n                    label = f'Code Block: \"{block.code[0:32]}...\"'\n                select.add_option(label, str(x), is_default=block == self.code)\n            rows.append(select.parent)", "                select.add_option(label, str(x), is_default=block == self.code)\n            rows.append(select.parent)\n\n        # version\n        for id, selected, options in self.selectors():\n            select = (\n                plugin.app.rest.build_message_action_row()\n                .add_text_menu(id)\n                .set_is_disabled(len(options) == 1)\n            )", "                .set_is_disabled(len(options) == 1)\n            )\n            for option in options[0:25]:\n                select.add_option(\n                    str(option), str(option), is_default=option == selected\n                )\n            rows.append(select.parent)\n\n        return rows\n", "        return rows\n\n    async def execute(self) -> None:\n        if not self.response:\n            await plugin.app.rest.trigger_typing(self.channel)\n\n        # try to execute code\n        code_file: hikari.Bytes | None = None\n        stdin_file: hikari.Bytes | None = None\n        out: list[str] = [f\"<@{self.requester}>\"]", "        stdin_file: hikari.Bytes | None = None\n        out: list[str] = [f\"<@{self.requester}>\"]\n\n        code_output_in_file = False\n        stdin_in_file = False\n\n        code_output: str = \"\"\n        if self.runtime:\n            ret = await self.runtime.provider.execute(self)\n            code_output = ret.format()", "            ret = await self.runtime.provider.execute(self)\n            code_output = ret.format()\n\n            if not code_output.strip():\n                out.append(\"Your code ran with no output.\")\n                code_output = \"\"\n        else:\n            out.append(\"No runtime selected.\")\n\n        stdin = self.stdin or \"\"", "\n        stdin = self.stdin or \"\"\n        formatted_stdin = \"\\n\".join(\n            f\"\\x1b[1;33mIN:\\x1b[0m {line}\" for line in stdin.splitlines()\n        )\n\n        if len(code_output) + len(formatted_stdin) > 1_950:\n            if len(code_output) < 1_950:\n                stdin_in_file = True\n            elif len(formatted_stdin) < 1_950:", "                stdin_in_file = True\n            elif len(formatted_stdin) < 1_950:\n                code_output_in_file = True\n            else:\n                code_output_in_file = True\n                stdin_in_file = True\n\n        if code_output:\n            if code_output_in_file:\n                code_file = hikari.Bytes(code_output, \"code.ansi\")", "            if code_output_in_file:\n                code_file = hikari.Bytes(code_output, \"code.ansi\")\n            else:\n                out.append(f\"```ansi\\n{code_output}```\")\n\n        if stdin:\n            if stdin_in_file:\n                stdin_file = hikari.Bytes(stdin, \"stdin.txt\")\n            else:\n                out.append(f\"```ansi\\n{formatted_stdin}```\")", "            else:\n                out.append(f\"```ansi\\n{formatted_stdin}```\")\n\n        # send message\n        out_str = \"\\n\".join(out)\n        rows = self.components()\n        attachments = list(filter(None, [code_file, stdin_file]))\n        if self.response:\n            await plugin.app.rest.edit_message(\n                self.channel,", "            await plugin.app.rest.edit_message(\n                self.channel,\n                self.response,\n                out_str,\n                components=rows,\n                attachments=attachments or None,\n            )\n        else:\n            resp = await plugin.app.rest.create_message(\n                self.channel,", "            resp = await plugin.app.rest.create_message(\n                self.channel,\n                out_str,\n                reply=self.message,\n                components=rows,\n                attachments=attachments,\n                user_mentions=[self.requester],\n            )\n            self.response = resp.id\n            instances[resp.id] = self", "            self.response = resp.id\n            instances[resp.id] = self\n"]}
{"filename": "bot/plugins/help.py", "chunked_list": ["import crescent\nimport hikari\n\nfrom bot.app import Plugin\nfrom bot.constants import EMBED_COLOR\n\nplugin = Plugin()\n\nHELP_EMBEDS = [\n    hikari.Embed(", "HELP_EMBEDS = [\n    hikari.Embed(\n        description=(\n            \"Hi! My name is io, and my job is to run code.\"\n            \"\\n I can run any code inside of code blocks:\"\n            \"\\n```\"\n            \"\\n`\\u200b`\\u200b`\\u200b<language-name>\"\n            \"\\n<your code here>\"\n            \"\\n`\\u200b`\\u200b`\\u200b\"\n            \"\\n```\"", "            \"\\n`\\u200b`\\u200b`\\u200b\"\n            \"\\n```\"\n        ),\n        color=EMBED_COLOR,\n    ),\n    hikari.Embed(\n        description=(\n            \"\\n- Running code - Start your message with `io/run`.\"\n            \"\\n- View Assembly - Start your message with `io/asm`.\"\n            \"\\nYou can use message commands by right-clicking on a message, \"", "            \"\\n- View Assembly - Start your message with `io/asm`.\"\n            \"\\nYou can use message commands by right-clicking on a message, \"\n            \"selecting the `Apps` subcategory, then clicking on the `Create Instance` \"\n            \"command.\"\n        ),\n        color=EMBED_COLOR,\n    ),\n]\n\n", "\n\n@plugin.include\n@crescent.command\nasync def help(ctx: crescent.Context) -> None:\n    await ctx.respond(embeds=HELP_EMBEDS)\n\n\n@plugin.include\n@crescent.event", "@plugin.include\n@crescent.event\nasync def on_message(message: hikari.MessageCreateEvent) -> None:\n    me = plugin.app.get_me()\n\n    if not me:\n        return\n\n    if not message.is_human:\n        return", "    if not message.is_human:\n        return\n\n    if not message.content:\n        return\n\n    if not (\n        message.content == me.mention\n        or message.content == \"io/help\"\n        or (\n            message.content.startswith(me.mention)\n            and message.content.removeprefix(me.mention).strip() == \"help\"\n        )\n    ):\n        return", "\n    await message.message.respond(embeds=HELP_EMBEDS, reply=True)\n"]}
{"filename": "bot/plugins/events.py", "chunked_list": ["import crescent\nimport hikari\n\nfrom bot import models\nfrom bot.app import Plugin\nfrom bot.plugins.instance import Instance\n\nplugin = Plugin()\n\n", "\n\n@plugin.include\n@crescent.event\nasync def on_message(event: hikari.MessageCreateEvent) -> None:\n    if not event.is_human:\n        return None\n    if not (ct := event.message.content):\n        return None\n    if not ct.startswith(\"io/\"):", "        return None\n    if not ct.startswith(\"io/\"):\n        return None\n    try:\n        cmd = ct[3:].splitlines()[0].split(\" \", 1)[0]\n    except KeyError:\n        return None\n    match cmd:\n        case \"run\":\n            action = models.Action.RUN", "        case \"run\":\n            action = models.Action.RUN\n        case \"asm\":\n            action = models.Action.ASM\n        case _:\n            return None\n\n    instance = await Instance.from_original(event.message, event.author_id)\n    if not instance:\n        return", "    if not instance:\n        return\n\n    instance.action = action\n    await instance.execute()\n"]}
{"filename": "bot/plugins/tasks.py", "chunked_list": ["from crescent.ext import tasks\n\nfrom bot.app import Plugin\n\nplugin = Plugin()\n\n\n@plugin.include\n@tasks.loop(minutes=30)\nasync def update_languages() -> None:", "@tasks.loop(minutes=30)\nasync def update_languages() -> None:\n    await plugin.model.manager.update_data()\n"]}
{"filename": "bot/plugins/message_commands.py", "chunked_list": ["import crescent\nimport hikari\n\nfrom bot.app import Plugin\n\nfrom .instance import Instance\n\nplugin = Plugin()\n\n", "\n\n@plugin.include\n@crescent.message_command(name=\"Create Instance\")\nasync def create_instance(ctx: crescent.Context, msg: hikari.Message) -> None:\n    inst = await Instance.from_original(msg, ctx.user.id)\n    if not inst:\n        await ctx.respond(\"No code blocks to run could be found.\", ephemeral=True)\n        return\n", "\n    await ctx.respond(\"Instance created.\", ephemeral=True)\n    await inst.execute()\n"]}
{"filename": "bot/plugins/__init__.py", "chunked_list": [""]}
{"filename": "bot/plugins/languages.py", "chunked_list": ["import crescent\nimport hikari\n\nfrom bot.app import Plugin\nfrom bot.constants import EMBED_COLOR\n\nplugin = Plugin()\n\n\n@plugin.include", "\n@plugin.include\n@crescent.command\nasync def languages(ctx: crescent.Context) -> None:\n    lang_names = list(\n        f\"`{runtime}`\" for runtime in plugin.model.manager.runtimes.run if runtime\n    )\n    embed = hikari.Embed(\n        title=\"Supported Languages\", description=\",\".join(lang_names), color=EMBED_COLOR\n    )", "        title=\"Supported Languages\", description=\",\".join(lang_names), color=EMBED_COLOR\n    )\n    await ctx.respond(embed=embed)\n"]}
{"filename": "bot/utils/fixes.py", "chunked_list": ["import re\n\nJAVA_PUBLIC_CLASS_REGEX = re.compile(r\"public\\s+class\")\nRUST_FN_REGEX = re.compile(r\"fn\\s+main\\s*\\(\\s*\\)\")\n\nZIG_STD_REGEX = re.compile(r\"std\\s*=\")\nZIG_MAIN_FN_REGEX = re.compile(r\"fn\\s+main\\s*\\(\\s*\\)\")\n\n\ndef transform_code(lang: str, code: str) -> str:", "\ndef transform_code(lang: str, code: str) -> str:\n    \"\"\"\n    Converts the code into new code based on the language and some rules.\n    \"\"\"\n\n    match lang:\n        case \"java\":\n            return JAVA_PUBLIC_CLASS_REGEX.sub(\"class\", code, count=1)\n", "            return JAVA_PUBLIC_CLASS_REGEX.sub(\"class\", code, count=1)\n\n        case \"rust\":\n            if not RUST_FN_REGEX.search(code):\n                return \"fn main() {\\n\" f\"{code}\\n\" \"}\"\n            return code\n\n        case \"zig\":\n            if not ZIG_STD_REGEX.search(code):\n                header = 'const std = @import(\"std\");'", "            if not ZIG_STD_REGEX.search(code):\n                header = 'const std = @import(\"std\");'\n            else:\n                header = \"\"\n\n            if not ZIG_MAIN_FN_REGEX.search(code):\n                return f\"{header}\\n\" \"pub fn main() !void { \" f\"{code}\" \"}\"\n\n            return f\"{header}\\n{code}\"\n", "            return f\"{header}\\n{code}\"\n\n        case _:\n            return code\n"]}
{"filename": "bot/utils/__init__.py", "chunked_list": [""]}
{"filename": "bot/utils/display.py", "chunked_list": ["def format_text(text: str) -> str:\n    return (\n        # GCC is stupid.\n        text.replace(\"\\x1b[K\", \"\")\n        # Discord doesn't understand this alias.\n        .replace(\"\\x1b[m\", \"\\x1b[0m\")\n        # Discord doesn't understand this either.\n        .replace(\"\\x1b[01m\", \"\\x1b[1m\")\n    )\n", ""]}
{"filename": "bot/utils/parse.py", "chunked_list": ["from __future__ import annotations\n\nimport re\nimport typing as t\n\nfrom hikari import Attachment, Message\n\nfrom bot import models\n\nCODE_BLOCK_REGEX = re.compile(r\"```(?P<lang>\\w*)[\\n\\s]*(?P<code>(.|\\n)*?)```\")", "\nCODE_BLOCK_REGEX = re.compile(r\"```(?P<lang>\\w*)[\\n\\s]*(?P<code>(.|\\n)*?)```\")\nCODE_LINE_REGEX = re.compile(r\"`(?P<code>[^`\\n]+)`\")\n\n\nasync def get_codes(message: Message) -> list[models.Code]:\n    return [\n        *_get_code_blocks(message.content),\n        *await _get_code_attachments(message.attachments),\n    ]", "        *await _get_code_attachments(message.attachments),\n    ]\n\n\ndef _get_code_blocks(content: str | None) -> list[models.Code]:\n    if not content:\n        return []\n\n    blocks: list[models.Code] = []\n\n    for block in CODE_BLOCK_REGEX.finditer(content):\n        dct = block.groupdict()\n        code = models.Code(code=dct[\"code\"])\n        if language := dct.get(\"lang\"):\n            code.language = language\n        blocks.append(code)\n\n    content = CODE_BLOCK_REGEX.sub(\"\", content)\n    for line in CODE_LINE_REGEX.finditer(content):\n        blocks.append(models.Code(code=line.groupdict()[\"code\"]))\n\n    return blocks", "\n\nasync def _get_code_attachments(files: t.Sequence[Attachment]) -> list[models.Code]:\n    codes: list[models.Code] = []\n\n    for file in files:\n        content = await file.read()\n        code = models.Code(code=content.decode(), filename=file.filename)\n        if extension := file.extension:\n            code.language = extension\n        codes.append(code)", "\n    return codes\n"]}
{"filename": "bot/providers/__init__.py", "chunked_list": [""]}
{"filename": "bot/providers/piston.py", "chunked_list": ["from __future__ import annotations\n\nimport typing as t\n\nimport aiohttp\n\nfrom bot import models\nfrom bot.config import CONFIG\nfrom bot.providers.provider import Provider\nfrom bot.utils.fixes import transform_code", "from bot.providers.provider import Provider\nfrom bot.utils.fixes import transform_code\n\nif t.TYPE_CHECKING:\n    from bot.app import Model\n    from bot.plugins.instance import Instance\n\n\nclass Piston(Provider):\n    URL = CONFIG.PISTON_URL\n\n    def __init__(self, model: Model) -> None:\n        self.aliases: dict[str, str] = {}\n        super().__init__(model)\n\n    async def startup(self) -> None:\n        self._session = aiohttp.ClientSession(\n            headers={\"content-type\": \"application/json\"}\n        )\n\n    async def update_data(self) -> None:\n        runtimes = models.RuntimeTree()\n        aliases: dict[str, str] = {}\n\n        async with self.session.get(self.URL + \"runtimes/\") as resp:\n            resp.raise_for_status()\n            for data in await resp.json():\n                if \"runtime\" in data:\n                    version = \"{}@{}\".format(data[\"runtime\"], data[\"version\"])\n                else:\n                    version = data[\"version\"]\n                runtime = models.Runtime(\n                    id=\"{}@{}\".format(data[\"language\"], data[\"version\"]),\n                    name=data[\"language\"],\n                    description=\"{} {}\".format(data[\"language\"], version),\n                    provider=self,\n                )\n\n                for alias in data[\"aliases\"]:\n                    aliases[alias] = runtime.name\n\n                runtimes.run[data[\"language\"]][\"piston\"][\"piston\"][version] = runtime\n\n        self.aliases = aliases\n        self.runtimes = runtimes\n\n    async def execute(self, instance: Instance) -> models.Result:\n        assert instance.runtime\n        assert instance.language.v\n        assert instance.code\n\n        lang, version = instance.runtime.id.split(\"@\")\n        post_data = {\n            \"language\": lang,\n            \"version\": version,\n            \"files\": [{\"content\": transform_code(lang, instance.code.code)}],\n            \"stdin\": instance.stdin,\n        }\n\n        async with self.session.post(self.URL + \"execute\", json=post_data) as resp:\n            resp.raise_for_status()\n            data = await resp.json()\n\n        return models.Result(\n            \"\\n\".join(\n                [\n                    data.get(\"compile\", {}).get(\"output\", \"\"),\n                    data.get(\"run\", {}).get(\"output\", \"\"),\n                ]\n            )\n        )", "class Piston(Provider):\n    URL = CONFIG.PISTON_URL\n\n    def __init__(self, model: Model) -> None:\n        self.aliases: dict[str, str] = {}\n        super().__init__(model)\n\n    async def startup(self) -> None:\n        self._session = aiohttp.ClientSession(\n            headers={\"content-type\": \"application/json\"}\n        )\n\n    async def update_data(self) -> None:\n        runtimes = models.RuntimeTree()\n        aliases: dict[str, str] = {}\n\n        async with self.session.get(self.URL + \"runtimes/\") as resp:\n            resp.raise_for_status()\n            for data in await resp.json():\n                if \"runtime\" in data:\n                    version = \"{}@{}\".format(data[\"runtime\"], data[\"version\"])\n                else:\n                    version = data[\"version\"]\n                runtime = models.Runtime(\n                    id=\"{}@{}\".format(data[\"language\"], data[\"version\"]),\n                    name=data[\"language\"],\n                    description=\"{} {}\".format(data[\"language\"], version),\n                    provider=self,\n                )\n\n                for alias in data[\"aliases\"]:\n                    aliases[alias] = runtime.name\n\n                runtimes.run[data[\"language\"]][\"piston\"][\"piston\"][version] = runtime\n\n        self.aliases = aliases\n        self.runtimes = runtimes\n\n    async def execute(self, instance: Instance) -> models.Result:\n        assert instance.runtime\n        assert instance.language.v\n        assert instance.code\n\n        lang, version = instance.runtime.id.split(\"@\")\n        post_data = {\n            \"language\": lang,\n            \"version\": version,\n            \"files\": [{\"content\": transform_code(lang, instance.code.code)}],\n            \"stdin\": instance.stdin,\n        }\n\n        async with self.session.post(self.URL + \"execute\", json=post_data) as resp:\n            resp.raise_for_status()\n            data = await resp.json()\n\n        return models.Result(\n            \"\\n\".join(\n                [\n                    data.get(\"compile\", {}).get(\"output\", \"\"),\n                    data.get(\"run\", {}).get(\"output\", \"\"),\n                ]\n            )\n        )", ""]}
{"filename": "bot/providers/godbolt.py", "chunked_list": ["from __future__ import annotations\n\nimport typing as t\n\nimport aiohttp\n\nfrom bot import models\nfrom bot.config import CONFIG\nfrom bot.providers.provider import Provider\nfrom bot.utils.fixes import transform_code", "from bot.providers.provider import Provider\nfrom bot.utils.fixes import transform_code\n\nif t.TYPE_CHECKING:\n    from bot.plugins.instance import Instance\n\n\ndef parse_response(data: dict[str, t.Any]) -> str:\n    berr = get_text(data, \"buildResult\", \"stderr\")\n    bout = get_text(data, \"buildResult\", \"stdout\")", "    berr = get_text(data, \"buildResult\", \"stderr\")\n    bout = get_text(data, \"buildResult\", \"stdout\")\n    err = get_text(data, \"stderr\")\n    out = get_text(data, \"stdout\")\n    asm = get_text(data, \"asm\")\n\n    if berr == err:\n        berr = None\n    if bout == out:\n        bout = None", "    if bout == out:\n        bout = None\n\n    return join_text(berr, bout, err, out, asm)\n\n\ndef join_text(*texts: str | None) -> str:\n    return \"\\n\".join(t for t in texts if t)\n\n", "\n\ndef get_text(obj: object, *path: str) -> str | None:\n    for k in path:\n        assert isinstance(obj, dict)\n        try:\n            obj = obj[k]\n        except (KeyError, TypeError):\n            return None\n    assert isinstance(obj, list)", "            return None\n    assert isinstance(obj, list)\n    return \"\\n\".join(line[\"text\"] for line in obj)\n\n\nclass GodBolt(Provider):\n    URL = CONFIG.GODBOLT_URL\n\n    async def startup(self) -> None:\n        self._session = aiohttp.ClientSession(headers={\"Accept\": \"application/json\"})", "    async def startup(self) -> None:\n        self._session = aiohttp.ClientSession(headers={\"Accept\": \"application/json\"})\n\n    async def update_data(self) -> None:\n        runtimes = models.RuntimeTree()\n\n        async with self.session.get(self.URL + \"compilers/\") as resp:\n            resp.raise_for_status()\n            for data in await resp.json():\n                runtime = models.Runtime(", "            for data in await resp.json():\n                runtime = models.Runtime(\n                    id=data[\"id\"],\n                    name=data[\"name\"],\n                    description=\"{}/{}/{}/{}\".format(\n                        data[\"lang\"],\n                        data[\"instructionSet\"] or \"none\",\n                        data[\"compilerType\"] or \"none\",\n                        data[\"semver\"] or \"none\",\n                    ),", "                        data[\"semver\"] or \"none\",\n                    ),\n                    provider=self,\n                )\n                for tree in [runtimes.asm, runtimes.run]:\n                    # godbolt supports execution and compilation\n                    # fmt: off\n                    (\n                        tree \n                        [data[\"lang\"]]", "                        tree \n                        [data[\"lang\"]]\n                        [data[\"instructionSet\"] or \"none\"]\n                        [data[\"compilerType\"] or \"none\"]\n                        [data[\"semver\"] or \"none\"]\n                    ) = runtime\n                    # fmt: on\n\n        self.runtimes = runtimes\n", "        self.runtimes = runtimes\n\n    async def _run(self, instance: Instance) -> models.Result:\n        if not (rt := instance.runtime):\n            return models.Result(\"No runtime selected.\")\n        if not (code := instance.code):\n            return models.Result(\"No code to run.\")\n        if not (lang := instance.language.v):\n            return models.Result(\"No language.\")\n", "            return models.Result(\"No language.\")\n\n        url = self.URL + f\"compiler/{rt.id}/compile\"\n        post_data = {\n            \"source\": transform_code(lang, code.code),\n            \"lang\": lang.lower(),\n            \"options\": {\n                \"compilerOptions\": {\"executorRequest\": True},\n                \"executeParameters\": {\"stdin\": instance.stdin},\n                \"filters\": {\"execute\": True},", "                \"executeParameters\": {\"stdin\": instance.stdin},\n                \"filters\": {\"execute\": True},\n            },\n        }\n\n        async with self.session.post(url, json=post_data) as resp:\n            resp.raise_for_status()\n            data = await resp.json()\n\n        return models.Result(parse_response(data))", "\n        return models.Result(parse_response(data))\n\n    async def _asm(self, instance: Instance) -> models.Result:\n        assert instance.runtime\n        assert instance.language.v\n        assert instance.code\n\n        rt = instance.runtime\n        lang = instance.language.v", "        rt = instance.runtime\n        lang = instance.language.v\n        code = instance.code\n\n        url = self.URL + f\"compiler/{rt.id}/compile\"\n        post_data = {\n            \"source\": transform_code(lang, code.code),\n            \"lang\": lang.lower(),\n            \"options\": {\n                \"compilerOptions\": {", "            \"options\": {\n                \"compilerOptions\": {\n                    \"executorRequest\": False,\n                },\n                \"filters\": {\n                    \"binary\": False,\n                    \"binaryObject\": False,\n                    \"commentOnly\": True,\n                    \"demangle\": True,\n                    \"directives\": True,", "                    \"demangle\": True,\n                    \"directives\": True,\n                    \"execute\": False,\n                    \"intel\": True,\n                    \"labels\": True,\n                    \"libraryCode\": False,\n                    \"trim\": False,\n                },\n            },\n        }", "            },\n        }\n\n        async with self.session.post(url, json=post_data) as resp:\n            resp.raise_for_status()\n            data = await resp.json()\n\n        return models.Result(parse_response(data))\n\n    async def execute(self, instance: Instance) -> models.Result:", "\n    async def execute(self, instance: Instance) -> models.Result:\n        match instance.action:\n            case models.Action.RUN:\n                return await self._run(instance)\n            case models.Action.ASM:\n                return await self._asm(instance)\n"]}
{"filename": "bot/providers/provider.py", "chunked_list": ["from __future__ import annotations\n\nimport abc\nimport typing as t\n\nimport aiohttp\n\nfrom bot import models\n\nif t.TYPE_CHECKING:\n    from bot.app import Model\n    from bot.plugins.instance import Instance", "\nif t.TYPE_CHECKING:\n    from bot.app import Model\n    from bot.plugins.instance import Instance\n\n\nclass Provider(abc.ABC):\n    def __init__(self, model: Model) -> None:\n        self.model = model\n        self.runtimes = models.RuntimeTree()\n        self._session: aiohttp.ClientSession | None = None\n\n    @property\n    def session(self) -> aiohttp.ClientSession:\n        assert self._session, \"aiohttp session not initialized\"\n        return self._session\n\n    async def shutdown(self) -> None:\n        if self._session and not self._session.closed:\n            await self._session.close()\n\n    @abc.abstractmethod\n    async def startup(self) -> None:\n        ...\n\n    @abc.abstractmethod\n    async def execute(self, instance: Instance) -> models.Result:\n        ...\n\n    @abc.abstractmethod\n    async def update_data(self) -> None:\n        ...\n\n    def __str__(self) -> str:\n        return self.__class__.__name__.lower()", ""]}
