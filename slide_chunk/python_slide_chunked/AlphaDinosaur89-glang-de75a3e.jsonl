{"filename": "Alphassembly/assembler/assembler.py", "chunked_list": ["from lib2to3.pytree import Node\nfrom math import log\nfrom tokenize import Token\nfrom consts import *\nfrom nodes import *\nimport struct\n\nclass Assembler:\n    def __init__(self, nodes):\n        self.nodes = nodes\n        self.labels = {}\n        self.binary = bytearray()\n        self.idx = 0\n        self.variables = {}\n        self.var_idx = 0\n\n    def visit(self, node):\n        if node == None:\n            return\n        method_name = f'visit_{type(node).__name__}'\n        method = getattr(self, method_name, self.no_visit_method)\n        return method(node)\n\n    def no_visit_method(self, node):\n        raise Exception(f'No visit_{type(node).__name__} method defined')\n    \n    def assemble(self):\n        self.fixlabel = True\n        \n        self.flag = True\n        for node in self.nodes:\n            self.idx += 1\n            self.visit(node)\n        \n        self.binary = bytearray()\n        \n        self.idx = 0\n\n        for node in self.nodes:\n            self.idx += 1\n            self.visit(node)\n        \n        self.binary = bytearray()\n        \n        self.idx = 0\n\n        for node in self.nodes:\n            self.idx += 1\n            self.visit(node)\n        \n        self.binary = bytearray()\n        \n        self.fixlabel = False        \n        self.flag = False\n        \n        self.idx = 0\n\n        for node in self.nodes:\n            self.idx += 1\n            self.visit(node)\n        self.binary.append(0)\n        \n        return self.binary\n    \n    def make_variable(self, varname):\n        if varname not in self.variables:\n            pass\n        else:\n            self.idx += 2\n            self.binary.append(4)\n            self.make_int32(self.variables[varname])\n            return\n        \n        self.variables[varname] = self.var_idx\n        \n        self.idx += 2\n        self.binary.append(4)\n        self.make_int32(self.var_idx)\n        \n        self.var_idx += 1\n    \n    def bytes_needed(self, n):\n        if n == 0:\n            return 1\n        elif n is None:\n            return 1\n        return int(log(n, 256)) + 1\n    \n    def make_int32(self, integer, label=None):\n        if integer is None:\n            integer = 0\n        \n        if label:\n            if label in self.labels.keys():\n                self.idx += 1\n                integer = self.labels[label]\n        \n        needed_bytes = self.bytes_needed(integer)\n        if needed_bytes == 0:\n            needed_bytes = 1\n        \n        self.idx += needed_bytes\n        if needed_bytes > 1 and self.fixlabel:\n            for label in self.labels:\n                if self.labels[label] > self.idx:\n                    self.labels[label] += needed_bytes-1\n        self.binary.append(needed_bytes)\n            \n        self.binary.extend(integer.to_bytes(needed_bytes, 'little'))\n    \n    def make_double64(self, float):\n        if float > 1.7976931348623157E+308:\n            raise Exception(\"Float too big\")\n        \n        needed_bytes = 8\n        if needed_bytes == 0:\n            needed_bytes = 1\n        \n        self.idx += needed_bytes\n            \n        self.binary.extend(struct.pack(\"d\", float))\n\n    def make_string(self, string):\n        for char in string:\n            self.binary.append(ord(char))\n\n        self.binary.append(0)\n    \n    def make_arg(self, val, jmp=False):\n        pc = False\n        if type(val) is ListNode:\n            self.make_list(val)\n        elif val.type == TT_IDENTIFIER:\n            if val.value in REGISTERS:\n                self.idx += 2\n                self.binary.append(1)\n                self.binary.append(REGISTERS[val.value])\n            else:\n                #try:\n                #    if self.bytes_needed(self.labels[val.value]) == 2:\n                #        pass\n                #    elif self.bytes_needed(self.labels[val.value]) == 3:\n                #        self.idx -= 1\n                #    elif self.bytes_needed(self.labels[val.value]) == 4:\n                #        self.idx -= 2\n                #    else:\n               #         self.idx += 1\n               # except KeyError:\n               #     pass\n               if not jmp:\n                    self.idx += 1\n                    self.binary.append(2)\n                    \n                    self.make_int32(None, label=val.value)\n               else:\n                   if self.labels.get(val.value):\n                        self.idx += 1\n                        #if self.bytes_needed(self.labels[val.value]) == 2:\n                        #    pass\n                        #elif self.bytes_needed(self.labels[val.value]) == 3:\n                        #    self.idx -= 1\n                        #elif self.bytes_needed(self.labels[val.value]) == 4:\n                        #    self.idx -= 2\n                        #else:\n                        #    self.idx += 1\n                                \n                        self.binary.append(2)\n                        if self.labels.get(val.value):\n                                self.make_int32(None, label = val.value)\n                   \n                #raise Exception(f\"Register: {val.value} not found\")\n        elif val.type == TT_INT:\n            if self.bytes_needed(val.value) == 2:\n                pass\n            elif self.bytes_needed(val.value) == 3:\n                self.idx -= 1\n            elif self.bytes_needed(val.value) == 4:\n                self.idx -= 2\n            else:\n                self.idx += 1\n                \n            self.idx += self.bytes_needed(val.value)\n            self.binary.append(2)\n            self.make_int32(val.value)\n        elif val.type == TT_FLOAT:\n            self.idx += 1\n            self.binary.append(5)\n            self.make_double64(val.value)\n        elif val.type == TT_STRING:\n            self.idx += len(val.value) + 2\n            self.binary.append(3)\n            self.make_string(val.value)\n        elif val.type == TT_VARIABLE:\n            self.make_variable(val.value)\n    \n    def make_register(self, val):\n        if val.type == TT_IDENTIFIER:\n            if val.value in REGISTERS:\n                self.idx += 2\n                self.binary.append(1)\n                self.binary.append(REGISTERS[val.value])\n            else:\n                raise Exception(f\"Register: '{val.value}' not found\")\n    \n    def make_op(self, val):\n        self.idx += 1\n        if val.type == TT_EE:\n            self.binary.append(1)\n        elif val.type == TT_NE:\n            self.binary.append(2)\n        elif val.type == TT_GT:\n            self.binary.append(3)\n        elif val.type == TT_GTE:\n            self.binary.append(4)\n        elif val.type == TT_LT:\n            self.binary.append(5)\n        elif val.type == TT_LTE:\n            self.binary.append(6)\n        else:\n            raise Exception(f\"Unrecognized operator: '{val.type}'\")\n    \n    def make_list(self, node):\n        self.idx += 2\n        self.binary.append(6)\n        \n        self.make_int32(len(node.nodes_list))\n        \n        for node in node.nodes_list:\n            val = self.visit(node)\n            self.make_arg(val)\n\n    ###################################\n\n    def visit_LoadNode(self, node):\n        string = node.string.value\n\n        self.binary.append(9)\n\n        self.make_string(string)\n\n        self.idx += len(string) + 1\n    \n    def visit_PrintNode(self, node):\n        self.binary.append(8)\n    \n    def visit_DoneNode(self, node):\n        self.binary.append(7)\n    \n    def visit_PopNode(self, node):\n        self.binary.append(6)\n        \n        if not node.reg == None:\n            self.make_register(node.reg)\n        else:\n            self.idx += 1\n            self.binary.append(0)\n    \n    def visit_DivNode(self, node):\n        self.binary.append(5)\n\n        if node.val1.type == TT_IDENTIFIER:\n            if node.val1.value in REGISTERS:\n                self.idx += 2\n                self.binary.append(1)\n                self.binary.append(REGISTERS[node.val1.value])\n        elif node.val1.type == TT_VARIABLE:\n            self.make_variable(node.val1.value)\n        else:\n            raise Exception(\"Left operand must be a register or variable\")\n\n        self.make_arg(node.val2)\n    \n    def visit_MulNode(self, node):\n        self.binary.append(4)\n\n        if node.val1.type == TT_IDENTIFIER:\n            if node.val1.value in REGISTERS:\n                self.idx += 2\n                self.binary.append(1)\n                self.binary.append(REGISTERS[node.val1.value])\n        elif node.val1.type == TT_VARIABLE:\n            self.make_variable(node.val1.value)\n        else:\n            raise Exception(\"Left operand must be a register or variable\")\n\n        self.make_arg(node.val2)\n    \n    def visit_SubNode(self, node):\n        self.binary.append(3)\n\n        if node.val1.type == TT_IDENTIFIER:\n            if node.val1.value in REGISTERS:\n                self.idx += 2\n                self.binary.append(1)\n                self.binary.append(REGISTERS[node.val1.value])\n        elif node.val1.type == TT_VARIABLE:\n            self.make_variable(node.val1.value)\n        else:\n            raise Exception(\"Left operand must be a register or variable\")\n            \n        self.make_arg(node.val2)\n    \n    def visit_AddNode(self, node):\n        self.binary.append(2)\n\n        if node.val1.type == TT_IDENTIFIER:\n            if node.val1.value in REGISTERS:\n                self.idx += 2\n                self.binary.append(1)\n                self.binary.append(REGISTERS[node.val1.value])\n        elif node.val1.type == TT_VARIABLE:\n            self.make_variable(node.val1.value)\n        else:\n            raise Exception(\"Left operand must be a register or variable\")\n            \n        self.make_arg(node.val2)\n    \n    def visit_ModuloNode(self, node):\n        self.binary.append(21)\n\n        if node.val1.type == TT_IDENTIFIER:\n            if node.val1.value in REGISTERS:\n                self.idx += 2\n                self.binary.append(1)\n                self.binary.append(REGISTERS[node.val1.value])\n        elif node.val1.type == TT_VARIABLE:\n            self.make_variable(node.val1.value)\n        else:\n            raise Exception(\"Left operand must be a register or variable\")\n            \n        self.make_arg(node.val2)\n    \n    def visit_PowNode(self, node):\n        self.binary.append(23)\n\n        if node.val1.type == TT_IDENTIFIER:\n            if node.val1.value in REGISTERS:\n                self.idx += 2\n                self.binary.append(1)\n                self.binary.append(REGISTERS[node.val1.value])\n        elif node.val1.type == TT_VARIABLE:\n            self.make_variable(node.val1.value)\n        else:\n            raise Exception(\"Left operand must be a register or variable\")\n            \n        self.make_arg(node.val2)\n    \n    def visit_PushNode(self, node):\n        if type(node.value) is not ListNode:\n            value = node.value.value or None\n            type_ = node.value.type or None\n        \n        self.binary.append(1)\n\n        # TODO: test if this works (pushing list)\n        if type(node.value) is ListNode:\n            self.make_list(node.value)\n        elif type_ == TT_INT:\n            self.binary.append(2)\n            self.make_int32(value)\n\n            self.idx += self.bytes_needed(value) + 1\n            self.idx -= self.bytes_needed(value) - 1\n        elif type_ == TT_FLOAT:\n            self.binary.append(5)\n            self.make_double64(value)\n            \n            self.idx += 1\n        elif type_ == TT_IDENTIFIER:\n            self.binary.append(1)\n            \n            if value in REGISTERS:\n                if value == \"ax\":\n                    self.binary.append(0xa)\n                if value == \"bx\":\n                    self.binary.append(0xb)\n                if value == \"cx\":\n                    self.binary.append(0xc)\n                if value == \"dx\":\n                    self.binary.append(0xd)\n                if value == \"sp\":\n                    self.binary.append(0xe)\n            else:\n                raise Exception(f\"Register not found: {value}\")\n\n            self.idx += 2\n        elif type_ == TT_VARIABLE:\n            self.make_variable(value)\n    \n    def visit_LabelNode(self, node):\n        self.idx -= 1\n        if self.flag:\n            self.labels[node.name.value] = self.idx\n    \n    def visit_JumpNode(self, node):\n        \n        #label = self.labels.get(node.label.value, None) or 0\n        \n        #if type(node.label.value) is str and label is None:\n        #    raise Exception(\"Label not found\")\n        \n        self.binary.append(10)\n        \n        self.make_arg(node.label, jmp=True)\n    \n    def visit_JeNode(self, node):\n        self.idx += 1\n        \n        label = self.labels.get(node.label.value, None) or 0\n        if type(node.label.value) is str and label is None:\n            raise Exception(\"Label not found\")\n        \n        self.binary.append(13)\n\n        self.make_int32(label)\n        \n        self.make_arg(node.argument)\n\n    def visit_JnNode(self, node):\n        self.idx += 1\n        \n        label = self.labels.get(node.label.value, None) or 0\n        if type(node.label.value) is str and label is None:\n            raise Exception(\"Label not found\")\n    \n        self.binary.append(14)\n\n        self.make_int32(label)\n        \n        self.make_arg(node.argument)\n    \n    def visit_JgNode(self, node):\n        self.idx += 1\n        \n        label = self.labels.get(node.label.value, None) or 0\n        if type(node.label.value) is str and label is None:\n            raise Exception(\"Label not found\")\n    \n        self.binary.append(15)\n\n        self.make_int32(label)\n        \n        self.make_arg(node.argument)\n    \n    def visit_JlNode(self, node):\n        label = self.labels.get(node.label.value, None) or 0\n        if type(node.label.value) is str and label is None:\n            raise Exception(\"Label not found\")\n    \n        self.binary.append(16)\n\n        self.make_int32(label)\n        \n        self.make_arg(node.argument)\n    \n    def visit_JtNode(self, node):\n        self.idx += 1\n        label = self.labels.get(node.label.value, None) or 0\n        if type(node.label.value) is str and label is None:\n            raise Exception(\"Label not found\")\n    \n        self.binary.append(19)\n\n        self.make_int32(label)\n    \n    def visit_JfNode(self, node):\n        self.idx += 1\n    \n        label = self.labels.get(node.label.value, None) or 0\n        if type(node.label.value) is str and label is None:\n            raise Exception(\"Label not found\")\n    \n        self.binary.append(20)\n\n        self.make_int32(label)\n    \n    def visit_CallNode(self, node):\n        \n        #label = self.labels.get(node.label.value, None) or 0\n        #if type(node.label.value) is str and label is None:\n        #    raise Exception(\"Label not found\")\n    \n        self.binary.append(11)\n        \n        self.make_arg(node.label, jmp=True)\n        \n        #self.make_int32(label)\n    \n    def visit_RetNode(self, node):\n        self.binary.append(12)\n    \n    def visit_MovNode(self, node):\n        # 1 register\n        # 2 int\n        # 3 str\n        # 4 variable\n        # 5 float\n        # 6 list\n        self.binary.append(17)\n\n        if node.left.type == TT_IDENTIFIER:\n            if node.left.value in REGISTERS:\n                self.idx += 2\n                self.binary.append(1)\n                if node.left.value == \"ax\":\n                    self.binary.append(0xa)\n                elif node.left.value == \"bx\":\n                    self.binary.append(0xb)\n                elif node.left.value == \"cx\":\n                    self.binary.append(0xc)\n                elif node.left.value == \"dx\":\n                    self.binary.append(0xd)\n                elif node.left.value == \"sp\":\n                    self.binary.append(0xe)\n            else:\n                raise Exception(f\"Register: {node.left.value} not found\")\n        elif node.left.type == TT_INT:\n            raise Exception(\"Cannot copy value to an integer\")\n        elif node.left.type == TT_FLOAT:\n            raise Exception(\"Cannot copy value to a float\")\n        elif node.left.type == TT_STRING:\n            raise Exception(\"Cannot copy value to a string\")\n        elif node.left.type == TT_VARIABLE:\n            self.make_variable(node.left.value)\n        else:\n            # can only happend when moving to a list\n            raise Exception(\"Cannot copy value to a list\")\n        \n        self.make_arg(node.right)\n    \n    def visit_StringNode(self, node):\n        return node.tok\n\n    def visit_IntegerNode(self, node):\n        return node.tok\n    \n    def visit_FloatNode(self, node):\n        return node.tok\n    \n    def visit_RegisterNode(self, node):\n        return node.tok\n\n    def visit_VariableNode(self, node):\n        return node.tok\n    \n    def visit_ListNode(self, node):\n        return node\n\n    def visit_CmpNode(self, node):\n        cases = node.cases\n        \n        self.idx += 1\n        \n        self.binary.append(18)\n        i = 0\n        while True:\n            case = cases[i]\n            left = self.visit(case[0])\n            middle = case[1]\n            right = self.visit(case[2])\n\n            self.make_arg(left)\n            self.make_op(middle)\n            self.make_arg(right)\n            \n            i += 1\n            if i >= len(cases):\n                break\n\n            if cases[i] == TT_AND:\n                self.idx += 1\n                self.binary.append(1)\n                i += 1\n            elif cases[i] == TT_OR:\n                self.idx += 1\n                self.binary.append(2)\n                i += 1\n\n        self.binary.append(0)\n    \n    def visit_EOFNode(self, node):\n        self.idx -= 1\n        pass\n    \n    def visit_BCallNode(self, node):\n        self.binary.append(22)\n    \n    def visit_TestNode(self, node):\n        self.binary.append(24)\n\n        if node.left.type == TT_IDENTIFIER:\n            if node.left.value in REGISTERS:\n                self.idx += 1\n                if node.left.value == \"ax\":\n                    self.binary.append(0xa)\n                elif node.left.value == \"bx\":\n                    self.binary.append(0xb)\n                elif node.left.value == \"cx\":\n                    self.binary.append(0xc)\n                elif node.left.value == \"dx\":\n                    self.binary.append(0xd)\n                elif node.left.value == \"sp\":\n                    self.binary.append(0xe)\n            else:\n                raise Exception(f\"Register: {node.left.value} not found\")\n        elif node.left.type == TT_INT:\n            raise Exception(\"Cannot copy value to an integer\")\n        elif node.left.type == TT_FLOAT:\n            raise Exception(\"Cannot copy value to a float\")\n        elif node.left.type == TT_STRING:\n            raise Exception(\"Cannot copy value to a string\")\n        elif node.left.type == TT_VARIABLE:\n            self.make_variable(node.left.value)\n        else:\n            # can only happend when moving to a list\n            raise Exception(\"Cannot copy value to a list\")\n\n        self.make_arg(node.right)\n        \n        # TODO: Finish implementation of test instruction\n    \n    def visit_PtNode(self, node):\n        self.binary.append(25)\n        \n        if node.target.type == TT_VARIABLE:\n            self.make_variable(node.target.value)\n        else:\n            raise Exception(\"Can only point to a variable\") # TODO: maybe change this in the future if needed\n\n        if node.storage.type == TT_VARIABLE:\n            self.make_variable(node.storage.value)\n        else:\n            raise Exception(\"Can only store a pointer in a variable\")\n    \n    def visit_SptNode(self, node):\n        self.binary.append(26)\n        \n        if node.target.type == TT_IDENTIFIER:\n            if node.target.type in REGISTERS:\n                self.make_register(node.target)\n            else:\n                raise Exception(f\"Register: {node.target.value} not found\")\n        elif node.target.type == TT_VARIABLE:\n            self.make_variable(node.target.value)\n        else:\n            raise Exception(\"Can only set a pointer value in a variable or a register\")\n        \n        self.make_arg(node.arg)"]}
{"filename": "Alphassembly/assembler/lexer.py", "chunked_list": ["from consts import *\n\nclass Token:\n    def __init__(self, type_, value=None):\n        self.type = type_\n        self.value = value\n\n    def matches(self, type_, value):\n        return self.type == type_ and self.value == value\n\n    def __repr__(self):\n        if self.value: return f'{self.type}:{self.value}'\n        return f'{self.type}'", "\n\nclass Lexer:\n    def __init__(self, text):\n        self.current_char = None\n        self.text = text\n        self.idx = -1\n        self.ln = 0\n        self.advance()\n\n    def advance(self):\n        self.idx += 1\n        self.current_char = self.text[self.idx] if self.idx < len(self.text) else None\n        if self.current_char == \"\\n\":\n            self.ln += 1\n\n    def make_tokens(self):\n        tokens = []\n        while self.current_char != None:\n            if self.current_char in \" \\t\":\n                self.advance()\n            elif self.current_char in \"#\":\n                sln = self.ln\n                while self.ln == sln:\n                    self.advance()\n            elif self.current_char == \"\\n\":\n                tokens.append(Token(TT_NEWLINE))\n                self.advance()\n            elif self.current_char in DIGITS:\n                tokens.append(self.make_number())\n            elif self.current_char == '\"' or self.current_char == \"'\":\n                tokens.append(self.make_string())\n            elif self.current_char in LETTERS + \"_.\":\n                toks = self.make_keyword()\n                for tok in toks:\n                    tokens.append(tok)\n            elif self.current_char in ',':\n                tokens.append(Token(TT_COMMA))\n                self.advance()\n            elif self.current_char == '!':\n                token = self.make_not_equals()\n                tokens.append(token)\n            elif self.current_char == '=':\n                tokens.append(self.make_equals())\n            elif self.current_char == '<':\n                tokens.append(self.make_less_than())\n            elif self.current_char == '>':\n                tokens.append(self.make_greater_than())\n            elif self.current_char == '&':\n                self.advance()\n                if self.current_char == '&':\n                    tokens.append(Token(TT_AND))\n                    self.advance()\n                else:\n                    raise Exception(f\"Illegal character: '{self.current_char}'\")\n            elif self.current_char == '|':\n                self.advance()\n                if self.current_char == '|':\n                    tokens.append(Token(TT_OR))\n                    self.advance()\n                else:\n                    raise Exception(f\"Illegal character: '{self.current_char}'\")\n            elif self.current_char == '[':\n                tokens.append(self.make_variable())\n            elif self.current_char == '{':\n                tokens.append(Token(TT_LCURLY))\n                self.advance()\n            elif self.current_char == '}':\n                tokens.append(Token(TT_RCURLY))\n                self.advance()\n            else:\n                raise Exception(f\"Illegal character: '{self.current_char}'\")\n\n        tokens.append(Token(TT_EOF))\n        return tokens\n\n    def make_variable(self):\n        var_name = ''\n\n        self.advance()\n        while self.current_char != ']':\n            if self.current_char == '\\n':\n                raise Exception(f\"Expected ']' line: {self.ln}\")\n            elif self.current_char == ']':\n                break\n\n            var_name += self.current_char\n            self.advance()\n            \n        self.advance()\n\n        return Token(TT_VARIABLE, var_name)\n\n    def make_keyword(self):\n        id_str = ''\n        tokens = []\n\n        while self.current_char != None and self.current_char in LETTERS_DIGITS + '._:':\n            id_str += self.current_char\n            self.advance()\n        \n        if id_str in KEYWORDS:\n            tok_type = TT_KEYWORD\n\n            tokens.append(Token(tok_type, id_str))\n        else:\n            if not id_str[len(id_str)-1] == \":\": \n                tokens.append(Token(TT_IDENTIFIER, id_str))\n                return tokens\n        \n        if not id_str in KEYWORDS:\n            strlen = len(id_str)\n            i = 1\n            for char in id_str:\n                if char == \":\":\n                    if i != strlen:\n                        raise SyntaxError(f\"Illegal character at line {self.ln}\")\n                    else:\n                        tokens.append(Token(TT_LABEL))\n                        tokens.append(Token(TT_STRING, id_str[0:-1]))\n\n                i += 1\n\n        return tokens\n\n    def make_number(self):\n        num_str = ''\n        dot_count = 0\n\n        i = 0\n        while self.current_char != None and self.current_char in DIGITS + '-.':\n            if self.current_char == '.':\n                if dot_count == 1: break\n                dot_count += 1\n            num_str += self.current_char\n            self.advance()\n            i += 1\n        \n        if dot_count == 0:\n            return Token(TT_INT, int(num_str))\n        else:\n            return Token(TT_FLOAT, float(num_str))\n    \n    def make_string(self):\n        string = ''\n        start_char = self.current_char\n        escape_character = False\n        self.advance()\n\n        escape_characters = {\n            'n': '\\n',\n            't': '\\t',\n            '\"': '\"',\n            \"'\": \"'\",\n            \"\\\\\": \"\\\\\"\n        }\n\n        while self.current_char != None and (self.current_char != start_char or escape_character):\n            if escape_character:\n                string += escape_characters.get(self.current_char, self.current_char)\n            else:\n                if self.current_char == \"\\\\\":\n                    escape_character = True\n                    self.advance()\n                    continue\n                else:\n                    string += self.current_char\n            self.advance()\n            escape_character = False\n        \n        self.advance()\n        return Token(TT_STRING, string)\n        \n    def make_not_equals(self):\n        self.advance()\n\n        if self.current_char == '=':\n            self.advance()\n            return Token(TT_NE)\n\n        self.advance()\n        raise Exception(\"Expected '='\")\n\n    def make_equals(self):\n        self.advance()\n\n        if self.current_char == '=':\n            self.advance()\n            return Token(TT_EE)\n        \n        raise Exception(\"Expected '='\")\n\n    def make_less_than(self):\n        tok_type = TT_LT\n        self.advance()\n\n        if self.current_char == '=':\n            self.advance()\n            tok_type = TT_LTE\n\n        return Token(tok_type)\n\n    def make_greater_than(self):\n        tok_type = TT_GT\n        self.advance()\n\n        if self.current_char == '=':\n            self.advance()\n            tok_type = TT_GTE\n\n        return Token(tok_type)", ""]}
{"filename": "Alphassembly/assembler/main.py", "chunked_list": ["import sys\nimport clog\nfrom lexer import *\nfrom parser_ import *\nfrom assembler import *\n\nif len(sys.argv) == 1:\n    raise Exception(\"No file to compile\")\nif len(sys.argv) == 2:\n    outfile = \"a.asb\"\nif len(sys.argv) >= 3:\n    outfile = sys.argv[2]", "if len(sys.argv) == 2:\n    outfile = \"a.asb\"\nif len(sys.argv) >= 3:\n    outfile = sys.argv[2]\n\nclog.log(f\"Compiling to {outfile}\")\n\ntry:\n    f = open(sys.argv[1], \"r\")\nexcept Exception as e:\n    print(e)\n    exit(1)", "\nscript = \"\"\nfor i in f.readlines():\n    script += i\nscript += '\\n'\n\nlexer = Lexer(script)\ntokens = lexer.make_tokens()\nf.close()\n", "f.close()\n\nparser = Parser(tokens)\nast = parser.parse()\n\nassembler = Assembler(ast)\nbinary = assembler.assemble()\n\nf = open(outfile, \"wb\")\nf.write(binary)", "f = open(outfile, \"wb\")\nf.write(binary)\nf.close()\n"]}
{"filename": "Alphassembly/assembler/consts.py", "chunked_list": ["import string\n\nTT_OP = \"OP\"\nTT_STRING = \"STRING\"\nTT_IDENTIFIER = \"IDENTIFIER\"\nTT_INT = \"INT\"\nTT_FLOAT = \"FLOAT\"\nTT_NEWLINE = \"NEWLINE\"\nTT_KEYWORD = \"KEYWORD\"\nTT_DOUBLECOLON = \"DOUBLECOLON\"", "TT_KEYWORD = \"KEYWORD\"\nTT_DOUBLECOLON = \"DOUBLECOLON\"\nTT_LABEL = \"LABEL\"\nTT_COMMA = \"COMMA\"\nTT_EE = 'EE'\nTT_NE = 'NE'\nTT_LT = 'LT'\nTT_GT = 'GT'\nTT_LTE = 'LTE'\nTT_GTE = 'GTE'", "TT_LTE = 'LTE'\nTT_GTE = 'GTE'\nTT_AND = 'AND'\nTT_OR = 'OR'\nTT_VARIABLE = \"VARIABLE\"\nTT_LCURLY = \"LCURLY\"\nTT_RCURLY = \"RCURLY\"\nTT_EOF = \"EOF\"\n\nDIGITS = '0123456789'", "\nDIGITS = '0123456789'\nLETTERS = string.ascii_letters\nLETTERS_DIGITS = LETTERS + DIGITS\n\nKEYWORDS = [\n    \"push\",\n    \"pop\",\n    \"add\",\n    \"sub\",", "    \"add\",\n    \"sub\",\n    \"mul\",\n    \"div\",\n    \"done\",\n    \"print\",\n    \"ld\",\n    \"jmp\",\n    \"call\",\n    \"ret\",", "    \"call\",\n    \"ret\",\n    \"je\",\n    \"jn\",\n    \"jg\",\n    \"jl\",\n    \"mov\",\n    \"cmp\",\n    \"jt\",\n    \"jf\",", "    \"jt\",\n    \"jf\",\n    \"mod\",\n    \"bcall\",\n    \"pow\",\n    \"test\",\n    \"pt\",\n    \"spt\"\n]\n", "]\n\nREGISTERS = {\n    \"ax\": 0xa,\n    \"bx\": 0xb,\n    \"cx\": 0xc,\n    \"dx\": 0xd,\n    \"sp\": 0xe\n}", "}"]}
{"filename": "Alphassembly/assembler/clog.py", "chunked_list": ["import colorama\n\ncolorama.init()\n\nyellow_f = colorama.Fore.LIGHTYELLOW_EX\nred_f = colorama.Fore.LIGHTRED_EX\ngreen_f = colorama.Fore.LIGHTGREEN_EX\nreset_f = colorama.Fore.RESET\n\ndef log(msg):\n    print(f\"{green_f}INFO:{reset_f} {msg}\")", "\ndef log(msg):\n    print(f\"{green_f}INFO:{reset_f} {msg}\")\n\ndef warning(msg):\n    print(f\"{yellow_f}WARNING:{reset_f} {msg}\")\n\ndef error(msg):\n    print(f\"{red_f}ERROR:{reset_f} {msg}\")\n", ""]}
{"filename": "Alphassembly/assembler/run_tests.py", "chunked_list": ["from concurrent.futures import process\nimport os\nimport clog\nimport subprocess as sp\nimport sys\n\ndef test(filename):\n    split_text = os.path.splitext(filename)\n    extless = split_text[0]\n    \n    if split_text[-1] == \".as\":\n        stdout = []\n        stderr = []\n        clog.log(f\"Compiling to tests/{extless}.asb\")\n        \n        proc = sp.run([sys.executable, \n                        f\"main.py\", f\"tests/{filename}\", f\"tests/{extless}.asb\"],\n                        capture_output=True)\n        \n        [stdout.append(a.decode(\"utf-8\") + \"\\n\") for a in proc.stdout.splitlines()]\n        [stderr.append(a.decode(\"utf-8\") + \"\\n\") for a in proc.stderr.splitlines()]\n        \n        ret = proc.returncode\n        \n        clog.log(f\"Running tests/{extless}.asb\")\n        proc = sp.run([\"C:\\\\Users\\\\gamed\\\\Documents\\\\projs\\\\alphassembly\\\\Alphassembly\\\\Alphassembly\\\\bin\\Debug\\\\net5.0\\\\Alphassembly.exe\", \n                       f\"tests\\\\{extless}.asb\"],\n                      capture_output=True)\n        \n        [stdout.append(a.decode(\"utf-8\") + \"\\n\") for a in proc.stdout.splitlines()]\n        [stderr.append(a.decode(\"utf-8\") + \"\\n\") for a in proc.stderr.splitlines()]\n        ret = proc.returncode if ret == 0 else ret\n        \n        with open(f\"tests/{extless}.txt\", \"w\") as log:\n            if not ret == 0:\n                log.write(f\"This test failed with exit code: {ret}\\n\\n\")\n            else:\n                log.write(f\"This test succeded with exit code: {ret}\\n\\n\")\n            log.write(\"stdout:\\n\")\n            log.writelines(stdout)\n            log.write(\"\\nstderr:\\n\")\n            log.writelines(stderr)\n        \n        if ret != 0:\n            clog.error(f\"Test of {filename} failed with exit code: {ret}\")\n            return ret\n        \n    return 0", "\nerrors = 0\nfor file in os.listdir(\"tests\"):\n    if test(file) != 0:\n        errors += 1\n\nmsg = \" errors\" if errors >= 2 or errors == 0 else \" error\"\nprint(f\"\\nTesting ended with {errors}\" + msg)\n\nif errors != 0:\n    print(\"See text files in the tests directory to see what caused the error(s)\")", "\nif errors != 0:\n    print(\"See text files in the tests directory to see what caused the error(s)\")\n    "]}
{"filename": "Alphassembly/assembler/parser_.py", "chunked_list": ["from consts import *\nfrom nodes import *\n\n\nclass Parser:\n    def __init__(self, tokens):\n        self.tokens = tokens\n        self.current_tok = None\n        self.tok_idx = -1\n        self.advance()\n    \n    def advance(self):\n        self.tok_idx += 1\n        self.current_tok = self.tokens[self.tok_idx]\n\n    def parse(self):\n        return self.statements()\n\n    ###############################\n\n    def statement(self):\n        if self.current_tok.matches(TT_KEYWORD, \"ld\"):\n            self.advance()\n\n            val = self.current_tok\n            self.advance()\n\n            return LoadNode(val)\n        elif self.current_tok.matches(TT_KEYWORD, \"print\"):\n            self.advance()\n\n            return PrintNode()\n        elif self.current_tok.matches(TT_KEYWORD, \"done\"):\n            self.advance()\n\n            return DoneNode()\n        elif self.current_tok.matches(TT_KEYWORD, \"pop\"):\n            self.advance()\n\n            arg = None\n            if self.current_tok.type == TT_IDENTIFIER:\n                arg = self.current_tok\n                self.advance()\n\n            return PopNode(arg)\n        elif self.current_tok.matches(TT_KEYWORD, \"div\"):\n            self.advance()\n\n            val1 = self.current_tok\n            self.advance()\n\n            if not self.current_tok.type == TT_COMMA:\n                raise Exception(f\"Expected ','\")\n            \n            self.advance()\n            val2 = self.current_tok\n\n            self.advance()\n\n            return DivNode(val1, val2)\n        elif self.current_tok.matches(TT_KEYWORD, \"mul\"):\n            self.advance()\n\n            val1 = self.current_tok\n            self.advance()\n\n            if not self.current_tok.type == TT_COMMA:\n                raise Exception(f\"Expected ','\")\n            \n            self.advance()\n            val2 = self.current_tok\n\n            self.advance()\n\n            return MulNode(val1, val2)\n        elif self.current_tok.matches(TT_KEYWORD, \"sub\"):\n            self.advance()\n\n            val1 = self.current_tok\n            self.advance()\n\n            if not self.current_tok.type == TT_COMMA:\n                raise Exception(f\"Expected ','\")\n            \n            self.advance()\n            val2 = self.current_tok\n\n            self.advance()\n            \n            return SubNode(val1, val2)\n        elif self.current_tok.matches(TT_KEYWORD, \"add\"):\n            self.advance()\n\n            val1 = self.current_tok\n            self.advance()\n\n            if not self.current_tok.type == TT_COMMA:\n                raise Exception(f\"Expected ','\")\n            \n            self.advance()\n            val2 = self.current_tok\n\n            self.advance()\n            \n            return AddNode(val1, val2)\n        elif self.current_tok.matches(TT_KEYWORD, \"mod\"):\n            self.advance()\n\n            val1 = self.current_tok\n            self.advance()\n\n            if not self.current_tok.type == TT_COMMA:\n                raise Exception(f\"Expected ','\")\n            \n            self.advance()\n            val2 = self.current_tok\n\n            self.advance()\n            \n            return ModuloNode(val1, val2)\n        elif self.current_tok.matches(TT_KEYWORD, \"push\"):\n            self.advance()\n\n            if self.current_tok.type != TT_LCURLY:\n                value = self.current_tok\n                self.advance()\n            else:\n                value = self.expr()                \n            \n            return PushNode(value)\n        elif self.current_tok.matches(TT_KEYWORD, \"jmp\"):\n            self.advance()\n\n            label = self.current_tok\n            if self.current_tok.type == TT_LABEL:\n                raise Exception(f\"Expected identifier\")\n            self.advance()\n\n            return JumpNode(label)\n        elif self.current_tok.matches(TT_KEYWORD, \"je\"):\n            self.advance()\n            \n            label = self.current_tok\n            self.advance()\n\n            if not self.current_tok.type == TT_COMMA:\n                raise Exception(f\"Expected ','\")\n            \n            self.advance()\n\n            argument = self.current_tok\n            self.advance()\n            \n            return JeNode(label, argument)\n        elif self.current_tok.matches(TT_KEYWORD, \"jn\"):\n            self.advance()\n            \n            label = self.current_tok\n            self.advance()\n\n            if not self.current_tok.type == TT_COMMA:\n                raise Exception(f\"Expected ','\")\n            \n            self.advance()\n\n            argument = self.current_tok\n            self.advance()\n            \n            return JnNode(label, argument)\n        elif self.current_tok.matches(TT_KEYWORD, \"jl\"):\n            self.advance()\n            \n            label = self.current_tok\n            self.advance()\n\n            if not self.current_tok.type == TT_COMMA:\n                raise Exception(f\"Expected ','\")\n            \n            self.advance()\n\n            argument = self.current_tok\n            self.advance()\n            \n            return JlNode(label, argument)\n        elif self.current_tok.matches(TT_KEYWORD, \"jg\"):\n            self.advance()\n            \n            label = self.current_tok\n            self.advance()\n\n            if not self.current_tok.type == TT_COMMA:\n                raise Exception(f\"Expected ','\")\n            \n            self.advance()\n\n            argument = self.current_tok\n            self.advance()\n            \n            return JgNode(label, argument)\n        elif self.current_tok.matches(TT_KEYWORD, \"jt\"):\n            self.advance()\n\n            label = self.current_tok\n            self.advance()\n            \n            return JtNode(label)\n        elif self.current_tok.matches(TT_KEYWORD, \"jf\"):\n            self.advance()\n            \n            label = self.current_tok\n            self.advance()\n            \n            return JfNode(label)\n        elif self.current_tok.matches(TT_KEYWORD, \"call\"):\n            self.advance()\n\n            label = self.current_tok\n            self.advance()\n\n            return CallNode(label)\n        elif self.current_tok.matches(TT_KEYWORD, \"bcall\"):\n            self.advance()\n\n            return BCallNode()\n        elif self.current_tok.matches(TT_KEYWORD, \"ret\"):\n            self.advance()\n\n            return RetNode()\n        elif self.current_tok.type == TT_LABEL:\n            self.advance()\n\n            name = self.current_tok\n            self.advance()\n\n            return LabelNode(name)\n        elif self.current_tok.matches(TT_KEYWORD, \"mov\"):\n            self.advance()\n\n            target = self.current_tok\n            self.advance()\n\n            if not self.current_tok.type == TT_COMMA:\n                raise Exception(f\"Expected ','\")\n            \n            self.advance()\n            if self.current_tok.type != TT_LCURLY:\n                value = self.current_tok\n                self.advance()\n            else:\n                value = self.expr()\n            \n            # when you mov from labels:\n            # mov ax, label\n            try:\n                if value.type == TT_KEYWORD:\n                    value.type = TT_IDENTIFIER\n            except AttributeError:\n                pass\n\n            return MovNode(target, value)\n        elif self.current_tok.matches(TT_KEYWORD, \"cmp\"):\n            self.advance()\n\n            cases = []\n            while True:\n                left = self.expr()\n\n                middle = self.current_tok\n                self.advance()\n\n                right = self.expr()\n                cases.append((left, middle, right))\n\n                if self.current_tok.type == TT_AND:\n                    cases.append(TT_AND)\n                    self.advance()\n                elif self.current_tok.type == TT_OR:\n                    cases.append(TT_OR)\n                    self.advance()\n                else:\n                    break\n            return CmpNode(cases)\n        elif self.current_tok.matches(TT_KEYWORD, \"pow\"):\n            self.advance()\n\n            val1 = self.current_tok\n            self.advance()\n\n            if not self.current_tok.type == TT_COMMA:\n                raise Exception(f\"Expected ','\")\n            \n            self.advance()\n            val2 = self.current_tok\n\n            self.advance()\n            \n            return PowNode(val1, val2)\n        elif self.current_tok.matches(TT_KEYWORD, \"test\"):\n            self.advance()\n            \n            target = self.current_tok\n            self.advance()\n            \n            if not self.current_tok.type == TT_COMMA:\n                raise Exception(f\"Expected ','\")\n            \n            self.advance()\n            if self.current_tok.type != TT_LCURLY:\n                value = self.current_tok\n                self.advance()\n            else:\n                value = self.expr()\n            \n            return TestNode(target, value)\n        elif self.current_tok.matches(TT_KEYWORD, \"pt\"):\n            self.advance()\n            \n            target = self.current_tok\n            self.advance()\n            \n            if not self.current_tok.type == TT_COMMA:\n                raise Exception(f\"Expected ','\")\n            \n            self.advance()\n            \n            storage = self.current_tok\n            self.advance()\n            \n            return PtNode(target, storage)\n        elif self.current_tok.matches(TT_KEYWORD, \"spt\"):\n            self.advance()\n            \n            target = self.current_tok\n            self.advance()\n            \n            if not self.current_tok.type == TT_COMMA:\n                raise Exception(f\"Expected ','\")\n            \n            self.advance()\n            \n            arg = self.current_tok\n            self.advance()\n            \n            return SptNode(target, arg)\n        elif self.current_tok.matches(TT_EOF, None):\n            return EOFNode()\n        else:\n            return self.expr()\n        \n            #raise Exception(f\"Unknown instruction: {self.current_tok.value}\")\n\n    def statements(self):\n        statements = []\n\n        while self.current_tok.type == TT_NEWLINE:\n            self.advance()\n\n        statements.append(self.statement())\n\n        more_statements = True\n\n        while True:\n            newline_count = 0\n            while self.current_tok.type == TT_NEWLINE:\n                self.advance()\n                newline_count += 1\n            if newline_count == 0:\n                more_statements = False\n\n            if not more_statements: break\n\n            statements.append(self.statement())\n        \n        return statements\n    \n    def expr(self):\n        tok = self.current_tok\n        if self.current_tok.type == TT_STRING:\n            self.advance()\n            return StringNode(tok)\n        elif self.current_tok.type == TT_INT:\n            self.advance()\n            return IntegerNode(tok)\n        elif self.current_tok.type == TT_FLOAT:\n            self.advance()\n            return FloatNode(tok)\n        elif self.current_tok.type == TT_IDENTIFIER:\n            if self.current_tok.value in REGISTERS:\n                self.advance()\n                return RegisterNode(tok)\n            else:\n                raise Exception(f\"Unexpected identifier: {self.current_tok.value}\")\n        elif self.current_tok.type == TT_VARIABLE:\n            self.advance()\n            return VariableNode(tok)\n        elif self.current_tok.type == TT_LCURLY:\n            self.advance()\n            \n            lst = []\n            if self.current_tok.type != TT_RCURLY:\n                lst.append(self.expr())\n                \n                if self.current_tok.type == TT_RCURLY:\n                    self.advance()\n                    return ListNode(lst)\n                elif self.current_tok.type == TT_COMMA:\n                    while self.current_tok.type != TT_NEWLINE:\n                        self.advance()\n                        \n                        lst.append(self.expr())\n                        \n                        if self.current_tok.type == TT_RCURLY:\n                            self.advance()\n                            return ListNode(lst)\n                    raise Exception(\"Expected '}'\")\n                else:\n                    raise Exception(\"expected '}' or ','\")\n            else:\n                self.advance()\n                return ListNode([])\n        else:\n            raise Exception(\"Syntax Error\")"]}
{"filename": "Alphassembly/assembler/nodes.py", "chunked_list": ["class EOFNode:\n    def __init__(self):\n        pass\n\nclass SptNode:\n    def __init__(self, target, arg):\n        self.target = target\n        self.arg = arg\n\nclass PtNode:\n    def __init__(self, target, storage):\n        self.target = target\n        self.storage = storage", "\nclass PtNode:\n    def __init__(self, target, storage):\n        self.target = target\n        self.storage = storage\n\nclass BCallNode:\n    def __init__(self):\n        pass\n\nclass ModuloNode:\n    def __init__(self, val1, val2):\n        self.val1 = val1\n        self.val2 = val2", "\nclass ModuloNode:\n    def __init__(self, val1, val2):\n        self.val1 = val1\n        self.val2 = val2\n\nclass LoadNode:\n    def __init__(self, string):\n        self.string = string\n", "\n\nclass PrintNode:\n    def __init__(self):\n        pass\n\n\nclass StringNode:\n    def __init__(self, val):\n        self.tok = val", "\n\nclass VariableNode:\n    def __init__(self, tok) -> None:\n        self.tok = tok\n\n\nclass IntegerNode:\n    def __init__(self, val):\n        self.tok = val", "\n\nclass FloatNode:\n    def __init__(self, val):\n        self.tok = val\n\n\nclass RegisterNode:\n    def __init__(self, val):\n        self.tok = val", "\n\nclass CmpNode:\n    def __init__(self, cases):\n        self.cases = cases\n        \n\nclass DoneNode:\n    def __init__(self):\n        pass", "\n\nclass PopNode:\n    def __init__(self, reg):\n        self.reg = reg\n\n\nclass DivNode:\n    def __init__(self, val1, val2):\n        self.val1 = val1\n        self.val2 = val2", "\n\nclass MulNode:\n    def __init__(self, val1, val2):\n        self.val1 = val1\n        self.val2 = val2\n\n\nclass SubNode:\n    def __init__(self, val1, val2):\n        self.val1 = val1\n        self.val2 = val2", "class SubNode:\n    def __init__(self, val1, val2):\n        self.val1 = val1\n        self.val2 = val2\n\n\nclass AddNode:\n    def __init__(self, val1, val2):\n        self.val1 = val1\n        self.val2 = val2", "\n\nclass PowNode:\n    def __init__(self, val1, val2):\n        self.val1 = val1\n        self.val2 = val2\n\n\nclass PushNode:\n    def __init__(self, value):\n        self.value = value", "class PushNode:\n    def __init__(self, value):\n        self.value = value\n\n\nclass LabelNode:\n    def __init__(self, name):\n        self.name = name\n\n\nclass JumpNode:\n    def __init__(self, label):\n        self.label = label", "\n\nclass JumpNode:\n    def __init__(self, label):\n        self.label = label\n\n\nclass JeNode:\n    def __init__(self, label, argument):\n        self.label = label\n        self.argument = argument", "\n\nclass JnNode:\n    def __init__(self, label, argument):\n        self.label = label\n        self.argument = argument\n\n\nclass JgNode:\n    def __init__(self, label, argument):\n        self.label = label\n        self.argument = argument", "class JgNode:\n    def __init__(self, label, argument):\n        self.label = label\n        self.argument = argument\n\n\nclass JlNode:\n    def __init__(self, label, argument):\n        self.label = label\n        self.argument = argument", "\n\nclass JtNode:\n    def __init__(self, label):\n        self.label = label\n\n\nclass JfNode:\n    def __init__(self, label):\n        self.label = label", "\n\nclass CallNode:\n    def __init__(self, label):\n        self.label = label\n\n\nclass RetNode:\n    def __init__(self):\n        pass", "\n\nclass MovNode:\n    def __init__(self, left, right):\n        self.left = left\n        self.right = right\n\n\nclass ListNode:\n    def __init__(self, nodes_list):\n        self.nodes_list = nodes_list", "class ListNode:\n    def __init__(self, nodes_list):\n        self.nodes_list = nodes_list\n\nclass TestNode:\n    def __init__(self, left, right):\n        self.left = left\n        self.right = right\n", ""]}
{"filename": "Alphassembly/assembler/glang/glc.py", "chunked_list": ["import getopt\nimport sys\nimport clog\nimport utils\nimport os\nfrom builtins_ import *\nfrom modules.consts import TT_KEYWORD, TT_STRING, TT_EOF, TT_KEYWORD, TT_NEWLINE\nfrom modules import lexer, _parser, codegen, errors, nodes, consts\n\n# glang Compiler", "\n# glang Compiler\n# glc\n\ntry:\n    opts, args = getopt.getopt(sys.argv[1:], \"o:I:shr\")\nexcept getopt.GetoptError as e:\n    clog.error(e)\n    exit(1)\n", "\nHELP = \"\"\"\\\nUsage: glc [options] file...\n  -o <file>         Place the output into <file>\n  -I <directory>    Add <directory> to include search path .\\\\std is added by default\n  -s                Doesn't print compilation information\n  -r                Compile program and run afterwards\n  -h                Displays this message\\\n\"\"\"\n", "\"\"\"\n\n# argument parsing\n\nsilent = False\nrun = False\noutput = \"a.asb\"\ninclude = ['.\\\\', '.\\\\std\\\\']\nfor opt in opts:\n    if opt[0] == '-h':\n        print(HELP)\n        exit()\n    elif opt[0] == '-o':\n        output = opt[1]\n    elif opt[0] == '-s':\n        silent = True\n    elif opt[0] == '-r':\n        run = True\n    elif opt[0] == '-I':\n        if opt[1][-1] != '\\\\':\n            opt[1] += '\\\\'\n        include.append(opt[1])", "for opt in opts:\n    if opt[0] == '-h':\n        print(HELP)\n        exit()\n    elif opt[0] == '-o':\n        output = opt[1]\n    elif opt[0] == '-s':\n        silent = True\n    elif opt[0] == '-r':\n        run = True\n    elif opt[0] == '-I':\n        if opt[1][-1] != '\\\\':\n            opt[1] += '\\\\'\n        include.append(opt[1])", "\nif len(args) < 1:\n    utils.error(\"no input files\")\n    utils.fail(1)\nelif len(args) > 1:\n    utils.error(\"more than 1 input files not supported yet\")\n    utils.fail(1)\n\ndef assemble(filename):\n    # switch this to an cx_Freeze executable in PATH\n\n    cmd(f\"..\\\\main.py {filename} {output}\", f\"alsm {filename} {output}\")", "def assemble(filename):\n    # switch this to an cx_Freeze executable in PATH\n\n    cmd(f\"..\\\\main.py {filename} {output}\", f\"alsm {filename} {output}\")\n\ndef cmd(command, message=None):\n    if not silent:\n        if message is None:\n            clog.log(f\"[CMD] {command}\")\n        else:\n            clog.log(f\"[CMD] {message}\")\n\n    os.system(command)", "\ndef preprocess(tokens):\n    i = 0\n    included_files = []\n    while i < len(tokens):\n        token = tokens[i]\n        if token.matches(TT_KEYWORD, 'include'):\n            token = tokens[i+1]\n            if token.type != TT_STRING:\n                return None, errors.InvalidSyntaxError(token.pos_start,\n                                                       token.pos_end,\n                                                       \"Expected string\")\n            del tokens[i]\n            inc = token\n            del tokens[i]\n                       \n            if not inc.value in included_files:\n                for path in include:\n                    try:\n                        f = open(path + inc.value, \"r\")\n                        f.close()\n                        f = path + inc.value\n                        included_files.append(inc.value)\n                        break\n                    except FileNotFoundError:\n                        f = None\n                \n                if f is None:\n                    return None, errors.IncludeError(inc.pos_start,\n                                            inc.pos_end,\n                                            f\"File not found {inc.value} in the include path\")\n                \n                with open(f, \"r\") as file:\n                    text = \"\"\n                    for char in file.readlines():\n                        text += char\n                \n                text += '\\n'\n                lex = lexer.Lexer(inc.value, text)\n                toks = lex.make_tokens()\n                temp = tokens\n                tokens = toks[0]\n                tokens.extend(temp)\n                i = -1\n        \n        i += 1\n    \n    temp_tokens = []\n\n    i = 0\n    while i <= len(tokens)-1:\n        token = tokens[i]\n        if token.type == TT_EOF and i != len(tokens)-1:\n            pass\n        elif token.matches(TT_KEYWORD, 'end'):\n            temp_tokens.append(lexer.Token(TT_KEYWORD, 'end', pos_start=token.pos_start,\n                                           pos_end=token.pos_end))\n            temp_tokens.append(lexer.Token(TT_NEWLINE, pos_start=token.pos_start,\n                                           pos_end=token.pos_end))\n        else:\n            temp_tokens.append(token)\n        i += 1\n    \n    tokens = temp_tokens\n    return tokens, None", "\ndef compile():\n    with open(args[0], \"r\") as f:\n        text = \"\"\n        for char in f.readlines():\n            text += char\n\n    try:\n        text += '\\n'\n        lex = lexer.Lexer(args[0], text)\n        tokens, error = lex.make_tokens()\n        if error:\n            utils.errorp(error)\n            utils.fail(1)\n    except Exception as e:\n        utils.errorp(e)\n        utils.fail(1)\n    \n    try:\n        tokens, error = preprocess(tokens)\n        if error:\n            utils.errorp(error)\n            utils.fail(1)\n    except Exception as e:\n        utils.errorp(e)\n        utils.fail(1)\n    \n    out = os.path.splitext(output)[0]\n    \n    if not silent:\n        clog.log(f\"Generating {out}.as\")\n    \n    try:\n        parser = _parser.Parser(tokens)\n        result = parser.parse()\n        \n        try:\n            if result.error:\n                utils.errorp(result.error)\n                utils.fail(1)\n        except AttributeError:\n            pass\n        \n        ast, call_nodes, var_accesses = result\n    except Exception as e:\n        utils.errorp(e)\n        utils.fail(1)\n    \n    if ast.error:\n        utils.errorp(ast.error)\n        utils.fail(1)\n    \n    init = \"\"\n    init += \"mov [true], 1\\n\"\n    init += \"mov [false], 0\\n\\n\"\n    \n    for text in BUILTINS:\n        init += text\n\n    # dead code elimination\n    for node in ast.node:\n        if isinstance(node, nodes.FuncDefNode):\n            if not node.func_name_tok.value in call_nodes \\\n                and not node.func_name_tok.value in var_accesses:\n                ast.node.remove(node)\n    \n    #try:\n    cdgen = codegen.Codegen()\n    result = cdgen.emit(ast.node)\n    result, error = result.value, result.error\n    #except Exception as e:\n    #    utils.errorp(e)\n    #    utils.fail(1)\n    \n    if error:\n        utils.errorp(error)\n        utils.fail(1)\n    \n    result = init + cdgen.hoisted_definitions + result\n    \n    with open(out + \".as\", \"w\") as o:\n        o.write(result)\n        \n    try:\n        assemble(out + \".as\")\n    except Exception as e:\n        utils.errorp(e)\n        utils.fail(1)\n    \n    if run:\n        cmd(f'..\\\\..\\\\bin\\\\Debug\\\\net5.0\\\\Alphassembly.exe {output}')", "\ncompile()\n"]}
{"filename": "Alphassembly/assembler/glang/clog.py", "chunked_list": ["import colorama\n\ncolorama.init()\n\nyellow_f = colorama.Fore.LIGHTYELLOW_EX\nred_f = colorama.Fore.LIGHTRED_EX\ngreen_f = colorama.Fore.LIGHTGREEN_EX\nreset_f = colorama.Fore.RESET\n\ndef log(msg):\n    print(f\"{green_f}INFO:{reset_f} {msg}\")", "\ndef log(msg):\n    print(f\"{green_f}INFO:{reset_f} {msg}\")\n\ndef warning(msg):\n    print(f\"{yellow_f}WARNING:{reset_f} {msg}\")\n\ndef error(msg):\n    print(f\"{red_f}ERROR:{reset_f} {msg}\")\n", ""]}
{"filename": "Alphassembly/assembler/glang/utils.py", "chunked_list": ["import clog\n\nerrors = 0\n\ndef error(msg):\n    global errors\n    errors += 1\n    clog.error(msg)\n\ndef errorp(msg):\n    \"\"\"only prints the error without clog.error\"\"\"\n    global errors\n    errors += 1\n    print(msg)", "\ndef errorp(msg):\n    \"\"\"only prints the error without clog.error\"\"\"\n    global errors\n    errors += 1\n    print(msg)\n\ndef fail(code=0):\n    print(\"Compilation terminated due to previous error(s).\")\n    exit(code)", ""]}
{"filename": "Alphassembly/assembler/glang/builtins_.py", "chunked_list": ["# builtins tuple\n# list of things the compiler uses\n# see builtins/ for readable code version\n\nBUILTINS = (\n    \"\"\"\"\"\"\n)"]}
{"filename": "Alphassembly/assembler/glang/modules/lexer.py", "chunked_list": ["from tokenize import Double\nfrom .position import *\nfrom .errors import *\nfrom .consts import *\n\nclass Token:\n    def __init__(self, type_, value=None, pos_start=None, pos_end=None):\n        self.type = type_\n        self.value = value\n\n        if pos_start:\n            self.pos_start = pos_start.copy()\n            self.pos_end = pos_start.copy()\n            self.pos_end.advance()\n\n        if pos_end:\n            self.pos_end = pos_end.copy()\n\n    def matches(self, type_, value):\n        return self.type == type_ and self.value == value\n\n    def __repr__(self):\n        if self.value: return f'{self.type}:{self.value}'\n        return f'{self.type}'", "\nclass Lexer:\n    def __init__(self, fn, text):\n        self.fn = fn\n        self.text = text\n        self.pos = Position(-1, 0, -1, fn, text)\n        self.current_char = None\n        self.advance()\n\n    def advance(self):\n        self.pos.advance(self.current_char)\n        self.current_char = self.text[self.pos.idx] if self.pos.idx < len(self.text) else None\n\n    def make_tokens(self):\n        tokens = []\n        \n        while self.current_char is not None:\n            if self.current_char in ' \\t':\n                self.advance()\n            elif self.current_char == '#':\n                self.advance()\n                while self.current_char != '\\n':\n                    self.advance()\n                self.advance()\n            elif self.current_char in ';\\n':\n                tokens.append(Token(TT_NEWLINE, pos_start=self.pos))\n                self.advance()\n            elif self.current_char in DIGITS:\n                tokens.append(self.make_number())\n            elif self.current_char in LETTERS:\n                toks = self.make_identifier()\n                for tok in toks:\n                    tokens.append(tok)\n            elif self.current_char in '\\'\"':\n                tokens.append(self.make_string())\n            elif self.current_char == ',':\n                tokens.append(Token(TT_COMMA, pos_start=self.pos))\n                self.advance()\n            elif self.current_char == ',':\n                tokens.append(Token(TT_COMMA, pos_start=self.pos))\n                self.advance()\n            elif self.current_char == '+':\n                tokens.append(Token(TT_PLUS, pos_start=self.pos))\n                self.advance()\n            elif self.current_char == '-':\n                tokens.append(Token(TT_MINUS, pos_start=self.pos))\n                self.advance()\n            elif self.current_char == '*':\n                if len(self.text) > 1 and self.text[self.pos.idx + 1] == \"*\":\n                    pos_start = self.pos.copy()\n                    self.advance()\n                    tokens.append(Token(TT_POW, pos_start=pos_start, pos_end=self.pos))\n                else:\n                    tokens.append(Token(TT_MUL, pos_start=self.pos))\n                self.advance()\n            elif self.current_char == '/':\n                tokens.append(Token(TT_DIV, pos_start=self.pos))\n                self.advance()\n            elif self.current_char == '%':\n                tokens.append(Token(TT_MOD, pos_start=self.pos))\n                self.advance()\n            elif self.current_char == '!':\n                token, error = self.make_not_equals()\n                if error: return [], error\n                tokens.append(token)\n            elif self.current_char == '=':\n                tokens.append(self.make_equals())\n            elif self.current_char == '<':\n                tokens.append(self.make_less_than())\n            elif self.current_char == '>':\n                tokens.append(self.make_greater_than())\n            elif self.current_char == '(':\n                tokens.append(Token(TT_LPAREN, pos_start=self.pos))\n                self.advance()\n            elif self.current_char == ')':\n                tokens.append(Token(TT_RPAREN, pos_start=self.pos))\n                self.advance()\n            elif self.current_char == '[':\n                tokens.append(Token(TT_LSQUARE, pos_start=self.pos))\n                self.advance()\n            elif self.current_char == ']':\n                tokens.append(Token(TT_RSQUARE, pos_start=self.pos))\n                self.advance()\n            elif self.current_char == ':':\n                tokens.append(Token(TT_DCOLON, pos_start=self.pos))\n                self.advance()\n            elif self.current_char == '.':\n                tokens.append(Token(TT_DOT, pos_start=self.pos))\n                self.advance()\n            else:\n                pos_start = self.pos.copy()\n                char = self.current_char\n                self.advance()\n                return [], IllegalCharError(pos_start, self.pos, \"'\" + char + \"'\")\n        \n        tokens.append(Token(TT_EOF, pos_start=self.pos))\n        return tokens, None\n    \n    def make_not_equals(self):\n        pos_start = self.pos.copy()\n        self.advance()\n\n        if self.current_char == '=':\n            self.advance()\n            return Token(TT_NE, pos_start=pos_start, pos_end=self.pos), None\n\n        self.advance()\n        return None, ExpectedCharError(pos_start, self.pos, \"'=' (after '!')\")\n\n    def make_equals(self):\n        tok_type = TT_EQ\n        pos_start = self.pos.copy()\n        self.advance()\n\n        if self.current_char == '=':\n            self.advance()\n            tok_type = TT_EE\n\n        return Token(tok_type, pos_start=pos_start, pos_end=self.pos)\n\n    def make_less_than(self):\n        tok_type = TT_LT\n        pos_start = self.pos.copy()\n        self.advance()\n\n        if self.current_char == '=':\n            self.advance()\n            tok_type = TT_LTE\n\n        return Token(tok_type, pos_start=pos_start, pos_end=self.pos)\n\n    def make_greater_than(self):\n        tok_type = TT_GT\n        pos_start = self.pos.copy()\n        self.advance()\n\n        if self.current_char == '=':\n            self.advance()\n            tok_type = TT_GTE\n\n        return Token(tok_type, pos_start=pos_start, pos_end=self.pos)\n\n    def make_number(self):\n        num_str = ''\n        dot_count = 0\n        pos_start = self.pos.copy()\n\n        while self.current_char is not None and self.current_char in DIGITS + '.':\n            if self.current_char == '.':\n                if dot_count == 1: break\n                dot_count += 1\n            num_str += self.current_char\n            self.advance()\n\n        if dot_count == 0:\n            return Token(TT_INT, int(num_str), pos_start, self.pos)\n        else:\n            return Token(TT_FLOAT, str(num_str), pos_start, self.pos)\n\n    def make_string(self):\n        string = ''\n        pos_start = self.pos.copy()\n        start_char = self.current_char\n        escape_character = False\n        self.advance()\n\n        escape_characters = {\n            'n': '\\\\n',\n            't': '\\\\t',\n            '\"': '\\\\\"',\n            \"'\": \"\\\\'\",\n            \"\\\\\": \"\\\\\\\\\",\n            \"b\": \"\\b\",\n            \"f\": \"\\f\",\n            \"r\": \"\\r\",\n            \"v\": \"\\v\"\n        }\n\n        while self.current_char != None and (self.current_char != start_char or escape_character):\n            if escape_character:\n                string += escape_characters.get(self.current_char, self.current_char)\n            else:\n                if self.current_char == '\\\\':\n                    escape_character = True\n                    self.advance()\n                    continue\n                else:\n                    string += self.current_char\n            self.advance()\n            escape_character = False\n\n        self.advance()\n        return Token(TT_STRING, string, pos_start, self.pos)\n\n    def make_identifier(self):\n        id_str = ''\n        pos_start = self.pos.copy()\n        tokens = []\n        postokens = []\n\n        while self.current_char != None and self.current_char in LETTERS_DIGITS + '_[]':\n            if self.current_char == '[':\n                postokens.append(Token(TT_LSQUARE, pos_start=pos_start))\n                self.advance()\n                continue\n            elif self.current_char == ']':\n                postokens.append(Token(TT_RSQUARE, pos_start=pos_start))\n                self.advance()\n                continue\n            id_str += self.current_char\n            self.advance()\n\n        tok_type = TT_KEYWORD if id_str in KEYWORDS else TT_IDENTIFIER\n        tokens.append(Token(tok_type, id_str, pos_start, self.pos))\n\n        [tokens.append(tok) for tok in postokens]\n\n        return tokens", ""]}
{"filename": "Alphassembly/assembler/glang/modules/codegen.py", "chunked_list": ["from asyncio import ReadTransport\nfrom doctest import OutputChecker\nfrom .errors import *\nfrom .ctresult import *\nfrom .consts import *\nfrom .nodes import *\nfrom .builtins import *\nfrom .lexer import Token\n\nclass Codegen:\n    def __init__(self):\n        self.label_idx = 0\n        self.var_idx = 0\n        self.loopsc = []\n        self.loopsb = []\n        self.loop_breakc = False\n        self.class_bcall = '18'\n        self.class_definitions = {}\n        self.hoisted_definitions = ''\n    \n    def emit(self, node):\n        method_name = f'emit_{type(node).__name__}'\n        method = getattr(self, method_name, self.no_emit_method)\n        return method(node)\n    \n    def no_emit_method(self, node):\n        raise Exception(f\"No emit_{type(node).__name__} method defined\")\n    \n    def emit_list(self, node):\n        res = CTResult()\n        output = \"\"\n        \n        for element_node in node:\n            output += res.register(self.emit(element_node))\n            if res.should_return(): return res\n        \n        return res.success(output)\n    \n    def emit_StringNode(self, node):\n        res = CTResult()\n        \n        output = \"mov ax, \"\n        output += '\"' + node.tok.value + '\"\\n'\n        return res.success(output)\n    \n    def emit_IntegerNode(self, node):\n        res = CTResult()\n        \n        output = \"mov ax, \"\n        output += str(node.tok.value) + '\\n'\n        return res.success(output)\n    \n    def emit_FloatNode(self, node):\n        res = CTResult()\n        \n        output = \"mov ax, \"\n        output += str(node.tok.value) + '\\n'\n        return res.success(output)\n    \n    def emit_ListNode(self, node):\n        res = CTResult()\n        # TODO: implement this\n        output = \"\"\n        \n        \n        length = len(node.element_nodes)\n        \n        variables = []\n        # make list of arguments\n        for _ in range(length):\n            variables.append(self.var_idx)\n            self.var_idx += 1\n        \n        i = 0\n        for var in variables:\n            output += res.register(self.emit(node.element_nodes[i]))\n            if res.error: return res\n                \n            output += f\"mov [.V{var}], ax\\n\"\n            i += 1\n            \n        output += 'mov ax, {'\n        i = 0\n        for var in variables:\n            output += f\"[.V{var}]\"\n            \n            if not i == len(variables)-1:\n                output += ', '\n            \n            i += 1\n        output += '}\\n'\n        \n        #print(output)\n        #exit()\n        \n        return res.success(output)\n    \n    def emit_VarAssignNode(self, node):\n        res = CTResult()\n        output = \"\"\n        \n        if type(node.var_name_tok) is BinOpNode:\n            if type(node.var_name_tok.left_node) is not VarAccessNode:\n                node.var_name_tok.left_node = VarAccessNode(node.var_name_tok.left_node.tok)\n                        \n            output += res.register(self.emit(node.value_node))\n            if res.error: return res\n            output += f\"push ax\\n\"\n            \n            self.class_bcall = '17'\n            output += res.register(self.emit(node.var_name_tok))\n            if res.error: return res\n            self.class_bcall = '18'\n            \n            return res.success(output)\n        \n        output += res.register(self.emit(node.value_node))\n        if res.error: return res\n        output += f\"mov [{node.var_name_tok.value}], ax\\n\"\n        return res.success(output)\n    \n    def emit_VarAccessNode(self, node):\n        res = CTResult()\n        \n        return res.success(f\"mov ax, [{node.var_name_tok.value}]\\n\")\n    \n    def op_op(self, node):\n        output = \"\"\n        op = \"\"\n        # TODO:\n        # make this to put it in a variable instead\n        # as it wont work when calling functions for example\n        # can probably be done for just functions\n        \n        if node.op_tok.type == TT_EE:\n            op = \"== \"\n        elif node.op_tok.type == TT_NE:\n            op = \"!= \"\n        elif node.op_tok.type == TT_LT:\n            op = \"< \"\n        elif node.op_tok.type == TT_GT:\n            op = \"> \"\n        elif node.op_tok.type == TT_LTE:\n            op = \"<= \"\n        elif node.op_tok.type == TT_GTE:\n            op = \">= \"\n        \n        if op != \"\":\n            if type(node.left_node) is not VarAccessNode and type(node.left_node) is not StringNode:\n                output += f\"{node.left_node.tok.value} \"\n            elif type(node.left_node) is StringNode:\n                output += f\"\\\"{node.left_node.tok.value}\\\" \"\n            elif type(node.left_node) is VarAccessNode:\n                output += f\"[{node.left_node.var_name_tok.value}] \"\n                \n            output += op\n                \n            if type(node.right_node) is not VarAccessNode and type(node.right_node) is not StringNode:\n                output += f\"{node.right_node.tok.value} \"\n            elif type(node.right_node) is StringNode:\n                output += f\"\\\"{node.right_node.tok.value}\\\" \"\n            elif type(node.right_node) is VarAccessNode:\n                output += f\"[{node.right_node.var_name_tok.value}] \"\n                \n        return output\n    \n    def andor_op(self, node, a=False):\n        res = CTResult()\n        \n        if not a:\n            output = \"cmp \"\n        else:\n            output = \"\"\n        \n        lnode = node.left_node\n        rnode = node.right_node\n        \n        if lnode.op_tok.matches(TT_KEYWORD, 'and'):\n            output += res.register(self.andor_op(lnode, True)) + \"&& \"\n            if res.error: return res\n        elif lnode.op_tok.matches(TT_KEYWORD, 'or'):\n            output += res.register(self.andor_op(lnode, True)) + \"|| \"\n            if res.error: return res\n        \n        output += self.op_op(lnode)\n        \n        if node.op_tok.matches(TT_KEYWORD, 'and') and not lnode.op_tok.matches(TT_KEYWORD, 'and'):\n            if output[-3:-1] in ('&&', '||'):\n                output = output[:-3]\n            output += \"&& \"\n        if node.op_tok.matches(TT_KEYWORD, 'or') and not lnode.op_tok.matches(TT_KEYWORD, 'or'):\n            if output[-3:-1] in ('&&', '||'):\n                output = output[:-3]\n            output += \"|| \"\n        \n        output += self.op_op(rnode)\n        \n        return res.success(output)\n    \n    def class_def(self, node):\n        res = CTResult()\n        output = \"\"\n        \n        last_node = node.right_node\n        while type(last_node) is BinOpNode:\n            last_node = last_node.right_node\n        \n        nd, _ = node.remove_last_node()\n        \n        self.class_bcall = '18'\n        \n        output += res.register(self.emit(nd))\n        if res.error: return res\n        self.class_bcall = '17'\n        \n        output += 'push ax\\n'\n        \n        output += f'mov ax, \"{last_node.var_name_tok.value}\"\\n'\n        output += 'push ax\\n'\n        \n        #output += 'mov ax, 17\\n'\n        #output += 'bcall\\n'\n        \n        return res.success(output)\n    \n    def class_access(self, node):\n        res = CTResult()\n        output = \"\"\n        \n        i = 0\n        right = node.right_node\n        while type(right) is BinOpNode:\n            right = right.right_node\n            i += 1\n        \n        output += res.register(self.emit(node.left_node))\n        if res.error: return res\n        output += 'push ax\\n'\n        \n        right = node.right_node\n        \n        if type(right) is BinOpNode:\n            left = node.right_node.left_node\n        while type(right) is BinOpNode:\n            if type(right) is BinOpNode:\n                left = right.left_node\n                right = right.right_node\n            \n            output += f'mov ax, \"{left.var_name_tok.value}\"\\n'\n            output += f'push ax\\n'\n            \n            output += f'mov ax, {self.class_bcall}\\n'\n            output += 'bcall\\n'\n            output += f'push ax\\n'\n        \n        if type(node.right_node) is CallNode:            \n            output += f'mov ax, \"{node.right_node.node_to_call.var_name_tok.value}\"\\n'\n            output += 'push ax\\n'\n        elif type(node.right_node) is not BinOpNode:\n            output += f'mov ax, \"{node.right_node.var_name_tok.value}\"\\n'\n            output += f'push ax\\n'\n        else:\n            output += f'mov ax, \"{right.var_name_tok.value}\"\\n'\n            output += f'push ax\\n'\n        \n        return res.success(output)\n    \n    def emit_BinOpNode(self, node):\n        res = CTResult()\n        output = \"\"\n        \n        if not node.op_tok.value in ('and', 'or', 'DOT') and not node.op_tok.type in (TT_DOT):\n            if res.should_return(): return res\n            output += res.register(self.emit(node.right_node))\n            if node.op_tok.type in (TT_PLUS, TT_MINUS, TT_MUL, TT_DIV, TT_MOD):\n                output += \"push ax\\n\"\n            else:\n                output += \"mov bx, ax\\n\"\n                output += \"push ax\\n\"\n            \n            output += res.register(self.emit(node.left_node))\n            if res.should_return(): return res\n        else:\n            if node.op_tok.matches(TT_KEYWORD, 'and') or node.op_tok.matches(TT_KEYWORD, 'or'):\n                output += res.register(self.emit(node.left_node))\n                if res.error: return res\n                \n                left_var = self.var_idx\n                self.var_idx += 1\n                \n                output += \"test ax, ax\\n\"\n                output += f\"mov [.V{left_var}], ax\\n\"\n                \n                output += res.register(self.emit(node.right_node))\n                if res.error: return res\n                \n                right_var = self.var_idx\n                self.var_idx += 1\n                \n                output += \"test ax, ax\\n\"\n                output += f\"mov [.V{right_var}], ax\\n\"\n                \n                # allows for something like this:\n                # 1 and 1 | 1 or 2 | foo() and bar()\n                if type(node.right_node) is not BinOpNode:\n                    varname = Token(TT_IDENTIFIER, f'.V{right_var}',\n                                    node.right_node.pos_start,\n                                    node.right_node.pos_start)\n                    node.right_node = BinOpNode(VarAccessNode(varname), Token(TT_NE, None,\n                                                                       node.right_node.pos_start, \n                                                                       node.right_node.pos_end),\n                                                                       IntegerNode(Token(TT_INT, 0,\n                                                                                         node.right_node.pos_start,\n                                                                                         node.right_node.pos_end)))\n                if type(node.left_node) is not BinOpNode:\n                    varname = Token(TT_IDENTIFIER, f'.V{left_var}',\n                                    node.left_node.pos_start,\n                                    node.left_node.pos_start)\n                    node.left_node = BinOpNode(VarAccessNode(varname), Token(TT_NE, None,\n                                                                       node.left_node.pos_start, \n                                                                       node.left_node.pos_end),\n                                                                       IntegerNode(Token(TT_INT, 0,\n                                                                                         node.left_node.pos_start,\n                                                                                         node.left_node.pos_end)))\n                output += res.register(self.andor_op(node)) + '\\n'\n                if res.error: return res\n                \n                l0 = self.label_idx\n                self.label_idx += 1\n                l1 = self.label_idx\n                self.label_idx += 1\n                l2 = self.label_idx\n                self.label_idx += 1\n                \n                output += f\"jt .L{l0}\\n\"\n                output += f\"jmp .L{l1}\\n\"\n                output += f\".L{l0}:\\n\"\n                output += f\"    mov ax, 1\\n\"\n                output += f\"    jmp .L{l2}\\n\"\n                output += f\".L{l1}:\\n\"\n                output += f\"    mov ax, 0\\n\"\n                output += f\".L{l2}:\\n\"\n                return res.success(output)\n        \n        if node.op_tok.type == TT_DOT:\n            if self.class_bcall == '18':\n                output += res.register(self.class_access(node))\n            else:\n                output += res.register(self.class_def(node))\n            if res.error: return res\n                \n\n            output += f'mov ax, {self.class_bcall}\\n'\n            output += 'bcall\\n'\n            \n            if type(node.right_node) is CallNode:\n                tempvar = self.var_idx\n                output += f'mov [.V{tempvar}], ax\\n'\n                self.var_idx += 1\n                for arg in node.right_node.arg_nodes[::-1]:\n                    output += res.register(self.emit(arg))\n                    if res.error: return res\n                    output += 'push ax\\n'\n                \n                output += res.register(self.emit(node.left_node))\n                if res.error: return res\n                \n                output += 'push ax\\n'\n                output += f'call [.V{tempvar}]\\n'\n        elif node.op_tok.type == TT_PLUS:\n            output += \"add ax, sp\\n\"\n            output += \"pop\\n\"\n        elif node.op_tok.type == TT_MINUS:\n            output += \"sub ax, sp\\n\"\n            output += \"pop\\n\"\n        elif node.op_tok.type == TT_MUL:\n            output += \"mul ax, sp\\n\"\n            output += \"pop\\n\"\n        elif node.op_tok.type == TT_DIV:\n            output += \"div ax, sp\\n\"\n            output += \"pop\\n\"\n        elif node.op_tok.type == TT_POW:\n            output += \"pow ax, sp\\n\"\n            output += \"pop\\n\"\n        elif node.op_tok.type == TT_MOD:\n            output += \"mod ax, sp\\n\"\n            output += \"pop\\n\"\n        elif node.op_tok.type == TT_EE:\n            l0 = self.label_idx\n            self.label_idx += 1\n            l1 = self.label_idx\n            self.label_idx += 1\n            l2 = self.label_idx\n            self.label_idx += 1\n            \n            output += \"pop\\n\"\n            output += \"cmp ax == bx\\n\"\n            output += f\"jt .L{l0}\\n\"\n            output += f\"jmp .L{l1}\\n\"            \n            output += f\".L{l0}:\\n\"\n            output += f\"    mov ax, 1\\n\"\n            output += f\"    jmp .L{l2}\\n\"\n            output += f\".L{l1}:\\n\"\n            output += f\"    mov ax, 0\\n\"\n            output += f\".L{l2}:\\n\"\n        elif node.op_tok.type == TT_NE:\n            l0 = self.label_idx\n            self.label_idx += 1\n            l1 = self.label_idx\n            self.label_idx += 1\n            l2 = self.label_idx\n            self.label_idx += 1\n            \n            output += \"pop\\n\"\n            output += \"cmp ax != bx\\n\"\n            output += f\"jt .L{l0}\\n\"\n            output += f\"jmp .L{l1}\\n\"            \n            output += f\".L{l0}:\\n\"\n            output += f\"    mov ax, 1\\n\"\n            output += f\"    jmp .L{l2}\\n\"\n            output += f\".L{l1}:\\n\"\n            output += f\"    mov ax, 0\\n\"\n            output += f\".L{l2}:\\n\"\n        elif node.op_tok.type == TT_LT:\n            l0 = self.label_idx\n            self.label_idx += 1\n            l1 = self.label_idx\n            self.label_idx += 1\n            l2 = self.label_idx\n            self.label_idx += 1\n            \n            output += \"pop\\n\"\n            output += \"cmp ax < bx\\n\"\n            output += f\"jt .L{l0}\\n\"\n            output += f\"jmp .L{l1}\\n\"            \n            output += f\".L{l0}:\\n\"\n            output += f\"    mov ax, 1\\n\"\n            output += f\"    jmp .L{l2}\\n\"\n            output += f\".L{l1}:\\n\"\n            output += f\"    mov ax, 0\\n\"\n            output += f\".L{l2}:\\n\"\n        elif node.op_tok.type == TT_GT:\n            l0 = self.label_idx\n            self.label_idx += 1\n            l1 = self.label_idx\n            self.label_idx += 1\n            l2 = self.label_idx\n            self.label_idx += 1\n            \n            output += \"pop\\n\"\n            output += \"cmp ax > bx\\n\"\n            output += f\"jt .L{l0}\\n\"\n            output += f\"jmp .L{l1}\\n\"            \n            output += f\".L{l0}:\\n\"\n            output += f\"    mov ax, 1\\n\"\n            output += f\"    jmp .L{l2}\\n\"\n            output += f\".L{l1}:\\n\"\n            output += f\"    mov ax, 0\\n\"\n            output += f\".L{l2}:\\n\"\n        elif node.op_tok.type == TT_LTE:\n            l0 = self.label_idx\n            self.label_idx += 1\n            l1 = self.label_idx\n            self.label_idx += 1\n            l2 = self.label_idx\n            self.label_idx += 1\n            \n            output += \"pop\\n\"\n            output += \"cmp ax <= bx\\n\"\n            output += f\"jt .L{l0}\\n\"\n            output += f\"jmp .L{l1}\\n\"            \n            output += f\".L{l0}:\\n\"\n            output += f\"    mov ax, 1\\n\"\n            output += f\"    jmp .L{l2}\\n\"\n            output += f\".L{l1}:\\n\"\n            output += f\"    mov ax, 0\\n\"\n            output += f\".L{l2}:\\n\"\n        elif node.op_tok.type == TT_GTE:\n            l0 = self.label_idx\n            self.label_idx += 1\n            l1 = self.label_idx\n            self.label_idx += 1\n            l2 = self.label_idx\n            self.label_idx += 1\n            \n            output += \"pop\\n\"\n            output += \"cmp ax >= bx\\n\"\n            output += f\"jt .L{l0}\\n\"\n            output += f\"jmp .L{l1}\\n\"            \n            output += f\".L{l0}:\\n\"\n            output += f\"    mov ax, 1\\n\"\n            output += f\"    jmp .L{l2}\\n\"\n            output += f\".L{l1}:\\n\"\n            output += f\"    mov ax, 0\\n\"\n            output += f\".L{l2}:\\n\"\n\n        return res.success(output)\n\n    def emit_UnaryOpNode(self, node):\n        res = CTResult()\n        output = \"\"\n        \n        output += res.register(self.emit(node.node))\n        if res.error: return res\n        \n        if node.op_tok.type == TT_MINUS:\n            output += \"mov bx, 0\\n\"\n            output += \"sub bx, 1\\n\"\n            output += \"mul ax, bx\\n\"\n        elif node.op_tok.type == TT_MUL:\n            var = self.var_idx\n            self.var_idx += 1\n            \n            output += res.register(self.emit(node.node))\n            if res.error: return res\n            output += f'mov [.V{var}], ax\\n'\n            \n            output += f\"pt [.V{var}], [.Vptr]\\n\"\n            output += \"mov ax, [.Vptr]\\n\"\n        \n        return res.success(output)\n\n    def emit_IfNode(self, node):\n        res = CTResult()\n        output = \"\"\n        l0 = self.label_idx\n        end = l0\n        self.label_idx += 1\n        l0 = self.label_idx\n        else_l0 = l0\n        self.label_idx += 1\n        l0 = self.label_idx\n        \n        for case in node.cases:\n            l0 = self.label_idx\n            self.label_idx += 1\n            l1 = self.label_idx\n            self.label_idx += 1\n            \n            output += res.register(self.emit(case[0]))\n            if res.error: return res\n            \n            output += \"test ax, ax\\n\"\n            output += \"cmp ax != 0\\n\"\n            output += f\"jt .L{l1}\\n\"\n            output += f\"jmp .L{l0}\\n\"\n            \n            output += f\".L{l1}:\\n\"\n            output += res.register(self.emit(case[1]))\n            if res.error: return res\n            output += f\"jmp .L{end}\\n\"\n\n            output += f\".L{l0}:\\n\"\n        \n        output += f\".L{else_l0}:\\n\"\n        if node.else_case:\n            output += res.register(self.emit(node.else_case[0]))\n            if res.error: return res\n        \n        output += f\".L{end}:\\n\"\n        \n        return res.success(output)\n    \n    def emit_ContinueNode(self, node):\n        if not self.loop_breakc:\n            return CTResult().failure(CTError(node.pos_start,\n                                       node.pos_end,\n                                       \"Cannot continue outside of a loop\"))\n        return CTResult().success(f\"jmp .L{self.loopsc[-1]}\\n\")\n\n    def emit_BreakNode(self, node):\n        if not self.loop_breakc:\n            return CTResult().failure(CTError(node.pos_start,\n                                       node.pos_end,\n                                       \"Cannot break outside of a loop\"))\n        return CTResult().success(f\"jmp .L{self.loopsb[-1]}\\n\")\n\n    def emit_WhileNode(self, node):\n        res = CTResult()\n        output = \"\"\n        \n        l0 = self.label_idx\n        self.label_idx += 1\n        l1 = self.label_idx\n        self.label_idx += 1\n        continue_label = l0\n        break_label = l1\n        \n        self.loopsc.append(continue_label)\n        self.loopsb.append(break_label)\n        \n        output += f\".L{l0}:\\n\"\n        output += res.register(self.emit(node.condition_node))\n        if res.error: return res\n        #output += \"cmp ax != 0\\n\"\n        #output += f\"jf .L{l1}\\n\"\n        output += \"test ax, ax\\n\"\n        output += \"cmp ax == 1\\n\"\n        output += f\"jf .L{l1}\\n\" \n        \n        for node in node.body_node:\n            self.loop_breakc = True\n            if type(node) is not CallNode:\n                output += res.register(self.emit(node))\n                if res.error: return res\n            else:\n                self.loop_breakc = False\n                output += res.register(self.emit(node))\n                if res.should_return(): return res\n        del self.loopsc[-1]\n        del self.loopsb[-1]\n        \n        output += f\"jmp .L{l0}\\n\"\n        output += f\".L{l1}:\\n\"\n        \n        return res.success(output)\n\n    def emit_ForNode(self, node):\n        res = CTResult()\n        output = \"\"\n        \n        l0 = self.label_idx\n        self.label_idx += 1\n        l1 = self.label_idx\n        self.label_idx += 1\n        continue_label = self.label_idx\n        self.label_idx += 1\n        break_label = self.label_idx\n        self.label_idx += 1\n        \n        self.loopsc.append(continue_label)\n        self.loopsb.append(break_label)\n        \n        var_name = node.var_name_tok.value\n        \n        output += res.register(self.emit(node.start_value_node))\n        if res.error: return res\n        output += f\"mov [{node.var_name_tok.value}], ax\\n\"\n        \n        end_value = self.var_idx\n        self.var_idx += 1\n        step_value = self.var_idx\n        self.var_idx += 1\n        \n        output += res.register(self.emit(node.end_value_node))\n        if res.error: return res\n        output += f\"mov [.V{end_value}], ax\\n\"\n        \n        if node.step_value_node:\n            output += res.register(self.emit(node.step_value_node))\n            if res.error: return res\n            output += f\"mov [.V{step_value}], ax\\n\"\n        else:\n            output += f\"mov [.V{step_value}], 1\\n\"\n        \n        output += f\"jmp .L{l1}\\n\"\n        output += f\".L{l0}:\\n\"\n        \n        for node in node.body_node:\n            self.loop_breakc = True\n            if type(node) is not CallNode:\n                output += res.register(self.emit(node))\n                if res.error: return res\n            else:\n                self.loop_breakc = False\n                output += res.register(self.emit(node))\n                if res.error: return res\n        del self.loopsc[-1]\n        del self.loopsb[-1]\n        \n        output += f\".L{continue_label}:\\n\"\n        output += f\"add [{var_name}], [.V{step_value}]\\n\"\n        \n        l2 = self.label_idx\n        self.label_idx += 1\n        l3 = self.label_idx\n        self.label_idx += 1\n        \n        output += f\".L{l1}:\\n\"\n        output += f\"cmp [.V{step_value}] >= 0\\n\"\n        output += f\"jt .L{l2}\\n\"\n        output += f\"jmp .L{l3}\\n\"\n        output += f\".L{l2}:\\n\"\n        output += f\"cmp [{var_name}] < [.V{end_value}]\\n\"\n        output += f\"jt .L{l0}\\n\"\n        output += f\".L{l3}:\\n\"\n        output += f\"cmp [{var_name}] > [.V{end_value}]\\n\"\n        output += f\"jt .L{l0}\\n\"\n        output += f\".L{break_label}:\\n\"\n        \n        return res.success(output)\n    \n    def emit_CallNode(self, node):\n        res = CTResult()\n        output = \"\"\n        \n        if type(node.node_to_call) is not VarAccessNode:\n            return res.failure(CTError(node.node_to_call.pos_start,\n                                       node.node_to_call.pos_end,\n                                       \"Function name is not an identifier\"))\n        \n        func_name = node.node_to_call.var_name_tok.value or None\n        \n        if not func_name in BUILTINS:\n            for node_ in node.arg_nodes[::-1]:\n                output += res.register(self.emit(node_))\n                output += \"push ax\\n\"\n            \n            output += res.register(self.emit(node.node_to_call))\n            if res.error: return res\n            \n            output += \"call ax\\n\"\n        else:\n            if not func_name in (\"asm\", \"ref\", \"new\"):\n                arg_len = len(node.arg_nodes)\n                for node in node.arg_nodes[::-1]:\n                    output += res.register(self.emit(node))\n                    output += \"push ax\\n\"\n                    \n                output += res.register(BUILTINS[func_name].execute(arg_len))\n            else:\n                if func_name == \"asm\":\n                    # TODO: return error if arg len is not 1\n                    args = node.arg_nodes[0]\n                    output += res.register(BUILTINS[func_name].execute(1, args.tok.value, True))\n                elif func_name == \"ref\":\n                    arg = node.arg_nodes[0]\n                    output += res.register(BUILTINS[func_name].execute(1, arg.var_name_tok.value, True))\n                elif func_name == \"new\":\n                    args_len = len(node.arg_nodes)\n                    \n                    if args_len < 1:\n                        return res.failure(CTError(\n                        node.pos_start, node.pos_end,\n                        f\"{1 - len(args_len)} too few args passed into new()\"\n                    ))\n                    \n                    arg = node.arg_nodes[0]\n                    args = node.arg_nodes[1:]\n                    \n                    if type(arg) is not ClassNode:\n                        return res.failure(CTError(\n                            arg.pos_start, arg.pos_end,\n                            f\"Expected class\"\n                        ))\n                    \n                    if arg.var_name_tok.value not in self.class_definitions.keys():\n                        return res.failure(CTError(\n                            arg.pos_start, arg.pos_end,\n                            f\"class {arg.var_name_tok.value} not found\"\n                        ))\n                    \n                    #value\n                    #variable\n                    #attr\n                    \n                    class_name = arg.var_name_tok.value\n                    \n                    output += f'mov [.temp{class_name}], \\'object {class_name}\\'\\n'\n                    \n                    for property, value in self.class_definitions[class_name]:\n                        #value\n\n                        if value is None:\n                            output += f'mov ax, 0\\n'\n                        else:\n                            output += res.register(self.emit(value))\n                            if res.error: return res\n                            \n                        output += 'push ax\\n'\n                        \n                        #variable\n                        output += f'mov ax, [.temp{class_name}]\\n'\n                        output += 'push ax\\n'\n                        \n                        #attr\n                        output += res.register(self.emit(property))\n                        if res.error: return res\n                        output += 'push ax\\n'\n                        \n                        output += 'mov ax, 17\\n'\n                        output += 'bcall\\n'\n                    \n                    methods = self.class_definitions[f'.{class_name}methods'] or None\n                    \n                    c_id = str(self.var_idx)\n                    self.var_idx += 1\n                    \n                    if methods and methods.element_nodes:\n                        for node in methods.element_nodes:\n                            func_name = node.func_name_tok.value\n                            \n                            try:\n                                emit = False\n                                _ = node.func_name_tok.set\n                                c_id = node.func_name_tok.c_id\n                            except AttributeError:\n                                emit = True\n                                func_name = '.' + func_name + c_id\n                                node.func_name_tok.value = func_name\n                                setattr(node.func_name_tok, 'set', True)\n                                setattr(node.func_name_tok, 'c_id', c_id)\n                           \n                            if func_name == '.constructor' + c_id:\n                                if len(node.arg_name_toks) < 1:\n                                    return res.failure(CTError(node.func_name_tok.pos_start, node.func_name_tok.pos_end,\n                                                            'Class construtor must have at least one argument'))\n                                node.body_node.append(ReturnNode(VarAccessNode(node.arg_name_toks[0]),\n                                                                 pos_start=node.arg_name_toks[0].pos_start,\n                                                                 pos_end=node.arg_name_toks[0].pos_end))\n                            \n                            # Avoid redefining already defined methods\n                            if emit:\n                                output += res.register(self.emit(node))\n                                if res.error: return res\n                            \n                            #value\n                            output += f'mov ax, [{func_name}]\\n'\n                            output += 'push ax\\n'\n                    \n                            #variable\n                            output += f'mov ax, [.temp{class_name}]\\n'\n                            output += 'push ax\\n'\n                            \n                            #attr\n                            output += f'mov ax, \\'{func_name[1:-len(c_id)]}\\'\\n'\n                            output += 'push ax\\n'\n                            \n                            output += 'mov ax, 17\\n'\n                            output += 'bcall\\n'\n                            \n                            if func_name == '.constructor' + c_id:\n                                for arg in args[::-1]:\n                                    output += res.register(self.emit(arg))\n                                    if res.error: return res\n                                    \n                                    output += 'push ax\\n'\n                                \n                                output += f'mov ax, [.temp{class_name}]\\n'\n                                output += 'push ax\\n'\n                                \n                                output += f'call [.constructor{c_id}]\\n'\n                                output += f'mov [.temp{class_name}], ax\\n'\n                    \n                    output += f'mov ax, [.temp{class_name}]\\n'\n        \n        return res.success(output)\n    \n    def emit_ReturnNode(self, node):\n        res = CTResult()\n        output = \"\"\n        \n        if node.node_to_return:\n            output += res.register(self.emit(node.node_to_return))\n            if res.error: return res\n        else:\n            output += \"mov ax, 0\\n\"\n        output += \"ret\\n\"\n        \n        return res.success(output)\n\n    def emit_FuncDefNode(self, node):\n        res = CTResult()\n        output = \"\"\n        \n        l0 = self.label_idx\n        self.label_idx += 1\n        \n        self.hoisted_definitions += 'mov ax, \"function\"\\n'\n        self.hoisted_definitions += 'push ax\\n'\n        \n        self.hoisted_definitions += f\"mov [{node.func_name_tok.value}], {node.func_name_tok.value}\\n\"\n        self.hoisted_definitions += f\"mov ax, [{node.func_name_tok.value}]\\n\"\n        self.hoisted_definitions += 'push ax\\n'\n        \n        self.hoisted_definitions += \"mov ax, '.type'\\n\"\n        self.hoisted_definitions += \"push ax\\n\"\n        self.hoisted_definitions += \"mov ax, 17\\n\"\n        self.hoisted_definitions += \"bcall\\n\"\n        \n        output += f\"jmp .L{l0}\\n\"\n        \n        output += f\"{node.func_name_tok.value}:\\n\"\n        \n        for arg in node.arg_name_toks:\n            output += f\"mov [{arg.value}], sp\\n\"\n            output += f\"pop\\n\"\n        \n        output += res.register(self.emit(node.body_node))\n        if res.error: return res\n        \n        output += f\"mov ax, 0\\n\"\n        output += f\"ret\\n\"\n        output += f\".L{l0}:\\n\"\n        \n        return res.success(output)\n    \n    def emit_Classnode(self, node):\n        res = CTResult()\n        output = \"\"\n        \n        return res.success(output)\n\n    def emit_ClassAssignNode(self, node):\n        res = CTResult()\n        output = \"\"\n        \n        class_name = node.var_name_tok.value\n        self.class_definitions[class_name] = node.value_node.element_nodes\n        \n        self.class_definitions[f'.{class_name}methods'] = node.methods\n\n        return res.success(output)", "\nclass Codegen:\n    def __init__(self):\n        self.label_idx = 0\n        self.var_idx = 0\n        self.loopsc = []\n        self.loopsb = []\n        self.loop_breakc = False\n        self.class_bcall = '18'\n        self.class_definitions = {}\n        self.hoisted_definitions = ''\n    \n    def emit(self, node):\n        method_name = f'emit_{type(node).__name__}'\n        method = getattr(self, method_name, self.no_emit_method)\n        return method(node)\n    \n    def no_emit_method(self, node):\n        raise Exception(f\"No emit_{type(node).__name__} method defined\")\n    \n    def emit_list(self, node):\n        res = CTResult()\n        output = \"\"\n        \n        for element_node in node:\n            output += res.register(self.emit(element_node))\n            if res.should_return(): return res\n        \n        return res.success(output)\n    \n    def emit_StringNode(self, node):\n        res = CTResult()\n        \n        output = \"mov ax, \"\n        output += '\"' + node.tok.value + '\"\\n'\n        return res.success(output)\n    \n    def emit_IntegerNode(self, node):\n        res = CTResult()\n        \n        output = \"mov ax, \"\n        output += str(node.tok.value) + '\\n'\n        return res.success(output)\n    \n    def emit_FloatNode(self, node):\n        res = CTResult()\n        \n        output = \"mov ax, \"\n        output += str(node.tok.value) + '\\n'\n        return res.success(output)\n    \n    def emit_ListNode(self, node):\n        res = CTResult()\n        # TODO: implement this\n        output = \"\"\n        \n        \n        length = len(node.element_nodes)\n        \n        variables = []\n        # make list of arguments\n        for _ in range(length):\n            variables.append(self.var_idx)\n            self.var_idx += 1\n        \n        i = 0\n        for var in variables:\n            output += res.register(self.emit(node.element_nodes[i]))\n            if res.error: return res\n                \n            output += f\"mov [.V{var}], ax\\n\"\n            i += 1\n            \n        output += 'mov ax, {'\n        i = 0\n        for var in variables:\n            output += f\"[.V{var}]\"\n            \n            if not i == len(variables)-1:\n                output += ', '\n            \n            i += 1\n        output += '}\\n'\n        \n        #print(output)\n        #exit()\n        \n        return res.success(output)\n    \n    def emit_VarAssignNode(self, node):\n        res = CTResult()\n        output = \"\"\n        \n        if type(node.var_name_tok) is BinOpNode:\n            if type(node.var_name_tok.left_node) is not VarAccessNode:\n                node.var_name_tok.left_node = VarAccessNode(node.var_name_tok.left_node.tok)\n                        \n            output += res.register(self.emit(node.value_node))\n            if res.error: return res\n            output += f\"push ax\\n\"\n            \n            self.class_bcall = '17'\n            output += res.register(self.emit(node.var_name_tok))\n            if res.error: return res\n            self.class_bcall = '18'\n            \n            return res.success(output)\n        \n        output += res.register(self.emit(node.value_node))\n        if res.error: return res\n        output += f\"mov [{node.var_name_tok.value}], ax\\n\"\n        return res.success(output)\n    \n    def emit_VarAccessNode(self, node):\n        res = CTResult()\n        \n        return res.success(f\"mov ax, [{node.var_name_tok.value}]\\n\")\n    \n    def op_op(self, node):\n        output = \"\"\n        op = \"\"\n        # TODO:\n        # make this to put it in a variable instead\n        # as it wont work when calling functions for example\n        # can probably be done for just functions\n        \n        if node.op_tok.type == TT_EE:\n            op = \"== \"\n        elif node.op_tok.type == TT_NE:\n            op = \"!= \"\n        elif node.op_tok.type == TT_LT:\n            op = \"< \"\n        elif node.op_tok.type == TT_GT:\n            op = \"> \"\n        elif node.op_tok.type == TT_LTE:\n            op = \"<= \"\n        elif node.op_tok.type == TT_GTE:\n            op = \">= \"\n        \n        if op != \"\":\n            if type(node.left_node) is not VarAccessNode and type(node.left_node) is not StringNode:\n                output += f\"{node.left_node.tok.value} \"\n            elif type(node.left_node) is StringNode:\n                output += f\"\\\"{node.left_node.tok.value}\\\" \"\n            elif type(node.left_node) is VarAccessNode:\n                output += f\"[{node.left_node.var_name_tok.value}] \"\n                \n            output += op\n                \n            if type(node.right_node) is not VarAccessNode and type(node.right_node) is not StringNode:\n                output += f\"{node.right_node.tok.value} \"\n            elif type(node.right_node) is StringNode:\n                output += f\"\\\"{node.right_node.tok.value}\\\" \"\n            elif type(node.right_node) is VarAccessNode:\n                output += f\"[{node.right_node.var_name_tok.value}] \"\n                \n        return output\n    \n    def andor_op(self, node, a=False):\n        res = CTResult()\n        \n        if not a:\n            output = \"cmp \"\n        else:\n            output = \"\"\n        \n        lnode = node.left_node\n        rnode = node.right_node\n        \n        if lnode.op_tok.matches(TT_KEYWORD, 'and'):\n            output += res.register(self.andor_op(lnode, True)) + \"&& \"\n            if res.error: return res\n        elif lnode.op_tok.matches(TT_KEYWORD, 'or'):\n            output += res.register(self.andor_op(lnode, True)) + \"|| \"\n            if res.error: return res\n        \n        output += self.op_op(lnode)\n        \n        if node.op_tok.matches(TT_KEYWORD, 'and') and not lnode.op_tok.matches(TT_KEYWORD, 'and'):\n            if output[-3:-1] in ('&&', '||'):\n                output = output[:-3]\n            output += \"&& \"\n        if node.op_tok.matches(TT_KEYWORD, 'or') and not lnode.op_tok.matches(TT_KEYWORD, 'or'):\n            if output[-3:-1] in ('&&', '||'):\n                output = output[:-3]\n            output += \"|| \"\n        \n        output += self.op_op(rnode)\n        \n        return res.success(output)\n    \n    def class_def(self, node):\n        res = CTResult()\n        output = \"\"\n        \n        last_node = node.right_node\n        while type(last_node) is BinOpNode:\n            last_node = last_node.right_node\n        \n        nd, _ = node.remove_last_node()\n        \n        self.class_bcall = '18'\n        \n        output += res.register(self.emit(nd))\n        if res.error: return res\n        self.class_bcall = '17'\n        \n        output += 'push ax\\n'\n        \n        output += f'mov ax, \"{last_node.var_name_tok.value}\"\\n'\n        output += 'push ax\\n'\n        \n        #output += 'mov ax, 17\\n'\n        #output += 'bcall\\n'\n        \n        return res.success(output)\n    \n    def class_access(self, node):\n        res = CTResult()\n        output = \"\"\n        \n        i = 0\n        right = node.right_node\n        while type(right) is BinOpNode:\n            right = right.right_node\n            i += 1\n        \n        output += res.register(self.emit(node.left_node))\n        if res.error: return res\n        output += 'push ax\\n'\n        \n        right = node.right_node\n        \n        if type(right) is BinOpNode:\n            left = node.right_node.left_node\n        while type(right) is BinOpNode:\n            if type(right) is BinOpNode:\n                left = right.left_node\n                right = right.right_node\n            \n            output += f'mov ax, \"{left.var_name_tok.value}\"\\n'\n            output += f'push ax\\n'\n            \n            output += f'mov ax, {self.class_bcall}\\n'\n            output += 'bcall\\n'\n            output += f'push ax\\n'\n        \n        if type(node.right_node) is CallNode:            \n            output += f'mov ax, \"{node.right_node.node_to_call.var_name_tok.value}\"\\n'\n            output += 'push ax\\n'\n        elif type(node.right_node) is not BinOpNode:\n            output += f'mov ax, \"{node.right_node.var_name_tok.value}\"\\n'\n            output += f'push ax\\n'\n        else:\n            output += f'mov ax, \"{right.var_name_tok.value}\"\\n'\n            output += f'push ax\\n'\n        \n        return res.success(output)\n    \n    def emit_BinOpNode(self, node):\n        res = CTResult()\n        output = \"\"\n        \n        if not node.op_tok.value in ('and', 'or', 'DOT') and not node.op_tok.type in (TT_DOT):\n            if res.should_return(): return res\n            output += res.register(self.emit(node.right_node))\n            if node.op_tok.type in (TT_PLUS, TT_MINUS, TT_MUL, TT_DIV, TT_MOD):\n                output += \"push ax\\n\"\n            else:\n                output += \"mov bx, ax\\n\"\n                output += \"push ax\\n\"\n            \n            output += res.register(self.emit(node.left_node))\n            if res.should_return(): return res\n        else:\n            if node.op_tok.matches(TT_KEYWORD, 'and') or node.op_tok.matches(TT_KEYWORD, 'or'):\n                output += res.register(self.emit(node.left_node))\n                if res.error: return res\n                \n                left_var = self.var_idx\n                self.var_idx += 1\n                \n                output += \"test ax, ax\\n\"\n                output += f\"mov [.V{left_var}], ax\\n\"\n                \n                output += res.register(self.emit(node.right_node))\n                if res.error: return res\n                \n                right_var = self.var_idx\n                self.var_idx += 1\n                \n                output += \"test ax, ax\\n\"\n                output += f\"mov [.V{right_var}], ax\\n\"\n                \n                # allows for something like this:\n                # 1 and 1 | 1 or 2 | foo() and bar()\n                if type(node.right_node) is not BinOpNode:\n                    varname = Token(TT_IDENTIFIER, f'.V{right_var}',\n                                    node.right_node.pos_start,\n                                    node.right_node.pos_start)\n                    node.right_node = BinOpNode(VarAccessNode(varname), Token(TT_NE, None,\n                                                                       node.right_node.pos_start, \n                                                                       node.right_node.pos_end),\n                                                                       IntegerNode(Token(TT_INT, 0,\n                                                                                         node.right_node.pos_start,\n                                                                                         node.right_node.pos_end)))\n                if type(node.left_node) is not BinOpNode:\n                    varname = Token(TT_IDENTIFIER, f'.V{left_var}',\n                                    node.left_node.pos_start,\n                                    node.left_node.pos_start)\n                    node.left_node = BinOpNode(VarAccessNode(varname), Token(TT_NE, None,\n                                                                       node.left_node.pos_start, \n                                                                       node.left_node.pos_end),\n                                                                       IntegerNode(Token(TT_INT, 0,\n                                                                                         node.left_node.pos_start,\n                                                                                         node.left_node.pos_end)))\n                output += res.register(self.andor_op(node)) + '\\n'\n                if res.error: return res\n                \n                l0 = self.label_idx\n                self.label_idx += 1\n                l1 = self.label_idx\n                self.label_idx += 1\n                l2 = self.label_idx\n                self.label_idx += 1\n                \n                output += f\"jt .L{l0}\\n\"\n                output += f\"jmp .L{l1}\\n\"\n                output += f\".L{l0}:\\n\"\n                output += f\"    mov ax, 1\\n\"\n                output += f\"    jmp .L{l2}\\n\"\n                output += f\".L{l1}:\\n\"\n                output += f\"    mov ax, 0\\n\"\n                output += f\".L{l2}:\\n\"\n                return res.success(output)\n        \n        if node.op_tok.type == TT_DOT:\n            if self.class_bcall == '18':\n                output += res.register(self.class_access(node))\n            else:\n                output += res.register(self.class_def(node))\n            if res.error: return res\n                \n\n            output += f'mov ax, {self.class_bcall}\\n'\n            output += 'bcall\\n'\n            \n            if type(node.right_node) is CallNode:\n                tempvar = self.var_idx\n                output += f'mov [.V{tempvar}], ax\\n'\n                self.var_idx += 1\n                for arg in node.right_node.arg_nodes[::-1]:\n                    output += res.register(self.emit(arg))\n                    if res.error: return res\n                    output += 'push ax\\n'\n                \n                output += res.register(self.emit(node.left_node))\n                if res.error: return res\n                \n                output += 'push ax\\n'\n                output += f'call [.V{tempvar}]\\n'\n        elif node.op_tok.type == TT_PLUS:\n            output += \"add ax, sp\\n\"\n            output += \"pop\\n\"\n        elif node.op_tok.type == TT_MINUS:\n            output += \"sub ax, sp\\n\"\n            output += \"pop\\n\"\n        elif node.op_tok.type == TT_MUL:\n            output += \"mul ax, sp\\n\"\n            output += \"pop\\n\"\n        elif node.op_tok.type == TT_DIV:\n            output += \"div ax, sp\\n\"\n            output += \"pop\\n\"\n        elif node.op_tok.type == TT_POW:\n            output += \"pow ax, sp\\n\"\n            output += \"pop\\n\"\n        elif node.op_tok.type == TT_MOD:\n            output += \"mod ax, sp\\n\"\n            output += \"pop\\n\"\n        elif node.op_tok.type == TT_EE:\n            l0 = self.label_idx\n            self.label_idx += 1\n            l1 = self.label_idx\n            self.label_idx += 1\n            l2 = self.label_idx\n            self.label_idx += 1\n            \n            output += \"pop\\n\"\n            output += \"cmp ax == bx\\n\"\n            output += f\"jt .L{l0}\\n\"\n            output += f\"jmp .L{l1}\\n\"            \n            output += f\".L{l0}:\\n\"\n            output += f\"    mov ax, 1\\n\"\n            output += f\"    jmp .L{l2}\\n\"\n            output += f\".L{l1}:\\n\"\n            output += f\"    mov ax, 0\\n\"\n            output += f\".L{l2}:\\n\"\n        elif node.op_tok.type == TT_NE:\n            l0 = self.label_idx\n            self.label_idx += 1\n            l1 = self.label_idx\n            self.label_idx += 1\n            l2 = self.label_idx\n            self.label_idx += 1\n            \n            output += \"pop\\n\"\n            output += \"cmp ax != bx\\n\"\n            output += f\"jt .L{l0}\\n\"\n            output += f\"jmp .L{l1}\\n\"            \n            output += f\".L{l0}:\\n\"\n            output += f\"    mov ax, 1\\n\"\n            output += f\"    jmp .L{l2}\\n\"\n            output += f\".L{l1}:\\n\"\n            output += f\"    mov ax, 0\\n\"\n            output += f\".L{l2}:\\n\"\n        elif node.op_tok.type == TT_LT:\n            l0 = self.label_idx\n            self.label_idx += 1\n            l1 = self.label_idx\n            self.label_idx += 1\n            l2 = self.label_idx\n            self.label_idx += 1\n            \n            output += \"pop\\n\"\n            output += \"cmp ax < bx\\n\"\n            output += f\"jt .L{l0}\\n\"\n            output += f\"jmp .L{l1}\\n\"            \n            output += f\".L{l0}:\\n\"\n            output += f\"    mov ax, 1\\n\"\n            output += f\"    jmp .L{l2}\\n\"\n            output += f\".L{l1}:\\n\"\n            output += f\"    mov ax, 0\\n\"\n            output += f\".L{l2}:\\n\"\n        elif node.op_tok.type == TT_GT:\n            l0 = self.label_idx\n            self.label_idx += 1\n            l1 = self.label_idx\n            self.label_idx += 1\n            l2 = self.label_idx\n            self.label_idx += 1\n            \n            output += \"pop\\n\"\n            output += \"cmp ax > bx\\n\"\n            output += f\"jt .L{l0}\\n\"\n            output += f\"jmp .L{l1}\\n\"            \n            output += f\".L{l0}:\\n\"\n            output += f\"    mov ax, 1\\n\"\n            output += f\"    jmp .L{l2}\\n\"\n            output += f\".L{l1}:\\n\"\n            output += f\"    mov ax, 0\\n\"\n            output += f\".L{l2}:\\n\"\n        elif node.op_tok.type == TT_LTE:\n            l0 = self.label_idx\n            self.label_idx += 1\n            l1 = self.label_idx\n            self.label_idx += 1\n            l2 = self.label_idx\n            self.label_idx += 1\n            \n            output += \"pop\\n\"\n            output += \"cmp ax <= bx\\n\"\n            output += f\"jt .L{l0}\\n\"\n            output += f\"jmp .L{l1}\\n\"            \n            output += f\".L{l0}:\\n\"\n            output += f\"    mov ax, 1\\n\"\n            output += f\"    jmp .L{l2}\\n\"\n            output += f\".L{l1}:\\n\"\n            output += f\"    mov ax, 0\\n\"\n            output += f\".L{l2}:\\n\"\n        elif node.op_tok.type == TT_GTE:\n            l0 = self.label_idx\n            self.label_idx += 1\n            l1 = self.label_idx\n            self.label_idx += 1\n            l2 = self.label_idx\n            self.label_idx += 1\n            \n            output += \"pop\\n\"\n            output += \"cmp ax >= bx\\n\"\n            output += f\"jt .L{l0}\\n\"\n            output += f\"jmp .L{l1}\\n\"            \n            output += f\".L{l0}:\\n\"\n            output += f\"    mov ax, 1\\n\"\n            output += f\"    jmp .L{l2}\\n\"\n            output += f\".L{l1}:\\n\"\n            output += f\"    mov ax, 0\\n\"\n            output += f\".L{l2}:\\n\"\n\n        return res.success(output)\n\n    def emit_UnaryOpNode(self, node):\n        res = CTResult()\n        output = \"\"\n        \n        output += res.register(self.emit(node.node))\n        if res.error: return res\n        \n        if node.op_tok.type == TT_MINUS:\n            output += \"mov bx, 0\\n\"\n            output += \"sub bx, 1\\n\"\n            output += \"mul ax, bx\\n\"\n        elif node.op_tok.type == TT_MUL:\n            var = self.var_idx\n            self.var_idx += 1\n            \n            output += res.register(self.emit(node.node))\n            if res.error: return res\n            output += f'mov [.V{var}], ax\\n'\n            \n            output += f\"pt [.V{var}], [.Vptr]\\n\"\n            output += \"mov ax, [.Vptr]\\n\"\n        \n        return res.success(output)\n\n    def emit_IfNode(self, node):\n        res = CTResult()\n        output = \"\"\n        l0 = self.label_idx\n        end = l0\n        self.label_idx += 1\n        l0 = self.label_idx\n        else_l0 = l0\n        self.label_idx += 1\n        l0 = self.label_idx\n        \n        for case in node.cases:\n            l0 = self.label_idx\n            self.label_idx += 1\n            l1 = self.label_idx\n            self.label_idx += 1\n            \n            output += res.register(self.emit(case[0]))\n            if res.error: return res\n            \n            output += \"test ax, ax\\n\"\n            output += \"cmp ax != 0\\n\"\n            output += f\"jt .L{l1}\\n\"\n            output += f\"jmp .L{l0}\\n\"\n            \n            output += f\".L{l1}:\\n\"\n            output += res.register(self.emit(case[1]))\n            if res.error: return res\n            output += f\"jmp .L{end}\\n\"\n\n            output += f\".L{l0}:\\n\"\n        \n        output += f\".L{else_l0}:\\n\"\n        if node.else_case:\n            output += res.register(self.emit(node.else_case[0]))\n            if res.error: return res\n        \n        output += f\".L{end}:\\n\"\n        \n        return res.success(output)\n    \n    def emit_ContinueNode(self, node):\n        if not self.loop_breakc:\n            return CTResult().failure(CTError(node.pos_start,\n                                       node.pos_end,\n                                       \"Cannot continue outside of a loop\"))\n        return CTResult().success(f\"jmp .L{self.loopsc[-1]}\\n\")\n\n    def emit_BreakNode(self, node):\n        if not self.loop_breakc:\n            return CTResult().failure(CTError(node.pos_start,\n                                       node.pos_end,\n                                       \"Cannot break outside of a loop\"))\n        return CTResult().success(f\"jmp .L{self.loopsb[-1]}\\n\")\n\n    def emit_WhileNode(self, node):\n        res = CTResult()\n        output = \"\"\n        \n        l0 = self.label_idx\n        self.label_idx += 1\n        l1 = self.label_idx\n        self.label_idx += 1\n        continue_label = l0\n        break_label = l1\n        \n        self.loopsc.append(continue_label)\n        self.loopsb.append(break_label)\n        \n        output += f\".L{l0}:\\n\"\n        output += res.register(self.emit(node.condition_node))\n        if res.error: return res\n        #output += \"cmp ax != 0\\n\"\n        #output += f\"jf .L{l1}\\n\"\n        output += \"test ax, ax\\n\"\n        output += \"cmp ax == 1\\n\"\n        output += f\"jf .L{l1}\\n\" \n        \n        for node in node.body_node:\n            self.loop_breakc = True\n            if type(node) is not CallNode:\n                output += res.register(self.emit(node))\n                if res.error: return res\n            else:\n                self.loop_breakc = False\n                output += res.register(self.emit(node))\n                if res.should_return(): return res\n        del self.loopsc[-1]\n        del self.loopsb[-1]\n        \n        output += f\"jmp .L{l0}\\n\"\n        output += f\".L{l1}:\\n\"\n        \n        return res.success(output)\n\n    def emit_ForNode(self, node):\n        res = CTResult()\n        output = \"\"\n        \n        l0 = self.label_idx\n        self.label_idx += 1\n        l1 = self.label_idx\n        self.label_idx += 1\n        continue_label = self.label_idx\n        self.label_idx += 1\n        break_label = self.label_idx\n        self.label_idx += 1\n        \n        self.loopsc.append(continue_label)\n        self.loopsb.append(break_label)\n        \n        var_name = node.var_name_tok.value\n        \n        output += res.register(self.emit(node.start_value_node))\n        if res.error: return res\n        output += f\"mov [{node.var_name_tok.value}], ax\\n\"\n        \n        end_value = self.var_idx\n        self.var_idx += 1\n        step_value = self.var_idx\n        self.var_idx += 1\n        \n        output += res.register(self.emit(node.end_value_node))\n        if res.error: return res\n        output += f\"mov [.V{end_value}], ax\\n\"\n        \n        if node.step_value_node:\n            output += res.register(self.emit(node.step_value_node))\n            if res.error: return res\n            output += f\"mov [.V{step_value}], ax\\n\"\n        else:\n            output += f\"mov [.V{step_value}], 1\\n\"\n        \n        output += f\"jmp .L{l1}\\n\"\n        output += f\".L{l0}:\\n\"\n        \n        for node in node.body_node:\n            self.loop_breakc = True\n            if type(node) is not CallNode:\n                output += res.register(self.emit(node))\n                if res.error: return res\n            else:\n                self.loop_breakc = False\n                output += res.register(self.emit(node))\n                if res.error: return res\n        del self.loopsc[-1]\n        del self.loopsb[-1]\n        \n        output += f\".L{continue_label}:\\n\"\n        output += f\"add [{var_name}], [.V{step_value}]\\n\"\n        \n        l2 = self.label_idx\n        self.label_idx += 1\n        l3 = self.label_idx\n        self.label_idx += 1\n        \n        output += f\".L{l1}:\\n\"\n        output += f\"cmp [.V{step_value}] >= 0\\n\"\n        output += f\"jt .L{l2}\\n\"\n        output += f\"jmp .L{l3}\\n\"\n        output += f\".L{l2}:\\n\"\n        output += f\"cmp [{var_name}] < [.V{end_value}]\\n\"\n        output += f\"jt .L{l0}\\n\"\n        output += f\".L{l3}:\\n\"\n        output += f\"cmp [{var_name}] > [.V{end_value}]\\n\"\n        output += f\"jt .L{l0}\\n\"\n        output += f\".L{break_label}:\\n\"\n        \n        return res.success(output)\n    \n    def emit_CallNode(self, node):\n        res = CTResult()\n        output = \"\"\n        \n        if type(node.node_to_call) is not VarAccessNode:\n            return res.failure(CTError(node.node_to_call.pos_start,\n                                       node.node_to_call.pos_end,\n                                       \"Function name is not an identifier\"))\n        \n        func_name = node.node_to_call.var_name_tok.value or None\n        \n        if not func_name in BUILTINS:\n            for node_ in node.arg_nodes[::-1]:\n                output += res.register(self.emit(node_))\n                output += \"push ax\\n\"\n            \n            output += res.register(self.emit(node.node_to_call))\n            if res.error: return res\n            \n            output += \"call ax\\n\"\n        else:\n            if not func_name in (\"asm\", \"ref\", \"new\"):\n                arg_len = len(node.arg_nodes)\n                for node in node.arg_nodes[::-1]:\n                    output += res.register(self.emit(node))\n                    output += \"push ax\\n\"\n                    \n                output += res.register(BUILTINS[func_name].execute(arg_len))\n            else:\n                if func_name == \"asm\":\n                    # TODO: return error if arg len is not 1\n                    args = node.arg_nodes[0]\n                    output += res.register(BUILTINS[func_name].execute(1, args.tok.value, True))\n                elif func_name == \"ref\":\n                    arg = node.arg_nodes[0]\n                    output += res.register(BUILTINS[func_name].execute(1, arg.var_name_tok.value, True))\n                elif func_name == \"new\":\n                    args_len = len(node.arg_nodes)\n                    \n                    if args_len < 1:\n                        return res.failure(CTError(\n                        node.pos_start, node.pos_end,\n                        f\"{1 - len(args_len)} too few args passed into new()\"\n                    ))\n                    \n                    arg = node.arg_nodes[0]\n                    args = node.arg_nodes[1:]\n                    \n                    if type(arg) is not ClassNode:\n                        return res.failure(CTError(\n                            arg.pos_start, arg.pos_end,\n                            f\"Expected class\"\n                        ))\n                    \n                    if arg.var_name_tok.value not in self.class_definitions.keys():\n                        return res.failure(CTError(\n                            arg.pos_start, arg.pos_end,\n                            f\"class {arg.var_name_tok.value} not found\"\n                        ))\n                    \n                    #value\n                    #variable\n                    #attr\n                    \n                    class_name = arg.var_name_tok.value\n                    \n                    output += f'mov [.temp{class_name}], \\'object {class_name}\\'\\n'\n                    \n                    for property, value in self.class_definitions[class_name]:\n                        #value\n\n                        if value is None:\n                            output += f'mov ax, 0\\n'\n                        else:\n                            output += res.register(self.emit(value))\n                            if res.error: return res\n                            \n                        output += 'push ax\\n'\n                        \n                        #variable\n                        output += f'mov ax, [.temp{class_name}]\\n'\n                        output += 'push ax\\n'\n                        \n                        #attr\n                        output += res.register(self.emit(property))\n                        if res.error: return res\n                        output += 'push ax\\n'\n                        \n                        output += 'mov ax, 17\\n'\n                        output += 'bcall\\n'\n                    \n                    methods = self.class_definitions[f'.{class_name}methods'] or None\n                    \n                    c_id = str(self.var_idx)\n                    self.var_idx += 1\n                    \n                    if methods and methods.element_nodes:\n                        for node in methods.element_nodes:\n                            func_name = node.func_name_tok.value\n                            \n                            try:\n                                emit = False\n                                _ = node.func_name_tok.set\n                                c_id = node.func_name_tok.c_id\n                            except AttributeError:\n                                emit = True\n                                func_name = '.' + func_name + c_id\n                                node.func_name_tok.value = func_name\n                                setattr(node.func_name_tok, 'set', True)\n                                setattr(node.func_name_tok, 'c_id', c_id)\n                           \n                            if func_name == '.constructor' + c_id:\n                                if len(node.arg_name_toks) < 1:\n                                    return res.failure(CTError(node.func_name_tok.pos_start, node.func_name_tok.pos_end,\n                                                            'Class construtor must have at least one argument'))\n                                node.body_node.append(ReturnNode(VarAccessNode(node.arg_name_toks[0]),\n                                                                 pos_start=node.arg_name_toks[0].pos_start,\n                                                                 pos_end=node.arg_name_toks[0].pos_end))\n                            \n                            # Avoid redefining already defined methods\n                            if emit:\n                                output += res.register(self.emit(node))\n                                if res.error: return res\n                            \n                            #value\n                            output += f'mov ax, [{func_name}]\\n'\n                            output += 'push ax\\n'\n                    \n                            #variable\n                            output += f'mov ax, [.temp{class_name}]\\n'\n                            output += 'push ax\\n'\n                            \n                            #attr\n                            output += f'mov ax, \\'{func_name[1:-len(c_id)]}\\'\\n'\n                            output += 'push ax\\n'\n                            \n                            output += 'mov ax, 17\\n'\n                            output += 'bcall\\n'\n                            \n                            if func_name == '.constructor' + c_id:\n                                for arg in args[::-1]:\n                                    output += res.register(self.emit(arg))\n                                    if res.error: return res\n                                    \n                                    output += 'push ax\\n'\n                                \n                                output += f'mov ax, [.temp{class_name}]\\n'\n                                output += 'push ax\\n'\n                                \n                                output += f'call [.constructor{c_id}]\\n'\n                                output += f'mov [.temp{class_name}], ax\\n'\n                    \n                    output += f'mov ax, [.temp{class_name}]\\n'\n        \n        return res.success(output)\n    \n    def emit_ReturnNode(self, node):\n        res = CTResult()\n        output = \"\"\n        \n        if node.node_to_return:\n            output += res.register(self.emit(node.node_to_return))\n            if res.error: return res\n        else:\n            output += \"mov ax, 0\\n\"\n        output += \"ret\\n\"\n        \n        return res.success(output)\n\n    def emit_FuncDefNode(self, node):\n        res = CTResult()\n        output = \"\"\n        \n        l0 = self.label_idx\n        self.label_idx += 1\n        \n        self.hoisted_definitions += 'mov ax, \"function\"\\n'\n        self.hoisted_definitions += 'push ax\\n'\n        \n        self.hoisted_definitions += f\"mov [{node.func_name_tok.value}], {node.func_name_tok.value}\\n\"\n        self.hoisted_definitions += f\"mov ax, [{node.func_name_tok.value}]\\n\"\n        self.hoisted_definitions += 'push ax\\n'\n        \n        self.hoisted_definitions += \"mov ax, '.type'\\n\"\n        self.hoisted_definitions += \"push ax\\n\"\n        self.hoisted_definitions += \"mov ax, 17\\n\"\n        self.hoisted_definitions += \"bcall\\n\"\n        \n        output += f\"jmp .L{l0}\\n\"\n        \n        output += f\"{node.func_name_tok.value}:\\n\"\n        \n        for arg in node.arg_name_toks:\n            output += f\"mov [{arg.value}], sp\\n\"\n            output += f\"pop\\n\"\n        \n        output += res.register(self.emit(node.body_node))\n        if res.error: return res\n        \n        output += f\"mov ax, 0\\n\"\n        output += f\"ret\\n\"\n        output += f\".L{l0}:\\n\"\n        \n        return res.success(output)\n    \n    def emit_Classnode(self, node):\n        res = CTResult()\n        output = \"\"\n        \n        return res.success(output)\n\n    def emit_ClassAssignNode(self, node):\n        res = CTResult()\n        output = \"\"\n        \n        class_name = node.var_name_tok.value\n        self.class_definitions[class_name] = node.value_node.element_nodes\n        \n        self.class_definitions[f'.{class_name}methods'] = node.methods\n\n        return res.success(output)", ""]}
{"filename": "Alphassembly/assembler/glang/modules/consts.py", "chunked_list": ["import string\n\nLETTERS = string.ascii_letters\nDIGITS = string.digits\nLETTERS_DIGITS = LETTERS + DIGITS\n\nTT_INT = 'INT'\nTT_FLOAT = 'FLOAT'\nTT_STRING = 'STRING'\nTT_IDENTIFIER = 'IDENTIFIER'", "TT_STRING = 'STRING'\nTT_IDENTIFIER = 'IDENTIFIER'\nTT_KEYWORD = 'KEYWORD'\nTT_PLUS = 'PLUS'\nTT_MINUS = 'MINUS'\nTT_MUL = 'MUL'\nTT_DIV = 'DIV'\nTT_POW = 'POW'\nTT_MOD = 'MOD'\nTT_EQ = 'EQ'", "TT_MOD = 'MOD'\nTT_EQ = 'EQ'\nTT_LPAREN = 'LPAREN'\nTT_RPAREN = 'RPAREN'\nTT_RSQUARE = 'RSQUARE'\nTT_LSQUARE = 'LSQUARE'\nTT_COMMA = 'COMMA'\nTT_NEWLINE = 'NEWLINE'\nTT_EE = 'EE'\nTT_NE = 'NE'", "TT_EE = 'EE'\nTT_NE = 'NE'\nTT_LT = 'LT'\nTT_GT = 'GT'\nTT_LTE = 'LTE'\nTT_GTE = 'GTE'\nTT_DCOLON = 'DCOLON'\nTT_DOT = 'DOT'\nTT_EOF = 'EOF'\n", "TT_EOF = 'EOF'\n\nKEYWORDS = [\n    'var',\n    'if',\n    'else',\n    'elif',\n    'end',\n    'and',\n    'or',", "    'and',\n    'or',\n    'for',\n    'to',\n    'step',\n    'continue',\n    'break',\n    'while',\n    'def',\n    'return',", "    'def',\n    'return',\n    'include',\n    'class'\n]\n"]}
{"filename": "Alphassembly/assembler/glang/modules/errors.py", "chunked_list": ["from .strings_with_arrows import *\n\nclass Error:\n    def __init__(self, pos_start, pos_end, error_name, details):\n        self.pos_start = pos_start\n        self.pos_end = pos_end\n        self.error_name = error_name\n        self.details = details\n\n    def __str__(self):\n        result = f'{self.error_name}: {self.details}\\n'\n        result += f'File {self.pos_start.fn}, line {self.pos_start.ln + 1}'\n        result += '\\n\\n' + string_with_arrows(self.pos_start.ftxt, self.pos_start, self.pos_end)\n        return result", "\n\nclass IllegalCharError(Error):\n    def __init__(self, pos_start, pos_end, details):\n        super().__init__(pos_start, pos_end, 'Illegal Character', details)\n\n\nclass ExpectedCharError(Error):\n    def __init__(self, pos_start, pos_end, details):\n        super().__init__(pos_start, pos_end, 'Expected Character', details)", "\n\nclass InvalidSyntaxError(Error):\n    def __init__(self, pos_start, pos_end, details=''):\n        super().__init__(pos_start, pos_end, 'Invalid Syntax', details)\n\n\nclass CTError(Error):\n    def __init__(self, pos_start, pos_end, details=''):\n        super().__init__(pos_start, pos_end, 'Compile time error', details)", "\n\nclass IncludeError(Error):\n    def __init__(self, pos_start, pos_end, details=''):\n        super().__init__(pos_start, pos_end, 'Include error', details)\n"]}
{"filename": "Alphassembly/assembler/glang/modules/builtin_function.py", "chunked_list": ["from .errors import *\nfrom .ctresult import *\n\nclass BaseFunction():\n    def __init__(self, name):\n        self.name = name or \"<anonymous>\"\n\n    def check_args(self, arg_names, args_len):\n        res = CTResult()\n\n        if args_len > len(arg_names):\n            return res.failure(CTError(\n            self.pos_start, self.pos_end,\n            f\"{args_len - len(arg_names)} too many args passed into {self}\",\n            self.context\n        ))\n        \n        if args_len < len(arg_names):\n            return res.failure(CTError(\n            self.pos_start, self.pos_end,\n            f\"{len(arg_names) - len(args_len)} too few args passed into {self}\",\n            self.context\n        ))\n\n        return res.success(None)\n\n    def populate_args(self, arg_names, args_len):\n        output = \"\"\n        for i in range(args_len):\n            arg_name = arg_names[i]\n            output += f\"mov [.V{arg_name}], sp\\n\"\n            output += f\"pop\\n\"\n        return output\n\n    def check_and_populate_args(self, arg_names, args_len):\n        res = CTResult()\n        output = \"\"\n        \n        res.register(self.check_args(arg_names, args_len))\n        if res.should_return(): return res\n        output += self.populate_args(arg_names, args_len)\n        return res.success(output)", "\n\nclass BuiltinFunction(BaseFunction):\n    def __init__(self, name):\n        super().__init__(name)\n\n    def execute(self, args_len, args=None, p=False):\n        res = CTResult()\n        output = \"\"\n\n        method_name = f'execute_{self.name}'\n        method = getattr(self, method_name, self.no_visit_method)\n\n        if not p:\n            output += res.register(self.check_and_populate_args(method.arg_names, args_len))\n            if res.error: return res\n\n            output += res.register(method())\n            if res.error: return res\n        else:\n            output += res.register(method(args))\n\n        return res.success(output)\n\n    def no_visit_method(self, node, context):\n        raise Exception(f'No execute_{self.name} method defined')\n\n    def copy(self):\n        copy = BuiltinFunction(self.name)\n        copy.set_context(self.context)\n        copy.set_pos(self.pos_start, self.pos_end)\n        return copy\n\n    def __repr__(self):\n        return f\"<built-in function {self.name}>\"\n\n    def execute_print(self):\n        output = \"\"\n        \n        output += \"push [.Vvalue]\\n\"\n        output += \"print\\n\"\n        output += \"pop\\n\"\n\n        return CTResult().success(output)\n    execute_print.arg_names = ['value']\n\n    def execute_exit(self):\n        output = \"\"\n        \n        output += \"push [.Vretcode]\\n\"\n        output += \"done\\n\"\n\n        return CTResult().success(output)\n    execute_exit.arg_names = ['retcode']\n    \n    def execute_asm(self, arg):\n        output = \"\"\n        \n        output += f\"{arg}\\n\"\n        \n        return CTResult().success(output)\n    \n    def execute_ref(self, arg): # TODO: this does not work as .Vvalue is used multiple times\n        output = \"\"\n        \n        # get the name of the variable that needs to be pointed to\n        output += f\"pt [{arg}], [.Vptr]\\n\"\n        output += \"mov ax, [.Vptr]\\n\"\n        \n        return CTResult().success(output)\n    execute_ref.arg_names = ['ptr']", ""]}
{"filename": "Alphassembly/assembler/glang/modules/parse_result.py", "chunked_list": ["class ParseResult:\n    def __init__(self):\n        self.error = None\n        self.node = None\n        self.last_registered_advance_count = 0\n        self.advance_count = 0\n        self.to_reverse_count = 0\n\n    def register_advancement(self):\n        self.last_registered_advance_count = 1\n        self.advance_count += 1\n\n    def try_register(self, res):\n        if res.error:\n            self.to_reverse_count = res.advance_count\n            return None\n        return self.register(res)\n\n    def register(self, res):\n        self.last_registered_advance_count = res.advance_count\n        self.advance_count += res.advance_count\n        if res.error: self.error = res.error\n        return res.node\n\n    def success(self, node):\n        self.node = node\n        return self\n\n    def failure(self, error):\n        if not self.error or self.last_registered_advance_count == 0:\n            self.error = error\n        return self", ""]}
{"filename": "Alphassembly/assembler/glang/modules/_parser.py", "chunked_list": ["from .nodes import *\nfrom .errors import *\nfrom .consts import *\nfrom .parse_result import *\n\n\nclass Parser:\n    def __init__(self, tokens):\n        self.current_tok = None\n        self.tokens = tokens\n        self.tok_idx = -1\n        self.advance()\n        self.call_nodes = []\n        self.var_accesses = []\n        self.current_func_name = None\n\n    def advance(self):\n        self.tok_idx += 1\n        if self.tok_idx < len(self.tokens):\n            self.current_tok = self.tokens[self.tok_idx]\n        return self.current_tok\n\n    def reverse(self, amount=1):\n        self.tok_idx -= amount\n        self.update_current_tok()\n        return self.current_tok\n\n    def update_current_tok(self):\n        if self.tok_idx >= 0 and self.tok_idx < len(self.tokens):\n            self.current_tok = self.tokens[self.tok_idx]\n\n    def parse(self):\n        res = self.statements()\n        if not res.error and self.current_tok.type != TT_EOF:\n            return res.failure(InvalidSyntaxError(\n                self.current_tok.pos_start, self.current_tok.pos_end,\n                \"Syntax error\"\n            ))\n\n        return res, self.call_nodes, self.var_accesses\n    \n    def statements(self):\n        res = ParseResult()\n        statements = []\n        pos_start = self.current_tok.pos_start.copy()\n\n        while self.current_tok.type == TT_NEWLINE:\n            res.register_advancement()\n            self.advance()\n\n\n        statement = res.register(self.statement())\n        if res.error: return res\n        statements.append(statement)\n\n        more_statements = True\n\n        while True:\n            newline_count = 0\n            while self.current_tok.type == TT_NEWLINE:\n                res.register_advancement()\n                self.advance()\n                newline_count += 1\n            if newline_count == 0:\n                more_statements = False\n\n            if not more_statements: break\n            statement = res.try_register(self.statement())\n            if not statement:\n                self.reverse(res.to_reverse_count)\n                more_statements = False\n                continue\n            statements.append(statement)\n\n        return res.success(statements)\n    \n    def statement(self):\n        res = ParseResult()\n        pos_start = self.current_tok.pos_start.copy()\n\n        # return, continue break and stuff can be added here\n        if self.current_tok.matches(TT_KEYWORD, 'var'):\n            res.register_advancement()\n            self.advance()\n\n            if self.current_tok.type != TT_IDENTIFIER:\n                return res.failure(InvalidSyntaxError(\n                    self.current_tok.pos_start, self.current_tok.pos_end,\n                    \"Expected identifier\"\n                ))\n            \n            var_name = self.current_tok\n            res.register_advancement()\n            self.advance()\n            expr = None\n\n            if self.current_tok.type == TT_DOT:\n                if self.current_tok.type == TT_DOT:\n                    left = var_name\n                    op_tok = self.current_tok\n                    \n                    res.register_advancement()\n                    self.advance()\n                    right = res.register(self.call())\n                    if res.error: return res\n            \n                    var_name = BinOpNode(StringNode(left), op_tok, right)\n            \n            if self.current_tok.type != TT_EQ:\n                return res.failure(InvalidSyntaxError(\n                    self.current_tok.pos_start, self.current_tok.pos_end,\n                    \"Expected '='\"\n                ))\n\n            res.register_advancement()\n            self.advance()\n            expr = res.register(self.expr())\n            if res.error: return res\n            return res.success(VarAssignNode(var_name, expr))\n        \n        elif self.current_tok.matches(TT_KEYWORD, 'return'):\n            res.register_advancement()\n            self.advance()\n\n            expr = res.try_register(self.expr())\n            if not expr:\n                self.reverse(res.to_reverse_count)\n            \n            return res.success(ReturnNode(expr, pos_start, self.current_tok.pos_start.copy()))\n        \n        elif self.current_tok.matches(TT_KEYWORD, 'class'):\n            res.register_advancement()\n            self.advance()\n            \n            class_name = self.current_tok\n            if not class_name.type == TT_IDENTIFIER:\n                return res.failure(InvalidSyntaxError(\n                    self.current_tok.pos_start, self.current_tok.pos_end,\n                    f\"Expected identifier but got {class_name.type}\"\n                ))\n            \n            res.register_advancement()\n            self.advance()\n            \n            if self.current_tok.type == TT_DCOLON:\n                res.register_advancement()\n                self.advance()\n                \n                if self.current_tok.type != TT_NEWLINE:\n                    return res.failure(InvalidSyntaxError(\n                        self.current_tok.pos_start, self.current_tok.pos_end,\n                        f\"Expected newline but got {self.current_tok.type}\"\n                    ))\n                \n                res.register_advancement()\n                self.advance()\n                \n                properties = [(StringNode(Token(TT_STRING, '.type',\n                                                self.current_tok.pos_start,\n                                                self.current_tok.pos_end)),\n                                                StringNode(Token(TT_STRING, 'object',\n                                                                 self.current_tok.pos_start,\n                                                                 self.current_tok.pos_end)))]\n                \n                methods = []\n                while self.current_tok.type in (TT_IDENTIFIER, TT_KEYWORD):\n                    property_ = self.current_tok\n                    val = None\n                    \n                    if self.current_tok.matches(TT_KEYWORD, 'def'):\n                        methods.append(res.register(self.func_def()))\n                        if res.error: return res\n\n                        if self.current_tok.type != TT_NEWLINE:\n                            return res.failure(InvalidSyntaxError(\n                                self.current_tok.pos_start, self.current_tok.pos_end,\n                                f\"Expected newline but got {self.current_tok}\"\n                            ))\n                        \n                        while self.current_tok.type == TT_NEWLINE:\n                            res.register_advancement()\n                            self.advance()\n                        \n                        continue\n                    elif self.current_tok.matches(TT_KEYWORD, 'end'):\n                        break\n                    elif self.current_tok.type == TT_KEYWORD:\n                        return res.failure(InvalidSyntaxError(\n                            self.current_tok.pos_start, self.current_tok.pos_end,\n                            f\"Expected def or identifier but got {self.current_tok}\"\n                        ))\n                    \n                    res.register_advancement()\n                    self.advance()\n                    \n                    if self.current_tok.type == TT_EQ:\n                        res.register_advancement()\n                        self.advance()\n                        val = res.register(self.expr())\n                        if res.error: return res\n                    \n                    if self.current_tok.type != TT_NEWLINE:\n                        return res.failure(InvalidSyntaxError(\n                            self.current_tok.pos_start, self.current_tok.pos_end,\n                            f\"Expected newline but got {self.current_tok}\"\n                        ))\n                    \n                    while self.current_tok.type == TT_NEWLINE:\n                        res.register_advancement()\n                        self.advance()\n                    \n                    properties.append((StringNode(property_), val))\n                \n                while self.current_tok.type == TT_NEWLINE:\n                    res.register_advancement()\n                    self.advance()\n                \n                if not self.current_tok.matches(TT_KEYWORD, 'end'):\n                    return res.failure(InvalidSyntaxError(\n                        self.current_tok.pos_start, self.current_tok.pos_end,\n                        f\"Expected end but got {self.current_tok}\"\n                    ))\n                    \n                res.register_advancement()\n                self.advance()\n                \n                methods = None if methods == [] else methods\n                \n                return res.success(ClassAssignNode(class_name, \n                                                   ListNode(properties,\n                                                                        pos_start=self.current_tok.pos_start,\n                                                                        pos_end=self.current_tok.pos_end),\n                                                    ListNode(methods,\n                                                                        pos_start=self.current_tok.pos_start,\n                                                                        pos_end=self.current_tok.pos_end)))\n            \n            return res.success(ClassNode(class_name))\n        \n        expr = res.register(self.expr())\n        if res.error:\n            return res.failure(InvalidSyntaxError(\n                self.current_tok.pos_start, self.current_tok.pos_end,\n                \"InvalidSyntaxError\"\n            ))\n\n        return res.success(expr)\n\n    def expr(self):\n        res = ParseResult()\n\n        node = res.register(self.bin_op(self.comp_expr, ((TT_KEYWORD, 'and'), (TT_KEYWORD, 'or'))))\n\n        if res.error:\n            return res.failure(InvalidSyntaxError(\n                self.current_tok.pos_start, self.current_tok.pos_end,\n                \"InvalidSyntaxError\"\n            ))\n\n        return res.success(node)\n\n    def comp_expr(self):\n        res = ParseResult()\n\n        node = res.register(self.bin_op(self.arith_expr, (TT_EE, TT_NE, TT_LT, TT_GT, TT_LTE, TT_GTE)))\n\n        if res.error:\n            return res.failure(InvalidSyntaxError(\n                self.current_tok.pos_start, self.current_tok.pos_end,\n                \"InvalidSyntaxError\"\n            ))\n\n        return res.success(node)\n\n    def arith_expr(self):\n        return self.bin_op(self.term, (TT_PLUS, TT_MINUS))\n\n    def term(self):\n        return self.bin_op(self.factor, (TT_MUL, TT_DIV))\n\n    def factor(self):\n        res = ParseResult()\n        tok = self.current_tok\n\n        if tok.type in (TT_PLUS, TT_MINUS, TT_MUL):\n            res.register_advancement()\n            self.advance()\n            factor = res.register(self.factor())\n            if res.error: return res\n            return res.success(UnaryOpNode(tok, factor))\n\n        return self.power()\n    \n    # only added because is a requirement\n    # TODO: Add functions\n    def call(self):\n        res = ParseResult()\n        atom = res.register(self.atom())\n        if res.error: return res\n\n        if self.current_tok.type == TT_LPAREN:\n            res.register_advancement()\n            self.advance()\n            arg_nodes = []\n\n            if self.current_tok.type == TT_RPAREN:\n                res.register_advancement()\n                self.advance()\n            else:\n                arg_nodes.append(res.register(self.expr()))\n                if res.error:\n                    return res.failure(InvalidSyntaxError(\n                        self.current_tok.pos_start, self.current_tok.pos_end,\n                        \"InvalidSyntaxError\"\n                    ))\n\n                while self.current_tok.type == TT_COMMA:\n                    res.register_advancement()\n                    self.advance()\n\n                    arg_nodes.append(res.register(self.expr()))\n                    if res.error: return res\n\n                if self.current_tok.type != TT_RPAREN:\n                    return res.failure(InvalidSyntaxError(\n                        self.current_tok.pos_start, self.current_tok.pos_end,\n                        f\"Expected ',' or ')'\"\n                    ))\n\n                res.register_advancement()\n                self.advance()\n            node = CallNode(atom, arg_nodes)\n            self.call_nodes.append(node.node_to_call.var_name_tok.value)\\\n                if not node.node_to_call.var_name_tok.value in self.call_nodes else None in self.call_nodes\n            return res.success(node)\n        elif self.current_tok.type == TT_DOT:\n            left = atom\n            op_tok = self.current_tok\n            \n            res.register_advancement()\n            self.advance()\n            right = res.register(self.call())\n            if res.error: return res\n            \n            return res.success(BinOpNode(left, op_tok, right))\n        \n        return res.success(atom)\n\n    def power(self):\n        return self.bin_op(self.call, (TT_POW, TT_MOD), self.factor)\n\n    def atom(self):\n        res = ParseResult()\n        tok = self.current_tok\n        pos_start = self.current_tok.pos_start.copy()\n\n        if tok.type == TT_INT:\n            res.register_advancement()\n            self.advance()\n            return res.success(IntegerNode(tok))\n        \n        elif tok.type == TT_FLOAT:\n            res.register_advancement()\n            self.advance()\n            return res.success(FloatNode(tok))\n\n        elif tok.type == TT_STRING:\n            res.register_advancement()\n            self.advance()\n            return res.success(StringNode(tok))\n\n        elif tok.type == TT_IDENTIFIER:\n            res.register_advancement()\n            self.advance()\n            self.var_accesses.append(tok.value)\n            return res.success(VarAccessNode(tok))\n\n        elif tok.type == TT_LPAREN:\n            res.register_advancement()\n            self.advance()\n            expr = res.register(self.expr())\n            if res.error: return res\n            if self.current_tok.type == TT_RPAREN:\n                res.register_advancement()\n                self.advance()\n                return res.success(expr)\n            else:\n                return res.failure(InvalidSyntaxError(\n                    self.current_tok.pos_start, self.current_tok.pos_end,\n                    \"Expected ')'\"\n                ))\n\n        elif tok.type == TT_LSQUARE:\n            list_expr = res.register(self.list_expr())\n            if res.error: return res\n            return res.success(list_expr)\n\n        elif tok.matches(TT_KEYWORD, 'if'):\n            if_expr = res.register(self.if_expr())\n            if res.error: return res\n            return res.success(if_expr)\n\n        elif tok.matches(TT_KEYWORD, 'for'):\n            for_expr = res.register(self.for_expr())\n            if res.error: return res\n            return res.success(for_expr)\n        \n        elif self.current_tok.matches(TT_KEYWORD, 'continue'):\n            res.register_advancement()\n            self.advance()\n            return res.success(ContinueNode(pos_start, self.current_tok.pos_start.copy()))\n        \n        elif self.current_tok.matches(TT_KEYWORD, 'break'):\n            res.register_advancement()\n            self.advance()\n            return res.success(BreakNode(pos_start, self.current_tok.pos_start.copy()))\n        \n        elif tok.matches(TT_KEYWORD, 'while'):\n            while_expr = res.register(self.while_expr())\n            if res.error: return res\n            return res.success(while_expr)\n        \n        elif tok.matches(TT_KEYWORD, 'def'):\n            func_def = res.register(self.func_def())\n            if res.error: return res\n            return res.success(func_def)\n        \n        elif tok.matches(TT_KEYWORD, 'class'):\n            class_node = res.register(self.statement())\n            if res.error: return res\n            return res.success(class_node)\n\n        return res.failure(InvalidSyntaxError(\n            tok.pos_start, tok.pos_end,\n            \"InvalidSyntaxError\"\n        ))\n\n    def list_expr(self):\n        res = ParseResult()\n        elements_nodes = []\n        pos_start = self.current_tok.pos_start.copy()\n\n        if self.current_tok.type != TT_LSQUARE:\n            return res.failure(InvalidSyntaxError(\n                self.current_tok.pos_start, self.current_tok.pos_end,\n                f\"Expected '['\"\n            ))\n\n        res.register_advancement()\n        self.advance()\n\n        if self.current_tok.type == TT_RSQUARE:\n            res.register_advancement()\n            self.advance()\n        else:\n            elements_nodes.append(res.register(self.expr()))\n            if res.error:\n                return res.failure(InvalidSyntaxError(\n                    self.current_tok.pos_start, self.current_tok.pos_end,\n                    \"Unexpected token\"\n                ))\n\n            while self.current_tok.type == TT_COMMA:\n                res.register_advancement()\n                self.advance()\n\n                elements_nodes.append(res.register(self.expr()))\n                if res.error: return res\n\n            if self.current_tok.type != TT_RSQUARE:\n                return res.failure(InvalidSyntaxError(\n                    self.current_tok.pos_start, self.current_tok.pos_end,\n                    f\"Expected ',' or ']'\"\n                ))\n\n            res.register_advancement()\n            self.advance()\n\n        return res.success(ListNode(\n            elements_nodes,\n            pos_start,\n            self.current_tok.pos_end.copy()\n        ))\n\n    def if_expr(self):\n        res = ParseResult()\n        all_cases = res.register(self.if_expr_cases('if'))\n        if res.error: return res\n        cases, else_case = all_cases\n        return res.success(IfNode(cases, else_case))\n\n    def if_expr_b(self):\n        return self.if_expr_cases('elif')\n\n    def if_expr_c(self):\n        res = ParseResult()\n        else_case = None\n\n        if self.current_tok.matches(TT_KEYWORD, 'else'):\n            res.register_advancement()\n            self.advance()\n\n            if self.current_tok.type != TT_DCOLON:\n                return res.failure(InvalidSyntaxError(\n                        self.current_tok.pos_start, self.current_tok.pos_end,\n                        \"Expected ':'\"\n                    ))\n            \n            res.register_advancement()\n            self.advance()\n\n            if self.current_tok.type == TT_NEWLINE:\n                res.register_advancement()\n                self.advance()\n\n                statements = res.register(self.statements())\n                if res.error: return res\n                else_case = (statements, True)\n\n                if self.current_tok.matches(TT_KEYWORD, 'end'):\n                    res.register_advancement()\n                    self.advance()\n                else:\n                    return res.failure(InvalidSyntaxError(\n                        self.current_tok.pos_start, self.current_tok.pos_end,\n                        \"Expected 'end'\"\n                    ))\n            else:\n                expr = res.register(self.statement())\n                if res.error: return res\n                else_case = (expr, False)\n\n        return res.success(else_case)\n\n    def if_expr_b_or_c(self):\n        res = ParseResult()\n        cases, else_case = [], None\n\n        if self.current_tok.matches(TT_KEYWORD, 'elif'):\n            all_cases = res.register(self.if_expr_b())\n            if res.error: return res\n            cases, else_case = all_cases\n        else:\n            else_case = res.register(self.if_expr_c())\n            if res.error: return res\n\n        return res.success((cases, else_case))\n\n    def if_expr_cases(self, case_keyword):\n        res = ParseResult()\n        cases = []\n        else_case = None\n\n        if not self.current_tok.matches(TT_KEYWORD, case_keyword):\n            return res.failure(InvalidSyntaxError(\n                self.current_tok.pos_start, self.current_tok.pos_end,\n                f\"Expected '{case_keyword}'\"\n            ))\n\n        res.register_advancement()\n        self.advance()\n\n        condition = res.register(self.statement())\n        if res.error: return res\n        \n        if not self.current_tok.type == TT_DCOLON:\n            return res.failure(InvalidSyntaxError(\n                self.current_tok.pos_start, self.current_tok.pos_end,\n                f\"Expected ':'\"\n            ))\n        \n        res.register_advancement()\n        self.advance()\n\n        if self.current_tok.type == TT_NEWLINE:\n            res.register_advancement()\n            self.advance()\n\n            statements = res.register(self.statements())\n            if res.error: return res\n            cases.append((condition, statements, True))\n\n            if self.current_tok.matches(TT_KEYWORD, 'end'):\n                res.register_advancement()\n                self.advance()\n            else:\n                all_cases = res.register(self.if_expr_b_or_c())\n                if res.error: return res\n                new_cases, else_case = all_cases\n                cases.extend(new_cases)\n        else:\n            expr = res.register(self.statement())\n            if res.error: return res\n            cases.append((condition, expr, False))\n\n            all_cases = res.register(self.if_expr_b_or_c())\n            if res.error: return res\n            new_cases, else_case = all_cases\n            cases.extend(new_cases)\n        return res.success((cases, else_case))\n    \n    def for_expr(self):\n        res = ParseResult()\n\n        if not self.current_tok.matches(TT_KEYWORD, 'for'):\n            return res.failure(InvalidSyntaxError(\n                self.current_tok.pos_start, self.current_tok.pos_end,\n                f\"Expected 'for'\"\n            ))\n\n        res.register_advancement()\n        self.advance()\n\n        if self.current_tok.type != TT_IDENTIFIER:\n            return res.failure(InvalidSyntaxError(\n                self.current_tok.pos_start, self.current_tok.pos_end,\n                f\"Expected identifier\"\n            ))\n\n        var_name = self.current_tok\n        res.register_advancement()\n        self.advance()\n\n        if self.current_tok.type != TT_EQ:\n            return res.failure(InvalidSyntaxError(\n                self.current_tok.pos_start, self.current_tok.pos_end,\n                f\"Expected '='\"\n            ))\n\n        res.register_advancement()\n        self.advance()\n\n        start_value = res.register(self.expr())\n        if res.error: return res\n\n        if not self.current_tok.matches(TT_KEYWORD, 'to'):\n            return res.failure(InvalidSyntaxError(\n                self.current_tok.pos_start, self.current_tok.pos_end,\n                f\"Expected 'to'\"\n            ))\n\n        res.register_advancement()\n        self.advance()\n\n        end_value = res.register(self.expr())\n        if res.error: return res\n        \n        if self.current_tok.matches(TT_KEYWORD, 'step'):\n            res.register_advancement()\n            self.advance()\n\n            step_value = res.register(self.expr())\n            if res.error: return res\n        else:\n            step_value = None\n\n        if not self.current_tok.type == TT_DCOLON:\n            return res.failure(InvalidSyntaxError(\n                self.current_tok.pos_start, self.current_tok.pos_end,\n                f\"Expected ':'\"\n            ))\n\n        res.register_advancement()\n        self.advance()\n\n        if self.current_tok.type == TT_NEWLINE:\n            res.register_advancement()\n            self.advance()\n\n            body = res.register(self.statements())\n            if res.error: return res\n\n            if not self.current_tok.matches(TT_KEYWORD, 'end'):\n                return res.failure(InvalidSyntaxError(\n                    self.current_tok.pos_start, self.current_tok.pos_end,\n                    f\"Expected 'end'\"\n                ))\n\n            res.register_advancement()\n            self.advance()\n\n            return res.success(ForNode(var_name, start_value, end_value, step_value, body, True))\n\n        body = res.register(self.statement())\n        if res.error: return res\n\n        return res.success(ForNode(var_name, start_value, end_value, step_value, body, False))\n        \n    ################################\n    \n    def bin_op(self, func_a, ops, func_b=None):\n        if func_b == None:\n            func_b = func_a\n\n        res = ParseResult()\n        left = res.register(func_a())\n        if res.error: return res\n\n        while self.current_tok.type in ops or (self.current_tok.type, self.current_tok.value) in ops:\n            op_tok = self.current_tok\n            res.register_advancement()\n            self.advance()\n            right = res.register(func_b())\n            if res.error: return res\n            left = BinOpNode(left, op_tok, right)\n\n        return res.success(left)\n    \n    def while_expr(self):\n        res = ParseResult()\n\n        if not self.current_tok.matches(TT_KEYWORD, 'while'):\n            return res.failure(InvalidSyntaxError(\n                self.current_tok.pos_start, self.current_tok.pos_end,\n                f\"Expected 'while'\"\n            ))\n\n        res.register_advancement()\n        self.advance()\n\n        condition = res.register(self.expr())\n        if res.error: return res\n\n        if not self.current_tok.type == TT_DCOLON:\n            return res.failure(InvalidSyntaxError(\n                self.current_tok.pos_start, self.current_tok.pos_end,\n                f\"Expected ':'\"\n            ))\n\n        res.register_advancement()\n        self.advance()\n\n        if self.current_tok.type == TT_NEWLINE:\n            res.register_advancement()\n            self.advance()\n\n            body = res.register(self.statements())\n            if res.error: return res\n\n            if not self.current_tok.matches(TT_KEYWORD, 'end'):\n                return res.failure(InvalidSyntaxError(\n                    self.current_tok.pos_start, self.current_tok.pos_end,\n                    f\"Expected 'end'\"\n                ))\n\n            res.register_advancement()\n            self.advance()\n\n            return res.success(WhileNode(condition, body, True))\n\n        body = res.register(self.statement())\n        if res.error: return res\n\n        return res.success(WhileNode(condition, body, False))\n\n    def func_def(self):\n        res = ParseResult()\n        \n        res.register_advancement()\n        self.advance()\n\n        func_name = self.current_tok\n        self.current_func_name = func_name.value\n        res.register_advancement()\n        self.advance()\n        \n        if self.current_tok.type != TT_LPAREN:\n            return res.failure(InvalidSyntaxError(\n                self.current_tok.pos_start, self.current_tok.pos_end,\n                \"Expected '('\"\n            ))\n        \n        res.register_advancement()\n        self.advance()\n        \n        arg_name_toks = []\n        \n        if self.current_tok.type == TT_IDENTIFIER:\n            arg_name_toks.append(self.current_tok)\n            res.register_advancement()\n            self.advance()\n\n            while self.current_tok.type == TT_COMMA:\n                res.register_advancement()\n                self.advance()\n\n                if self.current_tok.type != TT_IDENTIFIER:\n                    return res.failure(InvalidSyntaxError(\n                        self.current_tok.pos_start, self.current_tok.pos_end,\n                        \"Expected argument name\"\n                    ))\n\n                arg_name_toks.append(self.current_tok)\n                res.register_advancement()\n                self.advance()\n\n            if self.current_tok.type != TT_RPAREN:\n                return res.failure(InvalidSyntaxError(\n                    self.current_tok.pos_start, self.current_tok.pos_end,\n                    f\"Expected ',' or ')'\"\n                ))\n        else:\n            if self.current_tok.type != TT_RPAREN:\n                return res.failure(InvalidSyntaxError(\n                    self.current_tok.pos_start, self.current_tok.pos_end,\n                    \"Expected identifier or ')'\"\n                ))\n\n        res.register_advancement()\n        self.advance()\n\n        if self.current_tok.type != TT_DCOLON:\n            return res.failure(InvalidSyntaxError(\n                self.current_tok.pos_start, self.current_tok.pos_end,\n                f\"Expected ':'\"\n            ))\n\n        res.register_advancement()\n        self.advance()\n\n        if self.current_tok.type != TT_NEWLINE:\n            return res.failure(InvalidSyntaxError(\n                self.current_tok.pos_start, self.current_tok.pos_end,\n                f\"Expected NEWLINE\"\n            ))\n\n        res.register_advancement()\n        self.advance()\n\n        body = res.register(self.statements())\n        if res.error: return res\n\n        if not self.current_tok.matches(TT_KEYWORD, 'end'):\n            return res.failure(InvalidSyntaxError(\n                self.current_tok.pos_start, self.current_tok.pos_end,\n                f\"Expected 'end'\"\n            ))\n\n        res.register_advancement()\n        self.advance()\n\n        return res.success(FuncDefNode(\n            func_name,\n            arg_name_toks,\n            body,\n            False\n        ))", "    "]}
{"filename": "Alphassembly/assembler/glang/modules/strings_with_arrows.py", "chunked_list": ["def string_with_arrows(text, pos_start, pos_end):\n    result = ''\n\n    # Calculate indices\n    idx_start = max(text.rfind('\\n', 0, pos_start.idx), 0)\n    idx_end = text.find('\\n', idx_start + 1)\n    if idx_end < 0: idx_end = len(text)\n\n    # Generate each line\n    line_count = pos_end.ln - pos_start.ln + 1\n    for i in range(line_count):\n        # Calculate line columns\n        line = text[idx_start:idx_end]\n        col_start = pos_start.col if i == 0 else 0\n        col_end = pos_end.col if i == line_count - 1 else len(line) - 1\n\n        # Append to result\n        result += line + '\\n'\n        result += ' ' * col_start + '^' * (col_end - col_start)\n\n        # Re-calculate indices\n        idx_start = idx_end\n        idx_end = text.find('\\n', idx_start + 1)\n        if idx_end < 0: idx_end = len(text)\n\n    return result.replace('\\t', '')"]}
{"filename": "Alphassembly/assembler/glang/modules/ctresult.py", "chunked_list": ["class CTResult:\n    def __init__(self):\n        self.reset()\n\n    def reset(self):\n        self.value = None\n        self.error = None\n        self.func_return_value = None\n        self.loop_should_continue = False\n        self.loop_should_break = False\n\n    def register(self, res):\n        self.error = res.error\n        self.func_return_value = res.func_return_value\n        self.loop_should_continue = res.loop_should_continue\n        self.loop_should_break = res.loop_should_break\n        if res.value is None: res.value = \"\"\n        return res.value\n\n    def success(self, value):\n        self.reset()\n        self.value = value\n        return self\n\n    def success_return(self, value):\n        self.reset()\n        self.func_return_value = value\n        return self\n    \n    def success_continue(self):\n        self.reset()\n        self.loop_should_continue = True\n        return self\n\n    def success_break(self):\n        self.reset()\n        self.loop_should_break = True\n        return self\n\n    def failure(self, error):\n        self.reset()\n        self.error = error\n        return self\n\n    def should_return(self):\n        # Note: this will allow you to continue and break outside the current function\n        return (\n            self.error\n        )"]}
{"filename": "Alphassembly/assembler/glang/modules/builtins.py", "chunked_list": ["from .builtin_function import *\nBuiltinFunction.print = BuiltinFunction(\"print\")\nBuiltinFunction.exit = BuiltinFunction(\"exit\")\nBuiltinFunction.asm = BuiltinFunction(\"asm\")\nBuiltinFunction.ref = BuiltinFunction(\"ref\")\n# add argc and argv functions\n\nBUILTINS = {\n    \"print\": BuiltinFunction.print,\n    \"exit\": BuiltinFunction.exit,", "    \"print\": BuiltinFunction.print,\n    \"exit\": BuiltinFunction.exit,\n    \"asm\": BuiltinFunction.asm,\n    \"ref\": BuiltinFunction.ref,\n    'new': None # done in codegen\n}"]}
{"filename": "Alphassembly/assembler/glang/modules/position.py", "chunked_list": ["class Position:\n    def __init__(self, idx, ln, col, fn, ftxt):\n        self.idx = idx\n        self.ln = ln\n        self.col = col\n        self.fn = fn\n        self.ftxt = ftxt\n\n    def advance(self, current_char=None):\n        self.idx += 1\n        self.col += 1\n\n        if current_char == '\\n':\n            self.ln += 1\n            self.col = 0\n\n        return self\n\n    def copy(self):\n        return Position(self.idx, self.ln, self.col, self.fn, self.ftxt)", ""]}
{"filename": "Alphassembly/assembler/glang/modules/nodes.py", "chunked_list": ["from .consts import *\nfrom .lexer import *\n\nclass IntegerNode:\n    def __init__(self, tok):\n        self.tok = tok\n\n        self.pos_start = self.tok.pos_start\n        self.pos_end = self.tok.pos_end\n\n    def __repr__(self):\n        return f'{self.tok}'", "\n\nclass StringNode:\n    def __init__(self, tok):\n        self.tok = tok\n\n        self.pos_start = self.tok.pos_start\n        self.pos_end = self.tok.pos_end\n\n    def __repr__(self):\n        return f'{self.tok}'", "\n\nclass FloatNode:\n    def __init__(self, tok):\n        self.tok = tok\n\n        self.pos_start = self.tok.pos_start\n        self.pos_end = self.tok.pos_end\n\n    def __repr__(self):\n        return f'{self.tok}'", "\n\nclass ListNode:\n    def __init__(self, element_nodes, pos_start, pos_end):\n        self.element_nodes = element_nodes\n\n        self.pos_start = pos_start\n        self.pos_end = pos_end\n\n\nclass VarAccessNode:\n    def __init__(self, var_name_tok):\n        self.var_name_tok = var_name_tok\n\n        self.pos_start = self.var_name_tok.pos_start\n        self.pos_end = self.var_name_tok.pos_end", "\n\nclass VarAccessNode:\n    def __init__(self, var_name_tok):\n        self.var_name_tok = var_name_tok\n\n        self.pos_start = self.var_name_tok.pos_start\n        self.pos_end = self.var_name_tok.pos_end\n\n\nclass VarAssignNode:\n    def __init__(self, var_name_tok, value_node):\n        self.var_name_tok = var_name_tok\n        self.value_node = value_node\n\n        self.pos_start = self.var_name_tok.pos_start\n        self.pos_end = self.value_node.pos_end", "\n\nclass VarAssignNode:\n    def __init__(self, var_name_tok, value_node):\n        self.var_name_tok = var_name_tok\n        self.value_node = value_node\n\n        self.pos_start = self.var_name_tok.pos_start\n        self.pos_end = self.value_node.pos_end\n", "\n\nclass BinOpNode:\n    def __init__(self, left_node, op_tok, right_node):\n        self.left_node = left_node\n        self.op_tok = op_tok\n        self.right_node = right_node\n\n        self.pos_start = self.left_node.pos_start\n        self.pos_end = self.right_node.pos_end\n\n    def __repr__(self):\n        return f'({self.left_node}, {self.op_tok}, {self.right_node})'\n\n    def remove_last_node(self):\n        if not isinstance(self.right_node, BinOpNode):\n            # if the right node is not a BinOpNode, then it is the last node\n            return self.left_node, None\n\n        # recursively remove the last node from the right subtree\n        new_right_node, op_tok = self.right_node.remove_last_node()\n\n        # create a new BinOpNode with the updated right subtree\n        new_node = BinOpNode(self.left_node, self.op_tok, new_right_node)\n\n        return new_node, op_tok", "\n\nclass UnaryOpNode:\n    def __init__(self, op_tok, node):\n        self.op_tok = op_tok\n        self.node = node\n\n        self.pos_start = self.op_tok.pos_start\n        self.pos_end = node.pos_end\n\n        def __repr__(self):\n            return f'({self.op_tok}, {self.node})'", "\n\nclass IfNode:\n    def __init__(self, cases, else_case):\n        self.cases = cases\n        self.else_case = else_case\n\n        self.pos_start = self.cases[0][0].pos_start\n        if type((self.else_case or self.cases[len(self.cases) - 1])[0]) is not list:\n            self.pos_end = (self.else_case or self.cases[len(self.cases) - 1])[0].pos_end\n        else:\n            self.pos_end = (self.else_case or self.cases[len(self.cases) - 1])[0][-1].pos_end", "\n\nclass CallNode:\n    def __init__(self, node_to_call, arg_nodes):\n        self.node_to_call = node_to_call\n        self.arg_nodes = arg_nodes\n\n        self.pos_start = self.node_to_call.pos_start\n\n        if len(self.arg_nodes) > 0:\n            self.pos_end = self.arg_nodes[len(self.arg_nodes) - 1].pos_end\n        else:\n            self.pos_end = self.node_to_call.pos_end", "\n\nclass ForNode:\n    def __init__(self, var_name_tok, start_value_node, end_value_node, step_value_node, body_node, should_return_null):\n        self.var_name_tok = var_name_tok\n        self.start_value_node = start_value_node\n        self.end_value_node = end_value_node\n        self.step_value_node = step_value_node\n        self.body_node = body_node\n        self.should_return_null = should_return_null\n\n        self.pos_start = self.var_name_tok.pos_start\n        self.pos_end = self.body_node[-1].pos_end", "\n\nclass ContinueNode:\n    def __init__(self, pos_start, pos_end):\n        self.pos_start = pos_start\n        self.pos_end = pos_end\n\n\nclass BreakNode:\n    def __init__(self, pos_start, pos_end):\n        self.pos_start = pos_start\n        self.pos_end = pos_end", "class BreakNode:\n    def __init__(self, pos_start, pos_end):\n        self.pos_start = pos_start\n        self.pos_end = pos_end\n\n\nclass WhileNode:\n    def __init__(self, condition_node, body_node, should_return_null):\n        self.condition_node = condition_node\n        self.body_node = body_node\n        self.should_return_null = should_return_null\n\n        self.pos_start = self.condition_node.pos_start\n        self.pos_end = self.body_node[-1].pos_end", "\n\nclass ReturnNode:\n    def __init__(self, node_to_return, pos_start, pos_end):\n        self.node_to_return = node_to_return\n\n        self.pos_start = pos_start\n        self.pos_end = pos_end\n\n\nclass FuncDefNode:\n    def __init__(self, func_name_tok, arg_name_toks, body_node, should_auto_return):\n        self.func_name_tok = func_name_tok\n        self.arg_name_toks = arg_name_toks\n        self.body_node = body_node\n        self.should_auto_return = should_auto_return\n\n        if self.func_name_tok:\n            self.pos_start = self.func_name_tok.pos_start\n        elif len(self.arg_name_toks) > 0:\n            self.pos_start = self.arg_name_toks[0].pos_start\n        else:\n            self.pos_start = self.body_node.pos_start\n\n        self.pos_end = self.body_node[-1].pos_end", "\n\nclass FuncDefNode:\n    def __init__(self, func_name_tok, arg_name_toks, body_node, should_auto_return):\n        self.func_name_tok = func_name_tok\n        self.arg_name_toks = arg_name_toks\n        self.body_node = body_node\n        self.should_auto_return = should_auto_return\n\n        if self.func_name_tok:\n            self.pos_start = self.func_name_tok.pos_start\n        elif len(self.arg_name_toks) > 0:\n            self.pos_start = self.arg_name_toks[0].pos_start\n        else:\n            self.pos_start = self.body_node.pos_start\n\n        self.pos_end = self.body_node[-1].pos_end", "\n\nclass UnaryOpNode:\n    def __init__(self, op_tok, node):\n        self.op_tok = op_tok\n        self.node = node\n\n        self.pos_start = self.op_tok.pos_start\n        self.pos_end = node.pos_end\n\n        def __repr__(self):\n            return f'({self.op_tok}, {self.node})'", "\n\nclass ClassNode:\n    def __init__(self, var_name_tok):\n        self.var_name_tok = var_name_tok\n        \n        self.pos_start = self.var_name_tok.pos_start\n        self.pos_end = self.pos_start\n\nclass ClassAssignNode:\n    def __init__(self, var_name_tok, properties, methods=None):\n        self.var_name_tok = var_name_tok\n        self.value_node = properties\n        self.methods = methods \n\n        self.pos_start = self.var_name_tok.pos_start\n        self.pos_end = self.value_node.pos_end", "\nclass ClassAssignNode:\n    def __init__(self, var_name_tok, properties, methods=None):\n        self.var_name_tok = var_name_tok\n        self.value_node = properties\n        self.methods = methods \n\n        self.pos_start = self.var_name_tok.pos_start\n        self.pos_end = self.value_node.pos_end\n", "\n"]}
