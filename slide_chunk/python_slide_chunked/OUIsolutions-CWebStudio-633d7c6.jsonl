{"filename": "build.py", "chunked_list": ["\n\nimport Build.CToolKit as ct \nfrom Build.copile_all_exemples import copile_all_exemples\nfrom Build.full_folder_zip import zip_folder\n\nfrom os import remove\nSTARTER  = f'CWebStudio/CwebStudioMain.h'\nct.generate_amalgamated_code(STARTER,'CWebStudio_test.h')\ncopile_all_exemples('examples')", "ct.generate_amalgamated_code(STARTER,'CWebStudio_test.h')\ncopile_all_exemples('examples')\nremove('CWebStudio_test.h')\n\ndef modifier(text:str):\n    return text.replace('../CWebStudio_test.h','CWebStudio.h')\n\nct.include_code_in_markdown('README.md',True,modifier)\n\nct.generate_amalgamated_code(STARTER,'CWebStudio.h')", "\nct.generate_amalgamated_code(STARTER,'CWebStudio.h')\nzip_folder('CWebStudio')\n"]}
{"filename": "Build/copile_all_exemples.py", "chunked_list": ["\nfrom .CToolKit import compile_project\nfrom os import listdir,remove\nfrom os.path import  isdir\nfrom os import remove\n\n\n\ndef copile_all_exemples(folder:str):\n    print(f'folder: {folder}')\n    elements = listdir(folder)\n\n    for file in elements:\n        filepath = f'{folder}/{file}'\n        if isdir(filepath):\n            copile_all_exemples(filepath)\n        \n        try:\n            output =   compile_project(filepath)\n            remove(output)\n            print(f'\\tpassed:{filepath}')\n\n        except Exception as e:\n            try:\n                remove(output)\n            except:pass \n            print(f'\\tfaluired:{filepath}')\n            raise e ", "def copile_all_exemples(folder:str):\n    print(f'folder: {folder}')\n    elements = listdir(folder)\n\n    for file in elements:\n        filepath = f'{folder}/{file}'\n        if isdir(filepath):\n            copile_all_exemples(filepath)\n        \n        try:\n            output =   compile_project(filepath)\n            remove(output)\n            print(f'\\tpassed:{filepath}')\n\n        except Exception as e:\n            try:\n                remove(output)\n            except:pass \n            print(f'\\tfaluired:{filepath}')\n            raise e "]}
{"filename": "Build/full_folder_zip.py", "chunked_list": ["from os.path import isdir\nfrom os import listdir\nfrom os import getcwd\nfrom os import makedirs\nfrom shutil import rmtree,make_archive\nimport zipfile\n\ndef create_full_folder_cleared(folder:str,dest:str,zip_name:str):    \n    content = listdir(folder)\n    for c in content:\n        path = f'{folder}/{c}'\n        path = path.replace(getcwd() + '/','')\n        if c == dest:\n            continue\n        \n        if c == zip_name + '.zip':\n            continue\n\n        if c.startswith('.'):\n            continue\n        \n        if c.endswith('.pyc'):\n            continue\n\n        if c.startswith('__pycache__'):\n            continue\n\n        if c == 'main.c':\n            continue\n\n        if c.endswith('.out'):\n            continue\n        \n    \n        \n        if isdir(path):\n            makedirs(f'{dest}/{path}')\n            create_full_folder_cleared(path,dest,zip_name)\n        else:\n            \n            with open(path,'rb' ) as arq:\n                content = arq.read()\n            \n            with open(f'{dest}/{path}','wb') as arq:\n                arq.write(content)", "            \n\ndef zip_folder(zip_name:str):\n    out_name = 'out_folder'\n    \n    rmtree(out_name,ignore_errors=True)\n    makedirs(out_name)\n    create_full_folder_cleared(getcwd(),out_name,zip_name)\n    make_archive(zip_name,'zip',out_name)"]}
{"filename": "Build/CToolKit/ComandLineExecution.py", "chunked_list": ["from .Errors.ExecutionError import ExecutionError\nimport subprocess\n\n\nclass ComandLineExecution:\n    def __init__(self, command: str):\n        \"\"\"Execute the given comands\n        Args:\n            command (str):the comand to execute\n        Raises:\n            ExecutionError: if happen some execution error\n        \"\"\"\n        self.status_code, self.output = subprocess.getstatusoutput(command)\n\n        if self.status_code != 0:\n            raise ExecutionError(self.output, self.status_code)", ""]}
{"filename": "Build/CToolKit/amalgamation.py", "chunked_list": ["from os.path import join\n\ndef get_action(referencer_dir: str, line: str) -> str or None:\n    line = line.strip()\n    if not line.startswith('#include'):\n        return None\n\n    if '\"' in line:\n        relative_file = line.split('\"')[1]\n        return join(referencer_dir, relative_file)", "\n\n\ndef generate_amalgamated_code(starter: str,output:str=None) -> str:\n    \"\"\"generate an full amalgamated code of the code you pass\n    Args:\n        starter (str): the started path of your code ex:'test.h'\n        output (str): the output you want to save, if its None it will not save nothing\n    Raises:\n        FileNotFoundError: if some file were not found\n\n    Returns:\n        str: The full amalgamated code\n    \"\"\"\n    current_text = ''\n    try:\n        with open(starter) as f:\n            # get current dir name\n            current_dir = '/'.join(starter.split('/')[:-1])\n            lines = f.readlines()\n            for line in lines:\n                ##trim line\n                file_to_include = get_action(current_dir, line)\n                if file_to_include == None:\n                    current_text += line\n                    continue\n\n                else:\n                    current_text += generate_amalgamated_code(file_to_include)\n\n    except FileNotFoundError:\n        raise FileNotFoundError(f'FileNotFoundError: {starter}')\n\n    if output:\n        with open(output,'w') as arq:\n            arq.write(current_text)\n    return '\\n' + current_text +'\\n'", ""]}
{"filename": "Build/CToolKit/valgrind_parser.py", "chunked_list": ["\n\ndef convert_num(num:str)->str:\n    return int(num.replace(',',''))\n\n\n\n\n\ndef parse_block_line_based_on_key(text:str,key:str)->dict:\n    if key not in text:\n        return {'bytes':0,'blocks':0}\n    \n    target = text.split(key)[1]\n    elements = target.split(' ')\n\n    return {\n        'bytes':convert_num(elements[1]),\n        'blocks':convert_num(elements[4])\n    }", "\ndef parse_block_line_based_on_key(text:str,key:str)->dict:\n    if key not in text:\n        return {'bytes':0,'blocks':0}\n    \n    target = text.split(key)[1]\n    elements = target.split(' ')\n\n    return {\n        'bytes':convert_num(elements[1]),\n        'blocks':convert_num(elements[4])\n    }", "\n\ndef extract_output(text:str):\n    target = text.split('Command:')[1]\n    return target.split('==')[2]\n\n    \ndef parse_heap_usage(text:str)->dict:\n    target = text.split('total heap usage')[1]\n    positions = target.split(' ')\n    return {\n        'allocs':convert_num(positions[1]),\n        'frees':convert_num(positions[3]),\n        'bytes allocated': convert_num(positions[5])\n    }", "    \n    \ndef parse_valgrind_result(text:str)->dict:\n    \n    result  = {\n        'output': extract_output(text),\n        'in use at exit':parse_block_line_based_on_key(text,'in use at exit:'),\n        'definitely lost':parse_block_line_based_on_key(text,'definitely lost:'),\n        'indirectly lost':parse_block_line_based_on_key(text,'indirectly lost:'),\n        'possibly lost':parse_block_line_based_on_key(text,'possibly lost:'),\n        'still reachable':parse_block_line_based_on_key(text,'still reachable:'),\n        'suppressed':parse_block_line_based_on_key(text,' suppressed:'),\n        'heap usage': parse_heap_usage(text)\n    }\n    \n    return result", "\n    "]}
{"filename": "Build/CToolKit/__init__.py", "chunked_list": ["\nfrom .amalgamation import  generate_amalgamated_code\nfrom .ComandLineExecution import ComandLineExecution\nfrom .comand_line_functions import compile_project_by_command\nfrom .comand_line_functions import compile_project\nfrom .comand_line_functions import test_binary_with_valgrind\nfrom .comand_line_functions import execute_test_for_file\nfrom .FolderTestPreset.FolderTestPreset import FolderTestPreset\n\nfrom .Errors.CopilationError import CopilationError", "\nfrom .Errors.CopilationError import CopilationError\nfrom .Errors.CopilationWarning import CopilationWarning\nfrom .Errors.ExecutionError import ExecutionError\nfrom .Errors.ValgrindError import ValgrindError\nfrom .Errors.ValgrindLeak import ValgrindLeak\nfrom .Errors.NotExpectedResult import NotExpectedResult\n\nfrom .readme_converter import include_code_in_markdown", "from .readme_converter import include_code_in_markdown"]}
{"filename": "Build/CToolKit/comand_line_functions.py", "chunked_list": ["from typing import List\nfrom platform import system as current_os\nfrom os import remove\nfrom .Errors.CopilationError import CopilationError\nfrom .Errors.CopilationWarning import CopilationWarning\n\nfrom .Errors.ValgrindError import  ValgrindError\nfrom .Errors.ValgrindLeak import  ValgrindLeak\n\n", "\n\nfrom .ComandLineExecution import ComandLineExecution\nfrom .valgrind_parser import parse_valgrind_result\n\n\n\n\ndef compile_project_by_command(command: str, raise_errors: bool = True, raise_warnings: bool = True):\n    \"\"\"execute an copilation with the given comand\n    Args:\n        command (str): the comand copilation ,ex: 'gcc test.c'\n        raise_errors (bool, optional): if its to raise An copilation Error\n        raise_warnings (bool, optional): if is to raise an warning Error\n\n    Raises:\n        CopilationError: The Copilation Error Exception\n        CopilationWarning: The CopilationWarning Exception\n    \"\"\"\n    \n    result = ComandLineExecution(command)\n\n    if raise_errors and result.status_code != 0:\n        raise CopilationError(result.output, result.status_code)\n\n\n    if raise_warnings and 'warning:' in result.output:\n        raise CopilationWarning(result.output)", "def compile_project_by_command(command: str, raise_errors: bool = True, raise_warnings: bool = True):\n    \"\"\"execute an copilation with the given comand\n    Args:\n        command (str): the comand copilation ,ex: 'gcc test.c'\n        raise_errors (bool, optional): if its to raise An copilation Error\n        raise_warnings (bool, optional): if is to raise an warning Error\n\n    Raises:\n        CopilationError: The Copilation Error Exception\n        CopilationWarning: The CopilationWarning Exception\n    \"\"\"\n    \n    result = ComandLineExecution(command)\n\n    if raise_errors and result.status_code != 0:\n        raise CopilationError(result.output, result.status_code)\n\n\n    if raise_warnings and 'warning:' in result.output:\n        raise CopilationWarning(result.output)", "\n\ndef compile_project( file: str,compiler ='gcc', output: str = None, flags: List[str] = None, raise_errors: bool = True,\n                    raise_warnings: bool = True)->str:\n    \"\"\"Copiles an project file\n\n    Args:\n        compiler (str): the current compiler , ex: gcc,clang\n        file (str): the file to copile, ex: test.c\n        output (str, optional): the file output, ex: test.out ,if were None , it will be\n        the file replaced with .out or .exe\n        flags (List[str], optional): the optional flags copilatin\n        raise_errors (bool, optional): if its to raise An copilation Error\n        raise_warnings (bool, optional): if is to raise an warning Error\n\n    Raises:\n        CopilationError: The Copilation Error Exception\n        CopilationWarning: The CopilationWarning Exception\n    \"\"\"\n    if flags is None:\n        flags = []\n\n    if output is None:\n        if current_os() == 'Windows':\n            output = file.replace('.c', 'exe').replace('.cpp', '.exe')\n        else:\n            output = file.replace('.c', '.out').replace('.cpp', '.out')\n\n    command = f'{compiler} {file} -o {output} ' + ' -'.join(flags)\n    compile_project_by_command(command, raise_errors, raise_warnings)\n    return output", "\n\n\n\n\ndef test_binary_with_valgrind(binary_file:str,flags: List[str]= None)->dict:\n    \"\"\" will test an binary execution with valgrind\n    Args:\n        binary_file (str): the binary execution ex: test.out\n        flags (List[str], optional): addition flags to the copilation\n\n    Raises:\n        ValgrindError: And valgrind Error ex: an buffer overflow\n        ValgrindLeak: _An valgrind leak, ex: an non free alocation\n    \"\"\"\n    if flags is None:\n        flags = []\n\n    command = f'valgrind  ./{binary_file} ' + ' -'.join(flags)\n    result = ComandLineExecution(command)\n\n    #(result.output)\n    parsed_result = parse_valgrind_result(result.output)\n\n\n    if 'ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)' not in result.output:\n        raise ValgrindError(result.output,parsed_result)\n\n    if 'All heap blocks were freed -- no leaks are possible' not in result.output:\n        raise ValgrindLeak(result.output,parsed_result)\n    \n    return parsed_result", "\n    \n\n\ndef execute_test_for_file(\n        file: str,\n        compiler='gcc',\n        use_valgrind=True,\n        raise_warnings=True,\n        copilation_flags:List[str] =None,\n        execution_flags:List[str]=None)->dict or ComandLineExecution:\n    \"\"\"Execute an presset test for the current file\n    Args:\n        compiler (str): the compiler to use, ex: gcc or clang\n        file (str): the file to copile , ex: test.c\n        raise_warnings(bool): if its to raise warnings generated\n    Raises:\n        e: all possible errors\n    \"\"\"\n\n    result = compile_project(\n        file,\n        compiler,\n        raise_errors=True,\n        flags=copilation_flags,\n        raise_warnings=raise_warnings\n    )\n\n\n    if not use_valgrind:\n        if not execution_flags:\n            execution_flags = []\n        command =f'{result} '+ ' -'.join(execution_flags)\n        return  ComandLineExecution(command)\n\n    try:\n        valgrind_test = test_binary_with_valgrind(result,execution_flags)\n        remove(result)\n    except Exception as e:\n        remove(result)\n        raise e\n\n    return valgrind_test", "\n\n\n"]}
{"filename": "Build/CToolKit/readme_converter.py", "chunked_list": ["from typing import Callable\nimport json\n\n\ndef get_code_reference(line:str)->str or None:\n    test = ''\n    TARGET  = '<!--codeof:'\n    inclusion = ''\n    found_start = False\n\n    for letter in line:\n\n        if found_start == False:\n            if letter == ' ':\n                continue\n\n            if not TARGET.startswith(test):\n                return None\n\n            test+=letter\n\n            if test == TARGET:\n                found_start = True\n                continue\n\n        if found_start:\n\n            if letter == '-':\n                return inclusion.strip()\n\n            inclusion+=letter\n\n    return None", "\n\ndef parse_readme_lexer(text:str)->list:\n    constructed = []\n    block = ''\n\n    inside_block = False\n    first_line_inside_block = False\n    lines = text.split('\\n')\n    for line in lines:\n        if inside_block:\n            if first_line_inside_block:\n\n                if line.strip() == '':\n                    continue\n\n                if line.startswith('~~~') or line .startswith('\u00b4\u00b4\u00b4'):\n                    first_line_inside_block = False\n                    continue\n                else:\n                    inside_block = False\n                    first_line_inside_block = False\n                    continue\n            if line.startswith('~~~') or line.startswith('\u00b4\u00b4\u00b4'):\n                inside_block = False\n                first_line_inside_block = False\n                continue\n            continue\n\n        ref = get_code_reference(line)\n\n        if ref:\n            constructed.append({'type':'block','text':block})\n\n            extension = None\n            divided_ref = ref.split('.')\n            if len(divided_ref) > 1:\n                extension = divided_ref[-1].strip()\n            constructed.append({'type':'ref','ref':ref,'extension':extension})\n            block =''\n            inside_block = True\n            first_line_inside_block = True\n\n        if ref is None:\n            block+=line+'\\n'\n\n    constructed.append({'type': 'block', 'text': block})\n    return constructed", "\n\ndef include_code_in_markdown(markdown_file:str,save_file:bool=True,modifier:Callable=None)->str:\n    \"\"\"include all <!--codeof:teste.c--> in the given markdown file\n    Args:\n        markdown_file (str):the markdown file, ex: README.md\n        save_file (bool, optional): if is to save the file\n    Returns:\n        str: the generated markdown\n    \"\"\"\n    text = ''\n    with open(markdown_file,'r') as arq:\n        lexer = parse_readme_lexer(arq.read())\n\n        for l in lexer:\n            if l['type'] == 'block':\n                text+=l['text']\n\n            if l['type'] == 'ref':\n\n                text+=f'<!--codeof:{l[\"ref\"]}-->\\n'\n\n                with open(l['ref'] ,'r') as ref_arq:\n\n                    text+=f'~~~{l[\"extension\"]}\\n'\n                    ref_text = ref_arq.read()\n                    if modifier:\n                        text+=modifier(ref_text)\n                    else:\n                        text+=ref_text\n                    text+='\\n~~~\\n'\n\n    if '\\n' in text:\n        text = text[0:-1]\n\n    if save_file:\n        with open(markdown_file,'w') as arq:\n            arq.write(text)\n\n    return text"]}
{"filename": "Build/CToolKit/Errors/ValgrindError.py", "chunked_list": ["from .ComandLineWarning import ComandLineWarning\n\n\nclass ValgrindError(ComandLineWarning):\n    \n    def __init__(self, message: str,valgrind_status:dict  ):\n        super().__init__(str(message))\n        self.valgrind_status = valgrind_status\n     \n", "     \n\n"]}
{"filename": "Build/CToolKit/Errors/ValgrindLeak.py", "chunked_list": ["from .ComandLineWarning import ComandLineWarning\n\n\nclass ValgrindLeak(ComandLineWarning):\n\n    \n    def __init__(self, message: str,valgrind_status:dict  ):\n        super().__init__(str(message))\n        self.valgrind_status = valgrind_status\n     ", "     \n"]}
{"filename": "Build/CToolKit/Errors/ComandLineError.py", "chunked_list": ["\n\nclass ComandLineError(Exception):\n\n    def __init__(self, message: str, status_code: int):\n        self.status_code = status_code\n        self.message = message\n\n    def __str__(self):\n        text = f'Mensage: {self.message}\\n'\n        text += f'Status Code: {self.status_code}\\n'\n        return text", "\n\n"]}
{"filename": "Build/CToolKit/Errors/ComandLineWarning.py", "chunked_list": ["\n\nclass ComandLineWarning(Exception):\n\n    def __init__(self, message: str):\n        self.status_code = 0\n        self.message = message\n\n    def __str__(self):\n        text = f'Mensage: {self.message}\\n'\n        return text", "\n"]}
{"filename": "Build/CToolKit/Errors/ExecutionError.py", "chunked_list": ["\nfrom .ComandLineError import ComandLineError\nclass ExecutionError(ComandLineError):\n    pass"]}
{"filename": "Build/CToolKit/Errors/__init__.py", "chunked_list": [""]}
{"filename": "Build/CToolKit/Errors/SideEffectFolderDiferent.py", "chunked_list": ["\n\nclass SideEffectFolderDiferent(Exception):\n\n    def __init__(self,side_effect_folder:str):\n        self.mensage = side_effect_folder\n        super().__init__(self.mensage)\n"]}
{"filename": "Build/CToolKit/Errors/NotExpectedResult.py", "chunked_list": ["\nfrom typing import List\nclass NotExpectedResult(Exception):\n\n    def __int__(self,result: List[str] or dict or str, expected:List[str] or dict or str):\n        self.mensage = f'the result is deiferent than expected'\n        super().__init__(self.mensage)\n\n        self.result = result\n        self.expected = expected", ""]}
{"filename": "Build/CToolKit/Errors/CopilationWarning.py", "chunked_list": ["\nfrom .ComandLineWarning import ComandLineWarning\n\nclass CopilationWarning(ComandLineWarning):\n    pass"]}
{"filename": "Build/CToolKit/Errors/CopilationError.py", "chunked_list": ["\nfrom .ComandLineError import  ComandLineError\nclass CopilationError(ComandLineError):\n    pass"]}
{"filename": "Build/CToolKit/FolderTestPreset/Extras.py", "chunked_list": ["\nfrom .Print import FolderTestPressetPrints\nfrom os import listdir\n\nfrom os.path import isdir,isfile\nimport os\nimport shutil\nfrom shutil import rmtree,copytree\nfrom .folder_hash import are_folders_equal\n\nclass FolderTestPresetExtras(FolderTestPressetPrints):\n\n    def _get_expected_file(self, folder: str):\n        elements = listdir(folder)\n        for e in elements:\n            if isdir(e):\n                continue\n\n            if e.startswith('expected'):\n                return f'{folder}/{e}'\n\n\n    def _get_file_to_execute(self, folder: str):\n        c_file = f'{folder}/exec.c'\n        cpp_file = f'{folder}/exec.cpp'\n\n        if isfile(c_file):\n            return c_file\n\n        if isfile(cpp_file):\n            return cpp_file\n\n        raise FileNotFoundError(f'could not locate an exec.c or exec.cpp in {folder}')\n\n\n    def _create_copy_side_effect_folder(self):\n        if self._side_effect_folder is None:\n            return\n        rmtree('side_effect_copy', ignore_errors=True)\n        copytree(self._side_effect_folder,'side_effect_copy')\n\n\n\n\n    def _side_effect_folder_changed(self)->bool:\n        return not are_folders_equal(self._side_effect_folder,'side_effect_copy')\n\n\n\n    def _rebase_side_effect_folder(self):\n        rmtree(self._side_effect_folder,ignore_errors=True)\n        copytree(f'side_effect_copy',self._side_effect_folder)", "from .folder_hash import are_folders_equal\n\nclass FolderTestPresetExtras(FolderTestPressetPrints):\n\n    def _get_expected_file(self, folder: str):\n        elements = listdir(folder)\n        for e in elements:\n            if isdir(e):\n                continue\n\n            if e.startswith('expected'):\n                return f'{folder}/{e}'\n\n\n    def _get_file_to_execute(self, folder: str):\n        c_file = f'{folder}/exec.c'\n        cpp_file = f'{folder}/exec.cpp'\n\n        if isfile(c_file):\n            return c_file\n\n        if isfile(cpp_file):\n            return cpp_file\n\n        raise FileNotFoundError(f'could not locate an exec.c or exec.cpp in {folder}')\n\n\n    def _create_copy_side_effect_folder(self):\n        if self._side_effect_folder is None:\n            return\n        rmtree('side_effect_copy', ignore_errors=True)\n        copytree(self._side_effect_folder,'side_effect_copy')\n\n\n\n\n    def _side_effect_folder_changed(self)->bool:\n        return not are_folders_equal(self._side_effect_folder,'side_effect_copy')\n\n\n\n    def _rebase_side_effect_folder(self):\n        rmtree(self._side_effect_folder,ignore_errors=True)\n        copytree(f'side_effect_copy',self._side_effect_folder)", "\n\n\n\n\n\n\n\n\n", "\n\n\n\n\n\n"]}
{"filename": "Build/CToolKit/FolderTestPreset/Execution.py", "chunked_list": ["\nfrom os import listdir\nfrom os.path import  isdir\nfrom shutil import rmtree\nfrom typing import List\nfrom ..comand_line_functions import execute_test_for_file\nfrom ..Errors.NotExpectedResult import NotExpectedResult\nfrom ..Errors.SideEffectFolderDiferent import SideEffectFolderDiferent\nfrom .output_formatation import  sanitize_value\nfrom ..ComandLineExecution import ComandLineExecution", "from .output_formatation import  sanitize_value\nfrom ..ComandLineExecution import ComandLineExecution\nfrom .Creation import FolderTestPressetCreation\nfrom .folder_hash import are_folders_equal\nclass FolderTestPressetExecution(FolderTestPressetCreation):\n\n\n    def _execute_test_presset(self,folder:str):\n        self._rebase_side_effect_folder()\n\n        execution_file = self._get_file_to_execute(folder)\n        expected_file = self._get_expected_file(folder)\n\n        if expected_file is None:\n            raise FileNotFoundError(f'could not locate an expected.* in {folder}')\n\n\n        with open(expected_file,'r') as arq:\n            expected_content = arq.read()\n\n        sanitized_expected :dict or List[str] = sanitize_value(expected_file,expected_content)\n\n\n        generated_result:dict or ComandLineExecution = execute_test_for_file(\n                file=execution_file,\n                compiler=self._compiler,\n                use_valgrind=self._use_valgrind,\n                raise_warnings=self._raise_warnings\n        )\n\n\n        #verifying it there is an side effect folder\n        side_effect_test = f'{folder}/side_effect'\n        if isdir(side_effect_test):\n            are_equal = are_folders_equal(side_effect_test,self._side_effect_folder)\n\n            if are_equal == False:\n                raise SideEffectFolderDiferent(side_effect_test)\n\n\n        else:\n            if self._side_effect_folder_changed():\n                raise SideEffectFolderDiferent('there is no side effect folder passed')\n\n\n        if isinstance(generated_result,ComandLineExecution):\n            output = generated_result.output\n        else:\n            output = generated_result['output']\n\n\n        sanitized_result = sanitize_value(expected_file,output)\n\n\n\n\n        if sanitized_expected != sanitized_result:\n            raise NotExpectedResult(sanitized_expected,sanitized_result)\n\n\n\n\n\n    def _execute_loop_test(self,folder:str):\n        self._print_if_seetted_to_print_folder(folder)\n\n        elements:List[str] = listdir(folder)\n        for e in elements:\n\n            path = f'{folder}/{e}'\n\n            if isdir(path):\n\n                if e.startswith('T_'):\n                    try:\n                        self._execute_test_presset(path)\n                        self._print_if_setted_to_print_test(e, True)\n                    except Exception as ex:\n                        self._print_if_setted_to_print_test(e, False)\n                        raise ex\n                    continue\n\n                self._execute_loop_test(path)\n                continue\n\n            if path.endswith('.c') or path.endswith('.cpp'):\n                self._rebase_side_effect_folder()\n                try:\n                    execute_test_for_file(\n                        path,\n                        compiler=self._compiler,\n                        use_valgrind=self._use_valgrind,\n                        raise_warnings=self._raise_warnings,\n                        copilation_flags=self._compilation_flags,\n                        execution_flags=self._execution_flags\n                    )\n                    self._print_if_setted_to_print_test(e, True)\n\n                except Exception as ex:\n                    self._print_if_setted_to_print_test(e, False)\n                    raise ex\n\n\n    def start_test(self):\n        self._create_copy_side_effect_folder()\n\n        try:\n            self._execute_loop_test(self._folder)\n        except Exception as e:\n            self._rebase_side_effect_folder()\n            rmtree('side_effect_copy', ignore_errors=True)\n            raise e\n\n        self._rebase_side_effect_folder()\n        rmtree('side_effect_copy',ignore_errors=True)", "\n"]}
{"filename": "Build/CToolKit/FolderTestPreset/Print.py", "chunked_list": ["from .Constructor import  FolderTestPresetConstructor\n\nclass FolderTestPressetPrints(FolderTestPresetConstructor):\n\n    def _print_if_setted_to_print_test(self, element: str, passed: bool):\n        if not self._print_values:\n            return\n        if passed:\n            print('\\033[92m' + f'\\tpassed : {element}')\n        else:\n            print('\\033[91m' + f'\\tfail : {element}')\n\n        print('\\033[0m',end='')\n\n    def _print_if_setted_to_print_creation(self, element: str, created: bool):\n        if not self._print_values:\n            return\n        if created:\n            print('\\033[96m' + f'\\tcreated: {element}')\n        else:\n            print('\\033[94m' + f'\\talready exist: {element}')\n\n        print('\\033[0m',end='')\n\n    def _print_if_seetted_to_print_folder(self, folder: str):\n        if self._print_values:\n            print(f'folder :{folder}')", "\n"]}
{"filename": "Build/CToolKit/FolderTestPreset/Creation.py", "chunked_list": ["from typing import List\nfrom os import listdir\nfrom shutil import copytree,rmtree\n\nfrom os.path import  isdir\nfrom .Extras import FolderTestPresetExtras\nfrom ..ComandLineExecution import ComandLineExecution\nfrom ..comand_line_functions import execute_test_for_file\n\n", "\n\n\n\nclass FolderTestPressetCreation(FolderTestPresetExtras):\n\n    def _execute_test_presset_creating_output(self, folder: str):\n        self._rebase_side_effect_folder()\n\n        execution_file = self._get_file_to_execute(folder)\n        expected_file = self._get_expected_file(folder)\n\n\n        generated_result: dict or ComandLineExecution = execute_test_for_file(\n                file=execution_file,\n                compiler=self._compiler,\n                copilation_flags=self._compilation_flags,\n                execution_flags=self._execution_flags,\n                use_valgrind=self._use_valgrind,\n                raise_warnings=self._raise_warnings\n        )\n\n        modified = False\n\n\n        if self._side_effect_folder_changed():\n            #verify if there is no test presseted\n            if not isdir(f'{folder}/side_effect'):\n                copytree(self._side_effect_folder, f'{folder}/side_effect')\n                modified = True\n\n        if expected_file is None:\n            if isinstance(generated_result, ComandLineExecution):\n                output = generated_result.output\n            else:\n                output = generated_result['output']\n\n            with open(f'{folder}/expected.txt', 'w') as arq:\n                arq.write(output)\n            modified = True\n\n\n        if modified:\n            self._print_if_setted_to_print_creation(execution_file, True)\n        else:\n            self._print_if_setted_to_print_creation(execution_file, False)\n\n\n    def _execute_loop_creating_expected(self, folder: str):\n        self._print_if_seetted_to_print_folder(folder)\n\n        elements: List[str] = listdir(folder)\n        for e in elements:\n            path = f'{folder}/{e}'\n\n            if not isdir(path):\n                continue\n\n            if e.startswith('T_') :\n                try:\n                    self._execute_test_presset_creating_output(path)\n                except Exception as ex:\n                    self._print_if_setted_to_print_test(e, False)\n                    raise ex\n                continue\n\n            self._execute_loop_creating_expected(path)\n\n    def generate_ouptut(self):\n        self._create_copy_side_effect_folder()\n        try:\n            self._execute_loop_creating_expected(self._folder)\n        except Exception as e:\n            self._rebase_side_effect_folder()\n            rmtree('side_effect_copy', ignore_errors=True)\n            raise e\n\n        self._rebase_side_effect_folder()\n        rmtree('side_effect_copy', ignore_errors=True)", "\n"]}
{"filename": "Build/CToolKit/FolderTestPreset/Constructor.py", "chunked_list": ["from typing import List\n\nclass FolderTestPresetConstructor:\n\n    def __init__(\n            self,\n            folder:str,\n            side_effect_folder:str =None,\n            compiler='gcc',\n            compilation_flags:List[str]=None,\n            execution_flags:List[str]=None,\n            print_values=True,\n            use_valgrind=True,\n            raise_warnings=True\n    ):\n        self._folder = folder\n        self._side_effect_folder = side_effect_folder\n        self._compiler =compiler\n        self._compilation_flags = compilation_flags\n        self._execution_flags = execution_flags\n        self._print_values = print_values\n        self._use_valgrind = use_valgrind\n        self._raise_warnings = raise_warnings", ""]}
{"filename": "Build/CToolKit/FolderTestPreset/__init__.py", "chunked_list": [""]}
{"filename": "Build/CToolKit/FolderTestPreset/folder_hash.py", "chunked_list": ["\n\nfrom os import listdir\nfrom os.path import  isdir\n\nimport hashlib\n\n\n\ndef generate_folder_hash(folder:str)->str:\n\n    content = listdir(folder)\n    content.sort()\n    sha256 = hashlib.sha256()\n\n    for c in content:\n        path = f'{folder}/{c}'\n        sha256.update(c.encode('utf8'))\n\n        if isdir(path):\n            sha256.update(generate_folder_hash(path).encode('utf8'))\n\n        else:\n            with open(path,'rb') as arq:\n                sha256.update(arq.read())\n\n    return sha256.hexdigest()", "\ndef generate_folder_hash(folder:str)->str:\n\n    content = listdir(folder)\n    content.sort()\n    sha256 = hashlib.sha256()\n\n    for c in content:\n        path = f'{folder}/{c}'\n        sha256.update(c.encode('utf8'))\n\n        if isdir(path):\n            sha256.update(generate_folder_hash(path).encode('utf8'))\n\n        else:\n            with open(path,'rb') as arq:\n                sha256.update(arq.read())\n\n    return sha256.hexdigest()", "\n\ndef are_folders_equal(folder1,folder2)->bool:\n    hash1 =  generate_folder_hash(folder1)\n    hash2 = generate_folder_hash(folder2)\n    return hash1 == hash2\n\n\n", ""]}
{"filename": "Build/CToolKit/FolderTestPreset/FolderTestPreset.py", "chunked_list": ["from .Execution import FolderTestPressetExecution\n\nclass FolderTestPreset(FolderTestPressetExecution):\n    pass\n"]}
{"filename": "Build/CToolKit/FolderTestPreset/output_formatation.py", "chunked_list": ["import json\nfrom typing import List\ndef trim_lines(text:str)->List[str]:\n    lines = text.split('\\n')\n    striped = list(map(lambda x: x.strip(),lines))\n    return list(filter(lambda x: x != '' , striped))\n\ndef sanitize_value(filename:str,content:str=None)->dict or str or List[str]:\n\n    if filename.endswith('.json'):\n        return json.loads(content)\n\n    if 'not_trim' in filename:\n        return content\n\n    return trim_lines(content)", "\n"]}
