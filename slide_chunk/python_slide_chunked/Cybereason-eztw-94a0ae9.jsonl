{"filename": "setup.py", "chunked_list": ["from setuptools import setup\n\n# To build a wheel: python setup.py bdist_wheel\n\nsetup(\n    name=\"eztw\",    \n    version=\"1.0.3\",\n    description=\"Easy Python wrapper for ETW\",\n    url=\"https://github.com/wild-strudel/eztw\",\n    author=\"Uri Sternfeld\",", "    url=\"https://github.com/wild-strudel/eztw\",\n    author=\"Uri Sternfeld\",\n    packages=[\"eztw\", \"eztw.scripts\"],\n    python_requires=\">=3.10, <4\",\n    install_requires=[\"pywin32\"],\n    license=\"MIT\",\n    classifiers=[\n        'License :: OSI Approved :: MIT License',\n        'Programming Language :: Python',\n        'Programming Language :: Python :: 3',", "        'Programming Language :: Python',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.10',\n        'Programming Language :: Python :: 3.11',\n        'Programming Language :: Python :: Implementation :: CPython',\n        'Operating System :: Microsoft :: Windows',\n        'Operating System :: Microsoft :: Windows :: Windows 10',\n    ],\n)", ")"]}
{"filename": "eztw/log.py", "chunked_list": ["\"\"\"\nBasic logger used throughout eztw.\nUse enable_logging / disable_logging to enable or suppress.\n\"\"\"\nimport logging\n\nLOGGER = logging.getLogger(\"eztw\")\n\ndef enable_logging():\n    if not LOGGER.handlers:\n        LOGGER.setLevel(logging.INFO)\n        _formatter = logging.Formatter(\"%(asctime)s %(name)s %(levelname)s %(message)s\",\n                                       datefmt=\"%d/%m/%Y %H:%M:%S\")\n        _log_console_handler = logging.StreamHandler()\n        _log_console_handler.setLevel(logging.INFO)\n        _log_console_handler.setFormatter(_formatter)\n        LOGGER.addHandler(_log_console_handler)", "def enable_logging():\n    if not LOGGER.handlers:\n        LOGGER.setLevel(logging.INFO)\n        _formatter = logging.Formatter(\"%(asctime)s %(name)s %(levelname)s %(message)s\",\n                                       datefmt=\"%d/%m/%Y %H:%M:%S\")\n        _log_console_handler = logging.StreamHandler()\n        _log_console_handler.setLevel(logging.INFO)\n        _log_console_handler.setFormatter(_formatter)\n        LOGGER.addHandler(_log_console_handler)\n\ndef disable_logging():\n    if LOGGER.handlers:\n        LOGGER.handlers.clear()", "\ndef disable_logging():\n    if LOGGER.handlers:\n        LOGGER.handlers.clear()\n\nenable_logging()\n"]}
{"filename": "eztw/guid.py", "chunked_list": ["\"\"\"\nImplementation of GUID structure - can be constructed either from bytes (as a ctypes.Structure)\nor from string of a GUID (via the ctor).\n\"\"\"\nimport re\nimport ctypes\n\n\nclass GUID(ctypes.Structure):\n    \"\"\"\n    Represents a Windows GUID object. Can be read from a string or directly from data.\n    Can be converted back to a GUID string.\n    \"\"\"\n\n    # See https://learn.microsoft.com/en-us/windows/win32/api/guiddef/ns-guiddef-guid\n    _fields_ = [(\"Data1\", ctypes.c_ulong),\n                (\"Data2\", ctypes.c_ushort),\n                (\"Data3\", ctypes.c_ushort),\n                (\"Data4\", ctypes.c_ubyte * 8)]\n\n    GUID_RE = re.compile(\"^{?([0-9A-F]{8})-\"\n                         \"([0-9A-F]{4})-\"\n                         \"([0-9A-F]{4})-\"\n                         \"([0-9A-F]{2})([0-9A-F]{2})-\"\n                         \"([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})\"\n                         \"([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})}?$\",\n                         re.IGNORECASE)\n\n    @classmethod\n    def verify(cls, possibly_guid_string: str) -> bool:\n        \"\"\"\n        Verify that the given object is a valid GUID string.\n\n        @param possibly_guid_string: a string which might be a GUID\n        @return: True or False\n        \"\"\"\n        return cls.GUID_RE.search(possibly_guid_string) is not None\n\n    def __init__(self, guid_str: str):\n        super().__init__()\n        # Verify using regex that the string is valid\n        guid_match = self.GUID_RE.search(guid_str)\n        if guid_match is None:\n            raise ValueError(f\"Invalid GUID string {guid_str!r}\")\n        guid_parts = [int(i, 16) for i in guid_match.groups()]\n        self.Data1 = guid_parts[0]\n        self.Data2 = guid_parts[1]\n        self.Data3 = guid_parts[2]\n        for i in range(8):\n            self.Data4[i] = guid_parts[3 + i]\n\n    def __str__(self):\n        d = self.Data4\n        # This result is cached\n        return f\"{{{self.Data1:08x}-{self.Data2:04x}-{self.Data3:04x}-{d[0]:02x}{d[1]:02x}-\" \\\n               f\"{d[2]:02x}{d[3]:02x}{d[4]:02x}{d[5]:02x}{d[6]:02x}{d[7]:02x}}}\"\n\n    __repr__ = __str__", "class GUID(ctypes.Structure):\n    \"\"\"\n    Represents a Windows GUID object. Can be read from a string or directly from data.\n    Can be converted back to a GUID string.\n    \"\"\"\n\n    # See https://learn.microsoft.com/en-us/windows/win32/api/guiddef/ns-guiddef-guid\n    _fields_ = [(\"Data1\", ctypes.c_ulong),\n                (\"Data2\", ctypes.c_ushort),\n                (\"Data3\", ctypes.c_ushort),\n                (\"Data4\", ctypes.c_ubyte * 8)]\n\n    GUID_RE = re.compile(\"^{?([0-9A-F]{8})-\"\n                         \"([0-9A-F]{4})-\"\n                         \"([0-9A-F]{4})-\"\n                         \"([0-9A-F]{2})([0-9A-F]{2})-\"\n                         \"([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})\"\n                         \"([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})}?$\",\n                         re.IGNORECASE)\n\n    @classmethod\n    def verify(cls, possibly_guid_string: str) -> bool:\n        \"\"\"\n        Verify that the given object is a valid GUID string.\n\n        @param possibly_guid_string: a string which might be a GUID\n        @return: True or False\n        \"\"\"\n        return cls.GUID_RE.search(possibly_guid_string) is not None\n\n    def __init__(self, guid_str: str):\n        super().__init__()\n        # Verify using regex that the string is valid\n        guid_match = self.GUID_RE.search(guid_str)\n        if guid_match is None:\n            raise ValueError(f\"Invalid GUID string {guid_str!r}\")\n        guid_parts = [int(i, 16) for i in guid_match.groups()]\n        self.Data1 = guid_parts[0]\n        self.Data2 = guid_parts[1]\n        self.Data3 = guid_parts[2]\n        for i in range(8):\n            self.Data4[i] = guid_parts[3 + i]\n\n    def __str__(self):\n        d = self.Data4\n        # This result is cached\n        return f\"{{{self.Data1:08x}-{self.Data2:04x}-{self.Data3:04x}-{d[0]:02x}{d[1]:02x}-\" \\\n               f\"{d[2]:02x}{d[3]:02x}{d[4]:02x}{d[5]:02x}{d[6]:02x}{d[7]:02x}}}\"\n\n    __repr__ = __str__", "\ndef canonize_GUID(guid_str: str) -> str:\n    \"\"\"\n    Given a potentially-valid GUID string, canonize it into canonic GUID string.\n    \"\"\"\n    return str(GUID(guid_str))\n"]}
{"filename": "eztw/__init__.py", "chunked_list": ["from .common import EztwException\nfrom .controller import EztwController\nfrom .consumer import EztwConsumer\nfrom .session import EztwSessionIterator, consume_events\nfrom .event import EztwFilter, EztwDispatcher\nfrom .provider import get_provider, get_providers, get_provider_config, add_manual_provider, parse_event, \\\n    EztwProviderConfig\nfrom .trace_common import MAX_KEYWORDS\n", ""]}
{"filename": "eztw/session.py", "chunked_list": ["\"\"\"\nImplementation of EztwSessionIterator, which allows easy iteration over existing session or sessions.\nIt automatically parses and yields the event contents along with the event records.\nIf multiple sessions are consumed, a separate thread is used for each of them (since it's blocking).\n\nIn addition, provides the convenience function consume_events, which handles the consumption process\nend-to-end based on the given EztwEvent objects.\n\"\"\"\nimport threading\nimport queue", "import threading\nimport queue\nimport time\nfrom collections import defaultdict, Counter\n\nfrom .common import as_list, EztwException\nfrom .controller import EztwController\nfrom .provider import eztwm, get_provider_config\nfrom .consumer import EztwConsumer\nfrom .event import EztwEvent, EztwFilter", "from .consumer import EztwConsumer\nfrom .event import EztwEvent, EztwFilter\nfrom .trace_common import LOST_EVENTS_GUID, ad_hoc_session_name, MSNT_SystemTrace_GUID\n\n\nclass EztwSessionIterator:\n    \"\"\"\n    This class iterates over existing sessions by names - either a single session (current thread) or multiple\n    sessions (each in its own thread).\n\n    A second, optional parameter is which events to filter. This can either be None (no filter), or\n    a single or a list of EztwEvent objects. Only these events will be parsed and returned.\n\n    Finally, the session iterator automatically counts all events consumed during its operation (including\n    filtered ones) and presents a neat summary by provider/event when stopped (including when stopped\n    using Ctrl+C, i.e KeyboardInterrupt).\n\n    Example usage:\n    >>> session_names = ['session1', 'session2']\n    >>> events_to_filter = provider.Event_123\n    >>> with EztwSessionIterator(session_names, events_to_filter) as si:\n    >>>     for event_record, parsed_event in si:\n    >>>         # do something\n    \"\"\"\n    def __init__(self, session_names: str | list[str], filtered_events: EztwEvent | list[EztwEvent] | None = None):\n        self.session_names = as_list(session_names)\n        assert len(self.session_names) >= 1\n        self.event_filter = EztwFilter(filtered_events) if filtered_events else None\n\n    @staticmethod\n    def _thread_proc_consumer(session_name, event_queue, stop_signal):\n        # Consume a single session and put its event records in a shared queue until the stop signal is set\n        with EztwConsumer(session_name) as ezc:\n            while not stop_signal.is_set():\n                event_record = ezc.get_event()\n                if event_record:\n                    event_queue.put(event_record)\n\n    def _consume_events(self):\n        # Consume either a single session (in current thread) or multiple sessions (in separate threads)\n        if len(self.session_names) == 1:\n            # With a single session - consume in the same thread\n            with EztwConsumer(self.session_names[0]) as ezc:\n                yield from ezc\n        else:\n            # For multiple sessions - create a new Queue and stop signal\n            event_queue = queue.Queue()\n            stop_signal = threading.Event()\n            # Start one consumer thread per session (ProcessTrace is blocking each thread)\n            threads = [\n                threading.Thread(target=self._thread_proc_consumer, args=(session_name, event_queue, stop_signal))\n                for session_name in self.session_names]\n            # Start the threads\n            for th in threads:\n                th.start()\n            try:\n                # Get from queue until interrupted\n                while True:\n                    try:\n                        yield event_queue.get(timeout=0.1)\n                    except queue.Empty:\n                        continue\n            finally:\n                # Signal all threads to stop and wait for them to join\n                stop_signal.set()\n                for th in threads:\n                    th.join()\n\n    def __iter__(self):\n        event_counter = defaultdict(Counter)\n        unknown_events = set()\n        start_time = time.time()\n        try:\n            # Main iteration loop\n            for event_record in self._consume_events():\n                # Count this event\n                event_counter[event_record.provider_guid][event_record.id] += 1\n                if self.event_filter is None or event_record in self.event_filter:\n                    # Ignore these provider GUIDs\n                    if event_record.provider_guid in [MSNT_SystemTrace_GUID, LOST_EVENTS_GUID]:\n                        continue\n                    try:\n                        # Parse and yield\n                        yield event_record, eztwm.parse(event_record)\n                    except EztwException as e:\n                        # Only print once per event\n                        if hash(event_record) not in unknown_events:\n                            print(f\"Failed to parse event {event_record} - {e}\")\n                            unknown_events.add(hash(event_record))\n        except KeyboardInterrupt:\n            # Suppress\n            pass\n        except Exception as e:\n            print(f\"\\nUnhandled error - {e}\")\n        finally:\n            # If no events where consumed, there's nothing to report\n            if not event_counter:\n                return\n            # Print a nice summary of all consumed events\n            total_time = time.time() - start_time\n            print(f\"\\nTotal events during {total_time:.2f} seconds:\")\n            if LOST_EVENTS_GUID in event_counter:\n                lost_events = sum(event_counter.pop(LOST_EVENTS_GUID).values())\n                print(f\"\\tLOST EVENTS ({LOST_EVENTS_GUID}): {lost_events}\")\n            for provider_guid, event_count in event_counter.items():\n                provider_name = eztwm.get_provider_name_from_guid(provider_guid)\n                print(f\"\\tProvider {provider_guid} ({provider_name}):\")\n                for eid, cnt in event_count.most_common():\n                    print(f\"\\t\\tEvent ID {eid} - {cnt}\")\n            print()", "\n\ndef consume_events(events: EztwEvent | list[EztwEvent], session_name: None | str = None,\n                   keywords: None | dict[str, int] = None):\n    \"\"\"\n    Convenience function that automatically deducts the needed providers and keywords from the given list of\n    event classes, and only yields the parsed events if they're on the list (provider GUID + event ID).\n    Session name is optional, if omitted a random trace name will be used.\n\n    This function should probably be used for most cases.\n\n    @param events: a single EztwEvent or a list of them - only these events will be parsed and returned\n    @param session_name: either a session name to use or None (default, in which case a temporary name is used)\n    @param keywords: either None (implicit keywords from events) or a dict from provider GUID to keyword value\n    \"\"\"\n    if not session_name:\n        session_name = ad_hoc_session_name()\n    # Start consuming\n    with EztwController(session_name, get_provider_config(events, keywords=keywords)):\n        yield from EztwSessionIterator(session_name, events)", ""]}
{"filename": "eztw/controller.py", "chunked_list": ["\"\"\"\nImplementation of EztwController, which allows starting and stopping trace sessions, as well as\nenabling providers.\n\nNote: there are some advanced options when enabling providers (kernel-side filters, stack trace, etc.).\nThese are not yet supported.\n\"\"\"\nimport ctypes\nimport winerror\nimport win32event", "import winerror\nimport win32event\n\nfrom .guid import GUID\nfrom .log import LOGGER\nfrom .common import UCHAR, ULONG, ULONGLONG, LARGE_INTEGER, ULARGE_INTEGER, LPVOID, LPWSTR, HANDLE, \\\n    as_list, EztwException\nfrom .trace_common import ADVAPI32_DLL, TRACEHANDLE\nfrom .provider import EztwProviderConfig\n", "from .provider import EztwProviderConfig\n\n\nclass EztwControllerException(EztwException):\n    \"\"\"A trace controller error\"\"\"\n\n\n########\n# WINAPI\n", "# WINAPI\n\n# https://learn.microsoft.com/en-us/windows/win32/etw/logging-mode-constants\nEVENT_TRACE_REAL_TIME_MODE = 0x00000100\n\n# https://learn.microsoft.com/en-us/windows/win32/api/evntrace/ns-evntrace-event_trace_logfilea\nPROCESS_TRACE_MODE_REAL_TIME = 0x00000100\n\n# https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wmistr/ns-wmistr-_wnode_header\nWNODE_FLAG_TRACED_GUID = 0x00020000", "# https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wmistr/ns-wmistr-_wnode_header\nWNODE_FLAG_TRACED_GUID = 0x00020000\n\n# https://learn.microsoft.com/en-us/windows/win32/api/evntrace/nf-evntrace-controltracea\nEVENT_TRACE_CONTROL_STOP = 1\n\n# https://learn.microsoft.com/en-us/windows/win32/api/evntrace/ns-evntrace-enable_trace_parameters\nENABLE_TRACE_PARAMETERS_VERSION_2 = 2\n\n# https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wmistr/ns-wmistr-_wnode_header\nclass WNODE_HEADER(ctypes.Structure):\n    _fields_ = [('BufferSize', ULONG),\n                ('ProviderId', ULONG),\n                ('HistoricalContext', ULARGE_INTEGER),\n                ('TimeStamp', LARGE_INTEGER),\n                ('Guid', GUID),\n                ('ClientContext', ULONG),\n                ('Flags', ULONG)]", "\n# https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wmistr/ns-wmistr-_wnode_header\nclass WNODE_HEADER(ctypes.Structure):\n    _fields_ = [('BufferSize', ULONG),\n                ('ProviderId', ULONG),\n                ('HistoricalContext', ULARGE_INTEGER),\n                ('TimeStamp', LARGE_INTEGER),\n                ('Guid', GUID),\n                ('ClientContext', ULONG),\n                ('Flags', ULONG)]", "\n# https://learn.microsoft.com/en-us/windows/win32/api/evntrace/ns-evntrace-event_trace_properties\nclass EVENT_TRACE_PROPERTIES(ctypes.Structure):\n    _fields_ = [('Wnode', WNODE_HEADER),\n                ('BufferSize', ULONG),\n                ('MinimumBuffers', ULONG),\n                ('MaximumBuffers', ULONG),\n                ('MaximumFileSize', ULONG),\n                ('LogFileMode', ULONG),\n                ('FlushTimer', ULONG),\n                ('EnableFlags', ULONG),\n                ('AgeLimit', ULONG),\n                ('NumberOfBuffers', ULONG),\n                ('FreeBuffers', ULONG),\n                ('EventsLost', ULONG),\n                ('BuffersWritten', ULONG),\n                ('LogBuffersLost', ULONG),\n                ('RealTimeBuffersLost', ULONG),\n                ('LoggerThreadId', HANDLE),\n                ('LogFileNameOffset', ULONG),\n                ('LoggerNameOffset', ULONG)]", "\n# https://learn.microsoft.com/en-us/windows/win32/api/evntrace/nf-evntrace-starttracew\nStartTrace = ctypes.WINFUNCTYPE(\n    ULONG,                                      # Return type\n    ctypes.POINTER(TRACEHANDLE),                # PTRACEHANDLE TraceHandle\n    LPWSTR,                                     # LPCSTR InstanceName\n    ctypes.POINTER(EVENT_TRACE_PROPERTIES),     # PEVENT_TRACE_PROPERTIES Properties\n)((\"StartTraceW\", ADVAPI32_DLL))\n\n# https://learn.microsoft.com/en-us/windows/win32/api/evntrace/nf-evntrace-controltracew", "\n# https://learn.microsoft.com/en-us/windows/win32/api/evntrace/nf-evntrace-controltracew\nControlTrace = ctypes.WINFUNCTYPE(\n    ULONG,                                      # Return type\n    TRACEHANDLE,                                # TRACEHANDLE TraceHandle\n    LPWSTR,                                     # LPCSTR InstanceName\n    ctypes.POINTER(EVENT_TRACE_PROPERTIES),     # PEVENT_TRACE_PROPERTIES Properties\n    ULONG,                                      # ULONG ControlCode\n)((\"ControlTraceW\", ADVAPI32_DLL))\n", ")((\"ControlTraceW\", ADVAPI32_DLL))\n\n# https://learn.microsoft.com/en-us/windows/win32/api/evntprov/nc-evntprov-penablecallback\nEVENT_CONTROL_CODE_DISABLE_PROVIDER = 0\nEVENT_CONTROL_CODE_ENABLE_PROVIDER = 1\n\n# Not supported yet...\n\n# # https://learn.microsoft.com/en-us/windows/win32/api/evntprov/ns-evntprov-event_filter_descriptor\n# class EVENT_FILTER_DESCRIPTOR(ctypes.Structure):", "# # https://learn.microsoft.com/en-us/windows/win32/api/evntprov/ns-evntprov-event_filter_descriptor\n# class EVENT_FILTER_DESCRIPTOR(ctypes.Structure):\n#     _fields_ = [('Ptr', ULARGE_INTEGER),\n#                 ('Size', ULONG),\n#                 ('Type', ULONG),\n#                 ]\n#\n# # https://learn.microsoft.com/en-us/windows/win32/api/evntrace/ns-evntrace-enable_trace_parameters\n# class ENABLE_TRACE_PARAMETERS(ctypes.Structure):\n#     __fields__ = [(\"Version\", ULONG),", "# class ENABLE_TRACE_PARAMETERS(ctypes.Structure):\n#     __fields__ = [(\"Version\", ULONG),\n#                   (\"EnableProperty\", ULONG),\n#                   (\"ControlFlags\", ULONG),\n#                   (\"SourceId\", GUID),\n#                   (\"EnableFilterDesc\", ctypes.POINTER(EVENT_FILTER_DESCRIPTOR)),\n#                   (\"FilterDescCount\", ULONG),\n#                   ]\n\n# https://learn.microsoft.com/en-us/windows/win32/api/evntrace/nf-evntrace-enabletraceex2", "\n# https://learn.microsoft.com/en-us/windows/win32/api/evntrace/nf-evntrace-enabletraceex2\nEnableTraceEx2 = ctypes.WINFUNCTYPE(\n    ULONG,                                      # Return type\n    TRACEHANDLE,                                # TRACEHANDLE TraceHandle\n    ctypes.POINTER(GUID),                       # LPCGUID ProviderId\n    ULONG,                                      # ULONG ControlCode\n    UCHAR,                                      # UCHAR Level,\n    ULONGLONG,                                  # ULONGLONG MatchAnyKeyword\n    ULONGLONG,                                  # ULONGLONG MatchAllKeyword", "    ULONGLONG,                                  # ULONGLONG MatchAnyKeyword\n    ULONGLONG,                                  # ULONGLONG MatchAllKeyword\n    ULONG,                                      # Timeout\n    LPVOID,                                     # PENABLE_TRACE_PARAMETERS EnableParameters (not supported yet)\n    # ctypes.POINTER(ENABLE_TRACE_PARAMETERS),\n)((\"EnableTraceEx2\", ADVAPI32_DLL))\n\n\n########\n# Eztw", "########\n# Eztw\n\n# https://learn.microsoft.com/en-us/windows/win32/api/evntrace/ns-evntrace-event_trace_properties\nclass TraceProperties:\n    \"\"\"\n    A utility class to wrap usage of the EVENT_TRACE_PROPERTIES structure.\n    Currently only suitable for real-time trace session.\n    \"\"\"\n\n    MAX_LOGFILENAME_LEN = 1024\n    BUFFER_SIZE = (ctypes.sizeof(EVENT_TRACE_PROPERTIES) + 2 * ctypes.sizeof(ctypes.c_wchar) * MAX_LOGFILENAME_LEN)\n\n    def __init__(self):\n        self._buf = (ctypes.c_byte * self.BUFFER_SIZE)()\n        self.properties = ctypes.cast(ctypes.pointer(self._buf), ctypes.POINTER(EVENT_TRACE_PROPERTIES))\n        self.properties.contents.Wnode.BufferSize = self.BUFFER_SIZE\n        self.properties.contents.Wnode.Flags = WNODE_FLAG_TRACED_GUID\n        self.properties.contents.LoggerNameOffset = ctypes.sizeof(EVENT_TRACE_PROPERTIES)\n        self.properties.contents.LogFileNameOffset = (ctypes.sizeof(EVENT_TRACE_PROPERTIES) +\n                                                      ctypes.sizeof(ctypes.c_wchar) * self.MAX_LOGFILENAME_LEN)\n        self.properties.contents.LogFileMode = EVENT_TRACE_REAL_TIME_MODE\n        # TODO: allow customizing these values\n        self.properties.contents.BufferSize = 32\n        self.properties.contents.MinimumBuffers = 8", "\n\nclass EztwController:\n    \"\"\"\n    Create and manage a real-time trace session, as well as enable providers by config.\n    \"\"\"\n    def __init__(self, session_name: str, providers_config: EztwProviderConfig | list[EztwProviderConfig]):\n        \"\"\"\n        @param session_name: the name of the new trace\n        @param providers_config: a list of EztwProviderConfig or a single EztwProviderConfig\n        \"\"\"\n        self.session_handle = None\n        self.session_name = session_name\n        self.providers_config = as_list(providers_config)\n        assert self.providers_config  # Make sure we have at least one provider\n\n    def __del__(self):\n        self.stop()\n\n    def start(self):\n        \"\"\"\n        Start a new session or if one with the same name already exists - attempt to stop it first and then\n        start the new session.\n        \"\"\"\n        if self.session_handle is not None:\n            return\n        # Allocate a new trace handle\n        trace_handle = TRACEHANDLE()\n        LOGGER.info(f\"Starting trace session {self.session_name!r}...\")\n        trace_properties = TraceProperties()\n        # Call StartTrace\n        rc = StartTrace(ctypes.byref(trace_handle), self.session_name, trace_properties.properties)\n        if rc == winerror.ERROR_ALREADY_EXISTS:\n            # This error code means a session with this name already exists - try to stop and start again\n            LOGGER.warning(\n                f\"Session {self.session_name!r} already exists. Trying to stop and start a new session\")\n            trace_properties = TraceProperties()\n            rc = ControlTrace(0, self.session_name, trace_properties.properties, EVENT_TRACE_CONTROL_STOP)\n            if rc != winerror.ERROR_SUCCESS:\n                raise EztwControllerException(\n                    f\"ControlTrace failed for session {self.session_name!r} with error {rc}\")\n            # Try again\n            trace_properties = TraceProperties()\n            rc = StartTrace(ctypes.byref(trace_handle), self.session_name, trace_properties.properties)\n        if rc != winerror.ERROR_SUCCESS:\n            raise EztwControllerException(\n                f\"StartTrace failed for session {self.session_name!r} with error {rc}\")\n        # Success!\n        self.session_handle = trace_handle\n        # Enable providers\n        for provider_config in self.providers_config:\n            LOGGER.info(f\"Enabling provider {provider_config.guid} keywords={hex(provider_config.keywords)}\")\n            self.enable_provider(provider_config.guid, provider_config.keywords, provider_config.level)\n\n    def stop(self):\n        if self.session_handle is None:\n            return\n        LOGGER.info(f\"Stopping trace session {self.session_name!r}\")\n        trace_properties = TraceProperties()\n        rc = ControlTrace(self.session_handle, None, trace_properties.properties, EVENT_TRACE_CONTROL_STOP)\n        if rc == winerror.ERROR_WMI_INSTANCE_NOT_FOUND:\n            # Session no longer exists...\n            pass\n        elif rc != winerror.ERROR_SUCCESS:\n            raise EztwControllerException(\n                f\"ControlTrace failed for session {self.session_name!r} with error {rc}\")\n        self.session_handle = None\n\n    def enable_provider(self, provider_guid: str, keywords: int, level: int):\n        # TODO: support filters, stack trace and other advanced features\n        # etp = ENABLE_TRACE_PARAMETERS()\n        # etp.Version = ENABLE_TRACE_PARAMETERS_VERSION_2\n        # etp.FilterDescCount = 0\n        provider_guid_struct = GUID(provider_guid)\n        rc = EnableTraceEx2(\n                self.session_handle,\n                ctypes.byref(provider_guid_struct),\n                EVENT_CONTROL_CODE_ENABLE_PROVIDER,\n                level,\n                keywords,\n                0,\n                win32event.INFINITE,\n                None,  # ctypes.byref(etp),\n            )\n        if rc != winerror.ERROR_SUCCESS:\n            raise EztwControllerException(\n                f\"EnableTraceEx2 failed for session {self.session_name!r} for provider {provider_guid}\"\n                f\" with error {rc}\")\n\n    def __enter__(self):\n        self.start()\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.stop()", ""]}
{"filename": "eztw/consumer.py", "chunked_list": ["\"\"\"\nImplementation of EztwConsumer, which allows consuming real time event records from an existing\nreal-time trace session.\n\"\"\"\nimport ctypes\nimport queue\nimport time\nimport threading\nimport contextlib\nimport win32api", "import contextlib\nimport win32api\nimport winerror\n\nfrom .log import LOGGER\nfrom .guid import GUID\nfrom .common import UCHAR, USHORT, ULONG, LPWSTR, LARGE_INTEGER, ULARGE_INTEGER, LPVOID, LONG, WCHAR, FILETIME, \\\n    FILETIME_to_time, EztwException, SYSTEMTIME\nfrom .trace_common import ADVAPI32_DLL, TRACEHANDLE, INVALID_TRACE_HANDLE\n", "from .trace_common import ADVAPI32_DLL, TRACEHANDLE, INVALID_TRACE_HANDLE\n\n\nclass EztwConsumerException(EztwException):\n    \"\"\"A trace consumer error\"\"\"\n\n\n########\n# WINAPI\n", "# WINAPI\n\n# https://learn.microsoft.com/en-us/windows/win32/api/evntrace/ns-evntrace-event_trace_logfilea\nPROCESS_TRACE_MODE_REAL_TIME = 0x00000100\nPROCESS_TRACE_MODE_EVENT_RECORD = 0x10000000\n\n# https://learn.microsoft.com/en-us/windows/win32/api/evntrace/ns-evntrace-event_trace_header\nclass EVENT_TRACE_HEADER_CLASS(ctypes.Structure):\n    _fields_ = [('Type', UCHAR),\n                ('Level', UCHAR),\n                ('Version', USHORT)]", "\n# https://learn.microsoft.com/en-us/windows/win32/api/evntrace/ns-evntrace-event_trace_header\nclass EVENT_TRACE_HEADER(ctypes.Structure):\n    _fields_ = [('Size', USHORT),\n                ('HeaderType', UCHAR),\n                ('MarkerFlags', UCHAR),\n                ('Class', EVENT_TRACE_HEADER_CLASS),\n                ('ThreadId', ULONG),\n                ('ProcessId', ULONG),\n                ('TimeStamp', LARGE_INTEGER),\n                ('Guid', GUID),\n                ('ClientContext', ULONG),\n                ('Flags', ULONG)]", "\n# https://learn.microsoft.com/en-us/windows/win32/api/evntrace/ns-evntrace-event_trace\nclass EVENT_TRACE(ctypes.Structure):\n    _fields_ = [('Header', EVENT_TRACE_HEADER),\n                ('InstanceId', ULONG),\n                ('ParentInstanceId', ULONG),\n                ('ParentGuid', GUID),\n                ('MofData', LPVOID),\n                ('MofLength', ULONG),\n                ('ClientContext', ULONG)]", "\n# https://learn.microsoft.com/en-us/windows/win32/api/evntprov/ns-evntprov-event_descriptor\nclass EVENT_DESCRIPTOR(ctypes.Structure):\n    _fields_ = [('Id', USHORT),\n                ('Version', UCHAR),\n                ('Channel', UCHAR),\n                ('Level', UCHAR),\n                ('Opcode', UCHAR),\n                ('Task', USHORT),\n                ('Keyword', ULARGE_INTEGER)]", "\n# https://learn.microsoft.com/en-us/windows/win32/api/evntcons/ns-evntcons-event_header\nclass EVENT_HEADER(ctypes.Structure):\n    _fields_ = [('Size', USHORT),\n                ('HeaderType', USHORT),\n                ('Flags', USHORT),\n                ('EventProperty', USHORT),\n                ('ThreadId', ULONG),\n                ('ProcessId', ULONG),\n                ('TimeStamp', ULARGE_INTEGER),\n                ('ProviderId', GUID),\n                ('EventDescriptor', EVENT_DESCRIPTOR),\n                ('KernelTime', ULONG),\n                ('UserTime', ULONG),\n                ('ActivityId', GUID)]", "\n# https://learn.microsoft.com/en-us/windows/win32/api/evntrace/ns-evntrace-etw_buffer_context\nclass ETW_BUFFER_CONTEXT(ctypes.Structure):\n    _fields_ = [('ProcessorNumber', UCHAR),\n                ('Alignment', UCHAR),\n                ('LoggerId', USHORT)]\n\n# https://learn.microsoft.com/en-us/windows/win32/api/evntcons/ns-evntcons-event_header_extended_data_item\nclass EVENT_HEADER_EXTENDED_DATA_ITEM(ctypes.Structure):\n    _fields_ = [('Reserved1', USHORT),\n                ('ExtType', USHORT),\n                ('Reserved2', ULONG),\n                ('DataSize', USHORT),\n                ('DataPtr', ULARGE_INTEGER)]", "class EVENT_HEADER_EXTENDED_DATA_ITEM(ctypes.Structure):\n    _fields_ = [('Reserved1', USHORT),\n                ('ExtType', USHORT),\n                ('Reserved2', ULONG),\n                ('DataSize', USHORT),\n                ('DataPtr', ULARGE_INTEGER)]\n\n# https://learn.microsoft.com/en-us/windows/win32/api/evntcons/ns-evntcons-event_record\nclass EVENT_RECORD(ctypes.Structure):\n    _fields_ = [('EventHeader', EVENT_HEADER),\n                ('BufferContext', ETW_BUFFER_CONTEXT),\n                ('ExtendedDataCount', USHORT),\n                ('UserDataLength', USHORT),\n                ('ExtendedData', ctypes.POINTER(EVENT_HEADER_EXTENDED_DATA_ITEM)),\n                ('UserData', LPVOID),\n                ('UserContext', LPVOID)]", "class EVENT_RECORD(ctypes.Structure):\n    _fields_ = [('EventHeader', EVENT_HEADER),\n                ('BufferContext', ETW_BUFFER_CONTEXT),\n                ('ExtendedDataCount', USHORT),\n                ('UserDataLength', USHORT),\n                ('ExtendedData', ctypes.POINTER(EVENT_HEADER_EXTENDED_DATA_ITEM)),\n                ('UserData', LPVOID),\n                ('UserContext', LPVOID)]\n\nclass TIME_ZONE_INFORMATION(ctypes.Structure):\n    _fields_ = [('Bias', LONG),\n                ('StandardName', WCHAR * 32),\n                ('StandardDate', SYSTEMTIME),\n                ('StandardBias', LONG),\n                ('DaylightName', WCHAR * 32),\n                ('DaylightDate', SYSTEMTIME),\n                ('DaylightBias', LONG)]", "\nclass TIME_ZONE_INFORMATION(ctypes.Structure):\n    _fields_ = [('Bias', LONG),\n                ('StandardName', WCHAR * 32),\n                ('StandardDate', SYSTEMTIME),\n                ('StandardBias', LONG),\n                ('DaylightName', WCHAR * 32),\n                ('DaylightDate', SYSTEMTIME),\n                ('DaylightBias', LONG)]\n", "\n# https://learn.microsoft.com/en-us/windows/win32/api/evntrace/ns-evntrace-trace_logfile_header\nclass TRACE_LOGFILE_HEADER(ctypes.Structure):\n    _fields_ = [('BufferSize', ULONG),\n                ('MajorVersion', UCHAR),\n                ('MinorVersion', UCHAR),\n                ('SubVersion', UCHAR),\n                ('SubMinorVersion', UCHAR),\n                ('ProviderVersion', ULONG),\n                ('NumberOfProcessors', ULONG),\n                ('EndTime', LARGE_INTEGER),\n                ('TimerResolution', ULONG),\n                ('MaximumFileSize', ULONG),\n                ('LogFileMode', ULONG),\n                ('BuffersWritten', ULONG),\n                ('StartBuffers', ULONG),\n                ('PointerSize', ULONG),\n                ('EventsLost', ULONG),\n                ('CpuSpeedInMHz', ULONG),\n                ('LoggerName', LPWSTR),\n                ('LogFileName', LPWSTR),\n                ('TimeZone', TIME_ZONE_INFORMATION),\n                ('BootTime', LARGE_INTEGER),\n                ('PerfFreq', LARGE_INTEGER),\n                ('StartTime', LARGE_INTEGER),\n                ('ReservedFlags', ULONG),\n                ('BuffersLost', ULONG)]", "\n# This must be \"forward declared\", because of the EVENT_TRACE_BUFFER_CALLBACK definition...\nclass EVENT_TRACE_LOGFILE(ctypes.Structure):\n    pass\n\n# The type for event trace callbacks.\nEVENT_CALLBACK = ctypes.WINFUNCTYPE(None, ctypes.POINTER(EVENT_TRACE))\nEVENT_RECORD_CALLBACK = ctypes.WINFUNCTYPE(None, ctypes.POINTER(EVENT_RECORD))\nEVENT_TRACE_BUFFER_CALLBACK = ctypes.WINFUNCTYPE(ULONG, ctypes.POINTER(EVENT_TRACE_LOGFILE))\n\nclass EVENT_CALLBACK_UNION(ctypes.Union):\n    _fields_ = [('EventCallback', EVENT_CALLBACK),\n                ('EventRecordCallback', EVENT_RECORD_CALLBACK)]", "EVENT_TRACE_BUFFER_CALLBACK = ctypes.WINFUNCTYPE(ULONG, ctypes.POINTER(EVENT_TRACE_LOGFILE))\n\nclass EVENT_CALLBACK_UNION(ctypes.Union):\n    _fields_ = [('EventCallback', EVENT_CALLBACK),\n                ('EventRecordCallback', EVENT_RECORD_CALLBACK)]\n\nEVENT_TRACE_LOGFILE._fields_ = [\n    ('LogFileName', LPWSTR),\n    ('LoggerName', LPWSTR),\n    ('CurrentTime', LARGE_INTEGER),", "    ('LoggerName', LPWSTR),\n    ('CurrentTime', LARGE_INTEGER),\n    ('BuffersRead', ULONG),\n    ('ProcessTraceMode', ULONG),\n    ('CurrentEvent', EVENT_TRACE),\n    ('LogfileHeader', TRACE_LOGFILE_HEADER),\n    ('BufferCallback', EVENT_TRACE_BUFFER_CALLBACK),\n    ('BufferSize', ULONG),\n    ('Filled', ULONG),\n    ('EventsLost', ULONG),", "    ('Filled', ULONG),\n    ('EventsLost', ULONG),\n    ('EventCallback', EVENT_CALLBACK_UNION),\n    ('IsKernelTrace', ULONG),\n    ('Context', LPVOID)]\n\n# https://learn.microsoft.com/en-us/windows/win32/api/evntrace/nf-evntrace-opentracew\nOpenTrace = ctypes.WINFUNCTYPE(\n    TRACEHANDLE,                            # Return type\n    ctypes.POINTER(EVENT_TRACE_LOGFILE),    # PEVENT_TRACE_LOGFILEW Logfile", "    TRACEHANDLE,                            # Return type\n    ctypes.POINTER(EVENT_TRACE_LOGFILE),    # PEVENT_TRACE_LOGFILEW Logfile\n)((\"OpenTraceW\", ADVAPI32_DLL))\n\n# https://learn.microsoft.com/en-us/windows/win32/api/evntrace/nf-evntrace-processtrace\nProcessTrace = ctypes.WINFUNCTYPE(\n    ULONG,                          # Return type\n    ctypes.POINTER(TRACEHANDLE),    # PTRACEHANDLE HandleArray,\n    ULONG,                          # ULONG HandleCount\n    ctypes.POINTER(FILETIME),       # LPFILETIME StartTime", "    ULONG,                          # ULONG HandleCount\n    ctypes.POINTER(FILETIME),       # LPFILETIME StartTime\n    ctypes.POINTER(FILETIME),       # LPFILETIME EndTime\n)((\"ProcessTrace\", ADVAPI32_DLL))\n\n# https://learn.microsoft.com/en-us/windows/win32/api/evntrace/nf-evntrace-closetrace\nCloseTrace = ctypes.WINFUNCTYPE(\n    ULONG,          # Return type\n    TRACEHANDLE,    # TRACEHANDLE TraceHandle\n)((\"CloseTrace\", ADVAPI32_DLL))", "    TRACEHANDLE,    # TRACEHANDLE TraceHandle\n)((\"CloseTrace\", ADVAPI32_DLL))\n\n\n########\n# Eztw\n\nclass EventRecord:\n    \"\"\"\n    A single ETW event record, with header fields shared by all ETW events.\n    \"\"\"\n    def __init__(self, event_record: EVENT_RECORD, is_64bit: bool):\n        self.is_64bit = is_64bit\n        header = event_record.contents.EventHeader\n        descriptor = header.EventDescriptor\n        self.provider_guid = str(header.ProviderId)\n        # Old-style events have their actual ID in the 'opcode' field for some reason\n        self.id = descriptor.Id if descriptor.Id > 0 else descriptor.Opcode\n        self.version = descriptor.Version\n        self.keywords = descriptor.Keyword\n        self.process_id = header.ProcessId\n        self.thread_id = header.ThreadId\n        # Sometimes the TimeStamp is 0 - prevent weird behavior for negative timestamps\n        self.timestamp = FILETIME_to_time(header.TimeStamp) if header.TimeStamp > 0 else 0\n        # Read event data\n        if event_record.contents.UserData:\n            self.data = ctypes.string_at(event_record.contents.UserData, event_record.contents.UserDataLength)\n        else:\n            self.data = bytes()\n\n    def __str__(self):\n        return f\"{self.__class__.__name__}(provider_guid={self.provider_guid}, id={self.id}, \" \\\n               f\"version={self.version}, process_id={self.process_id}, timestamp={time.ctime(self.timestamp)})\"\n\n    __repr__ = __str__\n\n    def __hash__(self):\n        \"\"\"The event is uniquely identified via its provider GUID and event ID\"\"\"\n        return hash((self.provider_guid, self.id))", "\n\nclass EztwConsumer:\n    \"\"\"\n    Real-time consumer of an existing ETW trace.\n    Simply provider an existing session name.\n    \"\"\"\n    def __init__(self, session_name: str):\n        self.session_handle = None\n        self.session_name = session_name\n        self._buffer_callback = EVENT_TRACE_BUFFER_CALLBACK(self._buffer_callback)\n        #self._event_callback = EVENT_CALLBACK(self._event_callback) # Old format, unsupported\n        self._event_record_callback = EVENT_RECORD_CALLBACK(self.event_record_callback)\n        # Bitness is unknown at first - assume 32 (will be set after OpenTrace is called)\n        self.is_64bit = False\n        self.consumer_thread = None\n        # Safeguard against memory gulping if no events are consumed for a long time\n        self.events_queue = queue.Queue(maxsize=1000000)\n        # Since ProcessTrace is blocking, this allows to stop the trace\n        self.stop_event = threading.Event()\n        # Since we may want to stop either explicitly (calling stop) or implicitly (session is closed)\n        # from two different threads, we must protect ourselves\n        self.stop_lock = threading.Lock()\n        # Keep a reference to CloseTrace, so we don't lose it in the dtor if the interpreter exits unexpectedly\n        self.CloseTrace = CloseTrace\n\n    def __del__(self):\n        self.close_session()\n\n    def open_session(self):\n        # Create and initialize EVENT_TRACE_LOGFILE\n        logfile = EVENT_TRACE_LOGFILE()\n        logfile.LoggerName = self.session_name\n        # This session must be real-time. Event records are to be consumed (i.e: \"new-style\", Vista and above)\n        logfile.ProcessTraceMode = PROCESS_TRACE_MODE_REAL_TIME | PROCESS_TRACE_MODE_EVENT_RECORD\n        logfile.BufferCallback = self._buffer_callback\n        logfile.EventCallback.EventRecordCallback = self._event_record_callback\n        # Attempt to open an existing trace session\n        th = OpenTrace(ctypes.byref(logfile))\n        if th == INVALID_TRACE_HANDLE:\n            raise EztwConsumerException(\n                f\"OpenTrace failed for session {self.session_name!r} with error {win32api.GetLastError()}\")\n        self.session_handle = TRACEHANDLE(th)\n        # Now we can determine the pointer size (though we only support 64bit for now)\n        self.is_64bit = (logfile.LogfileHeader.PointerSize == 8)\n\n    def close_session(self):\n        if self.session_handle is None:\n            return\n        LOGGER.info(f\"Closing trace consumer for session {self.session_name!r}\")\n        rc = self.CloseTrace(self.session_handle)\n        if rc not in [winerror.ERROR_SUCCESS, winerror.ERROR_CTX_CLOSE_PENDING]:\n            raise EztwConsumerException(\n                f\"CloseTrace failed for session {self.session_name!r} with error {rc}\")\n        self.session_handle = None\n\n    def _buffer_callback(self, _buffer):\n        # Basically, do nothing unless explicitly ordered to stop\n        # According to https://learn.microsoft.com/en-us/windows/win32/api/evntrace/ns-evntrace-event_trace_logfilea\n        # this if this function returns 0, the ProcessTrace loop stops\n        if self.stop_event.is_set():\n            return 0\n        else:\n            return 1\n\n    def event_record_callback(self, event_record: EVENT_RECORD):\n        # Called for each event - new format (Windows-Vista and above)\n        # Drop events if queue is full\n        if not self.events_queue.full():\n            self.events_queue.put(EventRecord(event_record, self.is_64bit))\n\n    def consume(self):\n        try:\n            # If successful, this function blocks the current thread until stopped\n            rc = ProcessTrace(ctypes.byref(self.session_handle), 1, None, None)\n            if rc == winerror.ERROR_WMI_INSTANCE_NOT_FOUND:\n                raise EztwConsumerException(f\"Session {self.session_name!r} does not exist\")\n            if rc != winerror.ERROR_SUCCESS:\n                raise EztwConsumerException(\n                    f\"ProcessTrace failed for session {self.session_name!r} with error {rc}\")\n        finally:\n            self._stop()\n\n    def start(self):\n        if self.session_handle is not None:\n            return\n        self.stop_event.clear()\n        self.open_session()\n        # Consume event in a separate thread, since ProcessTrace is blocking. Events are put in a queue\n        self.consumer_thread = threading.Thread(target=self.consume, daemon=True)\n        self.consumer_thread.start()\n\n    def _stop(self):\n        with self.stop_lock:\n            if self.session_handle is None:\n                return\n            self.stop_event.set()\n            self.close_session()\n            self.session_handle = None\n\n    def stop(self):\n        self._stop()\n        if self.consumer_thread is not None:\n            self.consumer_thread.join()\n            self.consumer_thread = None\n\n    def pending_events(self) -> int:\n        \"\"\"\n        @return: number of currently pending event records\n        \"\"\"\n        return self.events_queue.qsize()\n\n    def get_event(self, timeout: float = 0.1) -> EventRecord | None:\n        \"\"\"\n        Wait for the next event record up to timeout\n\n        @param timeout: timeout in seconds\n        @return: EventRecord or None (on timeout)\n        \"\"\"\n        try:\n            return self.events_queue.get(timeout=timeout)\n        except queue.Empty:\n            return None\n\n    def wait_for_events(self, how_long: float) -> list[EventRecord]:\n        \"\"\"\n        Read all currently available events and optionally wait some more for new events\n\n        @param how_long: time to wait in seconds\n        @return: list of EventRecord\n        \"\"\"\n        start_time = time.time()\n        events = []\n        while (remaining_time := (start_time + how_long - time.time())) > 0:\n            try:\n                events.append(self.events_queue.get(timeout=remaining_time))\n            except queue.Empty:\n                break\n        return events\n\n    def __iter__(self):\n        \"\"\"\n        Iterate over all events forever (or until stopped).\n        Implicitly suppresses (but aborts on) keyboard interrupts (Ctrl+C).\n        If the session is externally closed (for example, using the logman.exe tool), the iteration stops.\n        \"\"\"\n        with self:\n            with contextlib.suppress(KeyboardInterrupt):\n                while True:\n                    if self.stop_event.is_set():\n                        break\n                    event_record = self.get_event()\n                    if event_record is not None:\n                        yield event_record\n\n    def __enter__(self):\n        self.start()\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.stop()", ""]}
{"filename": "eztw/trace_common.py", "chunked_list": ["\"\"\"\nVarious trace-specific common stuff.\n\"\"\"\nimport ctypes\nimport time\nfrom enum import Enum\nfrom dataclasses import dataclass\n\nfrom .guid import canonize_GUID\n", "from .guid import canonize_GUID\n\n# Represents a trace handle\nTRACEHANDLE = ctypes.c_uint64\n\n# This indicates an invalid trace handle\nINVALID_TRACE_HANDLE = 0xffffffffffffffff\n\n# Many functions are required from this DLL\nADVAPI32_DLL = ctypes.windll.advapi32", "# Many functions are required from this DLL\nADVAPI32_DLL = ctypes.windll.advapi32\n\n# https://learn.microsoft.com/en-us/windows/win32/api/evntrace/nf-evntrace-enabletrace\nTRACE_LEVEL_CRITICAL = 1\nTRACE_LEVEL_ERROR = 2\nTRACE_LEVEL_WARNING = 3\nTRACE_LEVEL_INFORMATION = 4\nTRACE_LEVEL_VERBOSE = 5\n", "TRACE_LEVEL_VERBOSE = 5\n\nMSNT_SystemTrace_GUID = canonize_GUID(\"{68fdd900-4a3e-11d1-84f4-0000f80464e3}\")\n\n# This special GUID indicates lost events\n# https://learn.microsoft.com/en-us/windows/win32/etw/lost-event\nLOST_EVENTS_GUID = canonize_GUID(\"{6a399ae0-4bc6-4de9-870b-3657f8947e7e}\")\n\nMAX_KEYWORDS = 0xffffffffffffffff\n", "MAX_KEYWORDS = 0xffffffffffffffff\n\n\n# https://learn.microsoft.com/en-us/windows/win32/api/tdh/ne-tdh-decoding_source\nclass PROVIDER_DECODING_SOURCE(Enum):\n    DecodingSourceXMLFile = 0\n    DecodingSourceWbem = 1\n    DecodingSourceWPP = 2\n    DecodingSourceTlg = 3\n    DecodingSourceMax = 4", "\n\n# https://learn.microsoft.com/en-us/windows/win32/api/tdh/ne-tdh-_tdh_in_type\nclass EVENT_FIELD_INTYPE(Enum):\n    INTYPE_NULL = 0\n    INTYPE_UNICODESTRING = 1\n    INTYPE_ANSISTRING = 2\n    INTYPE_INT8 = 3\n    INTYPE_UINT8 = 4\n    INTYPE_INT16 = 5\n    INTYPE_UINT16 = 6\n    INTYPE_INT32 = 7\n    INTYPE_UINT32 = 8\n    INTYPE_INT64 = 9\n    INTYPE_UINT64 = 10\n    INTYPE_FLOAT = 11\n    INTYPE_DOUBLE = 12\n    INTYPE_BOOLEAN = 13\n    INTYPE_BINARY = 14\n    INTYPE_GUID = 15\n    INTYPE_POINTER = 16\n    INTYPE_FILETIME = 17\n    INTYPE_SYSTEMTIME = 18\n    INTYPE_SID = 19\n    INTYPE_HEXINT32 = 20\n    INTYPE_HEXINT64 = 21\n    INTYPE_MANIFEST_COUNTEDSTRING = 22\n    INTYPE_MANIFEST_COUNTEDANSISTRING = 23\n    INTYPE_RESERVED24 = 24\n    INTYPE_MANIFEST_COUNTEDBINARY = 25\n    INTYPE_COUNTEDSTRING = 26\n    INTYPE_COUNTEDANSISTRING = 27\n    INTYPE_REVERSEDCOUNTEDSTRING = 28\n    INTYPE_REVERSEDCOUNTEDANSISTRING = 29\n    INTYPE_NONNULLTERMINATEDSTRING = 30\n    INTYPE_NONNULLTERMINATEDANSISTRING = 31\n    INTYPE_UNICODECHAR = 32\n    INTYPE_ANSICHAR = 33\n    INTYPE_SIZET = 34\n    INTYPE_HEXDUMP = 35\n    INTYPE_WBEMSID = 36", "\n# For those sneaky undocumented ones, keep the max known value\nEVENT_FIELD_INTYPE_MAX_VALUE = max([x.value for x in EVENT_FIELD_INTYPE.__members__.values()])\n\n\n@dataclass\nclass ProviderMetadata:\n    \"\"\"\n    Represents the metadata of a single provider - guid, name and \"decoding source\" (usually XML schema)\n    \"\"\"\n    guid: str\n    name: str\n    schema: PROVIDER_DECODING_SOURCE", "\n\n@dataclass\nclass EventFieldMetadata:\n    \"\"\"\n    Represents a single event's field - name, type and optional length/count fields\n    \"\"\"\n    name: str\n    type: EVENT_FIELD_INTYPE\n    # Either the name of the field that holds the byte size of this field, or None\n    length: str | int | None = None\n    # Either the name of the field that holds the count of this fild, or None\n    count: str | int | None = None", "\n\n@dataclass\nclass EventMetadata:\n    \"\"\"\n    Represents a single event - provider GUID, ID, version, name (optional), keyword and a list of TdhEventField\n    \"\"\"\n    provider_guid: str\n    id: int\n    version: int\n    name: str\n    keyword: int\n    fields: list[EventFieldMetadata]", "\ndef ad_hoc_session_name():\n    return f\"EZTW_TRACE_SESSION_{int(time.time())}\"\n"]}
{"filename": "eztw/common.py", "chunked_list": ["\"\"\"\nVarious definitions and functions used throughout eztw.\n\"\"\"\nimport re\nimport datetime\nimport ctypes.wintypes\n\n# Simplify windows types and add some missing ones\nUCHAR = ctypes.c_uint8\nUSHORT = ctypes.c_ushort", "UCHAR = ctypes.c_uint8\nUSHORT = ctypes.c_ushort\nULONG = ctypes.c_ulong\nULONGLONG = ctypes.c_ulonglong\nLPVOID = ctypes.c_void_p\nLONG = ctypes.wintypes.LONG\nWCHAR = ctypes.wintypes.WCHAR\nULARGE_INTEGER = ctypes.wintypes.ULARGE_INTEGER\nLARGE_INTEGER = ctypes.wintypes.LARGE_INTEGER\nHANDLE = ctypes.wintypes.HANDLE", "LARGE_INTEGER = ctypes.wintypes.LARGE_INTEGER\nHANDLE = ctypes.wintypes.HANDLE\nLPWSTR = ctypes.wintypes.LPWSTR\nFILETIME = ctypes.wintypes.FILETIME\n\n# The number of seconds between 01-01-1601 and 01-01-1970\nFILETIME_EPOCH_DELTA_S = 11644473600\n# Multiplier to convert from units of 100ns to seconds\nFILETIME_TO_SECONDS_MULTIPLIER = 1.0/10000000.0\n\ndef FILETIME_to_time(ft):\n    return (ft * FILETIME_TO_SECONDS_MULTIPLIER) - FILETIME_EPOCH_DELTA_S", "FILETIME_TO_SECONDS_MULTIPLIER = 1.0/10000000.0\n\ndef FILETIME_to_time(ft):\n    return (ft * FILETIME_TO_SECONDS_MULTIPLIER) - FILETIME_EPOCH_DELTA_S\n\nclass SYSTEMTIME(ctypes.Structure):\n    _fields_ = [('wYear', USHORT),\n                ('wMonth', USHORT),\n                ('wDayOfWeek', USHORT),\n                ('wDay', USHORT),\n                ('wHour', USHORT),\n                ('wMinute', USHORT),\n                ('wSecond', USHORT),\n                ('wMilliseconds', USHORT)]", "\ndef SYSTEMTIME_to_time(st):\n    # datetime accepts microseconds - multiply milliseconds by 1000\n    dt = datetime.datetime(st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds * 1000)\n    return dt.timestamp()\n\ndef as_list(x):\n    \"\"\"\n    Ensure that the returned value is a list, whether the input is a list or not\n    \"\"\"\n    # If this is a list, simply return\n    if isinstance(x, list):\n        return x\n    # If this object is iterable, but is not a string/bytes - convert it to list\n    if hasattr(x, \"__iter__\") and not isinstance(x, (str, bytes, bytearray)):\n        return list(x)\n    # Wrap x as a list and return\n    return [x]", "\ndef sanitize_name(name: str, replacement=\"_\") -> str:\n    \"\"\"Replace invalid characters with underscores\"\"\"\n    return re.sub(r\"\\W+\", replacement, name)\n\n\nclass EztwException(Exception):\n    \"\"\"Generic base class for other eztw exceptions\"\"\"\n", ""]}
{"filename": "eztw/tdh.py", "chunked_list": ["\"\"\"\nWrapper for the WinAPI of TDH (Trace Data Helper) functions:\nSee https://learn.microsoft.com/en-us/windows/win32/api/tdh/\n\nExposes two functions:\n\ntdh_enumerate_providers:\n    Returns a list of all locally registered ETW provider, each as a TdhProvider dataclass\ntdh_get_provider_events:\n    Given a provider GUID, returns a list of the provider's events as a list of TdhEvent dataclass", "tdh_get_provider_events:\n    Given a provider GUID, returns a list of the provider's events as a list of TdhEvent dataclass\n\"\"\"\nimport ctypes\nimport winerror\nfrom functools import cache\n\nfrom .common import UCHAR, USHORT, ULONG, ULONGLONG, LPVOID, sanitize_name, EztwException\nfrom .trace_common import EVENT_FIELD_INTYPE, ProviderMetadata, PROVIDER_DECODING_SOURCE, EventMetadata, \\\n    EVENT_FIELD_INTYPE_MAX_VALUE, EventFieldMetadata", "from .trace_common import EVENT_FIELD_INTYPE, ProviderMetadata, PROVIDER_DECODING_SOURCE, EventMetadata, \\\n    EVENT_FIELD_INTYPE_MAX_VALUE, EventFieldMetadata\nfrom .guid import GUID\n\n\nclass EztwTdhException(EztwException):\n    \"\"\"Represents a TDH error\"\"\"\n\n\n########", "\n########\n# WINAPI\n\nTDH_DLL = ctypes.WinDLL(\"tdh.dll\")\n\ndef read_wstring_at(buf, offset=0):\n    if offset > len(buf):\n        raise EztwTdhException(\"Wchar string out of bounds\")\n    return ctypes.wstring_at(ctypes.addressof(buf) + offset)", "\n\n# https://learn.microsoft.com/en-us/windows/win32/api/tdh/ns-tdh-trace_provider_info\nclass TRACE_PROVIDER_INFO(ctypes.Structure):\n    _fields_ = [('ProviderGuid', GUID),\n                ('SchemaSource', ULONG),\n                ('ProviderNameOffset', ULONG),\n                ]\n\n", "\n\n# https://learn.microsoft.com/en-us/windows/win32/api/tdh/ns-tdh-provider_enumeration_info\nclass PROVIDER_ENUMERATION_INFO(ctypes.Structure):\n    _fields_ = [('NumberOfProviders', ULONG),\n                ('Reserved', ULONG),\n                #('TraceProviderInfoArray', LPVOID), # Ignore array pointer\n                ]\n\n# https://learn.microsoft.com/en-us/windows/win32/api/tdh/nf-tdh-tdhenumerateproviders", "\n# https://learn.microsoft.com/en-us/windows/win32/api/tdh/nf-tdh-tdhenumerateproviders\nTdhEnumerateProviders = ctypes.WINFUNCTYPE(\n    ULONG,                  # Return type\n    LPVOID,                 # PPROVIDER_ENUMERATION_INFO pBuffer\n    ctypes.POINTER(ULONG),  # ULONG *pBufferSize\n)((\"TdhEnumerateProviders\", TDH_DLL))\n\ndef iterate_array_of(buf, offset, cls, array_size):\n    \"\"\"\n    Helper function for iterating over an array of const-size structs\n    \"\"\"\n    assert issubclass(cls, ctypes.Structure)\n    # Start reading at the given offset\n    cur_idx = offset\n    for i in range(array_size):\n        # Calculate the end offset and verify we don't overflow\n        new_idx = cur_idx + ctypes.sizeof(cls)\n        if new_idx > len(buf):\n            raise EztwTdhException(f\"Array of {cls.__name__} out of bounds\")\n        yield cls.from_buffer_copy(buf[cur_idx:new_idx])\n        cur_idx = new_idx", "def iterate_array_of(buf, offset, cls, array_size):\n    \"\"\"\n    Helper function for iterating over an array of const-size structs\n    \"\"\"\n    assert issubclass(cls, ctypes.Structure)\n    # Start reading at the given offset\n    cur_idx = offset\n    for i in range(array_size):\n        # Calculate the end offset and verify we don't overflow\n        new_idx = cur_idx + ctypes.sizeof(cls)\n        if new_idx > len(buf):\n            raise EztwTdhException(f\"Array of {cls.__name__} out of bounds\")\n        yield cls.from_buffer_copy(buf[cur_idx:new_idx])\n        cur_idx = new_idx", "\n\n# https://learn.microsoft.com/en-us/windows/win32/api/evntprov/ns-evntprov-event_descriptor\nclass EVENT_DESCRIPTOR(ctypes.Structure):\n    _fields_ = [('Id', USHORT),\n                ('Version', UCHAR),\n                ('Channel', UCHAR),\n                ('Level', UCHAR),\n                ('Opcode', UCHAR),\n                ('Task', USHORT),\n                ('Keyword', ULONGLONG),\n                ]", "\n\n# https://learn.microsoft.com/en-us/windows/win32/api/tdh/ns-tdh-trace_event_info\nclass TRACE_EVENT_INFO(ctypes.Structure):\n    _fields_ = [('ProviderGuid', GUID),\n                ('EventGuid', GUID),\n                ('EventDescriptor', EVENT_DESCRIPTOR),\n                ('DecodingSource', ULONG),\n                ('ProviderNameOffset', ULONG),\n                ('LevelNameOffset', ULONG),\n                ('ChannelNameOffset', ULONG),\n                ('KeywordsNameOffset', ULONG),\n                ('TaskNameOffset', ULONG),\n                ('OpcodeNameOffset', ULONG),\n                ('EventMessageOffset', ULONG),\n                ('ProviderMessageOffset', ULONG),\n                ('BinaryXMLOffset', ULONG),\n                ('BinaryXMLSize', ULONG),\n                ('EventNameOffset', ULONG),  # Can sometimes mean 'ActivityIDNameOffset'\n                ('EventAttributesOffset', ULONG),  # Can sometimes mean 'RelatedActivityIDNameOffset'\n                ('PropertyCount', ULONG),\n                ('TopLevelPropertyCount', ULONG),\n                ('Flags', ULONG),\n                #('EventPropertyInfoArray', LPVOID), # Ignore array pointer\n                ]", "\n\n# https://learn.microsoft.com/en-us/windows/win32/api/tdh/ns-tdh-provider_event_info\nclass PROVIDER_EVENT_INFO(ctypes.Structure):\n    _fields_ = [('NumberOfEvents', ULONG),\n                ('Reserved', ULONG),\n                #('EventDescriptorsArray', LPVOID), # Ignore array pointer\n                ]\n\n", "\n\n# https://learn.microsoft.com/en-us/windows/win32/api/tdh/ne-tdh-property_flags\nclass TDH_PROPERTY_FLAGS:\n    PropertyStruct = 0x1\n    PropertyParamLength = 0x2\n    PropertyParamCount = 0x4\n    PropertyWBEMXmlFragment = 0x8\n    PropertyParamFixedLength = 0x10\n    PropertyParamFixedCount = 0x20\n    PropertyHasTags = 0x40\n    PropertyHasCustomSchema = 0x80", "\n\n# https://learn.microsoft.com/en-us/windows/win32/api/tdh/ns-tdh-event_property_info\nclass EVENT_PROPERTY_INFO_UNION(ctypes.Structure):\n    _fields_ = [('InType', USHORT),\n                ('OutType', USHORT),\n                ('MapNameOffset', ULONG),\n                ]\n\n\nclass EVENT_PROPERTY_INFO(ctypes.Structure):\n    _fields_ = [('Flags', ULONG),\n                ('NameOffset', ULONG),\n                ('Union', EVENT_PROPERTY_INFO_UNION),\n                ('count', USHORT),      # Can also be countPropertyIndex\n                ('length', USHORT),     # Can also be lengthPropertyIndex\n                ('Reserved', ULONG),    # Can also be Tags\n                ]", "\n\nclass EVENT_PROPERTY_INFO(ctypes.Structure):\n    _fields_ = [('Flags', ULONG),\n                ('NameOffset', ULONG),\n                ('Union', EVENT_PROPERTY_INFO_UNION),\n                ('count', USHORT),      # Can also be countPropertyIndex\n                ('length', USHORT),     # Can also be lengthPropertyIndex\n                ('Reserved', ULONG),    # Can also be Tags\n                ]", "\n# https://learn.microsoft.com/en-us/windows/win32/api/tdh/nf-tdh-tdhenumeratemanifestproviderevents\nTdhEnumerateManifestProviderEvents = ctypes.WINFUNCTYPE(\n    ULONG,                  # Return value\n    ctypes.POINTER(GUID),   # LPGUID ProviderGuid\n    LPVOID,                 # PPROVIDER_EVENT_INFO Buffer\n    ctypes.POINTER(ULONG),  # ULONG *BufferSize\n)((\"TdhEnumerateManifestProviderEvents\", TDH_DLL))\n\n# https://learn.microsoft.com/en-us/windows/win32/api/tdh/nf-tdh-tdhgetmanifesteventinformation", "\n# https://learn.microsoft.com/en-us/windows/win32/api/tdh/nf-tdh-tdhgetmanifesteventinformation\nTdhGetManifestEventInformation = ctypes.WINFUNCTYPE(\n    ULONG,                              # Return value\n    ctypes.POINTER(GUID),               # LPGUID ProviderGuid\n    ctypes.POINTER(EVENT_DESCRIPTOR),   # PEVENT_DESCRIPTOR EventDescriptor\n    LPVOID,                             # PTRACE_EVENT_INFO Buffer\n    ctypes.POINTER(ULONG),              # ULONG *BufferSize\n)((\"TdhGetManifestEventInformation\", TDH_DLL))\n", ")((\"TdhGetManifestEventInformation\", TDH_DLL))\n\n# https://learn.microsoft.com/en-us/windows/win32/api/tdh/ne-tdh-event_field_type\nclass EVENT_FIELD_TYPE:\n    EventKeywordInformation = 0\n    EventLevelInformation = 1\n    EventChannelInformation = 2\n    EventTaskInformation = 3\n    EventOpcodeInformation = 4\n    EventInformationMax = 5", "\n# https://learn.microsoft.com/en-us/windows/win32/api/tdh/ns-tdh-provider_field_info\nclass PROVIDER_FIELD_INFO(ctypes.Structure):\n    _fields_ = [('NameOffset', ULONG),\n                ('DescriptionOffset', ULONG),\n                ('Value', ULONGLONG),\n                ]\n\n# https://learn.microsoft.com/en-us/windows/win32/api/tdh/ns-tdh-provider_field_infoarray\nclass PROVIDER_FIELD_INFOARRAY(ctypes.Structure):\n    _fields_ = [('NumberOfElements', ULONG),\n                ('FieldType', ULONG),\n                #('FieldInfoArray', LPVOID), # Ignore array pointer\n                ]", "# https://learn.microsoft.com/en-us/windows/win32/api/tdh/ns-tdh-provider_field_infoarray\nclass PROVIDER_FIELD_INFOARRAY(ctypes.Structure):\n    _fields_ = [('NumberOfElements', ULONG),\n                ('FieldType', ULONG),\n                #('FieldInfoArray', LPVOID), # Ignore array pointer\n                ]\n\n# https://learn.microsoft.com/en-us/windows/win32/api/tdh/nf-tdh-tdhqueryproviderfieldinformation\nTdhQueryProviderFieldInformation = ctypes.WINFUNCTYPE(\n    ULONG,                  # Return value", "TdhQueryProviderFieldInformation = ctypes.WINFUNCTYPE(\n    ULONG,                  # Return value\n    ctypes.POINTER(GUID),   # LPGUID pGuid\n    ULONGLONG,              # ULONGLONG EventFieldValue\n    ULONG,                  # EVENT_FIELD_TYPE EventFieldType\n    LPVOID,                 # PPROVIDER_FIELD_INFOARRAY pBuffer\n    ctypes.POINTER(ULONG),  # ULONG *pBufferSize\n)((\"TdhQueryProviderFieldInformation\", TDH_DLL))\n\n", "\n\n########\n# Eztw\n\n@cache\ndef tdh_enumerate_providers() -> list[ProviderMetadata]:\n    \"\"\"\n    Invokes TdhEnumerateProviders to get a list of provider metadata. Results are cached.\n\n    @return: list of TdhProvider instances\n    \"\"\"\n    # Call TdhEnumerateProviders with NULL to get the required size (Microsoft-style...)\n    size = ULONG(0)\n    rc = TdhEnumerateProviders(0, ctypes.byref(size))\n    if rc != winerror.ERROR_INSUFFICIENT_BUFFER:\n        raise EztwTdhException(f\"TdhEnumerateProviders failed with error {rc}\")\n    # Call TdhEnumerateProviders again with allocated buffer\n    buf = ctypes.create_string_buffer(size.value)\n    rc = TdhEnumerateProviders(ctypes.byref(buf), ctypes.byref(size))\n    if rc != winerror.ERROR_SUCCESS:\n        raise EztwTdhException(f\"TdhEnumerateProviders failed with error {rc}\")\n    # Parse the PROVIDER_ENUMERATION_INFO struct\n    pei = PROVIDER_ENUMERATION_INFO.from_buffer_copy(buf[:ctypes.sizeof(PROVIDER_ENUMERATION_INFO)])\n    # Get providers info from the array\n    providers = []\n    # Iterate an array of TRACE_PROVIDER_INFO structs\n    for trace_provider_info in iterate_array_of(\n            buf, ctypes.sizeof(PROVIDER_ENUMERATION_INFO), TRACE_PROVIDER_INFO, pei.NumberOfProviders):\n        schema_source = PROVIDER_DECODING_SOURCE(trace_provider_info.SchemaSource)\n        # Add new TdhProvider\n        providers.append(ProviderMetadata(\n            str(trace_provider_info.ProviderGuid),\n            read_wstring_at(buf, trace_provider_info.ProviderNameOffset),\n            schema_source))\n    return providers", "\n@cache\ndef tdh_get_provider_keywords(provider_guid: str) -> dict[str, int]:\n    \"\"\"\n    Given a provider's GUID attempts to return the known keywords of the provider.\n\n    @param provider_guid: a valid GUID string\n    @return: dictionary of keyword name to keyword value\n    \"\"\"\n    provider_guid_struct = GUID(provider_guid)\n    size = ULONG(0)\n    # Call TdhQueryProviderFieldInformation with NULL to get the required size (Microsoft-style...)\n    rc = TdhQueryProviderFieldInformation(ctypes.byref(provider_guid_struct), 0xffffffffffffffff,\n                                          EVENT_FIELD_TYPE.EventKeywordInformation, 0, ctypes.byref(size))\n    if rc != winerror.ERROR_INSUFFICIENT_BUFFER:\n        raise EztwTdhException(\n            f\"TdhQueryProviderFieldInformation failed for provider {provider_guid} with error {rc}\")\n    # Call TdhQueryProviderFieldInformation again with allocated buffer\n    buf = ctypes.create_string_buffer(size.value)\n    rc = TdhQueryProviderFieldInformation(ctypes.byref(provider_guid_struct), 0xffffffffffffffff,\n                                          EVENT_FIELD_TYPE.EventKeywordInformation, ctypes.byref(buf), ctypes.byref(size))\n    if rc != winerror.ERROR_SUCCESS:\n        raise EztwTdhException(\n            f\"TdhQueryProviderFieldInformation failed for provider {provider_guid} with error {rc}\")\n    pfi = PROVIDER_FIELD_INFOARRAY.from_buffer_copy(buf[:ctypes.sizeof(PROVIDER_FIELD_INFOARRAY)])\n    # Enumerate array of PROVIDER_FIELD_INFO\n    keywords = {}\n    for keywords_field_info in iterate_array_of(\n            buf, ctypes.sizeof(PROVIDER_FIELD_INFOARRAY), PROVIDER_FIELD_INFO, pfi.NumberOfElements):\n        keyword_name = sanitize_name(read_wstring_at(buf, keywords_field_info.NameOffset), '_')\n        keywords[keyword_name] = keywords_field_info.Value\n    return keywords", "\n@cache\ndef tdh_get_provider_events(provider_guid: str) -> list[EventMetadata]:\n    \"\"\"\n    Given a provider's GUID attempts to return a list of TdhEvent for this provider using the TDH API.\n    Note that each version of each event is represented as an independent TdhEvent.\n    May raise EztwTdhException if the provider's event info cannot be retrieved using the TDH API.\n\n    @param provider_guid: a valid GUID string\n    @return: list of TdhEvent\n    \"\"\"\n    # Convert the GUID string to a GUID struct\n    provider_guid_struct = GUID(provider_guid)\n    # Call TdhEnumerateManifestProviderEvents with NULL to get the required size (Microsoft-style...)\n    size = ULONG(0)\n    rc = TdhEnumerateManifestProviderEvents(ctypes.byref(provider_guid_struct), 0, ctypes.byref(size))\n    if rc != winerror.ERROR_INSUFFICIENT_BUFFER:\n        raise EztwTdhException(\n            f\"TdhEnumerateManifestProviderEvents failed for provider {provider_guid} with error {rc}\")\n    # Call TdhEnumerateManifestProviderEvents again with allocated buffer\n    buf = ctypes.create_string_buffer(size.value)\n    rc = TdhEnumerateManifestProviderEvents(ctypes.byref(provider_guid_struct), buf, ctypes.byref(size))\n    if rc != winerror.ERROR_SUCCESS:\n        raise EztwTdhException(\n            f\"TdhEnumerateManifestProviderEvents failed for provider {provider_guid} with error {rc}\")\n    # Parse the PROVIDER_EVENT_INFO struct\n    pei = PROVIDER_EVENT_INFO.from_buffer_copy(buf[:ctypes.sizeof(PROVIDER_EVENT_INFO)])\n    # Enumerate array of EVENT_DESCRIPTOR\n    events = []\n    for event_descriptor in iterate_array_of(\n            buf, ctypes.sizeof(PROVIDER_EVENT_INFO), EVENT_DESCRIPTOR, pei.NumberOfEvents):\n        # Call TdhGetManifestEventInformation with NULL to get the required size (Microsoft-style...)\n        event_info_size = ULONG(0)\n        rc = TdhGetManifestEventInformation(\n            ctypes.byref(provider_guid_struct), ctypes.byref(event_descriptor), 0, ctypes.byref(event_info_size))\n        if rc != winerror.ERROR_INSUFFICIENT_BUFFER:\n            raise EztwTdhException(\n                f\"TdhGetManifestEventInformation failed for provider {provider_guid} with error {rc}\")\n        # Call TdhGetManifestEventInformation again with allocated buffer\n        event_info_buf = ctypes.create_string_buffer(event_info_size.value)\n        rc = TdhGetManifestEventInformation(\n            ctypes.byref(provider_guid_struct), ctypes.byref(event_descriptor),\n            event_info_buf, ctypes.byref(event_info_size))\n        if rc != winerror.ERROR_SUCCESS:\n            raise EztwTdhException(\n                f\"TdhGetManifestEventInformation failed for provider {provider_guid} with error {rc}\")\n        # Parse the TRACE_EVENT_INFO struct\n        trace_event_info = TRACE_EVENT_INFO.from_buffer_copy(event_info_buf)\n        # Event ID/version uniquely identify this event in this provider\n        event_id = trace_event_info.EventDescriptor.Id\n        event_version = trace_event_info.EventDescriptor.Version\n        # Event keyword control the consumed events\n        # https://learn.microsoft.com/en-us/windows/win32/api/evntprov/ns-evntprov-event_descriptor\n        event_keyword = trace_event_info.EventDescriptor.Keyword & 0x0000FFFFFFFFFFFF\n        # Take either the event name or task name\n        event_name = None\n        if trace_event_info.EventNameOffset > 0:\n            event_name = read_wstring_at(event_info_buf, trace_event_info.EventNameOffset).rstrip(' ')\n        elif trace_event_info.TaskNameOffset > 0:\n            event_name = read_wstring_at(event_info_buf, trace_event_info.TaskNameOffset).rstrip(' ')\n        # Iterate over event properties array\n        # https://learn.microsoft.com/en-us/windows/win32/etw/retrieving-event-metadata\n        fields = []\n        for event_property_info in iterate_array_of(\n                event_info_buf, ctypes.sizeof(TRACE_EVENT_INFO),\n                EVENT_PROPERTY_INFO, trace_event_info.TopLevelPropertyCount):\n            # Get the field name\n            field_name = sanitize_name(read_wstring_at(event_info_buf, event_property_info.NameOffset), \"\")\n            length_field = None\n            # If this is a fixed-length field - keep the int value\n            if event_property_info.Flags & TDH_PROPERTY_FLAGS.PropertyParamFixedLength:\n                length_field = event_property_info.length\n            # Else if this field's length in bytes is described in another field, record it\n            elif event_property_info.Flags & TDH_PROPERTY_FLAGS.PropertyParamLength:\n                length_index = event_property_info.length\n                if length_index > len(fields):\n                    raise EztwTdhException(\n                        f\"Provider {provider_guid} - {event_name} length field index too high\")\n                length_field = fields[length_index].name\n            count_field = None\n            # If this is a fixed-count field - keep the int value\n            if event_property_info.Flags & TDH_PROPERTY_FLAGS.PropertyParamFixedCount:\n                count_field = event_property_info.count\n            # Else if this field's count (repeated array) is described in another field, record it\n            elif event_property_info.Flags & TDH_PROPERTY_FLAGS.PropertyParamCount:\n                count_index = event_property_info.count\n                if count_index > len(fields):\n                    raise EztwTdhException(\n                        f\"Provider {provider_guid} - {event_name} count field index too high\")\n                count_field = fields[count_index].name\n            # TODO: check other (currently unsupported) flags?\n            # Field type (\"intype\") - if unknown, keep the integer value\n            intype_value = event_property_info.Union.InType\n            if intype_value <= EVENT_FIELD_INTYPE_MAX_VALUE:\n                intype_value = EVENT_FIELD_INTYPE(intype_value)\n            # Append field\n            fields.append(EventFieldMetadata(field_name, intype_value, length_field, count_field))\n        # Append event\n        events.append(EventMetadata(provider_guid, event_id, event_version, event_name, event_keyword, fields))\n    return events", ""]}
{"filename": "eztw/provider.py", "chunked_list": ["\"\"\"\nImplementation of EztwProvider which represents a single provider (and its events).\nImplementation of EztwManager - a utility class for efficiently managing and accessing providers\nby name and GUID.\n\nIn addition, multiple API functions are exposed:\n    get_provider - return EztwProvider by GUID or name\n    get_providers - return a list of all locally registered providers (GUIDs and names)\n    get_provider_config - return the required EztwProviderConfig to enable providers based on desired events\n    add_manual_provider - manually add a new, non-registered provider", "    get_provider_config - return the required EztwProviderConfig to enable providers based on desired events\n    add_manual_provider - manually add a new, non-registered provider\n    parse_event - given an EventRecord, parse it (assuming the provider and its events are known)\n\"\"\"\nfrom collections import defaultdict\nfrom dataclasses import dataclass\n\nfrom .common import sanitize_name, EztwException, as_list\nfrom .trace_common import TRACE_LEVEL_VERBOSE, MSNT_SystemTrace_GUID, MAX_KEYWORDS\nfrom .guid import GUID, canonize_GUID", "from .trace_common import TRACE_LEVEL_VERBOSE, MSNT_SystemTrace_GUID, MAX_KEYWORDS\nfrom .guid import GUID, canonize_GUID\nfrom .event import EztwEvent, EventRecord\nfrom .tdh import tdh_enumerate_providers, tdh_get_provider_keywords, tdh_get_provider_events, EventMetadata\n\n\nclass EztwProviderException(EztwException):\n    \"\"\"Indicates a missing or unknown provider\"\"\"\n\n\nclass EztwProvider:\n    \"\"\"\n    Represents a trace provider and its events.\n    It is constructed from GUID, name and a list of TdhEvent objects (usually done automatically by EztwManager).\n    \"\"\"\n    def __init__(self, guid: str, name: str, keywords: dict[str, int], event_descriptors: list[EventMetadata]):\n        self.guid = str(GUID(guid))\n        self.name = name\n        self.keywords = {}\n        for keyword_name, keyword_value in keywords.items():\n            actual_keyword_name = f\"Keyword_{keyword_name}\"\n            self.keywords[actual_keyword_name] = keyword_value\n            setattr(self, actual_keyword_name, keyword_value)\n        # Group the event descriptors by their id\n        by_id = defaultdict(list)\n        for event_descriptor in event_descriptors:\n            by_id[event_descriptor.id].append(event_descriptor)\n        # Rearrange the events for ease of access\n        self.events_by_id = {}\n        self.events_by_name = {}\n        for event_id, event_descriptors in by_id.items():\n            # Add a new EztwEvent instance, store it by id and by its sanitized name\n            event = EztwEvent(event_descriptors)\n            self.events_by_id[event.id] = event\n            if event.name:\n                actual_event_name = f\"Event_{sanitize_name(event.name)}_{event.id}\"\n            else:\n                actual_event_name = f\"Event_{event.id}\"\n            self.events_by_name[actual_event_name] = event\n            setattr(self, actual_event_name, event)\n\n    @property\n    def events(self) -> list[EztwEvent]:\n        return [event for _id, event in sorted(self.events_by_id.items())]\n\n    def get_events_by_ids(self, event_ids: int | list[int]) -> list[EztwEvent]:\n        return [self.events_by_id[event_id] for event_id in as_list(event_ids) if event_id in self.events_by_id]\n\n    def parse(self, event_record: EventRecord):\n        \"\"\"\n        Given an EventRecord (and assuming it has the correct provider GUID), attempt to parse its content\n        fields based on its ID and version\n        \"\"\"\n        # Ensure the provider GUID is correct\n        assert event_record.provider_guid == self.guid\n        event = self.events_by_id.get(event_record.id)\n        if not event:\n            raise EztwProviderException(\n                f\"Provider {self.guid} ({self.name}) - unknown event ID {event_record.id}\")\n        return event.parse(event_record)\n\n    def string_details(self):\n        \"\"\"\n        @return: a nice representation of the provider, including all its events\n        \"\"\"\n        res = [f\"Provider GUID={self.guid} ({self.name})\", \"*\" * 40]\n        res.append(\"Keywords:\")\n        for keyword_name, keyword_value in sorted(self.keywords.items(), key=lambda x: x[1]):\n            res.append(f\"\\t{keyword_name} = {hex(keyword_value)}\")\n        res.append(\"Events:\")\n        for event in self.events:\n            res.append(event.string_details(indent=1))\n        return '\\n'.join(res)\n\n    def print(self):\n        print(self.string_details())\n\n    def __repr__(self):\n        return f\"{self.__class__.__name__}(guid={self.guid}, name={self.name!r}, {len(self.events_by_name)} events)\"", "\n\nclass EztwProvider:\n    \"\"\"\n    Represents a trace provider and its events.\n    It is constructed from GUID, name and a list of TdhEvent objects (usually done automatically by EztwManager).\n    \"\"\"\n    def __init__(self, guid: str, name: str, keywords: dict[str, int], event_descriptors: list[EventMetadata]):\n        self.guid = str(GUID(guid))\n        self.name = name\n        self.keywords = {}\n        for keyword_name, keyword_value in keywords.items():\n            actual_keyword_name = f\"Keyword_{keyword_name}\"\n            self.keywords[actual_keyword_name] = keyword_value\n            setattr(self, actual_keyword_name, keyword_value)\n        # Group the event descriptors by their id\n        by_id = defaultdict(list)\n        for event_descriptor in event_descriptors:\n            by_id[event_descriptor.id].append(event_descriptor)\n        # Rearrange the events for ease of access\n        self.events_by_id = {}\n        self.events_by_name = {}\n        for event_id, event_descriptors in by_id.items():\n            # Add a new EztwEvent instance, store it by id and by its sanitized name\n            event = EztwEvent(event_descriptors)\n            self.events_by_id[event.id] = event\n            if event.name:\n                actual_event_name = f\"Event_{sanitize_name(event.name)}_{event.id}\"\n            else:\n                actual_event_name = f\"Event_{event.id}\"\n            self.events_by_name[actual_event_name] = event\n            setattr(self, actual_event_name, event)\n\n    @property\n    def events(self) -> list[EztwEvent]:\n        return [event for _id, event in sorted(self.events_by_id.items())]\n\n    def get_events_by_ids(self, event_ids: int | list[int]) -> list[EztwEvent]:\n        return [self.events_by_id[event_id] for event_id in as_list(event_ids) if event_id in self.events_by_id]\n\n    def parse(self, event_record: EventRecord):\n        \"\"\"\n        Given an EventRecord (and assuming it has the correct provider GUID), attempt to parse its content\n        fields based on its ID and version\n        \"\"\"\n        # Ensure the provider GUID is correct\n        assert event_record.provider_guid == self.guid\n        event = self.events_by_id.get(event_record.id)\n        if not event:\n            raise EztwProviderException(\n                f\"Provider {self.guid} ({self.name}) - unknown event ID {event_record.id}\")\n        return event.parse(event_record)\n\n    def string_details(self):\n        \"\"\"\n        @return: a nice representation of the provider, including all its events\n        \"\"\"\n        res = [f\"Provider GUID={self.guid} ({self.name})\", \"*\" * 40]\n        res.append(\"Keywords:\")\n        for keyword_name, keyword_value in sorted(self.keywords.items(), key=lambda x: x[1]):\n            res.append(f\"\\t{keyword_name} = {hex(keyword_value)}\")\n        res.append(\"Events:\")\n        for event in self.events:\n            res.append(event.string_details(indent=1))\n        return '\\n'.join(res)\n\n    def print(self):\n        print(self.string_details())\n\n    def __repr__(self):\n        return f\"{self.__class__.__name__}(guid={self.guid}, name={self.name!r}, {len(self.events_by_name)} events)\"", "\n\n@dataclass\nclass EztwProviderConfig:\n    \"\"\"\n    Used to enable providers in new sessions using provider GUID, keywords and verbosity level\n    \"\"\"\n    guid: str\n    keywords: int = MAX_KEYWORDS\n    level: int = TRACE_LEVEL_VERBOSE", "\n\ndef canonize_provider_name(provider_name: str) -> str:\n    return sanitize_name(provider_name).lower()\n\n\nclass EztwManager:\n    \"\"\"\n    A convenience class for retrieving and accessing providers, creating appropriate configuration to enable\n    providers in trace sessions, and generic parsing of event records (by automatically finding the correct\n    provider and event).\n\n    Access to this class' methods is thread-safe.\n    \"\"\"\n    def __init__(self):\n        # This is the EztwProvider cache (starts empty)\n        self.providers = {}\n        # This is a tombstone for providers which were asked for but are unavailable\n        # (to prevent using the TDH again for unknown providers)\n        self._unknown_provider_tombstone = object()\n        # Get all locally registered providers and map both from GUID to name as well as name to GUID\n        self.provider_guid_by_name = {}\n        self.provider_name_by_guid = {}\n        for tdh_provider in tdh_enumerate_providers():\n            self.provider_guid_by_name[canonize_provider_name(tdh_provider.name)] = tdh_provider.guid\n            # Some GUIDs appear more than once - keep the first one (the name is not necessarily unique)\n            if tdh_provider.guid in self.provider_name_by_guid:\n                continue\n            self.provider_name_by_guid[tdh_provider.guid] = tdh_provider.name\n        # Special provider (very old kernel provider)\n        self.providers[MSNT_SystemTrace_GUID] = self._unknown_provider_tombstone\n        self.provider_name_by_guid[MSNT_SystemTrace_GUID] = \"MSNT_SystemTrace\"\n\n    def add_manual_provider(self, provider_guid: str, provider_name: str, provider_keywords: dict[str, int],\n                            provider_events: list[EventMetadata]):\n        new_provider = EztwProvider(provider_guid, provider_name, provider_keywords, provider_events)\n        self.providers[new_provider.guid] = new_provider\n        self.provider_name_by_guid[new_provider.guid] = provider_name\n        self.provider_guid_by_name[canonize_provider_name(provider_name)] = new_provider.guid\n        return new_provider\n\n    def get_provider_name_from_guid(self, provider_guid: str) -> str:\n        provider_guid = canonize_GUID(provider_guid)\n        return self.provider_name_by_guid.get(provider_guid) or \"Unknown\"\n\n    def get_provider_by_guid(self, provider_guid: str) -> EztwProvider:\n        provider_guid = canonize_GUID(provider_guid)\n        provider = self.providers.get(provider_guid)\n        # If the value for this GUID is a tombstone - we already know this provider is unavailable via TDH API\n        if provider is self._unknown_provider_tombstone:\n            raise EztwProviderException(f\"Could not find events for provider {provider_guid}\")\n        # If the value for this GUID is cached - simply return it\n        elif provider is not None:\n            return provider\n        # Add new provider\n        provider_name = self.get_provider_name_from_guid(provider_guid)\n        try:\n            provider_events = tdh_get_provider_events(provider_guid)\n            provider_keywords = tdh_get_provider_keywords(provider_guid)\n            new_provider = EztwProvider(provider_guid, provider_name, provider_keywords, provider_events)\n            self.providers[provider_guid] = new_provider\n            return new_provider\n        except EztwException:\n            # Set a tombstone for this provider GUID, so we won't try again for the next event\n            self.providers[provider_guid] = self._unknown_provider_tombstone\n            raise EztwProviderException(f\"Could not find events for provider {provider_guid}\")\n\n    def get_provider_by_name(self, provider_name: str) -> EztwProvider:\n        provider_guid = self.provider_guid_by_name.get(canonize_provider_name(provider_name))\n        if not provider_guid:\n            raise EztwProviderException(f\"Could not find locally registered provider named {provider_name!r}\")\n        return self.get_provider_by_guid(provider_guid)\n\n    def get_provider(self, guid_or_name: str) -> EztwProvider:\n        if GUID.verify(guid_or_name):\n            return self.get_provider_by_guid(guid_or_name)\n        else:\n            return self.get_provider_by_name(guid_or_name)\n\n    def parse(self, event_record: EventRecord):\n        return self.get_provider_by_guid(event_record.provider_guid).parse(event_record)\n\n    def __repr__(self):\n        return f\"{self.__class__.__name__}({len(self.provider_name_by_guid)} registered providers)\"", "\n#####################\n# Syntactic sugaring\n\n# Create a single global instance of the manager\neztwm = EztwManager()\n\ndef get_provider(guid_or_name: str) -> EztwProvider:\n    \"\"\"\n    @param guid_or_name: either a provider name or a provider GUID string\n    @return: EztwProvider\n    \"\"\"\n    return eztwm.get_provider(guid_or_name)", "\ndef get_providers() -> list[(str, str)]:\n    \"\"\"\n    @return: a list of tuples, each containing (provider GUID, provider name)\n    \"\"\"\n    return list(eztwm.provider_name_by_guid.items())\n\ndef get_provider_config(events: EztwEvent | list[EztwEvent], keywords: None | dict[str, int] = None,\n                        level: int = TRACE_LEVEL_VERBOSE) -> list[EztwProviderConfig]:\n    \"\"\"\n    @param events: either a single EztwEvent or a list of them (not necessarily from the same provider!)\n    @param keywords: either None (implicit keywords from events) or a dict from provider GUID to keyword value.\n        (only providers for which there are events given are used, others are ignored...)\n    @param level: verbosity level (0-5, default: TRACE_LEVEL_VERBOSE)\n    @return: list of EztwProviderConfig, one for each relevant provider\n    \"\"\"\n    # Rearrange events by provider GUID, and aggregate their keywords\n    by_provider_guid = defaultdict(int)\n    for event in as_list(events):\n        by_provider_guid[event.provider_guid] |= event.keyword\n    # Override implicit keywords as needed\n    if keywords:\n        for provider_guid, keywords in keywords.items():\n            if provider_guid in by_provider_guid:\n                by_provider_guid[provider_guid] = keywords\n    return [EztwProviderConfig(guid, keywords, level) for guid, keywords in by_provider_guid.items()]", "\ndef add_manual_provider(provider_guid: str, provider_name: str, provider_keywords: dict[str, int],\n                        provider_events: list[EventMetadata]):\n    \"\"\"\n    Manually add a new provider (potentially overwriting existing one with identical GUID/name)\n\n    @param provider_guid: GUID object\n    @param provider_name: string\n    @param provider_keywords: a dictionary that maps keyword names to values\n    @param provider_events: a list of TdhEvent objects\n    \"\"\"\n    return eztwm.add_manual_provider(provider_guid, provider_name, provider_keywords, provider_events)", "\ndef parse_event(event_record: EventRecord):\n    \"\"\"\n    Parse the given event record according to its provider GUID, event ID and event version, and\n    return an immutable event template containing the parsed fields.\n\n    Note that the provider's details are automatically fetched if this is the first time it's encountered (cached).\n\n    @param event_record: an EventRecord object\n    \"\"\"\n    return eztwm.parse(event_record)", ""]}
{"filename": "eztw/event.py", "chunked_list": ["\"\"\"\nImplementation of EztwEvent which represents a single event template.\nEach event may have multiple versions, each with different fields.\nThis class also allows parsing the context-specific contents of an event record.\n\"\"\"\nimport struct\nimport ctypes\nimport functools\nfrom collections import OrderedDict\nfrom dataclasses import make_dataclass", "from collections import OrderedDict\nfrom dataclasses import make_dataclass\nfrom typing import Callable\nimport keyword as python_keywords\n\nfrom .common import FILETIME_to_time, EztwException, as_list, sanitize_name, SYSTEMTIME, SYSTEMTIME_to_time\nfrom .guid import GUID\nfrom .consumer import EventRecord\nfrom .trace_common import EVENT_FIELD_INTYPE, EventMetadata, EventFieldMetadata\n", "from .trace_common import EVENT_FIELD_INTYPE, EventMetadata, EventFieldMetadata\n\n\nclass EztwEventParseException(EztwException):\n    \"\"\"Represents problem parsing an event's fields\"\"\"\n\n\nclass FieldsReader:\n    \"\"\"\n    Helper class for field data deserialization", "    \"\"\"\n    Helper class for field data deserialization\n    \"\"\"\n    def __init__(self, data: bytes, is_64bit: bool):\n        self.data = data\n        self.is_64bit = is_64bit\n        self.cur_offset = 0\n\n    def consume(self, size: int) -> bytes:\n        \"\"\"", "    def consume(self, size: int) -> bytes:\n        \"\"\"\n        Read X bytes if there are enough bytes, or raise EztwEventParseException if not\n        \"\"\"\n        if self.cur_offset + size > len(self.data):\n            raise EztwEventParseException(\n                f\"Data out of bounds at {self.cur_offset}:{size} (data size is {len(self.data)})\")\n        res = self.data[self.cur_offset:self.cur_offset + size]\n        self.cur_offset += size\n        return res", "        self.cur_offset += size\n        return res\n\n    def consume_INT8(self):\n        return struct.unpack(\"b\", self.consume(1))[0]\n\n    def consume_UINT8(self):\n        return struct.unpack(\"B\", self.consume(1))[0]\n\n    def consume_INT16(self):", "\n    def consume_INT16(self):\n        return struct.unpack(\"<h\", self.consume(2))[0]\n\n    def consume_UINT16(self):\n        return struct.unpack(\"<H\", self.consume(2))[0]\n\n    def consume_INT32(self):\n        return struct.unpack(\"<i\", self.consume(4))[0]\n", "        return struct.unpack(\"<i\", self.consume(4))[0]\n\n    def consume_UINT32(self):\n        return struct.unpack(\"<I\", self.consume(4))[0]\n\n    def consume_INT64(self):\n        return struct.unpack(\"<q\", self.consume(8))[0]\n\n    def consume_UINT64(self):\n        return struct.unpack(\"<Q\", self.consume(8))[0]", "    def consume_UINT64(self):\n        return struct.unpack(\"<Q\", self.consume(8))[0]\n\n    def consume_POINTER(self):\n        if self.is_64bit:\n            return self.consume_UINT64()\n        else:\n            return self.consume_UINT32()\n\n    def consume_FILETIME(self):", "\n    def consume_FILETIME(self):\n        return FILETIME_to_time(self.consume_UINT64())\n\n    def consume_SYSTEMTIME(self):\n        return SYSTEMTIME_to_time(SYSTEMTIME.from_buffer_copy(self.consume(16)))\n\n    def consume_STRING(self, size=None):\n        if size is None:\n            str_value = ctypes.string_at(self.data[self.cur_offset:])", "        if size is None:\n            str_value = ctypes.string_at(self.data[self.cur_offset:])\n            # Advance internal offset by string size plus null termination byte\n            self.cur_offset += len(str_value) + 1\n        else:\n            # Manually append null termination\n            str_value = ctypes.string_at(self.consume(size) + b'\\x00')\n        # ctypes.string_at (unlike wstring_at) returns bytes, need to decode\n        return str_value.decode(errors='replace')\n", "        return str_value.decode(errors='replace')\n\n    def consume_WSTRING(self, size=None):\n        if size is None:\n            str_value = ctypes.wstring_at(self.data[self.cur_offset:])\n            # Advance internal offset by string size plus null termination byte, multiplied by wchar_t size\n            self.cur_offset += (len(str_value) + 1) * 2\n        else:\n            # Manually append null termination\n            str_value = ctypes.wstring_at(self.consume(size * 2) + b'\\x00\\x00')", "            # Manually append null termination\n            str_value = ctypes.wstring_at(self.consume(size * 2) + b'\\x00\\x00')\n        return str_value\n\n    def consume_BOOLEAN(self):\n        return bool(self.consume_UINT32())\n\n    def consume_FLOAT(self):\n        return struct.unpack(\"f\", self.consume(4))[0]\n", "        return struct.unpack(\"f\", self.consume(4))[0]\n\n    def consume_DOUBLE(self):\n        return struct.unpack(\"d\", self.consume(8))[0]\n\n    def consume_SID(self):\n        # https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-sid\n        # TODO: parse further?\n        part1 = self.consume(2 + 6)\n        part2 = self.consume(part1[1] * 4)", "        part1 = self.consume(2 + 6)\n        part2 = self.consume(part1[1] * 4)\n        return part1 + part2\n\n    def consume_GUID(self):\n        return str(GUID.from_buffer_copy(self.consume(16)))\n\n    def consume_BINARY(self, size=None):\n        if size is not None:\n            return self.consume(size)", "        if size is not None:\n            return self.consume(size)\n        else:\n            # For some old IPv6 representations\n            return self.consume(16)\n\n    def consume_SIZED_WSTRING(self):\n        size = self.consume_UINT16()\n        return ctypes.wstring_at(self.consume(size) + b'\\x00\\x00')\n", "        return ctypes.wstring_at(self.consume(size) + b'\\x00\\x00')\n\n    def consume_SIZED_STRING(self):\n        size = self.consume_UINT16()\n        return ctypes.string_at(self.consume(size) + b'\\x00').decode(errors='replace')\n\n    def consume_SIZE_T(self):\n        if self.is_64bit:\n            return self.consume_UINT64()\n        else:", "            return self.consume_UINT64()\n        else:\n            return self.consume_UINT32()\n\n    def read(self, field: EventFieldMetadata, previous_fields: OrderedDict):\n        match field.type:\n            case EVENT_FIELD_INTYPE.INTYPE_INT8:\n                consume_func = self.consume_INT8\n            case EVENT_FIELD_INTYPE.INTYPE_UINT8:\n                consume_func = self.consume_UINT8", "            case EVENT_FIELD_INTYPE.INTYPE_UINT8:\n                consume_func = self.consume_UINT8\n            case EVENT_FIELD_INTYPE.INTYPE_INT16:\n                consume_func = self.consume_INT16\n            case EVENT_FIELD_INTYPE.INTYPE_UINT16:\n                consume_func = self.consume_UINT16\n            case EVENT_FIELD_INTYPE.INTYPE_INT32:\n                consume_func = self.consume_INT32\n            case EVENT_FIELD_INTYPE.INTYPE_UINT32 | EVENT_FIELD_INTYPE.INTYPE_HEXINT32:\n                consume_func = self.consume_UINT32", "            case EVENT_FIELD_INTYPE.INTYPE_UINT32 | EVENT_FIELD_INTYPE.INTYPE_HEXINT32:\n                consume_func = self.consume_UINT32\n            case EVENT_FIELD_INTYPE.INTYPE_INT64:\n                consume_func = self.consume_INT64\n            case EVENT_FIELD_INTYPE.INTYPE_UINT64 | EVENT_FIELD_INTYPE.INTYPE_HEXINT64:\n                consume_func = self.consume_UINT64\n            case EVENT_FIELD_INTYPE.INTYPE_POINTER:\n                consume_func = self.consume_POINTER\n            case EVENT_FIELD_INTYPE.INTYPE_BOOLEAN:\n                consume_func = self.consume_BOOLEAN", "            case EVENT_FIELD_INTYPE.INTYPE_BOOLEAN:\n                consume_func = self.consume_BOOLEAN\n            case EVENT_FIELD_INTYPE.INTYPE_FILETIME:\n                consume_func = self.consume_FILETIME\n            case EVENT_FIELD_INTYPE.INTYPE_SYSTEMTIME:\n                consume_func = self.consume_SYSTEMTIME\n            case EVENT_FIELD_INTYPE.INTYPE_UNICODESTRING:\n                consume_func = self.consume_WSTRING\n            case EVENT_FIELD_INTYPE.INTYPE_ANSISTRING:\n                consume_func = self.consume_STRING", "            case EVENT_FIELD_INTYPE.INTYPE_ANSISTRING:\n                consume_func = self.consume_STRING\n            case EVENT_FIELD_INTYPE.INTYPE_FLOAT:\n                consume_func = self.consume_FLOAT\n            case EVENT_FIELD_INTYPE.INTYPE_DOUBLE:\n                consume_func = self.consume_DOUBLE\n            case EVENT_FIELD_INTYPE.INTYPE_SID:\n                consume_func = self.consume_SID\n            case EVENT_FIELD_INTYPE.INTYPE_GUID:\n                consume_func = self.consume_GUID", "            case EVENT_FIELD_INTYPE.INTYPE_GUID:\n                consume_func = self.consume_GUID\n            case EVENT_FIELD_INTYPE.INTYPE_BINARY:\n                consume_func = self.consume_BINARY\n            case EVENT_FIELD_INTYPE.INTYPE_COUNTEDSTRING:\n                consume_func = self.consume_SIZED_WSTRING\n            case EVENT_FIELD_INTYPE.INTYPE_COUNTEDANSISTRING:\n                consume_func = self.consume_SIZED_STRING\n            case EVENT_FIELD_INTYPE.INTYPE_SIZET:\n                consume_func = self.consume_SIZE_T", "            case EVENT_FIELD_INTYPE.INTYPE_SIZET:\n                consume_func = self.consume_SIZE_T\n            case _:\n                raise EztwEventParseException(f\"Unknown or unsupported IN_TYPE {field.type!r}\")\n\n        # https://docs.microsoft.com/en-us/windows/win32/wes/eventmanifestschema-inputtype-complextype\n        # If there's a 'length' field, either read this amount of bytes (if length is int) or the variable\n        # length is stored in a previous field (if length is str)\n        if field.length is not None:\n            length_value = previous_fields.get(field.length) if not isinstance(field.length, int) else field.length", "        if field.length is not None:\n            length_value = previous_fields.get(field.length) if not isinstance(field.length, int) else field.length\n            consume_func = functools.partial(consume_func, length_value)\n        # If the 'count' field is not None, read the same type multiple times\n        if field.count is not None:\n            count_value = previous_fields.get(field.count) if not isinstance(field.count, int) else field.count\n            return [consume_func() for _ in range(count_value)]\n        else:\n            return consume_func()\n", "            return consume_func()\n\n\nclass EztwEvent:\n    \"\"\"\n    Represents a single event of a provider.\n    Maintains all known versions of this event and allows easy parsing.\n    Each version has its own dataclass (called EventTemplate or EventTemplate_#name#).\n    \"\"\"\n    def __init__(self, event_descriptors: list[EventMetadata]):", "    \"\"\"\n    def __init__(self, event_descriptors: list[EventMetadata]):\n        # This instance is initialized from a list of TdhEvent descriptors, so for sanity\n        # make sure there's at least one, and they all share the same provider GUID, id, name and keyword\n        assert len(event_descriptors) >= 1\n        self.provider_guid = event_descriptors[0].provider_guid\n        assert all(ed.provider_guid == self.provider_guid for ed in event_descriptors)\n        self.id = event_descriptors[0].id\n        assert all(ed.id == self.id for ed in event_descriptors)\n        self.name = event_descriptors[0].name", "        assert all(ed.id == self.id for ed in event_descriptors)\n        self.name = event_descriptors[0].name\n        if not all(ed.name == self.name for ed in event_descriptors):\n            # Take the latest name...\n            self.name = event_descriptors[-1].name\n        self.keyword = 0\n        # Sort the descriptors by their version, and create a template for their parsed fields\n        self.versions = {}\n        template_name = f\"EventTemplate_{self.id}\" if not self.name else f\"EventTemplate_{sanitize_name(self.name)}\"\n        for event_descriptor in event_descriptors:", "        template_name = f\"EventTemplate_{self.id}\" if not self.name else f\"EventTemplate_{sanitize_name(self.name)}\"\n        for event_descriptor in event_descriptors:\n            # Note that sometimes different versions of the same event have different keywords...\n            # Aggregate them just to be on the safe side\n            self.keyword |= event_descriptor.keyword\n            # Make sure that none of the field names is accidentally also a reserved Python keyword\n            # If so - append an underscore at the end.\n            # If the field name is a number - prepend it with an underscore.\n            field_names = []\n            for field in event_descriptor.fields:", "            field_names = []\n            for field in event_descriptor.fields:\n                if python_keywords.iskeyword(field.name):\n                    field_names.append(field.name + \"_\")\n                elif not field.name.isidentifier():\n                    field_names.append(\"_\" + field.name)\n                else:\n                    field_names.append(field.name)\n            self.versions[event_descriptor.version] = (\n                event_descriptor.fields,", "            self.versions[event_descriptor.version] = (\n                event_descriptor.fields,\n                make_dataclass(template_name, field_names)\n            )\n\n    def string_details(self, indent=0) -> str:\n        \"\"\"\n        @return: a nice representation of the event's versions and fields\n        \"\"\"\n        indent_str = \"\\t\"*indent", "        \"\"\"\n        indent_str = \"\\t\"*indent\n        res = [f\"{indent_str}Event ID={self.id} ({self.name}) keywords: {hex(self.keyword)}\"]\n        for version, (fields, _template) in sorted(self.versions.items()):\n            res.append(f\"{indent_str}\\tVersion {version}:\")\n            if not fields:\n                res.append(f\"{indent_str}\\t\\t(empty event)\")\n            for field in fields:\n                if isinstance(field.type, EVENT_FIELD_INTYPE):\n                    type_name = field.type.name", "                if isinstance(field.type, EVENT_FIELD_INTYPE):\n                    type_name = field.type.name\n                else:\n                    type_name = f\"Unknown type {field.type}\"\n                length_str = \"\"\n                if field.length is not None:\n                    length_str = f\" (length: {field.length})\"\n                count_str = \"\"\n                if field.count is not None:\n                    count_str = f\" (count: {field.count})\"", "                if field.count is not None:\n                    count_str = f\" (count: {field.count})\"\n                res.append(f\"{indent_str}\\t\\t{field.name}: {type_name}{length_str}{count_str}\")\n        return '\\n'.join(res)\n\n    def print(self):\n        print(self.string_details())\n\n    def parse(self, event_record: EventRecord):\n        \"\"\"", "    def parse(self, event_record: EventRecord):\n        \"\"\"\n        Given an EventRecord, find the correct template by version and parse the fields according to the schema.\n\n        @param event_record: an EventRecord instance\n        @return: the parsed field inside a dataclass template\n        \"\"\"\n        # Sanity - verify provider GUID, ID and version\n        # (usually this function is called by EztwProvider, so the parameters are already correct)\n        # However, if this is called directly we need to make sure...", "        # (usually this function is called by EztwProvider, so the parameters are already correct)\n        # However, if this is called directly we need to make sure...\n        assert event_record.provider_guid == self.provider_guid\n        assert event_record.id == self.id\n        if event_record.version not in self.versions:\n            raise EztwEventParseException(f\"Unknown version {event_record.version} for event \"\n                                          f\"{event_record.id} of provider {event_record.provider_guid}\")\n        # Get the list of fields and the pre-created \"template\"\n        event_fields, event_template = self.versions[event_record.version]\n        # Maintain the order of the parsed fields", "        event_fields, event_template = self.versions[event_record.version]\n        # Maintain the order of the parsed fields\n        field_values = OrderedDict()\n        # Initialize a new data consumer\n        fields_reader = FieldsReader(event_record.data, event_record.is_64bit)\n        for field in event_fields:\n            # Parse the next field\n            field_values[field.name] = fields_reader.read(field, field_values)\n        # Cast the parsed fields, by order, into the immutable event template\n        return event_template(*field_values.values())", "        # Cast the parsed fields, by order, into the immutable event template\n        return event_template(*field_values.values())\n\n    def __repr__(self):\n        return f\"{self.__class__.__name__}(id={self.id}, name={self.name!r}, \" \\\n               f\"provider_guid={self.provider_guid}, keyword={hex(self.keyword)})\"\n\n    def __hash__(self):\n        \"\"\"The event is uniquely identified via its provider GUID and event ID\"\"\"\n        return hash((self.provider_guid, self.id))", "        \"\"\"The event is uniquely identified via its provider GUID and event ID\"\"\"\n        return hash((self.provider_guid, self.id))\n\n\nclass EztwFilter:\n    \"\"\"\n    Simple helper class for filtering events.\n\n    Initialize from a single EztwEvent or a list of them, then given an EventRecord, check if\n    it's contained in this filter.", "    Initialize from a single EztwEvent or a list of them, then given an EventRecord, check if\n    it's contained in this filter.\n\n    Example:\n    >>> # Initialize from a single EztwEvent or a list of them\n    >>> ezf = EztwFilter(some_event)\n    >>>\n    >>> # Then, given an event record from a consumer:\n    >>> if event_record in ezf:\n    >>>     # Do something", "    >>> if event_record in ezf:\n    >>>     # Do something\n    \"\"\"\n    def __init__(self, events: EztwEvent | list[EztwEvent]):\n        self.event_hashes = {hash(event) for event in as_list(events)}\n\n    def __contains__(self, event_record: EventRecord):\n        return hash(event_record) in self.event_hashes\n\n", "\n\nclass EztwDispatcher:\n    \"\"\"\n    Simple mapper from event class to a callback function.\n\n    Initialize from a dict of: { EztwEvent: callable }\n    Filtering is done similarly to EztwFilter.\n    Each callable must accept two parameters - the event record and the parsed event. The parsed event\n    can either be parsed manually (using the parse_event function, for example), but is more often", "    Each callable must accept two parameters - the event record and the parsed event. The parsed event\n    can either be parsed manually (using the parse_event function, for example), but is more often\n    returned by an EztwSessionIterator (like the one used in the consume_events function).\n\n    The EztwDispatcher is simply invoked by calling it. If the given event record is not a part\n    of the dispatcher, nothing will happen. Note that the hash of both EventRecord and EztwEvent are the\n    same iff both their provider_guid and ID are the same.\n\n    To simplify even further, use the .events member of the dispatcher as a list of events to filter\n    for consume_events and EztwSessionIterator.", "    To simplify even further, use the .events member of the dispatcher as a list of events to filter\n    for consume_events and EztwSessionIterator.\n\n    Example:\n    >>> # Define callback functions for the desired events\n    >>> def some_callback(event_record, parsed_event):\n    >>>     # Do something\n    >>>\n    >>> # Initialize from a list of EztwEvent and their desired callback\n    >>> ezd = EztwDispatcher({some_event: some_callback, ...})", "    >>> # Initialize from a list of EztwEvent and their desired callback\n    >>> ezd = EztwDispatcher({some_event: some_callback, ...})\n    >>>\n    >>> # Then, given an event record and its parsed event (for example as yielded from consume_events):\n    >>> for event_record, parsed_event in consume_events(ezd.events):\n    >>>     # Call the callable (if the event is relevant, otherwise nothing happens)\n    >>>     ezd(event_record, parsed_event)\n    \"\"\"\n    def __init__(self, events_and_callbacks: dict[EztwEvent, Callable]):\n        self.events = []", "    def __init__(self, events_and_callbacks: dict[EztwEvent, Callable]):\n        self.events = []\n        self.mapping = {}\n        for event, callback in events_and_callbacks.items():\n            self.events.append(event)\n            self.mapping[hash(event)] = callback\n\n    def __call__(self, event_record: EventRecord, parsed_event):\n        dispatch = self.mapping.get(hash(event_record))\n        if dispatch:", "        dispatch = self.mapping.get(hash(event_record))\n        if dispatch:\n            dispatch(event_record, parsed_event)\n"]}
{"filename": "eztw/scripts/consume_raw_provider.py", "chunked_list": ["\"\"\"\nThis is a useful script that can consume any provider based on its GUID and optional keywords\n(defaults to MAX_KEYWORDS). Events are not parsed, but rather their event records are printed\nand also their hex data (using the hexdump module, if it's installed, or binascii.hexlify otherwise).\n\"\"\"\nimport sys\nimport time\n\nfrom .. import EztwController, EztwConsumer\nfrom ..trace_common import ad_hoc_session_name, MAX_KEYWORDS, MSNT_SystemTrace_GUID, LOST_EVENTS_GUID", "from .. import EztwController, EztwConsumer\nfrom ..trace_common import ad_hoc_session_name, MAX_KEYWORDS, MSNT_SystemTrace_GUID, LOST_EVENTS_GUID\nfrom ..provider import EztwProviderConfig\nfrom ..guid import GUID\nfrom ..log import LOGGER\n\ntry:\n    # Optional better printing using the hexdump module\n    import hexdump\n    print_hexdump = hexdump.hexdump\nexcept ImportError:\n    import binascii\n\n    def print_hexdump(data):\n        print(binascii.hexlify(data, ' '))", "\ndef main():\n    if len(sys.argv) < 2:\n        print(f\"USAGE: {sys.argv[0]} [provider GUID] <hex keywords, default is 0xffffffffffffffff>\")\n        sys.exit(1)\n    provider_guid = sys.argv[1]\n    if not GUID.verify(provider_guid):\n        raise ValueError(f\"Invalid GUID value {provider_guid!r}\")\n    if len(sys.argv) > 2:\n        keywords = int(sys.argv[2], 16)\n    else:\n        keywords = MAX_KEYWORDS\n    config = EztwProviderConfig(provider_guid, keywords)\n    session_name = ad_hoc_session_name()\n    LOGGER.info(f\"Consuming events from {provider_guid} with keywords {hex(keywords)} - press Ctrl+C to stop\")\n    with EztwController(session_name, config):\n        for i, event_record in enumerate(EztwConsumer(session_name)):\n            print(f\"=== [Event {i}] {time.ctime(event_record.timestamp)} ===\")\n            if event_record.provider_guid == MSNT_SystemTrace_GUID:\n                print(\"<SYSTEM TRACE EVENT>\")\n            elif event_record.provider_guid == LOST_EVENTS_GUID:\n                print(\"<LOST EVENT>\")\n            else:\n                print(event_record)\n                print_hexdump(event_record.data)", "\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "eztw/scripts/consume_provider.py", "chunked_list": ["\"\"\"\nThis is a useful script that can consume any locally registered provider directly from command-line.\nIt automatically parses any registered events and allows easy exploration of trace providers.\n\nIf only specific events are desired, provide them as the last parameter as a comma-separated list of IDs.\nOtherwise (default) all the provider's events are consumed.\n\nFor example, to consume any process/thread start events:\n\npython -m eztw.scripts.consume_provider microsoft-windows-kernel-process 1,3", "\npython -m eztw.scripts.consume_provider microsoft-windows-kernel-process 1,3\n\"\"\"\nimport sys\nimport time\n\nfrom .. import get_provider, consume_events, MAX_KEYWORDS\nfrom ..log import LOGGER\n\ndef main():\n    if len(sys.argv) < 2:\n        print(f\"USAGE: {sys.argv[0]} [provider name or GUID] <event ids, comma-separated>\")\n        sys.exit(1)\n    provider = get_provider(sys.argv[1])\n    keywords = None\n    if len(sys.argv) > 2:\n        event_ids = list(set(map(int, sys.argv[2].split(','))))\n        events = provider.get_events_by_ids(event_ids)\n    else:\n        # Consume all provider's events\n        events = provider.events\n        keywords = {provider.guid: MAX_KEYWORDS}\n    LOGGER.info(f\"Consuming {len(events)} events from {provider.guid} - press Ctrl+C to stop\")\n    for i, (event_record, parsed_event) in enumerate(consume_events(events, keywords=keywords)):\n        print(f\"=== [Event {i}] {time.ctime(event_record.timestamp)} ===\")\n        print(event_record)\n        print(parsed_event)", "\ndef main():\n    if len(sys.argv) < 2:\n        print(f\"USAGE: {sys.argv[0]} [provider name or GUID] <event ids, comma-separated>\")\n        sys.exit(1)\n    provider = get_provider(sys.argv[1])\n    keywords = None\n    if len(sys.argv) > 2:\n        event_ids = list(set(map(int, sys.argv[2].split(','))))\n        events = provider.get_events_by_ids(event_ids)\n    else:\n        # Consume all provider's events\n        events = provider.events\n        keywords = {provider.guid: MAX_KEYWORDS}\n    LOGGER.info(f\"Consuming {len(events)} events from {provider.guid} - press Ctrl+C to stop\")\n    for i, (event_record, parsed_event) in enumerate(consume_events(events, keywords=keywords)):\n        print(f\"=== [Event {i}] {time.ctime(event_record.timestamp)} ===\")\n        print(event_record)\n        print(parsed_event)", "\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "eztw/scripts/__init__.py", "chunked_list": [""]}
{"filename": "eztw/scripts/demo_file.py", "chunked_list": ["\"\"\"\nImplementation of an entire file-activity tracker.\nThis is required because most events from Microsoft-Windows-Kernel-File do not hold the original opened\nfilename, but rather a \"file object\" that is given when the file is first open.\nIn addition, various translations and file-specific parsing is added.\n\"\"\"\nimport os\nimport time\nimport string\nimport threading", "import string\nimport threading\nimport tempfile\nfrom dataclasses import dataclass\n\nimport win32file\n\nfrom .. import get_provider, consume_events, EztwDispatcher\nfrom ..log import LOGGER\n", "from ..log import LOGGER\n\n\nFILE_DIRECTORY_FILE = 0x00000001\nFILE_ATTRIBUTE_DIRECTORY = 0x00000010\nFILE_DELETE_ON_CLOSE = 0x00001000\n\nFileEndOfFileInformation = 20\n\n# Get current drive letters mapping by iterating A to Z and using QueryDosDevice", "\n# Get current drive letters mapping by iterating A to Z and using QueryDosDevice\nDRIVE_LETTER_MAPPING = {}\nfor c in string.ascii_uppercase:\n    try:\n        p = win32file.QueryDosDevice(f\"{c}:\").rstrip('\\x00')\n        DRIVE_LETTER_MAPPING[p] = f\"{c}:\\\\\"\n        LOGGER.info(f\"Drive {c} is mapped to {p}\")\n    except:\n        pass", "\nif not DRIVE_LETTER_MAPPING:\n    LOGGER.warning(\"No local drive mappings were found!\")\n\n# Given an NT path, translate it to a DOS path\n# (i.e: \\Device\\HarddiskVolume1\\bla\\file.txt ==> c:\\bla\\file.txt)\ndef translate_path(nt_path):\n    s = nt_path.split('\\\\')\n    m = DRIVE_LETTER_MAPPING.get('\\\\'.join(s[:3]))\n    if not m:\n        # Could not translate\n        return nt_path\n    # Replace the prefix\n    return m + '\\\\'.join(s[3:])", "\n# Given bitmap instance and a mapping of flags, convert the int bitmap to a human readable string\ndef get_flags_from_bitmap(bitmap, flags):\n    if bitmap == 0:\n        return \"<EMPTY 0x0>\"\n    res = []\n    for mask, name in flags.items():\n        if mask & bitmap:\n            res.append(name)\n    if not res:\n        return f\"<UNKNOWN {hex(bitmap)}>\"\n    else:\n        return ' | '.join(res)", "\n# Taken from: https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-iocreatefileex\nCREATE_OPTION_FLAGS = {\n    0x00000001: \"FILE_DIRECTORY_FILE\",\n    0x00000002: \"FILE_WRITE_THROUGH\",\n    0x00000004: \"FILE_SEQUENTIAL_ONLY\",\n    0x00000008: \"FILE_NO_INTERMEDIATE_BUFFERING\",\n    0x00000010: \"FILE_SYNCHRONOUS_IO_ALERT\",\n    0x00000020: \"FILE_SYNCHRONOUS_IO_NONALERT\",\n    0x00000040: \"FILE_NON_DIRECTORY_FILE\",", "    0x00000020: \"FILE_SYNCHRONOUS_IO_NONALERT\",\n    0x00000040: \"FILE_NON_DIRECTORY_FILE\",\n    0x00000080: \"FILE_CREATE_TREE_CONNECTION\",\n    0x00000100: \"FILE_COMPLETE_IF_OPLOCKED\",\n    0x00000200: \"FILE_NO_EA_KNOWLEDGE\",\n    0x00000400: \"FILE_OPEN_REMOTE_INSTANCE\",\n    0x00000800: \"FILE_RANDOM_ACCESS\",\n    0x00001000: \"FILE_DELETE_ON_CLOSE\",\n    0x00002000: \"FILE_OPEN_BY_FILE_ID\",\n    0x00004000: \"FILE_OPEN_FOR_BACKUP_INTENT\",", "    0x00002000: \"FILE_OPEN_BY_FILE_ID\",\n    0x00004000: \"FILE_OPEN_FOR_BACKUP_INTENT\",\n    0x00008000: \"FILE_NO_COMPRESSION\",\n    0x00010000: \"FILE_OPEN_REQUIRING_OPLOCK\",\n    0x00020000: \"FILE_DISALLOW_EXCLUSIVE\",\n    0x00040000: \"FILE_SESSION_AWARE\",\n    0x00100000: \"FILE_RESERVE_OPFILTER\",\n    0x00200000: \"FILE_OPEN_REPARSE_POINT\",\n    0x00400000: \"FILE_OPEN_NO_RECALL\",\n    0x00800000: \"FILE_OPEN_FOR_FREE_SPACE_QUERY\",", "    0x00400000: \"FILE_OPEN_NO_RECALL\",\n    0x00800000: \"FILE_OPEN_FOR_FREE_SPACE_QUERY\",\n}\n\n# Get the string representation of file creation options\ndef get_create_options_flags(create_options):\n    return get_flags_from_bitmap(create_options, CREATE_OPTION_FLAGS)\n\n# Taken from https://docs.microsoft.com/en-us/windows/win32/fileio/file-attribute-constants\nFILE_ATTRIBUTES_FLAGS = {", "# Taken from https://docs.microsoft.com/en-us/windows/win32/fileio/file-attribute-constants\nFILE_ATTRIBUTES_FLAGS = {\n    0x1: \"FILE_ATTRIBUTE_READONLY\",\n    0x2: \"FILE_ATTRIBUTE_HIDDEN\",\n    0x4: \"FILE_ATTRIBUTE_SYSTEM\",\n    0x10: \"FILE_ATTRIBUTE_DIRECTORY\",\n    0x20: \"FILE_ATTRIBUTE_ARCHIVE\",\n    0x40: \"FILE_ATTRIBUTE_DEVICE\",\n    0x80: \"FILE_ATTRIBUTE_NORMAL\",\n    0x100: \"FILE_ATTRIBUTE_TEMPORARY\",", "    0x80: \"FILE_ATTRIBUTE_NORMAL\",\n    0x100: \"FILE_ATTRIBUTE_TEMPORARY\",\n    0x200: \"FILE_ATTRIBUTE_SPARSE_FILE\",\n    0x400: \"FILE_ATTRIBUTE_REPARSE_POINT\",\n    0x800: \"FILE_ATTRIBUTE_COMPRESSED\",\n    0x1000: \"FILE_ATTRIBUTE_OFFLINE\",\n    0x2000: \"FILE_ATTRIBUTE_NOT_CONTENT_INDEXED\",\n    0x4000: \"FILE_ATTRIBUTE_ENCRYPTED\",\n    0x8000: \"FILE_ATTRIBUTE_INTEGRITY_STREAM\",\n    0x10000: \"FILE_ATTRIBUTE_VIRTUAL\",", "    0x8000: \"FILE_ATTRIBUTE_INTEGRITY_STREAM\",\n    0x10000: \"FILE_ATTRIBUTE_VIRTUAL\",\n    0x20000: \"FILE_ATTRIBUTE_NO_SCRUB_DATA\",\n    0x40000: \"FILE_ATTRIBUTE_RECALL_ON_OPEN\",\n    0x80000: \"FILE_ATTRIBUTE_PINNED\",\n    0x100000: \"FILE_ATTRIBUTE_UNPINNED\",\n    0x400000: \"FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS\",\n}\n\n# Get the string representation of the file creation attributes\ndef get_create_attributes_flags(create_attributes):\n    return get_flags_from_bitmap(create_attributes, FILE_ATTRIBUTES_FLAGS)", "\n# Get the string representation of the file creation attributes\ndef get_create_attributes_flags(create_attributes):\n    return get_flags_from_bitmap(create_attributes, FILE_ATTRIBUTES_FLAGS)\n\nSHARE_ACCESS_FLAGS = {\n    0x00000001: \"FILE_SHARE_READ\",\n    0x00000002: \"FILE_SHARE_WRITE\",\n    0x00000004: \"FILE_SHARE_DELETE\",\n}", "    0x00000004: \"FILE_SHARE_DELETE\",\n}\n\n# Get the string representation of the file creation share access flags\ndef get_share_access_flags(share_access):\n    return get_flags_from_bitmap(share_access, SHARE_ACCESS_FLAGS)\n\nFILE_OVERWRITE = 0x00000004\nFILE_OVERWRITE_IF = 0x00000005\n", "FILE_OVERWRITE_IF = 0x00000005\n\nDISPOSITION = {\n    0x00000001: \"FILE_OPEN\",\n    0x00000002: \"FILE_CREATE\",\n    0x00000003: \"FILE_OPEN_IF\",\n    0x00000004: \"FILE_OVERWRITE\",\n    0x00000005: \"FILE_OVERWRITE_IF\",\n}\n", "}\n\n# Get the string representation of the file creation disposition (this is not a bitmap...)\ndef get_create_disposition_flags(create_disposition):\n    res = DISPOSITION.get(create_disposition)\n    if not res:\n        return \"UNKNOWN\"\n    return res\n\n@dataclass\nclass OpenedFile:\n    \"\"\"\n    Represents an opened file\n    \"\"\"\n    pid: int\n    tid: int\n    filename: str\n    create_options: int\n    create_disposition: int\n    create_attributes: int\n    shared_access: int", "\n@dataclass\nclass OpenedFile:\n    \"\"\"\n    Represents an opened file\n    \"\"\"\n    pid: int\n    tid: int\n    filename: str\n    create_options: int\n    create_disposition: int\n    create_attributes: int\n    shared_access: int", "\n\nclass FileEventsConsumer:\n    \"\"\"\n    Consume the following events:\n        Open (create) - 12\n        Close - 14\n        Read - 15\n        Write - 16\n        SetInformation - 17\n        Delete - 26\n        Rename - 27\n        Created new file - 30\n\n    Each dispatcher callback function eventually calls the \"actual\" function (to be implemented by subclasses),\n    which receives in addition to the event record and parsed event also the relevant OpenedFile object\n    \"\"\"\n    def __init__(self):\n        # Maintain a map of OpenedFile instances by their file object\n        self.opened_files_by_file_object = {}\n\n    def run(self):\n        provider = get_provider(\"Microsoft-Windows-Kernel-File\")\n\n        # Instantiate a dispatcher for the callbacks\n        dispatcher = EztwDispatcher({\n            provider.Event_Create_12: self.onFileOpen,\n            provider.Event_Close_14: self.onFileClose,\n            provider.Event_Read_15: self.onFileRead,\n            provider.Event_Write_16: self.onFileWrite,\n            provider.Event_SetInformation_17: self.onFileSetInformation,\n            provider.Event_DeletePath_26: self.onFileDelete,\n            provider.Event_RenamePath_27: self.onFileRename,\n            provider.Event_CreateNewFile_30: self.onFileCreateNew,\n        })\n\n        # Consume events forever\n        LOGGER.info(\"Consuming file events...\")\n        for event_record, parsed_event in consume_events(dispatcher.events):\n            dispatcher(event_record, parsed_event)\n\n    def onFileOpen(self, event_record, parsed_event):\n        # Ignore directories\n        if parsed_event.CreateOptions & FILE_DIRECTORY_FILE or parsed_event.CreateAttributes & FILE_ATTRIBUTE_DIRECTORY:\n            return\n        # Too few delimiters... this is a dir or a root\n        n_delim = parsed_event.FileName.count(\"\\\\\")\n        if n_delim < 3 or (n_delim == 3 and parsed_event.FileName.endswith(\"\\\\\")):\n            return\n        # This is a file being opened\n        filename = translate_path(parsed_event.FileName)\n        opened_file = OpenedFile(\n            event_record.process_id,\n            parsed_event.IssuingThreadId if hasattr(parsed_event, \"IssuingThreadId\") else 0,\n            filename,\n            parsed_event.CreateOptions & 0xFFFFFF,\n            parsed_event.CreateOptions >> 24,\n            parsed_event.CreateAttributes,\n            parsed_event.ShareAccess)\n        # Cache the object by the FileObject\n        self.opened_files_by_file_object[parsed_event.FileObject] = opened_file\n        self.fileOpened(event_record, parsed_event, opened_file)\n\n    def fileOpened(self, event_record, parsed_event, opened_file):\n        pass\n\n    def onFileClose(self, event_record, parsed_event):\n        # If the file object is unknown, ignore this event\n        if (opened_file := self.opened_files_by_file_object.get(parsed_event.FileObject)) is None:\n            return\n        self.fileClosed(event_record, parsed_event, opened_file)\n        # Remove this file object from the cache now it's closed\n        self.opened_files_by_file_object.pop(parsed_event.FileObject)\n\n    def fileClosed(self, event_record, parsed_event, opened_file):\n        pass\n\n    def onFileRead(self, event_record, parsed_event):\n        if (opened_file := self.opened_files_by_file_object.get(parsed_event.FileObject)) is None:\n            return\n        self.fileRead(event_record, parsed_event, opened_file)\n\n    def fileRead(self, event_record, parsed_event, opened_file):\n        pass\n\n    def onFileWrite(self, event_record, parsed_event):\n        if (opened_file := self.opened_files_by_file_object.get(parsed_event.FileObject)) is None:\n            return\n        self.fileWritten(event_record, parsed_event, opened_file)\n\n    def fileWritten(self, event_record, parsed_event, opened_file):\n        pass\n\n    def onFileSetInformation(self, event_record, parsed_event):\n        if (opened_file := self.opened_files_by_file_object.get(parsed_event.FileObject)) is None:\n            return\n        # iff InfoClass is FileEndOfFileInformation and ExtraInformation is 0 - this is a truncation to empty\n        if parsed_event.InfoClass == FileEndOfFileInformation and parsed_event.ExtraInformation == 0:\n            self.fileTruncated(event_record, parsed_event, opened_file)\n        else:\n            self.fileSetInformation(event_record, parsed_event, opened_file)\n\n    def fileTruncated(self, event_record, parsed_event, opened_file):\n        pass\n\n    def fileSetInformation(self, event_record, parsed_event, opened_file):\n        pass\n\n    def onFileDelete(self, event_record, parsed_event):\n        if (opened_file := self.opened_files_by_file_object.get(parsed_event.FileObject)) is None:\n            return\n        self.fileDeleted(event_record, parsed_event, opened_file)\n        # Note that the file is not actually deleted from the file system until the handle is closed\n\n    def fileDeleted(self, event_record, parsed_event, opened_file):\n        pass\n\n    def onFileRename(self, event_record, parsed_event):\n        if (opened_file := self.opened_files_by_file_object.get(parsed_event.FileObject)) is None:\n            return\n        # Also translate the new filename to DOS path\n        self.fileRenamed(event_record, parsed_event, opened_file, translate_path(parsed_event.FilePath))\n\n    def fileRenamed(self, event_record, parsed_event, opened_file, new_filename):\n        pass\n\n    def onFileCreateNew(self, event_record, parsed_event):\n        if (opened_file := self.opened_files_by_file_object.get(parsed_event.FileObject)) is None:\n            return\n        self.fileCreated(event_record, parsed_event, opened_file)\n\n    def fileCreated(self, event_record, parsed_event, opened_file):\n        pass", "\n\nclass FileTracker(FileEventsConsumer):\n    \"\"\"\n    An example of a FileEventsConsumer subclass which simply tracks files according to their (partial) name\n    \"\"\"\n    def __init__(self, tracked_filenames):\n        super().__init__()\n        self.tracked_filenames = [x.lower() for x in tracked_filenames]\n\n    def is_relevant_file(self, filename):\n        # Check if the given filename is one we should track\n        filename = filename.lower()\n        return any(x in filename for x in self.tracked_filenames)\n\n    def fileOpened(self, event_record, parsed_event, opened_file):\n        if not self.is_relevant_file(opened_file.filename):\n            return\n        LOGGER.info(f\"File {opened_file.filename} opened by PID {opened_file.pid}\\n\"\n                    f\"\\tCreation options: {get_create_options_flags(opened_file.create_options)}\")\n\n    def fileClosed(self, event_record, parsed_event, opened_file):\n        if not self.is_relevant_file(opened_file.filename):\n            return\n        LOGGER.info(f\"File {opened_file.filename} was closed by PID {event_record.process_id}\")\n\n    def fileRead(self, event_record, parsed_event, opened_file):\n        if not self.is_relevant_file(opened_file.filename):\n            return\n        LOGGER.info(\n            f\"File {opened_file.filename} was read by PID {event_record.process_id}\"\n            f\" - {parsed_event.IOSize} bytes read\"\n        )\n\n    def fileWritten(self, event_record, parsed_event, opened_file):\n        if not self.is_relevant_file(opened_file.filename):\n            return\n        LOGGER.info(\n            f\"File {opened_file.filename} was written by PID {event_record.process_id}\"\n            f\" - {parsed_event.IOSize} bytes written\"\n        )\n\n    def fileTruncated(self, event_record, parsed_event, opened_file):\n        if not self.is_relevant_file(opened_file.filename):\n            return\n        LOGGER.info(f\"File {opened_file.filename} was truncated by PID {event_record.process_id}\")\n\n    def fileSetInformation(self, event_record, parsed_event, opened_file):\n        if not self.is_relevant_file(opened_file.filename):\n            return\n\n    def fileDeleted(self, event_record, parsed_event, opened_file):\n        if not self.is_relevant_file(opened_file.filename):\n            return\n        LOGGER.info(f\"File {opened_file.filename} was deleted by PID {event_record.process_id}\")\n\n    def fileRenamed(self, event_record, parsed_event, opened_file, new_filename):\n        if not self.is_relevant_file(opened_file.filename):\n            return\n        LOGGER.info(f\"File {opened_file.filename} was renamed by PID {event_record.process_id} to {new_filename}\")\n\n    def fileCreated(self, event_record, parsed_event, opened_file):\n        if not self.is_relevant_file(opened_file.filename):\n            return\n        LOGGER.info(f\"File {opened_file.filename} is a new file created by PID {event_record.process_id}\")", "\ndef delayed_file_activity(delay, filename):\n    LOGGER.info(f\"Thread started, sleeping for {delay} seconds...\")\n    time.sleep(delay)\n    actual_filename = tempfile.mktemp(filename)\n    LOGGER.info(f\"Thread starting manipulations on temporary file '{actual_filename}'\")\n    with open(actual_filename, \"wb\") as fp:\n        fp.write(b\"Hello world!\")\n    time.sleep(1)\n    with open(actual_filename, \"rb\") as fp:\n        _ = fp.read()\n    time.sleep(1)\n    new_filename = actual_filename + \".new\"\n    os.rename(actual_filename, new_filename)\n    time.sleep(1)\n    os.truncate(new_filename, 0)\n    time.sleep(1)\n    os.remove(new_filename)", "\ndef main():\n    # Create a delayed file-manipulation thread\n    file_delay = 3  # Seconds\n    filename = \"_eztw_test\"  # Base for temporary file name - this is also what we track\n    LOGGER.info(f\"Starting new thread. Manipulating {filename!r} in {file_delay} seconds...\")\n    threading.Thread(target=delayed_file_activity, args=(file_delay, filename)).start()\n\n    # Start consuming events via FileTracker\n    FileTracker([\"eztw_test\"]).run()", "\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "eztw/scripts/demo_dns.py", "chunked_list": ["\"\"\"\nThis demo scripts starts a new trace session to consume the Microsoft-Windows-DNS-Client provider,\nthen in a separate thread performs DNS query to python.org.\n\nThe main thread should show these events.\n\"\"\"\nimport time\nimport threading\nfrom socket import gethostbyname\n", "from socket import gethostbyname\n\nfrom .. import get_provider, get_provider_config, parse_event, EztwController, EztwConsumer, EztwFilter\nfrom ..log import LOGGER\n\ndef delayed_dns_query(delay, name):\n    LOGGER.info(f\"Thread started, sleeping for {delay} seconds...\")\n    time.sleep(delay)\n    LOGGER.info(f\"Thread performing query for {name!r}\")\n    gethostbyname(name)", "\ndef main():\n    provider = get_provider(\"microsoft-windows-dns-client\")\n    # provider = get_provider(\"{1c95126e-7eea-49a9-a3fe-a378b03ddb4d}\")\n\n    session_name = \"eztw_demo_dns\"\n\n    # This is the event we want according to the schema\n    # https://github.com/repnz/etw-providers-docs/blob/d5f68e8acda5da154ab44e405b610dd8c2ba1164/Manifests-Win10-18990/Microsoft-Windows-DNS-Client.xml\n    provider_config = get_provider_config(provider.Event_3008)\n    # Create a new session\n    with EztwController(session_name, provider_config):\n        # Schedule a separate thread for the query\n        dns_delay = 3  # Seconds\n        dns_query = \"python.org\"\n        LOGGER.info(f\"Starting new thread. Querying for {dns_query!r} in {dns_delay} seconds...\")\n        threading.Thread(target=delayed_dns_query, args=(dns_delay, dns_query)).start()\n        # Start consuming events\n        LOGGER.info(f\"Waiting for events... (runs forever, press Ctrl+C to stop)\")\n        # Filter only theis event\n        events_filter = EztwFilter(provider.Event_3008)\n        with EztwConsumer(session_name) as ezc:\n            for event_record in ezc:\n                # Skip any irrelevant event records\n                if event_record not in events_filter:\n                    continue\n                # Parsed fields of event 3008:\n                #   QueryName: str\n                #   QueryType: int\n                #   QueryOptions: int\n                #   QueryStatus: int\n                #   QueryResults: str\n                parsed_event = parse_event(event_record)\n                # Print only queries performed to this domain (python.org)\n                if dns_query in parsed_event.QueryName:\n                    print(f\"{time.ctime(event_record.timestamp)} PID {event_record.process_id} \"\n                          f\"performed DNS query:\")\n                    print(parsed_event)", "\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "eztw/scripts/demo_process.py", "chunked_list": ["\"\"\"\nConsume events for process-start, process-stop and image-load from Microsoft-Windows-Kernel-Process.\nTrack only processes called notepad.exe.\n\"\"\"\nimport time\nimport threading\nimport subprocess\n\nfrom .. import get_provider, consume_events, EztwDispatcher\nfrom ..log import LOGGER", "from .. import get_provider, consume_events, EztwDispatcher\nfrom ..log import LOGGER\n\n\nclass ProcessTracker:\n    \"\"\"\n    Helper class that defines our callback functions\n    \"\"\"\n    def __init__(self):\n        # Maintain a list of currently used PIDs by notepad.exe processes\n        self.notepad_processes = set()\n\n    def on_process_start(self, event_record, parsed_event):\n        if \"notepad.exe\" in parsed_event.ImageName:\n            print(f\"New process (PID {parsed_event.ProcessID}) started from {parsed_event.ImageName}\")\n            self.notepad_processes.add(parsed_event.ProcessID)\n\n    def on_process_stop(self, event_record, parsed_event):\n        if \"notepad.exe\" in parsed_event.ImageName and parsed_event.ProcessID in self.notepad_processes:\n            print(f\"Process (PID {parsed_event.ProcessID}) stopped\")\n            self.notepad_processes.remove(parsed_event.ProcessID)\n\n    def on_image_load(self, event_record, parsed_event):\n        # Only print loaded modules if this is one of our \"tracked\" notepad PIDs\n        if parsed_event.ProcessID in self.notepad_processes:\n            print(f\"Process {parsed_event.ProcessID} loaded a new module: {parsed_event.ImageName}\")", "\ndef delayed_process(delay, name):\n    LOGGER.info(f\"Thread started, sleeping for {delay} seconds...\")\n    time.sleep(delay)\n    LOGGER.info(f\"Thread starting new process {name!r}\")\n    process = subprocess.Popen(name)\n    time.sleep(delay)\n    process.kill()\n\ndef main():\n    provider = get_provider(\"microsoft windows kernel process\")\n    # provider = get_provider(\"{22FB2CD6-0E7B-422B-A0C7-2FAD1FD0E716}\")\n\n    process_tracker = ProcessTracker()\n    # Initialize EztwDispatcher that maps from the desired events to their callbacks\n    events_dispatcher = EztwDispatcher({\n        provider.Event_ProcessStart_1: process_tracker.on_process_start,\n        provider.Event_ProcessStop_2: process_tracker.on_process_stop,\n        provider.Event_ImageLoad_5: process_tracker.on_image_load,\n    })\n\n    # Create a delayed thread that starts and stops a new notepad.exe\n    process_delay = 3  # Seconds\n    process_name = \"notepad.exe\"\n    LOGGER.info(f\"Starting new thread. Launching {process_name!r} in {process_delay} seconds...\")\n    threading.Thread(target=delayed_process, args=(process_delay, process_name)).start()\n\n    LOGGER.info(f\"Waiting for events... (runs forever, press Ctrl+C to stop)\")\n    # Consuming and dispatching events is easy!\n    # Note that events_dispatcher has an 'events' member that holds all registered events\n    for event_record, parsed_event in consume_events(events_dispatcher.events):\n        events_dispatcher(event_record, parsed_event)", "\ndef main():\n    provider = get_provider(\"microsoft windows kernel process\")\n    # provider = get_provider(\"{22FB2CD6-0E7B-422B-A0C7-2FAD1FD0E716}\")\n\n    process_tracker = ProcessTracker()\n    # Initialize EztwDispatcher that maps from the desired events to their callbacks\n    events_dispatcher = EztwDispatcher({\n        provider.Event_ProcessStart_1: process_tracker.on_process_start,\n        provider.Event_ProcessStop_2: process_tracker.on_process_stop,\n        provider.Event_ImageLoad_5: process_tracker.on_image_load,\n    })\n\n    # Create a delayed thread that starts and stops a new notepad.exe\n    process_delay = 3  # Seconds\n    process_name = \"notepad.exe\"\n    LOGGER.info(f\"Starting new thread. Launching {process_name!r} in {process_delay} seconds...\")\n    threading.Thread(target=delayed_process, args=(process_delay, process_name)).start()\n\n    LOGGER.info(f\"Waiting for events... (runs forever, press Ctrl+C to stop)\")\n    # Consuming and dispatching events is easy!\n    # Note that events_dispatcher has an 'events' member that holds all registered events\n    for event_record, parsed_event in consume_events(events_dispatcher.events):\n        events_dispatcher(event_record, parsed_event)", "\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "eztw/scripts/dump_providers.py", "chunked_list": ["import sys\n\nfrom .. import get_providers, get_provider, EztwException\n\ndef main():\n    if len(sys.argv) < 2:\n        print(f\"USAGE: {sys.argv[0]} [output filename] <events>\")\n        sys.exit(1)\n    with_events = False\n    if len(sys.argv) >= 3:\n        if sys.argv[2] != \"events\":\n            print(f\"USAGE: {sys.argv[0]} [output filename] <events>\")\n            sys.exit(2)\n        with_events = True\n    print(f\"Collecting all providers and GUIDs...\")\n    all_providers = get_providers()\n    to_write = []\n    if not with_events:\n        for guid, name in sorted(all_providers, key=lambda x: x[1]):\n            to_write.append(f\"{guid} {name}\")\n    else:\n        print(\"Collecting all registered provider events and details (this may take a few minutes...)\")\n        for guid, name in sorted(all_providers, key=lambda x: x[1]):\n            try:\n                provider = get_provider(guid)\n                to_write.append(provider.string_details())\n            except EztwException:\n                to_write.extend(\n                    [f\"Provider GUID={guid} ({name})\", \"*\" * 40, \"\\t(Could not retrieve provider events)\"])\n            to_write.append(\"=\" * 40)\n            to_write.append(\"\")\n    with open(sys.argv[1], \"w\") as fp:\n        fp.write('\\n'.join(to_write))", "\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "eztw/scripts/tap_session.py", "chunked_list": ["\"\"\"\nThis useful script allows to \"tap\" into any pre-existing real-time trace session and start consuming\nand parsing its events.\n\nFor example:\npython -m eztw.scripts.tap_session EventLog-System\n\"\"\"\nimport sys\nimport time\n", "import time\n\nfrom ..log import LOGGER\nfrom .. import EztwSessionIterator\n\ndef main():\n    if len(sys.argv) < 2:\n        print(f\"USAGE: {sys.argv[0]} [existing real-time session name]\")\n        sys.exit(1)\n    LOGGER.info(f\"Tapping into session {sys.argv[1]!r} - press Ctrl+C to stop\")\n    for i, (event_record, parsed_event) in enumerate(EztwSessionIterator(sys.argv[1])):\n        print(f\"=== [Event {i}] {time.ctime(event_record.timestamp)} ==\")\n        print(event_record)\n        print(parsed_event)", "\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "eztw/tests/test_eztw.py", "chunked_list": ["import pytest\n\nimport subprocess\nimport ctypes\nimport struct\nimport time\n\nfrom .. import EztwController, EztwConsumer, get_provider, get_provider_config, parse_event, add_manual_provider\nfrom ..guid import GUID, canonize_GUID\nfrom ..common import FILETIME_EPOCH_DELTA_S, FILETIME_TO_SECONDS_MULTIPLIER, SYSTEMTIME", "from ..guid import GUID, canonize_GUID\nfrom ..common import FILETIME_EPOCH_DELTA_S, FILETIME_TO_SECONDS_MULTIPLIER, SYSTEMTIME\nfrom ..trace_common import EVENT_FIELD_INTYPE, EventMetadata, EventFieldMetadata\nfrom ..log import disable_logging\n\n\nclass TestEztw:\n\n    def test_process_provider(self):\n        disable_logging()\n        provider = get_provider(\"microsoft-windows-kernel-process\")\n        config = get_provider_config(provider.Event_ProcessStart_1)\n        session_name = \"test_eztw_session\"\n        found_process = False\n        with EztwController(session_name, config):\n            with EztwConsumer(session_name) as ezc:\n                new_process = subprocess.Popen(\"notepad\")\n                event_records = ezc.wait_for_events(5)\n                for event_record in event_records:\n                    if event_record.provider_guid != provider.guid or\\\n                            event_record.id != provider.Event_ProcessStart_1.id:\n                        continue\n                    parsed_event = parse_event(event_record)\n                    if parsed_event.ProcessID == new_process.pid and\\\n                            \"notepad\" in parsed_event.ImageName.lower():\n                        found_process = True\n                        break\n                new_process.kill()\n        assert found_process\n\n    @pytest.mark.parametrize(\"is_64bit\", [True, False])\n    def test_data_consumer(self, is_64bit):\n        provider_guid = canonize_GUID(\"{03020100-0504-0706-0809-0a0b0c0d0e0f}\")\n        provider_name = \"test_provider\"\n        field_names_types_and_values = [\n            (\"field_unicode_string\", EVENT_FIELD_INTYPE.INTYPE_UNICODESTRING, \"test unicode string\"),\n            (\"field_ansi_string\", EVENT_FIELD_INTYPE.INTYPE_ANSISTRING, b\"test ansi string\"),\n            (\"field_int8\", EVENT_FIELD_INTYPE.INTYPE_INT8, -1),\n            (\"field_uint8\", EVENT_FIELD_INTYPE.INTYPE_UINT8, 1),\n            (\"field_int16\", EVENT_FIELD_INTYPE.INTYPE_INT16, -1000),\n            (\"field_uint16\", EVENT_FIELD_INTYPE.INTYPE_UINT16, 1000),\n            (\"field_int32\", EVENT_FIELD_INTYPE.INTYPE_INT32, -1000000),\n            (\"field_uint32\", EVENT_FIELD_INTYPE.INTYPE_UINT32, 1000000),\n            (\"field_int64\", EVENT_FIELD_INTYPE.INTYPE_INT64, -1000000000),\n            (\"field_uint64\", EVENT_FIELD_INTYPE.INTYPE_UINT64, 1000000000),\n            (\"field_float\", EVENT_FIELD_INTYPE.INTYPE_FLOAT, -123.456),\n            (\"field_double\", EVENT_FIELD_INTYPE.INTYPE_DOUBLE, 123456.789),\n            (\"field_boolean\", EVENT_FIELD_INTYPE.INTYPE_BOOLEAN, True),\n            (\"field_guid\", EVENT_FIELD_INTYPE.INTYPE_GUID, provider_guid),\n            (\"field_pointer\", EVENT_FIELD_INTYPE.INTYPE_POINTER, 123456789),\n            (\"field_filetime\", EVENT_FIELD_INTYPE.INTYPE_FILETIME, 1234567890),\n            (\"field_systemtime\", EVENT_FIELD_INTYPE.INTYPE_SYSTEMTIME, 1234567890.0),\n            (\"field_countedstring\", EVENT_FIELD_INTYPE.INTYPE_COUNTEDSTRING, \"test 123\"),\n            (\"field_countedansistring\", EVENT_FIELD_INTYPE.INTYPE_COUNTEDANSISTRING, b\"test 123\"),\n            (\"field_size_t\", EVENT_FIELD_INTYPE.INTYPE_SIZET, 123456789),\n        ]\n        event_fields = [EventFieldMetadata(fname, ftype) for fname, ftype, _ in field_names_types_and_values]\n\n        # Special cases\n        binary_data1 = b\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\"\n        event_fields.append(EventFieldMetadata(\"field_binary1\", EVENT_FIELD_INTYPE.INTYPE_BINARY, len(binary_data1)))\n        binary_data2 = b\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\"\n        event_fields.append(EventFieldMetadata(\"field_binary2_size\", EVENT_FIELD_INTYPE.INTYPE_UINT16))\n        event_fields.append(EventFieldMetadata(\"field_binary2\", EVENT_FIELD_INTYPE.INTYPE_BINARY, \"field_binary2_size\"))\n        multi_data1 = [1, 2, 3]\n        event_fields.append(EventFieldMetadata(\"field_multi1_count\", EVENT_FIELD_INTYPE.INTYPE_UINT16))\n        event_fields.append(EventFieldMetadata(\"field_multi1\", EVENT_FIELD_INTYPE.INTYPE_UINT32, None, \"field_multi1_count\"))\n        multi_data2 = [\"qwe\", \"asd\", \"zxc\"]\n        event_fields.append(EventFieldMetadata(\"field_multi2_count\", EVENT_FIELD_INTYPE.INTYPE_UINT16))\n        event_fields.append(\n            EventFieldMetadata(\"field_multi2\", EVENT_FIELD_INTYPE.INTYPE_UNICODESTRING, None, \"field_multi2_count\"))\n        multi_data3 = [b\"qwer\", b\"asdf\", b\"zxcv\"]\n        event_fields.append(EventFieldMetadata(\"field_multi3_count\", EVENT_FIELD_INTYPE.INTYPE_UINT16))\n        event_fields.append(\n            EventFieldMetadata(\"field_multi3\", EVENT_FIELD_INTYPE.INTYPE_BINARY, 4, \"field_multi3_count\"))\n        multi_data4 = [\"qwer\", \"asdf\", \"zxcv\"]\n        event_fields.append(EventFieldMetadata(\"field_multi4_count\", EVENT_FIELD_INTYPE.INTYPE_UINT16))\n        event_fields.append(\n            EventFieldMetadata(\"field_multi4\", EVENT_FIELD_INTYPE.INTYPE_UNICODESTRING, 4, \"field_multi4_count\"))\n\n        provider_keywords = {}\n\n        # Define a new event template\n        event_id = 1234\n        event_version = 56\n        provider_events = [EventMetadata(provider_guid, event_id, event_version, \"test_event\", 0, event_fields)]\n\n        add_manual_provider(provider_guid, provider_name, provider_keywords, provider_events)\n        provider = get_provider(provider_guid)\n        event = provider.get_events_by_ids(event_id)[0]\n\n        dummy_data_parts = []\n        for _, ftype, fvalue in field_names_types_and_values:\n            if ftype is EVENT_FIELD_INTYPE.INTYPE_UNICODESTRING:\n                dummy_data_parts.append(bytes(ctypes.create_unicode_buffer(fvalue)))\n            elif ftype is EVENT_FIELD_INTYPE.INTYPE_ANSISTRING:\n                dummy_data_parts.append(bytes(ctypes.create_string_buffer(fvalue)))\n            elif ftype is EVENT_FIELD_INTYPE.INTYPE_INT8:\n                dummy_data_parts.append(struct.pack(\"b\", fvalue))\n            elif ftype is EVENT_FIELD_INTYPE.INTYPE_UINT8:\n                dummy_data_parts.append(struct.pack(\"B\", fvalue))\n            elif ftype is EVENT_FIELD_INTYPE.INTYPE_INT16:\n                dummy_data_parts.append(struct.pack(\"<h\", fvalue))\n            elif ftype is EVENT_FIELD_INTYPE.INTYPE_UINT16:\n                dummy_data_parts.append(struct.pack(\"<H\", fvalue))\n            elif ftype is EVENT_FIELD_INTYPE.INTYPE_INT32:\n                dummy_data_parts.append(struct.pack(\"<i\", fvalue))\n            elif ftype is EVENT_FIELD_INTYPE.INTYPE_UINT32:\n                dummy_data_parts.append(struct.pack(\"<I\", fvalue))\n            elif ftype is EVENT_FIELD_INTYPE.INTYPE_INT64:\n                dummy_data_parts.append(struct.pack(\"<q\", fvalue))\n            elif ftype is EVENT_FIELD_INTYPE.INTYPE_UINT64:\n                dummy_data_parts.append(struct.pack(\"<Q\", fvalue))\n            elif ftype is EVENT_FIELD_INTYPE.INTYPE_FLOAT:\n                dummy_data_parts.append(struct.pack(\"f\", fvalue))\n            elif ftype is EVENT_FIELD_INTYPE.INTYPE_DOUBLE:\n                dummy_data_parts.append(struct.pack(\"d\", fvalue))\n            elif ftype is EVENT_FIELD_INTYPE.INTYPE_BOOLEAN:\n                dummy_data_parts.append(struct.pack(\"<I\", int(fvalue)))\n            elif ftype is EVENT_FIELD_INTYPE.INTYPE_BINARY:\n                dummy_data_parts.append(fvalue)\n            elif ftype is EVENT_FIELD_INTYPE.INTYPE_GUID:\n                dummy_data_parts.append(bytes(GUID(fvalue)))\n            elif ftype is EVENT_FIELD_INTYPE.INTYPE_POINTER:\n                if is_64bit:\n                    dummy_data_parts.append(struct.pack(\"<Q\", fvalue))\n                else:\n                    dummy_data_parts.append(struct.pack(\"<I\", fvalue))\n            elif ftype is EVENT_FIELD_INTYPE.INTYPE_FILETIME:\n                if fvalue > 0:\n                    fvalue = int((fvalue + FILETIME_EPOCH_DELTA_S) / FILETIME_TO_SECONDS_MULTIPLIER)\n                dummy_data_parts.append(struct.pack(\"<Q\", fvalue))\n            elif ftype is EVENT_FIELD_INTYPE.INTYPE_SYSTEMTIME:\n                ts = time.localtime(fvalue)\n                st = SYSTEMTIME()\n                st.wYear = ts.tm_year\n                st.wMonth = ts.tm_mon\n                st.wDayOfWeek = ts.tm_wday\n                st.wDay = ts.tm_mday\n                st.wHour = ts.tm_hour\n                st.wMinute = ts.tm_min\n                st.wSecond = ts.tm_sec\n                st.wMilliseconds = 0\n                dummy_data_parts.append(bytes(st))\n            elif ftype is EVENT_FIELD_INTYPE.INTYPE_COUNTEDSTRING:\n                dummy_data_parts.append(struct.pack(\"<H\", len(fvalue)*2) + bytes(ctypes.create_unicode_buffer(fvalue))[:-2])\n            elif ftype is EVENT_FIELD_INTYPE.INTYPE_COUNTEDANSISTRING:\n                dummy_data_parts.append(struct.pack(\"<H\", len(fvalue)) + bytes(ctypes.create_string_buffer(fvalue))[:-1])\n            elif ftype is EVENT_FIELD_INTYPE.INTYPE_SIZET:\n                if is_64bit:\n                    dummy_data_parts.append(struct.pack(\"<Q\", fvalue))\n                else:\n                    dummy_data_parts.append(struct.pack(\"<I\", fvalue))\n\n        # Special cases\n        dummy_data_parts.append(binary_data1)\n        dummy_data_parts.append(struct.pack(\"<H\", len(binary_data2)))\n        dummy_data_parts.append(binary_data2)\n        dummy_data_parts.append(struct.pack(\"<H\", len(multi_data1)))\n        for x in multi_data1:\n            dummy_data_parts.append(struct.pack(\"<I\", x))\n        dummy_data_parts.append(struct.pack(\"<H\", len(multi_data2)))\n        for x in multi_data2:\n            dummy_data_parts.append(bytes(ctypes.create_unicode_buffer(x)))\n        dummy_data_parts.append(struct.pack(\"<H\", len(multi_data3)))\n        for x in multi_data3:\n            dummy_data_parts.append(x)\n        dummy_data_parts.append(struct.pack(\"<H\", len(multi_data4)))\n        for x in multi_data4:\n            dummy_data_parts.append(bytes(ctypes.create_unicode_buffer(x))[:-2])\n\n        class DummyEventRecord:\n            pass\n\n        dummy_event_record = DummyEventRecord()\n        dummy_event_record.is_64bit = is_64bit\n        dummy_event_record.provider_guid = provider_guid\n        dummy_event_record.id = event_id\n        dummy_event_record.version = event_version\n        dummy_event_record.data = b''.join(dummy_data_parts)\n\n        parsed_event = event.parse(dummy_event_record)\n\n        for fname, ftype, fvalue in field_names_types_and_values:\n            parsed_value = getattr(parsed_event, fname)\n            # Annoying Python strings\n            if ftype in [EVENT_FIELD_INTYPE.INTYPE_ANSISTRING, EVENT_FIELD_INTYPE.INTYPE_COUNTEDANSISTRING]:\n                parsed_value = parsed_value.encode()\n            elif ftype in [EVENT_FIELD_INTYPE.INTYPE_FLOAT, EVENT_FIELD_INTYPE.INTYPE_DOUBLE]:\n                parsed_value = round(parsed_value, 3)\n            assert(parsed_value == fvalue)\n\n        # Special cases\n        assert parsed_event.field_binary1 == binary_data1\n        assert parsed_event.field_binary2 == binary_data2\n        assert parsed_event.field_multi1 == multi_data1\n        assert parsed_event.field_multi2 == multi_data2\n        assert parsed_event.field_multi3 == multi_data3\n        assert parsed_event.field_multi4 == multi_data4", ""]}
{"filename": "eztw/tests/__init__.py", "chunked_list": [""]}
