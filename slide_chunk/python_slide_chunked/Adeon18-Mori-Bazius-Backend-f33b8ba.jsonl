{"filename": "app/APIGetawayService/main.py", "chunked_list": ["import sys\nimport os\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))) # I LOVE PYTHON\n\nimport uvicorn\nfrom controller.gateway_controller import App\n\nif __name__ == '__main__':\n    app = App()\n    uvicorn.run(app.app, port=9000, host='0.0.0.0')", ""]}
{"filename": "app/APIGetawayService/controller/gateway_controller.py", "chunked_list": ["from fastapi import FastAPI\nfrom service.gateway_service import GatewayService\nfrom common.game_data.stats import Stats\nfrom common.game_data.resources import Resources\nfrom common.game_data.user import User\nfrom common.game_data.guild import GuildCreation, Member\n\n\nclass App:\n    def __init__(self):\n        self.app = FastAPI()\n        self.service = GatewayService()\n\n        # HANGLING REGISTRATION VALIDATION ETC\n        @self.app.post(\"/register\")\n        async def game_register_post(user_data: User):\n            return self.service.handle_register_operation(user_data)\n\n        @self.app.post(\"/login\")\n        async def game_login_post(user_data: User):\n            return self.service.handle_login_operation(user_data)\n\n        # HANDLING GAME DATA\n        @self.app.get(\"/game_data/stats\")\n        async def game_data_stats(player_id: int):\n            return self.service.get_game_stats(player_id)\n\n        @self.app.post(\"/game_data/stats\")\n        async def game_data_set_stats(player_id: int, stats: Stats):\n            return self.service.set_game_stats(player_id, stats)\n\n        @self.app.get(\"/game_data/resources\")\n        async def game_data_resources(player_id: int):\n            return self.service.get_game_resources(player_id)\n\n        @self.app.post(\"/game_data/resources\")\n        async def game_data_set_resources(player_id: int, resources: Resources):\n            return self.service.set_game_resources(player_id, resources)\n\n        @self.app.get(\"/game_data/leaderboard\")\n        async def game_data_leaderboard(limit: int):\n            return self.service.get_game_leaderboard(limit)\n        \n        @self.app.get(\"/game_data/average\")\n        async def game_data_average(player_id: int):\n            return self.service.get_game_data_average(player_id)\n\n        # HANDLING GUILDS\n        @self.app.get(\"/guilds\")\n        async def get_guilds(limit: int):\n            return self.service.get_guilds(limit)\n\n        @self.app.get(\"/members\")\n        async def get_members(gid: str):\n            return self.service.get_members(gid)\n\n        @self.app.get(\"/guild\")\n        async def get_guild_by_member(player_id: int):\n            return self.service.get_guild_by_member(player_id)\n\n        @self.app.post(\"/guilds/new\")\n        async def create_guild(new_guild: GuildCreation):\n            print(new_guild)\n            return self.service.create_guild(dict(new_guild))\n\n        @self.app.post(\"/guilds/members/new\")\n        async def join_guild(member: Member):\n            return self.service.join_guild(member)\n\n        @self.app.delete(\"/guilds/leave\")\n        async def leave_guild(gid: str, player_id: int):\n            return self.service.leave_guild(gid, player_id)\n\n        @self.app.delete(\"/guilds/delete\")\n        async def delete_guild(gid: str):\n            return self.service.delete_guild(gid)", "class App:\n    def __init__(self):\n        self.app = FastAPI()\n        self.service = GatewayService()\n\n        # HANGLING REGISTRATION VALIDATION ETC\n        @self.app.post(\"/register\")\n        async def game_register_post(user_data: User):\n            return self.service.handle_register_operation(user_data)\n\n        @self.app.post(\"/login\")\n        async def game_login_post(user_data: User):\n            return self.service.handle_login_operation(user_data)\n\n        # HANDLING GAME DATA\n        @self.app.get(\"/game_data/stats\")\n        async def game_data_stats(player_id: int):\n            return self.service.get_game_stats(player_id)\n\n        @self.app.post(\"/game_data/stats\")\n        async def game_data_set_stats(player_id: int, stats: Stats):\n            return self.service.set_game_stats(player_id, stats)\n\n        @self.app.get(\"/game_data/resources\")\n        async def game_data_resources(player_id: int):\n            return self.service.get_game_resources(player_id)\n\n        @self.app.post(\"/game_data/resources\")\n        async def game_data_set_resources(player_id: int, resources: Resources):\n            return self.service.set_game_resources(player_id, resources)\n\n        @self.app.get(\"/game_data/leaderboard\")\n        async def game_data_leaderboard(limit: int):\n            return self.service.get_game_leaderboard(limit)\n        \n        @self.app.get(\"/game_data/average\")\n        async def game_data_average(player_id: int):\n            return self.service.get_game_data_average(player_id)\n\n        # HANDLING GUILDS\n        @self.app.get(\"/guilds\")\n        async def get_guilds(limit: int):\n            return self.service.get_guilds(limit)\n\n        @self.app.get(\"/members\")\n        async def get_members(gid: str):\n            return self.service.get_members(gid)\n\n        @self.app.get(\"/guild\")\n        async def get_guild_by_member(player_id: int):\n            return self.service.get_guild_by_member(player_id)\n\n        @self.app.post(\"/guilds/new\")\n        async def create_guild(new_guild: GuildCreation):\n            print(new_guild)\n            return self.service.create_guild(dict(new_guild))\n\n        @self.app.post(\"/guilds/members/new\")\n        async def join_guild(member: Member):\n            return self.service.join_guild(member)\n\n        @self.app.delete(\"/guilds/leave\")\n        async def leave_guild(gid: str, player_id: int):\n            return self.service.leave_guild(gid, player_id)\n\n        @self.app.delete(\"/guilds/delete\")\n        async def delete_guild(gid: str):\n            return self.service.delete_guild(gid)", ""]}
{"filename": "app/APIGetawayService/controller/__init__.py", "chunked_list": [""]}
{"filename": "app/APIGetawayService/service/__init__.py", "chunked_list": [""]}
{"filename": "app/APIGetawayService/service/gateway_service.py", "chunked_list": ["from common.game_data.stats import Stats\nfrom common.game_data.resources import Resources\nfrom common.game_data.user import User\nfrom common.game_data.guild import GuildCreation, Member\n\nfrom kafka import KafkaProducer\n\nimport requests\nimport consul\nimport json", "import consul\nimport json\nimport random\n\nKAFKA_SERVER = 'kafka-server:9092'\nGAME_DATA_TOPIC = 'game-data'\nGAME_STATS_TOPIC = 'game-stats'\n\nREGISTER_SERVICE_URL = 'http://register-service:8080/user/'\nLOGIN_SERVICE_URL = 'http://login-service:8080/login/user/'", "REGISTER_SERVICE_URL = 'http://register-service:8080/user/'\nLOGIN_SERVICE_URL = 'http://login-service:8080/login/user/'\nVALIDATION_SERVICE_URL = 'http://validation-service:8080/c/'\n\nSTATS_GAME_DATA_URL = 'http://game_data:8000/stats?player_id='\nRESOURCES_GAME_DATA_URL = 'http://game_data:8000/resources?player_id='\nLEADERBOARD_URL = \"http://game_data:8000/leaderboard?limit=\"\nAVERAGE_GAME_DATA_URL = 'http://game_data:8000/resources?player_id='\n\n# Guilds service urls", "\n# Guilds service urls\nGUILDS_URL = \"http://guilds-service:6969/guilds?limit={}\"\nGUILD_MEMBERS_URL = \"http://guilds-service:6969/members?gid={}\"\nGUILD_BY_MEMBER_URL = \"http://guilds-service:6969/guild?player_id={}\"\nCREATE_GUILD_URL = \"http://guilds-service:6969/guilds/new\"\nJOIN_GUILD_URL = \"http://guilds-service:6969/guilds/members/new\"\nLEAVE_GUILD_URL = \"http://guilds-service:6969/guilds/leave?gid={}&player_id={}\"\nDELETE_GUILD_URL = \"http://guilds-service:6969/guilds/delete?gid={}\"\n", "DELETE_GUILD_URL = \"http://guilds-service:6969/guilds/delete?gid={}\"\n\n\nclass GatewayService:\n    def __init__(self):\n        self.producer = KafkaProducer(bootstrap_servers=[KAFKA_SERVER])\n        self.consul_service = consul.Consul(host=\"consul\")\n\n    # Returns a boolean whether the validation was successful\n    def verify_request(self, uid: str, token: str):\n        url, port = self.get_address(\"validation\")\n        response = requests.post(\n            url=f\"http://{url}:{port}/validate\", json={\"uid\": uid, \"token\": token})\n\n        if response.text == \"true\":\n            return True\n\n        return False\n\n    def get_address(self, service_name):\n        consul_info = self.consul_service.health.service(service_name)[1]\n        address = random.choice(consul_info)[\"Service\"][\"Address\"]\n        port = random.choice(consul_info)[\"Service\"][\"Port\"]\n        return address, port\n\n    def handle_register_operation(self, user_data: User):\n        response = requests.post(\n            url=REGISTER_SERVICE_URL, json={\"username\": user_data.username, \"password\": user_data.password})\n\n        return response.json()\n\n    def handle_login_operation(self, user_data: User):\n        response = requests.post(\n            url=LOGIN_SERVICE_URL, json=dict(user_data))\n\n        return response.json()\n\n    def get_game_resources(self, player_id: int):\n        url, port = self.get_address(\"game-data\")\n        response = requests.get(url=f'http://{url}:{port}/resources?player_id=' + str(player_id))\n\n        return response.json()\n\n    def set_game_resources(self, player_id: int, resources: Resources):\n        # Verify the sender\n        if (not self.verify_request(resources.player_id, resources.token)):\n            print(\"Bad token: \" + resources.token, flush=True)\n            return {\"success\": False}\n\n        resources.token = None\n\n        # sync for now\n        metadata = self.producer.send(GAME_DATA_TOPIC, json.dumps(\n            resources.dict()).encode()).get(timeout=10)\n\n        return {\"success\": True, \"topic\": metadata.topic}\n\n    def get_game_stats(self, player_id: int):\n        url, port = self.get_address(\"game-data\")\n        response = requests.get(url=f\"http://{url}:{port}/stats?player_id=\" + str(player_id))\n\n        return response.json()\n\n    def set_game_stats(self, player_id: int, stats: Stats):\n        # Verify the sender\n        if (not self.verify_request(stats.player_id, stats.token)):\n            print(\"Bad token: \" + stats.token, flush=True)\n            return {\"success\": False}\n\n        stats.token = None\n\n        # set gata in game_data\n        metadata = self.producer.send(GAME_STATS_TOPIC, json.dumps(\n            stats.dict()).encode()).get(timeout=10)\n\n        return {\"success\": True, \"topic\": metadata.topic}\n\n    def get_game_leaderboard(self, limit):\n        url, port = self.get_address(\"game-data\")\n        response = requests.get(url=f\"http://{url}:{port}/leaderboard?limit={limit}\")\n\n        return response.json()\n\n    def get_game_data_average(self, player_id: int):\n        url, port = self.get_address(\"game-data\")\n        response = requests.get(url=f'http://{url}:{port}/average?player_id=' + str(player_id))\n\n        return response.json()\n\n    def get_guilds(self, limit: int):\n        response = requests.get(GUILDS_URL.format(limit))\n        return response.json()\n\n    def get_members(self, gid: str):\n        response = requests.get(GUILD_MEMBERS_URL.format(gid))\n        return response.json()\n\n    def get_guild_by_member(self, player_id: int):\n        response = requests.get(GUILD_BY_MEMBER_URL.format(player_id))\n        return response.json()\n\n    def create_guild(self, new_guild: GuildCreation):\n        print(new_guild)\n        response = requests.post(CREATE_GUILD_URL, json=new_guild)\n        return response.json()\n\n    def join_guild(self, member: Member):\n        response = requests.post(JOIN_GUILD_URL, json=member.dict())\n        return response.json()\n\n    def leave_guild(self, gid: str, player_id: int):\n        response = requests.delete(LEAVE_GUILD_URL.format(gid, player_id))\n        return response.json()\n\n    def delete_guild(self, gid: str):\n        response = requests.delete(DELETE_GUILD_URL.format(gid))\n        return response.json()", "\n"]}
{"filename": "app/game_data_service/main.py", "chunked_list": ["import sys\nimport os\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))) # I LOVE PYTHON\n\nfrom fastapi import FastAPI\nfrom contextlib import asynccontextmanager\n\nfrom service.game_data_service import GameDataService\nfrom common.game_data.stats import Stats\nfrom common.game_data.resources import Resources", "from common.game_data.stats import Stats\nfrom common.game_data.resources import Resources\n\n\nservice = GameDataService.new_service_with_cassandra()\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    # Startup\n    service.create_consume_data_task()", "    # Startup\n    service.create_consume_data_task()\n    service.create_consume_stats_task()\n\n    yield\n\n    # Shutdown\n    await service.shutdown_consumers()\n\napp = FastAPI(lifespan=lifespan)", "\napp = FastAPI(lifespan=lifespan)\n\n\n@app.get(\"/stats\")\nasync def stats(player_id: int):\n    return service.get_stats(player_id)\n\n@app.post(\"/stats\")\nasync def update_stats(player_id: int, stats: Stats):", "@app.post(\"/stats\")\nasync def update_stats(player_id: int, stats: Stats):\n    service.set_stats(player_id, stats)\n    return stats\n    \n\n@app.get(\"/resources\")\nasync def resources(player_id: int):\n    return service.get_resources(player_id)\n", "    return service.get_resources(player_id)\n\n@app.post(\"/resources\")\nasync def update_resources(player_id: int, resources: Resources):\n    service.set_resources(player_id, resources)\n    return resources\n\n@app.get(\"/leaderboard\")\nasync def leaderboard(limit: int):\n    return service.get_leaderboard(limit)", "async def leaderboard(limit: int):\n    return service.get_leaderboard(limit)\n\n@app.get(\"/average\")\nasync def average_resources(player_id: int):\n    return service.get_average_resources(player_id)\n\n@app.get(\"/health\")\ndef healthcheck():\n    return True", "def healthcheck():\n    return True"]}
{"filename": "app/game_data_service/repository/__init__.py", "chunked_list": [""]}
{"filename": "app/game_data_service/repository/cassandra_repository.py", "chunked_list": ["import os\nimport json\nfrom collections import namedtuple\nfrom common.game_data.stats import Stats\nfrom cassandra.cluster import Cluster\n\nfrom repository.game_data_repository import GameDataRepository\n\nfrom common.game_data.resources import Resources\nfrom common.game_data.stats import Stats", "from common.game_data.resources import Resources\nfrom common.game_data.stats import Stats\n\nclass CassandraRepository(GameDataRepository):\n    def __init__(self) -> None:\n        cassandra_endpoint = os.getenv(\"CASSANDRA_ENDPOINT\", \"localhost\")\n        cassandra_port = os.getenv(\"CASSANDRA_PORT\", 9042)\n\n        self.cassandra_client = Cluster([cassandra_endpoint], port=cassandra_port)\n        self.session = self.cassandra_client.connect()\n\n    \n    def get_stats(self, player_id: int) -> dict:\n        query = f\"\"\"\n        SELECT * FROM hunters.player_stats_by_player_id\n        WHERE player_id = {player_id}\n        \"\"\"\n        res = self.session.execute(query)\n        json = []\n        for row in res:\n            result = {}\n            for column in row._fields:\n                result[column] = getattr(row, column)\n            json.append(result)\n            break\n\n\n        return json[0] if len(json) > 0 else {}\n    \n    def get_resources(self, player_id: int) -> dict:\n        query = f\"\"\"\n        SELECT * FROM hunters.game_data_by_player_id\n        WHERE player_id = {player_id}\n        \"\"\"\n        res = self.session.execute(query)\n        json = []\n        for row in res:\n            result = {}\n            for column in row._fields:\n                result[column] = getattr(row, column)\n            json.append(result)\n            break\n\n\n        return json[0] if len(json) > 0 else {}\n    \n    def set_stats(self, player_id: int, stats: Stats):\n        stats_to_update = dict(((key, value) for key, value in vars(stats).items() if value is not None))\n        keys_to_update = list(stats_to_update.keys())\n        values_to_update = [stats_to_update[key] for key in keys_to_update]\n\n        if \"player_id\" not in stats_to_update:\n            keys_to_update.insert(0, \"player_id\")\n            values_to_update.insert(0, player_id)\n\n        query = f\"\"\"\n        INSERT INTO hunters.player_stats_by_player_id \n        ({\", \".join(keys_to_update)}) VALUES ({\", \".join([\"?\" for _ in values_to_update])})\n        \"\"\"\n        query = self.session.prepare(query)\n\n        self.session.execute(query, values_to_update)\n\n    def set_resources(self, player_id: int, resources: Resources):\n        resources_to_update = dict(((key, value) for key, value in vars(resources).items() if value is not None))\n        keys_to_update = list(resources_to_update.keys())\n        values_to_update = [resources_to_update[key] for key in keys_to_update]\n\n        if \"player_id\" not in resources_to_update:\n            keys_to_update.insert(0, \"player_id\")\n            values_to_update.insert(0, player_id)\n\n        query = f\"\"\"\n        INSERT INTO hunters.game_data_by_player_id \n        ({\", \".join(keys_to_update)}) VALUES ({\", \".join([\"?\" for _ in values_to_update])})\n        \"\"\"\n        query = self.session.prepare(query)\n\n        self.session.execute(query, values_to_update)\n    \n    def delete_stats(self, stats: Stats):\n        query = f\"\"\"\n        DELETE FROM hunters.player_stats_by_player_id WHERE player_id = {stats.player_id}\n        \"\"\"\n        \n        res = self.session.execute(query)\n\n    def get_leaderboard(self, limit: int):\n        query = f\"\"\"\n        SELECT * FROM hunters.player_stats_by_player_id\n        \"\"\"\n\n        result_set = self.session.execute(query)\n\n        # This is stupid, but it doesn't work any other way\n        column_names = result_set.column_names\n        Row = namedtuple('Row', column_names)\n\n        leaderboard_data = []\n        for row in result_set:\n            row_data = Row(*row)\n            leaderboard_data.append(row_data._asdict())\n\n        leaderboard_data = sorted(leaderboard_data, key=lambda x: x[\"power\"], reverse=True)\n        if limit is not None:\n            leaderboard_data = leaderboard_data[:limit]\n\n        return leaderboard_data\n\n    def get_average_resources(self, player_id: int):\n        query = f\"\"\"\n        SELECT * FROM hunters.average_growth_by_player_id WHERE player_id = {player_id}\n        \"\"\"\n\n        res = self.session.execute(query)\n        json = []\n        for row in res:\n            result = {}\n            for column in row._fields:\n                result[column] = getattr(row, column)\n            json.append(result)\n            break\n\n\n        return json[0] if len(json) > 0 else {}", "\n"]}
{"filename": "app/game_data_service/repository/game_data_repository.py", "chunked_list": ["from common.game_data.resources import Resources\nfrom common.game_data.stats import Stats\n\nclass GameDataRepository:\n    def __init__(self) -> None:\n        pass\n    \n    def get_stats(self, player_id: int):\n        pass\n\n    def get_resources(self, player_id: int):\n        pass\n\n    def set_stats(self, player_id: int, stats: Stats):\n        pass\n\n    def set_resources(self, player_id: int, resources: Resources):\n        pass\n\n    def delete_stats(self, stats: Stats):\n        pass\n\n    def get_leaderboard(self, limit: int):\n        pass\n\n    def get_average_resources(self, player_id: int):\n        pass"]}
{"filename": "app/game_data_service/service/game_data_service.py", "chunked_list": ["from aiokafka import AIOKafkaConsumer\nimport asyncio\nimport os\nimport consul\nimport socket\n\nfrom repository.game_data_repository import GameDataRepository\nfrom repository.cassandra_repository import CassandraRepository\n\nfrom common.game_data.resources import Resources", "\nfrom common.game_data.resources import Resources\nfrom common.game_data.stats import Stats\n\nclass GameDataService:\n    def __init__(self, repo: GameDataRepository) -> None:\n        self.repo = repo\n        kafka_address = os.getenv(\"KAFKA_ADDRESS\", \"localhost:29092\")\n\n        self.consul_service = consul.Consul(host=\"consul\")\n        hostname = socket.gethostname()\n        self.id = os.environ[\"SERVICE_ID\"]\n        check = consul.Check.http(f\"http://{hostname}:8000/health\", \"10s\", \"2s\", \"20s\")\n        self.name = \"game-data\"\n        self.consul_service.agent.service.register(self.name, service_id=self.name + self.id, address=hostname,\n                                                   port=8000, check=check)\n        \n        self.event_loop = asyncio.get_event_loop()\n        self.data_consumer = AIOKafkaConsumer(\"game-data\", loop=self.event_loop, bootstrap_servers=kafka_address, group_id=\"game_data_consumer\", auto_offset_reset=\"earliest\", enable_auto_commit=True)\n        self.stats_consumer = AIOKafkaConsumer(\"game-stats\", loop=self.event_loop, bootstrap_servers=kafka_address, group_id=\"game_data_consumer\", auto_offset_reset=\"earliest\", enable_auto_commit=True)\n    \n    def new_service_with_cassandra():\n        return GameDataService(CassandraRepository())\n\n    def get_stats(self, player_id: int) -> Stats:\n        stats = self.repo.get_stats(player_id)\n        return Stats.parse_obj(stats)\n\n    def get_resources(self, player_id: int) -> Resources:\n        resources = self.repo.get_resources(player_id)\n        return Resources.parse_obj(resources)\n\n    def set_stats(self, player_id: int, stats: Stats):\n        old_stats = self.get_stats(stats.player_id)\n        if stats.power is not None and old_stats.power is not None and old_stats.power != stats.power:\n            for field_name, field_val in vars(stats).items():\n                if not callable(field_val) and field_val is None:\n                    setattr(stats, field_name, getattr(old_stats, field_name))\n            self.delete_stats(old_stats)\n\n        self.repo.set_stats(stats.player_id, stats)\n\n    def set_resources(self, player_id: int, resources: Resources):\n        self.repo.set_resources(player_id, resources)\n    \n    def delete_stats(self, stats: Stats):\n        self.repo.delete_stats(stats)\n    \n    async def consume_data(self):\n        await self.data_consumer.start()\n\n        try:\n            async for msg in self.data_consumer:\n                print(f\"consumed data: {msg.value.decode('utf-8')}\")\n                resources = Resources.parse_raw(msg.value)\n                self.set_resources(resources.player_id, resources)\n        finally:\n            await self.data_consumer.stop()\n\n    async def consume_stats(self):\n        await self.stats_consumer.start()\n\n        try:\n            async for msg in self.stats_consumer:\n                print(f\"consumed stats: {msg.value.decode('utf-8')}\")\n                stats = Stats.parse_raw(msg.value)\n                self.set_stats(stats.player_id, stats)\n        finally:\n            await self.stats_consumer.stop()\n\n    def create_consume_stats_task(self):\n        self.event_loop.create_task(self.consume_stats())\n        \n    def create_consume_data_task(self):\n        self.event_loop.create_task(self.consume_data())\n\n    async def shutdown_consumers(self):\n        await self.data_consumer.stop()\n        await self.stats_consumer.stop()\n\n    def get_leaderboard(self, limit: int):\n        return self.repo.get_leaderboard(limit)\n\n    def get_average_resources(self, player_id: int):\n        return self.repo.get_average_resources(player_id)", ""]}
{"filename": "app/game_data_service/service/__init__.py", "chunked_list": [""]}
{"filename": "app/SnapshotService/main.py", "chunked_list": ["import asyncio\nimport sys\nimport os\nsys.path.append(os.path.abspath(os.path.join(\n    os.path.dirname(__file__), '..')))  # I LOVE PYTHON\n\nfrom service.snapshot_service import SnapShotService\nfrom contextlib import asynccontextmanager\nfrom fastapi import FastAPI\n", "from fastapi import FastAPI\n\nservice = SnapShotService()\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    # Startup\n    asyncio.get_event_loop().create_task(service.make_stat_snapshot())\n    asyncio.get_event_loop().create_task(service.make_resource_snapshot())\n    asyncio.get_event_loop().create_task(service.delete_old_stat_snapshot())", "    asyncio.get_event_loop().create_task(service.make_resource_snapshot())\n    asyncio.get_event_loop().create_task(service.delete_old_stat_snapshot())\n    asyncio.get_event_loop().create_task(service.delete_old_resource_snapshot())\n    yield\n\n\napp = FastAPI(lifespan=lifespan)\n\n\n@app.get(\"/logged_stats\")", "\n@app.get(\"/logged_stats\")\nasync def logged_stats(player_id: int, last_minutes: int):\n    return service.get_last_N_minute_stats(player_id, last_minutes)\n\n@app.get(\"/logged_resources\")\nasync def logged_resources(player_id: int, last_minutes: int):\n    return service.get_last_N_minute_resources(player_id, last_minutes)\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=9010)", "\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=9010)\n"]}
{"filename": "app/SnapshotService/repository/snapshot_service_repository.py", "chunked_list": ["import os\nfrom collections import namedtuple\nfrom cassandra.cluster import Cluster\n\n\nclass SnapshotServiceRepository():\n    def __init__(self) -> None:\n        cassandra_endpoint = os.getenv(\"CASSANDRA_ENDPOINT\", \"localhost\")\n        cassandra_port = os.getenv(\"CASSANDRA_PORT\", 9042)\n\n        self.cassandra_client = Cluster(\n            [cassandra_endpoint], port=cassandra_port)\n        self.session = self.cassandra_client.connect()\n\n    def get_last_stat_logs_player_id_range(self, player_id: int, start_time: str, end_time: str) -> dict:\n        query = f\"\"\"\n        SELECT * FROM hunters.player_stats_by_player_id_and_time_logs WHERE player_id = {player_id} AND time < '{end_time}' AND time > '{start_time}'\"\"\"\n        res = self.session.execute(query)\n        json = []\n        for row in res:\n            result = {}\n            for column in row._fields:\n                result[column] = getattr(row, column)\n            json.append(result)\n\n        return json\n\n    def get_last_resource_logs_player_id_range(self, player_id: int, start_time: str, end_time: str) -> dict:\n        query = f\"\"\"\n        SELECT * FROM hunters.game_data_by_player_id_and_time_logs WHERE player_id = {player_id} AND time < '{end_time}' AND time > '{start_time}'\"\"\"\n        res = self.session.execute(query)\n        json = []\n        for row in res:\n            result = {}\n            for column in row._fields:\n                result[column] = getattr(row, column)\n            json.append(result)\n\n        return json\n\n    # Get stats for all players\n    def get_all_stats(self) -> dict:\n        query = f\"\"\"\n        SELECT * FROM hunters.player_stats_by_player_id\"\"\"\n        res = self.session.execute(query)\n        json = []\n        for row in res:\n            result = {}\n            for column in row._fields:\n                result[column] = getattr(row, column)\n            json.append(result)\n\n        return json\n\n    # Get resources for all players\n    def get_all_resources(self) -> dict:\n        query = f\"\"\"\n        SELECT * FROM hunters.game_data_by_player_id\"\"\"\n        res = self.session.execute(query)\n        json = []\n        for row in res:\n            result = {}\n            for column in row._fields:\n                result[column] = getattr(row, column)\n            json.append(result)\n\n        return json\n\n    # Insert all data updated with time into the logs\n    # TODO: Make it a batch insert\n    def add_stat_snapshot(self, stat_list: list):\n        for stat_entry in stat_list:\n            keys_to_update = list(stat_entry.keys())\n            values_to_update = [stat_entry[key] for key in keys_to_update]\n\n            query = f\"\"\"\n            INSERT INTO hunters.player_stats_by_player_id_and_time_logs\n            ({\", \".join(keys_to_update)}) VALUES ({\", \".join([\"?\" for _ in values_to_update])})\n            \"\"\"\n            query = self.session.prepare(query)\n\n            self.session.execute(query, values_to_update)\n\n    # Insert all data updated with time into the logs\n    # TODO: Make it a batch insert\n    def add_resource_snapshot(self, res_list: list):\n        for stat_entry in res_list:\n            keys_to_update = list(stat_entry.keys())\n            values_to_update = [stat_entry[key] for key in keys_to_update]\n\n            query = f\"\"\"\n            INSERT INTO hunters.game_data_by_player_id_and_time_logs\n            ({\", \".join(keys_to_update)}) VALUES ({\", \".join([\"?\" for _ in values_to_update])})\n            \"\"\"\n            query = self.session.prepare(query)\n\n            self.session.execute(query, values_to_update)\n\n    def delete_old_stats_snapshots(self, time: str):\n        query = f\"\"\"\n        SELECT player_id FROM hunters.player_stats_by_player_id\"\"\"\n        res = self.session.execute(query)\n        for row in res:\n            for column in row._fields:\n                pid = getattr(row, column)\n\n            query = f\"\"\"\n            DELETE FROM hunters.player_stats_by_player_id_and_time_logs WHERE player_id = {pid} AND time < '{time}'\n            \"\"\"\n\n            res = self.session.execute(query)\n\n    def delete_old_resource_snapshots(self, time: str):\n        query = f\"\"\"\n        SELECT player_id FROM hunters.game_data_by_player_id\"\"\"\n        res = self.session.execute(query)\n        for row in res:\n            for column in row._fields:\n                pid = getattr(row, column)\n\n            query = f\"\"\"\n            DELETE FROM hunters.game_data_by_player_id_and_time_logs WHERE player_id = {pid} AND time < '{time}'\n            \"\"\"\n\n            res = self.session.execute(query)", ""]}
{"filename": "app/SnapshotService/service/snapshot_service.py", "chunked_list": ["import asyncio\nimport sys\nimport os\nsys.path.append(os.path.abspath(os.path.join(\n    os.path.dirname(__file__), '..')))  # I LOVE PYTHON\n\nfrom repository.snapshot_service_repository import SnapshotServiceRepository\nfrom contextlib import asynccontextmanager\nfrom fastapi import FastAPI\nfrom datetime import datetime, timedelta", "from fastapi import FastAPI\nfrom datetime import datetime, timedelta\n\n\nclass SnapShotService:\n    def __init__(self):\n        self.repo = SnapshotServiceRepository()\n\n    def get_last_N_minute_stats(self, player_id: int, N: int):\n        current_time = datetime.now()\n        end_time = current_time.strftime(\"%Y-%m-%d-%H-%M\")\n\n        time_minus_N = current_time - timedelta(minutes=N)\n        start_time = time_minus_N.strftime(\"%Y-%m-%d-%H-%M\")\n\n        return self.repo.get_last_stat_logs_player_id_range(player_id, start_time, end_time)\n\n    def get_last_N_minute_resources(self, player_id: int, N: int):\n        current_time = datetime.now()\n        end_time = current_time.strftime(\"%Y-%m-%d-%H-%M\")\n\n        time_minus_N = current_time - timedelta(minutes=N)\n        start_time = time_minus_N.strftime(\"%Y-%m-%d-%H-%M\")\n\n        return self.repo.get_last_resource_logs_player_id_range(player_id, start_time, end_time)\n\n    async def make_stat_snapshot(self):\n        while True:\n            current_time = datetime.now()\n            time_string = current_time.strftime(\"%Y-%m-%d-%H-%M\")\n\n            # Add your processing logic here\n            stats = self.repo.get_all_stats()\n            for stat in stats:\n                stat[\"time\"] = time_string\n            self.repo.add_stat_snapshot(stats)\n            print(\"Added stats snapshit at \" + time_string)\n\n            await asyncio.sleep(120)  # Sleep for 2 minutes (120 seconds)\n\n    async def make_resource_snapshot(self):\n        while True:\n            current_time = datetime.now()\n            time_string = current_time.strftime(\"%Y-%m-%d-%H-%M\")\n            # Add your processing logic here\n            resources = self.repo.get_all_resources()\n            for res in resources:\n                res[\"time\"] = time_string\n            self.repo.add_resource_snapshot(resources)\n            print(\"Added resource snapshit at \" + time_string)\n\n            await asyncio.sleep(120)  # Sleep for 2 minutes (120 seconds)\n\n    async def delete_old_stat_snapshot(self):\n        while True:\n            current_time = datetime.now()\n\n            time_minus_N = current_time - timedelta(minutes=120)\n            time = time_minus_N.strftime(\"%Y-%m-%d-%H-%M\")\n\n            self.repo.delete_old_stats_snapshots(time)\n\n            print(\"Deleted stat snapshots that are older than 120 mins\")\n\n            await asyncio.sleep(7200)  # Sleep for 2 hours (7200 seconds)\n\n    async def delete_old_resource_snapshot(self):\n        while True:\n            current_time = datetime.now()\n\n            time_minus_N = current_time - timedelta(minutes=120)\n            time = time_minus_N.strftime(\"%Y-%m-%d-%H-%M\")\n\n            self.repo.delete_old_resource_snapshots(time)\n\n            print(\"Deleted resource snapshots that are older than 120 mins\")\n\n            await asyncio.sleep(7200)  # Sleep for 2 hours (7200 seconds)"]}
{"filename": "app/GuildsService/__init__.py", "chunked_list": [""]}
{"filename": "app/GuildsService/models/guild.py", "chunked_list": ["from uuid import uuid4\nfrom pydantic import BaseModel, Field\nfrom typing import Union\n\n\nclass Guild(BaseModel):\n    name: str\n    description: str\n    num_members: int\n    limit_members: int", "\n\nclass Member(BaseModel):\n    gid: Union[str, None]\n    player_id: int\n    player_name: str\n\n\nclass GuildCreation(BaseModel):\n    name: str\n    description: str\n    num_members: int = 0\n    limit_members: int\n\n    player_id: int\n    player_name: str", "class GuildCreation(BaseModel):\n    name: str\n    description: str\n    num_members: int = 0\n    limit_members: int\n\n    player_id: int\n    player_name: str\n\n\nif __name__ == \"__main__\":\n    a = GuildCreation(name=\"name\", description=\"description\", limit_members=20, player_id=1, player_name=\"name\")\n    print(a)\n    print(Guild(**a.dict()))", "\n\nif __name__ == \"__main__\":\n    a = GuildCreation(name=\"name\", description=\"description\", limit_members=20, player_id=1, player_name=\"name\")\n    print(a)\n    print(Guild(**a.dict()))"]}
{"filename": "app/GuildsService/models/__init__.py", "chunked_list": [""]}
{"filename": "app/GuildsService/controller/guilds_controller.py", "chunked_list": ["from service.guilds_service import GuildsService\nfrom models.guild import Guild, Member, GuildCreation\n\nfrom fastapi import FastAPI\nimport uvicorn\n\n\nclass GuildsController:\n    def __init__(self):\n        self.app = FastAPI()\n        self.service = GuildsService()\n\n        @self.app.get(\"/guilds\")\n        async def get_guilds(limit: int):\n            r = await self.service.get_guilds(limit)\n            return r\n\n        @self.app.get(\"/members\")\n        async def get_members(gid: str):\n            r = await self.service.get_members(gid)\n            return r\n\n        @self.app.get(\"/guild\")\n        async def get_guild_by_member(player_id: int):\n            return await self.service.get_guild_by_member(player_id)\n\n        @self.app.post(\"/guilds/new\")\n        async def create_guild(new_guild: GuildCreation):\n            gid = await self.service.create_guild(new_guild)\n            if gid:\n                member = Member(gid=gid, player_id=new_guild.player_id, player_name=new_guild.player_name)\n                await self.service.join_guild(member)\n                return member\n\n        @self.app.post(\"/guilds/members/new\")\n        async def join_guild(member: Member):\n            await self.service.join_guild(member)\n            return member\n\n        @self.app.delete(\"/guilds/leave\")\n        async def leave_guild(gid: str, player_id: int):\n            await self.service.leave_guild(gid, player_id)\n            return True\n\n        @self.app.delete(\"/guilds/delete\")\n        async def delete_guild(gid: str):\n            await self.service.delete_guild(gid)\n            return gid", "\n\ncontroller = GuildsController()\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(controller.app, host=\"0.0.0.0\", port=6969)\n"]}
{"filename": "app/GuildsService/controller/__init__.py", "chunked_list": [""]}
{"filename": "app/GuildsService/service/guilds_service.py", "chunked_list": ["from pymongo import MongoClient\nfrom bson.objectid import ObjectId\nfrom models.guild import Guild, Member, GuildCreation\nfrom fastapi import HTTPException\nfrom typing import Union\n\n\nclass GuildsService:\n    def __init__(self):\n        self.client = MongoClient(\"mongodb\", 27017)\n        db = self.client[\"guilds\"]\n        self.guilds = db['guilds']\n        self.members = db['members']\n\n    async def get_guilds(self, limit: int):\n        guilds = list(self.guilds.find())[:limit]\n        if guilds:\n            for doc in guilds:\n                doc[\"_id\"] = str(doc[\"_id\"])\n        return guilds\n        # return {\"guilds\": guilds}\n\n    async def get_members(self, gid: str):\n        members = list(self.members.find({\"gid\": gid}))\n        if members:\n            for member in members:\n                member.pop(\"_id\", None)\n        return members\n\n    async def get_guild_by_member(self, player_id: int):\n        entry = self.members.find_one({\"player_id\": player_id})\n        if entry:\n            guild = self.guilds.find_one({\"_id\": ObjectId(entry[\"gid\"])})\n            guild[\"_id\"] = str(guild[\"_id\"])  # parse hex\n            return guild\n\n    async def create_guild(self, guild: GuildCreation):\n        result = self.guilds.insert_one(Guild(**guild.dict()).dict())\n        if result.acknowledged:\n            return str(result.inserted_id)\n\n    async def join_guild(self, member: Member):\n        # member_exists = self.members.find_one(member.dict())\n        # if member_exists:\n        #     return False\n\n        # guild = self.guilds.find_one({\"_id\": ObjectId(member.gid)})\n        # if not guild:\n        #     return False\n\n        self.members.insert_one(member.dict())\n        self.guilds.update_one({\"_id\": ObjectId(member.gid)}, {\"$inc\": {\"num_members\": 1}})\n        return True\n\n    async def leave_guild(self, gid: str, player_id: int):\n        self.guilds.update_one({\"_id\": ObjectId(gid)}, {\"$inc\": {\"num_members\": -1}})\n        self.members.delete_one({\"gid\": gid, \"player_id\": player_id})\n        guild = self.guilds.find_one({\"_id\": ObjectId(gid)})\n        # if not guild:\n        #     return False\n        if guild[\"num_members\"] == 0:\n            await self.delete_guild(gid)\n        return True\n\n    async def delete_guild(self, gid: str):\n        self.guilds.delete_one({\"_id\": ObjectId(gid)})\n        self.members.delete_many({\"gid\": gid})\n        return True", ""]}
{"filename": "app/GuildsService/service/__init__.py", "chunked_list": [""]}
{"filename": "app/common/game_data/guild.py", "chunked_list": ["from uuid import uuid4\nfrom pydantic import BaseModel, Field\nfrom typing import Union\n\n\nclass Guild(BaseModel):\n    name: str\n    description: str\n    num_members: int\n    limit_members: int", "\n\nclass Member(BaseModel):\n    gid: Union[str, None]\n    player_id: int\n    player_name: str\n\n\nclass GuildCreation(BaseModel):\n    name: str\n    description: str\n    num_members: int = 0\n    limit_members: int\n\n    player_id: int\n    player_name: str", "class GuildCreation(BaseModel):\n    name: str\n    description: str\n    num_members: int = 0\n    limit_members: int\n\n    player_id: int\n    player_name: str\n\n\nif __name__ == \"__main__\":\n    a = GuildCreation(name=\"name\", description=\"description\", limit_members=20, player_id=1, player_name=\"name\")\n    print(a)\n    print(Guild(**a.dict()))", "\n\nif __name__ == \"__main__\":\n    a = GuildCreation(name=\"name\", description=\"description\", limit_members=20, player_id=1, player_name=\"name\")\n    print(a)\n    print(Guild(**a.dict()))"]}
{"filename": "app/common/game_data/__init__.py", "chunked_list": [""]}
{"filename": "app/common/game_data/user.py", "chunked_list": ["from pydantic import BaseModel\nfrom typing import Union\nimport datetime\n\n\nclass User(BaseModel):\n    username: Union[str, None] = None\n    password: Union[str, None] = None\n    uid: Union[int, None] = None\n    created_on: Union[datetime.datetime, None] = None", "\n\nclass UserValidationData(BaseModel):\n    uid: Union[str, None] = None\n    token: Union[str, None] = None\n"]}
{"filename": "app/common/game_data/stats.py", "chunked_list": ["from pydantic import BaseModel\n\n\nclass Stats(BaseModel):\n    player_id: int | None = None\n    token: str | None = None\n    player_name: str | None = None\n    level: int | None = None\n    power: int | None = None\n    exp: int | None = None\n    hunters: int | None = None\n    masters: int | None = None", ""]}
{"filename": "app/common/game_data/resources.py", "chunked_list": ["from pydantic import BaseModel\n\n\nclass Resources(BaseModel):\n    player_id: int | None = None\n    token: str | None = None\n    player_name: str | None = None\n\n    # Utils\n    monster_bone: int | None = None\n    leather_scraps: int | None = None\n    oil: int | None = None\n\n    # Armor\n    armor: int | None = None\n    mastercrafted_armor: int | None = None\n\n    # Swords\n    silver_sword: int | None = None\n    kingslayers_silver_sword: int | None = None\n    steel_sword: int | None = None\n    kingslayers_steel_sword: int | None = None\n\n    # Diamonds\n    diamond_dust: int | None = None\n    diamond: int | None = None\n\n    # Ingots\n    dark_steel_ingot: int | None = None\n    meteorite_silver_ingot: int | None = None\n    green_gold_ingot: int | None = None\n\n    # Potions\n    swallow_potion: int | None = None\n\n    # Ores\n    dark_steel_ore: int | None = None\n    meteorite_silver_ore: int | None = None\n    green_gold_ore: int | None = None\n\n    # Herbs\n    arenaria: int | None = None\n    nostrix: int | None = None\n    wolfsbane: int | None = None", ""]}
{"filename": "app/StatsProcessing/stats_processing.py", "chunked_list": ["import time\nfrom pyspark.sql import SparkSession\nfrom pyspark.sql.functions import avg, col, lag\nfrom pyspark.sql.window import Window\n\n\nspark = SparkSession.builder\\\n    .appName(\"CassandraTableReader\") \\\n    .config(\"spark.cassandra.connection.host\",\"cassandra-node-1\")\\\n    .config(\"spark.cassandra.connection.port\",\"9042\")\\", "    .config(\"spark.cassandra.connection.host\",\"cassandra-node-1\")\\\n    .config(\"spark.cassandra.connection.port\",\"9042\")\\\n    .getOrCreate()\n\ndef hourly_job():\n    df = spark.read\\\n    .format(\"org.apache.spark.sql.cassandra\")\\\n    .options(table=\"game_data_by_player_id_and_time_logs\", keyspace=\"hunters\")\\\n    .load()\n    \n    # Calculate average growth for each column\n    columns = [\n        \"monster_bone\", \"leather_scraps\", \"oil\",\n        \"armor\", \"mastercrafted_armor\",\n        \"silver_sword\", \"kingslayers_silver_sword\",\n        \"steel_sword\", \"kingslayers_steel_sword\",\n        \"diamond_dust\", \"diamond\",\n        \"dark_steel_ingot\", \"meteorite_silver_ingot\", \"green_gold_ingot\",\n        \"swallow_potion\",\n        \"dark_steel_ore\", \"meteorite_silver_ore\", \"green_gold_ore\",\n        \"arenaria\", \"nostrix\", \"wolfsbane\"\n    ]\n\n    growth_df = df.withColumn(\"previous_player_id\", lag(\"player_id\").over(Window.orderBy(\"time\")))\n\n    for column in columns:\n        growth_column = \"growth_\" + column\n        growth_df = growth_df.withColumn(growth_column, col(column) - lag(col(column)).over(Window.partitionBy(\"player_id\").orderBy(\"time\")))\n\n    growth_df = growth_df.filter(growth_df.previous_player_id.isNotNull()).drop(\"previous_player_id\")\n    \n    avg_growth_df = growth_df.groupBy(\"player_id\").agg(*[avg(col).alias(\"avg_\" + col) for col in growth_df.columns if col.startswith(\"growth_\")])\n    # Write avg_growth_df to Cassandra table, replacing old values\n    avg_growth_df.write\\\n        .format(\"org.apache.spark.sql.cassandra\")\\\n        .options(table=\"average_growth_by_player_id\", keyspace=\"hunters\")\\\n        .mode(\"overwrite\")\\\n        .option(\"confirm.truncate\", \"true\")\\\n        .save()", "\n\nwhile True:\n    hourly_job()\n\n    # Sleep for 1 minute\n    time.sleep(60)\n\n    # # Sleep for 1 hour\n    # time.sleep(3600)", "    # # Sleep for 1 hour\n    # time.sleep(3600)\n\nspark.stop()"]}
{"filename": "app/tests/test_to_test.py", "chunked_list": ["import unittest\n\n\ndef add_numbers(a, b):\n    return a + b\n\n\nclass TestAddNumbers(unittest.TestCase):\n\n    def test_add_positive_numbers(self):\n        result = add_numbers(2, 3)\n        self.assertEqual(result, 5)\n\n    def test_add_negative_numbers(self):\n        result = add_numbers(-2, -3)\n        self.assertEqual(result, -5)\n\n    def test_add_zero(self):\n        result = add_numbers(0, 0)\n        self.assertEqual(result, 0)", "\n\nif __name__ == '__main__':\n    unittest.main()\n"]}
{"filename": "app/RegistrationLoginValidation/ValidationService/ValidationService.py", "chunked_list": ["from User import User\nfrom ValidationRepositoryInMemory import ValidationRepositoryInMemory\nfrom ValidationRepositoryHaz import ValidationRepositoryHaz\n\nimport secrets\nimport consul\nimport os\nimport socket\n\n\nclass ValidationService:\n    def __init__(self):\n        self.repository = ValidationRepositoryHaz()\n        self.consul_service = consul.Consul(host=\"consul\")\n        hostname = socket.gethostname()\n        self.id = os.environ[\"SERVICE_ID\"]\n        check = consul.Check.http(f\"http://{hostname}:8080/health\", \"10s\", \"2s\", \"20s\")\n        self.name = \"validation\"\n        self.consul_service.agent.service.register(self.name, service_id=self.name + self.id, address=hostname,\n                                                   port=8080, check=check)\n        self.repository.add_map_name(self.consul_service.kv.get('map-name')[1][\"Value\"].decode('utf-8'))\n\n    def log_user(self, uid):\n        token = secrets.token_hex(20)\n        self.repository.add_user_token(uid, token)\n        return token\n\n    def validate_user(self, uid, token):\n        stored_token = self.repository.get_user_token(uid)\n        return token == stored_token and stored_token != \"none\"", "\n\nclass ValidationService:\n    def __init__(self):\n        self.repository = ValidationRepositoryHaz()\n        self.consul_service = consul.Consul(host=\"consul\")\n        hostname = socket.gethostname()\n        self.id = os.environ[\"SERVICE_ID\"]\n        check = consul.Check.http(f\"http://{hostname}:8080/health\", \"10s\", \"2s\", \"20s\")\n        self.name = \"validation\"\n        self.consul_service.agent.service.register(self.name, service_id=self.name + self.id, address=hostname,\n                                                   port=8080, check=check)\n        self.repository.add_map_name(self.consul_service.kv.get('map-name')[1][\"Value\"].decode('utf-8'))\n\n    def log_user(self, uid):\n        token = secrets.token_hex(20)\n        self.repository.add_user_token(uid, token)\n        return token\n\n    def validate_user(self, uid, token):\n        stored_token = self.repository.get_user_token(uid)\n        return token == stored_token and stored_token != \"none\"", ""]}
{"filename": "app/RegistrationLoginValidation/ValidationService/User.py", "chunked_list": ["from pydantic import BaseModel\nfrom typing import Union\nimport datetime\n\n\nclass User(BaseModel):\n    username: str\n    password: str\n    uid: Union[int, None] = None\n    created_on: Union[datetime.datetime, None] = None", "\nclass UidTok(BaseModel):\n    uid: int\n    token: str"]}
{"filename": "app/RegistrationLoginValidation/ValidationService/ValidationRepositoryHaz.py", "chunked_list": ["import hazelcast\n\n\nclass ValidationRepositoryHaz:\n    def __init__(self):\n        self.logged_users = None\n        self.client = hazelcast.HazelcastClient(cluster_members=[\"hazelcast1\"])\n\n    def add_user_token(self, uid, token):\n        self.logged_users.lock(uid)\n        self.logged_users.put(uid, token).result()\n        self.logged_users.unlock(uid)\n\n    def add_map_name(self, map_name: str):\n        self.logged_users = self.client.get_map(map_name)\n\n    def get_user_token(self, uid):\n        return self.logged_users.get(uid).result() if self.logged_users.contains_key(uid).result() else \"none\"", ""]}
{"filename": "app/RegistrationLoginValidation/ValidationService/ValidationController.py", "chunked_list": ["from fastapi import FastAPI\nimport uvicorn\nfrom User import UidTok\nfrom ValidationService import ValidationService\nfrom pydantic import BaseModel\n\n\nclass LoginController:\n    def __init__(self):\n        self.app = FastAPI()\n        self.service = ValidationService()\n\n        @self.app.post(\"/log/{uid}\")\n        def post_user(uid: int):\n            token = self.service.log_user(uid)\n            return token\n\n        @self.app.post(\"/validate\")\n        def validate_user(user: UidTok) -> bool:\n            res = self.service.validate_user(user.uid, user.token)\n            return res\n\n        @self.app.get(\"/health\")\n        def health_check():\n            return True", "\n\ncontroller = LoginController()\n\nif __name__ == \"__main__\":\n    uvicorn.run(controller.app, port=8080, host=\"0.0.0.0\")\n"]}
{"filename": "app/RegistrationLoginValidation/ValidationService/ValidationRepositoryInMemory.py", "chunked_list": ["class ValidationRepositoryInMemory:\n    def __init__(self):\n        self.logged_users = dict()\n\n    def add_user_token(self, uid, token):\n        self.logged_users[uid] = token\n\n    def get_user_token(self, uid):\n        return self.logged_users[uid] if uid in self.logged_users.keys() else \"none\"\n", ""]}
{"filename": "app/RegistrationLoginValidation/LoginService/LoginController.py", "chunked_list": ["from fastapi import FastAPI\nimport uvicorn\nfrom User import User\nfrom LoginService import LoginService\nfrom fastapi import FastAPI, HTTPException\n\n\nclass LoginController:\n    def __init__(self):\n        self.app = FastAPI()\n        self.service = LoginService()\n\n        @self.app.post(\"/login/user/\")\n        def login_user(user: User):\n            logged_user = self.service.try_login_user(user)\n            return logged_user", "\n\ncontroller = LoginController()\n\nif __name__ == \"__main__\":\n    uvicorn.run(controller.app, port=8080, host=\"0.0.0.0\")\n"]}
{"filename": "app/RegistrationLoginValidation/LoginService/LoginService.py", "chunked_list": ["from User import User, UidTok\nfrom LoginRepositoryPostgress import LoginRepositoryPostgress\nfrom fastapi import HTTPException\nimport requests\nimport random\nimport consul\n\n\nclass LoginService:\n    def __init__(self):\n        self.repository = LoginRepositoryPostgress()\n        self.consul_service = consul.Consul(host=\"consul\")\n\n    def try_login_user(self, user: User) -> UidTok:\n        uid = self.repository.get_user_uid(user)\n        if uid is not None:\n            uid = uid[0]\n            print(f\"user exists, uid {uid}\")\n            url, port = self.get_address(\"validation\")\n            response = requests.post(url=f\"http://{url}:{port}/log/\" + str(uid))\n            token = response.text\n            print(token)\n            return UidTok(uid=uid, token=token)\n        else:\n            print(\"incorrect credentials\")\n            raise HTTPException(status_code=401, detail=\"Invalid Credentials\")\n\n    def get_address(self, service_name):\n        consul_info = self.consul_service.health.service(service_name)[1]\n        address = random.choice(consul_info)[\"Service\"][\"Address\"]\n        port = random.choice(consul_info)[\"Service\"][\"Port\"]\n        return address, port", "class LoginService:\n    def __init__(self):\n        self.repository = LoginRepositoryPostgress()\n        self.consul_service = consul.Consul(host=\"consul\")\n\n    def try_login_user(self, user: User) -> UidTok:\n        uid = self.repository.get_user_uid(user)\n        if uid is not None:\n            uid = uid[0]\n            print(f\"user exists, uid {uid}\")\n            url, port = self.get_address(\"validation\")\n            response = requests.post(url=f\"http://{url}:{port}/log/\" + str(uid))\n            token = response.text\n            print(token)\n            return UidTok(uid=uid, token=token)\n        else:\n            print(\"incorrect credentials\")\n            raise HTTPException(status_code=401, detail=\"Invalid Credentials\")\n\n    def get_address(self, service_name):\n        consul_info = self.consul_service.health.service(service_name)[1]\n        address = random.choice(consul_info)[\"Service\"][\"Address\"]\n        port = random.choice(consul_info)[\"Service\"][\"Port\"]\n        return address, port", ""]}
{"filename": "app/RegistrationLoginValidation/LoginService/User.py", "chunked_list": ["from pydantic import BaseModel\nfrom typing import Union\nimport datetime\n\n\nclass User(BaseModel):\n    username: str\n    password: str\n    uid: Union[int, None] = None\n    created_on: Union[datetime.datetime, None] = None", "\nclass UidTok(BaseModel):\n    uid: int\n    token: str"]}
{"filename": "app/RegistrationLoginValidation/LoginService/LoginRepositoryPostgress.py", "chunked_list": ["from User import User\nimport psycopg2\n\n\nclass LoginRepositoryPostgress:\n    def __init__(self):\n        self.conn = psycopg2.connect(database=\"users\",\n                                     host=\"postgresql\",\n                                     user=\"admin\",\n                                     password=\"admin\",\n                                     port=\"5432\")\n        self.cursor = self.conn.cursor()\n        print(\"connected\")\n\n    def get_user_uid(self, user: User):\n        self.cursor.execute(f\"SELECT * FROM users WHERE username='{user.username}' AND password='{user.password}'\")\n        res = self.cursor.fetchone()\n        return res", ""]}
{"filename": "app/RegistrationLoginValidation/RegisterService/User.py", "chunked_list": ["from pydantic import BaseModel\nfrom typing import Union\nimport datetime\n\n\nclass User(BaseModel):\n    username: str\n    password: str\n    uid: Union[int, None] = None\n    created_on: Union[datetime.datetime, None] = None", "\nclass UidTok(BaseModel):\n    uid: int\n    token: str"]}
{"filename": "app/RegistrationLoginValidation/RegisterService/RegisterService.py", "chunked_list": ["from User import User, UidTok\nfrom RegisterRepositoryPostgress import RegisterRepositoryPostgress\nimport requests\nfrom fastapi import HTTPException\nimport random\nimport consul\n\nclass RegisterService:\n    def __init__(self):\n        self.repository = RegisterRepositoryPostgress()\n        self.consul_service = consul.Consul(host=\"consul\")\n\n\n    def get_user(self, uid: int) -> User:\n        result = self.repository.get_user(uid)\n        print(result)\n        user = User(uid=result[0], username=result[1], password=result[2], created_on=result[3])\n        return user\n\n    def add_user(self, user: User) -> UidTok:\n        res = self.repository.register_user(user)\n        uid = res[0]\n        url, port = self.get_address(\"validation\")\n        response = requests.post(url=f\"http://{url}:{port}/log/\" + str(uid))\n        if response.status_code != 200:\n            raise HTTPException(status_code=response.status_code, detail=response.text)\n        token = response.text\n        print(f\"{uid}: {token}\")\n        return UidTok(uid=uid, token=token)\n\n    def delete_user(self, uid):\n        pass\n\n    def get_address(self, service_name):\n        consul_info = self.consul_service.health.service(service_name)[1]\n        address = random.choice(consul_info)[\"Service\"][\"Address\"]\n        port = random.choice(consul_info)[\"Service\"][\"Port\"]\n        return address, port", "\n"]}
{"filename": "app/RegistrationLoginValidation/RegisterService/RegisterRepositoryPostgress.py", "chunked_list": ["from User import User\nimport psycopg2\nfrom fastapi import HTTPException\n\nclass RegisterRepositoryPostgress:\n    def __init__(self):\n        self.conn = psycopg2.connect(database=\"users\",\n                                     host=\"postgresql\",\n                                     user=\"admin\",\n                                     password=\"admin\",\n                                     port=\"5432\")\n        self.cursor = self.conn.cursor()\n        print(\"connected\")\n\n    def register_user(self, user: User):\n        self.cursor.execute(f\"SELECT exists (SELECT 1 FROM users WHERE username='{user.username}')\")\n        if self.cursor.fetchone()[0]:\n            raise HTTPException(status_code=409, detail=\"user already exists\")\n        self.cursor.execute(\n            f\"INSERT INTO users(username, password, created_on) VALUES ('{user.username}', '{str(user.password)}',\\\n             current_timestamp) RETURNING uid\")\n        self.conn.commit()\n        return self.cursor.fetchone()\n\n    def del_user(self, uid):\n        pass\n\n    def get_user(self, uid):\n        self.cursor.execute(f\"SELECT * FROM users WHERE uid={uid}\")\n        self.conn.commit()\n        return self.cursor.fetchone()", ""]}
{"filename": "app/RegistrationLoginValidation/RegisterService/RegisterController.py", "chunked_list": ["from fastapi import FastAPI\nimport uvicorn\nfrom User import User, UidTok\nfrom RegisterService import RegisterService\n\n\nclass RegisterController:\n    def __init__(self):\n        self.app = FastAPI()\n        self.service = RegisterService()\n\n        @self.app.get(\"/user/{uid}\")\n        def get_user(uid: int) -> User:\n            user = self.service.get_user(uid)\n            return user\n\n        @self.app.post(\"/user\")\n        def post_user(user: User) -> UidTok:\n            uid_tok = self.service.add_user(user)\n            return uid_tok", "\n\ncontroller = RegisterController()\n\nif __name__ == \"__main__\":\n    uvicorn.run(controller.app, port=8080, host=\"0.0.0.0\")\n"]}
