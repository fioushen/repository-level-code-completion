{"filename": "scripts/import_content.py", "chunked_list": ["import os\nimport sys\nfrom pathlib import Path\n\n# FIXME: CHANGE THIS TO GETTING PATH\n\nROOT_DIR = str(Path(os.path.abspath(__file__)).parent.parent)\n\nsys.path.append(ROOT_DIR)\n", "sys.path.append(ROOT_DIR)\n\nimport asyncio\nfrom argparse import ArgumentParser\nfrom datetime import UTC, datetime, timedelta\nfrom uuid import uuid4\n\nimport pandas as pd\n\nfrom skill.db.repos.get_repo import get_repo", "\nfrom skill.db.repos.get_repo import get_repo\nfrom skill.entities import Activity, Tip, TipsTopic\nfrom skill.utils import TextWithTTS\n\n\ndef prep(s: str) -> str:\n    return s.replace('\"', \"\")\n\n", "\n\nasync def extract_activities(activities: pd.DataFrame) -> list[Activity]:\n    activities_to_insert: list[Activity] = []\n\n    for _, row in activities.iterrows():\n        hours, minutes = list(map(lambda x: int(x), row[2].split(\":\")))\n\n        activities_to_insert.append(\n            Activity(\n                uuid4(),\n                TextWithTTS(row[0], row[1]),\n                occupation_time=timedelta(hours=hours, minutes=minutes),\n                repo=repo,\n                created_date=datetime.utcnow().astimezone(UTC),\n            )\n        )", "\n    return activities_to_insert\n\n\nasync def extract_tips_topics(\n    tips_topics: pd.DataFrame,\n) -> list[TipsTopic]:\n    tips_topics_to_insert: list[TipsTopic] = []\n\n    for _, row in tips_topics.iterrows():\n        tips_topics_to_insert.append(\n            TipsTopic(\n                uuid4(),\n                TextWithTTS(\n                    prep(row.iloc[0]).lower().strip(), prep(row.iloc[1])\n                ),\n                TextWithTTS(prep(row.iloc[2]), prep(row.iloc[3])),\n                created_date=datetime.utcnow().astimezone(UTC),\n                repo=repo,\n            )\n        )", "\n    for _, row in tips_topics.iterrows():\n        tips_topics_to_insert.append(\n            TipsTopic(\n                uuid4(),\n                TextWithTTS(\n                    prep(row.iloc[0]).lower().strip(), prep(row.iloc[1])\n                ),\n                TextWithTTS(prep(row.iloc[2]), prep(row.iloc[3])),\n                created_date=datetime.utcnow().astimezone(UTC),\n                repo=repo,\n            )\n        )", "\n    return tips_topics_to_insert\n\n\nasync def extract_tips(\n    tips: pd.DataFrame,\n) -> list[Tip]:\n    tips_to_insert: list[Tip] = []\n\n    for _, row in tips.iterrows():\n        # topic = list(\n        #     filter(\n        #         lambda tips_topic: tips_topic.name.text.lower()\n        #         == row.topic_name.lower(),\n        #         tips_topics,\n        #     )\n        # )[0]\n\n        # if not topic:\n        #     raise ValueError(\n        #         f\"No topic with next name: {row.topic_name}\\n\"\n        #         f\"This error found in row with next data: {row}\"\n        # )\n\n        topic_name = prep(row.iloc[4]).lower().strip()\n\n        topic = await repo.get_tips_topic_by_name(topic_name)\n\n        if not topic:\n            print(f\"No topic with such topic name: {topic_name}\")\n            sys.exit()\n\n        tips_to_insert.append(\n            Tip(\n                uuid4(),\n                TextWithTTS(prep(row.iloc[0]), prep(row.iloc[1])),\n                TextWithTTS(prep(row.iloc[2]), prep(row.iloc[3])),\n                tips_topic=topic,\n                created_date=datetime.utcnow().astimezone(UTC),\n                repo=repo,\n            )\n        )", "\n    for _, row in tips.iterrows():\n        # topic = list(\n        #     filter(\n        #         lambda tips_topic: tips_topic.name.text.lower()\n        #         == row.topic_name.lower(),\n        #         tips_topics,\n        #     )\n        # )[0]\n\n        # if not topic:\n        #     raise ValueError(\n        #         f\"No topic with next name: {row.topic_name}\\n\"\n        #         f\"This error found in row with next data: {row}\"\n        # )\n\n        topic_name = prep(row.iloc[4]).lower().strip()\n\n        topic = await repo.get_tips_topic_by_name(topic_name)\n\n        if not topic:\n            print(f\"No topic with such topic name: {topic_name}\")\n            sys.exit()\n\n        tips_to_insert.append(\n            Tip(\n                uuid4(),\n                TextWithTTS(prep(row.iloc[0]), prep(row.iloc[1])),\n                TextWithTTS(prep(row.iloc[2]), prep(row.iloc[3])),\n                tips_topic=topic,\n                created_date=datetime.utcnow().astimezone(UTC),\n                repo=repo,\n            )\n        )", "\n    return tips_to_insert\n\n\nif __name__ == \"__main__\":\n    parser = ArgumentParser(\n        description=\"Manager for tips and activities content\"\n    )\n\n    parser.add_argument(\n        \"-a\",\n        \"--activities\",\n        action=\"store_true\",\n        help=\"either drop all activities and import new ones or not\",\n    )\n\n    parser.add_argument(\n        \"-T\",\n        \"--tips\",\n        action=\"store_true\",\n        help=\"either drop all tips topics with all tips and\"\n        \"import new ones or not\",\n    )\n\n    args = vars(parser.parse_args())\n\n    if not (args.get(\"activities\") or args.get(\"tips\")):\n        print(\n            \"At least one correct argument should be provided. \"\n            \"If you need help, add --help flag\"\n        )\n        sys.exit()\n\n    repo = get_repo(\"sa\")\n\n    loop = asyncio.get_event_loop()\n\n    if args.get(\"activities\"):\n        activities = pd.read_csv(\n            ROOT_DIR + \"/content/activities.csv\", index_col=False\n        )\n\n        extracted_activities = loop.run_until_complete(\n            extract_activities(activities)\n        )\n\n        loop.run_until_complete(repo.delete_all_activities())\n\n        loop.run_until_complete(repo.insert_activities(extracted_activities))\n\n    if args.get(\"tips\"):\n        tips_topics = pd.read_csv(\n            ROOT_DIR + \"/content/tips_topics.csv\", index_col=False\n        )\n\n        extracted_topics = loop.run_until_complete(\n            extract_tips_topics(tips_topics)\n        )\n\n        loop.run_until_complete(repo.delete_all_tips_topics())\n\n        loop.run_until_complete(repo.insert_tips_topics(extracted_topics))\n\n        tips = pd.read_csv(ROOT_DIR + \"/content/tips.csv\", index_col=False)\n\n        extracted_tips = loop.run_until_complete(extract_tips(tips))\n\n        loop.run_until_complete(repo.delete_all_tips())\n\n        loop.run_until_complete(repo.insert_tips(extracted_tips))\n\n    print(\"Content successfully imported!\")\n\n    loop.close()", ""]}
{"filename": "tests/sa_db_settings.py", "chunked_list": ["import os\nfrom pathlib import Path\n\nfrom dotenv import load_dotenv\nfrom sqlalchemy import event\nfrom sqlalchemy.engine import Engine\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\n\nfrom skill.db.repos.sa_repo import SARepoConfig", "\nfrom skill.db.repos.sa_repo import SARepoConfig\n\nload_dotenv()\n\n\n# Needed for some developing features\n# Should be False when production\nDEBUG = os.getenv(\"BOT_TOKEN\") or False\n", "DEBUG = os.getenv(\"BOT_TOKEN\") or False\n\nDB_PROVIDER = os.getenv(\"TEST_DB_PROVIDER\") or \"sqlite\"\n\nmatch DB_PROVIDER:\n    case \"postgres\":\n        POSTGRES_DRIVER_NAME = (\n            os.getenv(\"TEST_POSTGRES_DRIVER_NAME\") or \"asyncpg\"\n        )\n", "        )\n\n        POSTGRES_DB_NAME = os.getenv(\"TEST_POSTGRES_DB_NAME\") or \"postgres\"\n\n        POSTGRES_USERNAME = os.getenv(\"TEST_POSTGRES_USERNAME\") or \"postgres\"\n\n        POSTGRES_HOST = os.getenv(\"TEST_POSTGRES_HOST\") or \"localhost\"\n\n        POSTGRES_DB_PORT = os.getenv(\"TEST_POSTGRES_PORT\") or \"5432\"\n", "        POSTGRES_DB_PORT = os.getenv(\"TEST_POSTGRES_PORT\") or \"5432\"\n\n        POSTGRES_PASSWORD = os.getenv(\"TEST_POSTGRES_PASSWORD\") or \"postgres\"\n\n        if not POSTGRES_PASSWORD:\n            raise EnvironmentError(\n                \"POSTGRES_PASSWORD required if you are using PostgreSQL\"\n            )\n\n        DB_URL = (", "\n        DB_URL = (\n            f\"postgresql+{POSTGRES_DRIVER_NAME}://\"\n            + f\"{POSTGRES_USERNAME}:{POSTGRES_PASSWORD}\"\n            + f\"@{POSTGRES_HOST}:{POSTGRES_DB_PORT}\"\n            + f\"/{POSTGRES_DB_NAME}\"\n        )\n\n    case _:\n        SQLITE_DRIVER_NAME = (", "    case _:\n        SQLITE_DRIVER_NAME = (\n            os.getenv(\"TEST_SQLITE_DRIVER_NAME\") or \"aiosqlite\"\n        )\n\n        SQLITE_DB_NAME = os.getenv(\"TEST_SQLITE_DB_NAME\") or \"SAMPLEDATA.db\"\n\n        ROOT_DIR = Path(__file__).parent.parent.parent.resolve()\n\n        # In case you want to change path to SQLite DB file,", "\n        # In case you want to change path to SQLite DB file,\n        # just change this variable\n        SQLITE_DB_FILE_PATH = os.getenv(\n            \"TEST_SQLITE_DB_FILE_PATH\"\n        ) or os.path.join(ROOT_DIR, f\"{SQLITE_DB_NAME}\")\n\n        # URL for your database\n        DB_URL = f\"sqlite+{SQLITE_DRIVER_NAME}:///\" + SQLITE_DB_FILE_PATH\n", "        DB_URL = f\"sqlite+{SQLITE_DRIVER_NAME}:///\" + SQLITE_DB_FILE_PATH\n\n\nengine = create_async_engine(DB_URL, echo=False)\n\n\nasync_session = sessionmaker(  # type: ignore\n    engine, expire_on_commit=False, class_=AsyncSession  # type: ignore\n)\n", ")\n\nsa_repo_config = SARepoConfig(connection_provider=async_session)\n\n\nif DB_PROVIDER == \"sqlite\":\n\n    @event.listens_for(Engine, \"connect\")\n    def set_sqlite_pragma(dbapi_connection, connection_record):\n        cursor = dbapi_connection.cursor()", "    def set_sqlite_pragma(dbapi_connection, connection_record):\n        cursor = dbapi_connection.cursor()\n        cursor.execute(\"PRAGMA foreign_keys=ON\")\n        cursor.close()\n"]}
{"filename": "tests/test_dataconvert.py", "chunked_list": ["import datetime\n\nfrom skill.dataconvert.ya_converter import YaDataConverter\n\n\ndef test_data_convert():\n    dataconvert = YaDataConverter()\n    test_obj = {\n        \"type\": \"YANDEX.DATETIME\",\n        \"value\": {\n            \"year\": 1982,\n            \"month\": 9,\n            \"day\": 15,\n            \"hour\": 22,\n            \"minute\": 30,\n        }\n    }\n    converted1 = dataconvert.datetime(test_obj, \"UTC\")\n    needed1 = datetime.datetime(1982, 9, 15, 22, 30, tzinfo=datetime.UTC)\n    assert converted1 == needed1\n    converted2 = dataconvert.time(test_obj, \"UTC\")\n    needed2 = datetime.time(22, 30, tzinfo=datetime.UTC)\n    assert converted2 == needed2", ""]}
{"filename": "tests/__init__.py", "chunked_list": [""]}
{"filename": "tests/test_api.py", "chunked_list": ["import requests as r\n\nfrom skill.states import States\n\nTIME_REQUEST = {\n    \"meta\": {\n        \"locale\": \"ru-RU\",\n        \"timezone\": \"Europe/Moscow\",\n        \"client_id\": \"ru.yandex.searchplugin/7.16 (none none; android 4.4.2)\",\n        \"interfaces\": {\"screen\": {}, \"account_linking\": {}, \"audio_player\": {}},", "        \"client_id\": \"ru.yandex.searchplugin/7.16 (none none; android 4.4.2)\",\n        \"interfaces\": {\"screen\": {}, \"account_linking\": {}, \"audio_player\": {}},\n    },\n    \"request\": {\n        \"command\": \"\u0412\u043e \u0441\u043a\u043e\u043b\u044c\u043a\u043e \u043c\u043d\u0435 \u043d\u0430\u0434\u043e \u043b\u0435\u0447\u044c, \u0447\u0442\u043e\u0431\u044b \u0432\u0441\u0442\u0430\u0442\u044c \u0432 7:00\",\n        \"type\": \"SimpleUtterance\",\n        \"nlu\": {\n            \"intents\": {\n                \"sleep_calc\": {\n                    \"slots\": {", "                \"sleep_calc\": {\n                    \"slots\": {\n                        \"time\": {\n                            \"type\": \"YANDEX.DATETIME\",\n                            \"value\": {\"hour\": 7, \"minute\": 0},\n                        }\n                    }\n                }\n            }\n        },", "            }\n        },\n    },\n    \"session\": {\n        \"message_id\": 0,\n        \"session_id\": \"2eac4854-fce721f3-b845abba-20d60\",\n        \"skill_id\": \"3ad36498-f5rd-4079-a14b-788652932056\",\n        \"user_id\": \"47C73714B580ED2469056E71081159529FFC676A4E5B059D629A819E857DC2F8\",\n        \"user\": {\n            \"user_id\": \"6C91DA5198D1758C6A9F63A7C5CDDF09359F683B13A18A151FBF4C8B092BB0C2\",", "        \"user\": {\n            \"user_id\": \"6C91DA5198D1758C6A9F63A7C5CDDF09359F683B13A18A151FBF4C8B092BB0C2\",\n            \"access_token\": \"AgAAAAAB4vpbAAApoR1oaCd5yR6eiXSHqOGT8dT\",\n        },\n        \"application\": {\n            \"application_id\": \"47C73714B580ED2469056E71081159529FFC676A4E5B059D629A819E857DC2F8\"\n        },\n        \"new\": True,\n    },\n    \"state\": {", "    },\n    \"state\": {\n        \"session\": {\"value\": 10},\n        \"user\": {\"value\": 42},\n        \"application\": {\"value\": 37},\n    },\n    \"version\": \"1.0\",\n}\n\n\ndef make_request(command: str) -> dict:\n    return {\n        \"meta\": {\n            \"locale\": \"ru-RU\",\n            \"timezone\": \"Europe/Moscow\",\n            \"client_id\": \"ru.yandex.searchplugin/5.80 (Samsung Galaxy; Android 4.4)\",\n            \"interfaces\": {\"screen\": {}, \"account_linking\": {}},\n        },\n        \"request\": {\n            \"command\": command,\n            \"original_utterance\": command,\n            \"type\": \"SimpleUtterance\",\n            \"markup\": {\"dangerous_context\": True},\n            \"payload\": {},\n        },\n        \"session\": {\n            \"message_id\": 0,\n            \"session_id\": \"2eac4854-fce721f3-b845abba-20d60\",\n            \"skill_id\": \"3ad36498-f5rd-4079-a14b-788652932056\",\n            \"user_id\": \"47C73714B580ED2469056E71081159529FFC676A4E5B059D629A819E857DC2F8\",\n            \"user\": {\n                \"user_id\": \"6C91DA5198D1758C6A9F63A7C5CDDF09359F683B13A18A151FBF4C8B092BB0C2\",\n                \"access_token\": \"AgAAAAAB4vpbAAApoR1oaCd5yR6eiXSHqOGT8dT\",\n            },\n            \"application\": {\n                \"application_id\": \"47C73714B580ED2469056E71081159529FFC676A4E5B059D629A819E857DC2F8\"\n            },\n            \"new\": True,\n        },\n        \"version\": \"1.0\",\n    }", "\n\ndef make_request(command: str) -> dict:\n    return {\n        \"meta\": {\n            \"locale\": \"ru-RU\",\n            \"timezone\": \"Europe/Moscow\",\n            \"client_id\": \"ru.yandex.searchplugin/5.80 (Samsung Galaxy; Android 4.4)\",\n            \"interfaces\": {\"screen\": {}, \"account_linking\": {}},\n        },\n        \"request\": {\n            \"command\": command,\n            \"original_utterance\": command,\n            \"type\": \"SimpleUtterance\",\n            \"markup\": {\"dangerous_context\": True},\n            \"payload\": {},\n        },\n        \"session\": {\n            \"message_id\": 0,\n            \"session_id\": \"2eac4854-fce721f3-b845abba-20d60\",\n            \"skill_id\": \"3ad36498-f5rd-4079-a14b-788652932056\",\n            \"user_id\": \"47C73714B580ED2469056E71081159529FFC676A4E5B059D629A819E857DC2F8\",\n            \"user\": {\n                \"user_id\": \"6C91DA5198D1758C6A9F63A7C5CDDF09359F683B13A18A151FBF4C8B092BB0C2\",\n                \"access_token\": \"AgAAAAAB4vpbAAApoR1oaCd5yR6eiXSHqOGT8dT\",\n            },\n            \"application\": {\n                \"application_id\": \"47C73714B580ED2469056E71081159529FFC676A4E5B059D629A819E857DC2F8\"\n            },\n            \"new\": True,\n        },\n        \"version\": \"1.0\",\n    }", "\n\ndef make_test(req: dict | str, target_state: str):\n    if type(req) == str:\n        req = make_request(req)\n    resp = r.post(\"http://localhost:5555/\", json=req)\n    resp = resp.json()\n    print(resp)\n    assert resp[\"application_state\"] == target_state.lower()\n", "\n\ndef test_handler_main_func_short():\n    make_test(\"\u041f\u0440\u0438\u0432\u0435\u0442\", str(States.MAIN_MENU))\n\n    make_test(TIME_REQUEST, str(States.IN_CALCULATOR))\n\n    make_test(\"\u0414\u043e\u043b\u0433\u0438\u0439\", str(States.CALCULATED))\n\n    make_test(\"\u0414\u0430\", str(States.MAIN_MENU))", "\n    # make_test(\"\u041d\u043e\u0447\u043d\u043e\u0439 \u0441\u043e\u043d\", str(States.MAIN_MENU))\n\n\ndef test_handler_main_func_long():\n\n    make_test(\"\u042f \u0445\u043e\u0447\u0443 \u0441\u043f\u0430\u0442\u044c\", str(States.TIME_PROPOSED))\n\n    make_test(\"\u0414\u0430\", str(States.IN_CALCULATOR))\n\n    make_test(\"\u041a\u043e\u0440\u043e\u0442\u043a\u0438\u0439\", str(States.CALCULATED))\n\n    make_test(\"\u041c\u0435\u043d\u044e\", str(States.MAIN_MENU))", "\n\ndef test_handler_ask_tip():\n\n    make_test(\"\u041f\u043e\u0441\u043e\u0432\u0435\u0442\u0443\u0439\", str(States.ASKING_FOR_TIP))\n\n    make_test(\"\u041d\u043e\u0447\u043d\u043e\u0439 \u0441\u043e\u043d\", str(States.MAIN_MENU))\n\n\ndef test_handler_info():\n    make_test(\"\u0420\u0430\u0441\u0441\u043a\u0430\u0436\u0438 \u043e \u043d\u0430\u0432\u044b\u043a\u0435\", str(States.MAIN_MENU))", "\ndef test_handler_info():\n    make_test(\"\u0420\u0430\u0441\u0441\u043a\u0430\u0436\u0438 \u043e \u043d\u0430\u0432\u044b\u043a\u0435\", str(States.MAIN_MENU))\n"]}
{"filename": "tests/conftest.py", "chunked_list": ["import asyncio\n\nimport pytest\nimport pytest_asyncio\n\nfrom skill.db.models.sa_models import BaseModel\nfrom tests.sa_db_settings import engine\n\n\n@pytest.fixture(scope=\"session\")\ndef event_loop():\n    loop = asyncio.new_event_loop()\n    yield loop\n    loop.close()", "\n@pytest.fixture(scope=\"session\")\ndef event_loop():\n    loop = asyncio.new_event_loop()\n    yield loop\n    loop.close()\n\n\n@pytest_asyncio.fixture()\nasync def init_db() -> None:", "@pytest_asyncio.fixture()\nasync def init_db() -> None:\n    async with engine.begin() as conn:\n        await conn.run_sync(BaseModel.metadata.drop_all)\n        await conn.run_sync(BaseModel.metadata.create_all)\n"]}
{"filename": "tests/db/test_repo.py", "chunked_list": ["import random\nfrom datetime import UTC, datetime, time, timedelta, timezone\nfrom uuid import uuid4\n\nimport pytest\nimport pytest_asyncio\n\nfrom skill.db.repos.base_repo import BaseRepo\nfrom skill.db.repos.sa_repo import SARepo\nfrom skill.entities import Activity, Tip, TipsTopic, User", "from skill.db.repos.sa_repo import SARepo\nfrom skill.entities import Activity, Tip, TipsTopic, User\nfrom skill.exceptions import NoSuchEntityInDB\nfrom skill.utils import TextWithTTS\nfrom tests.sa_db_settings import sa_repo_config\n\nrepos_to_test = (SARepo(sa_repo_config),)\n\n\ndef generate_random_string_id() -> str:\n    return \"\".join(\n        (random.choice(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890\"))\n        for x in range(64)\n    )", "\ndef generate_random_string_id() -> str:\n    return \"\".join(\n        (random.choice(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890\"))\n        for x in range(64)\n    )\n\n\n# @pytest.mark.parametrize(\"repo\", repos_to_test)\n@pytest_asyncio.fixture()", "# @pytest.mark.parametrize(\"repo\", repos_to_test)\n@pytest_asyncio.fixture()\nasync def insert_values(repo: BaseRepo, init_db):\n    now = datetime.now(UTC)\n\n    user = User(\n        id=generate_random_string_id(),\n        streak=0,\n        last_skill_use=now,\n        heard_tips=[],", "        last_skill_use=now,\n        heard_tips=[],\n        last_wake_up_time=time(12, 5, 30),\n        join_date=now,\n        repo=repo,\n    )\n\n    new_user = User(\n        id=generate_random_string_id(),\n        streak=100,", "        id=generate_random_string_id(),\n        streak=100,\n        last_skill_use=None,\n        heard_tips=[],\n        last_wake_up_time=time(12, 5, 30),\n        join_date=now,\n        repo=repo,\n    )\n\n    await repo.insert_users([user, new_user])", "\n    await repo.insert_users([user, new_user])\n\n    topic = TipsTopic(\n        uuid4(),\n        TextWithTTS(\"\u0414\u043d\u0435\u0432\u043d\u044b\u0435 \u0441\u043e\u0432\u0435\u0442\u044b\", \"\u0414\u043d+\u0435\u0432\u043d\u044b\u0435 \u0441\u043e\u0432+\u0435\u0442\u044b\"),\n        TextWithTTS(\n            \"\u041d\u0443 \u0442\u0443\u043f\u043e \u043a\u0430\u043a\u0438\u0435-\u0442\u043e \u0434\u043d\u0435\u0432\u043d\u044b\u0435 \u0441\u043e\u0432\u0435\u0442\u044b, \u0430 \u043f\u043e\u0447\u0435\u043c\u0443 \u0431\u044b \u0438 \u043d\u0435\u0442\",\n            \"\u041d\u0443 \u0442+\u0443\u043f\u043e \u043a\u0430\u043a+\u0438\u0435-\u0442\u043e \u0434\u043d\u0435\u0432\u043d+\u044b\u0435 \u0441\u043e\u0432+\u0435\u0442\u044b, \u0430 \u043f\u043e\u0447\u0435\u043c+\u0443 \u0431\u044b \u0438 \u043d\u0435\u0442\",\n        ),", "            \"\u041d\u0443 \u0442+\u0443\u043f\u043e \u043a\u0430\u043a+\u0438\u0435-\u0442\u043e \u0434\u043d\u0435\u0432\u043d+\u044b\u0435 \u0441\u043e\u0432+\u0435\u0442\u044b, \u0430 \u043f\u043e\u0447\u0435\u043c+\u0443 \u0431\u044b \u0438 \u043d\u0435\u0442\",\n        ),\n        now,\n        repo,\n    )\n\n    new_topic = TipsTopic(\n        uuid4(),\n        TextWithTTS(\"Newtopic\", \"Newt+opic\"),\n        TextWithTTS(", "        TextWithTTS(\"Newtopic\", \"Newt+opic\"),\n        TextWithTTS(\n            \"Just a new topic, nothing much\",\n            \"Just a new t+opic, n+othing much\",\n        ),\n        datetime.now(),\n        repo,\n    )\n\n    await repo.insert_tips_topics([topic, new_topic])", "\n    await repo.insert_tips_topics([topic, new_topic])\n\n    tip = Tip(\n        uuid4(),\n        short_description=TextWithTTS(\n            \"\u041d\u0443 \u0442\u0443\u043f\u043e \u043a\u0430\u043a\u043e\u0439-\u0442\u043e \u0434\u043d\u0435\u0432\u043d\u043e\u0439 \u0441\u043e\u0432\u0435\u0442, \u0430 \u043f\u043e\u0447\u0435\u043c\u0443 \u0431\u044b \u0438 \u043d\u0435\u0442\",\n            \"\u041d\u0443 \u0442+\u0443\u043f\u043e \u043a\u0430\u043a+\u043e\u0439-\u0442\u043e \u0434\u043d\u0435\u0432\u043d+\u043e\u0439 \u0441\u043e\u0432+\u0435\u0442, \u0430 \u043f\u043e\u0447\u0435\u043c+\u0443 \u0431\u044b \u0438 \u043d\u0435\u0442\",\n        ),\n        tip_content=TextWithTTS(", "        ),\n        tip_content=TextWithTTS(\n            \"\u041d\u0443 \u0442\u0443\u043f\u043e \u043a\u0430\u043a\u043e\u0439-\u0442\u043e \u0434\u043d\u0435\u0432\u043d\u043e\u0439 \u0441\u043e\u0432\u0435\u0442, \u0430 \u043f\u043e\u0447\u0435\u043c\u0443 \u0431\u044b \u0438 \u043d\u0435\u0442\",\n            \"\u041d\u0443 \u0442+\u0443\u043f\u043e \u043a\u0430\u043a+\u043e\u0439-\u0442\u043e \u0434\u043d\u0435\u0432\u043d+\u043e\u0439 \u0441\u043e\u0432+\u0435\u0442, \u0430 \u043f\u043e\u0447\u0435\u043c+\u0443 \u0431\u044b \u0438 \u043d\u0435\u0442\",\n        ),\n        tips_topic=topic,\n        created_date=now,\n        repo=repo,\n    )\n", "    )\n\n    await repo.insert_tip(tip)\n\n    activity = Activity(\n        uuid4(),\n        TextWithTTS(\"\u0421\u0445\u043e\u0434\u0438\u0442\u044c \u043f\u043e\u0441\u0440\u0430\u0442\u044c\", \"\u0421\u0445\u043e\u0434\u0438\u0442\u044c \u0432 \u043e\u043a\u043d\u043e\"),\n        occupation_time=timedelta(hours=23, minutes=59, seconds=59),\n        created_date=now,\n        repo=repo,", "        created_date=now,\n        repo=repo,\n    )\n\n    await repo.insert_activity(activity)\n\n\n@pytest.mark.parametrize(\"repo\", repos_to_test)\n@pytest.mark.asyncio\nasync def test_users(repo: BaseRepo, init_db):", "@pytest.mark.asyncio\nasync def test_users(repo: BaseRepo, init_db):\n    now = datetime.now()\n\n    user = User(\n        id=generate_random_string_id(),\n        streak=0,\n        last_skill_use=now,\n        heard_tips=[],\n        last_wake_up_time=time(12, 5, 30),", "        heard_tips=[],\n        last_wake_up_time=time(12, 5, 30),\n        join_date=now,\n        repo=repo,\n    )\n\n    await repo.insert_user(user)\n\n    deleted_user = await repo.delete_user(user)\n", "    deleted_user = await repo.delete_user(user)\n\n    assert deleted_user == user\n\n    with pytest.raises(NoSuchEntityInDB):\n        await repo.delete_user(user)\n\n    with pytest.raises(NoSuchEntityInDB):\n        user.increase_streak()\n\n        await repo.update_user(user)", "\n    assert await repo.get_user_by_id(user._id) is None\n\n    new_user = User(\n        id=generate_random_string_id(),\n        streak=0,\n        last_skill_use=None,\n        heard_tips=[],\n        last_wake_up_time=time(12, 5, 30),\n        join_date=now,", "        last_wake_up_time=time(12, 5, 30),\n        join_date=now,\n        repo=repo,\n    )\n\n    await repo.insert_users([user, new_user])\n\n    users_list = await repo.get_users()\n\n    assert user in users_list and new_user in users_list", "\n    assert user in users_list and new_user in users_list\n\n    user_from_repo = await repo.get_user_by_id(user._id)\n\n    assert user == user_from_repo\n\n\n@pytest.mark.parametrize(\"repo\", repos_to_test)\n@pytest.mark.asyncio", "@pytest.mark.parametrize(\"repo\", repos_to_test)\n@pytest.mark.asyncio\nasync def test_activities(repo: BaseRepo, init_db):\n    now = datetime.now()\n\n    activity = Activity(\n        uuid4(),\n        TextWithTTS(\"\u0421\u0445\u043e\u0434\u0438\u0442\u044c \u043f\u043e\u0441\u0440\u0430\u0442\u044c\", \"\u0421\u0445\u043e\u0434\u0438\u0442\u044c \u0432 \u043e\u043a\u043d\u043e\"),\n        occupation_time=timedelta(hours=23, minutes=59, seconds=59),\n        created_date=now,", "        occupation_time=timedelta(hours=23, minutes=59, seconds=59),\n        created_date=now,\n        repo=repo,\n    )\n\n    await repo.insert_activity(activity)\n\n    deleted_activity = await repo.delete_activity(activity)\n\n    assert deleted_activity == activity", "\n    assert deleted_activity == activity\n\n    with pytest.raises(NoSuchEntityInDB):\n        await repo.delete_activity(activity)\n\n    with pytest.raises(NoSuchEntityInDB):\n        activity.description = TextWithTTS(\n            \"Huge description\", \"+Huge description\"\n        )\n        await repo.update_activity(activity)", "\n    assert await repo.get_activity_by_id(activity._id) is None\n\n    new_activity = Activity(\n        uuid4(),\n        TextWithTTS(\"\u0421\u0445\u043e\u0434\u0438\u0442\u044c \u0432 \u041b\u0443\u0432\u0440\", \"\u0421\u0445\u043e\u0434\u0438\u0442\u044c \u0432 \u0422\u0440\u0435\u0442\u044c\u044f\u043a\u043e\u0432\u043a\u0443\"),\n        occupation_time=timedelta(\n            hours=0, minutes=0, seconds=0, milliseconds=0, microseconds=1\n        ),\n        created_date=now,", "        ),\n        created_date=now,\n        repo=repo,\n    )\n\n    await repo.insert_activities([activity, new_activity])\n\n    activities_list = await repo.get_activities()\n\n    assert activity in activities_list and new_activity in activities_list", "\n    assert activity in activities_list and new_activity in activities_list\n\n    activity_from_repo = await repo.get_activity_by_id(activity._id)\n\n    assert activity == activity_from_repo\n\n\n@pytest.mark.parametrize(\"repo\", repos_to_test)\n@pytest.mark.asyncio", "@pytest.mark.parametrize(\"repo\", repos_to_test)\n@pytest.mark.asyncio\nasync def test_tips_topics(repo: BaseRepo, init_db):\n    now = datetime.now()\n\n    topic = TipsTopic(\n        uuid4(),\n        TextWithTTS(\"\u0414\u043d\u0435\u0432\u043d\u044b\u0435 \u0441\u043e\u0432\u0435\u0442\u044b\", \"\u0414\u043d+\u0435\u0432\u043d\u044b\u0435 \u0441\u043e\u0432+\u0435\u0442\u044b\"),\n        TextWithTTS(\n            \"\u041d\u0443 \u0442\u0443\u043f\u043e \u043a\u0430\u043a\u0438\u0435-\u0442\u043e \u0434\u043d\u0435\u0432\u043d\u044b\u0435 \u0441\u043e\u0432\u0435\u0442\u044b, \u0430 \u043f\u043e\u0447\u0435\u043c\u0443 \u0431\u044b \u0438 \u043d\u0435\u0442\",", "        TextWithTTS(\n            \"\u041d\u0443 \u0442\u0443\u043f\u043e \u043a\u0430\u043a\u0438\u0435-\u0442\u043e \u0434\u043d\u0435\u0432\u043d\u044b\u0435 \u0441\u043e\u0432\u0435\u0442\u044b, \u0430 \u043f\u043e\u0447\u0435\u043c\u0443 \u0431\u044b \u0438 \u043d\u0435\u0442\",\n            \"\u041d\u0443 \u0442+\u0443\u043f\u043e \u043a\u0430\u043a+\u0438\u0435-\u0442\u043e \u0434\u043d\u0435\u0432\u043d+\u044b\u0435 \u0441\u043e\u0432+\u0435\u0442\u044b, \u0430 \u043f\u043e\u0447\u0435\u043c+\u0443 \u0431\u044b \u0438 \u043d\u0435\u0442\",\n        ),\n        now,\n        repo,\n    )\n\n    await repo.insert_tips_topic(topic)\n", "    await repo.insert_tips_topic(topic)\n\n    deleted_tips_topic = await repo.delete_tips_topic(topic)\n\n    assert deleted_tips_topic == topic\n\n    with pytest.raises(NoSuchEntityInDB):\n        await repo.delete_tips_topic(topic)\n\n    with pytest.raises(NoSuchEntityInDB):\n        topic.topic_description = TextWithTTS(\n            \"Huge description\", \"+Huge description\"\n        )\n        await repo.update_tips_topic(topic)", "\n    with pytest.raises(NoSuchEntityInDB):\n        topic.topic_description = TextWithTTS(\n            \"Huge description\", \"+Huge description\"\n        )\n        await repo.update_tips_topic(topic)\n\n    assert await repo.get_tips_topic_by_id(topic._id) is None\n\n    new_topic = TipsTopic(", "\n    new_topic = TipsTopic(\n        uuid4(),\n        TextWithTTS(\"Newtopic\", \"Newt+opic\"),\n        TextWithTTS(\n            \"Just a new topic, nothing much\",\n            \"Just a new t+opic, n+othing much\",\n        ),\n        datetime.now(),\n        repo,", "        datetime.now(),\n        repo,\n    )\n\n    await repo.insert_tips_topics([topic, new_topic])\n\n    topics_list = await repo.get_tips_topics()\n\n    assert topic in topics_list and new_topic in topics_list\n", "    assert topic in topics_list and new_topic in topics_list\n\n    tips_topic_from_repo = await repo.get_tips_topic_by_id(topic._id)\n\n    assert tips_topic_from_repo == topic\n\n\n@pytest.mark.parametrize(\"repo\", repos_to_test)\n@pytest.mark.asyncio\nasync def test_tips(repo: BaseRepo, insert_values):", "@pytest.mark.asyncio\nasync def test_tips(repo: BaseRepo, insert_values):\n    now = datetime.now()\n\n    tip = Tip(\n        uuid4(),\n        short_description=TextWithTTS(\n            \"\u041d\u0443 \u0442\u0443\u043f\u043e \u043e\u0447\u0435\u0440\u0435\u0434\u043d\u043e\u0439 \u043a\u0430\u043a\u043e\u0439-\u0442\u043e \u0434\u043d\u0435\u0432\u043d\u043e\u0439 \u0441\u043e\u0432\u0435\u0442, \u0430 \u043f\u043e\u0447\u0435\u043c\u0443 \u0431\u044b \u0438 \u043d\u0435\u0442\",\n            \"\u041d\u0443 \u0442+\u0443\u043f\u043e \u043a\u0430\u043a+\u043e\u0439-\u0442\u043e \u0434\u043d\u0435\u0432\u043d+\u043e\u0439 \u0441\u043e\u0432+\u0435\u0442, \u0430 \u043f\u043e\u0447\u0435\u043c+\u0443 \u0431\u044b \u0438 \u043d\u0435\u0442\",\n        ),", "            \"\u041d\u0443 \u0442+\u0443\u043f\u043e \u043a\u0430\u043a+\u043e\u0439-\u0442\u043e \u0434\u043d\u0435\u0432\u043d+\u043e\u0439 \u0441\u043e\u0432+\u0435\u0442, \u0430 \u043f\u043e\u0447\u0435\u043c+\u0443 \u0431\u044b \u0438 \u043d\u0435\u0442\",\n        ),\n        tip_content=TextWithTTS(\n            \"\u041d\u0443 \u0442\u0443\u043f\u043e \u043e\u0447\u0435\u0440\u0435\u0434\u043d\u043e\u0439 \u043a\u0430\u043a\u043e\u0439-\u0442\u043e \u0434\u043d\u0435\u0432\u043d\u043e\u0439 \u0441\u043e\u0432\u0435\u0442, \u0430 \u043f\u043e\u0447\u0435\u043c\u0443 \u0431\u044b \u0438 \u043d\u0435\u0442\",\n            \"\u041d\u0443 \u0442+\u0443\u043f\u043e \u043a\u0430\u043a+\u043e\u0439-\u0442\u043e \u0434\u043d\u0435\u0432\u043d+\u043e\u0439 \u0441\u043e\u0432+\u0435\u0442, \u0430 \u043f\u043e\u0447\u0435\u043c+\u0443 \u0431\u044b \u0438 \u043d\u0435\u0442\",\n        ),\n        tips_topic=(await repo.get_tips_topics(1))[0],\n        created_date=now,\n        repo=repo,\n    )", "        repo=repo,\n    )\n\n    await repo.insert_tip(tip)\n\n    deleted_tip = await repo.delete_tip(tip)\n\n    assert deleted_tip == tip\n\n    with pytest.raises(NoSuchEntityInDB):\n        await repo.delete_tip(tip)", "\n    with pytest.raises(NoSuchEntityInDB):\n        await repo.delete_tip(tip)\n\n    with pytest.raises(NoSuchEntityInDB):\n        tip.short_description = TextWithTTS(\n            \"Huge description\", \"+Huge description\"\n        )\n        await repo.update_tip(tip)\n", "\n    assert await repo.get_tip_by_id(tip._id) is None\n\n    new_tip = Tip(\n        uuid4(),\n        TextWithTTS(\n            \"A new description for the tip\",\n            \"A new descr+iption for the tip\",\n        ),\n        TextWithTTS(\"Its content\", \"Its c+ontent\"),", "        ),\n        TextWithTTS(\"Its content\", \"Its c+ontent\"),\n        (await repo.get_tips_topics(1))[0],\n        datetime.now(),\n        repo,\n    )\n\n    await repo.insert_tips([tip, new_tip])\n\n    tips_list = await repo.get_tips()", "\n    tips_list = await repo.get_tips()\n\n    assert tip in tips_list and new_tip in tips_list\n\n    tip_from_repo = await repo.get_tip_by_id(tip._id)\n\n    assert tip_from_repo == tip\n\n", "\n\n@pytest.mark.parametrize(\"repo\", repos_to_test)\n@pytest.mark.asyncio\nasync def test_update(repo: BaseRepo, insert_values):\n    activity = (await repo.get_activities(1))[0]\n\n    activity.description = TextWithTTS(\n        activity.description.text, activity.description.tts + \" Updated now!\"\n    )", "        activity.description.text, activity.description.tts + \" Updated now!\"\n    )\n\n    activity.occupation_time = timedelta(\n        hours=0, minutes=0, seconds=0, microseconds=0, milliseconds=1\n    )\n\n    updated_activity = await repo.update_activity(activity)\n\n    assert (", "\n    assert (\n        activity._id == updated_activity._id\n        and activity.description == updated_activity.description\n        and activity.occupation_time == updated_activity.occupation_time\n    )\n\n    tips_topic = (await repo.get_tips_topics(1))[0]\n\n    tips_topic.name = TextWithTTS(\"Newname\", \"Newn+ame\")", "\n    tips_topic.name = TextWithTTS(\"Newname\", \"Newn+ame\")\n\n    tips_topic.topic_description = TextWithTTS(\n        \"Just a topic for testing\", \"Just a t+opic for t+esting\"\n    )\n\n    updated_tips_topic = await repo.update_tips_topic(tips_topic)\n\n    assert (", "\n    assert (\n        tips_topic._id == updated_tips_topic._id\n        and tips_topic.name == updated_tips_topic.name\n        and tips_topic.topic_description\n        == updated_tips_topic.topic_description\n    )\n\n    # TODO Add filtering\n    new_topic = list(", "    # TODO Add filtering\n    new_topic = list(\n        filter(lambda x: x._id != tips_topic._id, await repo.get_tips_topics())\n    )[0]\n\n    tip = (await repo.get_tips(1))[0]\n\n    tip.short_description = TextWithTTS(\n        \"Well, another description goes here\",\n        \"Well, an+other descr+iption goes h+ere\",", "        \"Well, another description goes here\",\n        \"Well, an+other descr+iption goes h+ere\",\n    )\n\n    tip.tip_content = TextWithTTS(\n        \"Well, that's the content I'd like to read\",\n        \"Well, that's the c+ontent I'd like to read\",\n    )\n\n    tip.tips_topic = new_topic", "\n    tip.tips_topic = new_topic\n\n    updated_tip = await repo.update_tip(tip)\n\n    assert (\n        tip.short_description == updated_tip.short_description\n        and tip.tip_content == updated_tip.tip_content\n        and tip.tips_topic == updated_tip.tips_topic\n    )", "        and tip.tips_topic == updated_tip.tips_topic\n    )\n\n    user = (await repo.get_users(1))[0].increase_streak()\n\n    new_tip = await repo.insert_tip(\n        Tip(\n            uuid4(),\n            TextWithTTS(\n                \"A new description for the tip\",", "            TextWithTTS(\n                \"A new description for the tip\",\n                \"A new descr+iption for the tip\",\n            ),\n            TextWithTTS(\"Its content\", \"Its c+ontent\"),\n            tips_topic,\n            datetime.now(),\n            repo,\n        )\n    )", "        )\n    )\n\n    user.add_heard_tip(new_tip)\n\n    user.last_skill_use = datetime.now()\n\n    user.last_wake_up_time = time(1, 50, 32)\n\n    updated_user = await repo.update_user(user)", "\n    updated_user = await repo.update_user(user)\n\n    assert user._streak == updated_user._streak\n\n    assert updated_user.last_skill_use == user.last_skill_use.astimezone(\n        timezone(timedelta(0))\n    )\n    assert updated_user.last_wake_up_time == user.last_wake_up_time\n    assert new_tip in user._heard_tips", "    assert updated_user.last_wake_up_time == user.last_wake_up_time\n    assert new_tip in user._heard_tips\n    assert new_tip in updated_user._heard_tips\n\n    user.drop_heard_tips()\n\n    updated_user = await repo.update_user(user)\n\n    assert updated_user._heard_tips == []\n", "    assert updated_user._heard_tips == []\n\n\n@pytest.mark.parametrize(\"repo\", repos_to_test)\n@pytest.mark.asyncio\nasync def test_getting(repo: BaseRepo, insert_values):\n    activities = await repo.get_activities()\n\n    assert await repo.get_activity_by_id(activities[0]._id) in activities\n", "    assert await repo.get_activity_by_id(activities[0]._id) in activities\n\n    tips = await repo.get_tips()\n\n    assert await repo.get_tip_by_id(tips[0]._id) in tips\n\n    tips_topics = await repo.get_tips_topics()\n\n    assert await repo.get_tips_topic_by_id(tips_topics[0]._id) in tips_topics\n", "    assert await repo.get_tips_topic_by_id(tips_topics[0]._id) in tips_topics\n\n    users = await repo.get_users()\n\n    assert await repo.get_user_by_id(users[0]._id) in users\n\n    tips_with_topic = await repo.get_topic_tips(tips_topics[0]._id)\n\n    assert tips_with_topic != []\n", "    assert tips_with_topic != []\n\n\n@pytest.mark.parametrize(\"repo\", repos_to_test)\n@pytest.mark.asyncio\nasync def test_users_stats(repo: BaseRepo, insert_values):\n    BIG_STREAK = 10000\n\n    all_users = await repo.get_users()\n", "    all_users = await repo.get_users()\n\n    all_user_counter = await repo.count_all_users()\n\n    assert len(all_users) == all_user_counter\n\n    assert await repo.count_users_with_streak(BIG_STREAK, condition=\">\") == 0\n    assert await repo.count_users_with_streak(BIG_STREAK, condition=\">=\") == 0\n\n    assert (", "\n    assert (\n        await repo.count_users_with_streak(BIG_STREAK, condition=\"<\")\n        == all_user_counter\n    )\n\n    assert (\n        await repo.count_users_with_streak(BIG_STREAK, condition=\"<=\")\n        == all_user_counter\n    )", "        == all_user_counter\n    )\n\n    assert await repo.count_users_with_streak(100, condition=\"<\") == 1\n\n    assert await repo.count_users_with_streak(100, condition=\"<=\") == 2\n\n    assert await repo.count_users_with_streak(100, condition=\">=\") == 1\n\n    assert await repo.count_users_with_streak(100, condition=\"==\") == 1", "\n    assert await repo.count_users_with_streak(100, condition=\"==\") == 1\n\n    assert await repo.count_users_with_streak(100, condition=\">\") == 0\n\n    assert await repo.count_users_with_streak(100, condition=\"==\") == 1\n\n\n@pytest.mark.parametrize(\"repo\", repos_to_test)\n@pytest.mark.asyncio", "@pytest.mark.parametrize(\"repo\", repos_to_test)\n@pytest.mark.asyncio\nasync def test_deleting_all_users(repo: BaseRepo, insert_values):\n    await repo.delete_all_users()\n\n    assert await repo.get_users() == []\n\n    await repo.delete_all_tips_topics()\n\n", "\n\n@pytest.mark.parametrize(\"repo\", repos_to_test)\n@pytest.mark.asyncio\nasync def test_deleting_all_activities(repo: BaseRepo, insert_values):\n    await repo.delete_all_activities()\n\n    assert await repo.get_activities() == []\n\n", "\n\n@pytest.mark.parametrize(\"repo\", repos_to_test)\n@pytest.mark.asyncio\nasync def test_deleting_all_tips_topics(repo: BaseRepo, insert_values):\n    await repo.delete_all_tips_topics()\n\n    assert await repo.get_tips_topics() == []\n\n    assert await repo.get_tips() == []", "\n    assert await repo.get_tips() == []\n\n\n@pytest.mark.parametrize(\"repo\", repos_to_test)\n@pytest.mark.asyncio\nasync def test_deleting_all_tips(repo: BaseRepo, insert_values):\n    await repo.delete_all_tips_topics()\n\n    topics_before_deleting = await repo.get_tips_topics()", "\n    topics_before_deleting = await repo.get_tips_topics()\n\n    assert await repo.get_tips() == []\n\n    assert await repo.get_tips_topics() == topics_before_deleting\n"]}
{"filename": "tests/db/__init__.py", "chunked_list": [""]}
{"filename": "tests/user_manager/test_user_manager.py", "chunked_list": ["import datetime\nimport random\nfrom uuid import uuid4\n\nimport pytest\nimport pytz\n\nfrom skill.db.repos.sa_repo import SARepo\nfrom skill.entities import Activity, TipsTopic, User\nfrom skill.messages.ru_messages import RUMessages", "from skill.entities import Activity, TipsTopic, User\nfrom skill.messages.ru_messages import RUMessages\nfrom skill.sleep_calculator import SleepMode\nfrom skill.user_manager import UserManager\nfrom skill.utils import TextWithTTS\nfrom tests.sa_db_settings import sa_repo_config\n\n\ndef generate_random_string_id() -> str:\n    return \"\".join(\n        (random.choice(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890\"))\n        for x in range(64)\n    )", "def generate_random_string_id() -> str:\n    return \"\".join(\n        (random.choice(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890\"))\n        for x in range(64)\n    )\n\n\n@pytest.mark.asyncio\nasync def test_me():\n    repo = SARepo(sa_repo_config)", "async def test_me():\n    repo = SARepo(sa_repo_config)\n    now = datetime.datetime.now(tz=pytz.utc)\n    tips_topic = TipsTopic(\n        id=uuid4(),\n        name=TextWithTTS(\"\u041d\u043e\u0447\u043d\u043e\u0439 \u0441\u043e\u043d\"),\n        topic_description=TextWithTTS(\"\u0432\u043e\u0442 \u043a\u0430\u043a\"),\n        created_date=now,\n        repo=repo,\n    )", "        repo=repo,\n    )\n\n    await repo.insert_tips_topic(tips_topic)\n\n    await tips_topic.add_tip(\n        short_description=TextWithTTS(\"\u0441\u0432\u044f\u0442\u0430\u044f \u0432\u043e\u0434\u0430\"),\n        tip_content=TextWithTTS(\"[1] \u043c\u043e\u0439\u0442\u0435 \u0440\u0443\u043a\u0438 \u0441\u0432\u044f\u0442\u043e\u0439 \u0432\u043e\u0434\u043e\u0439 \u043a\u043d\u0448\u043d\"),\n        tips_topic=tips_topic,\n        created_date=now,", "        tips_topic=tips_topic,\n        created_date=now,\n    )\n    await tips_topic.add_tip(\n        short_description=TextWithTTS(\"\u0437\u0430\u0447\u0435\u043c\"),\n        tip_content=TextWithTTS(\"[2] \u043d\u0435 \u043c\u043e\u0439\u0442\u0435 \u0440\u0443\u043a\u0438 \u0432\u043e\u043e\u0431\u0449\u0435 \u043d\u0438\u043a\u0430\u043a \u0432\u044b \u0447\u0442\u043e \u0434\u0443\u0440\u0430\u043a\"),\n        tips_topic=tips_topic,\n        created_date=now,\n    )\n    await tips_topic.add_tip(", "    )\n    await tips_topic.add_tip(\n        short_description=TextWithTTS(\"\u043e\u0431\u043b\u0438\u0436\u0438\"),\n        tip_content=TextWithTTS(\"[3] \u0432\u0441\u0451 \u0447\u0442\u043e \u043d\u0430\u043c \u043d\u0443\u0436\u043d\u043e \u0443 \u043d\u0430\u0441 \u0432 \u0440\u0443\u043a\u0430\u0445\"),\n        tips_topic=tips_topic,\n        created_date=now,\n    )\n\n    tips_topic = TipsTopic(\n        id=uuid4(),", "    tips_topic = TipsTopic(\n        id=uuid4(),\n        name=TextWithTTS(\"\u0414\u043d\u0435\u0432\u043d\u043e\u0439 \u0441\u043e\u043d\"),\n        topic_description=TextWithTTS(\"\u0432\u043e\u0442 \u043a\u0430\u043a\"),\n        created_date=now,\n        repo=repo,\n    )\n\n    await repo.insert_tips_topic(tips_topic)\n", "    await repo.insert_tips_topic(tips_topic)\n\n    await tips_topic.add_tip(\n        short_description=TextWithTTS(\"\u0441\u0432\u044f\u0442\u0430\u044f \u0432\u043e\u0434\u0430\"),\n        tip_content=TextWithTTS(\"[1] \u043c\u043e\u0439\u0442\u0435 \u0440\u0443\u043a\u0438 \u0441\u0432\u044f\u0442\u043e\u0439 \u0432\u043e\u0434\u043e\u0439 \u043a\u043d\u0448\u043d\"),\n        tips_topic=tips_topic,\n        created_date=now,\n    )\n    await tips_topic.add_tip(\n        short_description=TextWithTTS(\"\u0437\u0430\u0447\u0435\u043c\"),", "    await tips_topic.add_tip(\n        short_description=TextWithTTS(\"\u0437\u0430\u0447\u0435\u043c\"),\n        tip_content=TextWithTTS(\"[2] \u043d\u0435 \u043c\u043e\u0439\u0442\u0435 \u0440\u0443\u043a\u0438 \u0432\u043e\u043e\u0431\u0449\u0435 \u043d\u0438\u043a\u0430\u043a \u0432\u044b \u0447\u0442\u043e \u0434\u0443\u0440\u0430\u043a\"),\n        tips_topic=tips_topic,\n        created_date=now,\n    )\n    await tips_topic.add_tip(\n        short_description=TextWithTTS(\"\u043e\u0431\u043b\u0438\u0436\u0438\"),\n        tip_content=TextWithTTS(\"[3] \u0432\u0441\u0451 \u0447\u0442\u043e \u043d\u0430\u043c \u043d\u0443\u0436\u043d\u043e \u0443 \u043d\u0430\u0441 \u0432 \u0440\u0443\u043a\u0430\u0445\"),\n        tips_topic=tips_topic,", "        tip_content=TextWithTTS(\"[3] \u0432\u0441\u0451 \u0447\u0442\u043e \u043d\u0430\u043c \u043d\u0443\u0436\u043d\u043e \u0443 \u043d\u0430\u0441 \u0432 \u0440\u0443\u043a\u0430\u0445\"),\n        tips_topic=tips_topic,\n        created_date=now,\n    )\n\n\n@pytest.mark.asyncio\nasync def test_check_in():\n    repo = SARepo(sa_repo_config)\n    messages = RUMessages()", "    repo = SARepo(sa_repo_config)\n    messages = RUMessages()\n    now = datetime.datetime.now(tz=pytz.utc)\n\n    for user in await repo.get_users():\n        await repo.delete_user(user)\n\n    test_user_id = generate_random_string_id()\n\n    loser_user = User(", "\n    loser_user = User(\n        id=generate_random_string_id(),\n        streak=0,\n        last_skill_use=(now - datetime.timedelta(days=1)),\n        last_wake_up_time=datetime.time(hour=4, minute=20, tzinfo=pytz.utc),\n        heard_tips=[],\n        join_date=datetime.datetime(\n            year=2022, month=1, day=1, tzinfo=pytz.utc\n        ),", "            year=2022, month=1, day=1, tzinfo=pytz.utc\n        ),\n        repo=repo,\n    )\n\n    user = User(\n        id=test_user_id,\n        streak=4,\n        last_skill_use=(now - datetime.timedelta(days=1)),\n        last_wake_up_time=datetime.time(hour=4, minute=20, tzinfo=pytz.utc),", "        last_skill_use=(now - datetime.timedelta(days=1)),\n        last_wake_up_time=datetime.time(hour=4, minute=20, tzinfo=pytz.utc),\n        heard_tips=[],\n        join_date=datetime.datetime(\n            year=2022, month=1, day=1, tzinfo=pytz.utc\n        ),\n        repo=repo,\n    )\n    await repo.insert_users((user, loser_user))\n", "    await repo.insert_users((user, loser_user))\n\n    user_manager = await UserManager.new_manager(\n        test_user_id, repo, messages, create_user_if_not_found=False\n    )\n\n    assert user_manager is not None\n\n    message = await user_manager.check_in(now)\n", "    message = await user_manager.check_in(now)\n\n    assert \"5 \u0434\u0435\u043d\u044c \u043f\u043e\u0434\u0440\u044f\u0434\" in message.text  # type: ignore\n    assert \"50%\" in message.text  # type: ignore\n\n    user_upd = await repo.get_user_by_id(test_user_id)\n\n    assert bool(user_upd)\n\n    assert user_upd._streak == 5", "\n    assert user_upd._streak == 5\n    assert user_upd.last_skill_use == now\n\n    # Fast forward 5 days later\n    now = now + datetime.timedelta(days=5)\n    user_manager = await UserManager.new_manager(\n        test_user_id, repo, messages, create_user_if_not_found=False\n    )\n", "    )\n\n    assert bool(user_manager)\n\n    message = await user_manager.check_in(now)\n\n    assert \"\u0434\u0435\u043d\u044c \u043f\u043e\u0434\u0440\u044f\u0434\" not in message.text  # type: ignore\n\n    user_upd = await repo.get_user_by_id(test_user_id)\n", "    user_upd = await repo.get_user_by_id(test_user_id)\n\n    assert bool(user_upd)\n    assert user_upd._streak == 0\n    assert user_upd.last_skill_use == now\n\n\n@pytest.mark.asyncio\nasync def test_sleep_calc():\n    repo = SARepo(sa_repo_config)", "async def test_sleep_calc():\n    repo = SARepo(sa_repo_config)\n    messages = RUMessages()\n\n    test_user_id = generate_random_string_id()\n    user_manager = await UserManager.new_manager(test_user_id, repo, messages)\n    user_test = await repo.get_user_by_id(test_user_id)\n\n    assert bool(user_test) and bool(user_manager)\n", "    assert bool(user_test) and bool(user_manager)\n\n    assert user_manager.is_new_user()\n\n    message1 = await user_manager.get_ask_sleep_time_message()\n\n    assert \"\u043a\u0430\u043a \u0432 \u043f\u0440\u043e\u0448\u043b\u044b\u0439 \u0440\u0430\u0437\" not in message1.text_with_tts.text\n\n    now = datetime.datetime(\n        year=1420, month=1, day=1, hour=11, minute=0, second=0, tzinfo=pytz.utc", "    now = datetime.datetime(\n        year=1420, month=1, day=1, hour=11, minute=0, second=0, tzinfo=pytz.utc\n    )\n\n    wake_up_time = datetime.time(hour=14, minute=0, second=0, tzinfo=pytz.utc)\n\n    message2 = await user_manager.ask_sleep_time(\n        now, wake_up_time, SleepMode.LONG\n    )\n    print(message2.text_with_tts)", "    )\n    print(message2.text_with_tts)\n\n    assert not user_manager.is_new_user()\n\n    # assert \"02:00\" in message2.text_with_tts.text  # type: ignore\n\n    message2 = await user_manager.ask_sleep_time(\n        now, wake_up_time, SleepMode.SHORT\n    )", "        now, wake_up_time, SleepMode.SHORT\n    )\n    print(message2.text_with_tts)\n\n    message2 = await user_manager.ask_sleep_time(\n        now, wake_up_time, SleepMode.VERY_SHORT\n    )\n    print(message2.text_with_tts)\n\n    message2 = await user_manager.ask_sleep_time(", "\n    message2 = await user_manager.ask_sleep_time(\n        now, wake_up_time, SleepMode.MEDIUM\n    )\n    print(message2.text_with_tts)\n\n    assert \"12:30\" in message2.text_with_tts.text  # type: ignore\n\n    message3 = await user_manager.get_ask_sleep_time_message()\n    print(message3.text_with_tts)", "    message3 = await user_manager.get_ask_sleep_time_message()\n    print(message3.text_with_tts)\n\n    assert \"14:00\" in message3.text\n\n\n@pytest.mark.asyncio\nasync def test_activities_proposal():\n    repo = SARepo(sa_repo_config)\n    messages = RUMessages()", "    repo = SARepo(sa_repo_config)\n    messages = RUMessages()\n\n    test_user_id = generate_random_string_id()\n    user_manager = await UserManager.new_manager(test_user_id, repo, messages)\n    user_test = await repo.get_user_by_id(test_user_id)\n\n    assert bool(user_test) and bool(user_manager)\n\n    now = datetime.datetime(", "\n    now = datetime.datetime(\n        year=1420,\n        month=1,\n        day=1,\n        hour=11,\n        minute=00,\n        second=0,\n        tzinfo=pytz.utc,\n    )", "        tzinfo=pytz.utc,\n    )\n\n    for activity in await repo.get_activities():\n        await repo.delete_activity(activity)\n\n    activity1 = Activity(\n        id=uuid4(),\n        description=TextWithTTS(\"[FINDME_1] \u043c\u043e\u0440\u0433\u043d\u0443\u0442\u044c\"),\n        created_date=now,", "        description=TextWithTTS(\"[FINDME_1] \u043c\u043e\u0440\u0433\u043d\u0443\u0442\u044c\"),\n        created_date=now,\n        occupation_time=datetime.timedelta(hours=0, minutes=0, seconds=1),\n        repo=repo,\n    )\n    activity2 = Activity(\n        id=uuid4(),\n        description=TextWithTTS(\"[FINDME_2] \u0430\u043d\u0436\u0443\u043c\u0430\u043d\u044f\"),\n        created_date=now,\n        occupation_time=datetime.timedelta(hours=1, minutes=29, seconds=1),", "        created_date=now,\n        occupation_time=datetime.timedelta(hours=1, minutes=29, seconds=1),\n        repo=repo,\n    )\n    activity3 = Activity(\n        id=uuid4(),\n        description=TextWithTTS(\"[EXCLUDEME] \u0431\u0435\u0433\u0438\u0442\"),\n        created_date=now,\n        occupation_time=datetime.timedelta(hours=2, minutes=29, seconds=1),\n        repo=repo,", "        occupation_time=datetime.timedelta(hours=2, minutes=29, seconds=1),\n        repo=repo,\n    )\n\n    await repo.insert_activities((activity1, activity2, activity3))\n\n    wake_up_time = datetime.time(hour=14, minute=0, second=0, tzinfo=pytz.utc)\n\n    message1 = await user_manager.ask_sleep_time(\n        now, wake_up_time, SleepMode.SHORT", "    message1 = await user_manager.ask_sleep_time(\n        now, wake_up_time, SleepMode.SHORT\n    )\n\n    assert message1.text.count(\"[FINDME_1]\") == 1  # type: ignore\n    assert message1.text.count(\"[FINDME_2]\") == 1  # type: ignore\n    assert message1.text.count(\"[EXCLUDEME]\") == 0  # type: ignore\n\n    now = datetime.datetime(\n        year=1420,", "    now = datetime.datetime(\n        year=1420,\n        month=1,\n        day=1,\n        hour=12,\n        minute=30,\n        second=0,\n        tzinfo=pytz.utc,\n    )\n", "    )\n\n    message2 = await user_manager.ask_sleep_time(\n        now, wake_up_time, SleepMode.SHORT\n    )\n\n    assert message2.text.count(\"[FINDME_1]\") == 0  # type: ignore\n    assert message2.text.count(\"[FINDME_2]\") == 0  # type: ignore\n    assert message2.text.count(\"[EXCLUDEME]\") == 0  # type: ignore\n", "    assert message2.text.count(\"[EXCLUDEME]\") == 0  # type: ignore\n\n\n@pytest.mark.asyncio\nasync def test_tips():\n    repo = SARepo(sa_repo_config)\n    messages = RUMessages()\n\n    test_user_id = generate_random_string_id()\n    user_manager = await UserManager.new_manager(test_user_id, repo, messages)", "    test_user_id = generate_random_string_id()\n    user_manager = await UserManager.new_manager(test_user_id, repo, messages)\n    assert bool(user_manager)\n\n    for tip in await repo.get_tips():\n        await repo.delete_tip(tip)\n\n    now = datetime.datetime.now(pytz.utc)\n\n    tips_topic = TipsTopic(", "\n    tips_topic = TipsTopic(\n        id=uuid4(),\n        name=TextWithTTS(\"\u043a\u0430\u043a \u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u043e \u043c\u044b\u0442\u044c \u0440\u0443\u043a\u0438\"),\n        topic_description=TextWithTTS(\"\u0432\u043e\u0442 \u043a\u0430\u043a\"),\n        created_date=now,\n        repo=repo,\n    )\n\n    await repo.insert_tips_topic(tips_topic)", "\n    await repo.insert_tips_topic(tips_topic)\n\n    await tips_topic.add_tip(\n        short_description=TextWithTTS(\"\u0441\u0432\u044f\u0442\u0430\u044f \u0432\u043e\u0434\u0430\"),\n        tip_content=TextWithTTS(\"[1] \u043c\u043e\u0439\u0442\u0435 \u0440\u0443\u043a\u0438 \u0441\u0432\u044f\u0442\u043e\u0439 \u0432\u043e\u0434\u043e\u0439 \u043a\u043d\u0448\u043d\"),\n        tips_topic=tips_topic,\n        created_date=now,\n    )\n    await tips_topic.add_tip(", "    )\n    await tips_topic.add_tip(\n        short_description=TextWithTTS(\"\u0437\u0430\u0447\u0435\u043c\"),\n        tip_content=TextWithTTS(\"[2] \u043d\u0435 \u043c\u043e\u0439\u0442\u0435 \u0440\u0443\u043a\u0438 \u0432\u043e\u043e\u0431\u0449\u0435 \u043d\u0438\u043a\u0430\u043a \u0432\u044b \u0447\u0442\u043e \u0434\u0443\u0440\u0430\u043a\"),\n        tips_topic=tips_topic,\n        created_date=now,\n    )\n    await tips_topic.add_tip(\n        short_description=TextWithTTS(\"\u043e\u0431\u043b\u0438\u0436\u0438\"),\n        tip_content=TextWithTTS(\"[3] \u0432\u0441\u0451 \u0447\u0442\u043e \u043d\u0430\u043c \u043d\u0443\u0436\u043d\u043e \u0443 \u043d\u0430\u0441 \u0432 \u0440\u0443\u043a\u0430\u0445\"),", "        short_description=TextWithTTS(\"\u043e\u0431\u043b\u0438\u0436\u0438\"),\n        tip_content=TextWithTTS(\"[3] \u0432\u0441\u0451 \u0447\u0442\u043e \u043d\u0430\u043c \u043d\u0443\u0436\u043d\u043e \u0443 \u043d\u0430\u0441 \u0432 \u0440\u0443\u043a\u0430\u0445\"),\n        tips_topic=tips_topic,\n        created_date=now,\n    )\n\n    for _ in range(10):\n        user = await repo.update_user(user_manager.user.drop_heard_tips())\n        user_manager = UserManager(user, repo, messages)\n\n        message1 = await user_manager.ask_tip(tips_topic.name.text)\n        assert isinstance(message1, TextWithTTS)\n        exclude = False\n        for tag in (\"[1]\", \"[2]\", \"[3]\"):\n            if tag in message1.text:\n                exclude = tag\n                break\n        assert exclude\n        message2 = await user_manager.ask_tip(tips_topic.name.text)\n        assert isinstance(message2, TextWithTTS)\n        assert exclude not in message2.text", ""]}
{"filename": "tests/user_manager/__init__.py", "chunked_list": [""]}
{"filename": "skill/entities.py", "chunked_list": ["from __future__ import annotations\n\nfrom datetime import datetime, time, timedelta\nfrom uuid import UUID, uuid4\n\nfrom skill.db.repos.base_repo import BaseRepo\nfrom skill.utils import IdComparable, TextWithTTS\n\n\nclass User(IdComparable):\n    _id: str\n    _streak: int\n    last_skill_use: datetime | None\n    last_wake_up_time: time | None\n    _heard_tips: list[Tip]\n    _join_date: datetime\n\n    def __init__(\n        self,\n        id: str,\n        streak: int,\n        last_skill_use: datetime | None,\n        last_wake_up_time: time | None,\n        heard_tips: list[Tip],\n        join_date: datetime,\n        repo: BaseRepo,\n    ) -> None:\n        self._id = id\n        self._streak = streak\n        self.last_skill_use = last_skill_use\n        self.last_wake_up_time = last_wake_up_time\n        self._heard_tips = heard_tips\n        self._join_date = join_date\n        self.__repo = repo\n\n    def increase_streak(self) -> User:\n        self._streak += 1\n\n        return self\n\n    def drop_streak(self) -> User:\n        self._streak = 0\n\n        return self\n\n    def drop_heard_tips(self) -> User:\n        self._heard_tips = []\n\n        return self\n\n    def add_heard_tip(self, tip: Tip) -> User:\n        self._heard_tips.append(tip)\n\n        return self", "\nclass User(IdComparable):\n    _id: str\n    _streak: int\n    last_skill_use: datetime | None\n    last_wake_up_time: time | None\n    _heard_tips: list[Tip]\n    _join_date: datetime\n\n    def __init__(\n        self,\n        id: str,\n        streak: int,\n        last_skill_use: datetime | None,\n        last_wake_up_time: time | None,\n        heard_tips: list[Tip],\n        join_date: datetime,\n        repo: BaseRepo,\n    ) -> None:\n        self._id = id\n        self._streak = streak\n        self.last_skill_use = last_skill_use\n        self.last_wake_up_time = last_wake_up_time\n        self._heard_tips = heard_tips\n        self._join_date = join_date\n        self.__repo = repo\n\n    def increase_streak(self) -> User:\n        self._streak += 1\n\n        return self\n\n    def drop_streak(self) -> User:\n        self._streak = 0\n\n        return self\n\n    def drop_heard_tips(self) -> User:\n        self._heard_tips = []\n\n        return self\n\n    def add_heard_tip(self, tip: Tip) -> User:\n        self._heard_tips.append(tip)\n\n        return self", "\n\nclass Activity(IdComparable):\n    _id: UUID\n    _created_date: datetime\n    occupation_time: timedelta\n\n    # description: TextWithTTS\n    @property\n    def description(self) -> TextWithTTS:\n        return self.__description\n\n    @description.setter\n    def description(self, value: TextWithTTS):\n        if len(max(value.text, value.tts, key=len)) > 512:\n            raise ValueError(\n                \"Text and its speech format lengths should both be < 512\"\n            )\n\n        self.__description = value\n\n    def __init__(\n        self,\n        id: UUID,\n        description: TextWithTTS,\n        created_date: datetime,\n        occupation_time: timedelta,\n        repo: BaseRepo,\n    ) -> None:\n        self._id = id\n        self.description = description\n        self.occupation_time = occupation_time\n        self._created_date = created_date\n        self.__repo = repo", "\n\nclass Tip(IdComparable):\n    _id: UUID\n    _created_date: datetime\n    tips_topic: TipsTopic\n\n    # short_description: TextWithTTS\n    @property\n    def short_description(self) -> TextWithTTS:\n        return self.__short_description\n\n    @short_description.setter\n    def short_description(self, value: TextWithTTS):\n        if len(max(value.text, value.tts, key=len)) > 256:\n            raise ValueError(\n                \"Text and its speech format lengths should both be < 256\"\n            )\n\n        self.__short_description = value\n\n    # tip_content: TextWithTTS\n    @property\n    def tip_content(self) -> TextWithTTS:\n        return self.__tip_content\n\n    @tip_content.setter\n    def tip_content(self, value: TextWithTTS):\n        if len(max(value.text, value.tts, key=len)) > 1024:\n            raise ValueError(\n                \"Text and its speech format lengths should both be < 1024\"\n            )\n\n        self.__tip_content = value\n\n    def __init__(\n        self,\n        id: UUID,\n        short_description: TextWithTTS,\n        tip_content: TextWithTTS,\n        tips_topic: TipsTopic,\n        created_date: datetime,\n        repo: BaseRepo,\n    ) -> None:\n        self._id = id\n        self.short_description = short_description\n        self.tip_content = tip_content\n        self._created_date = created_date\n        self.tips_topic = tips_topic\n        self.__repo = repo", "\n\nclass TipsTopic(IdComparable):\n    _id: UUID\n    _created_date: datetime\n\n    # name: TextWithTTS\n    @property\n    def name(self) -> TextWithTTS:\n        return self.__name\n\n    @name.setter\n    def name(self, value: TextWithTTS):\n        if len(max(value.text, value.tts, key=len)) > 1024:\n            raise ValueError(\n                \"Text and its speech format lengths should both be < 1024\"\n            )\n\n        self.__name = value\n\n    # topic_description: TextWithTTS\n    @property\n    def topic_description(self) -> TextWithTTS:\n        return self.__topic_description\n\n    @topic_description.setter\n    def topic_description(self, value: TextWithTTS):\n        if len(max(value.text, value.tts, key=len)) > 1024:\n            raise ValueError(\n                \"Text and its speech format lengths should both be < 1024\"\n            )\n\n        self.__topic_description = value\n\n    def __init__(\n        self,\n        id: UUID,\n        name: TextWithTTS,\n        topic_description: TextWithTTS,\n        created_date: datetime,\n        repo: BaseRepo,\n    ) -> None:\n        self._id = id\n        self.name = name\n        self.topic_description = topic_description\n        self._created_date = created_date\n        self.__repo = repo\n\n    async def get_all_tips(self) -> list[Tip]:\n        return await self.__repo.get_topic_tips(self._id)\n\n    async def add_tip(\n        self,\n        short_description: TextWithTTS,\n        tip_content: TextWithTTS,\n        tips_topic: TipsTopic,\n        created_date: datetime,\n    ) -> Tip:\n        return await self.__repo.insert_tip(\n            Tip(\n                id=uuid4(),\n                short_description=short_description,\n                tip_content=tip_content,\n                tips_topic=tips_topic,\n                created_date=created_date,\n                repo=self.__repo,\n            )\n        )", ""]}
{"filename": "skill/handlers.py", "chunked_list": ["import datetime\nimport logging\n\nfrom aioalice import Dispatcher\nfrom aioalice.dispatcher import MemoryStorage\nfrom aioalice.types import Button\nfrom aioalice.types.alice_request import AliceRequest\nfrom pytz import timezone\n\nfrom skill.db.repos.sa_repo import SARepo", "\nfrom skill.db.repos.sa_repo import SARepo\nfrom skill.db.sa_db_settings import sa_repo_config\nfrom skill.messages.ru_messages import RUMessages\nfrom skill.sleep_calculator import SleepMode\nfrom skill.states import States\nfrom skill.user_manager import UserManager\n\nlogging.basicConfig(format=\"%(asctime)s %(name)-12s %(levelname)-8s %(message)s\")\n", "logging.basicConfig(format=\"%(asctime)s %(name)-12s %(levelname)-8s %(message)s\")\n\ndp = Dispatcher(storage=MemoryStorage())\n\nICO_ID = \"1540737/a491c8169a8b2597ba37\"\n\nTO_MENU_REPLICS = [\"\u0432\u044b\u0439\u0434\u0438\", \"\u043c\u0435\u043d\u044e\", \"\u041c\u0435\u043d\u044e\"]\n# Asking info\nGIVE_INFO_REPLICS = [\"\u0440\u0430\u0441\u0441\u043a\u0430\u0436\u0438 \u043e \u043d\u0430\u0432\u044b\u043a\u0435\", \"\u0440\u0430\u0441\u0441\u043a\u0430\u0436\u0438 \u043e \u0441\u0435\u0431\u0435\"]\n# What can you do", "GIVE_INFO_REPLICS = [\"\u0440\u0430\u0441\u0441\u043a\u0430\u0436\u0438 \u043e \u043d\u0430\u0432\u044b\u043a\u0435\", \"\u0440\u0430\u0441\u0441\u043a\u0430\u0436\u0438 \u043e \u0441\u0435\u0431\u0435\"]\n# What can you do\nGIVE_WHAT_CAN_YOU_DO_REPLICS = [\"\u0447\u0442\u043e \u0442\u044b \u0434\u0435\u043b\u0430\u0435\u0448\u044c\", \"\u0447\u0442\u043e \u0442\u044b \u0443\u043c\u0435\u0435\u0448\u044c\"]\n# Asking tip\nASK_FOR_TIP_REPLICS = [\n    \"\u043f\u043e\u0441\u043e\u0432\u0435\u0442\u0443\u0439\",\n    \"\u0441\u043e\u0432\u0435\u0442\",\n    \"\u043b\u0430\u0439\u0444\u0445\u0430\u043a\",\n    \"\u043f\u043e\u0434\u0441\u043a\u0430\u0436\u0438\",\n    \"\u043f\u043e\u0434\u0441\u043a\u0430\u0437\u043a\u0430\",", "    \"\u043f\u043e\u0434\u0441\u043a\u0430\u0436\u0438\",\n    \"\u043f\u043e\u0434\u0441\u043a\u0430\u0437\u043a\u0430\",\n]\n# Using main functionality (sleep time calculation)\nMAIN_FUNCTIONALITY_ENTER = [\"\u044f \u0445\u043e\u0447\u0443 \u0441\u043f\u0430\u0442\u044c\", \"\u0440\u0430\u0441\u0441\u0447\u0438\u0442\u0430\u0439 \u0441\u043e\u043d\"]\n# Using main functionality (sleep time calculation) (skip asking the time)\nMAIN_FUNCTIONALITY_ENTER_FAST = [\"\u0412\u043e \u0441\u043a\u043e\u043b\u044c\u043a\u043e\", \"\u041a\u043e\u0433\u0434\u0430\", \"\u0427\u0435\u0440\u0435\u0437 \u0441\u043a\u043e\u043b\u044c\u043a\u043e\"]\n# Choosing short sleep mode\nSHORT_SLEEP_KEYWORDS = RUMessages().SLEEP_MODES_NOMINATIVE[SleepMode.SHORT]\n# Choosing very short sleep mode", "SHORT_SLEEP_KEYWORDS = RUMessages().SLEEP_MODES_NOMINATIVE[SleepMode.SHORT]\n# Choosing very short sleep mode\nVERY_SHORT_SLEEP_KEYWORDS = RUMessages().SLEEP_MODES_NOMINATIVE[SleepMode.VERY_SHORT]\n# Choosing long sleep mode\nLONG_SLEEP_KEYWORDS = RUMessages().SLEEP_MODES_NOMINATIVE[SleepMode.LONG]\n# Choosing medium sleep mode\nMEDIUM_SLEEP_KEYWORDS = RUMessages().SLEEP_MODES_NOMINATIVE[SleepMode.MEDIUM]\n# Yes answer\nYES_REPLICS = [\"\u0434\u0430\", \"\u043a\u043e\u043d\u0435\u0447\u043d\u043e\", \"\u0435\u0441\u0442\u0435\u0441\u0442\u0432\u0435\u043d\u043d\u043e\", \"\u0445\u043e\u0447\u0443\"]\n# No answer", "YES_REPLICS = [\"\u0434\u0430\", \"\u043a\u043e\u043d\u0435\u0447\u043d\u043e\", \"\u0435\u0441\u0442\u0435\u0441\u0442\u0432\u0435\u043d\u043d\u043e\", \"\u0445\u043e\u0447\u0443\"]\n# No answer\nNO_REPLICS = [\"\u043d\u0435\u0442\", \"\u043e\u0442\u043a\u0430\u0437\u044b\u0432\u0430\u044e\u0441\u044c\", \"\u043d\u0435 \u0445\u043e\u0447\u0443\"]\n# Asking tip about night sleep\nWANT_NIGHT_TIP = [\"\u043d\u043e\u0447\u043d\u043e\u0439\"]\n# Asking tip abot day sleep\nWANT_DAY_TIP = [\"\u0434\u043d\u0435\u0432\u043d\u043e\u0439\"]\n# User aking help\nHELP_REPLICS = [\"\u043f\u043e\u043c\u043e\u0449\u044c\", \"\u043f\u043e\u043c\u043e\u0433\u0438\u0442\u0435\", \"\u0441\u043f\u0440\u0430\u0432\u043a\u0430\"]\n# User wants to stop skill", "HELP_REPLICS = [\"\u043f\u043e\u043c\u043e\u0449\u044c\", \"\u043f\u043e\u043c\u043e\u0433\u0438\u0442\u0435\", \"\u0441\u043f\u0440\u0430\u0432\u043a\u0430\"]\n# User wants to stop skill\nQUIT_SKILL_REPLICS = [\"\u0432\u044b\u0439\u0434\u0438\", \"\u0432\u044b\u0445\u043e\u0434\", \"\u0437\u0430\u043a\u0440\u043e\u0439 \u043d\u0430\u0432\u044b\u043a\"]\n\n\ndef get_buttons_with_text(texts: list[str] | None) -> list[Button] | None:\n    if texts is None:\n        return None\n    result = []\n    for text in texts:\n        button = Button(title=text)  # type: ignore\n        result.append(button)\n\n    return result", "\n\ndef contains_intent(req: AliceRequest, intent_name: str) -> bool:\n    return intent_name in req.request._raw_kwargs[\"nlu\"].get(\"intents\")\n\n\n@dp.request_handler(\n    state=States.SELECTING_TIME, func=lambda req: contains_intent(req, \"YANDEX.HELP\")\n)\nasync def time_form_info(alice_request: AliceRequest):", ")\nasync def time_form_info(alice_request: AliceRequest):\n    text_with_tts = RUMessages().get_sleep_form_message()\n    return alice_request.response(\n        response_or_text=text_with_tts.text,\n        tts=text_with_tts.tts,\n    )\n\n\n@dp.request_handler(", "\n@dp.request_handler(\n    state=States.all(),  # type: ignore\n    func=lambda req: contains_intent(req, \"QUIT_SKILL\"),\n)\nasync def quit_skill(alice_request: AliceRequest):\n    text_with_tts = RUMessages().get_quit_message()\n    return alice_request.response(\n        response_or_text=text_with_tts.text,\n        tts=text_with_tts.tts,", "        response_or_text=text_with_tts.text,\n        tts=text_with_tts.tts,\n        end_session=True,\n    )\n\n\ndp.register_request_handler(\n    quit_skill,\n    state=States.all(),\n    contains=QUIT_SKILL_REPLICS,", "    state=States.all(),\n    contains=QUIT_SKILL_REPLICS,\n)\n\n\n@dp.request_handler(\n    state=States.all(),  # type: ignore\n    func=lambda req: contains_intent(req, \"TO_MENU\"),\n    contains=TO_MENU_REPLICS,\n)", "    contains=TO_MENU_REPLICS,\n)\nasync def go_to_menu(alice_request: AliceRequest):\n    user_id = alice_request.session.user_id\n\n    text_with_tts = RUMessages().get_menu_welcome_message()\n\n    await dp.storage.set_state(user_id, States.MAIN_MENU)\n\n    return alice_request.response(", "\n    return alice_request.response(\n        response_or_text=text_with_tts.text,\n        tts=text_with_tts.tts,\n        buttons=get_buttons_with_text(RUMessages.MENU_BUTTONS_TEXT),\n    )\n\n\ndp.register_request_handler(\n    go_to_menu,", "dp.register_request_handler(\n    go_to_menu,\n    state=States.all(),\n    contains=TO_MENU_REPLICS,\n)\n\n\n@dp.request_handler(\n    state=States.all(),  # type: ignore\n    func=lambda req: contains_intent(req, \"YANDEX.HELP\"),", "    state=States.all(),  # type: ignore\n    func=lambda req: contains_intent(req, \"YANDEX.HELP\"),\n)\nasync def ask_help(alice_request: AliceRequest):\n    text_with_tts = RUMessages().get_help_message()\n    return alice_request.response(\n        response_or_text=text_with_tts.text,\n        tts=text_with_tts.tts,\n        buttons=get_buttons_with_text(RUMessages().HELP_BUTTONS_TEXT),\n    )", "        buttons=get_buttons_with_text(RUMessages().HELP_BUTTONS_TEXT),\n    )\n\n\ndp.register_request_handler(\n    ask_help,\n    state=States.all(),\n    contains=HELP_REPLICS,\n)\n", ")\n\n\n@dp.request_handler(\n    state=States.MAIN_MENU,\n    func=lambda req: contains_intent(req, \"GIVE_INFO\"),\n)  # type: ignore\nasync def give_info(alice_request: AliceRequest):\n    text_with_tts = RUMessages().get_info_message()\n    return alice_request.response_big_image(", "    text_with_tts = RUMessages().get_info_message()\n    return alice_request.response_big_image(\n        text=text_with_tts.text,\n        image_id=ICO_ID,\n        title=\"\u041e \u043d\u0430\u0432\u044b\u043a\u0435\",\n        description=text_with_tts.text,\n        tts=text_with_tts.tts,\n        buttons=get_buttons_with_text(RUMessages.MENU_BUTTONS_TEXT),\n    )\n", "    )\n\n\ndp.register_request_handler(\n    give_info,\n    state=States.MAIN_MENU,\n    contains=GIVE_INFO_REPLICS,\n)\n\n", "\n\n@dp.request_handler(\n    state=States.MAIN_MENU,\n    func=lambda req: contains_intent(req, \"GIVE_WHAT_CAN_YOU_DO\"),\n)  # type: ignore\nasync def give_functions(alice_request: AliceRequest):\n    text_with_tts = RUMessages().get_what_can_you_do_message()\n    return alice_request.response(\n        response_or_text=text_with_tts.text,", "    return alice_request.response(\n        response_or_text=text_with_tts.text,\n        tts=text_with_tts.tts,\n        buttons=get_buttons_with_text(RUMessages.MENU_BUTTONS_TEXT),\n    )\n\n\ndp.register_request_handler(\n    give_functions,\n    state=States.MAIN_MENU,", "    give_functions,\n    state=States.MAIN_MENU,\n    contains=GIVE_WHAT_CAN_YOU_DO_REPLICS,\n)\n\n\n@dp.request_handler(\n    state=States.ASKING_FOR_TIP,\n    func=lambda req: contains_intent(req, \"WANT_NIGHT_TIP\"),  # type: ignore\n)", "    func=lambda req: contains_intent(req, \"WANT_NIGHT_TIP\"),  # type: ignore\n)\nasync def send_night_tip(alice_request: AliceRequest):\n    user_id = alice_request.session.user_id\n    user_manager = await UserManager.new_manager(\n        user_id=user_id, repo=SARepo(sa_repo_config), messages=RUMessages()\n    )\n    response = await user_manager.ask_tip(\"\u043d\u043e\u0447\u043d\u043e\u0439\")\n    await dp.storage.set_state(user_id, response.state)\n    text_with_tts = response.text_with_tts", "    await dp.storage.set_state(user_id, response.state)\n    text_with_tts = response.text_with_tts\n    return alice_request.response(\n        response_or_text=text_with_tts.text,\n        tts=text_with_tts.tts,\n        buttons=get_buttons_with_text(response.buttons_text),\n    )\n\n\ndp.register_request_handler(", "\ndp.register_request_handler(\n    send_night_tip,\n    state=States.ASKING_FOR_TIP,\n    contains=WANT_NIGHT_TIP,\n)\n\n\n@dp.request_handler(\n    state=States.ASKING_FOR_TIP,", "@dp.request_handler(\n    state=States.ASKING_FOR_TIP,\n    func=lambda req: contains_intent(req, \"WANT_DAY_TIP\"),\n)  # type: ignore\nasync def send_day_tip(alice_request: AliceRequest):\n    user_id = alice_request.session.user_id\n    user_manager = await UserManager.new_manager(\n        user_id=user_id, repo=SARepo(sa_repo_config), messages=RUMessages()\n    )\n    response = await user_manager.ask_tip(\"\u0434\u043d\u0435\u0432\u043d\u043e\u0439\")", "    )\n    response = await user_manager.ask_tip(\"\u0434\u043d\u0435\u0432\u043d\u043e\u0439\")\n    await dp.storage.set_state(user_id, response.state)\n    text_with_tts = response.text_with_tts\n    return alice_request.response(\n        response_or_text=text_with_tts.text,\n        tts=text_with_tts.tts,\n        buttons=get_buttons_with_text(response.buttons_text),\n    )\n", "    )\n\n\ndp.register_request_handler(\n    send_day_tip,\n    state=States.ASKING_FOR_TIP,\n    contains=WANT_DAY_TIP,\n)\n\n", "\n\n@dp.request_handler(state=States.ASKING_FOR_TIP)  # type: ignore\nasync def reask_tip_topic(alice_request: AliceRequest):\n    text_with_tts = RUMessages().get_wrong_topic_message(\"\")\n    return alice_request.response(\n        response_or_text=text_with_tts.text, tts=text_with_tts.tts\n    )\n\n", "\n\n@dp.request_handler(\n    state=States.MAIN_MENU,\n    func=lambda req: contains_intent(req, \"ASK_FOR_TIP\"),  # type: ignore\n)\nasync def send_tip(alice_request: AliceRequest):\n    user_id = alice_request.session.user_id\n    text_with_tts = RUMessages().get_ask_tip_topic_message()\n    await dp.storage.set_state(user_id, States.ASKING_FOR_TIP)", "    text_with_tts = RUMessages().get_ask_tip_topic_message()\n    await dp.storage.set_state(user_id, States.ASKING_FOR_TIP)\n    return alice_request.response(\n        response_or_text=text_with_tts.text,\n        tts=text_with_tts.tts,\n        buttons=get_buttons_with_text(RUMessages.TIP_TOPIC_SELECTION_BUTTONS_TEXT),\n    )\n\n\ndp.register_request_handler(", "\ndp.register_request_handler(\n    send_tip,\n    state=States.MAIN_MENU,\n    contains=ASK_FOR_TIP_REPLICS,\n)\n\n\n@dp.request_handler(\n    state=States.IN_CALCULATOR,", "@dp.request_handler(\n    state=States.IN_CALCULATOR,\n    func=lambda req: contains_intent(req, \"VERY_SHORT_SLEEP\"),  # type: ignore,\n)\nasync def choose_very_short_duration(alice_request: AliceRequest):\n    user_id = alice_request.session.user_id\n    # time when user wants to get up, saved from previous dialogues\n    time = await dp.storage.get_data(user_id)\n    user_timezone = timezone(alice_request.meta.timezone)\n    hour = time[\"hour\"]", "    user_timezone = timezone(alice_request.meta.timezone)\n    hour = time[\"hour\"]\n    minute = time.get(\"minute\")\n    if minute is None:\n        minute = 0\n    wake_up_time = (\n        datetime.datetime.now(user_timezone)\n        .time()\n        .replace(hour=hour, minute=minute, tzinfo=user_timezone)\n    )", "        .replace(hour=hour, minute=minute, tzinfo=user_timezone)\n    )\n    user_manager = await UserManager.new_manager(\n        user_id=user_id, repo=SARepo(sa_repo_config), messages=RUMessages()\n    )\n    response = await user_manager.ask_sleep_time(\n        now=datetime.datetime.now(timezone(alice_request.meta.timezone)),\n        wake_up_time=wake_up_time,\n        mode=SleepMode.VERY_SHORT,\n    )", "        mode=SleepMode.VERY_SHORT,\n    )\n    text_with_tts = response.text_with_tts\n    await dp.storage.set_state(user_id, States.CALCULATED)\n    return alice_request.response(\n        response_or_text=text_with_tts.text,\n        tts=text_with_tts.tts,\n        buttons=get_buttons_with_text(response.buttons_text),\n    )\n", "    )\n\n\ndp.register_request_handler(\n    choose_very_short_duration,\n    state=States.IN_CALCULATOR,\n    contains=VERY_SHORT_SLEEP_KEYWORDS,\n)\n\n", "\n\n@dp.request_handler(\n    state=States.IN_CALCULATOR,\n    func=lambda req: contains_intent(req, \"SHORT_SLEEP\"),  # type: ignore\n)\nasync def choose_short_duration(alice_request: AliceRequest):\n    user_id = alice_request.session.user_id\n    # time when user wants to get up, saved from previous dialogues\n    time = await dp.storage.get_data(user_id)", "    # time when user wants to get up, saved from previous dialogues\n    time = await dp.storage.get_data(user_id)\n    user_timezone = timezone(alice_request.meta.timezone)\n    hour = time[\"hour\"]\n    minute = time.get(\"minute\")\n    if minute is None:\n        minute = 0\n    wake_up_time = (\n        datetime.datetime.now(user_timezone)\n        .time()", "        datetime.datetime.now(user_timezone)\n        .time()\n        .replace(hour=hour, minute=minute, tzinfo=user_timezone)\n    )\n    user_manager = await UserManager.new_manager(\n        user_id=user_id, repo=SARepo(sa_repo_config), messages=RUMessages()\n    )\n    response = await user_manager.ask_sleep_time(\n        now=datetime.datetime.now(timezone(alice_request.meta.timezone)),\n        wake_up_time=wake_up_time,", "        now=datetime.datetime.now(timezone(alice_request.meta.timezone)),\n        wake_up_time=wake_up_time,\n        mode=SleepMode.SHORT,\n    )\n    text_with_tts = response.text_with_tts\n    await dp.storage.set_state(user_id, States.CALCULATED)\n    return alice_request.response(\n        response_or_text=text_with_tts.text,\n        tts=text_with_tts.tts,\n        buttons=get_buttons_with_text(response.buttons_text),", "        tts=text_with_tts.tts,\n        buttons=get_buttons_with_text(response.buttons_text),\n    )\n\n\ndp.register_request_handler(\n    choose_short_duration,\n    state=States.IN_CALCULATOR,\n    contains=SHORT_SLEEP_KEYWORDS,\n)", "    contains=SHORT_SLEEP_KEYWORDS,\n)\n\n\n@dp.request_handler(\n    state=States.IN_CALCULATOR,\n    func=lambda req: contains_intent(req, \"MEDIUM_SLEEP\"),  # type: ignore\n)\nasync def choose_medium_duration(alice_request: AliceRequest):\n    user_id = alice_request.session.user_id", "async def choose_medium_duration(alice_request: AliceRequest):\n    user_id = alice_request.session.user_id\n    # time when user wants to get up, saved from previous dialogues\n    time = await dp.storage.get_data(user_id)\n    user_timezone = timezone(alice_request.meta.timezone)\n    hour = time[\"hour\"]\n    minute = time.get(\"minute\")\n    if minute is None:\n        minute = 0\n    wake_up_time = (", "    wake_up_time = (\n        datetime.datetime.now(user_timezone)\n        .time()\n        .replace(hour=hour, minute=minute, tzinfo=user_timezone)\n    )\n    user_manager = await UserManager.new_manager(\n        user_id=user_id, repo=SARepo(sa_repo_config), messages=RUMessages()\n    )\n    response = await user_manager.ask_sleep_time(\n        now=datetime.datetime.now(timezone(alice_request.meta.timezone)),", "    response = await user_manager.ask_sleep_time(\n        now=datetime.datetime.now(timezone(alice_request.meta.timezone)),\n        wake_up_time=wake_up_time,\n        mode=SleepMode.MEDIUM,\n    )\n    text_with_tts = response.text_with_tts\n    await dp.storage.set_state(user_id, States.CALCULATED)\n    return alice_request.response(\n        response_or_text=text_with_tts.text,\n        tts=text_with_tts.tts,", "        response_or_text=text_with_tts.text,\n        tts=text_with_tts.tts,\n        buttons=get_buttons_with_text(response.buttons_text),\n    )\n\n\ndp.register_request_handler(\n    choose_medium_duration,\n    state=States.IN_CALCULATOR,\n    contains=MEDIUM_SLEEP_KEYWORDS,", "    state=States.IN_CALCULATOR,\n    contains=MEDIUM_SLEEP_KEYWORDS,\n)\n\n\n@dp.request_handler(\n    state=States.IN_CALCULATOR,\n    func=lambda req: contains_intent(req, \"LONG_SLEEP\"),  # type: ignore)\n)\nasync def choose_long_duration(alice_request: AliceRequest):", ")\nasync def choose_long_duration(alice_request: AliceRequest):\n    user_id = alice_request.session.user_id\n    # time when user wants to get up, saved from previous dialogues\n    time = await dp.storage.get_data(user_id)\n    user_timezone = timezone(alice_request.meta.timezone)\n    hour = time[\"hour\"]\n    minute = time.get(\"minute\")\n    if minute is None:\n        minute = 0", "    if minute is None:\n        minute = 0\n    wake_up_time = (\n        datetime.datetime.now(user_timezone)\n        .time()\n        .replace(hour=hour, minute=minute, tzinfo=user_timezone)\n    )\n    user_manager = await UserManager.new_manager(\n        user_id=user_id, repo=SARepo(sa_repo_config), messages=RUMessages()\n    )", "        user_id=user_id, repo=SARepo(sa_repo_config), messages=RUMessages()\n    )\n    response = await user_manager.ask_sleep_time(\n        now=datetime.datetime.now(timezone(alice_request.meta.timezone)),\n        wake_up_time=wake_up_time,\n        mode=SleepMode.LONG,\n    )\n    text_with_tts = response.text_with_tts\n    await dp.storage.set_state(user_id, States.CALCULATED)\n    return alice_request.response(", "    await dp.storage.set_state(user_id, States.CALCULATED)\n    return alice_request.response(\n        response_or_text=text_with_tts.text,\n        tts=text_with_tts.tts,\n        buttons=get_buttons_with_text(response.buttons_text),\n    )\n\n\ndp.register_request_handler(\n    choose_long_duration,", "dp.register_request_handler(\n    choose_long_duration,\n    state=States.IN_CALCULATOR,\n    contains=LONG_SLEEP_KEYWORDS,\n)\n\n\n@dp.request_handler(state=States.SELECTING_TIME)  # type: ignore\nasync def enter_calculator(alice_request: AliceRequest):\n    user_id = alice_request.session.user_id\n    if \"nlu\" not in alice_request.request._raw_kwargs.keys():\n        response = RUMessages().get_ask_wake_up_time_message().text\n        return response", "async def enter_calculator(alice_request: AliceRequest):\n    user_id = alice_request.session.user_id\n    if \"nlu\" not in alice_request.request._raw_kwargs.keys():\n        response = RUMessages().get_ask_wake_up_time_message().text\n        return response\n    try:\n        value = alice_request.request._raw_kwargs[\"nlu\"][\"intents\"][\"sleep_calc\"][\n            \"slots\"\n        ][\"time\"][\"value\"]\n    except KeyError:\n        text_with_tts = RUMessages().get_wrong_time_message()\n        return alice_request.response(\n            response_or_text=text_with_tts.text,\n            tts=text_with_tts.tts,\n        )", "    if \"hour\" not in value.keys():\n        text_with_tts = RUMessages().get_wrong_time_message()\n        return alice_request.response(\n            response_or_text=text_with_tts.text,\n            tts=text_with_tts.tts,\n        )\n    if \"minute\" not in value.keys():\n        value[\"minutes\"] = 0\n    # save time sleep time\n    await dp.storage.set_data(user_id, value)", "    # save time sleep time\n    await dp.storage.set_data(user_id, value)\n    text_with_tts = RUMessages().get_ask_sleep_mode_message()\n    await dp.storage.set_state(user_id, States.IN_CALCULATOR)\n    return alice_request.response(\n        response_or_text=text_with_tts.text,\n        tts=text_with_tts.tts,\n        buttons=get_buttons_with_text(RUMessages.SLEEP_MODE_SELECTION_BUTTONS_TEXT),\n    )\n", "    )\n\n\ndp.register_request_handler(\n    enter_calculator,\n    state=States.MAIN_MENU,  # type: ignore\n    func=lambda req: contains_intent(req, \"MAIN_FUNCTIONALITY_ENTER_FAST\"),\n)\n\ndp.register_request_handler(", "\ndp.register_request_handler(\n    enter_calculator,\n    state=States.MAIN_MENU,  # type: ignore\n    contains=MAIN_FUNCTIONALITY_ENTER_FAST,\n)\n\n\n@dp.request_handler(\n    state=States.MAIN_MENU,", "@dp.request_handler(\n    state=States.MAIN_MENU,\n    func=lambda req: contains_intent(req, \"MAIN_FUNCTIONALITY_ENTER\"),  # type: ignore\n)\nasync def enter_calculator_with_no_time(alice_request: AliceRequest):\n    user_id = alice_request.session.user_id\n    user_manager = await UserManager.new_manager(\n        user_id=user_id, repo=SARepo(sa_repo_config), messages=RUMessages()\n    )\n    response = await user_manager.get_ask_sleep_time_message()", "    )\n    response = await user_manager.get_ask_sleep_time_message()\n    await dp.storage.set_state(user_id, response.state)\n    text_with_tts = response.text_with_tts\n    return alice_request.response(\n        response_or_text=text_with_tts.text,\n        tts=text_with_tts.tts,\n        buttons=get_buttons_with_text(response.buttons_text),\n    )\n", "    )\n\n\ndp.register_request_handler(\n    enter_calculator_with_no_time,\n    state=States.MAIN_MENU,  # type: ignore\n    contains=MAIN_FUNCTIONALITY_ENTER,\n)\n\n", "\n\n@dp.request_handler(\n    state=States.TIME_PROPOSED,\n    func=lambda req: contains_intent(req, \"YANDEX.REJECT\"),\n)  # type: ignore\nasync def enter_calculator_new_time(alice_request: AliceRequest):\n    user_id = alice_request.session.user_id\n    text_with_tts = RUMessages().get_ask_wake_up_time_message()\n    await dp.storage.set_state(user_id, States.SELECTING_TIME)", "    text_with_tts = RUMessages().get_ask_wake_up_time_message()\n    await dp.storage.set_state(user_id, States.SELECTING_TIME)\n    return alice_request.response(\n        response_or_text=text_with_tts.text, tts=text_with_tts.tts\n    )\n\n\ndp.register_request_handler(\n    enter_calculator_new_time,\n    state=States.TIME_PROPOSED,", "    enter_calculator_new_time,\n    state=States.TIME_PROPOSED,\n    contains=NO_REPLICS,\n)\n\n\n@dp.request_handler(\n    state=States.TIME_PROPOSED,\n    func=lambda req: contains_intent(req, \"YANDEX.CONFIRM\"),\n)  # type: ignore", "    func=lambda req: contains_intent(req, \"YANDEX.CONFIRM\"),\n)  # type: ignore\nasync def enter_calculator_proposed_time(alice_request: AliceRequest):\n    user_id = alice_request.session.user_id\n    user_manager = await UserManager.new_manager(\n        user_id=user_id, repo=SARepo(sa_repo_config), messages=RUMessages()\n    )\n    time = {\n        \"hour\": user_manager.user.last_wake_up_time.hour,\n        \"minute\": user_manager.user.last_wake_up_time.minute,", "        \"hour\": user_manager.user.last_wake_up_time.hour,\n        \"minute\": user_manager.user.last_wake_up_time.minute,\n    }\n    await dp.storage.set_data(user_id, time)\n    text_with_tts = RUMessages().get_ask_sleep_mode_message()\n    await dp.storage.set_state(user_id, States.IN_CALCULATOR)\n    return alice_request.response(\n        response_or_text=text_with_tts.text,\n        tts=text_with_tts.tts,\n        buttons=get_buttons_with_text(RUMessages.SLEEP_MODE_SELECTION_BUTTONS_TEXT),", "        tts=text_with_tts.tts,\n        buttons=get_buttons_with_text(RUMessages.SLEEP_MODE_SELECTION_BUTTONS_TEXT),\n    )\n\n\ndp.register_request_handler(\n    enter_calculator_proposed_time,\n    state=States.TIME_PROPOSED,\n    contains=YES_REPLICS,\n)", "    contains=YES_REPLICS,\n)\n\n\n@dp.request_handler(\n    state=States.CALCULATED,\n    func=lambda req: contains_intent(req, \"YANDEX.REJECT\"),\n)  # type: ignore\nasync def end_skill(alice_request: AliceRequest):\n    user_id = alice_request.session.user_id", "async def end_skill(alice_request: AliceRequest):\n    user_id = alice_request.session.user_id\n    await dp.storage.set_state(user_id, States.MAIN_MENU)\n    text_with_tts = RUMessages().get_good_night_message()\n    return alice_request.response(\n        response_or_text=text_with_tts.text,\n        tts=text_with_tts.tts,\n        buttons=get_buttons_with_text(RUMessages().MENU_BUTTONS_TEXT),\n    )\n", "    )\n\n\ndp.register_request_handler(\n    end_skill,\n    state=States.CALCULATED,\n    contains=NO_REPLICS,\n)\n\n", "\n\ndp.register_request_handler(\n    send_night_tip,\n    state=States.CALCULATED,  # type: ignore\n    func=lambda req: contains_intent(req, \"YANDEX.CONFIRM\"),\n    contains=YES_REPLICS,\n)\n\ndp.register_request_handler(", "\ndp.register_request_handler(\n    send_night_tip,\n    state=States.CALCULATED,\n    contains=YES_REPLICS,\n)\n\n\n@dp.request_handler()\nasync def welcome_user(alice_request: AliceRequest):", "@dp.request_handler()\nasync def welcome_user(alice_request: AliceRequest):\n    user_id = alice_request.session.user_id\n    user_manager = await UserManager.new_manager(\n        user_id=user_id, repo=SARepo(sa_repo_config), messages=RUMessages()\n    )\n    response = await user_manager.check_in(\n        now=datetime.datetime.now(timezone(alice_request.meta.timezone))\n    )\n    text_with_tts = response.text_with_tts", "    )\n    text_with_tts = response.text_with_tts\n    await dp.storage.set_state(user_id, States.MAIN_MENU)\n    return alice_request.response(\n        response_or_text=text_with_tts.text,\n        tts=text_with_tts.tts,\n        buttons=get_buttons_with_text(response.buttons_text),\n    )\n\n", "\n\n@dp.errors_handler()\nasync def error_handler(alice_request: AliceRequest, e):\n    user_id = alice_request.session.user_id\n    state = await dp.storage.get_state(user_id)\n    logging.error(str(state), exc_info=e)\n    text_with_tts = RUMessages().get_generic_error_message()\n\n    await dp.storage.set_state(user_id, States.MAIN_MENU)", "\n    await dp.storage.set_state(user_id, States.MAIN_MENU)\n\n    return alice_request.response(\n        response_or_text=text_with_tts.text,\n        tts=text_with_tts.tts,\n        buttons=get_buttons_with_text(RUMessages().MENU_BUTTONS_TEXT),\n    )\n\n", "\n\n@dp.request_handler(\n    state=States.all(),  # type: ignore\n)\nasync def universal_handler(alice_request: AliceRequest):\n    user_id = alice_request.session.user_id\n\n    text_with_tts = RUMessages().get_menu_welcome_message()\n", "    text_with_tts = RUMessages().get_menu_welcome_message()\n\n    await dp.storage.set_state(user_id, States.MAIN_MENU)\n\n    return alice_request.response(\n        response_or_text=text_with_tts.text,\n        tts=text_with_tts.tts,\n        buttons=get_buttons_with_text(RUMessages.MENU_BUTTONS_TEXT),\n    )\n", "    )\n"]}
{"filename": "skill/__main__.py", "chunked_list": ["from aioalice import get_new_configured_app\nfrom aiohttp import web\n\nfrom skill.config import WEBAPP_HOST, WEBAPP_PORT, WEBHOOK_URL_PATH\nfrom skill.handlers import dp\n\nif __name__ == \"__main__\":\n    app = get_new_configured_app(dispatcher=dp, path=WEBHOOK_URL_PATH)\n    web.run_app(app, host=WEBAPP_HOST, port=int(WEBAPP_PORT), loop=dp.loop)\n", ""]}
{"filename": "skill/config.py", "chunked_list": ["import os\n\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nWEBHOOK_URL_PATH = os.getenv(\"WEBHOOK_URL_PATH\") or \"/\"\n\nWEBAPP_HOST = os.getenv(\"WEBAPP_HOST\") or \"localhost\"\n", "WEBAPP_HOST = os.getenv(\"WEBAPP_HOST\") or \"localhost\"\n\nWEBAPP_PORT = os.getenv(\"WEBAPP_PORT\") or 5555\n"]}
{"filename": "skill/states.py", "chunked_list": ["from aioalice.utils.helper import Helper, HelperMode, Item\n\n\nclass States(Helper):\n    mode = HelperMode.snake_case\n\n    MAIN_MENU = Item()  # = main_menu\n    ASKING_FOR_TIP = Item()  # = asking_for_tip\n    SELECTING_TIME = Item()  # = selecting_time\n    IN_CALCULATOR = Item()  # = in_calculator\n    CALCULATED = Item()  # = calculated\n    TIME_PROPOSED = Item()  # = time_proposed", ""]}
{"filename": "skill/user_manager.py", "chunked_list": ["from __future__ import annotations\n\nimport datetime\nimport logging\nimport random\nfrom dataclasses import dataclass\nimport pytz\nfrom skill.entities import User\nfrom skill.exceptions import InvalidInputError\nfrom skill.db.repos.base_repo import BaseRepo", "from skill.exceptions import InvalidInputError\nfrom skill.db.repos.base_repo import BaseRepo\nfrom skill.messages.base_messages import BaseMessages\nfrom skill.sleep_calculator import SleepCalculator, SleepMode\nfrom skill.states import States\nfrom skill.utils import TextWithTTS\n\n\n@dataclass\nclass SkillResponse:\n    text_with_tts: TextWithTTS\n    state: str | None\n    buttons_text: list[str] | None", "@dataclass\nclass SkillResponse:\n    text_with_tts: TextWithTTS\n    state: str | None\n    buttons_text: list[str] | None\n\n\nclass UserManager:\n    user: User\n    repo: BaseRepo\n    messages: BaseMessages\n\n    def __init__(\n        self, user: User, repo: BaseRepo, messages: BaseMessages\n    ) -> None:\n        self.user = user\n        self.repo = repo\n        self.messages = messages\n\n    @classmethod\n    async def new_manager(\n        cls,\n        user_id: str,\n        repo: BaseRepo,\n        messages: BaseMessages,\n        create_user_if_not_found: bool = True,\n    ) -> UserManager:\n        \"\"\"Sets up UserManager with given user repo and messages.\n        If user_id is not found in the DB and create_user_if_not_found\n        is True, creates a new user.\n\n        Args:\n            user_id (str): User's ID as it is stored in the DB\n            and returned in the API request\n\n            repo (BaseRepo): the repo which this user manager should\n            work with\n\n            messages (BaseMessages): the messages generator used\n            by reply constructors\n\n            create_user_if_not_found (bool, optional): whether to create\n            a new user if user_id is not found in the DB or not.\n            Defaults to True.\n\n        Returns:\n            UserManager | None: proper UserManager instance. If\n            the user_id is not found in the DB and create_user_if_not_found\n            is False, returns None\n        \"\"\"\n\n        user = await repo.get_user_by_id(user_id)\n        # if not user and not create_user_if_not_found:\n        #    return None\n\n        if not user:\n            user = User(\n                id=user_id,\n                streak=0,\n                last_skill_use=None,\n                last_wake_up_time=None,\n                heard_tips=[],\n                join_date=datetime.datetime.now(),\n                repo=repo,\n            )\n            await repo.insert_user(user)\n\n        inst = cls(user=user, repo=repo, messages=messages)\n        return inst\n\n    def is_new_user(self):\n        return not (self.user.last_skill_use or self.user.last_wake_up_time)\n\n    async def count_scoreboard(self, percentages: bool = True) -> int:\n        \"\"\"Calculates user's position in the global streak scoreboard,\n        starting from the lowest.\n\n        Args:\n            percentages (bool, optional): whether to convert the score\n            to percentage rate of users with lower streak or not\n            Defaults to True\n\n        Returns:\n            int: user's scoreboard position or the percentage rate\n        \"\"\"\n\n        streak = self.user._streak\n\n        score = await self.repo.count_users_with_streak(streak, \"<=\") - 1\n        if not percentages:\n            return score\n        total = await self.repo.count_all_users()\n        percentage = round(score / total * 100)\n        return percentage\n\n    async def check_in(\n        self, now: datetime.datetime | None = None\n    ) -> SkillResponse:\n        \"\"\"Perform all needed processes when a user starts the skill.\n        To be more precise, this method:\n        - Drops user's streak if the streak is lost\n        - Increases user's streak if the streak is kept\n        - Updates user's last_skill_use field\n\n        Returns a properly constructed greeting message to welcome the user\n\n        Args:\n            now (datetime.datetime | None, optional): the time at which the\n            user started the skill. If not set, the method will recieve the\n            time with datetime.datetime.now() (using UTC). However, leaving\n            this parameter to None is deprecated due to the possible difference\n            between the request time and the execution time.\n            Defaults to None.\n\n        Returns:\n            TextWithTTS: a greeting message.\n        \"\"\"\n        if now is None:\n            now = datetime.datetime.now(pytz.utc)\n\n        new_user = True\n\n        if self.user.last_skill_use is not None:\n            new_user = False\n            yesterday = (now - datetime.timedelta(days=1)).date()\n            today = now.date()\n            if self.user.last_skill_use.date() == yesterday:\n                # Last skill use was yesterday, streak increased\n                self.user.increase_streak()\n            elif self.user.last_skill_use.date() != today:\n                # Last skill use was neither yesterday, nor today,\n                # thus streak dropped.\n                self.user.drop_streak()\n\n        self.user.last_skill_use = now\n\n        await self.repo.update_user(self.user)\n\n        if new_user:\n            return SkillResponse(\n                self.messages.get_start_message_intro(now),\n                States.MAIN_MENU,\n                self.messages.MENU_BUTTONS_TEXT,\n            )\n        streak = self.user._streak\n\n        scoreboard = await self.count_scoreboard(percentages=True)\n        return SkillResponse(\n            self.messages.get_start_message_comeback(\n                time=now, streak=streak, scoreboard=scoreboard\n            ),\n            States.MAIN_MENU,\n            self.messages.MENU_BUTTONS_TEXT,\n        )\n\n    async def ask_tip(self, topic_name: str) -> SkillResponse:\n        \"\"\"Chooses a tip on given topic that has most likely never\n        been heard before by the user and tracks the heard tips buffer.\n\n        Args:\n            topic_name (str): the name of the topic of tips\n\n        Returns:\n            TextWithTTS: a tip message in a form of TextWithTTS or\n            error message if the topic is not found.\n        \"\"\"\n\n        topic = await self.repo.get_tips_topic_by_name(topic_name)\n        if topic is None:\n            return SkillResponse(\n                self.messages.get_wrong_topic_message(topic_name),\n                States.ASKING_FOR_TIP,\n                self.messages.TIP_TOPIC_SELECTION_BUTTONS_TEXT,\n            )\n        tips = await self.repo.get_topic_tips(topic_id=topic._id)\n        heard_tips = self.user._heard_tips\n\n        if len(heard_tips) == len(tips):\n            self.user.drop_heard_tips()\n            heard_tips = []\n\n        if heard_tips:\n            tips = list(filter(lambda x: x not in heard_tips, tips))\n\n        tip = random.choice(tips)\n\n        self.user.add_heard_tip(tip)\n\n        await self.repo.update_user(self.user)\n        return SkillResponse(\n            self.messages.get_tip_message(tip),\n            States.MAIN_MENU,\n            self.messages.MENU_BUTTONS_TEXT,\n        )\n\n    async def get_ask_sleep_time_message(self) -> SkillResponse:\n        \"\"\"Get the proper message to ask a user the time at which\n        they want to wake up. The selected message depends on whether\n        the user have already used the sleep calculator or not.\"\"\"\n\n        last_wake_up_time = self.user.last_wake_up_time\n        if last_wake_up_time is not None:\n            return SkillResponse(\n                self.messages.get_propose_yesterday_wake_up_time_message(\n                    last_wake_up_time\n                ),\n                States.TIME_PROPOSED,\n                self.messages.SLEEP_TIME_PROPOSAL_BUTTONS_TEXT,\n            )\n        return SkillResponse(\n            self.messages.get_ask_wake_up_time_message(),\n            States.SELECTING_TIME,\n            None,\n        )\n\n    async def ask_sleep_time(\n        self,\n        now: datetime.datetime,\n        wake_up_time: datetime.time,\n        mode: SleepMode,\n        remember_time: bool = True,\n    ) -> SkillResponse:\n        \"\"\"Calculate user's sleep time. Constructs a response message,\n        in which it proposes the user a number of activities for the rest of\n        the evening, and returns the message.\n\n        Args:\n            now (datetime.datetime): the timestamp at which the user asks to\n            calculate their sleep time.\n\n            wake_up_time (datetime.time): the time at which the user\n            wants to wake up\n\n            mode (SleepMode.LONG | SleepMode.SHORT): user's selected\n            sleep mode\n\n            remember_time (bool, optional): whether to record the time at which\n            the user wants to wake up to the DB or not\n            Defaults to True.\n\n        Returns:\n            TextWithTTS: a response message in a form of TextWithTTS.\n        \"\"\"\n        logging.debug(wake_up_time)\n        if remember_time:\n            self.user.last_wake_up_time = wake_up_time\n            await self.repo.update_user(self.user)\n\n        try:\n            wake_up_datetime = datetime.datetime.combine(\n                date=now.date(),\n                time=wake_up_time,\n                tzinfo=now.tzinfo,\n            )\n            sleep_calc_result = SleepCalculator.calc(\n                wake_up_time=wake_up_datetime, origin_time=now, mode=mode\n            )\n        except InvalidInputError:\n            wake_up_datetime = datetime.datetime.combine(\n                date=(now + datetime.timedelta(days=1)).date(),\n                time=wake_up_time,\n                tzinfo=now.tzinfo,\n            )\n            sleep_calc_result = SleepCalculator.calc(\n                wake_up_time=wake_up_datetime, origin_time=now, mode=mode\n            )\n        all_activities = await self.repo.get_activities()\n        activities = SleepCalculator.activities_compilation(\n            now, sleep_calc_result.bed_time, all_activities\n        )\n        return SkillResponse(\n            self.messages.get_sleep_calc_time_message(\n                sleep_calc_result, activities\n            ),\n            States.CALCULATED,\n            self.messages.POST_SLEEP_CALCULATION_BUTTONS_TEXT,\n        )", ""]}
{"filename": "skill/__init__.py", "chunked_list": [""]}
{"filename": "skill/utils.py", "chunked_list": ["from __future__ import annotations\n\nimport datetime\nimport enum\nimport itertools\nimport random\nfrom typing import Any, Callable, Iterable, List, Union\n\n\nclass Daytime(enum.Enum):\n    DAY = enum.auto()\n    NIGHT = enum.auto()\n    EVENING = enum.auto()\n    MORNING = enum.auto()\n\n    @classmethod\n    def from_time(cls, time: Union[datetime.datetime, datetime.time]):\n        \"\"\"Identify Daytime from time\n\n        Args:\n            time (datetime.datetime | datetime.time): time to recieve daytime.\n\n        Returns:\n            Daytime: one of daytime options according to the given time\n        \"\"\"\n\n        if isinstance(time, datetime.datetime):\n            time = time.time()\n        morning = datetime.time(5, 0, 0)\n        day = datetime.time(12, 0, 0)\n        evening = datetime.time(16, 0, 0)\n        night = datetime.time(23, 0, 0)\n\n        if time < morning:\n            return cls.NIGHT\n        if time < day:\n            return cls.MORNING\n        if time < evening:\n            return cls.DAY\n        if time < night:\n            return cls.EVENING\n        return cls.NIGHT", "\nclass Daytime(enum.Enum):\n    DAY = enum.auto()\n    NIGHT = enum.auto()\n    EVENING = enum.auto()\n    MORNING = enum.auto()\n\n    @classmethod\n    def from_time(cls, time: Union[datetime.datetime, datetime.time]):\n        \"\"\"Identify Daytime from time\n\n        Args:\n            time (datetime.datetime | datetime.time): time to recieve daytime.\n\n        Returns:\n            Daytime: one of daytime options according to the given time\n        \"\"\"\n\n        if isinstance(time, datetime.datetime):\n            time = time.time()\n        morning = datetime.time(5, 0, 0)\n        day = datetime.time(12, 0, 0)\n        evening = datetime.time(16, 0, 0)\n        night = datetime.time(23, 0, 0)\n\n        if time < morning:\n            return cls.NIGHT\n        if time < day:\n            return cls.MORNING\n        if time < evening:\n            return cls.DAY\n        if time < night:\n            return cls.EVENING\n        return cls.NIGHT", "\n\nclass TextWithTTS:\n    text: str\n    tts: str\n\n    def __init__(self, text: str, tts: str | None = None):\n        self.text = text\n        if tts is None:\n            self.tts = text\n            return\n\n        self.tts = tts\n\n    def __eq__(self, __o: object) -> bool:\n        return (\n            isinstance(__o, TextWithTTS)\n            and self.text == __o.text\n            and self.tts == __o.tts\n        )\n\n    def __str__(self) -> str:\n        return \"Text:\\n\" f\"{self.text}\" \"\\n\" \"TTS:\\n\" f\"{self.tts}\"\n\n    def __add__(self, __o: Union[str, TextWithTTS]) -> TextWithTTS:\n        if isinstance(__o, TextWithTTS):\n            return TextWithTTS(self.text + __o.text, self.tts + __o.tts)\n        return TextWithTTS(self.text + __o, self.tts + __o)\n\n    def __radd__(self, __o: Union[str, TextWithTTS]) -> TextWithTTS:\n        if isinstance(__o, TextWithTTS):\n            return TextWithTTS(__o.text + self.text, __o.tts + self.tts)\n        return TextWithTTS(__o + self.text, __o + self.text)\n\n    def __iadd__(self, __o: Union[str, TextWithTTS]) -> TextWithTTS:\n        return self + __o\n\n    def transform(self, func: Callable[[str], str]) -> TextWithTTS:\n        \"\"\"Apply a function to both text and speech parts\n        of TextWithTTS.\n\n        Args:\n            func (Callable[[str], str]): the function to transform\n            TextWithTTS strings\n\n        Returns:\n            TextWithTTS: new TextWithTTS with transformed strings\n        \"\"\"\n\n        return TextWithTTS(func(self.text), func(self.tts))\n\n    def join(self, __iterable: Iterable[TextWithTTS], /):\n        \"\"\"Likewise str.join, concatenate any number of TextWithTTS.\n\n        Calls str.join for text parts and tts parts of TextWithTTS objects\n        seperately and returns a new instance with concatenated text and tts.\n        TextWithTTS whose method is being called inserts its text and tts\n        between the concatenated objects.\n\n        Args:\n            Iterable[TextWithTTS]: sequence of TextWithTTS to concatenate\n\n        Returns:\n            TextWithTTS: the concatenation result\n        \"\"\"\n\n        i1, i2 = itertools.tee(__iterable, 2)\n        return TextWithTTS(\n            self.text.join(map(lambda x: x.text, i1)),\n            self.tts.join(map(lambda x: x.tts, i2)),\n        )", "\n\nclass IdComparable:\n    _id: Any\n\n    def __eq__(self, __o: object) -> bool:\n        return isinstance(__o, self.__class__) and self._id == __o._id\n\n\ndef gentle_capitalize(text: str):\n    \"\"\"Make the first character of a string have upper case\n    leaving the rest of the string as is, unlike built-in\n    str.capitalize method, which makes all other characters\n    have lower case.\n\n    Args:\n        text (str): the string to convert\n\n    Returns:\n        str: gently capitalized string\n    \"\"\"\n\n    if not text:\n        return text\n    return text[0].upper() + text[1:]", "\ndef gentle_capitalize(text: str):\n    \"\"\"Make the first character of a string have upper case\n    leaving the rest of the string as is, unlike built-in\n    str.capitalize method, which makes all other characters\n    have lower case.\n\n    Args:\n        text (str): the string to convert\n\n    Returns:\n        str: gently capitalized string\n    \"\"\"\n\n    if not text:\n        return text\n    return text[0].upper() + text[1:]", "\n\ndef construct_random_message(*parts: List[TextWithTTS], insert_spaces=True):\n    \"\"\"Construct randomly generated message from a sequence\n    of message parts options.\n\n    Args:\n        *parts (List[TextWithTTS]): message parts options\n        in the sequential order.\n\n        insert_spaces (bool, optional): whether to insert\n        spaces inbetween the parts of a message or not.\n        Degaults to True.\n\n    Returns:\n        TextWithTTS: constructed message\n    \"\"\"\n\n    if insert_spaces:\n        delimiter = TextWithTTS(\" \")\n    else:\n        delimiter = TextWithTTS(\"\")\n\n    return delimiter.join(map(lambda x: random.choice(x), parts))", ""]}
{"filename": "skill/sleep_calculator.py", "chunked_list": ["import datetime\nfrom skill.exceptions import InvalidInputError\nfrom typing import Iterable, Callable\nfrom skill.entities import Activity\nfrom dataclasses import dataclass\nimport enum\n\n\nclass SleepModeDoesntFitError(Exception):\n    pass", "class SleepModeDoesntFitError(Exception):\n    pass\n\n\nclass SleepMode(enum.Enum):\n    LONG = enum.auto()\n    MEDIUM = enum.auto()\n    SHORT = enum.auto()\n    VERY_SHORT = enum.auto()\n", "\n\n@dataclass\nclass SleepCalculation:\n    bed_time: datetime.datetime = datetime.datetime(datetime.MINYEAR, 1, 1)\n    selected_mode: SleepMode = SleepMode.LONG\n    sleep_time: datetime.timedelta = datetime.timedelta(0)\n    changed_mode: SleepMode | None = None\n\n\nclass SleepCalculator:\n    _mode_calculators: dict[\n        SleepMode,\n        Callable[[datetime.datetime, datetime.datetime], datetime.timedelta],\n    ] = {}\n    _mode_priorities: dict[\n        SleepMode,\n        int,\n    ] = {}\n\n    @classmethod\n    def mode_calculator(cls, mode: SleepMode, priority: int):\n        def wrapper(func):\n            cls._mode_calculators[mode] = func\n            cls._mode_priorities[mode] = priority\n\n            def newfunc(*args, **kwargs):\n                sleep_time = func(*args, **kwargs)\n                if sleep_time <= datetime.timedelta(0):\n                    raise SleepModeDoesntFitError(\n                        \"Can't fit any sleep time in given range\"\n                    )\n                return sleep_time\n\n            return newfunc\n\n        return wrapper\n\n    @staticmethod\n    def activities_compilation(\n        time_a: datetime.datetime,\n        time_b: datetime.datetime,\n        all_activities: Iterable[Activity],\n        limit: int = 2,\n    ) -> list[Activity]:\n        \"\"\"Returns a number of activities that can be done between time_a and\n        time_b.\n\n        Args:\n            time_a (datetime.datetime): opening time boundary\n\n            time_b (datetime.datetime): closing time boundary\n\n            all_activities (Iterable[Activity]): the pool of all activities\n\n            limit (int, optional): the number of best fitting activities to\n            return.\n            Defaults to 2\n\n        Returns:\n            list[Activity]: the list of best fitting activities compilation\n        \"\"\"\n\n        if time_b < time_a:\n            raise InvalidInputError(\n                \"Closing boundary cannot be less than the opening boundary\"\n            )\n        delta = time_b - time_a\n        sorted_activities = sorted(\n            filter(lambda x: x.occupation_time < delta, all_activities),\n            reverse=True,\n            key=lambda x: x.occupation_time,\n        )\n        return sorted_activities[:limit]\n\n    @classmethod\n    def calc(\n        cls,\n        wake_up_time: datetime.datetime,\n        origin_time: datetime.datetime | None = None,\n        mode: SleepMode = SleepMode.LONG,\n    ) -> SleepCalculation:\n        \"\"\"Returns the time at which the user need to go to bed according to\n        their request.\n\n        Args:\n            wake_up_time (datetime.datetime): user's desired time to wake up\n\n            origin_time (datetime.datetime | None, optional): the starting\n            point in time from which the calculations are made.\n            If None is passed, origin_time sets to datetime.datetime.now()\n            result with the timezone of wake_up_time.\n            Defaults to None\n\n            mode (SleepMode.LONG | SleepMode.MEDIUM | SleepMode.SHORT |\n            SleepMode.VERY_SHORT): user's desired sleep mode\n\n        Returns:\n            datetime.datetime: the time at which the user should go to bed\n        \"\"\"\n\n        if origin_time is None:\n            origin_time = datetime.datetime.now(wake_up_time.tzinfo)\n\n        if wake_up_time <= origin_time:\n            raise InvalidInputError(\n                \"Wake up time is earlier than current time\"\n            )\n\n        result = SleepCalculation()\n        result.selected_mode = mode\n\n        # Initial calculation for the desired mode\n        try:\n            result.sleep_time = cls._mode_calculators[mode](\n                origin_time, wake_up_time\n            )\n        except SleepModeDoesntFitError:\n            # Impossible mode: choose the mode that fits the most\n            sleep_time = None\n            for mode, calculator in sorted(\n                cls._mode_calculators.items(),\n                key=lambda pair: cls._mode_priorities[pair[0]],\n            ):\n                try:\n                    sleep_time = calculator(origin_time, wake_up_time)\n                except SleepModeDoesntFitError:\n                    continue\n                result.sleep_time = sleep_time\n                result.changed_mode = mode\n                break\n\n            if sleep_time is None:\n                raise InvalidInputError(\n                    \"It is not possible to sleep in given period of time\"\n                )\n        result.bed_time = wake_up_time - result.sleep_time\n        return result", "\n\nclass SleepCalculator:\n    _mode_calculators: dict[\n        SleepMode,\n        Callable[[datetime.datetime, datetime.datetime], datetime.timedelta],\n    ] = {}\n    _mode_priorities: dict[\n        SleepMode,\n        int,\n    ] = {}\n\n    @classmethod\n    def mode_calculator(cls, mode: SleepMode, priority: int):\n        def wrapper(func):\n            cls._mode_calculators[mode] = func\n            cls._mode_priorities[mode] = priority\n\n            def newfunc(*args, **kwargs):\n                sleep_time = func(*args, **kwargs)\n                if sleep_time <= datetime.timedelta(0):\n                    raise SleepModeDoesntFitError(\n                        \"Can't fit any sleep time in given range\"\n                    )\n                return sleep_time\n\n            return newfunc\n\n        return wrapper\n\n    @staticmethod\n    def activities_compilation(\n        time_a: datetime.datetime,\n        time_b: datetime.datetime,\n        all_activities: Iterable[Activity],\n        limit: int = 2,\n    ) -> list[Activity]:\n        \"\"\"Returns a number of activities that can be done between time_a and\n        time_b.\n\n        Args:\n            time_a (datetime.datetime): opening time boundary\n\n            time_b (datetime.datetime): closing time boundary\n\n            all_activities (Iterable[Activity]): the pool of all activities\n\n            limit (int, optional): the number of best fitting activities to\n            return.\n            Defaults to 2\n\n        Returns:\n            list[Activity]: the list of best fitting activities compilation\n        \"\"\"\n\n        if time_b < time_a:\n            raise InvalidInputError(\n                \"Closing boundary cannot be less than the opening boundary\"\n            )\n        delta = time_b - time_a\n        sorted_activities = sorted(\n            filter(lambda x: x.occupation_time < delta, all_activities),\n            reverse=True,\n            key=lambda x: x.occupation_time,\n        )\n        return sorted_activities[:limit]\n\n    @classmethod\n    def calc(\n        cls,\n        wake_up_time: datetime.datetime,\n        origin_time: datetime.datetime | None = None,\n        mode: SleepMode = SleepMode.LONG,\n    ) -> SleepCalculation:\n        \"\"\"Returns the time at which the user need to go to bed according to\n        their request.\n\n        Args:\n            wake_up_time (datetime.datetime): user's desired time to wake up\n\n            origin_time (datetime.datetime | None, optional): the starting\n            point in time from which the calculations are made.\n            If None is passed, origin_time sets to datetime.datetime.now()\n            result with the timezone of wake_up_time.\n            Defaults to None\n\n            mode (SleepMode.LONG | SleepMode.MEDIUM | SleepMode.SHORT |\n            SleepMode.VERY_SHORT): user's desired sleep mode\n\n        Returns:\n            datetime.datetime: the time at which the user should go to bed\n        \"\"\"\n\n        if origin_time is None:\n            origin_time = datetime.datetime.now(wake_up_time.tzinfo)\n\n        if wake_up_time <= origin_time:\n            raise InvalidInputError(\n                \"Wake up time is earlier than current time\"\n            )\n\n        result = SleepCalculation()\n        result.selected_mode = mode\n\n        # Initial calculation for the desired mode\n        try:\n            result.sleep_time = cls._mode_calculators[mode](\n                origin_time, wake_up_time\n            )\n        except SleepModeDoesntFitError:\n            # Impossible mode: choose the mode that fits the most\n            sleep_time = None\n            for mode, calculator in sorted(\n                cls._mode_calculators.items(),\n                key=lambda pair: cls._mode_priorities[pair[0]],\n            ):\n                try:\n                    sleep_time = calculator(origin_time, wake_up_time)\n                except SleepModeDoesntFitError:\n                    continue\n                result.sleep_time = sleep_time\n                result.changed_mode = mode\n                break\n\n            if sleep_time is None:\n                raise InvalidInputError(\n                    \"It is not possible to sleep in given period of time\"\n                )\n        result.bed_time = wake_up_time - result.sleep_time\n        return result", "\n\n# TODO: Change the sleep mode definition architecture to be more\n# developer-friendly (Issue #87)\n\n\n@SleepCalculator.mode_calculator(SleepMode.VERY_SHORT, 3)\ndef vert_short_sleep(\n    origin_time: datetime.datetime, wake_up_time: datetime.datetime\n) -> datetime.timedelta:\n    origin_time += datetime.timedelta(minutes=10)\n    step = datetime.timedelta(hours=0, minutes=15)\n    delta = wake_up_time - origin_time\n    delta_steps = delta // step\n    sleep_time = delta_steps * step\n    min_time = datetime.timedelta(hours=0, minutes=15)\n    max_time = datetime.timedelta(hours=3, minutes=0)\n    sleep_time = min(sleep_time, max_time)\n    if sleep_time < min_time:\n        raise SleepModeDoesntFitError\n    return sleep_time", "\n\n@SleepCalculator.mode_calculator(SleepMode.SHORT, 2)\ndef short_sleep(\n    origin_time: datetime.datetime, wake_up_time: datetime.datetime\n) -> datetime.timedelta:\n    origin_time += datetime.timedelta(minutes=20)\n    step = datetime.timedelta(hours=1, minutes=00)\n    delta = wake_up_time - origin_time\n    delta_steps = delta // step\n    sleep_time = delta_steps * step\n    min_time = datetime.timedelta(hours=3, minutes=0)\n    max_time = datetime.timedelta(hours=6, minutes=0)\n    sleep_time = min(sleep_time, max_time)\n    if sleep_time < min_time:\n        raise SleepModeDoesntFitError\n    return sleep_time", "\n\n@SleepCalculator.mode_calculator(SleepMode.MEDIUM, 1)\ndef medium_sleep(\n    origin_time: datetime.datetime, wake_up_time: datetime.datetime\n) -> datetime.timedelta:\n    origin_time += datetime.timedelta(minutes=20)\n    step = datetime.timedelta(hours=1, minutes=30)\n    delta = wake_up_time - origin_time\n    delta_steps = delta // step\n    sleep_time = delta_steps * step\n    min_time = datetime.timedelta(hours=6, minutes=0)\n    max_time = datetime.timedelta(hours=9, minutes=0)\n    sleep_time = min(sleep_time, max_time)\n    if sleep_time < min_time:\n        raise SleepModeDoesntFitError\n    return sleep_time", "\n\n@SleepCalculator.mode_calculator(SleepMode.LONG, 0)\ndef long_sleep(\n    origin_time: datetime.datetime, wake_up_time: datetime.datetime\n) -> datetime.timedelta:\n    origin_time += datetime.timedelta(minutes=20)\n    step = datetime.timedelta(hours=1, minutes=30)\n    delta = wake_up_time - origin_time\n    delta_steps = delta // step\n    sleep_time = delta_steps * step\n    min_time = datetime.timedelta(hours=9, minutes=0)\n    max_time = datetime.timedelta(hours=12, minutes=0)\n    sleep_time = min(sleep_time, max_time)\n    if sleep_time < min_time:\n        raise SleepModeDoesntFitError\n    return sleep_time", ""]}
{"filename": "skill/exceptions.py", "chunked_list": ["class IncorrectConditionError(Exception):\n    \"\"\"Raised when an incorrect condition passed to a Repo method\"\"\"\n\n    pass\n\n\nclass NoSuchEntityInDB(Exception):\n    \"\"\"Raised by a Repo when no passed entity found in the DB\"\"\"\n\n    pass", "\n\nclass InvalidInputError(Exception):\n    \"\"\"raises when an incorrect input passed to skill methods\"\"\"\n\n    pass\n"]}
{"filename": "skill/db/sa_db_settings.py", "chunked_list": ["import os\nfrom pathlib import Path\n\nfrom dotenv import load_dotenv\nfrom sqlalchemy import event\nfrom sqlalchemy.engine import Engine\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\n\nfrom skill.db.repos.sa_repo import SARepoConfig", "\nfrom skill.db.repos.sa_repo import SARepoConfig\n\nload_dotenv()\n\n\n# Needed for some developing features\n# Should be False when production\nDEBUG = os.getenv(\"BOT_TOKEN\") or False\n", "DEBUG = os.getenv(\"BOT_TOKEN\") or False\n\n\nDB_PROVIDER = os.getenv(\"DB_PROVIDER\") or \"sqlite\"\n\nmatch DB_PROVIDER:\n    case \"postgres\":\n        POSTGRES_DRIVER_NAME = os.getenv(\"POSTGRES_DRIVER_NAME\") or \"asyncpg\"\n\n        POSTGRES_DB_NAME = os.getenv(\"POSTGRES_DB_NAME\") or \"postgres\"", "\n        POSTGRES_DB_NAME = os.getenv(\"POSTGRES_DB_NAME\") or \"postgres\"\n\n        POSTGRES_USERNAME = os.getenv(\"POSTGRES_USERNAME\") or \"postgres\"\n\n        POSTGRES_HOST = os.getenv(\"POSTGRES_HOST\") or \"localhost\"\n\n        POSTGRES_PORT = os.getenv(\"POSTGRES_PORT\") or \"5432\"\n\n        POSTGRES_PASSWORD = os.getenv(\"POSTGRES_PASSWORD\")", "\n        POSTGRES_PASSWORD = os.getenv(\"POSTGRES_PASSWORD\")\n\n        if not POSTGRES_PASSWORD:\n            raise EnvironmentError(\n                \"POSTGRES_PASSWORD required if you are using PostgreSQL\"\n            )\n\n        DB_URL = (\n            f\"postgresql+{POSTGRES_DRIVER_NAME}://\"", "        DB_URL = (\n            f\"postgresql+{POSTGRES_DRIVER_NAME}://\"\n            + f\"{POSTGRES_USERNAME}:{POSTGRES_PASSWORD}\"\n            + f\"@{POSTGRES_HOST}:{POSTGRES_PORT}\"\n            + f\"/{POSTGRES_DB_NAME}\"\n        )\n\n    case _:\n        SQLITE_DRIVER_NAME = os.getenv(\"SQLITE_DRIVER_NAME\") or \"aiosqlite\"\n", "        SQLITE_DRIVER_NAME = os.getenv(\"SQLITE_DRIVER_NAME\") or \"aiosqlite\"\n\n        SQLITE_DB_NAME = os.getenv(\"SQLITE_DB_NAME\") or \"data.db\"\n\n        ROOT_DIR = Path(__file__).parent.parent.parent.resolve()\n\n        # In case you want to change path to SQLite DB file,\n        # just change this variable\n        SQLITE_DB_FILE_PATH = os.getenv(\"SQLITE_DB_FILE_PATH\") or os.path.join(\n            ROOT_DIR, f\"{SQLITE_DB_NAME}\"", "        SQLITE_DB_FILE_PATH = os.getenv(\"SQLITE_DB_FILE_PATH\") or os.path.join(\n            ROOT_DIR, f\"{SQLITE_DB_NAME}\"\n        )\n\n        # URL for your database\n        DB_URL = f\"sqlite+{SQLITE_DRIVER_NAME}:///\" + SQLITE_DB_FILE_PATH\n\n\nengine = create_async_engine(DB_URL, echo=False)\n", "engine = create_async_engine(DB_URL, echo=False)\n\n\nasync_session = sessionmaker(\n    engine, expire_on_commit=False, class_=AsyncSession  # type: ignore\n)\n\nsa_repo_config = SARepoConfig(connection_provider=async_session)\n\nif DB_PROVIDER == \"sqlite\":", "\nif DB_PROVIDER == \"sqlite\":\n\n    @event.listens_for(Engine, \"connect\")\n    def set_sqlite_pragma(dbapi_connection, connection_record):\n        cursor = dbapi_connection.cursor()\n        cursor.execute(\"PRAGMA foreign_keys=ON\")\n        cursor.close()\n", ""]}
{"filename": "skill/db/__init__.py", "chunked_list": [""]}
{"filename": "skill/db/repos/get_repo.py", "chunked_list": ["from typing import Literal\n\nfrom skill.db.repos.base_repo import BaseRepo\nfrom skill.db.repos.sa_repo import SARepo\nfrom skill.db.sa_db_settings import sa_repo_config\n\n\ndef get_repo(repo_type: Literal[\"sa\"]) -> BaseRepo:\n    match repo_type:\n        case \"sa\":", "    match repo_type:\n        case \"sa\":\n            return SARepo(sa_repo_config)\n"]}
{"filename": "skill/db/repos/base_repo.py", "chunked_list": ["from __future__ import annotations\n\nimport abc\nfrom typing import (TYPE_CHECKING, Any, AsyncContextManager, Callable,\n                    Iterable, Literal)\nfrom uuid import UUID\n\nif TYPE_CHECKING:\n    from skill.entities import Activity, Tip, TipsTopic, User\n", "\n\nclass RepoConfig:\n    connection_provider: Callable[..., AsyncContextManager[Any]]\n\n    def __init__(\n        self, connection_provider: Callable[..., AsyncContextManager[Any]]\n    ) -> None:\n        self.connection_provider = connection_provider\n", "\n\nclass BaseRepo(abc.ABC):\n    @abc.abstractmethod\n    def __init__(self, config: RepoConfig) -> None:\n        pass\n\n    @abc.abstractmethod\n    async def insert_user(self, user: User) -> User:\n        pass\n\n    @abc.abstractmethod\n    async def insert_users(self, users: Iterable[User]) -> list[User]:\n        pass\n\n    @abc.abstractmethod\n    async def insert_activity(self, activity: Activity) -> Activity:\n        pass\n\n    @abc.abstractmethod\n    async def insert_activities(\n        self, activities: Iterable[Activity]\n    ) -> list[Activity]:\n        pass\n\n    @abc.abstractmethod\n    async def insert_tips_topic(self, tips_topic: TipsTopic) -> TipsTopic:\n        pass\n\n    @abc.abstractmethod\n    async def insert_tips_topics(\n        self, tips_topics: Iterable[TipsTopic]\n    ) -> list[TipsTopic]:\n        pass\n\n    @abc.abstractmethod\n    async def insert_tip(self, tip: Tip) -> Tip:\n        pass\n\n    @abc.abstractmethod\n    async def insert_tips(self, tips: Iterable[Tip]) -> list[Tip]:\n        pass\n\n    @abc.abstractmethod\n    async def delete_all_users(self) -> None:\n        \"\"\"Deletes ALL users entities from the db\"\"\"\n        pass\n\n    @abc.abstractmethod\n    async def delete_all_activities(self) -> None:\n        \"\"\"Deletes ALL activities entities from the db\"\"\"\n        pass\n\n    @abc.abstractmethod\n    async def delete_all_tips_topics(self) -> None:\n        \"\"\"Deletes ALL tips topics entities from the db\"\"\"\n        pass\n\n    @abc.abstractmethod\n    async def delete_all_tips(self) -> None:\n        \"\"\"Deletes ALL tips entities from the db\"\"\"\n        pass\n\n    @abc.abstractmethod\n    async def delete_user(self, user: User) -> User:\n        \"\"\"Deletes the passed user entity from the db\n\n        Args:\n            user (User): user that is going to be deleted\n\n        Raises:\n            NoSuchEntityInDB: raised if no such entity in the DB\n\n        Returns:\n            User: deleted entity\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    async def delete_activity(self, activity: Activity) -> Activity:\n        \"\"\"Deletes the passed activity entity from the db\n\n        Args:\n            activity (Activity): activity that is going to be deleted\n\n        Raises:\n            NoSuchEntityInDB: raised if no such entity in the DB\n\n        Returns:\n            Activity: deleted entity\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    async def delete_tips_topic(self, tips_topic: TipsTopic) -> TipsTopic:\n        \"\"\"Deletes the passed tips topic entity from the db\n        with all the related tips\n\n        Args:\n            tips_topic (TipsTopic): tips topic that is going to be deleted\n\n        Raises:\n            NoSuchEntityInDB: raised if no such entity in the DB\n\n        Returns:\n            TipsTopic: deleted entity\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    async def delete_tip(self, tip: Tip) -> Tip:\n        \"\"\"Deletes the passed tip entity from the db\n\n        Args:\n            tip (Tip): tip that is going to be deleted\n\n        Raises:\n            NoSuchEntityInDB: raised if no such entity in the DB\n\n        Returns:\n            Tip: deleted entity\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    async def update_user(self, user: User) -> User:\n        \"\"\"Updates the passed user entity in the db\n\n        Args:\n            user (User): user that is going to be updated\n\n        Raises:\n            NoSuchEntityInDB: raised if no such entity in the DB\n\n        Returns:\n            User: updated entity\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    async def update_activity(self, activity: Activity) -> Activity:\n        \"\"\"Updates the passed user entity in the db\n\n        Args:\n            activity (User): activity that is going to be updated\n\n        Raises:\n            NoSuchEntityInDB: raised if no such entity in the DB\n\n        Returns:\n            Activity: updated entity\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    async def update_tips_topic(self, tips_topic: TipsTopic) -> TipsTopic:\n        \"\"\"Updates the passed tips topic entity in the db\n\n        Args:\n            tips_topic (TipsTopic): tips topic that is going to be updated\n\n        Raises:\n            NoSuchEntityInDB: raised if no such entity in the DB\n\n        Returns:\n            TipsTopic: updated entity\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    async def update_tip(self, tip: Tip) -> Tip:\n        \"\"\"Updates the passed tip entity in the db\n\n        Args:\n            tip (Tip): tip that is going to be updated\n\n        Raises:\n            NoSuchEntityInDB: raised if no such entity in the DB\n\n        Returns:\n            Tip: updated entity\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    async def get_user_by_id(self, id: str) -> User | None:\n        pass\n\n    @abc.abstractmethod\n    async def get_activity_by_id(self, id: UUID) -> Activity | None:\n        pass\n\n    @abc.abstractmethod\n    async def get_tips_topic_by_id(self, id: UUID) -> TipsTopic | None:\n        pass\n\n    @abc.abstractmethod\n    async def get_tips_topic_by_name(self, name: str) -> TipsTopic | None:\n        pass\n\n    @abc.abstractmethod\n    async def get_tip_by_id(self, id: UUID) -> Tip | None:\n        pass\n\n    @abc.abstractmethod\n    async def get_tips_topics(\n        self, limit: int | None = None\n    ) -> list[TipsTopic]:\n        \"\"\"If no limit provided, the method should return\n        all tips topics from the DB\n\n        Args:\n            limit (int | None, optional): how many objects you want to get.\n            Defaults to None.\n\n        Returns:\n            list[TipsTopic]: list with objects\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    async def get_topic_tips(self, topic_id: UUID) -> list[Tip]:\n        \"\"\"If no limit provided, the method should return\n        all tips topics from the DB\n\n        Args:\n            limit (int | None, optional): how many objects you want to get.\n            Defaults to None.\n\n        Returns:\n            list[Tip]: list with objects ordered by creation date\n\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    async def get_tips(self, limit: int | None = None) -> list[Tip]:\n        \"\"\"If no limit provided, the method should return\n        all tips topics from the DB\n\n        Args:\n            limit (int | None, optional): how many objects you want to get.\n            Defaults to None.\n\n        Returns:\n            list[Tip]: list with objects\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    async def get_activities(self, limit: int | None = None) -> list[Activity]:\n        \"\"\"If no limit provided, the method should return\n        all tips topics from the DB\n\n        Args:\n            limit (int | None, optional): how many objects you want to get.\n            Defaults to None.\n\n        Returns:\n            list[Activity]: list with objects\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    async def get_users(self, limit: int | None = None) -> list[User]:\n        \"\"\"If no limit provided, the method should return\n        all tips topics from the DB\n\n        Args:\n            limit (int | None, optional): how many objects you want to get.\n            Defaults to None.\n\n        Returns:\n            list[User]: list with objects\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    async def count_all_users(self) -> int:\n        pass\n\n    @abc.abstractmethod\n    async def count_users_with_streak(\n        self,\n        streak: int,\n        condition: Literal[\"<\"]\n        | Literal[\">\"]\n        | Literal[\"<=\"]\n        | Literal[\">=\"]\n        | Literal[\"==\"],\n    ) -> int:\n        pass", ""]}
{"filename": "skill/db/repos/sa_repo.py", "chunked_list": ["import asyncio\nfrom typing import Callable, Iterable, Literal\nfrom uuid import UUID\n\nfrom sqlalchemy import delete, func, select\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom skill.db.models.sa_models import (ActivityModel, TipModel, TipsTopicModel,\n                                       UserModel)\nfrom skill.db.repos.base_repo import BaseRepo, RepoConfig", "                                       UserModel)\nfrom skill.db.repos.base_repo import BaseRepo, RepoConfig\nfrom skill.entities import Activity, Tip, TipsTopic, User\nfrom skill.exceptions import IncorrectConditionError, NoSuchEntityInDB\n\n\nclass SARepoConfig(RepoConfig):\n    connection_provider: Callable[..., AsyncSession]\n\n    def __init__(\n        self, connection_provider: Callable[..., AsyncSession]\n    ) -> None:\n        self.connection_provider = connection_provider", "\n\nclass SARepo(BaseRepo):\n    def __init__(self, config: SARepoConfig) -> None:\n        self.__config = config\n\n    async def insert_user(self, user: User) -> User:\n        async with self.__config.connection_provider() as session:\n            model = UserModel(user)\n\n            session.add(model)\n\n            await session.commit()\n\n            return await self.get_user_by_id(model.id)  # type: ignore\n\n    async def insert_users(self, users: Iterable[User]) -> list[User]:\n        async with self.__config.connection_provider() as session:\n            models = [UserModel(user) for user in users]\n\n            session.add_all(models)\n\n            await session.commit()\n\n            return [\n                entity\n                for entity in await asyncio.gather(\n                    *[self.get_user_by_id(model.id) for model in models]\n                )\n            ]  # type: ignore\n\n    async def insert_activity(self, activity: Activity) -> Activity:\n        async with self.__config.connection_provider() as session:\n            model = ActivityModel(activity)\n\n            session.add(model)\n\n            await session.commit()\n\n            return await self.get_activity_by_id(model.id)  # type: ignore\n\n    async def insert_activities(\n        self, activities: Iterable[Activity]\n    ) -> list[Activity]:\n        async with self.__config.connection_provider() as session:\n            models = [ActivityModel(activity) for activity in activities]\n\n            session.add_all(models)\n\n            await session.commit()\n\n            return [\n                entity\n                for entity in await asyncio.gather(\n                    *[self.get_activity_by_id(model.id) for model in models]\n                )\n            ]  # type: ignore\n\n    async def insert_tips_topic(self, tips_topic: TipsTopic) -> TipsTopic:\n        async with self.__config.connection_provider() as session:\n            model = TipsTopicModel(tips_topic)\n\n            session.add(model)\n\n            await session.commit()\n\n            return await self.get_tips_topic_by_id(model.id)  # type: ignore\n\n    async def insert_tips_topics(\n        self, tips_topics: Iterable[TipsTopic]\n    ) -> list[TipsTopic]:\n        async with self.__config.connection_provider() as session:\n            models = [TipsTopicModel(tips_topic) for tips_topic in tips_topics]\n\n            session.add_all(models)\n\n            await session.commit()\n\n            return [\n                entity\n                for entity in await asyncio.gather(\n                    *[self.get_tips_topic_by_id(model.id) for model in models]\n                )\n            ]  # type: ignore\n\n    async def insert_tip(self, tip: Tip) -> Tip:\n        async with self.__config.connection_provider() as session:\n            model = TipModel(tip)\n\n            session.add(model)\n\n            await session.commit()\n\n            return await self.get_tip_by_id(model.id)  # type: ignore\n\n    async def insert_tips(self, tips: Iterable[Tip]) -> list[Tip]:\n        async with self.__config.connection_provider() as session:\n            models = [TipModel(tip) for tip in tips]\n\n            session.add_all(models)\n\n            await session.commit()\n\n            return [\n                entity\n                for entity in await asyncio.gather(\n                    *[self.get_tip_by_id(model.id) for model in models]\n                )\n            ]\n\n    async def delete_all_users(self) -> None:\n        \"\"\"Deletes ALL users entities from the db\"\"\"\n        async with self.__config.connection_provider() as session:\n            q = delete(UserModel)\n\n            await session.execute(q)\n\n            await session.commit()\n\n    async def delete_all_activities(self) -> None:\n        \"\"\"Deletes ALL activities entities from the db\"\"\"\n        async with self.__config.connection_provider() as session:\n            q = delete(ActivityModel)\n\n            await session.execute(q)\n\n            await session.commit()\n\n    async def delete_all_tips_topics(self) -> None:\n        \"\"\"Deletes ALL tips AND ALL related tips from the db\"\"\"\n        async with self.__config.connection_provider() as session:\n            q = delete(TipsTopicModel)\n\n            await session.execute(q)\n\n            await session.commit()\n\n    async def delete_all_tips(self) -> None:\n        \"\"\"Deletes ALL tips entities from the db\"\"\"\n        async with self.__config.connection_provider() as session:\n            q = delete(TipModel)\n\n            await session.execute(q)\n\n            await session.commit()\n\n    async def delete_user(self, user: User) -> User:\n        \"\"\"Deletes the passed user entity from the db\n\n        Args:\n            user (User): user that is going to be deleted\n\n        Raises:\n            NoSuchEntityInDB: raised if no such entity in the DB\n\n        Returns:\n            User: deleted entity\n        \"\"\"\n        async with self.__config.connection_provider() as session:\n            model = await session.get(UserModel, user._id)\n\n            if not model:\n                raise NoSuchEntityInDB(f\"No user with next id: {user._id}\")\n\n            await session.delete(model)\n\n            await session.commit()\n\n            return model.as_entity(self)\n\n    async def delete_activity(self, activity: Activity) -> Activity:\n        \"\"\"Deletes the passed activity entity from the db\n\n        Args:\n            activity (Activity): activity that is going to be deleted\n\n        Raises:\n            NoSuchEntityInDB: raised if no such entity in the DB\n\n        Returns:\n            Activity: deleted entity\n        \"\"\"\n\n        async with self.__config.connection_provider() as session:\n            model = await session.get(ActivityModel, activity._id)\n\n            if not model:\n                raise NoSuchEntityInDB(\n                    f\"No activity with next id: {activity._id}\"\n                )\n\n            await session.delete(model)\n\n            await session.commit()\n\n            return model.as_entity(self)\n\n    async def delete_tips_topic(self, tips_topic: TipsTopic) -> TipsTopic:\n        \"\"\"Deletes the passed tips topic entity from the db\n        with all the related tips\n\n        Args:\n            tips_topic (TipsTopic): tips topic that is going to be deleted\n\n        Raises:\n            NoSuchEntityInDB: raised if no such entity in the DB\n\n        Returns:\n            TipsTopic: deleted entity\n        \"\"\"\n\n        async with self.__config.connection_provider() as session:\n            model = await session.get(TipsTopicModel, tips_topic._id)\n\n            if not model:\n                raise NoSuchEntityInDB(\n                    f\"No tips topic with next id: {tips_topic._id}\"\n                )\n\n            await session.delete(model)\n\n            await session.commit()\n\n            return model.as_entity(self)\n\n    async def delete_tip(self, tip: Tip) -> Tip:\n        \"\"\"Deletes the passed tip entity from the db\n\n        Args:\n            tip (Tip): tip that is going to be deleted\n\n        Raises:\n            NoSuchEntityInDB: raised if no such entity in the DB\n\n        Returns:\n            Tip: deleted entity\n        \"\"\"\n\n        async with self.__config.connection_provider() as session:\n            model = await session.get(TipModel, tip._id)\n\n            if not model:\n                raise NoSuchEntityInDB(f\"No tip with next id: {tip._id}\")\n\n            await session.delete(model)\n\n            await session.commit()\n\n            return model.as_entity(self)\n\n    async def update_user(self, user: User) -> User:\n        \"\"\"Updates the passed user entity in the db\n\n        Args:\n            user (User): user that is going to be updated\n\n        Raises:\n            NoSuchEntityInDB: raised if no such entity in the DB\n\n        Returns:\n            User: updated entity\n        \"\"\"\n        async with self.__config.connection_provider() as session:\n            model_in_db = await session.get(UserModel, user._id)\n\n            if not model_in_db:\n                raise NoSuchEntityInDB(f\"No user with next id: {user._id}\")\n\n            model = UserModel(user)\n\n            await session.merge(model)\n\n            await session.commit()\n\n            return await self.get_user_by_id(model.id)  # type: ignore\n\n    async def update_activity(self, activity: Activity) -> Activity:\n        \"\"\"Updates the passed user entity in the db\n\n        Args:\n            activity (User): activity that is going to be updated\n\n        Raises:\n            NoSuchEntityInDB: raised if no such entity in the DB\n\n        Returns:\n            Activity: updated entity\n        \"\"\"\n        async with self.__config.connection_provider() as session:\n            model_in_db = await session.get(ActivityModel, activity._id)\n\n            if not model_in_db:\n                raise NoSuchEntityInDB(\n                    f\"No activity with next id: {activity._id}\"\n                )\n\n            model = ActivityModel(activity)\n\n            await session.merge(model)\n\n            await session.commit()\n\n            return await self.get_activity_by_id(model.id)  # type: ignore\n\n    async def update_tips_topic(self, tips_topic: TipsTopic) -> TipsTopic:\n        \"\"\"Updates the passed tips topic entity in the db\n\n        Args:\n            tips_topic (TipsTopic): tips topic that is going to be updated\n\n        Raises:\n            NoSuchEntityInDB: raised if no such entity in the DB\n\n        Returns:\n            TipsTopic: updated entity\n        \"\"\"\n        async with self.__config.connection_provider() as session:\n            model_in_db = await session.get(TipsTopicModel, tips_topic._id)\n\n            if not model_in_db:\n                raise NoSuchEntityInDB(\n                    f\"No tips topic with next id: {tips_topic._id}\"\n                )\n\n            model = TipsTopicModel(tips_topic)\n\n            await session.merge(model)\n\n            await session.commit()\n\n            return await self.get_tips_topic_by_id(model.id)  # type: ignore\n\n    async def update_tip(self, tip: Tip) -> Tip:\n        \"\"\"Updates the passed tip entity in the db\n\n        Args:\n            tip (Tip): tip that is going to be updated\n\n        Raises:\n            NoSuchEntityInDB: raised if no such entity in the DB\n\n        Returns:\n            Tip: updated entity\n        \"\"\"\n        async with self.__config.connection_provider() as session:\n            model_in_db = await session.get(TipModel, tip._id)\n\n            if not model_in_db:\n                raise NoSuchEntityInDB(\n                    f\"No tips topic with next id: {tip._id}\"\n                )\n\n            model = TipModel(tip)\n\n            await session.merge(model)\n\n            await session.commit()\n\n            return await self.get_tip_by_id(model.id)  # type: ignore\n\n    async def get_user_by_id(self, id: str) -> User | None:\n        async with self.__config.connection_provider() as session:\n            q = select(UserModel).where(UserModel.id == id)\n\n            res = (await session.execute(q)).scalar()\n\n            return res and res.as_entity(self)\n\n    async def get_activity_by_id(self, id: UUID) -> Activity | None:\n        async with self.__config.connection_provider() as session:\n            q = select(ActivityModel).where(ActivityModel.id == id)\n\n            res = (await session.execute(q)).scalar()\n\n            return res and res.as_entity(self)\n\n    async def get_tips_topic_by_id(self, id: UUID) -> TipsTopic | None:\n        async with self.__config.connection_provider() as session:\n            q = select(TipsTopicModel).where(TipsTopicModel.id == id)\n\n            res = (await session.execute(q)).scalar()\n\n            return res and res.as_entity(self)\n\n    async def get_tips_topic_by_name(self, name: str) -> TipsTopic | None:\n        async with self.__config.connection_provider() as session:\n            q = select(TipsTopicModel).where(TipsTopicModel.name_text == name)\n\n            res = (await session.execute(q)).scalar()\n\n            return res and res.as_entity(self)\n\n    async def get_tip_by_id(self, id: UUID) -> Tip | None:\n        async with self.__config.connection_provider() as session:\n            q = select(TipModel).where(TipModel.id == id)\n\n            res = (await session.execute(q)).scalar()\n\n            return res and res.as_entity(self)\n\n    async def get_tips_topics(\n        self, limit: int | None = None\n    ) -> list[TipsTopic]:\n        \"\"\"If no limit provided, the method should return\n        all tips topics from the DB\n\n        Args:\n            limit (int | None, optional): how many objects you want to get.\n            Defaults to None.\n\n        Returns:\n            list[TipsTopic]: list with objects ordered by creation date\n        \"\"\"\n        async with self.__config.connection_provider() as session:\n            q = (\n                select(TipsTopicModel)\n                .order_by(TipsTopicModel.created_date)\n                .limit(limit)\n            )\n\n            res = (await session.execute(q)).scalars().all()\n\n            return [model.as_entity(self) for model in res]\n\n    async def get_topic_tips(\n        self, topic_id: UUID, limit: int | None = None\n    ) -> list[Tip]:\n        \"\"\"If no limit provided, the method should return\n        all tips topics from the DB\n\n        Args:\n            limit (int | None, optional): how many objects you want to get.\n            Defaults to None.\n\n        Returns:\n            list[Tip]: list with objects ordered by creation date\n\n        \"\"\"\n        async with self.__config.connection_provider() as session:\n            q = (\n                select(TipModel)\n                .where(TipModel.tips_topic_id == topic_id)\n                .order_by(TipModel.created_date)\n                .limit(limit)\n            )\n\n            res = (await session.execute(q)).scalars().all()\n\n            return [model.as_entity(self) for model in res]\n\n    async def get_tips(self, limit: int | None = None) -> list[Tip]:\n        \"\"\"If no limit provided, the method should return\n        all tips topics from the DB\n\n        Args:\n            limit (int | None, optional): how many objects you want to get.\n            Defaults to None.\n\n        Returns:\n            list[Tip]: list with objects ordered by creation date\n        \"\"\"\n        async with self.__config.connection_provider() as session:\n            q = select(TipModel).order_by(TipModel.created_date).limit(limit)\n\n            res = (await session.execute(q)).scalars().all()\n\n            return [model.as_entity(self) for model in res]\n\n    async def get_activities(self, limit: int | None = None) -> list[Activity]:\n        \"\"\"If no limit provided, the method should return\n        all tips topics from the DB\n\n        Args:\n            limit (int | None, optional): how many objects you want to get.\n            Defaults to None.\n\n        Returns:\n            list[Activity]: list with objects ordered by creation date\n        \"\"\"\n        async with self.__config.connection_provider() as session:\n            q = (\n                select(ActivityModel)\n                .order_by(ActivityModel.created_date)\n                .limit(limit)\n            )\n\n            res = (await session.execute(q)).scalars().all()\n\n            return [model.as_entity(self) for model in res]\n\n    async def get_users(self, limit: int | None = None) -> list[User]:\n        \"\"\"If no limit provided, the method should return\n        all tips topics from the DB\n\n        Args:\n            limit (int | None, optional): how many objects you want to get.\n            Defaults to None.\n\n        Returns:\n            list[User]: list with objects ordered by joining date\n        \"\"\"\n        async with self.__config.connection_provider() as session:\n            q = select(UserModel).order_by(UserModel.join_date).limit(limit)\n\n            res = (await session.execute(q)).scalars().all()\n\n            return [model.as_entity(self) for model in res]\n\n    async def count_all_users(self) -> int:\n        async with self.__config.connection_provider() as session:\n            q = select(func.count(UserModel.id))\n\n            return (await session.execute(q)).scalar()  # type: ignore\n\n    async def count_users_with_streak(\n        self,\n        streak: int,\n        condition: Literal[\"<\"]\n        | Literal[\">\"]\n        | Literal[\"<=\"]\n        | Literal[\">=\"]\n        | Literal[\"==\"],\n    ) -> int:\n        async with self.__config.connection_provider() as session:\n            Q_CONDITIONS = {\n                \">\": UserModel.streak > streak,\n                \"<\": UserModel.streak < streak,\n                \">=\": UserModel.streak >= streak,\n                \"<=\": UserModel.streak <= streak,\n                \"==\": UserModel.streak == streak,\n            }\n\n            if condition not in Q_CONDITIONS:\n                raise IncorrectConditionError()\n\n            q = select(func.count(UserModel.id)).where(Q_CONDITIONS[condition])\n\n            return (await session.execute(q)).scalar()  # type: ignore", ""]}
{"filename": "skill/db/repos/__init__.py", "chunked_list": [""]}
{"filename": "skill/db/models/__init__.py", "chunked_list": [""]}
{"filename": "skill/db/models/sa_models.py", "chunked_list": ["from __future__ import annotations\n\nfrom datetime import datetime, time, timedelta\nfrom uuid import UUID\n\nfrom sqlalchemy import (Column, DateTime, ForeignKey, Integer, Interval,\n                        String, Table, Time, Uuid)\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship\n\nfrom skill.db.repos.base_repo import BaseRepo", "\nfrom skill.db.repos.base_repo import BaseRepo\nfrom skill.entities import Activity, Tip, TipsTopic, User\nfrom skill.utils import TextWithTTS\n\n\nclass BaseModel(DeclarativeBase):\n    pass\n\n", "\n\nheard_tips_table = Table(\n    \"heard_tips\",\n    BaseModel.metadata,\n    Column(\"user_id\", ForeignKey(\"users.id\"), primary_key=True),\n    Column(\"tip_id\", ForeignKey(\"tips.id\"), primary_key=True),\n)\n\n\nclass UserModel(BaseModel):\n    __tablename__ = \"users\"\n\n    id: Mapped[str] = mapped_column(String(64), primary_key=True)\n    streak: Mapped[int] = mapped_column(Integer)\n    last_skill_use: Mapped[datetime | None] = mapped_column(\n        DateTime(True), default=None\n    )\n    last_wake_up_time: Mapped[time | None] = mapped_column(\n        Time(), default=None\n    )\n    join_date: Mapped[datetime] = mapped_column(DateTime(True))\n\n    heard_tips: Mapped[list[TipModel]] = relationship(\n        \"TipModel\",\n        back_populates=\"users_heard\",\n        order_by=\"TipModel.created_date\",\n        lazy=\"selectin\",\n        secondary=heard_tips_table,\n    )\n\n    def __init__(self, entity: User):\n        self.id = entity._id\n        self.streak = entity._streak\n        self.last_skill_use = entity.last_skill_use\n        self.last_wake_up_time = entity.last_wake_up_time\n        self.join_date = entity._join_date\n\n        self.heard_tips = [\n            TipModel(heard_tip) for heard_tip in entity._heard_tips\n        ]\n\n    def as_entity(self, repo: BaseRepo) -> User:\n        return User(\n            id=self.id,\n            streak=self.streak,\n            last_skill_use=self.last_skill_use,\n            last_wake_up_time=self.last_wake_up_time,\n            join_date=self.join_date,\n            heard_tips=[tip.as_entity(repo) for tip in self.heard_tips],\n            repo=repo,\n        )", "\n\nclass UserModel(BaseModel):\n    __tablename__ = \"users\"\n\n    id: Mapped[str] = mapped_column(String(64), primary_key=True)\n    streak: Mapped[int] = mapped_column(Integer)\n    last_skill_use: Mapped[datetime | None] = mapped_column(\n        DateTime(True), default=None\n    )\n    last_wake_up_time: Mapped[time | None] = mapped_column(\n        Time(), default=None\n    )\n    join_date: Mapped[datetime] = mapped_column(DateTime(True))\n\n    heard_tips: Mapped[list[TipModel]] = relationship(\n        \"TipModel\",\n        back_populates=\"users_heard\",\n        order_by=\"TipModel.created_date\",\n        lazy=\"selectin\",\n        secondary=heard_tips_table,\n    )\n\n    def __init__(self, entity: User):\n        self.id = entity._id\n        self.streak = entity._streak\n        self.last_skill_use = entity.last_skill_use\n        self.last_wake_up_time = entity.last_wake_up_time\n        self.join_date = entity._join_date\n\n        self.heard_tips = [\n            TipModel(heard_tip) for heard_tip in entity._heard_tips\n        ]\n\n    def as_entity(self, repo: BaseRepo) -> User:\n        return User(\n            id=self.id,\n            streak=self.streak,\n            last_skill_use=self.last_skill_use,\n            last_wake_up_time=self.last_wake_up_time,\n            join_date=self.join_date,\n            heard_tips=[tip.as_entity(repo) for tip in self.heard_tips],\n            repo=repo,\n        )", "\n\nclass ActivityModel(BaseModel):\n    __tablename__ = \"activities\"\n\n    id: Mapped[UUID] = mapped_column(Uuid, primary_key=True)\n    description_text: Mapped[str] = mapped_column(\n        String(512), unique=True, index=True\n    )\n    description_tts: Mapped[str] = mapped_column(String(512))\n    created_date: Mapped[datetime] = mapped_column(DateTime(True))\n    occupation_time: Mapped[timedelta] = mapped_column(Interval)\n\n    def __init__(self, entity: Activity):\n        self.id = entity._id\n        self.created_date = entity._created_date\n        self.description_text, self.description_tts = (\n            entity.description.text,\n            entity.description.tts,\n        )\n        self.occupation_time = entity.occupation_time\n\n    def as_entity(self, repo: BaseRepo) -> Activity:\n        return Activity(\n            id=self.id,\n            created_date=self.created_date,\n            description=TextWithTTS(\n                self.description_text, self.description_tts\n            ),\n            occupation_time=self.occupation_time,\n            repo=repo,\n        )", "\n\nclass TipModel(BaseModel):\n    __tablename__ = \"tips\"\n\n    id: Mapped[UUID] = mapped_column(Uuid, primary_key=True)\n    short_description_text: Mapped[str] = mapped_column(\n        String(256), unique=True, index=True\n    )\n    short_description_tts: Mapped[str] = mapped_column(String(256))\n    tip_content_text: Mapped[str] = mapped_column(\n        String(1024), unique=True, index=True\n    )\n    tip_content_tts: Mapped[str] = mapped_column(String(1024))\n\n    tips_topic_id: Mapped[UUID] = mapped_column(\n        Uuid, ForeignKey(\"tips_topics.id\", ondelete=\"CASCADE\")\n    )\n    tips_topic = relationship(\n        \"TipsTopicModel\",\n        back_populates=\"tips\",\n        lazy=\"selectin\",\n    )\n\n    users_heard = relationship(\"UserModel\", secondary=heard_tips_table)\n\n    created_date: Mapped[datetime] = mapped_column(DateTime(True))\n\n    def __init__(self, entity: Tip) -> None:\n        self.id = entity._id\n        self.short_description_text, self.short_description_tts = (\n            entity.short_description.text,\n            entity.short_description.tts,\n        )\n\n        self.tip_content_text, self.tip_content_tts = (\n            entity.tip_content.text,\n            entity.tip_content.tts,\n        )\n\n        self.tips_topic_id = entity.tips_topic._id\n\n        self.created_date = entity._created_date\n\n    def as_entity(self, repo: BaseRepo) -> Tip:\n        return Tip(\n            id=self.id,\n            created_date=self.created_date,\n            short_description=TextWithTTS(\n                self.short_description_text, self.short_description_tts\n            ),\n            tip_content=TextWithTTS(\n                self.tip_content_text, self.tip_content_tts\n            ),\n            tips_topic=self.tips_topic.as_entity(repo),\n            repo=repo,\n        )", "\n\nclass TipsTopicModel(BaseModel):\n    __tablename__ = \"tips_topics\"\n\n    id: Mapped[UUID] = mapped_column(Uuid, primary_key=True)\n    name_text: Mapped[str] = mapped_column(\n        String(256), unique=True, index=True\n    )\n    name_tts: Mapped[str] = mapped_column(String(256))\n    topic_description_text: Mapped[str] = mapped_column(\n        String(1024), unique=True, index=True\n    )\n    topic_description_tts: Mapped[str] = mapped_column(String(1024))\n\n    tips = relationship(\n        \"TipModel\",\n        back_populates=\"tips_topic\",\n        passive_deletes=True,\n    )\n\n    created_date: Mapped[datetime] = mapped_column(DateTime(True))\n\n    def __init__(self, entity: TipsTopic) -> None:\n        self.id = entity._id\n        self.name_text, self.name_tts = entity.name.text, entity.name.tts\n        self.topic_description_text, self.topic_description_tts = (\n            entity.topic_description.text,\n            entity.topic_description.tts,\n        )\n        self.created_date = entity._created_date\n\n    def as_entity(self, repo: BaseRepo) -> TipsTopic:\n        return TipsTopic(\n            id=self.id,\n            created_date=self.created_date,\n            name=TextWithTTS(self.name_text, self.name_tts),\n            topic_description=TextWithTTS(\n                self.topic_description_text, self.topic_description_tts\n            ),\n            repo=repo,\n        )", ""]}
{"filename": "skill/db/migrations/alembic/env.py", "chunked_list": ["import asyncio\nfrom logging.config import fileConfig\n\nfrom alembic import context\nfrom sqlalchemy import engine_from_config, pool\nfrom sqlalchemy.engine import Connection\nfrom sqlalchemy.ext.asyncio import AsyncEngine\n\nfrom skill.db.models.sa_models import BaseModel\nfrom skill.db.sa_db_settings import DB_URL", "from skill.db.models.sa_models import BaseModel\nfrom skill.db.sa_db_settings import DB_URL\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\n\nconfig.set_main_option(\"sqlalchemy.url\", DB_URL)\n\n# Interpret the config file for Python logging.", "\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nif config.config_file_name is not None:\n    fileConfig(config.config_file_name)\n\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata", "# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata\ntarget_metadata = BaseModel.metadata\n\n# other values from the config, defined by the needs of env.py,\n# can be acquired:\n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\n\n\ndef run_migrations_offline() -> None:\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    url = config.get_main_option(\"sqlalchemy.url\")\n    context.configure(\n        url=url,\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()", "\n\ndef run_migrations_offline() -> None:\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    url = config.get_main_option(\"sqlalchemy.url\")\n    context.configure(\n        url=url,\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()", "\n\ndef do_run_migrations(connection: Connection) -> None:\n    context.configure(connection=connection, target_metadata=target_metadata)\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\nasync def run_migrations_online() -> None:", "\nasync def run_migrations_online() -> None:\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    connectable = AsyncEngine(\n        engine_from_config(", "    connectable = AsyncEngine(\n        engine_from_config(\n            config.get_section(config.config_ini_section),  # type: ignore\n            prefix=\"sqlalchemy.\",\n            poolclass=pool.NullPool,\n            future=True,\n        )\n    )\n\n    async with connectable.connect() as connection:", "\n    async with connectable.connect() as connection:\n        await connection.run_sync(do_run_migrations)\n\n    await connectable.dispose()\n\n\nif context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    asyncio.run(run_migrations_online())", ""]}
{"filename": "skill/db/migrations/alembic/versions/13f56def336c_initial.py", "chunked_list": ["\"\"\"Initial\n\nRevision ID: 13f56def336c\nRevises: \nCreate Date: 2023-03-25 22:31:06.656168\n\n\"\"\"\nimport sqlalchemy as sa\nfrom alembic import op\n", "from alembic import op\n\n# revision identifiers, used by Alembic.\nrevision = '13f56def336c'\ndown_revision = None\nbranch_labels = None\ndepends_on = None\n\n\ndef upgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('activities',\n    sa.Column('id', sa.Uuid(), nullable=False),\n    sa.Column('description_text', sa.String(length=512), nullable=False),\n    sa.Column('description_tts', sa.String(length=512), nullable=False),\n    sa.Column('created_date', sa.DateTime(timezone=True), nullable=False),\n    sa.Column('occupation_time', sa.Interval(), nullable=False),\n    sa.PrimaryKeyConstraint('id')\n    )\n    op.create_table('tips_topics',\n    sa.Column('id', sa.Uuid(), nullable=False),\n    sa.Column('name_text', sa.String(length=256), nullable=False),\n    sa.Column('name_tts', sa.String(length=256), nullable=False),\n    sa.Column('topic_description_text', sa.String(length=1024), nullable=False),\n    sa.Column('topic_description_tts', sa.String(length=1024), nullable=False),\n    sa.Column('created_date', sa.DateTime(timezone=True), nullable=False),\n    sa.PrimaryKeyConstraint('id')\n    )\n    op.create_table('users',\n    sa.Column('id', sa.String(length=64), nullable=False),\n    sa.Column('streak', sa.Integer(), nullable=False),\n    sa.Column('last_skill_use', sa.DateTime(timezone=True), nullable=True),\n    sa.Column('last_wake_up_time', sa.Time(), nullable=True),\n    sa.Column('join_date', sa.DateTime(timezone=True), nullable=False),\n    sa.PrimaryKeyConstraint('id')\n    )\n    op.create_table('tips',\n    sa.Column('id', sa.Uuid(), nullable=False),\n    sa.Column('short_description_text', sa.String(length=256), nullable=False),\n    sa.Column('short_description_tts', sa.String(length=256), nullable=False),\n    sa.Column('tip_content_text', sa.String(length=1024), nullable=False),\n    sa.Column('tip_content_tts', sa.String(length=1024), nullable=False),\n    sa.Column('tips_topic_id', sa.Uuid(), nullable=False),\n    sa.Column('created_date', sa.DateTime(timezone=True), nullable=False),\n    sa.ForeignKeyConstraint(['tips_topic_id'], ['tips_topics.id'], ondelete='CASCADE'),\n    sa.PrimaryKeyConstraint('id')\n    )\n    op.create_table('heard_tips',\n    sa.Column('user_id', sa.String(length=64), nullable=False),\n    sa.Column('tip_id', sa.Uuid(), nullable=False),\n    sa.ForeignKeyConstraint(['tip_id'], ['tips.id'], ),\n    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),\n    sa.PrimaryKeyConstraint('user_id', 'tip_id')\n    )", "\ndef upgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('activities',\n    sa.Column('id', sa.Uuid(), nullable=False),\n    sa.Column('description_text', sa.String(length=512), nullable=False),\n    sa.Column('description_tts', sa.String(length=512), nullable=False),\n    sa.Column('created_date', sa.DateTime(timezone=True), nullable=False),\n    sa.Column('occupation_time', sa.Interval(), nullable=False),\n    sa.PrimaryKeyConstraint('id')\n    )\n    op.create_table('tips_topics',\n    sa.Column('id', sa.Uuid(), nullable=False),\n    sa.Column('name_text', sa.String(length=256), nullable=False),\n    sa.Column('name_tts', sa.String(length=256), nullable=False),\n    sa.Column('topic_description_text', sa.String(length=1024), nullable=False),\n    sa.Column('topic_description_tts', sa.String(length=1024), nullable=False),\n    sa.Column('created_date', sa.DateTime(timezone=True), nullable=False),\n    sa.PrimaryKeyConstraint('id')\n    )\n    op.create_table('users',\n    sa.Column('id', sa.String(length=64), nullable=False),\n    sa.Column('streak', sa.Integer(), nullable=False),\n    sa.Column('last_skill_use', sa.DateTime(timezone=True), nullable=True),\n    sa.Column('last_wake_up_time', sa.Time(), nullable=True),\n    sa.Column('join_date', sa.DateTime(timezone=True), nullable=False),\n    sa.PrimaryKeyConstraint('id')\n    )\n    op.create_table('tips',\n    sa.Column('id', sa.Uuid(), nullable=False),\n    sa.Column('short_description_text', sa.String(length=256), nullable=False),\n    sa.Column('short_description_tts', sa.String(length=256), nullable=False),\n    sa.Column('tip_content_text', sa.String(length=1024), nullable=False),\n    sa.Column('tip_content_tts', sa.String(length=1024), nullable=False),\n    sa.Column('tips_topic_id', sa.Uuid(), nullable=False),\n    sa.Column('created_date', sa.DateTime(timezone=True), nullable=False),\n    sa.ForeignKeyConstraint(['tips_topic_id'], ['tips_topics.id'], ondelete='CASCADE'),\n    sa.PrimaryKeyConstraint('id')\n    )\n    op.create_table('heard_tips',\n    sa.Column('user_id', sa.String(length=64), nullable=False),\n    sa.Column('tip_id', sa.Uuid(), nullable=False),\n    sa.ForeignKeyConstraint(['tip_id'], ['tips.id'], ),\n    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),\n    sa.PrimaryKeyConstraint('user_id', 'tip_id')\n    )", "    # ### end Alembic commands ###\n\n\ndef downgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_table('heard_tips')\n    op.drop_table('tips')\n    op.drop_table('users')\n    op.drop_table('tips_topics')\n    op.drop_table('activities')", "    # ### end Alembic commands ###\n"]}
{"filename": "skill/db/migrations/alembic/versions/17ae56c4d705_added_unique_fields_and_indexes.py", "chunked_list": ["\"\"\"Added unique fields and indexes\n\nRevision ID: 17ae56c4d705\nRevises: 13f56def336c\nCreate Date: 2023-03-28 22:08:20.183143\n\n\"\"\"\nimport sqlalchemy as sa\nfrom alembic import op\n", "from alembic import op\n\n# revision identifiers, used by Alembic.\nrevision = '17ae56c4d705'\ndown_revision = '13f56def336c'\nbranch_labels = None\ndepends_on = None\n\n\ndef upgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_index(op.f('ix_activities_description_text'), 'activities', ['description_text'], unique=True)\n    op.create_index(op.f('ix_tips_short_description_text'), 'tips', ['short_description_text'], unique=True)\n    op.create_index(op.f('ix_tips_tip_content_text'), 'tips', ['tip_content_text'], unique=True)\n    op.create_index(op.f('ix_tips_topics_name_text'), 'tips_topics', ['name_text'], unique=True)\n    op.create_index(op.f('ix_tips_topics_topic_description_text'), 'tips_topics', ['topic_description_text'], unique=True)", "\ndef upgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_index(op.f('ix_activities_description_text'), 'activities', ['description_text'], unique=True)\n    op.create_index(op.f('ix_tips_short_description_text'), 'tips', ['short_description_text'], unique=True)\n    op.create_index(op.f('ix_tips_tip_content_text'), 'tips', ['tip_content_text'], unique=True)\n    op.create_index(op.f('ix_tips_topics_name_text'), 'tips_topics', ['name_text'], unique=True)\n    op.create_index(op.f('ix_tips_topics_topic_description_text'), 'tips_topics', ['topic_description_text'], unique=True)\n    # ### end Alembic commands ###\n", "    # ### end Alembic commands ###\n\n\ndef downgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_index(op.f('ix_tips_topics_topic_description_text'), table_name='tips_topics')\n    op.drop_index(op.f('ix_tips_topics_name_text'), table_name='tips_topics')\n    op.drop_index(op.f('ix_tips_tip_content_text'), table_name='tips')\n    op.drop_index(op.f('ix_tips_short_description_text'), table_name='tips')\n    op.drop_index(op.f('ix_activities_description_text'), table_name='activities')", "    # ### end Alembic commands ###\n"]}
{"filename": "skill/messages/select.py", "chunked_list": ["from skill.messages.ru_messages import RUMessages\n\nPOSIX_alliases = {\"ru-RU\": RUMessages}\n\n\ndef auto(locale):\n    \"\"\"Determine what Messages class should be used according to\n    user's locale.\n\n    Args:\n        locale (str): POSIX language code\n\n    Returns:\n        Type[BaseMessages]: Messages class for the specified language\n\n    \"\"\"\n\n    if locale not in POSIX_alliases:\n        return RUMessages\n    return POSIX_alliases[locale]", ""]}
{"filename": "skill/messages/base_messages.py", "chunked_list": ["import abc\nimport datetime\nfrom skill.utils import TextWithTTS\nfrom typing import List\nfrom skill.sleep_calculator import SleepCalculation\nfrom skill.entities import Tip, Activity\n\n\nclass BaseMessages(abc.ABC):\n    MENU_BUTTONS_TEXT: list[str]\n    TIP_TOPIC_SELECTION_BUTTONS_TEXT: list[str]\n    SLEEP_TIME_PROPOSAL_BUTTONS_TEXT: list[str]\n    SLEEP_MODE_SELECTION_BUTTONS_TEXT: list[str]\n    POST_SLEEP_CALCULATION_BUTTONS_TEXT: list[str]\n\n    def __init__(self):\n        pass\n\n    @abc.abstractmethod\n    def get_start_message_intro(self, time: datetime.datetime) -> TextWithTTS:\n        pass\n\n    @abc.abstractmethod\n    def get_start_message_comeback(\n        self, time: datetime.datetime, streak: int, scoreboard: int\n    ) -> TextWithTTS:\n        pass\n\n    @abc.abstractmethod\n    def get_menu_welcome_message(self) -> TextWithTTS:\n        pass\n\n    @abc.abstractmethod\n    def get_info_message(self) -> TextWithTTS:\n        pass\n\n    @abc.abstractmethod\n    def get_ask_tip_topic_message(self) -> TextWithTTS:\n        pass\n\n    @abc.abstractmethod\n    def get_propose_yesterday_wake_up_time_message(\n        self, last_time: datetime.time\n    ) -> TextWithTTS:\n        pass\n\n    @abc.abstractmethod\n    def get_ask_wake_up_time_message(self) -> TextWithTTS:\n        pass\n\n    @abc.abstractmethod\n    def get_ask_sleep_mode_message(self) -> TextWithTTS:\n        pass\n\n    @abc.abstractmethod\n    def get_tip_message(self, tip: Tip) -> TextWithTTS:\n        pass\n\n    @abc.abstractmethod\n    def get_sleep_calc_time_message(\n        self,\n        sleep_calc_result: SleepCalculation,\n        activities: List[Activity],\n    ) -> TextWithTTS:\n        pass\n\n    @abc.abstractmethod\n    def get_good_night_message(self) -> TextWithTTS:\n        pass\n\n    @abc.abstractmethod\n    def get_wrong_topic_message(self, topic_name: str) -> TextWithTTS:\n        pass\n\n    @abc.abstractmethod\n    def get_generic_error_message(self) -> TextWithTTS:\n        pass\n\n    @abc.abstractmethod\n    def get_wrong_time_message(self) -> TextWithTTS:\n        pass\n\n    @abc.abstractmethod\n    def get_help_message(self) -> TextWithTTS:\n        pass\n\n    @abc.abstractmethod\n    def get_quit_message(self) -> TextWithTTS:\n        pass", "class BaseMessages(abc.ABC):\n    MENU_BUTTONS_TEXT: list[str]\n    TIP_TOPIC_SELECTION_BUTTONS_TEXT: list[str]\n    SLEEP_TIME_PROPOSAL_BUTTONS_TEXT: list[str]\n    SLEEP_MODE_SELECTION_BUTTONS_TEXT: list[str]\n    POST_SLEEP_CALCULATION_BUTTONS_TEXT: list[str]\n\n    def __init__(self):\n        pass\n\n    @abc.abstractmethod\n    def get_start_message_intro(self, time: datetime.datetime) -> TextWithTTS:\n        pass\n\n    @abc.abstractmethod\n    def get_start_message_comeback(\n        self, time: datetime.datetime, streak: int, scoreboard: int\n    ) -> TextWithTTS:\n        pass\n\n    @abc.abstractmethod\n    def get_menu_welcome_message(self) -> TextWithTTS:\n        pass\n\n    @abc.abstractmethod\n    def get_info_message(self) -> TextWithTTS:\n        pass\n\n    @abc.abstractmethod\n    def get_ask_tip_topic_message(self) -> TextWithTTS:\n        pass\n\n    @abc.abstractmethod\n    def get_propose_yesterday_wake_up_time_message(\n        self, last_time: datetime.time\n    ) -> TextWithTTS:\n        pass\n\n    @abc.abstractmethod\n    def get_ask_wake_up_time_message(self) -> TextWithTTS:\n        pass\n\n    @abc.abstractmethod\n    def get_ask_sleep_mode_message(self) -> TextWithTTS:\n        pass\n\n    @abc.abstractmethod\n    def get_tip_message(self, tip: Tip) -> TextWithTTS:\n        pass\n\n    @abc.abstractmethod\n    def get_sleep_calc_time_message(\n        self,\n        sleep_calc_result: SleepCalculation,\n        activities: List[Activity],\n    ) -> TextWithTTS:\n        pass\n\n    @abc.abstractmethod\n    def get_good_night_message(self) -> TextWithTTS:\n        pass\n\n    @abc.abstractmethod\n    def get_wrong_topic_message(self, topic_name: str) -> TextWithTTS:\n        pass\n\n    @abc.abstractmethod\n    def get_generic_error_message(self) -> TextWithTTS:\n        pass\n\n    @abc.abstractmethod\n    def get_wrong_time_message(self) -> TextWithTTS:\n        pass\n\n    @abc.abstractmethod\n    def get_help_message(self) -> TextWithTTS:\n        pass\n\n    @abc.abstractmethod\n    def get_quit_message(self) -> TextWithTTS:\n        pass", ""]}
{"filename": "skill/messages/unicode_literals.py", "chunked_list": ["DASH = \"\u2014\"\nLAQUO = \"\u00ab\"\nRAQUO = \"\u00bb\"\n"]}
{"filename": "skill/messages/debug.py", "chunked_list": ["import datetime\n\nfrom skill.utils import TextWithTTS\n\n\ndef messages_showcase(messages_class):\n    msg = messages_class()\n\n    class QuaziTip:\n        tip_content = TextWithTTS(\n            \"\u043b\u043e\u0436\u0438\u0442\u0435\u0441\u044c \u0441\u043f\u0430\u0442\u044c \u0432 \u043f\u043e\u043b\u0434\u0435\u043d\u044c, \u044d\u0442\u043e \u043f\u043e\u043c\u043e\u0433\u0430\u0435\u0442 \u043f\u0438\u0449\u0435\u0432\u0430\u0440\u0435\u043d\u0438\u044e\",\n            \"\u043b\u0430\u0436\u0438\u0442\u0435\u0441\u044c \u0441\u043f\u0430\u0442\u044c \u0432 \u043f+\u043e\u043b\u0434\u0435\u043d\u044c - \u044d\u0442\u043e \u043f\u043e\u043c\u043e\u0433\u0430\u0435\u0442 \u043f\u0438\u0449\u0435\u0432\u0430\u0440\u0435\u043d\u0438\u044e\",\n        )\n\n    class QuaziAct:\n        description = TextWithTTS(\"\u0432\u044b\u043a\u0438\u043d\u0443\u0442\u044c \u043c\u0443\u0441\u043e\u0440\", \"\u0432+\u044b\u043a\u0438\u043d\u0443\u0442\u044c \u043c+\u0443\u0441\u043e\u0440\")\n\n    print(msg.get_start_message_intro(datetime.datetime.now()))\n    print()\n    print(msg.get_start_message_comeback(datetime.datetime.now(), 42, 26))\n    print()\n    print(msg.get_menu_welcome_message())\n    print()\n    print(msg.get_info_message())\n    print()\n    print(msg.get_ask_tip_topic_message())\n    print()\n    print(\n        msg.get_propose_yesterday_wake_up_time_message(\n            datetime.datetime.now().time()\n        )\n    )\n    print()\n    print(msg.get_ask_wake_up_time_message())\n    print()\n    print(msg.get_ask_sleep_mode_message())\n    print()\n    print(msg.get_tip_message(QuaziTip()))\n    print()\n    print(\n        msg.get_sleep_calc_time_message(\n            datetime.datetime.now().time(), [QuaziAct()] * 4\n        )\n    )\n    print()\n    print(msg.get_good_night_message())", ""]}
{"filename": "skill/messages/ru_messages.py", "chunked_list": ["from __future__ import annotations\n\nimport datetime\nimport random\nfrom typing import TYPE_CHECKING, List\n\nfrom skill.messages.base_messages import BaseMessages\nfrom skill.sleep_calculator import SleepMode, SleepCalculation\nfrom skill.messages.unicode_literals import DASH, LAQUO, RAQUO\nfrom skill.utils import (", "from skill.messages.unicode_literals import DASH, LAQUO, RAQUO\nfrom skill.utils import (\n    Daytime,\n    TextWithTTS,\n    construct_random_message,\n    gentle_capitalize,\n)\n\nif TYPE_CHECKING:\n    from skill.entities import Activity, Tip", "if TYPE_CHECKING:\n    from skill.entities import Activity, Tip\n\n\nclass RUMessages(BaseMessages):\n    SLEEP_MODES_NOMINATIVE = {\n        SleepMode.VERY_SHORT: \"\u041b\u0451\u0433\u043a\u0438\u0439\",\n        SleepMode.SHORT: \"\u041a\u043e\u0440\u043e\u0442\u043a\u0438\u0439\",\n        SleepMode.MEDIUM: \"\u0421\u0440\u0435\u0434\u043d\u0438\u0439\",\n        SleepMode.LONG: \"\u0414\u043b\u0438\u043d\u043d\u044b\u0439\",", "        SleepMode.MEDIUM: \"\u0421\u0440\u0435\u0434\u043d\u0438\u0439\",\n        SleepMode.LONG: \"\u0414\u043b\u0438\u043d\u043d\u044b\u0439\",\n    }\n    SLEEP_MODES_INSTRUMENTAL = {\n        SleepMode.VERY_SHORT: \"\u041b\u0451\u0433\u043a\u0438\u043c\",\n        SleepMode.SHORT: \"\u041a\u043e\u0440\u043e\u0442\u043a\u0438\u043c\",\n        SleepMode.MEDIUM: \"\u0421\u0440\u0435\u0434\u043d\u0438\u043c\",\n        SleepMode.LONG: \"\u0414\u043b\u0438\u043d\u043d\u044b\u043c\",\n    }\n", "    }\n\n    MENU_BUTTONS_TEXT = [\n        \"\u0414\u0430\u0439 \u0441\u043e\u0432\u0435\u0442\",\n        \"\u0420\u0430\u0441\u0441\u0447\u0438\u0442\u0430\u0439 \u0441\u043e\u043d\",\n        \"\u0420\u0430\u0441\u0441\u043a\u0430\u0436\u0438 \u043e \u043d\u0430\u0432\u044b\u043a\u0435\",\n        \"\u041f\u043e\u043c\u043e\u0449\u044c\",\n    ]\n    TIP_TOPIC_SELECTION_BUTTONS_TEXT = [\"\u0414\u043d\u0435\u0432\u043d\u043e\u0439 \u0441\u043e\u043d\", \"\u041d\u043e\u0447\u043d\u043e\u0439 \u0441\u043e\u043d\"]\n    SLEEP_TIME_PROPOSAL_BUTTONS_TEXT = [\"\u0414\u0430\", \"\u041d\u0435\u0442\"]", "    TIP_TOPIC_SELECTION_BUTTONS_TEXT = [\"\u0414\u043d\u0435\u0432\u043d\u043e\u0439 \u0441\u043e\u043d\", \"\u041d\u043e\u0447\u043d\u043e\u0439 \u0441\u043e\u043d\"]\n    SLEEP_TIME_PROPOSAL_BUTTONS_TEXT = [\"\u0414\u0430\", \"\u041d\u0435\u0442\"]\n    POST_SLEEP_CALCULATION_BUTTONS_TEXT = [\"\u0414\u0430\", \"\u041d\u0435\u0442\"]\n    SLEEP_MODE_SELECTION_BUTTONS_TEXT = list(SLEEP_MODES_NOMINATIVE.values())\n    HELP_BUTTONS_TEXT = [\n        \"\u041c\u0435\u043d\u044e\",\n        \"\u042f \u0445\u043e\u0447\u0443 \u0441\u043f\u0430\u0442\u044c\",\n        \"\u0414\u0430\u0439 \u0441\u043e\u0432\u0435\u0442\",\n        \"\u0420\u0430\u0441\u0441\u043a\u0430\u0436\u0438 \u043e \u043d\u0430\u0432\u044b\u043a\u0435\",\n        \"\u0412\u044b\u0445\u043e\u0434\",", "        \"\u0420\u0430\u0441\u0441\u043a\u0430\u0436\u0438 \u043e \u043d\u0430\u0432\u044b\u043a\u0435\",\n        \"\u0412\u044b\u0445\u043e\u0434\",\n    ]\n\n    def __init__(self):\n        pass\n\n    def get_sleep_form_message(self) -> TextWithTTS:\n        return TextWithTTS(\n            f\"\u0421\u043a\u0430\u0436\u0438\u0442\u0435 \u0432\u043e \u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0432\u044b \u0445\u043e\u0442\u0438\u0442\u0435 \u0432\u0441\u0442\u0430\u0442\u044c \u043f\u043e \u0444\u043e\u0440\u043c\u0435 {LAQUO}\u0412 12:12{RAQUO}\"", "        return TextWithTTS(\n            f\"\u0421\u043a\u0430\u0436\u0438\u0442\u0435 \u0432\u043e \u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0432\u044b \u0445\u043e\u0442\u0438\u0442\u0435 \u0432\u0441\u0442\u0430\u0442\u044c \u043f\u043e \u0444\u043e\u0440\u043c\u0435 {LAQUO}\u0412 12:12{RAQUO}\"\n        )\n\n    def get_start_message_intro(self, time: datetime.datetime) -> TextWithTTS:\n        daytime = Daytime.from_time(time)\n        greeting = TextWithTTS(\"\u0417\u0434\u0440\u0430\u0432\u0441\u0442\u0432\u0443\u0439\u0442\u0435!\")\n        match daytime:\n            case Daytime.DAY:\n                greeting = TextWithTTS(\"\u0414\u043e\u0431\u0440\u044b\u0439 \u0434\u0435\u043d\u044c!\")", "            case Daytime.DAY:\n                greeting = TextWithTTS(\"\u0414\u043e\u0431\u0440\u044b\u0439 \u0434\u0435\u043d\u044c!\")\n            case Daytime.MORNING:\n                greeting = TextWithTTS(\"\u0414\u043e\u0431\u0440\u043e\u0435 \u0443\u0442\u0440\u043e!\")\n            case Daytime.EVENING:\n                greeting = TextWithTTS(\"\u0414\u043e\u0431\u0440\u044b\u0439 \u0432\u0435\u0447\u0435\u0440!\")\n            case Daytime.NIGHT:\n                greeting = TextWithTTS(\"\u0414\u043e\u0431\u0440\u043e\u0439 \u043d\u043e\u0447\u0438!\")\n\n        intro = TextWithTTS(", "\n        intro = TextWithTTS(\n            f\"\u042f {DASH} \u0421\u043e\u043d\u043d\u044b\u0439 \u041f\u043e\u043c\u043e\u0449\u043d\u0438\u043a. \u042f \u043f\u043e\u043c\u043e\u0433\u0430\u044e \u0432\u0430\u043c \u043e\u0440\u0433\u0430\u043d\u0438\u0437\u043e\u0432\u0430\u0442\u044c\" \" \u0432\u0430\u0448 \u0441\u043e\u043d.\"\n        )\n\n        man = TextWithTTS(\n            \"\u0412\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u043f\u043e\u043f\u0440\u043e\u0441\u0438\u0442\u044c \u043c\u0435\u043d\u044f \u0440\u0430\u0441\u0441\u0447\u0438\u0442\u0430\u0442\u044c \u043e\u043f\u0442\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u0434\u043b\u044f \"\n            \"\u0432\u0430\u0441 \u0432\u0440\u0435\u043c\u044f \u0441\u043d\u0430, \u0437\u0430 \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u0432\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u0432\u044b\u0441\u043f\u0430\u0442\u044c\u0441\u044f. \"\n            f\"\u0414\u043b\u044f \u044d\u0442\u043e\u0433\u043e \u0441\u043a\u0430\u0436\u0438\u0442\u0435 {LAQUO}\u042f \u0445\u043e\u0447\u0443 \u0441\u043f\u0430\u0442\u044c{RAQUO}. \"\n            \"\u0410 \u0435\u0449\u0451 \u0432\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u043f\u043e\u043f\u0440\u043e\u0441\u0438\u0442\u044c \u043c\u0435\u043d\u044f \u0434\u0430\u0442\u044c \u0432\u0430\u043c \u043f\u0430\u0440\u0443 \"", "            f\"\u0414\u043b\u044f \u044d\u0442\u043e\u0433\u043e \u0441\u043a\u0430\u0436\u0438\u0442\u0435 {LAQUO}\u042f \u0445\u043e\u0447\u0443 \u0441\u043f\u0430\u0442\u044c{RAQUO}. \"\n            \"\u0410 \u0435\u0449\u0451 \u0432\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u043f\u043e\u043f\u0440\u043e\u0441\u0438\u0442\u044c \u043c\u0435\u043d\u044f \u0434\u0430\u0442\u044c \u0432\u0430\u043c \u043f\u0430\u0440\u0443 \"\n            \"\u0441\u043e\u0432\u0435\u0442\u043e\u0432 \u043f\u043e \u0442\u043e\u043c\u0443, \u043a\u0430\u043a \u043b\u0443\u0447\u0448\u0435 \u0432\u044b\u0441\u044b\u043f\u0430\u0442\u044c\u0441\u044f. \u0427\u0442\u043e\u0431\u044b \u0432\u044b\u0439\u0442\u0438 \u0438\u0437 \u043d\u0430\u0432\u043a\u0430,\"\n            \" \u0441\u043a\u0430\u0436\u0438\u0442\u0435 \u00ab\u0412\u044b\u0445\u043e\u0434\u00bb. \"\n        )\n\n        replicas_tail = [\n            TextWithTTS(\"\u0427\u0435\u043c \u044f \u043c\u043e\u0433\u0443 \u043f\u043e\u043c\u043e\u0447\u044c?\"),\n            TextWithTTS(\"\u0427\u0435\u043c \u043c\u043e\u0433\u0443 \u043f\u043e\u043c\u043e\u0447\u044c?\"),\n            TextWithTTS(\"\u0427\u0435\u043c \u043c\u043e\u0433\u0443 \u0431\u044b\u0442\u044c \u043f\u043e\u043b\u0435\u0437\u043d\u0430?\"),", "            TextWithTTS(\"\u0427\u0435\u043c \u043c\u043e\u0433\u0443 \u043f\u043e\u043c\u043e\u0447\u044c?\"),\n            TextWithTTS(\"\u0427\u0435\u043c \u043c\u043e\u0433\u0443 \u0431\u044b\u0442\u044c \u043f\u043e\u043b\u0435\u0437\u043d\u0430?\"),\n            TextWithTTS(\"\u042f \u043a \u0432\u0430\u0448\u0438\u043c \u0443\u0441\u043b\u0443\u0433\u0430\u043c.\"),\n        ]\n\n        message = TextWithTTS(\" \").join(\n            (greeting, intro, man, random.choice(replicas_tail))\n        )\n\n        return message", "\n        return message\n\n    def get_start_message_comeback(\n        self, time: datetime.datetime, streak: int, scoreboard: int\n    ) -> TextWithTTS:\n        daytime = Daytime.from_time(time)\n        greeting = TextWithTTS(\"\u0417\u0434\u0440\u0430\u0432\u0441\u0442\u0432\u0443\u0439\u0442\u0435! \")\n        match daytime:\n            case Daytime.DAY:", "        match daytime:\n            case Daytime.DAY:\n                greeting = TextWithTTS(\"\u0414\u043e\u0431\u0440\u044b\u0439 \u0434\u0435\u043d\u044c! \")\n            case Daytime.MORNING:\n                greeting = TextWithTTS(\"\u0414\u043e\u0431\u0440\u043e\u0435 \u0443\u0442\u0440\u043e! \")\n            case Daytime.EVENING:\n                greeting = TextWithTTS(\"\u0414\u043e\u0431\u0440\u044b\u0439 \u0432\u0435\u0447\u0435\u0440! \")\n            case Daytime.NIGHT:\n                greeting = TextWithTTS(\"\u0414\u043e\u0431\u0440\u043e\u0439 \u043d\u043e\u0447\u0438! \")\n", "                greeting = TextWithTTS(\"\u0414\u043e\u0431\u0440\u043e\u0439 \u043d\u043e\u0447\u0438! \")\n\n        message = greeting\n\n        if streak > 1:\n            praise = TextWithTTS(\n                f\"\u0421\u0435\u0433\u043e\u0434\u043d\u044f \u0432\u044b \u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0435\u0441\u044c \u0421\u043e\u043d\u043d\u044b\u043c \u041f\u043e\u043c\u043e\u0449\u043d\u0438\u043a\u043e\u043c {streak}\" \" \u0434\u0435\u043d\u044c \u043f\u043e\u0434\u0440\u044f\u0434. \"\n            )\n            replicas_insert = [\n                TextWithTTS(\"\u0422\u0430\u043a \u0434\u0435\u0440\u0436\u0430\u0442\u044c!\"),", "            replicas_insert = [\n                TextWithTTS(\"\u0422\u0430\u043a \u0434\u0435\u0440\u0436\u0430\u0442\u044c!\"),\n                TextWithTTS(\"\u0417\u0430\u043c\u0435\u0447\u0430\u0442\u0435\u043b\u044c\u043d\u043e!\"),\n                TextWithTTS(\"\u0417\u0434\u043e\u0440\u043e\u0432\u043e!\"),\n                TextWithTTS(\"\u0423\u0440\u0430!\"),\n                TextWithTTS(\"\u041f\u0440\u0435\u043a\u0440\u0430\u0441\u043d\u043e!\"),\n                TextWithTTS(\"\u041f\u0440\u043e\u0434\u043e\u043b\u0436\u0430\u0439\u0442\u0435 \u0432 \u0442\u043e\u043c \u0436\u0435 \u0434\u0443\u0445\u0435!\"),\n            ]\n            praise += random.choice(replicas_insert)\n            praise += TextWithTTS(f\" \u0412\u044b \u0441\u043f\u0438\u0442\u0435 \u043b\u0443\u0447\u0448\u0435, \u0447\u0435\u043c {scoreboard}% \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u0439! \")", "            praise += random.choice(replicas_insert)\n            praise += TextWithTTS(f\" \u0412\u044b \u0441\u043f\u0438\u0442\u0435 \u043b\u0443\u0447\u0448\u0435, \u0447\u0435\u043c {scoreboard}% \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u0439! \")\n\n            message += praise\n\n        man = TextWithTTS(\n            \"\u0412\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u043f\u043e\u043f\u0440\u043e\u0441\u0438\u0442\u044c \u043c\u0435\u043d\u044f \u0440\u0430\u0441\u0441\u0447\u0438\u0442\u0430\u0442\u044c \u043e\u043f\u0442\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u0434\u043b\u044f \"\n            \"\u0432\u0430\u0441 \u0432\u0440\u0435\u043c\u044f \u0441\u043d\u0430, \u0437\u0430 \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u0432\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u0432\u044b\u0441\u043f\u0430\u0442\u044c\u0441\u044f. \"\n            f\"\u0414\u043b\u044f \u044d\u0442\u043e\u0433\u043e \u0441\u043a\u0430\u0436\u0438\u0442\u0435 {LAQUO}\u042f \u0445\u043e\u0447\u0443 \u0441\u043f\u0430\u0442\u044c{RAQUO}. \"\n            \"\u0410 \u0435\u0449\u0451 \u0432\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u043f\u043e\u043f\u0440\u043e\u0441\u0438\u0442\u044c \u043c\u0435\u043d\u044f \u0434\u0430\u0442\u044c \u0432\u0430\u043c \u043f\u0430\u0440\u0443 \"", "            f\"\u0414\u043b\u044f \u044d\u0442\u043e\u0433\u043e \u0441\u043a\u0430\u0436\u0438\u0442\u0435 {LAQUO}\u042f \u0445\u043e\u0447\u0443 \u0441\u043f\u0430\u0442\u044c{RAQUO}. \"\n            \"\u0410 \u0435\u0449\u0451 \u0432\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u043f\u043e\u043f\u0440\u043e\u0441\u0438\u0442\u044c \u043c\u0435\u043d\u044f \u0434\u0430\u0442\u044c \u0432\u0430\u043c \u043f\u0430\u0440\u0443 \"\n            \"\u0441\u043e\u0432\u0435\u0442\u043e\u0432 \u043f\u043e \u0442\u043e\u043c\u0443, \u043a\u0430\u043a \u043b\u0443\u0447\u0448\u0435 \u0432\u044b\u0441\u044b\u043f\u0430\u0442\u044c\u0441\u044f. \u0427\u0442\u043e\u0431\u044b \u0432\u044b\u0439\u0442\u0438 \u0438\u0437 \u043d\u0430\u0432\u044b\u043a\u0430,\"\n            \" \u0441\u043a\u0430\u0436\u0438\u0442\u0435 \u00ab\u0412\u044b\u0445\u043e\u0434\u00bb. \"\n        )\n\n        message += man\n\n        replicas_tail = [\n            TextWithTTS(\"\u0427\u0435\u043c \u044f \u043c\u043e\u0433\u0443 \u043f\u043e\u043c\u043e\u0447\u044c?\"),", "        replicas_tail = [\n            TextWithTTS(\"\u0427\u0435\u043c \u044f \u043c\u043e\u0433\u0443 \u043f\u043e\u043c\u043e\u0447\u044c?\"),\n            TextWithTTS(\"\u0427\u0435\u043c \u043c\u043e\u0433\u0443 \u043f\u043e\u043c\u043e\u0447\u044c?\"),\n            TextWithTTS(\"\u0427\u0435\u043c \u043c\u043e\u0433\u0443 \u0431\u044b\u0442\u044c \u043f\u043e\u043b\u0435\u0437\u043d\u0430?\"),\n            TextWithTTS(\"\u042f \u043a \u0432\u0430\u0448\u0438\u043c \u0443\u0441\u043b\u0443\u0433\u0430\u043c.\"),\n        ]\n\n        message += random.choice(replicas_tail)\n\n        return message", "\n        return message\n\n    def get_menu_welcome_message(self) -> TextWithTTS:\n        replicas_a = [\n            TextWithTTS(\"\u0412\u044b \u043d\u0430\u0445\u043e\u0434\u0438\u0442\u0435\u0441\u044c \u0432 \u0433\u043b\u0430\u0432\u043d\u043e\u043c \u043c\u0435\u043d\u044e.\"),\n            TextWithTTS(\"\u042d\u0442\u043e \u0433\u043b\u0430\u0432\u043d\u043e\u0435 \u043c\u0435\u043d\u044e \u0421\u043e\u043d\u043d\u043e\u0433\u043e \u041f\u043e\u043c\u043e\u0449\u043d\u0438\u043a\u0430.\"),\n            TextWithTTS(\"\u0412\u044b \u0432 \u0433\u043b\u0430\u0432\u043d\u043e\u043c \u043c\u0435\u043d\u044e.\"),\n            TextWithTTS(\"\u0412\u044b \u043d\u0430\u0445\u043e\u0434\u0438\u0442\u0435\u0441\u044c \u0432 \u0433\u043b\u0430\u0432\u043d\u043e\u043c \u043c\u0435\u043d\u044e \u0421\u043e\u043d\u043d\u043e\u0433\u043e \u041f\u043e\u043c\u043e\u0449\u043d\u0438\u043a\u0430.\"),\n        ]", "            TextWithTTS(\"\u0412\u044b \u043d\u0430\u0445\u043e\u0434\u0438\u0442\u0435\u0441\u044c \u0432 \u0433\u043b\u0430\u0432\u043d\u043e\u043c \u043c\u0435\u043d\u044e \u0421\u043e\u043d\u043d\u043e\u0433\u043e \u041f\u043e\u043c\u043e\u0449\u043d\u0438\u043a\u0430.\"),\n        ]\n\n        replicas_b = [\n            TextWithTTS(\n                f\"\u0421\u043a\u0430\u0436\u0438\u0442\u0435 {LAQUO}\u041f\u043e\u043c\u043e\u0449\u044c{RAQUO}, \u0447\u0442\u043e\u0431\u044b \u0443\u0437\u043d\u0430\u0442\u044c \u043e \" \"\u0444\u0443\u043d\u043a\u0446\u0438\u044f\u0445 \u043d\u0430\u0432\u044b\u043a\u0430.\"\n            )\n        ]\n\n        replicas_c = [", "\n        replicas_c = [\n            TextWithTTS(\"\u0427\u0435\u043c \u044f \u043c\u043e\u0433\u0443 \u043f\u043e\u043c\u043e\u0447\u044c?\"),\n            TextWithTTS(\"\u0427\u0435\u043c \u043c\u043e\u0433\u0443 \u0431\u044b\u0442\u044c \u043f\u043e\u043b\u0435\u0437\u043d\u0430?\"),\n            TextWithTTS(\"\u042f \u043a \u0432\u0430\u0448\u0438\u043c \u0443\u0441\u043b\u0443\u0433\u0430\u043c.\"),\n            TextWithTTS(\"\u0427\u0442\u043e \u0443\u0433\u043e\u0434\u043d\u043e, \u043b\u0438\u0448\u044c \u0431\u044b \u0432\u044b \u0441\u043f\u0430\u043b\u0438 \u0445\u043e\u0440\u043e\u0448\u043e.\"),\n            # NOTE:      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Informal\n        ]\n\n        message = construct_random_message(replicas_a, replicas_b, replicas_c)", "\n        message = construct_random_message(replicas_a, replicas_b, replicas_c)\n\n        return message\n\n    def get_info_message(self) -> TextWithTTS:\n        replicas_a = [\n            TextWithTTS(\n                f\"\u042f {DASH} \u0421\u043e\u043d\u043d\u044b\u0439 \u041f\u043e\u043c\u043e\u0449\u043d\u0438\u043a.\"\n                \" \u042f \u043c\u043e\u0433\u0443 \u043f\u043e\u043c\u043e\u0447\u044c \u043b\u044e\u0434\u044f\u043c, \u0438\u0441\u043f\u044b\u0442\u044b\u0432\u0430\u044e\u0449\u0438\u043c \u043f\u0440\u043e\u0431\u043b\u0435\u043c\u044b \u0441\u043e \u0441\u043d\u043e\u043c.\"", "                f\"\u042f {DASH} \u0421\u043e\u043d\u043d\u044b\u0439 \u041f\u043e\u043c\u043e\u0449\u043d\u0438\u043a.\"\n                \" \u042f \u043c\u043e\u0433\u0443 \u043f\u043e\u043c\u043e\u0447\u044c \u043b\u044e\u0434\u044f\u043c, \u0438\u0441\u043f\u044b\u0442\u044b\u0432\u0430\u044e\u0449\u0438\u043c \u043f\u0440\u043e\u0431\u043b\u0435\u043c\u044b \u0441\u043e \u0441\u043d\u043e\u043c.\"\n            ),\n            TextWithTTS(\n                f\"\u042f {DASH} \u0421\u043e\u043d\u043d\u044b\u0439 \u041f\u043e\u043c\u043e\u0449\u043d\u0438\u043a. \u042f \u043f\u043e\u043c\u043e\u0433\u0430\u044e \u043b\u044e\u0434\u044f\u043c, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u0445\u043e\u0442\u044f\u0442\"\n                \" \u043e\u0440\u0433\u0430\u043d\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0441\u0432\u043e\u0439 \u0441\u043e\u043d.\"\n            ),\n            TextWithTTS(\n                f\"\u042f {DASH} \u0421\u043e\u043d\u043d\u044b\u0439 \u041f\u043e\u043c\u043e\u0449\u043d\u0438\u043a. \u041c\u043e\u044f \u0446\u0435\u043b\u044c {DASH} \u043f\u043e\u043c\u043e\u0447\u044c\"\n                \" \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0442\u044c \u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u044b\u0439 \u0437\u0434\u043e\u0440\u043e\u0432\u044b\u0439 \u0441\u043e\u043d \u0442\u0435\u043c, \u043a\u043e\u043c\u0443 \u044d\u0442\u043e\u0433\u043e \u043d\u0435\"", "                f\"\u042f {DASH} \u0421\u043e\u043d\u043d\u044b\u0439 \u041f\u043e\u043c\u043e\u0449\u043d\u0438\u043a. \u041c\u043e\u044f \u0446\u0435\u043b\u044c {DASH} \u043f\u043e\u043c\u043e\u0447\u044c\"\n                \" \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0442\u044c \u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u044b\u0439 \u0437\u0434\u043e\u0440\u043e\u0432\u044b\u0439 \u0441\u043e\u043d \u0442\u0435\u043c, \u043a\u043e\u043c\u0443 \u044d\u0442\u043e\u0433\u043e \u043d\u0435\"\n                \" \u0445\u0432\u0430\u0442\u0430\u043b\u043e.\"\n            ),\n            TextWithTTS(\n                f\"\u042f {DASH} \u0421\u043e\u043d\u043d\u044b\u0439 \u041f\u043e\u043c\u043e\u0449\u043d\u0438\u043a. \u041c\u043e\u044f \u0446\u0435\u043b\u044c {DASH} \u043f\u043e\u043c\u043e\u0447\u044c\"\n                \" \u043d\u0435\u0432\u044b\u0441\u043f\u0430\u0432\u0448\u0438\u043c\u0441\u044f \u043b\u044e\u0434\u044f\u043c \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0442\u044c\"\n                \" \u0441\u0435\u0431\u0435 \u0445\u043e\u0440\u043e\u0448\u0438\u0439 \u043a\u043e\u043c\u0444\u043e\u0440\u0442\u043d\u044b\u0439 \u0441\u043e\u043d.\"\n            ),\n            TextWithTTS(", "            ),\n            TextWithTTS(\n                f\"\u042f {DASH} \u0421\u043e\u043d\u043d\u044b\u0439 \u041f\u043e\u043c\u043e\u0449\u043d\u0438\u043a, \u044f \u043c\u043e\u0433\u0443 \u043f\u043e\u043c\u043e\u0447\u044c \u043b\u0443\u0447\u0448\u0435 \u0441\u043f\u0430\u0442\u044c \u0442\u0435\u043c,\"\n                \" \u043a\u0442\u043e \u0438\u0441\u043f\u044b\u0442\u044b\u0432\u0430\u0435\u0442 \u0441 \u044d\u0442\u0438\u043c \u043f\u0440\u043e\u0431\u043b\u0435\u043c\u044b.\"\n            ),\n            TextWithTTS(\n                f\"\u042f {DASH} \u0421\u043e\u043d\u043d\u044b\u0439 \u041f\u043e\u043c\u043e\u0449\u043d\u0438\u043a, \u044f \u043c\u043e\u0433\u0443 \u043f\u043e\u043c\u043e\u0447\u044c \u0432\u0430\u043c \u0432\u044b\u0441\u044b\u043f\u0430\u0442\u044c\u0441\u044f,\"\n                \" \u0435\u0441\u043b\u0438 \u0443 \u0432\u0430\u0441 \u0435\u0441\u0442\u044c \u043f\u0440\u043e\u0431\u043b\u0435\u043c\u044b \u0441\u043e \u0441\u043d\u043e\u043c.\"\n            ),\n        ]", "            ),\n        ]\n\n        replicas_b = [\n            TextWithTTS(\n                \"\u0412\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u043f\u043e\u043f\u0440\u043e\u0441\u0438\u0442\u044c \u043c\u0435\u043d\u044f \u0440\u0430\u0441\u0441\u0447\u0438\u0442\u0430\u0442\u044c \u043e\u043f\u0442\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u0434\u043b\u044f \"\n                \"\u0432\u0430\u0441 \u0432\u0440\u0435\u043c\u044f \u0441\u043d\u0430, \u0437\u0430 \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u0432\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u0432\u044b\u0441\u043f\u0430\u0442\u044c\u0441\u044f.\"\n            ),\n            TextWithTTS(\n                \"\u042f \u043c\u043e\u0433\u0443 \u0440\u0430\u0441\u0441\u0447\u0438\u0442\u0430\u0442\u044c \u0434\u043b\u044f \u0432\u0430\u0441 \u043e\u043f\u0442\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \"", "            TextWithTTS(\n                \"\u042f \u043c\u043e\u0433\u0443 \u0440\u0430\u0441\u0441\u0447\u0438\u0442\u0430\u0442\u044c \u0434\u043b\u044f \u0432\u0430\u0441 \u043e\u043f\u0442\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \"\n                \"\u0432\u0440\u0435\u043c\u044f \u0441\u043d\u0430, \u0437\u0430 \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u0432\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u0432\u044b\u0441\u043f\u0430\u0442\u044c\u0441\u044f.\"\n            ),\n            TextWithTTS(\n                \"\u0421 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u043c\u0435\u043d\u044f, \u0432\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u0443\u0437\u043d\u0430\u0442\u044c, \u0432\u043e \u0441\u043a\u043e\u043b\u044c\u043a\u043e \"\n                \"\u0432\u0430\u043c \u0441\u0442\u043e\u0438\u0442 \u0441\u0435\u0433\u043e\u0434\u043d\u044f \u043b\u0435\u0447\u044c, \u0447\u0442\u043e\u0431\u044b \u0432\u044b\u0441\u043f\u0430\u0442\u044c\u0441\u044f.\"\n            ),\n            TextWithTTS(\n                \"\u042f \u043c\u043e\u0433\u0443 \u043f\u043e\u043c\u043e\u0447\u044c \u0432\u0430\u043c \u043f\u043e\u0434\u043e\u0431\u0440\u0430\u0442\u044c \u043f\u043e\u0434\u0445\u043e\u0434\u044f\u0449\u0435\u0435 \u0434\u043b\u044f \u0432\u0430\u0441 \"", "            TextWithTTS(\n                \"\u042f \u043c\u043e\u0433\u0443 \u043f\u043e\u043c\u043e\u0447\u044c \u0432\u0430\u043c \u043f\u043e\u0434\u043e\u0431\u0440\u0430\u0442\u044c \u043f\u043e\u0434\u0445\u043e\u0434\u044f\u0449\u0435\u0435 \u0434\u043b\u044f \u0432\u0430\u0441 \"\n                \"\u0432\u0440\u0435\u043c\u044f \u0441\u043d\u0430, \u0447\u0442\u043e\u0431\u044b \u0432\u044b \u0441\u043c\u043e\u0433\u043b\u0438 \u0432\u044b\u0441\u043f\u0430\u0442\u044c\u0441\u044f.\"\n            ),\n        ]\n\n        replicas_c = [\n            TextWithTTS(f\"\u0414\u043b\u044f \u044d\u0442\u043e\u0433\u043e \u0441\u043a\u0430\u0436\u0438\u0442\u0435 {LAQUO}\u042f \u0445\u043e\u0447\u0443 \u0441\u043f\u0430\u0442\u044c{RAQUO}.\"),\n            TextWithTTS(\n                \"\u0427\u0442\u043e\u0431\u044b \u0432\u044b\u0437\u0432\u0430\u0442\u044c \u044d\u0442\u0443 \u0444\u0443\u043d\u043a\u0446\u0438\u044e, \u0441\u043a\u0430\u0436\u0438\u0442e \" f\"{LAQUO}\u042f \u0445\u043e\u0447\u0443 \u0441\u043f\u0430\u0442\u044c{RAQUO}.\"", "            TextWithTTS(\n                \"\u0427\u0442\u043e\u0431\u044b \u0432\u044b\u0437\u0432\u0430\u0442\u044c \u044d\u0442\u0443 \u0444\u0443\u043d\u043a\u0446\u0438\u044e, \u0441\u043a\u0430\u0436\u0438\u0442e \" f\"{LAQUO}\u042f \u0445\u043e\u0447\u0443 \u0441\u043f\u0430\u0442\u044c{RAQUO}.\"\n            ),\n        ]\n\n        replicas_d = [\n            TextWithTTS(\n                \"\u0410 \u0435\u0449\u0451 \u0432\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u043f\u043e\u043f\u0440\u043e\u0441\u0438\u0442\u044c \u0443 \u043c\u0435\u043d\u044f \u0441\u043e\u0432\u0435\u0442 \u043f\u043e \u0442\u043e\u043c\u0443, \" \"\u043a\u0430\u043a \u043b\u0443\u0447\u0448\u0435 \u0441\u043f\u0430\u0442\u044c.\"\n            ),\n            TextWithTTS(", "            ),\n            TextWithTTS(\n                \"\u0418\u043b\u0438 \u0432\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u043f\u043e\u043f\u0440\u043e\u0441\u0438\u0442\u044c \u0443 \u043c\u0435\u043d\u044f \u0441\u043e\u0432\u0435\u0442 \u043f\u043e \u0442\u043e\u043c\u0443, \" \"\u043a\u0430\u043a \u043b\u0443\u0447\u0448\u0435 \u0441\u043f\u0430\u0442\u044c.\"\n            ),\n            TextWithTTS(\"\u0410 \u0435\u0449\u0451 \u044f \u043c\u043e\u0433\u0443 \u043f\u043e\u0434\u0435\u043b\u0438\u0442\u044c\u0441\u044f \u0441\u043e\u0432\u0435\u0442\u043e\u043c \u043f\u043e \u0437\u0434\u043e\u0440\u043e\u0432\u043e\u043c\u0443 \u0441\u043d\u0443.\"),\n            TextWithTTS(\n                \"\u0410 \u0435\u0449\u0451 \u044f \u043c\u043e\u0433\u0443 \u0434\u0430\u0442\u044c \u0432\u0430\u043c \u043d\u0435\u0431\u043e\u043b\u044c\u0448\u043e\u0439 \u0441\u043e\u0432\u0435\u0442 \u043f\u043e \"\n                \"\u0438\u043d\u0442\u0435\u0440\u0435\u0441\u0443\u044e\u0449\u0435\u043c\u0443 \u0432\u0430\u0441 \u0432\u0438\u0434\u0443 \u0441\u043d\u0430.\"\n            ),\n            TextWithTTS(", "            ),\n            TextWithTTS(\n                \"\u0415\u0449\u0451 \u044f \u043c\u043e\u0433\u0443 \u0434\u0430\u0442\u044c \u0432\u0430\u043c \u043f\u0430\u0440\u0443 \u0441\u043e\u0432\u0435\u0442\u043e\u0432 \u043f\u043e \u0443\u043b\u0443\u0447\u0448\u0435\u043d\u0438\u044e \" \"\u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0430 \u0432\u0430\u0448\u0435\u0433\u043e \u0441\u043d\u0430.\"\n            ),\n            TextWithTTS(\n                \"\u0410 \u0435\u0449\u0451 \u044f \u043c\u043e\u0433\u0443 \u0434\u0430\u0442\u044c \u0432\u0430\u043c \u043f\u0430\u0440\u0443 \u0441\u043e\u0432\u0435\u0442\u043e\u0432 \u043f\u043e \u0442\u043e\u043c\u0443, \" \"\u043a\u0430\u043a \u0432\u044b\u0441\u044b\u043f\u0430\u0442\u044c\u0441\u044f.\"\n            ),\n        ]\n\n        message = construct_random_message(", "\n        message = construct_random_message(\n            replicas_a, replicas_b, replicas_c, replicas_d\n        )\n\n        return message\n\n    def get_ask_tip_topic_message(self) -> TextWithTTS:\n        replicas = [\n            TextWithTTS(\"\u0412\u0430\u0441 \u0438\u043d\u0442\u0435\u0440\u0435\u0441\u0443\u0435\u0442 \u0441\u043e\u0432\u0435\u0442 \u043f\u043e \u0434\u043d\u0435\u0432\u043d\u043e\u043c\u0443 \u0438\u043b\u0438 \u043d\u043e\u0447\u043d\u043e\u043c\u0443 \u0441\u043d\u0443? \"),", "        replicas = [\n            TextWithTTS(\"\u0412\u0430\u0441 \u0438\u043d\u0442\u0435\u0440\u0435\u0441\u0443\u0435\u0442 \u0441\u043e\u0432\u0435\u0442 \u043f\u043e \u0434\u043d\u0435\u0432\u043d\u043e\u043c\u0443 \u0438\u043b\u0438 \u043d\u043e\u0447\u043d\u043e\u043c\u0443 \u0441\u043d\u0443? \"),\n            TextWithTTS(\n                \"\u041f\u043e \u043a\u0430\u043a\u043e\u043c\u0443 \u0441\u043d\u0443 \u0432\u044b \u0445\u043e\u0442\u0438\u0442\u0435 \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0441\u043e\u0432\u0435\u0442, \u0434\u043d\u0435\u0432\u043d\u043e\u043c\u0443, \" \"\u0438\u043b\u0438 \u043d\u043e\u0447\u043d\u043e\u043c\u0443? \"\n            ),\n            TextWithTTS(\n                \"\u042f \u043c\u043e\u0433\u0443 \u0434\u0430\u0442\u044c \u0432\u0430\u043c \u0441\u043e\u0432\u0435\u0442 \u043f\u043e \u0434\u043d\u0435\u0432\u043d\u043e\u043c\u0443 \u0438\u043b\u0438 \u043d\u043e\u0447\u043d\u043e\u043c\u0443 \u0441\u043d\u0443. \"\n                \"\u041a\u0430\u043a\u043e\u0439 \u0441\u043e\u043d \u0432\u0430\u0441 \u0438\u043d\u0442\u0435\u0440\u0435\u0441\u0443\u0435\u0442? \"\n            ),\n            TextWithTTS(", "            ),\n            TextWithTTS(\n                \"\u0421 \u043a\u0430\u043a\u0438\u043c \u0441\u043d\u043e\u043c \u0432\u0430\u043c \u043d\u0443\u0436\u043d\u0430 \u043f\u043e\u043c\u043e\u0449\u044c? \u0421 \u0434\u043d\u0435\u0432\u043d\u044b\u043c \u0438\u043b\u0438 \u043d\u043e\u0447\u043d\u044b\u043c? \"\n            ),\n            TextWithTTS(\"\u0412\u0430\u043c \u043d\u0443\u0436\u043d\u0430 \u043f\u043e\u043c\u043e\u0449\u044c \u043f\u043e \u0434\u043d\u0435\u0432\u043d\u043e\u043c\u0443 \u0438\u043b\u0438 \u043d\u043e\u0447\u043d\u043e\u043c\u0443 \u0441\u043d\u0443? \"),\n        ]\n        info = TextWithTTS(\n            \"\u0414\u043d\u0435\u0432\u043d\u043e\u0439 \u0441\u043e\u043d \u2014 \u043e\u0431\u044b\u0447\u043d\u043e, \u043a\u043e\u0440\u043e\u0442\u043a\u0438\u0439 \u043f\u0435\u0440\u0435\u0440\u044b\u0432 \u043e\u0442 \"\n            \"\u0440\u0443\u0442\u0438\u043d\u044b, \u0441\u043f\u043e\u0441\u043e\u0431 \u0441\u043d\u044f\u0442\u044c \u043d\u0430\u043a\u043e\u043f\u0438\u0432\u0448\u0443\u044e\u0441\u044f \u0443\u0441\u0442\u0430\u043b\u043e\u0441\u0442\u044c. \u041d\u043e\u0447\u043d\u043e\u0439 \u0441\u043e\u043d \u2014\"\n            \" \u043f\u0440\u043e\u0434\u043e\u043b\u0436\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0439 \u043e\u0442\u0434\u044b\u0445 \u043e\u0440\u0433\u0430\u043d\u0438\u0437\u043c\u0430 \u043f\u043e\u0441\u043b\u0435 \u0431\u043e\u0434\u0440\u043e\u0432\u0441\u0442\u0432\u043e\u0432\u0430\u043d\u0438\u044f, \"", "            \"\u0440\u0443\u0442\u0438\u043d\u044b, \u0441\u043f\u043e\u0441\u043e\u0431 \u0441\u043d\u044f\u0442\u044c \u043d\u0430\u043a\u043e\u043f\u0438\u0432\u0448\u0443\u044e\u0441\u044f \u0443\u0441\u0442\u0430\u043b\u043e\u0441\u0442\u044c. \u041d\u043e\u0447\u043d\u043e\u0439 \u0441\u043e\u043d \u2014\"\n            \" \u043f\u0440\u043e\u0434\u043e\u043b\u0436\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0439 \u043e\u0442\u0434\u044b\u0445 \u043e\u0440\u0433\u0430\u043d\u0438\u0437\u043c\u0430 \u043f\u043e\u0441\u043b\u0435 \u0431\u043e\u0434\u0440\u043e\u0432\u0441\u0442\u0432\u043e\u0432\u0430\u043d\u0438\u044f, \"\n            \"\u043f\u043e\u0434\u0440\u0430\u0437\u0443\u043c\u0435\u0432\u0430\u044e\u0449\u0438\u0439 \u0441\u043e\u0431\u043b\u044e\u0434\u0435\u043d\u0438\u0435 \u0440\u0435\u0433\u0443\u043b\u044f\u0440\u043d\u043e\u0433\u043e \u0440\u0435\u0436\u0438\u043c\u0430.\"\n        )\n        # NOTE: Tip topic options are currently hardcoded.\n        #       This may cause issues if new tip topics\n        #       are planned to be added in the future.\n        return random.choice(replicas) + info\n\n    def get_tip_message(self, tip: Tip) -> TextWithTTS:", "\n    def get_tip_message(self, tip: Tip) -> TextWithTTS:\n        return tip.tip_content.transform(gentle_capitalize)\n\n    def get_propose_yesterday_wake_up_time_message(\n        self, last_time: datetime.time\n    ) -> TextWithTTS:\n        return TextWithTTS(\n            text=\"\u0412\u044b \u0445\u043e\u0442\u0438\u0442\u0435 \u0437\u0430\u0432\u0442\u0440\u0430 \u0432\u0441\u0442\u0430\u0442\u044c \u043a\u0430\u043a \u0432 \u043f\u0440\u043e\u0448\u043b\u044b\u0439 \u0440\u0430\u0437,\"\n            f\" \u0432 {last_time.isoformat(timespec='minutes')}?\"", "            text=\"\u0412\u044b \u0445\u043e\u0442\u0438\u0442\u0435 \u0437\u0430\u0432\u0442\u0440\u0430 \u0432\u0441\u0442\u0430\u0442\u044c \u043a\u0430\u043a \u0432 \u043f\u0440\u043e\u0448\u043b\u044b\u0439 \u0440\u0430\u0437,\"\n            f\" \u0432 {last_time.isoformat(timespec='minutes')}?\"\n        )\n\n    def get_ask_wake_up_time_message(self) -> TextWithTTS:\n        return TextWithTTS(text=\"\u0412\u043e \u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0432\u044b \u0445\u043e\u0442\u0438\u0442\u0435 \u0437\u0430\u0432\u0442\u0440\u0430 \u043f\u0440\u043e\u0441\u043d\u0443\u0442\u044c\u0441\u044f?\")\n\n    def get_ask_sleep_mode_message(self) -> TextWithTTS:\n        message = TextWithTTS(\n            \"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043e\u0434\u0438\u043d \u0438\u0437 \u0440\u0435\u0436\u0438\u043c\u043e\u0432 \u0441\u043d\u0430:\\n\",", "        message = TextWithTTS(\n            \"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043e\u0434\u0438\u043d \u0438\u0437 \u0440\u0435\u0436\u0438\u043c\u043e\u0432 \u0441\u043d\u0430:\\n\",\n            \"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043e\u0434\u0438\u043d \u0438\u0437 \u0440\u0435\u0436\u0438\u043c\u043e\u0432 \u0441\u043d\u0430.\\n\",\n        )\n        message += TextWithTTS(\n            f\"\u0420\u0435\u0436\u0438\u043c {LAQUO}{self.SLEEP_MODES_NOMINATIVE[SleepMode.LONG]} \"\n            f\"\u0441\u043e\u043d {RAQUO} \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0442 \u0432\u0430\u043c \u043f\u0440\u043e\u0434\u043e\u043b\u0436\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0439 \u0441\u043e\u043d \u0434\u043b\u0438\u043d\u043e\u0439 \u043e\u0442\"\n            \" 9 \u0434\u043e 12 \u0447\u0430\u0441\u043e\u0432. \u041e\u0442\u043b\u0438\u0447\u043d\u0430\u044f \u043e\u043f\u0446\u0438\u044f \u043f\u043e\u0441\u043b\u0435 \u0434\u043e\u043b\u0433\u043e\u0439 \u0431\u0435\u0441\u0441\u043e\u043d\u043d\u043e\u0439 \u043d\u0435\u0434\u0435\u043b\u0438.\\n\",\n            f\"\u0420\u0435\u0436\u0438\u043c {LAQUO}{self.SLEEP_MODES_NOMINATIVE[SleepMode.LONG]} \"\n            f\"\u0441\u043e\u043d{RAQUO} \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0442 \u0432\u0430\u043c \u043f\u0440\u043e\u0434\u043e\u043b\u0436\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0439 \u0441\u043e\u043d \u0434\u043b\u0438\u043d\u043e\u0439 \u043e\u0442\"", "            f\"\u0420\u0435\u0436\u0438\u043c {LAQUO}{self.SLEEP_MODES_NOMINATIVE[SleepMode.LONG]} \"\n            f\"\u0441\u043e\u043d{RAQUO} \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0442 \u0432\u0430\u043c \u043f\u0440\u043e\u0434\u043e\u043b\u0436\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0439 \u0441\u043e\u043d \u0434\u043b\u0438\u043d\u043e\u0439 \u043e\u0442\"\n            \" \u0434\u0435\u0432\u044f\u0442\u0438 \u0434\u043e \u0434\u0432\u0435\u043d\u0430\u0434\u0446\u0430\u0442\u0438 \u0447\u0430\u0441\u043e\u0432. \u041e\u0442\u043b\u0438\u0447\u043d\u0430\u044f \u043e\u043f\u0446\u0438\u044f \u043f\u043e\u0441\u043b\u0435 \u0434\u043e\u043b\u0433\u043e\u0439\"\n            \" \u0431\u0435\u0441\u0441\u043e\u043d\u043d\u043e\u0439 \u043d\u0435\u0434\u0435\u043b\u0438!\\n\",\n        )\n        message += TextWithTTS(\n            f\"\u0420\u0435\u0436\u0438\u043c {LAQUO}{self.SLEEP_MODES_NOMINATIVE[SleepMode.MEDIUM]} \"\n            f\"\u0441\u043e\u043d{RAQUO} \u043f\u0440\u0435\u0434\u043b\u043e\u0436\u0438\u0442 \u0432\u0430\u043c \u043a\u043b\u0430\u0441\u0441\u0438\u0447\u0435\u0441\u043a\u0438\u0439 \u0441\u043e\u043d \u0434\u043b\u0438\u043d\u043e\u0439 \u043e\u0442\"\n            \" 6 \u0434\u043e 9 \u0447\u0430\u0441\u043e\u0432.\\n\",\n            f\"\u0420\u0435\u0436\u0438\u043c {LAQUO}{self.SLEEP_MODES_NOMINATIVE[SleepMode.MEDIUM]} \"", "            \" 6 \u0434\u043e 9 \u0447\u0430\u0441\u043e\u0432.\\n\",\n            f\"\u0420\u0435\u0436\u0438\u043c {LAQUO}{self.SLEEP_MODES_NOMINATIVE[SleepMode.MEDIUM]} \"\n            f\"\u0441\u043e\u043d{RAQUO} \u043f\u0440\u0435\u0434\u043b\u043e\u0436\u0438\u0442 \u0432\u0430\u043c \u043a\u043b\u0430\u0441\u0441\u0438\u0447\u0435\u0441\u043a\u0438\u0439 \u0441\u043e\u043d \u0434\u043b\u0438\u043d\u043e\u0439 \u043e\u0442\"\n            \" \u0448\u0435\u0441\u0442\u0438 \u0434\u043e \u0434\u0435\u0432\u044f\u0442\u0438 \u0447\u0430\u0441\u043e\u0432.\\n\",\n        )\n        message += TextWithTTS(\n            \"\u0415\u0441\u043b\u0438 \u0443 \u0432\u0430\u0441 \u0435\u0449\u0451 \u043c\u043d\u043e\u0433\u043e \u0434\u0435\u043b \u043d\u0430 \u0432\u0435\u0447\u0435\u0440, \u0438\u043b\u0438 \u0432\u044b \u043d\u0435 \u0445\u043e\u0442\u0438\u0442\u0435 \u043c\u043d\u043e\u0433\u043e \u0441\u043f\u0430\u0442\u044c,\"\n            \" \u0432\u0430\u043c \u043f\u043e\u0434\u043e\u0439\u0434\u0451\u0442 \u0440\u0435\u0436\u0438\u043c \"\n            f\"{LAQUO}{self.SLEEP_MODES_NOMINATIVE[SleepMode.SHORT]} \"\n            f\"\u0441\u043e\u043d{RAQUO}. \u0412\u044b \u043f\u0440\u043e\u0441\u043f\u0438\u0442\u0435 \u043e\u0442 3 \u0434\u043e 6 \u0447\u0430\u0441\u043e\u0432.\\n\",", "            f\"{LAQUO}{self.SLEEP_MODES_NOMINATIVE[SleepMode.SHORT]} \"\n            f\"\u0441\u043e\u043d{RAQUO}. \u0412\u044b \u043f\u0440\u043e\u0441\u043f\u0438\u0442\u0435 \u043e\u0442 3 \u0434\u043e 6 \u0447\u0430\u0441\u043e\u0432.\\n\",\n            \"\u0415\u0441\u043b\u0438 \u0443 \u0432\u0430\u0441 \u0435\u0449\u0451 \u043c\u043d\u043e\u0433\u043e \u0434\u0435\u043b \u043d\u0430 \u0432\u0435\u0447\u0435\u0440, \u0438\u043b\u0438 \u0432\u044b \u043d\u0435 \u0445\u043e\u0442\u0438\u0442\u0435 \u043c\u043d\u043e\u0433\u043e \u0441\u043f\u0430\u0442\u044c,\"\n            \" \u0432\u0430\u043c \u043f\u043e\u0434\u043e\u0439\u0434\u0451\u0442 \u0440\u0435\u0436\u0438\u043c \"\n            f\"{LAQUO}{self.SLEEP_MODES_NOMINATIVE[SleepMode.SHORT]} \"\n            f\"\u0441\u043e\u043d{RAQUO}. \u0412\u044b \u043f\u0440\u043e\u0441\u043f\u0438\u0442\u0435 \u043e\u0442 \u0442\u0440\u0451\u0445 \u0434\u043e \u0448\u0435\u0441\u0442\u0438 \u0447\u0430\u0441\u043e\u0432.\\n\",\n        )\n        message += TextWithTTS(\n            \"\u0414\u043b\u044f \u043d\u0435\u0431\u043e\u043b\u044c\u0448\u043e\u0433\u043e \u0434\u043d\u0435\u0432\u043d\u043e\u0433\u043e \u043e\u0442\u0434\u044b\u0445\u0430 \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u0440\u0435\u0436\u0438\u043c \"\n            f\"{LAQUO}{self.SLEEP_MODES_NOMINATIVE[SleepMode.VERY_SHORT]} \"", "            \"\u0414\u043b\u044f \u043d\u0435\u0431\u043e\u043b\u044c\u0448\u043e\u0433\u043e \u0434\u043d\u0435\u0432\u043d\u043e\u0433\u043e \u043e\u0442\u0434\u044b\u0445\u0430 \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u0440\u0435\u0436\u0438\u043c \"\n            f\"{LAQUO}{self.SLEEP_MODES_NOMINATIVE[SleepMode.VERY_SHORT]} \"\n            f\"\u0441\u043e\u043d{RAQUO}. \u041e\u043d \u043f\u043e\u0434\u0431\u0435\u0440\u0451\u0442 \u0432\u0430\u043c \u043f\u0435\u0440\u0435\u0440\u044b\u0432 \u043e\u0442 15 \u043c\u0438\u043d\u0443\u0442 \u0434\u043e 3 \u0447\u0430\u0441\u043e\u0432.\\n\",\n            \"\u0414\u043b\u044f \u043d\u0435\u0431\u043e\u043b\u044c\u0448\u043e\u0433\u043e \u0434\u043d\u0435\u0432\u043d\u043e\u0433\u043e \u043e\u0442\u0434\u044b\u0445\u0430 \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u0440\u0435\u0436\u0438\u043c \"\n            f\"{LAQUO}{self.SLEEP_MODES_NOMINATIVE[SleepMode.VERY_SHORT]} \"\n            f\"\u0441\u043e\u043d{RAQUO}. \u041e\u043d \u043f\u043e\u0434\u0431\u0435\u0440\u0451\u0442 \u0432\u0430\u043c \u043f\u0435\u0440\u0435\u0440\u044b\u0432 \u043e\u0442 \u043f\u044f\u0442\u043d\u0430\u0434\u0446\u0430\u0442\u0438 \u043c\u0438\u043d\u0443\u0442 \u0434\u043e\"\n            \" \u0442\u0440\u0451\u0445 \u0447\u0430\u0441\u043e\u0432.\\n\",\n        )\n        return message\n", "        return message\n\n    def get_sleep_calc_time_message(\n        self,\n        sleep_calc_result: SleepCalculation,\n        activities: List[Activity],\n    ) -> TextWithTTS:\n\n        if sleep_calc_result.changed_mode:\n            selected_mode = sleep_calc_result.selected_mode", "        if sleep_calc_result.changed_mode:\n            selected_mode = sleep_calc_result.selected_mode\n            changed_mode = sleep_calc_result.changed_mode\n            bed_time = sleep_calc_result.bed_time\n            message = TextWithTTS(\n                \"\u041a \u0441\u043e\u0436\u0430\u043b\u0435\u043d\u0438\u044e, \u0437\u0430 \u044d\u0442\u043e\u0442 \u043f\u0440\u043e\u043c\u0435\u0436\u0443\u0442\u043e\u043a \u0432\u0440\u0435\u043c\u0435\u043d\u0438 \u0432\u044b \u043d\u0435 \u0443\u0441\u043f\u0435\u0432\u0430\u0435\u0442\u0435 \"\n                \"\u043f\u043e\u0441\u043f\u0430\u0442\u044c \"\n                f\"{self.SLEEP_MODES_INSTRUMENTAL[selected_mode].lower()} \"\n                \"\u0441\u043d\u043e\u043c. \u0412\u043c\u0435\u0441\u0442\u043e \u044d\u0442\u043e\u0433\u043e, \u043f\u0440\u0435\u0434\u043b\u0430\u0433\u0430\u044e \u0432\u0430\u043c \u043f\u043e\u043f\u0440\u043e\u0431\u043e\u0432\u0430\u0442\u044c \"\n                f\"{self.SLEEP_MODES_NOMINATIVE[changed_mode].lower()} \"", "                \"\u0441\u043d\u043e\u043c. \u0412\u043c\u0435\u0441\u0442\u043e \u044d\u0442\u043e\u0433\u043e, \u043f\u0440\u0435\u0434\u043b\u0430\u0433\u0430\u044e \u0432\u0430\u043c \u043f\u043e\u043f\u0440\u043e\u0431\u043e\u0432\u0430\u0442\u044c \"\n                f\"{self.SLEEP_MODES_NOMINATIVE[changed_mode].lower()} \"\n                \"\u0441\u043e\u043d \u0438 \u043b\u0435\u0447\u044c \u0432 \"\n                f\"{bed_time.hour:02d}:{bed_time.minute:02d}. \"\n                f\"\u0412\u044b \u043f\u0440\u043e\u0441\u043f\u0438\u0442\u0435 {sleep_calc_result.sleep_time.seconds // 60} \"\n                \"\u043c\u0438\u043d\u0443\u0442. \"\n            )\n        else:\n            bed_time = sleep_calc_result.bed_time\n            message = TextWithTTS(", "            bed_time = sleep_calc_result.bed_time\n            message = TextWithTTS(\n                \"\u0425\u043e\u0440\u043e\u0448\u043e, \u0440\u0435\u043a\u043e\u043c\u0435\u043d\u0434\u0443\u044e \u0432\u0430\u043c \u043b\u0435\u0447\u044c \u0432 \"\n                f\"{bed_time.hour:02d}:{bed_time.minute:02d}. \"\n                f\"\u0412\u044b \u043f\u0440\u043e\u0441\u043f\u0438\u0442\u0435 {sleep_calc_result.sleep_time.seconds // 60} \"\n                \"\u043c\u0438\u043d\u0443\u0442. \"\n            )\n        if activities:\n            message += TextWithTTS(\"\u0417\u0430 \u044d\u0442\u043e\u0442 \u0432\u0435\u0447\u0435\u0440 \u0432\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u0443\u0441\u043f\u0435\u0442\u044c, \u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, \")\n", "            message += TextWithTTS(\"\u0417\u0430 \u044d\u0442\u043e\u0442 \u0432\u0435\u0447\u0435\u0440 \u0432\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u0443\u0441\u043f\u0435\u0442\u044c, \u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, \")\n\n            activities_text_with_tts = [act.description for act in activities]\n            if len(activities) > 1:\n                # Construct activity enumerating statement in proper Russian\n                # syntax: objects are seperated by a comma and a whitespace\n                # except for the last two, which have the word \"\u0438\u043b\u0438\" inbetween.\n                activities_text_with_tts[-1] = TextWithTTS(\" \u0438\u043b\u0438 \").join(\n                    (\n                        activities_text_with_tts[-2],", "                    (\n                        activities_text_with_tts[-2],\n                        activities_text_with_tts[-1],\n                    )\n                )  # Glue the last two objects together with the word \"\u0438\u043b\u0438\"\n                activities_text_with_tts.pop(-2)  # Get rid of the penultimate\n                #                                   object duplicate\n\n            message += TextWithTTS(\", \").join(activities_text_with_tts) + \". \"\n", "            message += TextWithTTS(\", \").join(activities_text_with_tts) + \". \"\n\n        replica_tail = [\n            TextWithTTS(\"\u041d\u0435 \u0436\u0435\u043b\u0430\u0435\u0442\u0435-\u043b\u0438 \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0441\u043e\u0432\u0435\u0442 \u043f\u043e \u0441\u043d\u0443?\"),\n            TextWithTTS(\"\u041d\u0435 \u0445\u043e\u0442\u0438\u0442\u0435-\u043b\u0438 \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0441\u043e\u0432\u0435\u0442 \u043f\u043e \u0441\u043d\u0443?\"),\n            TextWithTTS(\"\u0425\u043e\u0442\u0438\u0442\u0435 \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0441\u043e\u0432\u0435\u0442 \u043f\u043e \u0441\u043d\u0443?\"),\n            TextWithTTS(\"\u041a\u0430\u043a \u043d\u0430\u0441\u0447\u0451\u0442 \u0441\u043e\u0432\u0435\u0442\u0430 \u043f\u043e \u0441\u043d\u0443?\"),\n            TextWithTTS(\"\u041a\u0430\u043a \u043d\u0430\u0441\u0447\u0451\u0442 \u043d\u0435\u0431\u043e\u043b\u044c\u0448\u043e\u0433\u043e \u0441\u043e\u0432\u0435\u0442\u0430 \u043f\u043e \u0441\u043d\u0443?\"),\n            TextWithTTS(\"\u0412\u0430\u0441 \u0438\u043d\u0442\u0435\u0440\u0435\u0441\u0443\u0435\u0442 \u0441\u043e\u0432\u0435\u0442 \u043f\u043e \u0441\u043d\u0443?\"),\n            TextWithTTS(\"\u0425\u043e\u0442\u0438\u0442\u0435 \u0441\u043e\u0432\u0435\u0442 \u043f\u043e \u0441\u043d\u0443?\"),", "            TextWithTTS(\"\u0412\u0430\u0441 \u0438\u043d\u0442\u0435\u0440\u0435\u0441\u0443\u0435\u0442 \u0441\u043e\u0432\u0435\u0442 \u043f\u043e \u0441\u043d\u0443?\"),\n            TextWithTTS(\"\u0425\u043e\u0442\u0438\u0442\u0435 \u0441\u043e\u0432\u0435\u0442 \u043f\u043e \u0441\u043d\u0443?\"),\n        ]\n        message += random.choice(replica_tail)\n\n        return message\n\n    def get_good_night_message(self) -> TextWithTTS:\n        replicas = [\n            TextWithTTS(text=\"\u0425\u043e\u0440\u043e\u0448\u0435\u0433\u043e \u0441\u043d\u0430!\"),", "        replicas = [\n            TextWithTTS(text=\"\u0425\u043e\u0440\u043e\u0448\u0435\u0433\u043e \u0441\u043d\u0430!\"),\n            TextWithTTS(text=\"\u0421\u043f\u043e\u043a\u043e\u0439\u043d\u043e\u0439 \u043d\u043e\u0447\u0438!\"),\n            TextWithTTS(text=\"\u0414\u043e\u0431\u0440\u043e\u0439 \u043d\u043e\u0447\u0438!\"),\n            TextWithTTS(text=\"\u0421\u043b\u0430\u0434\u043a\u0438\u0445 \u0441\u043d\u043e\u0432!\"),\n            TextWithTTS(text=\"\u0421\u043f\u043e\u043a\u0438!\"),\n            # NOTE:           ^^^^^ Cringe\n            TextWithTTS(text=\"\u0425\u043e\u0440\u043e\u0448\u0438\u0445 \u0432\u0430\u043c \u0441\u043d\u043e\u0432\u0435\u0434\u0435\u043d\u0438\u0439!\"),\n            TextWithTTS(text=\"\u041a\u0440\u0435\u043f\u043a\u043e\u0433\u043e \u0441\u043d\u0430!\"),\n            TextWithTTS(text=\"\u041e\u0442\u0431\u043e\u0439!\"),", "            TextWithTTS(text=\"\u041a\u0440\u0435\u043f\u043a\u043e\u0433\u043e \u0441\u043d\u0430!\"),\n            TextWithTTS(text=\"\u041e\u0442\u0431\u043e\u0439!\"),\n            # NOTE:           ^^^^^ Informal\n        ]\n        return random.choice(replicas)\n\n    def get_wrong_topic_message(self, topic_name: str) -> TextWithTTS:\n        return TextWithTTS(\n            \"\u041f\u043e\u0436\u0430\u043b\u0443\u0439\u0441\u0442\u0430, \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043e\u0434\u0438\u043d \u0438\u0437 \u0432\u0430\u0440\u0438\u0430\u043d\u0442\u043e\u0432 \u0442\u0435\u043c \u0434\u043b\u044f \u0441\u043e\u0432\u0435\u0442\u0430: \"\n            \" \u0434\u043d\u0435\u0432\u043d\u043e\u0439 \u0441\u043e\u043d \u0438\u043b\u0438 \u043d\u043e\u0447\u043d\u043e\u0439 \u0441\u043e\u043d, \u0438\u043b\u0438 \u0432\u0435\u0440\u043d\u0438\u0442\u0435\u0441\u044c \u0432 \u0433\u043b\u0430\u0432\u043d\u043e\u0435 \u043c\u0435\u043d\u044e, \u0441\u043a\u0430\u0437\u0430\u0432\"", "            \"\u041f\u043e\u0436\u0430\u043b\u0443\u0439\u0441\u0442\u0430, \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043e\u0434\u0438\u043d \u0438\u0437 \u0432\u0430\u0440\u0438\u0430\u043d\u0442\u043e\u0432 \u0442\u0435\u043c \u0434\u043b\u044f \u0441\u043e\u0432\u0435\u0442\u0430: \"\n            \" \u0434\u043d\u0435\u0432\u043d\u043e\u0439 \u0441\u043e\u043d \u0438\u043b\u0438 \u043d\u043e\u0447\u043d\u043e\u0439 \u0441\u043e\u043d, \u0438\u043b\u0438 \u0432\u0435\u0440\u043d\u0438\u0442\u0435\u0441\u044c \u0432 \u0433\u043b\u0430\u0432\u043d\u043e\u0435 \u043c\u0435\u043d\u044e, \u0441\u043a\u0430\u0437\u0430\u0432\"\n            f\" {LAQUO}\u041c\u0435\u043d\u044e{RAQUO}\"\n        )\n        # TODO: Rephrase replica and add variety\n\n    def get_generic_error_message(self) -> TextWithTTS:\n        return TextWithTTS(\"\u0427\u0442\u043e-\u0442\u043e \u043f\u043e\u0448\u043b\u043e \u043d\u0435 \u0442\u0430\u043a, \u0432\u044b \u0431\u044b\u043b\u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0435\u043d\u044b \u0432 \u043c\u0435\u043d\u044e.\")\n\n    def get_wrong_time_message(self) -> TextWithTTS:", "\n    def get_wrong_time_message(self) -> TextWithTTS:\n        hour = random.randint(0, 23)\n        minute = random.randint(0, 59)\n        return TextWithTTS(\n            text=\"\u041f\u043e\u0436\u0430\u043b\u0443\u0439\u0441\u0442\u0430, \u0443\u043a\u0430\u0436\u0438\u0442\u0435 \u0432\u0440\u0435\u043c\u044f \u0432 \u0444\u043e\u0440\u043c\u0430\u0442\u0435 \u0427\u0427:\u041c\u041c, \"\n            f\"\u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, {hour}:{minute:02d}, \"\n            f\"\u0438\u043b\u0438 \u0432\u0435\u0440\u043d\u0438\u0442\u0435\u0441\u044c  \u0432 \u0433\u043b\u0430\u0432\u043d\u043e\u0435 \u043c\u0435\u043d\u044e, \u0441\u043a\u0430\u0437\u0430\u0432 {LAQUO}\u041c\u0435\u043d\u044e{RAQUO}\",\n            tts=\"\u041f\u043e\u0436\u0430\u043b\u0443\u0439\u0441\u0442\u0430, \u0443\u043a\u0430\u0436\u0438\u0442\u0435 \u0432\u0440\u0435\u043c\u044f \u0432 \u0444\u043e\u0440\u043c\u0430\u0442\u0435 \u0447\u0430\u0441 \u043c\u0438\u043d\u0443\u0442\u0430, \"\n            f\"\u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, {hour} \u0447\u0430\u0441\u043e\u0432 {minute} \u043c\u0438\u043d\u0443\u0442, \"", "            tts=\"\u041f\u043e\u0436\u0430\u043b\u0443\u0439\u0441\u0442\u0430, \u0443\u043a\u0430\u0436\u0438\u0442\u0435 \u0432\u0440\u0435\u043c\u044f \u0432 \u0444\u043e\u0440\u043c\u0430\u0442\u0435 \u0447\u0430\u0441 \u043c\u0438\u043d\u0443\u0442\u0430, \"\n            f\"\u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, {hour} \u0447\u0430\u0441\u043e\u0432 {minute} \u043c\u0438\u043d\u0443\u0442, \"\n            f\"\u0438\u043b\u0438 \u0432\u0435\u0440\u043d\u0438\u0442\u0435\u0441\u044c \u0432 \u0433\u043b\u0430\u0432\u043d\u043e\u0435 \u043c\u0435\u043d\u044e, \u0441\u043a\u0430\u0437\u0430\u0432 {LAQUO}\u041c\u0435\u043d\u044e{RAQUO}.\",\n        )\n\n    def get_help_message(self) -> TextWithTTS:\n        return TextWithTTS(\n            f\"C\u043a\u0430\u0436\u0438\u0442\u0435 {LAQUO}\u041c\u0435\u043d\u044e{RAQUO}, \u0447\u0442\u043e\u0431\u044b \u043f\u0435\u0440\u0435\u0439\u0442\u0438 \u0432 \u0433\u043b\u0430\u0432\u043d\u043e\u0435 \u043c\u0435\u043d\u044e\\n\"\n            f\"\u0421\u043a\u0430\u0436\u0438\u0442\u0435 {LAQUO}\u042f \u0445\u043e\u0447\u0443 \u0441\u043f\u0430\u0442\u044c{RAQUO}, \u0447\u0442\u043e\u0431\u044b \u0440\u0430\u0441\u0441\u0447\u0438\u0442\u0430\u0442\u044c \u043e\u043f\u0442\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435\"\n            \" \u0432\u0440\u0435\u043c\u044f \u0441\u043d\u0430\\n\"", "            f\"\u0421\u043a\u0430\u0436\u0438\u0442\u0435 {LAQUO}\u042f \u0445\u043e\u0447\u0443 \u0441\u043f\u0430\u0442\u044c{RAQUO}, \u0447\u0442\u043e\u0431\u044b \u0440\u0430\u0441\u0441\u0447\u0438\u0442\u0430\u0442\u044c \u043e\u043f\u0442\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435\"\n            \" \u0432\u0440\u0435\u043c\u044f \u0441\u043d\u0430\\n\"\n            f\"\u0421\u043a\u0430\u0436\u0438\u0442\u0435 {LAQUO}\u0414\u0430\u0439 \u0441\u043e\u0432\u0435\u0442{RAQUO}, \u0447\u0442\u043e\u0431\u044b \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0441\u043e\u0432\u0435\u0442 \u043f\u043e \u0441\u043d\u0443\\n\"\n            f\"\u0421\u043a\u0430\u0436\u0438\u0442\u0435 {LAQUO}\u0420\u0430\u0441\u0441\u043a\u0430\u0436\u0438 \u043e \u043d\u0430\u0432\u044b\u043a\u0435{RAQUO}, \u0447\u0442\u043e\u0431\u044b \u0443\u0437\u043d\u0430\u0442\u044c \u043f\u043e\u0431\u043e\u043b\u044c\u0448\u0435 \u043e\"\n            \" \u043d\u0430\u0432\u044b\u043a\u0435\\n\u0421\u043a\u0430\u0436\u0438\u0442\u0435 \u00ab\u0412\u044b\u0445\u043e\u0434\u00bb, \u0447\u0442\u043e\u0431\u044b \u0432\u044b\u0439\u0442\u0438 \u0438\u0437 \u043d\u0430\u0432\u044b\u043a\u0430.\"\n        )\n\n    def get_what_can_you_do_message(self) -> TextWithTTS:\n        return TextWithTTS(\n            \"\u042f \u043c\u043e\u0433\u0443 \u0440\u0430\u0441\u0441\u0447\u0438\u0442\u0430\u0442\u044c \u043e\u043f\u0442\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u0432\u0440\u0435\u043c\u044f \u0434\u043b\u044f \u0432\u0430\u0448\u0435\u0433\u043e \u043e\u0442\u0434\u044b\u0445\u0430 \u0438\"", "        return TextWithTTS(\n            \"\u042f \u043c\u043e\u0433\u0443 \u0440\u0430\u0441\u0441\u0447\u0438\u0442\u0430\u0442\u044c \u043e\u043f\u0442\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u0432\u0440\u0435\u043c\u044f \u0434\u043b\u044f \u0432\u0430\u0448\u0435\u0433\u043e \u043e\u0442\u0434\u044b\u0445\u0430 \u0438\"\n            \" \u043f\u0440\u0435\u0434\u043e\u0441\u0442\u0430\u0432\u0438\u0442\u044c \u0432\u0430\u043c \u0441\u043e\u0432\u0435\u0442\u044b \u043f\u043e \u0443\u043b\u0443\u0447\u0448\u0435\u043d\u0438\u044e \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0430 \u0441\u043d\u0430. \u0414\u043e\u0432\u0435\u0440\u044c\u0442\u0435\u0441\u044c\"\n            \" \u043c\u043e\u0438\u043c \u0437\u043d\u0430\u043d\u0438\u044f\u043c \u0438 \u043e\u043f\u044b\u0442\u0443, \u0438 \u0432\u044b \u043e\u0431\u0440\u0435\u0442\u0435\u0442\u0435 \u0433\u043b\u0443\u0431\u043e\u043a\u0438\u0439 \u0438 \u043f\u043e\u043b\u043d\u043e\u0446\u0435\u043d\u043d\u044b\u0439\"\n            \" \u043e\u0442\u0434\u044b\u0445, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043f\u043e\u0437\u0432\u043e\u043b\u0438\u0442 \u0432\u0430\u043c \u043f\u0440\u043e\u0441\u043d\u0443\u0442\u044c\u0441\u044f \u0443\u0442\u0440\u043e\u043c \u0441\u0432\u0435\u0436\u0438\u043c \u0438 \u0431\u043e\u0434\u0440\u044b\u043c.\"\n        )\n\n    def get_quit_message(self) -> TextWithTTS:\n        replicas = [\n            TextWithTTS(text=\"\u0425\u043e\u0440\u043e\u0448\u0435\u0433\u043e \u0432\u0430\u043c \u0441\u043d\u0430)\", tts=\"\u0445\u0430\u0440+\u043e\u0448\u0435\u0433\u043e \u0432\u0430\u043c \u0441\u043d\u0430!\"),", "        replicas = [\n            TextWithTTS(text=\"\u0425\u043e\u0440\u043e\u0448\u0435\u0433\u043e \u0432\u0430\u043c \u0441\u043d\u0430)\", tts=\"\u0445\u0430\u0440+\u043e\u0448\u0435\u0433\u043e \u0432\u0430\u043c \u0441\u043d\u0430!\"),\n            TextWithTTS(text=\"\u0421\u043f\u043e\u043a\u043e\u0439\u043d\u043e\u0439 \u043d\u043e\u0447\u0438!\"),\n            TextWithTTS(text=\"\u0414\u043e\u0431\u0440\u043e\u0439 \u043d\u043e\u0447\u0438!\"),\n            TextWithTTS(text=\"\u0421\u043b\u0430\u0434\u043a\u0438\u0445 \u0441\u043d\u043e\u0432!\"),\n            TextWithTTS(text=\"\u0420\u0430\u0434 \u043f\u043e\u043c\u043e\u0447\u044c!\"),\n            TextWithTTS(text=\"\u0425\u043e\u0440\u043e\u0448\u0438\u0445 \u0432\u0430\u043c \u0441\u043d\u043e\u0432\u0435\u0434\u0435\u043d\u0438\u0439!\"),\n            TextWithTTS(text=\"\u041a\u0440\u0435\u043f\u043a\u043e\u0433\u043e \u0441\u043d\u0430!\"),\n            TextWithTTS(text=\"\u041f\u043e\u043a\u0430-\u043f\u043e\u043a\u0430!\"),\n            TextWithTTS(text=\"\u041f\u0438\u0448\u0438\u0442\u0435 \u0435\u0449\u0451!\"),", "            TextWithTTS(text=\"\u041f\u043e\u043a\u0430-\u043f\u043e\u043a\u0430!\"),\n            TextWithTTS(text=\"\u041f\u0438\u0448\u0438\u0442\u0435 \u0435\u0449\u0451!\"),\n            TextWithTTS(text=\"\u0414\u0430 \u043f\u0440\u0438\u0431\u0443\u0434\u0435\u0442 \u0441 \u0432\u0430\u043c\u0438 \u0441\u043e\u043d!\"),\n            TextWithTTS(text=\"\u0414\u043e\u0441\u0432\u0438\u0434\u0430\u043d\u0438\u044f!\"),\n            TextWithTTS(text=\"\u0423\u0434\u0430\u0447\u0438!\"),\n            TextWithTTS(text=\"\u041f\u0438\u0448\u0438\u0442\u0435 \u043f\u043e\u0447\u0430\u0449\u0435!\"),\n        ]\n        return random.choice(replicas)\n", ""]}
{"filename": "skill/dataconvert/ya_converter.py", "chunked_list": ["import datetime\n\nimport pytz\n\nfrom skill.dataconvert.base_converter import BaseDataConverter\nfrom skill.exceptions import InvalidInputError\n\n\nclass YaDataConverter(BaseDataConverter):\n    \"\"\"Data converter for Yandex Alice API.\"\"\"\n\n    @staticmethod\n    def time(obj: dict, timezone: str | datetime.tzinfo) -> datetime.time:\n        \"\"\"Convert YANDEX.DATETIME JSON object to datetime.time with\n        given timezone\"\"\"\n\n        if obj[\"type\"] != \"YANDEX.DATETIME\":\n            raise InvalidInputError(\n                \"obj must be Alice API YANDEX.DATETIME object\"\n            )\n\n        tzinfo = (\n            timezone\n            if isinstance(timezone, datetime.tzinfo)\n            else pytz.timezone(timezone)\n        )\n\n        if \"hour\" not in obj[\"value\"] or \"minute\" not in obj[\"value\"]:\n            raise InvalidInputError(\n                \"obj should contain hour and minute information\"\n            )\n\n        time = datetime.time(\n            hour=obj[\"value\"][\"hour\"],\n            minute=obj[\"value\"][\"minute\"],\n            tzinfo=tzinfo,\n        )\n\n        return time\n\n    @staticmethod\n    def datetime(obj: dict, timezone: str) -> datetime.datetime:\n        \"\"\"Convert YANDEX.DATETIME JSON object to datetime.datetime with\n        given timezone\"\"\"\n\n        if obj[\"type\"] != \"YANDEX.DATETIME\":\n            raise InvalidInputError(\n                \"obj must be Alice API YANDEX.DATETIME object\"\n            )\n        if isinstance(timezone, str):\n            tzinfo = pytz.timezone(timezone)\n        elif isinstance(timezone, datetime.tzinfo):\n            tzinfo = timezone  # type: ignore\n        else:\n            raise InvalidInputError(\"Invalid timezone type\")\n\n        if not (\n            \"year\" in obj[\"value\"]\n            and \"month\" in obj[\"value\"]\n            and \"day\" in obj[\"value\"]\n            and \"hour\" in obj[\"value\"]\n            and \"minute\" in obj[\"value\"]\n        ):\n            raise InvalidInputError(\"Incomplete obj\")\n\n        result_datetime = datetime.datetime(\n            year=obj[\"value\"][\"year\"],\n            month=obj[\"value\"][\"month\"],\n            day=obj[\"value\"][\"day\"],\n            hour=obj[\"value\"][\"hour\"],\n            minute=obj[\"value\"][\"minute\"],\n            tzinfo=tzinfo,\n        )\n        return result_datetime", "class YaDataConverter(BaseDataConverter):\n    \"\"\"Data converter for Yandex Alice API.\"\"\"\n\n    @staticmethod\n    def time(obj: dict, timezone: str | datetime.tzinfo) -> datetime.time:\n        \"\"\"Convert YANDEX.DATETIME JSON object to datetime.time with\n        given timezone\"\"\"\n\n        if obj[\"type\"] != \"YANDEX.DATETIME\":\n            raise InvalidInputError(\n                \"obj must be Alice API YANDEX.DATETIME object\"\n            )\n\n        tzinfo = (\n            timezone\n            if isinstance(timezone, datetime.tzinfo)\n            else pytz.timezone(timezone)\n        )\n\n        if \"hour\" not in obj[\"value\"] or \"minute\" not in obj[\"value\"]:\n            raise InvalidInputError(\n                \"obj should contain hour and minute information\"\n            )\n\n        time = datetime.time(\n            hour=obj[\"value\"][\"hour\"],\n            minute=obj[\"value\"][\"minute\"],\n            tzinfo=tzinfo,\n        )\n\n        return time\n\n    @staticmethod\n    def datetime(obj: dict, timezone: str) -> datetime.datetime:\n        \"\"\"Convert YANDEX.DATETIME JSON object to datetime.datetime with\n        given timezone\"\"\"\n\n        if obj[\"type\"] != \"YANDEX.DATETIME\":\n            raise InvalidInputError(\n                \"obj must be Alice API YANDEX.DATETIME object\"\n            )\n        if isinstance(timezone, str):\n            tzinfo = pytz.timezone(timezone)\n        elif isinstance(timezone, datetime.tzinfo):\n            tzinfo = timezone  # type: ignore\n        else:\n            raise InvalidInputError(\"Invalid timezone type\")\n\n        if not (\n            \"year\" in obj[\"value\"]\n            and \"month\" in obj[\"value\"]\n            and \"day\" in obj[\"value\"]\n            and \"hour\" in obj[\"value\"]\n            and \"minute\" in obj[\"value\"]\n        ):\n            raise InvalidInputError(\"Incomplete obj\")\n\n        result_datetime = datetime.datetime(\n            year=obj[\"value\"][\"year\"],\n            month=obj[\"value\"][\"month\"],\n            day=obj[\"value\"][\"day\"],\n            hour=obj[\"value\"][\"hour\"],\n            minute=obj[\"value\"][\"minute\"],\n            tzinfo=tzinfo,\n        )\n        return result_datetime", ""]}
{"filename": "skill/dataconvert/base_converter.py", "chunked_list": ["import abc\nimport datetime\n\n\nclass BaseDataConverter(abc.ABC):\n    @staticmethod\n    @abc.abstractmethod\n    def time(obj: dict, timezone: str) -> datetime.time:\n        ...\n\n    @staticmethod\n    @abc.abstractmethod\n    def datetime(obj: dict, timezone: str) -> datetime.datetime:\n        ...", ""]}
{"filename": "content/__init__.py", "chunked_list": [""]}
