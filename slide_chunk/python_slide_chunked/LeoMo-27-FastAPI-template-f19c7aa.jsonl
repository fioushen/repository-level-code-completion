{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/main.py", "chunked_list": ["\"\"\"Main FastAPI app instance declaration.\"\"\"\n\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.middleware.trustedhost import TrustedHostMiddleware\n\nfrom src.api.router import router\nfrom src.core import config\n\napp = FastAPI(", "\napp = FastAPI(\n    title=config.settings.PROJECT_NAME,\n    version=config.settings.VERSION,\n    description=config.settings.DESCRIPTION,\n    openapi_url=\"/openapi.json\",\n    docs_url=\"/docs\",\n)\napp.include_router(router)\n", "app.include_router(router)\n\n# Sets all CORS enabled origins\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[str(origin) for origin in config.settings.BACKEND_CORS_ORIGINS],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)", "    allow_headers=[\"*\"],\n)\n\n# Guards against HTTP Host Header attacks\napp.add_middleware(TrustedHostMiddleware, allowed_hosts=config.settings.ALLOWED_HOSTS)\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/__init__.py", "chunked_list": [""]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/conftest.py", "chunked_list": ["\"\"\"\nUsed to set environment variable before running tests.\nWe need this to use test database.\n\"\"\"\n\nimport os\n\n# This will ensure using test database\nos.environ[\"ENVIRONMENT\"] = \"PYTEST\"\n", "os.environ[\"ENVIRONMENT\"] = \"PYTEST\"\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/schemas/auth.py", "chunked_list": ["\"\"\"Auth schemas.\"\"\"\nfrom .base import BaseRequest, BaseResponse\n\n\nclass RefreshTokenRequest(BaseRequest):\n    refresh_token: str\n\n\nclass AccessTokenResponse(BaseResponse):\n    token_type: str\n    access_token: str\n    expires_at: int\n    issued_at: int\n    refresh_token: str\n    refresh_token_expires_at: int\n    refresh_token_issued_at: int", "class AccessTokenResponse(BaseResponse):\n    token_type: str\n    access_token: str\n    expires_at: int\n    issued_at: int\n    refresh_token: str\n    refresh_token_expires_at: int\n    refresh_token_issued_at: int\n\n\nclass JWTTokenPayload(BaseRequest):\n    sub: str\n    refresh: bool\n    issued_at: int\n    expires_at: int", "\n\nclass JWTTokenPayload(BaseRequest):\n    sub: str\n    refresh: bool\n    issued_at: int\n    expires_at: int\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/schemas/base.py", "chunked_list": ["\"\"\"Base schemas for all requests and responses.\"\"\"\nfrom pydantic import BaseModel\n\n\nclass BaseRequest(BaseModel):\n    # may define additional fields or config shared across requests\n    pass\n\n\nclass BaseResponse(BaseModel):\n    # may define additional fields or config shared across responses\n    class Config:\n        orm_mode = True", "\nclass BaseResponse(BaseModel):\n    # may define additional fields or config shared across responses\n    class Config:\n        orm_mode = True\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/schemas/users.py", "chunked_list": ["\"\"\"User schemas.\"\"\"\nfrom pydantic import EmailStr\n\nfrom .base import BaseRequest, BaseResponse\n\n\nclass UserCreateRequest(BaseRequest):\n    email: EmailStr\n    password: str\n", "\n\nclass UserUpdateRequest(BaseRequest):\n    email: EmailStr | None = None\n    password: str | None = None\n\n\nclass UserResponse(BaseResponse):\n    id: str\n    email: EmailStr", ""]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/schemas/__init__.py", "chunked_list": ["from .auth import AccessTokenResponse, JWTTokenPayload, RefreshTokenRequest\nfrom .users import UserCreateRequest, UserResponse, UserUpdateRequest\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/tests/test_users.py", "chunked_list": ["from httpx import AsyncClient\nfrom sqlalchemy import select\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom src.main import app\nfrom src.models import User\nfrom src.tests.conftest import TEST_USER\n\n\nasync def test_get_current_user(client: AsyncClient, default_user_headers):", "\nasync def test_get_current_user(client: AsyncClient, default_user_headers):\n    response = await client.get(\n        app.url_path_for(\"read_current_user\"), headers=default_user_headers\n    )\n    assert response.status_code == 200\n    assert response.json() == {\n        \"id\": TEST_USER.id,\n        \"email\": TEST_USER.email,\n    }", "        \"email\": TEST_USER.email,\n    }\n\n\nasync def test_delete_current_user(\n    client: AsyncClient, default_user_headers, default_user, db_session: AsyncSession\n):\n    response = await client.delete(\n        app.url_path_for(\"delete_user\", id=default_user.id),\n        headers=default_user_headers,", "        app.url_path_for(\"delete_user\", id=default_user.id),\n        headers=default_user_headers,\n    )\n    assert response.status_code == 204\n    result = await db_session.execute(select(User).where(User.id == TEST_USER.id))\n    user = result.scalars().first()\n    assert user is None\n\n\nasync def test_update_current_user(", "\nasync def test_update_current_user(\n    client: AsyncClient, default_user_headers, default_user, db_session: AsyncSession\n):\n    response = await client.patch(\n        app.url_path_for(\"update_user\", id=default_user.id),\n        headers=default_user_headers,\n        json={\"email\": \"new_test_email@test.com\"},\n    )\n    assert response.status_code == 200", "    )\n    assert response.status_code == 200\n    result = await db_session.execute(select(User).where(User.id == TEST_USER.id))\n    user = result.scalars().first()\n    assert user is not None\n    assert user.email != TEST_USER.email\n\n\nasync def test_register_new_user(\n    client: AsyncClient, default_user_headers, db_session: AsyncSession", "async def test_register_new_user(\n    client: AsyncClient, default_user_headers, db_session: AsyncSession\n):\n    response = await client.post(\n        app.url_path_for(\"register_new_user\"),\n        headers=default_user_headers,\n        json={\n            \"email\": \"new_user@test.com\",\n            \"password\": \"another_password\",\n        },", "            \"password\": \"another_password\",\n        },\n    )\n    assert response.status_code == 201\n    result = await db_session.execute(\n        select(User).where(User.email == \"new_user@test.com\")\n    )\n    user = result.scalars().first()\n    assert user is not None\n", "    assert user is not None\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/tests/__init__.py", "chunked_list": [""]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/tests/test_auth.py", "chunked_list": ["from httpx import AsyncClient\n\nfrom src.main import app\nfrom src.models import User\nfrom src.tests.conftest import TEST_USER\n\n\nasync def test_auth_access_token(client: AsyncClient, default_user: User):\n    response = await client.post(\n        app.url_path_for(\"login_access_token\"),", "    response = await client.post(\n        app.url_path_for(\"login_access_token\"),\n        data={\n            \"username\": TEST_USER.email,\n            \"password\": TEST_USER.unhashed_password,\n        },\n    )\n    assert response.status_code == 200\n    token = response.json()\n    assert token[\"token_type\"] == \"Bearer\"", "    token = response.json()\n    assert token[\"token_type\"] == \"Bearer\"\n    assert \"access_token\" in token\n    assert \"expires_at\" in token\n    assert \"issued_at\" in token\n    assert \"refresh_token\" in token\n    assert \"refresh_token_expires_at\" in token\n    assert \"refresh_token_issued_at\" in token\n\n", "\n\nasync def test_auth_access_token_fail_no_user(client: AsyncClient):\n    response = await client.post(\n        app.url_path_for(\"login_access_token\"),\n        data={\n            \"username\": \"xxx\",\n            \"password\": \"yyy\",\n        },\n    )", "        },\n    )\n\n    assert response.status_code == 404\n    assert response.json() == {\"detail\": \"User not found.\"}\n\n\nasync def test_auth_refresh_token(client: AsyncClient, default_user: User):\n    response = await client.post(\n        app.url_path_for(\"login_access_token\"),", "    response = await client.post(\n        app.url_path_for(\"login_access_token\"),\n        data={\n            \"username\": TEST_USER.email,\n            \"password\": TEST_USER.unhashed_password,\n        },\n    )\n    refresh_token = response.json()[\"refresh_token\"]\n\n    new_token_response = await client.post(", "\n    new_token_response = await client.post(\n        app.url_path_for(\"refresh_token\"), json={\"refresh_token\": refresh_token}\n    )\n    assert new_token_response.status_code == 200\n    token = new_token_response.json()\n    assert token[\"token_type\"] == \"Bearer\"\n    assert \"access_token\" in token\n    assert \"expires_at\" in token\n    assert \"issued_at\" in token", "    assert \"expires_at\" in token\n    assert \"issued_at\" in token\n    assert \"refresh_token\" in token\n    assert \"refresh_token_expires_at\" in token\n    assert \"refresh_token_issued_at\" in token\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/tests/conftest.py", "chunked_list": ["\"\"\"Pytest configuration file.\n\nUsed to execute code before running tests, in this case we want to use test database.\n\"\"\"\nimport asyncio\nfrom collections.abc import AsyncGenerator\n\nimport pytest\nimport pytest_asyncio\nfrom httpx import AsyncClient", "import pytest_asyncio\nfrom httpx import AsyncClient\nfrom sqlalchemy import select\nfrom sqlalchemy.ext.asyncio import create_async_engine\n\nfrom src.core.db import async_db\nfrom src.main import app\nfrom src.models import Base, User\n\nfrom .utils.test_database import create_database, drop_database", "\nfrom .utils.test_database import create_database, drop_database\nfrom .utils.test_user import TestUser\n\nTEST_USER = TestUser()\nTEST_DATABASE_URL = async_db.set_async_db_uri\n\n\n@pytest.fixture(scope=\"session\")\ndef event_loop():\n    loop = asyncio.new_event_loop()\n    asyncio.set_event_loop(loop)\n    yield loop\n    loop.close()", "@pytest.fixture(scope=\"session\")\ndef event_loop():\n    loop = asyncio.new_event_loop()\n    asyncio.set_event_loop(loop)\n    yield loop\n    loop.close()\n\n\n@pytest_asyncio.fixture(scope=\"session\")\nasync def client() -> AsyncGenerator[AsyncClient, None]:", "@pytest_asyncio.fixture(scope=\"session\")\nasync def client() -> AsyncGenerator[AsyncClient, None]:\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        client.headers.update({\"Host\": \"localhost\"})\n        yield client\n\n\n@pytest.fixture(scope=\"session\")\nasync def database(event_loop):\n    await create_database(TEST_DATABASE_URL)", "async def database(event_loop):\n    await create_database(TEST_DATABASE_URL)\n\n    engine = create_async_engine(TEST_DATABASE_URL)\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n    await engine.dispose()\n\n    try:\n        yield TEST_DATABASE_URL\n    finally:\n        await drop_database(TEST_DATABASE_URL)", "    try:\n        yield TEST_DATABASE_URL\n    finally:\n        await drop_database(TEST_DATABASE_URL)\n\n\n@pytest.fixture(scope=\"session\")\nasync def sqla_engine(database):\n    async with async_db.async_engine.begin() as conn:\n        yield conn", "    async with async_db.async_engine.begin() as conn:\n        yield conn\n\n\n@pytest.fixture(scope=\"session\")\nasync def db_session(sqla_engine):\n    async with async_db.async_session() as session:\n        yield session\n\n", "\n\n@pytest_asyncio.fixture\nasync def default_user(database) -> User:\n    async with async_db.async_session() as session:\n        result = await session.execute(select(User).where(User.id == TEST_USER.id))\n        user = result.scalars().first()\n        if user is None:\n            new_user = User(\n                email=TEST_USER.email,\n                password=TEST_USER.password,\n            )\n            new_user.id = TEST_USER.id\n            session.add(new_user)\n            await session.commit()\n            await session.refresh(new_user)\n            return new_user", "        return user\n\n\n@pytest.fixture\ndef default_user_headers(default_user: User):\n    return {\"Authorization\": f\"Bearer {TEST_USER.access_token}\"}\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/tests/utils/test_user.py", "chunked_list": ["from random import randint\nfrom uuid import uuid4\n\nfrom src.core.security.jwt import jwt_generator\nfrom src.core.security.password import password_generator\n\n\nclass TestUser:\n    id: str = str(uuid4())\n    email: str = f\"test_{randint(0, 10)}@test.com\"\n    unhashed_password: str = f\"testing_user_{randint(0, 10)}\"\n    password: str = password_generator.get_password_hash(unhashed_password)\n    access_token = jwt_generator._generate_jwt_token(\n        str(id), 60 * 60 * 24, refresh=False\n    )[0]", ""]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/tests/utils/test_database.py", "chunked_list": ["from sqlalchemy import text\nfrom sqlalchemy.engine import make_url\nfrom sqlalchemy.ext.asyncio import create_async_engine\n\nfrom src.core import config\n\nDEFAULT_DB = config.settings.DB_NAME\n\n\nasync def create_database(url: str):", "\nasync def create_database(url: str):\n    \"\"\"Create the test database if it doesn't exist yet.\n    In case it does exist, drop it and create it again.\n    \"\"\"\n    url_object = make_url(url)\n    database_name = url_object.database\n    dbms_url = url_object.set(database=DEFAULT_DB)\n    engine = create_async_engine(dbms_url, isolation_level=\"AUTOCOMMIT\")\n", "    engine = create_async_engine(dbms_url, isolation_level=\"AUTOCOMMIT\")\n\n    async with engine.connect() as conn:\n        result = await conn.execute(\n            text(f\"SELECT 1 FROM pg_database WHERE datname='{database_name}'\")\n        )\n        database_exists = result.scalar() == 1\n\n    if database_exists:\n        await drop_database(str(url_object))", "    if database_exists:\n        await drop_database(str(url_object))\n\n    async with engine.connect() as conn:\n        await conn.execute(\n            text(\n                f'CREATE DATABASE \"{database_name}\" ENCODING \"utf8\" TEMPLATE template1'\n            )\n        )\n    await engine.dispose()", "        )\n    await engine.dispose()\n\n\nasync def drop_database(url: str):\n    \"\"\"Helper function to drop a database.\n    This is used to drop the test database after the tests are done.\n    \"\"\"\n    url_object = make_url(url)\n    dbms_url = url_object.set(database=DEFAULT_DB)", "    url_object = make_url(url)\n    dbms_url = url_object.set(database=DEFAULT_DB)\n    engine = create_async_engine(dbms_url, isolation_level=\"AUTOCOMMIT\")\n    async with engine.connect() as conn:\n        disc_users = \"\"\"\n        SELECT pg_terminate_backend(pg_stat_activity.%(pid_column)s)\n        FROM pg_stat_activity\n        WHERE pg_stat_activity.datname = '%(database)s'\n          AND %(pid_column)s <> pg_backend_pid();\n        \"\"\" % {", "          AND %(pid_column)s <> pg_backend_pid();\n        \"\"\" % {\n            \"pid_column\": \"pid\",\n            \"database\": url_object.database,\n        }\n        await conn.execute(text(disc_users))\n\n        await conn.execute(text(f'DROP DATABASE \"{url_object.database}\"'))\n", ""]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/tests/utils/__init__.py", "chunked_list": [""]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/models/base.py", "chunked_list": ["from sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/models/users.py", "chunked_list": ["import uuid\n\nfrom sqlalchemy import String\nfrom sqlalchemy.dialects.postgresql import UUID\nfrom sqlalchemy.orm import Mapped, mapped_column\n\nfrom .base import Base\n\n\nclass User(Base):\n    __tablename__ = \"user_model\"\n\n    id: Mapped[str] = mapped_column(\n        UUID(as_uuid=False), primary_key=True, default=lambda _: str(uuid.uuid4())\n    )\n    email: Mapped[str] = mapped_column(String(128), nullable=False, unique=True)\n    password: Mapped[str] = mapped_column(String(128), nullable=False)", "\nclass User(Base):\n    __tablename__ = \"user_model\"\n\n    id: Mapped[str] = mapped_column(\n        UUID(as_uuid=False), primary_key=True, default=lambda _: str(uuid.uuid4())\n    )\n    email: Mapped[str] = mapped_column(String(128), nullable=False, unique=True)\n    password: Mapped[str] = mapped_column(String(128), nullable=False)\n", ""]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/models/dogs.py", "chunked_list": ["import uuid\n\nfrom sqlalchemy import String\nfrom sqlalchemy.dialects.postgresql import UUID\nfrom sqlalchemy.orm import Mapped, mapped_column\n\nfrom .base import Base\n\n\nclass Dog(Base):\n    __tablename__ = \"dog_model\"\n\n    id: Mapped[str] = mapped_column(\n        UUID(as_uuid=False), primary_key=True, default=lambda _: str(uuid.uuid4())\n    )\n    name: Mapped[str] = mapped_column(String(128), nullable=False)", "\nclass Dog(Base):\n    __tablename__ = \"dog_model\"\n\n    id: Mapped[str] = mapped_column(\n        UUID(as_uuid=False), primary_key=True, default=lambda _: str(uuid.uuid4())\n    )\n    name: Mapped[str] = mapped_column(String(128), nullable=False)\n", ""]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/models/__init__.py", "chunked_list": ["from .base import Base\nfrom .dogs import Dog\nfrom .users import User\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/core/config.py", "chunked_list": ["\"\"\"\nFile with environment variables and general configuration logic.\n`SECRET_KEY`, `ENVIRONMENT` etc. map to env variables with the same names.\n\nFor project name, version, description we use pyproject.toml\nFor the rest, we use file `.env` (gitignored), see `.env.example`\n\nSee https://pydantic-docs.helpmanual.io/usage/settings/\n\nNote, complex types like lists are read as json-encoded strings.", "\nNote, complex types like lists are read as json-encoded strings.\n\"\"\"\n\nfrom pathlib import Path\nfrom secrets import token_hex\nfrom typing import Literal\n\nimport toml\nfrom pydantic import AnyHttpUrl, BaseSettings, PostgresDsn, validator", "import toml\nfrom pydantic import AnyHttpUrl, BaseSettings, PostgresDsn, validator\n\nPROJECT_DIR = Path(__file__).parent.parent.parent\nPYPROJECT_CONTENT = toml.load(f\"{PROJECT_DIR}/pyproject.toml\")[\"tool\"][\"poetry\"]\n\n\nclass Settings(BaseSettings):\n    # CORE SETTINGS\n    SECRET_KEY: str = token_hex(32)  # Use an environment variable instead.\n    ENVIRONMENT: Literal[\"DEV\", \"PYTEST\", \"STG\", \"PRD\"] = \"DEV\"\n    SECURITY_BCRYPT_ROUNDS: int = 12\n    ACCESS_TOKEN_EXPIRE_MINUTES: int = 10080  # 7 days\n    REFRESH_TOKEN_EXPIRE_MINUTES: int = 20160  # 14 days\n    ACCESS_TOKEN_EXPIRE: int = ACCESS_TOKEN_EXPIRE_MINUTES * 60\n    REFRESH_TOKEN_EXPIRE: int = REFRESH_TOKEN_EXPIRE_MINUTES * 60\n    BACKEND_CORS_ORIGINS: list[AnyHttpUrl] = []\n    ALLOWED_HOSTS: list[str] = [\"localhost\", \"127.0.0.1\"]\n\n    # PROJECT NAME, VERSION AND DESCRIPTION\n    PROJECT_NAME: str = PYPROJECT_CONTENT[\"name\"]\n    VERSION: str = PYPROJECT_CONTENT[\"version\"]\n    DESCRIPTION: str = PYPROJECT_CONTENT[\"description\"]\n\n    # POSTGRESQL DEFAULT DATABASE\n    DB_HOST: str\n    DB_USER: str\n    DB_PASSWORD: str\n    DB_PORT: str\n    DB_NAME: str\n    DATABASE_URI: str = \"\"\n    TEST_DATABASE_URI: str = \"\"\n\n    # See https://docs.pydantic.dev/usage/validators/\n    @validator(\"DATABASE_URI\")\n    def _assemble_default_db_connection(cls, v: str, values: dict[str, str]) -> str:\n        return PostgresDsn.build(\n            scheme=\"postgresql+asyncpg\",\n            user=values[\"DB_USER\"],\n            password=values[\"DB_PASSWORD\"],\n            host=values[\"DB_HOST\"],\n            port=values[\"DB_PORT\"],\n            path=f\"/{values['DB_NAME']}\",\n        )\n\n    # See https://docs.pydantic.dev/usage/validators/\n    @validator(\"TEST_DATABASE_URI\")\n    def _assemble_test_db_connection(cls, v: str, values: dict[str, str]) -> str:\n        return PostgresDsn.build(\n            scheme=\"postgresql+asyncpg\",\n            user=values[\"DB_USER\"],\n            password=values[\"DB_PASSWORD\"],\n            host=values[\"DB_HOST\"],\n            port=values[\"DB_PORT\"],\n            path=f\"/{values['DB_NAME']}-test\",\n        )\n\n    class Config:\n        env_file = f\"{PROJECT_DIR}/.env\"\n        case_sensitive = True", "\n\nsettings: Settings = Settings()  # type: ignore\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/core/db.py", "chunked_list": ["\"\"\"\nSQLAlchemy async engine and sessions tools\n\nhttps://docs.sqlalchemy.org/en/20/orm/extensions/asyncio.html\n\"\"\"\n\nfrom pydantic import PostgresDsn\nfrom sqlalchemy.ext.asyncio import AsyncEngine, async_sessionmaker, create_async_engine\nfrom sqlalchemy.pool import Pool as SQLAlchemyPool\n", "from sqlalchemy.pool import Pool as SQLAlchemyPool\n\nfrom src.core import config\n\n\nclass AsyncDatabase:\n    def __init__(self):\n        self.async_engine: AsyncEngine = create_async_engine(\n            url=self.set_async_db_uri,\n            pool_pre_ping=True,\n        )\n        self.async_session = async_sessionmaker(\n            self.async_engine, expire_on_commit=False\n        )\n        self.pool: SQLAlchemyPool = self.async_engine.pool\n\n    @property\n    def set_async_db_uri(self) -> str | PostgresDsn:\n        \"\"\"\n        Set the database uri for the async engine, depending on the environment\n        \"\"\"\n        if config.settings.ENVIRONMENT == \"PYTEST\":\n            database_uri = config.settings.TEST_DATABASE_URI\n        else:\n            database_uri = config.settings.DATABASE_URI\n\n        return database_uri", "\n\nasync_db: AsyncDatabase = AsyncDatabase()\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/core/__init__.py", "chunked_list": [""]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/core/security/password.py", "chunked_list": ["\"\"\"Password generation and verification tools.\"\"\"\n\nfrom passlib.context import CryptContext\n\nfrom src.core.config import settings\n\n\nclass PasswordGenerator:\n    def __init__(self) -> None:\n        self.pwd_context = CryptContext(\n            schemes=[\"bcrypt\"],\n            deprecated=\"auto\",\n            bcrypt__rounds=settings.SECURITY_BCRYPT_ROUNDS,\n        )\n\n    def verify_password(self, plain_password: str, password: str) -> bool:\n        \"\"\"Verifies plain and hashed password matches\n\n        Applies passlib context based on bcrypt algorithm on plain password.\n        \"\"\"\n        return self.pwd_context.verify(plain_password, password)\n\n    def get_password_hash(self, password: str) -> str:\n        \"\"\"Creates hash from password\n\n        Applies passlib context based on bcrypt algorithm on plain password.\n        \"\"\"\n        return self.pwd_context.hash(password)", "\n\npassword_generator: PasswordGenerator = PasswordGenerator()\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/core/security/jwt.py", "chunked_list": ["\"\"\"JWT generator used for authentication.\"\"\"\nimport time\nfrom typing import Tuple\n\nimport jwt\n\nfrom src.core.config import settings\nfrom src.schemas import AccessTokenResponse\n\n\nclass JWTGenerator:\n    def __init__(self) -> None:\n        self.jwt_algorithm = \"HS256\"\n\n    def _generate_jwt_token(\n        self, subject: str | int, exp_secs: int, refresh: bool\n    ) -> Tuple[str, int, int]:\n        \"\"\"Creates jwt access or refresh token for user.\n\n        Args:\n            subject: anything unique to user, id or email etc.\n            exp_secs: expire time in seconds\n            refresh: if True, this is refresh token\n        \"\"\"\n\n        issued_at = int(time.time())\n        expires_at = issued_at + exp_secs\n\n        to_encode: dict[str, int | str | bool] = {\n            \"issued_at\": issued_at,\n            \"expires_at\": expires_at,\n            \"sub\": subject,\n            \"refresh\": refresh,\n        }\n        encoded_jwt = jwt.encode(\n            to_encode,\n            key=settings.SECRET_KEY,\n            algorithm=self.jwt_algorithm,\n        )\n        return encoded_jwt, expires_at, issued_at\n\n    def generate_access_token(self, subject: str | int) -> AccessTokenResponse:\n        \"\"\"Generate tokens and return AccessTokenResponse\n\n        Args:\n            subject: anything unique to user, id or email etc.\n        \"\"\"\n\n        access_token, expires_at, issued_at = self._generate_jwt_token(\n            subject, settings.ACCESS_TOKEN_EXPIRE, refresh=False\n        )\n        refresh_token, refresh_expires_at, refresh_issued_at = self._generate_jwt_token(\n            subject, settings.REFRESH_TOKEN_EXPIRE, refresh=True\n        )\n        return AccessTokenResponse(\n            token_type=\"Bearer\",\n            access_token=access_token,\n            expires_at=expires_at,\n            issued_at=issued_at,\n            refresh_token=refresh_token,\n            refresh_token_expires_at=refresh_expires_at,\n            refresh_token_issued_at=refresh_issued_at,\n        )", "\n\nclass JWTGenerator:\n    def __init__(self) -> None:\n        self.jwt_algorithm = \"HS256\"\n\n    def _generate_jwt_token(\n        self, subject: str | int, exp_secs: int, refresh: bool\n    ) -> Tuple[str, int, int]:\n        \"\"\"Creates jwt access or refresh token for user.\n\n        Args:\n            subject: anything unique to user, id or email etc.\n            exp_secs: expire time in seconds\n            refresh: if True, this is refresh token\n        \"\"\"\n\n        issued_at = int(time.time())\n        expires_at = issued_at + exp_secs\n\n        to_encode: dict[str, int | str | bool] = {\n            \"issued_at\": issued_at,\n            \"expires_at\": expires_at,\n            \"sub\": subject,\n            \"refresh\": refresh,\n        }\n        encoded_jwt = jwt.encode(\n            to_encode,\n            key=settings.SECRET_KEY,\n            algorithm=self.jwt_algorithm,\n        )\n        return encoded_jwt, expires_at, issued_at\n\n    def generate_access_token(self, subject: str | int) -> AccessTokenResponse:\n        \"\"\"Generate tokens and return AccessTokenResponse\n\n        Args:\n            subject: anything unique to user, id or email etc.\n        \"\"\"\n\n        access_token, expires_at, issued_at = self._generate_jwt_token(\n            subject, settings.ACCESS_TOKEN_EXPIRE, refresh=False\n        )\n        refresh_token, refresh_expires_at, refresh_issued_at = self._generate_jwt_token(\n            subject, settings.REFRESH_TOKEN_EXPIRE, refresh=True\n        )\n        return AccessTokenResponse(\n            token_type=\"Bearer\",\n            access_token=access_token,\n            expires_at=expires_at,\n            issued_at=issued_at,\n            refresh_token=refresh_token,\n            refresh_token_expires_at=refresh_expires_at,\n            refresh_token_issued_at=refresh_issued_at,\n        )", "\n\njwt_generator: JWTGenerator = JWTGenerator()\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/core/security/__init__.py", "chunked_list": [""]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/api/dependencies.py", "chunked_list": ["\"\"\"Dependency functions for the API.\"\"\"\nimport time\nfrom collections.abc import AsyncGenerator\nfrom typing import Callable, Type\n\nimport jwt\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom sqlalchemy.ext.asyncio import AsyncSession\n", "from sqlalchemy.ext.asyncio import AsyncSession\n\nfrom src.controllers import BaseController, UserController\nfrom src.core import config\nfrom src.core.db import async_db\nfrom src.core.security.jwt import jwt_generator\nfrom src.models import User\nfrom src.schemas import JWTTokenPayload\n\nreusable_oauth2 = OAuth2PasswordBearer(tokenUrl=\"auth/access-token\")", "\nreusable_oauth2 = OAuth2PasswordBearer(tokenUrl=\"auth/access-token\")\n\n\nasync def get_session() -> AsyncGenerator[AsyncSession, None]:\n    async with async_db.async_session() as session:\n        yield session\n\n\ndef get_controller(\n    controller_class: Type[BaseController],\n) -> Callable[[AsyncSession], BaseController]:\n    def _get_controller(session: AsyncSession = Depends(get_session)) -> BaseController:\n        return controller_class(session)\n\n    return _get_controller", "\ndef get_controller(\n    controller_class: Type[BaseController],\n) -> Callable[[AsyncSession], BaseController]:\n    def _get_controller(session: AsyncSession = Depends(get_session)) -> BaseController:\n        return controller_class(session)\n\n    return _get_controller\n\n", "\n\nasync def get_current_user(\n    token: str = Depends(reusable_oauth2),\n    controller: UserController = Depends(get_controller(UserController)),\n) -> User:\n    \"\"\"Get current user based on the information in the access token\n    This function is used as a dependency for all routes that require authentication.\n    \"\"\"\n    try:\n        payload = jwt.decode(\n            token, config.settings.SECRET_KEY, algorithms=[jwt_generator.jwt_algorithm]\n        )\n    except jwt.DecodeError:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Could not validate credentials.\",\n        )", "    \"\"\"\n    try:\n        payload = jwt.decode(\n            token, config.settings.SECRET_KEY, algorithms=[jwt_generator.jwt_algorithm]\n        )\n    except jwt.DecodeError:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Could not validate credentials.\",\n        )", "    # JWT guarantees payload will be unchanged (and thus valid), no errors here\n    token_data = JWTTokenPayload(**payload)\n\n    if token_data.refresh:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Could not validate credentials, cannot use refresh token\",\n        )\n    now = int(time.time())\n    if now < token_data.issued_at or now > token_data.expires_at:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Could not validate credentials, token expired or not yet valid\",\n        )", "    now = int(time.time())\n    if now < token_data.issued_at or now > token_data.expires_at:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Could not validate credentials, token expired or not yet valid\",\n        )\n\n    user = await controller.get_user_by_attribute(attribute=\"id\", value=token_data.sub)\n    return user\n", "    return user\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/api/router.py", "chunked_list": ["from fastapi import APIRouter\n\nfrom src.api.routes import auth, users\n\nrouter = APIRouter()\nrouter.include_router(auth.router, prefix=\"/auth\", tags=[\"auth\"])\nrouter.include_router(users.router, prefix=\"/users\", tags=[\"users\"])\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/api/__init__.py", "chunked_list": [""]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/api/routes/auth.py", "chunked_list": ["import time\n\nimport jwt\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordRequestForm\nfrom pydantic import ValidationError\n\nfrom src.api.dependencies import get_controller\nfrom src.controllers import UserController\nfrom src.core import config", "from src.controllers import UserController\nfrom src.core import config\nfrom src.core.security.jwt import jwt_generator\nfrom src.core.security.password import password_generator\nfrom src.schemas import AccessTokenResponse, JWTTokenPayload, RefreshTokenRequest\n\nrouter = APIRouter()\n\n\n@router.post(\"/access-token\", response_model=AccessTokenResponse)", "\n@router.post(\"/access-token\", response_model=AccessTokenResponse)\nasync def login_access_token(\n    controller: UserController = Depends(get_controller(UserController)),\n    form_data: OAuth2PasswordRequestForm = Depends(),\n):\n    \"\"\"OAuth2 compatible token, get an access token for future requests using username and password\"\"\"\n\n    user = await controller.get_user_by_attribute(\n        attribute=\"email\", value=form_data.username", "    user = await controller.get_user_by_attribute(\n        attribute=\"email\", value=form_data.username\n    )\n\n    if not password_generator.verify_password(form_data.password, user.password):\n        raise HTTPException(status_code=400, detail=\"Incorrect password\")\n\n    return jwt_generator.generate_access_token(str(user.id))\n\n", "\n\n@router.post(\"/refresh-token\", response_model=AccessTokenResponse)\nasync def refresh_token(\n    input: RefreshTokenRequest,\n    controller: UserController = Depends(get_controller(UserController)),\n):\n    \"\"\"OAuth2 compatible token, get an access token for future requests using refresh token\"\"\"\n    try:\n        payload = jwt.decode(\n            input.refresh_token,\n            config.settings.SECRET_KEY,\n            algorithms=[jwt_generator.jwt_algorithm],\n        )\n    except (jwt.DecodeError, ValidationError):\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Could not validate credentials, unknown error\",\n        )", "    try:\n        payload = jwt.decode(\n            input.refresh_token,\n            config.settings.SECRET_KEY,\n            algorithms=[jwt_generator.jwt_algorithm],\n        )\n    except (jwt.DecodeError, ValidationError):\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Could not validate credentials, unknown error\",\n        )", "\n    token_data = JWTTokenPayload(**payload)\n\n    if not token_data.refresh:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Could not validate credentials, cannot use access token\",\n        )\n    now = int(time.time())\n    if now < token_data.issued_at or now > token_data.expires_at:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Could not validate credentials, token expired or not yet valid\",\n        )", "    now = int(time.time())\n    if now < token_data.issued_at or now > token_data.expires_at:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Could not validate credentials, token expired or not yet valid\",\n        )\n\n    user = await controller.get_user_by_attribute(attribute=\"id\", value=token_data.sub)\n\n    return jwt_generator.generate_access_token(str(user.id))", "\n    return jwt_generator.generate_access_token(str(user.id))\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/api/routes/users.py", "chunked_list": ["from fastapi import APIRouter, Depends\n\nfrom src.api import dependencies\nfrom src.controllers import UserController\nfrom src.models import User\nfrom src.schemas import UserCreateRequest, UserResponse, UserUpdateRequest\n\nrouter = APIRouter()\n\n", "\n\n@router.get(\"/me\", response_model=UserResponse)\nasync def read_current_user(\n    current_user: User = Depends(dependencies.get_current_user),\n):\n    \"\"\"Get current user\"\"\"\n    return current_user\n\n", "\n\n@router.delete(\"/me\", status_code=204)\nasync def delete_current_user(\n    current_user: User = Depends(dependencies.get_current_user),\n    controller: UserController = Depends(dependencies.get_controller(UserController)),\n):\n    \"\"\"Delete current user\"\"\"\n    await controller.delete_user_by_id(id=current_user.id)\n", "    await controller.delete_user_by_id(id=current_user.id)\n\n\n@router.get(\"/\", response_model=list[UserResponse])\nasync def get_users(\n    controller: UserController = Depends(dependencies.get_controller(UserController)),\n):\n    \"\"\"Get all users\"\"\"\n    users = await controller.get_users()\n    return list(users)", "    users = await controller.get_users()\n    return list(users)\n\n\n@router.get(\"/{id}\", response_model=UserResponse)\nasync def get_user(\n    id: str,\n    controller: UserController = Depends(dependencies.get_controller(UserController)),\n):\n    \"\"\"Get a user by id\"\"\"", "):\n    \"\"\"Get a user by id\"\"\"\n    user = await controller.get_user_by_attribute(attribute=\"id\", value=id)\n    return user\n\n\n@router.post(\"/register\", status_code=201, response_model=UserResponse)\nasync def register_new_user(\n    new_user: UserCreateRequest,\n    controller: UserController = Depends(dependencies.get_controller(UserController)),", "    new_user: UserCreateRequest,\n    controller: UserController = Depends(dependencies.get_controller(UserController)),\n):\n    \"\"\"Create new user\"\"\"\n    user = await controller.create_user(new_user=new_user)\n    return user\n\n\n@router.delete(\"/{id}\", status_code=204)\nasync def delete_user(", "@router.delete(\"/{id}\", status_code=204)\nasync def delete_user(\n    id: str,\n    controller: UserController = Depends(dependencies.get_controller(UserController)),\n    current_user: User = Depends(dependencies.get_current_user),\n):\n    \"\"\"Delete a user by id\"\"\"\n    await controller.delete_user_by_id(id=id)\n\n", "\n\n@router.patch(\"/{id}\", response_model=UserResponse)\nasync def update_user(\n    id: str,\n    update_user: UserUpdateRequest,\n    controller: UserController = Depends(dependencies.get_controller(UserController)),\n    current_user: User = Depends(dependencies.get_current_user),\n):\n    \"\"\"Update user data\"\"\"", "):\n    \"\"\"Update user data\"\"\"\n    user = await controller.update_user_by_id(id=id, user_update=update_user)\n    return user\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/api/routes/__init__.py", "chunked_list": [""]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/controllers/base.py", "chunked_list": ["from sqlalchemy.ext.asyncio import AsyncSession\n\n\nclass BaseController:\n    def __init__(self, session: AsyncSession):\n        self.session = session\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/controllers/users.py", "chunked_list": ["from typing import Sequence\n\nfrom fastapi import HTTPException\nfrom sqlalchemy import delete, select, update\n\nfrom src.controllers.base import BaseController\nfrom src.core.security.password import password_generator\nfrom src.models import User\nfrom src.schemas import UserCreateRequest, UserUpdateRequest\n", "from src.schemas import UserCreateRequest, UserUpdateRequest\n\n\nclass UserController(BaseController):\n    async def get_users(self) -> Sequence[User]:\n        \"\"\"Get all users in the database\"\"\"\n\n        result = await self.session.execute(select(User))\n        return result.scalars().all()\n\n    async def get_user_by_attribute(self, attribute: str, value: str) -> User:\n        \"\"\"Returns a user in the database by the given attribute\"\"\"\n\n        attribute_obj = getattr(User, attribute)\n        result = await self.session.execute(select(User).where(attribute_obj == value))\n        user = result.scalar()\n        if not user:\n            raise HTTPException(status_code=404, detail=\"User not found.\")\n\n        return user\n\n    async def create_user(self, new_user: UserCreateRequest) -> User:\n        \"\"\"Create a new user in the database\"\"\"\n\n        result = await self.session.execute(\n            select(User).where(User.email == new_user.email)\n        )\n        if result.scalar() is not None:\n            raise HTTPException(status_code=400, detail=\"Cannot use this email address\")\n\n        user = User(\n            email=new_user.email,\n            password=password_generator.get_password_hash(new_user.password),\n        )\n        self.session.add(user)\n        await self.session.commit()\n        await self.session.refresh(user)\n\n        return user\n\n    async def update_user_by_id(self, id: str, user_update: UserUpdateRequest) -> User:\n        \"\"\"Update a user information in the database by id\"\"\"\n\n        new_user_data = user_update.dict(exclude_unset=True)\n\n        user = await self.get_user_by_attribute(attribute=\"id\", value=id)\n\n        await self.session.execute(\n            update(User).where(User.id == id).values(**new_user_data)\n        )\n        await self.session.commit()\n        await self.session.refresh(user)\n\n        return user\n\n    async def delete_user_by_id(self, id: str) -> None:\n        \"\"\"Delete a user in the database by id\"\"\"\n\n        await self.get_user_by_attribute(attribute=\"id\", value=id)\n\n        await self.session.execute(delete(User).where(User.id == id))\n        await self.session.commit()", ""]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/controllers/__init__.py", "chunked_list": ["from .base import BaseController\nfrom .users import UserController\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/migrations/env.py", "chunked_list": ["import asyncio\nfrom logging.config import fileConfig\n\nfrom alembic import context\nfrom sqlalchemy import engine_from_config, pool\nfrom sqlalchemy.ext.asyncio import AsyncEngine\n\nfrom src.core import config as app_config\n\n# this is the Alembic Config object, which provides", "\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\n\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nfileConfig(config.config_file_name)  # type: ignore\n\n# add your model's MetaData object here", "\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata\nfrom src.models import Base  # noqa\n\ntarget_metadata = Base.metadata\n\n# other values from the config, defined by the needs of env.py,", "\n# other values from the config, defined by the needs of env.py,\n# can be acquired:\n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\n\n\ndef get_database_uri():\n    return app_config.settings.DATABASE_URI\n", "\n\ndef run_migrations_offline():\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    url = get_database_uri()\n    context.configure(\n        url=url,\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n        compare_type=True,\n        compare_server_default=True,\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()", "\n\ndef do_run_migrations(connection):\n    context.configure(\n        connection=connection, target_metadata=target_metadata, compare_type=True\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()\n", "\n\nasync def run_migrations_online():\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    configuration = config.get_section(config.config_ini_section)", "    \"\"\"\n    configuration = config.get_section(config.config_ini_section)\n    assert configuration\n    configuration[\"sqlalchemy.url\"] = get_database_uri()\n    connectable = AsyncEngine(\n        engine_from_config(\n            configuration,\n            prefix=\"sqlalchemy.\",\n            poolclass=pool.NullPool,\n            future=True,", "            poolclass=pool.NullPool,\n            future=True,\n        )  # type: ignore\n    )\n    async with connectable.connect() as connection:\n        await connection.run_sync(do_run_migrations)\n\n\nif context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    asyncio.run(run_migrations_online())", "if context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    asyncio.run(run_migrations_online())\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/migrations/versions/2023040500_rename_password_0a4b3a6eb149.py", "chunked_list": ["\"\"\"rename_password\n\nRevision ID: 0a4b3a6eb149\nRevises: 07c71f4389b6\nCreate Date: 2023-04-05 17:00:46.766553\n\n\"\"\"\nimport sqlalchemy as sa\nfrom alembic import op\n", "from alembic import op\n\n# revision identifiers, used by Alembic.\nrevision = \"0a4b3a6eb149\"\ndown_revision = \"07c71f4389b6\"\nbranch_labels = None\ndepends_on = None\n\n\ndef upgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table(\n        \"dog_model\",\n        sa.Column(\"id\", sa.UUID(as_uuid=False), nullable=False),\n        sa.Column(\"name\", sa.String(length=128), nullable=False),\n        sa.PrimaryKeyConstraint(\"id\"),\n    )\n    op.alter_column(\n        \"user_model\",\n        \"email\",\n        existing_type=sa.VARCHAR(length=254),\n        type_=sa.String(length=128),\n        existing_nullable=False,\n    )\n    op.drop_index(\"ix_user_model_email\", table_name=\"user_model\")\n    op.create_unique_constraint(None, \"user_model\", [\"email\"])", "\ndef upgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table(\n        \"dog_model\",\n        sa.Column(\"id\", sa.UUID(as_uuid=False), nullable=False),\n        sa.Column(\"name\", sa.String(length=128), nullable=False),\n        sa.PrimaryKeyConstraint(\"id\"),\n    )\n    op.alter_column(\n        \"user_model\",\n        \"email\",\n        existing_type=sa.VARCHAR(length=254),\n        type_=sa.String(length=128),\n        existing_nullable=False,\n    )\n    op.drop_index(\"ix_user_model_email\", table_name=\"user_model\")\n    op.create_unique_constraint(None, \"user_model\", [\"email\"])", "    # ### end Alembic commands ###\n\n\ndef downgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_constraint(None, \"user_model\", type_=\"unique\")\n    op.create_index(\"ix_user_model_email\", \"user_model\", [\"email\"], unique=False)\n    op.alter_column(\n        \"user_model\",\n        \"email\",\n        existing_type=sa.String(length=128),\n        type_=sa.VARCHAR(length=254),\n        existing_nullable=False,\n    )\n    op.drop_table(\"dog_model\")", "    # ### end Alembic commands ###\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/migrations/versions/2023020440_init_user_model_07c71f4389b6.py", "chunked_list": ["\"\"\"init_user_model\n\nRevision ID: 07c71f4389b6\nRevises:\nCreate Date: 2023-02-04 23:40:00.426237\n\n\"\"\"\nimport sqlalchemy as sa\nfrom alembic import op\n", "from alembic import op\n\n# revision identifiers, used by Alembic.\nrevision = \"07c71f4389b6\"\ndown_revision = None\nbranch_labels = None\ndepends_on = None\n\n\ndef upgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table(\n        \"user_model\",\n        sa.Column(\"id\", sa.UUID(), nullable=False),\n        sa.Column(\"email\", sa.String(length=254), nullable=False),\n        sa.Column(\"password\", sa.String(length=128), nullable=False),\n        sa.PrimaryKeyConstraint(\"id\"),\n    )\n    op.create_index(op.f(\"ix_user_model_email\"), \"user_model\", [\"email\"], unique=True)", "\ndef upgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table(\n        \"user_model\",\n        sa.Column(\"id\", sa.UUID(), nullable=False),\n        sa.Column(\"email\", sa.String(length=254), nullable=False),\n        sa.Column(\"password\", sa.String(length=128), nullable=False),\n        sa.PrimaryKeyConstraint(\"id\"),\n    )\n    op.create_index(op.f(\"ix_user_model_email\"), \"user_model\", [\"email\"], unique=True)", "    # ### end Alembic commands ###\n\n\ndef downgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_index(op.f(\"ix_user_model_email\"), table_name=\"user_model\")\n    op.drop_table(\"user_model\")\n    # ### end Alembic commands ###\n", ""]}
