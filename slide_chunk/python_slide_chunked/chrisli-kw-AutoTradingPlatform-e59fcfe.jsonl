{"filename": "run.py", "chunked_list": ["import os\nimport logging\nimport pandas as pd\nfrom argparse import ArgumentParser\n\nfrom trader import __version__ as ver\nfrom trader.config import TODAY_STR, holidays\nfrom trader.tasker import Tasks\n\n\ndef parse_args():\n    \"\"\"\n    \u57f7\u884c\u6307\u4ee4:$ python run.py -TASK auto_trader -ACCT account_name\n\n    \u53c3\u6578\u8aaa\u660e:\n    1. task(\u57f7\u884c\u7684\u76ee\u6a19\u7a0b\u5f0f): auto_trader, account_info, update_and_select_stock\n    2. account(\u4ee3\u865f): \u82e5 task == 'auto_trader', \u9700\u6307\u5b9a\u8981\u57f7\u884c\u7684\u5e33\u6236\u4ee3\u865f\n\n    \"\"\"\n    parser = ArgumentParser()\n    parser.add_argument(\n        '--task', '-TASK', type=str, default='auto_trader', help='\u57f7\u884c\u7684\u76ee\u6a19\u7a0b\u5f0f')\n    parser.add_argument(\n        '--account', '-ACCT', type=str, default='chrisli_1', help='\u4ee3\u865f')\n    args = parser.parse_args()\n    return (args)", "\n\ndef parse_args():\n    \"\"\"\n    \u57f7\u884c\u6307\u4ee4:$ python run.py -TASK auto_trader -ACCT account_name\n\n    \u53c3\u6578\u8aaa\u660e:\n    1. task(\u57f7\u884c\u7684\u76ee\u6a19\u7a0b\u5f0f): auto_trader, account_info, update_and_select_stock\n    2. account(\u4ee3\u865f): \u82e5 task == 'auto_trader', \u9700\u6307\u5b9a\u8981\u57f7\u884c\u7684\u5e33\u6236\u4ee3\u865f\n\n    \"\"\"\n    parser = ArgumentParser()\n    parser.add_argument(\n        '--task', '-TASK', type=str, default='auto_trader', help='\u57f7\u884c\u7684\u76ee\u6a19\u7a0b\u5f0f')\n    parser.add_argument(\n        '--account', '-ACCT', type=str, default='chrisli_1', help='\u4ee3\u865f')\n    args = parser.parse_args()\n    return (args)", "\n\nargs = parse_args()\ntask = args.task\naccount = args.account\nfilename = account if task == 'auto_trader' else task\n\nfor handler in logging.root.handlers[:]:\n    logging.root.removeHandler(handler)\n", "\nlogging.basicConfig(\n    level=logging.DEBUG,\n    format='%(asctime)s.%(msecs)03d|%(levelname)s: %(message)s',\n    datefmt='%Y-%m-%d %a %H:%M:%S',\n    handlers=[\n            logging.FileHandler(f'./logs/{filename}.log', 'a', encoding='utf-8'),\n            logging.StreamHandler()\n    ]\n)", "    ]\n)\nlogging.info('\u2014'*100)\nlogging.info(f'Current trader version is {ver}')\n\nif __name__ == \"__main__\":\n    date = pd.to_datetime(TODAY_STR)\n    if task != 'create_env' and date in holidays:\n        logging.warning(f'{holidays[date]}\u4e0d\u958b\u76e4')\n    elif task in Tasks:\n        functions = Tasks[task]\n        for func in functions:\n            if func.__name__ in ['runAutoTrader', 'runCrawlStockData']:\n                func(account)\n            else:\n                func()\n    else:\n        logging.warning(f\"The input task \u3010{task}\u3011 does not exist.\")\n\n    logging.debug('End of tasker')\n    os._exit(0)", ""]}
{"filename": "trader/APItest.py", "chunked_list": ["import time\nimport shioaji as sj\nfrom dotenv import dotenv_values\n\nfrom .config import TODAY\nfrom .utils.time import TimeTool\n\n\nclass APITester(TimeTool):\n    '''API\u4e32\u63a5\u6e2c\u8a66\uff0c\u6b63\u5f0f\u4e0b\u55ae\u524d\uff0c\u5fc5\u9808\u5148\u7d93\u904e\u6e2c\u8a66\uff0c\u624d\u53ef\u958b\u901a\u4e0b\u55ae\u529f\u80fd'''\n\n    def simulation_test(self, API_KEY, SECRET_KEY, acct):\n        api = sj.Shioaji(simulation=True)\n        api.login(API_KEY, SECRET_KEY)\n\n        is_simulate = api.simulation\n        if is_simulate:\n            print(f\"Log in to {acct} with simulation mode: {is_simulate}\")\n            time.sleep(30)\n        else:\n            print(f\"Log in to {acct} with real mode, log out\")\n            api.logout()\n            return\n\n        # \u80a1\u7968\u4e0b\u55ae\u6e2c\u8a66\n        stockid = '2603'\n        contract = api.Contracts.Stocks[stockid]\n        order = api.Order(\n            action=sj.constant.Action.Buy,\n            price=18,\n            quantity=1,\n            price_type=sj.constant.StockPriceType.LMT,\n            order_type=sj.constant.OrderType.ROD,\n            order_lot=sj.constant.StockOrderLot.Common,\n\n            account=api.stock_account\n        )\n        print(f'Stock order content:\\n{order}')\n\n        print('Place stock order')\n        trade = api.place_order(contract, order, timeout=0)\n        print(f'Done:\\n{trade}')\n        time.sleep(2)\n\n        # \u671f\u8ca8\u4e0b\u55ae\u6e2c\u8a66\n        futuresid = f'MXF{self.GetDueMonth(TODAY)}'\n        contract = api.Contracts.Futures.MXF[futuresid]\n        order = api.Order(\n            action=sj.constant.Action.Buy,\n            price=15000,\n            quantity=1,\n            price_type=sj.constant.FuturesPriceType.LMT,\n            order_type=sj.constant.OrderType.ROD,\n            octype=sj.constant.FuturesOCType.Auto,\n            account=api.futopt_account,\n        )\n        print(f'Futures order content:\\n{order}')\n        print('Place futures order')\n        trade = api.place_order(contract, order, timeout=0)\n        print(f'Done:\\n{trade}')\n\n        print(f'Log out {acct}: {api.logout()}\\n')\n\n    def verify_test(self, API_KEY, SECRET_KEY, acct):\n        api = sj.Shioaji(simulation=False)\n        api.login(API_KEY, SECRET_KEY)\n        print(f\"Log in to {acct} with real mode\")\n        time.sleep(10)\n\n        accounts = api.list_accounts()\n        for acct in accounts:\n            print(f'Account {acct.account_id}: {acct.signed}')\n\n        print(f'Log out {acct}: {api.logout()}\\n')\n\n    def run(self, account):\n        '''Shioaji \u5e33\u865f\u6e2c\u8a66'''\n\n        for i in range(2):\n            config = dotenv_values(f'./lib/envs/{account}.env')\n            API_KEY = config['API_KEY']\n            SECRET_KEY = config['SECRET_KEY']\n\n            if i == 0:\n                self.simulation_test(API_KEY, SECRET_KEY, account)\n                self.CountDown(720)\n            else:\n                self.verify_test(API_KEY, SECRET_KEY, account)", "class APITester(TimeTool):\n    '''API\u4e32\u63a5\u6e2c\u8a66\uff0c\u6b63\u5f0f\u4e0b\u55ae\u524d\uff0c\u5fc5\u9808\u5148\u7d93\u904e\u6e2c\u8a66\uff0c\u624d\u53ef\u958b\u901a\u4e0b\u55ae\u529f\u80fd'''\n\n    def simulation_test(self, API_KEY, SECRET_KEY, acct):\n        api = sj.Shioaji(simulation=True)\n        api.login(API_KEY, SECRET_KEY)\n\n        is_simulate = api.simulation\n        if is_simulate:\n            print(f\"Log in to {acct} with simulation mode: {is_simulate}\")\n            time.sleep(30)\n        else:\n            print(f\"Log in to {acct} with real mode, log out\")\n            api.logout()\n            return\n\n        # \u80a1\u7968\u4e0b\u55ae\u6e2c\u8a66\n        stockid = '2603'\n        contract = api.Contracts.Stocks[stockid]\n        order = api.Order(\n            action=sj.constant.Action.Buy,\n            price=18,\n            quantity=1,\n            price_type=sj.constant.StockPriceType.LMT,\n            order_type=sj.constant.OrderType.ROD,\n            order_lot=sj.constant.StockOrderLot.Common,\n\n            account=api.stock_account\n        )\n        print(f'Stock order content:\\n{order}')\n\n        print('Place stock order')\n        trade = api.place_order(contract, order, timeout=0)\n        print(f'Done:\\n{trade}')\n        time.sleep(2)\n\n        # \u671f\u8ca8\u4e0b\u55ae\u6e2c\u8a66\n        futuresid = f'MXF{self.GetDueMonth(TODAY)}'\n        contract = api.Contracts.Futures.MXF[futuresid]\n        order = api.Order(\n            action=sj.constant.Action.Buy,\n            price=15000,\n            quantity=1,\n            price_type=sj.constant.FuturesPriceType.LMT,\n            order_type=sj.constant.OrderType.ROD,\n            octype=sj.constant.FuturesOCType.Auto,\n            account=api.futopt_account,\n        )\n        print(f'Futures order content:\\n{order}')\n        print('Place futures order')\n        trade = api.place_order(contract, order, timeout=0)\n        print(f'Done:\\n{trade}')\n\n        print(f'Log out {acct}: {api.logout()}\\n')\n\n    def verify_test(self, API_KEY, SECRET_KEY, acct):\n        api = sj.Shioaji(simulation=False)\n        api.login(API_KEY, SECRET_KEY)\n        print(f\"Log in to {acct} with real mode\")\n        time.sleep(10)\n\n        accounts = api.list_accounts()\n        for acct in accounts:\n            print(f'Account {acct.account_id}: {acct.signed}')\n\n        print(f'Log out {acct}: {api.logout()}\\n')\n\n    def run(self, account):\n        '''Shioaji \u5e33\u865f\u6e2c\u8a66'''\n\n        for i in range(2):\n            config = dotenv_values(f'./lib/envs/{account}.env')\n            API_KEY = config['API_KEY']\n            SECRET_KEY = config['SECRET_KEY']\n\n            if i == 0:\n                self.simulation_test(API_KEY, SECRET_KEY, account)\n                self.CountDown(720)\n            else:\n                self.verify_test(API_KEY, SECRET_KEY, account)", "\n\nif __name__ == \"__main__\":\n    tester = APITester()\n\n    account = 'test_account_1'\n    tester.run(account)\n"]}
{"filename": "trader/tasker.py", "chunked_list": ["import time\nimport logging\nimport pandas as pd\nfrom datetime import datetime\nfrom dotenv import dotenv_values\nfrom concurrent.futures import as_completed\n\nfrom . import executor, notifier, picker, crawler1, crawler2, tdp, file_handler\nfrom .config import API, PATH, TODAY_STR, ACCOUNTS, TEnd, ConvertScales\nfrom .create_env import app", "from .config import API, PATH, TODAY_STR, ACCOUNTS, TEnd, ConvertScales\nfrom .create_env import app\nfrom .utils.database import redis_tick\nfrom .utils.subscribe import Subscriber\nfrom .utils.accounts import AccountInfo\nfrom .executor import StrategyExecutor\nfrom .performance.reports import PerformanceReport\n\ntry:\n    from .scripts.TaskList import customTasks\nexcept:\n    customTasks = {}", "try:\n    from .scripts.TaskList import customTasks\nexcept:\n    customTasks = {}\n\n\ndef runCreateENV():\n    file_handler.create_folder('./lib')\n    file_handler.create_folder('./lib/envs')\n    file_handler.create_folder('./lib/schedules')\n    app.run()", "\n\ndef runPerformanceReport(start=None, end=None):\n    try:\n        logging.debug(f'ACCOUNTS: {ACCOUNTS}')\n        for env in ACCOUNTS:\n            logging.debug(f'Load \u3010{env}\u3011 config')\n            config = dotenv_values(f'./lib/envs/{env}.env')\n\n            pr = PerformanceReport(env)\n            Tables = pr.getTables(config, start=start, end=end)\n            if Tables is not None:\n                pr.save_tables(Tables)\n                pr.plot_performance_report(Tables, save=True)\n\n                notifier.post(\n                    pr.TablesFile.split('/')[-1][:-5],\n                    image_name=pr.TablesFile.replace('xlsx', 'jpg'),\n                    msgType='AccountInfo'\n                )\n    except:\n        logging.exception('Catch an exception:')\n        notifier.post('\\n\u3010Error\u3011\u3010\u5e33\u52d9\u8cc7\u8a0a\u67e5\u8a62\u3011\u767c\u751f\u7570\u5e38', msgType='Tasker')\n        API.logout()", "\n\ndef runAccountInfo():\n    account = AccountInfo()\n    df = account.create_info_table()\n    tables = {}\n\n    try:\n        logging.debug(f'ACCOUNTS: {ACCOUNTS}')\n        for env in ACCOUNTS:\n            logging.debug(f'Load \u3010{env}\u3011 config')\n            config = dotenv_values(f'./lib/envs/{env}.env')\n\n            API_KEY = config['API_KEY']\n            SECRET_KEY = config['SECRET_KEY']\n            acct = config['ACCOUNT_NAME']\n            account._login(API_KEY, SECRET_KEY, acct)\n            time.sleep(1)\n\n            row = account.query_all()\n            if row:\n                for i, data in enumerate(row):\n                    if i < 3:\n                        logging.info(f\"{data}\uff1a {row[data]}\")\n                    else:\n                        logging.info(f\"{data}\uff1a NT$ {'{:,}'.format(row[data])}\")\n\n                if hasattr(df, 'sheet_names') and acct in df.sheet_names:\n                    tb = account.update_info(df, row)\n                else:\n                    tb = pd.DataFrame([row])\n\n                tables[acct] = tb\n\n                # \u63a8\u64ad\u8a0a\u606f\n                account_id = API.stock_account.account_id\n                notifier.post_account_info(account_id, row)\n            elif hasattr(df, 'sheet_names') and account.account_name in df.sheet_names:\n                tables[acct] = pd.read_excel(df, sheet_name=env)\n            else:\n                tables[acct] = account.DEFAULT_TABLE\n\n            # \u767b\u51fa\n            time.sleep(5)\n            logging.info(f'\u767b\u51fa\u7cfb\u7d71: {API.logout()}')\n            time.sleep(10)\n\n        logging.info('\u5132\u5b58\u8cc7\u8a0a')\n        writer = pd.ExcelWriter(\n            f'{PATH}/daily_info/{account.filename}', engine='xlsxwriter')\n\n        for sheet in tables:\n            try:\n                tables[sheet].to_excel(\n                    writer, encoding='utf-8-sig', index=False, sheet_name=sheet)\n            except:\n                logging.exception('Catch an exception:')\n                tables[sheet].to_excel(\n                    sheet+'.csv', encoding='utf-8-sig', index=False)\n        writer.save()\n    except:\n        logging.exception('Catch an exception:')\n        notifier.post('\\n\u3010Error\u3011\u3010\u5e33\u52d9\u8cc7\u8a0a\u67e5\u8a62\u3011\u767c\u751f\u7570\u5e38', msgType='Tasker')\n        API.logout()", "\n\ndef runAutoTrader(account):\n    try:\n        config = dotenv_values(f'./lib/envs/{account}.env')\n        se = StrategyExecutor(config=config)\n        se.login_and_activate()\n        se.run()\n    except KeyboardInterrupt:\n        notifier.post(\n            f\"\\n\u3010Interrupt\u3011\u3010\u4e0b\u55ae\u6a5f\u76e3\u63a7\u3011{se.ACCOUNT_NAME}\u5df2\u624b\u52d5\u95dc\u9589\", msgType='Tasker')\n    except:\n        logging.exception('Catch an exception:')\n        notifier.post(\n            f\"\\n\u3010Error\u3011\u3010\u4e0b\u55ae\u6a5f\u76e3\u63a7\u3011{se.ACCOUNT_NAME}\u767c\u751f\u7570\u5e38\", msgType='Tasker')\n    finally:\n        try:\n            se.output_files()\n        except:\n            logging.exception('Catch an exception (output_files):')\n            notifier.post(\n                f\"\\n\u3010Error\u3011\u3010\u4e0b\u55ae\u6a5f\u76e3\u63a7\u3011{se.ACCOUNT_NAME}\u8cc7\u6599\u5132\u5b58\u5931\u6557\", msgType='Tasker')\n\n        logging.info(f'\u767b\u51fa\u7cfb\u7d71: {API.logout()}')\n        notifier.post(f\"\\n\u3010\u505c\u6b62\u76e3\u63a7\u3011{se.ACCOUNT_NAME}\u95dc\u9589\u7a0b\u5f0f\u4e26\u767b\u51fa\", msgType='Tasker')\n\n    del se", "\n\ndef runCrawlStockData(account):\n    target = pd.to_datetime('15:05:00')\n    config = dotenv_values(f'./lib/envs/{account}.env')\n    aInfo = AccountInfo()\n\n    try:\n        now = datetime.now()\n        if now < target:\n            logging.info(\n                f'Current time is still early, will start to crawl after {target}')\n            aInfo.CountDown(target)\n\n        logging.info('\u958b\u59cb\u722c\u87f2')\n\n        # \u767b\u5165\n        API_KEY = config['API_KEY']\n        SECRET_KEY = config['SECRET_KEY']\n        acct = config['ACCOUNT_NAME']\n        aInfo._login(API_KEY, SECRET_KEY, acct)\n        time.sleep(30)\n\n        # \u66f4\u65b0\u80a1\u7968\u6e05\u55ae\n        logging.info('Updating stock list')\n        stock_list = crawler1.get_security_list(stock_only=True)\n        crawler1.export_security_list(stock_list)\n\n        # \u722c\u7576\u5929\u80a1\u50f9\u8cc7\u6599\n        crawler1.crawl_from_sinopac(stockids='all', update=True)\n        crawler1.merge_stockinfo()\n\n        # \u66f4\u65b0\u6b77\u53f2\u8cc7\u6599\n        for scale in ConvertScales:\n            crawler1.add_new_data(scale, save=True, start=TODAY_STR)\n            crawler1.merge_daily_data(TODAY_STR, scale, save=True)\n        crawler1.merge_daily_data(TODAY_STR, '1T', save=True)\n\n    except KeyboardInterrupt:\n        notifier.post(f\"\\n\u3010Interrupt\u3011\u3010\u722c\u87f2\u7a0b\u5f0f\u3011\u5df2\u624b\u52d5\u95dc\u9589\", msgType='Tasker')\n    except:\n        logging.exception('Catch an exception:')\n        notifier.post(f\"\\n\u3010Error\u3011\u3010\u722c\u87f2\u7a0b\u5f0f\u3011\u80a1\u50f9\u722c\u87f2\u767c\u751f\u7570\u5e38\", msgType='Tasker')\n        if len(crawler1.StockData):\n            df = pd.concat(crawler1.StockData)\n            filename = f'{crawler1.folder_path}/stock_data_1T.pkl'\n            file_handler.save_table(df, filename)\n    finally:\n        logging.info(f'\u767b\u51fa\u7cfb\u7d71: {API.logout()}')", "\n\ndef runSelectStock():\n    try:\n        df = picker.pick(3, 1.8, 3)\n        df = picker.melt_table(df)\n        tb = df[df.Time == TODAY_STR].reset_index(drop=True)\n        picker.export(tb)\n        notifier.post_stock_selection(tb)\n\n    except FileNotFoundError as e:\n        logging.warning(f'{e} No stock is selected.')\n    except KeyboardInterrupt:\n        notifier.post(f\"\\n\u3010Interrupt\u3011\u3010\u9078\u80a1\u7a0b\u5f0f\u3011\u5df2\u624b\u52d5\u95dc\u9589\", msgType='Tasker')\n    except:\n        logging.exception('Catch an exception:')\n        notifier.post(f\"\\n\u3010Error\u3011\u3010\u9078\u80a1\u7a0b\u5f0f\u3011\u9078\u80a1\u767c\u751f\u7570\u5e38\", msgType='Tasker')", "\n\ndef runCrawlFromHTML():\n    try:\n        # update PutCallRatio\n        step = 'PutCallRatio'\n        df_pcr_new = crawler2.put_call_ratio()\n        crawler2.export_put_call_ratio(df_pcr_new)\n        # notifier.post_put_call_ratio(df_pcr_new)\n\n        # \u722c\u9664\u6b0a\u606f\u8cc7\u6599\n        step = '\u722c\u9664\u6b0a\u606f\u8cc7\u6599'\n        dividends = crawler2.ex_dividend_list()\n        crawler2.export_ex_dividend_list(dividends)\n\n        # \u671f\u8ca8\u9010\u7b46\u6210\u4ea4\u8cc7\u6599\n        step = '\u671f\u8ca8\u9010\u7b46\u6210\u4ea4\u8cc7\u6599'\n        crawler2.get_FuturesTickData(TODAY_STR)\n\n        # \u8f49\u63db&\u66f4\u65b0\u671f\u8ca8\u9010\u7b46\u6210\u4ea4\u8cc7\u6599\n        df = tdp.convert_daily_tick(TODAY_STR, '1T')\n        crawler2.export_futures_kbar(df)\n\n    except KeyboardInterrupt:\n        notifier.post(f\"\\n\u3010Interrupt\u3011\u3010\u722c\u87f2\u7a0b\u5f0f\u3011\u5df2\u624b\u52d5\u95dc\u9589\", msgType='Tasker')\n    except:\n        logging.exception('Catch an exception:')\n        notifier.post(f\"\\n\u3010Error\u3011\u3010\u722c\u87f2\u7a0b\u5f0f\u3011{step}\u767c\u751f\u7570\u5e38\", msgType='Tasker')", "\n\ndef thread_subscribe(user, targets):\n    import shioaji as sj\n\n    subscriber = Subscriber()\n    api = sj.Shioaji()\n\n    @api.quote.on_event\n    def event_callback(resp_code: int, event_code: int, info: str, event: str):\n        if 'Subscription Not Found' in info:\n            logging.warning(info)\n        else:\n            logging.info(\n                f'Response code: {resp_code} | Event code: {event_code} | info: {info} | Event: {event}')\n\n    @api.on_quote_stk_v1()\n    def stk_quote_callback_v1(exchange, tick):\n        if tick.intraday_odd == 0 and tick.simtrade == 0:\n            tick_data = subscriber.stk_quote_v1(tick)\n            redis_tick.to_redis({tick.code: tick_data})\n\n    config = dotenv_values(f'./lib/envs/{user}.env')\n    API_KEY = config['API_KEY']\n    SECRET_KEY = config['SECRET_KEY']\n    api.login(API_KEY, SECRET_KEY)\n    time.sleep(2)\n\n    try:\n        logging.info('subscribe_targets')\n        for t in targets:\n            if t[:3] in api.Contracts.Indexs.__dict__:\n                target = api.Contracts.Indexs[t[:3]][t]\n            elif t[:3] in api.Contracts.Futures.__dict__:\n                target = api.Contracts.Futures[t[:3]][t]\n            elif t[:3] in api.Contracts.Options.__dict__:\n                target = api.Contracts.Options[t[:3]][t]\n            else:\n                target = api.Contracts.Stocks[t]\n            api.quote.subscribe(target, quote_type='tick', version='v1')\n\n        logging.info(f'Done subscribe {len(targets)} targets')\n\n        now = datetime.now()\n        time.sleep(max((TEnd - now).total_seconds(), 0))\n    except:\n        logging.exception('Catch an exception:')\n    finally:\n        logging.info(f'{datetime.now()} is log-out: {api.logout()}')\n        time.sleep(10)\n    return \"Task completed\"", "\n\ndef runShioajiSubscriber():\n    # TODO: \u8b80\u53d6\u8981\u76e4\u4e2d\u9078\u80a1\u7684\u80a1\u7968\u6c60\n    df = file_handler.read_table(f'{PATH}/selections/stock_list.xlsx')\n    codes = df[df.exchange.isin(['TSE', 'OTC'])].code.astype(str).values\n\n    N = 200\n    futures = []\n    for i, user in enumerate(ACCOUNTS):\n        targets = codes[N*i:N*(i+1)]\n        future = executor.submit(thread_subscribe, user, targets)\n        futures.append(future)\n\n    for future in as_completed(futures):\n        logging.info(future.result())", "\n\ndef runSimulationChecker():\n    try:\n        for account in ACCOUNTS:\n            config = dotenv_values(f'./lib/envs/{account}.env')\n\n            if config['MODE'] == 'Simulation':\n                se = StrategyExecutor(config=config)\n\n                # check stock pool size\n                watchlist = se.watchlist[se.watchlist.market == 'Stocks']\n                stocks = se.get_securityInfo('Stocks')\n                is_same_shape = watchlist.shape[0] == stocks.shape[0]\n                if not is_same_shape:\n                    text = f'\\n\u3010{account} \u5eab\u5b58\u4e0d\u4e00\u81f4\u3011'\n                    text += f'\\nSize: watchlist {watchlist.shape[0]}; stocks: {stocks.shape[0]}'\n                    text += f'\\nwatchlist day start: {watchlist.buyday.min()}'\n                    text += f'\\nwatchlist day end: {watchlist.buyday.max()}'\n                    text += f'\\nwatchlist - stocks: {set(watchlist.code) - set(stocks.code)}'\n                    text += f'\\nstocks - watchlist: {set(stocks.code) - set(watchlist.code)}'\n\n                    notifier.post(text, msgType='Monitor')\n\n    except FileNotFoundError as e:\n        logging.warning(e)\n        notifier.post(f'\\n{e}', msgType='Tasker')\n    except:\n        logging.exception('Catch an exception:')\n        notifier.post('\\n\u3010Error\u3011\u3010\u6a21\u64ec\u5e33\u6236\u6aa2\u67e5\u3011\u767c\u751f\u7570\u5e38', msgType='Tasker')", "\n\nTasks = {\n    'create_env': [runCreateENV],\n    'account_info': [runAccountInfo, runPerformanceReport, runSimulationChecker],\n    'update_and_select_stock': [runCrawlStockData, runSelectStock, runCrawlFromHTML],\n    'crawl_stock_data': [runCrawlStockData],\n    'select_stock': [runSelectStock],\n    'crawl_html': [runCrawlFromHTML],\n    'auto_trader': [runAutoTrader],", "    'crawl_html': [runCrawlFromHTML],\n    'auto_trader': [runAutoTrader],\n    'subscribe': [runShioajiSubscriber],\n}\n\nfor taskName, tasks in customTasks.items():\n    if taskName in Tasks:\n        Tasks[taskName] += tasks\n    else:\n        Tasks[taskName] = tasks", ""]}
{"filename": "trader/config.py", "chunked_list": ["import logging\nimport pandas as pd\nimport configparser\nimport shioaji as sj\nfrom datetime import datetime, timedelta\n\n\nAPI = sj.Shioaji()\nTODAY = datetime.today()\nTODAY_STR = TODAY.strftime(\"%Y-%m-%d\")", "TODAY = datetime.today()\nTODAY_STR = TODAY.strftime(\"%Y-%m-%d\")\n\nSystemConfig = configparser.ConfigParser()\nSystemConfig.read('./lib/config.ini', encoding='utf8')\n\n\ndef getList(section, option):\n    content = SystemConfig.get(section, option)\n    if len(content) > 0:\n        return content.replace(' ', '').split(',')\n    return []", "\n\ndef get_settings(section, option, dataType='str'):\n    funcs = {\n        'str': SystemConfig.get,\n        'int': SystemConfig.getint,\n        'float': SystemConfig.getfloat,\n        'bool': SystemConfig.getboolean,\n        'list': getList\n    }\n    if section in SystemConfig.sections():\n        options = SystemConfig.options(section)\n        if options and option.lower() in options:\n            try:\n                return funcs[dataType](section, option)\n            except:\n                return SystemConfig.get(section, option)\n\n    if dataType == 'list':\n        return []\n    return ''", "\n\ndef get_holidays():\n    try:\n        df = pd.read_csv('./lib/\u653f\u5e9c\u884c\u653f\u6a5f\u95dc\u8fa6\u516c\u65e5\u66c6\u8868.csv')\n        df.date = pd.to_datetime(df.date)\n        df.name = df.name.fillna(df.holidayCategory)\n        holidays = df.set_index('date').name.to_dict()\n\n        eves = {k: v for k, v in holidays.items() if v == '\u8fb2\u66c6\u9664\u5915'}\n        for i in range(2):\n            days = {d - timedelta(days=i+1) if d - timedelta(days=i+1)\n                    not in holidays else d - timedelta(days=i+2): '\u5e74\u524d\u5c01\u95dc' for d in eves}\n            holidays.update(days)\n        return holidays\n    except:\n        logging.warning('Run trader without holiday data.')\n        return {}", "\n\n# \u4f7f\u7528\u8005\u76f8\u95dc\nACCOUNTS = get_settings(\"ACCOUNT\", \"USERS\", dataType='list')\n\n# \u8cc7\u6599\u5eab\u76f8\u95dc\nREDIS_HOST = get_settings('DB', 'REDIS_HOST')\nREDIS_PORT = get_settings('DB', 'REDIS_PORT', dataType='int')\nREDIS_PWD = get_settings('DB', 'REDIS_PWD')\nHAS_REDIS = all(x for x in [REDIS_HOST, REDIS_PORT, REDIS_PWD])", "REDIS_PWD = get_settings('DB', 'REDIS_PWD')\nHAS_REDIS = all(x for x in [REDIS_HOST, REDIS_PORT, REDIS_PWD])\n\nDB_HOST = get_settings('DB', 'DB_HOST')\nDB_PORT = get_settings('DB', 'DB_PORT', dataType='int')\nDB_USER = get_settings('DB', 'DB_USER')\nDB_PWD = get_settings('DB', 'DB_PWD')\nDB_NAME = get_settings('DB', 'DB_NAME')\nHAS_DB = all(x for x in [DB_HOST, DB_NAME, DB_PORT, DB_PWD, DB_USER])\nDB_URL = f'{DB_USER}:{DB_PWD}@{DB_HOST}:{DB_PORT}' if HAS_DB else ''", "HAS_DB = all(x for x in [DB_HOST, DB_NAME, DB_PORT, DB_PWD, DB_USER])\nDB_URL = f'{DB_USER}:{DB_PWD}@{DB_HOST}:{DB_PORT}' if HAS_DB else ''\n\nPATH = get_settings('DATA', 'DATA_PATH')\n\n# LINE notify\nTOKEN_MONITOR = get_settings('LINENOTIFY', 'TOKEN_MONITOR')\nTOKEN_INFO = get_settings('LINENOTIFY', 'TOKEN_INFO')\n\n\nclass StrategyNameList:\n    StrategyLongNDT = get_settings('STRATEGY', 'Long', dataType='list')\n    StrategyShortNDT = get_settings('STRATEGY', 'Short', dataType='list')\n    StrategyLongDT = get_settings('STRATEGY', 'LongDT', dataType='list')\n    StrategyShortDT = get_settings('STRATEGY', 'ShortDT', dataType='list')\n\n    All = StrategyLongNDT + StrategyLongDT + StrategyShortNDT + StrategyShortDT\n    Long = StrategyLongNDT + StrategyLongDT\n    Short = StrategyShortNDT + StrategyShortDT\n    DayTrade = StrategyLongDT + StrategyShortDT\n    Code = {stra: f'Strategy{i+1}' for i, stra in enumerate(All)}", "\n\nclass StrategyNameList:\n    StrategyLongNDT = get_settings('STRATEGY', 'Long', dataType='list')\n    StrategyShortNDT = get_settings('STRATEGY', 'Short', dataType='list')\n    StrategyLongDT = get_settings('STRATEGY', 'LongDT', dataType='list')\n    StrategyShortDT = get_settings('STRATEGY', 'ShortDT', dataType='list')\n\n    All = StrategyLongNDT + StrategyLongDT + StrategyShortNDT + StrategyShortDT\n    Long = StrategyLongNDT + StrategyLongDT\n    Short = StrategyShortNDT + StrategyShortDT\n    DayTrade = StrategyLongDT + StrategyShortDT\n    Code = {stra: f'Strategy{i+1}' for i, stra in enumerate(All)}", "\n\n# \u7b56\u7565\u76f8\u95dc\nStrategyList = StrategyNameList()\n\n# \u4ea4\u6613\u76f8\u95dc\nFEE_RATE = .01\n\n# \u6642\u9593\u76f8\u95dc\nT15K = pd.to_datetime('09:15:00')", "# \u6642\u9593\u76f8\u95dc\nT15K = pd.to_datetime('09:15:00')\nT30K = pd.to_datetime('09:30:00')\nTStart = pd.to_datetime('09:05:00')\nTEnd = pd.to_datetime('13:30:05')\nTCheck1 = pd.to_datetime('09:03:00')\nTBuy1 = pd.to_datetime('09:00:00')\nTBuy2 = pd.to_datetime('13:15:00')\nTTry = pd.to_datetime('13:25:00')\nTimeStartStock = pd.to_datetime('09:00:00')", "TTry = pd.to_datetime('13:25:00')\nTimeStartStock = pd.to_datetime('09:00:00')\nTimeEndStock = pd.to_datetime('13:30:00')\nTimeStartFuturesDay = pd.to_datetime('08:45:00')\nTimeEndFuturesDay = pd.to_datetime('13:45:00')\nTimeStartFuturesNight = pd.to_datetime('15:00:00')\nTimeEndFuturesNight = pd.to_datetime('05:00:00') + timedelta(days=1)\nTimeTransferFutures = pd.to_datetime('13:00:00')\nholidays = get_holidays()\n", "holidays = get_holidays()\n\n# \u9078\u80a1\u76f8\u95dc\nSelectMethods = get_settings('SELECT', 'METHODS', dataType='list')\n\n# \u722c\u87f2\u76f8\u95dc\nConvertScales = get_settings('CRAWLER', 'SCALES', dataType='list')\n\n# K\u68d2\u7279\u5fb5\nKbarFeatures = {", "# K\u68d2\u7279\u5fb5\nKbarFeatures = {\n    '2T': get_settings('KBARFEATURE', 'K2min', dataType='list'),\n    '5T': get_settings('KBARFEATURE', 'K5min', dataType='list'),\n    '15T': get_settings('KBARFEATURE', 'K15min', dataType='list'),\n    '30T': get_settings('KBARFEATURE', 'K30min', dataType='list'),\n    '60T': get_settings('KBARFEATURE', 'K60min', dataType='list'),\n}\n", ""]}
{"filename": "trader/executor.py", "chunked_list": ["import ssl\nimport time\nimport logging\nimport numpy as np\nimport pandas as pd\nfrom typing import Dict\nfrom sys import platform\nfrom shioaji import constant\nfrom collections import namedtuple\nfrom datetime import datetime, timedelta", "from collections import namedtuple\nfrom datetime import datetime, timedelta\n\nfrom . import __version__\nfrom . import notifier, picker, crawler2, file_handler\nfrom .config import API, PATH, TODAY, TODAY_STR, holidays\nfrom .config import FEE_RATE, TEnd, TTry, TimeStartStock, TimeStartFuturesDay\nfrom .config import TimeEndFuturesDay, TimeStartFuturesNight, TimeEndFuturesNight\nfrom .utils import get_contract\nfrom .utils.kbar import KBarTool", "from .utils import get_contract\nfrom .utils.kbar import KBarTool\nfrom .utils.orders import OrderTool\nfrom .utils.cipher import CipherTool\nfrom .utils.accounts import AccountInfo\nfrom .utils.subscribe import Subscriber\nfrom .utils.watchlist import WatchListTool\nfrom .utils.database import db\nfrom .utils.database.tables import SecurityInfoStocks, SecurityInfoFutures\ntry:\n    from .scripts.StrategySet import StrategySet as StrategySets\nexcept:\n    from .utils.strategy import StrategyTool as StrategySets", "from .utils.database.tables import SecurityInfoStocks, SecurityInfoFutures\ntry:\n    from .scripts.StrategySet import StrategySet as StrategySets\nexcept:\n    from .utils.strategy import StrategyTool as StrategySets\n\n\nssl._create_default_https_context = ssl._create_unverified_context\n\n\nclass StrategyExecutor(AccountInfo, WatchListTool, KBarTool, OrderTool, Subscriber):\n    def __init__(self, config=None):\n        self.ct = CipherTool(decrypt=True, encrypt=False)\n        self.CONFIG = config\n\n        # \u4ea4\u6613\u5e33\u6236\u8a2d\u5b9a\n        self.ACCOUNT_NAME = self.getENV('ACCOUNT_NAME')\n        self.__API_KEY__ = self.getENV('API_KEY')\n        self.__SECRET_KEY__ = self.getENV('SECRET_KEY')\n        self.__ACCOUNT_ID__ = self.getENV('ACCOUNT_ID', 'decrypt')\n        self.__CA_PASSWD__ = self.getENV('CA_PASSWD', 'decrypt')\n\n        # \u80a1\u7968\u4f7f\u7528\u8005\u8a2d\u5b9a\n        self.KBAR_START_DAYay = self.getENV('KBAR_START_DAYay', 'date')\n        self.MODE = self.getENV('MODE')\n        self.MARKET = self.getENV('MARKET')\n        self.FILTER_OUT = self.getENV('FILTER_OUT', 'list')\n        self.STRATEGY_STOCK = self.getENV('STRATEGY_STOCK', 'list')\n        self.PRICE_THRESHOLD = self.getENV('PRICE_THRESHOLD', 'int')\n        self.INIT_POSITION = self.getENV('INIT_POSITION', 'int')\n        self.POSITION_LIMIT_LONG = self.getENV('POSITION_LIMIT_LONG', 'int')\n        self.POSITION_LIMIT_SHORT = self.getENV('POSITION_LIMIT_SHORT', 'int')\n        self.N_STOCK_LIMIT_TYPE = self.getENV('N_STOCK_LIMIT_TYPE')\n        self.N_LIMIT_LS = self.getENV('N_LIMIT_LS', 'int')\n        self.N_LIMIT_SS = self.getENV('N_LIMIT_SS', 'int')\n        self.BUY_UNIT = self.getENV('BUY_UNIT', 'int')\n        self.BUY_UNIT_TYPE = self.getENV('BUY_UNIT_TYPE')\n        self.ORDER_COND1 = self.getENV('ORDER_COND1')\n        self.ORDER_COND2 = self.getENV('ORDER_COND2')\n        self.LEVERAGE_LONG = {}\n        self.LEVERAGE_SHORT = {}\n        self.day_trade_cond = {\n            'MarginTrading': 'ShortSelling',\n            'ShortSelling': 'MarginTrading',\n            'Cash': 'Cash'\n        }\n        self.simulation = self.MODE == 'Simulation'\n\n        # \u671f\u8ca8\u4f7f\u7528\u8005\u8a2d\u5b9a\n        self.TRADING_PERIOD = self.getENV('TRADING_PERIOD')\n        self.STRATEGY_FUTURES = self.getENV('STRATEGY_FUTURES', 'list')\n        self.MARGIN_LIMIT = self.getENV('MARGIN_LIMIT', 'int')\n        self.N_FUTURES_LIMIT_TYPE = self.getENV('N_FUTURES_LIMIT_TYPE')\n        self.N_FUTURES_LIMIT = self.getENV('N_FUTURES_LIMIT', 'int')\n        self.N_SLOT = self.getENV('N_SLOT', 'int')\n        self.N_SLOT_TYPE = self.getENV('N_SLOT_TYPE')\n\n        super().__init__()\n        KBarTool.__init__(self, self.KBAR_START_DAYay)\n        OrderTool.__init__(self)\n        Subscriber.__init__(self)\n        WatchListTool.__init__(self, self.ACCOUNT_NAME)\n\n        # \u80a1\u7968\u53ef\u9032\u5834\u7c4c\u78bc (\u9032\u5834\u6642\u5224\u65b7\u7528)\n        self.simulate_amount = np.iinfo(np.int64).max\n        self.stocks = pd.DataFrame()\n        self.desposal_money = 0\n        self.stock_bought = []\n        self.stock_sold = []\n        self.n_stocks_long = 0\n        self.n_stocks_short = 0\n        self.total_market_value = 0\n        self.punish_list = []\n        self.pct_chg_DowJones = self.get_pct_chg_DowJones()\n        self.n_categories = None\n\n        # \u671f\u8ca8\u53ef\u9032\u5834\u7c4c\u78bc (\u9032\u5834\u6642\u5224\u65b7\u7528)\n        self.futures_opened = []\n        self.futures_closed = []\n        self.futures_transferred = {}\n        self.n_futures = 0\n        self.futures = pd.DataFrame()\n        self.Futures_Code_List = {}\n        self.margin_table = None\n\n        # \u4ea4\u6613\u76f8\u95dc\n        self.can_stock = 'stock' in self.MARKET\n        self.can_sell = self.MODE not in ['LongBuy', 'ShortBuy']\n        self.can_buy = self.MODE not in ['LongSell', 'ShortSell']\n        self.can_futures = 'futures' in self.MARKET\n        self.stocks_to_monitor = {}\n        self.futures_to_monitor = {}\n\n        # \u8f09\u5165\u6307\u6a19\u6a21\u7d44\n        self.set_scripts(StrategySets)\n\n    def set_scripts(self, strategySet: object):\n        self.StrategySet = strategySet(\n            account_name=self.ACCOUNT_NAME,\n            hold_day=self.getENV('HOLD_DAY', 'int'),\n            is_simulation=self.simulation,\n            stock_limit_type=self.N_STOCK_LIMIT_TYPE,\n            futures_limit_type=self.N_FUTURES_LIMIT_TYPE,\n            stock_limit_long=self.N_LIMIT_LS,\n            stock_limit_short=self.N_LIMIT_SS,\n            futures_limit=self.N_FUTURES_LIMIT,\n        )\n\n    def getENV(self, key: str, type_: str = 'text'):\n        if self.CONFIG and key in self.CONFIG:\n            env = self.CONFIG[key]\n\n            if type_ == 'int':\n                return int(env)\n            elif type_ == 'list':\n                if 'none' in env.lower():\n                    return []\n                return env.replace(' ', '').split(',')\n            elif type_ == 'date' and env:\n                return pd.to_datetime(env)\n            elif type_ == 'decrypt':\n                if not env or (not env[0].isdigit() and env[1:].isdigit()):\n                    return env\n                return self.ct.decrypt(env)\n            return env\n        elif type_ == 'int':\n            return 0\n        elif type_ == 'list':\n            return []\n        return None\n\n    def _set_trade_risks(self):\n        '''\u8a2d\u5b9a\u4ea4\u6613\u98a8\u96aa\u503c: \u53ef\u4ea4\u5272\u91d1\u984d\u3001\u7e3d\u5e02\u503c'''\n\n        cost_value = (self.stocks.quantity * self.stocks.cost_price).sum()\n        pnl = self.stocks.pnl.sum()\n        if self.simulation:\n            account_balance = self.INIT_POSITION\n            settle_info = pnl\n        else:\n            account_balance = self.balance()\n            settle_info = self.settle_info(mode='info').iloc[1:, 1].sum()\n\n        self.desposal_money = min(\n            account_balance+settle_info, self.POSITION_LIMIT_LONG)\n        self.total_market_value = self.desposal_money + cost_value + pnl\n\n        logging.info(\n            f'Desposal amount = {self.desposal_money} (limit: {self.POSITION_LIMIT_LONG})')\n\n    def _set_margin_limit(self):\n        '''\u8a08\u7b97\u53ef\u4ea4\u5272\u7684\u4fdd\u8b49\u91d1\u984d\uff0c\u4e0d\u53ef\u8d85\u904e\u5e33\u6236\u53ef\u4e0b\u55ae\u7684\u4fdd\u8b49\u91d1\u984d\u4e0a\u9650'''\n        if self.simulation:\n            self.desposal_margin = self.simulate_amount\n            self.ProfitAccCount = self.simulate_amount\n        else:\n            self.get_account_margin()\n        self.desposal_margin = min(self.desposal_margin, self.MARGIN_LIMIT)\n        logging.info(f'\u6b0a\u76ca\u7e3d\u503c: {self.ProfitAccCount}')\n        logging.info(\n            f'Margin available = {self.desposal_margin} (limit: {self.MARGIN_LIMIT})')\n\n    def _set_leverage(self, stockids: list):\n        '''\n        \u53d6\u5f97\u500b\u80a1\u878d\u8cc7\u6210\u6578\u8cc7\u6599\uff0c\n        \u82e5\u5e33\u6236\u8a2d\u5b9a\u70ba\u4e0d\u53ef\u878d\u8cc7\uff0c\u5247\u5168\u90e8\u878d\u8cc7\u6210\u6578\u70ba0\n        '''\n\n        df = pd.DataFrame([crawler2.get_leverage(s) for s in stockids])\n        if df.shape[0]:\n            df.loc[df.\u500b\u80a1\u878d\u5238\u4fe1\u7528\u8cc7\u683c == 'N', '\u878d\u5238\u6210\u6578'] = 100\n            df.\u4ee3\u865f = df.\u4ee3\u865f.astype(str)\n            df.\u878d\u8cc7\u6210\u6578 /= 100\n            df.\u878d\u5238\u6210\u6578 /= 100\n\n            if self.ORDER_COND1 != 'Cash':\n                self.LEVERAGE_LONG = df.set_index('\u4ee3\u865f').\u878d\u8cc7\u6210\u6578.to_dict()\n            else:\n                self.LEVERAGE_LONG = {code: 0 for code in stockids}\n\n            if self.ORDER_COND2 != 'Cash':\n                self.LEVERAGE_SHORT = df.set_index('\u4ee3\u865f').\u878d\u5238\u6210\u6578.to_dict()\n            else:\n                self.LEVERAGE_SHORT = {code: 1 for code in stockids}\n\n        logging.info(f'Long leverages: {self.LEVERAGE_LONG}')\n        logging.info(f'Short leverages: {self.LEVERAGE_SHORT}')\n\n    def _set_futures_code_list(self):\n        '''\u671f\u8ca8\u5546\u54c1\u4ee3\u865f\u8207\u4ee3\u78bc\u5c0d\u7167\u8868'''\n        if self.can_futures and self.Futures_Code_List == {}:\n            logging.debug('Set Futures_Code_List')\n            self.Futures_Code_List = {\n                f.code: f.symbol for m in API.Contracts.Futures for f in m}\n\n    def __order_callback(self, stat, msg):\n        '''\u8655\u7406\u59d4\u8a17/\u6210\u4ea4\u56de\u5831'''\n\n        if stat == constant.OrderState.StockOrder:\n            stock = msg['contract']['code']\n            order = msg['order']\n            operation = msg['operation']\n\n            c2 = operation['op_code'] == '00' or operation['op_msg'] == ''\n            c3 = order['action'] == 'Buy'\n            c4 = operation['op_code'] == '88' and '\u6b64\u8b49\u5238\u914d\u984d\u5f35\u6578\u4e0d\u8db3' in operation['op_msg']\n            c5 = len(stock) == 4\n\n            if order['account']['account_id'] == self.account_id_stock:\n                notifier.post_tftOrder(stat, msg)\n\n                if c3 and c5 and stock not in self.stock_bought:\n                    self.stock_bought.append(stock)\n\n                leverage = self.check_leverage(stock, order['order_cond'])\n                if c2 and c3:\n                    # \u8a18\u9304\u59d4\u8a17\u6210\u529f\u7684\u8cb7\u55ae\n                    price = self.Quotes.NowTargets[stock]['price'] if stock in self.Quotes.NowTargets else order['price']\n                    quantity = order['quantity']\n                    if order['order_lot'] == 'Common':\n                        quantity *= 1000\n                    order_data = {\n                        'Time': datetime.now(),\n                        'market': 'Stocks',\n                        'code': stock,\n                        'action': order['action'],\n                        'price': price,\n                        'quantity': quantity,\n                        'amount': self.get_stock_amount(stock, price, quantity, order['order_cond']),\n                        'order_cond': order['order_cond'],\n                        'order_lot': order['order_lot'],\n                        'leverage': leverage,\n                        'account_id': order['account']['account_id']\n                    }\n                    self.appendOrder(order_data)\n\n                # \u82e5\u878d\u8cc7\u914d\u984d\u5f35\u6578\u4e0d\u8db3\uff0c\u6539\u73fe\u80a1\u8cb7\u9032 ex: '\u6b64\u8b49\u5238\u914d\u984d\u5f35\u6578\u4e0d\u8db3\uff0c\u9918\u984d 0 \u5f35\uff08\u8b49\u91d1\uff1a 0 \uff09'\n                elif c4:\n                    q_balance = operation['op_msg'].split(' ')\n                    if len(q_balance) > 1:\n                        q_balance = int(q_balance[1])\n                        infos = dict(\n                            action=order['action'], target=stock, pos_target=100, pos_balance=100)\n                        # \u82e5\u672c\u65e5\u9084\u6c92\u6709\u4e0b\u904e\u878d\u8cc7\u4e14\u5269\u9918\u5238\u6578\u70ba0\uff0c\u624d\u53ef\u4ee5\u6539\u4e0b\u73fe\u80a1\n                        if q_balance == 0 and stock not in self.stock_bought:\n                            orderinfo = self.OrderInfo(\n                                quantity=1000 *\n                                int(order['quantity']*(1-leverage)),\n                                order_cond='Cash',\n                                **infos\n                            )\n                            self._place_order(orderinfo, market='Stocks')\n\n                        elif q_balance > 0:\n                            orderinfo = self.OrderInfo(\n                                quantity=q_balance,\n                                order_cond=order['order_cond'],\n                                **infos\n                            )\n                            self._place_order(orderinfo, market='Stocks')\n\n                # \u82e5\u522a\u55ae\u6210\u529f\u5c31\u81ea\u6e05\u55ae\u79fb\u9664\n                if operation['op_type'] == 'Cancel':\n                    self.deleteOrder(stock)\n                    if c3 and stock in self.stock_bought:\n                        self.stock_bought.remove(stock)\n\n        elif stat == constant.OrderState.StockDeal and msg['account_id'] == self.account_id_stock:\n            stock = msg['code']\n            msg.update({\n                'position': 100,\n                'yd_quantity': 0,\n                'bst': datetime.now(),\n                'cost_price': msg['price']\n            })\n            notifier.post_tftDeal(stat, msg)\n\n            if msg['order_lot'] == 'Common':\n                msg['quantity'] *= 1000\n\n            quantity = msg['quantity']\n            if msg['action'] == 'Sell':\n\n                if stock not in self.stock_sold and len(stock) == 4:\n                    self.stock_sold.append(stock)\n\n                price = msg['price']\n                leverage = self.check_leverage(stock, msg['order_cond'])\n                cost_price = self.get_cost_price(\n                    stock, price, msg['order_cond'])\n\n                # \u7d00\u9304\u6210\u4ea4\u7684\u8ce3\u55ae\n                order_data = {\n                    'Time': datetime.now(),\n                    'market': 'Stocks',\n                    'code': stock,\n                    'price': -price,\n                    'quantity': quantity,\n                    # \u8ce3\u51fa\u91d1\u984d - \u878d\u8cc7\u91d1\u984d - \u624b\u7e8c\u8cbb\n                    'amount': -(price - cost_price*leverage)*quantity*(1 - FEE_RATE),\n                    'order_cond': msg['order_cond'],\n                    'order_lot': msg['order_lot'],\n                    'leverage': leverage,\n                    'account_id': msg['account_id']\n                }\n                self.appendOrder(order_data)\n\n            # \u66f4\u65b0\u76e3\u63a7\u5eab\u5b58\n            if not self.simulation:\n                self.update_monitor_lists(msg['action'], msg)\n\n        elif stat == constant.OrderState.FuturesOrder:\n            code = msg['contract']['code']\n            symbol = code + msg['contract']['delivery_month']\n            bsh = self.Quotes.AllTargets[symbol]['price']\n            msg.update({\n                'symbol': symbol,\n                'cost_price': self.Quotes.NowTargets[symbol]['price'] if symbol in self.Quotes.NowTargets else 0,\n                'bsh': max(bsh) if bsh else 0,\n                'bst': datetime.now(),\n                'position': 100\n            })\n            order = msg['order']\n            operation = msg['operation']\n\n            if order['account']['account_id'] == self.account_id_futopt:\n                notifier.post_fOrder(stat, msg)\n                if operation['op_code'] == '00' or operation['op_msg'] == '':\n                    self._update_futures_deal_list(symbol, order['oc_type'])\n\n                    # \u7d00\u9304\u6210\u4ea4\u7684\u8ce3\u55ae\n                    price = -order['price'] if c4 else order['price']\n                    sign = -1 if order['action'] == 'Sell' else 1\n                    quantity = order['quantity']\n                    order_data = {\n                        'Time': datetime.now(),\n                        'market': 'Futures',\n                        'code': symbol,\n                        'price': price*sign,\n                        'quantity': quantity,\n                        'amount': self.get_open_margin(symbol, quantity)*sign,\n                        'op_type': order['oc_type'],\n                        'account_id': order['account']['account_id']\n                    }\n                    self.appendOrder(order_data)\n\n                # \u82e5\u522a\u55ae\u6210\u529f\u5c31\u81ea\u6e05\u55ae\u79fb\u9664\n                if operation['op_type'] == 'Cancel':\n                    self.deleteOrder(symbol)\n                    if symbol in self.futures_opened:\n                        self.futures_opened.remove(symbol)\n\n                # \u66f4\u65b0\u76e3\u63a7\u5eab\u5b58\n                if not self.simulation:\n                    self.update_monitor_lists(operation['op_type'], msg)\n\n        elif stat == constant.OrderState.FuturesDeal:\n            notifier.post_fDeal(stat, msg)\n\n    def login_and_activate(self):\n        # \u767b\u5165\n        self._login(self.__API_KEY__, self.__SECRET_KEY__, self.ACCOUNT_NAME)\n        self.account_id_stock = API.stock_account.account_id\n        logging.info(f'Stock account ID: {self.account_id_stock}')\n\n        if self.HAS_FUTOPT_ACCOUNT:\n            self.can_futures = 'futures' in self.MARKET\n            self.account_id_futopt = API.futopt_account.account_id\n            self._set_futures_code_list()\n            logging.info(f'Futures account ID: {self.account_id_futopt}')\n\n        # \u555f\u52d5\u6191\u8b49 (Mac \u4e0d\u9700\u555f\u52d5)\n        if platform != 'darwin':\n            logging.info(f'Activate {self.ACCOUNT_NAME} CA')\n            if self.__CA_PASSWD__:\n                ca_passwd = self.__CA_PASSWD__\n            else:\n                ca_passwd = self.__ACCOUNT_ID__\n            API.activate_ca(\n                ca_path=f\"./lib/ekey/551/{self.__ACCOUNT_ID__}/S/Sinopac.pfx\",\n                ca_passwd=ca_passwd,\n                person_id=self.__ACCOUNT_ID__,\n            )\n\n        # \u7cfb\u7d71 callback \u8a2d\u5b9a\n        self._set_callbacks()\n\n    def _set_callbacks(self):\n        '''\u53d6\u5f97API\u56de\u50b3\u5831\u50f9'''\n        @API.on_tick_stk_v1()\n        def stk_quote_callback_v1(exchange, tick):\n            if tick.intraday_odd == 0 and tick.simtrade == 0:\n\n                if tick.code not in self.Quotes.NowTargets:\n                    logging.debug(f'First quote of {tick.code}')\n\n                tick_data = self.stk_quote_v1(tick)\n                # self.to_redis({tick.code: tick_data})\n\n        @API.on_tick_fop_v1()\n        def fop_quote_callback_v1(exchange, tick):\n            try:\n                if tick.simtrade == 0:\n                    symbol = self.Futures_Code_List[tick.code]\n\n                    if symbol not in self.Quotes.NowTargets:\n                        logging.debug(f'First quote of {symbol}')\n\n                    tick_data = self.fop_quote_v1(symbol, tick)\n                    # self.to_redis({symbol: tick_data})\n            except KeyError:\n                logging.exception('KeyError: ')\n\n        @API.quote.on_quote\n        def quote_callback(topic: str, quote: dict):\n            self.index_v0(quote)\n\n        @API.quote.on_event\n        def event_callback(resp_code: int, event_code: int, info: str, event: str):\n            if 'Subscription Not Found' in info:\n                logging.warning(info)\n\n            else:\n                logging.info(\n                    f'Response code: {resp_code} | Event code: {event_code} | info: {info} | Event: {event}')\n\n                if info == 'Session connect timeout' or event_code == 1:\n                    time.sleep(5)\n                    logging.info(f'\u767b\u51fa\u7cfb\u7d71: {API.logout()}')\n                    logging.warning('Re-login')\n\n                    time.sleep(5)\n                    self._login(self.__API_KEY__,\n                                self.__SECRET_KEY__, self.ACCOUNT_NAME)\n\n        # \u8a02\u95b1\u4e0b\u55ae\u56de\u5831\n        API.set_order_callback(self.__order_callback)\n\n        # \u8a02\u95b1\u4e94\u6a94\u56de\u5831\n        @API.on_bidask_stk_v1()\n        def stk_quote_callback(exchange, bidask):\n            self.BidAsk[bidask.code] = bidask\n\n        @API.on_bidask_fop_v1()\n        def fop_quote_callback(exchange, bidask):\n            symbol = self.Futures_Code_List[bidask.code]\n            self.BidAsk[symbol] = bidask\n\n    def _log_and_notify(self, msg: str):\n        '''\u5c07\u8a0a\u606f\u52a0\u5165log\u4e26\u63a8\u64ad'''\n        logging.info(msg)\n        notifier.post(f'\\n{msg}', msgType='Monitor')\n\n    def init_stocks(self):\n        '''\u521d\u59cb\u5316\u80a1\u7968\u8cc7\u8a0a'''\n\n        if not self.can_stock:\n            return None, []\n\n        # \u8b80\u53d6\u9078\u80a1\u6e05\u55ae\n        strategies = self.get_stock_pool()\n\n        # \u53d6\u5f97\u9060\u7aef\u5eab\u5b58\n        self.stocks = self.get_securityInfo('Stocks')\n\n        # \u53d6\u5f97\u7b56\u7565\u6e05\u55ae\n        self.init_watchlist(self.stocks, strategies)\n\n        # \u5eab\u5b58\u7684\u8655\u7406\n        self.stocks = self.stocks.merge(\n            self.watchlist,\n            how='left',\n            on=['account', 'market', 'code']\n        )\n        self.stocks.position.fillna(100, inplace=True)\n        strategies.update(self.stocks.set_index('code').strategy.to_dict())\n\n        # \u5254\u9664\u4e0d\u5805\u63a7\u7684\u80a1\u7968\n        self.stocks = self.stocks[~self.stocks.code.isin(self.FILTER_OUT)]\n\n        # \u65b0\u589e\u6b77\u53f2K\u68d2\u8cc7\u6599\n        self.update_stocks_to_monitor(strategies)\n        all_targets = list(self.stocks_to_monitor)\n        self.history_kbars(['TSE001', 'OTC101'] + all_targets)\n\n        # \u4ea4\u6613\u98a8\u96aa\u63a7\u5236\n        buy_condition = self.stocks.action == 'Buy'\n        self.n_stocks_long = self.stocks[buy_condition].shape[0]\n        self.n_stocks_short = self.stocks[~buy_condition].shape[0]\n        self.N_LIMIT_LS = self.StrategySet.setNStockLimitLong(KBars=self.KBars)\n        self.N_LIMIT_SS = self.StrategySet.setNStockLimitShort(\n            KBars=self.KBars)\n        self.punish_list = crawler2.get_punish_list().\u8b49\u5238\u4ee3\u865f.to_list()\n        self._set_leverage(all_targets)\n        self._set_trade_risks()\n        logging.debug(f'stocks_to_monitor: {self.stocks_to_monitor}')\n        return strategies, all_targets\n\n    def init_futures(self):\n        '''\u521d\u59cb\u5316\u671f\u8ca8\u8cc7\u8a0a'''\n\n        def preprocess_(df):\n            if df.shape[0]:\n                for c in ['Volume', 'ContractAverPrice', 'SettlePrice', 'RealPrice']:\n                    df[c] = df[c].astype(float)\n                    if c in ['ContractAverPrice', 'SettlePrice', 'RealPrice']:\n                        df[c] = df.groupby('Code')[c].transform('mean')\n                    else:\n                        df[c] = df.groupby('Code')[c].transform(sum)\n\n                df = df.drop_duplicates('Code')\n                df = df.rename(columns={'ContractAverPrice': 'cost_price'})\n                df.Code = df.Code.astype(str).map(self.Futures_Code_List)\n                df.OrderBS = df.OrderBS.apply(\n                    lambda x: 'Buy' if x == 'B' else ('Sell' if x == 'S' else x))\n\n                orders = df[['Volume', 'OrderBS']]\n                orders = orders.rename(\n                    columns={'Volume': 'quantity', 'OrderBS': 'action'})\n                df['order'] = orders.to_dict('records')\n\n                day = TODAY_STR.replace('-', '/')\n                df['isDue'] = df.CodeName.apply(\n                    lambda x: day == get_contract(x).delivery_date)\n            return df\n\n        if not self.can_futures:\n            return None, []\n\n        # \u8b80\u53d6\u9078\u80a1\u6e05\u55ae\n        strategies = self.get_futures_pool()\n\n        # \u53d6\u5f97\u9060\u7aef\u5eab\u5b58\n        self.futures = self.get_securityInfo('Futures')\n\n        # \u5eab\u5b58\u7684\u8655\u7406\n        self.futures = preprocess_(self.futures)\n        self.futures = self.futures.merge(\n            self.watchlist,\n            how='left',\n            left_on=['Account', 'Market', 'Code'],\n            right_on=['account', 'market', 'code']\n        )\n        self.futures.position.fillna(100, inplace=True)\n\n        self.n_futures = self.futures.shape[0]\n\n        # \u53d6\u5f97\u7b56\u7565\u6e05\u55ae\n        self.futures.index = self.futures.Code\n        strategies.update(self.futures.strategy.to_dict())\n\n        # \u5254\u9664\u4e0d\u5805\u63a7\u7684\u80a1\u7968\n        self.futures = self.futures[~self.futures.Code.isin(self.FILTER_OUT)]\n\n        # update_futures_to_monitor\n        self.futures_to_monitor.update(self.futures.to_dict('index'))\n        self.futures_to_monitor.update({\n            f: None for f in strategies if f not in self.futures_to_monitor})\n\n        # \u65b0\u589e\u6b77\u53f2K\u68d2\u8cc7\u6599\n        all_futures = list(self.futures_to_monitor)\n        self.history_kbars(all_futures)\n\n        # \u4ea4\u6613\u98a8\u96aa\u63a7\u5236\n        self.N_FUTURES_LIMIT = self.StrategySet.setNFuturesLimit(\n            KBars=self.KBars)\n        self._set_margin_limit()\n        self.margin_table = self.get_margin_table().\u539f\u59cb\u4fdd\u8b49\u91d1.to_dict()\n        return strategies, all_futures\n\n    def _update_position(self, order: namedtuple, strategies: Dict[str, str]):\n        '''\u66f4\u65b0\u5eab\u5b58\u90e8\u4f4d\u6bd4\u4f8b'''\n\n        action = order.action if not order.octype else order.octype\n        target = order.target\n        position = order.pos_target\n        is_day_trade = self.StrategySet.isDayTrade(strategies[target])\n\n        # update monitor list position\n        if order.action_type == 'Close':\n            if action in ['Buy', 'Sell']:\n                self.stocks_to_monitor[target]['position'] -= position\n            else:\n                self.futures_to_monitor[target]['position'] -= position\n\n        # remove from monitor list\n        is_stock = target in self.stocks_to_monitor\n        is_futures = target in self.futures_to_monitor\n        c1 = position == 100 or position >= order.pos_balance\n        c2 = is_stock and self.stocks_to_monitor[target]['quantity'] <= 0\n        c3 = is_stock and self.stocks_to_monitor[target]['position'] <= 0\n        c4 = is_futures and self.futures_to_monitor[target]['order']['quantity'] <= 0\n        c5 = is_futures and self.futures_to_monitor[target]['position'] <= 0\n        if c1 or c2 or c3 or c4 or c5:\n            order = order._replace(pos_target=100)\n\n            if c2 or c3:\n                # TODO:if is_day_trade: self.stocks_to_monitor[target] = None\n                self.remove_stock_monitor_list(target)\n\n            if c4 or c5:\n                if is_day_trade:\n                    self.futures_to_monitor[target] = None\n                else:\n                    self.remove_futures_monitor_list(target)\n\n        # append watchlist or udpate watchlist position\n        self.update_watchlist_position(order, self.Quotes, strategies)\n\n    def update_stocks_to_monitor(self, stocks_pool: Dict[str, list]):\n        '''\u66f4\u65b0\u8cb7\u9032/\u8ce3\u51fa\u80a1\u7968\u76e3\u63a7\u6e05\u55ae'''\n\n        df = self.stocks.copy()\n        df.index = df.code\n        if not self.simulation:\n            df.order_cond = df.order_cond.apply(lambda x: x._value_)\n        self.stocks_to_monitor = df.to_dict('index')\n\n        for stock, stra in stocks_pool.items():\n            if (\n                (self.can_buy and self.StrategySet.isLong(stra)) or\n                (self.can_sell and self.StrategySet.isShort(stra))\n            ) and (stock not in self.stocks_to_monitor):\n                self.stocks_to_monitor.update({stock: None})\n\n    def update_monitor_lists(self, action, data):\n        '''\u66f4\u65b0\u76e3\u63a7\u5eab\u5b58(\u6210\u4ea4\u56de\u5831)'''\n        target = data['code']\n        if action in ['Buy', 'Sell']:\n            if target in self.stocks_to_monitor and self.stocks_to_monitor[target]:\n                logging.debug(\n                    f'\u66f4\u65b0 stocks_to_monitor \u3010QUANTITY\u3011: {action} {target}')\n                quantity = data['quantity']\n                # TODO: \u90e8\u5206\u9032\u5834\n                self.stocks_to_monitor[target]['quantity'] -= quantity\n            else:\n                logging.debug(\n                    f'\u66f4\u65b0 stocks_to_monitor \u3010DATA\u3011: {action} {target}')\n                self.stocks_to_monitor[target] = data\n\n        # New, Cover\n        else:\n            if target in self.futures_to_monitor and self.futures_to_monitor[target]:\n                logging.debug(\n                    f'\u66f4\u65b0 futures_to_monitor \u3010QUANTITY\u3011: {action} {target}')\n                quantity = data['order']['quantity']\n                self.futures_to_monitor[target]['order']['quantity'] -= quantity\n            else:\n                logging.debug(\n                    f'\u66f4\u65b0 futures_to_monitor \u3010DATA\u3011: {action} {target}')\n                self.futures_to_monitor[target] = data\n\n    def _update_futures_deal_list(self, target, octype):\n        '''\u66f4\u65b0\u671f\u8ca8\u4e0b\u55ae\u66ab\u5b58\u6e05\u55ae'''\n        if octype == 'New' and target not in self.futures_opened:\n            self.futures_opened.append(target)\n\n        if octype == 'Cover' and target not in self.futures_closed:\n            self.futures_closed.append(target)\n\n    def merge_buy_sell_lists(self, stocks_pool: Dict[str, str], market='Stocks'):\n        '''\u5408\u4f75\u9032\u51fa\u5834\u6e05\u55ae: \u5c07\u5eab\u5b58\u8207\u9078\u80a1\u6e05\u55ae\uff0c\u5408\u4f75'''\n\n        if market == 'Stocks' and self.stocks.shape[0]:\n            sells = self.stocks.code.values\n        elif market == 'Futures' and self.futures.shape[0]:\n            sells = self.futures.Code.values\n        else:\n            sells = []\n\n        all = sells.copy()\n        for ids in stocks_pool.values():\n            all = np.append(all, ids)\n\n        return np.unique(all)\n\n    def monitor_stocks(self, target: str, strategies: Dict[str, str]):\n        if target in self.Quotes.NowTargets and self.Quotes.NowIndex:\n            inputs = self.Quotes.NowTargets[target].copy()\n            data = self.stocks_to_monitor[target]\n            strategy = strategies[target]\n            isLongStrategy = self.StrategySet.isLong(strategy)\n            isDTStrategy = self.StrategySet.isDayTrade(strategy)\n            isSell = (\n                # long selling\n                (data and 'action' in data and data['action'] == 'Buy') or\n                # short selling\n                (not data and self.can_sell and not isLongStrategy)\n            )\n\n            # new position\n            if data is None:\n                mode = 'short' if isSell else 'long'\n\n                actionType = 'Open'\n                pos_balance = 100\n                order_cond = self.check_order_cond(target, mode)\n                quantity = self.get_quantity(target, strategy, order_cond)\n                enoughOpen = self.check_enough(target, quantity, mode)\n\n            # in-stock position\n            else:\n                actionType = 'Close'\n                pos_balance = data['position']\n                order_cond = data['order_cond']\n                quantity = data['quantity']\n                enoughOpen = False\n\n            inStocks = target in self.stocks.code.values\n            inDeal = target in self.stock_bought + self.stock_sold\n\n            is_day_trade = isDTStrategy and inDeal and (not inStocks)\n            isOpen = actionType == 'Open' and enoughOpen\n            isClose = (\n                (not isDTStrategy) and (not inDeal) and inStocks and\n                (actionType == 'Close')\n            )\n            isDTClose = (is_day_trade and (actionType == 'Close'))\n\n            if quantity and (isOpen or isClose or isDTClose):\n                tradeType = '\u7576\u6c96' if is_day_trade else '\u975e\u7576\u6c96'\n                func = self.StrategySet.mapFunction(\n                    actionType, tradeType, strategy)\n\n                if data:\n                    inputs.update(data)\n\n                actionInfo = func(\n                    inputs=inputs,\n                    kbars=self.KBars,\n                    Quotes=self.Quotes,\n                    pct_chg_DowJones=self.pct_chg_DowJones\n                )\n                if actionInfo.position:\n                    infos = dict(\n                        action_type=actionType,\n                        action='Sell' if isSell else 'Buy',\n                        target=target,\n                        quantity=quantity,\n                        order_cond=self.day_trade_cond[order_cond] if is_day_trade else order_cond,\n                        pos_target=actionInfo.position,\n                        pos_balance=pos_balance,\n                        reason=actionInfo.msg,\n                    )\n                    self._log_and_notify(actionInfo.msg)\n                    return self.OrderInfo(**infos)\n\n        return self.OrderInfo(target=target)\n\n    def monitor_futures(self, target: str, strategies: Dict[str, str]):\n        '''\u6aa2\u67e5\u671f\u8ca8\u662f\u5426\u7b26\u5408\u8ce3\u51fa\u689d\u4ef6\uff0c\u56de\u50b3\u8ce3\u51fa\u90e8\u4f4d(%)'''\n\n        if target in self.Quotes.NowTargets and self.N_FUTURES_LIMIT != 0:\n            inputs = self.Quotes.NowTargets[target].copy()\n            data = self.futures_to_monitor[target]\n            strategy = strategies[target]\n            isLongStrategy = self.StrategySet.isLong(strategy)\n\n            # \u5efa\u5009\n            if data is None:\n                octype = 'New'\n                actionType = 'Open'\n                quantity = self.get_open_slot(target, strategy)\n                enoughOpen = self._check_enough_open(target, quantity)\n                pos_balance = 100\n                action = 'Buy' if isLongStrategy else 'Sell'\n\n            # \u5eab\u5b58\n            else:\n                octype = 'Cover'\n                actionType = 'Close'\n                enoughOpen = False\n                pos_balance = data['position']\n                if target in self.futures_opened:\n                    quantity = data['order']['quantity']\n                    action = data['order']['action']\n                else:\n                    quantity = data['Volume']\n                    action = data['OrderBS']\n\n            if target in self.futures_transferred:\n                msg = f'{target} \u8f49\u5009-New'\n                infos = dict(\n                    action_type=actionType,\n                    action=action,\n                    target=target,\n                    quantity=self.futures_transferred[target],\n                    octype=octype,\n                    pos_target=100,\n                    pos_balance=0,\n                    reason=msg\n                )\n                self._log_and_notify(msg)\n                self.futures_transferred.pop(target)\n                return self.OrderInfo(**infos)\n\n            c1 = octype == 'New' and enoughOpen and not self.is_not_trade_day(\n                inputs['datetime'])\n            c2 = octype == 'Cover'\n            if quantity and (c1 or c2):\n                is_day_trade = self.StrategySet.isDayTrade(strategy)\n                tradeType = '\u7576\u6c96' if is_day_trade else '\u975e\u7576\u6c96'\n                isTransfer = (\n                    actionType == 'Close') and 'isDue' in data and data['isDue']\n                if isTransfer:\n                    func = self.StrategySet.transfer_position\n                else:\n                    func = self.StrategySet.mapFunction(\n                        actionType, tradeType, strategy)\n\n                if data:\n                    inputs.update(data)\n\n                actionInfo = func(\n                    inputs=inputs,\n                    kbars=self.KBars,\n                    Quotes=self.Quotes,\n                    pct_chg_DowJones=self.pct_chg_DowJones\n                )\n                if actionInfo.position:\n                    if isTransfer:\n                        new_target = f'{target[:3]}{self.GetDueMonth(TODAY)}'\n                        self.futures_transferred.update({new_target: quantity})\n\n                    infos = dict(\n                        action_type=actionType,\n                        action=action,\n                        target=target,\n                        quantity=quantity,\n                        octype=octype,\n                        pos_target=actionInfo.position,\n                        pos_balance=pos_balance,\n                        reason=actionInfo.msg\n                    )\n                    self._log_and_notify(actionInfo.msg)\n                    return self.OrderInfo(**infos)\n\n        return self.OrderInfo(target=target)\n\n    def _place_order(self, content: namedtuple, market='Stocks'):\n        logging.debug(f'\u3010content: {content}\u3011')\n\n        target = content.target\n        contract = get_contract(target)\n        if target in self.BidAsk:\n            quantity = self.get_sell_quantity(content, market)\n            price_type = 'MKT'\n            price = 0\n            order_lot = 'IntradayOdd' if content.quantity < 1000 and market == 'Stocks' else 'Common'\n\n            if market == 'Stocks':\n                bid_ask = self.BidAsk[target]\n                bid_ask = bid_ask.bid_price if content.action == 'Sell' else bid_ask.ask_price\n\n                # \u96f6\u80a1\u4ea4\u6613\n                if 0 < content.quantity < 1000:\n                    price_type = 'LMT'\n                    price = bid_ask[1]\n\n                # \u6574\u80a1\u4ea4\u6613\n                else:\n                    if datetime.now() >= TTry:\n                        price_type = 'LMT'\n                        price = bid_ask[1]\n                    elif target in self.punish_list:\n                        price_type = 'LMT'\n                        price = bid_ask[3]\n                    elif contract.exchange == 'OES':\n                        price_type = 'LMT'\n                        price = self.Quotes.NowTargets[target]['price']\n\n                log_msg = f\"\u3010{target}\u4e0b\u55ae\u5167\u5bb9: price={price}, quantity={quantity}, action={content.action}, price_type={price_type}, order_cond={content.order_cond}, order_lot={order_lot}\u3011\"\n            else:\n                log_msg = f\"\u3010{target}\u4e0b\u55ae\u5167\u5bb9: price={price}, quantity={quantity}, action={content.action}, price_type={price_type}, order_cond={content.octype}, order_lot={order_lot}\u3011\"\n\n            # \u4e0b\u55ae\n            logging.debug(log_msg)\n            if self.simulation and market == 'Stocks':\n                price = self.Quotes.NowTargets[target]['price']\n                quantity *= 1000\n                leverage = self.check_leverage(target, content.order_cond)\n                if content.action == 'Sell':\n                    self.stock_sold.append(target)\n                    cost_price = self.get_cost_price(\n                        target, price, content.order_cond)\n                    amount = -(price - cost_price*leverage) * \\\n                        quantity*(1 - FEE_RATE)\n                else:\n                    self.stock_bought.append(target)\n                    amount = self.get_stock_amount(\n                        target, price, quantity, content.order_cond)\n\n                sign = -1 if content.action == 'Sell' else 1\n                order_data = {\n                    'Time': datetime.now(),\n                    'market': market,\n                    'code': target,\n                    'action': content.action,\n                    'price': price*sign,\n                    'quantity': quantity,\n                    'amount': amount,\n                    'order_cond': content.order_cond if market == 'Stocks' else 'Cash',\n                    'order_lot': order_lot,\n                    'leverage': leverage,\n                    'account_id': f'simulate-{self.ACCOUNT_NAME}',\n                    'msg': content.reason\n                }\n                self.appendOrder(order_data)\n\n                # \u66f4\u65b0\u76e3\u63a7\u5eab\u5b58\n                order_data.update({\n                    'position': content.pos_target,\n                    'yd_quantity': 0,\n                    'bst': datetime.now(),\n                    'cost_price': abs(order_data['price'])\n                })\n                self.update_monitor_lists(content.action, order_data)\n\n                logging.debug('Place simulate order complete.')\n                notifier.post(log_msg, msgType='Order')\n\n            elif self.simulation and market == 'Futures':\n                price = self.Quotes.NowTargets[target]['price']\n                sign = -1 if content.action == 'Sell' else 1\n                order_data = {\n                    'Time': datetime.now(),\n                    'market': market,\n                    'code': target,\n                    'action': content.action,\n                    'price': price*sign,\n                    'quantity': quantity,\n                    'amount': self.get_open_margin(target, quantity)*sign,\n                    'op_type': content.octype,\n                    'account_id': f'simulate-{self.ACCOUNT_NAME}',\n                    'msg': content.reason\n                }\n                self.appendOrder(order_data)\n                self._update_futures_deal_list(target, content.octype)\n\n                # \u66f4\u65b0\u76e3\u63a7\u5eab\u5b58\n                bsh = self.Quotes.AllTargets[target]['price']\n                bsh = max(bsh) if bsh else price\n                order_data.update({\n                    'symbol': target,\n                    'cost_price': price,\n                    'bsh': bsh,\n                    'bst': datetime.now(),\n                    'position': content.pos_target,\n                    'order': {\n                        'quantity': quantity,\n                        'action': content.action\n                    }\n                })\n                self.update_monitor_lists(content.octype, order_data)\n\n                logging.debug('Place simulate order complete.')\n                notifier.post(log_msg, msgType='Order')\n            else:\n                # #ff0000 \u6279\u6b21\u4e0b\u55ae\u7684\u5f35\u6578 (\u80a1\u7968>1000\u80a1\u7684\u55ae\u4f4d\u70ba\u3010\u5f35\u3011) #ff0000\n                q = 5 if order_lot == 'Common' else quantity\n                if market == 'Stocks':\n                    target_ = self.desposal_money\n                else:\n                    target_ = self.desposal_margin\n\n                enough_to_place = self.checkEnoughToPlace(market, target_)\n                while quantity > 0 and enough_to_place:\n                    order = API.Order(\n                        # \u50f9\u683c (\u5e02\u50f9\u55ae = 0)\n                        price=price,\n                        # \u6578\u91cf (\u6700\u5c0f1\u5f35; \u96f6\u80a1\u6700\u5c0f50\u80a1 or \u5168\u90e8\u5eab\u5b58)\n                        quantity=min(quantity, q),\n                        # \u52d5\u4f5c: \u8cb7\u9032/\u8ce3\u51fa\n                        action=content.action,\n                        # \u5e02\u50f9\u55ae/\u9650\u50f9\u55ae\n                        price_type=price_type,\n                        # ROD:\u7576\u5929\u90fd\u53ef\u6210\u4ea4\n                        order_type=constant.OrderType.ROD,\n                        # \u59d4\u8a17\u985e\u578b: \u73fe\u80a1/\u878d\u8cc7\n                        order_cond=content.order_cond if market == 'Stocks' else 'Cash',\n                        # \u6574\u5f35\u6216\u96f6\u80a1\n                        order_lot=order_lot,\n                        # {Auto, New, Cover, DayTrade}(\u81ea\u52d5\u3001\u65b0\u5009\u3001\u5e73\u5009\u3001\u7576\u6c96)\n                        octype='Auto' if market == 'Stocks' else content.octype,\n                        account=API.stock_account if market == 'Stocks' else API.futopt_account,\n                        # \u5148\u8ce3\u5f8c\u8cb7: True, False\n                        daytrade_short=content.daytrade_short,\n                    )\n                    result = API.place_order(contract, order)\n                    self.check_order_status(result)\n                    quantity -= q\n\n    def get_securityInfo(self, market='Stocks'):\n        '''\u53d6\u5f97\u8b49\u5238\u5eab\u5b58\u6e05\u55ae'''\n\n        if self.simulation:\n            df_default = {\n                'Stocks': self.df_securityInfo,\n                'Futures': self.df_futuresInfo\n            }\n            try:\n                if db.HAS_DB and market == 'Stocks':\n                    df = db.query(\n                        SecurityInfoStocks,\n                        SecurityInfoStocks.account == self.ACCOUNT_NAME\n                    )\n                elif db.HAS_DB and market == 'Futures':\n                    df = db.query(\n                        SecurityInfoFutures,\n                        SecurityInfoFutures.Account == self.ACCOUNT_NAME\n                    )\n                else:\n                    df = file_handler.read_table(\n                        f'{PATH}/stock_pool/simulation_{market.lower()}_{self.ACCOUNT_NAME}.pkl',\n                        df_default=df_default[market]\n                    )\n            except:\n                df = df_default[market]\n\n            df['account_id'] = 'simulate'\n\n        else:\n            if market == 'Stocks':\n                df = self.securityInfo()\n                return df[df.code.apply(len) == 4]\n\n            df = self.get_openpositions()\n        return df\n\n    def get_margin_table(self):\n        '''\u53d6\u5f97\u4fdd\u8b49\u91d1\u6e05\u55ae'''\n        df = self.read_table('./lib/indexMarging.csv').reset_index()\n        df.columns = list(df.iloc[0, :])\n        df = df.iloc[1:, :-2]\n        df.\u539f\u59cb\u4fdd\u8b49\u91d1 = df.\u539f\u59cb\u4fdd\u8b49\u91d1.astype(int)\n\n        codes = [[f.code, f.symbol, f.name]\n                 for m in API.Contracts.Futures for f in m]\n        codes = pd.DataFrame(codes, columns=['code', 'symbol', 'name'])\n        codes = codes.set_index('name').symbol.to_dict()\n\n        month = str((datetime.now() + timedelta(days=30)).month).zfill(2)\n        df['code'] = (df.\u5546\u54c1\u5225 + month).map(codes)\n        return df.dropna().set_index('code')\n\n    def get_stock_pool(self):\n        '''\n        \u53d6\u5f97\u80a1\u7968\u9078\u80a1\u6c60\n        pools = {\n            'stockid':'strategy',\n        }\n        '''\n\n        pools = {}\n\n        df = picker.get_selection_files()\n        if df.shape[0]:\n            # \u6392\u9664\u4e0d\u4ea4\u6613\u7684\u80a1\u7968\n            # ### \u5168\u984d\u4ea4\u5272\u80a1\u4e0d\u8cb7\n            day_filter_out = crawler2.get_CashSettle()\n            df = df[~df.code.isin(day_filter_out.\u80a1\u7968\u4ee3\u78bc.values)]\n            df = df[~df.code.isin(self.FILTER_OUT)]\n\n            # \u6392\u9664\u9ad8\u50f9\u80a1\n            df = df[df.Close <= self.PRICE_THRESHOLD]\n\n            df = df.sort_values('Close')\n\n            # \u5efa\u7acb\u65cf\u7fa4\u6e05\u55ae\n            n_category = df.groupby('category').code.count().to_dict()\n            df['n_category'] = df.category.map(n_category)\n            self.n_categories = (\n                df.sort_values('n_category', ascending=False)\n                .set_index('code').n_category.to_dict())\n\n            # \u65cf\u7fa4\u6e05\u55ae\u6309\u7167\u7b56\u7565\u6b0a\u91cd & pc_ratio \u6c7a\u5b9a\n            # \u6b0a\u91cd\u5927\u7684\u5148\u52a0\u5165\uff0c\u907f\u514d\u91cd\u8907\n            if self.StrategySet.pc_ratio >= 115:\n                sort_order = ['long_weight', 'short_weight']\n            else:\n                sort_order = ['short_weight', 'long_weight']\n            strategies = self.StrategySet.STRATEGIES.sort_values(\n                sort_order, ascending=False).name.to_list()\n\n            for s in strategies:\n                if s in df.Strategy.values and s in self.STRATEGY_STOCK:\n                    stockids = df[df.Strategy == s].code\n                    pools.update({stock: s for stock in stockids})\n                    df = df[~df.code.isin(stockids)]\n\n        return pools\n\n    def get_futures_pool(self):\n        '''\u53d6\u5f97\u671f\u6b0a\u76ee\u6a19\u5546\u54c1\u6e05\u55ae'''\n\n        pools = {}\n\n        due_year_month = self.GetDueMonth(TODAY)\n        indexes = {\n            '\u653e\u7a7a\u5c0f\u53f0': [f'MXF{due_year_month}'],\n            '\u505a\u591a\u5c0f\u53f0': [f'MXF{due_year_month}'],\n            '\u653e\u7a7a\u5927\u53f0': [f'TXF{due_year_month}'],\n            '\u505a\u591a\u5927\u53f0': [f'TXF{due_year_month}'],\n        }\n        pools.update({\n            symbol: st for st in self.STRATEGY_FUTURES for symbol in indexes[st]\n        })\n        return pools\n\n    def get_quantity(self, target: str, strategy: str, order_cond: str):\n        '''\u8a08\u7b97\u9032\u5834\u80a1\u6578'''\n\n        if self.BUY_UNIT_TYPE == 'constant':\n            return 1000*self.BUY_UNIT\n\n        quantityFunc = self.StrategySet.mapQuantities(strategy)\n\n        inputs = self.Quotes.NowTargets[target]\n        quantity, quantity_limit = quantityFunc(\n            inputs=inputs, kbars=self.KBars)\n        leverage = self.check_leverage(target, order_cond)\n\n        quantity = int(min(quantity, quantity_limit)/(1 - leverage))\n        quantity = min(quantity, 499)\n\n        contract = get_contract(target)\n        if order_cond == 'MarginTrading':\n            quantity = min(contract.margin_trading_balance, quantity)\n        elif order_cond == 'ShortSelling':\n            quantity = min(contract.short_selling_balance, quantity)\n\n        return 1000*quantity\n\n    def get_stock_amount(self, target: str, price: float, quantity: int, mode='long'):\n        '''\u8a08\u7b97\u80a1\u7968\u59d4\u8a17\u91d1\u984d'''\n\n        leverage = self.check_leverage(target, mode)\n        fee = max(price*quantity*FEE_RATE, 20)\n        return price*quantity*(1 - leverage) + fee\n\n    def get_open_slot(self, target: str, strategy: str):\n        '''\u8a08\u7b97\u8cb7\u9032\u53e3\u6578'''\n\n        if self.N_SLOT_TYPE == 'constant':\n            return self.N_SLOT\n\n        quantityFunc = self.StrategySet.mapQuantities(strategy)\n\n        inputs = self.Quotes.NowTargets[target]\n        slot, quantity_limit = quantityFunc(inputs=inputs, kbars=self.KBars)\n        slot = int(min(slot, quantity_limit))\n        slot = min(slot, 499)\n        return slot\n\n    def get_open_margin(self, target: str, quantity: int):\n        '''\u8a08\u7b97\u671f\u8ca8\u4fdd\u8b49\u91d1\u984d'''\n\n        if target in self.Quotes.NowTargets and self.margin_table and target in self.margin_table:\n            fee = 100\n            return self.margin_table[target]*quantity + fee\n        return 0\n\n    def get_pct_chg_DowJones(self):\n        '''\u53d6\u5f97\u9053\u74ca\u6307\u6578\u524d\u4e00\u5929\u7684\u6f32\u8dcc\u5e45'''\n\n        start = self._strf_timedelta(TODAY, 30)\n        dj = crawler2.DowJones(start, TODAY_STR)\n        if 'c' in dj and len(dj['c']):\n            dj = dj['c']\n            return 100*round(dj[0]/dj[1] - 1, 4)\n        return 0\n\n    def get_cost_price(self, target: str, price: float, order_cond: str):\n        '''\u53d6\u5f97\u80a1\u7968\u7684\u9032\u5834\u50f9'''\n\n        if order_cond == 'ShortSelling':\n            return price\n\n        cost_price = self.stocks.set_index('code').cost_price.to_dict()\n        if target in cost_price:\n            return cost_price[target]\n        return 0\n\n    def check_leverage(self, target: str, mode='long'):\n        '''\u53d6\u5f97\u500b\u80a1\u7684\u878d\u8cc7/\u878d\u5238\u6210\u6578'''\n        if mode in ['long', 'MarginTrading'] and target in self.LEVERAGE_LONG:\n            return self.LEVERAGE_LONG[target]\n        elif mode in ['short', 'ShortSelling'] and target in self.LEVERAGE_SHORT:\n            return 1 - self.LEVERAGE_SHORT[target]\n        return 0\n\n    def check_order_cond(self, target: str, mode='long'):\n        '''\u6aa2\u67e5\u500b\u80a1\u53ef\u5426\u878d\u8cc7'''\n\n        contract = get_contract(target)\n        if mode == 'long':\n            if self.ORDER_COND1 != 'Cash' and (self.LEVERAGE_LONG[target] == 0 or contract.margin_trading_balance == 0):\n                return 'Cash'\n            return self.ORDER_COND1\n        else:\n            if self.ORDER_COND2 != 'Cash' and (self.LEVERAGE_SHORT[target] == 1 or contract.short_selling_balance == 0):\n                return 'Cash'\n            return self.ORDER_COND2\n\n    def check_enough(self, target: str, quantity: int, mode='long'):\n        '''\u8a08\u7b97\u53ef\u8cb7\u9032\u7684\u80a1\u7968\u6578\u91cf & \u91d1\u984d'''\n\n        if target not in self.Quotes.NowTargets:\n            return False\n\n        # \u66f4\u65b0\u53ef\u8cb7\u9032\u7684\u80a1\u7968\u984d\u5ea6 TODO: buy_deals, sell_deals\u6703\u5408\u8a08\u591a\u7a7a\u80a1\u7968\u6578\uff0c\u4f7fquota1, quota2\u7121\u6cd5\u7cbe\u6e96\n        buy_deals = len([s for s in self.stock_bought if len(s) == 4])\n        sell_deals = len([s for s in self.stock_sold if len(s) == 4])\n        quota1 = abs(self.N_LIMIT_LS) - self.n_stocks_long - \\\n            buy_deals + sell_deals\n        quota2 = abs(self.N_LIMIT_SS) - self.n_stocks_short + \\\n            buy_deals - sell_deals\n\n        # \u66f4\u65b0\u5df2\u59d4\u8a17\u91d1\u984d\n        df = self.filterOrderTable('Stocks')\n        df = df[df.code.apply(len) == 4]\n        amount1 = df.amount.sum()\n        amount2 = df[df.price > 0].amount.abs().sum()\n        amount3 = df[df.price < 0].amount.abs().sum()\n\n        cost_price = self.Quotes.NowTargets[target]['price']\n        target_amount = self.get_stock_amount(\n            target, cost_price, quantity, mode)\n\n        # under day limit condition\n        # 1. \u4e0d\u53ef\u8d85\u904e\u53ef\u4ea4\u5272\u91d1\u984d\n        # 2. \u4e0d\u53ef\u5927\u65bc\u5e33\u6236\u53ef\u59d4\u8a17\u91d1\u984d\u4e0a\u9650\n        # 3. \u4e0d\u53ef\u8d85\u904e\u80a1\u7968\u6578\u4e0a\u9650\n        if mode == 'long':\n            return (\n                (amount1 + target_amount <= self.desposal_money) &\n                (amount2 + target_amount <= self.POSITION_LIMIT_LONG) &\n                (quota1 > 0)\n            )\n\n        return (\n            (amount1 + target_amount <= self.desposal_money) &\n            (amount2 + target_amount <= self.POSITION_LIMIT_LONG) &\n            # 4. \u4e0d\u53ef\u8d85\u904e\u53ef\u4fe1\u7528\u4ea4\u6613\u984d\u5ea6\u4e0a\u9650\n            (amount3 + target_amount <= self.POSITION_LIMIT_SHORT) &\n            (quota2 > 0)\n        )\n\n    def _check_enough_open(self, target: str, quantity: int):\n        '''\u8a08\u7b97\u53ef\u958b\u5009\u7684\u671f\u8ca8\u53e3\u6578 & \u91d1\u984d'''\n\n        # \u66f4\u65b0\u53ef\u958b\u5009\u7684\u671f\u8ca8\u6a19\u7684\u6578\n        open_deals = len(self.futures_opened)\n        close_deals = len(self.futures_closed)\n        quota = abs(self.N_FUTURES_LIMIT) - \\\n            self.n_futures - open_deals + close_deals\n\n        # \u66f4\u65b0\u5df2\u59d4\u8a17\u91d1\u984d\n        df = self.filterOrderTable('Futures')\n        amount1 = df.amount.sum()\n        amount2 = df[df.price > 0].amount.sum()\n\n        # under day limit condition\n        # 1. \u4e0d\u53ef\u8d85\u904e\u53ef\u4ea4\u5272\u4fdd\u8b49\u91d1\n        # 2. \u4e0d\u53ef\u5927\u65bc\u5e33\u6236\u53ef\u59d4\u8a17\u4fdd\u8b49\u91d1\u4e0a\u9650\n        # 3. \u4e0d\u53ef\u8d85\u904e\u80a1\u7968\u6578\u4e0a\u9650\n        target_amount = self.get_open_margin(target, quantity)\n        return (\n            (amount1 + target_amount <= self.desposal_margin) &\n            (amount2 + target_amount <= self.MARGIN_LIMIT) &\n            (quota > 0)\n        )\n\n    def is_not_trade_day(self, now: datetime):\n        '''\u6aa2\u67e5\u662f\u5426\u70ba\u975e\u4ea4\u6613\u6642\u6bb5'''\n        is_holiday = TODAY in holidays\n        if self.can_futures:\n            close1 = (\n                (now > TimeEndFuturesNight) and\n                (now < TimeStartFuturesDay + timedelta(days=1))\n            )\n            close2 = now > TimeEndFuturesDay and now < TimeStartFuturesNight\n            if self.TRADING_PERIOD != 'Day':\n                # trader only closes during 05:00 ~ 08:45\n                close2 = False\n\n            return is_holiday or close1 or close2\n\n        return is_holiday or not (now <= TEnd)\n\n    def remove_stock_monitor_list(self, target: str):\n        logging.debug(f'Remove\u3010{target}\u3011from stocks_to_monitor.')\n        self.stocks_to_monitor.pop(target, None)\n\n        if target in self.stocks.code.values:\n            logging.debug(f'Remove\u3010{target}\u3011from self.stocks.')\n            self.stocks = self.stocks[self.stocks.code != target]\n            if self.simulation and db.HAS_DB:\n                db.delete(\n                    SecurityInfoStocks,\n                    SecurityInfoStocks.code == target,\n                    SecurityInfoStocks.account == self.ACCOUNT_NAME\n                )\n\n    def remove_futures_monitor_list(self, target: str):\n        '''Remove futures from futures_to_monitor'''\n        logging.debug(f'Remove\u3010{target}\u3011from futures_to_monitor.')\n        self.futures_to_monitor.pop(target, None)\n\n        if target in self.futures.CodeName.values:\n            logging.debug(f'Remove\u3010{target}\u3011from self.futures.')\n            self.futures = self.futures[self.futures.CodeName != target]\n            if self.simulation and db.HAS_DB:\n                db.delete(\n                    SecurityInfoFutures,\n                    SecurityInfoFutures.CodeName == target,\n                    SecurityInfoFutures.Account == self.ACCOUNT_NAME\n                )\n\n    def run(self):\n        '''\u57f7\u884c\u81ea\u52d5\u4ea4\u6613'''\n\n        strategy_s, all_stocks = self.init_stocks()\n        strategy_f, all_futures = self.init_futures()\n        usage = round(API.usage().bytes/2**20, 2)\n        self.subscribe_all(all_stocks+all_futures)\n\n        logging.info(f\"Current data usage: {usage}\")\n        logging.info(f\"Today's punish lis: {self.punish_list}\")\n        logging.info(f\"Stocks Ex-dividend: {self.StrategySet.dividends}\")\n        logging.info(f\"Previous Put/Call ratio: {self.StrategySet.pc_ratio}\")\n        logging.info(f'Start to monitor, basic settings:')\n        logging.info(f'Mode:{self.MODE}, Strategy: {self.STRATEGY_STOCK}')\n        logging.info(f'[Stock Strategy] {strategy_s}')\n        logging.info(f'[Stock Position] Long: {self.n_stocks_long}')\n        logging.info(f'[Stock Position] Short: {self.n_stocks_short}')\n        logging.info(f'[Stock Portfolio Limit] Long: {self.N_LIMIT_LS}')\n        logging.info(f'[Stock Portfolio Limit] Short: {self.N_LIMIT_SS}')\n        logging.info(\n            f'[Stock Position Limit] Long: {self.POSITION_LIMIT_LONG}')\n        logging.info(\n            f'[Stock Position Limit] Short: {self.POSITION_LIMIT_SHORT}')\n        logging.info(f'[Futures Strategy] {strategy_f}')\n        logging.info(f'[Futures position] {self.n_futures}')\n        logging.info(f'[Futures portfolio Limit] {self.N_FUTURES_LIMIT}')\n\n        text = f\"\\n\u3010\u958b\u59cb\u76e3\u63a7\u3011{self.ACCOUNT_NAME} \u555f\u52d5\u5b8c\u6210({__version__})\"\n        text += f\"\\n\u3010\u64cd\u76e4\u6a21\u5f0f\u3011{self.MODE}\\n\u3010\u64cd\u76e4\u7b56\u7565\u3011{self.STRATEGY_STOCK}\"\n        text += f\"\\n\u3010\u524d\u65e5\u884c\u60c5\u3011Put/Call: {self.StrategySet.pc_ratio}\"\n        text += f\"\\n\u3010\u7f8e\u80a1\u884c\u60c5\u3011\u9053\u74ca({self.pct_chg_DowJones}%)\"\n        text += f\"\\n\u3010\u6578\u64da\u7528\u91cf\u3011{usage}MB\"\n        notifier.post(text, msgType='Monitor')\n\n        # \u958b\u59cb\u76e3\u63a7\n        while True:\n            now = datetime.now()\n\n            if self.is_not_trade_day(now):\n                logging.info('Non-trading time, stop monitoring')\n                self.updateKBars('2T')\n                self.updateKBars('5T')\n                self.updateKBars('15T')\n                self.updateKBars('30T')\n                self.updateKBars('60T')\n                break\n            elif all(x == 0 for x in [\n                self.n_stocks_long, self.n_stocks_short,\n                self.N_LIMIT_LS, self.N_LIMIT_SS,\n                self.N_FUTURES_LIMIT, self.n_futures\n            ]):\n                self._log_and_notify(f\"\u3010\u505c\u6b62\u76e3\u63a7\u3011{self.ACCOUNT_NAME} \u7121\u53ef\u76e3\u63a7\u6e05\u55ae\")\n                break\n\n            # update K-bar data\n            is_trading_time = (\n                (self.can_futures and now > TimeStartFuturesDay + timedelta(seconds=30)) or\n                (self.can_stock and now > TimeStartStock + timedelta(seconds=30))\n            )\n            if is_trading_time and now.second < 5:\n                self._update_K1(self.StrategySet.dividends, quotes=self.Quotes)\n                self._set_target_quote_default(all_stocks+all_futures)\n                self._set_index_quote_default()\n                self.StrategySet.update_indicators(now, self.KBars)\n\n                if now.minute % 2 == 0:\n                    self.updateKBars('2T')\n\n                if now.minute % 5 == 0:\n                    self.updateKBars('5T')\n                    self.balance(mode='debug')  # \u9632\u6b62\u65b7\u7dda\u7528 TODO:\u5f85\u6c38\u8c50\u66f4\u65b0\u5f8c\u522a\u9664\n\n                if now.minute % 15 == 0:\n                    self.updateKBars('15T')\n\n                if now.minute % 30 == 0:\n                    self.updateKBars('30T')\n\n                if now.minute == 0:\n                    self.updateKBars('60T')\n\n            # TODO: merge stocks_to_monitor & futures_to_monitor\n            for target in list(self.stocks_to_monitor):\n                order = self.monitor_stocks(target, strategy_s)\n                if order.pos_target:\n                    self._place_order(order, market='Stocks')\n                    self._update_position(order, strategy_s)\n\n            for target in list(self.futures_to_monitor):\n                order = self.monitor_futures(target, strategy_f)\n                if order.pos_target:\n                    self._place_order(order, market='Futures')\n                    self._update_position(order, strategy_f)\n\n            time.sleep(max(5 - (datetime.now() - now).total_seconds(), 0))\n\n        time.sleep(10)\n        self.unsubscribe_all(all_stocks+all_futures)\n\n    def simulator_update_securityInfo(self, df: pd.DataFrame, table):\n        market = 'stocks' if 'stocks' in table.__tablename__ else 'futures'\n        if db.HAS_DB:\n            if market == 'stocks':\n                match_account = table.account == self.ACCOUNT_NAME\n                codes = db.query(table.code, match_account).code.values\n                tb = df[~df.code.isin(codes)]\n                update_values = df[df.code.isin(codes)].set_index('code')\n            else:\n                match_account = table.Account == self.ACCOUNT_NAME\n                codes = db.query(table.Code, match_account).Code.values\n                tb = df[~df.Code.isin(codes)]\n                update_values = df[df.Code.isin(codes)].set_index('Code')\n\n            # add new stocks\n            db.dataframe_to_DB(tb, table)\n\n            # update in-stocks\n            update_values = update_values.to_dict('index')\n            for target, values in update_values.items():\n                if market == 'stocks':\n                    condition = table.code == target, match_account\n                else:\n                    condition = table.Code == target, match_account\n                db.update(table, values, *condition)\n        else:\n            self.save_table(\n                df=df,\n                filename=f'{PATH}/stock_pool/simulation_{market}_{self.ACCOUNT_NAME}.pkl'\n            )\n\n    def __save_simulate_securityInfo(self):\n        '''\u5132\u5b58\u6a21\u64ec\u4ea4\u6613\u6a21\u5f0f\u4e0b\u7684\u80a1\u7968\u5eab\u5b58\u8868'''\n        if self.simulation:\n            # \u5132\u5b58\u5eab\u5b58\n            logging.debug(f'stocks_to_monitor: {self.stocks_to_monitor}')\n            logging.debug(\n                f'stocks shape: {self.stocks.shape}; watchlist shape: {self.watchlist.shape}')\n            df = {k: v for k, v in self.stocks_to_monitor.items() if v}\n            df = pd.DataFrame(df).T\n            if df.shape[0]:\n                df = df[df.account_id == f'simulate-{self.ACCOUNT_NAME}']\n                df = df.sort_values('code').reset_index()\n                df['last_price'] = df.code.map(\n                    {s: self.Quotes.NowTargets[s]['price'] for s in df.code})\n                df['pnl'] = df.action.apply(lambda x: 1 if x == 'Buy' else -1)\n                df['pnl'] = df.pnl*(df.last_price - df.cost_price)*df.quantity\n                df.yd_quantity = df.quantity\n                df['account'] = self.ACCOUNT_NAME\n                df = df[self.df_securityInfo.columns]\n            else:\n                df = self.df_securityInfo\n            logging.debug(\n                f'stocks shape: {df.shape}; watchlist shape: {self.watchlist.shape}')\n\n            if df.shape[0]:\n                self.simulator_update_securityInfo(df, SecurityInfoStocks)\n\n    def __save_simulate_futuresInfo(self):\n        '''\u5132\u5b58\u6a21\u64ec\u4ea4\u6613\u6a21\u5f0f\u4e0b\u7684\u671f\u8ca8\u5eab\u5b58\u8868'''\n        if self.simulation:\n            # \u5132\u5b58\u5eab\u5b58\n            logging.debug(f'futures_to_monitor: {self.futures_to_monitor}')\n            df = {k: v for k, v in self.futures_to_monitor.items() if v}\n            df = pd.DataFrame(df).T\n            if df.shape[0]:\n                df = df[df.account_id == f'simulate-{self.ACCOUNT_NAME}']\n                df = df.reset_index(drop=True)\n                df = df.rename(columns={\n                    'account_id': 'Account',\n                    'market': 'Market',\n                    'bst': 'Date',\n                    'symbol': 'CodeName',\n                    'action': 'OrderBS',\n                    'quantity': 'Volume',\n                    'cost_price': 'ContractAverPrice',\n                    'price': 'RealPrice',\n                })\n                df['Code'] = df.CodeName.apply(lambda x: get_contract(x).code)\n                df.Account = self.ACCOUNT_NAME\n\n                for c in self.df_futuresInfo.columns:\n                    if c not in df.columns:\n                        if c in [\n                            'ContractAverPrice', 'SettlePrice',\n                            'RealPrice', 'FlowProfitLoss',\n                            'SettleProfitLoss', 'OTAMT', 'MTAMT'\n                        ]:\n                            df[c] = 0\n                        else:\n                            df[c] = ''\n                df = df[self.df_futuresInfo.columns]\n            else:\n                df = self.df_futuresInfo\n\n            if df.shape[0]:\n                self.simulator_update_securityInfo(df, SecurityInfoFutures)\n\n    def output_files(self):\n        '''\u505c\u6b62\u4ea4\u6613\u6642\uff0c\u8f38\u51fa\u5eab\u5b58\u8cc7\u6599 & \u4ea4\u6613\u660e\u7d30'''\n        if 'position' in self.stocks.columns and not self.simulation:\n            codeList = self.get_securityInfo('Stocks').code.to_list()\n            self.update_watchlist(codeList)\n\n        self.save_watchlist(self.watchlist)\n        self.output_statement(\n            f'{PATH}/stock_pool/statement_{self.ACCOUNT_NAME}.csv')\n\n        if (datetime.now().weekday() not in [5, 6]):\n            for freq, df in self.KBars.items():\n                if freq != '1D':\n                    filename = f'{PATH}/Kbars/k{freq[:-1]}min_{self.ACCOUNT_NAME}.csv'\n                    self.save_table(df, filename)\n\n        if self.can_stock:\n            self.__save_simulate_securityInfo()\n\n        if self.can_futures:\n            self.__save_simulate_futuresInfo()\n\n        time.sleep(5)", "\n\nclass StrategyExecutor(AccountInfo, WatchListTool, KBarTool, OrderTool, Subscriber):\n    def __init__(self, config=None):\n        self.ct = CipherTool(decrypt=True, encrypt=False)\n        self.CONFIG = config\n\n        # \u4ea4\u6613\u5e33\u6236\u8a2d\u5b9a\n        self.ACCOUNT_NAME = self.getENV('ACCOUNT_NAME')\n        self.__API_KEY__ = self.getENV('API_KEY')\n        self.__SECRET_KEY__ = self.getENV('SECRET_KEY')\n        self.__ACCOUNT_ID__ = self.getENV('ACCOUNT_ID', 'decrypt')\n        self.__CA_PASSWD__ = self.getENV('CA_PASSWD', 'decrypt')\n\n        # \u80a1\u7968\u4f7f\u7528\u8005\u8a2d\u5b9a\n        self.KBAR_START_DAYay = self.getENV('KBAR_START_DAYay', 'date')\n        self.MODE = self.getENV('MODE')\n        self.MARKET = self.getENV('MARKET')\n        self.FILTER_OUT = self.getENV('FILTER_OUT', 'list')\n        self.STRATEGY_STOCK = self.getENV('STRATEGY_STOCK', 'list')\n        self.PRICE_THRESHOLD = self.getENV('PRICE_THRESHOLD', 'int')\n        self.INIT_POSITION = self.getENV('INIT_POSITION', 'int')\n        self.POSITION_LIMIT_LONG = self.getENV('POSITION_LIMIT_LONG', 'int')\n        self.POSITION_LIMIT_SHORT = self.getENV('POSITION_LIMIT_SHORT', 'int')\n        self.N_STOCK_LIMIT_TYPE = self.getENV('N_STOCK_LIMIT_TYPE')\n        self.N_LIMIT_LS = self.getENV('N_LIMIT_LS', 'int')\n        self.N_LIMIT_SS = self.getENV('N_LIMIT_SS', 'int')\n        self.BUY_UNIT = self.getENV('BUY_UNIT', 'int')\n        self.BUY_UNIT_TYPE = self.getENV('BUY_UNIT_TYPE')\n        self.ORDER_COND1 = self.getENV('ORDER_COND1')\n        self.ORDER_COND2 = self.getENV('ORDER_COND2')\n        self.LEVERAGE_LONG = {}\n        self.LEVERAGE_SHORT = {}\n        self.day_trade_cond = {\n            'MarginTrading': 'ShortSelling',\n            'ShortSelling': 'MarginTrading',\n            'Cash': 'Cash'\n        }\n        self.simulation = self.MODE == 'Simulation'\n\n        # \u671f\u8ca8\u4f7f\u7528\u8005\u8a2d\u5b9a\n        self.TRADING_PERIOD = self.getENV('TRADING_PERIOD')\n        self.STRATEGY_FUTURES = self.getENV('STRATEGY_FUTURES', 'list')\n        self.MARGIN_LIMIT = self.getENV('MARGIN_LIMIT', 'int')\n        self.N_FUTURES_LIMIT_TYPE = self.getENV('N_FUTURES_LIMIT_TYPE')\n        self.N_FUTURES_LIMIT = self.getENV('N_FUTURES_LIMIT', 'int')\n        self.N_SLOT = self.getENV('N_SLOT', 'int')\n        self.N_SLOT_TYPE = self.getENV('N_SLOT_TYPE')\n\n        super().__init__()\n        KBarTool.__init__(self, self.KBAR_START_DAYay)\n        OrderTool.__init__(self)\n        Subscriber.__init__(self)\n        WatchListTool.__init__(self, self.ACCOUNT_NAME)\n\n        # \u80a1\u7968\u53ef\u9032\u5834\u7c4c\u78bc (\u9032\u5834\u6642\u5224\u65b7\u7528)\n        self.simulate_amount = np.iinfo(np.int64).max\n        self.stocks = pd.DataFrame()\n        self.desposal_money = 0\n        self.stock_bought = []\n        self.stock_sold = []\n        self.n_stocks_long = 0\n        self.n_stocks_short = 0\n        self.total_market_value = 0\n        self.punish_list = []\n        self.pct_chg_DowJones = self.get_pct_chg_DowJones()\n        self.n_categories = None\n\n        # \u671f\u8ca8\u53ef\u9032\u5834\u7c4c\u78bc (\u9032\u5834\u6642\u5224\u65b7\u7528)\n        self.futures_opened = []\n        self.futures_closed = []\n        self.futures_transferred = {}\n        self.n_futures = 0\n        self.futures = pd.DataFrame()\n        self.Futures_Code_List = {}\n        self.margin_table = None\n\n        # \u4ea4\u6613\u76f8\u95dc\n        self.can_stock = 'stock' in self.MARKET\n        self.can_sell = self.MODE not in ['LongBuy', 'ShortBuy']\n        self.can_buy = self.MODE not in ['LongSell', 'ShortSell']\n        self.can_futures = 'futures' in self.MARKET\n        self.stocks_to_monitor = {}\n        self.futures_to_monitor = {}\n\n        # \u8f09\u5165\u6307\u6a19\u6a21\u7d44\n        self.set_scripts(StrategySets)\n\n    def set_scripts(self, strategySet: object):\n        self.StrategySet = strategySet(\n            account_name=self.ACCOUNT_NAME,\n            hold_day=self.getENV('HOLD_DAY', 'int'),\n            is_simulation=self.simulation,\n            stock_limit_type=self.N_STOCK_LIMIT_TYPE,\n            futures_limit_type=self.N_FUTURES_LIMIT_TYPE,\n            stock_limit_long=self.N_LIMIT_LS,\n            stock_limit_short=self.N_LIMIT_SS,\n            futures_limit=self.N_FUTURES_LIMIT,\n        )\n\n    def getENV(self, key: str, type_: str = 'text'):\n        if self.CONFIG and key in self.CONFIG:\n            env = self.CONFIG[key]\n\n            if type_ == 'int':\n                return int(env)\n            elif type_ == 'list':\n                if 'none' in env.lower():\n                    return []\n                return env.replace(' ', '').split(',')\n            elif type_ == 'date' and env:\n                return pd.to_datetime(env)\n            elif type_ == 'decrypt':\n                if not env or (not env[0].isdigit() and env[1:].isdigit()):\n                    return env\n                return self.ct.decrypt(env)\n            return env\n        elif type_ == 'int':\n            return 0\n        elif type_ == 'list':\n            return []\n        return None\n\n    def _set_trade_risks(self):\n        '''\u8a2d\u5b9a\u4ea4\u6613\u98a8\u96aa\u503c: \u53ef\u4ea4\u5272\u91d1\u984d\u3001\u7e3d\u5e02\u503c'''\n\n        cost_value = (self.stocks.quantity * self.stocks.cost_price).sum()\n        pnl = self.stocks.pnl.sum()\n        if self.simulation:\n            account_balance = self.INIT_POSITION\n            settle_info = pnl\n        else:\n            account_balance = self.balance()\n            settle_info = self.settle_info(mode='info').iloc[1:, 1].sum()\n\n        self.desposal_money = min(\n            account_balance+settle_info, self.POSITION_LIMIT_LONG)\n        self.total_market_value = self.desposal_money + cost_value + pnl\n\n        logging.info(\n            f'Desposal amount = {self.desposal_money} (limit: {self.POSITION_LIMIT_LONG})')\n\n    def _set_margin_limit(self):\n        '''\u8a08\u7b97\u53ef\u4ea4\u5272\u7684\u4fdd\u8b49\u91d1\u984d\uff0c\u4e0d\u53ef\u8d85\u904e\u5e33\u6236\u53ef\u4e0b\u55ae\u7684\u4fdd\u8b49\u91d1\u984d\u4e0a\u9650'''\n        if self.simulation:\n            self.desposal_margin = self.simulate_amount\n            self.ProfitAccCount = self.simulate_amount\n        else:\n            self.get_account_margin()\n        self.desposal_margin = min(self.desposal_margin, self.MARGIN_LIMIT)\n        logging.info(f'\u6b0a\u76ca\u7e3d\u503c: {self.ProfitAccCount}')\n        logging.info(\n            f'Margin available = {self.desposal_margin} (limit: {self.MARGIN_LIMIT})')\n\n    def _set_leverage(self, stockids: list):\n        '''\n        \u53d6\u5f97\u500b\u80a1\u878d\u8cc7\u6210\u6578\u8cc7\u6599\uff0c\n        \u82e5\u5e33\u6236\u8a2d\u5b9a\u70ba\u4e0d\u53ef\u878d\u8cc7\uff0c\u5247\u5168\u90e8\u878d\u8cc7\u6210\u6578\u70ba0\n        '''\n\n        df = pd.DataFrame([crawler2.get_leverage(s) for s in stockids])\n        if df.shape[0]:\n            df.loc[df.\u500b\u80a1\u878d\u5238\u4fe1\u7528\u8cc7\u683c == 'N', '\u878d\u5238\u6210\u6578'] = 100\n            df.\u4ee3\u865f = df.\u4ee3\u865f.astype(str)\n            df.\u878d\u8cc7\u6210\u6578 /= 100\n            df.\u878d\u5238\u6210\u6578 /= 100\n\n            if self.ORDER_COND1 != 'Cash':\n                self.LEVERAGE_LONG = df.set_index('\u4ee3\u865f').\u878d\u8cc7\u6210\u6578.to_dict()\n            else:\n                self.LEVERAGE_LONG = {code: 0 for code in stockids}\n\n            if self.ORDER_COND2 != 'Cash':\n                self.LEVERAGE_SHORT = df.set_index('\u4ee3\u865f').\u878d\u5238\u6210\u6578.to_dict()\n            else:\n                self.LEVERAGE_SHORT = {code: 1 for code in stockids}\n\n        logging.info(f'Long leverages: {self.LEVERAGE_LONG}')\n        logging.info(f'Short leverages: {self.LEVERAGE_SHORT}')\n\n    def _set_futures_code_list(self):\n        '''\u671f\u8ca8\u5546\u54c1\u4ee3\u865f\u8207\u4ee3\u78bc\u5c0d\u7167\u8868'''\n        if self.can_futures and self.Futures_Code_List == {}:\n            logging.debug('Set Futures_Code_List')\n            self.Futures_Code_List = {\n                f.code: f.symbol for m in API.Contracts.Futures for f in m}\n\n    def __order_callback(self, stat, msg):\n        '''\u8655\u7406\u59d4\u8a17/\u6210\u4ea4\u56de\u5831'''\n\n        if stat == constant.OrderState.StockOrder:\n            stock = msg['contract']['code']\n            order = msg['order']\n            operation = msg['operation']\n\n            c2 = operation['op_code'] == '00' or operation['op_msg'] == ''\n            c3 = order['action'] == 'Buy'\n            c4 = operation['op_code'] == '88' and '\u6b64\u8b49\u5238\u914d\u984d\u5f35\u6578\u4e0d\u8db3' in operation['op_msg']\n            c5 = len(stock) == 4\n\n            if order['account']['account_id'] == self.account_id_stock:\n                notifier.post_tftOrder(stat, msg)\n\n                if c3 and c5 and stock not in self.stock_bought:\n                    self.stock_bought.append(stock)\n\n                leverage = self.check_leverage(stock, order['order_cond'])\n                if c2 and c3:\n                    # \u8a18\u9304\u59d4\u8a17\u6210\u529f\u7684\u8cb7\u55ae\n                    price = self.Quotes.NowTargets[stock]['price'] if stock in self.Quotes.NowTargets else order['price']\n                    quantity = order['quantity']\n                    if order['order_lot'] == 'Common':\n                        quantity *= 1000\n                    order_data = {\n                        'Time': datetime.now(),\n                        'market': 'Stocks',\n                        'code': stock,\n                        'action': order['action'],\n                        'price': price,\n                        'quantity': quantity,\n                        'amount': self.get_stock_amount(stock, price, quantity, order['order_cond']),\n                        'order_cond': order['order_cond'],\n                        'order_lot': order['order_lot'],\n                        'leverage': leverage,\n                        'account_id': order['account']['account_id']\n                    }\n                    self.appendOrder(order_data)\n\n                # \u82e5\u878d\u8cc7\u914d\u984d\u5f35\u6578\u4e0d\u8db3\uff0c\u6539\u73fe\u80a1\u8cb7\u9032 ex: '\u6b64\u8b49\u5238\u914d\u984d\u5f35\u6578\u4e0d\u8db3\uff0c\u9918\u984d 0 \u5f35\uff08\u8b49\u91d1\uff1a 0 \uff09'\n                elif c4:\n                    q_balance = operation['op_msg'].split(' ')\n                    if len(q_balance) > 1:\n                        q_balance = int(q_balance[1])\n                        infos = dict(\n                            action=order['action'], target=stock, pos_target=100, pos_balance=100)\n                        # \u82e5\u672c\u65e5\u9084\u6c92\u6709\u4e0b\u904e\u878d\u8cc7\u4e14\u5269\u9918\u5238\u6578\u70ba0\uff0c\u624d\u53ef\u4ee5\u6539\u4e0b\u73fe\u80a1\n                        if q_balance == 0 and stock not in self.stock_bought:\n                            orderinfo = self.OrderInfo(\n                                quantity=1000 *\n                                int(order['quantity']*(1-leverage)),\n                                order_cond='Cash',\n                                **infos\n                            )\n                            self._place_order(orderinfo, market='Stocks')\n\n                        elif q_balance > 0:\n                            orderinfo = self.OrderInfo(\n                                quantity=q_balance,\n                                order_cond=order['order_cond'],\n                                **infos\n                            )\n                            self._place_order(orderinfo, market='Stocks')\n\n                # \u82e5\u522a\u55ae\u6210\u529f\u5c31\u81ea\u6e05\u55ae\u79fb\u9664\n                if operation['op_type'] == 'Cancel':\n                    self.deleteOrder(stock)\n                    if c3 and stock in self.stock_bought:\n                        self.stock_bought.remove(stock)\n\n        elif stat == constant.OrderState.StockDeal and msg['account_id'] == self.account_id_stock:\n            stock = msg['code']\n            msg.update({\n                'position': 100,\n                'yd_quantity': 0,\n                'bst': datetime.now(),\n                'cost_price': msg['price']\n            })\n            notifier.post_tftDeal(stat, msg)\n\n            if msg['order_lot'] == 'Common':\n                msg['quantity'] *= 1000\n\n            quantity = msg['quantity']\n            if msg['action'] == 'Sell':\n\n                if stock not in self.stock_sold and len(stock) == 4:\n                    self.stock_sold.append(stock)\n\n                price = msg['price']\n                leverage = self.check_leverage(stock, msg['order_cond'])\n                cost_price = self.get_cost_price(\n                    stock, price, msg['order_cond'])\n\n                # \u7d00\u9304\u6210\u4ea4\u7684\u8ce3\u55ae\n                order_data = {\n                    'Time': datetime.now(),\n                    'market': 'Stocks',\n                    'code': stock,\n                    'price': -price,\n                    'quantity': quantity,\n                    # \u8ce3\u51fa\u91d1\u984d - \u878d\u8cc7\u91d1\u984d - \u624b\u7e8c\u8cbb\n                    'amount': -(price - cost_price*leverage)*quantity*(1 - FEE_RATE),\n                    'order_cond': msg['order_cond'],\n                    'order_lot': msg['order_lot'],\n                    'leverage': leverage,\n                    'account_id': msg['account_id']\n                }\n                self.appendOrder(order_data)\n\n            # \u66f4\u65b0\u76e3\u63a7\u5eab\u5b58\n            if not self.simulation:\n                self.update_monitor_lists(msg['action'], msg)\n\n        elif stat == constant.OrderState.FuturesOrder:\n            code = msg['contract']['code']\n            symbol = code + msg['contract']['delivery_month']\n            bsh = self.Quotes.AllTargets[symbol]['price']\n            msg.update({\n                'symbol': symbol,\n                'cost_price': self.Quotes.NowTargets[symbol]['price'] if symbol in self.Quotes.NowTargets else 0,\n                'bsh': max(bsh) if bsh else 0,\n                'bst': datetime.now(),\n                'position': 100\n            })\n            order = msg['order']\n            operation = msg['operation']\n\n            if order['account']['account_id'] == self.account_id_futopt:\n                notifier.post_fOrder(stat, msg)\n                if operation['op_code'] == '00' or operation['op_msg'] == '':\n                    self._update_futures_deal_list(symbol, order['oc_type'])\n\n                    # \u7d00\u9304\u6210\u4ea4\u7684\u8ce3\u55ae\n                    price = -order['price'] if c4 else order['price']\n                    sign = -1 if order['action'] == 'Sell' else 1\n                    quantity = order['quantity']\n                    order_data = {\n                        'Time': datetime.now(),\n                        'market': 'Futures',\n                        'code': symbol,\n                        'price': price*sign,\n                        'quantity': quantity,\n                        'amount': self.get_open_margin(symbol, quantity)*sign,\n                        'op_type': order['oc_type'],\n                        'account_id': order['account']['account_id']\n                    }\n                    self.appendOrder(order_data)\n\n                # \u82e5\u522a\u55ae\u6210\u529f\u5c31\u81ea\u6e05\u55ae\u79fb\u9664\n                if operation['op_type'] == 'Cancel':\n                    self.deleteOrder(symbol)\n                    if symbol in self.futures_opened:\n                        self.futures_opened.remove(symbol)\n\n                # \u66f4\u65b0\u76e3\u63a7\u5eab\u5b58\n                if not self.simulation:\n                    self.update_monitor_lists(operation['op_type'], msg)\n\n        elif stat == constant.OrderState.FuturesDeal:\n            notifier.post_fDeal(stat, msg)\n\n    def login_and_activate(self):\n        # \u767b\u5165\n        self._login(self.__API_KEY__, self.__SECRET_KEY__, self.ACCOUNT_NAME)\n        self.account_id_stock = API.stock_account.account_id\n        logging.info(f'Stock account ID: {self.account_id_stock}')\n\n        if self.HAS_FUTOPT_ACCOUNT:\n            self.can_futures = 'futures' in self.MARKET\n            self.account_id_futopt = API.futopt_account.account_id\n            self._set_futures_code_list()\n            logging.info(f'Futures account ID: {self.account_id_futopt}')\n\n        # \u555f\u52d5\u6191\u8b49 (Mac \u4e0d\u9700\u555f\u52d5)\n        if platform != 'darwin':\n            logging.info(f'Activate {self.ACCOUNT_NAME} CA')\n            if self.__CA_PASSWD__:\n                ca_passwd = self.__CA_PASSWD__\n            else:\n                ca_passwd = self.__ACCOUNT_ID__\n            API.activate_ca(\n                ca_path=f\"./lib/ekey/551/{self.__ACCOUNT_ID__}/S/Sinopac.pfx\",\n                ca_passwd=ca_passwd,\n                person_id=self.__ACCOUNT_ID__,\n            )\n\n        # \u7cfb\u7d71 callback \u8a2d\u5b9a\n        self._set_callbacks()\n\n    def _set_callbacks(self):\n        '''\u53d6\u5f97API\u56de\u50b3\u5831\u50f9'''\n        @API.on_tick_stk_v1()\n        def stk_quote_callback_v1(exchange, tick):\n            if tick.intraday_odd == 0 and tick.simtrade == 0:\n\n                if tick.code not in self.Quotes.NowTargets:\n                    logging.debug(f'First quote of {tick.code}')\n\n                tick_data = self.stk_quote_v1(tick)\n                # self.to_redis({tick.code: tick_data})\n\n        @API.on_tick_fop_v1()\n        def fop_quote_callback_v1(exchange, tick):\n            try:\n                if tick.simtrade == 0:\n                    symbol = self.Futures_Code_List[tick.code]\n\n                    if symbol not in self.Quotes.NowTargets:\n                        logging.debug(f'First quote of {symbol}')\n\n                    tick_data = self.fop_quote_v1(symbol, tick)\n                    # self.to_redis({symbol: tick_data})\n            except KeyError:\n                logging.exception('KeyError: ')\n\n        @API.quote.on_quote\n        def quote_callback(topic: str, quote: dict):\n            self.index_v0(quote)\n\n        @API.quote.on_event\n        def event_callback(resp_code: int, event_code: int, info: str, event: str):\n            if 'Subscription Not Found' in info:\n                logging.warning(info)\n\n            else:\n                logging.info(\n                    f'Response code: {resp_code} | Event code: {event_code} | info: {info} | Event: {event}')\n\n                if info == 'Session connect timeout' or event_code == 1:\n                    time.sleep(5)\n                    logging.info(f'\u767b\u51fa\u7cfb\u7d71: {API.logout()}')\n                    logging.warning('Re-login')\n\n                    time.sleep(5)\n                    self._login(self.__API_KEY__,\n                                self.__SECRET_KEY__, self.ACCOUNT_NAME)\n\n        # \u8a02\u95b1\u4e0b\u55ae\u56de\u5831\n        API.set_order_callback(self.__order_callback)\n\n        # \u8a02\u95b1\u4e94\u6a94\u56de\u5831\n        @API.on_bidask_stk_v1()\n        def stk_quote_callback(exchange, bidask):\n            self.BidAsk[bidask.code] = bidask\n\n        @API.on_bidask_fop_v1()\n        def fop_quote_callback(exchange, bidask):\n            symbol = self.Futures_Code_List[bidask.code]\n            self.BidAsk[symbol] = bidask\n\n    def _log_and_notify(self, msg: str):\n        '''\u5c07\u8a0a\u606f\u52a0\u5165log\u4e26\u63a8\u64ad'''\n        logging.info(msg)\n        notifier.post(f'\\n{msg}', msgType='Monitor')\n\n    def init_stocks(self):\n        '''\u521d\u59cb\u5316\u80a1\u7968\u8cc7\u8a0a'''\n\n        if not self.can_stock:\n            return None, []\n\n        # \u8b80\u53d6\u9078\u80a1\u6e05\u55ae\n        strategies = self.get_stock_pool()\n\n        # \u53d6\u5f97\u9060\u7aef\u5eab\u5b58\n        self.stocks = self.get_securityInfo('Stocks')\n\n        # \u53d6\u5f97\u7b56\u7565\u6e05\u55ae\n        self.init_watchlist(self.stocks, strategies)\n\n        # \u5eab\u5b58\u7684\u8655\u7406\n        self.stocks = self.stocks.merge(\n            self.watchlist,\n            how='left',\n            on=['account', 'market', 'code']\n        )\n        self.stocks.position.fillna(100, inplace=True)\n        strategies.update(self.stocks.set_index('code').strategy.to_dict())\n\n        # \u5254\u9664\u4e0d\u5805\u63a7\u7684\u80a1\u7968\n        self.stocks = self.stocks[~self.stocks.code.isin(self.FILTER_OUT)]\n\n        # \u65b0\u589e\u6b77\u53f2K\u68d2\u8cc7\u6599\n        self.update_stocks_to_monitor(strategies)\n        all_targets = list(self.stocks_to_monitor)\n        self.history_kbars(['TSE001', 'OTC101'] + all_targets)\n\n        # \u4ea4\u6613\u98a8\u96aa\u63a7\u5236\n        buy_condition = self.stocks.action == 'Buy'\n        self.n_stocks_long = self.stocks[buy_condition].shape[0]\n        self.n_stocks_short = self.stocks[~buy_condition].shape[0]\n        self.N_LIMIT_LS = self.StrategySet.setNStockLimitLong(KBars=self.KBars)\n        self.N_LIMIT_SS = self.StrategySet.setNStockLimitShort(\n            KBars=self.KBars)\n        self.punish_list = crawler2.get_punish_list().\u8b49\u5238\u4ee3\u865f.to_list()\n        self._set_leverage(all_targets)\n        self._set_trade_risks()\n        logging.debug(f'stocks_to_monitor: {self.stocks_to_monitor}')\n        return strategies, all_targets\n\n    def init_futures(self):\n        '''\u521d\u59cb\u5316\u671f\u8ca8\u8cc7\u8a0a'''\n\n        def preprocess_(df):\n            if df.shape[0]:\n                for c in ['Volume', 'ContractAverPrice', 'SettlePrice', 'RealPrice']:\n                    df[c] = df[c].astype(float)\n                    if c in ['ContractAverPrice', 'SettlePrice', 'RealPrice']:\n                        df[c] = df.groupby('Code')[c].transform('mean')\n                    else:\n                        df[c] = df.groupby('Code')[c].transform(sum)\n\n                df = df.drop_duplicates('Code')\n                df = df.rename(columns={'ContractAverPrice': 'cost_price'})\n                df.Code = df.Code.astype(str).map(self.Futures_Code_List)\n                df.OrderBS = df.OrderBS.apply(\n                    lambda x: 'Buy' if x == 'B' else ('Sell' if x == 'S' else x))\n\n                orders = df[['Volume', 'OrderBS']]\n                orders = orders.rename(\n                    columns={'Volume': 'quantity', 'OrderBS': 'action'})\n                df['order'] = orders.to_dict('records')\n\n                day = TODAY_STR.replace('-', '/')\n                df['isDue'] = df.CodeName.apply(\n                    lambda x: day == get_contract(x).delivery_date)\n            return df\n\n        if not self.can_futures:\n            return None, []\n\n        # \u8b80\u53d6\u9078\u80a1\u6e05\u55ae\n        strategies = self.get_futures_pool()\n\n        # \u53d6\u5f97\u9060\u7aef\u5eab\u5b58\n        self.futures = self.get_securityInfo('Futures')\n\n        # \u5eab\u5b58\u7684\u8655\u7406\n        self.futures = preprocess_(self.futures)\n        self.futures = self.futures.merge(\n            self.watchlist,\n            how='left',\n            left_on=['Account', 'Market', 'Code'],\n            right_on=['account', 'market', 'code']\n        )\n        self.futures.position.fillna(100, inplace=True)\n\n        self.n_futures = self.futures.shape[0]\n\n        # \u53d6\u5f97\u7b56\u7565\u6e05\u55ae\n        self.futures.index = self.futures.Code\n        strategies.update(self.futures.strategy.to_dict())\n\n        # \u5254\u9664\u4e0d\u5805\u63a7\u7684\u80a1\u7968\n        self.futures = self.futures[~self.futures.Code.isin(self.FILTER_OUT)]\n\n        # update_futures_to_monitor\n        self.futures_to_monitor.update(self.futures.to_dict('index'))\n        self.futures_to_monitor.update({\n            f: None for f in strategies if f not in self.futures_to_monitor})\n\n        # \u65b0\u589e\u6b77\u53f2K\u68d2\u8cc7\u6599\n        all_futures = list(self.futures_to_monitor)\n        self.history_kbars(all_futures)\n\n        # \u4ea4\u6613\u98a8\u96aa\u63a7\u5236\n        self.N_FUTURES_LIMIT = self.StrategySet.setNFuturesLimit(\n            KBars=self.KBars)\n        self._set_margin_limit()\n        self.margin_table = self.get_margin_table().\u539f\u59cb\u4fdd\u8b49\u91d1.to_dict()\n        return strategies, all_futures\n\n    def _update_position(self, order: namedtuple, strategies: Dict[str, str]):\n        '''\u66f4\u65b0\u5eab\u5b58\u90e8\u4f4d\u6bd4\u4f8b'''\n\n        action = order.action if not order.octype else order.octype\n        target = order.target\n        position = order.pos_target\n        is_day_trade = self.StrategySet.isDayTrade(strategies[target])\n\n        # update monitor list position\n        if order.action_type == 'Close':\n            if action in ['Buy', 'Sell']:\n                self.stocks_to_monitor[target]['position'] -= position\n            else:\n                self.futures_to_monitor[target]['position'] -= position\n\n        # remove from monitor list\n        is_stock = target in self.stocks_to_monitor\n        is_futures = target in self.futures_to_monitor\n        c1 = position == 100 or position >= order.pos_balance\n        c2 = is_stock and self.stocks_to_monitor[target]['quantity'] <= 0\n        c3 = is_stock and self.stocks_to_monitor[target]['position'] <= 0\n        c4 = is_futures and self.futures_to_monitor[target]['order']['quantity'] <= 0\n        c5 = is_futures and self.futures_to_monitor[target]['position'] <= 0\n        if c1 or c2 or c3 or c4 or c5:\n            order = order._replace(pos_target=100)\n\n            if c2 or c3:\n                # TODO:if is_day_trade: self.stocks_to_monitor[target] = None\n                self.remove_stock_monitor_list(target)\n\n            if c4 or c5:\n                if is_day_trade:\n                    self.futures_to_monitor[target] = None\n                else:\n                    self.remove_futures_monitor_list(target)\n\n        # append watchlist or udpate watchlist position\n        self.update_watchlist_position(order, self.Quotes, strategies)\n\n    def update_stocks_to_monitor(self, stocks_pool: Dict[str, list]):\n        '''\u66f4\u65b0\u8cb7\u9032/\u8ce3\u51fa\u80a1\u7968\u76e3\u63a7\u6e05\u55ae'''\n\n        df = self.stocks.copy()\n        df.index = df.code\n        if not self.simulation:\n            df.order_cond = df.order_cond.apply(lambda x: x._value_)\n        self.stocks_to_monitor = df.to_dict('index')\n\n        for stock, stra in stocks_pool.items():\n            if (\n                (self.can_buy and self.StrategySet.isLong(stra)) or\n                (self.can_sell and self.StrategySet.isShort(stra))\n            ) and (stock not in self.stocks_to_monitor):\n                self.stocks_to_monitor.update({stock: None})\n\n    def update_monitor_lists(self, action, data):\n        '''\u66f4\u65b0\u76e3\u63a7\u5eab\u5b58(\u6210\u4ea4\u56de\u5831)'''\n        target = data['code']\n        if action in ['Buy', 'Sell']:\n            if target in self.stocks_to_monitor and self.stocks_to_monitor[target]:\n                logging.debug(\n                    f'\u66f4\u65b0 stocks_to_monitor \u3010QUANTITY\u3011: {action} {target}')\n                quantity = data['quantity']\n                # TODO: \u90e8\u5206\u9032\u5834\n                self.stocks_to_monitor[target]['quantity'] -= quantity\n            else:\n                logging.debug(\n                    f'\u66f4\u65b0 stocks_to_monitor \u3010DATA\u3011: {action} {target}')\n                self.stocks_to_monitor[target] = data\n\n        # New, Cover\n        else:\n            if target in self.futures_to_monitor and self.futures_to_monitor[target]:\n                logging.debug(\n                    f'\u66f4\u65b0 futures_to_monitor \u3010QUANTITY\u3011: {action} {target}')\n                quantity = data['order']['quantity']\n                self.futures_to_monitor[target]['order']['quantity'] -= quantity\n            else:\n                logging.debug(\n                    f'\u66f4\u65b0 futures_to_monitor \u3010DATA\u3011: {action} {target}')\n                self.futures_to_monitor[target] = data\n\n    def _update_futures_deal_list(self, target, octype):\n        '''\u66f4\u65b0\u671f\u8ca8\u4e0b\u55ae\u66ab\u5b58\u6e05\u55ae'''\n        if octype == 'New' and target not in self.futures_opened:\n            self.futures_opened.append(target)\n\n        if octype == 'Cover' and target not in self.futures_closed:\n            self.futures_closed.append(target)\n\n    def merge_buy_sell_lists(self, stocks_pool: Dict[str, str], market='Stocks'):\n        '''\u5408\u4f75\u9032\u51fa\u5834\u6e05\u55ae: \u5c07\u5eab\u5b58\u8207\u9078\u80a1\u6e05\u55ae\uff0c\u5408\u4f75'''\n\n        if market == 'Stocks' and self.stocks.shape[0]:\n            sells = self.stocks.code.values\n        elif market == 'Futures' and self.futures.shape[0]:\n            sells = self.futures.Code.values\n        else:\n            sells = []\n\n        all = sells.copy()\n        for ids in stocks_pool.values():\n            all = np.append(all, ids)\n\n        return np.unique(all)\n\n    def monitor_stocks(self, target: str, strategies: Dict[str, str]):\n        if target in self.Quotes.NowTargets and self.Quotes.NowIndex:\n            inputs = self.Quotes.NowTargets[target].copy()\n            data = self.stocks_to_monitor[target]\n            strategy = strategies[target]\n            isLongStrategy = self.StrategySet.isLong(strategy)\n            isDTStrategy = self.StrategySet.isDayTrade(strategy)\n            isSell = (\n                # long selling\n                (data and 'action' in data and data['action'] == 'Buy') or\n                # short selling\n                (not data and self.can_sell and not isLongStrategy)\n            )\n\n            # new position\n            if data is None:\n                mode = 'short' if isSell else 'long'\n\n                actionType = 'Open'\n                pos_balance = 100\n                order_cond = self.check_order_cond(target, mode)\n                quantity = self.get_quantity(target, strategy, order_cond)\n                enoughOpen = self.check_enough(target, quantity, mode)\n\n            # in-stock position\n            else:\n                actionType = 'Close'\n                pos_balance = data['position']\n                order_cond = data['order_cond']\n                quantity = data['quantity']\n                enoughOpen = False\n\n            inStocks = target in self.stocks.code.values\n            inDeal = target in self.stock_bought + self.stock_sold\n\n            is_day_trade = isDTStrategy and inDeal and (not inStocks)\n            isOpen = actionType == 'Open' and enoughOpen\n            isClose = (\n                (not isDTStrategy) and (not inDeal) and inStocks and\n                (actionType == 'Close')\n            )\n            isDTClose = (is_day_trade and (actionType == 'Close'))\n\n            if quantity and (isOpen or isClose or isDTClose):\n                tradeType = '\u7576\u6c96' if is_day_trade else '\u975e\u7576\u6c96'\n                func = self.StrategySet.mapFunction(\n                    actionType, tradeType, strategy)\n\n                if data:\n                    inputs.update(data)\n\n                actionInfo = func(\n                    inputs=inputs,\n                    kbars=self.KBars,\n                    Quotes=self.Quotes,\n                    pct_chg_DowJones=self.pct_chg_DowJones\n                )\n                if actionInfo.position:\n                    infos = dict(\n                        action_type=actionType,\n                        action='Sell' if isSell else 'Buy',\n                        target=target,\n                        quantity=quantity,\n                        order_cond=self.day_trade_cond[order_cond] if is_day_trade else order_cond,\n                        pos_target=actionInfo.position,\n                        pos_balance=pos_balance,\n                        reason=actionInfo.msg,\n                    )\n                    self._log_and_notify(actionInfo.msg)\n                    return self.OrderInfo(**infos)\n\n        return self.OrderInfo(target=target)\n\n    def monitor_futures(self, target: str, strategies: Dict[str, str]):\n        '''\u6aa2\u67e5\u671f\u8ca8\u662f\u5426\u7b26\u5408\u8ce3\u51fa\u689d\u4ef6\uff0c\u56de\u50b3\u8ce3\u51fa\u90e8\u4f4d(%)'''\n\n        if target in self.Quotes.NowTargets and self.N_FUTURES_LIMIT != 0:\n            inputs = self.Quotes.NowTargets[target].copy()\n            data = self.futures_to_monitor[target]\n            strategy = strategies[target]\n            isLongStrategy = self.StrategySet.isLong(strategy)\n\n            # \u5efa\u5009\n            if data is None:\n                octype = 'New'\n                actionType = 'Open'\n                quantity = self.get_open_slot(target, strategy)\n                enoughOpen = self._check_enough_open(target, quantity)\n                pos_balance = 100\n                action = 'Buy' if isLongStrategy else 'Sell'\n\n            # \u5eab\u5b58\n            else:\n                octype = 'Cover'\n                actionType = 'Close'\n                enoughOpen = False\n                pos_balance = data['position']\n                if target in self.futures_opened:\n                    quantity = data['order']['quantity']\n                    action = data['order']['action']\n                else:\n                    quantity = data['Volume']\n                    action = data['OrderBS']\n\n            if target in self.futures_transferred:\n                msg = f'{target} \u8f49\u5009-New'\n                infos = dict(\n                    action_type=actionType,\n                    action=action,\n                    target=target,\n                    quantity=self.futures_transferred[target],\n                    octype=octype,\n                    pos_target=100,\n                    pos_balance=0,\n                    reason=msg\n                )\n                self._log_and_notify(msg)\n                self.futures_transferred.pop(target)\n                return self.OrderInfo(**infos)\n\n            c1 = octype == 'New' and enoughOpen and not self.is_not_trade_day(\n                inputs['datetime'])\n            c2 = octype == 'Cover'\n            if quantity and (c1 or c2):\n                is_day_trade = self.StrategySet.isDayTrade(strategy)\n                tradeType = '\u7576\u6c96' if is_day_trade else '\u975e\u7576\u6c96'\n                isTransfer = (\n                    actionType == 'Close') and 'isDue' in data and data['isDue']\n                if isTransfer:\n                    func = self.StrategySet.transfer_position\n                else:\n                    func = self.StrategySet.mapFunction(\n                        actionType, tradeType, strategy)\n\n                if data:\n                    inputs.update(data)\n\n                actionInfo = func(\n                    inputs=inputs,\n                    kbars=self.KBars,\n                    Quotes=self.Quotes,\n                    pct_chg_DowJones=self.pct_chg_DowJones\n                )\n                if actionInfo.position:\n                    if isTransfer:\n                        new_target = f'{target[:3]}{self.GetDueMonth(TODAY)}'\n                        self.futures_transferred.update({new_target: quantity})\n\n                    infos = dict(\n                        action_type=actionType,\n                        action=action,\n                        target=target,\n                        quantity=quantity,\n                        octype=octype,\n                        pos_target=actionInfo.position,\n                        pos_balance=pos_balance,\n                        reason=actionInfo.msg\n                    )\n                    self._log_and_notify(actionInfo.msg)\n                    return self.OrderInfo(**infos)\n\n        return self.OrderInfo(target=target)\n\n    def _place_order(self, content: namedtuple, market='Stocks'):\n        logging.debug(f'\u3010content: {content}\u3011')\n\n        target = content.target\n        contract = get_contract(target)\n        if target in self.BidAsk:\n            quantity = self.get_sell_quantity(content, market)\n            price_type = 'MKT'\n            price = 0\n            order_lot = 'IntradayOdd' if content.quantity < 1000 and market == 'Stocks' else 'Common'\n\n            if market == 'Stocks':\n                bid_ask = self.BidAsk[target]\n                bid_ask = bid_ask.bid_price if content.action == 'Sell' else bid_ask.ask_price\n\n                # \u96f6\u80a1\u4ea4\u6613\n                if 0 < content.quantity < 1000:\n                    price_type = 'LMT'\n                    price = bid_ask[1]\n\n                # \u6574\u80a1\u4ea4\u6613\n                else:\n                    if datetime.now() >= TTry:\n                        price_type = 'LMT'\n                        price = bid_ask[1]\n                    elif target in self.punish_list:\n                        price_type = 'LMT'\n                        price = bid_ask[3]\n                    elif contract.exchange == 'OES':\n                        price_type = 'LMT'\n                        price = self.Quotes.NowTargets[target]['price']\n\n                log_msg = f\"\u3010{target}\u4e0b\u55ae\u5167\u5bb9: price={price}, quantity={quantity}, action={content.action}, price_type={price_type}, order_cond={content.order_cond}, order_lot={order_lot}\u3011\"\n            else:\n                log_msg = f\"\u3010{target}\u4e0b\u55ae\u5167\u5bb9: price={price}, quantity={quantity}, action={content.action}, price_type={price_type}, order_cond={content.octype}, order_lot={order_lot}\u3011\"\n\n            # \u4e0b\u55ae\n            logging.debug(log_msg)\n            if self.simulation and market == 'Stocks':\n                price = self.Quotes.NowTargets[target]['price']\n                quantity *= 1000\n                leverage = self.check_leverage(target, content.order_cond)\n                if content.action == 'Sell':\n                    self.stock_sold.append(target)\n                    cost_price = self.get_cost_price(\n                        target, price, content.order_cond)\n                    amount = -(price - cost_price*leverage) * \\\n                        quantity*(1 - FEE_RATE)\n                else:\n                    self.stock_bought.append(target)\n                    amount = self.get_stock_amount(\n                        target, price, quantity, content.order_cond)\n\n                sign = -1 if content.action == 'Sell' else 1\n                order_data = {\n                    'Time': datetime.now(),\n                    'market': market,\n                    'code': target,\n                    'action': content.action,\n                    'price': price*sign,\n                    'quantity': quantity,\n                    'amount': amount,\n                    'order_cond': content.order_cond if market == 'Stocks' else 'Cash',\n                    'order_lot': order_lot,\n                    'leverage': leverage,\n                    'account_id': f'simulate-{self.ACCOUNT_NAME}',\n                    'msg': content.reason\n                }\n                self.appendOrder(order_data)\n\n                # \u66f4\u65b0\u76e3\u63a7\u5eab\u5b58\n                order_data.update({\n                    'position': content.pos_target,\n                    'yd_quantity': 0,\n                    'bst': datetime.now(),\n                    'cost_price': abs(order_data['price'])\n                })\n                self.update_monitor_lists(content.action, order_data)\n\n                logging.debug('Place simulate order complete.')\n                notifier.post(log_msg, msgType='Order')\n\n            elif self.simulation and market == 'Futures':\n                price = self.Quotes.NowTargets[target]['price']\n                sign = -1 if content.action == 'Sell' else 1\n                order_data = {\n                    'Time': datetime.now(),\n                    'market': market,\n                    'code': target,\n                    'action': content.action,\n                    'price': price*sign,\n                    'quantity': quantity,\n                    'amount': self.get_open_margin(target, quantity)*sign,\n                    'op_type': content.octype,\n                    'account_id': f'simulate-{self.ACCOUNT_NAME}',\n                    'msg': content.reason\n                }\n                self.appendOrder(order_data)\n                self._update_futures_deal_list(target, content.octype)\n\n                # \u66f4\u65b0\u76e3\u63a7\u5eab\u5b58\n                bsh = self.Quotes.AllTargets[target]['price']\n                bsh = max(bsh) if bsh else price\n                order_data.update({\n                    'symbol': target,\n                    'cost_price': price,\n                    'bsh': bsh,\n                    'bst': datetime.now(),\n                    'position': content.pos_target,\n                    'order': {\n                        'quantity': quantity,\n                        'action': content.action\n                    }\n                })\n                self.update_monitor_lists(content.octype, order_data)\n\n                logging.debug('Place simulate order complete.')\n                notifier.post(log_msg, msgType='Order')\n            else:\n                # #ff0000 \u6279\u6b21\u4e0b\u55ae\u7684\u5f35\u6578 (\u80a1\u7968>1000\u80a1\u7684\u55ae\u4f4d\u70ba\u3010\u5f35\u3011) #ff0000\n                q = 5 if order_lot == 'Common' else quantity\n                if market == 'Stocks':\n                    target_ = self.desposal_money\n                else:\n                    target_ = self.desposal_margin\n\n                enough_to_place = self.checkEnoughToPlace(market, target_)\n                while quantity > 0 and enough_to_place:\n                    order = API.Order(\n                        # \u50f9\u683c (\u5e02\u50f9\u55ae = 0)\n                        price=price,\n                        # \u6578\u91cf (\u6700\u5c0f1\u5f35; \u96f6\u80a1\u6700\u5c0f50\u80a1 or \u5168\u90e8\u5eab\u5b58)\n                        quantity=min(quantity, q),\n                        # \u52d5\u4f5c: \u8cb7\u9032/\u8ce3\u51fa\n                        action=content.action,\n                        # \u5e02\u50f9\u55ae/\u9650\u50f9\u55ae\n                        price_type=price_type,\n                        # ROD:\u7576\u5929\u90fd\u53ef\u6210\u4ea4\n                        order_type=constant.OrderType.ROD,\n                        # \u59d4\u8a17\u985e\u578b: \u73fe\u80a1/\u878d\u8cc7\n                        order_cond=content.order_cond if market == 'Stocks' else 'Cash',\n                        # \u6574\u5f35\u6216\u96f6\u80a1\n                        order_lot=order_lot,\n                        # {Auto, New, Cover, DayTrade}(\u81ea\u52d5\u3001\u65b0\u5009\u3001\u5e73\u5009\u3001\u7576\u6c96)\n                        octype='Auto' if market == 'Stocks' else content.octype,\n                        account=API.stock_account if market == 'Stocks' else API.futopt_account,\n                        # \u5148\u8ce3\u5f8c\u8cb7: True, False\n                        daytrade_short=content.daytrade_short,\n                    )\n                    result = API.place_order(contract, order)\n                    self.check_order_status(result)\n                    quantity -= q\n\n    def get_securityInfo(self, market='Stocks'):\n        '''\u53d6\u5f97\u8b49\u5238\u5eab\u5b58\u6e05\u55ae'''\n\n        if self.simulation:\n            df_default = {\n                'Stocks': self.df_securityInfo,\n                'Futures': self.df_futuresInfo\n            }\n            try:\n                if db.HAS_DB and market == 'Stocks':\n                    df = db.query(\n                        SecurityInfoStocks,\n                        SecurityInfoStocks.account == self.ACCOUNT_NAME\n                    )\n                elif db.HAS_DB and market == 'Futures':\n                    df = db.query(\n                        SecurityInfoFutures,\n                        SecurityInfoFutures.Account == self.ACCOUNT_NAME\n                    )\n                else:\n                    df = file_handler.read_table(\n                        f'{PATH}/stock_pool/simulation_{market.lower()}_{self.ACCOUNT_NAME}.pkl',\n                        df_default=df_default[market]\n                    )\n            except:\n                df = df_default[market]\n\n            df['account_id'] = 'simulate'\n\n        else:\n            if market == 'Stocks':\n                df = self.securityInfo()\n                return df[df.code.apply(len) == 4]\n\n            df = self.get_openpositions()\n        return df\n\n    def get_margin_table(self):\n        '''\u53d6\u5f97\u4fdd\u8b49\u91d1\u6e05\u55ae'''\n        df = self.read_table('./lib/indexMarging.csv').reset_index()\n        df.columns = list(df.iloc[0, :])\n        df = df.iloc[1:, :-2]\n        df.\u539f\u59cb\u4fdd\u8b49\u91d1 = df.\u539f\u59cb\u4fdd\u8b49\u91d1.astype(int)\n\n        codes = [[f.code, f.symbol, f.name]\n                 for m in API.Contracts.Futures for f in m]\n        codes = pd.DataFrame(codes, columns=['code', 'symbol', 'name'])\n        codes = codes.set_index('name').symbol.to_dict()\n\n        month = str((datetime.now() + timedelta(days=30)).month).zfill(2)\n        df['code'] = (df.\u5546\u54c1\u5225 + month).map(codes)\n        return df.dropna().set_index('code')\n\n    def get_stock_pool(self):\n        '''\n        \u53d6\u5f97\u80a1\u7968\u9078\u80a1\u6c60\n        pools = {\n            'stockid':'strategy',\n        }\n        '''\n\n        pools = {}\n\n        df = picker.get_selection_files()\n        if df.shape[0]:\n            # \u6392\u9664\u4e0d\u4ea4\u6613\u7684\u80a1\u7968\n            # ### \u5168\u984d\u4ea4\u5272\u80a1\u4e0d\u8cb7\n            day_filter_out = crawler2.get_CashSettle()\n            df = df[~df.code.isin(day_filter_out.\u80a1\u7968\u4ee3\u78bc.values)]\n            df = df[~df.code.isin(self.FILTER_OUT)]\n\n            # \u6392\u9664\u9ad8\u50f9\u80a1\n            df = df[df.Close <= self.PRICE_THRESHOLD]\n\n            df = df.sort_values('Close')\n\n            # \u5efa\u7acb\u65cf\u7fa4\u6e05\u55ae\n            n_category = df.groupby('category').code.count().to_dict()\n            df['n_category'] = df.category.map(n_category)\n            self.n_categories = (\n                df.sort_values('n_category', ascending=False)\n                .set_index('code').n_category.to_dict())\n\n            # \u65cf\u7fa4\u6e05\u55ae\u6309\u7167\u7b56\u7565\u6b0a\u91cd & pc_ratio \u6c7a\u5b9a\n            # \u6b0a\u91cd\u5927\u7684\u5148\u52a0\u5165\uff0c\u907f\u514d\u91cd\u8907\n            if self.StrategySet.pc_ratio >= 115:\n                sort_order = ['long_weight', 'short_weight']\n            else:\n                sort_order = ['short_weight', 'long_weight']\n            strategies = self.StrategySet.STRATEGIES.sort_values(\n                sort_order, ascending=False).name.to_list()\n\n            for s in strategies:\n                if s in df.Strategy.values and s in self.STRATEGY_STOCK:\n                    stockids = df[df.Strategy == s].code\n                    pools.update({stock: s for stock in stockids})\n                    df = df[~df.code.isin(stockids)]\n\n        return pools\n\n    def get_futures_pool(self):\n        '''\u53d6\u5f97\u671f\u6b0a\u76ee\u6a19\u5546\u54c1\u6e05\u55ae'''\n\n        pools = {}\n\n        due_year_month = self.GetDueMonth(TODAY)\n        indexes = {\n            '\u653e\u7a7a\u5c0f\u53f0': [f'MXF{due_year_month}'],\n            '\u505a\u591a\u5c0f\u53f0': [f'MXF{due_year_month}'],\n            '\u653e\u7a7a\u5927\u53f0': [f'TXF{due_year_month}'],\n            '\u505a\u591a\u5927\u53f0': [f'TXF{due_year_month}'],\n        }\n        pools.update({\n            symbol: st for st in self.STRATEGY_FUTURES for symbol in indexes[st]\n        })\n        return pools\n\n    def get_quantity(self, target: str, strategy: str, order_cond: str):\n        '''\u8a08\u7b97\u9032\u5834\u80a1\u6578'''\n\n        if self.BUY_UNIT_TYPE == 'constant':\n            return 1000*self.BUY_UNIT\n\n        quantityFunc = self.StrategySet.mapQuantities(strategy)\n\n        inputs = self.Quotes.NowTargets[target]\n        quantity, quantity_limit = quantityFunc(\n            inputs=inputs, kbars=self.KBars)\n        leverage = self.check_leverage(target, order_cond)\n\n        quantity = int(min(quantity, quantity_limit)/(1 - leverage))\n        quantity = min(quantity, 499)\n\n        contract = get_contract(target)\n        if order_cond == 'MarginTrading':\n            quantity = min(contract.margin_trading_balance, quantity)\n        elif order_cond == 'ShortSelling':\n            quantity = min(contract.short_selling_balance, quantity)\n\n        return 1000*quantity\n\n    def get_stock_amount(self, target: str, price: float, quantity: int, mode='long'):\n        '''\u8a08\u7b97\u80a1\u7968\u59d4\u8a17\u91d1\u984d'''\n\n        leverage = self.check_leverage(target, mode)\n        fee = max(price*quantity*FEE_RATE, 20)\n        return price*quantity*(1 - leverage) + fee\n\n    def get_open_slot(self, target: str, strategy: str):\n        '''\u8a08\u7b97\u8cb7\u9032\u53e3\u6578'''\n\n        if self.N_SLOT_TYPE == 'constant':\n            return self.N_SLOT\n\n        quantityFunc = self.StrategySet.mapQuantities(strategy)\n\n        inputs = self.Quotes.NowTargets[target]\n        slot, quantity_limit = quantityFunc(inputs=inputs, kbars=self.KBars)\n        slot = int(min(slot, quantity_limit))\n        slot = min(slot, 499)\n        return slot\n\n    def get_open_margin(self, target: str, quantity: int):\n        '''\u8a08\u7b97\u671f\u8ca8\u4fdd\u8b49\u91d1\u984d'''\n\n        if target in self.Quotes.NowTargets and self.margin_table and target in self.margin_table:\n            fee = 100\n            return self.margin_table[target]*quantity + fee\n        return 0\n\n    def get_pct_chg_DowJones(self):\n        '''\u53d6\u5f97\u9053\u74ca\u6307\u6578\u524d\u4e00\u5929\u7684\u6f32\u8dcc\u5e45'''\n\n        start = self._strf_timedelta(TODAY, 30)\n        dj = crawler2.DowJones(start, TODAY_STR)\n        if 'c' in dj and len(dj['c']):\n            dj = dj['c']\n            return 100*round(dj[0]/dj[1] - 1, 4)\n        return 0\n\n    def get_cost_price(self, target: str, price: float, order_cond: str):\n        '''\u53d6\u5f97\u80a1\u7968\u7684\u9032\u5834\u50f9'''\n\n        if order_cond == 'ShortSelling':\n            return price\n\n        cost_price = self.stocks.set_index('code').cost_price.to_dict()\n        if target in cost_price:\n            return cost_price[target]\n        return 0\n\n    def check_leverage(self, target: str, mode='long'):\n        '''\u53d6\u5f97\u500b\u80a1\u7684\u878d\u8cc7/\u878d\u5238\u6210\u6578'''\n        if mode in ['long', 'MarginTrading'] and target in self.LEVERAGE_LONG:\n            return self.LEVERAGE_LONG[target]\n        elif mode in ['short', 'ShortSelling'] and target in self.LEVERAGE_SHORT:\n            return 1 - self.LEVERAGE_SHORT[target]\n        return 0\n\n    def check_order_cond(self, target: str, mode='long'):\n        '''\u6aa2\u67e5\u500b\u80a1\u53ef\u5426\u878d\u8cc7'''\n\n        contract = get_contract(target)\n        if mode == 'long':\n            if self.ORDER_COND1 != 'Cash' and (self.LEVERAGE_LONG[target] == 0 or contract.margin_trading_balance == 0):\n                return 'Cash'\n            return self.ORDER_COND1\n        else:\n            if self.ORDER_COND2 != 'Cash' and (self.LEVERAGE_SHORT[target] == 1 or contract.short_selling_balance == 0):\n                return 'Cash'\n            return self.ORDER_COND2\n\n    def check_enough(self, target: str, quantity: int, mode='long'):\n        '''\u8a08\u7b97\u53ef\u8cb7\u9032\u7684\u80a1\u7968\u6578\u91cf & \u91d1\u984d'''\n\n        if target not in self.Quotes.NowTargets:\n            return False\n\n        # \u66f4\u65b0\u53ef\u8cb7\u9032\u7684\u80a1\u7968\u984d\u5ea6 TODO: buy_deals, sell_deals\u6703\u5408\u8a08\u591a\u7a7a\u80a1\u7968\u6578\uff0c\u4f7fquota1, quota2\u7121\u6cd5\u7cbe\u6e96\n        buy_deals = len([s for s in self.stock_bought if len(s) == 4])\n        sell_deals = len([s for s in self.stock_sold if len(s) == 4])\n        quota1 = abs(self.N_LIMIT_LS) - self.n_stocks_long - \\\n            buy_deals + sell_deals\n        quota2 = abs(self.N_LIMIT_SS) - self.n_stocks_short + \\\n            buy_deals - sell_deals\n\n        # \u66f4\u65b0\u5df2\u59d4\u8a17\u91d1\u984d\n        df = self.filterOrderTable('Stocks')\n        df = df[df.code.apply(len) == 4]\n        amount1 = df.amount.sum()\n        amount2 = df[df.price > 0].amount.abs().sum()\n        amount3 = df[df.price < 0].amount.abs().sum()\n\n        cost_price = self.Quotes.NowTargets[target]['price']\n        target_amount = self.get_stock_amount(\n            target, cost_price, quantity, mode)\n\n        # under day limit condition\n        # 1. \u4e0d\u53ef\u8d85\u904e\u53ef\u4ea4\u5272\u91d1\u984d\n        # 2. \u4e0d\u53ef\u5927\u65bc\u5e33\u6236\u53ef\u59d4\u8a17\u91d1\u984d\u4e0a\u9650\n        # 3. \u4e0d\u53ef\u8d85\u904e\u80a1\u7968\u6578\u4e0a\u9650\n        if mode == 'long':\n            return (\n                (amount1 + target_amount <= self.desposal_money) &\n                (amount2 + target_amount <= self.POSITION_LIMIT_LONG) &\n                (quota1 > 0)\n            )\n\n        return (\n            (amount1 + target_amount <= self.desposal_money) &\n            (amount2 + target_amount <= self.POSITION_LIMIT_LONG) &\n            # 4. \u4e0d\u53ef\u8d85\u904e\u53ef\u4fe1\u7528\u4ea4\u6613\u984d\u5ea6\u4e0a\u9650\n            (amount3 + target_amount <= self.POSITION_LIMIT_SHORT) &\n            (quota2 > 0)\n        )\n\n    def _check_enough_open(self, target: str, quantity: int):\n        '''\u8a08\u7b97\u53ef\u958b\u5009\u7684\u671f\u8ca8\u53e3\u6578 & \u91d1\u984d'''\n\n        # \u66f4\u65b0\u53ef\u958b\u5009\u7684\u671f\u8ca8\u6a19\u7684\u6578\n        open_deals = len(self.futures_opened)\n        close_deals = len(self.futures_closed)\n        quota = abs(self.N_FUTURES_LIMIT) - \\\n            self.n_futures - open_deals + close_deals\n\n        # \u66f4\u65b0\u5df2\u59d4\u8a17\u91d1\u984d\n        df = self.filterOrderTable('Futures')\n        amount1 = df.amount.sum()\n        amount2 = df[df.price > 0].amount.sum()\n\n        # under day limit condition\n        # 1. \u4e0d\u53ef\u8d85\u904e\u53ef\u4ea4\u5272\u4fdd\u8b49\u91d1\n        # 2. \u4e0d\u53ef\u5927\u65bc\u5e33\u6236\u53ef\u59d4\u8a17\u4fdd\u8b49\u91d1\u4e0a\u9650\n        # 3. \u4e0d\u53ef\u8d85\u904e\u80a1\u7968\u6578\u4e0a\u9650\n        target_amount = self.get_open_margin(target, quantity)\n        return (\n            (amount1 + target_amount <= self.desposal_margin) &\n            (amount2 + target_amount <= self.MARGIN_LIMIT) &\n            (quota > 0)\n        )\n\n    def is_not_trade_day(self, now: datetime):\n        '''\u6aa2\u67e5\u662f\u5426\u70ba\u975e\u4ea4\u6613\u6642\u6bb5'''\n        is_holiday = TODAY in holidays\n        if self.can_futures:\n            close1 = (\n                (now > TimeEndFuturesNight) and\n                (now < TimeStartFuturesDay + timedelta(days=1))\n            )\n            close2 = now > TimeEndFuturesDay and now < TimeStartFuturesNight\n            if self.TRADING_PERIOD != 'Day':\n                # trader only closes during 05:00 ~ 08:45\n                close2 = False\n\n            return is_holiday or close1 or close2\n\n        return is_holiday or not (now <= TEnd)\n\n    def remove_stock_monitor_list(self, target: str):\n        logging.debug(f'Remove\u3010{target}\u3011from stocks_to_monitor.')\n        self.stocks_to_monitor.pop(target, None)\n\n        if target in self.stocks.code.values:\n            logging.debug(f'Remove\u3010{target}\u3011from self.stocks.')\n            self.stocks = self.stocks[self.stocks.code != target]\n            if self.simulation and db.HAS_DB:\n                db.delete(\n                    SecurityInfoStocks,\n                    SecurityInfoStocks.code == target,\n                    SecurityInfoStocks.account == self.ACCOUNT_NAME\n                )\n\n    def remove_futures_monitor_list(self, target: str):\n        '''Remove futures from futures_to_monitor'''\n        logging.debug(f'Remove\u3010{target}\u3011from futures_to_monitor.')\n        self.futures_to_monitor.pop(target, None)\n\n        if target in self.futures.CodeName.values:\n            logging.debug(f'Remove\u3010{target}\u3011from self.futures.')\n            self.futures = self.futures[self.futures.CodeName != target]\n            if self.simulation and db.HAS_DB:\n                db.delete(\n                    SecurityInfoFutures,\n                    SecurityInfoFutures.CodeName == target,\n                    SecurityInfoFutures.Account == self.ACCOUNT_NAME\n                )\n\n    def run(self):\n        '''\u57f7\u884c\u81ea\u52d5\u4ea4\u6613'''\n\n        strategy_s, all_stocks = self.init_stocks()\n        strategy_f, all_futures = self.init_futures()\n        usage = round(API.usage().bytes/2**20, 2)\n        self.subscribe_all(all_stocks+all_futures)\n\n        logging.info(f\"Current data usage: {usage}\")\n        logging.info(f\"Today's punish lis: {self.punish_list}\")\n        logging.info(f\"Stocks Ex-dividend: {self.StrategySet.dividends}\")\n        logging.info(f\"Previous Put/Call ratio: {self.StrategySet.pc_ratio}\")\n        logging.info(f'Start to monitor, basic settings:')\n        logging.info(f'Mode:{self.MODE}, Strategy: {self.STRATEGY_STOCK}')\n        logging.info(f'[Stock Strategy] {strategy_s}')\n        logging.info(f'[Stock Position] Long: {self.n_stocks_long}')\n        logging.info(f'[Stock Position] Short: {self.n_stocks_short}')\n        logging.info(f'[Stock Portfolio Limit] Long: {self.N_LIMIT_LS}')\n        logging.info(f'[Stock Portfolio Limit] Short: {self.N_LIMIT_SS}')\n        logging.info(\n            f'[Stock Position Limit] Long: {self.POSITION_LIMIT_LONG}')\n        logging.info(\n            f'[Stock Position Limit] Short: {self.POSITION_LIMIT_SHORT}')\n        logging.info(f'[Futures Strategy] {strategy_f}')\n        logging.info(f'[Futures position] {self.n_futures}')\n        logging.info(f'[Futures portfolio Limit] {self.N_FUTURES_LIMIT}')\n\n        text = f\"\\n\u3010\u958b\u59cb\u76e3\u63a7\u3011{self.ACCOUNT_NAME} \u555f\u52d5\u5b8c\u6210({__version__})\"\n        text += f\"\\n\u3010\u64cd\u76e4\u6a21\u5f0f\u3011{self.MODE}\\n\u3010\u64cd\u76e4\u7b56\u7565\u3011{self.STRATEGY_STOCK}\"\n        text += f\"\\n\u3010\u524d\u65e5\u884c\u60c5\u3011Put/Call: {self.StrategySet.pc_ratio}\"\n        text += f\"\\n\u3010\u7f8e\u80a1\u884c\u60c5\u3011\u9053\u74ca({self.pct_chg_DowJones}%)\"\n        text += f\"\\n\u3010\u6578\u64da\u7528\u91cf\u3011{usage}MB\"\n        notifier.post(text, msgType='Monitor')\n\n        # \u958b\u59cb\u76e3\u63a7\n        while True:\n            now = datetime.now()\n\n            if self.is_not_trade_day(now):\n                logging.info('Non-trading time, stop monitoring')\n                self.updateKBars('2T')\n                self.updateKBars('5T')\n                self.updateKBars('15T')\n                self.updateKBars('30T')\n                self.updateKBars('60T')\n                break\n            elif all(x == 0 for x in [\n                self.n_stocks_long, self.n_stocks_short,\n                self.N_LIMIT_LS, self.N_LIMIT_SS,\n                self.N_FUTURES_LIMIT, self.n_futures\n            ]):\n                self._log_and_notify(f\"\u3010\u505c\u6b62\u76e3\u63a7\u3011{self.ACCOUNT_NAME} \u7121\u53ef\u76e3\u63a7\u6e05\u55ae\")\n                break\n\n            # update K-bar data\n            is_trading_time = (\n                (self.can_futures and now > TimeStartFuturesDay + timedelta(seconds=30)) or\n                (self.can_stock and now > TimeStartStock + timedelta(seconds=30))\n            )\n            if is_trading_time and now.second < 5:\n                self._update_K1(self.StrategySet.dividends, quotes=self.Quotes)\n                self._set_target_quote_default(all_stocks+all_futures)\n                self._set_index_quote_default()\n                self.StrategySet.update_indicators(now, self.KBars)\n\n                if now.minute % 2 == 0:\n                    self.updateKBars('2T')\n\n                if now.minute % 5 == 0:\n                    self.updateKBars('5T')\n                    self.balance(mode='debug')  # \u9632\u6b62\u65b7\u7dda\u7528 TODO:\u5f85\u6c38\u8c50\u66f4\u65b0\u5f8c\u522a\u9664\n\n                if now.minute % 15 == 0:\n                    self.updateKBars('15T')\n\n                if now.minute % 30 == 0:\n                    self.updateKBars('30T')\n\n                if now.minute == 0:\n                    self.updateKBars('60T')\n\n            # TODO: merge stocks_to_monitor & futures_to_monitor\n            for target in list(self.stocks_to_monitor):\n                order = self.monitor_stocks(target, strategy_s)\n                if order.pos_target:\n                    self._place_order(order, market='Stocks')\n                    self._update_position(order, strategy_s)\n\n            for target in list(self.futures_to_monitor):\n                order = self.monitor_futures(target, strategy_f)\n                if order.pos_target:\n                    self._place_order(order, market='Futures')\n                    self._update_position(order, strategy_f)\n\n            time.sleep(max(5 - (datetime.now() - now).total_seconds(), 0))\n\n        time.sleep(10)\n        self.unsubscribe_all(all_stocks+all_futures)\n\n    def simulator_update_securityInfo(self, df: pd.DataFrame, table):\n        market = 'stocks' if 'stocks' in table.__tablename__ else 'futures'\n        if db.HAS_DB:\n            if market == 'stocks':\n                match_account = table.account == self.ACCOUNT_NAME\n                codes = db.query(table.code, match_account).code.values\n                tb = df[~df.code.isin(codes)]\n                update_values = df[df.code.isin(codes)].set_index('code')\n            else:\n                match_account = table.Account == self.ACCOUNT_NAME\n                codes = db.query(table.Code, match_account).Code.values\n                tb = df[~df.Code.isin(codes)]\n                update_values = df[df.Code.isin(codes)].set_index('Code')\n\n            # add new stocks\n            db.dataframe_to_DB(tb, table)\n\n            # update in-stocks\n            update_values = update_values.to_dict('index')\n            for target, values in update_values.items():\n                if market == 'stocks':\n                    condition = table.code == target, match_account\n                else:\n                    condition = table.Code == target, match_account\n                db.update(table, values, *condition)\n        else:\n            self.save_table(\n                df=df,\n                filename=f'{PATH}/stock_pool/simulation_{market}_{self.ACCOUNT_NAME}.pkl'\n            )\n\n    def __save_simulate_securityInfo(self):\n        '''\u5132\u5b58\u6a21\u64ec\u4ea4\u6613\u6a21\u5f0f\u4e0b\u7684\u80a1\u7968\u5eab\u5b58\u8868'''\n        if self.simulation:\n            # \u5132\u5b58\u5eab\u5b58\n            logging.debug(f'stocks_to_monitor: {self.stocks_to_monitor}')\n            logging.debug(\n                f'stocks shape: {self.stocks.shape}; watchlist shape: {self.watchlist.shape}')\n            df = {k: v for k, v in self.stocks_to_monitor.items() if v}\n            df = pd.DataFrame(df).T\n            if df.shape[0]:\n                df = df[df.account_id == f'simulate-{self.ACCOUNT_NAME}']\n                df = df.sort_values('code').reset_index()\n                df['last_price'] = df.code.map(\n                    {s: self.Quotes.NowTargets[s]['price'] for s in df.code})\n                df['pnl'] = df.action.apply(lambda x: 1 if x == 'Buy' else -1)\n                df['pnl'] = df.pnl*(df.last_price - df.cost_price)*df.quantity\n                df.yd_quantity = df.quantity\n                df['account'] = self.ACCOUNT_NAME\n                df = df[self.df_securityInfo.columns]\n            else:\n                df = self.df_securityInfo\n            logging.debug(\n                f'stocks shape: {df.shape}; watchlist shape: {self.watchlist.shape}')\n\n            if df.shape[0]:\n                self.simulator_update_securityInfo(df, SecurityInfoStocks)\n\n    def __save_simulate_futuresInfo(self):\n        '''\u5132\u5b58\u6a21\u64ec\u4ea4\u6613\u6a21\u5f0f\u4e0b\u7684\u671f\u8ca8\u5eab\u5b58\u8868'''\n        if self.simulation:\n            # \u5132\u5b58\u5eab\u5b58\n            logging.debug(f'futures_to_monitor: {self.futures_to_monitor}')\n            df = {k: v for k, v in self.futures_to_monitor.items() if v}\n            df = pd.DataFrame(df).T\n            if df.shape[0]:\n                df = df[df.account_id == f'simulate-{self.ACCOUNT_NAME}']\n                df = df.reset_index(drop=True)\n                df = df.rename(columns={\n                    'account_id': 'Account',\n                    'market': 'Market',\n                    'bst': 'Date',\n                    'symbol': 'CodeName',\n                    'action': 'OrderBS',\n                    'quantity': 'Volume',\n                    'cost_price': 'ContractAverPrice',\n                    'price': 'RealPrice',\n                })\n                df['Code'] = df.CodeName.apply(lambda x: get_contract(x).code)\n                df.Account = self.ACCOUNT_NAME\n\n                for c in self.df_futuresInfo.columns:\n                    if c not in df.columns:\n                        if c in [\n                            'ContractAverPrice', 'SettlePrice',\n                            'RealPrice', 'FlowProfitLoss',\n                            'SettleProfitLoss', 'OTAMT', 'MTAMT'\n                        ]:\n                            df[c] = 0\n                        else:\n                            df[c] = ''\n                df = df[self.df_futuresInfo.columns]\n            else:\n                df = self.df_futuresInfo\n\n            if df.shape[0]:\n                self.simulator_update_securityInfo(df, SecurityInfoFutures)\n\n    def output_files(self):\n        '''\u505c\u6b62\u4ea4\u6613\u6642\uff0c\u8f38\u51fa\u5eab\u5b58\u8cc7\u6599 & \u4ea4\u6613\u660e\u7d30'''\n        if 'position' in self.stocks.columns and not self.simulation:\n            codeList = self.get_securityInfo('Stocks').code.to_list()\n            self.update_watchlist(codeList)\n\n        self.save_watchlist(self.watchlist)\n        self.output_statement(\n            f'{PATH}/stock_pool/statement_{self.ACCOUNT_NAME}.csv')\n\n        if (datetime.now().weekday() not in [5, 6]):\n            for freq, df in self.KBars.items():\n                if freq != '1D':\n                    filename = f'{PATH}/Kbars/k{freq[:-1]}min_{self.ACCOUNT_NAME}.csv'\n                    self.save_table(df, filename)\n\n        if self.can_stock:\n            self.__save_simulate_securityInfo()\n\n        if self.can_futures:\n            self.__save_simulate_futuresInfo()\n\n        time.sleep(5)", ""]}
{"filename": "trader/__init__.py", "chunked_list": ["from concurrent.futures import ThreadPoolExecutor\n\nfrom .config import PATH\nfrom .utils.file import FileHandler\nfrom .utils.select import SelectStock\nfrom .utils.kbar import TickDataProcesser\nfrom .utils.notify import Notification\nfrom .utils.crawler import CrawlStockData, CrawlFromHTML\n\n", "\n\n__version__ = '1.9.21'\n\nexecutor = ThreadPoolExecutor(max_workers=5)\nfile_handler = FileHandler()\nnotifier = Notification()\npicker = SelectStock()\ncrawler1 = CrawlStockData()\ncrawler2 = CrawlFromHTML()", "crawler1 = CrawlStockData()\ncrawler2 = CrawlFromHTML()\ntdp = TickDataProcesser()\n\n\nfor f in [PATH, './logs']:\n    file_handler.create_folder(f)\n\nfor f in ['daily_info', 'Kbars', 'ticks', 'selections', 'stock_pool']:\n    file_handler.create_folder(f'{PATH}/{f}')", "for f in ['daily_info', 'Kbars', 'ticks', 'selections', 'stock_pool']:\n    file_handler.create_folder(f'{PATH}/{f}')\n\nfor f in ['1D', '60T', '30T', '1T']:\n    file_handler.create_folder(f'{PATH}/Kbars/{f}')\n\nfile_handler.create_folder(f'{PATH}/ticks/stocks')\nfile_handler.create_folder(f'{PATH}/ticks/futures')\nfile_handler.create_folder(f'{PATH}/selections/history')\n", "file_handler.create_folder(f'{PATH}/selections/history')\n"]}
{"filename": "trader/utils/crawler.py", "chunked_list": ["import io\nimport os\nimport re\nimport time\nimport json\nimport logging\nimport zipfile\nimport requests\nimport numpy as np\nimport pandas as pd", "import numpy as np\nimport pandas as pd\nfrom typing import Union\nfrom sqlalchemy import text\nfrom bs4 import BeautifulSoup\nfrom datetime import datetime, timedelta\n\nfrom ..config import API, PATH, TODAY_STR, TODAY\nfrom . import progress_bar, create_queue\nfrom .kbar import KBarTool", "from . import progress_bar, create_queue\nfrom .kbar import KBarTool\nfrom .time import TimeTool\nfrom .file import FileHandler\nfrom .database import db, KBarTables\nfrom .database.tables import KBarData1T, SecurityList, PutCallRatioList, ExDividendTable\n\n\ndef readStockList(markets=['OTC', 'TSE']):\n    if db.HAS_DB:\n        df = db.query(\n            SecurityList,\n            SecurityList.exchange.in_(markets)\n        )\n    else:\n        df = FileHandler().read_table(\n            f'{PATH}/selections/stock_list.xlsx',\n            df_default=pd.DataFrame(columns=['code', 'exchange'])\n        )\n        df.code = df.code.astype(int).astype(str)\n        df = df[df.exchange.isin(markets)]\n    return df", "def readStockList(markets=['OTC', 'TSE']):\n    if db.HAS_DB:\n        df = db.query(\n            SecurityList,\n            SecurityList.exchange.in_(markets)\n        )\n    else:\n        df = FileHandler().read_table(\n            f'{PATH}/selections/stock_list.xlsx',\n            df_default=pd.DataFrame(columns=['code', 'exchange'])\n        )\n        df.code = df.code.astype(int).astype(str)\n        df = df[df.exchange.isin(markets)]\n    return df", "\n\nclass CrawlStockData(FileHandler):\n    def __init__(self, folder_path: str = f'{PATH}/Kbars/1T/{TODAY_STR}', scale='1D'):\n        self.folder_path = folder_path\n        self.timetool = TimeTool()\n        self.kbartool = KBarTool()\n        self.filename = 'company_stock_data'\n        self.tempFile = f'{self.folder_path}/crawled_list.pkl'\n        self.scale = scale\n        self.StockData = []\n\n    def get_security_list(self, stock_only: bool = True):\n        '''\n        \u81ea Shioaji \u53d6\u5f97\u80a1\u7968\u6e05\u55ae\n        \u53ea\u4fdd\u7559\u666e\u901a\u80a1\u80a1\u7968\u4e14\u4e0d\u9700\u8981\u6b0a\u8b49: stock_only = True \n        '''\n        stock_list = [\n            {**stock} for exchange in API.Contracts.Stocks for stock in exchange]\n        df = pd.DataFrame(stock_list)\n        df = df[(df.update_date == df.update_date.max())]\n\n        if stock_only:\n            df.update_date = pd.to_datetime(df.update_date)\n            df = df[\n                ~(df.category.isin(['00', '  '])) & (df.code.apply(len) == 4)]\n\n        return df\n\n    def export_security_list(self, df: pd.DataFrame):\n        '''Export security data either to local or to DB'''\n\n        if db.HAS_DB:\n            codes = db.query(SecurityList.code).code.values\n\n            # add new data\n            tb = df[~df.code.isin(codes)].copy()\n            db.dataframe_to_DB(tb, SecurityList)\n\n            # delete old data\n            code1 = list(set(codes) - set(df.code))\n            condition = SecurityList.code.in_(code1)\n            db.delete(SecurityList, condition)\n        else:\n            self.save_table(df, f'{PATH}/selections/stock_list.xlsx')\n\n    def export_kbar_data(self, df: pd.DataFrame, scale: str):\n        '''Export kbar data either to local or to DB'''\n\n        if db.HAS_DB:\n            db.dataframe_to_DB(df, KBarTables[scale])\n\n        df.Volume = df.Volume.astype('int32')\n        filename = f'{PATH}/Kbars/{scale}/{TODAY_STR}-stocks-{scale}.pkl'\n        self.save_table(df, filename)\n        return df\n\n    def _load_data_into_queue(self, stockids: list):\n        '''\u5275\u5efa\u80a1\u7968\u5f85\u722c\u6e05\u55ae(queue)'''\n\n        # get stock id list\n        if type(stockids) == str and stockids == 'all':\n            stockids = readStockList().code.values\n        elif type(stockids) == str:\n            stockids = stockids.split(',')\n        logging.info(f\"Target list size: {len(stockids)}\")\n\n        # get crawled list\n        df_default = pd.DataFrame({'stockid': []})\n        self.crawled_list = self.read_table(self.tempFile, df_default)\n        logging.info(f\"Crawled size: {self.crawled_list.shape[0]}\")\n\n        return create_queue(stockids, self.crawled_list.stockid.values)\n\n    def crawl_from_sinopac(self, stockids: Union[str, list] = 'all', update=False, start=None, end=None):\n\n        self.create_folder(self.folder_path)\n        q = self._load_data_into_queue(stockids)\n        if isinstance(stockids, str) and stockids == 'all':\n            q.put('TSE001')\n            q.put('OTC101')\n        N = q.qsize()\n\n        if not start:\n            if update:\n                if db.HAS_DB:\n                    dates = db.query(KBarTables[self.scale].Time)\n                    if dates.shape[0]:\n                        last_end = dates.Time.max()\n                    else:\n                        last_end = self.timetool.last_business_day()\n                else:\n                    filename = f'{PATH}/Kbars/{self.filename}_{self.scale}.pkl'\n                    ref = self.timetool.last_business_day()\n                    last_end = self.read_table(\n                        filename=filename,\n                        df_default=pd.DataFrame({'Time': [ref]})\n                    ).Time.max()\n                start = self.timetool._strf_timedelta(last_end, -1)\n            else:\n                start = '2017-01-01'\n\n        self.StockData = np.array([None]*N)\n        while True:\n            if q.empty():\n                os.remove(self.tempFile)\n                logging.info(\"Queue is deleted successfully\")\n                break\n\n            i = N-q.qsize()\n            stockid = q.get()\n            tStart = time.time()\n\n            try:\n                df = self.kbartool.tbKBar(stockid, start, end)\n\n                if df is not None:\n                    self.StockData[i] = df\n\n                    # back-up queue\n                    self.crawled_list = pd.concat([\n                        self.crawled_list,\n                        pd.DataFrame([{'stockid': stockid}])\n                    ])\n                    self.save_table(self.crawled_list, filename=self.tempFile)\n            except:\n                logging.exception(f\"Put back into queue: {stockid}\")\n                q.put(stockid)\n\n            progress_bar(\n                N,\n                N-q.qsize()-1,\n                status=f'Getting {stockid} done ({round(time.time() - tStart, 2)}s)'\n            )\n            time.sleep(0.1)\n\n    def merge_stockinfo(self):\n        '''\n        \u722c\u87f2\u722c\u4e0b\u4f86\u7684\u8cc7\u6599\u662f\u6309\u516c\u53f8\u80a1\u7968\u4ee3\u865f\u5206\u5225\u5b58\u6210CSV\u6a94\n        \u6b64\u7a0b\u5f0f\u7528\u4f86\u5c07\u5168\u90e8\u7684\u516c\u53f8\u80a1\u7968\u8cc7\u6599\u5408\u4f75\u6210\u4e00\u500b\n        '''\n\n        logging.info(\"Merge stockinfo\")\n        if len(self.StockData):\n            df = pd.concat(self.StockData)\n            df.Time = pd.to_datetime(df.Time)\n            df.name = df.name.astype(int).astype(str)\n            self.StockData = df\n        else:\n            df = self.read_tables_in_folder(self.folder_path, pattern='.csv')\n            if df.shape[0]:\n                if 'Time' in df.columns:\n                    df['Time'] = pd.to_datetime(df['Time'])\n\n                df.name = df.name.astype(int)\n\n            self.remove_files(self.folder_path, pattern='.csv')\n\n        df = df.sort_values(['name', 'Time']).reset_index(drop=True)\n        df = self.export_kbar_data(df, '1T')\n        os.rmdir(self.folder_path)\n\n    def add_new_data(self, scale: str, save=True, start=None, end=None):\n        '''\u52a0\u5165\u65b0\u8cc7\u6599\u5230\u820aK\u68d2\u8cc7\u6599\u4e2d'''\n\n        if isinstance(self.StockData, pd.DataFrame) and self.StockData.shape[0]:\n            df = self.StockData.copy()\n        elif db.HAS_DB:\n            condition1 = KBarData1T.Time >= text(\n                start) if start else text('1901-01-01')\n            condition2 = KBarData1T.Time <= text(\n                end) if end else text(TODAY_STR)\n            df = db.query(KBarData1T, condition1, condition2)\n        else:\n            folders = self.listdir(f'{PATH}/Kbars/1T')\n            folders = [fd for fd in folders if '.' not in fd]\n\n            if start:\n                folders = [fd for fd in folders if fd >= start]\n\n            if end:\n                folders = [fd for fd in folders if fd <= end]\n\n            N = len(folders)\n            df = np.array([None]*N)\n            for i, fd in enumerate(folders):\n                filename = f'{PATH}/Kbars/1T/{fd}-stock_data_1T.pkl'\n                tb = self.read_table(filename)\n                tb = tb.sort_values(['name', 'Time'])\n\n                if tb.shape[0]:\n                    if 'Time' in tb.columns:\n                        tb['Time'] = pd.to_datetime(tb['Time'])\n\n                    tb.name = tb.name.astype(int)\n\n                df[i] = tb\n\n            df = pd.concat(df)\n            df = df.sort_values(['name', 'Time'])\n            df = df.reset_index(drop=True)\n            df.name = df.name.astype(int).astype(str)\n\n        if scale != '1T':\n            logging.info(f'Converting data scale to {scale}...')\n            df = self.kbartool.convert_kbar(df, scale=scale).dropna()\n\n        if save:\n            df = self.export_kbar_data(df, scale)\n\n        return df\n\n    def merge_daily_data(self, day: datetime, scale: str, save=True):\n        '''\n        This function merges daily kbar data at the 1st trading-day of \n        each month\n        '''\n\n        if not isinstance(day, datetime):\n            day = pd.to_datetime(day)\n\n        last_day = self.timetool.last_business_day(day)\n        if last_day.month != day.month:\n            dir_path = f'{PATH}/Kbars/{scale}'\n            year_month = self.timetool.datetime_to_str(last_day)[:-3]\n            df = self.read_tables_in_folder(dir_path, pattern=year_month)\n            df = df.sort_values(['name', 'Time'])\n            df = df.reset_index(drop=True)\n\n            if save:\n                filename = f'{dir_path}/{year_month}-stocks-{scale}.pkl'\n                self.remove_files(dir_path, pattern=year_month)\n                self.save_table(df, filename)", "\n\nclass CrawlFromHTML(TimeTool, FileHandler):\n\n    headers = {\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'\n    }\n    url_pc_ratio = 'https://www.taifex.com.tw/cht/3/pcRatio'\n    url_ex_dividend = 'https://www.twse.com.tw/rwd/zh/exRight/TWT48U?response=csv'\n    url_futures_tick = 'https://www.taifex.com.tw/file/taifex/Dailydownload/DailydownloadCSV'\n    url_cash_settle = 'https://www.sinotrade.com.tw/Stock/Stock_3_8_3'\n\n    def above_one_url(self, pageName: str, date: str, stockid: str):\n        '''\u7522\u751f\u8c79\u6295\u8cc7\u7db2\u7ad9\u8cc7\u6599\u7684URL'''\n\n        domain1 = 'https://www.above.one/cdn/TProStk'\n        domain2 = 'https://www.above.one/cdn/TProStkChips'\n        token = 'HVtjdOMP4f'\n        URLs = {\n            # 1. K\u7ddaHeader\u8cc7\u8a0a\n            'HeaderInfo': f'{domain1}/{pageName}/HVtjdOMP4f.json?day={date}&sym={stockid}&',\n\n            # 2. \u80a1\u61c2\u5238\u5546\u6392\u884c\u699c\n            'SymbolWinBroker': f'{domain2}/{pageName}/{token}.json?dateRange=20&day={date}&sym={stockid}&s=ProfitLoss:d',\n\n            # 3. \u5206\u50f9\u91cf\u8868\n            'SymbolPeriodPriceAccumVol': f'{domain2}/{pageName}/{token}.json?day={date}&pastNDays=1&sym={stockid}&',\n\n            # 4. \u4e3b\u529b\u900f\u8996\u5716\n            'DayMajorPriceNetVol': f'{domain2}/{pageName}/{token}.json?day={date}&sym={stockid}&',\n\n            # 5. \u5916\u672c\u6bd4\u8207\u6295\u672c\u6bd4\n            'FgnItrustRatio': f'{domain2}/{pageName}/{token}.json?ed={date}&kfreq=day&sd=2022-07-22&sym={stockid}&',\n\n            # 6. \u4e09\u5927\u6cd5\u4eba\u6210\u4ea4\u6bd4\n            'ExternalRatio': f'{domain2}/{pageName}/{token}.json?ed={date}&kfreq=day&sd=2022-07-22&sym={stockid}&s=Date:d',\n\n            # 7. \u878d\u8cc7\u878d\u5238\n            'MarginOffsetRatio': f'{domain2}/{pageName}/{token}.json?ed={date}&kfreq=day&sd=2022-07-22&sym={stockid}&s=Date:d',\n\n            # 8. \u501f\u5238\u8ce3\u51fa\u9918\u984d\n            'MgnSBLRatio': f'{domain2}/{pageName}/{token}.json?ed={date}&kfreq=day&sd=2022-07-22&sym={stockid}&s=Date:d',\n\n            # 9. \u5340\u9593\u9031\u8f49\u7387\n            'RangeTurnover': f'{domain2}/{pageName}/{token}.json?ed={date}&pastNDays=5&sd=2022-07-15&sym={stockid}&',\n\n            # 10. \u7576\u65e5\u6c96\u92b7\n            'DayTrade': f'{domain2}/{pageName}/{token}.json?ed={date}&kfreq=day&sd=2022-07-22&sym={stockid}&s=Date:d',\n\n            # 11. \u5927\u6236\u8207\u7f8a\u7fa4\u6301\u80a1\n            'LambsAndMajorHold': f'{domain2}/{pageName}/{token}.json?ed={date}&holdVolMajor=15&kfreq=day&sd=2021-11-23&sym={stockid}&s=Date:d',\n\n            # 12. \u96c6\u4fdd\u6236\u6578\n            'TdccCount': f'{domain2}/{pageName}/{token}.json?day={date}&sym={stockid}&',\n\n            # 13. \u5927\u80a1\u6771\u6301\u80a1\u8b8a\u52d5\n            'ShareBalChg': f'{domain2}/{pageName}/{token}.json?holdVolMajor=12&sym={stockid}&s=Date:d',\n\n            # 14. \u5238\u5546\u8cb7\u8d85\u7d71\u8a08\n            'BrkBuyNet': f'{domain2}/{pageName}/{token}.html?ed={date}&sd={date}&sym={stockid}&s=BuyNetVol:d&sno=0',\n\n            # 15. \u5238\u5546\u8ce3\u8d85\u7d71\u8a08\n            'BrkSellNet': f'{domain2}/{pageName}/{token}.html?ed={date}&sd={date}&sym={stockid}&s=SellNetVol:d&sno=0',\n\n            # 16. \u5167\u90e8\u4eba\u6301\u80a1\u6bd4\u7387\n            'ShareHoldRatio': f'{domain2}/{pageName}/{token}.json?ed=2022-08-31&sd=2015-03-31&sym={stockid}&s=YearMonth:d',\n\n            # 17. \u8463\u76e3\u5927\u80a1\u6771\u6301\u80a1\n            'ShareBal': f'{domain2}/{pageName}/{token}.html?sym={stockid}&ym=2022%2F8&sno=0',\n\n            # 18. \u5238\u5546\u8cb7\u8d85\u7d71\u8a08\n            'BrkBuyNet_InputRadio': f'{domain2}/{pageName}/{token}.html?ed={date}&sd={date}&sym={stockid}&s=BuyNetVol:d&sno=0',\n\n            # 19. \u80a1\u61c2\u5238\u5546\n            'SymbolWinBroker_InputRadio': f'{domain2}/{pageName}/{token}.html?dateRange=20&day={date}&sym={stockid}&s=ProfitLoss:d&sno=0'\n        }\n        return URLs[pageName]\n\n    def get_leverage(self, stockid: str):\n        '''\u53d6\u5f97\u500b\u80a1\u878d\u8cc7\u6210\u6578'''\n\n        url = f'https://www.sinotrade.com.tw/Stock/Stock_3_8_6?code={stockid}'\n        tb = pd.read_html(url)[-1]\n\n        if tb.shape[0] == 0:\n            return {'\u878d\u8cc7\u6210\u6578': 0, '\u878d\u5238\u6210\u6578': 100}\n        return tb.to_dict('records')[0]\n\n    def get_punish_list(self):\n        '''\u53d6\u5f97\u4e0a\u5e02\u6ac3\u8655\u7f6e\u80a1\u7968\u6e05\u55ae(\u8b49\u5238\u4ee3\u865f\u3001\u540d\u7a31\u3001\u8655\u7f6e\u8d77\u8a16\u65e5)'''\n\n        def get(url, period):\n            df_default = pd.DataFrame(columns=['\u8b49\u5238\u4ee3\u865f', '\u8b49\u5238\u540d\u7a31', 'period'])\n\n            n = 0\n            while n < 10:\n                try:\n                    df = requests.get(url, headers=self.headers).text\n                    df = pd.read_html(df)[0]\n                    df = df.dropna().rename(\n                        columns={period: 'period'}).iloc[:-1, :]\n                    return df\n                except:\n                    logging.exception('Catch an exception (get_punish_list):')\n                    n += 1\n                    time.sleep(1)\n            return df_default\n\n        # \u4e0a\u5e02\u8655\u7f6e\u516c\u544a\n        start = self._strf_timedelta(TODAY, 30).replace('-', '')\n        url = f'https://www.twse.com.tw/announcement/punish?response=html&startDate={start}&endDate='\n        df1 = get(url, '\u8655\u7f6e\u8d77\u8fc4\u6642\u9593')\n        df1 = df1[['\u8b49\u5238\u4ee3\u865f', '\u8b49\u5238\u540d\u7a31', 'period']]\n\n        # \u4e0a\u6ac3\u8655\u7f6e\u516c\u544a\n        start = self._strf_timedelta(TODAY, 30).replace('-', '/')\n        start = start.replace(start[:4], str(int(start[:4])-1911))\n        url = f'https://www.tpex.org.tw/web/bulletin/disposal_information/disposal_information_print.php?l=zh-tw&sd={start}'\n        df2 = get(url, '\u8655\u7f6e\u8d77\u8a16\u6642\u9593')\n        df2 = df2[['\u8b49\u5238\u4ee3\u865f', '\u8b49\u5238\u540d\u7a31', 'period']]\n\n        # \u5408\u4f75\n        df = pd.concat([df1, df2])\n        df.period = df.period.apply(lambda x: re.findall('[\\d+/]+', x))\n        df.\u8b49\u5238\u4ee3\u865f = df.\u8b49\u5238\u4ee3\u865f.astype(str)\n        df['startDate'] = df.period.apply(\n            lambda x: x[0].replace(x[0][:3], str(int(x[0][:3])+1911)))\n        df['startDate'] = pd.to_datetime(df['startDate'])\n        df['endDate'] = df.period.apply(\n            lambda x: x[1].replace(x[1][:3], str(int(x[1][:3])+1911)))\n        df['endDate'] = pd.to_datetime(df['endDate'])\n        df = df.sort_values('startDate')\n        df = df.drop_duplicates('\u8b49\u5238\u4ee3\u865f', keep='last').drop('period', axis=1)\n        df = df[df.endDate >= TODAY_STR]\n\n        return df\n\n    def put_call_ratio(self, start: str = '', end: str = ''):\n        if not start:\n            start = TODAY_STR.replace('-', '/')\n\n        if not end:\n            end = TODAY_STR.replace('-', '/')\n\n        df = pd.DataFrame()\n\n        s = start\n        while True:\n            e = str(\n                (pd.to_datetime(s) + timedelta(days=30)).date()).replace('-', '/')\n            logging.info(f'Period: {s} - {e}')\n\n            url = f'{self.url_pc_ratio}?queryStartDate={s}&queryEndDate={e}'\n            tb = pd.read_html(url)[3]\n            df = pd.concat([df, tb])\n\n            if pd.to_datetime(e) >= pd.to_datetime(end):\n                break\n\n            s = str(\n                (pd.to_datetime(e) + timedelta(days=1)).date()).replace('-', '/')\n            time.sleep(10)\n\n        df = df.rename(columns={\n            '\u65e5\u671f': 'Date',\n            '\u8ce3\u6b0a\u6210\u4ea4\u91cf': 'PutVolume',\n            '\u8cb7\u6b0a\u6210\u4ea4\u91cf': 'CallVolume',\n            '\u8cb7\u8ce3\u6b0a\u6210\u4ea4\u91cf\u6bd4\u7387%': 'PutCallVolumeRatio',\n            '\u8ce3\u6b0a\u672a\u5e73\u5009\u91cf': 'PutOpenInterest',\n            '\u8cb7\u6b0a\u672a\u5e73\u5009\u91cf': 'CallOpenInterest',\n            '\u8cb7\u8ce3\u6b0a\u672a\u5e73\u5009\u91cf\u6bd4\u7387%': 'PutCallRatio'\n        })\n        df.Date = pd.to_datetime(df.Date)\n\n        return df.sort_values('Date').reset_index(drop=True)\n\n    def export_put_call_ratio(self, df: pd.DataFrame):\n        if db.HAS_DB:\n            dates = db.query(PutCallRatioList.Date).Date\n            db.dataframe_to_DB(df[~df.Date.isin(dates)], PutCallRatioList)\n        else:\n            filename = f'{PATH}/put_call_ratio.csv'\n            df_pcr = self.read_and_concat(filename, df)\n            self.save_table(df_pcr, f'{PATH}/put_call_ratio.csv')\n\n    def export_futures_kbar(self, df: pd.DataFrame):\n        if db.HAS_DB:\n            db.dataframe_to_DB(df, KBarData1T)\n\n        year_month = TODAY_STR[:-3]\n        filename = f'{PATH}/Kbars/1T/{year_month}-futures-1T.pkl'\n        df.Volume = df.Volume.astype('int32')\n        df = self.read_and_concat(filename, df)\n        self.save_table(df, filename)\n\n    def export_ex_dividend_list(self, df: pd.DataFrame):\n        if db.HAS_DB:\n            df_old = db.query(ExDividendTable)\n            df = df[df.Date > df_old.Date.max()].copy()\n\n            db.dataframe_to_DB(df, ExDividendTable)\n        else:\n            self.save_table(df, f'{PATH}/exdividends.csv')\n\n    def ex_dividend_list(self):\n        '''\u722c\u87f2:\u8b49\u4ea4\u6240\u9664\u6b0a\u606f\u516c\u544a\u8868'''\n\n        try:\n            df = pd.read_csv(\n                self.url_ex_dividend, encoding='cp950', on_bad_lines='skip')\n        except:\n            df = pd.read_csv(\n                self.url_ex_dividend, encoding='big5', on_bad_lines='skip')\n\n        df = df.reset_index()\n        df.columns = df.iloc[0, :]\n        df = df.rename(columns={\n            '\u9664\u6b0a\u9664\u606f\u65e5\u671f': 'Date',\n            '\u80a1\u7968\u4ee3\u865f': 'Code',\n            '\u540d\u7a31': 'Name',\n            '\u9664\u6b0a\u606f': 'DividendType',\n            '\u7121\u511f\u914d\u80a1\u7387': 'DividendRate',\n            '\u73fe\u91d1\u589e\u8cc7\u914d\u80a1\u7387': 'CashCapitalRate',\n            '\u73fe\u91d1\u589e\u8cc7\u8a8d\u8cfc\u50f9': 'CashCapitalPrice',\n            '\u73fe\u91d1\u80a1\u5229': 'CashDividend',\n            '\u8a73\u7d30\u8cc7\u6599': 'Details',\n            '\u53c3\u8003\u50f9\u8a66\u7b97': 'Reference',\n            '\u6700\u8fd1\u4e00\u6b21\u7533\u5831\u8cc7\u6599 \u5b63\u5225/\u65e5\u671f': 'Quarter',\n            '\u6700\u8fd1\u4e00\u6b21\u7533\u5831\u6bcf\u80a1 (\u55ae\u4f4d)\u6de8\u503c': 'NetValue',\n            '\u6700\u8fd1\u4e00\u6b21\u7533\u5831\u6bcf\u80a1 (\u55ae\u4f4d)\u76c8\u9918': 'EPS'\n        })\n        df = df.iloc[1:, :-1]\n        df = df[df.Code.notnull()]\n        df = df[(df.Code.apply(len) == 4)]\n        df.Date = df.Date.apply(self.convert_date_format)\n        df.Date = pd.to_datetime(df.Date)\n        df.CashDividend = df.CashDividend.astype(float)\n        df.CashCapitalPrice = df.CashCapitalPrice.replace('\u5c1a\u672a\u516c\u544a', -1)\n        return df.sort_values('Date')\n\n    def DowJones(self, start: datetime, end: datetime):\n        '''\u9245\u4ea8\u7db2\u9053\u74ca\u5831\u50f9'''\n\n        url_dow_jones = 'https://ws.api.cnyes.com/ws/api/v1/charting/history'\n        start = self.date_2_mktime(start)\n        end = self.date_2_mktime(end)\n        params = f'?resolution=D&symbol=GI:DJI:INDEX&from={end}&to={start}'\n\n        try:\n            result = requests.get(url_dow_jones+params)\n            result = json.loads(result.text)\n            if 'data' not in result:\n                result['data'] = {}\n        except requests.exceptions.ConnectionError as e:\n            logging.warning(e)\n            result = {'data': {}}\n        except:\n            logging.exception('\u3010Error\u3011DowJones:')\n            result = {'data': {}}\n\n        return result['data']\n\n    def get_SymbolWinBroker_InputRadio(self, date: str, stockid: str):\n        '''\u80a1\u61c2\u5238\u5546'''\n\n        url = self.above_one_url('SymbolWinBroker_InputRadio', date, stockid)\n        content = requests.get(url, headers=self.headers)\n        soup = BeautifulSoup(content.text, \"lxml\")\n        soup = soup.find(\n            \"table\", {\"class\": \"TProStkChips/SymbolWinBroker_InputRadio_css\"})\n        soup = soup.find_all('td')\n        soup = [td.text.replace('\u25bc\u2780', '').replace('%', '')\n                for td in soup if len(td.text)]\n\n        columns = soup[:3]\n        soup = np.reshape(soup[3:], (int(len(soup[3:])/3), 3))\n        df = pd.DataFrame(soup, columns=columns)\n        df['\u640d\u76ca(\u767e\u842c)'] = df['\u640d\u76ca(\u767e\u842c)'].astype(float)\n        df.\u5206\u9ede\u5831\u916c\u7387 = df.\u5206\u9ede\u5831\u916c\u7387.astype(float)\n        df = df.sort_values('\u5206\u9ede\u5831\u916c\u7387', ascending=False).reset_index(drop=True)\n        return df\n\n    def get_SymbolWinBroker(self, date: str, stockid: str):\n        '''\u80a1\u61c2\u5238\u5546\u6392\u884c\u699c'''\n\n        url = self.above_one_url('SymbolWinBroker', date, stockid)\n        result = requests.get(url, headers=self.headers)\n        result = json.loads(result.text)['result']\n        df = pd.DataFrame(result['data'], columns=result['cheaders'])\n        df = df.sort_values('\u5206\u9ede\u5831\u916c\u7387', ascending=False).reset_index(drop=True)\n        return df\n\n    def get_SymbolBrkNetVol(self, df_brokers: pd.DataFrame, stockid: str, topN=2):\n        '''\u67e5\u5206\u9ede\u5831\u916c\u524dN\u9ad8\u7684\u5238\u5546\u8cb7\u8ce3\u8d85'''\n\n        brokers = df_brokers.head(topN).\u5238\u5546\u4ee3\u865f.values\n\n        domain = 'https://www.above.one/cdn/TProStk'\n        pageName = 'SymbolBrkNetVol'\n        krange2 = 'OneYear'\n        tb = pd.DataFrame(columns=['\u65e5\u671f', 'Code'])\n        for brkId in brokers:\n            url = f'{domain}/AuxData/RpNpJBcMvT.json?s=Date:a&aux={pageName}&auxParams=brkId_{brkId}&kfreq=day&krange2={krange2}&sym={stockid}&country=Tw'\n            result = requests.get(url, headers=self.headers)\n            result = json.loads(result.text)['result']\n            df = pd.DataFrame(result['data'], columns=result['cheaders'])\n            df.\u65e5\u671f = pd.to_datetime(df.\u65e5\u671f)\n            df = df.sort_values('\u65e5\u671f').rename(columns={'\u8cb7\u8d85\u80a1\u6578': f'{brkId}'})\n            df.insert(1, 'Code', stockid)\n            tb = tb.merge(df, how='outer', on=['\u65e5\u671f', 'Code'])\n            time.sleep(.5)\n\n        tb['TotalBuy'] = tb.iloc[:, 2:].sum(axis=1)  # .cumsum()\n        return tb\n\n    def get_FuturesTickData(self, date: str):\n        '''\u524d30\u500b\u4ea4\u6613\u65e5\u671f\u8ca8\u6bcf\u7b46\u6210\u4ea4\u8cc7\u6599'''\n\n        try:\n            year = date.split('-')[0]\n            month = date.split('-')[1]\n            date = date.replace('-', '_')\n\n            result = requests.get(f\"{self.url_futures_tick}/Daily_{date}.zip\")\n            z = zipfile.ZipFile(io.BytesIO(result.content))\n            z.extractall(f'{PATH}/ticks/futures/{year}/Daily_{year}_{month}')\n        except zipfile.BadZipFile:\n            logging.error('\u8f38\u5165\u7684\u65e5\u671f\u975e\u4ea4\u6613\u65e5')\n        except:\n            logging.exception('Catch an exception (get_FuturesTickData):')\n\n    def get_CashSettle(self):\n        '''\u53d6\u5f97\u4ea4\u6613\u7576\u65e5\u5168\u984d\u4ea4\u5272\u80a1\u6e05\u55ae'''\n\n        try:\n            df = pd.read_html(self.url_cash_settle)\n            return df[0]\n        except:\n            logging.warning('\u67e5\u7121\u5168\u984d\u4ea4\u5272\u80a1\u6e05\u55ae')\n            return pd.DataFrame(columns=['\u80a1\u7968\u4ee3\u78bc'])", ""]}
{"filename": "trader/utils/subscribe.py", "chunked_list": ["import numpy as np\nfrom typing import Union\n\nfrom ..config import API\nfrom . import get_contract\n\n\nclass Quotes:\n    AllIndex = {'TSE001': [], 'OTC101': []}\n    NowIndex = {}\n    AllTargets = {}\n    NowTargets = {}", "\n\nclass Subscriber:\n    def __init__(self):\n        # \u5373\u6642\u6210\u4ea4\u8cc7\u6599, \u6240\u6709\u6210\u4ea4\u8cc7\u6599, \u4e0b\u55ae\u8cc7\u6599\n        self.BidAsk = {}\n        self.Quotes = Quotes()\n\n    def _set_target_quote_default(self, targets: str):\n        '''\u521d\u59cb\u5316\u80a1\u7968/\u671f\u6b0a\u76e4\u4e2d\u8cc7\u8a0a'''\n        keys = [\n            'price', 'amount', 'total_amount',\n            'volume', 'total_volume', 'tick_type'\n        ]\n        self.Quotes.AllTargets = {s: {k: [] for k in keys} for s in targets}\n\n    def _set_index_quote_default(self):\n        '''\u521d\u59cb\u5316\u6307\u6578\u76e4\u4e2d\u8cc7\u8a0a'''\n        self.Quotes.AllIndex = {'TSE001': [], 'OTC101': []}\n\n    def index_v0(self, quote: dict):\n        if quote['Code'] == '001':\n            self.Quotes.NowIndex['TSE001'] = quote\n            self.Quotes.AllIndex['TSE001'].append(quote)\n        elif quote['Code'] == '101':\n            self.Quotes.NowIndex['OTC101'] = quote\n            self.Quotes.AllIndex['OTC101'].append(quote)\n\n    def stk_quote_v1(self, tick):\n        '''\u8655\u7406\u80a1\u7968\u5373\u6642\u6210\u4ea4\u8cc7\u6599'''\n        tick_data = dict(tick)\n        for k in [\n            'open', 'close', 'high', 'low', 'amount', 'total_amount', 'total_volume',\n            'avg_price', 'price_chg', 'pct_chg'\n        ]:\n            tick_data[k] = float(tick_data[k])\n        tick_data['price'] = tick_data['close']\n\n        for k in ['price', 'amount', 'total_amount', 'volume', 'total_volume', 'tick_type']:\n            self.Quotes.AllTargets[tick.code][k].append(tick_data[k])\n\n        self.Quotes.NowTargets[tick.code] = tick_data\n        return tick_data\n\n    def fop_quote_v1(self, symbol: str, tick):\n        '''\u8655\u7406\u671f\u6b0a\u5373\u6642\u6210\u4ea4\u8cc7\u6599'''\n        tick_data = dict(tick)\n        for k in [\n            'open', 'close', 'high', 'low', 'amount', 'total_amount',\n            'underlying_price', 'avg_price', 'price_chg', 'pct_chg'\n        ]:\n            tick_data[k] = float(tick_data[k])\n\n        tick_data['price'] = tick_data['close']\n        tick_data['symbol'] = symbol\n\n        for k in ['price', 'amount', 'total_amount', 'volume', 'total_volume', 'tick_type']:\n            self.Quotes.AllTargets[symbol][k].append(tick_data[k])\n\n        self.Quotes.NowTargets[symbol] = tick_data\n        return tick_data\n\n    def subscribe_index(self):\n        '''\u8a02\u95b1\u6307\u6578\u76e4\u4e2d\u8cc7\u8a0a'''\n\n        API.quote.subscribe(API.Contracts.Indexs.TSE.TSE001, quote_type='tick')\n        API.quote.subscribe(API.Contracts.Indexs.OTC.OTC101, quote_type='tick')\n        self._set_index_quote_default()\n\n    def unsubscribe_index(self):\n        '''\u53d6\u6d88\u8a02\u95b1\u6307\u6578\u76e4\u4e2d\u8cc7\u8a0a'''\n\n        API.quote.unsubscribe(\n            API.Contracts.Indexs.TSE.TSE001, quote_type='tick')\n        API.quote.unsubscribe(\n            API.Contracts.Indexs.OTC.OTC101, quote_type='tick')\n\n    def subscribe_targets(self, targets: list, quote_type: str = 'tick'):\n        '''\u8a02\u95b1\u80a1\u7968/\u671f\u8ca8\u76e4\u4e2d\u8cc7\u8a0a'''\n\n        for t in targets:\n            target = get_contract(t)\n            API.quote.subscribe(target, quote_type=quote_type, version='v1')\n\n    def unsubscribe_targets(self, targets: str, quote_type: str = 'tick'):\n        '''\u53d6\u6d88\u8a02\u95b1\u80a1\u7968\u76e4\u4e2d\u8cc7\u8a0a'''\n\n        for t in targets:\n            target = get_contract(t)\n            API.quote.unsubscribe(target, quote_type=quote_type, version='v1')\n\n    def subscribe_all(self, targetLists: Union[list, np.array]):\n        '''\u8a02\u95b1\u6307\u6578\u3001tick\u3001bidask\u8cc7\u6599'''\n\n        self.subscribe_index()\n        self.subscribe_targets(targetLists, 'tick')\n        self.subscribe_targets(targetLists, 'bidask')\n        self._set_target_quote_default(targetLists)\n\n    def unsubscribe_all(self, targetLists: Union[list, np.array]):\n        '''\u53d6\u6d88\u8a02\u95b1\u6307\u6578\u3001tick\u3001bidask\u8cc7\u6599'''\n\n        self.unsubscribe_index()\n        self.unsubscribe_targets(targetLists, 'tick')\n        self.unsubscribe_targets(targetLists, 'bidask')", ""]}
{"filename": "trader/utils/accounts.py", "chunked_list": ["import time\nimport logging\nimport pandas as pd\nimport shioaji as sj\nfrom datetime import datetime\nfrom shioaji.account import StockAccount\n\nfrom .. import crawler2\nfrom ..config import API, PATH, TODAY, TODAY_STR\nfrom .time import TimeTool", "from ..config import API, PATH, TODAY, TODAY_STR\nfrom .time import TimeTool\nfrom .file import FileHandler\n\n\nclass AccountInfo(TimeTool, FileHandler):\n    def __init__(self):\n        self.filename = f'{TODAY.year}_\u80a1\u7968\u5e33\u52d9\u8cc7\u8a0a.xlsx'\n        self.DEFAULT_TABLE = pd.DataFrame(\n            columns=[\n                '\u4ea4\u6613\u65e5\u671f',\n                'T\u65e5\u4ea4\u5272\u91d1\u984d',\n                'T\u65e5\u5e33\u6236\u9918\u984d',\n                'T+1\u65e5\u4ea4\u5272\u91d1\u984d',\n                'T+1\u65e5\u5e33\u6236\u9918\u984d',\n                'T+2\u65e5\u4ea4\u5272\u91d1\u984d',\n                'T+2\u65e5\u5e33\u6236\u9918\u984d',\n                '\u5eab\u5b58\u7e3d\u6210\u672c',\n                '\u5eab\u5b58\u73fe\u503c',\n                '\u878d\u8cc7\u91d1\u984d',\n                '\u878d\u5238\u91d1\u984d',\n                '\u672a\u5be6\u73fe\u640d\u76ca',\n                '\u5df2\u5be6\u73fe\u640d\u76ca',\n                '\u7576\u65e5\u65b0\u589e\u5eab\u5b58\u672a\u5be6\u73fe\u640d\u76ca',\n                '\u7e3d\u90e8\u4f4d\u73fe\u503c(\u542b\u878d\u8cc7\u91d1\u984d)',\n                '\u7e3d\u90e8\u4f4d\u73fe\u503c(\u4e0d\u542b\u878d\u8cc7\u91d1\u984d)',\n                '\u7d50\u7b97\u73fe\u503c'\n            ])\n        self.HAS_FUTOPT_ACCOUNT = False\n        self.desposal_margin = 0\n        self.ProfitAccCount = 0  # \u6b0a\u76ca\u7e3d\u503c\n        self.df_securityInfo = pd.DataFrame(\n            columns=[\n                'account', 'market',\n                'code', 'order_cond', 'action', 'pnl',\n                'cost_price', 'quantity', 'yd_quantity', 'last_price'\n            ]\n        )\n        self.df_futuresInfo = pd.DataFrame(\n            columns=[\n                'Account', 'Market', 'Date', 'Code', 'CodeName', 'OrderNum',\n                'OrderBS', 'OrderType', 'Currency', 'paddingByte', 'Volume',\n                'ContractAverPrice', 'SettlePrice', 'RealPrice', 'FlowProfitLoss', 'SettleProfitLoss',\n                'StartSecurity', 'UpKeepSecurity', 'OTAMT', 'MTAMT'\n            ]\n        )\n\n    def _login(self, API_KEY, SECRET_KEY, account_name):\n        n = 0\n        while n < 5:\n            try:\n                API.login(\n                    api_key=API_KEY,\n                    secret_key=SECRET_KEY,\n                    contracts_timeout=10000\n                )\n                break\n            except TimeoutError as e:\n                logging.warning(f'{e}')\n                n += 1\n                time.sleep(5)\n\n        nth_account = int(account_name[-1])\n        if nth_account > 1:\n            accounts = API.list_accounts()\n            accounts = [a for a in accounts if isinstance(a, StockAccount)]\n            if len(accounts) > 1:\n                API.set_default_account(accounts[nth_account-1])\n            else:\n                logging.warning('\u6b64ID\u53ea\u6709\u4e00\u500b\u8b49\u5238\u6236')\n\n        self.account_name = account_name\n\n        if API.futopt_account:\n            self.HAS_FUTOPT_ACCOUNT = True\n\n        time.sleep(0.05)\n        logging.info(f'\u3010{account_name}\u3011log-in successful!')\n\n    def _list_settlements(self):\n        '''\u53d6\u5f97\u4ea4\u5272\u8cc7\u8a0a'''\n        n = 0\n        while True:\n            try:\n                return API.settlements(API.stock_account)\n            except:\n                logging.warning('\u7121\u6cd5\u53d6\u5f97\u4ea4\u5272\u8cc7\u8a0a\uff0c\u91cd\u8a66\u4e2d')\n                n += 1\n\n                if n >= 60:\n                    return 0\n\n                time.sleep(1)\n\n    def _obj_2_df(self, objects: list):\n        '''\u628a\u81eaAPI\u67e5\u8a62\u5f97\u5230\u7684\u7269\u4ef6\u8f49\u70baDataFrame'''\n        try:\n            return pd.DataFrame([o.__dict__ for o in objects])\n        except:\n            return pd.DataFrame([{o[0]:o[1] for o in objects}])\n\n    def create_info_table(self):\n        if self.is_in_dir(self.filename, f'{PATH}/daily_info/'):\n            return pd.ExcelFile(f'{PATH}/daily_info/{self.filename}')\n        else:\n            return self.DEFAULT_TABLE\n\n    def balance(self, mode='info'):\n        '''\u67e5\u5e33\u6236\u9918\u984d'''\n        n = 0\n        while n < 5:\n            try:\n                df = self._obj_2_df(API.account_balance())\n                df.date = pd.to_datetime(df.date).dt.date.astype(str)\n                balance = df[df.date == df.date.max()].acc_balance.values[0]\n\n                if mode == 'info':\n                    logging.debug(f'Account balance = {balance}')\n            except:\n                logging.exception('Catch an exception (balance):')\n                balance = None\n\n            if balance != None:\n                return balance\n\n            time.sleep(1)\n            n += 1\n\n        logging.debug('\u3010Query account balance failed\u3011')\n        return -1\n\n    def get_stock_name(self, stockid: str):\n        '''\u4ee5\u80a1\u7968\u4ee3\u865f\u67e5\u8a62\u516c\u53f8\u540d\u7a31'''\n        stockname = API.Contracts.Stocks[stockid]\n        if (stockname is not None):\n            return stockname.name\n        return stockname\n\n    def securityInfo(self):\n        '''\u67e5\u5eab\u5b58\u660e\u7d30'''\n        while True:\n            try:\n                stocks = API.list_positions(\n                    API.stock_account,\n                    unit=sj.constant.Unit.Share\n                )\n                stocks = self._obj_2_df(stocks)\n                break\n            except:\n                logging.warning('\u7121\u6cd5\u53d6\u5f97\u5eab\u5b58\uff0c\u91cd\u8a66\u4e2d')\n                time.sleep(1)\n        stocks = stocks.rename(\n            columns={\n                'cond': 'order_cond',\n                'direction': 'action',\n                'price': 'cost_price',\n            }\n        )\n        if stocks.shape[0]:\n            stocks.pnl = stocks.pnl.astype(int)  # \u672a\u5be6\u73fe\u640d\u76ca\n            stocks.order_cond = stocks.order_cond.astype(str)  # \u4ea4\u6613\u5225\n            stocks.insert(1, 'name', stocks.code.apply(self.get_stock_name))\n            stocks[['account', 'market']] = [self.account_name, 'Stocks']\n            return stocks\n        return self.df_securityInfo\n\n    def get_profit_loss(self, start: str, end: str):\n        '''\u67e5\u8a62\u5df2\u5be6\u73fe\u640d\u76ca'''\n        profitloss = API.list_profit_loss(API.stock_account, start, end)\n        return self._obj_2_df(profitloss)\n\n    def query_close(self, stockid: str, date: str):\n        '''\u67e5\u8b49\u5238\u6536\u76e4\u50f9'''\n        ticks = API.ticks(API.Contracts.Stocks[stockid], date)\n        df = pd.DataFrame({**ticks})\n        df.ts = pd.to_datetime(df.ts)\n        try:\n            return df.close.values[-1]\n        except:\n            return -1\n\n    def realized_profit(self, start: str = None, end: str = None):\n        '''\n        \u8a08\u7b97\u5df2\u5be6\u73fe\u640d\u76ca\n        start:\u958b\u59cb\u65e5\u671f, \u9810\u8a2d\u70ba\u6700\u8fd1\u4e00\u500b\u71df\u696d\u65e5(\u67e5\u8a62\u7576\u65e5)\n        end: \u7d50\u675f\u65e5\u671f, \u9810\u8a2d\u70ba\u6700\u8fd1\u4e00\u500b\u71df\u696d\u65e5(\u67e5\u8a62\u7576\u65e5)\n        '''\n\n        i = 0\n        while i < 5:\n            try:\n                day = self._strf_timedelta(TODAY, i)\n                if not start:\n                    start_ = day\n                if not end:\n                    end_ = day\n\n                profitloss = self.get_profit_loss(start_, end_)\n                if profitloss.shape[0]:\n                    return profitloss.pnl.sum()\n                return 0\n            except:\n                # \u9047\u4f11\u5e02\u5247\u5f80\u524d\u4e00\u5929\u67e5\u8a62, \u76f4\u5230\u67e5\u5230\u8cc7\u6599\u70ba\u6b62\n                print(f\"\u67e5\u7121 {day} \u5df2\u5be6\u73fe\u640d\u76ca, \u6539\u67e5\u8a62\u524d\u4e00\u5929\\n\")\n                i += 1\n                time.sleep(2)\n\n                if i == 5:\n                    return 0\n\n    def settle_info(self, mode='info'):\n        '''\u67e5\u8a62 T ~ T+2 \u65e5\u7684\u4ea4\u5272\u91d1\u984d'''\n\n        df_fail = pd.DataFrame(columns=['date', 'amount', 'T'])\n\n        now = datetime.now()\n        if 18 <= now.hour <= 19:\n            logging.debug('Settle info temporary not accessable.')\n            return df_fail\n\n        n = 0\n        while n < 5:\n            try:\n                settlement = self._list_settlements()\n                df = self._obj_2_df(settlement)\n\n                if mode == 'info':\n                    logging.debug(f\"Settlements:{df.to_dict('records')}\")\n\n                return df\n\n            except:\n                logging.exception('Catch an exception (settle_info):')\n\n            time.sleep(1)\n            n += 1\n\n        return df_fail\n\n    def compute_total_cost(self, stocks: pd.DataFrame):\n        '''\u7e3d\u6210\u672c\u5408\u8a08'''\n        if stocks.shape[0]:\n            return (stocks.cost_price*stocks.quantity).sum()\n        return 0\n\n    def compute_total_unrealized_profit(self, stocks: pd.DataFrame):\n        '''\u672a\u5be6\u73fe\u640d\u76ca\u5408\u8a08'''\n        if stocks.shape[0]:\n            return stocks.pnl.sum()\n        return 0\n\n    def compute_margin_amount(self, stocks: pd.DataFrame):\n        '''\u8a08\u7b97\u878d\u8cc7/\u878d\u5238\u91d1\u984d'''\n        if stocks.shape[0]:\n            is_leverage = (\n                'MarginTrading' == stocks.order_cond.apply(lambda x: x._value_))\n            leverages = [\n                crawler2.get_leverage(s)['\u878d\u8cc7\u6210\u6578']/100 for s in stocks.code]\n            return sum(is_leverage*stocks.cost_price*stocks.quantity*leverages)\n        return 0\n\n    def compute_today_unrealized_profit(self, stocks: pd.DataFrame):\n        '\u4eca\u65e5\u65b0\u589e\u5eab\u5b58\u672a\u5be6\u73fe\u640d\u76ca\u5408\u8a08'\n        if stocks.shape[0]:\n            return stocks[stocks.yd_quantity == 0].pnl.sum()\n        return 0\n\n    def query_all(self):\n        # \u5eab\u5b58\u660e\u7d30(\u80a1)\n        stocks = self.securityInfo()\n\n        # \u5df2\u5be6\u73fe\u640d\u76ca\n        profit = self.realized_profit()\n\n        if not stocks.shape[0] and profit == 0:\n            logging.info('\u76ee\u524d\u7121\u5eab\u5b58')\n            return None\n\n        if stocks.shape[0]:\n            print(f'\\n{stocks}\\n')\n\n        # \u5eab\u5b58\u6210\u672c & \u73fe\u503c\n        total_cost = self.compute_total_cost(stocks)\n        unrealized_profit = self.compute_total_unrealized_profit(stocks)\n        total_market_value = total_cost + unrealized_profit\n\n        # \u878d\u8cc7\u91d1\u984d\n        margin_amount = self.compute_margin_amount(stocks)\n\n        # \u5e33\u6236\u9918\u984d\n        balance = self.balance()\n        if balance < 0:\n            logging.error(f'Balance = {balance}, get balance from local')\n            balance = pd.read_excel(\n                f'{PATH}/daily_info/{self.filename}', sheet_name=self.account_name)\n            balance = balance['T+1\u65e5\u5e33\u6236\u9918\u984d'].values[-1]\n\n        # \u4eca\u65e5\u65b0\u589e\u5eab\u5b58\u672a\u5be6\u73fe\u640d\u76ca\n        today_unrealized_profit = self.compute_today_unrealized_profit(stocks)\n\n        # \u5e33\u52d9\u4ea4\u5272\u8cc7\u8a0a\n        settle_info = self.settle_info()\n        settles = settle_info.amount[1:].sum()\n\n        # \u7e3d\u73fe\u503c = \u5e33\u6236\u9918\u984d + T+1\u65e5\u4ea4\u5272\u91d1\u984d + T+2\u65e5\u4ea4\u5272\u91d1\u984d + \u5eab\u5b58\u73fe\u503c\n        total_value = int(balance + total_market_value + settles)\n\n        now = int(total_value - margin_amount - unrealized_profit)\n        settle_t1 = settle_info.values[1, 1]\n        settle_t2 = settle_info.values[2, 1]\n        row = {\n            '\u4ea4\u6613\u65e5\u671f': TODAY_STR,\n            'T\u65e5\u4ea4\u5272\u91d1\u984d': settle_info.values[0, 1],\n            'T\u65e5\u5e33\u6236\u9918\u984d': int(balance),\n            'T+1\u65e5\u4ea4\u5272\u91d1\u984d': settle_t1,\n            'T+1\u65e5\u5e33\u6236\u9918\u984d': balance + settle_t1,\n            'T+2\u65e5\u4ea4\u5272\u91d1\u984d': settle_t2,\n            'T+2\u65e5\u5e33\u6236\u9918\u984d': balance + settle_t1 + settle_t2,\n            '\u5eab\u5b58\u7e3d\u6210\u672c': int(total_cost),\n            '\u5eab\u5b58\u73fe\u503c': int(total_market_value),\n            '\u878d\u8cc7\u91d1\u984d': int(margin_amount),\n            '\u878d\u5238\u91d1\u984d': 0,\n            '\u672a\u5be6\u73fe\u640d\u76ca': int(unrealized_profit),\n            '\u5df2\u5be6\u73fe\u640d\u76ca': int(profit),\n            '\u7576\u65e5\u65b0\u589e\u5eab\u5b58\u672a\u5be6\u73fe\u640d\u76ca': int(today_unrealized_profit),\n            '\u7e3d\u90e8\u4f4d\u73fe\u503c(\u542b\u878d\u8cc7\u91d1\u984d)': int(total_value),\n            '\u7e3d\u90e8\u4f4d\u73fe\u503c(\u4e0d\u542b\u878d\u8cc7\u91d1\u984d)': int(total_value - margin_amount),\n            '\u7d50\u7b97\u73fe\u503c': now\n        }\n        return row\n\n    def update_info(self, df, row):\n        tb = pd.read_excel(df, sheet_name='dentist_1')\n        tb = pd.concat([\n            tb,\n            pd.DataFrame([row])\n        ]).reset_index(drop=True)\n        return tb\n\n    def get_account_margin(self):\n        '''\u671f\u6b0a\u4fdd\u8b49\u91d1\u8cc7\u8a0a'''\n\n        n = 0\n        while n < 5 and API.futopt_account.signed:\n            try:\n                margin = API.margin(API.futopt_account)\n            except:\n                logging.exception('Catch an exception (get_account_margin):')\n                margin = None\n\n            if margin:\n                self.desposal_margin = margin.available_margin\n                self.ProfitAccCount = margin.equity\n                break\n\n            time.sleep(1)\n            n += 1\n\n    def get_openpositions(self):\n        '''\u67e5\u770b\u671f\u6b0a\u5e33\u6236\u6301\u6709\u90e8\u4f4d'''\n\n        positions = API.list_positions(API.futopt_account)\n        if not positions:\n            return self.df_futuresInfo\n\n        df = self._obj_2_df(positions)\n        if df.shape[0]:\n            df[['Account', 'Market']] = [self.account_name, 'Futures']\n            return df\n        return self.df_futuresInfo\n\n    def get_settle_profitloss(self, start_date: str, end_date: str):\n        '''\u67e5\u770b\u671f\u6b0a\u5e33\u6236(\u5df2\u5be6\u73fe)\u640d\u76ca'''\n        # TODO: 1.0.0 list_profit_loss_detail(*api.futopt_account*), list_profit_loss_summary(*api.futopt_account*)\n\n        if start_date:\n            start_date = start_date.replace('-', '')\n\n        if end_date:\n            end_date = end_date.replace('-', '')\n\n        settle_profitloss = API.get_account_settle_profitloss(\n            summary='Y', start_date=start_date, end_date=end_date)\n        df_profitloss = pd.DataFrame(settle_profitloss.data())\n        return df_profitloss\n\n    def dataUsage(self):\n        return round(API.usage().bytes/2**20, 2)", ""]}
{"filename": "trader/utils/notify.py", "chunked_list": ["import logging\nimport requests\nimport pandas as pd\n\nfrom ..config import API, TOKEN_INFO, TOKEN_MONITOR\n\n\nclass Notification:\n    NotifyURL = \"https://notify-api.line.me/api/notify\"\n    order_cond = {\n        'Cash': '\u73fe\u80a1',\n        'MarginTrading': '\u878d\u8cc7',\n        'ShortSelling': '\u878d\u5238'\n    }\n    order_lot = {\n        'Common': '\u5f35',\n        'IntradayOdd': '\u80a1'\n    }\n    oc_type = {\n        'New': '\u65b0\u5009',\n        'Cover': '\u5e73\u5009'\n    }\n\n    def headers(self, msgType: str):\n        '''LINE notify\u63a8\u64adheader\u8a2d\u5b9a'''\n        if msgType in ['Order', 'Deal', 'AccountInfo', 'Monitor', 'Tasker', 'Crawler']:\n            return {\"Authorization\": f\"Bearer {TOKEN_MONITOR}\"} if TOKEN_MONITOR else {}\n        return {\"Authorization\": f\"Bearer {TOKEN_INFO}\"} if TOKEN_INFO else {}\n\n    def post(self, message: str, image_name=None, msgType: str = 'price'):\n        '''Line Notify \u63a8\u64ad\uff0c\u53ef\u50b3\u9001\u6587\u5b57\u6216\u5716\u7247\u8a0a\u606f'''\n\n        data = {'message': message}\n        headers = self.headers(msgType)\n\n        if not headers:\n            return\n\n        if image_name:\n            image = open(image_name, 'rb')\n            files = {'imageFile': image}\n            requests.post(\n                self.NotifyURL,\n                headers=headers,\n                data=data,\n                files=files\n            )\n        else:\n            requests.post(self.NotifyURL, headers=headers, data=data)\n\n    def post_tftOrder(self, stat, msg: dict):\n        '''\u767c\u9001\u63a8\u64ad-\u80a1\u7968\u59d4\u8a17'''\n        logging.debug(f'[{stat}][{msg}]')\n\n        stock = msg['contract']['code']\n        name = API.Contracts.Stocks[stock].name\n        order = msg['order']\n        account = order['account']['account_id']\n        cond = self.order_cond[order['order_cond']]\n        lot = self.order_lot[order['order_lot']]\n\n        operation = msg['operation']\n        if operation['op_code'] == '00' or operation['op_msg'] == '':\n            text = f\"\\n\u3010\u59d4\u8a17\u6210\u529f\u3011{name}-{stock}\\n\u3010\u5e33\u865f\u3011{account}\\n\u3010{cond}\u3011{order['action']} {order['quantity']}{lot}\"\n            self.post(text, msgType='Order')\n\n        if operation['op_code'] == '88':\n            text = f\"\\n\u3010\u59d4\u8a17\u5931\u6557\u3011{name}-{stock}\\n\u3010\u5e33\u865f\u3011{account}\\n\u3010{operation['op_msg']}\u3011\"\n            self.post(text, msgType='Order')\n\n        if operation['op_type'] == 'Cancel':\n            text = f\"\\n\u3010\u522a\u55ae\u6210\u529f\u3011{name}-{stock}\\n\u3010\u5e33\u865f\u3011{account}\\n\u3010{cond}\u3011{order['action']} {order['quantity']}{lot}\"\n            self.post(text, msgType='Order')\n\n    def post_tftDeal(self, stat, msg: dict):\n        '''\u767c\u9001\u63a8\u64ad-\u80a1\u7968\u6210\u4ea4'''\n        logging.debug(f'[{stat}][{msg}]')\n\n        stock = msg['code']\n        name = API.Contracts.Stocks[stock].name\n        account = msg['account_id']\n        cond = self.order_cond[msg['order_cond']]\n        lot = self.order_lot[msg['order_lot']]\n        price = msg['price']\n        text = f\"\\n\u3010\u6210\u4ea4\u3011{name}-{stock}\\n\u3010\u5e33\u865f\u3011{account}\\n\u3010{cond}\u3011{msg['action']} {msg['quantity']}{lot} {price}\u5143\"\n        self.post(text, msgType='Deal')\n\n    def post_fOrder(self, stat, msg: dict):\n        '''\u767c\u9001\u63a8\u64ad-\u671f\u8ca8\u59d4\u8a17'''\n        logging.debug(f'[{stat}][{msg}]')\n\n        code = msg['contract']['code']\n        delivery_month = msg['contract']['delivery_month']\n        name = API.Contracts['Futures'][code][code+delivery_month].name\n        order = msg['order']\n        account = order['account']['account_id']\n        oc_type = self.oc_type[order['oc_type']]\n        quantity = order['quantity']\n\n        operation = msg['operation']\n        if operation['op_code'] == '00' or operation['op_msg'] == '':\n            text = f\"\\n\u3010\u59d4\u8a17\u6210\u529f\u3011{name}({code+delivery_month})\\n\u3010\u5e33\u865f\u3011{account}\\n\u3010{oc_type}\u3011{order['action']} {quantity}\u53e3\"\n            self.post(text, msgType='Order')\n\n        if operation['op_code'] != '00':\n            text = f\"\\n\u3010\u59d4\u8a17\u5931\u6557\u3011{name}({code+delivery_month})\\n\u3010\u5e33\u865f\u3011{account}\\n\u3010{operation['op_msg']}\u3011\"\n            self.post(text, msgType='Order')\n\n    def post_fDeal(self, stat, msg: dict):\n        '''\u767c\u9001\u63a8\u64ad-\u671f\u8ca8\u6210\u4ea4'''\n        logging.debug(f'[{stat}][{msg}]')\n\n        code = msg['code']\n        delivery_month = msg['delivery_month']\n        name = API.Contracts['Futures'][code][code+delivery_month].name\n        account = msg['account_id']\n        price = msg['price']\n        quantity = msg['quantity']\n        text = f\"\\n\u3010\u6210\u4ea4\u3011{name}({code+delivery_month})\\n\u3010\u5e33\u865f\u3011{account}\\n\u3010{msg['action']}\u3011{quantity}\u53e3 {price}\u5143\"\n        self.post(text, msgType='Deal')\n\n    def post_put_call_ratio(self, df_pcr: pd.DataFrame):\n        '''\u767c\u9001\u63a8\u64ad-Put/Call Ratio'''\n\n        if df_pcr.shape[0]:\n            put_call_ratio = df_pcr.PutCallRatio.values[0]\n        else:\n            put_call_ratio = '\u67e5\u7121\u8cc7\u6599'\n\n        text = f\"\\n\u3010\u672c\u65e5Put/Call Ratio\u3011 {put_call_ratio}\"\n        self.post(text, msgType='Msg')\n\n    def post_account_info(self, account_id: str, info: dict):\n        '''\u767c\u9001\u63a8\u64ad-\u6bcf\u65e5\u5e33\u52d9'''\n\n        if info:\n            text = f'\\n\u5e33\u865f: {account_id}'\n            for k, i in info.items():\n                text += f'\\n{k}: {i}'\n        else:\n            text = '\u67e5\u7121\u8cc7\u8a0a'\n\n        text = f\"\\n\u3010\u76e4\u5f8c\u5e33\u52d9\u8cc7\u8a0a\u3011{text}\"\n        self.post(text, msgType='AccountInfo')\n\n    def post_stock_selection(self, df: pd.DataFrame):\n        '''\u767c\u9001\u63a8\u64ad-\u6bcf\u65e5\u9078\u80a1\u6e05\u55ae'''\n\n        if df.shape[0]:\n            strategies = df.Strategy.unique()\n\n            text = ''\n            for s in strategies:\n                temp = df[df.Strategy == s]\n                temp = temp.set_index('company_name').code.to_dict()\n\n                _text = ''\n                for k, v in temp.items():\n                    _text += f'\\n{k}({v}), '\n\n                text += f\"\\n----------{s}----------{_text.rstrip(', ')}\\n\"\n            text = text.rstrip('\\n')\n\n        else:\n            text = '\u7121'\n\n        text = f\"\\n\u3010\u672c\u65e5\u9078\u80a1\u6e05\u55ae\u3011{text}\"\n        self.post(text, msgType='StockSelect')", ""]}
{"filename": "trader/utils/select.py", "chunked_list": ["import logging\nimport numpy as np\nimport pandas as pd\nfrom datetime import timedelta\n\nfrom ..config import PATH, TODAY_STR, TODAY, SelectMethods\nfrom .time import TimeTool\nfrom .file import FileHandler\nfrom .crawler import readStockList\nfrom .database import db, KBarTables", "from .crawler import readStockList\nfrom .database import db, KBarTables\nfrom .database.tables import SelectedStocks\ntry:\n    from ..scripts.conditions import SelectConditions\nexcept:\n    logging.warning('Cannot import select scripts from package.')\n    SelectConditions = None\ntry:\n    from ..scripts.features import FeaturesSelect\nexcept:\n    logging.warning('Cannot import feature scripts from package.')\n    FeaturesSelect = None", "try:\n    from ..scripts.features import FeaturesSelect\nexcept:\n    logging.warning('Cannot import feature scripts from package.')\n    FeaturesSelect = None\n\n\nclass SelectStock(TimeTool, FileHandler):\n    def __init__(self, scale='1D'):\n        self.set_select_scripts(SelectConditions, FeaturesSelect)\n        self.scale = scale\n        self.categories = {\n            1: '\u6c34\u6ce5\u5de5\u696d',\n            2: '\u98df\u54c1\u5de5\u696d',\n            3: '\u5851\u81a0\u5de5\u696d',\n            4: '\u7d21\u7e54\u7e96\u7dad',\n            5: '\u96fb\u6a5f\u6a5f\u68b0',\n            6: '\u96fb\u5668\u96fb\u7e9c',\n            21: '\u5316\u5b78\u5de5\u696d',\n            22: '\u751f\u6280\u91ab\u7642\u696d',\n            8: '\u73bb\u7483\u9676\u74f7',\n            9: '\u9020\u7d19\u5de5\u696d',\n            10: '\u92fc\u9435\u5de5\u696d',\n            11: '\u6a61\u81a0\u5de5\u696d',\n            12: '\u6c7d\u8eca\u5de5\u696d',\n            24: '\u534a\u5c0e\u9ad4\u696d',\n            25: '\u96fb\u8166\u53ca\u9031\u908a\u8a2d\u5099\u696d',\n            26: '\u5149\u96fb\u696d',\n            27: '\u901a\u4fe1\u7db2\u8def\u696d',\n            28: '\u96fb\u5b50\u96f6\u7d44\u4ef6\u696d',\n            29: '\u96fb\u5b50\u901a\u8def\u696d',\n            30: '\u8cc7\u8a0a\u670d\u52d9\u696d',\n            31: '\u5176\u4ed6\u96fb\u5b50\u696d',\n            14: '\u5efa\u6750\u71df\u9020',\n            15: '\u822a\u904b\u696d',\n            16: '\u89c0\u5149\u4e8b\u696d',\n            17: '\u91d1\u878d\u696d',\n            18: '\u8cbf\u6613\u767e\u8ca8',\n            23: '\u6cb9\u96fb\u71c3\u6c23\u696d',\n            19: '\u7d9c\u5408',\n            20: '\u5176\u4ed6',\n            32: '\u6587\u5316\u5275\u610f\u696d',\n            33: '\u8fb2\u696d\u79d1\u6280\u696d',\n            34: '\u96fb\u5b50\u5546\u52d9',\n            80: '\u7ba1\u7406\u80a1\u7968'\n        }\n\n    def set_select_scripts(self, select_scripts: object = None, feature_scripts: object = None):\n        '''Set preprocess & stock selection scripts'''\n\n        if select_scripts and feature_scripts:\n            feature_scripts = feature_scripts()\n            self.Preprocess = {\n                m: getattr(feature_scripts, f'preprocess_{m}') for m in SelectMethods}\n\n            if hasattr(feature_scripts, 'preprocess_common'):\n                self.Preprocess.update({\n                    'preprocess_common': feature_scripts.preprocess_common})\n\n            select_scripts = select_scripts()\n            self.METHODS = {\n                m: getattr(select_scripts, f'condition_{m}') for m in SelectMethods}\n        else:\n            self.Preprocess = {}\n            self.METHODS = {}\n\n    def load_and_merge(self, targets):\n        if db.HAS_DB:\n            start = TODAY - timedelta(days=365*2)\n            condition1 = KBarTables[self.scale].Time >= start\n            condition2 = KBarTables[self.scale].name.in_(targets)\n            df = db.query(KBarTables[self.scale], condition1, condition2)\n        else:\n            dir_path = f'{PATH}/Kbars/{self.scale}'\n            df = self.read_tables_in_folder(dir_path, pattern='stocks')\n\n        df = df.drop_duplicates(['name', 'Time'], keep='last')\n        df = df.sort_values(['name', 'Time'])\n        return df\n\n    def preprocess(self, df: pd.DataFrame):\n        df = df.groupby('name').tail(365).reset_index(drop=True)\n        df.name = df.name.astype(int).astype(str)\n        df.Close = df.Close.replace(0, np.nan).fillna(method='ffill')\n\n        for col in ['Open', 'High', 'Low', 'Close']:\n            df.loc[\n                (df.name == '8070') & (df.Time < '2020-08-17'), col] /= 10\n            df.loc[\n                (df.name == '6548') & (df.Time < '2019-09-09'), col] /= 10\n\n        if 'preprocess_common' in self.Preprocess:\n            df = self.Preprocess['preprocess_common'](df)\n\n        return df\n\n    def pick(self, *args):\n        stockids = readStockList()\n        df = self.load_and_merge(stockids.code.tolist() + ['1', '101'])\n        df = self.preprocess(df)\n\n        for m, func in self.Preprocess.items():\n            if m != 'preprocess_common':\n                df = func(df)\n\n        for i, (m, func) in enumerate(self.METHODS.items()):\n            df.insert(i+2, m, func(df, *args))\n\n        # insert columns\n        stockids.category = stockids.category.astype(int)\n        stockids = stockids.set_index('code')\n\n        df.insert(1, 'company_name', df.name.map(stockids.name.to_dict()))\n        df.insert(2, 'category', df.name.map(\n            stockids.category.to_dict()).map(self.categories))\n\n        return df\n\n    def melt_table(self, df: pd.DataFrame, columns=[]):\n        '''Melt the \"strategy\" columns into values of a table'''\n\n        if not columns:\n            columns = [\n                'name', 'company_name', 'category', 'Time',\n                'Open', 'High', 'Low', 'Close', 'Volume', 'Amount',\n            ]\n        select_methods = list(self.METHODS)\n\n        df = df[columns + select_methods]\n        df = df.melt(\n            id_vars=columns,\n            value_vars=select_methods,\n            var_name='Strategy',\n            value_name='isMatch'\n        )\n        df.Strategy *= df.isMatch\n        df = df[df.Strategy != '']\n\n        df = df.reset_index(drop=True).drop('isMatch', axis=1)\n        df = df.rename(columns={'name': 'code'})\n        df = df.sort_values(['Strategy', 'code'])\n\n        return df\n\n    def export(self, df: pd.DataFrame):\n        if db.HAS_DB:\n            db.dataframe_to_DB(df, SelectedStocks)\n        else:\n            self.save_table(df, f'{PATH}/selections/all.csv')\n            self.save_table(\n                df, f'{PATH}/selections/history/{TODAY_STR}-all.csv')\n\n    def get_selection_files(self):\n        '''\u53d6\u5f97\u9078\u80a1\u6e05\u55ae'''\n\n        day = self.last_business_day()\n\n        if db.HAS_DB:\n            df = db.query(SelectedStocks, SelectedStocks.Time == day)\n        else:\n            df = self.read_table(\n                filename=f'{PATH}/selections/all.csv',\n                df_default=pd.DataFrame(columns=[\n                    'code', 'company_name', 'category', 'Time',\n                    'Open', 'High', 'Low', 'Close',\n                    'Volume', 'Amount', 'Strategy'\n                ])\n            )\n            df.Time = pd.to_datetime(df.Time)\n            df.code = df.code.astype(str)\n            df = df[df.Time == day]\n\n        return df", ""]}
{"filename": "trader/utils/time.py", "chunked_list": ["import re\nimport time\nimport pandas as pd\nfrom typing import Union\nfrom datetime import datetime, timedelta\n\nfrom ..config import TODAY_STR, holidays\n\n\nclass TimeTool:\n\n    DueDays = {\n        (d.year, d.month): d for d in pd.date_range('2001-01-01', '2030-12-31', freq='WOM-3WED')}\n\n    def datetime_to_str(self, date: datetime):\n        '''\u5c07datetime\u6642\u9593\u8f49\u70ba\u5b57\u4e32, \u8f38\u51fa\u683c\u5f0f:YYYY-MM-DD'''\n        return date.strftime(\"%Y-%m-%d\")\n\n    def str_to_datetime(self, date: str):\n        '''\u5c07\u5b57\u4e32\u6642\u9593\u8f49\u70badatetime, \u8f38\u5165\u683c\u5f0f:YYYY-MM-DD'''\n        return datetime.strptime(date, \"%Y-%m-%d\")\n\n    def now_str(self):\n        '''\u53d6\u5f97\u7576\u4e0b\u6642\u9593\u6233\u7684\u5b57\u4e32\u683c\u5f0f'''\n        return datetime.now().strftime('%Y-%m-%d %a %H:%M:%S.%f')\n\n    def now_for_log(self):\n        return f\"\u3010{self.now_str()}\u3011\"\n\n    def _strf_timedelta(self, date: Union[str, datetime], delta: int):\n        '''\u8a08\u7b97\u524dN\u65e5\u7684\u65e5\u671f(str)'''\n\n        if isinstance(date, str):\n            date = self.str_to_datetime(date)\n\n        return self.datetime_to_str(date - timedelta(days=delta))\n\n    def get_buyday(self, day: datetime):\n        '''\u8a08\u7b97\u9032\u5834\u65e5'''\n        n = self.nday_diff(day) + 1\n        return self._strf_timedelta(day, n)\n\n    def nday_diff(self, date: datetime):\n        '''\n        \u9047\u5047\u65e5\u7684\u65e5\u6578\u5224\u65b7\n        \u82e5\u4eca\u65e5\u70ba\u661f\u671f\u4e00, \u5f80\u524d\u63a8\u7b972\u5929\n        \u82e5\u4eca\u65e5\u70ba\u661f\u671f\u5929, \u5f80\u524d\u63a8\u7b971\u5929\n        \u5176\u9918\u65e5\u5b50\u53ea\u8981\u524d\u4e00\u5929\u70ba\u4ea4\u6613\u65e5\u5247\u4e0d\u9808\u5f80\u524d\u63a8\u7b97\n        '''\n        if (date.weekday() == 0):\n            return 2\n        elif (date.weekday() == 6):\n            return 1\n        return 0\n\n    def date_diff(self, day1: Union[str, datetime], day2: Union[str, datetime]):\n        '''\u8a08\u7b97\u5169\u500b\u65e5\u671f\u4e4b\u9593\u7684\u5929\u6578'''\n        if isinstance(day1, str):\n            day1 = pd.to_datetime(day1)\n\n        if isinstance(day2, str):\n            day2 = pd.to_datetime(day2)\n\n        return (day1 - day2).days\n\n    def is_pass_time(self, time_target: Union[str, datetime]):\n        '''\u6aa2\u67e5\u7576\u4e0b\u6642\u9593\u662f\u5426\u5df2\u904e\u60f3\u6aa2\u67e5\u7684\u76ee\u6a19\u6642\u9593'''\n        if isinstance(time_target, str):\n            time_target = pd.to_datetime(time_target)\n\n        return datetime.now() >= time_target\n\n    def count_n_kbars(self, start: datetime, end: datetime, scale: int):\n        '''\n        \u8a08\u7b97K\u68d2\u6578\u91cf\n        scale\u55ae\u4f4d: min\n        '''\n        # TODO: \u6263\u9664\u570b\u5b9a\u5047\u65e5\u4e0d\u958b\u76e4 & \u6536\u76e4\u671f\u9593\n\n        if isinstance(start, str):\n            start = pd.to_datetime(start)\n\n        if isinstance(end, str):\n            end = pd.to_datetime(end)\n\n        m1 = start.minute - (start.minute % scale)\n        start = start.replace(minute=m1, second=0, microsecond=0)\n\n        m2 = end.minute - (end.minute % scale)\n        end = end.replace(minute=m2, second=0, microsecond=0)\n\n        n_kbar = (end - start).total_seconds()/60/scale\n\n        if start.weekday() == 4 and end.weekday() == 0:\n            n_kbar -= 1440*2/scale\n\n        return n_kbar\n\n    def convert_date_format(self, x: str):\n        '''\u8f49\u63db\u6c11\u570b\u683c\u5f0f\u70ba\u897f\u5143\u683c\u5f0f'''\n\n        x = re.findall('\\d+', x)\n        year = int(x[0])\n        if year < 1911:\n            x[0] = str(year + 1911)\n        return '-'.join(x)\n\n    def date_2_mktime(self, date: str):\n        '''\u5c07\u65e5\u671f\u8f49\u70ba\u6d6e\u9ede\u6578\u683c\u5f0f'''\n\n        date = date.replace('-', '').replace('/', '')\n        date = date.replace(' ', '').replace(':', '')\n        date = datetime(int(date[:4]), int(date[4:6]), int(date[6:8]), 8)\n        return int(time.mktime(date.timetuple()))\n\n    def utcfromtimestamp_(self, timestamp):\n        '''\u5c07\u6d6e\u9ede\u683c\u5f0f\u6642\u9593\u6233\u8f49\u70badatetime\u683c\u5f0f'''\n        return datetime.utcfromtimestamp(timestamp)\n\n    def last_business_day(self, date: datetime = None):\n        '''\u53d6\u5f97\u6700\u8fd1\u4e00\u500b\u4ea4\u6613\u65e5\uff0c\u9047\u5047\u65e5, \u9023\u5047, or\u88dc\u73ed\u65e5\u5247\u5f80\u524d\u63a8\u7b97'''\n\n        if not date:\n            date = TODAY_STR\n\n        d = 1\n        while True:\n            day = pd.to_datetime(date) - timedelta(days=d)\n            if day not in holidays and day.weekday() not in [5, 6]:\n                return day\n\n            d += 1\n\n    def GetDueMonth(self, sourcedate: datetime, months: int = 1):\n        '''\u63a8\u7b97\u4ea4\u5272\u6708\u4efd\uff0c\u5728\u4ea4\u5272\u65e5\u4e4b\u524d\u7684\u65e5\u671f\uff0c\u4ea4\u5272\u6708\u70ba\u7576\u6708\uff0c\u4ea4\u5272\u65e5\u4e4b\u5f8c\u70ba\u6b21\u6708'''\n\n        dueday = self.DueDays[(sourcedate.year, sourcedate.month)]\n        if pd.to_datetime(sourcedate) < dueday:\n            return str(sourcedate.year) + str(sourcedate.month).zfill(2)\n\n        month = sourcedate.month - 1 + months\n        year = sourcedate.year + month // 12\n        month = month % 12 + 1\n        return str(year) + str(month).zfill(2)\n\n    def CountDown(self, target: Union[int, datetime]):\n        '''\u5012\u6578\u8a08\u6642'''\n\n        if isinstance(target, int):\n            N = target\n        else:\n            now = datetime.now()\n            N = int((target - now).total_seconds())\n\n        for i in range(N, 0, -1):\n            print(\n                f\"Time remaining: {int(i/60)}min {i % 60}s\", end=\"\\r\", flush=True)\n            time.sleep(1)\n\n        print(\"Time remaining: 0min 0s\", end=\"\\r\", flush=True)", "\nclass TimeTool:\n\n    DueDays = {\n        (d.year, d.month): d for d in pd.date_range('2001-01-01', '2030-12-31', freq='WOM-3WED')}\n\n    def datetime_to_str(self, date: datetime):\n        '''\u5c07datetime\u6642\u9593\u8f49\u70ba\u5b57\u4e32, \u8f38\u51fa\u683c\u5f0f:YYYY-MM-DD'''\n        return date.strftime(\"%Y-%m-%d\")\n\n    def str_to_datetime(self, date: str):\n        '''\u5c07\u5b57\u4e32\u6642\u9593\u8f49\u70badatetime, \u8f38\u5165\u683c\u5f0f:YYYY-MM-DD'''\n        return datetime.strptime(date, \"%Y-%m-%d\")\n\n    def now_str(self):\n        '''\u53d6\u5f97\u7576\u4e0b\u6642\u9593\u6233\u7684\u5b57\u4e32\u683c\u5f0f'''\n        return datetime.now().strftime('%Y-%m-%d %a %H:%M:%S.%f')\n\n    def now_for_log(self):\n        return f\"\u3010{self.now_str()}\u3011\"\n\n    def _strf_timedelta(self, date: Union[str, datetime], delta: int):\n        '''\u8a08\u7b97\u524dN\u65e5\u7684\u65e5\u671f(str)'''\n\n        if isinstance(date, str):\n            date = self.str_to_datetime(date)\n\n        return self.datetime_to_str(date - timedelta(days=delta))\n\n    def get_buyday(self, day: datetime):\n        '''\u8a08\u7b97\u9032\u5834\u65e5'''\n        n = self.nday_diff(day) + 1\n        return self._strf_timedelta(day, n)\n\n    def nday_diff(self, date: datetime):\n        '''\n        \u9047\u5047\u65e5\u7684\u65e5\u6578\u5224\u65b7\n        \u82e5\u4eca\u65e5\u70ba\u661f\u671f\u4e00, \u5f80\u524d\u63a8\u7b972\u5929\n        \u82e5\u4eca\u65e5\u70ba\u661f\u671f\u5929, \u5f80\u524d\u63a8\u7b971\u5929\n        \u5176\u9918\u65e5\u5b50\u53ea\u8981\u524d\u4e00\u5929\u70ba\u4ea4\u6613\u65e5\u5247\u4e0d\u9808\u5f80\u524d\u63a8\u7b97\n        '''\n        if (date.weekday() == 0):\n            return 2\n        elif (date.weekday() == 6):\n            return 1\n        return 0\n\n    def date_diff(self, day1: Union[str, datetime], day2: Union[str, datetime]):\n        '''\u8a08\u7b97\u5169\u500b\u65e5\u671f\u4e4b\u9593\u7684\u5929\u6578'''\n        if isinstance(day1, str):\n            day1 = pd.to_datetime(day1)\n\n        if isinstance(day2, str):\n            day2 = pd.to_datetime(day2)\n\n        return (day1 - day2).days\n\n    def is_pass_time(self, time_target: Union[str, datetime]):\n        '''\u6aa2\u67e5\u7576\u4e0b\u6642\u9593\u662f\u5426\u5df2\u904e\u60f3\u6aa2\u67e5\u7684\u76ee\u6a19\u6642\u9593'''\n        if isinstance(time_target, str):\n            time_target = pd.to_datetime(time_target)\n\n        return datetime.now() >= time_target\n\n    def count_n_kbars(self, start: datetime, end: datetime, scale: int):\n        '''\n        \u8a08\u7b97K\u68d2\u6578\u91cf\n        scale\u55ae\u4f4d: min\n        '''\n        # TODO: \u6263\u9664\u570b\u5b9a\u5047\u65e5\u4e0d\u958b\u76e4 & \u6536\u76e4\u671f\u9593\n\n        if isinstance(start, str):\n            start = pd.to_datetime(start)\n\n        if isinstance(end, str):\n            end = pd.to_datetime(end)\n\n        m1 = start.minute - (start.minute % scale)\n        start = start.replace(minute=m1, second=0, microsecond=0)\n\n        m2 = end.minute - (end.minute % scale)\n        end = end.replace(minute=m2, second=0, microsecond=0)\n\n        n_kbar = (end - start).total_seconds()/60/scale\n\n        if start.weekday() == 4 and end.weekday() == 0:\n            n_kbar -= 1440*2/scale\n\n        return n_kbar\n\n    def convert_date_format(self, x: str):\n        '''\u8f49\u63db\u6c11\u570b\u683c\u5f0f\u70ba\u897f\u5143\u683c\u5f0f'''\n\n        x = re.findall('\\d+', x)\n        year = int(x[0])\n        if year < 1911:\n            x[0] = str(year + 1911)\n        return '-'.join(x)\n\n    def date_2_mktime(self, date: str):\n        '''\u5c07\u65e5\u671f\u8f49\u70ba\u6d6e\u9ede\u6578\u683c\u5f0f'''\n\n        date = date.replace('-', '').replace('/', '')\n        date = date.replace(' ', '').replace(':', '')\n        date = datetime(int(date[:4]), int(date[4:6]), int(date[6:8]), 8)\n        return int(time.mktime(date.timetuple()))\n\n    def utcfromtimestamp_(self, timestamp):\n        '''\u5c07\u6d6e\u9ede\u683c\u5f0f\u6642\u9593\u6233\u8f49\u70badatetime\u683c\u5f0f'''\n        return datetime.utcfromtimestamp(timestamp)\n\n    def last_business_day(self, date: datetime = None):\n        '''\u53d6\u5f97\u6700\u8fd1\u4e00\u500b\u4ea4\u6613\u65e5\uff0c\u9047\u5047\u65e5, \u9023\u5047, or\u88dc\u73ed\u65e5\u5247\u5f80\u524d\u63a8\u7b97'''\n\n        if not date:\n            date = TODAY_STR\n\n        d = 1\n        while True:\n            day = pd.to_datetime(date) - timedelta(days=d)\n            if day not in holidays and day.weekday() not in [5, 6]:\n                return day\n\n            d += 1\n\n    def GetDueMonth(self, sourcedate: datetime, months: int = 1):\n        '''\u63a8\u7b97\u4ea4\u5272\u6708\u4efd\uff0c\u5728\u4ea4\u5272\u65e5\u4e4b\u524d\u7684\u65e5\u671f\uff0c\u4ea4\u5272\u6708\u70ba\u7576\u6708\uff0c\u4ea4\u5272\u65e5\u4e4b\u5f8c\u70ba\u6b21\u6708'''\n\n        dueday = self.DueDays[(sourcedate.year, sourcedate.month)]\n        if pd.to_datetime(sourcedate) < dueday:\n            return str(sourcedate.year) + str(sourcedate.month).zfill(2)\n\n        month = sourcedate.month - 1 + months\n        year = sourcedate.year + month // 12\n        month = month % 12 + 1\n        return str(year) + str(month).zfill(2)\n\n    def CountDown(self, target: Union[int, datetime]):\n        '''\u5012\u6578\u8a08\u6642'''\n\n        if isinstance(target, int):\n            N = target\n        else:\n            now = datetime.now()\n            N = int((target - now).total_seconds())\n\n        for i in range(N, 0, -1):\n            print(\n                f\"Time remaining: {int(i/60)}min {i % 60}s\", end=\"\\r\", flush=True)\n            time.sleep(1)\n\n        print(\"Time remaining: 0min 0s\", end=\"\\r\", flush=True)", ""]}
{"filename": "trader/utils/__init__.py", "chunked_list": ["import queue\nimport logging\nimport numpy as np\n\nfrom ..config import API\n\n\ndef reduce_mem_usage(df, verbose=True):\n    numerics = ['int16', 'int32', 'int64', 'float16', 'float32', 'float64']\n    start_mem = df.memory_usage().sum() / 1024**2\n    for col in df.columns:\n        col_type = df[col].dtypes\n        if col_type in numerics:\n            c_min = df[col].min()\n            c_max = df[col].max()\n            if str(col_type)[:3] == 'int':\n                if c_min > np.iinfo(np.int8).min and c_max < np.iinfo(np.int8).max:\n                    df[col] = df[col].astype(np.int8)\n                elif c_min > np.iinfo(np.int16).min and c_max < np.iinfo(np.int16).max:\n                    df[col] = df[col].astype(np.int16)\n                elif c_min > np.iinfo(np.int32).min and c_max < np.iinfo(np.int32).max:\n                    df[col] = df[col].astype(np.int32)\n                elif c_min > np.iinfo(np.int64).min and c_max < np.iinfo(np.int64).max:\n                    df[col] = df[col].astype(np.int64)\n            else:\n                if c_min > np.finfo(np.float16).min and c_max < np.finfo(np.float16).max:\n                    df[col] = df[col].astype(np.float16)\n                elif c_min > np.finfo(np.float32).min and c_max < np.finfo(np.float32).max:\n                    df[col] = df[col].astype(np.float32)\n                else:\n                    df[col] = df[col].astype(np.float64)\n    end_mem = df.memory_usage().sum() / 1024**2\n    if verbose:\n        print('Mem. usage decreased to {:5.2f} Mb ({:.1f}% reduction)'.format(\n            end_mem, 100 * (start_mem - end_mem) / start_mem))\n    return df", "\n\ndef progress_bar(N, i, status=''):\n    n = i+1\n    progress = f\"\\r{status} |{'\u2588'*int(n*50/N)}{' '*(50-int(n*50/N))} | {n}/{N} ({round(n/N*100, 2)}%)\"\n    print(progress, end='')\n\n\ndef create_queue(target_list, crawled_list=[]):\n    '''put candidate companies not crawled into queue'''\n    logging.info(\"Put targets in queue...\")\n    q = queue.Queue(0)\n\n    target_list = list(set(target_list)-set(crawled_list))\n    N = len(target_list)\n\n    for i, company in enumerate(target_list):\n        q.put(company)\n        progress_bar(N, i)\n\n    logging.info(f\"Targets in queue: {q.qsize()}\")\n    return (q)", "def create_queue(target_list, crawled_list=[]):\n    '''put candidate companies not crawled into queue'''\n    logging.info(\"Put targets in queue...\")\n    q = queue.Queue(0)\n\n    target_list = list(set(target_list)-set(crawled_list))\n    N = len(target_list)\n\n    for i, company in enumerate(target_list):\n        q.put(company)\n        progress_bar(N, i)\n\n    logging.info(f\"Targets in queue: {q.qsize()}\")\n    return (q)", "\n\ndef get_contract(target: str):\n    if target[:3] in API.Contracts.Indexs.__dict__:\n        return API.Contracts.Indexs[target[:3]][target]\n    elif target[:3] in API.Contracts.Futures.__dict__:\n        return API.Contracts.Futures[target[:3]][target]\n    elif target[:3] in API.Contracts.Options.__dict__:\n        return API.Contracts.Options[target[:3]][target]\n    return API.Contracts.Stocks[target]", "\n"]}
{"filename": "trader/utils/watchlist.py", "chunked_list": ["import pandas as pd\nfrom datetime import datetime\nfrom collections import namedtuple\n\nfrom ..config import PATH\nfrom . import get_contract\nfrom .time import TimeTool\nfrom .file import FileHandler\nfrom .database import db\nfrom .database.tables import Watchlist", "from .database import db\nfrom .database.tables import Watchlist\n\n\nclass WatchListTool(TimeTool, FileHandler):\n\n    def __init__(self, account_name):\n        self.account_name = account_name\n        self.MatchAccount = Watchlist.account == self.account_name\n        self.watchlist_file = f'watchlist_{account_name}'\n        self.watchlist = self.get_watchlist()\n\n    def get_watchlist(self):\n        \"\"\"Load watchlist data\"\"\"\n        if db.HAS_DB:\n            df = db.query(Watchlist, Watchlist.account == self.account_name)\n            return df\n\n        df = self.read_table(\n            filename=f'{PATH}/stock_pool/{self.watchlist_file}.csv',\n            df_default=pd.DataFrame(columns=[\n                'account', 'market', 'code', 'buyday',\n                'bsh', 'position', 'strategy'\n            ])\n        )\n        df.code = df.code.astype(str)\n        df.buyday = pd.to_datetime(df.buyday.astype(str))\n        df.position = df.position.fillna(100)\n        df.strategy = df.strategy.fillna('Unknown')\n        return df\n\n    def _append_watchlist(self, market: str, orderinfo: namedtuple, quotes: dict, strategy_pool: dict = None):\n        '''Add new stock data to watchlist'''\n        if isinstance(orderinfo, str):\n            # Manual trading\n            target = orderinfo\n            position = 100\n            cost_price = quotes\n            check_quantity = True\n        else:\n            # Auto trading\n            target = orderinfo.target\n            position = abs(orderinfo.pos_target)\n            cost_price = quotes.NowTargets[target]['price']\n            check_quantity = orderinfo.quantity != 0\n\n        if target not in self.watchlist.code.values and check_quantity:\n            data = {\n                'account': self.account_name,\n                'market': market,\n                'code': target,\n                'buyday': datetime.now(),\n                'bsh': cost_price,\n                'position': position,\n                'strategy': strategy_pool[target] if strategy_pool and target in strategy_pool else 'unknown'\n            }\n            self.watchlist = pd.concat([self.watchlist, pd.DataFrame([data])])\n\n            if db.HAS_DB:\n                db.add_data(Watchlist, **data)\n\n    def init_watchlist(self, stocks: pd.DataFrame, strategy_pool: dict):\n        stocks = stocks[~stocks.code.isin(self.watchlist.code)].code.values\n\n        # Add stocks to watchlist if it is empty.\n        if not self.watchlist.shape[0] and stocks.shape[0]:\n            for stock in stocks:\n                cost_price = get_contract(stock).reference\n                self._append_watchlist(\n                    'Stocks', stock, cost_price, strategy_pool)\n\n    def update_watchlist(self, codeList: list):\n        '''Update watchlist data when trading time is closed'''\n\n        # Update watchlist position if there's any stock both exists\n        # in stock account and watchlist but position <= 0.\n        condi1 = self.watchlist.code.isin(codeList)\n        condi2 = (self.watchlist.position <= 0)\n        self.watchlist.loc[~condi1 | condi2, 'position'] = 0\n        self.watchlist.loc[condi1 & condi2, 'position'] = 100\n\n        if db.HAS_DB:\n            code1 = self.watchlist[~condi1 | condi2].code.values\n            condition = Watchlist.code.in_(code1), self.MatchAccount\n            db.update(Watchlist, {'position': 0}, *condition)\n\n            code2 = self.watchlist[condi1 & condi2].code.values\n            condition = Watchlist.code.in_(code2), self.MatchAccount\n            db.update(Watchlist, {'position': 100}, condition)\n\n        self.remove_from_watchlist()\n\n    def remove_from_watchlist(self):\n        '''Delete Watchlist data where position <= 0.'''\n\n        self.watchlist = self.watchlist[self.watchlist.position > 0]\n        if db.HAS_DB:\n            db.delete(Watchlist, Watchlist.position <= 0, self.MatchAccount)\n\n    def update_watchlist_position(self, order: namedtuple, quotes: dict, strategy_pool: dict = None):\n        target = order.target\n        position = order.pos_target\n\n        if target in self.watchlist.code.values:\n            condition = self.watchlist.code == target\n            if order.action_type == 'Open':\n                self.watchlist.loc[condition, 'position'] += position\n            else:\n                self.watchlist.loc[condition, 'position'] -= position\n\n            if db.HAS_DB and condition.sum():\n                position = self.watchlist.loc[condition, 'position'].values[0]\n                condition = Watchlist.code.in_([target]), self.MatchAccount\n                db.update(Watchlist, {'position': position}, *condition)\n\n            self.remove_from_watchlist()\n        else:\n            market = 'Stocks' if not order.octype else 'Futures'\n            self._append_watchlist(market, order, quotes, strategy_pool)\n\n    def save_watchlist(self, df: pd.DataFrame):\n        if db.HAS_DB:\n            codes = db.query(Watchlist.code, self.MatchAccount).code.values\n            tb = df[~df.code.isin(codes)]\n            db.dataframe_to_DB(tb, Watchlist)\n        else:\n            self.save_table(\n                df=df,\n                filename=f'{PATH}/stock_pool/{self.watchlist_file}.csv',\n                saveEmpty=True\n            )", ""]}
{"filename": "trader/utils/orders.py", "chunked_list": ["import time\nimport logging\nimport pandas as pd\nfrom collections import namedtuple\n\nfrom ..config import API, PATH\nfrom .file import FileHandler\nfrom .database import db\nfrom .database.tables import TradingStatement\n", "from .database.tables import TradingStatement\n\n\nclass OrderTool(FileHandler):\n    OrderInfo = namedtuple(\n        typename=\"OrderInfo\",\n        field_names=[\n            'action_type',\n            'action', 'target', 'quantity',\n            'order_cond', 'octype', 'pos_target',\n            'pos_balance', 'daytrade_short', 'reason'\n        ],\n        defaults=['', '', '', 0, '', '', 0, 0, False, '']\n    )\n    MsgOrder = namedtuple(\n        typename='MsgOrder',\n        field_names=['operation', 'order', 'status', 'contract']\n    )\n    OrderTable = pd.DataFrame(columns=[\n        'Time', 'market', 'code', 'action',\n        'price', 'quantity', 'amount',\n        'order_cond', 'order_lot', 'leverage',\n        'op_type', 'account_id', 'msg',\n\n    ])\n\n    def get_sell_quantity(self, content: namedtuple, market: str = 'Stocks'):\n        '''\u6839\u64da\u5eab\u5b58, \u5269\u9918\u90e8\u4f4d\u6bd4\u4f8b, \u8ce3\u51fa\u6bd4\u4f8b\uff0c\u53cd\u63a8\u8ce3\u51fa\u91cf(\u5f35)'''\n        if market == 'Stocks':\n            q_before = int(content.quantity/1000)\n            condition = content.pos_balance > 0 and content.quantity >= 1000\n        else:\n            q_before = content.quantity\n            condition = content.pos_balance > 0 and content.quantity != 0\n\n        if condition:\n            quantity = int(q_before/content.pos_balance *\n                           abs(content.pos_target))\n            quantity = 1000*max(min(quantity, q_before), 1)\n            return max(round(quantity/1000), 1)\n        return q_before\n\n    def check_order_status(self, order_result):\n        '''\u78ba\u8a8d\u59d4\u8a17\u72c0\u614b'''\n        time.sleep(0.1)\n        API.update_status(API.stock_account)\n        status = order_result.status.status\n        if status not in ['PreSubmitted', 'Filled']:\n            logging.warning('order not submitted/filled')\n\n    def appendOrder(self, order_data: dict):\n        '''Add new order data to OrderTable'''\n        self.OrderTable = pd.concat([\n            self.OrderTable,\n            pd.DataFrame([order_data])\n        ])\n\n    def deleteOrder(self, code: str):\n        '''Delete order data from OrderTable'''\n        self.OrderTable = self.OrderTable[self.OrderTable.code != code]\n\n    def checkEnoughToPlace(self, market: str, target: str):\n        '''Check if current placed amount is under target limit.'''\n        df = self.OrderTable[self.OrderTable.market == market]\n        return df.amount.sum() < target\n\n    def filterOrderTable(self, market: str):\n        '''Filter OrderTable by market'''\n        return self.OrderTable[self.OrderTable.market == market].copy()\n\n    def output_statement(self, filename: str = ''):\n        '''Export trading statement'''\n\n        if db.HAS_DB:\n            self.OrderTable.order_cond.fillna('', inplace=True)\n            self.OrderTable.order_lot.fillna('', inplace=True)\n            self.OrderTable.leverage.fillna(-1, inplace=True)\n            self.OrderTable.op_type.fillna('', inplace=True)\n            db.dataframe_to_DB(self.OrderTable, TradingStatement)\n        else:\n            statement = self.read_and_concat(filename, self.OrderTable)\n            self.save_table(statement, filename)\n\n    def read_statement(self, account: str = ''):\n        '''Import trading statement'''\n\n        if db.HAS_DB:\n            df = db.query(\n                TradingStatement,\n                TradingStatement.account_id == account\n            )\n        else:\n            filename = f\"{PATH}/stock_pool/statement_{account.split('-')[-1]}.csv\"\n            df = self.read_table(filename, df_default=self.OrderTable)\n            df = df[df.account_id == account]\n            df = df.astype({\n                'price': float,\n                'quantity': float,\n                'amount': float,\n                'leverage': float\n            })\n            df.Time = pd.to_datetime(df.Time)\n\n        df = df.drop_duplicates()\n        return df", ""]}
{"filename": "trader/utils/file.py", "chunked_list": ["import os\nimport numpy as np\nimport pandas as pd\nfrom io import BytesIO\nfrom zipfile import ZipFile\nfrom datetime import datetime\n\nfrom . import progress_bar\nfrom ..config import PATH, TODAY\n", "from ..config import PATH, TODAY\n\n\nclass FileHandler:\n    def create_folder(self, path):\n        if not os.path.exists(path):\n            os.makedirs(path)\n\n    def listdir(self, dir_path: str, pattern: str = '', filter_out: list = ['desktop.ini']):\n        if pattern:\n            result = [f for f in os.listdir(dir_path) if pattern in f]\n        else:\n            result = os.listdir(dir_path)\n        return [f for f in result if f not in filter_out]\n\n    def list_files(self, dir_path: str, pattern: str = '', filter_out: list = ['desktop.ini']):\n        file_list = []\n        for root, _, files in os.walk(dir_path):\n            for file in files:\n                if pattern in file and file not in filter_out:\n                    file_list.append(os.path.join(root, file))\n        return file_list\n\n    def is_in_dir(self, filename: str, dir_path: str):\n        '''Check if a filename is in dir_path.'''\n        return filename in os.listdir(dir_path)\n\n    def rpt_2_df(self, file: str):\n        '''Conver .rpt file to Pandas DataFrame'''\n\n        f = file.readlines()\n        f = [\n            t.decode('big5').rstrip('\\r\\n') if isinstance(t, bytes) else t.rstrip('\\n') for t in f]\n        f = [t.replace(' ', '').split(',') for t in f]\n        return pd.DataFrame(f[1:], columns=f[0])\n\n    def unzip_file(self, filename: str, filters: list = [], filepath=''):\n        '''\u89e3\u58d3\u7e2e\u6a94\u6848\u4e26\u532f\u51fa'''\n\n        if isinstance(filename, BytesIO):\n            folders = ZipFile(filename)\n        else:\n            folders = ZipFile(f'{filename}.zip')\n        names = folders.namelist()\n        N = len(names)\n\n        if N > 1 and isinstance(filename, str):\n            self.create_folder(filename)\n\n        for i, folder in enumerate(names):\n            if any(f in filters for f in [folder, folder.rstrip('/'), folder[:4]]):\n                continue\n\n            if '.zip' in folder:\n                folderPath = f\"{filename}/{folder.replace('.zip', '')}\"\n                print(f\"\\n{folder.replace('.zip', '')}\")\n                self.create_folder(folderPath)\n                zfiledata = BytesIO(folders.read(folder))\n                self.unzip_file(zfiledata, filepath=folderPath)\n\n            elif '.rpt' in folder:\n                file = BytesIO(folders.read(folder))\n                file = self.rpt_2_df(file)\n                folderPath = filepath if filepath else (filename if N > 1 else '.')\n                self.save_table(file, f\"{folderPath}/{folder.replace('.rpt', '.csv')}\")\n                progress_bar(N, i)\n\n    def remove_files(self, dirpath: str, files: list = None, pattern: str = ''):\n        if not files:\n            files = self.listdir(dirpath, pattern=pattern)\n\n        for f in files:\n            os.remove(f'{dirpath}/{f}')\n\n    def save_table(self, df: pd.DataFrame, filename: str, saveEmpty=False):\n        if df.shape[0] or saveEmpty:\n            if '.csv' in filename:\n                df.to_csv(filename, index=False, encoding='utf-8-sig')\n            elif '.xlsx' in filename:\n                df.to_excel(filename, index=False, encoding='utf-8-sig')\n            else:\n                df.to_pickle(filename)\n\n    def read_table(self, filename: str, df_default: pd.DataFrame = None):\n        if os.path.exists(filename):\n            if '.pkl' in filename:\n                tb = pd.read_pickle(filename)\n            elif '.xlsx' in filename:\n                tb = pd.read_excel(filename)\n            else:\n                try:\n                    tb = pd.read_csv(filename)\n                except:\n                    tb = pd.read_csv(\n                        filename, low_memory=False, encoding='big5')\n        elif isinstance(df_default, pd.DataFrame):\n            tb = df_default\n        else:\n            tb = pd.DataFrame()\n\n        return tb\n\n    def read_and_concat(self, filename: str, df: pd.DataFrame):\n        tb = self.read_table(filename)\n        tb = pd.concat([tb, df]).reset_index(drop=True)\n        return tb\n\n    def read_tables_in_folder(self, dir_path: str, pattern: str = None, **kwargs):\n        files = self.listdir(dir_path, pattern=pattern)\n\n        # filter files by time interval\n        start = kwargs.get('start')\n        if start:\n            if not isinstance(start, pd.Timestamp):\n                start = pd.to_datetime(start)\n            y1, m1 = start.year, start.month\n            files = [\n                f for f in files if int(f[:4]) >= y1 and int(f[5:7]) >= m1]\n\n        end = kwargs.get('end')\n        if end:\n            if not isinstance(end, pd.Timestamp):\n                end = pd.to_datetime(end)\n            y2, m2 = end.year, end.month\n            files = [\n                f for f in files if int(f[:4]) <= y2 and int(f[5:7]) <= m2]\n\n        # read tables\n        N = len(files)\n        if N:\n            df = np.array([None]*N)\n            for i, f in enumerate(files):\n                df[i] = self.read_table(f'{dir_path}/{f}')\n                progress_bar(N, i, status=f'[{f}]')\n\n            df = pd.concat(df).reset_index(drop=True)\n            return df\n        return pd.DataFrame()\n\n    def read_tick_data(self, market: str, **kwargs):\n        '''\n        \u5408\u4f75\u9010\u7b46\u4ea4\u6613\u660e\u7d30\u8868\u3002\u4ee5year\u70ba\u4e3b\uff0c\u5408\u4f75\u8a72\u5e74\u5ea6\u7684\u8cc7\u6599\uff0c\u53ef\u53e6\u5916\u6307\u5b9a\u8981\u5408\u4f75\u7684\u5340\u9593\n        '''\n\n        dir_path = f'{PATH}/ticks/{market.lower()}'\n        files = self.list_files(dir_path)\n\n        # Filter files by time interval\n        start = kwargs.get('start')\n        if start:\n            if not isinstance(start, pd.Timestamp):\n                start = pd.to_datetime(start)\n        else:\n            start = pd.to_datetime('1970-01-01')\n\n        end = kwargs.get('end')\n        if end:\n            if not isinstance(end, pd.Timestamp):\n                end = pd.to_datetime(end)\n        else:\n            end = TODAY\n\n        df = []\n        for f in files:\n            date = f.split('\\\\')[-1][:-4].split('_')[1:]\n            date = datetime(*(int(d) for d in date))\n            if start <= date <= end:\n                df.append(f)\n\n        N = len(df)\n        for i, f in enumerate(df):\n            df[i] = self.read_table(f)\n            status = f.split('\\\\')[-1]\n            progress_bar(N, i, status=f'[{status}]')\n        df = pd.concat(df)\n        return df", ""]}
{"filename": "trader/utils/kbar.py", "chunked_list": ["import re\nimport logging\nimport pandas as pd\nfrom typing import List, Dict\nfrom datetime import datetime, timedelta\n\nfrom ..config import API, PATH, TODAY, TODAY_STR, TimeStartStock, TimeEndStock\nfrom ..config import KbarFeatures\nfrom ..indicators.signals import TechnicalSignals\nfrom . import get_contract", "from ..indicators.signals import TechnicalSignals\nfrom . import get_contract\nfrom .time import TimeTool\nfrom .file import FileHandler\ntry:\n    from ..scripts.features import KBarFeatureTool\nexcept:\n    logging.warning('Cannot import KBar Scripts from package.')\n    KBarFeatureTool = None\n", "\n\nclass KBarTool(TechnicalSignals, TimeTool, FileHandler):\n    def __init__(self, kbar_start_day=''):\n        self.set_kbar_scripts(KBarFeatureTool)\n        self.daysdata = self.__set_daysdata(kbar_start_day)\n        self.maps = {\n            'name': 'first',\n            'Open': 'first',\n            'High': 'max',\n            'Low': 'min',\n            'Close': 'last',\n            'Volume': 'sum',\n            'Amount': 'sum'\n        }\n        self.kbar_columns = [\n            'name', 'Time',\n            'Open', 'High', 'Low', 'Close', 'Volume', 'Amount'\n        ]\n        self.featureFuncs = {\n            '1T': self.add_K1min_feature,\n            '2T': self.add_K2min_feature,\n            '5T': self.add_K5min_feature,\n            '15T': self.add_K15min_feature,\n            '30T': self.add_K30min_feature,\n            '60T': self.add_K60min_feature,\n            '1D': self.add_KDay_feature,\n        }\n        self.KBars = {\n            freq: pd.DataFrame(columns=self.kbar_columns) for freq in self.featureFuncs\n        }\n\n    def __set_daysdata(self, kbar_start_day):\n        '''\n        \u8a2d\u5b9a\u89c0\u5bdfK\u68d2\u6578(N\u500b\u4ea4\u6613\u65e5)\n        \u82e5\u6709\u8a2d\u5b9a\u6700\u8fd1\u5d29\u76e4\u65e5, \u5247\u89c0\u5bdfK\u68d2\u6578 = \u4e0a\u6b21\u5d29\u76e4\u65e5\u958b\u59cb\u7b97N\u500b\u4ea4\u6613\u65e5\n        \u82e5\u6c92\u6709\u8a2d\u6700\u8fd1\u5d29\u76e4\u65e5, \u5247\u89c0\u5bdfK\u68d2\u6578 = 35\n        \u53c3\u6578 - kbar_start_day: \u89c0\u5bdf\u8d77\u59cb\u65e5\uff0c\u683c\u5f0f\u70ba yyyy-mm-dd\n        '''\n\n        if not kbar_start_day or TODAY < kbar_start_day:\n            return 35\n\n        return max((TODAY - kbar_start_day).days, 35)\n\n    def add_KDay_feature(self, df: pd.DataFrame):\n        return df\n\n    def add_K60min_feature(self, df: pd.DataFrame):\n        return df\n\n    def add_K30min_feature(self, df: pd.DataFrame):\n        return df\n\n    def add_K15min_feature(self, df: pd.DataFrame):\n        return df\n\n    def add_K5min_feature(self, df: pd.DataFrame):\n        return df\n\n    def add_K2min_feature(self, df: pd.DataFrame):\n        return df\n\n    def add_K1min_feature(self, df: pd.DataFrame):\n        return df\n\n    def on_set_feature_function(self, kbar_scripts, attrName):\n        def wrapper(func):\n            if hasattr(kbar_scripts, attrName):\n                setattr(self, attrName, func)\n            return func\n        return wrapper\n\n    def set_kbar_scripts(self, kbar_scripts: object = None):\n        '''\u8a2d\u5b9aK\u7dda\u7279\u5fb5\u8173\u672c'''\n\n        if kbar_scripts:\n            kbar_scripts = kbar_scripts()\n\n            @self.on_set_feature_function(kbar_scripts, 'add_K1min_feature')\n            def _add_K1min_feature(df):\n                return kbar_scripts.add_K1min_feature(df)\n\n            @self.on_set_feature_function(kbar_scripts, 'add_K2min_feature')\n            def _add_K2min_feature(df):\n                return kbar_scripts.add_K2min_feature(df)\n\n            @self.on_set_feature_function(kbar_scripts, 'add_K5min_feature')\n            def _add_K5min_feature(df):\n                return kbar_scripts.add_K5min_feature(df)\n\n            @self.on_set_feature_function(kbar_scripts, 'add_K15min_feature')\n            def _add_K15min_feature(df):\n                return kbar_scripts.add_K15min_feature(df)\n\n            @self.on_set_feature_function(kbar_scripts, 'add_K30min_feature')\n            def _add_K30min_feature(df):\n                return kbar_scripts.add_K30min_feature(df)\n\n            @self.on_set_feature_function(kbar_scripts, 'add_K60min_feature')\n            def _add_K60min_feature(df):\n                return kbar_scripts.add_K60min_feature(df)\n\n            @self.on_set_feature_function(kbar_scripts, 'add_KDay_feature')\n            def _add_KDay_feature(df):\n                return kbar_scripts.add_KDay_feature(df)\n\n    def _scale_converter(self, scale: str):\n        '''Convert scale format from str to int'''\n        return int(re.findall('\\d+', scale)[0])\n\n    def tbKBar(self, stockid: str, start: str, end: str = None):\n        '''\u53d6\u5f97k\u68d2\u8cc7\u6599'''\n\n        if not end:\n            end = TODAY_STR\n\n        contract = get_contract(stockid)\n        # TODO: fix AttributeError\n        try:\n            kbars = API.kbars(contract, start=start, end=end, timeout=60000)\n        except AttributeError:\n            logging.exception(f'tbKBar({stockid}) Catch an Exception:')\n            kbars = {'ts': []}\n\n        tb = pd.DataFrame({**kbars})\n        tb.ts = pd.to_datetime(tb.ts)\n        tb.insert(0, 'name', stockid)\n        tb.name = tb.name.replace('OTC101', '101').replace('TSE001', '001')\n        tb = tb.rename(columns={'ts': 'Time'})\n        return tb\n\n    def history_kbars(self, stockids: List[str], daysdata: int = 0):\n        '''Get history kbar data'''\n\n        now = datetime.now()\n        ndays = daysdata if daysdata else self.daysdata\n        for stockid in stockids:\n            tb = self.tbKBar(stockid, self._strf_timedelta(TODAY, ndays))\n            for scale in self.featureFuncs:\n                kbar = self.convert_kbar(tb, scale)\n                if scale == '1D':\n                    kbar = kbar[kbar.Time.dt.date.astype(str) != TODAY_STR]\n                else:\n                    scale_ = self._scale_converter(scale)\n                    n = self.count_n_kbars(TimeStartStock, now, scale_)\n                    time_ = TimeStartStock + timedelta(minutes=scale_*n)\n                    kbar = kbar[kbar.Time < time_]\n\n                self.KBars[scale] = self.concatKBars(self.KBars[scale], kbar)\n\n        for scale, kbar in self.KBars.items():\n            kbar = self.featureFuncs[scale](kbar)\n            self.KBars[scale] = kbar\n\n    def convert_kbar(self, tb: pd.DataFrame, scale='60T'):\n        '''\u5c071\u5206K\u8f49\u63db\u6210\u5176\u4ed6\u9031\u671fK\u7dda\u8cc7\u6599'''\n        if tb.shape[0]:\n            return (\n                tb.set_index('Time')\n                .groupby('name')\n                .resample(scale, closed='left', label='left')\n                .apply(self.maps)\n                .reset_index(level='Time')\n                .reset_index(drop=True)\n                .dropna()\n            )\n        return tb\n\n    def revert_dividend_price(self, df: pd.DataFrame, dividends: Dict[str, float]):\n        '''\u9084\u539f\u9664\u6b0a\u606f\u80a1\u50f9'''\n\n        if df.shape[0]:\n            has_dividend = df.name.isin(dividends.keys())\n            if has_dividend.sum():\n                _dividends = df[has_dividend].name.map(dividends)\n                for col in ['Open', 'High', 'Low', 'Close']:\n                    df.loc[has_dividend, col] += _dividends\n        return df\n\n    def tick_to_df_targets(self, q_all: dict, q_now: dict):\n        '''\u5c07\u500b\u80a1tick\u8cc7\u6599\u8f49\u70baK\u68d2'''\n\n        if not q_all and not q_now:\n            return pd.DataFrame()\n\n        if any([] in q_all[s].values() for s in q_all):\n            q_all = {s: q_all[s] for s in q_all if [] not in q_all[s].values()}\n            q_all.update(\n                {s: {k: [v] for k, v in q_now[s].items()} for s in q_now if s not in q_all})\n\n        tb = pd.DataFrame(q_all).T\n\n        if not tb.shape[1]:\n            return pd.DataFrame()\n\n        tb['Time'] = pd.to_datetime(datetime.now())\n        tb['Open'] = tb.price.apply(lambda x: x[0])\n        tb['High'] = tb.price.apply(max)\n        tb['Low'] = tb.price.apply(min)\n        tb['Close'] = tb.price.apply(lambda x: x[-1])\n        tb.volume = tb.volume.apply(sum)\n        tb['Amount'] = tb.amount.apply(lambda x: x[-1])\n        tb = tb.reset_index().rename(\n            columns={'index': 'name', 'volume': 'Volume'})\n        return tb[self.kbar_columns]\n\n    def tick_to_df_index(self, quotes: list):\n        '''\u5c07\u6307\u6578tick\u8cc7\u6599\u8f49\u70baK\u68d2'''\n\n        if not quotes:\n            return pd.DataFrame()\n\n        try:\n            tb = pd.DataFrame(quotes)\n            tb = tb.rename(columns={'Code': 'name', 'Date': 'date'})\n\n            tb['Time'] = pd.to_datetime(datetime.now())\n            tb['Open'] = tb.Close.values[0]\n            tb['High'] = tb.Close.max()\n            tb['Low'] = tb.Close.min()\n            tb['Close'] = tb.Close.values[-1]\n            tb.Volume = tb.Volume.sum()\n            tb['Amount'] = tb.Amount.sum()\n            tb = tb[self.kbar_columns]\n            return tb.drop_duplicates(['name', 'Time'])\n        except:\n            return pd.DataFrame()\n\n    def concatKBars(self, df1: pd.DataFrame, df2: pd.DataFrame):\n        '''\u5408\u4f75K\u68d2\u8cc7\u6599\u8868'''\n        return pd.concat([df1, df2]).sort_values(['name', 'Time']).reset_index(drop=True)\n\n    def updateKBars(self, scale: str):\n        '''\u6aa2\u67e5\u4e26\u66f4\u65b0K\u68d2\u8cc7\u6599\u8868'''\n\n        _scale = self._scale_converter(scale)\n        t1 = datetime.now()\n        t2 = t1 - timedelta(minutes=_scale + .5)\n        if not self.KBars[scale][self.KBars[scale].Time >= t2].shape[0]:\n            tb = self.KBars['1T'].copy()\n            tb = tb[(tb.Time >= t2) & (tb.Time < t1)]\n            if tb.shape[0]:\n                tb = self.convert_kbar(tb, scale=scale)\n\n                for col in KbarFeatures[scale]:\n                    tb[col] = None\n\n                kbar = self.concatKBars(self.KBars[scale], tb)\n                self.KBars[scale] = self.featureFuncs[scale](kbar)\n\n    def _update_K1(self, dividends: dict, quotes):\n        '''\u6bcf\u96941\u5206\u9418\u66f4\u65b01\u5206K'''\n\n        def concat_df(df):\n            if df.shape[0]:\n                self.KBars['1T'] = pd.concat(\n                    [self.KBars['1T'], df]).sort_values(['name', 'Time']).reset_index(drop=True)\n\n        if TimeStartStock <= datetime.now() <= TimeEndStock:\n            for i in quotes.AllIndex:\n                tb = self.tick_to_df_index(quotes.AllIndex[i])\n                concat_df(tb)\n\n        df = self.tick_to_df_targets(quotes.AllTargets, quotes.NowTargets)\n        df = self.revert_dividend_price(df, dividends)\n        concat_df(df)", "\n\nclass TickDataProcesser(TimeTool, FileHandler):\n    '''\u8f49\u63db\u671f\u8ca8\u9010\u7b46\u4ea4\u6613'''\n\n    def convert_daily_tick(self, date: str, scale: str):\n        ymd = date.split('-')\n        m = f'Daily_{ymd[0]}_{ymd[1]}'\n        folder = f'{PATH}/ticks/futures/{ymd[0]}/{m}'\n        df = self.read_table(f'{folder}/{m}_{ymd[2]}.csv')\n        if df.shape[0]:\n            df = self.preprocess_futures_tick(df)\n            df = self.convert_tick_2_kbar(df, scale, period='all')\n        return df\n\n    def preprocess_futures_tick(self, df, underlying='TX'):\n        df = df.rename(columns={\n            '\u5546\u54c1\u4ee3\u865f': 'name',\n            '\u6210\u4ea4\u50f9\u683c': 'Price',\n            '\u6210\u4ea4\u6578\u91cf(B+S)': 'Quantity',\n            '\u958b\u76e4\u96c6\u5408\u7af6\u50f9 ': 'Simtrade',\n            '\u8fd1\u6708\u50f9\u683c': 'PriceOld',\n            '\u9060\u6708\u50f9\u683c': 'PriceNew',\n            '\u5230\u671f\u6708\u4efd(\u9031\u5225)': 'DueMonth'\n        })\n\n        df.name = df.name.apply(lambda x: x.replace(' ', ''))\n        df.DueMonth = df.DueMonth.apply(\n            lambda x: x.replace(' ', '').split('/'))\n        df.PriceOld = df.PriceOld.replace('-', 0).astype(float)\n        df.PriceNew = df.PriceNew.replace('-', 0).astype(float)\n\n        if underlying != 'all':\n            df = df[df.name == underlying].reset_index(drop=True)\n\n        df['Time'] = pd.to_datetime(df.\u6210\u4ea4\u65e5\u671f.astype(\n            str) + df.\u6210\u4ea4\u6642\u9593.astype(str).str.zfill(6))\n        df['date'] = pd.to_datetime(df.Time.dt.date)\n        df.Simtrade = df.Simtrade.apply(lambda x: True if x == '*' else False)\n        df['DueMonthOld'] = df.DueMonth.apply(lambda x: x[0])\n        df['DueMonthNew'] = df.DueMonth.apply(lambda x: x[-1])\n        df['period'] = 2\n        df.loc[df.Time.dt.hour.isin(range(8, 14)), 'period'] = 1\n\n        # \u8655\u7406\u8de8\u6708\u59d4\u8a17\u4ea4\u6613(\u8f49\u5009)\n        # df['DueMonth'] = df['DueMonth'].apply(lambda x: x.split('/'))\n        # df.Price += df.PriceOld\n        # df = df.explode(['DueMonth'])\n\n        df = df.drop(['\u6210\u4ea4\u65e5\u671f', '\u6210\u4ea4\u6642\u9593', 'date', 'DueMonth'], axis=1)\n        return df\n\n    def convert_tick_2_kbar(self, df, scale, period='day_only'):\n        '''\u5c07\u9010\u7b46\u8cc7\u6599\u8f49\u70baK\u7dda\u8cc7\u6599\u3002period = day_only(\u65e5\u76e4), night_only(\u591c\u76e4), all(\u65e5\u76e4+\u591c\u76e4)'''\n        df['Open'] = df['High'] = df['Low'] = df['Close'] = df.Price\n        df['Volume'] = df['Quantity']/2\n        df['Amount'] = df.Close*df.Volume\n\n        due_month = pd.to_datetime(df.Time.dt.date).apply(self.GetDueMonth)\n        df = df[\n            (df.DueMonthOld == df.DueMonthNew) &\n            (df.DueMonthOld == due_month)\n        ]\n        if period == 'day_only':\n            df = df[df.period == 1]\n\n        df = KBarTool().convert_kbar(df, scale=scale)\n        return df", ""]}
{"filename": "trader/utils/cipher.py", "chunked_list": ["from cryptography.hazmat.primitives.asymmetric import padding\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives import serialization\n\n# ssh-keygen -P \"\" -t rsa -b 4096 -m pem -f sinopac\n# ssh-keygen - f sinopac.pub -e -m pem > sinopac_public_key.pem\n\n\nclass CipherTool:\n    def __init__(self, decrypt: bool = True, encrypt: bool = True, **kwargs):\n        self.DECRYPT = decrypt\n        self.ENCRYPT = encrypt\n        self.__load_keys(**kwargs)\n\n    def __load_keys(self, **kwargs):\n        key_path = kwargs['key_path'] if 'key_path' in kwargs else \"./lib/ckey\"\n        if self.ENCRYPT:\n            try:\n                with open(f\"{key_path}/sinopac_public.pem\", \"rb\") as f:\n                    self._PUBLICKEY_ = serialization.load_pem_public_key(\n                        f.read(), backend=default_backend()\n                    )\n            except FileNotFoundError:\n                print(\n                    f'FileNotFoundError: {key_path}/sinopac_public.pem. Texts will not be encrypted.')\n                self._PUBLICKEY_ = None\n\n        if self.DECRYPT:\n            try:\n                with open(f\"{key_path}/sinopac_private.pem\", \"rb\") as f:\n                    self._PRIVATEKEY_ = serialization.load_pem_private_key(\n                        f.read(), None, backend=default_backend()\n                    )\n            except FileNotFoundError:\n                print(\n                    f'FileNotFoundError: {key_path}/sinopac_private.pem. Texts will not be decrypted.')\n                self._PRIVATEKEY_ = None\n\n    def encrypt(self, msg: str):\n        '''Encrypt text messages.'''\n        if self.ENCRYPT and self._PUBLICKEY_:\n            return self._PUBLICKEY_.encrypt(\n                msg.encode(),\n                padding.OAEP(\n                    mgf=padding.MGF1(algorithm=hashes.SHA256()),\n                    algorithm=hashes.SHA256(),\n                    label=None\n                )\n            ).hex()\n\n        print(\"Can't encrypt without public key\")\n        return msg\n\n    def decrypt(self, msg: str):\n        '''Decrypt text messages.'''\n        if self.DECRYPT and self._PRIVATEKEY_:\n\n            if not isinstance(msg, bytes):\n                msg = bytes.fromhex(msg)\n\n            return self._PRIVATEKEY_.decrypt(\n                msg,\n                padding.OAEP(\n                    mgf=padding.MGF1(algorithm=hashes.SHA256()),\n                    algorithm=hashes.SHA256(),\n                    label=None\n                )\n            ).decode()\n\n        print(\"Can't decrypt without private key\")\n        return msg", "\nclass CipherTool:\n    def __init__(self, decrypt: bool = True, encrypt: bool = True, **kwargs):\n        self.DECRYPT = decrypt\n        self.ENCRYPT = encrypt\n        self.__load_keys(**kwargs)\n\n    def __load_keys(self, **kwargs):\n        key_path = kwargs['key_path'] if 'key_path' in kwargs else \"./lib/ckey\"\n        if self.ENCRYPT:\n            try:\n                with open(f\"{key_path}/sinopac_public.pem\", \"rb\") as f:\n                    self._PUBLICKEY_ = serialization.load_pem_public_key(\n                        f.read(), backend=default_backend()\n                    )\n            except FileNotFoundError:\n                print(\n                    f'FileNotFoundError: {key_path}/sinopac_public.pem. Texts will not be encrypted.')\n                self._PUBLICKEY_ = None\n\n        if self.DECRYPT:\n            try:\n                with open(f\"{key_path}/sinopac_private.pem\", \"rb\") as f:\n                    self._PRIVATEKEY_ = serialization.load_pem_private_key(\n                        f.read(), None, backend=default_backend()\n                    )\n            except FileNotFoundError:\n                print(\n                    f'FileNotFoundError: {key_path}/sinopac_private.pem. Texts will not be decrypted.')\n                self._PRIVATEKEY_ = None\n\n    def encrypt(self, msg: str):\n        '''Encrypt text messages.'''\n        if self.ENCRYPT and self._PUBLICKEY_:\n            return self._PUBLICKEY_.encrypt(\n                msg.encode(),\n                padding.OAEP(\n                    mgf=padding.MGF1(algorithm=hashes.SHA256()),\n                    algorithm=hashes.SHA256(),\n                    label=None\n                )\n            ).hex()\n\n        print(\"Can't encrypt without public key\")\n        return msg\n\n    def decrypt(self, msg: str):\n        '''Decrypt text messages.'''\n        if self.DECRYPT and self._PRIVATEKEY_:\n\n            if not isinstance(msg, bytes):\n                msg = bytes.fromhex(msg)\n\n            return self._PRIVATEKEY_.decrypt(\n                msg,\n                padding.OAEP(\n                    mgf=padding.MGF1(algorithm=hashes.SHA256()),\n                    algorithm=hashes.SHA256(),\n                    label=None\n                )\n            ).decode()\n\n        print(\"Can't decrypt without private key\")\n        return msg", "\n\nif __name__ == \"__main__\":\n\n    ct = CipherTool()\n    msg = 'Hello World'\n    encrypted = ct.encrypt(msg)\n    print(encrypted)\n", ""]}
{"filename": "trader/utils/strategy.py", "chunked_list": ["import logging\nimport pandas as pd\nfrom datetime import datetime\nfrom collections import namedtuple\n\nfrom .. import file_handler\nfrom ..config import PATH, TODAY_STR, TimeTransferFutures, StrategyList\nfrom ..utils.database import db\nfrom ..utils.database.tables import PutCallRatioList, ExDividendTable\n", "from ..utils.database.tables import PutCallRatioList, ExDividendTable\n\n\nclass StrategyTool:\n    def __init__(self, **kwargs):\n        self.set_config(**kwargs)\n        self.Action = namedtuple(\n            typename=\"Action\",\n            field_names=['position', 'reason', 'msg', 'price'],\n            defaults=[0, '', '', 0]\n        )\n        self.pc_ratio = self.get_put_call_ratio()\n        self.dividends = self.get_ex_dividends_list()\n        self.STRATEGIES = pd.DataFrame(\n            columns=['name', 'long_weight', 'short_weight']\n        )\n        self.Funcs = {\n            'Open': {  # action\n                '\u7576\u6c96': {},  # tradeType\n                '\u975e\u7576\u6c96': {}\n            },\n            'Close': {\n                '\u7576\u6c96': {},\n                '\u975e\u7576\u6c96': {}\n            }\n        }\n        self.QuantityFunc = {}\n\n    def set_config(self, **kwargs):\n        self.account_name = kwargs.get('account_name', 'unknown')\n        self.hold_day = kwargs.get('hold_day', 20)\n        self.is_simulation = kwargs.get('is_simulation', True)\n        self.stock_limit_type = kwargs.get('stock_limit_type', 'Constant')\n        self.futures_limit_type = kwargs.get('futures_limit_type', 'Constant')\n        self.stock_limit_long = kwargs.get('stock_limit_long', 0)\n        self.stock_limit_short = kwargs.get('stock_limit_short', 0)\n        self.futures_limit = kwargs.get('futures_limit', 0)\n\n    def mapFunction(self, action: str, tradeType: str, strategy: str):\n        has_action = action in self.Funcs\n        has_tradeType = tradeType in self.Funcs[action]\n        has_strategy = strategy in self.Funcs[action][tradeType]\n        if has_action and has_tradeType and has_strategy:\n            return self.Funcs[action][tradeType][strategy]\n        return self.__DoNothing__\n\n    def mapQuantities(self, strategy: str):\n\n        def default_quantity(**kwargs):\n            return 1, 499\n\n        if strategy in self.QuantityFunc:\n            return self.QuantityFunc[strategy]\n\n        return default_quantity\n\n    def __DoNothing__(self, **kwargs):\n        return self.Action()\n\n    def update_indicators(self, now: datetime, kbars: dict):\n        pass\n\n    def setNStockLimitLong(self, KBars: dict = None):\n        '''\n        Set the number limit of securities of a portfolio can hold \n        for a long strategy\n        '''\n\n        if self.is_simulation:\n            return 3000\n        elif self.stock_limit_type != 'constant':\n            return self.stock_limit_long\n        return self.stock_limit_long\n\n    def setNStockLimitShort(self, KBars: dict = None):\n        '''\n        Set the number limit of securities of a portfolio can hold \n        for a short strategy\n        '''\n\n        if self.is_simulation:\n            return 3000\n        elif self.stock_limit_type != 'constant':\n            return self.stock_limit_short\n        return self.stock_limit_short\n\n    def setNFuturesLimit(self, KBars: dict = None):\n        '''Set the number limit of securities of a portfolio can hold'''\n        return 0\n\n    def _get_value(self, data: pd.DataFrame, stockid: str, col: str):\n        if isinstance(data, pd.DataFrame):\n            tb = data[data.name == stockid]\n\n            if tb.shape[0]:\n                return tb[col].values[-1]\n            return 0\n\n        return data[stockid].get(col)\n\n    def get_ex_dividends_list(self):\n        '''\u53d6\u5f97\u7576\u65e5\u9664\u6b0a\u606f\u80a1\u7968\u6e05\u55ae'''\n\n        if db.HAS_DB:\n            df = db.query(ExDividendTable)\n            return df[df.Date == TODAY_STR].set_index('Code').CashDividend.to_dict()\n\n        try:\n            df = file_handler.read_table(f'{PATH}/exdividends.csv')\n            df.Code = df.Code.astype(str).str.zfill(4)\n            return df[df.Date == TODAY_STR].set_index('Code').CashDividend.to_dict()\n        except:\n            logging.warning('==========exdividends.csv\u4e0d\u5b58\u5728\uff0c\u7121\u9664\u6b0a\u606f\u80a1\u7968\u6e05\u55ae==========')\n            return {}\n\n    def get_put_call_ratio(self):\n        '''\u53d6\u5f97\u524d\u4e00\u500b\u4ea4\u6613\u65e5\u6536\u76e4\u5f8c\u7684Put-Call ratio'''\n        if db.HAS_DB:\n            pc_ratio = db.query(PutCallRatioList.PutCallRatio)\n            if pc_ratio.shape[0]:\n                return pc_ratio.PutCallRatio.values[-1]\n            return 100\n\n        try:\n            pc_ratio = file_handler.read_table(f'{PATH}/put_call_ratio.csv')\n            pc_ratio = pc_ratio.sort_values('Date')\n            return pc_ratio.PutCallRatio.values[-1]\n        except:\n            logging.warning(\n                '==========put_call_ratio.csv\u4e0d\u5b58\u5728\uff0c\u7121\u524d\u4e00\u4ea4\u6613\u65e5\u7684Put/Call Ratio==========')\n            return 100\n\n    def transfer_position(self, inputs: dict, kbars: dict, **kwargs):\n        target = inputs['symbol']\n        now = datetime.now()\n        if now > TimeTransferFutures:\n            return self.Action(100, '\u8f49\u5009', f'{target} \u8f49\u5009-Cover')\n        return self.Action()\n\n    def isLong(self, strategy: str):\n        '''Check if a strategy is a long strategy.'''\n        return strategy in StrategyList.Long\n\n    def isShort(self, strategy: str):\n        '''Check if a strategy is a short strategy.'''\n        return strategy in StrategyList.Short\n\n    def isDayTrade(self, strategy: str):\n        '''Check if a strategy is a day-trade strategy.'''\n        return strategy in StrategyList.DayTrade", ""]}
{"filename": "trader/utils/database/__init__.py", "chunked_list": ["import logging\nfrom sqlalchemy import create_engine\n\nfrom .sql import SQLDatabase\nfrom .redis import RedisTools\nfrom .tables import *\nfrom ...config import DB_NAME, DB_URL\n\n\ndef create_schema(schemaName):\n    engine = create_engine(f'mysql+pymysql://{DB_URL}')\n\n    conn = engine.connect()\n    if schemaName.lower() not in conn.dialect.get_schema_names(conn):\n        logging.warning(f'Schema {schemaName} not exist, create {schemaName}.')\n        engine.execute(f\"CREATE SCHEMA {schemaName}\")\n        conn.close()\n        logging.warning(f'Done creating schema {schemaName}')\n\n    # disconnect database\n    engine.dispose()", "\ndef create_schema(schemaName):\n    engine = create_engine(f'mysql+pymysql://{DB_URL}')\n\n    conn = engine.connect()\n    if schemaName.lower() not in conn.dialect.get_schema_names(conn):\n        logging.warning(f'Schema {schemaName} not exist, create {schemaName}.')\n        engine.execute(f\"CREATE SCHEMA {schemaName}\")\n        conn.close()\n        logging.warning(f'Done creating schema {schemaName}')\n\n    # disconnect database\n    engine.dispose()", "\n\ndb = SQLDatabase()\nredis_tick = RedisTools(redisKey='TickData')\n\nif db.HAS_DB:\n    create_schema(DB_NAME)\n    Base.metadata.create_all(db.engine)\n\n    KBarTables = {\n        '1D': KBarData1D,\n        '1T': KBarData1T,\n        '30T': KBarData30T,\n        '60T': KBarData60T\n    }\nelse:\n    KBarTables = {}", ""]}
{"filename": "trader/utils/database/tables.py", "chunked_list": ["from sqlalchemy import Column, Integer, FLOAT, String, text, BigInteger\nfrom sqlalchemy.dialects.mysql import TIMESTAMP\n\nfrom .sql import Base\n\n\ntime_default = text(\"CURRENT_TIMESTAMP(6)\")\ncollation = 'utf8mb4_unicode_ci'\n\n\nclass SecurityInfoStocks(Base):\n    __tablename__ = 'security_info_stocks'\n\n    pk_id = Column(\n        Integer, primary_key=True, autoincrement=True, nullable=False)\n\n    account = Column(String(50, collation), nullable=False, comment='\u5e33\u6236\u4ee3\u865f')\n    market = Column(String(10, collation), nullable=False, comment='\u5e02\u5834\u5225')\n    code = Column(String(10, collation), nullable=False, comment='\u8b49\u5238\u4ee3\u865f')\n    order_cond = Column(String(50, collation), nullable=False, comment='\u59d4\u8a17\u985e\u578b')\n    action = Column(String(10, collation), nullable=False, comment='\u8cb7\u8ce3\u5225')\n    pnl = Column(Integer, comment='\u672a\u5be6\u73fe\u640d\u76ca')\n    cost_price = Column(FLOAT(2), nullable=False, comment='\u6210\u672c\u50f9')\n    quantity = Column(Integer, nullable=False, comment='\u4eca\u65e5\u5eab\u5b58\u91cf')\n    yd_quantity = Column(Integer, comment='\u6628\u65e5\u5eab\u5b58\u91cf')\n    last_price = Column(FLOAT(2), nullable=False, comment='\u524d\u4e00\u65e5\u6536\u76e4\u50f9')\n\n    create_time = Column(\n        TIMESTAMP(fsp=6), nullable=False, server_default=time_default)\n\n    def __init__(self, **kwargs):\n        for property, value in kwargs.items():\n            setattr(self, property, value)", "\n\nclass SecurityInfoStocks(Base):\n    __tablename__ = 'security_info_stocks'\n\n    pk_id = Column(\n        Integer, primary_key=True, autoincrement=True, nullable=False)\n\n    account = Column(String(50, collation), nullable=False, comment='\u5e33\u6236\u4ee3\u865f')\n    market = Column(String(10, collation), nullable=False, comment='\u5e02\u5834\u5225')\n    code = Column(String(10, collation), nullable=False, comment='\u8b49\u5238\u4ee3\u865f')\n    order_cond = Column(String(50, collation), nullable=False, comment='\u59d4\u8a17\u985e\u578b')\n    action = Column(String(10, collation), nullable=False, comment='\u8cb7\u8ce3\u5225')\n    pnl = Column(Integer, comment='\u672a\u5be6\u73fe\u640d\u76ca')\n    cost_price = Column(FLOAT(2), nullable=False, comment='\u6210\u672c\u50f9')\n    quantity = Column(Integer, nullable=False, comment='\u4eca\u65e5\u5eab\u5b58\u91cf')\n    yd_quantity = Column(Integer, comment='\u6628\u65e5\u5eab\u5b58\u91cf')\n    last_price = Column(FLOAT(2), nullable=False, comment='\u524d\u4e00\u65e5\u6536\u76e4\u50f9')\n\n    create_time = Column(\n        TIMESTAMP(fsp=6), nullable=False, server_default=time_default)\n\n    def __init__(self, **kwargs):\n        for property, value in kwargs.items():\n            setattr(self, property, value)", "\n\nclass SecurityInfoFutures(Base):\n    __tablename__ = 'security_info_futures'\n\n    pk_id = Column(\n        Integer, primary_key=True, autoincrement=True, nullable=False)\n\n    Account = Column(String(50, collation), nullable=False, comment='\u5e33\u6236\u4ee3\u865f')\n    Market = Column(String(10, collation), nullable=False, comment='\u5e02\u5834\u5225')\n    Date = Column(\n        TIMESTAMP(fsp=6), server_default=time_default, nullable=False, comment='\u65e5\u671f')\n    Code = Column(String(10, collation), nullable=False, comment='\u8b49\u5238\u4ee3\u865f')\n    CodeName = Column(String(50, collation), comment='\u6a19\u7684\u540d\u7a31')\n    OrderNum = Column(String(50, collation), comment='\u59d4\u8a17\u7de8\u865f')\n    OrderBS = Column(String(50, collation), comment='\u8cb7\u8ce3\u5225')\n    OrderType = Column(String(50, collation), comment='\u59d4\u8a17\u985e\u578b')\n    Currency = Column(String(50, collation), comment='\u5e63\u5225')\n    paddingByte = Column(String(50, collation), comment='unknown')\n    Volume = Column(FLOAT(2), comment='\u6210\u4ea4\u91cf')\n    ContractAverPrice = Column(FLOAT(2), comment='\u5e73\u5747\u5408\u7d04\u50f9')\n    SettlePrice = Column(FLOAT(2), comment='\u5c65\u7d04\u50f9')\n    RealPrice = Column(FLOAT(2), comment='unknown')\n    FlowProfitLoss = Column(FLOAT(2), comment='unknown')\n    SettleProfitLoss = Column(FLOAT(2), comment='unknown')\n    StartSecurity = Column(String(50, collation), comment='unknown')\n    UpKeepSecurity = Column(String(50, collation), comment='unknown')\n    OTAMT = Column(FLOAT(2), comment='unknown')\n    MTAMT = Column(FLOAT(2), comment='unknown')\n\n    create_time = Column(\n        TIMESTAMP(fsp=6), nullable=False, server_default=time_default)\n\n    def __init__(self, **kwargs):\n        for property, value in kwargs.items():\n            setattr(self, property, value)", "\n\nclass Watchlist(Base):\n    __tablename__ = 'watchlist'\n\n    pk_id = Column(\n        Integer, primary_key=True, autoincrement=True, nullable=False)\n\n    account = Column(String(50, collation), nullable=False)\n    market = Column(String(10, collation), nullable=False)\n    code = Column(String(10, collation), nullable=False)\n    buyday = Column(TIMESTAMP(fsp=6), server_default=time_default)\n    bsh = Column(FLOAT(2), nullable=False)\n    position = Column(Integer, nullable=False)\n    strategy = Column(String(50, collation), server_default='unknown')\n    create_time = Column(\n        TIMESTAMP(fsp=6), nullable=False, server_default=time_default)\n\n    def __init__(self, **kwargs):\n        for property, value in kwargs.items():\n            setattr(self, property, value)", "\n\nclass SecurityList(Base):\n    __tablename__ = 'security_list'\n\n    pk_id = Column(\n        Integer, primary_key=True, autoincrement=True, nullable=False)\n\n    underlying_kind = Column(String(50, collation))\n    update_date = Column(TIMESTAMP(fsp=6), server_default=time_default)\n    target_code = Column(String(10, collation))\n    reference = Column(FLOAT(2), nullable=False)\n    delivery_date = Column(String(10, collation))\n    exchange = Column(String(3, collation))\n    delivery_month = Column(String(6, collation))\n    name = Column(String(50, collation), default='unknown')\n    short_selling_balance = Column(Integer)\n    option_right = Column(String(50, collation))\n    strike_price = Column(FLOAT(2))\n    underlying_code = Column(String(10, collation))\n    margin_trading_balance = Column(Integer)\n    limit_up = Column(FLOAT(2), nullable=False)\n    limit_down = Column(FLOAT(2), nullable=False)\n    symbol = Column(String(10, collation))\n    category = Column(String(3, collation))\n    multiplier = Column(FLOAT(2), default=0)\n    currency = Column(String(3, collation), default='TWD')\n    day_trade = Column(String(7, collation), default='No')\n    code = Column(String(10, collation), nullable=False)\n    unit = Column(Integer)\n    security_type = Column(String(3, collation))\n\n    create_time = Column(\n        TIMESTAMP(fsp=6), nullable=False, server_default=time_default)\n\n    def __init__(self, **kwargs):\n        for property, value in kwargs.items():\n            setattr(self, property, value)", "\n\nclass KBarData1T(Base):\n    __tablename__ = 'kbar_data_1T'\n\n    pk_id = Column(\n        Integer, primary_key=True, autoincrement=True, nullable=False)\n\n    name = Column(String(10, collation), nullable=False)\n    Time = Column(TIMESTAMP(fsp=6), server_default=time_default)\n    Open = Column(FLOAT(2), default=0)\n    High = Column(FLOAT(2), default=0)\n    Low = Column(FLOAT(2), default=0)\n    Close = Column(FLOAT(2), default=0)\n    Volume = Column(FLOAT(2), default=0)\n    Amount = Column(FLOAT(2), default=0)\n\n    create_time = Column(\n        TIMESTAMP(fsp=6), nullable=False, server_default=time_default)\n\n    def __init__(self, **kwargs):\n        for property, value in kwargs.items():\n            setattr(self, property, value)", "\n\nclass KBarData30T(Base):\n    __tablename__ = 'kbar_data_30T'\n\n    pk_id = Column(\n        Integer, primary_key=True, autoincrement=True, nullable=False)\n\n    name = Column(String(10, collation), nullable=False)\n    Time = Column(TIMESTAMP(fsp=6), server_default=time_default)\n    Open = Column(FLOAT(2), default=0)\n    High = Column(FLOAT(2), default=0)\n    Low = Column(FLOAT(2), default=0)\n    Close = Column(FLOAT(2), default=0)\n    Volume = Column(FLOAT(2), default=0)\n    Amount = Column(FLOAT(2), default=0)\n\n    create_time = Column(\n        TIMESTAMP(fsp=6), nullable=False, server_default=time_default)\n\n    def __init__(self, **kwargs):\n        for property, value in kwargs.items():\n            setattr(self, property, value)", "\n\nclass KBarData60T(Base):\n    __tablename__ = 'kbar_data_60T'\n\n    pk_id = Column(\n        Integer, primary_key=True, autoincrement=True, nullable=False)\n\n    name = Column(String(10, collation), nullable=False)\n    Time = Column(TIMESTAMP(fsp=6), server_default=time_default)\n    Open = Column(FLOAT(2), default=0)\n    High = Column(FLOAT(2), default=0)\n    Low = Column(FLOAT(2), default=0)\n    Close = Column(FLOAT(2), default=0)\n    Volume = Column(FLOAT(2), default=0)\n    Amount = Column(FLOAT(2), default=0)\n\n    create_time = Column(\n        TIMESTAMP(fsp=6), nullable=False, server_default=time_default)\n\n    def __init__(self, **kwargs):\n        for property, value in kwargs.items():\n            setattr(self, property, value)", "\n\nclass KBarData1D(Base):\n    __tablename__ = 'kbar_data_1D'\n\n    pk_id = Column(\n        Integer, primary_key=True, autoincrement=True, nullable=False)\n\n    name = Column(String(10, collation), nullable=False)\n    Time = Column(TIMESTAMP(fsp=6), server_default=time_default)\n    Open = Column(FLOAT(2), default=0)\n    High = Column(FLOAT(2), default=0)\n    Low = Column(FLOAT(2), default=0)\n    Close = Column(FLOAT(2), default=0)\n    Volume = Column(FLOAT(2), default=0)\n    Amount = Column(FLOAT(2), default=0)\n\n    create_time = Column(\n        TIMESTAMP(fsp=6), nullable=False, server_default=time_default)\n\n    def __init__(self, **kwargs):\n        for property, value in kwargs.items():\n            setattr(self, property, value)", "\n\nclass PutCallRatioList(Base):\n    __tablename__ = 'put_call_ratio'\n\n    pk_id = Column(\n        Integer, primary_key=True, autoincrement=True, nullable=False)\n\n    Date = Column(TIMESTAMP(fsp=6), server_default=time_default, comment='\u65e5\u671f')\n    PutVolume = Column(FLOAT(2), default=0, comment='\u8ce3\u6b0a\u6210\u4ea4\u91cf')\n    CallVolume = Column(FLOAT(2), default=0, comment='\u8cb7\u6b0a\u6210\u4ea4\u91cf')\n    PutCallVolumeRatio = Column(FLOAT(2), default=0, comment='\u8cb7\u8ce3\u6b0a\u6210\u4ea4\u91cf\u6bd4\u7387%')\n    PutOpenInterest = Column(FLOAT(2), default=0, comment='\u8ce3\u6b0a\u672a\u5e73\u5009')\n    CallOpenInterest = Column(FLOAT(2), default=0, comment='\u8cb7\u6b0a\u672a\u5e73\u5009')\n    PutCallRatio = Column(FLOAT(2), default=0, comment='\u8cb7\u8ce3\u6b0a\u672a\u5e73\u5009\u91cf\u6bd4\u7387%')\n\n    create_time = Column(\n        TIMESTAMP(fsp=6), nullable=False, server_default=time_default)\n\n    def __init__(self, **kwargs):\n        for property, value in kwargs.items():\n            setattr(self, property, value)", "\n\nclass ExDividendTable(Base):\n    __tablename__ = 'ex_dividend_table'\n\n    pk_id = Column(\n        Integer, primary_key=True, autoincrement=True, nullable=False)\n\n    Date = Column(\n        TIMESTAMP(fsp=6), server_default=time_default, comment='\u9664\u6b0a\u9664\u606f\u65e5\u671f')\n    Code = Column(String(10, collation), nullable=False, comment='\u80a1\u7968\u4ee3\u865f')\n    Name = Column(String(50, collation), default='unknown', comment='\u540d\u7a31')\n    DividendType = Column(String(5, collation), comment='\u9664\u6b0a\u606f')\n    DividendRate = Column(FLOAT(2), default=0, comment='\u7121\u511f\u914d\u80a1\u7387')\n    CashCapitalRate = Column(FLOAT(2), default=0, comment='\u73fe\u91d1\u589e\u8cc7\u914d\u80a1\u7387')\n    CashCapitalPrice = Column(FLOAT(2), default=0, comment='\u73fe\u91d1\u589e\u8cc7\u8a8d\u8cfc\u50f9')\n    CashDividend = Column(FLOAT(2), default=0, comment='\u73fe\u91d1\u80a1\u5229')\n    Details = Column(String(10, collation), comment='\u8a73\u7d30\u8cc7\u6599')\n    Reference = Column(String(10, collation), comment='\u53c3\u8003\u50f9\u8a66\u7b97')\n    Quarter = Column(String(10, collation), comment='\u6700\u8fd1\u4e00\u6b21\u7533\u5831\u8cc7\u6599 \u5b63\u5225/\u65e5\u671f')\n    NetValue = Column(FLOAT(2), default=0, comment='\u6700\u8fd1\u4e00\u6b21\u7533\u5831\u6bcf\u80a1 (\u55ae\u4f4d)\u6de8\u503c')\n    EPS = Column(FLOAT(2), default=0, comment='\u6700\u8fd1\u4e00\u6b21\u7533\u5831\u6bcf\u80a1 (\u55ae\u4f4d)\u76c8\u9918')\n\n    create_time = Column(\n        TIMESTAMP(fsp=6), nullable=False, server_default=time_default)\n\n    def __init__(self, **kwargs):\n        for property, value in kwargs.items():\n            setattr(self, property, value)", "\n\nclass TradingStatement(Base):\n    __tablename__ = 'trading_statement'\n\n    pk_id = Column(\n        Integer, primary_key=True, autoincrement=True, nullable=False)\n\n    Time = Column(\n        TIMESTAMP(fsp=6), server_default=time_default, comment='\u4ea4\u6613\u65e5\u671f')\n    market = Column(String(10, collation), nullable=False, comment='\u5e02\u5834\u5225')\n    account_id = Column(\n        String(50, collation), default='unknown', comment='\u5e33\u865f\u5225')\n    code = Column(String(10, collation), nullable=False, comment='\u8b49\u5238\u4ee3\u865f')\n    action = Column(String(50, collation), default='unknown', comment='\u8cb7\u8ce3\u5225')\n    price = Column(FLOAT(2), default=0, comment='\u6210\u4ea4\u50f9')\n    quantity = Column(FLOAT(2), default=0, comment='\u6210\u4ea4\u6578\u91cf')\n    amount = Column(FLOAT(2), default=0, comment='\u6210\u4ea4\u91d1\u984d')\n    order_cond = Column(\n        String(50, collation), default='unknown', comment='\u73fe\u80a1\u6216\u878d\u8cc7')\n    order_lot = Column(\n        String(50, collation), default='unknown', comment='\u6574\u5f35\u6216\u96f6\u80a1')\n    op_type = Column(\n        String(50, collation), default='unknown', comment='\u671f\u6b0a\u59d4\u8a17\u985e\u578b')\n    leverage = Column(FLOAT(2), default=1, comment='\u69d3\u687f\u6bd4\u4f8b')\n    msg = Column(\n        String(200, collation), default='unknown', comment='\u9032\u51fa\u5834\u8a0a\u606f')\n\n    create_time = Column(\n        TIMESTAMP(fsp=6), nullable=False, server_default=time_default)\n\n    def __init__(self, **kwargs):\n        for property, value in kwargs.items():\n            setattr(self, property, value)", "\n\nclass SelectedStocks(Base):\n    __tablename__ = 'selected_stocks'\n\n    pk_id = Column(\n        Integer, primary_key=True, autoincrement=True, nullable=False)\n\n    code = Column(String(10, collation), nullable=False, comment='\u8b49\u5238\u4ee3\u865f')\n    company_name = Column(String(10, collation), comment='\u8b49\u5238\u540d\u7a31')\n    category = Column(String(50, collation), comment='\u7522\u696d\u985e\u5225')\n    Time = Column(\n        TIMESTAMP(fsp=6), server_default=time_default, comment='\u9078\u80a1\u65e5\u671f')\n    Open = Column(FLOAT(2), nullable=False, comment='\u958b\u76e4\u50f9')\n    High = Column(FLOAT(2), nullable=False, comment='\u6700\u9ad8\u50f9')\n    Low = Column(FLOAT(2), nullable=False, comment='\u6700\u4f4e\u50f9')\n    Close = Column(FLOAT(2), nullable=False, comment='\u6536\u76e4\u50f9')\n    Volume = Column(Integer, comment='\u6210\u4ea4\u91cf')\n    Amount = Column(BigInteger, comment='\u6210\u4ea4\u984d')\n    Strategy = Column(String(10, collation), nullable=False, comment='\u9078\u80a1\u7b56\u7565')\n\n    create_time = Column(\n        TIMESTAMP(fsp=6), nullable=False, server_default=time_default)\n\n    def __init__(self, **kwargs):\n        for property, value in kwargs.items():\n            setattr(self, property, value)", ""]}
{"filename": "trader/utils/database/sql.py", "chunked_list": ["import logging\nimport numpy as np\nimport pandas as pd\nfrom sqlalchemy import update\nfrom sqlalchemy.pool import QueuePool\nfrom sqlalchemy import asc, desc, create_engine\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, scoped_session, load_only\n\nfrom ...config import HAS_DB, DB_NAME, DB_URL", "\nfrom ...config import HAS_DB, DB_NAME, DB_URL\nfrom ..file import FileHandler\n\n\nBase = declarative_base()\n\n\nclass SQLDatabase(FileHandler):\n    def __init__(self):\n        self.HAS_DB = HAS_DB\n        if self.HAS_DB:\n            self.sql_connect = f\"mysql+pymysql://{DB_URL}/{DB_NAME}?charset=utf8mb4&binary_prefix=true\"\n            self.engine = create_engine(\n                self.sql_connect,\n                pool_size=50,\n                # max_overflow=max_overflow,\n                pool_recycle=10,\n                pool_timeout=10,\n                pool_pre_ping=True,\n                poolclass=QueuePool,\n                pool_use_lifo=True,\n                echo=False\n            )\n            self.sessionmaker_ = sessionmaker(bind=self.engine)\n\n    def get_session(self):\n        return scoped_session(self.sessionmaker_)\n\n    def create_table(self, table):\n        engine = create_engine(self.sql_connect)\n        table\n        Base.metadata.create_all(engine)\n\n    def query(self, table, *filterBy, **conditions):\n        '''Get data from DB'''\n\n        session = self.get_session()\n        query = session.query(table).filter(*filterBy)\n\n        if conditions.get('orderBy'):\n            if conditions['orderBy'] == 'asc':\n                query = query.order_by(asc(conditions['orderTarget']))\n            else:\n                query = query.order_by(desc(conditions['orderTarget']))\n\n        if conditions.get('limit'):\n            query = query.limit(conditions['limit'])\n\n        if conditions.get('fields'):\n            query = query.options(load_only(*conditions['fields']))\n\n        result = pd.read_sql(query.statement, session.bind)\n        session.close()\n\n        for c in ['pk_id', 'create_time']:\n            if c in result.columns:\n                result = result.drop(['pk_id', 'create_time'], axis=1)\n        return result\n\n    def update(self, table, update_content: dict, *filterBy):\n        '''Update data in table'''\n\n        session = self.get_session()\n        session.execute(\n            update(table).where(*filterBy).values(update_content)\n        )\n        session.commit()\n        session.close()\n\n    def delete(self, table, *args):\n        '''Delete data in table'''\n\n        session = self.get_session()\n        query_data = session.query(table).filter(*args).all()\n        for row in query_data:\n            session.delete(row)\n            session.commit()\n        session.close()\n\n    def check_exist(self, table, **kwargs):\n        '''Check if data exists in table'''\n\n        session = self.get_session()\n        q = session.query(table).filter_by(**kwargs)\n        check_result = session.query(q.exists()).scalar()\n        session.close()\n        return check_result\n\n    def dataframe_to_DB(self, df: pd.DataFrame, table):\n        '''Import dataframe to DB'''\n\n        # \u8f49\u63db\u6642\u9593\u683c\u5f0f\n        for col in df.columns:\n            if df[col].dtype == pd._libs.tslibs.timestamps.Timestamp:\n                df[col] = df[col].astype(str).apply(\n                    lambda x: None if x == 'NaT' else x)\n\n        # \u88dc\u7a7a\u503c\n        if df.isnull().sum().sum():\n            df = df.where(pd.notnull(df), '')\n\n        datarows = np.array(df.to_dict('records'))\n        alldata = np.array([table(**row) for row in datarows])\n\n        # upload data\n        session = self.get_session()\n        session.add_all(alldata)\n        session.commit()\n        session.close()\n\n    def add_data(self, table, **input_data):\n        try:\n            session = self.get_session()\n            data = table(**input_data)\n            session.add(data)\n            session.commit()\n        except:\n            session.rollback()\n            logging.error(\n                f\"Save data into {table.__tablename__} failed\")\n        finally:\n            session.close()\n\n    def export_table(self, table, filename, *filterBy, **conditions):\n        '''Export DB data'''\n\n        df = self.query(table, *filterBy, **conditions)\n        self.save_table(df, filename)", "class SQLDatabase(FileHandler):\n    def __init__(self):\n        self.HAS_DB = HAS_DB\n        if self.HAS_DB:\n            self.sql_connect = f\"mysql+pymysql://{DB_URL}/{DB_NAME}?charset=utf8mb4&binary_prefix=true\"\n            self.engine = create_engine(\n                self.sql_connect,\n                pool_size=50,\n                # max_overflow=max_overflow,\n                pool_recycle=10,\n                pool_timeout=10,\n                pool_pre_ping=True,\n                poolclass=QueuePool,\n                pool_use_lifo=True,\n                echo=False\n            )\n            self.sessionmaker_ = sessionmaker(bind=self.engine)\n\n    def get_session(self):\n        return scoped_session(self.sessionmaker_)\n\n    def create_table(self, table):\n        engine = create_engine(self.sql_connect)\n        table\n        Base.metadata.create_all(engine)\n\n    def query(self, table, *filterBy, **conditions):\n        '''Get data from DB'''\n\n        session = self.get_session()\n        query = session.query(table).filter(*filterBy)\n\n        if conditions.get('orderBy'):\n            if conditions['orderBy'] == 'asc':\n                query = query.order_by(asc(conditions['orderTarget']))\n            else:\n                query = query.order_by(desc(conditions['orderTarget']))\n\n        if conditions.get('limit'):\n            query = query.limit(conditions['limit'])\n\n        if conditions.get('fields'):\n            query = query.options(load_only(*conditions['fields']))\n\n        result = pd.read_sql(query.statement, session.bind)\n        session.close()\n\n        for c in ['pk_id', 'create_time']:\n            if c in result.columns:\n                result = result.drop(['pk_id', 'create_time'], axis=1)\n        return result\n\n    def update(self, table, update_content: dict, *filterBy):\n        '''Update data in table'''\n\n        session = self.get_session()\n        session.execute(\n            update(table).where(*filterBy).values(update_content)\n        )\n        session.commit()\n        session.close()\n\n    def delete(self, table, *args):\n        '''Delete data in table'''\n\n        session = self.get_session()\n        query_data = session.query(table).filter(*args).all()\n        for row in query_data:\n            session.delete(row)\n            session.commit()\n        session.close()\n\n    def check_exist(self, table, **kwargs):\n        '''Check if data exists in table'''\n\n        session = self.get_session()\n        q = session.query(table).filter_by(**kwargs)\n        check_result = session.query(q.exists()).scalar()\n        session.close()\n        return check_result\n\n    def dataframe_to_DB(self, df: pd.DataFrame, table):\n        '''Import dataframe to DB'''\n\n        # \u8f49\u63db\u6642\u9593\u683c\u5f0f\n        for col in df.columns:\n            if df[col].dtype == pd._libs.tslibs.timestamps.Timestamp:\n                df[col] = df[col].astype(str).apply(\n                    lambda x: None if x == 'NaT' else x)\n\n        # \u88dc\u7a7a\u503c\n        if df.isnull().sum().sum():\n            df = df.where(pd.notnull(df), '')\n\n        datarows = np.array(df.to_dict('records'))\n        alldata = np.array([table(**row) for row in datarows])\n\n        # upload data\n        session = self.get_session()\n        session.add_all(alldata)\n        session.commit()\n        session.close()\n\n    def add_data(self, table, **input_data):\n        try:\n            session = self.get_session()\n            data = table(**input_data)\n            session.add(data)\n            session.commit()\n        except:\n            session.rollback()\n            logging.error(\n                f\"Save data into {table.__tablename__} failed\")\n        finally:\n            session.close()\n\n    def export_table(self, table, filename, *filterBy, **conditions):\n        '''Export DB data'''\n\n        df = self.query(table, *filterBy, **conditions)\n        self.save_table(df, filename)", ""]}
{"filename": "trader/utils/database/redis.py", "chunked_list": ["import time\nimport redis\nimport pickle\nimport logging\nfrom typing import Iterable\n\nfrom ...config import HAS_REDIS, REDIS_HOST, REDIS_PORT, REDIS_PWD\nfrom .. import progress_bar\n\n\nclass RedisTools:\n    def __init__(self, redisKey):\n        self.HAS_REDIS = HAS_REDIS\n        self.REDIS_KEY = redisKey\n        self.redis_client = self.init_client()\n\n    def init_client(self):\n        '''Initialize Redis by config settings'''\n\n        if self.HAS_REDIS:\n            return redis.Redis(\n                host=REDIS_HOST,\n                port=REDIS_PORT,\n                password=REDIS_PWD,\n                decode_responses=False\n            )\n\n    def _data2byte(self, data: Iterable):\n        return pickle.dumps(data)\n\n    def to_redis(self, data: dict):\n        '''insert data to Redis at a time'''\n\n        N = len(data)\n        if N > 1:\n            pipe = self.redis_client.pipeline()\n\n            for i, c in enumerate(data):\n                pipe.set(f'{self.REDIS_KEY}:{c}', self._data2byte(data[c]))\n                progress_bar(N, i)\n\n            pipe.execute()\n\n        else:\n            for k, v in data.items():\n                self.redis_client.set(\n                    f'{self.REDIS_KEY}:{k}', self._data2byte(v))\n\n    def query(self, key: str):\n        '''query data from redis'''\n\n        n = 0\n        while n < 5:\n            try:\n                data = self.redis_client.get(f\"{self.REDIS_KEY}:{key}\")\n                break\n            except:\n                n += 1\n                logging.error(\n                    f\"Cannot connect to {REDIS_HOST}, reconnect ({n}/5).\")\n                self.redis_client = self.init_client()\n                time.sleep(1)\n\n        if n == 5:\n            return 'Redis ConnectionError'\n\n        try:\n            return pickle.loads(data)\n        except TypeError:\n            return None\n\n    def query_keys(self, keys: str = None, match: str = None):\n        if not keys and not match:\n            keys = self.redis_client.keys()\n        elif match:\n            _, keys = self.redis_client.scan(match=match)\n\n        data = self.redis_client.mget(keys)\n        return [pickle.loads(d) for d in data if d]\n\n    def delete_keys(self, keys: list):\n        '''delete data stored in Redis by key'''\n\n        for k in keys:\n            self.redis_client.delete(f'{self.REDIS_KEY}:{k}')\n\n    def clear_all(self):\n        '''delete all data stored in Redis'''\n\n        self.redis_client.delete(*self.redis_client.keys())\n\n    def memory_usage(self):\n        '''check Redis memory usage'''\n        used_memory = self.redis_client.info()['total_system_memory_human']\n\n        print(f'Total keys = {len(self.redis_client.keys())}')\n        print(f\"Used_memory of {REDIS_HOST}:{REDIS_PORT} = {used_memory}\")", "\n\nclass RedisTools:\n    def __init__(self, redisKey):\n        self.HAS_REDIS = HAS_REDIS\n        self.REDIS_KEY = redisKey\n        self.redis_client = self.init_client()\n\n    def init_client(self):\n        '''Initialize Redis by config settings'''\n\n        if self.HAS_REDIS:\n            return redis.Redis(\n                host=REDIS_HOST,\n                port=REDIS_PORT,\n                password=REDIS_PWD,\n                decode_responses=False\n            )\n\n    def _data2byte(self, data: Iterable):\n        return pickle.dumps(data)\n\n    def to_redis(self, data: dict):\n        '''insert data to Redis at a time'''\n\n        N = len(data)\n        if N > 1:\n            pipe = self.redis_client.pipeline()\n\n            for i, c in enumerate(data):\n                pipe.set(f'{self.REDIS_KEY}:{c}', self._data2byte(data[c]))\n                progress_bar(N, i)\n\n            pipe.execute()\n\n        else:\n            for k, v in data.items():\n                self.redis_client.set(\n                    f'{self.REDIS_KEY}:{k}', self._data2byte(v))\n\n    def query(self, key: str):\n        '''query data from redis'''\n\n        n = 0\n        while n < 5:\n            try:\n                data = self.redis_client.get(f\"{self.REDIS_KEY}:{key}\")\n                break\n            except:\n                n += 1\n                logging.error(\n                    f\"Cannot connect to {REDIS_HOST}, reconnect ({n}/5).\")\n                self.redis_client = self.init_client()\n                time.sleep(1)\n\n        if n == 5:\n            return 'Redis ConnectionError'\n\n        try:\n            return pickle.loads(data)\n        except TypeError:\n            return None\n\n    def query_keys(self, keys: str = None, match: str = None):\n        if not keys and not match:\n            keys = self.redis_client.keys()\n        elif match:\n            _, keys = self.redis_client.scan(match=match)\n\n        data = self.redis_client.mget(keys)\n        return [pickle.loads(d) for d in data if d]\n\n    def delete_keys(self, keys: list):\n        '''delete data stored in Redis by key'''\n\n        for k in keys:\n            self.redis_client.delete(f'{self.REDIS_KEY}:{k}')\n\n    def clear_all(self):\n        '''delete all data stored in Redis'''\n\n        self.redis_client.delete(*self.redis_client.keys())\n\n    def memory_usage(self):\n        '''check Redis memory usage'''\n        used_memory = self.redis_client.info()['total_system_memory_human']\n\n        print(f'Total keys = {len(self.redis_client.keys())}')\n        print(f\"Used_memory of {REDIS_HOST}:{REDIS_PORT} = {used_memory}\")", ""]}
{"filename": "trader/indicators/signals.py", "chunked_list": ["import pandas as pd\n\n\nclass ChipAnalysis:\n    '''\u7c4c\u78bc\u5206\u6790'''\n\n    def __init__(self, df, target):\n        self.df = df\n        self.target = target\n        self.group = df.groupby('stockid')[self.target]\n\n    def change(self):\n        # \u6f32\u8dcc\n        return self.group.transform('diff')\n\n    def changepercent(self):\n        # \u6f32\u8dcc\u5e45\n        return 100*self.df.quotechange/self.group.transform('shift')\n\n    def dailychange(self):\n        # \u7576\u65e5\u9ad8\u4f4e\u50f9\u5dee\n        return self.df.high - self.df.low\n\n    def dailychangepercent(self):\n        # \u7576\u65e5\u9707\u5e45\n        return 100*self.df.dailychange/self.group.transform('shift')\n\n    def MA(self, d):\n        # \u79fb\u52d5\u5e73\u5747\n        return self.group.transform(lambda x: x.rolling(d).mean())\n\n    def short_margin(self):\n        # \u5238\u8cc7\u6bd4 = \u878d\u5238\u9918\u984d / \u878d\u8cc7\u9918\u984d\n        shortMarginPercent = self.df.shortRemaining/self.df.marginRemaining\n        return shortMarginPercent\n\n    def close_short_index(self):\n        # \u5238\u88dc\u529b\u9053 = \u878d\u5238\u9918\u984d / 5 \u65e5\u6210\u4ea4\u5747\u91cf\n        V_1D_5_MA = self.df.groupby('stockid').volume.transform(\n            lambda x: x.rolling(5).mean())\n        closeShortIndex = self.df.shortRemaining/V_1D_5_MA\n        return closeShortIndex", "\n\nclass TechnicalSignals:\n    def _MA(self, df: pd.DataFrame, col: str, n=7, shift=0):\n        return df.groupby('name')[col].transform(lambda x: x.shift(shift).rolling(n).mean())\n\n    def _STD(self, df: pd.DataFrame, col: str, n=7, shift=0):\n        return df.groupby('name')[col].transform(lambda x: x.shift(shift).rolling(n).std())\n\n    def _MAX(self, df: pd.DataFrame, col: str, n=7, shift=0):\n        return df.groupby('name')[col].transform(lambda x: x.shift(shift).rolling(n).max())\n\n    def _MIN(self, df: pd.DataFrame, col: str, n=7, shift=0):\n        return df.groupby('name')[col].transform(lambda x: x.shift(shift).rolling(n).min())\n\n    def MACD(self, tb, d1=12, d2=26, dma=9):\n        group = tb.groupby('name').Close\n\n        # # \u80a1\u50f9\u8207\u4ea4\u6613\u91cf/MACD\u80cc\u96e2\n        # cond1 = (tb.quotechange > 0) & (tb.ema_diff < 0)\n        # cond2 = (tb.quotechange < 0) & (tb.ema_diff > 0)\n        # tb['diverge_MACD'] = (cond1 | cond2).astype(int)\n\n        # DIFF (\u5feb\u7dda) = EMA (\u6536\u76e4\u50f9, 12) - EMA (\u6536\u76e4\u50f9, 26)\n        tb[f'ema_{d1}'] = group.transform(\n            lambda x: x.ewm(span=d1, adjust=False).mean())\n        tb[f'ema_{d2}'] = group.transform(\n            lambda x: x.ewm(span=d2, adjust=False).mean())\n        tb['ema_diff'] = tb[f'ema_{d1}'] - tb[f'ema_{d2}']\n\n        # DEA(\u6162\u7dda) = EMA (DIFF, 9)\n        tb['MACD'] = tb.groupby('name').ema_diff.transform(\n            lambda x: x.ewm(span=dma, adjust=False).mean())\n\n        # MACD\u7d05\u7da0\u67f1\u72c0\u9ad4 = DIFF - DEA\n        tb['diff_MACD'] = tb.ema_diff - tb.MACD\n        return tb\n\n    def check_MACD_dev(self, df: pd.DataFrame):\n        '''\u80cc\u96e2(MACD)'''\n\n        close_diff = df.groupby('name').Close.transform('diff').fillna(0)\n        diff_MACD_diff = df.groupby(\n            'name').diff_MACD.transform('diff').fillna(0)\n        return ((close_diff >= 0) & (diff_MACD_diff <= 0)) | ((close_diff <= 0) & (diff_MACD_diff >= 0))\n\n    def RSI(self, change, period=12):\n        '''\n        change: stock close price daily quote change\n\n        RSI = RS/(1+RS), where RS = Up/Down\n        # Up = d day mean of previous change ups\n        # Down = d day mean of previous change downs\n        '''\n        ups = pd.Series(index=change.index, data=change[change > 0])\n        downs = pd.Series(index=change.index, data=-change[change < 0])\n\n        # \u8a08\u7b97d\u65e5\u5e73\u5747\u6f32\u8dcc\n        mean_u = ups.fillna(0).rolling(period).mean()\n        mean_d = downs.fillna(0).rolling(period).mean()\n\n        # \u8a08\u7b97 RSI\n        rsi = 100*mean_u/(mean_u + mean_d)\n        return rsi\n\n    def RSV(self, tb, d=9):\n        d_min = tb.groupby('name').Close.transform(\n            lambda x: x.rolling(d).min())\n        d_max = tb.groupby('name').Close.transform(\n            lambda x: x.rolling(d).max())\n\n        try:\n            (100*(tb.Close - d_min)/(d_max - d_min)).fillna(-1)\n        except:\n            tb['d_min'] = d_min\n            tb['d_max'] = d_max\n\n        return (100*(tb.Close - d_min)/(d_max - d_min)).fillna(-1)\n\n    def KD(self, tb):\n        '''\n        Reference: https://medium.com/%E5%8F%B0%E8%82%A1etf%E8%B3%87%E6%96%99%E7%A7%91%E5%AD%B8-%E7%A8%8B%E5%BC%8F%E9%A1%9E/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80-%E8%87%AA%E5%BB%BAkd%E5%80%BC-819d6fd707c8\n        \u4e00\u3001 \u8981\u7b97\u51faKD\u503c\uff0c\u5fc5\u5148\u7b97\u51faRSV\u5f37\u5f31\u503c\uff0c\u4ee5\u4e0b\u4ee5 9 \u5929\u70ba\u8a08\u7b97\u57fa\u6e96\u3002\n            RSV=( \u6536\u76e4 - 9\u65e5\u5167\u7684\u6700\u4f4e ) / ( 9\u65e5\u5167\u7684\u6700\u9ad8 - 9\u65e5\u5167\u7684\u6700\u4f4e ) * 100\n        \u4e8c\u3001 \u518d\u4ee5\u5e73\u6ed1\u79fb\u52d5\u5e73\u5747\u6cd5\uff0c\u4f86\u8a08\u7b97KD\u503c\u3002\n            \u671f\u521d:K= 50\uff0cD= 50\n            \u7576\u65e5K\u503c=\u524d\u4e00\u65e5K\u503c * 2/3 + \u7576\u65e5RSV * 1/3\n            \u7576\u65e5D\u503c=\u524d\u4e00\u65e5D\u503c * 2/3 + \u7576\u65e5K\u503c * 1/3\n        '''\n        def _getK(rsv):\n            K = []\n            for r in rsv:\n                if r == -1:\n                    K.append(50)\n                else:\n                    K.append(K[-1]*2/3 + r/3)\n            return K\n\n        def _getD(k):\n            D = []\n            for i, k in enumerate(k):\n                if i == 0:\n                    D.append(50)\n                else:\n                    D.append(D[-1] * 2/3 + k/3)\n            return D\n\n        tb['K'] = tb.groupby('name').RSV.transform(_getK)\n        tb['D'] = tb.groupby('name').K.transform(_getD)\n        return tb", ""]}
{"filename": "trader/create_env/__init__.py", "chunked_list": ["from flask import Flask, request, render_template\n\nfrom trader import file_handler\n\n\ndef _create_env(inputs):\n    modes = {\n        '\u4f5c\u591a\u53ea\u8ce3\u51fa': 'LongSell',\n        '\u4f5c\u591a\u53ea\u8cb7\u9032': 'LongBuy',\n        '\u4f5c\u591a\u8cb7\u9032&\u8ce3\u51fa': 'LongBoth',\n        '\u4f5c\u7a7a\u53ea\u8ce3\u51fa': 'ShortSell',\n        '\u4f5c\u7a7a\u53ea\u8cb7\u9032': 'ShortBuy',\n        '\u4f5c\u7a7a\u8cb7\u9032&\u8ce3\u51fa': 'ShortBoth',\n        '\u4f5c\u591a\u4e14\u505a\u7a7a, \u4e14\u53ef\u8cb7\u9032\u4e5f\u53ef\u8ce3\u51fa': 'All',\n        '\u6a21\u64ec': 'Simulation'\n    }\n    markets = {\n        '\u53ea\u6709\u80a1\u7968': 'stock',\n        '\u53ea\u6709\u671f\u8ca8': 'futures',\n        '\u80a1\u7968 & \u671f\u8ca8': 'stock and futures',\n    }\n\n    account_name = inputs['ACCOUNT_NAME']\n\n    users = file_handler.listdir('./lib/envs', account_name)\n    if users:\n        nth_account = max(users) + 1\n    else:\n        nth_account = 1\n\n    account_name = f'{account_name}_{nth_account}'\n    myBat = open(f\"./lib/envs/{account_name}.env\", 'w+', encoding='utf-8')\n\n    content = f\"\"\"# \u4f7f\u7528\u8005\u8cc7\u8a0a\n        ACCOUNT_NAME={account_name}\n        API_KEY = {inputs['API_KEY']}\n        SECRET_KEY = {inputs['SECRET_KEY']}\n        ACCOUNT_ID = {inputs['ACCOUNT_ID']}\n        CA_PASSWD = {inputs['CA_PASSWD']}\n\n        # \u5d29\u76e4\u65e5\n        KBAR_START_DAYay=\n\n        # \u591a\u7a7a\u6a21\u5f0f (\u82f1\u6587)\n        # \u4f5c\u591a: LongSell(\u53ea\u8ce3\u51fa), LongBuy(\u53ea\u8cb7\u9032), LongBoth(\u8cb7\u9032&\u8ce3\u51fa)\n        # \u4f5c\u7a7a: ShortSell(\u53ea\u8ce3\u51fa), ShortBuy(\u53ea\u8cb7\u9032), ShortBoth(\u8cb7\u9032&\u8ce3\u51fa)\n        # All: \u4f5c\u591a\u4e14\u505a\u7a7a, \u4e14\u53ef\u8cb7\u9032\u4e5f\u53ef\u8ce3\u51fa\n        # Simulation: \u53ef\u505a\u7b56\u7565\u76e3\u63a7(\u591a or \u7a7a or \u591a\u7b56\u7565), \u4f46\u4e0d\u4e0b\u55ae\n        MODE={modes[inputs['MODE']]}\n\n        # \u5e02\u5834\u985e\u578b:stock/futures/stock and futures\n        MARKET={markets[inputs['MARKET']]}\n\n        # \u904e\u6ffe\u6389\u4e0d\u76e3\u63a7\u80a1\u7968\u7684\u6e05\u55ae\uff0c\u6c92\u6709\u7b49\u865f\u5f8c\u9762\u7a7a\u767d\n        FILTER_OUT={inputs['FILTER_OUT']}\n\n        # \u80a1\u7968\u8981\u57f7\u884c\u7684\u7b56\u7565\n        STRATEGY_STOCK={inputs['STRATEGY_STOCK']}\n\n        # \u9ad8\u50f9\u80a1\u9580\u6abb\n        PRICE_THRESHOLD=99999\n\n        # \u8d77\u59cb\u90e8\u4f4d\n        INIT_POSITION=100000\n\n        # \u90e8\u4f4d\u4e0a\u9650/\u53ef\u59d4\u8a17\u91d1\u984d\u4e0a\u9650\n        POSITION_LIMIT_LONG={inputs['POSITION_LIMIT_LONG']}\n        POSITION_LIMIT_SHORT={inputs['POSITION_LIMIT_SHORT']}\n\n        # \u6295\u8cc7\u7d44\u5408\u80a1\u7968\u6578\u4e0a\u9650\n        N_LIMIT_LS={inputs['N_LIMIT_LS']}\n        N_LIMIT_SS={inputs['N_LIMIT_SS']}\n\n        # \u6295\u8cc7\u7d44\u5408\u80a1\u7968\u6578\u4e0a\u9650\u985e\u578b: \u56fa\u5b9a(constant)/\u96a8\u5927\u76e4\u74b0\u5883\u6ce2\u52d5(float)\n        N_STOCK_LIMIT_TYPE={inputs['N_STOCK_LIMIT_TYPE']}\n\n        # \u6bcf\u6b21\u8cb7\u9032\u7684\u55ae\u4f4d(\u5f35)\n        BUY_UNIT={inputs['BUY_UNIT']}\n\n        # \u8cb7\u9032\u7684\u55ae\u4f4d\u6578\u985e\u578b: \u56fa\u5b9a(constant)/\u96a8\u6de8\u503c\u7b49\u6bd4\u4f8b\u589e\u52a0(float)\n        BUY_UNIT_TYPE={inputs['BUY_UNIT_TYPE']}\n\n        # \u73fe\u80a1/\u878d\u8cc7 (Cash/MarginTrading/ShortSelling)\n        ORDER_COND1={inputs['ORDER_COND1']}\n        ORDER_COND2={inputs['ORDER_COND2']}\n\n        # \u6700\u9577\u6301\u6709\u5929\u6578(\u542b\u516d\u65e5)\n        HOLD_DAY={inputs['HOLD_DAY']}\n\n        # ----------------------------------- \u671f\u8ca8\u8a2d\u5b9a ----------------------------------- #\n        # \u4ea4\u6613\u6642\u6bb5(Day/Night/Both)\n        TRADING_PERIOD={inputs['TRADING_PERIOD']}\n\n        # \u671f\u8ca8\u8981\u57f7\u884c\u7684\u7b56\u7565\n        STRATEGY_FUTURES={inputs['STRATEGY_FUTURES']}\n\n        # \u53ef\u4e0b\u55ae\u7684\u4fdd\u8b49\u91d1\u984d\u4e0a\u9650\n        MARGIN_LIMIT = {inputs['MARGIN_LIMIT']}\n\n        # \u6295\u8cc7\u7d44\u5408\u671f\u6b0a\u6578\u4e0a\u9650\n        N_FUTURES_LIMIT={inputs['N_FUTURES_LIMIT']}\n\n        # \u671f\u6b0a\u6295\u8cc7\u7d44\u5408\u671f\u6b0a\u6578\u4e0a\u9650\u985e\u578b: \u56fa\u5b9a(constant)/\u96a8\u5927\u76e4\u74b0\u5883\u6ce2\u52d5(float)\n        N_FUTURES_LIMIT_TYPE={inputs['N_FUTURES_LIMIT_TYPE']}\n\n        # \u6bcf\u6b21\u671f\u6b0a\u5efa\u5009\u7684\u55ae\u4f4d(\u53e3)\n        N_SLOT={inputs['N_SLOT']}\n\n        # \u5efa\u5009\u7684\u53e3\u6578\u985e\u578b: \u56fa\u5b9a(constant)/\u96a8\u6de8\u503c\u7b49\u6bd4\u4f8b\u589e\u52a0(float)\n        N_SLOT_TYPE={inputs['N_SLOT_TYPE']}\n        \"\"\".replace('        ', '')\n\n    myBat.write(content)\n    myBat.close()\n    return {account_name: content}", "\n\ndef _create_bat(account_name):\n    myBat = open(f'./lib/schedules/auto_trader_{account_name}.bat', 'w+')\n    myBat.write(\n        f\"\"\"call C:/Users/%username%/anaconda3/Scripts/activate.bat\n\n        cd /d %~dp0/../..\n\n        set SJ_LOG_PATH=%~dp0/../../logs/shioaji.log\n\n        python run.py -TASK auto_trader -ACCT {account_name}\n        \"\"\".replace('        ', ''))\n\n    myBat.close()", "\n\ndef bat_add_script(name):\n    filename = './lib/schedules/auto_trader_all.bat'\n    myBat = open(filename, 'r')\n    contents = myBat.readlines()\n    command_line = f'start /min cmd /c %~dp0/auto_trader_{name}.bat'\n    if command_line not in contents:\n        contents.append(f'''\\n\\n{command_line}''')\n\n    myBat = open(filename, 'w')\n    myBat.write(\"\".join(contents))\n    myBat.close()", "\n\napp = Flask(__name__)\n\n\n# Homepage\n@ app.route(\"/\", methods=['GET'])\ndef account():\n    return render_template('index.html')\n", "\n\n@ app.route(\"/account-result\", methods=['POST'])\ndef account_result():\n\n    data = request.form\n    result = _create_env(data)\n\n    # # \u65b0\u589e\u500b\u4ebabat\u6a94\n    account_name = list(result)[0]\n    _create_bat(account_name)\n\n    # # \u52a0\u5165\u500b\u4ebabat\u6a94\u57f7\u884c\u6307\u4ee4\n    # bat_add_script(name)\n\n    result = {'msg': '\u65b0\u589e\u6210\u529f'}\n    return render_template('account_result.html', result=result)", ""]}
{"filename": "trader/performance/base.py", "chunked_list": ["import numpy as np\nimport pandas as pd\n\nfrom ..config import StrategyList\n\n\ndef AccountingNumber(number: float):\n    return f\"{'{:,}'.format(number)}\"\n\n\ndef convert_statement(df, mode='trading', **kwargs):\n    def extract_strategy(msg):\n        for s in StrategyList.All:\n            if s in msg:\n                return s\n        return 'Unknown'\n\n    if not df.shape[0]:\n        return df\n\n    init_position = kwargs.get('init_position', 1000000)\n    if mode == 'trading':\n        df = df.rename(columns={\n            'code': 'Code',\n            'price': 'Price',\n            'quantity': 'Quantity',\n            'msg': 'Reason',\n            'amount': 'Amount'\n        })\n        df['Strategy'] = df.Reason.apply(extract_strategy)\n        df['isLong'] = df.Strategy.apply(lambda x: x in StrategyList.Long)\n        df['isShort'] = df.isLong == False\n        df['isOpen'] = (\n            ((df.isLong == True) & (df.action == 'Buy')) |\n            ((df.isShort == True) & (df.action == 'Sell'))\n        )\n\n        target_columns1 = ['Strategy', 'Code', 'isLong', 'isShort']\n        target_columns2 = ['Time', 'Price', 'Quantity', 'Amount', 'Reason']\n        tb1 = df[df.isOpen == True][target_columns1 + target_columns2]\n        tb1.columns = target_columns1 + ['Open' + c for c in target_columns2]\n\n        tb2 = df[df.isOpen == False][target_columns1 + target_columns2]\n        tb2.columns = target_columns1 + ['Close' + c for c in target_columns2]\n\n        tb = pd.concat([tb1, tb2]).sort_index()\n        tb.CloseAmount = tb.CloseAmount.abs()\n        tb.OpenQuantity = tb.OpenQuantity.fillna(tb.CloseQuantity)\n        for c in ['Time', 'Price', 'Amount', 'Reason']:\n            col = f'Open{c}'\n            tb[col] = tb.groupby('Code')[col].fillna(method='ffill')\n\n        tb['OpenAmount'] = (tb.OpenPrice*tb.OpenQuantity).abs()\n        tb['CloseAmount'] = (tb.ClosePrice*tb.CloseQuantity).abs()\n        tb['profit'] = (tb.CloseAmount - tb.OpenAmount)*(tb.isShort*(-2)+1)\n        tb['returns'] = 100*(tb.profit/tb.OpenAmount).round(4)\n        tb['balance'] = init_position + tb.profit.cumsum()\n        tb = tb.dropna().reset_index(drop=True)\n\n        for index, row in tb.iterrows():\n            sub_string = f'\u3010{row.Code}\u3011{row.Strategy}'\n            tb.at[index, 'OpenReason'] = row.OpenReason.replace(\n                sub_string, '').replace('-', '')\n            tb.at[index, 'CloseReason'] = row.CloseReason.replace(\n                sub_string, '').replace('-', '')\n        return tb\n\n    else:\n        df.OpenAmount = df.OpenAmount.astype('int64')\n        df.CloseAmount = df.CloseAmount.astype('int64')\n        df.ClosePrice = df.ClosePrice.round(2)\n\n        if kwargs['market'] == 'Stocks':\n            netOpenAmount = (df.OpenAmount + df.OpenFee)\n            netCloseAmount = (df.CloseAmount - df.CloseFee - df.Tax)\n            df['profit'] = (netCloseAmount - netOpenAmount).astype('int64')\n            df['returns'] = (\n                100*(df.CloseAmount/df.OpenAmount - 1)).round(2)\n        else:\n            sign = 1 if kwargs['isLong'] else -1\n\n            df['profit'] = (df.ClosePrice - df.OpenPrice)*df.CloseQuantity\n            totalExpense = (df.OpenFee + df.CloseFee + df.Tax)*sign\n            df.profit = df.profit*kwargs['multipler'] - totalExpense\n            df['returns'] = (\n                sign*100*((df.ClosePrice/df.OpenPrice)**sign - 1)).round(2)\n\n        df.profit = df.profit.round()\n        df['iswin'] = df.profit > 0\n\n        if not kwargs['isLong']:\n            df.profit *= -1\n            df.returns *= -1\n        df['balance'] = init_position + df.profit.cumsum()\n\n        return df", "\n\ndef convert_statement(df, mode='trading', **kwargs):\n    def extract_strategy(msg):\n        for s in StrategyList.All:\n            if s in msg:\n                return s\n        return 'Unknown'\n\n    if not df.shape[0]:\n        return df\n\n    init_position = kwargs.get('init_position', 1000000)\n    if mode == 'trading':\n        df = df.rename(columns={\n            'code': 'Code',\n            'price': 'Price',\n            'quantity': 'Quantity',\n            'msg': 'Reason',\n            'amount': 'Amount'\n        })\n        df['Strategy'] = df.Reason.apply(extract_strategy)\n        df['isLong'] = df.Strategy.apply(lambda x: x in StrategyList.Long)\n        df['isShort'] = df.isLong == False\n        df['isOpen'] = (\n            ((df.isLong == True) & (df.action == 'Buy')) |\n            ((df.isShort == True) & (df.action == 'Sell'))\n        )\n\n        target_columns1 = ['Strategy', 'Code', 'isLong', 'isShort']\n        target_columns2 = ['Time', 'Price', 'Quantity', 'Amount', 'Reason']\n        tb1 = df[df.isOpen == True][target_columns1 + target_columns2]\n        tb1.columns = target_columns1 + ['Open' + c for c in target_columns2]\n\n        tb2 = df[df.isOpen == False][target_columns1 + target_columns2]\n        tb2.columns = target_columns1 + ['Close' + c for c in target_columns2]\n\n        tb = pd.concat([tb1, tb2]).sort_index()\n        tb.CloseAmount = tb.CloseAmount.abs()\n        tb.OpenQuantity = tb.OpenQuantity.fillna(tb.CloseQuantity)\n        for c in ['Time', 'Price', 'Amount', 'Reason']:\n            col = f'Open{c}'\n            tb[col] = tb.groupby('Code')[col].fillna(method='ffill')\n\n        tb['OpenAmount'] = (tb.OpenPrice*tb.OpenQuantity).abs()\n        tb['CloseAmount'] = (tb.ClosePrice*tb.CloseQuantity).abs()\n        tb['profit'] = (tb.CloseAmount - tb.OpenAmount)*(tb.isShort*(-2)+1)\n        tb['returns'] = 100*(tb.profit/tb.OpenAmount).round(4)\n        tb['balance'] = init_position + tb.profit.cumsum()\n        tb = tb.dropna().reset_index(drop=True)\n\n        for index, row in tb.iterrows():\n            sub_string = f'\u3010{row.Code}\u3011{row.Strategy}'\n            tb.at[index, 'OpenReason'] = row.OpenReason.replace(\n                sub_string, '').replace('-', '')\n            tb.at[index, 'CloseReason'] = row.CloseReason.replace(\n                sub_string, '').replace('-', '')\n        return tb\n\n    else:\n        df.OpenAmount = df.OpenAmount.astype('int64')\n        df.CloseAmount = df.CloseAmount.astype('int64')\n        df.ClosePrice = df.ClosePrice.round(2)\n\n        if kwargs['market'] == 'Stocks':\n            netOpenAmount = (df.OpenAmount + df.OpenFee)\n            netCloseAmount = (df.CloseAmount - df.CloseFee - df.Tax)\n            df['profit'] = (netCloseAmount - netOpenAmount).astype('int64')\n            df['returns'] = (\n                100*(df.CloseAmount/df.OpenAmount - 1)).round(2)\n        else:\n            sign = 1 if kwargs['isLong'] else -1\n\n            df['profit'] = (df.ClosePrice - df.OpenPrice)*df.CloseQuantity\n            totalExpense = (df.OpenFee + df.CloseFee + df.Tax)*sign\n            df.profit = df.profit*kwargs['multipler'] - totalExpense\n            df['returns'] = (\n                sign*100*((df.ClosePrice/df.OpenPrice)**sign - 1)).round(2)\n\n        df.profit = df.profit.round()\n        df['iswin'] = df.profit > 0\n\n        if not kwargs['isLong']:\n            df.profit *= -1\n            df.returns *= -1\n        df['balance'] = init_position + df.profit.cumsum()\n\n        return df", "\n\ndef compute_profits(tb):\n    total_profit = tb.profit.sum()\n    df_profit = tb[tb.profit > 0]\n    df_loss = tb[tb.profit <= 0]\n\n    has_profits = df_profit.shape[0]\n    has_loss = df_loss.shape[0]\n\n    # \u6bdb\u5229/\u6bdb\u640d\n    gross_profit = df_profit.profit.sum() if has_profits else 0\n    gross_loss = df_loss.profit.sum() if has_loss else 0\n    profit_factor = round(\n        abs(gross_profit/gross_loss), 2) if gross_loss else np.inf\n    if total_profit < 0:\n        profit_factor *= -1\n\n    # \u5e73\u5747\u7372\u5229/\u8667\u640d\u91d1\u984d\n    mean_profit = df_profit.profit.mean() if has_profits else 0\n    mean_loss = df_loss.profit.mean() if has_loss else 0\n    max_profit = df_profit.profit.max() if has_profits else 0\n    max_loss = df_loss.profit.min() if has_loss else 0\n\n    ratio1 = round(abs(mean_profit/mean_loss), 4) if mean_loss else np.inf\n    profits = {\n        'TotalProfit': round(total_profit),\n        'GrossProfit': round(gross_profit),\n        'GrossLoss': round(gross_loss),\n        'MeanProfit': round(mean_profit if mean_profit else 0),\n        'MeanLoss': round(mean_loss if mean_loss else 0),\n        'MaxProfit': max_profit,\n        'MaxLoss': max_loss,\n        'ProfitFactor': profit_factor,\n        'ProfitRatio': ratio1\n    }\n\n    if 'KRun' in tb.columns:\n        profits.update({\n            'KRunProfit': round(df_profit.KRun.mean(), 1) if has_profits else 0,\n            'KRunLoss': round(df_loss.KRun.mean(), 1) if has_loss else 0\n        })\n    else:\n        profits.update({\n            'KRunProfit': None,\n            'KRunLoss': None\n        })\n\n    return profits", "\n\ndef computeReturn(df, target1, target2):\n    if df.shape[0] and target1 in df.columns and target2 in df.columns:\n        start = df[target1].values[0]\n        end = df[target2].values[-1]\n        return 100*round(end/start - 1, 2)\n    return 0\n\n\ndef computeWinLoss(df: pd.DataFrame):\n    '''Count wins and losses'''\n    win_loss = (df.profit > 0).value_counts().to_dict()\n    if True not in win_loss:\n        win_loss[True] = 0\n\n    if False not in win_loss:\n        win_loss[False] = 0\n\n    return win_loss", "\n\ndef computeWinLoss(df: pd.DataFrame):\n    '''Count wins and losses'''\n    win_loss = (df.profit > 0).value_counts().to_dict()\n    if True not in win_loss:\n        win_loss[True] = 0\n\n    if False not in win_loss:\n        win_loss[False] = 0\n\n    return win_loss", ""]}
{"filename": "trader/performance/backtest.py", "chunked_list": ["import time\nimport numpy as np\nimport pandas as pd\nfrom typing import Union\nfrom datetime import datetime\nfrom collections import namedtuple\n\nfrom .base import (\n    AccountingNumber,\n    compute_profits,", "    AccountingNumber,\n    compute_profits,\n    computeReturn,\n    computeWinLoss,\n    convert_statement\n)\nfrom .. import file_handler\nfrom ..config import PATH, TODAY_STR\nfrom ..utils import progress_bar\nfrom ..utils.time import TimeTool", "from ..utils import progress_bar\nfrom ..utils.time import TimeTool\nfrom ..utils.file import FileHandler\nfrom ..utils.kbar import KBarTool\nfrom ..utils.crawler import readStockList\nfrom ..utils.database import db, KBarTables\n\n\nclass BacktestPerformance(FileHandler):\n    def __init__(self, config) -> None:\n        self.Market = config.market\n        self.scale = config.scale\n        self.LEVERAGE_INTEREST = 0.075*(config.leverage != 1)\n        self.leverage = 1/config.leverage\n        self.margin = config.margin\n        self.multipler = config.multipler\n        self.mode = config.mode.lower()\n\n        self.DATAPATH = f'{PATH}/backtest'\n        self.ResultInfo = namedtuple(\n            typename=\"TestResult\",\n            field_names=['Configuration', 'Summary', 'Statement', 'DailyInfo'],\n            defaults=[None]*4\n        )\n\n    def process_daily_info(self, df: pd.DataFrame, **result):\n        '''update daily info table'''\n        profit = df.groupby('CloseTime').profit.sum().to_dict()\n        nOpen = df.groupby('OpenTime').Code.count().to_dict()\n\n        daily_info = result['daily_info'].copy()\n        init_position = result.get('init_position', 1000000)\n        profit = pd.Series(daily_info.index).map(profit).fillna(0).cumsum()\n        daily_info['balance'] = init_position + profit.values\n        daily_info['nOpen'] = daily_info.index.map(nOpen).fillna(0)\n        daily_info = daily_info.dropna()\n        if self.Market != 'Stocks':\n            for c in ['TSEopen', 'TSEclose', 'OTCopen', 'OTCclose']:\n                daily_info[c] = 1\n        return daily_info\n\n    def getMDD(self, df: pd.DataFrame):\n        tb = df[['CloseTime', 'balance']].copy()\n        tb.set_index(pd.to_datetime(tb['CloseTime']), inplace=True)\n        tb.drop('CloseTime', axis=1, inplace=True)\n\n        # Reference:\n        # https://github.com/pyinvest/quant_basic_toturial/blob/master/quant/16_Max_drawdown.ipynb\n        dr = tb.pct_change(1)\n        r = dr.add(1).cumprod()\n        dd = r.div(r.cummax()).sub(1)\n\n        if dd.shape[0] > 1:\n            mdd = dd.min()\n            end = dd.idxmin()\n            start = r.loc[:end[0]].idxmax()\n            days = end - start\n            result = {\n                'MDD': mdd[0],\n                'Start': start[0],\n                'End': end[0],\n                'Days': days[0],\n                'TotalLoss': df[(df.CloseTime >= start[0]) & (df.CloseTime <= end[0])].profit.sum()\n            }\n            return result\n        return {}\n\n    def get_max_profit_loss_days(self, statement: pd.DataFrame):\n        '''\n        \u8a08\u7b97\u6700\u5927\u9023\u7e8c\u7372\u5229/\u640d\u5931\u5929\u6578\n        \u53c3\u6578:\n        statement - \u56de\u6e2c\u4ea4\u6613\u660e\u7d30\n        scale - \u56de\u6e2c\u7684k\u68d2\u983b\u7387\n        '''\n\n        def count_profits(is_profit):\n            condition = profits.is_profit == is_profit\n            counts = profits[condition].groupby('labels').profit.count()\n\n            if not counts.shape[0]:\n                return {\n                    'start': '1900-01-01',\n                    'end': '1900-01-01',\n                    'n': 0,\n                    'amount': 0\n                }\n\n            count_max = counts[counts == counts.max()].index[0]\n            result = profits[profits.labels == count_max]\n            return {\n                'start': str(result.CloseTime.min()).split(' ')[0],\n                'end': str(result.CloseTime.max()).split(' ')[0],\n                'n': result.shape[0],\n                'amount': result.profit.sum().astype(int)\n            }\n\n        profits = statement.copy()\n\n        if self.scale != '1D':\n            profits.CloseTime = profits.CloseTime.dt.date\n\n        profits = profits.groupby('CloseTime').profit.sum().reset_index()\n        profits['is_profit'] = (profits.profit > 0).astype(int)\n\n        isprofit = profits.is_profit.values\n        labels = []\n\n        n = 1\n        for i, p in enumerate(isprofit):\n            if i != 0 and p != isprofit[i-1]:\n                n = n + 1\n\n            labels.append(n)\n\n        profits['labels'] = labels\n\n        max_positives = count_profits(is_profit=1)\n        max_negagives = count_profits(is_profit=0)\n        return max_positives, max_negagives\n\n    def get_backtest_result(self, **result):\n        '''\u53d6\u5f97\u56de\u6e2c\u5831\u544a'''\n\n        init_position = result.get('init_position', 1000000)\n        configs = {\n            '\u8d77\u59cb\u8cc7\u91d1': AccountingNumber(init_position),\n            '\u505a\u591a/\u505a\u7a7a': self.mode,\n            '\u69d3\u687f\u500d\u6578': self.leverage,\n            '\u9032\u5834\u9806\u5e8f': result.get('buyOrder', 'Close')\n        }\n        if isinstance(result['statement'], list):\n            df = pd.DataFrame(result['statement'])\n            df = convert_statement(\n                df,\n                mode='backtest',\n                **result,\n                market=self.Market,\n                multipler=self.multipler\n            )\n        else:\n            df = result['statement'].copy()\n            df['KRun'] = -1  # TODO\n\n        if df.shape[0]:\n\n            start = str(df.OpenTime.min().date())\n            end = str(df.CloseTime.max().date())\n\n            win_loss = computeWinLoss(df)\n\n            if 'daily_info' in result:\n                Kbars = result.get('Kbars')\n                result['daily_info'] = self.process_daily_info(df, **result)\n\n                # TSE \u6f32\u8dcc\u5e45\n                tse_return = computeReturn(Kbars['1D'], 'TSEopen', 'TSEclose')\n\n                # OTC \u6f32\u8dcc\u5e45\n                otc_return = computeReturn(Kbars['1D'], 'OTCopen', 'OTCclose')\n            else:\n                result['daily_info'] = None\n                if db.HAS_DB:\n                    table = KBarTables[self.scale]\n                    table = db.query(\n                        table,\n                        table.Time >= df.OpenTime.min(),\n                        table.Time <= df.CloseTime.max(),\n                    )\n                else:\n                    dir_path = f'{PATH}/KBars/{self.scale}'\n                    table = self.read_tables_in_folder(dir_path)\n                    table = table[\n                        (table.Time >= df.OpenTime.min()) &\n                        (table.Time <= df.CloseTime.max())\n                    ]\n\n                df_TSE = table[table.name == '1']\n                df_OTC = table[table.name == '101']\n\n                tse_return = computeReturn(df_TSE, 'Open', 'Close')\n                otc_return = computeReturn(df_OTC, 'Open', 'Close')\n\n            # \u7e3d\u5831\u916c\u7387\n            profits = compute_profits(df)\n            balance = init_position + profits['TotalProfit']\n            total_return = balance/init_position\n\n            # \u5e74\u5316\u5831\u916c\u7387\n            days = (df.CloseTime.max() - df.OpenTime.min()).days\n            if days:\n                anaualized_return = 100*round(total_return**(365/days) - 1, 2)\n            else:\n                anaualized_return = 0\n\n            if df.shape[0] >= 5:\n                std = df.balance.rolling(5).std().median()\n            else:\n                std = 0\n\n            mdd_data = self.getMDD(df)\n            if mdd_data:\n                mdd = f\"{AccountingNumber(mdd_data['TotalLoss'])}({100*round(mdd_data['MDD'], 6)}%)\"\n                mddTimes = f\"{mdd_data['Start']} ~ {mdd_data['End']}\uff0c\u5171{mdd_data['Days']}\u5929\"\n            else:\n                mdd = 0\n                mddTimes = '\u7121'\n\n            # \u6458\u8981\n            summary = pd.DataFrame([{\n                '\u671f\u672b\u8cc7\u91d1': AccountingNumber(round(balance)),\n                '\u6bdb\u5229': AccountingNumber(profits['GrossProfit']),\n                '\u6bdb\u640d': AccountingNumber(profits['GrossLoss']),\n                '\u6de8\u5229': AccountingNumber(profits['TotalProfit']),\n                '\u5e73\u5747\u7372\u5229': AccountingNumber(profits['MeanProfit']),\n                '\u5e73\u5747\u8667\u640d': AccountingNumber(profits['MeanLoss']),\n                '\u6de8\u503c\u6ce2\u52d5\u5ea6': AccountingNumber(round(std)),\n                '\u7e3d\u5831\u916c(\u8207\u5927\u76e4\u6bd4\u8f03)': f\"{round(100*(total_return - 1), 2)}%\",\n                '\u6307\u6578\u5831\u916c(TSE/OTC)': f\"{tse_return}%/{otc_return}%\",\n                '\u5e74\u5316\u5831\u916c\u7387': f\"{AccountingNumber(anaualized_return)}%\",\n                '\u6700\u5927\u55ae\u7b46\u7372\u5229': AccountingNumber(profits['MaxProfit']),\n                '\u6700\u5927\u55ae\u7b46\u8667\u640d': AccountingNumber(profits['MaxLoss']),\n                'MDD': mdd,\n                'MDD\u671f\u9593': mddTimes,\n                '\u5168\u90e8\u5e73\u5747\u6301\u5009K\u7dda\u6578': round(df.KRun.mean(), 1),\n                '\u7372\u5229\u5e73\u5747\u6301\u5009K\u7dda\u6578': profits['KRunProfit'],\n                '\u8667\u640d\u5e73\u5747\u6301\u5009K\u7dda\u6578': profits['KRunLoss'],\n                '\u7372\u5229\u4ea4\u6613\u7b46\u6578': win_loss[True],\n                '\u8667\u640d\u4ea4\u6613\u7b46\u6578': win_loss[False],\n                '\u7e3d\u4ea4\u6613\u7b46\u6578': df.shape[0],\n                '\u52dd\u7387': f\"{round(100*win_loss[True]/df.shape[0], 2)}%\",\n                '\u7372\u5229\u56e0\u5b50': profits['ProfitFactor'],\n                '\u76c8\u8667\u6bd4': profits['ProfitRatio'],\n            }]).T.reset_index()\n            summary.columns = ['Content', 'Description']\n\n        else:\n            print('\u7121\u4ea4\u6613\u7d00\u9304')\n            start = str(result['startDate'].date())\n            end = str(result['endDate'].date())\n            summary, df = None, None\n\n        configs.update({'\u4ea4\u6613\u958b\u59cb\u65e5': start, '\u4ea4\u6613\u7d50\u675f\u65e5': end})\n        configs = pd.DataFrame([configs]).T.reset_index()\n        configs.columns = ['Content', 'Description']\n        return self.ResultInfo(configs, summary, df, result['daily_info'])\n\n    def generate_tb_reasons(self, statement):\n        '''\u9032\u51fa\u5834\u539f\u56e0\u7d71\u8a08\u8868'''\n\n        aggs = {'Code': 'count', 'iswin': 'sum', 'profit': ['sum', 'mean']}\n        df = statement.groupby(['OpenReason', 'CloseReason']).agg(aggs)\n        df = df.unstack(0).reset_index()\n        df = df.T.reset_index(level=[0, 1], drop=True).T\n\n        openReasons = list(np.unique(list(df.columns[1:])))\n        p = len(openReasons)\n\n        df.insert(p+1, 'total_count', df.fillna(0).iloc[:, 1:p+1].sum(axis=1))\n        df.insert(\n            2*p+2, 'total_win', df.fillna(0).iloc[:, p+2:2*p+2].sum(axis=1))\n        for i in range(p):\n            df.insert(\n                2*p+3+i, f'win_{openReasons[i]}', 100*df.iloc[:, p+2+i]/df.iloc[:, 1+i])\n\n        df = df.fillna(0)\n\n        sums = df.sum().values\n        for i in range(p):\n            sums[2*p+3+i] = round(100*sums[p+2+i]/sums[1+i], 2)\n            sums[4*p+3+i] = round(sums[3*p+3+i]/sums[1+i])\n        df = pd.concat([df, pd.DataFrame(sums, index=df.columns).T])\n\n        for i in range(1, df.shape[1]):\n            if 0 < i - 2*(p+1) <= p:\n                df.iloc[:, i] = df.iloc[:, i].astype(float).round(2)\n            else:\n                df.iloc[:, i] = df.iloc[:, i].astype(int)\n\n        columns1 = ['OpenReason'] + (openReasons + ['\u52a0\u7e3d'])*2 + openReasons*3\n        columns2 = ['CloseReason'] + ['\u7b46\u6578']*(p+1) + ['\u7372\u5229\u7b46\u6578'] * \\\n            (p+1) + ['\u52dd\u7387']*p + ['\u7e3d\u7372\u5229']*p + ['\u5e73\u5747\u7372\u5229']*p\n        df.columns = pd.MultiIndex.from_arrays([columns1, columns2])\n        df.iloc[-1, 0] = 'Total'\n        return df\n\n    def generate_win_rates(self, statement):\n        '''\u500b\u80a1\u52dd\u7387\u7d71\u8a08'''\n        group = statement.groupby('Code')\n        win_rates = group.iswin.sum().reset_index()\n        win_rates['total_deals'] = group.Code.count().values\n        win_rates['win_rate'] = win_rates.iswin/win_rates.total_deals\n        return win_rates\n\n    def save_result(self, TestResult):\n        '''\u5132\u5b58\u56de\u6e2c\u5831\u544a'''\n\n        win_rates = self.generate_win_rates(TestResult.Statement)\n        reasons = self.generate_tb_reasons(TestResult.Statement)\n\n        writer = pd.ExcelWriter(\n            f'{self.DATAPATH}/{TODAY_STR}-backtest.xlsx', engine='xlsxwriter')\n        TestResult.Configuration.to_excel(\n            writer, index=False, sheet_name='Backtest Settings')\n        TestResult.Summary.to_excel(\n            writer, index=False, sheet_name='Summary')\n        TestResult.Statement.to_excel(\n            writer, index=False,  sheet_name='Transaction Detail')\n        reasons.to_excel(writer, sheet_name='Transaction Reasons')\n        win_rates.to_excel(writer, index=False, sheet_name='Win Rate')\n        writer.save()", "class BacktestPerformance(FileHandler):\n    def __init__(self, config) -> None:\n        self.Market = config.market\n        self.scale = config.scale\n        self.LEVERAGE_INTEREST = 0.075*(config.leverage != 1)\n        self.leverage = 1/config.leverage\n        self.margin = config.margin\n        self.multipler = config.multipler\n        self.mode = config.mode.lower()\n\n        self.DATAPATH = f'{PATH}/backtest'\n        self.ResultInfo = namedtuple(\n            typename=\"TestResult\",\n            field_names=['Configuration', 'Summary', 'Statement', 'DailyInfo'],\n            defaults=[None]*4\n        )\n\n    def process_daily_info(self, df: pd.DataFrame, **result):\n        '''update daily info table'''\n        profit = df.groupby('CloseTime').profit.sum().to_dict()\n        nOpen = df.groupby('OpenTime').Code.count().to_dict()\n\n        daily_info = result['daily_info'].copy()\n        init_position = result.get('init_position', 1000000)\n        profit = pd.Series(daily_info.index).map(profit).fillna(0).cumsum()\n        daily_info['balance'] = init_position + profit.values\n        daily_info['nOpen'] = daily_info.index.map(nOpen).fillna(0)\n        daily_info = daily_info.dropna()\n        if self.Market != 'Stocks':\n            for c in ['TSEopen', 'TSEclose', 'OTCopen', 'OTCclose']:\n                daily_info[c] = 1\n        return daily_info\n\n    def getMDD(self, df: pd.DataFrame):\n        tb = df[['CloseTime', 'balance']].copy()\n        tb.set_index(pd.to_datetime(tb['CloseTime']), inplace=True)\n        tb.drop('CloseTime', axis=1, inplace=True)\n\n        # Reference:\n        # https://github.com/pyinvest/quant_basic_toturial/blob/master/quant/16_Max_drawdown.ipynb\n        dr = tb.pct_change(1)\n        r = dr.add(1).cumprod()\n        dd = r.div(r.cummax()).sub(1)\n\n        if dd.shape[0] > 1:\n            mdd = dd.min()\n            end = dd.idxmin()\n            start = r.loc[:end[0]].idxmax()\n            days = end - start\n            result = {\n                'MDD': mdd[0],\n                'Start': start[0],\n                'End': end[0],\n                'Days': days[0],\n                'TotalLoss': df[(df.CloseTime >= start[0]) & (df.CloseTime <= end[0])].profit.sum()\n            }\n            return result\n        return {}\n\n    def get_max_profit_loss_days(self, statement: pd.DataFrame):\n        '''\n        \u8a08\u7b97\u6700\u5927\u9023\u7e8c\u7372\u5229/\u640d\u5931\u5929\u6578\n        \u53c3\u6578:\n        statement - \u56de\u6e2c\u4ea4\u6613\u660e\u7d30\n        scale - \u56de\u6e2c\u7684k\u68d2\u983b\u7387\n        '''\n\n        def count_profits(is_profit):\n            condition = profits.is_profit == is_profit\n            counts = profits[condition].groupby('labels').profit.count()\n\n            if not counts.shape[0]:\n                return {\n                    'start': '1900-01-01',\n                    'end': '1900-01-01',\n                    'n': 0,\n                    'amount': 0\n                }\n\n            count_max = counts[counts == counts.max()].index[0]\n            result = profits[profits.labels == count_max]\n            return {\n                'start': str(result.CloseTime.min()).split(' ')[0],\n                'end': str(result.CloseTime.max()).split(' ')[0],\n                'n': result.shape[0],\n                'amount': result.profit.sum().astype(int)\n            }\n\n        profits = statement.copy()\n\n        if self.scale != '1D':\n            profits.CloseTime = profits.CloseTime.dt.date\n\n        profits = profits.groupby('CloseTime').profit.sum().reset_index()\n        profits['is_profit'] = (profits.profit > 0).astype(int)\n\n        isprofit = profits.is_profit.values\n        labels = []\n\n        n = 1\n        for i, p in enumerate(isprofit):\n            if i != 0 and p != isprofit[i-1]:\n                n = n + 1\n\n            labels.append(n)\n\n        profits['labels'] = labels\n\n        max_positives = count_profits(is_profit=1)\n        max_negagives = count_profits(is_profit=0)\n        return max_positives, max_negagives\n\n    def get_backtest_result(self, **result):\n        '''\u53d6\u5f97\u56de\u6e2c\u5831\u544a'''\n\n        init_position = result.get('init_position', 1000000)\n        configs = {\n            '\u8d77\u59cb\u8cc7\u91d1': AccountingNumber(init_position),\n            '\u505a\u591a/\u505a\u7a7a': self.mode,\n            '\u69d3\u687f\u500d\u6578': self.leverage,\n            '\u9032\u5834\u9806\u5e8f': result.get('buyOrder', 'Close')\n        }\n        if isinstance(result['statement'], list):\n            df = pd.DataFrame(result['statement'])\n            df = convert_statement(\n                df,\n                mode='backtest',\n                **result,\n                market=self.Market,\n                multipler=self.multipler\n            )\n        else:\n            df = result['statement'].copy()\n            df['KRun'] = -1  # TODO\n\n        if df.shape[0]:\n\n            start = str(df.OpenTime.min().date())\n            end = str(df.CloseTime.max().date())\n\n            win_loss = computeWinLoss(df)\n\n            if 'daily_info' in result:\n                Kbars = result.get('Kbars')\n                result['daily_info'] = self.process_daily_info(df, **result)\n\n                # TSE \u6f32\u8dcc\u5e45\n                tse_return = computeReturn(Kbars['1D'], 'TSEopen', 'TSEclose')\n\n                # OTC \u6f32\u8dcc\u5e45\n                otc_return = computeReturn(Kbars['1D'], 'OTCopen', 'OTCclose')\n            else:\n                result['daily_info'] = None\n                if db.HAS_DB:\n                    table = KBarTables[self.scale]\n                    table = db.query(\n                        table,\n                        table.Time >= df.OpenTime.min(),\n                        table.Time <= df.CloseTime.max(),\n                    )\n                else:\n                    dir_path = f'{PATH}/KBars/{self.scale}'\n                    table = self.read_tables_in_folder(dir_path)\n                    table = table[\n                        (table.Time >= df.OpenTime.min()) &\n                        (table.Time <= df.CloseTime.max())\n                    ]\n\n                df_TSE = table[table.name == '1']\n                df_OTC = table[table.name == '101']\n\n                tse_return = computeReturn(df_TSE, 'Open', 'Close')\n                otc_return = computeReturn(df_OTC, 'Open', 'Close')\n\n            # \u7e3d\u5831\u916c\u7387\n            profits = compute_profits(df)\n            balance = init_position + profits['TotalProfit']\n            total_return = balance/init_position\n\n            # \u5e74\u5316\u5831\u916c\u7387\n            days = (df.CloseTime.max() - df.OpenTime.min()).days\n            if days:\n                anaualized_return = 100*round(total_return**(365/days) - 1, 2)\n            else:\n                anaualized_return = 0\n\n            if df.shape[0] >= 5:\n                std = df.balance.rolling(5).std().median()\n            else:\n                std = 0\n\n            mdd_data = self.getMDD(df)\n            if mdd_data:\n                mdd = f\"{AccountingNumber(mdd_data['TotalLoss'])}({100*round(mdd_data['MDD'], 6)}%)\"\n                mddTimes = f\"{mdd_data['Start']} ~ {mdd_data['End']}\uff0c\u5171{mdd_data['Days']}\u5929\"\n            else:\n                mdd = 0\n                mddTimes = '\u7121'\n\n            # \u6458\u8981\n            summary = pd.DataFrame([{\n                '\u671f\u672b\u8cc7\u91d1': AccountingNumber(round(balance)),\n                '\u6bdb\u5229': AccountingNumber(profits['GrossProfit']),\n                '\u6bdb\u640d': AccountingNumber(profits['GrossLoss']),\n                '\u6de8\u5229': AccountingNumber(profits['TotalProfit']),\n                '\u5e73\u5747\u7372\u5229': AccountingNumber(profits['MeanProfit']),\n                '\u5e73\u5747\u8667\u640d': AccountingNumber(profits['MeanLoss']),\n                '\u6de8\u503c\u6ce2\u52d5\u5ea6': AccountingNumber(round(std)),\n                '\u7e3d\u5831\u916c(\u8207\u5927\u76e4\u6bd4\u8f03)': f\"{round(100*(total_return - 1), 2)}%\",\n                '\u6307\u6578\u5831\u916c(TSE/OTC)': f\"{tse_return}%/{otc_return}%\",\n                '\u5e74\u5316\u5831\u916c\u7387': f\"{AccountingNumber(anaualized_return)}%\",\n                '\u6700\u5927\u55ae\u7b46\u7372\u5229': AccountingNumber(profits['MaxProfit']),\n                '\u6700\u5927\u55ae\u7b46\u8667\u640d': AccountingNumber(profits['MaxLoss']),\n                'MDD': mdd,\n                'MDD\u671f\u9593': mddTimes,\n                '\u5168\u90e8\u5e73\u5747\u6301\u5009K\u7dda\u6578': round(df.KRun.mean(), 1),\n                '\u7372\u5229\u5e73\u5747\u6301\u5009K\u7dda\u6578': profits['KRunProfit'],\n                '\u8667\u640d\u5e73\u5747\u6301\u5009K\u7dda\u6578': profits['KRunLoss'],\n                '\u7372\u5229\u4ea4\u6613\u7b46\u6578': win_loss[True],\n                '\u8667\u640d\u4ea4\u6613\u7b46\u6578': win_loss[False],\n                '\u7e3d\u4ea4\u6613\u7b46\u6578': df.shape[0],\n                '\u52dd\u7387': f\"{round(100*win_loss[True]/df.shape[0], 2)}%\",\n                '\u7372\u5229\u56e0\u5b50': profits['ProfitFactor'],\n                '\u76c8\u8667\u6bd4': profits['ProfitRatio'],\n            }]).T.reset_index()\n            summary.columns = ['Content', 'Description']\n\n        else:\n            print('\u7121\u4ea4\u6613\u7d00\u9304')\n            start = str(result['startDate'].date())\n            end = str(result['endDate'].date())\n            summary, df = None, None\n\n        configs.update({'\u4ea4\u6613\u958b\u59cb\u65e5': start, '\u4ea4\u6613\u7d50\u675f\u65e5': end})\n        configs = pd.DataFrame([configs]).T.reset_index()\n        configs.columns = ['Content', 'Description']\n        return self.ResultInfo(configs, summary, df, result['daily_info'])\n\n    def generate_tb_reasons(self, statement):\n        '''\u9032\u51fa\u5834\u539f\u56e0\u7d71\u8a08\u8868'''\n\n        aggs = {'Code': 'count', 'iswin': 'sum', 'profit': ['sum', 'mean']}\n        df = statement.groupby(['OpenReason', 'CloseReason']).agg(aggs)\n        df = df.unstack(0).reset_index()\n        df = df.T.reset_index(level=[0, 1], drop=True).T\n\n        openReasons = list(np.unique(list(df.columns[1:])))\n        p = len(openReasons)\n\n        df.insert(p+1, 'total_count', df.fillna(0).iloc[:, 1:p+1].sum(axis=1))\n        df.insert(\n            2*p+2, 'total_win', df.fillna(0).iloc[:, p+2:2*p+2].sum(axis=1))\n        for i in range(p):\n            df.insert(\n                2*p+3+i, f'win_{openReasons[i]}', 100*df.iloc[:, p+2+i]/df.iloc[:, 1+i])\n\n        df = df.fillna(0)\n\n        sums = df.sum().values\n        for i in range(p):\n            sums[2*p+3+i] = round(100*sums[p+2+i]/sums[1+i], 2)\n            sums[4*p+3+i] = round(sums[3*p+3+i]/sums[1+i])\n        df = pd.concat([df, pd.DataFrame(sums, index=df.columns).T])\n\n        for i in range(1, df.shape[1]):\n            if 0 < i - 2*(p+1) <= p:\n                df.iloc[:, i] = df.iloc[:, i].astype(float).round(2)\n            else:\n                df.iloc[:, i] = df.iloc[:, i].astype(int)\n\n        columns1 = ['OpenReason'] + (openReasons + ['\u52a0\u7e3d'])*2 + openReasons*3\n        columns2 = ['CloseReason'] + ['\u7b46\u6578']*(p+1) + ['\u7372\u5229\u7b46\u6578'] * \\\n            (p+1) + ['\u52dd\u7387']*p + ['\u7e3d\u7372\u5229']*p + ['\u5e73\u5747\u7372\u5229']*p\n        df.columns = pd.MultiIndex.from_arrays([columns1, columns2])\n        df.iloc[-1, 0] = 'Total'\n        return df\n\n    def generate_win_rates(self, statement):\n        '''\u500b\u80a1\u52dd\u7387\u7d71\u8a08'''\n        group = statement.groupby('Code')\n        win_rates = group.iswin.sum().reset_index()\n        win_rates['total_deals'] = group.Code.count().values\n        win_rates['win_rate'] = win_rates.iswin/win_rates.total_deals\n        return win_rates\n\n    def save_result(self, TestResult):\n        '''\u5132\u5b58\u56de\u6e2c\u5831\u544a'''\n\n        win_rates = self.generate_win_rates(TestResult.Statement)\n        reasons = self.generate_tb_reasons(TestResult.Statement)\n\n        writer = pd.ExcelWriter(\n            f'{self.DATAPATH}/{TODAY_STR}-backtest.xlsx', engine='xlsxwriter')\n        TestResult.Configuration.to_excel(\n            writer, index=False, sheet_name='Backtest Settings')\n        TestResult.Summary.to_excel(\n            writer, index=False, sheet_name='Summary')\n        TestResult.Statement.to_excel(\n            writer, index=False,  sheet_name='Transaction Detail')\n        reasons.to_excel(writer, sheet_name='Transaction Reasons')\n        win_rates.to_excel(writer, index=False, sheet_name='Win Rate')\n        writer.save()", "\n\nclass BackTester(BacktestPerformance, TimeTool):\n    def __init__(self, script=None):\n        self.set_scripts(script)\n\n        self.isLong = True\n        self.sign = 1\n        self.FEE_RATE = .001425*.65\n        self.TAX_RATE_STOCK = .003\n        self.TAX_RATE_FUTURES = .00002\n        self.TimeCol = 'Time'\n\n        self.indexes = ['1', '101']\n        self.nStocksLimit = 0\n        self.nStocks_high = 20\n        self.day_trades = []\n        self.statements = []\n        self.stocks = {}\n        self.daily_info = {}\n        self.init_balance = 1000000\n        self.balance = self.init_balance\n        self.market_value = self.init_balance\n        self.buyOrder = 'Close'\n        self.Action = namedtuple(\n            typename=\"Action\",\n            field_names=['position', 'reason', 'msg', 'price'],\n            defaults=[0, '', '', 0]\n        )\n\n    def load_datasets(self, start='', end='', dataPath=''):\n        market = self.Script.market\n        if market == 'Stocks':\n            codes = readStockList().code.to_list()\n        else:\n            codes = ['TX']\n        codes += self.indexes\n\n        if not start:\n            start = '2018-07-01'\n\n        if not end:\n            end = TODAY_STR\n\n        dir_path = f'{dataPath if dataPath else PATH}/Kbars/'\n        scales = file_handler.listdir(dir_path)\n\n        Kbars = {scale: None for scale in self.Script.kbarScales}\n        Kbars['1D'] = None\n        for scale in Kbars:\n            scale_ = scale if market == 'Stocks' and scale in scales else '1T'\n\n            if db.HAS_DB:\n                df = db.query(\n                    KBarTables[scale_],\n                    KBarTables[scale_].Time >= start,\n                    KBarTables[scale_].Time <= end,\n                    KBarTables[scale_].name.in_(codes)\n                )\n            else:\n                df = file_handler.read_tables_in_folder(\n                    f'{dir_path}/{scale_}',\n                    pattern=market.lower(),\n                    start=start,\n                    end=end\n                )\n                df = df[\n                    (df.Time >= start) &\n                    (df.Time <= end) &\n                    df.name.isin(codes)\n                ]\n\n            df = df.sort_values(['name', 'Time']).reset_index(drop=True)\n            if market == 'Futures' or scale not in scales:\n                df = KBarTool().convert_kbar(df, scale=scale)\n\n            df['date'] = df.Time.dt.date.astype(str)\n            Kbars[scale] = df\n\n        if hasattr(self.Script, 'extraData'):\n            for dataname, func in self.Script.extraData.items():\n                Kbars[dataname] = func(start=start, end=end, dataPath=dataPath)\n\n        return Kbars\n\n    def addFeatures(self, Kbars: dict):\n        return Kbars\n\n    def selectStocks(self, Kbars: dict):\n        '''\u4f9d\u7167\u7b56\u7565\u9078\u80a1\u689d\u4ef6\u6311\u51fa\u53ef\u9032\u5834\u7684\u80a1\u7968\uff0c\u5fc5\u9808\u65b0\u589e\u4e00\u500b\"isIn\"\u6b04\u4f4d'''\n        return Kbars\n\n    def examineOpen(self, inputs: dict, kbars: dict, **kwargs):\n        '''\u6aa2\u67e5\u9032\u5834\u689d\u4ef6'''\n        return self.Action(100, '\u9032\u5834', 'msg', kbars['1D']['Open'])\n\n    def examineClose(self, inputs: dict, kbars: dict, **kwargs):\n        '''\u6aa2\u67e5\u51fa\u5834\u689d\u4ef6'''\n        if inputs['low'] < inputs['open']:\n            closePrice = inputs['open']\n            return self.Action(100, '\u51fa\u5834', 'msg', closePrice)\n        return self.Action()\n\n    def computeOpenLimit(self, Kbars: dict, **kwargs):\n        '''\u8a08\u7b97\u6bcf\u65e5\u8cb7\u9032\u80a1\u7968\u4e0a\u9650(\u53ef\u505a\u5e7e\u652f)'''\n        return 2000\n\n    def computeOpenUnit(self, Kbars: dict):\n        '''\n        \u8a08\u7b97\u8cb7\u9032\u80a1\u6578\n        \u53c3\u6578:\n        inputs - \u4ea4\u6613\u5224\u65b7\u7576\u4e0b\u7684\u80a1\u7968\u8cc7\u6599(\u958b\u9ad8\u4f4e\u6536\u7b49)\n        '''\n        return 5\n\n    def setVolumeProp(self, market_value: float):\n        '''\u6839\u64da\u6210\u4ea4\u91cf\u6bd4\u4f8b\u8a2d\u5b9a\u9032\u5834\u5f35\u6578'''\n        return 0.025\n\n    def on_set_script_function(self, testScript, attrName):\n        def wrapper(func):\n            if hasattr(testScript, attrName):\n                setattr(self, attrName, func)\n            return func\n        return wrapper\n\n    def set_scripts(self, testScript: object = None):\n        '''\u8a2d\u5b9a\u56de\u6e2c\u8173\u672c'''\n\n        if not testScript:\n            return\n\n        BacktestPerformance.__init__(self, testScript)\n        self.Script = testScript\n        self.isLong = testScript.mode == 'long'\n        self.sign = 1 if self.isLong else -1\n\n        @self.on_set_script_function(testScript, 'addFeatures')\n        def func1(df):\n            return testScript.addFeatures(df)\n\n        @self.on_set_script_function(testScript, 'selectStocks')\n        def func2(df):\n            return testScript.selectStocks(df)\n\n        @self.on_set_script_function(testScript, 'examineOpen')\n        def func3(inputs, kbars, **kwargs):\n            return testScript.examineOpen(inputs, kbars, **kwargs)\n\n        @self.on_set_script_function(testScript, 'examineClose')\n        def func4(inputs, kbars, **kwargs):\n            return testScript.examineClose(inputs, kbars, **kwargs)\n\n        @self.on_set_script_function(testScript, 'computeOpenLimit')\n        def func5(Kbars, **kwargs):\n            return testScript.computeOpenLimit(Kbars, **kwargs)\n\n        @self.on_set_script_function(testScript, 'computeOpenUnit')\n        def func6(inputs):\n            return testScript.computeOpenUnit(inputs)\n\n        @self.on_set_script_function(testScript, 'setVolumeProp')\n        def func7(market_value):\n            return testScript.setVolumeProp(market_value)\n\n    def updateMarketValue(self):\n        '''\u66f4\u65b0\u5eab\u5b58\u5e02\u503c'''\n\n        if self.stocks:\n            amount = sum([\n                self.computeCloseAmount(\n                    s['openPrice'], s['price'], s['quantity'])[1]\n                for s in self.stocks.values()\n            ])\n        else:\n            amount = 0\n\n        self.market_value = self.balance + amount\n\n    def _updateStatement(self, **kwargs):\n        '''\u66f4\u65b0\u4ea4\u6613\u7d00\u9304'''\n        price = kwargs['price']\n        quantity = kwargs['quantity']\n        data = self.stocks[kwargs['stockid']]\n        openPrice = data['openPrice']\n        openamount, amount = self.computeCloseAmount(\n            openPrice, price, quantity)\n        openfee = self.computeFee(openamount)\n        closefee = self.computeFee(amount)\n        interest = self.computeLeverageInterest(\n            kwargs['day'], data['day'], openamount)\n        tax = self.computeTax(openPrice, price, quantity)\n\n        if self.isLong:\n            return_ = data['cum_max_min']/openPrice\n        else:\n            return_ = openPrice/data['cum_max_min']\n\n        self.balance += (amount - closefee - interest - tax)\n        self.statements.append({\n            'Code': kwargs['stockid'],\n            'OpenTime': data['day'],\n            'OpenReason': data['openReason'],\n            'OpenPrice': openPrice,\n            'OpenQuantity': quantity,\n            'OpenAmount': openamount,\n            'OpenFee': openfee,\n            'CloseTime': kwargs['day'],\n            'CloseReason': kwargs['reason'],\n            'ClosePrice': price,\n            'CloseQuantity': quantity,\n            'CloseAmount': amount,\n            'CloseFee': closefee,\n            'Tax': tax,\n            'KRun': data['krun'],\n            'PotentialReturn': 100*round(return_ - 1, 4)\n        })\n\n    def execute(self, trans_type: str, **kwargs):\n        '''\n        \u65b0\u589e/\u66f4\u65b0\u5eab\u5b58\u660e\u7d30\n        trans_type: 'Open' or 'Close'\n        '''\n\n        stockid = kwargs['stockid']\n        day = kwargs['day']\n        price = kwargs['price']\n\n        if trans_type == 'Open':\n            quantity = kwargs['quantity']\n            amount = kwargs['amount']\n            self.balance -= amount\n\n            if stockid not in self.stocks:\n                self.stocks.update({\n                    stockid: {\n                        'day': day,\n                        'openPrice': price,\n                        'quantity': quantity,\n                        'position': 100,\n                        'price': price,\n                        'profit': 1,\n                        'amount': amount,\n                        'openReason': kwargs['reason'],\n                        'krun': 0,\n                        'cum_max_min': kwargs['cum_max_min'],\n                        'bsh': kwargs['bsh']\n                    }\n                })\n            else:\n                self.computeAveragePrice(quantity, price)\n\n        else:\n            quantity = self.computeCloseUnit(stockid, kwargs['position'])\n            kwargs['quantity'] = quantity\n            self._updateStatement(**kwargs)\n            if quantity <= self.stocks[stockid]['quantity']:\n                self.stocks[stockid]['quantity'] -= quantity\n                self.stocks[stockid]['position'] -= kwargs['position']\n\n            if self.stocks[stockid]['quantity'] <= 0:\n                self.stocks.pop(stockid, None)\n                self.nClose += 1\n\n    def get_tick_delta(self, stock_price: float):\n        if stock_price < 10:\n            return 0.01\n        elif stock_price < 50:\n            return 0.05\n        elif stock_price < 100:\n            return 0.1\n        elif stock_price < 500:\n            return 0.5\n        elif stock_price < 1000:\n            return 1\n        return 5\n\n    def computePriceByDev(self, stock_price: float, dev: float):\n        '''\u8a08\u7b97\u771f\u5be6\u80a1\u50f9(By tick price)'''\n\n        tick_delta = self.get_tick_delta(stock_price)\n        return round(int(stock_price*dev/tick_delta)*tick_delta + tick_delta, 2)\n\n    def computeOpenAmount(self, price: float, quantity: int):\n        if self.Market == 'Stocks':\n            return quantity*price*self.leverage\n        return quantity*self.margin\n\n    def computeCloseAmount(self, openPrice: float, closePrice: float, quantity: int):\n        openAmount = self.computeOpenAmount(openPrice, quantity)\n        profit = (closePrice - openPrice)*quantity\n        if self.Market == 'Stocks' and self.leverage == 1:\n            closeAmount = closePrice*quantity\n        elif self.Market == 'Stocks' and self.leverage != 1:\n            closeAmount = openAmount + profit\n        else:\n            closeAmount = openAmount + profit*self.multipler*self.sign\n        return openAmount, closeAmount\n\n    def computeCloseUnit(self, stockid: str, prop: float):\n        '''\u5f9e\u51fa\u5834\u7684\u6bd4\u4f8b%\u63a8\u7b97\u51fa\u5834\u91cf(\u5f35/\u53e3)'''\n        q_balance = self.stocks[stockid]['quantity']\n        position_now = self.stocks[stockid]['position']\n        if prop != 100 and position_now != prop and q_balance > 1000:\n            q_target = q_balance/1000\n            q_target = int(q_target*prop/100)\n\n            if q_target == 0:\n                return 1000\n\n            return min(1000*q_target, q_balance)\n        return q_balance\n\n    def computeFee(self, amount: float):\n        return max(round(amount*self.FEE_RATE), 20)\n\n    def computeAveragePrice(self, stockid: str, quantity: int, price: float):\n        # \u52a0\u78bc\u5f8c\u66f4\u65b0\n        data = self.stocks[stockid]\n        total_quantity = data['quantity'] + quantity\n        total_amount = data['openPrice']*data['quantity'] + price*quantity\n        average_price = round(total_amount/total_quantity, 2)\n\n        self.stocks[stockid].update({\n            'openPrice': average_price,\n            'quantity': total_quantity,\n            'openReason': data['openReason'] + f'<br>{quantity}'\n        })\n\n    def computeTax(self, openPrice: float, closePrice: float, quantity: int):\n        if self.Market == 'Stocks':\n            return round((openPrice*quantity)*self.TAX_RATE_STOCK)\n        return round(closePrice*quantity*self.multipler*self.TAX_RATE_FUTURES)\n\n    def computeLeverageInterest(self, day1: Union[str, datetime], day2: Union[str, datetime], amount: float):\n        if self.leverage == 1:\n            return 0\n\n        d = self.date_diff(day1, day2)\n        return amount*(1 - self.leverage)*self.LEVERAGE_INTEREST*d/365\n\n    def checkOpenUnitLimit(self, unit: float, volume_ma: float):\n        unit = max(round(unit), 0)\n        unit_limit = max(volume_ma*self.volume_prop, 10)\n        unit = int(min(unit, unit_limit)/self.leverage)\n        return min(unit, 2000)  # \u4e0a\u9650 2000 \u5f35\n\n    def checkOpen(self, inputs: dict):\n        '''\n        \u8cb7\u9032\u689d\u4ef6\u5224\u65b7\n        \u53c3\u6578:\n        day - \u4ea4\u6613\u65e5(\u6642\u9593)\n        inputs - \u4ea4\u6613\u5224\u65b7\u7576\u4e0b\u7684\u80a1\u7968\u8cc7\u6599(\u958b\u9ad8\u4f4e\u6536\u7b49)\n        '''\n\n        unit = self.computeOpenUnit(inputs)\n        # if 'volume_ma' in inputs:\n        #     unit = self.checkOpenUnitLimit(unit, inputs['volume_ma'])\n\n        openInfo = self.examineOpen(\n            None,\n            kbars=inputs,\n            market_value=self.market_value,\n            day_trades=self.day_trades\n        )\n\n        if openInfo.price > 0 and unit > 0:\n            name = inputs['name']\n            data = inputs[self.Script.scale][name]\n            if name in self.stocks:\n                # \u52a0\u78bc\u90e8\u4f4d\n                quantity = 1000*(self.stocks[name]['quantity']/1000)/3\n            elif self.Market == 'Stocks':\n                quantity = 1000*unit\n            else:\n                quantity = unit\n\n            amount = self.computeOpenAmount(openInfo.price, quantity)\n            fee = self.computeFee(amount)\n            if self.balance >= amount+fee and len(self.stocks) < self.nStocksLimit:\n                self.execute(\n                    trans_type='Open',\n                    day=data['Time'],\n                    stockid=name,\n                    price=openInfo.price,\n                    quantity=quantity,\n                    position=None,\n                    amount=amount,\n                    cum_max_min=data['High'] if self.isLong else data['Low'],\n                    reason=openInfo.reason,\n                    bsh=data['High']\n                )\n                self.day_trades.append(name)\n\n    def checkMarginCall(self, name: str, closePrice: float):\n        if self.leverage == 1:\n            return False\n\n        openPrice = self.stocks[name]['openPrice']\n        margin = closePrice/(openPrice*(1 - self.leverage))\n        return margin < 1.35\n\n    def checkClose(self, inputs: dict, stocksClosed: dict):\n        name = inputs['name']\n        data = inputs[self.Script.scale][name]\n        value = data['High'] if self.isLong else data['Low']\n        cum_max_min = min(self.stocks[name]['cum_max_min'], value)\n        self.stocks[name].update({\n            'price': data['Close'],\n            'krun': self.stocks[name]['krun'] + 1,\n            'cum_max_min': cum_max_min\n        })\n\n        closeInfo = self.examineClose(\n            inputs=self.stocks,\n            kbars=inputs,\n            stocksClosed=stocksClosed\n        )\n\n        margin_call = self.checkMarginCall(name, closeInfo.price)\n        if closeInfo.position or margin_call:\n            self.execute(\n                trans_type='Close',\n                day=data['Time'],\n                stockid=name,\n                price=closeInfo.price,\n                quantity=None,\n                position=100 if margin_call else closeInfo.position,\n                reason='\u7dad\u6301\u7387<133%' if margin_call else closeInfo.reason\n            )\n\n    def set_open_order(self, df: pd.DataFrame):\n        # by \u6210\u4ea4\u503c\n        if self.buyOrder == 'z_totalamount':\n            df = df.sort_values('z_totalamount')\n\n        # by \u65cf\u7fa4\uff06\u6210\u4ea4\u503c\n        elif self.buyOrder == 'category':\n            name_count = df[df.isIn == True].groupby('category').name.count()\n            name_count = name_count.to_dict()\n            df['n_category'] = df.category.map(name_count).fillna(0)\n            df = df.sort_values(['n_category'], ascending=False)\n        else:\n            df = df.sort_values('Close')\n        return df\n\n    def set_params(self, **params):\n        '''\u53c3\u6578\u8a2d\u5b9a'''\n\n        init_position = params.get('init_position', 1000000)\n        self.balance = self.init_balance = self.market_value = init_position\n        self.buyOrder = params.get('buyOrder', None)\n        self.Kbars = {}\n        self.day_trades = []\n        self.statements = []\n        self.stocks = {}\n        self.daily_info = {}\n\n    def run(self, Kbars: dict, **params):\n        '''\n        \u56de\u6e2c\n        \u53c3\u6578:\n        Kbars - \u6b77\u53f2\u8cc7\u6599\u8868\n        '''\n\n        self.set_params(**params)\n        stocksClosed = {}\n        if hasattr(self, 'Script'):\n            print(f\"Strategy: {self.Script.strategy}{self.Script.scale}\")\n\n        t1 = time.time()\n\n        df = Kbars[self.Script.scale].sort_values('Time')\n        group = df.groupby('Time')\n        N = len(group)\n        for i, (time_, rows) in enumerate(group):\n            self.nClose = 0\n            self.volume_prop = self.setVolumeProp(self.market_value)\n\n            # \u9032\u5834\u9806\u5e8f\n            stockids = list(self.stocks) + self.indexes\n            rows = rows[(rows.isIn == 1) | (rows.name.isin(stockids))]\n            if rows.name.nunique() == 2:\n                continue\n\n            # \u53d6\u51fa\u7576\u5929(\u6216\u67d0\u5c0f\u6642)\u6240\u6709\u80a1\u7968\u8cc7\u8a0a\n            chance = rows.isIn.sum()\n            if rows.nth_bar.min() == 1:\n                day = str(pd.to_datetime(time_).date())\n                tb = Kbars['1D'][Kbars['1D'].date == day]\n                self.Kbars['1D'] = tb.set_index('name').to_dict('index')\n                del tb\n\n                self.nStocksLimit = self.computeOpenLimit(\n                    self.Kbars, day=time_)\n                self.day_trades = []\n\n            # \u6aa2\u67e5\u9032\u5834 & \u51fa\u5834\n            rows = self.set_open_order(rows)\n            rows = rows.set_index('name').to_dict('index')\n            for name, row in rows.items():\n                if name in self.indexes:\n                    continue\n\n                inputs = Kbars.copy()\n                temp = {name: row}\n                temp.update({k: rows[k] for k in self.indexes if k in rows})\n                inputs[self.Script.scale] = temp\n                inputs['name'] = name\n                if '1D' in Kbars:\n                    inputs['1D'] = self.Kbars['1D']\n\n                if name in self.stocks:\n                    self.checkClose(inputs, stocksClosed)\n                else:\n                    self.checkOpen(inputs)\n\n            # \u66f4\u65b0\u4ea4\u6613\u660e\u7d30\u6578\u64da\n            self.daily_info[time_] = {\n                'chance': chance,\n                'n_stock_limit': self.nStocksLimit,\n                'n_stocks': len(self.stocks),\n                'nClose': self.nClose\n            }\n            self.updateMarketValue()\n            progress_bar(N, i)\n\n        t2 = time.time()\n        print(f\"\\nBacktest time: {round(t2-t1, 2)}s\")\n\n        # \u6e05\u7a7a\u5269\u9918\u5eab\u5b58\n        for name in list(self.stocks):\n            self.execute(\n                trans_type='Close',\n                day=time_,\n                stockid=name,\n                price=self.stocks[name]['price'],\n                quantity=None,\n                position=100,\n                reason='\u6e05\u7a7a\u5eab\u5b58'\n            )\n        self.daily_info.update({time_: {'nClose': self.nClose}})\n\n        result = self.get_backtest_result(\n            **params,\n            statement=self.statements,\n            startDate=df.Time.min(),\n            endDate=df.Time.max(),\n            daily_info=pd.DataFrame(self.daily_info).T,\n            isLong=self.isLong,\n            Kbars=Kbars\n        )\n        del df, rows\n        return result", ""]}
{"filename": "trader/performance/__init__.py", "chunked_list": ["import os\nimport sys\n\nfrom ..config import PATH\nfrom .. import file_handler\n\n\nsys.path.append(os.path.abspath(os.path.join('./', os.pardir)))\nfile_handler.create_folder(f'{PATH}/backtest')\n", "file_handler.create_folder(f'{PATH}/backtest')\n"]}
{"filename": "trader/performance/charts.py", "chunked_list": ["import pandas as pd\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\n\ndef convert_encodings(filename):\n    try:\n        f = open(filename, \"r+\")\n        fstr = f.read()\n        ffilter = 'utf-8'\n        fposition = fstr.find(ffilter)\n        f.seek(fposition, 0)\n        f.write('  Big5  ')\n        f.close()\n    except:\n        print(\"\\nCan't convert encoding to Big5\")", "\n\ndef export_figure(fig, filename):\n    if '.html' in fig:\n        fig.write_html(filename)\n    fig.write_image(filename, scale=5)\n\n\nclass SuplotHandler:\n    def add_table(self, fig: make_subplots, df: pd.DataFrame, row: int, col: int, **cellargs):\n        '''Subplot add table'''\n        fig.add_trace(\n            go.Table(\n                header=dict(\n                    values=list(df.columns),\n                    font=dict(size=15),\n                    align=\"center\"\n                ),\n                cells=dict(\n                    values=[df[k].tolist() for k in df.columns],\n                    align=\"center\",\n                    font=dict(size=13),\n                    **cellargs\n                )\n            ),\n            row=row,\n            col=col\n        )\n        return fig\n\n    def add_candlestick(self, fig, df, row, col):\n        if not df.shape[0]:\n            return fig\n\n        title = {'1': 'TWSE', '101': 'OTC'}\n        name = df.name.unique()[0]\n        name = title[name] if name in title else name\n\n        # plot candlestick\n        fig.add_trace(\n            go.Candlestick(\n                x=df.Time,\n                open=df.Open,\n                high=df.High,\n                low=df.Low,\n                close=df.Close,\n                name=name,\n                increasing=dict(line=dict(color='#e63746')),\n                decreasing=dict(line=dict(color='#42dd31')),\n            ),\n            row=row,\n            col=col,\n            secondary_y=True\n        )\n\n        # plot MA\n        for c, d in [('#447a9c', 5), ('#E377C2', 10)]:\n            ma = df.Close.rolling(d).mean().values\n            fig.add_trace(\n                go.Scatter(\n                    x=df.Time,\n                    y=ma,\n                    mode='lines+text',\n                    marker_color=c,\n                    name=f'{d}MA',\n                    text=[\n                        f'{d}MA' if i == d else '' for i, _ in enumerate(ma)],\n                    textfont=dict(color=c),\n                    textposition='bottom right',\n                ),\n                row=row,\n                col=col,\n                secondary_y=True\n            )\n\n        # plot volume\n        colors = [\n            '#d3efd2' if o >= c else '#efd2d8' for o, c in zip(df.Open, df.Close)\n        ]\n        fig.add_trace(\n            go.Bar(\n                x=df.Time,\n                y=df.Volume,\n                marker_color=colors,\n                name='Volume',\n            ),\n            row=row,\n            col=col,\n            secondary_y=False\n        )\n\n        # update axes settings\n        fig.update_xaxes(\n            rangeslider=dict(visible=False),\n            rangebreaks=[\n                dict(bounds=[\"sat\", \"mon\"]),\n                # dict(bounds=[14, 8], pattern=\"hour\"),\n            ],\n            row=row,\n            col=col,\n        )\n        fig.update_yaxes(\n            title=name,\n            secondary_y=True,\n            showgrid=True,\n            tickformat=\".0f\",\n            row=row,\n            col=col\n        )\n        fig.update_yaxes(\n            title=\"Volume\",\n            secondary_y=False,\n            showgrid=False,\n            row=row,\n            col=col\n        )\n        return fig\n\n    def add_line(self, fig: make_subplots, df: pd.DataFrame, row: int, col: int, settings: dict, **kwargs):\n        fig.add_trace(\n            go.Scatter(\n                x=df.index,\n                y=df[settings['y']],\n                mode='lines',\n                name=settings['name'],\n                marker_color=settings['marker_color'],\n                **kwargs\n            ),\n            row=row,\n            col=col\n        )\n        return fig", "class SuplotHandler:\n    def add_table(self, fig: make_subplots, df: pd.DataFrame, row: int, col: int, **cellargs):\n        '''Subplot add table'''\n        fig.add_trace(\n            go.Table(\n                header=dict(\n                    values=list(df.columns),\n                    font=dict(size=15),\n                    align=\"center\"\n                ),\n                cells=dict(\n                    values=[df[k].tolist() for k in df.columns],\n                    align=\"center\",\n                    font=dict(size=13),\n                    **cellargs\n                )\n            ),\n            row=row,\n            col=col\n        )\n        return fig\n\n    def add_candlestick(self, fig, df, row, col):\n        if not df.shape[0]:\n            return fig\n\n        title = {'1': 'TWSE', '101': 'OTC'}\n        name = df.name.unique()[0]\n        name = title[name] if name in title else name\n\n        # plot candlestick\n        fig.add_trace(\n            go.Candlestick(\n                x=df.Time,\n                open=df.Open,\n                high=df.High,\n                low=df.Low,\n                close=df.Close,\n                name=name,\n                increasing=dict(line=dict(color='#e63746')),\n                decreasing=dict(line=dict(color='#42dd31')),\n            ),\n            row=row,\n            col=col,\n            secondary_y=True\n        )\n\n        # plot MA\n        for c, d in [('#447a9c', 5), ('#E377C2', 10)]:\n            ma = df.Close.rolling(d).mean().values\n            fig.add_trace(\n                go.Scatter(\n                    x=df.Time,\n                    y=ma,\n                    mode='lines+text',\n                    marker_color=c,\n                    name=f'{d}MA',\n                    text=[\n                        f'{d}MA' if i == d else '' for i, _ in enumerate(ma)],\n                    textfont=dict(color=c),\n                    textposition='bottom right',\n                ),\n                row=row,\n                col=col,\n                secondary_y=True\n            )\n\n        # plot volume\n        colors = [\n            '#d3efd2' if o >= c else '#efd2d8' for o, c in zip(df.Open, df.Close)\n        ]\n        fig.add_trace(\n            go.Bar(\n                x=df.Time,\n                y=df.Volume,\n                marker_color=colors,\n                name='Volume',\n            ),\n            row=row,\n            col=col,\n            secondary_y=False\n        )\n\n        # update axes settings\n        fig.update_xaxes(\n            rangeslider=dict(visible=False),\n            rangebreaks=[\n                dict(bounds=[\"sat\", \"mon\"]),\n                # dict(bounds=[14, 8], pattern=\"hour\"),\n            ],\n            row=row,\n            col=col,\n        )\n        fig.update_yaxes(\n            title=name,\n            secondary_y=True,\n            showgrid=True,\n            tickformat=\".0f\",\n            row=row,\n            col=col\n        )\n        fig.update_yaxes(\n            title=\"Volume\",\n            secondary_y=False,\n            showgrid=False,\n            row=row,\n            col=col\n        )\n        return fig\n\n    def add_line(self, fig: make_subplots, df: pd.DataFrame, row: int, col: int, settings: dict, **kwargs):\n        fig.add_trace(\n            go.Scatter(\n                x=df.index,\n                y=df[settings['y']],\n                mode='lines',\n                name=settings['name'],\n                marker_color=settings['marker_color'],\n                **kwargs\n            ),\n            row=row,\n            col=col\n        )\n        return fig", ""]}
{"filename": "trader/performance/reports.py", "chunked_list": ["import logging\nimport numpy as np\nimport pandas as pd\nfrom datetime import timedelta\nfrom collections import namedtuple\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\nfrom ..config import PATH, TODAY, TODAY_STR, SelectMethods, StrategyNameList\nfrom ..utils import progress_bar", "from ..config import PATH, TODAY, TODAY_STR, SelectMethods, StrategyNameList\nfrom ..utils import progress_bar\nfrom ..utils.time import TimeTool\nfrom ..utils.file import FileHandler\nfrom ..utils.orders import OrderTool\nfrom ..utils.database import db, KBarTables\nfrom ..utils.database.tables import SelectedStocks\nfrom .base import convert_statement\nfrom .backtest import BacktestPerformance\nfrom .charts import export_figure, convert_encodings, SuplotHandler\ntry:\n    from ..scripts import backtest_config\nexcept:\n    logging.warning('Cannot import test scripts from package.')\n    backtest_config = None", "from .backtest import BacktestPerformance\nfrom .charts import export_figure, convert_encodings, SuplotHandler\ntry:\n    from ..scripts import backtest_config\nexcept:\n    logging.warning('Cannot import test scripts from package.')\n    backtest_config = None\n\n\nclass FiguresSet:\n    pass", "\nclass FiguresSet:\n    pass\n\n\nclass PerformanceReport(SuplotHandler, OrderTool, TimeTool, FileHandler):\n    def __init__(self, account: str):\n        self.set_report_scripts(backtest_config)\n        self.account = account\n        self.TablesFile = f'{PATH}/daily_info/{TODAY_STR[:-3]}-performance-{account}.xlsx'\n        self.Tables = namedtuple(\n            typename='Tables',\n            field_names=['Configuration', 'Summary', 'Statement', 'Selection'],\n            defaults=[None]*4\n        )\n        self.strategies = []\n\n    def set_report_scripts(self, report_scripts: object = None):\n        if report_scripts:\n            bts = report_scripts.__dict__\n            self.Scripts = {\n                k[:-3]: v for k, v in bts.items()\n                if ('T' in k or 'D' in k) and (k[:-3] in SelectMethods)\n            }\n        else:\n            self.Scripts = {}\n\n    def getStrategyList(self, df: pd.DataFrame):\n        '''Get strategy list in code order'''\n\n        strategies = pd.DataFrame([StrategyNameList.Code]).T.reset_index()\n        strategies.columns = ['name', 'code']\n        strategies = strategies[strategies.name.isin(df.Strategy)].name.values\n        return strategies\n\n    def getTables(self, config, start=None, end=None):\n\n        def concat_strategy_table(results: dict, table_name: str):\n            df = pd.DataFrame()\n            for k, v in results.items():\n                if table_name == 'Configuration':\n                    temp = v.Configuration\n                else:\n                    temp = v.Summary\n                temp = temp.rename(\n                    columns={'Description': k}).set_index('Content')\n                df = pd.concat([df, temp], axis=1)\n            return df.reset_index()\n\n        init_position = int(config['INIT_POSITION'])\n\n        df = self.read_statement(f'simulate-{self.account}')\n\n        if not df.shape[0]:\n            return None\n\n        df = convert_statement(df, init_position=init_position)\n\n        # filter data\n        if start is None and end is None:\n            df = df[df.CloseTime.dt.month == TODAY.month]\n        else:\n            if not start:\n                start = TODAY_STR[:-2] + '01'\n\n            if not end:\n                end = TODAY_STR\n\n            df = df[(df.CloseTime >= str(start)) & (df.CloseTime <= str(end))]\n\n        self.strategies = self.getStrategyList(df)\n        results = {}\n        for stra in self.strategies:\n            backtest_config = self.Scripts[stra]\n            bp = BacktestPerformance(backtest_config)\n            statement = df[df.Strategy == stra]\n\n            result = dict(\n                init_position=init_position,\n                unit=int(init_position/100000),\n                buyOrder='Close',\n                statement=statement,\n            )\n            performance = bp.get_backtest_result(**result)\n            results[stra] = performance\n\n        df_config = concat_strategy_table(results, 'Configuration')\n        df_summary = concat_strategy_table(results, 'Summary')\n        return self.Tables(df_config, df_summary, df)\n\n    def save_tables(self, Tables: namedtuple):\n        writer = pd.ExcelWriter(self.TablesFile, engine='xlsxwriter')\n\n        Tables.Configuration.to_excel(\n            writer, encoding='utf-8-sig', index=False, sheet_name='Configuration')\n        Tables.Summary.to_excel(\n            writer, encoding='utf-8-sig', index=False, sheet_name='Summary')\n        Tables.Statement.to_excel(\n            writer, encoding='utf-8-sig', index=False, sheet_name='Statement')\n\n        writer.save()\n\n    def getSelections(self, statement):\n        start = self.last_business_day(statement.OpenTime.values[0])\n        if db.HAS_DB:\n            df = db.query(\n                SelectedStocks,\n                SelectedStocks.Time >= start\n            )\n        else:\n            dir_path = f'{PATH}/selections/history'\n            df = self.read_tables_in_folder(dir_path)\n        df = df[\n            df.Strategy.isin(statement.Strategy) &\n            (df.Time >= start)\n        ]\n        df['isLong'] = df.Strategy.map(\n            statement.set_index('Strategy').isLong.to_dict()\n        )\n        return df\n\n    def getKbarTable(self, df_select: pd.DataFrame):\n        start = df_select.Time.min()\n        end = df_select.Time.max() + timedelta(days=20)\n        names = df_select.code.to_list() + ['1', '101']\n        if db.HAS_DB:\n            df = KBarTables['1D']\n            df = db.query(\n                df,\n                df.Time >= start,\n                df.Time <= end,\n                df.name.in_(names)\n            )\n        else:\n            dir_path = f'{PATH}/KBars/1D'\n            df = self.read_tables_in_folder(dir_path)\n            df = df[\n                (df.Time >= start) &\n                (df.Time <= end) &\n                df.name.isin(names)\n            ]\n        df = df.sort_values(['name', 'Time']).reset_index(drop=True)\n        return df\n\n    def plot_performance_report(self, Tables: namedtuple = None, save=True):\n        if Tables is None:\n            df = pd.read_excel(self.TablesFile, sheet_name='Statement')\n            df_config = pd.read_excel(\n                self.TablesFile, sheet_name='Configuration')\n            df_summary = pd.read_excel(self.TablesFile, sheet_name='Summary')\n            df_summary.iloc[22, 1:] = df_summary.iloc[22, 1:].apply(\n                lambda x: float(x.replace('%', '')))\n        else:\n            df = Tables.Statement\n            df_config = Tables.Configuration\n            df_summary = Tables.Summary\n\n        if not df.shape[0]:\n            return None\n\n        df.OpenTime = df.OpenTime.dt.date\n        df.CloseTime = df.CloseTime.dt.date\n\n        df_select = self.getSelections(df)\n        table = self.getKbarTable(df_select)\n        tb = df_select.drop_duplicates(['code', 'Time', 'isLong'])\n        profits = np.array([0.0]*tb.shape[0])\n        for i, (code, day, is_long) in enumerate(zip(tb.code, tb.Time, tb.isLong)):\n            temp = table[(table.name == code) & (table.Time >= day)].head(5)\n            v1 = temp.Open.values[0]\n            v2 = temp.Close.values[-1]\n            m = 1 if is_long else -1\n            profits[i] = 100*m*(v2-v1)/v1\n\n        tb['profit'] = profits.round(4)\n        tb['profit'].sum()\n\n        # Make Plots\n        subplot_titles = (\n            \"TWSE\",\n            \"OTC\",\n            'Number of Daily Selections',\n            'Accumulated Profits',\n            '5-day Percentage Change After Selection',\n            'Actual Trading Profits',\n            \"Trading Volume\",\n            \"Profit Factor/Profit Ratio\",\n        )\n        specs = [[{'secondary_y': True}]*2] + [[{}, {}]]*3\n        fig = make_subplots(\n            rows=4, cols=2, subplot_titles=subplot_titles, specs=specs)\n\n        if self.strategies == []:\n            self.strategies = self.getStrategyList(df)\n\n        colors = [\n            'rgb(22, 65, 192)',\n            'rgb(16, 154, 246)',\n            'rgb(49, 220, 246)',\n            'rgb(49, 92, 246)',\n            'rgb(49, 122, 246)',\n            'rgb(28, 157, 212)',\n            'rgb(89, 213, 238)',\n            'rgb(49, 246, 240)',\n            'rgb(128, 229, 249)',\n            'rgb(139, 186, 234)',\n        ][:len(self.strategies)]\n\n        # Candlesticks\n        for name, col in [['1', 1], ['101', 2]]:\n            temp = table[table.name == name]\n            fig = self.add_candlestick(fig, temp, 1, col)\n\n        for stra, color in zip(self.strategies, colors):\n            name = StrategyNameList.Code[stra]\n\n            # \u6bcf\u65e5\u9078\u80a1\u6578\n            tb1 = df_select[df_select.Strategy == stra]\n            tb1 = tb1.groupby(['Time', 'Strategy']).code.count()\n            tb1 = tb1.reset_index()\n            max_point = tb1.code.max()\n            fig.add_trace(\n                go.Scatter(\n                    x=tb1.Time,\n                    y=tb1.code,\n                    name=name,\n                    showlegend=False,\n                    marker_color=color,\n                    mode='lines+text',\n                    fill='tonexty',\n                    stackgroup='one',\n                    text=[name if x == max_point else '' for x in tb1.code],\n                    textfont=dict(color='rgb(157, 42, 44)'),\n                    textposition='top center',\n                ),\n                row=2,\n                col=1\n            )\n\n            # \u9078\u80a1\u5f8c5\u5929\u6f32\u5e45(%)\n            fig.add_trace(\n                go.Histogram(\n                    x=tb[tb.Strategy == stra].profit,\n                    name=name,\n                    showlegend=False,\n                    marker_color=color,\n                    nbinsx=50,\n                ),\n                row=3,\n                col=1\n            )\n\n            # \u5be6\u969b\u4ea4\u6613\u7372\u5229(%)\n            tb2 = df[df.Strategy == stra].copy()\n            fig.add_trace(\n                go.Scatter(\n                    x=tb2.returns,\n                    y=tb2.profit,\n                    name=name,\n                    showlegend=False,\n                    marker_color=color,\n                    mode='markers',\n                ),\n                row=3,\n                col=2\n            )\n\n            # \u7d2f\u7a4d\u7372\u5229\n            init_position = int(df_config.loc[0, stra].replace(',', ''))\n            tb2 = tb2.groupby('CloseTime').profit.sum().reset_index()\n            tb2['cumsum_profit'] = 100*(tb2.profit.cumsum()/init_position)\n            max_point = tb2.cumsum_profit.max()\n            fig.add_trace(\n                go.Scatter(\n                    x=tb2.CloseTime,\n                    y=tb2.cumsum_profit,\n                    name=name,\n                    showlegend=False,\n                    marker_color=color,\n                    mode='lines+text',\n                    fill='tozeroy',\n                    text=[name if x == max_point else '' for x in tb2.cumsum_profit],\n                    textfont=dict(color='rgb(157, 42, 44)'),\n                    textposition='top left',\n                ),\n                row=2,\n                col=2\n            )\n\n        # \u4ea4\u6613\u91cf & \u7372\u5229\u56e0\u5b50/\u76c8\u8667\u6bd4\n        colors = [\n            'rgb(252, 193, 74)',\n            'hsl(51, 55%, 82%)',\n            'rgb(245, 126, 0)',\n            'rgb(17, 76, 95)',\n            'rgb(16, 154, 246)'\n        ]\n        for c, i in zip(colors, [17, 18, 19, 21, 22]):\n            tb3 = df_summary.iloc[i, :]\n            fig.add_trace(\n                go.Bar(\n                    x=[StrategyNameList.Code[s] for s in tb3[1:].index],\n                    y=tb3[1:],\n                    showlegend=False,\n                    marker_color=c,\n                ),\n                row=4,\n                col=1 if i < 22 else 2\n            )\n\n        start = df.OpenTime.min()\n        end = df.CloseTime.max()\n        title = f'{start} ~ {end} Trading Performance'\n        fig.update_layout(\n            title=title,\n            title_x=0.5,\n            title_font=dict(size=23),\n            bargap=0.15,\n            height=1500,\n            width=1000\n        )\n        fig.update_yaxes(title='Profit(%)', row=2, col=2)\n        fig.update_xaxes(title='Return(%)', row=3, col=1)\n        fig.update_yaxes(title='Count', row=3, col=1)\n        fig.update_xaxes(title='Return(%)', row=3, col=2)\n        fig.update_yaxes(title='Profit', tickvals=[0], row=3, col=2)\n\n        if save:\n            export_figure(fig, self.TablesFile.replace('xlsx', 'jpg'))\n        return fig", "\n\nclass BacktestReport(SuplotHandler, FileHandler):\n    def __init__(self, backtestScript) -> None:\n        self.Figures = FiguresSet\n        self.Script = backtestScript\n        self.DATAPATH = f'{PATH}/backtest'\n        self.col_maps = {\n            'chance': 'first',\n            'n_stock_limit': 'first',\n            'n_stocks': 'last',\n            'nClose': 'sum',\n            'balance': 'last',\n            'nOpen': 'sum',\n            'profit': 'sum',\n        }\n        self.Titles = (\n            # tables\n            'Backtest Settings', '',\n            'Summary', '',\n            'Transaction Detail', '',\n\n            # candles\n            'TWSE', 'OTC',\n\n            # lines/scatters\n            'Put/Call Ratio', 'Changes in Opens & Closes',\n            'Balance', 'Accumulated Profit/Loss',\n            'Changes in Portfolio Control', ''\n        )\n\n    def _replaceString(self, x: str):\n        return str(x).replace(' ', '<br>').replace('00.000000000', '00')\n\n    def _daily_info_processor(self, TestResult: object):\n        profit = TestResult.Statement.groupby('CloseTime').profit.sum()\n        profit = profit.to_dict()\n\n        df = TestResult.DailyInfo\n        df['profit'] = df.index.map(profit).fillna(0).values\n        df = df.resample('1D', closed='left', label='left').apply(self.col_maps)\n        df = df.dropna()\n        df['profits'] = (df.profit*(df.profit > 0)).cumsum()\n        df['losses'] = (df.profit*(df.profit <= 0)).cumsum()\n        return df\n\n    def plot_backtest_result(self, TestResult: object, Kbars: dict, title=\"Backtest Report\"):\n        '''\u5c07\u56de\u6e2c\u7d50\u679c\u756b\u6210\u5716\u8868'''\n\n        if TestResult.Statement is None:\n            return self.Figures\n\n        statement = TestResult.Statement.copy()\n        statement.OpenTime = statement.OpenTime.apply(self._replaceString)\n        statement.CloseTime = statement.CloseTime.apply(self._replaceString)\n\n        daily_info = self._daily_info_processor(TestResult)\n\n        N = 7\n        n_tables = 3\n        spec1 = [[{\"type\": \"table\", \"colspan\": 2}, {}]]*n_tables  # 3\u5f35\u8868\n        spec2 = [[{'secondary_y': True}]*2]  # TSE & OTC K\u7dda\u5716\n        spec3 = [[{\"type\": \"scatter\"}]*2]*(N-n_tables-1)  # \u5176\u9918\u6298\u7dda\u8d70\u52e2\u5716\n        fig = make_subplots(\n            rows=N,\n            cols=2,\n            vertical_spacing=0.02,\n            subplot_titles=list(self.Titles),\n            specs=spec1 + spec2 + spec3,\n            row_heights=[0.1, 0.15, 0.15] + [0.6/(N-n_tables)]*(N-n_tables)\n        )\n        fig = self.add_table(fig, TestResult.Configuration, row=1, col=1)\n        fig = self.add_table(fig, TestResult.Summary, row=2, col=1)\n        fig = self.add_table(fig, statement, row=3, col=1, height=40)\n\n        # TSE/OTC candlesticks\n        if self.Script.market == 'Stocks':\n            for col, (a, b) in enumerate([('1', 'TWSE'), ('101', 'OTC')]):\n                temp = Kbars['1D'].copy()\n                temp = temp[temp.name == a].sort_values('Time')\n                temp['name'] = b\n                fig = self.add_candlestick(fig, temp, row=4, col=col+1)\n        else:\n            fig = self.add_candlestick(fig, Kbars['1D'], row=4, col=1)\n\n        # Put/Call Ratio\n        if 'put_call_ratio' in Kbars:\n            df_pcr = pd.DataFrame(Kbars['put_call_ratio']).T\n            df_pcr['pc115'] = 115\n            for args in [\n                dict(y='PutCallRatio', name='Put/Call Ratio',\n                     marker_color='#ff9f1a'),\n                dict(y='pc115', name='\u591a\u7a7a\u5206\u754c', marker_color='#68c035'),\n            ]:\n                fig = self.add_line(\n                    fig,\n                    df_pcr,\n                    row=5,\n                    col=1,\n                    settings=args\n                )\n\n        # Changes in Opens & Closes\n        for args in [\n            dict(y='nOpen', name='Opens', marker_color='#48b2ef'),\n            dict(y='nClose', name='Closes', marker_color='#7F7F7F'),\n            dict(y='n_stocks', name='in-stock', marker_color='#ef488e')\n        ]:\n            fig = self.add_line(fig, daily_info, row=5, col=2, settings=args)\n\n        # Accumulated Balance\n        args = dict(y='balance', name='Accumulated Balance',\n                    marker_color='#d3503c')\n        fig = self.add_line(fig, daily_info, row=6, col=1, settings=args)\n\n        # Accumulated Profit/Loss\n        for args in [\n            dict(y='profits', name=\"Accumulated Profit\", marker_color='#c25656'),\n            dict(y='losses', name=\"Accumulated Loss\", marker_color='#9ad37e')\n        ]:\n            fig = self.add_line(\n                fig, daily_info, row=6, col=2, settings=args, fill='tozeroy')\n\n        # Changes in Portfolio Control\n        for args in [\n            dict(y='chance', name='Opens Available', marker_color='#48efec'),\n            dict(y='n_stock_limit', name='Opens Limit', marker_color='#b1487f')\n        ]:\n            fig = self.add_line(fig, daily_info, row=7, col=1, settings=args)\n\n        # figure layouts\n        fig.update_layout(height=2400, width=1700, title_text=title)\n        setattr(self.Figures, 'BacktestResult', fig)\n\n        return self.Figures\n\n    def plot_Ins_Outs(self, df: pd.DataFrame, testResult: object):\n        '''\u756b\u5716: \u500b\u80a1\u9032\u51fa\u5834\u4f4d\u7f6e'''\n\n        cols = ['name', 'Time', 'Open', 'High', 'Low', 'Close']\n        statement = testResult.Statement\n        statement['start'] = statement.groupby(\n            'stock').OpenTime.transform(lambda x: x.min() - timedelta(days=5))\n        statement['end'] = statement.groupby(\n            'stock').CloseTime.transform(lambda x: x.max() + timedelta(days=5))\n        tb = df[cols][\n            (df.Time >= statement.start.min()) & (df.Time <= statement.end.max())]\n\n        stocks = statement.stock.unique()\n        N = stocks.shape[0]\n        for i, s in enumerate(stocks):\n            df1 = statement[statement.stock == s].copy()\n\n            start = df1.start.values[0]\n            end = df1.end.values[0]\n            df2 = tb[(tb.name == s) & (tb.Time >= start) & (tb.Time <= end)]\n\n            ins = df2[df2.Time.isin(df1.OpenTime)]\n            ins = ins.set_index('Time').Low.to_dict()\n            df1['Ins'] = df1.OpenTime.map(ins)\n\n            outs = df2[df2.Time.isin(df1.CloseTime)]\n            outs = outs.set_index('Time').High.to_dict()\n            df1['Outs'] = df1.CloseTime.map(outs)\n\n            fig = go.Figure(\n                data=[\n                    go.Candlestick(\n                        x=df2.Time,\n                        open=df2['Open'],\n                        high=df2['High'],\n                        low=df2['Low'],\n                        close=df2['Close'],\n                        name=f'{s}\u9032\u51fa\u5834\u9ede\u4f4d',\n                        increasing=dict(line=dict(color='Crimson')),\n                        decreasing=dict(line=dict(color='LimeGreen'))\n                    ),\n\n                    go.Scatter(\n                        x=df1.OpenTime,\n                        y=df1.Ins*0.96,\n                        customdata=np.stack(\n                            (df1.OpenReason, df1.Ins),\n                            axis=-1\n                        ),\n                        hovertemplate='%{x} <br>%{customdata[0]} <br>%{customdata[1]} \u9032\u5834',\n                        name='\u9032\u5834',\n                        mode='markers',\n                        marker=dict(\n                            symbol='star-triangle-up',\n                            color='MediumBlue',\n                            size=10,\n                            line=dict(color='MediumPurple', width=1)\n                        ),\n                    ),\n\n                    go.Scatter(\n                        x=df1.CloseTime,\n                        y=df1.Outs*1.04,\n                        customdata=df1[\n                            ['CloseReason', 'Outs', 'profit', 'returns']].values,\n                        hovertemplate='%{x} <br>%{customdata[0]} <br>\u51fa\u5834: %{customdata[1]} <br>\u7372\u5229: %{customdata[2]} (%{customdata[3]}%)',\n                        name='\u51fa\u5834',\n                        mode='markers',\n                        marker=dict(\n                            symbol='star-triangle-down',\n                            color='#17BECF',\n                            size=10,\n                            line=dict(color='MediumPurple', width=1)\n                        ),\n                    )\n                ],\n                # \u8a2d\u5b9a XY \u986f\u793a\u683c\u5f0f\n                layout=go.Layout(\n                    xaxis=go.layout.XAxis(tickformat='%Y-%m-%d %H:%M'),\n                    yaxis=go.layout.YAxis(tickformat='.2f')\n                )\n            )\n\n            fig.update_xaxes(\n                rangebreaks=[\n                    dict(bounds=[\"sat\", \"mon\"]),\n                    dict(bounds=[14, 8], pattern=\"hour\"),\n                ]\n            )\n            setattr(self.Figures, f'fig{s}', fig)\n            progress_bar(N, i)\n\n        return self.Figures\n\n    def save_figure(self, fig: object, filename='\u56de\u6e2c\u5716\u8868'):\n        '''\u8f38\u51fa\u56de\u6e2c\u5716\u8868'''\n\n        folder_path = f'{self.DATAPATH}/\u56de\u6e2c\u5831\u544a/{TODAY_STR}-{filename}'\n        self.create_folder(folder_path)\n        export_figure(fig.BacktestResult, f'{folder_path}/\u56de\u6e2c\u7d50\u679c.html')\n\n        figures = [f for f in fig.__dict__ if 'fig' in f]\n        for f in figures:\n            export_figure(fig.__dict__[f], f'{folder_path}/{f}.html')\n\n        files = self.listdir(folder_path, pattern='.html')\n        for file in files:\n            convert_encodings(f'{folder_path}/{file}')", ""]}
{"filename": "docs/script samples/StrategySet.py", "chunked_list": ["import pandas as pd\nfrom datetime import datetime\nfrom trader.utils.strategy import StrategyTool\n\n\nclass StrategySet(StrategyTool):\n    '''\n    ===================================================================\n    StrategySet is a set of strategy class for AutoTradingPlatform, it \n    inherits the StrategyTool Object for the use of common functions.\n\n    *****\n    The attributes in the __init__ are all necessary, itestablishes the \n    Funcs attribute when the system starts.\n    *****\n\n    After preparing the script, set the target script to be executed \n    in self.Funcs in init. For example, if buyStrategy1 belongs to \n    Strategy1 and is a \u975e\u7576\u6c96 buying strategy, then buyStrategy1 \n    should be classified into \n    self.Funcs['Open']['\u975e\u7576\u6c96']['Strategy1'], where Open means \n    opening a position, whereas Close is to close a position.\n    ===================================================================\n    '''\n\n    def __init__(self, **kwargs):\n        StrategyTool.__init__(self, **kwargs)\n\n        # customized settings\n        self.STRATEGIES = pd.DataFrame(\n            # table of strategy set, recording each strategy name and its\n            # weight of long/short perspective. If a strategy is a long\n            # strategy, give an integer to its long_weight and 0 to its\n            # short_weight; and vice versa.\n            [\n                ['Strategy1', 1, 0],\n                ['Strategy2', 2, 0],\n                ['Strategy3', 3, 0],\n                ['Strategy4', 0, 1],\n            ],\n            columns=['name', 'long_weight', 'short_weight']\n        )\n        self.Funcs = {\n            'Open': {\n                '\u7576\u6c96': {},\n                '\u975e\u7576\u6c96': {\n                    'Strategy1': self.open_Strategy1,\n                    'Strategy2': self.open_Strategy2,\n                }\n            },\n            'Close': {\n                '\u7576\u6c96': {},\n                '\u975e\u7576\u6c96': {\n                    'Strategy1': self.close_Strategy1,\n                    'Strategy2': self.close_Strategy2,\n                }\n            }\n        }\n\n        self.QuantityFunc = {\n            'Strategy1': self.quantity_Strategy1\n        }\n\n    def update_indicators(self, now: datetime, kbars: dict):\n        '''\n        ===================================================================\n\n        *****OPTIONAL*****\n\n        Functions of updating indicators for all strategies. Any new\n        indicator data can be created as an attribute in this module.This \n        function is OPTIONAL to use, which means if not determine this func, \n        the system will not be affected.\n        ===================================================================\n        '''\n        pass\n\n    def setNStockLimitLong(self, KBars: dict = None):\n        '''\n        ===================================================================\n\n        *****OPTIONAL*****\n\n        Functions of setting the number of STOCK limit to trade for all \n        LONG strategies. This function is OPTIONAL to use, which means \n        if not determine this func, the system will automatically return \n        the value of self.stock_limit_long for further operations.\n        ===================================================================\n        '''\n        if self.is_simulation:\n            return 3000\n        elif self.stock_limit_type != 'constant':\n            return self.stock_limit_long\n        return self.stock_limit_long\n\n    def setNStockLimitShort(self, KBars: dict = None):\n        '''\n        ===================================================================\n\n        *****OPTIONAL*****\n\n        Functions of setting the number of STOCK limit to trade for all \n        SHORT strategies. This function is OPTIONAL to use, which means \n        if not determine this func, the system will automatically return \n        the value of self.stock_limit_short for further operations.\n        ===================================================================\n        '''\n        if self.is_simulation:\n            return 3000\n        elif self.stock_limit_type != 'constant':\n            return self.stock_limit_short\n        return self.stock_limit_short\n\n    def setNFuturesLimit(self, KBars: dict = None):\n        '''\n        ===================================================================\n\n        *****OPTIONAL*****\n\n        Functions of setting the number of FUTURES limit to trade for all \n        futures strategies. This function is OPTIONAL to use, which means \n        if not determine this func, the system will automatically return \n        the value of self.futures_limit for further operations.\n        ===================================================================\n        '''\n        if self.futures_limit_type != 'constant':\n            return self.futures_limit\n        return self.futures_limit\n\n    def quantity_Strategy1(self, inputs: dict, kbars: dict, mode='trading', **kwargs):\n        '''\n        ===================================================================\n\n        *****OPTIONAL*****\n\n        Functions of calculating quantity of opening stock positions. It \n        returns 2 values: quantity & quantity_limit, where quantity is \n        determined by your strategy and quantity_limit is set to default \n        1.   This function is OPTIONAL to use, which means if not deter-\n        mine this func, the system will automatically return 1, 499 for\n        further operations.\n        ===================================================================\n        '''\n        quantity = 1\n        quantity_limit = 499\n        return quantity, quantity_limit\n\n    def open_Strategy1(self, inputs: dict, kbars: dict, mode='trading', **kwargs):\n        '''\n        ===================================================================\n        Functions of determining if the system can open a LONG stock \n        position.\n\n        Arguments:\n        inputs: daily quote data of a stock/futures security, including, \n        open, high, low, close, volume, ..., etc\n        kbars: Kbar data for condition checking, supported kbar frequencies\n        are 1D, 60T, 30T, 15T, 5T, 1T.\n\n        Supported key-word arguments:\n        Quotes: current and history (for the past 1-min period) tick data.\n        pct_chg_DowJones: the percentage change of the previous trade-day\n        Dow-Jones index.\n\n        The function returns a namedtuple Object, including position(%), \n        reason, and msg.\n        ===================================================================\n        '''\n        buy_condition = inputs['price'] > inputs['open']\n        if buy_condition == True:\n            buy_position = 100\n            return self.Action(buy_position, 'buy_reason', 'buy_message')\n        return self.Action()\n\n    def close_Strategy1(self, inputs: dict, kbars: dict, mode='trading', **kwargs):\n        '''\n        ===================================================================\n        Functions of determining if the system can close a LONG stock \n        position.\n\n        Arguments:\n        inputs: daily quote data of a stock/futures security, including, \n        open, high, low, close, price, volume, ..., etc\n        kbars: Kbar data for condition checking, supported kbar frequencies\n        are 1D, 60T, 30T, 15T, 5T, 1T.\n\n        Supported key-word arguments:\n        Quotes: current and history (for the past 1-min period) tick data.\n        pct_chg_DowJones: the percentage change of the previous trade-day\n        Dow-Jones index.\n\n        The function returns a namedtuple Object, including position(%), \n        reason, and msg.\n        ===================================================================\n        '''\n        sell_condition = inputs['price'] < inputs['open']\n        if sell_condition == True:\n            sell_position = 100\n            return self.Action(sell_position, 'sell_reason', 'sell_message')\n        return self.Action()\n\n    def open_Strategy2(self, inputs: dict, kbars: dict, mode='trading', **kwargs):\n        '''\n        ===================================================================\n        Functions of determining if the system can open a SHORT stock \n        position.\n\n        Arguments:\n        inputs: daily quote data of a stock/futures security, including, \n        open, high, low, close, price, volume, ..., etc\n        kbars: Kbar data for condition checking, supported kbar frequencies\n        are 1D, 60T, 30T, 15T, 5T, 1T.\n\n        Supported key-word arguments:\n        Quotes: current and history (for the past 1-min period) tick data.\n        pct_chg_DowJones: the percentage change of the previous trade-day\n        Dow-Jones index.\n\n        The function returns a namedtuple Object, including position(%), \n        reason, and msg.\n        ===================================================================\n        '''\n        sell_condition = inputs['price'] < inputs['open']\n        if sell_condition == True:\n            sell_position = 100\n            return self.Action(sell_position, 'sell_reason', 'sell_message')\n        return self.Action()\n\n    def close_Strategy2(self, inputs: dict, kbars: dict, mode='trading', **kwargs):\n        '''\n        ===================================================================\n        Functions of determining if the system can close a SHORT stock \n        position.\n\n        Arguments:\n        inputs: daily quote data of a stock/futures security, including, \n        open, high, low, close, volume, ..., etc\n        kbars: Kbar data for condition checking, supported kbar frequencies\n        are 1D, 60T, 30T, 15T, 5T, 1T.\n\n        Supported key-word arguments:\n        Quotes: current and history (for the past 1-min period) tick data.\n        pct_chg_DowJones: the percentage change of the previous trade-day\n        Dow-Jones index.\n\n        The function returns a namedtuple Object, including position(%), \n        reason, and msg.\n        ===================================================================\n        '''\n        buy_condition = inputs['price'] > inputs['open']\n        if buy_condition == True:\n            buy_position = 100\n            return self.Action(buy_position, 'buy_reason', 'buy_message')\n        return self.Action()", ""]}
{"filename": "docs/script samples/backtest_sample.py", "chunked_list": ["import os\nimport pandas as pd\nfrom datetime import timedelta\n\nfrom trader.config import TODAY_STR\nfrom trader.performance.backtest import BackTester\nfrom trader.performance.reports import BacktestReport\nfrom trader.scripts.conditions import SelectConditions\nfrom trader.scripts.StrategySet import StrategySet\nfrom trader.scripts.features import FeatureTrading, FeaturesSelect", "from trader.scripts.StrategySet import StrategySet\nfrom trader.scripts.features import FeatureTrading, FeaturesSelect\n\n\ndef dats_source(start='', end=''):\n    if not start:\n        start = '2000-01-01'\n\n    if not end:\n        end = TODAY_STR\n\n    df = pd.read_csv('your_data_path')\n    df = df[(df.Time >= start) & (df.Time <= end)]\n    return df", "\n\nclass SampleScript(StrategySet, FeaturesSelect, FeatureTrading, SelectConditions):\n    '''\n    ===================================================================\n    This is a sample of formating a backtest script.\n    The following attributes are required:\n    1. strategy\n    2. market\n    3. margin\n    4. multipler\n    5. mode\n    6. scale\n    7. kbarScales\n    8. raiseQuota\n    9. leverage\n    10. extraData\n    ===================================================================\n    '''\n\n    # strategy name\n    strategy = 'LongStrategy'\n\n    # Stocks/Futures market\n    market = 'Stocks'\n\n    # futures trading margin\n    margin = 0\n\n    # futures trading multipler for computing profits\n    multipler = 1\n\n    # Define whether its a long or short strategy\n    mode = 'long'\n\n    # Kbar MAIN scale for backtesting\n    scale = '5T'\n\n    # Kbar scales to generate indicators for backtesting\n    kbarScales = ['1D', '5T']\n\n    # whether raise trading quota after opening a position\n    raiseQuota = False\n\n    # trading leverage\n    leverage = 1\n\n    # Optional: add this attribute if your strategy needs more datssets.\n    extraData = dict(dats_source=dats_source)\n\n    def addFeatures_1D(self, df: pd.DataFrame):\n        '''\n        ===================================================================\n\n        *****OPTIONAL*****\n\n        Function of adding \"Day-frequency\" features. Add this function if\n        your backtest strategy needs multi-scale kbar datasets.\n        ===================================================================\n        '''\n        df = self.preprocess_common(df)\n        df = getattr(self, f'preprocess_{self.strategy}')(df)\n        df = getattr(self, f'addFeatures_1D_{self.strategy}')(df, 'backtest')\n        return df\n\n    def addFeatures_T(self, df: pd.DataFrame, scale: str):\n        '''\n        ===================================================================\n        Functions of adding \"other-frequency\" features.\n        ===================================================================\n        '''\n        func = getattr(self, f'addFeatures_{scale}_{self.strategy}')\n        df = func(df, 'backtest')\n        return df\n\n    def addFeatures(self, Kbars: dict):\n        for scale in self.kbarScales:\n            if scale == '1D':\n                Kbars[scale] = self.addFeatures_1D(Kbars[scale])\n            else:\n                Kbars[scale] = self.addFeatures_T(Kbars[scale], scale)\n        return Kbars\n\n    def selectStocks(self, Kbars: dict, *args):\n        '''\n        ===================================================================\n        Set conditions to select stocks.\n        ===================================================================\n        '''\n        df = Kbars['1D']\n        df['isIn'] = getattr(self, f'condition_{self.strategy}')(df, *args)\n        df.isIn = df.groupby('name').isIn.shift(1).fillna(False)\n        Kbars['1D'] = df\n\n        if len(self.kbarScales) > 1:\n            df = Kbars[self.scale]\n            isIn = Kbars['1D'][['date', 'name', 'isIn']]\n            df = df.merge(isIn, how='left', on=['date', 'name'])\n            Kbars[self.scale] = df\n\n        return Kbars\n\n    def setVolumeProp(self, market_value):\n        return self.get_volume_prop(self.strategy, market_value)\n\n    def computeOpenLimit(self, KBars: dict, **kwargs):\n        '''\n        ===================================================================\n        Determine the daily limit to open a position.\n        ===================================================================\n        '''\n        if not hasattr(self, f'openLimit_{self.strategy}'):\n            return 2000\n\n        func = getattr(self, f'openLimit_{self.strategy}')\n        return func(KBars, 'backtest')\n\n    def computeOpenUnit(self, kbars: dict):\n        if not hasattr(self, f'quantity_{self.strategy}'):\n            return 5\n\n        func = getattr(self, f'quantity_{self.strategy}')\n        quantity, _ = func(None, kbars, 'backtest')\n        return quantity\n\n    def examineOpen(self, inputs: dict, kbars: dict, **kwargs):\n        '''\n        ===================================================================\n        Set conditions to open a position.\n        ===================================================================\n        '''\n        func = self.mapFunction('Open', self.tradeType, self.strategy)\n        return func(inputs=inputs, kbars=kbars, mode='backtest', **kwargs)\n\n    def examineClose(self, inputs: dict, kbars: dict, **kwargs):\n        '''\n        ===================================================================\n        Set conditions to close a position.\n        ===================================================================\n        '''\n        func = self.mapFunction('Close', self.tradeType, self.strategy)\n        return func(inputs=inputs, kbars=kbars, mode='backtest', **kwargs)", "\n\ntester = BackTester()\nbacktestScript = SampleScript()\ntester.set_scripts(backtestScript)\n\n\n# Load & Merge datasets\nKbars = tester.load_datasets(\n    start=pd.to_datetime(TODAY_STR) - timedelta(days=365),", "Kbars = tester.load_datasets(\n    start=pd.to_datetime(TODAY_STR) - timedelta(days=365),\n    end='',\n    dataPath=f'{os.getcwd()}/data'\n)\n\n# Add backtest features and select stocks\nKbars = tester.addFeatures(Kbars)\nKbars = tester.selectStocks(Kbars)\n", "Kbars = tester.selectStocks(Kbars)\n\n# Run backtest\ninit_position = 1000000\nparams = dict(init_position=init_position, buyOrder='Close')\nTestResult = tester.run(Kbars, **params)\n\nif TestResult.Summary is not None:\n    print(TestResult.Summary)\n", "\n# Plot figures\nbr = BacktestReport(backtestScript)\nfig = br.plot_backtest_result(TestResult)\n\n# Output backtest results\ntester.save_result(TestResult)\nbr.save_figure(fig, 'Backtest Result')\n", ""]}
{"filename": "docs/script samples/conditions.py", "chunked_list": ["import pandas as pd\n\n\nclass SelectConditions:\n    '''\n    ===================================================================\n    This module is created for stock selection. The function name format \n    is condition_{your_strategy_name} where \"your_strategy_name\" is the \n    same as your strategy name defined in StrategySet.py. The \n    SelectStock module will automatically set the preprocess and \n    condition functions when the program initializes.\n    ===================================================================\n    '''\n\n    def condition_strategy1(self, df: pd.DataFrame, *args):\n        '''\n        ===================================================================\n        Functions of selection conditions for the strategy.\n        ===================================================================\n        '''\n        b1 = df.Close/df.yClose > 1.05\n        b2 = df.Volume > 10000\n        b3 = df.Close > df.Open\n        return b1 & b2 & b3", ""]}
{"filename": "docs/script samples/features.py", "chunked_list": ["import pandas as pd\n\nfrom trader.indicators.signals import TechnicalSignals\n\n\nclass FeaturesSelect:\n    '''\n    ===================================================================\n    This module is created for stock selection. The function name format \n    is preprocess_{your_strategy_name} where \"your_strategy_name\" is the \n    same as your strategy name defined in StrategySet.py. The \n    SelectStock module will automatically set the preprocess and \n    condition functions when the program initializes.\n    ===================================================================\n    '''\n\n    def preprocess_strategy1(self, df: pd.DataFrame):\n        '''\n        ===================================================================\n        Functions of preprocessing data for the strategy.\n        ===================================================================\n        '''\n        group = df.groupby('name')\n        df['yClose'] = group.Close.transform('shift')\n        return df", "\n\nclass KBarFeatureTool(TechnicalSignals):\n    '''\n    ===================================================================\n    This module is created for adding KBar features. There is a name \n    format for function names: add_K{kbar_frequency}_feature, where\n    \"kbar_frequency\" can be Day, 60min, 30min, 15min, 5min, or 1min. Each\n    function is designed to add features with respect to its frequency\n    data.\n    ===================================================================\n    '''\n\n    def add_KDay_feature(self, KDay: pd.DataFrame):\n        '''\n        ===================================================================\n        Functions of adding Day-frequency features.\n        ===================================================================\n        '''\n        KDay['date'] = pd.to_datetime(KDay['date'])\n        KDay['ma_1D_5'] = self._MA(KDay, 'Close', 5)\n        return KDay\n\n    def add_K60min_feature(self, K60min: pd.DataFrame):\n        '''\n        ===================================================================\n        Functions of adding 60min-frequency features.\n        ===================================================================\n        '''\n        K60min['ma_60T_10'] = self._MA(K60min, 'Close', 10)\n        return K60min\n\n    def add_K30min_feature(self, K30min: pd.DataFrame):\n        '''\n        ===================================================================\n        Functions of adding 30min-frequency features.\n        ===================================================================\n        '''\n        K30min['ma_30T_10'] = self._MA(K30min, 'Close', 10)\n        return K30min", ""]}
