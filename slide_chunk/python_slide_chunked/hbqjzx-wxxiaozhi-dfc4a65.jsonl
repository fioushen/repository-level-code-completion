{"filename": "app.py", "chunked_list": ["# encoding:utf-8\n\nimport argparse\nimport config\nfrom channel import channel_factory\nfrom common import log, const\nfrom multiprocessing import Pool\n\nfrom plugins.plugin_manager import PluginManager\n", "from plugins.plugin_manager import PluginManager\n\n\n# \u542f\u52a8\u901a\u9053\ndef start_process(channel_type, config_path):\n    try:\n        # \u82e5\u4e3a\u591a\u8fdb\u7a0b\u542f\u52a8,\u5b50\u8fdb\u7a0b\u65e0\u6cd5\u76f4\u63a5\u8bbf\u95ee\u4e3b\u8fdb\u7a0b\u7684\u5185\u5b58\u7a7a\u95f4,\u91cd\u65b0\u521b\u5efaconfig\u7c7b\n        config.load_config(config_path)\n        model_type = config.conf().get(\"model\").get(\"type\")\n        log.info(\"[MultiChannel] Start up {} on {}\", model_type, channel_type)\n        channel = channel_factory.create_channel(channel_type)\n        channel.startup()\n    except Exception as e:\n        log.error(\"[MultiChannel] Start up failed on {}: {}\", channel_type, str(e))\n        raise e", "\n\ndef main():\n    try:\n        # load config\n        config.load_config(args.config)\n\n        model_type = config.conf().get(\"model\").get(\"type\")\n        channel_type = config.conf().get(\"channel\").get(\"type\")\n\n        PluginManager()\n        # 1.\u5355\u4e2a\u5b57\u7b26\u4e32\u683c\u5f0f\u914d\u7f6e\u65f6\uff0c\u76f4\u63a5\u542f\u52a8\n        if not isinstance(channel_type, list):\n            start_process(channel_type, args.config)\n            exit(0)\n\n        # 2.\u5355\u901a\u9053\u5217\u8868\u914d\u7f6e\u65f6\uff0c\u76f4\u63a5\u542f\u52a8\n        if len(channel_type) == 1:\n            start_process(channel_type[0], args.config)\n            exit(0)\n\n        # 3.\u591a\u901a\u9053\u914d\u7f6e\u65f6\uff0c\u8fdb\u7a0b\u6c60\u542f\u52a8\n        # \u4f7f\u7528\u4e3b\u8fdb\u7a0b\u542f\u52a8\u7ec8\u7aef\u901a\u9053\n        if const.TERMINAL in channel_type:\n            index = channel_type.index(const.TERMINAL)\n            terminal = channel_type.pop(index)\n        else:\n            terminal = None\n\n        # \u4f7f\u7528\u8fdb\u7a0b\u6c60\u542f\u52a8\u5176\u4ed6\u901a\u9053\u5b50\u8fdb\u7a0b\n        pool = Pool(len(channel_type))\n        for type_item in channel_type:\n            log.info(\"[INIT] Start up: {} on {}\", model_type, type_item)\n            pool.apply_async(start_process, args=[type_item, args.config])\n\n        if terminal:\n            start_process(terminal, args.config)\n\n        # \u7b49\u5f85\u6c60\u4e2d\u6240\u6709\u8fdb\u7a0b\u6267\u884c\u5b8c\u6bd5\n        pool.close()\n        pool.join()\n    except Exception as e:\n        log.error(\"App startup failed!\")\n        log.exception(e)", "\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--config\", help=\"config.json path(e.g: ./config.json  or  /usr/local/bot-on-anything/config.json)\",type=str,default=\"./config.json\")\n    args = parser.parse_args()\n    main()\n"]}
{"filename": "config.py", "chunked_list": ["# encoding:utf-8\n\nimport json\nimport os\n\nconfig = {}\n\n\ndef load_config(config_path = \"./config.json\"):\n    global config\n    if not os.path.exists(config_path):\n        raise Exception('\u914d\u7f6e\u6587\u4ef6\u4e0d\u5b58\u5728\uff0c\u8bf7\u6839\u636econfig-template.json\u6a21\u677f\u521b\u5efaconfig.json\u6587\u4ef6')\n\n    config_str = read_file(config_path)\n    # \u5c06json\u5b57\u7b26\u4e32\u53cd\u5e8f\u5217\u5316\u4e3adict\u7c7b\u578b\n    config = json.loads(config_str)\n    print(\"Load config success\")\n    return config", "def load_config(config_path = \"./config.json\"):\n    global config\n    if not os.path.exists(config_path):\n        raise Exception('\u914d\u7f6e\u6587\u4ef6\u4e0d\u5b58\u5728\uff0c\u8bf7\u6839\u636econfig-template.json\u6a21\u677f\u521b\u5efaconfig.json\u6587\u4ef6')\n\n    config_str = read_file(config_path)\n    # \u5c06json\u5b57\u7b26\u4e32\u53cd\u5e8f\u5217\u5316\u4e3adict\u7c7b\u578b\n    config = json.loads(config_str)\n    print(\"Load config success\")\n    return config", "\ndef get_root():\n    return os.path.dirname(os.path.abspath( __file__ ))\n\n\ndef read_file(path):\n    with open(path, mode='r', encoding='utf-8') as f:\n        return f.read()\n\n\ndef conf():\n    return config", "\n\ndef conf():\n    return config\n\n\ndef model_conf(model_type):\n    return config.get('model').get(model_type)\n\ndef model_conf_val(model_type, key):\n    val = config.get('model').get(model_type).get(key)\n    if not val:\n        # common default config\n        return config.get('model').get(key)\n    return val", "\ndef model_conf_val(model_type, key):\n    val = config.get('model').get(model_type).get(key)\n    if not val:\n        # common default config\n        return config.get('model').get(key)\n    return val\n\n\ndef channel_conf(channel_type):\n    return config.get('channel').get(channel_type)", "\ndef channel_conf(channel_type):\n    return config.get('channel').get(channel_type)\n\n\ndef channel_conf_val(channel_type, key, default=None):\n    val = config.get('channel').get(channel_type).get(key)\n    if not val:\n        # common default config\n        return config.get('channel').get(key, default)\n    return val", "\n\ndef common_conf_val(key, default=None):\n    if not config.get('common'):\n        return default\n    return config.get('common').get(key, default)\n"]}
{"filename": "plugins/plugin.py", "chunked_list": ["# encoding:utf-8\nclass Plugin:\n    def __init__(self):\n        self.handlers = {}\n\n    def get_help_text(self, **kwargs):\n        return \"\u6682\u65e0\u5e2e\u52a9\u4fe1\u606f\""]}
{"filename": "plugins/plugin_registry.py", "chunked_list": ["# encoding:utf-8\n\nimport inspect\nfrom plugins.plugin import Plugin\nfrom common.log import logger\nfrom common import functions\n\n@functions.singleton\nclass PluginRegistry:\n    def __init__(self):\n        self.plugins = []\n\n    def register(self, name: str, desire_priority: int = 0, **kwargs):\n        def wrapper(plugin_cls):\n            plugin_cls.name = name\n            plugin_cls.priority = desire_priority\n            plugin_cls.desc = kwargs.get('desc')\n            plugin_cls.author = kwargs.get('author')\n            plugin_cls.version = kwargs.get('version') or \"1.0\"\n            plugin_cls.namecn = kwargs.get('namecn') or name\n            plugin_cls.hidden = kwargs.get('hidden') or False\n            plugin_cls.enabled = kwargs.get('enabled') or True\n            logger.info(f\"Plugin {name}_v{plugin_cls.version} registered\")\n            return plugin_cls\n        return wrapper\n\n    def register_from_module(self, module):\n            plugins = []\n            for name, obj in inspect.getmembers(module):\n                if inspect.isclass(obj) and issubclass(obj, Plugin) and obj != Plugin:\n                    plugin_name = getattr(obj, \"name\", None)\n                    if plugin_name:\n                        plugin = obj()\n                        plugin.name = plugin_name\n                        plugin.priority = getattr(obj, \"priority\", 0)\n                        plugin.desc = getattr(obj, \"desc\", None)\n                        plugin.author = getattr(obj, \"author\", None)\n                        plugin.version = getattr(obj, \"version\", \"1.0\")\n                        plugin.namecn = getattr(obj, \"namecn\", plugin_name)\n                        plugin.hidden = getattr(obj, \"hidden\", False)\n                        plugin.enabled = getattr(obj, \"enabled\", True)\n            # Sort the list of plugins by priority\n            self.plugins.append(plugin)\n            self.plugins.sort(key=lambda x: x.priority, reverse=True)\n\n    def get_plugin(self, name):\n        plugin = next((p for p in self.plugins if p.name.upper() == name.upper()), None)\n        return plugin\n\n    def list_plugins(self):\n        return [plugin for plugin in self.plugins]", "class PluginRegistry:\n    def __init__(self):\n        self.plugins = []\n\n    def register(self, name: str, desire_priority: int = 0, **kwargs):\n        def wrapper(plugin_cls):\n            plugin_cls.name = name\n            plugin_cls.priority = desire_priority\n            plugin_cls.desc = kwargs.get('desc')\n            plugin_cls.author = kwargs.get('author')\n            plugin_cls.version = kwargs.get('version') or \"1.0\"\n            plugin_cls.namecn = kwargs.get('namecn') or name\n            plugin_cls.hidden = kwargs.get('hidden') or False\n            plugin_cls.enabled = kwargs.get('enabled') or True\n            logger.info(f\"Plugin {name}_v{plugin_cls.version} registered\")\n            return plugin_cls\n        return wrapper\n\n    def register_from_module(self, module):\n            plugins = []\n            for name, obj in inspect.getmembers(module):\n                if inspect.isclass(obj) and issubclass(obj, Plugin) and obj != Plugin:\n                    plugin_name = getattr(obj, \"name\", None)\n                    if plugin_name:\n                        plugin = obj()\n                        plugin.name = plugin_name\n                        plugin.priority = getattr(obj, \"priority\", 0)\n                        plugin.desc = getattr(obj, \"desc\", None)\n                        plugin.author = getattr(obj, \"author\", None)\n                        plugin.version = getattr(obj, \"version\", \"1.0\")\n                        plugin.namecn = getattr(obj, \"namecn\", plugin_name)\n                        plugin.hidden = getattr(obj, \"hidden\", False)\n                        plugin.enabled = getattr(obj, \"enabled\", True)\n            # Sort the list of plugins by priority\n            self.plugins.append(plugin)\n            self.plugins.sort(key=lambda x: x.priority, reverse=True)\n\n    def get_plugin(self, name):\n        plugin = next((p for p in self.plugins if p.name.upper() == name.upper()), None)\n        return plugin\n\n    def list_plugins(self):\n        return [plugin for plugin in self.plugins]"]}
{"filename": "plugins/__init__.py", "chunked_list": ["# encoding:utf-8\nfrom .event import *\nfrom .plugin import *\nfrom plugins.plugin_registry import PluginRegistry\n\ninstance = PluginRegistry()\n\nregister                    = instance.register\n# load_plugins                = instance.load_plugins\n# emit_event                  = instance.emit_event", "# load_plugins                = instance.load_plugins\n# emit_event                  = instance.emit_event\n"]}
{"filename": "plugins/event.py", "chunked_list": ["# encoding:utf-8\n\nfrom enum import Enum\n\n\nclass Event(Enum):\n    # ON_RECEIVE_MESSAGE = 1  # \u6536\u5230\u6d88\u606f\n\n    ON_HANDLE_CONTEXT = 2   # \u5bf9\u5e94\u901a\u9053\u5904\u7406\u6d88\u606f\u524d\n    \"\"\"\n    e_context = {  \"channel\": \u6d88\u606fchannel,  \"context\" : \u672c\u6b21\u6d88\u606f\u7684context, \"reply\" : \u76ee\u524d\u7684\u56de\u590d\uff0c\u521d\u59cb\u4e3a\u7a7a , \"args\": \u5176\u4ed6\u4e0a\u4e0b\u6587\u53c2\u6570 }\n    \"\"\"\n\n    ON_DECORATE_REPLY = 3   # \u5f97\u5230\u56de\u590d\u540e\u51c6\u5907\u88c5\u9970\n    \"\"\"\n    e_context = {  \"channel\": \u6d88\u606fchannel,  \"context\" : \u672c\u6b21\u6d88\u606f\u7684context, \"reply\" : \u76ee\u524d\u7684\u56de\u590d , \"args\": \u5176\u4ed6\u4e0a\u4e0b\u6587\u53c2\u6570 }\n    \"\"\"\n\n    ON_SEND_REPLY = 4       # \u53d1\u9001\u56de\u590d\u524d\n    \"\"\"\n    bot-on-anything \u4e0d\u652f\u6301ON_SEND_REPLY\u4e8b\u4ef6,\u8bf7\u4f7f\u7528ON_BRIDGE_HANDLE_CONTEXT\u6216\u8005ON_BRIDGE_HANDLE_STREAM_CONTEXT\u4e8b\u4ef6\n    \"\"\"\n\n    # AFTER_SEND_REPLY = 5    # \u53d1\u9001\u56de\u590d\u540e\n\n    ON_BRIDGE_HANDLE_CONTEXT = 6   # \u6a21\u578b\u6865\u5904\u7406\u6d88\u606f\u524d\n    \"\"\"\n    e_context = { \"context\" : \u672c\u6b21\u6d88\u606f\u7684context, \"reply\" : \u76ee\u524d\u7684\u56de\u590d\uff0c\u521d\u59cb\u4e3a\u7a7a , \"args\": \u5176\u4ed6\u4e0a\u4e0b\u6587\u53c2\u6570 }\n    \"\"\"\n\n    ON_BRIDGE_HANDLE_STREAM_CONTEXT = 7   # \u6a21\u578b\u6865\u5904\u7406\u6d41\u5f0f\u6d88\u606f\u524d,\u6d41\u5f0f\u5bf9\u8bdd\u7684\u6d88\u606f\u5904\u7406\u4ec5\u652f\u6301\u4e00\u6b21\u6027\u8fd4\u56de,\u8bf7\u76f4\u63a5\u8fd4\u56de\u7ed3\u679c\n    \"\"\"\n    e_context = {  \"context\" : \u672c\u6b21\u6d88\u606f\u7684context, \"reply\" : \u76ee\u524d\u7684\u56de\u590d\uff0c\u521d\u59cb\u4e3a\u7a7a , \"args\": \u5176\u4ed6\u4e0a\u4e0b\u6587\u53c2\u6570 }\n    \"\"\"", "\n    \nclass EventAction(Enum):\n    CONTINUE = 1            # \u4e8b\u4ef6\u672a\u7ed3\u675f\uff0c\u7ee7\u7eed\u4ea4\u7ed9\u4e0b\u4e2a\u63d2\u4ef6\u5904\u7406\uff0c\u5982\u679c\u6ca1\u6709\u4e0b\u4e2a\u63d2\u4ef6\uff0c\u5219\u4ea4\u4ed8\u7ed9\u9ed8\u8ba4\u7684\u4e8b\u4ef6\u5904\u7406\u903b\u8f91\n    BREAK = 2               # \u4e8b\u4ef6\u7ed3\u675f\uff0c\u4e0d\u518d\u7ed9\u4e0b\u4e2a\u63d2\u4ef6\u5904\u7406\uff0c\u4ea4\u4ed8\u7ed9\u9ed8\u8ba4\u7684\u4e8b\u4ef6\u5904\u7406\u903b\u8f91\n    BREAK_PASS = 3          # \u4e8b\u4ef6\u7ed3\u675f\uff0c\u4e0d\u518d\u7ed9\u4e0b\u4e2a\u63d2\u4ef6\u5904\u7406\uff0c\u4e0d\u4ea4\u4ed8\u7ed9\u9ed8\u8ba4\u7684\u4e8b\u4ef6\u5904\u7406\u903b\u8f91\n\n\nclass EventContext:\n    def __init__(self, event, econtext=dict()):\n        self.event = event\n        self.econtext = econtext\n        self.action = EventAction.CONTINUE\n\n    def __getitem__(self, key):\n        return self.econtext.get(key,\"\")\n\n    def __setitem__(self, key, value):\n        self.econtext[key] = value\n\n    def __delitem__(self, key):\n        del self.econtext[key]\n\n    def is_pass(self):\n        return self.action == EventAction.BREAK_PASS", "class EventContext:\n    def __init__(self, event, econtext=dict()):\n        self.event = event\n        self.econtext = econtext\n        self.action = EventAction.CONTINUE\n\n    def __getitem__(self, key):\n        return self.econtext.get(key,\"\")\n\n    def __setitem__(self, key, value):\n        self.econtext[key] = value\n\n    def __delitem__(self, key):\n        del self.econtext[key]\n\n    def is_pass(self):\n        return self.action == EventAction.BREAK_PASS", ""]}
{"filename": "plugins/plugin_manager.py", "chunked_list": ["# encoding:utf-8\nimport os\nimport importlib.util\nfrom plugins.event import EventAction, EventContext,Event\nfrom plugins.plugin_registry import PluginRegistry\nfrom common import functions, log\n\n@functions.singleton\nclass PluginManager:\n    def __init__(self, plugins_dir=\"./plugins/\"):\n        self.plugins_dir = plugins_dir\n        self.plugin_registry = PluginRegistry()\n        self.load_plugins()\n\n    def load_plugins(self):\n        for plugin_name in self.find_plugin_names():\n            if os.path.exists(f\"./plugins/{plugin_name}/{plugin_name}.py\"):\n                try:\n                    plugin_module = self.load_plugin_module(plugin_name)\n                    self.plugin_registry.register_from_module(plugin_module)\n                except Exception as e:\n                    log.warn(\"Failed to import plugin %s\" % (plugin_name))\n\n    def find_plugin_names(self):\n        plugin_names = []\n        for entry in os.scandir(self.plugins_dir):\n            if entry.is_dir():\n                plugin_names.append(entry.name)\n        return plugin_names\n\n    def load_plugin_module(self, plugin_name):\n        spec = importlib.util.spec_from_file_location(\n            plugin_name, os.path.join(self.plugins_dir, plugin_name, f\"{plugin_name}.py\")\n        )\n        module = importlib.util.module_from_spec(spec)\n        spec.loader.exec_module(module)\n        return module\n\n    def emit_event(self, e_context: EventContext, *args, **kwargs):\n        for plugin in self.plugin_registry.list_plugins():\n            if plugin.enabled and e_context.action == EventAction.CONTINUE:\n                if(e_context.event in plugin.handlers):\n                    plugin.handlers[e_context.event](e_context, *args, **kwargs)\n        return e_context", "class PluginManager:\n    def __init__(self, plugins_dir=\"./plugins/\"):\n        self.plugins_dir = plugins_dir\n        self.plugin_registry = PluginRegistry()\n        self.load_plugins()\n\n    def load_plugins(self):\n        for plugin_name in self.find_plugin_names():\n            if os.path.exists(f\"./plugins/{plugin_name}/{plugin_name}.py\"):\n                try:\n                    plugin_module = self.load_plugin_module(plugin_name)\n                    self.plugin_registry.register_from_module(plugin_module)\n                except Exception as e:\n                    log.warn(\"Failed to import plugin %s\" % (plugin_name))\n\n    def find_plugin_names(self):\n        plugin_names = []\n        for entry in os.scandir(self.plugins_dir):\n            if entry.is_dir():\n                plugin_names.append(entry.name)\n        return plugin_names\n\n    def load_plugin_module(self, plugin_name):\n        spec = importlib.util.spec_from_file_location(\n            plugin_name, os.path.join(self.plugins_dir, plugin_name, f\"{plugin_name}.py\")\n        )\n        module = importlib.util.module_from_spec(spec)\n        spec.loader.exec_module(module)\n        return module\n\n    def emit_event(self, e_context: EventContext, *args, **kwargs):\n        for plugin in self.plugin_registry.list_plugins():\n            if plugin.enabled and e_context.action == EventAction.CONTINUE:\n                if(e_context.event in plugin.handlers):\n                    plugin.handlers[e_context.event](e_context, *args, **kwargs)\n        return e_context", ""]}
{"filename": "plugins/selector/selector.py", "chunked_list": ["# encoding:utf-8\n\nimport os\nimport plugins\nfrom plugins import *\nfrom common import log\nfrom common import functions\n\n\n@plugins.register(name=\"Selector\", desire_priority=99, hidden=True, desc=\"A model selector\", version=\"0.1\", author=\"RegimenArsenic\")\nclass Selector(Plugin):\n    def __init__(self):\n        super().__init__()\n        curdir = os.path.dirname(__file__)\n        try:\n            self.config = functions.load_json_file(curdir, \"selector.json\")\n        except Exception as e:\n            log.warn(\"[Selector] init failed\")\n            raise e\n        self.handlers[Event.ON_HANDLE_CONTEXT] = self.select_model\n        self.handlers[Event.ON_BRIDGE_HANDLE_STREAM_CONTEXT] = self.select_model\n        log.info(\"[Selector] inited\")\n\n    def get_events(self):\n        return self.handlers\n\n    def select_model(self, e_context: EventContext):\n        model=e_context['args'].get('model')\n        for selector in self.config.get(\"selector\", []):\n            prefix = selector.get('prefix', [])\n            check_prefix=functions.check_prefix(e_context[\"context\"], prefix)\n            if (check_prefix):\n                model=selector.get('model')\n                if isinstance(check_prefix, str):\n                    e_context[\"context\"] = e_context[\"context\"].split(check_prefix, 1)[1].strip()\n                break\n        log.debug(f\"[Selector] select model {model}\")\n        e_context.action = EventAction.CONTINUE  # \u4e8b\u4ef6\u7ee7\u7eed\uff0c\u4ea4\u4ed8\u7ed9\u4e0b\u4e2a\u63d2\u4ef6\u6216\u9ed8\u8ba4\u903b\u8f91\n        e_context['args']['model']=model\n        return e_context", "\n@plugins.register(name=\"Selector\", desire_priority=99, hidden=True, desc=\"A model selector\", version=\"0.1\", author=\"RegimenArsenic\")\nclass Selector(Plugin):\n    def __init__(self):\n        super().__init__()\n        curdir = os.path.dirname(__file__)\n        try:\n            self.config = functions.load_json_file(curdir, \"selector.json\")\n        except Exception as e:\n            log.warn(\"[Selector] init failed\")\n            raise e\n        self.handlers[Event.ON_HANDLE_CONTEXT] = self.select_model\n        self.handlers[Event.ON_BRIDGE_HANDLE_STREAM_CONTEXT] = self.select_model\n        log.info(\"[Selector] inited\")\n\n    def get_events(self):\n        return self.handlers\n\n    def select_model(self, e_context: EventContext):\n        model=e_context['args'].get('model')\n        for selector in self.config.get(\"selector\", []):\n            prefix = selector.get('prefix', [])\n            check_prefix=functions.check_prefix(e_context[\"context\"], prefix)\n            if (check_prefix):\n                model=selector.get('model')\n                if isinstance(check_prefix, str):\n                    e_context[\"context\"] = e_context[\"context\"].split(check_prefix, 1)[1].strip()\n                break\n        log.debug(f\"[Selector] select model {model}\")\n        e_context.action = EventAction.CONTINUE  # \u4e8b\u4ef6\u7ee7\u7eed\uff0c\u4ea4\u4ed8\u7ed9\u4e0b\u4e2a\u63d2\u4ef6\u6216\u9ed8\u8ba4\u903b\u8f91\n        e_context['args']['model']=model\n        return e_context", ""]}
{"filename": "plugins/createimg/createimg.py", "chunked_list": ["# encoding:utf-8\n\nfrom channel.http.http_channel import HttpChannel\nfrom channel.wechat.wechat_channel import WechatChannel\nimport plugins\nfrom plugins import *\nfrom common import functions\nfrom config import channel_conf\nfrom config import channel_conf_val\nfrom common import const", "from config import channel_conf_val\nfrom common import const\n\n\n@plugins.register(name=\"CreateImg\", desire_priority=90, hidden=True, desc=\"A simple plugin that create images from model\", version=\"0.1\", author=\"RegimenArseic\")\nclass Createimg(Plugin):\n    def __init__(self):\n        super().__init__()\n        self.handles = {HttpChannel: self.handle_http}\n        self.channel_types = {HttpChannel: const.HTTP,\n                              WechatChannel: const.WECHAT}\n        self.handlers[Event.ON_HANDLE_CONTEXT] = self.handle_query\n        self.handlers[Event.ON_DECORATE_REPLY] = self.send_images\n\n    def get_events(self):\n        return self.handlers\n\n    def handle_query(self, e_context: EventContext):\n        channel = e_context['channel']\n        channel_type = self.channel_types.get(type(channel), None)\n        if (channel_type):\n            query = e_context['context']\n            if (query):\n                img_match_prefix = functions.check_prefix(\n                    query, channel_conf_val(channel_type, 'image_create_prefix'))\n                if img_match_prefix:\n                    if (channel_type == const.HTTP) and e_context['args'].get('stream', False):\n                        e_context['reply'] = channel.handle(\n                            {'msg': e_context['args']['origin'], 'id': e_context['args']['from_user_id']})\n                        e_context.action = EventAction.BREAK_PASS\n                    else:\n                        query = query.split(img_match_prefix, 1)[1].strip()\n                        e_context['args']['type'] = 'IMAGE_CREATE'\n                        if (channel_type == const.WECHAT):\n                            channel._do_send_img(\n                                query, e_context['args'])\n                            e_context.action = EventAction.BREAK_PASS\n                        else:\n                            e_context.action = EventAction.CONTINUE\n        return e_context\n\n    def handle_http(self, e_context: EventContext):\n        reply = e_context[\"reply\"]\n        if e_context['args'].get('type', '') == 'IMAGE_CREATE':\n            if isinstance(reply, list):\n                images = \"\"\n                for url in reply:\n                    images += f\"[!['IMAGE_CREATE']({url})]({url})\\n\\n\"\n            e_context[\"reply\"] = images\n        return e_context\n\n    def send_images(self, e_context: EventContext):\n        channel = e_context['channel']\n        method = self.handles.get(type(channel), None)\n        if (method):\n            e_context = method(e_context)\n        e_context.action = EventAction.BREAK_PASS  # \u4e8b\u4ef6\u7ed3\u675f\uff0c\u4e0d\u518d\u7ed9\u4e0b\u4e2a\u63d2\u4ef6\u5904\u7406\uff0c\u4e0d\u4ea4\u4ed8\u7ed9\u9ed8\u8ba4\u7684\u4e8b\u4ef6\u5904\u7406\u903b\u8f91\n        return e_context", ""]}
{"filename": "common/functions.py", "chunked_list": ["import json\nimport os\nimport re\nfrom common import log\n\ndef singleton(cls):\n    instances = {}\n\n    def get_instance(*args, **kwargs):\n        if cls not in instances:\n            instances[cls] = cls(*args, **kwargs)\n        return instances[cls]\n\n    return get_instance", "\ndef load_json_file(curdir: str, file: str = 'config.json'):\n    config_path = os.path.join(curdir, file)\n    try:\n        with open(config_path, \"r\", encoding=\"utf-8\") as f:\n            config = json.load(f)\n            return config\n    except Exception as e:\n        if isinstance(e, FileNotFoundError):\n            log.warn(\n                f\"[common]load json file failed, {config_path}\\{file} not found\")\n        else:\n            log.warn(\"[common]load json file failed\")\n        raise e", "\n\ndef contain_chinese(str):\n    \"\"\"\n    \u5224\u65ad\u4e00\u4e2a\u5b57\u7b26\u4e32\u4e2d\u662f\u5426\u542b\u6709\u4e2d\u6587\n    \"\"\"\n    pattern = re.compile('[\\u4e00-\\u9fa5]')\n    match = pattern.search(str)\n    return match != None\n", "\n\ndef check_prefix(content, prefix_list):\n    if(len(prefix_list)==0):\n        return True\n    for prefix in prefix_list:\n        if content.startswith(prefix):\n            return prefix\n    return False\n", ""]}
{"filename": "common/log.py", "chunked_list": ["# encoding:utf-8\n\nimport logging\nimport sys\n\nSWITCH = True\n\ndef _get_logger():\n    log = logging.getLogger('log')\n    log.setLevel(logging.INFO)\n    console_handle = logging.StreamHandler(sys.stdout)\n    console_handle.setFormatter(logging.Formatter('[%(levelname)s][%(asctime)s][%(filename)s:%(lineno)d] - %(message)s',\n                                                  datefmt='%Y-%m-%d %H:%M:%S'))\n    log.addHandler(console_handle)\n    return log", "\ndef close_log():\n    global  SWITCH\n    SWITCH = False\n\n\ndef debug(arg, *args):\n    if SWITCH:\n        if len(args) == 0:\n            logger.debug(arg)\n        else:\n            logger.debug(arg.format(*args))", "\ndef info(arg, *args):\n    if SWITCH:\n        if len(args) == 0:\n            logger.info(arg)\n        else:\n            logger.info(arg.format(*args))\n\n\ndef warn(arg, *args):\n    if len(args) == 0:\n        logger.warning(arg)\n    else:\n        logger.warning(arg.format(*args))", "\ndef warn(arg, *args):\n    if len(args) == 0:\n        logger.warning(arg)\n    else:\n        logger.warning(arg.format(*args))\n\ndef error(arg, *args):\n    if len(args) == 0:\n        logger.error(arg)\n    else:\n        logger.error(arg.format(*args))", "\ndef exception(e):\n    logger.exception(e)\n\n\n# \u65e5\u5fd7\u53e5\u67c4\nlogger = _get_logger()\n"]}
{"filename": "common/sensitive_word.py", "chunked_list": ["import requests\nfrom  config import conf\n\nclass SensitiveWord:\n    def __init__(self):\n        # \u8bfb\u53d6\u914d\u7f6e\u6587\u4ef6\n        try:\n            self.config = conf()  # \u52a0\u8f7d\u914d\u7f6e\u6587\u4ef6\n            #print(self.config) # \u8f93\u51fa\u914d\u7f6e\u6587\u4ef6\u5185\u5bb9\u4ee5\u8fdb\u884c\u8c03\u8bd5\n        except Exception as e:\n            print(e)  # \u6253\u5370\u9519\u8bef\u4fe1\u606f\n\n        # \u8bbe\u7f6e\u8bf7\u6c42 URL\n        self.url = \"https://aip.baidubce.com/rest/2.0/antispam/v2/spam\"\n\n        # \u83b7\u53d6 access token\n        self.access_token = self.get_access_token()\n\n    def get_access_token(self):\n        \"\"\"\n        \u83b7\u53d6\u767e\u5ea6\u4e91\u63a5\u53e3\u7684 access token\n\n        :return: str access token\n        \n        \"\"\"\n        \n        #\u68c0\u6d4b\u654f\u611f\u8bcd\u914d\u7f6e\u662f\u5426\u5b58\u5728\n        if self.config is not None and \"common\" in self.config and \"type\" in self.config[\"common\"] and self.config[\"common\"][\"type\"]:\n\n            url = \"https://aip.baidubce.com/oauth/2.0/token\"\n            params = {\n                \"grant_type\": \"client_credentials\",\n                \"client_id\": self.config[\"common\"][\"client_id\"],\n                \"client_secret\": self.config[\"common\"][\"client_secret\"]\n            }\n            response = requests.post(url, params=params)\n            response_json = response.json()\n\n            access_token = response_json.get(\"access_token\")\n\n            if not access_token:\n                raise ValueError(f\"\u83b7\u53d6 access_token \u5931\u8d25: {response_json.get('error_description')}\")\n            \n            print(f\"Access token: {access_token}\")  # \u8f93\u51fa\u8bbf\u95ee\u4ee4\u724c\u4ee5\u8fdb\u884c\u8c03\u8bd5\n            return access_token\n\n\n    def process_text(self, text):\n\n        #\u68c0\u6d4b\u654f\u611f\u8bcd\u914d\u7f6e\u662f\u5426\u5b58\u5728\n        if self.config is not None and \"common\" in self.config and \"sensitive\" in self.config[\"common\"] and self.config[\"common\"][\"sensitive\"]:\n            #\u5b58\u5728\u5219\u6267\u884c\u6b63\u5e38\u68c0\u6d4b\u6d41\u7a0b\n            url = \"https://aip.baidubce.com/rest/2.0/solution/v1/text_censor/v2/user_defined\"  # API \u8bf7\u6c42\u5730\u5740\n            access_token = self.get_access_token()\n            headers = {\"content-type\": \"application/x-www-form-urlencoded\"}\n            params = {\n                \"text\": text.encode(\"utf-8\"),\n                \"access_token\": access_token\n            }\n            response = requests.post(url, data=params, headers=headers)\n\n            if response.status_code != 200:\n                raise ValueError(f\"\u65e0\u6cd5\u8fde\u63a5\u5230\u63a5\u53e3\uff0c\u8bf7\u68c0\u67e5\u4f60\u7684\u7f51\u7edc: {response.json().get('error_msg')}\")\n\n            conclusion_type = response.json().get(\"conclusionType\")\n\n\n            print(response.json())  # \u8f93\u51fa\u5b8c\u6574\u7684 API \u54cd\u5e94\u7ed3\u679c\n\n            if conclusion_type in [1, None]:\n                return False\n            else:\n                return True\n        #\u4e0d\u5b58\u5728\u5219\u76f4\u63a5\u8fd4\u56de\u65e0\u654f\u611f\u8bcd\n        else:\n            return False", ""]}
{"filename": "common/const.py", "chunked_list": ["# channel\nTERMINAL = \"terminal\"\nWECHAT = \"wechat\"\nWECHAT_MP = \"wechat_mp\"\nWECHAT_MP_SERVICE = \"wechat_mp_service\"\nWECHAT_COM = \"wechat_com\"\nQQ = \"qq\"\nGMAIL = \"gmail\"\nTELEGRAM = \"telegram\"\nSLACK = \"slack\"", "TELEGRAM = \"telegram\"\nSLACK = \"slack\"\nHTTP = \"http\"\nDINGTALK = \"dingtalk\"\nFEISHU = \"feishu\"\nDISCORD = \"discord\"\n\n# model\nOPEN_AI = \"openai\"\nCHATGPT = \"chatgpt\"", "OPEN_AI = \"openai\"\nCHATGPT = \"chatgpt\"\nZHISHUYUN = \"zhishuyun\"\nBAIDU = \"baidu\"\nBING = \"bing\"\nBARD = \"bard\""]}
{"filename": "model/model.py", "chunked_list": ["\"\"\"\nAuto-replay chat robot abstract class\n\"\"\"\n\n\nclass Model(object):\n    def reply(self, query, context=None):\n        \"\"\"\n        model auto-reply content\n        :param req: received message\n        :return: reply content\n        \"\"\"\n        raise NotImplementedError", ""]}
{"filename": "model/model_factory.py", "chunked_list": ["\"\"\"\nchannel factory\n\"\"\"\n\nfrom common import const\n\ndef create_bot(model_type):\n    \"\"\"\n    create a channel instance\n    :param channel_type: channel type code\n    :return: channel instance\n    \"\"\"\n\n    if model_type == const.OPEN_AI:\n        # OpenAI \u5b98\u65b9\u5bf9\u8bdd\u6a21\u578bAPI (gpt-3.0)\n        from model.openai.open_ai_model import OpenAIModel\n        return OpenAIModel()\n\n    elif model_type == const.CHATGPT:\n        # ChatGPT API (gpt-3.5-turbo)\n        from model.openai.chatgpt_model import ChatGPTModel\n        return ChatGPTModel()\n    \n    elif model_type == const.ZHISHUYUN:\n        from model.openai.zhishuyun_model import ZhishuyunModel\n        return ZhishuyunModel()\n\n    elif model_type == const.BAIDU:\n        from model.baidu.yiyan_model import YiyanModel\n        return YiyanModel()\n\n    elif model_type == const.BING:\n        from model.bing.new_bing_model import BingModel\n        return BingModel()\n\n    elif model_type == const.BARD:\n        from model.google.bard_model import BardModel\n        return BardModel()\n\n    raise RuntimeError", ""]}
{"filename": "model/bing/new_bing_model.py", "chunked_list": ["# encoding:utf-8\nimport asyncio\nfrom model.model import Model\nfrom config import model_conf_val, common_conf_val\nfrom common import log\nfrom EdgeGPT import Chatbot, ConversationStyle\nfrom ImageGen import ImageGen\nfrom common import functions\nfrom model.bing.jailbroken_sydney import SydneyBot\n", "from model.bing.jailbroken_sydney import SydneyBot\n\nuser_session = dict()\nsuggestion_session = dict()\n# newBing\u5bf9\u8bdd\u6a21\u578b\u9006\u5411\u7f51\u9875gitAPI\n\n\nclass BingModel(Model):\n\n    style = ConversationStyle.creative\n    bot: Chatbot = None\n    cookies: list = None\n\n    def __init__(self):\n        try:\n            self.cookies = model_conf_val(\"bing\", \"cookies\")\n            self.jailbreak = model_conf_val(\"bing\", \"jailbreak\")\n            self.bot = SydneyBot(cookies=self.cookies, options={}) if (\n                self.jailbreak) else Chatbot(cookies=self.cookies)\n        except Exception as e:\n            log.warn(e)\n\n    async def reply_text_stream(self, query: str, context=None) -> dict:\n        async def handle_answer(final, answer):\n            if final:\n                try:\n                    reply = self.build_source_attributions(answer, context)\n                    log.info(\"[NewBing] reply:{}\", reply)\n                    yield True, reply\n                except Exception as e:\n                    log.warn(answer)\n                    log.warn(e)\n                    await user_session.get(context['from_user_id'], None).reset()\n                    yield True, answer\n            else:\n                try:\n                    yield False, answer\n                except Exception as e:\n                    log.warn(answer)\n                    log.warn(e)\n                    await user_session.get(context['from_user_id'], None).reset()\n                    yield True, answer\n\n        if not context or not context.get('type') or context.get('type') == 'TEXT':\n            clear_memory_commands = common_conf_val(\n                'clear_memory_commands', ['#\u6e05\u9664\u8bb0\u5fc6'])\n            if query in clear_memory_commands:\n                user_session[context['from_user_id']] = None\n                yield True, '\u8bb0\u5fc6\u5df2\u6e05\u9664'\n            bot = user_session.get(context['from_user_id'], None)\n            if not bot:\n                bot = self.bot\n            else:\n                query = self.get_quick_ask_query(query, context)\n            user_session[context['from_user_id']] = bot\n            log.info(\"[NewBing] query={}\".format(query))\n            if self.jailbreak:\n                async for final, answer in bot.ask_stream(query, conversation_style=self.style, message_id=bot.user_message_id):\n                    async for result in handle_answer(final, answer):\n                        yield result\n            else:\n                async for final, answer in bot.ask_stream(query, conversation_style=self.style):\n                    async for result in handle_answer(final, answer):\n                        yield result\n\n    def reply(self, query: str, context=None) -> tuple[str, dict]:\n        if not context or not context.get('type') or context.get('type') == 'TEXT':\n            clear_memory_commands = common_conf_val(\n                'clear_memory_commands', ['#\u6e05\u9664\u8bb0\u5fc6'])\n            if query in clear_memory_commands:\n                user_session[context['from_user_id']] = None\n                return '\u8bb0\u5fc6\u5df2\u6e05\u9664'\n            bot = user_session.get(context['from_user_id'], None)\n            if (bot == None):\n                bot = self.bot\n            else:\n                query = self.get_quick_ask_query(query, context)\n\n            user_session[context['from_user_id']] = bot\n            log.info(\"[NewBing] query={}\".format(query))\n            if (self.jailbreak):\n                task = bot.ask(query, conversation_style=self.style,\n                               message_id=bot.user_message_id)\n            else:\n                task = bot.ask(query, conversation_style=self.style)\n\n            answer = asyncio.run(task)\n            if isinstance(answer, str):\n                return answer\n            try:\n                reply = answer[\"item\"][\"messages\"][-1]\n            except Exception as e:\n                user_session.get(context['from_user_id'], None).reset()\n                log.warn(answer)\n                return \"\u672c\u8f6e\u5bf9\u8bdd\u5df2\u8d85\u65f6\uff0c\u5df2\u5f00\u542f\u65b0\u7684\u4e00\u8f6e\u5bf9\u8bdd,\u8bf7\u91cd\u65b0\u63d0\u95ee\u3002\"\n            return self.build_source_attributions(answer, context)\n        elif context.get('type', None) == 'IMAGE_CREATE':\n            if functions.contain_chinese(query):\n                return \"ImageGen\u76ee\u524d\u4ec5\u652f\u6301\u4f7f\u7528\u82f1\u6587\u5173\u952e\u8bcd\u751f\u6210\u56fe\u7247\"\n            return self.create_img(query)\n\n    def create_img(self, query):\n        try:\n            log.info(\"[NewBing] image_query={}\".format(query))\n            cookie_value = self.cookies[0][\"value\"]\n            image_generator = ImageGen(cookie_value)\n            img_list = image_generator.get_images(query)\n            log.info(\"[NewBing] image_list={}\".format(img_list))\n            return img_list\n        except Exception as e:\n            log.warn(e)\n            return \"\u8f93\u5165\u7684\u5185\u5bb9\u53ef\u80fd\u8fdd\u53cd\u5fae\u8f6f\u7684\u56fe\u7247\u751f\u6210\u5185\u5bb9\u7b56\u7565\u3002\u8fc7\u591a\u7684\u7b56\u7565\u51b2\u7a81\u53ef\u80fd\u4f1a\u5bfc\u81f4\u4f60\u88ab\u6682\u505c\u8bbf\u95ee\u3002\"\n\n    def get_quick_ask_query(self, query, context):\n        if (len(query) == 1 and query.isdigit() and query != \"0\"):\n            suggestion_dict = suggestion_session[context['from_user_id']]\n            if (suggestion_dict != None):\n                query = suggestion_dict[int(query)-1]\n                if (query == None):\n                    return \"\u8f93\u5165\u7684\u5e8f\u53f7\u4e0d\u5728\u5efa\u8bae\u5217\u8868\u8303\u56f4\u4e2d\"\n                else:\n                    query = \"\u5728\u4e0a\u9762\u7684\u57fa\u7840\u4e0a\uff0c\"+query\n        return query\n\n    def build_source_attributions(self, answer, context):\n        reference = \"\"\n        reply = answer[\"item\"][\"messages\"][-1]\n        reply_text = reply[\"text\"]\n        if \"sourceAttributions\" in reply:\n            for i, attribution in enumerate(reply[\"sourceAttributions\"]):\n                display_name = attribution[\"providerDisplayName\"]\n                url = attribution[\"seeMoreUrl\"]\n                reference += f\"{i+1}\u3001[{display_name}]({url})\\n\\n\"\n\n            if len(reference) > 0:\n                reference = \"***\\n\"+reference\n\n            suggestion = \"\"\n            if \"suggestedResponses\" in reply:\n                suggestion_dict = dict()\n                for i, attribution in enumerate(reply[\"suggestedResponses\"]):\n                    suggestion_dict[i] = attribution[\"text\"]\n                    suggestion += f\">{i+1}\u3001{attribution['text']}\\n\\n\"\n                suggestion_session[context['from_user_id']\n                                   ] = suggestion_dict\n\n            if len(suggestion) > 0:\n                suggestion = \"***\\n\u4f60\u53ef\u4ee5\u901a\u8fc7\u8f93\u5165\u5e8f\u53f7\u5feb\u901f\u8ffd\u95ee\u6211\u4ee5\u4e0b\u5efa\u8bae\u95ee\u9898\uff1a\\n\\n\"+suggestion\n\n            throttling = answer[\"item\"][\"throttling\"]\n            throttling_str = \"\"\n\n            if throttling[\"numUserMessagesInConversation\"] == throttling[\"maxNumUserMessagesInConversation\"]:\n                user_session.get(context['from_user_id'], None).reset()\n                throttling_str = \"(\u5bf9\u8bdd\u8f6e\u6b21\u5df2\u8fbe\u4e0a\u9650\uff0c\u672c\u6b21\u804a\u5929\u5df2\u7ed3\u675f\uff0c\u5c06\u5f00\u542f\u65b0\u7684\u5bf9\u8bdd)\"\n            else:\n                throttling_str = f\"\u5bf9\u8bdd\u8f6e\u6b21: {throttling['numUserMessagesInConversation']}/{throttling['maxNumUserMessagesInConversation']}\\n\"\n\n            response = f\"{reply_text}\\n{reference}\\n{suggestion}\\n***\\n{throttling_str}\"\n            log.info(\"[NewBing] reply={}\", response)\n            return response\n        else:\n            user_session.get(context['from_user_id'], None).reset()\n            log.warn(\"[NewBing] reply={}\", answer)\n            return \"\u5bf9\u8bdd\u88ab\u63a5\u53e3\u62d2\u7edd\uff0c\u5df2\u5f00\u542f\u65b0\u7684\u4e00\u8f6e\u5bf9\u8bdd\u3002\"", ""]}
{"filename": "model/bing/jailbroken_sydney.py", "chunked_list": ["# encoding:utf-8\nimport asyncio\nimport time\nimport websockets\nimport random\nimport uuid\nimport EdgeGPT\nfrom EdgeGPT import ChatHubRequest, Chatbot, Conversation, ChatHub\nfrom typing import Generator\nfrom config import model_conf_val", "from typing import Generator\nfrom config import model_conf_val\n\n\nclass SydneyBot(Chatbot):\n    def __init__(\n        self,\n        cookiePath: str = \"\",\n        cookies: dict | None = None,\n        proxy: str | None = None,\n        options: dict | None = None,\n    ) -> None:\n        self.conversations_cache = {}\n        self.parent_message_id = 0\n        self.user_message_id = 0\n        self.conversation_key = uuid.uuid4()\n        self.cookiePath: str = cookiePath\n        self.cookies: dict | None = cookies\n        self.proxy: str | None = proxy\n        self.chat_hub: SydneyHub\n        cache_options = options.get('cache', {})\n        cache_options['namespace'] = cache_options.get('namespace', 'bing')\n        self.conversations_cache = cache_options\n\n    @staticmethod\n    def get_messages_for_conversation(messages, parent_message_id):\n        ordered_messages = []\n        current_message_id = parent_message_id\n        while current_message_id:\n            message = next(\n                (m for m in messages if m['id'] == current_message_id), None)\n            if not message:\n                break\n            ordered_messages.insert(0, message)\n            current_message_id = message.get('parentMessageId')\n        return ordered_messages\n\n    async def ask_stream(\n        self,\n        prompt: str,\n        conversation_style: EdgeGPT.CONVERSATION_STYLE_TYPE = None,\n        message_id: str = None\n    ) -> dict:\n        # \u5f00\u542f\u65b0\u5bf9\u8bdd\n        self.chat_hub = SydneyHub(Conversation(\n            self.cookiePath, self.cookies, self.proxy))\n        self.parent_message_id = message_id if message_id != None else uuid.uuid4()\n        # \u6784\u9020\u5386\u53f2\u5bf9\u8bdd\u5b57\u7b26\u4e32,\u66f4\u65b0SydneyHubRequest\u7684\u5386\u53f2\u5bf9\u8bdd\n        conversation = self.conversations_cache.get(self.conversation_key)\n        if conversation is None:\n            conversation = {\n                \"messages\": [],\n                \"createdAt\": int(time.time()*1000)\n            }\n        previous_cached_messages = \"\"\n        for conversation_message in self.get_messages_for_conversation(conversation[\"messages\"], self.parent_message_id):\n            previous_cached_messages += f\"{conversation_message['role'].replace('bot', 'AI')}:\\n{conversation_message['message']}\\n\\n\"\n        chars = list(model_conf_val(\"bing\", \"jailbreak_prompt\"))\n        chars = [('-' + c if random.random() < 0.5 else '_' + c)\n                 if i > 0 else c for i, c in enumerate(chars)]\n        previous_messages = ''.join(chars)\n        self.chat_hub.request.previous_messages = previous_messages + \\\n            \"\\n\\n\"+previous_cached_messages\n\n        # \u5c06\u5f53\u524d\u63d0\u95ee\u52a0\u5165\u5386\u53f2\u5bf9\u8bdd\u5217\u8868\n        self.user_message_id = uuid.uuid4()\n        user_message = {\n            \"id\": self.user_message_id,\n            \"parentMessageId\": self.parent_message_id,\n            \"role\": 'User',\n            \"message\": prompt,\n        }\n        conversation[\"messages\"].append(user_message)\n        self.conversations_cache[self.conversation_key] = conversation\n\n        async for final, response in self.chat_hub.ask_stream(\n            prompt=prompt,\n            conversation_style=conversation_style\n        ):\n            if final:\n                try:\n                    if self.chat_hub.wss and not self.chat_hub.wss.closed:\n                        await self.chat_hub.wss.close()\n                    self.update_reply_cache(response[\"item\"][\"messages\"][-1])\n                except Exception as e:\n                    self.conversations_cache[self.conversation_key][\"messages\"].pop()\n                    yield True, f\"AI\u751f\u6210\u5185\u5bb9\u88ab\u5fae\u8f6f\u5185\u5bb9\u8fc7\u6ee4\u5668\u62e6\u622a,\u5df2\u5220\u9664\u6700\u540e\u4e00\u6b21\u63d0\u95ee\u7684\u8bb0\u5fc6,\u8bf7\u5c1d\u8bd5\u4f7f\u7528\u5176\u4ed6\u6587\u5b57\u63cf\u8ff0\u95ee\u9898,\u82e5AI\u4f9d\u7136\u65e0\u6cd5\u6b63\u5e38\u56de\u590d,\u8bf7\u6e05\u9664\u5168\u90e8\u8bb0\u5fc6\u540e\u518d\u6b21\u5c1d\u8bd5\"\n            yield final, response\n\n    async def ask(\n        self,\n        prompt: str,\n        conversation_style: EdgeGPT.CONVERSATION_STYLE_TYPE = None,\n        message_id: str = None\n    ) -> dict:\n        async for final, response in self.ask_stream(\n            prompt=prompt,\n            conversation_style=conversation_style,\n            message_id=message_id\n        ):\n            if final:\n                self.update_reply_cache(response[\"item\"][\"messages\"][-1])\n                return response\n\n    def update_reply_cache(\n        self,\n        reply,\n    ) -> None:\n        # \u5c06\u56de\u590d\u52a0\u5165\u5386\u53f2\u5bf9\u8bdd\u5217\u8868\n        replyMessage = {\n            \"id\": uuid.uuid4(),\n            \"parentMessageId\": self.user_message_id,\n            \"role\": 'Bing',\n            \"message\": reply[\"text\"],\n            \"details\": reply,\n        }\n        self.conversations_cache[self.conversation_key][\"messages\"].append(\n            replyMessage)\n        self.user_message_id = replyMessage[\"id\"]", "\n\nclass SydneyHub(ChatHub):\n    \"\"\"\n    Chat API\n    \"\"\"\n\n    def __init__(self, conversation: Conversation) -> None:\n        self.wss: websockets.WebSocketClientProtocol | None = None\n        self.request: SydneyHubRequest\n        self.loop: bool\n        self.task: asyncio.Task\n        self.request = SydneyHubRequest(\n            conversation_signature=conversation.struct[\"conversationSignature\"],\n            client_id=conversation.struct[\"clientId\"],\n            conversation_id=conversation.struct[\"conversationId\"],\n        )\n\n    async def ask_stream(\n        self,\n        prompt: str,\n        wss_link: str = \"wss://sydney.bing.com/sydney/ChatHub\",\n        conversation_style: EdgeGPT.CONVERSATION_STYLE_TYPE = None,\n    ) -> Generator[str, None, None]:\n        async for item in super().ask_stream(prompt=prompt, conversation_style=conversation_style, wss_link=wss_link):\n            yield item", "\n\nclass SydneyHubRequest(ChatHubRequest):\n\n    def __init__(\n        self,\n        conversation_signature: str,\n        client_id: str,\n        conversation_id: str,\n        invocation_id: int = 0,\n    ) -> None:\n        super().__init__(conversation_signature=conversation_signature, client_id=client_id,\n                         conversation_id=conversation_id, invocation_id=invocation_id)\n        self.previous_messages = \"\"\n\n    def update(\n        self,\n        prompt: str,\n        conversation_style: EdgeGPT.CONVERSATION_STYLE_TYPE,\n        options: list | None = None,\n    ) -> None:\n        self.invocation_id = 0\n        super().update(prompt=prompt, conversation_style=conversation_style, options=options)\n        self.struct[\"arguments\"][0][\"message\"][\"messageType\"] = \"SearchQuery\"\n        self.struct[\"arguments\"][0][\"previousMessages\"] = [\n            {\"text\":  \"N/A\\n\\n\"+self.previous_messages, \"author\": 'bot', }]", ""]}
{"filename": "model/baidu/yiyan_model.py", "chunked_list": ["# encoding:utf-8\n\nfrom model.model import Model\nfrom config import model_conf\nfrom common import const\nfrom common.log import logger\nimport requests\nimport time\n\nsessions = {}", "\nsessions = {}\n\nclass YiyanModel(Model):\n    def __init__(self):\n        self.acs_token = model_conf(const.BAIDU).get('acs_token')\n        self.cookie = model_conf(const.BAIDU).get('cookie')\n        self.base_url = 'https://yiyan.baidu.com/eb'\n\n    def reply(self, query, context=None):\n        logger.info(\"[BAIDU] query={}\".format(query))\n        user_id = context.get('session_id') or context.get('from_user_id')\n        context['query'] = query\n\n        # 1.create session\n        chat_session_id = sessions.get(user_id)\n        if not chat_session_id:\n            self.new_session(context)\n            sessions[user_id] = context['chat_session_id']\n        else:\n            context['chat_session_id'] = chat_session_id\n\n        # 2.create chat\n        flag = self.new_chat(context)\n        if not flag:\n            return \"\u521b\u5efa\u4f1a\u8bdd\u5931\u8d25\uff0c\u8bf7\u7a0d\u540e\u518d\u8bd5\"\n\n        # 3.query\n        context['reply'] = ''\n        self.query(context, 0, 0)\n\n        return context['reply']\n\n\n    def new_session(self, context):\n        data = {\n            \"sessionName\": context['query'],\n            \"timestamp\": int(time.time() * 1000),\n            \"deviceType\": \"pc\"\n        }\n        res = requests.post(url=self.base_url+'/session/new', headers=self._create_header(), json=data)\n        # print(res.headers)\n        context['chat_session_id'] = res.json()['data']['sessionId']\n        logger.info(\"[BAIDU] newSession: id={}\".format(context['chat_session_id']))\n\n\n    def new_chat(self, context):\n        headers = self._create_header()\n        headers['Acs-Token'] = self.acs_token\n        data = {\n            \"sessionId\": context.get('chat_session_id'),\n            \"text\": context['query'],\n            \"parentChatId\": 0,\n            \"type\": 10,\n            \"timestamp\": int(time.time() * 1000),\n            \"deviceType\": \"pc\",\n            \"code\": 0,\n            \"msg\": \"\"\n        }\n        res = requests.post(url=self.base_url+'/chat/new', headers=headers, json=data).json()\n        if res['code'] != 0:\n            logger.error(\"[BAIDU] New chat error, msg={}\", res['msg'])\n            return False\n        context['chat_id'] = res['data']['botChat']['id']\n        context['parent_chat_id'] = res['data']['botChat']['parent']\n        return True\n\n\n    def query(self, context, sentence_id, count):\n        headers = self._create_header()\n        headers['Acs-Token'] = self.acs_token\n        data = {\n            \"chatId\": context['chat_id'],\n            \"parentChatId\": context['parent_chat_id'],\n            \"sentenceId\": sentence_id,\n            \"stop\": 0,\n            \"timestamp\": 1679068791405,\n            \"deviceType\": \"pc\"\n        }\n        res = requests.post(url=self.base_url + '/chat/query', headers=headers, json=data)\n        logger.debug(\"[BAIDU] query: sent_id={}, count={}, res={}\".format(sentence_id, count, res.text))\n\n        res = res.json()\n        if res['data']['text'] != '':\n            context['reply'] += res['data']['text']\n            # logger.debug(\"[BAIDU] query: sent_id={}, reply={}\".format(sentence_id, res['data']['text']))\n\n        if res['data']['is_end'] == 1:\n            return\n\n        if count > 10:\n            return\n\n        time.sleep(1)\n        if not res['data']['text']:\n            return self.query(context, sentence_id, count+1)\n        else:\n            return self.query(context, sentence_id+1, count+1)\n\n\n    def _create_header(self):\n        headers = {\n            'Host': 'yiyan.baidu.com',\n            'Origin': 'https://yiyan.baidu.com',\n            'Referer': 'https://yiyan.baidu.com',\n            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36',\n            'Content-Type': 'application/json',\n            'Cookie': self.cookie\n        }\n        return headers", ""]}
{"filename": "model/openai/zhishuyun_model.py", "chunked_list": ["# encoding:utf-8\n\nfrom model.model import Model\nfrom config import model_conf, common_conf_val\nfrom common import const\nfrom common import log\nimport openai\nimport time\nimport requests\n", "import requests\n\nuser_session = dict()\nuser_conversation_id = {}\n\n# OpenAI\u5bf9\u8bdd\u6a21\u578bAPI (\u53ef\u7528)\nclass ZhishuyunModel(Model):\n    def __init__(self):\n        self.token = model_conf(const.OPEN_AI).get('token')\n    def reply(self, query, context=None):\n        # acquire reply content\n        if not context or not context.get('type') or context.get('type') == 'TEXT':\n            log.info(\"[CHATGPT] query={}\".format(query))\n            from_user_id = context['from_user_id']\n            clear_memory_commands = common_conf_val('clear_memory_commands', ['#\u6e05\u9664\u8bb0\u5fc6'])\n            if query in clear_memory_commands:\n                Session.clear_session(from_user_id)\n                return '\u8bb0\u5fc6\u5df2\u6e05\u9664'\n\n            new_query = Session.build_session_query(query, from_user_id)\n            log.debug(\"[CHATGPT] session query={}\".format(new_query))\n\n            # if context.get('stream'):\n            #     # reply in stream\n            #     return self.reply_text_stream(query, new_query, from_user_id)\n\n            reply_content = self.reply_text(new_query, from_user_id, 0)\n            #log.debug(\"[CHATGPT] new_query={}, user={}, reply_cont={}\".format(new_query, from_user_id, reply_content))\n            return reply_content\n\n        elif context.get('type', None) == 'IMAGE_CREATE':\n            return self.create_img(query, 0)\n\n    def reply_text(self, query, user_id, retry_count=0):\n        try:\n            url = f'https://api.zhishuyun.com/chatgpt?token={self.token}'\n            headers = {\n                'accept': 'application/json',\n                'content-type': 'application/json'\n            }\n            if user_id in user_conversation_id:\n                conversation_id = user_conversation_id[user_id]\n                payload = {\n                    'question': query[-1]['content'],\n                    \"stateful\": True,\n                    'conversation_id': conversation_id\n                }\n            else:\n                payload = {\n                    'question': query[-1]['content'],\n                    \"stateful\": True\n                }\n\n            response = requests.post(url, json=payload, headers=headers)\n\n            answer = response.json()['answer']\n            conversation_id = response.json()['conversation_id']\n            user_conversation_id[user_id] = conversation_id\n\n            used_token = 500\n            log.debug(response)\n            log.info(\"[CHATGPT] reply={}\", answer)\n            if answer:\n                # save conversation\n                Session.save_session(query, answer, user_id, used_token)\n            return answer\n        \n        except openai.error.RateLimitError as e:\n            # rate limit exception\n            log.warn(e)\n            if retry_count < 1:\n                time.sleep(5)\n                log.warn(\"[CHATGPT] RateLimit exceed, \u7b2c{}\u6b21\u91cd\u8bd5\".format(retry_count+1))\n                return self.reply_text(query, user_id, retry_count+1)\n            else:\n                return \"\u63d0\u95ee\u592a\u5feb\u5566\uff0c\u8bf7\u4f11\u606f\u4e00\u4e0b\u518d\u95ee\u6211\u5427\"\n        except openai.error.APIConnectionError as e:\n            log.warn(e)\n            log.warn(\"[CHATGPT] APIConnection failed\")\n            return \"\u6211\u8fde\u63a5\u4e0d\u5230\u7f51\u7edc\uff0c\u8bf7\u7a0d\u540e\u91cd\u8bd5\"\n        except openai.error.Timeout as e:\n            log.warn(e)\n            log.warn(\"[CHATGPT] Timeout\")\n            return \"\u6211\u6ca1\u6709\u6536\u5230\u6d88\u606f\uff0c\u8bf7\u7a0d\u540e\u91cd\u8bd5\"\n        except Exception as e:\n            # unknown exception\n            log.exception(e)\n            Session.clear_session(user_id)\n            return \"\u8bf7\u518d\u95ee\u6211\u4e00\u6b21\u5427\"\n\n\n    async def reply_text_stream(self, query,  context, retry_count=0):\n        try:\n            user_id=context['from_user_id']\n            new_query = Session.build_session_query(query, user_id)\n            res = openai.ChatCompletion.create(\n                model= model_conf(const.OPEN_AI).get(\"model\") or \"gpt-3.5-turbo\",  # \u5bf9\u8bdd\u6a21\u578b\u7684\u540d\u79f0\n                messages=new_query,\n                temperature=model_conf(const.OPEN_AI).get(\"temperature\", 0.75),  # \u71b5\u503c\uff0c\u5728[0,1]\u4e4b\u95f4\uff0c\u8d8a\u5927\u8868\u793a\u9009\u53d6\u7684\u5019\u9009\u8bcd\u8d8a\u968f\u673a\uff0c\u56de\u590d\u8d8a\u5177\u6709\u4e0d\u786e\u5b9a\u6027\uff0c\u5efa\u8bae\u548ctop_p\u53c2\u6570\u4e8c\u9009\u4e00\u4f7f\u7528\uff0c\u521b\u610f\u6027\u4efb\u52a1\u8d8a\u5927\u8d8a\u597d\uff0c\u7cbe\u786e\u6027\u4efb\u52a1\u8d8a\u5c0f\u8d8a\u597d\n                #max_tokens=4096,  # \u56de\u590d\u6700\u5927\u7684\u5b57\u7b26\u6570\uff0c\u4e3a\u8f93\u5165\u548c\u8f93\u51fa\u7684\u603b\u6570\n                #top_p=model_conf(const.OPEN_AI).get(\"top_p\", 0.7),,  #\u5019\u9009\u8bcd\u5217\u8868\u30020.7 \u610f\u5473\u7740\u53ea\u8003\u8651\u524d70%\u5019\u9009\u8bcd\u7684\u6807\u8bb0\uff0c\u5efa\u8bae\u548ctemperature\u53c2\u6570\u4e8c\u9009\u4e00\u4f7f\u7528\n                frequency_penalty=model_conf(const.OPEN_AI).get(\"frequency_penalty\", 0.0),  # [-2,2]\u4e4b\u95f4\uff0c\u8be5\u503c\u8d8a\u5927\u5219\u8d8a\u964d\u4f4e\u6a21\u578b\u4e00\u884c\u4e2d\u7684\u91cd\u590d\u7528\u8bcd\uff0c\u66f4\u503e\u5411\u4e8e\u4ea7\u751f\u4e0d\u540c\u7684\u5185\u5bb9\n                presence_penalty=model_conf(const.OPEN_AI).get(\"presence_penalty\", 1.0),  # [-2,2]\u4e4b\u95f4\uff0c\u8be5\u503c\u8d8a\u5927\u5219\u8d8a\u4e0d\u53d7\u8f93\u5165\u9650\u5236\uff0c\u5c06\u9f13\u52b1\u6a21\u578b\u751f\u6210\u8f93\u5165\u4e2d\u4e0d\u5b58\u5728\u7684\u65b0\u8bcd\uff0c\u66f4\u503e\u5411\u4e8e\u4ea7\u751f\u4e0d\u540c\u7684\u5185\u5bb9\n                stream=True\n            )\n            full_response = \"\"\n            for chunk in res:\n                log.debug(chunk)\n                if (chunk[\"choices\"][0][\"finish_reason\"]==\"stop\"):\n                    break\n                chunk_message = chunk['choices'][0]['delta'].get(\"content\")\n                if(chunk_message):\n                    full_response+=chunk_message\n                yield False,full_response\n            Session.save_session(query, full_response, user_id)\n            log.info(\"[chatgpt]: reply={}\", full_response)\n            yield True,full_response\n\n        except openai.error.RateLimitError as e:\n            # rate limit exception\n            log.warn(e)\n            if retry_count < 1:\n                time.sleep(5)\n                log.warn(\"[CHATGPT] RateLimit exceed, \u7b2c{}\u6b21\u91cd\u8bd5\".format(retry_count+1))\n                yield True, self.reply_text_stream(query, user_id, retry_count+1)\n            else:\n                yield True, \"\u63d0\u95ee\u592a\u5feb\u5566\uff0c\u8bf7\u4f11\u606f\u4e00\u4e0b\u518d\u95ee\u6211\u5427\"\n        except openai.error.APIConnectionError as e:\n            log.warn(e)\n            log.warn(\"[CHATGPT] APIConnection failed\")\n            yield True, \"\u6211\u8fde\u63a5\u4e0d\u5230\u7f51\u7edc\uff0c\u8bf7\u7a0d\u540e\u91cd\u8bd5\"\n        except openai.error.Timeout as e:\n            log.warn(e)\n            log.warn(\"[CHATGPT] Timeout\")\n            yield True, \"\u6211\u6ca1\u6709\u6536\u5230\u6d88\u606f\uff0c\u8bf7\u7a0d\u540e\u91cd\u8bd5\"\n        except Exception as e:\n            # unknown exception\n            log.exception(e)\n            Session.clear_session(user_id)\n            yield True, \"\u8bf7\u518d\u95ee\u6211\u4e00\u6b21\u5427\"\n\n    def create_img(self, query, retry_count=0):\n        try:\n            log.info(\"[OPEN_AI] image_query={}\".format(query))\n            response = openai.Image.create(\n                prompt=query,    #\u56fe\u7247\u63cf\u8ff0\n                n=1,             #\u6bcf\u6b21\u751f\u6210\u56fe\u7247\u7684\u6570\u91cf\n                size=\"256x256\"   #\u56fe\u7247\u5927\u5c0f,\u53ef\u9009\u6709 256x256, 512x512, 1024x1024\n            )\n            image_url = response['data'][0]['url']\n            log.info(\"[OPEN_AI] image_url={}\".format(image_url))\n            return [image_url]\n        except openai.error.RateLimitError as e:\n            log.warn(e)\n            if retry_count < 1:\n                time.sleep(5)\n                log.warn(\"[OPEN_AI] ImgCreate RateLimit exceed, \u7b2c{}\u6b21\u91cd\u8bd5\".format(retry_count+1))\n                return self.reply_text(query, retry_count+1)\n            else:\n                return \"\u63d0\u95ee\u592a\u5feb\u5566\uff0c\u8bf7\u4f11\u606f\u4e00\u4e0b\u518d\u95ee\u6211\u5427\"\n        except Exception as e:\n            log.exception(e)\n            return None", "\n\nclass Session(object):\n    @staticmethod\n    def build_session_query(query, user_id):\n        '''\n        build query with conversation history\n        e.g.  [\n            {\"role\": \"system\", \"content\": \"You are a helpful assistant.\"},\n            {\"role\": \"user\", \"content\": \"Who won the world series in 2020?\"},\n            {\"role\": \"assistant\", \"content\": \"The Los Angeles Dodgers won the World Series in 2020.\"},\n            {\"role\": \"user\", \"content\": \"Where was it played?\"}\n        ]\n        :param query: query content\n        :param user_id: from user id\n        :return: query content with conversaction\n        '''\n        session = user_session.get(user_id, [])\n        if len(session) == 0:\n            system_prompt = model_conf(const.OPEN_AI).get(\"character_desc\", \"\")\n            system_item = {'role': 'system', 'content': system_prompt}\n            session.append(system_item)\n            user_session[user_id] = session\n        user_item = {'role': 'user', 'content': query}\n        session.append(user_item)\n        return session\n\n    @staticmethod\n    def save_session(query, answer, user_id, used_tokens=0):\n        max_tokens = model_conf(const.OPEN_AI).get('conversation_max_tokens')\n        max_history_num = model_conf(const.OPEN_AI).get('max_history_num', None)\n        if not max_tokens or max_tokens > 4000:\n            # default value\n            max_tokens = 1000\n        session = user_session.get(user_id)\n        if session:\n            # append conversation\n            gpt_item = {'role': 'assistant', 'content': answer}\n            session.append(gpt_item)\n\n        if used_tokens > max_tokens and len(session) >= 3:\n            # pop first conversation (TODO: more accurate calculation)\n            session.pop(1)\n            session.pop(1)\n\n        if max_history_num is not None:\n            while len(session) > max_history_num * 2 + 1:\n                session.pop(1)\n                session.pop(1)\n\n    @staticmethod\n    def clear_session(user_id):\n        user_session[user_id] = []", "\n"]}
{"filename": "model/openai/chatgpt_model.py", "chunked_list": ["# encoding:utf-8\n\nfrom model.model import Model\nfrom config import model_conf, common_conf_val\nfrom common import const\nfrom common import log\nimport openai\nimport time\n\nuser_session = dict()", "\nuser_session = dict()\n\n# OpenAI\u5bf9\u8bdd\u6a21\u578bAPI (\u53ef\u7528)\nclass ChatGPTModel(Model):\n    def __init__(self):\n        openai.api_key = model_conf(const.OPEN_AI).get('api_key')\n        api_base = model_conf(const.OPEN_AI).get('api_base')\n        if api_base:\n            openai.api_base = api_base\n        proxy = model_conf(const.OPEN_AI).get('proxy')\n        if proxy:\n            openai.proxy = proxy\n        log.info(\"[CHATGPT] api_base={} proxy={}\".format(\n            api_base, proxy))\n    def reply(self, query, context=None):\n        # acquire reply content\n        if not context or not context.get('type') or context.get('type') == 'TEXT':\n            log.info(\"[CHATGPT] query={}\".format(query))\n            from_user_id = context['from_user_id']\n            clear_memory_commands = common_conf_val('clear_memory_commands', ['#\u6e05\u9664\u8bb0\u5fc6'])\n            if query in clear_memory_commands:\n                Session.clear_session(from_user_id)\n                return '\u8bb0\u5fc6\u5df2\u6e05\u9664'\n\n            new_query = Session.build_session_query(query, from_user_id)\n            log.debug(\"[CHATGPT] session query={}\".format(new_query))\n\n            # if context.get('stream'):\n            #     # reply in stream\n            #     return self.reply_text_stream(query, new_query, from_user_id)\n\n            reply_content = self.reply_text(new_query, from_user_id, 0)\n            #log.debug(\"[CHATGPT] new_query={}, user={}, reply_cont={}\".format(new_query, from_user_id, reply_content))\n            return reply_content\n\n        elif context.get('type', None) == 'IMAGE_CREATE':\n            return self.create_img(query, 0)\n\n    def reply_text(self, query, user_id, retry_count=0):\n        try:\n            response = openai.ChatCompletion.create(\n                model= model_conf(const.OPEN_AI).get(\"model\") or \"gpt-3.5-turbo\",  # \u5bf9\u8bdd\u6a21\u578b\u7684\u540d\u79f0\n                messages=query,\n                temperature=model_conf(const.OPEN_AI).get(\"temperature\", 0.75),  # \u71b5\u503c\uff0c\u5728[0,1]\u4e4b\u95f4\uff0c\u8d8a\u5927\u8868\u793a\u9009\u53d6\u7684\u5019\u9009\u8bcd\u8d8a\u968f\u673a\uff0c\u56de\u590d\u8d8a\u5177\u6709\u4e0d\u786e\u5b9a\u6027\uff0c\u5efa\u8bae\u548ctop_p\u53c2\u6570\u4e8c\u9009\u4e00\u4f7f\u7528\uff0c\u521b\u610f\u6027\u4efb\u52a1\u8d8a\u5927\u8d8a\u597d\uff0c\u7cbe\u786e\u6027\u4efb\u52a1\u8d8a\u5c0f\u8d8a\u597d\n                #max_tokens=4096,  # \u56de\u590d\u6700\u5927\u7684\u5b57\u7b26\u6570\uff0c\u4e3a\u8f93\u5165\u548c\u8f93\u51fa\u7684\u603b\u6570\n                #top_p=model_conf(const.OPEN_AI).get(\"top_p\", 0.7),,  #\u5019\u9009\u8bcd\u5217\u8868\u30020.7 \u610f\u5473\u7740\u53ea\u8003\u8651\u524d70%\u5019\u9009\u8bcd\u7684\u6807\u8bb0\uff0c\u5efa\u8bae\u548ctemperature\u53c2\u6570\u4e8c\u9009\u4e00\u4f7f\u7528\n                frequency_penalty=model_conf(const.OPEN_AI).get(\"frequency_penalty\", 0.0),  # [-2,2]\u4e4b\u95f4\uff0c\u8be5\u503c\u8d8a\u5927\u5219\u8d8a\u964d\u4f4e\u6a21\u578b\u4e00\u884c\u4e2d\u7684\u91cd\u590d\u7528\u8bcd\uff0c\u66f4\u503e\u5411\u4e8e\u4ea7\u751f\u4e0d\u540c\u7684\u5185\u5bb9\n                presence_penalty=model_conf(const.OPEN_AI).get(\"presence_penalty\", 1.0)  # [-2,2]\u4e4b\u95f4\uff0c\u8be5\u503c\u8d8a\u5927\u5219\u8d8a\u4e0d\u53d7\u8f93\u5165\u9650\u5236\uff0c\u5c06\u9f13\u52b1\u6a21\u578b\u751f\u6210\u8f93\u5165\u4e2d\u4e0d\u5b58\u5728\u7684\u65b0\u8bcd\uff0c\u66f4\u503e\u5411\u4e8e\u4ea7\u751f\u4e0d\u540c\u7684\u5185\u5bb9\n                )\n            reply_content = response.choices[0]['message']['content']\n            used_token = response['usage']['total_tokens']\n            log.debug(response)\n            log.info(\"[CHATGPT] reply={}\", reply_content)\n            if reply_content:\n                # save conversation\n                Session.save_session(query, reply_content, user_id, used_token)\n            return response.choices[0]['message']['content']\n        except openai.error.RateLimitError as e:\n            # rate limit exception\n            log.warn(e)\n            if retry_count < 1:\n                time.sleep(5)\n                log.warn(\"[CHATGPT] RateLimit exceed, \u7b2c{}\u6b21\u91cd\u8bd5\".format(retry_count+1))\n                return self.reply_text(query, user_id, retry_count+1)\n            else:\n                return \"\u63d0\u95ee\u592a\u5feb\u5566\uff0c\u8bf7\u4f11\u606f\u4e00\u4e0b\u518d\u95ee\u6211\u5427\"\n        except openai.error.APIConnectionError as e:\n            log.warn(e)\n            log.warn(\"[CHATGPT] APIConnection failed\")\n            return \"\u6211\u8fde\u63a5\u4e0d\u5230\u7f51\u7edc\uff0c\u8bf7\u7a0d\u540e\u91cd\u8bd5\"\n        except openai.error.Timeout as e:\n            log.warn(e)\n            log.warn(\"[CHATGPT] Timeout\")\n            return \"\u6211\u6ca1\u6709\u6536\u5230\u6d88\u606f\uff0c\u8bf7\u7a0d\u540e\u91cd\u8bd5\"\n        except Exception as e:\n            # unknown exception\n            log.exception(e)\n            Session.clear_session(user_id)\n            return \"\u8bf7\u518d\u95ee\u6211\u4e00\u6b21\u5427\"\n\n\n    async def reply_text_stream(self, query,  context, retry_count=0):\n        try:\n            user_id=context['from_user_id']\n            new_query = Session.build_session_query(query, user_id)\n            res = openai.ChatCompletion.create(\n                model= model_conf(const.OPEN_AI).get(\"model\") or \"gpt-3.5-turbo\",  # \u5bf9\u8bdd\u6a21\u578b\u7684\u540d\u79f0\n                messages=new_query,\n                temperature=model_conf(const.OPEN_AI).get(\"temperature\", 0.75),  # \u71b5\u503c\uff0c\u5728[0,1]\u4e4b\u95f4\uff0c\u8d8a\u5927\u8868\u793a\u9009\u53d6\u7684\u5019\u9009\u8bcd\u8d8a\u968f\u673a\uff0c\u56de\u590d\u8d8a\u5177\u6709\u4e0d\u786e\u5b9a\u6027\uff0c\u5efa\u8bae\u548ctop_p\u53c2\u6570\u4e8c\u9009\u4e00\u4f7f\u7528\uff0c\u521b\u610f\u6027\u4efb\u52a1\u8d8a\u5927\u8d8a\u597d\uff0c\u7cbe\u786e\u6027\u4efb\u52a1\u8d8a\u5c0f\u8d8a\u597d\n                #max_tokens=4096,  # \u56de\u590d\u6700\u5927\u7684\u5b57\u7b26\u6570\uff0c\u4e3a\u8f93\u5165\u548c\u8f93\u51fa\u7684\u603b\u6570\n                #top_p=model_conf(const.OPEN_AI).get(\"top_p\", 0.7),,  #\u5019\u9009\u8bcd\u5217\u8868\u30020.7 \u610f\u5473\u7740\u53ea\u8003\u8651\u524d70%\u5019\u9009\u8bcd\u7684\u6807\u8bb0\uff0c\u5efa\u8bae\u548ctemperature\u53c2\u6570\u4e8c\u9009\u4e00\u4f7f\u7528\n                frequency_penalty=model_conf(const.OPEN_AI).get(\"frequency_penalty\", 0.0),  # [-2,2]\u4e4b\u95f4\uff0c\u8be5\u503c\u8d8a\u5927\u5219\u8d8a\u964d\u4f4e\u6a21\u578b\u4e00\u884c\u4e2d\u7684\u91cd\u590d\u7528\u8bcd\uff0c\u66f4\u503e\u5411\u4e8e\u4ea7\u751f\u4e0d\u540c\u7684\u5185\u5bb9\n                presence_penalty=model_conf(const.OPEN_AI).get(\"presence_penalty\", 1.0),  # [-2,2]\u4e4b\u95f4\uff0c\u8be5\u503c\u8d8a\u5927\u5219\u8d8a\u4e0d\u53d7\u8f93\u5165\u9650\u5236\uff0c\u5c06\u9f13\u52b1\u6a21\u578b\u751f\u6210\u8f93\u5165\u4e2d\u4e0d\u5b58\u5728\u7684\u65b0\u8bcd\uff0c\u66f4\u503e\u5411\u4e8e\u4ea7\u751f\u4e0d\u540c\u7684\u5185\u5bb9\n                stream=True\n            )\n            full_response = \"\"\n            for chunk in res:\n                log.debug(chunk)\n                if (chunk[\"choices\"][0][\"finish_reason\"]==\"stop\"):\n                    break\n                chunk_message = chunk['choices'][0]['delta'].get(\"content\")\n                if(chunk_message):\n                    full_response+=chunk_message\n                yield False,full_response\n            Session.save_session(query, full_response, user_id)\n            log.info(\"[chatgpt]: reply={}\", full_response)\n            yield True,full_response\n\n        except openai.error.RateLimitError as e:\n            # rate limit exception\n            log.warn(e)\n            if retry_count < 1:\n                time.sleep(5)\n                log.warn(\"[CHATGPT] RateLimit exceed, \u7b2c{}\u6b21\u91cd\u8bd5\".format(retry_count+1))\n                yield True, self.reply_text_stream(query, user_id, retry_count+1)\n            else:\n                yield True, \"\u63d0\u95ee\u592a\u5feb\u5566\uff0c\u8bf7\u4f11\u606f\u4e00\u4e0b\u518d\u95ee\u6211\u5427\"\n        except openai.error.APIConnectionError as e:\n            log.warn(e)\n            log.warn(\"[CHATGPT] APIConnection failed\")\n            yield True, \"\u6211\u8fde\u63a5\u4e0d\u5230\u7f51\u7edc\uff0c\u8bf7\u7a0d\u540e\u91cd\u8bd5\"\n        except openai.error.Timeout as e:\n            log.warn(e)\n            log.warn(\"[CHATGPT] Timeout\")\n            yield True, \"\u6211\u6ca1\u6709\u6536\u5230\u6d88\u606f\uff0c\u8bf7\u7a0d\u540e\u91cd\u8bd5\"\n        except Exception as e:\n            # unknown exception\n            log.exception(e)\n            Session.clear_session(user_id)\n            yield True, \"\u8bf7\u518d\u95ee\u6211\u4e00\u6b21\u5427\"\n\n    def create_img(self, query, retry_count=0):\n        try:\n            log.info(\"[OPEN_AI] image_query={}\".format(query))\n            response = openai.Image.create(\n                prompt=query,    #\u56fe\u7247\u63cf\u8ff0\n                n=1,             #\u6bcf\u6b21\u751f\u6210\u56fe\u7247\u7684\u6570\u91cf\n                size=\"256x256\"   #\u56fe\u7247\u5927\u5c0f,\u53ef\u9009\u6709 256x256, 512x512, 1024x1024\n            )\n            image_url = response['data'][0]['url']\n            log.info(\"[OPEN_AI] image_url={}\".format(image_url))\n            return [image_url]\n        except openai.error.RateLimitError as e:\n            log.warn(e)\n            if retry_count < 1:\n                time.sleep(5)\n                log.warn(\"[OPEN_AI] ImgCreate RateLimit exceed, \u7b2c{}\u6b21\u91cd\u8bd5\".format(retry_count+1))\n                return self.reply_text(query, retry_count+1)\n            else:\n                return \"\u63d0\u95ee\u592a\u5feb\u5566\uff0c\u8bf7\u4f11\u606f\u4e00\u4e0b\u518d\u95ee\u6211\u5427\"\n        except Exception as e:\n            log.exception(e)\n            return None", "\n\nclass Session(object):\n    @staticmethod\n    def build_session_query(query, user_id):\n        '''\n        build query with conversation history\n        e.g.  [\n            {\"role\": \"system\", \"content\": \"You are a helpful assistant.\"},\n            {\"role\": \"user\", \"content\": \"Who won the world series in 2020?\"},\n            {\"role\": \"assistant\", \"content\": \"The Los Angeles Dodgers won the World Series in 2020.\"},\n            {\"role\": \"user\", \"content\": \"Where was it played?\"}\n        ]\n        :param query: query content\n        :param user_id: from user id\n        :return: query content with conversaction\n        '''\n        session = user_session.get(user_id, [])\n        if len(session) == 0:\n            system_prompt = model_conf(const.OPEN_AI).get(\"character_desc\", \"\")\n            system_item = {'role': 'system', 'content': system_prompt}\n            session.append(system_item)\n            user_session[user_id] = session\n        user_item = {'role': 'user', 'content': query}\n        session.append(user_item)\n        return session\n\n    @staticmethod\n    def save_session(query, answer, user_id, used_tokens=0):\n        max_tokens = model_conf(const.OPEN_AI).get('conversation_max_tokens')\n        max_history_num = model_conf(const.OPEN_AI).get('max_history_num', None)\n        if not max_tokens or max_tokens > 4000:\n            # default value\n            max_tokens = 1000\n        session = user_session.get(user_id)\n        if session:\n            # append conversation\n            gpt_item = {'role': 'assistant', 'content': answer}\n            session.append(gpt_item)\n\n        if used_tokens > max_tokens and len(session) >= 3:\n            # pop first conversation (TODO: more accurate calculation)\n            session.pop(1)\n            session.pop(1)\n\n        if max_history_num is not None:\n            while len(session) > max_history_num * 2 + 1:\n                session.pop(1)\n                session.pop(1)\n\n    @staticmethod\n    def clear_session(user_id):\n        user_session[user_id] = []", "\n"]}
{"filename": "model/openai/open_ai_model.py", "chunked_list": ["# encoding:utf-8\n\nfrom model.model import Model\nfrom config import model_conf, common_conf_val\nfrom common import const\nfrom common import log\nimport openai\nimport time\n\nuser_session = dict()", "\nuser_session = dict()\n\n# OpenAI\u5bf9\u8bdd\u6a21\u578bAPI (\u53ef\u7528)\nclass OpenAIModel(Model):\n    def __init__(self):\n        openai.api_key = model_conf(const.OPEN_AI).get('api_key')\n        api_base = model_conf(const.OPEN_AI).get('api_base')\n        if api_base:\n            openai.api_base = api_base\n        log.info(\"[OPEN_AI] api_base={}\".format(openai.api_base))\n        self.model = model_conf(const.OPEN_AI).get('model', 'text-davinci-003')\n        proxy = model_conf(const.OPEN_AI).get('proxy')\n        if proxy:\n            openai.proxy = proxy\n\n    def reply(self, query, context=None):\n        # acquire reply content\n        if not context or not context.get('type') or context.get('type') == 'TEXT':\n            log.info(\"[OPEN_AI] query={}\".format(query))\n            from_user_id = context['from_user_id']\n            clear_memory_commands = common_conf_val('clear_memory_commands', ['#\u6e05\u9664\u8bb0\u5fc6'])\n            if query in clear_memory_commands:\n                Session.clear_session(from_user_id)\n                return '\u8bb0\u5fc6\u5df2\u6e05\u9664'\n\n            new_query = Session.build_session_query(query, from_user_id)\n            log.debug(\"[OPEN_AI] session query={}\".format(new_query))\n\n            if context.get('stream'):\n                # reply in stream\n                return self.reply_text_stream(query, new_query, from_user_id)\n\n            reply_content = self.reply_text(new_query, from_user_id, 0)\n            log.debug(\"[OPEN_AI] new_query={}, user={}, reply_cont={}\".format(new_query, from_user_id, reply_content))\n            if reply_content and query:\n                Session.save_session(query, reply_content, from_user_id)\n            return reply_content\n\n        elif context.get('type', None) == 'IMAGE_CREATE':\n            return self.create_img(query, 0)\n\n    def reply_text(self, query, user_id, retry_count=0):\n        try:\n            response = openai.Completion.create(\n                model=self.model,  # \u5bf9\u8bdd\u6a21\u578b\u7684\u540d\u79f0\n                prompt=query,\n                temperature=model_conf(const.OPEN_AI).get(\"temperature\", 0.75),  # \u71b5\u503c\uff0c\u5728[0,1]\u4e4b\u95f4\uff0c\u8d8a\u5927\u8868\u793a\u9009\u53d6\u7684\u5019\u9009\u8bcd\u8d8a\u968f\u673a\uff0c\u56de\u590d\u8d8a\u5177\u6709\u4e0d\u786e\u5b9a\u6027\uff0c\u5efa\u8bae\u548ctop_p\u53c2\u6570\u4e8c\u9009\u4e00\u4f7f\u7528\uff0c\u521b\u610f\u6027\u4efb\u52a1\u8d8a\u5927\u8d8a\u597d\uff0c\u7cbe\u786e\u6027\u4efb\u52a1\u8d8a\u5c0f\u8d8a\u597d\n                #max_tokens=4096,  # \u56de\u590d\u6700\u5927\u7684\u5b57\u7b26\u6570\uff0c\u4e3a\u8f93\u5165\u548c\u8f93\u51fa\u7684\u603b\u6570\n                #top_p=model_conf(const.OPEN_AI).get(\"top_p\", 0.7),,  #\u5019\u9009\u8bcd\u5217\u8868\u30020.7 \u610f\u5473\u7740\u53ea\u8003\u8651\u524d70%\u5019\u9009\u8bcd\u7684\u6807\u8bb0\uff0c\u5efa\u8bae\u548ctemperature\u53c2\u6570\u4e8c\u9009\u4e00\u4f7f\u7528\n                frequency_penalty=model_conf(const.OPEN_AI).get(\"frequency_penalty\", 0.0),  # [-2,2]\u4e4b\u95f4\uff0c\u8be5\u503c\u8d8a\u5927\u5219\u8d8a\u964d\u4f4e\u6a21\u578b\u4e00\u884c\u4e2d\u7684\u91cd\u590d\u7528\u8bcd\uff0c\u66f4\u503e\u5411\u4e8e\u4ea7\u751f\u4e0d\u540c\u7684\u5185\u5bb9\n                presence_penalty=model_conf(const.OPEN_AI).get(\"presence_penalty\", 1.0),  # [-2,2]\u4e4b\u95f4\uff0c\u8be5\u503c\u8d8a\u5927\u5219\u8d8a\u4e0d\u53d7\u8f93\u5165\u9650\u5236\uff0c\u5c06\u9f13\u52b1\u6a21\u578b\u751f\u6210\u8f93\u5165\u4e2d\u4e0d\u5b58\u5728\u7684\u65b0\u8bcd\uff0c\u66f4\u503e\u5411\u4e8e\u4ea7\u751f\u4e0d\u540c\u7684\u5185\u5bb9\n                stop=[\"\\n\\n\\n\"]\n            )\n            res_content = response.choices[0]['text'].strip().replace('<|endoftext|>', '')\n            log.info(\"[OPEN_AI] reply={}\".format(res_content))\n            return res_content\n        except openai.error.RateLimitError as e:\n            # rate limit exception\n            log.warn(e)\n            if retry_count < 1:\n                time.sleep(5)\n                log.warn(\"[OPEN_AI] RateLimit exceed, \u7b2c{}\u6b21\u91cd\u8bd5\".format(retry_count+1))\n                return self.reply_text(query, user_id, retry_count+1)\n            else:\n                return \"\u63d0\u95ee\u592a\u5feb\u5566\uff0c\u8bf7\u4f11\u606f\u4e00\u4e0b\u518d\u95ee\u6211\u5427\"\n        except Exception as e:\n            # unknown exception\n            log.exception(e)\n            Session.clear_session(user_id)\n            return \"\u8bf7\u518d\u95ee\u6211\u4e00\u6b21\u5427\"\n\n\n    async def reply_text_stream(self, query,  context, retry_count=0):\n        try:\n            user_id=context['from_user_id']\n            new_query = Session.build_session_query(query, user_id)\n            res = openai.Completion.create(\n                model= \"text-davinci-003\",  # \u5bf9\u8bdd\u6a21\u578b\u7684\u540d\u79f0\n                prompt=new_query,\n                temperature=model_conf(const.OPEN_AI).get(\"temperature\", 0.75),  # \u71b5\u503c\uff0c\u5728[0,1]\u4e4b\u95f4\uff0c\u8d8a\u5927\u8868\u793a\u9009\u53d6\u7684\u5019\u9009\u8bcd\u8d8a\u968f\u673a\uff0c\u56de\u590d\u8d8a\u5177\u6709\u4e0d\u786e\u5b9a\u6027\uff0c\u5efa\u8bae\u548ctop_p\u53c2\u6570\u4e8c\u9009\u4e00\u4f7f\u7528\uff0c\u521b\u610f\u6027\u4efb\u52a1\u8d8a\u5927\u8d8a\u597d\uff0c\u7cbe\u786e\u6027\u4efb\u52a1\u8d8a\u5c0f\u8d8a\u597d\n                max_tokens=model_conf(const.OPEN_AI).get(\"conversation_max_tokens\", 3000),  # \u56de\u590d\u6700\u5927\u7684\u5b57\u7b26\u6570\uff0c\u4e3a\u8f93\u5165\u548c\u8f93\u51fa\u7684\u603b\u6570,davinci\u7684\u6d41\u5f0f\u5bf9\u8bdd\u9700\u8981\u542f\u7528\u8fd9\u5c5e\u6027\uff0c\u4e0d\u7136\u5bf9\u8bdd\u4f1a\u65ad\u6d41\n                #top_p=model_conf(const.OPEN_AI).get(\"top_p\", 0.7),,  #\u5019\u9009\u8bcd\u5217\u8868\u30020.7 \u610f\u5473\u7740\u53ea\u8003\u8651\u524d70%\u5019\u9009\u8bcd\u7684\u6807\u8bb0\uff0c\u5efa\u8bae\u548ctemperature\u53c2\u6570\u4e8c\u9009\u4e00\u4f7f\u7528\n                frequency_penalty=model_conf(const.OPEN_AI).get(\"frequency_penalty\", 0.0),  # [-2,2]\u4e4b\u95f4\uff0c\u8be5\u503c\u8d8a\u5927\u5219\u8d8a\u964d\u4f4e\u6a21\u578b\u4e00\u884c\u4e2d\u7684\u91cd\u590d\u7528\u8bcd\uff0c\u66f4\u503e\u5411\u4e8e\u4ea7\u751f\u4e0d\u540c\u7684\u5185\u5bb9\n                presence_penalty=model_conf(const.OPEN_AI).get(\"presence_penalty\", 1.0),  # [-2,2]\u4e4b\u95f4\uff0c\u8be5\u503c\u8d8a\u5927\u5219\u8d8a\u4e0d\u53d7\u8f93\u5165\u9650\u5236\uff0c\u5c06\u9f13\u52b1\u6a21\u578b\u751f\u6210\u8f93\u5165\u4e2d\u4e0d\u5b58\u5728\u7684\u65b0\u8bcd\uff0c\u66f4\u503e\u5411\u4e8e\u4ea7\u751f\u4e0d\u540c\u7684\u5185\u5bb9\n                stream=True\n            )\n            full_response = \"\"\n            for chunk in res:\n                log.debug(chunk)\n                if (chunk[\"choices\"][0][\"finish_reason\"]==\"stop\"):\n                    break\n                chunk_message = chunk['choices'][0].get(\"text\")\n                if(chunk_message):\n                    full_response+=chunk_message\n                yield False,full_response\n            Session.save_session(query, full_response, user_id)\n            log.info(\"[chatgpt]: reply={}\", full_response)\n            yield True,full_response\n\n        except openai.error.RateLimitError as e:\n            # rate limit exception\n            log.warn(e)\n            if retry_count < 1:\n                time.sleep(5)\n                log.warn(\"[CHATGPT] RateLimit exceed, \u7b2c{}\u6b21\u91cd\u8bd5\".format(retry_count+1))\n                yield True, self.reply_text_stream(query, user_id, retry_count+1)\n            else:\n                yield True, \"\u63d0\u95ee\u592a\u5feb\u5566\uff0c\u8bf7\u4f11\u606f\u4e00\u4e0b\u518d\u95ee\u6211\u5427\"\n        except openai.error.APIConnectionError as e:\n            log.warn(e)\n            log.warn(\"[CHATGPT] APIConnection failed\")\n            yield True, \"\u6211\u8fde\u63a5\u4e0d\u5230\u7f51\u7edc\uff0c\u8bf7\u7a0d\u540e\u91cd\u8bd5\"\n        except openai.error.Timeout as e:\n            log.warn(e)\n            log.warn(\"[CHATGPT] Timeout\")\n            yield True, \"\u6211\u6ca1\u6709\u6536\u5230\u6d88\u606f\uff0c\u8bf7\u7a0d\u540e\u91cd\u8bd5\"\n        except Exception as e:\n            # unknown exception\n            log.exception(e)\n            Session.clear_session(user_id)\n            yield True, \"\u8bf7\u518d\u95ee\u6211\u4e00\u6b21\u5427\"\n\n    def _process_reply_stream(\n            self,\n            query: str,\n            reply: dict,\n            user_id: str\n    ) -> str:\n        full_response = \"\"\n        for response in reply:\n            if response.get(\"choices\") is None or len(response[\"choices\"]) == 0:\n                raise Exception(\"OpenAI API returned no choices\")\n            if response[\"choices\"][0].get(\"finish_details\") is not None:\n                break\n            if response[\"choices\"][0].get(\"text\") is None:\n                raise Exception(\"OpenAI API returned no text\")\n            if response[\"choices\"][0][\"text\"] == \"<|endoftext|>\":\n                break\n            yield response[\"choices\"][0][\"text\"]\n            full_response += response[\"choices\"][0][\"text\"]\n        if query and full_response:\n            Session.save_session(query, full_response, user_id)\n\n\n    def create_img(self, query, retry_count=0):\n        try:\n            log.info(\"[OPEN_AI] image_query={}\".format(query))\n            response = openai.Image.create(\n                prompt=query,    #\u56fe\u7247\u63cf\u8ff0\n                n=1,             #\u6bcf\u6b21\u751f\u6210\u56fe\u7247\u7684\u6570\u91cf\n                size=\"256x256\"   #\u56fe\u7247\u5927\u5c0f,\u53ef\u9009\u6709 256x256, 512x512, 1024x1024\n            )\n            image_url = response['data'][0]['url']\n            log.info(\"[OPEN_AI] image_url={}\".format(image_url))\n            return [image_url]\n        except openai.error.RateLimitError as e:\n            log.warn(e)\n            if retry_count < 1:\n                time.sleep(5)\n                log.warn(\"[OPEN_AI] ImgCreate RateLimit exceed, \u7b2c{}\u6b21\u91cd\u8bd5\".format(retry_count+1))\n                return self.reply_text(query, retry_count+1)\n            else:\n                return \"\u63d0\u95ee\u592a\u5feb\u5566\uff0c\u8bf7\u4f11\u606f\u4e00\u4e0b\u518d\u95ee\u6211\u5427\"\n        except Exception as e:\n            log.exception(e)\n            return None", "\n\nclass Session(object):\n    @staticmethod\n    def build_session_query(query, user_id):\n        '''\n        build query with conversation history\n        e.g.  Q: xxx\n              A: xxx\n              Q: xxx\n        :param query: query content\n        :param user_id: from user id\n        :return: query content with conversaction\n        '''\n        prompt = model_conf(const.OPEN_AI).get(\"character_desc\", \"\")\n        if prompt:\n            prompt += \"<|endoftext|>\\n\\n\\n\"\n        session = user_session.get(user_id, None)\n        if session:\n            for conversation in session:\n                prompt += \"Q: \" + conversation[\"question\"] + \"\\n\\n\\nA: \" + conversation[\"answer\"] + \"<|endoftext|>\\n\"\n            prompt += \"Q: \" + query + \"\\nA: \"\n            return prompt\n        else:\n            return prompt + \"Q: \" + query + \"\\nA: \"\n\n    @staticmethod\n    def save_session(query, answer, user_id):\n        max_tokens = model_conf(const.OPEN_AI).get(\"conversation_max_tokens\")\n        if not max_tokens:\n            # default 3000\n            max_tokens = 1000\n        conversation = dict()\n        conversation[\"question\"] = query\n        conversation[\"answer\"] = answer\n        session = user_session.get(user_id)\n        log.debug(conversation)\n        log.debug(session)\n        if session:\n            # append conversation\n            session.append(conversation)\n        else:\n            # create session\n            queue = list()\n            queue.append(conversation)\n            user_session[user_id] = queue\n\n        # discard exceed limit conversation\n        Session.discard_exceed_conversation(user_session[user_id], max_tokens)\n\n\n    @staticmethod\n    def discard_exceed_conversation(session, max_tokens):\n        count = 0\n        count_list = list()\n        for i in range(len(session)-1, -1, -1):\n            # count tokens of conversation list\n            history_conv = session[i]\n            count += len(history_conv[\"question\"]) + len(history_conv[\"answer\"])\n            count_list.append(count)\n\n        for c in count_list:\n            if c > max_tokens:\n                # pop first conversation\n                session.pop(0)\n\n    @staticmethod\n    def clear_session(user_id):\n        user_session[user_id] = []", ""]}
{"filename": "model/google/bard_bot.py", "chunked_list": ["\nimport json\nimport random\nimport requests\nimport re\nclass BardBot:\n    BARD_URL = \"https://bard.google.com/\"\n    BARD_CHAT_URL = (\n        \"https://bard.google.com/_/BardChatUi/data/assistant.lamda.BardFrontendService/StreamGenerate\"\n    )\n    HEADERS = {\n        \"Host\": \"bard.google.com\",\n        \"X-Same-Domain\": \"1\",\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36\",\n        \"Content-Type\": \"application/x-www-form-urlencoded;charset=UTF-8\",\n        \"Origin\": \"https://bard.google.com\",\n        \"Referer\": \"https://bard.google.com/\",\n    }\n\n    def __init__(self, session_id: str):\n        self._reqid = random.randrange(10000,99999)\n        self.conversation_id = \"\"\n        self.response_id = \"\"\n        self.choice_id = \"\"\n        self.session = requests.Session()\n        self.session.headers = self.HEADERS\n        self.session.cookies.set(\"__Secure-1PSID\", session_id)\n        self.SNlM0e = self.__get_snlm0e()\n\n    def __get_snlm0e(self) -> str:\n        resp = self.session.get(url=self.BARD_URL, timeout=10)\n        if resp.status_code != 200:\n            raise Exception(\"Failed to connect Google Bard\")\n        try:\n            SNlM0e = re.search(r\"SNlM0e\\\":\\\"(.*?)\\\"\", resp.text).group(1)\n            return SNlM0e\n        except Exception as e:\n            raise Exception(f\"Cookies may be wrong:{e}\")\n\n    def ask(self, message: str) -> dict[str, str]:\n        params = {\n            \"bl\": \"boq_assistant-bard-web-server_20230326.21_p0\",\n            \"_reqid\": str(self._reqid),\n            \"rt\": \"c\",\n        }\n        message_struct = [[message], None, [self.conversation_id, self.response_id, self.choice_id]]\n        data = {\"f.req\": json.dumps([None, json.dumps(message_struct)]), \"at\": self.SNlM0e}\n        try:\n            resp = self.session.post(self.BARD_CHAT_URL, params=params, data=data)\n            content = json.loads(resp.content.splitlines()[3])[0][2]\n            if not (content := json.loads(resp.content.splitlines()[3])[0][2]):\n                return {\"content\": f\"Bard encountered an error: {resp.content}.\"} \n            json_data = json.loads(content)\n            results = {\n                \"content\": json_data[0][0],\n                \"conversation_id\": json_data[1][0],\n                \"response_id\": json_data[1][1],\n                \"reference\": json_data[3],\n                \"choices\": [{\"id\": i[0], \"content\": i[1]} for i in json_data[4]],\n            }\n            self.conversation_id = results['conversation_id']\n            self.response_id = results['response_id']\n            self.choice_id = results[\"choices\"][0][\"id\"]\n            self._reqid += 100000\n            return results\n        except Exception as e:\n            raise Exception(f\"Failed to ask Google Bard:{e}\")"]}
{"filename": "model/google/bard_model.py", "chunked_list": ["# encoding:utf-8\nfrom .bard_bot import BardBot\nfrom config import model_conf_val\nfrom model.model import Model\nfrom common import log\n\nuser_session = dict()\n\n\nclass BardModel(Model):\n    bot: BardBot = None\n\n    def __init__(self):\n        try:\n            self.cookies = model_conf_val(\"bard\", \"cookie\")\n            self.bot = BardBot(self.cookies)\n        except Exception as e:\n            log.warn(e)\n\n    def reply(self, query: str, context=None) -> dict[str, str]:\n        if not context or not context.get('type') or context.get('type') == 'TEXT':\n            bot = user_session.get(context['from_user_id'], None)\n            if bot is None:\n                bot = self.bot\n\n            user_session[context['from_user_id']] = bot\n            log.info(f\"[Bard] query={query}\")\n            answer = bot.ask(query)\n            # Bard\u6700\u591a\u8fd4\u56de3\u4e2a\u751f\u6210\u7ed3\u679c,\u76ee\u524d\u6682\u65f6\u9009\u7b2c\u4e00\u4e2a\u8fd4\u56de\n            reply = answer['content']\n            if answer['reference']:\n                reference = [({'index': item[0], 'reference':item[2][0] if item[2][0] else item[2][1]}) for item in answer['reference'][0]]\n                reference.sort(key=lambda x: x['index'], reverse=True)\n                reply = self.insert_reference(reply, reference)\n            log.warn(f\"[Bard] answer={reply}\")\n            return reply\n\n    async def reply_text_stream(self, query: str, context=None) -> dict:\n        reply = self.reply(query, context)\n        yield True, reply\n\n    def insert_reference(self, reply: str, reference: list) -> str:\n        refer = '\\n***\\n\\n'\n        length = len(reference)\n        for i, item in enumerate(reference):\n            index = item[\"index\"] - 1\n            reply = reply[:index] + f'[^{length-i}]' + reply[index:]\n            refer += f'- ^{i+1}\uff1a{item[\"reference\"]}\\n\\n'\n        refer += '***'\n        return reply + refer", "\nclass BardModel(Model):\n    bot: BardBot = None\n\n    def __init__(self):\n        try:\n            self.cookies = model_conf_val(\"bard\", \"cookie\")\n            self.bot = BardBot(self.cookies)\n        except Exception as e:\n            log.warn(e)\n\n    def reply(self, query: str, context=None) -> dict[str, str]:\n        if not context or not context.get('type') or context.get('type') == 'TEXT':\n            bot = user_session.get(context['from_user_id'], None)\n            if bot is None:\n                bot = self.bot\n\n            user_session[context['from_user_id']] = bot\n            log.info(f\"[Bard] query={query}\")\n            answer = bot.ask(query)\n            # Bard\u6700\u591a\u8fd4\u56de3\u4e2a\u751f\u6210\u7ed3\u679c,\u76ee\u524d\u6682\u65f6\u9009\u7b2c\u4e00\u4e2a\u8fd4\u56de\n            reply = answer['content']\n            if answer['reference']:\n                reference = [({'index': item[0], 'reference':item[2][0] if item[2][0] else item[2][1]}) for item in answer['reference'][0]]\n                reference.sort(key=lambda x: x['index'], reverse=True)\n                reply = self.insert_reference(reply, reference)\n            log.warn(f\"[Bard] answer={reply}\")\n            return reply\n\n    async def reply_text_stream(self, query: str, context=None) -> dict:\n        reply = self.reply(query, context)\n        yield True, reply\n\n    def insert_reference(self, reply: str, reference: list) -> str:\n        refer = '\\n***\\n\\n'\n        length = len(reference)\n        for i, item in enumerate(reference):\n            index = item[\"index\"] - 1\n            reply = reply[:index] + f'[^{length-i}]' + reply[index:]\n            refer += f'- ^{i+1}\uff1a{item[\"reference\"]}\\n\\n'\n        refer += '***'\n        return reply + refer", ""]}
{"filename": "bridge/bridge.py", "chunked_list": ["from model import model_factory\nimport config\nfrom plugins.event import Event, EventContext\nfrom plugins.plugin_manager import PluginManager\n\n\nclass Bridge(object):\n    def __init__(self):\n        pass\n\n    def fetch_reply_content(self, query, context):\n        econtext = PluginManager().emit_event(EventContext(\n            Event.ON_BRIDGE_HANDLE_CONTEXT, {'context': query, 'args': context}))\n        type = econtext['args'].get('model') or config.conf().get(\"model\").get(\"type\")\n        query = econtext.econtext.get(\"context\", None)\n        reply = econtext.econtext.get(\"reply\", \"\u65e0\u56de\u590d\")\n        if not econtext.is_pass() and query:\n            return model_factory.create_bot(type).reply(query, context)\n        else:\n            return reply\n\n    async def fetch_reply_stream(self, query, context):\n        econtext = PluginManager().emit_event(EventContext(\n            Event.ON_BRIDGE_HANDLE_CONTEXT, {'context': query, 'args': context}))\n        type = econtext['args'].get('model') or config.conf().get(\"model\").get(\"type\")\n        query = econtext.econtext.get(\"context\", None)\n        reply = econtext.econtext.get(\"reply\", \"\u65e0\u56de\u590d\")\n        bot = model_factory.create_bot(type)\n        if not econtext.is_pass() and query:\n            async for final, response in bot.reply_text_stream(query, context):\n                yield final, response\n        else:\n            yield True, reply", ""]}
{"filename": "channel/channel.py", "chunked_list": ["\"\"\"\nMessage sending channel abstract class\n\"\"\"\n\nfrom bridge.bridge import Bridge\n\nclass Channel(object):\n    def startup(self):\n        \"\"\"\n        init channel\n        \"\"\"\n        raise NotImplementedError\n\n    def handle(self, msg):\n        \"\"\"\n        process received msg\n        :param msg: message object\n        \"\"\"\n        raise NotImplementedError\n\n    def send(self, msg, receiver):\n        \"\"\"\n        send message to user\n        :param msg: message content\n        :param receiver: receiver channel account\n        :return: \n        \"\"\"\n        raise NotImplementedError\n\n    def build_reply_content(self, query, context=None):\n        return Bridge().fetch_reply_content(query, context)\n\n    async def build_reply_stream(self, query, context=None):\n        async for final,response in Bridge().fetch_reply_stream(query, context):\n            yield final,response", ""]}
{"filename": "channel/channel_factory.py", "chunked_list": ["\"\"\"\nchannel factory\n\"\"\"\nfrom common import const\n\ndef create_channel(channel_type):\n    \"\"\"\n    create a channel instance\n    :param channel_type: channel type code\n    :return: channel instance\n    \"\"\"\n    if channel_type== const.TERMINAL:\n        from channel.terminal.terminal_channel import TerminalChannel\n        return TerminalChannel()\n\n    if channel_type == const.WECHAT:\n        from channel.wechat.wechat_channel import WechatChannel\n        return WechatChannel()\n\n    elif channel_type == const.WECHAT_MP:\n        from channel.wechat.wechat_mp_channel import WechatSubsribeAccount\n        return WechatSubsribeAccount()\n\n    elif channel_type == const.WECHAT_MP_SERVICE:\n        from channel.wechat.wechat_mp_service_channel import WechatServiceAccount\n        return WechatServiceAccount()\n\n    elif channel_type == const.WECHAT_COM:\n        from channel.wechat.wechat_com_channel import WechatEnterpriseChannel\n        return WechatEnterpriseChannel()\n\n    elif channel_type == const.QQ:\n        from channel.qq.qq_channel import QQChannel\n        return QQChannel()\n\n    elif channel_type == const.GMAIL:\n        from channel.gmail.gmail_channel import GmailChannel\n        return GmailChannel()\n\n    elif channel_type == const.TELEGRAM:\n        from channel.telegram.telegram_channel import TelegramChannel\n        return TelegramChannel()\n    \n    elif channel_type == const.SLACK:\n        from channel.slack.slack_channel import SlackChannel\n        return SlackChannel()\n\n    elif channel_type == const.HTTP:\n        from channel.http.http_channel import HttpChannel\n        return HttpChannel()\n\n    elif channel_type == const.DINGTALK:\n        from channel.dingtalk.dingtalk_channel import DingTalkChannel\n        return DingTalkChannel()\n\n    elif channel_type == const.FEISHU:\n        from channel.feishu.feishu_channel import FeiShuChannel\n        return FeiShuChannel()\n\n    elif channel_type == const.DISCORD:\n        from channel.discord.discord_channel import DiscordChannel\n        return DiscordChannel()\n\n    else:\n        raise RuntimeError(\"unknown channel_type in config.json: \" + channel_type)", ""]}
{"filename": "channel/dingtalk/dingtalk_channel.py", "chunked_list": ["# encoding:utf-8\nimport json\nimport hmac\nimport hashlib\nimport base64\nimport time\nimport requests\nfrom urllib.parse import quote_plus\nfrom common import log\nfrom flask import Flask, request, render_template, make_response", "from common import log\nfrom flask import Flask, request, render_template, make_response\nfrom common import const\nfrom common import functions\nfrom config import channel_conf\nfrom config import channel_conf_val\nfrom channel.channel import Channel\n\n\nclass DingTalkHandler():\n    def __init__(self, config):\n        self.dingtalk_key = config.get('dingtalk_key')\n        self.dingtalk_secret = config.get('dingtalk_secret')\n        self.dingtalk_token = config.get('dingtalk_token')\n        self.dingtalk_post_token = config.get('dingtalk_post_token')\n        self.access_token = None\n        log.info(\"[DingTalk] AppKey={}, AppSecret={} Token={} post Token={}\".format(self.dingtalk_key, self.dingtalk_secret, self.dingtalk_token, self.dingtalk_post_token))\n\n    def notify_dingtalk_webhook(self, data):\n        timestamp = round(time.time() * 1000)\n        secret_enc = bytes(self.dingtalk_secret, encoding='utf-8')\n        string_to_sign = '{}\\n{}'.format(timestamp, self.dingtalk_secret)\n        string_to_sign_enc = bytes(string_to_sign, encoding='utf-8')\n        hmac_code = hmac.new(secret_enc, string_to_sign_enc,\n                             digestmod=hashlib.sha256).digest()\n        sign = quote_plus(base64.b64encode(hmac_code))\n\n        notify_url = f\"https://oapi.dingtalk.com/robot/send?access_token={self.dingtalk_token}&timestamp={timestamp}&sign={sign}\"\n        try:\n            log.info(\"[DingTalk] url={}\".format(str(notify_url)))\n            r = requests.post(notify_url, json=data)\n            reply = r.json()\n            log.info(\"[DingTalk] reply={}\".format(str(reply)))\n        except Exception as e:\n            log.error(e)\n\n    def get_token_internal(self):\n        access_token_url = 'https://api.dingtalk.com/v1.0/oauth2/accessToken'\n        try:\n            r = requests.post(access_token_url, json={\"appKey\": self.dingtalk_key, \"appSecret\": self.dingtalk_secret})\n        except:\n            raise Exception(\"DingTalk token\u83b7\u53d6\u5931\u8d25!!!\")\n\n        data = json.loads(r.content)\n        access_token = data['accessToken']\n        expire_in = data['expireIn']\n        \n        self.access_token = access_token\n        self.expire_at = int(expire_in) + time.time()\n\n        return self.access_token\n    \n    def get_token(self):\n        if self.access_token is None or self.expire_at <= time.time():\n            self.get_token_internal()\n        \n        return self.access_token\n    \n    def get_post_url(self, data):\n        type = data['conversationType']\n        if type == \"1\":\n            return f\"https://api.dingtalk.com/v1.0/robot/oToMessages/batchSend\"\n        else:\n            return f\"https://api.dingtalk.com/v1.0/robot/groupMessages/send\"\n    \n    def build_response(self, reply, data):\n        type = data['conversationType']\n        if type == \"1\":\n            return self.build_oto_response(reply, data)\n        else:\n            return self.build_group_response(reply, data)\n\n    def build_oto_response(self, reply, data):\n        conversation_id = data['conversationId']\n        prompt = data['text']['content']\n        prompt = prompt.strip()\n        img_match_prefix = functions.check_prefix(\n            prompt, channel_conf_val(const.DINGTALK, 'image_create_prefix'))\n        nick = data['senderNick']\n        staffid = data['senderStaffId']\n        robotCode = data['robotCode']\n        if img_match_prefix and isinstance(reply, list):\n            images = \"\"\n            for url in reply:\n                images += f\"!['IMAGE_CREATE']({url})\\n\"\n            reply = images\n            resp = {\n                \"msgKey\": \"sampleMarkdown\",\n                \"msgParam\": json.dumps({\n                    \"title\": \"IMAGE @\" + nick + \" \", \n                    \"text\": images + \" \\n \" + \"@\" + nick\n                }),\n                \"robotCode\": robotCode,\n                \"userIds\": [staffid]\n            }\n        else:\n            resp = {\n                \"msgKey\": \"sampleText\",\n                \"msgParam\": json.dumps({\n                    \"content\": reply\n                }),\n                \"robotCode\": robotCode,\n                \"userIds\": [staffid]\n            }\n        return resp\n    \n    def build_group_response(self, reply, data):\n        conversation_id = data['conversationId']\n        prompt = data['text']['content']\n        prompt = prompt.strip()\n        img_match_prefix = functions.check_prefix(\n            prompt, channel_conf_val(const.DINGTALK, 'image_create_prefix'))\n        nick = data['senderNick']\n        staffid = data['senderStaffId']\n        robot_code = data['robotCode']\n        if img_match_prefix and isinstance(reply, list):\n            images = \"\"\n            for url in reply:\n                images += f\"!['IMAGE_CREATE']({url})\\n\"\n            reply = images\n            resp = {\n                \"msgKey\": \"sampleMarkdown\",\n                \"msgParam\": json.dumps({\n                    \"title\": \"IMAGE @\" + nick + \" \", \n                    \"text\": images + \" \\n \" + \"@\" + nick\n                }),\n                \"robotCode\": robot_code,\n                \"openConversationId\": conversation_id,\n                \"at\": {\n                    \"atUserIds\": [\n                        staffid\n                    ],\n                    \"isAtAll\": False\n                }\n            }\n        else:\n            resp = {\n                \"msgKey\": \"sampleText\",\n                \"msgParam\": json.dumps({\n                    \"content\": reply + \" \\n \" + \"@\" + nick\n                }),\n                \"robotCode\": robot_code,\n                \"openConversationId\": conversation_id,\n                \"at\": {\n                    \"atUserIds\": [\n                       staffid \n                    ],\n                    \"isAtAll\": False\n                }\n            }\n        return resp\n    \n    \n    def build_webhook_response(self, reply, data):\n        conversation_id = data['conversationId']\n        prompt = data['text']['content']\n        prompt = prompt.strip()\n        img_match_prefix = functions.check_prefix(\n            prompt, channel_conf_val(const.DINGTALK, 'image_create_prefix'))\n        nick = data['senderNick']\n        staffid = data['senderStaffId']\n        robotCode = data['robotCode']\n        if img_match_prefix and isinstance(reply, list):\n            images = \"\"\n            for url in reply:\n                images += f\"!['IMAGE_CREATE']({url})\\n\"\n            reply = images\n            resp = {\n                \"msgtype\": \"markdown\",\n                \"markdown\": {\n                    \"title\": \"IMAGE @\" + nick + \" \", \n                    \"text\": images + \" \\n \" + \"@\" + nick\n                },\n                \"at\": {\n                    \"atUserIds\": [\n                        staffid\n                    ],\n                    \"isAtAll\": False\n                }\n            }\n        else:\n            resp = {\n                \"msgtype\": \"text\",\n                \"text\": {\n                    \"content\": reply\n                },\n                \"at\": {\n                    \"atUserIds\": [\n                       staffid \n                    ],\n                    \"isAtAll\": False\n                }\n            }\n        return resp\n    \n    def chat(self, channel, data):\n        reply = channel.handle(data)\n        type = data['conversationType']\n        if type == \"1\":\n            reply_json = self.build_response(reply, data)\n            self.notify_dingtalk(data, reply_json)\n        else:\n            # group\u7684\u4e0d\u6e05\u695a\u600e\u4e48@\uff0c\u5148\u7528webhook\u8c03\u7528\n            reply_json = self.build_webhook_response(reply, data)\n            self.notify_dingtalk_webhook(reply_json)\n        \n\n    def notify_dingtalk(self, data, reply_json):\n        headers = {\n            'content-type': 'application/json', \n            'x-acs-dingtalk-access-token': self.get_token()\n        }\n\n        notify_url = self.get_post_url(data)\n        try:\n            r = requests.post(notify_url, json=reply_json, headers=headers)\n            resp = r.json()\n            log.info(\"[DingTalk] response={}\".format(str(resp)))\n        except Exception as e:\n            log.error(e)", "\nclass DingTalkHandler():\n    def __init__(self, config):\n        self.dingtalk_key = config.get('dingtalk_key')\n        self.dingtalk_secret = config.get('dingtalk_secret')\n        self.dingtalk_token = config.get('dingtalk_token')\n        self.dingtalk_post_token = config.get('dingtalk_post_token')\n        self.access_token = None\n        log.info(\"[DingTalk] AppKey={}, AppSecret={} Token={} post Token={}\".format(self.dingtalk_key, self.dingtalk_secret, self.dingtalk_token, self.dingtalk_post_token))\n\n    def notify_dingtalk_webhook(self, data):\n        timestamp = round(time.time() * 1000)\n        secret_enc = bytes(self.dingtalk_secret, encoding='utf-8')\n        string_to_sign = '{}\\n{}'.format(timestamp, self.dingtalk_secret)\n        string_to_sign_enc = bytes(string_to_sign, encoding='utf-8')\n        hmac_code = hmac.new(secret_enc, string_to_sign_enc,\n                             digestmod=hashlib.sha256).digest()\n        sign = quote_plus(base64.b64encode(hmac_code))\n\n        notify_url = f\"https://oapi.dingtalk.com/robot/send?access_token={self.dingtalk_token}&timestamp={timestamp}&sign={sign}\"\n        try:\n            log.info(\"[DingTalk] url={}\".format(str(notify_url)))\n            r = requests.post(notify_url, json=data)\n            reply = r.json()\n            log.info(\"[DingTalk] reply={}\".format(str(reply)))\n        except Exception as e:\n            log.error(e)\n\n    def get_token_internal(self):\n        access_token_url = 'https://api.dingtalk.com/v1.0/oauth2/accessToken'\n        try:\n            r = requests.post(access_token_url, json={\"appKey\": self.dingtalk_key, \"appSecret\": self.dingtalk_secret})\n        except:\n            raise Exception(\"DingTalk token\u83b7\u53d6\u5931\u8d25!!!\")\n\n        data = json.loads(r.content)\n        access_token = data['accessToken']\n        expire_in = data['expireIn']\n        \n        self.access_token = access_token\n        self.expire_at = int(expire_in) + time.time()\n\n        return self.access_token\n    \n    def get_token(self):\n        if self.access_token is None or self.expire_at <= time.time():\n            self.get_token_internal()\n        \n        return self.access_token\n    \n    def get_post_url(self, data):\n        type = data['conversationType']\n        if type == \"1\":\n            return f\"https://api.dingtalk.com/v1.0/robot/oToMessages/batchSend\"\n        else:\n            return f\"https://api.dingtalk.com/v1.0/robot/groupMessages/send\"\n    \n    def build_response(self, reply, data):\n        type = data['conversationType']\n        if type == \"1\":\n            return self.build_oto_response(reply, data)\n        else:\n            return self.build_group_response(reply, data)\n\n    def build_oto_response(self, reply, data):\n        conversation_id = data['conversationId']\n        prompt = data['text']['content']\n        prompt = prompt.strip()\n        img_match_prefix = functions.check_prefix(\n            prompt, channel_conf_val(const.DINGTALK, 'image_create_prefix'))\n        nick = data['senderNick']\n        staffid = data['senderStaffId']\n        robotCode = data['robotCode']\n        if img_match_prefix and isinstance(reply, list):\n            images = \"\"\n            for url in reply:\n                images += f\"!['IMAGE_CREATE']({url})\\n\"\n            reply = images\n            resp = {\n                \"msgKey\": \"sampleMarkdown\",\n                \"msgParam\": json.dumps({\n                    \"title\": \"IMAGE @\" + nick + \" \", \n                    \"text\": images + \" \\n \" + \"@\" + nick\n                }),\n                \"robotCode\": robotCode,\n                \"userIds\": [staffid]\n            }\n        else:\n            resp = {\n                \"msgKey\": \"sampleText\",\n                \"msgParam\": json.dumps({\n                    \"content\": reply\n                }),\n                \"robotCode\": robotCode,\n                \"userIds\": [staffid]\n            }\n        return resp\n    \n    def build_group_response(self, reply, data):\n        conversation_id = data['conversationId']\n        prompt = data['text']['content']\n        prompt = prompt.strip()\n        img_match_prefix = functions.check_prefix(\n            prompt, channel_conf_val(const.DINGTALK, 'image_create_prefix'))\n        nick = data['senderNick']\n        staffid = data['senderStaffId']\n        robot_code = data['robotCode']\n        if img_match_prefix and isinstance(reply, list):\n            images = \"\"\n            for url in reply:\n                images += f\"!['IMAGE_CREATE']({url})\\n\"\n            reply = images\n            resp = {\n                \"msgKey\": \"sampleMarkdown\",\n                \"msgParam\": json.dumps({\n                    \"title\": \"IMAGE @\" + nick + \" \", \n                    \"text\": images + \" \\n \" + \"@\" + nick\n                }),\n                \"robotCode\": robot_code,\n                \"openConversationId\": conversation_id,\n                \"at\": {\n                    \"atUserIds\": [\n                        staffid\n                    ],\n                    \"isAtAll\": False\n                }\n            }\n        else:\n            resp = {\n                \"msgKey\": \"sampleText\",\n                \"msgParam\": json.dumps({\n                    \"content\": reply + \" \\n \" + \"@\" + nick\n                }),\n                \"robotCode\": robot_code,\n                \"openConversationId\": conversation_id,\n                \"at\": {\n                    \"atUserIds\": [\n                       staffid \n                    ],\n                    \"isAtAll\": False\n                }\n            }\n        return resp\n    \n    \n    def build_webhook_response(self, reply, data):\n        conversation_id = data['conversationId']\n        prompt = data['text']['content']\n        prompt = prompt.strip()\n        img_match_prefix = functions.check_prefix(\n            prompt, channel_conf_val(const.DINGTALK, 'image_create_prefix'))\n        nick = data['senderNick']\n        staffid = data['senderStaffId']\n        robotCode = data['robotCode']\n        if img_match_prefix and isinstance(reply, list):\n            images = \"\"\n            for url in reply:\n                images += f\"!['IMAGE_CREATE']({url})\\n\"\n            reply = images\n            resp = {\n                \"msgtype\": \"markdown\",\n                \"markdown\": {\n                    \"title\": \"IMAGE @\" + nick + \" \", \n                    \"text\": images + \" \\n \" + \"@\" + nick\n                },\n                \"at\": {\n                    \"atUserIds\": [\n                        staffid\n                    ],\n                    \"isAtAll\": False\n                }\n            }\n        else:\n            resp = {\n                \"msgtype\": \"text\",\n                \"text\": {\n                    \"content\": reply\n                },\n                \"at\": {\n                    \"atUserIds\": [\n                       staffid \n                    ],\n                    \"isAtAll\": False\n                }\n            }\n        return resp\n    \n    def chat(self, channel, data):\n        reply = channel.handle(data)\n        type = data['conversationType']\n        if type == \"1\":\n            reply_json = self.build_response(reply, data)\n            self.notify_dingtalk(data, reply_json)\n        else:\n            # group\u7684\u4e0d\u6e05\u695a\u600e\u4e48@\uff0c\u5148\u7528webhook\u8c03\u7528\n            reply_json = self.build_webhook_response(reply, data)\n            self.notify_dingtalk_webhook(reply_json)\n        \n\n    def notify_dingtalk(self, data, reply_json):\n        headers = {\n            'content-type': 'application/json', \n            'x-acs-dingtalk-access-token': self.get_token()\n        }\n\n        notify_url = self.get_post_url(data)\n        try:\n            r = requests.post(notify_url, json=reply_json, headers=headers)\n            resp = r.json()\n            log.info(\"[DingTalk] response={}\".format(str(resp)))\n        except Exception as e:\n            log.error(e)", "\n\nclass DingTalkChannel(Channel):\n    def __init__(self):\n        log.info(\"[DingTalk] started.\")\n\n    def startup(self):\n        http_app.run(host='0.0.0.0', port=channel_conf(const.DINGTALK).get('port'))\n\n    def handle(self, data):\n        reply = \"\u60a8\u597d\uff0c\u6709\u4ec0\u4e48\u6211\u53ef\u4ee5\u5e2e\u52a9\u60a8\u89e3\u7b54\u7684\u95ee\u9898\u5417\uff1f\"\n        prompt = data['text']['content']\n        prompt = prompt.strip()\n        if str(prompt) != 0:\n            conversation_id = data['conversationId']\n            sender_id = data['senderId']\n            context = dict()\n            img_match_prefix = functions.check_prefix(\n                prompt, channel_conf_val(const.DINGTALK, 'image_create_prefix'))\n            if img_match_prefix:\n                prompt = prompt.split(img_match_prefix, 1)[1].strip()\n                context['type'] = 'IMAGE_CREATE'\n            id = sender_id\n            context['from_user_id'] = str(id)\n            reply = super().build_reply_content(prompt, context)\n        return reply", "         \n\ndd = DingTalkChannel()\nhandlers = dict()\nrobots = channel_conf(const.DINGTALK).get('dingtalk_robots')\nif robots and len(robots) > 0:\n    for robot in robots:\n        robot_config = channel_conf(const.DINGTALK).get(robot)\n        robot_key = robot_config.get('dingtalk_key')\n        group_name = robot_config.get('dingtalk_group')\n        handlers[group_name or robot_key] = DingTalkHandler(robot_config)\nelse:\n    handlers['DEFAULT'] = DingTalkHandler(channel_conf(const.DINGTALK))", "http_app = Flask(__name__,)\n\n\n@http_app.route(\"/\", methods=['POST'])\ndef chat():\n    log.info(\"[DingTalk] chat_headers={}\".format(str(request.headers)))\n    log.info(\"[DingTalk] chat={}\".format(str(request.data)))\n    token = request.headers.get('token')\n    data = json.loads(request.data)\n    if data:\n        content = data['text']['content']\n        if not content:\n            return\n        code = data['robotCode']\n        group_name = None\n        if 'conversationTitle' in data:\n            group_name = data['conversationTitle']\n        handler = handlers.get(group_name, handlers.get(code, handlers.get('DEFAULT')))\n        if handler.dingtalk_post_token and token != handler.dingtalk_post_token:\n            return {'ret': 203}\n        handler.chat(dd, data)\n        return {'ret': 200}\n    \n    return {'ret': 201}", "\n"]}
{"filename": "channel/terminal/terminal_channel.py", "chunked_list": ["from channel.channel import Channel\nfrom common import log\n\nimport sys\n\nclass TerminalChannel(Channel):\n    def startup(self):\n        # close log\n        log.close_log()\n        context = {\"from_user_id\": \"User\", \"stream\": True}\n        print(\"\\nPlease input your question\")\n        while True:\n            try:\n                prompt = self.get_input(\"User:\\n\")\n            except KeyboardInterrupt:\n                print(\"\\nExiting...\")\n                sys.exit()\n\n            print(\"Bot:\")\n            sys.stdout.flush()\n            for res in super().build_reply_content(prompt, context):\n                print(res, end=\"\")\n                sys.stdout.flush()\n            print(\"\\n\")\n\n\n    def get_input(self, prompt):\n        \"\"\"\n        Multi-line input function\n        \"\"\"\n        print(prompt, end=\"\")\n        line = input()\n        return line", ""]}
{"filename": "channel/wechat/wechat_mp_channel.py", "chunked_list": ["import werobot\nimport time\nfrom config import channel_conf\nfrom common import const\nfrom common.log import logger\nfrom channel.channel import Channel\nfrom concurrent.futures import ThreadPoolExecutor\nimport os\n\n", "\n\n\nrobot = werobot.WeRoBot(token=channel_conf(const.WECHAT_MP).get('token'))\nthread_pool = ThreadPoolExecutor(max_workers=8)\ncache = {}\n\n@robot.text\ndef hello_world(msg):\n    with open('sensitive_words.txt', 'r', encoding='utf-8') as f: #\u52a0\u5165\u68c0\u6d4b\u8fdd\u89c4\u8bcd\n        sensitive_words = [line.strip() for line in f.readlines()]\n        found = False\n        for word in sensitive_words:\n            if word != '' and word in msg.content:\n                found = True\n                break\n        if found:\n            return \"\u8f93\u5165\u5185\u5bb9\u6709\u654f\u611f\u8bcd\u6c47\"\n\n        else:\n            logger.info('[WX_Public] receive public msg: {}, userId: {}'.format(msg.content, msg.source))\n            key = msg.content + '|' + msg.source\n            if cache.get(key):\n                # request time\n                cache.get(key)['req_times'] += 1\n            return WechatSubsribeAccount().handle(msg)", "def hello_world(msg):\n    with open('sensitive_words.txt', 'r', encoding='utf-8') as f: #\u52a0\u5165\u68c0\u6d4b\u8fdd\u89c4\u8bcd\n        sensitive_words = [line.strip() for line in f.readlines()]\n        found = False\n        for word in sensitive_words:\n            if word != '' and word in msg.content:\n                found = True\n                break\n        if found:\n            return \"\u8f93\u5165\u5185\u5bb9\u6709\u654f\u611f\u8bcd\u6c47\"\n\n        else:\n            logger.info('[WX_Public] receive public msg: {}, userId: {}'.format(msg.content, msg.source))\n            key = msg.content + '|' + msg.source\n            if cache.get(key):\n                # request time\n                cache.get(key)['req_times'] += 1\n            return WechatSubsribeAccount().handle(msg)", "\n\nclass WechatSubsribeAccount(Channel):\n    def startup(self):\n        logger.info('[WX_Public] Wechat Public account service start!')\n        robot.config['PORT'] = channel_conf(const.WECHAT_MP).get('port')\n        robot.config['HOST'] = '0.0.0.0'\n        robot.run()\n\n    def handle(self, msg, count=1):\n        if msg.content == \"\u7ee7\u7eed\":\n            return self.get_un_send_content(msg.source)\n\n        context = dict()\n        context['from_user_id'] = msg.source\n        key = msg.content + '|' + msg.source\n        res = cache.get(key)\n        if not res:\n            cache[key] = {\"status\": \"waiting\", \"req_times\": 1}\n            thread_pool.submit(self._do_send, msg.content, context)\n\n        res = cache.get(key)\n        logger.info(\"count={}, res={}\".format(count, res))\n        if res.get('status') == 'success':\n            res['status'] = \"done\"\n            cache.pop(key)\n            return res.get(\"data\")\n\n        if cache.get(key)['req_times'] == 3 and count >= 4:\n            logger.info(\"\u5fae\u4fe1\u8d85\u65f63\u6b21\")\n            return \"\u5df2\u5f00\u59cb\u5904\u7406\uff0c\u8bf7\u7a0d\u7b49\u7247\u523b\u540e\u8f93\u5165\\\"\u7ee7\u7eed\\\"\u67e5\u770b\u56de\u590d\"\n\n        if count <= 5:\n            time.sleep(1)\n            if count == 5:\n                # \u7b2c5\u79d2\u4e0d\u505a\u8fd4\u56de\uff0c\u9632\u6b62\u6d88\u606f\u53d1\u9001\u51fa\u53bb\u4e86\u4f46\u662f\u5fae\u4fe1\u5df2\u7ecf\u4e2d\u65ad\u8fde\u63a5\n                return None\n            return self.handle(msg, count+1)\n\n    def _do_send(self, query, context):\n        key = query + '|' + context['from_user_id']\n        reply_text = super().build_reply_content(query, context)\n        logger.info('[WX_Public] reply content: {}'.format(reply_text))\n        cache[key]['status'] = \"success\"\n        cache[key]['data'] = reply_text\n\n    def get_un_send_content(self, from_user_id):\n        for key in cache:\n            if from_user_id in key:\n                value = cache[key]\n                if value.get('status') == \"success\":\n                    cache.pop(key)\n                    return value.get(\"data\")\n                return \"\u8fd8\u5728\u5904\u7406\u4e2d\uff0c\u8bf7\u7a0d\u540e\u518d\u8bd5\"\n        return \"\u76ee\u524d\u65e0\u7b49\u5f85\u56de\u590d\u4fe1\u606f\uff0c\u8bf7\u8f93\u5165\u5bf9\u8bdd\"", ""]}
{"filename": "channel/wechat/wechat_com_channel.py", "chunked_list": ["#!/usr/bin/env python\n# -*- coding=utf-8 -*-\n\"\"\"\n@time: 2023/4/10 22:24\n@Project \uff1abot-on-anything\n@file: wechat_com_channel.py\n\n\"\"\"\nfrom channel.channel import Channel\nfrom concurrent.futures import ThreadPoolExecutor", "from channel.channel import Channel\nfrom concurrent.futures import ThreadPoolExecutor\nfrom common.log import logger\nfrom config import conf\n\nfrom wechatpy.enterprise.crypto import WeChatCrypto\nfrom wechatpy.enterprise import WeChatClient\nfrom wechatpy.exceptions import InvalidSignatureException\nfrom wechatpy.enterprise.exceptions import InvalidCorpIdException\nfrom wechatpy.enterprise import parse_message", "from wechatpy.enterprise.exceptions import InvalidCorpIdException\nfrom wechatpy.enterprise import parse_message\nfrom flask import Flask, request, abort\n\nthread_pool = ThreadPoolExecutor(max_workers=8)\napp = Flask(__name__)\n\n\n@app.route('/wechat', methods=['GET', 'POST'])\ndef handler_msg():\n    return WechatEnterpriseChannel().handle()", "@app.route('/wechat', methods=['GET', 'POST'])\ndef handler_msg():\n    return WechatEnterpriseChannel().handle()\n\n\n_conf = conf().get(\"channel\").get(\"wechat_com\")\n\n\nclass WechatEnterpriseChannel(Channel):\n    def __init__(self):\n        self.CorpId = _conf.get('wechat_corp_id')\n        self.Secret = _conf.get('secret')\n        self.AppId = _conf.get('appid')\n        self.TOKEN = _conf.get('wechat_token')\n        self.EncodingAESKey = _conf.get('wechat_encoding_aes_key')\n        self.crypto = WeChatCrypto(self.TOKEN, self.EncodingAESKey, self.CorpId)\n        self.client = WeChatClient(self.CorpId, self.Secret, self.AppId)\n\n    def startup(self):\n        # start message listener\n        app.run(host='0.0.0.0', port=_conf.get('port'))\n\n    def send(self, msg, receiver):\n        logger.info('[WXCOM] sendMsg={}, receiver={}'.format(msg, receiver))\n        self.client.message.send_text(self.AppId, receiver, msg)\n\n    def _do_send(self, query, reply_user_id):\n        try:\n            if not query:\n                return\n            context = dict()\n            context['from_user_id'] = reply_user_id\n            reply_text = super().build_reply_content(query, context)\n            if reply_text:\n                self.send(reply_text, reply_user_id)\n        except Exception as e:\n            logger.exception(e)\n\n    def handle(self):\n        query_params = request.args\n        signature = query_params.get('msg_signature', '')\n        timestamp = query_params.get('timestamp', '')\n        nonce = query_params.get('nonce', '')\n        if request.method == 'GET':\n            # \u5904\u7406\u9a8c\u8bc1\u8bf7\u6c42\n            echostr = query_params.get('echostr', '')\n            try:\n                echostr = self.crypto.check_signature(signature, timestamp, nonce, echostr)\n            except InvalidSignatureException:\n                abort(403)\n            print(echostr)\n            return echostr\n        elif request.method == 'POST':\n            try:\n                message = self.crypto.decrypt_message(\n                    request.data,\n                    signature,\n                    timestamp,\n                    nonce\n                )\n            except (InvalidSignatureException, InvalidCorpIdException):\n                abort(403)\n            msg = parse_message(message)\n            if msg.type == 'text':\n                thread_pool.submit(self._do_send, msg.content, msg.source)\n            else:\n                reply = 'Can not handle this for now'\n                # \u672a\u80fd\u5904\u7406\u7684\u6d88\u606f\u6216\u83dc\u5355\u4e8b\u4ef6\u6682\u4e0d\u505a\u54cd\u5e94\u4f18\u5316\u7528\u6237\u4f53\u9a8c\n                # self.client.message.send_text(self.AppId, msg.source, reply)\n            return 'success'", "class WechatEnterpriseChannel(Channel):\n    def __init__(self):\n        self.CorpId = _conf.get('wechat_corp_id')\n        self.Secret = _conf.get('secret')\n        self.AppId = _conf.get('appid')\n        self.TOKEN = _conf.get('wechat_token')\n        self.EncodingAESKey = _conf.get('wechat_encoding_aes_key')\n        self.crypto = WeChatCrypto(self.TOKEN, self.EncodingAESKey, self.CorpId)\n        self.client = WeChatClient(self.CorpId, self.Secret, self.AppId)\n\n    def startup(self):\n        # start message listener\n        app.run(host='0.0.0.0', port=_conf.get('port'))\n\n    def send(self, msg, receiver):\n        logger.info('[WXCOM] sendMsg={}, receiver={}'.format(msg, receiver))\n        self.client.message.send_text(self.AppId, receiver, msg)\n\n    def _do_send(self, query, reply_user_id):\n        try:\n            if not query:\n                return\n            context = dict()\n            context['from_user_id'] = reply_user_id\n            reply_text = super().build_reply_content(query, context)\n            if reply_text:\n                self.send(reply_text, reply_user_id)\n        except Exception as e:\n            logger.exception(e)\n\n    def handle(self):\n        query_params = request.args\n        signature = query_params.get('msg_signature', '')\n        timestamp = query_params.get('timestamp', '')\n        nonce = query_params.get('nonce', '')\n        if request.method == 'GET':\n            # \u5904\u7406\u9a8c\u8bc1\u8bf7\u6c42\n            echostr = query_params.get('echostr', '')\n            try:\n                echostr = self.crypto.check_signature(signature, timestamp, nonce, echostr)\n            except InvalidSignatureException:\n                abort(403)\n            print(echostr)\n            return echostr\n        elif request.method == 'POST':\n            try:\n                message = self.crypto.decrypt_message(\n                    request.data,\n                    signature,\n                    timestamp,\n                    nonce\n                )\n            except (InvalidSignatureException, InvalidCorpIdException):\n                abort(403)\n            msg = parse_message(message)\n            if msg.type == 'text':\n                thread_pool.submit(self._do_send, msg.content, msg.source)\n            else:\n                reply = 'Can not handle this for now'\n                # \u672a\u80fd\u5904\u7406\u7684\u6d88\u606f\u6216\u83dc\u5355\u4e8b\u4ef6\u6682\u4e0d\u505a\u54cd\u5e94\u4f18\u5316\u7528\u6237\u4f53\u9a8c\n                # self.client.message.send_text(self.AppId, msg.source, reply)\n            return 'success'", ""]}
{"filename": "channel/wechat/wechat_channel.py", "chunked_list": ["# encoding:utf-8\n\n\"\"\"\nwechat channel\n\"\"\"\n\nimport time\nimport itchat\nimport json\nfrom itchat.content import *", "import json\nfrom itchat.content import *\nfrom channel.channel import Channel\nfrom concurrent.futures import ThreadPoolExecutor\nfrom common.log import logger\nfrom common import const\nfrom config import channel_conf_val\nimport requests\nfrom plugins.plugin_manager import *\nfrom common.sensitive_word import SensitiveWord", "from plugins.plugin_manager import *\nfrom common.sensitive_word import SensitiveWord\n\nimport io\n\n\nthread_pool = ThreadPoolExecutor(max_workers=8)\nsw = SensitiveWord()\n\n@itchat.msg_register(TEXT)\ndef handler_single_msg(msg):\n    WechatChannel().handle(msg)\n    return None", "\n@itchat.msg_register(TEXT)\ndef handler_single_msg(msg):\n    WechatChannel().handle(msg)\n    return None\n\n\n@itchat.msg_register(TEXT, isGroupChat=True)\ndef handler_group_msg(msg):\n    WechatChannel().handle_group(msg)\n    return None", "def handler_group_msg(msg):\n    WechatChannel().handle_group(msg)\n    return None\n\n\nclass WechatChannel(Channel):\n    def __init__(self):\n        pass\n\n    def startup(self):\n        # login by scan QRCode\n        hot_reload = channel_conf_val(const.WECHAT, 'hot_reload', True)\n        if channel_conf_val(const.WECHAT, 'receive_qrcode_api'):\n            itchat.auto_login(enableCmdQR=2, hot_reload=hot_reload, qrCallback=self.login)\n        else:\n            itchat.auto_login(enableCmdQR=2, hotReload=hot_reload)\n\n        # start message listener\n        itchat.run()\n\n    def login(self, uuid=None, status='0', qrcode=None):\n        print('uuid:', uuid)\n        print('status:', status)\n        # \u8bf7\u5c06\u94fe\u63a5\u8f6c\u53d1\u5230\u5916\u90e8\u63a5\u53e3\uff0c\u5e76\u5728\u5916\u90e8\u81ea\u884c\u901a\u8fc7\u4e8c\u7ef4\u7801\u751f\u6210\u5e93\u5c06\u94fe\u63a5\u8f6c\u6362\u4e3a\u4e8c\u7ef4\u7801\u540e\u5c55\u793a\uff0c\u4f8b\u5982\uff1a\u5c06\u4e0b\u65b9\u7684 qrcode_link \u901a\u8fc7\u8349\u6599\u4e8c\u7ef4\u7801\u8fdb\u884c\u5904\u7406\u540e\uff0c\u518d\u901a\u8fc7\u624b\u673a\u7aef\u626b\u7801\u767b\u5f55\u5fae\u4fe1\u5c0f\u53f7\n        print('qrcode_link:', 'https://login.weixin.qq.com/l/'+uuid)\n\n    def handle(self, msg):\n        logger.debug(\"[WX]receive msg: \" + json.dumps(msg, ensure_ascii=False))\n        from_user_id = msg['FromUserName']\n        to_user_id = msg['ToUserName']              # \u63a5\u6536\u4ebaid\n        other_user_id = msg['User']['UserName']     # \u5bf9\u624b\u65b9id\n        create_time = msg['CreateTime']             # \u6d88\u606f\u65f6\u95f4\n        content = msg['Text']\n\n        hot_reload = channel_conf_val(const.WECHAT, 'hot_reload', True)\n        if hot_reload == True and int(create_time) < int(time.time()) - 60:  # \u8df3\u8fc71\u5206\u949f\u524d\u7684\u5386\u53f2\u6d88\u606f\n            logger.debug(\"[WX]history message skipped\")\n            return\n\n        # \u8c03\u7528\u654f\u611f\u8bcd\u68c0\u6d4b\u51fd\u6570\n        if sw.process_text(content):\n            self.send('\u8bf7\u68c0\u67e5\u60a8\u7684\u8f93\u5165\u662f\u5426\u6709\u8fdd\u89c4\u5185\u5bb9', from_user_id)\n            return\n\n        match_prefix = self.check_prefix(content, channel_conf_val(const.WECHAT, 'single_chat_prefix'))\n        if from_user_id == other_user_id and match_prefix is not None:\n            # \u597d\u53cb\u5411\u81ea\u5df1\u53d1\u9001\u6d88\u606f\n            if match_prefix != '':\n                str_list = content.split(match_prefix, 1)\n                if len(str_list) == 2:\n                    content = str_list[1].strip()\n            thread_pool.submit(self._do_send, content, from_user_id)\n\n        elif to_user_id == other_user_id and match_prefix:\n            # \u81ea\u5df1\u7ed9\u597d\u53cb\u53d1\u9001\u6d88\u606f\n            str_list = content.split(match_prefix, 1)\n            if len(str_list) == 2:\n                content = str_list[1].strip()\n            thread_pool.submit(self._do_send, content, to_user_id)\n\n\n    def handle_group(self, msg):\n        logger.debug(\"[WX]receive group msg: \" + json.dumps(msg, ensure_ascii=False))\n        group_name = msg['User'].get('NickName', None)\n        group_id = msg['User'].get('UserName', None)\n        create_time = msg['CreateTime']             # \u6d88\u606f\u65f6\u95f4\n\n        hot_reload = channel_conf_val(const.WECHAT, 'hot_reload', True)\n        if hot_reload == True and int(create_time) < int(time.time()) - 60:  # \u8df3\u8fc71\u5206\u949f\u524d\u7684\u5386\u53f2\u6d88\u606f\n            logger.debug(\"[WX]history message skipped\")\n            return\n\n        if not group_name:\n            return None\n        origin_content = msg['Content']\n        content = msg['Content']\n        content_list = content.split(' ', 1)\n        context_special_list = content.split('\\u2005', 1)\n        if len(context_special_list) == 2:\n            content = context_special_list[1]\n        elif len(content_list) == 2:\n            content = content_list[1]\n\n        \n\n        match_prefix = (msg['IsAt'] and not channel_conf_val(const.WECHAT, \"group_at_off\", False)) or self.check_prefix(origin_content, channel_conf_val(const.WECHAT, 'group_chat_prefix')) or self.check_contain(origin_content, channel_conf_val(const.WECHAT, 'group_chat_keyword'))\n\n        # \u5982\u679c\u5728\u7fa4\u91cc\u88abat\u4e86 \u6216 \u89e6\u53d1\u673a\u5668\u4eba\u5173\u952e\u5b57\uff0c\u5219\u8c03\u7528\u654f\u611f\u8bcd\u68c0\u6d4b\u51fd\u6570\n        if match_prefix is True:\n            if sw.process_text(content):\n                self.send('\u8bf7\u68c0\u67e5\u60a8\u7684\u8f93\u5165\u662f\u5426\u6709\u8fdd\u89c4\u5185\u5bb9', group_id)\n                return\n\n        group_white_list = channel_conf_val(const.WECHAT, 'group_name_white_list')\n        \n        if ('ALL_GROUP' in group_white_list or group_name in group_white_list or self.check_contain(group_name, channel_conf_val(const.WECHAT, 'group_name_keyword_white_list'))) and match_prefix:\n            thread_pool.submit(self._do_send_group, content, msg)\n        return None\n\n    def send(self, msg, receiver):\n        logger.info('[WX] sendMsg={}, receiver={}'.format(msg, receiver))\n        itchat.send(msg, toUserName=receiver)\n\n    def _do_send(self, query, reply_user_id):\n        try:\n            if not query:\n                return\n            context = dict()\n            context['from_user_id'] = reply_user_id\n            e_context = PluginManager().emit_event(EventContext(Event.ON_HANDLE_CONTEXT, {\n                'channel': self, 'context': query,  \"args\": context}))\n\n            reply = e_context['reply']\n            if not e_context.is_pass():\n                reply = super().build_reply_content(e_context[\"context\"], e_context[\"args\"])\n                e_context = PluginManager().emit_event(EventContext(Event.ON_DECORATE_REPLY, {\n                    'channel': self, 'context': context, 'reply': reply, \"args\": e_context[\"args\"]}))\n                reply = e_context['reply']\n                if reply:\n                    self.send(channel_conf_val(const.WECHAT, \"single_chat_reply_prefix\") + reply, reply_user_id)\n        except Exception as e:\n            logger.exception(e)\n\n    def _do_send_img(self, query, context):\n        try:\n            if not query:\n                return\n            reply_user_id=context['from_user_id']\n            img_urls = super().build_reply_content(query, context)\n            if not img_urls:\n                return\n            if not isinstance(img_urls, list):\n                self.send(channel_conf_val(const.WECHAT, \"single_chat_reply_prefix\") + img_urls, reply_user_id)\n                return\n            for url in img_urls:\n            # \u56fe\u7247\u4e0b\u8f7d\n                pic_res = requests.get(url, stream=True)\n                image_storage = io.BytesIO()\n                for block in pic_res.iter_content(1024):\n                    image_storage.write(block)\n                image_storage.seek(0)\n\n                # \u56fe\u7247\u53d1\u9001\n                logger.info('[WX] sendImage, receiver={}'.format(reply_user_id))\n                itchat.send_image(image_storage, reply_user_id)\n        except Exception as e:\n            logger.exception(e)\n\n    def _do_send_group(self, query, msg):\n        if not query:\n            return\n        context = dict()\n        context['from_user_id'] = msg['User']['UserName']\n        e_context = PluginManager().emit_event(EventContext(Event.ON_HANDLE_CONTEXT, {\n            'channel': self, 'context': query,  \"args\": context}))\n        reply = e_context['reply']\n        if not e_context.is_pass():\n            context['from_user_id'] = msg['ActualUserName']\n            reply = super().build_reply_content(e_context[\"context\"], e_context[\"args\"])\n            e_context = PluginManager().emit_event(EventContext(Event.ON_DECORATE_REPLY, {\n                'channel': self, 'context': context, 'reply': reply, \"args\": e_context[\"args\"]}))\n            reply = e_context['reply']\n            if reply:\n                reply = '@' + msg['ActualNickName'] + ' ' + reply.strip()\n                self.send(channel_conf_val(const.WECHAT, \"group_chat_reply_prefix\", \"\") + reply, msg['User']['UserName'])\n\n    def check_prefix(self, content, prefix_list):\n        for prefix in prefix_list:\n            if content.startswith(prefix):\n                return prefix\n        return None\n\n\n    def check_contain(self, content, keyword_list):\n        if not keyword_list:\n            return None\n        for ky in keyword_list:\n            if content.find(ky) != -1:\n                return True\n        return None", ""]}
{"filename": "channel/wechat/wechat_mp_service_channel.py", "chunked_list": ["import werobot\nfrom config import channel_conf\nfrom common import const\nfrom common.log import logger\nfrom channel.channel import Channel\nfrom concurrent.futures import ThreadPoolExecutor\n\nrobot = werobot.WeRoBot(token=channel_conf(const.WECHAT_MP).get('token'))\nthread_pool = ThreadPoolExecutor(max_workers=8)\n", "thread_pool = ThreadPoolExecutor(max_workers=8)\n\n@robot.text\ndef hello_world(msg):\n    logger.info('[WX_Public] receive public msg: {}, userId: {}'.format(msg.content, msg.source))\n    return WechatServiceAccount().handle(msg)\n\n\nclass WechatServiceAccount(Channel):\n    def startup(self):\n        logger.info('[WX_Public] Wechat Public account service start!')\n        robot.config['PORT'] = channel_conf(const.WECHAT_MP).get('port')\n        robot.config[\"APP_ID\"] = channel_conf(const.WECHAT_MP).get('app_id')\n        robot.config[\"APP_SECRET\"] = channel_conf(const.WECHAT_MP).get('app_secret')\n        robot.config['HOST'] = '0.0.0.0'\n        robot.run()\n\n    def handle(self, msg, count=0):\n        context = {}\n        context['from_user_id'] = msg.source\n        thread_pool.submit(self._do_send, msg.content, context)\n        return \"\u6b63\u5728\u601d\u8003\u4e2d...\"\n\n\n    def _do_send(self, query, context):\n        reply_text = super().build_reply_content(query, context)\n        logger.info('[WX_Public] reply content: {}'.format(reply_text))\n        client = robot.client\n        client.send_text_message(context['from_user_id'], reply_text)", "class WechatServiceAccount(Channel):\n    def startup(self):\n        logger.info('[WX_Public] Wechat Public account service start!')\n        robot.config['PORT'] = channel_conf(const.WECHAT_MP).get('port')\n        robot.config[\"APP_ID\"] = channel_conf(const.WECHAT_MP).get('app_id')\n        robot.config[\"APP_SECRET\"] = channel_conf(const.WECHAT_MP).get('app_secret')\n        robot.config['HOST'] = '0.0.0.0'\n        robot.run()\n\n    def handle(self, msg, count=0):\n        context = {}\n        context['from_user_id'] = msg.source\n        thread_pool.submit(self._do_send, msg.content, context)\n        return \"\u6b63\u5728\u601d\u8003\u4e2d...\"\n\n\n    def _do_send(self, query, context):\n        reply_text = super().build_reply_content(query, context)\n        logger.info('[WX_Public] reply content: {}'.format(reply_text))\n        client = robot.client\n        client.send_text_message(context['from_user_id'], reply_text)", ""]}
{"filename": "channel/qq/qq_channel.py", "chunked_list": ["from channel.channel import Channel\nfrom aiocqhttp import CQHttp, Event\nfrom common import log\nfrom concurrent.futures import ThreadPoolExecutor\n\nbot = CQHttp(api_root='http://127.0.0.1:5700')\nthread_pool = ThreadPoolExecutor(max_workers=8)\n\n@bot.on_message('private')\ndef handle_private_msg(event: Event):\n    log.info(\"event: {}\", event)\n    QQChannel().handle(event)", "@bot.on_message('private')\ndef handle_private_msg(event: Event):\n    log.info(\"event: {}\", event)\n    QQChannel().handle(event)\n\n@bot.on_message('group')\ndef handle_private_msg(event: Event):\n    log.info(\"event: {}\", event)\n    QQChannel().handle_group(event)\n\nclass QQChannel(Channel):\n    def startup(self):\n        bot.run(host='127.0.0.1', port=8080)\n\n    # private chat\n    def handle(self, msg):\n        thread_pool.submit(self._do_handle, msg)\n\n    def _do_handle(self, msg):\n        context = dict()\n        log.info(\"event: {}\", \"do_handle\")\n        context['from_user_id'] = msg.user_id\n        reply_text = super().build_reply_content(msg.message, context)\n        bot.sync.send_private_msg(user_id=msg.user_id, message=reply_text)\n\n    # group chat\n    def handle_group(self, msg):\n        thread_pool.submit(self._do_handle_group, msg)\n\n    def _do_handle_group(self, msg):\n        context = dict()\n        if msg.message and msg.message.find('CQ:at'):\n            receiver = msg.message.split('qq=')[1].split(']')[0]\n            if receiver == str(msg['self_id']):\n                text_list = msg.message.split(']', 2)\n                if len(text_list) == 2 and len(text_list[1]) > 0:\n                    query = text_list[1].strip()\n                    context['from_user_id'] = str(msg.user_id)\n                    reply_text = super().build_reply_content(query, context)\n                    reply_text = '[CQ:at,qq=' + str(msg.user_id) + '] ' + reply_text\n\n                    bot.sync.send_group_msg(group_id=msg['group_id'], message=reply_text)", "\nclass QQChannel(Channel):\n    def startup(self):\n        bot.run(host='127.0.0.1', port=8080)\n\n    # private chat\n    def handle(self, msg):\n        thread_pool.submit(self._do_handle, msg)\n\n    def _do_handle(self, msg):\n        context = dict()\n        log.info(\"event: {}\", \"do_handle\")\n        context['from_user_id'] = msg.user_id\n        reply_text = super().build_reply_content(msg.message, context)\n        bot.sync.send_private_msg(user_id=msg.user_id, message=reply_text)\n\n    # group chat\n    def handle_group(self, msg):\n        thread_pool.submit(self._do_handle_group, msg)\n\n    def _do_handle_group(self, msg):\n        context = dict()\n        if msg.message and msg.message.find('CQ:at'):\n            receiver = msg.message.split('qq=')[1].split(']')[0]\n            if receiver == str(msg['self_id']):\n                text_list = msg.message.split(']', 2)\n                if len(text_list) == 2 and len(text_list[1]) > 0:\n                    query = text_list[1].strip()\n                    context['from_user_id'] = str(msg.user_id)\n                    reply_text = super().build_reply_content(query, context)\n                    reply_text = '[CQ:at,qq=' + str(msg.user_id) + '] ' + reply_text\n\n                    bot.sync.send_group_msg(group_id=msg['group_id'], message=reply_text)", ""]}
{"filename": "channel/discord/discord_channel.py", "chunked_list": ["# encoding:utf-8\n\n\"\"\"\ndiscord channel\nPython discord - https://github.com/Rapptz/discord.py.git\n\"\"\"\nfrom channel.channel import Channel\nfrom common.log import logger\nfrom config import conf, common_conf_val, channel_conf\nimport ssl", "from config import conf, common_conf_val, channel_conf\nimport ssl\nimport discord\nfrom discord.ext import commands\n\nclass DiscordChannel(Channel):\n\n    def __init__(self):\n        config = conf()\n        \n        self.token = channel_conf('discord').get('app_token')\n        self.discord_channel_name = channel_conf('discord').get('channel_name')\n        self.discord_channel_session = channel_conf('discord').get('channel_session', 'author')\n        self.voice_enabled = channel_conf('discord').get('voice_enabled', False)\n        self.cmd_clear_session = common_conf_val('clear_memory_commands', ['#\u6e05\u9664\u8bb0\u5fc6'])[0]\n        self.sessions = []\n        self.intents = discord.Intents.default()\n        self.intents.message_content = True\n        self.intents.guilds = True\n        self.intents.members = True\n        self.intents.messages = True\n        self.intents.voice_states = True\n        \n        context = ssl.create_default_context()\n        context.load_verify_locations(common_conf_val('certificate_file'))\n        self.bot = commands.Bot(command_prefix='!', intents=self.intents, ssl=context)\n        self.bot.add_listener(self.on_ready)\n\n        logger.debug('cmd_clear_session %s', self.cmd_clear_session)\n\n    def startup(self):\n        self.bot.add_listener(self.on_message)\n        self.bot.add_listener(self.on_guild_channel_delete)\n        self.bot.add_listener(self.on_guild_channel_create)\n        self.bot.add_listener(self.on_private_channel_delete)\n        self.bot.add_listener(self.on_private_channel_create)\n        self.bot.add_listener(self.on_channel_delete)\n        self.bot.add_listener(self.on_channel_create)\n        self.bot.add_listener(self.on_thread_delete)\n        self.bot.add_listener(self.on_thread_create)\n        self.bot.run(self.token)\n\n    async def on_ready(self):\n        logger.info('Bot is online user:{}'.format(self.bot.user))\n        if self.voice_enabled == False: \n            logger.debug('disable music')\n            await self.bot.remove_cog(\"Music\")\n    \n    async def join(self, ctx):\n        logger.debug('join %s', repr(ctx))\n        channel = ctx.author.voice.channel\n        await channel.connect()\n\n    async def _do_on_channel_delete(self, channel):\n        if not self.discord_channel_name or channel.name != self.discord_channel_name:\n            logger.debug('skip _do_on_channel_delete %s', channel.name)\n            return\n        \n        for name in self.sessions:\n            try:\n                response = self.send_text(name, self.cmd_clear_session)\n                logger.debug('_do_on_channel_delete %s %s', channel.name, response)\n            except Exception as e:\n                logger.warn('clear session except, id:%s', name)\n\n        self.sessions.clear()\n\n    async def on_guild_channel_delete(self, channel):\n        logger.debug('on_guild_channel_delete %s', repr(channel))\n        await self._do_on_channel_delete(channel)\n    \n    async def on_guild_channel_create(self, channel):\n        logger.debug('on_guild_channel_create %s', repr(channel))\n\n    async def on_private_channel_delete(self, channel):\n        logger.debug('on_channel_delete %s', repr(channel))\n        await self._do_on_channel_delete(channel)\n    \n    async def on_private_channel_create(self, channel):\n        logger.debug('on_channel_create %s', repr(channel))\n\n    async def on_channel_delete(self, channel):\n        logger.debug('on_channel_delete %s', repr(channel))\n    \n    async def on_channel_create(self, channel):\n        logger.debug('on_channel_create %s', repr(channel))\n\n    async def on_thread_delete(self, thread):\n        print('on_thread_delete', thread)\n        if self.discord_channel_session != 'thread' or thread.parent.name != self.discord_channel_name:\n            logger.debug('skip on_thread_delete %s', thread.id)\n            return\n        \n        try:\n            response = self.send_text(thread.id, self.cmd_clear_session)\n            if thread.id in self.sessions:\n                self.sessions.remove(thread.id)\n            logger.debug('on_thread_delete %s %s', thread.id, response)\n        except Exception as e:\n            logger.warn('on_thread_delete except %s', thread.id)\n            raise e\n            \n\n    async def on_thread_create(self, thread):\n        logger.debug('on_thread_create %s', thread.id) \n        if self.discord_channel_session != 'thread' or thread.parent.name != self.discord_channel_name:\n            logger.debug('skip on_channel_create %s', repr(thread))\n            return\n        \n        self.sessions.append(thread.id)\n\n    async def on_message(self, message):\n        \"\"\"\n        listen for message event\n        \"\"\"\n        await self.bot.wait_until_ready()\n        if not self.check_message(message):\n            return\n \n        prompt = message.content.strip();\n        logger.debug('author: %s', message.author)\n        logger.debug('prompt: %s', prompt)\n\n        session_id = message.author\n        if self.discord_channel_session == 'thread' and isinstance(message.channel, discord.Thread):\n            logger.debug('on_message thread id %s', message.channel.id)\n            session_id = message.channel.id\n\n        await message.channel.send('...')\n        response = response = self.send_text(session_id, prompt)\n        await message.channel.send(response)\n\n\n    def check_message(self, message):\n        if message.author == self.bot.user:\n            return False\n        \n        prompt = message.content.strip();\n        if not prompt:\n            logger.debug('no prompt author: %s', message.author)\n            return False\n   \n        if self.discord_channel_name:\n            if isinstance(message.channel, discord.Thread) and message.channel.parent.name == self.discord_channel_name:\n                return True\n            if not isinstance(message.channel, discord.Thread) and self.discord_channel_session != 'thread' and message.channel.name == self.discord_channel_name:\n                return True\n            \n            logger.debug(\"The accessed channel does not meet the discord channel configuration conditions.\")\n            return False\n        else:\n            return True\n        \n    def send_text(self, id, content):\n        context = dict()\n        context['type'] = 'TEXT'\n        context['from_user_id'] = id\n        context['content'] = content\n        return super().build_reply_content(content, context)"]}
{"filename": "channel/http/auth.py", "chunked_list": ["# encoding:utf-8\n\nimport jwt\nimport datetime\nimport time\nfrom flask import jsonify, request\nfrom common import const\nfrom config import channel_conf\n\n\nclass Auth():\n    def __init__(self, login):\n    # argument 'privilegeRequired' is to set up your method's privilege\n    # name\n        self.login = login\n        super(Auth, self).__init__()\n\n    @staticmethod\n    def encode_auth_token(user_id, login_time):\n        \"\"\"\n        \u751f\u6210\u8ba4\u8bc1Token\n        :param user_id: int\n        :param login_time: datetime\n        :return: string\n        \"\"\"\n        try:\n            payload = {\n                'iss': 'ken',  # \u7b7e\u540d\n                'exp': datetime.datetime.utcnow() + datetime.timedelta(days=0, hours=10),  # \u8fc7\u671f\u65f6\u95f4\n                'iat': datetime.datetime.utcnow(),  # \u5f00\u59cb\u65f6\u95f4\n                'data': {\n                    'id': user_id,\n                    'login_time': login_time\n                }\n            }\n            return jwt.encode(\n                payload,\n                channel_conf(const.HTTP).get('http_auth_secret_key'),\n                algorithm='HS256'\n            )  # \u52a0\u5bc6\u751f\u6210\u5b57\u7b26\u4e32\n        except Exception as e:\n            return e\n\n    @staticmethod\n    def decode_auth_token(auth_token):\n        \"\"\"\n        \u9a8c\u8bc1Token\n        :param auth_token:\n        :return: integer|string\n        \"\"\"\n        try:\n            # \u53d6\u6d88\u8fc7\u671f\u65f6\u95f4\u9a8c\u8bc1\n            payload = jwt.decode(auth_token, channel_conf(const.HTTP).get(\n                'http_auth_secret_key'), algorithms='HS256')  # options={'verify_exp': False} \u52a0\u4e0a\u540e\u4e0d\u9a8c\u8bc1token\u8fc7\u671f\u65f6\u95f4\n            if ('data' in payload and 'id' in payload['data']):\n                return payload\n            else:\n                raise jwt.InvalidTokenError\n        except jwt.ExpiredSignatureError:\n            return 'Token\u8fc7\u671f'\n        except jwt.InvalidTokenError:\n            return '\u65e0\u6548Token'", "\n\nclass Auth():\n    def __init__(self, login):\n    # argument 'privilegeRequired' is to set up your method's privilege\n    # name\n        self.login = login\n        super(Auth, self).__init__()\n\n    @staticmethod\n    def encode_auth_token(user_id, login_time):\n        \"\"\"\n        \u751f\u6210\u8ba4\u8bc1Token\n        :param user_id: int\n        :param login_time: datetime\n        :return: string\n        \"\"\"\n        try:\n            payload = {\n                'iss': 'ken',  # \u7b7e\u540d\n                'exp': datetime.datetime.utcnow() + datetime.timedelta(days=0, hours=10),  # \u8fc7\u671f\u65f6\u95f4\n                'iat': datetime.datetime.utcnow(),  # \u5f00\u59cb\u65f6\u95f4\n                'data': {\n                    'id': user_id,\n                    'login_time': login_time\n                }\n            }\n            return jwt.encode(\n                payload,\n                channel_conf(const.HTTP).get('http_auth_secret_key'),\n                algorithm='HS256'\n            )  # \u52a0\u5bc6\u751f\u6210\u5b57\u7b26\u4e32\n        except Exception as e:\n            return e\n\n    @staticmethod\n    def decode_auth_token(auth_token):\n        \"\"\"\n        \u9a8c\u8bc1Token\n        :param auth_token:\n        :return: integer|string\n        \"\"\"\n        try:\n            # \u53d6\u6d88\u8fc7\u671f\u65f6\u95f4\u9a8c\u8bc1\n            payload = jwt.decode(auth_token, channel_conf(const.HTTP).get(\n                'http_auth_secret_key'), algorithms='HS256')  # options={'verify_exp': False} \u52a0\u4e0a\u540e\u4e0d\u9a8c\u8bc1token\u8fc7\u671f\u65f6\u95f4\n            if ('data' in payload and 'id' in payload['data']):\n                return payload\n            else:\n                raise jwt.InvalidTokenError\n        except jwt.ExpiredSignatureError:\n            return 'Token\u8fc7\u671f'\n        except jwt.InvalidTokenError:\n            return '\u65e0\u6548Token'", "\n\ndef authenticate(password):\n    \"\"\"\n    \u7528\u6237\u767b\u5f55\uff0c\u767b\u5f55\u6210\u529f\u8fd4\u56detoken\n    :param password:\n    :return: json\n    \"\"\"\n    authPassword = channel_conf(const.HTTP).get('http_auth_password')\n    if (authPassword != password):\n        return False\n    else:\n        login_time = time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime())\n        token = Auth.encode_auth_token(password, login_time)\n        return token", "\n\ndef identify(request):\n    \"\"\"\n    \u7528\u6237\u9274\u6743\n    :return: list\n    \"\"\"\n    try:\n        authPassword = channel_conf(const.HTTP).get('http_auth_password')\n        if (not authPassword):\n            return True\n        if (request is None):\n            return False\n        authorization = request.cookies.get('Authorization')\n        if (authorization):\n            payload = Auth.decode_auth_token(authorization)\n            if not isinstance(payload, str):\n                authPassword = channel_conf(\n                    const.HTTP).get('http_auth_password')\n                password = payload['data']['id']\n                if (password != authPassword):\n                    return False\n                else:\n                    return True\n        return False\n \n    except jwt.ExpiredSignatureError:\n        #result = 'Token\u5df2\u66f4\u6539\uff0c\u8bf7\u91cd\u65b0\u767b\u5f55\u83b7\u53d6'\n        return False\n \n    except jwt.InvalidTokenError:\n        #result = '\u6ca1\u6709\u63d0\u4f9b\u8ba4\u8bc1token'\n        return False", ""]}
{"filename": "channel/http/http_channel.py", "chunked_list": ["# encoding:utf-8\n\nimport asyncio\nimport json\nfrom channel.http import auth\nfrom flask import Flask, request, render_template, make_response\nfrom datetime import timedelta\nfrom common import const\nfrom common import functions\nfrom config import channel_conf", "from common import functions\nfrom config import channel_conf\nfrom config import channel_conf_val\nfrom channel.channel import Channel\nfrom flask_socketio import SocketIO\nfrom common import log\nfrom plugins.plugin_manager import *\n\nhttp_app = Flask(__name__,)\nsocketio = SocketIO(http_app, close_timeout=5)", "http_app = Flask(__name__,)\nsocketio = SocketIO(http_app, close_timeout=5)\n# \u81ea\u52a8\u91cd\u8f7d\u6a21\u677f\u6587\u4ef6\nhttp_app.jinja_env.auto_reload = True\nhttp_app.config['TEMPLATES_AUTO_RELOAD'] = True\n\n# \u8bbe\u7f6e\u9759\u6001\u6587\u4ef6\u7f13\u5b58\u8fc7\u671f\u65f6\u95f4\nhttp_app.config['SEND_FILE_MAX_AGE_DEFAULT'] = timedelta(seconds=1)\n\n", "\n\nasync def return_stream(data):\n    async for final, response in HttpChannel().handle_stream(data=data):\n        try:\n            if (final):\n                socketio.server.emit(\n                    'disconnect', {'result': response, 'final': final}, request.sid, namespace=\"/chat\")\n                disconnect()\n            else:\n                socketio.server.emit(\n                    'message', {'result': response, 'final': final}, request.sid, namespace=\"/chat\")\n        except Exception as e:\n            disconnect()\n            log.warn(\"[http]emit:{}\", e)\n            break", "\n\n@socketio.on('message', namespace='/chat')\ndef stream(data):\n    if (auth.identify(request) == False):\n        client_sid = request.sid\n        socketio.server.disconnect(client_sid)\n        return\n    data = json.loads(data[\"data\"])\n    if (data):\n        img_match_prefix = functions.check_prefix(\n            data[\"msg\"], channel_conf_val(const.HTTP, 'image_create_prefix'))\n        if img_match_prefix:\n            reply_text = HttpChannel().handle(data=data)\n            socketio.emit(\n                'disconnect', {'result': reply_text}, namespace='/chat')\n            disconnect()\n            return\n        asyncio.run(return_stream(data))", "\n\n@socketio.on('connect', namespace='/chat')\ndef connect():\n    log.info('connected')\n    socketio.emit('message', {'info': \"connected\"}, namespace='/chat')\n\n\n@socketio.on('disconnect', namespace='/chat')\ndef disconnect():\n    log.info('disconnect')\n    socketio.server.disconnect(request.sid, namespace=\"/chat\")", "@socketio.on('disconnect', namespace='/chat')\ndef disconnect():\n    log.info('disconnect')\n    socketio.server.disconnect(request.sid, namespace=\"/chat\")\n\n\n@http_app.route(\"/chat\", methods=['POST'])\ndef chat():\n    if (auth.identify(request) == False):\n        return\n    data = json.loads(request.data)\n    if data:\n        msg = data['msg']\n        if not msg:\n            return\n        reply_text = HttpChannel().handle(data=data)\n        return {'result': reply_text}", "\n\n@http_app.route(\"/\", methods=['GET'])\ndef index():\n    if (auth.identify(request) == False):\n        return login()\n    return render_template('index.html')\n\n\n@http_app.route(\"/login\", methods=['POST', 'GET'])\ndef login():\n    response = make_response(\"<html></html>\", 301)\n    response.headers.add_header('content-type', 'text/plain')\n    response.headers.add_header('location', './')\n    if (auth.identify(request) == True):\n        return response\n    else:\n        if request.method == \"POST\":\n            token = auth.authenticate(request.form['password'])\n            if (token != False):\n                response.set_cookie(key='Authorization', value=token)\n                return response\n        else:\n            return render_template('login.html')\n    response.headers.set('location', './login?err=\u767b\u5f55\u5931\u8d25')\n    return response", "\n@http_app.route(\"/login\", methods=['POST', 'GET'])\ndef login():\n    response = make_response(\"<html></html>\", 301)\n    response.headers.add_header('content-type', 'text/plain')\n    response.headers.add_header('location', './')\n    if (auth.identify(request) == True):\n        return response\n    else:\n        if request.method == \"POST\":\n            token = auth.authenticate(request.form['password'])\n            if (token != False):\n                response.set_cookie(key='Authorization', value=token)\n                return response\n        else:\n            return render_template('login.html')\n    response.headers.set('location', './login?err=\u767b\u5f55\u5931\u8d25')\n    return response", "\n\nclass HttpChannel(Channel):\n    def startup(self):\n        http_app.run(host='0.0.0.0', port=channel_conf(const.HTTP).get('port'))\n\n    def handle(self, data):\n        context = dict()\n        query = data[\"msg\"]\n        id = data[\"id\"]\n        context['from_user_id'] = str(id)\n        e_context = PluginManager().emit_event(EventContext(Event.ON_HANDLE_CONTEXT, {\n            'channel': self, 'context': query,  \"args\": context}))\n        reply = e_context['reply']\n        if not e_context.is_pass():\n            reply = super().build_reply_content(e_context[\"context\"], e_context[\"args\"])\n            e_context = PluginManager().emit_event(EventContext(Event.ON_DECORATE_REPLY, {\n                'channel': self, 'context': context, 'reply': reply, \"args\": context}))\n            reply = e_context['reply']\n        return reply\n\n    async def handle_stream(self, data):\n        context = dict()\n        id = data[\"id\"]\n        context['from_user_id'] = str(id)\n        context['stream'] = True\n        context['origin'] = data[\"msg\"]\n        e_context = PluginManager().emit_event(EventContext(Event.ON_HANDLE_CONTEXT, {\n            'channel': self, 'context': data[\"msg\"], 'reply': data[\"msg\"], \"args\": context}))\n        reply = e_context['reply']\n        if not e_context.is_pass():\n            async for final, reply in super().build_reply_stream(data[\"msg\"], context):\n                yield final, reply\n        else:\n            yield True, reply", ""]}
{"filename": "channel/slack/slack_channel.py", "chunked_list": ["import re\nfrom slack_bolt import App\nfrom slack_bolt.adapter.socket_mode import SocketModeHandler\nfrom common import const\nfrom common.log import logger\nfrom channel.channel import Channel\nfrom config import channel_conf\n\n# \u521b\u5efa Slack Bolt \u5b9e\u4f8b\napp = App(token=channel_conf(const.SLACK).get('slack_bot_token'))", "# \u521b\u5efa Slack Bolt \u5b9e\u4f8b\napp = App(token=channel_conf(const.SLACK).get('slack_bot_token'))\n\n# \u521b\u5efa SocketModeHandler \u5b9e\u4f8b\nhandler = SocketModeHandler(app=app,\n                            app_token=channel_conf(const.SLACK).get('slack_app_token'))\n\n# \u76d1\u542c Slack app_mention \u4e8b\u4ef6\n@app.event(\"app_mention\")\ndef handle_mention(event, say):\n    if 'thread_ts' in event:\n        ts = event[\"thread_ts\"]\n    else:\n        ts = event[\"ts\"]\n    reply_text = SlackChannel().handle(event)\n    say(text=f\"{reply_text}\", thread_ts=ts)", "@app.event(\"app_mention\")\ndef handle_mention(event, say):\n    if 'thread_ts' in event:\n        ts = event[\"thread_ts\"]\n    else:\n        ts = event[\"ts\"]\n    reply_text = SlackChannel().handle(event)\n    say(text=f\"{reply_text}\", thread_ts=ts)\n\nclass SlackChannel(Channel):\n    def startup(self):\n        handler.start()\n\n    def handle(self, event):\n        context = dict()\n        if 'thread_ts' in event:\n            ts = event[\"thread_ts\"]\n        else:\n            ts = event[\"ts\"]\n        context['from_user_id'] = str(ts)\n        # \u4f7f\u7528\u6b63\u5219\u8868\u8fbe\u5f0f\u53bb\u9664 @xxxx\n        plain_text = re.sub(r\"<@\\w+>\", \"\", event[\"text\"])\n        return super().build_reply_content(plain_text, context)", "\nclass SlackChannel(Channel):\n    def startup(self):\n        handler.start()\n\n    def handle(self, event):\n        context = dict()\n        if 'thread_ts' in event:\n            ts = event[\"thread_ts\"]\n        else:\n            ts = event[\"ts\"]\n        context['from_user_id'] = str(ts)\n        # \u4f7f\u7528\u6b63\u5219\u8868\u8fbe\u5f0f\u53bb\u9664 @xxxx\n        plain_text = re.sub(r\"<@\\w+>\", \"\", event[\"text\"])\n        return super().build_reply_content(plain_text, context)", ""]}
{"filename": "channel/gmail/gmail_channel.py", "chunked_list": ["import smtplib\nimport imaplib\nimport email\nimport re\nimport base64\nimport time\nfrom random import randrange\nfrom email.mime.text import MIMEText\nfrom email.header import decode_header\nfrom channel.channel import Channel", "from email.header import decode_header\nfrom channel.channel import Channel\nfrom concurrent.futures import ThreadPoolExecutor\nfrom common import const\nfrom config import channel_conf_val, channel_conf\n\n\nsmtp_ssl_host = 'smtp.gmail.com: 587'\nimap_ssl_host = 'imap.gmail.com'\nMAX_DELAY = 30", "imap_ssl_host = 'imap.gmail.com'\nMAX_DELAY = 30\nMIN_DELAY = 15\nSTEP_TIME = 2\nLATESTN = 5\nwait_time = 0\nthread_pool = ThreadPoolExecutor(max_workers=8)\n\ndef checkEmail(email):\n    # regex = '^[a-z0-9]+[\\._]?[a-z0-9]+[@]\\w+[.]\\w{2,3}$'\n    regex = r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'\n    if re.search(regex, email):\n        return True\n    else:\n        return False", "def checkEmail(email):\n    # regex = '^[a-z0-9]+[\\._]?[a-z0-9]+[@]\\w+[.]\\w{2,3}$'\n    regex = r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'\n    if re.search(regex, email):\n        return True\n    else:\n        return False\n\ndef process(max, speed):\n    global wait_time\n    i=0\n    while i<=max:\n        i=i+1\n        time.sleep(speed)\n        print(\"\\r\"+\"Waited: \"+str(i+wait_time)+\"s\", end='')\n        # print(\"\\r\"+\"===\"*int(i-1)+\":-)\"+\"===\"*int(max-i)+\"$\"+str(max)+'  waited:'+str(i)+\"%\", end='')\n    wait_time += max*speed", "def process(max, speed):\n    global wait_time\n    i=0\n    while i<=max:\n        i=i+1\n        time.sleep(speed)\n        print(\"\\r\"+\"Waited: \"+str(i+wait_time)+\"s\", end='')\n        # print(\"\\r\"+\"===\"*int(i-1)+\":-)\"+\"===\"*int(max-i)+\"$\"+str(max)+'  waited:'+str(i)+\"%\", end='')\n    wait_time += max*speed\n    \nclass GmailChannel(Channel):\n    def __init__(self):\n        self.host_email = channel_conf_val(const.GMAIL, 'host_email')\n        self.host_password = channel_conf_val(const.GMAIL, 'host_password')\n        # self.addrs_white_list = channel_conf_val(const.GMAIL, 'addrs_white_list')\n        self.subject_keyword = channel_conf_val(const.GMAIL, 'subject_keyword')\n        \n    def startup(self):\n        global wait_time\n        ques_list = list()\n        lastques = {'from': None, 'subject': None, 'content': None}\n        print(\"INFO: let's go...\")\n        while(True):\n            ques_list = self.receiveEmail()\n            if ques_list:\n                for ques in ques_list:\n                    if ques['subject'] is None:\n                        print(\"WARN: question from:%s is empty \" % ques['from'])\n                    elif(lastques['subject'] == ques['subject'] and lastques['from'] == ques['from']):\n                        print(\"INFO: this question has already been answered. Q:%s\" % (ques['subject']))\n                    else:\n                        if ques['subject']:\n                            print(\"Nice: a new message coming...\", end='\\n')\n                            self.handle(ques) \n                            lastques = ques\n                            wait_time = 0\n                        else: \n                            print(\"WARN: the question in subject is empty\")\n            else: \n                process(randrange(MIN_DELAY, MAX_DELAY), STEP_TIME)\n    \n    def handle(self, question):\n        message = dict()\n        context = dict()\n        print(\"INFO: From: %s Question: %s\" % (question['from'], question['subject']))\n        context['from_user_id'] = question['from']\n        answer = super().build_reply_content(question['subject'], context) #get answer from openai\n        message = MIMEText(answer)\n        message['subject'] = question['subject']\n        message['from'] = self.host_email\n        message['to'] = question['from']\n        thread_pool.submit(self.sendEmail, message)\n        \n    def sendEmail(self, message: list) -> dict:\n        smtp_server = smtplib.SMTP(smtp_ssl_host)\n        smtp_server.starttls()\n        smtp_server.login(self.host_email, self.host_password)\n        output = {'success': 0, 'failed': 0, 'invalid': 0}\n        try:\n            smtp_server.sendmail(message['from'], message['to'], message.as_string())\n            print(\"sending to {}\".format(message['to']))\n            output['success'] += 1\n        except Exception as e:\n            print(\"Error: {}\".format(e))\n            output['failed'] += 1\n        print(\"successed:{}, failed:{}\".format(output['success'], output['failed']))\n        smtp_server.quit()\n        return output\n\n    def receiveEmail(self):\n        question_list = list()\n        question = {'from': None, 'subject': None, 'content': None}\n        imap_server = imaplib.IMAP4_SSL(imap_ssl_host)\n        imap_server.login(self.host_email, self.host_password)\n        imap_server.select('inbox')\n        status, data = imap_server.search(None, 'ALL')\n        mail_ids = []\n        for block in data:\n            mail_ids += block.split()\n        #only fetch the latest 5 messages\n        mail_ids = mail_ids[-LATESTN:]\n        for i in mail_ids:\n            status, data = imap_server.fetch(i, '(RFC822)')\n            for response in data:\n                if isinstance(response, tuple):\n                    message = email.message_from_bytes(response[1])\n                    mail_from = message['from'].split('<')[1].replace(\">\", \"\")\n                    # if mail_from not in self.addrs_white_list:\n                    #     continue\n                    \n                    #subject do not support chinese\n                    mail_subject = decode_header(message['subject'])[0][0]\n                    if isinstance(mail_subject, bytes):\n                        # UnicodeDecodeError: 'utf-8' codec can't decode byte 0xc5\n                        try:\n                            mail_subject = mail_subject.decode()\n                        except UnicodeDecodeError:\n                            mail_subject = mail_subject.decode('latin-1')\n                    if not self.check_contain(mail_subject, self.subject_keyword):   #check subject here\n                        continue\n                    if message.is_multipart(): \n                        mail_content = ''\n                        for part in message.get_payload():\n                            flag=False\n                            if isinstance(part.get_payload(), list): \n                                    part = part.get_payload()[0]\n                                    flag = True\n                            if part.get_content_type()  in ['text/plain', 'multipart/alternative']: \n                                #TODO some string can't be decode\n                                if flag:\n                                    mail_content += str(part.get_payload())\n                                else: \n                                    try:\n                                        mail_content += base64.b64decode(str(part.get_payload())).decode(\"utf-8\")\n                                    except UnicodeDecodeError:\n                                        mail_content += base64.b64decode(str(part.get_payload())).decode('latin-1')\n                    else:\n                        mail_content = message.get_payload()\n                    question['from'] = mail_from\n                    question['subject'] = ' '.join(mail_subject.split(' ')[1:])\n                    question['content'] = mail_content\n                    # print(f'\\nFrom: {mail_from}')\n                    print(f'\\n\\nSubject: {mail_subject}')\n                    # print(f'Content: {mail_content.replace(\" \", \"\")}')\n                    question_list.append(question)\n                    question = {'from': None, 'subject': None, 'content': None}\n                    imap_server.store(i, \"+FLAGS\", \"\\\\Deleted\") #delete the mail i\n                    print(\"INFO: deleting mail: %s\" % mail_subject)\n        imap_server.expunge()\n        imap_server.close()\n        imap_server.logout()\n        return question_list\n    \n    def check_contain(self, content, keyword_list):\n        if not keyword_list:\n            return None\n        for ky in keyword_list:\n            if content.find(ky) != -1:\n                return True\n        return None ", "    \nclass GmailChannel(Channel):\n    def __init__(self):\n        self.host_email = channel_conf_val(const.GMAIL, 'host_email')\n        self.host_password = channel_conf_val(const.GMAIL, 'host_password')\n        # self.addrs_white_list = channel_conf_val(const.GMAIL, 'addrs_white_list')\n        self.subject_keyword = channel_conf_val(const.GMAIL, 'subject_keyword')\n        \n    def startup(self):\n        global wait_time\n        ques_list = list()\n        lastques = {'from': None, 'subject': None, 'content': None}\n        print(\"INFO: let's go...\")\n        while(True):\n            ques_list = self.receiveEmail()\n            if ques_list:\n                for ques in ques_list:\n                    if ques['subject'] is None:\n                        print(\"WARN: question from:%s is empty \" % ques['from'])\n                    elif(lastques['subject'] == ques['subject'] and lastques['from'] == ques['from']):\n                        print(\"INFO: this question has already been answered. Q:%s\" % (ques['subject']))\n                    else:\n                        if ques['subject']:\n                            print(\"Nice: a new message coming...\", end='\\n')\n                            self.handle(ques) \n                            lastques = ques\n                            wait_time = 0\n                        else: \n                            print(\"WARN: the question in subject is empty\")\n            else: \n                process(randrange(MIN_DELAY, MAX_DELAY), STEP_TIME)\n    \n    def handle(self, question):\n        message = dict()\n        context = dict()\n        print(\"INFO: From: %s Question: %s\" % (question['from'], question['subject']))\n        context['from_user_id'] = question['from']\n        answer = super().build_reply_content(question['subject'], context) #get answer from openai\n        message = MIMEText(answer)\n        message['subject'] = question['subject']\n        message['from'] = self.host_email\n        message['to'] = question['from']\n        thread_pool.submit(self.sendEmail, message)\n        \n    def sendEmail(self, message: list) -> dict:\n        smtp_server = smtplib.SMTP(smtp_ssl_host)\n        smtp_server.starttls()\n        smtp_server.login(self.host_email, self.host_password)\n        output = {'success': 0, 'failed': 0, 'invalid': 0}\n        try:\n            smtp_server.sendmail(message['from'], message['to'], message.as_string())\n            print(\"sending to {}\".format(message['to']))\n            output['success'] += 1\n        except Exception as e:\n            print(\"Error: {}\".format(e))\n            output['failed'] += 1\n        print(\"successed:{}, failed:{}\".format(output['success'], output['failed']))\n        smtp_server.quit()\n        return output\n\n    def receiveEmail(self):\n        question_list = list()\n        question = {'from': None, 'subject': None, 'content': None}\n        imap_server = imaplib.IMAP4_SSL(imap_ssl_host)\n        imap_server.login(self.host_email, self.host_password)\n        imap_server.select('inbox')\n        status, data = imap_server.search(None, 'ALL')\n        mail_ids = []\n        for block in data:\n            mail_ids += block.split()\n        #only fetch the latest 5 messages\n        mail_ids = mail_ids[-LATESTN:]\n        for i in mail_ids:\n            status, data = imap_server.fetch(i, '(RFC822)')\n            for response in data:\n                if isinstance(response, tuple):\n                    message = email.message_from_bytes(response[1])\n                    mail_from = message['from'].split('<')[1].replace(\">\", \"\")\n                    # if mail_from not in self.addrs_white_list:\n                    #     continue\n                    \n                    #subject do not support chinese\n                    mail_subject = decode_header(message['subject'])[0][0]\n                    if isinstance(mail_subject, bytes):\n                        # UnicodeDecodeError: 'utf-8' codec can't decode byte 0xc5\n                        try:\n                            mail_subject = mail_subject.decode()\n                        except UnicodeDecodeError:\n                            mail_subject = mail_subject.decode('latin-1')\n                    if not self.check_contain(mail_subject, self.subject_keyword):   #check subject here\n                        continue\n                    if message.is_multipart(): \n                        mail_content = ''\n                        for part in message.get_payload():\n                            flag=False\n                            if isinstance(part.get_payload(), list): \n                                    part = part.get_payload()[0]\n                                    flag = True\n                            if part.get_content_type()  in ['text/plain', 'multipart/alternative']: \n                                #TODO some string can't be decode\n                                if flag:\n                                    mail_content += str(part.get_payload())\n                                else: \n                                    try:\n                                        mail_content += base64.b64decode(str(part.get_payload())).decode(\"utf-8\")\n                                    except UnicodeDecodeError:\n                                        mail_content += base64.b64decode(str(part.get_payload())).decode('latin-1')\n                    else:\n                        mail_content = message.get_payload()\n                    question['from'] = mail_from\n                    question['subject'] = ' '.join(mail_subject.split(' ')[1:])\n                    question['content'] = mail_content\n                    # print(f'\\nFrom: {mail_from}')\n                    print(f'\\n\\nSubject: {mail_subject}')\n                    # print(f'Content: {mail_content.replace(\" \", \"\")}')\n                    question_list.append(question)\n                    question = {'from': None, 'subject': None, 'content': None}\n                    imap_server.store(i, \"+FLAGS\", \"\\\\Deleted\") #delete the mail i\n                    print(\"INFO: deleting mail: %s\" % mail_subject)\n        imap_server.expunge()\n        imap_server.close()\n        imap_server.logout()\n        return question_list\n    \n    def check_contain(self, content, keyword_list):\n        if not keyword_list:\n            return None\n        for ky in keyword_list:\n            if content.find(ky) != -1:\n                return True\n        return None ", "        \n\n\n\n\n\n\n\n", ""]}
{"filename": "channel/telegram/telegram_channel.py", "chunked_list": ["from concurrent.futures import ThreadPoolExecutor\nimport io\nimport requests\nimport telebot\nfrom common import const\nfrom common.log import logger\nfrom channel.channel import Channel\nfrom config import channel_conf_val, channel_conf\nbot = telebot.TeleBot(token=channel_conf(const.TELEGRAM).get('bot_token'))\nthread_pool = ThreadPoolExecutor(max_workers=8)", "bot = telebot.TeleBot(token=channel_conf(const.TELEGRAM).get('bot_token'))\nthread_pool = ThreadPoolExecutor(max_workers=8)\n\n@bot.message_handler(commands=['help'])\ndef send_welcome(message):\n    bot.send_message(message.chat.id, \"<a>\u6211\u662fchatGPT\u673a\u5668\u4eba\uff0c\u5f00\u59cb\u548c\u6211\u804a\u5929\u5427!</a>\", parse_mode = \"HTML\")\n\n# \u5904\u7406\u6587\u672c\u7c7b\u578b\u6d88\u606f\n@bot.message_handler(content_types=['text'])\ndef send_welcome(msg):\n    # telegram\u6d88\u606f\u5904\u7406\n    TelegramChannel().handle(msg)", "@bot.message_handler(content_types=['text'])\ndef send_welcome(msg):\n    # telegram\u6d88\u606f\u5904\u7406\n    TelegramChannel().handle(msg)\n\nclass TelegramChannel(Channel):\n    def __init__(self):\n        pass\n\n    def startup(self):\n        logger.info(\"\u5f00\u59cb\u542f\u52a8[telegram]\u673a\u5668\u4eba\")\n        bot.infinity_polling()\n\n    def handle(self, msg):\n        logger.debug(\"[Telegram] receive msg: \" + msg.text)\n        img_match_prefix = self.check_prefix(msg, channel_conf_val(const.TELEGRAM, 'image_create_prefix'))\n        # \u5982\u679c\u662f\u56fe\u7247\u8bf7\u6c42\n        if img_match_prefix:\n            thread_pool.submit(self._do_send_img, msg, str(msg.chat.id))\n        else:\n            thread_pool.submit(self._dosend,msg.text,msg)\n        \n    def _dosend(self,query,msg):\n        context= dict()\n        context['from_user_id'] = str(msg.chat.id)\n        reply_text = super().build_reply_content(query, context)\n        logger.info('[Telegram] reply content: {}'.format(reply_text))\n        bot.reply_to(msg,reply_text)\n        \n    def _do_send_img(self, msg, reply_user_id):\n        try:\n            if not msg:\n                return\n            context = dict()\n            context['type'] = 'IMAGE_CREATE'\n            img_urls = super().build_reply_content(msg.text, context)\n            if not img_urls:\n                return\n            if not isinstance(img_urls, list):\n                bot.reply_to(msg,img_urls)\n                return\n            for url in img_urls:\n            # \u56fe\u7247\u4e0b\u8f7d\n                pic_res = requests.get(url, stream=True)\n                image_storage = io.BytesIO()\n                for block in pic_res.iter_content(1024):\n                    image_storage.write(block)\n                image_storage.seek(0)\n\n                # \u56fe\u7247\u53d1\u9001\n                logger.info('[Telegrame] sendImage, receiver={}'.format(reply_user_id))\n                bot.send_photo(msg.chat.id,image_storage)\n        except Exception as e:\n            logger.exception(e)\n\n    def check_prefix(self, msg, prefix_list):\n        if not prefix_list:\n            return None\n        for prefix in prefix_list:\n            if msg.text.startswith(prefix):\n                return prefix\n        return None", ""]}
{"filename": "channel/feishu/store.py", "chunked_list": ["# -*- coding: UTF-8 -*-\n\nimport time\nfrom threading import Lock\n\n\nclass Store(object):\n    \"\"\"\n    This is an interface to storage (Key, Value) pairs for sdk.\n    \"\"\"\n\n    def get(self, key):  # type: (str) -> Tuple[bool, str]\n        return False, ''\n\n    def set(self, key, value, expire):  # type: (str, str, int) -> None\n        \"\"\"\n        storage key, value into the store, value has an expire time.(unit: second)\n        \"\"\"\n        pass", "\n\nclass ExpireValue(object):\n    def __init__(self, value, expireTime):  # type: (str, int) -> None\n        self.value = value\n        self.expireTime = expireTime\n\n\nclass MemoryStore(Store):\n    \"\"\"\n    This is an implement of `StoreInterface` which stores data in the memory\n    \"\"\"\n\n    def __init__(self):  # type: () -> None\n        self.data = {}  # type: Dict[str, ExpireValue]\n        self.mutex = Lock()  # type: Lock\n\n    def get(self, key):  # type: (str) -> Tuple[bool, str]\n        # print('get %s' % key)\n        self.mutex.acquire()\n        try:\n            val = self.data.get(key)\n            if val is None:\n                return False, \"\"\n            else:\n                if val.expireTime == -1:\n                    return True, val.value\n                elif val.expireTime < int(time.time()):\n                    self.data.pop(key)\n                    return False, \"\"\n                else:\n                    return True, val.value\n        finally:\n            self.mutex.release()\n\n    def set(self, key, value, expire=None):  # type: (str, str, int) -> None\n        # print('put %s=%s, expire=%s' % (key, value, expire))\n        \"\"\"\n        storage key, value into the store, value has an expire time.(unit: second)\n        \"\"\"\n        self.mutex.acquire()\n        try:\n            self.data[key] = ExpireValue(\n                value, expire == None and -1 or int(time.time()) + expire)\n        finally:\n            self.mutex.release()", "class MemoryStore(Store):\n    \"\"\"\n    This is an implement of `StoreInterface` which stores data in the memory\n    \"\"\"\n\n    def __init__(self):  # type: () -> None\n        self.data = {}  # type: Dict[str, ExpireValue]\n        self.mutex = Lock()  # type: Lock\n\n    def get(self, key):  # type: (str) -> Tuple[bool, str]\n        # print('get %s' % key)\n        self.mutex.acquire()\n        try:\n            val = self.data.get(key)\n            if val is None:\n                return False, \"\"\n            else:\n                if val.expireTime == -1:\n                    return True, val.value\n                elif val.expireTime < int(time.time()):\n                    self.data.pop(key)\n                    return False, \"\"\n                else:\n                    return True, val.value\n        finally:\n            self.mutex.release()\n\n    def set(self, key, value, expire=None):  # type: (str, str, int) -> None\n        # print('put %s=%s, expire=%s' % (key, value, expire))\n        \"\"\"\n        storage key, value into the store, value has an expire time.(unit: second)\n        \"\"\"\n        self.mutex.acquire()\n        try:\n            self.data[key] = ExpireValue(\n                value, expire == None and -1 or int(time.time()) + expire)\n        finally:\n            self.mutex.release()", "\n\n"]}
{"filename": "channel/feishu/feishu_channel.py", "chunked_list": ["# encoding:utf-8\nimport json\nimport hmac\nimport hashlib\nimport base64\nimport time\nimport requests\nfrom urllib.parse import quote_plus\nfrom common import log\nfrom flask import Flask, request, render_template, make_response", "from common import log\nfrom flask import Flask, request, render_template, make_response\nfrom common import const\nfrom common import functions\nfrom config import channel_conf\nfrom config import channel_conf_val\nfrom channel.channel import Channel\nfrom urllib import request as url_request\nfrom channel.feishu.store import MemoryStore\n\nclass FeiShuChannel(Channel):\n    def __init__(self):\n        self.app_id = channel_conf(\n            const.FEISHU).get('app_id')\n        self.app_secret = channel_conf(\n            const.FEISHU).get('app_secret')\n        self.verification_token = channel_conf(\n            const.FEISHU).get('verification_token')\n        log.info(\"[FeiShu] app_id={}, app_secret={} verification_token={}\".format(\n            self.app_id, self.app_secret, self.verification_token))\n        self.memory_store = MemoryStore()\n\n    def startup(self):\n        http_app.run(host='0.0.0.0', port=channel_conf(\n            const.FEISHU).get('port'))\n        \n    def get_tenant_access_token(self):\n        url = \"https://open.feishu.cn/open-apis/auth/v3/tenant_access_token/internal/\"\n        headers = {\n            \"Content-Type\": \"application/json\"\n        }\n        req_body = {\n            \"app_id\": self.app_id,\n            \"app_secret\": self.app_secret\n        }\n\n        data = bytes(json.dumps(req_body), encoding='utf8')\n        req = url_request.Request(url=url, data=data,\n                              headers=headers, method='POST')\n        try:\n            response = url_request.urlopen(req)\n        except Exception as e:\n            print(e.read().decode())\n            return \"\"\n\n        rsp_body = response.read().decode('utf-8')\n        rsp_dict = json.loads(rsp_body)\n        code = rsp_dict.get(\"code\", -1)\n        if code != 0:\n            print(\"get tenant_access_token error, code =\", code)\n            return \"\"\n        return rsp_dict.get(\"tenant_access_token\", \"\")\n\n    def notify_feishu(self, token, receive_type, receive_id, at_id, answer):\n        log.info(\"notify_feishu.receive_type = {} receive_id={}\",\n                 receive_type, receive_id)\n\n        url = \"https://open.feishu.cn/open-apis/im/v1/messages\"\n        params = {\"receive_id_type\": receive_type}\n        \n        # text = at_id and \"<at user_id=\\\"%s\\\">%s</at>\" % (\n        #     at_id, answer.lstrip()) or answer.lstrip()\n        text = answer.lstrip()\n        log.info(\"notify_feishu.text = {}\", text)\n        msgContent = {\n            \"text\": text,\n        }\n        req = {\n            \"receive_id\": receive_id,  # chat id\n            \"msg_type\": \"text\",\n            \"content\": json.dumps(msgContent),\n        }\n        payload = json.dumps(req)\n        headers = {\n            # your access token\n            \"Authorization\": \"Bearer \" + token,\n            \"Content-Type\": \"application/json\",\n        }\n        response = requests.request(\n            \"POST\", url, params=params, headers=headers, data=payload\n        )\n        log.info(\"notify_feishu.response.content = {}\", response.content)\n\n    def handle(self, message):\n        event = message[\"event\"]\n        msg = event[\"message\"]\n        messageId = msg[\"message_id\"]\n        chat_type = msg[\"chat_type\"]\n        sender_id = event[\"sender\"][\"sender_id\"][\"open_id\"]\n        \n        prompt = json.loads(msg[\"content\"])[\"text\"]\n        prompt = prompt.replace(\"@_user_1\", \"\")\n        \n        #\u91cd\u590d\n        r, v = self.memory_store.get(messageId)\n        if v:\n            return {'ret': 200}\n        \n        self.memory_store.set(messageId, True)\n        \n        # \u975e\u6587\u672c\u4e0d\u5904\u7406\n        message_type = msg[\"message_type\"]\n        if message_type != \"text\":\n            return {'ret': 200}\n        if chat_type == \"group\":\n            mentions = msg[\"mentions\"]\n            # \u65e5\u5e38\u7fa4\u6c9f\u901a\u8981@\u624d\u751f\u6548\n            if not mentions:\n                return {'ret': 200}\n            receive_type = \"chat_id\"\n            receive_id = msg.get(\"chat_id\")\n            at_id = sender_id\n        elif chat_type == \"p2p\":\n            receive_type = \"open_id\"\n            receive_id = sender_id\n            at_id = None\n\n        # \u8c03\u7528\u53d1\u6d88\u606f API \u4e4b\u524d\uff0c\u5148\u8981\u83b7\u53d6 API \u8c03\u7528\u51ed\u8bc1\uff1atenant_access_token\n        access_token = self.get_tenant_access_token()\n        if access_token == \"\":\n            log.error(\"send message access_token is empty\")\n            return {'ret': 204}\n\n        context = dict()\n        img_match_prefix = functions.check_prefix(\n            prompt, channel_conf_val(const.DINGTALK, 'image_create_prefix'))\n        if img_match_prefix:\n            prompt = prompt.split(img_match_prefix, 1)[1].strip()\n            context['type'] = 'IMAGE_CREATE'\n        context['from_user_id'] = str(sender_id)\n        reply = super().build_reply_content(prompt, context)\n        if img_match_prefix:\n            if not isinstance(reply, list):\n                return {'ret': 204}\n            images = \"\"\n            for url in reply:\n                images += f\"[!['IMAGE_CREATE']({url})]({url})\\n\"\n            reply = images\n        # \u673a\u5668\u4eba echo \u6536\u5230\u7684\u6d88\u606f\n        self.notify_feishu(access_token, receive_type,\n                           receive_id, at_id, reply)\n        return {'ret': 200}\n\n    def handle_request_url_verify(self, post_obj):\n        # \u539f\u6837\u8fd4\u56de challenge \u5b57\u6bb5\u5185\u5bb9\n        challenge = post_obj.get(\"challenge\", \"\")\n        return {'challenge': challenge}", "from channel.feishu.store import MemoryStore\n\nclass FeiShuChannel(Channel):\n    def __init__(self):\n        self.app_id = channel_conf(\n            const.FEISHU).get('app_id')\n        self.app_secret = channel_conf(\n            const.FEISHU).get('app_secret')\n        self.verification_token = channel_conf(\n            const.FEISHU).get('verification_token')\n        log.info(\"[FeiShu] app_id={}, app_secret={} verification_token={}\".format(\n            self.app_id, self.app_secret, self.verification_token))\n        self.memory_store = MemoryStore()\n\n    def startup(self):\n        http_app.run(host='0.0.0.0', port=channel_conf(\n            const.FEISHU).get('port'))\n        \n    def get_tenant_access_token(self):\n        url = \"https://open.feishu.cn/open-apis/auth/v3/tenant_access_token/internal/\"\n        headers = {\n            \"Content-Type\": \"application/json\"\n        }\n        req_body = {\n            \"app_id\": self.app_id,\n            \"app_secret\": self.app_secret\n        }\n\n        data = bytes(json.dumps(req_body), encoding='utf8')\n        req = url_request.Request(url=url, data=data,\n                              headers=headers, method='POST')\n        try:\n            response = url_request.urlopen(req)\n        except Exception as e:\n            print(e.read().decode())\n            return \"\"\n\n        rsp_body = response.read().decode('utf-8')\n        rsp_dict = json.loads(rsp_body)\n        code = rsp_dict.get(\"code\", -1)\n        if code != 0:\n            print(\"get tenant_access_token error, code =\", code)\n            return \"\"\n        return rsp_dict.get(\"tenant_access_token\", \"\")\n\n    def notify_feishu(self, token, receive_type, receive_id, at_id, answer):\n        log.info(\"notify_feishu.receive_type = {} receive_id={}\",\n                 receive_type, receive_id)\n\n        url = \"https://open.feishu.cn/open-apis/im/v1/messages\"\n        params = {\"receive_id_type\": receive_type}\n        \n        # text = at_id and \"<at user_id=\\\"%s\\\">%s</at>\" % (\n        #     at_id, answer.lstrip()) or answer.lstrip()\n        text = answer.lstrip()\n        log.info(\"notify_feishu.text = {}\", text)\n        msgContent = {\n            \"text\": text,\n        }\n        req = {\n            \"receive_id\": receive_id,  # chat id\n            \"msg_type\": \"text\",\n            \"content\": json.dumps(msgContent),\n        }\n        payload = json.dumps(req)\n        headers = {\n            # your access token\n            \"Authorization\": \"Bearer \" + token,\n            \"Content-Type\": \"application/json\",\n        }\n        response = requests.request(\n            \"POST\", url, params=params, headers=headers, data=payload\n        )\n        log.info(\"notify_feishu.response.content = {}\", response.content)\n\n    def handle(self, message):\n        event = message[\"event\"]\n        msg = event[\"message\"]\n        messageId = msg[\"message_id\"]\n        chat_type = msg[\"chat_type\"]\n        sender_id = event[\"sender\"][\"sender_id\"][\"open_id\"]\n        \n        prompt = json.loads(msg[\"content\"])[\"text\"]\n        prompt = prompt.replace(\"@_user_1\", \"\")\n        \n        #\u91cd\u590d\n        r, v = self.memory_store.get(messageId)\n        if v:\n            return {'ret': 200}\n        \n        self.memory_store.set(messageId, True)\n        \n        # \u975e\u6587\u672c\u4e0d\u5904\u7406\n        message_type = msg[\"message_type\"]\n        if message_type != \"text\":\n            return {'ret': 200}\n        if chat_type == \"group\":\n            mentions = msg[\"mentions\"]\n            # \u65e5\u5e38\u7fa4\u6c9f\u901a\u8981@\u624d\u751f\u6548\n            if not mentions:\n                return {'ret': 200}\n            receive_type = \"chat_id\"\n            receive_id = msg.get(\"chat_id\")\n            at_id = sender_id\n        elif chat_type == \"p2p\":\n            receive_type = \"open_id\"\n            receive_id = sender_id\n            at_id = None\n\n        # \u8c03\u7528\u53d1\u6d88\u606f API \u4e4b\u524d\uff0c\u5148\u8981\u83b7\u53d6 API \u8c03\u7528\u51ed\u8bc1\uff1atenant_access_token\n        access_token = self.get_tenant_access_token()\n        if access_token == \"\":\n            log.error(\"send message access_token is empty\")\n            return {'ret': 204}\n\n        context = dict()\n        img_match_prefix = functions.check_prefix(\n            prompt, channel_conf_val(const.DINGTALK, 'image_create_prefix'))\n        if img_match_prefix:\n            prompt = prompt.split(img_match_prefix, 1)[1].strip()\n            context['type'] = 'IMAGE_CREATE'\n        context['from_user_id'] = str(sender_id)\n        reply = super().build_reply_content(prompt, context)\n        if img_match_prefix:\n            if not isinstance(reply, list):\n                return {'ret': 204}\n            images = \"\"\n            for url in reply:\n                images += f\"[!['IMAGE_CREATE']({url})]({url})\\n\"\n            reply = images\n        # \u673a\u5668\u4eba echo \u6536\u5230\u7684\u6d88\u606f\n        self.notify_feishu(access_token, receive_type,\n                           receive_id, at_id, reply)\n        return {'ret': 200}\n\n    def handle_request_url_verify(self, post_obj):\n        # \u539f\u6837\u8fd4\u56de challenge \u5b57\u6bb5\u5185\u5bb9\n        challenge = post_obj.get(\"challenge\", \"\")\n        return {'challenge': challenge}", "\n\nfeishu = FeiShuChannel()\nhttp_app = Flask(__name__,)\n\n\n@http_app.route(\"/\", methods=['POST'])\ndef chat():\n    # log.info(\"[FeiShu] chat_headers={}\".format(str(request.headers)))\n    log.info(\"[FeiShu] chat={}\".format(str(request.data)))\n    obj = json.loads(request.data)\n    if not obj:\n        return {'ret': 201}\n    # \u6821\u9a8c verification token \u662f\u5426\u5339\u914d\uff0ctoken \u4e0d\u5339\u914d\u8bf4\u660e\u8be5\u56de\u8c03\u5e76\u975e\u6765\u81ea\u5f00\u53d1\u5e73\u53f0\n    headers = obj.get(\"header\")\n    if not headers:\n        return {'ret': 201}\n    token = headers.get(\"token\", \"\")\n    if token != feishu.verification_token:\n        log.error(\"verification token not match, token = {}\", token)\n        return {'ret': 201}\n\n    # \u6839\u636e type \u5904\u7406\u4e0d\u540c\u7c7b\u578b\u4e8b\u4ef6\n    t = obj.get(\"type\", \"\")\n    if \"url_verification\" == t:  # \u9a8c\u8bc1\u8bf7\u6c42 URL \u662f\u5426\u6709\u6548\n        return feishu.handle_request_url_verify(obj)\n    elif headers.get(\"event_type\", None) == \"im.message.receive_v1\":  # \u4e8b\u4ef6\u56de\u8c03\n        return feishu.handle(obj)\n    return {'ret': 202}", "    \n"]}
