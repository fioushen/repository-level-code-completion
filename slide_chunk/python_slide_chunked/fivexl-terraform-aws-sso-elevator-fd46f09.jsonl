{"filename": "src/check_python_version.py", "chunked_list": ["import json\nimport sys\n\n# Read the JSON data passed from Terraform\nraw_data = sys.stdin.read()\ndata = json.loads(raw_data)\n\nrequired_version = data[\"required_version\"]\n\n# Get the current Python version", "\n# Get the current Python version\ncurrent_version = f\"{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}\"\n\nif current_version != required_version:\n    # Write the error message to stderr\n    sys.stderr.write(\n        f\"Local python version is incorrect: {current_version}. Required version is {required_version}. Please clean 'builds', and then use docker for deployment, or destroy and re-create sso_elevator with the correct python version.\"  # noqa: E501\n    )\n    # Exit with a status code of 1, indicating failure\n    sys.exit(1)", "\nprint(json.dumps({\"current_version\": current_version}))\n"]}
{"filename": "src/main.py", "chunked_list": ["import functools\nfrom datetime import timedelta\n\nimport boto3\nfrom aws_lambda_powertools import Logger\nfrom slack_bolt import Ack, App, BoltContext\nfrom slack_bolt.adapter.aws_lambda import SlackRequestHandler\nfrom slack_sdk import WebClient\nfrom slack_sdk.web.slack_response import SlackResponse\n", "from slack_sdk.web.slack_response import SlackResponse\n\nimport access_control\nimport config\nimport entities\nimport errors\nimport organizations\nimport schedule\nimport slack_helpers\nimport sso", "import slack_helpers\nimport sso\n\nlogger = config.get_logger(service=\"main\")\n\nsession = boto3.Session()\nschedule_client = session.client(\"scheduler\")\norg_client = session.client(\"organizations\")\nsso_client = session.client(\"sso-admin\")\n", "sso_client = session.client(\"sso-admin\")\n\ncfg = config.get_config()\napp = App(\n    process_before_response=True,\n    logger=config.get_logger(service=\"slack\", level=cfg.slack_app_log_level),\n)\n\n\ndef lambda_handler(event: str, context):  # noqa: ANN001, ANN201", "\ndef lambda_handler(event: str, context):  # noqa: ANN001, ANN201\n    slack_handler = SlackRequestHandler(app=app)\n    return slack_handler.handle(event, context)\n\n\ndef error_handler(client: WebClient, e: Exception, logger: Logger, context: BoltContext) -> None:\n    logger.exception(e)\n    if isinstance(e, errors.ConfigurationError):\n        text = f\"<@{context['user_id']}> Your request for AWS permissions failed with error: {e}. Check logs for more details.\"", "    if isinstance(e, errors.ConfigurationError):\n        text = f\"<@{context['user_id']}> Your request for AWS permissions failed with error: {e}. Check logs for more details.\"\n        client.chat_postMessage(text=text, channel=cfg.slack_channel_id)\n    else:\n        text = f\"<@{context['user_id']}> Your request for AWS permissions failed with error. Check access-requester logs for more details.\"\n        client.chat_postMessage(text=text, channel=cfg.slack_channel_id)\n\n\ndef handle_errors(fn):  # noqa: ANN001, ANN201\n    # Default slack error handler (app.error) does not handle all exceptions. Or at least I did not find how to do it.", "def handle_errors(fn):  # noqa: ANN001, ANN201\n    # Default slack error handler (app.error) does not handle all exceptions. Or at least I did not find how to do it.\n    # So I created this error handler.\n    @functools.wraps(fn)\n    def wrapper(*args, **kwargs):  # noqa: ANN002, ANN003, ANN202\n        try:\n            return fn(*args, **kwargs)\n        except Exception as e:\n            client: WebClient = kwargs[\"client\"]\n            context: BoltContext = kwargs[\"context\"]", "            client: WebClient = kwargs[\"client\"]\n            context: BoltContext = kwargs[\"context\"]\n            error_handler(client=client, e=e, logger=logger, context=context)\n\n    return wrapper\n\n\ntrigger_view_map = {}\n# To update the view, it is necessary to know the view_id. It is returned when the view is opened.\n# But shortcut 'request_for_access' handled by two functions. The first one opens the view and the second one updates it.", "# To update the view, it is necessary to know the view_id. It is returned when the view is opened.\n# But shortcut 'request_for_access' handled by two functions. The first one opens the view and the second one updates it.\n# So we need to store the view_id somewhere. Since the trigger_id is unique for each request,\n# and available in both functions, we can use it as a key. The value is the view_id.\n\n\ndef show_initial_form(client: WebClient, body: dict, ack: Ack) -> SlackResponse:\n    ack()\n    logger.info(\"Showing initial form\")\n    logger.debug(\"Request body\", extra={\"body\": body})", "    logger.info(\"Showing initial form\")\n    logger.debug(\"Request body\", extra={\"body\": body})\n    trigger_id = body[\"trigger_id\"]\n    response = client.views_open(trigger_id=trigger_id, view=slack_helpers.RequestForAccessView.build())\n    trigger_view_map[trigger_id] = response.data[\"view\"][\"id\"]  # type: ignore # noqa: PGH003\n    return response\n\n\ndef load_select_options(client: WebClient, body: dict) -> SlackResponse:\n    logger.info(\"Loading select options for view (accounts and permission sets)\")", "def load_select_options(client: WebClient, body: dict) -> SlackResponse:\n    logger.info(\"Loading select options for view (accounts and permission sets)\")\n    logger.debug(\"Request body\", extra={\"body\": body})\n\n    accounts = organizations.get_accounts_from_config(client=org_client, cfg=cfg)\n    permission_sets = sso.get_permission_sets_from_config(client=sso_client, cfg=cfg)\n    trigger_id = body[\"trigger_id\"]\n\n    view = slack_helpers.RequestForAccessView.update_with_accounts_and_permission_sets(accounts=accounts, permission_sets=permission_sets)\n    return client.views_update(view_id=trigger_view_map[trigger_id], view=view)", "    view = slack_helpers.RequestForAccessView.update_with_accounts_and_permission_sets(accounts=accounts, permission_sets=permission_sets)\n    return client.views_update(view_id=trigger_view_map[trigger_id], view=view)\n\n\napp.shortcut(\"request_for_access\")(\n    show_initial_form,\n    load_select_options,\n)\n\n", "\n\ncache_for_dublicate_requests = {}\n\n\n@handle_errors\ndef handle_button_click(body: dict, client: WebClient, context: BoltContext) -> SlackResponse:  # noqa: ARG001\n    logger.info(\"Handling button click\")\n    payload = slack_helpers.ButtonClickedPayload.parse_obj(body)\n    logger.info(\"Button click payload\", extra={\"payload\": payload})", "    payload = slack_helpers.ButtonClickedPayload.parse_obj(body)\n    logger.info(\"Button click payload\", extra={\"payload\": payload})\n    approver = slack_helpers.get_user(client, id=payload.approver_slack_id)\n    requester = slack_helpers.get_user(client, id=payload.request.requester_slack_id)\n\n\n    if (cache_for_dublicate_requests.get(\"requester_slack_id\") == payload.request.requester_slack_id\n    and cache_for_dublicate_requests.get(\"account_id\") == payload.request.account_id\n    and cache_for_dublicate_requests.get(\"permission_set_name\") == payload.request.permission_set_name):\n        return client.chat_postMessage(", "    and cache_for_dublicate_requests.get(\"permission_set_name\") == payload.request.permission_set_name):\n        return client.chat_postMessage(\n            channel=payload.channel_id,\n            text=f\"<@{approver.id}> request is already in progress, please wait for the result.\",\n            thread_ts=payload.thread_ts,\n        )\n    cache_for_dublicate_requests[\"requester_slack_id\"] = payload.request.requester_slack_id\n    cache_for_dublicate_requests[\"account_id\"] = payload.request.account_id\n    cache_for_dublicate_requests[\"permission_set_name\"] = payload.request.permission_set_name\n", "    cache_for_dublicate_requests[\"permission_set_name\"] = payload.request.permission_set_name\n\n    if payload.action == entities.ApproverAction.Discard:\n        slack_helpers.remove_buttons(payload, client, approver)\n        cache_for_dublicate_requests.clear()\n        return client.chat_postMessage(\n            channel=payload.channel_id,\n            text=f\"Request was discarded by<@{approver.id}> \",\n            thread_ts=payload.thread_ts,\n        )", "            thread_ts=payload.thread_ts,\n        )\n\n    decision = access_control.make_decision_on_approve_request(\n        action=payload.action,\n        statements=cfg.statements,\n        account_id=payload.request.account_id,\n        permission_set_name=payload.request.permission_set_name,\n        approver_email=approver.email,\n        requester_email=requester.email,", "        approver_email=approver.email,\n        requester_email=requester.email,\n    )\n    logger.info(\"Decision on request was made\", extra={\"decision\": decision})\n\n    if not decision.permit:\n        cache_for_dublicate_requests.clear()\n        return client.chat_postMessage(\n            channel=payload.channel_id,\n            text=f\"<@{approver.id}> you can not approve this request\",", "            channel=payload.channel_id,\n            text=f\"<@{approver.id}> you can not approve this request\",\n            thread_ts=payload.thread_ts,\n        )\n    slack_helpers.remove_buttons(payload, client, approver)\n\n    access_control.execute_decision(\n        decision=decision,\n        permission_set_name=payload.request.permission_set_name,\n        account_id=payload.request.account_id,", "        permission_set_name=payload.request.permission_set_name,\n        account_id=payload.request.account_id,\n        permission_duration=payload.request.permission_duration,\n        approver=approver,\n        requester=requester,\n        reason=payload.request.reason,\n    )\n    cache_for_dublicate_requests.clear()\n    return client.chat_postMessage(\n        channel=payload.channel_id,", "    return client.chat_postMessage(\n        channel=payload.channel_id,\n        text=f\"Permissions granted to <@{requester.id}> by <@{approver.id}>.\",\n        thread_ts=payload.thread_ts,\n    )\n\n\ndef acknowledge_request(ack: Ack):  # noqa: ANN201\n    ack()\n", "    ack()\n\n\napp.action(entities.ApproverAction.Approve.value)(\n    ack=acknowledge_request,\n    lazy=[handle_button_click],\n)\n\napp.action(entities.ApproverAction.Discard.value)(\n    ack=acknowledge_request,", "app.action(entities.ApproverAction.Discard.value)(\n    ack=acknowledge_request,\n    lazy=[handle_button_click],\n)\n\n\n@handle_errors\ndef handle_request_for_access_submittion(\n    body: dict,\n    ack: Ack,  # noqa: ARG001", "    body: dict,\n    ack: Ack,  # noqa: ARG001\n    client: WebClient,\n    context: BoltContext,  # noqa: ARG001\n) -> SlackResponse | None:\n    logger.info(\"Handling request for access submittion\")\n    request = slack_helpers.RequestForAccessView.parse(body)\n    logger.info(\"View submitted\", extra={\"view\": request})\n    requester = slack_helpers.get_user(client, id=request.requester_slack_id)\n    decision = access_control.make_decision_on_access_request(", "    requester = slack_helpers.get_user(client, id=request.requester_slack_id)\n    decision = access_control.make_decision_on_access_request(\n        cfg.statements,\n        account_id=request.account_id,\n        permission_set_name=request.permission_set_name,\n        requester_email=requester.email,\n    )\n    logger.info(\"Decision on request was made\", extra={\"decision\": decision})\n\n    account = organizations.describe_account(org_client, request.account_id)", "\n    account = organizations.describe_account(org_client, request.account_id)\n\n    show_buttons = bool(decision.approvers)\n    slack_response = client.chat_postMessage(\n        blocks=slack_helpers.build_approval_request_message_blocks(\n            requester_slack_id=request.requester_slack_id,\n            account=account,\n            role_name=request.permission_set_name,\n            reason=request.reason,", "            role_name=request.permission_set_name,\n            reason=request.reason,\n            permission_duration=request.permission_duration,\n            show_buttons=show_buttons,\n        ),\n        channel=cfg.slack_channel_id,\n        text=f\"Request for access to {account.name} account from {requester.real_name}\",\n    )\n\n    if show_buttons:", "\n    if show_buttons:\n        ts = slack_response[\"ts\"]\n        if ts is not None:\n            schedule.schedule_discard_buttons_event(\n                schedule_client=schedule_client,\n                time_stamp=ts,\n                channel_id=cfg.slack_channel_id,\n            )\n            schedule.schedule_approver_notification_event(", "            )\n            schedule.schedule_approver_notification_event(\n                schedule_client=schedule_client,\n                message_ts=ts,\n                channel_id=cfg.slack_channel_id,\n                time_to_wait=timedelta(minutes=cfg.approver_renotification_initial_wait_time,)\n            )\n\n    match decision.reason:\n        case access_control.DecisionReason.ApprovalNotRequired:", "    match decision.reason:\n        case access_control.DecisionReason.ApprovalNotRequired:\n            text = \"Approval for this Permission Set & Account is not required. Request will be approved automatically.\"\n        case access_control.DecisionReason.SelfApproval:\n            text = \"Self approval is allowed and requester is an approver. Request will be approved automatically.\"\n        case access_control.DecisionReason.RequiresApproval:\n            approvers = [slack_helpers.get_user_by_email(client, email) for email in decision.approvers]\n            mention_approvers = \" \".join(f\"<@{approver.id}>\" for approver in approvers)\n            text = f\"{mention_approvers} there is a request waiting for the approval.\"\n        case access_control.DecisionReason.NoApprovers:", "            text = f\"{mention_approvers} there is a request waiting for the approval.\"\n        case access_control.DecisionReason.NoApprovers:\n            text = \"Nobody can approve this request.\"\n        case access_control.DecisionReason.NoStatements:\n            text = \"There are no statements for this Permission Set & Account.\"\n\n    client.chat_postMessage(text=text, thread_ts=slack_response[\"ts\"], channel=cfg.slack_channel_id)\n\n    access_control.execute_decision(\n        decision=decision,", "    access_control.execute_decision(\n        decision=decision,\n        permission_set_name=request.permission_set_name,\n        account_id=request.account_id,\n        permission_duration=request.permission_duration,\n        approver=requester,\n        requester=requester,\n        reason=request.reason,\n    )\n", "    )\n\n    if decision.grant:\n        return client.chat_postMessage(\n            channel=cfg.slack_channel_id,\n            text=f\"Permissions granted to <@{requester.id}>\",\n            thread_ts=slack_response[\"ts\"],\n        )\n\n", "\n\napp.view(slack_helpers.RequestForAccessView.CALLBACK_ID)(\n    ack=acknowledge_request,\n    lazy=[handle_request_for_access_submittion],\n)\n\n\n@app.action(\"duration_picker_action\")\ndef handle_duration_picker_action(ack):  # noqa: ANN201, ANN001", "@app.action(\"duration_picker_action\")\ndef handle_duration_picker_action(ack):  # noqa: ANN201, ANN001\n    ack()\n"]}
{"filename": "src/events.py", "chunked_list": ["from datetime import timedelta\nfrom typing import Literal\n\nfrom pydantic import Field, root_validator\n\nimport entities\nimport sso\nfrom entities.model import BaseModel\n\n\nclass RevokeEvent(BaseModel):\n    schedule_name: str\n    approver: entities.slack.User\n    requester: entities.slack.User\n    user_account_assignment: sso.UserAccountAssignment\n    permission_duration: timedelta", "\n\nclass RevokeEvent(BaseModel):\n    schedule_name: str\n    approver: entities.slack.User\n    requester: entities.slack.User\n    user_account_assignment: sso.UserAccountAssignment\n    permission_duration: timedelta\n\n\nclass ScheduledRevokeEvent(BaseModel):\n    action: Literal[\"event_bridge_revoke\"]\n    revoke_event: RevokeEvent\n\n    @root_validator(pre=True)\n    def validate_payload(cls, values: dict) -> dict:  # noqa: ANN101\n        values[\"revoke_event\"] = RevokeEvent.parse_raw(values[\"revoke_event\"])\n        return values", "\n\nclass ScheduledRevokeEvent(BaseModel):\n    action: Literal[\"event_bridge_revoke\"]\n    revoke_event: RevokeEvent\n\n    @root_validator(pre=True)\n    def validate_payload(cls, values: dict) -> dict:  # noqa: ANN101\n        values[\"revoke_event\"] = RevokeEvent.parse_raw(values[\"revoke_event\"])\n        return values", "\n\nclass DiscardButtonsEvent(BaseModel):\n    action: Literal[\"discard_buttons_event\"]\n    schedule_name: str\n    time_stamp: str\n    channel_id: str\n\n\nclass CheckOnInconsistency(BaseModel):\n    action: Literal[\"check_on_inconsistency\"]", "\nclass CheckOnInconsistency(BaseModel):\n    action: Literal[\"check_on_inconsistency\"]\n\n\nclass SSOElevatorScheduledRevocation(BaseModel):\n    action: Literal[\"sso_elevator_scheduled_revocation\"]\n\n\nclass ApproverNotificationEvent(BaseModel):\n    action: Literal[\"approvers_renotification\"]\n    schedule_name: str\n    time_stamp: str\n    channel_id: str\n    time_to_wait_in_seconds: float", "\nclass ApproverNotificationEvent(BaseModel):\n    action: Literal[\"approvers_renotification\"]\n    schedule_name: str\n    time_stamp: str\n    channel_id: str\n    time_to_wait_in_seconds: float\n\n\nclass Event(BaseModel):\n    __root__: (\n        ScheduledRevokeEvent |\n        DiscardButtonsEvent |\n        CheckOnInconsistency |\n        SSOElevatorScheduledRevocation |\n        ApproverNotificationEvent\n    ) = Field(\n        ..., discriminator=\"action\"\n    )", "\nclass Event(BaseModel):\n    __root__: (\n        ScheduledRevokeEvent |\n        DiscardButtonsEvent |\n        CheckOnInconsistency |\n        SSOElevatorScheduledRevocation |\n        ApproverNotificationEvent\n    ) = Field(\n        ..., discriminator=\"action\"\n    )", ""]}
{"filename": "src/revoker.py", "chunked_list": ["from datetime import datetime, timedelta\n\nimport boto3\nimport slack_sdk\nfrom mypy_boto3_events import EventBridgeClient\nfrom mypy_boto3_identitystore import IdentityStoreClient\nfrom mypy_boto3_organizations import OrganizationsClient\nfrom mypy_boto3_scheduler import EventBridgeSchedulerClient\nfrom mypy_boto3_sso_admin import SSOAdminClient\nfrom pydantic import ValidationError", "from mypy_boto3_sso_admin import SSOAdminClient\nfrom pydantic import ValidationError\nfrom slack_sdk.web.slack_response import SlackResponse\n\nimport config\nimport entities\nimport organizations\nimport s3\nimport schedule\nimport slack_helpers", "import schedule\nimport slack_helpers\nimport sso\nfrom events import (\n    ApproverNotificationEvent,\n    CheckOnInconsistency,\n    DiscardButtonsEvent,\n    Event,\n    RevokeEvent,\n    ScheduledRevokeEvent,", "    RevokeEvent,\n    ScheduledRevokeEvent,\n    SSOElevatorScheduledRevocation,\n)\n\nlogger = config.get_logger(service=\"revoker\")\n\ncfg = config.get_config()\norg_client = boto3.client(\"organizations\")\nsso_client = boto3.client(\"sso-admin\")", "org_client = boto3.client(\"organizations\")\nsso_client = boto3.client(\"sso-admin\")\nidentitystore_client = boto3.client(\"identitystore\")\nscheduler_client = boto3.client(\"scheduler\")\nevents_client = boto3.client(\"events\")\nslack_client = slack_sdk.WebClient(token=cfg.slack_bot_token)\n\n\ndef lambda_handler(event: dict, __) -> SlackResponse | None:  # type: ignore # noqa: ANN001, PGH003\n    try:", "def lambda_handler(event: dict, __) -> SlackResponse | None:  # type: ignore # noqa: ANN001, PGH003\n    try:\n        parsed_event = Event.parse_obj(event).__root__\n    except ValidationError as e:\n        logger.warning(\"Got unexpected event:\", extra={\"event\": event, \"exception\": e})\n        raise e\n\n    match parsed_event:\n        case ScheduledRevokeEvent():\n            logger.info(\"Handling ScheduledRevokeEvent\", extra={\"event\": parsed_event})", "        case ScheduledRevokeEvent():\n            logger.info(\"Handling ScheduledRevokeEvent\", extra={\"event\": parsed_event})\n\n            return handle_scheduled_account_assignment_deletion(\n                revoke_event=parsed_event.revoke_event,\n                sso_client=sso_client,\n                cfg=cfg,\n                scheduler_client=scheduler_client,\n                org_client=org_client,\n                slack_client=slack_client,", "                org_client=org_client,\n                slack_client=slack_client,\n                identitystore_client=identitystore_client,\n            )\n\n        case DiscardButtonsEvent():\n            logger.info(\"Handling DiscardButtonsEvent\", extra={\"event\": parsed_event})\n            handle_discard_buttons_event(event=parsed_event, slack_client=slack_client, scheduler_client=scheduler_client)\n            return\n", "            return\n\n        case CheckOnInconsistency():\n            logger.info(\"Handling CheckOnInconsistency event\", extra={\"event\": parsed_event})\n\n            return handle_check_on_inconsistency(\n                sso_client=sso_client,\n                cfg=cfg,\n                scheduler_client=scheduler_client,\n                org_client=org_client,", "                scheduler_client=scheduler_client,\n                org_client=org_client,\n                slack_client=slack_client,\n                identitystore_client=identitystore_client,\n                events_client=events_client,\n            )\n\n        case SSOElevatorScheduledRevocation():\n            logger.info(\"Handling SSOElevatorScheduledRevocation event\", extra={\"event\": parsed_event})\n            return handle_sso_elevator_scheduled_revocation(", "            logger.info(\"Handling SSOElevatorScheduledRevocation event\", extra={\"event\": parsed_event})\n            return handle_sso_elevator_scheduled_revocation(\n                sso_client=sso_client,\n                cfg=cfg,\n                scheduler_client=scheduler_client,\n                org_client=org_client,\n                slack_client=slack_client,\n                identitystore_client=identitystore_client,\n            )\n        case ApproverNotificationEvent():", "            )\n        case ApproverNotificationEvent():\n            logger.info(\"Handling ApproverNotificationEvent event\", extra={\"event\": parsed_event})\n            return handle_approvers_renotification_event(\n                event = parsed_event,\n                slack_client=slack_client,\n                scheduler_client=scheduler_client,\n            )\n\n", "\n\ndef handle_account_assignment_deletion(  # noqa: PLR0913\n    account_assignment: sso.UserAccountAssignment,\n    cfg: config.Config,\n    sso_client: SSOAdminClient,\n    org_client: OrganizationsClient,\n    slack_client: slack_sdk.WebClient,\n    identitystore_client: IdentityStoreClient,\n) -> SlackResponse | None:", "    identitystore_client: IdentityStoreClient,\n) -> SlackResponse | None:\n    logger.info(\"Handling account assignment deletion\", extra={\"account_assignment\": account_assignment})\n\n    assignment_status = sso.delete_account_assignment_and_wait_for_result(\n        sso_client,\n        account_assignment,\n    )\n\n    permission_set = sso.describe_permission_set(", "\n    permission_set = sso.describe_permission_set(\n        sso_client,\n        account_assignment.instance_arn,\n        account_assignment.permission_set_arn,\n    )\n\n    s3.log_operation(\n        s3.AuditEntry(\n            role_name=permission_set.name,", "        s3.AuditEntry(\n            role_name=permission_set.name,\n            account_id=account_assignment.account_id,\n            reason=\"automated revocation\",\n            requester_slack_id=\"NA\",\n            requester_email=\"NA\",\n            request_id=assignment_status.request_id,\n            approver_slack_id=\"NA\",\n            approver_email=\"NA\",\n            operation_type=\"revoke\",", "            approver_email=\"NA\",\n            operation_type=\"revoke\",\n            permission_duration=\"NA\",\n        ),\n    )\n\n    if cfg.post_update_to_slack:\n        account = organizations.describe_account(org_client, account_assignment.account_id)\n        return slack_notify_user_on_revoke(\n            cfg=cfg,", "        return slack_notify_user_on_revoke(\n            cfg=cfg,\n            account_assignment=account_assignment,\n            permission_set=permission_set,\n            account=account,\n            sso_client=sso_client,\n            identitystore_client=identitystore_client,\n            slack_client=slack_client,\n        )\n", "        )\n\n\ndef slack_notify_user_on_revoke(  # noqa: PLR0913\n    cfg: config.Config,\n    account_assignment: sso.AccountAssignment | sso.UserAccountAssignment,\n    permission_set: entities.aws.PermissionSet,\n    account: entities.aws.Account,\n    sso_client: SSOAdminClient,\n    identitystore_client: IdentityStoreClient,", "    sso_client: SSOAdminClient,\n    identitystore_client: IdentityStoreClient,\n    slack_client: slack_sdk.WebClient,\n) -> SlackResponse:\n    mention = slack_helpers.create_slack_mention_by_principal_id(\n        account_assignment=account_assignment,\n        sso_client=sso_client,\n        cfg=cfg,\n        identitystore_client=identitystore_client,\n        slack_client=slack_client,", "        identitystore_client=identitystore_client,\n        slack_client=slack_client,\n    )\n    return slack_client.chat_postMessage(\n        channel=cfg.slack_channel_id,\n        text=f\"Revoked role {permission_set.name} for user {mention} in account {account.name}\",\n    )\n\n\ndef handle_scheduled_account_assignment_deletion(  # noqa: PLR0913", "\ndef handle_scheduled_account_assignment_deletion(  # noqa: PLR0913\n    revoke_event: RevokeEvent,\n    sso_client: SSOAdminClient,\n    cfg: config.Config,\n    scheduler_client: EventBridgeSchedulerClient,\n    org_client: OrganizationsClient,\n    slack_client: slack_sdk.WebClient,\n    identitystore_client: IdentityStoreClient,\n) -> SlackResponse | None:", "    identitystore_client: IdentityStoreClient,\n) -> SlackResponse | None:\n    logger.info(\"Handling scheduled account assignment deletion\", extra={\"revoke_event\": revoke_event})\n\n    user_account_assignment = revoke_event.user_account_assignment\n    assignment_status = sso.delete_account_assignment_and_wait_for_result(\n        sso_client,\n        user_account_assignment,\n    )\n    permission_set = sso.describe_permission_set(", "    )\n    permission_set = sso.describe_permission_set(\n        sso_client,\n        sso_instance_arn=user_account_assignment.instance_arn,\n        permission_set_arn=user_account_assignment.permission_set_arn,\n    )\n\n    s3.log_operation(\n        s3.AuditEntry(\n            role_name=permission_set.name,", "        s3.AuditEntry(\n            role_name=permission_set.name,\n            account_id=user_account_assignment.account_id,\n            reason=\"scheduled_revocation\",\n            requester_slack_id=revoke_event.requester.id,\n            requester_email=revoke_event.requester.email,\n            request_id=assignment_status.request_id,\n            approver_slack_id=revoke_event.approver.id,\n            approver_email=revoke_event.approver.email,\n            operation_type=\"revoke\",", "            approver_email=revoke_event.approver.email,\n            operation_type=\"revoke\",\n            permission_duration=revoke_event.permission_duration,\n        ),\n    )\n    schedule.delete_schedule(scheduler_client, revoke_event.schedule_name)\n\n    if cfg.post_update_to_slack:\n        account = organizations.describe_account(org_client, user_account_assignment.account_id)\n        slack_notify_user_on_revoke(", "        account = organizations.describe_account(org_client, user_account_assignment.account_id)\n        slack_notify_user_on_revoke(\n            cfg=cfg,\n            account_assignment=user_account_assignment,\n            permission_set=permission_set,\n            account=account,\n            sso_client=sso_client,\n            identitystore_client=identitystore_client,\n            slack_client=slack_client,\n        )", "            slack_client=slack_client,\n        )\n\n\ndef handle_check_on_inconsistency(  # noqa: PLR0913\n    sso_client: SSOAdminClient,\n    cfg: config.Config,\n    scheduler_client: EventBridgeSchedulerClient,\n    org_client: OrganizationsClient,\n    slack_client: slack_sdk.WebClient,", "    org_client: OrganizationsClient,\n    slack_client: slack_sdk.WebClient,\n    identitystore_client: IdentityStoreClient,\n    events_client: EventBridgeClient,\n) -> None:\n    account_assignments = sso.get_account_assignment_information(sso_client, cfg, org_client)\n    scheduled_revoke_events = schedule.get_scheduled_events(scheduler_client)\n    account_assignments_from_events = [\n        sso.AccountAssignment(\n            permission_set_arn=scheduled_event.revoke_event.user_account_assignment.permission_set_arn,", "        sso.AccountAssignment(\n            permission_set_arn=scheduled_event.revoke_event.user_account_assignment.permission_set_arn,\n            account_id=scheduled_event.revoke_event.user_account_assignment.account_id,\n            principal_id=scheduled_event.revoke_event.user_account_assignment.user_principal_id,\n            principal_type=\"USER\",\n        )\n        for scheduled_event in scheduled_revoke_events\n    ]\n\n    for account_assignment in account_assignments:", "\n    for account_assignment in account_assignments:\n        if account_assignment not in account_assignments_from_events:\n            account = organizations.describe_account(org_client, account_assignment.account_id)\n            logger.warning(\"Found an inconsistent account assignment\", extra={\"account_assignment\": account_assignment})\n            mention = slack_helpers.create_slack_mention_by_principal_id(\n                account_assignment=account_assignment,\n                sso_client=sso_client,\n                cfg=cfg,\n                identitystore_client=identitystore_client,", "                cfg=cfg,\n                identitystore_client=identitystore_client,\n                slack_client=slack_client,\n            )\n            rule = schedule.get_event_brige_rule(\n                event_brige_client=events_client, rule_name=cfg.sso_elevator_scheduled_revocation_rule_name\n            )\n            next_run_time_or_expression = schedule.check_rule_expression_and_get_next_run(rule)\n            time_notice = \"\"\n            if isinstance(next_run_time_or_expression, datetime):", "            time_notice = \"\"\n            if isinstance(next_run_time_or_expression, datetime):\n                time_notice = f\" The next scheduled revocation is set for {next_run_time_or_expression}.\"\n            elif isinstance(next_run_time_or_expression, str):\n                time_notice = f\" The revocation schedule is set as: {next_run_time_or_expression}.\"  # noqa: Q000\n\n            slack_client.chat_postMessage(\n                channel=cfg.slack_channel_id,\n                text=(\n                    f\"Inconsistent account assignment detected in {account.name}-{account.id} for {mention}. \"", "                text=(\n                    f\"Inconsistent account assignment detected in {account.name}-{account.id} for {mention}. \"\n                    f\"The unidentified assignment will be automatically revoked.{time_notice}\"\n                ),\n            )\n\n\ndef handle_sso_elevator_scheduled_revocation(  # noqa: PLR0913\n    sso_client: SSOAdminClient,\n    cfg: config.Config,", "    sso_client: SSOAdminClient,\n    cfg: config.Config,\n    scheduler_client: EventBridgeSchedulerClient,\n    org_client: OrganizationsClient,\n    slack_client: slack_sdk.WebClient,\n    identitystore_client: IdentityStoreClient,\n) -> None:\n    account_assignments = sso.get_account_assignment_information(sso_client, cfg, org_client)\n    scheduled_revoke_events = schedule.get_scheduled_events(scheduler_client)\n    sso_instance = sso.describe_sso_instance(sso_client, cfg.sso_instance_arn)", "    scheduled_revoke_events = schedule.get_scheduled_events(scheduler_client)\n    sso_instance = sso.describe_sso_instance(sso_client, cfg.sso_instance_arn)\n    account_assignments_from_events = [\n        sso.AccountAssignment(\n            permission_set_arn=scheduled_event.revoke_event.user_account_assignment.permission_set_arn,\n            account_id=scheduled_event.revoke_event.user_account_assignment.account_id,\n            principal_id=scheduled_event.revoke_event.user_account_assignment.user_principal_id,\n            principal_type=\"USER\",\n        )\n        for scheduled_event in scheduled_revoke_events", "        )\n        for scheduled_event in scheduled_revoke_events\n    ]\n    for account_assignment in account_assignments:\n        if account_assignment in account_assignments_from_events:\n            logger.info(\n                \"Account assignment already scheduled for revocation. Skipping.\",\n                extra={\"account_assignment\": account_assignment},\n            )\n            continue", "            )\n            continue\n        else:\n            handle_account_assignment_deletion(\n                account_assignment=sso.UserAccountAssignment(\n                    account_id=account_assignment.account_id,\n                    permission_set_arn=account_assignment.permission_set_arn,\n                    user_principal_id=account_assignment.principal_id,\n                    instance_arn=sso_instance.arn,\n                ),", "                    instance_arn=sso_instance.arn,\n                ),\n                sso_client=sso_client,\n                org_client=org_client,\n                slack_client=slack_client,\n                identitystore_client=identitystore_client,\n                cfg=cfg,\n            )\n\n", "\n\ndef handle_discard_buttons_event(\n    event: DiscardButtonsEvent, slack_client: slack_sdk.WebClient, scheduler_client: EventBridgeSchedulerClient\n) -> None:\n    message = slack_helpers.get_message_from_timestamp(\n        channel_id=event.channel_id,\n        message_ts=event.time_stamp,\n        slack_client=slack_client,\n    )", "        slack_client=slack_client,\n    )\n    schedule.delete_schedule(scheduler_client, event.schedule_name)\n    if message is None:\n        logger.warning(\"Message was not found\", extra={\"event\": event})\n        return\n\n    for block in message[\"blocks\"]:\n        if slack_helpers.get_block_id(block) == \"buttons\":\n            blocks = slack_helpers.remove_blocks(message[\"blocks\"], block_ids=[\"buttons\"])", "        if slack_helpers.get_block_id(block) == \"buttons\":\n            blocks = slack_helpers.remove_blocks(message[\"blocks\"], block_ids=[\"buttons\"])\n            blocks.append(\n                slack_helpers.SectionBlock(\n                    block_id=\"footer\",\n                    text=slack_helpers.MarkdownTextObject(\n                        text=f\"Request expired after {cfg.request_expiration_hours} hour(s).\",\n                    ),\n                )\n            )", "                )\n            )\n            slack_client.chat_update(\n                channel=event.channel_id,\n                ts=message[\"ts\"],\n                blocks=blocks,\n                text=\"Request expired\",\n            )\n            logger.info(\"Buttons were removed\", extra={\"event\": event})\n            return", "            logger.info(\"Buttons were removed\", extra={\"event\": event})\n            return\n\n    logger.info(\"Buttons were not found\", extra={\"event\": event})\n\n\n\ndef handle_approvers_renotification_event(\n    event: ApproverNotificationEvent, slack_client: slack_sdk.WebClient, scheduler_client: EventBridgeSchedulerClient\n) -> None:", "    event: ApproverNotificationEvent, slack_client: slack_sdk.WebClient, scheduler_client: EventBridgeSchedulerClient\n) -> None:\n\n    message = slack_helpers.get_message_from_timestamp(\n        channel_id=event.channel_id,\n        message_ts=event.time_stamp,\n        slack_client=slack_client,\n    )\n    schedule.delete_schedule(scheduler_client, event.schedule_name)\n    if message is None:", "    schedule.delete_schedule(scheduler_client, event.schedule_name)\n    if message is None:\n        logger.warning(\"Message not found\", extra={\"event\": event})\n        return\n\n    for block in message[\"blocks\"]:\n        if slack_helpers.get_block_id(block) == \"buttons\":\n            time_to_wait = timedelta(seconds=event.time_to_wait_in_seconds)\n            if cfg.approver_renotification_backoff_multiplier != 0:\n                time_to_wait = time_to_wait * cfg.approver_renotification_backoff_multiplier", "            if cfg.approver_renotification_backoff_multiplier != 0:\n                time_to_wait = time_to_wait * cfg.approver_renotification_backoff_multiplier\n            slack_response = slack_client.chat_postMessage(\n                channel=event.channel_id,\n                thread_ts=message[\"ts\"],\n                text=\"The request is still awaiting approval. The next reminder will be \"\n                    f\"sent in {time_to_wait}, unless the request is approved or \"\n                    \"discarded beforehand.\",\n            )\n            logger.info(\"Notifications to approvers were sent.\")", "            )\n            logger.info(\"Notifications to approvers were sent.\")\n            logger.debug(\"Slack response:\", extra={\"slack_response\": slack_response})\n\n            schedule.schedule_approver_notification_event(\n                schedule_client=scheduler_client,\n                channel_id=event.channel_id,\n                message_ts=message[\"ts\"],\n                time_to_wait=time_to_wait\n            )", "                time_to_wait=time_to_wait\n            )\n            return\n\n    logger.info(\"The request has already been approved or discarded.\", extra={\"event\": event})\n    return\n"]}
{"filename": "src/statement.py", "chunked_list": ["from enum import Enum\nfrom typing import FrozenSet, Union\n\nfrom pydantic import ConstrainedStr, EmailStr, Field\n\nfrom entities import BaseModel\n\n\nclass ResourceType(str, Enum):\n    Account = \"Account\"\n    OU = \"OU\"", "class ResourceType(str, Enum):\n    Account = \"Account\"\n    OU = \"OU\"\n\n\nclass AWSAccountId(ConstrainedStr):\n    regex = r\"^\\d{12}$\"\n\n\nclass AWSOUName(ConstrainedStr):\n    regex = r\"^[\\s\\S]{1,128}$\"", "\nclass AWSOUName(ConstrainedStr):\n    regex = r\"^[\\s\\S]{1,128}$\"\n\n\nclass PermissionSetName(ConstrainedStr):\n    regex = r\"^[\\w+=,.@-]{1,32}$\"\n\n\nclass WildCard(ConstrainedStr):\n    regex = r\"^\\*$\"", "\nclass WildCard(ConstrainedStr):\n    regex = r\"^\\*$\"\n\n\nclass BaseStatement(BaseModel):\n    permission_set: FrozenSet[Union[PermissionSetName, WildCard]]\n\n    allow_self_approval: bool = False\n    approval_is_not_required: bool = False\n    approvers: FrozenSet[EmailStr] = Field(default_factory=frozenset)", "\n\nclass Statement(BaseStatement):\n    resource_type: ResourceType = Field(ResourceType.Account, const=True)\n    resource: FrozenSet[Union[AWSAccountId, WildCard]]\n\n    def affects(self, account_id: str, permission_set_name: str) -> bool:  # noqa: ANN101\n        return (account_id in self.resource or \"*\" in self.resource) and (\n            permission_set_name in self.permission_set or \"*\" in self.permission_set\n        )", "\n\ndef get_affected_statements(statements: FrozenSet[Statement], account_id: str, permission_set_name: str) -> FrozenSet[Statement]:\n    return frozenset(statement for statement in statements if statement.affects(account_id, permission_set_name))\n\n\nclass OUStatement(BaseStatement):\n    resource_type: ResourceType = Field(ResourceType.OU, const=True)\n    resource: FrozenSet[Union[AWSOUName, WildCard]]\n", ""]}
{"filename": "src/config.py", "chunked_list": ["import os\nfrom typing import Optional\n\nfrom aws_lambda_powertools import Logger\nfrom pydantic import BaseSettings, root_validator\n\nimport entities\nfrom statement import Statement\n\n\ndef parse_statement(_dict: dict) -> Statement:\n    def to_set_if_list_or_str(v: list | str) -> frozenset[str]:\n        if isinstance(v, list):\n            return frozenset(v)\n        return frozenset([v]) if isinstance(v, str) else v\n\n    return Statement.parse_obj(\n        {\n            \"permission_set\": to_set_if_list_or_str(_dict[\"PermissionSet\"]),\n            \"resource\": to_set_if_list_or_str(_dict[\"Resource\"]),\n            \"approvers\": to_set_if_list_or_str(_dict.get(\"Approvers\", set())),\n            \"resource_type\": _dict.get(\"ResourceType\"),\n            \"approval_is_not_required\": _dict.get(\"ApprovalIsNotRequired\", False),\n            \"allow_self_approval\": _dict.get(\"AllowSelfApproval\", False),\n        }\n    )", "\n\ndef parse_statement(_dict: dict) -> Statement:\n    def to_set_if_list_or_str(v: list | str) -> frozenset[str]:\n        if isinstance(v, list):\n            return frozenset(v)\n        return frozenset([v]) if isinstance(v, str) else v\n\n    return Statement.parse_obj(\n        {\n            \"permission_set\": to_set_if_list_or_str(_dict[\"PermissionSet\"]),\n            \"resource\": to_set_if_list_or_str(_dict[\"Resource\"]),\n            \"approvers\": to_set_if_list_or_str(_dict.get(\"Approvers\", set())),\n            \"resource_type\": _dict.get(\"ResourceType\"),\n            \"approval_is_not_required\": _dict.get(\"ApprovalIsNotRequired\", False),\n            \"allow_self_approval\": _dict.get(\"AllowSelfApproval\", False),\n        }\n    )", "\n\nclass Config(BaseSettings):\n    schedule_policy_arn: str\n    revoker_function_arn: str\n    revoker_function_name: str\n    schedule_group_name: str\n\n    post_update_to_slack: bool = False\n    slack_channel_id: str\n    slack_bot_token: str\n\n    approver_renotification_initial_wait_time: int\n    approver_renotification_backoff_multiplier: int\n\n    sso_instance_arn: str\n\n    log_level: str = \"INFO\"\n    slack_app_log_level: str = \"INFO\"\n    statements: frozenset[Statement]\n\n    accounts: frozenset[str]\n    permission_sets: frozenset[str]\n\n    s3_bucket_for_audit_entry_name: str\n    s3_bucket_prefix_for_partitions: str\n\n    sso_elevator_scheduled_revocation_rule_name: str\n    request_expiration_hours: int = 8\n\n    max_permissions_duration_time: int\n\n    class Config:\n        frozen = True\n\n    @root_validator(pre=True)\n    def get_accounts_and_permission_sets(cls, values: dict) -> dict:  # noqa: ANN101\n        statements = {parse_statement(st) for st in values.get(\"statements\", [])}  # type: ignore # noqa: PGH003\n        permission_sets = set()\n        accounts = set()\n        for statement in statements:\n            permission_sets.update(statement.permission_set)\n            if statement.resource_type == \"Account\":\n                accounts.update(statement.resource)\n        return values | {\"accounts\": accounts, \"permission_sets\": permission_sets, \"statements\": frozenset(statements)}", "\n\ndef get_logger(service: Optional[str] = None, level: Optional[str] = None) -> Logger:\n    kwargs = {\n        \"json_default\": entities.json_default,\n        \"level\": level or os.environ.get(\"LOG_LEVEL\", \"INFO\"),\n    }\n    if service:\n        kwargs[\"service\"] = service\n    return Logger(**kwargs)", "\n\n_config: Optional[Config] = None\n\n\ndef get_config() -> Config:\n    global _config  # noqa: PLW0603\n    if _config is None:\n        _config = Config()  # type: ignore # noqa: PGH003\n    return _config", ""]}
{"filename": "src/errors.py", "chunked_list": ["class ConfigurationError(Exception):\n    ...\n\n\nclass AccountAssignmentError(ConfigurationError):\n    ...\n\n\nclass NotFound(ConfigurationError):\n    ...", "class NotFound(ConfigurationError):\n    ...\n"]}
{"filename": "src/organizations.py", "chunked_list": ["from mypy_boto3_organizations import OrganizationsClient, type_defs\n\nimport config\nfrom entities.aws import Account\n\n\ndef parse_account(td: type_defs.AccountTypeDef) -> Account:\n    return Account.parse_obj({\"id\": td.get(\"Id\"), \"name\": td.get(\"Name\")})\n\ndef list_accounts(client: OrganizationsClient) -> list[Account]:\n    accounts = []\n    paginator = client.get_paginator(\"list_accounts\")\n    for page in paginator.paginate():\n        accounts.extend(page[\"Accounts\"])\n    return [parse_account(account) for account in accounts]", "\ndef list_accounts(client: OrganizationsClient) -> list[Account]:\n    accounts = []\n    paginator = client.get_paginator(\"list_accounts\")\n    for page in paginator.paginate():\n        accounts.extend(page[\"Accounts\"])\n    return [parse_account(account) for account in accounts]\n\n\ndef describe_account(client: OrganizationsClient, account_id: str) -> Account:\n    account = client.describe_account(AccountId=account_id)[\"Account\"]\n    return parse_account(account)", "\ndef describe_account(client: OrganizationsClient, account_id: str) -> Account:\n    account = client.describe_account(AccountId=account_id)[\"Account\"]\n    return parse_account(account)\n\n\ndef get_accounts_from_config(client: OrganizationsClient, cfg: config.Config) -> list[Account]:\n    if \"*\" in cfg.accounts:\n        accounts = list_accounts(client)\n    else:\n        accounts = [ac for ac in list_accounts(client) if ac.id in cfg.accounts]\n    return accounts", ""]}
{"filename": "src/slack_helpers.py", "chunked_list": ["import datetime\nimport time\nfrom datetime import timedelta\nfrom typing import Optional, TypeVar, Union\n\nimport jmespath as jp\nimport slack_sdk.errors\nfrom mypy_boto3_identitystore import IdentityStoreClient\nfrom mypy_boto3_sso_admin import SSOAdminClient\nfrom pydantic import root_validator", "from mypy_boto3_sso_admin import SSOAdminClient\nfrom pydantic import root_validator\nfrom slack_sdk import WebClient\nfrom slack_sdk.models.blocks import (\n    ActionsBlock,\n    Block,\n    ButtonElement,\n    DividerBlock,\n    InputBlock,\n    MarkdownTextObject,", "    InputBlock,\n    MarkdownTextObject,\n    Option,\n    PlainTextInputElement,\n    PlainTextObject,\n    SectionBlock,\n    StaticSelectElement,\n)\nfrom slack_sdk.models.views import View\nfrom slack_sdk.web.slack_response import SlackResponse", "from slack_sdk.models.views import View\nfrom slack_sdk.web.slack_response import SlackResponse\n\nimport config\nimport entities\nimport sso\nfrom entities import BaseModel\n\n# ruff: noqa: ANN102, PGH003\n", "# ruff: noqa: ANN102, PGH003\n\nlogger = config.get_logger(service=\"slack\")\ncfg = config.get_config()\n\n\nclass RequestForAccess(BaseModel):\n    permission_set_name: str\n    account_id: str\n    reason: str\n    requester_slack_id: str\n    permission_duration: timedelta", "\n\nclass RequestForAccessView:\n    CALLBACK_ID = \"request_for_access_submitted\"\n\n    REASON_BLOCK_ID = \"provide_reason\"\n    REASON_ACTION_ID = \"provided_reason\"\n\n    ACCOUNT_BLOCK_ID = \"select_account\"\n    ACCOUNT_ACTION_ID = \"selected_account\"\n\n    PERMISSION_SET_BLOCK_ID = \"select_permission_set\"\n    PERMISSION_SET_ACTION_ID = \"selected_permission_set\"\n\n    DURATION_BLOCK_ID = \"duration_picker\"\n    DURATION_ACTION_ID = \"duration_picker_action\"\n\n    LOADING_BLOCK_ID = \"loading\"\n\n    @classmethod\n    def build(cls) -> View:\n        return View(\n            type=\"modal\",\n            callback_id=cls.CALLBACK_ID,\n            submit=PlainTextObject(text=\"Request\"),\n            close=PlainTextObject(text=\"Cancel\"),\n            title=PlainTextObject(text=\"Get AWS access\"),\n            blocks=[\n                SectionBlock(text=MarkdownTextObject(text=\":wave: Hey! Please fill form below to request AWS access.\")),\n                DividerBlock(),\n                SectionBlock(\n                    block_id=cls.DURATION_BLOCK_ID,\n                    text=MarkdownTextObject(text=\"Select the duration for which the authorization will be provided\"),\n                    accessory=StaticSelectElement(\n                        action_id=cls.DURATION_ACTION_ID,\n                        initial_option=get_max_duration_block(cfg)[0],\n                        options=get_max_duration_block(cfg),\n                        placeholder=PlainTextObject(text=\"Select duration\"),\n                    ),\n                ),\n                InputBlock(\n                    block_id=cls.REASON_BLOCK_ID,\n                    label=PlainTextObject(text=\"What is it you are going to do\"),\n                    element=PlainTextInputElement(\n                        action_id=cls.REASON_ACTION_ID,\n                        multiline=True,\n                    ),\n                ),\n                DividerBlock(),\n                SectionBlock(\n                    text=MarkdownTextObject(\n                        text=\"Remember to use access responsibly. All actions (AWS API calls) are being recorded.\",\n                    ),\n                ),\n                SectionBlock(\n                    block_id=cls.LOADING_BLOCK_ID,\n                    text=MarkdownTextObject(\n                        text=\":hourglass: Loading available accounts and permission sets...\",\n                    ),\n                ),\n            ],\n        )\n\n    @classmethod\n    def build_select_account_input_block(cls, accounts: list[entities.aws.Account]) -> InputBlock:\n        # TODO: handle case when there are more than 100 accounts\n        # 99 is the limit for StaticSelectElement\n        # https://slack.dev/python-slack-sdk/api-docs/slack_sdk/models/blocks/block_elements.html#:~:text=StaticSelectElement(InputInteractiveElement)%3A%0A%20%20%20%20type%20%3D%20%22static_select%22-,options_max_length%20%3D%20100,-option_groups_max_length%20%3D%20100%0A%0A%20%20%20%20%40property%0A%20%20%20%20def%20attributes(\n        if len(accounts) >99: # noqa: PLR2004\n            accounts = accounts[:99]\n        sorted_accounts = sorted(accounts, key=lambda account: account.name)\n        return InputBlock(\n            block_id=cls.ACCOUNT_BLOCK_ID,\n            label=PlainTextObject(text=\"Select account\"),\n            element=StaticSelectElement(\n                action_id=cls.ACCOUNT_ACTION_ID,\n                placeholder=PlainTextObject(text=\"Select account\"),\n                options=[\n                    Option(text=PlainTextObject(text=f\"{account.id} - {account.name}\"), value=account.id) for account in sorted_accounts\n                ],\n            ),\n        )\n\n    @classmethod\n    def build_select_permission_set_input_block(cls, permission_sets: list[entities.aws.PermissionSet]) -> InputBlock:\n        sorted_permission_sets = sorted(permission_sets, key=lambda permission_set: permission_set.name)\n        return InputBlock(\n            block_id=cls.PERMISSION_SET_BLOCK_ID,\n            label=PlainTextObject(text=\"Select permission set\"),\n            element=StaticSelectElement(\n                action_id=cls.PERMISSION_SET_ACTION_ID,\n                placeholder=PlainTextObject(text=\"Select permission set\"),\n                options=[\n                    Option(text=PlainTextObject(text=permission_set.name), value=permission_set.name)\n                    for permission_set in sorted_permission_sets\n                ],\n            ),\n        )\n\n    @classmethod\n    def update_with_accounts_and_permission_sets(\n        cls, accounts: list[entities.aws.Account], permission_sets: list[entities.aws.PermissionSet]\n    ) -> View:\n        view = cls.build()\n        view.blocks = remove_blocks(view.blocks, block_ids=[cls.LOADING_BLOCK_ID])\n        view.blocks = insert_blocks(\n            blocks=view.blocks,\n            blocks_to_insert=[\n                cls.build_select_account_input_block(accounts),\n                cls.build_select_permission_set_input_block(permission_sets),\n            ],\n            after_block_id=cls.REASON_BLOCK_ID,\n        )\n        return view\n\n    @classmethod\n    def parse(cls, obj: dict) -> RequestForAccess:\n        values = jp.search(\"view.state.values\", obj)\n        hhmm = jp.search(f\"{cls.DURATION_BLOCK_ID}.{cls.DURATION_ACTION_ID}.selected_option.value\", values)\n        hours, minutes = map(int, hhmm.split(\":\"))\n        duration = timedelta(hours=hours, minutes=minutes)\n        return RequestForAccess.parse_obj(\n            {\n                \"permission_duration\": duration,\n                \"permission_set_name\": jp.search(\n                    f\"{cls.PERMISSION_SET_BLOCK_ID}.{cls.PERMISSION_SET_ACTION_ID}.selected_option.value\", values\n                ),\n                \"account_id\": jp.search(f\"{cls.ACCOUNT_BLOCK_ID}.{cls.ACCOUNT_ACTION_ID}.selected_option.value\", values),\n                \"reason\": jp.search(f\"{cls.REASON_BLOCK_ID}.{cls.REASON_ACTION_ID}.value\", values),\n                \"requester_slack_id\": jp.search(\"user.id\", obj),\n            }\n        )", "\n\nT = TypeVar(\"T\", Block, dict)\n\n\ndef get_block_id(block: Union[Block, dict]) -> Optional[str]:\n    return block[\"block_id\"] if isinstance(block, dict) else block.block_id\n\n\ndef remove_blocks(blocks: list[T], block_ids: list[str]) -> list[T]:\n    return [block for block in blocks if get_block_id(block) not in block_ids]", "\ndef remove_blocks(blocks: list[T], block_ids: list[str]) -> list[T]:\n    return [block for block in blocks if get_block_id(block) not in block_ids]\n\n\ndef insert_blocks(blocks: list[T], blocks_to_insert: list[Block], after_block_id: str) -> list[T]:\n    index = next(i for i, block in enumerate(blocks) if get_block_id(block) == after_block_id)\n    return blocks[: index + 1] + blocks_to_insert + blocks[index + 1 :]  # type: ignore\n\n\ndef humanize_timedelta(td: timedelta) -> str:\n    # example 12h 30m\n    hours, remainder = divmod(td.seconds, 3600)\n    minutes, _ = divmod(remainder, 60)\n    return f\"{hours}h {minutes}m\"", "\n\ndef humanize_timedelta(td: timedelta) -> str:\n    # example 12h 30m\n    hours, remainder = divmod(td.seconds, 3600)\n    minutes, _ = divmod(remainder, 60)\n    return f\"{hours}h {minutes}m\"\n\n\ndef unhumanize_timedelta(td_str: str) -> timedelta:\n    hours, minutes = td_str.split(\" \")\n    hours = hours.removesuffix(\"h\")\n    minutes = minutes.removesuffix(\"m\")\n    return timedelta(hours=int(hours), minutes=int(minutes))", "\ndef unhumanize_timedelta(td_str: str) -> timedelta:\n    hours, minutes = td_str.split(\" \")\n    hours = hours.removesuffix(\"h\")\n    minutes = minutes.removesuffix(\"m\")\n    return timedelta(hours=int(hours), minutes=int(minutes))\n\n\ndef build_approval_request_message_blocks(  # noqa: PLR0913\n    requester_slack_id: str,\n    account: entities.aws.Account,\n    role_name: str,\n    reason: str,\n    permission_duration: timedelta,\n    show_buttons: bool = True,\n) -> list[Block]:\n    blocks: list[Block] = [\n        SectionBlock(block_id=\"header\", text=MarkdownTextObject(text=\"AWS account access request.\")),\n        SectionBlock(\n            block_id=\"content\",\n            fields=[\n                MarkdownTextObject(text=f\"Requester: <@{requester_slack_id}>\"),\n                MarkdownTextObject(text=f\"Account: {account.name} #{account.id}\"),\n                MarkdownTextObject(text=f\"Role name: {role_name}\"),\n                MarkdownTextObject(text=f\"Reason: {reason}\"),\n                MarkdownTextObject(text=f\"Permission duration: {humanize_timedelta(permission_duration)}\"),\n            ],\n        ),\n    ]\n    if show_buttons:\n        blocks.append(\n            ActionsBlock(\n                block_id=\"buttons\",\n                elements=[\n                    ButtonElement(\n                        action_id=entities.ApproverAction.Approve.value,\n                        text=PlainTextObject(text=\"Approve\"),\n                        style=\"primary\",\n                        value=entities.ApproverAction.Approve.value,\n                    ),\n                    ButtonElement(\n                        action_id=entities.ApproverAction.Discard.value,\n                        text=PlainTextObject(text=\"Discard\"),\n                        style=\"danger\",\n                        value=entities.ApproverAction.Discard.value,\n                    ),\n                ],\n            )\n        )\n    return blocks", "def build_approval_request_message_blocks(  # noqa: PLR0913\n    requester_slack_id: str,\n    account: entities.aws.Account,\n    role_name: str,\n    reason: str,\n    permission_duration: timedelta,\n    show_buttons: bool = True,\n) -> list[Block]:\n    blocks: list[Block] = [\n        SectionBlock(block_id=\"header\", text=MarkdownTextObject(text=\"AWS account access request.\")),\n        SectionBlock(\n            block_id=\"content\",\n            fields=[\n                MarkdownTextObject(text=f\"Requester: <@{requester_slack_id}>\"),\n                MarkdownTextObject(text=f\"Account: {account.name} #{account.id}\"),\n                MarkdownTextObject(text=f\"Role name: {role_name}\"),\n                MarkdownTextObject(text=f\"Reason: {reason}\"),\n                MarkdownTextObject(text=f\"Permission duration: {humanize_timedelta(permission_duration)}\"),\n            ],\n        ),\n    ]\n    if show_buttons:\n        blocks.append(\n            ActionsBlock(\n                block_id=\"buttons\",\n                elements=[\n                    ButtonElement(\n                        action_id=entities.ApproverAction.Approve.value,\n                        text=PlainTextObject(text=\"Approve\"),\n                        style=\"primary\",\n                        value=entities.ApproverAction.Approve.value,\n                    ),\n                    ButtonElement(\n                        action_id=entities.ApproverAction.Discard.value,\n                        text=PlainTextObject(text=\"Discard\"),\n                        style=\"danger\",\n                        value=entities.ApproverAction.Discard.value,\n                    ),\n                ],\n            )\n        )\n    return blocks", "\n\ndef button_click_info_block(action: entities.ApproverAction, approver_slack_id: str) -> SectionBlock:\n    return SectionBlock(\n        block_id=\"footer\",\n        text=MarkdownTextObject(\n            text=f\"<@{approver_slack_id}> pressed {action.value} button\",\n        ),\n    )\n", "\n\nclass ButtonClickedPayload(BaseModel):\n    action: entities.ApproverAction\n    approver_slack_id: str\n    thread_ts: str\n    channel_id: str\n    message: dict\n    request: RequestForAccess\n\n    class Config:\n        frozen = True\n\n    @root_validator(pre=True)\n    def validate_payload(cls, values: dict) -> dict:  # noqa: ANN101\n        fields = jp.search(\"message.blocks[?block_id == 'content'].fields[]\", values)\n        requester_mention = cls.find_in_fields(fields, \"Requester\")\n        requester_slack_id = requester_mention.removeprefix(\"<@\").removesuffix(\">\")\n        humanized_permission_duration = cls.find_in_fields(fields, \"Permission duration\")\n        permission_duration = unhumanize_timedelta(humanized_permission_duration)\n        account = cls.find_in_fields(fields, \"Account\")\n        account_id = account.split(\"#\")[-1]\n        return {\n            \"action\": jp.search(\"actions[0].value\", values),\n            \"approver_slack_id\": jp.search(\"user.id\", values),\n            \"thread_ts\": jp.search(\"message.ts\", values),\n            \"channel_id\": jp.search(\"channel.id\", values),\n            \"message\": values.get(\"message\"),\n            \"request\": RequestForAccess(\n                requester_slack_id=requester_slack_id,\n                account_id=account_id,\n                permission_set_name=cls.find_in_fields(fields, \"Role name\"),\n                reason=cls.find_in_fields(fields, \"Reason\"),\n                permission_duration=permission_duration,\n            ),\n        }\n\n    @staticmethod\n    def find_in_fields(fields: list[dict[str, str]], key: str) -> str:\n        for field in fields:\n            if field[\"text\"].startswith(key):\n                return field[\"text\"].split(\": \")[1].strip()\n        raise ValueError(f\"Failed to parse message. Could not find {key} in fields: {fields}\")", "\n\ndef parse_user(user: dict) -> entities.slack.User:\n    return entities.slack.User.parse_obj(\n        {\"id\": jp.search(\"user.id\", user), \"email\": jp.search(\"user.profile.email\", user), \"real_name\": jp.search(\"user.real_name\", user)}\n    )\n\n\ndef get_user(client: WebClient, id: str) -> entities.slack.User:\n    response = client.users_info(user=id)\n    return parse_user(response.data)  # type: ignore", "def get_user(client: WebClient, id: str) -> entities.slack.User:\n    response = client.users_info(user=id)\n    return parse_user(response.data)  # type: ignore\n\n\ndef get_user_by_email(client: WebClient, email: str) -> entities.slack.User:\n    start = datetime.datetime.now()\n    timeout_seconds = 30\n    try:\n        r = client.users_lookupByEmail(email=email)\n        return parse_user(r.data)  # type: ignore\n    except slack_sdk.errors.SlackApiError as e:\n        if e.response[\"error\"] == \"ratelimited\":\n            if datetime.datetime.now() - start >= datetime.timedelta(seconds=timeout_seconds):\n                raise e\n            logger.info(f\"Rate limited when getting slack user by email. Sleeping for 3 seconds. {e}\")\n            time.sleep(3)\n            return get_user_by_email(client, email)\n        else:\n            raise e\n    except Exception as e:\n        raise e", "\n\ndef remove_buttons(payload: ButtonClickedPayload, client: WebClient, approver: entities.slack.User) -> SlackResponse:\n    blocks = remove_blocks(payload.message[\"blocks\"], block_ids=[\"buttons\"])\n    blocks.append(button_click_info_block(payload.action, approver.id))\n    return client.chat_update(\n        channel=payload.channel_id,\n        ts=payload.thread_ts,\n        blocks=blocks,\n        text=\"Buttons were removed.\",\n    )", "\n\ndef create_slack_mention_by_principal_id(\n    account_assignment: sso.AccountAssignment | sso.UserAccountAssignment,\n    sso_client: SSOAdminClient,\n    cfg: config.Config,\n    identitystore_client: IdentityStoreClient,\n    slack_client: WebClient,\n) -> str:\n    sso_instance = sso.describe_sso_instance(sso_client, cfg.sso_instance_arn)\n    aws_user_emails = sso.get_user_emails(\n        identitystore_client,\n        sso_instance.identity_store_id,\n        account_assignment.principal_id if isinstance(account_assignment, sso.AccountAssignment) else account_assignment.user_principal_id,\n    )\n    user_name = None\n\n    for email in aws_user_emails:\n        try:\n            slack_user = get_user_by_email(slack_client, email)\n            user_name = slack_user.real_name\n        except Exception:\n            continue\n\n    return f\"{user_name}\" if user_name is not None else aws_user_emails[0]", "\n\ndef get_message_from_timestamp(channel_id: str, message_ts: str, slack_client: slack_sdk.WebClient) -> dict | None:\n    response = slack_client.conversations_history(channel=channel_id)\n\n    if response[\"ok\"]:\n        messages = response.get(\"messages\")\n        if messages is not None:\n            for message in messages:\n                if \"ts\" in message and message[\"ts\"] == message_ts:\n                    return message\n\n    return None", "\n\ndef get_max_duration_block(cfg: config.Config) -> list[Option]:\n    return [\n        Option(text=PlainTextObject(text=f\"{i // 2:02d}:{(i % 2) * 30:02d}\"), value=f\"{i // 2:02d}:{(i % 2) * 30:02d}\")\n        for i in range(1, cfg.max_permissions_duration_time * 2 + 1)\n    ]\n\n", ""]}
{"filename": "src/sso.py", "chunked_list": ["from __future__ import annotations\n\nimport datetime\nimport time\nfrom dataclasses import dataclass\nfrom typing import TYPE_CHECKING, Callable, Generator, Optional, TypeVar\n\nimport config\nimport entities\nimport errors", "import entities\nimport errors\nimport organizations\n\nif TYPE_CHECKING:\n    from mypy_boto3_identitystore import IdentityStoreClient\n    from mypy_boto3_organizations import OrganizationsClient\n    from mypy_boto3_sso_admin import SSOAdminClient, type_defs\n\n    from entities.aws import PermissionSet", "\n# ruff: noqa: PGH003\nT = TypeVar(\"T\")\n\nlogger = config.get_logger(service=\"sso\")\n\n\n@dataclass\nclass AccountAssignmentStatus:\n    status: str\n    request_id: str\n    failure_reason: Optional[str]\n    target_id: str\n    target_type: str\n    permission_set_arn: str\n    principal_type: str\n    principal_id: str\n    created_date: Optional[str]\n\n    @staticmethod\n    def from_type_def(d: type_defs.AccountAssignmentOperationStatusTypeDef) -> AccountAssignmentStatus:\n        return AccountAssignmentStatus(\n            status=d[\"Status\"],  # type: ignore\n            request_id=d[\"RequestId\"],  # type: ignore\n            failure_reason=d.get(\"FailureReason\"),  # type: ignore\n            target_id=d[\"TargetId\"],  # type: ignore\n            target_type=d[\"TargetType\"],  # type: ignore\n            permission_set_arn=d[\"PermissionSetArn\"],  # type: ignore\n            principal_type=d[\"PrincipalType\"],  # type: ignore\n            principal_id=d[\"PrincipalId\"],  # type: ignore\n            created_date=d.get(\"CreatedDate\"),  # type: ignore\n        )\n\n    @staticmethod\n    def is_in_progress(status: AccountAssignmentStatus) -> bool:\n        return status.status == \"IN_PROGRESS\"\n\n    @staticmethod\n    def is_ready(status: AccountAssignmentStatus) -> bool:\n        return status.status == \"SUCCEEDED\"\n\n    @staticmethod\n    def is_failed(status: AccountAssignmentStatus) -> bool:\n        return status.status == \"FAILED\"", "class AccountAssignmentStatus:\n    status: str\n    request_id: str\n    failure_reason: Optional[str]\n    target_id: str\n    target_type: str\n    permission_set_arn: str\n    principal_type: str\n    principal_id: str\n    created_date: Optional[str]\n\n    @staticmethod\n    def from_type_def(d: type_defs.AccountAssignmentOperationStatusTypeDef) -> AccountAssignmentStatus:\n        return AccountAssignmentStatus(\n            status=d[\"Status\"],  # type: ignore\n            request_id=d[\"RequestId\"],  # type: ignore\n            failure_reason=d.get(\"FailureReason\"),  # type: ignore\n            target_id=d[\"TargetId\"],  # type: ignore\n            target_type=d[\"TargetType\"],  # type: ignore\n            permission_set_arn=d[\"PermissionSetArn\"],  # type: ignore\n            principal_type=d[\"PrincipalType\"],  # type: ignore\n            principal_id=d[\"PrincipalId\"],  # type: ignore\n            created_date=d.get(\"CreatedDate\"),  # type: ignore\n        )\n\n    @staticmethod\n    def is_in_progress(status: AccountAssignmentStatus) -> bool:\n        return status.status == \"IN_PROGRESS\"\n\n    @staticmethod\n    def is_ready(status: AccountAssignmentStatus) -> bool:\n        return status.status == \"SUCCEEDED\"\n\n    @staticmethod\n    def is_failed(status: AccountAssignmentStatus) -> bool:\n        return status.status == \"FAILED\"", "\n\n@dataclass\nclass UserAccountAssignment:\n    instance_arn: str\n    account_id: str\n    permission_set_arn: str\n    user_principal_id: str\n\n    def as_dict(self: UserAccountAssignment) -> dict:\n        return {\n            \"InstanceArn\": self.instance_arn,\n            \"TargetId\": self.account_id,\n            \"PermissionSetArn\": self.permission_set_arn,\n            \"PrincipalId\": self.user_principal_id,\n            \"TargetType\": \"AWS_ACCOUNT\",\n            \"PrincipalType\": \"USER\",\n        }", "\n\ndef create_account_assignment(client: SSOAdminClient, assignment: UserAccountAssignment) -> AccountAssignmentStatus:\n    response = client.create_account_assignment(**assignment.as_dict())\n    return AccountAssignmentStatus.from_type_def(response[\"AccountAssignmentCreationStatus\"])\n\n\ndef delete_account_assignment(client: SSOAdminClient, assignment: UserAccountAssignment) -> AccountAssignmentStatus:\n    response = client.delete_account_assignment(**assignment.as_dict())\n    return AccountAssignmentStatus.from_type_def(response[\"AccountAssignmentDeletionStatus\"])", "\n\ndef describe_account_assignment_creation_status(\n    client: SSOAdminClient, assignment: UserAccountAssignment, request_id: str\n) -> AccountAssignmentStatus:\n    response = client.describe_account_assignment_creation_status(\n        InstanceArn=assignment.instance_arn,\n        AccountAssignmentCreationRequestId=request_id,\n    )\n    return AccountAssignmentStatus.from_type_def(response[\"AccountAssignmentCreationStatus\"])", "\n\ndef describe_account_assignment_deletion_status(\n    client: SSOAdminClient, assignment: UserAccountAssignment, request_id: str\n) -> AccountAssignmentStatus:\n    response = client.describe_account_assignment_deletion_status(\n        InstanceArn=assignment.instance_arn,\n        AccountAssignmentDeletionRequestId=request_id,\n    )\n    return AccountAssignmentStatus.from_type_def(response[\"AccountAssignmentDeletionStatus\"])", "\n\ndef retry_while(\n    fn: Callable[[], T],\n    condition: Callable[[T], bool],\n    retry_period_seconds: int = 1,\n    timeout_seconds: int = 20,\n) -> T:\n    # If timeout_seconds -1, then retry forever.\n    start = datetime.datetime.now()\n\n    def is_timeout(timeout_seconds: int) -> bool:\n        if timeout_seconds == -1:\n            return False\n        return datetime.datetime.now() - start >= datetime.timedelta(seconds=timeout_seconds)\n\n    while True:\n        response = fn()\n        if is_timeout(timeout_seconds):\n            return response\n\n        if condition(response):\n            time.sleep(retry_period_seconds)\n            continue\n        else:\n            return response", "\n\ndef create_account_assignment_and_wait_for_result(client: SSOAdminClient, assignment: UserAccountAssignment) -> AccountAssignmentStatus:\n    response = create_account_assignment(client, assignment)\n    if AccountAssignmentStatus.is_ready(response):\n        return response\n    else:\n\n        def fn() -> AccountAssignmentStatus:\n            return describe_account_assignment_creation_status(client, assignment, response.request_id)\n\n        result = retry_while(fn, condition=AccountAssignmentStatus.is_in_progress, timeout_seconds=-1)\n    if AccountAssignmentStatus.is_failed(result):\n        e = errors.AccountAssignmentError(\"Failed to create account assignment.\")\n        logger.exception(e, extra={\"status\": result})\n        raise e\n\n    logger.info(\"Account assignment creation finished successfully.\")\n    return result", "\n\ndef delete_account_assignment_and_wait_for_result(client: SSOAdminClient, assignment: UserAccountAssignment) -> AccountAssignmentStatus:\n    response = delete_account_assignment(client, assignment)\n    if AccountAssignmentStatus.is_ready(response):\n        return response\n    else:\n\n        def fn() -> AccountAssignmentStatus:\n            return describe_account_assignment_deletion_status(client, assignment, response.request_id)\n\n        result = retry_while(fn, condition=AccountAssignmentStatus.is_in_progress, timeout_seconds=-1)\n\n    if AccountAssignmentStatus.is_failed(result):\n        e = errors.AccountAssignmentError(\"Failed to delete account assignment.\")\n        logger.exception(e, extra={\"status\": result})\n        raise e\n    logger.info(\"Account assignment deletion finished successfully.\")\n    return result", "\n\n@dataclass\nclass IAMIdentityCenterInstance:\n    \"\"\"IAM Identity Center Instance\n\n    Attributes:\n        arn (str): ARN of the IAM Identity Center Instance\n        identity_store_id (str): ID of the Identity Store\n    \"\"\"\n\n    arn: str\n    identity_store_id: str\n\n    @staticmethod\n    def from_instance_metadata_type_def(td: type_defs.InstanceMetadataTypeDef) -> \"IAMIdentityCenterInstance\":\n        return IAMIdentityCenterInstance(\n            arn=td[\"InstanceArn\"],  # type: ignore\n            identity_store_id=td[\"IdentityStoreId\"],  # type: ignore\n        )", "\n\ndef list_sso_instances(client: SSOAdminClient) -> list[IAMIdentityCenterInstance]:\n    \"\"\"List all IAM Identity Center Instances\n\n    Returns:\n        list[IAMIdentityCenterInstance]: List of IAM Identity Center Instances\n    \"\"\"\n    instances: list[IAMIdentityCenterInstance] = []\n    paginator = client.get_paginator(\"list_instances\")\n    for page in paginator.paginate():\n        instances.extend(IAMIdentityCenterInstance.from_instance_metadata_type_def(instance) for instance in page[\"Instances\"])\n    return instances", "\n\ndef describe_sso_instance(client: SSOAdminClient, instance_arn: str) -> IAMIdentityCenterInstance:\n    \"\"\"Describe IAM Identity Center Instance\n\n    Args:\n        instance_arn (str): ARN of the IAM Identity Center Instance\n\n    Returns:\n        IAMIdentityCenterInstance: IAM Identity Center Instance\n    \"\"\"\n    sso_instances = list_sso_instances(client)\n    return next(instance for instance in sso_instances if instance.arn == instance_arn)", "\n\n@dataclass\nclass AccountAssignment:\n    account_id: str\n    permission_set_arn: str\n    principal_id: str\n    principal_type: str\n\n    @staticmethod\n    def from_type_def(td: type_defs.AccountAssignmentTypeDef) -> AccountAssignment:\n        return AccountAssignment(\n            account_id=td[\"AccountId\"],  # type: ignore\n            permission_set_arn=td[\"PermissionSetArn\"],  # type: ignore\n            principal_id=td[\"PrincipalId\"],  # type: ignore\n            principal_type=td[\"PrincipalType\"],  # type: ignore\n        )", "\n\ndef list_user_account_assignments(\n    client: SSOAdminClient,\n    instance_arn: str,\n    account_ids: list[str],\n    permission_set_arns: list[str],\n) -> list[\"AccountAssignment\"]:\n    paginator = client.get_paginator(\"list_account_assignments\")\n    account_assignments: list[AccountAssignment] = []\n\n    for account_id in account_ids:\n        for permission_set_arn in permission_set_arns:\n            for page in paginator.paginate(\n                InstanceArn=instance_arn,\n                AccountId=account_id,\n                PermissionSetArn=permission_set_arn,\n            ):\n                for account_assignment in page[\"AccountAssignments\"]:\n                    aa = AccountAssignment.from_type_def(account_assignment)\n                    if aa.principal_type == \"USER\":\n                        account_assignments.append(aa)\n    return account_assignments", "\n\ndef parse_permission_set(td: type_defs.DescribePermissionSetResponseTypeDef) -> entities.aws.PermissionSet:\n    ps = td.get(\"PermissionSet\", {})\n    return entities.aws.PermissionSet.parse_obj(\n        {\n            \"name\": ps.get(\"Name\"),\n            \"arn\": ps.get(\"PermissionSetArn\"),\n            \"description\": ps.get(\"Description\"),\n        }\n    )", "\n\ndef describe_permission_set(client: SSOAdminClient, sso_instance_arn: str, permission_set_arn: str) -> entities.aws.PermissionSet:\n    td = client.describe_permission_set(InstanceArn=sso_instance_arn, PermissionSetArn=permission_set_arn)\n    return parse_permission_set(td)\n\n\ndef get_permission_set_by_name(client: SSOAdminClient, sso_instance_arn: str, permission_set_name: str) -> entities.aws.PermissionSet:\n    if ps := next(\n        (permission_set for permission_set in list_permission_sets(client, sso_instance_arn) if permission_set.name == permission_set_name),\n        None,\n    ):\n        return ps\n    raise errors.NotFound(f\"Permission set with name {permission_set_name} not found\")", "\n\ndef list_permission_sets_arns(client: SSOAdminClient, sso_instance_arn: str) -> Generator[str, None, None]:\n    paginator = client.get_paginator(\"list_permission_sets\")\n    for page in paginator.paginate(InstanceArn=sso_instance_arn):\n        yield from page[\"PermissionSets\"]\n\n\ndef list_permission_sets(client: SSOAdminClient, sso_instance_arn: str) -> Generator[entities.aws.PermissionSet, None, None]:\n    for permission_set_arn in list_permission_sets_arns(client, sso_instance_arn):\n        yield describe_permission_set(client, sso_instance_arn, permission_set_arn)", "def list_permission_sets(client: SSOAdminClient, sso_instance_arn: str) -> Generator[entities.aws.PermissionSet, None, None]:\n    for permission_set_arn in list_permission_sets_arns(client, sso_instance_arn):\n        yield describe_permission_set(client, sso_instance_arn, permission_set_arn)\n\n\ndef get_user_principal_id_by_email(client: IdentityStoreClient, identity_store_id: str, email: str) -> str:\n    response = client.list_users(IdentityStoreId=identity_store_id)\n    for user in response[\"Users\"]:\n        for user_email in user.get(\"Emails\", []):\n            if user_email.get(\"Value\") == email:\n                return user[\"UserId\"]\n\n    raise errors.NotFound(f\"AWS SSO User with email {email} not found\")", "\n\ndef get_user_emails(client: IdentityStoreClient, identity_store_id: str, user_id: str) -> list[str]:\n    user = client.describe_user(\n        IdentityStoreId=identity_store_id,\n        UserId=user_id,\n    )\n    return [email[\"Value\"] for email in user[\"Emails\"] if \"Value\" in email]\n\n\ndef get_permission_sets_from_config(client: SSOAdminClient, cfg: config.Config) -> list[PermissionSet]:\n    if \"*\" in cfg.permission_sets:\n        permission_sets = list(list_permission_sets(client, cfg.sso_instance_arn))\n    else:\n        permission_sets = [ps for ps in list_permission_sets(client, cfg.sso_instance_arn) if ps.name in cfg.permission_sets]\n    return permission_sets", "\n\ndef get_permission_sets_from_config(client: SSOAdminClient, cfg: config.Config) -> list[PermissionSet]:\n    if \"*\" in cfg.permission_sets:\n        permission_sets = list(list_permission_sets(client, cfg.sso_instance_arn))\n    else:\n        permission_sets = [ps for ps in list_permission_sets(client, cfg.sso_instance_arn) if ps.name in cfg.permission_sets]\n    return permission_sets\n\n\ndef get_account_assignment_information(\n    sso_client: SSOAdminClient, cfg: config.Config, org_client: OrganizationsClient\n) -> list[AccountAssignment]:\n    describe_sso_instance(sso_client, cfg.sso_instance_arn)\n    accounts = organizations.get_accounts_from_config(org_client, cfg)\n    permission_sets = get_permission_sets_from_config(sso_client, cfg)\n    account_assignments = list_user_account_assignments(\n        sso_client,\n        cfg.sso_instance_arn,\n        [a.id for a in accounts],\n        [ps.arn for ps in permission_sets],\n    )\n    return account_assignments", "\n\ndef get_account_assignment_information(\n    sso_client: SSOAdminClient, cfg: config.Config, org_client: OrganizationsClient\n) -> list[AccountAssignment]:\n    describe_sso_instance(sso_client, cfg.sso_instance_arn)\n    accounts = organizations.get_accounts_from_config(org_client, cfg)\n    permission_sets = get_permission_sets_from_config(sso_client, cfg)\n    account_assignments = list_user_account_assignments(\n        sso_client,\n        cfg.sso_instance_arn,\n        [a.id for a in accounts],\n        [ps.arn for ps in permission_sets],\n    )\n    return account_assignments", ""]}
{"filename": "src/s3.py", "chunked_list": ["import json\nimport uuid\nfrom dataclasses import asdict, dataclass\nfrom datetime import datetime, timedelta\nfrom mypy_boto3_s3 import S3Client, type_defs\n\nimport boto3\n\nfrom config import get_config, get_logger\n", "from config import get_config, get_logger\n\ncfg = get_config()\nlogger = get_logger(service=\"s3\")\ns3: S3Client = boto3.client(\"s3\")\n\n\n@dataclass\nclass AuditEntry:\n    role_name: str\n    account_id: str\n    reason: str\n    requester_slack_id: str\n    requester_email: str\n    request_id: str\n    approver_slack_id: str\n    approver_email: str\n    operation_type: str\n    permission_duration: str | timedelta", "class AuditEntry:\n    role_name: str\n    account_id: str\n    reason: str\n    requester_slack_id: str\n    requester_email: str\n    request_id: str\n    approver_slack_id: str\n    approver_email: str\n    operation_type: str\n    permission_duration: str | timedelta", "\n\ndef log_operation(audit_entry: AuditEntry) -> type_defs.PutObjectOutputTypeDef:\n    now = datetime.now()\n    logger.debug(\"Posting audit entry to s3\", extra={\"audit_entry\": audit_entry})\n    logger.info(\"Posting audit entry to s3\")\n    if isinstance(audit_entry.permission_duration, timedelta):\n        permission_duration = str(int(audit_entry.permission_duration.total_seconds()))\n    else:\n        permission_duration = \"NA\"\n\n    audit_entry_dict = asdict(audit_entry) | {\n        \"permission_duration\": permission_duration,\n        \"time\": str(now),\n        \"timestamp\": int(now.timestamp() * 1000),\n    }\n\n    json_data = json.dumps(audit_entry_dict)\n    bucket_name = cfg.s3_bucket_for_audit_entry_name\n    bucket_prefix = cfg.s3_bucket_prefix_for_partitions\n    return s3.put_object(\n        Bucket=bucket_name,\n        Key=f\"{bucket_prefix}/{now.strftime('%Y/%m/%d')}/{uuid.uuid4()}.json\",\n        Body=json_data,\n        ContentType=\"application/json\",\n    )", ""]}
{"filename": "src/schedule.py", "chunked_list": ["import json\nfrom datetime import datetime, timedelta, timezone\n\nimport botocore.exceptions\nimport jmespath as jp\nfrom croniter import croniter\nfrom mypy_boto3_events import EventBridgeClient\nfrom mypy_boto3_events import type_defs as events_type_defs\nfrom mypy_boto3_scheduler import EventBridgeSchedulerClient\nfrom mypy_boto3_scheduler import type_defs as scheduler_type_defs", "from mypy_boto3_scheduler import EventBridgeSchedulerClient\nfrom mypy_boto3_scheduler import type_defs as scheduler_type_defs\nfrom pydantic import ValidationError\n\nimport config\nimport entities\nimport sso\nfrom events import DiscardButtonsEvent, Event, RevokeEvent, ScheduledRevokeEvent, ApproverNotificationEvent\n\nlogger = config.get_logger(service=\"schedule\")", "\nlogger = config.get_logger(service=\"schedule\")\ncfg = config.get_config()\n\n\ndef get_event_brige_rule(event_brige_client: EventBridgeClient, rule_name: str) -> events_type_defs.DescribeRuleResponseTypeDef:\n    return event_brige_client.describe_rule(Name=rule_name)\n\n\ndef get_next_cron_run_time(cron_expression: str, base_time: datetime) -> datetime:\n    # Replace ? with * to comply with croniter\n    cron_expression = cron_expression.replace(\"?\", \"*\")\n    cron_iter = croniter(cron_expression, base_time)\n    next_run_time = cron_iter.get_next(datetime)\n    logger.debug(f\"Next run time: {next_run_time}\")\n    return next_run_time", "\ndef get_next_cron_run_time(cron_expression: str, base_time: datetime) -> datetime:\n    # Replace ? with * to comply with croniter\n    cron_expression = cron_expression.replace(\"?\", \"*\")\n    cron_iter = croniter(cron_expression, base_time)\n    next_run_time = cron_iter.get_next(datetime)\n    logger.debug(f\"Next run time: {next_run_time}\")\n    return next_run_time\n\ndef check_rule_expression_and_get_next_run(rule: events_type_defs.DescribeRuleResponseTypeDef) -> datetime | str:\n    schedule_expression = rule[\"ScheduleExpression\"]\n    current_time = datetime.utcnow()\n    logger.debug(f\"Current time: {current_time}\")\n    logger.debug(f\"Schedule expression: {schedule_expression}\")\n\n    if schedule_expression.startswith(\"rate\"):\n        return schedule_expression\n    elif schedule_expression.startswith(\"cron\"):\n        clean_expression = schedule_expression.replace(\"cron(\", \"\").replace(\")\", \"\")\n        try:\n            return get_next_cron_run_time(clean_expression, current_time)\n        except Exception as e:\n            logger.warning(f\"Unable to parse cron expression: {clean_expression}\", extra={\"error\": e})\n            return schedule_expression\n    else:\n        raise ValueError(\"Unknown schedule expression format!\")", "\ndef check_rule_expression_and_get_next_run(rule: events_type_defs.DescribeRuleResponseTypeDef) -> datetime | str:\n    schedule_expression = rule[\"ScheduleExpression\"]\n    current_time = datetime.utcnow()\n    logger.debug(f\"Current time: {current_time}\")\n    logger.debug(f\"Schedule expression: {schedule_expression}\")\n\n    if schedule_expression.startswith(\"rate\"):\n        return schedule_expression\n    elif schedule_expression.startswith(\"cron\"):\n        clean_expression = schedule_expression.replace(\"cron(\", \"\").replace(\")\", \"\")\n        try:\n            return get_next_cron_run_time(clean_expression, current_time)\n        except Exception as e:\n            logger.warning(f\"Unable to parse cron expression: {clean_expression}\", extra={\"error\": e})\n            return schedule_expression\n    else:\n        raise ValueError(\"Unknown schedule expression format!\")", "\n\ndef get_schedules(client: EventBridgeSchedulerClient) -> list[scheduler_type_defs.GetScheduleOutputTypeDef]:\n    paginator = client.get_paginator(\"list_schedules\")\n    scheduled_events = []\n    for page in paginator.paginate(GroupName=cfg.schedule_group_name):\n        schedules_names = jp.search(\"Schedules[*].Name\", page)\n        for schedule_name in schedules_names:\n            if not schedule_name:\n                continue\n            full_schedule = client.get_schedule(GroupName=cfg.schedule_group_name, Name=schedule_name)\n            scheduled_events.append(full_schedule)\n    return scheduled_events", "\n\ndef get_scheduled_events(client: EventBridgeSchedulerClient) -> list[ScheduledRevokeEvent]:\n    scheduled_events = get_schedules(client)\n    scheduled_revoke_events: list[ScheduledRevokeEvent] = []\n    for full_schedule in scheduled_events:\n        if full_schedule[\"Name\"].startswith(\"discard-buttons\"):\n            continue\n\n        event = json.loads(jp.search(\"Target.Input\", full_schedule))\n\n        try:\n            event = Event.parse_obj(event)\n        except ValidationError as e:\n            logger.warning(\"Got unexpected event\", extra={\"event\": event, \"error\": e})\n            continue\n\n        if isinstance(event.__root__, ScheduledRevokeEvent):\n            scheduled_revoke_events.append(event.__root__)\n            print(\"case: ScheduledRevokeEvent\")\n\n    return scheduled_revoke_events", "\n\ndef delete_schedule(client: EventBridgeSchedulerClient, schedule_name: str) -> None:\n    try:\n        client.delete_schedule(GroupName=cfg.schedule_group_name, Name=schedule_name)\n        logger.info(\"Schedule deleted\", extra={\"schedule_name\": schedule_name})\n    except botocore.exceptions.ClientError as e:\n        if jp.search(\"Error.Code\", e.response) == \"ResourceNotFoundException\":\n            logger.info(\"Schedule for deletion was not found\", extra={\"schedule_name\": schedule_name})\n        else:\n            raise e", "\n\ndef get_and_delete_scheduled_revoke_event_if_already_exist(\n    client: EventBridgeSchedulerClient,\n    user_account_assignment: sso.UserAccountAssignment,\n) -> None:\n    for scheduled_event in get_scheduled_events(client):\n        if scheduled_event.revoke_event.user_account_assignment == user_account_assignment:\n            logger.info(\"Schedule already exist, deleting it\", extra={\"schedule_name\": scheduled_event.revoke_event.schedule_name})\n            delete_schedule(client, scheduled_event.revoke_event.schedule_name)", "\n\ndef event_bridge_schedule_after(td: timedelta) -> str:\n    now = datetime.now(timezone.utc)\n    return f\"at({(now + td).replace(microsecond=0).isoformat().replace('+00:00', '')})\"\n\n\ndef schedule_revoke_event(\n    schedule_client: EventBridgeSchedulerClient,\n    permission_duration: timedelta,\n    approver: entities.slack.User,\n    requester: entities.slack.User,\n    user_account_assignment: sso.UserAccountAssignment,\n) -> scheduler_type_defs.CreateScheduleOutputTypeDef:\n    logger.info(\"Scheduling revoke event\")\n    schedule_name = f\"{cfg.revoker_function_name}\" + datetime.now().strftime(\"%Y-%m-%d-%H-%M-%S\")\n    get_and_delete_scheduled_revoke_event_if_already_exist(schedule_client, user_account_assignment)\n    revoke_event = RevokeEvent(\n        schedule_name=schedule_name,\n        approver=approver,\n        requester=requester,\n        user_account_assignment=user_account_assignment,\n        permission_duration=permission_duration,\n    )\n    logger.debug(\"Creating schedule\", extra={\"revoke_event\": revoke_event})\n    return schedule_client.create_schedule(\n        FlexibleTimeWindow={\"Mode\": \"OFF\"},\n        Name=schedule_name,\n        GroupName=cfg.schedule_group_name,\n        ScheduleExpression=event_bridge_schedule_after(permission_duration),\n        State=\"ENABLED\",\n        Target=scheduler_type_defs.TargetTypeDef(\n            Arn=cfg.revoker_function_arn,\n            RoleArn=cfg.schedule_policy_arn,\n            Input=json.dumps(\n                {\n                    \"action\": \"event_bridge_revoke\",\n                    \"revoke_event\": revoke_event.json(),\n                },\n            ),\n        ),\n    )", "\n\ndef schedule_discard_buttons_event(\n    schedule_client: EventBridgeSchedulerClient,\n    time_stamp: str,\n    channel_id: str,\n) -> scheduler_type_defs.CreateScheduleOutputTypeDef | None:\n    if cfg.request_expiration_hours == 0:\n        logger.info(\"Request expiration is disabled, not scheduling discard buttons event\")\n        return\n    permission_duration = timedelta(hours=cfg.request_expiration_hours)\n\n    logger.info(\"Scheduling discard buttons event\")\n    schedule_name = \"discard-buttons\" + datetime.now().strftime(\"%Y-%m-%d-%H-%M-%S\")\n    logger.debug(\n        \"Creating schedule\",\n        extra={\n            \"schedule_name\": schedule_name,\n            \"permission_duration\": permission_duration,\n            \"time_stamp\": time_stamp,\n            \"channel_id\": channel_id,\n        },\n    )\n    return schedule_client.create_schedule(\n        FlexibleTimeWindow={\"Mode\": \"OFF\"},\n        Name=schedule_name,\n        GroupName=cfg.schedule_group_name,\n        ScheduleExpression=event_bridge_schedule_after(permission_duration),\n        State=\"ENABLED\",\n        Target=scheduler_type_defs.TargetTypeDef(\n            Arn=cfg.revoker_function_arn,\n            RoleArn=cfg.schedule_policy_arn,\n            Input=json.dumps(\n                DiscardButtonsEvent(\n                    action=\"discard_buttons_event\",\n                    schedule_name=schedule_name,\n                    time_stamp=time_stamp,\n                    channel_id=channel_id,\n                ).dict()\n            ),\n        ),\n    )", "\ndef schedule_approver_notification_event(\n    schedule_client: EventBridgeSchedulerClient,\n    message_ts: str,\n    channel_id: str,\n    time_to_wait: timedelta,\n) ->scheduler_type_defs.CreateScheduleOutputTypeDef | None:\n    # If the initial wait time is 0, we don't schedule the event\n    if cfg.approver_renotification_initial_wait_time == 0:\n        logger.info(\"Approver renotification is disabled, not scheduling approver notification event\")\n        return\n\n    logger.info(\"Scheduling approver notification event\")\n    schedule_name = \"approvers-renotification\" + datetime.now().strftime(\"%Y-%m-%d-%H-%M-%S\")\n    logger.debug(\n        \"Creating schedule\",\n        extra={\n            \"schedule_name\": schedule_name,\n            \"time_to_wait\": time_to_wait,\n            \"time_stamp\": message_ts,\n            \"channel_id\": channel_id,\n        },\n    )\n    return schedule_client.create_schedule(\n        FlexibleTimeWindow={\"Mode\": \"OFF\"},\n        Name=schedule_name,\n        GroupName=cfg.schedule_group_name,\n        ScheduleExpression=event_bridge_schedule_after(time_to_wait),\n        State=\"ENABLED\",\n        Target=scheduler_type_defs.TargetTypeDef(\n            Arn=cfg.revoker_function_arn,\n            RoleArn=cfg.schedule_policy_arn,\n            Input=json.dumps(\n                ApproverNotificationEvent(\n                    action=\"approvers_renotification\",\n                    schedule_name=schedule_name,\n                    time_stamp=message_ts,\n                    channel_id=channel_id,\n                    time_to_wait_in_seconds=time_to_wait.total_seconds()\n                ).dict()\n            ),\n        ),\n    )", ""]}
{"filename": "src/access_control.py", "chunked_list": ["import datetime\nfrom enum import Enum\nfrom typing import FrozenSet\n\nimport boto3\n\nimport config\nimport entities\nimport s3\nimport schedule", "import s3\nimport schedule\nimport sso\nfrom entities import BaseModel\nfrom statement import Statement, get_affected_statements\n\nlogger = config.get_logger(\"access_control\")\ncfg = config.get_config()\n\nsession = boto3._get_default_session()", "\nsession = boto3._get_default_session()\norg_client = session.client(\"organizations\")\nsso_client = session.client(\"sso-admin\")\nidentitystore_client = session.client(\"identitystore\")\nschedule_client = session.client(\"scheduler\")\n\n\nclass DecisionReason(Enum):\n    RequiresApproval = \"RequiresApproval\"\n    ApprovalNotRequired = \"ApprovalNotRequired\"\n    SelfApproval = \"SelfApproval\"\n    NoStatements = \"NoStatements\"\n    NoApprovers = \"NoApprovers\"", "class DecisionReason(Enum):\n    RequiresApproval = \"RequiresApproval\"\n    ApprovalNotRequired = \"ApprovalNotRequired\"\n    SelfApproval = \"SelfApproval\"\n    NoStatements = \"NoStatements\"\n    NoApprovers = \"NoApprovers\"\n\n\nclass AccessRequestDecision(BaseModel):\n    grant: bool\n    reason: DecisionReason\n    based_on_statements: FrozenSet[Statement]\n    approvers: FrozenSet[str] = frozenset()", "class AccessRequestDecision(BaseModel):\n    grant: bool\n    reason: DecisionReason\n    based_on_statements: FrozenSet[Statement]\n    approvers: FrozenSet[str] = frozenset()\n\n\ndef make_decision_on_access_request(\n    statements: FrozenSet[Statement],\n    permission_set_name: str,\n    account_id: str,\n    requester_email: str,\n) -> AccessRequestDecision:\n    affected_statements = get_affected_statements(statements, account_id, permission_set_name)\n    decision_based_on_statements: set[Statement] = set()\n    potential_approvers = set()\n\n    for statement in affected_statements:\n        if statement.approval_is_not_required:\n            return AccessRequestDecision(\n                grant=True,\n                reason=DecisionReason.ApprovalNotRequired,\n                based_on_statements=frozenset([statement]),\n            )\n        if requester_email in statement.approvers and statement.allow_self_approval:\n            return AccessRequestDecision(\n                grant=True,\n                reason=DecisionReason.SelfApproval,\n                based_on_statements=frozenset([statement]),\n            )\n\n        decision_based_on_statements.add(statement)\n        potential_approvers.update(approver for approver in statement.approvers if approver != requester_email)\n\n    if len(decision_based_on_statements) == 0:  # sourcery skip\n        return AccessRequestDecision(\n            grant=False,\n            reason=DecisionReason.NoStatements,\n            based_on_statements=frozenset(decision_based_on_statements),\n        )\n\n    if not potential_approvers:\n        return AccessRequestDecision(\n            grant=False,\n            reason=DecisionReason.NoApprovers,\n            based_on_statements=frozenset(decision_based_on_statements),\n        )\n\n    return AccessRequestDecision(\n        grant=False,\n        reason=DecisionReason.RequiresApproval,\n        approvers=frozenset(potential_approvers),\n        based_on_statements=frozenset(decision_based_on_statements),\n    )", "\n\nclass ApproveRequestDecision(BaseModel):\n    \"\"\"Decision on approver request\n\n    grant: bool - Create account assignment, if grant is True\n    permit: bool - Allow approver to make an action Approve if permit is True\n    based_on_statements: FrozenSet[Statement]\n    \"\"\"\n\n    grant: bool\n    permit: bool\n    based_on_statements: FrozenSet[Statement]", "\n\ndef make_decision_on_approve_request(  # noqa: PLR0913\n    action: entities.ApproverAction,\n    statements: frozenset[Statement],\n    permission_set_name: str,\n    account_id: str,\n    approver_email: str,\n    requester_email: str,\n) -> ApproveRequestDecision:\n    affected_statements = get_affected_statements(statements, account_id, permission_set_name)\n\n    for statement in affected_statements:\n        if approver_email in statement.approvers:\n            is_self_approval = approver_email == requester_email\n            if is_self_approval and statement.allow_self_approval or not is_self_approval:\n                return ApproveRequestDecision(\n                    grant=action == entities.ApproverAction.Approve,\n                    permit=True,\n                    based_on_statements=frozenset([statement]),\n                )\n\n    return ApproveRequestDecision(\n        grant=False,\n        permit=False,\n        based_on_statements=affected_statements,\n    )", "\n\ndef execute_decision(  # noqa: PLR0913\n    decision: AccessRequestDecision | ApproveRequestDecision,\n    permission_set_name: str,\n    account_id: str,\n    permission_duration: datetime.timedelta,\n    approver: entities.slack.User,\n    requester: entities.slack.User,\n    reason: str,\n) -> bool:\n    logger.info(\"Executing decision\")\n    if not decision.grant:\n        logger.info(\"Access request denied\")\n        return False  # Temporary solution for testing\n\n    sso_instance = sso.describe_sso_instance(sso_client, cfg.sso_instance_arn)\n    permission_set = sso.get_permission_set_by_name(sso_client, sso_instance.arn, permission_set_name)\n    user_principal_id = sso.get_user_principal_id_by_email(identitystore_client, sso_instance.identity_store_id, requester.email)\n    account_assignment = sso.UserAccountAssignment(\n        instance_arn=sso_instance.arn,\n        account_id=account_id,\n        permission_set_arn=permission_set.arn,\n        user_principal_id=user_principal_id,\n    )\n\n    logger.info(\"Creating account assignment\", extra={\"account_assignment\": account_assignment})\n\n    account_assignment_status = sso.create_account_assignment_and_wait_for_result(\n        sso_client,\n        account_assignment,\n    )\n\n    s3.log_operation(\n        audit_entry=s3.AuditEntry(\n            account_id=account_id,\n            role_name=permission_set.name,\n            reason=reason,\n            requester_slack_id=requester.id,\n            requester_email=requester.email,\n            approver_slack_id=approver.id,\n            approver_email=approver.email,\n            request_id=account_assignment_status.request_id,\n            operation_type=\"grant\",\n            permission_duration=permission_duration,\n        ),\n    )\n\n    schedule.schedule_revoke_event(\n        permission_duration=permission_duration,\n        schedule_client=schedule_client,\n        approver=approver,\n        requester=requester,\n        user_account_assignment=sso.UserAccountAssignment(\n            instance_arn=sso_instance.arn,\n            account_id=account_id,\n            permission_set_arn=permission_set.arn,\n            user_principal_id=user_principal_id,\n        ),\n    )\n    return True  # Temporary solution for testing", ""]}
{"filename": "src/tests/test_access_control.py", "chunked_list": ["import datetime\n\nimport pytest\n\nimport entities\nfrom access_control import (\n    AccessRequestDecision,\n    ApproveRequestDecision,\n    DecisionReason,\n    execute_decision,", "    DecisionReason,\n    execute_decision,\n    make_decision_on_access_request,\n    make_decision_on_approve_request,\n)\nfrom statement import Statement\n\n# ruff: noqa: ANN201, ANN001\n\n", "\n\n@pytest.fixture\ndef execute_decision_info():\n    return {\n        \"permission_set_name\": \"1233321\",\n        \"account_id\": \"1233321\",\n        \"permission_duration\": datetime.timedelta(days=1),\n        \"approver\": entities.slack.User(email=\"email@email\", id=\"123\", real_name=\"123\"),\n        \"requester\": entities.slack.User(email=\"email@email\", id=\"123\", real_name=\"123\"),\n        \"reason\": \"\",\n    }", "\n\n@pytest.fixture(\n    params=[\n        {\n            \"description\": \"Grant access if approval is not required\",\n            \"in\": {\n                \"statements\": frozenset(\n                    [\n                        Statement.parse_obj(", "                    [\n                        Statement.parse_obj(\n                            {\n                                \"resource_type\": \"Account\",\n                                \"resource\": [\"*\"],\n                                \"permission_set\": [\"*\"],\n                                \"approval_is_not_required\": True,\n                            }\n                        )\n                    ]", "                        )\n                    ]\n                ),\n                \"account_id\": \"111111111111\",\n                \"permission_set_name\": \"AdministratorAccess\",\n                \"requester_email\": \"anybody@example.com\",\n            },\n            \"out\": AccessRequestDecision(\n                grant=True,\n                reason=DecisionReason.ApprovalNotRequired,", "                grant=True,\n                reason=DecisionReason.ApprovalNotRequired,\n                based_on_statements=frozenset(\n                    [\n                        Statement.parse_obj(\n                            {\n                                \"resource_type\": \"Account\",\n                                \"resource\": [\"*\"],\n                                \"permission_set\": [\"*\"],\n                                \"approval_is_not_required\": True,", "                                \"permission_set\": [\"*\"],\n                                \"approval_is_not_required\": True,\n                            }\n                        )\n                    ]\n                ),\n            ),\n        },\n        {\n            \"description\": \"Request requires approval if requester is not an approver\",", "        {\n            \"description\": \"Request requires approval if requester is not an approver\",\n            \"in\": {\n                \"statements\": frozenset(\n                    [\n                        Statement.parse_obj(\n                            {\n                                \"resource_type\": \"Account\",\n                                \"resource\": [\"111111111111\"],\n                                \"permission_set\": [\"AdministratorAccess\"],", "                                \"resource\": [\"111111111111\"],\n                                \"permission_set\": [\"AdministratorAccess\"],\n                                \"approvers\": [\"one@example.com\"],\n                            }\n                        )\n                    ]\n                ),\n                \"account_id\": \"111111111111\",\n                \"permission_set_name\": \"AdministratorAccess\",\n                \"requester_email\": \"second@example.com\",", "                \"permission_set_name\": \"AdministratorAccess\",\n                \"requester_email\": \"second@example.com\",\n            },\n            \"out\": AccessRequestDecision(\n                grant=False,\n                reason=DecisionReason.RequiresApproval,\n                approvers=frozenset([\"one@example.com\"]),\n                based_on_statements=frozenset(\n                    [\n                        Statement.parse_obj(", "                    [\n                        Statement.parse_obj(\n                            {\n                                \"resource_type\": \"Account\",\n                                \"resource\": [\"111111111111\"],\n                                \"permission_set\": [\"AdministratorAccess\"],\n                                \"approvers\": [\"one@example.com\"],\n                            }\n                        )\n                    ]", "                        )\n                    ]\n                ),\n            ),\n        },\n        {\n            \"description\": \"requester is not an approver and self approval is allowed - RequiresApproval\",\n            \"in\": {\n                \"statements\": frozenset(\n                    [", "                \"statements\": frozenset(\n                    [\n                        Statement.parse_obj(\n                            {\n                                \"resource_type\": \"Account\",\n                                \"resource\": [\"111111111111\"],\n                                \"permission_set\": [\"AdministratorAccess\"],\n                                \"approvers\": [\"one@example.com\"],\n                                \"allow_self_approval\": True,\n                            }", "                                \"allow_self_approval\": True,\n                            }\n                        )\n                    ]\n                ),\n                \"account_id\": \"111111111111\",\n                \"permission_set_name\": \"AdministratorAccess\",\n                \"requester_email\": \"second@example.com\",\n            },\n            \"out\": AccessRequestDecision(", "            },\n            \"out\": AccessRequestDecision(\n                grant=False,\n                reason=DecisionReason.RequiresApproval,\n                approvers=frozenset([\"one@example.com\"]),\n                based_on_statements=frozenset(\n                    [\n                        Statement.parse_obj(\n                            {\n                                \"resource_type\": \"Account\",", "                            {\n                                \"resource_type\": \"Account\",\n                                \"resource\": [\"111111111111\"],\n                                \"permission_set\": [\"AdministratorAccess\"],\n                                \"approvers\": [\"one@example.com\"],\n                                \"allow_self_approval\": True,\n                            }\n                        )\n                    ]\n                ),", "                    ]\n                ),\n            ),\n        },\n        {\n            \"description\": \"requester is an approver, but self approval is not allowed, and there is other approver - RequiresApproval\",\n            \"in\": {\n                \"statements\": frozenset(\n                    [\n                        Statement.parse_obj(", "                    [\n                        Statement.parse_obj(\n                            {\n                                \"resource_type\": \"Account\",\n                                \"resource\": [\"111111111111\"],\n                                \"permission_set\": [\"AdministratorAccess\"],\n                                \"approvers\": [\"approver@example.com\", \"approver2@example.com\"],\n                            }\n                        )\n                    ]", "                        )\n                    ]\n                ),\n                \"account_id\": \"111111111111\",\n                \"permission_set_name\": \"AdministratorAccess\",\n                \"requester_email\": \"approver@example.com\",\n            },\n            \"out\": AccessRequestDecision(\n                grant=False,\n                reason=DecisionReason.RequiresApproval,", "                grant=False,\n                reason=DecisionReason.RequiresApproval,\n                based_on_statements=frozenset(\n                    [\n                        Statement.parse_obj(\n                            {\n                                \"resource_type\": \"Account\",\n                                \"resource\": [\"111111111111\"],\n                                \"permission_set\": [\"AdministratorAccess\"],\n                                \"approvers\": [\"approver@example.com\", \"approver2@example.com\"],", "                                \"permission_set\": [\"AdministratorAccess\"],\n                                \"approvers\": [\"approver@example.com\", \"approver2@example.com\"],\n                            }\n                        )\n                    ]\n                ),\n                approvers=frozenset({\"approver2@example.com\"}),\n            ),\n        },\n        {", "        },\n        {\n            \"description\": \"self approval is allowed and requester is approver -SelfApproval\",\n            \"in\": {\n                \"statements\": frozenset(\n                    [\n                        Statement.parse_obj(\n                            {\n                                \"resource_type\": \"Account\",\n                                \"resource\": [\"*\"],", "                                \"resource_type\": \"Account\",\n                                \"resource\": [\"*\"],\n                                \"permission_set\": [\"*\"],\n                                \"approvers\": [\"approver@example.com\"],\n                                \"allow_self_approval\": True,\n                            }\n                        )\n                    ]\n                ),\n                \"account_id\": \"111111111111\",", "                ),\n                \"account_id\": \"111111111111\",\n                \"permission_set_name\": \"AdministratorAccess\",\n                \"requester_email\": \"approver@example.com\",\n            },\n            \"out\": AccessRequestDecision(\n                grant=True,\n                reason=DecisionReason.SelfApproval,\n                based_on_statements=frozenset(\n                    [", "                based_on_statements=frozenset(\n                    [\n                        Statement.parse_obj(\n                            {\n                                \"resource_type\": \"Account\",\n                                \"resource\": [\"*\"],\n                                \"permission_set\": [\"*\"],\n                                \"approvers\": [\"approver@example.com\"],\n                                \"allow_self_approval\": True,\n                            }", "                                \"allow_self_approval\": True,\n                            }\n                        )\n                    ]\n                ),\n            ),\n        },\n        {\n            \"description\": \"no approvers - NoApprovers\",\n            \"in\": {", "            \"description\": \"no approvers - NoApprovers\",\n            \"in\": {\n                \"statements\": frozenset(\n                    [\n                        Statement.parse_obj(\n                            {\n                                \"resource_type\": \"Account\",\n                                \"resource\": [\"*\"],\n                                \"permission_set\": [\"*\"],\n                            }", "                                \"permission_set\": [\"*\"],\n                            }\n                        )\n                    ]\n                ),\n                \"account_id\": \"111111111111\",\n                \"permission_set_name\": \"AdministratorAccess\",\n                \"requester_email\": \"example@example.com\",\n            },\n            \"out\": AccessRequestDecision(", "            },\n            \"out\": AccessRequestDecision(\n                grant=False,\n                reason=DecisionReason.NoApprovers,\n                based_on_statements=frozenset(\n                    frozenset(\n                        [\n                            Statement.parse_obj(\n                                {\n                                    \"resource_type\": \"Account\",", "                                {\n                                    \"resource_type\": \"Account\",\n                                    \"resource\": [\"*\"],\n                                    \"permission_set\": [\"*\"],\n                                }\n                            )\n                        ]\n                    )\n                ),\n            ),", "                ),\n            ),\n        },\n        {\n            \"description\": \"requester is an approver, but self approval is not allowed - NoApprovers\",\n            \"in\": {\n                \"statements\": frozenset(\n                    [\n                        Statement.parse_obj(\n                            {", "                        Statement.parse_obj(\n                            {\n                                \"resource_type\": \"Account\",\n                                \"resource\": [\"111111111111\"],\n                                \"permission_set\": [\"AdministratorAccess\"],\n                                \"approvers\": [\"approver@example.com\"],\n                            }\n                        )\n                    ]\n                ),", "                    ]\n                ),\n                \"account_id\": \"111111111111\",\n                \"permission_set_name\": \"AdministratorAccess\",\n                \"requester_email\": \"approver@example.com\",\n            },\n            \"out\": AccessRequestDecision(\n                grant=False,\n                reason=DecisionReason.NoApprovers,\n                based_on_statements=frozenset(", "                reason=DecisionReason.NoApprovers,\n                based_on_statements=frozenset(\n                    [\n                        Statement.parse_obj(\n                            {\n                                \"resource_type\": \"Account\",\n                                \"resource\": [\"111111111111\"],\n                                \"permission_set\": [\"AdministratorAccess\"],\n                                \"approvers\": [\"approver@example.com\"],\n                            }", "                                \"approvers\": [\"approver@example.com\"],\n                            }\n                        )\n                    ]\n                ),\n            ),\n        },\n        {\n            \"description\": \"no approvers but self approval is allowed - NoApprovers\",\n            \"in\": {", "            \"description\": \"no approvers but self approval is allowed - NoApprovers\",\n            \"in\": {\n                \"statements\": frozenset(\n                    [\n                        Statement.parse_obj(\n                            {\n                                \"resource_type\": \"Account\",\n                                \"resource\": [\"*\"],\n                                \"permission_set\": [\"*\"],\n                                \"allow_self_approval\": True,", "                                \"permission_set\": [\"*\"],\n                                \"allow_self_approval\": True,\n                            }\n                        )\n                    ]\n                ),\n                \"account_id\": \"111111111111\",\n                \"permission_set_name\": \"AdministratorAccess\",\n                \"requester_email\": \"example@example.com\",\n            },", "                \"requester_email\": \"example@example.com\",\n            },\n            \"out\": AccessRequestDecision(\n                grant=False,\n                reason=DecisionReason.NoApprovers,\n                based_on_statements=frozenset(\n                    frozenset(\n                        [\n                            Statement.parse_obj(\n                                {", "                            Statement.parse_obj(\n                                {\n                                    \"resource_type\": \"Account\",\n                                    \"resource\": [\"*\"],\n                                    \"permission_set\": [\"*\"],\n                                    \"allow_self_approval\": True,\n                                }\n                            )\n                        ]\n                    )", "                        ]\n                    )\n                ),\n            ),\n        },\n        {\n            \"description\": \"statement is not affected by the access request - NoStatements\",\n            \"in\": {\n                \"statements\": frozenset(\n                    [", "                \"statements\": frozenset(\n                    [\n                        Statement.parse_obj(\n                            {\n                                \"resource_type\": \"Account\",\n                                \"resource\": [\"111111111111\"],\n                                \"permission_set\": [\"ReadOnlyAccess\"],\n                                \"approvers\": [\"approver@example.com\"],\n                            }\n                        ),", "                            }\n                        ),\n                    ]\n                ),\n                \"account_id\": \"111111111111\",\n                \"permission_set_name\": \"AdministratorAccess\",\n                \"requester_email\": \"requester@example.com\",\n            },\n            \"out\": AccessRequestDecision(\n                grant=False,", "            \"out\": AccessRequestDecision(\n                grant=False,\n                reason=DecisionReason.NoStatements,\n                based_on_statements=frozenset([]),\n            ),\n        },\n        {\n            \"description\": \"multiple statements affecting the access request, some require approval and some don't\",\n            \"in\": {\n                \"statements\": frozenset(", "            \"in\": {\n                \"statements\": frozenset(\n                    [\n                        Statement.parse_obj(\n                            {\n                                \"resource_type\": \"Account\",\n                                \"resource\": [\"111111111111\"],\n                                \"permission_set\": [\"AdministratorAccess\"],\n                                \"approvers\": [\"approver@example.com\"],\n                            }", "                                \"approvers\": [\"approver@example.com\"],\n                            }\n                        ),\n                        Statement.parse_obj(\n                            {\n                                \"resource_type\": \"Account\",\n                                \"resource\": [\"111111111111\"],\n                                \"permission_set\": [\"AdministratorAccess\"],\n                                \"approval_is_not_required\": True,\n                            }", "                                \"approval_is_not_required\": True,\n                            }\n                        ),\n                    ]\n                ),\n                \"account_id\": \"111111111111\",\n                \"permission_set_name\": \"AdministratorAccess\",\n                \"requester_email\": \"approver@example.com\",\n            },\n            \"out\": AccessRequestDecision(", "            },\n            \"out\": AccessRequestDecision(\n                grant=True,\n                reason=DecisionReason.ApprovalNotRequired,\n                based_on_statements=frozenset(\n                    [\n                        Statement.parse_obj(\n                            {\n                                \"resource_type\": \"Account\",\n                                \"resource\": [\"111111111111\"],", "                                \"resource_type\": \"Account\",\n                                \"resource\": [\"111111111111\"],\n                                \"permission_set\": [\"AdministratorAccess\"],\n                                \"approval_is_not_required\": True,\n                            }\n                        ),\n                    ]\n                ),\n            ),\n        },", "            ),\n        },\n        {\n            \"description\": \"multiple statements affecting the access request, with different sets of approvers.\",\n            \"in\": {\n                \"statements\": frozenset(\n                    [\n                        Statement.parse_obj(\n                            {\n                                \"resource_type\": \"Account\",", "                            {\n                                \"resource_type\": \"Account\",\n                                \"resource\": [\"111111111111\"],\n                                \"permission_set\": [\"AdministratorAccess\"],\n                                \"approvers\": [\"approver1@example.com\"],\n                            }\n                        ),\n                        Statement.parse_obj(\n                            {\n                                \"resource_type\": \"Account\",", "                            {\n                                \"resource_type\": \"Account\",\n                                \"resource\": [\"111111111111\"],\n                                \"permission_set\": [\"AdministratorAccess\"],\n                                \"approvers\": [\"approver2@example.com\"],\n                            }\n                        ),\n                    ]\n                ),\n                \"account_id\": \"111111111111\",", "                ),\n                \"account_id\": \"111111111111\",\n                \"permission_set_name\": \"AdministratorAccess\",\n                \"requester_email\": \"requester@example.com\",\n            },\n            \"out\": AccessRequestDecision(\n                grant=False,\n                reason=DecisionReason.RequiresApproval,\n                approvers=frozenset([\"approver1@example.com\", \"approver2@example.com\"]),\n                based_on_statements=frozenset(", "                approvers=frozenset([\"approver1@example.com\", \"approver2@example.com\"]),\n                based_on_statements=frozenset(\n                    [\n                        Statement.parse_obj(\n                            {\n                                \"resource_type\": \"Account\",\n                                \"resource\": [\"111111111111\"],\n                                \"permission_set\": [\"AdministratorAccess\"],\n                                \"approvers\": [\"approver1@example.com\"],\n                            }", "                                \"approvers\": [\"approver1@example.com\"],\n                            }\n                        ),\n                        Statement.parse_obj(\n                            {\n                                \"resource_type\": \"Account\",\n                                \"resource\": [\"111111111111\"],\n                                \"permission_set\": [\"AdministratorAccess\"],\n                                \"approvers\": [\"approver2@example.com\"],\n                            }", "                                \"approvers\": [\"approver2@example.com\"],\n                            }\n                        ),\n                    ]\n                ),\n            ),\n        },\n    ],\n    ids=lambda t: t[\"description\"],\n)\ndef test_cases_for_access_request_decision(request):\n    return request.param", "    ids=lambda t: t[\"description\"],\n)\ndef test_cases_for_access_request_decision(request):\n    return request.param\n\n\n@pytest.fixture(\n    params=[\n        {\n            \"description\": \"approver is approver\",", "        {\n            \"description\": \"approver is approver\",\n            \"in\": {\n                \"action\": entities.ApproverAction.Approve,\n                \"statements\": frozenset(\n                    [\n                        Statement.parse_obj(\n                            {\n                                \"resource_type\": \"Account\",\n                                \"resource\": [\"111111111111\"],", "                                \"resource_type\": \"Account\",\n                                \"resource\": [\"111111111111\"],\n                                \"permission_set\": [\"AdministratorAccess\"],\n                                \"approvers\": [\"approver@example.com\"],\n                            }\n                        )\n                    ]\n                ),\n                \"account_id\": \"111111111111\",\n                \"permission_set_name\": \"AdministratorAccess\",", "                \"account_id\": \"111111111111\",\n                \"permission_set_name\": \"AdministratorAccess\",\n                \"requester_email\": \"requester@example.com\",\n                \"approver_email\": \"approver@example.com\",\n            },\n            \"out\": ApproveRequestDecision(\n                grant=True,\n                permit=True,\n                based_on_statements=frozenset(\n                    [", "                based_on_statements=frozenset(\n                    [\n                        Statement.parse_obj(\n                            {\n                                \"resource_type\": \"Account\",\n                                \"resource\": [\"111111111111\"],\n                                \"permission_set\": [\"AdministratorAccess\"],\n                                \"approvers\": [\"approver@example.com\"],\n                            }\n                        )", "                            }\n                        )\n                    ]\n                ),\n            ),\n        },\n        {\n            \"description\": \"approver is approver but self approval is not allowed\",\n            \"in\": {\n                \"action\": entities.ApproverAction.Approve,", "            \"in\": {\n                \"action\": entities.ApproverAction.Approve,\n                \"statements\": frozenset(\n                    [\n                        Statement.parse_obj(\n                            {\n                                \"resource_type\": \"Account\",\n                                \"resource\": [\"111111111111\"],\n                                \"permission_set\": [\"AdministratorAccess\"],\n                                \"approvers\": [\"approver@example.com\"],", "                                \"permission_set\": [\"AdministratorAccess\"],\n                                \"approvers\": [\"approver@example.com\"],\n                                \"allow_self_approval\": False,\n                            }\n                        )\n                    ]\n                ),\n                \"account_id\": \"111111111111\",\n                \"permission_set_name\": \"AdministratorAccess\",\n                \"requester_email\": \"approver@example.com\",", "                \"permission_set_name\": \"AdministratorAccess\",\n                \"requester_email\": \"approver@example.com\",\n                \"approver_email\": \"approver@example.com\",\n            },\n            \"out\": ApproveRequestDecision(\n                grant=False,\n                permit=False,\n                based_on_statements=frozenset(\n                    [\n                        Statement.parse_obj(", "                    [\n                        Statement.parse_obj(\n                            {\n                                \"resource_type\": \"Account\",\n                                \"resource\": [\"111111111111\"],\n                                \"permission_set\": [\"AdministratorAccess\"],\n                                \"approvers\": [\"approver@example.com\"],\n                            }\n                        )\n                    ]", "                        )\n                    ]\n                ),\n            ),\n        },\n        {\n            \"description\": \"approver is not an approver\",\n            \"in\": {\n                \"action\": entities.ApproverAction.Approve,\n                \"statements\": frozenset(", "                \"action\": entities.ApproverAction.Approve,\n                \"statements\": frozenset(\n                    [\n                        Statement.parse_obj(\n                            {\n                                \"resource_type\": \"Account\",\n                                \"resource\": [\"111111111111\"],\n                                \"permission_set\": [\"AdministratorAccess\"],\n                                \"approvers\": [\"approver@example.com\"],\n                            }", "                                \"approvers\": [\"approver@example.com\"],\n                            }\n                        )\n                    ]\n                ),\n                \"account_id\": \"222222222222\",\n                \"permission_set_name\": \"AdministratorAccess\",\n                \"requester_email\": \"requester@example.com\",\n                \"approver_email\": \"notapprover@example.com\",\n            },", "                \"approver_email\": \"notapprover@example.com\",\n            },\n            \"out\": ApproveRequestDecision(\n                grant=False,\n                permit=False,\n                based_on_statements=frozenset(),\n            ),\n        },\n    ],\n    ids=lambda t: t[\"description\"],", "    ],\n    ids=lambda t: t[\"description\"],\n)\ndef test_cases_for_approve_request_decision(request):\n    return request.param\n\n\ndef test_make_decision_on_access_request(test_cases_for_access_request_decision):\n    assert make_decision_on_access_request(**test_cases_for_access_request_decision[\"in\"]) == test_cases_for_access_request_decision[\"out\"]\n", "\n\ndef test_make_decision_on_approve_request(test_cases_for_approve_request_decision):\n    assert (\n        make_decision_on_approve_request(**test_cases_for_approve_request_decision[\"in\"]) == test_cases_for_approve_request_decision[\"out\"]\n    )\n\n\ndef test_execute_access_request_decision(\n    test_cases_for_access_request_decision,\n    execute_decision_info,\n):\n    if test_cases_for_access_request_decision[\"out\"].grant is not True:\n        assert execute_decision(decision=test_cases_for_access_request_decision[\"out\"], **execute_decision_info) is False", "def test_execute_access_request_decision(\n    test_cases_for_access_request_decision,\n    execute_decision_info,\n):\n    if test_cases_for_access_request_decision[\"out\"].grant is not True:\n        assert execute_decision(decision=test_cases_for_access_request_decision[\"out\"], **execute_decision_info) is False\n\n\ndef test_execute_approve_request_decision(\n    test_cases_for_approve_request_decision,\n    execute_decision_info,\n):\n    if test_cases_for_approve_request_decision[\"out\"].grant is not True:\n        assert execute_decision(decision=test_cases_for_approve_request_decision[\"out\"], **execute_decision_info) is False", "def test_execute_approve_request_decision(\n    test_cases_for_approve_request_decision,\n    execute_decision_info,\n):\n    if test_cases_for_approve_request_decision[\"out\"].grant is not True:\n        assert execute_decision(decision=test_cases_for_approve_request_decision[\"out\"], **execute_decision_info) is False\n\n\ndef test_make_and_excute_access_request_decision(\n    test_cases_for_access_request_decision,\n    execute_decision_info,\n):\n    decision = make_decision_on_access_request(**test_cases_for_access_request_decision[\"in\"])\n    if decision.grant is not True:\n        assert execute_decision(decision=decision, **execute_decision_info) is False", "def test_make_and_excute_access_request_decision(\n    test_cases_for_access_request_decision,\n    execute_decision_info,\n):\n    decision = make_decision_on_access_request(**test_cases_for_access_request_decision[\"in\"])\n    if decision.grant is not True:\n        assert execute_decision(decision=decision, **execute_decision_info) is False\n\n\ndef test_make_and_excute_approve_request_decision(\n    test_cases_for_approve_request_decision,\n    execute_decision_info,\n):\n    decision = make_decision_on_approve_request(**test_cases_for_approve_request_decision[\"in\"])\n    if decision.grant is not True:\n        assert execute_decision(decision=decision, **execute_decision_info) is False", "\ndef test_make_and_excute_approve_request_decision(\n    test_cases_for_approve_request_decision,\n    execute_decision_info,\n):\n    decision = make_decision_on_approve_request(**test_cases_for_approve_request_decision[\"in\"])\n    if decision.grant is not True:\n        assert execute_decision(decision=decision, **execute_decision_info) is False\n", ""]}
{"filename": "src/tests/__init__.py", "chunked_list": [""]}
{"filename": "src/tests/test_config.py", "chunked_list": ["import json\nimport os\n\nfrom hypothesis import example, given, settings\nfrom hypothesis import strategies as st\nfrom hypothesis.strategies import SearchStrategy\nfrom pydantic import ValidationError\n\nimport config\n", "import config\n\nfrom . import strategies\n\n# ruff: noqa\nVALID_STATEMENT_DICT = {\n    \"ResourceType\": \"Account\",\n    \"Resource\": [\"111111111111\"],\n    \"PermissionSet\": \"AdministratorAccess\",\n    \"Approvers\": \"example@gmail.com\",", "    \"PermissionSet\": \"AdministratorAccess\",\n    \"Approvers\": \"example@gmail.com\",\n}\n\n\n@given(strategies.statement_dict())\n@settings(max_examples=100)\n@example({}).xfail(raises=KeyError, reason=\"Empty dict is not a valid statement\")\n@example(VALID_STATEMENT_DICT)\ndef test_parse_statement(dict_statement: dict):", "@example(VALID_STATEMENT_DICT)\ndef test_parse_statement(dict_statement: dict):\n    try:\n        config.parse_statement(dict_statement)\n    except ValidationError:\n        assert False\n\n\ndef config_dict(statements: SearchStrategy = strategies.jsonstr(st.lists(strategies.statement_dict()))):\n    return st.fixed_dictionaries(", "def config_dict(statements: SearchStrategy = strategies.jsonstr(st.lists(strategies.statement_dict()))):\n    return st.fixed_dictionaries(\n        {\n            \"schedule_policy_arn\": strategies.json_safe_text,\n            \"revoker_function_arn\": strategies.json_safe_text,\n            \"revoker_function_name\": strategies.json_safe_text,\n            \"schedule_group_name\": strategies.json_safe_text,\n            \"slack_channel_id\": strategies.json_safe_text,\n            \"slack_bot_token\": strategies.json_safe_text,\n            \"sso_instance_arn\": strategies.json_safe_text,", "            \"slack_bot_token\": strategies.json_safe_text,\n            \"sso_instance_arn\": strategies.json_safe_text,\n            \"s3_bucket_for_audit_entry_name\": strategies.json_safe_text,\n            \"s3_bucket_prefix_for_partitions\": strategies.json_safe_text,\n            \"sso_elevator_scheduled_revocation_rule_name\": strategies.json_safe_text,\n            \"log_level\": st.one_of(st.just(\"INFO\"), st.just(\"DEBUG\"), st.just(\"WARNING\"), st.just(\"ERROR\"), st.just(\"CRITICAL\")),\n            \"post_update_to_slack\": strategies.str_bool,\n            \"statements\": statements,\n            \"request_expiration_hours\": st.integers(min_value=0, max_value=24),\n            \"approver_renotification_initial_wait_time\": st.integers(min_value=0, max_value=60),", "            \"request_expiration_hours\": st.integers(min_value=0, max_value=24),\n            \"approver_renotification_initial_wait_time\": st.integers(min_value=0, max_value=60),\n            \"approver_renotification_backoff_multiplier\": st.integers(min_value=0, max_value=10),\n            \"max_permissions_duration_time\": st.integers(min_value=0, max_value=24),\n        }\n    )\n\n\ndef valid_config_dict(statements_as_json: bool = True):\n    if statements_as_json:", "def valid_config_dict(statements_as_json: bool = True):\n    if statements_as_json:\n        statements = json.dumps([VALID_STATEMENT_DICT])\n    else:\n        statements = [VALID_STATEMENT_DICT]\n    return {\n        \"schedule_policy_arn\": \"x\",\n        \"revoker_function_arn\": \"x\",\n        \"revoker_function_name\": \"x\",\n        \"schedule_group_name\": \"x\",", "        \"revoker_function_name\": \"x\",\n        \"schedule_group_name\": \"x\",\n        \"slack_channel_id\": \"x\",\n        \"slack_bot_token\": \"x\",\n        \"sso_instance_arn\": \"x\",\n        \"log_level\": \"INFO\",\n        \"post_update_to_slack\": \"False\",\n        \"statements\": statements,\n        \"s3_bucket_for_audit_entry_name\": \"x\",\n        \"s3_bucket_prefix_for_partitions\": \"x\",", "        \"s3_bucket_for_audit_entry_name\": \"x\",\n        \"s3_bucket_prefix_for_partitions\": \"x\",\n        \"sso_elevator_scheduled_revocation_rule_name\": \"x\",\n        \"request_expiration_hours\": \"8\",\n        \"approver_renotification_initial_wait_time\": \"15\",\n        \"approver_renotification_backoff_multiplier\": \"2\",\n        \"max_permissions_duration_time\": \"24\",\n\n    }\n", "    }\n\n\n@given(config_dict())\n@example(valid_config_dict())\n@example({}).xfail(raises=ValidationError, reason=\"Empty dict is not a valid config\")\n@example(valid_config_dict() | {\"post_update_to_slack\": \"x\"}).xfail(raises=ValidationError, reason=\"Invalid bool\")\n@settings(max_examples=50)\ndef test_config_load_environment_variables(dict_config: dict):\n    os.environ = dict_config", "def test_config_load_environment_variables(dict_config: dict):\n    os.environ = dict_config\n    config.Config()  # type: ignore\n\n\n@given(config_dict(statements=st.lists(strategies.statement_dict(), max_size=20)))\n@settings(max_examples=50)\n@example(valid_config_dict(statements_as_json=False))\n@example(valid_config_dict(statements_as_json=False) | {\"post_update_to_slack\": \"x\"}).xfail(raises=ValidationError, reason=\"Invalid bool\")\ndef test_config_init(dict_config: dict):", "@example(valid_config_dict(statements_as_json=False) | {\"post_update_to_slack\": \"x\"}).xfail(raises=ValidationError, reason=\"Invalid bool\")\ndef test_config_init(dict_config: dict):\n    config.Config(**dict_config)\n"]}
{"filename": "src/tests/utils.py", "chunked_list": ["import base64\nimport json\nimport os\nimport uuid\nfrom urllib.parse import parse_qsl, urlencode\n\nfrom aws_lambda_powertools.utilities.typing import LambdaContext\n\n# ruff: noqa: ANN201, ANN001, ANN204, ANN101\n", "# ruff: noqa: ANN201, ANN001, ANN204, ANN101\n\n\ndef decode_body(raw_body: str) -> dict:\n    \"\"\"Decode the body of a Slack request\"\"\"\n    body = base64.b64decode(raw_body).decode(\"utf-8\")\n    body_dict = dict(parse_qsl(body))\n    json_payload = body_dict[\"payload\"]\n    return json.loads(json_payload)\n", "\n\ndef encode_body(payload: dict) -> str:\n    \"\"\"Encode the body of a Slack request\"\"\"\n    json_payload = json.dumps(payload, separators=(\",\", \":\"))\n    body_dict = {\"payload\": json_payload}\n    qls = urlencode(body_dict)\n    return base64.b64encode(qls.encode(\"utf-8\")).decode(\"utf-8\")\n\n\ndef get_lambda_env_vars(lambda_client, function_name: str, qualifier: str = \"$LATEST\") -> dict:\n    print(f\"Getting environment variables from lambda {function_name}:{qualifier}...\")\n    return lambda_client.get_function_configuration(FunctionName=function_name, Qualifier=qualifier)[\"Environment\"][\"Variables\"]", "\n\ndef get_lambda_env_vars(lambda_client, function_name: str, qualifier: str = \"$LATEST\") -> dict:\n    print(f\"Getting environment variables from lambda {function_name}:{qualifier}...\")\n    return lambda_client.get_function_configuration(FunctionName=function_name, Qualifier=qualifier)[\"Environment\"][\"Variables\"]\n\n\ndef update_local_env_vars_from_lambda(lambda_client, function_name: str, qualifier: str = \"$LATEST\"):\n    lambda_env_vars = get_lambda_env_vars(lambda_client, function_name, qualifier)\n    os.environ |= lambda_env_vars\n    print(f\"Local environment variables updated from lambda {function_name}:{qualifier}!\")", "\n\nclass LambdaTestContext(LambdaContext):\n    def __init__(self, name: str, version: int = 1, region: str = \"us-east-1\", account_id: str = \"111122223333\"):\n        self._function_name = name\n        self._function_version = str(version)\n        self._memory_limit_in_mb = 128\n        self._invoked_function_arn = f\"arn:aws:lambda:{region}:{account_id}:function:{name}:{version}\"\n        self._aws_request_id = str(uuid.uuid4())\n        self._log_group_name = f\"/aws/lambda/{name}\"\n        self._log_stream_name = str(uuid.uuid4())", ""]}
{"filename": "src/tests/strategies.py", "chunked_list": ["import json\nimport string\nfrom typing import Literal\n\nfrom hypothesis import strategies as st\nfrom hypothesis.strategies import SearchStrategy\n\n# ruff: noqa: ANN201\n\n\ndef jsonstr(strategy: SearchStrategy) -> SearchStrategy:\n    return st.builds(\n        json.dumps,\n        strategy,\n    )", "\n\ndef jsonstr(strategy: SearchStrategy) -> SearchStrategy:\n    return st.builds(\n        json.dumps,\n        strategy,\n    )\n\n\n# https://docs.aws.amazon.com/organizations/latest/APIReference/API_CreateAccountStatus.html", "\n# https://docs.aws.amazon.com/organizations/latest/APIReference/API_CreateAccountStatus.html\naws_account_id = st.text(min_size=12, max_size=12, alphabet=string.digits)\n\n# https://docs.aws.amazon.com/singlesignon/latest/APIReference/API_CreatePermissionSet.html#singlesignon-CreatePermissionSet-request-Name\naws_permission_set_name = st.text(min_size=1, max_size=32, alphabet=string.ascii_letters + string.digits + \"_+=,.@-\")\n\n# https://docs.aws.amazon.com/organizations/latest/APIReference/API_CreateOrganizationalUnit.html#organizations-CreateOrganizationalUnit-request-Name\naws_organization_unit_name = st.text(min_size=1, max_size=128, alphabet=string.ascii_letters)\n", "aws_organization_unit_name = st.text(min_size=1, max_size=128, alphabet=string.ascii_letters)\n\nstatement_approvers = st.frozensets(st.emails(), min_size=1, max_size=10)\n\nstr_bool = st.one_of(st.just(str(True)), st.just(str(False)))\n\njson_safe_text = st.text(\n    alphabet=st.characters(\n        blacklist_categories=(\"Cs\", \"Cc\", \"Cf\", \"Co\", \"Cn\"),\n        blacklist_characters=(\"/\"),", "        blacklist_categories=(\"Cs\", \"Cc\", \"Cf\", \"Co\", \"Cn\"),\n        blacklist_characters=(\"/\"),\n    ),\n    min_size=1,\n    max_size=200,\n)\n\n\ndef resource_type_st(resource_type: Literal[\"Account\", \"OU\", \"Any\"] = \"Any\"):\n    if resource_type == \"Account\":\n        return st.just(\"Account\")\n    elif resource_type == \"OU\":\n        return st.just(\"OU\")\n    elif resource_type == \"Any\":\n        return st.sampled_from([\"Account\", \"OU\"])\n    raise ValueError(f\"Unknown resource type: {resource_type}\")", "def resource_type_st(resource_type: Literal[\"Account\", \"OU\", \"Any\"] = \"Any\"):\n    if resource_type == \"Account\":\n        return st.just(\"Account\")\n    elif resource_type == \"OU\":\n        return st.just(\"OU\")\n    elif resource_type == \"Any\":\n        return st.sampled_from([\"Account\", \"OU\"])\n    raise ValueError(f\"Unknown resource type: {resource_type}\")\n\n", "\n\n@st.composite\ndef resource(draw: st.DrawFn, resource_type: SearchStrategy[str]):\n    r_type = draw(resource_type)\n    if r_type == \"Account\":\n        return draw(aws_account_id)\n    elif r_type == \"OU\":\n        return draw(aws_organization_unit_name)\n    raise ValueError(f\"Unknown resource type: {r_type}\")", "\n\ndef statement_dict(\n    resource_type: Literal[\"Account\", \"OU\", \"Any\"] = \"Account\",\n):\n    resource_type_strategy = st.shared(resource_type_st(resource_type))\n    resource_strategy = resource(resource_type_strategy)\n    return st.fixed_dictionaries(\n        mapping={\n            \"ResourceType\": resource_type_strategy,\n            \"Resource\": st.one_of(resource_strategy, st.lists(resource_strategy, max_size=20), st.just(\"*\")),\n            \"PermissionSet\": st.one_of(\n                aws_permission_set_name,\n                st.lists(aws_permission_set_name, max_size=20),\n                st.just(\"*\"),\n            ),\n        },\n        optional={\n            \"Approvers\": st.one_of(st.emails(), st.lists(st.emails(), max_size=20)),\n            \"ApprovalIsNotRequired\": st.booleans(),\n            \"AllowSelfApproval\": st.booleans(),\n        },\n    )", ""]}
{"filename": "src/tests/conftest.py", "chunked_list": ["import os\n\nimport boto3\n\n\ndef pytest_sessionstart(session):  # noqa: ANN201, ARG001, ANN001\n    mock_env = {\n        \"schedule_policy_arn\": \"x\",\n        \"revoker_function_arn\": \"x\",\n        \"revoker_function_name\": \"x\",\n        \"schedule_group_name\": \"x\",\n        \"post_update_to_slack\": \"true\",\n        \"slack_channel_id\": \"x\",\n        \"slack_bot_token\": \"x\",\n        \"sso_instance_arn\": \"x\",\n        \"log_level\": \"DEBUG\",\n        \"slack_app_log_level\": \"INFO\",\n        \"s3_bucket_for_audit_entry_name\": \"x\",\n        \"s3_bucket_prefix_for_partitions\": \"x\",\n        \"sso_elevator_scheduled_revocation_rule_name\": \"x\",\n        \"request_expiration_hours\": \"8\",\n        \"approver_renotification_initial_wait_time\": \"15\",\n        \"approver_renotification_backoff_multiplier\": \"2\",\n        \"max_permissions_duration_time\": \"24\"\n\n    }\n    os.environ |= mock_env\n\n    boto3.setup_default_session(region_name=\"us-east-1\")", ""]}
{"filename": "src/entities/aws.py", "chunked_list": ["from typing import Optional\n\nfrom .model import BaseModel\n\n\nclass Account(BaseModel):\n    id: str\n    name: str\n\n\nclass PermissionSet(BaseModel):\n    name: str\n    arn: str\n    description: Optional[str]", "\n\nclass PermissionSet(BaseModel):\n    name: str\n    arn: str\n    description: Optional[str]\n"]}
{"filename": "src/entities/model.py", "chunked_list": ["import dataclasses\nimport enum\nfrom typing import FrozenSet\n\nfrom pydantic import BaseModel as PydanticBaseModel\n\n\nclass BaseModel(PydanticBaseModel):\n    class Config:\n        frozen = True\n\n    def dict(self, *args, **kwargs) -> dict:  # noqa: ANN101, ANN003, ANN002\n        \"\"\"Converts instance to dict representation of it. Workaround for https://github.com/pydantic/pydantic/issues/1090\"\"\"\n        cp = super().copy()\n        cp.Config.frozen = False\n        for field_name in cp.__fields__.keys():\n            attr = cp.__getattribute__(field_name)\n            if isinstance(attr, FrozenSet):\n                cp.__setattr__(field_name, list(attr))\n\n        cp.Config.frozen = True\n        # frozendict.frozendict(?)\n        return PydanticBaseModel.dict(cp, *args, **kwargs)", "\n\ndef json_default(o: object) -> str | dict:\n    if isinstance(o, PydanticBaseModel):\n        return o.dict()\n    elif dataclasses.is_dataclass(o):\n        return dataclasses.asdict(o)\n    elif isinstance(o, enum.Enum):\n        return o.value\n    return str(o)", ""]}
{"filename": "src/entities/slack.py", "chunked_list": ["from enum import Enum\n\nfrom .model import BaseModel\n\n\nclass ApproverAction(Enum):\n    Approve = \"approve\"\n    Discard = \"discard\"\n\n\nclass User(BaseModel):\n    id: str\n    email: str\n    real_name: str", "\n\nclass User(BaseModel):\n    id: str\n    email: str\n    real_name: str\n"]}
{"filename": "src/entities/__init__.py", "chunked_list": ["# ruff: noqa: F401\nfrom . import aws, slack\nfrom .model import BaseModel, json_default\nfrom .slack import ApproverAction\n"]}
