{"filename": "backend/ingestion/tests/__init__.py", "chunked_list": [""]}
{"filename": "backend/ingestion/tests/test_file_system_tree.py", "chunked_list": ["import os\nimport unittest\nimport platform\nimport networkx as nx\nfrom hashlib import sha256\nfrom unittest.mock import MagicMock, patch\nfrom server.server.system.fstree import FileSystemTree\n\n\nclass TestFileSystemTree(unittest.TestCase):\n    def setUp(self) -> None:\n        self.test_uri = \"neo4j://localhost:7687\"\n        self.test_user = \"neo4j\"\n        self.test_password = \"password\"\n\n    def test_init(self) -> None:\n        with patch(\"neo4j.GraphDatabase.driver\") as mock_driver:\n            fst = FileSystemTree(self.test_uri, self.test_user, self.test_password)\n            mock_driver.assert_called_once_with(\n                self.test_uri, auth=(self.test_user, self.test_password)\n            )\n\n    def test_ready(self) -> None:\n        with patch(\"builtins.print\") as mock_print:\n            with FileSystemTree(\n                self.test_uri, self.test_user, self.test_password\n            ) as fst:\n                fst.ready()\n                mock_print.assert_called_once_with(\"started neo4j\")\n\n    def test_close(self) -> None:\n        with patch(\"neo4j.GraphDatabase.driver\") as mock_driver:\n            with FileSystemTree(\n                self.test_uri, self.test_user, self.test_password\n            ) as fst:\n                fst.close()\n                fst.driver.close.assert_called_once()\n\n    def test_print_greeting(self) -> None:\n        test_message = \"Hello, World!\"\n        with patch(\"neo4j.GraphDatabase.driver\") as mock_driver:\n            session = MagicMock()\n            mock_driver.return_value.session.return_value.__enter__.return_value = (\n                session\n            )\n            fst = FileSystemTree(self.test_uri, self.test_user, self.test_password)\n            with patch(\"builtins.print\") as mock_print:\n                fst.print_greeting(test_message)\n                session.execute_write.assert_called_once()\n                mock_print.assert_called_once()\n\n    def test_get_system_info(self) -> None:\n        # get system info using the function\n        with FileSystemTree(\n                self.test_uri, self.test_user, self.test_password\n            ) as fst:\n            system_info = fst.get_system_info()\n\n            # verify that the output is correct\n            assert isinstance(system_info, dict)\n            assert \"platform\" in system_info and system_info[\"platform\"] == platform.system()\n            assert \"platform-release\" in system_info and system_info[\"platform-release\"] == platform.release()\n            assert \"platform-version\" in system_info and system_info[\"platform-version\"] == platform.version()\n            assert \"architecture\" in system_info and system_info[\"architecture\"] == platform.machine()\n            assert \"hostname\" in system_info and system_info[\"hostname\"] == platform.node()\n            assert \"processor\" in system_info and system_info[\"processor\"] == platform.processor()\n            assert \"ram\" in system_info and isinstance(system_info[\"ram\"], str) and \"GB\" in system_info[\"ram\"]\n            assert \"uptime\" in system_info and isinstance(system_info[\"uptime\"], int) and system_info[\"uptime\"] > 0\n\n    def test_map_file_system(self) -> None:\n        def cleanup(test_dir: str) -> None:\n            # clean up the temporary directory\n            os.remove(os.path.join(test_dir, \"file1.txt\"))\n            os.remove(os.path.join(test_dir, \"subdir\", \"file2.txt\"))\n            os.rmdir(os.path.join(test_dir, \"subdir\"))\n            os.rmdir(test_dir)\n\n        # create a temporary directory with some files and directories\n        base_dir = os.path.dirname(os.path.abspath(__file__))\n        test_dir = os.path.join(base_dir, \"test_dir\")\n        cleanup(test_dir)\n        os.makedirs(test_dir)\n        os.makedirs(os.path.join(test_dir, \"subdir\"))\n        with open(os.path.join(test_dir, \"file1.txt\"), \"w\") as f:\n            f.write(\"Hello, world!\")\n        with open(os.path.join(test_dir, \"subdir\", \"file2.txt\"), \"w\") as f:\n            f.write(\"Goodbye, world!\")\n\n        # run the map_file_system function\n        with FileSystemTree(\n                self.test_uri, self.test_user, self.test_password\n            ) as fst:\n            file_tree = fst.map_file_system(test_dir)\n            print(nx.to_dict_of_dicts(file_tree))\n\n            # verify that the output is correct\n            assert isinstance(file_tree, nx.DiGraph)\n            assert file_tree.has_node(test_dir)\n\n            print(f'file1: {os.path.join(test_dir, \"file1.txt\")}')\n            print(f'tree: {nx.to_dict_of_dicts(file_tree)}')\n\n            assert file_tree.has_node(os.path.join(test_dir, \"file1.txt\"))\n            assert file_tree.has_node(os.path.join(test_dir, \"subdir\"))\n            assert file_tree.has_node(os.path.join(test_dir, \"subdir\", \"file2.txt\"))\n            assert file_tree.nodes[test_dir][\"type\"] == \"directory\"\n            assert file_tree.nodes[os.path.join(test_dir, \"file1.txt\")][\"type\"] == \"file\"\n            assert file_tree.nodes[os.path.join(test_dir, \"subdir\")][\"type\"] == \"directory\"\n            assert file_tree.nodes[os.path.join(test_dir, \"subdir\", \"file2.txt\")][\"type\"] == \"file\"\n            assert file_tree.successors(test_dir) == [os.path.join(test_dir, \"file1.txt\"), os.path.join(test_dir, \"subdir\")]\n            assert file_tree.successors(os.path.join(test_dir, \"subdir\")) == [os.path.join(test_dir, \"subdir\", \"file2.txt\")]\n\n    def test__calculate_merkle_tree(self) -> None:\n        # Create a graph with nodes and attributes\n        G = nx.DiGraph()\n        G.add_node(\"a\", type=\"directory\")\n        G.add_node(\"b\", type=\"file\", name=\"file1.txt\")\n        G.add_node(\"c\", type=\"file\", name=\"file2.txt\")\n        G.add_edge(\"a\", \"b\")\n        G.add_edge(\"a\", \"c\")\n\n        with FileSystemTree(\n                self.test_uri, self.test_user, self.test_password\n            ) as fst:\n\n            # Calculate the Merkle tree\n            merkle_tree = fst._calculate_merkle_tree(G)\n\n            # Verify the expected hash values for each node\n            expected_hashes = {\n                \"a\": sha256(repr({\"type\": \"directory\"}).encode()).hexdigest(),\n                \"b\": sha256(repr({\"type\": \"file\", \"name\": \"file1.txt\"}).encode()).hexdigest(),\n                \"c\": sha256(repr({\"type\": \"file\", \"name\": \"file2.txt\"}).encode()).hexdigest(),\n            }\n            assert merkle_tree == expected_hashes\n\n\n    def test__find_differences(self) -> None:\n        # Create two Merkle trees\n        original_tree = {\"a\": \"hash1\", \"b\": \"hash2\", \"c\": \"hash3\"}\n        new_tree = {\"a\": \"hash1\", \"b\": \"newhash\", \"d\": \"hash4\"}\n\n        with FileSystemTree(\n                self.test_uri, self.test_user, self.test_password\n            ) as fst:\n            # Find the differences between the two trees\n            differences = fst._find_differences(original_tree, new_tree)\n\n            # Verify the expected differences\n            expected_differences = {\"b\": \"newhash\", \"c\": None, \"d\": \"hash4\"}\n            assert differences == expected_differences\n\n\n    def test_update_graph_with_merkle_tree(self) -> None:\n        # Create a graph with nodes and edges\n        G = nx.DiGraph()\n        G.add_node(\"a\", type=\"directory\")\n        G.add_node(\"b\", type=\"file\", name=\"file1.txt\")\n        G.add_node(\"c\", type=\"file\", name=\"file2.txt\")\n        G.add_edge(\"a\", \"b\")\n        G.add_edge(\"a\", \"c\")\n\n        # Write the graph to a file\n        graphml_file = \"test_graph.graphml\"\n        nx.write_graphml(G, graphml_file)\n\n        # Create a new file tree with some modifications\n        new_tree = nx.DiGraph()\n        new_tree.add_node(\"a\", type=\"directory\")\n        new_tree.add_node(\"b\", type=\"file\", name=\"file1.txt\", size=\"100KB\")\n        new_tree.add_edge(\"a\", \"b\")\n        new_tree.add_node(\"d\", type=\"file\", name=\"file3.txt\")\n        new_tree.add_edge(\"a\", \"d\")\n\n        with FileSystemTree(\n                self.test_uri, self.test_user, self.test_password\n            ) as fst:\n\n            # Update the original graph with the differences\n            updated_graph = fst.update_graph_with_merkle_tree(new_tree, graphml_file)\n\n            # Verify that the graph has been updated correctly\n            assert updated_graph.has_node(\"a\")\n            assert updated_graph.has_node(\"b\")\n            assert updated_graph.has_node(\"d\")\n            assert not updated_graph.has_node(\"c\")\n            assert updated_graph.has_edge(\"a\", \"b\")\n            assert updated_graph.has_edge(\"a\", \"d\")\n\n            # Clean up the test file\n            os.remove(graphml_file)", "\nclass TestFileSystemTree(unittest.TestCase):\n    def setUp(self) -> None:\n        self.test_uri = \"neo4j://localhost:7687\"\n        self.test_user = \"neo4j\"\n        self.test_password = \"password\"\n\n    def test_init(self) -> None:\n        with patch(\"neo4j.GraphDatabase.driver\") as mock_driver:\n            fst = FileSystemTree(self.test_uri, self.test_user, self.test_password)\n            mock_driver.assert_called_once_with(\n                self.test_uri, auth=(self.test_user, self.test_password)\n            )\n\n    def test_ready(self) -> None:\n        with patch(\"builtins.print\") as mock_print:\n            with FileSystemTree(\n                self.test_uri, self.test_user, self.test_password\n            ) as fst:\n                fst.ready()\n                mock_print.assert_called_once_with(\"started neo4j\")\n\n    def test_close(self) -> None:\n        with patch(\"neo4j.GraphDatabase.driver\") as mock_driver:\n            with FileSystemTree(\n                self.test_uri, self.test_user, self.test_password\n            ) as fst:\n                fst.close()\n                fst.driver.close.assert_called_once()\n\n    def test_print_greeting(self) -> None:\n        test_message = \"Hello, World!\"\n        with patch(\"neo4j.GraphDatabase.driver\") as mock_driver:\n            session = MagicMock()\n            mock_driver.return_value.session.return_value.__enter__.return_value = (\n                session\n            )\n            fst = FileSystemTree(self.test_uri, self.test_user, self.test_password)\n            with patch(\"builtins.print\") as mock_print:\n                fst.print_greeting(test_message)\n                session.execute_write.assert_called_once()\n                mock_print.assert_called_once()\n\n    def test_get_system_info(self) -> None:\n        # get system info using the function\n        with FileSystemTree(\n                self.test_uri, self.test_user, self.test_password\n            ) as fst:\n            system_info = fst.get_system_info()\n\n            # verify that the output is correct\n            assert isinstance(system_info, dict)\n            assert \"platform\" in system_info and system_info[\"platform\"] == platform.system()\n            assert \"platform-release\" in system_info and system_info[\"platform-release\"] == platform.release()\n            assert \"platform-version\" in system_info and system_info[\"platform-version\"] == platform.version()\n            assert \"architecture\" in system_info and system_info[\"architecture\"] == platform.machine()\n            assert \"hostname\" in system_info and system_info[\"hostname\"] == platform.node()\n            assert \"processor\" in system_info and system_info[\"processor\"] == platform.processor()\n            assert \"ram\" in system_info and isinstance(system_info[\"ram\"], str) and \"GB\" in system_info[\"ram\"]\n            assert \"uptime\" in system_info and isinstance(system_info[\"uptime\"], int) and system_info[\"uptime\"] > 0\n\n    def test_map_file_system(self) -> None:\n        def cleanup(test_dir: str) -> None:\n            # clean up the temporary directory\n            os.remove(os.path.join(test_dir, \"file1.txt\"))\n            os.remove(os.path.join(test_dir, \"subdir\", \"file2.txt\"))\n            os.rmdir(os.path.join(test_dir, \"subdir\"))\n            os.rmdir(test_dir)\n\n        # create a temporary directory with some files and directories\n        base_dir = os.path.dirname(os.path.abspath(__file__))\n        test_dir = os.path.join(base_dir, \"test_dir\")\n        cleanup(test_dir)\n        os.makedirs(test_dir)\n        os.makedirs(os.path.join(test_dir, \"subdir\"))\n        with open(os.path.join(test_dir, \"file1.txt\"), \"w\") as f:\n            f.write(\"Hello, world!\")\n        with open(os.path.join(test_dir, \"subdir\", \"file2.txt\"), \"w\") as f:\n            f.write(\"Goodbye, world!\")\n\n        # run the map_file_system function\n        with FileSystemTree(\n                self.test_uri, self.test_user, self.test_password\n            ) as fst:\n            file_tree = fst.map_file_system(test_dir)\n            print(nx.to_dict_of_dicts(file_tree))\n\n            # verify that the output is correct\n            assert isinstance(file_tree, nx.DiGraph)\n            assert file_tree.has_node(test_dir)\n\n            print(f'file1: {os.path.join(test_dir, \"file1.txt\")}')\n            print(f'tree: {nx.to_dict_of_dicts(file_tree)}')\n\n            assert file_tree.has_node(os.path.join(test_dir, \"file1.txt\"))\n            assert file_tree.has_node(os.path.join(test_dir, \"subdir\"))\n            assert file_tree.has_node(os.path.join(test_dir, \"subdir\", \"file2.txt\"))\n            assert file_tree.nodes[test_dir][\"type\"] == \"directory\"\n            assert file_tree.nodes[os.path.join(test_dir, \"file1.txt\")][\"type\"] == \"file\"\n            assert file_tree.nodes[os.path.join(test_dir, \"subdir\")][\"type\"] == \"directory\"\n            assert file_tree.nodes[os.path.join(test_dir, \"subdir\", \"file2.txt\")][\"type\"] == \"file\"\n            assert file_tree.successors(test_dir) == [os.path.join(test_dir, \"file1.txt\"), os.path.join(test_dir, \"subdir\")]\n            assert file_tree.successors(os.path.join(test_dir, \"subdir\")) == [os.path.join(test_dir, \"subdir\", \"file2.txt\")]\n\n    def test__calculate_merkle_tree(self) -> None:\n        # Create a graph with nodes and attributes\n        G = nx.DiGraph()\n        G.add_node(\"a\", type=\"directory\")\n        G.add_node(\"b\", type=\"file\", name=\"file1.txt\")\n        G.add_node(\"c\", type=\"file\", name=\"file2.txt\")\n        G.add_edge(\"a\", \"b\")\n        G.add_edge(\"a\", \"c\")\n\n        with FileSystemTree(\n                self.test_uri, self.test_user, self.test_password\n            ) as fst:\n\n            # Calculate the Merkle tree\n            merkle_tree = fst._calculate_merkle_tree(G)\n\n            # Verify the expected hash values for each node\n            expected_hashes = {\n                \"a\": sha256(repr({\"type\": \"directory\"}).encode()).hexdigest(),\n                \"b\": sha256(repr({\"type\": \"file\", \"name\": \"file1.txt\"}).encode()).hexdigest(),\n                \"c\": sha256(repr({\"type\": \"file\", \"name\": \"file2.txt\"}).encode()).hexdigest(),\n            }\n            assert merkle_tree == expected_hashes\n\n\n    def test__find_differences(self) -> None:\n        # Create two Merkle trees\n        original_tree = {\"a\": \"hash1\", \"b\": \"hash2\", \"c\": \"hash3\"}\n        new_tree = {\"a\": \"hash1\", \"b\": \"newhash\", \"d\": \"hash4\"}\n\n        with FileSystemTree(\n                self.test_uri, self.test_user, self.test_password\n            ) as fst:\n            # Find the differences between the two trees\n            differences = fst._find_differences(original_tree, new_tree)\n\n            # Verify the expected differences\n            expected_differences = {\"b\": \"newhash\", \"c\": None, \"d\": \"hash4\"}\n            assert differences == expected_differences\n\n\n    def test_update_graph_with_merkle_tree(self) -> None:\n        # Create a graph with nodes and edges\n        G = nx.DiGraph()\n        G.add_node(\"a\", type=\"directory\")\n        G.add_node(\"b\", type=\"file\", name=\"file1.txt\")\n        G.add_node(\"c\", type=\"file\", name=\"file2.txt\")\n        G.add_edge(\"a\", \"b\")\n        G.add_edge(\"a\", \"c\")\n\n        # Write the graph to a file\n        graphml_file = \"test_graph.graphml\"\n        nx.write_graphml(G, graphml_file)\n\n        # Create a new file tree with some modifications\n        new_tree = nx.DiGraph()\n        new_tree.add_node(\"a\", type=\"directory\")\n        new_tree.add_node(\"b\", type=\"file\", name=\"file1.txt\", size=\"100KB\")\n        new_tree.add_edge(\"a\", \"b\")\n        new_tree.add_node(\"d\", type=\"file\", name=\"file3.txt\")\n        new_tree.add_edge(\"a\", \"d\")\n\n        with FileSystemTree(\n                self.test_uri, self.test_user, self.test_password\n            ) as fst:\n\n            # Update the original graph with the differences\n            updated_graph = fst.update_graph_with_merkle_tree(new_tree, graphml_file)\n\n            # Verify that the graph has been updated correctly\n            assert updated_graph.has_node(\"a\")\n            assert updated_graph.has_node(\"b\")\n            assert updated_graph.has_node(\"d\")\n            assert not updated_graph.has_node(\"c\")\n            assert updated_graph.has_edge(\"a\", \"b\")\n            assert updated_graph.has_edge(\"a\", \"d\")\n\n            # Clean up the test file\n            os.remove(graphml_file)", "\n"]}
{"filename": "backend/ingestion/server/manage.py", "chunked_list": ["#!/usr/bin/env python\n\"\"\"Django's command-line utility for administrative tasks.\"\"\"\nimport os\nimport sys\n\n\ndef main():\n    \"\"\"Run administrative tasks.\"\"\"\n    os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"server.settings\")\n    try:\n        from django.core.management import execute_from_command_line\n    except ImportError as exc:\n        raise ImportError(\n            \"Couldn't import Django. Are you sure it's installed and \"\n            \"available on your PYTHONPATH environment variable? Did you \"\n            \"forget to activate a virtual environment?\"\n        ) from exc\n    execute_from_command_line(sys.argv)", "\n\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "backend/ingestion/server/server/settings.py", "chunked_list": ["\"\"\"\nDjango settings for server project.\n\nGenerated by 'django-admin startproject' using Django 4.1.7.\n\nFor more information on this file, see\nhttps://docs.djangoproject.com/en/4.1/topics/settings/\n\nFor the full list of settings and their values, see\nhttps://docs.djangoproject.com/en/4.1/ref/settings/", "For the full list of settings and their values, see\nhttps://docs.djangoproject.com/en/4.1/ref/settings/\n\"\"\"\nimport os\nfrom pathlib import Path\nfrom dotenv import load_dotenv\n\nDJANGO_ENV = os.environ.get(\"DJANGO_ENV\", \"dev\")\n\ncurrent_directory_path = os.path.dirname(os.path.abspath(__file__))", "\ncurrent_directory_path = os.path.dirname(os.path.abspath(__file__))\n\n\nif DJANGO_ENV == \"prod\":\n    load_dotenv(os.path.join(current_directory_path, \"../env/.env.prod\"))\nelse:\n    load_dotenv(os.path.join(current_directory_path, \"../env/.env.dev\"))\n\n# Build paths inside the project like this: BASE_DIR / 'subdir'.", "\n# Build paths inside the project like this: BASE_DIR / 'subdir'.\nBASE_DIR = Path(__file__).resolve().parent.parent\n\n\n# Quick-start development settings - unsuitable for production\n# See https://docs.djangoproject.com/en/4.1/howto/deployment/checklist/\n\n# SECURITY WARNING: keep the secret key used in production secret!\nSECRET_KEY = os.environ.get(\"SECRET_KEY\")", "# SECURITY WARNING: keep the secret key used in production secret!\nSECRET_KEY = os.environ.get(\"SECRET_KEY\")\n\n# SECURITY WARNING: don't run with debug turned on in production!\nDEBUG = True\n\nALLOWED_HOSTS = []\n\n\n# Application definition", "\n# Application definition\n\nINSTALLED_APPS = [\n    \"django.contrib.admin\",\n    \"django.contrib.auth\",\n    \"django.contrib.contenttypes\",\n    \"django.contrib.sessions\",\n    \"django.contrib.messages\",\n    \"django.contrib.staticfiles\",", "    \"django.contrib.messages\",\n    \"django.contrib.staticfiles\",\n    \"backend.apis\",\n    \"backend.fstree\",\n]\n\nMIDDLEWARE = [\n    \"django.middleware.security.SecurityMiddleware\",\n    \"django.contrib.sessions.middleware.SessionMiddleware\",\n    \"django.middleware.common.CommonMiddleware\",", "    \"django.contrib.sessions.middleware.SessionMiddleware\",\n    \"django.middleware.common.CommonMiddleware\",\n    \"django.middleware.csrf.CsrfViewMiddleware\",\n    \"django.contrib.auth.middleware.AuthenticationMiddleware\",\n    \"django.contrib.messages.middleware.MessageMiddleware\",\n    \"django.middleware.clickjacking.XFrameOptionsMiddleware\",\n]\n\nROOT_URLCONF = \"server.urls\"\n", "ROOT_URLCONF = \"server.urls\"\n\nTEMPLATES = [\n    {\n        \"BACKEND\": \"django.template.backends.django.DjangoTemplates\",\n        \"DIRS\": [],\n        \"APP_DIRS\": True,\n        \"OPTIONS\": {\n            \"context_processors\": [\n                \"django.template.context_processors.debug\",", "            \"context_processors\": [\n                \"django.template.context_processors.debug\",\n                \"django.template.context_processors.request\",\n                \"django.contrib.auth.context_processors.auth\",\n                \"django.contrib.messages.context_processors.messages\",\n            ],\n        },\n    },\n]\n", "]\n\nWSGI_APPLICATION = \"server.wsgi.application\"\n\n\n# Database\n# https://docs.djangoproject.com/en/4.1/ref/settings/#databases\n\nDATABASES = {\n    \"default\": {", "DATABASES = {\n    \"default\": {\n        \"ENGINE\": \"django.db.backends.sqlite3\",\n        \"NAME\": BASE_DIR / \"db.sqlite3\",\n    }\n}\n\n\n# Password validation\n# https://docs.djangoproject.com/en/4.1/ref/settings/#auth-password-validators", "# Password validation\n# https://docs.djangoproject.com/en/4.1/ref/settings/#auth-password-validators\n\nAUTH_PASSWORD_VALIDATORS = [\n    {\n        \"NAME\": \"django.contrib.auth.password_validation.UserAttributeSimilarityValidator\",\n    },\n    {\n        \"NAME\": \"django.contrib.auth.password_validation.MinimumLengthValidator\",\n    },", "        \"NAME\": \"django.contrib.auth.password_validation.MinimumLengthValidator\",\n    },\n    {\n        \"NAME\": \"django.contrib.auth.password_validation.CommonPasswordValidator\",\n    },\n    {\n        \"NAME\": \"django.contrib.auth.password_validation.NumericPasswordValidator\",\n    },\n]\n", "]\n\n\n# Internationalization\n# https://docs.djangoproject.com/en/4.1/topics/i18n/\n\nLANGUAGE_CODE = \"en-us\"\n\nTIME_ZONE = \"UTC\"\n", "TIME_ZONE = \"UTC\"\n\nUSE_I18N = True\n\nUSE_TZ = True\n\n\n# Static files (CSS, JavaScript, Images)\n# https://docs.djangoproject.com/en/4.1/howto/static-files/\n", "# https://docs.djangoproject.com/en/4.1/howto/static-files/\n\nSTATIC_URL = \"static/\"\n\n# Default primary key field type\n# https://docs.djangoproject.com/en/4.1/ref/settings/#default-auto-field\n\nDEFAULT_AUTO_FIELD = \"django.db.models.BigAutoField\"\n", ""]}
{"filename": "backend/ingestion/server/server/urls.py", "chunked_list": ["\"\"\"server URL Configuration\n\nThe `urlpatterns` list routes URLs to views. For more information please see:\n    https://docs.djangoproject.com/en/4.1/topics/http/urls/\nExamples:\nFunction views\n    1. Add an import:  from my_app import views\n    2. Add a URL to urlpatterns:  path('', views.home, name='home')\nClass-based views\n    1. Add an import:  from other_app.views import Home", "Class-based views\n    1. Add an import:  from other_app.views import Home\n    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')\nIncluding another URLconf\n    1. Import the include() function: from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n\"\"\"\nfrom api.filesystem import get_urls\n\nurlpatterns = []", "\nurlpatterns = []\nurlpatterns.extend(get_urls())\n"]}
{"filename": "backend/ingestion/server/server/__init__.py", "chunked_list": [""]}
{"filename": "backend/ingestion/server/server/asgi.py", "chunked_list": ["\"\"\"\nASGI config for server project.\n\nIt exposes the ASGI callable as a module-level variable named ``application``.\n\nFor more information on this file, see\nhttps://docs.djangoproject.com/en/4.1/howto/deployment/asgi/\n\"\"\"\n\nimport os", "\nimport os\n\nfrom django.core.asgi import get_asgi_application\n\nos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"server.settings\")\n\napplication = get_asgi_application()\n", ""]}
{"filename": "backend/ingestion/server/server/wsgi.py", "chunked_list": ["\"\"\"\nWSGI config for server project.\n\nIt exposes the WSGI callable as a module-level variable named ``application``.\n\nFor more information on this file, see\nhttps://docs.djangoproject.com/en/4.1/howto/deployment/wsgi/\n\"\"\"\n\nimport os", "\nimport os\n\nfrom django.core.wsgi import get_wsgi_application\n\nos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"server.settings\")\n\napplication = get_wsgi_application()\n", ""]}
{"filename": "backend/ingestion/server/server/system/__init__.py", "chunked_list": [""]}
{"filename": "backend/ingestion/server/server/system/fstree.py", "chunked_list": ["import os\nimport time\nimport hashlib\nfrom collections import deque\nfrom typing import Dict, List, Union\nimport psutil\nimport platform\nfrom django.apps import AppConfig\nfrom neo4j import GraphDatabase\nimport networkx as nx", "from neo4j import GraphDatabase\nimport networkx as nx\n\n\nclass FileSystemTree(AppConfig):\n    def __init__(self, uri, user, password):\n        self.uri = uri\n        self.user = user\n        self.password = password\n        self.driver = GraphDatabase.driver(uri, auth=(user, password))\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        self.close()\n\n    def ready(self):\n        file_tree = self.map_file_system(\"/\")\n        nx.write_graphml(file_tree, \"file_tree.graphml\")\n\n    def close(self):\n        self.driver.close()\n\n    def print_greeting(self, message):\n        with self.driver.session() as session:\n            greeting = session.execute_write(self._create_and_return_greeting, message)\n            print(greeting)\n\n    @staticmethod\n    def _create_and_return_greeting(tx, message):\n        result = tx.run(\n            \"CREATE (a:Greeting) \"\n            \"SET a.message = $message \"\n            \"RETURN a.message + ', from node ' + id(a)\",\n            message=message,\n        )\n        return result.single()[0]\n\n    def get_system_info(self) -> Dict[str, Union[str, int, float]]:\n        system_info = {\n            \"platform\": platform.system(),\n            \"platform-release\": platform.release(),\n            \"platform-version\": platform.version(),\n            \"architecture\": platform.machine(),\n            \"hostname\": platform.node(),\n            \"processor\": platform.processor(),\n            \"ram\": str(round(psutil.virtual_memory().total / (1024 * 1024 * 1024), 2))\n            + \" GB\",\n            \"uptime\": int(time.time() - psutil.boot_time()),\n        }\n        return system_info\n\n    def map_file_system(self, path: str = \"/\") -> nx.DiGraph:\n        file_tree = nx.DiGraph()\n        file_tree.add_node(path, type=\"directory\")\n\n        queue = deque()\n        queue.append(path)\n\n        while queue:\n            current_path = queue.popleft()\n\n            if \"/dev\" in current_path or \"/proc\" in current_path:\n                continue\n\n            try:\n                with os.scandir(current_path) as entries:\n                    for entry in entries:\n                        if entry.is_file():\n                            file_tree.add_node(\n                                os.path.join(current_path, entry.name),\n                                type=\"file\",\n                                name=entry.name,\n                            )\n                            file_tree.add_edge(\n                                current_path, os.path.join(current_path, entry.name)\n                            )\n                        elif entry.is_dir():\n                            subdir = os.path.join(current_path, entry.name)\n                            file_tree.add_node(\n                                subdir, type=\"directory\", name=entry.name\n                            )\n                            file_tree.add_edge(current_path, subdir)\n                            queue.append(subdir)\n\n            except (PermissionError, FileNotFoundError):\n                pass\n\n        return file_tree\n\n    def update_graph_with_merkle_tree(\n        self, file_tree: nx.DiGraph, graphml_file: str\n    ) -> nx.DiGraph:\n        # load the graph from the graphml file\n        G = nx.read_graphml(graphml_file)\n\n        # calculate the Merkle Trees for the original and new file trees\n        original_merkle_tree = self._calculate_merkle_tree(G)\n        new_merkle_tree = self._calculate_merkle_tree(file_tree)\n\n        # find the differences between the two trees\n        differences = self._find_differences(original_merkle_tree, new_merkle_tree)\n\n        # apply the differences to the original graph\n        for node, attributes in differences.items():\n            if attributes is None:\n                G.remove_node(node)\n            else:\n                G.add_node(node, **attributes)\n\n        return G\n\n    def _calculate_merkle_tree(self, file_tree: nx.DiGraph) -> dict:\n        merkle_tree = {}\n        for node in sorted(file_tree.nodes):\n            hash_value = hashlib.sha256(\n                repr(file_tree.nodes[node]).encode()\n            ).hexdigest()\n            merkle_tree[node] = hash_value\n\n        return merkle_tree\n\n    def _find_differences(self, original_tree: dict, new_tree: dict) -> dict:\n        differences = {}\n        \n        # find nodes in new_tree that are not in original_tree\n        for node, hash_value in new_tree.items():\n            if node not in original_tree:\n                differences[node] = new_tree[node]\n            elif original_tree[node] != hash_value:\n                differences[node] = new_tree[node]\n\n        # find nodes in original_tree that are not in new_tree\n        for node, hash_value in original_tree.items():\n            if node not in new_tree:\n                differences[node] = None\n\n        return differences", ""]}
{"filename": "backend/ingestion/server/server/api/__init__.py", "chunked_list": [""]}
{"filename": "backend/ingestion/server/server/api/filesystem.py", "chunked_list": ["import os\nimport time\nfrom collections import deque\nfrom typing import Dict, List, Union\nfrom dotenv import load_dotenv\nimport psutil\nimport platform\nfrom django.contrib import admin\nfrom django.urls import path\nfrom django.http import HttpRequest, HttpResponse, HttpResponseBadRequest, JsonResponse", "from django.urls import path\nfrom django.http import HttpRequest, HttpResponse, HttpResponseBadRequest, JsonResponse\n\n\"\"\"\nPOST configurations to:\n1. Update connected APIs\n2. Modify refresh interval\n\"\"\"\n\n\ndef configure(req: HttpRequest) -> HttpResponse:\n    if req.method == \"POST\":\n        configuration = req.POST.get(\"config\")", "\n\ndef configure(req: HttpRequest) -> HttpResponse:\n    if req.method == \"POST\":\n        configuration = req.POST.get(\"config\")\n\n\ndef get_urls():\n    return [\n        path(\"admin/\", admin.site.urls),\n        path(\"api/v1/configure\", configure, name=\"configure\"),\n    ]", ""]}
{"filename": "backend/speech/manage.py", "chunked_list": ["#!/usr/bin/env python\n\"\"\"Django's command-line utility for administrative tasks.\"\"\"\nimport os\nimport sys\n\n\ndef main():\n    \"\"\"Run administrative tasks.\"\"\"\n    os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"backend.settings\")\n    try:\n        from django.core.management import execute_from_command_line\n    except ImportError as exc:\n        raise ImportError(\n            \"Couldn't import Django. Are you sure it's installed and \"\n            \"available on your PYTHONPATH environment variable? Did you \"\n            \"forget to activate a virtual environment?\"\n        ) from exc\n    execute_from_command_line(sys.argv)", "\n\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "backend/speech/backend/settings.py", "chunked_list": ["\"\"\"\nDjango settings for backend project.\n\nGenerated by 'django-admin startproject' using Django 4.1.7.\n\nFor more information on this file, see\nhttps://docs.djangoproject.com/en/4.1/topics/settings/\n\nFor the full list of settings and their values, see\nhttps://docs.djangoproject.com/en/4.1/ref/settings/", "For the full list of settings and their values, see\nhttps://docs.djangoproject.com/en/4.1/ref/settings/\n\"\"\"\nimport os\nfrom pathlib import Path\nfrom dotenv import load_dotenv\n\nDJANGO_ENV = os.environ.get(\"DJANGO_ENV\", \"dev\")\n\ncurrent_directory_path = os.path.dirname(os.path.abspath(__file__))", "\ncurrent_directory_path = os.path.dirname(os.path.abspath(__file__))\n\n\nif DJANGO_ENV == \"prod\":\n    load_dotenv(os.path.join(current_directory_path, \"../env/.env.prod\"))\nelse:\n    load_dotenv(os.path.join(current_directory_path, \"../env/.env.dev\"))\n\n# Build paths inside the project like this: BASE_DIR / 'subdir'.", "\n# Build paths inside the project like this: BASE_DIR / 'subdir'.\nBASE_DIR = Path(__file__).resolve().parent.parent\n\n\n# Quick-start development settings - unsuitable for production\n# See https://docs.djangoproject.com/en/4.1/howto/deployment/checklist/\n\n# SECURITY WARNING: keep the secret key used in production secret!\nSECRET_KEY = os.environ.get(\"SECRET_KEY\")", "# SECURITY WARNING: keep the secret key used in production secret!\nSECRET_KEY = os.environ.get(\"SECRET_KEY\")\n\n# SECURITY WARNING: don't run with debug turned on in production!\nDEBUG = True\n\nALLOWED_HOSTS = []\n\n\n# Application definition", "\n# Application definition\n\nINSTALLED_APPS = [\n    \"django.contrib.admin\",\n    \"django.contrib.auth\",\n    \"django.contrib.contenttypes\",\n    \"django.contrib.sessions\",\n    \"django.contrib.messages\",\n    \"django.contrib.staticfiles\",", "    \"django.contrib.messages\",\n    \"django.contrib.staticfiles\",\n]\n\nMIDDLEWARE = [\n    \"django.middleware.security.SecurityMiddleware\",\n    \"django.contrib.sessions.middleware.SessionMiddleware\",\n    \"django.middleware.common.CommonMiddleware\",\n    \"django.middleware.csrf.CsrfViewMiddleware\",\n    \"django.contrib.auth.middleware.AuthenticationMiddleware\",", "    \"django.middleware.csrf.CsrfViewMiddleware\",\n    \"django.contrib.auth.middleware.AuthenticationMiddleware\",\n    \"django.contrib.messages.middleware.MessageMiddleware\",\n    \"django.middleware.clickjacking.XFrameOptionsMiddleware\",\n]\n\nROOT_URLCONF = \"backend.urls\"\n\nTEMPLATES = [\n    {", "TEMPLATES = [\n    {\n        \"BACKEND\": \"django.template.backends.django.DjangoTemplates\",\n        \"DIRS\": [],\n        \"APP_DIRS\": True,\n        \"OPTIONS\": {\n            \"context_processors\": [\n                \"django.template.context_processors.debug\",\n                \"django.template.context_processors.request\",\n                \"django.contrib.auth.context_processors.auth\",", "                \"django.template.context_processors.request\",\n                \"django.contrib.auth.context_processors.auth\",\n                \"django.contrib.messages.context_processors.messages\",\n            ],\n        },\n    },\n]\n\nWSGI_APPLICATION = \"backend.wsgi.application\"\n", "WSGI_APPLICATION = \"backend.wsgi.application\"\n\n\n# Database\n# https://docs.djangoproject.com/en/4.1/ref/settings/#databases\n\nDATABASES = {\n    \"default\": {\n        \"ENGINE\": \"django.db.backends.sqlite3\",\n        \"NAME\": BASE_DIR / \"db.sqlite3\",", "        \"ENGINE\": \"django.db.backends.sqlite3\",\n        \"NAME\": BASE_DIR / \"db.sqlite3\",\n    }\n}\n\n\n# Password validation\n# https://docs.djangoproject.com/en/4.1/ref/settings/#auth-password-validators\n\nAUTH_PASSWORD_VALIDATORS = [", "\nAUTH_PASSWORD_VALIDATORS = [\n    {\n        \"NAME\": \"django.contrib.auth.password_validation.UserAttributeSimilarityValidator\",\n    },\n    {\n        \"NAME\": \"django.contrib.auth.password_validation.MinimumLengthValidator\",\n    },\n    {\n        \"NAME\": \"django.contrib.auth.password_validation.CommonPasswordValidator\",", "    {\n        \"NAME\": \"django.contrib.auth.password_validation.CommonPasswordValidator\",\n    },\n    {\n        \"NAME\": \"django.contrib.auth.password_validation.NumericPasswordValidator\",\n    },\n]\n\n\n# Internationalization", "\n# Internationalization\n# https://docs.djangoproject.com/en/4.1/topics/i18n/\n\nLANGUAGE_CODE = \"en-us\"\n\nTIME_ZONE = \"UTC\"\n\nUSE_I18N = True\n", "USE_I18N = True\n\nUSE_TZ = True\n\n\n# Static files (CSS, JavaScript, Images)\n# https://docs.djangoproject.com/en/4.1/howto/static-files/\n\nSTATIC_URL = \"static/\"\n", "STATIC_URL = \"static/\"\n\n# Default primary key field type\n# https://docs.djangoproject.com/en/4.1/ref/settings/#default-auto-field\n\nDEFAULT_AUTO_FIELD = \"django.db.models.BigAutoField\"\n"]}
{"filename": "backend/speech/backend/urls.py", "chunked_list": ["\"\"\"backend URL Configuration\n\nThe `urlpatterns` list routes URLs to views. For more information please see:\n    https://docs.djangoproject.com/en/4.1/topics/http/urls/\nExamples:\nFunction views\n    1. Add an import:  from my_app import views\n    2. Add a URL to urlpatterns:  path('', views.home, name='home')\nClass-based views\n    1. Add an import:  from other_app.views import Home", "Class-based views\n    1. Add an import:  from other_app.views import Home\n    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')\nIncluding another URLconf\n    1. Import the include() function: from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n\"\"\"\nfrom django.contrib import admin\nfrom django.urls import path\nfrom backend.api import speech", "from django.urls import path\nfrom backend.api import speech\n\nurlpatterns = [path(\"admin/\", admin.site.urls)]\nurlpatterns.extend(speech.get_urlpatterns())\n"]}
{"filename": "backend/speech/backend/__init__.py", "chunked_list": [""]}
{"filename": "backend/speech/backend/asgi.py", "chunked_list": ["\"\"\"\nASGI config for backend project.\n\nIt exposes the ASGI callable as a module-level variable named ``application``.\n\nFor more information on this file, see\nhttps://docs.djangoproject.com/en/4.1/howto/deployment/asgi/\n\"\"\"\n\nimport os", "\nimport os\n\nfrom django.core.asgi import get_asgi_application\n\nos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"backend.settings\")\n\napplication = get_asgi_application()\n", ""]}
{"filename": "backend/speech/backend/wsgi.py", "chunked_list": ["\"\"\"\nWSGI config for backend project.\n\nIt exposes the WSGI callable as a module-level variable named ``application``.\n\nFor more information on this file, see\nhttps://docs.djangoproject.com/en/4.1/howto/deployment/wsgi/\n\"\"\"\n\nimport os", "\nimport os\nimport shutil\nimport atexit\nfrom django.core.wsgi import get_wsgi_application\n\nos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"backend.settings\")\n\napplication = get_wsgi_application()\n", "application = get_wsgi_application()\n\n\ndef shutdown_handler():\n    shutil.rmtree(\"media/\")\n\n\natexit.register(shutdown_handler)\n", ""]}
{"filename": "backend/speech/backend/api/__init__.py", "chunked_list": [""]}
{"filename": "backend/speech/backend/api/speech.py", "chunked_list": ["import os\nimport uuid\nfrom pydub import AudioSegment\nfrom django.urls import path\nfrom django.http import JsonResponse\nfrom django.views.decorators.csrf import csrf_exempt\n\nfrom model.speech.whisper import Whisper\n\nmodel = Whisper(os.environ.get(\"MODEL\", \"openai/whisper-tiny\"))", "\nmodel = Whisper(os.environ.get(\"MODEL\", \"openai/whisper-tiny\"))\n\nALLOWED_EXTENSIONS = {\"mp3\", \"wav\", \"ogg\", \"m4a\", \"flac\", \"webm\"}\n\n\ndef allowed_file(filename: str) -> bool:\n    return \".\" in filename and filename.rsplit(\".\", 1)[1].lower() in ALLOWED_EXTENSIONS\n\n", "\n\n@csrf_exempt\ndef transcribe_audio(request):\n    if request.method == \"POST\":\n        if \"file\" not in request.FILES:\n            return JsonResponse({\"error\": \"No file provided.\"}, status=400)\n\n        file = request.FILES[\"file\"]\n        if not allowed_file(file.name):\n            return JsonResponse(\n                {\"error\": \"Invalid file type. Please upload an audio file.\"}, status=400\n            )\n\n        os.makedirs(\"media\", exist_ok=True)\n\n        # Save the received file\n        filename = f\"{uuid.uuid4()}.{file.name.rsplit('.', 1)[1].lower()}\"\n        filepath = os.path.join(\"media\", filename)\n\n        with open(filepath, \"wb\") as f:\n            for chunk in file.chunks():\n                f.write(chunk)\n\n        # Convert the file to .wav format\n        input_format = file.name.rsplit(\".\", 1)[1].lower()\n        if input_format != \"wav\":\n            wav_filename = f\"{uuid.uuid4()}.wav\"\n            wav_filepath = os.path.join(\"media\", wav_filename)\n            sound = AudioSegment.from_file(filepath, format=input_format)\n            sound.export(wav_filepath, format=\"wav\")\n            os.remove(filepath)  # Remove the original file\n        else:\n            wav_filepath = filepath\n\n        # Call the transcription function\n        # transcription = transcribe(wav_filepath)\n        transcription = model.transcribe(wav_filepath)\n\n        # Remove the .wav file\n        os.remove(wav_filepath)\n\n        return JsonResponse({\"transcription\": transcription})\n    else:\n        return JsonResponse({\"error\": \"Invalid request method. Use POST.\"}, status=405)", "\n\ndef get_urlpatterns():\n    return [\n        path(\"transcribe/\", transcribe_audio, name=\"transcribe\"),\n    ]\n"]}
{"filename": "backend/speech/tests/test_speech.py", "chunked_list": ["import os\nimport pytest\nfrom scipy.io import wavfile\n\n\ndef test_transcribe():\n    pretrained_model = os.environ.get(\"MODEL\", \"openai/whisper-tiny\")\n\n    processor = WhisperProcessor.from_pretrained(pretrained_model)\n    model = WhisperForConditionalGeneration.from_pretrained(pretrained_model)\n    model.config.forced_decoder_ids = None\n\n    sampling_rate, data = wavfile.read(\"test.wav\")\n    data = whisper.convert_wav_to_flac(data, sampling_rate)\n\n    input_features = processor(\n        data, sampling_rate=sampling_rate, return_tensors=\"pt\"\n    ).input_features\n    predicted_ids = model.generate(input_features)\n    transcription = processor.batch_decode(predicted_ids, skip_special_tokens=True)\n    assert (\n        transcription[0].strip()\n        == \"Mr. Quilter is the apostle of the middle classes and we are glad to welcome his gospel.\"\n    )", ""]}
{"filename": "backend/speech/tests/test_whisper.py", "chunked_list": ["import pytest\nimport numpy as np\nfrom scipy.io import wavfile\nfrom speech.whisper import Whisper\n\n\n@pytest.fixture\ndef whisper():\n    return Whisper()\n", "\n\ndef test_convert_wav_to_flac(whisper):\n    # Create a simple sine wave\n    sample_rate = 16000\n    frequency = 440\n    duration = 1\n    time = np.linspace(0, duration, sample_rate * duration, endpoint=False)\n    wav_data = np.sin(2 * np.pi * frequency * time) * (2**15 - 1)\n\n    flac_data = whisper.convert_wav_to_flac(wav_data, sample_rate)\n\n    assert isinstance(flac_data, np.ndarray)\n    assert len(flac_data) == len(wav_data)", "\n\ndef test_whisper(whisper):\n    sampling_rate, data = wavfile.read(\"test.wav\")\n    data = whisper.convert_wav_to_flac(data, sampling_rate)\n    transcription = whisper.speech_to_text(data, sampling_rate)\n    assert (\n        transcription[0].strip()\n        == \"Mr. Quilter is the apostle of the middle classes and we are glad to welcome his gospel.\"\n    )", ""]}
{"filename": "backend/speech/model/__init__.py", "chunked_list": [""]}
{"filename": "backend/speech/model/speech/main.py", "chunked_list": ["from whisper import Whisper\n\n\ndef main():\n    model = Whisper()\n    model.transcribe_audio()\n\n\nif __name__ == \"__main__\":\n    main()", "if __name__ == \"__main__\":\n    main()\n"]}
{"filename": "backend/speech/model/speech/whisper.py", "chunked_list": ["\"\"\"\nThis script continuously listens for audio input, processes the audio in 5-second chunks, and \ntranscribes the speech using the \"openai/whisper\" model series with the Transformers pipeline \nand chunking enabled.\n\nhttps://huggingface.co/openai/whisper-tiny\n\"\"\"\n\nimport os\nimport io", "import os\nimport io\nimport string\nimport pyaudio\nimport numpy as np\nimport soundfile as sf\nfrom scipy.io import wavfile\nfrom typing import List\nfrom queue import Queue\nfrom threading import Thread", "from queue import Queue\nfrom threading import Thread\nfrom transformers import WhisperProcessor, WhisperForConditionalGeneration\n\n\nclass Whisper(object):\n    def __init__(self, model: str = \"openai/whisper-tiny\"):\n        self.seconds = int(os.environ.get(\"SECONDS\", 5))\n        self.sampling_rate = int(os.environ.get(\"SAMPLING_RATE\", 16000))\n        self.pretrained_model = model\n\n        self.processor = WhisperProcessor.from_pretrained(self.pretrained_model)\n        self.model = WhisperForConditionalGeneration.from_pretrained(\n            self.pretrained_model\n        )\n        self.model.config.forced_decoder_ids = None\n\n    # Record user audio\n    def record_audio(\n        self,\n        queue: Queue,\n        chunk: int = 1024,\n        channels: int = 1,\n        rate: int = 16000,\n        format: int = pyaudio.paInt16,\n    ) -> None:\n        audio = pyaudio.PyAudio()\n        stream = audio.open(\n            format=format,\n            channels=channels,\n            rate=rate,\n            input=True,\n            frames_per_buffer=chunk,\n        )\n\n        print(\"Listening...\")\n\n        while True:\n            try:\n                data = stream.read(chunk, exception_on_overflow=False)\n                queue.put(data)\n            except OSError as e:\n                if e.errno == -9981:\n                    print(\"Input overflowed. Skipping...\")\n                else:\n                    raise e\n\n    def convert_wav_to_flac(self, wav_data: np.ndarray, sample_rate: int) -> np.ndarray:\n        flac_data = io.BytesIO()\n        sf.write(flac_data, wav_data, sample_rate, format=\"FLAC\")\n\n        flac_data.seek(0)\n        flac_data_array, _ = sf.read(flac_data)\n\n        return flac_data_array\n\n    def speech_to_text(self, data: np.ndarray, sampling_rate: int) -> List[str]:\n        input_features = self.processor(\n            data, sampling_rate=sampling_rate, return_tensors=\"pt\"\n        ).input_features\n        predicted_ids = self.model.generate(input_features)\n        return self.processor.batch_decode(predicted_ids, skip_special_tokens=True)\n\n    def transcribe(self, file_path: str) -> str:\n        sampling_rate, data = wavfile.read(file_path)\n        data = self.convert_wav_to_flac(data, sampling_rate)\n\n        return self.speech_to_text(data, sampling_rate)\n\n    def transcribe_audio(self):\n        # Initialize the recording thread and queue\n        record_queue = Queue()\n        record_thread = Thread(target=self.record_audio, args=(record_queue,))\n        record_thread.daemon = True\n        record_thread.start()\n\n        # Set up continuous streaming\n        buffer = []\n        buffer_len = 0\n        buffer_max_len = self.seconds * self.sampling_rate\n\n        print(\"Starting transcription loop...\")\n\n        pattern = r\"[^\\w\\s]\"\n\n        while True:\n            if not record_queue.empty():\n                # Retrieve the recorded data and append it to the buffer\n                data = record_queue.get()\n                data_np = np.frombuffer(data, dtype=np.int16)\n                buffer.append(data_np)\n                buffer_len += len(data_np)\n\n                # Check if the buffer is full\n                if buffer_len >= buffer_max_len:\n                    # Concatenate the buffered data into a single array\n                    audio_input = np.concatenate(buffer, axis=0)\n\n                    # Save the audio input to a temporary file\n                    temp_filename = \"temp.wav\"\n                    sf.write(\n                        temp_filename, audio_input, self.sampling_rate, subtype=\"PCM_16\"\n                    )\n\n                    sampling_rate, data = wavfile.read(\"temp.wav\")\n                    data = self.convert_wav_to_flac(data, sampling_rate)\n\n                    transcription = self.speech_to_text(data, sampling_rate)\n\n                    # TODO: Trigger is for development purposes only. Remove later.\n                    print(\"Transcription:\", transcription)\n                    trigger = (\n                        transcription[0]\n                        .lower()\n                        .translate(str.maketrans(\"\", \"\", string.punctuation))\n                        .strip()\n                    )\n\n                    if trigger == \"stop\":\n                        os.remove(temp_filename)\n                        break\n\n                    # Clear the buffer and remove the temporary file\n                    buffer = []\n                    buffer_len = 0\n                    os.remove(temp_filename)", ""]}
{"filename": "backend/speech/model/speech/__init__.py", "chunked_list": [""]}
