{"filename": "scripts/image_gen.py", "chunked_list": ["import requests\nimport io\nimport os.path\nfrom PIL import Image\nfrom config import Config\nimport uuid\nfrom base64 import b64decode\n\ncfg = Config()\n", "cfg = Config()\n\nworking_directory = \"auto_gpt_workspace\"\n\ndef generate_image(prompt):\n    # STABLE DIFFUSION\n    if cfg.image_provider == 'sd':\n\n        API_URL = \"https://api-inference.huggingface.co/models/CompVis/stable-diffusion-v1-4\"\n        headers = {\"Authorization\": \"Bearer \" + cfg.huggingface_api_token}\n\n        response = requests.post(API_URL, headers=headers, json={\n            \"inputs\": prompt,\n        })\n\n        image = Image.open(io.BytesIO(response.content))\n        print(\"Image Generated for prompt:\" + prompt)\n\n        image.save(os.path.join(working_directory, filename))\n\n        return \"Saved to disk:\" + filename\n\n    else:\n        return \"No Image Provider Set\"", ""]}
{"filename": "scripts/spinner.py", "chunked_list": ["import sys\nimport threading\nimport itertools\nimport time\n\n\nclass Spinner:\n    \"\"\"A simple spinner class\"\"\"\n    def __init__(self, message=\"Loading...\", delay=0.1):\n        \"\"\"Initialize the spinner class\"\"\"\n        self.spinner = itertools.cycle(['-', '/', '|', '\\\\'])\n        self.delay = delay\n        self.message = message\n        self.running = False\n        self.spinner_thread = None\n\n    def spin(self):\n        \"\"\"Spin the spinner\"\"\"\n        while self.running:\n            sys.stdout.write(next(self.spinner) + \" \" + self.message + \"\\r\")\n            sys.stdout.flush()\n            time.sleep(self.delay)\n            sys.stdout.write('\\b' * (len(self.message) + 2))\n\n    def __enter__(self):\n        \"\"\"Start the spinner\"\"\"\n        self.running = True\n        self.spinner_thread = threading.Thread(target=self.spin)\n        self.spinner_thread.start()\n\n    def __exit__(self, exc_type, exc_value, exc_traceback):\n        \"\"\"Stop the spinner\"\"\"\n        self.running = False\n        self.spinner_thread.join()\n        sys.stdout.write('\\r' + ' ' * (len(self.message) + 2) + '\\r')\n        sys.stdout.flush()", ""]}
{"filename": "scripts/call_ai_function.py", "chunked_list": ["from config import Config\n\ncfg = Config()\n\nfrom llm_utils import create_chat_completion\n# This is a magic function that can do anything with no-code. See\n# https://github.com/Torantulino/AI-Functions for more info.\ndef call_ai_function(function, args, description, model=None):\n    \"\"\"Call an AI function\"\"\"\n    if model is None:\n        model = cfg.smart_llm_model\n    # For each arg, if any are None, convert to \"None\":\n    args = [str(arg) if arg is not None else \"None\" for arg in args]\n    # parse args to comma seperated string\n    args = \", \".join(args)\n    messages = [\n        {\n            \"role\": \"system\",\n            \"content\": f\"You are now the following python function: ```# {description}\\n{function}```\\n\\nOnly respond with your `return` value.\",\n        },\n        {\"role\": \"user\", \"content\": args},\n    ]\n\n    response = create_chat_completion(\n        model=model, messages=messages, temperature=0\n    )\n\n    return response", ""]}
{"filename": "scripts/json_parser.py", "chunked_list": ["import json\nfrom typing import Any, Dict, Union\nfrom call_ai_function import call_ai_function\nfrom config import Config\nfrom json_utils import correct_json\n\ncfg = Config()\n\nJSON_SCHEMA = \"\"\"\n{", "JSON_SCHEMA = \"\"\"\n{\n    \"command\": {\n        \"name\": \"command name\",\n        \"args\":{\n            \"arg name\": \"value\"\n        }\n    },\n    \"thoughts\":\n    {", "    \"thoughts\":\n    {\n        \"text\": \"thought\",\n        \"reasoning\": \"reasoning\",\n        \"plan\": \"- short bulleted\\n- list that conveys\\n- long-term plan\",\n        \"criticism\": \"constructive self-criticism\",\n        \"speak\": \"thoughts summary to say to user\"\n    }\n}\n\"\"\"", "}\n\"\"\"\n\n\ndef fix_and_parse_json(    \n    json_str: str,\n    try_to_fix_with_gpt: bool = True\n) -> Union[str, Dict[Any, Any]]:\n    \"\"\"Fix and parse JSON string\"\"\"\n    try:\n        json_str = json_str.replace('\\t', '')\n        json_str = json_str.replace('\\\\_', '_')\n        return json.loads(json_str)\n    except json.JSONDecodeError as _:  # noqa: F841\n        json_str = correct_json(json_str)\n        try:\n            return json.loads(json_str)\n        except json.JSONDecodeError as _:  # noqa: F841\n            pass\n    # Let's do something manually:\n    # sometimes GPT responds with something BEFORE the braces:\n    # \"I'm sorry, I don't understand. Please try again.\"\n    # {\"text\": \"I'm sorry, I don't understand. Please try again.\",\n    #  \"confidence\": 0.0}\n    # So let's try to find the first brace and then parse the rest\n    #  of the string\n    try:\n        brace_index = json_str.index(\"{\")\n        json_str = json_str[brace_index:]\n        last_brace_index = json_str.rindex(\"}\")\n        json_str = json_str[:last_brace_index+1]\n        return json.loads(json_str)\n    except json.JSONDecodeError as e:  # noqa: F841\n        if try_to_fix_with_gpt:\n            print(\"Warning: Failed to parse AI output, attempting to fix.\"\n                  \"\\n If you see this warning frequently, it's likely that\"\n                  \" your prompt is confusing the AI. Try changing it up\"\n                  \" slightly.\")\n            # Now try to fix this up using the ai_functions\n            ai_fixed_json = fix_json(json_str, JSON_SCHEMA)\n\n            if ai_fixed_json != \"failed\":\n                return json.loads(ai_fixed_json)\n            else:\n                # This allows the AI to react to the error message,\n                #   which usually results in it correcting its ways.\n                print(\"Failed to fix ai output, telling the AI.\")\n                return json_str\n        else:\n            raise e", "            \n        \ndef fix_json(json_str: str, schema: str) -> str:\n    \"\"\"Fix the given JSON string to make it parseable and fully complient with the provided schema.\"\"\"\n    \n    # Try to fix the JSON using gpt:\n    function_string = \"def fix_json(json_str: str, schema:str=None) -> str:\"\n    args = [f\"'''{json_str}'''\", f\"'''{schema}'''\"]\n    description_string = \"Fixes the provided JSON string to make it parseable\"\\\n        \" and fully complient with the provided schema.\\n If an object or\"\\\n        \" field specified in the schema isn't contained within the correct\"\\\n        \" JSON, it is ommited.\\n This function is brilliant at guessing\"\\\n        \" when the format is incorrect.\"\n\n    # If it doesn't already start with a \"`\", add one:\n    if not json_str.startswith(\"`\"):\n        json_str = \"```json\\n\" + json_str + \"\\n```\"\n    result_string = call_ai_function(\n        function_string, args, description_string, model=cfg.fast_llm_model\n    )\n    if cfg.debug:\n        print(\"------------ JSON FIX ATTEMPT ---------------\")\n        print(f\"Original JSON: {json_str}\")\n        print(\"-----------\")\n        print(f\"Fixed JSON: {result_string}\")\n        print(\"----------- END OF FIX ATTEMPT ----------------\")\n\n    try:\n        json.loads(result_string)  # just check the validity\n        return result_string\n    except:  # noqa: E722\n        # Get the call stack:\n        # import traceback\n        # call_stack = traceback.format_exc()\n        # print(f\"Failed to fix JSON: '{json_str}' \"+call_stack)\n        return \"failed\"", ""]}
{"filename": "scripts/main.py", "chunked_list": ["import json\nimport random\nimport commands as cmd\nimport utils\nfrom memory import get_memory\nimport data\nimport chat\nfrom colorama import Fore, Style\nfrom spinner import Spinner\nimport time", "from spinner import Spinner\nimport time\nimport speak\nfrom enum import Enum, auto\nimport sys\nfrom config import Config\nfrom json_parser import fix_and_parse_json\nfrom ai_config import AIConfig\nimport traceback\nimport yaml", "import traceback\nimport yaml\nimport argparse\nimport logging\n\ncfg = Config()\n\ndef configure_logging():\n    logging.basicConfig(filename='log.txt',\n                    filemode='a',\n                    format='%(asctime)s,%(msecs)d %(name)s %(levelname)s %(message)s',\n                    datefmt='%H:%M:%S',\n                    level=logging.DEBUG)\n    return logging.getLogger('AutoGPT')", "\n# def check_openai_api_key():\n#     \"\"\"Check if the OpenAI API key is set in config.py or as an environment variable.\"\"\"\n#     if not cfg.openai_api_key:\n#         print(\n#             Fore.RED +\n#             \"Please set your OpenAI API key in config.py or as an environment variable.\"\n#         )\n#         print(\"You can get your key from https://beta.openai.com/account/api-keys\")\n#         exit(1)", "#         print(\"You can get your key from https://beta.openai.com/account/api-keys\")\n#         exit(1)\n\ndef print_to_console(\n        title,\n        title_color,\n        content,\n        speak_text=False,\n        min_typing_speed=0.05,\n        max_typing_speed=0.01):\n    \"\"\"Prints text to the console with a typing effect\"\"\"\n    global cfg\n    global logger\n    if speak_text and cfg.speak_mode:\n        speak.say_text(f\"{title}. {content}\")\n    print(title_color + title + \" \" + Style.RESET_ALL, end=\"\")\n    if content:\n        logger.info(title + ': ' + content)\n        if isinstance(content, list):\n            content = \" \".join(content)\n        words = content.split()\n        for i, word in enumerate(words):\n            print(word, end=\"\", flush=True)\n            if i < len(words) - 1:\n                print(\" \", end=\"\", flush=True)\n            typing_speed = random.uniform(min_typing_speed, max_typing_speed)\n            time.sleep(typing_speed)\n            # type faster after each word\n            min_typing_speed = min_typing_speed * 0.95\n            max_typing_speed = max_typing_speed * 0.95\n    print()", "\n\ndef print_assistant_thoughts(assistant_reply):\n    \"\"\"Prints the assistant's thoughts to the console\"\"\"\n    global ai_name\n    global cfg\n    try:\n        # Parse and print Assistant response\n        print(\"Assistent Reply\", assistant_reply)\n        assistant_reply_json = fix_and_parse_json(assistant_reply)\n\n        # Check if assistant_reply_json is a string and attempt to parse it into a JSON object\n        if isinstance(assistant_reply_json, str):\n            try:\n                assistant_reply_json = json.loads(assistant_reply_json)\n            except json.JSONDecodeError as e:\n                print_to_console(\"Error: Invalid JSON\\n\", Fore.RED, assistant_reply)\n                assistant_reply_json = {}\n\n        assistant_thoughts_reasoning = None\n        assistant_thoughts_plan = None\n        assistant_thoughts_speak = None\n        assistant_thoughts_criticism = None\n        assistant_thoughts = assistant_reply_json.get(\"thoughts\", {})\n        assistant_thoughts_text = assistant_thoughts.get(\"text\")\n\n        if assistant_thoughts:\n            assistant_thoughts_reasoning = assistant_thoughts.get(\"reasoning\")\n            assistant_thoughts_plan = assistant_thoughts.get(\"plan\")\n            assistant_thoughts_criticism = assistant_thoughts.get(\"criticism\")\n            assistant_thoughts_speak = assistant_thoughts.get(\"speak\")\n\n        print_to_console(f\"{ai_name.upper()} THOUGHTS:\", Fore.YELLOW, assistant_thoughts_text)\n        print_to_console(\"REASONING:\", Fore.YELLOW, assistant_thoughts_reasoning)\n\n        if assistant_thoughts_plan:\n            print_to_console(\"PLAN:\", Fore.YELLOW, \"\")\n            # If it's a list, join it into a string\n            if isinstance(assistant_thoughts_plan, list):\n                assistant_thoughts_plan = \"\\n\".join(assistant_thoughts_plan)\n            elif isinstance(assistant_thoughts_plan, dict):\n                assistant_thoughts_plan = str(assistant_thoughts_plan)\n\n            # Split the input_string using the newline character and dashes\n            lines = assistant_thoughts_plan.split('\\n')\n            for line in lines:\n                line = line.lstrip(\"- \")\n                print_to_console(\"- \", Fore.GREEN, line.strip())\n\n        print_to_console(\"CRITICISM:\", Fore.YELLOW, assistant_thoughts_criticism)\n        # Speak the assistant's thoughts\n        if cfg.speak_mode and assistant_thoughts_speak:\n            speak.say_text(assistant_thoughts_speak)\n\n    except json.decoder.JSONDecodeError:\n        print_to_console(\"Error: Invalid JSON\\n\", Fore.RED, assistant_reply)\n\n    # All other errors, return \"Error: + error message\"\n    except Exception as e:\n        call_stack = traceback.format_exc()\n        print_to_console(\"Error: \\n\", Fore.RED, call_stack)", "\n\ndef load_variables(config_file=\"config.yaml\"):\n    \"\"\"Load variables from yaml file if it exists, otherwise prompt the user for input\"\"\"\n    try:\n        with open(config_file) as file:\n            config = yaml.load(file, Loader=yaml.FullLoader)\n        ai_name = config.get(\"ai_name\")\n        ai_role = config.get(\"ai_role\")\n        ai_goals = config.get(\"ai_goals\")\n    except FileNotFoundError:\n        ai_name = \"\"\n        ai_role = \"\"\n        ai_goals = []\n\n    # Prompt the user for input if config file is missing or empty values\n    if not ai_name:\n        ai_name = utils.clean_input(\"Name your AI: \")\n        if ai_name == \"\":\n            ai_name = \"Entrepreneur-GPT\"\n\n    if not ai_role:\n        ai_role = utils.clean_input(f\"{ai_name} is: \")\n        if ai_role == \"\":\n            ai_role = \"an AI designed to autonomously develop and run businesses with the sole goal of increasing your net worth.\"\n\n    if not ai_goals:\n        print(\"Enter up to 5 goals for your AI: \")\n        print(\"For example: \\nIncrease net worth, Grow Twitter Account, Develop and manage multiple businesses autonomously'\")\n        print(\"Enter nothing to load defaults, enter nothing when finished.\")\n        ai_goals = []\n        for i in range(5):\n            ai_goal = utils.clean_input(f\"Goal {i+1}: \")\n            if ai_goal == \"\":\n                break\n            ai_goals.append(ai_goal)\n        if len(ai_goals) == 0:\n            ai_goals = [\"Increase net worth\", \"Grow Twitter Account\", \"Develop and manage multiple businesses autonomously\"]\n\n    # Save variables to yaml file\n    config = {\"ai_name\": ai_name, \"ai_role\": ai_role, \"ai_goals\": ai_goals}\n    with open(config_file, \"w\") as file:\n        documents = yaml.dump(config, file)\n\n    prompt = data.load_prompt()\n    prompt_start = \"\"\"Your decisions must always be made independently without seeking user assistance. Play to your strengths as an LLM and pursue simple strategies with no legal complications.\"\"\"\n\n    # Construct full prompt\n    full_prompt = f\"You are {ai_name}, {ai_role}\\n{prompt_start}\\n\\nGOALS:\\n\\n\"\n    for i, goal in enumerate(ai_goals):\n        full_prompt += f\"{i+1}. {goal}\\n\"\n\n    full_prompt += f\"\\n\\n{prompt}\"\n    return full_prompt", "\n\ndef construct_prompt():\n    \"\"\"Construct the prompt for the AI to respond to\"\"\"\n    config = AIConfig.load()\n    if config.ai_name:\n        print_to_console(\n            f\"Welcome back! \",\n            Fore.GREEN,\n            f\"Would you like me to return to being {config.ai_name}?\",\n            speak_text=True)\n        should_continue = utils.clean_input(f\"\"\"Continue with the last settings?\nName:  {config.ai_name}\nRole:  {config.ai_role}\nGoals: {config.ai_goals}\nContinue (y/n): \"\"\")\n        if should_continue.lower() == \"n\":\n            config = AIConfig()\n\n    if not config.ai_name:\n        config = prompt_user()\n        config.save()\n\n    # Get rid of this global:\n    global ai_name\n    ai_name = config.ai_name\n\n    full_prompt = config.construct_full_prompt()\n    return full_prompt", "\n\ndef prompt_user():\n    \"\"\"Prompt the user for input\"\"\"\n    ai_name = \"\"\n    # Construct the prompt\n    print_to_console(\n        \"Welcome to Auto-GPT! \",\n        Fore.GREEN,\n        \"Enter the name of your AI and its role below. Entering nothing will load defaults.\",\n        speak_text=True)\n\n    # Get AI Name from User\n    print_to_console(\n        \"Name your AI: \",\n        Fore.GREEN,\n        \"For example, 'Entrepreneur-GPT'\")\n    ai_name = utils.clean_input(\"AI Name: \")\n    if ai_name == \"\":\n        ai_name = \"Entrepreneur-GPT\"\n\n    print_to_console(\n        f\"{ai_name} here!\",\n        Fore.LIGHTBLUE_EX,\n        \"I am at your service.\",\n        speak_text=True)\n\n    # Get AI Role from User\n    print_to_console(\n        \"Describe your AI's role: \",\n        Fore.GREEN,\n        \"For example, 'an AI designed to autonomously develop and run businesses with the sole goal of increasing your net worth.'\")\n    ai_role = utils.clean_input(f\"{ai_name} is: \")\n    if ai_role == \"\":\n        ai_role = \"an AI designed to autonomously develop and run businesses with the sole goal of increasing your net worth.\"\n\n    # Enter up to 5 goals for the AI\n    print_to_console(\n        \"Enter up to 5 goals for your AI: \",\n        Fore.GREEN,\n        \"For example: \\nIncrease net worth, Grow Twitter Account, Develop and manage multiple businesses autonomously'\")\n    print(\"Enter nothing to load defaults, enter nothing when finished.\", flush=True)\n    ai_goals = []\n    for i in range(5):\n        ai_goal = utils.clean_input(f\"{Fore.LIGHTBLUE_EX}Goal{Style.RESET_ALL} {i+1}: \")\n        if ai_goal == \"\":\n            break\n        ai_goals.append(ai_goal)\n    if len(ai_goals) == 0:\n        ai_goals = [\"Increase net worth\", \"Grow Twitter Account\",\n                    \"Develop and manage multiple businesses autonomously\"]\n\n    config = AIConfig(ai_name, ai_role, ai_goals)\n    return config", "\ndef parse_arguments():\n    \"\"\"Parses the arguments passed to the script\"\"\"\n    global cfg\n    cfg.set_continuous_mode(False)\n    cfg.set_speak_mode(False)\n\n    parser = argparse.ArgumentParser(description='Process arguments.')\n    parser.add_argument('--continuous', action='store_true', help='Enable Continuous Mode')\n    parser.add_argument('--speak', action='store_true', help='Enable Speak Mode')\n    parser.add_argument('--debug', action='store_true', help='Enable Debug Mode')\n    parser.add_argument('--fast', action='store_true', help='Enable the fast LLM model')\n    args = parser.parse_args()\n\n    if args.continuous:\n        print_to_console(\"Continuous Mode: \", Fore.RED, \"ENABLED\")\n        print_to_console(\n            \"WARNING: \",\n            Fore.RED,\n            \"Continuous mode is not recommended. It is potentially dangerous and may cause your AI to run forever or carry out actions you would not usually authorise. Use at your own risk.\")\n        cfg.set_continuous_mode(True)\n\n    if args.speak:\n        print_to_console(\"Speak Mode: \", Fore.GREEN, \"ENABLED\")\n        cfg.set_speak_mode(True)\n\n    if args.debug:\n        print_to_console(\"Debug Mode: \", Fore.GREEN, \"ENABLED\")\n        cfg.set_debug_mode(True)\n\n    if args.fast:\n        print_to_console(\"Fast LLM: \", Fore.GREEN, \"ENABLED\")\n        cfg.set_smart_llm_model(cfg.fast_llm_model)\n\n    if args.debug:\n        print_to_console(\"Debug Mode: \", Fore.GREEN, \"ENABLED\")\n        cfg.set_debug_mode(True)", "\n\n# TODO: fill in llm values here\n# check_openai_api_key()\ncfg = Config()\nlogger = configure_logging()\nparse_arguments()\nai_name = \"\"\nprompt = construct_prompt()\n# print(prompt)", "prompt = construct_prompt()\n# print(prompt)\n# Initialize variables\nfull_message_history = []\nresult = None\nnext_action_count = 0\n# Make a constant:\nuser_input = \"Determine which next command to use, and respond using the format specified above:\"\n\n# Initialize memory and make sure it is empty.", "\n# Initialize memory and make sure it is empty.\n# this is particularly important for indexing and referencing pinecone memory\nmemory = get_memory(cfg, init=True)\nprint('Using memory of type: ' + memory.__class__.__name__)\n\n# Interaction Loop\nwhile True:\n    # Send message to AI, get response\n    with Spinner(\"Thinking... \"):\n        assistant_reply = chat.chat_with_ai(\n            prompt,\n            user_input,\n            full_message_history,\n            memory,\n            cfg.fast_token_limit) # TODO: This hardcodes the model to use the fast llm. Make this an argument", "    # Send message to AI, get response\n    with Spinner(\"Thinking... \"):\n        assistant_reply = chat.chat_with_ai(\n            prompt,\n            user_input,\n            full_message_history,\n            memory,\n            cfg.fast_token_limit) # TODO: This hardcodes the model to use the fast llm. Make this an argument\n\n    # Print Assistant thoughts", "\n    # Print Assistant thoughts\n    print_assistant_thoughts(assistant_reply)\n\n    # Get command name and arguments\n    try:\n        command_name, arguments = cmd.get_command(assistant_reply)\n    except Exception as e:\n        print_to_console(\"Error: \\n\", Fore.RED, str(e))\n\n    if not cfg.continuous_mode and next_action_count == 0:\n        ### GET USER AUTHORIZATION TO EXECUTE COMMAND ###\n        # Get key press: Prompt the user to press enter to continue or escape\n        # to exit\n        user_input = \"\"\n        print_to_console(\n            \"NEXT ACTION: \",\n            Fore.CYAN,\n            f\"COMMAND = {Fore.CYAN}{command_name}{Style.RESET_ALL}  ARGUMENTS = {Fore.CYAN}{arguments}{Style.RESET_ALL}\")\n        print(\n            f\"Enter 'y' to authorise command, 'y -N' to run N continuous commands, 'n' to exit program, or enter feedback for {ai_name}...\",\n            flush=True)\n        while True:\n            console_input = utils.clean_input(Fore.MAGENTA + \"Input:\" + Style.RESET_ALL)\n            if console_input.lower() == \"y\":\n                user_input = \"GENERATE NEXT COMMAND JSON\"\n                break\n            elif console_input.lower().startswith(\"y -\"):\n                try:\n                    next_action_count = abs(int(console_input.split(\" \")[1]))\n                    user_input = \"GENERATE NEXT COMMAND JSON\"\n                except ValueError:\n                    print(\"Invalid input format. Please enter 'y -n' where n is the number of continuous tasks.\")\n                    continue\n                break\n            elif console_input.lower() == \"n\":\n                user_input = \"EXIT\"\n                break\n            else:\n                user_input = console_input\n                command_name = \"human_feedback\"\n                break\n\n        if user_input == \"GENERATE NEXT COMMAND JSON\":\n            print_to_console(\n            \"-=-=-=-=-=-=-= COMMAND AUTHORISED BY USER -=-=-=-=-=-=-=\",\n            Fore.MAGENTA,\n            \"\")\n        elif user_input == \"EXIT\":\n            print(\"Exiting...\", flush=True)\n            break\n    else:\n        # Print command\n        print_to_console(\n            \"NEXT ACTION: \",\n            Fore.CYAN,\n            f\"COMMAND = {Fore.CYAN}{command_name}{Style.RESET_ALL}  ARGUMENTS = {Fore.CYAN}{arguments}{Style.RESET_ALL}\")", "\n    if not cfg.continuous_mode and next_action_count == 0:\n        ### GET USER AUTHORIZATION TO EXECUTE COMMAND ###\n        # Get key press: Prompt the user to press enter to continue or escape\n        # to exit\n        user_input = \"\"\n        print_to_console(\n            \"NEXT ACTION: \",\n            Fore.CYAN,\n            f\"COMMAND = {Fore.CYAN}{command_name}{Style.RESET_ALL}  ARGUMENTS = {Fore.CYAN}{arguments}{Style.RESET_ALL}\")\n        print(\n            f\"Enter 'y' to authorise command, 'y -N' to run N continuous commands, 'n' to exit program, or enter feedback for {ai_name}...\",\n            flush=True)\n        while True:\n            console_input = utils.clean_input(Fore.MAGENTA + \"Input:\" + Style.RESET_ALL)\n            if console_input.lower() == \"y\":\n                user_input = \"GENERATE NEXT COMMAND JSON\"\n                break\n            elif console_input.lower().startswith(\"y -\"):\n                try:\n                    next_action_count = abs(int(console_input.split(\" \")[1]))\n                    user_input = \"GENERATE NEXT COMMAND JSON\"\n                except ValueError:\n                    print(\"Invalid input format. Please enter 'y -n' where n is the number of continuous tasks.\")\n                    continue\n                break\n            elif console_input.lower() == \"n\":\n                user_input = \"EXIT\"\n                break\n            else:\n                user_input = console_input\n                command_name = \"human_feedback\"\n                break\n\n        if user_input == \"GENERATE NEXT COMMAND JSON\":\n            print_to_console(\n            \"-=-=-=-=-=-=-= COMMAND AUTHORISED BY USER -=-=-=-=-=-=-=\",\n            Fore.MAGENTA,\n            \"\")\n        elif user_input == \"EXIT\":\n            print(\"Exiting...\", flush=True)\n            break\n    else:\n        # Print command\n        print_to_console(\n            \"NEXT ACTION: \",\n            Fore.CYAN,\n            f\"COMMAND = {Fore.CYAN}{command_name}{Style.RESET_ALL}  ARGUMENTS = {Fore.CYAN}{arguments}{Style.RESET_ALL}\")", "\n    # Execute command\n    if command_name.lower().startswith( \"error\" ):\n        result = f\"Command {command_name} threw the following error: \" + arguments\n    elif command_name == \"human_feedback\":\n        result = f\"Human feedback: {user_input}\"\n    else:\n        result = f\"Command {command_name} returned: {cmd.execute_command(command_name, arguments)}\"\n        if next_action_count > 0:\n            next_action_count -= 1", "\n    memory_to_add = f\"Assistant Reply: {assistant_reply} \" \\\n                    f\"\\nResult: {result} \" \\\n                    f\"\\nHuman Feedback: {user_input} \"\n\n    memory.add(memory_to_add)\n\n    # Check if there's a result from the command append it to the message\n    # history\n    if result is not None:\n        full_message_history.append(chat.create_chat_message(\"system\", result))\n        print_to_console(\"SYSTEM: \", Fore.YELLOW, result)\n    else:\n        full_message_history.append(\n            chat.create_chat_message(\n                \"system\", \"Unable to execute command\"))\n        print_to_console(\"SYSTEM: \", Fore.YELLOW, \"Unable to execute command\")", "    # history\n    if result is not None:\n        full_message_history.append(chat.create_chat_message(\"system\", result))\n        print_to_console(\"SYSTEM: \", Fore.YELLOW, result)\n    else:\n        full_message_history.append(\n            chat.create_chat_message(\n                \"system\", \"Unable to execute command\"))\n        print_to_console(\"SYSTEM: \", Fore.YELLOW, \"Unable to execute command\")\n", "\n"]}
{"filename": "scripts/config.py", "chunked_list": ["import abc\nimport os\nfrom dotenv import load_dotenv\n# Load environment variables from .env file\nload_dotenv()\n\n\nclass Singleton(abc.ABCMeta, type):\n    \"\"\"\n    Singleton metaclass for ensuring only one instance of a class.\n    \"\"\"\n\n    _instances = {}\n\n    def __call__(cls, *args, **kwargs):\n        \"\"\"Call method for the singleton metaclass.\"\"\"\n        if cls not in cls._instances:\n            cls._instances[cls] = super(\n                Singleton, cls).__call__(\n                *args, **kwargs)\n        return cls._instances[cls]", "\n\nclass AbstractSingleton(abc.ABC, metaclass=Singleton):\n    pass\n\n\nclass Config(metaclass=Singleton):\n    \"\"\"\n    Configuration class to store the state of bools for different scripts access.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the Config class\"\"\"\n        self.debug = False\n        self.continuous_mode = False\n        self.speak_mode = False\n\n        self.fast_llm_model = os.getenv(\"FAST_LLM_MODEL\", \"./models/7B/ggml-model.bin\")\n        self.smart_llm_model = os.getenv(\"SMART_LLM_MODEL\", \"./models/13B/ggml-vicuna-13b-4bit.bin\")\n        self.fast_token_limit = int(os.getenv(\"FAST_TOKEN_LIMIT\", 1500))\n        self.smart_token_limit = int(os.getenv(\"SMART_TOKEN_LIMIT\", 2000))\n\n        self.elevenlabs_api_key = os.getenv(\"ELEVENLABS_API_KEY\")\n\n        self.use_mac_os_tts = False\n        self.use_mac_os_tts = os.getenv(\"USE_MAC_OS_TTS\")\n        \n        self.google_api_key = os.getenv(\"GOOGLE_API_KEY\")\n        self.custom_search_engine_id = os.getenv(\"CUSTOM_SEARCH_ENGINE_ID\")\n\n        self.pinecone_api_key = os.getenv(\"PINECONE_API_KEY\")\n        self.pinecone_region = os.getenv(\"PINECONE_ENV\")\n\n        self.image_provider = os.getenv(\"IMAGE_PROVIDER\")\n        self.huggingface_api_token = os.getenv(\"HUGGINGFACE_API_TOKEN\")\n\n        # User agent headers to use when browsing web\n        # Some websites might just completely deny request with an error code if no user agent was found.\n        self.user_agent_header = {\"User-Agent\":\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.97 Safari/537.36\"}\n        self.redis_host = os.getenv(\"REDIS_HOST\", \"localhost\")\n        self.redis_port = os.getenv(\"REDIS_PORT\", \"6379\")\n        self.redis_password = os.getenv(\"REDIS_PASSWORD\", \"\")\n        self.wipe_redis_on_start = os.getenv(\"WIPE_REDIS_ON_START\", \"True\") == 'True'\n        self.memory_index = os.getenv(\"MEMORY_INDEX\", 'auto-gpt')\n        # Note that indexes must be created on db 0 in redis, this is not configureable.\n\n        self.memory_backend = os.getenv(\"MEMORY_BACKEND\", 'local')\n\n    def set_continuous_mode(self, value: bool):\n        \"\"\"Set the continuous mode value.\"\"\"\n        self.continuous_mode = value\n\n    def set_speak_mode(self, value: bool):\n        \"\"\"Set the speak mode value.\"\"\"\n        self.speak_mode = value\n\n    def set_debug_mode(self, value: bool):\n        self.debug_mode = value\n\n    def set_fast_llm_model(self, value: str):\n        \"\"\"Set the fast LLM model value.\"\"\"\n        self.fast_llm_model = value\n\n    def set_smart_llm_model(self, value: str):\n        \"\"\"Set the smart LLM model value.\"\"\"\n        self.smart_llm_model = value\n\n    def set_fast_token_limit(self, value: int):\n        \"\"\"Set the fast token limit value.\"\"\"\n        self.fast_token_limit = value\n\n    def set_smart_token_limit(self, value: int):\n        \"\"\"Set the smart token limit value.\"\"\"\n        self.smart_token_limit = value\n\n    def set_elevenlabs_api_key(self, value: str):\n        \"\"\"Set the ElevenLabs API key value.\"\"\"\n        self.elevenlabs_api_key = value\n\n    def set_google_api_key(self, value: str):\n        \"\"\"Set the Google API key value.\"\"\"\n        self.google_api_key = value\n\n    def set_custom_search_engine_id(self, value: str):\n        \"\"\"Set the custom search engine id value.\"\"\"\n        self.custom_search_engine_id = value\n\n    def set_pinecone_api_key(self, value: str):\n        \"\"\"Set the Pinecone API key value.\"\"\"\n        self.pinecone_api_key = value\n\n    def set_pinecone_region(self, value: str):\n        \"\"\"Set the Pinecone region value.\"\"\"\n        self.pinecone_region = value\n\n    def set_debug_mode(self, value: bool):\n        \"\"\"Set the debug mode value.\"\"\"\n        self.debug = value", ""]}
{"filename": "scripts/token_counter.py", "chunked_list": ["import tiktoken\nfrom typing import List, Dict\n\ndef count_message_tokens(messages : List[Dict[str, str]], model : str = \"13b\") -> int:\n    \"\"\"\n    Returns the number of tokens used by a list of messages.\n\n    Args:\n    messages (list): A list of messages, each of which is a dictionary containing the role and content of the message.\n    model (str): The name of the model to use for tokenization. Defaults to a 13b model.\n\n    Returns:\n    int: The number of tokens used by the list of messages.\n    \"\"\"\n    try:\n        encoding = tiktoken.encoding_for_model(model)\n    except KeyError:\n        print(\"Warning: model not found. Using cl100k_base encoding.\")\n        encoding = tiktoken.get_encoding(\"cl100k_base\")\n    if \"7b\" in model.lower():\n        tokens_per_message = 4  # every message follows <|start|>{role/name}\\n{content}<|end|>\\n\n        tokens_per_name = -1  # if there's a name, the role is omitted\n    elif \"13b\" in model.lower():\n        tokens_per_message = 3\n        tokens_per_name = 1\n    else:\n        return count_message_tokens(messages, model=\"13b\")\n    num_tokens = 0\n    for message in messages:\n        num_tokens += tokens_per_message\n        for key, value in message.items():\n            num_tokens += len(encoding.encode(value))\n            if key == \"name\":\n                num_tokens += tokens_per_name\n    num_tokens += 3  # every reply is primed with <|start|>assistant<|message|>\n    return num_tokens", "\ndef count_string_tokens(string: str, model_name: str) -> int:\n    \"\"\"\n    Returns the number of tokens in a text string.\n\n    Args:\n    string (str): The text string.\n    model_name (str): The name of the encoding to use. (e.g., \"ggml-vicuna-13b-4bit\")\n\n    Returns:\n    int: The number of tokens in the text string.\n    \"\"\"\n    encoding = tiktoken.encoding_for_model(model_name)\n    num_tokens = len(encoding.encode(string))\n    return num_tokens", ""]}
{"filename": "scripts/agent_manager.py", "chunked_list": ["from llm_utils import create_chat_completion\n\nnext_key = 0\nagents = {}  # key, (task, full_message_history, model)\n\n# Create new GPT agent\n# TODO: Centralise use of create_chat_completion() to globally enforce token limit\n\ndef create_agent(task, prompt, model):\n    \"\"\"Create a new agent and return its key\"\"\"\n    global next_key\n    global agents\n\n    messages = [{\"role\": \"user\", \"content\": prompt}, ]\n\n    # Start GTP3 instance\n    agent_reply = create_chat_completion(\n        model=model,\n        messages=messages,\n    )\n\n    # Update full message history\n    messages.append({\"role\": \"assistant\", \"content\": agent_reply})\n\n    key = next_key\n    # This is done instead of len(agents) to make keys unique even if agents\n    # are deleted\n    next_key += 1\n\n    agents[key] = (task, messages, model)\n\n    return key, agent_reply", "def create_agent(task, prompt, model):\n    \"\"\"Create a new agent and return its key\"\"\"\n    global next_key\n    global agents\n\n    messages = [{\"role\": \"user\", \"content\": prompt}, ]\n\n    # Start GTP3 instance\n    agent_reply = create_chat_completion(\n        model=model,\n        messages=messages,\n    )\n\n    # Update full message history\n    messages.append({\"role\": \"assistant\", \"content\": agent_reply})\n\n    key = next_key\n    # This is done instead of len(agents) to make keys unique even if agents\n    # are deleted\n    next_key += 1\n\n    agents[key] = (task, messages, model)\n\n    return key, agent_reply", "\n\ndef message_agent(key, message):\n    \"\"\"Send a message to an agent and return its response\"\"\"\n    global agents\n\n    task, messages, model = agents[int(key)]\n\n    # Add user message to message history before sending to agent\n    messages.append({\"role\": \"user\", \"content\": message})\n\n    # Start GTP3 instance\n    agent_reply = create_chat_completion(\n        model=model,\n        messages=messages,\n    )\n\n    # Update full message history\n    messages.append({\"role\": \"assistant\", \"content\": agent_reply})\n\n    return agent_reply", "\n\ndef list_agents():\n    \"\"\"Return a list of all agents\"\"\"\n    global agents\n\n    # Return a list of agent keys and their tasks\n    return [(key, task) for key, (task, _, _) in agents.items()]\n\n\ndef delete_agent(key):\n    \"\"\"Delete an agent and return True if successful, False otherwise\"\"\"\n    global agents\n\n    try:\n        del agents[int(key)]\n        return True\n    except KeyError:\n        return False", "\n\ndef delete_agent(key):\n    \"\"\"Delete an agent and return True if successful, False otherwise\"\"\"\n    global agents\n\n    try:\n        del agents[int(key)]\n        return True\n    except KeyError:\n        return False", ""]}
{"filename": "scripts/file_operations.py", "chunked_list": ["import os\nimport os.path\n\n# Set a dedicated folder for file I/O\nworking_directory = \"auto_gpt_workspace\"\n\n# Create the directory if it doesn't exist\nif not os.path.exists(working_directory):\n    os.makedirs(working_directory)\n", "\n\ndef safe_join(base, *paths):\n    \"\"\"Join one or more path components intelligently.\"\"\"\n    new_path = os.path.join(base, *paths)\n    norm_new_path = os.path.normpath(new_path)\n\n    if os.path.commonprefix([base, norm_new_path]) != base:\n        raise ValueError(\"Attempted to access outside of working directory.\")\n\n    return norm_new_path", "\n\ndef read_file(filename):\n    \"\"\"Read a file and return the contents\"\"\"\n    try:\n        filepath = safe_join(working_directory, filename)\n        with open(filepath, \"r\", encoding='utf-8') as f:\n            content = f.read()\n        return content\n    except Exception as e:\n        return \"Error: \" + str(e)", "\n\ndef write_to_file(filename, text):\n    \"\"\"Write text to a file\"\"\"\n    try:\n        filepath = safe_join(working_directory, filename)\n        directory = os.path.dirname(filepath)\n        if not os.path.exists(directory):\n            os.makedirs(directory)\n        with open(filepath, \"w\") as f:\n            f.write(text)\n        return \"File written to successfully.\"\n    except Exception as e:\n        return \"Error: \" + str(e)", "\n\ndef append_to_file(filename, text):\n    \"\"\"Append text to a file\"\"\"\n    try:\n        filepath = safe_join(working_directory, filename)\n        with open(filepath, \"a\") as f:\n            f.write(text)\n        return \"Text appended successfully.\"\n    except Exception as e:\n        return \"Error: \" + str(e)", "\n\ndef delete_file(filename):\n    \"\"\"Delete a file\"\"\"\n    try:\n        filepath = safe_join(working_directory, filename)\n        os.remove(filepath)\n        return \"File deleted successfully.\"\n    except Exception as e:\n        return \"Error: \" + str(e)", "\ndef search_files(directory):\n    found_files = []\n\n    if directory == \"\" or directory == \"/\":\n        search_directory = working_directory\n    else:\n        search_directory = safe_join(working_directory, directory)\n\n    for root, _, files in os.walk(search_directory):\n        for file in files:\n            if file.startswith('.'):\n                continue\n            relative_path = os.path.relpath(os.path.join(root, file), working_directory)\n            found_files.append(relative_path)\n\n    return found_files"]}
{"filename": "scripts/execute_code.py", "chunked_list": ["import docker\nimport os\n\n\ndef execute_python_file(file):\n    \"\"\"Execute a Python file in a Docker container and return the output\"\"\"\n    workspace_folder = \"auto_gpt_workspace\"\n\n    print (f\"Executing file '{file}' in workspace '{workspace_folder}'\")\n\n    if not file.endswith(\".py\"):\n        return \"Error: Invalid file type. Only .py files are allowed.\"\n\n    file_path = os.path.join(workspace_folder, file)\n\n    if not os.path.isfile(file_path):\n        return f\"Error: File '{file}' does not exist.\"\n\n    try:\n        client = docker.from_env()\n\n        # You can replace 'python:3.8' with the desired Python image/version\n        # You can find available Python images on Docker Hub:\n        # https://hub.docker.com/_/python\n        container = client.containers.run(\n            'python:3.10',\n            f'python {file}',\n            volumes={\n                os.path.abspath(workspace_folder): {\n                    'bind': '/workspace',\n                    'mode': 'ro'}},\n            working_dir='/workspace',\n            stderr=True,\n            stdout=True,\n            detach=True,\n        )\n\n        output = container.wait()\n        logs = container.logs().decode('utf-8')\n        container.remove()\n\n        # print(f\"Execution complete. Output: {output}\")\n        # print(f\"Logs: {logs}\")\n\n        return logs\n\n    except Exception as e:\n        return f\"Error: {str(e)}\"", ""]}
{"filename": "scripts/utils.py", "chunked_list": ["def clean_input(prompt: str=''):\n    try:\n        return input(prompt)\n    except KeyboardInterrupt:\n        print(\"You interrupted Auto-Llama\")\n        print(\"Quitting...\")\n        exit(0)\n\n", ""]}
{"filename": "scripts/data.py", "chunked_list": ["import os\nfrom pathlib import Path\n\ndef load_prompt():\n    \"\"\"Load the prompt from data/prompt.txt\"\"\"\n    try:\n        # get directory of this file:\n        file_dir = Path(__file__).parent\n        prompt_file_path = file_dir / \"data\" / \"prompt.txt\"\n\n        # Load the prompt from data/prompt.txt\n        with open(prompt_file_path, \"r\") as prompt_file:\n            prompt = prompt_file.read()\n\n        return prompt\n    except FileNotFoundError:\n        print(\"Error: Prompt file not found\", flush=True)\n        return \"\"", ""]}
{"filename": "scripts/ai_config.py", "chunked_list": ["import yaml\nimport data\nimport os\n\nclass AIConfig:\n    \"\"\"\n    A class object that contains the configuration information for the AI\n\n    Attributes:\n        ai_name (str): The name of the AI.\n        ai_role (str): The description of the AI's role.\n        ai_goals (list): The list of objectives the AI is supposed to complete.\n    \"\"\"\n\n    def __init__(self, ai_name: str=\"\", ai_role: str=\"\", ai_goals: list=[]) -> None:\n        \"\"\"\n        Initialize a class instance\n\n        Parameters:\n            ai_name (str): The name of the AI.\n            ai_role (str): The description of the AI's role.\n            ai_goals (list): The list of objectives the AI is supposed to complete.\n        Returns:\n            None\n        \"\"\"\n\n        self.ai_name = ai_name\n        self.ai_role = ai_role\n        self.ai_goals = ai_goals\n\n    # Soon this will go in a folder where it remembers more stuff about the run(s)\n    SAVE_FILE = os.path.join(os.path.dirname(__file__), '..', 'ai_settings.yaml')\n\n    @classmethod\n    def load(cls: object, config_file: str=SAVE_FILE) -> object:\n        \"\"\"\n        Returns class object with parameters (ai_name, ai_role, ai_goals) loaded from yaml file if yaml file exists,\n        else returns class with no parameters.\n\n        Parameters:\n           cls (class object): An AIConfig Class object.\n           config_file (int): The path to the config yaml file. DEFAULT: \"../ai_settings.yaml\"\n\n        Returns:\n            cls (object): A instance of given cls object\n        \"\"\"\n\n        try:\n            with open(config_file) as file:\n                config_params = yaml.load(file, Loader=yaml.FullLoader)\n        except FileNotFoundError:\n            config_params = {}\n\n        ai_name = config_params.get(\"ai_name\", \"\")\n        ai_role = config_params.get(\"ai_role\", \"\")\n        ai_goals = config_params.get(\"ai_goals\", [])\n\n        return cls(ai_name, ai_role, ai_goals)\n\n    def save(self, config_file: str=SAVE_FILE) -> None:\n        \"\"\"\n        Saves the class parameters to the specified file yaml file path as a yaml file.\n\n        Parameters:\n            config_file(str): The path to the config yaml file. DEFAULT: \"../ai_settings.yaml\"\n\n        Returns:\n            None\n        \"\"\"\n\n        config = {\"ai_name\": self.ai_name, \"ai_role\": self.ai_role, \"ai_goals\": self.ai_goals}\n        with open(config_file, \"w\") as file:\n            yaml.dump(config, file)\n\n    def construct_full_prompt(self) -> str:\n        \"\"\"\n        Returns a prompt to the user with the class information in an organized fashion.\n\n        Parameters:\n            None\n\n        Returns:\n            full_prompt (str): A string containing the intitial prompt for the user including the ai_name, ai_role and ai_goals.\n        \"\"\"\n\n        prompt_start = \"\"\"Your decisions must always be made independently without seeking user assistance. Play to your strengths as an LLM and pursue simple strategies with no legal complications.\"\"\"\n\n        # Construct full prompt\n        full_prompt = f\"You are {self.ai_name}, {self.ai_role}\\n{prompt_start}\\n\\nGOALS:\\n\\n\"\n        for i, goal in enumerate(self.ai_goals):\n            full_prompt += f\"{i+1}. {goal}\\n\"\n\n        full_prompt += f\"\\n\\n{data.load_prompt()}\"\n        return full_prompt", "\n"]}
{"filename": "scripts/browse.py", "chunked_list": ["import requests\nfrom bs4 import BeautifulSoup\nfrom config import Config\nfrom llm_utils import create_chat_completion\n\ncfg = Config()\n\n# Define and check for local file address prefixes\ndef check_local_file_access(url):\n    local_prefixes = ['file:///', 'file://localhost', 'http://localhost', 'https://localhost']\n    return any(url.startswith(prefix) for prefix in local_prefixes)", "def check_local_file_access(url):\n    local_prefixes = ['file:///', 'file://localhost', 'http://localhost', 'https://localhost']\n    return any(url.startswith(prefix) for prefix in local_prefixes)\n\ndef scrape_text(url):\n    \"\"\"Scrape text from a webpage\"\"\"\n    # Most basic check if the URL is valid:\n    if not url.startswith('http'):\n        return \"Error: Invalid URL\"\n    \n    # Restrict access to local files\n    if check_local_file_access(url):\n        return \"Error: Access to local files is restricted\"\n    \n    try:\n        response = requests.get(url, headers=cfg.user_agent_header)\n    except requests.exceptions.RequestException as e:\n        return \"Error: \" + str(e)\n\n    # Check if the response contains an HTTP error\n    if response.status_code >= 400:\n        return \"Error: HTTP \" + str(response.status_code) + \" error\"\n\n    soup = BeautifulSoup(response.text, \"html.parser\")\n\n    for script in soup([\"script\", \"style\"]):\n        script.extract()\n\n    text = soup.get_text()\n    lines = (line.strip() for line in text.splitlines())\n    chunks = (phrase.strip() for line in lines for phrase in line.split(\"  \"))\n    text = '\\n'.join(chunk for chunk in chunks if chunk)\n\n    return text", "\n\ndef extract_hyperlinks(soup):\n    \"\"\"Extract hyperlinks from a BeautifulSoup object\"\"\"\n    hyperlinks = []\n    for link in soup.find_all('a', href=True):\n        hyperlinks.append((link.text, link['href']))\n    return hyperlinks\n\n\ndef format_hyperlinks(hyperlinks):\n    \"\"\"Format hyperlinks into a list of strings\"\"\"\n    formatted_links = []\n    for link_text, link_url in hyperlinks:\n        formatted_links.append(f\"{link_text} ({link_url})\")\n    return formatted_links", "\n\ndef format_hyperlinks(hyperlinks):\n    \"\"\"Format hyperlinks into a list of strings\"\"\"\n    formatted_links = []\n    for link_text, link_url in hyperlinks:\n        formatted_links.append(f\"{link_text} ({link_url})\")\n    return formatted_links\n\n\ndef scrape_links(url):\n    \"\"\"Scrape links from a webpage\"\"\"\n    response = requests.get(url, headers=cfg.user_agent_header)\n\n    # Check if the response contains an HTTP error\n    if response.status_code >= 400:\n        return \"error\"\n\n    soup = BeautifulSoup(response.text, \"html.parser\")\n\n    for script in soup([\"script\", \"style\"]):\n        script.extract()\n\n    hyperlinks = extract_hyperlinks(soup)\n\n    return format_hyperlinks(hyperlinks)", "\n\ndef scrape_links(url):\n    \"\"\"Scrape links from a webpage\"\"\"\n    response = requests.get(url, headers=cfg.user_agent_header)\n\n    # Check if the response contains an HTTP error\n    if response.status_code >= 400:\n        return \"error\"\n\n    soup = BeautifulSoup(response.text, \"html.parser\")\n\n    for script in soup([\"script\", \"style\"]):\n        script.extract()\n\n    hyperlinks = extract_hyperlinks(soup)\n\n    return format_hyperlinks(hyperlinks)", "\n\ndef split_text(text, max_length=8192):\n    \"\"\"Split text into chunks of a maximum length\"\"\"\n    paragraphs = text.split(\"\\n\")\n    current_length = 0\n    current_chunk = []\n\n    for paragraph in paragraphs:\n        if current_length + len(paragraph) + 1 <= max_length:\n            current_chunk.append(paragraph)\n            current_length += len(paragraph) + 1\n        else:\n            yield \"\\n\".join(current_chunk)\n            current_chunk = [paragraph]\n            current_length = len(paragraph) + 1\n\n    if current_chunk:\n        yield \"\\n\".join(current_chunk)", "\n\ndef create_message(chunk, question):\n    \"\"\"Create a message for the user to summarize a chunk of text\"\"\"\n    return {\n        \"role\": \"user\",\n        \"content\": f\"\\\"\\\"\\\"{chunk}\\\"\\\"\\\" Using the above text, please answer the following question: \\\"{question}\\\" -- if the question cannot be answered using the text, please summarize the text.\"\n    }\n\ndef summarize_text(text, question):\n    \"\"\"Summarize text using the LLM model\"\"\"\n    if not text:\n        return \"Error: No text to summarize\"\n\n    text_length = len(text)\n    print(f\"Text length: {text_length} characters\")\n\n    summaries = []\n    chunks = list(split_text(text))\n\n    for i, chunk in enumerate(chunks):\n        print(f\"Summarizing chunk {i + 1} / {len(chunks)}\")\n        messages = [create_message(chunk, question)]\n\n        summary = create_chat_completion(\n            model=cfg.fast_llm_model,\n            messages=messages,\n            max_tokens=300,\n        )\n        summaries.append(summary)\n\n    print(f\"Summarized {len(chunks)} chunks.\")\n\n    combined_summary = \"\\n\".join(summaries)\n    messages = [create_message(combined_summary, question)]\n\n    final_summary = create_chat_completion(\n        model=cfg.fast_llm_model,\n        messages=messages,\n        max_tokens=300,\n    )\n\n    return final_summary", "\ndef summarize_text(text, question):\n    \"\"\"Summarize text using the LLM model\"\"\"\n    if not text:\n        return \"Error: No text to summarize\"\n\n    text_length = len(text)\n    print(f\"Text length: {text_length} characters\")\n\n    summaries = []\n    chunks = list(split_text(text))\n\n    for i, chunk in enumerate(chunks):\n        print(f\"Summarizing chunk {i + 1} / {len(chunks)}\")\n        messages = [create_message(chunk, question)]\n\n        summary = create_chat_completion(\n            model=cfg.fast_llm_model,\n            messages=messages,\n            max_tokens=300,\n        )\n        summaries.append(summary)\n\n    print(f\"Summarized {len(chunks)} chunks.\")\n\n    combined_summary = \"\\n\".join(summaries)\n    messages = [create_message(combined_summary, question)]\n\n    final_summary = create_chat_completion(\n        model=cfg.fast_llm_model,\n        messages=messages,\n        max_tokens=300,\n    )\n\n    return final_summary", ""]}
{"filename": "scripts/ai_functions.py", "chunked_list": ["from typing import List, Optional\nimport json\nfrom config import Config\nfrom call_ai_function import call_ai_function\nfrom json_parser import fix_and_parse_json\ncfg = Config()\n\n\ndef evaluate_code(code: str) -> List[str]:\n    \"\"\"\n    A function that takes in a string and returns a response from create chat completion api call.\n\n    Parameters:\n        code (str): Code to be evaluated.\n    Returns:\n        A result string from create chat completion. A list of suggestions to improve the code.\n    \"\"\"\n\n    function_string = \"def analyze_code(code: str) -> List[str]:\"\n    args = [code]\n    description_string = \"\"\"Analyzes the given code and returns a list of suggestions for improvements.\"\"\"\n\n    result_string = call_ai_function(function_string, args, description_string)\n\n    return result_string", "def evaluate_code(code: str) -> List[str]:\n    \"\"\"\n    A function that takes in a string and returns a response from create chat completion api call.\n\n    Parameters:\n        code (str): Code to be evaluated.\n    Returns:\n        A result string from create chat completion. A list of suggestions to improve the code.\n    \"\"\"\n\n    function_string = \"def analyze_code(code: str) -> List[str]:\"\n    args = [code]\n    description_string = \"\"\"Analyzes the given code and returns a list of suggestions for improvements.\"\"\"\n\n    result_string = call_ai_function(function_string, args, description_string)\n\n    return result_string", "\n\ndef improve_code(suggestions: List[str], code: str) -> str:\n    \"\"\"\n    A function that takes in code and suggestions and returns a response from create chat completion api call.\n\n    Parameters:\n        suggestions (List): A list of suggestions around what needs to be improved.\n        code (str): Code to be improved.\n    Returns:\n        A result string from create chat completion. Improved code in response.\n    \"\"\"\n\n    function_string = (\n        \"def generate_improved_code(suggestions: List[str], code: str) -> str:\"\n    )\n    args = [json.dumps(suggestions), code]\n    description_string = \"\"\"Improves the provided code based on the suggestions provided, making no other changes.\"\"\"\n\n    result_string = call_ai_function(function_string, args, description_string)\n    return result_string", "\n\n\ndef write_tests(code: str, focus: List[str]) -> str:\n    \"\"\"\n    A function that takes in code and focus topics and returns a response from create chat completion api call.\n\n    Parameters:\n        focus (List): A list of suggestions around what needs to be improved.\n        code (str): Code for test cases to be generated against.\n    Returns:\n        A result string from create chat completion. Test cases for the submitted code in response.\n    \"\"\"\n\n    function_string = (\n        \"def create_test_cases(code: str, focus: Optional[str] = None) -> str:\"\n    )\n    args = [code, json.dumps(focus)]\n    description_string = \"\"\"Generates test cases for the existing code, focusing on specific areas if required.\"\"\"\n\n    result_string = call_ai_function(function_string, args, description_string)\n    return result_string", ""]}
{"filename": "scripts/commands.py", "chunked_list": ["import browse\nimport json\nfrom memory import get_memory\nimport datetime\nimport agent_manager as agents\nimport speak\nfrom config import Config\nimport ai_functions as ai\nfrom file_operations import read_file, write_to_file, append_to_file, delete_file, search_files\nfrom execute_code import execute_python_file", "from file_operations import read_file, write_to_file, append_to_file, delete_file, search_files\nfrom execute_code import execute_python_file\nfrom json_parser import fix_and_parse_json\nfrom image_gen import generate_image\nfrom duckduckgo_search import ddg\nfrom googleapiclient.discovery import build\nfrom googleapiclient.errors import HttpError\n\ncfg = Config()\n", "cfg = Config()\n\n\ndef is_valid_int(value):\n    try:\n        int(value)\n        return True\n    except ValueError:\n        return False\n\ndef get_command(response):\n    \"\"\"Parse the response and return the command name and arguments\"\"\"\n    try:\n        response_json = fix_and_parse_json(response)\n\n        if \"command\" not in response_json:\n            return \"Error:\" , \"Missing 'command' object in JSON\"\n\n        command = response_json[\"command\"]\n\n        if \"name\" not in command:\n            return \"Error:\", \"Missing 'name' field in 'command' object\"\n\n        command_name = command[\"name\"]\n\n        # Use an empty dictionary if 'args' field is not present in 'command' object\n        arguments = command.get(\"args\", {})\n\n        return command_name, arguments\n    except json.decoder.JSONDecodeError:\n        return \"Error:\", \"Invalid JSON\"\n    # All other errors, return \"Error: + error message\"\n    except Exception as e:\n        return \"Error:\", str(e)", "\ndef get_command(response):\n    \"\"\"Parse the response and return the command name and arguments\"\"\"\n    try:\n        response_json = fix_and_parse_json(response)\n\n        if \"command\" not in response_json:\n            return \"Error:\" , \"Missing 'command' object in JSON\"\n\n        command = response_json[\"command\"]\n\n        if \"name\" not in command:\n            return \"Error:\", \"Missing 'name' field in 'command' object\"\n\n        command_name = command[\"name\"]\n\n        # Use an empty dictionary if 'args' field is not present in 'command' object\n        arguments = command.get(\"args\", {})\n\n        return command_name, arguments\n    except json.decoder.JSONDecodeError:\n        return \"Error:\", \"Invalid JSON\"\n    # All other errors, return \"Error: + error message\"\n    except Exception as e:\n        return \"Error:\", str(e)", "\n\ndef execute_command(command_name, arguments):\n    \"\"\"Execute the command and return the result\"\"\"\n    memory = get_memory(cfg)\n\n    try:\n        if command_name == \"google\":\n\n            # Check if the Google API key is set and use the official search method\n            # If the API key is not set or has only whitespaces, use the unofficial search method\n            if cfg.google_api_key and (cfg.google_api_key.strip() if cfg.google_api_key else None):\n                return google_official_search(arguments[\"input\"])\n            else:\n                return google_search(arguments[\"input\"])\n        elif command_name == \"memory_add\":\n            return memory.add(arguments[\"string\"])\n        elif command_name == \"start_agent\":\n            return start_agent(\n                arguments[\"name\"],\n                arguments[\"task\"],\n                arguments[\"prompt\"])\n        elif command_name == \"message_agent\":\n            return message_agent(arguments[\"key\"], arguments[\"message\"])\n        elif command_name == \"list_agents\":\n            return list_agents()\n        elif command_name == \"delete_agent\":\n            return delete_agent(arguments[\"key\"])\n        elif command_name == \"get_text_summary\":\n            return get_text_summary(arguments[\"url\"], arguments[\"question\"])\n        elif command_name == \"get_hyperlinks\":\n            return get_hyperlinks(arguments[\"url\"])\n        elif command_name == \"read_file\":\n            return read_file(arguments[\"file\"])\n        elif command_name == \"write_to_file\":\n            return write_to_file(arguments[\"file\"], arguments[\"text\"])\n        elif command_name == \"append_to_file\":\n            return append_to_file(arguments[\"file\"], arguments[\"text\"])\n        elif command_name == \"delete_file\":\n            return delete_file(arguments[\"file\"])\n        elif command_name == \"search_files\":\n            return search_files(arguments[\"directory\"])\n        elif command_name == \"browse_website\":\n            return browse_website(arguments[\"url\"], arguments[\"question\"])\n        # TODO: Change these to take in a file rather than pasted code, if\n        # non-file is given, return instructions \"Input should be a python\n        # filepath, write your code to file and try again\"\n        elif command_name == \"evaluate_code\":\n            return ai.evaluate_code(arguments[\"code\"])\n        elif command_name == \"improve_code\":\n            return ai.improve_code(arguments[\"suggestions\"], arguments[\"code\"])\n        elif command_name == \"write_tests\":\n            return ai.write_tests(arguments[\"code\"], arguments.get(\"focus\"))\n        elif command_name == \"execute_python_file\":  # Add this command\n            return execute_python_file(arguments[\"file\"])\n        elif command_name == \"generate_image\":\n            return generate_image(arguments[\"prompt\"])\n        elif command_name == \"do_nothing\":\n            return \"No action performed.\"\n        elif command_name == \"task_complete\":\n            shutdown()\n        else:\n            return f\"Unknown command '{command_name}'. Please refer to the 'COMMANDS' list for availabe commands and only respond in the specified JSON format.\"\n    # All errors, return \"Error: + error message\"\n    except Exception as e:\n        return \"Error: \" + str(e)", "\n\ndef get_datetime():\n    \"\"\"Return the current date and time\"\"\"\n    return \"Current date and time: \" + \\\n        datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n\n\ndef google_search(query, num_results=8):\n    \"\"\"Return the results of a google search\"\"\"\n    search_results = []\n    for j in ddg(query, max_results=num_results):\n        search_results.append(j)\n\n    return json.dumps(search_results, ensure_ascii=False, indent=4)", "def google_search(query, num_results=8):\n    \"\"\"Return the results of a google search\"\"\"\n    search_results = []\n    for j in ddg(query, max_results=num_results):\n        search_results.append(j)\n\n    return json.dumps(search_results, ensure_ascii=False, indent=4)\n\ndef google_official_search(query, num_results=8):\n    \"\"\"Return the results of a google search using the official Google API\"\"\"\n    from googleapiclient.discovery import build\n    from googleapiclient.errors import HttpError\n    import json\n\n    try:\n        # Get the Google API key and Custom Search Engine ID from the config file\n        api_key = cfg.google_api_key\n        custom_search_engine_id = cfg.custom_search_engine_id\n\n        # Initialize the Custom Search API service\n        service = build(\"customsearch\", \"v1\", developerKey=api_key)\n\n        # Send the search query and retrieve the results\n        result = service.cse().list(q=query, cx=custom_search_engine_id, num=num_results).execute()\n\n        # Extract the search result items from the response\n        search_results = result.get(\"items\", [])\n\n        # Create a list of only the URLs from the search results\n        search_results_links = [item[\"link\"] for item in search_results]\n\n    except HttpError as e:\n        # Handle errors in the API call\n        error_details = json.loads(e.content.decode())\n\n        # Check if the error is related to an invalid or missing API key\n        if error_details.get(\"error\", {}).get(\"code\") == 403 and \"invalid API key\" in error_details.get(\"error\", {}).get(\"message\", \"\"):\n            return \"Error: The provided Google API key is invalid or missing.\"\n        else:\n            return f\"Error: {e}\"\n\n    # Return the list of search result URLs\n    return search_results_links", "def google_official_search(query, num_results=8):\n    \"\"\"Return the results of a google search using the official Google API\"\"\"\n    from googleapiclient.discovery import build\n    from googleapiclient.errors import HttpError\n    import json\n\n    try:\n        # Get the Google API key and Custom Search Engine ID from the config file\n        api_key = cfg.google_api_key\n        custom_search_engine_id = cfg.custom_search_engine_id\n\n        # Initialize the Custom Search API service\n        service = build(\"customsearch\", \"v1\", developerKey=api_key)\n\n        # Send the search query and retrieve the results\n        result = service.cse().list(q=query, cx=custom_search_engine_id, num=num_results).execute()\n\n        # Extract the search result items from the response\n        search_results = result.get(\"items\", [])\n\n        # Create a list of only the URLs from the search results\n        search_results_links = [item[\"link\"] for item in search_results]\n\n    except HttpError as e:\n        # Handle errors in the API call\n        error_details = json.loads(e.content.decode())\n\n        # Check if the error is related to an invalid or missing API key\n        if error_details.get(\"error\", {}).get(\"code\") == 403 and \"invalid API key\" in error_details.get(\"error\", {}).get(\"message\", \"\"):\n            return \"Error: The provided Google API key is invalid or missing.\"\n        else:\n            return f\"Error: {e}\"\n\n    # Return the list of search result URLs\n    return search_results_links", "\ndef browse_website(url, question):\n    \"\"\"Browse a website and return the summary and links\"\"\"\n    summary = get_text_summary(url, question)\n    links = get_hyperlinks(url)\n\n    # Limit links to 5\n    if len(links) > 5:\n        links = links[:5]\n\n    result = f\"\"\"Website Content Summary: {summary}\\n\\nLinks: {links}\"\"\"\n\n    return result", "\n\ndef get_text_summary(url, question):\n    \"\"\"Return the results of a google search\"\"\"\n    text = browse.scrape_text(url)\n    summary = browse.summarize_text(text, question)\n    return \"\"\" \"Result\" : \"\"\" + summary\n\n\ndef get_hyperlinks(url):\n    \"\"\"Return the results of a google search\"\"\"\n    link_list = browse.scrape_links(url)\n    return link_list", "\ndef get_hyperlinks(url):\n    \"\"\"Return the results of a google search\"\"\"\n    link_list = browse.scrape_links(url)\n    return link_list\n\n\ndef commit_memory(string):\n    \"\"\"Commit a string to memory\"\"\"\n    _text = f\"\"\"Committing memory with string \"{string}\" \"\"\"\n    mem.permanent_memory.append(string)\n    return _text", "\n\ndef delete_memory(key):\n    \"\"\"Delete a memory with a given key\"\"\"\n    if key >= 0 and key < len(mem.permanent_memory):\n        _text = \"Deleting memory with key \" + str(key)\n        del mem.permanent_memory[key]\n        print(_text)\n        return _text\n    else:\n        print(\"Invalid key, cannot delete memory.\")\n        return None", "\n\ndef overwrite_memory(key, string):\n    \"\"\"Overwrite a memory with a given key and string\"\"\"\n    # Check if the key is a valid integer\n    if is_valid_int(key):\n        key_int = int(key)\n        # Check if the integer key is within the range of the permanent_memory list\n        if 0 <= key_int < len(mem.permanent_memory):\n            _text = \"Overwriting memory with key \" + str(key) + \" and string \" + string\n            # Overwrite the memory slot with the given integer key and string\n            mem.permanent_memory[key_int] = string\n            print(_text)\n            return _text\n        else:\n            print(f\"Invalid key '{key}', out of range.\")\n            return None\n    # Check if the key is a valid string\n    elif isinstance(key, str):\n        _text = \"Overwriting memory with key \" + key + \" and string \" + string\n        # Overwrite the memory slot with the given string key and string\n        mem.permanent_memory[key] = string\n        print(_text)\n        return _text\n    else:\n        print(f\"Invalid key '{key}', must be an integer or a string.\")\n        return None", "\n\ndef shutdown():\n    \"\"\"Shut down the program\"\"\"\n    print(\"Shutting down...\")\n    quit()\n\n\ndef start_agent(name, task, prompt, model=cfg.fast_llm_model):\n    \"\"\"Start an agent with a given name, task, and prompt\"\"\"\n    global cfg\n\n    # Remove underscores from name\n    voice_name = name.replace(\"_\", \" \")\n\n    first_message = f\"\"\"You are {name}.  Respond with: \"Acknowledged\".\"\"\"\n    agent_intro = f\"{voice_name} here, Reporting for duty!\"\n\n    # Create agent\n    if cfg.speak_mode:\n        speak.say_text(agent_intro, 1)\n    key, ack = agents.create_agent(task, first_message, model)\n\n    if cfg.speak_mode:\n        speak.say_text(f\"Hello {voice_name}. Your task is as follows. {task}.\")\n\n    # Assign task (prompt), get response\n    agent_response = message_agent(key, prompt)\n\n    return f\"Agent {name} created with key {key}. First response: {agent_response}\"", "def start_agent(name, task, prompt, model=cfg.fast_llm_model):\n    \"\"\"Start an agent with a given name, task, and prompt\"\"\"\n    global cfg\n\n    # Remove underscores from name\n    voice_name = name.replace(\"_\", \" \")\n\n    first_message = f\"\"\"You are {name}.  Respond with: \"Acknowledged\".\"\"\"\n    agent_intro = f\"{voice_name} here, Reporting for duty!\"\n\n    # Create agent\n    if cfg.speak_mode:\n        speak.say_text(agent_intro, 1)\n    key, ack = agents.create_agent(task, first_message, model)\n\n    if cfg.speak_mode:\n        speak.say_text(f\"Hello {voice_name}. Your task is as follows. {task}.\")\n\n    # Assign task (prompt), get response\n    agent_response = message_agent(key, prompt)\n\n    return f\"Agent {name} created with key {key}. First response: {agent_response}\"", "\n\ndef message_agent(key, message):\n    \"\"\"Message an agent with a given key and message\"\"\"\n    global cfg\n\n    # Check if the key is a valid integer\n    if is_valid_int(key):\n        agent_response = agents.message_agent(int(key), message)\n    # Check if the key is a valid string\n    elif isinstance(key, str):\n        agent_response = agents.message_agent(key, message)\n    else:\n        return \"Invalid key, must be an integer or a string.\"\n\n    # Speak response\n    if cfg.speak_mode:\n        speak.say_text(agent_response, 1)\n    return agent_response", "\n\ndef list_agents():\n    \"\"\"List all agents\"\"\"\n    return agents.list_agents()\n\n\ndef delete_agent(key):\n    \"\"\"Delete an agent with a given key\"\"\"\n    result = agents.delete_agent(key)\n    if not result:\n        return f\"Agent {key} does not exist.\"\n    return f\"Agent {key} deleted.\"", ""]}
{"filename": "scripts/json_utils.py", "chunked_list": ["import re\nimport json\nfrom config import Config\n\ncfg = Config()\n\n\ndef extract_char_position(error_message: str) -> int:\n    \"\"\"Extract the character position from the JSONDecodeError message.\n\n    Args:\n        error_message (str): The error message from the JSONDecodeError\n          exception.\n\n    Returns:\n        int: The character position.\n    \"\"\"\n    import re\n\n    char_pattern = re.compile(r'\\(char (\\d+)\\)')\n    if match := char_pattern.search(error_message):\n        return int(match[1])\n    else:\n        raise ValueError(\"Character position not found in the error message.\")", "\n\ndef add_quotes_to_property_names(json_string: str) -> str:\n    \"\"\"\n    Add quotes to property names in a JSON string.\n\n    Args:\n        json_string (str): The JSON string.\n\n    Returns:\n        str: The JSON string with quotes added to property names.\n    \"\"\"\n\n    def replace_func(match):\n        return f'\"{match.group(1)}\":'\n\n    property_name_pattern = re.compile(r'(\\w+):')\n    corrected_json_string = property_name_pattern.sub(\n        replace_func,\n        json_string)\n\n    try:\n        json.loads(corrected_json_string)\n        return corrected_json_string\n    except json.JSONDecodeError as e:\n        raise e", "\n\ndef balance_braces(json_string: str) -> str:\n    \"\"\"\n    Balance the braces in a JSON string.\n\n    Args:\n        json_string (str): The JSON string.\n\n    Returns:\n        str: The JSON string with braces balanced.\n    \"\"\"\n\n    open_braces_count = json_string.count('{')\n    close_braces_count = json_string.count('}')\n\n    while open_braces_count > close_braces_count:\n        json_string += '}'\n        close_braces_count += 1\n\n    while close_braces_count > open_braces_count:\n        json_string = json_string.rstrip('}')\n        close_braces_count -= 1\n\n    try:\n        json.loads(json_string)\n        return json_string\n    except json.JSONDecodeError as e:\n        pass", "\n\ndef fix_invalid_escape(json_str: str, error_message: str) -> str:\n    while error_message.startswith('Invalid \\\\escape'):\n        bad_escape_location = extract_char_position(error_message)\n        json_str = json_str[:bad_escape_location] + \\\n            json_str[bad_escape_location + 1:]\n        try:\n            json.loads(json_str)\n            return json_str\n        except json.JSONDecodeError as e:\n            if cfg.debug:\n                print('json loads error - fix invalid escape', e)\n            error_message = str(e)\n    return json_str", "\n\ndef correct_json(json_str: str) -> str:\n    \"\"\"\n    Correct common JSON errors.\n\n    Args:\n        json_str (str): The JSON string.\n    \"\"\"\n\n    try:\n        if cfg.debug:\n            print(\"json\", json_str)\n        json.loads(json_str)\n        return json_str\n    except json.JSONDecodeError as e:\n        if cfg.debug:\n            print('json loads error', e)\n        error_message = str(e)\n        if error_message.startswith('Invalid \\\\escape'):\n            json_str = fix_invalid_escape(json_str, error_message)\n        if error_message.startswith('Expecting property name enclosed in double quotes'):\n            json_str = add_quotes_to_property_names(json_str)\n            try:\n                json.loads(json_str)\n                return json_str\n            except json.JSONDecodeError as e:\n                if cfg.debug:\n                    print('json loads error - add quotes', e)\n                error_message = str(e)\n        if balanced_str := balance_braces(json_str):\n            return balanced_str\n    return json_str", ""]}
{"filename": "scripts/chat.py", "chunked_list": ["import time\nfrom dotenv import load_dotenv\nfrom config import Config\nimport token_counter\nfrom llm_utils import create_chat_completion\n\ncfg = Config()\n\ndef create_chat_message(role, content):\n    \"\"\"\n    Create a chat message with the given role and content.\n\n    Args:\n    role (str): The role of the message sender, e.g., \"system\", \"user\", or \"assistant\".\n    content (str): The content of the message.\n\n    Returns:\n    dict: A dictionary containing the role and content of the message.\n    \"\"\"\n    return {\"role\": role, \"content\": content}", "def create_chat_message(role, content):\n    \"\"\"\n    Create a chat message with the given role and content.\n\n    Args:\n    role (str): The role of the message sender, e.g., \"system\", \"user\", or \"assistant\".\n    content (str): The content of the message.\n\n    Returns:\n    dict: A dictionary containing the role and content of the message.\n    \"\"\"\n    return {\"role\": role, \"content\": content}", "\n\ndef generate_context(prompt, relevant_memory, full_message_history, model):\n    current_context = [\n        create_chat_message(\n            \"system\", prompt),\n        create_chat_message(\n            \"system\", f\"The current time and date is {time.strftime('%c')}\"),\n        create_chat_message(\n            \"system\", f\"This reminds you of these events from your past:\\n{relevant_memory}\\n\\n\")]\n\n    # Add messages from the full message history until we reach the token limit\n    next_message_to_add_index = len(full_message_history) - 1\n    insertion_index = len(current_context)\n    # Count the currently used tokens\n    current_tokens_used = token_counter.count_message_tokens(current_context, model)\n    return next_message_to_add_index, current_tokens_used, insertion_index, current_context", "\n\n# TODO: Change debug from hardcode to argument\ndef chat_with_ai(\n        prompt,\n        user_input,\n        full_message_history,\n        permanent_memory,\n        token_limit):\n    \"\"\"Interact with the OpenAI API, sending the prompt, user input, message history, and permanent memory.\"\"\"\n    while True:\n        \"\"\"\n        Interact with the OpenAI API, sending the prompt, user input, message history, and permanent memory.\n\n        Args:\n        prompt (str): The prompt explaining the rules to the AI.\n        user_input (str): The input from the user.\n        full_message_history (list): The list of all messages sent between the user and the AI.\n        permanent_memory (Obj): The memory object containing the permanent memory.\n        token_limit (int): The maximum number of tokens allowed in the API call.\n\n        Returns:\n        str: The AI's response.\n        \"\"\"\n        model = cfg.fast_llm_model # TODO: Change model from hardcode to argument\n        # Reserve 1000 tokens for the response\n        \n        if cfg.debug:\n            print(f\"Token limit: {token_limit}\")\n            \n        send_token_limit = token_limit - 1000\n\n        relevant_memory = permanent_memory.get_relevant(str(full_message_history[-5:]), 10)\n\n        if cfg.debug:\n            print('Memory Stats: ', permanent_memory.get_stats())\n\n        next_message_to_add_index, current_tokens_used, insertion_index, current_context = generate_context(\n            prompt, relevant_memory, full_message_history, model)\n\n        while current_tokens_used > 2500:\n            # remove memories until we are under 2500 tokens\n            relevant_memory = relevant_memory[1:]\n            next_message_to_add_index, current_tokens_used, insertion_index, current_context = generate_context(\n                prompt, relevant_memory, full_message_history, model)\n\n        current_tokens_used += token_counter.count_message_tokens([create_chat_message(\"user\", user_input)], model) # Account for user input (appended later)\n\n        while next_message_to_add_index >= 0:\n            # print (f\"CURRENT TOKENS USED: {current_tokens_used}\")\n            message_to_add = full_message_history[next_message_to_add_index]\n\n            tokens_to_add = token_counter.count_message_tokens([message_to_add], model)\n            if current_tokens_used + tokens_to_add > send_token_limit:\n                break\n\n            # Add the most recent message to the start of the current context, after the two system prompts.\n            current_context.insert(insertion_index, full_message_history[next_message_to_add_index])\n\n            # Count the currently used tokens\n            current_tokens_used += tokens_to_add\n\n            # Move to the next most recent message in the full message history\n            next_message_to_add_index -= 1\n\n        # Append user input, the length of this is accounted for above\n        current_context.extend([create_chat_message(\"user\", user_input)])\n\n        # Calculate remaining tokens\n        tokens_remaining = token_limit - current_tokens_used\n        # assert tokens_remaining >= 0, \"Tokens remaining is negative. This should never happen, please submit a bug report at https://www.github.com/Torantulino/Auto-GPT\"\n\n        # Debug print the current context\n        if cfg.debug:\n            print(f\"Token limit: {token_limit}\")\n            print(f\"Send Token Count: {current_tokens_used}\")\n            print(f\"Tokens remaining for response: {tokens_remaining}\")\n            print(\"------------ CONTEXT SENT TO AI ---------------\")\n            for message in current_context:\n                # Skip printing the prompt\n                if message[\"role\"] == \"system\" and message[\"content\"] == prompt:\n                    continue\n                print(\n                    f\"{message['role'].capitalize()}: {message['content']}\")\n                print()\n            print(\"----------- END OF CONTEXT ----------------\")\n\n        # TODO: use a model defined elsewhere, so that model can contain temperature and other settings we care about\n        assistant_reply = create_chat_completion(\n            model=model,\n            messages=current_context,\n            max_tokens=tokens_remaining,\n        )\n\n        # Update full message history\n        full_message_history.append(\n            create_chat_message(\n                \"user\", user_input))\n        full_message_history.append(\n            create_chat_message(\n                \"assistant\", assistant_reply))\n\n        return assistant_reply"]}
{"filename": "scripts/speak.py", "chunked_list": ["import os\nfrom playsound import playsound\nimport requests\nfrom config import Config\ncfg = Config()\nimport gtts\n\n\n# TODO: Nicer names for these ids\nvoices = [\"ErXwobaYiN019PkySvjV\", \"EXAVITQu4vr4xnSDxMaL\"]", "# TODO: Nicer names for these ids\nvoices = [\"ErXwobaYiN019PkySvjV\", \"EXAVITQu4vr4xnSDxMaL\"]\n\ntts_headers = {\n    \"Content-Type\": \"application/json\",\n    \"xi-api-key\": cfg.elevenlabs_api_key\n}\n\ndef eleven_labs_speech(text, voice_index=0):\n    \"\"\"Speak text using elevenlabs.io's API\"\"\"\n    tts_url = \"https://api.elevenlabs.io/v1/text-to-speech/{voice_id}\".format(\n        voice_id=voices[voice_index])\n    formatted_message = {\"text\": text}\n    response = requests.post(\n        tts_url, headers=tts_headers, json=formatted_message)\n\n    if response.status_code == 200:\n        with open(\"speech.mpeg\", \"wb\") as f:\n            f.write(response.content)\n        playsound(\"speech.mpeg\")\n        os.remove(\"speech.mpeg\")\n        return True\n    else:\n        print(\"Request failed with status code:\", response.status_code)\n        print(\"Response content:\", response.content)\n        return False", "def eleven_labs_speech(text, voice_index=0):\n    \"\"\"Speak text using elevenlabs.io's API\"\"\"\n    tts_url = \"https://api.elevenlabs.io/v1/text-to-speech/{voice_id}\".format(\n        voice_id=voices[voice_index])\n    formatted_message = {\"text\": text}\n    response = requests.post(\n        tts_url, headers=tts_headers, json=formatted_message)\n\n    if response.status_code == 200:\n        with open(\"speech.mpeg\", \"wb\") as f:\n            f.write(response.content)\n        playsound(\"speech.mpeg\")\n        os.remove(\"speech.mpeg\")\n        return True\n    else:\n        print(\"Request failed with status code:\", response.status_code)\n        print(\"Response content:\", response.content)\n        return False", "\ndef gtts_speech(text):\n    tts = gtts.gTTS(text)\n    tts.save(\"speech.mp3\")\n    playsound(\"speech.mp3\")\n    os.remove(\"speech.mp3\")\n\ndef macos_tts_speech(text):\n    os.system(f'say \"{text}\"')\n\ndef say_text(text, voice_index=0):\n    if not cfg.elevenlabs_api_key:\n        if cfg.use_mac_os_tts == 'True':\n            macos_tts_speech(text)\n        else:\n            gtts_speech(text)\n    else:\n        success = eleven_labs_speech(text, voice_index)\n        if not success:\n            gtts_speech(text)", "\ndef say_text(text, voice_index=0):\n    if not cfg.elevenlabs_api_key:\n        if cfg.use_mac_os_tts == 'True':\n            macos_tts_speech(text)\n        else:\n            gtts_speech(text)\n    else:\n        success = eleven_labs_speech(text, voice_index)\n        if not success:\n            gtts_speech(text)", "\n"]}
{"filename": "scripts/llm_utils.py", "chunked_list": ["from config import Config\nfrom llama_cpp import Llama\n\ncfg = Config()\nllm = Llama(model_path=cfg.smart_llm_model, n_ctx=2048, embedding=True)\n\n\ndef create_chat_completion(messages, model=None, temperature=0.36, max_tokens=0)->str:\n    response = llm(messages[0][\"content\"], stop=[\"Q:\", \"### Human:\"], echo=False, temperature=temperature, max_tokens=max_tokens)\n    return response[\"choices\"][0][\"text\"]", ""]}
{"filename": "scripts/memory/base.py", "chunked_list": ["\"\"\"Base class for memory providers.\"\"\"\nimport abc\nfrom config import AbstractSingleton\nfrom llm_utils import llm\n\ndef get_ada_embedding(text):\n    text = text.replace(\"\\n\", \" \")\n    return llm.embed(text)\n\nclass MemoryProviderSingleton(AbstractSingleton):\n    @abc.abstractmethod\n    def add(self, data):\n        pass\n\n    @abc.abstractmethod\n    def get(self, data):\n        pass\n\n    @abc.abstractmethod\n    def clear(self):\n        pass\n\n    @abc.abstractmethod\n    def get_relevant(self, data, num_relevant=5):\n        pass\n\n    @abc.abstractmethod\n    def get_stats(self):\n        pass", "\nclass MemoryProviderSingleton(AbstractSingleton):\n    @abc.abstractmethod\n    def add(self, data):\n        pass\n\n    @abc.abstractmethod\n    def get(self, data):\n        pass\n\n    @abc.abstractmethod\n    def clear(self):\n        pass\n\n    @abc.abstractmethod\n    def get_relevant(self, data, num_relevant=5):\n        pass\n\n    @abc.abstractmethod\n    def get_stats(self):\n        pass", ""]}
{"filename": "scripts/memory/local.py", "chunked_list": ["import dataclasses\nimport orjson\nfrom typing import Any, List, Optional\nimport numpy as np\nimport os\nfrom memory.base import MemoryProviderSingleton, get_ada_embedding\n\n\nEMBED_DIM = 5120#1536\nSAVE_OPTIONS = orjson.OPT_SERIALIZE_NUMPY | orjson.OPT_SERIALIZE_DATACLASS", "EMBED_DIM = 5120#1536\nSAVE_OPTIONS = orjson.OPT_SERIALIZE_NUMPY | orjson.OPT_SERIALIZE_DATACLASS\n\n\ndef create_default_embeddings():\n    return np.zeros((0, EMBED_DIM)).astype(np.float32)\n\n\n@dataclasses.dataclass\nclass CacheContent:\n    texts: List[str] = dataclasses.field(default_factory=list)\n    embeddings: np.ndarray = dataclasses.field(\n        default_factory=create_default_embeddings\n    )", "@dataclasses.dataclass\nclass CacheContent:\n    texts: List[str] = dataclasses.field(default_factory=list)\n    embeddings: np.ndarray = dataclasses.field(\n        default_factory=create_default_embeddings\n    )\n\n\nclass LocalCache(MemoryProviderSingleton):\n\n    # on load, load our database\n    def __init__(self, cfg) -> None:\n        self.filename = f\"{cfg.memory_index}.json\"\n        if os.path.exists(self.filename):\n            with open(self.filename, 'rb') as f:\n                loaded = orjson.loads(f.read())\n                self.data = CacheContent(**loaded)\n        else:\n            self.data = CacheContent()\n\n    def add(self, text: str):\n        \"\"\"\n        Add text to our list of texts, add embedding as row to our\n            embeddings-matrix\n\n        Args:\n            text: str\n\n        Returns: None\n        \"\"\"\n        if 'Command Error:' in text:\n            return \"\"\n        self.data.texts.append(text)\n\n        embedding = get_ada_embedding(text)\n\n        vector = np.array(embedding).astype(np.float32)\n        vector = vector[np.newaxis, :]\n        self.data.embeddings = np.concatenate(\n            [\n                vector,\n                self.data.embeddings,\n            ],\n            axis=0,\n        )\n\n        with open(self.filename, 'wb') as f:\n            out = orjson.dumps(\n                self.data,\n                option=SAVE_OPTIONS\n            )\n            f.write(out)\n        return text\n\n    def clear(self) -> str:\n        \"\"\"\n        Clears the redis server.\n\n        Returns: A message indicating that the memory has been cleared.\n        \"\"\"\n        self.data = CacheContent()\n        return \"Obliviated\"\n\n    def get(self, data: str) -> Optional[List[Any]]:\n        \"\"\"\n        Gets the data from the memory that is most relevant to the given data.\n\n        Args:\n            data: The data to compare to.\n\n        Returns: The most relevant data.\n        \"\"\"\n        return self.get_relevant(data, 1)\n\n    def get_relevant(self, text: str, k: int) -> List[Any]:\n        \"\"\"\"\n        matrix-vector mult to find score-for-each-row-of-matrix\n         get indices for top-k winning scores\n         return texts for those indices\n        Args:\n            text: str\n            k: int\n\n        Returns: List[str]\n        \"\"\"\n        embedding = get_ada_embedding(text)\n\n        scores = np.dot(self.data.embeddings, embedding)\n\n        top_k_indices = np.argsort(scores)[-k:][::-1]\n\n        return [self.data.texts[i] for i in top_k_indices]\n\n    def get_stats(self):\n        \"\"\"\n        Returns: The stats of the local cache.\n        \"\"\"\n        return len(self.data.texts), self.data.embeddings.shape", "class LocalCache(MemoryProviderSingleton):\n\n    # on load, load our database\n    def __init__(self, cfg) -> None:\n        self.filename = f\"{cfg.memory_index}.json\"\n        if os.path.exists(self.filename):\n            with open(self.filename, 'rb') as f:\n                loaded = orjson.loads(f.read())\n                self.data = CacheContent(**loaded)\n        else:\n            self.data = CacheContent()\n\n    def add(self, text: str):\n        \"\"\"\n        Add text to our list of texts, add embedding as row to our\n            embeddings-matrix\n\n        Args:\n            text: str\n\n        Returns: None\n        \"\"\"\n        if 'Command Error:' in text:\n            return \"\"\n        self.data.texts.append(text)\n\n        embedding = get_ada_embedding(text)\n\n        vector = np.array(embedding).astype(np.float32)\n        vector = vector[np.newaxis, :]\n        self.data.embeddings = np.concatenate(\n            [\n                vector,\n                self.data.embeddings,\n            ],\n            axis=0,\n        )\n\n        with open(self.filename, 'wb') as f:\n            out = orjson.dumps(\n                self.data,\n                option=SAVE_OPTIONS\n            )\n            f.write(out)\n        return text\n\n    def clear(self) -> str:\n        \"\"\"\n        Clears the redis server.\n\n        Returns: A message indicating that the memory has been cleared.\n        \"\"\"\n        self.data = CacheContent()\n        return \"Obliviated\"\n\n    def get(self, data: str) -> Optional[List[Any]]:\n        \"\"\"\n        Gets the data from the memory that is most relevant to the given data.\n\n        Args:\n            data: The data to compare to.\n\n        Returns: The most relevant data.\n        \"\"\"\n        return self.get_relevant(data, 1)\n\n    def get_relevant(self, text: str, k: int) -> List[Any]:\n        \"\"\"\"\n        matrix-vector mult to find score-for-each-row-of-matrix\n         get indices for top-k winning scores\n         return texts for those indices\n        Args:\n            text: str\n            k: int\n\n        Returns: List[str]\n        \"\"\"\n        embedding = get_ada_embedding(text)\n\n        scores = np.dot(self.data.embeddings, embedding)\n\n        top_k_indices = np.argsort(scores)[-k:][::-1]\n\n        return [self.data.texts[i] for i in top_k_indices]\n\n    def get_stats(self):\n        \"\"\"\n        Returns: The stats of the local cache.\n        \"\"\"\n        return len(self.data.texts), self.data.embeddings.shape", ""]}
{"filename": "scripts/memory/__init__.py", "chunked_list": ["from memory.local import LocalCache\ntry:\n    from memory.redismem import RedisMemory\nexcept ImportError:\n    print(\"Redis not installed. Skipping import.\")\n    RedisMemory = None\n\ntry:\n    from memory.pinecone import PineconeMemory\nexcept ImportError:\n    print(\"Pinecone not installed. Skipping import.\")\n    PineconeMemory = None", "\n\ndef get_memory(cfg, init=False):\n    memory = None\n    if cfg.memory_backend == \"pinecone\":\n        if not PineconeMemory:\n            print(\"Error: Pinecone is not installed. Please install pinecone\"\n                  \" to use Pinecone as a memory backend.\")\n        else:\n            memory = PineconeMemory(cfg)\n            if init:\n                memory.clear()\n    elif cfg.memory_backend == \"redis\":\n        if not RedisMemory:\n            print(\"Error: Redis is not installed. Please install redis-py to\"\n                  \" use Redis as a memory backend.\")\n        else:\n            memory = RedisMemory(cfg)\n\n    if memory is None:\n        memory = LocalCache(cfg)\n        if init:\n            memory.clear()\n    return memory", "\n\n__all__ = [\n    \"get_memory\",\n    \"LocalCache\",\n    \"RedisMemory\",\n    \"PineconeMemory\",\n]\n", ""]}
{"filename": "scripts/memory/pinecone.py", "chunked_list": ["\nimport pinecone\n\nfrom memory.base import MemoryProviderSingleton, get_ada_embedding\n\n\nclass PineconeMemory(MemoryProviderSingleton):\n    def __init__(self, cfg):\n        pinecone_api_key = cfg.pinecone_api_key\n        pinecone_region = cfg.pinecone_region\n        pinecone.init(api_key=pinecone_api_key, environment=pinecone_region)\n        dimension = 1536\n        metric = \"cosine\"\n        pod_type = \"p1\"\n        table_name = \"auto-gpt\"\n        # this assumes we don't start with memory.\n        # for now this works.\n        # we'll need a more complicated and robust system if we want to start with memory.\n        self.vec_num = 0\n        if table_name not in pinecone.list_indexes():\n            pinecone.create_index(table_name, dimension=dimension, metric=metric, pod_type=pod_type)\n        self.index = pinecone.Index(table_name)\n\n    def add(self, data):\n        vector = get_ada_embedding(data)\n        # no metadata here. We may wish to change that long term.\n        resp = self.index.upsert([(str(self.vec_num), vector, {\"raw_text\": data})])\n        _text = f\"Inserting data into memory at index: {self.vec_num}:\\n data: {data}\"\n        self.vec_num += 1\n        return _text\n\n    def get(self, data):\n        return self.get_relevant(data, 1)\n\n    def clear(self):\n        self.index.delete(deleteAll=True)\n        return \"Obliviated\"\n\n    def get_relevant(self, data, num_relevant=5):\n        \"\"\"\n        Returns all the data in the memory that is relevant to the given data.\n        :param data: The data to compare to.\n        :param num_relevant: The number of relevant data to return. Defaults to 5\n        \"\"\"\n        query_embedding = get_ada_embedding(data)\n        results = self.index.query(query_embedding, top_k=num_relevant, include_metadata=True)\n        sorted_results = sorted(results.matches, key=lambda x: x.score)\n        return [str(item['metadata'][\"raw_text\"]) for item in sorted_results]\n\n    def get_stats(self):\n        return self.index.describe_index_stats()", ""]}
{"filename": "scripts/memory/redismem.py", "chunked_list": ["\"\"\"Redis memory provider.\"\"\"\nfrom typing import Any, List, Optional\nimport redis\nfrom redis.commands.search.field import VectorField, TextField\nfrom redis.commands.search.query import Query\nfrom redis.commands.search.indexDefinition import IndexDefinition, IndexType\nimport numpy as np\n\nfrom memory.base import MemoryProviderSingleton, get_ada_embedding\n", "from memory.base import MemoryProviderSingleton, get_ada_embedding\n\n\nSCHEMA = [\n    TextField(\"data\"),\n    VectorField(\n        \"embedding\",\n        \"HNSW\",\n        {\n            \"TYPE\": \"FLOAT32\",", "        {\n            \"TYPE\": \"FLOAT32\",\n            \"DIM\": 1536,\n            \"DISTANCE_METRIC\": \"COSINE\"\n        }\n    ),\n]\n\n\nclass RedisMemory(MemoryProviderSingleton):\n    def __init__(self, cfg):\n        \"\"\"\n        Initializes the Redis memory provider.\n\n        Args:\n            cfg: The config object.\n\n        Returns: None\n        \"\"\"\n        redis_host = cfg.redis_host\n        redis_port = cfg.redis_port\n        redis_password = cfg.redis_password\n        self.dimension = 1536\n        self.redis = redis.Redis(\n            host=redis_host,\n            port=redis_port,\n            password=redis_password,\n            db=0  # Cannot be changed\n        )\n        self.cfg = cfg\n        if cfg.wipe_redis_on_start:\n            self.redis.flushall()\n        try:\n            self.redis.ft(f\"{cfg.memory_index}\").create_index(\n                fields=SCHEMA,\n                definition=IndexDefinition(\n                    prefix=[f\"{cfg.memory_index}:\"],\n                    index_type=IndexType.HASH\n                    )\n                )\n        except Exception as e:\n            print(\"Error creating Redis search index: \", e)\n        existing_vec_num = self.redis.get(f'{cfg.memory_index}-vec_num')\n        self.vec_num = int(existing_vec_num.decode('utf-8')) if\\\n            existing_vec_num else 0\n\n    def add(self, data: str) -> str:\n        \"\"\"\n        Adds a data point to the memory.\n\n        Args:\n            data: The data to add.\n\n        Returns: Message indicating that the data has been added.\n        \"\"\"\n        if 'Command Error:' in data:\n            return \"\"\n        vector = get_ada_embedding(data)\n        vector = np.array(vector).astype(np.float32).tobytes()\n        data_dict = {\n            b\"data\": data,\n            \"embedding\": vector\n        }\n        pipe = self.redis.pipeline()\n        pipe.hset(f\"{self.cfg.memory_index}:{self.vec_num}\", mapping=data_dict)\n        _text = f\"Inserting data into memory at index: {self.vec_num}:\\n\"\\\n            f\"data: {data}\"\n        self.vec_num += 1\n        pipe.set(f'{self.cfg.memory_index}-vec_num', self.vec_num)\n        pipe.execute()\n        return _text\n\n    def get(self, data: str) -> Optional[List[Any]]:\n        \"\"\"\n        Gets the data from the memory that is most relevant to the given data.\n\n        Args:\n            data: The data to compare to.\n\n        Returns: The most relevant data.\n        \"\"\"\n        return self.get_relevant(data, 1)\n\n    def clear(self) -> str:\n        \"\"\"\n        Clears the redis server.\n\n        Returns: A message indicating that the memory has been cleared.\n        \"\"\"\n        self.redis.flushall()\n        return \"Obliviated\"\n\n    def get_relevant(\n        self,\n        data: str,\n        num_relevant: int = 5\n    ) -> Optional[List[Any]]:\n        \"\"\"\n        Returns all the data in the memory that is relevant to the given data.\n        Args:\n            data: The data to compare to.\n            num_relevant: The number of relevant data to return.\n\n        Returns: A list of the most relevant data.\n        \"\"\"\n        query_embedding = get_ada_embedding(data)\n        base_query = f\"*=>[KNN {num_relevant} @embedding $vector AS vector_score]\"\n        query = Query(base_query).return_fields(\n            \"data\",\n            \"vector_score\"\n        ).sort_by(\"vector_score\").dialect(2)\n        query_vector = np.array(query_embedding).astype(np.float32).tobytes()\n\n        try:\n            results = self.redis.ft(f\"{self.cfg.memory_index}\").search(\n                query, query_params={\"vector\": query_vector}\n            )\n        except Exception as e:\n            print(\"Error calling Redis search: \", e)\n            return None\n        return [result.data for result in results.docs]\n\n    def get_stats(self):\n        \"\"\"\n        Returns: The stats of the memory index.\n        \"\"\"\n        return self.redis.ft(f\"{self.cfg.memory_index}\").info()", "\nclass RedisMemory(MemoryProviderSingleton):\n    def __init__(self, cfg):\n        \"\"\"\n        Initializes the Redis memory provider.\n\n        Args:\n            cfg: The config object.\n\n        Returns: None\n        \"\"\"\n        redis_host = cfg.redis_host\n        redis_port = cfg.redis_port\n        redis_password = cfg.redis_password\n        self.dimension = 1536\n        self.redis = redis.Redis(\n            host=redis_host,\n            port=redis_port,\n            password=redis_password,\n            db=0  # Cannot be changed\n        )\n        self.cfg = cfg\n        if cfg.wipe_redis_on_start:\n            self.redis.flushall()\n        try:\n            self.redis.ft(f\"{cfg.memory_index}\").create_index(\n                fields=SCHEMA,\n                definition=IndexDefinition(\n                    prefix=[f\"{cfg.memory_index}:\"],\n                    index_type=IndexType.HASH\n                    )\n                )\n        except Exception as e:\n            print(\"Error creating Redis search index: \", e)\n        existing_vec_num = self.redis.get(f'{cfg.memory_index}-vec_num')\n        self.vec_num = int(existing_vec_num.decode('utf-8')) if\\\n            existing_vec_num else 0\n\n    def add(self, data: str) -> str:\n        \"\"\"\n        Adds a data point to the memory.\n\n        Args:\n            data: The data to add.\n\n        Returns: Message indicating that the data has been added.\n        \"\"\"\n        if 'Command Error:' in data:\n            return \"\"\n        vector = get_ada_embedding(data)\n        vector = np.array(vector).astype(np.float32).tobytes()\n        data_dict = {\n            b\"data\": data,\n            \"embedding\": vector\n        }\n        pipe = self.redis.pipeline()\n        pipe.hset(f\"{self.cfg.memory_index}:{self.vec_num}\", mapping=data_dict)\n        _text = f\"Inserting data into memory at index: {self.vec_num}:\\n\"\\\n            f\"data: {data}\"\n        self.vec_num += 1\n        pipe.set(f'{self.cfg.memory_index}-vec_num', self.vec_num)\n        pipe.execute()\n        return _text\n\n    def get(self, data: str) -> Optional[List[Any]]:\n        \"\"\"\n        Gets the data from the memory that is most relevant to the given data.\n\n        Args:\n            data: The data to compare to.\n\n        Returns: The most relevant data.\n        \"\"\"\n        return self.get_relevant(data, 1)\n\n    def clear(self) -> str:\n        \"\"\"\n        Clears the redis server.\n\n        Returns: A message indicating that the memory has been cleared.\n        \"\"\"\n        self.redis.flushall()\n        return \"Obliviated\"\n\n    def get_relevant(\n        self,\n        data: str,\n        num_relevant: int = 5\n    ) -> Optional[List[Any]]:\n        \"\"\"\n        Returns all the data in the memory that is relevant to the given data.\n        Args:\n            data: The data to compare to.\n            num_relevant: The number of relevant data to return.\n\n        Returns: A list of the most relevant data.\n        \"\"\"\n        query_embedding = get_ada_embedding(data)\n        base_query = f\"*=>[KNN {num_relevant} @embedding $vector AS vector_score]\"\n        query = Query(base_query).return_fields(\n            \"data\",\n            \"vector_score\"\n        ).sort_by(\"vector_score\").dialect(2)\n        query_vector = np.array(query_embedding).astype(np.float32).tobytes()\n\n        try:\n            results = self.redis.ft(f\"{self.cfg.memory_index}\").search(\n                query, query_params={\"vector\": query_vector}\n            )\n        except Exception as e:\n            print(\"Error calling Redis search: \", e)\n            return None\n        return [result.data for result in results.docs]\n\n    def get_stats(self):\n        \"\"\"\n        Returns: The stats of the memory index.\n        \"\"\"\n        return self.redis.ft(f\"{self.cfg.memory_index}\").info()", ""]}
{"filename": "tests/test_browse_scrape_text.py", "chunked_list": ["\n# Generated by CodiumAI\n\nimport requests\nimport pytest\n\nfrom scripts.browse import scrape_text\n\n\"\"\"\nCode Analysis", "\"\"\"\nCode Analysis\n\nObjective:\nThe objective of the \"scrape_text\" function is to scrape the text content from a given URL and return it as a string, after removing any unwanted HTML tags and scripts.\n\nInputs:\n- url: a string representing the URL of the webpage to be scraped.\n\nFlow:", "\nFlow:\n1. Send a GET request to the given URL using the requests library and the user agent header from the config file.\n2. Check if the response contains an HTTP error. If it does, return an error message.\n3. Use BeautifulSoup to parse the HTML content of the response and extract all script and style tags.\n4. Get the text content of the remaining HTML using the get_text() method of BeautifulSoup.\n5. Split the text into lines and then into chunks, removing any extra whitespace.\n6. Join the chunks into a single string with newline characters between them.\n7. Return the cleaned text.\n", "7. Return the cleaned text.\n\nOutputs:\n- A string representing the cleaned text content of the webpage.\n\nAdditional aspects:\n- The function uses the requests library and BeautifulSoup to handle the HTTP request and HTML parsing, respectively.\n- The function removes script and style tags from the HTML to avoid including unwanted content in the text output.\n- The function uses a generator expression to split the text into lines and chunks, which can improve performance for large amounts of text.\n\"\"\"", "- The function uses a generator expression to split the text into lines and chunks, which can improve performance for large amounts of text.\n\"\"\"\n\n\n\nclass TestScrapeText:\n\n    # Tests that scrape_text() returns the expected text when given a valid URL.\n    def test_scrape_text_with_valid_url(self, mocker):\n        # Mock the requests.get() method to return a response with expected text\n        expected_text = \"This is some sample text\"\n        mock_response = mocker.Mock()\n        mock_response.status_code = 200\n        mock_response.text = f\"<html><body><div><p style='color: blue;'>{expected_text}</p></div></body></html>\"\n        mocker.patch(\"requests.get\", return_value=mock_response)\n\n        # Call the function with a valid URL and assert that it returns the expected text\n        url = \"http://www.example.com\"\n        assert scrape_text(url) == expected_text\n\n    # Tests that the function returns an error message when an invalid or unreachable url is provided.\n    def test_invalid_url(self, mocker):\n        # Mock the requests.get() method to raise an exception\n        mocker.patch(\"requests.get\", side_effect=requests.exceptions.RequestException)\n\n        # Call the function with an invalid URL and assert that it returns an error message\n        url = \"http://www.invalidurl.com\"\n        error_message = scrape_text(url)\n        assert \"Error:\" in error_message\n\n    # Tests that the function returns an empty string when the html page contains no text to be scraped.\n    def test_no_text(self, mocker):\n        # Mock the requests.get() method to return a response with no text\n        mock_response = mocker.Mock()\n        mock_response.status_code = 200\n        mock_response.text = \"<html><body></body></html>\"\n        mocker.patch(\"requests.get\", return_value=mock_response)\n\n        # Call the function with a valid URL and assert that it returns an empty string\n        url = \"http://www.example.com\"\n        assert scrape_text(url) == \"\"\n\n    # Tests that the function returns an error message when the response status code is an http error (>=400).\n    def test_http_error(self, mocker):\n        # Mock the requests.get() method to return a response with a 404 status code\n        mocker.patch('requests.get', return_value=mocker.Mock(status_code=404))\n\n        # Call the function with a URL\n        result = scrape_text(\"https://www.example.com\")\n\n        # Check that the function returns an error message\n        assert result == \"Error: HTTP 404 error\"\n\n    # Tests that scrape_text() properly handles HTML tags.\n    def test_scrape_text_with_html_tags(self, mocker):\n        # Create a mock response object with HTML containing tags\n        html = \"<html><body><p>This is <b>bold</b> text.</p></body></html>\"\n        mock_response = mocker.Mock()\n        mock_response.status_code = 200\n        mock_response.text = html\n        mocker.patch(\"requests.get\", return_value=mock_response)\n\n        # Call the function with a URL\n        result = scrape_text(\"https://www.example.com\")\n\n        # Check that the function properly handles HTML tags\n        assert result == \"This is bold text.\"", ""]}
{"filename": "tests/json_tests.py", "chunked_list": ["import unittest\nimport os\nimport sys\n# Probably a better way:\nsys.path.append(os.path.abspath('../scripts'))\nfrom json_parser import fix_and_parse_json\n\nclass TestParseJson(unittest.TestCase):\n    def test_valid_json(self):\n        # Test that a valid JSON string is parsed correctly\n        json_str = '{\"name\": \"John\", \"age\": 30, \"city\": \"New York\"}'\n        obj = fix_and_parse_json(json_str)\n        self.assertEqual(obj, {\"name\": \"John\", \"age\": 30, \"city\": \"New York\"})\n\n    def test_invalid_json_minor(self):\n        # Test that an invalid JSON string can be fixed with gpt\n        json_str = '{\"name\": \"John\", \"age\": 30, \"city\": \"New York\",}'\n        self.assertEqual(fix_and_parse_json(json_str, try_to_fix_with_gpt=False), {\"name\": \"John\", \"age\": 30, \"city\": \"New York\"})\n\n    def test_invalid_json_major_with_gpt(self):\n        # Test that an invalid JSON string raises an error when try_to_fix_with_gpt is False\n        json_str = 'BEGIN: \"name\": \"John\" - \"age\": 30 - \"city\": \"New York\" :END'\n        self.assertEqual(fix_and_parse_json(json_str, try_to_fix_with_gpt=True), {\"name\": \"John\", \"age\": 30, \"city\": \"New York\"})\n\n    def test_invalid_json_major_without_gpt(self):\n        # Test that a REALLY invalid JSON string raises an error when try_to_fix_with_gpt is False\n        json_str = 'BEGIN: \"name\": \"John\" - \"age\": 30 - \"city\": \"New York\" :END'\n        # Assert that this raises an exception:\n        with self.assertRaises(Exception):\n            fix_and_parse_json(json_str, try_to_fix_with_gpt=False)\n\n    def test_invalid_json_leading_sentence_with_gpt(self):\n        # Test that a REALLY invalid JSON string raises an error when try_to_fix_with_gpt is False\n        json_str = \"\"\"I suggest we start by browsing the repository to find any issues that we can fix.\n\n{\n    \"command\": {\n        \"name\": \"browse_website\",\n        \"args\":{\n            \"url\": \"https://github.com/Torantulino/Auto-GPT\"\n        }\n    },\n    \"thoughts\":\n    {\n        \"text\": \"I suggest we start browsing the repository to find any issues that we can fix.\",\n        \"reasoning\": \"Browsing the repository will give us an idea of the current state of the codebase and identify any issues that we can address to improve the repo.\",\n        \"plan\": \"- Look through the repository to find any issues.\\n- Investigate any issues to determine what needs to be fixed\\n- Identify possible solutions to fix the issues\\n- Open Pull Requests with fixes\",\n        \"criticism\": \"I should be careful while browsing so as not to accidentally introduce any new bugs or issues.\",\n        \"speak\": \"I will start browsing the repository to find any issues we can fix.\"\n    }\n}\"\"\"\n        good_obj = {\n          \"command\": {\n              \"name\": \"browse_website\",\n              \"args\":{\n                  \"url\": \"https://github.com/Torantulino/Auto-GPT\"\n              }\n          },\n          \"thoughts\":\n          {\n              \"text\": \"I suggest we start browsing the repository to find any issues that we can fix.\",\n              \"reasoning\": \"Browsing the repository will give us an idea of the current state of the codebase and identify any issues that we can address to improve the repo.\",\n              \"plan\": \"- Look through the repository to find any issues.\\n- Investigate any issues to determine what needs to be fixed\\n- Identify possible solutions to fix the issues\\n- Open Pull Requests with fixes\",\n              \"criticism\": \"I should be careful while browsing so as not to accidentally introduce any new bugs or issues.\",\n              \"speak\": \"I will start browsing the repository to find any issues we can fix.\"\n          }\n      }\n        # Assert that this raises an exception:\n        self.assertEqual(fix_and_parse_json(json_str, try_to_fix_with_gpt=False), good_obj)\n\n\n\n    def test_invalid_json_leading_sentence_with_gpt(self):\n        # Test that a REALLY invalid JSON string raises an error when try_to_fix_with_gpt is False\n        json_str = \"\"\"I will first need to browse the repository (https://github.com/Torantulino/Auto-GPT) and identify any potential bugs that need fixing. I will use the \"browse_website\" command for this.\n\n{\n    \"command\": {\n        \"name\": \"browse_website\",\n        \"args\":{\n            \"url\": \"https://github.com/Torantulino/Auto-GPT\"\n        }\n    },\n    \"thoughts\":\n    {\n        \"text\": \"Browsing the repository to identify potential bugs\",\n        \"reasoning\": \"Before fixing bugs, I need to identify what needs fixing. I will use the 'browse_website' command to analyze the repository.\",\n        \"plan\": \"- Analyze the repository for potential bugs and areas of improvement\",\n        \"criticism\": \"I need to ensure I am thorough and pay attention to detail while browsing the repository.\",\n        \"speak\": \"I am browsing the repository to identify potential bugs.\"\n    }\n}\"\"\"\n        good_obj = {\n    \"command\": {\n        \"name\": \"browse_website\",\n        \"args\":{\n            \"url\": \"https://github.com/Torantulino/Auto-GPT\"\n        }\n    },\n    \"thoughts\":\n    {\n        \"text\": \"Browsing the repository to identify potential bugs\",\n        \"reasoning\": \"Before fixing bugs, I need to identify what needs fixing. I will use the 'browse_website' command to analyze the repository.\",\n        \"plan\": \"- Analyze the repository for potential bugs and areas of improvement\",\n        \"criticism\": \"I need to ensure I am thorough and pay attention to detail while browsing the repository.\",\n        \"speak\": \"I am browsing the repository to identify potential bugs.\"\n    }\n}\n        # Assert that this raises an exception:\n        self.assertEqual(fix_and_parse_json(json_str, try_to_fix_with_gpt=False), good_obj)", "\n\n\nif __name__ == '__main__':\n    unittest.main()\n"]}
