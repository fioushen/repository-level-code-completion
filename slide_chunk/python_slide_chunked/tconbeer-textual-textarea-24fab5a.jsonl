{"filename": "tests/conftest.py", "chunked_list": ["from pathlib import Path\n\nimport pytest\n\n\n@pytest.fixture\ndef data_dir() -> Path:\n    here = Path(__file__)\n    return here.parent / \"data\"\n", ""]}
{"filename": "tests/functional_tests/test_comments.py", "chunked_list": ["import pytest\nfrom textual.app import App\nfrom textual_textarea import TextArea\nfrom textual_textarea.key_handlers import Cursor\n\n\n@pytest.mark.parametrize(\n    \"language,expected_marker\",\n    [\n        (\"python\", \"# \"),", "    [\n        (\"python\", \"# \"),\n        (\"sql\", \"-- \"),\n        (\"mysql\", \"# \"),\n        (\"c\", \"// \"),\n    ],\n)\n@pytest.mark.asyncio\nasync def test_comments(app: App, language: str, expected_marker: str) -> None:\n    async with app.run_test() as pilot:", "async def test_comments(app: App, language: str, expected_marker: str) -> None:\n    async with app.run_test() as pilot:\n        ta = app.query_one(TextArea)\n        ta.language = language\n        original_text = \"foo bar baz\"\n        ta.text = original_text\n        ta.cursor = Cursor(0, 0)\n\n        await pilot.press(\"ctrl+underscore\")  # alias for ctrl+/\n        assert ta.text == f\"{expected_marker}{original_text}\"", "        await pilot.press(\"ctrl+underscore\")  # alias for ctrl+/\n        assert ta.text == f\"{expected_marker}{original_text}\"\n"]}
{"filename": "tests/functional_tests/test_textarea.py", "chunked_list": ["from typing import List, Union\n\nimport pytest\nfrom textual.app import App\nfrom textual_textarea import TextArea\nfrom textual_textarea.key_handlers import Cursor\n\n\n@pytest.mark.parametrize(\n    \"keys,lines,anchor,cursor,expected_lines,expected_anchor,expected_cursor\",", "@pytest.mark.parametrize(\n    \"keys,lines,anchor,cursor,expected_lines,expected_anchor,expected_cursor\",\n    [\n        (\n            [\"ctrl+a\"],\n            [\"select \", \" foo \"],\n            None,\n            Cursor(1, 2),\n            None,\n            Cursor(0, 0),", "            None,\n            Cursor(0, 0),\n            Cursor(1, 4),\n        ),\n        (\n            [\"ctrl+shift+right\"],\n            [\"select \", \" foo \"],\n            None,\n            Cursor(0, 0),\n            None,", "            Cursor(0, 0),\n            None,\n            Cursor(0, 0),\n            Cursor(0, 6),\n        ),\n        (\n            [\"right\"],\n            [\"select \", \" foo \"],\n            Cursor(0, 0),\n            Cursor(0, 6),", "            Cursor(0, 0),\n            Cursor(0, 6),\n            None,\n            None,\n            Cursor(1, 0),\n        ),\n        (\n            [\"a\"],\n            [\"select \", \" foo \"],\n            None,", "            [\"select \", \" foo \"],\n            None,\n            Cursor(1, 4),\n            [\"select \", \" fooa \"],\n            None,\n            Cursor(1, 5),\n        ),\n        (\n            [\"a\"],\n            [\"select \", \" foo \"],", "            [\"a\"],\n            [\"select \", \" foo \"],\n            Cursor(1, 0),\n            Cursor(1, 4),\n            [\"select \", \"a \"],\n            None,\n            Cursor(1, 1),\n        ),\n        (\n            [\"enter\"],", "        (\n            [\"enter\"],\n            [\"a \", \"a \"],\n            None,\n            Cursor(1, 0),\n            [\"a \", \" \", \"a \"],\n            None,\n            Cursor(2, 0),\n        ),\n        (", "        ),\n        (\n            [\"enter\"],\n            [\"a \", \"a \"],\n            None,\n            Cursor(1, 1),\n            [\"a \", \"a \", \" \"],\n            None,\n            Cursor(2, 0),\n        ),", "            Cursor(2, 0),\n        ),\n        (\n            [\"enter\"],\n            [\"a() \"],\n            None,\n            Cursor(0, 2),\n            [\"a( \", \"     \", \") \"],\n            None,\n            Cursor(1, 4),", "            None,\n            Cursor(1, 4),\n        ),\n        (\n            [\"enter\"],\n            [\" a() \"],\n            None,\n            Cursor(0, 3),\n            [\" a( \", \"     \", \" ) \"],\n            None,", "            [\" a( \", \"     \", \" ) \"],\n            None,\n            Cursor(1, 4),\n        ),\n    ],\n)\n@pytest.mark.asyncio\nasync def test_keys(\n    app: App,\n    keys: List[str],", "    app: App,\n    keys: List[str],\n    lines: List[str],\n    anchor: Union[Cursor, None],\n    cursor: Cursor,\n    expected_lines: Union[List[str], None],\n    expected_anchor: Union[Cursor, None],\n    expected_cursor: Cursor,\n) -> None:\n    if expected_lines is None:\n        expected_lines = lines", ") -> None:\n    if expected_lines is None:\n        expected_lines = lines\n\n    async with app.run_test() as pilot:\n        widget = app.query_one(TextArea)\n        input = widget.text_input\n        input.lines = lines.copy()\n        input.selection_anchor = anchor\n        input.cursor = cursor", "        input.selection_anchor = anchor\n        input.cursor = cursor\n\n        for key in keys:\n            await pilot.press(key)\n\n        assert input.lines == expected_lines\n        assert input.selection_anchor == expected_anchor\n        assert input.cursor == expected_cursor\n", "        assert input.cursor == expected_cursor\n\n\n@pytest.mark.asyncio\nasync def test_move_cursor(app: App) -> None:\n    async with app.run_test():\n        ta = app.query_one(TextArea)\n        ti = ta.text_input\n        ti.lines = [f\"{'X' * i} \" for i in range(10)]\n", "        ti.lines = [f\"{'X' * i} \" for i in range(10)]\n\n        assert ta.cursor == Cursor(0, 0)\n        for i in range(10):\n            ti.move_cursor(100, i)\n            assert ta.cursor == Cursor(i, i)\n            ti.move_cursor(0, i)\n            assert ta.cursor == Cursor(i, 0)\n\n        ti.move_cursor(-100, -100)", "\n        ti.move_cursor(-100, -100)\n        assert ta.cursor == Cursor(0, 0)\n\n        ti.move_cursor(-10, 5)\n        assert ta.cursor == Cursor(5, 0)\n\n        ti.move_cursor(5, -5)\n        assert ta.cursor == Cursor(0, 0)\n", "        assert ta.cursor == Cursor(0, 0)\n\n\n@pytest.mark.parametrize(\n    \"starting_anchor,starting_cursor,expected_clipboard\",\n    [\n        (Cursor(0, 5), Cursor(1, 5), [\"56789 \", \"01234\"]),\n        (Cursor(0, 0), Cursor(1, 0), [\"0123456789 \", \"\"]),\n    ],\n)", "    ],\n)\n@pytest.mark.asyncio\nasync def test_copy_paste(\n    app_all_clipboards: App,\n    starting_anchor: Cursor,\n    starting_cursor: Cursor,\n    expected_clipboard: List[str],\n) -> None:\n    original_text = \"0123456789\\n0123456789\\n0123456789\"", ") -> None:\n    original_text = \"0123456789\\n0123456789\\n0123456789\"\n\n    async with app_all_clipboards.run_test() as pilot:\n        ta = app_all_clipboards.query_one(TextArea)\n        ti = ta.text_input\n        ta.text = original_text\n        ti.selection_anchor = starting_anchor\n        ti.cursor = starting_cursor\n", "        ti.cursor = starting_cursor\n\n        await pilot.press(\"ctrl+c\")\n        assert ti.clipboard == expected_clipboard\n        assert ti.selection_anchor == starting_anchor\n        assert ti.cursor == starting_cursor\n        assert ta.text == original_text\n\n        await pilot.press(\"ctrl+u\")\n        assert ti.clipboard == expected_clipboard", "        await pilot.press(\"ctrl+u\")\n        assert ti.clipboard == expected_clipboard\n        assert ti.selection_anchor is None\n        assert ti.cursor == starting_cursor\n        assert ta.text == original_text\n\n        await pilot.press(\"ctrl+a\")\n        assert ti.selection_anchor == Cursor(0, 0)\n        assert ti.cursor == Cursor(\n            len(original_text.splitlines()) - 1, len(original_text.splitlines()[-1])", "        assert ti.cursor == Cursor(\n            len(original_text.splitlines()) - 1, len(original_text.splitlines()[-1])\n        )\n        assert ti.clipboard == expected_clipboard\n        assert ta.text == original_text\n\n        await pilot.press(\"ctrl+u\")\n        assert ti.selection_anchor is None\n        assert ti.cursor == Cursor(\n            len(expected_clipboard) - 1, len(expected_clipboard[-1])", "        assert ti.cursor == Cursor(\n            len(expected_clipboard) - 1, len(expected_clipboard[-1])\n        )\n        assert ti.clipboard == expected_clipboard\n        assert ta.text == \"\\n\".join([line.strip() for line in expected_clipboard])\n\n        await pilot.press(\"ctrl+a\")\n        await pilot.press(\"ctrl+x\")\n        assert ti.selection_anchor is None\n        assert ti.cursor == Cursor(0, 0)", "        assert ti.selection_anchor is None\n        assert ti.cursor == Cursor(0, 0)\n        assert ti.clipboard == expected_clipboard\n        assert ta.text == \"\"\n\n        await pilot.press(\"ctrl+v\")\n        assert ti.selection_anchor is None\n        assert ti.cursor == Cursor(\n            len(expected_clipboard) - 1, len(expected_clipboard[-1])\n        )", "            len(expected_clipboard) - 1, len(expected_clipboard[-1])\n        )\n        assert ti.clipboard == expected_clipboard\n        assert ta.text == \"\\n\".join([line.rstrip() for line in expected_clipboard])\n\n\n@pytest.mark.asyncio\nasync def test_text_property(app: App) -> None:\n    async with app.run_test():\n        ta = app.query_one(TextArea)", "    async with app.run_test():\n        ta = app.query_one(TextArea)\n        assert ta.text == \"\"\n        assert ta.selected_text == \"\"\n\n        ta.text = \"select\\nfoo\"\n        assert ta.text_input.lines == [\"select \", \"foo \"]\n        assert ta.selection_anchor is None\n        assert ta.selected_text == \"\"\n", "        assert ta.selected_text == \"\"\n\n        # this input should be validated and cursor moved\n        # to EOF\n        ta.cursor = Cursor(100, 100)\n        assert ta.cursor == Cursor(1, 3)\n        assert ta.selection_anchor is None\n        assert ta.selected_text == \"\"\n\n        ta.selection_anchor = Cursor(0, 0)", "\n        ta.selection_anchor = Cursor(0, 0)\n        assert ta.selection_anchor == Cursor(0, 0)\n        assert ta.selected_text == ta.text\n\n        ta.selection_anchor = Cursor(0, 1)\n        ta.cursor = Cursor(1, 1)\n        assert ta.selected_text == \"elect\\nf\"\n\n        ta.text_input.lines = [\"a \", \" \", \"b \", \"c \"]", "\n        ta.text_input.lines = [\"a \", \" \", \"b \", \"c \"]\n        assert ta.text == \"a\\n\\nb\\nc\"\n        ta.cursor = Cursor(3, 0)\n        assert ta.selection_anchor == Cursor(0, 1)\n        assert ta.selected_text == \"\\n\\nb\\n\"\n"]}
{"filename": "tests/functional_tests/__init__.py", "chunked_list": [""]}
{"filename": "tests/functional_tests/test_open.py", "chunked_list": ["from pathlib import Path\n\nimport pytest\nfrom textual.app import App\nfrom textual.widgets import Input\nfrom textual_textarea import TextArea\n\n\n@pytest.mark.parametrize(\"filename\", [\"foo.py\", \"empty.py\"])\n@pytest.mark.asyncio", "@pytest.mark.parametrize(\"filename\", [\"foo.py\", \"empty.py\"])\n@pytest.mark.asyncio\nasync def test_open(data_dir: Path, app: App, filename: str) -> None:\n    p = data_dir / \"test_open\" / filename\n    with open(p, \"r\") as f:\n        contents = f.read()\n\n    async with app.run_test() as pilot:\n        ta = app.query_one(TextArea)\n        assert ta.text == \"\"", "        ta = app.query_one(TextArea)\n        assert ta.text == \"\"\n        starting_text = \"123\"\n        for key in starting_text:\n            await pilot.press(key)\n        assert ta.text == starting_text\n\n        await pilot.press(\"ctrl+o\")\n        open_input = ta.query_one(Input)\n        assert open_input.id and \"open\" in open_input.id", "        open_input = ta.query_one(Input)\n        assert open_input.id and \"open\" in open_input.id\n        assert open_input.has_focus\n\n        for key in str(p):\n            await pilot.press(key)\n        await pilot.press(\"enter\")\n\n        assert ta.text == contents\n        assert ta.text_input.has_focus", "        assert ta.text == contents\n        assert ta.text_input.has_focus\n\n        # make sure the end of the buffer is formatted properly.\n        # these previously caused a crash.\n        await pilot.press(\"ctrl+end\")\n        assert ta.cursor.pos >= 0\n        await pilot.press(\"enter\")\n", ""]}
{"filename": "tests/functional_tests/conftest.py", "chunked_list": ["from typing import Type, Union\n\nimport pytest\nfrom textual.app import App, ComposeResult, CSSPathType\nfrom textual.driver import Driver\nfrom textual_textarea.textarea import TextArea\n\n\nclass TextAreaApp(App, inherit_bindings=False):\n    def __init__(\n        self,\n        driver_class: Union[Type[Driver], None] = None,\n        css_path: Union[CSSPathType, None] = None,\n        watch_css: bool = False,\n        language: Union[str, None] = None,\n        use_system_clipboard: bool = True,\n    ):\n        self.language = language\n        self.use_system_clipboard = use_system_clipboard\n        super().__init__(driver_class, css_path, watch_css)\n\n    def compose(self) -> ComposeResult:\n        yield TextArea(\n            language=self.language, use_system_clipboard=self.use_system_clipboard\n        )\n\n    def on_mount(self) -> None:\n        ta = self.query_one(TextArea)\n        ta.focus()", "class TextAreaApp(App, inherit_bindings=False):\n    def __init__(\n        self,\n        driver_class: Union[Type[Driver], None] = None,\n        css_path: Union[CSSPathType, None] = None,\n        watch_css: bool = False,\n        language: Union[str, None] = None,\n        use_system_clipboard: bool = True,\n    ):\n        self.language = language\n        self.use_system_clipboard = use_system_clipboard\n        super().__init__(driver_class, css_path, watch_css)\n\n    def compose(self) -> ComposeResult:\n        yield TextArea(\n            language=self.language, use_system_clipboard=self.use_system_clipboard\n        )\n\n    def on_mount(self) -> None:\n        ta = self.query_one(TextArea)\n        ta.focus()", "\n\n@pytest.fixture\ndef app() -> App:\n    app = TextAreaApp(language=\"python\")\n    return app\n\n\n@pytest.fixture(params=[False, True], ids=[\"no_sys_clipboard\", \"default\"])\ndef app_all_clipboards(request: pytest.FixtureRequest) -> App:\n    app = TextAreaApp(use_system_clipboard=request.param)\n    return app", "@pytest.fixture(params=[False, True], ids=[\"no_sys_clipboard\", \"default\"])\ndef app_all_clipboards(request: pytest.FixtureRequest) -> App:\n    app = TextAreaApp(use_system_clipboard=request.param)\n    return app\n"]}
{"filename": "tests/data/test_open/empty.py", "chunked_list": [""]}
{"filename": "tests/data/test_open/foo.py", "chunked_list": ["def foo(bar: str, baz: int) -> None:\n    return\n"]}
{"filename": "tests/unit_tests/test_path_validator.py", "chunked_list": ["from pathlib import Path\n\nimport pytest\nfrom textual_textarea.path_input import PathValidator\n\n\n@pytest.mark.parametrize(\n    \"relpath,dir_okay,file_okay,must_exist,expected_result\",\n    [\n        (\"foo\", True, True, True, True),", "    [\n        (\"foo\", True, True, True, True),\n        (\"foo\", True, True, False, True),\n        (\"foo\", True, False, True, True),\n        (\"foo\", True, False, False, True),\n        (\"foo\", False, True, True, False),\n        (\"foo\", False, True, False, False),\n        (\"foo\", False, False, True, False),\n        (\"foo\", False, False, False, False),\n        (\"bar\", True, True, True, True),", "        (\"foo\", False, False, False, False),\n        (\"bar\", True, True, True, True),\n        (\"bar\", True, True, False, True),\n        (\"bar\", True, False, True, True),\n        (\"bar\", True, False, False, True),\n        (\"bar\", False, True, True, False),\n        (\"bar\", False, True, False, False),\n        (\"bar\", False, False, True, False),\n        (\"bar\", False, False, False, False),\n        (\"baz\", True, True, True, False),", "        (\"bar\", False, False, False, False),\n        (\"baz\", True, True, True, False),\n        (\"baz\", True, True, False, True),\n        (\"baz\", True, False, True, False),\n        (\"baz\", True, False, False, True),\n        (\"baz\", False, True, True, False),\n        (\"baz\", False, True, False, True),\n        (\"baz\", False, False, True, False),\n        (\"baz\", False, False, False, True),\n        (\"foo/baz.txt\", True, True, True, True),", "        (\"baz\", False, False, False, True),\n        (\"foo/baz.txt\", True, True, True, True),\n        (\"foo/baz.txt\", True, True, False, True),\n        (\"foo/baz.txt\", True, False, True, False),\n        (\"foo/baz.txt\", True, False, False, False),\n        (\"foo/baz.txt\", False, True, True, True),\n        (\"foo/baz.txt\", False, True, False, True),\n        (\"foo/baz.txt\", False, False, True, False),\n        (\"foo/baz.txt\", False, False, False, False),\n    ],", "        (\"foo/baz.txt\", False, False, False, False),\n    ],\n)\ndef test_path_validator(\n    data_dir: Path,\n    relpath: str,\n    dir_okay: bool,\n    file_okay: bool,\n    must_exist: bool,\n    expected_result: bool,\n) -> None:\n    p = data_dir / \"test_validator\" / relpath\n    validator = PathValidator(dir_okay, file_okay, must_exist)\n    result = validator.validate(str(p))\n    assert result.is_valid == expected_result", ""]}
{"filename": "tests/unit_tests/test_key_handlers.py", "chunked_list": ["from typing import List\n\nimport pytest\nfrom textual_textarea.key_handlers import Cursor, handle_arrow\n\n\n@pytest.mark.parametrize(\n    \"key,lines,cursor,expected\",\n    [\n        (\"right\", [\"select 1 \"], Cursor(0, 0), Cursor(0, 1)),", "    [\n        (\"right\", [\"select 1 \"], Cursor(0, 0), Cursor(0, 1)),\n        (\"left\", [\"select 1 \"], Cursor(0, 0), Cursor(0, 0)),\n        (\"up\", [\"select 1 \"], Cursor(0, 0), Cursor(0, 0)),\n        (\"down\", [\"select 1 \"], Cursor(0, 0), Cursor(0, 8)),\n        (\"right\", [\"select 1 \"], Cursor(0, 1), Cursor(0, 2)),\n        (\"left\", [\"select 1 \"], Cursor(0, 1), Cursor(0, 0)),\n        (\"up\", [\"select 1 \"], Cursor(0, 1), Cursor(0, 0)),\n        (\"down\", [\"select 1 \"], Cursor(0, 1), Cursor(0, 8)),\n        (\"right\", [\"select 1 \"], Cursor(0, 8), Cursor(0, 8)),", "        (\"down\", [\"select 1 \"], Cursor(0, 1), Cursor(0, 8)),\n        (\"right\", [\"select 1 \"], Cursor(0, 8), Cursor(0, 8)),\n        (\"left\", [\"select 1 \"], Cursor(0, 8), Cursor(0, 7)),\n        (\"up\", [\"select 1 \"], Cursor(0, 8), Cursor(0, 0)),\n        (\"down\", [\"select 1 \"], Cursor(0, 8), Cursor(0, 8)),\n        (\"right\", [\"select 1 \", \"from a \"], Cursor(0, 0), Cursor(0, 1)),\n        (\"left\", [\"select 1 \", \"from a \"], Cursor(0, 0), Cursor(0, 0)),\n        (\"up\", [\"select 1 \", \"from a \"], Cursor(0, 0), Cursor(0, 0)),\n        (\"down\", [\"select 1 \", \"from a \"], Cursor(0, 0), Cursor(1, 0)),\n        (\"right\", [\"select 1 \", \"from a \"], Cursor(0, 8), Cursor(1, 0)),", "        (\"down\", [\"select 1 \", \"from a \"], Cursor(0, 0), Cursor(1, 0)),\n        (\"right\", [\"select 1 \", \"from a \"], Cursor(0, 8), Cursor(1, 0)),\n        (\"left\", [\"select 1 \", \"from a \"], Cursor(0, 8), Cursor(0, 7)),\n        (\"up\", [\"select 1 \", \"from a \"], Cursor(0, 8), Cursor(0, 0)),\n        (\"down\", [\"select 1 \", \"from a \"], Cursor(0, 8), Cursor(1, 6)),\n        (\"right\", [\"select 1 \", \"from a \"], Cursor(1, 0), Cursor(1, 1)),\n        (\"left\", [\"select 1 \", \"from a \"], Cursor(1, 0), Cursor(0, 8)),\n        (\"up\", [\"select 1 \", \"from a \"], Cursor(1, 0), Cursor(0, 0)),\n        (\"down\", [\"select 1 \", \"from a \"], Cursor(1, 0), Cursor(1, 6)),\n        (\"right\", [\"select 1 \", \"from a \"], Cursor(1, 6), Cursor(1, 6)),", "        (\"down\", [\"select 1 \", \"from a \"], Cursor(1, 0), Cursor(1, 6)),\n        (\"right\", [\"select 1 \", \"from a \"], Cursor(1, 6), Cursor(1, 6)),\n        (\"left\", [\"select 1 \", \"from a \"], Cursor(1, 6), Cursor(1, 5)),\n        (\"up\", [\"select 1 \", \"from a \"], Cursor(1, 6), Cursor(0, 6)),\n        (\"down\", [\"select 1 \", \"from a \"], Cursor(1, 6), Cursor(1, 6)),\n        (\"ctrl+right\", [\"select 1 \"], Cursor(0, 0), Cursor(0, 6)),\n        (\"ctrl+left\", [\"select 1 \"], Cursor(0, 0), Cursor(0, 0)),\n        (\"ctrl+right\", [\"select 1 \"], Cursor(0, 6), Cursor(0, 8)),\n        (\"ctrl+left\", [\"select 1 \"], Cursor(0, 6), Cursor(0, 0)),\n        (\"ctrl+right\", [\"select 1 \"], Cursor(0, 7), Cursor(0, 8)),", "        (\"ctrl+left\", [\"select 1 \"], Cursor(0, 6), Cursor(0, 0)),\n        (\"ctrl+right\", [\"select 1 \"], Cursor(0, 7), Cursor(0, 8)),\n        (\"ctrl+left\", [\"select 1 \"], Cursor(0, 7), Cursor(0, 0)),\n        (\"ctrl+right\", [\"select 1 \"], Cursor(0, 8), Cursor(0, 8)),\n        (\"ctrl+left\", [\"select 1 \"], Cursor(0, 8), Cursor(0, 7)),\n        (\"ctrl+right\", [\"select 1 \", \"from a \"], Cursor(0, 0), Cursor(0, 6)),\n        (\"ctrl+left\", [\"select 1 \", \"from a \"], Cursor(0, 0), Cursor(0, 0)),\n        (\"ctrl+right\", [\"select 1 \", \"from a \"], Cursor(0, 1), Cursor(0, 6)),\n        (\"ctrl+left\", [\"select 1 \", \"from a \"], Cursor(0, 1), Cursor(0, 0)),\n        (\"ctrl+right\", [\"select 1 \", \"from a \"], Cursor(0, 6), Cursor(0, 8)),", "        (\"ctrl+left\", [\"select 1 \", \"from a \"], Cursor(0, 1), Cursor(0, 0)),\n        (\"ctrl+right\", [\"select 1 \", \"from a \"], Cursor(0, 6), Cursor(0, 8)),\n        (\"ctrl+left\", [\"select 1 \", \"from a \"], Cursor(0, 6), Cursor(0, 0)),\n        (\"ctrl+right\", [\"select 1 \", \"from a \"], Cursor(0, 7), Cursor(0, 8)),\n        (\"ctrl+left\", [\"select 1 \", \"from a \"], Cursor(0, 7), Cursor(0, 0)),\n        (\"ctrl+right\", [\"select 1 \", \"from a \"], Cursor(0, 8), Cursor(1, 4)),\n        (\"ctrl+left\", [\"select 1 \", \"from a \"], Cursor(0, 8), Cursor(0, 7)),\n        (\"ctrl+right\", [\"select 1 \", \"from a \"], Cursor(1, 0), Cursor(1, 4)),\n        (\"ctrl+left\", [\"select 1 \", \"from a \"], Cursor(1, 0), Cursor(0, 7)),\n        (\"ctrl+left\", [\"    select 1 \", \"    from a \"], Cursor(1, 4), Cursor(1, 0)),", "        (\"ctrl+left\", [\"select 1 \", \"from a \"], Cursor(1, 0), Cursor(0, 7)),\n        (\"ctrl+left\", [\"    select 1 \", \"    from a \"], Cursor(1, 4), Cursor(1, 0)),\n        (\"ctrl+right\", [\"    select 1 \", \"    from a \"], Cursor(1, 0), Cursor(1, 8)),\n        (\"ctrl+right\", [\"sum(foo) \"], Cursor(0, 0), Cursor(0, 3)),\n        (\"ctrl+right\", [\"sum(foo) \"], Cursor(0, 3), Cursor(0, 7)),\n        (\"ctrl+right\", [\"sum(foo) \"], Cursor(0, 7), Cursor(0, 8)),\n        (\"ctrl+left\", [\"sum(foo) \"], Cursor(0, 8), Cursor(0, 4)),\n        (\"ctrl+left\", [\"sum(foo) \"], Cursor(0, 4), Cursor(0, 0)),\n    ],\n)\ndef test_arrows(key: str, lines: List[str], cursor: Cursor, expected: Cursor) -> None:\n    actual = handle_arrow(key, lines, cursor)\n    assert actual == expected", "    ],\n)\ndef test_arrows(key: str, lines: List[str], cursor: Cursor, expected: Cursor) -> None:\n    actual = handle_arrow(key, lines, cursor)\n    assert actual == expected\n"]}
{"filename": "src/textual_textarea/colors.py", "chunked_list": ["from typing import NamedTuple\n\nfrom rich.syntax import PygmentsSyntaxTheme\nfrom textual.color import BLACK, WHITE, Color\n\n\nclass WidgetColors(NamedTuple):\n    contrast_text_color: Color\n    bgcolor: Color\n    selection_bgcolor: Color\n\n    @classmethod\n    def from_theme(cls, theme: str) -> \"WidgetColors\":\n        theme_background_style = PygmentsSyntaxTheme(theme).get_background_style()\n        if (\n            theme_background_style is not None\n            and theme_background_style.bgcolor is not None\n        ):\n            t_color = Color.from_rich_color(theme_background_style.bgcolor)\n            bgcolor = t_color\n            contrast_text_color = t_color.get_contrast_text()\n            if t_color.brightness >= 0.5:\n                selection_bgcolor = t_color.darken(0.10)\n            else:\n                selection_bgcolor = t_color.lighten(0.10)\n            return WidgetColors(contrast_text_color, bgcolor, selection_bgcolor)\n        else:\n            return WidgetColors(BLACK, WHITE, Color.parse(\"#aaaaaa\"))", ""]}
{"filename": "src/textual_textarea/__main__.py", "chunked_list": ["import sys\n\nfrom textual.app import App, ComposeResult\n\nfrom textual_textarea import TextArea\n\n\nclass TextApp(App, inherit_bindings=False):\n    def compose(self) -> ComposeResult:\n        try:\n            language = sys.argv[1]\n        except IndexError:\n            language = \"python\"\n        yield TextArea(language=language, theme=\"monokai\", use_system_clipboard=True)\n\n    def on_mount(self) -> None:\n        ta = self.query_one(TextArea)\n        ta.focus()", "\n\napp = TextApp()\napp.run()\n"]}
{"filename": "src/textual_textarea/error_modal.py", "chunked_list": ["from typing import Union\n\nfrom textual.app import ComposeResult\nfrom textual.containers import Vertical, VerticalScroll\nfrom textual.screen import ModalScreen\nfrom textual.widgets import Static\n\n\nclass ErrorModal(ModalScreen):\n    DEFAULT_CSS = \"\"\"\n        ErrorModal {\n            align: center middle;\n            padding: 0;\n        }\n        #error_modal__outer {\n            border: round $error;\n            background: $surface;\n            margin: 5 10;\n            padding: 1 2;\n            max-width: 88;\n        }\n\n        #error_modal__header {\n            dock: top;\n            color: $text-muted;\n            margin: 0 0 1 0;\n            padding: 0 1;\n        }\n\n        #error_modal__inner {\n            border: round $panel-lighten-1;\n            padding: 1 1 1 2;\n        }\n\n        #error_modal__info {\n            padding: 0 3 0 0;\n        }\n\n        #error_modal__footer {\n            dock: bottom;\n            color: $text-muted;\n            margin: 1 0 0 0;\n            padding: 0 1;\n        }\n    \"\"\"\n\n    def __init__(\n        self,\n        title: str,\n        header: str,\n        error: BaseException,\n        name: Union[str, None] = None,\n        id: Union[str, None] = None,\n        classes: Union[str, None] = None,\n    ) -> None:\n        self.title = title\n        self.header = header\n        self.error = error\n        super().__init__(name, id, classes)\n\n    def compose(self) -> ComposeResult:\n        with Vertical(id=\"error_modal__outer\"):\n            yield Static(self.header, id=\"error_modal__header\")\n            with Vertical(id=\"error_modal__inner\"):\n                with VerticalScroll():\n                    yield Static(str(self.error), id=\"error_modal__info\")\n            yield Static(\"Press any key to continue.\", id=\"error_modal__footer\")\n\n    def on_mount(self) -> None:\n        container = self.query_one(\"#error_modal__outer\")\n        container.border_title = self.title\n\n    def on_key(self) -> None:\n        self.app.pop_screen()\n        self.app.action_focus_next()", "class ErrorModal(ModalScreen):\n    DEFAULT_CSS = \"\"\"\n        ErrorModal {\n            align: center middle;\n            padding: 0;\n        }\n        #error_modal__outer {\n            border: round $error;\n            background: $surface;\n            margin: 5 10;\n            padding: 1 2;\n            max-width: 88;\n        }\n\n        #error_modal__header {\n            dock: top;\n            color: $text-muted;\n            margin: 0 0 1 0;\n            padding: 0 1;\n        }\n\n        #error_modal__inner {\n            border: round $panel-lighten-1;\n            padding: 1 1 1 2;\n        }\n\n        #error_modal__info {\n            padding: 0 3 0 0;\n        }\n\n        #error_modal__footer {\n            dock: bottom;\n            color: $text-muted;\n            margin: 1 0 0 0;\n            padding: 0 1;\n        }\n    \"\"\"\n\n    def __init__(\n        self,\n        title: str,\n        header: str,\n        error: BaseException,\n        name: Union[str, None] = None,\n        id: Union[str, None] = None,\n        classes: Union[str, None] = None,\n    ) -> None:\n        self.title = title\n        self.header = header\n        self.error = error\n        super().__init__(name, id, classes)\n\n    def compose(self) -> ComposeResult:\n        with Vertical(id=\"error_modal__outer\"):\n            yield Static(self.header, id=\"error_modal__header\")\n            with Vertical(id=\"error_modal__inner\"):\n                with VerticalScroll():\n                    yield Static(str(self.error), id=\"error_modal__info\")\n            yield Static(\"Press any key to continue.\", id=\"error_modal__footer\")\n\n    def on_mount(self) -> None:\n        container = self.query_one(\"#error_modal__outer\")\n        container.border_title = self.title\n\n    def on_key(self) -> None:\n        self.app.pop_screen()\n        self.app.action_focus_next()", ""]}
{"filename": "src/textual_textarea/comments.py", "chunked_list": ["INLINE_MARKERS = {\n    \"abap\": '\"',\n    \"actionscript\": \"//\",\n    \"as\": \"//\",\n    \"actionscript3\": \"//\",\n    \"as3\": \"//\",\n    \"ada\": \"--\",\n    \"ada95\": \"--\",\n    \"ada2005\": \"--\",\n    \"antlr-objc\": \"//\",", "    \"ada2005\": \"--\",\n    \"antlr-objc\": \"//\",\n    \"apl\": \"\u235d\",\n    \"applescript\": \"--\",\n    \"autohotkey\": \";\",\n    \"ahk\": \";\",\n    \"autoit\": \";\",\n    \"basemake\": \"#\",\n    \"bash\": \"#\",\n    \"sh\": \"#\",", "    \"bash\": \"#\",\n    \"sh\": \"#\",\n    \"ksh\": \"#\",\n    \"zsh\": \"#\",\n    \"shell\": \"#\",\n    \"batch\": \"::\",\n    \"bat\": \"::\",\n    \"dosbatch\": \"::\",\n    \"winbatch\": \"::\",\n    \"bbcbasic\": \"REM\",", "    \"winbatch\": \"::\",\n    \"bbcbasic\": \"REM\",\n    \"blitzbasic\": \"REM\",\n    \"b3d\": \"REM\",\n    \"bplus\": \"REM\",\n    \"boo\": \"#\",\n    \"c\": \"//\",\n    \"csharp\": \"//\",\n    \"c#\": \"//\",\n    \"cs\": \"//\",", "    \"c#\": \"//\",\n    \"cs\": \"//\",\n    \"cpp\": \"//\",\n    \"c++\": \"//\",\n    \"cbmbas\": \"REM\",\n    \"clojure\": \";\",\n    \"clj\": \";\",\n    \"clojurescript\": \";\",\n    \"cljs\": \";\",\n    \"cmake\": \"#\",", "    \"cljs\": \";\",\n    \"cmake\": \"#\",\n    \"cobol\": \"*>\",\n    \"cobolfree\": \"*>\",\n    \"common-lisp\": \";\",\n    \"cl\": \";\",\n    \"lisp\": \";\",\n    \"d\": \"//\",\n    \"delphi\": \"//\",\n    \"pas\": \"//\",", "    \"delphi\": \"//\",\n    \"pas\": \"//\",\n    \"pascal\": \"//\",\n    \"objectpascal\": \"//\",\n    \"eiffel\": \"--\",\n    \"elixir\": \"#\",\n    \"ex\": \"#\",\n    \"exs\": \"#\",\n    \"iex\": \"#\",\n    \"elm\": \"--\",", "    \"iex\": \"#\",\n    \"elm\": \"--\",\n    \"emacs-lisp\": \";\",\n    \"elisp\": \";\",\n    \"emacs\": \";\",\n    \"erlang\": \"%\",\n    \"erl\": \"%\",\n    \"fsharp\": \"//\",\n    \"f#\": \"//\",\n    \"factor\": \"!\",", "    \"f#\": \"//\",\n    \"factor\": \"!\",\n    \"fish\": \"#\",\n    \"fishshell\": \"#\",\n    \"forth\": \"\\\\\",\n    \"fortran\": \"!\",\n    \"f90\": \"!\",\n    \"fortranfixed\": \"!\",\n    \"go\": \"//\",\n    \"golang\": \"//\",", "    \"go\": \"//\",\n    \"golang\": \"//\",\n    \"haskell\": \"--\",\n    \"hs\": \"--\",\n    \"inform6\": \"!\",\n    \"i6\": \"!\",\n    \"i6t\": \"!\",\n    \"inform7\": \"!\",\n    \"i7\": \"!\",\n    \"j\": \"NB.\",", "    \"i7\": \"!\",\n    \"j\": \"NB.\",\n    \"java\": \"//\",\n    \"jsp\": \"//\",\n    \"javascript\": \"//\",\n    \"js\": \"//\",\n    \"julia\": \"#\",\n    \"jl\": \"#\",\n    \"jlcon\": \"#\",\n    \"julia-repl\": \"#\",", "    \"jlcon\": \"#\",\n    \"julia-repl\": \"#\",\n    \"kotlin\": \"//\",\n    \"lua\": \"--\",\n    \"make\": \"#\",\n    \"makefile\": \"#\",\n    \"mf\": \"#\",\n    \"bsdmake\": \"#\",\n    \"matlab\": \"%\",\n    \"matlabsession\": \"%\",", "    \"matlab\": \"%\",\n    \"matlabsession\": \"%\",\n    \"monkey\": \"'\",\n    \"mysql\": \"#\",\n    \"newlisp\": \";\",\n    \"nimrod\": \"#\",\n    \"nim\": \"#\",\n    \"objective-c\": \"//\",\n    \"objectivec\": \"//\",\n    \"obj-c\": \"//\",", "    \"objectivec\": \"//\",\n    \"obj-c\": \"//\",\n    \"objc\": \"//\",\n    \"objective-c++\": \"//\",\n    \"objectivec++\": \"//\",\n    \"obj-c++\": \"//\",\n    \"objc++\": \"//\",\n    \"perl\": \"#\",\n    \"pl\": \"#\",\n    \"perl6\": \"#\",", "    \"pl\": \"#\",\n    \"perl6\": \"#\",\n    \"pl6\": \"#\",\n    \"raku\": \"#\",\n    \"php\": \"#\",\n    \"php3\": \"#\",\n    \"php4\": \"#\",\n    \"php5\": \"#\",\n    \"plpgsql\": \"--\",\n    \"psql\": \"--\",", "    \"plpgsql\": \"--\",\n    \"psql\": \"--\",\n    \"postgresql-console\": \"--\",\n    \"postgres-console\": \"--\",\n    \"postgres-explain\": \"--\",\n    \"postgresql\": \"--\",\n    \"postgres\": \"--\",\n    \"postscript\": \"%\",\n    \"postscr\": \"%\",\n    \"powershell\": \"#\",", "    \"postscr\": \"%\",\n    \"powershell\": \"#\",\n    \"pwsh\": \"#\",\n    \"posh\": \"#\",\n    \"ps1\": \"#\",\n    \"psm1\": \"#\",\n    \"pwsh-session\": \"#\",\n    \"ps1con\": \"#\",\n    \"prolog\": \"%\",\n    \"python\": \"#\",", "    \"prolog\": \"%\",\n    \"python\": \"#\",\n    \"py\": \"#\",\n    \"sage\": \"#\",\n    \"python3\": \"#\",\n    \"py3\": \"#\",\n    \"python2\": \"#\",\n    \"py2\": \"#\",\n    \"py2tb\": \"#\",\n    \"pycon\": \"#\",", "    \"py2tb\": \"#\",\n    \"pycon\": \"#\",\n    \"pytb\": \"#\",\n    \"py3tb\": \"#\",\n    \"py+ul4\": \"#\",\n    \"qbasic\": \"REM\",\n    \"basic\": \"REM\",\n    \"ragel-ruby\": \"#\",\n    \"ragel-rb\": \"#\",\n    \"rebol\": \";\",", "    \"ragel-rb\": \"#\",\n    \"rebol\": \";\",\n    \"red\": \";\",\n    \"red/system\": \";\",\n    \"ruby\": \"#\",\n    \"rb\": \"#\",\n    \"duby\": \"#\",\n    \"rbcon\": \"#\",\n    \"irb\": \"#\",\n    \"rust\": \"//\",", "    \"irb\": \"#\",\n    \"rust\": \"//\",\n    \"rs\": \"//\",\n    \"sass\": \"//\",\n    \"scala\": \"//\",\n    \"scheme\": \";\",\n    \"scm\": \";\",\n    \"sql\": \"--\",\n    \"sql+jinja\": \"--\",\n    \"sqlite3\": \"--\",", "    \"sql+jinja\": \"--\",\n    \"sqlite3\": \"--\",\n    \"swift\": \"//\",\n    \"tex\": \"%\",\n    \"latex\": \"%\",\n    \"tsql\": \"--\",\n    \"t-sql\": \"--\",\n    \"vbscript\": \"'\",\n    \"vhdl\": \"--\",\n    \"wast\": \";;\",", "    \"vhdl\": \"--\",\n    \"wast\": \";;\",\n    \"wat\": \";;\",\n    \"yaml\": \"#\",\n    \"yaml+jinja\": \"#\",\n    \"salt\": \"#\",\n    \"sls\": \"#\",\n    \"zig\": \"//\",\n}\n", "}\n"]}
{"filename": "src/textual_textarea/__init__.py", "chunked_list": ["from textual_textarea.messages import TextAreaCursorMoved\nfrom textual_textarea.path_input import CancelPathInput, PathInput\nfrom textual_textarea.textarea import TextArea\n\n__all__ = [\"TextArea\", \"PathInput\", \"CancelPathInput\", \"TextAreaCursorMoved\"]\n"]}
{"filename": "src/textual_textarea/containers.py", "chunked_list": ["from typing import Union\n\nfrom textual.containers import Container, ScrollableContainer\nfrom textual.widget import Widget\n\nfrom textual_textarea.colors import WidgetColors\n\n\nclass TextContainer(\n    ScrollableContainer,\n    inherit_bindings=False,\n    can_focus=False,\n    can_focus_children=True,\n):\n    DEFAULT_CSS = \"\"\"\n        TextContainer {\n            height: 1fr;\n            width: 100%\n        }\n    \"\"\"", "class TextContainer(\n    ScrollableContainer,\n    inherit_bindings=False,\n    can_focus=False,\n    can_focus_children=True,\n):\n    DEFAULT_CSS = \"\"\"\n        TextContainer {\n            height: 1fr;\n            width: 100%\n        }\n    \"\"\"", "\n\nclass FooterContainer(\n    Container,\n    inherit_bindings=False,\n    can_focus=False,\n    can_focus_children=True,\n):\n    DEFAULT_CSS = \"\"\"\n        FooterContainer {\n            dock: bottom;\n            height: auto;\n            width: 100%\n        }\n    \"\"\"\n\n    def __init__(\n        self,\n        theme_colors: WidgetColors,\n        *children: Widget,\n        name: Union[str, None] = None,\n        id: Union[str, None] = None,\n        classes: Union[str, None] = None,\n        disabled: bool = False,\n    ) -> None:\n        super().__init__(\n            *children, name=name, id=id, classes=classes, disabled=disabled\n        )\n        self.theme_colors = theme_colors", ""]}
{"filename": "src/textual_textarea/textarea.py", "chunked_list": ["from math import ceil, floor\nfrom os.path import expanduser\nfrom typing import List, Tuple, Union\n\nimport pyperclip\nfrom rich.console import RenderableType\nfrom rich.style import Style\nfrom rich.syntax import Syntax\nfrom textual import events\nfrom textual.app import ComposeResult", "from textual import events\nfrom textual.app import ComposeResult\nfrom textual.binding import Binding\nfrom textual.reactive import reactive\nfrom textual.widget import Widget\nfrom textual.widgets import Input, Label, Static\n\nfrom textual_textarea.colors import WidgetColors\nfrom textual_textarea.comments import INLINE_MARKERS\nfrom textual_textarea.containers import FooterContainer, TextContainer", "from textual_textarea.comments import INLINE_MARKERS\nfrom textual_textarea.containers import FooterContainer, TextContainer\nfrom textual_textarea.error_modal import ErrorModal\nfrom textual_textarea.key_handlers import Cursor, handle_arrow\nfrom textual_textarea.messages import TextAreaCursorMoved, TextAreaScrollOne\nfrom textual_textarea.path_input import PathInput\nfrom textual_textarea.serde import deserialize_lines, serialize_lines\n\nBRACKETS = {\n    \"(\": \")\",", "BRACKETS = {\n    \"(\": \")\",\n    \"[\": \"]\",\n    \"{\": \"}\",\n}\nCLOSERS = {'\"': '\"', \"'\": \"'\", **BRACKETS}\nTAB_SIZE = 4\n\n\nclass TextInput(Static, can_focus=True):\n    DEFAULT_CSS = \"\"\"\n        TextInput {\n            height: auto;\n            width: auto;\n            padding: 0 1;\n        }\n    \"\"\"\n\n    lines: reactive[List[str]] = reactive(lambda: list(\" \"))\n    cursor: reactive[Cursor] = reactive(Cursor(0, 0))\n    selection_anchor: reactive[Union[Cursor, None]] = reactive(None)\n    clipboard: List[str] = list()\n    cursor_visible: reactive[bool] = reactive(True)\n    use_system_clipboard: bool = True\n    language: reactive[Union[str, None]] = reactive(None)\n\n    def __init__(\n        self,\n        theme_colors: WidgetColors,\n        language: Union[str, None] = None,\n        theme: str = \"monokai\",\n        use_system_clipboard: bool = True,\n    ) -> None:\n        super().__init__()\n        self.theme_colors = theme_colors\n        self.language = language\n        self.theme = theme\n        self.use_system_clipboard = use_system_clipboard\n\n    def on_mount(self) -> None:\n        self.blink_timer = self.set_interval(\n            0.5,\n            self._toggle_cursor,\n            pause=not self.has_focus,\n        )\n\n    def on_focus(self) -> None:\n        self.cursor_visible = True\n        self.blink_timer.reset()\n        self._scroll_to_cursor()\n        self.update(self._content)\n\n    def on_blur(self) -> None:\n        self.blink_timer.pause()\n        self.cursor_visible = False\n        self.update(self._content)\n\n    def on_mouse_down(self, event: events.MouseDown) -> None:\n        \"\"\"\n        Moves the anchor and cursor to the click.\n        \"\"\"\n        event.stop()\n        self.cursor_visible = True\n        self.blink_timer.reset()\n        self.selection_anchor = Cursor.from_mouse_event(event)\n        self.move_cursor(event.x - 1, event.y)\n        self.focus()\n\n    def on_mouse_move(self, event: events.MouseMove) -> None:\n        \"\"\"\n        Updates the cursor if the button is pressed while the mouse\n        is moving.\n        \"\"\"\n        if event.button == 1:\n            self.move_cursor(event.x - 1, event.y)\n\n    def on_mouse_up(self, event: events.MouseUp) -> None:\n        \"\"\"\n        Moves the cursor to the click.\n        \"\"\"\n        event.stop()\n        self.cursor_visible = True\n        self.blink_timer.reset()\n        if self.selection_anchor == Cursor.from_mouse_event(event):\n            # simple click\n            self.selection_anchor = None\n        else:\n            self.move_cursor(event.x - 1, event.y)\n        self.focus()\n\n    def on_click(self, event: events.Click) -> None:\n        \"\"\"\n        Click duplicates MouseUp and MouseDown, so we just capture and kill this event.\n        \"\"\"\n        event.stop()\n\n    def on_paste(self, event: events.Paste) -> None:\n        \"\"\"\n        If the user hits ctrl+v, we don't get that keypress;\n        we get a Paste event instead.\n\n        This ignores the contents of the Paste message and mimics the behavior of\n        ctrl+u.\n        \"\"\"\n        event.stop()\n        self.cursor_visible = True\n        self.blink_timer.reset()\n        self._insert_clipboard_at_selection(self.selection_anchor, self.cursor)\n        self.selection_anchor = None\n        self.update(self._content)\n\n    def on_key(self, event: events.Key) -> None:\n        self.cursor_visible = True\n        self.blink_timer.reset()\n        selection_before = self.selection_anchor\n\n        # set selection_anchor if it's unset\n        if event.key == \"shift+delete\":\n            pass  # todo: shift+delete should delete the whole line\n        elif event.key == \"shift+tab\":\n            pass\n        elif event.key in (\n            \"ctrl+underscore\",\n            \"ctrl+`\",\n            \"ctrl+@\",\n            \"ctrl+s\",\n            \"ctrl+c\",\n            \"ctrl+enter\",\n            \"ctrl+j\",\n            \"ctrl+e\",\n            \"f1\",\n            \"f2\",\n            \"f3\",\n            \"f4\",\n            \"f5\",\n            \"f6\",\n            \"f7\",\n            \"f8\",\n            \"f9\",\n            \"f10\",\n            \"f11\",\n            \"f12\",\n        ):\n            pass  #  these should maintain selection\n        elif event.key == \"ctrl+a\":\n            self.selection_anchor = Cursor(0, 0)\n        elif selection_before is None and \"shift\" in event.key:\n            self.selection_anchor = self.cursor\n        elif selection_before is not None and \"shift\" not in event.key:\n            self.selection_anchor = None\n\n        # set cursor and modify lines if necessary\n        if event.key in (\n            \"apostrophe\",\n            \"quotation_mark\",\n            \"left_parenthesis\",\n            \"left_square_bracket\",\n            \"left_curly_bracket\",\n            \"right_parenthesis\",\n            \"right_square_bracket\",\n            \"right_curly_bracket\",\n        ):\n            assert event.character is not None\n            if selection_before is None:\n                self._insert_closed_character_at_cursor(event.character, self.cursor)\n            elif event.key in (\n                \"right_parenthesis\",\n                \"right_square_bracket\",\n                \"right_curly_bracket\",\n            ):\n                self._delete_selection(selection_before, self.cursor)\n                self._insert_character_at_cursor(event.character, self.cursor)\n                self.cursor = Cursor(\n                    lno=self.cursor.lno, pos=self.cursor.pos + len(event.character)\n                )\n            else:\n                self._insert_characters_around_selection(\n                    event.character, selection_before, self.cursor\n                )\n        elif event.key in (\"pageup\", \"shift+pageup\"):\n            event.stop()\n            self.move_cursor(\n                x=self.cursor.pos, y=(self.cursor.lno - self._visible_height() + 1)\n            )\n        elif event.key in (\"pagedown\", \"shift+pagedown\"):\n            event.stop()\n            self.move_cursor(\n                x=self.cursor.pos, y=(self.cursor.lno + self._visible_height() - 1)\n            )\n        elif event.key in (\"ctrl+up\", \"ctrl+down\"):\n            event.stop()\n            self.post_message(TextAreaScrollOne(direction=event.key.split(\"+\")[1]))\n        elif any([dir in event.key for dir in [\"left\", \"right\", \"up\", \"down\"]]):\n            event.stop()\n            self.cursor = handle_arrow(event.key, self.lines, self.cursor)\n        elif event.key in (\"home\", \"shift+home\"):\n            event.stop()\n            self.cursor = Cursor(self.cursor.lno, 0)\n        elif event.key in (\"end\", \"shift+end\"):\n            event.stop()\n            self.cursor = Cursor(self.cursor.lno, len(self.lines[self.cursor.lno]) - 1)\n        elif event.key == \"ctrl+home\":\n            event.stop()\n            self.cursor = Cursor(0, 0)\n        elif event.key in (\"ctrl+end\", \"ctrl+a\"):\n            event.stop()\n            self.cursor = Cursor(lno=len(self.lines) - 1, pos=len(self.lines[-1]) - 1)\n        elif event.key == \"ctrl+underscore\":  # actually ctrl+/\n            event.stop()\n            if self.inline_comment_marker:\n                lines, first, last = self._get_selected_lines(selection_before)\n                stripped_lines = [line.lstrip() for line in lines]\n                indents = [len(line) - len(line.lstrip()) for line in lines]\n                if all(\n                    [\n                        line.startswith(self.inline_comment_marker)\n                        for line in stripped_lines\n                    ]\n                ):\n                    no_comment_lines = [\n                        line[len(self.inline_comment_marker) :].lstrip()\n                        for line in stripped_lines\n                    ]\n                    self.lines[first.lno : last.lno + 1] = [\n                        f\"{' ' * indent}{line}\"\n                        for indent, line in zip(indents, no_comment_lines)\n                    ]\n                    self.move_cursor(\n                        self.cursor.pos - len(self.inline_comment_marker) - 1,\n                        self.cursor.lno,\n                    )\n                    if selection_before:\n                        self.move_selection_anchor(\n                            selection_before.pos - len(self.inline_comment_marker) - 1,\n                            selection_before.lno,\n                        )\n                else:\n                    self.lines[first.lno : last.lno + 1] = [\n                        f\"{' ' * indent}{self.inline_comment_marker} {stripped_line}\"\n                        for indent, stripped_line in zip(indents, stripped_lines)\n                    ]\n                    self.move_cursor(\n                        self.cursor.pos + len(self.inline_comment_marker) + 1,\n                        self.cursor.lno,\n                    )\n                    if selection_before:\n                        self.move_selection_anchor(\n                            selection_before.pos + len(self.inline_comment_marker) + 1,\n                            selection_before.lno,\n                        )\n        elif event.key in (\"ctrl+c\", \"ctrl+x\"):\n            event.stop()\n            if selection_before:\n                lines, first, last = self._get_selected_lines(selection_before)\n            else:  # no selection, copy whole line\n                lines, first, last = (\n                    [self.lines[self.cursor.lno], \"\"],\n                    Cursor(self.cursor.lno, 0),\n                    Cursor(self.cursor.lno, len(self.lines[self.cursor.lno])),\n                )\n            lines[-1] = lines[-1][: last.pos]\n            lines[0] = lines[0][first.pos :]\n            self.clipboard = lines.copy()\n            if self.use_system_clipboard:\n                try:\n                    pyperclip.copy(serialize_lines(self.clipboard))\n                except pyperclip.PyperclipException:\n                    # no system clipboard; common in CI runners\n                    pass\n            self.log(f\"copied to clipboard: {self.clipboard}\")\n            if event.key == \"ctrl+x\":\n                self._delete_selection(first, last)\n                new_lno = min(first.lno, len(self.lines) - 1)\n                self.cursor = Cursor(\n                    new_lno, min(first.pos, len(self.lines[new_lno]) - 1)\n                )\n        elif event.key in (\"ctrl+u\", \"ctrl+v\"):\n            event.stop()\n            self._insert_clipboard_at_selection(selection_before, self.cursor)\n        elif event.key == \"tab\":\n            event.stop()\n            lines, first, last = self._get_selected_lines(selection_before)\n            # in some cases, selections are replaced with four spaces\n            if first.lno == last.lno and (\n                first.pos == last.pos\n                or first.pos != 0\n                or last.pos != len(self.lines[self.cursor.lno]) - 1\n            ):\n                self._delete_selection(first, last)\n                indent = TAB_SIZE - first.pos % TAB_SIZE\n                self._insert_character_at_cursor(\" \" * indent, first)\n                self.cursor = Cursor(lno=first.lno, pos=first.pos + indent)\n            # usually, selected lines are prepended with four-ish spaces\n            else:\n                self._indent_selection(selection_before, self.cursor, kind=\"indent\")\n        elif event.key == \"shift+tab\":\n            event.stop()\n            self._indent_selection(selection_before, self.cursor, kind=\"dedent\")\n        elif event.key == \"enter\":\n            event.stop()\n            old_lines, first, last = self._get_selected_lines(selection_before)\n            head = f\"{old_lines[0][:first.pos]} \"\n            tail = f\"{old_lines[-1][last.pos:]}\"\n            if old_lines[0].isspace():\n                indent = 0\n            else:\n                indent = len(old_lines[0]) - len(old_lines[0].lstrip())\n\n            char_before = self._get_character_before_cursor(first)\n            if char_before in BRACKETS and BRACKETS[\n                char_before\n            ] == self._get_character_at_cursor(last):\n                new_indent = indent + TAB_SIZE - (indent % TAB_SIZE)\n                self.lines[first.lno : last.lno + 1] = [\n                    head,\n                    f\"{' ' * new_indent} \",\n                    f\"{' ' * indent}{tail.lstrip()}\",\n                ]\n                self.cursor = Cursor(first.lno + 1, new_indent)\n            else:\n                self.lines[first.lno : last.lno + 1] = [\n                    head,\n                    f\"{' ' * indent}{tail.lstrip() or ' '}\",\n                ]\n                self.cursor = Cursor(first.lno + 1, min(first.pos, indent))\n        elif event.key == \"delete\":\n            event.stop()\n            if selection_before is None:\n                anchor = self.cursor\n                cursor = handle_arrow(\"right\", self.lines, self.cursor)\n            else:\n                anchor = selection_before\n                cursor = self.cursor\n            self._delete_selection(anchor, cursor)\n        elif event.key == \"backspace\":\n            event.stop()\n            if selection_before is None:\n                anchor = self.cursor\n                cursor = handle_arrow(\"left\", self.lines, self.cursor)\n            else:\n                anchor = selection_before\n                cursor = self.cursor\n            self._delete_selection(anchor, cursor)\n\n        elif event.is_printable:\n            event.stop()\n            assert event.character is not None\n            if selection_before is not None:\n                self._delete_selection(selection_before, self.cursor)\n            self._insert_character_at_cursor(event.character, self.cursor)\n            self.cursor = Cursor(\n                lno=self.cursor.lno, pos=self.cursor.pos + len(event.character)\n            )\n\n        self.update(self._content)\n\n    def watch_cursor(self) -> None:\n        self._scroll_to_cursor()\n\n    def watch_language(self, language: str) -> None:\n        self.inline_comment_marker = INLINE_MARKERS.get(language)\n\n    @property\n    def _content(self) -> RenderableType:\n        syntax = Syntax(\n            \"\\n\".join(self.lines),\n            lexer=self.language,\n            theme=self.theme,\n        )\n        if self.cursor_visible:\n            syntax.stylize_range(\n                \"reverse\",\n                # rows are 1-indexed\n                (self.cursor.lno + 1, self.cursor.pos),\n                (self.cursor.lno + 1, self.cursor.pos + 1),\n            )\n        if self.selection_anchor is not None:\n            first = min(self.selection_anchor, self.cursor)\n            second = max(self.selection_anchor, self.cursor)\n            selection_style = Style(\n                bgcolor=self.theme_colors.selection_bgcolor.rich_color\n            )\n            syntax.stylize_range(\n                selection_style,\n                # rows are 1-indexed\n                (first.lno + 1, first.pos),\n                (second.lno + 1, second.pos),\n            )\n        return syntax\n\n    def _scroll_to_cursor(self) -> None:\n        self.post_message(TextAreaCursorMoved(self.cursor.pos, self.cursor.lno))\n\n    def _visible_height(self) -> int:\n        parent = self.parent\n        assert isinstance(parent, TextContainer)\n        return parent.window_region.height\n\n    def _toggle_cursor(self) -> None:\n        self.cursor_visible = not self.cursor_visible\n        self.update(self._content)\n\n    def _get_selected_lines(\n        self,\n        maybe_anchor: Union[Cursor, None],\n        maybe_cursor: Union[Cursor, None] = None,\n    ) -> Tuple[List[str], Cursor, Cursor]:\n        \"\"\"\n        Returns a tuple of:\n         - the lines between (inclusive) the optional selection anchor and the cursor,\n         - the first of either the cursor or anchor\n         - the last of either the cursor or anchor\n        \"\"\"\n        cursor = maybe_cursor or self.cursor\n        anchor = maybe_anchor or cursor\n        first = min(anchor, cursor)\n        last = max(anchor, cursor)\n        return self.lines[first.lno : last.lno + 1], first, last\n\n    def _insert_character_at_cursor(self, character: str, cursor: Cursor) -> None:\n        line = self.lines[cursor.lno]\n        new_line = f\"{line[:cursor.pos]}{character}{line[cursor.pos:]}\"\n        self.lines[cursor.lno] = new_line\n\n    def _insert_characters_around_selection(\n        self, character: str, anchor: Cursor, cursor: Cursor\n    ) -> None:\n        first = min(anchor, cursor)\n        last = max(anchor, cursor)\n        self._insert_character_at_cursor(character, first)\n        if first.lno == last.lno:\n            self.cursor = Cursor(lno=last.lno, pos=last.pos + len(character))\n        else:\n            self.cursor = last\n        self._insert_character_at_cursor(CLOSERS[character], self.cursor)\n\n    def _insert_closed_character_at_cursor(\n        self, character: str, cursor: Cursor\n    ) -> None:\n        if self._get_character_at_cursor(cursor) == character:\n            self.cursor = Cursor(cursor.lno, cursor.pos + 1)\n        else:\n            prev = self._get_character_before_cursor(cursor)\n            self._insert_character_at_cursor(character, cursor)\n            self.cursor = Cursor(cursor.lno, cursor.pos + len(character))\n            if (\n                character in CLOSERS\n                and self.cursor.pos == len(self.lines[self.cursor.lno]) - 1\n                and (prev is None or prev == \" \" or character in BRACKETS)\n            ):\n                self._insert_character_at_cursor(CLOSERS[character], self.cursor)\n\n    def _delete_selection(self, anchor: Cursor, cursor: Cursor) -> None:\n        old_lines, first, last = self._get_selected_lines(anchor, maybe_cursor=cursor)\n        head = f\"{old_lines[0][:first.pos]}\"\n        tail = f\"{old_lines[-1][last.pos:]}\"\n        if new_line := f\"{head}{tail}\":\n            self.lines[first.lno : last.lno + 1] = [new_line]\n        else:  # empty str, no line-ending space, delete whole line\n            self.lines[first.lno : last.lno + 1] = []\n            if not self.lines:\n                self.lines = [\" \"]\n        self.cursor = Cursor(first.lno, first.pos)\n\n    def _indent_selection(\n        self, anchor: Union[Cursor, None], cursor: Cursor, kind: str\n    ) -> None:\n        assert kind in (\"indent\", \"dedent\")\n        rounder, offset = (ceil, -1) if kind == \"dedent\" else (floor, 1)\n\n        lines, first, last = self._get_selected_lines(anchor, cursor)\n        leading_spaces = [(len(line) - len(line.lstrip())) for line in lines]\n        leading_tabs = [rounder(space / TAB_SIZE) for space in leading_spaces]\n        new_lines = [\n            f\"{' ' * TAB_SIZE * max(0, indent+offset)}{line.lstrip()}\"\n            for line, indent in zip(lines, leading_tabs)\n        ]\n        self.lines[first.lno : last.lno + 1] = new_lines\n        if anchor:\n            change_at_anchor_line = len(new_lines[anchor.lno - first.lno]) - len(\n                lines[anchor.lno - first.lno]\n            )\n            self.selection_anchor = (\n                anchor\n                if anchor.pos == 0\n                else Cursor(\n                    anchor.lno,\n                    anchor.pos + change_at_anchor_line,\n                )\n            )\n        change_at_cursor = len(new_lines[cursor.lno - first.lno]) - len(\n            lines[cursor.lno - first.lno]\n        )\n        self.cursor = (\n            cursor\n            if cursor.pos == 0\n            else Cursor(cursor.lno, cursor.pos + change_at_cursor)\n        )\n\n    def _insert_clipboard_at_selection(\n        self, anchor: Union[Cursor, None], cursor: Cursor\n    ) -> None:\n        if self.use_system_clipboard:\n            try:\n                sys_clipboard = pyperclip.paste()\n            except pyperclip.PyperclipException:\n                # no system clipboard; common in CI runners\n                pass\n            else:\n                self.clipboard = deserialize_lines(sys_clipboard, trim=True)\n        if anchor:\n            self._delete_selection(anchor, cursor)\n            cursor = self.cursor\n        head = self.lines[cursor.lno][: cursor.pos]\n        tail = self.lines[cursor.lno][cursor.pos :]\n        if (clip_len := len(self.clipboard)) != 0:\n            new_lines = self.clipboard.copy()\n            new_lines[0] = f\"{head}{new_lines[0]}\"\n            new_lines[-1] = f\"{new_lines[-1]}{tail}\"\n            self.lines[cursor.lno : cursor.lno + 1] = new_lines\n            self.cursor = Cursor(\n                cursor.lno + clip_len - 1,\n                len(self.lines[cursor.lno + clip_len - 1]) - len(tail),\n            )\n\n    def _get_character_at_cursor(self, cursor: Cursor) -> str:\n        return self.lines[cursor.lno][cursor.pos]\n\n    def _get_character_before_cursor(self, cursor: Cursor) -> Union[str, None]:\n        if self.cursor.pos == 0:\n            return None\n        else:\n            return self.lines[cursor.lno][cursor.pos - 1]\n\n    def move_cursor(self, x: int, y: int) -> None:\n        self.cursor = self._get_valid_cursor(x, y)\n        self.update(self._content)\n\n    def move_selection_anchor(self, x: int, y: int) -> None:\n        self.selection_anchor = self._get_valid_cursor(x, y)\n        self.update(self._content)\n\n    def _get_valid_cursor(self, x: int, y: int) -> Cursor:\n        max_y = len(self.lines) - 1\n        safe_y = max(0, min(max_y, y))\n        max_x = len(self.lines[safe_y]) - 1\n        safe_x = max(0, min(max_x, x))\n        return Cursor(lno=safe_y, pos=safe_x)\n\n    def clear_selection_anchor(self) -> None:\n        self.selection_anchor = None\n        self.update(self._content)", "\nclass TextInput(Static, can_focus=True):\n    DEFAULT_CSS = \"\"\"\n        TextInput {\n            height: auto;\n            width: auto;\n            padding: 0 1;\n        }\n    \"\"\"\n\n    lines: reactive[List[str]] = reactive(lambda: list(\" \"))\n    cursor: reactive[Cursor] = reactive(Cursor(0, 0))\n    selection_anchor: reactive[Union[Cursor, None]] = reactive(None)\n    clipboard: List[str] = list()\n    cursor_visible: reactive[bool] = reactive(True)\n    use_system_clipboard: bool = True\n    language: reactive[Union[str, None]] = reactive(None)\n\n    def __init__(\n        self,\n        theme_colors: WidgetColors,\n        language: Union[str, None] = None,\n        theme: str = \"monokai\",\n        use_system_clipboard: bool = True,\n    ) -> None:\n        super().__init__()\n        self.theme_colors = theme_colors\n        self.language = language\n        self.theme = theme\n        self.use_system_clipboard = use_system_clipboard\n\n    def on_mount(self) -> None:\n        self.blink_timer = self.set_interval(\n            0.5,\n            self._toggle_cursor,\n            pause=not self.has_focus,\n        )\n\n    def on_focus(self) -> None:\n        self.cursor_visible = True\n        self.blink_timer.reset()\n        self._scroll_to_cursor()\n        self.update(self._content)\n\n    def on_blur(self) -> None:\n        self.blink_timer.pause()\n        self.cursor_visible = False\n        self.update(self._content)\n\n    def on_mouse_down(self, event: events.MouseDown) -> None:\n        \"\"\"\n        Moves the anchor and cursor to the click.\n        \"\"\"\n        event.stop()\n        self.cursor_visible = True\n        self.blink_timer.reset()\n        self.selection_anchor = Cursor.from_mouse_event(event)\n        self.move_cursor(event.x - 1, event.y)\n        self.focus()\n\n    def on_mouse_move(self, event: events.MouseMove) -> None:\n        \"\"\"\n        Updates the cursor if the button is pressed while the mouse\n        is moving.\n        \"\"\"\n        if event.button == 1:\n            self.move_cursor(event.x - 1, event.y)\n\n    def on_mouse_up(self, event: events.MouseUp) -> None:\n        \"\"\"\n        Moves the cursor to the click.\n        \"\"\"\n        event.stop()\n        self.cursor_visible = True\n        self.blink_timer.reset()\n        if self.selection_anchor == Cursor.from_mouse_event(event):\n            # simple click\n            self.selection_anchor = None\n        else:\n            self.move_cursor(event.x - 1, event.y)\n        self.focus()\n\n    def on_click(self, event: events.Click) -> None:\n        \"\"\"\n        Click duplicates MouseUp and MouseDown, so we just capture and kill this event.\n        \"\"\"\n        event.stop()\n\n    def on_paste(self, event: events.Paste) -> None:\n        \"\"\"\n        If the user hits ctrl+v, we don't get that keypress;\n        we get a Paste event instead.\n\n        This ignores the contents of the Paste message and mimics the behavior of\n        ctrl+u.\n        \"\"\"\n        event.stop()\n        self.cursor_visible = True\n        self.blink_timer.reset()\n        self._insert_clipboard_at_selection(self.selection_anchor, self.cursor)\n        self.selection_anchor = None\n        self.update(self._content)\n\n    def on_key(self, event: events.Key) -> None:\n        self.cursor_visible = True\n        self.blink_timer.reset()\n        selection_before = self.selection_anchor\n\n        # set selection_anchor if it's unset\n        if event.key == \"shift+delete\":\n            pass  # todo: shift+delete should delete the whole line\n        elif event.key == \"shift+tab\":\n            pass\n        elif event.key in (\n            \"ctrl+underscore\",\n            \"ctrl+`\",\n            \"ctrl+@\",\n            \"ctrl+s\",\n            \"ctrl+c\",\n            \"ctrl+enter\",\n            \"ctrl+j\",\n            \"ctrl+e\",\n            \"f1\",\n            \"f2\",\n            \"f3\",\n            \"f4\",\n            \"f5\",\n            \"f6\",\n            \"f7\",\n            \"f8\",\n            \"f9\",\n            \"f10\",\n            \"f11\",\n            \"f12\",\n        ):\n            pass  #  these should maintain selection\n        elif event.key == \"ctrl+a\":\n            self.selection_anchor = Cursor(0, 0)\n        elif selection_before is None and \"shift\" in event.key:\n            self.selection_anchor = self.cursor\n        elif selection_before is not None and \"shift\" not in event.key:\n            self.selection_anchor = None\n\n        # set cursor and modify lines if necessary\n        if event.key in (\n            \"apostrophe\",\n            \"quotation_mark\",\n            \"left_parenthesis\",\n            \"left_square_bracket\",\n            \"left_curly_bracket\",\n            \"right_parenthesis\",\n            \"right_square_bracket\",\n            \"right_curly_bracket\",\n        ):\n            assert event.character is not None\n            if selection_before is None:\n                self._insert_closed_character_at_cursor(event.character, self.cursor)\n            elif event.key in (\n                \"right_parenthesis\",\n                \"right_square_bracket\",\n                \"right_curly_bracket\",\n            ):\n                self._delete_selection(selection_before, self.cursor)\n                self._insert_character_at_cursor(event.character, self.cursor)\n                self.cursor = Cursor(\n                    lno=self.cursor.lno, pos=self.cursor.pos + len(event.character)\n                )\n            else:\n                self._insert_characters_around_selection(\n                    event.character, selection_before, self.cursor\n                )\n        elif event.key in (\"pageup\", \"shift+pageup\"):\n            event.stop()\n            self.move_cursor(\n                x=self.cursor.pos, y=(self.cursor.lno - self._visible_height() + 1)\n            )\n        elif event.key in (\"pagedown\", \"shift+pagedown\"):\n            event.stop()\n            self.move_cursor(\n                x=self.cursor.pos, y=(self.cursor.lno + self._visible_height() - 1)\n            )\n        elif event.key in (\"ctrl+up\", \"ctrl+down\"):\n            event.stop()\n            self.post_message(TextAreaScrollOne(direction=event.key.split(\"+\")[1]))\n        elif any([dir in event.key for dir in [\"left\", \"right\", \"up\", \"down\"]]):\n            event.stop()\n            self.cursor = handle_arrow(event.key, self.lines, self.cursor)\n        elif event.key in (\"home\", \"shift+home\"):\n            event.stop()\n            self.cursor = Cursor(self.cursor.lno, 0)\n        elif event.key in (\"end\", \"shift+end\"):\n            event.stop()\n            self.cursor = Cursor(self.cursor.lno, len(self.lines[self.cursor.lno]) - 1)\n        elif event.key == \"ctrl+home\":\n            event.stop()\n            self.cursor = Cursor(0, 0)\n        elif event.key in (\"ctrl+end\", \"ctrl+a\"):\n            event.stop()\n            self.cursor = Cursor(lno=len(self.lines) - 1, pos=len(self.lines[-1]) - 1)\n        elif event.key == \"ctrl+underscore\":  # actually ctrl+/\n            event.stop()\n            if self.inline_comment_marker:\n                lines, first, last = self._get_selected_lines(selection_before)\n                stripped_lines = [line.lstrip() for line in lines]\n                indents = [len(line) - len(line.lstrip()) for line in lines]\n                if all(\n                    [\n                        line.startswith(self.inline_comment_marker)\n                        for line in stripped_lines\n                    ]\n                ):\n                    no_comment_lines = [\n                        line[len(self.inline_comment_marker) :].lstrip()\n                        for line in stripped_lines\n                    ]\n                    self.lines[first.lno : last.lno + 1] = [\n                        f\"{' ' * indent}{line}\"\n                        for indent, line in zip(indents, no_comment_lines)\n                    ]\n                    self.move_cursor(\n                        self.cursor.pos - len(self.inline_comment_marker) - 1,\n                        self.cursor.lno,\n                    )\n                    if selection_before:\n                        self.move_selection_anchor(\n                            selection_before.pos - len(self.inline_comment_marker) - 1,\n                            selection_before.lno,\n                        )\n                else:\n                    self.lines[first.lno : last.lno + 1] = [\n                        f\"{' ' * indent}{self.inline_comment_marker} {stripped_line}\"\n                        for indent, stripped_line in zip(indents, stripped_lines)\n                    ]\n                    self.move_cursor(\n                        self.cursor.pos + len(self.inline_comment_marker) + 1,\n                        self.cursor.lno,\n                    )\n                    if selection_before:\n                        self.move_selection_anchor(\n                            selection_before.pos + len(self.inline_comment_marker) + 1,\n                            selection_before.lno,\n                        )\n        elif event.key in (\"ctrl+c\", \"ctrl+x\"):\n            event.stop()\n            if selection_before:\n                lines, first, last = self._get_selected_lines(selection_before)\n            else:  # no selection, copy whole line\n                lines, first, last = (\n                    [self.lines[self.cursor.lno], \"\"],\n                    Cursor(self.cursor.lno, 0),\n                    Cursor(self.cursor.lno, len(self.lines[self.cursor.lno])),\n                )\n            lines[-1] = lines[-1][: last.pos]\n            lines[0] = lines[0][first.pos :]\n            self.clipboard = lines.copy()\n            if self.use_system_clipboard:\n                try:\n                    pyperclip.copy(serialize_lines(self.clipboard))\n                except pyperclip.PyperclipException:\n                    # no system clipboard; common in CI runners\n                    pass\n            self.log(f\"copied to clipboard: {self.clipboard}\")\n            if event.key == \"ctrl+x\":\n                self._delete_selection(first, last)\n                new_lno = min(first.lno, len(self.lines) - 1)\n                self.cursor = Cursor(\n                    new_lno, min(first.pos, len(self.lines[new_lno]) - 1)\n                )\n        elif event.key in (\"ctrl+u\", \"ctrl+v\"):\n            event.stop()\n            self._insert_clipboard_at_selection(selection_before, self.cursor)\n        elif event.key == \"tab\":\n            event.stop()\n            lines, first, last = self._get_selected_lines(selection_before)\n            # in some cases, selections are replaced with four spaces\n            if first.lno == last.lno and (\n                first.pos == last.pos\n                or first.pos != 0\n                or last.pos != len(self.lines[self.cursor.lno]) - 1\n            ):\n                self._delete_selection(first, last)\n                indent = TAB_SIZE - first.pos % TAB_SIZE\n                self._insert_character_at_cursor(\" \" * indent, first)\n                self.cursor = Cursor(lno=first.lno, pos=first.pos + indent)\n            # usually, selected lines are prepended with four-ish spaces\n            else:\n                self._indent_selection(selection_before, self.cursor, kind=\"indent\")\n        elif event.key == \"shift+tab\":\n            event.stop()\n            self._indent_selection(selection_before, self.cursor, kind=\"dedent\")\n        elif event.key == \"enter\":\n            event.stop()\n            old_lines, first, last = self._get_selected_lines(selection_before)\n            head = f\"{old_lines[0][:first.pos]} \"\n            tail = f\"{old_lines[-1][last.pos:]}\"\n            if old_lines[0].isspace():\n                indent = 0\n            else:\n                indent = len(old_lines[0]) - len(old_lines[0].lstrip())\n\n            char_before = self._get_character_before_cursor(first)\n            if char_before in BRACKETS and BRACKETS[\n                char_before\n            ] == self._get_character_at_cursor(last):\n                new_indent = indent + TAB_SIZE - (indent % TAB_SIZE)\n                self.lines[first.lno : last.lno + 1] = [\n                    head,\n                    f\"{' ' * new_indent} \",\n                    f\"{' ' * indent}{tail.lstrip()}\",\n                ]\n                self.cursor = Cursor(first.lno + 1, new_indent)\n            else:\n                self.lines[first.lno : last.lno + 1] = [\n                    head,\n                    f\"{' ' * indent}{tail.lstrip() or ' '}\",\n                ]\n                self.cursor = Cursor(first.lno + 1, min(first.pos, indent))\n        elif event.key == \"delete\":\n            event.stop()\n            if selection_before is None:\n                anchor = self.cursor\n                cursor = handle_arrow(\"right\", self.lines, self.cursor)\n            else:\n                anchor = selection_before\n                cursor = self.cursor\n            self._delete_selection(anchor, cursor)\n        elif event.key == \"backspace\":\n            event.stop()\n            if selection_before is None:\n                anchor = self.cursor\n                cursor = handle_arrow(\"left\", self.lines, self.cursor)\n            else:\n                anchor = selection_before\n                cursor = self.cursor\n            self._delete_selection(anchor, cursor)\n\n        elif event.is_printable:\n            event.stop()\n            assert event.character is not None\n            if selection_before is not None:\n                self._delete_selection(selection_before, self.cursor)\n            self._insert_character_at_cursor(event.character, self.cursor)\n            self.cursor = Cursor(\n                lno=self.cursor.lno, pos=self.cursor.pos + len(event.character)\n            )\n\n        self.update(self._content)\n\n    def watch_cursor(self) -> None:\n        self._scroll_to_cursor()\n\n    def watch_language(self, language: str) -> None:\n        self.inline_comment_marker = INLINE_MARKERS.get(language)\n\n    @property\n    def _content(self) -> RenderableType:\n        syntax = Syntax(\n            \"\\n\".join(self.lines),\n            lexer=self.language,\n            theme=self.theme,\n        )\n        if self.cursor_visible:\n            syntax.stylize_range(\n                \"reverse\",\n                # rows are 1-indexed\n                (self.cursor.lno + 1, self.cursor.pos),\n                (self.cursor.lno + 1, self.cursor.pos + 1),\n            )\n        if self.selection_anchor is not None:\n            first = min(self.selection_anchor, self.cursor)\n            second = max(self.selection_anchor, self.cursor)\n            selection_style = Style(\n                bgcolor=self.theme_colors.selection_bgcolor.rich_color\n            )\n            syntax.stylize_range(\n                selection_style,\n                # rows are 1-indexed\n                (first.lno + 1, first.pos),\n                (second.lno + 1, second.pos),\n            )\n        return syntax\n\n    def _scroll_to_cursor(self) -> None:\n        self.post_message(TextAreaCursorMoved(self.cursor.pos, self.cursor.lno))\n\n    def _visible_height(self) -> int:\n        parent = self.parent\n        assert isinstance(parent, TextContainer)\n        return parent.window_region.height\n\n    def _toggle_cursor(self) -> None:\n        self.cursor_visible = not self.cursor_visible\n        self.update(self._content)\n\n    def _get_selected_lines(\n        self,\n        maybe_anchor: Union[Cursor, None],\n        maybe_cursor: Union[Cursor, None] = None,\n    ) -> Tuple[List[str], Cursor, Cursor]:\n        \"\"\"\n        Returns a tuple of:\n         - the lines between (inclusive) the optional selection anchor and the cursor,\n         - the first of either the cursor or anchor\n         - the last of either the cursor or anchor\n        \"\"\"\n        cursor = maybe_cursor or self.cursor\n        anchor = maybe_anchor or cursor\n        first = min(anchor, cursor)\n        last = max(anchor, cursor)\n        return self.lines[first.lno : last.lno + 1], first, last\n\n    def _insert_character_at_cursor(self, character: str, cursor: Cursor) -> None:\n        line = self.lines[cursor.lno]\n        new_line = f\"{line[:cursor.pos]}{character}{line[cursor.pos:]}\"\n        self.lines[cursor.lno] = new_line\n\n    def _insert_characters_around_selection(\n        self, character: str, anchor: Cursor, cursor: Cursor\n    ) -> None:\n        first = min(anchor, cursor)\n        last = max(anchor, cursor)\n        self._insert_character_at_cursor(character, first)\n        if first.lno == last.lno:\n            self.cursor = Cursor(lno=last.lno, pos=last.pos + len(character))\n        else:\n            self.cursor = last\n        self._insert_character_at_cursor(CLOSERS[character], self.cursor)\n\n    def _insert_closed_character_at_cursor(\n        self, character: str, cursor: Cursor\n    ) -> None:\n        if self._get_character_at_cursor(cursor) == character:\n            self.cursor = Cursor(cursor.lno, cursor.pos + 1)\n        else:\n            prev = self._get_character_before_cursor(cursor)\n            self._insert_character_at_cursor(character, cursor)\n            self.cursor = Cursor(cursor.lno, cursor.pos + len(character))\n            if (\n                character in CLOSERS\n                and self.cursor.pos == len(self.lines[self.cursor.lno]) - 1\n                and (prev is None or prev == \" \" or character in BRACKETS)\n            ):\n                self._insert_character_at_cursor(CLOSERS[character], self.cursor)\n\n    def _delete_selection(self, anchor: Cursor, cursor: Cursor) -> None:\n        old_lines, first, last = self._get_selected_lines(anchor, maybe_cursor=cursor)\n        head = f\"{old_lines[0][:first.pos]}\"\n        tail = f\"{old_lines[-1][last.pos:]}\"\n        if new_line := f\"{head}{tail}\":\n            self.lines[first.lno : last.lno + 1] = [new_line]\n        else:  # empty str, no line-ending space, delete whole line\n            self.lines[first.lno : last.lno + 1] = []\n            if not self.lines:\n                self.lines = [\" \"]\n        self.cursor = Cursor(first.lno, first.pos)\n\n    def _indent_selection(\n        self, anchor: Union[Cursor, None], cursor: Cursor, kind: str\n    ) -> None:\n        assert kind in (\"indent\", \"dedent\")\n        rounder, offset = (ceil, -1) if kind == \"dedent\" else (floor, 1)\n\n        lines, first, last = self._get_selected_lines(anchor, cursor)\n        leading_spaces = [(len(line) - len(line.lstrip())) for line in lines]\n        leading_tabs = [rounder(space / TAB_SIZE) for space in leading_spaces]\n        new_lines = [\n            f\"{' ' * TAB_SIZE * max(0, indent+offset)}{line.lstrip()}\"\n            for line, indent in zip(lines, leading_tabs)\n        ]\n        self.lines[first.lno : last.lno + 1] = new_lines\n        if anchor:\n            change_at_anchor_line = len(new_lines[anchor.lno - first.lno]) - len(\n                lines[anchor.lno - first.lno]\n            )\n            self.selection_anchor = (\n                anchor\n                if anchor.pos == 0\n                else Cursor(\n                    anchor.lno,\n                    anchor.pos + change_at_anchor_line,\n                )\n            )\n        change_at_cursor = len(new_lines[cursor.lno - first.lno]) - len(\n            lines[cursor.lno - first.lno]\n        )\n        self.cursor = (\n            cursor\n            if cursor.pos == 0\n            else Cursor(cursor.lno, cursor.pos + change_at_cursor)\n        )\n\n    def _insert_clipboard_at_selection(\n        self, anchor: Union[Cursor, None], cursor: Cursor\n    ) -> None:\n        if self.use_system_clipboard:\n            try:\n                sys_clipboard = pyperclip.paste()\n            except pyperclip.PyperclipException:\n                # no system clipboard; common in CI runners\n                pass\n            else:\n                self.clipboard = deserialize_lines(sys_clipboard, trim=True)\n        if anchor:\n            self._delete_selection(anchor, cursor)\n            cursor = self.cursor\n        head = self.lines[cursor.lno][: cursor.pos]\n        tail = self.lines[cursor.lno][cursor.pos :]\n        if (clip_len := len(self.clipboard)) != 0:\n            new_lines = self.clipboard.copy()\n            new_lines[0] = f\"{head}{new_lines[0]}\"\n            new_lines[-1] = f\"{new_lines[-1]}{tail}\"\n            self.lines[cursor.lno : cursor.lno + 1] = new_lines\n            self.cursor = Cursor(\n                cursor.lno + clip_len - 1,\n                len(self.lines[cursor.lno + clip_len - 1]) - len(tail),\n            )\n\n    def _get_character_at_cursor(self, cursor: Cursor) -> str:\n        return self.lines[cursor.lno][cursor.pos]\n\n    def _get_character_before_cursor(self, cursor: Cursor) -> Union[str, None]:\n        if self.cursor.pos == 0:\n            return None\n        else:\n            return self.lines[cursor.lno][cursor.pos - 1]\n\n    def move_cursor(self, x: int, y: int) -> None:\n        self.cursor = self._get_valid_cursor(x, y)\n        self.update(self._content)\n\n    def move_selection_anchor(self, x: int, y: int) -> None:\n        self.selection_anchor = self._get_valid_cursor(x, y)\n        self.update(self._content)\n\n    def _get_valid_cursor(self, x: int, y: int) -> Cursor:\n        max_y = len(self.lines) - 1\n        safe_y = max(0, min(max_y, y))\n        max_x = len(self.lines[safe_y]) - 1\n        safe_x = max(0, min(max_x, x))\n        return Cursor(lno=safe_y, pos=safe_x)\n\n    def clear_selection_anchor(self) -> None:\n        self.selection_anchor = None\n        self.update(self._content)", "\n\nclass TextArea(Widget, can_focus=True, can_focus_children=False):\n    \"\"\"\n    A Widget that presents a feature-rich, multiline text editor interface.\n\n    Attributes:\n        text (str): The contents of the TextArea\n        language (str): Must be the short name of a Pygments lexer\n            (https://pygments.org/docs/lexers/), e.g., \"python\", \"sql\", \"as3\".\n        theme (str): Must be name of a Pygments style (https://pygments.org/styles/),\n            e.g., \"bw\", \"github-dark\", \"solarized-light\".\n        theme_colors (WidgetColors): The colors extracted from the theme.\n    \"\"\"\n\n    DEFAULT_CSS = \"\"\"\n    #validation_label {\n        color: $error;\n        text-style: italic;\n        margin: 0 0 0 3;\n    }\n    \"\"\"\n\n    BINDINGS = [\n        Binding(\"ctrl+s\", \"save\", \"Save Query\"),\n        Binding(\"ctrl+o\", \"load\", \"Open Query\"),\n        Binding(\"ctrl+q\", \"quit\", \"Quit\"),\n    ]\n\n    def __init__(\n        self,\n        *children: Widget,\n        name: Union[str, None] = None,\n        id: Union[str, None] = None,\n        classes: Union[str, None] = None,\n        disabled: bool = False,\n        language: Union[str, None] = None,\n        theme: str = \"monokai\",\n        use_system_clipboard: bool = True,\n    ) -> None:\n        \"\"\"\n        Initializes an instance of a TextArea.\n\n        Args:\n            (see also textual.widget.Widget)\n            language (str): Must be the short name of a Pygments lexer\n                (https://pygments.org/docs/lexers/), e.g., \"python\", \"sql\", \"as3\".\n            theme (str): Must be name of a Pygments style (https://pygments.org/styles/),\n                e.g., \"bw\", \"github-dark\", \"solarized-light\".\n        \"\"\"\n        super().__init__(\n            *children, name=name, id=id, classes=classes, disabled=disabled\n        )\n        self._language = language\n        self.theme = theme\n        self.theme_colors = WidgetColors.from_theme(self.theme)\n        self.use_system_clipboard = use_system_clipboard\n\n    @property\n    def text(self) -> str:\n        \"\"\"\n        Returns:\n            (str) The contents of the TextArea.\n        \"\"\"\n        return serialize_lines(self.text_input.lines)\n\n    @text.setter\n    def text(self, contents: str) -> None:\n        \"\"\"\n        Args:\n            contents (str): A string (optionally containing newlines) to\n                set the contents of the TextArea equal to.\n        \"\"\"\n        self.text_input.move_cursor(0, 0)\n        self.text_input.lines = deserialize_lines(contents)\n\n    @property\n    def selected_text(self) -> str:\n        \"\"\"\n        Returns:\n            str: The contents of the TextArea between the selection\n            anchor and the cursor. Returns an empty string if the\n            selection anchor is not set.\n        \"\"\"\n        anchor = self.text_input.selection_anchor\n        if anchor is None:\n            return \"\"\n        else:\n            lines, first, last = self.text_input._get_selected_lines(anchor)\n            lines[-1] = lines[-1][: last.pos]\n            lines[0] = lines[0][first.pos :]\n            return serialize_lines(lines)\n\n    @property\n    def cursor(self) -> Cursor:\n        \"\"\"\n        Returns\n            Cursor: The location of the cursor in the TextInput\n        \"\"\"\n        return self.text_input.cursor\n\n    @cursor.setter\n    def cursor(self, cursor: Union[Cursor, Tuple[int, int]]) -> None:\n        \"\"\"\n        Args:\n            cursor (Union[Cursor, Tuple[int, int]]): The position (line number, pos)\n            to move the cursor to\n        \"\"\"\n        self.text_input.move_cursor(cursor[1], cursor[0])\n\n    @property\n    def selection_anchor(self) -> Union[Cursor, None]:\n        \"\"\"\n        Returns\n            Cursor: The location of the selection anchor in the TextInput\n        \"\"\"\n        return self.text_input.selection_anchor\n\n    @selection_anchor.setter\n    def selection_anchor(self, cursor: Union[Cursor, Tuple[int, int], None]) -> None:\n        \"\"\"\n        Args:\n            cursor (Union[Cursor, Tuple[int, int], None]): The position\n            (line number, pos) to move the selection anchor to, or None\n            to clear the selection.\n        \"\"\"\n        if cursor is None:\n            self.text_input.clear_selection_anchor()\n        else:\n            self.text_input.move_selection_anchor(cursor[1], cursor[0])\n\n    @property\n    def language(self) -> Union[str, None]:\n        \"\"\"\n        Returns\n            str | None: The Pygments short name of the active language\n        \"\"\"\n        return self.text_input.language\n\n    @language.setter\n    def language(self, language: str) -> None:\n        \"\"\"\n        Args:\n            langage (str | None): The Pygments short name for the new language\n        \"\"\"\n        self.text_input.language = language\n\n    def compose(self) -> ComposeResult:\n        with TextContainer():\n            yield TextInput(\n                language=self._language,\n                theme=self.theme,\n                theme_colors=self.theme_colors,\n            )\n        with FooterContainer(theme_colors=self.theme_colors):\n            yield Label(\"\", id=\"validation_label\")\n\n    def on_mount(self) -> None:\n        self.styles.background = self.theme_colors.bgcolor\n        self.text_container = self.query_one(TextContainer)\n        self.text_input = self.query_one(TextInput)\n        self.footer = self.query_one(FooterContainer)\n\n    def on_focus(self) -> None:\n        self.text_input.focus()\n\n    def on_click(self) -> None:\n        self.text_input.focus()\n\n    def action_save(self) -> None:\n        self._clear_footer_input()\n        self._mount_footer_input(\"save\")\n\n    def action_load(self) -> None:\n        self._clear_footer_input()\n        self._mount_footer_input(\"open\")\n\n    def _clear_footer_input(self) -> None:\n        try:\n            self.footer.query_one(PathInput).remove()\n        except Exception:\n            pass\n        try:\n            self.footer.query_one(Label).update(\"\")\n        except Exception:\n            pass\n\n    def on_cancel_path_input(self) -> None:\n        self._clear_footer_input()\n\n    def _mount_footer_input(self, name: str) -> None:\n        if name == \"open\":\n            file_okay, dir_okay, must_exist = True, False, True\n        else:\n            file_okay, dir_okay, must_exist = True, False, False\n\n        input = PathInput(\n            id=f\"textarea__{name}_input\",\n            placeholder=f\"{name.capitalize()}: Enter file path OR press ESC to cancel\",\n            file_okay=file_okay,\n            dir_okay=dir_okay,\n            must_exist=must_exist,\n        )\n        input.styles.background = self.theme_colors.bgcolor\n        input.styles.border = \"round\", self.theme_colors.contrast_text_color\n        input.styles.color = self.theme_colors.contrast_text_color\n        self.footer.mount(input)\n        input.focus()\n\n    def on_text_area_cursor_moved(self, event: TextAreaCursorMoved) -> None:\n        \"\"\"\n        Scrolls the container so the cursor is visible.\n        \"\"\"\n        container = self.text_container\n        x_buffer = max(container.window_region.width // 6, 2)\n        y_buffer = max(container.window_region.height // 6, 2)\n        if event.cursor_x < container.window_region.x + x_buffer:  # scroll left\n            container.scroll_to(event.cursor_x - x_buffer, container.window_region.y)\n        elif (\n            event.cursor_x\n            >= container.window_region.x + container.window_region.width - x_buffer\n        ):  # scroll right\n            container.scroll_to(\n                event.cursor_x - container.window_region.width + x_buffer,\n                container.window_region.y,\n            )\n        if event.cursor_y < container.window_region.y + y_buffer:  # scroll up\n            container.scroll_to(container.window_region.x, event.cursor_y - y_buffer)\n        elif (\n            event.cursor_y\n            >= container.window_region.y + container.window_region.height - y_buffer\n        ):  # scroll down\n            container.scroll_to(\n                container.window_region.x,\n                event.cursor_y - container.window_region.height + y_buffer,\n            )\n        self.text_input.update(self.text_input._content)\n\n    def on_text_area_scroll_one(self, event: TextAreaScrollOne) -> None:\n        event.stop()\n        offset = 1 if event.direction == \"down\" else -1\n        self.text_container.scroll_to(\n            self.text_container.window_region.x,\n            self.text_container.window_region.y + offset,\n        )\n\n    def on_input_changed(self, message: Input.Changed) -> None:\n        if message.input.id in (\"textarea__save_input\", \"textarea__open_input\"):\n            label = self.footer.query_one(Label)\n            if message.validation_result and not message.validation_result.is_valid:\n                label.update(\";\".join(message.validation_result.failure_descriptions))\n            else:\n                label.update(\"\")\n\n    def on_input_submitted(self, message: Input.Submitted) -> None:\n        \"\"\"\n        Handle the submit event for the Save and Open modals.\n        \"\"\"\n        expanded_path = expanduser(message.input.value)\n        if message.input.id == \"textarea__save_input\":\n            try:\n                with open(expanded_path, \"w\") as f:\n                    f.write(self.text)\n            except OSError as e:\n                self.app.push_screen(\n                    ErrorModal(\n                        title=\"Save File Error\",\n                        header=(\n                            \"There was an error when attempting to save your file:\"\n                        ),\n                        error=e,\n                    )\n                )\n        elif message.input.id == \"textarea__open_input\":\n            try:\n                with open(expanded_path, \"r\") as f:\n                    contents = f.read()\n            except OSError as e:\n                self.app.push_screen(\n                    ErrorModal(\n                        title=\"Open File Error\",\n                        header=(\n                            \"There was an error when attempting to open your file:\"\n                        ),\n                        error=e,\n                    )\n                )\n            else:\n                self.text = contents\n        self._clear_footer_input()\n        self.text_input.update(self.text_input._content)\n        self.text_input.focus()", ""]}
{"filename": "src/textual_textarea/key_handlers.py", "chunked_list": ["import re\nfrom typing import List, NamedTuple\n\nfrom textual import log\nfrom textual.events import MouseEvent\n\nWWB = re.compile(r\"\\W*\\w+\\b\")\n\n\nclass Cursor(NamedTuple):\n    lno: int\n    pos: int\n\n    @classmethod\n    def from_mouse_event(cls, event: MouseEvent) -> \"Cursor\":\n        return Cursor(event.y, event.x - 1)", "\nclass Cursor(NamedTuple):\n    lno: int\n    pos: int\n\n    @classmethod\n    def from_mouse_event(cls, event: MouseEvent) -> \"Cursor\":\n        return Cursor(event.y, event.x - 1)\n\n\ndef handle_arrow(key: str, lines: List[str], cursor: Cursor) -> Cursor:\n    arrow = key.split(\"+\")[-1]\n    if \"ctrl\" in key:\n        assert arrow not in (\"up\", \"down\"), \"ctrl+up/down should be handled first\"\n        if arrow == \"right\":\n            return _handle_ctrl_right(lines, cursor)\n        else:  # if arrow == \"left\":\n            return _handle_ctrl_left(lines, cursor)\n    else:\n        if arrow == \"right\":\n            return _handle_right(lines, cursor)\n        elif arrow == \"left\":\n            return _handle_left(lines, cursor)\n        elif arrow == \"down\":\n            return _handle_down(lines, cursor)\n        else:  # arrow == \"up\":\n            return _handle_up(lines, cursor)", "\n\ndef handle_arrow(key: str, lines: List[str], cursor: Cursor) -> Cursor:\n    arrow = key.split(\"+\")[-1]\n    if \"ctrl\" in key:\n        assert arrow not in (\"up\", \"down\"), \"ctrl+up/down should be handled first\"\n        if arrow == \"right\":\n            return _handle_ctrl_right(lines, cursor)\n        else:  # if arrow == \"left\":\n            return _handle_ctrl_left(lines, cursor)\n    else:\n        if arrow == \"right\":\n            return _handle_right(lines, cursor)\n        elif arrow == \"left\":\n            return _handle_left(lines, cursor)\n        elif arrow == \"down\":\n            return _handle_down(lines, cursor)\n        else:  # arrow == \"up\":\n            return _handle_up(lines, cursor)", "\n\ndef _handle_right(lines: List[str], cursor: Cursor) -> Cursor:\n    max_x = len(lines[cursor.lno]) - 1\n    max_y = len(lines) - 1\n    if cursor.lno == max_y:\n        return Cursor(lno=max_y, pos=min(max_x, cursor.pos + 1))\n    elif cursor.pos == max_x:\n        return Cursor(lno=cursor.lno + 1, pos=0)\n    else:\n        return Cursor(lno=cursor.lno, pos=cursor.pos + 1)", "\n\ndef _handle_left(lines: List[str], cursor: Cursor) -> Cursor:\n    if cursor.lno == 0:\n        return Cursor(0, pos=max(0, cursor.pos - 1))\n    elif cursor.pos == 0:\n        return Cursor(\n            lno=cursor.lno - 1,\n            pos=len(lines[cursor.lno - 1]) - 1,\n        )\n    else:\n        return Cursor(lno=cursor.lno, pos=cursor.pos - 1)", "\n\ndef _handle_down(lines: List[str], cursor: Cursor) -> Cursor:\n    max_y = len(lines) - 1\n    if cursor.lno == max_y:\n        return Cursor(lno=max_y, pos=len(lines[cursor.lno]) - 1)\n    else:\n        max_x = len(lines[cursor.lno + 1]) - 1\n        return Cursor(lno=cursor.lno + 1, pos=min(max_x, cursor.pos))\n", "\n\ndef _handle_up(lines: List[str], cursor: Cursor) -> Cursor:\n    if cursor.lno == 0:\n        return Cursor(0, 0)\n    else:\n        max_x = len(lines[cursor.lno - 1]) - 1\n        return Cursor(lno=cursor.lno - 1, pos=min(max_x, cursor.pos))\n\n\ndef _handle_ctrl_right(lines: List[str], cursor: Cursor) -> Cursor:\n    max_x = len(lines[cursor.lno]) - 1\n    max_y = len(lines) - 1\n    if cursor.pos == max_x and cursor.lno == max_y:\n        return cursor\n    elif cursor.pos == max_x:\n        lno = cursor.lno + 1\n        pos = 0\n    else:\n        lno = cursor.lno\n        pos = cursor.pos\n\n    tail = lines[lno][pos:]\n    if match := WWB.match(tail):\n        return Cursor(lno=lno, pos=pos + match.span()[1])\n    else:  # no more words, move to end of line\n        return Cursor(lno=lno, pos=len(lines[lno]) - 1)", "\n\ndef _handle_ctrl_right(lines: List[str], cursor: Cursor) -> Cursor:\n    max_x = len(lines[cursor.lno]) - 1\n    max_y = len(lines) - 1\n    if cursor.pos == max_x and cursor.lno == max_y:\n        return cursor\n    elif cursor.pos == max_x:\n        lno = cursor.lno + 1\n        pos = 0\n    else:\n        lno = cursor.lno\n        pos = cursor.pos\n\n    tail = lines[lno][pos:]\n    if match := WWB.match(tail):\n        return Cursor(lno=lno, pos=pos + match.span()[1])\n    else:  # no more words, move to end of line\n        return Cursor(lno=lno, pos=len(lines[lno]) - 1)", "\n\ndef _handle_ctrl_left(lines: List[str], cursor: Cursor) -> Cursor:\n    if cursor.pos == 0 and cursor.lno == 0:\n        return cursor\n    elif cursor.pos == 0:\n        lno = cursor.lno - 1\n        pos = len(lines[lno]) - 1\n    else:\n        lno = cursor.lno\n        pos = cursor.pos\n\n    tail = lines[lno][:pos][::-1]\n    if match := WWB.match(tail):\n        log(match)\n        return Cursor(lno=lno, pos=pos - match.span()[1])\n    else:  # no more words, move to start of line\n        return Cursor(lno=lno, pos=0)", ""]}
{"filename": "src/textual_textarea/path_input.py", "chunked_list": ["import stat\nfrom pathlib import Path\nfrom typing import Union\n\nfrom rich.highlighter import Highlighter\nfrom textual.message import Message\nfrom textual.suggester import Suggester\nfrom textual.validation import ValidationResult, Validator\nfrom textual.widgets import Input\n", "from textual.widgets import Input\n\n\nclass CancelPathInput(Message):\n    pass\n\n\nclass PathSuggester(Suggester):\n    def __init__(self) -> None:\n        super().__init__(use_cache=True, case_sensitive=True)\n\n    async def get_suggestion(self, value: str) -> Union[str, None]:\n        try:\n            p = Path(value).expanduser()\n            matches = list(p.parent.glob(f\"{p.parts[-1]}*\"))\n            if len(matches) == 1:\n                return str(matches[0])\n            else:\n                return None\n        except Exception:\n            return None", "\n\nclass PathValidator(Validator):\n    def __init__(\n        self,\n        dir_okay: bool,\n        file_okay: bool,\n        must_exist: bool,\n        failure_description: str = \"Not a valid path.\",\n    ) -> None:\n        self.dir_okay = dir_okay\n        self.file_okay = file_okay\n        self.must_exist = must_exist\n        super().__init__(failure_description)\n\n    def validate(self, value: str) -> ValidationResult:\n        if self.dir_okay and self.file_okay and not self.must_exist:\n            return self.success()\n        try:\n            p = Path(value).expanduser().resolve()\n        except Exception:\n            return self.failure(\"Not a valid path.\")\n\n        try:\n            st = p.stat()\n        except FileNotFoundError:\n            if self.must_exist:\n                return self.failure(\"File or directory does not exist.\")\n            return self.success()\n\n        if not self.dir_okay and stat.S_ISDIR(st.st_mode):\n            return self.failure(\"Path cannot be a directory.\")\n        elif not self.file_okay and stat.S_ISREG(st.st_mode):\n            return self.failure(\"Path cannot be a regular file.\")\n\n        return self.success()", "\n\nclass PathInput(Input):\n    BINDINGS = [\n        (\"escape\", \"cancel\", \"Cancel\"),\n        (\"tab\", \"complete\", \"Accept Completion\"),\n    ]\n\n    def __init__(\n        self,\n        value: Union[str, None] = None,\n        placeholder: str = \"\",\n        highlighter: Union[Highlighter, None] = None,\n        password: bool = False,\n        *,\n        name: Union[str, None] = None,\n        id: Union[str, None] = None,\n        classes: Union[str, None] = None,\n        disabled: bool = False,\n        dir_okay: bool = True,\n        file_okay: bool = True,\n        must_exist: bool = False,\n        tab_advances_focus: bool = False,\n    ) -> None:\n        self.tab_advances_focus = tab_advances_focus\n        super().__init__(\n            value,\n            placeholder,\n            highlighter,\n            password,\n            suggester=PathSuggester(),\n            validators=PathValidator(dir_okay, file_okay, must_exist),\n            name=name,\n            id=id,\n            classes=classes,\n            disabled=disabled,\n        )\n\n    def action_cancel(self) -> None:\n        self.post_message(CancelPathInput())\n\n    def action_complete(self) -> None:\n        if self._suggestion and self._suggestion != self.value:\n            self.action_cursor_right()\n        elif self.tab_advances_focus:\n            self.app.action_focus_next()", ""]}
{"filename": "src/textual_textarea/serde.py", "chunked_list": ["from typing import List\n\n\ndef serialize_lines(lines: List[str]) -> str:\n    return \"\\n\".join([line.rstrip() for line in lines])\n\n\ndef deserialize_lines(text: str, trim: bool = False) -> List[str]:\n    if text:\n        lines = [f\"{line} \" for line in text.splitlines()]\n        if text.endswith((\"\\n\", \"\\r\", \"\\r\\n\")):\n            lines.append(\" \")\n    else:\n        lines = [\" \"]\n\n    if trim:\n        lines[-1] = lines[-1].rstrip()\n\n    return lines", ""]}
{"filename": "src/textual_textarea/messages.py", "chunked_list": ["from textual.message import Message\n\n\nclass TextAreaCursorMoved(Message, bubble=True):\n    \"\"\"Posted when the cursor moves\n\n    Attributes:\n        cursor_x: The x position of the cursor\n        cursor_y: The y position (line number)\n    \"\"\"\n\n    def __init__(self, cursor_x: int, cursor_y: int) -> None:\n        super().__init__()\n        self.cursor_x = cursor_x\n        self.cursor_y = cursor_y", "\n\nclass TextAreaScrollOne(Message, bubble=True):\n    \"\"\"\n    Posted to get parent container to scroll one in a direction\n    \"\"\"\n\n    def __init__(self, direction: str) -> None:\n        super().__init__()\n        assert direction in (\"up\", \"down\")\n        self.direction = direction", ""]}
