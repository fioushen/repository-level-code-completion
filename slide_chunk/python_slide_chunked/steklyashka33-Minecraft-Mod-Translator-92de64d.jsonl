{"filename": "example_libraries.py", "chunked_list": ["from CTkScrollableDropdown import CTkScrollableDropdown\nimport customtkinter\n\nroot = customtkinter.CTk()\n\ncustomtkinter.CTkLabel(root, text=\"Different Dropdown Styles\").pack(pady=5)\n\n# Some option list\nvalues = [\"python\",\"tkinter\",\"customtkinter\",\"widgets\",\n          \"options\",\"menu\",\"combobox\",\"dropdown\",\"search\"]", "values = [\"python\",\"tkinter\",\"customtkinter\",\"widgets\",\n          \"options\",\"menu\",\"combobox\",\"dropdown\",\"search\"]\n\n# Attach to OptionMenu \noptionmenu = customtkinter.CTkOptionMenu(root, width=240)\noptionmenu.pack(fill=\"x\", padx=10, pady=10)\n\nCTkScrollableDropdown(optionmenu, values=values)\n\n# Attach to Combobox", "\n# Attach to Combobox\ncombobox = customtkinter.CTkComboBox(root, width=240)\ncombobox.pack(fill=\"x\", padx=10, pady=10)\n\nCTkScrollableDropdown(combobox, values=values, justify=\"left\", button_color=\"transparent\")\n\n# Attach to Entry\ncustomtkinter.CTkLabel(root, text=\"Live Search Values\").pack()\n", "customtkinter.CTkLabel(root, text=\"Live Search Values\").pack()\n\nentry = customtkinter.CTkEntry(root, width=240)\nentry.pack(fill=\"x\", padx=10, pady=10)\n\nCTkScrollableDropdown(entry, values=values, command=lambda e: entry.insert(1, e),\n                      autocomplete=True) # Using autocomplete\n\n# Attach to Button \nbutton = customtkinter.CTkButton(root, text=\"choose options\", width=240)", "# Attach to Button \nbutton = customtkinter.CTkButton(root, text=\"choose options\", width=240)\nbutton.pack(fill=\"x\", padx=10, pady=10)\n\nCTkScrollableDropdown(button, values=values, height=270, resize=False, button_height=30,\n                      scrollbar=False, command=lambda e: button.configure(text=e))\n\nroot.mainloop()\n", ""]}
{"filename": "APP.py", "chunked_list": ["from customtkinter import *\nfrom utils import *\nfrom pages import *\nfrom typing import Union\nfrom CTkMessagebox import CTkMessagebox\nfrom PIL import Image\nimport os\n\n\nclass App(CTk):\n    def __init__(self):\n        super().__init__()\n\n        self.main_folder = os.path.dirname(os.path.abspath(__file__))\n        self.data = GetData(self.main_folder)\n        \n        self.config, self.user_config, _, i = self.data.get()\n\n        # get supported_languages\n        # print(dict( [[a[\"google_code\"], a[\"mc_code\"]] for a in i.values()] ))\n\n        # \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0433\u043b\u0430\u0432\u043d\u043e\u0433\u043e \u043e\u043a\u043d\u0430\n        self.title( self.config.title ) # type: ignore\n        window_width = 640\n        window_height = 480\n\n        set_appearance_mode(self.user_config.appearance_mode)  # Modes: \"System\" (standard), \"Dark\", \"Light\" # type: ignore\n        set_default_color_theme(\"blue\")  # Themes: \"blue\" (standard), \"green\", \"dark-blue\")\n\n        screen_width = self.winfo_screenwidth()\n        screen_height = self.winfo_screenheight()\n\n        x_cordinate = (screen_width - window_width)//2\n        y_cordinate = (screen_height - window_height)//2\n        self.geometry(f\"{window_width}x{window_height}+{x_cordinate}+{y_cordinate}\")\n        self.resizable(False, False)\n        \n\t\t# configure grid layout (3x4)\n        self.grid_columnconfigure(0, weight=3, uniform=\"fred\")\n        self.grid_columnconfigure(1, weight=7, uniform=\"fred\")\n        self.grid_rowconfigure(0, weight=1, uniform=\"fred\")\n\n        '''image_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), \"images\")\n        self.image = CTkImage(Image.open(os.path.join(image_path, \"light_conductor.png\")), size=(26, 26))'''\n\n        pages = (Page1, Page2, Page3)\n        self.pages = (i for i in pages)\n        self.current_page = next(self.pages)\n        # self.current_page = next(self.pages)\n\n        self.build_sidebar()\n        self.build_main()\n\n    def build_sidebar(self):\n        \"\"\"creates a sidebar.\"\"\"\n        self.sidebar_frame = Sidebar(self, self.data, self.update_language, self.update_appearance_mode, corner_radius=0)\n        self.sidebar_frame.grid(row=0, column=0, sticky=\"nsew\")\n\n    def build_main(self, session: Union[SessionData, None] = None):\n        self.main_frame = self.current_page(self, data=self.data, session=session, command=self.next_page) # type: ignore\n        self.main_frame.grid(row=0, column=1, padx=20, pady=20, sticky=\"nsew\")\n\n        \"\"\"\n        settings_image = CTkImage(light_image=Image.open(\"light_settings.png\"),\n                             dark_image=Image.open(\"dark_settings.png\"),\n                             size=(25, 25))\n\n        settings_button = CTkButton(self, text=\"\", image=settings_image, command=settings_button_event)\n        settings_button.grid(row=0, column=2, padx=5, pady=5, sticky=\"nsew\")\"\"\"\n    \n    def next_page(self, session: SessionData):\n        try:\n            self.main_frame.destroy()\n            self.current_page = next(self.pages)\n            self.build_main(session)\n        except StopIteration:\n            pass\n    \n    def update_language(self, language: str):\n        if self.user_config.interface_language == language: # type: ignore\n            return None\n        \n        self.user_config.interface_language = language # type: ignore\n        UserConfigManager(self.main_folder).save_user_config(vars(self.user_config))\n\n        session = self.main_frame.get_session_data()\n\n        self.sidebar_frame.destroy()\n        self.main_frame.destroy()\n        self.build_sidebar()\n        self.build_main(session)\n\n    def update_appearance_mode(self, new_appearance_mode: str):\n        if new_appearance_mode == self.user_config.appearance_mode: # type: ignore\n            return \n        \n        self.user_config.appearance_mode = new_appearance_mode # type: ignore\n        UserConfigManager(self.main_folder).save_user_config(vars(self.user_config))\n        \n        set_appearance_mode(new_appearance_mode)\n        \n    def run(self):\n        # \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u0437\u0430\u043f\u0443\u0441\u043a\u0430 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f\n        self.mainloop()", "\nclass App(CTk):\n    def __init__(self):\n        super().__init__()\n\n        self.main_folder = os.path.dirname(os.path.abspath(__file__))\n        self.data = GetData(self.main_folder)\n        \n        self.config, self.user_config, _, i = self.data.get()\n\n        # get supported_languages\n        # print(dict( [[a[\"google_code\"], a[\"mc_code\"]] for a in i.values()] ))\n\n        # \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0433\u043b\u0430\u0432\u043d\u043e\u0433\u043e \u043e\u043a\u043d\u0430\n        self.title( self.config.title ) # type: ignore\n        window_width = 640\n        window_height = 480\n\n        set_appearance_mode(self.user_config.appearance_mode)  # Modes: \"System\" (standard), \"Dark\", \"Light\" # type: ignore\n        set_default_color_theme(\"blue\")  # Themes: \"blue\" (standard), \"green\", \"dark-blue\")\n\n        screen_width = self.winfo_screenwidth()\n        screen_height = self.winfo_screenheight()\n\n        x_cordinate = (screen_width - window_width)//2\n        y_cordinate = (screen_height - window_height)//2\n        self.geometry(f\"{window_width}x{window_height}+{x_cordinate}+{y_cordinate}\")\n        self.resizable(False, False)\n        \n\t\t# configure grid layout (3x4)\n        self.grid_columnconfigure(0, weight=3, uniform=\"fred\")\n        self.grid_columnconfigure(1, weight=7, uniform=\"fred\")\n        self.grid_rowconfigure(0, weight=1, uniform=\"fred\")\n\n        '''image_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), \"images\")\n        self.image = CTkImage(Image.open(os.path.join(image_path, \"light_conductor.png\")), size=(26, 26))'''\n\n        pages = (Page1, Page2, Page3)\n        self.pages = (i for i in pages)\n        self.current_page = next(self.pages)\n        # self.current_page = next(self.pages)\n\n        self.build_sidebar()\n        self.build_main()\n\n    def build_sidebar(self):\n        \"\"\"creates a sidebar.\"\"\"\n        self.sidebar_frame = Sidebar(self, self.data, self.update_language, self.update_appearance_mode, corner_radius=0)\n        self.sidebar_frame.grid(row=0, column=0, sticky=\"nsew\")\n\n    def build_main(self, session: Union[SessionData, None] = None):\n        self.main_frame = self.current_page(self, data=self.data, session=session, command=self.next_page) # type: ignore\n        self.main_frame.grid(row=0, column=1, padx=20, pady=20, sticky=\"nsew\")\n\n        \"\"\"\n        settings_image = CTkImage(light_image=Image.open(\"light_settings.png\"),\n                             dark_image=Image.open(\"dark_settings.png\"),\n                             size=(25, 25))\n\n        settings_button = CTkButton(self, text=\"\", image=settings_image, command=settings_button_event)\n        settings_button.grid(row=0, column=2, padx=5, pady=5, sticky=\"nsew\")\"\"\"\n    \n    def next_page(self, session: SessionData):\n        try:\n            self.main_frame.destroy()\n            self.current_page = next(self.pages)\n            self.build_main(session)\n        except StopIteration:\n            pass\n    \n    def update_language(self, language: str):\n        if self.user_config.interface_language == language: # type: ignore\n            return None\n        \n        self.user_config.interface_language = language # type: ignore\n        UserConfigManager(self.main_folder).save_user_config(vars(self.user_config))\n\n        session = self.main_frame.get_session_data()\n\n        self.sidebar_frame.destroy()\n        self.main_frame.destroy()\n        self.build_sidebar()\n        self.build_main(session)\n\n    def update_appearance_mode(self, new_appearance_mode: str):\n        if new_appearance_mode == self.user_config.appearance_mode: # type: ignore\n            return \n        \n        self.user_config.appearance_mode = new_appearance_mode # type: ignore\n        UserConfigManager(self.main_folder).save_user_config(vars(self.user_config))\n        \n        set_appearance_mode(new_appearance_mode)\n        \n    def run(self):\n        # \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u0437\u0430\u043f\u0443\u0441\u043a\u0430 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f\n        self.mainloop()", "\n\n\nif __name__ == \"__main__\":\n    app = App()\n    app.run()"]}
{"filename": "pages/texthandler.py", "chunked_list": ["import logging\nimport tkinter\n\nclass TextHandler(logging.Handler):\n    # This class allows you to log to a Tkinter Text or ScrolledText widget\n\n    def __init__(self, text):\n        # run the regular Handler __init__\n        logging.Handler.__init__(self)\n        # Store a reference to the Text it will log to\n        self.text = text\n\n    def emit(self, record):\n        msg = self.format(record)\n\n        def append():\n            self.text.configure(state='normal')\n            self.text.insert(tkinter.END, msg + '\\n')\n            self.text.configure(state='disabled')\n            # Autoscroll to the bottom\n            self.text.yview(tkinter.END)\n        # This is necessary because we can't modify the Text from other threads\n        self.text.after(0, append)"]}
{"filename": "pages/folder_dialog_combobox.py", "chunked_list": ["import tkinter\nfrom typing import Optional, Tuple, Union, Callable\nfrom customtkinter import *\n\nclass FolderDialogComboBox(CTkComboBox):\n    def __init__(self,\n                 master: any,\n                 width: int = 140,\n                 height: int = 28,\n                 corner_radius: Optional[int] = None,\n                 border_width: Optional[int] = None,\n\n                 bg_color: Union[str, Tuple[str, str]] = \"transparent\",\n                 fg_color: Optional[Union[str, Tuple[str, str]]] = None,\n                 border_color: Optional[Union[str, Tuple[str, str]]] = None,\n                 button_color: Optional[Union[str, Tuple[str, str]]] = None,\n                 button_hover_color: Optional[Union[str, Tuple[str, str]]] = None,\n                 text_color: Optional[Union[str, Tuple[str, str]]] = None,\n                 text_color_disabled: Optional[Union[str, Tuple[str, str]]] = None,\n\n                 font: Optional[Union[tuple, CTkFont]] = None,\n                 state: str = tkinter.NORMAL,\n                 hover: bool = True,\n                 variable: Union[tkinter.Variable, None] = None,\n                 command: Union[Callable[[str], None], None] = None,\n                 justify: str = \"left\",\n                 **kwargs):\n        super().__init__(master, width, height, corner_radius, border_width, \n                         bg_color, fg_color, border_color, button_color, button_hover_color, \n                         text_color = text_color, \n                         text_color_disabled = text_color_disabled, \n                         font = font, \n                         state = state, \n                         hover = hover, \n                         variable = variable, \n                         command = command, \n                         justify = justify, **kwargs)\n    \n    def _open_dropdown_menu(self):\n        self._choose_folder()\n\n    def _choose_folder(self):\n        \"\"\"function for calling the folder selection dialog.\"\"\"\n        \n        folder_path = filedialog.askdirectory()\n        if folder_path:\n            self._dropdown_callback(folder_path)"]}
{"filename": "pages/page1.py", "chunked_list": ["from typing import Any, Optional, Tuple, Union, Callable\nfrom threading import Timer\nfrom customtkinter import *\nfrom utils import *\nfrom .folder_dialog_combobox import FolderDialogComboBox\nfrom .session_data import SessionData\n\nclass Page1(CTkFrame):\n    def __init__(self,\n                 master: Any,\n                 data: GetData,\n                 width: int = 200,\n                 height: int = 200,\n                 corner_radius: Optional[Union[int, str]] = None,\n                 border_width: Optional[Union[int, str]] = None,\n\n                 bg_color: Union[str, Tuple[str, str]] = \"transparent\",\n                 fg_color: Optional[Union[str, Tuple[str, str]]] = None,\n                 border_color: Optional[Union[str, Tuple[str, str]]] = None,\n\n                 background_corner_colors: Union[Tuple[Union[str, Tuple[str, str]]], None] = None,\n                 overwrite_preferred_drawing_method: Union[str, None] = None,\n                 session: Union[SessionData, None] = None,\n                 command: Union[Callable[[SessionData], None], None] = None,\n                 **kwargs):\n        super().__init__(master, width, height, corner_radius, border_width, bg_color, fg_color, border_color, background_corner_colors, overwrite_preferred_drawing_method, **kwargs)\n        \n        self._command = command\n\n        self.grid_columnconfigure(0, weight=1, uniform=\"fred\")\n        self.grid_rowconfigure((1, 2, 3, 4), weight=6, uniform=\"fred\") # type: ignore\n        self.grid_rowconfigure(5, weight=8, uniform=\"fred\")\n        self.grid_rowconfigure((6, 7, 8), weight=6, uniform=\"fred\") # type: ignore\n        self.grid_rowconfigure((0, 9), weight=10, uniform=\"fred\") # type: ignore\n\n        _, self.user_config, self.lang, self.supported_languages = data.get()\n        self.main_folder = data.get_main_folder()\n\n        # \n        header_font = CTkFont(\"Arial\", size=38, weight=\"bold\")\n        self.main_label = CTkLabel(self, text=self.lang.data_entry, font=header_font) # type: ignore\n        self.main_label.grid(row=0, column=0, sticky=\"s\")\n\n        combobox_font = CTkFont(\"Arial\", size=14)\n        label_font = CTkFont(\"Arial\", size=18)\n        widget_width = 210\n        widget_height = 36\n\n        # \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043f\u043e\u0434\u043f\u0438\u0441\u0438 \u043a \u0432\u0432\u043e\u0434\u0443 \u043f\u0443\u0442\u0438 \u043a \u043f\u0430\u043f\u043a\u0435 \u0441 \u043c\u043e\u0434\u0430\u043c\u0438\n        path_to_mods_font = CTkFont(\"Arial\", size=14)\n        entry_path_to_mods_label = CTkLabel(self, text=self.lang.path_to_mods, font=path_to_mods_font) # type: ignore\n        entry_path_to_mods_label.grid(row=1, column=0, sticky=\"s\")\n        # \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 CTkComboBox \u0434\u043b\u044f \u0432\u0432\u043e\u0434\u0430 \u043f\u0443\u0442\u0438 \u043a \u043f\u0430\u043f\u043a\u0435 \u0441 \u043c\u043e\u0434\u0430\u043c\u0438\n        self.path_to_mods = StringVar()\n        self.path_to_mods_entry = FolderDialogComboBox(self, width=widget_width, height=widget_height, font=combobox_font, variable=self.path_to_mods)\n        self.path_to_mods_entry.grid(row=2, column=0)\n        self.path_to_mods_entry.set(self.user_config.last_path_to_mods) # type: ignore\n\n        # \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043f\u043e\u0434\u043f\u0438\u0441\u0438 \u0434\u043b\u044f \u0432\u044b\u0431\u043e\u0440\u0430 \u044f\u0437\u044b\u043a\u043e\u0432\n        language_label = CTkLabel(self, text=self.lang.translation_language, font=label_font) # type: ignore\n        language_label.grid(row=3, column=0, sticky=\"s\")\n        # \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0432\u0438\u0434\u0436\u0435\u0442\u0430 CTkOptionMenu \u0434\u043b\u044f \u0432\u044b\u0431\u043e\u0440\u0430 \u044f\u0437\u044b\u043a\u043e\u0432\n        self.target_language = StringVar()\n        language_font = CTkFont(\"Arial\", size=18)\n        self.language_optionmenu = CTkOptionMenu(self, width=widget_width, height=widget_height, font=language_font, variable=self.target_language)\n        self.language_optionmenu.grid(row=4, column=0)\n        self.language_optionmenu.set(self.lang.select_language) # type: ignore\n        list_supported_languages = self.supported_languages.keys()\n        CTkScrollableDropdown(self.language_optionmenu, height = 200, values=list_supported_languages, frame_corner_radius=20)\n\n        # \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u043e\u0433\u0440\u0430\u043d\u0438\u0447\u0435\u043d\u0438\u044f \u0434\u043b\u0438\u043d\u044b \u0441\u0442\u0440\u043e\u043a\u0438\n        def character_limit(entry_text):\n            if len(entry_text.get()) > 0:\n                entry_text.set(entry_text.get()[:6])\n        \n        # \u0440\u0430\u043c\u043a\u0430 \u0434\u043b\u044f \u043f\u0440\u0438\u0441\u0442\u0430\u0432\u043a\u0438 \u043a \u043f\u0435\u0440\u0435\u0432\u043e\u0434\u0430\u043c\n        startwith_frame = CTkFrame(self, width=widget_width, height=int(widget_height*1.33), fg_color=\"transparent\")\n        startwith_frame.grid(row=5, column=0)\n        startwith_frame.grid_propagate(False)\n        startwith_frame.grid_rowconfigure(0, weight=1)\n        startwith_frame.grid_columnconfigure((0, 1), weight=1) # type: ignore\n        # \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043f\u043e\u0434\u043f\u0438\u0441\u0438 \u0434\u043b\u044f \u043f\u0440\u0438\u0441\u0442\u0430\u0432\u043a\u0438 \u043a \u043f\u0435\u0440\u0435\u0432\u043e\u0434\u0430\u043c\n        startwith_font_label = CTkFont(\"Arial\", 16)\n        startwith_label = CTkLabel(startwith_frame, text=self.lang.startwith, font=startwith_font_label, anchor='w') # type: ignore\n        startwith_label.grid(row=0, column=0, sticky=\"sew\")\n        # \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0432\u0438\u0434\u0436\u0435\u0442\u0430 CTkEntry \u0434\u043b\u044f \u043f\u0440\u0438\u0441\u0442\u0430\u0432\u043a\u0438 \u043a \u043f\u0435\u0440\u0435\u0432\u043e\u0434\u0430\u043c\n        self.startwith = StringVar(value=self.user_config.startwith) # type: ignore\n        self.startwith.trace_add(\"write\", lambda *args: character_limit(self.startwith))\n        startwith_entry_font = CTkFont(\"Arial\", size=18, weight=\"bold\")\n        startwith_width: int = (widget_width//2.5) # type: ignore\n        self.startwith_entry = CTkEntry(startwith_frame, width=startwith_width, height=widget_height, font=startwith_entry_font, textvariable=self.startwith, justify='center')\n        self.startwith_entry.grid(row=0, column=1, sticky=\"se\")\n\n        # \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043f\u043e\u0434\u043f\u0438\u0441\u0438 \u043a \u0432\u0432\u043e\u0434\u0443 \u043f\u0443\u0442\u0438 \u043a \u043f\u0430\u043f\u043a\u0435 \u0441\u043e\u0437\u0440\u0430\u043d\u0435\u043d\u0438\u0439\n        path_to_save_font = CTkFont(\"Arial\", size=14)\n        path_to_save_label = CTkLabel(self, text=self.lang.last_path_to_save, font=path_to_save_font) # type: ignore\n        path_to_save_label.grid(row=6, column=0, sticky=\"s\")\n        # \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 CTkComboBox \u0434\u043b\u044f \u0432\u0432\u043e\u0434\u0430 \u043f\u0443\u0442\u0438 \u043a \u043f\u0430\u043f\u043a\u0435 \u0441\u043e\u0437\u0440\u0430\u043d\u0435\u043d\u0438\u0439\n        self.path_to_save = StringVar()\n        self.path_to_save_entry = FolderDialogComboBox(self, width=widget_width, height=widget_height, font=combobox_font, variable=self.path_to_save)\n        self.path_to_save_entry.grid(row=7, column=0)\n        self.path_to_save_entry.set(self.user_config.last_path_to_save) # type: ignore\n        \n        # \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043d\u0430\u0434\u043f\u0438\u0441\u0438 \u043e \u043d\u0435\u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u0438 \u043f\u0440\u043e\u0434\u043e\u043b\u0436\u0438\u0442\u044c\n        self.error_label = CTkLabel(self, text_color=\"red\", text=self.lang.error, font=(\"Arial\", 14)) # type: ignore\n        self.timer = None\n        # \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043a\u043d\u043e\u043f\u043a\u0438 \u0434\u043b\u044f \u043f\u0440\u043e\u0434\u043e\u043b\u0436\u0435\u043d\u0438\u044f\n        button_font = CTkFont(\"Arial\", size=22, weight=\"bold\")\n        next_button = CTkButton(self, width=widget_width, height=widget_height, font=button_font, text=self.lang.next, command=self.next_step) # type: ignore\n        next_button.grid(row=9, column=0, sticky=\"n\")\n\n        # set session data.\n        if session:\n            self._set_session_data(session)\n        \n    def next_step(self):\n        # \u0444\u0443\u043d\u043a\u0446\u0438\u044f, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u0431\u0443\u0434\u0435\u0442 \u0432\u044b\u0437\u044b\u0432\u0430\u0442\u044c\u0441\u044f \u043f\u0440\u0438 \u043d\u0430\u0436\u0430\u0442\u0438\u0438 \u043d\u0430 \u043a\u043d\u043e\u043f\u043a\u0443 \"\u041f\u0440\u043e\u0434\u043e\u043b\u0436\u0438\u0442\u044c\"\n\n        #\n        if self.timer:\n            self.timer.cancel()\n\n        #\n        if self.target_language.get() == self.lang.select_language or not self.checking_the_path(self.path_to_mods.get()): # type: ignore\n            self.error_label.grid(row=8, column=0, sticky=\"s\")\n            self.timer = Timer(5, self._error_label_timer)\n            self.timer.start()\n            return\n        \n        session = self.get_session_data()\n\n        self.user_config.last_path_to_mods = session.path_to_mods # type: ignore\n        self.user_config.last_path_to_save = session.path_to_save # type: ignore\n        self.user_config.startwith = session.startwith # type: ignore\n        UserConfigManager(self.main_folder).save_user_config(vars(self.user_config))\n\n        if self._command:\n            self._command(session)\n\n    def checking_the_path(self, folder):\n        try:\n            UserConfigManager._checking_the_path(folder)\n            return True\n        except NotADirectoryError:\n            return False\n    \n    def get_session_data(self) -> SessionData:\n        \"\"\"returns session data.\"\"\"\n\n        path_to_mods = self.path_to_mods.get()\n        path_to_save = self.path_to_save.get()\n        to_language = lang if (lang := self.target_language.get()) != self.lang.select_language else None # type: ignore\n        startwith = self.startwith.get()\n\n        session = SessionData(path_to_mods, path_to_save, to_language, startwith)\n\n        return session\n    \n    def _set_session_data(self, session: SessionData) -> None:\n        \"\"\"set session data.\"\"\"\n\n        self.path_to_mods.set(session.path_to_mods)\n        self.path_to_save.set(session.path_to_save)\n        self.target_language.set(lang if (lang := session.to_language) else self.lang.select_language) # type: ignore\n        self.startwith.set(session.startwith)\n    \n    def _error_label_timer(self) -> None:\n        \"\"\"Removes error_label.\"\"\"\n\n        self.error_label.grid_forget()"]}
{"filename": "pages/sidebar.py", "chunked_list": ["from typing import Optional, Tuple, Union, Callable\nfrom customtkinter import *\nfrom utils import *\nfrom CTkMessagebox import CTkMessagebox\n\nclass Sidebar(CTkFrame):\n    def __init__(self,\n                 master: any,\n                 data: GetData,\n                 update_language_callback: Callable[[str], None],\n                 update_appearance_mode_callback: Callable[[str], None],\n                 width: int = 200,\n                 height: int = 200,\n                 corner_radius: Optional[Union[int, str]] = None,\n                 border_width: Optional[Union[int, str]] = None,\n\n                 bg_color: Union[str, Tuple[str, str]] = \"transparent\",\n                 fg_color: Optional[Union[str, Tuple[str, str]]] = None,\n                 border_color: Optional[Union[str, Tuple[str, str]]] = None,\n\n                 background_corner_colors: Union[Tuple[Union[str, Tuple[str, str]]], None] = None,\n                 overwrite_preferred_drawing_method: Union[str, None] = None,\n                 **kwargs):\n        super().__init__(master, width, height, corner_radius, border_width, bg_color, fg_color, border_color, background_corner_colors, overwrite_preferred_drawing_method, **kwargs)\n        \n        self.update_language_callback = update_language_callback\n        self.update_appearance_mode_callback = update_appearance_mode_callback\n\n        self.config, self.user_config, self.lang, self.supported_languages = data.get()\n        self.main_folder = data.get_main_folder()\n\n        self.grid_rowconfigure(1, weight=1)\n        self.grid_columnconfigure(0, weight=1)\n\n        self.logo_label = CTkLabel(self, text=self.config.title, font=CTkFont(size=21, weight=\"bold\"))\n        self.logo_label.grid(row=0, column=0, padx=10, pady=(20, 10))\n\n        font_label=CTkFont(size=15)\n\n        values = list(self.user_config.dict_interface_language.keys())\n        self.interface_language_label = CTkLabel(self, text=self.lang.interface_language, anchor=\"w\", font=font_label)\n        self.interface_language_label.grid(row=2, column=0, padx=10, pady=(10, 0))\n        self.interface_language_menu = CTkOptionMenu(self, values=values, command=self.update_language_callback)\n        self.interface_language_menu.grid(row=3, column=0, padx=10, pady=10, sticky=\"ew\")\n        self.interface_language_menu.set(self.lang.language_name)\n\n        system_list_of_appearance_modes = self.config.system_list_of_appearance_modes\n        lang_list_of_appearance_modes = self.lang.list_of_appearance_modes\n        self.dict_of_appearance_modes = dict(zip(lang_list_of_appearance_modes, system_list_of_appearance_modes))\n        dict_of_system_appearance_modes = dict(zip(system_list_of_appearance_modes, lang_list_of_appearance_modes))\n        self.appearance_mode_label = CTkLabel(self, text=self.lang.appearance_mode, anchor=\"w\", font=font_label)\n        self.appearance_mode_label.grid(row=4, column=0, padx=10, pady=(10, 0))\n        self.appearance_mode_optionemenu = CTkOptionMenu(self, values=self.lang.list_of_appearance_modes, command=self.change_appearance_mode_event)\n        self.appearance_mode_optionemenu.grid(row=5, column=0, padx=10, pady=(10, 10), sticky=\"ew\")\n        self.appearance_mode_optionemenu.set(dict_of_system_appearance_modes[ self.user_config.appearance_mode ])\n\n    def change_appearance_mode_event(self, new_appearance_mode: str):\n        system_new_appearance_modes = self.dict_of_appearance_modes[new_appearance_mode]\n        self.update_appearance_mode_callback(system_new_appearance_modes)", ""]}
{"filename": "pages/__init__.py", "chunked_list": ["\nfrom .session_data import SessionData\nfrom .sidebar import Sidebar\nfrom .page1 import Page1\nfrom .page2 import Page2\nfrom .page3 import Page3"]}
{"filename": "pages/session_data.py", "chunked_list": ["from dataclasses import dataclass\nfrom typing import List, Tuple, Union\n\n@dataclass\nclass SessionData:\n    #Page1\n    path_to_mods: str\n    path_to_save: str\n    to_language: Union[str, None]\n    startwith: str\n    \n    #Page2\n    inactive_files_state: bool = True\n    save_untranslated_files: bool = False\n    create_subfolder: bool = True\n    normal_switches: Union[List[Tuple[str, bool]], None] = None\n    disabled_switches: Union[List[Tuple[str, bool]], None] = None\n    mods_for_translation: Union[list, None] = None\n\n    def set(self, **kwargs):\n        for key, value in kwargs.items():\n            setattr(self, key, value)"]}
{"filename": "pages/flipped_ctkcheckbox.py", "chunked_list": ["import tkinter\nfrom typing import Callable, Optional, Tuple, Union\nfrom customtkinter import CTkCheckBox\nfrom customtkinter.windows.widgets.font import CTkFont\n\n\n\nclass FlippedCTkCheckBox(CTkCheckBox):\n    def __init__(self,\n                 master: any,\n                 width: int = 100,\n                 height: int = 24,\n                 checkbox_width: int = 24,\n                 checkbox_height: int = 24,\n                 corner_radius: Optional[int] = None,\n                 border_width: Optional[int] = None,\n\n                 bg_color: Union[str, Tuple[str, str]] = \"transparent\",\n                 fg_color: Optional[Union[str, Tuple[str, str]]] = None,\n                 hover_color: Optional[Union[str, Tuple[str, str]]] = None,\n                 border_color: Optional[Union[str, Tuple[str, str]]] = None,\n                 checkmark_color: Optional[Union[str, Tuple[str, str]]] = None,\n                 text_color: Optional[Union[str, Tuple[str, str]]] = None,\n                 text_color_disabled: Optional[Union[str, Tuple[str, str]]] = None,\n\n                 text: str = \"CTkCheckBox\",\n                 font: Optional[Union[tuple, CTkFont]] = None,\n                 textvariable: Union[tkinter.Variable, None] = None,\n                 state: str = tkinter.NORMAL,\n                 hover: bool = True,\n                 command: Union[Callable[[], None], None] = None,\n                 onvalue: Union[int, str] = 1,\n                 offvalue: Union[int, str] = 0,\n                 variable: Union[tkinter.Variable, None] = None,\n                 **kwargs):\n        super().__init__(master, width, height, checkbox_width, checkbox_height, corner_radius, border_width, bg_color, fg_color, hover_color, border_color, checkmark_color, text_color, text_color_disabled, text, font, textvariable, state, hover, command, onvalue, offvalue, variable, **kwargs)\n        \n        self._canvas.grid(row=0, column=2, sticky=\"e\")\n        self._text_label.grid(row=0, column=0, sticky=\"w\")\n        self._text_label[\"anchor\"] = \"w\""]}
{"filename": "pages/page2.py", "chunked_list": ["from typing import Any, Optional, Tuple, Union, Callable\nfrom pathlib import Path\nfrom customtkinter import *\nfrom threading import Thread\nfrom utils import *\nfrom ModTranslator import *\nfrom .create_switches import CreateSwitches\nfrom .session_data import SessionData\n\nclass Page2(CTkFrame):\n    def __init__(self,\n                 master: Any,\n                 data: GetData,\n                 session: SessionData,\n                 width: int = 200,\n                 height: int = 200,\n                 corner_radius: Optional[Union[int, str]] = None,\n                 border_width: Optional[Union[int, str]] = None,\n\n                 bg_color: Union[str, Tuple[str, str]] = \"transparent\",\n                 fg_color: Optional[Union[str, Tuple[str, str]]] = None,\n                 border_color: Optional[Union[str, Tuple[str, str]]] = None,\n\n                 background_corner_colors: Union[Tuple[Union[str, Tuple[str, str]]], None] = None,\n                 overwrite_preferred_drawing_method: Union[str, None] = None,\n                 command: Union[Callable[[SessionData], None], None] = None,\n                 **kwargs):\n        super().__init__(master, width, height, corner_radius, border_width, bg_color, fg_color, border_color, background_corner_colors, overwrite_preferred_drawing_method, **kwargs)\n\n        self.grid_columnconfigure(0, weight=1, uniform=\"fred\")\n        self.grid_rowconfigure(0, weight=4, uniform=\"fred\")\n        self.grid_rowconfigure((1, 3, 4), weight=3, uniform=\"fred\") # type: ignore\n        self.grid_rowconfigure(2, weight=16, uniform=\"fred\")\n        self.grid_rowconfigure(5, weight=5, uniform=\"fred\")\n\n        self._session = session\n        self._command = command\n\n        _, self.user_config, self.lang, self.supported_languages = data.get()\n        self.main_folder = data.get_main_folder()\n        \n        scrollable_frame_width = 300\n        widget_width = 210\n        widget_height = 36\n\n        # \n        header_font = CTkFont(\"Arial\", size=30, weight=\"bold\")\n        main_label = CTkLabel(self, text=self.lang.file_management, font=header_font) # type: ignore\n        main_label.grid(row=0, column=0, sticky=\"s\")\n\n        # \n        self.inactive_files_state = BooleanVar(value=self._session.inactive_files_state)\n        inactive_files_state_font = CTkFont(\"Arial\", size=16, weight=\"bold\")\n        inactive_files_state_checkbox = CTkSwitch(self, text=self.lang.inactive_files_state, font=inactive_files_state_font, command=self._inactive_files_event, variable=self.inactive_files_state) # type: ignore\n        inactive_files_state_checkbox.grid(row=1, column=0)\n\n        # create scrollable frame\n        scrollable_frame = CTkScrollableFrame(self, label_text=self.lang.file_selection) # type: ignore\n        scrollable_frame.grid(row=2, column=0, sticky=\"ns\")\n        scrollable_frame.grid_columnconfigure(0, weight=1)\n        scrollable_frame._parent_frame.configure(width=scrollable_frame_width)\n        scrollable_frame._parent_frame.grid_propagate(False)\n        #build switches\n        self.disabled_switches = None\n        self.thread = Thread(target=self._build_switches_for_scrollable_frame, args=(scrollable_frame,))\n        self.thread.start()\n\n        # \n        self.save_untranslated_files = BooleanVar(value=self._session.save_untranslated_files)\n        save_untranslated_files_font = CTkFont(\"Arial\", size=14)\n        save_untranslated_files_checkbox = CTkSwitch(self, text=self.lang.save_untranslated_files, font=save_untranslated_files_font, variable=self.save_untranslated_files) # type: ignore\n        save_untranslated_files_checkbox.grid(row=3, column=0)\n        \n        # \n        self.create_subfolder = BooleanVar(value=self._session.create_subfolder)\n        create_subfolder_font = CTkFont(\"Arial\", size=14)\n        create_subfolder_checkbox = CTkSwitch(self, text=self.lang.create_subfolder, font=create_subfolder_font, variable=self.create_subfolder) # type: ignore\n        create_subfolder_checkbox.grid(row=4, column=0)\n        \n        # \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043a\u043d\u043e\u043f\u043a\u0438 \u0434\u043b\u044f \u043f\u0440\u043e\u0434\u043e\u043b\u0436\u0435\u043d\u0438\u044f\n        button_font = CTkFont(\"Arial\", size=22, weight=\"bold\")\n        next_button = CTkButton(self, width=widget_width, height=widget_height, font=button_font, text=self.lang.next, command=self.next_step) # type: ignore\n        next_button.grid(row=5, column=0, sticky=\"\")\n\n    def _inactive_files_event(self) -> None:\n        if self.disabled_switches is None:\n            return\n        \n        if self.inactive_files_state.get():\n            self.disabled_switches.hide()\n        else:\n            self.disabled_switches.show()\n        \n    def _build_switches_for_scrollable_frame(self, master):\n        \"\"\"create switches for scrollable frame.\"\"\"\n\n        if self._session.normal_switches is None and self._session.disabled_switches is None:\n            #get mods\n            mods_translation = CheckModsTranslation(self.supported_languages[self._session.to_language][\"mc_code\"],\n                                                self._session.path_to_mods,\n                                                exception_handler=self._exception_handler_ignore)\n            untranslated_mods = mods_translation.get_untranslated_mods()\n            untranslated_names_of_mods = [Path(mod).stem for mod in untranslated_mods]\n            other_mods = mods_translation.get_translated_mods() + mods_translation.get_mods_with_no_languages()\n            other_names_of_mods = [Path(mod).stem for mod in other_mods]\n            #get values\n            normal_switches_values = True\n        else:\n            #get mods\n            untranslated_names_of_mods = [name for name, value in self._session.normal_switches]\n            other_names_of_mods = [name for name, value in self._session.disabled_switches]\n            #get values\n            normal_switches_values = [value for name, value in self._session.normal_switches]\n\n        #create switches\n        max_length = 30\n        self.normal_switches = CreateSwitches(master, untranslated_names_of_mods, start=0, values=normal_switches_values, max_length=max_length)\n        self.disabled_switches = CreateSwitches(master, other_names_of_mods, start=len(self.normal_switches.get_switches()), state=DISABLED, values=False, max_length=max_length)\n        \n        #hide disabled switches\n        self._inactive_files_event()\n    \n    def next_step(self):\n        if self.thread.is_alive():\n            print(\"wait\")\n            return\n        \n        variable_switches = self.normal_switches.get_variable_switches()\n        mods_for_translation = [text for text, variable in variable_switches if variable]\n\n        session = self.get_session_data()\n        session.set(mods_for_translation=mods_for_translation)\n\n        if self._command:\n            self._command(session)\n    \n    def get_session_data(self) -> SessionData:\n        \"\"\"returns session data.\"\"\"\n        if self.thread.is_alive():\n            # self.thread.join()\n            pass\n        else:\n            normal_switches_data = self.normal_switches.get_variable_switches()\n            disabled_switches_data = self.disabled_switches.get_variable_switches()\n            self._session.set(normal_switches=normal_switches_data,\n                              disabled_switches=disabled_switches_data)\n\n        #get values\n        inactive_files_state = self.inactive_files_state.get()\n        save_untranslated_files = self.save_untranslated_files.get()\n        create_subfolder = self.create_subfolder.get()\n\n        self._session.set(inactive_files_state=inactive_files_state, \n                          save_untranslated_files=save_untranslated_files,\n                          create_subfolder=create_subfolder)\n\n        return self._session\n    \n    def _exception_handler_ignore(self, exception: Exception, comment: str):\n        pass", "\nclass Page2(CTkFrame):\n    def __init__(self,\n                 master: Any,\n                 data: GetData,\n                 session: SessionData,\n                 width: int = 200,\n                 height: int = 200,\n                 corner_radius: Optional[Union[int, str]] = None,\n                 border_width: Optional[Union[int, str]] = None,\n\n                 bg_color: Union[str, Tuple[str, str]] = \"transparent\",\n                 fg_color: Optional[Union[str, Tuple[str, str]]] = None,\n                 border_color: Optional[Union[str, Tuple[str, str]]] = None,\n\n                 background_corner_colors: Union[Tuple[Union[str, Tuple[str, str]]], None] = None,\n                 overwrite_preferred_drawing_method: Union[str, None] = None,\n                 command: Union[Callable[[SessionData], None], None] = None,\n                 **kwargs):\n        super().__init__(master, width, height, corner_radius, border_width, bg_color, fg_color, border_color, background_corner_colors, overwrite_preferred_drawing_method, **kwargs)\n\n        self.grid_columnconfigure(0, weight=1, uniform=\"fred\")\n        self.grid_rowconfigure(0, weight=4, uniform=\"fred\")\n        self.grid_rowconfigure((1, 3, 4), weight=3, uniform=\"fred\") # type: ignore\n        self.grid_rowconfigure(2, weight=16, uniform=\"fred\")\n        self.grid_rowconfigure(5, weight=5, uniform=\"fred\")\n\n        self._session = session\n        self._command = command\n\n        _, self.user_config, self.lang, self.supported_languages = data.get()\n        self.main_folder = data.get_main_folder()\n        \n        scrollable_frame_width = 300\n        widget_width = 210\n        widget_height = 36\n\n        # \n        header_font = CTkFont(\"Arial\", size=30, weight=\"bold\")\n        main_label = CTkLabel(self, text=self.lang.file_management, font=header_font) # type: ignore\n        main_label.grid(row=0, column=0, sticky=\"s\")\n\n        # \n        self.inactive_files_state = BooleanVar(value=self._session.inactive_files_state)\n        inactive_files_state_font = CTkFont(\"Arial\", size=16, weight=\"bold\")\n        inactive_files_state_checkbox = CTkSwitch(self, text=self.lang.inactive_files_state, font=inactive_files_state_font, command=self._inactive_files_event, variable=self.inactive_files_state) # type: ignore\n        inactive_files_state_checkbox.grid(row=1, column=0)\n\n        # create scrollable frame\n        scrollable_frame = CTkScrollableFrame(self, label_text=self.lang.file_selection) # type: ignore\n        scrollable_frame.grid(row=2, column=0, sticky=\"ns\")\n        scrollable_frame.grid_columnconfigure(0, weight=1)\n        scrollable_frame._parent_frame.configure(width=scrollable_frame_width)\n        scrollable_frame._parent_frame.grid_propagate(False)\n        #build switches\n        self.disabled_switches = None\n        self.thread = Thread(target=self._build_switches_for_scrollable_frame, args=(scrollable_frame,))\n        self.thread.start()\n\n        # \n        self.save_untranslated_files = BooleanVar(value=self._session.save_untranslated_files)\n        save_untranslated_files_font = CTkFont(\"Arial\", size=14)\n        save_untranslated_files_checkbox = CTkSwitch(self, text=self.lang.save_untranslated_files, font=save_untranslated_files_font, variable=self.save_untranslated_files) # type: ignore\n        save_untranslated_files_checkbox.grid(row=3, column=0)\n        \n        # \n        self.create_subfolder = BooleanVar(value=self._session.create_subfolder)\n        create_subfolder_font = CTkFont(\"Arial\", size=14)\n        create_subfolder_checkbox = CTkSwitch(self, text=self.lang.create_subfolder, font=create_subfolder_font, variable=self.create_subfolder) # type: ignore\n        create_subfolder_checkbox.grid(row=4, column=0)\n        \n        # \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043a\u043d\u043e\u043f\u043a\u0438 \u0434\u043b\u044f \u043f\u0440\u043e\u0434\u043e\u043b\u0436\u0435\u043d\u0438\u044f\n        button_font = CTkFont(\"Arial\", size=22, weight=\"bold\")\n        next_button = CTkButton(self, width=widget_width, height=widget_height, font=button_font, text=self.lang.next, command=self.next_step) # type: ignore\n        next_button.grid(row=5, column=0, sticky=\"\")\n\n    def _inactive_files_event(self) -> None:\n        if self.disabled_switches is None:\n            return\n        \n        if self.inactive_files_state.get():\n            self.disabled_switches.hide()\n        else:\n            self.disabled_switches.show()\n        \n    def _build_switches_for_scrollable_frame(self, master):\n        \"\"\"create switches for scrollable frame.\"\"\"\n\n        if self._session.normal_switches is None and self._session.disabled_switches is None:\n            #get mods\n            mods_translation = CheckModsTranslation(self.supported_languages[self._session.to_language][\"mc_code\"],\n                                                self._session.path_to_mods,\n                                                exception_handler=self._exception_handler_ignore)\n            untranslated_mods = mods_translation.get_untranslated_mods()\n            untranslated_names_of_mods = [Path(mod).stem for mod in untranslated_mods]\n            other_mods = mods_translation.get_translated_mods() + mods_translation.get_mods_with_no_languages()\n            other_names_of_mods = [Path(mod).stem for mod in other_mods]\n            #get values\n            normal_switches_values = True\n        else:\n            #get mods\n            untranslated_names_of_mods = [name for name, value in self._session.normal_switches]\n            other_names_of_mods = [name for name, value in self._session.disabled_switches]\n            #get values\n            normal_switches_values = [value for name, value in self._session.normal_switches]\n\n        #create switches\n        max_length = 30\n        self.normal_switches = CreateSwitches(master, untranslated_names_of_mods, start=0, values=normal_switches_values, max_length=max_length)\n        self.disabled_switches = CreateSwitches(master, other_names_of_mods, start=len(self.normal_switches.get_switches()), state=DISABLED, values=False, max_length=max_length)\n        \n        #hide disabled switches\n        self._inactive_files_event()\n    \n    def next_step(self):\n        if self.thread.is_alive():\n            print(\"wait\")\n            return\n        \n        variable_switches = self.normal_switches.get_variable_switches()\n        mods_for_translation = [text for text, variable in variable_switches if variable]\n\n        session = self.get_session_data()\n        session.set(mods_for_translation=mods_for_translation)\n\n        if self._command:\n            self._command(session)\n    \n    def get_session_data(self) -> SessionData:\n        \"\"\"returns session data.\"\"\"\n        if self.thread.is_alive():\n            # self.thread.join()\n            pass\n        else:\n            normal_switches_data = self.normal_switches.get_variable_switches()\n            disabled_switches_data = self.disabled_switches.get_variable_switches()\n            self._session.set(normal_switches=normal_switches_data,\n                              disabled_switches=disabled_switches_data)\n\n        #get values\n        inactive_files_state = self.inactive_files_state.get()\n        save_untranslated_files = self.save_untranslated_files.get()\n        create_subfolder = self.create_subfolder.get()\n\n        self._session.set(inactive_files_state=inactive_files_state, \n                          save_untranslated_files=save_untranslated_files,\n                          create_subfolder=create_subfolder)\n\n        return self._session\n    \n    def _exception_handler_ignore(self, exception: Exception, comment: str):\n        pass"]}
{"filename": "pages/create_switches.py", "chunked_list": ["from typing import Optional, Tuple, Union, Callable\nfrom tkinter import NORMAL, BooleanVar\nfrom threading import Thread, currentThread\nfrom .flipped_ctkcheckbox import FlippedCTkCheckBox\n\nclass CreateSwitches:\n    def __init__(self,\n                 master: any,\n                 texts: list[str],\n                 start: int = 0,\n                 state: str = NORMAL,\n                 values: Union[bool, list[bool]] = True,\n                 max_length: int = 30):\n                 \n        from time import time\n        self.start = time()\n        \n        indexes = range(len(texts))\n        self._switches: list[FlippedCTkCheckBox] = []\n        self._variable_switches: list[tuple[str, BooleanVar]] = []\n        self._master = master\n        self._start = start\n        self._state = state\n        self._max_length = max_length\n\n        self._threads: list[Thread] = []\n\n        if isinstance(values, bool):\n            value = values\n            for index, text in zip(indexes, texts):\n                self._create_thread(index, text, value)\n        elif isinstance(values, list) and all(isinstance(value, bool) for value in values):\n            for index, text, value in zip(indexes, texts, values):\n                self._create_thread(index, text, value)\n        else:\n            raise TypeError(\"The 'values' argument should be either a Boolean value (bool) or a list of Boolean values (list[bool]), \\\n                            and its length should match the length of the 'texts' list.\")\n        \n        for thread in self._threads:\n            thread.join()\n        \n        # print(\"the work is completed in\", time()-self.start)\n    \n    def _create_thread(self, index, text, value):\n            thread = Thread(target=self._build_switch, args=(index, text, value))\n            thread.start()\n            self._threads.append(thread)\n\n    def _build_switch(self, index, text, value):\n            try:\n                _text = text if len(text) <= self._max_length else text[:self._max_length] + \"...\"\n                _value = BooleanVar(value=value)\n                checkbox = FlippedCTkCheckBox(master=self._master, text=f\"{_text}\",  state=self._state, variable=_value)\n                checkbox.grid(row=(self._start + index), column=0, padx=10, pady=(0, 10), sticky=\"ew\")\n                self._switches.append(checkbox)\n                self._variable_switches.append((text, _value,))\n            except Exception as e:\n                # print(e)\n                pass\n\n    def get_switches(self) -> list:\n        \"\"\"return switches.\"\"\"\n        return self._switches\n    \n    def get_variable_switches(self) -> list[tuple[str, bool]]:\n        \"\"\"return the list with texts and values.\"\"\"\n        return [(text, variable.get()) for text, variable in self._variable_switches]\n    \n    def hide(self, switches: Union[list, None] = None) -> None:\n        if switches is None:\n            _switches = self._switches\n        \n        for i in _switches:\n            i.grid_remove()\n\n    def show(self, switches: Union[list, None] = None) -> None:\n        if switches is None:\n            _switches = self._switches\n\n        for i in _switches:\n            i.grid()"]}
{"filename": "pages/page3.py", "chunked_list": ["from typing import Any, Optional, Tuple, Union, Callable\nfrom customtkinter import *\nfrom threading import Thread\nfrom utils import *\nfrom ModTranslator import *\nfrom .session_data import SessionData\n\nclass Page3(CTkFrame):\n    def __init__(self,\n                 master: Any,\n                 data: GetData,\n                 session: SessionData,\n                 width: int = 200,\n                 height: int = 200,\n                 corner_radius: Optional[Union[int, str]] = None,\n                 border_width: Optional[Union[int, str]] = None,\n\n                 bg_color: Union[str, Tuple[str, str]] = \"transparent\",\n                 fg_color: Optional[Union[str, Tuple[str, str]]] = None,\n                 border_color: Optional[Union[str, Tuple[str, str]]] = None,\n\n                 background_corner_colors: Union[Tuple[Union[str, Tuple[str, str]]], None] = None,\n                 overwrite_preferred_drawing_method: Union[str, None] = None,\n                 command: Union[Callable[[SessionData], None], None] = None,\n                 **kwargs):\n        super().__init__(master, width, height, corner_radius, border_width, bg_color, fg_color, border_color, background_corner_colors, overwrite_preferred_drawing_method, **kwargs)\n\n        self.grid_columnconfigure(0, weight=1, uniform=\"fred\")\n        self.grid_rowconfigure(0, weight=3, uniform=\"fred\")\n        self.grid_rowconfigure(1, weight=3, uniform=\"fred\")\n        self.grid_rowconfigure(2, weight=18, uniform=\"fred\")\n        self.grid_rowconfigure(3, weight=6, uniform=\"fred\")\n\n        self._session = session\n        self._command = command\n\n        _, self.user_config, self.lang, self.supported_languages = data.get()\n        self.main_folder = data.get_main_folder()\n        \n        widget_width = 210\n        widget_height = 36\n\n        # \n        header_font = CTkFont(\"Arial\", size=30, weight=\"bold\")\n        main_label = CTkLabel(self, text=self.lang.file_management, font=header_font) # type: ignore\n        main_label.grid(row=0, column=0, sticky=\"\")\n\n        # \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043f\u043e\u0434\u043f\u0438\u0441\u0438 \u043a \n        path_to_save_font = CTkFont(\"Arial\", size=26)\n        path_to_save_label = CTkLabel(self, text=self.lang.log, font=path_to_save_font) # type: ignore\n        path_to_save_label.grid(row=1, column=0, sticky=\"s\")\n\n        # create textbox \n        textbox = CTkTextbox(self, width=350)\n        textbox.grid(row=2, column=0, sticky=\"ns\")\n        textbox.configure(state=DISABLED)\n\n        #\n        from .texthandler import TextHandler\n        COMMENT = \"This translation was made by the Minecraft-Mods-Translator program.\\n//repository \u2014 https://github.com/steklyashka33/Minecraft-Mods-Translator\"\n        self.translator = ModsTranslator(COMMENT)\n        handler = TextHandler(textbox)\n        handler.setFormatter(self.translator.FORMATTER)\n        self.logger = self.translator.get_logger()\n        self.logger.addHandler(handler)\n        self.thread = Thread(target=self._start_translating, args=())\n        self.thread.start()\n        \n        # \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043a\u043d\u043e\u043f\u043a\u0438 \u0434\u043b\u044f \u043f\u0440\u043e\u0434\u043e\u043b\u0436\u0435\u043d\u0438\u044f\n        button_font = CTkFont(\"Arial\", size=22, weight=\"bold\")\n        close_button = CTkButton(self, width=widget_width, height=widget_height, font=button_font, text=self.lang.close, command=self.next_step) # type: ignore\n        close_button.grid(row=3, column=0, sticky=\"\")\n    \n    def _start_translating(self):\n        language: dict = self.supported_languages[self._session.to_language]\n        self.translator.translate(language[\"google_code\"],\n                             self._session.path_to_mods,\n                             self._session.mods_for_translation,\n                             self._session.path_to_save,\n                             self._session.startwith)\n    \n    def next_step(self):\n        if self.thread.is_alive():\n            print(\"wait\")\n            return\n\n        session = self.get_session_data()\n        session.set()\n\n        if self._command:\n            self._command(session) # type: ignore\n    \n    def get_session_data(self) -> SessionData:\n        \"\"\"returns session data.\"\"\"\n        if self.thread.is_alive():\n            # self.thread.join()\n            return\n\n        return self._session\n    \n    def _exception_handler(self, file_name):\n        print(f\"error {file_name}\")"]}
{"filename": "utils/dataclass.py", "chunked_list": ["from dataclasses import dataclass\n\n@dataclass(init=False)\nclass DataClass:\n    def __init__(self, **kwargs):\n        for key, value in kwargs.items():\n            setattr(self, key, value)\n            "]}
{"filename": "utils/yaml_file_manager.py", "chunked_list": ["import os\nimport yaml\n\nclass YAMLFileManager:\n    \"\"\"Class for managing YAML files in a directory.\"\"\"\n\n    def __init__(self, directory, file_name=None):\n        self.set_directory(directory)\n        self.set_file_name(file_name)\n    \n    def set_file_name(self, file_name) -> None:\n        \"\"\"Set the file name.\"\"\"\n\n        if file_name is None:\n            self._file_name = None\n        elif isinstance(file_name, str):\n            if not file_name.endswith('.yaml'):\n                file_name += '.yaml'\n            self._file_name = file_name\n        else:\n            raise TypeError(\"File name must be a string.\")\n    \n    def set_directory(self, directory) -> None:\n        \"\"\"Set the directory.\"\"\"\n\n        if isinstance(directory, str):\n            if os.path.isdir(directory):\n                self._directory = directory\n            else:\n                raise NotADirectoryError(f\"Directory '{directory}' does not exist.\")\n        else:\n            raise TypeError(\"Directory must be a string.\")\n    \n    def get_file_name(self) -> str:\n        return self._file_name\n    \n    def get_directory(self) -> str:\n        return self._directory\n    \n    def load_file(self):\n        \"\"\"Load the YAML file and return its contents as a Python object.\"\"\"\n\n        if self._file_name is not None:\n            file_path = os.path.join(self._directory, self._file_name)\n            if os.path.isfile(file_path):\n                with open(file_path, 'r', encoding=\"utf-8\") as file:\n                    return yaml.safe_load(file)\n            else:\n                raise FileNotFoundError(f\"File '{self._file_name}' does not exist in '{self._directory}'\")\n        else:\n            raise ValueError(\"No file name specified.\")\n    \n    def write_to_file(self, to_yaml) -> None:\n        \"\"\"Writes the passed values to a file.\"\"\"\n\n        with open(self._file_name, 'w', encoding=\"utf-8\") as f:\n            yaml.dump(to_yaml, f, encoding=\"utf-8\")\n    \n    def get_yaml_files(self) -> list[str]:\n        \"\"\"Get the names of all YAML files in the directory.\"\"\"\n\n        file_names = []\n        for file in os.listdir(self._directory):\n            if file.endswith('.yaml'):\n                file_names.append(file)\n        \n        return file_names", "\nif __name__ == \"__main__\":\n    maneger = YAMLFileManager(\"./lang\", \"ru\")\n    print(maneger.load_file())"]}
{"filename": "utils/__init__.py", "chunked_list": ["\n\nfrom .CTkScrollableDropdown import CTkScrollableDropdown\nfrom .user_config_manager import UserConfigManager\nfrom .yaml_file_manager import YAMLFileManager\nfrom .get_data import GetData"]}
{"filename": "utils/user_config_manager.py", "chunked_list": ["from .yaml_file_manager import YAMLFileManager\nfrom os.path import isfile, join\nimport os\n\nclass UserConfigManager():\n    \"\"\"manager for working with the user_config file.\"\"\"\n\n    USER_CONFIG_TEMPLATE = {\n        'interface_language': 'English', \n        'dict_interface_language': None, #example:  English: en.yaml\n        'appearance_mode': 'System', #number from the list system_list_of_appearance_modes\n        'last_path_to_mods': os.path.expanduser('~\\\\AppData\\\\Roaming\\\\.minecraft\\\\mods'),\n        'last_path_to_save': os.path.expanduser('~\\\\Documents\\\\translations'),\n        'startwith': '(Auto)',\n        }\n\n    FILE_NAME = \"user_config.yaml\"\n\n    def __init__(self, main_folder: str) -> None:\n\n        #checking for correct input\n        self._checking_the_path(main_folder)\n        self.main_folder = main_folder\n    \n    @staticmethod\n    def _checking_the_path(folder) -> None:\n        \"\"\"checking the folder path for errors.\"\"\"\n\n        if isinstance(folder, str):\n            if not os.path.isdir(folder):\n                raise NotADirectoryError(f\"Directory '{folder}' does not exist.\")\n        else:\n            raise TypeError(\"Directory must be a string.\")\n    \n    def get_user_config(self, folder_with_translations: str):\n        \"\"\"returns data from the user_config file.\"\"\"\n\n        #checking for correct input\n        self._checking_the_path(os.path.join(self.main_folder, folder_with_translations))\n\n        file_manager = YAMLFileManager(self.main_folder, self.FILE_NAME)\n        if isfile( join(self.main_folder, self.FILE_NAME) ):\n            self.user_config = file_manager.load_file()\n        else:\n            self.user_config = self.USER_CONFIG_TEMPLATE\n        \n        self.user_config['dict_interface_language'] = self._get_dictionary_of_interface_language(folder_with_translations)\n        \n        return self.user_config\n    \n    def save_user_config(self, data) -> None:\n        \"\"\"writes data to the user_config file.\"\"\"\n\n        file_manager = YAMLFileManager(self.main_folder, self.FILE_NAME)\n        file_manager.write_to_file(data)\n    \n    def _get_dictionary_of_interface_language(self, folder_with_translations):\n        \"\"\"return dict_interface_language.\"\"\"\n        \n        path_to_folder_with_translations = os.path.join(self.main_folder, folder_with_translations)\n        manager = YAMLFileManager(path_to_folder_with_translations)\n\n        translations_files = manager.get_yaml_files()\n        dict_interface_language = {}\n\n        for file_name in translations_files:\n            manager.set_file_name(file_name)\n            file_data = manager.load_file()\n            \n            try:\n                language_name = file_data['language_name']\n                dict_interface_language[language_name] = file_name\n            except:\n                pass\n            \n        return dict_interface_language", "\n\n\nif __name__ == \"__main__\":\n    main_folder = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n    manager = UserConfigManager(main_folder)\n    folder_with_translations = YAMLFileManager(main_folder, \"config.yaml\").load_file()[\"folder_with_translations\"]\n    data = manager.get_user_config(folder_with_translations)\n    print(data)"]}
{"filename": "utils/get_data.py", "chunked_list": ["from .yaml_file_manager import YAMLFileManager\nfrom .user_config_manager import UserConfigManager\nfrom .dataclass import DataClass\nimport os\n\nclass GetData:\n    \"\"\"work with data.\"\"\"\n\n    def __init__(self, main_folder) -> None:\n        self.main_folder = main_folder\n\n    def get(self) -> tuple[DataClass, DataClass, DataClass, dict]:\n        \"\"\"returns config, user_config, lang, supported_languages data.\"\"\"\n        \n        # get config\n        config = YAMLFileManager(self.main_folder, \"config.yaml\").load_file()\n        \n        #get user_config\n        folder_with_translations = config[\"folder_with_translations\"]\n        user_config = UserConfigManager(self.main_folder).get_user_config(folder_with_translations)\n\n        #get lang\n        language_file = user_config[\"dict_interface_language\"][ user_config[\"interface_language\"] ]\n        lang = YAMLFileManager(os.path.join( self.main_folder, folder_with_translations ), language_file).load_file()\n\n        #get supported_languages\n        supported_languages_file_name = \"supported_languages.yaml\"\n        supported_languages = YAMLFileManager(self.main_folder, supported_languages_file_name).load_file()\n\n        config_class = DataClass(**config)\n        user_config_class = DataClass(**user_config)\n        lang_class = DataClass(**lang)\n\n        return config_class, user_config_class, lang_class, supported_languages\n\n    def get_main_folder(self):\n        \"\"\"returns main_folder.\"\"\"\n        return self.main_folder"]}
{"filename": "utils/CTkScrollableDropdown/ctk_scrollable_dropdown.py", "chunked_list": ["'''\nAdvanced Scrollable Dropdown class for customtkinter widgets\nAuthor: Akash Bora\n'''\n\nimport customtkinter\nimport sys\nimport time\n\nclass CTkScrollableDropdown(customtkinter.CTkToplevel):\n    \n    def __init__(self, attach, x=None, y=None, button_color=None, height: int = 200, width: int = None,\n                 fg_color=None, button_height: int = 20, justify=\"center\", scrollbar_button_color=None,\n                 scrollbar=True, scrollbar_button_hover_color=None, frame_border_width=2, values=[],\n                 command=None, image_values=[], alpha: float = 0.97, frame_corner_radius=20, double_click=False,\n                 resize=True, frame_border_color=None, text_color=None, autocomplete=False, **button_kwargs):\n        \n        super().__init__(takefocus=1)\n        \n        self.focus()\n        self.alpha = alpha\n        self.attach = attach\n        self.corner = frame_corner_radius\n        self.padding = 0\n        self.focus_something = False\n        self.disable = True\n        \n        if sys.platform.startswith(\"win\"):\n            self.after(100, lambda: self.overrideredirect(True))\n            self.transparent_color = self._apply_appearance_mode(self._fg_color)\n            self.attributes(\"-transparentcolor\", self.transparent_color)\n        elif sys.platform.startswith(\"darwin\"):\n            self.overrideredirect(True)\n            self.transparent_color = 'systemTransparent'\n            self.attributes(\"-transparent\", True)\n            self.focus_something = True\n        else:\n            self.overrideredirect(True)\n            self.transparent_color = '#000001'\n            self.corner = 0\n            self.padding = 18\n            self.withdraw()\n\n        self.hide = True\n        self.attach.bind('<Configure>', lambda e: self._withdraw() if not self.disable else None, add=\"+\")\n        self.attach.winfo_toplevel().bind('<Configure>', lambda e: self._withdraw() if not self.disable else None, add=\"+\")\n        self.attach.winfo_toplevel().bind(\"<Triple-Button-1>\", lambda e: self._withdraw() if not self.disable else None, add=\"+\")        \n        self.attach.winfo_toplevel().bind(\"<Button-3>\", lambda e: self._withdraw() if not self.disable else None, add=\"+\")\n        self.attach.winfo_toplevel().bind(\"<Button-2>\", lambda e: self._withdraw() if not self.disable else None, add=\"+\")\n        \n        self.attributes('-alpha', 0)\n        self.disable = False\n        self.fg_color = customtkinter.ThemeManager.theme[\"CTkFrame\"][\"fg_color\"] if fg_color is None else fg_color\n        self.scroll_button_color = customtkinter.ThemeManager.theme[\"CTkScrollbar\"][\"button_color\"] if scrollbar_button_color is None else scrollbar_button_color\n        self.scroll_hover_color = customtkinter.ThemeManager.theme[\"CTkScrollbar\"][\"button_hover_color\"] if scrollbar_button_hover_color is None else scrollbar_button_hover_color\n        self.frame_border_color = customtkinter.ThemeManager.theme[\"CTkFrame\"][\"border_color\"] if frame_border_color is None else frame_border_color\n        self.button_color = customtkinter.ThemeManager.theme[\"CTkFrame\"][\"top_fg_color\"] if button_color is None else button_color\n        self.text_color = customtkinter.ThemeManager.theme[\"CTkLabel\"][\"text_color\"] if text_color is None else text_color\n        \n        if scrollbar is False:\n            self.scroll_button_color = self.fg_color\n            self.scroll_hover_color = self.fg_color\n            \n        self.frame = customtkinter.CTkScrollableFrame(self, bg_color=self.transparent_color, fg_color=self.fg_color,\n                                        scrollbar_button_hover_color=self.scroll_hover_color,\n                                        corner_radius=self.corner, border_width=frame_border_width,\n                                        scrollbar_button_color=self.scroll_button_color,\n                                        border_color=self.frame_border_color)\n        self.frame._scrollbar.grid_configure(padx=3)\n        self.frame.pack(expand=True, fill=\"both\")\n        self.dummy_entry = customtkinter.CTkEntry(self.frame, fg_color=\"transparent\", border_width=0, height=1, width=1)\n        self.no_match = customtkinter.CTkLabel(self.frame, text=\"No Match\")\n        self.height = height\n        self.height_new = height\n        self.width = width\n        self.command = command\n        self.fade = False\n        self.resize = resize\n        self.autocomplete = autocomplete\n        self.var_update = customtkinter.StringVar()\n        self.appear = False\n        \n        if justify.lower()==\"left\":\n            self.justify = \"w\"\n        elif justify.lower()==\"right\":\n            self.justify = \"e\"\n        else:\n            self.justify = \"c\"\n            \n        self.button_height = button_height\n        self.values = values\n        self.button_num = len(self.values)\n        self.image_values = None if len(image_values)!=len(self.values) else image_values\n        \n        self.resizable(width=False, height=False)\n        self.transient(self.master)\n        self._init_buttons(**button_kwargs)\n\n        # Add binding for different ctk widgets\n        if double_click or self.attach.winfo_name().startswith(\"!ctkentry\") or self.attach.winfo_name().startswith(\"!ctkcombobox\"):\n            self.attach.bind('<Double-Button-1>', lambda e: self._iconify(), add=\"+\")\n        else:\n            self.attach.bind('<Button-1>', lambda e: self._iconify(), add=\"+\")\n\n        if self.attach.winfo_name().startswith(\"!ctkcombobox\"):\n            self.attach._canvas.tag_bind(\"right_parts\", \"<Button-1>\", lambda e: self._iconify())\n            self.attach._canvas.tag_bind(\"dropdown_arrow\", \"<Button-1>\", lambda e: self._iconify())\n            if self.command is None:\n                self.command = self.attach.set\n              \n        if self.attach.winfo_name().startswith(\"!ctkoptionmenu\"):\n            self.attach._canvas.bind(\"<Button-1>\", lambda e: self._iconify())\n            self.attach._text_label.bind(\"<Button-1>\", lambda e: self._iconify())\n            if self.command is None:\n                self.command = self.attach.set\n        \n        self.update_idletasks()\n        self.x = x\n        self.y = y\n\n        if self.autocomplete:\n            self.bind_autocomplete()\n            \n        self.deiconify()\n        self.withdraw()\n        \n        self.attributes(\"-alpha\", self.alpha)\n        \n    def _withdraw(self):\n        if self.hide is False: self.withdraw()\n        self.hide = True\n\n    def _update(self, a, b, c):\n        self.live_update(self.attach._entry.get())\n        \n    def bind_autocomplete(self, ):\n        def appear(x):\n            self.appear = True\n            \n        if self.attach.winfo_name().startswith(\"!ctkcombobox\"):\n            self.attach._entry.configure(textvariable=self.var_update)\n            self.attach._entry.bind(\"<Key>\", appear)\n            self.attach.set(self.values[0])\n            self.var_update.trace_add('write', self._update)\n            \n        if self.attach.winfo_name().startswith(\"!ctkentry\"):\n            self.attach.configure(textvariable=self.var_update)\n            self.attach.bind(\"<Key>\", appear)\n            self.var_update.trace_add('write', self._update)\n        \n    def fade_out(self):\n        for i in range(100,0,-10):\n            if not self.winfo_exists():\n                break\n            self.attributes(\"-alpha\", i/100)\n            self.update()\n            time.sleep(1/100)\n            \n    def fade_in(self):\n        for i in range(0,100,10):\n            if not self.winfo_exists():\n                break\n            self.attributes(\"-alpha\", i/100)\n            self.update()\n            time.sleep(1/100)\n            \n    def _init_buttons(self, **button_kwargs):\n        self.i = 0\n        self.widgets = {}\n        for row in self.values:                                \n            self.widgets[self.i] = customtkinter.CTkButton(self.frame,\n                                                          text=row,\n                                                          height=self.button_height,\n                                                          fg_color=self.button_color,\n                                                          text_color=self.text_color,\n                                                          image=self.image_values[i] if self.image_values is not None else None,\n                                                          anchor=self.justify,\n                                                          command=lambda k=row: self._attach_key_press(k), **button_kwargs)\n            self.widgets[self.i].pack(fill=\"x\", pady=2, padx=(self.padding, 0))\n            self.i+=1\n             \n        self.hide = False\n            \n    def destroy_popup(self):\n        self.destroy()\n        self.disable = True\n\n    def place_dropdown(self):\n        self.x_pos = self.attach.winfo_rootx() if self.x is None else self.x + self.attach.winfo_rootx()\n        self.y_pos = self.attach.winfo_rooty() + self.attach.winfo_reqheight() + 5 if self.y is None else self.y + self.attach.winfo_rooty()\n        self.width_new = self.attach.winfo_width() if self.width is None else self.width\n        \n        if self.resize:\n            if self.button_num==1:      \n                self.height_new = self.button_height * self.button_num + 45\n            else:\n                self.height_new = self.button_height * self.button_num + 35\n            if self.height_new>self.height:\n                self.height_new = self.height\n\n        self.geometry('{}x{}+{}+{}'.format(self.width_new, self.height_new,\n                                           self.x_pos, self.y_pos))\n        self.fade_in()\n        self.attributes('-alpha', self.alpha)\n        self.attach.focus()\n\n    def _iconify(self):\n        if self.disable: return\n        if self.hide:\n            self._deiconify()        \n            self.focus()\n            self.hide = False\n            self.place_dropdown()\n            if self.focus_something:\n                self.dummy_entry.pack()\n                self.dummy_entry.focus_set()\n                self.after(100, self.dummy_entry.pack_forget)\n        else:\n            self.withdraw()\n            self.hide = True\n            \n    def _attach_key_press(self, k):\n        self.fade = True\n        if self.command:\n            self.command(k)\n        self.fade = False\n        self.fade_out()\n        self.withdraw()\n        self.hide = True\n            \n    def live_update(self, string=None):\n        if not self.appear: return\n        if self.disable: return\n        if self.fade: return\n        if string:\n            self._deiconify()\n            i=1\n            for key in self.widgets.keys():\n                s = self.widgets[key].cget(\"text\")\n                if not s.startswith(string):\n                    self.widgets[key].pack_forget()\n                else:\n                    self.widgets[key].pack(fill=\"x\", pady=2, padx=(self.padding, 0))\n                    i+=1\n                    \n            if i==1:\n                self.no_match.pack(fill=\"x\", pady=2, padx=(self.padding, 0))\n            else:\n                self.no_match.pack_forget()\n            self.button_num = i\n            self.place_dropdown()\n            \n        else:\n            self.no_match.pack_forget()\n            self.button_num = len(self.values)\n            for key in self.widgets.keys():\n                self.widgets[key].destroy()\n            self._init_buttons()\n            self.place_dropdown()\n            \n        self.frame._parent_canvas.yview_moveto(0.0)\n        self.appear = False\n        \n    def insert(self, value, **kwargs):\n        self.widgets[self.i] = customtkinter.CTkButton(self.frame,\n                                                       text=value,\n                                                       height=self.button_height,\n                                                       fg_color=self.button_color,\n                                                       text_color=self.text_color,\n                                                       anchor=self.justify,\n                                                       command=lambda k=value: self._attach_key_press(k), **kwargs)\n        self.widgets[self.i].pack(fill=\"x\", pady=2, padx=(self.padding, 0))\n        self.i+=1\n        self.values.append(value)\n        \n    def _deiconify(self):\n        if len(self.values)>0:\n            self.deiconify()\n\n    def popup(self, x=None, y=None):\n        self.x = x\n        self.y = y\n        self.hide = True\n        self._iconify()\n        \n    def configure(self, **kwargs):\n        if \"height\" in kwargs:\n            self.height = kwargs.pop(\"height\")\n            self.height_new = self.height\n            \n        if \"alpha\" in kwargs:\n            self.alpha = kwargs.pop(\"alpha\")\n            \n        if \"width\" in kwargs:\n            self.width = kwargs.pop(\"width\")\n            \n        if \"fg_color\" in kwargs:\n            self.frame.configure(fg_color=kwargs.pop(\"fg_color\"))\n            \n        if \"values\" in kwargs:\n            self.values = kwargs.pop(\"values\")\n            self.image_values = None\n            for key in self.widgets.keys():\n                self.widgets[key].destroy()\n            self._init_buttons()\n            \n        if \"image_values\" in kwargs:\n            self.image_values = kwargs.pop(\"image_values\")\n            self.image_values = None if len(self.image_values)!=len(self.values) else self.image_values\n            if self.image_values is not None:\n                i=0\n                for key in self.widgets.keys():\n                    self.widgets[key].configure(image=self.image_values[i])\n                    i+=1\n                    \n        if \"button_color\" in kwargs:\n            for key in self.widgets.keys():\n                self.widgets[key].configure(fg_color=kwargs.pop(\"button_color\"))\n                \n        for key in self.widgets.keys():\n            self.widgets[key].configure(**kwargs)", "\nclass CTkScrollableDropdown(customtkinter.CTkToplevel):\n    \n    def __init__(self, attach, x=None, y=None, button_color=None, height: int = 200, width: int = None,\n                 fg_color=None, button_height: int = 20, justify=\"center\", scrollbar_button_color=None,\n                 scrollbar=True, scrollbar_button_hover_color=None, frame_border_width=2, values=[],\n                 command=None, image_values=[], alpha: float = 0.97, frame_corner_radius=20, double_click=False,\n                 resize=True, frame_border_color=None, text_color=None, autocomplete=False, **button_kwargs):\n        \n        super().__init__(takefocus=1)\n        \n        self.focus()\n        self.alpha = alpha\n        self.attach = attach\n        self.corner = frame_corner_radius\n        self.padding = 0\n        self.focus_something = False\n        self.disable = True\n        \n        if sys.platform.startswith(\"win\"):\n            self.after(100, lambda: self.overrideredirect(True))\n            self.transparent_color = self._apply_appearance_mode(self._fg_color)\n            self.attributes(\"-transparentcolor\", self.transparent_color)\n        elif sys.platform.startswith(\"darwin\"):\n            self.overrideredirect(True)\n            self.transparent_color = 'systemTransparent'\n            self.attributes(\"-transparent\", True)\n            self.focus_something = True\n        else:\n            self.overrideredirect(True)\n            self.transparent_color = '#000001'\n            self.corner = 0\n            self.padding = 18\n            self.withdraw()\n\n        self.hide = True\n        self.attach.bind('<Configure>', lambda e: self._withdraw() if not self.disable else None, add=\"+\")\n        self.attach.winfo_toplevel().bind('<Configure>', lambda e: self._withdraw() if not self.disable else None, add=\"+\")\n        self.attach.winfo_toplevel().bind(\"<Triple-Button-1>\", lambda e: self._withdraw() if not self.disable else None, add=\"+\")        \n        self.attach.winfo_toplevel().bind(\"<Button-3>\", lambda e: self._withdraw() if not self.disable else None, add=\"+\")\n        self.attach.winfo_toplevel().bind(\"<Button-2>\", lambda e: self._withdraw() if not self.disable else None, add=\"+\")\n        \n        self.attributes('-alpha', 0)\n        self.disable = False\n        self.fg_color = customtkinter.ThemeManager.theme[\"CTkFrame\"][\"fg_color\"] if fg_color is None else fg_color\n        self.scroll_button_color = customtkinter.ThemeManager.theme[\"CTkScrollbar\"][\"button_color\"] if scrollbar_button_color is None else scrollbar_button_color\n        self.scroll_hover_color = customtkinter.ThemeManager.theme[\"CTkScrollbar\"][\"button_hover_color\"] if scrollbar_button_hover_color is None else scrollbar_button_hover_color\n        self.frame_border_color = customtkinter.ThemeManager.theme[\"CTkFrame\"][\"border_color\"] if frame_border_color is None else frame_border_color\n        self.button_color = customtkinter.ThemeManager.theme[\"CTkFrame\"][\"top_fg_color\"] if button_color is None else button_color\n        self.text_color = customtkinter.ThemeManager.theme[\"CTkLabel\"][\"text_color\"] if text_color is None else text_color\n        \n        if scrollbar is False:\n            self.scroll_button_color = self.fg_color\n            self.scroll_hover_color = self.fg_color\n            \n        self.frame = customtkinter.CTkScrollableFrame(self, bg_color=self.transparent_color, fg_color=self.fg_color,\n                                        scrollbar_button_hover_color=self.scroll_hover_color,\n                                        corner_radius=self.corner, border_width=frame_border_width,\n                                        scrollbar_button_color=self.scroll_button_color,\n                                        border_color=self.frame_border_color)\n        self.frame._scrollbar.grid_configure(padx=3)\n        self.frame.pack(expand=True, fill=\"both\")\n        self.dummy_entry = customtkinter.CTkEntry(self.frame, fg_color=\"transparent\", border_width=0, height=1, width=1)\n        self.no_match = customtkinter.CTkLabel(self.frame, text=\"No Match\")\n        self.height = height\n        self.height_new = height\n        self.width = width\n        self.command = command\n        self.fade = False\n        self.resize = resize\n        self.autocomplete = autocomplete\n        self.var_update = customtkinter.StringVar()\n        self.appear = False\n        \n        if justify.lower()==\"left\":\n            self.justify = \"w\"\n        elif justify.lower()==\"right\":\n            self.justify = \"e\"\n        else:\n            self.justify = \"c\"\n            \n        self.button_height = button_height\n        self.values = values\n        self.button_num = len(self.values)\n        self.image_values = None if len(image_values)!=len(self.values) else image_values\n        \n        self.resizable(width=False, height=False)\n        self.transient(self.master)\n        self._init_buttons(**button_kwargs)\n\n        # Add binding for different ctk widgets\n        if double_click or self.attach.winfo_name().startswith(\"!ctkentry\") or self.attach.winfo_name().startswith(\"!ctkcombobox\"):\n            self.attach.bind('<Double-Button-1>', lambda e: self._iconify(), add=\"+\")\n        else:\n            self.attach.bind('<Button-1>', lambda e: self._iconify(), add=\"+\")\n\n        if self.attach.winfo_name().startswith(\"!ctkcombobox\"):\n            self.attach._canvas.tag_bind(\"right_parts\", \"<Button-1>\", lambda e: self._iconify())\n            self.attach._canvas.tag_bind(\"dropdown_arrow\", \"<Button-1>\", lambda e: self._iconify())\n            if self.command is None:\n                self.command = self.attach.set\n              \n        if self.attach.winfo_name().startswith(\"!ctkoptionmenu\"):\n            self.attach._canvas.bind(\"<Button-1>\", lambda e: self._iconify())\n            self.attach._text_label.bind(\"<Button-1>\", lambda e: self._iconify())\n            if self.command is None:\n                self.command = self.attach.set\n        \n        self.update_idletasks()\n        self.x = x\n        self.y = y\n\n        if self.autocomplete:\n            self.bind_autocomplete()\n            \n        self.deiconify()\n        self.withdraw()\n        \n        self.attributes(\"-alpha\", self.alpha)\n        \n    def _withdraw(self):\n        if self.hide is False: self.withdraw()\n        self.hide = True\n\n    def _update(self, a, b, c):\n        self.live_update(self.attach._entry.get())\n        \n    def bind_autocomplete(self, ):\n        def appear(x):\n            self.appear = True\n            \n        if self.attach.winfo_name().startswith(\"!ctkcombobox\"):\n            self.attach._entry.configure(textvariable=self.var_update)\n            self.attach._entry.bind(\"<Key>\", appear)\n            self.attach.set(self.values[0])\n            self.var_update.trace_add('write', self._update)\n            \n        if self.attach.winfo_name().startswith(\"!ctkentry\"):\n            self.attach.configure(textvariable=self.var_update)\n            self.attach.bind(\"<Key>\", appear)\n            self.var_update.trace_add('write', self._update)\n        \n    def fade_out(self):\n        for i in range(100,0,-10):\n            if not self.winfo_exists():\n                break\n            self.attributes(\"-alpha\", i/100)\n            self.update()\n            time.sleep(1/100)\n            \n    def fade_in(self):\n        for i in range(0,100,10):\n            if not self.winfo_exists():\n                break\n            self.attributes(\"-alpha\", i/100)\n            self.update()\n            time.sleep(1/100)\n            \n    def _init_buttons(self, **button_kwargs):\n        self.i = 0\n        self.widgets = {}\n        for row in self.values:                                \n            self.widgets[self.i] = customtkinter.CTkButton(self.frame,\n                                                          text=row,\n                                                          height=self.button_height,\n                                                          fg_color=self.button_color,\n                                                          text_color=self.text_color,\n                                                          image=self.image_values[i] if self.image_values is not None else None,\n                                                          anchor=self.justify,\n                                                          command=lambda k=row: self._attach_key_press(k), **button_kwargs)\n            self.widgets[self.i].pack(fill=\"x\", pady=2, padx=(self.padding, 0))\n            self.i+=1\n             \n        self.hide = False\n            \n    def destroy_popup(self):\n        self.destroy()\n        self.disable = True\n\n    def place_dropdown(self):\n        self.x_pos = self.attach.winfo_rootx() if self.x is None else self.x + self.attach.winfo_rootx()\n        self.y_pos = self.attach.winfo_rooty() + self.attach.winfo_reqheight() + 5 if self.y is None else self.y + self.attach.winfo_rooty()\n        self.width_new = self.attach.winfo_width() if self.width is None else self.width\n        \n        if self.resize:\n            if self.button_num==1:      \n                self.height_new = self.button_height * self.button_num + 45\n            else:\n                self.height_new = self.button_height * self.button_num + 35\n            if self.height_new>self.height:\n                self.height_new = self.height\n\n        self.geometry('{}x{}+{}+{}'.format(self.width_new, self.height_new,\n                                           self.x_pos, self.y_pos))\n        self.fade_in()\n        self.attributes('-alpha', self.alpha)\n        self.attach.focus()\n\n    def _iconify(self):\n        if self.disable: return\n        if self.hide:\n            self._deiconify()        \n            self.focus()\n            self.hide = False\n            self.place_dropdown()\n            if self.focus_something:\n                self.dummy_entry.pack()\n                self.dummy_entry.focus_set()\n                self.after(100, self.dummy_entry.pack_forget)\n        else:\n            self.withdraw()\n            self.hide = True\n            \n    def _attach_key_press(self, k):\n        self.fade = True\n        if self.command:\n            self.command(k)\n        self.fade = False\n        self.fade_out()\n        self.withdraw()\n        self.hide = True\n            \n    def live_update(self, string=None):\n        if not self.appear: return\n        if self.disable: return\n        if self.fade: return\n        if string:\n            self._deiconify()\n            i=1\n            for key in self.widgets.keys():\n                s = self.widgets[key].cget(\"text\")\n                if not s.startswith(string):\n                    self.widgets[key].pack_forget()\n                else:\n                    self.widgets[key].pack(fill=\"x\", pady=2, padx=(self.padding, 0))\n                    i+=1\n                    \n            if i==1:\n                self.no_match.pack(fill=\"x\", pady=2, padx=(self.padding, 0))\n            else:\n                self.no_match.pack_forget()\n            self.button_num = i\n            self.place_dropdown()\n            \n        else:\n            self.no_match.pack_forget()\n            self.button_num = len(self.values)\n            for key in self.widgets.keys():\n                self.widgets[key].destroy()\n            self._init_buttons()\n            self.place_dropdown()\n            \n        self.frame._parent_canvas.yview_moveto(0.0)\n        self.appear = False\n        \n    def insert(self, value, **kwargs):\n        self.widgets[self.i] = customtkinter.CTkButton(self.frame,\n                                                       text=value,\n                                                       height=self.button_height,\n                                                       fg_color=self.button_color,\n                                                       text_color=self.text_color,\n                                                       anchor=self.justify,\n                                                       command=lambda k=value: self._attach_key_press(k), **kwargs)\n        self.widgets[self.i].pack(fill=\"x\", pady=2, padx=(self.padding, 0))\n        self.i+=1\n        self.values.append(value)\n        \n    def _deiconify(self):\n        if len(self.values)>0:\n            self.deiconify()\n\n    def popup(self, x=None, y=None):\n        self.x = x\n        self.y = y\n        self.hide = True\n        self._iconify()\n        \n    def configure(self, **kwargs):\n        if \"height\" in kwargs:\n            self.height = kwargs.pop(\"height\")\n            self.height_new = self.height\n            \n        if \"alpha\" in kwargs:\n            self.alpha = kwargs.pop(\"alpha\")\n            \n        if \"width\" in kwargs:\n            self.width = kwargs.pop(\"width\")\n            \n        if \"fg_color\" in kwargs:\n            self.frame.configure(fg_color=kwargs.pop(\"fg_color\"))\n            \n        if \"values\" in kwargs:\n            self.values = kwargs.pop(\"values\")\n            self.image_values = None\n            for key in self.widgets.keys():\n                self.widgets[key].destroy()\n            self._init_buttons()\n            \n        if \"image_values\" in kwargs:\n            self.image_values = kwargs.pop(\"image_values\")\n            self.image_values = None if len(self.image_values)!=len(self.values) else self.image_values\n            if self.image_values is not None:\n                i=0\n                for key in self.widgets.keys():\n                    self.widgets[key].configure(image=self.image_values[i])\n                    i+=1\n                    \n        if \"button_color\" in kwargs:\n            for key in self.widgets.keys():\n                self.widgets[key].configure(fg_color=kwargs.pop(\"button_color\"))\n                \n        for key in self.widgets.keys():\n            self.widgets[key].configure(**kwargs)", ""]}
{"filename": "utils/CTkScrollableDropdown/ctk_scrollable_dropdown_frame.py", "chunked_list": ["'''\nAdvanced Scrollable Dropdown Frame class for customtkinter widgets\nAuthor: Akash Bora\n'''\n\nimport customtkinter\nimport sys\n\nclass CTkScrollableDropdownFrame(customtkinter.CTkFrame):\n    \n    def __init__(self, attach, x=None, y=None, button_color=None, height: int = 200, width: int = None,\n                 fg_color=None, button_height: int = 20, justify=\"center\", scrollbar_button_color=None,\n                 scrollbar=True, scrollbar_button_hover_color=None, frame_border_width=2, values=[],\n                 command=None, image_values=[], double_click=False, frame_corner_radius=True, resize=True, frame_border_color=None,\n                 text_color=None, autocomplete=False, **button_kwargs):\n\n        super().__init__(master=attach.winfo_toplevel(), bg_color=attach.cget(\"bg_color\"))\n        \n        self.attach = attach\n        self.corner = 11 if frame_corner_radius else 0\n        self.padding = 0\n        self.disable = True\n\n        self.hide = True\n        self.attach.bind('<Configure>', lambda e: self._withdraw() if not self.disable else None, add=\"+\")\n        self.attach.winfo_toplevel().bind(\"<Triple-Button-1>\", lambda e: self._withdraw() if not self.disable else None, add=\"+\")\n        self.attach.winfo_toplevel().bind(\"<Button-3>\", lambda e: self._withdraw() if not self.disable else None, add=\"+\")\n        self.attach.winfo_toplevel().bind(\"<Button-2>\", lambda e: self._withdraw() if not self.disable else None, add=\"+\")\n        \n        self.disable = False\n        self.fg_color = customtkinter.ThemeManager.theme[\"CTkFrame\"][\"fg_color\"] if fg_color is None else fg_color\n        self.scroll_button_color = customtkinter.ThemeManager.theme[\"CTkScrollbar\"][\"button_color\"] if scrollbar_button_color is None else scrollbar_button_color\n        self.scroll_hover_color = customtkinter.ThemeManager.theme[\"CTkScrollbar\"][\"button_hover_color\"] if scrollbar_button_hover_color is None else scrollbar_button_hover_color\n        self.frame_border_color = customtkinter.ThemeManager.theme[\"CTkFrame\"][\"border_color\"] if frame_border_color is None else frame_border_color\n        self.button_color = customtkinter.ThemeManager.theme[\"CTkFrame\"][\"top_fg_color\"] if button_color is None else button_color\n        self.text_color = customtkinter.ThemeManager.theme[\"CTkLabel\"][\"text_color\"] if text_color is None else text_color\n        \n        if scrollbar is False:\n            self.scroll_button_color = self.fg_color\n            self.scroll_hover_color = self.fg_color\n            \n        self.frame = customtkinter.CTkScrollableFrame(self, fg_color=self.fg_color, bg_color=attach.cget(\"bg_color\"),\n                                        scrollbar_button_hover_color=self.scroll_hover_color,\n                                        corner_radius=self.corner, border_width=frame_border_width,\n                                        scrollbar_button_color=self.scroll_button_color,\n                                        border_color=self.frame_border_color)\n        self.frame._scrollbar.grid_configure(padx=3)\n        self.frame.pack(expand=True, fill=\"both\")\n        \n        if self.corner==0:\n            self.corner = 21\n            \n        self.dummy_entry = customtkinter.CTkEntry(self.frame, fg_color=\"transparent\", border_width=0, height=1, width=1)\n        self.no_match = customtkinter.CTkLabel(self.frame, text=\"No Match\")\n        self.height = height\n        self.height_new = height\n        self.width = width\n        self.command = command\n        self.fade = False\n        self.resize = resize\n        self.autocomplete = autocomplete\n        self.var_update = customtkinter.StringVar()\n        self.appear = False\n        \n        if justify.lower()==\"left\":\n            self.justify = \"w\"\n        elif justify.lower()==\"right\":\n            self.justify = \"e\"\n        else:\n            self.justify = \"c\"\n            \n        self.button_height = button_height\n        self.values = values\n        self.button_num = len(self.values)\n        self.image_values = None if len(image_values)!=len(self.values) else image_values\n        \n        self._init_buttons(**button_kwargs)\n\n        # Add binding for different ctk widgets\n        if double_click or self.attach.winfo_name().startswith(\"!ctkentry\") or self.attach.winfo_name().startswith(\"!ctkcombobox\"):\n            self.attach.bind('<Double-Button-1>', lambda e: self._iconify(), add=\"+\")\n            self.attach._entry.bind('<FocusOut>', lambda e: self._withdraw() if not self.disable else None, add=\"+\")\n        else:\n            self.attach.bind('<Button-1>', lambda e: self._iconify(), add=\"+\")\n\n        if self.attach.winfo_name().startswith(\"!ctkcombobox\"):\n            self.attach._canvas.tag_bind(\"right_parts\", \"<Button-1>\", lambda e: self._iconify())\n            self.attach._canvas.tag_bind(\"dropdown_arrow\", \"<Button-1>\", lambda e: self._iconify())\n      \n            if self.command is None:\n                self.command = self.attach.set\n              \n        if self.attach.winfo_name().startswith(\"!ctkoptionmenu\"):\n            self.attach._canvas.bind(\"<Button-1>\", lambda e: self._iconify())\n            self.attach._text_label.bind(\"<Button-1>\", lambda e: self._iconify())\n            if self.command is None:\n                self.command = self.attach.set\n        \n        self.x = x\n        self.y = y\n\n        if self.autocomplete:\n            self.bind_autocomplete()\n        \n    def _withdraw(self):\n        if self.hide is False: self.place_forget()\n        self.hide = True\n\n    def _update(self, a, b, c):\n        self.live_update(self.attach._entry.get())\n        \n    def bind_autocomplete(self, ):\n        def appear(x):\n            self.appear = True\n            \n        if self.attach.winfo_name().startswith(\"!ctkcombobox\"):\n            self.attach._entry.configure(textvariable=self.var_update)\n            self.attach.set(self.values[0])\n            self.attach._entry.bind(\"<Key>\", appear)\n            self.var_update.trace_add('write', self._update)\n            \n        if self.attach.winfo_name().startswith(\"!ctkentry\"):\n            self.attach.configure(textvariable=self.var_update)\n            self.attach.bind(\"<Key>\", appear)\n            self.var_update.trace_add('write', self._update)\n            \n    def _init_buttons(self, **button_kwargs):\n        self.i = 0\n        self.widgets = {}\n        for row in self.values:                                \n            self.widgets[self.i] = customtkinter.CTkButton(self.frame,\n                                                          text=row,\n                                                          height=self.button_height,\n                                                          fg_color=self.button_color,\n                                                          text_color=self.text_color,\n                                                          image=self.image_values[i] if self.image_values is not None else None,\n                                                          anchor=self.justify,\n                                                          command=lambda k=row: self._attach_key_press(k), **button_kwargs)\n            self.widgets[self.i].pack(fill=\"x\", pady=2, padx=(self.padding, 0))\n            self.i+=1\n             \n        self.hide = False\n            \n    def destroy_popup(self):\n        self.destroy()\n        self.disable = True\n\n    def place_dropdown(self):\n        self.x_pos = self.attach.winfo_x() if self.x is None else self.x + self.attach.winfo_rootx()\n        self.y_pos = self.attach.winfo_y() + self.attach.winfo_reqheight() + 5 if self.y is None else self.y + self.attach.winfo_rooty()\n        self.width_new = self.attach.winfo_width()-45+self.corner if self.width is None else self.width\n        \n        if self.resize:\n            if self.button_num==1:      \n                self.height_new = self.button_height * self.button_num + 45\n            else:\n                self.height_new = self.button_height * self.button_num + 35\n            if self.height_new>self.height:\n                self.height_new = self.height\n \n        self.frame.configure(width=self.width_new, height=self.height_new)\n        self.place(x=self.x_pos, y=self.y_pos)\n        \n        if sys.platform.startswith(\"darwin\"):\n            self.dummy_entry.pack()\n            self.after(100, self.dummy_entry.pack_forget())\n            \n        self.lift()\n        self.attach.focus()\n   \n    def _iconify(self):\n        if self.disable: return\n        if self.hide:       \n            self.hide = False\n            self.place_dropdown()\n        else:\n            self.place_forget()\n            self.hide = True\n            \n    def _attach_key_press(self, k):\n        self.fade = True\n        if self.command:\n            self.command(k)\n        self.fade = False\n        self.place_forget()\n        self.hide = True\n            \n    def live_update(self, string=None):\n        if not self.appear: return\n        if self.disable: return\n        if self.fade: return\n        if string:\n            self._deiconify()\n            i=1\n            for key in self.widgets.keys():\n                s = self.widgets[key].cget(\"text\")\n                if not s.startswith(string):\n                    self.widgets[key].pack_forget()\n                else:\n                    self.widgets[key].pack(fill=\"x\", pady=2, padx=(self.padding, 0))\n                    i+=1\n                    \n            if i==1:\n                self.no_match.pack(fill=\"x\", pady=2, padx=(self.padding, 0))\n            else:\n                self.no_match.pack_forget()\n            self.button_num = i\n            self.place_dropdown()\n            \n        else:\n            self.no_match.pack_forget()\n            self.button_num = len(self.values)\n            for key in self.widgets.keys():\n                self.widgets[key].destroy()\n            self._init_buttons()\n            self.place_dropdown()\n            \n        self.frame._parent_canvas.yview_moveto(0.0)\n        self.appear = False\n        \n    def insert(self, value, **kwargs):\n        self.widgets[self.i] = customtkinter.CTkButton(self.frame,\n                                                       text=value,\n                                                       height=self.button_height,\n                                                       fg_color=self.button_color,\n                                                       text_color=self.text_color,\n                                                       anchor=self.justify,\n                                                       command=lambda k=value: self._attach_key_press(k), **kwargs)\n        self.widgets[self.i].pack(fill=\"x\", pady=2, padx=(self.padding, 0))\n        self.i+=1\n        self.values.append(value)\n        \n    def _deiconify(self):\n        if len(self.values)>0:\n            self.pack_forget()\n\n    def popup(self, x=None, y=None):\n        self.x = x\n        self.y = y\n        self.hide = True\n        self._iconify()\n        \n    def configure(self, **kwargs):\n        if \"height\" in kwargs:\n            self.height = kwargs.pop(\"height\")\n            self.height_new = self.height\n            \n        if \"alpha\" in kwargs:\n            self.alpha = kwargs.pop(\"alpha\")\n            \n        if \"width\" in kwargs:\n            self.width = kwargs.pop(\"width\")\n            \n        if \"fg_color\" in kwargs:\n            self.frame.configure(fg_color=kwargs.pop(\"fg_color\"))\n            \n        if \"values\" in kwargs:\n            self.values = kwargs.pop(\"values\")\n            self.image_values = None\n            for key in self.widgets.keys():\n                self.widgets[key].destroy()\n            self._init_buttons()\n            \n        if \"image_values\" in kwargs:\n            self.image_values = kwargs.pop(\"image_values\")\n            self.image_values = None if len(self.image_values)!=len(self.values) else self.image_values\n            if self.image_values is not None:\n                i=0\n                for key in self.widgets.keys():\n                    self.widgets[key].configure(image=self.image_values[i])\n                    i+=1\n                    \n        if \"button_color\" in kwargs:\n            for key in self.widgets.keys():\n                self.widgets[key].configure(fg_color=kwargs.pop(\"button_color\"))\n                \n        for key in self.widgets.keys():\n            self.widgets[key].configure(**kwargs)", "class CTkScrollableDropdownFrame(customtkinter.CTkFrame):\n    \n    def __init__(self, attach, x=None, y=None, button_color=None, height: int = 200, width: int = None,\n                 fg_color=None, button_height: int = 20, justify=\"center\", scrollbar_button_color=None,\n                 scrollbar=True, scrollbar_button_hover_color=None, frame_border_width=2, values=[],\n                 command=None, image_values=[], double_click=False, frame_corner_radius=True, resize=True, frame_border_color=None,\n                 text_color=None, autocomplete=False, **button_kwargs):\n\n        super().__init__(master=attach.winfo_toplevel(), bg_color=attach.cget(\"bg_color\"))\n        \n        self.attach = attach\n        self.corner = 11 if frame_corner_radius else 0\n        self.padding = 0\n        self.disable = True\n\n        self.hide = True\n        self.attach.bind('<Configure>', lambda e: self._withdraw() if not self.disable else None, add=\"+\")\n        self.attach.winfo_toplevel().bind(\"<Triple-Button-1>\", lambda e: self._withdraw() if not self.disable else None, add=\"+\")\n        self.attach.winfo_toplevel().bind(\"<Button-3>\", lambda e: self._withdraw() if not self.disable else None, add=\"+\")\n        self.attach.winfo_toplevel().bind(\"<Button-2>\", lambda e: self._withdraw() if not self.disable else None, add=\"+\")\n        \n        self.disable = False\n        self.fg_color = customtkinter.ThemeManager.theme[\"CTkFrame\"][\"fg_color\"] if fg_color is None else fg_color\n        self.scroll_button_color = customtkinter.ThemeManager.theme[\"CTkScrollbar\"][\"button_color\"] if scrollbar_button_color is None else scrollbar_button_color\n        self.scroll_hover_color = customtkinter.ThemeManager.theme[\"CTkScrollbar\"][\"button_hover_color\"] if scrollbar_button_hover_color is None else scrollbar_button_hover_color\n        self.frame_border_color = customtkinter.ThemeManager.theme[\"CTkFrame\"][\"border_color\"] if frame_border_color is None else frame_border_color\n        self.button_color = customtkinter.ThemeManager.theme[\"CTkFrame\"][\"top_fg_color\"] if button_color is None else button_color\n        self.text_color = customtkinter.ThemeManager.theme[\"CTkLabel\"][\"text_color\"] if text_color is None else text_color\n        \n        if scrollbar is False:\n            self.scroll_button_color = self.fg_color\n            self.scroll_hover_color = self.fg_color\n            \n        self.frame = customtkinter.CTkScrollableFrame(self, fg_color=self.fg_color, bg_color=attach.cget(\"bg_color\"),\n                                        scrollbar_button_hover_color=self.scroll_hover_color,\n                                        corner_radius=self.corner, border_width=frame_border_width,\n                                        scrollbar_button_color=self.scroll_button_color,\n                                        border_color=self.frame_border_color)\n        self.frame._scrollbar.grid_configure(padx=3)\n        self.frame.pack(expand=True, fill=\"both\")\n        \n        if self.corner==0:\n            self.corner = 21\n            \n        self.dummy_entry = customtkinter.CTkEntry(self.frame, fg_color=\"transparent\", border_width=0, height=1, width=1)\n        self.no_match = customtkinter.CTkLabel(self.frame, text=\"No Match\")\n        self.height = height\n        self.height_new = height\n        self.width = width\n        self.command = command\n        self.fade = False\n        self.resize = resize\n        self.autocomplete = autocomplete\n        self.var_update = customtkinter.StringVar()\n        self.appear = False\n        \n        if justify.lower()==\"left\":\n            self.justify = \"w\"\n        elif justify.lower()==\"right\":\n            self.justify = \"e\"\n        else:\n            self.justify = \"c\"\n            \n        self.button_height = button_height\n        self.values = values\n        self.button_num = len(self.values)\n        self.image_values = None if len(image_values)!=len(self.values) else image_values\n        \n        self._init_buttons(**button_kwargs)\n\n        # Add binding for different ctk widgets\n        if double_click or self.attach.winfo_name().startswith(\"!ctkentry\") or self.attach.winfo_name().startswith(\"!ctkcombobox\"):\n            self.attach.bind('<Double-Button-1>', lambda e: self._iconify(), add=\"+\")\n            self.attach._entry.bind('<FocusOut>', lambda e: self._withdraw() if not self.disable else None, add=\"+\")\n        else:\n            self.attach.bind('<Button-1>', lambda e: self._iconify(), add=\"+\")\n\n        if self.attach.winfo_name().startswith(\"!ctkcombobox\"):\n            self.attach._canvas.tag_bind(\"right_parts\", \"<Button-1>\", lambda e: self._iconify())\n            self.attach._canvas.tag_bind(\"dropdown_arrow\", \"<Button-1>\", lambda e: self._iconify())\n      \n            if self.command is None:\n                self.command = self.attach.set\n              \n        if self.attach.winfo_name().startswith(\"!ctkoptionmenu\"):\n            self.attach._canvas.bind(\"<Button-1>\", lambda e: self._iconify())\n            self.attach._text_label.bind(\"<Button-1>\", lambda e: self._iconify())\n            if self.command is None:\n                self.command = self.attach.set\n        \n        self.x = x\n        self.y = y\n\n        if self.autocomplete:\n            self.bind_autocomplete()\n        \n    def _withdraw(self):\n        if self.hide is False: self.place_forget()\n        self.hide = True\n\n    def _update(self, a, b, c):\n        self.live_update(self.attach._entry.get())\n        \n    def bind_autocomplete(self, ):\n        def appear(x):\n            self.appear = True\n            \n        if self.attach.winfo_name().startswith(\"!ctkcombobox\"):\n            self.attach._entry.configure(textvariable=self.var_update)\n            self.attach.set(self.values[0])\n            self.attach._entry.bind(\"<Key>\", appear)\n            self.var_update.trace_add('write', self._update)\n            \n        if self.attach.winfo_name().startswith(\"!ctkentry\"):\n            self.attach.configure(textvariable=self.var_update)\n            self.attach.bind(\"<Key>\", appear)\n            self.var_update.trace_add('write', self._update)\n            \n    def _init_buttons(self, **button_kwargs):\n        self.i = 0\n        self.widgets = {}\n        for row in self.values:                                \n            self.widgets[self.i] = customtkinter.CTkButton(self.frame,\n                                                          text=row,\n                                                          height=self.button_height,\n                                                          fg_color=self.button_color,\n                                                          text_color=self.text_color,\n                                                          image=self.image_values[i] if self.image_values is not None else None,\n                                                          anchor=self.justify,\n                                                          command=lambda k=row: self._attach_key_press(k), **button_kwargs)\n            self.widgets[self.i].pack(fill=\"x\", pady=2, padx=(self.padding, 0))\n            self.i+=1\n             \n        self.hide = False\n            \n    def destroy_popup(self):\n        self.destroy()\n        self.disable = True\n\n    def place_dropdown(self):\n        self.x_pos = self.attach.winfo_x() if self.x is None else self.x + self.attach.winfo_rootx()\n        self.y_pos = self.attach.winfo_y() + self.attach.winfo_reqheight() + 5 if self.y is None else self.y + self.attach.winfo_rooty()\n        self.width_new = self.attach.winfo_width()-45+self.corner if self.width is None else self.width\n        \n        if self.resize:\n            if self.button_num==1:      \n                self.height_new = self.button_height * self.button_num + 45\n            else:\n                self.height_new = self.button_height * self.button_num + 35\n            if self.height_new>self.height:\n                self.height_new = self.height\n \n        self.frame.configure(width=self.width_new, height=self.height_new)\n        self.place(x=self.x_pos, y=self.y_pos)\n        \n        if sys.platform.startswith(\"darwin\"):\n            self.dummy_entry.pack()\n            self.after(100, self.dummy_entry.pack_forget())\n            \n        self.lift()\n        self.attach.focus()\n   \n    def _iconify(self):\n        if self.disable: return\n        if self.hide:       \n            self.hide = False\n            self.place_dropdown()\n        else:\n            self.place_forget()\n            self.hide = True\n            \n    def _attach_key_press(self, k):\n        self.fade = True\n        if self.command:\n            self.command(k)\n        self.fade = False\n        self.place_forget()\n        self.hide = True\n            \n    def live_update(self, string=None):\n        if not self.appear: return\n        if self.disable: return\n        if self.fade: return\n        if string:\n            self._deiconify()\n            i=1\n            for key in self.widgets.keys():\n                s = self.widgets[key].cget(\"text\")\n                if not s.startswith(string):\n                    self.widgets[key].pack_forget()\n                else:\n                    self.widgets[key].pack(fill=\"x\", pady=2, padx=(self.padding, 0))\n                    i+=1\n                    \n            if i==1:\n                self.no_match.pack(fill=\"x\", pady=2, padx=(self.padding, 0))\n            else:\n                self.no_match.pack_forget()\n            self.button_num = i\n            self.place_dropdown()\n            \n        else:\n            self.no_match.pack_forget()\n            self.button_num = len(self.values)\n            for key in self.widgets.keys():\n                self.widgets[key].destroy()\n            self._init_buttons()\n            self.place_dropdown()\n            \n        self.frame._parent_canvas.yview_moveto(0.0)\n        self.appear = False\n        \n    def insert(self, value, **kwargs):\n        self.widgets[self.i] = customtkinter.CTkButton(self.frame,\n                                                       text=value,\n                                                       height=self.button_height,\n                                                       fg_color=self.button_color,\n                                                       text_color=self.text_color,\n                                                       anchor=self.justify,\n                                                       command=lambda k=value: self._attach_key_press(k), **kwargs)\n        self.widgets[self.i].pack(fill=\"x\", pady=2, padx=(self.padding, 0))\n        self.i+=1\n        self.values.append(value)\n        \n    def _deiconify(self):\n        if len(self.values)>0:\n            self.pack_forget()\n\n    def popup(self, x=None, y=None):\n        self.x = x\n        self.y = y\n        self.hide = True\n        self._iconify()\n        \n    def configure(self, **kwargs):\n        if \"height\" in kwargs:\n            self.height = kwargs.pop(\"height\")\n            self.height_new = self.height\n            \n        if \"alpha\" in kwargs:\n            self.alpha = kwargs.pop(\"alpha\")\n            \n        if \"width\" in kwargs:\n            self.width = kwargs.pop(\"width\")\n            \n        if \"fg_color\" in kwargs:\n            self.frame.configure(fg_color=kwargs.pop(\"fg_color\"))\n            \n        if \"values\" in kwargs:\n            self.values = kwargs.pop(\"values\")\n            self.image_values = None\n            for key in self.widgets.keys():\n                self.widgets[key].destroy()\n            self._init_buttons()\n            \n        if \"image_values\" in kwargs:\n            self.image_values = kwargs.pop(\"image_values\")\n            self.image_values = None if len(self.image_values)!=len(self.values) else self.image_values\n            if self.image_values is not None:\n                i=0\n                for key in self.widgets.keys():\n                    self.widgets[key].configure(image=self.image_values[i])\n                    i+=1\n                    \n        if \"button_color\" in kwargs:\n            for key in self.widgets.keys():\n                self.widgets[key].configure(fg_color=kwargs.pop(\"button_color\"))\n                \n        for key in self.widgets.keys():\n            self.widgets[key].configure(**kwargs)", ""]}
{"filename": "utils/CTkScrollableDropdown/__init__.py", "chunked_list": ["\"\"\"\nCustomTkinter Scrollable Dropdown Menu\nAuthor: Akash Bora\nLicense: MIT\nThis is a custom dropdown menu for customtkinter.\nHomepage: https://github.com/Akascape/CTkScrollableDropdown\n\"\"\"\n\n__version__ = '0.9'\n", "__version__ = '0.9'\n\nfrom .ctk_scrollable_dropdown import CTkScrollableDropdown\nfrom .ctk_scrollable_dropdown_frame import CTkScrollableDropdownFrame\n"]}
{"filename": "utils/_get_supported_languages/get_supported_languages.py", "chunked_list": ["import yaml, os\nfrom collections import defaultdict\n\ndef find_matching_tuples(lst):\n    groups = defaultdict(list)\n    for t in lst:\n        groups[t[0]].append(t)\n\n    matching_groups = [v for v in groups.values() if len(v) > 1]\n\n    return matching_groups", "\ndef dialogue(l: list):\n    run = True\n    while run:\n        question = ' or '.join([f\"{i[1:]}\" for i in l])\n        answer = input(f\"{question}?\\n(write the answer with the serial number of the variant): \")\n        print()\n        try:\n            result = int(answer)\n            if result <= len(l):return result-1\n        except:\n            pass", "\ndef load_file(name):\n    with open(name, \"r\", encoding=\"utf-8\") as file:\n        return file.read()\n\n\nif __name__ == \"__main__\":\n    main_folder = os.path.dirname(os.path.abspath(__file__))\n\n    minecraft_languages = load_file(main_folder+\"\\\\minecraft_languages.txt\").split(\"\\t\")\n    google_languages = load_file(main_folder+\"\\\\google_languages.txt\").replace(\"\\n\", \"\\t\").split(\"\\t\")\n    #print(minecraft_languages, google_languages)\n    \n    language = minecraft_languages[3::8]\n    in_game = minecraft_languages[4::8]\n    s_list = list(zip(language, in_game))\n    \n    g_language = google_languages[0::2]\n    g_code = google_languages[1::2]\n    g_list = list(zip(g_language, g_code))\n\n    result = []\n\n    for google_lang, google_code in g_list:\n        for mc_lang, mc_code in s_list:\n            if google_lang in mc_lang:\n                result.append((google_lang, mc_lang, google_code, mc_code))\n\n    \n    for variants in find_matching_tuples(result):\n        del variants[dialogue(variants)]\n        for i in variants:\n            result.remove(i)\n    \n    saving = [(google_lang, {\"google_code\": google_code, \"mc_code\": mc_code}) for google_lang, mc_lang, google_code, mc_code in result]\n\n    save = dict(saving)\n    with open(main_folder+\"\\\\supported_languages.yaml\", 'w', encoding=\"utf-8\") as f:\n        yaml.dump(save, f, encoding=\"utf-8\")"]}
{"filename": "ModTranslator/__init__.py", "chunked_list": ["\nfrom .mod_translator import *"]}
{"filename": "ModTranslator/test/test.py", "chunked_list": ["import os, sys, logging\nfrom shutil import copyfile\n\n# import ModTranslator\nmain_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\nsys.path.insert(1, main_dir)\nfrom mods_translator import ModsTranslator\n\ndef main():\n\n    # \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043f\u0443\u0442\u044c \u043a \u0442\u0435\u043a\u0443\u0449\u0435\u0439 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0438\n    current_dir = os.path.dirname(os.path.abspath(__file__))\n\n    test_file = \"test_file.jar\"\n    verification_file = \"check.jar\"\n    path_test_file = os.path.join(current_dir, test_file)\n    path_verification_file = os.path.join(current_dir, verification_file)\n\n    #\u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043d\u0430 \u043d\u0430\u043b\u0438\u0447\u0438\u0435 \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0433\u043e \u0444\u0430\u0439\u043b\u0430.\n    if os.path.isfile( path_test_file ):\n\n        #\u041a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0438 \u043f\u0435\u0440\u0435\u0438\u043c\u0435\u043d\u043e\u0432\u0430\u0442\u044c \u0442\u0435\u0441\u0442\u043e\u0432\u044b\u0439 \u0444\u0430\u0439\u043b. \n        copyfile(path_test_file, path_verification_file)\n\n        file = [verification_file]\n\n        translator = ModsTranslator()\n        # add handler\n        handler = logging.StreamHandler()\n        handler.setFormatter(translator.FORMATTER)\n        logger = translator.get_logger()\n        logger.addHandler(handler)\n        # start of text translation\n        translator.translate(\"ru\", current_dir, file)\n        \n        #Deleting verification files.\n        if os.path.isfile(path_verification_file):\n            os.remove(path_verification_file)\n            logger.info(f\"clone {verification_file} deleted.\")", "def main():\n\n    # \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043f\u0443\u0442\u044c \u043a \u0442\u0435\u043a\u0443\u0449\u0435\u0439 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0438\n    current_dir = os.path.dirname(os.path.abspath(__file__))\n\n    test_file = \"test_file.jar\"\n    verification_file = \"check.jar\"\n    path_test_file = os.path.join(current_dir, test_file)\n    path_verification_file = os.path.join(current_dir, verification_file)\n\n    #\u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043d\u0430 \u043d\u0430\u043b\u0438\u0447\u0438\u0435 \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0433\u043e \u0444\u0430\u0439\u043b\u0430.\n    if os.path.isfile( path_test_file ):\n\n        #\u041a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0438 \u043f\u0435\u0440\u0435\u0438\u043c\u0435\u043d\u043e\u0432\u0430\u0442\u044c \u0442\u0435\u0441\u0442\u043e\u0432\u044b\u0439 \u0444\u0430\u0439\u043b. \n        copyfile(path_test_file, path_verification_file)\n\n        file = [verification_file]\n\n        translator = ModsTranslator()\n        # add handler\n        handler = logging.StreamHandler()\n        handler.setFormatter(translator.FORMATTER)\n        logger = translator.get_logger()\n        logger.addHandler(handler)\n        # start of text translation\n        translator.translate(\"ru\", current_dir, file)\n        \n        #Deleting verification files.\n        if os.path.isfile(path_verification_file):\n            os.remove(path_verification_file)\n            logger.info(f\"clone {verification_file} deleted.\")", "\nif __name__ == '__main__':\n    main()"]}
{"filename": "ModTranslator/mod_translator/check_mods_translation.py", "chunked_list": ["import os\nfrom typing import Optional, Tuple, Union, Callable\nfrom .path_to_languages import PathToLanguages\n\nclass CheckModsTranslation:\n    def __init__(self, \n                 target_language_code: str,\n                 directory: str,\n                 mod_files: Union[list[str], None] = None,\n                 exception_handler: Union[Callable[[str], None], None] = None) -> None:\n        \n        if not target_language_code.endswith(\".json\"):\n            target_language_code += \".json\"\n        \n        self._translated_mods: list = []\n        self._untranslated_mods: list = []\n        self._mods_with_no_languages: list = []\n        \n        self._directory = self._check_the_path(directory)\n        self._mod_files = mod_files if mod_files else os.listdir(self._directory)\n        self._mod_files = self._filter_files_by_extension(self._mod_files, \".jar\")\n        self._exception_handler = exception_handler\n\n        for file_name in list( self._mod_files ):\n\n            #\u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0430\u0431\u0441\u043e\u043b\u044e\u0442\u043d\u043e\u0433\u043e \u043f\u0443\u0442\u0438 \u043c\u043e\u0434\u0430.\n            file_path = os.path.join(self._directory, file_name)\n            \n            if not os.path.isfile(file_path):\n                comment = f\"no file found {file_name}.\"\n                if self._exception_handler:\n                    self._exception_handler(comment)\n                    continue\n                else:\n                    raise FileNotFoundError(comment)\n            \n            manager = PathToLanguages(file_path)\n\n            if not manager.isFolderWithTranslations():\n                self._mods_with_no_languages.append(file_name)\n\n            elif manager.isNecessaryTranslation(target_language_code):\n                self._translated_mods.append(file_name)\n\n            else:\n                self._untranslated_mods.append(file_name)\n    \n    def get_all(self):\n        return (self._translated_mods, \n                self._untranslated_mods, \n                self._mods_with_no_languages)\n\n    def get_translated_mods(self):\n        return self._translated_mods\n    \n    def get_untranslated_mods(self):\n        return self._untranslated_mods\n    \n    def get_mods_with_no_languages(self):\n        return self._mods_with_no_languages\n\n    @staticmethod\n    def _filter_files_by_extension(file_names, desired_extension):\n        filtered_files = list(filter(lambda file: file.endswith(desired_extension), file_names))\n        return filtered_files\n    \n    @staticmethod\n    def _check_the_path(folder: str) -> str:\n        \"\"\"check the folder path for errors.\"\"\"\n\n        if isinstance(folder, str):\n            if not os.path.isdir(folder):\n                raise NotADirectoryError(f\"Directory '{folder}' does not exist.\")\n        else:\n            raise TypeError(\"Directory must be a string.\")\n        return folder"]}
{"filename": "ModTranslator/mod_translator/mod_translator.py", "chunked_list": ["__author__ = 'Steklyashka'\n\nfrom typing import List, Optional, Tuple, Union, Callable\nfrom json import loads\nfrom shutil import copyfile\nimport os, logging\nfrom .translator import Translator\nfrom .zip_file_manager import ZipFileManager\nfrom .path_to_languages import PathToLanguages\nfrom .check_mods_translation import CheckModsTranslation", "from .path_to_languages import PathToLanguages\nfrom .check_mods_translation import CheckModsTranslation\n\nclass ModsTranslator:\n    def __init__(self,\n                 comment: str = \"The translation is done automatically.\",\n                 supported_languages: Union[dict, None] = None,):\n        self.COMMENT = f\"//{comment}\\n\"\n        SUPPORT_LANGUAGES = self._load_supported_languages()\n        self._supported_languages = supported_languages if supported_languages else SUPPORT_LANGUAGES\n        \n        self.FORMATTER = logging.Formatter('%(asctime)s [%(levelname)s] %(message)s', datefmt='%H:%M:%S')\n        self._logger = self._create_logger(self.FORMATTER)\n    \n    def _load_supported_languages(self):\n        # \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043f\u0443\u0442\u044c \u043a \u0442\u0435\u043a\u0443\u0449\u0435\u0439 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0438\n        main_dir = os.path.dirname(os.path.abspath(__file__))\n\n        with open(os.path.join(main_dir, \"supported_languages.json\"), 'r', encoding=\"utf8\") as f:\n            SUPPORT_LANGUAGES = loads(f.read())\n        \n        return SUPPORT_LANGUAGES\n\n    def translate(self,\n                 target_language: str,\n                 directory: str,\n                 mod_files: Union[List[str], None] = None,\n                 directory_of_saves: Union[str, None] = None,\n                 startwith: str = \"(Auto)\"):\n        \"\"\"\n        target_language - \u044f\u0437\u044b\u043a \u043d\u0430 \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043d\u0443\u0436\u043d\u043e \u043f\u0435\u0440\u0435\u0432\u0435\u0441\u0442\u0438,\n        directory - \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u044f \u0441 \u043c\u043e\u0434\u0430\u043c\u0438,\n        mod_files - \u0441\u043f\u0438\u0441\u043e\u043a \u043f\u0435\u0440\u0435\u0432\u043e\u0434\u0438\u043c\u044b\u0445 \u043c\u043e\u0434\u043e\u0432 \u0441 \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043d\u0438\u0435\u043c jar,\n        \"\"\"\n\n        FROM_LANGUAGE = \"en_us.json\"\n        target_language_code: str = self._supported_languages[target_language]\n        if not target_language_code.endswith(\".json\"):\n            target_language_code += \".json\"\n        self._directory = directory\n        self._mod_files = self._adding_extension_to_files(mod_files, \".jar\") if mod_files else None\n        self._directory_of_saves = CheckModsTranslation._check_the_path(directory_of_saves) if directory_of_saves else self._directory\n        self._startwith = startwith\n        \n        check_mods = CheckModsTranslation(target_language_code,\n                                          self._directory,\n                                          self._mod_files,\n                                          self._exception_handler)\n        untranslated_mods = check_mods.get_untranslated_mods()\n\n        for mod_name in untranslated_mods:\n            #\u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0430\u0431\u0441\u043e\u043b\u044e\u0442\u043d\u043e\u0433\u043e \u043f\u0443\u0442\u0438 \u043c\u043e\u0434\u0430.\n            file_path = os.path.join(self._directory, mod_name)\n\n            #\u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043f\u0443\u0442\u044c \u0438 \u043f\u0435\u0440\u0435\u0432\u043e\u0434\u044b \u0438\u0437 \u043c\u043e\u0434\u0430.\n            for path in PathToLanguages(file_path).getFolders():\n                # set the paths to the working files\n                from_file = os.path.join(path, FROM_LANGUAGE).replace(\"\\\\\", \"/\")\n                to_file = os.path.join(path, target_language_code).replace(\"\\\\\", \"/\")\n                \n                file_contents: dict = loads(ZipFileManager.read_file_in_ZipFile(file_path, from_file))\n                texts = list(file_contents.values())\n                \n                try:\n                    # get translation\n                    translation = Translator().translate( texts, target_language )\n                except TypeError: # texts has elements not of type str\n                    self._logger.warning(f\"unable to translate {mod_name} due to broken structure.\")\n                    continue\n\n                # \u041f\u043e\u0434\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 \u043f\u0435\u0440\u0435\u0432\u043e\u0434\u043e\u0432 \u043a \u043a\u043b\u044e\u0447\u0430\u043c.\n                result = dict( zip( file_contents.keys(), translation ) )\n\n                # save\n                self._save(mod_name, to_file, str(result))\n    \n    def get_logger(self):\n        return self._logger\n    \n    def _exception_handler(self, comment: str):\n        self._logger.warning(f\"{comment}\")\n    \n    @staticmethod\n    def _adding_extension_to_files(file_names: List[str], desired_extension):\n        fun = lambda file: file if file.endswith(desired_extension) else file+desired_extension\n        mods = list(map(fun, file_names))\n        return mods\n    \n    @staticmethod\n    def _create_logger(formatter: logging.Formatter) -> logging.Logger:\n        \"\"\"creates and returns a logger.\"\"\"\n        \n        file = os.path.basename(__file__)  # \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0435 \u0444\u0430\u0439\u043b\u0430\n        file_name = os.path.splitext(file)[0]  # \u0418\u0437\u0432\u043b\u0435\u043a\u0430\u0435\u043c \u0438\u043c\u044f \u0444\u0430\u0439\u043b\u0430 \u0431\u0435\u0437 \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043d\u0438\u044f\n    \n        # create logger\n        logger = logging.getLogger(file_name)\n        logger.setLevel(logging.DEBUG)\n\n        # \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u0430 \u0434\u043b\u044f \u0437\u0430\u043f\u0438\u0441\u0438 \u043b\u043e\u0433\u043e\u0432 \u0432 \u0444\u0430\u0439\u043b\n        file_dir = os.path.dirname(__file__)\n        file_handler = logging.FileHandler(f\"{file_dir}\\\\{file_name}.log\", mode='w', encoding='utf-8')\n        file_handler.setLevel(logging.DEBUG)\n        file_handler.setFormatter(formatter)\n\n        # \u0414\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u0430 \u0432 \u043b\u043e\u0433\u0433\u0435\u0440\n        logger.addHandler(file_handler)\n\n        return logger\n    \n    def _save(self, zip_mod_name: str, file_name: str, string: str):\n        \"\"\"Saving changes.\"\"\"\n\n        zip_file = os.path.join(self._directory_of_saves, zip_mod_name)\n\n        if not self._directory_of_saves is self._directory:\n            from_file_path = os.path.join(self._directory, zip_mod_name)\n            to_file_path = os.path.join(self._directory_of_saves, zip_mod_name)\n            copyfile(from_file_path, to_file_path)\n\n        ZipFileManager.adding_a_file( zip_file, file_name, self.COMMENT + string )\n        self._logger.info(f\"mod {zip_mod_name} has been saved\")"]}
{"filename": "ModTranslator/mod_translator/__init__.py", "chunked_list": ["\nfrom .mod_translator import ModsTranslator\nfrom .check_mods_translation import CheckModsTranslation"]}
{"filename": "ModTranslator/mod_translator/zip_file_manager.py", "chunked_list": ["__author__ = 'Steklyashka'\n\nimport zipfile\n\nclass ZipFileManager:\n    \"\"\"\u041c\u0435\u043d\u0435\u0434\u0436\u0435\u0440 \u0434\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441 zip-\u0444\u0430\u0439\u043b\u0430\u043c\u0438.\"\"\"\n\n    @staticmethod\n    def read_ZipFile(jarFile) -> list[str]:\n        \"\"\"\u0412\u043e\u0437\u0440\u0430\u0449\u0430\u0435\u0442 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u043c\u043e\u0435 \u0444\u0430\u0439\u043b\u0430.\"\"\"\n        \n        with zipfile.ZipFile(jarFile, 'r') as z:\n            return z.namelist()\n    \n    @staticmethod\n    def read_file_in_ZipFile(zip_file: str, file: str) -> str:\n        \"\"\"\n        \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u0442 zip \u0444\u0430\u0439\u043b \u0438 \u0444\u0430\u0439\u043b \u0432 \u043d\u0451\u043c \u043b\u0435\u0436\u0430\u0449\u0438\u0439.\n        \u0412\u043e\u0437\u0440\u0430\u0449\u0430\u0435\u0442 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u043c\u043e\u0435 \u044d\u0442\u043e\u0433\u043e \u0444\u0430\u0439\u043b\u0430.\n        \"\"\"\n        with zipfile.ZipFile(zip_file, \"r\", allowZip64=False) as zf,  \\\n            zf.open(file, \"r\") as f:\n\n            return f.read().decode('utf-8')\n    \n    @staticmethod\n    def adding_a_file(zip_file: str, file: str, string: str):\n        \"\"\"\u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u0442 \u0444\u0430\u0439\u043b \u0432 zip \u0444\u0430\u0439\u043b. \"\"\"\n        \n        with zipfile.ZipFile(zip_file, \"a\", allowZip64=False) as z,  \\\n            z.open(file, \"w\") as f:\n\n            f.write( string.encode('utf-8') )", "\n"]}
{"filename": "ModTranslator/mod_translator/translator.py", "chunked_list": ["__author__ = 'Steklyashka'\n\nfrom typing import Optional, Tuple, Union, Callable, Dict\nfrom googletrans.constants import DEFAULT_CLIENT_SERVICE_URLS, DEFAULT_RAISE_EXCEPTION, DEFAULT_USER_AGENT\nfrom googletrans.models import Translated\nfrom googletrans import Translator as google_Translator\nimport sys\n\nimport httpcore\nfrom httpx import Timeout", "import httpcore\nfrom httpx import Timeout\n\nsys.setrecursionlimit(100)\n\n#pip3 install googletrans==3.1.0a0\n\n\nclass Translator(google_Translator):\n\t\"\"\"Google Translate ajax API implementation class\n\n    You have to create an instance of Translator to use this API\n\n    :param service_urls: google translate url list. URLs will be used randomly.\n                         For example ``['translate.google.com', 'translate.google.co.kr']``\n                         To preferably use the non webapp api, service url should be translate.googleapis.com\n    :type service_urls: a sequence of strings\n\n    :param user_agent: the User-Agent header to send when making requests.\n    :type user_agent: :class:`str`\n\n    :param proxies: proxies configuration.\n                    Dictionary mapping protocol or protocol and host to the URL of the proxy\n                    For example ``{'http': 'foo.bar:3128', 'http://host.name': 'foo.bar:4012'}``\n    :type proxies: dictionary\n\n    :param timeout: Definition of timeout for httpx library.\n                    Will be used for every request.\n    :type timeout: number or a double of numbers\n    :param raise_exception: if `True` then raise exception if smth will go wrong\n    :type raise_exception: boolean\n    \"\"\"\n    \n\tdef __init__(self,\n\t      \t\t service_urls = DEFAULT_CLIENT_SERVICE_URLS, user_agent: str = DEFAULT_USER_AGENT,\n\t\t  \t\t raise_exception = DEFAULT_RAISE_EXCEPTION,\n          \t\t proxies: Union[Dict[str, httpcore.SyncHTTPTransport], None] = None,\n          \t\t timeout: Union[Timeout, None] = None,\n          \t\t http2: bool = True):\n\t\tsuper().__init__(service_urls, user_agent, raise_exception, proxies, timeout, http2)  # type: ignore\n\n\tdef translate(self,\n\t       text: Union[str, list[str]],\n\t\t   dest='en',\n\t\t   src='auto',\n\t\t   **kwargs) -> Union[str, list[str]]:\n\t\t\"\"\"\u0412\u043e\u0437\u0440\u0430\u0449\u0430\u0435\u0442 \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440 \u043a\u043b\u0430\u0441\u0441\u0430 Translated \u0441 \u043f\u0435\u0440\u0435\u0432\u043e\u0434\u043e\u043c.\"\"\"\n\n\t\tif type(text) is list:\n\t\t\tself._separator = ' //. '  #\u0420\u0430\u0437\u0434\u0435\u043b\u0438\u0442\u0435\u043b\u044c\n\t\t\tself.dest = dest\n\t\t\tself.src = src\n\t\t\tself.kwargs = kwargs\n\t\t\t\n\t\t\tlist_texts = self._check_string_limit(text)\n\t\t\ttranslated_texts = [self._text_translation(texts) for texts in list_texts]\n\t\t\t\n\t\t\t#\u0421\u043e\u0435\u0434\u0438\u043d\u044f\u0435\u043c \u043f\u0435\u0440\u0435\u0432\u0435\u0434\u0451\u043d\u043d\u044b\u0435 \u0442\u0435\u043a\u0441\u0442\u044b\n\t\t\treturn sum(translated_texts, [])\n\n\t\telse:\n\t\t\treturn super().translate(text, dest, src, **kwargs).text\n\t\n\tdef _text_translation(self, texts: list[str]) -> list[str]:\n\t\t\"\"\"\u041f\u0435\u0440\u0435\u0432\u043e\u0434\u0438\u0442 \u0442\u0435\u043a\u0441\u0442.\"\"\"\n\n\t\t#\u0421\u043e\u0435\u0434\u0438\u043d\u044f\u0435\u043c \u0442\u0435\u043a\u0441\u0442\u044b \u0440\u0430\u0437\u0434\u0438\u043b\u0438\u0442\u0435\u043b\u0435\u043c\n\t\tconnected_text = self._join_text(texts)\n\t\t#\u041d\u0430\u0445\u043e\u0434\u0438\u043c \u0434\u043b\u0438\u043d\u0443 \u043f\u0435\u0440\u0432\u043e\u043d\u0430\u0447\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u0442\u0435\u043a\u0441\u0442\u0430\n\t\tlen_text = len(texts)\n\n\t\t#\u041f\u0435\u0440\u0435\u0432\u043e\u0434\u0438\u043c \u0442\u0435\u043a\u0441\u0442\n\t\ttranslated = super().translate(connected_text, self.dest, self.src, **self.kwargs)\n\t\t#\u0420\u0430\u0437\u0434\u0435\u043b\u044f\u0435\u043c \u043f\u0435\u0440\u0435\u0432\u0435\u0434\u0451\u043d\u043d\u044b\u0439 \u0442\u0435\u043a\u0441\u0442 \u0440\u0430\u0437\u0434\u0435\u043b\u0438\u0442\u0435\u043b\u0435\u043c\n\t\tresult = self._split_text(translated.text)\n\t\t\n\t\t#\u0421\u0432\u0435\u0440\u044f\u0435\u043c \u0434\u043b\u0438\u043d\u0443 \u043f\u0435\u0440\u0435\u0432\u0435\u0434\u0451\u043d\u043d\u043e\u0433\u043e \u0438 \u043d\u0435 \u043f\u0435\u0440\u0435\u0432\u0435\u0434\u0451\u043d\u043d\u043e\u0433\u043e \u0442\u0435\u043a\u0441\u0442\u0430.\n\t\tif len(result) != len_text:\n\t\t\ttranslation1 = self._text_translation( texts[ :len_text//2 ] )\n\t\t\ttranslation2 = self._text_translation( texts[ len_text//2: ] )\n\t\t\treturn translation1 + translation2\n\t\telse:\n\t\t\treturn result\n\t\n\tdef _check_string_limit(self, texts: list[str]) -> list[ list[str] ]:\n\t\t\"\"\"\u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u0442 \u043d\u0430 \u043f\u0440\u0435\u0432\u044b\u0448\u0435\u043d\u0438\u0435 \u043b\u0438\u043c\u0438\u0442\u0430 \u0438 \u0432\u043e\u0437\u0440\u0430\u0449\u0430\u0435\u0442 \u0441\u043f\u0438\u0441\u043a\u0438, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043d\u0435 \u043f\u0440\u0435\u0432\u044b\u0448\u0430\u044e\u0442 \u043b\u0438\u043c\u0438\u0442.\"\"\"\n\n\t\ttexts_lenght = len(texts)\n\t\tconnected_text = self._join_text(texts)\n\t\tconnected_text_lenght = len(connected_text)\n\t\tself.max_characters = 5000 # google translate limit of 5000 characters\n\n\t\tif connected_text_lenght < self.max_characters:\n\t\t\treturn [connected_text]\n\t\telse:\n\t\t\ttext1 = self._check_string_limit( texts[ :texts_lenght//2 ] )\n\t\t\ttext2 = self._check_string_limit( texts[ texts_lenght//2: ] )\n\t\t\treturn text1 + text2\n\t\n\tdef _join_text(self, texts: list) -> str:\n\t\t\"\"\"\u0421\u043e\u0435\u0434\u0438\u043d\u044f\u0435\u0442 \u0442\u0435\u043a\u0441\u0442\u044b \u0440\u0430\u0437\u0434\u0438\u043b\u0438\u0442\u0435\u043b\u0435\u043c.\"\"\"\n\t\treturn self._separator.join(texts)\n\t\n\tdef _split_text(self, text: str) -> list[str]:\n\t\t\"\"\"\u0420\u0430\u0437\u0434\u0435\u043b\u044f\u0442 \u0442\u0435\u043a\u0441\u0442 \u043f\u043e \u0440\u0430\u0437\u0434\u0438\u043b\u0438\u0442\u0435\u043b\u044e.\"\"\"\n\t\tsplit_text = text.split(self._separator.strip())\n\t\tstrip_function = lambda s: s.strip()\n\t\treturn list(map(strip_function, split_text)) #\u043e\u0431\u0440\u0435\u0437\u0430\u0435\u043c \u0442\u0435\u043a\u0441\u0442 \u043e\u0442 \u043f\u0440\u043e\u0431\u0435\u043b\u043e\u0432", "class Translator(google_Translator):\n\t\"\"\"Google Translate ajax API implementation class\n\n    You have to create an instance of Translator to use this API\n\n    :param service_urls: google translate url list. URLs will be used randomly.\n                         For example ``['translate.google.com', 'translate.google.co.kr']``\n                         To preferably use the non webapp api, service url should be translate.googleapis.com\n    :type service_urls: a sequence of strings\n\n    :param user_agent: the User-Agent header to send when making requests.\n    :type user_agent: :class:`str`\n\n    :param proxies: proxies configuration.\n                    Dictionary mapping protocol or protocol and host to the URL of the proxy\n                    For example ``{'http': 'foo.bar:3128', 'http://host.name': 'foo.bar:4012'}``\n    :type proxies: dictionary\n\n    :param timeout: Definition of timeout for httpx library.\n                    Will be used for every request.\n    :type timeout: number or a double of numbers\n    :param raise_exception: if `True` then raise exception if smth will go wrong\n    :type raise_exception: boolean\n    \"\"\"\n    \n\tdef __init__(self,\n\t      \t\t service_urls = DEFAULT_CLIENT_SERVICE_URLS, user_agent: str = DEFAULT_USER_AGENT,\n\t\t  \t\t raise_exception = DEFAULT_RAISE_EXCEPTION,\n          \t\t proxies: Union[Dict[str, httpcore.SyncHTTPTransport], None] = None,\n          \t\t timeout: Union[Timeout, None] = None,\n          \t\t http2: bool = True):\n\t\tsuper().__init__(service_urls, user_agent, raise_exception, proxies, timeout, http2)  # type: ignore\n\n\tdef translate(self,\n\t       text: Union[str, list[str]],\n\t\t   dest='en',\n\t\t   src='auto',\n\t\t   **kwargs) -> Union[str, list[str]]:\n\t\t\"\"\"\u0412\u043e\u0437\u0440\u0430\u0449\u0430\u0435\u0442 \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440 \u043a\u043b\u0430\u0441\u0441\u0430 Translated \u0441 \u043f\u0435\u0440\u0435\u0432\u043e\u0434\u043e\u043c.\"\"\"\n\n\t\tif type(text) is list:\n\t\t\tself._separator = ' //. '  #\u0420\u0430\u0437\u0434\u0435\u043b\u0438\u0442\u0435\u043b\u044c\n\t\t\tself.dest = dest\n\t\t\tself.src = src\n\t\t\tself.kwargs = kwargs\n\t\t\t\n\t\t\tlist_texts = self._check_string_limit(text)\n\t\t\ttranslated_texts = [self._text_translation(texts) for texts in list_texts]\n\t\t\t\n\t\t\t#\u0421\u043e\u0435\u0434\u0438\u043d\u044f\u0435\u043c \u043f\u0435\u0440\u0435\u0432\u0435\u0434\u0451\u043d\u043d\u044b\u0435 \u0442\u0435\u043a\u0441\u0442\u044b\n\t\t\treturn sum(translated_texts, [])\n\n\t\telse:\n\t\t\treturn super().translate(text, dest, src, **kwargs).text\n\t\n\tdef _text_translation(self, texts: list[str]) -> list[str]:\n\t\t\"\"\"\u041f\u0435\u0440\u0435\u0432\u043e\u0434\u0438\u0442 \u0442\u0435\u043a\u0441\u0442.\"\"\"\n\n\t\t#\u0421\u043e\u0435\u0434\u0438\u043d\u044f\u0435\u043c \u0442\u0435\u043a\u0441\u0442\u044b \u0440\u0430\u0437\u0434\u0438\u043b\u0438\u0442\u0435\u043b\u0435\u043c\n\t\tconnected_text = self._join_text(texts)\n\t\t#\u041d\u0430\u0445\u043e\u0434\u0438\u043c \u0434\u043b\u0438\u043d\u0443 \u043f\u0435\u0440\u0432\u043e\u043d\u0430\u0447\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u0442\u0435\u043a\u0441\u0442\u0430\n\t\tlen_text = len(texts)\n\n\t\t#\u041f\u0435\u0440\u0435\u0432\u043e\u0434\u0438\u043c \u0442\u0435\u043a\u0441\u0442\n\t\ttranslated = super().translate(connected_text, self.dest, self.src, **self.kwargs)\n\t\t#\u0420\u0430\u0437\u0434\u0435\u043b\u044f\u0435\u043c \u043f\u0435\u0440\u0435\u0432\u0435\u0434\u0451\u043d\u043d\u044b\u0439 \u0442\u0435\u043a\u0441\u0442 \u0440\u0430\u0437\u0434\u0435\u043b\u0438\u0442\u0435\u043b\u0435\u043c\n\t\tresult = self._split_text(translated.text)\n\t\t\n\t\t#\u0421\u0432\u0435\u0440\u044f\u0435\u043c \u0434\u043b\u0438\u043d\u0443 \u043f\u0435\u0440\u0435\u0432\u0435\u0434\u0451\u043d\u043d\u043e\u0433\u043e \u0438 \u043d\u0435 \u043f\u0435\u0440\u0435\u0432\u0435\u0434\u0451\u043d\u043d\u043e\u0433\u043e \u0442\u0435\u043a\u0441\u0442\u0430.\n\t\tif len(result) != len_text:\n\t\t\ttranslation1 = self._text_translation( texts[ :len_text//2 ] )\n\t\t\ttranslation2 = self._text_translation( texts[ len_text//2: ] )\n\t\t\treturn translation1 + translation2\n\t\telse:\n\t\t\treturn result\n\t\n\tdef _check_string_limit(self, texts: list[str]) -> list[ list[str] ]:\n\t\t\"\"\"\u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u0442 \u043d\u0430 \u043f\u0440\u0435\u0432\u044b\u0448\u0435\u043d\u0438\u0435 \u043b\u0438\u043c\u0438\u0442\u0430 \u0438 \u0432\u043e\u0437\u0440\u0430\u0449\u0430\u0435\u0442 \u0441\u043f\u0438\u0441\u043a\u0438, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043d\u0435 \u043f\u0440\u0435\u0432\u044b\u0448\u0430\u044e\u0442 \u043b\u0438\u043c\u0438\u0442.\"\"\"\n\n\t\ttexts_lenght = len(texts)\n\t\tconnected_text = self._join_text(texts)\n\t\tconnected_text_lenght = len(connected_text)\n\t\tself.max_characters = 5000 # google translate limit of 5000 characters\n\n\t\tif connected_text_lenght < self.max_characters:\n\t\t\treturn [connected_text]\n\t\telse:\n\t\t\ttext1 = self._check_string_limit( texts[ :texts_lenght//2 ] )\n\t\t\ttext2 = self._check_string_limit( texts[ texts_lenght//2: ] )\n\t\t\treturn text1 + text2\n\t\n\tdef _join_text(self, texts: list) -> str:\n\t\t\"\"\"\u0421\u043e\u0435\u0434\u0438\u043d\u044f\u0435\u0442 \u0442\u0435\u043a\u0441\u0442\u044b \u0440\u0430\u0437\u0434\u0438\u043b\u0438\u0442\u0435\u043b\u0435\u043c.\"\"\"\n\t\treturn self._separator.join(texts)\n\t\n\tdef _split_text(self, text: str) -> list[str]:\n\t\t\"\"\"\u0420\u0430\u0437\u0434\u0435\u043b\u044f\u0442 \u0442\u0435\u043a\u0441\u0442 \u043f\u043e \u0440\u0430\u0437\u0434\u0438\u043b\u0438\u0442\u0435\u043b\u044e.\"\"\"\n\t\tsplit_text = text.split(self._separator.strip())\n\t\tstrip_function = lambda s: s.strip()\n\t\treturn list(map(strip_function, split_text)) #\u043e\u0431\u0440\u0435\u0437\u0430\u0435\u043c \u0442\u0435\u043a\u0441\u0442 \u043e\u0442 \u043f\u0440\u043e\u0431\u0435\u043b\u043e\u0432", "\n\nif __name__ == '__main__':\n\n\tdata = [\n  \t\"Chest of Drawers\",\n  \t\"Egg Plant\",\n  \t\"Eye Vine\",\n\t]\n\n\ttranslation = Translator().translate(data, dest='ru')\n\tprint(f\"{translation}\")"]}
{"filename": "ModTranslator/mod_translator/path_to_languages.py", "chunked_list": ["__author__ = 'Steklyashka'\n\nfrom .zip_file_manager import ZipFileManager\nimport os\n\nclass PathToLanguages:\n    \"\"\"\u041f\u043e\u043b\u0443\u0447\u0430\u0435\u0442 \u043d\u0430 \u0432\u0445\u043e\u0434 \u043f\u043e\u043b\u043d\u044b\u0439 \u043f\u0443\u0442\u044c \u043a \u043c\u043e\u0434\u0443(\u0438\u0433\u0440\u044b minecraft),\n    \u0430 \u0432\u043e\u0437\u0440\u0430\u0449\u044f\u0435\u0442 \u043f\u0443\u0442\u044c \u0438 \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u043d\u0438\u0435 \u043f\u0430\u043f\u043a\u0438 \u0441 \u043f\u0435\u0440\u0435\u0432\u043e\u0434\u0430\u043c\u0438.\"\"\"\n\n    def __init__(self, mod_file: str) -> None:\n        self._File = mod_file\n        self.__folders, self.__List_of_translations = _Tools.getPathToLanguages( mod_file )\n    \n    def getAll(self) -> tuple[ tuple[str], tuple[ list[str] ] ]:\n        \"\"\"\u0412\u043e\u0437\u0440\u0430\u0449\u0430\u0435\u0442 zip[path, translations].\"\"\"\n        return zip(self.__folders, self.__List_of_translations)\n\n    def getListOfTranslations(self) -> tuple[ list[str] ]:\n        \"\"\"\u0412\u043e\u0437\u0440\u0430\u0449\u0430\u0435\u0442 \u043f\u0435\u0440\u0435\u0432\u043e\u0434\u044b.\"\"\"\n        return self.__List_of_translations\n    \n    def getFolders(self) -> tuple[str]:\n        \"\"\"\u0412\u043e\u0437\u0440\u0430\u0449\u0430\u0435\u0442 \u043f\u0443\u0442\u044c \u043a \u043f\u0435\u0440\u0435\u0432\u043e\u0434\u0430\u043c.\"\"\"\n        return self.__folders\n    \n    def getNameFile(self) -> str:\n        \"\"\"\u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0438\u043c\u044f \u0444\u0430\u0439\u043b\u0430.\"\"\"\n        return self._File\n    \n    def isFolderWithTranslations(self) -> bool:\n        \"\"\"\u0412\u043e\u0437\u0440\u0430\u0449\u0430\u0435\u0442 True/False \u043f\u0440\u0438 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u043e\u0432\u0432\u0430\u043d\u0438\u0438 \u0438\u043b\u0438 \u043e\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0438\u0438 \u043f\u0430\u043f\u043a\u0438 \u0441 \u043f\u0435\u0440\u0435\u0432\u043e\u0434\u0430\u043c\u0438.\"\"\"\n        return bool(self.__folders)\n    \n    def isNecessaryTranslation(self, lang) -> bool:\n        \"\"\"\u0412\u043e\u0437\u0440\u0430\u0449\u0430\u0435\u0442 True/False \u043f\u0440\u0438 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u043e\u0432\u0432\u0430\u043d\u0438\u0438 \u0438\u043b\u0438 \u043e\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0438\u0438 \u043d\u0443\u0436\u043d\u043e\u0433\u043e \u043f\u0435\u0440\u0435\u0432\u043e\u0434\u0430.\"\"\"\n        \n        return not any([\n            lang not in translations \\\n                for translations in self.__List_of_translations\n                ])", "\n\n    \nclass _Tools:\n    \"\"\"\u041f\u043e\u043b\u0443\u0447\u0430\u0435\u0442 \u043d\u0430 \u0432\u0445\u043e\u0434 \u043f\u043e\u043b\u043d\u044b\u0439 \u043f\u0443\u0442\u044c \u043a jar \u043c\u043e\u0434\u0443(\u0438\u0433\u0440\u044b minecraft),\n    \u0430 \u0432\u043e\u0437\u0440\u0430\u0449\u044f\u0435\u0442 \u043f\u0443\u0442\u044c \u0438 \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u043d\u0438\u0435 \u043f\u0430\u043f\u043a\u0438 \u0441 \u043f\u0435\u0440\u0435\u0432\u043e\u0434\u0430\u043c\u0438.\"\"\"\n    \n    @classmethod\n    def getPathToLanguages(cls, mod_file) -> tuple[   tuple[ str ], tuple[ list[str] ]   ]:\n        \"\"\"\u0412\u043e\u0437\u0440\u0430\u0449\u0430\u0435\u0442 \u043f\u0435\u0440\u0435\u0432\u043e\u0434\u044b \u0438 \u0438\u0445 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u044e.\"\"\"\n\n        PATH = 'assets/' #\u0414\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u044f\n        FROM_LANGUAGE = \"en_us.json\"\n\n        #\u0427\u0442\u0435\u043d\u0438\u0435 \u0444\u0430\u0439\u043b\u0430\n        namelist = ZipFileManager.read_ZipFile(mod_file)\n\n        #\u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u043c\u043e\u0433\u043e \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0438 - PATH\n        namelist = cls._getArchiveSlice(PATH, namelist)\n\n        #\u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u043c\u043e\u0433\u043e \u043f\u0430\u043f\u043e\u043a lang\n        func = lambda f: os.path.basename(os.path.dirname(f)) == 'lang' and os.path.basename(f)\n        namelist = list( filter(func, namelist) )\n\n        #\u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0439 \u0444\u0430\u0439\u043b\u043e\u0432\n        folders = cls._unique_folders(namelist)\n\n        #\u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043d\u0430 \u043d\u0430\u043b\u0438\u0447\u0430\u0435 FROM_LANGUAGE\n        func = lambda f: os.path.join(f, FROM_LANGUAGE)\n        namelist = list( filter(func, namelist) )\n        \n        #\u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0439 \u0444\u0430\u0439\u043b\u043e\u0432\n        List_of_translations = [cls._getArchiveDirectory(folder, namelist.copy()) for folder in folders]\n\n        return tuple(folders), tuple(List_of_translations)\n    \n    @classmethod\n    def _unique_folders(cls, path_list):\n        unique_folders_set = set()\n\n        for path in path_list:\n            folder = os.path.dirname(path)\n            unique_folders_set.add(folder)\n\n        return list(unique_folders_set)\n\n    @classmethod\n    def _getArchiveDirectory(cls, directory: str, archive: list) -> list:\n        \"\"\"\u0412\u043e\u0437\u0440\u0430\u0449\u0430\u0435\u0442 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u043c\u043e\u0435 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0438.\"\"\"\n        \n        archive_slice = cls._getArchiveSlice(directory, archive)\n\n        func = lambda path_file: os.path.basename(path_file)\n        archive_directory = map(func, archive_slice)\n\n        return list(archive_directory)\n    \n    @staticmethod\n    def _getArchiveSlice(directory: str, archive: list) -> list:\n        \"\"\"\u0412\u043e\u0437\u0440\u0430\u0449\u0430\u0435\u0442 \u043f\u043e\u043b\u043d\u044b\u0439 \u043f\u0443\u0442\u044c \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u043c\u043e\u0433\u043e \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0438. \u041e\u0442\u0441\u0435\u043a\u0430\u0435\u0442 \u043e\u0441\u0442\u0430\u043b\u044c\u043d\u043e\u0435.\"\"\"\n        \n        def func(s: str):\n            return s.startswith(directory)\n\n        archive_slice = filter(func, archive)\n\n        return list(archive_slice)"]}
