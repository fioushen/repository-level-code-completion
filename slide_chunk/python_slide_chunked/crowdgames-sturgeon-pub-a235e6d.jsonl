{"filename": "custom.py", "chunked_list": ["import argparse, pickle\nimport generator, reach, util\n\n\n\nWEIGHT_CUSTOM      =   100\n\nCUST_RESULT        = 'result'\nCUST_TEXT_LEVEL    = 'text-level'\nCUST_TEXT_COUNT    = 'text-count'", "CUST_TEXT_LEVEL    = 'text-level'\nCUST_TEXT_COUNT    = 'text-count'\nCUST_TEXT_MAX      = 'text-max'\nCUST_PATH          = 'path'\nCUST_PATH_ENDS     = 'path-ends'\nCUST_PATH_FWD      = 'path-fwd'\nCUST_PATH_SHORT    = 'path-short'\nCUST_LIST = [CUST_RESULT, CUST_TEXT_LEVEL, CUST_TEXT_COUNT, CUST_TEXT_MAX, CUST_PATH, CUST_PATH_ENDS, CUST_PATH_FWD, CUST_PATH_SHORT]\n\n", "\n\n\ndef str_to_weight(s):\n    if s == 'hard':\n        return None\n    elif s == 'soft':\n        return WEIGHT_CUSTOM\n    else:\n        util.check(False, 'weight')", "\ndef str_to_result(s):\n    with util.openz(s, 'rb') as f:\n        return pickle.load(f)\n\ndef str_to_points(s):\n    ret = []\n    for pt in s.split(','):\n        a, b = pt.split()\n        ret.append((int(a), int(b)))\n    return ret", "\ndef arg_cvt(args, cvts):\n    util.check(len(args) == len(cvts), 'argument length')\n\n    return [cvt(arg) for arg, cvt in zip(args, cvts)]\n\ndef args_to_custom(cust, args):\n    if cust == CUST_RESULT:\n        result_info, which, rlo, clo, rhi, chi, roff, coff, weight = arg_cvt(args, (str_to_result, str, int, int, int, int, int, int, str_to_weight))\n        return OutResultConstraint(result_info, which, rlo, clo, rhi, chi, roff, coff, weight)\n\n    elif cust == CUST_TEXT_LEVEL:\n        out_text_level, weight = arg_cvt(args, (util.read_text_level, str_to_weight))\n        return OutTextLevelConstraint(out_text_level, weight)\n\n    elif cust == CUST_TEXT_COUNT:\n        rlo, clo, rhi, chi, tlo, thi, out_texts, weight = arg_cvt(args, (int, int, int, int, int, int, str, str_to_weight))\n        return OutTextCountConstraint(rlo, clo, rhi, chi, tlo, thi, out_texts, weight)\n\n    elif cust == CUST_TEXT_MAX:\n        rlo, clo, rhi, chi, out_texts, weight = arg_cvt(args, (int, int, int, int, str, str_to_weight))\n        return OutTextMaximizeConstraint(rlo, clo, rhi, chi, out_texts, weight)\n\n    elif cust == CUST_PATH:\n        path_points, weight = arg_cvt(args, (str_to_points, str_to_weight))\n        return OutPathConstraint(path_points, weight)\n\n    elif cust == CUST_PATH_ENDS:\n        sr, sc, gr, gc, weight = arg_cvt(args, (int, int, int, int, str_to_weight))\n        return OutPathEndsConstraint(sr, sc, gr, gc, weight)\n\n    elif cust == CUST_PATH_FWD:\n        direction, weight, = arg_cvt(args, (str, str_to_weight))\n        return OutPathFwdConstraint(direction, weight)\n\n    elif cust == CUST_PATH_SHORT:\n        direction, most, weight = arg_cvt(args, (str, int, str_to_weight))\n        return OutPathShortConstraint(direction, most, weight)\n\n    else:\n        util.check(False, 'cust')", "\n\n\nclass CustomConstraint:\n    def __init__(self):\n        pass\n\n    def add(self, gen):\n        pass\n\nclass OutPathConstraint(CustomConstraint):\n    def __init__(self, path_points, weight):\n        self._path_points = path_points\n        self._weight = weight\n\n    def add(self, gen):\n        print('add custom out path constraint', self._weight)\n\n        path_cache = {}\n        for (fr, fc), (tr, tc) in zip(self._path_points, self._path_points[1:]):\n            util.check(0 <= tc and tc < gen.get_cols(), 'wrapping not supported')\n            path_cache[(fr, fc, tr, tc, tc)] = None\n\n        reach_edges = gen.reachability_edges()\n        util.check(reach_edges is not None, 'reach_edges')\n\n        for rr in range(gen.get_rows()):\n            for cc in range(gen.get_cols()):\n                gen.add_constraint_start(rr, cc, (rr, cc) == self._path_points[0], self._weight)\n                gen.add_constraint_goal(rr, cc, (rr, cc) == self._path_points[-1], self._weight)\n\n        for cfr, cfc, ctr, ctc, cpwtc in reach_edges:\n            on_path = (cfr, cfc, ctr, ctc, cpwtc) in path_cache\n            gen.add_constraint_reach_edge(cfr, cfc, ctr, ctc, cpwtc, on_path, self._weight)\n            if on_path:\n                del path_cache[(cfr, cfc, ctr, ctc, cpwtc)]\n\n        util.check(len(path_cache) == 0, 'not all path edges used')\n\n        path_edges = [(a, b, c, d) for (a, b), (c, d) in zip(self._path_points, self._path_points[1:])]\n        gen.append_extra_meta([util.meta_path('custom-path', path_edges)])", "\nclass OutPathConstraint(CustomConstraint):\n    def __init__(self, path_points, weight):\n        self._path_points = path_points\n        self._weight = weight\n\n    def add(self, gen):\n        print('add custom out path constraint', self._weight)\n\n        path_cache = {}\n        for (fr, fc), (tr, tc) in zip(self._path_points, self._path_points[1:]):\n            util.check(0 <= tc and tc < gen.get_cols(), 'wrapping not supported')\n            path_cache[(fr, fc, tr, tc, tc)] = None\n\n        reach_edges = gen.reachability_edges()\n        util.check(reach_edges is not None, 'reach_edges')\n\n        for rr in range(gen.get_rows()):\n            for cc in range(gen.get_cols()):\n                gen.add_constraint_start(rr, cc, (rr, cc) == self._path_points[0], self._weight)\n                gen.add_constraint_goal(rr, cc, (rr, cc) == self._path_points[-1], self._weight)\n\n        for cfr, cfc, ctr, ctc, cpwtc in reach_edges:\n            on_path = (cfr, cfc, ctr, ctc, cpwtc) in path_cache\n            gen.add_constraint_reach_edge(cfr, cfc, ctr, ctc, cpwtc, on_path, self._weight)\n            if on_path:\n                del path_cache[(cfr, cfc, ctr, ctc, cpwtc)]\n\n        util.check(len(path_cache) == 0, 'not all path edges used')\n\n        path_edges = [(a, b, c, d) for (a, b), (c, d) in zip(self._path_points, self._path_points[1:])]\n        gen.append_extra_meta([util.meta_path('custom-path', path_edges)])", "\nclass OutPathEndsConstraint(CustomConstraint):\n    def __init__(self, sr, sc, gr, gc, weight):\n        self._sr = sr\n        self._sc = sc\n        self._gr = gr\n        self._gc = gc\n        self._weight = weight\n\n    def add(self, gen):\n        print('add custom out path ends constraint', self._weight)\n\n        for rr in range(gen.get_rows()):\n            for cc in range(gen.get_cols()):\n                gen.add_constraint_start(rr, cc, (rr, cc) == (self._sr, self._sc), self._weight)\n                gen.add_constraint_goal(rr, cc, (rr, cc) == (self._gr, self._gc), self._weight)\n\n        ends = [(self._sr, self._sc), (self._gr, self._gc)]\n        gen.append_extra_meta([util.meta_tile('custom-path-ends', ends)])", "\nclass OutPathFwdConstraint(CustomConstraint):\n    def __init__(self, direction, weight):\n        self._direction = direction\n        self._weight = weight\n\n    def add(self, gen):\n        print('add custom out path forward constraint', self._weight)\n\n        reach_edges = gen.reachability_edges()\n        util.check(reach_edges is not None, 'reach_edges')\n\n        for cfr, cfc, ctr, ctc, cpwtc in reach_edges:\n            if self._direction == reach.RGOAL_L_R:\n                exclude = (ctc <= cfc)\n            elif self._direction == reach.RGOAL_B_T:\n                exclude = (ctr >= cfr)\n            else:\n                util.check(False, 'direction')\n\n            if exclude:\n                gen.add_constraint_reach_edge(cfr, cfc, ctr, ctc, cpwtc, False, self._weight)", "\nclass OutResultConstraint(CustomConstraint):\n    def __init__(self, out_result, which, rlo, clo, rhi, chi, roff, coff, weight):\n        self._out_result = out_result\n        self._which = which\n        self._rlo = rlo\n        self._clo = clo\n        self._rhi = rhi\n        self._chi = chi\n        self._roff = roff\n        self._coff = coff\n        self._weight = weight\n\n    def add(self, gen):\n        print('add custom out result constraint', self._weight)\n\n        util.check(0 <= self._rlo, 'size')\n        util.check(0 <= self._clo, 'size')\n        util.check(self._rlo < self._rhi, 'size')\n        util.check(self._clo < self._chi, 'size')\n        util.check(self._rhi <= len(self._out_result.tile_level), 'size')\n        util.check(self._chi <= len(self._out_result.tile_level[0]), 'size')\n\n        util.check(0 <= self._roff, 'size')\n        util.check(0 <= self._coff, 'size')\n        util.check(self._rhi - self._rlo + self._roff <= gen.get_rows(), 'size')\n        util.check(self._chi - self._clo + self._coff <= gen.get_cols(), 'size')\n\n        # T: tiles\n        # Po: path - on path\n        # Pa: path - on and off path\n        # Ro: reverse path - on path\n        # Ra: reverse path - on and off path\n        util.check(self._which in ['T', 'Po', 'Pa', 'Ro', 'Ra', 'TPo', 'TPa', 'TRo', 'TRa'], 'which')\n\n        rinto = -self._rlo + self._roff\n        cinto = -self._clo + self._coff\n\n        gen.append_extra_meta([util.meta_rect('custom', [(self._rlo + rinto, self._clo + cinto, self._rhi + rinto, self._chi + cinto)])])\n\n        if 'T' in self._which:\n            for rr in range(self._rlo, self._rhi):\n                for cc in range(self._clo, self._chi):\n                    gen.add_constraint_tile_counts([(rr + rinto, cc + cinto)], [self._out_result.tile_level[rr][cc]], 1, 1, self._weight)\n\n        if 'Po' in self._which or 'Pa' in self._which or 'Ro' in self._which or 'Ra' in self._which:\n            util.check(self._out_result.reach_info is not None, 'reach_info')\n\n            path_all = ('Pa' in self._which) or ('Ra' in self._which)\n            path_reverse = ('Ro' in self._which) or ('Ra' in self._which)\n\n            path_edges = self._out_result.reach_info.path_edges\n            if path_reverse:\n                path_edges = reversed(path_edges)\n\n            path_cache = {}\n            path_start_found, path_start = False, self._out_result.reach_info.path_tiles[0]\n            path_goal_found, path_goal = False, self._out_result.reach_info.path_tiles[-1]\n            for (fr, fc, tr, pwtc) in path_edges:\n                tc = pwtc % len(self._out_result.tile_level[0])\n\n                f_in = self._rlo <= fr and fr < self._rhi and self._clo <= fc and fc < self._chi\n                t_in = self._rlo <= tr and tr < self._rhi and self._clo <= tc and tc < self._chi\n\n                if path_reverse and t_in and (tr, tc) == path_goal:\n                    path_goal_found = True\n                if not path_reverse and f_in and (fr, fc) == path_start:\n                    path_start_found = True\n\n                if f_in and t_in:\n                    cfr = fr + rinto\n                    cfc = fc + cinto\n                    ctr = tr + rinto\n                    ctc = tc + cinto\n                    cpwtc = pwtc + cinto\n                    path_cache[(cfr, cfc, ctr, ctc, cpwtc)] = None\n                elif fc < 0 or fc >= len(self._out_result.tile_level[0]):\n                    # skip duplicate path edges coming in after a wrap\n                    continue\n                else:\n                    break\n\n                if not path_reverse and t_in and (tr, tc) == path_goal:\n                    path_goal_found = True\n                if path_reverse and f_in and (fr, fc) == path_start:\n                    path_start_found = True\n\n            reach_edges = gen.reachability_edges()\n            util.check(reach_edges is not None, 'reach_edges')\n\n            for cfr, cfc, ctr, ctc, cpwtc in reach_edges:\n                on_path = (cfr, cfc, ctr, ctc, cpwtc) in path_cache\n                add_cnstr = on_path or path_all\n                if add_cnstr:\n                    gen.add_constraint_reach_edge(cfr, cfc, ctr, ctc, cpwtc, on_path, self._weight)\n\n            for rr in range(self._rlo, self._rhi):\n                for cc in range(self._clo, self._chi):\n                    if path_start_found or path_all:\n                        gen.add_constraint_start(rr + rinto, cc + cinto, (rr, cc) == path_start, self._weight)\n                    if path_goal_found or path_all:\n                        gen.add_constraint_goal(rr + rinto, cc + cinto, (rr, cc) == path_goal, self._weight)", "\nclass OutPathShortConstraint(CustomConstraint):\n    def __init__(self, direction, most, weight):\n        self._direction = direction\n        self._most = most\n        self._weight = weight\n\n    def add(self, gen):\n        print('add custom out path short constraint', self._weight)\n\n        if self._direction == reach.RGOAL_L_R:\n            for cc in range(gen.get_cols()):\n                vvs = []\n                for rr in range(gen.get_rows()):\n                    vvs.append(gen._reach_vars_node[(rr, cc)])\n                gen._solver.cnstr_count(vvs, True, 0, self._most, self._weight)\n\n        elif self._direction == reach.RGOAL_B_T:\n            for rr in range(gen.get_rows()):\n                vvs = []\n                for cc in range(gen.get_cols()):\n                    vvs.append(gen._reach_vars_node[(rr, cc)])\n                gen._solver.cnstr_count(vvs, True, 0, self._most, self._weight)\n\n        else:\n            util.check(False, 'direction')", "\nclass OutTextLevelConstraint(CustomConstraint):\n    def __init__(self, out_text_level, weight):\n        self._out_text_level = out_text_level\n        self._weight = weight\n\n    def add(self, gen):\n        print('add custom out text level constraint', self._weight)\n\n        util.check(len(self._out_text_level) == gen.get_rows(), 'size')\n        util.check(len(self._out_text_level[0]) == gen.get_cols(), 'size')\n\n        for rr in range(gen.get_rows()):\n            for cc in range(gen.get_cols()):\n                out_text = self._out_text_level[rr][cc]\n                if out_text != util.DEFAULT_TEXT:\n                    possible_tiles = [tile for tile, text in gen.get_scheme_info().tileset.tile_to_text.items() if text == out_text]\n                    gen.add_constraint_tile_counts([(rr, cc)], possible_tiles, 1, 1, self._weight)", "\nclass OutTextLevelDiffCellConstraint(CustomConstraint):\n    def __init__(self, out_text_level, density, offset, weight):\n        self._out_text_level = out_text_level\n        self._density = density\n        self._offset = offset\n        self._weight = weight\n\n    def add(self, gen):\n        print('add custom out text level diff cell constraint', self._weight)\n\n        util.check(len(self._out_text_level) == gen.get_rows(), 'size')\n        util.check(len(self._out_text_level[0]) == gen.get_cols(), 'size')\n\n        for rr in range(gen.get_rows()):\n            for cc in range(gen.get_cols()):\n                if (self._offset + cc + gen.get_cols() * rr) % self._density != 0:\n                    print('-', end='')\n                    continue\n                else:\n                    print('+', end='')\n\n                out_text = self._out_text_level[rr][cc]\n                if out_text != util.DEFAULT_TEXT:\n                    diff_tiles = [tile for tile, text in gen.get_scheme_info().tileset.tile_to_text.items() if text != out_text]\n                    gen.add_constraint_tile_counts([(rr, cc)], diff_tiles, 1, 1, self._weight)\n            print()", "\nclass OutTextLevelDiffCountConstraint(CustomConstraint):\n    def __init__(self, out_text_level, diff_pct, weight):\n        self._out_text_level = out_text_level\n        self._diff_pct = diff_pct\n        self._weight = weight\n\n    def add(self, gen):\n        print('add custom out text level diff count constraint', self._weight)\n\n        util.check(len(self._out_text_level) == gen.get_rows(), 'size')\n        util.check(len(self._out_text_level[0]) == gen.get_cols(), 'size')\n\n        all_diff_vars = []\n        for rr in range(gen.get_rows()):\n            for cc in range(gen.get_cols()):\n                out_text = self._out_text_level[rr][cc]\n                if out_text != util.DEFAULT_TEXT:\n                    diff_tiles = [tile for tile, text in gen.get_scheme_info().tileset.tile_to_text.items() if text != out_text]\n                    for tile in diff_tiles:\n                        all_diff_vars.append(gen._tile_var(rr, cc, tile))\n\n        tile_diff_count = max(1, min(len(all_diff_vars), int(gen.get_rows() * gen.get_cols() * self._diff_pct // 100)))\n        gen._solver.cnstr_count(all_diff_vars, True, tile_diff_count, len(all_diff_vars), self._weight)", "\nclass OutTextCountConstraint(CustomConstraint):\n    def __init__(self, rlo, clo, rhi, chi, tlo, thi, out_texts, weight):\n        self._rlo = rlo\n        self._clo = clo\n        self._rhi = rhi\n        self._chi = chi\n        self._tlo = tlo\n        self._thi = thi\n        self._out_texts = out_texts\n        self._weight = weight\n\n    def add(self, gen):\n        print('add custom out text count constraint', self._weight)\n\n        possible_tiles = [tile for tile, text in gen.get_scheme_info().tileset.tile_to_text.items() if text in self._out_texts]\n\n        rcs = []\n        for rr in range(self._rlo, self._rhi):\n            for cc in range(self._clo, self._chi):\n                rcs.append((rr, cc))\n        gen.add_constraint_tile_counts(rcs, possible_tiles, self._tlo, self._thi, self._weight)", "\nclass OutTileCountConstraint(CustomConstraint):\n    def __init__(self, rlo, clo, rhi, chi, tlo, thi, out_tile, weight):\n        self._rlo = rlo\n        self._clo = clo\n        self._rhi = rhi\n        self._chi = chi\n        self._tlo = tlo\n        self._thi = thi\n        self._out_tile = out_tile\n        self._weight = weight\n\n    def add(self, gen):\n        print('add custom out tile count constraint', self._weight)\n\n        possible_tiles = [self._out_tile]\n\n        rcs = []\n        for rr in range(self._rlo, self._rhi):\n            for cc in range(self._clo, self._chi):\n                rcs.append((rr, cc))\n        gen.add_constraint_tile_counts(rcs, possible_tiles, self._tlo, self._thi, self._weight)", "\nclass OutTextMaximizeConstraint(CustomConstraint):\n    def __init__(self, rlo, clo, rhi, chi, out_texts, weight):\n        self._rlo = rlo\n        self._clo = clo\n        self._rhi = rhi\n        self._chi = chi\n        self._out_texts = out_texts\n        self._weight = weight\n\n    def add(self, gen):\n        print('add custom out text maximize constraint', self._weight)\n\n        possible_tiles = [tile for tile, text in gen.get_scheme_info().tileset.tile_to_text.items() if text in self._out_texts]\n\n        for rr in range(self._rlo, self._rhi):\n            for cc in range(self._clo, self._chi):\n                gen.add_constraint_tile_counts([(rr, cc)], possible_tiles, 1, 1, self._weight)", ""]}
{"filename": "reach.py", "chunked_list": ["import util\n\n\n\nRMOVE_MAZE               = 'maze'\nRMOVE_TOMB               = 'tomb'\nRMOVE_CLIMB              = 'climb'\nRMOVE_SUPERCAT           = 'supercat'\nRMOVE_SUPERCAT2          = 'supercat2'\nRMOVE_PLATFORM           = 'platform'", "RMOVE_SUPERCAT2          = 'supercat2'\nRMOVE_PLATFORM           = 'platform'\nRMOVE_LIST               = [RMOVE_MAZE, RMOVE_TOMB, RMOVE_SUPERCAT, RMOVE_SUPERCAT2, RMOVE_CLIMB, RMOVE_PLATFORM]\n\nRGOAL_ALL                = 'all'\nRGOAL_SET                = 'set'\nRGOAL_L_R                = 'l-r'\nRGOAL_B_T                = 'b-t'\nRGOAL_T_B                = 't-b'\nRGOAL_TL_BR              = 'tl-br'", "RGOAL_T_B                = 't-b'\nRGOAL_TL_BR              = 'tl-br'\nRGOAL_TR_BL              = 'tr-bl'\nRGOAL_BL_TR              = 'bl-tr'\nRGOAL_BR_TL              = 'br-tl'\nRGOAL_DICT = {\n    RGOAL_ALL: 0,\n    RGOAL_SET: 4,\n    RGOAL_L_R: 1,\n    RGOAL_B_T: 1,", "    RGOAL_L_R: 1,\n    RGOAL_B_T: 1,\n    RGOAL_T_B: 1,\n    RGOAL_TL_BR: 1,\n    RGOAL_TR_BL: 1,\n    RGOAL_BL_TR: 1,\n    RGOAL_BR_TL: 1\n}\n\n", "\n\n\ndef get_move_template(reach_move):\n    move_template = []\n\n    if reach_move == RMOVE_MAZE:\n        move_template.append(((-1,  0), [], [], []))\n        move_template.append((( 1,  0), [], [], []))\n        move_template.append((( 0, -1), [], [], []))\n        move_template.append((( 0,  1), [], [], []))\n\n    elif reach_move == RMOVE_TOMB:\n        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            for ii in [1, 2, 4, 6, 10]:\n                dest = (dr * ii, dc * ii)\n                need_open_path = [(dr * jj, dc * jj) for jj in range(1, ii)]\n                need_open_aux = []\n                need_closed = [(dr * (ii + 1), dc * (ii + 1))]\n                move_template.append((dest, need_open_path, need_open_aux, need_closed))\n\n    elif reach_move in [RMOVE_CLIMB, RMOVE_SUPERCAT, RMOVE_SUPERCAT2]:\n        # fall\n        move_template.append(((1,  0), [], [], []))\n        move_template.append(((1,  1), [(1, 0)], [], []))\n        move_template.append(((1, -1), [(1, 0)], [], []))\n\n        # walk\n        move_template.append(((0,  1), [], [], [(1, 0)]))\n        move_template.append(((0, -1), [], [], [(1, 0)]))\n\n        # wall climb (only starting from ground, no continue onto ledge)\n        for dc in [1, -1]:\n            for ii in range(1, 8):\n                dest = (-ii, 0)\n                need_open_path = [(-jj, 0) for jj in range(1, ii)]\n                need_open_aux = []\n                need_closed = [(1, 0)] + [(-jj, dc) for jj in range(ii + 1)]\n                move_template.append((dest, need_open_path, need_open_aux, need_closed))\n\n        # wall jump (requires extra closed tiles to prevent continuing jump/fall in same direction, open to prevent jump from ground)\n        jump_arc = [(0, 1), (-1,  1), (-1,  2), (-2,  2), (-2,  3), (-3,  3), (-3,  4)]\n        for dc in [1, -1]:\n            arc_start = 0 if reach_move == RMOVE_SUPERCAT else 1\n            for ii in range(arc_start, len(jump_arc)):\n                dest = (jump_arc[ii][0], dc * jump_arc[ii][1])\n                need_open_path =  [(jr, dc * jc) for jr, jc in jump_arc[:ii]]\n                need_open_aux = [(1, 0)]\n                need_closed = [(-1, -dc), (0, -dc), (1, -dc)]\n                move_template.append((dest, need_open_path, need_open_aux, need_closed))\n\n        if reach_move in [RMOVE_SUPERCAT, RMOVE_SUPERCAT2]:\n            # dash jump\n            arc_start = 0 if reach_move == RMOVE_SUPERCAT else 1\n            jump_arc = [(0, 1), (-1,  1), (-1,  2), (-2,  2), (-2,  3), (-2,  4), (-2,  5)]\n            for dc in [1, -1]:\n                for ii in range(arc_start, len(jump_arc)):\n                    dest = (jump_arc[ii][0], dc * jump_arc[ii][1])\n                    need_open_path = [(jr, dc * jc) for jr, jc in jump_arc[:ii]]\n                    if reach_move == RMOVE_SUPERCAT:\n                        need_open_aux = [(1, dc)]\n                    elif reach_move == RMOVE_SUPERCAT2:\n                        need_open_aux = [(1, dc), (-1, 0)]\n                    else:\n                        util.check(False, 'reach_move')\n                    need_closed = [(1, 0)]\n                    move_template.append((dest, need_open_path, need_open_aux, need_closed))\n\n    elif reach_move == RMOVE_PLATFORM:\n        # fall\n        move_template.append(((1,  0), [], [], []))\n        move_template.append(((1,  1), [(1, 0)], [], []))\n        move_template.append(((1, -1), [(1, 0)], [], []))\n\n        # walk\n        move_template.append(((0,  1), [], [], [(1, 0)]))\n        move_template.append(((0, -1), [], [], [(1, 0)]))\n\n        # jump\n        jump_arcs = [\n            [(-1,  0), (-2,  0), (-3,  0), (-4,  0), (-4,  1)],\n            [(-1,  0), (-2,  0), (-3,  0), (-4,  0), (-4, -1)],\n            [(-1,  0), (-1,  1), (-2,  1), (-2,  2), (-3,  2), (-3,  3), (-4,  3), (-4,  4)],\n            [(-1,  0), (-1, -1), (-2, -1), (-2, -2), (-3, -2), (-3, -3), (-4, -3), (-4, -4)],\n        ]\n        for jump_arc in jump_arcs:\n            for ii in range(len(jump_arc)):\n                dest = jump_arc[ii]\n                need_open_path = [jrc for jrc in jump_arc[:ii]]\n                need_open_aux = []\n                need_closed = [(1, 0)]\n                move_template.append((dest, need_open_path, need_open_aux, need_closed))\n    else:\n        util.check(False, 'reach_move ' + reach_move)\n\n    move_template_uniq = []\n    for arc in move_template:\n        if arc not in move_template_uniq:\n            move_template_uniq.append(arc)\n\n    return move_template_uniq", "\n\n\ndef get_reach_info(rows, cols, reach_setup, scheme_info):\n    util.check(scheme_info.tileset.tile_to_text is not None, 'reachability only for (text) level generation')\n\n    reach_info = util.ReachabilityInfo()\n\n\n\n    reach_info.start_rcs = []\n    reach_info.goal_rcs = []\n\n    def r_all(_st, _gl):\n        for _rr in range(rows):\n            for _cc in range(cols):\n                _st.append((_rr, _cc))\n                _gl.append((_rr, _cc))\n\n    def r_set(_sr, _sc, _gr, _gc, _st, _gl):\n        _st.append((_sr, _sc))\n        _gl.append((_gr, _gc))\n\n    def r_left_to_right(_sz, _st, _gl):\n        for _rr in range(rows):\n            for _cc in range(_sz):\n                _st.append((_rr, _cc))\n                _gl.append((_rr, cols - 1 - _cc))\n\n    def r_bottom_to_top(_sz, _st, _gl):\n        for _rr in range(_sz):\n            for _cc in range(cols):\n                _st.append((rows - 1 - _rr, _cc))\n                _gl.append((_rr, _cc))\n\n    def r_top_to_bottom(_sz, _st, _gl):\n        for _rr in range(_sz):\n            for _cc in range(cols):\n                _st.append((_rr, _cc))\n                _gl.append((rows - 1 - _rr, _cc))\n\n    def r_topleft_to_botright(_szr, _szc, _st, _gl):\n        for _rr in range(_szr):\n            for _cc in range(_szc):\n                _st.append((_rr, _cc))\n                _gl.append((rows - 1 - _rr, cols - 1 - _cc))\n\n    def r_topright_to_botleft(_szr, _szc, _st, _gl):\n        for _rr in range(_szr):\n            for _cc in range(_szc):\n                _st.append((_rr, cols - 1 - _cc))\n                _gl.append((rows - 1 - _rr, _cc))\n\n    def r_botleft_to_topright(_szr, _szc, _st, _gl):\n        for _rr in range(_szr):\n            for _cc in range(_szc):\n                _st.append((rows - 1 - _rr, _cc))\n                _gl.append((_rr, cols - 1 - _cc))\n\n    def r_botright_to_topleft(_szr, _szc, _st, _gl):\n        for _rr in range(_szr):\n            for _cc in range(_szc):\n                _st.append((rows - 1 - _rr, cols - 1 - _cc))\n                _gl.append((_rr, _cc))\n\n    if reach_setup.goal_loc == RGOAL_ALL:\n        r_all(reach_info.start_rcs, reach_info.goal_rcs)\n    elif reach_setup.goal_loc == RGOAL_SET:\n        r_set(reach_setup.goal_params[0], reach_setup.goal_params[1], reach_setup.goal_params[2], reach_setup.goal_params[3], reach_info.start_rcs, reach_info.goal_rcs)\n    elif reach_setup.goal_loc == RGOAL_L_R:\n        r_left_to_right(reach_setup.goal_params[0], reach_info.start_rcs, reach_info.goal_rcs)\n    elif reach_setup.goal_loc == RGOAL_B_T:\n        r_bottom_to_top(reach_setup.goal_params[0], reach_info.start_rcs, reach_info.goal_rcs)\n    elif reach_setup.goal_loc == RGOAL_T_B:\n        r_top_to_bottom(reach_setup.goal_params[0], reach_info.start_rcs, reach_info.goal_rcs)\n    elif reach_setup.goal_loc == RGOAL_TL_BR:\n        r_topleft_to_botright(reach_setup.goal_params[0], reach_setup.goal_params[0], reach_info.start_rcs, reach_info.goal_rcs)\n    elif reach_setup.goal_loc == RGOAL_TR_BL:\n        r_topright_to_botleft(reach_setup.goal_params[0], reach_setup.goal_params[0], reach_info.start_rcs, reach_info.goal_rcs)\n    elif reach_setup.goal_loc == RGOAL_BL_TR:\n        r_botleft_to_topright(reach_setup.goal_params[0], reach_setup.goal_params[0], reach_info.start_rcs, reach_info.goal_rcs)\n    elif reach_setup.goal_loc == RGOAL_BR_TL:\n        r_botright_to_topleft(reach_setup.goal_params[0], reach_setup.goal_params[0], reach_info.start_rcs, reach_info.goal_rcs)\n    else:\n        util.check(False, 'reach_goal_loc ' + reach_setup.goal_loc)\n\n\n\n    reach_info.game_to_move = {}\n\n    for game, reach_move in reach_setup.game_to_move.items():\n        game_move = util.GameMoveInfo()\n        reach_info.game_to_move[game] = game_move\n\n        game_move.start_tile, game_move.goal_tile, game_move.open_tiles = None, None, []\n        for tag, tiles in scheme_info.game_to_tag_to_tiles[game].items():\n            for tile in tiles:\n                text = scheme_info.tileset.tile_to_text[tile]\n                if text == util.START_TEXT:\n                    util.check(game_move.start_tile is None, 'multiple tiles with start text')\n                    game_move.start_tile = tile\n                if text == util.GOAL_TEXT:\n                    util.check(game_move.goal_tile is None, 'multiple tiles with goal text')\n                    game_move.goal_tile = tile\n                if text in reach_setup.open_text:\n                    game_move.open_tiles.append(tile)\n        util.check(game_move.start_tile is not None, 'no tiles with start text')\n        util.check(game_move.goal_tile is not None, 'no tiles with goal text')\n        util.check(len(game_move.open_tiles) > 0, 'no tiles with open text')\n\n        game_move.wrap_cols = reach_setup.wrap_cols\n        game_move.move_template = get_move_template(reach_move)\n\n    return reach_info", ""]}
{"filename": "solvers.py", "chunked_list": ["import json, multiprocessing, queue, random, sys\nimport util\n\ntry:\n    available_z3 = False\n    import z3\n    available_z3 = True\nexcept ImportError:\n    pass\n\ntry:\n    available_cvc5 = False\n    import cvc5.pythonic\n    available_cvc5 = True\nexcept ImportError:\n    pass", "\ntry:\n    available_cvc5 = False\n    import cvc5.pythonic\n    available_cvc5 = True\nexcept ImportError:\n    pass\n\ntry:\n    available_clingo = False\n    import clingo\n    available_clingo = True\nexcept ImportError:\n    pass", "try:\n    available_clingo = False\n    import clingo\n    available_clingo = True\nexcept ImportError:\n    pass\n\ntry:\n    available_pysat = False\n    import pysat.card\n    import pysat.formula\n    import pysat.examples.fm\n    import pysat.examples.rc2\n    import pysat.solvers\n    available_pysat = True\nexcept ImportError:\n    pass", "\n\n\nSOLVER_PRINT          = 'print'\nSOLVER_Z3             = 'z3'\nSOLVER_CVC5           = 'cvc5'\nSOLVER_CLINGO_FE      = 'clingo-fe'\nSOLVER_CLINGO_BE      = 'clingo-be'\nSOLVER_PYSAT_FM       = 'pysat-fm'\nSOLVER_PYSAT_RC2      = 'pysat-rc2'", "SOLVER_PYSAT_FM       = 'pysat-fm'\nSOLVER_PYSAT_RC2      = 'pysat-rc2'\nSOLVER_PYSAT_FM_BOOL  = 'pysat-fm-boolonly'\nSOLVER_PYSAT_RC2_BOOL = 'pysat-rc2-boolonly'\nSOLVER_PYSAT_MC       = 'pysat-minicard'\nSOLVER_LIST           = [SOLVER_PRINT, SOLVER_Z3, SOLVER_CVC5, SOLVER_CLINGO_FE, SOLVER_CLINGO_BE, SOLVER_PYSAT_FM, SOLVER_PYSAT_RC2, SOLVER_PYSAT_FM_BOOL, SOLVER_PYSAT_RC2_BOOL, SOLVER_PYSAT_MC]\nSOLVER_NOTEST_LIST    = [SOLVER_PRINT]\n\nPYSAT_OPTION_CARD     = 'card'\nPYSAT_OPTION_BOOLONLY = 'boolonly'", "PYSAT_OPTION_CARD     = 'card'\nPYSAT_OPTION_BOOLONLY = 'boolonly'\nPYSAT_ENCODING        = pysat.card.EncType.kmtotalizer\n\n\n\ndef solver_id_to_solver(solver_id):\n    if solver_id == SOLVER_PRINT:\n        return PrintSolver()\n    elif solver_id == SOLVER_Z3:\n        return Z3Solver()\n    elif solver_id == SOLVER_CVC5:\n        return CVC5Solver()\n    elif solver_id == SOLVER_CLINGO_FE:\n        return ClingoFrontendSolver()\n    elif solver_id == SOLVER_CLINGO_BE:\n        return ClingoBackendSolver()\n    elif solver_id == SOLVER_PYSAT_FM:\n        return PySatSolverFM()\n    elif solver_id == SOLVER_PYSAT_RC2:\n        return PySatSolverRC2()\n    elif solver_id == SOLVER_PYSAT_FM_BOOL:\n        return PySatSolverFMBoolOnly()\n    elif solver_id == SOLVER_PYSAT_RC2_BOOL:\n        return PySatSolverRC2BoolOnly()\n    elif solver_id == SOLVER_PYSAT_MC:\n        return PySatSolverMiniCard()\n    else:\n        util.check(False, 'solver ' + solver_id + ' unrecognized.')", "\n\n\nclass Solver:\n    def __init__(self, solver_id):\n        self._solver_id = solver_id\n\n    def get_id(self):\n        return self._solver_id\n\n    def make_var(self):\n        util.check(False, 'unimplemented')\n\n    def make_conj(self, vvs, settings):\n        util.check(False, 'unimplemented')\n\n    def cnstr_implies_disj(self, in_vv, in_vv_setting, out_vvs, out_vv_settings, weight):\n        util.check(False, 'unimplemented')\n\n    def cnstr_count(self, vvs, settings, lo, hi, weight):\n        util.check(False, 'unimplemented')\n\n    def solve(self):\n        util.check(False, 'unimplemented')\n\n    def get_var(self, vv):\n        util.check(False, 'unimplemented')\n\n    def get_objective(self):\n        util.check(False, 'unimplemented')", "\n\n\ndef _wrap_var(vv):\n    return ('v', vv)\n\ndef _wrap_conj(vv):\n    return ('c', vv)\n\ndef _is_var(vv):\n    return vv[0] == 'v'", "\ndef _is_var(vv):\n    return vv[0] == 'v'\n\ndef _is_conj(vv):\n    return vv[0] == 'c'\n\ndef _unwrap_var(vv):\n    util.check(type(vv) == tuple and len(vv) == 2 and vv[0] == 'v', 'unwrap')\n    return vv[1]", "\ndef _unwrap_conj(vv):\n    util.check(type(vv) == tuple and len(vv) == 2 and vv[0] == 'c', 'unwrap')\n    return vv[1]\n\ndef _unwrap_any(vv):\n    util.check(type(vv) == tuple and len(vv) == 2 and vv[0] in ['v', 'c'], 'unwrap')\n    return vv[1]\n\ndef _unwrap_lit_lconj(vv, setting, negate_func):\n    vv = _unwrap_any(vv)\n    if not setting:\n        vv = negate_func(vv)\n    return vv", "\ndef _unwrap_lit_lconj(vv, setting, negate_func):\n    vv = _unwrap_any(vv)\n    if not setting:\n        vv = negate_func(vv)\n    return vv\n\ndef _unwrap_lit_lconjs(vvs, settings, negate_func):\n    if settings in [True, False]:\n        settings = [settings for vv in vvs]\n    else:\n        util.check(len(vvs) == len(settings), 'different vvs and settings lengths')\n\n    return [_unwrap_lit_lconj(vv, setting, negate_func) for vv, setting in zip(vvs, settings)]", "\n\n\nclass SolverImpl(Solver):\n    def __init__(self, solver_id, weighted):\n        super().__init__(solver_id)\n\n        self._weighted = weighted\n\n        self._result = None\n        self._objective = None\n\n    def make_var(self):\n        return _wrap_var(self._IMPL_make_var())\n\n    def make_conj(self, vvs, settings):\n        util.check(len(vvs) > 0, 'empty conj')\n\n        return _wrap_conj(self._IMPL_make_conj(_unwrap_lit_lconjs(vvs, settings, self._IMPL_negate_var_conj)))\n\n    def cnstr_implies_disj(self, in_vv, in_vv_setting, out_vvs, out_vv_settings, weight):\n        if not self._weighted:\n            util.check(weight is None, 'solver does not support weights')\n            return self._IMPL_cnstr_implies_disj(_unwrap_lit_lconj(in_vv, in_vv_setting, self._IMPL_negate_var_conj), _unwrap_lit_lconjs(out_vvs, out_vv_settings, self._IMPL_negate_var_conj_for_implies_out))\n        else:\n            return self._IMPL_cnstr_implies_disj(_unwrap_lit_lconj(in_vv, in_vv_setting, self._IMPL_negate_var_conj), _unwrap_lit_lconjs(out_vvs, out_vv_settings, self._IMPL_negate_var_conj_for_implies_out), weight)\n\n    def cnstr_count(self, vvs, settings, lo, hi, weight):\n        util.check(0 <= lo and lo <= hi and hi <= len(vvs), 'count')\n\n        if not self._weighted:\n            util.check(weight is None, 'solver does not support weights')\n            return self._IMPL_cnstr_count(_unwrap_lit_lconjs(vvs, settings, self._IMPL_negate_var_conj), lo, hi)\n        else:\n            return self._IMPL_cnstr_count(_unwrap_lit_lconjs(vvs, settings, self._IMPL_negate_var_conj), lo, hi, weight)\n\n    def solve(self):\n        return self._IMPL_solve()\n\n    def get_var(self, vv):\n        return self._IMPL_get_var(_unwrap_var(vv))\n\n    def get_objective(self):\n        return self._objective\n\n    def _IMPL_negate_var_conj_for_implies_out(self, ll):\n        return self._IMPL_negate_var_conj(ll)\n\n    def _IMPL_negate_var_conj(self, ll):\n        util.check(False, 'unimplemented')\n\n    def _IMPL_make_var(self):\n        util.check(False, 'unimplemented')\n\n    def _IMPL_make_conj(self, lls):\n        util.check(False, 'unimplemented')\n\n    def _IMPL_cnstr_implies_disj(self, ll_in, lls_out, weight):\n        util.check(False, 'unimplemented')\n\n    def _IMPL_cnstr_count(self, lls, lo, hi, weight):\n        util.check(False, 'unimplemented')\n\n    def _IMPL_solve(self):\n        util.check(False, 'unimplemented')\n\n    def _IMPL_get_var(self, vv):\n        util.check(False, 'unimplemented')", "\n\n\nclass PortfolioSolver(Solver):\n    def __init__(self, solver_ids, timeout):\n        super().__init__('portfolio:' + ';'.join(solver_ids))\n\n        self._solver_ids = solver_ids\n        self._timeout = timeout\n\n        self._solver_var_conjs = []\n        self._solver_commands = []\n\n        self._result = None\n        self._objective = None\n\n    def make_var(self):\n        self._solver_var_conjs.append(_wrap_var(None))\n        return len(self._solver_var_conjs) - 1\n\n    def make_conj(self, vvs, settings):\n        util.check(len(vvs) > 0, 'empty conj')\n\n        self._solver_var_conjs.append(_wrap_conj((tuple(vvs), settings)))\n        return len(self._solver_var_conjs) - 1\n\n    def cnstr_implies_disj(self, in_vv, in_vv_setting, out_vvs, out_vv_settings, weight):\n        self._solver_commands.append(('cnstr_implies_disj', (in_vv, in_vv_setting, out_vvs, out_vv_settings, weight)))\n\n    def cnstr_count(self, vvs, settings, lo, hi, weight):\n        util.check(0 <= lo and lo <= hi and hi <= len(vvs), 'count')\n\n        self._solver_commands.append(('cnstr_count', (vvs, settings, lo, hi, weight)))\n\n    def solve(self):\n        q = multiprocessing.Queue()\n\n        procs = [(multiprocessing.Process(target=PortfolioSolver.run_solver, args=(q, index, solver_id, self._solver_var_conjs, self._solver_commands))) for (index, solver_id) in enumerate(self._solver_ids)]\n        for proc in procs:\n            proc.start()\n\n        result = None\n        try:\n            result = q.get(timeout=self._timeout)\n        except queue.Empty:\n            util.write_portfolio('portfolio timeout\\n')\n\n        for proc in procs:\n            proc.kill()\n\n        if result is None:\n            return False\n        else:\n            index, self._result, self._objective = result\n            util.write_portfolio('portfolio using %d %s\\n' % (index, self._solver_ids[index]))\n            return True\n\n    def get_var(self, vv):\n        return self._result[vv]\n\n    def get_objective(self):\n        return self._objective\n\n    @staticmethod\n    def run_solver(s_q, s_index, s_solver_id, s_solver_var_conjs, s_solver_commands):\n        s_ret = None\n\n        try:\n            util.write_portfolio('portfolio starting %d %s\\n' % (s_index, s_solver_id))\n\n            s_solver = solver_id_to_solver(s_solver_id)\n\n            s_var_conj_map = {}\n\n            def translate_vars(_vvv):\n                nonlocal s_var_conj_map\n                if type(_vvv) in [list, tuple]:\n                    return [s_var_conj_map[_vv] for _vv in _vvv]\n                else:\n                    return s_var_conj_map[_vvv]\n\n            s_vars_inds = []\n            s_conjs_inds = []\n\n            for s_ind, s_var_conj in enumerate(s_solver_var_conjs):\n                if _is_var(s_var_conj):\n                    s_vars_inds.append(s_ind)\n                elif _is_conj(s_var_conj):\n                    s_conjs_inds.append(s_ind)\n                else:\n                    util.check(False, 'var_conj')\n\n            random.Random(s_index).shuffle(s_vars_inds)\n\n            for s_ind in s_vars_inds:\n                util.check(_is_var(s_solver_var_conjs[s_ind]), 'var')\n                s_var_conj_map[s_ind] = s_solver.make_var()\n\n            for s_ind in s_conjs_inds:\n                util.check(_is_conj(s_solver_var_conjs[s_ind]), 'conj')\n                s_info = _unwrap_conj(s_solver_var_conjs[s_ind])\n                s_var_conj_map[s_ind] = s_solver.make_conj(translate_vars(s_info[0]), s_info[1])\n\n            for s_func_name, s_args in s_solver_commands:\n                if s_func_name == 'cnstr_implies_disj':\n                    s_solver.cnstr_implies_disj(translate_vars(s_args[0]), s_args[1], translate_vars(s_args[2]), s_args[3], s_args[4])\n                elif s_func_name == 'cnstr_count':\n                    s_solver.cnstr_count(translate_vars(s_args[0]), s_args[1], s_args[2], s_args[3], s_args[4])\n                else:\n                    util.check(False, 's_func_name')\n\n            if s_solver.solve():\n                s_vars_set = {}\n                for s_ind, s_var_conj in enumerate(s_solver_var_conjs):\n                    if _is_var(s_var_conj):\n                        s_vars_set[s_ind] = s_solver.get_var(translate_vars(s_ind))\n\n                s_ret = (s_index, s_vars_set, s_solver.get_objective())\n\n            util.write_portfolio('portfolio finishing %d %s\\n' % (s_index, s_solver_id))\n\n        except Exception as e:\n            util.write_portfolio('portfolio error %d %s %s\\n' % (s_index, s_solver_id, e))\n\n        s_q.put(s_ret)", "\n\n\nclass PrintSolver(SolverImpl):\n    def __init__(self):\n        super().__init__(SOLVER_PRINT, True)\n\n        self._curr_id = 0\n        self._output = {}\n        self._output['var'] = []\n        self._output['conj'] = []\n        self._output['cnstr_implies_disj'] = []\n        self._output['cnstr_count'] = []\n\n    def _IMPL_negate_var_conj(self, ll):\n        return '~' + ll\n\n    def _IMPL_make_var(self):\n        self._curr_id += 1\n        ret = 'v%d' % self._curr_id\n        self._output['var'].append({'id':ret})\n        return ret\n\n    def _IMPL_make_conj(self, lls):\n        self._curr_id += 1\n        ret = 'c%d' % self._curr_id\n        self._output['conj'].append({'id':ret, 'of':lls})\n        return ret\n\n    def _IMPL_cnstr_implies_disj(self, in_ll, out_lls, weight):\n        print_weight = weight if weight is not None else 0\n        self._output['cnstr_implies_disj'].append({'if':in_ll, 'then':out_lls, 'weight':print_weight})\n\n    def _IMPL_cnstr_count(self, lls, lo, hi, weight):\n        print_weight = weight if weight is not None else 0\n        self._output['cnstr_count'].append({'of':lls, 'min':lo, 'max':hi, 'weight':print_weight})\n\n    def _IMPL_solve(self):\n        print(json.dumps(self._output, indent=2))\n        return False", "\n\n\nclass Z3Solver(SolverImpl):\n    def __init__(self):\n        util.check(available_z3, 'z3 not available')\n\n        super().__init__(SOLVER_Z3, True)\n\n        self._s = z3.Optimize()\n\n    def _help_add_cnstr_weight(self, cnstr, weight):\n        if weight is None:\n            self._s.add(cnstr)\n        else:\n            self._s.add_soft(cnstr, weight)\n\n    def _IMPL_negate_var_conj(self, ll):\n        return z3.Not(ll)\n\n    def _IMPL_make_var(self):\n        return z3.FreshBool()\n\n    def _IMPL_make_conj(self, lls):\n        if len(lls) == 1:\n            return lls[0]\n        else:\n            return z3.And(*lls)\n\n    def _IMPL_cnstr_implies_disj(self, in_ll, out_lls, weight):\n        self._help_add_cnstr_weight(z3.Implies(in_ll, z3.Or(*out_lls)), weight)\n\n    def _IMPL_cnstr_count(self, lls, lo, hi, weight):\n        if len(lls) == 0:\n            pass\n\n        elif len(lls) == 1:\n            if lo == 0 and hi == 1:\n                pass\n            elif lo == 0 and hi == 0:\n                self._help_add_cnstr_weight(z3.Not(lls[0]), weight)\n            elif lo == 1 and hi == 1:\n                self._help_add_cnstr_weight(lls[0], weight)\n            else:\n                util.check(False, 'count vars')\n\n        else:\n            lls_count = [(vv, 1) for vv in lls]\n\n            if lo == hi:\n                self._help_add_cnstr_weight(z3.PbEq(lls_count, lo), weight)\n            else:\n                if lo == 0:\n                    pass\n                elif lo == 1:\n                    self._help_add_cnstr_weight(z3.Or(lls), weight)\n                else:\n                    self._help_add_cnstr_weight(z3.PbGe(lls_count, lo), weight)\n\n                if hi < len(lls):\n                    self._help_add_cnstr_weight(z3.PbLe(lls_count, hi), weight)\n\n    def _IMPL_solve(self):\n        def on_model(_m):\n            util.write_time('.')\n\n        self._s.set_on_model(on_model)\n\n        chk = self._s.check()\n        util.write_time('\\n')\n        util.write_time(str(chk) + '\\n')\n\n        if chk == z3.unsat:\n            return False\n\n        if chk == z3.unknown:\n            util.write_time(str(self._s.reason_unknown()) + '\\n')\n            return False\n\n        self._result = self._s.model()\n\n        objs = [self._s.model().evaluate(obj) for obj in self._s.objectives()]\n        if len(objs) == 0:\n            self._objective = 0\n        else:\n            util.check(len(objs) == 1, 'cost length')\n            self._objective = objs[0].as_long()\n\n        return True\n\n    def _IMPL_get_var(self, vv):\n        return bool(self._result[vv])", "\n\n\nclass CVC5Solver(SolverImpl):\n    def __init__(self):\n        util.check(available_cvc5, 'cvc5 not available')\n\n        super().__init__(SOLVER_CVC5, False)\n\n        self._s = cvc5.pythonic.SimpleSolver()\n\n    def _IMPL_negate_var_conj(self, ll):\n        return cvc5.pythonic.Not(ll)\n\n    def _IMPL_make_var(self):\n        return cvc5.pythonic.FreshBool()\n\n    def _IMPL_make_conj(self, lls):\n        if len(lls) == 1:\n            return lls[0]\n        else:\n            return cvc5.pythonic.And(*lls)\n\n    def _IMPL_cnstr_implies_disj(self, in_ll, out_lls):\n        if len(out_lls) == 0:\n            self._s.add(cvc5.pythonic.Implies(in_ll, False))\n        elif len(out_lls) == 1:\n            self._s.add(cvc5.pythonic.Implies(in_ll, out_lls[0]))\n        else:\n            self._s.add(cvc5.pythonic.Implies(in_ll, cvc5.pythonic.Or(*out_lls)))\n\n    def _IMPL_cnstr_count(self, lls, lo, hi):\n        if len(lls) == 0:\n            pass\n\n        elif len(lls) == 1:\n            if lo == 0 and hi == 1:\n                pass\n            elif lo == 0 and hi == 0:\n                self._s.add(cvc5.pythonic.Not(lls[0]))\n            elif lo == 1 and hi == 1:\n                self._s.add(lls[0])\n            else:\n                util.check(False, 'count vars')\n\n        else:\n            lls_if = sum([cvc5.pythonic.If(ll, 1, 0) for ll in lls])\n\n            if lo == hi:\n                self._s.add(lls_if == lo)\n            else:\n                if lo == 0:\n                    pass\n                elif lo == 1:\n                    self._s.add(cvc5.pythonic.Or(lls))\n                else:\n                    self._s.add(lls_if >= lo)\n\n                if hi < len(lls):\n                    self._s.add(lls_if <= hi)\n\n    def _IMPL_solve(self):\n        chk = self._s.check()\n        util.write_time('\\n')\n        util.write_time(str(chk) + '\\n')\n\n        if chk == cvc5.pythonic.unsat:\n            return False\n\n        if chk == cvc5.pythonic.unknown:\n            util.write_time(str(self._s.reason_unknown()) + '\\n')\n            return False\n\n        self._result = self._s.model()\n        self._objective = 0\n\n        return True\n\n    def _IMPL_get_var(self, vv):\n        return bool(self._result[vv])", "\n\n\nclass ClingoFrontendSolver(SolverImpl):\n    def __init__(self):\n        util.check(available_clingo, 'clingo not available')\n\n        super().__init__(SOLVER_CLINGO_FE, True)\n\n        self._ctl_init()\n\n        self._curr_id = 0\n        self._soft_var_weights = {}\n\n    def _ctl_init(self):\n        args = ['--rand-freq=0.2', '--seed=0']\n        self._ctl = clingo.Control(args)\n\n    def _ctl_add_rule(self, rule):\n        self._ctl.add('base', [], rule)\n\n    def _ctl_ground(self):\n        self._ctl.ground([('base', [])])\n\n    def _ctl_solve(self, on_model):\n        self._ctl.solve(on_model=on_model)\n\n    def _help_new_soft_var(self, weight):\n        weight_func = 'soft%d' % weight\n\n        if weight in self._soft_var_weights:\n            util.check(self._soft_var_weights[weight] == weight_func, 'weight and weight_func mismatch')\n        else:\n            self._soft_var_weights[weight] = weight_func\n\n        self._curr_id += 1\n        soft_var = '%s(%d)' % (weight_func, self._curr_id)\n        self._ctl_add_rule('0{ %s }1.' % soft_var)\n\n        return soft_var\n\n    def _help_new_var(self):\n        self._curr_id += 1\n        new_var = 'var(%d)' % self._curr_id\n        self._ctl_add_rule('0{ %s }1.' % new_var)\n\n        return new_var\n\n    def _IMPL_negate_var_conj(self, ll):\n        return 'not %s' % ll\n\n    def _IMPL_make_var(self):\n        return self._help_new_var()\n\n    def _IMPL_make_conj(self, lls):\n        if len(lls) == 1:\n            return lls[0]\n        else:\n            conj_var = self._help_new_var()\n            for ll in lls:\n                self._ctl_add_rule('%s :- %s.' % (ll, conj_var))\n            self._ctl_add_rule('%s :- %s.' % (conj_var, ','.join(lls)))\n            return conj_var\n\n    def _IMPL_cnstr_implies_disj(self, in_ll, out_lls, weight):\n        soft_var = []\n        if weight is not None:\n            soft_var = [self._help_new_soft_var(weight)]\n\n        self._ctl_add_rule('%s :- %s.' % (';'.join(out_lls + soft_var), in_ll))\n\n    def _IMPL_cnstr_count(self, lls, lo, hi, weight):\n        soft_var_body = None\n        def get_soft_var_body():\n            nonlocal soft_var_body\n            if soft_var_body is None:\n                if weight is None:\n                    soft_var_body = ''\n                else:\n                    soft_var_body = ' :- not %s' % self._help_new_soft_var(weight)\n            return soft_var_body\n\n        if len(lls) == 0:\n            pass\n\n        elif len(lls) == 1:\n            if lo == 0 and hi == 1:\n                pass\n            elif lo == 0 and hi == 0:\n                self._ctl_add_rule('not %s%s.' % (lls[0], get_soft_var_body()))\n            elif lo == 1 and hi == 1:\n                self._ctl_add_rule('%s%s.' % (lls[0], get_soft_var_body()))\n            else:\n                util.check(False, 'count vars')\n\n        else:\n            lo_str = ''\n            if lo > 0:\n                lo_str = str(lo)\n\n            hi_str = ''\n            if hi < len(lls):\n                hi_str = str(hi)\n\n            if lo_str != '' or hi_str != '':\n                self._ctl_add_rule('%s{ %s }%s%s.' % (lo_str, ';'.join(lls), hi_str, get_soft_var_body()))\n\n    def _IMPL_solve(self):\n        def on_model(_m):\n            util.write_time('.')\n\n            if len(_m.cost) == 0:\n                self._objective = 0\n            else:\n                util.check(len(_m.cost) == 1, 'cost length')\n                self._objective = _m.cost[0]\n\n            self._result = {}\n            for symbol in _m.symbols(atoms=True):\n                self._result[str(symbol)] = None\n\n        for weight, weight_func in self._soft_var_weights.items():\n            self._ctl_add_rule('#minimize{ %d, ID : %s(ID) }.' % (weight, weight_func))\n\n        self._ctl_ground()\n        self._ctl_solve(on_model)\n        util.write_time('\\n')\n\n        return self._result is not None\n\n    def _IMPL_get_var(self, vv):\n        return vv in self._result", "\n\n\nclass ClingoBackendSolver(SolverImpl):\n    def __init__(self):\n        util.check(available_clingo, 'clingo not available')\n\n        super().__init__(SOLVER_CLINGO_BE, True)\n\n        self._ctl = clingo.Control()\n\n        self._all_atoms = []\n\n    def _help_new_var(self, be):\n        ret = be.add_atom()\n        self._all_atoms.append(ret)\n        be.add_rule([ret], choice=True)\n        return ret\n\n    def _IMPL_negate_var_conj_for_implies_out(self, ll):\n        # TODO: is there a better way to get negative literals in the head of a rule?\n        with self._ctl.backend() as be:\n            opp_ll = self._help_new_var(be)\n            # one is true, one is false\n            be.add_rule([], [ll, opp_ll])\n            be.add_rule([], [-ll, -opp_ll])\n            return opp_ll\n\n    def _IMPL_negate_var_conj(self, ll):\n        return -ll\n\n    def _IMPL_make_var(self):\n        with self._ctl.backend() as be:\n            return self._help_new_var(be)\n\n    def _IMPL_make_conj(self, lls):\n        if len(lls) == 1:\n            return lls[0]\n        else:\n            with self._ctl.backend() as be:\n                conj_var = self._help_new_var(be)\n                for ll in lls:\n                    be.add_rule([], [-ll, conj_var])\n                be.add_rule([conj_var], lls)\n                return conj_var\n\n    def _IMPL_cnstr_implies_disj(self, in_ll, out_lls, weight):\n        with self._ctl.backend() as be:\n            soft_var = []\n            if weight is not None:\n                soft_var = [self._help_new_var(be)]\n\n            be.add_rule(out_lls + soft_var, [in_ll])\n\n            if len(soft_var) != 0:\n                util.check(len(soft_var) == 1, 'soft var')\n                be.add_minimize(1, [(soft_var[0], weight)])\n\n    def _IMPL_cnstr_count(self, lls, lo, hi, weight):\n        with self._ctl.backend() as be:\n            soft_var = None\n            def get_soft_var():\n                nonlocal soft_var\n                if soft_var is None:\n                    if weight is None:\n                        soft_var = []\n                    else:\n                        soft_var = [self._help_new_var(be)]\n                        be.add_minimize(1, [(soft_var[0], weight)])\n                return soft_var\n\n            if len(lls) == 0:\n                pass\n\n            elif len(lls) == 1:\n                if lo == 0 and hi == 1:\n                    pass\n                elif lo == 0 and hi == 0:\n                    be.add_rule(get_soft_var(), [lls[0]])\n                elif lo == 1 and hi == 1:\n                    be.add_rule(get_soft_var(), [-lls[0]])\n                else:\n                    util.check(False, 'count vars')\n\n            else:\n                if lo == 0:\n                    pass\n                elif lo == 1:\n                    be.add_rule(get_soft_var(), [-ll for ll in lls])\n                else:\n                    be.add_weight_rule(get_soft_var(), len(lls) + 1 - lo, [(-ll, 1) for ll in lls])\n\n                if hi < len(lls):\n                    be.add_weight_rule(get_soft_var(), hi + 1, [(ll, 1) for ll in lls])\n\n    def _IMPL_solve(self):\n        def on_model(_m):\n            util.write_time('.')\n\n            if len(_m.cost) == 0:\n                self._objective = 0\n            else:\n                util.check(len(_m.cost) == 1, 'cost length')\n                self._objective = _m.cost[0]\n\n            self._result = {}\n            for atom in self._all_atoms:\n                if _m.is_true(atom):\n                    self._result[atom] = None\n\n        self._ctl.solve(on_model=on_model)\n        util.write_time('\\n')\n\n        return self._result is not None\n\n    def _IMPL_get_var(self, vv):\n        return vv in self._result", "\n\n\nclass PySatSolverMiniCard(SolverImpl):\n    def __init__(self):\n        util.check(available_pysat, 'pysat not available')\n\n        super().__init__(SOLVER_PYSAT_MC, False)\n\n        self._s = pysat.solvers.Solver(name='mc')\n\n        self._curr_id = 0\n\n    def _next_var(self):\n        self._curr_id += 1\n        return self._curr_id\n\n    def _IMPL_negate_var_conj(self, ll):\n        return -ll\n\n    def _IMPL_make_var(self):\n        return self._next_var()\n\n    def _IMPL_make_conj(self, lls):\n        if len(lls) == 1:\n            return lls[0]\n        else:\n            conj_var = self._next_var()\n            for ll in lls:\n                self._s.add_clause([-conj_var, ll]) # ... conj_var -> A ll\n            self._s.add_clause([-ll for ll in lls] + [conj_var]) # A lls -> conj_var\n            return conj_var\n\n    def _IMPL_cnstr_implies_disj(self, in_ll, out_lls):\n        self._s.add_clause([-in_ll] + out_lls)\n\n    def _IMPL_cnstr_count(self, lls, lo, hi):\n        if len(lls) == 0:\n            pass\n\n        elif len(lls) == 1:\n            if lo == 0 and hi == 1:\n                pass\n            elif lo == 0 and hi == 0:\n                self._s.add_clause([-lls[0]])\n            elif lo == 1 and hi == 1:\n                self._s.add_clause([lls[0]])\n            else:\n                util.check(False, 'count vars')\n\n        else:\n            if lo == 0:\n                pass\n            elif lo == 1:\n                self._s.add_clause(lls)\n            else:\n                self._s.add_atmost([-ll for ll in lls], len(lls) - lo)\n\n            if hi < len(lls):\n                self._s.add_atmost(lls, hi)\n\n    def _IMPL_solve(self):\n        if not self._s.solve():\n            return False\n\n        self._result = self._s.get_model()\n        self._objective = 0\n\n        return True\n\n    def _IMPL_get_var(self, vv):\n        return self._result[vv - 1] > 0", "\n\n\nclass _PySatSolverWeighted(SolverImpl):\n    def __init__(self, solver_id, solver_option):\n        util.check(available_pysat, 'pysat not available')\n\n        util.check(solver_option in [PYSAT_OPTION_CARD, PYSAT_OPTION_BOOLONLY], 'invalid option for solver: ' + solver_option)\n\n        super().__init__(solver_id, True)\n\n        self._option = solver_option\n\n        if self._option == PYSAT_OPTION_CARD:\n            self._wcnf = pysat.formula.WCNFPlus()\n        else:\n            self._wcnf = pysat.formula.WCNF()\n\n        self._curr_id = 0\n\n    def _help_get_args_dict(self):\n        args_dict = {}\n        if self._option == PYSAT_OPTION_CARD:\n            args_dict['solver'] = 'minicard'\n        return args_dict\n\n    def _next_var(self):\n        self._curr_id += 1\n        return self._curr_id\n\n    def _IMPL_negate_var_conj(self, ll):\n        return -ll\n\n    def _IMPL_make_var(self):\n        return self._next_var()\n\n    def _IMPL_make_conj(self, lls):\n        if len(lls) == 1:\n            return lls[0]\n        else:\n            conj_var = self._next_var()\n            for ll in lls:\n                self._wcnf.append([-conj_var, ll]) # ... conj_var -> A ll\n            self._wcnf.append([-ll for ll in lls] + [conj_var]) # A lls -> conj_var\n            return conj_var\n\n    def _IMPL_cnstr_implies_disj(self, in_ll, out_lls, weight):\n        self._wcnf.append([-in_ll] + out_lls, weight=weight)\n\n    def _IMPL_cnstr_count(self, lls, lo, hi, weight):\n        if len(lls) == 0:\n            pass\n\n        elif len(lls) == 1:\n            if lo == 0 and hi == 1:\n                pass\n            elif lo == 0 and hi == 0:\n                self._wcnf.append([-lls[0]], weight=weight)\n            elif lo == 1 and hi == 1:\n                self._wcnf.append([lls[0]], weight=weight)\n            else:\n                util.check(False, 'count vars')\n\n        else:\n            if self._option == PYSAT_OPTION_CARD and weight is None: # PySat currently only supports hard cardinality constraints\n                if lo == 0:\n                    pass\n                elif lo == 1:\n                    self._wcnf.append(lls)\n                else:\n                    self._wcnf.append([[-ll for ll in lls], len(lls) - lo], is_atmost=True)\n\n                if hi < len(lls):\n                    self._wcnf.append([lls, hi], is_atmost=True)\n\n            else:\n                label_var_cls = []\n\n                if lo == 0:\n                    pass\n                elif lo == 1:\n                    self._wcnf.append(lls, weight=weight)\n                else:\n                    if weight is not None and len(label_var_cls) == 0:\n                        label_var_cls = [self._next_var()]\n\n                    cnf = pysat.card.CardEnc.atleast(lits=lls, bound=lo, top_id=self._curr_id, encoding=PYSAT_ENCODING)\n                    for cls in cnf:\n                        self._wcnf.append(cls + label_var_cls)\n                        self._curr_id = max(self._curr_id, max(cls))\n\n                if hi < len(lls):\n                    if weight is not None and len(label_var_cls) == 0:\n                        label_var_cls = [self._next_var()]\n\n                    cnf = pysat.card.CardEnc.atmost(lits=lls, bound=hi, top_id=self._curr_id, encoding=PYSAT_ENCODING)\n                    for cls in cnf:\n                        self._wcnf.append(cls + label_var_cls)\n                        self._curr_id = max(self._curr_id, max(cls))\n\n                for label_var in label_var_cls:\n                    self._wcnf.append([-label_var], weight=weight)\n\n    def _IMPL_solve(self):\n        model, cost = self._do_solve()\n\n        if not model:\n            return False\n\n        self._result = model\n        self._objective = cost\n\n        return True\n\n    def _IMPL_get_var(self, vv):\n        return self._result[vv - 1] > 0", "\nclass _PySatSolverFM(_PySatSolverWeighted):\n    def __init__(self, solver_id, solver_option):\n        super().__init__(solver_id, solver_option)\n\n    def _do_solve(self):\n        fm = pysat.examples.fm.FM(self._wcnf, **self._help_get_args_dict())\n        if fm.compute():\n            return fm.model, fm.cost\n\n        return None, None", "\nclass PySatSolverFM(_PySatSolverFM):\n    def __init__(self):\n        super().__init__(SOLVER_PYSAT_FM, PYSAT_OPTION_CARD)\n\nclass PySatSolverFMBoolOnly(_PySatSolverFM):\n    def __init__(self):\n        super().__init__(SOLVER_PYSAT_FM_BOOL, PYSAT_OPTION_BOOLONLY)\n\nclass _PySatSolverRC2(_PySatSolverWeighted):\n    def __init__(self, solver_id, solver_option):\n        super().__init__(solver_id, solver_option)\n\n    def _do_solve(self):\n        with pysat.examples.rc2.RC2(self._wcnf, **self._help_get_args_dict()) as rc2:\n            for m in rc2.enumerate():\n                return list(m), rc2.cost\n\n        return None, None", "\nclass _PySatSolverRC2(_PySatSolverWeighted):\n    def __init__(self, solver_id, solver_option):\n        super().__init__(solver_id, solver_option)\n\n    def _do_solve(self):\n        with pysat.examples.rc2.RC2(self._wcnf, **self._help_get_args_dict()) as rc2:\n            for m in rc2.enumerate():\n                return list(m), rc2.cost\n\n        return None, None", "\nclass PySatSolverRC2(_PySatSolverRC2):\n    def __init__(self):\n        super().__init__(SOLVER_PYSAT_RC2, PYSAT_OPTION_CARD)\n\nclass PySatSolverRC2BoolOnly(_PySatSolverRC2):\n    def __init__(self):\n        super().__init__(SOLVER_PYSAT_RC2_BOOL, PYSAT_OPTION_BOOLONLY)\n", ""]}
{"filename": "util_graph.py", "chunked_list": ["import sys\nimport util\nimport networkx as nx\n\n\n\nATTR_LABEL     = 'label'\nATTR_POSITION  = 'pos'\nATTR_HIGHLIGHT = 'highlight'\n", "ATTR_HIGHLIGHT = 'highlight'\n\nGTYPE_UTREE    = 'utree'\nGTYPE_DTREE    = 'dtree'\nGTYPE_DAG      = 'dag'\nGTYPE_UGRAPH   = 'ugraph'\nGTYPE_LIST     = [GTYPE_UTREE, GTYPE_DTREE, GTYPE_DAG, GTYPE_UGRAPH]\n\nLABEL_GRID_EAST  = 'e'\nLABEL_GRID_SOUTH = 's'", "LABEL_GRID_EAST  = 'e'\nLABEL_GRID_SOUTH = 's'\n\nDIR_FRA        = 'fra'\nDIR_TIL        = 'til'\n\n\n\nclass Graphs:\n    def __init__(self):\n        self.gtype = None\n        self.colors = {}\n        self.graphs = []", "class Graphs:\n    def __init__(self):\n        self.gtype = None\n        self.colors = {}\n        self.graphs = []\n\nclass GraphDesc:\n    def __init__(self):\n        self.gtype = None\n        self.colors = {}\n\n        self.node_labels = {}\n        self.edge_labels = {}\n\n        self.node_label_count = {}\n        self.node_label_neighbors = {}", "\n\n\ndef gtype_directed(gtype):\n    if gtype in [GTYPE_DTREE, GTYPE_DAG]:\n        return True\n    elif gtype in [GTYPE_UTREE, GTYPE_UGRAPH]:\n        return False\n    else:\n        util.check(False, 'Unknown gtype ' + str(gtype))", "\ndef gtype_tree(gtype):\n    if gtype in [GTYPE_UTREE, GTYPE_DTREE]:\n        return True\n    elif gtype in [GTYPE_DAG, GTYPE_UGRAPH]:\n        return False\n    else:\n        util.check(False, 'Unknown gtype ' + str(gtype))\n\ndef check_graph(gr, gtype):\n    util.check(len(gr.nodes) > 0, 'no nodes')\n\n    if gtype_directed(gtype):\n        util.check(nx.is_weakly_connected(gr), 'not connected')\n    else:\n        util.check(nx.is_connected(gr), 'not connected')\n\n    if gtype_tree(gtype):\n        util.check(nx.is_tree(gr), 'not a tree')\n\n    if gtype_directed(gtype):\n        util.check(nx.is_directed_acyclic_graph(gr), 'not dag')", "\ndef check_graph(gr, gtype):\n    util.check(len(gr.nodes) > 0, 'no nodes')\n\n    if gtype_directed(gtype):\n        util.check(nx.is_weakly_connected(gr), 'not connected')\n    else:\n        util.check(nx.is_connected(gr), 'not connected')\n\n    if gtype_tree(gtype):\n        util.check(nx.is_tree(gr), 'not a tree')\n\n    if gtype_directed(gtype):\n        util.check(nx.is_directed_acyclic_graph(gr), 'not dag')", "\ndef nodes_and_labels(gr):\n    return [(node, gr.nodes[node][ATTR_LABEL]) for node in gr.nodes]\n\ndef edges_and_labels(gr):\n    return [(edge[0], edge[1], gr.edges[edge][ATTR_LABEL]) for edge in gr.edges]\n\ndef read_graphs(filenames):\n    grs = Graphs()\n\n    grs.gtype = None\n    grs.colors = {}\n    grs.graphs = []\n\n    colors_warned = {}\n\n    for filename in filenames:\n        gr = None\n        with util.openz(filename, 'rt') as infile:\n            for line in infile:\n                if '#' in line:\n                    line = line[:line.find('#')]\n\n                line = line.strip()\n                if len(line) == 0:\n                    continue\n\n                splt = line.split()\n                if splt[0] == 't':\n                    util.check(len(splt) == 2, 'splt len')\n                    util.check(splt[1] in GTYPE_LIST, 'gtype')\n                    if grs.gtype is None:\n                        grs.gtype = splt[1]\n                    else:\n                        util.check(splt[1] == grs.gtype, 'gtype mismatch')\n\n                    util.check(gr is None, 'mutliple t')\n                    if gtype_directed(grs.gtype):\n                        gr = nx.DiGraph()\n                    else:\n                        gr = nx.Graph()\n\n                elif splt[0] == 'n':\n                    util.check(len(splt) in [2, 3], 'splt len')\n                    node = splt[1]\n                    util.check(not gr.has_node(node), 'no duplicate nodes')\n                    gr.add_node(node)\n                    if len(splt) == 3:\n                        gr.nodes[node][ATTR_LABEL] = splt[2]\n                    else:\n                        gr.nodes[node][ATTR_LABEL] = ''\n\n                elif splt[0] == 'e':\n                    util.check(len(splt) in [3, 4], 'splt len')\n                    fra, til = splt[1], splt[2]\n                    util.check(fra != til, 'no self edges')\n                    util.check(not gr.has_edge(fra, til), 'no duplicate edges')\n                    gr.add_edge(fra, til)\n                    if len(splt) == 4:\n                        gr.edges[(fra, til)][ATTR_LABEL] = splt[3]\n                    else:\n                        gr.edges[(fra, til)][ATTR_LABEL] = ''\n\n                elif splt[0] == 'c':\n                    util.check(len(splt) == 3, 'splt len')\n                    label = splt[1]\n                    color = splt[2]\n                    if label not in grs.colors:\n                        grs.colors[label] = color\n                    elif grs.colors[label] != color and label not in colors_warned:\n                        print('WARNING: multiple colors for same label', label)\n                        colors_warned[label] = None\n\n                elif splt[0] == 'p':\n                    util.check(len(splt) == 4, 'splt len')\n                    node = splt[1]\n                    xx = int(splt[2])\n                    yy = int(splt[3])\n                    gr.nodes[node][ATTR_POSITION] = (xx, yy)\n\n                elif splt[0] == 'h':\n                    util.check(len(splt) == 2, 'splt len')\n                    node = splt[1]\n                    gr.nodes[node][ATTR_HIGHLIGHT] = True\n\n                else:\n                    util.check(False, 'line: ' + line)\n\n        if gr is not None:\n            check_graph(gr, grs.gtype)\n\n            grs.graphs.append(gr)\n\n    util.check(len(grs.graphs) != 0, 'no graphs loaded')\n\n    return grs", "\ndef write_graph(grs, out):\n    util.check(len(grs.graphs) == 1, 'can only write single graph')\n    gr = grs.graphs[0]\n\n    out.write(f't {grs.gtype}\\n')\n    for label, color in grs.colors.items():\n        out.write(f'c {label} {color}\\n')\n    for node, label in nodes_and_labels(gr):\n        if label == '':\n            out.write(f'n {node}\\n')\n        else:\n            out.write(f'n {node} {label}\\n')\n    for fra, til, label in edges_and_labels(gr):\n        if label == '':\n            out.write(f'e {fra} {til}\\n')\n        else:\n            out.write(f'e {fra} {til} {label}\\n')\n    for node in gr.nodes:\n        if ATTR_POSITION in gr.nodes[node]:\n            xx, yy = gr.nodes[node][ATTR_POSITION]\n            out.write(f'p {node} {xx} {yy}\\n')\n    for node in gr.nodes:\n        if ATTR_HIGHLIGHT in gr.nodes[node]:\n            out.write(f'h {node}\\n')", "\ndef write_graph_dot(grs, out):\n    if gtype_directed(grs.gtype):\n        dtype = 'digraph'\n        dedge = '->'\n    else:\n        dtype = 'graph'\n        dedge = '--'\n\n    out.write(f'{dtype} G {{\\n')\n    out.write(f'  node [shape=\"circle\" fontsize=\"24\" width=\"0.5\" height=\"0.5\" fixedsize=\"true\"]\\n')\n    out.write(f'  edge [fontsize=\"20\"]\\n')\n    for gg, gr in enumerate(grs.graphs):\n        if len(grs.graphs) > 1:\n            nodeprefix = f'{gg}-'\n        else:\n            nodeprefix = ''\n\n        for node, label in nodes_and_labels(gr):\n            attrs = ''\n            if label == '':\n                attrs += f'label=\"\"'\n            else:\n                attrs += f'label=\"{label}\"'\n\n            if len(label) > 1:\n                fontsize = max(6, 24 - 2.5 * (len(label) - 1))\n                attrs += f' fontsize=\"{fontsize}\"'\n\n            if label in grs.colors:\n                attrs += f' style=\"filled\" fillcolor=\"#{grs.colors[label]}\"'\n            else:\n                attrs += f' style=\"filled\" fillcolor=\"#eeeeee\"'\n\n            if ATTR_POSITION in gr.nodes[node]:\n                xx, yy = gr.nodes[node][ATTR_POSITION]\n                attrs += f' pos=\"{xx},{yy}!\"'\n\n            if ATTR_HIGHLIGHT in gr.nodes[node]:\n                attrs += f' shape=\"doublecircle\"'\n\n            out.write(f'  \"{nodeprefix}{node}\" [{attrs}]\\n')\n        for fra, til, label in edges_and_labels(gr):\n            attrs = ''\n            if label == '':\n                attrs += f'label=\"\"'\n            else:\n                attrs += f'label=\"{label}\"'\n\n            if len(label) > 1:\n                fontsize = max(6, 24 - 2.5 * (len(label) - 1))\n                attrs += f' fontsize=\"{fontsize}\"'\n\n            out.write(f'  \"{nodeprefix}{fra}\" {dedge} \"{nodeprefix}{til}\" [{attrs}]\\n')\n    out.write('}\\n')", "\ndef write_graph_to_file(grs, filename):\n    if filename is None:\n        write_graph(grs, sys.stdout)\n    else:\n        with util.openz(filename, 'wt') as outfile:\n            if util.fileistype(filename, '.dot'):\n                write_graph_dot(grs, outfile)\n            else:\n                write_graph(grs, outfile)", "\ndef layout_grid(gr):\n    roots = [nn for nn, dd in gr.in_degree() if dd == 0]\n    util.check(len(roots) == 1, 'grid does not have 1 root')\n    root = roots[0]\n\n    used_pos = {}\n\n    queue = [root]\n    gr.nodes[root][ATTR_POSITION] = (0, 0)\n    used_pos[(0, 0)] = root\n\n    while len(queue) != 0:\n        node = queue[0]\n        queue = queue[1:]\n        out_edges = gr.out_edges(node)\n\n        pos = gr.nodes[node][ATTR_POSITION]\n\n        for out_edge in out_edges:\n            out_node = out_edge[1]\n            if gr.edges[out_edge][ATTR_LABEL] == LABEL_GRID_EAST:\n                out_pos = (pos[0] + 1, pos[1])\n            elif gr.edges[out_edge][ATTR_LABEL] == LABEL_GRID_SOUTH:\n                out_pos = (pos[0], pos[1] - 1)\n            else:\n                util.check(False, 'grid edge label')\n\n            if ATTR_POSITION in gr.nodes[out_node]:\n                util.check(gr.nodes[out_node][ATTR_POSITION] == out_pos, 'different positions found')\n\n            else:\n                util.check(out_pos not in used_pos, 'duplicate pos')\n                gr.nodes[out_node][ATTR_POSITION] = out_pos\n                used_pos[out_pos] = out_node\n\n                queue.append(out_node)", ""]}
{"filename": "tile2graph.py", "chunked_list": ["import argparse, os, shutil, pickle, sys\nimport util, util_graph\nimport networkx as nx\n\n\n\ndef tiles2graph(tile_info, text_labels):\n    util.check(len(tile_info.levels) == 1, 'only handles one tile level')\n\n    if text_labels:\n        util.check(tile_info.tileset.tile_to_text, 'no text')\n\n    tile_level = tile_info.levels[0].tiles\n\n    rows = len(tile_level)\n    cols = len(tile_level[0])\n\n    def nodeid(_rr, _cc):\n        return f'{_rr}-{_cc}'\n\n    gr = nx.DiGraph()\n    for rr in range(rows):\n        for cc in range(cols):\n            if text_labels:\n                node_label = tile_info.tileset.tile_to_text[tile_level[rr][cc]]\n            else:\n                node_label = tile_level[rr][cc]\n\n            gr.add_node(nodeid(rr, cc))\n            gr.nodes[nodeid(rr, cc)][util_graph.ATTR_LABEL] = node_label\n\n    for rr in range(rows):\n        for cc in range(cols):\n            if rr + 1 < rows:\n                gr.add_edge(nodeid(rr, cc), nodeid(rr + 1, cc))\n                gr.edges[(nodeid(rr, cc), nodeid(rr + 1, cc))][util_graph.ATTR_LABEL] = util_graph.LABEL_GRID_SOUTH\n            if cc + 1 < cols:\n                gr.add_edge(nodeid(rr, cc), nodeid(rr, cc + 1))\n                gr.edges[(nodeid(rr, cc), nodeid(rr, cc + 1))][util_graph.ATTR_LABEL] = util_graph.LABEL_GRID_EAST\n\n    gtype = util_graph.GTYPE_DAG\n\n    util_graph.check_graph(gr, gtype)\n\n    grs = util_graph.Graphs()\n    grs.gtype = gtype\n    grs.colors = {}\n    grs.graphs = [gr]\n\n    return grs", "\n\n\nif __name__ == '__main__':\n    util.timer_start()\n\n    parser = argparse.ArgumentParser(description='Generate tiles from level and/or image.')\n    parser.add_argument('--outfile', required=True, type=str, help='Output tile file.')\n    parser.add_argument('--tilefile', required=True, type=str, help='Input tile file.')\n    parser.add_argument('--text-labels', action='store_true', help='Use tile text for labels.')\n    args = parser.parse_args()\n\n    with util.openz(args.tilefile, 'rb') as f:\n        tile_info = pickle.load(f)\n\n    ogrs = tiles2graph(tile_info, args.text_labels)\n    util_graph.write_graph_to_file(ogrs, args.outfile)", ""]}
{"filename": "scheme2output.py", "chunked_list": ["import argparse, pickle, random, sys, time\nimport custom, generator, mkiii, reach, solvers, util\n\n\n\nWEIGHT_PATTERNS       = 10000\nWEIGHT_COUNTS         =     1\n\n\n", "\n\nCOUNTS_SCALE_HALF     = (0.5, 1.5)\nCOUNTS_SCALE_ZERO     = (0.0, 1e10)\n\n\n\ndef scheme2output(scheme_info, tag_level, game_level, solver, randomize, weight_patterns, weight_counts, counts_scale, reach_setup, mkiii_setup, custom_constraints, show_path_tiles):\n    si = scheme_info\n\n    rows = len(tag_level)\n    cols = len(tag_level[0])\n\n    for tag_row, game_row in zip(tag_level, game_level):\n        util.check(len(tag_row) == len(game_row) == cols, 'row length mismatch')\n        for tag, game in zip(tag_row, game_row):\n            util.check(game != util.VOID_TEXT, 'void game')\n            util.check(game in si.game_to_tag_to_tiles, 'unrecognized game ' + game)\n            util.check(tag == util.VOID_TEXT or tag in si.game_to_tag_to_tiles[game], 'unrecognized tag ' + tag + ' for game ' + game)\n\n    print('using solver', solver.get_id())\n\n    if mkiii_setup is not None:\n        gen = mkiii.GeneratorMKIII(solver, randomize, rows, cols, si, tag_level, game_level)\n    else:\n        gen = generator.Generator(solver, randomize, rows, cols, si, tag_level, game_level)\n\n    util.timer_section('add tile rules')\n    gen.add_rules_tiles()\n\n    if si.pattern_info is not None and weight_patterns != 0:\n        util.timer_section('add pattern rules')\n        gen.add_rules_patterns(weight_patterns)\n\n    if si.count_info is not None and weight_counts != 0:\n        util.timer_section('add count rules')\n        lo, hi = counts_scale\n        gen.add_rules_counts(False, lo, hi, weight_counts) # TODO? (si.tile_to_text is not None)\n\n    if reach_setup is not None:\n        util.timer_section('add reachability rules')\n        gen.add_rules_reachability(reach.get_reach_info(rows, cols, reach_setup, si))\n\n    if mkiii_setup is not None:\n        util.timer_section('add mkiii rules')\n        gen.add_rules_mkiii(mkiii.get_example_info(mkiii_setup))\n\n    if custom_constraints and len(custom_constraints) > 0:\n        util.timer_section('add custom')\n        for custom_constraint in custom_constraints:\n            custom_constraint.add(gen)\n\n    util.timer_section('solve')\n\n    result = None\n    if gen.solve():\n        util.timer_section('create output')\n        result = gen.get_result()\n        util.print_result_info(result, False)\n\n    util.timer_section(None)\n\n    return result", "\n\n\nif __name__ == '__main__':\n    util.timer_start()\n\n    parser = argparse.ArgumentParser(description='Create output from scheme.')\n\n    parser.add_argument('--outfile', required=True, type=str, help='Output file (without extension, which will be added).')\n    parser.add_argument('--schemefile', required=True, type=str, help='Input scheme file.')\n\n    parser.add_argument('--tagfile', type=str, help='Input tag file.')\n    parser.add_argument('--gamefile', type=str, help='Input game file.')\n    parser.add_argument('--size', type=int, nargs=2, help='Level size (if no tag or game file provided.')\n\n    parser.add_argument('--randomize', type=int, help='Randomize based on given number.')\n    parser.add_argument('--show-path-tiles', action='store_true', help='Show path in tiles.')\n\n    parser.add_argument('--solver', type=str, nargs='+', choices=solvers.SOLVER_LIST, default=[solvers.SOLVER_PYSAT_RC2], help='Solver name, from: ' + ','.join(solvers.SOLVER_LIST) + '.')\n    parser.add_argument('--solver-portfolio-timeout', type=int, help='Force use of portfolio with given timeout (even for single solver).')\n\n    parser.add_argument('--soft-patterns', action='store_true', help='Make patterns soft constraints.')\n    parser.add_argument('--no-patterns', action='store_true', help='Don\\'t use pattern rules, even if present.')\n    parser.add_argument('--zero-counts', action='store_true', help='Only use counts to prevent tiles not occuring in region.')\n    parser.add_argument('--no-counts', action='store_true', help='Don\\'t use tile count rules, even if present.')\n\n    parser.add_argument('--reach-move', type=str, nargs='+', default=None, help='Use reachability move rules, from: ' + ','.join(reach.RMOVE_LIST) + '.')\n    parser.add_argument('--reach-wrap-cols', action='store_true', help='Wrap columns in reachability.')\n    parser.add_argument('--reach-goal', type=str, nargs='+', default=None, help='Use reachability goals, from: ' + ','.join(reach.RGOAL_DICT.keys()) + ', plus meta.')\n    parser.add_argument('--reach-open-zelda', action='store_true', help='Use Zelda open tiles.')\n\n    parser.add_argument('--mkiii-example', type=str, choices=mkiii.EXAMPLES, help='MKIII example name, from: ' + ','.join(mkiii.EXAMPLES) + '.')\n    parser.add_argument('--mkiii-layers', type=int, help='MKIII number of layers.')\n\n    parser.add_argument('--custom', type=str, nargs='+', action='append', help='Constraints on output, from: ' + ','.join(custom.CUST_LIST) + ', plus options.')\n\n    parser.add_argument('--compress', action='store_true', help='Compress output.')\n    parser.add_argument('--result-only', action='store_true', help='Only save result file.')\n\n    parser.add_argument('--quiet', action='store_true', help='Reduce output.')\n\n    args = parser.parse_args()\n\n    if args.quiet:\n        sys.stdout = open(os.devnull, 'w')\n\n    if len(args.solver) == 1 and not args.solver_portfolio_timeout:\n        solver = solvers.solver_id_to_solver(args.solver[0])\n    else:\n        solver = solvers.PortfolioSolver(args.solver, args.solver_portfolio_timeout)\n\n    with util.openz(args.schemefile, 'rb') as f:\n        scheme_info = pickle.load(f)\n\n    if args.size:\n        if args.tagfile or args.gamefile:\n            parser.error('cannot use --size with --tagfile or --gamefile')\n\n        tag_level = util.make_grid(args.size[0], args.size[1], util.DEFAULT_TEXT)\n        game_level = util.make_grid(args.size[0], args.size[1], util.DEFAULT_TEXT)\n\n    elif args.tagfile or args.gamefile:\n        if args.size:\n            parser.error('cannot use --size with --tagfile or --gamefile')\n\n        if args.tagfile and args.gamefile:\n            tag_level = util.read_text_level(args.tagfile)\n            game_level = util.read_text_level(args.gamefile)\n        elif args.tagfile:\n            tag_level = util.read_text_level(args.tagfile)\n            game_level = util.make_grid(len(tag_level), len(tag_level[0]), util.DEFAULT_TEXT)\n        elif args.gamefile:\n            game_level = util.read_text_level(args.gamefile)\n            tag_level = util.make_grid(len(game_level), len(game_level[0]), util.DEFAULT_TEXT)\n\n    else:\n        parser.error('must use --size, --tagfile or --gamefile')\n\n\n\n    reach_setup = None\n\n    if args.reach_move or args.reach_goal:\n        if not args.reach_move or not args.reach_goal:\n            parser.error('must use --reach-move and --reach-goal together')\n\n        reach_setup = util.ReachabilitySetup()\n        reach_setup.wrap_cols = False\n        reach_setup.open_text = util.OPEN_TEXT\n\n        reach_setup.game_to_move = util.arg_list_to_dict_options(parser, '--reach-move', args.reach_move, reach.RMOVE_LIST)\n\n        if args.reach_goal[0] not in reach.RGOAL_DICT:\n            parser.error('--reach-goal[0] must be in ' + ','.join(reach.RGOAL_DICT.key()))\n        reach_setup.goal_loc = args.reach_goal[0]\n\n        if len(args.reach_goal[1:]) != reach.RGOAL_DICT[reach_setup.goal_loc]:\n            parser.error('--reach-goal[1:] must be length ' + str(reach.RGOAL_DICT[reach_setup.goal_loc]))\n\n        reach_setup.goal_params = []\n        for rg in args.reach_goal[1:]:\n            if not rg.isnumeric():\n                parser.error('--reach-goal[1:] must all be integer')\n            reach_setup.goal_params.append(int(rg))\n\n    if args.reach_open_zelda:\n        if not reach_setup:\n            parser.error('cannot specify --reach-open-zelda without other reach args')\n        reach_setup.open_text = util.OPEN_TEXT_ZELDA\n\n    if args.reach_wrap_cols:\n        if not reach_setup:\n            parser.error('cannot specify --reach-wrap-cols without other reach args')\n        reach_setup.wrap_cols = True\n\n\n\n    mkiii_setup = None\n\n    if args.mkiii_example or args.mkiii_layers:\n        if not args.mkiii_example or not args.mkiii_layers:\n            parser.error('must use --mkiii-example and --mkiii-layers together')\n\n        mkiii_setup = mkiii.MKIIISetup()\n        mkiii_setup.example = args.mkiii_example\n        mkiii_setup.layers = args.mkiii_layers\n\n\n\n    custom_constraints = []\n\n    if args.custom:\n        for cust_args in args.custom:\n            custom_constraints.append(custom.args_to_custom(cust_args[0], cust_args[1:]))\n\n\n    if args.no_patterns:\n        weight_patterns = 0\n    elif args.soft_patterns:\n        weight_patterns = WEIGHT_PATTERNS\n    else:\n        weight_patterns = None\n\n    if args.no_counts:\n        weight_counts = 0\n    else:\n        weight_counts = WEIGHT_COUNTS\n\n    if args.zero_counts:\n        counts_scale = COUNTS_SCALE_ZERO\n    else:\n        counts_scale = COUNTS_SCALE_HALF\n\n    result_info = scheme2output(scheme_info, tag_level, game_level, solver, args.randomize, weight_patterns, weight_counts, counts_scale, reach_setup, mkiii_setup, custom_constraints, args.show_path_tiles)\n    if result_info:\n        util.save_result_info(result_info, args.outfile, args.compress, args.result_only)\n        util.exit_solution_found()\n    else:\n        util.exit_solution_not_found()", ""]}
{"filename": "graph2dot.py", "chunked_list": ["import argparse, itertools, json, random, sys, time\nimport util, util_graph\nimport networkx as nx\n\n\n\nif __name__ == '__main__':\n    util.timer_start()\n\n    parser = argparse.ArgumentParser(description='Convert a dot file to a graph file.')\n    parser.add_argument('--outfile', type=str, help='Output file.')\n    parser.add_argument('--graphfile', required=True, nargs='+', type=str, help='Input graph file(s).')\n    parser.add_argument('--grid', action='store_true', help='Layout as grid.')\n    args = parser.parse_args()\n\n    grs = util_graph.read_graphs(args.graphfile)\n\n    if args.grid:\n        util_graph.layout_grid(grs.graphs[0])\n\n    if args.outfile is None:\n        util_graph.write_graph_dot(grs, sys.stdout)\n    else:\n        with util.openz(args.outfile, 'wt') as outfile:\n            util_graph.write_graph_dot(grs, outfile)", ""]}
{"filename": "file2file.py", "chunked_list": ["import argparse, base64, json, io, pickle, sys, time\nimport util, util_explore\nimport numpy as np\nimport PIL.Image\n\n\n\ndef image2base64(image):\n    bytes_io = io.BytesIO()\n    util.fresh_image(image).save(bytes_io, 'png')\n    bytes_io.flush()\n    bytes_io.seek(0)\n    return base64.b64encode(bytes_io.read()).decode('ascii')", "\ndef image2iid(image, iid_dict, image_list):\n    if id(image) not in iid_dict:\n        iid_dict[id(image)] = len(image_list)\n        image_list.append(image2base64(image))\n    return iid_dict[id(image)]\n\ndef dict2json(d, encode_val=None):\n    if encode_val is None:\n        encode_val = lambda x: x\n    return [(key, encode_val(val)) for key, val in d.items()]", "\ndef tileset2json(ts, encode_image):\n    ret = {}\n    ret['tile_ids'] = list(ts.tile_ids.keys())\n    ret['tile_to_text'] = dict2json(ts.tile_to_text)\n    ret['tile_to_image'] = dict2json(ts.tile_to_image, encode_image)\n    ret['tile_image_size'] = ts.tile_image_size\n    return ret\n\ndef tileinfo2json(ti, encode_image):\n    ret = {}\n    ret['tileset'] = tileset2json(ti.tileset, encode_image)\n    if ti.levels is None:\n        ret['levels'] = None\n    else:\n        ret['levels'] = [{'tiles': tli.tiles, 'tags': tli.tags, 'games': tli.games, 'meta': tli.meta} for tli in ti.levels]\n    return ret", "\ndef tileinfo2json(ti, encode_image):\n    ret = {}\n    ret['tileset'] = tileset2json(ti.tileset, encode_image)\n    if ti.levels is None:\n        ret['levels'] = None\n    else:\n        ret['levels'] = [{'tiles': tli.tiles, 'tags': tli.tags, 'games': tli.games, 'meta': tli.meta} for tli in ti.levels]\n    return ret\n\ndef explore2json(ex, encode_image):\n    ret = {}\n    ret['rows'] = ex.rows\n    ret['cols'] = ex.cols\n    ret['tileset'] = tileset2json(ex.tileset, encode_image)\n    ret['ntind'] = ex.ntind\n    ret['neind'] = ex.neind\n    ret['npind'] = ex.npind\n    ret['void_tind'] = ex.void_tind\n    ret['tind_to_text'] = dict2json(ex.tind_to_text)\n    ret['tind_to_image'] = dict2json(ex.tind_to_image, encode_image)\n    ret['tinds_to_tile'] = dict2json(ex.tinds_to_tile)\n    ret['eind_to_edge'] = dict2json(ex.eind_to_edge)\n    ret['pind_to_prop'] = dict2json(ex.pind_to_prop)\n    ret['level_data'] = [base64.b64encode(level_data.tobytes()).decode('ascii') for level_data in ex.level_data]\n    return ret", "\ndef explore2json(ex, encode_image):\n    ret = {}\n    ret['rows'] = ex.rows\n    ret['cols'] = ex.cols\n    ret['tileset'] = tileset2json(ex.tileset, encode_image)\n    ret['ntind'] = ex.ntind\n    ret['neind'] = ex.neind\n    ret['npind'] = ex.npind\n    ret['void_tind'] = ex.void_tind\n    ret['tind_to_text'] = dict2json(ex.tind_to_text)\n    ret['tind_to_image'] = dict2json(ex.tind_to_image, encode_image)\n    ret['tinds_to_tile'] = dict2json(ex.tinds_to_tile)\n    ret['eind_to_edge'] = dict2json(ex.eind_to_edge)\n    ret['pind_to_prop'] = dict2json(ex.pind_to_prop)\n    ret['level_data'] = [base64.b64encode(level_data.tobytes()).decode('ascii') for level_data in ex.level_data]\n    return ret", "\ndef wrap2json(what, encode):\n    iid_dict = {}\n    image_list = []\n    data = encode(what, lambda x: image2iid(x, iid_dict, image_list))\n    ret = {}\n    ret['image'] = image_list\n    ret['data'] = data\n    return ret\n\ndef base642image(st):\n    return util.fresh_image(PIL.Image.open(io.BytesIO(base64.b64decode(st))))", "\ndef base642image(st):\n    return util.fresh_image(PIL.Image.open(io.BytesIO(base64.b64decode(st))))\n\ndef iid2image(iid, image_list):\n    return image_list[iid]\n\ndef json2dict(j, decode_key=None, decode_val=None):\n    if decode_key is None:\n        decode_key = lambda x: x\n    if decode_val is None:\n        decode_val = lambda x: x\n    return {decode_key(key): decode_val(val) for key, val in j}", "\ndef json2tileset(obj, decode_image):\n    ts = util.TileSetInfo()\n    ts.tile_ids = dict.fromkeys(obj['tile_ids'])\n    ts.tile_to_text = json2dict(obj['tile_to_text'])\n    ts.tile_to_image = json2dict(obj['tile_to_image'], decode_val=decode_image)\n    ts.tile_image_size = obj['tile_image_size']\n    return ts\n\ndef json2tileinfo(obj, decode_image):\n    ti = util.TileInfo()\n    ti.tileset = json2tileset(obj['tileset'], decode_image)\n    if obj['levels'] is None:\n        ti.levels = None\n    else:\n        ti.levels = []\n        for jtli in obj['levels']:\n            tli = util.TileLevelInfo()\n            tli.tiles = jtli['tiles']\n            tli.tags = jtli['tags']\n            tli.games = jtli['games']\n            tli.meta = [json.loads(json.dumps(entry)) for entry in jtli['meta']]\n            ti.levels.append(tli)\n    return ti", "\ndef json2tileinfo(obj, decode_image):\n    ti = util.TileInfo()\n    ti.tileset = json2tileset(obj['tileset'], decode_image)\n    if obj['levels'] is None:\n        ti.levels = None\n    else:\n        ti.levels = []\n        for jtli in obj['levels']:\n            tli = util.TileLevelInfo()\n            tli.tiles = jtli['tiles']\n            tli.tags = jtli['tags']\n            tli.games = jtli['games']\n            tli.meta = [json.loads(json.dumps(entry)) for entry in jtli['meta']]\n            ti.levels.append(tli)\n    return ti", "\ndef json2explore(obj, decode_image):\n    ex = util_explore.ExploreInfo()\n    ex.rows = obj['rows']\n    ex.cols = obj['cols']\n    ex.tileset = json2tileset(obj['tileset'], decode_image)\n    ex.ntind = obj['ntind']\n    ex.neind = obj['neind']\n    ex.npind = obj['npind']\n    ex.void_tind = obj['void_tind']\n    ex.tind_to_text = json2dict(obj['tind_to_text'])\n    ex.tind_to_image = json2dict(obj['tind_to_image'], decode_val=decode_image)\n    ex.tinds_to_tile = json2dict(obj['tinds_to_tile'], decode_key=tuple)\n    ex.eind_to_edge = json2dict(obj['eind_to_edge'], decode_val=tuple)\n    ex.pind_to_prop = json2dict(obj['pind_to_prop'])\n    ex.level_data = np.array([np.frombuffer(base64.b64decode(level_data), dtype=np.uint8) for level_data in obj['level_data']])\n    return ex", "\ndef json2wrap(obj, decode):\n    image_list = [base642image(img) for img in obj['image']]\n    return decode(obj['data'], lambda x: iid2image(x, image_list))\n\nif __name__ == '__main__':\n    util.timer_start()\n\n    parser = argparse.ArgumentParser(description='Convert files to/from json.')\n    parser.add_argument('--infile', required=True, type=str, help='Input file.')\n    parser.add_argument('--outfile', required=True, type=str, help='Output file.')\n    args = parser.parse_args()\n\n    if util.fileistype(args.infile, '.explore') and util.fileistype(args.outfile, '.jexplore'):\n        with util.openz(args.infile, 'rb') as f:\n            ex = pickle.load(f)\n        with util.openz(args.outfile, 'wt') as f:\n            json.dump(wrap2json(ex, explore2json), f)\n            f.write('\\n')\n\n    elif util.fileistype(args.infile, '.jexplore') and util.fileistype(args.outfile, '.explore'):\n        with util.openz(args.infile, 'rt') as f:\n            ex = json2wrap(json.load(f), json2explore)\n        with util.openz(args.outfile, 'wb') as f:\n            pickle.dump(ex, f)\n\n    elif util.fileistype(args.infile, '.tile') and util.fileistype(args.outfile, '.jtile'):\n        with util.openz(args.infile, 'rb') as f:\n            ti = pickle.load(f)\n        with util.openz(args.outfile, 'wt') as f:\n            json.dump(wrap2json(ti, tileinfo2json), f)\n            f.write('\\n')\n\n    elif util.fileistype(args.infile, '.jtile') and util.fileistype(args.outfile, '.tile'):\n        with util.openz(args.infile, 'rt') as f:\n            ti = json2wrap(json.load(f), json2tileinfo)\n        with util.openz(args.outfile, 'wb') as f:\n            pickle.dump(ti, f)\n\n    else:\n        util.check(False, 'unrecognized conversion')", ""]}
{"filename": "solvers-test.py", "chunked_list": ["import os, sys\nimport util, solvers\n\nif __name__ == '__main__':\n    if len(sys.argv) > 1:\n        solvers_to_test = sys.argv[1:]\n    else:\n        solvers_to_test = list(sorted(set(solvers.SOLVER_LIST) - set(solvers.SOLVER_NOTEST_LIST)))\n\n    os.environ['STG_MUTE_TIME'] = '1'\n    os.environ['STG_MUTE_PORT'] = '1'\n\n    tests = []\n\n    def setup(solver, wt, a, b):\n        solver.cnstr_count([a], False, 1, 1, wt)\n        solver.cnstr_implies_disj(a, False, [b], False, wt)\n    tests.append((2, setup, [False, False]))\n\n    def setup(solver, wt, a, b, c):\n        solver.cnstr_implies_disj(a, True, [b], True, wt)\n        solver.cnstr_implies_disj(b, True, [c], True, wt)\n        solver.cnstr_count([a, b, c], True, 2, 2, wt)\n    tests.append((3, setup, [False, True, True]))\n\n    def setup(solver, wt, a, b, c):\n        solver.cnstr_count([a, b, c], True, 3, 3, wt)\n    tests.append((3, setup, [True, True, True]))\n\n    def setup(solver, wt, a, b, c):\n        solver.cnstr_count([a, b, c], False, 3, 3, wt)\n    tests.append((3, setup, [False, False, False]))\n\n    def setup(solver, wt, a, b, c):\n        solver.cnstr_count([a, b], True, 1, 1, wt)\n        solver.cnstr_count([b], True, 0, 0, wt)\n        solver.cnstr_implies_disj(a, True, [b, c], True, wt)\n    tests.append((3, setup, [True, False, True]))\n\n    def setup(solver, wt, a, b, c):\n        d = solver.make_conj([a, b, c], [True, False, True])\n        solver.cnstr_count([d], True, 1, 1, wt)\n    tests.append((3, setup, [True, False, True]))\n\n    def setup(solver, wt, a, b, c):\n        d = solver.make_conj([a, b, c], False)\n        solver.cnstr_count([b], False, 1, 1, wt)\n        solver.cnstr_count([c], True, 0, 0, wt)\n        solver.cnstr_count([d], False, 1, 1, wt)\n    tests.append((3, setup, [True, False, False]))\n\n    def setup(solver, wt, a, b, c, d):\n        solver.cnstr_count([a, b, c, d], False, 3, 4, wt)\n        solver.cnstr_count([a], True, 1, 1, wt)\n    tests.append((4, setup, [True, False, False, False]))\n\n    def setup(solver, wt, a, b, c, d):\n        solver.cnstr_count([a, b], True, 1, 1, wt)\n        solver.cnstr_count([b], False, 1, 1, wt)\n        solver.cnstr_count([d], False, 1, 1, wt)\n        solver.cnstr_count([a, b, c, d], [True, True, False, False], 2, 2, wt)\n    tests.append((4, setup, [True, False, True, False]))\n\n    for solver_id in solvers_to_test:\n        for use_portfolio in [False, True]:\n            for use_weight in [None, 1]:\n                if solver_id in [solvers.SOLVER_CVC5, solvers.SOLVER_PYSAT_MC] and use_weight is not None:\n                    continue\n\n                print(solver_id, use_portfolio, use_weight)\n\n                for nvars, setup, expect in tests:\n                    print('.', end='')\n                    if use_portfolio:\n                        solver = solvers.PortfolioSolver([solver_id], None)\n                    else:\n                        solver = solvers.solver_id_to_solver(solver_id)\n                    vvs = [solver.make_var() for ii in range(nvars)]\n                    setup(solver, use_weight, *vvs)\n                    solver.solve()\n                    res = [solver.get_var(vv) for vv in vvs]\n                    util.check(res == expect, 'var')\n                    obj = solver.get_objective()\n                    util.check(obj == 0, 'objective')\n                print()", ""]}
{"filename": "input2tile.py", "chunked_list": ["import argparse, json, os, shutil, pickle, sys\nimport PIL.Image\nimport util\n\n\n\nTILE_OUTPUT_FOLDER = 'tiles'\n\n\n\ndef get_tile_key(tile_text, tile_image):\n    tile_key = ()\n    if tile_text is not None:\n        tile_key = tile_key + (tile_text,)\n    if tile_image is not None:\n        tile_key = tile_key + (tuple(tile_image.getdata()),)\n    return tile_key", "\n\ndef get_tile_key(tile_text, tile_image):\n    tile_key = ()\n    if tile_text is not None:\n        tile_key = tile_key + (tile_text,)\n    if tile_image is not None:\n        tile_key = tile_key + (tuple(tile_image.getdata()),)\n    return tile_key\n", "\n\n\ndef input2tiles(base_tile_info, text_levels, image_levels, tag_levels, games, paths, tile_image_size, no_levels, text_key_only, tile_output_folder):\n    tile_key_to_tile_id = {}\n\n    if base_tile_info is not None:\n        ts = base_tile_info.tileset\n\n        for tile in ts.tile_ids:\n            tile_text = ts.tile_to_text[tile] if ts.tile_to_text is not None else None\n            tile_image = ts.tile_to_image[tile] if ts.tile_to_image is not None else None\n            tile_key = get_tile_key(tile_text, tile_image if not text_key_only else None)\n            util.check(tile_key not in tile_key_to_tile_id, 'duplicate tile key in base tile info')\n            tile_key_to_tile_id[tile_key] = tile\n    else:\n        ts = util.TileSetInfo()\n\n        ts.tile_ids = {}\n\n        ts.tile_to_text = {} if text_levels else None\n        ts.tile_to_image = {} if image_levels else None\n        ts.tile_image_size = tile_image_size\n\n    ti = util.TileInfo()\n    ti.tileset = ts\n    if no_levels:\n        ti.levels = None\n    else:\n        ti.levels = []\n\n\n\n    if text_levels is not None:\n        level_count = len(text_levels)\n    elif image_levels is not None:\n        level_count = len(image_levels)\n    else:\n        util.check(False, 'text and image both missing')\n\n    if text_levels is not None:\n        util.check(len(text_levels) == level_count, 'need same number of levels')\n    else:\n        text_levels = [None] * level_count\n\n    if image_levels is not None:\n        util.check(len(image_levels) == level_count, 'need same number of levels')\n    else:\n        image_levels = [None] * level_count\n\n    if tag_levels is not None:\n        util.check(len(tag_levels) == level_count, 'need same number of levels')\n    else:\n        tag_levels = [None] * level_count\n\n    if games is not None:\n        util.check(len(games) == level_count, 'need same number of levels')\n    else:\n        games = [None] * level_count\n\n    if paths is not None:\n        util.check(len(paths) == level_count, 'need same number of levels')\n    else:\n        paths = [None] * level_count\n\n\n\n    for ii, (text_level_meta, image_level, tag_level, game, path) in enumerate(zip(text_levels, image_levels, tag_levels, games, paths)):\n        if text_level_meta is not None:\n            text_level, text_meta = text_level_meta\n            text_sz = (len(text_level), len(text_level[0]))\n        else:\n            text_level, text_meta = None, None\n            text_sz = None\n\n        if image_level is not None:\n            image_sz = image_level.size\n\n            if ts.tile_image_size is None:\n                util.check(text_sz is not None, 'need text level to determine tile image size')\n                tile_size_x = image_sz[0] / text_sz[1]\n                tile_size_y = image_sz[1] / text_sz[0]\n                util.check(tile_size_y == tile_size_x and tile_size_y == int(tile_size_y) and tile_size_x == int(tile_size_x), 'can\\'t determine tile image size')\n                ts.tile_image_size = int(tile_size_x)\n                print('Tile size set to', ts.tile_image_size)\n\n            util.check(image_sz[0] % ts.tile_image_size == 0 and image_sz[1] % ts.tile_image_size == 0, 'Image size not multiple of tile size')\n            image_sz = (image_sz[1] // ts.tile_image_size, image_sz[0] // ts.tile_image_size)\n        else:\n            image_sz = None\n\n        if text_sz and image_sz:\n            util.check(text_sz == image_sz, 'text and image size mismatch')\n            rows, cols = text_sz\n        elif text_sz:\n            rows, cols = text_sz\n        elif image_sz:\n            rows, cols = image_sz\n        else:\n            util.check(False, 'text and image both missing')\n\n        tile_level = []\n        for rr in range(rows):\n            tile_level_row = []\n            for cc in range(cols):\n                tile_text = None\n                tile_text_is_void = None\n                if text_level is not None:\n                    tile_text = text_level[rr][cc]\n                    tile_text_is_void = (tile_text == util.VOID_TEXT)\n\n                tile_image = None\n                tile_image_is_void = None\n                if image_level is not None:\n                    tile_image = util.fresh_image(image_level.crop((cc * ts.tile_image_size, rr * ts.tile_image_size, cc * ts.tile_image_size + ts.tile_image_size, rr * ts.tile_image_size + ts.tile_image_size)).convert('RGBA'))\n                    tile_image_is_void = (sum([ch for px in tile_image.getdata() for ch in px]) == 0)\n\n                if tile_text_is_void or tile_image_is_void:\n                    util.check(tile_text_is_void in [True, None], 'void')\n                    util.check(tile_image_is_void in [True, None], 'void')\n                    tile_id = util.VOID_TILE\n\n                else:\n                    tile_key = get_tile_key(tile_text, tile_image if not text_key_only else None)\n                    if tile_key not in tile_key_to_tile_id:\n                        if base_tile_info is not None:\n                            util.check(False, 'tile missing in base tile info')\n\n                        tile_id = len(ts.tile_ids)\n                        ts.tile_ids[tile_id] = None\n\n                        tile_key_to_tile_id[tile_key] = tile_id\n\n                        if tile_text:\n                            ts.tile_to_text[tile_id] = tile_text\n                        if tile_image:\n                            ts.tile_to_image[tile_id] = tile_image\n                    else:\n                        tile_id = tile_key_to_tile_id[tile_key]\n\n                tile_level_row.append(tile_id)\n            tile_level.append(tile_level_row)\n\n        if tag_level is None:\n            tag_level = util.make_grid(rows, cols, util.DEFAULT_TEXT)\n            for rr in range(rows):\n                for cc in range(cols):\n                    if tile_level[rr][cc] == util.VOID_TILE:\n                        tag_level[rr][cc] = util.VOID_TEXT\n        else:\n            util.check(len(tag_level) == rows, 'tile and tag level row count mismatch')\n            for rr in range(rows):\n                util.check(len(tag_level[rr]) == cols, 'row length mismatch')\n                for cc in range(cols):\n                    util.check((tile_level[rr][cc] == util.VOID_TILE) == (tag_level[rr][cc] == util.VOID_TEXT), 'void')\n\n        if game is None:\n            game_level = util.make_grid(rows, cols, util.DEFAULT_TEXT)\n        else:\n            util.check(type(game) == str and len(game) == 1, 'game')\n            game_level = util.make_grid(rows, cols, game)\n\n        if path is not None:\n            if text_meta is None:\n                text_meta = []\n            text_meta.insert(0, util.meta_path(path))\n\n        util.print_tile_level(tile_level)\n        print()\n        util.print_text_level(tag_level)\n        print()\n        util.print_text_level(game_level)\n        print()\n\n        if not no_levels:\n            tli = util.TileLevelInfo()\n            tli.tiles = tile_level\n            tli.tags = tag_level\n            tli.games = game_level\n            tli.meta = text_meta\n            ti.levels.append(tli)\n\n    if image_level and tile_output_folder:\n        print('saving image tiles')\n\n        if os.path.exists(tile_output_folder):\n            shutil.rmtree(tile_output_folder)\n        os.makedirs(tile_output_folder)\n\n        for tile, tile_image in ts.tile_to_image.items():\n            tile_filename = '%s/tile%04d.png' % (tile_output_folder, tile)\n            print(tile_filename)\n            tile_image.save(tile_filename)\n        print()\n\n    print('Found %d tiles' % len(ts.tile_ids))\n\n    return ti", "\n\n\nif __name__ == '__main__':\n    util.timer_start()\n\n    parser = argparse.ArgumentParser(description='Generate tiles from level and/or image.')\n    parser.add_argument('--outfile', required=True, type=str, help='Output tile file.')\n    parser.add_argument('--basefile', type=str, help='Input base files containing all tiles.')\n    parser.add_argument('--textfile', type=str, nargs='+', help='Input text file(s).')\n    parser.add_argument('--imagefile', type=str, nargs='+', help='Input image file(s).')\n    parser.add_argument('--tagfile', type=str, nargs='+', help='Input tag level file(s).')\n    parser.add_argument('--game', type=str, nargs='+', help='Input game(s).')\n    parser.add_argument('--pathfile', type=str, nargs='+', help='Input path file(s).')\n    parser.add_argument('--tilesize', type=int, help='Size of tiles in image.')\n    parser.add_argument('--savetileimages', action='store_true', help='Save tile images.')\n    parser.add_argument('--text-key-only', action='store_true', help='Only use text when keying tiles.')\n    parser.add_argument('--no-levels', action='store_true', help='Don\\'t store levels with tiles.')\n    parser.add_argument('--quiet', action='store_true', help='Reduce output.')\n    args = parser.parse_args()\n\n    if args.quiet:\n        sys.stdout = open(os.devnull, 'w')\n\n    if not args.textfile and not args.imagefile:\n        parser.error('--textfile or --imagefile required')\n\n    if args.imagefile and not (args.textfile or args.tilesize):\n        parser.error('--imagefile requires --textfile or --tilesize')\n\n    if args.basefile is not None:\n        with util.openz(args.basefile, 'rb') as f:\n            base_tile_info = pickle.load(f)\n    else:\n        base_tile_info = None\n\n    if args.textfile is not None:\n        text_levels = [util.read_text_level(textfile, True) for textfile in args.textfile]\n    else:\n        text_levels = None\n\n    if args.imagefile is not None:\n        def open_and_load_image(fn):\n            with util.openz(fn, 'rb') as f:\n                img = PIL.Image.open(f)\n                img.load()\n                return img\n        image_levels = [open_and_load_image(imagefile) for imagefile in args.imagefile]\n    else:\n        image_levels = None\n\n    if args.tagfile is not None:\n        tag_levels = [util.read_text_level(tagfile) for tagfile in args.tagfile]\n    else:\n        tag_levels = None\n\n    if args.pathfile is not None:\n        def open_and_load_path(fn):\n            with util.openz(fn, 'rt') as f:\n                return [tuple(edge) for edge in json.load(f)]\n        paths = [open_and_load_path(pathfile) for pathfile in args.pathfile]\n    else:\n        paths = None\n\n    tile_info = input2tiles(base_tile_info, text_levels, image_levels, tag_levels, args.game, paths, args.tilesize,\n                            args.no_levels, args.text_key_only, TILE_OUTPUT_FOLDER if args.savetileimages else None)\n    with util.openz(args.outfile, 'wb') as f:\n        pickle.dump(tile_info, f)", ""]}
{"filename": "mkiii.py", "chunked_list": ["import generator, util\n\n\n\nEX_MKJR_WALK      = 'mkjr-walk'\nEX_MKJR_WALK_THRU = 'mkjr-walk-thru'\nEX_MKJR_MAZE      = 'mkjr-maze'\nEX_MKJR_MAZE_COIN = 'mkjr-maze-coin'\nEX_SOKO           = 'soko'\nEX_DOKU           = 'doku'", "EX_SOKO           = 'soko'\nEX_DOKU           = 'doku'\nEX_LOCK           = 'lock'\nEX_SLIDE          = 'slide'\nEX_FILL           = 'fill'\nEX_PLAT           = 'plat'\nEX_VVV            = 'vvv'\nEX_LINK           = 'link'\nEX_MATCH          = 'match'\n", "EX_MATCH          = 'match'\n\nEXAMPLES = [EX_MKJR_WALK, EX_MKJR_WALK_THRU, EX_MKJR_MAZE, EX_MKJR_MAZE_COIN, EX_SOKO, EX_DOKU, EX_LOCK, EX_SLIDE, EX_FILL, EX_PLAT, EX_VVV, EX_LINK, EX_MATCH]\n\n\n\nDIR_NORTH     = [(-1,  0)]\nDIR_SOUTH     = [( 1,  0)]\nDIR_EAST      = [( 0,  1)]\nDIR_WEST      = [( 0, -1)]", "DIR_EAST      = [( 0,  1)]\nDIR_WEST      = [( 0, -1)]\nDIR_EASTWEST  = [( 0,  1), ( 0, -1)]\nDIR_SOUTHEAST = [( 1,  0), ( 0, 1)]\nDIR_ALL       = [(1, 0), (-1, 0), (0, 1), (0, -1)]\nDIR_NONE      = [(0, 0)]\n\n\n\nRR_GRP_CHOICE = 'RULE_CHOICE'", "\nRR_GRP_CHOICE = 'RULE_CHOICE'\nRR_GRP_ALL    = 'RULE_ALL'\n\nRR_ORD_ONE = 'ONE'\nRR_ORD_SEQ = 'SEQ'\nRR_ORD_PRI = 'PRI'\n\n\n\nclass MKIIISetup:\n    def __init__(self):\n        self.example = None\n        self.layers = None", "\n\nclass MKIIISetup:\n    def __init__(self):\n        self.example = None\n        self.layers = None\n\nclass MKIIIInfo:\n    def __init__(self):\n        self.states = None\n        self.rep_rules = None\n        self.rep_rule_names = None\n        self.rep_rule_order = None\n        self.use_term = None\n        self.custom = None\n        self.layers = None\n        self.extra_meta = []", "\nclass CustomInfo:\n    def __init__(self, solver, rng, vars_lrct, rows, cols, layers):\n        self.solver = solver\n        self.rng = rng\n        self.vars_lrct = vars_lrct\n        self.rows = rows\n        self.cols = cols\n        self.layers = layers\n", "\n\n\ndef init_range(ci, chars, lo, hi):\n    vvs = []\n    for rr in range(ci.rows):\n        for cc in range(ci.cols):\n            for char in chars:\n                vvs.append(ci.vars_lrct[(0, rr, cc, char)])\n    ci.solver.cnstr_count(vvs, True, lo, hi, None)", "\ndef init_exact(ci, chars, amt):\n    init_range(ci, chars, amt, amt)\n\ndef init_points(ci, default, points):\n    for rr in range(ci.rows):\n        for cc in range(ci.cols):\n            if (rr, cc) in points:\n                st = points[(rr, cc)]\n            else:\n                st = default\n            ci.solver.cnstr_count([ci.vars_lrct[(0, rr, cc, st)]], True, 1, 1, None)", "\ndef init_dist_atleast(ci, char1, char2, dst):\n    for rr in range(ci.rows):\n        for cc in range(ci.cols):\n            for r2 in range(ci.rows):\n                for c2 in range(ci.cols):\n                    dstsq = (rr - r2) ** 2 + (cc - c2) ** 2\n                    if dstsq < dst * dst:\n                        ci.solver.cnstr_implies_disj(ci.vars_lrct[(0, rr, cc, char1)], True, [ci.vars_lrct[(0, r2, c2, char2)]], False, None)\n                        ci.solver.cnstr_implies_disj(ci.vars_lrct[(0, rr, cc, char2)], True, [ci.vars_lrct[(0, r2, c2, char1)]], False, None)", "\ndef init_dist_impl_nearby(ci, char1, chars2, dst):\n    for rr in range(ci.rows):\n        for cc in range(ci.cols):\n            vvs = []\n            for r2 in range(ci.rows):\n                for c2 in range(ci.cols):\n                    dstsq = (rr - r2) ** 2 + (cc - c2) ** 2\n                    if dstsq <= dst * dst + 0.001:\n                        for char2 in chars2:\n                            vvs.append(ci.vars_lrct[(0, r2, c2, char2)])\n            ci.solver.cnstr_implies_disj(ci.vars_lrct[(0, rr, cc, char1)], True, vvs, True, None)", "\ndef full_range(ci, chars, lo, hi):\n    vvs = []\n    for ll in range(ci.layers):\n        for rr in range(ci.rows):\n            for cc in range(ci.cols):\n                for char in chars:\n                    vvs.append(ci.vars_lrct[(ll, rr, cc, char)])\n    ci.solver.cnstr_count(vvs, True, lo, hi, None)\n\ndef full_exact(ci, chars, amt):\n    full_range(ci, chars, amt, amt)", "\ndef full_exact(ci, chars, amt):\n    full_range(ci, chars, amt, amt)\n\ndef full_norepeat(ci, char):\n    vvs = []\n    for ll in range(ci.layers - 1):\n        for rr in range(ci.rows):\n            for cc in range(ci.cols):\n                for l2 in range(ll + 1, ci.layers):\n                    ci.solver.cnstr_implies_disj(ci.vars_lrct[(ll, rr, cc, char)], True, [ci.vars_lrct[(l2, rr, cc, char)]], False, None)", "\ndef fini_range(ci, chars, lo, hi):\n    vvs = []\n    for rr in range(ci.rows):\n        for cc in range(ci.cols):\n            for char in chars:\n                vvs.append(ci.vars_lrct[(ci.layers - 1, rr, cc, char)])\n    ci.solver.cnstr_count(vvs, True, lo, hi, None)\n\ndef fini_exact(ci, chars, amt):\n    fini_range(ci, chars, amt, amt)", "\ndef fini_exact(ci, chars, amt):\n    fini_range(ci, chars, amt, amt)\n\ndef init_implies(ci, char1, r1, c1, chars2, r2, c2):\n    v1 = ci.vars_lrct[(0, r1, c1, char1)]\n    if r2 < 0 or r2 >= ci.rows or c2 < 0 or c2 >= ci.cols:\n        pass\n    else:\n        vv2 = [ci.vars_lrct[(0, r2, c2, char2)] for char2 in chars2]\n        ci.solver.cnstr_implies_disj(v1, True, vv2, True, None)", "\ndef fini_implies(ci, char1, r1, c1, chars2, r2, c2):\n    v1 = ci.vars_lrct[(ci.layers - 1, r1, c1, char1)]\n    if r2 < 0 or r2 >= ci.rows or c2 < 0 or c2 >= ci.cols:\n        ci.solver.cnstr_count([v1], True, 0, 0, None)\n    else:\n        vv2 = [ci.vars_lrct[(ci.layers - 1, r2, c2, char2)] for char2 in chars2]\n        ci.solver.cnstr_implies_disj(v1, True, vv2, True, None)\n\n", "\n\n\ndef get_example_info(mkiii_setup):\n    ei = MKIIIInfo()\n\n    ei.layers = mkiii_setup.layers\n\n    if mkiii_setup.example == EX_MKJR_WALK:\n        ei.states = 'X-*'\n        ei.rep_rules = [(RR_GRP_CHOICE, [(DIR_ALL, '*XX', '--*')])]\n        ei.rep_rule_order = RR_ORD_ONE\n        ei.use_term = False\n\n        def _custom(ci):\n            init_points(ci, 'X', {(1, 1): '*'})\n        ei.custom = _custom\n\n    elif mkiii_setup.example == EX_MKJR_WALK_THRU:\n        ei.states = 'X-*$oO'\n        ei.rep_rules = [(RR_GRP_CHOICE, [(DIR_ALL, '*XX', '--*'), (DIR_ALL, '*X$', '--*'), (DIR_ALL, '*Xo', '--O')])]\n        ei.rep_rule_order = RR_ORD_ONE\n        ei.use_term = True\n\n        def _custom(ci):\n            # start in top-left\n            init_points(ci, 'X', {(1, 1): '*', (1, ci.cols - 2): '$', (ci.rows - 2, 1): '$', (ci.rows - 2, ci.cols - 2): 'o'})\n\n            # through collectibles to exit\n            fini_exact(ci, '$', 0)\n            fini_exact(ci, 'o', 0)\n\n        ei.custom = _custom\n\n    elif mkiii_setup.example == EX_MKJR_MAZE:\n        ei.states = 'X-~'\n        ei.rep_rules = [(RR_GRP_CHOICE, [(DIR_ALL, '-XX', '-~-')])]\n        ei.rep_rule_order = RR_ORD_ONE\n        ei.use_term = False\n\n        def _custom(ci):\n            # start in middle\n            init_points(ci, 'X', {(ci.rows // 2, ci.cols // 2): '-'})\n        ei.custom = _custom\n\n    elif mkiii_setup.example == EX_MKJR_MAZE_COIN:\n        ei.states = 'X-~$@o'\n        ei.rep_rules = [(RR_GRP_CHOICE, [(DIR_ALL, '-XX', '-~-'), (DIR_ALL, '-XX', '-$-'), (DIR_ALL, '-XX', '-@-'), (DIR_ALL, '-XX', '-o-')])]\n        ei.rep_rule_order = RR_ORD_ONE\n        ei.use_term = False\n\n        def _custom(ci):\n            # start in middle\n            init_points(ci, 'X', {(ci.rows // 2, ci.cols // 2): '-'})\n\n            # placements\n            fini_range(ci, '$', 3, 5)\n            fini_exact(ci, '@', 1)\n            fini_exact(ci, 'o', 1)\n        ei.custom = _custom\n\n    elif mkiii_setup.example == EX_SOKO:\n        ei.states = 'X-@#oO'\n        ei.rep_rules = [(RR_GRP_CHOICE, [(DIR_ALL, '@-', '-@'), (DIR_ALL, '@#-', '-@#'), (DIR_ALL, '@#o', '-@O')])]\n        ei.rep_rule_order = RR_ORD_ONE\n        ei.use_term = True\n\n        def _custom(ci):\n            # start\n            init_exact(ci, '@', 1)\n            init_exact(ci, '#', 2)\n            init_exact(ci, 'o', 2)\n\n            # border\n            for rr in range(ci.rows):\n                ci.solver.cnstr_count([ci.vars_lrct[(0, rr, 0, 'X')]], True, 1, 1, None)\n                ci.solver.cnstr_count([ci.vars_lrct[(0, rr, ci.cols - 1, 'X')]], True, 1, 1, None)\n            for cc in range(ci.cols):\n                ci.solver.cnstr_count([ci.vars_lrct[(0, 0, cc, 'X')]], True, 1, 1, None)\n                ci.solver.cnstr_count([ci.vars_lrct[(0, ci.rows - 1, cc, 'X')]], True, 1, 1, None)\n\n            # distances\n            init_dist_atleast(ci, '#', 'o', 2)\n\n            # clear around boxes\n            for rr in range(ci.rows):\n                for cc in range(ci.cols):\n                    for r2 in range(1, ci.rows - 1):\n                        if rr == r2:\n                            continue\n                        ci.solver.cnstr_implies_disj(ci.vars_lrct[(0, rr, cc, '#')], True, [ci.vars_lrct[(0, r2, cc, 'o')]], False, None)\n                    for c2 in range(1, ci.cols - 1):\n                        if cc == c2:\n                            continue\n                        ci.solver.cnstr_implies_disj(ci.vars_lrct[(0, rr, cc, '#')], True, [ci.vars_lrct[(0, rr, c2, 'o')]], False, None)\n\n            # all boxes cleared at end\n            fini_exact(ci, '#', 0)\n        ei.custom = _custom\n\n    elif mkiii_setup.example == EX_DOKU:\n        ei.states = '-123456789'\n        ei.rep_rules = [(RR_GRP_CHOICE, [(DIR_NONE, '-', '1'), (DIR_NONE, '-', '2'), (DIR_NONE, '-', '3'),\n                                         (DIR_NONE, '-', '4'), (DIR_NONE, '-', '5'), (DIR_NONE, '-', '6'),\n                                         (DIR_NONE, '-', '7'), (DIR_NONE, '-', '8'), (DIR_NONE, '-', '9')])]\n        ei.rep_rule_order = RR_ORD_ONE\n        ei.use_term = False\n\n        ei.extra_meta.append(util.meta_rect('level', [(0, 0, 3, 3), (0, 3, 3, 6), (0, 6, 3, 9), (3, 0, 6, 3), (3, 3, 6, 6), (3, 6, 6, 9), (6, 0, 9, 3), (6, 3, 9, 6), (6, 6, 9, 9)]))\n\n        def _custom(ci):\n            # check size\n            util.check(ci.rows == 9, 'doku size')\n            util.check(ci.cols == 9, 'doku size')\n\n            # start\n            init_range(ci, '-', ci.layers - 1, ci.layers - 1)\n\n            # symmetric\n            for rr in range(ci.rows):\n                for cc in range(ci.cols):\n                    ci.solver.cnstr_implies_disj(ci.vars_lrct[(0, rr, cc, '-')], True, [ci.vars_lrct[(0, ci.rows - 1 - rr, ci.cols - 1 - cc, '-')]], True, None)\n\n            # extra layer vars\n            vars_layer_cant = {}\n            for ll in range(ci.layers - 1):\n                vars_layer_cant[ll] = {}\n                for ss in '123456789':\n                    for rr in range(ci.rows):\n                        for cc in range(ci.cols):\n                            vars_layer_cant[ll][(rr, cc, ss)] = ci.solver.make_var()\n                for ss in '123456789':\n                    for rr in range(ci.rows):\n                        for cc in range(ci.cols):\n                            cant_vvs = []\n                            for r2 in range(ci.rows):\n                                if rr != r2:\n                                    cant_vvs.append(ci.vars_lrct[(ll, r2, cc, ss)])\n                            for c2 in range(ci.cols):\n                                if cc != c2:\n                                    cant_vvs.append(ci.vars_lrct[(ll, rr, c2, ss)])\n                            ci.solver.cnstr_implies_disj(vars_layer_cant[ll][(rr, cc, ss)], True, cant_vvs, True, None)\n\n            vars_layer_must = {}\n            for ll in range(ci.layers - 1):\n                vars_layer_must[ll] = {}\n                for ss in '123456789':\n                    for rr in range(ci.rows):\n                        for cc in range(ci.cols):\n                            box_cant = []\n                            for br in range(3):\n                                for bc in range(3):\n                                    r2 = (rr // 3) * 3 + br\n                                    c2 = (cc // 3) * 3 + bc\n                                    if (rr, cc) != (r2, c2):\n                                        box_cant.append(vars_layer_cant[ll][(r2, c2, ss)])\n                            box_cant_conj = ci.solver.make_conj(box_cant, True)\n                            vars_layer_must[ll][(rr, cc, ss)] = box_cant_conj\n\n            for ll in range(ci.layers - 1):\n                for ss in '123456789':\n                    for rr in range(ci.rows):\n                        for cc in range(ci.cols):\n                            changes = ci.solver.make_conj([ci.vars_lrct[(ll, rr, cc, '-')], ci.vars_lrct[(ll + 1, rr, cc, ss)]], True)\n                            ci.solver.cnstr_implies_disj(changes, True, [vars_layer_must[ll][(rr, cc, ss)]], True, None)\n\n            # partially filled then filled at end\n            for ll in range(ci.layers):\n                lo = 1 if ll + 1 == ci.layers else 0\n                for ss in '123456789':\n                    for rr in range(ci.rows):\n                        vars_rc = []\n                        for cc in range(ci.cols):\n                            vars_rc.append(ci.vars_lrct[(ll, rr, cc, ss)])\n                        ci.solver.cnstr_count(vars_rc, True, lo, 1, None)\n\n                    for cc in range(ci.cols):\n                        vars_rc = []\n                        for rr in range(ci.rows):\n                            vars_rc.append(ci.vars_lrct[(ll, rr, cc, ss)])\n                        ci.solver.cnstr_count(vars_rc, True, lo, 1, None)\n\n                    for br in range(ci.rows // 3):\n                        for bc in range(ci.cols // 3):\n                            vars_rc = []\n                            for ir in range(3):\n                                for ic in range(3):\n                                    vars_rc.append(ci.vars_lrct[(ll, br * 3 + ir, bc * 3 + ic, ss)])\n                            ci.solver.cnstr_count(vars_rc, True, lo, 1, None)\n\n        ei.custom = _custom\n\n    elif mkiii_setup.example == EX_LOCK:\n        rep_rules_player = (RR_GRP_CHOICE, [(DIR_ALL, '@-', '-@'), (DIR_ALL, '&-', '-&'), (DIR_ALL, '@%', '-&'), (DIR_ALL, '&:', '@-'), (DIR_ALL, '@~', '~@'), (DIR_ALL, '@o', '~O')])\n        rep_rules_enemy = (RR_GRP_ALL, [(DIR_ALL, '+--@', '-+-@'), (DIR_ALL, '+-@', '-+@'), (DIR_ALL, '+@', '-+'),\n                                         (DIR_ALL, '+--&', '-+-&'), (DIR_ALL, '+-&', '-+&'), (DIR_ALL, '+&', '-+')])\n        ei.states = 'X-~@%:&oO+'\n        ei.rep_rules = [rep_rules_player, rep_rules_enemy]\n        ei.rep_rule_names = ['player', 'enemy']\n        ei.rep_rule_order = RR_ORD_SEQ\n        ei.use_term = True\n\n        def _custom(ci):\n            # one start/goal\n            init_exact(ci, '@', 1)\n            init_exact(ci, 'o', 1)\n\n            # key/door/enemy\n            init_exact(ci, '%', 1)\n            init_exact(ci, ':', 1)\n            init_exact(ci, '+', 2)\n\n            # setup\n            init_range(ci, 'X', 0, ci.rows * ci.cols // 2)\n            init_dist_impl_nearby(ci, '+', '%:@', 2)\n            for rr in range(ci.rows):\n                for cc in range(ci.cols):\n                    ci.solver.cnstr_implies_disj(ci.vars_lrct[(0, rr, cc, '+')], True, [ci.vars_lrct[(ci.layers - 1, rr, cc, '+')]], False, None)\n\n            # goal reached at end\n            fini_exact(ci, 'o', 0)\n        ei.custom = _custom\n\n    elif mkiii_setup.example == EX_SLIDE:\n        ei.states = 'X-@^v><oOabc()[]'\n        ei.rep_rules = [\n            (RR_GRP_CHOICE, [\n                (DIR_NONE, '@', '@'),\n                (DIR_NORTH, '@-', '-^'), (DIR_SOUTH, '@-', '-v'), (DIR_EAST, '@-', '->'), (DIR_WEST, '@-', '-<'),\n                (DIR_NORTH, '@o', '-O'), (DIR_SOUTH, '@o', '-O'), (DIR_EAST, '@o', '-O'), (DIR_WEST, '@o', '-O'),\n                (DIR_NORTH, '^o', '-O'), (DIR_SOUTH, 'vo', '-O'), (DIR_EAST, '>o', '-O'), (DIR_WEST, '<o', '-O'),\n                (DIR_NORTH, '^a', '-a'), (DIR_SOUTH, 'va', '-a'), (DIR_EAST, '>a', '-a'), (DIR_WEST, '<a', '-a'),\n                (DIR_NORTH, '^b', '-b'), (DIR_SOUTH, 'vb', '-b'), (DIR_EAST, '>b', '-b'), (DIR_WEST, '<b', '-b'),\n                (DIR_NORTH, '^c', '-c'), (DIR_SOUTH, 'vc', '-c'), (DIR_EAST, '>c', '-c'), (DIR_WEST, '<c', '-c'),\n                (DIR_NORTH, '^-', '-^'), (DIR_SOUTH, 'v-', '-v'), (DIR_EAST, '>-', '->'), (DIR_WEST, '<-', '-<'),\n                (DIR_NORTH, '^X', '@X'), (DIR_SOUTH, 'vX', '@X'), (DIR_EAST, '>X', '@X'), (DIR_WEST, '<X', '@X')]),\n             (RR_GRP_ALL, [(DIR_NONE, 'a', 'b'), (DIR_NONE, 'b', 'c'), (DIR_NONE, 'c', 'a'), # only one turret so no rules on those collisions; turret/goal?\n                            (DIR_NORTH, 'a-', 'b('), (DIR_SOUTH, 'a-', 'b)'), (DIR_EAST, 'a-', 'b]'), (DIR_WEST, 'a-', 'b['),\n                            (DIR_NORTH, 'a@', 'b('), (DIR_SOUTH, 'a@', 'b)'), (DIR_EAST, 'a@', 'b]'), (DIR_WEST, 'a@', 'b['),\n                            (DIR_NORTH, 'a^', 'b('), (DIR_SOUTH, 'a^', 'b)'), (DIR_EAST, 'a^', 'b]'), (DIR_WEST, 'a^', 'b['),\n                            (DIR_NORTH, 'av', 'b('), (DIR_SOUTH, 'av', 'b)'), (DIR_EAST, 'av', 'b]'), (DIR_WEST, 'av', 'b['),\n                            (DIR_NORTH, 'a>', 'b('), (DIR_SOUTH, 'a>', 'b)'), (DIR_EAST, 'a>', 'b]'), (DIR_WEST, 'a>', 'b['),\n                            (DIR_NORTH, 'a<', 'b('), (DIR_SOUTH, 'a<', 'b)'), (DIR_EAST, 'a<', 'b]'), (DIR_WEST, 'a<', 'b['),\n                            (DIR_NORTH, '(-', '-('), (DIR_SOUTH, ')-', '-)'), (DIR_EAST, ']-', '-]'), (DIR_WEST, '[-', '-['),\n                            (DIR_NORTH, '(@', '-('), (DIR_SOUTH, ')@', '-)'), (DIR_EAST, ']@', '-]'), (DIR_WEST, '[@', '-['),\n                            (DIR_NORTH, '(^', '-('), (DIR_SOUTH, ')^', '-)'), (DIR_EAST, ']^', '-]'), (DIR_WEST, '[^', '-['),\n                            (DIR_NORTH, '(v', '-('), (DIR_SOUTH, ')v', '-)'), (DIR_EAST, ']v', '-]'), (DIR_WEST, '[v', '-['),\n                            (DIR_NORTH, '(>', '-('), (DIR_SOUTH, ')>', '-)'), (DIR_EAST, ']>', '-]'), (DIR_WEST, '[>', '-['),\n                            (DIR_NORTH, '(<', '-('), (DIR_SOUTH, ')<', '-)'), (DIR_EAST, ']<', '-]'), (DIR_WEST, '[<', '-['),\n                            (DIR_NORTH, '(X', '-X'), (DIR_SOUTH, ')X', '-X'), (DIR_EAST, ']X', '-X'), (DIR_WEST, '[X', '-X')])]\n        ei.rep_rule_names = ['player', 'enemy']\n        ei.rep_rule_order = RR_ORD_SEQ\n        ei.use_term = True\n\n        def _custom(ci):\n            # start/goal/turret\n            init_exact(ci, '@', 1)\n            init_exact(ci, 'a', 1)\n            init_exact(ci, 'o', 1)\n\n            # start and goal in opposite corners\n            CSIZE = 3\n            start_vvs_rem = []\n            start_vvs_00 = []\n            start_vvs_01 = []\n            start_vvs_10 = []\n            start_vvs_11 = []\n            goal_vvs_rem = []\n            goal_vvs_00 = []\n            goal_vvs_01 = []\n            goal_vvs_10 = []\n            goal_vvs_11 = []\n            for rr in range(CSIZE):\n                for cc in range(CSIZE):\n                    start_vvs_rem.append(ci.vars_lrct[(0, rr, cc, '@')])\n                    goal_vvs_rem.append(ci.vars_lrct[(0, rr, cc, 'o')])\n            for rr in range(CSIZE):\n                for cc in range(CSIZE):\n                    start_vvs_00.append(ci.vars_lrct[(0, rr, cc, '@')])\n                    goal_vvs_00.append(ci.vars_lrct[(0, rr, cc, 'o')])\n            for rr in range(CSIZE):\n                for cc in range(ci.cols - CSIZE, ci.cols):\n                    start_vvs_01.append(ci.vars_lrct[(0, rr, cc, '@')])\n                    goal_vvs_01.append(ci.vars_lrct[(0, rr, cc, 'o')])\n            for rr in range(ci.rows - CSIZE, ci.rows):\n                for cc in range(CSIZE):\n                    start_vvs_10.append(ci.vars_lrct[(0, rr, cc, '@')])\n                    goal_vvs_10.append(ci.vars_lrct[(0, rr, cc, 'o')])\n            for rr in range(ci.rows - CSIZE, ci.rows):\n                for cc in range(ci.cols - CSIZE, ci.cols):\n                    start_vvs_11.append(ci.vars_lrct[(0, rr, cc, '@')])\n                    goal_vvs_11.append(ci.vars_lrct[(0, rr, cc, 'o')])\n            start_vvs_rem = sorted(list(set(start_vvs_rem) - set(start_vvs_00) - set(start_vvs_01) - set(start_vvs_10) - set(start_vvs_11)))\n            ci.solver.cnstr_count(start_vvs_00 + start_vvs_01 + start_vvs_10 + start_vvs_11, True, 1, 1, None)\n            ci.solver.cnstr_count(start_vvs_rem, True, 0, 0, None)\n            goal_vvs_rem = sorted(list(set(goal_vvs_rem) - set(goal_vvs_00) - set(goal_vvs_01) - set(goal_vvs_10) - set(goal_vvs_11)))\n            ci.solver.cnstr_count(goal_vvs_00 + goal_vvs_01 + goal_vvs_10 + goal_vvs_11, True, 1, 1, None)\n            ci.solver.cnstr_count(goal_vvs_rem, True, 0, 0, None)\n\n            for start_vv in start_vvs_00:\n                ci.solver.cnstr_implies_disj(start_vv, True, goal_vvs_00, False, None)\n                ci.solver.cnstr_implies_disj(start_vv, True, goal_vvs_01, False, None)\n                ci.solver.cnstr_implies_disj(start_vv, True, goal_vvs_10, False, None)\n                ci.solver.cnstr_implies_disj(start_vv, True, goal_vvs_11, True, None)\n            for start_vv in start_vvs_01:\n                ci.solver.cnstr_implies_disj(start_vv, True, goal_vvs_00, False, None)\n                ci.solver.cnstr_implies_disj(start_vv, True, goal_vvs_01, False, None)\n                ci.solver.cnstr_implies_disj(start_vv, True, goal_vvs_10, True, None)\n                ci.solver.cnstr_implies_disj(start_vv, True, goal_vvs_11, False, None)\n            for start_vv in start_vvs_10:\n                ci.solver.cnstr_implies_disj(start_vv, True, goal_vvs_00, False, None)\n                ci.solver.cnstr_implies_disj(start_vv, True, goal_vvs_01, True, None)\n                ci.solver.cnstr_implies_disj(start_vv, True, goal_vvs_10, False, None)\n                ci.solver.cnstr_implies_disj(start_vv, True, goal_vvs_11, False, None)\n            for start_vv in start_vvs_11:\n                ci.solver.cnstr_implies_disj(start_vv, True, goal_vvs_00, True, None)\n                ci.solver.cnstr_implies_disj(start_vv, True, goal_vvs_01, False, None)\n                ci.solver.cnstr_implies_disj(start_vv, True, goal_vvs_10, False, None)\n                ci.solver.cnstr_implies_disj(start_vv, True, goal_vvs_11, False, None)\n\n            for goal_vv in goal_vvs_00:\n                ci.solver.cnstr_implies_disj(goal_vv, True, start_vvs_00, False, None)\n                ci.solver.cnstr_implies_disj(goal_vv, True, start_vvs_01, False, None)\n                ci.solver.cnstr_implies_disj(goal_vv, True, start_vvs_10, False, None)\n                ci.solver.cnstr_implies_disj(goal_vv, True, start_vvs_11, True, None)\n            for goal_vv in goal_vvs_01:\n                ci.solver.cnstr_implies_disj(goal_vv, True, start_vvs_00, False, None)\n                ci.solver.cnstr_implies_disj(goal_vv, True, start_vvs_01, False, None)\n                ci.solver.cnstr_implies_disj(goal_vv, True, start_vvs_10, True, None)\n                ci.solver.cnstr_implies_disj(goal_vv, True, start_vvs_11, False, None)\n            for goal_vv in goal_vvs_10:\n                ci.solver.cnstr_implies_disj(goal_vv, True, start_vvs_00, False, None)\n                ci.solver.cnstr_implies_disj(goal_vv, True, start_vvs_01, True, None)\n                ci.solver.cnstr_implies_disj(goal_vv, True, start_vvs_10, False, None)\n                ci.solver.cnstr_implies_disj(goal_vv, True, start_vvs_11, False, None)\n            for goal_vv in goal_vvs_11:\n                ci.solver.cnstr_implies_disj(goal_vv, True, start_vvs_00, True, None)\n                ci.solver.cnstr_implies_disj(goal_vv, True, start_vvs_01, False, None)\n                ci.solver.cnstr_implies_disj(goal_vv, True, start_vvs_10, False, None)\n                ci.solver.cnstr_implies_disj(goal_vv, True, start_vvs_11, False, None)\n\n            # turret in middle\n            turret_rows = range(ci.rows // 3, 2 * ci.rows // 3)\n            turret_cols = range(ci.cols // 3, 2 * ci.cols // 3)\n            vvs = []\n            for rr in turret_rows:\n                for cc in turret_cols:\n                    vvs.append(ci.vars_lrct[(0, rr, cc, 'a')])\n            ci.solver.cnstr_count(vvs, True, 1, 1, None)\n\n            # clear around turrets\n            for rr in range(ci.rows):\n                for cc in range(ci.cols):\n                    for r2 in range(1, ci.rows - 1):\n                        if rr == r2:\n                            continue\n                        ci.solver.cnstr_implies_disj(ci.vars_lrct[(0, rr, cc, 'a')], True, [ci.vars_lrct[(0, r2, cc, '-')]], True, None)\n                    for c2 in range(1, ci.cols - 1):\n                        if cc == c2:\n                            continue\n                        ci.solver.cnstr_implies_disj(ci.vars_lrct[(0, rr, cc, 'a')], True, [ci.vars_lrct[(0, rr, c2, '-')]], True, None)\n\n            # bump along side walls\n            vvs = []\n            for rr in turret_rows:\n                vvs.append(ci.vars_lrct[(0, rr, 1, 'X')])\n            ci.solver.cnstr_count(vvs, True, 1, 1, None)\n            vvs = []\n            for rr in turret_rows:\n                vvs.append(ci.vars_lrct[(0, rr, ci.cols - 2, 'X')])\n            ci.solver.cnstr_count(vvs, True, 1, 1, None)\n            vvs = []\n            for cc in turret_cols:\n                vvs.append(ci.vars_lrct[(0, 1, cc, 'X')])\n            ci.solver.cnstr_count(vvs, True, 1, 1, None)\n            vvs = []\n            for cc in turret_cols:\n                vvs.append(ci.vars_lrct[(0, ci.rows - 2, cc, 'X')])\n            ci.solver.cnstr_count(vvs, True, 1, 1, None)\n\n            # goal reached at end\n            fini_exact(ci, 'o', 0)\n        ei.custom = _custom\n\n    elif mkiii_setup.example == EX_FILL:\n        ei.states = 'X-~@^v><'\n        ei.rep_rules = [\n            (RR_GRP_CHOICE, [\n                (DIR_NORTH, '@-', '~^'), (DIR_SOUTH, '@-', '~v'), (DIR_EAST, '@-', '~>'), (DIR_WEST, '@-', '~<'),\n                (DIR_NORTH, '@~', '~^'), (DIR_SOUTH, '@~', '~v'), (DIR_EAST, '@~', '~>'), (DIR_WEST, '@~', '~<'),\n                (DIR_NORTH, '^-', '~^'), (DIR_SOUTH, 'v-', '~v'), (DIR_EAST, '>-', '~>'), (DIR_WEST, '<-', '~<'),\n                (DIR_NORTH, '^~', '~^'), (DIR_SOUTH, 'v~', '~v'), (DIR_EAST, '>~', '~>'), (DIR_WEST, '<~', '~<'),\n                (DIR_NORTH, '^X', '@X'), (DIR_SOUTH, 'vX', '@X'), (DIR_EAST, '>X', '@X'), (DIR_WEST, '<X', '@X')])]\n        ei.rep_rule_order = RR_ORD_ONE\n        ei.use_term = True\n\n        def _custom(ci):\n            # start\n            init_exact(ci, '@', 1)\n            init_range(ci, '-', (ci.rows - 2) * (ci.cols - 2) // 3, ci.rows * ci.cols)\n            init_range(ci, '~', 0, 0)\n\n            # border\n            for rr in range(ci.rows):\n                ci.solver.cnstr_count([ci.vars_lrct[(0, rr, 0, 'X')]], True, 1, 1, None)\n                ci.solver.cnstr_count([ci.vars_lrct[(0, rr, ci.cols - 1, 'X')]], True, 1, 1, None)\n            for cc in range(ci.cols):\n                ci.solver.cnstr_count([ci.vars_lrct[(0, 0, cc, 'X')]], True, 1, 1, None)\n                ci.solver.cnstr_count([ci.vars_lrct[(0, ci.rows - 1, cc, 'X')]], True, 1, 1, None)\n\n            # filled\n            fini_exact(ci, '-', 0)\n            fini_exact(ci, '@', 1)\n        ei.custom = _custom\n\n    elif mkiii_setup.example == EX_PLAT:\n        ei.states = 'X-@12oO+?'\n        ei.rep_rules = [(RR_GRP_CHOICE,\n                         [(DIR_EASTWEST, '@-', '-@'), (DIR_NONE, '@', '@'), (DIR_EASTWEST, '@o', '-O'), (DIR_NORTH, 'X@', 'X2'),\n                          (DIR_EASTWEST, '1-', '-1'), (DIR_NONE, '1', '1'),\n                          (DIR_EASTWEST, '2-', '-2'), (DIR_NONE, '2', '2')]),\n                        (RR_GRP_ALL,\n                         [(DIR_WEST, '+-', '-+'), (DIR_WEST, '+@', '-+'), (DIR_WEST, '+2', '-+'), (DIR_WEST, '+1', '-+')]),\n                        (RR_GRP_ALL, # TODO: what about enemy above player? '-@+'\n                         [(DIR_NORTH, '-+', '+-'), (DIR_NORTH, '@+', '+-'),\n                          (DIR_NORTH, 'X@', 'X@'), (DIR_NORTH, '+@', '@-'), (DIR_NORTH, '-@', '@-'),\n                          (DIR_NORTH, '2-', '-1'), (DIR_NORTH, '2X', '@X'), (DIR_NORTH, '2?', '@X'),\n                          (DIR_NORTH, '1-', '-@'), (DIR_NORTH, '1X', '@X'), (DIR_NORTH, '1?', '@X')])]\n        ei.rep_rule_names = ['player', 'enemy', 'physics']\n        ei.rep_rule_order = RR_ORD_SEQ\n        ei.use_term = True\n\n        def _custom(ci):\n            # start/goal placement\n            ci.solver.cnstr_count([ci.vars_lrct[(0, ci.rows - 2, 0, '@')]], True, 1, 1, None)\n            ci.solver.cnstr_count([ci.vars_lrct[(0, ci.rows - 2, ci.cols - 1, 'o')]], True, 1, 1, None)\n\n            # one start/goal\n            init_exact(ci, '@', 1)\n            init_exact(ci, 'o', 1)\n            init_exact(ci, '?', 1)\n            init_exact(ci, '+', 2)\n\n            # goal reached at end\n            fini_exact(ci, 'o', 0)\n            fini_exact(ci, '?', 0)\n            fini_exact(ci, '+', 0)\n        ei.custom = _custom\n\n    elif mkiii_setup.example == EX_VVV:\n        ei.states = 'X-^v+()oO'\n        ei.rep_rules = [(RR_GRP_CHOICE,\n                         [(DIR_SOUTH, 'vX', '^X'), (DIR_NONE, 'v', 'v'), (DIR_EASTWEST, 'v-', '-v'), (DIR_EASTWEST, 'vo', '-O'),\n                          (DIR_NORTH, '^X', 'vX'), (DIR_NONE, '^', '^'), (DIR_EASTWEST, '^-', '-^'), (DIR_EASTWEST, '^o', '-O')]),\n                        (RR_GRP_ALL,\n                         [(DIR_EAST, ')-', '-)'), (DIR_EAST, ')X', '(X'), (DIR_EAST, ')v', '-)'), (DIR_EAST, ')^', '-)'),\n                          (DIR_WEST, '(-', '-('), (DIR_WEST, '(X', ')X'), (DIR_WEST, '(v', '-('), (DIR_WEST, '(^', '-('),\n                          (DIR_EAST, ')(', '()')]),\n                        (RR_GRP_ALL,\n                         [(DIR_SOUTH, 'v-', '-v'), (DIR_SOUTH, 'vo', '-O'), (DIR_SOUTH, 'v(', '-('), (DIR_SOUTH, 'v)', '-)'), (DIR_SOUTH, 'v+', '-+'),\n                          (DIR_NORTH, '^-', '-^'), (DIR_NORTH, '^o', '-O'), (DIR_NORTH, '^)', '-)'), (DIR_NORTH, '^)', '-)'), (DIR_NORTH, '^+', '-+')])]\n\n        ei.rep_rule_names = ['player', 'enemy', 'physics']\n        ei.rep_rule_order = RR_ORD_SEQ\n        ei.use_term = True\n\n        def _custom(ci):\n            # start/goal placement\n            ci.solver.cnstr_count([ci.vars_lrct[(0, ci.rows - 2, 1, 'v')]], True, 1, 1, None)\n            ci.solver.cnstr_count([ci.vars_lrct[(0, ci.rows - 2, ci.cols - 2, 'o')]], True, 1, 1, None)\n\n            # one start/goal\n            init_exact(ci, 'v', 1)\n            init_exact(ci, 'o', 1)\n\n            # turrets / solid\n            init_exact(ci, '()', 2)\n            init_range(ci, '+', 4, ci.cols)\n\n            # goal reached at end\n            fini_exact(ci, 'o', 0)\n        ei.custom = _custom\n\n    elif mkiii_setup.example == EX_LINK:\n        ei.states = '\u2500\u2502\u2510\u2518\u2514\u250cX'\n        ei.rep_rules = [(RR_GRP_CHOICE, [(DIR_NONE, '\u2500', '\u2502'), (DIR_NONE, '\u2502', '\u2500'), (DIR_NONE, '\u2510', '\u2518'), (DIR_NONE, '\u2518', '\u2514'), (DIR_NONE, '\u2514', '\u250c'), (DIR_NONE, '\u250c', '\u2510')])]\n        ei.rep_rule_order = RR_ORD_ONE\n        ei.use_term = True\n\n        def _custom(ci):\n            init_range(ci, '\u2500', 1, 10)\n            init_range(ci, '\u2502', 1, 10)\n            init_range(ci, 'X', max(1, ci.rows * ci.rows // 10), ci.rows * ci.rows // 2)\n\n            # disconnected at start\n            rows_order = list(range(ci.rows))\n            cols_order = list(range(ci.cols))\n            if ci.rng:\n                ci.rng.shuffle(rows_order)\n                ci.rng.shuffle(cols_order)\n\n            ind = 0\n            for rr in rows_order:\n                for cc in cols_order:\n                    ind += 1\n                    if ind % 4 == 0:\n                        ci.solver.cnstr_count([ci.vars_lrct[(0, rr, cc, ss)] for ss in '\u2500\u2502\u2510\u2518\u2514\u250c'], True, 1, 1, None)\n                        init_implies(ci, '\u2500', rr, cc, '\u2510\u2518\u2502X', rr, cc - 1)\n                        init_implies(ci, '\u2500', rr, cc, '\u2514\u250c\u2502X', rr, cc + 1)\n                        init_implies(ci, '\u2502', rr, cc, '\u2518\u2514\u2500X', rr - 1, cc)\n                        init_implies(ci, '\u2502', rr, cc, '\u250c\u2510\u2500X', rr + 1, cc)\n                        init_implies(ci, '\u2510', rr, cc, '\u2510\u2518\u2502X', rr, cc - 1)\n                        init_implies(ci, '\u2510', rr, cc, '\u250c\u2510\u2500X', rr + 1, cc)\n                        init_implies(ci, '\u2518', rr, cc, '\u2510\u2518\u2502X', rr, cc - 1)\n                        init_implies(ci, '\u2518', rr, cc, '\u2518\u2514\u2500X', rr - 1, cc)\n                        init_implies(ci, '\u2514', rr, cc, '\u2514\u250c\u2502X', rr, cc + 1)\n                        init_implies(ci, '\u2514', rr, cc, '\u2518\u2514\u2500X', rr - 1, cc)\n                        init_implies(ci, '\u250c', rr, cc, '\u2514\u250c\u2502X', rr, cc + 1)\n                        init_implies(ci, '\u250c', rr, cc, '\u250c\u2510\u2500X', rr + 1, cc)\n\n            # connected at end\n            for rr in range(ci.rows):\n                for cc in range(ci.cols):\n                    fini_implies(ci, '\u2500', rr, cc, '\u2514\u250c\u2500', rr, cc - 1)\n                    fini_implies(ci, '\u2500', rr, cc, '\u2510\u2518\u2500', rr, cc + 1)\n                    fini_implies(ci, '\u2502', rr, cc, '\u2518\u2514\u2502', rr + 1, cc)\n                    fini_implies(ci, '\u2502', rr, cc, '\u250c\u2510\u2502', rr - 1, cc)\n                    fini_implies(ci, '\u2510', rr, cc, '\u2514\u250c\u2500', rr, cc - 1)\n                    fini_implies(ci, '\u2510', rr, cc, '\u2518\u2514\u2502', rr + 1, cc)\n                    fini_implies(ci, '\u2518', rr, cc, '\u2514\u250c\u2500', rr, cc - 1)\n                    fini_implies(ci, '\u2518', rr, cc, '\u250c\u2510\u2502', rr - 1, cc)\n                    fini_implies(ci, '\u2514', rr, cc, '\u2510\u2518\u2500', rr, cc + 1)\n                    fini_implies(ci, '\u2514', rr, cc, '\u250c\u2510\u2502', rr - 1, cc)\n                    fini_implies(ci, '\u250c', rr, cc, '\u2510\u2518\u2500', rr, cc + 1)\n                    fini_implies(ci, '\u250c', rr, cc, '\u2518\u2514\u2502', rr + 1, cc)\n\n            # no simple loops at end\n            for rr in range(ci.rows - 1):\n                for cc in range(ci.cols - 1):\n                    patt = ci.solver.make_conj([ci.vars_lrct[(ci.layers - 1, rr, cc, '\u250c')], ci.vars_lrct[(ci.layers - 1, rr, cc + 1, '\u2510')], ci.vars_lrct[(ci.layers - 1, rr + 1, cc, '\u2514')], ci.vars_lrct[(ci.layers - 1, rr + 1, cc + 1, '\u2518')]], True)\n                    ci.solver.cnstr_count([patt], True, 0, 0, None)\n\n        ei.custom = _custom\n\n    elif mkiii_setup.example == EX_MATCH:\n        ei.states = 'X-789'\n        rep_rules_fall  = (RR_GRP_ALL, [(DIR_SOUTH, '7-', '-7'), (DIR_SOUTH, '8-', '-8'), (DIR_SOUTH, '9-', '-9')])\n        rep_rules_match = (RR_GRP_ALL, [(DIR_SOUTHEAST, '777', '---'), (DIR_SOUTHEAST, '888', '---'), (DIR_SOUTHEAST, '999', '---')])\n        rep_rules_swap  = (RR_GRP_CHOICE, [(DIR_ALL, '78', '87'), (DIR_ALL, '89', '98'), (DIR_ALL, '97', '79'), (DIR_EASTWEST, '7-', '-7'), (DIR_EASTWEST, '8-', '-8'), (DIR_EASTWEST, '9-', '-9')])\n        ei.rep_rules = [rep_rules_fall, rep_rules_match, rep_rules_swap]\n        ei.rep_rule_names = ['fall', 'match', 'swap']\n        ei.rep_rule_order = RR_ORD_PRI\n        ei.use_term = True\n\n        def _custom(ci):\n            # no block above blanks\n            for rr in range(1, ci.rows):\n                for cc in range(ci.cols):\n                    ci.solver.cnstr_implies_disj(ci.vars_lrct[(0, rr, cc, '-')], True, [ci.vars_lrct[(0, rr - 1, cc, '-')]], True, None)\n\n            # only a few blank at top\n            init_range(ci, '-', ci.cols + 1, ci.cols * 3)\n\n            # only a few blocks\n            init_range(ci, 'X', 0, ci.rows * ci.cols // 5)\n\n            # a few of each block\n            init_range(ci, '7', 3, ci.rows * ci.cols)\n            init_range(ci, '8', 3, ci.rows * ci.cols)\n            init_range(ci, '9', 3, ci.rows * ci.cols)\n\n            # no 3 in a row\n            for ss in '789':\n                for rr in range(1, ci.rows - 1):\n                    for cc in range(ci.cols):\n                        ci.solver.cnstr_implies_disj(ci.vars_lrct[(0, rr, cc, ss)], True, [ci.vars_lrct[(0, rr - 1, cc, ss)], ci.vars_lrct[(0, rr + 1, cc, ss)]], False, None)\n                for rr in range(ci.rows):\n                    for cc in range(1, ci.cols - 1):\n                        ci.solver.cnstr_implies_disj(ci.vars_lrct[(0, rr, cc, ss)], True, [ci.vars_lrct[(0, rr, cc - 1, ss)], ci.vars_lrct[(0, rr, cc + 1, ss)]], False, None)\n\n            # all cleared at end\n            fini_range(ci, '7', 0, 0)\n            fini_range(ci, '8', 0, 0)\n            fini_range(ci, '9', 0, 0)\n\n        ei.custom = _custom\n\n    else:\n        util.check(False, 'mkiii_setup example' + mkiii_setup.example)\n\n    return ei", "\n\n\nclass GeneratorMKIII(generator.Generator):\n    def __init__(self, solver, randomize, rows, cols, scheme_info, tag_level, game_level):\n        super().__init__(solver, randomize, rows, cols, scheme_info, tag_level, game_level)\n\n        self._states = None\n        self._layers = None\n        self._group_names = None\n\n        self._vars_lrct = None\n        self._vars_patt = None\n        self._vars_term = None\n        self._vars_pri = None\n\n        self._var_state_false = None\n\n        self._change_vars_rcs = None\n\n    def add_rules_mkiii(self, mkiii_info):\n        print('add mkiii constraints')\n\n        self._states = mkiii_info.states\n        self._layers = mkiii_info.layers\n        self._group_names = list(mkiii_info.rep_rule_names) if mkiii_info.rep_rule_names else None\n\n        self.append_extra_meta(mkiii_info.extra_meta)\n\n        self._vars_lrct = {}\n        self._vars_patt = {}\n        self._vars_term = None\n        self._vars_pri = None\n\n        self._var_state_false = self._solver.make_var()\n        self._solver.cnstr_count([self._var_state_false], True, 0, 0, None)\n\n        self._change_vars_rcs = [[]]\n\n        text_to_tile = {}\n        for tile, text in self._scheme_info.tileset.tile_to_text.items():\n            util.check(text not in text_to_tile, 'cannot have duplicate tile text ' + text + ' for mkiii')\n            util.check(text in self._states, 'text ' + text + ' not in states')\n            text_to_tile[text] = tile\n\n        layers_order = list(range(self._layers))\n        rows_order = list(range(self._rows))\n        cols_order = list(range(self._cols))\n        states_order = list(self._states)\n\n        if self._rng:\n            self._rng.shuffle(layers_order)\n            self._rng.shuffle(rows_order)\n            self._rng.shuffle(cols_order)\n            self._rng.shuffle(states_order)\n\n        # terminal variables\n        if mkiii_info.use_term:\n            self._vars_term = []\n            self._vars_term.append(None)\n            for ll in range(self._layers - 1):\n                self._vars_term.append(self._solver.make_var())\n\n        # state variables\n        for ll in layers_order:\n            for rr in rows_order:\n                for cc in cols_order:\n                    for ss in states_order:\n                        if ll == 0:\n                            if ss in text_to_tile:\n                                self._vars_lrct[(0, rr, cc, ss)] = self._vars_rc_t[(rr, cc)][text_to_tile[ss]]\n                            else:\n                                self._vars_lrct[(0, rr, cc, ss)] = self._var_state_false\n                        else:\n                            self._vars_lrct[(ll, rr, cc, ss)] = self._solver.make_var()\n\n        # one state true (first layer already handled)\n        for ll in range(1, self._layers):\n            for rr in range(self._rows):\n                for cc in range(self._cols):\n                    vvs = []\n                    for ss in self._states:\n                        vvs.append(self._vars_lrct[(ll, rr, cc, ss)])\n\n                    self._solver.cnstr_count(vvs, True, 1, 1, None)\n\n        # make_conj duplicate helper\n        conjs = {}\n        def _make_conj(_vvs):\n            nonlocal conjs\n\n            _key = tuple(sorted([str(_vv) for _vv in _vvs]))\n\n            if _key not in conjs:\n                conjs[_key] = self._solver.make_conj(_vvs, True)\n            return conjs[_key]\n\n        if mkiii_info.rep_rule_order in [RR_ORD_ONE, RR_ORD_SEQ]:\n            self._vars_pri = None\n        elif mkiii_info.rep_rule_order == RR_ORD_PRI:\n            self._vars_pri = []\n        else:\n            util.check(False, 'rep_rule_order')\n\n        if mkiii_info.rep_rule_order == RR_ORD_ONE:\n            util.check(len(mkiii_info.rep_rules) == 1, 'rep_rule_order')\n        elif mkiii_info.rep_rule_order in [RR_ORD_SEQ, RR_ORD_PRI]:\n            util.check(len(mkiii_info.rep_rules) > 1, 'rep_rule_order')\n        else:\n            util.check(False, 'rep_rule_order')\n\n        for ll in range(self._layers - 1):\n            # keep track of change vars\n            layer_change_vars_rcs = []\n\n            # terminal stays set\n            if self._vars_term is not None:\n                if ll > 0:\n                    self._solver.cnstr_implies_disj(self._vars_term[ll], True, [self._vars_term[ll + 1]], True, None)\n\n            # keep track of possible changes at this layer\n            all_changes_rc = {}\n            for rr in range(self._rows):\n                for cc in range(self._cols):\n                    all_changes_rc[(rr, cc)] = []\n\n            # set up priority vars\n            if self._vars_pri is not None:\n                inds_pri = []\n\n            # set up rep rules\n            for rep_rules_index in range(len(mkiii_info.rep_rules)):\n                if self._vars_pri is not None:\n                    ind_pri = self._solver.make_var()\n                    prev_inds_pri = list(inds_pri)\n                    inds_pri.append(ind_pri)\n                else:\n                    if rep_rules_index != (ll % len(mkiii_info.rep_rules)):\n                        continue\n\n                rep_rules_type, rep_rules = mkiii_info.rep_rules[rep_rules_index]\n\n                # keep track of possible changes at this index\n                ind_changes = []\n                ind_changes_vin = []\n\n                # connections between layers\n                for rr in range(self._rows):\n                    for cc in range(self._cols):\n                        for rule_info in rep_rules:\n                            rule_dirs, rule_in, rule_out = rule_info\n                            util.check(len(rule_in) == len(rule_out), 'rule in and out different lengths')\n\n                            for dr, dc in rule_dirs:\n                                util.check(abs(dr) + abs(dc) <= 1, 'dr and/or dc out of range')\n                                if dr == dc == 0:\n                                    util.check(len(rule_in) == len(rule_out) == 1, 'rule has length but no direction')\n\n                                if rr + dr * len(rule_in) >= -1 and rr + dr * len(rule_in) <= self._rows and cc + dc * len(rule_in) >= -1 and cc + dc * len(rule_in) <= self._cols:\n                                    vin = []\n                                    vou = []\n                                    vrs = []\n                                    vcs = []\n                                    for ii in range(len(rule_in)):\n                                        vin.append(self._vars_lrct[(ll + 0, rr + dr * ii, cc + dc * ii, rule_in[ii])])\n                                        vou.append(self._vars_lrct[(ll + 1, rr + dr * ii, cc + dc * ii, rule_out[ii])])\n                                        vrs.append(rr + dr * ii)\n                                        vcs.append(cc + dc * ii)\n\n                                    change = _make_conj(vin + vou)\n                                    change_vin = _make_conj(vin)\n                                    layer_change_vars_rcs.append((vin + vou, (min(vrs), min(vcs), max(vrs) + 1, max(vcs) + 1)))\n\n                                    ind_changes.append(change)\n                                    ind_changes_vin.append(change_vin)\n\n                                    for ii in range(len(rule_in)):\n                                        all_changes_rc[(rr + dr * ii, cc + dc * ii)].append(change)\n\n                if self._vars_pri is not None:\n                    # pri equals any change\n                    for change in ind_changes:\n                        self._solver.cnstr_implies_disj(change, True, [ind_pri], True, None)\n                    self._solver.cnstr_implies_disj(ind_pri, True, ind_changes, True, None)\n\n                if rep_rules_type == RR_GRP_CHOICE:\n                    # exactly one change or terminal or prev pri changed\n                    changes_or_term_or_prev_pri = ind_changes\n                    if self._vars_term is not None:\n                        changes_or_term_or_prev_pri.append(self._vars_term[ll + 1])\n                    if self._vars_pri is not None:\n                        changes_or_term_or_prev_pri = changes_or_term_or_prev_pri + prev_inds_pri\n                    self._solver.cnstr_count(changes_or_term_or_prev_pri, True, 1, 1, None)\n\n                elif rep_rules_type == RR_GRP_ALL:\n                    # everything that can change does, unless terminal or prev_pri\n                    for ind_change, ind_change_vin in zip(ind_changes, ind_changes_vin):\n                        change_or_term_or_prev_pri = [ind_change]\n                        if self._vars_term is not None:\n                            change_or_term_or_prev_pri.append(self._vars_term[ll + 1])\n                        if self._vars_pri is not None:\n                            change_or_term_or_prev_pri = change_or_term_or_prev_pri + prev_inds_pri\n                        self._solver.cnstr_implies_disj(ind_change_vin, True, change_or_term_or_prev_pri, True, None)\n                        self._solver.cnstr_count(change_or_term_or_prev_pri, True, 0, 1, None)\n\n                else:\n                    util.check(False, 'rep_rules_type')\n\n            self._change_vars_rcs.append(layer_change_vars_rcs)\n\n            if self._vars_pri is not None:\n                self._vars_pri.append(inds_pri)\n\n                # exactly one priority changes, or term\n                inds_pri_or_term = list(inds_pri)\n                if self._vars_term is not None:\n                    inds_pri_or_term.append(self._vars_term[ll + 1])\n                self._solver.cnstr_count(inds_pri_or_term, True, 1, 1, None)\n\n            # everything is either the same or part of a change\n            for rr in range(self._rows):\n                for cc in range(self._cols):\n                    for ss in self._states:\n                        vv0 = self._vars_lrct[(ll + 0, rr, cc, ss)]\n                        vv1 = self._vars_lrct[(ll + 1, rr, cc, ss)]\n                        self._solver.cnstr_implies_disj(vv0, True, [vv1] + all_changes_rc[(rr, cc)], True, None)\n                        # TODO needed?\n                        self._solver.cnstr_implies_disj(vv0, False, [vv1] + all_changes_rc[(rr, cc)], [False] + [True] * len(all_changes_rc[(rr, cc)]), None)\n\n        if mkiii_info.custom:\n            mkiii_info.custom(CustomInfo(self._solver, self._rng, self._vars_lrct, self._rows, self._cols, self._layers))\n\n    def get_result(self):\n        result_info = super().get_result()\n        result_info.execution_info = self._get_execution()\n        return result_info\n\n    def _get_execution(self):\n        pi = util.ResultExecutionInfo()\n        pi.levels = []\n        pi.names = []\n        pi.changes = []\n        pi.term = []\n        pi.first_term = []\n\n        if not self._group_names:\n            pi.names = [None] * self._layers\n        else:\n            pi.names.append('initial')\n\n            for ll in range(self._layers - 1):\n                if self._vars_pri is not None: # RR_ORD_PRI\n                    inds_pri = self._vars_pri[ll]\n                    util.check(len(inds_pri) == len(self._group_names), 'pri and name length mismatch')\n                    pri_name = None\n                    for vv, name in zip(inds_pri, self._group_names):\n                        if self._solver.get_var(vv):\n                            util.check(pri_name is None, 'multiple pri set')\n                            pri_name = name\n                    if pri_name is None:\n                        pri_name = 'none'\n                    pi.names.append(pri_name)\n                else: # RR_ORD_SEQ, RR_ORD_ONE\n                    pi.names.append(self._group_names[ll % len(self._group_names)])\n\n        for ll in range(self._layers):\n            changes = []\n            for cvvs, crcs in self._change_vars_rcs[ll]:\n                changed = True\n                for vv in cvvs:\n                    if not self._solver.get_var(vv):\n                        changed = False\n                if changed:\n                    changes.append(crcs)\n            pi.changes.append(changes)\n\n            level = []\n            for rr in range(self._rows):\n                level_row = []\n                for cc in range(self._cols):\n                    use_ss = None\n                    for ss in self._states:\n                        vv = self._vars_lrct[(ll, rr, cc, ss)]\n                        if self._solver.get_var(vv):\n                            util.check(use_ss is None, 'multiple states set')\n                            use_ss = ss\n                    util.check(use_ss is not None, 'no state set')\n                    level_row.append(use_ss)\n                level.append(level_row)\n            pi.levels.append(level)\n\n            if self._vars_term is None or ll == 0:\n                pi.term.append(None)\n                pi.first_term.append(None)\n\n            else:\n                prev_term = False if ll == 1 else self._solver.get_var(self._vars_term[ll - 1])\n                curr_term = self._solver.get_var(self._vars_term[ll])\n\n                if prev_term:\n                    util.check(curr_term, 'term unset')\n\n                pi.term.append(curr_term)\n\n                if curr_term and not prev_term:\n                    pi.first_term.append(True)\n                else:\n                    pi.first_term.append(False)\n\n        return pi", ""]}
{"filename": "pathed.py", "chunked_list": ["import argparse, hashlib, io, math, multiprocessing, os, pickle, random, sys, time\nimport custom, reach, scheme2output, solvers, util, util_path\nimport PIL.Image, PIL.ImageTk\nimport tkinter\n\nWEIGHT_PATH    =  100\nWEIGHT_PATTERN = None\nWEIGHT_COUNTS  =    1\n\nINSET          =   10", "\nINSET          =   10\nCELL_SIZE      =   25\nFRAME          =    5\n\nLEVEL_COUNT    =  128\n\nREFRESH_MSEC   =   50\nPATH_DELAY_SEC =    1.0\n\ndef tocvs(x):\n    return (x * CELL_SIZE) + INSET", "PATH_DELAY_SEC =    1.0\n\ndef tocvs(x):\n    return (x * CELL_SIZE) + INSET\n\ndef fromcvs(x):\n    return (x - INSET) / CELL_SIZE\n\ndef encode_result_info(result_info, want_image):\n    if result_info is None:\n        return None\n\n    if not want_image:\n        result_info.image_level = None\n    elif result_info.image_level is not None:\n        bytes_io = io.BytesIO()\n        result_info.image_level.convert('RGB').save(bytes_io, 'png')\n        bytes_io.flush()\n        bytes_io.seek(0)\n        result_info.image_level = bytes_io.read()\n\n    return result_info", "def encode_result_info(result_info, want_image):\n    if result_info is None:\n        return None\n\n    if not want_image:\n        result_info.image_level = None\n    elif result_info.image_level is not None:\n        bytes_io = io.BytesIO()\n        result_info.image_level.convert('RGB').save(bytes_io, 'png')\n        bytes_io.flush()\n        bytes_io.seek(0)\n        result_info.image_level = bytes_io.read()\n\n    return result_info", "\ndef decode_result_info(result_info):\n    if result_info is None:\n        return None\n\n    if result_info.image_level is not None:\n        result_info.image_level = PIL.Image.open(io.BytesIO(result_info.image_level))\n\n    return result_info\n\nclass PathCanvas(tkinter.Canvas):\n    def __init__(self, root, rows, cols, move_template, schemefile, outfolder):\n        super().__init__(root, width=cols*CELL_SIZE+2*INSET-FRAME, height=rows*CELL_SIZE+2*INSET-FRAME)\n\n        self._rows = rows\n        self._cols = cols\n\n        self._seed_gen = 0\n        self._seed_rand_path = 0\n        self._reverse = False\n\n        self._move_template = move_template\n        self._template_open_closed = util_path.get_template_open_closed(reach.get_move_template(self._move_template))\n\n        self._schemefile = schemefile\n        self._outfolder = outfolder\n\n        self._path_open = {}\n        self._path_closed = {}\n        self._path_nexts = None\n\n        self._working_draw = []\n        self._gen_objective = None\n\n        self._mouse = None\n        self._draw_open_closed = False\n        self._mouse_draw = []\n\n        self._path = []\n        self._gen_path = []\n        self._path_draw = []\n\n        self._grid_draw = []\n\n        self._gen_image = None\n        self._gen_text = None\n        self._image_draw = []\n\n        self._gen_proc = None\n        self._gen_proc_wanted = None\n        self._gen_proc_termed = False\n        self._gen_proc_q = None\n\n        self.bind_all(\"<BackSpace>\", self.on_key_backspace)\n        self.bind_all(\"<KeyPress-=>\", self.on_key_equal)\n        self.bind_all(\"<KeyPress-c>\", self.on_key_c)\n        self.bind_all(\"<KeyPress-x>\", self.on_key_x)\n        self.bind_all(\"<KeyPress-p>\", self.on_key_p)\n        self.bind_all(\"<KeyPress-n>\", self.on_key_n)\n        self.bind_all(\"<KeyPress-b>\", self.on_key_b)\n        self.bind_all(\"<KeyPress-o>\", self.on_key_o)\n        self.bind_all(\"<KeyPress-r>\", self.on_key_r)\n        self.bind_all(\"<KeyPress-s>\", self.on_key_s)\n        self.bind_all(\"<KeyPress-w>\", self.on_key_w)\n        self.bind(\"<Motion>\", self.on_mouse_motion)\n        self.bind(\"<Leave>\", self.on_mouse_leave)\n        self.bind(\"<ButtonPress-1>\", self.on_mouse_button)\n        self.after(REFRESH_MSEC, self.on_timer)\n\n        self.pack()\n\n        self.redraw_from_image()\n\n    def restart_gen_proc(self, delay):\n        if self._schemefile:\n            self._gen_proc_wanted = time.time() + delay\n\n    @staticmethod\n    def gen_proc_body(q, rows, cols, seed, start_goal, path_points, move_template, schemefile, want_image, outfile):\n        util.timer_start(False)\n\n        if outfile is not None:\n            outfile_file = util.openz(outfile + '.log', 'wt')\n            sys.stdout = outfile_file\n\n        with util.openz(schemefile, 'rb') as f:\n            scheme_info = pickle.load(f)\n\n        tag_game_level = util.make_grid(rows, cols, util.DEFAULT_TEXT)\n        solver = solvers.PySatSolverRC2()\n\n        reach_setup = util.ReachabilitySetup()\n        reach_setup.wrap_cols = False\n        reach_setup.open_text = util.OPEN_TEXT\n        reach_setup.game_to_move = { util.DEFAULT_TEXT: move_template }\n        reach_setup.goal_loc = reach.RGOAL_ALL\n        reach_setup.goal_params = []\n\n        custom_cnstrs = []\n        if start_goal is not None:\n            custom_cnstrs.append(custom.OutPathEndsConstraint(start_goal[0], start_goal[1], start_goal[2], start_goal[3], WEIGHT_PATH))\n        if path_points is not None:\n            custom_cnstrs.append(custom.OutPathConstraint(path_points, WEIGHT_PATH))\n\n        result_info = scheme2output.scheme2output(scheme_info, tag_game_level, tag_game_level, solver, seed, WEIGHT_PATTERN, WEIGHT_COUNTS, scheme2output.COUNTS_SCALE_HALF, reach_setup, None, custom_cnstrs, False)\n\n        if outfile is not None and result_info is not None:\n            print('saving to', outfile)\n            util.save_result_info(result_info, outfile)\n\n        encode_result_info(result_info, want_image)\n        q.put(result_info)\n\n        if result_info:\n            util.exit_solution_found()\n        else:\n            util.exit_solution_not_found()\n\n    def on_timer(self):\n        if self._gen_proc is not None:\n            if not self._gen_proc.is_alive():\n                if self._gen_proc_termed:\n                    print('proc termed')\n                elif self._gen_proc.exitcode != 0:\n                    print('proc error')\n                else:\n                    print('proc done')\n\n                    result_info = self._gen_proc_q.get()\n                    decode_result_info(result_info)\n\n                    if result_info is not None:\n                        print(result_info.reach_info.path_edges)\n\n                        if result_info.image_level is None:\n                            self._gen_image = None\n                        else:\n                            self._gen_image = PIL.ImageTk.PhotoImage(result_info.image_level.resize((self._cols * CELL_SIZE, self._rows * CELL_SIZE), PIL.Image.Resampling.BILINEAR))\n                        self._gen_text = result_info.text_level\n                        self._gen_path = util_path.point_path_from_edge_path(result_info.reach_info.path_edges)\n                        self._gen_objective = result_info.objective\n\n                    self.redraw_from_image()\n                self._gen_proc = None\n\n        if self._gen_proc_wanted is not None:\n            if self._gen_proc is not None:\n                if self._gen_proc.is_alive():\n                    print('terminating proc')\n                    self._gen_proc_termed = True\n                    self._gen_proc.terminate()\n\n            elif time.time() >= self._gen_proc_wanted:\n                self._gen_proc_wanted = None\n                self._gen_proc_termed = False\n\n                if len(self._path) > 0:\n                    print('starting proc')\n\n                    if self._outfolder is None:\n                        outfile = None\n                    else:\n                        outfile = os.path.join(self._outfolder, hashlib.md5(str(self._path).encode('utf-8')).hexdigest() + ('_%04d' % self._seed_gen))\n\n                    self._gen_proc_q = multiprocessing.Queue()\n                    self._gen_proc = multiprocessing.Process(target=self.gen_proc_body, args=(self._gen_proc_q, self._rows, self._cols, self._seed_gen, None, self._path, self._move_template, self._schemefile, True, outfile))\n                    self._gen_proc.start()\n                else:\n                    print('empty path')\n                    self._gen_image = None\n                    self._gen_text = None\n                    self._gen_path = []\n                    self._gen_objective = None\n                    self.redraw_from_image()\n\n        self.redraw_from_working()\n        self.after(REFRESH_MSEC, self.on_timer)\n\n    def redraw_from_working(self):\n        for draw in self._working_draw:\n            self.delete(draw)\n        self._working_draw = []\n\n        if self._gen_path != self._path:\n            self._working_draw.append(self.create_line(tocvs(0.65), tocvs(0.65), tocvs(1.35), tocvs(1.35), fill='purple', width=3))\n            self._working_draw.append(self.create_line(tocvs(1.35), tocvs(0.65), tocvs(0.65), tocvs(1.35), fill='purple', width=3))\n\n        if self._gen_proc is not None:\n            self._working_draw.append(self.create_arc(tocvs(0.5), tocvs(0.5), tocvs(1.5), tocvs(1.5), outline='purple', width=3, style=tkinter.ARC, start=time.time() * 45.0, extent=300.0))\n\n    def redraw_from_mouse(self):\n        for draw in self._mouse_draw:\n            self.delete(draw)\n        self._mouse_draw = []\n\n        if self._mouse is not None:\n            mr, mc = self._mouse\n\n            if self._path_nexts is None or self._mouse in self._path_nexts:\n                self._mouse_draw.append(self.create_rectangle(tocvs(mc), tocvs(mr), tocvs(mc + 1), tocvs(mr + 1), outline='green', width=3))\n            else:\n                self._mouse_draw.append(self.create_rectangle(tocvs(mc), tocvs(mr), tocvs(mc + 1), tocvs(mr + 1), outline='gray', width=3))\n\n        self.redraw_from_working()\n\n    def _do_draw_path(self, points, larger, color, dash):\n        if larger:\n            outline_color = color\n            width = 3\n        else:\n            outline_color = ''\n            width = 2\n\n        if len(points) > 1:\n            draw_line = []\n            for pr, pc in points:\n                draw_line.append(tocvs(pc + 0.5))\n                draw_line.append(tocvs(pr + 0.5))\n            self._path_draw.append(self.create_line(*draw_line, fill=color, width=width, dash=dash))\n\n            for (pr0, pc0, pr1, pc1) in util_path.edge_path_from_point_path(points):\n                pr0 += 0.5\n                pc0 += 0.5\n                pr1 += 0.5\n                pc1 += 0.5\n                dr = pr1 - pr0\n                dc = pc1 - pc0\n                ll = (dr ** 2 + dc ** 2) ** 0.5\n                dr /= ll\n                dc /= ll\n                SCL = 0.3\n                OFF = 0.075\n                tra = pr1 - OFF * dr\n                tca = pc1 - OFF * dc\n                trb = (pr1 - dr * SCL - 0.5 * dc * SCL) - OFF * dr\n                tcb = (pc1 - dc * SCL + 0.5 * dr * SCL) - OFF * dc\n                trc = (pr1 - dr * SCL + 0.5 * dc * SCL) - OFF * dr\n                tcc = (pc1 - dc * SCL - 0.5 * dr * SCL) - OFF * dc\n                self._path_draw.append(self.create_polygon([tocvs(tca), tocvs(tra), tocvs(tcb), tocvs(trb), tocvs(tcc), tocvs(trc)], fill=color, outline=outline_color, width=width))\n\n        draw_ends = []\n        if len(points) > 0:\n            draw_ends.append(points[0])\n        if len(points) > 1:\n            draw_ends.append(points[-1])\n        for pr, pc in draw_ends:\n            sz = 0.15\n            self._path_draw.append(self.create_oval(tocvs(pc + (0.5 - sz)), tocvs(pr + (0.5 - sz)), tocvs(pc + (0.5 + sz)), tocvs(pr + (0.5 + sz)), fill=color, outline=outline_color, width=width))\n\n    def redraw_from_path(self):\n        for draw in self._path_draw:\n            self.delete(draw)\n        self._path_draw = []\n\n        if self._draw_open_closed:\n            for nr, nc in self._path_open:\n                self._path_draw.append(self.create_oval(tocvs(nc + 0.25), tocvs(nr + 0.25), tocvs(nc + 0.75), tocvs(nr + 0.75), outline='blue', width=2))\n            for nr, nc in self._path_closed:\n                self._path_draw.append(self.create_rectangle(tocvs(nc + 0.25), tocvs(nr + 0.25), tocvs(nc + 0.75), tocvs(nr + 0.75), outline='blue', width=2))\n\n        self._do_draw_path(self._gen_path, True, 'red', None)\n        self._do_draw_path(self._path, False, 'pink', (3, 3))\n\n        if self._path_nexts is not None:\n            for nr, nc in self._path_nexts:\n                self._path_draw.append(self.create_rectangle(tocvs(nc), tocvs(nr), tocvs(nc + 1), tocvs(nr + 1), outline='black', width=3))\n\n        self.redraw_from_mouse()\n\n    def redraw_from_grid(self):\n        for draw in self._grid_draw:\n            self.delete(draw)\n        self._grid_draw = []\n\n        for rr in range(self._rows + 1):\n            self._grid_draw.append(self.create_line(tocvs(0), tocvs(rr), tocvs(self._cols), tocvs(rr), fill='gray'))\n        for cc in range(self._cols + 1):\n            self._grid_draw.append(self.create_line(tocvs(cc), tocvs(0), tocvs(cc), tocvs(self._rows), fill='gray'))\n\n        self.redraw_from_path()\n\n    def redraw_from_image(self):\n        for draw in self._image_draw:\n            self.delete(draw)\n        self._image_draw = []\n\n        if self._gen_image is None:\n            self._image_draw.append(self.create_rectangle(tocvs(0), tocvs(0), tocvs(self._cols), tocvs(self._rows), outline=None, fill='white'))\n        else:\n            self._image_draw.append(self.create_image(INSET, INSET, anchor=tkinter.NW, image=self._gen_image))\n\n        self.redraw_from_grid()\n\n    def recompute_nexts(self):\n        self._path_nexts, self._path_open, self._path_closed = util_path.get_nexts_open_closed_from(self._path, self._reverse, self._rows, self._cols, self._template_open_closed)\n        self.redraw_from_path()\n\n    def new_manual_path(self, delay_proc):\n        self.recompute_nexts()\n        self.restart_gen_proc(PATH_DELAY_SEC if delay_proc else 0.0)\n\n    def on_key_backspace(self, event):\n        if len(self._path) > 0:\n            self._path = self._path[:-1]\n            self.new_manual_path(True)\n\n    def on_key_equal(self, event):\n        if len(self._path) > 0:\n            self._path = self._path[1:]\n            self.new_manual_path(True)\n\n    def on_key_x(self, event):\n        if self._schemefile:\n            self._path = []\n            self.new_manual_path(True)\n\n    def on_key_p(self, event):\n        self._reverse = not self._reverse\n        self.recompute_nexts()\n\n    def on_key_c(self, event):\n        if self._schemefile:\n            self._path = self._gen_path\n            self.new_manual_path(True)\n\n    def on_key_b(self, event):\n        self._seed_gen = (self._seed_gen + LEVEL_COUNT - 1) % LEVEL_COUNT\n        self.new_manual_path(False)\n\n    def on_key_n(self, event):\n        self._seed_gen = (self._seed_gen + 1) % LEVEL_COUNT\n        self.new_manual_path(False)\n\n    def on_key_o(self, event):\n        self._draw_open_closed = not self._draw_open_closed\n        self.redraw_from_path()\n\n    def on_key_r(self, event):\n        self._seed_rand_path += 1\n        rng = random.Random(self._seed_rand_path)\n        self._path = util_path.random_path_by_search(rng, self._rows, self._cols, self._template_open_closed)\n        self.new_manual_path(False)\n\n    def on_key_s(self, event):\n        if len(self._path) >= 2:\n            self._path = util_path.shortest_path_between(self._path[0], self._path[-1], self._rows, self._cols, self._template_open_closed, {}, {})\n            self.new_manual_path(False)\n\n    def on_key_w(self, event):\n        if self._gen_path is not None and len(self._gen_path) >= 2:\n            are_open, are_closed = util_path.get_level_open_closed(self._gen_text, util.OPEN_TEXT)\n            self._path = util_path.shortest_path_between(self._gen_path[0], self._gen_path[-1], self._rows, self._cols, self._template_open_closed, are_open, are_closed)\n            self.new_manual_path(False)\n\n    def on_mouse_motion(self, event):\n        mr, mc = math.floor(fromcvs(event.y)), math.floor(fromcvs(event.x))\n        if 0 <= mr and mr < self._rows and 0 <= mc and mc < self._cols:\n            self._mouse = (mr, mc)\n        else:\n            self._mouse = None\n        self.redraw_from_mouse()\n\n    def on_mouse_leave(self, event):\n        self._mouse = None\n        self.redraw_from_mouse()\n\n    def on_mouse_button(self, event):\n        if self._mouse is not None:\n            if self._path_nexts is None or self._mouse in self._path_nexts:\n                if not self._reverse:\n                    self._path.append(self._mouse)\n                else:\n                    self._path.insert(0, self._mouse)\n                self.new_manual_path(True)", "\nclass PathCanvas(tkinter.Canvas):\n    def __init__(self, root, rows, cols, move_template, schemefile, outfolder):\n        super().__init__(root, width=cols*CELL_SIZE+2*INSET-FRAME, height=rows*CELL_SIZE+2*INSET-FRAME)\n\n        self._rows = rows\n        self._cols = cols\n\n        self._seed_gen = 0\n        self._seed_rand_path = 0\n        self._reverse = False\n\n        self._move_template = move_template\n        self._template_open_closed = util_path.get_template_open_closed(reach.get_move_template(self._move_template))\n\n        self._schemefile = schemefile\n        self._outfolder = outfolder\n\n        self._path_open = {}\n        self._path_closed = {}\n        self._path_nexts = None\n\n        self._working_draw = []\n        self._gen_objective = None\n\n        self._mouse = None\n        self._draw_open_closed = False\n        self._mouse_draw = []\n\n        self._path = []\n        self._gen_path = []\n        self._path_draw = []\n\n        self._grid_draw = []\n\n        self._gen_image = None\n        self._gen_text = None\n        self._image_draw = []\n\n        self._gen_proc = None\n        self._gen_proc_wanted = None\n        self._gen_proc_termed = False\n        self._gen_proc_q = None\n\n        self.bind_all(\"<BackSpace>\", self.on_key_backspace)\n        self.bind_all(\"<KeyPress-=>\", self.on_key_equal)\n        self.bind_all(\"<KeyPress-c>\", self.on_key_c)\n        self.bind_all(\"<KeyPress-x>\", self.on_key_x)\n        self.bind_all(\"<KeyPress-p>\", self.on_key_p)\n        self.bind_all(\"<KeyPress-n>\", self.on_key_n)\n        self.bind_all(\"<KeyPress-b>\", self.on_key_b)\n        self.bind_all(\"<KeyPress-o>\", self.on_key_o)\n        self.bind_all(\"<KeyPress-r>\", self.on_key_r)\n        self.bind_all(\"<KeyPress-s>\", self.on_key_s)\n        self.bind_all(\"<KeyPress-w>\", self.on_key_w)\n        self.bind(\"<Motion>\", self.on_mouse_motion)\n        self.bind(\"<Leave>\", self.on_mouse_leave)\n        self.bind(\"<ButtonPress-1>\", self.on_mouse_button)\n        self.after(REFRESH_MSEC, self.on_timer)\n\n        self.pack()\n\n        self.redraw_from_image()\n\n    def restart_gen_proc(self, delay):\n        if self._schemefile:\n            self._gen_proc_wanted = time.time() + delay\n\n    @staticmethod\n    def gen_proc_body(q, rows, cols, seed, start_goal, path_points, move_template, schemefile, want_image, outfile):\n        util.timer_start(False)\n\n        if outfile is not None:\n            outfile_file = util.openz(outfile + '.log', 'wt')\n            sys.stdout = outfile_file\n\n        with util.openz(schemefile, 'rb') as f:\n            scheme_info = pickle.load(f)\n\n        tag_game_level = util.make_grid(rows, cols, util.DEFAULT_TEXT)\n        solver = solvers.PySatSolverRC2()\n\n        reach_setup = util.ReachabilitySetup()\n        reach_setup.wrap_cols = False\n        reach_setup.open_text = util.OPEN_TEXT\n        reach_setup.game_to_move = { util.DEFAULT_TEXT: move_template }\n        reach_setup.goal_loc = reach.RGOAL_ALL\n        reach_setup.goal_params = []\n\n        custom_cnstrs = []\n        if start_goal is not None:\n            custom_cnstrs.append(custom.OutPathEndsConstraint(start_goal[0], start_goal[1], start_goal[2], start_goal[3], WEIGHT_PATH))\n        if path_points is not None:\n            custom_cnstrs.append(custom.OutPathConstraint(path_points, WEIGHT_PATH))\n\n        result_info = scheme2output.scheme2output(scheme_info, tag_game_level, tag_game_level, solver, seed, WEIGHT_PATTERN, WEIGHT_COUNTS, scheme2output.COUNTS_SCALE_HALF, reach_setup, None, custom_cnstrs, False)\n\n        if outfile is not None and result_info is not None:\n            print('saving to', outfile)\n            util.save_result_info(result_info, outfile)\n\n        encode_result_info(result_info, want_image)\n        q.put(result_info)\n\n        if result_info:\n            util.exit_solution_found()\n        else:\n            util.exit_solution_not_found()\n\n    def on_timer(self):\n        if self._gen_proc is not None:\n            if not self._gen_proc.is_alive():\n                if self._gen_proc_termed:\n                    print('proc termed')\n                elif self._gen_proc.exitcode != 0:\n                    print('proc error')\n                else:\n                    print('proc done')\n\n                    result_info = self._gen_proc_q.get()\n                    decode_result_info(result_info)\n\n                    if result_info is not None:\n                        print(result_info.reach_info.path_edges)\n\n                        if result_info.image_level is None:\n                            self._gen_image = None\n                        else:\n                            self._gen_image = PIL.ImageTk.PhotoImage(result_info.image_level.resize((self._cols * CELL_SIZE, self._rows * CELL_SIZE), PIL.Image.Resampling.BILINEAR))\n                        self._gen_text = result_info.text_level\n                        self._gen_path = util_path.point_path_from_edge_path(result_info.reach_info.path_edges)\n                        self._gen_objective = result_info.objective\n\n                    self.redraw_from_image()\n                self._gen_proc = None\n\n        if self._gen_proc_wanted is not None:\n            if self._gen_proc is not None:\n                if self._gen_proc.is_alive():\n                    print('terminating proc')\n                    self._gen_proc_termed = True\n                    self._gen_proc.terminate()\n\n            elif time.time() >= self._gen_proc_wanted:\n                self._gen_proc_wanted = None\n                self._gen_proc_termed = False\n\n                if len(self._path) > 0:\n                    print('starting proc')\n\n                    if self._outfolder is None:\n                        outfile = None\n                    else:\n                        outfile = os.path.join(self._outfolder, hashlib.md5(str(self._path).encode('utf-8')).hexdigest() + ('_%04d' % self._seed_gen))\n\n                    self._gen_proc_q = multiprocessing.Queue()\n                    self._gen_proc = multiprocessing.Process(target=self.gen_proc_body, args=(self._gen_proc_q, self._rows, self._cols, self._seed_gen, None, self._path, self._move_template, self._schemefile, True, outfile))\n                    self._gen_proc.start()\n                else:\n                    print('empty path')\n                    self._gen_image = None\n                    self._gen_text = None\n                    self._gen_path = []\n                    self._gen_objective = None\n                    self.redraw_from_image()\n\n        self.redraw_from_working()\n        self.after(REFRESH_MSEC, self.on_timer)\n\n    def redraw_from_working(self):\n        for draw in self._working_draw:\n            self.delete(draw)\n        self._working_draw = []\n\n        if self._gen_path != self._path:\n            self._working_draw.append(self.create_line(tocvs(0.65), tocvs(0.65), tocvs(1.35), tocvs(1.35), fill='purple', width=3))\n            self._working_draw.append(self.create_line(tocvs(1.35), tocvs(0.65), tocvs(0.65), tocvs(1.35), fill='purple', width=3))\n\n        if self._gen_proc is not None:\n            self._working_draw.append(self.create_arc(tocvs(0.5), tocvs(0.5), tocvs(1.5), tocvs(1.5), outline='purple', width=3, style=tkinter.ARC, start=time.time() * 45.0, extent=300.0))\n\n    def redraw_from_mouse(self):\n        for draw in self._mouse_draw:\n            self.delete(draw)\n        self._mouse_draw = []\n\n        if self._mouse is not None:\n            mr, mc = self._mouse\n\n            if self._path_nexts is None or self._mouse in self._path_nexts:\n                self._mouse_draw.append(self.create_rectangle(tocvs(mc), tocvs(mr), tocvs(mc + 1), tocvs(mr + 1), outline='green', width=3))\n            else:\n                self._mouse_draw.append(self.create_rectangle(tocvs(mc), tocvs(mr), tocvs(mc + 1), tocvs(mr + 1), outline='gray', width=3))\n\n        self.redraw_from_working()\n\n    def _do_draw_path(self, points, larger, color, dash):\n        if larger:\n            outline_color = color\n            width = 3\n        else:\n            outline_color = ''\n            width = 2\n\n        if len(points) > 1:\n            draw_line = []\n            for pr, pc in points:\n                draw_line.append(tocvs(pc + 0.5))\n                draw_line.append(tocvs(pr + 0.5))\n            self._path_draw.append(self.create_line(*draw_line, fill=color, width=width, dash=dash))\n\n            for (pr0, pc0, pr1, pc1) in util_path.edge_path_from_point_path(points):\n                pr0 += 0.5\n                pc0 += 0.5\n                pr1 += 0.5\n                pc1 += 0.5\n                dr = pr1 - pr0\n                dc = pc1 - pc0\n                ll = (dr ** 2 + dc ** 2) ** 0.5\n                dr /= ll\n                dc /= ll\n                SCL = 0.3\n                OFF = 0.075\n                tra = pr1 - OFF * dr\n                tca = pc1 - OFF * dc\n                trb = (pr1 - dr * SCL - 0.5 * dc * SCL) - OFF * dr\n                tcb = (pc1 - dc * SCL + 0.5 * dr * SCL) - OFF * dc\n                trc = (pr1 - dr * SCL + 0.5 * dc * SCL) - OFF * dr\n                tcc = (pc1 - dc * SCL - 0.5 * dr * SCL) - OFF * dc\n                self._path_draw.append(self.create_polygon([tocvs(tca), tocvs(tra), tocvs(tcb), tocvs(trb), tocvs(tcc), tocvs(trc)], fill=color, outline=outline_color, width=width))\n\n        draw_ends = []\n        if len(points) > 0:\n            draw_ends.append(points[0])\n        if len(points) > 1:\n            draw_ends.append(points[-1])\n        for pr, pc in draw_ends:\n            sz = 0.15\n            self._path_draw.append(self.create_oval(tocvs(pc + (0.5 - sz)), tocvs(pr + (0.5 - sz)), tocvs(pc + (0.5 + sz)), tocvs(pr + (0.5 + sz)), fill=color, outline=outline_color, width=width))\n\n    def redraw_from_path(self):\n        for draw in self._path_draw:\n            self.delete(draw)\n        self._path_draw = []\n\n        if self._draw_open_closed:\n            for nr, nc in self._path_open:\n                self._path_draw.append(self.create_oval(tocvs(nc + 0.25), tocvs(nr + 0.25), tocvs(nc + 0.75), tocvs(nr + 0.75), outline='blue', width=2))\n            for nr, nc in self._path_closed:\n                self._path_draw.append(self.create_rectangle(tocvs(nc + 0.25), tocvs(nr + 0.25), tocvs(nc + 0.75), tocvs(nr + 0.75), outline='blue', width=2))\n\n        self._do_draw_path(self._gen_path, True, 'red', None)\n        self._do_draw_path(self._path, False, 'pink', (3, 3))\n\n        if self._path_nexts is not None:\n            for nr, nc in self._path_nexts:\n                self._path_draw.append(self.create_rectangle(tocvs(nc), tocvs(nr), tocvs(nc + 1), tocvs(nr + 1), outline='black', width=3))\n\n        self.redraw_from_mouse()\n\n    def redraw_from_grid(self):\n        for draw in self._grid_draw:\n            self.delete(draw)\n        self._grid_draw = []\n\n        for rr in range(self._rows + 1):\n            self._grid_draw.append(self.create_line(tocvs(0), tocvs(rr), tocvs(self._cols), tocvs(rr), fill='gray'))\n        for cc in range(self._cols + 1):\n            self._grid_draw.append(self.create_line(tocvs(cc), tocvs(0), tocvs(cc), tocvs(self._rows), fill='gray'))\n\n        self.redraw_from_path()\n\n    def redraw_from_image(self):\n        for draw in self._image_draw:\n            self.delete(draw)\n        self._image_draw = []\n\n        if self._gen_image is None:\n            self._image_draw.append(self.create_rectangle(tocvs(0), tocvs(0), tocvs(self._cols), tocvs(self._rows), outline=None, fill='white'))\n        else:\n            self._image_draw.append(self.create_image(INSET, INSET, anchor=tkinter.NW, image=self._gen_image))\n\n        self.redraw_from_grid()\n\n    def recompute_nexts(self):\n        self._path_nexts, self._path_open, self._path_closed = util_path.get_nexts_open_closed_from(self._path, self._reverse, self._rows, self._cols, self._template_open_closed)\n        self.redraw_from_path()\n\n    def new_manual_path(self, delay_proc):\n        self.recompute_nexts()\n        self.restart_gen_proc(PATH_DELAY_SEC if delay_proc else 0.0)\n\n    def on_key_backspace(self, event):\n        if len(self._path) > 0:\n            self._path = self._path[:-1]\n            self.new_manual_path(True)\n\n    def on_key_equal(self, event):\n        if len(self._path) > 0:\n            self._path = self._path[1:]\n            self.new_manual_path(True)\n\n    def on_key_x(self, event):\n        if self._schemefile:\n            self._path = []\n            self.new_manual_path(True)\n\n    def on_key_p(self, event):\n        self._reverse = not self._reverse\n        self.recompute_nexts()\n\n    def on_key_c(self, event):\n        if self._schemefile:\n            self._path = self._gen_path\n            self.new_manual_path(True)\n\n    def on_key_b(self, event):\n        self._seed_gen = (self._seed_gen + LEVEL_COUNT - 1) % LEVEL_COUNT\n        self.new_manual_path(False)\n\n    def on_key_n(self, event):\n        self._seed_gen = (self._seed_gen + 1) % LEVEL_COUNT\n        self.new_manual_path(False)\n\n    def on_key_o(self, event):\n        self._draw_open_closed = not self._draw_open_closed\n        self.redraw_from_path()\n\n    def on_key_r(self, event):\n        self._seed_rand_path += 1\n        rng = random.Random(self._seed_rand_path)\n        self._path = util_path.random_path_by_search(rng, self._rows, self._cols, self._template_open_closed)\n        self.new_manual_path(False)\n\n    def on_key_s(self, event):\n        if len(self._path) >= 2:\n            self._path = util_path.shortest_path_between(self._path[0], self._path[-1], self._rows, self._cols, self._template_open_closed, {}, {})\n            self.new_manual_path(False)\n\n    def on_key_w(self, event):\n        if self._gen_path is not None and len(self._gen_path) >= 2:\n            are_open, are_closed = util_path.get_level_open_closed(self._gen_text, util.OPEN_TEXT)\n            self._path = util_path.shortest_path_between(self._gen_path[0], self._gen_path[-1], self._rows, self._cols, self._template_open_closed, are_open, are_closed)\n            self.new_manual_path(False)\n\n    def on_mouse_motion(self, event):\n        mr, mc = math.floor(fromcvs(event.y)), math.floor(fromcvs(event.x))\n        if 0 <= mr and mr < self._rows and 0 <= mc and mc < self._cols:\n            self._mouse = (mr, mc)\n        else:\n            self._mouse = None\n        self.redraw_from_mouse()\n\n    def on_mouse_leave(self, event):\n        self._mouse = None\n        self.redraw_from_mouse()\n\n    def on_mouse_button(self, event):\n        if self._mouse is not None:\n            if self._path_nexts is None or self._mouse in self._path_nexts:\n                if not self._reverse:\n                    self._path.append(self._mouse)\n                else:\n                    self._path.insert(0, self._mouse)\n                self.new_manual_path(True)", "\n\n\ndef pathed(rows, cols, reach_move, schemefile, outfolder):\n    root = tkinter.Tk()\n    root.title('pathed')\n\n    PathCanvas(root, rows, cols, reach_move, schemefile, outfolder)\n\n    root.mainloop()", "\n\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='Path editor.')\n\n    parser.add_argument('--size', required=True, type=int, nargs=2, help='Level size.')\n    parser.add_argument('--reach-move', required=True, type=str, help='Use reachability move rules, from: ' + ','.join(reach.RMOVE_LIST) + '.')\n    parser.add_argument('--schemefile', type=str, help='Input scheme file.')\n    parser.add_argument('--outfolder', type=str, help='Output folder.')\n\n    args = parser.parse_args()\n\n    pathed(args.size[0], args.size[1], args.reach_move, args.schemefile, args.outfolder)", ""]}
{"filename": "tag2game.py", "chunked_list": ["import argparse, math, pickle, pprint, random, sys, time\nimport util\n\n\n\ndef tag2game(tag_level, scheme_info, game_priority):\n    rows = len(tag_level)\n    cols = len(tag_level[0])\n\n    game_level = util.make_grid(rows, cols, util.DEFAULT_TEXT)\n\n    for rr in range(rows):\n        for cc in range(cols):\n            tag = tag_level[rr][cc]\n\n            found_game = False\n            for game in game_priority:\n                util.check(game in scheme_info.game_to_tag_to_tiles, 'game not in scheme info')\n                if tag in scheme_info.game_to_tag_to_tiles[game]:\n                    game_level[rr][cc] = game\n                    found_game = True\n                    break\n            util.check(found_game, 'tag ' + tag + ' not found in games')\n\n    return game_level", "\n\n\nif __name__ == '__main__':\n    util.timer_start()\n\n    parser = argparse.ArgumentParser(description='Generate game file from tag (and scheme) file.')\n    parser.add_argument('--outfile', required=True, type=str, help='Output game level file.')\n    parser.add_argument('--tagfile', required=True, type=str, help='Input tag level file.')\n    parser.add_argument('--schemefile', required=True, type=str, help='Input scheme level file.')\n    parser.add_argument('--game', required=True, type=str, nargs='+', help='Game priority.')\n    args = parser.parse_args()\n\n    tag_level = util.read_text_level(args.tagfile)\n\n    with util.openz(args.schemefile, 'rb') as f:\n        scheme_info = pickle.load(f)\n\n    game_level = tag2game(tag_level, scheme_info, args.game)\n    util.print_text_level(game_level)\n    with util.openz(args.outfile, 'wt') as f:\n        util.print_text_level(game_level, outfile=f)", ""]}
{"filename": "generator.py", "chunked_list": ["import argparse, math, pickle, pprint, random, sys, time\nimport solvers, util\n\n\n\nclass Generator:\n    def __init__(self, solver, randomize, rows, cols, scheme_info, tag_level, game_level):\n        super().__init__()\n\n        self._solver = solver\n        self._rng = random.Random(randomize) if randomize else None\n\n        self._extra_meta = []\n\n        self._rows = rows\n        self._cols = cols\n\n        self._scheme_info = scheme_info\n        self._tag_level = tag_level\n        self._game_level = game_level\n\n        self._vars_rc_t = {}\n        self._vars_pattern = {}\n\n        self._var_void_true = self._solver.make_var()\n        self._solver.cnstr_count([self._var_void_true], True, 1, 1, None)\n\n        self._reach_info = None\n        self._reach_vars_node = {}\n        self._reach_vars_edge = {}\n        self._reach_out_edges = None\n\n    def _tile_var(self, rr, cc, tile):\n        if (rr, cc) in self._vars_rc_t:\n            util.check(tile != util.VOID_TILE, 'void tile')\n            return self._vars_rc_t[(rr, cc)][tile]\n        else:\n            util.check(tile == util.VOID_TILE, 'void tile')\n            return self._var_void_true\n\n    def _tile_has_var(self, rr, cc, tile):\n        if (rr, cc) in self._vars_rc_t:\n            return tile in self._vars_rc_t[(rr, cc)]\n        else:\n            return tile == util.VOID_TILE\n\n    def _pattern_var(self, pattern):\n        util.check(len(pattern) > 0, 'empty pattern')\n\n        key = tuple(sorted(set(pattern)))\n\n        if key not in self._vars_pattern:\n            self._vars_pattern[key] = self._solver.make_conj([self._tile_var(pr, pc, ptile) for pr, pc, ptile in pattern], True)\n\n        return self._vars_pattern[key]\n\n    def get_rows(self):\n        return self._rows\n\n    def get_cols(self):\n        return self._cols\n\n    def get_scheme_info(self):\n        return self._scheme_info\n\n    def append_extra_meta(self, meta):\n        self._extra_meta += meta\n\n    def add_rules_tiles(self):\n        print('add tile constraints')\n\n        row_order = list(range(self._rows))\n        col_order = list(range(self._cols))\n\n        if self._rng:\n            self._rng.shuffle(row_order)\n            self._rng.shuffle(col_order)\n\n        for rr in row_order:\n            for cc in col_order:\n                tag = self._tag_level[rr][cc]\n                game = self._game_level[rr][cc]\n\n                if tag == util.VOID_TEXT:\n                    continue\n\n                tiles = list(self._scheme_info.game_to_tag_to_tiles[game][tag].keys())\n                util.check(util.VOID_TILE not in tiles, 'void tile')\n\n                if self._rng:\n                    self._rng.shuffle(tiles)\n\n                self._vars_rc_t[(rr, cc)] = {}\n                for tile in tiles:\n                    self._vars_rc_t[(rr, cc)][tile] = self._solver.make_var()\n\n                vvs = list(self._vars_rc_t[(rr, cc)].values())\n\n                self._solver.cnstr_count(vvs, True, 1, 1, None)\n\n    def add_rules_patterns(self, weight_patterns):\n        print('add pattern constraints', weight_patterns)\n\n        util.check(weight_patterns is None or weight_patterns > 0, 'weight')\n\n        def add_tile_patterns(_pattern_in, _pattern_out_list):\n            _pattern_in_var = self._pattern_var(_pattern_in)\n\n            if len(_pattern_out_list) == 0:\n                self._solver.cnstr_count([_pattern_in_var], True, 0, 0, weight_patterns)\n\n            else:\n                _pattern_out_vars = [self._pattern_var(_pattern_out) for _pattern_out in _pattern_out_list]\n                self._solver.cnstr_implies_disj(_pattern_in_var, True, _pattern_out_vars, True, weight_patterns)\n\n        def add_pattern_options(_patterns):\n            _pattern_vars = [self._pattern_var(_pattern) for _pattern in _patterns]\n            self._solver.cnstr_count(_pattern_vars, True, 1, len(_pattern_vars), weight_patterns)\n\n        if self._scheme_info.pattern_info.stride_rows == 0:\n            util.check(0 == self._scheme_info.pattern_info.dr_lo and self._rows == self._scheme_info.pattern_info.dr_hi + 1, 'rows do not stride and row count does not start at 0 or does not match')\n        if self._scheme_info.pattern_info.stride_cols == 0:\n            util.check(0 == self._scheme_info.pattern_info.dc_lo and self._cols == self._scheme_info.pattern_info.dc_hi + 1, 'cols do not stride and col count does not start at 0 or does not match')\n\n        row_range = range(-self._scheme_info.pattern_info.dr_hi, self._rows - self._scheme_info.pattern_info.dr_lo, self._scheme_info.pattern_info.stride_rows) if self._scheme_info.pattern_info.stride_rows else [0]\n        col_range = range(-self._scheme_info.pattern_info.dc_hi, self._cols - self._scheme_info.pattern_info.dc_lo, self._scheme_info.pattern_info.stride_cols) if self._scheme_info.pattern_info.stride_cols else [0]\n\n        def pattern_inst(_pattern_template, _pattern):\n            _inst = []\n            for (_dr, _dc), _ptile in zip(_pattern_template, _pattern):\n                _nr = rr + _dr\n                _nc = cc + _dc\n\n                _nbr_tag = util.VOID_TEXT if (_nr <= -1 or _nr >= self._rows or _nc <= -1 or _nc >= self._cols) else self._tag_level[_nr][_nc]\n\n                if _nbr_tag == util.VOID_TEXT:\n                    if _ptile != util.VOID_TILE:\n                        return None\n                else:\n                    if _ptile not in self._vars_rc_t[(_nr, _nc)]:\n                        return None\n\n                _inst.append((_nr, _nc, _ptile))\n            return tuple(_inst)\n\n        for rr in row_range:\n            for cc in col_range:\n                game = self._game_level[max(0, min(self._rows - 1, rr))][max(0, min(self._cols - 1, cc))]\n\n                game_patterns_info = self._scheme_info.pattern_info.game_to_patterns[game]\n\n                if game_patterns_info is None:\n                    continue\n\n                for pattern_template_in in game_patterns_info:\n                    all_pattern_in_inst = []\n\n                    for pattern_in in game_patterns_info[pattern_template_in]:\n                        pattern_inst_in = pattern_inst(pattern_template_in, pattern_in)\n                        if pattern_inst_in is None:\n                            continue\n\n                        all_pattern_in_inst.append(pattern_inst_in)\n\n                        for pattern_template_out in game_patterns_info[pattern_template_in][pattern_in]:\n                            if pattern_template_out is None:\n                                continue\n\n                            pattern_list_out = []\n                            for pattern_out in game_patterns_info[pattern_template_in][pattern_in][pattern_template_out]:\n                                pattern_inst_out = pattern_inst(pattern_template_out, pattern_out)\n                                if pattern_inst_out is not None:\n                                    pattern_list_out.append(pattern_inst_out)\n\n                            add_tile_patterns(pattern_inst_in, pattern_list_out)\n\n                    util.check(len(all_pattern_in_inst) > 0, 'no inst in patterns')\n                    add_pattern_options(all_pattern_in_inst)\n\n    def add_rules_counts(self, use_out_text_groups, counts_scale_lo, counts_scale_hi, weight_counts):\n        print('add count constraints', weight_counts)\n\n        util.check(weight_counts is None or weight_counts > 0, 'weight')\n\n        print('using output text groups' if use_out_text_groups else 'using single tile groups')\n\n        def add_counts(_rr_lo, _rr_hi, _cc_lo, _cc_hi, _count_game_to_tag_to_tiles):\n            for _game, _count_tag_to_tiles in _count_game_to_tag_to_tiles.items():\n                for _tag in _count_tag_to_tiles:\n                    _rcs = []\n                    for _rr in range(_rr_lo, _rr_hi):\n                        for _cc in range(_cc_lo, _cc_hi):\n                            if self._game_level[_rr][_cc] == _game and self._tag_level[_rr][_cc] == _tag:\n                                _rcs.append((_rr, _cc))\n\n                    if len(_rcs) == 0:\n                        continue\n\n                    if use_out_text_groups:\n                        util.check(self._scheme_info.tileset.tile_to_text is not None, 'tile groups out text')\n\n                        _inv = {}\n                        for _tile in _count_tag_to_tiles[_game][_tag]:\n                            _out_text = self._scheme_info.tileset.tile_to_text[_tile]\n\n                            # no counts on start/goal tiles\n                            if _out_text == util.START_TEXT or _out_text == util.GOAL_TEXT:\n                                continue\n\n                            if _out_text not in _inv:\n                                _inv[_out_text] = []\n                            _inv[_out_text].append(_tile)\n\n                        _tile_groups = [(_out_text, _tiles) for _out_text, _tiles in _inv.items()]\n                    else:\n                        _tile_groups = [(None, [_tile]) for _tile in _count_tag_to_tiles[_tag]]\n\n                    if len(_tile_groups) <= 1:\n                        continue\n\n                    for _out_text, _tiles in _tile_groups:\n                        _wt = 0.0\n                        for _tile in _tiles:\n                            _wt += _count_tag_to_tiles[_tag][_tile]\n\n                        _lo = max(0,         math.floor(counts_scale_lo * len(_rcs) * _wt))\n                        _hi = min(len(_rcs), math.ceil (counts_scale_hi * len(_rcs) * _wt))\n                        self.add_constraint_tile_counts(_rcs, _tiles, _lo, _hi, weight_counts)\n\n        for rr_divs in range(self._scheme_info.count_info.divs_size[0]):\n            for cc_divs in range(self._scheme_info.count_info.divs_size[1]):\n                rr_lo = self._rows * (rr_divs + 0) // self._scheme_info.count_info.divs_size[0]\n                rr_hi = self._rows * (rr_divs + 1) // self._scheme_info.count_info.divs_size[0]\n                cc_lo = self._cols * (cc_divs + 0) // self._scheme_info.count_info.divs_size[1]\n                cc_hi = self._cols * (cc_divs + 1) // self._scheme_info.count_info.divs_size[1]\n\n                add_counts(rr_lo, rr_hi, cc_lo, cc_hi, self._scheme_info.count_info.divs_to_game_to_tag_to_tile_count[(rr_divs, cc_divs)])\n\n    def add_constraint_tile_counts(self, rcs, tiles, lo, hi, weight_counts):\n        util.check(lo <= hi, 'counts')\n        util.check(weight_counts is None or weight_counts > 0, 'weight')\n\n        vvs = [self._tile_var(rr, cc, tile) for rr, cc in rcs for tile in tiles]\n\n        self._solver.cnstr_count(vvs, True, lo, hi, weight_counts)\n\n    def reachability_edges(self):\n        if self._reach_info is None:\n            return None\n\n        edges = {}\n        for edge_key in self._reach_vars_edge:\n            fr, fc, tr, tc, pwtc, need_open_path, need_open_aux, need_closed = edge_key\n            edges[(fr, fc, tr, tc, pwtc)] = None\n\n        return edges\n\n    def add_constraint_reach_edge(self, cfr, cfc, ctr, ctc, cpwtc, on_path, weight):\n        edge_vars = []\n        for edge_key in self._reach_out_edges[(cfr, cfc)]:\n            fr, fc, tr, tc, pwtc, need_open_path, need_open_aux, need_closed = edge_key\n            if (cfr, cfc, ctr, ctc, cpwtc) == (fr, fc, tr, tc, pwtc):\n                edge_vars.append(self._reach_vars_edge[edge_key])\n\n        edge_count = 1 if on_path else 0\n\n        self._solver.cnstr_count(edge_vars, True, edge_count, edge_count, weight)\n\n    def add_constraint_start(self, rr, cc, on_path, weight):\n        game = self._game_level[rr][cc]\n        move_info = self._reach_info.game_to_move[game]\n        vv = self._tile_var(rr, cc, move_info.start_tile)\n        self._solver.cnstr_count([vv], on_path, 1, 1, weight)\n\n    def add_constraint_goal(self, rr, cc, on_path, weight):\n        game = self._game_level[rr][cc]\n        move_info = self._reach_info.game_to_move[game]\n        vv = self._tile_var(rr, cc, move_info.goal_tile)\n        self._solver.cnstr_count([vv], on_path, 1, 1, weight)\n\n    def add_rules_reachability(self, reach_info):\n        print('add reachability constraints')\n\n        self._reach_info = reach_info\n\n        nodes = []\n        in_edges = {}\n        out_edges = {}\n\n        possible_start_vvs, possible_goal_vvs = [], []\n        impossible_start_vvs, impossible_goal_vvs = [], []\n        for (rr, cc) in self._vars_rc_t:\n            game = self._game_level[rr][cc]\n            move_info = reach_info.game_to_move[game]\n\n            if self._tile_has_var(rr, cc, move_info.start_tile):\n                vv = self._tile_var(rr, cc, move_info.start_tile)\n                if (rr, cc) in reach_info.start_rcs:\n                    possible_start_vvs.append(vv)\n                else:\n                    impossible_start_vvs.append(vv)\n            if self._tile_has_var(rr, cc, move_info.goal_tile):\n                vv = self._tile_var(rr, cc, move_info.goal_tile)\n                if (rr, cc) in reach_info.goal_rcs:\n                    possible_goal_vvs.append(vv)\n                else:\n                    impossible_goal_vvs.append(vv)\n\n        # exactly one start in possible tiles\n        self._solver.cnstr_count(possible_start_vvs, True, 1, 1, None)\n\n        # no start in impossible tiles\n        self._solver.cnstr_count(impossible_start_vvs, True, 0, 0, None)\n\n        # exactly one goal in possible tiles\n        self._solver.cnstr_count(possible_goal_vvs, True, 1, 1, None)\n\n        # no goal in impossible tiles\n        self._solver.cnstr_count(impossible_goal_vvs, True, 0, 0, None)\n\n        for rr, cc in self._vars_rc_t:\n            util.check(not self._tile_has_var(rr, cc, util.VOID_TILE), 'void tile')\n\n            node = (rr, cc)\n            nodes.append(node)\n            out_edges[node] = {}\n            in_edges[node] = {}\n\n            self._reach_vars_node[(rr, cc)] = self._solver.make_var()\n\n        for rr, cc in nodes:\n            game = self._game_level[rr][cc]\n            move_info = reach_info.game_to_move[game]\n\n            for dest_delta, need_open_path_delta, need_open_aux_delta, need_closed_delta in move_info.move_template:\n                def inst_deltas(_deltas):\n                    _inst = ()\n                    for _dr, _dc in _deltas:\n                        _nr = rr + _dr\n                        _nc = cc + _dc\n                        if move_info.wrap_cols: _nc = _nc % self._cols\n                        if (_nr, _nc) not in nodes:\n                            return None\n                        _inst = _inst + ((_nr, _nc),)\n                    return _inst\n\n                need_open_path = inst_deltas(need_open_path_delta + [dest_delta])\n                if need_open_path is None:\n                    continue\n\n                need_open_aux = inst_deltas(need_open_aux_delta)\n                if need_open_aux is None:\n                    continue\n\n                need_closed = inst_deltas(need_closed_delta)\n                if need_closed is None:\n                    continue\n\n                tr = rr + dest_delta[0]\n                tc = cc + dest_delta[1]\n\n                pwtc = tc\n                if move_info.wrap_cols: tc = tc % self._cols\n\n                edge_key = (rr, cc, tr, tc, pwtc, need_open_path, need_open_aux, need_closed)\n\n                out_edges[(rr, cc)][edge_key] = None\n                in_edges[(tr, tc)][edge_key] = None\n\n                if edge_key not in self._reach_vars_edge:\n                    self._reach_vars_edge[edge_key] = self._solver.make_var()\n\n        open_vars = {}\n        for rr, cc in nodes:\n            game = self._game_level[rr][cc]\n            move_info = reach_info.game_to_move[game]\n\n            # TODO: treat start and goal tiles separately from open tiles?\n            all_open_tiles = move_info.open_tiles + [move_info.start_tile, move_info.goal_tile]\n\n            if len(all_open_tiles) == 1:\n                open_var = self._tile_var(rr, cc, all_open_tiles[0])\n            else:\n                open_var = self._solver.make_var()\n                open_tile_vvs = [self._tile_var(rr, cc, all_open_tile) for all_open_tile in all_open_tiles]\n                for open_tile_vv in open_tile_vvs:\n                    self._solver.cnstr_implies_disj(open_tile_vv, True, [open_var], True, None)\n                self._solver.cnstr_implies_disj(open_var, True, open_tile_vvs, True, None)\n            open_vars[(rr, cc)] = open_var\n\n        for rr, cc in nodes:\n            game = self._game_level[rr][cc]\n            move_info = reach_info.game_to_move[game]\n\n            reach_node_var = self._reach_vars_node[(rr, cc)]\n\n            out_vvs = []\n            for edge_key in out_edges[(rr, cc)]:\n                reach_out_edge_var = self._reach_vars_edge[edge_key]\n                out_vvs.append(reach_out_edge_var)\n\n                fr, fc, tr, tc, pwtc, need_open_path, need_open_aux, need_closed = edge_key\n                util.check((fr, fc) == (rr, cc), 'edge')\n\n                self._solver.cnstr_implies_disj(reach_node_var, False, [reach_out_edge_var], False, None) # !reach_node_var -> !reach_out_edge_var\n\n                for nor, noc in need_open_path + need_open_aux:\n                    open_out_var = open_vars[(nor, noc)]\n                    self._solver.cnstr_implies_disj(open_out_var, False, [reach_out_edge_var], False, None) # !open_out_var -> !reach_out_edge_var\n\n                for ncr, ncc in need_closed:\n                    open_out_var = open_vars[(ncr, ncc)]\n                    self._solver.cnstr_implies_disj(open_out_var, True, [reach_out_edge_var], False, None) # open_out_var -> !reach_out_edge_var\n\n            in_vvs = []\n            for edge_key in in_edges[(rr, cc)]:\n                reach_in_edge_var = self._reach_vars_edge[edge_key]\n                in_vvs.append(reach_in_edge_var)\n\n            # at most 1 in edge\n            if len(in_vvs) > 0:\n                self._solver.cnstr_count(in_vvs, True, 0, 1, None)\n\n            # at most 1 out edge\n            if len(out_vvs) > 0:\n                self._solver.cnstr_count(out_vvs, True, 0, 1, None)\n\n            # start handling\n            start_and_in_vvs = in_vvs\n\n            if self._tile_has_var(rr, cc, move_info.start_tile):\n                start_tile_var = self._tile_var(rr, cc, move_info.start_tile)\n\n                # start must be reachable\n                self._solver.cnstr_implies_disj(start_tile_var, True, [reach_node_var], True, None) # start_tile_var -> reach_node_var\n\n                # start has no in edges\n                for in_vv in in_vvs:\n                    self._solver.cnstr_implies_disj(start_tile_var, True, [in_vv], False, None) # ... start_tile_var -> A !in_edge\n\n                start_and_in_vvs = [start_tile_var] + start_and_in_vvs\n\n            # unless it's the start, no in edges means not reachable\n            conj_start_and_in_vvs = self._solver.make_conj(start_and_in_vvs, False)\n            self._solver.cnstr_implies_disj(conj_start_and_in_vvs, True, [reach_node_var], False, None) # !start_tile_var & A !in_edge -> !reach_node_var\n\n            # goal handling\n            if self._tile_has_var(rr, cc, move_info.goal_tile):\n                goal_tile_var = self._tile_var(rr, cc, move_info.goal_tile)\n\n                # goal must be reachable\n                self._solver.cnstr_implies_disj(goal_tile_var, True, [reach_node_var], True, None) # goal_tile_var -> reach_node_var\n\n                # goal has no out edges\n                for out_vv in out_vvs:\n                    self._solver.cnstr_implies_disj(goal_tile_var, True, [out_vv], False, None) # ... goal_tile_var -> A !in_edge\n\n        self._reach_out_edges = out_edges\n\n    def solve(self):\n        if self._solver.solve():\n            print('objective: %s' % str(self._solver.get_objective()))\n            return True\n        else:\n            return False\n\n    def get_result(self):\n        res_info = util.ResultInfo()\n\n        res_info.objective = self._solver.get_objective()\n\n        res_info.extra_meta += self._extra_meta\n\n        res_info.reach_info = None\n        if self._reach_info:\n            res_info.reach_info = util.ResultReachInfo()\n            res_info.reach_info.path_edges, res_info.reach_info.path_tiles, path_edge_keys = self._get_reach_path()\n            res_info.reach_info.offpath_edges = self._get_reach_offpath_edges(path_edge_keys)\n\n        res_info.tile_level = util.make_grid(self._rows, self._cols, util.VOID_TILE)\n        res_info.text_level = None\n        res_info.image_level = None\n\n        set_tiles = self._get_tiles_set()\n        for rr in range(self._rows):\n            for cc in range(self._cols):\n                tag = self._tag_level[rr][cc]\n\n                if (rr, cc) in set_tiles:\n                    found_tile = set_tiles[(rr, cc)]\n                else:\n                    found_tile = util.VOID_TILE\n\n                util.check((tag == util.VOID_TEXT) == (found_tile == util.VOID_TILE), 'void')\n\n                res_info.tile_level[rr][cc] = found_tile\n\n        if self._scheme_info.tileset.tile_to_text is not None:\n            res_info.text_level = util.tile_level_to_text_level(res_info.tile_level, self._scheme_info.tileset)\n\n        if self._scheme_info.tileset.tile_to_image is not None:\n            res_info.image_level = util.tile_level_to_image_level(res_info.tile_level, self._scheme_info.tileset)\n\n        return res_info\n\n    def _get_tiles_set(self):\n        tiles = {}\n\n        for rr, cc in self._vars_rc_t:\n            found_tile = None\n            for tile in self._vars_rc_t[(rr, cc)]:\n                if self._solver.get_var(self._vars_rc_t[(rr, cc)][tile]):\n                    util.check(found_tile is None, 'multiple tiles selected.')\n                    found_tile = tile\n            util.check(found_tile is not None, 'no tile selected.')\n            tiles[(rr, cc)] = found_tile\n\n        return tiles\n\n    def _get_reach_path(self):\n        if not self._reach_info:\n            return None\n\n        node_path = []\n        tile_path = []\n        key_path = []\n\n        start_rc, goal_rc = None, None\n        for (rr, cc) in self._vars_rc_t:\n            game = self._game_level[rr][cc]\n            move_info = self._reach_info.game_to_move[game]\n\n            if move_info.start_tile in self._vars_rc_t[(rr, cc)] and self._solver.get_var(self._tile_var(rr, cc, move_info.start_tile)):\n                start_rc = (rr, cc)\n            if move_info.goal_tile in self._vars_rc_t[(rr, cc)] and self._solver.get_var(self._tile_var(rr, cc, move_info.goal_tile)):\n                goal_rc = (rr, cc)\n\n        util.check(start_rc is not None, 'no start')\n        util.check(goal_rc is not None, 'no goal')\n\n        tile_path.append(start_rc)\n\n        current_node = start_rc\n\n        while current_node:\n            rr, cc = current_node\n\n            current_reachable = self._solver.get_var(self._reach_vars_node[(rr, cc)])\n            util.check(current_reachable, 'current node not reachable')\n\n            next_node = None\n            for edge_key in self._reach_out_edges[(rr, cc)]:\n                fr, fc, tr, tc, pwtc, need_open_path, need_open_aux, need_closed = edge_key\n                util.check(fr == rr and fc == cc, 'edge')\n\n                out_reachable = self._solver.get_var(self._reach_vars_edge[edge_key])\n                if out_reachable:\n                    util.check(next_node is None, 'multiple out edges')\n                    util.check(need_open_path[-1] == (tr, tc), 'path does not end at node')\n\n                    for nr, nc in need_open_path:\n                        tile_path.append((nr, nc))\n\n                    if tc == pwtc:\n                        node_path.append((fr, fc, tr, tc))\n                    else:\n                        node_path.append((fr, fc, tr, pwtc))\n                        node_path.append((fr, fc + (tc - pwtc), tr, tc))\n\n                    key_path.append(edge_key)\n\n                    next_node = (tr, tc)\n\n            util.check(next_node is not None or current_node == goal_rc, 'path does not end at goal')\n\n            current_node = next_node\n\n        for (ra, ca), (rb, cb) in zip(tile_path, tile_path[1:]):\n            game = self._game_level[ra][ca]\n            move_info = self._reach_info.game_to_move[game]\n\n            if not move_info.wrap_cols:\n                util.check(abs(ra - rb) + abs(ca - cb) == 1, 'path tiles')\n            else:\n                if ca > 1 + cb:\n                    cb += self._cols\n                if cb > 1 + ca:\n                    ca += self._cols\n                util.check(abs(ra - rb) + abs(ca - cb) == 1, 'path tiles')\n\n        return node_path, tile_path, key_path\n\n    def _get_reach_offpath_edges(self, path_edge_keys):\n        if not self._reach_info:\n            return None\n\n        edges = {}\n\n        for edge_key in self._reach_vars_edge:\n            edge_reachable = self._solver.get_var(self._reach_vars_edge[edge_key])\n            if edge_reachable and edge_key not in path_edge_keys:\n                fr, fc, tr, tc, pwtc, need_open_path, need_open_aux, need_closed = edge_key\n                if tc == pwtc:\n                    edges[(fr, fc, tr, tc)] = None\n                else:\n                    edges[(fr, fc, tr, pwtc)] = None\n                    edges[(fr, fc + (tc - pwtc), tr, tc)] = None\n\n        return list(edges.keys())", ""]}
{"filename": "util.py", "chunked_list": ["import atexit, bz2, copy, gzip, json, os, pickle, shutil, subprocess, sys, time\nimport PIL.Image\n\n\n\nMETA_STR        = 'META'\n\nMGROUP_PATH     = 'path'\nMGROUP_OFFPATH  = 'offpath'\n", "MGROUP_OFFPATH  = 'offpath'\n\nOPEN_TEXT       = '-'\nOPEN_TEXT_ZELDA = 'DLOMS-'\nSTART_TEXT      = '{'\nGOAL_TEXT       = '}'\n\nDEFAULT_TEXT    = ','\nPATH_TEXT       = 'p'\n", "PATH_TEXT       = 'p'\n\nVOID_TEXT       = ' '\nVOID_TILE       = -1\n\nSPECIAL_CHARS = [PATH_TEXT]\nINDEX_CHARS = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\n\n\nclass TileSetInfo:\n    def __init__(self):\n        self.tile_ids = None\n\n        self.tile_to_text = None\n        self.tile_to_image = None\n        self.tile_image_size = None", "\n\nclass TileSetInfo:\n    def __init__(self):\n        self.tile_ids = None\n\n        self.tile_to_text = None\n        self.tile_to_image = None\n        self.tile_image_size = None\n\nclass TileLevelInfo:\n    def __init__(self):\n        self.tiles = None\n        self.tags = None\n        self.games = None\n        self.meta = None", "\nclass TileLevelInfo:\n    def __init__(self):\n        self.tiles = None\n        self.tags = None\n        self.games = None\n        self.meta = None\n\nclass TileInfo:\n    def __init__(self):\n        self.tileset = None\n        self.levels = None", "class TileInfo:\n    def __init__(self):\n        self.tileset = None\n        self.levels = None\n\n\n\nclass SchemeCountInfo:\n    def __init__(self):\n        self.divs_size = None\n\n        self.divs_to_game_to_tag_to_tile_count = None", "\nclass SchemePatternInfo:\n    def __init__(self):\n        self.game_to_patterns = None\n\n        self.stride_rows = None\n        self.stride_cols = None\n        self.dr_lo = None\n        self.dr_hi = None\n        self.dc_lo = None\n        self.dc_hi = None", "\nclass SchemeInfo:\n    def __init__(self):\n        self.tileset = None\n\n        self.game_to_tag_to_tiles = None\n\n        self.count_info = None\n        self.pattern_info = None\n", "\n\n\nclass ReachabilitySetup:\n    def __init__(self):\n        self.game_to_move = None\n        self.wrap_cols = None\n        self.goal_loc = None\n        self.goal_params = None\n        self.open_text = None", "\nclass GameMoveInfo:\n    def __init__(self):\n        self.start_tile = None\n        self.goal_tile = None\n        self.open_tiles = None\n\n        self.move_template = None\n        self.wrap_cols = None\n\nclass ReachabilityInfo:\n    def __init__(self):\n        self.start_rcs = None\n        self.goal_rcs = None\n\n        self.game_to_move = None", "\nclass ReachabilityInfo:\n    def __init__(self):\n        self.start_rcs = None\n        self.goal_rcs = None\n\n        self.game_to_move = None\n\nclass ResultReachInfo:\n    def __init__(self):\n        self.path_edges = None\n        self.path_tiles = None\n        self.offpath_edges = None", "class ResultReachInfo:\n    def __init__(self):\n        self.path_edges = None\n        self.path_tiles = None\n        self.offpath_edges = None\n\nclass ResultExecutionInfo:\n    def __init__(self):\n        self.levels = None\n        self.names = None\n        self.changes = None\n        self.term = None\n        self.first_term = None", "\nclass ResultInfo:\n    def __init__(self):\n        self.tile_level = None\n        self.text_level = None\n        self.image_level = None\n\n        self.reach_info = None\n\n        self.execution_info = None\n\n        self.objective = None\n\n        self.extra_meta = []", "\n\n\nclass SectionTimer:\n    def __init__(self):\n        self._start_time = time.time()\n        self._last_section = None\n        self._last_time = None\n\n    def print_done(self):\n        if not mute_time():\n            print('--TOTALTIME %.2f' % (time.time() - self._start_time))\n\n    def print_section(self, section):\n        curr_time = time.time()\n\n        if self._last_section is not None:\n            if mute_time():\n                print('...%s done' % self._last_section, flush=True)\n            else:\n                last = '%.2f' % (curr_time - self._last_time)\n                total = '%.2f' % (curr_time - self._start_time)\n                print('...%s took %s, %s' % (self._last_section, last, total), flush=True)\n\n        self._last_section = section\n        self._last_time = curr_time\n\n        if section is not None:\n            print('starting %s...' % (section), flush=True)", "\n_section_timer = None\ndef _timer_stop():\n    global _section_timer\n    _section_timer.print_section(None)\n    _section_timer.print_done()\n    _section_timer = None\n\ndef timer_start(print_cmdline=True):\n    global _section_timer\n    _section_timer = SectionTimer()\n    atexit.register(_timer_stop)\n    if print_cmdline:\n        print('running ' + subprocess.list2cmdline(sys.argv))", "def timer_start(print_cmdline=True):\n    global _section_timer\n    _section_timer = SectionTimer()\n    atexit.register(_timer_stop)\n    if print_cmdline:\n        print('running ' + subprocess.list2cmdline(sys.argv))\n\ndef timer_section(section):\n    global _section_timer\n    if _section_timer is None:\n        print(section)\n    else:\n        _section_timer.print_section(section)", "\n\n\ndef mute_time():\n    return os.environ.get('STG_MUTE_TIME')\n\ndef mute_port():\n    return os.environ.get('STG_MUTE_PORT')\n\ndef write_time(ss):\n    if not mute_time():\n        sys.stdout.write(ss)\n        sys.stdout.flush()", "\ndef write_time(ss):\n    if not mute_time():\n        sys.stdout.write(ss)\n        sys.stdout.flush()\n\ndef write_portfolio(ss):\n    if not mute_port():\n        sys.stdout.write(ss)\n        sys.stdout.flush()", "\n\n\ndef exit_solution_found():\n    sys.stdout.write('--SOLVED\\n')\n    sys.stdout.flush()\n    sys.exit(0)\n\ndef exit_solution_not_found():\n    sys.stdout.write('--NOSOLUTION\\n')\n    sys.stdout.flush()\n    sys.exit(-1)", "def exit_solution_not_found():\n    sys.stdout.write('--NOSOLUTION\\n')\n    sys.stdout.flush()\n    sys.exit(-1)\n\n\n\ndef check(cond, msg):\n    if not cond:\n        raise RuntimeError(msg)", "\ndef arg_list_to_dict(parser, name, arg_list, check_option):\n    if arg_list is None:\n        return None\n\n    res = {}\n    if len(arg_list) == 1 and '=' not in arg_list[0]:\n        res[DEFAULT_TEXT] = check_option(arg_list[0])\n    else:\n        for kv in arg_list:\n            if kv.count('=') != 1:\n                parser.error(name + ' as dict must have exactly 1 =')\n            key, val = kv.split('=')\n            res[key] = check_option(val)\n    return res", "\ndef arg_list_to_dict_int(parser, name, arg_list):\n    return arg_list_to_dict(parser, name, arg_list, int)\n\ndef arg_list_to_dict_options(parser, name, arg_list, val_options):\n    def check_option(option):\n        if option not in val_options:\n            parser.error(name + ' must be in ' + ','.join(val_options))\n        return option\n\n    return arg_list_to_dict(parser, name, arg_list, check_option)", "\ndef check_tileset_match(ts0, ts1):\n    check(ts0.tile_ids == ts1.tile_ids, 'tileset mismatch')\n    check(ts0.tile_image_size == ts1.tile_image_size, 'tileset mismatch')\n\n    if ts0.tile_to_text is not None or ts1.tile_to_text is not None:\n        check(ts0.tile_to_text is not None and ts1.tile_to_text is not None, 'tileset mismatch')\n        for tile in ts0.tile_ids:\n            check(ts0.tile_to_text[tile] == ts1.tile_to_text[tile], 'tileset mismatch')\n    else:\n        check(ts0.tile_to_text is None and ts1.tile_to_text is None, 'tileset mismatch')\n\n    if ts0.tile_to_image is not None or ts1.tile_to_image is not None:\n        check(ts0.tile_to_image is not None and ts1.tile_to_image is not None, 'tileset mismatch')\n        for tile in ts0.tile_ids:\n            check(tuple(ts0.tile_to_image[tile].getdata()) == tuple(ts1.tile_to_image[tile].getdata()), 'tileset mismatch')\n    else:\n        check(ts0.tile_to_image is None and ts1.tile_to_image is None, 'tileset mismatch')", "\ndef make_grid(rows, cols, elem):\n    out = []\n    for rr in range(rows):\n        out_row = []\n        for cc in range(cols):\n            out_row.append(copy.copy(elem))\n        out.append(out_row)\n    return out\n\ndef rotate_grid_cw(grid):\n    return [list(elem) for elem in zip(*grid[::-1])]", "\ndef rotate_grid_cw(grid):\n    return [list(elem) for elem in zip(*grid[::-1])]\n\ndef corner_indices(til, depth):\n    def corner_indices_helper(_fra, _til, _depth, _sofar, _track):\n        if _depth == 0:\n            _track.append(_sofar)\n        else:\n            for _ind in range(_fra, _til):\n                corner_indices_helper(_ind + 1, _til, _depth - 1, _sofar + (_ind,), _track)\n    ret = []\n    corner_indices_helper(0, til, depth, (), ret)\n    return ret", "\ndef fileistype(fn, ext):\n    return fn.endswith(ext) or fn.endswith(ext + '.gz') or fn.endswith(ext + '.bz2')\n\ndef fresh_image(image):\n    image_data = PIL.Image.new(image.mode, image.size)\n    image_data.putdata(image.getdata())\n    return image_data\n\ndef trim_void_tile_level(tile_level):\n    rows, cols = len(tile_level), len(tile_level[0])\n\n    rr_lo, rr_hi = rows, 0\n    for rr in range(rows):\n        any_nonvoid = False\n        for cc in range(cols):\n            if tile_level[rr][cc] != VOID_TILE:\n                any_nonvoid = True\n                break\n        if any_nonvoid:\n            rr_lo = min(rr_lo, rr)\n            rr_hi = max(rr_hi, rr + 1)\n\n    cc_lo, cc_hi = cols, 0\n    for cc in range(cols):\n        any_nonvoid = False\n        for rr in range(rows):\n            if tile_level[rr][cc] != VOID_TILE:\n                any_nonvoid = True\n                break\n        if any_nonvoid:\n            cc_lo = min(cc_lo, cc)\n            cc_hi = max(cc_hi, cc + 1)\n\n    ret = []\n    for rr in range(rr_lo, rr_hi):\n        row = []\n        for cc in range(cc_lo, cc_hi):\n            row.append(tile_level[rr][cc])\n        ret.append(row)\n    print(rr_lo, rr_hi, cc_lo, cc_hi)\n    print(ret)\n    return ret", "\ndef trim_void_tile_level(tile_level):\n    rows, cols = len(tile_level), len(tile_level[0])\n\n    rr_lo, rr_hi = rows, 0\n    for rr in range(rows):\n        any_nonvoid = False\n        for cc in range(cols):\n            if tile_level[rr][cc] != VOID_TILE:\n                any_nonvoid = True\n                break\n        if any_nonvoid:\n            rr_lo = min(rr_lo, rr)\n            rr_hi = max(rr_hi, rr + 1)\n\n    cc_lo, cc_hi = cols, 0\n    for cc in range(cols):\n        any_nonvoid = False\n        for rr in range(rows):\n            if tile_level[rr][cc] != VOID_TILE:\n                any_nonvoid = True\n                break\n        if any_nonvoid:\n            cc_lo = min(cc_lo, cc)\n            cc_hi = max(cc_hi, cc + 1)\n\n    ret = []\n    for rr in range(rr_lo, rr_hi):\n        row = []\n        for cc in range(cc_lo, cc_hi):\n            row.append(tile_level[rr][cc])\n        ret.append(row)\n    print(rr_lo, rr_hi, cc_lo, cc_hi)\n    print(ret)\n    return ret", "\ndef tile_level_to_text_level(tile_level, tileset):\n    rows, cols = len(tile_level), len(tile_level[0])\n\n    text_level = make_grid(rows, cols, VOID_TEXT)\n    for rr in range(rows):\n        for cc in range(cols):\n            if tile_level[rr][cc] != VOID_TILE:\n                text_level[rr][cc] = tileset.tile_to_text[tile_level[rr][cc]]\n    return text_level", "\ndef tile_level_to_image_level(tile_level, tileset):\n    rows, cols = len(tile_level), len(tile_level[0])\n\n    image_level = PIL.Image.new('RGBA', (cols * tileset.tile_image_size, rows * tileset.tile_image_size), (0, 0, 0, 0))\n    for rr in range(rows):\n        for cc in range(cols):\n            if tile_level[rr][cc] != VOID_TILE:\n                image_level.paste(tileset.tile_to_image[tile_level[rr][cc]], (cc * tileset.tile_image_size, rr * tileset.tile_image_size))\n    return image_level", "\ndef get_meta_path(meta):\n    if meta is not None:\n        for md in meta:\n            if md['type'] == 'geom' and md['shape'] == 'path' and md['group'] == MGROUP_PATH:\n                return [tuple(elem) for elem in md['data']]\n    return None\n\ndef get_meta_properties(meta):\n    if meta is not None:\n        ret = None\n        for md in meta:\n            if md['type'] == 'property':\n                if ret is None:\n                    ret = []\n                ret += md['value']\n        return ret\n    return None", "def get_meta_properties(meta):\n    if meta is not None:\n        ret = None\n        for md in meta:\n            if md['type'] == 'property':\n                if ret is None:\n                    ret = []\n                ret += md['value']\n        return ret\n    return None", "\ndef meta_check_json(obj):\n    check(type(obj) == dict, 'json')\n    check('type' in obj, 'json')\n    check(type(obj['type']) == str, 'json')\n    for key, value in obj.items():\n        check(type(key) == str, 'json')\n        check(type(value) in [str, int, float, list], 'json')\n        if type(value) == list:\n            for elem in value:\n                check(type(elem) in [str, int, float, list], 'json')\n                if type(elem) == list:\n                    for elem2 in elem:\n                        check(type(elem2) in [str, int, float], 'json')\n    return obj", "\ndef meta_path(group, data):\n    return meta_check_json({ 'type': 'geom', 'shape': 'path', 'group': group, 'data': [list(elem) for elem in data] })\n\ndef meta_line(group, data):\n    return meta_check_json({ 'type': 'geom', 'shape': 'line', 'group': group, 'data': [list(elem) for elem in data] })\n\ndef meta_tile(group, data):\n    return meta_check_json({ 'type': 'geom', 'shape': 'tile', 'group': group, 'data': [list(elem) for elem in data] })\n\ndef meta_rect(group, data):\n    return meta_check_json({ 'type': 'geom', 'shape': 'rect', 'group': group, 'data': [list(elem) for elem in data] })", "\ndef meta_rect(group, data):\n    return meta_check_json({ 'type': 'geom', 'shape': 'rect', 'group': group, 'data': [list(elem) for elem in data] })\n\ndef meta_properties(data):\n    return meta_check_json({ 'type': 'property', 'value': data })\n\ndef meta_custom(data):\n    return meta_check_json(data)\n\ndef openz(filename, mode):\n    if filename.endswith('.gz'):\n        return gzip.open(filename, mode)\n    elif filename.endswith('.bz2'):\n        return bz2.open(filename, mode)\n    else:\n        return open(filename, mode)", "\ndef openz(filename, mode):\n    if filename.endswith('.gz'):\n        return gzip.open(filename, mode)\n    elif filename.endswith('.bz2'):\n        return bz2.open(filename, mode)\n    else:\n        return open(filename, mode)\n\ndef print_result_info(result_info, replace_path_tiles):\n    print('tile level')\n    print_tile_level(result_info.tile_level)\n\n    if result_info.text_level is not None:\n        print('text level')\n        print_result_text_level(result_info, [], replace_path_tiles)\n\n    if result_info.execution_info is not None:\n        print('execution')\n        for level, name, first_term in zip(result_info.execution_info.levels, result_info.execution_info.names, result_info.execution_info.first_term):\n            if first_term:\n                print('>>> TERM <<<')\n                print()\n            if name:\n                print('>>> ' + name)\n            print_text_level(level)\n            print()", "\ndef print_result_info(result_info, replace_path_tiles):\n    print('tile level')\n    print_tile_level(result_info.tile_level)\n\n    if result_info.text_level is not None:\n        print('text level')\n        print_result_text_level(result_info, [], replace_path_tiles)\n\n    if result_info.execution_info is not None:\n        print('execution')\n        for level, name, first_term in zip(result_info.execution_info.levels, result_info.execution_info.names, result_info.execution_info.first_term):\n            if first_term:\n                print('>>> TERM <<<')\n                print()\n            if name:\n                print('>>> ' + name)\n            print_text_level(level)\n            print()", "\ndef save_result_info(result_info, prefix, compress=False, result_only=False):\n    result_name = prefix + '.result'\n    if compress:\n        result_name += '.gz'\n    print('writing result to', result_name)\n\n    with openz(result_name, 'wb') as f:\n        pickle.dump(result_info, f)\n\n    if not result_only:\n        if result_info.text_level is not None:\n            text_name = prefix + '.lvl'\n            print('writing text level to', text_name)\n\n            with openz(text_name, 'wt') as f:\n                print_result_text_level(result_info, result_info.extra_meta, False, outfile=f)\n\n        if result_info.image_level is not None:\n            image_name = prefix + '.png'\n            print('writing image level to', image_name)\n\n            result_info.image_level.save(image_name)\n\n        if result_info.execution_info is not None:\n            exec_folder = prefix + '_exec'\n            print('writing execution levels to', exec_folder)\n            if os.path.exists(exec_folder):\n                shutil.rmtree(exec_folder)\n            os.makedirs(exec_folder)\n\n            for ii, (level, name, changes, term) in enumerate(zip(result_info.execution_info.levels, result_info.execution_info.names, result_info.execution_info.changes, result_info.execution_info.term)):\n                descr = ['term' if term else 'step']\n                if name:\n                    descr.append(name)\n\n                step_name = exec_folder + ('/%02d_' % ii) + '_'.join(descr) + '_exec.lvl'\n\n                meta = result_info.extra_meta\n                if len(changes) != 0:\n                    meta.append(meta_rect('change', changes))\n                meta.append(meta_custom({'type': 'mkiii', 'desc': descr}))\n\n                with openz(step_name, 'wt') as f:\n                    print_text_level(level, meta=meta, outfile=f)", "\ndef index_to_char(idx):\n    if idx < len(INDEX_CHARS):\n        return INDEX_CHARS[idx]\n    else:\n        return '?'\n\ndef print_tile_level(tile_level, outfile=None):\n    if outfile is None:\n        outfile = sys.stdout\n\n    for row in tile_level:\n        for tile in row:\n            if tile == VOID_TILE:\n                display_tile = VOID_TEXT\n            else:\n                display_tile = index_to_char(tile)\n            outfile.write(display_tile)\n        outfile.write('\\n')", "\ndef print_tile_level_json(tile_level, meta=None, outfile=None):\n    if outfile is None:\n        outfile = sys.stdout\n\n    out = {}\n    out['tile'] = tile_level\n    if meta != None:\n        out['meta'] = meta\n    json.dump(out, outfile)\n    outfile.write('\\n')", "\ndef print_result_text_level(result_info, extra_meta, replace_path_tiles, outfile=None):\n    if outfile is None:\n        outfile = sys.stdout\n\n    meta = []\n    if result_info.reach_info is not None:\n        meta.append(meta_path(MGROUP_PATH, result_info.reach_info.path_edges))\n        meta.append(meta_tile(MGROUP_PATH, result_info.reach_info.path_tiles))\n        meta.append(meta_line(MGROUP_OFFPATH, result_info.reach_info.offpath_edges))\n\n    if extra_meta is not None:\n        meta += extra_meta\n\n    if replace_path_tiles and result_info.reach_info is not None:\n        path_tiles = result_info.reach_info.path_tiles\n    else:\n        path_tiles = None\n\n    print_text_level(result_info.text_level, meta=meta, replace_path_tiles=path_tiles, outfile=outfile)", "\ndef print_text_level(text_level, meta=None, replace_path_tiles=None, outfile=None):\n    if outfile is None:\n        outfile = sys.stdout\n\n    for rr, row in enumerate(text_level):\n        for cc, tile in enumerate(row):\n            if replace_path_tiles is not None and (rr, cc) in replace_path_tiles:\n                outfile.write(PATH_TEXT)\n            else:\n                outfile.write(tile)\n        outfile.write('\\n')\n\n    if meta is not None:\n        for md in meta:\n            outfile.write(META_STR + ' ' + json.dumps(md) + '\\n')", "\ndef process_old_meta(line):\n    TAG = 'META DRAW'\n    if line.startswith(TAG):\n        res = {}\n        res['type'] = 'geom'\n\n        line = line[len(TAG):].strip()\n\n        splt = line.split(':')\n        check(len(splt) == 2, 'split')\n        res['shape'] = splt[0].strip().lower()\n        line = splt[1].strip()\n\n        splt = line.split(';')\n        if len(splt) == 1:\n            points_str = splt[0].strip()\n        elif len(splt) == 2:\n            res['group'] = splt[0].strip()\n            points_str = splt[1].strip()\n        else:\n            check(False, 'split')\n\n        def _number(_s):\n            _ret = float(_s)\n            if _ret == int(_ret):\n                return int(_ret)\n            else:\n                return _ret\n\n        res['data'] = [tuple([_number(el) for el in pt.strip().split()]) for pt in points_str.split(',')]\n        return res\n\n    TAG = 'META REM'\n    if line.startswith(TAG):\n        return {'type': 'comment', 'value': line[len(TAG):].strip()}\n\n    return None", "\ndef read_text_level(infilename, include_meta=False):\n    with openz(infilename, 'rt') as infile:\n        lvl = []\n        meta = []\n\n        for line in infile.readlines():\n            line = line.rstrip('\\n')\n\n            old_meta = process_old_meta(line)\n            if old_meta is not None:\n                meta.append(old_meta)\n            elif line.startswith(META_STR):\n                if include_meta:\n                    meta.append(json.loads(line[len(META_STR):]))\n            else:\n                for special_char in SPECIAL_CHARS:\n                    check(special_char not in line, 'special char ' + special_char + ' in level.')\n\n                lvl.append([c for c in line])\n\n        if include_meta:\n            return lvl, meta\n        else:\n            return lvl", ""]}
{"filename": "tile2scheme.py", "chunked_list": ["import argparse, pickle, pprint, sys\nimport util\n\n\n\nPATTERN_NEIGH_2        = [([(0, 0)], [( 0, 1)]),\n                          ([(0, 0)], [( 1, 0)])]\n\nPATTERN_NEIGH_L        = [([(0, 0)], [( 0, 1)]),\n                          ([(0, 0)], [( 1, 1)]),", "PATTERN_NEIGH_L        = [([(0, 0)], [( 0, 1)]),\n                          ([(0, 0)], [( 1, 1)]),\n                          ([(0, 0)], [( 1, 0)])]\n\nPATTERN_NEIGH_PLUS     = [([(0, 0)], [( 0,  1)]),\n                          ([(0, 0)], [( 1,  0)]),\n                          ([(0, 0)], [( 0, -1)]),\n                          ([(0, 0)], [(-1,  0)])]\n\nPATTERN_NEIGH_BLOCK2   = [([(0, 0), (0, 1), (1, 0), (1, 1)], [(2, 0), (2, 1)]),", "\nPATTERN_NEIGH_BLOCK2   = [([(0, 0), (0, 1), (1, 0), (1, 1)], [(2, 0), (2, 1)]),\n                          ([(0, 0), (0, 1), (1, 0), (1, 1)], [(0, 2), (1, 2)]),\n                          ([(0, 0), (0, 1), (1, 0), (1, 1)], [(1, 2), (2, 1), (2, 2)])]\n\nPATTERN_NO_OUT_BLOCK_2  = [([(0, 0), (0, 1), (1, 0), (1, 1)], None)]\n\nPATTERN_NO_OUT_BLOCK_3  = [([(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)], None)]\n\nPATTERN_BLOCKZ         = [([(0, 0)], [(0, 1), (1, 1)]),", "\nPATTERN_BLOCKZ         = [([(0, 0)], [(0, 1), (1, 1)]),\n                          ([(0, 0)], [(1, 0), (1, 1)])]\n#PATTERN_BLOCKZ        = [([(0, 0)], [(0, 1)]),\n#                          ([(0, 0)], [(1, 0)]),\n#                          ([(1, 0), (0, 1)], [(1, 1)])]\n\nPATTERN_BLOCK2         = [([(0, 0)],\n                           [(0, 1), (1, 1), (1, 0)])]\n", "                           [(0, 1), (1, 1), (1, 0)])]\n\nPATTERN_BLOCK2_INV     = [([(0, 0), (0, 1), (1, 0)],\n                           [(1, 1)])]\n\nPATTERN_BLOCK3         = [([(0, 0)],\n                           [(0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)])]\n\nPATTERN_RING           = [([(0, 0)],\n                           [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)])]", "PATTERN_RING           = [([(0, 0)],\n                           [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)])]\n\nPATTERN_DIAMOND        = [([(0, 0)],\n                           [(-2, 0), (-1, -1), (-1, 0), (-1, 1), (0, -2), (0, -1), (0, 1), (0, 2), (1, -1), (1, 0), (1, 1), (2, 0)])]\n\nPATTERN_DYN_NO_OUT_2GRAM_COLS = 'PATTERN_DYN_NO_OUT_2GRAM_COLS'\nPATTERN_DYN_3GRAM_COLS        = 'PATTERN_DYN_3GRAM_COLS'\nPATTERN_DYN_2GRAM_ROWS        = 'PATTERN_DYN_2GRAM_ROWS'\nPATTERN_DYN_ZGRAM_COLS        = 'PATTERN_DYN_ZGRAM_COLS'", "PATTERN_DYN_2GRAM_ROWS        = 'PATTERN_DYN_2GRAM_ROWS'\nPATTERN_DYN_ZGRAM_COLS        = 'PATTERN_DYN_ZGRAM_COLS'\nPATTERN_DYN_ROOMS             = 'PATTERN_DYN_ROOMS'\n\nPATTERN_DICT = {\n    'nbr-2'      : PATTERN_NEIGH_2,\n    'nbr-l'      : PATTERN_NEIGH_L,\n    'nbr-plus'   : PATTERN_NEIGH_PLUS,\n    'nbr-block2' : PATTERN_NEIGH_BLOCK2,\n    'noout-bl-2' : PATTERN_NO_OUT_BLOCK_2,", "    'nbr-block2' : PATTERN_NEIGH_BLOCK2,\n    'noout-bl-2' : PATTERN_NO_OUT_BLOCK_2,\n    'noout-bl-3' : PATTERN_NO_OUT_BLOCK_3, # was no-out3\n    'blockz'     : PATTERN_BLOCKZ,\n    'block2'     : PATTERN_BLOCK2,\n    'block2-inv' : PATTERN_BLOCK2_INV,\n    'block3'     : PATTERN_BLOCK3,\n    'ring'       : PATTERN_RING,\n    'diamond'    : PATTERN_DIAMOND,\n    'noout-gc-2' : PATTERN_DYN_NO_OUT_2GRAM_COLS,", "    'diamond'    : PATTERN_DIAMOND,\n    'noout-gc-2' : PATTERN_DYN_NO_OUT_2GRAM_COLS,\n    '3gc'        : PATTERN_DYN_3GRAM_COLS,\n    '2gr'        : PATTERN_DYN_2GRAM_ROWS,\n    'zgc'        : PATTERN_DYN_ZGRAM_COLS,\n    'rooms'      : PATTERN_DYN_ROOMS,\n}\n\n\n\ndef inc(tile_dict, key, tile, amount):\n    if key not in tile_dict:\n        tile_dict[key] = {}\n    if tile not in tile_dict[key]:\n        tile_dict[key][tile] = 0\n    tile_dict[key][tile] += amount", "\n\ndef inc(tile_dict, key, tile, amount):\n    if key not in tile_dict:\n        tile_dict[key] = {}\n    if tile not in tile_dict[key]:\n        tile_dict[key][tile] = 0\n    tile_dict[key][tile] += amount\n\ndef normalize(tile_dict):\n    for key in tile_dict:\n        total = 0\n        for tile in tile_dict[key]:\n            total += tile_dict[key][tile]\n        if total != 0:\n            for tile in tile_dict[key]:\n                tile_dict[key][tile] = tile_dict[key][tile] / total", "\ndef normalize(tile_dict):\n    for key in tile_dict:\n        total = 0\n        for tile in tile_dict[key]:\n            total += tile_dict[key][tile]\n        if total != 0:\n            for tile in tile_dict[key]:\n                tile_dict[key][tile] = tile_dict[key][tile] / total\n\ndef tiles2scheme(tile_info, divs_size, game_to_patterns_delta, level_rotate):\n    ti = tile_info\n    si = util.SchemeInfo()\n\n    si.tileset = ti.tileset\n\n    si.game_to_tag_to_tiles = {}\n\n    if divs_size is None:\n        si.count_info = None\n    else:\n        si.count_info = util.SchemeCountInfo()\n\n        si.count_info.divs_size = divs_size\n        si.count_info.divs_to_game_to_tag_to_tile_count = {}\n        for rr_divs in range(si.count_info.divs_size[0]):\n            for cc_divs in range(si.count_info.divs_size[1]):\n                si.count_info.divs_to_game_to_tag_to_tile_count[(rr_divs, cc_divs)] = {}\n\n    if game_to_patterns_delta is None:\n        si.pattern_info = None\n    else:\n        si.pattern_info = util.SchemePatternInfo()\n\n        si.pattern_info.game_to_patterns = {}\n\n        si.pattern_info.stride_rows = 1\n        si.pattern_info.stride_cols = 1\n        si.pattern_info.dr_lo = 0\n        si.pattern_info.dr_hi = 0\n        si.pattern_info.dc_lo = 0\n        si.pattern_info.dc_hi = 0\n\n        for game, patterns_delta in game_to_patterns_delta.items():\n            if patterns_delta == PATTERN_DYN_NO_OUT_2GRAM_COLS:\n                util.check(len(game_to_patterns_delta) == 1, 'multiple games stride')\n\n                gram_rows = [len(tli.tiles) for tli in ti.levels]\n                util.check(len(set(gram_rows)) == 1, 'all levels must be same height')\n                gram_rows = gram_rows[0]\n\n                si.pattern_info.stride_rows = 0\n                patterns_delta = [([(rr, cc) for rr in range(gram_rows) for cc in range(2)], None)]\n                game_to_patterns_delta[game] = patterns_delta\n            elif patterns_delta == PATTERN_DYN_3GRAM_COLS:\n                util.check(len(game_to_patterns_delta) == 1, 'multiple games stride')\n\n                gram_rows = [len(tli.tiles) for tli in ti.levels]\n                util.check(len(set(gram_rows)) == 1, 'all levels must be same height')\n                gram_rows = gram_rows[0]\n\n                si.pattern_info.stride_rows = 0\n                patterns_delta = [([(rr, cc) for rr in range(gram_rows) for cc in range(2)],\n                                   [(rr, 2) for rr in range(gram_rows)])]\n                game_to_patterns_delta[game] = patterns_delta\n            elif patterns_delta == PATTERN_DYN_2GRAM_ROWS:\n                util.check(len(game_to_patterns_delta) == 1, 'multiple games stride')\n\n                gram_cols = [len(tli.tiles[0]) for tli in ti.levels]\n                util.check(len(set(gram_cols)) == 1, 'all levels must be same width')\n                gram_cols = gram_cols[0]\n\n                si.pattern_info.stride_cols = 0\n                patterns_delta = [([(rr, cc) for rr in [0] for cc in range(gram_cols)],\n                                   [(1, cc) for cc in range(gram_cols)])]\n                game_to_patterns_delta[game] = patterns_delta\n            elif patterns_delta == PATTERN_DYN_ZGRAM_COLS:\n                util.check(len(game_to_patterns_delta) == 1, 'multiple games stride')\n\n                si.pattern_info.stride_rows = 11\n                patterns_delta = [([(rr, 0) for rr in range(11)],\n                                   [(rr, 1) for rr in range(11)]),\n                                  ([(10, 0)],\n                                   [(11, 0)])]\n                game_to_patterns_delta[game] = patterns_delta\n            elif patterns_delta == PATTERN_DYN_ROOMS:\n                util.check(len(game_to_patterns_delta) == 1, 'multiple games stride')\n\n                si.pattern_info.stride_rows = 11\n                si.pattern_info.stride_cols = 3\n                patterns_delta = [\n                    ([(rr, cc) for rr in range(11) for cc in range(3)],\n                     None),\n                    ([(rr, 2) for rr in range(11)],\n                     [(rr, 3) for rr in range(11)]),\n                    ([(10, cc) for cc in range(3)],\n                     [(11, cc) for cc in range(3)])\n                ]\n                game_to_patterns_delta[game] = patterns_delta\n\n        for game, patterns_delta in game_to_patterns_delta.items():\n            if patterns_delta is None:\n                si.pattern_info.game_to_patterns[game] = None\n            else:\n                si.pattern_info.game_to_patterns[game] = {}\n\n                for pattern_template_in, pattern_template_out in patterns_delta:\n                    for dr, dc in pattern_template_in + (pattern_template_out if pattern_template_out else []):\n                        si.pattern_info.dr_lo = min(si.pattern_info.dr_lo, dr)\n                        si.pattern_info.dr_hi = max(si.pattern_info.dr_hi, dr)\n                        si.pattern_info.dc_lo = min(si.pattern_info.dc_lo, dc)\n                        si.pattern_info.dc_hi = max(si.pattern_info.dc_hi, dc)\n\n    tile_levels, tag_levels, game_levels = [], [], []\n    for tli in ti.levels:\n        tile_level = tli.tiles\n        tag_level = tli.tags\n        game_level = tli.games\n\n        tile_levels.append(tile_level)\n        tag_levels.append(tag_level)\n        game_levels.append(game_level)\n\n        if level_rotate:\n            for ii in range(3):\n                tile_level = util.rotate_grid_cw(tile_level)\n                tag_level = util.rotate_grid_cw(tag_level)\n                game_level = util.rotate_grid_cw(game_level)\n\n                tile_levels.append(tile_level)\n                tag_levels.append(tag_level)\n                game_levels.append(game_level)\n\n    for tile_level, tag_level, game_level in zip(tile_levels, tag_levels, game_levels):\n        rows = len(tile_level)\n        cols = len(tile_level[0])\n\n        util.print_tile_level(tile_level)\n        print()\n\n        for rr in range(rows):\n            for cc in range(cols):\n                tile = tile_level[rr][cc]\n                tag = tag_level[rr][cc]\n                game = game_level[rr][cc]\n\n                util.check(game != util.VOID_TEXT, 'void game')\n                util.check((tile == util.VOID_TILE) == (tag == util.VOID_TEXT), 'void')\n                if tile == util.VOID_TILE:\n                    continue\n\n                if game not in si.game_to_tag_to_tiles:\n                    si.game_to_tag_to_tiles[game] = {}\n                if tag not in si.game_to_tag_to_tiles[game]:\n                    si.game_to_tag_to_tiles[game][tag] = {}\n                si.game_to_tag_to_tiles[game][tag][tile] = None\n\n        if si.count_info is not None:\n            util.check(si.count_info.divs_size[0] <= rows and si.count_info.divs_size[1] <= cols, 'level to small for divs')\n\n            for rr_divs in range(si.count_info.divs_size[0]):\n                for cc_divs in range(si.count_info.divs_size[1]):\n                    rr_lo = rows * (rr_divs + 0) // si.count_info.divs_size[0]\n                    rr_hi = rows * (rr_divs + 1) // si.count_info.divs_size[0]\n                    cc_lo = cols * (cc_divs + 0) // si.count_info.divs_size[1]\n                    cc_hi = cols * (cc_divs + 1) // si.count_info.divs_size[1]\n\n                    for game, tag_to_tiles in si.game_to_tag_to_tiles.items():\n                        if game not in si.count_info.divs_to_game_to_tag_to_tile_count[(rr_divs, cc_divs)]:\n                            si.count_info.divs_to_game_to_tag_to_tile_count[(rr_divs, cc_divs)][game] = {}\n\n                            for tag, tiles in tag_to_tiles.items():\n                                for tile in tiles:\n                                    inc(si.count_info.divs_to_game_to_tag_to_tile_count[(rr_divs, cc_divs)][game], tag, tile, 0)\n\n                    for rr in range(rr_lo, rr_hi):\n                        for cc in range(cc_lo, cc_hi):\n                            tile = tile_level[rr][cc]\n                            tag = tag_level[rr][cc]\n                            game = game_level[rr][cc]\n\n                            util.check(game != util.VOID_TEXT, 'void game')\n                            util.check((tile == util.VOID_TILE) == (tag == util.VOID_TEXT), 'void')\n                            if tile == util.VOID_TILE:\n                                continue\n\n                            inc(si.count_info.divs_to_game_to_tag_to_tile_count[(rr_divs, cc_divs)][game], tag, tile, 1)\n\n                    for game, tag_to_tiles in si.game_to_tag_to_tiles.items():\n                        for tag, tiles in tag_to_tiles.items():\n                            for tile in tiles:\n                                inc(si.count_info.divs_to_game_to_tag_to_tile_count[(rr_divs, cc_divs)][game], tag, tile, 0)\n\n        if si.pattern_info is not None:\n            row_range = range(-si.pattern_info.dr_hi, rows - si.pattern_info.dr_lo, si.pattern_info.stride_rows) if si.pattern_info.stride_rows else [0]\n            col_range = range(-si.pattern_info.dc_hi, cols - si.pattern_info.dc_lo, si.pattern_info.stride_cols) if si.pattern_info.stride_cols else [0]\n\n            for rr in row_range:\n                for cc in col_range:\n                    game = game_level[max(0, min(rows - 1, rr))][max(0, min(cols - 1, cc))]\n\n                    if game_to_patterns_delta[game] is None:\n                        continue\n\n                    def get_pattern(_template):\n                        _pattern = []\n                        for _dr, _dc in _template:\n                            _nr = rr + _dr\n                            _nc = cc + _dc\n\n                            if _nr <= -1 or _nr >= rows or _nc <= -1 or _nc >= cols:\n                                _nbr_tile = util.VOID_TILE\n                            else:\n                                _nbr_tile = tile_level[_nr][_nc]\n\n                            _pattern.append(_nbr_tile)\n                        return tuple(_pattern)\n\n                    for pattern_template_in, pattern_template_out in game_to_patterns_delta[game]:\n                        pattern_template_in = tuple(pattern_template_in)\n                        pattern_in = get_pattern(pattern_template_in)\n                        pattern_template_out = tuple(pattern_template_out) if pattern_template_out else None\n                        pattern_out = get_pattern(pattern_template_out) if pattern_template_out else None\n\n                        if pattern_template_in not in si.pattern_info.game_to_patterns[game]:\n                            si.pattern_info.game_to_patterns[game][pattern_template_in] = {}\n\n                        if pattern_in not in si.pattern_info.game_to_patterns[game][pattern_template_in]:\n                            si.pattern_info.game_to_patterns[game][pattern_template_in][pattern_in] = {}\n\n                        if pattern_template_out not in si.pattern_info.game_to_patterns[game][pattern_template_in][pattern_in]:\n                            si.pattern_info.game_to_patterns[game][pattern_template_in][pattern_in][pattern_template_out] = {}\n\n                        si.pattern_info.game_to_patterns[game][pattern_template_in][pattern_in][pattern_template_out][pattern_out] = None\n\n\n\n    if si.count_info is not None:\n        for grc in si.count_info.divs_to_game_to_tag_to_tile_count:\n            for game in si.count_info.divs_to_game_to_tag_to_tile_count[grc]:\n                normalize(si.count_info.divs_to_game_to_tag_to_tile_count[grc][game])\n\n    printer = pprint.PrettyPrinter(width=200)\n    printer.pprint(si.game_to_tag_to_tiles)\n\n    print()\n    if si.count_info is not None:\n        print('Counts:')\n        printer.pprint(si.count_info.divs_to_game_to_tag_to_tile_count)\n    else:\n        print('No counts.')\n\n    print()\n    if si.pattern_info is not None:\n        print('Patterns:')\n        print(si.pattern_info.dr_lo, si.pattern_info.dr_hi, si.pattern_info.dc_lo, si.pattern_info.dc_hi, si.pattern_info.stride_rows, si.pattern_info.stride_cols)\n        printer.pprint(si.pattern_info.game_to_patterns)\n    else:\n        print('No patterns.')\n\n    return si", "\ndef tiles2scheme(tile_info, divs_size, game_to_patterns_delta, level_rotate):\n    ti = tile_info\n    si = util.SchemeInfo()\n\n    si.tileset = ti.tileset\n\n    si.game_to_tag_to_tiles = {}\n\n    if divs_size is None:\n        si.count_info = None\n    else:\n        si.count_info = util.SchemeCountInfo()\n\n        si.count_info.divs_size = divs_size\n        si.count_info.divs_to_game_to_tag_to_tile_count = {}\n        for rr_divs in range(si.count_info.divs_size[0]):\n            for cc_divs in range(si.count_info.divs_size[1]):\n                si.count_info.divs_to_game_to_tag_to_tile_count[(rr_divs, cc_divs)] = {}\n\n    if game_to_patterns_delta is None:\n        si.pattern_info = None\n    else:\n        si.pattern_info = util.SchemePatternInfo()\n\n        si.pattern_info.game_to_patterns = {}\n\n        si.pattern_info.stride_rows = 1\n        si.pattern_info.stride_cols = 1\n        si.pattern_info.dr_lo = 0\n        si.pattern_info.dr_hi = 0\n        si.pattern_info.dc_lo = 0\n        si.pattern_info.dc_hi = 0\n\n        for game, patterns_delta in game_to_patterns_delta.items():\n            if patterns_delta == PATTERN_DYN_NO_OUT_2GRAM_COLS:\n                util.check(len(game_to_patterns_delta) == 1, 'multiple games stride')\n\n                gram_rows = [len(tli.tiles) for tli in ti.levels]\n                util.check(len(set(gram_rows)) == 1, 'all levels must be same height')\n                gram_rows = gram_rows[0]\n\n                si.pattern_info.stride_rows = 0\n                patterns_delta = [([(rr, cc) for rr in range(gram_rows) for cc in range(2)], None)]\n                game_to_patterns_delta[game] = patterns_delta\n            elif patterns_delta == PATTERN_DYN_3GRAM_COLS:\n                util.check(len(game_to_patterns_delta) == 1, 'multiple games stride')\n\n                gram_rows = [len(tli.tiles) for tli in ti.levels]\n                util.check(len(set(gram_rows)) == 1, 'all levels must be same height')\n                gram_rows = gram_rows[0]\n\n                si.pattern_info.stride_rows = 0\n                patterns_delta = [([(rr, cc) for rr in range(gram_rows) for cc in range(2)],\n                                   [(rr, 2) for rr in range(gram_rows)])]\n                game_to_patterns_delta[game] = patterns_delta\n            elif patterns_delta == PATTERN_DYN_2GRAM_ROWS:\n                util.check(len(game_to_patterns_delta) == 1, 'multiple games stride')\n\n                gram_cols = [len(tli.tiles[0]) for tli in ti.levels]\n                util.check(len(set(gram_cols)) == 1, 'all levels must be same width')\n                gram_cols = gram_cols[0]\n\n                si.pattern_info.stride_cols = 0\n                patterns_delta = [([(rr, cc) for rr in [0] for cc in range(gram_cols)],\n                                   [(1, cc) for cc in range(gram_cols)])]\n                game_to_patterns_delta[game] = patterns_delta\n            elif patterns_delta == PATTERN_DYN_ZGRAM_COLS:\n                util.check(len(game_to_patterns_delta) == 1, 'multiple games stride')\n\n                si.pattern_info.stride_rows = 11\n                patterns_delta = [([(rr, 0) for rr in range(11)],\n                                   [(rr, 1) for rr in range(11)]),\n                                  ([(10, 0)],\n                                   [(11, 0)])]\n                game_to_patterns_delta[game] = patterns_delta\n            elif patterns_delta == PATTERN_DYN_ROOMS:\n                util.check(len(game_to_patterns_delta) == 1, 'multiple games stride')\n\n                si.pattern_info.stride_rows = 11\n                si.pattern_info.stride_cols = 3\n                patterns_delta = [\n                    ([(rr, cc) for rr in range(11) for cc in range(3)],\n                     None),\n                    ([(rr, 2) for rr in range(11)],\n                     [(rr, 3) for rr in range(11)]),\n                    ([(10, cc) for cc in range(3)],\n                     [(11, cc) for cc in range(3)])\n                ]\n                game_to_patterns_delta[game] = patterns_delta\n\n        for game, patterns_delta in game_to_patterns_delta.items():\n            if patterns_delta is None:\n                si.pattern_info.game_to_patterns[game] = None\n            else:\n                si.pattern_info.game_to_patterns[game] = {}\n\n                for pattern_template_in, pattern_template_out in patterns_delta:\n                    for dr, dc in pattern_template_in + (pattern_template_out if pattern_template_out else []):\n                        si.pattern_info.dr_lo = min(si.pattern_info.dr_lo, dr)\n                        si.pattern_info.dr_hi = max(si.pattern_info.dr_hi, dr)\n                        si.pattern_info.dc_lo = min(si.pattern_info.dc_lo, dc)\n                        si.pattern_info.dc_hi = max(si.pattern_info.dc_hi, dc)\n\n    tile_levels, tag_levels, game_levels = [], [], []\n    for tli in ti.levels:\n        tile_level = tli.tiles\n        tag_level = tli.tags\n        game_level = tli.games\n\n        tile_levels.append(tile_level)\n        tag_levels.append(tag_level)\n        game_levels.append(game_level)\n\n        if level_rotate:\n            for ii in range(3):\n                tile_level = util.rotate_grid_cw(tile_level)\n                tag_level = util.rotate_grid_cw(tag_level)\n                game_level = util.rotate_grid_cw(game_level)\n\n                tile_levels.append(tile_level)\n                tag_levels.append(tag_level)\n                game_levels.append(game_level)\n\n    for tile_level, tag_level, game_level in zip(tile_levels, tag_levels, game_levels):\n        rows = len(tile_level)\n        cols = len(tile_level[0])\n\n        util.print_tile_level(tile_level)\n        print()\n\n        for rr in range(rows):\n            for cc in range(cols):\n                tile = tile_level[rr][cc]\n                tag = tag_level[rr][cc]\n                game = game_level[rr][cc]\n\n                util.check(game != util.VOID_TEXT, 'void game')\n                util.check((tile == util.VOID_TILE) == (tag == util.VOID_TEXT), 'void')\n                if tile == util.VOID_TILE:\n                    continue\n\n                if game not in si.game_to_tag_to_tiles:\n                    si.game_to_tag_to_tiles[game] = {}\n                if tag not in si.game_to_tag_to_tiles[game]:\n                    si.game_to_tag_to_tiles[game][tag] = {}\n                si.game_to_tag_to_tiles[game][tag][tile] = None\n\n        if si.count_info is not None:\n            util.check(si.count_info.divs_size[0] <= rows and si.count_info.divs_size[1] <= cols, 'level to small for divs')\n\n            for rr_divs in range(si.count_info.divs_size[0]):\n                for cc_divs in range(si.count_info.divs_size[1]):\n                    rr_lo = rows * (rr_divs + 0) // si.count_info.divs_size[0]\n                    rr_hi = rows * (rr_divs + 1) // si.count_info.divs_size[0]\n                    cc_lo = cols * (cc_divs + 0) // si.count_info.divs_size[1]\n                    cc_hi = cols * (cc_divs + 1) // si.count_info.divs_size[1]\n\n                    for game, tag_to_tiles in si.game_to_tag_to_tiles.items():\n                        if game not in si.count_info.divs_to_game_to_tag_to_tile_count[(rr_divs, cc_divs)]:\n                            si.count_info.divs_to_game_to_tag_to_tile_count[(rr_divs, cc_divs)][game] = {}\n\n                            for tag, tiles in tag_to_tiles.items():\n                                for tile in tiles:\n                                    inc(si.count_info.divs_to_game_to_tag_to_tile_count[(rr_divs, cc_divs)][game], tag, tile, 0)\n\n                    for rr in range(rr_lo, rr_hi):\n                        for cc in range(cc_lo, cc_hi):\n                            tile = tile_level[rr][cc]\n                            tag = tag_level[rr][cc]\n                            game = game_level[rr][cc]\n\n                            util.check(game != util.VOID_TEXT, 'void game')\n                            util.check((tile == util.VOID_TILE) == (tag == util.VOID_TEXT), 'void')\n                            if tile == util.VOID_TILE:\n                                continue\n\n                            inc(si.count_info.divs_to_game_to_tag_to_tile_count[(rr_divs, cc_divs)][game], tag, tile, 1)\n\n                    for game, tag_to_tiles in si.game_to_tag_to_tiles.items():\n                        for tag, tiles in tag_to_tiles.items():\n                            for tile in tiles:\n                                inc(si.count_info.divs_to_game_to_tag_to_tile_count[(rr_divs, cc_divs)][game], tag, tile, 0)\n\n        if si.pattern_info is not None:\n            row_range = range(-si.pattern_info.dr_hi, rows - si.pattern_info.dr_lo, si.pattern_info.stride_rows) if si.pattern_info.stride_rows else [0]\n            col_range = range(-si.pattern_info.dc_hi, cols - si.pattern_info.dc_lo, si.pattern_info.stride_cols) if si.pattern_info.stride_cols else [0]\n\n            for rr in row_range:\n                for cc in col_range:\n                    game = game_level[max(0, min(rows - 1, rr))][max(0, min(cols - 1, cc))]\n\n                    if game_to_patterns_delta[game] is None:\n                        continue\n\n                    def get_pattern(_template):\n                        _pattern = []\n                        for _dr, _dc in _template:\n                            _nr = rr + _dr\n                            _nc = cc + _dc\n\n                            if _nr <= -1 or _nr >= rows or _nc <= -1 or _nc >= cols:\n                                _nbr_tile = util.VOID_TILE\n                            else:\n                                _nbr_tile = tile_level[_nr][_nc]\n\n                            _pattern.append(_nbr_tile)\n                        return tuple(_pattern)\n\n                    for pattern_template_in, pattern_template_out in game_to_patterns_delta[game]:\n                        pattern_template_in = tuple(pattern_template_in)\n                        pattern_in = get_pattern(pattern_template_in)\n                        pattern_template_out = tuple(pattern_template_out) if pattern_template_out else None\n                        pattern_out = get_pattern(pattern_template_out) if pattern_template_out else None\n\n                        if pattern_template_in not in si.pattern_info.game_to_patterns[game]:\n                            si.pattern_info.game_to_patterns[game][pattern_template_in] = {}\n\n                        if pattern_in not in si.pattern_info.game_to_patterns[game][pattern_template_in]:\n                            si.pattern_info.game_to_patterns[game][pattern_template_in][pattern_in] = {}\n\n                        if pattern_template_out not in si.pattern_info.game_to_patterns[game][pattern_template_in][pattern_in]:\n                            si.pattern_info.game_to_patterns[game][pattern_template_in][pattern_in][pattern_template_out] = {}\n\n                        si.pattern_info.game_to_patterns[game][pattern_template_in][pattern_in][pattern_template_out][pattern_out] = None\n\n\n\n    if si.count_info is not None:\n        for grc in si.count_info.divs_to_game_to_tag_to_tile_count:\n            for game in si.count_info.divs_to_game_to_tag_to_tile_count[grc]:\n                normalize(si.count_info.divs_to_game_to_tag_to_tile_count[grc][game])\n\n    printer = pprint.PrettyPrinter(width=200)\n    printer.pprint(si.game_to_tag_to_tiles)\n\n    print()\n    if si.count_info is not None:\n        print('Counts:')\n        printer.pprint(si.count_info.divs_to_game_to_tag_to_tile_count)\n    else:\n        print('No counts.')\n\n    print()\n    if si.pattern_info is not None:\n        print('Patterns:')\n        print(si.pattern_info.dr_lo, si.pattern_info.dr_hi, si.pattern_info.dc_lo, si.pattern_info.dc_hi, si.pattern_info.stride_rows, si.pattern_info.stride_cols)\n        printer.pprint(si.pattern_info.game_to_patterns)\n    else:\n        print('No patterns.')\n\n    return si", "\n\n\nif __name__ == '__main__':\n    util.timer_start()\n\n    parser = argparse.ArgumentParser(description='Create scheme from tile info and (optionally) tag level.')\n    parser.add_argument('--outfile', required=True, type=str, help='Output scheme file.')\n    parser.add_argument('--tilefile', required=True, type=str, help='Input tile file.')\n    parser.add_argument('--countdivs', type=int, nargs=2)\n    parser.add_argument('--pattern', type=str, nargs='+', help='Pattern template, from: ' + ','.join(PATTERN_DICT.keys()) + '.')\n    parser.add_argument('--level-rotate', action='store_true', help='Rotate levels to create more patterns.')\n    parser.add_argument('--quiet', action='store_true', help='Reduce output.')\n    args = parser.parse_args()\n\n    if args.quiet:\n        sys.stdout = open(os.devnull, 'w')\n\n    with util.openz(args.tilefile, 'rb') as f:\n        tile_info = pickle.load(f)\n\n    if args.pattern is not None:\n        game_to_patterns_name = util.arg_list_to_dict_options(parser, '--pattern', args.pattern, PATTERN_DICT.keys())\n        game_to_patterns_delta = {}\n        for game, patterns_name in game_to_patterns_name.items():\n            game_to_patterns_delta[game] = PATTERN_DICT[patterns_name]\n    else:\n        game_to_patterns_delta = None\n\n    scheme_info = tiles2scheme(tile_info, args.countdivs, game_to_patterns_delta, args.level_rotate)\n    with util.openz(args.outfile, 'wb') as f:\n        pickle.dump(scheme_info, f)", ""]}
{"filename": "dot2graph.py", "chunked_list": ["import argparse, itertools, json, random, sys, time\nimport util, util_graph\nimport networkx as nx\n\nMULTILABEL = ';'\n\n\n\nif __name__ == '__main__':\n    util.timer_start()\n\n    parser = argparse.ArgumentParser(description='Convert a dot file to a graph file.')\n    parser.add_argument('--outfile', type=str, help='Output file.')\n    parser.add_argument('--dotfile', required=True, type=str, help='Input dot file.')\n    parser.add_argument('--root', type=str, help='Root node label; produces dag, otherwise produces ugraph.')\n    args = parser.parse_args()\n\n    dot = nx.DiGraph(nx.nx_pydot.read_dot(args.dotfile))\n\n    for node in dot.nodes:\n        dot.nodes[node][util_graph.ATTR_LABEL] = dot.nodes[node][util_graph.ATTR_LABEL].strip('\"')\n    for edge in dot.edges:\n        dot.edges[edge][util_graph.ATTR_LABEL] = dot.edges[edge][util_graph.ATTR_LABEL].strip('\"')\n\n    grs = util_graph.Graphs()\n    grs.colors = {}\n\n    if args.root:\n        grs.gtype = util_graph.GTYPE_DAG\n        root_node = None\n        for node in dot.nodes:\n            if dot.nodes[node][util_graph.ATTR_LABEL] == args.root:\n                util.check(root_node is None, 'multiple root nodes')\n                root_node = node\n        util.check(root_node is not None, 'no root node')\n\n        gr = nx.bfs_tree(dot, root_node)\n\n        for edge in dot.edges:\n            if not nx.has_path(gr, edge[1], edge[0]):\n                gr.add_edge(edge[0], edge[1])\n    else:\n        grs.gtype = util_graph.GTYPE_UGRAPH\n\n        gr = dot.to_undirected()\n\n    def orderlabels(lbls):\n        lbls = lbls.split(',')\n        lbls = [lbl.strip() for lbl in lbls]\n        lbls = [lbl for lbl in lbls if lbl != '']\n        lbls = sorted(lbls)\n        lbls = MULTILABEL.join(lbls)\n        return lbls\n\n    gr_orig = dot\n\n    for node in gr.nodes:\n        gr.nodes[node][util_graph.ATTR_LABEL] = orderlabels(gr_orig.nodes[node][util_graph.ATTR_LABEL])\n\n    for ea, eb in gr.edges:\n        lbla = gr_orig.edges[(ea, eb)][util_graph.ATTR_LABEL] if (ea, eb) in gr_orig.edges else ''\n        lblb = gr_orig.edges[(eb, ea)][util_graph.ATTR_LABEL] if (eb, ea) in gr_orig.edges else ''\n\n        if lbla == lblb or lblb == '':\n            lbl = lbla\n        elif lbla == '':\n            lbl = lblb\n        else:\n            lbl = lbla + MULTILABEL + lblb\n        gr.edges[(ea, eb)][util_graph.ATTR_LABEL] = orderlabels(lbl)\n\n    grs.graphs = [gr]\n\n    util_graph.write_graph_to_file(grs, args.outfile)", "if __name__ == '__main__':\n    util.timer_start()\n\n    parser = argparse.ArgumentParser(description='Convert a dot file to a graph file.')\n    parser.add_argument('--outfile', type=str, help='Output file.')\n    parser.add_argument('--dotfile', required=True, type=str, help='Input dot file.')\n    parser.add_argument('--root', type=str, help='Root node label; produces dag, otherwise produces ugraph.')\n    args = parser.parse_args()\n\n    dot = nx.DiGraph(nx.nx_pydot.read_dot(args.dotfile))\n\n    for node in dot.nodes:\n        dot.nodes[node][util_graph.ATTR_LABEL] = dot.nodes[node][util_graph.ATTR_LABEL].strip('\"')\n    for edge in dot.edges:\n        dot.edges[edge][util_graph.ATTR_LABEL] = dot.edges[edge][util_graph.ATTR_LABEL].strip('\"')\n\n    grs = util_graph.Graphs()\n    grs.colors = {}\n\n    if args.root:\n        grs.gtype = util_graph.GTYPE_DAG\n        root_node = None\n        for node in dot.nodes:\n            if dot.nodes[node][util_graph.ATTR_LABEL] == args.root:\n                util.check(root_node is None, 'multiple root nodes')\n                root_node = node\n        util.check(root_node is not None, 'no root node')\n\n        gr = nx.bfs_tree(dot, root_node)\n\n        for edge in dot.edges:\n            if not nx.has_path(gr, edge[1], edge[0]):\n                gr.add_edge(edge[0], edge[1])\n    else:\n        grs.gtype = util_graph.GTYPE_UGRAPH\n\n        gr = dot.to_undirected()\n\n    def orderlabels(lbls):\n        lbls = lbls.split(',')\n        lbls = [lbl.strip() for lbl in lbls]\n        lbls = [lbl for lbl in lbls if lbl != '']\n        lbls = sorted(lbls)\n        lbls = MULTILABEL.join(lbls)\n        return lbls\n\n    gr_orig = dot\n\n    for node in gr.nodes:\n        gr.nodes[node][util_graph.ATTR_LABEL] = orderlabels(gr_orig.nodes[node][util_graph.ATTR_LABEL])\n\n    for ea, eb in gr.edges:\n        lbla = gr_orig.edges[(ea, eb)][util_graph.ATTR_LABEL] if (ea, eb) in gr_orig.edges else ''\n        lblb = gr_orig.edges[(eb, ea)][util_graph.ATTR_LABEL] if (eb, ea) in gr_orig.edges else ''\n\n        if lbla == lblb or lblb == '':\n            lbl = lbla\n        elif lbla == '':\n            lbl = lblb\n        else:\n            lbl = lbla + MULTILABEL + lblb\n        gr.edges[(ea, eb)][util_graph.ATTR_LABEL] = orderlabels(lbl)\n\n    grs.graphs = [gr]\n\n    util_graph.write_graph_to_file(grs, args.outfile)", ""]}
{"filename": "gdesc2graph.py", "chunked_list": ["import argparse, itertools, json, pickle, random, sys, time\nimport solvers, util, util_graph\nimport networkx as nx\n\n\n\nCONNECT_REACH  = 'reach'\nCONNECT_LAYER  = 'layer'\nCONNECT_LIST   = [CONNECT_REACH, CONNECT_LAYER]\n", "CONNECT_LIST   = [CONNECT_REACH, CONNECT_LAYER]\n\nEDGEOPT_FULL   = 'full'\nEDGEOPT_BAND   = 'band'\nEDGEOPT_GRID   = 'grid'\nEDGEOPT_RECT   = 'rect'\nEDGEOPT_LIST   = [EDGEOPT_FULL, EDGEOPT_BAND, EDGEOPT_GRID, EDGEOPT_RECT]\n\ndef gdesc2graph(s, grd, min_size, max_size, edgeopt, edgeopt_params, label_min, label_max, label_count, connect, randomize):\n    # set up solver vars\n    util.timer_section('set up')\n\n    if label_min:\n        for ll in label_min:\n            util.check(ll == util.DEFAULT_TEXT or ll in grd.node_labels, 'no label_min')\n    if label_max:\n        for ll in label_max:\n            util.check(ll == util.DEFAULT_TEXT or ll in grd.node_labels, 'no label_max')\n\n    if edgeopt == EDGEOPT_FULL:\n        util.check(len(edgeopt_params) == 0, 'edgeopt_params')\n    elif edgeopt == EDGEOPT_BAND:\n        util.check(len(edgeopt_params) == 1, 'edgeopt_params')\n    elif edgeopt in [EDGEOPT_GRID, EDGEOPT_RECT]:\n        util.check(len(edgeopt_params) == 1, 'edgeopt_params')\n    else:\n        util.check(False, 'edgeopt')\n\n    # node labels\n    labels_plus_none = list(grd.node_labels) + [None]\n\n    vars_nodes_by_label = {}\n    for ll in labels_plus_none:\n        vars_nodes_by_label[ll] = []\n\n    node_id_order = list(range(max_size))\n    if randomize is not None:\n        rng = random.Random(randomize)\n        rng.shuffle(node_id_order)\n\n    vars_node_by_id = {}\n    for ii in node_id_order:\n        vars_node_by_id[ii] = {}\n        for ll in labels_plus_none:\n            vv = s.make_var()\n            vars_nodes_by_label[ll].append(vv)\n            vars_node_by_id[ii][ll] = vv\n        s.cnstr_count(list(vars_node_by_id[ii].values()), True, 1, 1, None)\n\n    # edge labels\n    edge_labels_plus_none = list(grd.edge_labels) + [None]\n\n    vars_edges_by_label = {}\n    for ll in edge_labels_plus_none:\n        vars_edges_by_label[ll] = []\n\n    vars_edge_by_id_by_label = {}\n    for ii in node_id_order:\n        if edgeopt == EDGEOPT_FULL:\n            jjs = range(ii + 1, max_size)\n        elif edgeopt == EDGEOPT_BAND:\n            band_size = edgeopt_params[0]\n            jjs = range(ii + 1, min(ii + band_size + 1, max_size))\n        elif edgeopt in [EDGEOPT_GRID, EDGEOPT_RECT]:\n            grid_stride = edgeopt_params[0]\n            jjs = []\n            if (ii + 1) < max_size and (ii + 1) % grid_stride != 0:\n                jjs.append(ii + 1)\n            if (ii + grid_stride) < max_size:\n                jjs.append(ii + grid_stride)\n        else:\n            util.check(False, 'edgeopt')\n\n        for jj in jjs:\n            vars_edge_by_id_by_label[(ii, jj)] = {}\n            for ll in edge_labels_plus_none:\n                vv = s.make_var()\n                vars_edge_by_id_by_label[(ii, jj)][ll] = vv\n                vars_edges_by_label[ll].append(vv)\n            s.cnstr_count(list(vars_edge_by_id_by_label[(ii, jj)].values()), True, 1, 1, None)\n\n            if edgeopt in [EDGEOPT_GRID, EDGEOPT_RECT]:\n                if jj == ii + 1:\n                    s.cnstr_count([vars_edge_by_id_by_label[(ii, jj)][None], vars_edge_by_id_by_label[(ii, jj)][util_graph.LABEL_GRID_SOUTH]], True, 1, 1, None)\n                elif jj == ii + grid_stride:\n                    s.cnstr_count([vars_edge_by_id_by_label[(ii, jj)][None], vars_edge_by_id_by_label[(ii, jj)][util_graph.LABEL_GRID_EAST]], True, 1, 1, None)\n\n    # how many nodes can be missing\n    s.cnstr_count(vars_nodes_by_label[None], True, 0, max_size - min_size, None)\n\n    # connected\n    if connect == CONNECT_REACH:\n        vars_node_connect = []\n        for ii in range(max_size):\n            vars_node_connect.append(s.make_var())\n\n        for ii in range(max_size):\n            # all nodes must be either missing or connected\n            # missing node not connected - covered by this\n            s.cnstr_count([vars_node_by_id[ii][None], vars_node_connect[ii]], True, 1, 1, None)\n\n        # other than first node, no incoming reachable means not reachable\n        for ii in range(1, max_size):\n            incoming = []\n            for jj in range(ii):\n                if (jj, ii) in vars_edge_by_id_by_label:\n                    incoming.append(s.make_conj([vars_node_connect[jj], vars_edge_by_id_by_label[(jj, ii)][None]], [True, False]))\n            s.cnstr_implies_disj(s.make_conj(incoming, False), True, [vars_node_connect[ii]], False, None)\n\n    elif connect == CONNECT_LAYER:\n        connect_layers = max_size // 2 + 1\n\n        vars_node_connect = []\n        for cc in range(connect_layers):\n            layer = {}\n            for ii in range(max_size):\n                layer[ii] = s.make_var()\n            vars_node_connect.append(layer)\n\n        s.cnstr_count(list(vars_node_connect[0].values()), True, 1, 1, None)\n        for cc in range(1, connect_layers):\n            for ii in range(max_size):\n                incoming = []\n                for jj in range(max_size):\n                    if ii == jj:\n                        continue\n                    ei, ej = min(ii, jj), max(ii, jj)\n                    if (ei, ej) in vars_edge_by_id_by_label:\n                        incoming.append(s.make_conj([vars_node_connect[cc - 1][jj], vars_edge_by_id_by_label[(ei, ej)][None]], [True, False]))\n                s.cnstr_implies_disj(s.make_conj([vars_node_connect[cc - 1][ii]] + incoming, False), True, [vars_node_connect[cc][ii]], False, None)\n\n        for ii in range(max_size):\n            s.cnstr_count([vars_node_connect[connect_layers - 1][ii], vars_node_by_id[ii][None]], True, 1, 1, None)\n\n    else:\n        util.check(False, 'connect')\n\n    # tree\n    if util_graph.gtype_tree(grd.gtype):\n        missing_edges = vars_edges_by_label[None]\n        missing_nodes = vars_nodes_by_label[None]\n        s.cnstr_count(missing_edges + missing_nodes, [False] * len(missing_edges) + [True] * len(missing_nodes), max_size - 1, max_size - 1, None)\n\n    # node label counts\n    for ll in grd.node_labels:\n        ll_min, ll_max = 0, max_size\n\n        if label_min:\n            if ll in label_min:\n                ll_min = max(ll_min, label_min[ll])\n            elif util.DEFAULT_TEXT in label_min:\n                ll_min = max(ll_min, label_min[util.DEFAULT_TEXT])\n\n        if label_max:\n            if ll in label_max:\n                ll_max = min(ll_max, label_max[ll])\n            elif util.DEFAULT_TEXT in label_max:\n                ll_max = min(ll_max, label_max[util.DEFAULT_TEXT])\n\n        if label_count:\n            ll_min = max(ll_min, int(min_size * 0.5 * grd.node_label_count[ll]))\n            ll_max = min(ll_max, int(max_size * 1.5 * grd.node_label_count[ll]))\n\n        if (ll_min, ll_max) != (0, max_size):\n            s.cnstr_count(vars_nodes_by_label[ll], True, ll_min, ll_max, None)\n\n    # cache patterns\n    _conjs = {}\n    def make_conj(vvs, settings):\n        nonlocal s, _conjs\n        key = tuple(sorted(zip(vvs, settings)))\n        if key not in _conjs:\n            _conjs[key] = s.make_conj(vvs, settings)\n        return _conjs[key]\n\n    # add structure constraints\n    if edgeopt in [EDGEOPT_GRID, EDGEOPT_RECT]:\n        if edgeopt == EDGEOPT_RECT:\n            # first column set\n            for ii in range(grid_stride):\n                s.cnstr_count([vars_node_by_id[ii][None]], False, 1, 1, None)\n\n            # any in column set makes whole column set\n            for ii in range(0, max_size, grid_stride):\n                for jj in range(ii, min(ii + grid_stride, max_size)):\n                    for kk in range(ii, min(ii + grid_stride, max_size)):\n                        s.cnstr_implies_disj(vars_node_by_id[jj][None], False, [vars_node_by_id[kk][None]], False, None)\n\n        # make squares\n        grid_stride = edgeopt_params[0]\n        for ii in node_id_order:\n            # 0 a 1\n            # b   c\n            # 2 d 3\n            ea = (ii, ii + grid_stride)\n            eb = (ii, ii + 1)\n            ec = (ii + grid_stride, ii + 1 + grid_stride)\n            ed = (ii + 1, ii + 1 + grid_stride)\n\n            if ea not in vars_edge_by_id_by_label or eb not in vars_edge_by_id_by_label or ec not in vars_edge_by_id_by_label or ed not in vars_edge_by_id_by_label:\n                continue\n\n            eav = vars_edge_by_id_by_label[ea][util_graph.LABEL_GRID_EAST]\n            ebv = vars_edge_by_id_by_label[eb][util_graph.LABEL_GRID_SOUTH]\n            ecv = vars_edge_by_id_by_label[ec][util_graph.LABEL_GRID_SOUTH]\n            edv = vars_edge_by_id_by_label[ed][util_graph.LABEL_GRID_EAST]\n\n            s.cnstr_implies_disj(make_conj([ebv, ecv, edv], [True, True, True]), True, [eav], True, None)\n            s.cnstr_implies_disj(make_conj([eav, ecv, edv], [True, True, True]), True, [ebv], True, None)\n            s.cnstr_implies_disj(make_conj([eav, ebv, edv], [True, True, True]), True, [ecv], True, None)\n            s.cnstr_implies_disj(make_conj([eav, ebv, ecv], [True, True, True]), True, [edv], True, None)\n\n    if False:#edgeopt == EDGEOPT_GRID: # TODO: separate option?\n        util.timer_section('add structure constraints')\n\n        # NOTE: with node setting rules, can change number of rows by leaving the bottom ones blank\n\n        # first column set\n        for ii in range(grid_stride):\n            s.cnstr_count([vars_node_by_id[ii][None]], False, 1, 1, None)\n\n        # any in column set makes whole column set\n        for ii in range(0, max_size, grid_stride):\n            for jj in range(ii, min(ii + grid_stride, max_size)):\n                for kk in range(ii, min(ii + grid_stride, max_size)):\n                    s.cnstr_implies_disj(vars_node_by_id[jj][None], False, [vars_node_by_id[kk][None]], False, None)\n\n        # make squares\n        grid_stride = edgeopt_params[0]\n        for ii in node_id_order:\n            # 0 a 1\n            # b   c\n            # 2 d 3\n            ea = (ii, ii + grid_stride)\n            eb = (ii, ii + 1)\n            ec = (ii + grid_stride, ii + 1 + grid_stride)\n            ed = (ii + 1, ii + 1 + grid_stride)\n\n            if ea not in vars_edge_by_id_by_label or eb not in vars_edge_by_id_by_label or ec not in vars_edge_by_id_by_label or ed not in vars_edge_by_id_by_label:\n                continue\n\n            eav = vars_edge_by_id_by_label[ea][util_graph.LABEL_GRID_EAST]\n            ebv = vars_edge_by_id_by_label[eb][util_graph.LABEL_GRID_SOUTH]\n            ecv = vars_edge_by_id_by_label[ec][util_graph.LABEL_GRID_SOUTH]\n            edv = vars_edge_by_id_by_label[ed][util_graph.LABEL_GRID_EAST]\n\n            s.cnstr_implies_disj(make_conj([eav, ebv], [True, True]), True, [ecv], True, None)\n            s.cnstr_implies_disj(make_conj([eav, ebv], [True, True]), True, [edv], True, None)\n\n            s.cnstr_implies_disj(make_conj([ebv, edv], [True, True]), True, [eav], True, None)\n            s.cnstr_implies_disj(make_conj([ebv, edv], [True, True]), True, [ecv], True, None)\n\n            s.cnstr_implies_disj(make_conj([eav, ecv], [True, True]), True, [ebv], True, None)\n            s.cnstr_implies_disj(make_conj([eav, ecv], [True, True]), True, [edv], True, None)\n\n            s.cnstr_implies_disj(make_conj([ecv, edv], [True, True]), True, [eav], True, None)\n            s.cnstr_implies_disj(make_conj([ecv, edv], [True, True]), True, [ebv], True, None)\n\n    if False:#edgeopt == EDGEOPT_GRID: # TODO: separate option?\n        util.timer_section('add structure constraints')\n\n        nodes_set = itertools.product(node_id_order, repeat=3)\n        for np in nodes_set:\n            structures = [\n                # 0 > 1\n                # v   v\n                # 2 > X\n                [(np[0], np[1]), util_graph.LABEL_GRID_EAST,\n                 (np[0], np[2]), util_graph.LABEL_GRID_SOUTH,\n                 (np[1],  None), util_graph.LABEL_GRID_SOUTH,\n                 (np[2],  None), util_graph.LABEL_GRID_EAST],\n                # X > 0\n                # v   v\n                # 1 > 2\n                [(np[0], np[2]), util_graph.LABEL_GRID_SOUTH,\n                 (np[1], np[2]), util_graph.LABEL_GRID_EAST,\n                 ( None, np[0]), util_graph.LABEL_GRID_EAST,\n                 ( None, np[1]), util_graph.LABEL_GRID_SOUTH],\n                # 0 > X\n                # v   v\n                # 1 > 2\n                [(np[0], np[1]), util_graph.LABEL_GRID_SOUTH,\n                 (np[1], np[2]), util_graph.LABEL_GRID_EAST,\n                 (np[0],  None), util_graph.LABEL_GRID_EAST,\n                 ( None, np[2]), util_graph.LABEL_GRID_SOUTH],\n                # 0 > 1\n                # v   v\n                # X > 2\n                [(np[0], np[1]), util_graph.LABEL_GRID_EAST,\n                 (np[1], np[2]), util_graph.LABEL_GRID_SOUTH,\n                 (np[0],  None), util_graph.LABEL_GRID_SOUTH,\n                 ( None, np[2]), util_graph.LABEL_GRID_EAST]\n            ]\n\n            for ea, eal, eb, ebl, ect, ecl, edt, edl in structures:\n                if ea not in vars_edge_by_id_by_label or eb not in vars_edge_by_id_by_label:\n                    continue\n\n                eav = vars_edge_by_id_by_label[ea][eal]\n                ebv = vars_edge_by_id_by_label[eb][ebl]\n                part = make_conj([eav, ebv], [True, True])\n\n                completions = []\n                for npx in node_id_order:\n                    ec = tuple([(ee if ee is not None else npx) for ee in ect])\n                    ed = tuple([(ee if ee is not None else npx) for ee in edt])\n                    if ec not in vars_edge_by_id_by_label or ed not in vars_edge_by_id_by_label:\n                        continue\n\n                    ecv = vars_edge_by_id_by_label[ec][ecl]\n                    edv = vars_edge_by_id_by_label[ed][edl]\n                    completions.append(make_conj([ecv, edv], [True, True]))\n\n                s.cnstr_implies_disj(part, True, completions, True, None)\n\n    # add neighbor constraints\n    util.timer_section('add neighbor constraints')\n\n    for ii in node_id_order:\n        edges_vars = []\n        edges_dir = []\n        edges_other_node = []\n        for jj in node_id_order:\n            if ii == jj:\n                continue\n            ei, ej = min(ii, jj), max(ii, jj)\n            if (ei, ej) in vars_edge_by_id_by_label:\n                edges_vars.append(vars_edge_by_id_by_label[(ei, ej)])\n                edges_dir.append(None if not util_graph.gtype_directed(grd.gtype) else (util_graph.DIR_FRA if jj < ii else util_graph.DIR_TIL))\n                edges_other_node.append(jj)\n\n        # missing node has no edges; using conj seems to work better than multiple individual implies\n        s.cnstr_implies_disj(vars_node_by_id[ii][None], True, [make_conj([edge[None] for edge in edges_vars], [True] * len(edges_vars))], True, None)\n\n        # apply from description\n        for label in grd.node_labels:\n            patts = []\n            for nbrs in grd.node_label_neighbors[label]:\n                edge_inds_set = util.corner_indices(len(edges_vars), len(nbrs))\n                for edge_inds in edge_inds_set:\n                    for nbrs_perm in itertools.permutations(range(len(nbrs))):\n                        nodes = []\n                        edges = [ev[None] for ev in edges_vars]\n                        for edge_ind, nbr_ind in zip(edge_inds, nbrs_perm):\n                            nbr_node_label, nbr_edge_label, nbr_edge_dir = nbrs[nbr_ind]\n                            if nbr_edge_dir == edges_dir[edge_ind]:\n                                if nbr_node_label is not None:\n                                    nodes.append(vars_node_by_id[edges_other_node[edge_ind]][nbr_node_label])\n                                edges[edge_ind] = edges_vars[edge_ind][nbr_edge_label]\n                            else:\n                                nodes, edges = None, None\n                                break\n                        if nodes is not None:\n                            patts.append(make_conj(edges + nodes, [True] * (len(edges) + len(nodes))))\n\n            if len(patts) == 0:\n                s.cnstr_count([vars_node_by_id[ii][label]], True, 0, 0, None)\n            else:\n                s.cnstr_implies_disj(vars_node_by_id[ii][label], True, patts, True, None)\n\n    util.timer_section('solve')\n\n    result = None\n    if s.solve():\n        util.timer_section('create graph')\n\n        if util_graph.gtype_directed(grd.gtype):\n            gr = nx.DiGraph()\n        else:\n            gr = nx.Graph()\n\n        for ii, vvs in vars_node_by_id.items():\n            label = False\n            for ll, vv in vvs.items():\n                if s.get_var(vv):\n                    util.check(label == False, 'multiple labels')\n                    label = ll\n            util.check(label != False, 'no label')\n            if label is not None:\n                gr.add_node(ii)\n                gr.nodes[ii][util_graph.ATTR_LABEL] = label\n\n        for (ii, jj), vvs in vars_edge_by_id_by_label.items():\n            label = False\n            for ll, vv in vvs.items():\n                if s.get_var(vv):\n                    util.check(label == False, 'multiple labels')\n                    label = ll\n            util.check(label != False, 'no label')\n            if label is not None:\n                gr.add_edge(ii, jj)\n                gr.edges[(ii, jj)][util_graph.ATTR_LABEL] = label\n\n        util_graph.check_graph(gr, grd.gtype)\n\n        if edgeopt in [EDGEOPT_GRID, EDGEOPT_RECT]:\n            util_graph.layout_grid(gr)\n\n        grs = util_graph.Graphs()\n        grs.gtype = grd.gtype\n        grs.colors = grd.colors\n        grs.graphs = [gr]\n        result = grs\n\n    util.timer_section(None)\n\n    return result", "def gdesc2graph(s, grd, min_size, max_size, edgeopt, edgeopt_params, label_min, label_max, label_count, connect, randomize):\n    # set up solver vars\n    util.timer_section('set up')\n\n    if label_min:\n        for ll in label_min:\n            util.check(ll == util.DEFAULT_TEXT or ll in grd.node_labels, 'no label_min')\n    if label_max:\n        for ll in label_max:\n            util.check(ll == util.DEFAULT_TEXT or ll in grd.node_labels, 'no label_max')\n\n    if edgeopt == EDGEOPT_FULL:\n        util.check(len(edgeopt_params) == 0, 'edgeopt_params')\n    elif edgeopt == EDGEOPT_BAND:\n        util.check(len(edgeopt_params) == 1, 'edgeopt_params')\n    elif edgeopt in [EDGEOPT_GRID, EDGEOPT_RECT]:\n        util.check(len(edgeopt_params) == 1, 'edgeopt_params')\n    else:\n        util.check(False, 'edgeopt')\n\n    # node labels\n    labels_plus_none = list(grd.node_labels) + [None]\n\n    vars_nodes_by_label = {}\n    for ll in labels_plus_none:\n        vars_nodes_by_label[ll] = []\n\n    node_id_order = list(range(max_size))\n    if randomize is not None:\n        rng = random.Random(randomize)\n        rng.shuffle(node_id_order)\n\n    vars_node_by_id = {}\n    for ii in node_id_order:\n        vars_node_by_id[ii] = {}\n        for ll in labels_plus_none:\n            vv = s.make_var()\n            vars_nodes_by_label[ll].append(vv)\n            vars_node_by_id[ii][ll] = vv\n        s.cnstr_count(list(vars_node_by_id[ii].values()), True, 1, 1, None)\n\n    # edge labels\n    edge_labels_plus_none = list(grd.edge_labels) + [None]\n\n    vars_edges_by_label = {}\n    for ll in edge_labels_plus_none:\n        vars_edges_by_label[ll] = []\n\n    vars_edge_by_id_by_label = {}\n    for ii in node_id_order:\n        if edgeopt == EDGEOPT_FULL:\n            jjs = range(ii + 1, max_size)\n        elif edgeopt == EDGEOPT_BAND:\n            band_size = edgeopt_params[0]\n            jjs = range(ii + 1, min(ii + band_size + 1, max_size))\n        elif edgeopt in [EDGEOPT_GRID, EDGEOPT_RECT]:\n            grid_stride = edgeopt_params[0]\n            jjs = []\n            if (ii + 1) < max_size and (ii + 1) % grid_stride != 0:\n                jjs.append(ii + 1)\n            if (ii + grid_stride) < max_size:\n                jjs.append(ii + grid_stride)\n        else:\n            util.check(False, 'edgeopt')\n\n        for jj in jjs:\n            vars_edge_by_id_by_label[(ii, jj)] = {}\n            for ll in edge_labels_plus_none:\n                vv = s.make_var()\n                vars_edge_by_id_by_label[(ii, jj)][ll] = vv\n                vars_edges_by_label[ll].append(vv)\n            s.cnstr_count(list(vars_edge_by_id_by_label[(ii, jj)].values()), True, 1, 1, None)\n\n            if edgeopt in [EDGEOPT_GRID, EDGEOPT_RECT]:\n                if jj == ii + 1:\n                    s.cnstr_count([vars_edge_by_id_by_label[(ii, jj)][None], vars_edge_by_id_by_label[(ii, jj)][util_graph.LABEL_GRID_SOUTH]], True, 1, 1, None)\n                elif jj == ii + grid_stride:\n                    s.cnstr_count([vars_edge_by_id_by_label[(ii, jj)][None], vars_edge_by_id_by_label[(ii, jj)][util_graph.LABEL_GRID_EAST]], True, 1, 1, None)\n\n    # how many nodes can be missing\n    s.cnstr_count(vars_nodes_by_label[None], True, 0, max_size - min_size, None)\n\n    # connected\n    if connect == CONNECT_REACH:\n        vars_node_connect = []\n        for ii in range(max_size):\n            vars_node_connect.append(s.make_var())\n\n        for ii in range(max_size):\n            # all nodes must be either missing or connected\n            # missing node not connected - covered by this\n            s.cnstr_count([vars_node_by_id[ii][None], vars_node_connect[ii]], True, 1, 1, None)\n\n        # other than first node, no incoming reachable means not reachable\n        for ii in range(1, max_size):\n            incoming = []\n            for jj in range(ii):\n                if (jj, ii) in vars_edge_by_id_by_label:\n                    incoming.append(s.make_conj([vars_node_connect[jj], vars_edge_by_id_by_label[(jj, ii)][None]], [True, False]))\n            s.cnstr_implies_disj(s.make_conj(incoming, False), True, [vars_node_connect[ii]], False, None)\n\n    elif connect == CONNECT_LAYER:\n        connect_layers = max_size // 2 + 1\n\n        vars_node_connect = []\n        for cc in range(connect_layers):\n            layer = {}\n            for ii in range(max_size):\n                layer[ii] = s.make_var()\n            vars_node_connect.append(layer)\n\n        s.cnstr_count(list(vars_node_connect[0].values()), True, 1, 1, None)\n        for cc in range(1, connect_layers):\n            for ii in range(max_size):\n                incoming = []\n                for jj in range(max_size):\n                    if ii == jj:\n                        continue\n                    ei, ej = min(ii, jj), max(ii, jj)\n                    if (ei, ej) in vars_edge_by_id_by_label:\n                        incoming.append(s.make_conj([vars_node_connect[cc - 1][jj], vars_edge_by_id_by_label[(ei, ej)][None]], [True, False]))\n                s.cnstr_implies_disj(s.make_conj([vars_node_connect[cc - 1][ii]] + incoming, False), True, [vars_node_connect[cc][ii]], False, None)\n\n        for ii in range(max_size):\n            s.cnstr_count([vars_node_connect[connect_layers - 1][ii], vars_node_by_id[ii][None]], True, 1, 1, None)\n\n    else:\n        util.check(False, 'connect')\n\n    # tree\n    if util_graph.gtype_tree(grd.gtype):\n        missing_edges = vars_edges_by_label[None]\n        missing_nodes = vars_nodes_by_label[None]\n        s.cnstr_count(missing_edges + missing_nodes, [False] * len(missing_edges) + [True] * len(missing_nodes), max_size - 1, max_size - 1, None)\n\n    # node label counts\n    for ll in grd.node_labels:\n        ll_min, ll_max = 0, max_size\n\n        if label_min:\n            if ll in label_min:\n                ll_min = max(ll_min, label_min[ll])\n            elif util.DEFAULT_TEXT in label_min:\n                ll_min = max(ll_min, label_min[util.DEFAULT_TEXT])\n\n        if label_max:\n            if ll in label_max:\n                ll_max = min(ll_max, label_max[ll])\n            elif util.DEFAULT_TEXT in label_max:\n                ll_max = min(ll_max, label_max[util.DEFAULT_TEXT])\n\n        if label_count:\n            ll_min = max(ll_min, int(min_size * 0.5 * grd.node_label_count[ll]))\n            ll_max = min(ll_max, int(max_size * 1.5 * grd.node_label_count[ll]))\n\n        if (ll_min, ll_max) != (0, max_size):\n            s.cnstr_count(vars_nodes_by_label[ll], True, ll_min, ll_max, None)\n\n    # cache patterns\n    _conjs = {}\n    def make_conj(vvs, settings):\n        nonlocal s, _conjs\n        key = tuple(sorted(zip(vvs, settings)))\n        if key not in _conjs:\n            _conjs[key] = s.make_conj(vvs, settings)\n        return _conjs[key]\n\n    # add structure constraints\n    if edgeopt in [EDGEOPT_GRID, EDGEOPT_RECT]:\n        if edgeopt == EDGEOPT_RECT:\n            # first column set\n            for ii in range(grid_stride):\n                s.cnstr_count([vars_node_by_id[ii][None]], False, 1, 1, None)\n\n            # any in column set makes whole column set\n            for ii in range(0, max_size, grid_stride):\n                for jj in range(ii, min(ii + grid_stride, max_size)):\n                    for kk in range(ii, min(ii + grid_stride, max_size)):\n                        s.cnstr_implies_disj(vars_node_by_id[jj][None], False, [vars_node_by_id[kk][None]], False, None)\n\n        # make squares\n        grid_stride = edgeopt_params[0]\n        for ii in node_id_order:\n            # 0 a 1\n            # b   c\n            # 2 d 3\n            ea = (ii, ii + grid_stride)\n            eb = (ii, ii + 1)\n            ec = (ii + grid_stride, ii + 1 + grid_stride)\n            ed = (ii + 1, ii + 1 + grid_stride)\n\n            if ea not in vars_edge_by_id_by_label or eb not in vars_edge_by_id_by_label or ec not in vars_edge_by_id_by_label or ed not in vars_edge_by_id_by_label:\n                continue\n\n            eav = vars_edge_by_id_by_label[ea][util_graph.LABEL_GRID_EAST]\n            ebv = vars_edge_by_id_by_label[eb][util_graph.LABEL_GRID_SOUTH]\n            ecv = vars_edge_by_id_by_label[ec][util_graph.LABEL_GRID_SOUTH]\n            edv = vars_edge_by_id_by_label[ed][util_graph.LABEL_GRID_EAST]\n\n            s.cnstr_implies_disj(make_conj([ebv, ecv, edv], [True, True, True]), True, [eav], True, None)\n            s.cnstr_implies_disj(make_conj([eav, ecv, edv], [True, True, True]), True, [ebv], True, None)\n            s.cnstr_implies_disj(make_conj([eav, ebv, edv], [True, True, True]), True, [ecv], True, None)\n            s.cnstr_implies_disj(make_conj([eav, ebv, ecv], [True, True, True]), True, [edv], True, None)\n\n    if False:#edgeopt == EDGEOPT_GRID: # TODO: separate option?\n        util.timer_section('add structure constraints')\n\n        # NOTE: with node setting rules, can change number of rows by leaving the bottom ones blank\n\n        # first column set\n        for ii in range(grid_stride):\n            s.cnstr_count([vars_node_by_id[ii][None]], False, 1, 1, None)\n\n        # any in column set makes whole column set\n        for ii in range(0, max_size, grid_stride):\n            for jj in range(ii, min(ii + grid_stride, max_size)):\n                for kk in range(ii, min(ii + grid_stride, max_size)):\n                    s.cnstr_implies_disj(vars_node_by_id[jj][None], False, [vars_node_by_id[kk][None]], False, None)\n\n        # make squares\n        grid_stride = edgeopt_params[0]\n        for ii in node_id_order:\n            # 0 a 1\n            # b   c\n            # 2 d 3\n            ea = (ii, ii + grid_stride)\n            eb = (ii, ii + 1)\n            ec = (ii + grid_stride, ii + 1 + grid_stride)\n            ed = (ii + 1, ii + 1 + grid_stride)\n\n            if ea not in vars_edge_by_id_by_label or eb not in vars_edge_by_id_by_label or ec not in vars_edge_by_id_by_label or ed not in vars_edge_by_id_by_label:\n                continue\n\n            eav = vars_edge_by_id_by_label[ea][util_graph.LABEL_GRID_EAST]\n            ebv = vars_edge_by_id_by_label[eb][util_graph.LABEL_GRID_SOUTH]\n            ecv = vars_edge_by_id_by_label[ec][util_graph.LABEL_GRID_SOUTH]\n            edv = vars_edge_by_id_by_label[ed][util_graph.LABEL_GRID_EAST]\n\n            s.cnstr_implies_disj(make_conj([eav, ebv], [True, True]), True, [ecv], True, None)\n            s.cnstr_implies_disj(make_conj([eav, ebv], [True, True]), True, [edv], True, None)\n\n            s.cnstr_implies_disj(make_conj([ebv, edv], [True, True]), True, [eav], True, None)\n            s.cnstr_implies_disj(make_conj([ebv, edv], [True, True]), True, [ecv], True, None)\n\n            s.cnstr_implies_disj(make_conj([eav, ecv], [True, True]), True, [ebv], True, None)\n            s.cnstr_implies_disj(make_conj([eav, ecv], [True, True]), True, [edv], True, None)\n\n            s.cnstr_implies_disj(make_conj([ecv, edv], [True, True]), True, [eav], True, None)\n            s.cnstr_implies_disj(make_conj([ecv, edv], [True, True]), True, [ebv], True, None)\n\n    if False:#edgeopt == EDGEOPT_GRID: # TODO: separate option?\n        util.timer_section('add structure constraints')\n\n        nodes_set = itertools.product(node_id_order, repeat=3)\n        for np in nodes_set:\n            structures = [\n                # 0 > 1\n                # v   v\n                # 2 > X\n                [(np[0], np[1]), util_graph.LABEL_GRID_EAST,\n                 (np[0], np[2]), util_graph.LABEL_GRID_SOUTH,\n                 (np[1],  None), util_graph.LABEL_GRID_SOUTH,\n                 (np[2],  None), util_graph.LABEL_GRID_EAST],\n                # X > 0\n                # v   v\n                # 1 > 2\n                [(np[0], np[2]), util_graph.LABEL_GRID_SOUTH,\n                 (np[1], np[2]), util_graph.LABEL_GRID_EAST,\n                 ( None, np[0]), util_graph.LABEL_GRID_EAST,\n                 ( None, np[1]), util_graph.LABEL_GRID_SOUTH],\n                # 0 > X\n                # v   v\n                # 1 > 2\n                [(np[0], np[1]), util_graph.LABEL_GRID_SOUTH,\n                 (np[1], np[2]), util_graph.LABEL_GRID_EAST,\n                 (np[0],  None), util_graph.LABEL_GRID_EAST,\n                 ( None, np[2]), util_graph.LABEL_GRID_SOUTH],\n                # 0 > 1\n                # v   v\n                # X > 2\n                [(np[0], np[1]), util_graph.LABEL_GRID_EAST,\n                 (np[1], np[2]), util_graph.LABEL_GRID_SOUTH,\n                 (np[0],  None), util_graph.LABEL_GRID_SOUTH,\n                 ( None, np[2]), util_graph.LABEL_GRID_EAST]\n            ]\n\n            for ea, eal, eb, ebl, ect, ecl, edt, edl in structures:\n                if ea not in vars_edge_by_id_by_label or eb not in vars_edge_by_id_by_label:\n                    continue\n\n                eav = vars_edge_by_id_by_label[ea][eal]\n                ebv = vars_edge_by_id_by_label[eb][ebl]\n                part = make_conj([eav, ebv], [True, True])\n\n                completions = []\n                for npx in node_id_order:\n                    ec = tuple([(ee if ee is not None else npx) for ee in ect])\n                    ed = tuple([(ee if ee is not None else npx) for ee in edt])\n                    if ec not in vars_edge_by_id_by_label or ed not in vars_edge_by_id_by_label:\n                        continue\n\n                    ecv = vars_edge_by_id_by_label[ec][ecl]\n                    edv = vars_edge_by_id_by_label[ed][edl]\n                    completions.append(make_conj([ecv, edv], [True, True]))\n\n                s.cnstr_implies_disj(part, True, completions, True, None)\n\n    # add neighbor constraints\n    util.timer_section('add neighbor constraints')\n\n    for ii in node_id_order:\n        edges_vars = []\n        edges_dir = []\n        edges_other_node = []\n        for jj in node_id_order:\n            if ii == jj:\n                continue\n            ei, ej = min(ii, jj), max(ii, jj)\n            if (ei, ej) in vars_edge_by_id_by_label:\n                edges_vars.append(vars_edge_by_id_by_label[(ei, ej)])\n                edges_dir.append(None if not util_graph.gtype_directed(grd.gtype) else (util_graph.DIR_FRA if jj < ii else util_graph.DIR_TIL))\n                edges_other_node.append(jj)\n\n        # missing node has no edges; using conj seems to work better than multiple individual implies\n        s.cnstr_implies_disj(vars_node_by_id[ii][None], True, [make_conj([edge[None] for edge in edges_vars], [True] * len(edges_vars))], True, None)\n\n        # apply from description\n        for label in grd.node_labels:\n            patts = []\n            for nbrs in grd.node_label_neighbors[label]:\n                edge_inds_set = util.corner_indices(len(edges_vars), len(nbrs))\n                for edge_inds in edge_inds_set:\n                    for nbrs_perm in itertools.permutations(range(len(nbrs))):\n                        nodes = []\n                        edges = [ev[None] for ev in edges_vars]\n                        for edge_ind, nbr_ind in zip(edge_inds, nbrs_perm):\n                            nbr_node_label, nbr_edge_label, nbr_edge_dir = nbrs[nbr_ind]\n                            if nbr_edge_dir == edges_dir[edge_ind]:\n                                if nbr_node_label is not None:\n                                    nodes.append(vars_node_by_id[edges_other_node[edge_ind]][nbr_node_label])\n                                edges[edge_ind] = edges_vars[edge_ind][nbr_edge_label]\n                            else:\n                                nodes, edges = None, None\n                                break\n                        if nodes is not None:\n                            patts.append(make_conj(edges + nodes, [True] * (len(edges) + len(nodes))))\n\n            if len(patts) == 0:\n                s.cnstr_count([vars_node_by_id[ii][label]], True, 0, 0, None)\n            else:\n                s.cnstr_implies_disj(vars_node_by_id[ii][label], True, patts, True, None)\n\n    util.timer_section('solve')\n\n    result = None\n    if s.solve():\n        util.timer_section('create graph')\n\n        if util_graph.gtype_directed(grd.gtype):\n            gr = nx.DiGraph()\n        else:\n            gr = nx.Graph()\n\n        for ii, vvs in vars_node_by_id.items():\n            label = False\n            for ll, vv in vvs.items():\n                if s.get_var(vv):\n                    util.check(label == False, 'multiple labels')\n                    label = ll\n            util.check(label != False, 'no label')\n            if label is not None:\n                gr.add_node(ii)\n                gr.nodes[ii][util_graph.ATTR_LABEL] = label\n\n        for (ii, jj), vvs in vars_edge_by_id_by_label.items():\n            label = False\n            for ll, vv in vvs.items():\n                if s.get_var(vv):\n                    util.check(label == False, 'multiple labels')\n                    label = ll\n            util.check(label != False, 'no label')\n            if label is not None:\n                gr.add_edge(ii, jj)\n                gr.edges[(ii, jj)][util_graph.ATTR_LABEL] = label\n\n        util_graph.check_graph(gr, grd.gtype)\n\n        if edgeopt in [EDGEOPT_GRID, EDGEOPT_RECT]:\n            util_graph.layout_grid(gr)\n\n        grs = util_graph.Graphs()\n        grs.gtype = grd.gtype\n        grs.colors = grd.colors\n        grs.graphs = [gr]\n        result = grs\n\n    util.timer_section(None)\n\n    return result", "\n\n\nif __name__ == '__main__':\n    util.timer_start()\n\n    parser = argparse.ArgumentParser(description='Generate graphs based on example graph.')\n    parser.add_argument('--solver', type=str, nargs='+', choices=solvers.SOLVER_LIST, default=[solvers.SOLVER_PYSAT_RC2], help='Solver name, from: ' + ','.join(solvers.SOLVER_LIST) + '.')\n    parser.add_argument('--outfile', required=True, type=str, help='Output file.')\n    parser.add_argument('--gdescfile', required=True, type=str, help='Input graph description file.')\n    parser.add_argument('--minsize', required=True, type=int, help='Minimum size.')\n    parser.add_argument('--maxsize', required=True, type=int, help='Maximum size.')\n    parser.add_argument('--edgeopt', type=str, nargs='+', default=[EDGEOPT_FULL], help='Edge options, from: ' + ','.join(EDGEOPT_LIST) + '.')\n    parser.add_argument('--label-min', type=str, nargs='+', default=None, help='Minimum number of each label to generate.')\n    parser.add_argument('--label-max', type=str, nargs='+', default=None, help='Maximum number of each label to generate.')\n    parser.add_argument('--label-count', action='store_true', help='Generate using label counts from example.')\n    parser.add_argument('--connect', type=str, choices=CONNECT_LIST, default=CONNECT_REACH, help='Connect approach name, from: ' + ','.join(CONNECT_LIST) + '.')\n    parser.add_argument('--randomize', type=int, help='Randomize based on given number.')\n    args = parser.parse_args()\n\n    if len(args.solver) == 1:\n        solver = solvers.solver_id_to_solver(args.solver[0])\n    else:\n        solver = solvers.PortfolioSolver(args.solver, None)\n\n    if args.edgeopt is not None:\n        edgeopt = args.edgeopt[0]\n        edgeopt_params = tuple([int(ee) for ee in args.edgeopt[1:]])\n        util.check(edgeopt in EDGEOPT_LIST, '--edgeopt must be in ' + ','.join(EDGEOPT_LIST))\n\n    label_min = util.arg_list_to_dict_int(parser, '--label-min', args.label_min)\n    label_max = util.arg_list_to_dict_int(parser, '--label-max', args.label_max)\n\n    with util.openz(args.gdescfile, 'rb') as f:\n        grd = pickle.load(f)\n\n    ogrs = gdesc2graph(solver, grd, args.minsize, args.maxsize, edgeopt, edgeopt_params, label_min, label_max, args.label_count, args.connect, args.randomize)\n    if ogrs is not None:\n        util_graph.write_graph(ogrs, sys.stdout)\n        util_graph.write_graph_to_file(ogrs, args.outfile)\n        util.exit_solution_found()\n    else:\n        util.exit_solution_not_found()", ""]}
{"filename": "gdesc2summary.py", "chunked_list": ["import argparse, itertools, json, pickle, random, sys, time\nimport util, util_graph\nimport networkx as nx\n\n\n\ndef gdesc2summary(grd):\n    grs = util_graph.Graphs()\n    grs.gtype = grd.gtype\n    grs.colors = grd.colors\n    grs.graphs = []\n    result = grs\n\n    for label in grd.node_labels:\n        for nbrs in grd.node_label_neighbors[label]:\n            gid = len(grs.graphs)\n\n            if util_graph.gtype_directed(grd.gtype):\n                gr = nx.DiGraph()\n            else:\n                gr = nx.Graph()\n\n            central_node = f'{gid}:*'\n\n            gr.add_node(central_node)\n            gr.nodes[central_node][util_graph.ATTR_LABEL] = label\n            gr.nodes[central_node][util_graph.ATTR_HIGHLIGHT] = True\n\n            for ni, (nbr_node_label, nbr_edge_label, nbr_edge_dir) in enumerate(nbrs):\n                nbr_node = f'{gid}:{ni}'\n\n                if nbr_edge_dir == util_graph.DIR_TIL or nbr_edge_dir is None:\n                    edge = (central_node, nbr_node)\n                elif nbr_edge_dir == util_graph.DIR_FRA:\n                    edge = (nbr_node, central_node)\n                else:\n                    util.check(False, 'nbr_edge_dir')\n\n                gr.add_node(nbr_node)\n                gr.nodes[nbr_node][util_graph.ATTR_LABEL] = nbr_node_label\n\n                gr.add_edge(edge[0], edge[1])\n                gr.edges[edge][util_graph.ATTR_LABEL] = nbr_edge_label\n\n            grs.graphs.append(gr)\n\n    return grs", "\n\n\nif __name__ == '__main__':\n    util.timer_start()\n\n    parser = argparse.ArgumentParser(description='Summarize graph description.')\n    parser.add_argument('--outfile', type=str, help='Output file.')\n    parser.add_argument('--gdescfile', required=True, type=str, help='Input graph description file.')\n    args = parser.parse_args()\n\n    with util.openz(args.gdescfile, 'rb') as f:\n        grd = pickle.load(f)\n\n    ogrs = gdesc2summary(grd)\n    print(f'found {len(grd.node_labels)} node labels')\n    print(f'found {len(grd.edge_labels)} edge labels')\n    print(f'found {len(ogrs.graphs)} neighborhoods')\n\n    if args.outfile is None:\n        for gr in ogrs.graphs:\n            ogr = util_graph.GraphDesc()\n            ogr.gtype = ogrs.gtype\n            ogr.colors = ogrs.colors\n            ogr.graphs = [gr]\n            print()\n            util_graph.write_graph(ogr, sys.stdout)\n\n    else:\n        util_graph.write_graph_to_file(ogrs, args.outfile)", ""]}
{"filename": "graph2gdesc.py", "chunked_list": ["import argparse, itertools, json, pickle, random, sys, time\nimport util, util_graph\nimport networkx as nx\n\n\n\ndef graph_nbrs(gr, gtype, node):\n    nbrs = []\n    for fra, til, label in util_graph.edges_and_labels(gr):\n        nbr, dir_tag = None, None\n\n        if util_graph.gtype_directed(gtype):\n            if fra == node:\n                nbr, dir_tag = til, util_graph.DIR_TIL\n            elif til == node:\n                nbr, dir_tag = fra, util_graph.DIR_FRA\n        else:\n            if fra == node:\n                nbr = til\n            elif til == node:\n                nbr = fra\n\n        if nbr:\n            nbrs.append((nbr, label, dir_tag))\n\n    return nbrs", "\ndef graph2gdesc(grs, edgesonly):\n    util.timer_section('extract')\n\n    grd = util_graph.GraphDesc()\n\n    grd.gtype = grs.gtype\n    grd.colors = grs.colors\n\n    grd.node_labels = {}\n    grd.edge_labels = {}\n\n    total_nodes = 0\n\n    for gr in grs.graphs:\n        total_nodes += len(gr.nodes)\n\n        for node, label in util_graph.nodes_and_labels(gr):\n            if label not in grd.node_labels:\n                grd.node_labels[label] = None\n                grd.node_label_count[label] = 0\n                grd.node_label_neighbors[label] = []\n\n        for fra, til, label in util_graph.edges_and_labels(gr):\n            if label not in grd.edge_labels:\n                grd.edge_labels[label] = None\n\n        for node, label in util_graph.nodes_and_labels(gr):\n            grd.node_label_count[label] += 1\n\n            nbr_labels = []\n\n            nbrs = graph_nbrs(gr, grd.gtype, node)\n            for nbr_node, nbr_edge_label, nbr_edge_dir in nbrs:\n                if edgesonly:\n                    nbr_node_label = None\n                else:\n                    nbr_node_label = gr.nodes[nbr_node][util_graph.ATTR_LABEL]\n                nbr_labels.append((nbr_node_label, nbr_edge_label, nbr_edge_dir))\n\n            nbr_labels = tuple(sorted(nbr_labels))\n\n            if nbr_labels not in grd.node_label_neighbors[label]:\n                grd.node_label_neighbors[label].append(nbr_labels)\n\n    for label in grd.node_labels:\n        grd.node_label_count[label] = grd.node_label_count[label] / total_nodes\n        grd.node_label_neighbors[label] = sorted(grd.node_label_neighbors[label])\n\n    return grd", "\n\n\nif __name__ == '__main__':\n    util.timer_start()\n\n    parser = argparse.ArgumentParser(description='Extract description from example graph.')\n    parser.add_argument('--outfile', required=True, type=str, help='Output file.')\n    parser.add_argument('--graphfile', required=True, nargs='+', type=str, help='Input graph file(s).')\n    parser.add_argument('--edgesonly', action='store_true', help='Make description from only edges.')\n    args = parser.parse_args()\n\n    grs = util_graph.read_graphs(args.graphfile)\n\n    grd = graph2gdesc(grs, args.edgesonly)\n    with util.openz(args.outfile, 'wb') as f:\n        pickle.dump(grd, f)", ""]}
{"filename": "levels2explore.py", "chunked_list": ["import argparse, glob, gzip, math, os, pickle, random, sys, threading, time\nimport util, util_explore\nimport numpy as np\nimport PIL.Image, PIL.ImageDraw, PIL.ImageTk\nimport tkinter, tkinter.messagebox\n\n\n\ndef one_hot(rows, cols, ntind, neind, npind, levels, einds, pinds):\n    a = np.zeros((len(levels), rows, cols, ntind), dtype=np.uint8)\n    for ll, level in enumerate(levels):\n        for rr in range(rows):\n            for cc in range(cols):\n                for tind in level[rr][cc]:\n                    a[ll][rr][cc][tind] = 1\n    a = a.reshape((len(levels), rows * cols * ntind))\n\n    b = np.zeros((len(levels), neind), dtype=np.uint8)\n    for ll, ll_einds in enumerate(einds):\n        for eind in ll_einds:\n            b[ll][eind] = 1\n\n    c = np.zeros((len(levels), npind), dtype=np.uint8)\n    for ll, ll_pinds in enumerate(pinds):\n        for pind in ll_pinds:\n            c[ll][pind] = 1\n\n    return np.concatenate((a, b, c), axis=1)", "def one_hot(rows, cols, ntind, neind, npind, levels, einds, pinds):\n    a = np.zeros((len(levels), rows, cols, ntind), dtype=np.uint8)\n    for ll, level in enumerate(levels):\n        for rr in range(rows):\n            for cc in range(cols):\n                for tind in level[rr][cc]:\n                    a[ll][rr][cc][tind] = 1\n    a = a.reshape((len(levels), rows * cols * ntind))\n\n    b = np.zeros((len(levels), neind), dtype=np.uint8)\n    for ll, ll_einds in enumerate(einds):\n        for eind in ll_einds:\n            b[ll][eind] = 1\n\n    c = np.zeros((len(levels), npind), dtype=np.uint8)\n    for ll, ll_pinds in enumerate(pinds):\n        for pind in ll_pinds:\n            c[ll][pind] = 1\n\n    return np.concatenate((a, b, c), axis=1)", "\n\n\ndef levels2explore(tilefiles, resultfiles, pad_top, text_only, image_only):\n    print('loading...')\n\n    rows, cols = None, None\n    tileset = None\n    use_text = None\n    use_image = None\n\n    entry_size = None\n    all_levels = []\n\n    tind_to_text = {}\n    text_to_tind = {}\n    tind_to_image = {}\n    image_to_tind = {}\n    tinds_to_tile = {}\n    tile_to_tinds = {}\n\n    ntind = 0\n    ntind_both = 0\n    ntind_text = 0\n    ntind_image = 0\n\n    eind_to_edge = {}\n    edge_to_eind = {}\n    all_edges = []\n    all_einds = []\n\n    pind_to_prop = {}\n    prop_to_pind = {}\n    all_pinds = []\n\n    def add_level(_tile_level, _edges, _props):\n        nonlocal rows, cols\n\n        _lrows = len(_tile_level)\n        _lcols = len(_tile_level[0])\n        if rows is None:\n            rows, cols = _lrows, _lcols\n        else:\n            rows = max(rows, _lrows)\n            cols = max(cols, _lcols)\n\n        _level = []\n        for _rr in range(_lrows):\n            _row = []\n            for _cc in range(_lcols):\n                _row.append(tile_to_tinds[_tile_level[_rr][_cc]])\n            _level.append(_row)\n\n        _pinds = []\n        if _props is not None:\n            for _prop in _props:\n                if _prop not in prop_to_pind:\n                    _pind = len(prop_to_pind)\n                    prop_to_pind[_prop] = _pind\n                    pind_to_prop[_pind] = _prop\n                _pinds.append(prop_to_pind[_prop])\n\n        all_levels.append(_level)\n        all_edges.append([tuple(_edge) for _edge in _edges] if _edges is not None else [])\n        all_pinds.append(_pinds)\n\n    def add_einds(_edges):\n        _einds = []\n        for _edge in _edges:\n            if _edge not in edge_to_eind:\n                _eind = len(edge_to_eind)\n                edge_to_eind[_edge] = _eind\n                eind_to_edge[_eind] = _edge\n            _einds.append(edge_to_eind[_edge])\n        all_einds.append(_einds)\n\n    def pad_level(_level, _path, _rows, _cols, _void_tind):\n        if len(_level) == _rows and len(_level[0]) == _cols:\n            return False\n\n        for _rr in range(len(_level)):\n            while len(_level[_rr]) != _cols:\n                _level[_rr].append(_void_tind)\n        while len(_level) != _rows:\n            if pad_top:\n                _level.insert(0, [_void_tind] * _cols)\n                for ii in range(len(_path)):\n                    _path[ii] = (_path[ii][0] + 1, _path[ii][1], _path[ii][2] + 1, _path[ii][3])\n            else:\n                _level.append([_void_tind] * _cols)\n        return True\n\n    for tilefile_glob in tilefiles:\n        for tilefile in glob.iglob(tilefile_glob):\n            with util.openz(tilefile, 'rb') as f:\n                tile_info = pickle.load(f)\n\n                if tileset == None:\n                    tileset = tile_info.tileset\n                    use_text = (tileset.tile_to_text is not None) and (not image_only)\n                    use_image = (tileset.tile_to_image is not None) and (not text_only)\n\n                    tile_to_tinds = {}\n                    for tile in tileset.tile_ids:\n                        tile_to_tinds[tile] = []\n\n                    tile_to_image_key = {}\n                    if use_image:\n                        for tile in tileset.tile_ids:\n                            tile_to_image_key[tile] = tuple(tileset.tile_to_image[tile].getdata())\n\n                    text_uniq = {}\n                    image_key_uniq = {}\n\n                    for tile in tileset.tile_ids:\n                        if use_text:\n                            text = tileset.tile_to_text[tile]\n                            if text in text_uniq:\n                                text_uniq[text] = False\n                            else:\n                                text_uniq[text] = True\n                        if use_image:\n                            image_key = tile_to_image_key[tile]\n                            if image_key in image_key_uniq:\n                                image_key_uniq[image_key] = False\n                            else:\n                                image_key_uniq[image_key] = True\n\n                    for tile in tileset.tile_ids:\n                        if use_text and use_image:\n                            text = tileset.tile_to_text[tile]\n                            image_key = tile_to_image_key[tile]\n\n                            if text_uniq[text] and image_key_uniq[image_key]:\n                                text_to_tind[text] = ntind\n                                tind_to_text[ntind] = text\n                                image_to_tind[image_key] = ntind\n                                tind_to_image[ntind] = tileset.tile_to_image[tile]\n                                tile_to_tinds[tile].append(ntind)\n                                ntind += 1\n                                ntind_both += 1\n                                continue\n\n                        if use_text:\n                            text = tileset.tile_to_text[tile]\n                            if text not in text_to_tind:\n                                text_to_tind[text] = ntind\n                                tind_to_text[ntind] = text\n                                ntind += 1\n                                ntind_text += 1\n                            tile_to_tinds[tile].append(text_to_tind[text])\n\n                        if use_image:\n                            image_key = tile_to_image_key[tile]\n                            if image_key not in image_to_tind:\n                                image_to_tind[image_key] = ntind\n                                tind_to_image[ntind] = tileset.tile_to_image[tile]\n                                ntind += 1\n                                ntind_image += 1\n                            tile_to_tinds[tile].append(image_to_tind[image_key])\n\n                    for tile, tinds in tile_to_tinds.items():\n                        tinds_to_tile[tuple(sorted(tinds))] = tile\n\n                else:\n                    util.check_tileset_match(tileset, tile_info.tileset)\n\n                if tile_info.levels is not None:\n                    for tli in tile_info.levels:\n                        path = util.get_meta_path(tli.meta)\n                        properties = util.get_meta_properties(tli.meta)\n                        add_level(tli.tiles, path, properties)\n\n    if resultfiles is not None:\n        for resultfile_glob in resultfiles:\n            for resultfile in glob.iglob(resultfile_glob):\n                with util.openz(resultfile, 'rb') as f:\n                    result_info = pickle.load(f)\n                    edges = result_info.reach_info.path_edges if result_info.reach_info is not None else []\n                    add_level(result_info.tile_level, edges, None)\n\n    print('loaded', len(all_levels), 'levels')\n\n    print('encoding...')\n\n    void_tind = None\n    any_padded = False\n    for level, edges in zip(all_levels, all_edges):\n        this_padded = pad_level(level, edges, rows, cols, [ntind])\n        any_padded = any_padded or this_padded\n\n    if any_padded:\n        print('padded!')\n        void_tind = ntind\n        ntind += 1\n\n    for edges in all_edges:\n        add_einds(edges)\n\n    ex = util_explore.ExploreInfo()\n    ex.rows = rows\n    ex.cols = cols\n\n    ex.tileset = tileset\n\n    ex.ntind = ntind\n    ex.neind = max(list(eind_to_edge.keys()) + [-1]) + 1\n    ex.npind = max(list(pind_to_prop.keys()) + [-1]) + 1\n\n    ex.void_tind = void_tind\n\n    ex.tind_to_text = tind_to_text\n    ex.tind_to_image = tind_to_image\n    ex.tinds_to_tile = tinds_to_tile\n    ex.eind_to_edge = eind_to_edge\n    ex.pind_to_prop = pind_to_prop\n\n    ex.level_data = np.packbits(one_hot(ex.rows, ex.cols, ex.ntind, ex.neind, ex.npind, all_levels, all_einds, all_pinds), axis=1)\n\n    print('encoded', len(ex.level_data), 'levels')\n    print('encoded', len(ex.tileset.tile_ids), 'tiles into', str(ex.ntind) + ';', ntind_text, 'text', ntind_image, 'image', ntind_both, 'both', 1 if ex.void_tind is not None else 0, 'void')\n    print('encoded', len(ex.eind_to_edge), 'edges into', ex.neind)\n    print('encoded', len(ex.pind_to_prop), 'props into', ex.npind)\n    print('encoded data', ex.level_data.shape)\n\n    return ex", "\n\n\nif __name__ == '__main__':\n    util.timer_start()\n\n    parser = argparse.ArgumentParser(description='Path editor.')\n    parser.add_argument('--outfile', required=True, type=str, help='Explore file to write to.')\n    parser.add_argument('--tilefile', required=True, type=str, nargs='+', help='Input tile file(s).')\n    parser.add_argument('--resultfile', type=str, nargs='+', help='Input result file(s).')\n    parser.add_argument('--text-only', action='store_true', help='Only use tile edges.')\n    parser.add_argument('--image-only', action='store_true', help='Only use image edges.')\n    parser.add_argument('--pad-top', action='store_true', help='Pad top of level when needed.')\n\n    args = parser.parse_args()\n\n    explore_info = levels2explore(args.tilefile, args.resultfile, args.pad_top, args.text_only, args.image_only)\n    with util.openz(args.outfile, 'wb') as f:\n        pickle.dump(explore_info, f)", ""]}
{"filename": "util-test.py", "chunked_list": ["import itertools, os\nimport util\n\nif __name__ == '__main__':\n    os.environ['STG_MUTE_TIME'] = '1'\n    os.environ['STG_MUTE_PORT'] = '1'\n\n    print('corner_indices')\n    for til in [5, 10, 15]:\n        for depth in [2, 3, 5]:\n            util_inds = util.corner_indices(til, depth)\n            itertools_inds = [inds for inds in itertools.product(range(til), repeat=depth) if len(inds) == len(set(inds)) and list(inds) == sorted(inds)]\n            util.check(util_inds == itertools_inds, 'corner_indices')", ""]}
{"filename": "portfolio.py", "chunked_list": ["import argparse, os, queue, signal, subprocess, tempfile, threading, time\nimport util\nimport pysat.formula\n\n\n\ndef run_portfolio(filename, timeout):\n    time_start = time.time()\n\n    solvers = []\n    for solver in os.listdir('solvers'):\n        solver_filename = os.path.join('solvers', solver)\n        if os.path.isfile(solver_filename) and os.access(solver_filename, os.X_OK):\n            solvers.append(solver_filename)\n\n    util.check(len(solvers) > 0, 'no solvers found')\n\n    procs = []\n    for solver in solvers:\n        print('c! starting', solver)\n        tfile = tempfile.TemporaryFile()\n        proc = subprocess.Popen(solver.split() + [filename], stdout=tfile, stderr=subprocess.STDOUT, encoding='ascii')\n        procs.append((solver, proc, tfile))\n\n    wcnf = pysat.formula.WCNF(from_file=filename)\n\n\n    completed_procs = []\n\n    while True:\n        for solver, proc, tfile in procs:\n            if proc.poll() is not None:\n                completed_procs.append((solver, proc, tfile))\n        if len(completed_procs) != 0:\n            break\n        if time.time() - time_start >= timeout:\n            break\n        time.sleep(0.1)\n\n    if len(completed_procs) == 0:\n        print('c! timeout')\n        for solver, proc, tfile in procs:\n            proc.send_signal(signal.SIGINT)\n\n        for solver, proc, tfile in procs:\n            proc.wait()\n\n        completed_procs = procs\n\n    outs = []\n\n    for solver, proc, tfile in completed_procs:\n        tfile.seek(0)\n        out = tfile.read().decode('ascii')\n        tfile.close()\n        outs.append((solver, out))\n\n    for solver, proc, tfile in procs:\n        proc.kill()\n\n    models = []\n    for solver, out in outs:\n        print('c output from', solver)\n        model = None\n        for line in out.split('\\n'):\n            if len(line) > 0 and line[0] == 'o':\n                print(line)\n            if len(line) > 0 and line[0] == 'v':\n                model = line\n        if model is not None:\n            print('c model from', solver)\n            models.append((solver, model))\n\n    if len(models) == 0:\n        print('c no models')\n\n    elif len(models) == 1:\n        print('c one model')\n        solver, model = models[0]\n        print('c! using model', solver)\n        print(model)\n\n    else:\n        print('c multiple models')\n        best_model, best_solver, best_unsat = None, None, None\n\n        for solver, model in models:\n            vvs = [int(ss) > 0 for ss in model.split()[1:]]\n            unsat = 0\n            for cls, wt in zip(wcnf.soft, wcnf.wght):\n                sat = False\n                for ind in cls:\n                    if vvs[abs(ind) - 1] == (ind > 0):\n                        sat = True\n                        break\n                if not sat:\n                    unsat += wt\n\n            print('c model', solver, unsat)\n            if best_unsat is None or unsat < best_unsat:\n                best_model, best_solver, best_unsat = model, solver, unsat\n\n        print('c! using model', best_solver)\n        print('o', best_unsat)\n        print(best_model)", "\n\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='Run a portfolio of DIMACS solvers.')\n    parser.add_argument('infile', type=str, help='Input DIMACS file.')\n    parser.add_argument('--timeout', type=int, required=True, help='Timeout in seconds.')\n    args = parser.parse_args()\n\n    run_portfolio(args.infile, args.timeout)", ""]}
{"filename": "explorer.py", "chunked_list": ["import argparse, glob, gzip, math, os, pickle, random, sys, threading, time\nimport util, util_explore, util_path\nimport numpy as np\nimport PIL.Image, PIL.ImageDraw, PIL.ImageTk\nimport tkinter, tkinter.messagebox\n\nINSET           =    10\nFRAME           =     5\n\nCELL_SIZE_DEF   =    50", "\nCELL_SIZE_DEF   =    50\n\nMAX_CACHE       =   128\nMAX_UNDO        =   128\nMAX_EDGES       =   256\nMAX_SQRT        =     4\n\nTIME_RECOMPUTE  =  None\n", "TIME_RECOMPUTE  =  None\n\nPATH_OFF        =     0\nPATH_VIEW       =     1\nPATH_EDIT       =     2\n\nTILE_TEXT       =     0\nTILE_IMAGE      =     1\n\nCOLOR_BACK      = '#F0F0F0'", "\nCOLOR_BACK      = '#F0F0F0'\nCOLOR_GRID      = 'gray'\nCOLOR_EDGE      = 'orange'\nCOLOR_OVER      = 'purple'\nCOLOR_INACTIVE  = 'darkgray'\nCOLOR_ACTIVE    = 'magenta'\nCOLOR_SELECTED  = 'black'\n\n", "\n\n\nclass RemainingInfo:\n    def __init__(self, rows, cols):\n        self.levels = []\n        self.nlevels = 0\n\n        self.texts = util.make_grid(rows, cols, [])\n        self.texts_sqrt = util.make_grid(rows, cols, 0)\n\n        self.images = util.make_grid(rows, cols, [])\n        self.images_sqrt = util.make_grid(rows, cols, 0)\n\n        self.einds = []\n        self.einds_cell = util.make_grid(rows, cols, [])\n\n        self.pinds = []", "\n\n\nclass ExplorerFrame(tkinter.Frame):\n    def __init__(self, root, explorer_info, cell_size, text_disp, image_disp):\n        super().__init__(root)\n\n        if TIME_RECOMPUTE is not None:\n            self._times = []\n\n        self._cell_size = cell_size\n\n        self._ex = explorer_info\n        self._nlevels = len(self._ex.level_data)\n        self._tiles_len = self._ex.rows * self._ex.cols * self._ex.ntind\n        self._level_len = self._tiles_len + self._ex.neind + self._ex.npind\n        self._packed_level_len = math.ceil(self._level_len / 8)\n\n        self.pack()\n\n        if len(self._ex.tind_to_text) > 0 and len(self._ex.tind_to_image) == 0:\n            self._displays = [TILE_TEXT]\n        elif len(self._ex.tind_to_text) == 0 and len(self._ex.tind_to_image) > 0:\n            self._displays = [TILE_IMAGE]\n        elif text_disp and image_disp:\n            self._displays = [TILE_IMAGE, TILE_TEXT]\n        elif text_disp:\n            self._displays = [TILE_TEXT]\n        elif image_disp:\n            self._displays = [TILE_IMAGE]\n        elif self._ex.tind_to_text.keys() == self._ex.tind_to_image.keys():\n            self._displays = [TILE_IMAGE]\n        else:\n            self._displays = [TILE_IMAGE, TILE_TEXT]\n\n        self._display_w = self._ex.cols * self._cell_size + INSET\n        self._display_h = self._ex.rows * self._cell_size + INSET\n        if self._ex.cols > self._ex.rows * 1.2:\n            self._display_dx = 0\n            self._display_dy = self._display_h\n        else:\n            self._display_dx = self._display_w\n            self._display_dy = 0\n        self._xoffset = 0\n        self._yoffset = 0\n\n        width = self._display_w + (len(self._displays) - 1) * self._display_dx + INSET - FRAME\n        height = self._display_h + (len(self._displays) - 1) * self._display_dy + INSET - FRAME\n        self._cvs = tkinter.Canvas(self, width=width, height=height)\n        self._cvs.grid(column=0, row=0)\n\n        self._sidebar = tkinter.Frame(self)\n        self._sidebar.grid(column=1, row=0, sticky=tkinter.N, padx=INSET, pady=INSET)\n\n        self._check = []\n        self._check_var = []\n        if self._ex.npind > 0:\n            for ii in range(self._ex.npind):\n                chk_var = tkinter.IntVar()\n                chk = tkinter.Checkbutton(self._sidebar, text=self._ex.pind_to_prop[ii], anchor=tkinter.W, variable=chk_var, onvalue=1, offvalue=0, tristatevalue=-1, command=self._toggle_prop)\n                chk.pack()\n                self._check.append(chk)\n                self._check_var.append(chk_var)\n\n        self._widgets = []\n\n        self._label_rem = tkinter.Label(self._sidebar)\n        self._label_rem.pack()\n        self._widgets.append(self._label_rem)\n\n        def keybutton(key, text, command):\n            btn = tkinter.Button(self._sidebar, text=text, command=command)\n            btn.pack()\n            self._widgets.append(btn)\n            self.bind_all('<KeyPress-' + key + '>', command)\n\n        keybutton('p', '(P)ath mode', self.on_evt_path_mode)\n        keybutton('x', 'Clear (X)', self.on_evt_clear)\n        keybutton('r', '(R)andom', self.on_evt_random)\n        keybutton('f', '(F)inish', self.on_evt_finish)\n        keybutton('z', 'Undo (Z)', self.on_evt_undo)\n        keybutton('y', 'Redo (Y)', self.on_evt_redo)\n        keybutton('d', '(D)isplay', self.on_evt_display)\n        keybutton('e', '(E)xport', self.on_evt_export)\n\n        self._cvs.bind('<Motion>', self.on_mouse_motion)\n        self._cvs.bind('<Leave>', self.on_mouse_leave)\n        self._cvs.bind('<ButtonPress-1>', self.on_mouse_button)\n\n        void_list = [self._ex.void_tind] if self._ex.void_tind is not None else []\n        self._tind_text = np.array(list(self._ex.tind_to_text) + void_list)\n        self._tind_image = np.array(list(self._ex.tind_to_image) + void_list)\n\n        self._tind_to_image = {}\n        self._avg_color = 'lightgray'\n\n        if len(self._ex.tind_to_image) > 0:\n            image_sizes = math.ceil(math.sqrt(len(self._ex.tind_to_image)))\n            if image_sizes >= 8:\n                print('too many tiles')\n                sys.exit(-1)\n\n            for sz in range(1, image_sizes + 1):\n                imgsz = (math.ceil(self._cell_size / sz), math.ceil(self._cell_size / sz))\n                self._tind_to_image[sz] = {}\n                if self._ex.void_tind is not None:\n                    void_image = PIL.Image.new('RGB', imgsz, (48, 32, 32))\n                    void_draw = PIL.ImageDraw.Draw(void_image)\n                    void_draw.line([(0, imgsz[1]), (imgsz[0], 0)], fill=(80, 32, 32), width=3)\n                    self._tind_to_image[sz][self._ex.void_tind] = PIL.ImageTk.PhotoImage(void_image)\n                for tind, img in self._ex.tind_to_image.items():\n                    img = img.resize(imgsz, PIL.Image.Resampling.BILINEAR)\n                    self._tind_to_image[sz][tind] = PIL.ImageTk.PhotoImage(img)\n\n            img_sum = None\n            img_count = 0\n            for tile, image in self._ex.tileset.tile_to_image.items():\n                arr = np.array(image.getdata())\n                if img_sum is None:\n                    img_sum = np.sum(arr, axis=0)\n                else:\n                    img_sum += np.sum(arr, axis=0)\n                img_count += len(arr)\n            avg_color = ((img_sum / img_count + 240) / 2).astype(np.uint8)\n            self._avg_color = '#%02x%02x%02x' % (avg_color[0], avg_color[1], avg_color[2])\n\n        self._mouse_evt = None\n        self._mouse = None\n\n        self._selected_tiles = np.array(util.make_grid(self._ex.rows, self._ex.cols, [0] * self._ex.ntind), dtype=np.uint8)\n        self._selected_tiles_auto = self._selected_tiles.copy()\n        self._selected_einds = np.zeros(self._ex.neind, dtype=np.uint8)\n        self._selected_pinds = np.zeros(self._ex.npind, dtype=np.uint8)\n\n        self._rem = RemainingInfo(self._ex.rows, self._ex.cols)\n\n        self._tmp1 = np.zeros((self._nlevels, self._packed_level_len), dtype=np.uint8)\n        self._tmp2 = np.zeros((self._nlevels, self._packed_level_len), dtype=bool)\n        self._tmp3 = np.zeros((self._nlevels, 1), dtype=bool)\n        self._tmp4 = np.zeros((self._nlevels, self._packed_level_len), dtype=np.uint8)\n        self._tmp5 = np.zeros(self._packed_level_len, dtype=np.uint8)\n\n        self._selected_cache = {}\n\n        self._undo = []\n        self._undo_ind = -1\n\n        self._show_paths = PATH_OFF\n\n        self._draw_working = []\n        self._draw_mouse = []\n        self._draw_selected = []\n        self._draw_path = []\n        self._draw_back = []\n\n        self._thread = None\n        self._mutex = threading.RLock()\n\n        with self._mutex:\n            self.undo_push()\n            self._recompute()\n            self.redraw_from_back()\n\n    def tocvsx(self, x):\n        return (x * self._cell_size) + INSET + self._xoffset\n\n    def tocvsy(self, y):\n        return (y * self._cell_size) + INSET + self._yoffset\n\n    def fromcvsx(self, x):\n        return (x - INSET - self._xoffset) / self._cell_size\n\n    def fromcvsy(self, y):\n        return (y - INSET - self._yoffset) / self._cell_size\n\n    def _toggle_prop(self):\n        with self._mutex:\n            for ii, cv in enumerate(self._check_var):\n                self._selected_pinds[ii] = (1 if cv.get() == 1 else 0)\n            self.undo_push()\n            self._recompute()\n            self.redraw_from_back()\n\n    def rem_indices(self, show_tiles):\n        if show_tiles == TILE_TEXT:\n            return self._rem.texts, self._rem.texts_sqrt, self._tind_text\n        else:\n            return self._rem.images, self._rem.images_sqrt, self._tind_image\n\n    def _recompute_mouse(self):\n        if self._mouse_evt is not None:\n            mex = self._mouse_evt.x\n            mey = self._mouse_evt.y\n\n            md = 0\n            while md < len(self._displays):\n                self._xoffset, self._yoffset = md * self._display_dx, md * self._display_dy\n                mrr, mcr = self.fromcvsy(self._mouse_evt.y), self.fromcvsx(self._mouse_evt.x)\n                mr, mc = math.floor(mrr), math.floor(mcr)\n                if 0 <= mr and mr < self._ex.rows and 0 <= mc and mc < self._ex.cols:\n                    break\n                md += 1\n\n            mi = None\n            if 0 <= mr and mr < self._ex.rows and 0 <= mc and mc < self._ex.cols:\n                mrf, mcf = mrr - mr, mcr - mc\n                if self._show_paths == PATH_EDIT:\n                    if md > 0:\n                        self._mouse = None\n                        return\n\n                    closest_pt, closest_dist_sq = None, None\n                    for eind in self._rem.einds_cell[mr][mc]:\n                        r0, c0, r1, c1 = self._ex.eind_to_edge[eind]\n                        r0 += 0.5\n                        c0 += 0.5\n                        dist_sq = (r0 - mrr) ** 2 + (c0 - mcr) ** 2\n                        if closest_pt is None or dist_sq < closest_dist_sq:\n                            closest_pt, closest_dist_sq = (r0, c0), dist_sq\n\n                    if closest_pt is not None:\n                        clr, clc = closest_pt\n\n                        close_einds = []\n                        for eind in self._rem.einds_cell[mr][mc]:\n                            r0, c0, r1, c1 = self._ex.eind_to_edge[eind]\n                            r0 += 0.5\n                            c0 += 0.5\n                            dist_sq = (r0 - clr) ** 2 + (c0 - clc) ** 2\n                            if dist_sq <= 0.1 * 0.1:\n                                close_einds.append(eind)\n\n                        def normvec(_vr, _vc):\n                            _vl = math.sqrt(_vr * _vr + _vc * _vc)\n                            if _vl < 0.01:\n                                return (0.0, 1.0)\n                            return (_vr / _vl, _vc / _vl)\n                        mvr, mvc = normvec(mrr - clr, mcr - clc)\n                        closest, closest_ang = None, None\n                        for eind in close_einds:\n                            r0, c0, r1, c1 = self._ex.eind_to_edge[eind]\n                            r0 += 0.5\n                            c0 += 0.5\n                            r1 += 0.5\n                            c1 += 0.5\n                            evr, evc = normvec(r1 - r0, c1 - c0)\n                            edge_ang = math.acos(max(-1.0, min(1.0, mvr * evr + mvc * evc)))\n                            if closest_ang is None or edge_ang < closest_ang:\n                                closest, closest_ang = eind, edge_ang\n                        mi = closest\n                else:\n                    indices_rc, indices_sqrt_rc, indices_disp = self.rem_indices(self._displays[md])\n                    sqrt = indices_sqrt_rc[mr][mc]\n                    mir = math.floor(mrf * sqrt)\n                    mic = math.floor(mcf * sqrt)\n                    ii = mir * sqrt + mic\n                    if ii < len(indices_rc[mr][mc]):\n                        mi = ii\n                self._mouse = (mr, mc, md, mi)\n            else:\n                self._mouse = None\n        else:\n            self._mouse = None\n\n    def _recompute_thread(self):\n        with self._mutex:\n            if TIME_RECOMPUTE is not None:\n                start_time = time.time()\n\n            selected_tiles = np.bitwise_or(self._selected_tiles.reshape(self._tiles_len), self._selected_tiles_auto.reshape(self._tiles_len))\n            selected_packed = np.packbits(np.concatenate((selected_tiles, self._selected_einds, self._selected_pinds)))\n\n        cache_key = selected_packed.tobytes()\n\n        if cache_key not in self._selected_cache:\n            np.bitwise_and(selected_packed, self._ex.level_data, out=self._tmp1)\n            np.equal(self._tmp1, selected_packed, out=self._tmp2)\n            np.all(self._tmp2, axis=1, keepdims=True, out=self._tmp3)\n            np.multiply(self._tmp3, self._ex.level_data, out=self._tmp4)\n            np.bitwise_or.reduce(self._tmp4, out=self._tmp5)\n            remaining = np.unpackbits(self._tmp5, count=self._level_len, axis=0)\n            remaining_tiles, remaining_einds, remaining_pinds = np.split(remaining, [self._tiles_len, self._tiles_len + self._ex.neind])\n\n            remaining_tiles = remaining_tiles.reshape((self._ex.rows, self._ex.cols, self._ex.ntind))\n\n            out = RemainingInfo(self._ex.rows, self._ex.cols)\n\n            out.levels = np.nonzero(self._tmp3)[0]\n            out.nlevels = len(out.levels)\n\n            for rr in range(self._ex.rows):\n                for cc in range(self._ex.cols):\n                    tiles = np.nonzero(remaining_tiles[rr][cc])[0]\n                    out.texts[rr][cc] = np.intersect1d(tiles, self._tind_text)\n                    out.texts_sqrt[rr][cc] = math.ceil(math.sqrt(len(out.texts[rr][cc])))\n                    out.images[rr][cc] = np.intersect1d(tiles, self._tind_image)\n                    out.images_sqrt[rr][cc] = math.ceil(math.sqrt(len(out.images[rr][cc])))\n\n            out.einds = list(np.nonzero(remaining_einds)[0])\n            for eind in out.einds:\n                r0, c0, r1, c1 = self._ex.eind_to_edge[eind]\n\n                rs = []\n                if r0 == int(r0):\n                    rs.append(int(r0))\n                else:\n                    if math.floor(r0) >= 0:\n                        rs.append(math.floor(r0))\n                    if math.ceil(r0) < self._ex.rows:\n                        rs.append(math.ceil(r0))\n\n                cs = []\n                if c0 == int(c0):\n                    cs.append(int(c0))\n                else:\n                    if math.floor(c0) >= 0:\n                        cs.append(math.floor(c0))\n                    if math.ceil(c0) < self._ex.cols:\n                        cs.append(math.ceil(c0))\n\n                for rr in rs:\n                    for cc in cs:\n                        out.einds_cell[rr][cc].append(eind)\n\n            out.pinds = remaining_pinds\n\n            self._selected_cache[cache_key] = out\n\n        else:\n            out = self._selected_cache[cache_key]\n            del self._selected_cache[cache_key]\n            self._selected_cache[cache_key] = out\n\n        while len(self._selected_cache) > MAX_CACHE:\n            key = next(iter(self._selected_cache))\n            del self._selected_cache[key]\n\n        out = self._selected_cache[cache_key]\n\n        with self._mutex:\n            sys.stdout.flush()\n\n            self._rem = out\n\n            self._thread = None\n\n            if TIME_RECOMPUTE is not None:\n                this_time = time.time() - start_time\n                self._times.append(this_time)\n                while len(self._times) > TIME_RECOMPUTE:\n                    del self._times[0]\n                print('%0.3f %0.3f' % (sum(self._times) / len(self._times), this_time))\n\n    def check_thread(self):\n        with self._mutex:\n            self.redraw_from_working()\n\n            if self._thread is None:\n                self._recompute_mouse()\n                self.redraw_from_back()\n\n            else:\n                self.after(1, self.check_thread)\n\n    def _recompute(self):\n        with self._mutex:\n            if self._thread is None:\n                for cb in self._check:\n                    cb['state'] = tkinter.DISABLED\n                for bt in self._widgets:\n                    bt['state'] = tkinter.DISABLED\n\n                self._thread = threading.Thread(target=self._recompute_thread)\n                self._thread.start()\n                self.redraw_from_back()\n                self.after(1, self.check_thread)\n\n    def create_rrect(self, x0, y0, x1, y1, cn, fill):\n        return self._cvs.create_polygon(x0+cn, y0, x0+cn, y0,\n                                   x1-cn, y0, x1-cn, y0,\n                                   x1, y0,\n                                   x1, y0+cn, x1, y0+cn,\n                                   x1, y1-cn, x1, y1-cn,\n                                   x1, y1,\n                                   x1-cn, y1, x1-cn, y1,\n                                   x0+cn, y1, x0+cn, y1,\n                                   x0, y1,\n                                   x0, y1-cn, x0, y1-cn,\n                                   x0, y0+cn, x0, y0+cn,\n                                   x0, y0,\n                                   fill=fill, outline='', joinstyle=tkinter.ROUND, smooth=1)\n\n    def create_arrow(self, x0, y0, x1, y1, fill, width, dash):\n        if dash is not None:\n            return self._cvs.create_line(x0, y0, x1, y1, fill=fill, width=width, arrow='last', dash=dash)\n        else:\n            return self._cvs.create_line(0.5 * (x0 + x1), 0.5 * (y0 + y1), x0, y0, x1, y1, fill=fill, width=width, arrow='last', joinstyle=tkinter.ROUND)\n\n    def create_tiles_from_cell(self, draw_list, disp, rr, cc):\n        indices_rc, indices_sqrt_rc, indices_disp = self.rem_indices(disp)\n        indices = indices_rc[rr][cc]\n        sqrt = indices_sqrt_rc[rr][cc]\n        to = self._cell_size / (2 * sqrt)\n        font = ('Courier', str(int(self._cell_size / sqrt)))\n        ind = 0\n        for index in indices:\n            ox = (ind % sqrt) / sqrt * self._cell_size\n            oy = (ind // sqrt) / sqrt * self._cell_size\n            ind += 1\n            if disp == TILE_IMAGE:\n                image = self._tind_to_image[sqrt][index]\n                draw_list.append(self._cvs.create_image(self.tocvsx(cc) + ox, self.tocvsy(rr) + oy, anchor=tkinter.NW, image=image))\n            else:\n                if index == self._ex.void_tind:\n                    draw_list.append(self._cvs.create_text(self.tocvsx(cc) + ox + to, self.tocvsy(rr) + oy + to, text='/', fill='#a04040', font=font, anchor=tkinter.CENTER))\n                else:\n                    draw_list.append(self._cvs.create_text(self.tocvsx(cc) + ox + to, self.tocvsy(rr) + oy + to, text=self._ex.tind_to_text[index], font=font, anchor=tkinter.CENTER))\n\n    def create_tiles_from(self, draw_list, disp):\n        indices_rc, indices_sqrt_rc, indices_disp = self.rem_indices(disp)\n        for rr in range(self._ex.rows):\n            for cc in range(self._ex.cols):\n                sqrt = indices_sqrt_rc[rr][cc]\n                if sqrt == 0:\n                    pass\n                elif sqrt <= MAX_SQRT:\n                    self.create_tiles_from_cell(draw_list, disp, rr, cc)\n                else:\n                    if disp == TILE_IMAGE:\n                        clr = self._avg_color\n                    else:\n                        clr = 'lightgray'\n                    draw_list.append(self.create_rrect(self.tocvsx(cc + 0.1), self.tocvsy(rr + 0.1), self.tocvsx(cc + 0.9), self.tocvsy(rr + 0.9), 0.4 * self._cell_size, clr))\n\n    def redraw_from_working(self):\n        with self._mutex:\n            for draw in self._draw_working:\n                self._cvs.delete(draw)\n            self._draw_working = []\n\n        if self._thread is not None:\n            if self._mouse is None:\n                self._draw_working.append(self._cvs.create_arc(INSET + 5, INSET + 5, INSET + 30, INSET + 30, outline=COLOR_OVER, width=3, style=tkinter.ARC, start=time.time() * 45.0, extent=300.0))\n            else:\n                mr, mc, md, mi = self._mouse\n                self._draw_working.append(self._cvs.create_arc(self.tocvsx(mc + 0.1), self.tocvsy(mr + 0.1), self.tocvsx(mc + 0.4), self.tocvsy(mr + 0.4), outline=COLOR_OVER, width=2, style=tkinter.ARC, start=time.time() * 45.0, extent=300.0))\n\n    def redraw_from_mouse(self):\n        with self._mutex:\n            for draw in self._draw_mouse:\n                self._cvs.delete(draw)\n            self._draw_mouse = []\n\n            if self._thread is not None:\n                color_over = COLOR_INACTIVE\n            else:\n                color_over = COLOR_OVER\n\n            if self._mouse is not None:\n                mr, mc, md, mi = self._mouse\n\n                for dd, disp in enumerate(self._displays):\n                    self._xoffset, self._yoffset = dd * self._display_dx, dd * self._display_dy\n                    if dd != md:\n                        self._draw_mouse.append(self._cvs.create_rectangle(self.tocvsx(mc), self.tocvsy(mr), self.tocvsx(mc + 1), self.tocvsy(mr + 1), outline=color_over, width=2))\n\n                indices_rc, indices_sqrt_rc, indices_disp = self.rem_indices(self._displays[md])\n                sqrt = indices_sqrt_rc[mr][mc]\n                self._xoffset, self._yoffset = md * self._display_dx,  md * self._display_dy\n\n                if self._thread is None:\n                    if self._show_paths == PATH_EDIT:\n                        for eind in self._rem.einds_cell[mr][mc]:\n                            r0, c0, r1, c1 = self._ex.eind_to_edge[eind]\n                            self._draw_mouse.append(self.create_arrow(self.tocvsx(c0 + 0.5), self.tocvsy(r0 + 0.5), self.tocvsx(c1 + 0.5), self.tocvsy(r1 + 0.5), COLOR_EDGE, 3, None))\n                    else:\n                        if sqrt > MAX_SQRT:\n                            tile_cids = []\n                            disp = self._displays[md]\n                            self.create_tiles_from_cell(tile_cids, disp, mr, mc)\n                            tile_cids.append(self._cvs.create_rectangle(self.tocvsx(mc), self.tocvsy(mr), self.tocvsx(mc + 1), self.tocvsy(mr + 1), fill=COLOR_BACK, outline=''))\n                            for cid in tile_cids:\n                                self._cvs.tag_raise(cid, self._draw_back[-1])\n                            self._draw_mouse += tile_cids\n\n                self._draw_mouse.append(self._cvs.create_rectangle(self.tocvsx(mc), self.tocvsy(mr), self.tocvsx(mc + 1), self.tocvsy(mr + 1), outline=color_over, width=2))\n                if self._show_paths == PATH_EDIT:\n                    self._draw_mouse.append(self.create_arrow(self.tocvsx(mc + 0), self.tocvsy(mr + 0), self.tocvsx(mc + 1), self.tocvsy(mr + 0), color_over, 2, None))\n                    self._draw_mouse.append(self.create_arrow(self.tocvsx(mc + 1), self.tocvsy(mr + 1), self.tocvsx(mc + 0), self.tocvsy(mr + 1), color_over, 2, None))\n\n                if mi is not None and self._thread is None:\n                    if self._show_paths == PATH_EDIT:\n                        r0, c0, r1, c1 = self._ex.eind_to_edge[mi]\n                        self._draw_mouse.append(self.create_arrow(self.tocvsx(c0 + 0.5), self.tocvsy(r0 + 0.5), self.tocvsx(c1 + 0.5), self.tocvsy(r1 + 0.5), COLOR_ACTIVE, 3, None))\n\n                    else:\n                        ox = (mi % sqrt) / sqrt * self._cell_size\n                        oy = (mi // sqrt) / sqrt * self._cell_size\n                        sz = self._cell_size // sqrt\n\n                        self._draw_mouse.append(self._cvs.create_rectangle(self.tocvsx(mc) + ox, self.tocvsy(mr) + oy, self.tocvsx(mc) + ox + sz, self.tocvsy(mr) + oy + sz, outline=COLOR_ACTIVE, width=3))\n            self.redraw_from_working()\n\n    def redraw_from_selected(self):\n        with self._mutex:\n            for draw in self._draw_selected:\n                self._cvs.delete(draw)\n            self._draw_selected = []\n\n            for dd, disp in enumerate(self._displays):\n                self._xoffset, self._yoffset = dd * self._display_dx, dd * self._display_dy\n                indices_rc, indices_sqrt_rc, indices_disp = self.rem_indices(disp)\n\n                for rr in range(self._ex.rows + 1):\n                    self._draw_selected.append(self._cvs.create_line(self.tocvsx(0), self.tocvsy(rr), self.tocvsx(self._ex.cols), self.tocvsy(rr), fill=COLOR_GRID))\n                for cc in range(self._ex.cols + 1):\n                    self._draw_selected.append(self._cvs.create_line(self.tocvsx(cc), self.tocvsy(0), self.tocvsx(cc), self.tocvsy(self._ex.rows), fill=COLOR_GRID))\n\n                for rr in range(self._ex.rows):\n                    for cc in range(self._ex.cols):\n                        if np.count_nonzero(self._selected_tiles[rr][cc][indices_disp]) > 0:\n                            self._draw_selected.append(self._cvs.create_rectangle(self.tocvsx(cc + 0.1), self.tocvsy(rr + 0.1), self.tocvsx(cc + 0.9), self.tocvsy(rr + 0.9), outline=COLOR_SELECTED, width=2, dash=(2,4)))\n                        elif np.count_nonzero(self._selected_tiles[rr][cc]) > 0:\n                            self._draw_selected.append(self._cvs.create_rectangle(self.tocvsx(cc + 0.1), self.tocvsy(rr + 0.1), self.tocvsx(cc + 0.9), self.tocvsy(rr + 0.9), outline=COLOR_SELECTED, width=2, dash=(2,12)))\n                        elif np.count_nonzero(self._selected_tiles_auto[rr][cc][indices_disp]) > 0:\n                            self._draw_selected.append(self._cvs.create_rectangle(self.tocvsx(cc + 0.1), self.tocvsy(rr + 0.1), self.tocvsx(cc + 0.9), self.tocvsy(rr + 0.9), outline=COLOR_SELECTED, width=1, dash=(4,8)))\n\n            if np.sum(self._selected_einds) > 0:\n                self._xoffset, self._yoffset = 0, 0\n                for eind, (r0, c0, r1, c1) in self._ex.eind_to_edge.items():\n                    if self._selected_einds[eind]:\n                        self._draw_selected.append(self.create_arrow(self.tocvsx(c0 + 0.5), self.tocvsy(r0 + 0.5), self.tocvsx(c1 + 0.5), self.tocvsy(r1 + 0.5), COLOR_SELECTED, 5, (4,4)))\n\n            self.redraw_from_mouse()\n\n    def redraw_from_path(self):\n        with self._mutex:\n            for draw in self._draw_path:\n                self._cvs.delete(draw)\n            self._draw_path = []\n\n            if self._show_paths in [PATH_VIEW, PATH_EDIT]:\n                self._xoffset, self._yoffset = 0, 0\n                if len(self._rem.einds) <= MAX_EDGES:\n                    for eind in self._rem.einds:\n                        r0, c0, r1, c1 = self._ex.eind_to_edge[eind]\n                        self._draw_path.append(self.create_arrow(self.tocvsx(c0 + 0.5), self.tocvsy(r0 + 0.5), self.tocvsx(c1 + 0.5), self.tocvsy(r1 + 0.5), COLOR_EDGE, 3, None))\n                else:\n                    for rr in range(self._ex.rows):\n                        for cc in range(self._ex.cols):\n                            if len(self._rem.einds_cell[rr][cc]) > 0:\n                                self._draw_path.append(self._cvs.create_oval(self.tocvsx(cc + 0.4), self.tocvsy(rr + 0.4), self.tocvsx(cc + 0.6), self.tocvsy(rr + 0.6), fill=COLOR_EDGE, outline=''))\n\n            self.redraw_from_selected()\n\n    def redraw_from_back(self):\n        with self._mutex:\n            for draw in self._draw_back:\n                self._cvs.delete(draw)\n            self._draw_back = []\n\n            self._label_rem.config(text=str(self._rem.nlevels) + ' level' + ('' if self._rem.nlevels == 1 else 's'))\n\n            for cb, cv, selected, remaining in zip(self._check, self._check_var, self._selected_pinds, self._rem.pinds):\n                if remaining:\n                    if self._thread is not None:\n                        cb['state'] = tkinter.DISABLED\n                    else:\n                        cb['state'] = tkinter.NORMAL\n                    if selected:\n                        cv.set(1)\n                    else:\n                        cv.set(0)\n                else:\n                    cb['state'] = tkinter.DISABLED\n                    cv.set(-1)\n\n            for bt in self._widgets:\n                if self._thread is not None:\n                    bt['state'] = tkinter.DISABLED\n                else:\n                    bt['state'] = tkinter.NORMAL\n\n            for dd, disp in enumerate(self._displays):\n                self._xoffset, self._yoffset = dd * self._display_dx, dd * self._display_dy\n\n                self._draw_back.append(self._cvs.create_rectangle(self.tocvsx(0), self.tocvsy(0), self.tocvsx(self._ex.cols), self.tocvsy(self._ex.rows), fill=COLOR_BACK, outline=''))\n\n                self.create_tiles_from(self._draw_back, disp)\n\n            self.redraw_from_path()\n\n    def undo_append(self):\n        with self._mutex:\n            self._undo.append((self._selected_tiles.copy(),\n                               self._selected_tiles_auto.copy(),\n                               self._selected_einds.copy(),\n                               self._selected_pinds.copy()))\n\n    def undo_restore(self):\n        with self._mutex:\n            selected_tiles, selected_tiles_auto, selected_einds, selected_pinds = self._undo[self._undo_ind]\n            self._selected_tiles = selected_tiles.copy()\n            self._selected_tiles_auto = selected_tiles_auto.copy()\n            self._selected_einds = selected_einds.copy()\n            self._selected_pinds = selected_pinds.copy()\n\n    def undo_push(self):\n        with self._mutex:\n            self._undo = self._undo[0:self._undo_ind + 1]\n            self.undo_append()\n            while len(self._undo) > MAX_UNDO + 1:\n                self._undo = self._undo[1:]\n            self._undo_ind = len(self._undo) - 1\n\n    def undo_undo(self):\n        with self._mutex:\n            if len(self._undo) > 0 and self._undo_ind > 0:\n                self._undo_ind -= 1\n                self.undo_restore()\n                return True\n            return False\n\n    def undo_redo(self):\n        with self._mutex:\n            if self._undo_ind + 1 < len(self._undo):\n                self._undo_ind += 1\n                self.undo_restore()\n                return True\n            return False\n\n    def on_evt_display(self, event=None):\n        with self._mutex:\n            if len(self._ex.tind_to_text) > 0 and len(self._ex.tind_to_image) > 0:\n                if len(self._displays) == 1:\n                    if self._displays == [TILE_IMAGE]:\n                        self._displays = [TILE_TEXT]\n                    else:\n                        self._displays = [TILE_IMAGE]\n                elif len(self._displays) == 2:\n                    if self._displays == [TILE_IMAGE, TILE_TEXT]:\n                        self._displays = [TILE_TEXT, TILE_IMAGE]\n                    else:\n                        self._displays = [TILE_IMAGE, TILE_TEXT]\n                self.redraw_from_back()\n\n    def on_evt_export(self, event=None):\n        with self._mutex:\n            if self._thread is not None:\n                return\n\n            if self._rem.nlevels != 1:\n                tkinter.messagebox.showwarning(message='Can only export when exactly one level.')\n            else:\n                ind = self._rem.levels[0]\n                remaining = np.unpackbits(self._ex.level_data[ind], count=self._level_len, axis=0)\n                remaining_tiles, remaining_einds, remaining_pinds = np.split(remaining, [self._tiles_len, self._tiles_len + self._ex.neind])\n                remaining_tiles = remaining_tiles.reshape((self._ex.rows, self._ex.cols, self._ex.ntind))\n\n                filename = 'explorer-out'\n                filenames = []\n\n                tile_level = util.make_grid(self._ex.rows, self._ex.cols, util.VOID_TILE)\n                for rr in range(self._ex.rows):\n                    for cc in range(self._ex.cols):\n                        tinds = tuple(np.nonzero(remaining_tiles[rr][cc])[0])\n                        if tinds != (self._ex.void_tind,):\n                            tile_level[rr][cc] = self._ex.tinds_to_tile[tinds]\n                tile_level = util.trim_void_tile_level(tile_level)\n\n                meta = []\n                if self._ex.neind > 0:\n                    edges = [self._ex.eind_to_edge[eind] for eind in self._rem.einds]\n                    path_edges = util_path.order_edge_path(edges)\n                    meta.append(util.meta_path(util.MGROUP_PATH, path_edges))\n                if self._ex.npind > 0:\n                    props = [self._ex.pind_to_prop[pind] for pind in np.nonzero(self._rem.pinds)[0]]\n                    meta.append(util.meta_properties(props))\n\n                tile_filename = filename + '.tlvl'\n                filenames.append(tile_filename)\n                with util.openz(tile_filename, 'wt') as f:\n                    util.print_tile_level_json(tile_level, meta=meta, outfile=f)\n\n                if len(self._ex.tind_to_text) > 0:\n                    text_level = util.tile_level_to_text_level(tile_level, self._ex.tileset)\n\n                    text_filename = filename + '.lvl'\n                    filenames.append(text_filename)\n                    with util.openz(text_filename, 'wt') as f:\n                        util.print_text_level(text_level, meta=meta, outfile=f)\n\n                if len(self._ex.tind_to_image) > 0:\n                    image_level = util.tile_level_to_image_level(tile_level, self._ex.tileset)\n\n                    image_filename = filename + '.png'\n                    filenames.append(image_filename)\n                    image_level.save(image_filename)\n\n                tkinter.messagebox.showinfo(message='Exported level to:\\n' + '\\n'.join(filenames))\n\n            self.focus_force()\n\n    def on_evt_undo(self, event=None):\n        with self._mutex:\n            if self._thread is not None:\n                return\n\n            if self.undo_undo():\n                self._recompute()\n                self.redraw_from_back()\n\n    def on_evt_redo(self, event=None):\n        with self._mutex:\n            if self._thread is not None:\n                return\n\n            if self.undo_redo():\n                self._recompute()\n                self.redraw_from_back()\n\n    def on_evt_clear(self, event=None):\n        with self._mutex:\n            if self._thread is not None:\n                return\n\n            self._selected_tiles *= 0\n            self._selected_tiles_auto *= 0\n            self._selected_einds *= 0\n            self._selected_pinds *= 0\n            self.undo_push()\n            self._recompute()\n            self.redraw_from_back()\n\n    def on_evt_path_mode(self, event=None):\n        with self._mutex:\n            if self._show_paths == PATH_OFF:\n                self._show_paths = PATH_VIEW\n            elif self._show_paths == PATH_VIEW:\n                self._show_paths = PATH_EDIT\n            else:\n                self._show_paths = PATH_OFF\n            self._recompute_mouse()\n            self.redraw_from_path()\n\n    def on_evt_random(self, event=None):\n        with self._mutex:\n            if self._thread is not None:\n                return\n\n            if self._rem.nlevels <= 1:\n                return\n\n            if self._show_paths == PATH_EDIT:\n                einds = [eind for eind in self._rem.einds if self._selected_einds[eind] == 0]\n                if len(einds) > 0:\n                    eind = random.choice(einds)\n                    self._selected_einds[eind] = 1\n                    self.undo_push()\n                    self._recompute()\n                    self.redraw_from_back()\n            else:\n                remaining_choices = []\n                for rr in range(self._ex.rows):\n                    for cc in range(self._ex.cols):\n                        if len(self._rem.texts[rr][cc]) > 1 and np.sum(self._selected_tiles[rr][cc][self._tind_text]) == 0:\n                            remaining_choices.append((rr, cc, self._rem.texts[rr][cc]))\n                        if len(self._rem.images[rr][cc]) > 1 and np.sum(self._selected_tiles[rr][cc][self._tind_image]) == 0:\n                            remaining_choices.append((rr, cc, self._rem.images[rr][cc]))\n                if len(remaining_choices) > 0:\n                    rr, cc, indices = random.choice(remaining_choices)\n                    index = random.choice(indices)\n                    self._selected_tiles[rr][cc][index] = 1\n                    self.undo_push()\n                    self._recompute()\n                    self.redraw_from_back()\n\n    def on_evt_finish(self, event=None):\n        with self._mutex:\n            if self._thread is not None:\n                return\n\n            if np.count_nonzero(self._selected_tiles_auto) > 0:\n                self._selected_tiles_auto *= 0\n                self.undo_push()\n                self._recompute()\n                self.redraw_from_back()\n\n            else:\n                ind = np.random.choice(self._rem.levels, 1)[0]\n\n                remaining = np.unpackbits(self._ex.level_data[ind], count=self._level_len, axis=0)\n                remaining_tiles, remaining_einds, remaining_pinds = np.split(remaining, [self._tiles_len, self._tiles_len + self._ex.neind])\n                remaining_tiles = remaining_tiles.reshape((self._ex.rows, self._ex.cols, self._ex.ntind))\n\n                self._selected_tiles_auto = remaining_tiles\n                self.undo_push()\n                self._recompute()\n                self.redraw_from_back()\n\n    def on_mouse_motion(self, event):\n        with self._mutex:\n            self._mouse_evt = event\n            self._recompute_mouse()\n            self.redraw_from_mouse()\n\n    def on_mouse_leave(self, event):\n        with self._mutex:\n            self._mouse_evt = None\n            self._recompute_mouse()\n            self.redraw_from_mouse()\n\n    def on_mouse_button(self, event):\n        with self._mutex:\n            if self._thread is not None:\n                return\n\n            if self._mouse is not None:\n                mr, mc, md, mi = self._mouse\n\n                if mi is not None:\n                    if self._show_paths == PATH_EDIT:\n                        if self._selected_einds[mi] != 0:\n                            self._selected_einds[mi] = 0\n                        else:\n                            self._selected_einds[mi] = 1\n                    else:\n                        indices_rc, indices_sqrt_rc, indices_disp = self.rem_indices(self._displays[md])\n                        if np.count_nonzero(self._selected_tiles[mr][mc][indices_disp]) != 0:\n                            self._selected_tiles[mr][mc][indices_disp] *= 0\n                        else:\n                            index = indices_rc[mr][mc][mi]\n                            self._selected_tiles[mr][mc][indices_disp] *= 0\n                            self._selected_tiles[mr][mc][index] = 1\n\n                    self.undo_push()\n                    self._recompute()\n                    self.redraw_from_back()", "\n\n\ndef explorer(explorer_info, cell_size, text_disp, image_disp):\n    root = tkinter.Tk()\n    root.title('explorer')\n\n    print('exploring', len(explorer_info.level_data), 'levels')\n    if len(explorer_info.tind_to_text) > 0:\n        print('has text')\n    if len(explorer_info.tind_to_image) > 0:\n        print('has image')\n\n    ExplorerFrame(root, explorer_info, cell_size, text_disp, image_disp)\n\n    root.mainloop()", "\n\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='Path editor.')\n\n    parser.add_argument('--explorefile', required=True, type=str, help='Explore file to run, or write to.')\n    parser.add_argument('--cell-size', type=int, help='Size of cells.', default=CELL_SIZE_DEF)\n    parser.add_argument('--text', action='store_true', help='Try text display.')\n    parser.add_argument('--image', action='store_true', help='Try image display.')\n\n    args = parser.parse_args()\n\n    print('loading...')\n    start_time = time.time()\n\n    with util.openz(args.explorefile, 'rb') as f:\n        explore_info = pickle.load(f)\n\n    print('loaded %d levels in %0.3f' % (len(explore_info.level_data), time.time() - start_time))\n\n    explorer(explore_info, args.cell_size, args.text, args.image)", ""]}
{"filename": "util_path.py", "chunked_list": ["import util\n\nRANDOM_PATH_INSET = 1\n\ndef point_path_from_edge_path(edge_path):\n    point_path = []\n    if len(edge_path) > 0:\n        (fr, fc, tr, tc) = edge_path[0]\n        point_path.append((fr, fc))\n    for (fr, fc, tr, tc) in edge_path:\n        util.check((fr, fc) == point_path[-1], 'edge path')\n        point_path.append((tr, tc))\n    return point_path", "\ndef edge_path_from_point_path(point_path):\n    return [(a, b, c, d) for (a, b), (c, d) in zip(point_path, point_path[1:])]\n\ndef order_edge_path(edge_path_unordered):\n    src_to_dst = {}\n    dsts = {}\n    for a, b, c, d in edge_path_unordered:\n        src_to_dst[(a, b)] = (c, d)\n        dsts[(c, d)] = None\n\n    src = None\n    for a, b, c, d in edge_path_unordered:\n        if (a, b) not in dsts:\n            util.check(src is None, 'multiple starts in path')\n            src = (a, b)\n    util.check(src is not None, 'no starts in path')\n\n    edge_path = []\n    while src in src_to_dst:\n        dst = src_to_dst[src]\n        edge_path.append((src[0], src[1], dst[0], dst[1]))\n        util.check(len(edge_path) <= len(edge_path_unordered), 'path lengths')\n        src = dst\n    util.check(len(edge_path) == len(edge_path_unordered), 'path lengths')\n\n    return edge_path", "\ndef edge_path_from_lines(prefix, lines):\n    for line in lines:\n        if line.startswith(prefix):\n            edge_path = []\n            edges_str = line[len(prefix):]\n            for edge in edges_str.split(','):\n                edge = tuple([int(el) for el in edge.strip().split()])\n                util.check(len(edge) == 4, 'edge length')\n                edge_path.append(edge)\n            return edge_path\n    return None", "\ndef get_template_open_closed(move_template):\n    template_open_closed = {}\n    for dest, need_open_path, need_open_aux, need_closed in move_template:\n        need_open_close = ([(0, 0)] + need_open_path + need_open_aux + [dest], need_closed)\n        if dest not in template_open_closed:\n            template_open_closed[dest] = []\n        template_open_closed[dest].append(need_open_close)\n    return template_open_closed\n\ndef get_path_open_closed(path, template_open_closed):\n    path_open = {}\n    path_closed = {}\n\n    for (fr, fc, tr, tc) in edge_path_from_point_path(path):\n        dr, dc = tr - fr, tc - fc\n        open_sets, closed_sets = [], []\n\n        for dopen, dclosed in template_open_closed[(dr, dc)]:\n            open_set, closed_set = set(), set()\n            for (rr, cc) in dopen:\n                open_set.add((fr + rr, fc + cc))\n            open_sets.append(open_set)\n            for (rr, cc) in dclosed:\n                closed_set.add((fr + rr, fc + cc))\n            closed_sets.append(closed_set)\n\n        for open_pt in sorted(set.intersection(*open_sets)):\n            path_open[open_pt] = None\n        for closed_pt in sorted(set.intersection(*closed_sets)):\n            path_closed[closed_pt] = None\n\n    return path_open, path_closed", "\ndef get_path_open_closed(path, template_open_closed):\n    path_open = {}\n    path_closed = {}\n\n    for (fr, fc, tr, tc) in edge_path_from_point_path(path):\n        dr, dc = tr - fr, tc - fc\n        open_sets, closed_sets = [], []\n\n        for dopen, dclosed in template_open_closed[(dr, dc)]:\n            open_set, closed_set = set(), set()\n            for (rr, cc) in dopen:\n                open_set.add((fr + rr, fc + cc))\n            open_sets.append(open_set)\n            for (rr, cc) in dclosed:\n                closed_set.add((fr + rr, fc + cc))\n            closed_sets.append(closed_set)\n\n        for open_pt in sorted(set.intersection(*open_sets)):\n            path_open[open_pt] = None\n        for closed_pt in sorted(set.intersection(*closed_sets)):\n            path_closed[closed_pt] = None\n\n    return path_open, path_closed", "\ndef get_level_open_closed(text_level, open_text):\n    are_open = {}\n    are_closed = {}\n\n    util.check(util.START_TEXT not in open_text and util.GOAL_TEXT not in open_text, 'start/goal in open_text')\n\n    open_start_goal_text = open_text + util.START_TEXT + util.GOAL_TEXT\n\n    for rr in range(len(text_level)):\n        for cc in range(len(text_level[rr])):\n            if text_level[rr][cc] in open_start_goal_text:\n                are_open[(rr, cc)] = None\n            else:\n                are_closed[(rr, cc)] = None\n\n    return are_open, are_closed", "\ndef get_nexts_from(pt, rows, cols, template_open_closed, are_open, are_closed, exclude):\n    lr, lc = pt\n    nexts = {}\n\n    for dest, need_open_closeds in template_open_closed.items():\n        nr, nc = lr + dest[0], lc + dest[1]\n        if nr < 0 or rows <= nr or nc < 0 or cols <= nc:\n            continue\n        if (nr, nc) in exclude:\n            continue\n\n        for need_open, need_closed in need_open_closeds:\n            need_missing = False\n            for need_r, need_c in need_open:\n                need_r, need_c = lr + need_r, lc + need_c\n                if need_r < 0 or rows <= need_r or need_c < 0 or cols <= need_c:\n                    need_missing = True\n                if (need_r, need_c) in are_closed:\n                    need_missing = True\n            for need_r, need_c in need_closed:\n                need_r, need_c = lr + need_r, lc + need_c\n                if need_r < 0 or rows <= need_r or need_c < 0 or cols <= need_c:\n                    need_missing = True\n                if (need_r, need_c) in are_open:\n                    need_missing = True\n            if need_missing:\n                continue\n\n            nexts[(nr, nc)] = None\n\n    return nexts", "\ndef get_nexts_open_closed_from(path, reverse, rows, cols, template_open_closed):\n    path_nexts = None\n    path_open, path_closed = get_path_open_closed(path, template_open_closed)\n\n    if len(path) > 0:\n        if not reverse:\n            path_nexts = get_nexts_from(path[-1], rows, cols, template_open_closed, path_open, path_closed, path)\n        else:\n            path_nexts = {}\n            for rr in range(rows):\n                for cc in range(cols):\n                    pt = (rr, cc)\n                    if pt in path:\n                        continue\n                    if path[0] not in get_nexts_from(pt, rows, cols, template_open_closed, path_open, path_closed, path[1:]):\n                        continue\n                    path_nexts[pt] = None\n\n    return path_nexts, path_open, path_closed", "\ndef path_between(rng, start, end, rows, cols, inset, template_open_closed, are_open_closed):\n    q = []\n    seen = {}\n\n    q.append([start])\n    seen[start] = None\n\n    found_path = None\n    while len(q) > 0:\n        path = q.pop()\n\n        if path[-1] == end:\n            found_path = path\n            break\n\n        if are_open_closed is not None:\n            are_open, are_closed = are_open_closed\n        else:\n            are_open, are_closed = get_path_open_closed(path, template_open_closed)\n\n        path_nexts = get_nexts_from(path[-1], rows, cols, template_open_closed, are_open, are_closed, path)\n\n        for n in path_nexts:\n            if n[0] < inset or n[0] >= rows - inset:\n                continue\n            if n[1] < inset or n[1] >= cols - inset:\n                continue\n\n            if n not in seen:\n                q.insert(0, path + [n])\n                seen[n] = None\n\n        if rng is not None:\n            rng.shuffle(q)\n\n    return found_path", "\ndef shortest_path_between(start, end, rows, cols, template_open_closed, are_open, are_closed):\n    return path_between(None, start, end, rows, cols, 0, template_open_closed, (are_open, are_closed))\n\ndef random_path_between(rng, start, end, rows, cols, inset, template_open_closed):\n    return path_between(rng, start, end, rows, cols, inset, template_open_closed, None)\n\ndef random_path_by_search(rng, rows, cols, template_open_closed):\n    pts = []\n    for rr in range(RANDOM_PATH_INSET, rows - RANDOM_PATH_INSET):\n        for cc in range(RANDOM_PATH_INSET, cols - RANDOM_PATH_INSET):\n            pts.append((rr, cc))\n    start, end = rng.sample(pts, 2)\n\n    return random_path_between(rng, start, end, rows, cols, RANDOM_PATH_INSET, template_open_closed)", ""]}
{"filename": "explore2summary.py", "chunked_list": ["import argparse, json, pickle, sys, time\nimport util, util_explore\nimport numpy as np\n\n\ndef explore2summary(ex, summarize_levels, summarize_edges):\n    level_length = ex.rows * ex.cols * ex.ntind + ex.neind + ex.npind\n\n    print('levels:', ex.level_data.shape[0])\n    print('level length:', level_length)\n    print('level length (packed):', ex.level_data.shape[1])\n    print('size:', ex.rows, 'rows,', ex.cols, 'cols')\n    print('tile indices / bits:', ex.ntind, '/', ex.rows * ex.cols * ex.ntind)\n    print('edge indices:', ex.neind)\n    print('property indices:', ex.npind)\n\n    image_ids = {}\n    for tind, image in ex.tind_to_image.items():\n        image_id = id(image)\n        if image_id not in image_ids:\n            image_ids[image_id] = util.index_to_char(len(image_ids))\n\n    print('index text:  ', ''.join([(ex.tind_to_text[tind] if tind in ex.tind_to_text else ' ') for tind in range(ex.ntind)]))\n    print('index image: ', ''.join([(image_ids[id(ex.tind_to_image[tind])] if tind in ex.tind_to_image else ' ')  for tind in range(ex.ntind)]))\n\n    tile_to_tinds = {}\n    for tinds, tile in ex.tinds_to_tile.items():\n        tile_to_tinds[tile] = tinds\n\n    tiles_strings = []\n    for tile in ex.tileset.tile_ids:\n        tile_string = str(tile) + ':'\n        for tind in tile_to_tinds[tile]:\n            if tind in ex.tind_to_text:\n                tile_string = tile_string + ex.tind_to_text[tind]\n            if tind in ex.tind_to_image:\n                tile_string = tile_string + image_ids[id(ex.tind_to_image[tind])]\n        tiles_strings.append(tile_string)\n\n    print('tiles:', ' '.join(tiles_strings))\n\n    print('void tile:', 'yes' if ex.void_tind is not None else 'no')\n\n    print('properties:', '; '.join(ex.pind_to_prop.values()))\n\n    if summarize_edges:\n        print('edges:')\n        for eind in range(ex.neind):\n            print(ex.eind_to_edge[eind])\n\n    if summarize_levels:\n        print('levels:')\n        print(''.join(((['T'] + ['t'] * (ex.ntind - 1)) * (ex.rows * ex.cols)) + ['e'] * ex.neind  + ['p'] * ex.npind))\n        levels_unpacked = np.unpackbits(ex.level_data, count=level_length, axis=1)\n        for level in levels_unpacked:\n            print(''.join([str(vv) for vv in level]))", "\nif __name__ == '__main__':\n    util.timer_start()\n\n    parser = argparse.ArgumentParser(description='Summarize explore file.')\n    parser.add_argument('--explorefile', required=True, type=str, help='Input explore file.')\n    parser.add_argument('--levels', action='store_true', help='Include levels in summary.')\n    parser.add_argument('--edges', action='store_true', help='Include edges in summary.')\n    args = parser.parse_args()\n\n    with util.openz(args.explorefile, 'rb') as f:\n        ex = pickle.load(f)\n\n    explore2summary(ex, args.levels, args.edges)", ""]}
{"filename": "util_explore.py", "chunked_list": ["class ExploreInfo:\n    def __init__(self):\n        self.rows = None\n        self.cols = None\n\n        self.tileset = None\n\n        self.ntind = None\n        self.neind = None\n        self.npind = None\n\n        self.void_tind = None\n\n        self.tind_to_text = None\n        self.tind_to_image = None\n        self.tinds_to_tile = None\n        self.eind_to_edge = None\n        self.pind_to_prop = None\n\n        self.level_data = None", ""]}
