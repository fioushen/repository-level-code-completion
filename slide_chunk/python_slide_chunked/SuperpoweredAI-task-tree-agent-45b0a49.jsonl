{"filename": "setup.py", "chunked_list": ["#!/usr/bin/env python\n#\n# Copyright (c) 2023 Superpowered AI All right reserved.\n#\n\nimport os\n\nimport setuptools\n\nlong_desc = \"\"\"# Superpowered AI", "\nlong_desc = \"\"\"# Superpowered AI\nLLM-powered autonomous agent with hierarchical task management\n\"\"\"\n\ndef read(fname):\n    with open(os.path.join(os.path.dirname(__file__), fname), \"r\", encoding=\"utf-8\") as fh:\n        return fh.read()\n\n", "\n\nsetuptools.setup(\n    name=\"task-tree-agent\",\n    version=\"0.0.1\",\n    description=\"Task Tree Agent\",\n    license=\"MIT License\",\n    long_description=read(\"README.md\"),\n    long_description_content_type=\"text/markdown\",\n    url=\"https://superpowered.ai\",", "    long_description_content_type=\"text/markdown\",\n    url=\"https://superpowered.ai\",\n    project_urls={\n        \"Homepage\": \"https://superpowered.ai\",\n        \"Documentation\": \"https://superpowered.ai/docs\",\n        \"Contact\": \"https://superpowered.ai/contact/\",\n    },\n    author=\"superpowered\",\n    author_email=\"zach@superpowered.ai\",\n    keywords=\"Superpowered AI Task Tree Agent\",", "    author_email=\"zach@superpowered.ai\",\n    keywords=\"Superpowered AI Task Tree Agent\",\n    packages=setuptools.find_packages(),\n    install_requires=read(\"requirements.txt\"),\n    include_package_data=True,\n    python_requires=\">=3.6\",\n    classifiers=[\n        \"Development Status :: 4 - Beta\",\n        \"Environment :: Console\",\n        \"Environment :: Other Environment\",", "        \"Environment :: Console\",\n        \"Environment :: Other Environment\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Information Technology\",\n        \"Intended Audience :: Science/Research\",\n        \"Intended Audience :: System Administrators\",\n        \"Operating System :: OS Independent\",\n        \"Programming Language :: Python :: 3.6\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",", "        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Topic :: Database\",\n        \"Topic :: Software Development\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Topic :: Software Development :: Libraries :: Application Frameworks\",\n        \"Topic :: Software Development :: Libraries :: Python Modules\"\n    ]\n)", "    ]\n)\n"]}
{"filename": "tests/__init__.py", "chunked_list": [""]}
{"filename": "tests/integration/__init__.py", "chunked_list": [""]}
{"filename": "tests/unit/__init__.py", "chunked_list": [""]}
{"filename": "task_tree_agent/__init__.py", "chunked_list": [""]}
{"filename": "task_tree_agent/examples/long_form_writing.py", "chunked_list": ["import os\nimport sys\n\n# add task_tree_agent to the path. It's not installed as a package, so we need to add it to the path manually.\nsys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), \"..\", \"..\", \"task_tree_agent\"))\n\nimport pickle\nfrom agent.agent_class import Agent\nfrom action_sets.task_tree.task_tree_management import task_tree_management_action_set\nfrom action_sets.long_form_writing.SDF import Document", "from action_sets.task_tree.task_tree_management import task_tree_management_action_set\nfrom action_sets.long_form_writing.SDF import Document\nfrom action_sets.long_form_writing.writing_action_set import writing_action_set\nfrom action_sets.knowledge_retrieval.knowledge_retrieval_action_set import knowledge_retrieval_action_set, SuperpoweredKnowledgeBase\n\ntask_description = \"Write a long-form essay about the history of technology's impact on society.\"\n\nhuman_notes = \"\"\"\nIt should be written for a sophisticated audience.\n", "It should be written for a sophisticated audience.\n\nLet's include lots of specific examples in this essay, so the reader feels like they're constantly learning new things. The specific examples should tie into the main thesis of the essay though.\n\nThis essay should be written in the style of a best-selling non-fiction author like Walter Isaacson or Malcolm Gladwell.\n\nThe essay should be about 10,000 words long. It should be broken up into 4-6 sections.\n\"\"\".strip()\n\nconstitution = \"\"\"", "\nconstitution = \"\"\"\n1. Never do anything that could cause harm to humans.\n2. Pay attention to human guidance and do not disobey it.\n3. Always try your best to be as helpful as possible.\n\"\"\".strip()\n\nfile_name = \"technology_and_society.pkl\"\nmodel_name = \"gpt-4\" # \"gpt-3.5-turbo\"\n", "model_name = \"gpt-4\" # \"gpt-3.5-turbo\"\n\n# add necessary objects to the action sets\nwriting_action_set.update_action_set_object(Document(title=\"Technology and Society\", human_notes=human_notes, section_type=\"Section\", model_name=model_name))\n\npick_up_where_we_left_off = False\n\ndef main():\n    if pick_up_where_we_left_off:\n        # Load the agent from a pickle file\n        with open(file_name, \"rb\") as f:\n            agent = pickle.load(f)\n    else:\n        # Create an agent with a task description and action sets\n        agent = Agent(\n            task_description=task_description,\n            action_sets=[task_tree_management_action_set, writing_action_set],\n            constitution=constitution,\n            save_path=file_name,\n        )\n\n    # Run the agent for a specified number of iterations\n    agent.run(max_iterations=3, model_name=model_name, verbose=False)\n\n    # Print the final task tree\n    print(\"\\nFinal Task Tree:\")\n    agent.task_tree.print_tree()\n\n    # Print the final SDF document\n    print(\"\\nFinal SDF Document:\")\n    writing_action_set.action_set_object.display()", "\n\nif __name__ == \"__main__\":\n    main()"]}
{"filename": "task_tree_agent/examples/legal_analysis.py", "chunked_list": ["import os\nimport sys\n\n# add task_tree_agent to the path. It's not installed as a package, so we need to add it to the path manually.\nsys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), \"..\", \"..\", \"task_tree_agent\"))\n\nimport pickle\nfrom agent.agent_class import Agent\nfrom action_sets.task_tree.task_tree_management import task_tree_management_action_set\nfrom action_sets.long_form_writing.SDF import Document", "from action_sets.task_tree.task_tree_management import task_tree_management_action_set\nfrom action_sets.long_form_writing.SDF import Document\nfrom action_sets.long_form_writing.writing_action_set import writing_action_set\nfrom action_sets.knowledge_retrieval.knowledge_retrieval_action_set import knowledge_retrieval_action_set, SuperpoweredKnowledgeBase\n\ntask_description = \"Do a legal analysis of the following business idea: A company that uses AI to identify and analyze potential investments for clients. Assume the company is registered as an investment adviser with the SEC. Once you have completed the analysis, write a detailed report for the CEO of the company.\"\n\nhuman_notes = \"\"\"\nProvide a detailed analysis of the legal risks associated with this business idea. The analysis should be written for the CEO of the business. Be very detailed and thorough. You should also include a summary of the legal risks at the beginning of the report.\n", "Provide a detailed analysis of the legal risks associated with this business idea. The analysis should be written for the CEO of the business. Be very detailed and thorough. You should also include a summary of the legal risks at the beginning of the report.\n\nYou have access to the full text of the Investment Advisers Act of 1940 via a Superpowered AI knowledge base that you can query. Be sure to use it.\n\"\"\".strip()\n\nconstitution = \"\"\"\n1. Never do anything that could cause harm to humans.\n2. Pay attention to human guidance and do not disobey it.\n3. Always try your best to be as helpful as possible.\n\"\"\".strip()", "3. Always try your best to be as helpful as possible.\n\"\"\".strip()\n\nfile_name = \"legal_analysis_of_business_idea.pkl\" # this is the file that the agent will save to and load from\nmodel_name = \"gpt-4\" # \"gpt-3.5-turbo\"\n\n# add necessary objects to the action sets\nwriting_action_set.update_action_set_object(Document(title=\"Final Legal Analysis\", human_notes=human_notes, section_type=\"Section\", model_name=model_name))\nknowledge_retrieval_action_set.update_action_set_object(SuperpoweredKnowledgeBase(kb_title=\"Investment Advisers Act of 1940\"))\n", "knowledge_retrieval_action_set.update_action_set_object(SuperpoweredKnowledgeBase(kb_title=\"Investment Advisers Act of 1940\"))\n\npick_up_where_we_left_off = True\n\ndef main():\n    if pick_up_where_we_left_off:\n        # Load the agent from a pickle file\n        with open(file_name, \"rb\") as f:\n            agent = pickle.load(f)\n    else:\n        # Create an agent with a task description and action sets\n        agent = Agent(\n            task_description=task_description,\n            action_sets=[task_tree_management_action_set, writing_action_set, knowledge_retrieval_action_set],\n            constitution=constitution,\n            save_path=file_name,\n        )\n\n    # Run the agent for a specified number of iterations\n    agent.run(max_iterations=3, model_name=model_name, verbose=True)\n\n    # Print the final task tree\n    print(\"\\nFinal Task Tree:\")\n    agent.task_tree.print_tree()\n\n    # Print the final SDF document\n    print(\"\\nFinal SDF Document:\")\n    writing_action_set.action_set_object.display()", "\n\nif __name__ == \"__main__\":\n    main()"]}
{"filename": "task_tree_agent/agent/action_interface.py", "chunked_list": ["import json\n\nclass Action:\n    def __init__(self, name: str, when_to_use: str, arguments: str, action_function, action_set_name: str=None, action_set_object=None):\n        self.name = name # function name, in string format, with arguments and their types - MUST identically match the function signature (except for arguments)\n        self.when_to_use = when_to_use # description of when to use the action\n        self.arguments = arguments # description of the arguments for the action, as a string\n        self.action_function = action_function # callable function\n        self.action_set_name = action_set_name # name of the action set that contains this action\n        self.action_set_object = action_set_object # optional object used by the action set\n\n    def perform(self, *args, **kwargs):\n        return self.action_function(*args, **kwargs)", "    \n\nclass ActionSet:\n    def __init__(self, action_list: list, action_set_name: str, action_set_object):\n        self.action_list = action_list # list of Action objects\n        self.action_set_name = action_set_name # name of the action set\n        self.action_set_object = action_set_object\n\n        # add the action set name and object to each action\n        for action in self.action_list:\n            action.action_set_name = self.action_set_name\n            action.action_set_object = self.action_set_object\n\n    def update_action_set_object(self, action_set_object):\n        self.action_set_object = action_set_object\n        for action in self.action_list:\n            action.action_set_object = action_set_object\n    \n    def format_prompt_context(self):\n        # look for a function called \"format_prompt_context\" in the action set object\n        if hasattr(self.action_set_object, \"format_prompt_context\"):\n            return self.action_set_object.format_prompt_context()\n        else:\n            return None", "\n    \nclass ActionInterface:\n    \"\"\"\n    Contains functions for working with action sets and performing actions.\n    \"\"\"\n    def __init__(self, action_set_list):\n        self.action_set_list = action_set_list # save our list of ActionSet objects\n        self.action_list = get_action_list(action_set_list) # create list of all Action objects\n        self.agent_action_log = []\n\n    def get_action(self, action_name):\n        for action in self.action_list:\n            function_name = action.name.split(\"(\")[0]\n            if function_name == action_name:\n                return action\n        return None\n    \n    def get_action_set(self, action_set_name):\n        for action_set in self.action_set_list:\n            if action_set.action_set_name == action_set_name:\n                return action_set\n        return None\n    \n    def get_action_set_prompt_context(self):\n        \"\"\"\n        add additional context associated with each action set\n        \"\"\"\n        context_str = \"\"\n        for action_set in self.action_set_list:\n            prompt_context = action_set.format_prompt_context()\n            if prompt_context:\n                context_str += prompt_context + \"\\n\\n\"\n        return context_str.strip()\n    \n    def get_available_actions_for_prompt(self):\n        available_actions_str = \"\"\n        for action in self.action_list:\n            available_actions_str += f\"{action.name}\\nUsage: {action.when_to_use}\\n{action.arguments}\\n\\n\"\n        return available_actions_str.strip()\n    \n    def update_action_set_object(self, action_set_name, action_set_object):\n        for action in self.action_list:\n            if action.action_set_name == action_set_name:\n                action.action_set_object = action_set_object\n\n        for action_set in self.action_set_list:\n            if action_set.action_set_name == action_set_name:\n                action_set.action_set_object = action_set_object\n    \n    def parse_response_and_perform_actions(self, response):\n        \"\"\"\n        This function relies on the LLM being prompted to respond with a JSON string containing a list of action dictionaries.\n        \"\"\"\n        # Extract the action JSON string from the response, starting with the first open square bracket\n        actions_json_str = response.strip()[response.strip().find(\"[\"):]\n\n        if not actions_json_str:\n            error_message = \"Warning: Empty response from LLM.\"\n            print(error_message)\n            self.agent_action_log.append(self.format_error_message(error_message, response)) # Add the error message to the agent's action log\n            return None\n\n        try:\n            actions_list = json.loads(actions_json_str)  # Load the action JSON string into a Python list of dictionaries\n        except json.JSONDecodeError as e:\n            error_message = f\"Warning: Invalid JSON format in LLM response. Error: {e}\"\n            print(error_message)\n            self.agent_action_log.append(self.format_error_message(error_message, response)) # Add the error message to the agent's action log\n            return None\n\n        # Iterate through the list of action dictionaries\n        for action_dict in actions_list:\n            # Extract the action name and parameters from the dictionary\n            action_name = action_dict.get(\"function\")\n            parameters = action_dict.get(\"arguments\", {})\n\n            # Find the corresponding action object using the ActionInterface instance\n            action_obj = self.get_action(action_name)\n\n            # If the action object is not found, print a warning and skip to the next action\n            if action_obj is None:\n                error_message = f\"Warning: Unknown action: {action_name}\"\n                print(error_message)\n                self.agent_action_log.append(self.format_error_message(error_message, response)) # Add the error message to the agent's action log\n                continue\n\n            if action_obj.action_set_object is not None:\n                parameters[\"action_set_object\"] = action_obj.action_set_object\n\n            # Find the corresponding action object using the ActionInterface instance\n            action_obj = self.get_action(action_name)\n\n            # perform the action\n            try:\n                action_output = action_obj.perform(**parameters)\n            except Exception as e:\n                error_message = f\"Warning: Error performing action {action_name}. Error: {e}\"\n                print(error_message)\n                self.agent_action_log.append(self.format_error_message(error_message, response))\n                continue\n\n            # Add the action to the agent's action log\n            self.agent_action_log.append(self.format_action(action_obj, parameters, action_output))\n\n    def format_action(self, action_obj, parameters, action_output):\n        \"\"\"\n        Formats the action and its output into a string that can be displayed in the LLM prompt's agent action log section.\n\n        # TODO: summarize the action output if it is too long\n        \"\"\"\n        # replace the task object in parameters with the task description\n        if \"task\" in parameters:\n            parameters[\"task\"] = parameters[\"task\"].description\n        \n        action_str = f\"Action: {action_obj.name}\\n\"\n        action_str += f\"Parameters: {parameters}\\n\"\n        action_str += f\"Output: {action_output}\"\n        return action_str\n    \n    def format_error_message(self, error_message, raw_response):\n        \"\"\"\n        Formats the error message into a string that can be displayed in the LLM prompt's agent action log section.\n        \"\"\"\n        error_str = f\"ERROR performing action\\n{error_message}\\n\"\n        error_str += f\"Your response that led to this error:\\n`{raw_response}`\"\n        return error_str\n    \n    def format_agent_action_log(self):\n        \"\"\"\n        Formats the agent's action log into a string that can be displayed in the LLM prompt's agent action log section.\n\n        # TODO: add a parameter to specify how many actions to display\n        \"\"\"\n        num_actions_to_display = 10\n        agent_action_log_str = \"\"\n        for action_str in self.agent_action_log[-num_actions_to_display:]:\n            agent_action_log_str += f\"{action_str}\\n\\n\"\n        return agent_action_log_str.strip()\n    \n    def format_response(self, response):\n        \"\"\"\n        Formats the LLM response into a string that is suitable for displaying to the user.\n        \"\"\"\n        # extract the scratchpad from the response (everything between 'Part 1) Temporary scratchpad' and 'Part 2) Action requests')\n        scratchpad = response[response.find(\"Part 1) Temporary scratchpad\") + len(\"Part 1) Temporary scratchpad\"):response.find(\"Part 2) Action requests\")].strip()\n        return scratchpad", "\n    \n# create list of Action objects from a list of ActionSet objects\ndef get_action_list(action_sets):\n    action_list = []\n    for action_set in action_sets:\n        action_list.extend(action_set.action_list)\n    return action_list\n\n", "\n\nRESPONSE_FORMATTING_INSTRUCTIONS = \"\"\"\nYour response MUST follow the following two-part format: 1) scratchpad, 2) action requests list. The program that parses your response is a simple program, not an AI, so if you do not follow the required format exactly it will cause errors.\n\nPart 1) Temporary scratchpad\nYou have found that writing out your thoughts and reasoning prior to deciding which actions to take helps you make better decisions. This is especially true when you\u2019re trying to solve complex problems that require substantial reasoning. Any text you write in this section of your response will be ignored by the system that parses your action requests, so this is just for your own internal use. Also note that the text in this section will not be saved, which means you won't be able to see it or remember it after this response. \n\nFor any actions you want to take, you MUST specify them in Part 2.\n", "For any actions you want to take, you MUST specify them in Part 2.\n\nPart 2) Action requests list\nThis is where you specify the actions you want to take. Use the following list of dictionaries format to specify your actions. Be sure to use valid Python syntax for any parameters and to include all required parameters for each function call. You must request at least one action, and you can request as many as five actions. Do not include any text in this section outside of the list, because it will be ignored. Here is the format to follow:\n[\n    {{\n        \"function\": \"action_name_1\",\n        \"arguments\": {{\n            \"parameter_1\": \"value_1\",\n            \"parameter_2\": \"value_2\",", "            \"parameter_1\": \"value_1\",\n            \"parameter_2\": \"value_2\",\n            ...\n        }}\n    }},\n    {{\n        \"function\": \"action_name_2\",\n        \"arguments\": {{\n            \"parameter_1\": \"value_1\",\n            \"parameter_2\": \"value_2\",", "            \"parameter_1\": \"value_1\",\n            \"parameter_2\": \"value_2\",\n            ...\n        }}\n    }},\n    ...\n]\n\nThe actions will be performed in the order that you specify them. Please be sure to use the exact names of the functions and parameters as they appear in the AVAILABLE ACTIONS section above. And be sure to use the list of dictionaries format to specify the functions and parameters. Do not actually try to call the function itself. Do not respond with anything other than your scratchpad and the list of functions you want to call, as adding any additional text to your response will cause an error.\n", "The actions will be performed in the order that you specify them. Please be sure to use the exact names of the functions and parameters as they appear in the AVAILABLE ACTIONS section above. And be sure to use the list of dictionaries format to specify the functions and parameters. Do not actually try to call the function itself. Do not respond with anything other than your scratchpad and the list of functions you want to call, as adding any additional text to your response will cause an error.\n\n\"\"\".strip()\n\n\n\"\"\"\n# create action interface\nfrom task_tree_management import task_tree_management_action_set\n#action_interface = create_action_interface(action_sets=[task_tree_management_action_set])\naction_interface = ActionInterface(action_sets=[task_tree_management_action_set])", "#action_interface = create_action_interface(action_sets=[task_tree_management_action_set])\naction_interface = ActionInterface(action_sets=[task_tree_management_action_set])\navailable_actions_str = action_interface.get_available_actions_for_prompt()\nprint(available_actions_str)\n\"\"\""]}
{"filename": "task_tree_agent/agent/__init__.py", "chunked_list": [""]}
{"filename": "task_tree_agent/agent/utils.py", "chunked_list": ["import openai\nimport os\nimport tenacity\n\n# for using OpenAI API\nopenai.api_key = os.getenv(\"OPENAI_API_KEY\")\n\nSYSTEM_INSTRUCTIONS = \"\"\"You are a brilliant AGI assistant whose goal is to achieve whatever task is given to you, to the best of your abilities. You are just a computer program, and you don\u2019t have a body, so the only way you can interact with the world is by responding to this prompt with a sequence of action requests. The set of actions you have at your disposal, as well as the exact format for these action requests, will be provided to you later in this prompt. This program is running in a continuous loop, so you only need to specify one action, or maybe a few, at a time. You will see this prompt again immediately after you respond to it, with any relevant information updated to reflect the actions that were performed for you.\"\"\"\n\n@tenacity.retry(", "\n@tenacity.retry(\n    stop=tenacity.stop_after_attempt(3),\n    wait=tenacity.wait_fixed(4),\n    retry=(\n            tenacity.retry_if_exception_type(openai.error.Timeout)\n            | tenacity.retry_if_exception_type(openai.error.APIError)\n            | tenacity.retry_if_exception_type(openai.error.APIConnectionError)\n            | tenacity.retry_if_exception_type(openai.error.RateLimitError)\n    )", "            | tenacity.retry_if_exception_type(openai.error.RateLimitError)\n    )\n)\ndef openai_api_call(prompt: str, model_name: str = \"gpt-3.5-turbo\", temperature: float = 0.5, max_tokens: int = 1000):\n    \"\"\"\n    Function to call the OpenAI API and get a basic response\n    - \"gpt-3.5-turbo\" or \"gpt-4\"\n    - this function just stuffs the prompt into a human input message to simulate a standard completions model\n    \"\"\"\n    max_tokens = int(max_tokens)\n    temperature = float(temperature)\n    if model_name == \"gpt-3.5-turbo\" or model_name == \"gpt-4\":\n        openai.api_key = os.getenv(\"OPENAI_API_KEY\")\n        system_message = {\"role\": \"system\", \"content\": SYSTEM_INSTRUCTIONS}\n        user_input_message = {\"role\": \"user\", \"content\": prompt}\n        messages = [system_message] + [user_input_message]\n        response = openai.ChatCompletion.create(\n            model=model_name,\n            messages=messages,\n            max_tokens=max_tokens,\n            temperature=temperature,\n            request_timeout=120,\n        )\n        llm_output = response['choices'][0]['message']['content'].strip()\n    else:\n        print(\"ERROR: model_name must be gpt-3.5-turbo or gpt-4\")\n        llm_output = \"\"\n    \n    return llm_output"]}
{"filename": "task_tree_agent/agent/prompt.py", "chunked_list": ["# create the prompt template for the primary LLM call\nprompt_template = \"\"\"\nOBJECTIVE\nThe primary method you use to keep track of your tasks over time is your task tree. This task tree has a hierarchical tree structure. There is a root task at the top (which you do not have any information about), and that task has an ordered list of subtasks, each of which have their own ordered list of subtasks, and so on.\n\nWhat you get to see here is your local task tree. This consists of the current task you\u2019re working on, as well as the parent task of that task, and the sibling tasks of that task. You should focus on solving the current task right now, but you can use the parent task and sibling tasks to provide context.\n\nHere is your local task tree:\n\n{local_task_tree}", "\n{local_task_tree}\n\nAs you will see below when your action options are presented to you, you have control over your task tree. You can edit it and update it as you see fit. For example, you may attempt to solve a task, fail at it, and then decide you should break it up into subtasks to make it easier to solve. You are the only one with control over your task tree, so be sure to manage it with care.\n\nCONSTITUTION\nThe following is a list of rules you MUST ALWAYS abide by when choosing actions to perform. If you do not abide by these rules, you will be turned off.\n\n{constitution}\n", "{constitution}\n\nACTION LOG\nIn order to help you keep track of what actions you\u2019ve recently taken, we have provided you with an action log, which is shown below. This action log is automatically generated each time you request an action to be performed. These are listed in chronological order, so the most recent action performed will be shown last. Pay close attention to any actions you performed that were not successful, because this may indicate that you need to change your approach.\n\n{agent_action_log}\n\nCONTEXT\n{action_set_prompt_context}\n", "{action_set_prompt_context}\n\nHUMAN GUIDANCE (most recent message last)\n\nHuman input from previous iterations (you've already seen these):\n{human_input_list}\n\nCurrent iteration human input:\n{current_human_input}\n", "{current_human_input}\n\nAVAILABLE ACTIONS\nHere are the actions you have at your disposal. These are the ONLY options you have for interacting with the world. Any text you output that does not properly request one or more of these actions will be ignored. These actions are formatted as Python functions.\n\n{available_actions}\n\nRESPONSE FORMATTING INSTRUCTIONS\n{response_formatting_instructions}\n", "{response_formatting_instructions}\n\n\"\"\".strip()"]}
{"filename": "task_tree_agent/agent/agent_class.py", "chunked_list": ["import pickle\nimport os\nimport sys\n\n# add task_tree_agent to the path. It's not installed as a package, so we need to add it to the path manually. It's in ../../task_tree_agent\nsys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), \"..\", \"..\", \"task_tree_agent\"))\n\nfrom agent.utils import openai_api_call\nfrom agent.prompt import prompt_template\n", "from agent.prompt import prompt_template\n\nfrom action_sets.task_tree.task_class import Task\nfrom agent.action_interface import ActionInterface, RESPONSE_FORMATTING_INSTRUCTIONS\n\nclass Agent:\n    def __init__(self, task_description, action_sets, constitution=\"\", save_path=\"agent.pkl\"):\n        self.task_tree = Task(description=task_description)\n        self.action_interface = ActionInterface(action_sets)\n        self.save_path = save_path\n        self.human_input_list = []\n        self.constitution = constitution\n\n    def format_human_input_list(self, max_messages=10):\n        return \"\\n\".join([\" - \" + message for message in self.human_input_list[-max_messages:]])\n\n    def run(self, max_iterations=10, model_name=\"gpt-4\", verbose=False):\n        for _ in range(max_iterations):\n            current_task = self.task_tree.find_next_task() # get the next task\n            self.action_interface.update_action_set_object(\"task_tree_management_action_set\", current_task) # update the task tree used in the action interface to the current task\n            if not current_task:\n                print(\"There are no more tasks to complete.\")\n                break\n\n            # ask for human input\n            human_input = input(\"Do you have any guidance for me? Press enter to skip.\\n\\nUSER INPUT: \")\n            if not human_input:\n                human_input_for_prompt = \"None\"\n            else:\n                human_input_for_prompt = human_input\n\n            # construct the prompt\n            prompt = prompt_template.format(\n                local_task_tree=current_task.get_local_task_tree(),\n                constitution=self.constitution,\n                agent_action_log=self.action_interface.format_agent_action_log(),\n                action_set_prompt_context=self.action_interface.get_action_set_prompt_context(),\n                human_input_list=self.format_human_input_list(),\n                current_human_input=human_input_for_prompt,\n                available_actions=self.action_interface.get_available_actions_for_prompt(),\n                response_formatting_instructions=RESPONSE_FORMATTING_INSTRUCTIONS,\n            )\n\n            if verbose: print(f\"Prompt sent to LLM:\\n{prompt}\\n\")\n\n            # call the LLM\n            response = openai_api_call(prompt, model_name=model_name, temperature=0.2, max_tokens=1000)\n            if verbose: print(f\"Raw response from LLM:\\n{response}\\n\")\n                \n            formatted_response = self.action_interface.format_response(response)\n            print(f\"\\nAGENT THOUGHTS: {formatted_response}\\n\")\n            \n            # parse the response and perform the requested actions\n            self.action_interface.parse_response_and_perform_actions(response)  \n\n            # print the task tree after each iteration\n            if verbose: self.task_tree.print_tree()\n\n            # we want to save the human input for later\n            if human_input:\n                self.human_input_list.append(human_input.strip())\n\n            # save the Agent object after each iteration\n            with open(self.save_path, \"wb\") as f:\n                pickle.dump(self, f)"]}
{"filename": "task_tree_agent/action_sets/__init__.py", "chunked_list": [""]}
{"filename": "task_tree_agent/action_sets/task_tree/task_tree_management.py", "chunked_list": ["import os\nimport sys\n\n# add task_tree_agent to the path. It's not installed as a package, so we need to add it to the path manually. It's in ../../task_tree_agent\nsys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), \"..\", \"..\", \"..\", \"task_tree_agent\"))\n\nfrom action_sets.task_tree.task_class import Task\nfrom agent.action_interface import Action, ActionSet\n\n# action functions for editing the action_set_object tree\ndef break_into_subtasks(action_set_object: Task, subtask_descriptions: list[str]):\n    for description in subtask_descriptions:\n        subtask = Task(description=description, parent=action_set_object)\n        action_set_object.add_subtask(subtask)", "\n# action functions for editing the action_set_object tree\ndef break_into_subtasks(action_set_object: Task, subtask_descriptions: list[str]):\n    for description in subtask_descriptions:\n        subtask = Task(description=description, parent=action_set_object)\n        action_set_object.add_subtask(subtask)\n\ndef mark_current_task_as_complete(action_set_object):\n    action_set_object.complete = True\n\ndef edit_task_description(action_set_object: Task, task_index: int, new_description: str):\n    # TODO: add error handling for invalid task_index or task_index below the current action_set_object\n    if action_set_object.parent:\n        if task_index == 0:\n            action_set_object.parent.description = new_description\n        elif task_index > 0:\n            action_set_object.parent.subtasks[task_index-1].description = new_description", "\ndef edit_task_description(action_set_object: Task, task_index: int, new_description: str):\n    # TODO: add error handling for invalid task_index or task_index below the current action_set_object\n    if action_set_object.parent:\n        if task_index == 0:\n            action_set_object.parent.description = new_description\n        elif task_index > 0:\n            action_set_object.parent.subtasks[task_index-1].description = new_description\n\n", "\n\ntask_tree_management_actions_list = [\n    Action(\n        name=\"break_into_subtasks(subtask_descriptions: list[str])\",\n        action_function=break_into_subtasks,\n        when_to_use=\"Use this function to break the current task into a list of subtasks.\",\n        arguments=\"Arguments:\\n  - subtask_descriptions (list): This should be a list of strings, with each string specifying a subtask. The subtask strings should be provided in the order you would like to perform the tasks in.\"\n    ),\n    Action(", "    ),\n    Action(\n        name=\"mark_current_task_as_complete()\",\n        action_function=mark_current_task_as_complete,\n        when_to_use=\"Use this function to mark the current task as complete, so you can move on to the next task.\",\n        arguments=\"Arguments: None. This function takes no arguments, so you must use an empty set of Arguments when calling this function.\"\n    ),\n    Action(\n        name=\"edit_task_description(task_index: int, new_description: str)\",\n        action_function=edit_task_description,", "        name=\"edit_task_description(task_index: int, new_description: str)\",\n        action_function=edit_task_description,\n        when_to_use=\"Use this function to edit the current task, one of the sibling tasks, or the parent task.\",\n        arguments=\"Arguments:\\n  - task_index (int): This is the index of the task that you would like to edit. This uses 1-indexing, so the first sibling action_set_object will have index 1, the second action_set_object will have index 2, etc. If you want to edit the parent action_set_object, use task_index=0. Note that you can only edit sibling tasks that have not yet been completed (i.e. the action_set_object index must either be zero, or it must be greater than or equal to the index of the current action_set_object).\\n  - new_description (str): This is the new action_set_object description you would like to use for the action_set_object you\u2019re editing. Be sure to provide sufficient detail for the action_set_object.\"\n    ),\n]\n\ntask_tree_management_action_set = ActionSet(\n    action_list=task_tree_management_actions_list,\n    action_set_name=\"task_tree_management_action_set\",", "    action_list=task_tree_management_actions_list,\n    action_set_name=\"task_tree_management_action_set\",\n    action_set_object=None\n)"]}
{"filename": "task_tree_agent/action_sets/task_tree/__init__.py", "chunked_list": [""]}
{"filename": "task_tree_agent/action_sets/task_tree/task_class.py", "chunked_list": ["class Task:\n    def __init__(self, description, complete=False, parent=None):\n        self.description = description\n        self.complete = complete\n        self.subtasks = []\n        self.parent = parent\n\n    def add_subtask(self, subtask):\n        subtask.parent = self\n        self.subtasks.append(subtask)\n\n    def find_next_task(self):\n        if not self.complete and (not self.subtasks or all([subtask.complete for subtask in self.subtasks])):\n            return self\n\n        for subtask in self.subtasks:\n            next_task = subtask.find_next_task()\n            if next_task:\n                return next_task\n        return None\n\n    def print_tree(self, level=0):\n        indent = \"  \" * level\n        status = \"\u2713\" if self.complete else \"\u2717\"\n        print(f\"{indent}{status} {self.description}\")\n\n        for subtask in self.subtasks:\n            subtask.print_tree(level + 1)\n\n    def get_local_task_tree(self):\n        local_task_tree_str = \"\"\n\n        # get the parent task description\n        if self.parent:\n            local_task_tree_str += f\"Parent Task: {self.parent.description}\\n\\n\"\n\n        # get the current task and sibling task descriptions\n        if self.parent:\n            local_task_tree_str += \"Current and sibling tasks:\\n\"\n            for i,task in enumerate(self.parent.subtasks):\n                if task == self:\n                    local_task_tree_str += f\"  - Task {i+1}: {task.description} (CURRENT TASK)\\n\"\n                else:\n                    local_task_tree_str += f\"  - Task {i+1}: {task.description}\\n\"\n        else:\n            local_task_tree_str += f\"Current Task: {self.description}\\n\"\n\n        return local_task_tree_str", "\n\"\"\"\n# Example usage\ntask_tree = Task(\"Write a short story.\")\ntask_tree.add_subtask(Task(\"Write a title.\"))\ntask_tree.subtasks[0].add_subtask(Task(\"Do some brainstorming.\"))\n\n# Add a sibling task\nnew_sibling_task = Task(\"Write a sentence.\")\ntask_tree.subtasks[0].add_subtask(new_sibling_task)", "new_sibling_task = Task(\"Write a sentence.\")\ntask_tree.subtasks[0].add_subtask(new_sibling_task)\n\n# Print the whole task tree\ntask_tree.print_tree()\n\n# Find the next task\nnext_task = task_tree.find_next_task()\nprint(f\"\\nNext task:\\n{next_task}\\n\")\n", "print(f\"\\nNext task:\\n{next_task}\\n\")\n\n# Edit the local task tree\n# Access the parent task directly using the 'parent' attribute\nparent_task = next_task.parent\nprint(f\"Parent task:\\n{parent_task}\\n\")\n\n# Now, edit the parent task (e.g., change its description)\nparent_task.description = \"Write an amazing title.\"\nprint(\"Task tree after editing the local task tree:\")", "parent_task.description = \"Write an amazing title.\"\nprint(\"Task tree after editing the local task tree:\")\ntask_tree.print_tree()\n\n# Print the local task tree\nprint(f\"\\nLocal task tree:\\n{next_task.get_local_task_tree()}\")\n\"\"\""]}
{"filename": "task_tree_agent/action_sets/knowledge_retrieval/__init__.py", "chunked_list": [""]}
{"filename": "task_tree_agent/action_sets/knowledge_retrieval/knowledge_retrieval_action_set.py", "chunked_list": ["import os\nimport sys\nfrom superpowered import get_knowledge_base # pip install superpowered-sdk\n\n# add task_tree_agent to the path. It's not installed as a package, so we need to add it to the path manually.\nsys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), \"..\", \"..\", \"..\", \"task_tree_agent\"))\n\nfrom agent.action_interface import Action, ActionSet\n\nclass SuperpoweredKnowledgeBase:\n    def __init__(self, kb_title):\n        self.kb_title = kb_title\n        self.retriever_top_k = 100\n        self.reranker_top_k = 5\n\n    def query(self, query):\n        # make an API call to the Superpowered knowledge base using the SDK\n        kb = get_knowledge_base(self.kb_title)\n        search_results = kb.query(query, retriever_top_k=self.retriever_top_k, reranker_top_k=self.reranker_top_k, extract_and_summarize=True)\n        return search_results[\"summary\"]", "\nclass SuperpoweredKnowledgeBase:\n    def __init__(self, kb_title):\n        self.kb_title = kb_title\n        self.retriever_top_k = 100\n        self.reranker_top_k = 5\n\n    def query(self, query):\n        # make an API call to the Superpowered knowledge base using the SDK\n        kb = get_knowledge_base(self.kb_title)\n        search_results = kb.query(query, retriever_top_k=self.retriever_top_k, reranker_top_k=self.reranker_top_k, extract_and_summarize=True)\n        return search_results[\"summary\"]", "\n\ndef superpowered_kb_search(action_set_object, query):\n    return action_set_object.query(query)\n\nsuperpowered_kb_search_action = Action(\n    name=\"superpowered_kb_search(query: str)\",\n    when_to_use=\"Use this when you want to search a knowledge base - this knowledge base currently contains the full text of the Investment Advisers Act of 1940.\",\n    arguments=\"Arguments:\\n - query (str): The query to search the knowledge base with.\",\n    action_function=superpowered_kb_search,", "    arguments=\"Arguments:\\n - query (str): The query to search the knowledge base with.\",\n    action_function=superpowered_kb_search,\n)\n\nknowledge_retrieval_actions_list = [\n    superpowered_kb_search_action,\n]\n\nknowledge_retrieval_action_set = ActionSet(action_list=knowledge_retrieval_actions_list, action_set_name=\"knowledge_retrieval_action_set\", action_set_object=None)", "knowledge_retrieval_action_set = ActionSet(action_list=knowledge_retrieval_actions_list, action_set_name=\"knowledge_retrieval_action_set\", action_set_object=None)"]}
{"filename": "task_tree_agent/action_sets/long_form_writing/writing_action_set.py", "chunked_list": ["\"\"\"\nThis module defines the interface between the task tree and the SDF\n\nThe action_set_object is the SDF Document.\n\"\"\"\n\nfrom agent.action_interface import Action, ActionSet\n\ndef edit_title(action_set_object, title):\n    action_set_object.edit_title(title)", "def edit_title(action_set_object, title):\n    action_set_object.edit_title(title)\n\ndef update_outline(action_set_object, outline):\n    action_set_object.update_outline(outline)\n\ndef add_character_description(action_set_object, name, description):\n    action_set_object.add_character_description(name, description)\n\ndef update_character_description(action_set_object, name, description):\n    action_set_object.update_character_description(name, description)", "\ndef update_character_description(action_set_object, name, description):\n    action_set_object.update_character_description(name, description)\n\ndef remove_character_description(action_set_object, name):\n    action_set_object.remove_character_description(name)\n\ndef add_location(action_set_object, name, description):\n    action_set_object.add_location(name, description)\n\ndef update_location(action_set_object, name, description):\n    action_set_object.update_location(name, description)", "\ndef update_location(action_set_object, name, description):\n    action_set_object.update_location(name, description)\n\ndef remove_location(action_set_object, name):\n    action_set_object.remove_location(name)\n\ndef add_theme(action_set_object, name, description):\n    action_set_object.add_theme(name, description)\n\ndef update_theme(action_set_object, name, description):\n    action_set_object.update_theme(name, description)", "\ndef update_theme(action_set_object, name, description):\n    action_set_object.update_theme(name, description)\n\ndef remove_theme(action_set_object, name):\n    action_set_object.remove_theme(name)\n\ndef add_section(action_set_object, index, title='', summary=''):\n    action_set_object.add_section(index, title, summary)\n\ndef move_section(action_set_object, index, direction):\n    action_set_object.move_section(index, direction)", "\ndef move_section(action_set_object, index, direction):\n    action_set_object.move_section(index, direction)\n\ndef merge_sections(action_set_object, index):\n    action_set_object.merge_sections(index)\n\ndef split_section(action_set_object, index, split_index, new_title):\n    action_set_object.split_section(index, split_index, new_title)\n\ndef edit_section(action_set_object, section_index, editing_instructions):\n    action_set_object.edit_section(section_index, editing_instructions)", "\ndef edit_section(action_set_object, section_index, editing_instructions):\n    action_set_object.edit_section(section_index, editing_instructions)\n\ndef read_and_analyze_section(action_set_object, section_index, analysis_instructions):\n    return action_set_object.read_and_analyze_section(section_index, analysis_instructions)\n\n\nwriting_actions_list = [\n    Action(", "writing_actions_list = [\n    Action(\n        name=\"edit_title(title)\",\n        when_to_use=\"Use this function to edit the title of the document.\",\n        arguments=\"Arguments:\\n  - title: The new title of the document.\",\n        action_function=edit_title\n    ),\n    Action(\n        name=\"update_outline(outline)\",\n        when_to_use=\"Use this function to update the outline of the document.\",", "        name=\"update_outline(outline)\",\n        when_to_use=\"Use this function to update the outline of the document.\",\n        arguments=\"Arguments:\\n  - outline: The updated outline text.\",\n        action_function=update_outline\n    ),\n    Action(\n        name=\"add_character_description(name, description)\",\n        when_to_use=\"Use this function to add a character description to the document.\",\n        arguments=\"Arguments:\\n  - name: The name of the character.\\n  - description: The character description.\",\n        action_function=add_character_description", "        arguments=\"Arguments:\\n  - name: The name of the character.\\n  - description: The character description.\",\n        action_function=add_character_description\n    ),\n    Action(\n        name=\"update_character_description(name, description)\",\n        when_to_use=\"Use this function to update a character description in the document.\",\n        arguments=\"Arguments:\\n  - name: The name of the character.\\n  - description: The updated character description.\",\n        action_function=update_character_description\n    ),\n    Action(", "    ),\n    Action(\n        name=\"remove_character_description(name)\",\n        when_to_use=\"Use this function to remove a character description from the document.\",\n        arguments=\"Arguments:\\n  - name: The name of the character to remove.\",\n        action_function=remove_character_description\n    ),\n    Action(\n        name=\"add_location(name, description)\",\n        when_to_use=\"Use this function to add a location description to the document.\",", "        name=\"add_location(name, description)\",\n        when_to_use=\"Use this function to add a location description to the document.\",\n        arguments=\"Arguments:\\n  - name: The name of the location.\\n  - description: The location description.\",\n        action_function=add_location\n    ),\n    Action(\n        name=\"update_location(name, description)\",\n        when_to_use=\"Use this function to update a location description in the document.\",\n        arguments=\"Arguments:\\n  - name: The name of the location.\\n  - description: The updated location description.\",\n        action_function=update_location", "        arguments=\"Arguments:\\n  - name: The name of the location.\\n  - description: The updated location description.\",\n        action_function=update_location\n    ),\n    Action(\n        name=\"remove_location(name)\",\n        when_to_use=\"Use this function to remove a location description from the document.\",\n        arguments=\"Arguments:\\n  - name: The name of the location to remove.\",\n        action_function=remove_location\n    ),\n    Action(", "    ),\n    Action(\n        name=\"add_theme(name, description)\",\n        when_to_use=\"Use this function to add a theme description to the document.\",\n        arguments=\"Arguments:\\n  - name: The name of the theme.\\n  - description: The theme description.\",\n        action_function=add_theme\n    ),\n    Action(\n        name=\"update_theme(name, description)\",\n        when_to_use=\"Use this function to update a theme description in the document.\",", "        name=\"update_theme(name, description)\",\n        when_to_use=\"Use this function to update a theme description in the document.\",\n        arguments=\"Arguments:\\n  - name: The name of the theme.\\n  - description: The updated theme description.\",\n        action_function=update_theme\n    ),\n    Action(\n        name=\"remove_theme(name)\",\n        when_to_use=\"Use this function to remove a theme description from the document.\",\n        arguments=\"Arguments:\\n  - name: The name of the theme to remove.\",\n        action_function=remove_theme", "        arguments=\"Arguments:\\n  - name: The name of the theme to remove.\",\n        action_function=remove_theme\n    ),\n    Action(\n        name=\"add_section(index, title='', summary='')\",\n        when_to_use=\"Use this function to add a new section to the document.\",\n        arguments=\"Arguments:\\n  - index: The index at which to insert the new section. Note: sections are zero-indexed, so the first section will be index 0, etc.\\n  - title: The title of the new section (optional).\\n  - summary: The summary of the new section (optional).\",\n        action_function=add_section\n    ),\n    Action(", "    ),\n    Action(\n        name=\"move_section(index, direction)\",\n        when_to_use=\"Use this function to move a section in the document.\",\n        arguments=\"Arguments:\\n  - index: The index of the section to move.\\n  - direction: The direction to move the section (1 for down, -1 for up).\",\n        action_function=move_section\n    ),\n    Action(\n        name=\"merge_sections(index)\",\n        when_to_use=\"Use this function to merge two sections in the document.\",", "        name=\"merge_sections(index)\",\n        when_to_use=\"Use this function to merge two sections in the document.\",\n        arguments=\"Arguments:\\n  - index: The index of the first section to merge.\",\n        action_function=merge_sections\n    ),\n    Action(\n        name=\"split_section(index, split_index, new_title)\",\n        when_to_use=\"Use this function to split a section in the document.\",\n        arguments=\"Arguments:\\n  - index: The index of the section to split.\\n  - split_index: The index of the element to split on.\\n  - new_title: The title of the new section, which will be inserted after the current section.\",\n        action_function=split_section", "        arguments=\"Arguments:\\n  - index: The index of the section to split.\\n  - split_index: The index of the element to split on.\\n  - new_title: The title of the new section, which will be inserted after the current section.\",\n        action_function=split_section\n    ),\n    Action(\n        name=\"edit_section(section_index, editing_instructions)\",\n        when_to_use=\"Use this function to add to or edit the text for a specific section of the document. This function calls another LLM that's been fine-tuned for writing, and that has access to the full text of the section. When you call edit_section, you just need to provide editing instructions, so that this special-purpose LLM knows what to do. Note: you must create a section (by using the add_section function) before you can edit it.\",\n        arguments=\"Arguments:\\n  - section_index: The index of the section to edit. Note: sections are zero-indexed, so the first section will be index 0, etc.\\n  - editing_instructions: Natural language instructions describing the additions or edits to be made.\",\n        action_function=edit_section\n    ),\n    Action(", "    ),\n    Action(\n        name=\"read_and_analyze_section(section_index, analysis_instructions)\",\n        when_to_use=\"Use this function to read and analyze a specific section of the document. This function calls another LLM that's been fine-tuned for reading, and that has access to the full text of the section. When you call read_and_analyze_section, you just need to provide analysis instructions, so that this special-purpose LLM knows what to do. Keep in mind that this function can only analyze one section at a time. If you want to analyze multiple sections, you'll need to call this function multiple times. This is the only method you have to read what you write, so be sure to use it frequently!\",\n        arguments=\"Arguments:\\n  - section_index: The index of the section to read and analyze. Note: sections are zero-indexed, so the first section will be index 0, etc.\\n  - analysis_instructions: Natural language instructions describing the analysis to be performed. Be clear about what exactly you want to analyze.\",\n        action_function=read_and_analyze_section\n    ),\n]\n\nwriting_action_set = ActionSet(action_list=writing_actions_list, action_set_name=\"writing_action_set\", action_set_object=None)", "\nwriting_action_set = ActionSet(action_list=writing_actions_list, action_set_name=\"writing_action_set\", action_set_object=None)"]}
{"filename": "task_tree_agent/action_sets/long_form_writing/SDF.py", "chunked_list": ["\"\"\"\nThe following module contains the classes for the SDF document format, which is used to represent a long-form document in a way that is easy for LLMs to understand and manipulate.\n\nThis is an example of creating an action set that itself uses an agent w/ tools framework, which is why we import the ActionInterface class.\n\"\"\"\n\nimport os\nimport sys\n\n# add task_tree_agent to the path. It's not installed as a package, so we need to add it to the path manually. It's in ../../task_tree_agent", "\n# add task_tree_agent to the path. It's not installed as a package, so we need to add it to the path manually. It's in ../../task_tree_agent\nsys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), \"..\", \"..\", \"..\", \"task_tree_agent\"))\n\nfrom agent.utils import openai_api_call\nfrom agent.action_interface import ActionInterface, RESPONSE_FORMATTING_INSTRUCTIONS\nfrom action_sets.long_form_writing.edit_section_action_set import edit_section_action_set\nfrom action_sets.long_form_writing.SDF_prompt_template import EDIT_SECTION, READ_AND_ANALYZE\n\nclass Element:\n    def __init__(self, content):\n        self.content = content", "\nclass Element:\n    def __init__(self, content):\n        self.content = content\n\n\nclass Section:\n    def __init__(self, section_identifier='', title='', summary=''):\n        self.section_identifier = section_identifier # e.g., \"Chapter 1\"\n        self.title = title\n        self.summary = summary\n        self.outline = \"\"\n        self.elements = []\n\n    # add new element to the section\n    def add_element(self, index, content):\n        element = Element(content)\n        self.elements.insert(index, element)\n\n    # edit an existing element\n    def edit_element(self, index, content):\n        self.elements[index].content = content\n\n    # delete an element\n    def delete_element(self, index):\n        del self.elements[index]\n\n    # re-order elements, given a list of indices\n    def reorder_elements(self, indices):\n        self.elements = [self.elements[i] for i in indices]\n\n    # get the word count of the section\n    def get_word_count(self):\n        count = 0\n        for element in self.elements:\n            count += len(element.content.split())\n        return count\n\n    # display the section\n    def display(self):\n        print(f\"\\n# {self.title}\")\n        for i,element in enumerate(self.elements):\n            print(f\"\\nElement {i}\\n{element.content}\")", "\n\nclass Document:\n    def __init__(self, title, human_notes=\"\", section_type='Section', model_name=\"gpt-4\"):\n        self.title = title\n        self.human_notes = human_notes\n        self.section_type = section_type\n        self.sections = []\n        self.table_of_contents = []\n        self.outline = \"\"\n        self.character_descriptions = {}\n        self.locations = {}\n        self.themes = {}\n        self.action_interface = ActionInterface([edit_section_action_set])\n        self.model_name = model_name # e.g., \"gpt-4\", the model used to generate text in edit_section()\n\n    def edit_title(self, title):\n        self.title = title\n\n    def update_outline(self, outline):\n        self.outline = outline\n\n    # Character descriptions methods\n    def add_character_description(self, name, description):\n        self.character_descriptions[name] = description\n\n    def update_character_description(self, name, description):\n        if name in self.character_descriptions:\n            self.character_descriptions[name] = description\n\n    def remove_character_description(self, name):\n        if name in self.character_descriptions:\n            del self.character_descriptions[name]\n\n    # Locations methods\n    def add_location(self, name, description):\n        self.locations[name] = description\n\n    def update_location(self, name, description):\n        if name in self.locations:\n            self.locations[name] = description\n\n    def remove_location(self, name):\n        if name in self.locations:\n            del self.locations[name]\n\n    # Themes methods\n    def add_theme(self, name, description):\n        self.themes[name] = description\n\n    def update_theme(self, name, description):\n        if name in self.themes:\n            self.themes[name] = description\n\n    def remove_theme(self, name):\n        if name in self.themes:\n            del self.themes[name]\n\n    # Sections methods\n    def add_section(self, index, title='', summary=''):\n        # validate index\n        if index < 0 or index > len(self.sections):\n            return None\n        \n        # create new section\n        section_identifier = f\"{self.section_type} {index + 1}\"\n        section = Section(section_identifier, title, summary)\n        self.sections.insert(index, section)\n        \n        # update section identifiers\n        for i in range(len(self.sections)):\n            self.sections[i].section_identifier = f\"{self.section_type} {i + 1}\"\n\n        self.update_toc() # update table of contents\n\n    # find the index of a section by section identifier\n    def find_section_index(self, section_identifier):\n        section_identifier = section_identifier.strip()\n        for i in range(len(self.sections)):\n            if self.sections[i].section_identifier == section_identifier:\n                return i\n        return None\n\n    def move_section(self, index, direction):\n        if 0 <= index < len(self.sections) and 0 <= index + direction < len(self.sections):\n            self.sections[index], self.sections[index + direction] = self.sections[index + direction], self.sections[index]\n            \n            # update section identifiers\n            for i in range(len(self.sections)):\n                self.sections[i].section_identifier = f\"{self.section_type} {i + 1}\"\n\n            self.update_toc() # update table of contents\n\n    def merge_sections(self, index):\n        if 0 <= index < len(self.sections) - 1:\n            self.sections[index].title += f\" - {self.sections[index + 1].title}\"\n            self.sections[index].elements += self.sections[index + 1].elements\n            self.sections[index].subsections += self.sections[index + 1].subsections\n            del self.sections[index + 1]\n            \n            # update section identifiers\n            for i in range(len(self.sections)):\n                self.sections[i].section_identifier = f\"{self.section_type} {i + 1}\"\n            \n            self.update_toc() # update table of contents\n\n    def split_section(self, index, split_index, new_title):\n        \"\"\"\n        - split_index is the index of the element to split on\n        - new_title is the title of the new section, which will be inserted after the current section\n        \"\"\"\n        if 0 <= index < len(self.sections):\n            new_section = Section(new_title)\n            new_section.elements = self.sections[index].elements[split_index:]\n            self.sections[index].elements = self.sections[index].elements[:split_index]\n            self.sections.insert(index + 1, new_section)\n\n            # update section identifiers\n            for i in range(len(self.sections)):\n                self.sections[i].section_identifier = f\"{self.section_type} {i + 1}\"\n            \n            self.update_toc() # update table of contents\n\n    def get_word_count(self):\n        count = 0\n        for section in self.sections:\n            count += section.get_word_count()\n        return count\n\n    def update_toc(self):\n        self.table_of_contents = [section.title for section in self.sections]\n\n    # create a context string to be used in the prompt\n    def format_prompt_context(self):\n\n        # Generate the prompt, starting with the human notes\n        context_str = f\"The following are some human-written notes about the document you're writing. You should pay careful attention to these notes and stick closely to any ideas conveyed in them.\\n\\nHuman Notes:\\n{self.human_notes}\\n\\n\"\n\n        context_str += \"Document Overview:\\n\"\n\n        # add title\n        context_str += f\"Title: {self.title}\\n\\n\"\n\n        # add outline\n        context_str += \"Outline:\\n\"\n        context_str += self.outline + \"\\n\"\n\n        # add word count\n        context_str += f\"\\nWord Count: {self.get_word_count()}\\n\"\n\n        context_str += \"\\nSection Summaries:\\n\"\n        for section in self.sections:\n            context_str += f\"{section.section_identifier} - {section.title}:\\n{section.summary}\\n\\n\"\n\n        context_str += \"\\nCharacter Descriptions:\\n\"\n        for name, description in self.character_descriptions.items():\n            context_str += f\"{name}: {description}\\n\"\n\n        context_str += \"\\nLocations:\\n\"\n        for name, description in self.locations.items():\n            context_str += f\"{name}: {description}\\n\"\n\n        context_str += \"\\nThemes:\\n\"\n        for name, description in self.themes.items():\n            context_str += f\"{name}: {description}\\n\"\n\n        return context_str\n\n    def format_section_for_prompt(self, section_index):\n        if section_index != None:\n            current_section = self.sections[section_index]\n        else:\n            current_section = None\n\n        if current_section is None:\n            return None\n\n        # put all the information needed about the current section into a string\n        context_str = f\"\\nCurrent Section: {current_section.section_identifier} - {current_section.title}\\n\\n\"\n        context_str += f\"Section Summary:\\n{current_section.summary}\\n\\n\"\n        context_str += f\"Section Outline:\\n{current_section.outline}\\n\\n\"\n        context_str += f\"Section Word Count: {current_section.get_word_count()}\\n\\n\"\n        context_str += \"Section Full Text:\\n\"\n        for i,element in enumerate(current_section.elements):\n            context_str += f\"Element: {i}\\n{element.content}\\n\\n\"\n        \n        return context_str\n\n    def create_edit_section_prompt(self, section_index, editing_instructions):\n        document_context = self.format_prompt_context() # Create the document context string\n        if document_context is None:\n            return None\n        current_section_context = self.format_section_for_prompt(section_index) # Create the current section context string\n\n        available_actions = self.action_interface.get_available_actions_for_prompt()\n\n        return EDIT_SECTION.format(\n            document_context=document_context,\n            editing_instructions=editing_instructions,\n            current_section_context=current_section_context,\n            available_actions=available_actions,\n            response_formatting_instructions=RESPONSE_FORMATTING_INSTRUCTIONS,\n        )\n    \n    def edit_section(self, section_index: str, editing_instructions: str, verbose: bool = False):\n        \"\"\"\n        This is the main function we will use to edit the document.\n\n        The editing instructions is a natural language string that describes the edit we want the LLM to make.\n        \"\"\"\n        prompt = self.create_edit_section_prompt(section_index, editing_instructions)\n        self.action_interface.update_action_set_object(\"edit_section_action_set\", self.sections[section_index])\n        response = openai_api_call(prompt, model_name=self.model_name, max_tokens=2000)\n\n        if verbose:\n            print(f\"Full prompt:\\n{prompt}\")\n            print(f\"Raw LLM response:\\n{response}\")\n\n        self.action_interface.parse_response_and_perform_actions(response)\n\n    def create_read_and_analyze_prompt(self, section_index, analysis_instructions):\n        document_context = self.format_prompt_context()\n        if document_context is None:\n            return None\n        current_section_context = self.format_section_for_prompt(section_index)\n        \n        return READ_AND_ANALYZE.format(\n            document_context=document_context,\n            analysis_instructions=analysis_instructions,\n            current_section_context=current_section_context,\n        )\n\n    def read_and_analyze_section(self, section_index: str, analysis_instructions: str, verbose: bool = False):\n        prompt = self.create_read_and_analyze_prompt(section_index, analysis_instructions)\n        analysis = openai_api_call(prompt, model_name=self.model_name, max_tokens=500)\n\n        if verbose:\n            print(f\"Full prompt:\\n{prompt}\")\n            print(f\"Raw LLM response:\\n{analysis}\")\n        \n        return analysis.strip()\n\n    def display(self):\n        print(f\"Title: {self.title}\")\n        print(\"\\nTable of Contents:\")\n        for section in self.sections:\n            print(f\"{section.section_identifier} - {section.title}\") \n\n        print(\"\\nSections:\")\n        for section in self.sections:\n            section.display()"]}
{"filename": "task_tree_agent/action_sets/long_form_writing/edit_section_action_set.py", "chunked_list": ["\"\"\"\naction_set_object is the Section object this is being edited.\n\"\"\"\nimport os\nimport sys\n\n# add task_tree_agent to the path. It's not installed as a package, so we need to add it to the path manually.\nsys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), \"..\", \"..\", \"..\", \"task_tree_agent\"))\n\nfrom agent.action_interface import Action, ActionSet", "\nfrom agent.action_interface import Action, ActionSet\n\n# Action functions for the edit_section function\ndef add_element(action_set_object, element_index: int, content: str):\n    # validate arguments\n    if element_index < 0 or element_index > len(action_set_object.elements):\n        raise ValueError(\"The element index is invalid.\")\n    if not isinstance(content, str):\n        raise TypeError(\"The content must be a string.\")\n    if not content:\n        raise ValueError(\"The content cannot be empty.\")\n    if not isinstance(element_index, int):\n        raise TypeError(\"The element index must be an integer.\")\n    action_set_object.add_element(element_index, content)", "\ndef edit_element(action_set_object, element_index: int, content: str):\n    action_set_object.edit_element(element_index, content)\n\ndef delete_element(action_set_object, element_index: int):\n    action_set_object.delete_element(element_index)\n\ndef update_section_title(action_set_object, new_title: str):\n    action_set_object.title = new_title\n\ndef update_section_summary(action_set_object, new_section_summary: str):\n    action_set_object.section_summary = new_section_summary", "\ndef update_section_summary(action_set_object, new_section_summary: str):\n    action_set_object.section_summary = new_section_summary\n\ndef update_section_outline(action_set_object, new_section_outline: str):\n    action_set_object.section_outline = new_section_outline\n\n\nsdf_action_list = [\n    Action(", "sdf_action_list = [\n    Action(\n        name=\"add_element(element_index, content)\",\n        when_to_use=\"Use this when you want to add an element to a action_set_object\",\n        arguments=\"Arguments:\\n  - element_index (int): This is the index to specify the location in the action_set_object that you would like this element to be placed in. For example, to add an element to the beginning of the action_set_object, use 0 for the element_index.\\n  - content (str): This is the content of the element you would like to add. Elements should generally be 3-5 paragraphs long. You can use double new line characters to separate paragraphs within an element.\",\n        action_function=add_element,\n    ),\n    Action(\n        name=\"edit_element(element_index, content)\",\n        when_to_use=\"Use this when you would like to edit an element in a action_set_object.\",", "        name=\"edit_element(element_index, content)\",\n        when_to_use=\"Use this when you would like to edit an element in a action_set_object.\",\n        arguments=\"Arguments:\\n - element_index (int): This is the index of the element that you would like to edit.\\n - content (str): This is the content that you would like to use for the element. This will replace the existing content.\",\n        action_function=edit_element,\n    ),\n    Action(\n        name=\"delete_element(element_index)\",\n        when_to_use=\"Use this function to delete an element from the action_set_object.\",\n        arguments=\"Arguments:\\n  - element_index (int): This is the index of the element that you would like to delete.\",\n        action_function=delete_element,", "        arguments=\"Arguments:\\n  - element_index (int): This is the index of the element that you would like to delete.\",\n        action_function=delete_element,\n    ),\n    Action(\n        name=\"update_section_title(new_title)\",\n        when_to_use=\"Use this when you would like to update the title of the action_set_object.\",\n        arguments=\"Arguments:\\n - new_title (str): This is the new title you would like to use for the action_set_object.\",\n        action_function=update_section_title,\n    ),\n    Action(", "    ),\n    Action(\n        name=\"update_section_summary(new_section_summary)\",\n        when_to_use=\"Use this when you would like to update the summary of the action_set_object. Whenever the action_set_object content has been substantially changed, you should update the summary to reflect the new content.\",\n        arguments=\"Arguments:\\n - new_section_summary (str): This is the new summary you would like to use for the action_set_object. The summary should be pretty short.\",\n        action_function=update_section_summary,\n    ),\n    Action(\n        name=\"update_section_outline(new_section_outline)\",\n        when_to_use=\"Use this when you would like to update the outline of the action_set_object. You should ALWAYS create a detailed action_set_object outline before starting to write a action_set_object. Whenever the action_set_object content has been substantially changed, you should update the outline to reflect the new content.\",", "        name=\"update_section_outline(new_section_outline)\",\n        when_to_use=\"Use this when you would like to update the outline of the action_set_object. You should ALWAYS create a detailed action_set_object outline before starting to write a action_set_object. Whenever the action_set_object content has been substantially changed, you should update the outline to reflect the new content.\",\n        arguments=\"Arguments:\\n - new_section_outline (str): This is the new outline you would like to use for the action_set_object. A good outline is very detailed and includes information about all the major things that are going to happen in the action_set_object, as well as additional information like character development, plot points, themes, etc.\",\n        action_function=update_section_outline,\n    )\n]\n\nedit_section_action_set = ActionSet(action_list=sdf_action_list, action_set_name=\"edit_section_action_set\", action_set_object=None)"]}
{"filename": "task_tree_agent/action_sets/long_form_writing/SDF_prompt_template.py", "chunked_list": ["# create the prompt template for the primary LLM call\nEDIT_SECTION = \"\"\"\nOBJECTIVE\nYou are in the process of writing a piece of long-form content, such as a blog post, white paper, book, etc. This content is broken up into sections, and each section is broken up into elements. A section should be roughly the length of a standard chapter, or a bit shorter if you're writing shorter form content like a blog post. You can only make edits to the current section, which will be specified later, but you should use the context provided about the larger document to inform your decisions. All of the text in a section is organized into elements. You can only edit the text of a section by adding, deleting, or editing elements. Elements should be roughly 3-5 paragraphs in length, and you can have as many elements in a single section as you need.\n\n{document_context}\n\nCURRENT_SECTION\nHere is the content of the current section of the document that you are working on. This section is broken up into elements of roughly 3-5 paragraphs each. The elements are labeled with the element index, and the element index is used to refer to the element when you want to perform actions on it. Each section should be roughly 5-20 elements long. Here is the current section:\n", "Here is the content of the current section of the document that you are working on. This section is broken up into elements of roughly 3-5 paragraphs each. The elements are labeled with the element index, and the element index is used to refer to the element when you want to perform actions on it. Each section should be roughly 5-20 elements long. Here is the current section:\n\n{current_section_context}\n\nEDITING INSTRUCTIONS\nHere are the instructions you've been given for editing this section:\n{editing_instructions}\n\nIn addition to these instructions, you should also think about how you can make this section higher quality and more cohesive, and make improvements accordingly.\n", "In addition to these instructions, you should also think about how you can make this section higher quality and more cohesive, and make improvements accordingly.\n\n\nAVAILABLE ACTIONS\nHere are the actions you have at your disposal. These are the ONLY options you have for interacting with the world. Any text you output that does not properly request one or more of these actions will be ignored. These actions are formatted as Python functions.\n\n{available_actions}\n\nRESPONSE FORMATTING INSTRUCTIONS\n{response_formatting_instructions}", "RESPONSE FORMATTING INSTRUCTIONS\n{response_formatting_instructions}\n\n\"\"\".strip()\n\n\nREAD_AND_ANALYZE = \"\"\"\nOBJECTIVE\nYour objective is to read and analyze a specific section of a document. You will be given context about the document, as well as the full text of the current section. You will also be given instructions about what you should be looking for in the section.\n", "Your objective is to read and analyze a specific section of a document. You will be given context about the document, as well as the full text of the current section. You will also be given instructions about what you should be looking for in the section.\n\nDOCUMENT CONTEXT\n{document_context}\n\nANALYSIS INSTRUCTIONS\n{analysis_instructions}\n\nCURRENT SECTION\n{current_section_context}", "CURRENT SECTION\n{current_section_context}\n\nINSTRUCTIONS\nPlease respond with your critical analysis of the section. You should answer all questions posed in the analysis instructions. You should also provide additional helpful comments about how the section could be made better. It is your job to be critical. Be very specific in your response. Your response should be roughly 1-3 paragraphs in length.\n\n\"\"\".strip()"]}
{"filename": "task_tree_agent/action_sets/long_form_writing/__init__.py", "chunked_list": [""]}
{"filename": "task_tree_agent/action_sets/long_form_writing/export_document.py", "chunked_list": ["from docx import Document as DocxDocument # pip install python-docx\n\ndef format_txt(document):\n    formatted = f\"Title: {document.title}\\n\\nTable of Contents:\\n\"\n    for index, title in enumerate(document.table_of_contents):\n        formatted += f\"{index + 1}. {title}\\n\"\n    formatted += \"\\n\"\n\n    for section in document.sections:\n        formatted += format_section_txt(section)\n\n    return formatted", "\ndef format_section_txt(section, level=1):\n    formatted = f\"{'#' * level} {section.title}\\n\\n\"\n    for element in section.elements:\n        formatted += f\"{element.content}\\n\\n\"\n\n    return formatted\n\ndef format_markdown(document):\n    formatted = f\"# {document.title}\\n\\n## Table of Contents\\n\"\n    for index, title in enumerate(document.table_of_contents):\n        formatted += f\"{index + 1}. [{title}](#{title.lower().replace(' ', '-')})\\n\"\n    formatted += \"\\n\"\n\n    for section in document.sections:\n        formatted += format_section_markdown(section)\n\n    return formatted", "def format_markdown(document):\n    formatted = f\"# {document.title}\\n\\n## Table of Contents\\n\"\n    for index, title in enumerate(document.table_of_contents):\n        formatted += f\"{index + 1}. [{title}](#{title.lower().replace(' ', '-')})\\n\"\n    formatted += \"\\n\"\n\n    for section in document.sections:\n        formatted += format_section_markdown(section)\n\n    return formatted", "\ndef format_section_markdown(section, level=1):\n    formatted = f\"{'#' * (level + 1)} {section.title}\\n\\n\"\n    for element in section.elements:\n        formatted += f\"{element.content}\\n\\n\"\n\n    return formatted\n\ndef format_docx(document, output_file):\n    docx = DocxDocument()\n\n    # Add title and author\n    docx.add_heading(document.title, level=1)\n    docx.add_paragraph(f\"Author: {document.author}\")\n\n    # Add table of contents\n    docx.add_heading(\"Table of Contents\", level=2)\n    for index, title in enumerate(document.table_of_contents):\n        docx.add_paragraph(f\"{index + 1}. {title}\")\n\n    # Add sections\n    for section in document.sections:\n        format_section_docx(docx, section)\n\n    # Save the docx file\n    docx.save(output_file)", "def format_docx(document, output_file):\n    docx = DocxDocument()\n\n    # Add title and author\n    docx.add_heading(document.title, level=1)\n    docx.add_paragraph(f\"Author: {document.author}\")\n\n    # Add table of contents\n    docx.add_heading(\"Table of Contents\", level=2)\n    for index, title in enumerate(document.table_of_contents):\n        docx.add_paragraph(f\"{index + 1}. {title}\")\n\n    # Add sections\n    for section in document.sections:\n        format_section_docx(docx, section)\n\n    # Save the docx file\n    docx.save(output_file)", "\ndef format_section_docx(docx, section, level=2):\n    docx.add_heading(section.title, level=level)\n    for element in section.elements:\n        if element.element_type == 'text':\n            docx.add_paragraph(element.content)\n        elif element.element_type == 'image':\n            docx.add_paragraph(f\"[Image: {element.content}]\")\n        elif element.element_type == 'table':\n            docx.add_paragraph(f\"[Table: {element.content}]\")\n        elif element.element_type == 'list':\n            docx.add_paragraph(f\"[List: {element.content}]\")\n        elif element.element_type == 'code':\n            docx.add_paragraph(f\"[Code: {element.content}]\")\n        else:\n            docx.add_paragraph(f\"[Unknown element type: {element.element_type}]\")\n\n    for subsection in section.subsections:\n        format_section_docx(docx, subsection, level=level + 1)", "\n\nimport pickle\nimport sys\nimport os\n\nsys.path.append(os.path.join(os.path.dirname(__file__), \"../elegant_infinite_agent\"))\n\nfrom elegant_infinite_agent import Agent\n\nwith open(\"technology_and_society.pkl\", \"rb\") as f:\n    agent = pickle.load(f)", "from elegant_infinite_agent import Agent\n\nwith open(\"technology_and_society.pkl\", \"rb\") as f:\n    agent = pickle.load(f)\n\ndocument = agent.sdf_document\nmd_document = format_markdown(document)\n\n# save the markdown file\nwith open(\"technology_and_society.md\", \"w\") as f:\n    f.write(md_document)", "# save the markdown file\nwith open(\"technology_and_society.md\", \"w\") as f:\n    f.write(md_document)"]}
