{"filename": "tests/test_version.py", "chunked_list": ["\"\"\" Test package version is correctly set \"\"\"\nimport unittest\n\ntry:\n    from src.BDPotentiometer import __version__ as version\nexcept ModuleNotFoundError:\n    from BDPotentiometer import __version__ as version\n\n\nclass TestVersion(unittest.TestCase):\n    \"\"\"\n    Test _version.py has correct version number assigned to global __version__ variable.\n    \"\"\"\n\n    def test_check_version_numbering(self) -> None:\n        \"\"\"\n        Version must be string with three integers separated by dot.\n        Example: `0.1.4` or `2.0.0`.\n        All three digits must not negative and must not be equal to zero at the same time.\n        \"\"\"\n        # Assert version is a string.\n        self.assertTrue(isinstance(version, str))\n\n        # Assert no extra space present. Example: \" 0.1.1  \" is not correct, \"0.1.1\" is correct.\n        self.assertEqual(len(version), len(version.strip()))\n\n        # Assert all three parts are present\n        v_l = version.split(\".\")\n        self.assertEqual(len(v_l), 3)\n\n        # Assert no extra space present in each part.\n        # Example: \"0. 1 .1\" is not correct, \"0.1.1\" is correct\n        for i in range(3):\n            self.assertEqual(len(v_l[i]), len(v_l[i].strip()))\n\n        # Convert all parts of the version to int values\n        v_maj = int(v_l[0])\n        v_min = int(v_l[1])\n        v_patch = int(v_l[2])\n\n        # Assert all version numbers are not negative\n        self.assertTrue(v_maj >= 0)\n        self.assertTrue(v_min >= 0)\n        self.assertTrue(v_patch >= 0)\n\n        # Assert all version numbers are not equal to zero at the same time\n        self.assertTrue(v_maj + v_min + v_patch > 0)", "\nclass TestVersion(unittest.TestCase):\n    \"\"\"\n    Test _version.py has correct version number assigned to global __version__ variable.\n    \"\"\"\n\n    def test_check_version_numbering(self) -> None:\n        \"\"\"\n        Version must be string with three integers separated by dot.\n        Example: `0.1.4` or `2.0.0`.\n        All three digits must not negative and must not be equal to zero at the same time.\n        \"\"\"\n        # Assert version is a string.\n        self.assertTrue(isinstance(version, str))\n\n        # Assert no extra space present. Example: \" 0.1.1  \" is not correct, \"0.1.1\" is correct.\n        self.assertEqual(len(version), len(version.strip()))\n\n        # Assert all three parts are present\n        v_l = version.split(\".\")\n        self.assertEqual(len(v_l), 3)\n\n        # Assert no extra space present in each part.\n        # Example: \"0. 1 .1\" is not correct, \"0.1.1\" is correct\n        for i in range(3):\n            self.assertEqual(len(v_l[i]), len(v_l[i].strip()))\n\n        # Convert all parts of the version to int values\n        v_maj = int(v_l[0])\n        v_min = int(v_l[1])\n        v_patch = int(v_l[2])\n\n        # Assert all version numbers are not negative\n        self.assertTrue(v_maj >= 0)\n        self.assertTrue(v_min >= 0)\n        self.assertTrue(v_patch >= 0)\n\n        # Assert all version numbers are not equal to zero at the same time\n        self.assertTrue(v_maj + v_min + v_patch > 0)", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/potentiometer/test_potentiometer_parameters_lock.py", "chunked_list": ["\"\"\" Test access to Potentiometer locked/unlocked properties. \"\"\"\nimport unittest\n\ntry:\n    from src.BDPotentiometer import Potentiometer\nexcept ModuleNotFoundError:\n    from BDPotentiometer import Potentiometer\n\n\nclass TestPotentiometerLocked(unittest.TestCase):\n    \"\"\"\n    Testing Potentiometer properties `r_ab` and `r_w`.\n    \"\"\"\n\n    def setUp(self) -> None:\n        self.pot = None\n        self.pot_locked = None\n\n    def test_locked(self):\n        \"\"\"\n        Test locked potentiometer. Altering of `r_ab` and `r_w` properties should be ignored.\n        Changing of any other property is allowed.\n        \"\"\"\n        for rheostat in [True, False]:\n            self.pot_locked = Potentiometer(\n                r_ab=10e3, r_w=75, rheostat=rheostat, parameters_locked=True\n            )\n            # Assert the device is locked and that property is read-only.\n            self.assertTrue(self.pot_locked.parameters_locked)\n            with self.assertRaises(AttributeError):\n                self.pot_locked.parameters_locked = False\n            with self.assertRaises(AttributeError):\n                self.pot_locked.parameters_locked = True\n            # Try to change `r_ab`, check that the value was not changed.\n            initial_value = self.pot_locked.r_ab\n            new_value = 2 * initial_value\n            self.pot_locked.r_ab = new_value\n            self.assertEqual(self.pot_locked.r_ab, initial_value)\n            # Try to change `r_w`, check that the value was not changed.\n            initial_value = self.pot_locked.r_w\n            new_value = 2 * initial_value\n            self.pot_locked.r_w = new_value\n            self.assertEqual(self.pot_locked.r_w, initial_value)\n            # Check that `r_lim`, and `r_load`, and `voltage_in` are not locked.\n            initial_value = self.pot_locked.r_lim\n            new_value = 2 * initial_value\n            self.pot_locked.r_lim = new_value\n            self.assertEqual(self.pot_locked.r_lim, new_value)\n            initial_value = self.pot_locked.r_load\n            new_value = 2 * initial_value\n            self.pot_locked.r_load = new_value\n            self.assertEqual(self.pot_locked.r_load, new_value)\n            initial_value = self.pot_locked.voltage_in\n            new_value = 2 * initial_value\n            self.pot_locked.voltage_in = new_value\n            self.assertEqual(self.pot_locked.voltage_in, new_value)\n\n    def test_unlocked(self):\n        \"\"\"\n        Test unlocked potentiometer.\n        Changing of any property is allowed.\n        \"\"\"\n        for rheostat in [True, False]:\n            self.pot = Potentiometer(\n                r_ab=10e3, r_w=75, rheostat=rheostat, parameters_locked=False\n            )\n            # Assert the device is not locked and that property is read-only.\n            self.assertFalse(self.pot.parameters_locked)\n            with self.assertRaises(AttributeError):\n                self.pot.parameters_locked = True\n            with self.assertRaises(AttributeError):\n                self.pot.parameters_locked = False\n            # Try to change `r_ab`, check that the value was changed.\n            initial_value = self.pot.r_ab\n            new_value = 2 * initial_value\n            self.pot.r_ab = new_value\n            self.assertEqual(self.pot.r_ab, new_value)\n            # Try to change `r_w`, check that the value was changed.\n            initial_value = self.pot.r_w\n            new_value = 2 * initial_value\n            self.pot.r_w = new_value\n            self.assertEqual(self.pot.r_w, new_value)\n            # Check that `r_lim`, and `r_load`, and `voltage_in` are not locked.\n            initial_value = self.pot.r_lim\n            new_value = 2 * initial_value\n            self.pot.r_lim = new_value\n            self.assertEqual(self.pot.r_lim, new_value)\n            initial_value = self.pot.r_load\n            new_value = 2 * initial_value\n            self.pot.r_load = new_value\n            self.assertEqual(self.pot.r_load, new_value)\n            initial_value = self.pot.voltage_in\n            new_value = 2 * initial_value\n            self.pot.voltage_in = new_value\n            self.assertEqual(self.pot.voltage_in, new_value)", "\nclass TestPotentiometerLocked(unittest.TestCase):\n    \"\"\"\n    Testing Potentiometer properties `r_ab` and `r_w`.\n    \"\"\"\n\n    def setUp(self) -> None:\n        self.pot = None\n        self.pot_locked = None\n\n    def test_locked(self):\n        \"\"\"\n        Test locked potentiometer. Altering of `r_ab` and `r_w` properties should be ignored.\n        Changing of any other property is allowed.\n        \"\"\"\n        for rheostat in [True, False]:\n            self.pot_locked = Potentiometer(\n                r_ab=10e3, r_w=75, rheostat=rheostat, parameters_locked=True\n            )\n            # Assert the device is locked and that property is read-only.\n            self.assertTrue(self.pot_locked.parameters_locked)\n            with self.assertRaises(AttributeError):\n                self.pot_locked.parameters_locked = False\n            with self.assertRaises(AttributeError):\n                self.pot_locked.parameters_locked = True\n            # Try to change `r_ab`, check that the value was not changed.\n            initial_value = self.pot_locked.r_ab\n            new_value = 2 * initial_value\n            self.pot_locked.r_ab = new_value\n            self.assertEqual(self.pot_locked.r_ab, initial_value)\n            # Try to change `r_w`, check that the value was not changed.\n            initial_value = self.pot_locked.r_w\n            new_value = 2 * initial_value\n            self.pot_locked.r_w = new_value\n            self.assertEqual(self.pot_locked.r_w, initial_value)\n            # Check that `r_lim`, and `r_load`, and `voltage_in` are not locked.\n            initial_value = self.pot_locked.r_lim\n            new_value = 2 * initial_value\n            self.pot_locked.r_lim = new_value\n            self.assertEqual(self.pot_locked.r_lim, new_value)\n            initial_value = self.pot_locked.r_load\n            new_value = 2 * initial_value\n            self.pot_locked.r_load = new_value\n            self.assertEqual(self.pot_locked.r_load, new_value)\n            initial_value = self.pot_locked.voltage_in\n            new_value = 2 * initial_value\n            self.pot_locked.voltage_in = new_value\n            self.assertEqual(self.pot_locked.voltage_in, new_value)\n\n    def test_unlocked(self):\n        \"\"\"\n        Test unlocked potentiometer.\n        Changing of any property is allowed.\n        \"\"\"\n        for rheostat in [True, False]:\n            self.pot = Potentiometer(\n                r_ab=10e3, r_w=75, rheostat=rheostat, parameters_locked=False\n            )\n            # Assert the device is not locked and that property is read-only.\n            self.assertFalse(self.pot.parameters_locked)\n            with self.assertRaises(AttributeError):\n                self.pot.parameters_locked = True\n            with self.assertRaises(AttributeError):\n                self.pot.parameters_locked = False\n            # Try to change `r_ab`, check that the value was changed.\n            initial_value = self.pot.r_ab\n            new_value = 2 * initial_value\n            self.pot.r_ab = new_value\n            self.assertEqual(self.pot.r_ab, new_value)\n            # Try to change `r_w`, check that the value was changed.\n            initial_value = self.pot.r_w\n            new_value = 2 * initial_value\n            self.pot.r_w = new_value\n            self.assertEqual(self.pot.r_w, new_value)\n            # Check that `r_lim`, and `r_load`, and `voltage_in` are not locked.\n            initial_value = self.pot.r_lim\n            new_value = 2 * initial_value\n            self.pot.r_lim = new_value\n            self.assertEqual(self.pot.r_lim, new_value)\n            initial_value = self.pot.r_load\n            new_value = 2 * initial_value\n            self.pot.r_load = new_value\n            self.assertEqual(self.pot.r_load, new_value)\n            initial_value = self.pot.voltage_in\n            new_value = 2 * initial_value\n            self.pot.voltage_in = new_value\n            self.assertEqual(self.pot.voltage_in, new_value)", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/potentiometer/test_potentiometer_r_wa_r_wb.py", "chunked_list": ["\"\"\" Tests for Potentiometer `r_wa` and `r_wb` calculation. \"\"\"\n\nimport unittest\nimport numpy as np\n\ntry:\n    from src.BDPotentiometer import Potentiometer\nexcept ModuleNotFoundError:\n    from BDPotentiometer import Potentiometer\n", "\n\nclass TestPotentiometerRwaRwb(unittest.TestCase):\n    \"\"\"\n    Testing Potentiometer `r_wa` and `r_wb` calculation.\n    \"\"\"\n\n    def test_rwa_rwb(self):\n        \"\"\"\n        Testing correctness of r_wa and r_wb calculation for\n        locked/unlocked potentiometer and rheostat configurations.\n        \"\"\"\n        for rheostat in (False, True):\n            for locked in (False, True):\n                pot = Potentiometer(\n                    r_ab=10e3, r_w=75, rheostat=rheostat, parameters_locked=locked\n                )\n                for pos in np.linspace(0, 1.0, num=101, endpoint=True):\n                    r_wa = pot.r_wa(pos)\n                    r_wb = pot.r_wb(pos)\n                    np.testing.assert_allclose(r_wa, pot.r_w + (1 - pos) * pot.r_ab)\n                    np.testing.assert_allclose(pot.r_wa_to_position(r_wa), pos)\n                    np.testing.assert_allclose(r_wb, pot.r_w + pos * pot.r_ab)\n                    np.testing.assert_allclose(pot.r_wb_to_position(r_wb), pos)\n                    np.testing.assert_allclose(r_wa + r_wb, 2 * pot.r_w + pot.r_ab)\n                # Out of range wiper position should coerce to 0\n                pos = -0.1\n                np.testing.assert_allclose(pot.r_wa(pos), pot.r_w + pot.r_ab)\n                np.testing.assert_allclose(pot.r_wb(pos), pot.r_w)\n                # Out of range wiper position should coerce to 1\n                pos = 1.1\n                np.testing.assert_allclose(pot.r_wa(pos), pot.r_w)\n                np.testing.assert_allclose(pot.r_wb(pos), pot.r_w + pot.r_ab)\n                # Out of range resistance should coerce to pot.r_ab + pot.r_w\n                np.testing.assert_allclose(\n                    pot.r_wa_to_position(pot.r_ab + 2 * pot.r_w),\n                    pot.r_wa_to_position(pot.r_ab + pot.r_w),\n                )\n                np.testing.assert_allclose(\n                    pot.r_wb_to_position(pot.r_ab + 2 * pot.r_w),\n                    pot.r_wb_to_position(pot.r_ab + pot.r_w),\n                )\n                # Out of range resistance should coerce to pot.r_w\n                np.testing.assert_allclose(\n                    pot.r_wa_to_position(0), pot.r_wa_to_position(pot.r_w)\n                )\n                np.testing.assert_allclose(\n                    pot.r_wb_to_position(0), pot.r_wb_to_position(pot.r_w)\n                )\n                # Out of range (negative) resistance should coerce to pot.r_w\n                np.testing.assert_allclose(\n                    pot.r_wa_to_position(-1), pot.r_wa_to_position(pot.r_w)\n                )\n                np.testing.assert_allclose(\n                    pot.r_wb_to_position(-1), pot.r_wb_to_position(pot.r_w)\n                )", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/potentiometer/test_potentiometer_constructor.py", "chunked_list": ["\"\"\" Tests for Potentiometer constructor. \"\"\"\n\nimport unittest\nimport numpy as np\n\ntry:\n    from src.BDPotentiometer import Potentiometer\nexcept ModuleNotFoundError:\n    from BDPotentiometer import Potentiometer\n", "\n\nclass TestPotentiometerConstructor(unittest.TestCase):\n    \"\"\"\n    Testing Potentiometer constructor.\n    \"\"\"\n\n    def test_r_ab(self) -> None:\n        \"\"\"\n        Test r_ab parameter.\n        \"\"\"\n        for rheostat in [True, False]:\n            for locked in [True, False]:\n                # Normal values\n                for r_ab in [1, 1e3, 10e3, np.float64(1.1e3), np.float32(1.1e3)]:\n                    pot = Potentiometer(\n                        r_ab=r_ab, r_w=75, rheostat=rheostat, parameters_locked=locked\n                    )\n                    self.assertEqual(pot.r_ab, r_ab)\n                    # Test default values (zero) for r_lim, r_load, voltage_in are set.\n                    self.assertEqual(pot.r_lim, 0)\n                    self.assertEqual(pot.r_load, 0)\n                    self.assertEqual(pot.voltage_in, 0)\n                # Wrong values\n                for r_ab in [-1.0, 0, 0.0, -1e3, -10e3]:\n                    with self.assertRaises(ValueError):\n                        _ = Potentiometer(\n                            r_ab=r_ab,\n                            r_w=75,\n                            rheostat=rheostat,\n                            parameters_locked=locked,\n                        )\n                # Wrong type\n                for r_ab in [\"1.0e3\", \"10\", \"1\", [1e3], (1e3,), None]:\n                    with self.assertRaises(TypeError):\n                        _ = Potentiometer(\n                            r_ab=r_ab,\n                            r_w=75,\n                            rheostat=rheostat,\n                            parameters_locked=locked,\n                        )\n\n    def test_r_w(self) -> None:\n        \"\"\"\n        Test r_w parameter.\n        \"\"\"\n        for rheostat in [True, False]:\n            for locked in [True, False]:\n                # Normal values\n                for r_w in [\n                    0,\n                    0.0,\n                    1,\n                    100.134,\n                    1e3,\n                    10e3,\n                    np.float64(1.1e3),\n                    np.float32(1.1e3),\n                ]:\n                    pot = Potentiometer(\n                        r_ab=10e3, r_w=r_w, rheostat=rheostat, parameters_locked=locked\n                    )\n                    self.assertEqual(pot.r_w, r_w)\n                    # Test default values (zero) for r_lim, r_load, voltage_in are set.\n                    self.assertEqual(pot.r_lim, 0)\n                    self.assertEqual(pot.r_load, 0)\n                    self.assertEqual(pot.voltage_in, 0)\n                # Wrong values\n                for r_w in [-1.0, -1e3, -10e3]:\n                    with self.assertRaises(ValueError):\n                        _ = Potentiometer(\n                            r_ab=10e3,\n                            r_w=r_w,\n                            rheostat=rheostat,\n                            parameters_locked=locked,\n                        )\n                # Wrong type\n                for r_w in [\"1.0e3\", \"10\", \"1\", [1e3], (1e3,), None]:\n                    with self.assertRaises(TypeError):\n                        pot = Potentiometer(\n                            r_ab=10e3,\n                            r_w=r_w,\n                            rheostat=rheostat,\n                            parameters_locked=locked,\n                        )\n\n    def test_rheostat(self) -> None:\n        \"\"\"\n        Test rheostat parameter.\n        \"\"\"\n        # Normal values and strange ones. All will be converted to bool\n        for rheostat in [True, False, 1, 0, \"1.0e3\", \"10\", \"1\", [1e3], (1e3,), None]:\n            pot = Potentiometer(\n                r_ab=10e3, r_w=75, rheostat=rheostat, parameters_locked=False\n            )\n            self.assertEqual(pot.rheostat, bool(rheostat))\n            # Test default values (zero) for r_lim, r_load, voltage_in are set.\n            self.assertEqual(pot.r_lim, 0)\n            self.assertEqual(pot.r_load, 0)\n            self.assertEqual(pot.voltage_in, 0)\n\n    def test_locked(self) -> None:\n        \"\"\"\n        Test locked parameter.\n        \"\"\"\n        # Normal values and strange ones. All will be converted to bool\n        for rheostat in [True, False]:\n            for locked in [True, False, 1, 0, \"1.0e3\", \"10\", \"1\", [1e3], (1e3,), None]:\n                pot = Potentiometer(\n                    r_ab=10e3, r_w=75, rheostat=rheostat, parameters_locked=locked\n                )\n                self.assertEqual(pot.parameters_locked, bool(locked))\n                # Test default values (zero) for r_lim, r_load, voltage_in are set.\n                self.assertEqual(pot.r_lim, 0)\n                self.assertEqual(pot.r_load, 0)\n                self.assertEqual(pot.voltage_in, 0)", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/potentiometer/test_potentiometer_fixed_resistors.py", "chunked_list": ["\"\"\" Test Potentiometer resistors properties setters and getters. \"\"\"\n\nimport unittest\nimport numpy as np\n\ntry:\n    from src.BDPotentiometer import Potentiometer\nexcept ModuleNotFoundError:\n    from BDPotentiometer import Potentiometer\n", "\n\nclass TestPotentiometerFixedResistors(unittest.TestCase):\n    \"\"\"\n    Testing Potentiometer properties r_ab, r_w, r_lim, r_load.\n    \"\"\"\n\n    def setUp(self) -> None:\n        self.pot = None\n\n    def test_r_ab(self) -> None:\n        \"\"\"\n        Test r_ab property.\n        For unlocked potentiometer and rheostat result is the same.\n        \"\"\"\n        for rheostat in [True, False]:\n            self.pot = Potentiometer(\n                r_ab=10e3, r_w=75, rheostat=rheostat, parameters_locked=False\n            )\n            self.assertEqual(self.pot.r_ab, 10e3)\n            # Normal values\n            for r_ab in [1, 1e3, 10e3, np.float64(1.1e3), np.float32(1.1e3)]:\n                self.pot.r_ab = r_ab\n                self.assertEqual(self.pot.r_ab, r_ab)\n                self.assertIsInstance(self.pot.r_ab, float)\n            # Wrong values\n            for r_ab in [-1.0, 0, 0.0, -1e3, -10e3]:\n                with self.assertRaises(ValueError):\n                    self.pot.r_ab = r_ab\n            # Wrong type\n            for r_ab in [\"1.0e3\", \"10\", \"1\", [1e3], (1e3,), None]:\n                with self.assertRaises(TypeError):\n                    self.pot.r_ab = r_ab\n\n    def test_r_w(self) -> None:\n        \"\"\"\n        Test r_w property.\n        For unlocked potentiometer and rheostat result is the same.\n        \"\"\"\n        for rheostat in [True, False]:\n            self.pot = Potentiometer(\n                r_ab=10e3, r_w=75, rheostat=rheostat, parameters_locked=False\n            )\n            self.assertEqual(self.pot.r_w, 75)\n            # Normal values\n            for r_w in [0, 0.0, 1, 1e3, 10e3, np.float64(1.1e3), np.float32(1.1e3)]:\n                self.pot.r_w = r_w\n                self.assertEqual(self.pot.r_w, r_w)\n                self.assertIsInstance(self.pot.r_w, float)\n            # Wrong values\n            for r_w in [-1.0, -1e3, -10e3]:\n                with self.assertRaises(ValueError):\n                    self.pot.r_w = r_w\n            # Wrong type\n            for r_w in [\"1.0e3\", \"10\", \"1\", [1e3], (1e3,), None]:\n                with self.assertRaises(TypeError):\n                    self.pot.r_w = r_w\n\n    def test_r_lim(self) -> None:\n        \"\"\"\n        Test r_lim property.\n        For unlocked potentiometer and rheostat result is the same.\n        \"\"\"\n        for rheostat in [True, False]:\n            self.pot = Potentiometer(\n                r_ab=10e3, r_w=75, rheostat=rheostat, parameters_locked=False\n            )\n            self.assertEqual(self.pot.r_lim, 0)\n            # Normal values\n            for r_lim in [0, 0.0, 1, 1e3, 10e3, np.float64(1.1e3), np.float32(1.1e3)]:\n                self.pot.r_lim = r_lim\n                self.assertEqual(self.pot.r_lim, r_lim)\n                self.assertIsInstance(self.pot.r_lim, float)\n            # Wrong values\n            for r_lim in [-1.0, -1e3, -10e3]:\n                with self.assertRaises(ValueError):\n                    self.pot.r_lim = r_lim\n            # Wrong type\n            for r_lim in [\"1.0e3\", \"10\", \"1\", [1e3], (1e3,), None]:\n                with self.assertRaises(TypeError):\n                    self.pot.r_lim = r_lim\n\n    def test_r_load(self) -> None:\n        \"\"\"\n        Test r_load property.\n        For unlocked potentiometer and rheostat result is the same.\n        \"\"\"\n        for rheostat in [True, False]:\n            self.pot = Potentiometer(\n                r_ab=10e3, r_w=75, rheostat=rheostat, parameters_locked=False\n            )\n            self.assertEqual(self.pot.r_load, 0)\n            # Normal values\n            for r_load in [0, 0.0, 1, 1e3, 10e3, np.float64(1.1e3), np.float32(1.1e3)]:\n                self.pot.r_load = r_load\n                self.assertEqual(self.pot.r_load, r_load)\n                self.assertIsInstance(self.pot.r_load, float)\n            # Wrong values\n            for r_load in [-1.0, -1e3, -10e3]:\n                with self.assertRaises(ValueError):\n                    self.pot.r_load = r_load\n            # Wrong type\n            for r_load in [\"1.0e3\", \"10\", \"1\", [1e3], (1e3,), None]:\n                with self.assertRaises(TypeError):\n                    self.pot.r_load = r_load", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/potentiometer/test_potentiometer_voltage_in.py", "chunked_list": ["\"\"\" Tests for Potentiometer input voltage property. \"\"\"\n\nimport unittest\nimport numpy as np\n\ntry:\n    from src.BDPotentiometer import Potentiometer\nexcept ModuleNotFoundError:\n    from BDPotentiometer import Potentiometer\n", "\n\nclass TestPotentiometerVoltageIn(unittest.TestCase):\n    \"\"\"\n    Testing Potentiometer input voltage property.\n    \"\"\"\n\n    def setUp(self) -> None:\n        self.pot = None\n\n    def test_voltage_in(self):\n        \"\"\"\n        Input voltage testing.\n        For unlocked potentiometer and rheostat result is the same.\n        \"\"\"\n        for rheostat in [True, False]:\n            self.pot = Potentiometer(\n                r_ab=10e3, r_w=75, rheostat=rheostat, parameters_locked=False\n            )\n            self.assertEqual(self.pot.voltage_in, 0.0)  # Zero is default input voltage\n            for voltage in [\n                -5,\n                -4.5,\n                0,\n                0.0,\n                float(\"-0.0\"),\n                4.5,\n                5,\n                np.float32(4.2),\n                np.float64(5.2),\n            ]:\n                self.pot.voltage_in = voltage\n                self.assertEqual(self.pot.voltage_in, voltage)\n                self.assertIsInstance(self.pot.voltage_in, float)\n            for voltage in [\"5.1\", \"a\", None, [2.0], (1.1,)]:\n                with self.assertRaises(TypeError):\n                    self.pot.voltage_in = voltage\n            for voltage in [float(\"nan\"), float(\"-inf\"), float(\"inf\")]:\n                with self.assertRaises(ValueError):\n                    self.pot.voltage_in = voltage", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/potentiometer/test_potentiometer_voltage_out.py", "chunked_list": ["\"\"\" Tests for Potentiometer class. \"\"\"\n\nimport unittest\nimport numpy as np\n\ntry:\n    from src.BDPotentiometer import Potentiometer\nexcept ModuleNotFoundError:\n    from BDPotentiometer import Potentiometer\n", "\n\nclass TestPotentiometerVoltageOut(unittest.TestCase):\n    \"\"\"\n    Testing Potentiometer.\n    \"\"\"\n\n    def test_voltage_out(self):\n        \"\"\"\n        Testing correctness of output voltage calculation for both\n        potentiometer and rheostat configurations.\n        \"\"\"\n        for rheostat in (False, True):\n            pot = Potentiometer(\n                r_ab=10e3, r_w=75, rheostat=rheostat, parameters_locked=False\n            )\n            pot.r_lim = 0.0\n            pot.r_load = 1e6\n            # Zero input voltage should result in zero output voltage\n            pot.voltage_in = 0.0\n            for pos in np.linspace(0, 1.0, num=101, endpoint=True):\n                self.assertEqual(pot.voltage_out(pos), 0.0)\n            # Zero load resistance should result in zero output voltage\n            pot.r_load = 0\n            pot.voltage_in = 5.0\n            for pos in np.linspace(0, 1.0, num=101, endpoint=True):\n                self.assertEqual(pot.voltage_out(pos), 0.0)\n            # Testing range of input voltages\n            for voltage in np.linspace(-5, 5, num=101, endpoint=True):\n                pot.voltage_in = voltage\n                for pos in np.linspace(0, 1.0, num=101, endpoint=True):\n                    if voltage == 0:\n                        self.assertEqual(pot.voltage_out(pos), 0.0)\n                        continue\n                    pot.r_lim = 0.0\n                    pot.r_load = 1e100\n                    if rheostat:\n                        r_total = pot.r_load + pot.r_lim + pot.r_wb(pos)\n                        result = pot.voltage_in * pot.r_load / r_total\n                    else:\n                        result = pot.voltage_in * pos\n                    np.testing.assert_allclose(pot.voltage_out(pos), result)\n                    pot.r_lim = 200.0\n                    pot.r_load = 1e4\n                    np.testing.assert_allclose(\n                        pot.voltage_out_to_wiper_position(pot.voltage_out(pos)),\n                        pos,\n                        atol=1e-15,\n                        rtol=1e-6,\n                    )\n            pot.r_lim = 200.0\n            pot.r_load = 1e4\n            # At zero input voltage wiper position is always zero (min. current)\n            pot.voltage_in = 0.0\n            for pos in np.linspace(0, 1, num=101, endpoint=True):\n                self.assertEqual(\n                    pot.voltage_out_to_wiper_position(pot.voltage_out(pos)), 0\n                )\n            # Positive v_in can not result in negative v_out and vice-versa\n            pot.voltage_in = 5.0\n            for v_out in np.linspace(-5, -1e-5, num=101, endpoint=True):\n                self.assertEqual(pot.voltage_out_to_wiper_position(v_out), 0)\n            pot.voltage_in = -5.0\n            for v_out in np.linspace(1e-5, 5, num=101, endpoint=True):\n                self.assertEqual(pot.voltage_out_to_wiper_position(v_out), 0)\n\n    def test_voltage_out_wrong_type(self):\n        \"\"\"\n        Testing TypeError is raised on wrong type voltage out input for both\n        potentiometer and rheostat configurations.\n        \"\"\"\n        for rheostat in (False, True):\n            pot = Potentiometer(\n                r_ab=10e3, r_w=75, rheostat=rheostat, parameters_locked=False\n            )\n            pot.r_lim = 0.0\n            pot.r_load = 1e6\n            # Zero input voltage should result in zero output voltage\n            pot.voltage_in = 5.0\n            # Wrong type\n            for v_out in [None, \"100.2\"]:\n                with self.assertRaises(TypeError):\n                    pot.voltage_out_to_wiper_position(v_out)\n            # Wrong type\n            for pos in [None, \"0.2\"]:\n                with self.assertRaises(TypeError):\n                    pot.voltage_out(pos)", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/mcp4xxx/test_mcp4xxx.py", "chunked_list": ["\"\"\" Tests for DigitalPotentiometerDevice class. \"\"\"\n\nimport unittest\n\ntry:\n    from src.BDPotentiometer.mcp4xxx.mcp4xxx import (\n        resistance_list,\n        _coerce_max_value,\n        _coerce_r_ab,\n        _check_write_response,\n        _check_read_response,\n        # _check_status_response,\n        # _check_tcon_response,\n        # _parse_tcon_response,\n        # _tcon_to_cmd,\n    )\nexcept ModuleNotFoundError:\n    from BDPotentiometer.mcp4xxx.mcp4xxx import (\n        resistance_list,\n        _coerce_max_value,\n        _coerce_r_ab,\n        _check_write_response,\n        _check_read_response,\n        # _check_status_response,\n        # _check_tcon_response,\n        # _parse_tcon_response,\n        # _tcon_to_cmd,\n    )", "\n\nclass MCP4xxxTestCase(unittest.TestCase):\n    \"\"\"\n    MCP4XXX class testing.\n    \"\"\"\n\n    def test_resistance_list(self):\n        \"\"\"Test r_ab resistance list is correct.\"\"\"\n        self.assertEqual(resistance_list, (5e3, 10e3, 50e3, 100e3))\n\n    def test_coerce_max_value(self):\n        \"\"\"test correct coercion of max_value.\"\"\"\n        self.assertEqual(_coerce_max_value(128), 128)\n        self.assertEqual(_coerce_max_value(256), 256)\n        with self.assertRaises(ValueError):\n            _coerce_max_value(512)\n        with self.assertRaises(ValueError):\n            _coerce_max_value(\"a\")\n\n    def test_coerce_r_ab(self):\n        \"\"\"test correct coercion of r_ab.\"\"\"\n        for r_ab in resistance_list:\n            self.assertEqual(_coerce_r_ab(r_ab), r_ab)\n        with self.assertRaises(ValueError):\n            _coerce_r_ab(20e3)\n        with self.assertRaises(ValueError):\n            _coerce_r_ab(\"a\")\n\n    def test_write_response(self):\n        \"\"\"Test write response checker.\"\"\"\n        with self.assertRaises(ValueError):\n            _check_write_response(None)\n\n    def test_read_response(self):\n        \"\"\"Test read response checker.\"\"\"\n        with self.assertRaises(ValueError):\n            _check_read_response(None)", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/digital_potentiometer/test_digital_potentiometer.py", "chunked_list": ["\"\"\" Tests for DigitalPotentiometerDevice class. \"\"\"\n\n# pylint: disable=protected-access\n\nimport unittest\nimport numpy as np\n\ntry:\n    from src.BDPotentiometer import (\n        Potentiometer,\n        DigitalWiper,\n        DigitalPotentiometerDevice,\n    )\nexcept ModuleNotFoundError:\n    from BDPotentiometer import Potentiometer, DigitalWiper, DigitalPotentiometerDevice", "\n\nclass TestDigitalPotentiometer(unittest.TestCase):\n    \"\"\"\n    Testing DigitalPotentiometerDevice.\n    \"\"\"\n\n    def setUp(self) -> None:\n        self.pot = Potentiometer(\n            r_ab=10e3, r_w=75, rheostat=False, parameters_locked=False\n        )\n        digital_wiper = DigitalWiper(\n            potentiometer=self.pot, max_value=128, parameters_locked=False\n        )\n        self.digital_pot = DigitalPotentiometerDevice(wiper=digital_wiper, channels=2)\n        self.digital_pot.set_channel_label(0, \"CH A\")\n        self.digital_pot.set_channel_label(1, \"CH B\")\n\n    def test_basic_properties(self):\n        \"\"\"\n        Testing basic parameters.\n        \"\"\"\n        pot = Potentiometer(r_ab=10e3, r_w=75, rheostat=False, parameters_locked=False)\n        digital_wiper = DigitalWiper(\n            potentiometer=pot, max_value=128, parameters_locked=False\n        )\n        digital_pot = DigitalPotentiometerDevice(wiper=digital_wiper, channels=3)\n        self.assertEqual(digital_pot.channels_num, 3)\n        channels = digital_pot.channels\n        for channel_number, wiper in channels.items():\n            self.assertEqual(wiper.potentiometer.r_ab, pot.r_ab)\n            self.assertEqual(wiper.potentiometer.r_w, pot.r_w)\n            self.assertEqual(wiper.potentiometer.r_lim, pot.r_lim)\n            self.assertEqual(wiper.max_value, digital_wiper.max_value)\n            self.assertEqual(\n                channel_number,\n                digital_pot.get_channel_number_by_label(str(channel_number)),\n            )\n            self.assertEqual(\n                channel_number,\n                digital_pot._get_channel_number_by_label_or_id(str(channel_number)),\n            )\n            self.assertEqual(\n                channel_number,\n                digital_pot._get_channel_number_by_label_or_id(channel_number),\n            )\n\n    def test_channel_labels(self):\n        \"\"\"\n        Test channels labeling system\n        \"\"\"\n        self.digital_pot.set_channel_label(0, \"CH A\")\n        self.digital_pot.set_channel_label(1, \"CH B\")\n        self.assertEqual(0, self.digital_pot.get_channel_number_by_label(\"CH A\"))\n        self.assertEqual(1, self.digital_pot.get_channel_number_by_label(\"CH B\"))\n        self.assertEqual(0, self.digital_pot._get_channel_number_by_label_or_id(0))\n        self.assertEqual(1, self.digital_pot._get_channel_number_by_label_or_id(1))\n        self.assertEqual(1, self.digital_pot._get_channel_number_by_label_or_id(\"CH B\"))\n        self.assertIsNone(self.digital_pot.get_channel_number_by_label(\"CH C\"))\n        self.assertIsNone(self.digital_pot._get_channel_number_by_label_or_id(\"CH C\"))\n        self.assertIsNone(self.digital_pot._get_channel_number_by_label_or_id(3))\n        with self.assertRaises(ValueError):\n            self.digital_pot._get_channel_number_by_label_or_id(1.1)\n        with self.assertRaises(ValueError):\n            self.digital_pot._get_channel_number_by_label_or_id(-1)\n        self.digital_pot.set_channel_label(0, None)\n        self.assertEqual(0, self.digital_pot.get_channel_number_by_label(\"0\"))\n        self.digital_pot.set_channel_label(0, \"CH A\")\n        with self.assertRaises(ValueError):\n            self.digital_pot.set_channel_label(1, \"CH A\")\n        with self.assertRaises(ValueError):\n            self.digital_pot.set_channel_label(2, \"CH A\")\n        with self.assertRaises(ValueError):\n            self.digital_pot.set_channel_label(1.1, \"CH C\")\n        with self.assertRaises(ValueError):\n            self.digital_pot.set_channel_label(-1, \"CH C\")\n\n    def test_value_set_and_get(self):\n        \"\"\"\n        Test `set` and `read` functions, value property\n        \"\"\"\n        self.digital_pot.set_value(0, 10)\n        self.assertEqual(self.digital_pot.value[0], 10)\n        self.assertEqual(self.digital_pot.get_value(0), 10)\n        self.digital_pot.set_value(\"CH A\", 20)\n        self.assertEqual(self.digital_pot.value[0], 20)\n        self.assertEqual(self.digital_pot.get_value(\"CH A\"), 20)\n        with self.assertRaises(ValueError):\n            self.digital_pot.set_value(\"CH C\", 20)\n        with self.assertRaises(ValueError):\n            self.digital_pot.set_value(2, 20)\n\n        self.assertEqual(self.digital_pot.get_value(0), 20)\n        self.assertEqual(self.digital_pot.get_value(\"CH A\"), 20)\n        with self.assertRaises(ValueError):\n            self.digital_pot.get_value(\"CH C\")\n        with self.assertRaises(ValueError):\n            self.digital_pot.get_value(2)\n\n        self.digital_pot.value = (10, 20)\n        self.assertEqual(self.digital_pot.value, (10, 20))\n        with self.assertRaises(ValueError):\n            self.digital_pot.value = 10\n        with self.assertRaises(ValueError):\n            self.digital_pot.value = (10, 20, 30)\n        values = np.arange(129)\n        for value in values:\n            self.digital_pot.set_value(0, value)\n            self.digital_pot.set_value(1, value)\n            self.assertEqual(self.digital_pot.value, (value, value))\n\n    def test_rwa_rwb(self):\n        \"\"\"Test r_wa and r_wb control\"\"\"\n        self.digital_pot.set_r_wa(0, self.pot.r_ab / 2)\n        self.digital_pot.set_r_wa(\"CH A\", self.pot.r_ab / 2)\n        pos = self.digital_pot.value[0] / self.digital_pot.channels[0].max_value\n        self.assertEqual(self.digital_pot.r_wa[0], self.pot.r_wa(pos))\n        self.assertEqual(self.digital_pot.get_r_wa(0), self.pot.r_wa(pos))\n        self.assertEqual(self.digital_pot.get_r_wa(\"CH A\"), self.pot.r_wa(pos))\n        with self.assertRaises(ValueError):\n            self.digital_pot.set_r_wa(2, self.pot.r_ab / 2)\n        self.digital_pot.set_r_wb(1, self.pot.r_ab / 3)\n        self.digital_pot.set_r_wb(\"CH B\", self.pot.r_ab / 3)\n        pos = self.digital_pot.value[1] / self.digital_pot.channels[1].max_value\n        self.assertEqual(self.digital_pot.r_wb[1], self.pot.r_wb(pos))\n        self.assertEqual(self.digital_pot.get_r_wb(1), self.pot.r_wb(pos))\n        self.assertEqual(self.digital_pot.get_r_wb(\"CH B\"), self.pot.r_wb(pos))\n        with self.assertRaises(ValueError):\n            self.digital_pot.set_r_wb(2, self.pot.r_ab / 3)\n\n        self.digital_pot.r_wa = (self.pot.r_ab / 2, self.pot.r_ab / 3)\n        pos = self.digital_pot.value[0] / self.digital_pot.channels[0].max_value\n        self.assertEqual(self.digital_pot.r_wa[0], self.pot.r_wa(pos))\n        pos = self.digital_pot.value[1] / self.digital_pot.channels[1].max_value\n        self.assertEqual(self.digital_pot.r_wa[1], self.pot.r_wa(pos))\n        self.digital_pot.r_wb = (self.pot.r_ab / 2, self.pot.r_ab / 3)\n        pos = self.digital_pot.value[0] / self.digital_pot.channels[0].max_value\n        self.assertEqual(self.digital_pot.r_wb[0], self.pot.r_wb(pos))\n        pos = self.digital_pot.value[1] / self.digital_pot.channels[1].max_value\n        self.assertEqual(self.digital_pot.r_wb[1], self.pot.r_wb(pos))\n\n        with self.assertRaises(ValueError):\n            self.digital_pot.r_wa = (0, 0, 0)\n        with self.assertRaises(TypeError):\n            self.digital_pot.r_wa = 0\n\n        with self.assertRaises(ValueError):\n            self.digital_pot.r_wb = (0, 0, 0)\n        with self.assertRaises(TypeError):\n            self.digital_pot.r_wb = 0\n\n        with self.assertRaises(ValueError):\n            self.digital_pot.get_r_wa(\"CH ZZZ\")\n        with self.assertRaises(ValueError):\n            self.digital_pot.get_r_wb(\"CH ZZZ\")\n\n    def test_voltage_in(self):\n        \"\"\"\n        Test voltage_in setters and getters\n        \"\"\"\n        self.assertEqual(self.digital_pot.voltage_in, (0, 0))\n        self.digital_pot.voltage_in = (-5, 5)\n        self.assertEqual(self.digital_pot.voltage_in, (-5, 5))\n        self.assertEqual(self.digital_pot.get_voltage_in(\"CH A\"), -5)\n        self.assertEqual(self.digital_pot.get_voltage_in(\"CH B\"), 5)\n        with self.assertRaises(ValueError):\n            self.digital_pot.get_voltage_in(\"CH XXX\")\n        with self.assertRaises(ValueError):\n            self.digital_pot.voltage_in = (-5, 5, 0)\n        with self.assertRaises(TypeError):\n            self.digital_pot.voltage_in = 5\n        self.digital_pot.set_voltage_in(0, 5)\n        self.digital_pot.set_voltage_in(\"CH B\", 15)\n        self.assertEqual(self.digital_pot.voltage_in, (5, 15))\n        with self.assertRaises(ValueError):\n            self.digital_pot.set_voltage_in(2, 5)\n\n    def test_voltage_out(self):\n        \"\"\"\n        Test voltage_out setters and getters\n        \"\"\"\n        self.assertEqual(self.digital_pot.voltage_out, (0, 0))\n        self.digital_pot.voltage_in = (-5, 5)\n        self.digital_pot.voltage_out = (-2.5, 2.5)\n        self.assertEqual(\n            self.digital_pot.voltage_out,\n            (\n                self.digital_pot.channels[0].voltage_out,\n                self.digital_pot.channels[1].voltage_out,\n            ),\n        )\n        self.assertEqual(\n            self.digital_pot.get_voltage_out(\"CH A\"),\n            self.digital_pot.channels[0].voltage_out,\n        )\n        self.assertEqual(\n            self.digital_pot.get_voltage_out(\"CH B\"),\n            self.digital_pot.channels[1].voltage_out,\n        )\n        with self.assertRaises(ValueError):\n            self.digital_pot.get_voltage_out(\"CH XXX\")\n        with self.assertRaises(ValueError):\n            self.digital_pot.voltage_out = (-5, 5, 0)\n        with self.assertRaises(TypeError):\n            self.digital_pot.voltage_out = 5\n        self.digital_pot.set_voltage_out(0, -1)\n        self.digital_pot.set_voltage_out(\"CH B\", 1.5)\n        self.assertEqual(\n            self.digital_pot.voltage_out,\n            (\n                self.digital_pot.channels[0].voltage_out,\n                self.digital_pot.channels[1].voltage_out,\n            ),\n        )\n        with self.assertRaises(ValueError):\n            self.digital_pot.set_voltage_out(2, 5)\n        min_r_step = (self.pot.r_ab + self.pot.r_w) / self.digital_pot.channels[\n            0\n        ].max_value\n        self.assertTrue(\n            abs(self.digital_pot.channels[0].voltage_out - 1) < min_r_step * 5\n        )\n\n    def test_r_lim(self):\n        \"\"\"\n        Test r_lim property and corresponding get_ and set_ methods.\n        \"\"\"\n        self.digital_pot.r_lim = 200\n        self.assertEqual(self.digital_pot.r_lim, (200, 200))\n        self.digital_pot.r_lim = (100, 200)\n        self.assertEqual(self.digital_pot.r_lim, (100, 200))\n        self.assertEqual(self.digital_pot.get_r_lim(\"CH A\"), 100)\n        self.assertEqual(self.digital_pot.get_r_lim(\"CH B\"), 200)\n        self.digital_pot.set_r_lim(\"CH B\", 300)\n        self.assertEqual(self.digital_pot.get_r_lim(\"CH B\"), 300)\n        with self.assertRaises(ValueError):\n            self.digital_pot.r_lim = (100, 200, 300)\n        with self.assertRaises(TypeError):\n            self.digital_pot.r_lim = (\"A\", 200)\n        with self.assertRaises(ValueError):\n            self.digital_pot.r_lim = \"A\"\n        with self.assertRaises(ValueError):\n            self.digital_pot.set_r_lim(\"CH XXX\", 300)\n        with self.assertRaises(ValueError):\n            self.digital_pot.get_r_lim(\"CH XXX\")\n        with self.assertRaises(ValueError):\n            self.digital_pot.set_r_lim(\"CH B\", -300)\n\n    def test_r_load(self):\n        \"\"\"\n        Testing r_load property and corresponding get_ and set_ methods.\n        \"\"\"\n        self.digital_pot.r_load = 1e6\n        self.assertEqual(self.digital_pot.r_load, (1e6, 1e6))\n        self.digital_pot.r_load = (1e6, 2e6)\n        self.assertEqual(self.digital_pot.r_load, (1e6, 2e6))\n        self.assertEqual(self.digital_pot.get_r_load(\"CH A\"), 1e6)\n        self.assertEqual(self.digital_pot.get_r_load(\"CH B\"), 2e6)\n        self.digital_pot.set_r_load(\"CH B\", 3e6)\n        self.assertEqual(self.digital_pot.get_r_load(\"CH B\"), 3e6)\n        with self.assertRaises(ValueError):\n            self.digital_pot.r_load = (1e6, 2e6, 3e6)\n        with self.assertRaises(TypeError):\n            self.digital_pot.r_load = (\"A\", 2e6)\n        with self.assertRaises(ValueError):\n            self.digital_pot.r_load = \"A\"\n        with self.assertRaises(ValueError):\n            self.digital_pot.set_r_load(\"CH XXX\", 3e6)\n        with self.assertRaises(ValueError):\n            self.digital_pot.get_r_load(\"CH XXX\")\n        with self.assertRaises(ValueError):\n            self.digital_pot.set_r_load(\"CH B\", -3e6)", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/helpers/test_helpers_check_number.py", "chunked_list": ["\"\"\" Testing helpers functions (check_number). \"\"\"\n\nimport unittest\nimport numpy as np\n\ntry:\n    from src.BDPotentiometer.__helpers import check_number\nexcept ModuleNotFoundError:\n    from BDPotentiometer.__helpers import check_number\n", "\n\nclass TestHelpersCheckNumber(unittest.TestCase):\n    \"\"\"\n    Testing check_number function.\n    Function checks if argument is a real number (not complex).\n    return int or float depending on argument type or raises ValueError\n    if argument is not a real number.\n    check_number does not allow argument to be +-inf, or NaN.\n    Special numbers `+0` and `-0` must be converted to just 0\n    \"\"\"\n\n    def test_check_number_int(self):\n        \"\"\"Check integer arguments.\"\"\"\n        for input_value in [-17, -1, -0, 0, 1, 17]:\n            output_value = check_number(input_value)\n            self.assertEqual(output_value, input_value)\n            self.assertIsInstance(output_value, int)\n            # Check numpy integer types.\n            for numpy_type in [np.int32, np.int64, np.int8]:\n                np_input_value = numpy_type(input_value)\n                output_value = check_number(np_input_value)\n                self.assertEqual(output_value, input_value)\n                self.assertIsInstance(output_value, int)\n\n    def test_check_number_float(self):\n        \"\"\"Check float arguments.\"\"\"\n        for input_value in [-17.3, -2.0, -1.1, 0.0, 1.0, 17.2]:\n            output_value = check_number(input_value)\n            self.assertEqual(output_value, input_value)\n            self.assertIsInstance(output_value, float)\n            # Check numpy float types.\n            for numpy_type in [np.float32, np.float64]:\n                np_input_value = numpy_type(input_value)\n                output_value = check_number(np_input_value)\n                np.testing.assert_allclose(output_value, input_value)\n                self.assertIsInstance(output_value, float)\n        # Check +0 and -0 float numbers are converted to 0.0.\n        for input_value in [float(\"+0.0\"), float(\"-0.0\")]:\n            output_value = check_number(input_value)\n            self.assertEqual(output_value, 0.0)\n            self.assertIsInstance(output_value, float)\n\n    def test_check_number_float_inf_nan(self):\n        \"\"\"Check float inf and nan arguments.\"\"\"\n        # Check ValueError is raised for special float +-inf, NaN.\n        for input_value in [\n            float(\"+inf\"),\n            float(\"-inf\"),\n            float(\"nan\"),\n            np.inf,\n            -np.inf,\n        ]:\n            with self.assertRaises(ValueError):\n                check_number(input_value)\n\n    def test_check_number_wrong_type(self):\n        \"\"\"Check TypeError is raised for wrong argument type.\"\"\"\n        for input_value in [\n            1.1 + 3.5j,  # Complex value\n            1.1 + 0j,  # Complex value with zero imaginary part\n            \"-17.3\",\n            \"a\",\n            [0.0],\n            [1.0, 17.2],\n            (np.pi,),\n            (2, 2.3),\n            None,\n        ]:\n            with self.assertRaises(TypeError):\n                check_number(input_value)", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/helpers/test_helpers_check_integer.py", "chunked_list": ["\"\"\" Testing helpers functions (check_integer). \"\"\"\n\nimport unittest\nimport numpy as np\n\ntry:\n    from src.BDPotentiometer.__helpers import check_integer\nexcept ModuleNotFoundError:\n    from BDPotentiometer.__helpers import check_integer\n", "\n\nclass TestHelpersCheckInteger(unittest.TestCase):\n    \"\"\"\n    Testing check_integer function.\n    \"\"\"\n\n    def test_check_integer_int(self):\n        \"\"\"Check integers.\"\"\"\n        for input_value in [-100, -3, -0, 0, 2, 100]:\n            output_value = check_integer(input_value)\n            self.assertEqual(output_value, input_value)\n            self.assertIsInstance(output_value, int)\n            # Check numpy integer types.\n            for numpy_type in [np.int32, np.int64, np.int8]:\n                np_input_value = numpy_type(input_value)\n                output_value = check_integer(np_input_value)\n                self.assertEqual(output_value, input_value)\n                self.assertIsInstance(output_value, int)\n\n    def test_check_integer_float(self):\n        \"\"\"Check floats.\"\"\"\n        for input_value in [-100.0, -3.0, float(\"-0.0\"), 0.0, 2.0, 100.0]:\n            output_value = check_integer(input_value)\n            self.assertEqual(output_value, input_value)\n            self.assertIsInstance(output_value, int)\n        # Check numpy float types.\n        for input_value in [-17.0, -2.0, -1.0, 0.0, 1.0, 137.0]:\n            for numpy_type in [np.float32, np.float64]:\n                np_input_value = numpy_type(input_value)\n                output_value = check_integer(np_input_value)\n                np.testing.assert_allclose(output_value, input_value)\n                self.assertIsInstance(output_value, int)\n\n    def test_check_integer_wrong_value(self):\n        \"\"\"\n        Check ValueError is raised for not integer argument values,\n        including special floats.\n        \"\"\"\n        for input_value in [\n            float(\"inf\"),\n            float(\"-inf\"),\n            float(\"nan\"),\n            np.inf,\n            -np.inf,\n            -27.1,\n            -22.2,\n            np.pi,\n        ]:\n            with self.assertRaises(ValueError):\n                check_integer(input_value)\n\n    def test_check_integer_wrong_type(self):\n        \"\"\"Check TypeError is raised for wrong argument type.\"\"\"\n        for input_value in [\n            1.1 + 3.2j,  # Complex number\n            3.14 + 0j,  # Complex number with zero imaginary part\n            \"-18.7\",\n            \"b\",\n            [0.0],\n            [1.1, 16.4],\n            (np.pi,),\n            (4, 2.3),\n            None,\n        ]:\n            with self.assertRaises(TypeError):\n                check_integer(input_value)", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/helpers/test_helpers.py", "chunked_list": ["\"\"\" Testing helpers functions. \"\"\"\n\nimport unittest\nimport numpy as np\n\ntry:\n    from src.BDPotentiometer.__helpers import (\n        check_not_negative,\n        check_positive,\n        clamp,\n        build_tuple,\n        adjust_tuple,\n    )\nexcept ModuleNotFoundError:\n    from BDPotentiometer.__helpers import (\n        check_not_negative,\n        check_positive,\n        clamp,\n        build_tuple,\n        adjust_tuple,\n    )", "\n\nclass TestHelpers(unittest.TestCase):\n    \"\"\"Test case for helpers functions\"\"\"\n\n    def test_non_negative(self):\n        \"\"\"\n        Testing check_not_negative function.\n        \"\"\"\n        # Check integers.\n        for input_value in [100, 3, -0, 0, 2]:\n            output_value = check_not_negative(input_value)\n            self.assertEqual(output_value, input_value)\n            self.assertIsInstance(output_value, int)\n        # Check floats.\n        for input_value in [100.0, 3.0, float(\"-0.0\"), 0.0, 2.0]:\n            output_value = check_not_negative(input_value)\n            self.assertEqual(output_value, input_value)\n            self.assertIsInstance(output_value, float)\n        # Check numpy integer types.\n        for input_value in [17, 1, 0, 17]:\n            for numpy_type in [np.int32, np.int64, np.int8]:\n                np_input_value = numpy_type(input_value)\n                output_value = check_not_negative(np_input_value)\n                self.assertEqual(output_value, input_value)\n                self.assertIsInstance(output_value, int)\n        # Check numpy float types.\n        for input_value in [17.4, 2.0, 1.234, float(\"-0.0\"), 0.0, np.pi]:\n            for numpy_type in [np.float32, np.float64]:\n                np_input_value = numpy_type(input_value)\n                output_value = check_not_negative(np_input_value)\n                np.testing.assert_allclose(output_value, input_value)\n                self.assertIsInstance(output_value, float)\n        # Check ValueError raised for negative values.\n        for input_value in [-100, -2, -17.1, -2.2, -np.pi]:\n            with self.assertRaises(ValueError):\n                check_not_negative(input_value)\n        # Check ValueError raised for special floats +-inf, NaN.\n        for input_value in [float(\"inf\"), float(\"-inf\"), float(\"nan\")]:\n            with self.assertRaises(ValueError):\n                check_not_negative(input_value)\n        # Check TypeError is raised for wrong argument type.\n        for input_value in [\"-17.3\", \"a\", [0.0], [1.0, 17.2], (np.pi,), (2, 2.3), None]:\n            with self.assertRaises(TypeError):\n                check_not_negative(input_value)\n\n    def test_positive(self):\n        \"\"\"\n        Testing check_positive function.\n        \"\"\"\n        # Check integers.\n        for input_value in [100, 3, 2]:\n            output_value = check_positive(input_value)\n            self.assertEqual(output_value, input_value)\n            self.assertIsInstance(output_value, int)\n        # Check floats.\n        for input_value in [100.0, 3.0, 2.0]:\n            output_value = check_positive(input_value)\n            self.assertEqual(output_value, input_value)\n            self.assertIsInstance(output_value, float)\n        # Check numpy integer types.\n        for input_value in [17, 1, 17]:\n            for numpy_type in [np.int32, np.int64, np.int8]:\n                np_input_value = numpy_type(input_value)\n                output_value = check_positive(np_input_value)\n                self.assertEqual(output_value, input_value)\n                self.assertIsInstance(output_value, int)\n        # Check numpy float types.\n        for input_value in [17.4, 2.0, 1.234, np.pi]:\n            for numpy_type in [np.float32, np.float64]:\n                np_input_value = numpy_type(input_value)\n                output_value = check_positive(np_input_value)\n                np.testing.assert_allclose(output_value, input_value)\n                self.assertIsInstance(output_value, float)\n        # Check ValueError raised for negative and zero values.\n        for input_value in [-100, -2, -17.1, -2.2, -np.pi, 0, 0.0, float(\"-0.0\")]:\n            with self.assertRaises(ValueError):\n                check_positive(input_value)\n        # Check ValueError raised for special floats +-inf, NaN.\n        for input_value in [float(\"inf\"), float(\"-inf\"), float(\"nan\")]:\n            with self.assertRaises(ValueError):\n                check_positive(input_value)\n        # Check TypeError is raised for wrong argument type.\n        for input_value in [\"-17.3\", \"a\", [0.0], [1.0, 17.2], (np.pi,), (2, 2.3), None]:\n            with self.assertRaises(TypeError):\n                check_positive(input_value)\n\n    def test_clamp(self):\n        \"\"\"\n        Testing clamp function normal operation.\n        \"\"\"\n        # Check non-zero width range.\n        left = -0.1  # float\n        right = 100  # int\n        for input_value in [\n            -1,\n            -1.0,\n            -0.1,\n            0,\n            1.5,\n            12,\n            100.0,\n            100,\n            101,\n            101.0,\n        ]:\n            for output_value in [\n                clamp(input_value, left, right),\n                clamp(input_value, right, left),\n            ]:\n                if min(left, right) <= input_value <= max(left, right):\n                    self.assertEqual(output_value, input_value)\n                elif input_value < min(left, right):\n                    self.assertEqual(output_value, min(left, right))\n                elif input_value > max(left, right):\n                    self.assertEqual(output_value, max(left, right))\n                # If input is a float number clamp must return float\n                if isinstance(input_value, float):\n                    self.assertIsInstance(output_value, float)\n        # Check zero width range.\n        left = 100.0  # float\n        right = 100  # int\n        for input_value in [-1, -1.0, 0.0, 0, 100.0, 100, 101, 101.0]:\n            for output_value in [\n                clamp(input_value, left, right),\n                clamp(input_value, right, left),\n            ]:\n                if min(left, right) <= input_value <= max(left, right):\n                    self.assertEqual(output_value, input_value)\n                if input_value < min(left, right):\n                    self.assertEqual(output_value, min(left, right))\n                if input_value > max(left, right):\n                    self.assertEqual(output_value, max(left, right))\n                # If input is a float number clamp must return float\n                if isinstance(input_value, float):\n                    self.assertIsInstance(output_value, float)\n\n    def test_clamp_errors(self):\n        \"\"\"\n        Testing clamp function errors.\n        \"\"\"\n        # Check TypeError is raised for wrong argument type.\n        for input_value in [\"-17.3\", \"a\", [0.0], [1.0, 17.2], (np.pi,), (2, 2.3), None]:\n            with self.assertRaises(TypeError):\n                clamp(input_value, -10.0, 10)\n        for left in [\"-17.3\", \"a\", [0.0], [1.0, 17.2], (np.pi,), (2, 2.3), None]:\n            with self.assertRaises(TypeError):\n                clamp(10, left, 10.0)\n        for right in [\"-17.3\", \"a\", [0.0], [1.0, 17.2], (np.pi,), (2, 2.3), None]:\n            with self.assertRaises(TypeError):\n                clamp(10, -10, right)\n\n    def test_build_tuple(self):\n        \"\"\"\n        Testing build_tuple function normal operation.\n        \"\"\"\n        # Check normal operation: build tuple from single number.\n        for input_value in [-1.1, -1, -1.0, 0, 0.0, 1.0, 1, 1.1]:\n            for num in [1, 2, 3, 20, 3.0]:\n                for func in [lambda x: 2 * x, None]:\n                    output_value = build_tuple(input_value, num, func=func)\n                    self.assertEqual(len(output_value), num)\n                    for item in output_value:\n                        if func is None:\n                            self.assertEqual(item, input_value)\n                        else:\n                            self.assertEqual(item, func(input_value))\n                        self.assertIsInstance(\n                            item, float\n                        )  # build_tuple returns tuple of floats\n        # Check normal operation: apply func to given list or tuple.\n        for input_value in [[-1.1, -1, 3], (-1.0, 0, 0.0, 1.0, 1, 1.1)]:\n            for func in [lambda x: 2 * x, None]:\n                output_value = build_tuple(input_value, len(input_value), func=func)\n                self.assertEqual(len(output_value), len(input_value))\n                for item_out, item_in in zip(output_value, input_value):\n                    if func is None:\n                        self.assertEqual(item_out, item_in)\n                    else:\n                        self.assertEqual(item_out, func(item_in))\n                    self.assertIsInstance(\n                        item_out, float\n                    )  # build_tuple returns tuple of floats\n\n    def test_build_tuple_errors(self):\n        \"\"\"\n        Testing build_tuple function errors.\n        \"\"\"\n        # Check ValueError is raised for wrong number of elements\n        for input_value in [[2.1, np.pi], (0, 3.14, -4, 5.2)]:\n            with self.assertRaises(ValueError):\n                build_tuple(input_value, 3, func=None)\n        # Check ValueError is raised for wrong num parameter value\n        for num in [-3, 2.1, np.pi]:\n            with self.assertRaises(ValueError):\n                build_tuple(-10, num, func=None)\n        # Check TypeError is raised for wrong input value\n        for input_value in [\"a\", \"2\", [2.2, \"1.0\"], None]:\n            with self.assertRaises(TypeError):\n                build_tuple(input_value, 2, func=None)\n        # Check TypeError is raised for wrong num parameter value\n        for num in [\"a\", [1, 2, 3], \"2\", None]:\n            with self.assertRaises(TypeError):\n                build_tuple(-10, num, func=None)\n        # Check TypeError is raised for wrong func parameter value\n        for func in [2, \"a\", [1, 2, 3]]:\n            with self.assertRaises(TypeError):\n                build_tuple(-10, 2, func=func)\n\n    def test_adjust_tuple(self):\n        \"\"\"\n        Testing adjust_tuple function\n        \"\"\"\n        # Check truncate tuple or list\n        value = (1, 2.0, 3.0, 4.0, 5.0)  # int values will be converted to float\n        self.assertEqual(adjust_tuple(value, 2, default_value=4), (1.0, 2.0))\n        self.assertEqual(adjust_tuple(list(value), 2, default_value=4), (1.0, 2.0))\n        self.assertEqual(adjust_tuple(list(value), 2.0, default_value=4), (1.0, 2.0))\n        # Check grow tuple or list\n        value = (1, 2.0)  # int values will be converted to float\n        self.assertEqual(adjust_tuple(value, 4, default_value=4), (1.0, 2.0, 4.0, 4.0))\n        self.assertEqual(\n            adjust_tuple(list(value), 4, default_value=4), (1.0, 2.0, 4.0, 4.0)\n        )\n        # Check leave tuple or least unchanged\n        value = (1.0, 2.0, 3)  # int values will be converted to float\n        self.assertEqual(adjust_tuple(value, 3, default_value=4), (1.0, 2.0, 3.0))\n        self.assertEqual(adjust_tuple(list(value), 3, default_value=4), (1.0, 2.0, 3.0))\n        # Check TypeError is raised for wrong input value\n        for input_value in [1, 2.3, [\"a\", 2], (None, 1.1), None]:\n            with self.assertRaises(TypeError):\n                adjust_tuple(input_value, 2, default_value=4)\n        # Check TypeError is raised for wrong num value\n        for num in [\"1\", [\"a\", 2], (None, 1.1), None]:\n            with self.assertRaises(TypeError):\n                adjust_tuple((1.0, 2.2), num, default_value=4)\n        # Check ValueError is raised for wrong num value\n        for num in [-3, -1.0, 2.3]:\n            with self.assertRaises(ValueError):\n                adjust_tuple((1.0, 2.2), num, default_value=4)\n        # Check TypeError is raised for wrong default value\n        for default_value in [\"1\", [\"a\", 2], (None, 1.1), None]:\n            with self.assertRaises(TypeError):\n                adjust_tuple((1.0, 2.2), 2, default_value=default_value)", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/digital_wiper/test_digital_wiper_constructor.py", "chunked_list": ["\"\"\" Tests for DigitalWiper constructor. \"\"\"\n\nimport unittest\n\ntry:\n    from src.BDPotentiometer import Potentiometer, DigitalWiper\nexcept ModuleNotFoundError:\n    from BDPotentiometer import Potentiometer, DigitalWiper\n\n\nclass TestDigitalWiperConstructor(unittest.TestCase):\n    \"\"\"\n    Testing DigitalWiper constructor.\n    \"\"\"\n\n    def test_constructor(self) -> None:\n        \"\"\"\n        Test DigitalWiper constructor\n        \"\"\"\n        pot = Potentiometer(r_ab=10e3, r_w=75, rheostat=False, parameters_locked=False)\n        # Normal constructor parameters\n        for locked in [True, False]:\n            for max_value in [1, 10, 128, 1024]:\n                digital_wiper = DigitalWiper(\n                    potentiometer=pot, max_value=max_value, parameters_locked=locked\n                )\n                self.assertEqual(digital_wiper.potentiometer, pot)\n                self.assertEqual(digital_wiper.parameters_locked, locked)\n                self.assertEqual(digital_wiper.max_value, max_value)\n        # Wrong potentiometer type\n        for locked in [True, False]:\n            for pot_ in [None, \"pot\"]:\n                with self.assertRaises(TypeError):\n                    _ = DigitalWiper(\n                        potentiometer=pot_, max_value=128, parameters_locked=locked\n                    )\n        # Wrong max_value type\n        for locked in [True, False]:\n            for max_value in [None, \"128\"]:\n                with self.assertRaises(TypeError):\n                    _ = DigitalWiper(\n                        potentiometer=pot, max_value=max_value, parameters_locked=locked\n                    )\n        # Wrong max_value value\n        for locked in [True, False]:\n            for max_value in [0, -128, 12.6]:\n                with self.assertRaises(ValueError):\n                    _ = DigitalWiper(\n                        potentiometer=pot, max_value=max_value, parameters_locked=locked\n                    )", "\n\nclass TestDigitalWiperConstructor(unittest.TestCase):\n    \"\"\"\n    Testing DigitalWiper constructor.\n    \"\"\"\n\n    def test_constructor(self) -> None:\n        \"\"\"\n        Test DigitalWiper constructor\n        \"\"\"\n        pot = Potentiometer(r_ab=10e3, r_w=75, rheostat=False, parameters_locked=False)\n        # Normal constructor parameters\n        for locked in [True, False]:\n            for max_value in [1, 10, 128, 1024]:\n                digital_wiper = DigitalWiper(\n                    potentiometer=pot, max_value=max_value, parameters_locked=locked\n                )\n                self.assertEqual(digital_wiper.potentiometer, pot)\n                self.assertEqual(digital_wiper.parameters_locked, locked)\n                self.assertEqual(digital_wiper.max_value, max_value)\n        # Wrong potentiometer type\n        for locked in [True, False]:\n            for pot_ in [None, \"pot\"]:\n                with self.assertRaises(TypeError):\n                    _ = DigitalWiper(\n                        potentiometer=pot_, max_value=128, parameters_locked=locked\n                    )\n        # Wrong max_value type\n        for locked in [True, False]:\n            for max_value in [None, \"128\"]:\n                with self.assertRaises(TypeError):\n                    _ = DigitalWiper(\n                        potentiometer=pot, max_value=max_value, parameters_locked=locked\n                    )\n        # Wrong max_value value\n        for locked in [True, False]:\n            for max_value in [0, -128, 12.6]:\n                with self.assertRaises(ValueError):\n                    _ = DigitalWiper(\n                        potentiometer=pot, max_value=max_value, parameters_locked=locked\n                    )", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/digital_wiper/test_digital_wiper_fixed_resistors.py", "chunked_list": ["\"\"\" Tests for DigitalWiper fixed resistors. \"\"\"\n\nimport unittest\nimport numpy as np\n\ntry:\n    from src.BDPotentiometer import Potentiometer, DigitalWiper\nexcept ModuleNotFoundError:\n    from BDPotentiometer import Potentiometer, DigitalWiper\n", "\n\nclass TestDigitalWiperFixedResistors(unittest.TestCase):\n    \"\"\"\n    Testing DigitalWiper fixed resistors.\n    \"\"\"\n\n    def test_r_lim(self):\n        \"\"\"\n        Tests current limiting resistor value altering.\n        \"\"\"\n        pot = Potentiometer(\n            r_ab=200e3, r_w=375, rheostat=False, parameters_locked=False\n        )\n        for locked in [True, False]:\n            for max_value in [1, 14, 43]:\n                digital_wiper = DigitalWiper(\n                    potentiometer=pot, max_value=max_value, parameters_locked=locked\n                )\n                # Correct values (positive float numbers)\n                for resistance in np.linspace(0, 104, num=101, endpoint=True):\n                    digital_wiper.r_lim = resistance\n                    self.assertEqual(digital_wiper.r_lim, resistance)\n                    self.assertEqual(\n                        digital_wiper.r_lim, digital_wiper.potentiometer.r_lim\n                    )\n                # Wrong values\n                for resistance in [-200.4, -1]:\n                    with self.assertRaises(ValueError):\n                        digital_wiper.r_lim = resistance\n                # Wrong type\n                for resistance in [None, \"100.2\"]:\n                    with self.assertRaises(TypeError):\n                        digital_wiper.r_lim = resistance\n\n    def test_r_load(self):\n        \"\"\"\n        Tests load resistor value altering.\n        \"\"\"\n        pot = Potentiometer(\n            r_ab=170e3, r_w=145, rheostat=False, parameters_locked=False\n        )\n        for locked in [True, False]:\n            for max_value in [1, 26, 51]:\n                digital_wiper = DigitalWiper(\n                    potentiometer=pot, max_value=max_value, parameters_locked=locked\n                )\n                # Correct values (positive float numbers)\n                for resistance in np.linspace(0, 10e4, num=101, endpoint=True):\n                    digital_wiper.r_load = resistance\n                    self.assertEqual(digital_wiper.r_load, resistance)\n                    self.assertEqual(\n                        digital_wiper.r_load, digital_wiper.potentiometer.r_load\n                    )\n                # Wrong values\n                for resistance in [-200.4, -1]:\n                    with self.assertRaises(ValueError):\n                        digital_wiper.r_load = resistance\n                # Wrong type\n                for resistance in [None, \"100.2\"]:\n                    with self.assertRaises(TypeError):\n                        digital_wiper.r_load = resistance", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/digital_wiper/test_digital_wiper_value.py", "chunked_list": ["\"\"\" Tests for DigitalWiper value get and set operations. \"\"\"\n\nimport unittest\nimport numpy as np\n\ntry:\n    from src.BDPotentiometer import Potentiometer, DigitalWiper\nexcept ModuleNotFoundError:\n    from BDPotentiometer import Potentiometer, DigitalWiper\n", "\n\nclass TestDigitalWiperValue(unittest.TestCase):\n    \"\"\"\n    Testing DigitalWiper `value` property.\n    \"\"\"\n\n    def test_value_get_set(self):\n        \"\"\"\n        Testing `value` property.\n        \"\"\"\n        pot = Potentiometer(\n            r_ab=100e3, r_w=175, rheostat=False, parameters_locked=False\n        )\n        for locked in [True, False]:\n            for max_value in [1, 16, 31]:\n                digital_wiper = DigitalWiper(\n                    potentiometer=pot, max_value=max_value, parameters_locked=locked\n                )\n                # Correct values\n                for value_new in np.arange(max_value):\n                    digital_wiper.value = value_new\n                    self.assertEqual(digital_wiper.value, value_new)\n                # Check correct float values\n                for value_new in [0.0, 1.0]:\n                    digital_wiper.value = value_new\n                    self.assertEqual(digital_wiper.value, value_new)\n                # Values less than 0 will be clamped to zero\n                for value_new in [-10, -1, 0]:\n                    digital_wiper.value = value_new\n                    self.assertEqual(digital_wiper.value, 0)\n                # Values greater than max_value will be clamped to max_value\n                for value_new in [max_value, max_value + 1, max_value + 10]:\n                    digital_wiper.value = value_new\n                    self.assertEqual(digital_wiper.value, max_value)\n                    self.assertEqual(digital_wiper.value, digital_wiper.max_value)\n        # Wrong parameter value (non int number)\n        for value_new in [-1.1, 0.2, 12.5]:\n            with self.assertRaises(ValueError):\n                digital_wiper.value = value_new\n        # Wrong parameter type\n        for value_new in [None, \"1\"]:\n            with self.assertRaises(TypeError):\n                digital_wiper.value = value_new\n\n    def test_value_relative(self):\n        \"\"\"\n        Test relative value calculation.\n        \"\"\"\n        pot = Potentiometer(\n            r_ab=100e3, r_w=175, rheostat=False, parameters_locked=False\n        )\n        for locked in [True, False]:\n            for max_value in [1, 16, 31]:\n                digital_wiper = DigitalWiper(\n                    potentiometer=pot, max_value=max_value, parameters_locked=locked\n                )\n                # Correct values\n                for value_r_new in np.linspace(0, 1, num=51, endpoint=True):\n                    digital_wiper.value_relative = value_r_new\n                    value_int = int(round(value_r_new * digital_wiper.max_value))\n                    value_r_new_coerced = value_int / digital_wiper.max_value\n                    self.assertEqual(digital_wiper.value_relative, value_r_new_coerced)\n                    self.assertEqual(digital_wiper.value, value_int)\n                # Values less than 0 will be clamped to zero\n                for value_r_new in [-10.2, -3.3, -1, 0, 0.0]:\n                    digital_wiper.value_relative = value_r_new\n                    self.assertEqual(digital_wiper.value_relative, 0)\n                    self.assertEqual(digital_wiper.value, 0)\n                # Values greater than 1 will be clamped to 1\n                for value_r_new in [1, 1.0, 1.1, 12, 35.6]:\n                    digital_wiper.value_relative = value_r_new\n                    self.assertEqual(digital_wiper.value_relative, 1)\n                    self.assertEqual(digital_wiper.value, max_value)\n                    self.assertEqual(digital_wiper.value, digital_wiper.max_value)\n        # Wrong parameter type\n        for value_r_new in [None, \"1\"]:\n            with self.assertRaises(TypeError):\n                digital_wiper.value_relative = value_r_new", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/digital_wiper/test_digital_wiper_channel_numbering.py", "chunked_list": ["\"\"\" Tests for DigitalWiper channel numbering. \"\"\"\n\nimport unittest\n\ntry:\n    from src.BDPotentiometer import Potentiometer, DigitalWiper\nexcept ModuleNotFoundError:\n    from BDPotentiometer import Potentiometer, DigitalWiper\n\n\nclass TestDigitalWiperChannelNumbering(unittest.TestCase):\n    \"\"\"\n    Testing DigitalWiper channel numbering.\n    \"\"\"\n\n    def test_channel_numbering(self):\n        \"\"\"\n        Testing channel numbering.\n        DigitalWiper Channel is a channel of the actual digital potentiometer device,\n        numbered in int numbers starting from 0.\n        \"\"\"\n        pot = Potentiometer(r_ab=20e3, r_w=50, rheostat=False, parameters_locked=False)\n        for locked in [True, False]:\n            for max_value in [1, 64, 128, 256]:\n                digital_wiper = DigitalWiper(\n                    potentiometer=pot, max_value=max_value, parameters_locked=locked\n                )\n                self.assertEqual(\n                    digital_wiper.channel, 0\n                )  # default channel number is 0\n                # Correct channel numbers\n                for channel_number in [3, 4.0, 1234, 0, 17]:\n                    digital_wiper.channel = channel_number\n                    self.assertEqual(digital_wiper.channel, channel_number)\n                # Wrong channel number value\n                for channel_number_ in [-1, 1.12]:\n                    with self.assertRaises(ValueError):\n                        digital_wiper.channel = channel_number_\n                # Wrong channel number type\n                for channel_number_ in [\"1\", None]:\n                    with self.assertRaises(TypeError):\n                        digital_wiper.channel = channel_number_\n                self.assertEqual(\n                    digital_wiper.channel, channel_number\n                )  # Check that channel number did not_change", "\n\nclass TestDigitalWiperChannelNumbering(unittest.TestCase):\n    \"\"\"\n    Testing DigitalWiper channel numbering.\n    \"\"\"\n\n    def test_channel_numbering(self):\n        \"\"\"\n        Testing channel numbering.\n        DigitalWiper Channel is a channel of the actual digital potentiometer device,\n        numbered in int numbers starting from 0.\n        \"\"\"\n        pot = Potentiometer(r_ab=20e3, r_w=50, rheostat=False, parameters_locked=False)\n        for locked in [True, False]:\n            for max_value in [1, 64, 128, 256]:\n                digital_wiper = DigitalWiper(\n                    potentiometer=pot, max_value=max_value, parameters_locked=locked\n                )\n                self.assertEqual(\n                    digital_wiper.channel, 0\n                )  # default channel number is 0\n                # Correct channel numbers\n                for channel_number in [3, 4.0, 1234, 0, 17]:\n                    digital_wiper.channel = channel_number\n                    self.assertEqual(digital_wiper.channel, channel_number)\n                # Wrong channel number value\n                for channel_number_ in [-1, 1.12]:\n                    with self.assertRaises(ValueError):\n                        digital_wiper.channel = channel_number_\n                # Wrong channel number type\n                for channel_number_ in [\"1\", None]:\n                    with self.assertRaises(TypeError):\n                        digital_wiper.channel = channel_number_\n                self.assertEqual(\n                    digital_wiper.channel, channel_number\n                )  # Check that channel number did not_change", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/digital_wiper/test_digital_wiper_rwa_rwb.py", "chunked_list": ["\"\"\" Tests for DigitalWiper `r_wa` and `r_wb` calculations. \"\"\"\n\nimport unittest\nimport numpy as np\n\ntry:\n    from src.BDPotentiometer import Potentiometer, DigitalWiper\nexcept ModuleNotFoundError:\n    from BDPotentiometer import Potentiometer, DigitalWiper\n", "\n\nclass TestDigitalWiperRwaRwb(unittest.TestCase):\n    \"\"\"\n    Testing DigitalWiper `r_wa` and `r_wb` calculations.\n    \"\"\"\n\n    def test_rwa_rwb(self):\n        \"\"\"\n        Test `r_wa` and `r_wb` properties.\n        \"\"\"\n        pot = Potentiometer(\n            r_ab=111e3, r_w=174, rheostat=False, parameters_locked=False\n        )\n        for locked in [True, False]:\n            for max_value in [1, 26, 41]:\n                digital_wiper = DigitalWiper(\n                    potentiometer=pot, max_value=max_value, parameters_locked=locked\n                )\n                # Correct values\n                for resistance in np.linspace(\n                    pot.r_w, pot.r_ab + pot.r_w, num=101, endpoint=True\n                ):\n                    digital_wiper.r_wa = resistance\n                    pos = digital_wiper.value_relative\n                    self.assertEqual(\n                        digital_wiper.r_wa, digital_wiper.potentiometer.r_wa(pos)\n                    )\n                    self.assertEqual(\n                        digital_wiper.r_wb, digital_wiper.potentiometer.r_wb(pos)\n                    )\n                    digital_wiper.r_wb = resistance\n                    pos = digital_wiper.value_relative\n                    self.assertEqual(\n                        digital_wiper.r_wa, digital_wiper.potentiometer.r_wa(pos)\n                    )\n                    self.assertEqual(\n                        digital_wiper.r_wb, digital_wiper.potentiometer.r_wb(pos)\n                    )\n                # Values less than r_w are clamped to r_w\n                for resistance in [-10.2, 0, pot.r_w - 0.1, pot.r_w]:\n                    digital_wiper.r_wa = resistance\n                    pos_req = digital_wiper.value_relative\n                    digital_wiper.r_wa = pot.r_w\n                    pos_r_w = digital_wiper.value_relative\n                    self.assertEqual(pos_req, pos_r_w)\n                    self.assertEqual(\n                        digital_wiper.r_wa, digital_wiper.potentiometer.r_wa(pos_r_w)\n                    )\n                    self.assertEqual(\n                        digital_wiper.r_wb, digital_wiper.potentiometer.r_wb(pos_r_w)\n                    )\n                    digital_wiper.r_wb = resistance\n                    pos_req = digital_wiper.value_relative\n                    digital_wiper.r_wb = pot.r_w\n                    pos_r_w = digital_wiper.value_relative\n                    self.assertEqual(pos_req, pos_r_w)\n                    self.assertEqual(\n                        digital_wiper.r_wa, digital_wiper.potentiometer.r_wa(pos_r_w)\n                    )\n                    self.assertEqual(\n                        digital_wiper.r_wb, digital_wiper.potentiometer.r_wb(pos_r_w)\n                    )\n                # Values greater than r_ab + r_w are clamped to r_ab + r_w\n                for resistance in [\n                    pot.r_ab + pos_r_w * 10,\n                    pot.r_ab + pos_r_w + 0.1,\n                    pot.r_ab + pos_r_w,\n                ]:\n                    digital_wiper.r_wa = resistance\n                    pos_req = digital_wiper.value_relative\n                    digital_wiper.r_wa = pot.r_ab + pos_r_w\n                    pos_r_max = digital_wiper.value_relative\n                    self.assertEqual(pos_req, pos_r_max)\n                    self.assertEqual(\n                        digital_wiper.r_wa, digital_wiper.potentiometer.r_wa(pos_r_max)\n                    )\n                    self.assertEqual(\n                        digital_wiper.r_wb, digital_wiper.potentiometer.r_wb(pos_r_max)\n                    )\n                    digital_wiper.r_wb = resistance\n                    pos_req = digital_wiper.value_relative\n                    digital_wiper.r_wb = pot.r_ab + pos_r_w\n                    pos_r_max = digital_wiper.value_relative\n                    self.assertEqual(pos_req, pos_r_max)\n                    self.assertEqual(\n                        digital_wiper.r_wa, digital_wiper.potentiometer.r_wa(pos_r_max)\n                    )\n                    self.assertEqual(\n                        digital_wiper.r_wb, digital_wiper.potentiometer.r_wb(pos_r_max)\n                    )\n                # Wrong value type\n                for resistance in [None, \"5.1\"]:\n                    with self.assertRaises(TypeError):\n                        digital_wiper.r_wa = resistance\n                    with self.assertRaises(TypeError):\n                        digital_wiper.r_wb = resistance", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/digital_wiper/test_digital_wiper_constructor_spi.py", "chunked_list": ["\"\"\" Tests for SpiDigitalWiper class constructor. \"\"\"\n\nimport unittest\n\ntry:\n    from src.BDPotentiometer import Potentiometer, SpiDigitalWiper\nexcept ModuleNotFoundError:\n    from BDPotentiometer import Potentiometer, SpiDigitalWiper\n\n\nclass TestSpiDigitalWiperConstructor(unittest.TestCase):\n    \"\"\"\n    Testing SpiDigitalWiper constructor.\n    \"\"\"\n\n    def setUp(self) -> None:\n        \"\"\"\n        Set up Unittest\n        \"\"\"\n        self.pot = Potentiometer(\n            r_ab=10e3, r_w=75, rheostat=False, parameters_locked=False\n        )\n        self.spi_digital_wiper = SpiDigitalWiper(\n            spi=None, potentiometer=self.pot, max_value=128, parameters_locked=False\n        )\n\n    def test_spi_digital_wiper(self):\n        \"\"\"\n        Test SpiDigitalWiper constructor (without SPI interface).\n        \"\"\"\n        digital_wiper = SpiDigitalWiper(\n            spi=None, potentiometer=self.pot, max_value=128, parameters_locked=False\n        )\n        self.assertEqual(digital_wiper.spi, None)\n        digital_wiper.spi = None\n        self.assertEqual(digital_wiper.spi, None)", "\n\nclass TestSpiDigitalWiperConstructor(unittest.TestCase):\n    \"\"\"\n    Testing SpiDigitalWiper constructor.\n    \"\"\"\n\n    def setUp(self) -> None:\n        \"\"\"\n        Set up Unittest\n        \"\"\"\n        self.pot = Potentiometer(\n            r_ab=10e3, r_w=75, rheostat=False, parameters_locked=False\n        )\n        self.spi_digital_wiper = SpiDigitalWiper(\n            spi=None, potentiometer=self.pot, max_value=128, parameters_locked=False\n        )\n\n    def test_spi_digital_wiper(self):\n        \"\"\"\n        Test SpiDigitalWiper constructor (without SPI interface).\n        \"\"\"\n        digital_wiper = SpiDigitalWiper(\n            spi=None, potentiometer=self.pot, max_value=128, parameters_locked=False\n        )\n        self.assertEqual(digital_wiper.spi, None)\n        digital_wiper.spi = None\n        self.assertEqual(digital_wiper.spi, None)", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/digital_wiper/test_digital_wiper_voltage_out.py", "chunked_list": ["\"\"\" Tests for DigitalWiper output voltage property. \"\"\"\n\nimport unittest\nimport numpy as np\n\ntry:\n    from src.BDPotentiometer import Potentiometer, DigitalWiper\nexcept ModuleNotFoundError:\n    from BDPotentiometer import Potentiometer, DigitalWiper\n", "\n\nclass TestDigitalWiperVoltageOut(unittest.TestCase):\n    \"\"\"\n    Testing DigitalWiper `voltage_out`.\n    \"\"\"\n\n    def test_voltage_out(self):\n        \"\"\"\n        Test output voltage property and methods.\n        \"\"\"\n        pot = Potentiometer(\n            r_ab=101e3, r_w=185, rheostat=False, parameters_locked=False\n        )\n        for locked in [True, False]:\n            for max_value in [1, 15, 33]:\n                digital_wiper = DigitalWiper(\n                    potentiometer=pot, max_value=max_value, parameters_locked=locked\n                )\n                digital_wiper.r_lim = 123.5\n                digital_wiper.r_load = 1e6\n                # Correct values (positive float numbers)\n                digital_wiper.voltage_in = 5\n                for voltage in np.linspace(0, 5, num=13, endpoint=True):\n                    digital_wiper.voltage_out = voltage\n                    np.testing.assert_allclose(\n                        digital_wiper.voltage_out,\n                        digital_wiper.potentiometer.voltage_out(\n                            digital_wiper.value_relative\n                        ),\n                    )\n                for voltage in np.linspace(-5, 0, num=13, endpoint=True):\n                    digital_wiper.voltage_out = voltage\n                    self.assertEqual(digital_wiper.voltage_out, 0)\n                digital_wiper.voltage_in = -5\n                for voltage in np.linspace(-5, 0, num=13, endpoint=True):\n                    digital_wiper.voltage_out = voltage\n                    np.testing.assert_allclose(\n                        digital_wiper.voltage_out,\n                        digital_wiper.potentiometer.voltage_out(\n                            digital_wiper.value_relative\n                        ),\n                    )\n                for voltage in np.linspace(0, 5, num=13, endpoint=True):\n                    digital_wiper.voltage_out = voltage\n                    self.assertEqual(digital_wiper.voltage_out, 0)\n                digital_wiper.voltage_in = 0\n                for voltage in np.linspace(-5, 5, num=13, endpoint=True):\n                    digital_wiper.voltage_out = voltage\n                    self.assertEqual(digital_wiper.voltage_out, 0)\n                digital_wiper.r_load = 0\n                digital_wiper.voltage_in = 5\n                for voltage in np.linspace(-5, 5, num=13, endpoint=True):\n                    digital_wiper.voltage_out = voltage\n                    self.assertEqual(digital_wiper.voltage_out, 0)\n                # Wrong type\n                for voltage in [None, \"100.2\"]:\n                    with self.assertRaises(TypeError):\n                        digital_wiper.voltage_out = voltage", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/digital_wiper/test_digital_wiper_min_max_value.py", "chunked_list": ["\"\"\" Tests for DigitalWiper min max value properties. \"\"\"\n\nimport unittest\n\ntry:\n    from src.BDPotentiometer import Potentiometer, DigitalWiper\nexcept ModuleNotFoundError:\n    from BDPotentiometer import Potentiometer, DigitalWiper\n\n\nclass TestDigitalWiperMinMaxValue(unittest.TestCase):\n    \"\"\"\n    Testing DigitalWiper `min_value` and `max_value` properties.\n    \"\"\"\n\n    def test_min_value(self):\n        \"\"\"\n        Testing `min_value` property.\n        Should always be zero and can not be changed&\n        \"\"\"\n        pot = Potentiometer(r_ab=50e3, r_w=200, rheostat=False, parameters_locked=False)\n        for locked in [True, False]:\n            for max_value in [1, 32, 64, 256]:\n                digital_wiper = DigitalWiper(\n                    potentiometer=pot, max_value=max_value, parameters_locked=locked\n                )\n                self.assertEqual(digital_wiper.min_value, 0)\n                for min_value_ in [None, -1, 1, \"1\", \"0\", 0]:\n                    with self.assertRaises(AttributeError):\n                        digital_wiper.min_value = min_value_\n\n    def test_max_value(self):\n        \"\"\"\n        Testing `max_value` property.\n        In contrast with `min_value`, `max_value` can be altered unless wiper is locked.\n        `max_value` must be positive int number.\n        \"\"\"\n        pot = Potentiometer(\n            r_ab=100e3, r_w=175, rheostat=False, parameters_locked=False\n        )\n        for locked in [True, False]:\n            for max_value in [1, 16, 32, 2048]:\n                digital_wiper = DigitalWiper(\n                    potentiometer=pot, max_value=max_value, parameters_locked=locked\n                )\n                self.assertEqual(digital_wiper.max_value, max_value)\n                # Correct values\n                for max_value_new in [1, 10, 128, 1024, 128.0]:\n                    digital_wiper.max_value = max_value_new\n                    # Check that parameters_locked locks the max_value\n                    if not digital_wiper.parameters_locked:\n                        self.assertEqual(digital_wiper.max_value, max_value_new)\n                    else:\n                        self.assertEqual(digital_wiper.max_value, max_value)\n                # Wrong value\n                for max_value_ in [0, -1, -10, 128.5]:\n                    with self.assertRaises(ValueError):\n                        digital_wiper.max_value = max_value_\n                # Wrong type\n                for max_value_ in [None, \"1\"]:\n                    with self.assertRaises(TypeError):\n                        digital_wiper.max_value = max_value_\n                # Check that value did not change\n                if not digital_wiper.parameters_locked:\n                    self.assertEqual(digital_wiper.max_value, max_value_new)\n                else:\n                    self.assertEqual(digital_wiper.max_value, max_value)", "\n\nclass TestDigitalWiperMinMaxValue(unittest.TestCase):\n    \"\"\"\n    Testing DigitalWiper `min_value` and `max_value` properties.\n    \"\"\"\n\n    def test_min_value(self):\n        \"\"\"\n        Testing `min_value` property.\n        Should always be zero and can not be changed&\n        \"\"\"\n        pot = Potentiometer(r_ab=50e3, r_w=200, rheostat=False, parameters_locked=False)\n        for locked in [True, False]:\n            for max_value in [1, 32, 64, 256]:\n                digital_wiper = DigitalWiper(\n                    potentiometer=pot, max_value=max_value, parameters_locked=locked\n                )\n                self.assertEqual(digital_wiper.min_value, 0)\n                for min_value_ in [None, -1, 1, \"1\", \"0\", 0]:\n                    with self.assertRaises(AttributeError):\n                        digital_wiper.min_value = min_value_\n\n    def test_max_value(self):\n        \"\"\"\n        Testing `max_value` property.\n        In contrast with `min_value`, `max_value` can be altered unless wiper is locked.\n        `max_value` must be positive int number.\n        \"\"\"\n        pot = Potentiometer(\n            r_ab=100e3, r_w=175, rheostat=False, parameters_locked=False\n        )\n        for locked in [True, False]:\n            for max_value in [1, 16, 32, 2048]:\n                digital_wiper = DigitalWiper(\n                    potentiometer=pot, max_value=max_value, parameters_locked=locked\n                )\n                self.assertEqual(digital_wiper.max_value, max_value)\n                # Correct values\n                for max_value_new in [1, 10, 128, 1024, 128.0]:\n                    digital_wiper.max_value = max_value_new\n                    # Check that parameters_locked locks the max_value\n                    if not digital_wiper.parameters_locked:\n                        self.assertEqual(digital_wiper.max_value, max_value_new)\n                    else:\n                        self.assertEqual(digital_wiper.max_value, max_value)\n                # Wrong value\n                for max_value_ in [0, -1, -10, 128.5]:\n                    with self.assertRaises(ValueError):\n                        digital_wiper.max_value = max_value_\n                # Wrong type\n                for max_value_ in [None, \"1\"]:\n                    with self.assertRaises(TypeError):\n                        digital_wiper.max_value = max_value_\n                # Check that value did not change\n                if not digital_wiper.parameters_locked:\n                    self.assertEqual(digital_wiper.max_value, max_value_new)\n                else:\n                    self.assertEqual(digital_wiper.max_value, max_value)", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/digital_wiper/test_digital_wiper_deep_copy_spi.py", "chunked_list": ["\"\"\" Tests for DigitalWiper class deep copy. \"\"\"\n\nfrom copy import deepcopy\nimport unittest\n\ntry:\n    from src.BDPotentiometer import Potentiometer, SpiDigitalWiper\nexcept ModuleNotFoundError:\n    from BDPotentiometer import Potentiometer, SpiDigitalWiper\n", "\n\nclass TestSpiDigitalWiperDeepCopy(unittest.TestCase):\n    \"\"\"\n    Testing DigitalWiper deep copy.\n    \"\"\"\n\n    def setUp(self) -> None:\n        \"\"\"\n        Set up Unittest\n        \"\"\"\n        self.pot = Potentiometer(\n            r_ab=10e3, r_w=75, rheostat=False, parameters_locked=False\n        )\n        self.spi_digital_wiper = SpiDigitalWiper(\n            spi=None, potentiometer=self.pot, max_value=128, parameters_locked=False\n        )\n\n    def test_spi_deepcopy(self):\n        \"\"\"\n        Test deepcopy for SpiDigitalWiper.\n        \"\"\"\n\n        self.spi_digital_wiper.r_lim = 200\n        self.spi_digital_wiper.r_load = 1e100\n        self.spi_digital_wiper.voltage_in = 5\n        dw_copy = deepcopy(self.spi_digital_wiper)\n        self.assertIsInstance(dw_copy, SpiDigitalWiper)\n        self.assertNotEqual(dw_copy, self.spi_digital_wiper)\n        self.assertNotEqual(dw_copy.potentiometer, self.spi_digital_wiper.potentiometer)\n        self.assertEqual(dw_copy.min_value, self.spi_digital_wiper.min_value)\n        self.assertEqual(dw_copy.max_value, self.spi_digital_wiper.max_value)\n        self.assertEqual(\n            dw_copy.potentiometer.r_ab, self.spi_digital_wiper.potentiometer.r_ab\n        )\n        self.assertEqual(\n            dw_copy.potentiometer.r_w, self.spi_digital_wiper.potentiometer.r_w\n        )\n        self.assertEqual(\n            dw_copy.potentiometer.r_lim, self.spi_digital_wiper.potentiometer.r_lim\n        )\n        self.assertEqual(\n            dw_copy.potentiometer.r_load, self.spi_digital_wiper.potentiometer.r_load\n        )\n        self.assertEqual(\n            dw_copy.potentiometer.voltage_in,\n            self.spi_digital_wiper.potentiometer.voltage_in,\n        )\n        self.assertEqual(dw_copy.spi, self.spi_digital_wiper.spi)", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/digital_wiper/test_digital_wiper_voltage_in.py", "chunked_list": ["\"\"\" Tests for DigitalWiper input voltage property. \"\"\"\n\nimport unittest\nimport numpy as np\n\ntry:\n    from src.BDPotentiometer import Potentiometer, DigitalWiper\nexcept ModuleNotFoundError:\n    from BDPotentiometer import Potentiometer, DigitalWiper\n", "\n\nclass TestDigitalWiperVoltageIn(unittest.TestCase):\n    \"\"\"\n    Testing DigitalWiper `voltage_in`.\n    \"\"\"\n\n    def test_voltage_in(self):\n        \"\"\"\n        Test input voltage property and methods.\n        \"\"\"\n        pot = Potentiometer(\n            r_ab=104e3, r_w=275, rheostat=False, parameters_locked=False\n        )\n        for locked in [True, False]:\n            for max_value in [1, 11, 37]:\n                digital_wiper = DigitalWiper(\n                    potentiometer=pot, max_value=max_value, parameters_locked=locked\n                )\n                # Correct values (positive float numbers)\n                for voltage in np.linspace(-51, 51, num=107, endpoint=True):\n                    digital_wiper.voltage_in = voltage\n                    self.assertEqual(digital_wiper.voltage_in, voltage)\n                    self.assertEqual(\n                        digital_wiper.voltage_in, digital_wiper.potentiometer.voltage_in\n                    )\n                digital_wiper.voltage_in = 0\n                self.assertEqual(digital_wiper.voltage_in, 0)\n                self.assertEqual(\n                    digital_wiper.voltage_in, digital_wiper.potentiometer.voltage_in\n                )\n                # Wrong type\n                for voltage in [None, \"100.2\"]:\n                    with self.assertRaises(TypeError):\n                        digital_wiper.voltage_in = voltage", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/digital_wiper/test_digital_wiper_deep_copy.py", "chunked_list": ["\"\"\" Tests for DigitalWiper class deep copy. \"\"\"\n\nfrom copy import deepcopy\nimport unittest\n\ntry:\n    from src.BDPotentiometer import Potentiometer, DigitalWiper\nexcept ModuleNotFoundError:\n    from BDPotentiometer import Potentiometer, DigitalWiper\n", "\n\nclass TestDigitalWiperDeepCopy(unittest.TestCase):\n    \"\"\"\n    Testing DigitalWiper deep copy.\n    \"\"\"\n\n    def setUp(self) -> None:\n        \"\"\"\n        Set up Unittest\n        \"\"\"\n        self.pot = Potentiometer(\n            r_ab=10e3, r_w=75, rheostat=False, parameters_locked=False\n        )\n        self.digital_wiper = DigitalWiper(\n            potentiometer=self.pot, max_value=128, parameters_locked=False\n        )\n        self.digital_wiper_locked = DigitalWiper(\n            potentiometer=self.pot, max_value=128, parameters_locked=True\n        )\n\n    def test_deepcopy(self):\n        \"\"\"\n        Test deepcopy.\n        \"\"\"\n        self.digital_wiper.r_lim = 200\n        self.digital_wiper.r_load = 1e100\n        self.digital_wiper.voltage_in = 5\n        dw_copy = deepcopy(self.digital_wiper)\n        self.assertIsInstance(dw_copy, DigitalWiper)\n        self.assertNotEqual(dw_copy, self.digital_wiper)\n        self.assertNotEqual(dw_copy.potentiometer, self.digital_wiper.potentiometer)\n        self.assertEqual(dw_copy.min_value, self.digital_wiper.min_value)\n        self.assertEqual(dw_copy.max_value, self.digital_wiper.max_value)\n        self.assertEqual(\n            dw_copy.potentiometer.r_ab, self.digital_wiper.potentiometer.r_ab\n        )\n        self.assertEqual(\n            dw_copy.potentiometer.r_w, self.digital_wiper.potentiometer.r_w\n        )\n        self.assertEqual(\n            dw_copy.potentiometer.r_lim, self.digital_wiper.potentiometer.r_lim\n        )\n        self.assertEqual(\n            dw_copy.potentiometer.r_load, self.digital_wiper.potentiometer.r_load\n        )\n        self.assertEqual(\n            dw_copy.potentiometer.voltage_in,\n            self.digital_wiper.potentiometer.voltage_in,\n        )", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "examples/mcp4231.py", "chunked_list": ["\"\"\" Example of MCP4231 usage \"\"\"\n\nfrom BDPotentiometer.mcp4xxx import MCP4231\n\n# Create potentiometer with total resistance 10 kOhm\nmy_pot = MCP4231(r_ab=10e3, device=0)\n\n# Label the two available channels with meaningful names\nmy_pot.set_channel_label(0, \"V_CTRL\")\nmy_pot.set_channel_label(1, \"AMPL\")", "my_pot.set_channel_label(0, \"V_CTRL\")\nmy_pot.set_channel_label(1, \"AMPL\")\n\n# Set current limiting resistor value for V_CTRL channel\nmy_pot.set_r_lim(\"V_CTRL\", 1.1e3)\n# The properties are also available\nmy_pot.r_lim = (1.1e3, 0)\nprint(f\"Current limiting resistors: {my_pot.r_lim}\")\n\n# Set load resistor value for V_CTRL channel", "\n# Set load resistor value for V_CTRL channel\nmy_pot.set_r_load(\"V_CTRL\", 50e3)\nmy_pot.r_load = (100e3, 1e3)\nprint(f\"Load resistors: {my_pot.r_load}\")\n\n# Set input voltage\nmy_pot.set_voltage_in(\"V_CTRL\", 5.0)\nmy_pot.voltage_in = (5.0, 0.0)\nprint(f\"Input voltage: {my_pot.voltage_in}\")", "my_pot.voltage_in = (5.0, 0.0)\nprint(f\"Input voltage: {my_pot.voltage_in}\")\n\n# All Done! Now you can control the pot\nmy_pot.set_voltage_out(\"V_CTRL\", 3.3)\nmy_pot.voltage_out = (3.7, 0)\nprint(f\"Output voltage: {my_pot.voltage_out}\")\n\n# You can also control the resistance\nmy_pot.set_r_wb(\"AMPL\", 1e3)", "# You can also control the resistance\nmy_pot.set_r_wb(\"AMPL\", 1e3)\n# OR\nmy_pot.set_r_wa(\"AMPL\", 9e3)\n\n# You can also set pot's winder position to exact value\nmy_pot.set_value(\"AMPL\", 64)\nprint(f\"Winder position for AMPL channel is {my_pot.get_value('AMPL')}\")\nprint(f\"Winder position for all channels: {my_pot.value}\")\n", "print(f\"Winder position for all channels: {my_pot.value}\")\n"]}
{"filename": "docs/source/conf.py", "chunked_list": ["# Configuration file for the Sphinx documentation builder.\n\n# pylint: skip-file\n\n# -- Project information\n\nproject = \"BDPotentiometer\"\ncopyright = \"2023, Anton Bondarenko\"\nauthor = \"Anton Bondarenko\"\n", "author = \"Anton Bondarenko\"\n\nrelease = \"0.0.2\"\nversion = \"0.0.2\"\n\n# -- General configuration\n\nextensions = [\n    \"sphinx.ext.duration\",\n    \"sphinx.ext.doctest\",", "    \"sphinx.ext.duration\",\n    \"sphinx.ext.doctest\",\n    \"sphinx.ext.autodoc\",\n    \"sphinx.ext.autosummary\",\n    \"sphinx.ext.intersphinx\",\n]\n\nintersphinx_mapping = {\n    \"python\": (\"https://docs.python.org/3/\", None),\n    \"sphinx\": (\"https://www.sphinx-doc.org/en/master/\", None),", "    \"python\": (\"https://docs.python.org/3/\", None),\n    \"sphinx\": (\"https://www.sphinx-doc.org/en/master/\", None),\n}\nintersphinx_disabled_domains = [\"std\"]\n\ntemplates_path = [\"_templates\"]\n\n# -- Options for HTML output\n\nhtml_theme = \"sphinx_rtd_theme\"", "\nhtml_theme = \"sphinx_rtd_theme\"\n\n# -- Options for EPUB output\nepub_show_urls = \"footnote\"\n"]}
{"filename": "src/BDPotentiometer/__helpers.py", "chunked_list": ["\"\"\"This module contains internal helper functions and not supposed to be used outside.\"\"\"\n\nfrom numbers import Real, Integral\nfrom math import isnan\nfrom typing import Union, Callable\n\n\ndef check_number(num: Union[float, int, Real]) -> Union[float, int]:\n    \"\"\"\n    Checks if argument is a real number.\n    check_number does not allow argument to be `+inf` or `-inf`, or `NaN`.\n    Special float numbers `+0.0` and `-0.0` will be converted to just 0.0\n\n    :param num: variable to check.\n    :return: Unchanged `num` as float or int or raises ValueError if num is not a real number.\n    \"\"\"\n    if not isinstance(num, Real):\n        raise TypeError(f\"Expected integer or float number, got {type(num)}\")\n    if isinstance(num, Integral):\n        return int(num)\n    if num in [float(\"inf\"), float(\"-inf\")]:\n        raise ValueError(f\"Expected integer or float number, got {num}\")\n    if isnan(num):\n        raise ValueError(\"Expected integer or float number, not NaN\")\n    if num == 0:\n        return 0.0\n    return float(num)", "\n\ndef check_integer(num: Union[float, int, Real]) -> int:\n    \"\"\"\n    Checks if `num` is an integer and converts it to int, otherwise raises ValueError.\n\n    :param num: Number (either int or float) to be checked.\n    :return: int representation of `num` or rises ValueError.\n    \"\"\"\n    num = check_number(num)\n    if isinstance(num, float):\n        if not num.is_integer():\n            raise ValueError(\"Argument should be integer number\")\n    return int(num)", "\n\ndef check_not_negative(num: Union[float, int]) -> Union[float, int]:\n    \"\"\"\n    Checks if `num` is a not negative number, otherwise rises ValueError.\n\n    :param num: Either float or int number.\n    :return: `num` if it is not negative or rises ValueError.\n    \"\"\"\n    num = check_number(num)\n    if num < 0:\n        raise ValueError(\"Argument should be not negative number\")\n    return num", "\n\ndef check_positive(num: Union[float, int]) -> Union[float, int]:\n    \"\"\"\n    Checks if `num` is a positive number, otherwise rises ValueError.\n\n    :param num: Either float or int number.\n    :return: `num` if it is positive or rises ValueError.\n    \"\"\"\n    num = check_number(num)\n    if num <= 0:\n        raise ValueError(\"Argument should be a positive number\")\n    return num", "\n\ndef clamp(\n    value: Union[float, int], min_value: Union[float, int], max_value: Union[float, int]\n) -> Union[float, int]:\n    \"\"\"\n    Clamp `value` to given range between `min_value` and `max_value`.\n\n    :param value: Either float or int number to be coerced.\n    :param min_value: Lower coerce range boundary.\n    :param max_value: Upper coerce range boundary.\n    :return: Value coerced to given range.\n    \"\"\"\n    value = check_number(value)\n    min_value = check_number(min_value)\n    max_value = check_number(max_value)\n    if min_value > max_value:\n        min_value, max_value = max_value, min_value\n    if value < min_value:\n        if isinstance(value, float):\n            return float(min_value)\n        return min_value\n    if value > max_value:\n        if isinstance(value, float):\n            return float(max_value)\n        return max_value\n    return value", "\n\ndef build_tuple(\n    value: Union[float, int, tuple[float, ...], list[float, ...]],\n    num: Union[int, float],\n    func: Union[Callable, None] = None,\n) -> tuple[float, ...]:\n    \"\"\"\n    Builds tuple of floats of given length by applying a callable `func` to value.\n    If `value` is an iterable (either list or tuple) its length must be equal to `num`.\n    The `func` will be applied to each element of the iterable.\n    If `value` is a number the resulting tuple of length `num` will be built of same `func(value)`\n    elements converted to float.\n    If `func` is None the `value` will enter resulting tuple unchanged.\n\n    :param value: Iterable (either list or tuple) or a number.\n    :param num: A number of elements in a tuple.\n    :param func: Callable to be applied to `value` or None for identity function.\n    :return: A tuple of floats of length `num` produced by application of `func` to `value`.\n    \"\"\"\n\n    def identity(val: float) -> float:\n        return val\n\n    if not isinstance(value, (float, int, tuple, list)):\n        raise TypeError(\"Argument should be a number or list or tuple of numbers\")\n    num = check_integer(check_positive(num))\n    if func is not None:\n        if not callable(func):\n            raise TypeError(\"function must be callable or None\")\n    else:\n        func = identity\n\n    if isinstance(value, (list, tuple)):\n        if len(value) != num:\n            raise ValueError(f\"A tuple or list of length {num} expected\")\n        return tuple(float(func(check_number(value_i))) for value_i in value)\n    value = check_number(value)\n    return tuple(float(func(value)) for _ in range(num))", "\n\ndef adjust_tuple(\n    value: Union[tuple[float, ...], list[float, ...]], num: int, default_value: float\n) -> tuple[float, ...]:\n    \"\"\"\n    Adjusts tuple or list of floats to a given length `num` and returns a tuple.\n    if `num` is less than initial length of the tuple it will be truncated to first `num` elements,\n    otherwise it will be appended using `default_value` parameter.\n\n    :param value: Initial iterable (either tuple or list) of float values.\n    :param num: Final length of the tuple.\n    :param default_value: Default value to populate the tuple if it needs to be grown.\n    :return: A tuple of floats of length `num`.\n    \"\"\"\n    if not isinstance(value, (tuple, list)):\n        raise TypeError(\"Argument should be a list or a tuple of numbers\")\n    num = check_integer(check_positive(num))\n    default_value = float(check_number(default_value))\n    if len(value) < num:\n        return tuple(\n            [float(check_number(value_i)) for value_i in value]\n            + [default_value] * (num - len(value))\n        )\n    if len(value) > num:\n        return tuple(float(check_number(value[i])) for i in range(num))\n    return tuple(float(check_number(value_i)) for value_i in value)", ""]}
{"filename": "src/BDPotentiometer/digital_wiper.py", "chunked_list": ["\"\"\" Module contains basic digital wiper class implementation \"\"\"\n\nfrom copy import deepcopy\nfrom typing import Union\nfrom gpiozero import SPI\n\nfrom .potentiometer import Potentiometer\nfrom .__helpers import check_integer, check_positive, check_not_negative, clamp\n\n\nclass DigitalWiper:\n    \"\"\"\n    Generic digital wiper class.\n    Digital wiper change position by discrete movement between 0 and `max_value`.\n    Property `parameters_locked` is used to disable change of `max_value`\n    parameter after object is created, only wiper position change is allowed.\n    \"\"\"\n\n    # pylint: disable=too-many-instance-attributes\n\n    def __init__(\n        self,\n        potentiometer: Potentiometer,\n        max_value: int = 128,\n        parameters_locked: bool = False,\n    ) -> None:\n        self.__parameters_locked: bool = bool(parameters_locked)\n        if isinstance(potentiometer, Potentiometer):\n            self.__potentiometer: Potentiometer = potentiometer\n        else:\n            raise TypeError(\n                f\"Expected an instance of Potentiometer class, got {type(potentiometer)}\"\n            )\n        self.__channel: int = 0\n        self.__max_value: int = check_integer(check_positive(max_value))\n        self.__value: int = 0\n        self.read()\n\n    @property\n    def parameters_locked(self) -> bool:\n        \"\"\"\n        Check if parameters of the wiper are locked.\n\n        :return: True if locked and False otherwise\n        \"\"\"\n        return self.__parameters_locked\n\n    @property\n    def potentiometer(self) -> Potentiometer:\n        \"\"\"\n        Access Potentiometer instance.\n        :return: Potentiometer\n        \"\"\"\n        return self.__potentiometer\n\n    @property\n    def channel(self) -> int:\n        \"\"\"Wiper channel number\"\"\"\n        return self.__channel\n\n    @channel.setter\n    def channel(self, channel: int) -> None:\n        self.__channel = check_integer(check_not_negative(channel))\n\n    @property\n    def min_value(self) -> int:\n        \"\"\"\n        Returns minimal wiper position, which is always zero.\n        :return: Always return 0.\n        \"\"\"\n        return 0\n\n    @property\n    def max_value(self) -> int:\n        \"\"\"\n        Returns device max wiper position value.\n\n        :return: Max wiper position value as int.\n        \"\"\"\n        return self.__max_value\n\n    @max_value.setter\n    def max_value(self, max_value: int) -> None:\n        new_value = check_integer(check_positive(max_value))\n        if not self.parameters_locked:\n            self.__max_value = new_value\n            self.value = self.__value\n\n    def _set_value(self, value: int) -> int:\n        \"\"\"\n        Set given wiper position to `value`.\n\n        :param value: Requested value as int.\n        :return: Value actually set as int.\n        \"\"\"\n        value = int(round(clamp(value, 0, self.max_value)))\n        return value\n\n    def _read_value(self) -> int:\n        \"\"\"\n        Read value of wiper position.\n\n        :return: Wiper position value (int).\n        \"\"\"\n        return self.__value\n\n    def read(self) -> None:\n        \"\"\"\n        Read wiper position into value property.\n        \"\"\"\n        self.__value = self._read_value()\n\n    @property\n    def value(self) -> int:\n        \"\"\"\n        Current wiper position.\n\n        :return: Wiper position value (int).\n        \"\"\"\n        self.read()\n        return self.__value\n\n    @value.setter\n    def value(self, value: int) -> None:\n        value = clamp(check_integer(value), 0, self.max_value)\n        data = self._set_value(value)\n        self.__value = data\n\n    @property\n    def value_relative(self) -> float:\n        \"\"\"\n        Relative wiper position value in the range 0..1.\n        :return: Relative wiper position (float)\n        \"\"\"\n        return self.value / self.max_value\n\n    @value_relative.setter\n    def value_relative(self, value: float) -> None:\n        value = clamp(value, 0, 1)\n        value_int = int(round(value * self.max_value))\n        self.value = value_int\n\n    @property\n    def r_wb(self) -> float:\n        \"\"\"\n        Calculates resistance between terminals B and W.\n\n        :return: Resistance between terminals B and W (float).\n        \"\"\"\n        return self.potentiometer.r_wb(self.value_relative)\n\n    @r_wb.setter\n    def r_wb(self, resistance: float) -> None:\n        self.value = int(\n            round(self.potentiometer.r_wb_to_position(resistance) * self.max_value)\n        )\n\n    @property\n    def r_wa(self) -> float:\n        \"\"\"\n        Calculates resistance between terminals A and W.\n\n        :return: Resistance between terminals A and W (float).\n        \"\"\"\n        return self.potentiometer.r_wa(self.value_relative)\n\n    @r_wa.setter\n    def r_wa(self, resistance: float) -> None:\n        self.value = int(\n            round(self.potentiometer.r_wa_to_position(resistance) * self.max_value)\n        )\n\n    @property\n    def r_lim(self) -> float:\n        \"\"\"\n        Potentiometer current limiting resistor.\n        \"\"\"\n        return self.potentiometer.r_lim\n\n    @r_lim.setter\n    def r_lim(self, r_lim: float) -> None:\n        self.potentiometer.r_lim = r_lim\n\n    @property\n    def r_load(self) -> float:\n        \"\"\"\n        Potentiometer load resistor.\n        \"\"\"\n        return self.potentiometer.r_load\n\n    @r_load.setter\n    def r_load(self, r_load: float) -> None:\n        self.potentiometer.r_load = r_load\n\n    @property\n    def voltage_in(self) -> float:\n        \"\"\"\n        Device input Voltage.\n\n        :return: Input voltage (float).\n        \"\"\"\n        return self.potentiometer.voltage_in\n\n    @voltage_in.setter\n    def voltage_in(self, voltage: float) -> None:\n        self.potentiometer.voltage_in = voltage\n\n    @property\n    def voltage_out(self) -> float:\n        \"\"\"\n        Calculates output voltage for given wiper position.\n\n        :return: Output voltage (float).\n        \"\"\"\n        return self.potentiometer.voltage_out(self.value / self.max_value)\n\n    @voltage_out.setter\n    def voltage_out(self, voltage: float) -> None:\n        self.value = int(\n            round(\n                self.potentiometer.voltage_out_to_wiper_position(voltage)\n                * self.max_value\n            )\n        )\n\n    def __deepcopy__(self, memo):\n        cls = self.__class__\n        result = cls.__new__(cls)\n        memo[id(self)] = result\n        for key, value in self.__dict__.items():\n            setattr(result, key, deepcopy(value, memo))\n        return result", "\n\nclass DigitalWiper:\n    \"\"\"\n    Generic digital wiper class.\n    Digital wiper change position by discrete movement between 0 and `max_value`.\n    Property `parameters_locked` is used to disable change of `max_value`\n    parameter after object is created, only wiper position change is allowed.\n    \"\"\"\n\n    # pylint: disable=too-many-instance-attributes\n\n    def __init__(\n        self,\n        potentiometer: Potentiometer,\n        max_value: int = 128,\n        parameters_locked: bool = False,\n    ) -> None:\n        self.__parameters_locked: bool = bool(parameters_locked)\n        if isinstance(potentiometer, Potentiometer):\n            self.__potentiometer: Potentiometer = potentiometer\n        else:\n            raise TypeError(\n                f\"Expected an instance of Potentiometer class, got {type(potentiometer)}\"\n            )\n        self.__channel: int = 0\n        self.__max_value: int = check_integer(check_positive(max_value))\n        self.__value: int = 0\n        self.read()\n\n    @property\n    def parameters_locked(self) -> bool:\n        \"\"\"\n        Check if parameters of the wiper are locked.\n\n        :return: True if locked and False otherwise\n        \"\"\"\n        return self.__parameters_locked\n\n    @property\n    def potentiometer(self) -> Potentiometer:\n        \"\"\"\n        Access Potentiometer instance.\n        :return: Potentiometer\n        \"\"\"\n        return self.__potentiometer\n\n    @property\n    def channel(self) -> int:\n        \"\"\"Wiper channel number\"\"\"\n        return self.__channel\n\n    @channel.setter\n    def channel(self, channel: int) -> None:\n        self.__channel = check_integer(check_not_negative(channel))\n\n    @property\n    def min_value(self) -> int:\n        \"\"\"\n        Returns minimal wiper position, which is always zero.\n        :return: Always return 0.\n        \"\"\"\n        return 0\n\n    @property\n    def max_value(self) -> int:\n        \"\"\"\n        Returns device max wiper position value.\n\n        :return: Max wiper position value as int.\n        \"\"\"\n        return self.__max_value\n\n    @max_value.setter\n    def max_value(self, max_value: int) -> None:\n        new_value = check_integer(check_positive(max_value))\n        if not self.parameters_locked:\n            self.__max_value = new_value\n            self.value = self.__value\n\n    def _set_value(self, value: int) -> int:\n        \"\"\"\n        Set given wiper position to `value`.\n\n        :param value: Requested value as int.\n        :return: Value actually set as int.\n        \"\"\"\n        value = int(round(clamp(value, 0, self.max_value)))\n        return value\n\n    def _read_value(self) -> int:\n        \"\"\"\n        Read value of wiper position.\n\n        :return: Wiper position value (int).\n        \"\"\"\n        return self.__value\n\n    def read(self) -> None:\n        \"\"\"\n        Read wiper position into value property.\n        \"\"\"\n        self.__value = self._read_value()\n\n    @property\n    def value(self) -> int:\n        \"\"\"\n        Current wiper position.\n\n        :return: Wiper position value (int).\n        \"\"\"\n        self.read()\n        return self.__value\n\n    @value.setter\n    def value(self, value: int) -> None:\n        value = clamp(check_integer(value), 0, self.max_value)\n        data = self._set_value(value)\n        self.__value = data\n\n    @property\n    def value_relative(self) -> float:\n        \"\"\"\n        Relative wiper position value in the range 0..1.\n        :return: Relative wiper position (float)\n        \"\"\"\n        return self.value / self.max_value\n\n    @value_relative.setter\n    def value_relative(self, value: float) -> None:\n        value = clamp(value, 0, 1)\n        value_int = int(round(value * self.max_value))\n        self.value = value_int\n\n    @property\n    def r_wb(self) -> float:\n        \"\"\"\n        Calculates resistance between terminals B and W.\n\n        :return: Resistance between terminals B and W (float).\n        \"\"\"\n        return self.potentiometer.r_wb(self.value_relative)\n\n    @r_wb.setter\n    def r_wb(self, resistance: float) -> None:\n        self.value = int(\n            round(self.potentiometer.r_wb_to_position(resistance) * self.max_value)\n        )\n\n    @property\n    def r_wa(self) -> float:\n        \"\"\"\n        Calculates resistance between terminals A and W.\n\n        :return: Resistance between terminals A and W (float).\n        \"\"\"\n        return self.potentiometer.r_wa(self.value_relative)\n\n    @r_wa.setter\n    def r_wa(self, resistance: float) -> None:\n        self.value = int(\n            round(self.potentiometer.r_wa_to_position(resistance) * self.max_value)\n        )\n\n    @property\n    def r_lim(self) -> float:\n        \"\"\"\n        Potentiometer current limiting resistor.\n        \"\"\"\n        return self.potentiometer.r_lim\n\n    @r_lim.setter\n    def r_lim(self, r_lim: float) -> None:\n        self.potentiometer.r_lim = r_lim\n\n    @property\n    def r_load(self) -> float:\n        \"\"\"\n        Potentiometer load resistor.\n        \"\"\"\n        return self.potentiometer.r_load\n\n    @r_load.setter\n    def r_load(self, r_load: float) -> None:\n        self.potentiometer.r_load = r_load\n\n    @property\n    def voltage_in(self) -> float:\n        \"\"\"\n        Device input Voltage.\n\n        :return: Input voltage (float).\n        \"\"\"\n        return self.potentiometer.voltage_in\n\n    @voltage_in.setter\n    def voltage_in(self, voltage: float) -> None:\n        self.potentiometer.voltage_in = voltage\n\n    @property\n    def voltage_out(self) -> float:\n        \"\"\"\n        Calculates output voltage for given wiper position.\n\n        :return: Output voltage (float).\n        \"\"\"\n        return self.potentiometer.voltage_out(self.value / self.max_value)\n\n    @voltage_out.setter\n    def voltage_out(self, voltage: float) -> None:\n        self.value = int(\n            round(\n                self.potentiometer.voltage_out_to_wiper_position(voltage)\n                * self.max_value\n            )\n        )\n\n    def __deepcopy__(self, memo):\n        cls = self.__class__\n        result = cls.__new__(cls)\n        memo[id(self)] = result\n        for key, value in self.__dict__.items():\n            setattr(result, key, deepcopy(value, memo))\n        return result", "\n\nclass SpiDigitalWiper(DigitalWiper):\n    \"\"\"Digital wiper with SPI interface\"\"\"\n\n    def __init__(\n        self,\n        potentiometer: Potentiometer,\n        spi: Union[SPI, None] = None,\n        max_value: int = 128,\n        parameters_locked: bool = False,\n    ):\n        self.__spi = None\n        if isinstance(spi, SPI):\n            self.__spi = spi\n        super().__init__(\n            potentiometer=potentiometer,\n            max_value=max_value,\n            parameters_locked=parameters_locked,\n        )\n\n    @property\n    def spi(self) -> Union[SPI, None]:\n        \"\"\"\n        Get SPI interface\n        :return: SPI interface (gpiozero.SPI)\n        \"\"\"\n        return self.__spi\n\n    @spi.setter\n    def spi(self, spi: Union[SPI, None]) -> None:\n        if isinstance(spi, SPI):\n            self.__spi = spi\n        self.__spi = None\n\n    def __deepcopy__(self, memo):\n        cls = self.__class__\n        result = cls.__new__(cls)\n        memo[id(self)] = result\n        for key, value in self.__dict__.items():\n            if \"_spi\" in key:\n                setattr(result, key, value)\n                continue\n            setattr(result, key, deepcopy(value, memo))\n        return result", ""]}
{"filename": "src/BDPotentiometer/potentiometer.py", "chunked_list": ["\"\"\" Basic potentiometer device implementation \"\"\"\n\nimport math as m\n\nfrom .__helpers import clamp, check_number, check_positive, check_not_negative\n\n\nclass Potentiometer:\n    \"\"\"\n    Represents a general potentiometer with 3 terminals A, B, and W.\n\n    A     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     B\n     o\u2500\u2500\u2500\u2500\u2524Potentiometer\u251c\u2500\u2500\u2500\u2500\u2500o\n          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           1 <\u2500\u2500 \u2502 \u2500\u2500> 0\n                 o W\n    Total resistance is `r_ab`, wiper resistance is `r_w`\n    If device is `locked` parameters `r_ab` and `r_w` are read-only.\n\n    Wiper moves from B to A changing position from 0 to 1.\n    Resistance between terminals WA and WB can be calculated using `r_wa` and `r_wb` functions.\n    Reverse functions `r_wa_to_position` and `r_wb_to_position` for calculation of wiper position\n    given r_wa or r_wb are also available.\n\n    Parameter `rheostat` turns potentiometer to rheostat with terminal A floating not connected,\n    and two terminals B and W available\n\n    A     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     B\n     x\u2500\u2500\u2500\u2500\u2524   Rheostat  \u251c\u2500\u2500\u2500\u2500\u2500o\n          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           1 <\u2500\u2500 \u2502 \u2500\u2500> 0\n                 o W\n\n    Potentiometer can be connected like shown bin the sketch below\n                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 A     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     B\n      (V_in) o\u2500\u2500\u2500\u2524 R_lim  \u251c\u2500\u2500o\u2500\u2500\u2500\u2500\u2524   POT    \u251c\u2500\u2500\u2500\u2500\u2500o\u2500\u2500\u2500\u2500\u2510\n                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2518          \u2502\n                                  1 <\u2500\u2500 \u2502 \u2500\u2500> 0         \u2502\n                                        o W (V_out)    \u2500\u2534\u2500 GND\n                                        \u2502\n                                      \u250c\u2500\u2500\u2500\u2510\n                                      \u2502 L \u2502\n                             R_load   \u2502 o \u2502\n                                      \u2502 a \u2502\n                                      \u2502 d \u2502\n                                      \u2514\u2500\u2500\u2500\u2518\n                                        \u2502\n                                       \u2500\u2534\u2500 GND\n\n    Rheostat possible connection circuit is shown below.\n\n      A     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     B   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       x\u2500\u2500\u2500\u2500\u2524 Rheostat \u251c\u2500\u2500\u2500\u2500\u2500o\u2500\u2500\u2500\u2524 R_lim  \u251c\u2500\u2500o (V_in)\n            \u2514\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            1 <\u2500\u2500 \u2502 \u2500\u2500> 0\n                  o W (V_out)\n                  \u2502\n                \u250c\u2500\u2500\u2500\u2510\n                \u2502 L \u2502\n         R_load \u2502 o \u2502\n                \u2502 a \u2502\n                \u2502 d \u2502\n                \u2514\u2500\u2500\u2500\u2518\n                  \u2502\n                 \u2500\u2534\u2500 GND\n\n    R_lim is current limiting resistor, and R_load is resistive load.\n    Parameters `r_lim` and `r_load` can be set using properties with same name.\n    Default value for R_lim and R_load is zero.\n    Input voltage (V_in) is set using property `voltage_in`.\n    Output voltage (V_out) can be calculated using method `voltage_out`.\n\n    Wiper position given required V_out can be calculated\n    using function `voltage_out_to_wiper_position`.\n\n    \"\"\"\n\n    # pylint: disable=too-many-instance-attributes\n\n    def __init__(\n        self,\n        r_ab: float,\n        r_w: float = 0,\n        rheostat: bool = False,\n        parameters_locked: bool = False,\n    ) -> None:\n        self.__parameters_locked: bool = bool(parameters_locked)\n        self.__r_ab: float = float(check_positive(r_ab))\n        self.__r_w: float = float(check_not_negative(r_w))\n        self.__rheostat: bool = bool(rheostat)\n\n        self.__r_lim: float = 0\n        self.__r_load: float = 0\n        self.__voltage_in: float = 0\n\n    @property\n    def r_ab(self) -> float:\n        \"\"\"\n        Total resistance of the potentiometer between A and B terminals.\n\n        :return: Total resistance as float.\n        \"\"\"\n        return self.__r_ab\n\n    @r_ab.setter\n    def r_ab(self, resistance: float) -> None:\n        if not self.parameters_locked:\n            self.__r_ab = float(check_positive(resistance))\n\n    @property\n    def r_w(self) -> float:\n        \"\"\"\n        Wiper terminal resistance.\n\n        :return: Wiper resistance as float.\n        \"\"\"\n        return self.__r_w\n\n    @r_w.setter\n    def r_w(self, r_w: float) -> None:\n        if not self.parameters_locked:\n            self.__r_w = float(check_not_negative(r_w))\n\n    @property\n    def parameters_locked(self) -> bool:\n        \"\"\"\n        Check if parameters of the potentiometer are locked.\n\n        :return: True if locked and False otherwise\n        \"\"\"\n        return self.__parameters_locked\n\n    @property\n    def rheostat(self) -> bool:\n        \"\"\"\n        Check if device is configured as a rheostat (terminal A is floating and not available\n        for connection).\n\n        :return: True if device is a rheostat, otherwise False.\n        \"\"\"\n        return self.__rheostat\n\n    @property\n    def r_lim(self) -> float:\n        \"\"\"R_lim current limiting resistor\"\"\"\n        return self.__r_lim\n\n    @r_lim.setter\n    def r_lim(self, r_lim: float) -> None:\n        self.__r_lim = float(check_not_negative(r_lim))\n\n    @property\n    def r_load(self) -> float:\n        \"\"\"Resistive load R_load value\"\"\"\n        return self.__r_load\n\n    @r_load.setter\n    def r_load(self, r_load: float) -> None:\n        self.__r_load = float(check_not_negative(r_load))\n\n    @property\n    def voltage_in(self) -> float:\n        \"\"\"\n        Input voltage of the device.\n\n        :return: voltage_in (float).\n        \"\"\"\n        return self.__voltage_in\n\n    @voltage_in.setter\n    def voltage_in(self, voltage: float) -> None:\n        self.__voltage_in = float(check_number(voltage))\n\n    def r_wa(self, wiper_position: float) -> float:\n        \"\"\"\n        Calculates resistance between terminals A and W given the wiper position\n        as a fraction of its movement in the range from 0 (terminal B) to 1 (terminal A).\n\n        :param wiper_position: Wiper position in the range [0: 1]\n        :return: Resistance between terminals A and W (float).\n        \"\"\"\n        wiper_position = clamp(wiper_position, 0, 1)\n        return self.r_w + (1 - wiper_position) * self.r_ab\n\n    def r_wb(self, wiper_position: float) -> float:\n        \"\"\"\n        Calculates resistance between terminals B and W given the wiper position\n        as a fraction of its movement in the range from 0 (terminal B) to 1 (terminal A).\n\n        :param wiper_position: Wiper position in the range [0: 1]\n        :return: Resistance between terminals B and W (float).\n        \"\"\"\n        wiper_position = clamp(wiper_position, 0, 1)\n        return self.r_w + wiper_position * self.r_ab\n\n    def r_wa_to_position(self, r_wa: float) -> float:\n        \"\"\"\n        Calculate wiper position as a fraction of its movement in the range from 0 (terminal B)\n        to 1 (terminal A) given the resistance between terminals A and W.\n\n        :param r_wa: Resistance between terminals A and W (float)\n        :return: Wiper position in the range [0: 1] (float).\n        \"\"\"\n        r_wa = clamp(r_wa, self.r_w, self.r_w + self.r_ab)\n        return 1 - (r_wa - self.r_w) / self.r_ab\n\n    def r_wb_to_position(self, r_wb: float) -> float:\n        \"\"\"\n        Calculate wiper position as a fraction of its movement in the range from 0 (terminal B)\n        to 1 (terminal A) given the resistance between terminals B and W.\n\n        :param r_wb: Resistance between terminals B and W (float)\n        :return: Wiper position in the range [0: 1] (float).\n        \"\"\"\n        r_wb = clamp(r_wb, self.r_w, self.r_w + self.r_ab)\n        return (r_wb - self.r_w) / self.r_ab\n\n    def voltage_out(self, wiper_position: float) -> float:\n        \"\"\"\n        Calculates output voltage for given wiper position.\n\n        :param wiper_position: Wiper position as float number between 0 and 1.\n        :return: Voltage (float).\n        \"\"\"\n        wiper_position = clamp(wiper_position, 0, 1)\n        if self.rheostat:\n            r_total = self.r_load + self.r_lim + self.r_wb(wiper_position)\n            return self.voltage_in * self.r_load / r_total\n        r_wb = self.r_ab * wiper_position\n        r_wa = self.r_ab * (1 - wiper_position)\n        r_bot = r_wb * (self.r_w + self.r_load) / (r_wb + self.r_w + self.r_load)\n        v_bot = self.voltage_in * r_bot / (r_bot + self.r_lim + r_wa)\n        return v_bot / (self.r_load + self.r_w) * self.r_load\n\n    def voltage_out_to_wiper_position(self, voltage_out: float) -> float:\n        \"\"\"\n        Calculates wiper position given output voltage.\n\n        :param voltage_out: Output voltage (float).\n        :return: Wiper position as float number between 0 and 1.\n        \"\"\"\n        voltage_out = check_number(voltage_out)\n        if voltage_out == 0 or self.r_load == 0 or self.voltage_in == 0:\n            return 0\n        if (self.voltage_in / voltage_out) / abs(self.voltage_in / voltage_out) < 0:\n            return 0\n\n        if self.rheostat:\n            r_total = self.voltage_in * self.r_load / voltage_out\n            r_wb = r_total - self.r_load - self.r_lim\n            return self.r_wb_to_position(r_wb)\n\n        v_bot = voltage_out * (self.r_w + self.r_load) / self.r_load\n        r_lim = self.r_ab + self.r_lim\n        r_l = self.r_w + self.r_load\n        quad_b = self.voltage_in / v_bot * r_l - r_lim\n        quad_ac = -r_lim * r_l\n        quad_d = quad_b**2 - 4 * quad_ac\n        r_wb = (-quad_b + m.sqrt(quad_d)) / 2\n        return r_wb / self.r_ab", ""]}
{"filename": "src/BDPotentiometer/__init__.py", "chunked_list": ["\"\"\" Module to operate SPI digital potentiometer devices \"\"\"\n\n# pylint: disable=invalid-name\n\n__version__ = \"0.0.2\"\n\nfrom .potentiometer import Potentiometer\nfrom .digital_wiper import DigitalWiper, SpiDigitalWiper\nfrom .digital_potentiometer import DigitalPotentiometerDevice\n\ntry:\n    from .__gpiozero_helpers import fix_gpiozero_dual_cs_spi\nexcept ModuleNotFoundError:\n    from .__gpiozero_helpers import (\n        fix_gpiozero_dual_cs_spi_dummy as fix_gpiozero_dual_cs_spi,\n    )", "from .digital_potentiometer import DigitalPotentiometerDevice\n\ntry:\n    from .__gpiozero_helpers import fix_gpiozero_dual_cs_spi\nexcept ModuleNotFoundError:\n    from .__gpiozero_helpers import (\n        fix_gpiozero_dual_cs_spi_dummy as fix_gpiozero_dual_cs_spi,\n    )\n", ""]}
{"filename": "src/BDPotentiometer/digital_potentiometer.py", "chunked_list": ["\"\"\" Digital potentiometer base class \"\"\"\n\nimport copy\nfrom typing import Union\n\nfrom .__helpers import check_not_negative, check_positive, check_integer\nfrom .digital_wiper import DigitalWiper\n\n\nclass DigitalPotentiometerDevice:\n    \"\"\"\n    Represents a digital potentiometer device connected to SPI (serial interface).\n\n    A     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     B\n     o\u2500\u2500\u2500\u2500\u2524   POT    \u251c\u2500\u2500\u2500\u2500\u2500o\n          \u2514\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2518\n                \u2502\n                o W\n\n    Total resistance of the potentiometer is `r_ab`. All terminals are available for connection.\n    W is a programmable wiper terminal with output resistance `r_w`.\n    Wiper position can be set between 0 and `max_value`. Parameter `default_value` sets initial\n    wiper position. Use None for pots with non-volatile memory.\n\n    For easy operation as voltage source following topology is assumed.\n\n    V_in     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 A     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     B\n         o\u2500\u2500\u2500\u2524 R_lim  \u251c\u2500\u2500o\u2500\u2500\u2500\u2500\u2524   POT    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2518          \u2502\n                      max_value <\u2500\u2500 \u2502 \u2500\u2500> 0         \u2502\n                                    o W (V_out)    \u2500\u2534\u2500 GND\n                                    \u2502\n                                  \u250c\u2500\u2500\u2500\u2510\n                                  \u2502 R \u2502\n                                  \u2502lo-\u2502\n                                  \u2502ad \u2502\n                                  \u2514\u2500\u2500\u2500\u2518\n                                    \u2502\n                                   \u2500\u2534\u2500 GND\n\n\n    terminal A is connected to voltage supply via current limiting resistor R_lim,\n    terminal B is connected to ground. Voltage at W terminal may be set or calculated.\n    Terminal W is connected to load resistance R_load.\n    By default, `R_load` equals to 1 MOhm, and `R_lim` equals to zero Ohms.\n\n    Device can also be configured in Rheostat mode. In this case terminal A is left floating\n    and only terminals B and W are available for connection.\n\n      A     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     B\n       x\u2500\u2500\u2500\u2500\u2524   POT    \u251c\u2500\u2500\u2500\u2500\u2500o\n            \u2514\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2518\n    max_value <\u2500\u2500 \u2502 \u2500\u2500> 0\n                  o W\n\n    Option with `R_lim` and `R_load` connection is also available\n\n      A     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     B   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   (V_in)\n       x\u2500\u2500\u2500\u2500\u2524   POT    \u251c\u2500\u2500\u2500\u2500\u2500o\u2500\u2500\u2500\u2524 R_lim  \u251c\u2500\u2500o\n            \u2514\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    max_value <\u2500\u2500 \u2502 \u2500\u2500> 0\n                  o W (V_out)\n                  \u2502\n                \u250c\u2500\u2500\u2500\u2510\n                \u2502 R \u2502\n                \u2502lo-\u2502\n                \u2502ad \u2502\n                \u2514\u2500\u2500\u2500\u2518\n                  \u2502\n                 \u2500\u2534\u2500 GND\n    \"\"\"\n\n    # pylint: disable=too-many-public-methods\n    # pylint: disable=too-many-instance-attributes\n\n    def __init__(self, wiper: DigitalWiper, channels: int = 1) -> None:\n        self.__channels: dict[int, DigitalWiper] = {}\n        self.__labels: dict[int, str] = {0: \"0\"}\n        for i in range(check_integer(check_positive(channels))):\n            wiper = copy.deepcopy(wiper)\n            wiper.channel = i\n            wiper.potentiometer.r_lim = 0\n            wiper.potentiometer.r_load = 0\n            wiper.potentiometer.voltage_in = 0\n            wiper.read()\n            self.__channels[i] = wiper\n            self.__labels[i] = str(i)\n\n    def set_channel_label(\n        self, channel: int = 0, label: Union[str, None] = None\n    ) -> None:\n        \"\"\"\n        Assigns string label to a channel.\n        Note that label must be unique, otherwise will rise ValueError.\n\n        :param channel: Channel number.\n        :param label: Label for the channel (str).\n        \"\"\"\n        channel = check_integer(check_not_negative(channel))\n        if channel not in self.__labels:\n            raise ValueError(f\"Channel {channel} does not exist.\")\n        if label is None:\n            label = str(channel)\n        for idx, lbl in self.__labels.items():\n            if lbl == label and idx != channel:\n                raise ValueError(\n                    f\"Label {label} already assigned to another channel {idx}.\"\n                )\n        self.__labels[channel] = str(label)\n\n    def get_channel_number_by_label(self, label: str) -> Union[int, None]:\n        \"\"\"\n        Look for channel number by label provided.\n\n        :param label: Channel label (str).\n        :return: Channel number if label found or None.\n        \"\"\"\n        try:\n            return list(self.__labels.values()).index(str(label))\n        except ValueError:\n            return None\n\n    def _get_channel_number_by_label_or_id(\n        self, channel: Union[int, str]\n    ) -> Union[int, None]:\n        \"\"\"\n        Look for channel number by label or number provided.\n\n        :param channel: Channel number or label (int | str).\n        :return: Channel number if channel found or None.\n        \"\"\"\n        if isinstance(channel, str):\n            return self.get_channel_number_by_label(channel)\n        channel = check_integer(check_not_negative(channel))\n        if channel in self.__channels:\n            return channel\n        return None\n\n    @property\n    def channels(self) -> dict[int, DigitalWiper]:\n        \"\"\"\n        Available channels of the device.\n\n        :return: dict of DigitalWiper objects\n        \"\"\"\n        return self.__channels\n\n    @property\n    def channels_num(self) -> int:\n        \"\"\"\n        Get the number of channels of the device.\n\n        :return: number of available channels as int.\n        \"\"\"\n        return len(self.__channels)\n\n    def set_value(self, channel: Union[int, str] = 0, value: int = 0) -> int:\n        \"\"\"\n        Method to set the value for a given channel.\n\n        :param channel: Channel number or label (int | str).\n        :param value: Wiper position value requested (int).\n        :return: Wiper position value actually set (int).\n        \"\"\"\n        channel_number = self._get_channel_number_by_label_or_id(channel)\n        if channel_number is None:\n            raise ValueError(f\"Channel {channel} not found.\")\n        self.channels[channel_number].value = value\n        return self.channels[channel_number].value\n\n    def get_value(self, channel: Union[int, str] = 0) -> int:\n        \"\"\"\n        Read value of given channel.\n\n        :param channel: Channel number or label (int | str).\n        :return: Wiper position value (int).\n        \"\"\"\n        channel_number = self._get_channel_number_by_label_or_id(channel)\n        if channel_number is None:\n            raise ValueError(f\"Channel {channel} not found.\")\n        return self.channels[channel_number].value\n\n    @property\n    def value(self) -> tuple[int, ...]:\n        \"\"\"\n        Tuple of current values for all channels.\n\n        :return: Tuple of int values for all channels.\n        \"\"\"\n        return tuple(wiper.value for _, wiper in self.channels.items())\n\n    @value.setter\n    def value(self, value: Union[list[int], tuple[int, ...]]) -> None:\n        if not isinstance(value, (list, tuple)):\n            raise ValueError(\"A tuple or list of values is expected.\")\n        if len(value) != self.channels_num:\n            raise ValueError(\n                f\"A tuple or list of length {self.channels_num} is expected.\"\n            )\n        for i in range(self.channels_num):\n            self.channels[i].value = value[i]\n\n    def set_r_wb(self, channel: Union[int, str] = 0, resistance: float = 0) -> int:\n        \"\"\"\n        Set the resistance for given channel between B and W terminals\n        as close as possible to requested value.\n\n        :param channel: Channel number or label (int | str)\n        :param resistance: Requested resistance as float.\n        :return: Wiper position value as int.\n        \"\"\"\n        channel_number = self._get_channel_number_by_label_or_id(channel)\n        if channel_number is None:\n            raise ValueError(f\"Channel {channel} not found.\")\n        self.channels[channel_number].r_wb = resistance\n        return self.channels[channel_number].value\n\n    def get_r_wb(self, channel: Union[int, str] = 0) -> float:\n        \"\"\"\n        Get the resistance for given channel between B and W terminals.\n\n        :param channel: Channel number or label (int | str)\n        :return: B-W resistance value as float.\n        \"\"\"\n        channel_number = self._get_channel_number_by_label_or_id(channel)\n        if channel_number is None:\n            raise ValueError(f\"Channel {channel} not found.\")\n        return self.channels[channel_number].r_wb\n\n    @property\n    def r_wb(self) -> tuple[float, ...]:\n        \"\"\"\n        Resistance between B and W terminals for all channels as a tuple of floats.\n\n        :return: B-W resistance for all channels as a tuple of floats.\n        \"\"\"\n        return tuple(wiper.r_wb for _, wiper in self.channels.items())\n\n    @r_wb.setter\n    def r_wb(self, resistance: Union[list[float], tuple[float, ...]]) -> None:\n        if len(resistance) != self.channels_num:\n            raise ValueError(\n                f\"A tuple or list of length {self.channels_num} is expected.\"\n            )\n        for channel, wiper in self.channels.items():\n            wiper.r_wb = resistance[channel]\n\n    def set_r_wa(self, channel: Union[int, str] = 0, resistance: float = 0) -> int:\n        \"\"\"\n        Set the resistance for given channel between A and W terminals\n        as close as possible to requested value.\n\n        :param channel: Channel number or label (int | str)\n        :param resistance: Requested resistance as float.\n        :return: Wiper position value as int.\n        \"\"\"\n        channel_number = self._get_channel_number_by_label_or_id(channel)\n        if channel_number is None:\n            raise ValueError(f\"Channel {channel} not found.\")\n        self.channels[channel_number].r_wa = resistance\n        return self.channels[channel_number].value\n\n    def get_r_wa(self, channel: Union[int, str] = 0) -> float:\n        \"\"\"\n        Get the resistance for given channel between A and W terminals.\n\n        :param channel: Channel number or label (int | str)\n        :return: A-W resistance value as float.\n        \"\"\"\n        channel_number = self._get_channel_number_by_label_or_id(channel)\n        if channel_number is None:\n            raise ValueError(f\"Channel {channel} not found.\")\n        return self.channels[channel_number].r_wa\n\n    @property\n    def r_wa(self) -> tuple[float, ...]:\n        \"\"\"\n        Resistance between A and W terminals for all channels as a tuple of floats.\n\n        :return: A-W resistance for all channels as a tuple of floats.\n        \"\"\"\n        return tuple(wiper.r_wa for _, wiper in self.channels.items())\n\n    @r_wa.setter\n    def r_wa(self, resistance: Union[list[float], tuple[float, ...]]) -> None:\n        if len(resistance) != self.channels_num:\n            raise ValueError(\n                f\"A tuple or list of length {self.channels_num} is expected.\"\n            )\n        for channel, wiper in self.channels.items():\n            wiper.r_wa = resistance[channel]\n\n    def set_r_lim(self, channel: Union[int, str] = 0, resistance: float = 0) -> None:\n        \"\"\"\n        Set the current limiting resistor value for given channel.\n\n        :param channel: Channel number or label (int | str)\n        :param resistance: Requested resistance as float.\n        \"\"\"\n        channel_number = self._get_channel_number_by_label_or_id(channel)\n        if channel_number is None:\n            raise ValueError(f\"Channel {channel} not found.\")\n        self.channels[channel_number].r_lim = resistance\n\n    def get_r_lim(self, channel: Union[int, str] = 0) -> float:\n        \"\"\"\n        Get the current limiting resistor value for given channel.\n\n        :param channel: Channel number or label (int | str)\n        :return: Current limiting resistor value as float.\n        \"\"\"\n        channel_number = self._get_channel_number_by_label_or_id(channel)\n        if channel_number is None:\n            raise ValueError(f\"Channel {channel} not found.\")\n        return self.channels[channel_number].r_lim\n\n    @property\n    def r_lim(self) -> tuple[float, ...]:\n        \"\"\"\n        Potentiometer current limiting resistors for all channels.\n        \"\"\"\n        return tuple(wiper.r_lim for _, wiper in self.channels.items())\n\n    @r_lim.setter\n    def r_lim(\n        self, resistance: Union[int, float, list[float], tuple[float, ...]]\n    ) -> None:\n        if isinstance(resistance, (int, float)):\n            resistance = [float(resistance)] * self.channels_num\n        if (\n            not isinstance(resistance, (list, tuple))\n            or len(resistance) != self.channels_num\n        ):\n            raise ValueError(\n                f\"A tuple or list of length {self.channels_num} is expected.\"\n            )\n        for channel, wiper in self.channels.items():\n            wiper.r_lim = resistance[channel]\n\n    def set_r_load(self, channel: Union[int, str] = 0, resistance: float = 0) -> None:\n        \"\"\"\n        Set the load resistor value for given channel.\n\n        :param channel: Channel number or label (int | str)\n        :param resistance: Requested resistance as float.\n        \"\"\"\n        channel_number = self._get_channel_number_by_label_or_id(channel)\n        if channel_number is None:\n            raise ValueError(f\"Channel {channel} not found.\")\n        self.channels[channel_number].r_load = resistance\n\n    def get_r_load(self, channel: Union[int, str] = 0) -> float:\n        \"\"\"\n        Get the load resistor value for given channel.\n\n        :param channel: Channel number or label (int | str)\n        :return: Load resistor value as float.\n        \"\"\"\n        channel_number = self._get_channel_number_by_label_or_id(channel)\n        if channel_number is None:\n            raise ValueError(f\"Channel {channel} not found.\")\n        return self.channels[channel_number].r_load\n\n    @property\n    def r_load(self) -> tuple[float, ...]:\n        \"\"\"\n        Potentiometer load resistors for all channels.\n        \"\"\"\n        return tuple(wiper.r_load for _, wiper in self.channels.items())\n\n    @r_load.setter\n    def r_load(\n        self, resistance: Union[int, float, list[float], tuple[float, ...]]\n    ) -> None:\n        if isinstance(resistance, (int, float)):\n            resistance = [float(resistance)] * self.channels_num\n        if (\n            not isinstance(resistance, (list, tuple))\n            or len(resistance) != self.channels_num\n        ):\n            raise ValueError(\n                f\"A tuple or list of length {self.channels_num} is expected.\"\n            )\n        for channel, wiper in self.channels.items():\n            wiper.r_load = resistance[channel]\n\n    def set_voltage_in(\n        self, channel: Union[int, str] = 0, voltage: float = 0.0\n    ) -> float:\n        \"\"\"\n        Set input voltage for a given channel number.\n\n        :param channel: Channel number (int).\n        :param voltage: Requested input voltage (float).\n        :return: Set input voltage (float)\n        \"\"\"\n        channel_number = self._get_channel_number_by_label_or_id(channel)\n        if channel_number is None:\n            raise ValueError(f\"Channel {channel} not found.\")\n        self.channels[channel_number].voltage_in = voltage\n        return self.channels[channel_number].voltage_in\n\n    def get_voltage_in(self, channel: Union[int, str] = 0) -> float:\n        \"\"\"\n        Get input voltage for a given channel number.\n\n        :param channel: Channel number (int).\n        :return: Input voltage (float).\n        \"\"\"\n        channel_number = self._get_channel_number_by_label_or_id(channel)\n        if channel_number is None:\n            raise ValueError(f\"Channel {channel} not found.\")\n        return self.channels[channel_number].voltage_in\n\n    @property\n    def voltage_in(self) -> tuple[float, ...]:\n        \"\"\"\n        Input voltage of the device.\n\n        :return: voltage_in tuple of floats.\n        \"\"\"\n        return tuple(wiper.voltage_in for _, wiper in self.channels.items())\n\n    @voltage_in.setter\n    def voltage_in(self, voltage: Union[list[float], tuple[float]]) -> None:\n        if len(voltage) != self.channels_num:\n            raise ValueError(\n                f\"A tuple or list of length {self.channels_num} is expected.\"\n            )\n        for channel, wiper in self.channels.items():\n            wiper.voltage_in = voltage[channel]\n\n    def set_voltage_out(\n        self, channel: Union[int, str] = 0, voltage: float = 0.0\n    ) -> float:\n        \"\"\"\n        Set voltage at wiper for a given channel number.\n\n        :param channel: Channel number (int).\n        :param voltage: Voltage requested (float).\n        :return: Actual output voltage closest to requested (float).\n        \"\"\"\n        channel_number = self._get_channel_number_by_label_or_id(channel)\n        if channel_number is None:\n            raise ValueError(f\"Channel {channel} not found.\")\n        self.channels[channel_number].voltage_out = voltage\n        return self.channels[channel_number].voltage_out\n\n    def get_voltage_out(self, channel: Union[int, str] = 0) -> float:\n        \"\"\"\n        Get voltage at wiper for a given channel number.\n\n        :param channel: Channel number (int).\n        :return:Voltage (float).\n        \"\"\"\n        channel_number = self._get_channel_number_by_label_or_id(channel)\n        if channel_number is None:\n            raise ValueError(f\"Channel {channel} not found.\")\n        return self.channels[channel_number].voltage_out\n\n    @property\n    def voltage_out(self) -> tuple[float, ...]:\n        \"\"\"\n        Voltage at pot's wiper for all available channels as a tuple of floats.\n\n        :return: A tuple of voltages as floats.\n        \"\"\"\n        return tuple(wiper.voltage_out for _, wiper in self.channels.items())\n\n    @voltage_out.setter\n    def voltage_out(self, voltage: Union[list[float], tuple[float]]) -> None:\n        if len(voltage) != self.channels_num:\n            raise ValueError(\n                f\"A tuple or list of length {self.channels_num} is expected.\"\n            )\n        for channel, wiper in self.channels.items():\n            wiper.voltage_out = voltage[channel]", "\nclass DigitalPotentiometerDevice:\n    \"\"\"\n    Represents a digital potentiometer device connected to SPI (serial interface).\n\n    A     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     B\n     o\u2500\u2500\u2500\u2500\u2524   POT    \u251c\u2500\u2500\u2500\u2500\u2500o\n          \u2514\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2518\n                \u2502\n                o W\n\n    Total resistance of the potentiometer is `r_ab`. All terminals are available for connection.\n    W is a programmable wiper terminal with output resistance `r_w`.\n    Wiper position can be set between 0 and `max_value`. Parameter `default_value` sets initial\n    wiper position. Use None for pots with non-volatile memory.\n\n    For easy operation as voltage source following topology is assumed.\n\n    V_in     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 A     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     B\n         o\u2500\u2500\u2500\u2524 R_lim  \u251c\u2500\u2500o\u2500\u2500\u2500\u2500\u2524   POT    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2518          \u2502\n                      max_value <\u2500\u2500 \u2502 \u2500\u2500> 0         \u2502\n                                    o W (V_out)    \u2500\u2534\u2500 GND\n                                    \u2502\n                                  \u250c\u2500\u2500\u2500\u2510\n                                  \u2502 R \u2502\n                                  \u2502lo-\u2502\n                                  \u2502ad \u2502\n                                  \u2514\u2500\u2500\u2500\u2518\n                                    \u2502\n                                   \u2500\u2534\u2500 GND\n\n\n    terminal A is connected to voltage supply via current limiting resistor R_lim,\n    terminal B is connected to ground. Voltage at W terminal may be set or calculated.\n    Terminal W is connected to load resistance R_load.\n    By default, `R_load` equals to 1 MOhm, and `R_lim` equals to zero Ohms.\n\n    Device can also be configured in Rheostat mode. In this case terminal A is left floating\n    and only terminals B and W are available for connection.\n\n      A     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     B\n       x\u2500\u2500\u2500\u2500\u2524   POT    \u251c\u2500\u2500\u2500\u2500\u2500o\n            \u2514\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2518\n    max_value <\u2500\u2500 \u2502 \u2500\u2500> 0\n                  o W\n\n    Option with `R_lim` and `R_load` connection is also available\n\n      A     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     B   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   (V_in)\n       x\u2500\u2500\u2500\u2500\u2524   POT    \u251c\u2500\u2500\u2500\u2500\u2500o\u2500\u2500\u2500\u2524 R_lim  \u251c\u2500\u2500o\n            \u2514\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    max_value <\u2500\u2500 \u2502 \u2500\u2500> 0\n                  o W (V_out)\n                  \u2502\n                \u250c\u2500\u2500\u2500\u2510\n                \u2502 R \u2502\n                \u2502lo-\u2502\n                \u2502ad \u2502\n                \u2514\u2500\u2500\u2500\u2518\n                  \u2502\n                 \u2500\u2534\u2500 GND\n    \"\"\"\n\n    # pylint: disable=too-many-public-methods\n    # pylint: disable=too-many-instance-attributes\n\n    def __init__(self, wiper: DigitalWiper, channels: int = 1) -> None:\n        self.__channels: dict[int, DigitalWiper] = {}\n        self.__labels: dict[int, str] = {0: \"0\"}\n        for i in range(check_integer(check_positive(channels))):\n            wiper = copy.deepcopy(wiper)\n            wiper.channel = i\n            wiper.potentiometer.r_lim = 0\n            wiper.potentiometer.r_load = 0\n            wiper.potentiometer.voltage_in = 0\n            wiper.read()\n            self.__channels[i] = wiper\n            self.__labels[i] = str(i)\n\n    def set_channel_label(\n        self, channel: int = 0, label: Union[str, None] = None\n    ) -> None:\n        \"\"\"\n        Assigns string label to a channel.\n        Note that label must be unique, otherwise will rise ValueError.\n\n        :param channel: Channel number.\n        :param label: Label for the channel (str).\n        \"\"\"\n        channel = check_integer(check_not_negative(channel))\n        if channel not in self.__labels:\n            raise ValueError(f\"Channel {channel} does not exist.\")\n        if label is None:\n            label = str(channel)\n        for idx, lbl in self.__labels.items():\n            if lbl == label and idx != channel:\n                raise ValueError(\n                    f\"Label {label} already assigned to another channel {idx}.\"\n                )\n        self.__labels[channel] = str(label)\n\n    def get_channel_number_by_label(self, label: str) -> Union[int, None]:\n        \"\"\"\n        Look for channel number by label provided.\n\n        :param label: Channel label (str).\n        :return: Channel number if label found or None.\n        \"\"\"\n        try:\n            return list(self.__labels.values()).index(str(label))\n        except ValueError:\n            return None\n\n    def _get_channel_number_by_label_or_id(\n        self, channel: Union[int, str]\n    ) -> Union[int, None]:\n        \"\"\"\n        Look for channel number by label or number provided.\n\n        :param channel: Channel number or label (int | str).\n        :return: Channel number if channel found or None.\n        \"\"\"\n        if isinstance(channel, str):\n            return self.get_channel_number_by_label(channel)\n        channel = check_integer(check_not_negative(channel))\n        if channel in self.__channels:\n            return channel\n        return None\n\n    @property\n    def channels(self) -> dict[int, DigitalWiper]:\n        \"\"\"\n        Available channels of the device.\n\n        :return: dict of DigitalWiper objects\n        \"\"\"\n        return self.__channels\n\n    @property\n    def channels_num(self) -> int:\n        \"\"\"\n        Get the number of channels of the device.\n\n        :return: number of available channels as int.\n        \"\"\"\n        return len(self.__channels)\n\n    def set_value(self, channel: Union[int, str] = 0, value: int = 0) -> int:\n        \"\"\"\n        Method to set the value for a given channel.\n\n        :param channel: Channel number or label (int | str).\n        :param value: Wiper position value requested (int).\n        :return: Wiper position value actually set (int).\n        \"\"\"\n        channel_number = self._get_channel_number_by_label_or_id(channel)\n        if channel_number is None:\n            raise ValueError(f\"Channel {channel} not found.\")\n        self.channels[channel_number].value = value\n        return self.channels[channel_number].value\n\n    def get_value(self, channel: Union[int, str] = 0) -> int:\n        \"\"\"\n        Read value of given channel.\n\n        :param channel: Channel number or label (int | str).\n        :return: Wiper position value (int).\n        \"\"\"\n        channel_number = self._get_channel_number_by_label_or_id(channel)\n        if channel_number is None:\n            raise ValueError(f\"Channel {channel} not found.\")\n        return self.channels[channel_number].value\n\n    @property\n    def value(self) -> tuple[int, ...]:\n        \"\"\"\n        Tuple of current values for all channels.\n\n        :return: Tuple of int values for all channels.\n        \"\"\"\n        return tuple(wiper.value for _, wiper in self.channels.items())\n\n    @value.setter\n    def value(self, value: Union[list[int], tuple[int, ...]]) -> None:\n        if not isinstance(value, (list, tuple)):\n            raise ValueError(\"A tuple or list of values is expected.\")\n        if len(value) != self.channels_num:\n            raise ValueError(\n                f\"A tuple or list of length {self.channels_num} is expected.\"\n            )\n        for i in range(self.channels_num):\n            self.channels[i].value = value[i]\n\n    def set_r_wb(self, channel: Union[int, str] = 0, resistance: float = 0) -> int:\n        \"\"\"\n        Set the resistance for given channel between B and W terminals\n        as close as possible to requested value.\n\n        :param channel: Channel number or label (int | str)\n        :param resistance: Requested resistance as float.\n        :return: Wiper position value as int.\n        \"\"\"\n        channel_number = self._get_channel_number_by_label_or_id(channel)\n        if channel_number is None:\n            raise ValueError(f\"Channel {channel} not found.\")\n        self.channels[channel_number].r_wb = resistance\n        return self.channels[channel_number].value\n\n    def get_r_wb(self, channel: Union[int, str] = 0) -> float:\n        \"\"\"\n        Get the resistance for given channel between B and W terminals.\n\n        :param channel: Channel number or label (int | str)\n        :return: B-W resistance value as float.\n        \"\"\"\n        channel_number = self._get_channel_number_by_label_or_id(channel)\n        if channel_number is None:\n            raise ValueError(f\"Channel {channel} not found.\")\n        return self.channels[channel_number].r_wb\n\n    @property\n    def r_wb(self) -> tuple[float, ...]:\n        \"\"\"\n        Resistance between B and W terminals for all channels as a tuple of floats.\n\n        :return: B-W resistance for all channels as a tuple of floats.\n        \"\"\"\n        return tuple(wiper.r_wb for _, wiper in self.channels.items())\n\n    @r_wb.setter\n    def r_wb(self, resistance: Union[list[float], tuple[float, ...]]) -> None:\n        if len(resistance) != self.channels_num:\n            raise ValueError(\n                f\"A tuple or list of length {self.channels_num} is expected.\"\n            )\n        for channel, wiper in self.channels.items():\n            wiper.r_wb = resistance[channel]\n\n    def set_r_wa(self, channel: Union[int, str] = 0, resistance: float = 0) -> int:\n        \"\"\"\n        Set the resistance for given channel between A and W terminals\n        as close as possible to requested value.\n\n        :param channel: Channel number or label (int | str)\n        :param resistance: Requested resistance as float.\n        :return: Wiper position value as int.\n        \"\"\"\n        channel_number = self._get_channel_number_by_label_or_id(channel)\n        if channel_number is None:\n            raise ValueError(f\"Channel {channel} not found.\")\n        self.channels[channel_number].r_wa = resistance\n        return self.channels[channel_number].value\n\n    def get_r_wa(self, channel: Union[int, str] = 0) -> float:\n        \"\"\"\n        Get the resistance for given channel between A and W terminals.\n\n        :param channel: Channel number or label (int | str)\n        :return: A-W resistance value as float.\n        \"\"\"\n        channel_number = self._get_channel_number_by_label_or_id(channel)\n        if channel_number is None:\n            raise ValueError(f\"Channel {channel} not found.\")\n        return self.channels[channel_number].r_wa\n\n    @property\n    def r_wa(self) -> tuple[float, ...]:\n        \"\"\"\n        Resistance between A and W terminals for all channels as a tuple of floats.\n\n        :return: A-W resistance for all channels as a tuple of floats.\n        \"\"\"\n        return tuple(wiper.r_wa for _, wiper in self.channels.items())\n\n    @r_wa.setter\n    def r_wa(self, resistance: Union[list[float], tuple[float, ...]]) -> None:\n        if len(resistance) != self.channels_num:\n            raise ValueError(\n                f\"A tuple or list of length {self.channels_num} is expected.\"\n            )\n        for channel, wiper in self.channels.items():\n            wiper.r_wa = resistance[channel]\n\n    def set_r_lim(self, channel: Union[int, str] = 0, resistance: float = 0) -> None:\n        \"\"\"\n        Set the current limiting resistor value for given channel.\n\n        :param channel: Channel number or label (int | str)\n        :param resistance: Requested resistance as float.\n        \"\"\"\n        channel_number = self._get_channel_number_by_label_or_id(channel)\n        if channel_number is None:\n            raise ValueError(f\"Channel {channel} not found.\")\n        self.channels[channel_number].r_lim = resistance\n\n    def get_r_lim(self, channel: Union[int, str] = 0) -> float:\n        \"\"\"\n        Get the current limiting resistor value for given channel.\n\n        :param channel: Channel number or label (int | str)\n        :return: Current limiting resistor value as float.\n        \"\"\"\n        channel_number = self._get_channel_number_by_label_or_id(channel)\n        if channel_number is None:\n            raise ValueError(f\"Channel {channel} not found.\")\n        return self.channels[channel_number].r_lim\n\n    @property\n    def r_lim(self) -> tuple[float, ...]:\n        \"\"\"\n        Potentiometer current limiting resistors for all channels.\n        \"\"\"\n        return tuple(wiper.r_lim for _, wiper in self.channels.items())\n\n    @r_lim.setter\n    def r_lim(\n        self, resistance: Union[int, float, list[float], tuple[float, ...]]\n    ) -> None:\n        if isinstance(resistance, (int, float)):\n            resistance = [float(resistance)] * self.channels_num\n        if (\n            not isinstance(resistance, (list, tuple))\n            or len(resistance) != self.channels_num\n        ):\n            raise ValueError(\n                f\"A tuple or list of length {self.channels_num} is expected.\"\n            )\n        for channel, wiper in self.channels.items():\n            wiper.r_lim = resistance[channel]\n\n    def set_r_load(self, channel: Union[int, str] = 0, resistance: float = 0) -> None:\n        \"\"\"\n        Set the load resistor value for given channel.\n\n        :param channel: Channel number or label (int | str)\n        :param resistance: Requested resistance as float.\n        \"\"\"\n        channel_number = self._get_channel_number_by_label_or_id(channel)\n        if channel_number is None:\n            raise ValueError(f\"Channel {channel} not found.\")\n        self.channels[channel_number].r_load = resistance\n\n    def get_r_load(self, channel: Union[int, str] = 0) -> float:\n        \"\"\"\n        Get the load resistor value for given channel.\n\n        :param channel: Channel number or label (int | str)\n        :return: Load resistor value as float.\n        \"\"\"\n        channel_number = self._get_channel_number_by_label_or_id(channel)\n        if channel_number is None:\n            raise ValueError(f\"Channel {channel} not found.\")\n        return self.channels[channel_number].r_load\n\n    @property\n    def r_load(self) -> tuple[float, ...]:\n        \"\"\"\n        Potentiometer load resistors for all channels.\n        \"\"\"\n        return tuple(wiper.r_load for _, wiper in self.channels.items())\n\n    @r_load.setter\n    def r_load(\n        self, resistance: Union[int, float, list[float], tuple[float, ...]]\n    ) -> None:\n        if isinstance(resistance, (int, float)):\n            resistance = [float(resistance)] * self.channels_num\n        if (\n            not isinstance(resistance, (list, tuple))\n            or len(resistance) != self.channels_num\n        ):\n            raise ValueError(\n                f\"A tuple or list of length {self.channels_num} is expected.\"\n            )\n        for channel, wiper in self.channels.items():\n            wiper.r_load = resistance[channel]\n\n    def set_voltage_in(\n        self, channel: Union[int, str] = 0, voltage: float = 0.0\n    ) -> float:\n        \"\"\"\n        Set input voltage for a given channel number.\n\n        :param channel: Channel number (int).\n        :param voltage: Requested input voltage (float).\n        :return: Set input voltage (float)\n        \"\"\"\n        channel_number = self._get_channel_number_by_label_or_id(channel)\n        if channel_number is None:\n            raise ValueError(f\"Channel {channel} not found.\")\n        self.channels[channel_number].voltage_in = voltage\n        return self.channels[channel_number].voltage_in\n\n    def get_voltage_in(self, channel: Union[int, str] = 0) -> float:\n        \"\"\"\n        Get input voltage for a given channel number.\n\n        :param channel: Channel number (int).\n        :return: Input voltage (float).\n        \"\"\"\n        channel_number = self._get_channel_number_by_label_or_id(channel)\n        if channel_number is None:\n            raise ValueError(f\"Channel {channel} not found.\")\n        return self.channels[channel_number].voltage_in\n\n    @property\n    def voltage_in(self) -> tuple[float, ...]:\n        \"\"\"\n        Input voltage of the device.\n\n        :return: voltage_in tuple of floats.\n        \"\"\"\n        return tuple(wiper.voltage_in for _, wiper in self.channels.items())\n\n    @voltage_in.setter\n    def voltage_in(self, voltage: Union[list[float], tuple[float]]) -> None:\n        if len(voltage) != self.channels_num:\n            raise ValueError(\n                f\"A tuple or list of length {self.channels_num} is expected.\"\n            )\n        for channel, wiper in self.channels.items():\n            wiper.voltage_in = voltage[channel]\n\n    def set_voltage_out(\n        self, channel: Union[int, str] = 0, voltage: float = 0.0\n    ) -> float:\n        \"\"\"\n        Set voltage at wiper for a given channel number.\n\n        :param channel: Channel number (int).\n        :param voltage: Voltage requested (float).\n        :return: Actual output voltage closest to requested (float).\n        \"\"\"\n        channel_number = self._get_channel_number_by_label_or_id(channel)\n        if channel_number is None:\n            raise ValueError(f\"Channel {channel} not found.\")\n        self.channels[channel_number].voltage_out = voltage\n        return self.channels[channel_number].voltage_out\n\n    def get_voltage_out(self, channel: Union[int, str] = 0) -> float:\n        \"\"\"\n        Get voltage at wiper for a given channel number.\n\n        :param channel: Channel number (int).\n        :return:Voltage (float).\n        \"\"\"\n        channel_number = self._get_channel_number_by_label_or_id(channel)\n        if channel_number is None:\n            raise ValueError(f\"Channel {channel} not found.\")\n        return self.channels[channel_number].voltage_out\n\n    @property\n    def voltage_out(self) -> tuple[float, ...]:\n        \"\"\"\n        Voltage at pot's wiper for all available channels as a tuple of floats.\n\n        :return: A tuple of voltages as floats.\n        \"\"\"\n        return tuple(wiper.voltage_out for _, wiper in self.channels.items())\n\n    @voltage_out.setter\n    def voltage_out(self, voltage: Union[list[float], tuple[float]]) -> None:\n        if len(voltage) != self.channels_num:\n            raise ValueError(\n                f\"A tuple or list of length {self.channels_num} is expected.\"\n            )\n        for channel, wiper in self.channels.items():\n            wiper.voltage_out = voltage[channel]", ""]}
{"filename": "src/BDPotentiometer/__gpiozero_helpers.py", "chunked_list": ["\"\"\"Some helpers for gpiozero.\"\"\"\n\ntry:\n    from gpiozero import Device\n    from gpiozero.pins.local import LocalPiHardwareSPI, LocalPiHardwareSPIShared\n    from gpiozero.pins.rpigpio import RPiGPIOFactory\nexcept ModuleNotFoundError:\n    pass\n\n\ndef fix_gpiozero_dual_cs_spi() -> None:\n    \"\"\"\n    A workaround written by slghb GitHub user to use two spi devices with hardware spi.\n    Taken from https://github.com/gpiozero/gpiozero/issues/1015\n\n    :return: None.\n    \"\"\"\n\n    class LocalPiHardwareSPIFixed(LocalPiHardwareSPI):\n        \"\"\"Custom conflict checker\"\"\"\n\n        # pylint: disable=too-few-public-methods\n        def _conflicts_with(self, other):\n            # pylint: disable=protected-access\n            return not (\n                isinstance(other, LocalPiHardwareSPI)\n                and (self._port, self._device) != (other._port, other._device)\n            )\n\n        @property\n        def value(self):\n            \"\"\"\n            Returns a value representing the device's state. Frequently, this is a\n            boolean value, or a number between 0 and 1 but some devices use larger\n            ranges (e.g. -1 to +1) and composite devices usually use tuples to\n            return the states of all their subordinate components.\n            \"\"\"\n            raise NotImplementedError\n\n    class LocalPiHardwareSPISharedFixed(LocalPiHardwareSPIShared):\n        \"\"\"Custom Shared SPI hardware class inheriting from fixed Hardware SPI class above\"\"\"\n\n        def _conflicts_with(self, other):\n            # pylint: disable=protected-access\n            return not (\n                isinstance(other, LocalPiHardwareSPI)\n                and (self._port, self._device) != (other._port, other._device)\n            )\n\n        @property\n        def value(self):\n            \"\"\"\n            Returns a value representing the device's state. Frequently, this is a\n            boolean value, or a number between 0 and 1 but some devices use larger\n            ranges (e.g. -1 to +1) and composite devices usually use tuples to\n            return the states of all their subordinate components.\n            \"\"\"\n            raise NotImplementedError\n\n    class FixedRPiGPIOFactory(RPiGPIOFactory):\n        \"\"\"Fixed RPiGPIOFactory\"\"\"\n\n        def _get_spi_class(self, shared, hardware):\n            \"\"\"\n            Return a Fixed SPI class if shared hardware SPI port between two devices\n\n            :param shared: Flag for shared usage of SPI port.\n            :param hardware: Flag for hardware SPI usage.\n            :return:\n            \"\"\"\n            if hardware:\n                if shared:\n                    return LocalPiHardwareSPISharedFixed\n                return LocalPiHardwareSPIFixed\n            return super()._get_spi_class(shared, hardware)\n\n    Device.pin_factory = FixedRPiGPIOFactory()", "\n\ndef fix_gpiozero_dual_cs_spi() -> None:\n    \"\"\"\n    A workaround written by slghb GitHub user to use two spi devices with hardware spi.\n    Taken from https://github.com/gpiozero/gpiozero/issues/1015\n\n    :return: None.\n    \"\"\"\n\n    class LocalPiHardwareSPIFixed(LocalPiHardwareSPI):\n        \"\"\"Custom conflict checker\"\"\"\n\n        # pylint: disable=too-few-public-methods\n        def _conflicts_with(self, other):\n            # pylint: disable=protected-access\n            return not (\n                isinstance(other, LocalPiHardwareSPI)\n                and (self._port, self._device) != (other._port, other._device)\n            )\n\n        @property\n        def value(self):\n            \"\"\"\n            Returns a value representing the device's state. Frequently, this is a\n            boolean value, or a number between 0 and 1 but some devices use larger\n            ranges (e.g. -1 to +1) and composite devices usually use tuples to\n            return the states of all their subordinate components.\n            \"\"\"\n            raise NotImplementedError\n\n    class LocalPiHardwareSPISharedFixed(LocalPiHardwareSPIShared):\n        \"\"\"Custom Shared SPI hardware class inheriting from fixed Hardware SPI class above\"\"\"\n\n        def _conflicts_with(self, other):\n            # pylint: disable=protected-access\n            return not (\n                isinstance(other, LocalPiHardwareSPI)\n                and (self._port, self._device) != (other._port, other._device)\n            )\n\n        @property\n        def value(self):\n            \"\"\"\n            Returns a value representing the device's state. Frequently, this is a\n            boolean value, or a number between 0 and 1 but some devices use larger\n            ranges (e.g. -1 to +1) and composite devices usually use tuples to\n            return the states of all their subordinate components.\n            \"\"\"\n            raise NotImplementedError\n\n    class FixedRPiGPIOFactory(RPiGPIOFactory):\n        \"\"\"Fixed RPiGPIOFactory\"\"\"\n\n        def _get_spi_class(self, shared, hardware):\n            \"\"\"\n            Return a Fixed SPI class if shared hardware SPI port between two devices\n\n            :param shared: Flag for shared usage of SPI port.\n            :param hardware: Flag for hardware SPI usage.\n            :return:\n            \"\"\"\n            if hardware:\n                if shared:\n                    return LocalPiHardwareSPISharedFixed\n                return LocalPiHardwareSPIFixed\n            return super()._get_spi_class(shared, hardware)\n\n    Device.pin_factory = FixedRPiGPIOFactory()", "\n\ndef fix_gpiozero_dual_cs_spi_dummy() -> None:\n    \"\"\"\n    A stub function if there will be problems importing above function\n    \"\"\"\n"]}
{"filename": "src/BDPotentiometer/mcp4xxx/mcp4xx1.py", "chunked_list": ["\"\"\" MCP4XX1 series potentiometers \"\"\"\n\nfrom BDPotentiometer import DigitalPotentiometerDevice\nfrom .mcp4xxx import MCP4xxxPotentiometer, MCP4xxxWiper, MCP4xxx\n\n\nclass MCP4xx1(DigitalPotentiometerDevice, MCP4xxx):\n    \"\"\"MCP4XX1 is a single or dual channel digital potentiometer.\"\"\"\n\n    def __init__(\n        self, r_ab: float = 10e3, max_value: int = 128, channels: int = 1, **spi_args\n    ) -> None:\n        MCP4xxx.__init__(self, **spi_args)\n        potentiometer = MCP4xxxPotentiometer(r_ab, rheostat=False)\n        wiper = MCP4xxxWiper(\n            potentiometer=potentiometer, spi=self._spi, max_value=max_value\n        )\n        DigitalPotentiometerDevice.__init__(self, wiper=wiper, channels=channels)", "\n\nclass MCP4131(MCP4xx1):\n    \"\"\"7-bit, single channel pot with volatile wiper\"\"\"\n\n    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n        super().__init__(r_ab=r_ab, max_value=128, channels=1, **spi_args)\n\n\nclass MCP4141(MCP4xx1):\n    \"\"\"7-bit, single channel pot with non-volatile wiper\"\"\"\n\n    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n        super().__init__(r_ab=r_ab, max_value=128, channels=1, **spi_args)", "\nclass MCP4141(MCP4xx1):\n    \"\"\"7-bit, single channel pot with non-volatile wiper\"\"\"\n\n    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n        super().__init__(r_ab=r_ab, max_value=128, channels=1, **spi_args)\n\n\nclass MCP4151(MCP4xx1):\n    \"\"\"8-bit, single channel pot with volatile wiper\"\"\"\n\n    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n        super().__init__(r_ab=r_ab, max_value=256, channels=1, **spi_args)", "class MCP4151(MCP4xx1):\n    \"\"\"8-bit, single channel pot with volatile wiper\"\"\"\n\n    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n        super().__init__(r_ab=r_ab, max_value=256, channels=1, **spi_args)\n\n\nclass MCP4161(MCP4xx1):\n    \"\"\"8-bit, single channel pot with non-volatile wiper\"\"\"\n\n    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n        super().__init__(r_ab=r_ab, max_value=256, channels=1, **spi_args)", "\n\nclass MCP4231(MCP4xx1):\n    \"\"\"7-bit, dual channel pot with volatile wiper\"\"\"\n\n    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n        super().__init__(r_ab=r_ab, max_value=128, channels=2, **spi_args)\n\n\nclass MCP4241(MCP4xx1):\n    \"\"\"7-bit, dual channel pot with non-volatile wiper\"\"\"\n\n    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n        super().__init__(r_ab=r_ab, max_value=128, channels=2, **spi_args)", "\nclass MCP4241(MCP4xx1):\n    \"\"\"7-bit, dual channel pot with non-volatile wiper\"\"\"\n\n    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n        super().__init__(r_ab=r_ab, max_value=128, channels=2, **spi_args)\n\n\nclass MCP4251(MCP4xx1):\n    \"\"\"8-bit, dual channel pot with volatile wiper\"\"\"\n\n    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n        super().__init__(r_ab=r_ab, max_value=256, channels=2, **spi_args)", "class MCP4251(MCP4xx1):\n    \"\"\"8-bit, dual channel pot with volatile wiper\"\"\"\n\n    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n        super().__init__(r_ab=r_ab, max_value=256, channels=2, **spi_args)\n\n\nclass MCP4261(MCP4xx1):\n    \"\"\"8-bit, dual channel pot with volatile wiper\"\"\"\n\n    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n        super().__init__(r_ab=r_ab, max_value=256, channels=2, **spi_args)", ""]}
{"filename": "src/BDPotentiometer/mcp4xxx/mcp4xx2.py", "chunked_list": ["\"\"\" MCP4XX2 series rheostats \"\"\"\n\nfrom BDPotentiometer import DigitalPotentiometerDevice\nfrom .mcp4xxx import MCP4xxxPotentiometer, MCP4xxxWiper, MCP4xxx\n\n\nclass MCP4xx2(DigitalPotentiometerDevice, MCP4xxx):\n    \"\"\"MCP4XX2 is a single or dual channel digital rheostat.\"\"\"\n\n    def __init__(\n        self, r_ab: float = 10e3, max_value: int = 128, channels: int = 1, **spi_args\n    ) -> None:\n        MCP4xxx.__init__(self, **spi_args)\n        potentiometer = MCP4xxxPotentiometer(r_ab, rheostat=True)\n        wiper = MCP4xxxWiper(\n            potentiometer=potentiometer, spi=self._spi, max_value=max_value\n        )\n        DigitalPotentiometerDevice.__init__(self, wiper=wiper, channels=channels)", "\n\nclass MCP4132(MCP4xx2):\n    \"\"\"7-bit, single channel rheostat with volatile wiper\"\"\"\n\n    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n        super().__init__(r_ab=r_ab, max_value=128, channels=1, **spi_args)\n\n\nclass MCP4142(MCP4xx2):\n    \"\"\"7-bit, single channel rheostat with non-volatile wiper\"\"\"\n\n    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n        super().__init__(r_ab=r_ab, max_value=128, channels=1, **spi_args)", "\nclass MCP4142(MCP4xx2):\n    \"\"\"7-bit, single channel rheostat with non-volatile wiper\"\"\"\n\n    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n        super().__init__(r_ab=r_ab, max_value=128, channels=1, **spi_args)\n\n\nclass MCP4152(MCP4xx2):\n    \"\"\"8-bit, single channel rheostat with volatile wiper\"\"\"\n\n    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n        super().__init__(r_ab=r_ab, max_value=256, channels=1, **spi_args)", "class MCP4152(MCP4xx2):\n    \"\"\"8-bit, single channel rheostat with volatile wiper\"\"\"\n\n    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n        super().__init__(r_ab=r_ab, max_value=256, channels=1, **spi_args)\n\n\nclass MCP4162(MCP4xx2):\n    \"\"\"8-bit, single channel rheostat with non-volatile wiper\"\"\"\n\n    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n        super().__init__(r_ab=r_ab, max_value=256, channels=1, **spi_args)", "\n\nclass MCP4232(MCP4xx2):\n    \"\"\"7-bit, dual channel rheostat with volatile wiper\"\"\"\n\n    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n        super().__init__(r_ab=r_ab, max_value=128, channels=2, **spi_args)\n\n\nclass MCP4242(MCP4xx2):\n    \"\"\"7-bit, dual channel rheostat with non-volatile wiper\"\"\"\n\n    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n        super().__init__(r_ab=r_ab, max_value=128, channels=2, **spi_args)", "\nclass MCP4242(MCP4xx2):\n    \"\"\"7-bit, dual channel rheostat with non-volatile wiper\"\"\"\n\n    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n        super().__init__(r_ab=r_ab, max_value=128, channels=2, **spi_args)\n\n\nclass MCP4252(MCP4xx2):\n    \"\"\"8-bit, dual channel rheostat with volatile wiper\"\"\"\n\n    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n        super().__init__(r_ab=r_ab, max_value=256, channels=2, **spi_args)", "class MCP4252(MCP4xx2):\n    \"\"\"8-bit, dual channel rheostat with volatile wiper\"\"\"\n\n    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n        super().__init__(r_ab=r_ab, max_value=256, channels=2, **spi_args)\n\n\nclass MCP4262(MCP4xx2):\n    \"\"\"8-bit, dual channel rheostat with non-volatile wiper\"\"\"\n\n    def __init__(self, r_ab: float = 10e3, **spi_args) -> None:\n        super().__init__(r_ab=r_ab, max_value=256, channels=2, **spi_args)", ""]}
{"filename": "src/BDPotentiometer/mcp4xxx/__init__.py", "chunked_list": ["\"\"\" MCP4xxx series Digital potentiometers and rheostats \"\"\"\n\nfrom .mcp4xxx import resistance_list\n\nfrom .mcp4xx1 import (\n    MCP4131,\n    MCP4141,\n    MCP4151,\n    MCP4161,\n    MCP4231,", "    MCP4161,\n    MCP4231,\n    MCP4241,\n    MCP4251,\n    MCP4261,\n)\nfrom .mcp4xx2 import (\n    MCP4132,\n    MCP4142,\n    MCP4152,", "    MCP4142,\n    MCP4152,\n    MCP4162,\n    MCP4232,\n    MCP4242,\n    MCP4252,\n    MCP4262,\n)\n", ""]}
{"filename": "src/BDPotentiometer/mcp4xxx/mcp4xxx.py", "chunked_list": ["\"\"\" MCP4XXX series SPI device base class \"\"\"\n\nfrom typing import Union\nfrom gpiozero import SPI, SPIDevice\n\nfrom BDPotentiometer import SpiDigitalWiper, Potentiometer\n\n\nresistance_list: tuple[float, ...] = (5e3, 10e3, 50e3, 100e3)\n", "resistance_list: tuple[float, ...] = (5e3, 10e3, 50e3, 100e3)\n\n\ndef _coerce_max_value(max_value: int) -> int:\n    if max_value not in (128, 256):\n        raise ValueError(\"Max value must be equal to 128 or 256.\")\n    return max_value\n\n\ndef _coerce_r_ab(r_ab: float) -> float:\n    \"\"\"\n    Coerce resistance to the closest available for MCP4XXX devices.\n    :param r_ab: input resistance (float).\n    :return: resistance coerced to one from `resistance_list` (float).\n    \"\"\"\n    if r_ab not in resistance_list:\n        raise ValueError(f\"r_ab must be in {resistance_list}\")\n    return float(r_ab)", "\ndef _coerce_r_ab(r_ab: float) -> float:\n    \"\"\"\n    Coerce resistance to the closest available for MCP4XXX devices.\n    :param r_ab: input resistance (float).\n    :return: resistance coerced to one from `resistance_list` (float).\n    \"\"\"\n    if r_ab not in resistance_list:\n        raise ValueError(f\"r_ab must be in {resistance_list}\")\n    return float(r_ab)", "\n\ndef _check_write_response(data: list) -> None:\n    \"\"\"\n    Checks that the write response is in correct format.\n    :param data: Response data (list).\n    \"\"\"\n    if data is None:\n        raise ValueError(f\"Wrong response {data}\")\n", "\n\ndef _check_read_response(data: list) -> None:\n    \"\"\"\n    Checks that the read response is in correct format.\n    :param data: Response data (list).\n    \"\"\"\n    if data is None:\n        raise ValueError(f\"Wrong response {data}\")\n", "\n\ndef _check_status_response(data: list) -> None:\n    \"\"\"\n    Checks that the status request response is in correct format.\n    :param data: Response data (list).\n    \"\"\"\n    reserved = (0b1, 0b11100000)\n    if not (\n        data[0] & reserved[0] == reserved[0] and data[1] & reserved[1] == reserved[1]\n    ):\n        raise ValueError(f\"Wrong response {data}\")", "\n\ndef _check_tcon_response(data: list) -> None:\n    \"\"\"\n    Checks that the TCON response is in correct format.\n    :param data: Response data (list).\n    \"\"\"\n    reserved = (0b1,)\n    if not data[0] & reserved[0] == reserved[0]:\n        raise ValueError(f\"Wrong response {data}\")", "\n\ndef _parse_tcon_response(data: int) -> dict[str, bool]:\n    \"\"\"\n    Parses TCON response data.\n    :param data: raw TCON response data (int).\n    \":return: Parsed TCON state (dict).\n    \"\"\"\n    result = {\n        \"shdn\": not (data & 0b1000 == 0b1000),\n        \"A\": data & 0b0100 == 0b0100,\n        \"W\": data & 0b0010 == 0b0010,\n        \"B\": data & 0b0001 == 0b0001,\n    }\n    return result", "\n\ndef _tcon_to_cmd(tcon: dict[str, bool]) -> int:\n    \"\"\"\n    Convert TCON dict to TCON cmd ready for sending to device.\n    :param tcon: TCON requested state (dict).\n    :return: TCON cmd (int).\n    \"\"\"\n    shdn = 0 if tcon[\"shdn\"] else 0b1000\n    terminal_a = 0b0100 if tcon[\"A\"] else 0\n    terminal_w = 0b0010 if tcon[\"W\"] else 0\n    terminal_b = 0b0001 if tcon[\"B\"] else 0\n    return shdn | terminal_a | terminal_w | terminal_b", "\n\n_W_CMD = 0b00000000\n_R_CMD = 0b00001100\n_CH = (0b00000000, 0b00010000)\n_STATUS = 0b01010000\n_TCON = 0b01000000\n_SHDN = 0b10\n\n\nclass MCP4xxxPotentiometer(Potentiometer):\n    \"\"\"Potentiometer to use with MCP4XXX\"\"\"\n\n    def __init__(self, r_ab: float, rheostat: bool = False) -> None:\n        r_ab = _coerce_r_ab(r_ab)\n        super().__init__(r_ab=r_ab, r_w=75, rheostat=rheostat, parameters_locked=True)", "\n\nclass MCP4xxxPotentiometer(Potentiometer):\n    \"\"\"Potentiometer to use with MCP4XXX\"\"\"\n\n    def __init__(self, r_ab: float, rheostat: bool = False) -> None:\n        r_ab = _coerce_r_ab(r_ab)\n        super().__init__(r_ab=r_ab, r_w=75, rheostat=rheostat, parameters_locked=True)\n\n\nclass MCP4xxxWiper(SpiDigitalWiper):\n    \"\"\"Special version of SPIDigitalWiper for MCP4XXX pots\"\"\"\n\n    def __init__(\n        self,\n        potentiometer: MCP4xxxPotentiometer,\n        spi: Union[SPI, None] = None,\n        max_value: int = 128,\n    ):\n        max_value = _coerce_max_value(max_value)\n        super().__init__(\n            potentiometer=potentiometer,\n            spi=spi,\n            max_value=max_value,\n            parameters_locked=True,\n        )\n\n    def _set_value(self, value: int) -> int:\n        if isinstance(self.spi, SPI):\n            data = self.spi.transfer([_W_CMD | _CH[self.channel], value])\n            _check_write_response(data)\n            return value\n        raise ConnectionError(\"SPI interface not set\")\n\n    def _read_value(self):\n        if isinstance(self.spi, SPI):\n            data = self.spi.transfer([_R_CMD | _CH[self.channel], 0])\n            _check_read_response(data)\n            return data[1]\n        raise ConnectionError(\"SPI interface not set\")", "\n\nclass MCP4xxxWiper(SpiDigitalWiper):\n    \"\"\"Special version of SPIDigitalWiper for MCP4XXX pots\"\"\"\n\n    def __init__(\n        self,\n        potentiometer: MCP4xxxPotentiometer,\n        spi: Union[SPI, None] = None,\n        max_value: int = 128,\n    ):\n        max_value = _coerce_max_value(max_value)\n        super().__init__(\n            potentiometer=potentiometer,\n            spi=spi,\n            max_value=max_value,\n            parameters_locked=True,\n        )\n\n    def _set_value(self, value: int) -> int:\n        if isinstance(self.spi, SPI):\n            data = self.spi.transfer([_W_CMD | _CH[self.channel], value])\n            _check_write_response(data)\n            return value\n        raise ConnectionError(\"SPI interface not set\")\n\n    def _read_value(self):\n        if isinstance(self.spi, SPI):\n            data = self.spi.transfer([_R_CMD | _CH[self.channel], 0])\n            _check_read_response(data)\n            return data[1]\n        raise ConnectionError(\"SPI interface not set\")", "\n\nclass MCP4xxx(SPIDevice):\n    \"\"\"Base class for MCP4XXX series devices\"\"\"\n\n    def __init__(self, **spi_args) -> None:\n        super().__init__(shared=True, **spi_args)\n\n    @property\n    def value(self):\n        raise NotImplementedError\n\n    def get_shdn_pin_status(self) -> bool:\n        \"\"\"\n        Check status of device SHDN pin.\n\n        :return: SHDN state (bool).\n        \"\"\"\n        data = self._spi.transfer([_R_CMD | _STATUS, 0])\n        _check_status_response(data)\n        if data[1] & _SHDN == _SHDN:\n            return True\n        return False\n\n    def read_tcon(self) -> tuple[dict[str, bool], dict[str, bool]]:\n        \"\"\"\n        Read terminals connection (TCON) status of the device.\n\n        :return: Tuple of TCON status dicts.\n        \"\"\"\n        data = self._spi.transfer([_R_CMD | _TCON, 0])\n        _check_tcon_response(data)\n        ch0 = data[1] & 0b1111\n        ch1 = (data[1] & 0b11110000) >> 4\n        return _parse_tcon_response(ch0), _parse_tcon_response(ch1)\n\n    def write_tcon(\n        self,\n        ch0: Union[dict[str, bool], None] = None,\n        ch1: Union[dict[str, bool], None] = None,\n    ) -> bool:\n        \"\"\"\n        MCP4XXX terminals connection (TCON) control.\n\n        :return: True if success, otherwise False.\n        \"\"\"\n        default_tcon_value = {\"shdn\": False, \"A\": True, \"W\": True, \"B\": True}\n        if ch0 is None:\n            ch0 = default_tcon_value\n        if ch1 is None:\n            ch1 = default_tcon_value\n        ch0_cmd = _tcon_to_cmd(ch0)\n        ch1_cmd = _tcon_to_cmd(ch1)\n        data = ch0_cmd | (ch1_cmd << 4)\n        _ = self._spi.transfer([_W_CMD | _TCON, data])\n        resp = self._spi.transfer([_R_CMD | _TCON, 0])\n        _check_tcon_response(resp)\n        if resp[1] == data:\n            return True\n        return False\n\n    def shdn(self, ch0: bool = False, ch1: bool = False) -> bool:\n        \"\"\"\n        Shutdown of device channels using TCON control.\n        :param ch0: Boolean True for SHDN.\n        :param ch1: Boolean True for SHDN.\n        :return: True if success, otherwise False.\n        \"\"\"\n        return self.write_tcon(\n            ch0={\"shdn\": ch0, \"A\": True, \"W\": True, \"B\": True},\n            ch1={\"shdn\": ch1, \"A\": True, \"W\": True, \"B\": True},\n        )", ""]}
