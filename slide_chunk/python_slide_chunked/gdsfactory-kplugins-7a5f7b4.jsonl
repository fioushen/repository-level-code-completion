{"filename": "tests/test_sample.py", "chunked_list": ["# Sample Test passing with nose and pytest\n\ndef test_pass():\n    pass\n"]}
{"filename": "kplugins/async_utils.py", "chunked_list": ["from __future__ import annotations\n\nimport asyncio\nfrom pathlib import Path\nfrom typing import Optional\n\n\nasync def handle_return(\n    out_or_err: asyncio.streams.StreamReader,\n    log_file: Optional[Path] = None,", "    out_or_err: asyncio.streams.StreamReader,\n    log_file: Optional[Path] = None,\n    to_console: bool = True,\n) -> None:\n    with open(log_file, \"w\") as f:\n        while True:\n            # Without this sleep, the program won't exit\n            await asyncio.sleep(0)\n            data = await out_or_err.readline()\n            line = data.decode().strip()\n            if line:\n                if to_console:\n                    print(line)\n                f.write(line + \"\\n\")", "\n\nasync def execute_and_stream_output(\n    command: str, log_file_dir: Path, log_file_str: str\n) -> asyncio.subprocess.Process:\n    # Best not to use shell, but I can't get create_subprocess_exec to work here\n    proc = await asyncio.create_subprocess_shell(\n        command,\n        stdin=asyncio.subprocess.PIPE,\n        stdout=asyncio.subprocess.PIPE,", "        stdin=asyncio.subprocess.PIPE,\n        stdout=asyncio.subprocess.PIPE,\n        stderr=asyncio.subprocess.PIPE,\n    )\n    asyncio.create_task(\n        handle_return(proc.stdout, log_file=log_file_dir / f\"{log_file_str}_out.log\")\n    )\n    asyncio.create_task(\n        handle_return(proc.stderr, log_file=log_file_dir / f\"{log_file_str}_err.log\")\n    )", "        handle_return(proc.stderr, log_file=log_file_dir / f\"{log_file_str}_err.log\")\n    )\n\n    # This needs to also handle the \"wait_to_finish\" flag\n    await proc.wait()\n    return proc\n"]}
{"filename": "kplugins/materials.py", "chunked_list": ["\"\"\"Register materials.\"\"\"\nfrom __future__ import annotations\n\nfrom typing import Callable, Dict, Tuple, Union\n\nimport numpy as np\n\nMaterialSpec = Union[str, float, Tuple[float, float], Callable]\n\nmaterial_name_to_meep: Dict[str, MaterialSpec] = {", "\nmaterial_name_to_meep: Dict[str, MaterialSpec] = {\n    \"si\": \"Si\",\n    \"sin\": \"Si3N4_NIR\",\n    \"sio2\": \"SiO2\",\n}\n\nmaterial_name_to_lumerical: Dict[str, MaterialSpec] = {\n    \"si\": \"Si (Silicon) - Palik\",\n    \"sio2\": \"SiO2 (Glass) - Palik\",", "    \"si\": \"Si (Silicon) - Palik\",\n    \"sio2\": \"SiO2 (Glass) - Palik\",\n    \"sin\": \"Si3N4 (Silicon Nitride) - Phillip\",\n}\n\n\n# default materials\ndef si(wav: np.ndarray) -> np.ndarray:\n    \"\"\"Silicon crystalline.\"\"\"\n    from gdsfactory.simulation.gtidy3d.materials import si\n\n    return si(wav)", "\n\ndef sio2(wav: np.ndarray) -> np.ndarray:\n    \"\"\"Silicon oxide.\"\"\"\n    from gdsfactory.simulation.gtidy3d.materials import sio2\n\n    return sio2(wav)\n\n\ndef sin(wav: np.ndarray) -> np.ndarray:\n    \"\"\"Silicon Nitride.\"\"\"\n    from gdsfactory.simulation.gtidy3d.materials import sin\n\n    return sin(wav)", "\ndef sin(wav: np.ndarray) -> np.ndarray:\n    \"\"\"Silicon Nitride.\"\"\"\n    from gdsfactory.simulation.gtidy3d.materials import sin\n\n    return sin(wav)\n\n\nmaterials_index = {\"si\": si, \"sio2\": sio2, \"sin\": sin}\n", "materials_index = {\"si\": si, \"sio2\": sio2, \"sin\": sin}\n\n__all__ = [\n    \"material_name_to_meep\",\n    \"material_name_to_lumerical\",\n    \"materials_index\",\n    \"si\",\n    \"sio2\",\n    \"sin\",\n]", "    \"sin\",\n]\n"]}
{"filename": "kplugins/get_sparameters_path.py", "chunked_list": ["from __future__ import annotations\n\nimport hashlib\nimport pathlib\nfrom copy import deepcopy\nfrom functools import partial\nfrom pathlib import Path\nfrom typing import Any, Optional\n\nimport numpy as np", "\nimport numpy as np\n\nimport kfactory as kf\n\nfrom kgeneric import pdk\nfrom kgeneric.pdk import LayerStack\nfrom kfactory.kcell import clean_value\nfrom kfactory.typings import CellSpec\n", "from kfactory.typings import CellSpec\n\n\ndef get_kwargs_hash(**kwargs: Any) -> str:\n    \"\"\"Returns kwargs parameters hash.\"\"\"\n    kwargs_list = [f\"{key}={clean_value(kwargs[key])}\" for key in sorted(kwargs.keys())]\n    kwargs_string = \"_\".join(kwargs_list)\n    return hashlib.md5(kwargs_string.encode()).hexdigest()[:8]\n\n\ndef _get_sparameters_path(\n    cell: kf.KCell,\n    dirpath: Optional[Path] = None,\n    **kwargs: Any,\n) -> Path:\n    \"\"\"Return Sparameters npz filepath hashing simulation settings for \\\n            a consistent unique name.\n\n    Args:\n        component: component or component factory.\n        dirpath: directory to store sparameters in CSV.\n            Defaults to active Pdk.sparameters_path.\n        kwargs: simulation settings.\n\n    \"\"\"\n    dirpath_ = dirpath or pdk.sparameters_path\n    # component = f.get_component(component)\n\n    dirpath = pathlib.Path(dirpath_)\n    dirpath = (\n        dirpath / cell.function_name\n        if hasattr(cell, \"function_name\")\n        else dirpath\n    )\n    dirpath.mkdir(exist_ok=True, parents=True)\n    return dirpath / f\"{cell.hash().hex()}_{get_kwargs_hash(**kwargs)}.npz\"", "\n\ndef _get_sparameters_path(\n    cell: kf.KCell,\n    dirpath: Optional[Path] = None,\n    **kwargs: Any,\n) -> Path:\n    \"\"\"Return Sparameters npz filepath hashing simulation settings for \\\n            a consistent unique name.\n\n    Args:\n        component: component or component factory.\n        dirpath: directory to store sparameters in CSV.\n            Defaults to active Pdk.sparameters_path.\n        kwargs: simulation settings.\n\n    \"\"\"\n    dirpath_ = dirpath or pdk.sparameters_path\n    # component = f.get_component(component)\n\n    dirpath = pathlib.Path(dirpath_)\n    dirpath = (\n        dirpath / cell.function_name\n        if hasattr(cell, \"function_name\")\n        else dirpath\n    )\n    dirpath.mkdir(exist_ok=True, parents=True)\n    return dirpath / f\"{cell.hash().hex()}_{get_kwargs_hash(**kwargs)}.npz\"", "\n\ndef _get_sparameters_data(\n    component: ComponentSpec, **kwargs: Any\n) -> np.ndarray[str, np.dtype[Any]]:\n    \"\"\"Returns Sparameters data in a pandas DataFrame.\n\n    Keyword Args:\n        component: component.\n        dirpath: directory path to store sparameters.\n        kwargs: simulation settings.\n\n    \"\"\"\n    component = kf.get_component(component)\n    kwargs.update(component=component)\n    filepath = _get_sparameters_path(component=component, **kwargs)\n    return np.ndarray(np.load(filepath))", "\n\nget_sparameters_path_meow = partial(_get_sparameters_path, tool=\"meow\")\n\nget_sparameters_path_meep = partial(_get_sparameters_path, tool=\"meep\")\nget_sparameters_path_lumerical = partial(_get_sparameters_path, tool=\"lumerical\")\nget_sparameters_path_tidy3d = partial(_get_sparameters_path, tool=\"tidy3d\")\n\nget_sparameters_data_meep = partial(_get_sparameters_data, tool=\"meep\")\nget_sparameters_data_lumerical = partial(_get_sparameters_data, tool=\"lumerical\")", "get_sparameters_data_meep = partial(_get_sparameters_data, tool=\"meep\")\nget_sparameters_data_lumerical = partial(_get_sparameters_data, tool=\"lumerical\")\nget_sparameters_data_tidy3d = partial(_get_sparameters_data, tool=\"tidy3d\")\n\n\nif __name__ == \"__main__\":\n    # c = kf.pcells.taper(length=1.0, width1=0.5, width2=0.5, layer=1)\n    # p = get_sparameters_path_lumerical(c)\n\n    # sp = np.load(p)\n    # spd = dict(sp)\n    # print(spd)\n\n    # test_get_sparameters_path(test=False)\n    # test_get_sparameters_path(test=True)\n    print(\"\")", ""]}
{"filename": "kplugins/plot.py", "chunked_list": ["from __future__ import annotations\n\nimport re\nfrom functools import partial\nfrom itertools import combinations\nfrom typing import Dict, Optional, Sequence, Tuple\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n", "import numpy as np\n\nimport kgeneric as kf\n\n\ndef _check_ports(sp: Dict[str, np.ndarray], ports: Sequence[str]):\n    \"\"\"Ensure ports exist in Sparameters.\"\"\"\n    for port in ports:\n        if port not in sp:\n            raise ValueError(f\"Did not find port {port!r} in {list(sp.keys())}\")", "\n\ndef plot_sparameters(\n    sp: Dict[str, np.ndarray],\n    logscale: bool = True,\n    keys: Optional[Tuple[str, ...]] = None,\n    with_simpler_input_keys: bool = False,\n    with_simpler_labels: bool = True,\n) -> None:\n    \"\"\"Plots Sparameters from a dict of np.ndarrays.\n\n    Args:\n        sp: Sparameters np.ndarray.\n        logscale: plots 20*log10(S).\n        keys: list of keys to plot, plots all by default.\n        with_simpler_input_keys: You can use S12 keys instead of o1@0,o2@0.\n        with_simpler_labels: uses S11, S12 in plot labels instead of o1@0,o2@0.\n\n    .. plot::\n        :include-source:\n\n        import gdsfactory as gf\n        import gdsfactory.simulation as sim\n\n        sp = sim.get_sparameters_data_lumerical(component=gf.components.mmi1x2)\n        sim.plot.plot_sparameters(sp, logscale=True)\n\n    \"\"\"\n    w = sp[\"wavelengths\"] * 1e3\n    keys = keys or [key for key in sp if not key.lower().startswith(\"wav\")]\n\n    for key in keys:\n        if with_simpler_input_keys:\n            key = f\"o{key[1]}@0,o{key[2]}@0\"\n            if key not in sp:\n                raise ValueError(f\"{key!r} not in {list(sp.keys())}\")\n\n        if with_simpler_labels and \"o\" in key and \"@\" in key:\n            port_mode1_port_mode2 = key.split(\",\")\n            if len(port_mode1_port_mode2) != 2:\n                raise ValueError(f\"{key!r} needs to be 'portin@mode,portout@mode'\")\n            port_mode1, port_mode2 = port_mode1_port_mode2\n            port1, _mode1 = port_mode1.split(\"@\")\n            port2, _mode2 = port_mode2.split(\"@\")\n            alias = f\"S{port1[1:]}{port2[1:]}\"\n        else:\n            alias = key\n\n        if key not in sp:\n            raise ValueError(f\"{key!r} not in {list(sp.keys())}\")\n        y = sp[key]\n        y = 20 * np.log10(np.abs(y)) if logscale else np.abs(y) ** 2\n        plt.plot(w, y, label=alias)\n    plt.legend()\n    plt.xlabel(\"wavelength (nm)\")\n    plt.ylabel(\"|S| (dB)\") if logscale else plt.ylabel(\"$|S|^2$\")\n    plt.show()", "\n\ndef plot_sparameters_phase(\n    sp: Dict[str, np.ndarray],\n    logscale: bool = True,\n    keys: Optional[Tuple[str, ...]] = None,\n    with_simpler_input_keys: bool = False,\n    with_simpler_labels: bool = True,\n) -> None:\n    w = sp[\"wavelengths\"] * 1e3\n    keys = keys or [key for key in sp if not key.lower().startswith(\"wav\")]\n\n    for key in keys:\n        if with_simpler_input_keys:\n            key = f\"o{key[1]}@0,o{key[2]}@0\"\n            if key not in sp:\n                raise ValueError(f\"{key!r} not in {list(sp.keys())}\")\n\n        if with_simpler_labels and \"o\" in key and \"@\" in key:\n            port_mode1_port_mode2 = key.split(\",\")\n            if len(port_mode1_port_mode2) != 2:\n                raise ValueError(f\"{key!r} needs to be 'portin@mode,portout@mode'\")\n            port_mode1, port_mode2 = port_mode1_port_mode2\n            port1, _mode1 = port_mode1.split(\"@\")\n            port2, _mode2 = port_mode2.split(\"@\")\n            alias = f\"S{port1[1:]}{port2[1:]}\"\n        else:\n            alias = key\n\n        if key not in sp:\n            raise ValueError(f\"{key!r} not in {list(sp.keys())}\")\n        y = sp[key]\n        y = np.angle(y)\n        plt.plot(w, y, label=alias)\n    plt.legend()\n    plt.xlabel(\"wavelength (nm)\")\n    plt.ylabel(\"S (deg)\")\n    plt.show()", "\n\ndef plot_imbalance(\n    sp: Dict[str, np.ndarray], ports: Sequence[str], ax: Optional[plt.Axes] = None\n) -> None:\n    \"\"\"Plots imbalance in dB for coupler.\n    The imbalance is always defined between two ports, so this function plots the\n    imbalance between all unique port combinations.\n\n    Args:\n        sp: sparameters dict np.ndarray.\n        ports: list of port name @ mode index. o1@0 is the fundamental mode for o1 port.\n        ax: matplotlib axis object to draw into.\n\n    \"\"\"\n    _check_ports(sp, ports)\n\n    power = {port: np.abs(sp[port]) ** 2 for port in ports}\n    x = sp[\"wavelengths\"] * 1e3\n\n    if ax is None:\n        _, ax = plt.subplots()\n\n    for p1, p2 in combinations(ports, 2):\n        p1in, p1out = re.findall(r\"\\d+\", p1)[::2]\n        p2in, p2out = re.findall(r\"\\d+\", p2)[::2]\n        label = f\"$S_{{{p1in}{p1out}}}, S_{{{p2in}{p2out}}}$\"\n        ax.plot(x, 10 * np.log10(1 - (power[p1] - power[p2])), label=label)\n\n    ax.set_xlim((x[0], x[-1]))\n    ax.set_xlabel(\"wavelength (nm)\")\n    ax.set_ylabel(\"imbalance (dB)\")\n    plt.legend()", "\n\ndef plot_loss(\n    sp: Dict[str, np.ndarray], ports: Sequence[str], ax: Optional[plt.Axes] = None\n) -> None:\n    \"\"\"Plots loss dB for coupler.\n\n    Args:\n        sp: sparameters dict np.ndarray.\n        ports: list of port name @ mode index. o1@0 is the fundamental mode for o1 port.\n        ax: matplotlib axis object to draw into.\n\n    \"\"\"\n    _check_ports(sp, ports)\n\n    power = {port: np.abs(sp[port]) ** 2 for port in ports}\n    x = sp[\"wavelengths\"] * 1e3\n\n    if ax is None:\n        _, ax = plt.subplots()\n\n    for n, p in power.items():\n        pin, pout = re.findall(r\"\\d+\", n)[::2]\n        ax.plot(x, 10 * np.log10(p), label=f\"$|S_{{{pin}{pout}}}|^2$\")\n    if len(ports) > 1:\n        ax.plot(x, 10 * np.log10(sum(power.values())), \"k--\", label=\"Total\")\n    ax.set_xlim((x[0], x[-1]))\n    ax.set_xlabel(\"wavelength (nm)\")\n    ax.set_ylabel(\"excess loss (dB)\")\n    plt.legend()", "\n\ndef plot_reflection(\n    sp: Dict[str, np.ndarray], ports: Sequence[str], ax: Optional[plt.Axes] = None\n) -> None:\n    \"\"\"Plots reflection in dB for coupler.\n\n    Args:\n        sp: sparameters dict np.ndarray.\n        ports: list of port name @ mode index. o1@0 is the fundamental mode for o1 port.\n        ax: matplotlib axis object to draw into.\n\n    \"\"\"\n    _check_ports(sp, ports)\n\n    power = {port: np.abs(sp[port]) ** 2 for port in ports}\n    x = sp[\"wavelengths\"] * 1e3\n\n    if ax is None:\n        _, ax = plt.subplots()\n\n    for n, p in power.items():\n        pin, pout = re.findall(r\"\\d+\", n)[::2]\n        ax.plot(x, 10 * np.log10(p), label=f\"$|S_{{{pin}{pout}}}|^2$\")\n    if len(ports) > 1:\n        ax.plot(x, 10 * np.log10(sum(power.values())), \"k--\", label=\"Total\")\n    ax.set_xlim((x[0], x[-1]))\n    ax.set_xlabel(\"wavelength (nm)\")\n    ax.set_ylabel(\"reflection (dB)\")\n    plt.legend()", "\n\nplot_loss1x2 = partial(plot_loss, ports=[\"o1@0,o2@0\", \"o1@0,o3@0\"])\nplot_loss2x2 = partial(plot_loss, ports=[\"o1@0,o3@0\", \"o1@0,o4@0\"])\nplot_imbalance1x2 = partial(plot_imbalance, ports=[\"o1@0,o2@0\", \"o1@0,o3@0\"])\nplot_imbalance2x2 = partial(plot_imbalance, ports=[\"o1@0,o3@0\", \"o1@0,o4@0\"])\nplot_reflection1x2 = partial(plot_reflection, ports=[\"o1@0,o1@0\"])\nplot_reflection2x2 = partial(plot_reflection, ports=[\"o1@0,o1@0\", \"o2@0,o1@0\"])\n\nif __name__ == \"__main__\":\n    import gdsfactory.simulation as sim\n\n    sp = sim.get_sparameters_data_tidy3d(component=kf.cells.mmi1x2)", "\nif __name__ == \"__main__\":\n    import gdsfactory.simulation as sim\n\n    sp = sim.get_sparameters_data_tidy3d(component=kf.cells.mmi1x2)\n    # plot_sparameters(sp, logscale=False, keys=[\"o1@0,o2@0\"])\n    # plot_sparameters(sp, logscale=False, keys=[\"S21\"])\n    # plt.show()\n", ""]}
{"filename": "kplugins/config.py", "chunked_list": ["\"\"\"Store configuration.\"\"\"\n\n__all__ = [\"PATH\"]\n\nimport pathlib\n\nhome = pathlib.Path.home()\ncwd = pathlib.Path.cwd()\ncwd_config = cwd / \"config.yml\"\n", "cwd_config = cwd / \"config.yml\"\n\nhome_config = home / \".config\" / \"KFactory plugins.yml\"\nconfig_dir = home / \".config\"\nconfig_dir.mkdir(exist_ok=True)\nmodule_path = pathlib.Path(__file__).parent.absolute()\nrepo_path = module_path.parent\n\n\nclass Path:\n    module = module_path\n    repo = repo_path", "\nclass Path:\n    module = module_path\n    repo = repo_path\n\n\nPATH = Path()\n\nif __name__ == \"__main__\":\n    print(PATH)", "if __name__ == \"__main__\":\n    print(PATH)\n\n"]}
{"filename": "kplugins/port_symmetries.py", "chunked_list": ["port_symmetries_1x1 = {\n    \"o1@0,o1@0\": [\"o2@0,o2@0\"],\n    \"o2@0,o1@0\": [\"o1@0,o2@0\"],\n}\n\n\nport_symmetries_crossing = {\n    \"o1@0,o1@0\": [\"o2@0,o2@0\", \"o3@0,o3@0\", \"o4@0,o4@0\"],\n    \"o2@0,o1@0\": [\"o1@0,o2@0\", \"o3@0,o4@0\", \"o4@0,o3@0\"],\n    \"o3@0,o1@0\": [\"o1@0,o3@0\", \"o2@0,o4@0\", \"o4@0,o2@0\"],", "    \"o2@0,o1@0\": [\"o1@0,o2@0\", \"o3@0,o4@0\", \"o4@0,o3@0\"],\n    \"o3@0,o1@0\": [\"o1@0,o3@0\", \"o2@0,o4@0\", \"o4@0,o2@0\"],\n    \"o4@0,o1@0\": [\"o1@0,o4@0\", \"o2@0,o3@0\", \"o3@0,o2@0\"],\n}\n\n\nif __name__ == \"__main__\":\n    import numpy as np\n\n    port_symmetries = port_symmetries_crossing\n\n    sp = dict(wavelengths=np.linspace(1.5, 1.6, 3))\n    sp[\"o1@0,o1@0\"] = 2 * np.linspace(1.5, 1.6, 3)\n\n    for key, symmetries in port_symmetries.items():\n        for sym in symmetries:\n            if key in sp:\n                sp[sym] = sp[key]", ""]}
{"filename": "kplugins/__init__.py", "chunked_list": ["\"\"\"Kplugins - KFactory plugins\"\"\"\n\n__version__ = '0.0.2'\n"]}
{"filename": "kplugins/typings.py", "chunked_list": ["\nimport pathlib\nfrom typing import Callable, Dict, Tuple, Union\n\nMaterialSpec = Union[str, float, Tuple[float, float], Callable]\nPathType = pathlib.Path | str\n"]}
{"filename": "kplugins/extensions.py", "chunked_list": ["import numpy as np\n\nfrom typing import List\n\n\ndef move_polar_rad_copy(pos: List(float), angle: float, length: float) -> np.ndarray:\n    \"\"\"Returns the points of a position (pos) with angle, by shifted by certain.\n\n    length.\n\n    Args:\n        pos: position.\n        angle: in radians.\n        length: extension length in um.\n    \"\"\"\n    c = np.cos(angle)\n    s = np.sin(angle)\n    return pos + length * np.array([c, s])", ""]}
{"filename": "kplugins/kmeep/get_simulation_grating_fiber.py", "chunked_list": ["\"\"\"Adapted from https://github.com/simbilod/option.\n\nSMF specs from photonics.byu.edu/FiberOpticConnectors.parts/images/smf28.pdf\n\nMFD:\n\n- 10.4 for Cband\n- 9.2 for Oband\n\n\"\"\"", "\n\"\"\"\n\nfrom __future__ import annotations\n\nimport hashlib\nfrom typing import Any, Dict, Optional\n\nimport meep as mp\nimport numpy as np", "import meep as mp\nimport numpy as np\n\nfrom kfactory.kcell import clean_value\nfrom typing import List\n\nnm = 1e-3\nnSi = 3.47\nnSiO2 = 1.44\n", "nSiO2 = 1.44\n\n\ndef fiber_core_material(fiber_numerical_aperture, fiber_clad_material):\n    return (fiber_numerical_aperture**2 + fiber_clad_material**2) ** 0.5\n\n\ndef get_simulation_grating_fiber(\n    period: float = 0.66,\n    fill_factor: float = 0.5,\n    n_periods: int = 30,\n    widths: Optional[List[float]] = None,\n    gaps: Optional[List[float]] = None,\n    fiber_angle_deg: float = 20.0,\n    fiber_xposition: float = 1.0,\n    fiber_core_diameter: float = 10.4,\n    fiber_numerical_aperture: float = 0.14,\n    fiber_clad_material: float = nSiO2,\n    nwg: float = nSi,\n    nslab: Optional[float] = None,\n    clad_material: float = nSiO2,\n    nbox: float = nSiO2,\n    nsubstrate: float = nSi,\n    pml_thickness: float = 1.0,\n    substrate_thickness: float = 1.0,\n    box_thickness: float = 2.0,\n    core_thickness: float = 220 * nm,\n    slab_thickness: float = 150 * nm,\n    top_clad_thickness: float = 2.0,\n    air_gap_thickness: float = 1.0,\n    fiber_thickness: float = 2.0,\n    resolution: int = 64,  # pixels/um\n    wavelength_start: float = 1.4,\n    wavelength_stop: float = 1.7,\n    wavelength_points: int = 150,\n    decay_by: float = 1e-3,\n    eps_averaging: bool = False,\n    fiber_port_y_offset_from_air: float = 1,\n    waveguide_port_x_offset_from_grating_start: float = 10,\n    fiber_port_x_size: Optional[float] = None,\n    xmargin: float = 10.0,\n) -> Dict[str, Any]:\n    r\"\"\"Returns simulation results from grating coupler with fiber.\n\n    na**2 = core_material**2 - clad_material**2\n    core_material = sqrt(na**2 + core_material**2)\n\n    Args:\n        period: fiber grating period in um.\n        fill_factor: fraction of the grating period filled with the grating material.\n        n_periods: number of periods.\n        widths: Optional list of widths. Overrides period, fill_factor, n_periods.\n        gaps: Optional list of gaps. Overrides period, fill_factor, n_periods.\n        fiber_angle_deg: fiber angle in degrees.\n        fiber_xposition: xposition.\n        fiber_core_diameter: fiber diameter. 10.4 for Cband and 9.2um for Oband.\n        fiber_numerical_aperture: NA.\n        fiber_clad_material: fiber cladding index.\n        nwg: waveguide index.\n        nslab: slab refractive index.\n        clad_material: top cladding index.\n        nbox: box index bottom.\n        nsubstrate: index substrate.\n        pml_thickness: pml_thickness (um).\n        substrate_thickness: substrate_thickness (um).\n        box_thickness: thickness for bottom cladding (um).\n        core_thickness: core_thickness (um).\n        slab_thickness: slab thickness (um). etch_depth=core_thickness-slab_thickness.\n        top_clad_thickness: thickness of the top cladding.\n        air_gap_thickness: air gap thickness.\n        fiber_thickness: fiber_thickness.\n        resolution: resolution pixels/um.\n        wavelength_start: min wavelength (um).\n        wavelength_stop: max wavelength (um).\n        wavelength_points: wavelength points.\n        eps_averaging: epsilon averaging.\n        fiber_port_y_offset_from_air: y_offset from fiber to air (um).\n        waveguide_port_x_offset_from_grating_start: in um.\n        fiber_port_x_size: in um.\n        xmargin: margin from PML to grating end in um.\n\n\n    .. code::\n\n                fiber_xposition\n                     |\n                fiber_core_diameter\n             /     /  /     /       |\n            /     /  /     /        | fiber_thickness\n           /     /  /     /    _ _ _| _ _ _ _ _ _  _\n                                    |\n                                    | air_gap_thickness\n                               _ _ _| _ _ _ _ _ _  _\n                                    |\n                   clad_material            | top_clad_thickness\n                _   _   _      _ _ _| _ _ _ _ _ _  _\n          nwg _| |_| |_| |__________|              _\n                                    |               |\n                 nslab              |core_thickness   | slab_thickness\n                ______________ _ _ _|_ _ _ _ _ _ _ _|\n                                    |\n                 nbox               |box_thickness\n                ______________ _ _ _|_ _ _ _ _ _ _ _\n                                    |\n                 nsubstrate         |substrate_thickness\n                ______________ _ _ _|\n\n    |--------------------|<-------->\n                            xmargin\n\n    \"\"\"\n    wavelengths = np.linspace(wavelength_start, wavelength_stop, wavelength_points)\n    wavelength = np.mean(wavelengths)\n    freqs = 1 / wavelengths\n    widths = widths or n_periods * [period * fill_factor]\n    gaps = gaps or n_periods * [period * (1 - fill_factor)]\n    nslab = nslab or nwg\n\n    settings = dict(\n        widths=widths,\n        gaps=gaps,\n        n_periods=n_periods,\n        nslab=nslab,\n        fiber_angle_deg=fiber_angle_deg,\n        fiber_xposition=fiber_xposition,\n        fiber_core_diameter=fiber_core_diameter,\n        fiber_numerical_aperture=fiber_numerical_aperture,\n        fiber_clad_material=fiber_clad_material,\n        nwg=nwg,\n        clad_material=clad_material,\n        nbox=nbox,\n        nsubstrate=nsubstrate,\n        pml_thickness=pml_thickness,\n        substrate_thickness=substrate_thickness,\n        box_thickness=box_thickness,\n        core_thickness=core_thickness,\n        top_clad_thickness=top_clad_thickness,\n        air_gap_thickness=air_gap_thickness,\n        fiber_thickness=fiber_thickness,\n        resolution=resolution,\n        wavelength_start=wavelength_start,\n        wavelength_stop=wavelength_stop,\n        wavelength_points=wavelength_points,\n        decay_by=decay_by,\n        eps_averaging=eps_averaging,\n        fiber_port_y_offset_from_air=fiber_port_y_offset_from_air,\n        waveguide_port_x_offset_from_grating_start=waveguide_port_x_offset_from_grating_start,\n        fiber_port_x_size=fiber_port_x_size,\n    )\n    settings_string = clean_value(settings)\n    settings_hash = hashlib.md5(settings_string.encode()).hexdigest()[:8]\n\n    # Angle in radians\n    fiber_angle = np.radians(fiber_angle_deg)\n\n    # Z (Y)-domain\n    sz = (\n        +pml_thickness\n        + substrate_thickness\n        + box_thickness\n        + core_thickness\n        + top_clad_thickness\n        + air_gap_thickness\n        + fiber_thickness\n        + pml_thickness\n    )\n    # XY (X)-domain\n    # Assume fiber port dominates\n    fiber_port_y = (\n        -sz / 2\n        + core_thickness\n        + top_clad_thickness\n        + air_gap_thickness\n        + fiber_port_y_offset_from_air\n    )\n    fiber_port_x_offset_from_angle = np.abs(fiber_port_y * np.tan(fiber_angle))\n    length_grating = np.sum(widths) + np.sum(gaps)\n    sxy = (\n        2 * xmargin\n        + 2 * pml_thickness\n        + 2 * fiber_port_x_offset_from_angle\n        + length_grating\n    )\n\n    # Materials from indices\n    slab_material = mp.Medium(index=nslab)\n    wg_material = mp.Medium(index=nwg)\n    top_clad_material = mp.Medium(index=clad_material)\n    bottom_clad_material = mp.Medium(index=nbox)\n    fiber_core_material = (\n        fiber_numerical_aperture**2 + fiber_clad_material**2\n    ) ** 0.5\n    fiber_clad_material = mp.Medium(index=fiber_clad_material)\n    fiber_core_material = mp.Medium(index=fiber_core_material)\n\n    # Useful reference point\n    grating_start = (\n        -fiber_xposition\n    )  # Since fiber dominates, keep it centered and offset the grating\n\n    # Initialize domain x-z plane simulation\n    cell_size = mp.Vector3(sxy, sz)\n\n    # Ports (position, sizes, directions)\n    fiber_port_y = -sz / 2 + (\n        +pml_thickness\n        + substrate_thickness\n        + box_thickness\n        + core_thickness\n        + top_clad_thickness\n        + air_gap_thickness\n        + fiber_port_y_offset_from_air\n    )\n    fiber_port_center = mp.Vector3(fiber_port_x_offset_from_angle, fiber_port_y)\n    fiber_port_x_size = fiber_port_x_size or 3.5 * fiber_core_diameter\n    fiber_port_size = mp.Vector3(fiber_port_x_size, 0, 0)\n    # fiber_port_direction = mp.Vector3(y=-1).rotate(mp.Vector3(z=1), -1 * fiber_angle)\n\n    waveguide_port_y = -sz / 2 + (\n        +pml_thickness\n        + substrate_thickness\n        + box_thickness / 2\n        + core_thickness / 2\n        + top_clad_thickness / 2\n    )\n    waveguide_port_x = grating_start - waveguide_port_x_offset_from_grating_start\n    waveguide_port_center = mp.Vector3(\n        waveguide_port_x, waveguide_port_y\n    )  # grating_start - dtaper, 0)\n    waveguide_port_size = mp.Vector3(\n        0, box_thickness + core_thickness / 2 + top_clad_thickness\n    )\n    waveguide_port_direction = mp.X\n\n    # Geometry\n    fiber_clad = 120\n    hfiber_geom = 200  # Some large number to make fiber extend into PML\n\n    geometry = [\n        mp.Block(\n            material=fiber_clad_material,\n            center=mp.Vector3(0, waveguide_port_y - core_thickness / 2),\n            size=mp.Vector3(fiber_clad, hfiber_geom),\n            e1=mp.Vector3(x=1).rotate(mp.Vector3(z=1), -1 * fiber_angle),\n            e2=mp.Vector3(y=1).rotate(mp.Vector3(z=1), -1 * fiber_angle),\n        )\n    ]\n\n    geometry.append(\n        mp.Block(\n            material=fiber_core_material,\n            center=mp.Vector3(x=0),\n            size=mp.Vector3(fiber_core_diameter, hfiber_geom),\n            e1=mp.Vector3(x=1).rotate(mp.Vector3(z=1), -1 * fiber_angle),\n            e2=mp.Vector3(y=1).rotate(mp.Vector3(z=1), -1 * fiber_angle),\n        )\n    )\n\n    # Air gap\n    geometry.append(\n        mp.Block(\n            material=mp.air,\n            center=mp.Vector3(\n                0,\n                -sz / 2\n                + (\n                    +pml_thickness\n                    + substrate_thickness\n                    + box_thickness\n                    + core_thickness\n                    + top_clad_thickness\n                    + air_gap_thickness / 2\n                ),\n            ),\n            size=mp.Vector3(mp.inf, air_gap_thickness),\n        )\n    )\n    # Top cladding\n    geometry.append(\n        mp.Block(\n            material=top_clad_material,\n            center=mp.Vector3(\n                0,\n                -sz / 2\n                + (\n                    +pml_thickness\n                    + substrate_thickness\n                    + box_thickness\n                    + core_thickness / 2\n                    + top_clad_thickness / 2\n                ),\n            ),\n            size=mp.Vector3(mp.inf, core_thickness + top_clad_thickness),\n        )\n    )\n    # Bottom cladding\n    geometry.append(\n        mp.Block(\n            material=bottom_clad_material,\n            center=mp.Vector3(\n                0,\n                -sz / 2 + (+pml_thickness + substrate_thickness + box_thickness / 2),\n            ),\n            size=mp.Vector3(mp.inf, box_thickness),\n        )\n    )\n\n    # slab\n    geometry.append(\n        mp.Block(\n            material=slab_material,\n            center=mp.Vector3(\n                0,\n                -sz / 2\n                + (\n                    +pml_thickness\n                    + substrate_thickness\n                    + box_thickness\n                    + slab_thickness / 2\n                ),\n            ),\n            size=mp.Vector3(mp.inf, slab_thickness),\n        )\n    )\n\n    etch_depth = core_thickness - slab_thickness\n    x = grating_start\n\n    # grating teeth\n    for width, gap in zip(widths, gaps):\n        geometry.append(\n            mp.Block(\n                material=wg_material,\n                center=mp.Vector3(\n                    x + gap / 2,\n                    -sz / 2\n                    + (\n                        +pml_thickness\n                        + substrate_thickness\n                        + box_thickness\n                        + core_thickness\n                        - etch_depth / 2\n                    ),\n                ),\n                size=mp.Vector3(width, etch_depth),\n            )\n        )\n        x += width + gap\n\n    # waveguide\n    geometry.append(\n        mp.Block(\n            material=wg_material,\n            center=mp.Vector3(\n                -sxy / 2,\n                -sz / 2\n                + (\n                    +pml_thickness\n                    + substrate_thickness\n                    + box_thickness\n                    + core_thickness\n                    - etch_depth / 2\n                ),\n            ),\n            size=mp.Vector3(sxy, etch_depth),\n        )\n    )\n\n    # Substrate\n    geometry.append(\n        mp.Block(\n            material=mp.Medium(index=nsubstrate),\n            center=mp.Vector3(0, -sz / 2 + pml_thickness / 2 + substrate_thickness / 2),\n            size=mp.Vector3(mp.inf, pml_thickness + substrate_thickness),\n        )\n    )\n\n    # PMLs\n    boundary_layers = [mp.PML(pml_thickness)]\n\n    # mode frequency\n    fcen = 1 / wavelength\n    fwidth = 0.2 * fcen\n\n    # Waveguide source\n    sources_directions = [mp.X]\n    sources = [\n        mp.EigenModeSource(\n            src=mp.GaussianSource(frequency=fcen, fwidth=fwidth),\n            size=waveguide_port_size,\n            center=waveguide_port_center,\n            eig_band=1,\n            direction=sources_directions[0],\n            eig_match_freq=True,\n            eig_parity=mp.ODD_Z,\n        )\n    ]\n\n    # Ports\n    waveguide_monitor_port = mp.ModeRegion(\n        center=waveguide_port_center + mp.Vector3(x=0.2), size=waveguide_port_size\n    )\n    fiber_monitor_port = mp.ModeRegion(\n        center=fiber_port_center - mp.Vector3(y=0.2), size=fiber_port_size\n    )\n\n    sim = mp.Simulation(\n        resolution=resolution,\n        cell_size=cell_size,\n        boundary_layers=boundary_layers,\n        geometry=geometry,\n        sources=sources,\n        dimensions=2,\n        eps_averaging=eps_averaging,\n    )\n    waveguide_monitor = sim.add_mode_monitor(\n        freqs, waveguide_monitor_port, yee_grid=True\n    )\n    fiber_monitor = sim.add_mode_monitor(freqs, fiber_monitor_port)\n    field_monitor_point = (0, 0, 0)\n\n    return dict(\n        sim=sim,\n        cell_size=cell_size,\n        freqs=freqs,\n        fcen=fcen,\n        waveguide_monitor=waveguide_monitor,\n        waveguide_port_direction=waveguide_port_direction,\n        fiber_monitor=fiber_monitor,\n        fiber_angle_deg=fiber_angle_deg,\n        sources=sources,\n        field_monitor_point=field_monitor_point,\n        initialized=False,\n        settings=settings,\n        settings_hash=settings_hash,\n    )", "\n\ndef get_port_1D_eigenmode(\n    sim_dict,\n    band_num: int = 1,\n    fiber_angle_deg: float = 15.0,\n):\n    \"\"\"Args are the following.\n\n        sim_dict: simulation dict\n        band_num: band number to solve for\n\n    Returns:\n        Mode object compatible with /modes plugin\n    \"\"\"\n    # Initialize\n    sim = sim_dict[\"sim\"]\n    source = sim_dict[\"sources\"][0]\n    waveguide_monitor = sim_dict[\"waveguide_monitor\"]\n    fiber_monitor = sim_dict[\"fiber_monitor\"]\n\n    # Obtain source frequency\n    fsrc = source.src.frequency\n\n    # Obtain xsection\n    center_fiber = fiber_monitor.regions[0].center\n    size_fiber = fiber_monitor.regions[0].size\n    center_waveguide = waveguide_monitor.regions[0].center\n    size_waveguide = waveguide_monitor.regions[0].size\n\n    # Solve for the modes\n    if sim_dict[\"initialized\"] is False:\n        sim.init_sim()\n        sim_dict[\"initialized\"] = True\n\n    # Waveguide\n    eigenmode_waveguide = sim.get_eigenmode(\n        direction=mp.X,\n        where=mp.Volume(center=center_waveguide, size=size_waveguide),\n        band_num=band_num,\n        kpoint=mp.Vector3(\n            fsrc * 3.48, 0, 0\n        ),  # Hardcoded index for now, pull from simulation eventually\n        frequency=fsrc,\n    )\n    ys_waveguide = np.linspace(\n        center_waveguide.y - size_waveguide.y / 2,\n        center_waveguide.y + size_waveguide.y / 2,\n        int(sim.resolution * size_waveguide.y),\n    )\n    x_waveguide = center_waveguide.x\n\n    # Fiber\n    eigenmode_fiber = sim.get_eigenmode(\n        direction=mp.NO_DIRECTION,\n        where=mp.Volume(center=center_fiber, size=size_fiber),\n        band_num=band_num,\n        kpoint=mp.Vector3(0, fsrc * 1.45, 0).rotate(\n            mp.Vector3(z=1), -1 * np.radians(fiber_angle_deg)\n        ),  # Hardcoded index for now, pull from simulation eventually\n        frequency=fsrc,\n    )\n    xs_fiber = np.linspace(\n        center_fiber.x - size_fiber.x / 2,\n        center_fiber.x + size_fiber.x / 2,\n        int(sim.resolution * size_fiber.x),\n    )\n    y_fiber = center_fiber.y\n\n    return (\n        x_waveguide,\n        ys_waveguide,\n        eigenmode_waveguide,\n        xs_fiber,\n        y_fiber,\n        eigenmode_fiber,\n    )", "\n\ndef plot(sim, eps_parameters=None) -> None:\n    \"\"\"sim: simulation object.\"\"\"\n    sim.plot2D(eps_parameters=eps_parameters)\n    # plt.colorbar()\n\n\nif __name__ == \"__main__\":\n    import matplotlib.pyplot as plt\n\n    # Plotting\n    epsilons = [1, 1.43482, 1.44, 1.44427, 3.47]\n\n    eps_parameters = {\"contour\": True, \"levels\": np.unique(epsilons)}\n    fiber_na = float(np.sqrt(1.44427**2 - 1.43482**2))\n\n    sim_dict = get_simulation_grating_fiber(\n        # grating parameters\n        period=0.66,\n        fill_factor=0.5,\n        n_periods=30,\n        # fiber parameters,\n        fiber_angle_deg=20.0,\n        fiber_xposition=0.0,\n        fiber_core_diameter=9,\n        fiber_numerical_aperture=fiber_na,\n        fiber_clad_material=nSiO2,\n        # material parameters\n        nwg=3.47,\n        clad_material=1.44,\n        nbox=1.44,\n        nsubstrate=3.47,\n        # stack parameters\n        pml_thickness=1.0,\n        substrate_thickness=1.0,\n        box_thickness=2.0,\n        core_thickness=220 * nm,\n        top_clad_thickness=2.0,\n        air_gap_thickness=1.0,\n        fiber_thickness=2.0,\n        # simulation parameters\n        resolution=50,\n    )\n    plot(sim_dict[\"sim\"], eps_parameters=eps_parameters)\n    # plot(sim_dict[\"sim\"])\n    plt.show()", "if __name__ == \"__main__\":\n    import matplotlib.pyplot as plt\n\n    # Plotting\n    epsilons = [1, 1.43482, 1.44, 1.44427, 3.47]\n\n    eps_parameters = {\"contour\": True, \"levels\": np.unique(epsilons)}\n    fiber_na = float(np.sqrt(1.44427**2 - 1.43482**2))\n\n    sim_dict = get_simulation_grating_fiber(\n        # grating parameters\n        period=0.66,\n        fill_factor=0.5,\n        n_periods=30,\n        # fiber parameters,\n        fiber_angle_deg=20.0,\n        fiber_xposition=0.0,\n        fiber_core_diameter=9,\n        fiber_numerical_aperture=fiber_na,\n        fiber_clad_material=nSiO2,\n        # material parameters\n        nwg=3.47,\n        clad_material=1.44,\n        nbox=1.44,\n        nsubstrate=3.47,\n        # stack parameters\n        pml_thickness=1.0,\n        substrate_thickness=1.0,\n        box_thickness=2.0,\n        core_thickness=220 * nm,\n        top_clad_thickness=2.0,\n        air_gap_thickness=1.0,\n        fiber_thickness=2.0,\n        # simulation parameters\n        resolution=50,\n    )\n    plot(sim_dict[\"sim\"], eps_parameters=eps_parameters)\n    # plot(sim_dict[\"sim\"])\n    plt.show()", ""]}
{"filename": "kplugins/kmeep/get_port_eigenmode.py", "chunked_list": ["from __future__ import annotations\n\nimport matplotlib.pyplot as plt\nimport meep as mp\nimport numpy as np\n\nfrom kgeneric.cells import waveguide\nfrom kplugins.gmeep import get_simulation\nfrom kplugins.modes.types import Mode\n", "from kplugins.modes.types import Mode\n\n'''\n\ndef get_domain_measurements(sim, output_plane, frequency, resolution=0):\n    \"\"\"\n    Modified from meep/python/visualization.py plot_eps\n    CURRENTLY UNUSED -- will be useful once the MEEP conda packages are updates to latest source\n    Could also modify the epsilon plotting of mode to be override by plot_xsection, which already works\n    \"\"\"", "    Could also modify the epsilon plotting of mode to be override by plot_xsection, which already works\n    \"\"\"\n    # Get domain measurements\n    sim_center, sim_size = get_2D_dimensions(sim, output_plane)\n\n    xmin = sim_center.x - sim_size.x / 2\n    xmax = sim_center.x + sim_size.x / 2\n    ymin = sim_center.y - sim_size.y / 2\n    ymax = sim_center.y + sim_size.y / 2\n    zmin = sim_center.z - sim_size.z / 2", "    ymax = sim_center.y + sim_size.y / 2\n    zmin = sim_center.z - sim_size.z / 2\n    zmax = sim_center.z + sim_size.z / 2\n\n    grid_resolution = resolution if resolution else sim.resolution\n    Nx = int((xmax - xmin) * grid_resolution + 1)\n    Ny = int((ymax - ymin) * grid_resolution + 1)\n    Nz = int((zmax - zmin) * grid_resolution + 1)\n\n    if sim_size.x == 0:", "\n    if sim_size.x == 0:\n        # Plot y on x axis, z on y axis (YZ plane)\n        xtics = np.array([sim_center.x])\n        ytics = np.linspace(ymin, ymax, Ny)\n        ztics = np.linspace(zmin, zmax, Nz)\n    elif sim_size.y == 0:\n        # Plot x on x axis, z on y axis (XZ plane)\n        xtics = np.linspace(xmin, xmax, Nx)\n        ytics = np.array([sim_center.y])", "        xtics = np.linspace(xmin, xmax, Nx)\n        ytics = np.array([sim_center.y])\n        ztics = np.linspace(zmin, zmax, Nz)\n    elif sim_size.z == 0:\n        # Plot x on x axis, y on y axis (XY plane)\n        xtics = np.linspace(xmin, xmax, Nx)\n        ytics = np.linspace(ymin, ymax, Ny)\n        ztics = np.array([sim_center.z])\n    else:\n        raise ValueError(\"A 2D plane has not been specified...\")", "    else:\n        raise ValueError(\"A 2D plane has not been specified...\")\n\n    eps_data = np.rot90(np.real(sim.get_epsilon_grid(xtics, ytics, ztics, frequency)))\n    return eps_data\n'''\n\n\ndef get_port_2Dx_eigenmode(\n    sim_dict,\n    source_index=0,\n    port_name=\"o1\",\n    band_num=1,\n    choose_yz=False,\n    y=0,\n    z=0,\n):\n    \"\"\"NOTE: currently only handles ports normal to x-direction.\n\n    Args:\n        sim_dict: simulation dict\n        source_index: source index (to pull from sim_dict)\n        port_name: port name corresponding to mode_monitor to inspect\n        band_num: band number to solve for\n        choose_yz: whether y-z samples are generated or provided\n        y: y array (if choose_yz is True)\n        z: z array (if choose_yz is True)\n\n    Returns:\n        Mode object compatible with /modes plugin\n    \"\"\"\n    # Initialize\n    sim = sim_dict[\"sim\"]\n    source = sim_dict[\"sources\"][source_index]\n    mode_monitor = sim_dict[\"monitors\"][port_name]\n\n    # Obtain source frequency\n    fsrc = source.src.frequency\n\n    # Obtain xsection\n    center = mode_monitor.regions[0].center\n    size = mode_monitor.regions[0].size\n\n    \"\"\"\n    CURRENTLY UNUSED -- will be useful once the MEEP conda packages are updates to latest source\n    # output_plane = mp.Volume(center=center, size=size)\n    # Get best guess for kvector\n    # eps_data = get_domain_measurements(\n    #     sim, output_plane, fsrc, resolution=1 / (y[1] - y[0]) if y else 0\n    # )\n    # n = np.sqrt(np.max(eps_data))\n    \"\"\"\n\n    # Solve for the modes\n    if sim_dict[\"initialized\"] is False:\n        sim.init_sim()\n        sim_dict[\"initialized\"] = True\n\n    eigenmode = sim.get_eigenmode(\n        direction=mp.X,\n        where=mp.Volume(center=center, size=size),\n        band_num=band_num,\n        kpoint=mp.Vector3(\n            fsrc * 3.45, 0, 0\n        ),  # Hardcoded index for now, pull from simulation eventually\n        frequency=fsrc,\n    )\n\n    # The output of this function is slightly different then MPB (there is no mode_solver object)\n    # Format like the Mode objects in kfactory/simulation/modes to reuse modes' functions\n    if not choose_yz:\n        ny = int(size.y * sim.resolution)\n        nz = int(size.z * sim.resolution)\n        y = np.linspace(\n            center.y - size.y / 2, center.y + size.y / 2, ny\n        )  # eigenmode solver and sim res are technically different\n        z = np.linspace(center.z - size.z / 2, center.z + size.z / 2, nz)\n    yy, zz = np.meshgrid(y, z, indexing=\"ij\")\n    E = np.zeros([ny, nz, 1, 3], dtype=np.cdouble)\n    H = np.zeros([ny, nz, 1, 3], dtype=np.cdouble)\n    for i in range(ny):\n        for j in range(nz):\n            E[i, j, 0, 0] = eigenmode.amplitude(\n                mp.Vector3(center.x, yy[i, j], zz[i, j]), mp.Ex\n            )\n            E[i, j, 0, 1] = eigenmode.amplitude(\n                mp.Vector3(center.x, yy[i, j], zz[i, j]), mp.Ey\n            )\n            E[i, j, 0, 2] = eigenmode.amplitude(\n                mp.Vector3(center.x, yy[i, j], zz[i, j]), mp.Ez\n            )\n            H[i, j, 0, 0] = eigenmode.amplitude(\n                mp.Vector3(center.x, yy[i, j], zz[i, j]), mp.Hx\n            )\n            H[i, j, 0, 1] = eigenmode.amplitude(\n                mp.Vector3(center.x, yy[i, j], zz[i, j]), mp.Hy\n            )\n            H[i, j, 0, 2] = eigenmode.amplitude(\n                mp.Vector3(center.x, yy[i, j], zz[i, j]), mp.Hz\n            )\n\n    return Mode(\n        mode_number=band_num,\n        neff=eigenmode.k.x / fsrc,\n        wavelength=1 / fsrc,\n        ng=None,  # Not currently supported\n        E=E,\n        H=H,\n        eps=None,  # Eventually return the index distribution for co-plotting\n        y=y,\n        z=z,\n    )", "def get_port_2Dx_eigenmode(\n    sim_dict,\n    source_index=0,\n    port_name=\"o1\",\n    band_num=1,\n    choose_yz=False,\n    y=0,\n    z=0,\n):\n    \"\"\"NOTE: currently only handles ports normal to x-direction.\n\n    Args:\n        sim_dict: simulation dict\n        source_index: source index (to pull from sim_dict)\n        port_name: port name corresponding to mode_monitor to inspect\n        band_num: band number to solve for\n        choose_yz: whether y-z samples are generated or provided\n        y: y array (if choose_yz is True)\n        z: z array (if choose_yz is True)\n\n    Returns:\n        Mode object compatible with /modes plugin\n    \"\"\"\n    # Initialize\n    sim = sim_dict[\"sim\"]\n    source = sim_dict[\"sources\"][source_index]\n    mode_monitor = sim_dict[\"monitors\"][port_name]\n\n    # Obtain source frequency\n    fsrc = source.src.frequency\n\n    # Obtain xsection\n    center = mode_monitor.regions[0].center\n    size = mode_monitor.regions[0].size\n\n    \"\"\"\n    CURRENTLY UNUSED -- will be useful once the MEEP conda packages are updates to latest source\n    # output_plane = mp.Volume(center=center, size=size)\n    # Get best guess for kvector\n    # eps_data = get_domain_measurements(\n    #     sim, output_plane, fsrc, resolution=1 / (y[1] - y[0]) if y else 0\n    # )\n    # n = np.sqrt(np.max(eps_data))\n    \"\"\"\n\n    # Solve for the modes\n    if sim_dict[\"initialized\"] is False:\n        sim.init_sim()\n        sim_dict[\"initialized\"] = True\n\n    eigenmode = sim.get_eigenmode(\n        direction=mp.X,\n        where=mp.Volume(center=center, size=size),\n        band_num=band_num,\n        kpoint=mp.Vector3(\n            fsrc * 3.45, 0, 0\n        ),  # Hardcoded index for now, pull from simulation eventually\n        frequency=fsrc,\n    )\n\n    # The output of this function is slightly different then MPB (there is no mode_solver object)\n    # Format like the Mode objects in kfactory/simulation/modes to reuse modes' functions\n    if not choose_yz:\n        ny = int(size.y * sim.resolution)\n        nz = int(size.z * sim.resolution)\n        y = np.linspace(\n            center.y - size.y / 2, center.y + size.y / 2, ny\n        )  # eigenmode solver and sim res are technically different\n        z = np.linspace(center.z - size.z / 2, center.z + size.z / 2, nz)\n    yy, zz = np.meshgrid(y, z, indexing=\"ij\")\n    E = np.zeros([ny, nz, 1, 3], dtype=np.cdouble)\n    H = np.zeros([ny, nz, 1, 3], dtype=np.cdouble)\n    for i in range(ny):\n        for j in range(nz):\n            E[i, j, 0, 0] = eigenmode.amplitude(\n                mp.Vector3(center.x, yy[i, j], zz[i, j]), mp.Ex\n            )\n            E[i, j, 0, 1] = eigenmode.amplitude(\n                mp.Vector3(center.x, yy[i, j], zz[i, j]), mp.Ey\n            )\n            E[i, j, 0, 2] = eigenmode.amplitude(\n                mp.Vector3(center.x, yy[i, j], zz[i, j]), mp.Ez\n            )\n            H[i, j, 0, 0] = eigenmode.amplitude(\n                mp.Vector3(center.x, yy[i, j], zz[i, j]), mp.Hx\n            )\n            H[i, j, 0, 1] = eigenmode.amplitude(\n                mp.Vector3(center.x, yy[i, j], zz[i, j]), mp.Hy\n            )\n            H[i, j, 0, 2] = eigenmode.amplitude(\n                mp.Vector3(center.x, yy[i, j], zz[i, j]), mp.Hz\n            )\n\n    return Mode(\n        mode_number=band_num,\n        neff=eigenmode.k.x / fsrc,\n        wavelength=1 / fsrc,\n        ng=None,  # Not currently supported\n        E=E,\n        H=H,\n        eps=None,  # Eventually return the index distribution for co-plotting\n        y=y,\n        z=z,\n    )", "\n\nif __name__ == \"__main__\":\n    c = waveguide(length=2, width=0.5, layer=0)\n    c.add_padding(default=0, bottom=3, top=3, layers=[(100, 0)])\n\n    sim_dict = get_simulation(\n        c,\n        is_3d=True,\n        res=50,\n        port_source_offset=-0.1,\n        port_field_monitor_offset=-0.1,\n        port_margin=2.5,\n    )\n\n    m1_MEEP = get_port_2Dx_eigenmode(\n        sim_dict=sim_dict,\n        source_index=0,\n        port_name=\"o1\",\n    )\n    print(m1_MEEP.neff)\n    m1_MEEP.plot_hy()\n    m1_MEEP.plot_hx()\n    m1_MEEP.plot_hz()\n    plt.show()", ""]}
{"filename": "kplugins/kmeep/write_sparameters_meep_batch.py", "chunked_list": ["\"\"\"Compute and write Sparameters using Meep in an MPI pool.\"\"\"\n\nfrom __future__ import annotations\n\nfrom functools import partial\nimport multiprocessing\nimport pathlib\nimport shutil\nimport time\nfrom pathlib import Path", "import time\nfrom pathlib import Path\nfrom pprint import pprint\nfrom typing import Dict, List, Optional\n\nimport numpy as np\nimport pydantic\nfrom tqdm.auto import tqdm\n\nimport kfactory as gf", "\nimport kfactory as gf\nfrom kfactory import KCell\nfrom kfactory.conf import logger\nfrom kgeneric import pdk\nimport kgeneric as kg\nfrom kplugins import port_symmetries\nfrom kplugins.get_sparameters_path import (\n    get_sparameters_path_meep as get_sparameters_path,\n)", "    get_sparameters_path_meep as get_sparameters_path,\n)\nfrom kplugins.gmeep.write_sparameters_meep import remove_simulation_kwargs\nfrom kplugins.gmeep.write_sparameters_meep_mpi import (\n    write_sparameters_meep_mpi,\n)\nfrom kfactory.technology import LayerStack\n\ncore_materials = multiprocessing.cpu_count()\n", "core_materials = multiprocessing.cpu_count()\n\ntemp_dir_default = Path(\"./sparameters\") / \"temp\"\n\n\n@pydantic.validate_arguments\ndef write_sparameters_meep_batch(\n    jobs: List[Dict],\n    cores_per_run: int = 2,\n    total_cores: int = 4,\n    temp_dir: Path = temp_dir_default,\n    delete_temp_files: bool = True,\n    dirpath: Optional[Path] = None,\n    layer_stack: Optional[LayerStack] = None,\n    **kwargs,\n) -> List[Path]:\n    \"\"\"Write Sparameters for a batch of jobs using MPI and returns results filepaths.\n\n    Given a list of write_sparameters_meep keyword arguments `jobs` launches them in\n    different cores using MPI where each simulation runs with `cores_per_run` cores.\n    If there are more simulations than cores each batch runs sequentially.\n\n\n    Args\n        jobs: list of Dicts containing the simulation settings for each job.\n            for write_sparameters_meep.\n        cores_per_run: number of processors to assign to each component simulation.\n        total_cores: total number of cores to use.\n        temp_dir: temporary directory to hold simulation files.\n        delete_temp_files: deletes temp_dir when done.\n        dirpath: directory to store Sparameters.\n        layer_stack: contains layer to thickness, zmin and material.\n            Defaults to active pdk.layer_stack.\n\n    keyword Args:\n        resolution: in pixels/um (30: for coarse, 100: for fine).\n        port_symmetries: Dict to specify port symmetries, to save number of simulations.\n        dirpath: directory to store Sparameters.\n        port_margin: margin on each side of the port.\n        port_monitor_offset: offset between monitor GDS port and monitor MEEP port.\n        port_source_offset: offset between source GDS port and source MEEP port.\n        filepath: to store pandas Dataframe with Sparameters in CSV format..\n        animate: saves a MP4 images of the simulation for inspection, and also\n            outputs during computation. The name of the file is the source index.\n        lazy_parallelism: toggles the flag \"meep.divide_parallel_processes\" to\n            perform the simulations with different sources in parallel.\n        dispersive: use dispersive models for materials (requires higher resolution).\n        xmargin: left and right distance from component to PML.\n        xmargin_left: west distance from component to PML.\n        xmargin_right: east distance from component to PML.\n        ymargin: top and bottom distance from component to PML.\n        ymargin_top: north distance from component to PML.\n        ymargin_bot: south distance from component to PML.\n        extend_ports_length: to extend ports beyond the PML\n        layer_stack: Dict of layer number (int, int) to thickness (um).\n        zmargin_top: thickness for cladding above core.\n        zmargin_bot: thickness for cladding below core.\n        tpml: PML thickness (um).\n        clad_material: material for cladding.\n        is_3d: if True runs in 3D.\n        wavelength_start: wavelength min (um).\n        wavelength_stop: wavelength max (um).\n        wavelength_points: wavelength steps.\n        dfcen: delta frequency.\n        port_source_name: input port name.\n        port_margin: margin on each side of the port.\n        distance_source_to_monitors: in (um) source goes before.\n        port_source_offset: offset between source GDS port and source MEEP port.\n        port_monitor_offset: offset between monitor GDS port and monitor MEEP port.\n\n    Returns:\n        filepath list for sparameters numpy saved files (wavelengths, o1@0,o2@0, ...).\n\n    \"\"\"\n    layer_stack = layer_stack or pdk.layer_stack\n\n    # Parse jobs\n    jobs_to_run = []\n    for job in jobs:\n        cell = job[\"cell\"]\n        cell = pdk.get_cell(cell)\n        assert isinstance(cell, KCell)\n        settings = remove_simulation_kwargs(kwargs)\n        filepath = job.get(\n            \"filepath\",\n            get_sparameters_path(\n                component=cell,\n                dirpath=dirpath,\n                layer_stack=layer_stack,\n                **settings,\n            ),\n        )\n        if filepath.exists():\n            job.update(**kwargs)\n            if job.get(\"overwrite\", kwargs.get(\"overwrite\", False)):\n                pathlib.Path.unlink(filepath)\n                logger.info(\n                    f\"Simulation {filepath!r} found and overwrite is True. \"\n                    \"Deleting file and adding it to the queue.\"\n                )\n                jobs_to_run.append(job)\n            else:\n                logger.info(\n                    f\"Simulation {filepath!r} found exists and \"\n                    \"overwrite is False. Removing it from the queue.\"\n                )\n        else:\n            logger.info(f\"Simulation {filepath!r} not found. Adding it to the queue\")\n            jobs_to_run.append(job)\n\n    jobs = jobs_to_run\n\n    batches = int(np.ceil(cores_per_run * len(jobs) / total_cores))\n    jobs_per_batch = int(np.floor(total_cores / cores_per_run))\n    njobs = len(jobs)\n    logger.info(f\"Running {njobs} simulations\")\n    logger.info(f\"total_cores = {total_cores} with cores_per_run = {cores_per_run}\")\n    logger.info(f\"Running {batches} batches with up to {jobs_per_batch} jobs each.\")\n\n    i = 0\n    # For each batch in the pool\n    for j in tqdm(range(batches)):\n        filepaths = []\n\n        # For each job in the batch\n        for k in range(jobs_per_batch):\n            if i >= njobs:\n                continue\n            logger.info(f\"Task {k} of batch {j} is job {i}\")\n\n            # Obtain current job\n            simulations_settings = jobs[i]\n\n            pprint(simulations_settings)\n\n            filepath = write_sparameters_meep_mpi(\n                cores=cores_per_run,\n                temp_dir=temp_dir,\n                temp_file_str=f\"write_sparameters_meep_mpi_{i}\",\n                wait_to_finish=False,\n                **simulations_settings,\n            )\n            filepaths.append(filepath)\n\n            # Increment task number\n            i += 1\n\n        # Wait for batch to end\n        done = False\n        num_pool_jobs = len(filepaths)\n        while not done:\n            # Check if all jobs finished\n            jobs_done = sum(1 for filepath in filepaths if filepath.exists())\n            if jobs_done == num_pool_jobs:\n                done = True\n            else:\n                time.sleep(1)\n\n    temp_dir = pathlib.Path(temp_dir)\n    if temp_dir.exists() and delete_temp_files:\n        shutil.rmtree(temp_dir)\n    return filepaths", "\n\nwrite_sparameters_meep_batch_1x1 = partial(\n    write_sparameters_meep_batch, port_symmetries=port_symmetries.port_symmetries_1x1\n)\n\nwrite_sparameters_meep_batch_1x1_bend90 = partial(\n    write_sparameters_meep_batch,\n    port_symmetries=port_symmetries.port_symmetries_1x1,\n    ymargin=0,", "    port_symmetries=port_symmetries.port_symmetries_1x1,\n    ymargin=0,\n    ymargin_bot=3,\n    xmargin_right=3,\n)\n\n\nif __name__ == \"__main__\":\n    jobs = [\n        {\n            \"component\": kg.cells.waveguide(width=0.5, length=i, layer=0),\n            \"run\": True,\n            \"overwrite\": True,\n            \"lazy_parallelism\": False,\n            \"ymargin\": 3,\n        }\n        for i in range(1, 4)\n    ]\n\n    filepaths = write_sparameters_meep_batch(\n        jobs=jobs,\n        cores_per_run=4,\n        total_cores=8,\n    )", ""]}
{"filename": "kplugins/kmeep/test_eigenmode.py", "chunked_list": ["\"\"\"Compares the modes of a kfactory + MEEP waveguide cross-section vs a\ndirect MPB calculation.\"\"\"\n\nfrom __future__ import annotations\n\nimport h5py\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.interpolate import griddata\n", "from scipy.interpolate import griddata\n\nfrom kgeneric.cells import waveguide\nfrom kgeneric.config import PATH\nfrom kplugins.gmeep import get_simulation\nfrom kplugins.gmeep.get_port_eigenmode import get_port_2Dx_eigenmode\nfrom kplugins.modes import find_modes_waveguide, get_mode_solver_rib\nfrom kplugins.modes.types import Mode\n\n\ndef lumerical_parser(E_1D, H_1D, y_1D, z_1D, res=50, z_offset=0.11 * 1e-6):\n    \"\"\"Converts 1D arrays of fields to 2D arrays according to positions.\n\n    Lumerical data is in 1D arrays, and over a nonregular mesh\n\n    Args\n        E_1D: E array from Lumerical.\n        H_1D: H array from Lumerical.\n        y_1D: y array from Lumerical.\n        z_1D: z array from Lumerical.\n        res: desired resolution.\n        z_offset: z offset to move the fields.\n\n    \"\"\"\n    # Make regular grid from resolution and range of domain\n    y_1D = y_1D[...].flatten()\n    z_1D = z_1D[...].flatten()\n    ny = int(np.max(y_1D) - np.min(y_1D) * 1e6 * res)\n    nz = int(np.max(z_1D) - np.min(z_1D) * 1e6 * res)\n    y = np.linspace(np.min(y_1D), np.max(y_1D), ny) * 1e6\n    z = np.linspace(np.min(z_1D), np.max(z_1D), nz) * 1e6\n    yy, zz = np.meshgrid(y, z)\n\n    # Generates points parameter ((y,z) array) for griddata\n    points = np.zeros([len(E_1D[...][0, :]), 2])\n    i = 0\n    for j in range(len(z_1D)):\n        for k in range(len(y_1D)):\n            points[i, 0] = y_1D[k] * 1e6\n            points[i, 1] = z_1D[j] * 1e6\n            i += 1\n\n    # Get interpolated field values\n    E = np.zeros([ny, nz, 1, 3], dtype=np.cdouble)\n    H = np.zeros([ny, nz, 1, 3], dtype=np.cdouble)\n    E[:, :, 0, 0] = griddata(\n        points,\n        E_1D[...][0, :][\"real\"] + 1j * E_1D[...][0, :][\"imag\"],\n        (zz, yy),\n        method=\"cubic\",\n    )\n    E[:, :, 0, 1] = griddata(\n        points,\n        E_1D[...][1, :][\"real\"] + 1j * E_1D[...][1, :][\"imag\"],\n        (zz, yy),\n        method=\"cubic\",\n    )\n    E[:, :, 0, 2] = griddata(\n        points,\n        E_1D[...][2, :][\"real\"] + 1j * E_1D[...][2, :][\"imag\"],\n        (zz, yy),\n        method=\"cubic\",\n    )\n    H[:, :, 0, 0] = griddata(\n        points,\n        H_1D[...][0, :][\"real\"] + 1j * H_1D[...][0, :][\"imag\"],\n        (zz, yy),\n        method=\"cubic\",\n    )\n    H[:, :, 0, 1] = griddata(\n        points,\n        H_1D[...][1, :][\"real\"] + 1j * H_1D[...][1, :][\"imag\"],\n        (zz, yy),\n        method=\"cubic\",\n    )\n    H[:, :, 0, 2] = griddata(\n        points,\n        H_1D[...][2, :][\"real\"] + 1j * H_1D[...][2, :][\"imag\"],\n        (zz, yy),\n        method=\"cubic\",\n    )\n\n    return E, H, y, z", "\n\ndef lumerical_parser(E_1D, H_1D, y_1D, z_1D, res=50, z_offset=0.11 * 1e-6):\n    \"\"\"Converts 1D arrays of fields to 2D arrays according to positions.\n\n    Lumerical data is in 1D arrays, and over a nonregular mesh\n\n    Args\n        E_1D: E array from Lumerical.\n        H_1D: H array from Lumerical.\n        y_1D: y array from Lumerical.\n        z_1D: z array from Lumerical.\n        res: desired resolution.\n        z_offset: z offset to move the fields.\n\n    \"\"\"\n    # Make regular grid from resolution and range of domain\n    y_1D = y_1D[...].flatten()\n    z_1D = z_1D[...].flatten()\n    ny = int(np.max(y_1D) - np.min(y_1D) * 1e6 * res)\n    nz = int(np.max(z_1D) - np.min(z_1D) * 1e6 * res)\n    y = np.linspace(np.min(y_1D), np.max(y_1D), ny) * 1e6\n    z = np.linspace(np.min(z_1D), np.max(z_1D), nz) * 1e6\n    yy, zz = np.meshgrid(y, z)\n\n    # Generates points parameter ((y,z) array) for griddata\n    points = np.zeros([len(E_1D[...][0, :]), 2])\n    i = 0\n    for j in range(len(z_1D)):\n        for k in range(len(y_1D)):\n            points[i, 0] = y_1D[k] * 1e6\n            points[i, 1] = z_1D[j] * 1e6\n            i += 1\n\n    # Get interpolated field values\n    E = np.zeros([ny, nz, 1, 3], dtype=np.cdouble)\n    H = np.zeros([ny, nz, 1, 3], dtype=np.cdouble)\n    E[:, :, 0, 0] = griddata(\n        points,\n        E_1D[...][0, :][\"real\"] + 1j * E_1D[...][0, :][\"imag\"],\n        (zz, yy),\n        method=\"cubic\",\n    )\n    E[:, :, 0, 1] = griddata(\n        points,\n        E_1D[...][1, :][\"real\"] + 1j * E_1D[...][1, :][\"imag\"],\n        (zz, yy),\n        method=\"cubic\",\n    )\n    E[:, :, 0, 2] = griddata(\n        points,\n        E_1D[...][2, :][\"real\"] + 1j * E_1D[...][2, :][\"imag\"],\n        (zz, yy),\n        method=\"cubic\",\n    )\n    H[:, :, 0, 0] = griddata(\n        points,\n        H_1D[...][0, :][\"real\"] + 1j * H_1D[...][0, :][\"imag\"],\n        (zz, yy),\n        method=\"cubic\",\n    )\n    H[:, :, 0, 1] = griddata(\n        points,\n        H_1D[...][1, :][\"real\"] + 1j * H_1D[...][1, :][\"imag\"],\n        (zz, yy),\n        method=\"cubic\",\n    )\n    H[:, :, 0, 2] = griddata(\n        points,\n        H_1D[...][2, :][\"real\"] + 1j * H_1D[...][2, :][\"imag\"],\n        (zz, yy),\n        method=\"cubic\",\n    )\n\n    return E, H, y, z", "\n\ndef MPB_eigenmode():\n    ms = get_mode_solver_rib(wg_width=0.45, sy=6, sz=6)\n    modes = find_modes_waveguide(mode_solver=ms, res=50)\n    m1_MPB = modes[1]\n    m2_MPB = modes[2]\n    return m1_MPB, m2_MPB\n\n\ndef MPB_eigenmode_toDisk() -> None:\n    m1_MPB, m2_MPB = MPB_eigenmode()\n    np.save(\"test_data/stripWG_mpb/neff1.npy\", m1_MPB.neff)\n    np.save(\"test_data/stripWG_mpb/E1.npy\", m1_MPB.E)\n    np.save(\"test_data/stripWG_mpb/H1.npy\", m1_MPB.H)\n    np.save(\"test_data/stripWG_mpb/y1.npy\", m1_MPB.y)\n    np.save(\"test_data/stripWG_mpb/z1.npy\", m1_MPB.z)\n    np.save(\"test_data/stripWG_mpb/neff2.npy\", m2_MPB.neff)\n    np.save(\"test_data/stripWG_mpb/E2.npy\", m2_MPB.E)\n    np.save(\"test_data/stripWG_mpb/H2.npy\", m2_MPB.H)\n    np.save(\"test_data/stripWG_mpb/y2.npy\", m2_MPB.y)\n    np.save(\"test_data/stripWG_mpb/z2.npy\", m2_MPB.z)", "\n\ndef MPB_eigenmode_toDisk() -> None:\n    m1_MPB, m2_MPB = MPB_eigenmode()\n    np.save(\"test_data/stripWG_mpb/neff1.npy\", m1_MPB.neff)\n    np.save(\"test_data/stripWG_mpb/E1.npy\", m1_MPB.E)\n    np.save(\"test_data/stripWG_mpb/H1.npy\", m1_MPB.H)\n    np.save(\"test_data/stripWG_mpb/y1.npy\", m1_MPB.y)\n    np.save(\"test_data/stripWG_mpb/z1.npy\", m1_MPB.z)\n    np.save(\"test_data/stripWG_mpb/neff2.npy\", m2_MPB.neff)\n    np.save(\"test_data/stripWG_mpb/E2.npy\", m2_MPB.E)\n    np.save(\"test_data/stripWG_mpb/H2.npy\", m2_MPB.H)\n    np.save(\"test_data/stripWG_mpb/y2.npy\", m2_MPB.y)\n    np.save(\"test_data/stripWG_mpb/z2.npy\", m2_MPB.z)", "\n\ndef compare_mpb_lumerical(plot=False) -> None:\n    \"\"\"\n    WARNING: Segmentation fault occurs if both ms object above and sim object exist in memory at the same time\n    Instead load results from separate MPB run\n\n    Same namespace run does not work\n    # MPB mode\n    # ms = get_mode_solver_rib(wg_width=0.5)\n    # modes = find_modes_waveguide(mode_solver=ms, res=50)\n    # m1_MPB = modes[1]\n\n    separate namespace run does not work either\n    # m1_MPB = MPB_eigenmode()\n    \"\"\"\n    # Test data\n    filepath = PATH.module_path / \"simulation\" / \"gmeep\" / \"test_data\"\n\n    # MPB calculation\n    # Load previously-computed waveguide results\n    m1_MPB_neff = np.load(filepath / \"stripWG_mpb\" / \"neff1.npy\")\n    m1_MPB_E = np.load(filepath / \"stripWG_mpb\" / \"E1.npy\")\n    m1_MPB_H = np.load(filepath / \"stripWG_mpb\" / \"H1.npy\")\n    m1_MPB_y = np.load(filepath / \"stripWG_mpb\" / \"y1.npy\")\n    m1_MPB_z = np.load(filepath / \"stripWG_mpb\" / \"z1.npy\")\n    m2_MPB_neff = np.load(filepath / \"stripWG_mpb\" / \"neff2.npy\")\n    m2_MPB_E = np.load(filepath / \"stripWG_mpb\" / \"E2.npy\")\n    m2_MPB_H = np.load(filepath / \"stripWG_mpb\" / \"H2.npy\")\n    m2_MPB_y = np.load(filepath / \"stripWG_mpb\" / \"y2.npy\")\n    m2_MPB_z = np.load(filepath / \"stripWG_mpb\" / \"z2.npy\")\n    # Package into modes object\n    m1_MPB = Mode(\n        mode_number=1,\n        neff=m1_MPB_neff,\n        wavelength=None,\n        ng=None,\n        E=m1_MPB_E,\n        H=m1_MPB_H,\n        eps=None,\n        y=m1_MPB_y,\n        z=m1_MPB_z,\n    )\n    m2_MPB = Mode(\n        mode_number=1,\n        neff=m2_MPB_neff,\n        wavelength=None,\n        ng=None,\n        E=m2_MPB_E,\n        H=m2_MPB_H,\n        eps=None,\n        y=m2_MPB_y,\n        z=m2_MPB_z,\n    )\n\n    # Load Lumerical result\n    with h5py.File(filepath / \"stripWG_lumerical\" / \"mode1.mat\", \"r\") as f:\n        E, H, y, z = lumerical_parser(\n            f[\"E\"][\"E\"], f[\"H\"][\"H\"], f[\"E\"][\"y\"], f[\"E\"][\"z\"], res=50\n        )\n        # Package into modes object\n        m1_lumerical = Mode(\n            mode_number=1,\n            neff=f[\"neff\"][0][0][0],\n            wavelength=None,\n            ng=None,\n            E=E,\n            H=H,\n            eps=None,\n            y=y,\n            z=z,\n        )\n    with h5py.File(filepath / \"stripWG_lumerical\" / \"mode2.mat\", \"r\") as f:\n        E, H, y, z = lumerical_parser(\n            f[\"E\"][\"E\"], f[\"H\"][\"H\"], f[\"E\"][\"y\"], f[\"E\"][\"z\"], res=50\n        )\n        # Package into modes object\n        m2_lumerical = Mode(\n            mode_number=1,\n            neff=f[\"neff\"][0][0][0],\n            wavelength=None,\n            ng=None,\n            E=E,\n            H=H,\n            eps=None,\n            y=y,\n            z=z,\n        )\n\n    # MEEP calculation\n    c = waveguide(length=2, width=0.45, layer=0)\n    c = c\n    # c = c.add_padding(default=0, bottom=4, top=4, layers=[(100, 0)])\n\n    sim_dict = get_simulation(\n        c,\n        is_3d=True,\n        port_source_offset=-0.1,\n        port_monitor_offset=-0.1,\n        port_margin=3,\n        resolution=50,\n    )\n\n    m1_MEEP = get_port_2Dx_eigenmode(\n        sim_dict=sim_dict,\n        source_index=0,\n        port_name=\"o1\",\n    )\n\n    m2_MEEP = get_port_2Dx_eigenmode(\n        sim_dict=sim_dict,\n        source_index=0,\n        port_name=\"o1\",\n        band_num=2,\n    )\n\n    if plot:\n        # M1, E-field\n        plt.figure(figsize=(10, 8), dpi=100)\n        plt.suptitle(\n            \"MEEP get_eigenmode / MPB find_modes_waveguide / Lumerical (manual)\",\n            y=1.05,\n            fontsize=18,\n        )\n\n        plt.subplot(3, 3, 1)\n        m1_MEEP.plot_ex(show=False, operation=np.abs, scale=False)\n\n        plt.subplot(3, 3, 2)\n        m1_MPB.plot_ex(show=False, operation=np.abs, scale=False)\n\n        plt.subplot(3, 3, 3)\n        m1_lumerical.plot_ex(show=False, operation=np.abs, scale=False)\n\n        plt.subplot(3, 3, 4)\n        m1_MEEP.plot_ey(show=False, operation=np.abs, scale=False)\n\n        plt.subplot(3, 3, 5)\n        m1_MPB.plot_ey(show=False, operation=np.abs, scale=False)\n\n        plt.subplot(3, 3, 6)\n        m1_lumerical.plot_ey(show=False, operation=np.abs, scale=False)\n\n        plt.subplot(3, 3, 7)\n        m1_MEEP.plot_ez(show=False, operation=np.abs, scale=False)\n\n        plt.subplot(3, 3, 8)\n        m1_MPB.plot_ez(show=False, operation=np.abs, scale=False)\n\n        plt.subplot(3, 3, 9)\n        m1_lumerical.plot_ez(show=False, operation=np.abs, scale=False)\n\n        plt.tight_layout()\n        plt.show()\n\n        # M1, H-field\n        plt.figure(figsize=(10, 8), dpi=100)\n        plt.suptitle(\n            \"MEEP get_eigenmode / MPB find_modes_waveguide / Lumerical (manual)\",\n            y=1.05,\n            fontsize=18,\n        )\n\n        plt.subplot(3, 3, 1)\n        m1_MEEP.plot_hx(show=False, operation=np.abs, scale=False)\n\n        plt.subplot(3, 3, 2)\n        m1_MPB.plot_hx(show=False, operation=np.abs, scale=False)\n\n        plt.subplot(3, 3, 3)\n        m1_lumerical.plot_hx(show=False, operation=np.abs, scale=False)\n\n        plt.subplot(3, 3, 4)\n        m1_MEEP.plot_hy(show=False, operation=np.abs, scale=False)\n\n        plt.subplot(3, 3, 5)\n        m1_MPB.plot_hy(show=False, operation=np.abs, scale=False)\n\n        plt.subplot(3, 3, 6)\n        m1_lumerical.plot_hy(show=False, operation=np.abs, scale=False)\n\n        plt.subplot(3, 3, 7)\n        m1_MEEP.plot_hz(show=False, operation=np.abs, scale=False)\n\n        plt.subplot(3, 3, 8)\n        m1_MPB.plot_hz(show=False, operation=np.abs, scale=False)\n\n        plt.subplot(3, 3, 9)\n        m1_lumerical.plot_hz(show=False, operation=np.abs, scale=False)\n\n        plt.tight_layout()\n        plt.show()\n\n        # # M2, E-field\n        # plt.figure(figsize=(10, 8), dpi=100)\n\n        # plt.subplot(3, 3, 1)\n        # m2_MEEP.plot_ex(show=False, operation=np.abs, scale=False)\n\n        # plt.subplot(3, 3, 2)\n        # m2_MPB.plot_ex(show=False, operation=np.abs, scale=False)\n\n        # plt.subplot(3, 3, 3)\n        # m2_lumerical.plot_ex(show=False, operation=np.abs, scale=False)\n\n        # plt.subplot(3, 3, 4)\n        # m2_MEEP.plot_ey(show=False, operation=np.abs, scale=False)\n\n        # plt.subplot(3, 3, 5)\n        # m2_MPB.plot_ey(show=False, operation=np.abs, scale=False)\n\n        # plt.subplot(3, 3, 6)\n        # m2_lumerical.plot_ey(show=False, operation=np.abs, scale=False)\n\n        # plt.subplot(3, 3, 7)\n        # m2_MEEP.plot_ez(show=False, operation=np.abs, scale=False)\n\n        # plt.subplot(3, 3, 8)\n        # m2_MPB.plot_ez(show=False, operation=np.abs, scale=False)\n\n        # plt.subplot(3, 3, 9)\n        # m2_lumerical.plot_ez(show=False, operation=np.abs, scale=False)\n\n        # plt.tight_layout()\n        # plt.show()\n\n        # # M2, H-field\n        # plt.figure(figsize=(10, 8), dpi=100)\n\n        # plt.subplot(3, 3, 1)\n        # m2_MEEP.plot_hx(show=False, operation=np.abs, scale=False)\n\n        # plt.subplot(3, 3, 2)\n        # m2_MPB.plot_hx(show=False, operation=np.abs, scale=False)\n\n        # plt.subplot(3, 3, 3)\n        # m2_lumerical.plot_hx(show=False, operation=np.abs, scale=False)\n\n        # plt.subplot(3, 3, 4)\n        # m2_MEEP.plot_hy(show=False, operation=np.abs, scale=False)\n\n        # plt.subplot(3, 3, 5)\n        # m2_MPB.plot_hy(show=False, operation=np.abs, scale=False)\n\n        # plt.subplot(3, 3, 6)\n        # m2_lumerical.plot_hy(show=False, operation=np.abs, scale=False)\n\n        # plt.subplot(3, 3, 7)\n        # m2_MEEP.plot_hz(show=False, operation=np.abs, scale=False)\n\n        # plt.subplot(3, 3, 8)\n        # m2_MPB.plot_hz(show=False, operation=np.abs, scale=False)\n\n        # plt.subplot(3, 3, 9)\n        # m2_lumerical.plot_hz(show=False, operation=np.abs, scale=False)\n\n        # plt.tight_layout()\n        # plt.show()\n\n    # Check propagation constants\n    # print(m1_MEEP.neff, m1_MPB.neff, m1_lumerical.neff)\n    # print(m2_MEEP.neff, m2_MPB.neff, m2_lumerical.neff)\n\n    # Check mode profiles\n    assert np.isclose(m1_MPB.neff, m1_lumerical.neff, atol=0.02)\n    assert np.isclose(m1_MEEP.neff, m1_MPB.neff, atol=0.02)\n    assert np.isclose(m2_MPB.neff, m2_lumerical.neff, atol=0.07)\n    assert np.isclose(m2_MEEP.neff, m2_MPB.neff, atol=0.07)", "\n    # TODO modes check\n\n\nif __name__ == \"__main__\":\n    # MPB_eigenmode_toDisk()\n    compare_mpb_lumerical(plot=False)\n"]}
{"filename": "kplugins/kmeep/write_sparameters_meep.py", "chunked_list": ["\"\"\"Compute and write Sparameters using Meep.\"\"\"\n\nfrom __future__ import annotations\n\nfrom functools import partial\nimport inspect\nimport multiprocessing\nimport pathlib\nimport time\nfrom pathlib import Path", "import time\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Optional\n\nimport meep as mp\nimport numpy as np\nimport pydantic\nfrom omegaconf import OmegaConf\nfrom tqdm.auto import tqdm\n", "from tqdm.auto import tqdm\n\nimport kfactory as gf\nfrom kfactory import Port\nfrom kfactory.kcell import KCell, clean_value\nfrom kfactory.conf import logger\nimport kgeneric as kg\nfrom kgeneric import pdk\nfrom kplugins import port_symmetries\nfrom kplugins.get_sparameters_path import (", "from kplugins import port_symmetries\nfrom kplugins.get_sparameters_path import (\n    get_sparameters_path_meep as get_sparameters_path,\n)\nfrom kplugins.gmeep.get_simulation import (\n    get_simulation,\n    settings_get_simulation,\n)\nfrom kfactory.technology import LayerStack\nfrom kfactory.typings import CellSpec, PathType", "from kfactory.technology import LayerStack\nfrom kfactory.typings import CellSpec, PathType\n\ncore_materials = multiprocessing.cpu_count()\n\n\ndef remove_simulation_kwargs(d: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Returns a copy of dict with only simulation settings.\n\n    removes all flags for the simulator itself\n    \"\"\"\n    d = d.copy()\n    d.pop(\"run\", None)\n    d.pop(\"lazy_parallelism\", None)\n    d.pop(\"overwrite\", None)\n    d.pop(\"animate\", None)\n    d.pop(\"wait_to_finish\", None)\n    d.pop(\"cores\", None)\n    d.pop(\"temp_dir\", None)\n    d.pop(\"temp_file_str\", None)\n    return d", "\n\ndef parse_port_eigenmode_coeff(port_name: str, ports: Dict[str, Port], sim_dict: Dict):\n    \"\"\"Returns the coefficients relative to whether the wavevector is entering or \\\n            exiting simulation.\n\n    Args:\n        port_index: index of port.\n        ports: component_ref.ports.\n        sim_dict: simulation dict.\n\n    \"\"\"\n    if port_name not in ports:\n        raise ValueError(f\"port = {port_name!r} not in {list(ports.keys())}.\")\n\n    orientation = ports[port_name].orientation\n\n    # Inputs\n    sim = sim_dict[\"sim\"]\n    monitors = sim_dict[\"monitors\"]\n\n    # get_eigenmode_coeff.alpha[:,:,idx]\n    # with ind being the forward or backward wave according to cell coordinates.\n    # Figure out if that is exiting the simulation or not\n    # depending on the port orientation (assuming it's near PMLs)\n    if orientation == 0:  # east\n        kpoint = mp.Vector3(x=1)\n        idx_in = 1\n        idx_out = 0\n    elif orientation == 90:  # north\n        kpoint = mp.Vector3(y=1)\n        idx_in = 1\n        idx_out = 0\n    elif orientation == 180:  # west\n        kpoint = mp.Vector3(x=1)\n        idx_in = 0\n        idx_out = 1\n    elif orientation == 270:  # south\n        kpoint = mp.Vector3(y=1)\n        idx_in = 0\n        idx_out = 1\n    else:\n        raise ValueError(\n            f\"Port orientation {orientation!r} not in 0, 90, 180, or 270 degrees!\"\n        )\n\n    # Get port coeffs\n    monitor_coeff = sim.get_eigenmode_coefficients(\n        monitors[port_name], [1], kpoint_func=lambda f, n: kpoint\n    )\n\n    coeff_in = monitor_coeff.alpha[\n        0, :, idx_in\n    ]  # ingoing (w.r.t. simulation cell) wave\n    coeff_out = monitor_coeff.alpha[\n        0, :, idx_out\n    ]  # outgoing (w.r.t. simulation cell) wave\n\n    return coeff_in, coeff_out", "\n\n@pydantic.validate_arguments\ndef write_sparameters_meep(\n    component: CellSpec,\n    port_source_names: Optional[List[str]] = None,\n    port_symmetries: Optional[Dict] = None,\n    resolution: int = 30,\n    wavelength_start: float = 1.5,\n    wavelength_stop: float = 1.6,\n    wavelength_points: int = 50,\n    dirpath: Optional[PathType] = None,\n    layer_stack: Optional[LayerStack] = None,\n    port_margin: float = 2,\n    port_monitor_offset: float = -0.1,\n    port_source_offset: float = -0.1,\n    filepath: Optional[Path] = None,\n    overwrite: bool = False,\n    animate: bool = False,\n    lazy_parallelism: bool = False,\n    run: bool = True,\n    dispersive: bool = False,\n    xmargin: float = 0,\n    ymargin: float = 3,\n    xmargin_left: float = 0,\n    xmargin_right: float = 0,\n    ymargin_top: float = 0,\n    ymargin_bot: float = 0,\n    decay_by: float = 1e-3,\n    is_3d: bool = False,\n    z: float = 0,\n    plot_args: Optional[Dict] = None,\n    only_return_filepath_sim_settings=False,\n    **settings,\n) -> Dict:\n    r\"\"\"Returns Sparameters and writes them to npz filepath.\n\n    Simulates each time using a different input port (by default, all of them)\n    unless you specify port_symmetries:\n\n    port_symmetries_crossing = {\n        \"o1@0,o1@0\": [\"o2@0,o2@0\", \"o3@0,o3@0\", \"o4@0,o4@0\"],\n        \"o2@0,o1@0\": [\"o1@0,o2@0\", \"o3@0,o4@0\", \"o4@0,o3@0\"],\n        \"o3@0,o1@0\": [\"o1@0,o3@0\", \"o2@0,o4@0\", \"o4@0,o2@0\"],\n        \"o4@0,o1@0\": [\"o1@0,o4@0\", \"o2@0,o3@0\", \"o3@0,o2@0\"],\n    }\n\n    - Only simulations using the outer key port names will be run\n    - The associated value is another dict whose keys are the S-parameters computed\n        when this source is active\n    - The values of this inner Dict are lists of s-parameters whose values are copied\n\n\n    .. code::\n\n         top view\n              ________________________________\n             |                               |\n             | xmargin_left                  | port_extension\n             |<--------->       port_margin ||<-->\n          o2_|___________          _________||_o3\n             |           \\        /          |\n             |            \\      /           |\n             |             ======            |\n             |            /      \\           |\n          o1_|___________/        \\__________|_o4\n             |   |                 <-------->|\n             |   |ymargin_bot   xmargin_right|\n             |   |                           |\n             |___|___________________________|\n\n        side view\n              ________________________________\n             |                     |         |\n             |                     |         |\n             |                   zmargin_top |\n             |xmargin_left         |         |\n             |<---> _____         _|___      |\n             |     |     |       |     |     |\n             |     |     |       |     |     |\n             |     |_____|       |_____|     |\n             |       |                       |\n             |       |                       |\n             |       |zmargin_bot            |\n             |       |                       |\n             |_______|_______________________|\n\n\n\n    Args:\n        component: to simulate.\n        resolution: in pixels/um (30: for coarse, 100: for fine).\n        port_source_names: list of ports to excite. Defaults to all.\n        port_symmetries: Dict to specify port symmetries, to save number of simulations.\n        dirpath: directory to store Sparameters.\n        layer_stack: contains layer to thickness, zmin and material.\n            Defaults to active pdk.layer_stack.\n        port_margin: margin on each side of the port.\n        port_monitor_offset: offset between KCell and monitor port in um.\n        port_source_offset: offset between KCell and source port in um.\n        filepath: to store pandas Dataframe with Sparameters in npz format.\n            Defaults to dirpath/component_.npz.\n        overwrite: overwrites stored Sparameter npz results.\n        animate: saves a MP4 images of the simulation for inspection, and also\n            outputs during computation. The name of the file is the source index.\n        lazy_parallelism: toggles the flag \"meep.divide_parallel_processes\" to\n            perform the simulations with different sources in parallel.\n            By default MPI just runs the same copy of the Python script everywhere,\n            with the C++ under MEEP actually being parallelized.\n            divide_parallel_processes allows us to logically split this one calculation\n            into (in this case \"cores\") subdivisions.\n            The only difference in the scripts is that a different integer n\n            is returned depending on the subdivision it is running in.\n            So we use that n to select different sources, and each subdivision calculates\n            its own Sparams independently. Afterwards, we collect all\n            results in one of the subdivisions (if rank == 0).\n        run: runs simulation, if False, only plots simulation.\n        dispersive: use dispersive models for materials (requires higher resolution).\n        xmargin: left and right distance from component to PML.\n        xmargin_left: west distance from component to PML.\n        xmargin_right: east distance from component to PML.\n        ymargin: top and bottom distance from component to PML.\n        ymargin_top: north distance from component to PML.\n        ymargin_bot: south distance from component to PML.\n        is_3d: if True runs in 3D (much slower).\n        z: for 2D plot.\n        plot_args: if animate or not run, customization keyword arguments passed to\n          `plot2D()` (i.e. `labels`, `eps_parameters`, `boundary_parameters`, `field_parameters`, etc.)\n\n    keyword Args:\n        extend_ports_length: to extend ports beyond the PML (um).\n        zmargin_top: thickness for cladding above core (um).\n        zmargin_bot: thickness for cladding below core (um).\n        tpml: PML thickness (um).\n        clad_material: material for cladding.\n        wavelength_start: wavelength min (um).\n        wavelength_stop: wavelength max (um).\n        wavelength_points: wavelength steps.\n        dfcen: delta frequency.\n        port_source_name: input port name.\n        port_margin: margin on each side of the port (um).\n        distance_source_to_monitors: in (um).\n        port_source_offset: offset between source KCell port and source MEEP port.\n        port_monitor_offset: offset between KCell and MEEP port monitor.\n        material_name_to_meep: map layer_stack names with meep material database name\n            or refractive index. dispersive materials have a wavelength dependent index.\n\n    Returns:\n        sparameters in a Dict (wavelengths, s11a, o1@0,o2@0, ...)\n            where `a` is the angle in radians and `m` the module.\n\n    \"\"\"\n    component = (\n        component if isinstance(component, KCell) else pdk.get_cell(component)\n    )\n    layer_stack = layer_stack or pdk.layer_stack\n\n    plot_args = plot_args or {}\n\n    for setting in settings:\n        if setting not in settings_get_simulation:\n            raise ValueError(f\"{setting!r} not in {settings_get_simulation}\")\n\n    port_symmetries = port_symmetries or {}\n\n    xmargin_left = xmargin_left or xmargin\n    xmargin_right = xmargin_right or xmargin\n\n    ymargin_top = ymargin_top or ymargin\n    ymargin_bot = ymargin_bot or ymargin\n\n    sim_settings = dict(\n        resolution=resolution,\n        port_symmetries=port_symmetries,\n        wavelength_start=wavelength_start,\n        wavelength_stop=wavelength_stop,\n        wavelength_points=wavelength_points,\n        port_margin=port_margin,\n        port_monitor_offset=port_monitor_offset,\n        port_source_offset=port_source_offset,\n        dispersive=dispersive,\n        ymargin_top=ymargin_top,\n        ymargin_bot=ymargin_bot,\n        xmargin_left=xmargin_left,\n        xmargin_right=xmargin_right,\n        is_3d=is_3d,\n        **settings,\n    )\n\n    filepath = filepath or get_sparameters_path(\n        component=component,\n        dirpath=dirpath,\n        layer_stack=layer_stack,\n        **sim_settings,\n    )\n\n    sim_settings = sim_settings.copy()\n    sim_settings[\"layer_stack\"] = layer_stack.to_dict()\n    sim_settings[\"component\"] = component.to_dict()\n    filepath = pathlib.Path(filepath)\n    filepath_sim_settings = filepath.with_suffix(\".yml\")\n\n    # FIXME: Ideally, we should split sim settings generation from doing the\n    #        simulation... this is a hack.\n    if only_return_filepath_sim_settings:\n        return filepath_sim_settings\n\n    # filepath_sim_settings.write_text(OmegaConf.to_yaml(sim_settings))\n    # logger.info(f\"Write simulation settings to {filepath_sim_settings!r}\")\n    # return filepath_sim_settings\n\n    component = gf.add_padding_container(\n        component,\n        default=0,\n        top=ymargin_top,\n        bottom=ymargin_bot,\n        left=xmargin_left,\n        right=xmargin_right,\n    )\n\n    if not run:\n        sim_dict = get_simulation(\n            component=component,\n            wavelength_start=wavelength_start,\n            wavelength_stop=wavelength_stop,\n            wavelength_points=wavelength_points,\n            layer_stack=layer_stack,\n            port_margin=port_margin,\n            port_monitor_offset=port_monitor_offset,\n            port_source_offset=port_source_offset,\n            dispersive=dispersive,\n            is_3d=is_3d,\n            **settings,\n        )\n        sim = sim_dict[\"sim\"]\n        if is_3d:\n            sim.plot2D(\n                output_plane=mp.Volume(\n                    size=mp.Vector3(sim.cell_size.x, sim.cell_size.y, 0),\n                    center=mp.Vector3(0, 0, z),\n                ),\n                **plot_args,\n            )\n        else:\n            sim.plot2D(plot_eps_flag=True, **plot_args)\n        return sim\n\n    if filepath.exists():\n        if not overwrite:\n            logger.info(f\"Simulation loaded from {filepath!r}\")\n            return dict(np.load(filepath))\n        elif overwrite:\n            filepath.unlink()\n\n    component_ref = component.ref()\n    ports = component_ref.ports\n    port_names = [port.name for port in list(ports.values())]\n    port_source_names = port_source_names or port_names\n    num_sims = len(port_source_names) - len(port_symmetries)\n\n    sp = {}  # Sparameters dict\n    start = time.time()\n\n    @pydantic.validate_arguments\n    def sparameter_calculation(\n        port_source_name: str,\n        component: KCell,\n        port_symmetries: Optional[Dict] = port_symmetries,\n        port_names: List[str] = port_names,\n        wavelength_start: float = wavelength_start,\n        wavelength_stop: float = wavelength_stop,\n        wavelength_points: int = wavelength_points,\n        animate: bool = animate,\n        plot_args: Dict = plot_args,\n        dispersive: bool = dispersive,\n        decay_by: float = decay_by,\n        **settings,\n    ) -> Dict:\n        \"\"\"Return Sparameter dict.\"\"\"\n        sim_dict = get_simulation(\n            component=component,\n            port_source_name=port_source_name,\n            resolution=resolution,\n            wavelength_start=wavelength_start,\n            wavelength_stop=wavelength_stop,\n            wavelength_points=wavelength_points,\n            port_margin=port_margin,\n            port_monitor_offset=port_monitor_offset,\n            port_source_offset=port_source_offset,\n            dispersive=dispersive,\n            layer_stack=layer_stack,\n            is_3d=is_3d,\n            **settings,\n        )\n\n        sim = sim_dict[\"sim\"]\n        # freqs = sim_dict[\"freqs\"]\n        # wavelengths = 1 / freqs\n        # print(sim.resolution)\n\n        # Terminate when the area in the whole area decayed\n        termination = [mp.stop_when_energy_decayed(dt=50, decay_by=decay_by)]\n\n        if animate:\n            # Defaults for animation\n            if \"field_parameters\" not in plot_args:\n                plot_args[\"field_parameters\"] = {\n                    \"alpha\": 0.8,\n                    \"cmap\": \"RdBu\",\n                    \"interpolation\": \"none\",\n                }\n            if \"eps_parameters\" not in plot_args:\n                plot_args[\"eps_parameters\"] = {\"contour\": True}\n            if \"fields\" not in plot_args:\n                plot_args[\"fields\"] = mp.Ez\n            if \"realtime\" not in plot_args:\n                plot_args[\"realtime\"] = True\n            if \"normalize\" not in plot_args:\n                plot_args[\"normalize\"] = True\n\n            sim.use_output_directory()\n            animate = mp.Animate2D(\n                sim,\n                **plot_args,\n            )\n            sim.run(mp.at_every(1, animate), until_after_sources=termination)\n            animate.to_mp4(30, f\"{component.name}_{port_source_name}.mp4\")\n        else:\n            sim.run(until_after_sources=termination)\n\n        # Calculate mode overlaps\n        # Get source monitor results\n        source_entering, _ = parse_port_eigenmode_coeff(\n            port_source_name, component.ports, sim_dict\n        )\n        # Get coefficients\n        for port_name in port_names:\n            _, monitor_exiting = parse_port_eigenmode_coeff(\n                port_name, component.ports, sim_dict\n            )\n            key = f\"{port_name}@0,{port_source_name}@0\"\n            sp[key] = monitor_exiting / source_entering\n\n        if bool(port_symmetries):\n            for key, symmetries in port_symmetries.items():\n                for sym in symmetries:\n                    if key in sp:\n                        sp[sym] = sp[key]\n\n        return sp\n\n    if lazy_parallelism:\n        from mpi4py import MPI\n\n        cores = min([num_sims, multiprocessing.cpu_count()])\n\n        n = mp.divide_parallel_processes(cores)\n        comm = MPI.COMM_WORLD\n        size = comm.Get_size()\n        rank = comm.Get_rank()\n\n        # Map port names to integers\n        port_source_dict = {}\n        for number, name in enumerate(port_source_names):\n            port_source_dict[number] = name\n\n        sp = sparameter_calculation(\n            port_source_name=port_source_dict[n],\n            component=component,\n            port_symmetries=port_symmetries,\n            wavelength_start=wavelength_start,\n            wavelength_stop=wavelength_stop,\n            wavelength_points=wavelength_points,\n            animate=animate,\n            port_names=port_names,\n            **settings,\n        )\n        # Synchronize dicts\n        if rank == 0:\n            for i in range(1, size):\n                data = comm.recv(source=i, tag=11)\n                sp.update(data)\n\n            sp[\"wavelengths\"] = np.linspace(\n                wavelength_start, wavelength_stop, wavelength_points\n            )\n            np.savez_compressed(filepath, **sp)\n            logger.info(f\"Write simulation results to {filepath!r}\")\n            filepath_sim_settings.write_text(\n                OmegaConf.to_yaml(clean_value(sim_settings))\n            )\n            logger.info(f\"Write simulation settings to {filepath_sim_settings!r}\")\n            return sp\n        else:\n            comm.send(sp, dest=0, tag=11)\n\n    else:\n        for port_source_name in tqdm(port_source_names):\n            sp.update(\n                sparameter_calculation(\n                    port_source_name,\n                    component=component,\n                    port_symmetries=port_symmetries,\n                    wavelength_start=wavelength_start,\n                    wavelength_stop=wavelength_stop,\n                    wavelength_points=wavelength_points,\n                    animate=animate,\n                    port_names=port_names,\n                    **settings,\n                )\n            )\n        sp[\"wavelengths\"] = np.linspace(\n            wavelength_start, wavelength_stop, wavelength_points\n        )\n        np.savez_compressed(filepath, **sp)\n\n        end = time.time()\n        sim_settings.update(compute_time_seconds=end - start)\n        sim_settings.update(compute_time_minutes=(end - start) / 60)\n        logger.info(f\"Write simulation results to {filepath!r}\")\n        filepath_sim_settings.write_text(OmegaConf.to_yaml(sim_settings))\n        logger.info(f\"Write simulation settings to {filepath_sim_settings!r}\")\n        return sp", "\n\nwrite_sparameters_meep_1x1 = partial(\n    write_sparameters_meep, port_symmetries=port_symmetries.port_symmetries_1x1\n)\n\nwrite_sparameters_meep_1x1_bend90 = partial(\n    write_sparameters_meep,\n    ymargin=0,\n    ymargin_bot=3,", "    ymargin=0,\n    ymargin_bot=3,\n    xmargin_right=3,\n    port_symmetries=port_symmetries.port_symmetries_1x1,\n)\n\nsig = inspect.signature(write_sparameters_meep)\nsettings_write_sparameters_meep = set(sig.parameters.keys()).union(\n    settings_get_simulation\n)", "    settings_get_simulation\n)\n\nif __name__ == \"__main__\":\n    wavelength_start = 1.26\n    wavelength_stop = 1.36\n    sim_settings = dict(\n        wavelength_start=wavelength_start, wavelength_stop=wavelength_stop\n    )\n    # c = gf.components.mmi1x2(cross_section=gf.cross_section.strip)\n    c = kg.cells.waveguide(0.5, length=2, layer=0)\n    import matplotlib.pyplot as plt\n\n    def func(x):\n        result = np.where(np.abs(x) > 1e-10, np.abs(x) ** 2, -10)\n        return np.log10(result, out=result, where=result > 0)\n\n    sp = write_sparameters_meep(\n        c,\n        run=True,\n        animate=True,\n        is_3d=False,\n        plot_args={\n            \"eps_parameters\": {\"contour\": True},\n            \"field_parameters\": {\n                \"alpha\": 0.8,\n                \"cmap\": \"RdBu\",\n                \"interpolation\": \"none\",\n                \"post_process\": func,\n            },\n            \"realtime\": False,\n        },\n        overwrite=True,\n        **sim_settings,\n    )\n    plt.show()", "\n    # from kfactory.simulation.add_simulation_markers import add_simulation_markers\n    # import kfactory.simulation as sim\n\n    # c = gf.components.straight(length=2)\n    # c = gf.components.bend_euler(radius=3)\n    # c = add_simulation_markers(c)\n\n    # sp = write_sparameters_meep_1x1(c, run=True, is_3d=False)\n    # sim.plot.plot_sparameters(sp)", "    # sp = write_sparameters_meep_1x1(c, run=True, is_3d=False)\n    # sim.plot.plot_sparameters(sp)\n\n    # import matplotlib.pyplot as plt\n    # plt.show()\n"]}
{"filename": "kplugins/kmeep/get_material.py", "chunked_list": ["from __future__ import annotations\n\nfrom functools import partial\nfrom typing import Dict, Optional, Union\n\nimport meep as mp\nimport meep.materials as mat\nimport numpy as np\n\nfrom kplugins.materials import material_name_to_meep as material_name_to_meep_default", "\nfrom kplugins.materials import material_name_to_meep as material_name_to_meep_default\n\nMATERIALS = [m for m in dir(mat) if not m.startswith(\"_\")]\n\n\ndef get_material(\n    name: str = \"si\",\n    wavelength: float = 1.55,\n    dispersive: bool = False,\n    material_name_to_meep: Optional[Dict[str, Union[str, float]]] = None,\n) -> mp.Medium:\n    \"\"\"Returns Meep Medium from database.\n\n    Args:\n        name: material name.\n        wavelength: wavelength (um).\n        dispersive: True for built-in Meep index model,\n            False for simple, non-dispersive model.\n        material_name_to_meep: dispersive materials have a wavelength\n            dependent index. Maps layer_stack names with meep material database names.\n\n    Note:\n        Using the built-in models can be problematic at low resolution.\n\n    \"\"\"\n    material_name_to_meep_new = material_name_to_meep or {}\n    material_name_to_meep = material_name_to_meep_default.copy()\n    material_name_to_meep.update(**material_name_to_meep_new)\n\n    materials = [material.lower() for material in MATERIALS]\n    name = name.lower()\n\n    if name not in material_name_to_meep and name not in materials:\n        raise KeyError(f\"material {name!r} not found in available materials\")\n\n    meep_name = material_name_to_meep[name]\n\n    if isinstance(meep_name, (int, float)):\n        # if material is only a number, we can return early regardless of dispersion\n        return mp.Medium(index=meep_name)\n\n    material = getattr(mat, meep_name)\n\n    if dispersive:\n        return material\n\n    # now what's left is the case of having a dispersive meep medium but a simulation\n    # without dispersion, so we extract the permittivity at the correct wavelength\n    try:\n        return mp.Medium(epsilon=material.epsilon(1 / wavelength)[0][0])\n    except ValueError as e:\n        print(f\"material = {name!r} not defined for wavelength={wavelength}\")\n        raise e", "\n\ndef get_index(\n    wavelength: float = 1.55,\n    name: str = \"Si\",\n    dispersive: bool = False,\n) -> float:\n    \"\"\"Returns refractive index from Meep's material database.\n\n    Args:\n        name: material name.\n        wavelength: wavelength (um).\n        dispersive: True for built-in Meep index model,\n            False for simple, non-dispersive model.\n\n    Note:\n        Using the built-in models can be problematic at low resolution.\n        If fields are NaN or Inf, increase resolution or use a non-dispersive model.\n\n    \"\"\"\n    medium = get_material(\n        name=name,\n        wavelength=wavelength,\n        dispersive=dispersive,\n    )\n\n    epsilon_matrix = medium.epsilon(1 / wavelength)\n    epsilon11 = epsilon_matrix[0][0]\n    return float(epsilon11.real**0.5)", "\n\ndef test_index() -> None:\n    n = get_index(name=\"sin\")\n    n_reference = 1.9962797317138816\n    assert np.isclose(n, n_reference), n\n\n\nsi = partial(get_index, name=\"Si\")\nsio2 = partial(get_index, name=\"SiO2\")", "si = partial(get_index, name=\"Si\")\nsio2 = partial(get_index, name=\"SiO2\")\n\n\nif __name__ == \"__main__\":\n    test_index()\n    # n = get_index(name=\"Si\", wavelength=1.31)\n    # print(n, type(n))\n", ""]}
{"filename": "kplugins/kmeep/test_materials.py", "chunked_list": ["import kfactory as kf\nfrom kplugins.gmeep.write_sparameters_meep import write_sparameters_meep\n\n\ndef test_materials_override() -> None:\n    \"\"\"Checks that materials are properly overridden if index is provided.\"\"\"\n\n    c = kf.cells.waveguide(length=2, width=0.5, layer=0)\n\n    # Default (materials strings)\n    sp1 = write_sparameters_meep(\n        c,\n        run=False,\n        animate=False,\n        is_3d=False,\n        overwrite=True,\n    )\n\n    # Override\n    sp2 = write_sparameters_meep(\n        c,\n        run=False,\n        animate=False,\n        material_name_to_meep=dict(si=2.0),\n        is_3d=False,\n        overwrite=True,\n    )\n\n    assert sp1.geometry[0].material.epsilon(freq=1)[0][0] != 4.0\n    assert sp2.geometry[0].material.epsilon(freq=1)[0][0] == 4.0", "\n\nif __name__ == \"__main__\":\n    test_materials_override()\n"]}
{"filename": "kplugins/kmeep/write_sparameters_meep_mpi.py", "chunked_list": ["\"\"\"Compute and write Sparameters using Meep in MPI.\"\"\"\n\nfrom __future__ import annotations\n\nfrom functools import partial\nimport multiprocessing\nimport pathlib\nimport shlex\nimport subprocess\nimport sys", "import subprocess\nimport sys\nimport time\nfrom pathlib import Path\nfrom typing import Optional\n\nimport pydantic\n\nimport kfactory as gf\nfrom kfactory import KCell", "import kfactory as gf\nfrom kfactory import KCell\nfrom kfactory.conf import logger\nfrom kgeneric import pdk\nfrom kgeneric.config import PATH\nimport kgeneric as kg\nfrom kplugins import port_symmetries\nfrom kplugins.get_sparameters_path import (\n    get_sparameters_path_meep as get_sparameters_path,\n)", "    get_sparameters_path_meep as get_sparameters_path,\n)\nfrom kplugins.gmeep.write_sparameters_meep import (\n    remove_simulation_kwargs,\n    settings_write_sparameters_meep,\n)\nfrom kfactory.technology import LayerStack\nfrom kfactory.typings import CellSpec, PathType\nimport pickle\n", "import pickle\n\ncore_materials = multiprocessing.cpu_count()\n\ntemp_dir_default = Path(PATH.sparameters_path) / \"temp\"\n\n\ndef _python() -> str:\n    \"\"\"Select correct python executable from current activated environment.\"\"\"\n    return sys.executable", "\n\n@pydantic.validate_arguments\ndef write_sparameters_meep_mpi(\n    component: CellSpec,\n    layer_stack: Optional[LayerStack] = None,\n    cores: int = core_materials,\n    filepath: Optional[PathType] = None,\n    dirpath: Optional[PathType] = None,\n    temp_dir: Path = temp_dir_default,\n    temp_file_str: str = \"write_sparameters_meep_mpi\",\n    live_output: bool = False,\n    overwrite: bool = False,\n    wait_to_finish: bool = True,\n    **kwargs,\n) -> Path:\n    \"\"\"Write Sparameters using multiple cores and MPI and returns Sparameters filepath.\n\n    Simulates each time using a different input port (by default, all of them)\n    unless you specify port_symmetries:\n\n    checks stderror and kills MPI job if there is any stderror message\n\n    port_symmetries = {\"o1\":\n            {\n                \"s11\": [\"s22\",\"s33\",\"s44\"],\n                \"s21\": [\"s21\",\"s34\",\"s43\"],\n                \"s31\": [\"s13\",\"s24\",\"s42\"],\n                \"s41\": [\"s14\",\"s23\",\"s32\"],\n            }\n        }\n\n    Args:\n        component: kfactory Kcell.\n        cores: number of processors.\n        filepath: to store pandas Dataframe with Sparameters in CSV format.\n            Defaults to dirpath/component_.csv.\n        dirpath: directory to store sparameters in CSV.\n            Defaults to active Pdk.sparameters_path.\n        layer_stack: contains layer to thickness, zmin and material.\n            Defaults to active pdk.layer_stack.\n        temp_dir: temporary directory to hold simulation files.\n        temp_file_str: names of temporary files in temp_dir.\n        live_output: stream output of mpirun command to file and print to console\n            (meep verbosity still needs to be set separately).\n        overwrite: overwrites stored simulation results.\n        wait_to_finish: if True makes the function call blocking.\n\n    Keyword Args:\n        resolution: in pixels/um (30: for coarse, 100: for fine).\n        port_symmetries: Dict to specify port symmetries, to save number of simulations.\n        dirpath: directory to store Sparameters.\n        port_margin: margin on each side of the port.\n        port_monitor_offset: offset between monitor GDS port and monitor MEEP port.\n        port_source_offset: offset between source GDS port and source MEEP port.\n        filepath: to store pandas Dataframe with Sparameters in CSV format.\n        animate: saves a MP4 images of the simulation for inspection, and also\n            outputs during computation. The name of the file is the source index.\n        lazy_parallelism: toggles the flag \"meep.divide_parallel_processes\" to\n            perform the simulations with different sources in parallel.\n        dispersive: use dispersive models for materials (requires higher resolution).\n        xmargin: left and right distance from component to PML.\n        xmargin_left: west distance from component to PML.\n        xmargin_right: east distance from component to PML.\n        ymargin: top and bottom distance from component to PML.\n        ymargin_top: north distance from component to PML.\n        ymargin_bot: south distance from component to PML.\n        extend_ports_length: to extend ports beyond the PML.\n        zmargin_top: thickness for cladding above core.\n        zmargin_bot: thickness for cladding below core.\n        tpml: PML thickness (um).\n        clad_material: material for cladding.\n        is_3d: if True runs in 3D.\n        wavelength_start: wavelength min (um).\n        wavelength_stop: wavelength max (um).\n        wavelength_points: wavelength steps.\n        dfcen: delta frequency.\n        port_source_name: input port name.\n        port_margin: margin on each side of the port.\n        distance_source_to_monitors: in (um) source goes before.\n        port_source_offset: offset between source GDS port and source MEEP port.\n        port_monitor_offset: offset between monitor GDS port and monitor MEEP port.\n\n    Returns:\n        filepath for sparameters CSV (wavelengths, s11a, o1@0,o2@0, ...)\n            where `a` is the angle in radians and `m` the module.\n\n    TODO:\n        write stdout to file, maybe simulation logs too.\n\n    \"\"\"\n    for setting in kwargs:\n        if setting not in settings_write_sparameters_meep:\n            raise ValueError(f\"{setting!r} not in {settings_write_sparameters_meep}\")\n\n    component = gf.get_component(component)\n    assert isinstance(component, KCell)\n\n    layer_stack = layer_stack or pdk.layer_stack\n\n    settings = remove_simulation_kwargs(kwargs)\n    filepath = filepath or get_sparameters_path(\n        component=component,\n        dirpath=dirpath,\n        layer_stack=layer_stack,\n        **settings,\n    )\n    filepath = pathlib.Path(filepath)\n    if filepath.exists() and not overwrite:\n        logger.info(f\"Simulation {filepath!r} already exists\")\n        return filepath\n\n    if filepath.exists() and overwrite:\n        filepath.unlink()\n\n    # Save all the simulation arguments for later retrieval\n    temp_dir.mkdir(exist_ok=True, parents=True)\n    tempfile = temp_dir / temp_file_str\n    filepath_json = tempfile.with_suffix(\".json\")\n    logger.info(f\"Write {filepath_json!r}\")\n\n    layer_stack_json = layer_stack.json()\n    filepath_json.write_text(layer_stack_json)\n\n    parameters_file = tempfile.with_suffix(\".pkl\")\n    with open(parameters_file, \"wb\") as outp:\n        pickle.dump(settings, outp, pickle.HIGHEST_PROTOCOL)\n\n    # Save component to disk through gds for gdstk compatibility\n    component_file = tempfile.with_suffix(\".gds\")\n    component.write_gds_with_metadata(component_file)\n\n    # Write execution file\n    script_lines = [\n        \"import pathlib\\n\",\n        \"import pickle\\n\",\n        \"from kfactory.simulation.gmeep import write_sparameters_meep\\n\\n\",\n        \"from kfactory.read import import_gds\\n\",\n        \"from kfactory.technology import LayerStack\\n\\n\",\n        \"if __name__ == '__main__':\\n\",\n        f\"\\twith open(\\\"{parameters_file}\\\", 'rb') as inp:\\n\",\n        \"\\t\\tparameters_dict = pickle.load(inp)\\n\\n\",\n        f\"\\tcomponent = import_gds({str(component_file)!r}, read_metadata=True)\\n\",\n        f\"\\tfilepath_json = pathlib.Path({str(filepath_json)!r})\\n\",\n        \"\\tlayer_stack = LayerStack.parse_raw(filepath_json.read_text())\\n\",\n        f\"\\twrite_sparameters_meep(component=component, overwrite={overwrite}, \"\n        f\"layer_stack=layer_stack, filepath={str(filepath)!r},\",\n    ]\n    script_lines.extend(f'\\t\\t{key} = parameters_dict[\"{key}\"],\\n' for key in settings)\n    script_lines.append(\"\\t)\")\n\n    script_file = tempfile.with_suffix(\".py\")\n    with open(script_file, \"w\") as script_file_obj:\n        script_file_obj.writelines(script_lines)\n    command = f\"mpirun -np {cores} {_python()} {script_file}\"\n    logger.info(command)\n    logger.info(str(filepath))\n\n    if live_output:\n        import asyncio\n\n        from kplugins.async_utils import execute_and_stream_output\n\n        asyncio.run(\n            execute_and_stream_output(\n                command, log_file_dir=temp_dir, log_file_str=temp_file_str\n            )\n        )\n    else:\n        with subprocess.Popen(\n            shlex.split(command),\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n        ) as proc:\n            print(proc.stdout.read().decode())\n            print(proc.stderr.read().decode())\n            sys.stdout.flush()\n            sys.stderr.flush()\n        if wait_to_finish and not proc.stderr:\n            while not filepath.exists():\n                print(proc.stdout.read().decode())\n                print(proc.stderr.read().decode())\n                sys.stdout.flush()\n                sys.stderr.flush()\n                time.sleep(1)\n    return filepath", "\n\nwrite_sparameters_meep_mpi_1x1 = partial(\n    write_sparameters_meep_mpi, port_symmetries=port_symmetries.port_symmetries_1x1\n)\n\nwrite_sparameters_meep_mpi_1x1_bend90 = partial(\n    write_sparameters_meep_mpi,\n    ymargin_bot=3,\n    ymargin=0,", "    ymargin_bot=3,\n    ymargin=0,\n    xmargin_right=3,\n    port_symmetries=port_symmetries.port_symmetries_1x1,\n)\n\n\nif __name__ == \"__main__\":\n    import numpy as np\n\n    c1 = kg.cells.waveguide(0.5, length=2.1, layer=0)\n    filepath = write_sparameters_meep_mpi(\n        component=c1,\n        # ymargin=3,\n        cores=2,\n        run=True,\n        overwrite=True,\n        live_output=True,\n        # lazy_parallelism=True,\n        lazy_parallelism=False,\n        temp_dir=\"./test/\",\n        filepath=\"instance_dict.csv\",\n        resolution=20,\n    )\n    sp = np.load(filepath)\n    print(list(sp.keys()))", ""]}
{"filename": "kplugins/kmeep/__init__.py", "chunked_list": ["from __future__ import annotations\n\ntry:\n    import meep as mp\nexcept ModuleNotFoundError as e:\n    print(\"You need to 'conda install -c conda-forge pymeep=*=mpi_mpich_* nlopt -y'\")\n    raise e\n\nfrom kfactory.conf import logger\nfrom kplugins import plot, port_symmetries", "from kfactory.conf import logger\nfrom kplugins import plot, port_symmetries\nfrom kplugins.get_sparameters_path import get_sparameters_data_meep\nfrom kplugins.gmeep.get_simulation import get_simulation\nfrom kplugins.gmeep.meep_adjoint_optimization import (\n    get_meep_adjoint_optimizer,\n    run_meep_adjoint_optimizer,\n)\nfrom kplugins.gmeep.write_sparameters_grating import (\n    write_sparameters_grating,", "from kplugins.gmeep.write_sparameters_grating import (\n    write_sparameters_grating,\n    write_sparameters_grating_batch,\n    write_sparameters_grating_mpi,\n)\nfrom kplugins.gmeep.write_sparameters_meep import (\n    write_sparameters_meep,\n    write_sparameters_meep_1x1,\n    write_sparameters_meep_1x1_bend90,\n)", "    write_sparameters_meep_1x1_bend90,\n)\nfrom kplugins.gmeep.write_sparameters_meep_batch import (\n    write_sparameters_meep_batch,\n    write_sparameters_meep_batch_1x1,\n    write_sparameters_meep_batch_1x1_bend90,\n)\nfrom kplugins.gmeep.write_sparameters_meep_mpi import (\n    write_sparameters_meep_mpi,\n    write_sparameters_meep_mpi_1x1,", "    write_sparameters_meep_mpi,\n    write_sparameters_meep_mpi_1x1,\n    write_sparameters_meep_mpi_1x1_bend90,\n)\n\nlogger.info(f\"Meep {mp.__version__!r} installed at {mp.__path__!r}\")\n\n__all__ = [\n    \"get_meep_adjoint_optimizer\",\n    \"get_simulation\",", "    \"get_meep_adjoint_optimizer\",\n    \"get_simulation\",\n    \"get_sparameters_data_meep\",\n    \"run_meep_adjoint_optimizer\",\n    \"write_sparameters_meep\",\n    \"write_sparameters_meep_1x1\",\n    \"write_sparameters_meep_1x1_bend90\",\n    \"write_sparameters_meep_mpi\",\n    \"write_sparameters_meep_mpi_1x1\",\n    \"write_sparameters_meep_mpi_1x1_bend90\",", "    \"write_sparameters_meep_mpi_1x1\",\n    \"write_sparameters_meep_mpi_1x1_bend90\",\n    \"write_sparameters_meep_batch\",\n    \"write_sparameters_meep_batch_1x1\",\n    \"write_sparameters_meep_batch_1x1_bend90\",\n    \"write_sparameters_grating\",\n    \"write_sparameters_grating_mpi\",\n    \"write_sparameters_grating_batch\",\n    \"plot\",\n    \"port_symmetries\",", "    \"plot\",\n    \"port_symmetries\",\n]\n__version__ = \"0.0.3\"\n"]}
{"filename": "kplugins/kmeep/write_sparameters_grating.py", "chunked_list": ["\"\"\"SMF specs from photonics.byu.edu/FiberOpticConnectors.parts/images/smf28.pdf.\n\nMFD:\n\n- 10.4 for Cband\n- 9.2 for Oband\n\n\"\"\"\nfrom __future__ import annotations\n", "from __future__ import annotations\n\nimport hashlib\nimport pathlib\nimport shlex\nimport shutil\nimport subprocess\nimport time\nfrom typing import Dict, Optional, Tuple\n", "from typing import Dict, Optional, Tuple\n\nimport matplotlib.pyplot as plt\nimport meep as mp\nimport numpy as np\nimport omegaconf\n\nfrom kfactory.conf import logger\nfrom kfactory.kcell import clean_value\nfrom kplugins.gmeep.get_simulation_grating_fiber import (", "from kfactory.kcell import clean_value\nfrom kplugins.gmeep.get_simulation_grating_fiber import (\n    get_simulation_grating_fiber,\n)\nfrom kplugins.gmeep.write_sparameters_meep_mpi import _python\nfrom kfactory.typings import PathType\n\nnm = 1e-3\nnSi = 3.48\nnSiO2 = 1.44", "nSi = 3.48\nnSiO2 = 1.44\n\nFloats = Tuple[float, ...]\n\n\ndef fiber_core_material(fiber_numerical_aperture, fiber_clad_material):\n    return (fiber_numerical_aperture**2 + fiber_clad_material**2) ** 0.5\n\n\ndef write_sparameters_grating(\n    plot: bool = False,\n    plot_contour: bool = False,\n    animate: bool = False,\n    overwrite: bool = False,\n    dirpath: Optional[PathType] = \"./sparameters\",\n    decay_by: float = 1e-3,\n    verbosity: int = 0,\n    **settings,\n) -> np.ndarray:\n    \"\"\"Write grating coupler with fiber Sparameters.\n\n    Args:\n        plot: plot simulation (do not run).\n        plot_contour: show contours.\n        animate: create animation.\n        overwrite: overwrites simulation if found.\n        dirpath: directory path.\n        decay_by: field decay to stop simulation.\n        verbosity: print messages.\n        core_materials: number of cores.\n\n    Keyword Args:\n        period: fiber grating period in um.\n        fill_factor: fraction of the grating period filled with the grating material.\n        n_periods: number of periods.\n        widths: Optional list of widths. Overrides period, fill_factor, n_periods.\n        gaps: Optional list of gaps. Overrides period, fill_factor, n_periods.\n        fiber_angle_deg: fiber angle in degrees.\n        fiber_xposition: xposition.\n        fiber_core_diameter: fiber diameter.\n        fiber_numerical_aperture: NA.\n        fiber_clad_material: fiber cladding index.\n        nwg: waveguide index.\n        nslab: slab refractive index.\n        clad_material: top cladding index.\n        nbox: box index bottom.\n        nsubstrate: index substrate.\n        pml_thickness: pml_thickness (um).\n        substrate_thickness: substrate_thickness (um).\n        box_thickness: thickness for bottom cladding (um).\n        core_thickness: core_thickness (um).\n        slab_thickness: slab thickness (um). etch_depth=core_thickness-slab_thickness.\n        top_clad_thickness: thickness of the top cladding.\n        air_gap_thickness: air gap thickness.\n        fiber_thickness: fiber_thickness.\n        resolution: resolution pixels/um.\n        wavelength_start: min wavelength (um).\n        wavelength_stop: max wavelength (um).\n        wavelength_points: wavelength points.\n        eps_averaging: epsilon averaging.\n        fiber_port_y_offset_from_air: y_offset from fiber to air (um).\n        waveguide_port_x_offset_from_grating_start: in um.\n        fiber_port_x_size: in um.\n        xmargin: margin from PML to grating end in um.\n\n    .. code::\n\n                 fiber_xposition\n                  |\n             fiber_core_diameter\n          /     /  /     /       |\n         /     /  /     /        | fiber_thickness\n        /     /  /     /    _ _ _| _ _ _ _ _ _  _\n                                 |\n                                 | air_gap_thickness\n                            _ _ _| _ _ _ _ _ _  _\n                                 |\n                clad_material            | top_clad_thickness\n                            _ _ _| _ _ _ _ _ _  _\n             _|-|_|-|_|-|___     |              _| etch_depth\n              core_material        |     |core_thickness\n             ______________|_ _ _|_ _ _ _ _ _ _ _\n                                 |\n              nbox               |box_thickness\n             ______________ _ _ _|_ _ _ _ _ _ _ _\n                                 |\n              nsubstrate         |substrate_thickness\n             ______________ _ _ _|\n\n    \"\"\"\n    mp.verbosity(verbosity)\n\n    settings_string = clean_value(settings)\n    settings_hash = hashlib.md5(settings_string.encode()).hexdigest()[:8]\n\n    filename = f\"fiber_{settings_hash}.yml\"\n    dirpath = dirpath or pathlib.Path(__file__).parent / \"data\"\n    dirpath = pathlib.Path(dirpath)\n    dirpath.mkdir(exist_ok=True, parents=True)\n    filepath = dirpath / filename\n    filepath_npz = filepath.with_suffix(\".npz\")\n    filepath_mp4 = filepath.with_suffix(\".mp4\")\n\n    if filepath_npz.exists() and not overwrite and not plot:\n        logger.info(f\"sparameters loaded from {str(filepath_npz)!r}\")\n        return np.load(filepath_npz)\n\n    sim_dict = get_simulation_grating_fiber(**settings)\n    sim = sim_dict[\"sim\"]\n    freqs = sim_dict[\"freqs\"]\n    start = time.time()\n\n    if plot or plot_contour:\n        eps_parameters = dict(contour=True) if plot_contour else None\n        sim.plot2D(eps_parameters=eps_parameters)\n        plt.show()\n        return\n\n    termination = [mp.stop_when_energy_decayed(dt=50, decay_by=decay_by)]\n\n    if animate:\n        # Run while saving fields\n        # sim.use_output_directory()\n        animate = mp.Animate2D(\n            sim,\n            fields=mp.Ez,\n            realtime=False,\n            normalize=True,\n            eps_parameters={\"contour\": True},\n            field_parameters={\n                \"alpha\": 0.8,\n                \"cmap\": \"RdBu\",\n                \"interpolation\": \"none\",\n            },\n            boundary_parameters={\n                \"hatch\": \"o\",\n                \"linewidth\": 1.5,\n                \"facecolor\": \"y\",\n                \"edgecolor\": \"b\",\n                \"alpha\": 0.3,\n            },\n        )\n\n        sim.run(mp.at_every(1, animate), until_after_sources=termination)\n        animate.to_mp4(15, filepath_mp4)\n\n    else:\n        sim.run(until_after_sources=termination)\n\n    # Extract mode information\n    waveguide_monitor = sim_dict[\"waveguide_monitor\"]\n    waveguide_port_direction = sim_dict[\"waveguide_port_direction\"]\n    fiber_monitor = sim_dict[\"fiber_monitor\"]\n    fiber_angle_deg = sim_dict[\"fiber_angle_deg\"]\n    fcen = sim_dict[\"fcen\"]\n    wavelengths = 1 / freqs\n\n    waveguide_mode = sim.get_eigenmode_coefficients(\n        waveguide_monitor,\n        [1],\n        eig_parity=mp.ODD_Z,\n        direction=waveguide_port_direction,\n    )\n    fiber_mode = sim.get_eigenmode_coefficients(\n        fiber_monitor,\n        [1],\n        direction=mp.NO_DIRECTION,\n        eig_parity=mp.ODD_Z,\n        kpoint_func=lambda f, n: mp.Vector3(0, fcen * 1.45, 0).rotate(\n            mp.Vector3(z=1), -1 * np.radians(fiber_angle_deg)\n        ),  # Hardcoded index for now, pull from simulation eventually\n    )\n    end = time.time()\n\n    a1 = waveguide_mode.alpha[:, :, 0].flatten()  # forward wave\n    b1 = waveguide_mode.alpha[:, :, 1].flatten()  # backward wave\n\n    # Since waveguide port is oblique, figure out forward and backward direction\n    kdom_fiber = fiber_mode.kdom[0]\n    idx = 1 - (kdom_fiber.y > 0) * 1\n\n    a2 = fiber_mode.alpha[:, :, idx].flatten()  # forward wave\n    # b2 = fiber_mode.alpha[:, :, 1 - idx].flatten()  # backward wave\n\n    s11 = np.squeeze(b1 / a1)\n    s12 = np.squeeze(a2 / a1)\n    s22 = s11.copy()\n    s21 = s12.copy()\n\n    simulation = dict(\n        settings=settings,\n        compute_time_seconds=end - start,\n        compute_time_minutes=(end - start) / 60,\n    )\n    filepath.write_text(omegaconf.OmegaConf.to_yaml(simulation))\n\n    sp = {\n        \"o1@0,o1@0\": s11,\n        \"o1@0,o2@0\": s12,\n        \"o2@0,o1@0\": s21,\n        \"o2@0,o2@0\": s22,\n        \"wavelengths\": wavelengths,\n    }\n    np.savez_compressed(filepath_npz, **sp)\n    return sp", "\n\ndef write_sparameters_grating(\n    plot: bool = False,\n    plot_contour: bool = False,\n    animate: bool = False,\n    overwrite: bool = False,\n    dirpath: Optional[PathType] = \"./sparameters\",\n    decay_by: float = 1e-3,\n    verbosity: int = 0,\n    **settings,\n) -> np.ndarray:\n    \"\"\"Write grating coupler with fiber Sparameters.\n\n    Args:\n        plot: plot simulation (do not run).\n        plot_contour: show contours.\n        animate: create animation.\n        overwrite: overwrites simulation if found.\n        dirpath: directory path.\n        decay_by: field decay to stop simulation.\n        verbosity: print messages.\n        core_materials: number of cores.\n\n    Keyword Args:\n        period: fiber grating period in um.\n        fill_factor: fraction of the grating period filled with the grating material.\n        n_periods: number of periods.\n        widths: Optional list of widths. Overrides period, fill_factor, n_periods.\n        gaps: Optional list of gaps. Overrides period, fill_factor, n_periods.\n        fiber_angle_deg: fiber angle in degrees.\n        fiber_xposition: xposition.\n        fiber_core_diameter: fiber diameter.\n        fiber_numerical_aperture: NA.\n        fiber_clad_material: fiber cladding index.\n        nwg: waveguide index.\n        nslab: slab refractive index.\n        clad_material: top cladding index.\n        nbox: box index bottom.\n        nsubstrate: index substrate.\n        pml_thickness: pml_thickness (um).\n        substrate_thickness: substrate_thickness (um).\n        box_thickness: thickness for bottom cladding (um).\n        core_thickness: core_thickness (um).\n        slab_thickness: slab thickness (um). etch_depth=core_thickness-slab_thickness.\n        top_clad_thickness: thickness of the top cladding.\n        air_gap_thickness: air gap thickness.\n        fiber_thickness: fiber_thickness.\n        resolution: resolution pixels/um.\n        wavelength_start: min wavelength (um).\n        wavelength_stop: max wavelength (um).\n        wavelength_points: wavelength points.\n        eps_averaging: epsilon averaging.\n        fiber_port_y_offset_from_air: y_offset from fiber to air (um).\n        waveguide_port_x_offset_from_grating_start: in um.\n        fiber_port_x_size: in um.\n        xmargin: margin from PML to grating end in um.\n\n    .. code::\n\n                 fiber_xposition\n                  |\n             fiber_core_diameter\n          /     /  /     /       |\n         /     /  /     /        | fiber_thickness\n        /     /  /     /    _ _ _| _ _ _ _ _ _  _\n                                 |\n                                 | air_gap_thickness\n                            _ _ _| _ _ _ _ _ _  _\n                                 |\n                clad_material            | top_clad_thickness\n                            _ _ _| _ _ _ _ _ _  _\n             _|-|_|-|_|-|___     |              _| etch_depth\n              core_material        |     |core_thickness\n             ______________|_ _ _|_ _ _ _ _ _ _ _\n                                 |\n              nbox               |box_thickness\n             ______________ _ _ _|_ _ _ _ _ _ _ _\n                                 |\n              nsubstrate         |substrate_thickness\n             ______________ _ _ _|\n\n    \"\"\"\n    mp.verbosity(verbosity)\n\n    settings_string = clean_value(settings)\n    settings_hash = hashlib.md5(settings_string.encode()).hexdigest()[:8]\n\n    filename = f\"fiber_{settings_hash}.yml\"\n    dirpath = dirpath or pathlib.Path(__file__).parent / \"data\"\n    dirpath = pathlib.Path(dirpath)\n    dirpath.mkdir(exist_ok=True, parents=True)\n    filepath = dirpath / filename\n    filepath_npz = filepath.with_suffix(\".npz\")\n    filepath_mp4 = filepath.with_suffix(\".mp4\")\n\n    if filepath_npz.exists() and not overwrite and not plot:\n        logger.info(f\"sparameters loaded from {str(filepath_npz)!r}\")\n        return np.load(filepath_npz)\n\n    sim_dict = get_simulation_grating_fiber(**settings)\n    sim = sim_dict[\"sim\"]\n    freqs = sim_dict[\"freqs\"]\n    start = time.time()\n\n    if plot or plot_contour:\n        eps_parameters = dict(contour=True) if plot_contour else None\n        sim.plot2D(eps_parameters=eps_parameters)\n        plt.show()\n        return\n\n    termination = [mp.stop_when_energy_decayed(dt=50, decay_by=decay_by)]\n\n    if animate:\n        # Run while saving fields\n        # sim.use_output_directory()\n        animate = mp.Animate2D(\n            sim,\n            fields=mp.Ez,\n            realtime=False,\n            normalize=True,\n            eps_parameters={\"contour\": True},\n            field_parameters={\n                \"alpha\": 0.8,\n                \"cmap\": \"RdBu\",\n                \"interpolation\": \"none\",\n            },\n            boundary_parameters={\n                \"hatch\": \"o\",\n                \"linewidth\": 1.5,\n                \"facecolor\": \"y\",\n                \"edgecolor\": \"b\",\n                \"alpha\": 0.3,\n            },\n        )\n\n        sim.run(mp.at_every(1, animate), until_after_sources=termination)\n        animate.to_mp4(15, filepath_mp4)\n\n    else:\n        sim.run(until_after_sources=termination)\n\n    # Extract mode information\n    waveguide_monitor = sim_dict[\"waveguide_monitor\"]\n    waveguide_port_direction = sim_dict[\"waveguide_port_direction\"]\n    fiber_monitor = sim_dict[\"fiber_monitor\"]\n    fiber_angle_deg = sim_dict[\"fiber_angle_deg\"]\n    fcen = sim_dict[\"fcen\"]\n    wavelengths = 1 / freqs\n\n    waveguide_mode = sim.get_eigenmode_coefficients(\n        waveguide_monitor,\n        [1],\n        eig_parity=mp.ODD_Z,\n        direction=waveguide_port_direction,\n    )\n    fiber_mode = sim.get_eigenmode_coefficients(\n        fiber_monitor,\n        [1],\n        direction=mp.NO_DIRECTION,\n        eig_parity=mp.ODD_Z,\n        kpoint_func=lambda f, n: mp.Vector3(0, fcen * 1.45, 0).rotate(\n            mp.Vector3(z=1), -1 * np.radians(fiber_angle_deg)\n        ),  # Hardcoded index for now, pull from simulation eventually\n    )\n    end = time.time()\n\n    a1 = waveguide_mode.alpha[:, :, 0].flatten()  # forward wave\n    b1 = waveguide_mode.alpha[:, :, 1].flatten()  # backward wave\n\n    # Since waveguide port is oblique, figure out forward and backward direction\n    kdom_fiber = fiber_mode.kdom[0]\n    idx = 1 - (kdom_fiber.y > 0) * 1\n\n    a2 = fiber_mode.alpha[:, :, idx].flatten()  # forward wave\n    # b2 = fiber_mode.alpha[:, :, 1 - idx].flatten()  # backward wave\n\n    s11 = np.squeeze(b1 / a1)\n    s12 = np.squeeze(a2 / a1)\n    s22 = s11.copy()\n    s21 = s12.copy()\n\n    simulation = dict(\n        settings=settings,\n        compute_time_seconds=end - start,\n        compute_time_minutes=(end - start) / 60,\n    )\n    filepath.write_text(omegaconf.OmegaConf.to_yaml(simulation))\n\n    sp = {\n        \"o1@0,o1@0\": s11,\n        \"o1@0,o2@0\": s12,\n        \"o2@0,o1@0\": s21,\n        \"o2@0,o2@0\": s22,\n        \"wavelengths\": wavelengths,\n    }\n    np.savez_compressed(filepath_npz, **sp)\n    return sp", "\n\ndef write_sparameters_grating_mpi(\n    instance: Dict,\n    cores: int = 2,\n    temp_dir: Optional[str] = None,\n    temp_file_str: str = \"write_sparameters_meep_mpi\",\n    verbosity: bool = False,\n):\n    \"\"\"Write grating coupler Sparameters using multiple cores.\n\n    Given a Dict of write_sparameters_meep keyword arguments (the \"instance\"),\n    launches a parallel simulation on `cores` cores\n    Returns the subprocess Popen object\n\n    Args:\n        instances: keys are parameters names of write_sparameters_meep,\n            and entries the values.\n        cores (int): number of processors.\n        temp_dir (FilePath): temporary directory to hold simulation files.\n        temp_file_str (str): names of temporary files in temp_dir.\n        verbosity (bool): progress messages.\n\n    \"\"\"\n    # Save the component object to simulation for later retrieval\n    temp_dir = temp_dir or pathlib.Path(__file__).parent / \"temp\"\n    temp_dir = pathlib.Path(temp_dir)\n    temp_dir.mkdir(exist_ok=True, parents=True)\n    filepath = temp_dir / temp_file_str\n\n    # Add parallelism info\n    instance[\"core_materials\"] = cores\n\n    # Write execution file\n    script_lines = [\n        \"from kpugins.gmeep.write_sparameters_grating import write_sparameters_grating\\n\\n\",\n        'if __name__ == \"__main__\":\\n\\n',\n        \"\\twrite_sparameters_grating(\\n\",\n    ]\n    script_lines.extend(f\"\\t\\t{key} = {instance[key]!r},\\n\" for key in instance.keys())\n    script_lines.append(\"\\t)\")\n    script_file = filepath.with_suffix(\".py\")\n    with open(script_file, \"w\") as script_file_obj:\n        script_file_obj.writelines(script_lines)\n    # Exec string\n    command = f\"mpirun -np {cores} {_python()} {script_file}\"\n\n    # Launch simulation\n    if verbosity:\n        print(f\"Launching: {command}\")\n    return subprocess.Popen(\n        shlex.split(command),\n        shell=False,\n        stdin=None,\n        stdout=None,\n        stderr=None,\n    )", "\n\ndef write_sparameters_grating_batch(\n    instances,\n    cores_per_instance: int = 2,\n    total_cores: int = 4,\n    temp_dir: Optional[str] = None,\n    delete_temp_files: bool = False,\n    verbosity: bool = False,\n) -> None:\n    \"\"\"Write grating coupler Sparameters using multiple cores in batches of simulations.\n\n    Given a tuple of write_sparameters_meep keyword arguments (instances)\n    launches parallel simulations each simulation is assigned \"cores_per_instance\" cores\n    Assumes total of \"total_cores\" if cores_per_instance * len(instances) > total_cores\n    then the overflow will be performed serially\n\n    Args:\n        instances: list of Dicts. The keys must be parameters names of write_sparameters_meep,\n            and entries the values.\n        cores_per_instance: number of processors to assign to each instance.\n        total_cores: total number of cores to use.\n        temp_dir: temporary directory to hold simulation files.\n        delete_temp_file: whether to delete temp_dir when done.\n        verbosity: show progress messages.\n\n    \"\"\"\n    # Save the component object to simulation for later retrieval\n    temp_dir = temp_dir or pathlib.Path(__file__).parent / \"temp\"\n    temp_dir = pathlib.Path(temp_dir)\n    temp_dir.mkdir(exist_ok=True, parents=True)\n\n    # Setup pools\n    num_pools = int(np.ceil(cores_per_instance * len(instances) / total_cores))\n    instances_per_pool = int(np.floor(total_cores / cores_per_instance))\n    num_tasks = len(instances)\n\n    if verbosity:\n        print(f\"Running parallel simulations over {num_tasks} instances\")\n        print(\n            f\"Using a total of {total_cores} cores with {cores_per_instance} cores per instance\"\n        )\n        print(\n            f\"Tasks split amongst {num_pools} pools with up to {instances_per_pool} instances each.\"\n        )\n\n    i = 0\n    # For each pool\n    for j in range(num_pools):\n        processes = []\n        # For instance in the pool\n        for k in range(instances_per_pool):\n            # Flag to catch nonfull pools\n            if i >= num_tasks:\n                continue\n            if verbosity:\n                print(f\"Task {k} of pool {j} is instance {i}\")\n            # Obtain current instance\n            instance = instances[i]\n\n            process = write_sparameters_grating_batch(\n                instances=instance,\n                cores_per_instance=cores_per_instance,\n                temp_dir=temp_dir,\n                verbosity=verbosity,\n            )\n            processes.append(process)\n\n            # Increment task number\n            i += 1\n\n        # Wait for pool to end\n        for process in processes:\n            process.wait()\n\n    if delete_temp_files:\n        shutil.rmtree(temp_dir)", "\n\nif __name__ == \"__main__\":\n    # fiber_numerical_aperture = float(np.sqrt(1.44427 ** 2 - 1.43482 ** 2))\n    # instance1 = dict(\n    #     period=0.66,\n    #     fill_factor=0.5,\n    #     n_periods=50,\n    #     etch_depth=70 * nm,\n    #     fiber_angle_deg=10.0,\n    #     fiber_xposition=0.0,\n    #     fiber_core_diameter=9,\n    #     fiber_numerical_aperture=fiber_numerical_aperture,\n    #     fiber_clad_material=1.43482,\n    #     core_material=3.47,\n    #     clad_material=1.44,\n    #     nbox=1.44,\n    #     nsubstrate=3.47,\n    #     pml_thickness=1.0,\n    #     substrate_thickness=1.0,\n    #     box_thickness=2.0,\n    #     core_thickness=220 * nm,\n    #     top_clad_thickness=2.0,\n    #     air_gap_thickness=1.0,\n    #     fiber_thickness=2.0,\n    #     res=20,  # pixels/um\n    #     wavelength_min=1.4,\n    #     wavelength_max=1.7,\n    #     wavelength_points=150,\n    #     fiber_port_y_offset_from_air=1,\n    #     waveguide_port_x_offset_from_grating_start=10,\n    #     overwrite=True,\n    #     verbosity=0,\n    #     decay_by=1e-3,\n    # )\n    # instance2 = instance1.copy()\n    # instance2[\"period\"] = 0.5\n    # write_sparameters_meep_batch(\n    #     instances=[instance1, instance2],\n    #     cores_per_instance=4,\n    #     total_cores=8,\n    #     verbosity=True,\n    #     delete_temp_files=True,\n    # )\n\n    from kplugins.plot import plot_sparameters\n\n    sp = write_sparameters_grating(fiber_angle_deg=15)\n    plot_sparameters(sp)", ""]}
{"filename": "kplugins/kmeep/get_simulation_grating_farfield.py", "chunked_list": ["\"\"\"FIXME: needs some work.\n\n- figure out get_farfield outputs\n- add tutorial in docs/notebooks/plugins/meep/002_gratings.ipynb\n- add filecache\n- benchmark with lumerical and tidy3d\n- add tests\n\n\"\"\"\nfrom __future__ import annotations", "\"\"\"\nfrom __future__ import annotations\n\nfrom typing import Any, Dict, List, Optional\n\nimport meep as mp\nimport numpy as np\n\n\nnm = 1e-3", "\nnm = 1e-3\nnSi = 3.48\nnSiO2 = 1.44\n\n\ndef fiber_core_material(fiber_numerical_aperture, fiber_clad_material):\n    return (fiber_numerical_aperture**2 + fiber_clad_material**2) ** 0.5\n\n\ndef get_simulation_grating_farfield(\n    period: float = 0.66,\n    fill_factor: float = 0.5,\n    n_periods: int = 30,\n    widths: Optional[List[float]] = None,\n    gaps: Optional[List[float]] = None,\n    etch_depth: float = 70 * nm,\n    fiber_angle_deg: float = 20.0,\n    fiber_xposition: float = 1.0,\n    fiber_core_diameter: float = 10.4,\n    fiber_numerical_aperture: float = 0.14,\n    fiber_clad_material: float = nSiO2,\n    core_material: float = nSi,\n    clad_material: float = nSiO2,\n    nsubstrate: float = nSi,\n    pml_thickness: float = 1,\n    box_thickness: float = 2.0,\n    clad_thickness: float = 2.0,\n    core_thickness: float = 220 * nm,\n    resolution: int = 64,  # pixels/um\n    wavelength_min: float = 1.5,\n    wavelength_max: float = 1.6,\n    wavelength_points: int = 50,\n) -> Dict[str, Any]:\n    \"\"\"Returns grating coupler far field simulation.\n\n    FIXME! needs some more work.\n\n    na**2 = core_material**2 - clad_material**2\n    core_material = sqrt(na**2 + core_material**2)\n\n    Args:\n        period: fiber grating period.\n        fill_factor: fraction of the grating period\n            filled with the grating material.\n        n_periods: number of periods\n        widths: Optional list of widths.\n            Overrides period, fill_factor, n_periods.\n        gaps: Optional list of gaps. Overrides period, fill_factor, n_periods.\n        etch_depth: grating etch depth.\n        fiber_angle_deg: fiber angle in degrees.\n        fiber_xposition: xposition.\n        fiber_core_diameter: fiber diameter.\n        fiber_numerical_aperture: NA.\n        fiber_clad_material: fiber cladding index.\n        core_material: fiber index core.\n        clad_material: top cladding index.\n        nbox: box index bottom.\n        nsubstrate: index substrate.\n        pml_thickness: pml_thickness (um).\n        substrate_thickness: substrate_thickness (um).\n        box_thickness: thickness for bottom cladding (um).\n        core_thickness: core_thickness (um).\n        top_clad_thickness: thickness of the top cladding.\n        air_gap_thickness: air gap thickness.\n        resolution: resolution pixels/um.\n        wavelength_min: min wavelength (um).\n        wavelength_max: max wavelength (um).\n        wavelength_points: wavelength points.\n\n\n    Some parameters are different from get_simulation_grating_fiber\n        fiber_thickness: fiber_thickness.\n\n    \"\"\"\n    wavelengths = np.linspace(wavelength_min, wavelength_max, wavelength_points)\n    wavelength = np.mean(wavelengths)\n    freqs = 1 / wavelengths\n    widths = widths or n_periods * [period * fill_factor]\n    gaps = gaps or n_periods * [period * (1 - fill_factor)]\n\n    settings = dict(\n        period=period,\n        fill_factor=fill_factor,\n        fiber_angle_deg=fiber_angle_deg,\n        fiber_xposition=fiber_xposition,\n        fiber_core_diameter=fiber_core_diameter,\n        fiber_numerical_aperture=fiber_core_diameter,\n        fiber_clad_material=fiber_clad_material,\n        resolution=resolution,\n        core_material=core_material,\n        clad_material=clad_material,\n        nsubstrate=nsubstrate,\n        n_periods=n_periods,\n        box_thickness=box_thickness,\n        clad_thickness=clad_thickness,\n        etch_depth=etch_depth,\n        wavelength_min=wavelength_min,\n        wavelength_max=wavelength_max,\n        wavelength_points=wavelength_points,\n        widths=widths,\n        gaps=gaps,\n    )\n    length_grating = np.sum(widths) + np.sum(gaps)\n\n    substrate_thickness = 1.0\n    hair = 4\n    core_material = mp.Medium(index=core_material)\n    clad_material = mp.Medium(index=clad_material)\n    fiber_angle = np.radians(fiber_angle_deg)\n\n    y_offset = 0\n    x_offset = 0\n\n    # Minimally-parametrized computational cell\n    # Could be further optimized\n\n    # X-domain\n    dbufferx = 0.5\n    if length_grating < 3 * fiber_core_diameter:\n        sxy = 3 * fiber_core_diameter + 2 * dbufferx + 2 * pml_thickness\n    else:  # Fiber probably to the left\n        sxy = (\n            3 / 2 * fiber_core_diameter\n            + length_grating / 2\n            + 2 * dbufferx\n            + 2 * pml_thickness\n        )\n\n    # Useful reference points\n    cell_edge_left = -sxy / 2 + dbufferx + pml_thickness\n    grating_start = -fiber_xposition\n\n    # Y-domain (using z notation from 3D legacy code)\n    dbuffery = 0.5\n    sz = (\n        2 * dbuffery\n        + box_thickness\n        + core_thickness\n        + hair\n        + substrate_thickness\n        + 2 * pml_thickness\n    )\n\n    # Initialize domain x-z plane simulation\n    cell_size = mp.Vector3(sxy, sz)\n\n    # Ports (position, sizes, directions)\n    fiber_offset_from_angle = (clad_thickness + core_thickness) * np.tan(fiber_angle)\n    fiber_port_center = mp.Vector3(\n        (0.5 * sz - pml_thickness + y_offset - 1) * np.sin(fiber_angle)\n        + cell_edge_left\n        + 3 / 2 * fiber_core_diameter\n        - fiber_offset_from_angle,\n        0.5 * sz - pml_thickness + y_offset - 1,\n    )\n    fiber_port_size = mp.Vector3(3 * fiber_core_diameter, 0, 0)\n    # fiber_port_direction = mp.Vector3(y=-1).rotate(mp.Vector3(z=1), -1 * fiber_angle)\n\n    waveguide_port_center = mp.Vector3(-sxy / 4)\n    waveguide_port_size = mp.Vector3(0, 2 * clad_thickness - 0.2)\n    waveguide_port_direction = mp.X\n\n    # Geometry\n    fiber_clad = 120\n    hfiber_geom = 100  # Some large number to make fiber extend into PML\n\n    fiber_core_material = (\n        fiber_numerical_aperture**2 + fiber_clad_material**2\n    ) ** 0.5\n    fiber_clad_material = mp.Medium(index=fiber_clad_material)\n    fiber_core_material = mp.Medium(index=fiber_core_material)\n\n    geometry = [\n        mp.Block(\n            material=fiber_clad_material,\n            center=mp.Vector3(\n                x=grating_start + fiber_xposition - fiber_offset_from_angle\n            ),\n            size=mp.Vector3(fiber_clad, hfiber_geom),\n            e1=mp.Vector3(x=1).rotate(mp.Vector3(z=1), -1 * fiber_angle),\n            e2=mp.Vector3(y=1).rotate(mp.Vector3(z=1), -1 * fiber_angle),\n        )\n    ]\n\n    geometry.append(\n        mp.Block(\n            material=fiber_core_material,\n            center=mp.Vector3(\n                x=grating_start + fiber_xposition - fiber_offset_from_angle\n            ),\n            size=mp.Vector3(fiber_core_diameter, hfiber_geom),\n            e1=mp.Vector3(x=1).rotate(mp.Vector3(z=1), -1 * fiber_angle),\n            e2=mp.Vector3(y=1).rotate(mp.Vector3(z=1), -1 * fiber_angle),\n        )\n    )\n\n    # clad\n    geometry.append(\n        mp.Block(\n            material=clad_material,\n            center=mp.Vector3(0, clad_thickness / 2),\n            size=mp.Vector3(mp.inf, clad_thickness),\n        )\n    )\n    # BOX\n    geometry.append(\n        mp.Block(\n            material=clad_material,\n            center=mp.Vector3(0, -0.5 * box_thickness),\n            size=mp.Vector3(mp.inf, box_thickness),\n        )\n    )\n\n    # waveguide\n    geometry.append(\n        mp.Block(\n            material=core_material,\n            center=mp.Vector3(0, core_thickness / 2),\n            size=mp.Vector3(mp.inf, core_thickness),\n        )\n    )\n\n    # grating etch\n    x = grating_start\n    for width, gap in zip(widths, gaps):\n        geometry.append(\n            mp.Block(\n                material=clad_material,\n                center=mp.Vector3(x + gap / 2, core_thickness - etch_depth / 2),\n                size=mp.Vector3(gap, etch_depth),\n            )\n        )\n        x += width + gap\n\n    # Substrate\n    geometry.append(\n        mp.Block(\n            material=mp.Medium(index=nsubstrate),\n            center=mp.Vector3(\n                0,\n                -0.5 * (core_thickness + substrate_thickness + pml_thickness + dbuffery)\n                - box_thickness,\n            ),\n            size=mp.Vector3(mp.inf, substrate_thickness + pml_thickness + dbuffery),\n        )\n    )\n\n    # PMLs\n    boundary_layers = [mp.PML(pml_thickness)]\n\n    # mode frequency\n    fcen = 1 / wavelength\n\n    # Waveguide source\n    sources_directions = [mp.X]\n    sources = [\n        mp.EigenModeSource(\n            src=mp.GaussianSource(fcen, fwidth=0.1 * fcen),\n            size=waveguide_port_size,\n            center=waveguide_port_center,\n            eig_band=1,\n            direction=sources_directions[0],\n            eig_match_freq=True,\n            eig_parity=mp.ODD_Z,\n        )\n    ]\n\n    # Ports\n    waveguide_monitor_port = mp.ModeRegion(\n        center=waveguide_port_center + mp.Vector3(x=0.2), size=waveguide_port_size\n    )\n    fiber_monitor_port = mp.ModeRegion(\n        center=fiber_port_center - mp.Vector3(y=0.2), size=fiber_port_size\n    )\n\n    sim = mp.Simulation(\n        resolution=resolution,\n        cell_size=cell_size,\n        boundary_layers=boundary_layers,\n        geometry=geometry,\n        sources=sources,\n        dimensions=2,\n        eps_averaging=True,\n    )\n\n    offset_vector = mp.Vector3(x_offset, y_offset)\n    nearfield = sim.add_near2far(\n        fcen,\n        0,\n        1,\n        mp.Near2FarRegion(\n            mp.Vector3(x_offset, 0.5 * sz - pml_thickness + y_offset) - offset_vector,\n            size=mp.Vector3(sxy - 2 * pml_thickness, 0),\n        ),\n    )\n\n    waveguide_monitor = sim.add_mode_monitor(\n        freqs, waveguide_monitor_port, yee_grid=True\n    )\n    fiber_monitor = sim.add_mode_monitor(freqs, fiber_monitor_port)\n    field_monitor_point = (0, 0, 0)\n\n    return dict(\n        sim=sim,\n        cell_size=cell_size,\n        freqs=freqs,\n        fcen=fcen,\n        waveguide_monitor=waveguide_monitor,\n        waveguide_port_direction=waveguide_port_direction,\n        fiber_monitor=fiber_monitor,\n        fiber_angle_deg=fiber_angle_deg,\n        sources=sources,\n        field_monitor_point=field_monitor_point,\n        initialized=False,\n        settings=settings,\n        nearfield=nearfield,\n    )", "\n\ndef get_simulation_grating_farfield(\n    period: float = 0.66,\n    fill_factor: float = 0.5,\n    n_periods: int = 30,\n    widths: Optional[List[float]] = None,\n    gaps: Optional[List[float]] = None,\n    etch_depth: float = 70 * nm,\n    fiber_angle_deg: float = 20.0,\n    fiber_xposition: float = 1.0,\n    fiber_core_diameter: float = 10.4,\n    fiber_numerical_aperture: float = 0.14,\n    fiber_clad_material: float = nSiO2,\n    core_material: float = nSi,\n    clad_material: float = nSiO2,\n    nsubstrate: float = nSi,\n    pml_thickness: float = 1,\n    box_thickness: float = 2.0,\n    clad_thickness: float = 2.0,\n    core_thickness: float = 220 * nm,\n    resolution: int = 64,  # pixels/um\n    wavelength_min: float = 1.5,\n    wavelength_max: float = 1.6,\n    wavelength_points: int = 50,\n) -> Dict[str, Any]:\n    \"\"\"Returns grating coupler far field simulation.\n\n    FIXME! needs some more work.\n\n    na**2 = core_material**2 - clad_material**2\n    core_material = sqrt(na**2 + core_material**2)\n\n    Args:\n        period: fiber grating period.\n        fill_factor: fraction of the grating period\n            filled with the grating material.\n        n_periods: number of periods\n        widths: Optional list of widths.\n            Overrides period, fill_factor, n_periods.\n        gaps: Optional list of gaps. Overrides period, fill_factor, n_periods.\n        etch_depth: grating etch depth.\n        fiber_angle_deg: fiber angle in degrees.\n        fiber_xposition: xposition.\n        fiber_core_diameter: fiber diameter.\n        fiber_numerical_aperture: NA.\n        fiber_clad_material: fiber cladding index.\n        core_material: fiber index core.\n        clad_material: top cladding index.\n        nbox: box index bottom.\n        nsubstrate: index substrate.\n        pml_thickness: pml_thickness (um).\n        substrate_thickness: substrate_thickness (um).\n        box_thickness: thickness for bottom cladding (um).\n        core_thickness: core_thickness (um).\n        top_clad_thickness: thickness of the top cladding.\n        air_gap_thickness: air gap thickness.\n        resolution: resolution pixels/um.\n        wavelength_min: min wavelength (um).\n        wavelength_max: max wavelength (um).\n        wavelength_points: wavelength points.\n\n\n    Some parameters are different from get_simulation_grating_fiber\n        fiber_thickness: fiber_thickness.\n\n    \"\"\"\n    wavelengths = np.linspace(wavelength_min, wavelength_max, wavelength_points)\n    wavelength = np.mean(wavelengths)\n    freqs = 1 / wavelengths\n    widths = widths or n_periods * [period * fill_factor]\n    gaps = gaps or n_periods * [period * (1 - fill_factor)]\n\n    settings = dict(\n        period=period,\n        fill_factor=fill_factor,\n        fiber_angle_deg=fiber_angle_deg,\n        fiber_xposition=fiber_xposition,\n        fiber_core_diameter=fiber_core_diameter,\n        fiber_numerical_aperture=fiber_core_diameter,\n        fiber_clad_material=fiber_clad_material,\n        resolution=resolution,\n        core_material=core_material,\n        clad_material=clad_material,\n        nsubstrate=nsubstrate,\n        n_periods=n_periods,\n        box_thickness=box_thickness,\n        clad_thickness=clad_thickness,\n        etch_depth=etch_depth,\n        wavelength_min=wavelength_min,\n        wavelength_max=wavelength_max,\n        wavelength_points=wavelength_points,\n        widths=widths,\n        gaps=gaps,\n    )\n    length_grating = np.sum(widths) + np.sum(gaps)\n\n    substrate_thickness = 1.0\n    hair = 4\n    core_material = mp.Medium(index=core_material)\n    clad_material = mp.Medium(index=clad_material)\n    fiber_angle = np.radians(fiber_angle_deg)\n\n    y_offset = 0\n    x_offset = 0\n\n    # Minimally-parametrized computational cell\n    # Could be further optimized\n\n    # X-domain\n    dbufferx = 0.5\n    if length_grating < 3 * fiber_core_diameter:\n        sxy = 3 * fiber_core_diameter + 2 * dbufferx + 2 * pml_thickness\n    else:  # Fiber probably to the left\n        sxy = (\n            3 / 2 * fiber_core_diameter\n            + length_grating / 2\n            + 2 * dbufferx\n            + 2 * pml_thickness\n        )\n\n    # Useful reference points\n    cell_edge_left = -sxy / 2 + dbufferx + pml_thickness\n    grating_start = -fiber_xposition\n\n    # Y-domain (using z notation from 3D legacy code)\n    dbuffery = 0.5\n    sz = (\n        2 * dbuffery\n        + box_thickness\n        + core_thickness\n        + hair\n        + substrate_thickness\n        + 2 * pml_thickness\n    )\n\n    # Initialize domain x-z plane simulation\n    cell_size = mp.Vector3(sxy, sz)\n\n    # Ports (position, sizes, directions)\n    fiber_offset_from_angle = (clad_thickness + core_thickness) * np.tan(fiber_angle)\n    fiber_port_center = mp.Vector3(\n        (0.5 * sz - pml_thickness + y_offset - 1) * np.sin(fiber_angle)\n        + cell_edge_left\n        + 3 / 2 * fiber_core_diameter\n        - fiber_offset_from_angle,\n        0.5 * sz - pml_thickness + y_offset - 1,\n    )\n    fiber_port_size = mp.Vector3(3 * fiber_core_diameter, 0, 0)\n    # fiber_port_direction = mp.Vector3(y=-1).rotate(mp.Vector3(z=1), -1 * fiber_angle)\n\n    waveguide_port_center = mp.Vector3(-sxy / 4)\n    waveguide_port_size = mp.Vector3(0, 2 * clad_thickness - 0.2)\n    waveguide_port_direction = mp.X\n\n    # Geometry\n    fiber_clad = 120\n    hfiber_geom = 100  # Some large number to make fiber extend into PML\n\n    fiber_core_material = (\n        fiber_numerical_aperture**2 + fiber_clad_material**2\n    ) ** 0.5\n    fiber_clad_material = mp.Medium(index=fiber_clad_material)\n    fiber_core_material = mp.Medium(index=fiber_core_material)\n\n    geometry = [\n        mp.Block(\n            material=fiber_clad_material,\n            center=mp.Vector3(\n                x=grating_start + fiber_xposition - fiber_offset_from_angle\n            ),\n            size=mp.Vector3(fiber_clad, hfiber_geom),\n            e1=mp.Vector3(x=1).rotate(mp.Vector3(z=1), -1 * fiber_angle),\n            e2=mp.Vector3(y=1).rotate(mp.Vector3(z=1), -1 * fiber_angle),\n        )\n    ]\n\n    geometry.append(\n        mp.Block(\n            material=fiber_core_material,\n            center=mp.Vector3(\n                x=grating_start + fiber_xposition - fiber_offset_from_angle\n            ),\n            size=mp.Vector3(fiber_core_diameter, hfiber_geom),\n            e1=mp.Vector3(x=1).rotate(mp.Vector3(z=1), -1 * fiber_angle),\n            e2=mp.Vector3(y=1).rotate(mp.Vector3(z=1), -1 * fiber_angle),\n        )\n    )\n\n    # clad\n    geometry.append(\n        mp.Block(\n            material=clad_material,\n            center=mp.Vector3(0, clad_thickness / 2),\n            size=mp.Vector3(mp.inf, clad_thickness),\n        )\n    )\n    # BOX\n    geometry.append(\n        mp.Block(\n            material=clad_material,\n            center=mp.Vector3(0, -0.5 * box_thickness),\n            size=mp.Vector3(mp.inf, box_thickness),\n        )\n    )\n\n    # waveguide\n    geometry.append(\n        mp.Block(\n            material=core_material,\n            center=mp.Vector3(0, core_thickness / 2),\n            size=mp.Vector3(mp.inf, core_thickness),\n        )\n    )\n\n    # grating etch\n    x = grating_start\n    for width, gap in zip(widths, gaps):\n        geometry.append(\n            mp.Block(\n                material=clad_material,\n                center=mp.Vector3(x + gap / 2, core_thickness - etch_depth / 2),\n                size=mp.Vector3(gap, etch_depth),\n            )\n        )\n        x += width + gap\n\n    # Substrate\n    geometry.append(\n        mp.Block(\n            material=mp.Medium(index=nsubstrate),\n            center=mp.Vector3(\n                0,\n                -0.5 * (core_thickness + substrate_thickness + pml_thickness + dbuffery)\n                - box_thickness,\n            ),\n            size=mp.Vector3(mp.inf, substrate_thickness + pml_thickness + dbuffery),\n        )\n    )\n\n    # PMLs\n    boundary_layers = [mp.PML(pml_thickness)]\n\n    # mode frequency\n    fcen = 1 / wavelength\n\n    # Waveguide source\n    sources_directions = [mp.X]\n    sources = [\n        mp.EigenModeSource(\n            src=mp.GaussianSource(fcen, fwidth=0.1 * fcen),\n            size=waveguide_port_size,\n            center=waveguide_port_center,\n            eig_band=1,\n            direction=sources_directions[0],\n            eig_match_freq=True,\n            eig_parity=mp.ODD_Z,\n        )\n    ]\n\n    # Ports\n    waveguide_monitor_port = mp.ModeRegion(\n        center=waveguide_port_center + mp.Vector3(x=0.2), size=waveguide_port_size\n    )\n    fiber_monitor_port = mp.ModeRegion(\n        center=fiber_port_center - mp.Vector3(y=0.2), size=fiber_port_size\n    )\n\n    sim = mp.Simulation(\n        resolution=resolution,\n        cell_size=cell_size,\n        boundary_layers=boundary_layers,\n        geometry=geometry,\n        sources=sources,\n        dimensions=2,\n        eps_averaging=True,\n    )\n\n    offset_vector = mp.Vector3(x_offset, y_offset)\n    nearfield = sim.add_near2far(\n        fcen,\n        0,\n        1,\n        mp.Near2FarRegion(\n            mp.Vector3(x_offset, 0.5 * sz - pml_thickness + y_offset) - offset_vector,\n            size=mp.Vector3(sxy - 2 * pml_thickness, 0),\n        ),\n    )\n\n    waveguide_monitor = sim.add_mode_monitor(\n        freqs, waveguide_monitor_port, yee_grid=True\n    )\n    fiber_monitor = sim.add_mode_monitor(freqs, fiber_monitor_port)\n    field_monitor_point = (0, 0, 0)\n\n    return dict(\n        sim=sim,\n        cell_size=cell_size,\n        freqs=freqs,\n        fcen=fcen,\n        waveguide_monitor=waveguide_monitor,\n        waveguide_port_direction=waveguide_port_direction,\n        fiber_monitor=fiber_monitor,\n        fiber_angle_deg=fiber_angle_deg,\n        sources=sources,\n        field_monitor_point=field_monitor_point,\n        initialized=False,\n        settings=settings,\n        nearfield=nearfield,\n    )", "\n\ndef get_farfield(wavelength: float = 1.55, **kwargs):\n    \"\"\"FIXME: figure out outputs.\n\n    based on\n    http://www.simpetus.com/projects.html#meep_outcoupler\n    \"\"\"\n    sim_dict = get_simulation_grating_farfield(**kwargs)\n\n    sim = sim_dict[\"sim\"]\n    sim.run(until=400)\n\n    fcen = 1 / wavelength\n    r = 1000 / fcen  # 1000 wavelengths out from the source\n    npts = 1000  # number of points in [0,2*pi) range of angles\n\n    farfield_angles = []\n    farfield_power = []\n\n    nearfield = sim[\"nearfield\"]\n    for n in range(npts):\n        ff = sim.get_farfield(\n            nearfield,\n            mp.Vector3(r * np.cos(np.pi * (n / npts)), r * np.sin(np.pi * (n / npts))),\n        )\n        farfield_angles.append(\n            np.angle(np.cos(np.pi * (n / npts)) + 1j * np.sin(np.pi * (n / npts)))\n        )\n        farfield_power.append(ff)\n\n    farfield_angles = np.array(farfield_angles)\n    farfield_power = np.array(farfield_power)\n\n    return sim.get_eigenmode_coefficients(\n        sim_dict[\"waveguide_monitor\"], [1], eig_parity=mp.ODD_Z, direction=mp.X\n    )", "\n\ndef get_port_1D_eigenmode(\n    sim_dict,\n    band_num: int = 1,\n    fiber_angle_deg: float = 15,\n):\n    \"\"\"Args are the following.\n\n        sim_dict: simulation dict\n        band_num: band number to solve for\n        fiber_angle_deg\n\n    Returns:\n        Mode object compatible with /modes plugin\n    \"\"\"\n    # Initialize\n    sim = sim_dict[\"sim\"]\n    source = sim_dict[\"sources\"][0]\n    waveguide_monitor = sim_dict[\"waveguide_monitor\"]\n    fiber_monitor = sim_dict[\"fiber_monitor\"]\n\n    # Obtain source frequency\n    fsrc = source.src.frequency\n\n    # Obtain xsection\n    center_fiber = fiber_monitor.regions[0].center\n    size_fiber = fiber_monitor.regions[0].size\n    center_waveguide = waveguide_monitor.regions[0].center\n    size_waveguide = waveguide_monitor.regions[0].size\n\n    # Solve for the modes\n    if sim_dict[\"initialized\"] is False:\n        sim.init_sim()\n        sim_dict[\"initialized\"] = True\n\n    # Waveguide\n    eigenmode_waveguide = sim.get_eigenmode(\n        direction=mp.X,\n        where=mp.Volume(center=center_waveguide, size=size_waveguide),\n        band_num=band_num,\n        kpoint=mp.Vector3(\n            fsrc * 3.48, 0, 0\n        ),  # Hardcoded index for now, pull from simulation eventually\n        frequency=fsrc,\n    )\n    ys_waveguide = np.linspace(\n        center_waveguide.y - size_waveguide.y / 2,\n        center_waveguide.y + size_waveguide.y / 2,\n        int(sim.resolution * size_waveguide.y),\n    )\n    x_waveguide = center_waveguide.x\n\n    # Fiber\n    eigenmode_fiber = sim.get_eigenmode(\n        direction=mp.NO_DIRECTION,\n        where=mp.Volume(center=center_fiber, size=size_fiber),\n        band_num=band_num,\n        kpoint=mp.Vector3(0, fsrc * 1.45, 0).rotate(\n            mp.Vector3(z=1), -1 * np.radians(fiber_angle_deg)\n        ),  # Hardcoded index for now, pull from simulation eventually\n        frequency=fsrc,\n    )\n    xs_fiber = np.linspace(\n        center_fiber.x - size_fiber.x / 2,\n        center_fiber.x + size_fiber.x / 2,\n        int(sim.resolution * size_fiber.x),\n    )\n    y_fiber = center_fiber.y\n\n    return (\n        x_waveguide,\n        ys_waveguide,\n        eigenmode_waveguide,\n        xs_fiber,\n        y_fiber,\n        eigenmode_fiber,\n    )", "\n\ndef plot(sim) -> None:\n    \"\"\"sim: simulation object.\"\"\"\n    sim.plot2D(eps_parameters={\"contour\": True})\n    # plt.colorbar()\n\n\nif __name__ == \"__main__\":\n    import matplotlib.pyplot as plt\n\n    sim_dict = get_simulation_grating_farfield(fiber_xposition=1, fiber_angle_deg=15)\n\n    # plot(sim_dict[\"sim\"])\n    # plt.show()\n\n    # results = {}\n    # for angle in [10]:\n    #     print(angle)\n    #     (\n    #         x_waveguide,\n    #         ys_waveguide,\n    #         eigenmode_waveguide,\n    #         xs_fiber,\n    #         y_fiber,\n    #         eigenmode_fiber,\n    #     ) = get_port_1D_eigenmode(sim_dict, band_num=1, fiber_angle_deg=angle)\n    #     Ez_fiber = np.zeros(len(xs_fiber), dtype=np.complex128)\n    #     for i in range(len(xs_fiber)):\n    #         Ez_fiber[i] = eigenmode_fiber.amplitude(\n    #             mp.Vector3(xs_fiber[i], y_fiber, 0), mp.Ez\n    #         )\n    #     plt.plot(xs_fiber, np.abs(Ez_fiber))\n\n    # plt.xlabel(\"x (um)\")\n    # plt.ylabel(\"Ez (a.u.)\")\n    # plt.savefig(\"fiber.png\")\n\n    # # M1, E-field\n    # plt.figure(figsize=(10, 8), dpi=100)\n    # plt.suptitle(\n    #     \"MEEP get_eigenmode / MPB find_modes / Lumerical (manual)\",\n    #     y=1.05,\n    #     fontsize=18,\n    # )\n    # plt.show()\n\n    wavelength = 1.55\n    settings = {}\n    sim_dict = get_simulation_grating_farfield(**settings)\n\n    sim = sim_dict[\"sim\"]\n    sim.run(until=100)\n    # sim.run(until=400)\n\n    fcen = 1 / wavelength\n    r = 1000 / fcen  # 1000 wavelengths out from the source\n    npts = 1000  # number of points in [0,2*pi) range of angles\n\n    farfield_angles = []\n    farfield_power = []\n\n    nearfield = sim[\"nearfield\"]\n    for n in range(npts):\n        ff = sim.get_farfield(\n            nearfield,\n            mp.Vector3(r * np.cos(np.pi * (n / npts)), r * np.sin(np.pi * (n / npts))),\n        )\n        farfield_angles.append(\n            np.angle(np.cos(np.pi * (n / npts)) + 1j * np.sin(np.pi * (n / npts)))\n        )\n        farfield_power.append(ff)\n\n    farfield_angles = np.array(farfield_angles)\n    farfield_power = np.array(farfield_power)\n\n    # Waveguide\n    res_waveguide = sim.get_eigenmode_coefficients(\n        sim_dict[\"waveguide_monitor\"], [1], eig_parity=mp.ODD_Z, direction=mp.X\n    )\n    print(res_waveguide)\n    plt.plot(farfield_power)\n    plt.show()", "if __name__ == \"__main__\":\n    import matplotlib.pyplot as plt\n\n    sim_dict = get_simulation_grating_farfield(fiber_xposition=1, fiber_angle_deg=15)\n\n    # plot(sim_dict[\"sim\"])\n    # plt.show()\n\n    # results = {}\n    # for angle in [10]:\n    #     print(angle)\n    #     (\n    #         x_waveguide,\n    #         ys_waveguide,\n    #         eigenmode_waveguide,\n    #         xs_fiber,\n    #         y_fiber,\n    #         eigenmode_fiber,\n    #     ) = get_port_1D_eigenmode(sim_dict, band_num=1, fiber_angle_deg=angle)\n    #     Ez_fiber = np.zeros(len(xs_fiber), dtype=np.complex128)\n    #     for i in range(len(xs_fiber)):\n    #         Ez_fiber[i] = eigenmode_fiber.amplitude(\n    #             mp.Vector3(xs_fiber[i], y_fiber, 0), mp.Ez\n    #         )\n    #     plt.plot(xs_fiber, np.abs(Ez_fiber))\n\n    # plt.xlabel(\"x (um)\")\n    # plt.ylabel(\"Ez (a.u.)\")\n    # plt.savefig(\"fiber.png\")\n\n    # # M1, E-field\n    # plt.figure(figsize=(10, 8), dpi=100)\n    # plt.suptitle(\n    #     \"MEEP get_eigenmode / MPB find_modes / Lumerical (manual)\",\n    #     y=1.05,\n    #     fontsize=18,\n    # )\n    # plt.show()\n\n    wavelength = 1.55\n    settings = {}\n    sim_dict = get_simulation_grating_farfield(**settings)\n\n    sim = sim_dict[\"sim\"]\n    sim.run(until=100)\n    # sim.run(until=400)\n\n    fcen = 1 / wavelength\n    r = 1000 / fcen  # 1000 wavelengths out from the source\n    npts = 1000  # number of points in [0,2*pi) range of angles\n\n    farfield_angles = []\n    farfield_power = []\n\n    nearfield = sim[\"nearfield\"]\n    for n in range(npts):\n        ff = sim.get_farfield(\n            nearfield,\n            mp.Vector3(r * np.cos(np.pi * (n / npts)), r * np.sin(np.pi * (n / npts))),\n        )\n        farfield_angles.append(\n            np.angle(np.cos(np.pi * (n / npts)) + 1j * np.sin(np.pi * (n / npts)))\n        )\n        farfield_power.append(ff)\n\n    farfield_angles = np.array(farfield_angles)\n    farfield_power = np.array(farfield_power)\n\n    # Waveguide\n    res_waveguide = sim.get_eigenmode_coefficients(\n        sim_dict[\"waveguide_monitor\"], [1], eig_parity=mp.ODD_Z, direction=mp.X\n    )\n    print(res_waveguide)\n    plt.plot(farfield_power)\n    plt.show()", ""]}
{"filename": "kplugins/kmeep/test_write_sparameters_meep.py", "chunked_list": ["\"\"\"test meep sparameters.\"\"\"\n\nfrom __future__ import annotations\n\nimport numpy as np\n\nimport kfactory as gf\nimport kplugins as kpl\nimport kplugins.gmeep as gm\nfrom kgeneric import pdk as PDK", "import kplugins.gmeep as gm\nfrom kgeneric import pdk as PDK\nimport kgeneric as kg\nimport copy\n\nPDK.activate()\n\nsimulation_settings = dict(resolution=20, is_3d=False)\n\n\ndef test_sparameters_straight() -> None:\n    \"\"\"Checks Sparameters for a straight waveguide.\"\"\"\n    c = kg.cells.waveguide(0.5, length=2, layer=0)\n    p = 3\n    sp = gm.write_sparameters_meep(c, ymargin=0, overwrite=True, **simulation_settings)\n\n    # Check reasonable reflection/transmission\n    assert np.allclose(np.abs(sp[\"o1@0,o2@0\"]), 1, atol=1e-02), np.abs(sp[\"o1@0,o2@0\"])\n    assert np.allclose(np.abs(sp[\"o2@0,o1@0\"]), 1, atol=1e-02), np.abs(sp[\"o2@0,o1@0\"])\n    assert np.allclose(np.abs(sp[\"o1@0,o1@0\"]), 0, atol=5e-02), np.abs(sp[\"o1@0,o1@0\"])\n    assert np.allclose(np.abs(sp[\"o2@0,o2@0\"]), 0, atol=5e-02), np.abs(sp[\"o2@0,o2@0\"])", "\n\ndef test_sparameters_straight() -> None:\n    \"\"\"Checks Sparameters for a straight waveguide.\"\"\"\n    c = kg.cells.waveguide(0.5, length=2, layer=0)\n    p = 3\n    sp = gm.write_sparameters_meep(c, ymargin=0, overwrite=True, **simulation_settings)\n\n    # Check reasonable reflection/transmission\n    assert np.allclose(np.abs(sp[\"o1@0,o2@0\"]), 1, atol=1e-02), np.abs(sp[\"o1@0,o2@0\"])\n    assert np.allclose(np.abs(sp[\"o2@0,o1@0\"]), 1, atol=1e-02), np.abs(sp[\"o2@0,o1@0\"])\n    assert np.allclose(np.abs(sp[\"o1@0,o1@0\"]), 0, atol=5e-02), np.abs(sp[\"o1@0,o1@0\"])\n    assert np.allclose(np.abs(sp[\"o2@0,o2@0\"]), 0, atol=5e-02), np.abs(sp[\"o2@0,o2@0\"])", "\n\ndef test_sparameters_straight_symmetric() -> None:\n    \"\"\"Checks Sparameters for a straight waveguide.\"\"\"\n    c = kg.cells.waveguide(0.5, length=2, layer=0)\n    p = 3\n    # c = gf.add_padding_container(c, default=0, top=p, bottom=p)\n    # port_symmetries for straight\n    sp = gm.write_sparameters_meep(\n        c,\n        overwrite=True,\n        port_symmetries=kpl.port_symmetries.port_symmetries_1x1,\n        ymargin=0,\n        **simulation_settings,\n    )\n\n    # Check reasonable reflection/transmission\n    assert np.allclose(np.abs(sp[\"o1@0,o2@0\"]), 1, atol=1e-02), np.abs(sp[\"o1@0,o2@0\"])\n    assert np.allclose(np.abs(sp[\"o2@0,o1@0\"]), 1, atol=1e-02), np.abs(sp[\"o2@0,o1@0\"])\n    assert np.allclose(np.abs(sp[\"o1@0,o1@0\"]), 0, atol=5e-02), np.abs(sp[\"o1@0,o1@0\"])\n    assert np.allclose(np.abs(sp[\"o2@0,o2@0\"]), 0, atol=5e-02), np.abs(sp[\"o2@0,o2@0\"])", "\n\ndef test_sparameters_crossing_symmetric() -> None:\n    \"\"\"Checks Sparameters for a waveguide crossing exploiting symmetries.\"\"\"\n    c = gf.components.crossing()\n    sp = gm.write_sparameters_meep(\n        c,\n        overwrite=True,\n        port_symmetries=kpl.port_symmetries.port_symmetries_crossing,\n        ymargin=0,\n        **simulation_settings,\n    )\n    assert sp", "\n\ndef test_sparameters_straight_mpi() -> None:\n    \"\"\"Checks Sparameters for a straight waveguide using MPI.\"\"\"\n    c = kg.cells.waveguide(0.5, length=2, layer=0)\n    p = 3\n    # c = gf.add_padding_container(c, default=0, top=p, bottom=p)\n    filepath = gm.write_sparameters_meep_mpi(\n        c, ymargin=0, overwrite=True, **simulation_settings\n    )\n    sp = np.load(filepath)\n    sp = dict(sp)\n\n    # Check reasonable reflection/transmission\n    assert np.allclose(np.abs(sp[\"o1@0,o2@0\"]), 1, atol=1e-02), np.abs(sp[\"o1@0,o2@0\"])\n    assert np.allclose(np.abs(sp[\"o2@0,o1@0\"]), 1, atol=1e-02), np.abs(sp[\"o2@0,o1@0\"])\n    assert np.allclose(np.abs(sp[\"o1@0,o1@0\"]), 0, atol=5e-02), np.abs(sp[\"o1@0,o1@0\"])\n    assert np.allclose(np.abs(sp[\"o2@0,o2@0\"]), 0, atol=5e-02), np.abs(sp[\"o2@0,o2@0\"])\n\n    \"\"\"Now check different parameters are properly handled.\"\"\"\n    modified_settings = copy.deepcopy(simulation_settings)\n    modified_settings[\"wavelength_points\"] = 10\n    filepath2 = gm.write_sparameters_meep_mpi(\n        c, ymargin=0, overwrite=True, **modified_settings\n    )\n    sp2 = np.load(filepath2)\n    sp2 = dict(sp2)\n    assert len(sp[\"wavelengths\"]) != len(sp2[\"wavelengths\"])", "\n\ndef test_sparameters_straight_batch() -> None:\n    \"\"\"Checks Sparameters for a straight waveguide using an MPI pool.\"\"\"\n\n    components = []\n    p = 3\n    for length in [2]:\n        c = kg.cells.waveguide(0.5, length=length, layer=0)\n        # c = gf.add_padding_container(c, default=0, top=p, bottom=p)\n        components.append(c)\n\n    filepaths = gm.write_sparameters_meep_batch(\n        [\n            {\"component\": c, \"overwrite\": True, **simulation_settings}\n            for c in components\n        ],\n    )\n\n    filepath = filepaths[0]\n    sp = np.load(filepath)\n    sp = dict(sp)\n\n    # Check reasonable reflection/transmission\n    assert np.allclose(np.abs(sp[\"o1@0,o2@0\"]), 1, atol=1e-02), np.abs(sp[\"o1@0,o2@0\"])\n    assert np.allclose(np.abs(sp[\"o2@0,o1@0\"]), 1, atol=1e-02), np.abs(sp[\"o2@0,o1@0\"])\n    assert np.allclose(np.abs(sp[\"o1@0,o1@0\"]), 0, atol=5e-02), np.abs(sp[\"o1@0,o1@0\"])\n    assert np.allclose(np.abs(sp[\"o2@0,o2@0\"]), 0, atol=5e-02), np.abs(sp[\"o2@0,o2@0\"])\n\n    filepath2 = kpl.get_sparameters_path_meep(\n        component=c, layer_stack=PDK.layer_stack, **simulation_settings\n    )\n    assert (\n        filepath2 == filepaths[0]\n    ), f\"filepath returned {filepaths[0]} differs from {filepath2}\"", "\n\n# def test_sparameters_grating_coupler() -> None:\n#     \"\"\"Checks Sparameters for a grating coupler.\"\"\"\n#     sp = gm.write_sparameters_grating()  # fiber_angle_deg = 20\n#     assert sp\n\n\ndef test_sparameters_lazy_parallelism() -> None:\n    \"\"\"Checks that the Sparameters computed using MPI and lazy_parallelism flag give the same results as the serial calculation.\"\"\"\n    c = kg.cells.waveguide(0.5, length=2, layer=0)\n    p = 3\n\n    filepath_parallel = gm.write_sparameters_meep_mpi(\n        c, ymargin=0, overwrite=True, lazy_parallelism=True, **simulation_settings\n    )\n    sp_parallel = np.load(filepath_parallel)\n\n    filepath_serial = gm.write_sparameters_meep_mpi(\n        c, ymargin=0, overwrite=True, lazy_parallelism=False, **simulation_settings\n    )\n    sp_serial = dict(np.load(filepath_serial))\n\n    # Check matching reflection/transmission\n    assert np.allclose(sp_parallel[\"o1@0,o1@0\"], sp_serial[\"o1@0,o1@0\"], atol=1e-2)\n    assert np.allclose(sp_parallel[\"o2@0,o1@0\"], sp_serial[\"o2@0,o1@0\"], atol=1e-2)\n    assert np.allclose(sp_parallel[\"o1@0,o2@0\"], sp_serial[\"o1@0,o2@0\"], atol=1e-2)\n    assert np.allclose(sp_parallel[\"o2@0,o2@0\"], sp_serial[\"o2@0,o2@0\"], atol=1e-2)", "def test_sparameters_lazy_parallelism() -> None:\n    \"\"\"Checks that the Sparameters computed using MPI and lazy_parallelism flag give the same results as the serial calculation.\"\"\"\n    c = kg.cells.waveguide(0.5, length=2, layer=0)\n    p = 3\n\n    filepath_parallel = gm.write_sparameters_meep_mpi(\n        c, ymargin=0, overwrite=True, lazy_parallelism=True, **simulation_settings\n    )\n    sp_parallel = np.load(filepath_parallel)\n\n    filepath_serial = gm.write_sparameters_meep_mpi(\n        c, ymargin=0, overwrite=True, lazy_parallelism=False, **simulation_settings\n    )\n    sp_serial = dict(np.load(filepath_serial))\n\n    # Check matching reflection/transmission\n    assert np.allclose(sp_parallel[\"o1@0,o1@0\"], sp_serial[\"o1@0,o1@0\"], atol=1e-2)\n    assert np.allclose(sp_parallel[\"o2@0,o1@0\"], sp_serial[\"o2@0,o1@0\"], atol=1e-2)\n    assert np.allclose(sp_parallel[\"o1@0,o2@0\"], sp_serial[\"o1@0,o2@0\"], atol=1e-2)\n    assert np.allclose(sp_parallel[\"o2@0,o2@0\"], sp_serial[\"o2@0,o2@0\"], atol=1e-2)", "\n\nif __name__ == \"__main__\":\n    # test_sparameters_straight()\n    test_sparameters_straight_mpi()\n    # test_sparameters_crossing_symmetric(False)\n    # test_sparameterslazy_parallelism()\n    # test_sparameters_straight_symmetric()\n    # test_sparameters_straight_batch()\n    # test_sparameters_crossing_symmetric()", "    # test_sparameters_straight_batch()\n    # test_sparameters_crossing_symmetric()\n\n    # c = gf.components.straight(length=2)\n    # p = 3\n    # c = gf.add_padding_container(c, default=0, top=p, bottom=p)\n    # filepath = gm.write_sparameters_meep_mpi(\n    #     c, ymargin=0, overwrite=True, **simulation_settings\n    # )\n    # sp = dict(np.load(filepath))", "    # )\n    # sp = dict(np.load(filepath))\n\n    # # Check reasonable reflection/transmission\n    # assert np.allclose(np.abs(sp[\"o1@0,o2@0\"]), 1, atol=1e-02), np.abs(sp[\"o1@0,o2@0\"])\n"]}
{"filename": "kplugins/kmeep/get_meep_geometry.py", "chunked_list": ["from __future__ import annotations\n\nfrom typing import Dict, List, Optional, Union\n\nimport meep as mp\nimport numpy as np\n\nimport kgeneric as kf\nfrom kgeneric import pdk\nfrom kplugins.gmeep.get_material import get_material", "from kgeneric import pdk\nfrom kplugins.gmeep.get_material import get_material\nfrom kfactory.technology import LayerStack\nfrom kfactory.typings import CellSpec\n\n\ndef get_meep_geometry_from_component(\n    KCell: CellSpec,\n    layer_stack: Optional[LayerStack] = None,\n    material_name_to_meep: Optional[Dict[str, Union[str, float]]] = None,\n    wavelength: float = 1.55,\n    is_3d: bool = False,\n    dispersive: bool = False,\n    **kwargs,\n) -> List[mp.GeometricObject]:\n    \"\"\"Returns Meep geometry from a kfactory KCell.\n\n    Args:\n        KCell: kfactory KCell.\n        layer_stack: for material layers.\n        material_name_to_meep: maps layer_stack name to meep material name.\n        wavelength: in um.\n        is_3d: renders in 3D.\n        dispersive: add dispersion.\n        kwargs: settings.\n    \"\"\"\n    KCell = pdk.get_cell(cell=KCell, **kwargs)\n    layer_stack = layer_stack or pdk.layer_stack\n\n    layer_to_thickness = layer_stack.get_layer_to_thickness()\n    layer_to_material = layer_stack.get_layer_to_material()\n    layer_to_zmin = layer_stack.get_layer_to_zmin()\n    layer_to_sidewall_angle = layer_stack.get_layer_to_sidewall_angle()\n    # component_with_booleans = layer_stack.get_component_with_derived_layers(KCell)\n\n    geometry = []\n\n    for layer in KCell.kcl.layer_indices():\n        for shape in KCell._kdb_cell.shapes(layer):\n            height = layer_to_thickness[layer] if is_3d else mp.inf\n            zmin_um = layer_to_zmin[layer] if is_3d else 0\n            # center = mp.Vector3(0, 0, (zmin_um + height) / 2)\n\n            vertices = [mp.Vector3(p.x, p.y, zmin_um) for p in shape.each_dpoint()]\n            material_name = layer_to_material[layer]\n\n            if material_name:\n                material = get_material(\n                    name=material_name,\n                    dispersive=dispersive,\n                    material_name_to_meep=material_name_to_meep,\n                    wavelength=wavelength,\n                )\n                geometry.append(\n                    mp.Prism(\n                        vertices=vertices,\n                        height=height,\n                        sidewall_angle=layer_to_sidewall_angle[layer]\n                        if is_3d\n                        else 0,\n                        material=material,\n                        # center=center\n                    )\n                )\n    return geometry", "\n\n# def get_meep_geometry_from_cross_section(\n#     cross_section: CrossSectionSpec,\n#     extension_length: Optional[float] = None,\n#     layer_stack: Optional[LayerStack] = None,\n#     material_name_to_meep: Optional[Dict[str, Union[str, float]]] = None,\n#     wavelength: float = 1.55,\n#     dispersive: bool = False,\n#     **kwargs,", "#     dispersive: bool = False,\n#     **kwargs,\n# ) -> List[mp.GeometricObject]:\n#     x = kf.get_cross_section(cross_section=cross_section, **kwargs)\n\n#     x_sections = [\n#         kf.Section(offset=x.offset, layer=x.layer, width=x.width),\n#         *x.sections,\n#     ]\n", "#     ]\n\n#     layer_stack = layer_stack or get_layer_stack()\n\n#     layer_to_thickness = layer_stack.get_layer_to_thickness()\n#     layer_to_material = layer_stack.get_layer_to_material()\n#     layer_to_zmin = layer_stack.get_layer_to_zmin()\n#     layer_to_sidewall_angle = layer_stack.get_layer_to_sidewall_angle()\n\n#     geometry = []", "\n#     geometry = []\n#     for section in x_sections:\n#         print(f\"section: {section}\")\n#         layer = kf.get_layer(section.layer)\n\n#         if layer in layer_to_thickness and layer in layer_to_material:\n#             height = layer_to_thickness[layer]\n#             width = section.width\n#             offset = section.offset", "#             width = section.width\n#             offset = section.offset\n\n#             zmin_um = layer_to_zmin[layer] + (0 if height > 0 else -height)\n#             # center = mp.Vector3(0, 0, (zmin_um + height) / 2)\n\n#             material_name = layer_to_material[layer]\n#             material = get_material(\n#                 name=material_name,\n#                 dispersive=dispersive,", "#                 name=material_name,\n#                 dispersive=dispersive,\n#                 material_name_to_meep=material_name_to_meep,\n#                 wavelength=wavelength,\n#             )\n#             index = material.epsilon(1 / wavelength)[0, 0] ** 0.5\n#             print(f\"add {material_name!r} layer with index {index}\")\n#             # Don't need to use prism unless using sidewall angles\n#             if layer in layer_to_sidewall_angle:\n#                 # If using a prism, all dimensions need to be finite", "#             if layer in layer_to_sidewall_angle:\n#                 # If using a prism, all dimensions need to be finite\n#                 xspan = extension_length or 1\n#                 p = mp.Prism(\n#                     vertices=[\n#                         mp.Vector3(x=-xspan / 2, y=-width / 2, z=zmin_um),\n#                         mp.Vector3(x=-xspan / 2, y=width / 2, z=zmin_um),\n#                         mp.Vector3(x=xspan / 2, y=width / 2, z=zmin_um),\n#                         mp.Vector3(x=xspan / 2, y=-width / 2, z=zmin_um),\n#                     ],", "#                         mp.Vector3(x=xspan / 2, y=-width / 2, z=zmin_um),\n#                     ],\n#                     height=height,\n#                     center=mp.Vector3(y=offset, z=height / 2 + zmin_um),\n#                     sidewall_angle=np.deg2rad(layer_to_sidewall_angle[layer]),\n#                     material=material,\n#                 )\n#                 geometry.append(p)\n\n#             else:", "\n#             else:\n#                 xspan = extension_length or mp.inf\n#                 geometry.append(\n#                     mp.Block(\n#                         size=mp.Vector3(xspan, width, height),\n#                         material=material,\n#                         center=mp.Vector3(y=offset, z=height / 2 + zmin_um),\n#                     )\n#                 )", "#                     )\n#                 )\n#     return geometry\n\n\nif __name__ == \"__main__\":\n    import kplugins.gmeep as gm\n    import matplotlib.pyplot as plt\n\n    c = kf.components.taper_strip_to_ridge_trenches()\n    sp = gm.write_sparameters_meep(\n        c, run=False, ymargin_top=3, ymargin_bot=3, is_3d=True\n    )\n    plt.show()", "    # c.show(show_ports=True)\n"]}
{"filename": "kplugins/kmeep/meep_adjoint_optimization.py", "chunked_list": ["from __future__ import annotations\n\nfrom types import LambdaType\nfrom typing import Any, Callable, Dict, List, Optional, Tuple, Union\n\nimport nlopt\nimport numpy as np\nfrom meep import Block, EigenModeSource, MaterialGrid, Simulation, Vector3, Volume\nfrom meep.adjoint import DesignRegion, EigenmodeCoefficient, OptimizationProblem\nfrom meep.visualization import get_2D_dimensions", "from meep.adjoint import DesignRegion, EigenmodeCoefficient, OptimizationProblem\nfrom meep.visualization import get_2D_dimensions\nfrom numpy import ndarray\n\nimport kfactory as kf\nfrom kfactory import kdb\nfrom kfactory import KCell\nfrom kplugins.gmeep import get_simulation\nfrom kfactory.technology import LayerStack\nfrom kfactory.kcell import LayerEnum", "from kfactory.technology import LayerStack\nfrom kfactory.kcell import LayerEnum\nimport kgeneric as kg\n\n\ndef get_meep_adjoint_optimizer(\n    cell: KCell,\n    objective_function: Callable,\n    design_regions: List[DesignRegion],\n    design_variables: List[MaterialGrid],\n    design_update: np.ndarray,\n    TE_mode_number: int = 1,\n    resolution: int = 30,\n    cell_size: Optional[Tuple] = None,\n    extend_ports_length: Optional[float] = 10.0,\n    layer_stack: Optional[LayerStack] = None,\n    zmargin_top: float = 3.0,\n    zmargin_bot: float = 3.0,\n    tpml: float = 1.5,\n    clad_material: str = \"SiO2\",\n    is_3d: bool = False,\n    wavelength_start: float = 1.5,\n    wavelength_stop: float = 1.6,\n    wavelength_points: int = 50,\n    dfcen: float = 0.2,\n    port_source_name: str = \"o1\",\n    port_margin: float = 3,\n    distance_source_to_monitors: float = 0.2,\n    port_source_offset: float = 0,\n    port_monitor_offset: float = 0,\n    dispersive: bool = False,\n    material_name_to_meep: Optional[Dict[str, Union[str, float]]] = None,\n    **settings,\n):\n    \"\"\"Return a Meep `OptimizationProblem` object.\n\n    Args:\n        cell: kfactory cell.\n        objective_function: functions must be composed of \"field functions\" that transform the recorded fields.\n        design_regions: list of DesignRegion objects.\n        design_variables: list of MaterialGrid objects.\n        design_update: ndarray to initialize the optimization.\n        TE_mode_number: TE mode number.\n        resolution: in pixels/um (20: for coarse, 120: for fine).\n        cell_size: tuple of Simulation object dimensions in um.\n        extend_ports_length: to extend ports beyond the PML.\n        layer_stack: contains layer to thickness, zmin and material.\n            Defaults to active pdk.layer_stack.\n        zmargin_top: thickness for cladding above core.\n        zmargin_bot: thickness for cladding below core.\n        tpml: PML thickness (um).\n        clad_material: material for cladding.\n        is_3d: if True runs in 3D.\n        wavelength_start: wavelength min (um).\n        wavelength_stop: wavelength max (um).\n        wavelength_points: wavelength steps.\n        dfcen: delta frequency.\n        port_source_name: input port name.\n        port_margin: margin on each side of the port.\n        distance_source_to_monitors: in (um) source goes before.\n        port_source_offset: offset between source GDS port and source MEEP port.\n        port_monitor_offset: offset between monitor GDS port and monitor MEEP port.\n        dispersive: use dispersive material models (requires higher resolution).\n        material_name_to_meep: map layer_stack names with meep material database name\n            or refractive index. dispersive materials have a wavelength dependent index.\n\n    Keyword Args:\n        settings: extra simulation settings (resolution, symmetries, etc.)\n\n    Returns:\n        opt: OptimizationProblem object\n    \"\"\"\n    sim_dict = get_simulation(\n        cell,\n        resolution=resolution,\n        extend_ports_length=extend_ports_length,\n        layer_stack=layer_stack,\n        zmargin_top=zmargin_top,\n        zmargin_bot=zmargin_bot,\n        tpml=tpml,\n        clad_material=clad_material,\n        is_3d=is_3d,\n        wavelength_start=wavelength_start,\n        wavelength_stop=wavelength_stop,\n        wavelength_points=wavelength_points,\n        dfcen=dfcen,\n        port_source_name=port_source_name,\n        port_margin=port_margin,\n        distance_source_to_monitors=distance_source_to_monitors,\n        port_source_offset=port_source_offset,\n        port_monitor_offset=port_monitor_offset,\n        dispersive=dispersive,\n        material_name_to_meep=material_name_to_meep,\n        **settings,\n    )\n    sim = sim_dict[\"sim\"]\n\n    design_regions_geoms = [\n        Block(\n            center=design_region.center,\n            size=design_region.size,\n            material=design_variable,\n        )\n        for design_region, design_variable in zip(design_regions, design_variables)\n    ]\n\n    for design_region_geom in design_regions_geoms:\n        sim.geometry.append(design_region_geom)\n\n    cell_thickness = sim.cell_size[2]\n\n    monitors = sim_dict[\"monitors\"]\n    ob_list = [\n        EigenmodeCoefficient(\n            sim,\n            Volume(\n                center=monitor.regions[0].center,\n                size=monitor.regions[0].size,\n            ),\n            TE_mode_number,\n        )\n        for monitor in monitors.values()\n    ]\n\n    for design_region, design_variable in zip(design_regions, design_variables):\n        sim.geometry.append(\n            Block(design_region.size, design_region.center, material=design_variable)\n        )\n        block = cell._kdb_cell.shapes(0).insert(kdb.DBox(\n                (design_region.size[0], design_region.size[1])\n            )\n        )\n        block = block.transformed(kdb.Trans(0, False, design_region.center[0] / cell.kcl.dbu, design_region.center[1] / cell.kcl.dbu))\n\n    sim.cell_size = (\n        Vector3(*cell_size)\n        if cell_size\n        else Vector3(\n            cell._kdb_cell.dbbox().width() + 2 * sim.boundary_layers[0].thickness,\n            cell._kdb_cell.dbbox().height() + 2 * sim.boundary_layers[0].thickness,\n            cell_thickness,\n        )\n    )\n\n    source = [\n        EigenModeSource(\n            sim.sources[0].src,\n            eig_band=1,\n            direction=sim.sources[0].direction,\n            eig_kpoint=Vector3(1, 0, 0),\n            size=sim.sources[0].size,\n            center=sim.sources[0].center,\n        )\n    ]\n\n    sim.sources = source\n\n    opt = OptimizationProblem(\n        simulation=sim,\n        objective_functions=[objective_function],\n        objective_arguments=ob_list,\n        design_regions=design_regions,\n        frequencies=sim_dict[\"freqs\"],\n        decay_by=settings.get(\"decay_by\", 1e-5),\n    )\n\n    opt.update_design([design_update])\n    opt.plot2D(True)\n\n    return opt", "\n\ndef run_meep_adjoint_optimizer(\n    number_of_params: int,\n    cost_function: LambdaType,\n    update_variable: np.ndarray,\n    maximize_cost_function: bool = True,\n    algorithm: int = nlopt.LD_MMA,\n    lower_bound: Any = 0,\n    upper_bound: Any = 1,\n    maxeval: int = 10,\n    get_optimized_component: bool = False,\n    opt: Optional[OptimizationProblem] = None,\n    **kwargs,\n) -> Union[ndarray, KCell]:\n    \"\"\"Run adjoint optimization using Meep.\n\n    Args:\n        number_of_params: number of parameters to optimize (usually resolution_in_x * resolution_in_y).\n        cost_function: cost function to optimize.\n        update_variable: variable to update the optimization with.\n        maximize_cost_function: if True, maximize the cost function, else minimize it.\n        algorithm: nlopt algorithm to use (default: nlopt.LD_MMA).\n        lower_bound: lower bound for the optimization.\n        upper_bound: upper bound for the optimization.\n        maxeval: maximum number of evaluations.\n        get_optimized_component: if True, returns the optimized kfactory KCell.\n            If this is True, the Optimization object used for the optimization must be passed as an argument.\n        opt: OptimizationProblem object used for the optimization. Used only if get_optimized_component is True.\n\n    Keyword Args:\n        fcen: center frequency of the source.\n        upscale_factor: upscale factor for the optimization's grid.\n        threshold_offset_from_max: threshold offset from max eps value.\n        layer: layer to apply to the optimized cell.\n    \"\"\"\n    solver = nlopt.opt(algorithm, number_of_params)\n    solver.set_lower_bounds(lower_bound)\n    solver.set_upper_bounds(upper_bound)\n    if maximize_cost_function:\n        solver.set_max_objective(cost_function)\n    else:\n        solver.set_min_objective(cost_function)\n    solver.set_maxeval(maxeval)\n    update_variable[:] = solver.optimize(update_variable)\n\n    if get_optimized_component:\n        fcen = kwargs.get(\"fcen\", 1 / 1.55)\n        upscale_factor = kwargs.get(\"upscale_factor\", 2)\n        threshold_offset_from_max = kwargs.get(\"threshold_offset_from_max\", 0.01)\n        layer = kwargs.get(\"layer\", (1, 0))\n\n        return get_component_from_sim(\n            opt.sim, fcen, upscale_factor, threshold_offset_from_max, layer\n        )\n    return update_variable", "\n\ndef get_component_from_sim(\n    sim: Simulation,\n    fcen: float = 1 / 1.55,\n    upscale_factor: int = 2,\n    threshold_offset_from_max: float = 2.0,\n    layer: LayerEnum = 0,\n) -> KCell:\n    \"\"\"Get kfactory KCell from Meep Simulation object.\n\n    Args:\n        sim: Meep Simulation object.\n        fcen: center frequency of the source.\n        upscale_factor: upscale factor for the optimization's grid.\n        threshold_offset_from_max: threshold offset from max eps value.\n        layer: layer to apply to the optimized cell.\n\n    Returns:\n        kfactory KCell.\n    \"\"\"\n    grid_resolution = upscale_factor * sim.resolution\n    sim_center, sim_size = get_2D_dimensions(sim, output_plane=None)\n    xmin = sim_center.x - sim_size.x / 2\n    xmax = sim_center.x + sim_size.x / 2\n    ymin = sim_center.y - sim_size.y / 2\n    ymax = sim_center.y + sim_size.y / 2\n    Nx = int((xmax - xmin) * grid_resolution + 1)\n    Ny = int((ymax - ymin) * grid_resolution + 1)\n    xtics = np.linspace(xmin, xmax, Nx)\n    ytics = np.linspace(ymin, ymax, Ny)\n    ztics = np.array([sim_center.z])\n    eps_data = np.real(sim.get_epsilon_grid(xtics, ytics, ztics, frequency=fcen))\n\n    return kg.read.from_np(\n        eps_data,\n        nm_per_pixel=1e3 / grid_resolution,\n        layer=layer,\n        threshold=np.max(eps_data) - threshold_offset_from_max,\n    )", "\n\ndef _example_optim_geometry() -> KCell:\n    \"\"\"Dummy example of a cell to optimize.\"\"\"\n    from meep import Medium\n\n    design_region_width = 5\n    design_region_height = 4\n\n    resolution = 20\n    design_region_resolution = int(5 * resolution)\n\n    Nx = int(design_region_resolution * design_region_width)\n    Ny = int(design_region_resolution * design_region_height)\n\n    pml_size = 1.0\n    waveguide_length = 0.5\n    Sx = 2 * pml_size + 2 * waveguide_length + design_region_width\n\n    SiO2 = Medium(index=1.44)\n    Si = Medium(index=3.4)\n\n    design_variables = MaterialGrid(Vector3(Nx, Ny), SiO2, Si, grid_type=\"U_MEAN\")\n    design_region = DesignRegion(\n        design_variables,\n        volume=Volume(\n            center=Vector3(),\n            size=Vector3(design_region_width, design_region_height, 0),\n        ),\n    )\n\n    c = KCell(\"mmi1x2\")\n\n    arm_separation = 1.0\n    straight1 = c << kg.cells.waveguide(0.5, Sx / 2 + 1, 0)\n    straight1.move(straight1.ports[\"o2\"], (-design_region_width / 2.0, 0))\n    straight2 = c << kg.cells.waveguide(0.5, Sx / 2 + 1, 0)\n    straight2.move(\n        straight2.ports[\"o1\"], (design_region_width / 2.0, (arm_separation + 1.0) / 2.0)\n    )\n    straight3 = c << kg.cells.waveguide(0.5, Sx / 2 + 1, 0)\n    straight3.move(\n        straight3.ports[\"o1\"],\n        (design_region_width / 2.0, (-arm_separation - 1.0) / 2.0),\n    )\n\n    c.add_port(\"o1\", port=straight1.ports[\"o1\"])\n    c.add_port(\"o2\", port=straight2.ports[\"o2\"])\n    c.add_port(\"o3\", port=straight3.ports[\"o2\"])\n\n    return design_region, design_variables, c, Nx, Ny", "\n\nif __name__ == \"__main__\":\n    import autograd.numpy as npa\n\n    eta_i = 0.5\n\n    design_region, design_variables, c, Nx, Ny = _example_optim_geometry()\n\n    seed = 240\n    np.random.seed(seed)\n    x0 = np.random.rand(\n        Nx * Ny,\n    )\n\n    def J(source, top, bottom):\n        power = npa.abs(top / source) ** 2 + npa.abs(bottom / source) ** 2\n        return npa.mean(power)\n\n    opt = get_meep_adjoint_optimizer(\n        c,\n        J,\n        [design_region],\n        [design_variables],\n        x0,\n        cell_size=(15, 8),\n        extend_ports_length=0,\n        port_margin=0.75,\n        port_source_offset=-3.5,\n        port_monitor_offset=-3.5,\n    )\n\n    opt.plot2D(True)", ""]}
{"filename": "kplugins/kmeep/get_simulation.py", "chunked_list": ["\"\"\"Returns simulation from kcell.\"\"\"\nfrom __future__ import annotations\n\nimport inspect\nimport warnings\nfrom typing import Any, Dict, Optional, Union\n\nimport meep as mp\nimport numpy as np\n", "import numpy as np\n\nimport kfactory as kf\nimport kgeneric as kg\nfrom kfactory import KCell\nfrom kplugins.extensions import move_polar_rad_copy\nfrom kgeneric import pdk\nfrom kplugins.gmeep.get_material import get_material\nfrom kplugins.gmeep.get_meep_geometry import (\n    get_meep_geometry_from_component,", "from kplugins.gmeep.get_meep_geometry import (\n    get_meep_geometry_from_component,\n)\nfrom kfactory.technology import LayerStack\n\nmp.verbosity(0)\n\nsig = inspect.signature(mp.Simulation)\nsettings_meep = set(sig.parameters.keys())\n", "settings_meep = set(sig.parameters.keys())\n\n\ndef get_simulation(\n    kcell: KCell,\n    resolution: int = 30,\n    extend_ports_length: Optional[float] = 10.0,\n    layer_stack: Optional[LayerStack] = None,\n    zmargin_top: float = 3.0,\n    zmargin_bot: float = 3.0,\n    tpml: float = 1.5,\n    clad_material: str = \"SiO2\",\n    is_3d: bool = False,\n    wavelength_start: float = 1.5,\n    wavelength_stop: float = 1.6,\n    wavelength_points: int = 50,\n    dfcen: float = 0.2,\n    port_source_name: str = \"o1\",\n    port_margin: float = 3,\n    distance_source_to_monitors: float = 0.2,\n    port_source_offset: float = 0,\n    port_monitor_offset: float = 0,\n    dispersive: bool = False,\n    material_name_to_meep: Optional[Dict[str, Union[str, float]]] = None,\n    **settings,\n) -> Dict[str, Any]:\n    r\"\"\"Returns Simulation dict from kfactory KCell.\n\n    based on meep directional coupler example\n    https://meep.readthedocs.io/en/latest/Python_Tutorials/GDSII_Import/\n\n    https://support.lumerical.com/hc/en-us/articles/360042095873-Metamaterial-S-parameter-extraction\n\n    .. code::\n\n         top view\n              ________________________________\n             |                               |\n             | xmargin_left                  | port_extension\n             |<------>          port_margin ||<-->\n          ___|___________          _________||___\n             |           \\        /          |\n             |            \\      /           |\n             |             ======            |\n             |            /      \\           |\n          ___|___________/        \\__________|___\n             |   |                 <-------->|\n             |   |ymargin_bot   xmargin_right|\n             |   |                           |\n             |___|___________________________|\n\n        side view\n              ________________________________\n             |                     |         |\n             |                     |         |\n             |                   zmargin_top |\n             |ymargin              |         |\n             |<---> _____         _|___      |\n             |     |     |       |     |     |\n             |     |     |       |     |     |\n             |     |_____|       |_____|     |\n             |       |                       |\n             |       |                       |\n             |       |zmargin_bot            |\n             |       |                       |\n             |_______|_______________________|\n\n\n    Args:\n        kcell: kfactory KCell.\n        resolution: in pixels/um (20: for coarse, 120: for fine).\n        extend_ports_length: to extend ports beyond the PML.\n        layer_stack: contains layer to thickness, zmin and material.\n            Defaults to active pdk.layer_stack.\n        zmargin_top: thickness for cladding above core.\n        zmargin_bot: thickness for cladding below core.\n        tpml: PML thickness (um).\n        clad_material: material for cladding.\n        is_3d: if True runs in 3D.\n        wavelength_start: wavelength min (um).\n        wavelength_stop: wavelength max (um).\n        wavelength_points: wavelength steps.\n        dfcen: delta frequency.\n        port_source_name: input port name.\n        port_margin: margin on each side of the port.\n        distance_source_to_monitors: in (um) source goes before.\n        port_source_offset: offset between source GDS port and source MEEP port.\n        port_monitor_offset: offset between monitor GDS port and monitor MEEP port.\n        dispersive: use dispersive material models (requires higher resolution).\n        material_name_to_meep: map layer_stack names with meep material database name\n            or refractive index. dispersive materials have a wavelength dependent index.\n\n    Keyword Args:\n        settings: extra simulation settings (resolution, symmetries, etc.)\n\n    Returns:\n        simulation dict: sim, monitors, sources.\n\n    Make sure you review the simulation before you simulate a kcell\n\n    .. code::\n\n        import kfactory as gf\n        import kfactory.simulation.meep as gm\n\n        c = gf.components.bend_circular()\n        gm.write_sparameters_meep(c, run=False)\n\n    \"\"\"\n    for setting in settings:\n        if setting not in settings_meep:\n            raise ValueError(f\"{setting!r} not in {sorted(settings_meep)}\")\n\n    layer_stack = layer_stack or pdk.layer_stack\n    layer_to_thickness = layer_stack.get_layer_to_thickness()\n\n    c = KCell()\n    component_ref = c << kcell\n\n    wavelength = (wavelength_start + wavelength_stop) / 2\n\n    wavelengths = np.linspace(wavelength_start, wavelength_stop, wavelength_points)\n    port_names = list(component_ref.ports.copy().get_all_named().keys())\n\n    if port_source_name not in port_names:\n        warnings.warn(f\"port_source_name={port_source_name!r} not in {port_names}\")\n        port_source = component_ref.ports[0]\n        port_source_name = port_source.name\n        warnings.warn(f\"Selecting port_source_name={port_source_name!r} instead.\")\n\n    assert isinstance(\n        kcell, KCell\n    ), f\"kcell needs to be a gf.KCell, got Type {type(kcell)}\"\n\n    if \"port_extension\" in settings:\n        port_extension = settings[\"port_settings\"]\n    else:\n        port_extension = 10.0\n    cell_extended = KCell()\n    for port in kcell.ports:\n        cell_ref = cell_extended << kcell\n        width = port.width * kcell.kcl.dbu if isinstance(port.width, int) else 1\n        extension = cell_extended.create_inst(\n            kf.cells.waveguide.waveguide(width, port_extension, layer=port.layer)\n        )\n        extension.align(\"o2\", cell_ref, port.name)\n        output_port = extension.ports[\"o1\"]\n        cell_extended.add_port(extension.ports[\"o1\"], name=port.name)\n\n    cell_extended.show()\n    cell_extended.flatten()\n\n    # geometry_center = [component_extended.x, component_extended.y]\n    # geometry_center = [0, 0]\n    # print(geometry_center)\n\n    layers_thickness = [\n        layer_to_thickness[layer.layer, layer.datatype]\n        for layer in kcell.kcl.layer_infos()\n        if (layer.layer, layer.datatype) in layer_to_thickness\n    ]\n\n    if layers_thickness is None:\n        raise ValueError(\n            f\"KCell layers {kcell.layers} not in {layer_to_thickness.keys()}. \"\n            \"Did you passed the correct layer_stack?\"\n        )\n\n    t_core = max(layers_thickness)\n    cell_thickness = tpml + zmargin_bot + t_core + zmargin_top + tpml if is_3d else 0\n\n    cell_size = mp.Vector3(\n        kcell._kdb_cell.dbbox().width() + 2 * tpml,\n        kcell._kdb_cell.dbbox().height() + 2 * tpml,\n        cell_thickness,\n    )\n\n    geometry = get_meep_geometry_from_component(\n        kcell=cell_extended,\n        layer_stack=layer_stack,\n        material_name_to_meep=material_name_to_meep,\n        wavelength=wavelength,\n        is_3d=is_3d,\n        dispersive=dispersive,\n    )\n\n    freqs = 1 / wavelengths\n    fcen = np.mean(freqs)\n    frequency_width = dfcen * fcen\n\n    # Add source\n    port = component_ref.ports[port_source_name]\n    angle_rad = np.radians(port.orientation)\n    width = port.d.width + 2 * port_margin\n    size_x = width * abs(np.sin(angle_rad))\n    size_y = width * abs(np.cos(angle_rad))\n    size_x = 0 if size_x < 0.001 else size_x\n    size_y = 0 if size_y < 0.001 else size_y\n    size_z = cell_thickness - 2 * tpml if is_3d else 20\n    size = [size_x, size_y, size_z]\n    xy_shifted = move_polar_rad_copy(\n        np.array(port.center), angle=angle_rad, length=port_source_offset\n    )\n    center = xy_shifted.tolist() + [0]  # (x, y, z=0)\n\n    if np.isclose(port.orientation, 0):\n        direction = mp.X\n    elif np.isclose(port.orientation, 90):\n        direction = mp.Y\n    elif np.isclose(port.orientation, 180):\n        direction = mp.X\n    elif np.isclose(port.orientation, 270):\n        direction = mp.Y\n    else:\n        raise ValueError(\n            f\"Port source {port_source_name!r} orientation {port.orientation} \"\n            \"not 0, 90, 180, 270 degrees\"\n        )\n\n    sources = [\n        mp.EigenModeSource(\n            src=mp.GaussianSource(fcen, fwidth=frequency_width),\n            size=size,\n            center=center,\n            eig_band=1,\n            eig_parity=mp.NO_PARITY if is_3d else mp.EVEN_Y + mp.ODD_Z,\n            eig_match_freq=True,\n            eig_kpoint=-1 * mp.Vector3(x=1).rotate(mp.Vector3(z=1), angle_rad),\n            direction=direction,\n        )\n    ]\n\n    sim = mp.Simulation(\n        cell_size=cell_size,\n        boundary_layers=[mp.PML(tpml)],\n        sources=sources,\n        geometry=geometry,\n        default_material=get_material(\n            name=clad_material,\n            material_name_to_meep=material_name_to_meep,\n            wavelength=wavelength,\n        ),\n        resolution=resolution,\n        **settings,\n    )\n\n    # Add port monitors dict\n    monitors = {}\n    for port_name in component_ref.ports.keys():\n        port = component_ref.ports[port_name]\n        angle_rad = np.radians(port.orientation)\n        width = port.d.width + 2 * port_margin\n        size_x = width * abs(np.sin(angle_rad))\n        size_y = width * abs(np.cos(angle_rad))\n        size_x = 0 if size_x < 0.001 else size_x\n        size_y = 0 if size_y < 0.001 else size_y\n        size = mp.Vector3(size_x, size_y, size_z)\n        size = [size_x, size_y, size_z]\n\n        # if monitor has a source move monitor inwards\n        length = (\n            -distance_source_to_monitors + port_source_offset\n            if port_name == port_source_name\n            else port_monitor_offset\n        )\n        xy_shifted = move_polar_rad_copy(\n            np.array(port.center), angle=angle_rad, length=length\n        )\n        center = xy_shifted.tolist() + [0]  # (x, y, z=0)\n        m = sim.add_mode_monitor(freqs, mp.ModeRegion(center=center, size=size))\n        m.z = 0\n        monitors[port_name] = m\n    return dict(\n        sim=sim,\n        cell_size=cell_size,\n        freqs=freqs,\n        monitors=monitors,\n        sources=sources,\n        port_source_name=port_source_name,\n        initialized=False,\n    )", "\n\nsig = inspect.signature(get_simulation)\nsettings_get_simulation = set(sig.parameters.keys()).union(settings_meep)\n\n\nif __name__ == \"__main__\":\n    import matplotlib.pyplot as plt\n\n    c = kg.cells.bend_circular()\n\n    sim_dict = get_simulation(\n        c,\n        is_3d=False,\n        # resolution=50,\n        # port_source_offset=-0.1,\n        # port_field_monitor_offset=-0.1,\n        # port_margin=2.5,\n    )\n    sim = sim_dict[\"sim\"]\n    sim.plot2D()\n    plt.show()\n\n    # Plot monitor cross-section (is_3D needs to be True)\n    # sim.init_sim()\n    # eps_data = sim.get_epsilon()\n\n    # from mayavi import mlab\n    # s = mlab.contour3d(eps_data, colormap=\"YlGnBu\")\n    # mlab.show()\n\n    print(settings_get_simulation)", ""]}
{"filename": "kplugins/lumerical/write_sparameters_lumerical.py", "chunked_list": ["\"\"\"Write Sparameters with Lumerical FDTD.\"\"\"\nfrom __future__ import annotations\n\nimport itertools\nimport shutil\nimport time\n\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Optional\n", "from typing import Any, Dict, List, Optional\n\nimport numpy as np\nimport omegaconf  # TODO: remove omegaconf\n\nimport kfactory as kf\n\nfrom kfactory.typings import CellSpec\nfrom kfactory.conf import logger\nfrom kfactory.pdk import LayerStack", "from kfactory.conf import logger\nfrom kfactory.pdk import LayerStack\nfrom kgeneric.pdk import LAYER_STACK\n\nfrom kplugins.get_sparameters_path import (\n    get_sparameters_path_lumerical as get_sparameters_path,\n)\nfrom kplugins.typings import PathType\nfrom kplugins.lumerical.simulation_settings import (\n    SIMULATION_SETTINGS_LUMERICAL_FDTD,", "from kplugins.lumerical.simulation_settings import (\n    SIMULATION_SETTINGS_LUMERICAL_FDTD,\n    SimulationSettingsLumericalFdtd,\n)\n\nrun_false_warning = \"\"\"\nYou have passed run=False to debug the simulation\n\nrun=False returns the simulation session for you to debug and make sure it is correct\n", "run=False returns the simulation session for you to debug and make sure it is correct\n\nTo compute the Sparameters you need to pass run=True\n\"\"\"\n\n\ndef set_material(session, structure: str, material: MaterialSpec) -> None:  # type: ignore\n    \"\"\"Sets the material of a structure.\n\n    Args:\n        session: lumerical session.\n        structure: name of the lumerical structure.\n        material: material spec, can be\n            a string from lumerical database materials.\n            a float or int, representing refractive index.\n            a complex for n, k materials.\n\n    \"\"\"\n    if isinstance(material, str):\n        session.setnamed(structure, \"material\", material)\n    elif isinstance(material, (int, float)):\n        session.setnamed(structure, \"index\", material)\n    elif isinstance(material, complex):\n        mat = session.addmaterial(\"(n,k) Material\")\n        session.setmaterial(mat, \"Refractive Index\", material.real)\n        session.setmaterial(mat, \"Imaginary Refractive Index\", material.imag)\n        session.setnamed(structure, \"material\", mat)\n    elif isinstance(material, (tuple, list)):\n        if len(material) != 2:\n            raise ValueError(\n                \"Complex material requires a tuple or list of two numbers \"\n                f\"(real, imag). Got {material} \"\n            )\n        real, imag = material\n        mat = session.addmaterial(\"(n,k) Material\")\n        session.setmaterial(mat, \"Refractive Index\", real)\n        session.setmaterial(mat, \"Imaginary Refractive Index\", imag)\n        session.setnamed(structure, \"material\", mat)\n    else:\n        raise ValueError(\n            f\"{material!r} needs to be a float refractive index, a complex number or tuple \"\n            \"or a string from lumerical's material database\"\n        )\n\n    return None", "\n\ndef plot_sparameters_lumerical(\n    cell: kf.KCell,\n    layer_stack: LayerStack = LAYER_STACK,\n    session: Optional[object] = None,\n    run: bool = True,\n    overwrite: bool = False,\n    dirpath: Optional[PathType] = None,\n    simulation_settings: SimulationSettingsLumericalFdtd = SIMULATION_SETTINGS_LUMERICAL_FDTD,\n    material_name_to_lumerical: Optional[Dict[str, MaterialSpec]] = None,\n    delete_fsp_files: bool = True,\n    solver: str = \"FDTD\",\n    input_port: str = \"o1\",\n    output_port: str = \"o2\",\n    **settings: Any,\n) -> str:\n    \"\"\"Plots and returns cell s-parameters using Lumerical INTERCONNECT.\n\n    If simulation exists it returns the Sparameters directly unless overwrite=True\n    which forces a re-run of the simulation\n\n    Writes s-parameters in both .npz and .csv format.\n\n    In the npz format you can see `S12m` where `m` stands for magnitude\n    and `S12a` where `a` stands for angle in radians\n\n    Your cells need to have ports, that will extend over the PML.\n\n    For your Fab technology you can overwrite\n\n    - simulation_settings\n    - dirpath\n    - layerStack\n\n    converts kfactory units (um) to Lumerical units (m)\n\n    Disclaimer: This function tries to extract Sparameters automatically\n    is hard to make a function that will fit all your possible simulation settings.\n    You can use this function for inspiration to create your own.\n\n    Args:\n        cell: kfactory cell\n        layer_stack: kfactory layer stack\n        session: lumerical session\n        run: if True runs the simulation\n        overwrite: if True overwrites the simulation\n        dirpath: directory where to write the simulation files\n        simulation_settings: simulation settings\n        material_name_to_lumerical: dictionary with material names\n        delete_fsp_files: if True deletes the .fsp files\n        solver: FDTD or MODE\n        settings: simulation settings\n\n    Returns:\n        result file path\n\n    \"\"\"\n\n    s_params: List[np.ndarray[str, np.dtype[Any]]] = []\n    insts = []\n    trans = []\n\n    cell = kf.get_cell(cell)\n\n    def recurse_insts(comp: kf.KCell, p=None):  # type: ignore\n        if p:\n            comp.transform(p)\n        for inst in comp.insts:\n            if inst.trans in trans:\n                continue\n            if inst.cell.name == cell.name:\n                continue\n            if len(inst.cell.insts) > 0:\n                if \"sim\" in inst.cell.info:\n                    trans.append(inst.trans)\n                    insts.append(inst)\n                    continue\n                recurse_insts(inst.cell.dup(), inst.instance.trans)\n            else:\n                insts.append(inst)\n                trans.append(inst.trans)\n\n    if \"sim\" not in cell.info and \"sparameters\" not in cell.info:\n        recurse_insts(cell)\n    paths: dict[str, Path] = {}\n    for inst in insts:\n        # paths = {}\n        cell_ = inst.cell\n        if not overwrite:\n            if \"sparameters\" in cell_.info:\n                path = Path(cell_.info[\"sparameters\"])\n                if path.exists():\n                    s_params.append(path)  # type: ignore\n                    paths[cell_.name] = path\n                    continue\n            if \"cells\" in cell_.info:\n                paths = {}\n                for cell2 in cell_.info[\"cells\"]:\n                    settings_ = cell_.info[\"cells\"][cell2]\n                    cell_2 = kf.get_cell(settings_[\"cell\"], **settings_[\"params\"])\n                    path = get_sparameters_path(\n                        cell_2,\n                        dirpath=dirpath,\n                        layer_stack=layer_stack or LAYER_STACK,\n                        **settings,\n                    )\n                    if overwrite or not path.exists():\n                        try:\n                            cell_solver = cell_.info[\"cells\"][cell2][\"sim\"]\n                        except KeyError:\n                            cell_solver = solver\n                        s_params.append(\n                            write_sparameters_lumerical(\n                                cell=cell_2,\n                                layer_stack=layer_stack,\n                                session=session,\n                                run=run,\n                                overwrite=overwrite,\n                                dirpath=dirpath,\n                                simulation_settings=simulation_settings,\n                                material_name_to_lumerical=material_name_to_lumerical,\n                                delete_fsp_files=delete_fsp_files,\n                                solver=cell_solver,\n                                **settings,\n                            )\n                        )\n                    paths[cell_2.name] = path\n\n            else:\n                print(\"Simulation exists\", cell_.name)\n                path = get_sparameters_path(\n                    cell_,\n                    dirpath=dirpath,\n                    layer_stack=layer_stack or LAYER_STACK,\n                    **settings,\n                )\n                if path.exists():\n                    s_params.append(np.load(path))\n                    paths[cell_.name] = path\n                else:\n                    s_params.append(\n                        write_sparameters_lumerical(\n                            cell=cell_,\n                            layer_stack=layer_stack,\n                            session=session,\n                            run=run,\n                            overwrite=overwrite,\n                            dirpath=dirpath,\n                            simulation_settings=simulation_settings,\n                            material_name_to_lumerical=material_name_to_lumerical,\n                            delete_fsp_files=delete_fsp_files,\n                            solver=solver,\n                            **settings,\n                        )\n                    )\n                paths[cell_.name] = path\n        else:\n            s_params.append(\n                write_sparameters_lumerical(\n                    cell=cell_,\n                    layer_stack=layer_stack,\n                    session=session,\n                    run=run,\n                    overwrite=overwrite,\n                    dirpath=dirpath,\n                    simulation_settings=simulation_settings,\n                    material_name_to_lumerical=material_name_to_lumerical,\n                    delete_fsp_files=delete_fsp_files,\n                    solver=solver,\n                    **settings,\n                )\n            )\n            paths[cell_.name] = get_sparameters_path(\n                cell_,\n                dirpath=dirpath,\n                layer_stack=layer_stack or LAYER_STACK,\n                **settings,\n            )\n    if len(s_params) > 1:\n        try:\n            import sys\n\n            sys.path.append(\"C:\\\\Program Files\\\\Lumerical\\\\v231\\\\api\\\\python\\\\\")\n            import lumapi  # type: ignore\n        except ModuleNotFoundError as e:\n            print(\n                \"Cannot import lumapi (Python Lumerical API). \"\n                \"You can add set the PYTHONPATH variable or add it with `sys.path.append()`\"\n            )\n            raise e\n        except OSError as e:\n            raise e\n        s = lumapi.INTERCONNECT()\n        s.switchtodesign()\n        s.clear()\n        s.deleteall()\n        s.addelement(\"Optical Network Analyzer\")\n        s.set(\"name\", \"ONA\")\n        s.set(\"number of input ports\", len(cell.ports._ports) - 1)\n        s.set(\"input parameter\", 2)\n        s.set(\"start frequency\", 3e8 / simulation_settings.wavelength_stop / 1e-6)\n        s.set(\"stop frequency\", 3e8 / simulation_settings.wavelength_start / 1e-6)\n        s.set(\"number of points\", simulation_settings.wavelength_points)\n        cells: dict[tuple[float, float], Any] = {}\n        for instance in insts:\n            for port in instance.ports:\n                if port.d.position in cells:\n                    cells[port.d.position].update(\n                        {port: port.name, \"instance2\": instance}\n                    )\n                else:\n                    cells[port.d.position] = {port: port.name, \"instance1\": instance}\n\n        inputs: List[Any] = []\n        input = input_port\n        outputs: List[Any] = []\n        output = output_port\n        for value in cells.values():\n            inv_comp = False\n            instances = (\n                [value[\"instance1\"], value[\"instance2\"]]\n                if \"instance2\" in value\n                else [value[\"instance1\"]]\n            )\n            for i, instance in enumerate(instances):\n                if instance.cell.name not in paths:\n                    value[f\"instance{i+1}\"] = None\n                    for key, val in value.items():\n                        if key in instance.ports:\n                            value[key] = None\n                            value.pop(key)\n                    inv_comp = True\n                    instances.remove(instance)\n                    continue\n                if paths[instance.cell.name].with_suffix(\".ldf\").exists():\n                    s.addelement(\"MODE Waveguide\")\n                    s.setnamed(f\"WGD_1\", \"name\", f\"{instance.cell.name, instance.hash}\")\n                    s.setnamed(\n                        f\"{instance.cell.name, instance.hash}\", \"load from file\", True\n                    )\n                    s.setnamed(\n                        f\"{instance.cell.name, instance.hash}\",\n                        \"mode filename\",\n                        paths[instance.cell.name].with_suffix(\".ldf\").as_posix(),\n                    )\n                else:\n                    s.addelement(\"Optical N Port S-Parameter\")\n                    s.setnamed(\n                        f\"SPAR_1\", \"name\", f\"{instance.cell.name, instance.hash}\"\n                    )\n                    s.setnamed(\n                        f\"{instance.cell.name, instance.hash}\", \"load from file\", True\n                    )\n                    filepath_cell = get_sparameters_path(\n                        instance,\n                        dirpath=dirpath,\n                        simulation_settings=simulation_settings,\n                    )\n                    s.setnamed(\n                        f\"{instance.cell.name, instance.hash}\",\n                        \"s parameters filename\",\n                        paths[instance.cell.name].as_posix().replace(\".npz\", \".dat\"),\n                    )\n                s.setnamed(\n                    f\"{instance.cell.name, instance.hash}\",\n                    \"x position\",\n                    instance.instance.dbbox().center().x * 100,\n                )\n                s.setnamed(\n                    f\"{instance.cell.name, instance.hash}\",\n                    \"y position\",\n                    instance.instance.dbbox().center().y * 100,\n                )\n\n            if inv_comp:\n                continue\n            ports = [\n                value[port]\n                for port in value\n                if port is not None and port != \"instance1\" and port != \"instance2\"\n            ]\n            ports_ = [\n                port\n                for port in value\n                if port is not None and port != \"instance1\" and port != \"instance2\"\n            ]\n            # ports.remove(None) if None in ports else None\n            if len(ports) > 1 and ports[1] not in [p.name for p in instances[1].ports]:\n                ports = ports[::-1]\n            # if \"cells\" in cell.info:\n            # for cell_ in cell.info[\"cells\"]:\n            #     cell__ = cell.info[\"cells\"][cell_][\"cell\"]\n            #     settings__ = cell.info[\"cells\"][cell_][\"params\"]\n            #     print(kf.get_cell(cell__, **settings__).name)\n            if len(instances) == 2:\n                s.connect(\n                    f\"{instances[0].cell.name, instances[0].hash}\",\n                    ports[0],\n                    f\"{instances[1].cell.name, instances[1].hash}\",\n                    ports[1],\n                )\n            else:\n                print(cell.ports, value)\n                input_port = (\n                    ports[0]\n                    if input_port in cell.ports.get_all_named().keys()\n                    and ports_[0].d.position == cell.ports[input_port].d.position\n                    else input\n                )\n                output_port = (\n                    ports[0]\n                    if output_port in cell.ports.get_all_named().keys()\n                    and ports_[0].d.position == cell.ports[output_port].d.position\n                    else output\n                )\n                inputs = [instances[0], input_port] if input != input_port else inputs\n                outputs = (\n                    [instances[0], output_port] if output != output_port else outputs\n                )\n        s.connect(\n            \"ONA\",\n            f\"input 1\",\n            f\"{inputs[0].cell.name, inputs[0].hash}\",\n            f\"{inputs[1]}\",\n        )\n        path3 = get_sparameters_path(\n            cell, dirpath=dirpath, simulation_settings=simulation_settings\n        )\n        s.save(path3.as_posix().replace(\".npz\", \".ice\"))\n        s.connect(\n            \"ONA\",\n            \"output\",\n            f\"{outputs[0].cell.name, outputs[0].hash}\",\n            f\"{outputs[1]}\",\n        )\n        s.run()\n        s.save(path3.as_posix().replace(\".npz\", \".ice\"))\n\n        s.exportcsvresults(path3.as_posix().replace(\".npz\", \".csv\"))\n\n        return path3.as_posix().replace(\".npz\", \"/ONA.csv\")", "\n\ndef write_sparameters_lumerical(\n    cell: CellSpec,\n    layer_stack: LayerStack = LAYER_STACK,\n    session: Optional[object] = None,\n    run: bool = True,\n    overwrite: bool = False,\n    dirpath: Optional[PathType] = None,\n    simulation_settings: SimulationSettingsLumericalFdtd = SIMULATION_SETTINGS_LUMERICAL_FDTD,\n    material_name_to_lumerical: Optional[Dict[str, MaterialSpec]] = None,\n    delete_fsp_files: bool = True,\n    solver: str = \"FDTD\",\n    **settings: Any,\n) -> np.ndarray[str, np.dtype[Any]] | Any:\n    r\"\"\"Returns and writes cell Sparameters using Lumerical FDTD.\n\n    If simulation exists it returns the Sparameters directly unless overwrite=True\n    which forces a re-run of the simulation\n\n    Writes Sparameters both in .npz and .DAT (interconnect format) as well as\n    simulation settings in .YAML\n\n    In the npz format you can see `S12m` where `m` stands for magnitude\n    and `S12a` where `a` stands for angle in radians\n\n    Your cells need to have ports, that will extend over the PML.\n\n    .. image:: https://i.imgur.com/dHAzZRw.png\n\n    For your Fab technology you can overwrite\n\n    - simulation_settings\n    - dirpath\n    - layerStack\n\n    converts kfactory units (um) to Lumerical units (m)\n\n    Disclaimer: This function tries to extract Sparameters automatically\n    is hard to make a function that will fit all your possible simulation settings.\n    You can use this function for inspiration to create your own.\n\n\n    TODO:\n        mode_selection\n\n    Args:\n        cell: cell to simulate.\n        session: you can pass a session=lumapi.FDTD() or it will create one.\n        run: True runs Lumerical, False only draws simulation.\n        overwrite: run even if simulation results already exists.\n        dirpath: directory to store sparameters in npz.\n            Defaults to active Pdk.sparameters_path.\n        layer_stack: contains layer to thickness, zmin and material.\n            Defaults to active pdk.layer_stack.\n        simulation_settings: dataclass with all simulation_settings.\n        material_name_to_lumerical: alias to lumerical material's database name\n            or refractive index.\n            translate material name in LayerStack to lumerical's database name.\n        delete_fsp_files: deletes lumerical fsp files after simulation.\n\n    Keyword Args:\n        background_material: for the background.\n        port_margin: on both sides of the port width (um).\n        port_height: port height (um).\n        port_extension: port extension (um).\n        mesh_accuracy: 2 (1: coarse, 2: fine, 3: superfine).\n        zmargin: for the FDTD region (um).\n        ymargin: for the FDTD region (um).\n        xmargin: for the FDTD region (um).\n        wavelength_start: 1.2 (um).\n        wavelength_stop: 1.6 (um).\n        wavelength_points: 500.\n        simulation_time: (s) related to max path length 3e8/2.4*10e-12*1e6 = 1.25mm.\n        simulation_temperature: in kelvin (default = 300).\n        frequency_dependent_profile: computes mode profiles for different wavelengths.\n        field_profile_samples: number of wavelengths to compute field profile.\n\n\n\n    .. code::\n\n         top view\n              ________________________________\n             |                               |\n             | xmargin                       | port_extension\n             |<------>          port_margin ||<-->\n          o2_|___________          _________||_o3\n             |           \\        /          |\n             |            \\      /           |\n             |             ======            |\n             |            /      \\           |\n          o1_|___________/        \\__________|_o4\n             |   |                           |\n             |   |ymargin                    |\n             |   |                           |\n             |___|___________________________|\n\n        side view\n              ________________________________\n             |                               |\n             |                               |\n             |                               |\n             |ymargin                        |\n             |<---> _____         _____      |\n             |     |     |       |     |     |\n             |     |     |       |     |     |\n             |     |_____|       |_____|     |\n             |       |                       |\n             |       |                       |\n             |       |zmargin                |\n             |       |                       |\n             |_______|_______________________|\n\n\n\n    Return:\n        Sparameters np.ndarray (wavelengths, o1@0,o1@0, o1@0,o2@0 ...)\n            suffix `a` for angle in radians and `m` for module.\n\n    \"\"\"\n    s_params = []\n    insts = []\n    trans = []\n    # cell = kf.get_cell(cell)\n\n    def recurse_insts(comp: Any, p=None):  # type: ignore\n        if p:\n            comp.transform(p)\n        for inst in comp.insts:\n            if inst.trans in trans:\n                continue\n            if inst.cell.name == cell.name:  # type: ignore\n                continue\n            if len(inst.cell.insts) > 0:\n                if \"sim\" in inst.cell.info:\n                    trans.append(inst.trans)\n                    insts.append(inst)\n                    continue\n                recurse_insts(inst.cell.dup(), inst.instance.trans)\n            else:\n                insts.append(inst)\n                trans.append(inst.trans)\n\n    if \"sim\" not in cell.info:\n        recurse_insts(cell)\n    paths: dict[str, Path] = {}\n    for inst in insts:\n        cell_ = inst.cell\n        # paths = {}\n        if not overwrite:\n            if \"cells\" in cell_.info:\n                paths = {}\n                for cell2 in cell_.info[\"cells\"]:\n                    settings_ = cell_.info[\"cells\"][cell2]\n                    cell_2 = kf.get_cell(settings_[\"cell\"], **settings_[\"params\"])\n                    path = get_sparameters_path(\n                        cell_2,\n                        dirpath=dirpath,\n                        layer_stack=layer_stack or LAYER_STACK,\n                        **settings,\n                    )\n                    if overwrite or not path.exists():\n                        try:\n                            cell_solver = cell_.info[\"cells\"][cell2][\"sim\"]\n                        except KeyError:\n                            cell_solver = solver\n                        s_params.append(\n                            write_sparameters_lumerical(\n                                cell=cell_2,\n                                layer_stack=layer_stack,\n                                session=session,\n                                run=run,\n                                overwrite=overwrite,\n                                dirpath=dirpath,\n                                simulation_settings=simulation_settings,\n                                material_name_to_lumerical=material_name_to_lumerical,\n                                delete_fsp_files=delete_fsp_files,\n                                solver=cell_solver,\n                                **settings,\n                            )\n                        )\n                    paths[cell_2.name] = path\n\n            else:\n                path = get_sparameters_path(\n                    cell_,\n                    dirpath=dirpath,\n                    layer_stack=layer_stack or LAYER_STACK,\n                    **settings,\n                )\n                if path.exists():\n                    # s_params.append(np.ndarray(np.load(path)))\n                    paths[cell_.name] = path\n                else:\n                    s_params.append(\n                        write_sparameters_lumerical(\n                            cell=cell_,\n                            layer_stack=layer_stack,\n                            session=session,\n                            run=run,\n                            overwrite=overwrite,\n                            dirpath=dirpath,\n                            simulation_settings=simulation_settings,\n                            material_name_to_lumerical=material_name_to_lumerical,\n                            delete_fsp_files=delete_fsp_files,\n                            solver=solver,\n                            **settings,\n                        )\n                    )\n                paths[cell_.name] = path\n        else:\n            s_params.append(\n                write_sparameters_lumerical(\n                    cell=cell_,\n                    layer_stack=layer_stack,\n                    session=session,\n                    run=run,\n                    overwrite=overwrite,\n                    dirpath=dirpath,\n                    simulation_settings=simulation_settings,\n                    material_name_to_lumerical=material_name_to_lumerical,\n                    delete_fsp_files=delete_fsp_files,\n                    solver=solver,\n                    **settings,\n                )\n            )\n            paths[cell_.name] = get_sparameters_path(\n                cell_,\n                dirpath=dirpath,\n                layer_stack=layer_stack or LAYER_STACK,\n                **settings,\n            )\n    sim_settings = dict(simulation_settings)\n\n    layer_stack = layer_stack or LAYER_STACK\n\n    layer_to_thickness = layer_stack.get_layer_to_thickness()\n    layer_to_zmin = layer_stack.get_layer_to_zmin()\n    layer_to_material = layer_stack.get_layer_to_material()\n\n    if hasattr(cell.info, \"simulation_settings\"):\n        sim_settings.update(cell.info.simulation_settings)\n        logger.info(f\"Updating {cell.name!r} sim settings {cell.simulation_settings}\")\n    for setting in settings:\n        if setting not in sim_settings:\n            raise ValueError(\n                f\"Invalid setting {setting!r} not in ({list(sim_settings.keys())})\"\n            )\n\n    sim_settings.update(**settings)\n    ss = SimulationSettingsLumericalFdtd(**sim_settings)\n\n    cell_extended = kf.KCell()\n    for port in cell.ports:\n        cell_ref = cell_extended << cell\n        width = port.width * cell.kcl.dbu if isinstance(port.width, int) else 1\n        extension = cell_extended.create_inst(\n            kf.cells.waveguide.waveguide(width, ss.port_extension, layer=port.layer)\n        )\n        extension.align(\"o2\", cell_ref, port.name)\n        output_port = extension.ports[\"o1\"]\n        cell_extended.add_port(extension.ports[\"o1\"], name=port.name)\n\n    # ports = cell_extended.get_ports_list(port_type=\"optical\")\n    # if not ports:\n    #     raise ValueError(f\"{cell.name!r} does not have any optical ports\")\n\n    # cell.remove_layers(cell.layers - set(layer_to_thickness.keys()))\n    # cell._bb_valid = False\n    cell_extended.flatten()\n    cell_extended.name = \"top\"\n    # cell.flatten()\n    cell_extended.draw_ports()\n    solver = cell.info[\"sim\"] if \"sim\" in cell.info else solver\n    filepath_npz = get_sparameters_path(\n        cell=cell,\n        dirpath=dirpath,\n        layer_stack=layer_stack,\n        **settings,\n    )\n    cell_extended.write(filepath_npz.with_suffix(\".gds\"))\n    gdspath = filepath_npz.with_suffix(\".gds\")\n    filepath = filepath_npz.with_suffix(\".dat\")\n    filepath_sim_settings = filepath.with_suffix(\".yml\")\n    filepath_fsp = filepath.with_suffix(\".fsp\")\n    fspdir = filepath.parent / f\"{filepath.stem}_s-parametersweep\"\n\n    if run and filepath_npz.exists() and not overwrite:\n        logger.info(f\"Reading Sparameters from {filepath_npz}\")\n        return np.ndarray(np.load(filepath_npz))\n\n    if not run and session is None:\n        print(run_false_warning)\n\n    logger.info(f\"Writing Sparameters to {filepath_npz}\")\n    xmin = cell.dbbox().left\n    xmax = cell.dbbox().right\n    ymin = cell.dbbox().bottom\n    ymax = cell.dbbox().top\n    x_min = (xmin - ss.xmargin) * 1e-6\n    x_max = (xmax + ss.xmargin) * 1e-6\n    y_min = (ymin - ss.ymargin) * 1e-6\n    y_max = (ymax + ss.ymargin) * 1e-6\n\n    # layers_thickness = [\n    #     layer_to_thickness[layer]\n    #     for layer in cell.get_layers()\n    #     if layer in layer_to_thickness\n    # ]\n    # if not layers_thickness:\n    #     raise ValueError(\n    #         f\"no layers for cell {cell.get_layers()}\"\n    #         f\"in layer stack {layer_stack}\"\n    #     )\n    # layers_zmin = [\n    #     layer_to_zmin[layer]\n    #     for layer in cell.get_layers()\n    #     if layer in layer_to_zmin\n    # ]\n    # cell_thickness = max(layers_thickness)\n    # cell_zmin = min(layers_zmin)\n\n    # z = (cell_zmin + cell_thickness) / 2 * 1e-6\n    z = 0.0\n    z_span = 1e-6\n\n    x_span = x_max - x_min\n    y_span = y_max - y_min\n\n    # layers = cell.get_layers()\n    sim_settings.update(dict(layer_stack=layer_stack.to_dict()))\n\n    # sim_settings = dict(\n    #     simulation_settings=sim_settings,\n    #     cell=cell.to_dict(),\n    #     # version=__version__,\n    # )\n\n    logger.info(\n        f\"Simulation size = {x_span*1e6:.3f}, {y_span*1e6:.3f}, {z_span*1e6:.3f} um\"\n    )\n\n    # from pprint import pprint\n    # filepath_sim_settings.write_text(omegaconf.OmegaConf.to_yaml(sim_settings))\n    # print(filepath_sim_settings)\n    # pprint(sim_settings)\n    # return\n\n    try:\n        import sys\n\n        sys.path.append(\"C:\\\\Program Files\\\\Lumerical\\\\v231\\\\api\\\\python\\\\\")\n        import lumapi\n    except ModuleNotFoundError as e:\n        print(\n            \"Cannot import lumapi (Python Lumerical API). \"\n            \"You can add set the PYTHONPATH variable or add it with `sys.path.append()`\"\n        )\n        raise e\n    except OSError as e:\n        raise e\n\n    start = time.time()\n    s = (\n        session or lumapi.FDTD(hide=False)\n        if solver == \"FDTD\"\n        else lumapi.MODE(hide=False)\n    )\n    s.newproject()\n    s.selectall()\n    s.deleteall()\n    s.addrect(\n        x_min=x_min,\n        x_max=x_max,\n        y_min=y_min,\n        y_max=y_max,\n        z=z,\n        z_span=z_span,\n        index=1.5,\n        name=\"clad\",\n    )\n\n    material_name_to_lumerical_new = material_name_to_lumerical or {}\n    material_name_to_lumerical = ss.material_name_to_lumerical.copy()\n    material_name_to_lumerical.update(**material_name_to_lumerical_new)\n\n    material = (\n        material_name_to_lumerical[ss.background_material] if solver == \"FDTD\" else None\n    )\n    set_material(\n        session=s, structure=\"clad\", material=material\n    ) if solver == \"FDTD\" and material is not None else None\n\n    s.addfdtd(\n        dimension=\"3D\",\n        x_min=x_min,\n        x_max=x_max,\n        y_min=y_min,\n        y_max=y_max,\n        z=z,\n        z_span=z_span,\n        mesh_accuracy=ss.mesh_accuracy,\n        use_early_shutoff=True,\n        simulation_time=ss.simulation_time,\n        simulation_temperature=ss.simulation_temperature,\n    ) if solver == \"FDTD\" else s.addeme(\n        solver_type=\"2D XY plane: X prop\",\n        x_min=x_min,\n        group_spans=x_span,\n        y_min=y_min,\n        y_max=y_max,\n        z=z,\n        # z_span=z_span,\n        # mesh_accuracy=ss.mesh_accuracy,\n        # use_early_shutoff=True,\n        simulation_temperature=ss.simulation_temperature,\n    )\n\n    for layer, level in layer_stack.layers.items():\n        material_name = layer_to_material[level.layer]\n        if material_name not in material_name_to_lumerical:\n            continue\n        material = material_name_to_lumerical[material_name]\n\n        zmin = layer_to_zmin[level.layer]\n        thickness = layer_to_thickness[level.layer]\n        zmax = zmin + thickness\n        z = (zmax + zmin) / 2\n\n        path = gdspath\n        try:\n            s.gdsimport(str(path), \"top\", f\"{level.layer[0]}:{level.layer[1]}\")\n        except Exception as e:\n            continue\n        layername = f\"GDS_LAYER_{level.layer[0]}:{level.layer[1]}\"\n        s.setnamed(layername, \"z\", z * 1e-6)\n        s.setnamed(layername, \"z span\", thickness * 1e-6)\n        set_material(session=s, structure=layername, material=material)\n        logger.info(f\"adding {layer}, thickness = {thickness} um, zmin = {zmin} um \")\n\n    s.deletesweep(\"s-parameter sweep\")\n\n    if solver == \"MODE\":\n        for i in range(2):\n            s.select(\"EME::Ports::port_1\")\n            s.delete()\n\n    for i, port in enumerate(cell.ports):\n        from kgeneric import pdk\n\n        zmin = layer_to_zmin[(1, 0)]  # type: ignore\n        thickness = layer_to_thickness[(1, 0)]  # type: ignore\n        z = (zmin + thickness) / 2\n        zspan = 2 * ss.port_margin + thickness\n\n        if solver == \"FDTD\":\n            s.addport()\n        elif solver == \"MODE\" and i != 0:\n            s.addemeport()\n        s.setnamed(\n            f\"FDTD::ports\", \"monitor frequency points\", ss.wavelength_points\n        ) if solver == \"FDTD\" else None\n        p = (\n            f\"FDTD::ports::port {i+1}\"\n            if solver == \"FDTD\"\n            else f\"EME::Ports::port_{i+1}\"\n        )\n        s.setnamed(p, \"x\", port.x * 1e-6 / 1000)\n        s.setnamed(p, \"y\", port.y * 1e-6 / 1000)\n        s.setnamed(p, \"z\", z * 1e-6 / 1000)\n        s.setnamed(p, \"z span\", zspan * 1e-6)\n        if solver != \"MODE\":\n            s.setnamed(p, \"frequency dependent profile\", ss.frequency_dependent_profile)\n            s.setnamed(p, \"number of field profile samples\", ss.field_profile_samples)\n\n        deg = int(port.orientation)\n        # if port.orientation not in [0, 90, 180, 270]:\n        #     raise ValueError(f\"{port.orientation} needs to be [0, 90, 180, 270]\")\n\n        if -45 <= deg <= 45:\n            direction = \"Backward\"\n            injection_axis = \"x-axis\"\n            dxp = 0.0\n            dyp = 2 * ss.port_margin + port.width / 1000\n        elif 45 < deg < 90 + 45:\n            direction = \"Backward\"\n            injection_axis = \"y-axis\"\n            dxp = 2 * ss.port_margin + port.width / 1000\n            dyp = 0.0\n        elif 90 + 45 < deg < 180 + 45:\n            direction = \"Forward\"\n            injection_axis = \"x-axis\"\n            dxp = 0.0\n            dyp = 2 * ss.port_margin + port.width / 1000\n        elif 180 + 45 < deg < 180 + 45 + 90:\n            direction = \"Forward\"\n            injection_axis = \"y-axis\"\n            dxp = 2 * ss.port_margin + port.width / 1000\n            dyp = 0.0\n\n        else:\n            raise ValueError(\n                f\"port {port.name!r} orientation {port.orientation} is not valid\"\n            )\n\n        port_location = (\n            \"left\" if direction == \"Forward\" and injection_axis == \"x-axis\" else \"right\"\n        )\n        s.setnamed(p, \"direction\", direction) if solver == \"FDTD\" else s.setnamed(\n            p, \"port location\", port_location\n        )\n        s.setnamed(p, \"injection axis\", injection_axis) if solver == \"FDTD\" else None\n        s.setnamed(p, \"y span\", dyp * 1e-6)\n        s.setnamed(p, \"x span\", dxp * 1e-6) if solver == \"FDTD\" else s.setnamed(\n            p, \"z span\", zspan\n        )\n        # s.setnamed(p, \"theta\", deg)\n        s.setnamed(p, \"name\", port.name) if solver == \"FDTD\" else None\n        # s.setnamed(p, \"name\", f\"o{i+1}\")\n\n        logger.info(\n            f\"port {p} {port.name!r}: at ({port.x}, {port.y}, 0)\"\n            f\"size = ({dxp}, {dyp}, {zspan})\"\n        )\n\n    s.setglobalsource(\"wavelength start\", ss.wavelength_start * 1e-6)\n    s.setglobalsource(\"wavelength stop\", ss.wavelength_stop * 1e-6)\n    # s.setglobalsource(\"wavelength points\", ss.wavelength_points)\n\n    if run and solver == \"FDTD\":\n        s.addsweep(3)\n        s.setsweep(\"s-parameter sweep\", \"Excite all ports\", 0)\n        s.setsweep(\"s-parameter sweep\", \"auto symmetry\", True)\n        s.setglobalmonitor(\"frequency points\", ss.wavelength_points)\n        s.save(str(filepath_fsp))\n        s.runsweep(\"s-parameter sweep\")\n        sp = (\n            s.getsweepresult(\"s-parameter sweep\", \"S parameters\")\n            if solver == \"FDTD\"\n            else s.getsweepresult(\"s-parameter sweep\", \"user s matrix\")\n        )\n        s.exportsweep(\"s-parameter sweep\", str(filepath))\n        logger.info(f\"wrote sparameters to {filepath}\")\n\n        # sp[\"wavelengths\"] = sp.pop(\"lambda\").flatten() * 1e6\n        np.savez_compressed(filepath_npz, **sp)\n\n        with open(filepath, \"r+\") as fd:\n            data = fd.read()\n            diction = {180: \"LEFT\", 0: \"RIGHT\", 90: \"TOP\", 270: \"BOTTOM\"}\n            for p_ in cell.ports:\n                data = data.replace(\n                    f\"{p_.name}, LEFT\", f\"{p_.name}, {diction[int(p_.orientation)]}\"\n                )\n            fd.seek(0)\n            fd.write(data)\n        fd.close()\n        # keys = [key for key in sp.keys() if key.startswith(\"S\")]\n        # ra = {\n        #     f\"{key.lower()}a\": list(np.unwrap(np.angle(sp[key].flatten())))\n        #     for key in keys\n        # }\n        # rm = {f\"{key.lower()}m\": list(np.abs(sp[key].flatten())) for key in keys}\n        # results = {\"wavelengths\": wavelengths}\n        # results.update(ra)\n        # results.update(rm)\n        # df = pd.DataFrame(results, index=wavelengths)\n        # df.to_csv(filepath_npz, index=False)\n\n        end = time.time()\n        sim_settings.update(compute_time_seconds=end - start)\n        sim_settings.update(compute_time_minutes=(end - start) / 60)\n        filepath_sim_settings.write_text(omegaconf.OmegaConf.to_yaml(sim_settings))\n        if delete_fsp_files and fspdir.exists():\n            shutil.rmtree(fspdir)\n            logger.info(\n                f\"deleting simulation files in {fspdir}. \"\n                \"To keep them, use delete_fsp_files=False flag\"\n            )\n\n        return sp\n    elif run and solver == \"MODE\":\n        start = time.time()\n        s.run()\n        s.setemeanalysis(\"wavelength sweep\", 1)\n        s.setemeanalysis(\"start wavelength\", ss.wavelength_start * 1e-6)\n        s.setemeanalysis(\"stop wavelength\", ss.wavelength_stop * 1e-6)\n        s.setemeanalysis(\"number of wavelength points\", ss.wavelength_points)\n        s.emesweep(\"wavelength sweep\")\n\n        sp = s.getemesweep(\"S_wavelength_sweep\")\n\n        s.exportemesweep(str(filepath))\n\n        with open(filepath, \"r+\") as f:\n            text = f.read()\n            for i, val in enumerate(cell.ports):\n                text = text.replace(f\"port {i+1}\", val.name)\n            f.write(text)\n        f.close()\n\n        sp = np.ndarray(sp)\n        np.savez_compressed(filepath_npz, **sp)\n\n        end = time.time()\n\n        sim_settings.update(compute_time_seconds=end - start)\n        sim_settings.update(compute_time_minutes=(end - start) / 60)\n        filepath_sim_settings.write_text(omegaconf.OmegaConf.to_yaml(sim_settings))\n        if delete_fsp_files and fspdir.exists():\n            shutil.rmtree(fspdir)\n            logger.info(\n                f\"deleting simulation files in {fspdir}. \"\n                \"To keep them, use delete_fsp_files=False flag\"\n            )\n\n        return sp\n\n    filepath_sim_settings.write_text(omegaconf.OmegaConf.to_yaml(sim_settings))\n    return s", "\n\nif __name__ == \"__main__\":\n    import kgeneric\n    from kgeneric.pdk import LAYER\n    import lumapi\n\n    s = lumapi.FDTD()\n\n    cell = kgeneric.cells.waveguide(width=0.5, length=2, layer=LAYER.WG)\n\n    material_name_to_lumerical = dict(si=(3.45, 2))  # or dict(si=3.45+2j)\n    r = write_sparameters_lumerical(\n        cell=cell,\n        material_name_to_lumerical=material_name_to_lumerical,  # type: ignore\n        run=False,\n        session=s,\n    )", ""]}
{"filename": "kplugins/lumerical/simulation_settings.py", "chunked_list": ["from typing import Dict\n\nfrom pydantic import BaseModel\n\nimport numpy as np\nfrom kplugins.typings import MaterialSpec\n\n\nmaterial_name_to_lumerical_default: Dict[str, MaterialSpec] = {\n    \"si\": \"Si (Silicon) - Palik\",", "material_name_to_lumerical_default: Dict[str, MaterialSpec] = {\n    \"si\": \"Si (Silicon) - Palik\",\n    \"sio2\": \"SiO2 (Glass) - Palik\",\n    \"sin\": \"Si3N4 (Silicon Nitride) - Phillip\",\n}\n\n\nclass SimulationSettingsLumericalFdtd(BaseModel):\n    \"\"\"Lumerical FDTD simulation_settings.\n\n    Parameters:\n        background_material: for the background.\n        port_margin: on both sides of the port width (um).\n        port_height: port height (um).\n        port_extension: port extension (um).\n        mesh_accuracy: 2 (1: coarse, 2: fine, 3: superfine).\n        zmargin: for the FDTD region (um).\n        ymargin: for the FDTD region (um).\n        xmargin: for the FDTD region (um).\n        wavelength_start: 1.2 (um).\n        wavelength_stop: 1.6 (um).\n        wavelength_points: 500.\n        simulation_time: (s) related to max path length\n            3e8/2.4*10e-12*1e6 = 1.25mm.\n        simulation_temperature: in kelvin (default = 300).\n        frequency_dependent_profile: compute mode profiles for each wavelength.\n        field_profile_samples: number of wavelengths to compute field profile.\n    \"\"\"\n\n    background_material: str = \"sio2\"\n    port_margin: float = 1.5\n    port_extension: float = 5.0\n    mesh_accuracy: int = 2\n    zmargin: float = 1.0\n    ymargin: float = 3.0\n    xmargin: float = 3.0\n    wavelength_start: float = 1.2\n    wavelength_stop: float = 1.6\n    wavelength_points: int = 500\n    simulation_time: float = 10e-12\n    simulation_temperature: float = 300\n    frequency_dependent_profile: bool = True\n    field_profile_samples: int = 15\n    distance_source_to_monitors: float = 0.2\n    material_name_to_lumerical: Dict[\n        str, MaterialSpec\n    ] = material_name_to_lumerical_default\n\n    class Config:\n        \"\"\"pydantic basemodel config.\"\"\"\n\n        arbitrary_types_allowed = True", "\n\nSIMULATION_SETTINGS_LUMERICAL_FDTD = SimulationSettingsLumericalFdtd()\n\nif __name__ == \"__main__\":\n    d = SIMULATION_SETTINGS_LUMERICAL_FDTD\n"]}
