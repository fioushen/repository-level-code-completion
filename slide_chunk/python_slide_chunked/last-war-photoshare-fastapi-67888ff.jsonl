{"filename": "main.py", "chunked_list": ["import uvicorn\nfrom fastapi import FastAPI, Depends, HTTPException\nfrom fastapi.responses import HTMLResponse\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy import text\n\nfrom src.database.db import get_db\nfrom src.routes import users, auth, comments, tags, images, ratings\n\napp = FastAPI()", "\napp = FastAPI()\n\n\n@app.get(\"/\", description='Main page')\ndef root():\n    \"\"\"\n    Main page definition\n\n    :return: dict: health status\n\n    \"\"\"\n    return {\"message\": \"Welcome to the FAST API from team 6\"}", "\n\n@app.get(\"/api/healthchecker\")\ndef healthchecker(db: Session = Depends(get_db)):\n    \"\"\"\n    Health Checker\n\n    :param db: database session\n    :return: dict: health status\n    \"\"\"\n    try:\n        result = db.execute(text(\"SELECT 1\")).fetchone()\n        if result is None:\n            raise HTTPException(status_code=500, detail=\"Database is not configured correctly\")\n        return {\"message\": \"Welcome to FastAPI!\"}\n    except Exception:\n        raise HTTPException(status_code=500, detail=\"Error connecting to the database\")", "\n\napp.include_router(users.router, prefix='/api')\napp.include_router(auth.router, prefix='/api')\napp.include_router(comments.router, prefix='/api')\napp.include_router(images.router, prefix='/api')\napp.include_router(tags.router, prefix='/api')\napp.include_router(ratings.router, prefix='/api')\n", ""]}
{"filename": "tests/test_unit_repository_ratings.py", "chunked_list": ["import unittest\nfrom unittest.mock import MagicMock\n\n\nfrom sqlalchemy.orm import Session\n\nfrom src.database.models import Rating, User, Image\nfrom src.repository.ratings import (\n    create_rate,\n    delete_rate,", "    create_rate,\n    delete_rate,\n    calculate_rating,\n    show_images_by_rating\n)\n\n\nclass TestRatings(unittest.IsolatedAsyncioTestCase):\n\n    def setUp(self):\n        self.session = MagicMock(spec=Session)\n        self.test_user = User(\n            id=1,\n            login='SuperUser',\n            email='user@super.com',\n            password_checksum='superpwd',\n            is_active=True,\n        )\n\n    def tearDown(self):\n        self.session = None\n        self.test_user = None\n\n    # test create_rate function from src/repository/ratings.py with different inputs\n    async def test_create_rate_own_image(self):\n        # test if it is not possible to rate own image\n        self.session.query().filter().order_by().first.return_value = Image(\n            id=1,\n            image_url='test_image',\n            description='test_path',\n            user_id=1,\n        )\n        with self.assertRaises(Exception):\n            await create_rate(image_id=1, rate=5, db=self.session, user=self.test_user)\n\n    async def test_create_rate_twice(self):\n        # test if it is not possible to rate twice\n        self.session.query().filter().order_by().first.return_value = Rating(\n            id=1,\n            image_id=1,\n            rate=5,\n            user_id=1,\n        )\n        with self.assertRaises(Exception):\n            await create_rate(image_id=1, rate=5, db=self.session, user=self.test_user)\n\n    async def test_create_rate_image_not_exists(self):\n        # test if it is not possible to rate an image that does not exist\n        self.session.query().filter().order_by().first.return_value = None\n        with self.assertRaises(Exception):\n            await create_rate(image_id=1, rate=5, db=self.session, user=self.test_user)\n\n    async def test_create_rate(self):\n        # test if it is possible to rate an image\n        self.session.query().filter().order_by().first.return_value = None\n        self.session.query().filter().order_by().first.return_value = Image(\n            id=2,\n            image_url='test_image',\n            description='test_path',\n            user_id=2,\n        )\n        result = await create_rate(image_id=2, rate=5, db=self.session, user=self.test_user)\n        self.assertIsInstance(result, Rating)\n\n    async def test_delete_rate(self):\n        # test if it is possible to delete a rate\n        self.session.query().filter().order_by().first.return_value = Rating(\n            id=1,\n            image_id=1,\n            rate=5,\n            user_id=1,\n        )\n        result = await delete_rate(rate_id=1, db=self.session, user=self.test_user)\n        self.assertIsNone(result)\n\n    async def test_calculate_rating(self):\n        # test if it is possible to calculate rate\n        self.session.query().filter().order_by().first.return_value = Rating(\n            id=1,\n            image_id=1,\n            rate=5,\n            user_id=1,\n        )\n        result = await calculate_rating(image_id=1, db=self.session, user=self.test_user)\n        self.assertEqual(result, 5)\n\n    async def test_show_images_by_rating(self):\n        # test if it is possible to show images by rating\n        self.session.query().filter().order_by().first.return_value = Rating(\n            id=1,\n            image_id=1,\n            rate=5,\n            user_id=1,\n        )\n        result = await show_images_by_rating(True, db=self.session, user=self.test_user)\n        self.assertIsInstance(result, list)", "\n\nif __name__ == '__main__':\n    unittest.main()"]}
{"filename": "tests/test_unit_route_images.py", "chunked_list": ["from unittest.mock import MagicMock\nimport io\n\nimport qrcode\nfrom PIL import Image as PILImage\nfrom pytest import fixture\n\nfrom src.database.models import User, UserRole, Image\nfrom fastapi import status, UploadFile\nimport datetime", "from fastapi import status, UploadFile\nimport datetime\n\n\n@fixture(scope='module')\ndef token(client, user, session):\n    response = client.post(\"/api/auth/signup\", json={\"login\": \"deadpool\", \"email\": \"deadpool@example.com\",\n                                                     \"password_checksum\": \"123456789\"})\n    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n    current_user.role = UserRole.Admin\n    session.commit()\n    response = client.post(\"/api/auth/login\", data={\n                            \"username\": \"deadpool@example.com\",\n                            \"password\": \"123456789\"}, headers={'Content-Type': 'application/x-www-form-urlencoded'})\n    data = response.json()\n    return data[\"access_token\"]", "\n\n@fixture(scope='module')\ndef token_moder(client, user_moder, session):\n    response = client.post(\"/api/auth/signup\", json={\"login\": \"dead2pool\", \"email\": \"dead2pool@example.com\",\n                                                     \"password_checksum\": \"123456789\"})\n    current_user: User = session.query(User).filter(User.email == user_moder.get('email')).first()\n    current_user.role = UserRole.Moderator\n    session.commit()\n    response = client.post(\"/api/auth/login\", data={\n                            \"username\": \"dead2pool@example.com\",\n                            \"password\": \"123456789\"}, headers={'Content-Type': 'application/x-www-form-urlencoded'})\n    data = response.json()\n    return data[\"access_token\"]", "\n\n@fixture(scope='module')\ndef token_user(client, user_user, session):\n    response = client.post(\"/api/auth/signup\", json={\"login\": \"dead1pool\", \"email\": \"dead1pool@example.com\",\n                                                     \"password_checksum\": \"123456789\"})\n    response = client.post(\"/api/auth/login\", data={\n                            \"username\": \"dead1pool@example.com\",\n                            \"password\": \"123456789\"}, headers={'Content-Type': 'application/x-www-form-urlencoded'})\n    data = response.json()\n    return data[\"access_token\"]", "\n\n@fixture(scope='module')\ndef image(client, user, session):\n    response = client.post(\"/api/auth/signup\", json={\"login\": \"deadpool\", \"email\": \"deadpool@example.com\",\n                                                     \"password_checksum\": \"123456789\"})\n    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n    image = session.query(Image).filter(Image.id == 1).first()\n    if image is None:\n        image = Image(\n                    id=1,\n                    image_url=\"https://res.cloudinary.com/dy9mhswnt/image/upload/c_fill,g_faces,h_500,r_max,w_500\"\n                                \"/v1/photoshare/473db2aa2c097073b2e971767d76f543960ce141f4acf4671e82369de8526e9e\",\n                    user_id=current_user.id,\n                    created_at=datetime.datetime.now(),\n                    description=\"est_image_test_image_test_image_test_image\"\n        )\n        session.add(image)\n        session.commit()\n        session.refresh(image)\n    return image", "\n\n@fixture(scope='module')\ndef image_moder(client, user_moder, session):\n    response = client.post(\"/api/auth/signup\", json={\"login\": \"dead2pool\", \"email\": \"dead2pool@example.com\",\n                                                     \"password_checksum\": \"123456789\"})\n    current_user: User = session.query(User).filter(User.email == user_moder.get('email')).first()\n    image = session.query(Image).filter(Image.id == 2).first()\n    if image is None:\n        image = Image(\n                    id=2,\n                    image_url=\"https://res.cloudinary.com/dy9mhswnt/image/upload/c_fill,g_faces,h_500,r_max,w_500\"\n                                \"/v1/photoshare/223db2aa2c097073b2e971767d76f543960ce141f4acf4671e82369de8526e9e\",\n                    user_id=current_user.id,\n                    created_at=datetime.datetime.now(),\n                    description=\"est_image_test_image_test_image_test_image\"\n        )\n        session.add(image)\n        session.commit()\n        session.refresh(image)\n    return image", "\n\n@fixture(scope='module')\ndef image_user(client, user_user, session):\n    response = client.post(\"/api/auth/signup\", json={\"login\": \"dead1pool\", \"email\": \"dead1pool@example.com\",\n                                                     \"password_checksum\": \"123456789\"})\n    current_user: User = session.query(User).filter(User.email == user_user.get('email')).first()\n    image = session.query(Image).filter(Image.id == 3).first()\n    if image is None:\n        image = Image(\n                    id=3,\n                    image_url=\"https://res.cloudinary.com/dy9mhswnt/image/upload/c_fill,g_faces,h_500,r_max,w_500\"\n                                \"/v1/photoshare/333db2aa2c097073b2e971767d76f543960ce141f4acf4671e82369de8526e9e\",\n                    user_id=current_user.id,\n                    created_at=datetime.datetime.now(),\n                    description=\"est_image_test_image_test_image_test_image\"\n        )\n        session.add(image)\n        session.commit()\n        session.refresh(image)\n    return image", "\n\ndef test_create_transformation_image_by_admin(client, token, image):\n    response = client.post(\"/api/images/transformation\", json={\"id\": 1, \"transformation\": \"standard\"},\n                           headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == status.HTTP_201_CREATED\n    response = client.post(\"/api/images/transformation\", json={\"id\": 1, \"transformation\": \"standard\"},\n                           headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == status.HTTP_409_CONFLICT\n    response = client.post(\"/api/images/transformation\", json={\"id\": 100, \"transformation\": \"standard\"},\n                           headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == status.HTTP_404_NOT_FOUND\n    response = client.post(\"/api/images/transformation\", json={\"id\": 100, \"transformation\": \"test\"},\n                           headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == status.HTTP_404_NOT_FOUND", "\n\ndef test_create_transformation_image_by_moder(client, token_moder, image_moder):\n    response = client.post(\"/api/images/transformation\", json={\"id\": 2, \"transformation\": \"standard\"},\n                           headers={\"Authorization\": f\"Bearer {token_moder}\"})\n    assert response.status_code == status.HTTP_201_CREATED\n\n\ndef test_create_transformation_image_by_user(client, token_user, image_user):\n    response = client.post(\"/api/images/transformation\", json={\"id\": 3, \"transformation\": \"standard\"},\n                           headers={\"Authorization\": f\"Bearer {token_user}\"})\n    assert response.status_code == status.HTTP_201_CREATED\n    response = client.post(\"/api/images/transformation\", json={\"id\": 100, \"transformation\": \"standard\"},\n                           headers={\"Authorization\": f\"Bearer {token_user}\"})\n    assert response.status_code == status.HTTP_404_NOT_FOUND", "def test_create_transformation_image_by_user(client, token_user, image_user):\n    response = client.post(\"/api/images/transformation\", json={\"id\": 3, \"transformation\": \"standard\"},\n                           headers={\"Authorization\": f\"Bearer {token_user}\"})\n    assert response.status_code == status.HTTP_201_CREATED\n    response = client.post(\"/api/images/transformation\", json={\"id\": 100, \"transformation\": \"standard\"},\n                           headers={\"Authorization\": f\"Bearer {token_user}\"})\n    assert response.status_code == status.HTTP_404_NOT_FOUND\n\n\ndef test_get_images_by_admin(client, token):\n    response = client.get(\"/api/images/\", headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == status.HTTP_200_OK\n    response = client.get(\"/api/images/\", headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == status.HTTP_404_NOT_FOUND", "\ndef test_get_images_by_admin(client, token):\n    response = client.get(\"/api/images/\", headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == status.HTTP_200_OK\n    response = client.get(\"/api/images/\", headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == status.HTTP_404_NOT_FOUND\n\n\ndef test_get_images_by_moder(client, token_moder):\n    response = client.get(\"/api/images/\", headers={\"Authorization\": f\"Bearer {token_moder}\"})\n    assert response.status_code == status.HTTP_200_OK", "def test_get_images_by_moder(client, token_moder):\n    response = client.get(\"/api/images/\", headers={\"Authorization\": f\"Bearer {token_moder}\"})\n    assert response.status_code == status.HTTP_200_OK\n\n\ndef test_get_images_by_user(client, token_user):\n    response = client.get(\"/api/images/\", headers={\"Authorization\": f\"Bearer {token_user}\"})\n    assert response.status_code == status.HTTP_200_OK\n\n\ndef test_get_image_by_admin(client, token, image):\n    response = client.get(\"/api/images/1\", headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == status.HTTP_200_OK\n    response = client.get(\"/api/images/100\", headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == status.HTTP_404_NOT_FOUND\n    response = client.get(\"/api/images/{image_id}\", headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY", "\n\ndef test_get_image_by_admin(client, token, image):\n    response = client.get(\"/api/images/1\", headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == status.HTTP_200_OK\n    response = client.get(\"/api/images/100\", headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == status.HTTP_404_NOT_FOUND\n    response = client.get(\"/api/images/{image_id}\", headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n", "\n\ndef test_get_image_moder(client, token_moder, image_moder):\n    response = client.get(\"/api/images/2\", headers={\"Authorization\": f\"Bearer {token_moder}\"})\n    assert response.status_code == status.HTTP_200_OK\n\n\ndef test_get_image_by_user(client, token_user, image_user):\n    response = client.get(\"/api/images/3\", headers={\"Authorization\": f\"Bearer {token_user}\"})\n    assert response.status_code == status.HTTP_200_OK\n    response = client.get(\"/api/images/100\", headers={\"Authorization\": f\"Bearer {token_user}\"})\n    assert response.status_code == status.HTTP_404_NOT_FOUND\n    response = client.get(\"/api/images/{image_id}\", headers={\"Authorization\": f\"Bearer {token_user}\"})\n    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY", "\n\ndef test_update_description_image_by_admin(client, token, image):\n    response = client.patch(\"/api/images/description/1\", json={\n                            \"description\": \"description_description_description\",\n                            \"tags_text\": \"python\"}, headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == status.HTTP_200_OK, response.text\n    data = response.json()\n    assert data[\"description\"] == \"description_description_description\"\n    response = client.patch(\"/api/images/description/100\", json={\n                            \"description\": \"description_description_description\",\n                            \"tags_text\": \"python\"}, headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == status.HTTP_404_NOT_FOUND\n    response = client.patch(\"/api/images/description/{image_id}\", json={\"descri\": \"n\"},\n                            headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY", "\n\ndef test_update_description_image_by_user(client, token_user, image_user):\n    response = client.patch(\"/api/images/description/3\", json={\n                            \"description\": \"description_description_description\",\n                            \"tags_text\": \"python\"}, headers={\"Authorization\": f\"Bearer {token_user}\"})\n    assert response.status_code == status.HTTP_200_OK, response.text\n    data = response.json()\n    assert data[\"description\"] == \"description_description_description\"\n    response = client.patch(\"/api/images/description/100\", json={\n                            \"description\": \"description_description_description\",\n                            \"tags_text\": \"python\"}, headers={\"Authorization\": f\"Bearer {token_user}\"})\n    assert response.status_code == status.HTTP_404_NOT_FOUND\n    response = client.patch(\"/api/images/description/{image_id}\", json={\"descri\": \"n\"},\n                            headers={\"Authorization\": f\"Bearer {token_user}\"})\n    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY", "\n\ndef test_remove_image_by_admin(client, token, image):\n    response = client.delete(\"/api/images/1\", headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == status.HTTP_204_NO_CONTENT\n    response = client.delete(\"/api/images/100\", headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == status.HTTP_404_NOT_FOUND\n    response = client.delete(\"/api/images/{image_id}\", headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n", "\n\ndef test_remove_image_by_moder(client, token_moder, image_moder):\n    response = client.delete(\"/api/images/2\", headers={\"Authorization\": f\"Bearer {token_moder}\"})\n    assert response.status_code == status.HTTP_403_FORBIDDEN\n    response = client.delete(\"/api/images/100\", headers={\"Authorization\": f\"Bearer {token_moder}\"})\n    assert response.status_code == status.HTTP_403_FORBIDDEN\n    response = client.delete(\"/api/images/{image_id}\", headers={\"Authorization\": f\"Bearer {token_moder}\"})\n    assert response.status_code == status.HTTP_403_FORBIDDEN\n", "\n\ndef test_remove_image_by_user(client, token_user, image_user):\n    response = client.delete(\"/api/images/3\", headers={\"Authorization\": f\"Bearer {token_user}\"})\n    assert response.status_code == status.HTTP_403_FORBIDDEN\n    response = client.delete(\"/api/images/100\", headers={\"Authorization\": f\"Bearer {token_user}\"})\n    assert response.status_code == status.HTTP_403_FORBIDDEN\n    response = client.delete(\"/api/images/{image_id}\", headers={\"Authorization\": f\"Bearer {token_user}\"})\n    assert response.status_code == status.HTTP_403_FORBIDDEN\n", "\n\ndef test_create_image(client, token):\n    image_file = io.BytesIO()\n    image = PILImage.new('RGB', size=(100, 100), color=(255, 0, 0))\n    image.save(image_file, 'jpeg')\n    image_file.seek(0)\n    response = client.post(\n        \"/api/images\",\n        data={\"description\": \"test_image_test_image_test_image_test_image\",\n              \"tags_text\": \"#python\",\n              },\n        files={\"image_file\": (\"test.jpg\", image_file, \"image/jpeg\")}\n        ,\n        headers={\"Authorization\": f\"Bearer {token}\"},\n    )\n    assert response.status_code == status.HTTP_201_CREATED, response.text\n    data = response.json()\n    assert data[\"description\"] == \"test_image_test_image_test_image_test_image\"\n    assert \"id\" in data\n    image_file = io.BytesIO()\n    image = PILImage.new('RGB', size=(100, 100), color=(255, 110, 0))\n    image.save(image_file, 'jpeg')\n    image_file.seek(0)\n\n    response = client.post(\n        \"/api/images\",\n        data={\"description\": \"sma\",\n              \"tags_text\": \"#python\",\n              },\n        files={\"image_file\": (\"test.jpg\", image_file, \"image/jpeg\")}\n        ,\n        headers={\"Authorization\": f\"Bearer {token}\"},\n    )\n    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY", "\n\ndef test_generate_qrcode(client, token):\n    response = client.post(\"/generate_qrcode/100\", headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == status.HTTP_404_NOT_FOUND\n    qr = qrcode.QRCode(\n                        version=1,\n                        error_correction=qrcode.constants.ERROR_CORRECT_L,\n                        box_size=3,\n                        border=4,\n                        )\n    qr.add_data(\"test\")\n    qr.make(fit=True)\n    img = qr.make_image(fill_color=\"black\", back_color=\"white\")\n    output = io.BytesIO()\n    img.save(output)\n    output.seek(0)\n    response = client.post(\"/generate_qrcode/1\", headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == status.HTTP_201_CREATED", "\n"]}
{"filename": "tests/test_unit_route_comments.py", "chunked_list": ["from pytest import fixture\n\nfrom src.database.models import User, UserRole\nfrom fastapi import status\n\n@fixture(scope='function')\ndef token(client, user, session):\n    response = client.post(\"/api/auth/signup\",\n                           json={\"login\": \"deadpool\",\n                                                     \"email\": \"deadpool@example.com\",\n                                                     \"password_checksum\": \"123456789\"})\n    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n    current_user.role = UserRole.Admin\n    session.commit()\n    response = client.post(\"/api/auth/login\",\n                           data={\"username\": \"deadpool@example.com\",\n                                 \"password\": \"123456789\"},\n                           headers={'Content-Type': 'application/x-www-form-urlencoded'})\n    data = response.json()\n    return data[\"access_token\"]", "\n\ndef test_post_comment(client, token):\n    response = client.post(\"/api/comments/1\", json={\"comment_text\": \"Test text for new comment\"}, \n                           headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == 200, response.text\n    body_data = response.json()\n    assert body_data == {\n        \"id\": 1,\n        \"user_id\": 1,\n        \"image_id\": 1,\n        \"comment_text\": \"Test text for new comment\",\n        \"created_at\": f\"{body_data['created_at']}\",\n        \"updated_at\": None,\n    }", "\n\ndef test_show_user_comments(client, token):\n    response = client.get(\"/api/comments/user/1\", headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == 200, response.text\n    data = response.json()\n    assert data[0][\"id\"] == 1\n\n\ndef test_show_comments(client, token):\n    response = client.get(\"api/comments/image/1\", headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == 200, response.text\n    data = response.json()\n    assert data[0][\"id\"] == 1", "\ndef test_show_comments(client, token):\n    response = client.get(\"api/comments/image/1\", headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == 200, response.text\n    data = response.json()\n    assert data[0][\"id\"] == 1\n\n\ndef test_update_comment(client, token):\n    response = client.put(\n        \"api/comments/1\", json={\"comment_text\": \"NEW Test text for comment\"},\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n    assert response.status_code == 200, response.text\n    body_data = response.json()\n    assert body_data == {\n        \"id\": 1,\n        \"user_id\": 1,\n        \"image_id\": 1,\n        \"comment_text\": \"NEW Test text for comment\",\n        \"created_at\": f\"{body_data['created_at']}\",\n        \"updated_at\": f\"{body_data['updated_at']}\",\n    }", "def test_update_comment(client, token):\n    response = client.put(\n        \"api/comments/1\", json={\"comment_text\": \"NEW Test text for comment\"},\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n    assert response.status_code == 200, response.text\n    body_data = response.json()\n    assert body_data == {\n        \"id\": 1,\n        \"user_id\": 1,\n        \"image_id\": 1,\n        \"comment_text\": \"NEW Test text for comment\",\n        \"created_at\": f\"{body_data['created_at']}\",\n        \"updated_at\": f\"{body_data['updated_at']}\",\n    }", "\n\ndef test_remove_comment(client, token):\n    response = client.delete(\"/api/comments/100\", headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == status.HTTP_404_NOT_FOUND\n    response = client.delete(\"/api/comments/{image_id}\", headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n"]}
{"filename": "tests/test_unit_route_tags.py", "chunked_list": ["import datetime\n\nfrom pytest import fixture\n\nfrom src.database.models import Tag, User, UserRole, Image\nfrom fastapi import status\n\n\n@fixture(scope='module')\ndef token(client, user, session):\n    \"\"\"\n    The token function is used to create a user with admin privileges, and then log in as that user.\n    This allows us to test the endpoints that require an admin token.\n\n    Args:\n        client: Make requests to the api\n        user: Create a user in the database\n        session: Make queries to the database\n\n    Returns:\n        A valid access token\n    \"\"\"\n    response = client.post(\"/api/auth/signup\", json={\"login\": \"deadpool\", \"email\": \"deadpool@example.com\",\n                                                     \"password_checksum\": \"123456789\"})\n    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n    current_user.role = UserRole.Admin\n    session.commit()\n    response = client.post(\"/api/auth/login\", data={\n        \"username\": \"deadpool@example.com\",\n        \"password\": \"123456789\"}, headers={'Content-Type': 'application/x-www-form-urlencoded'})\n    data = response.json()\n    return data[\"access_token\"]", "@fixture(scope='module')\ndef token(client, user, session):\n    \"\"\"\n    The token function is used to create a user with admin privileges, and then log in as that user.\n    This allows us to test the endpoints that require an admin token.\n\n    Args:\n        client: Make requests to the api\n        user: Create a user in the database\n        session: Make queries to the database\n\n    Returns:\n        A valid access token\n    \"\"\"\n    response = client.post(\"/api/auth/signup\", json={\"login\": \"deadpool\", \"email\": \"deadpool@example.com\",\n                                                     \"password_checksum\": \"123456789\"})\n    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n    current_user.role = UserRole.Admin\n    session.commit()\n    response = client.post(\"/api/auth/login\", data={\n        \"username\": \"deadpool@example.com\",\n        \"password\": \"123456789\"}, headers={'Content-Type': 'application/x-www-form-urlencoded'})\n    data = response.json()\n    return data[\"access_token\"]", "\n\ndef test_create_tags(client, session, token):\n    \"\"\"\n    The test_create_tags function tests the POST /api/tag/{tags} endpoint.\n    It does this by creating a new tag with the name &quot;test&quot; and then checking that it was created correctly.\n\n    Args:\n        client: Make requests to the api\n        session: Query the database for tags\n        token: Authenticate the user\n\n    Returns:\n        A 201 status code and a list of dictionaries containing the tag name\n    \"\"\"\n    tags_string = \"test\"\n    response = client.post(\"/api/tag/%23test\", headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == status.HTTP_201_CREATED, response.text\n\n    expected_response = [{\"id\": 1, \"tag_name\": tags_string}]\n    assert response.json() == expected_response\n\n    tag = session.query(Tag).first()\n    assert tag is not None\n    assert tag.tag_name == tags_string", "\n\ndef test_create_tags_not_authorization(client, session):\n    \"\"\"\n    The test_create_tags_not_authorization function tests that a user cannot create a tag without authorization.\n\n    Args:\n        client: Make requests to the api\n        session: Create a new database session for the test\n\n    Returns:\n        A 401 unauthorized status code\n    \"\"\"\n    token = \"not_valid\"\n    response = client.post(\"/api/tag/%23test\", headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == status.HTTP_401_UNAUTHORIZED, response.text", "\n\ndef test_create_tags_not_valid_tags(client, session, token):\n    \"\"\"\n    The test_create_tags_not_valid_tags function tests the POST /api/tag/ endpoint.\n    It does this by sending a request to the endpoint with no data, and then checking that it returns a 404 status code.\n\n    Args:\n        client: Make requests to the api\n        session: Rollback the database after each test\n        token: Authenticate the user\n\n    Returns:\n        404\n    \"\"\"\n    response = client.post(\"/api/tag/\", headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == status.HTTP_404_NOT_FOUND, response.text", "\n\ndef test_get_images_by_tag(client, session, token):\n    \"\"\"\n    The test_get_images_by_tag function tests the get_images_by_tag function in the tag.py file.\n    The test is successful if it returns a 200 status code and a list of images with tags that match the tag name.\n\n    Args:\n        client: Make requests to the api\n        session: Create a new database session for the test\n        token: Authenticate the user\n\n    Returns:\n        The images that have the tag\n    \"\"\"\n    tag_name = \"test\"\n    limit = 10\n    offset = 0\n\n    tag = session.query(Tag).filter(Tag.id == 1).first()\n\n    image = session.query(Image).filter(Image.id == 1).first()\n\n    date = datetime.datetime.now()\n\n    if image is None:\n        image = Image(\n            id=1,\n            image_url=\"https://res.cloudinary.com/dy9mhswnt/image/upload/c_fill,g_faces,h_500,r_max,w_500\"\n                      \"/v1/photoshare/333db2aa2c097073b2e971767d76f543960ce141f4acf4671e82369de8526e9e\",\n            user_id=1,\n            created_at=date,\n            description=\"est_image_test_image_test_image_test_image\",\n            tags=[tag]\n        )\n        session.add(image)\n        session.commit()\n        session.refresh(image)\n\n    response = client.get(\"/api/tag/image/test\", headers={\"Authorization\": f\"Bearer {token}\"},\n                          params={\"limit\": limit, \"offset\": offset})\n\n    assert response.status_code == status.HTTP_200_OK, response.text\n\n    expected_response = [\n        {\n            \"id\": 1,\n            \"image_url\": \"https://res.cloudinary.com/dy9mhswnt/image/upload/c_fill,g_faces,h_500,r_max,w_500\"\n                         \"/v1/photoshare/333db2aa2c097073b2e971767d76f543960ce141f4acf4671e82369de8526e9e\",\n            \"user_id\": 1,\n            \"created_at\": date,\n            \"updated_at\": date,\n            \"description\": \"est_image_test_image_test_image_test_image\",\n            \"tags\": [\n                {\n                    \"id\": 1,\n                    \"tag_name\": \"test\"\n                }\n            ]\n        }\n    ]\n\n    assert response.json()[0][\"id\"] == expected_response[0][\"id\"]\n    assert response.json()[0][\"image_url\"] == expected_response[0][\"image_url\"]\n    assert response.json()[0][\"user_id\"] == expected_response[0][\"user_id\"]\n    assert response.json()[0][\"description\"] == expected_response[0][\"description\"]\n    assert response.json()[0][\"tags\"][0][\"id\"] == expected_response[0][\"tags\"][0][\"id\"]\n    assert response.json()[0][\"tags\"][0][\"tag_name\"] == expected_response[0][\"tags\"][0][\"tag_name\"]", "\n\ndef test_get_images_by_tag_not_found_images(client, session, token):\n    \"\"\"\n    The test_get_images_by_tag_not_found_images function tests the get_images_by_tag function in the image.py file\n    to ensure that it returns an empty list when no images are found with a given tag.\n\n    Args:\n        client: Make requests to the api\n        session: Pass the database session to the test function\n        token: Test the get_images_by_tag function with a valid token\n\n    Returns:\n        An empty list\n    \"\"\"\n    limit = 10\n    offset = 0\n\n    response = client.get(\"/api/tag/image/testnotfound\", headers={\"Authorization\": f\"Bearer {token}\"},\n                          params={\"limit\": limit, \"offset\": offset})\n\n    assert response.json() == []", "\n\ndef test_get_one_tag_found(client, session, token):\n    \"\"\"\n    The test_get_one_tag_found function tests the GET /api/tag/{tag_name} endpoint.\n    It ensures that a tag can be retrieved by its name.\n\n    Args:\n        client: Make requests to the api\n        session: Create a new session for the test\n        token: Authenticate the user\n\n    Returns:\n        A 200 response with the tag data\n    \"\"\"\n    tag = {\n        \"id\": 1,\n        \"tag_name\": \"test\"\n    }\n    response = client.get(\"/api/tag/test\", headers={\"Authorization\": f\"Bearer {token}\"})\n\n    assert response.status_code == status.HTTP_200_OK, response.text\n    assert response.json() == tag", "\n\ndef test_get_one_tag_not_found(client, session, token):\n    \"\"\"\n    The test_get_one_tag_not_found function tests the GET /api/tag/{id} endpoint.\n        It ensures that a 404 status code is returned when an invalid tag id is passed in.\n\n    Args:\n        client: Send requests to the api\n        session: Create a new session for the test\n        token: Authenticate the user\n\n    Returns:\n        A 404 status code\n    \"\"\"\n    tag = None\n    response = client.get(\"/api/tag/testnotfound\", headers={\"Authorization\": f\"Bearer {token}\"})\n\n    assert response.status_code == status.HTTP_404_NOT_FOUND, response.text", "\n\ndef test_update_tag_found(client, session, token):\n    \"\"\"\n    The test_update_tag_found function tests the update_tag function in the tag.py file.\n    It does this by first creating a new tag name, then it uses that to create a response from the client using PUT method\n    to update an existing tag with id 1 and header of token authorization. It then asserts that status code is 200 OK, which means\n    the request was successful and returns what we expected (in this case, it should return updated information for id 1).\n    Finally, it creates an expected response variable to compare against our actual response.\n\n    Args:\n        client: Make requests to the api\n        session: Create a new session for the test\n        token: Authenticate the user\n\n    Returns:\n        A 200 status code and the updated tag\n    \"\"\"\n    new_tag_name = \"test_1\"\n\n    response = client.put(\"/api/tag/1\", headers={\"Authorization\": f\"Bearer {token}\"}, json={\"tag_name\": new_tag_name})\n\n    assert response.status_code == status.HTTP_200_OK, response.text\n\n    expected_response = {\"id\": 1, \"tag_name\": new_tag_name}\n    assert response.json() == expected_response", "\n\ndef test_update_tag_not_found(client, session, token):\n    \"\"\"\n    The test_update_tag_not_found function tests the update tag endpoint.\n        It does this by first creating a new tag, then attempting to update it with an invalid id.\n        The expected result is that the response status code should be 404 NOT FOUND.\n\n    Args:\n        client: Make requests to the api\n        session: Create a new session for the test\n        token: Authenticate the user\n\n    Returns:\n        A 404 status code\n    \"\"\"\n    new_tag_name = \"test_1\"\n\n    response = client.put(\"/api/tag/999\", headers={\"Authorization\": f\"Bearer {token}\"}, json={\"tag_name\": new_tag_name})\n\n    assert response.status_code == status.HTTP_404_NOT_FOUND, response.text", "\n\ndef test_delete_tag_found(client, session, token):\n    \"\"\"\n    The test_delete_tag_found function tests the DELETE /api/tag/{tag_name} endpoint.\n    It does so by first creating a tag with the name &quot;test&quot; and then deleting it.\n    The test passes if the response status code is 204 No Content and if there are no tags in the database with that name.\n\n    Args:\n        client: Send a request to the server\n        session: Access the database\n        token: Pass in the token to the function\n\n    Returns:\n        A 204 status code\n    \"\"\"\n    response = client.delete(\"/api/tag/test_1\", headers={\"Authorization\": f\"Bearer {token}\"})\n\n    assert response.status_code == status.HTTP_204_NO_CONTENT, response.text\n\n    tag = session.query(Tag).filter(Tag.tag_name == \"test\").first()\n    assert tag is None", "\n\ndef test_delete_tag_not_found(client, session, token):\n    \"\"\"\n    The test_delete_tag_not_found function tests the DELETE /api/tag/{name} endpoint.\n    It does so by first creating a tag, then deleting it, and finally attempting to delete it again.\n    The final attempt should fail with a 404 Not Found error.\n\n    Args:\n        client: Make requests to the api\n        session: Create a database session\n        token: Authenticate the user\n\n    Returns:\n        A 404 status code\n    \"\"\"\n    response = client.delete(\"/api/tag/test\", headers={\"Authorization\": f\"Bearer {token}\"})\n\n    assert response.status_code == status.HTTP_404_NOT_FOUND, response.text", ""]}
{"filename": "tests/test_unit_repository_images.py", "chunked_list": ["import unittest\nfrom unittest.mock import MagicMock\nfrom sqlalchemy.orm import Session\n\nfrom src.database.models import User, Image\nfrom src.schemas.images import ImageModel\nfrom src.repository.images import (\n    get_images,\n    get_image,\n    create,", "    get_image,\n    create,\n    get_image_from_id,\n    get_image_from_url,\n    remove,\n    change_description,\n)\n\n\nclass TestContacts(unittest.IsolatedAsyncioTestCase):\n\n    def setUp(self):\n        self.session = MagicMock(spec=Session)\n        self.user = User(id=1)\n\n    async def test_get_images_found(self):\n        expect_res = [Image(), ]\n        self.session.query().filter().order_by().limit().offset().all.return_value = expect_res\n        result = await get_images(limit=10, offset=0, user=self.user, db=self.session)\n        self.assertEqual(result, expect_res)\n        self.assertListEqual(result, expect_res)\n\n    async def test_get_image_found(self):\n        expect_res = Image()\n        self.session.query().filter().order_by().first.return_value = expect_res\n        result = await get_image(image_id=1, user=self.user, db=self.session)\n        self.assertEqual(result, expect_res)\n\n    async def test_get_image_not_found(self):\n        self.session.query().filter().order_by().first.return_value = None\n        result = await get_image(image_id=100, user=self.user, db=self.session)\n        self.assertIsNone(result)\n\n    async def test_create_found(self):\n        body = ImageModel(tags_text=\"last, python\", description=\"test description test test\")\n        result = await create(body=body, image_url=\"image_url\", user=self.user, db=self.session)\n        self.assertEqual(result.description, body.description)\n        self.assertListEqual(result.tags, [])\n        self.assertTrue(hasattr(result, \"id\"))\n\n    async def test_get_image_from_id_found(self):\n        expect_res = Image()\n        self.session.query().filter().first.return_value = expect_res\n        result = await get_image_from_id(image_id=1, user=self.user, db=self.session)\n        self.assertEqual(result, expect_res)\n\n    async def test_get_image_from_id_not_found(self):\n        self.session.query().filter().first.return_value = None\n        result = await get_image_from_id(image_id=100, user=self.user, db=self.session)\n        self.assertIsNone(result)\n\n    async def test_get_image_from_url_found(self):\n        expect_res = Image()\n        self.session.query().filter().first.return_value = expect_res\n        result = await get_image_from_url(image_url=\"photo/349856\", user=self.user, db=self.session)\n        self.assertEqual(result, expect_res)\n\n    async def test_get_image_from_url_not_found(self):\n        self.session.query().filter().first.return_value = None\n        result = await get_image_from_url(image_url=\"\", user=self.user, db=self.session)\n        self.assertIsNone(result)\n\n    async def test_remove_found(self):\n        expect_res = Image()\n        self.session.query().filter().first.return_value = expect_res\n        result = await remove(image_id=1, user=self.user, db=self.session)\n        self.assertEqual(result, expect_res)\n\n    async def test_remove_not_found(self):\n        self.session.query().filter().first.return_value = None\n        result = await remove(image_id=100, user=self.user, db=self.session)\n        self.assertIsNone(result)\n\n    async def test_change_description_found(self):\n        expect_res = Image()\n        body = ImageModel(tags_text=\"last, python\", description=\"test description test test\")\n        self.session.query().filter().first.return_value = expect_res\n        self.session.commit.return_value = None\n        result = await change_description(body=body, image_id=1, user=self.user, db=self.session)\n        self.assertEqual(result, expect_res)\n        self.assertListEqual(result.tags, [])\n\n    async def test_change_description_not_found(self):\n        body = ImageModel(tags_text=\"last, python\", description=\"test description test test\")\n        self.session.query().filter().first.return_value = None\n        self.session.commit.return_value = None\n        result = await change_description(body=body, image_id=1, user=self.user, db=self.session)\n        self.assertIsNone(result)", "\nclass TestContacts(unittest.IsolatedAsyncioTestCase):\n\n    def setUp(self):\n        self.session = MagicMock(spec=Session)\n        self.user = User(id=1)\n\n    async def test_get_images_found(self):\n        expect_res = [Image(), ]\n        self.session.query().filter().order_by().limit().offset().all.return_value = expect_res\n        result = await get_images(limit=10, offset=0, user=self.user, db=self.session)\n        self.assertEqual(result, expect_res)\n        self.assertListEqual(result, expect_res)\n\n    async def test_get_image_found(self):\n        expect_res = Image()\n        self.session.query().filter().order_by().first.return_value = expect_res\n        result = await get_image(image_id=1, user=self.user, db=self.session)\n        self.assertEqual(result, expect_res)\n\n    async def test_get_image_not_found(self):\n        self.session.query().filter().order_by().first.return_value = None\n        result = await get_image(image_id=100, user=self.user, db=self.session)\n        self.assertIsNone(result)\n\n    async def test_create_found(self):\n        body = ImageModel(tags_text=\"last, python\", description=\"test description test test\")\n        result = await create(body=body, image_url=\"image_url\", user=self.user, db=self.session)\n        self.assertEqual(result.description, body.description)\n        self.assertListEqual(result.tags, [])\n        self.assertTrue(hasattr(result, \"id\"))\n\n    async def test_get_image_from_id_found(self):\n        expect_res = Image()\n        self.session.query().filter().first.return_value = expect_res\n        result = await get_image_from_id(image_id=1, user=self.user, db=self.session)\n        self.assertEqual(result, expect_res)\n\n    async def test_get_image_from_id_not_found(self):\n        self.session.query().filter().first.return_value = None\n        result = await get_image_from_id(image_id=100, user=self.user, db=self.session)\n        self.assertIsNone(result)\n\n    async def test_get_image_from_url_found(self):\n        expect_res = Image()\n        self.session.query().filter().first.return_value = expect_res\n        result = await get_image_from_url(image_url=\"photo/349856\", user=self.user, db=self.session)\n        self.assertEqual(result, expect_res)\n\n    async def test_get_image_from_url_not_found(self):\n        self.session.query().filter().first.return_value = None\n        result = await get_image_from_url(image_url=\"\", user=self.user, db=self.session)\n        self.assertIsNone(result)\n\n    async def test_remove_found(self):\n        expect_res = Image()\n        self.session.query().filter().first.return_value = expect_res\n        result = await remove(image_id=1, user=self.user, db=self.session)\n        self.assertEqual(result, expect_res)\n\n    async def test_remove_not_found(self):\n        self.session.query().filter().first.return_value = None\n        result = await remove(image_id=100, user=self.user, db=self.session)\n        self.assertIsNone(result)\n\n    async def test_change_description_found(self):\n        expect_res = Image()\n        body = ImageModel(tags_text=\"last, python\", description=\"test description test test\")\n        self.session.query().filter().first.return_value = expect_res\n        self.session.commit.return_value = None\n        result = await change_description(body=body, image_id=1, user=self.user, db=self.session)\n        self.assertEqual(result, expect_res)\n        self.assertListEqual(result.tags, [])\n\n    async def test_change_description_not_found(self):\n        body = ImageModel(tags_text=\"last, python\", description=\"test description test test\")\n        self.session.query().filter().first.return_value = None\n        self.session.commit.return_value = None\n        result = await change_description(body=body, image_id=1, user=self.user, db=self.session)\n        self.assertIsNone(result)", "\n\nif __name__ == '__main__':\n    unittest.main()"]}
{"filename": "tests/test_unit_route_ratings.py", "chunked_list": ["from pytest import fixture\n\nfrom src.database.models import User, UserRole, Image, Rating\nfrom fastapi import status\nimport datetime\n\n\n@fixture(scope='module')\ndef token(client, user, session):\n    response = client.post(\"/api/auth/signup\", json={\"login\": \"deadpool\", \"email\": \"deadpool@example.com\",\n                                                     \"password_checksum\": \"123456789\"})\n    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n    current_user.role = UserRole.Admin\n    session.commit()\n    response = client.post(\"/api/auth/login\", data={\n        \"username\": \"deadpool@example.com\",\n        \"password\": \"123456789\"}, headers={'Content-Type': 'application/x-www-form-urlencoded'})\n    data = response.json()\n    return data[\"access_token\"]", "def token(client, user, session):\n    response = client.post(\"/api/auth/signup\", json={\"login\": \"deadpool\", \"email\": \"deadpool@example.com\",\n                                                     \"password_checksum\": \"123456789\"})\n    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n    current_user.role = UserRole.Admin\n    session.commit()\n    response = client.post(\"/api/auth/login\", data={\n        \"username\": \"deadpool@example.com\",\n        \"password\": \"123456789\"}, headers={'Content-Type': 'application/x-www-form-urlencoded'})\n    data = response.json()\n    return data[\"access_token\"]", "\n\n@fixture(scope='module')\ndef image(client, user, session):\n    response = client.post(\"/api/auth/signup\", json={\"login\": \"deadpool\", \"email\": \"deadpool@example.com\",\n                                                     \"password_checksum\": \"123456789\"})\n    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n    image = session.query(Image).filter(Image.id == 1).first()\n    if image is None:\n        image = Image(\n            id=1,\n            image_url=\"https://res.cloudinary.com/dy9mhswnt/image/upload/c_fill,g_faces,h_500,r_max,w_500\"\n                      \"/v1/photoshare/473db2aa2c097073b2e971767d76f543960ce141f4acf4671e82369de8526e9e\",\n            user_id=5,\n            created_at=datetime.datetime.now(),\n            description=\"est_image_test_image_test_image_test_image\",\n\n        )\n        session.add(image)\n        session.commit()\n        session.refresh(image)\n    return image", "\n\n@fixture(scope='module')\ndef rating(client, user, session):\n    response = client.post(\"/api/auth/signup\", json={\"login\": \"deadpool\", \"email\": \"deadpool@example.com\",\n                                                     \"password_checksum\": \"123456789\"})\n    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n    rating = session.query(Image).filter(Rating.id == 1).first()\n    if rating is None:\n        rating = Rating(\n            id=1,\n            rate=5,\n            user_id=current_user.id,\n            image_id=1,\n        )\n        session.add(rating)\n        session.commit()\n        session.refresh(rating)\n    return rating", "\n\ndef test_show_images_by_rating(client, token, image, session):\n    response = client.get(\"/api/rating/show_images_by_rating?to_decrease=true\",\n                          headers={'Authorization': f'Bearer {token}'}\n                          )\n    assert response.status_code == status.HTTP_200_OK\n\n\ndef test_create_rate(client, token, image, session):\n    response = client.post(\"/api/rating/1/5\",\n                           headers={'Authorization': f'Bearer {token}'}\n                           )\n    assert response.status_code == status.HTTP_200_OK", "\ndef test_create_rate(client, token, image, session):\n    response = client.post(\"/api/rating/1/5\",\n                           headers={'Authorization': f'Bearer {token}'}\n                           )\n    assert response.status_code == status.HTTP_200_OK\n\n\ndef test_delete_rate(client, token, session, rating):\n    response = client.delete(\"/api/rating/delete/1\",\n                             headers={'Authorization': f'Bearer {token}'}\n                             )\n    assert response.status_code == status.HTTP_404_NOT_FOUND", "def test_delete_rate(client, token, session, rating):\n    response = client.delete(\"/api/rating/delete/1\",\n                             headers={'Authorization': f'Bearer {token}'}\n                             )\n    assert response.status_code == status.HTTP_404_NOT_FOUND\n\n\ndef test_show_image_rating(client, token, image, session):\n    response = client.get(\"/api/rating/show_image_rating/1\",\n                          headers={'Authorization': f'Bearer {token}'}\n                          )\n    assert response.status_code == status.HTTP_200_OK", ""]}
{"filename": "tests/test_route_main.py", "chunked_list": ["from fastapi import status\n\n\ndef test_root(client):\n    response = client.get(\"/\")\n    assert response.status_code == status.HTTP_200_OK\n    data = response.json()\n    assert data[\"message\"] == \"Welcome to the FAST API from team 6\"\n\n\ndef test_healthchecker(client):\n    response = client.get(\"/api/healthchecker\")\n    assert response.status_code == status.HTTP_200_OK\n    data = response.json()\n    assert data[\"message\"] == \"Welcome to FastAPI!\"", "\n\ndef test_healthchecker(client):\n    response = client.get(\"/api/healthchecker\")\n    assert response.status_code == status.HTTP_200_OK\n    data = response.json()\n    assert data[\"message\"] == \"Welcome to FastAPI!\"\n\n\n", "\n"]}
{"filename": "tests/test_unit_repository_tags.py", "chunked_list": ["import unittest\nfrom unittest.mock import MagicMock, patch\nfrom sqlalchemy.orm import Session\n\nfrom src.schemas.tags import TagModel\nfrom src.database.models import Tag, tag_to_image, Image\nfrom src.repository.tags import (\n    parse_tags,\n    create_tags,\n    edit_tag,", "    create_tags,\n    edit_tag,\n    find_tag,\n    delete_tag,\n    get_images_by_tag\n)\n\n\n\"\"\"\nUnit test repository tags.", "\"\"\"\nUnit test repository tags.\n\"\"\"\n\n\nclass TestTags(unittest.IsolatedAsyncioTestCase):\n    \"\"\"\n    Unit Test Tags repository.\n    \"\"\"\n    def setUp(self):\n        \"\"\"\n        The setUp function is run before each test.\n        It creates a mock session object, and a tag object with an id of 1, and the name &quot;test_tags&quot;.\n        It also creates an image object with an id of 1, url &quot;url image&quot;, user_id of 1, and description\n        &quot;test string description________________________________&quot;. The incoming data is set to &quot;#test_tags&quot;.\n\n        Args:\n            self: Represent the instance of the class\n\n        Returns:\n            A list of objects that will be used in the tests\n        \"\"\"\n        self.session = MagicMock(spec=Session)\n        self.tag = Tag(id=1, tag_name=\"test_tags\")\n        self.incoming_data = \"#test_tags\"\n        self.image = Image(\n            id=1,\n            image_url=\"url image\",\n            user_id=1,\n            description=\"test string description________________________________\",\n        )\n\n    def test_parse_tags_found(self):\n        \"\"\"\n        The test_parse_tags_found function tests the parse_tags function.\n        It checks to see if the tags are found in the incoming data and returns a list of those tags.\n\n        Args:\n            self: Represent the instance of the object that is passed to the method when it is called\n\n        Returns:\n            A list of tags\n        \"\"\"\n        expect_result = [\"test_tags\"]\n        tags = parse_tags(self.incoming_data)\n        self.assertEqual(tags, expect_result)\n        self.assertListEqual(tags, expect_result)\n\n    def test_parse_tags_not_found(self):\n        \"\"\"\n        The test_parse_tags_not_found function tests the parse_tags function when there are no tags in the incoming data.\n        The expected result is an empty list, and that is what we get.\n\n        Args:\n            self: Represent the instance of the class\n\n        Returns:\n            An empty list\n        \"\"\"\n        expect_result = list()\n        incoming_data = \"\"\n        tags = parse_tags(incoming_data)\n        self.assertEqual(tags, expect_result)\n        self.assertListEqual(tags, expect_result)\n\n    async def test_create_new_tags_existing_tag(self):\n        \"\"\"\n        The test_create_new_tags_existing_tag function tests the create_tags function when a tag already exists in the database.\n        The test creates an incoming data list with one tag, and then sets up a mock session object that returns that same tag when queried.\n        The test then calls the create_tags function with this incoming data and mock session object, and asserts that it returns a list containing only one element:\n        the original inputted Tag object.\n\n        Args:\n            self: Represent the instance of the object that is passed to the method when it is called\n\n        Returns:\n            The tag\n        \"\"\"\n        expect_result = [self.tag]\n        self.session.query().filter().first.return_value = self.tag\n        result = await create_tags(self.incoming_data, db=self.session)\n        self.assertEqual(result, expect_result)\n        self.assertEqual(result[0], expect_result[0])\n\n    async def test_create_new_tags_new_tag(self):\n        \"\"\"\n        The test_create_new_tags_new_tag function tests the create_tags function when a new tag is created.\n        The test_create_new_tags_new_tag function uses patch to mock the Tag class and return a MagicMock object.\n        The test then calls the create tags function with incoming data that does not exist in the database,\n        and asserts that it returns an array containing one element, which is equal to self.tag.\n\n        Args:\n            self: Access the class attributes and methods\n\n        Returns:\n            The tag that it created\n        \"\"\"\n        expect_result = [self.tag]\n        self.session.query().filter().first.return_value = None\n        self.session.add.return_value = MagicMock(return_value=self.tag)\n        with patch('src.repository.tags.Tag', return_value=self.tag):\n            result = await create_tags(self.incoming_data, db=self.session)\n        self.assertEqual(result, expect_result)\n        self.assertEqual(result[0], expect_result[0])\n\n    async def test_edit_tag_found(self):\n        \"\"\"\n        The test_edit_tag_found function tests the edit_tag function.\n            The test_edit_tag_found function is a coroutine that takes in self as an argument.\n            The expect result variable is set to the tag variable, which was created earlier in this class.\n            The edit tag name variable is set to &quot;edit name tag&quot;.  This will be used later on when we are editing our tags.\n                We want to make sure that our tags can be edited properly and accurately, so we need a way of testing this out!\n                That's what this test does for us!  It makes sure that our tags\n\n        Args:\n            self: Represent the instance of the class\n\n        Returns:\n            A result\n        \"\"\"\n        expect_result = self.tag\n        edit_tag_name = \"edit_name_tag\"\n        tag_model = TagModel(tag_name=edit_tag_name)\n        result = await edit_tag(expect_result, tag_model, db=self.session)\n        self.assertEqual(result.tag_name, edit_tag_name)\n        self.assertEqual(result.tag_name, expect_result.tag_name)\n        self.assertEqual(result.id, expect_result.id)\n\n    async def test_find_tag_by_id_found(self):\n        \"\"\"\n        The test_find_tag_by_id_found function tests the find_tag function when a tag is found.\n            The test_find_tag_by_id function sets up the following:\n                - A mock session object with a query method that returns an object with a filter method that returns an object\n                    with first and all methods. The first and all methods return None by default, but can be set to return\n                    objects of any type. In this case, we set it to return our self.tag instance variable which is of type TagModel (see above).\n\n        Args:\n            self: Access the attributes and methods of the class in python\n\n        Returns:\n            The tag object and the name of that tag\n        \"\"\"\n        expect_result = self.tag\n        id_tag = self.tag.id\n        self.session.query().filter().first.return_value = self.tag\n        result = await find_tag(id_tag, db=self.session)\n        self.assertEqual(result, expect_result)\n        self.assertEqual(result.tag_name, expect_result.tag_name)\n\n    async def test_find_tag_by_id_not_found(self):\n        \"\"\"\n        The test_find_tag_by_id_not_found function tests the find_tag function when a tag is not found.\n            The test_find_tag_by_id function creates a mock session and assigns it to self.session, then\n            creates an expect result of None and assigns it to expect result, then sets the id of self.tag\n            equal to id tag, then sets the return value for first() on filter() on query() on self.session\n            equal to None (which simulates that no tags were found), finally calls find tag with id tag as its argument.\n\n        Args:\n            self: Represent the instance of the object that is passed to the method when it is called\n\n        Returns:\n            None\n        \"\"\"\n        expect_result = None\n        id_tag = self.tag.id\n        self.session.query().filter().first.return_value = None\n        result = await find_tag(id_tag, db=self.session)\n        self.assertEqual(result, expect_result)\n        self.assertIsNone(result)\n\n    async def test_find_tag_found(self):\n        \"\"\"\n        The test_find_tag_found function tests the find_tag function when a tag is found.\n        It does this by creating a mock session and setting up the query to return an object.\n        The test then calls find_tag with that tag name, and checks if it returns the expected result.\n\n        Args:\n            self: Represent the instance of the object that is passed to the method\n\n        Returns:\n            The tag that is passed into it\n        \"\"\"\n        expect_result = self.tag\n        tex_tag = self.tag.tag_name\n        self.session.query().filter().first.return_value = self.tag\n        result = await find_tag(tex_tag, db=self.session)\n        self.assertEqual(result, expect_result)\n        self.assertEqual(result.tag_name, expect_result.tag_name)\n\n    async def test_find_tag_not_found(self):\n        \"\"\"\n        The test_find_tag_not_found function tests the find_tag function when a tag is not found.\n            The test_find_tag_not_found function uses the mock library to create a mock session object, and then sets up\n            that object's query method to return another mocked object. This second mocked object has its filter method set\n            up to return yet another mocked object, which in turn has its first method set up so that it returns None. This\n            simulates what happens when no tag with the given name exists in the database: The query() call returns an empty list,\n            and calling first on an\n\n        Args:\n            self: Represent the instance of the object that is passed to the method\n\n        Returns:\n            None\n        \"\"\"\n        expect_result = None\n        tex_tag = self.tag.tag_name\n        self.session.query().filter().first.return_value = None\n        result = await find_tag(tex_tag, db=self.session)\n        self.assertEqual(result, expect_result)\n        self.assertIsNone(result)\n\n    async def test_delete_tag_found(self):\n        \"\"\"\n        The test_delete_tag_found function tests the delete_tag function in the tags.py file.\n        The test_delete_tag_found function is a coroutine, so it must be called with 'await' and runs asynchronously.\n        The test_delete_tag found function takes no arguments, but uses self to access class variables that are set up in\n        the setUpClass method at the top of this TestCase class definition.\n\n        Args:\n            self: Represent the instance of the class\n\n        Returns:\n            The tag that was deleted\n        \"\"\"\n        expect_result = self.tag\n        tex_tag = self.tag.tag_name\n        self.session.query().filter().first.return_value = self.tag\n        result = await delete_tag(tex_tag, db=self.session)\n        self.assertEqual(result, expect_result)\n        self.assertEqual(result.tag_name, expect_result.tag_name)\n\n    async def test_delete_tag_not_found(self):\n        \"\"\"\n        The test_delete_tag_not_found function tests the delete_tag function in the tags.py file.\n        The test_delete_tag_not_found function is a coroutine that takes no arguments and returns nothing.\n        The test case for this function is when a tag does not exist in the database, so it should return None.\n\n        Args:\n            self: Access the attributes and methods of the class in python\n\n        Returns:\n            None\n        \"\"\"\n        expect_result = None\n        tex_tag = self.tag.tag_name\n        self.session.query().filter().first.return_value = None\n        result = await delete_tag(tex_tag, db=self.session)\n        self.assertEqual(result, expect_result)\n        self.assertIsNone(result)\n\n    async def test_get_images_by_tag_found(self):\n        \"\"\"\n        The test_get_images_by_tag_found function tests the get_images_by_tag function in the image.py file.\n        The test is successful if it returns a list of images that have been tagged with a specific tag.\n\n        Args:\n            self: Represent the instance of the class\n\n        Returns:\n            The list of images that match the tag\n        \"\"\"\n        expect_result = [self.image]\n        tex_tag = self.tag.tag_name\n        tag_limit = 10\n        tag_offset = 0\n        self.session.query().join().join().filter().order_by().limit().offset().all.return_value = [self.image]\n        result = await get_images_by_tag(tag=tex_tag, limit=tag_limit, offset=tag_offset, db=self.session)\n        self.assertEqual(result, expect_result)\n        self.assertEqual(result[0].id, expect_result[0].id)\n        self.assertEqual(result[0].image_url, expect_result[0].image_url)\n        self.assertEqual(result[0].description, expect_result[0].description)\n        self.assertEqual(result[0].user_id, expect_result[0].user_id)\n\n    async def test_get_images_by_tag_not_found(self):\n        \"\"\"\n        The test_get_images_by_tag_not_found function tests the get_images_by_tag function in the image.py file\n        to ensure that it returns None when no images are found with a given tag.\n\n        Args:\n            self: Access the attributes and methods of the class in python\n\n        Returns:\n            None\n        \"\"\"\n        expect_result = None\n        tex_tag = self.tag.tag_name\n        tag_limit = 10\n        tag_offset = 0\n        self.session.query().join().join().filter().order_by().limit().offset().all.return_value = None\n        result = await get_images_by_tag(tag=tex_tag, limit=tag_limit, offset=tag_offset, db=self.session)\n        self.assertEqual(result, expect_result)\n        self.assertIsNone(result)", "\n\nif __name__ == '__main__':\n    unittest.main()\n"]}
{"filename": "tests/test_unit_repository_users.py", "chunked_list": ["import unittest\nfrom datetime import datetime\nfrom unittest.mock import MagicMock\n\nfrom sqlalchemy.orm import Session\n\nfrom src.database.models import User\nfrom src.repository.users import create_user, update_token, update_avatar, update_user, change_role, ban_user, \\\n    get_user_profile, update_user_by_admin\nfrom src.schemas.users import UserModel, UserUpdate, UserChangeRole, UserShow, UserUpdateAdmin", "    get_user_profile, update_user_by_admin\nfrom src.schemas.users import UserModel, UserUpdate, UserChangeRole, UserShow, UserUpdateAdmin\n\n\nclass TestUsersRepository(unittest.IsolatedAsyncioTestCase):\n    def setUp(self):\n        self.session = MagicMock(spec=Session)\n        self.test_user = User(id=1,\n                              login='SomeLogin',\n                              email='someemail@gmail.com',\n                              role=1,\n                              user_pic_url='https://www.gravatar.com/avatar/94d093eda664addd6e450d7e9881bcad?s=32&d'\n                                           '=identicon&r=PG',\n                              name='Somename',\n                              is_active=True,\n                              password_checksum='secret')\n\n    async def test_create_user(self):\n        body = UserModel(login=self.test_user.login,\n                         email=self.test_user.email,\n                         password_checksum=self.test_user.password_checksum)\n\n        res = await create_user(body=body, db=self.session)\n\n        self.assertTrue(hasattr(res, \"id\"))\n        self.assertEqual(res.login, body.login)\n        self.assertEqual(res.email, body.email)\n        self.assertEqual(res.password_checksum, body.password_checksum)\n\n    async def test_update_token(self):\n        user = self.test_user\n        token = None\n        result = await update_token(user=user, refresh_token=token, db=self.session)\n        self.assertIsNone(result)\n\n    async def test_update_avatar(self):\n        url = 'https://res.cloudinary.com/'\n        result = await update_avatar(email=self.test_user.email, url=url, db=self.session)\n        self.assertEqual(result.avatar, url)\n\n    async def test_change_role(self):\n        body = UserChangeRole(id=self.test_user.id,\n                              role=2,\n                              updated_at=datetime.now())\n        res = await change_role(body=body, user=self.test_user, db=self.session)\n        self.assertEqual(res.role, body.role)\n\n    async def test_change_role_not_found(self):\n        body = UserChangeRole(id=100, role=2, updated_at=datetime.now())\n        self.session.query().filter().first.return_value = None\n        self.session.commit.return_value = None\n\n        result = await change_role(body=body, user=self.test_user, db=self.session)\n        self.assertIsNone(result)\n\n    async def test_get_user_profile(self):\n        user_profile = UserShow(\n            id=self.test_user.id,\n            login=self.test_user.login,\n            email=self.test_user.email,\n            role=self.test_user.role,\n            user_pic_url=self.test_user.user_pic_url,\n            name=self.test_user.name,\n            is_active=self.test_user.is_active,\n        )\n\n        self.session.query().filter().first.return_value = self.test_user\n\n        res = await get_user_profile(login=self.test_user.login, db=self.session)\n\n        self.assertEqual(res, user_profile)\n\n    async def test_ban_user(self):\n        res = await ban_user(user_id=1, db=self.session)\n        self.assertEqual(res.is_active, False)\n\n    async def test_ban_user_not_found(self):\n        self.session.query().filter().first.return_value = None\n        result = await ban_user(user_id=100, db=self.session)\n        self.assertIsNone(result)\n\n    async def test_update_user(self):\n        body = UserUpdate(id=self.test_user.id,\n                          login=self.test_user.login,\n                          email=self.test_user.email,\n                          role=self.test_user.role,\n                          user_pic_url=self.test_user.user_pic_url,\n                          name=\"test_update\",\n                          password_checksum=self.test_user.password_checksum,\n                          is_active=self.test_user.is_active,\n                          )\n\n        self.session.query().filter().first.return_value = self.test_user\n        res = await update_user(body=body, user=self.test_user, db=self.session)\n        self.assertEqual(res.name, \"test_update\")\n\n    async def test_update_user_not_found(self):\n        body = UserUpdate(id=100, email=self.test_user.email, password_checksum=self.test_user.password_checksum)\n        self.session.query().filter().first.return_value = None\n        res = await update_user(body=body, user=self.test_user, db=self.session)\n        self.assertIsNone(res)\n\n    async def test_update_user_by_admin(self):\n        body = UserUpdateAdmin(id=self.test_user.id,\n                               login=self.test_user.login,\n                               email=self.test_user.email,\n                               role=self.test_user.role,\n                               user_pic_url=self.test_user.user_pic_url,\n                               name=\"test_update_admin\",\n                               password_checksum=self.test_user.password_checksum,\n                               is_active=self.test_user.is_active,\n                               )\n\n        self.session.query().filter().first.return_value = self.test_user\n        res = await update_user_by_admin(body=body, user=self.test_user, db=self.session)\n        self.assertEqual(res.name, \"test_update_admin\")\n\n    async def test_update_user_by_admin_not_found(self):\n        body = UserUpdateAdmin(id=self.test_user.id,\n                               login=self.test_user.login,\n                               email=self.test_user.email,\n                               role=self.test_user.role,\n                               user_pic_url=self.test_user.user_pic_url,\n                               name=\"test_update_admin\",\n                               password_checksum=self.test_user.password_checksum,\n                               is_active=self.test_user.is_active,\n                               )\n        self.session.query().filter().first.return_value = None\n        res = await update_user_by_admin(body=body, user=self.test_user, db=self.session)\n        self.assertIsNone(res)", "\n\nif __name__ == '__main__':\n    unittest.main()\n"]}
{"filename": "tests/test_unit_route_auth.py", "chunked_list": ["from _pytest.fixtures import fixture\nfrom fastapi import status\n\nfrom src.database.models import User, UserRole\n\n\n@fixture(scope='function')\ndef token(client, user, session):\n    response = client.post(\"/api/auth/signup\",\n                           json={\"login\": \"deadpool\",\n                                 \"email\": \"deadpool@example.com\",\n                                 \"password_checksum\": \"123456789\"})\n    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n    current_user.role = UserRole.Admin\n    session.commit()\n    response = client.post(\"/api/auth/login\",\n                           data={\"username\": \"deadpool@example.com\",\n                                 \"password\": \"123456789\"},\n                           headers={'Content-Type': 'application/x-www-form-urlencoded'})\n    data = response.json()\n    return data[\"access_token\"]", "\n\ndef test_signup(client, user, session):\n    response = client.post(\"api/auth/signup\", json=user)\n    assert response.status_code == status.HTTP_201_CREATED\n\n    response = client.post(\"api/auth/signup\", json=user)\n    assert response.status_code == status.HTTP_409_CONFLICT\n\n\ndef test_login(client):\n    response = client.post(\"/api/auth/login\",\n                           data={\"username\": \"deadpool@example.com\",\n                                 \"password\": \"123456789\"},\n                           headers={'Content-Type': 'application/x-www-form-urlencoded'})\n\n    assert response.status_code == status.HTTP_200_OK\n    response = client.post(\"/api/auth/login\",\n                           data={\"username\": \"deadpool@example.com\",\n                                 \"password\": \"444\"},\n                           headers={'Content-Type': 'application/x-www-form-urlencoded'})\n\n    assert response.status_code == status.HTTP_401_UNAUTHORIZED", "\n\ndef test_login(client):\n    response = client.post(\"/api/auth/login\",\n                           data={\"username\": \"deadpool@example.com\",\n                                 \"password\": \"123456789\"},\n                           headers={'Content-Type': 'application/x-www-form-urlencoded'})\n\n    assert response.status_code == status.HTTP_200_OK\n    response = client.post(\"/api/auth/login\",\n                           data={\"username\": \"deadpool@example.com\",\n                                 \"password\": \"444\"},\n                           headers={'Content-Type': 'application/x-www-form-urlencoded'})\n\n    assert response.status_code == status.HTTP_401_UNAUTHORIZED", "\n\ndef test_login_wrong_user_data(client):\n    response = client.post(\"/api/auth/login\",\n                           data={\"username\": \"not_found@example.com\",\n                                 \"password\": \"123456789\"},\n                           headers={'Content-Type': 'application/x-www-form-urlencoded'})\n\n    assert response.status_code == status.HTTP_401_UNAUTHORIZED\n", "\n\ndef test_logout(client, token):\n    response = client.post(\"api/auth/logout\", headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == status.HTTP_200_OK\n\n\ndef test_refresh_token(client, token):\n    response = client.get(\"api/auth/refresh_token\", headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == status.HTTP_200_OK\n    response = client.get(\"api/auth/refresh_token\")\n    assert response.status_code == status.HTTP_401_UNAUTHORIZED", ""]}
{"filename": "tests/test_unit_services_tags.py", "chunked_list": ["import unittest\n\nfrom src.database.models import Tag\nfrom src.services.tags import (\n    create_transformation_tags\n)\n\n\n\"\"\"\nUnit test services tags.", "\"\"\"\nUnit test services tags.\n\"\"\"\n\n\nclass TestTags(unittest.IsolatedAsyncioTestCase):\n    \"\"\"\n    Unit test services tags.\n    \"\"\"\n    def setUp(self):\n        \"\"\"\n        The setUp function is run before each test.\n        It creates a Tag object and stores it in the self.tag_2 variable, which can be accessed by any of the tests in this class.\n\n        Args:\n            self: Represent the instance of the class\n\n        Returns:\n            The self\n        \"\"\"\n        self.tag_1 = Tag(id=1, tag_name=\"tag_1#Test#Test2\")\n        self.tags = [self.tag_1]\n\n    def test_create_transformation_tags(self):\n        \"\"\"\n        The test_create_transformation_tags function tests the create_transformation_tags function.\n        It does this by creating a list of tags, and then passing that list to the create_transformation_tags function.\n        The expected result is a string with all of the tags in it, separated by #tag#'s. The actual result is compared to\n        the expected result using an assert statement.\n\n        Args:\n            self: Represent the instance of the class\n\n        Returns:\n            A string of tags with the\n        \"\"\"\n        expected_result = \"#tag_1#Test#Test2\"\n        result = create_transformation_tags(self.tags)\n        self.assertEqual(result, expected_result)", "\n\nif __name__ == '__main__':\n    unittest.main()\n"]}
{"filename": "tests/test_unit_repository_comments.py", "chunked_list": ["import unittest\nfrom unittest.mock import MagicMock\n\nfrom sqlalchemy.orm import Session\n\nfrom src.database.models import Comment, User\nfrom src.schemas.comments import CommentBase, CommentResponse\nfrom src.repository.comments import (\n    get_all_user_comments,\n    get_comments_by_image_id,", "    get_all_user_comments,\n    get_comments_by_image_id,\n    create_comment,\n    delete_comment,\n    edit_comment,\n)\n\n\nclass TestComments(unittest.IsolatedAsyncioTestCase):\n\n    def setUp(self):\n        self.session = MagicMock(spec=Session)\n        self.test_user = User(id=1,\n                              login='SomeLogin',\n                              email='someemail@gmail.com',\n                              role=1,\n                              user_pic_url='https://www.gravatar.com/avatar/94d093eda664addd6e450d7e9881bcad?s=32&d'\n                                           '=identicon&r=PG',\n                              name='Somename',\n                              is_active=True,\n                              password_checksum='secret')\n        \n    async def test_get_all_user_comments(self):\n        comments = [Comment(), Comment(), Comment()]\n        self.session.query().filter().offset().limit().all.return_value = comments\n        result = await get_all_user_comments(skip=0, limit=10, user_id=self.test_user.id, db=self.session)\n        self.assertEqual(result, comments)\n\n\n    async def test_get_comments_by_image_id(self):\n        comments = [Comment(), Comment(), Comment()]\n        self.session.query().filter().offset().limit().all.return_value = comments\n        result = await get_comments_by_image_id(skip=0, limit=10, image_id=1, db=self.session)\n        self.assertEqual(result, comments)\n\n\n    async def test_create_comment(self):\n        image_id = 1\n        body = CommentBase(comment_text='test_comment')\n        result = await create_comment(image_id=image_id, body=body, db=self.session, user=self.test_user)\n        self.assertEqual(result.comment_text, body.comment_text)\n        self.assertEqual(result.image_id, image_id)\n        self.assertTrue(hasattr(result, \"id\"))\n\n\n    async def test_delete_comment_found(self):\n        comment = Comment()\n        self.session.query().filter().first.return_value = comment\n        result = await delete_comment(comment_id=1, db=self.session, user=self.test_user)\n        self.assertEqual(result, comment)\n\n\n    async def test_delete_comment_not_found(self):\n        self.session.query().filter().first.return_value = None\n        result = await delete_comment(comment_id=1, db=self.session, user=self.test_user)\n        self.assertIsNone(result)\n    \n\n    async def test_edit_comment_found(self):\n        body = CommentBase(comment_text='test_comment')\n        comment = Comment()\n        self.session.query().filter().first.return_value = comment\n        self.session.commit.return_value = None\n        result = await edit_comment(comment_id=1, body=body, db=self.session, user=self.test_user)\n        self.assertEqual(result, comment)\n\n\n    async def test_edit_comment_not_found(self):\n        body = CommentBase(comment_text='test_comment')\n        self.session.query().filter().first.return_value = None\n        self.session.commit.return_value = None\n        result = await edit_comment(comment_id=1, body=body, db=self.session, user=self.test_user)\n        self.assertIsNone(result)", "class TestComments(unittest.IsolatedAsyncioTestCase):\n\n    def setUp(self):\n        self.session = MagicMock(spec=Session)\n        self.test_user = User(id=1,\n                              login='SomeLogin',\n                              email='someemail@gmail.com',\n                              role=1,\n                              user_pic_url='https://www.gravatar.com/avatar/94d093eda664addd6e450d7e9881bcad?s=32&d'\n                                           '=identicon&r=PG',\n                              name='Somename',\n                              is_active=True,\n                              password_checksum='secret')\n        \n    async def test_get_all_user_comments(self):\n        comments = [Comment(), Comment(), Comment()]\n        self.session.query().filter().offset().limit().all.return_value = comments\n        result = await get_all_user_comments(skip=0, limit=10, user_id=self.test_user.id, db=self.session)\n        self.assertEqual(result, comments)\n\n\n    async def test_get_comments_by_image_id(self):\n        comments = [Comment(), Comment(), Comment()]\n        self.session.query().filter().offset().limit().all.return_value = comments\n        result = await get_comments_by_image_id(skip=0, limit=10, image_id=1, db=self.session)\n        self.assertEqual(result, comments)\n\n\n    async def test_create_comment(self):\n        image_id = 1\n        body = CommentBase(comment_text='test_comment')\n        result = await create_comment(image_id=image_id, body=body, db=self.session, user=self.test_user)\n        self.assertEqual(result.comment_text, body.comment_text)\n        self.assertEqual(result.image_id, image_id)\n        self.assertTrue(hasattr(result, \"id\"))\n\n\n    async def test_delete_comment_found(self):\n        comment = Comment()\n        self.session.query().filter().first.return_value = comment\n        result = await delete_comment(comment_id=1, db=self.session, user=self.test_user)\n        self.assertEqual(result, comment)\n\n\n    async def test_delete_comment_not_found(self):\n        self.session.query().filter().first.return_value = None\n        result = await delete_comment(comment_id=1, db=self.session, user=self.test_user)\n        self.assertIsNone(result)\n    \n\n    async def test_edit_comment_found(self):\n        body = CommentBase(comment_text='test_comment')\n        comment = Comment()\n        self.session.query().filter().first.return_value = comment\n        self.session.commit.return_value = None\n        result = await edit_comment(comment_id=1, body=body, db=self.session, user=self.test_user)\n        self.assertEqual(result, comment)\n\n\n    async def test_edit_comment_not_found(self):\n        body = CommentBase(comment_text='test_comment')\n        self.session.query().filter().first.return_value = None\n        self.session.commit.return_value = None\n        result = await edit_comment(comment_id=1, body=body, db=self.session, user=self.test_user)\n        self.assertIsNone(result)", "\n\nif __name__ == '__main__':\n    unittest.main()"]}
{"filename": "tests/conftest.py", "chunked_list": ["import pytest\n\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\nfrom main import app\nfrom src.database.models import Base\nfrom src.database.db import get_db\n", "from src.database.db import get_db\n\nSQLALCHEMY_DATABASE_URL = \"sqlite:///./test.db\"\n\nengine = create_engine(\n    SQLALCHEMY_DATABASE_URL, connect_args={\"check_same_thread\": False}\n)\nTestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n", "\n\n@pytest.fixture(scope=\"module\")\ndef session():\n    # Create the database\n\n    Base.metadata.drop_all(bind=engine)\n    Base.metadata.create_all(bind=engine)\n\n    db = TestingSessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()", "\n\n@pytest.fixture(scope=\"module\")\ndef client(session):\n    # Dependency override\n\n    def override_get_db():\n        try:\n            yield session\n        finally:\n            session.close()\n\n    app.dependency_overrides[get_db] = override_get_db\n\n    yield TestClient(app)", "\n\n@pytest.fixture(scope=\"module\")\ndef user():\n    return {\"login\": \"deadpool\", \"email\": \"deadpool@example.com\", \"password_checksum\": \"123456789\"}\n\n\n@pytest.fixture(scope=\"module\")\ndef user_moder():\n    return {\"login\": \"dead2pool\", \"email\": \"dead2pool@example.com\", \"password_checksum\": \"123456789\"}", "def user_moder():\n    return {\"login\": \"dead2pool\", \"email\": \"dead2pool@example.com\", \"password_checksum\": \"123456789\"}\n\n\n@pytest.fixture(scope=\"module\")\ndef user_user():\n    return {\"login\": \"dead1pool\", \"email\": \"dead1pool@example.com\", \"password_checksum\": \"123456789\"}\n"]}
{"filename": "tests/test_unit_route_users.py", "chunked_list": ["from pytest import fixture\n\nfrom src.database.models import User, UserRole\nfrom fastapi import status\n\n\n@fixture(scope='function')\ndef token(client, user, session):\n    response = client.post(\"/api/auth/signup\",\n                           json={\"login\": \"deadpool\",\n                                 \"email\": \"deadpool@example.com\",\n                                 \"password_checksum\": \"123456789\"})\n    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n    current_user.role = UserRole.Admin\n    session.commit()\n    response = client.post(\"/api/auth/login\",\n                           data={\"username\": \"deadpool@example.com\",\n                                 \"password\": \"123456789\"},\n                           headers={'Content-Type': 'application/x-www-form-urlencoded'})\n    data = response.json()\n    return data[\"access_token\"]", "\n\n@fixture(scope='function')\ndef token_second(client, user, session):\n    response = client.post(\"/api/auth/signup\",\n                           json={\"login\": \"TEST\",\n                                 \"email\": \"testpool@example.com\",\n                                 \"password_checksum\": \"testpassword\"})\n    current_user: User = session.query(User).filter(User.email == 'testpool@example.com').first()\n    current_user.role = UserRole.Admin\n    session.commit()\n    response = client.post(\"/api/auth/login\",\n                           data={\"username\": \"testpool@example.com\",\n                                 \"password\": \"testpassword\"},\n                           headers={'Content-Type': 'application/x-www-form-urlencoded'})\n    data = response.json()\n    return data[\"access_token\"]", "\n\ndef test_read_users_me(client, token):\n    response = client.get(\"api/users/me/\",\n                          headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == status.HTTP_200_OK\n    response = client.get(\"api/users/me/\")\n    assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\n\ndef test_read_user_profile_by_username(client, token, user):\n    login = user['login']\n    response = client.get(f\"api/users/user/{login}/\", headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == status.HTTP_200_OK\n    login = 'test_wrong_login'\n    response = client.get(f\"api/users/user/{login}/\", headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == status.HTTP_404_NOT_FOUND", "\n\ndef test_read_user_profile_by_username(client, token, user):\n    login = user['login']\n    response = client.get(f\"api/users/user/{login}/\", headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == status.HTTP_200_OK\n    login = 'test_wrong_login'\n    response = client.get(f\"api/users/user/{login}/\", headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == status.HTTP_404_NOT_FOUND\n", "\n\ndef test_change_role(client, user, token):\n    response = client.put(\"api/users/change_role\",\n                          json={\n                              \"id\": 1000,\n                              \"role\": 2,\n                              },\n                          headers={\"Authorization\": f\"Bearer {token}\"},)\n    assert response.status_code == status.HTTP_404_NOT_FOUND\n\n    response = client.put(\"api/users/change_role\",\n                          json={\n                              \"id\": 1,\n                              \"role\": 2,\n                              },\n                          headers={\"Authorization\": f\"Bearer {token}\"},)\n    assert response.status_code == status.HTTP_200_OK\n\n    response = client.put(\"api/users/change_role\")\n    assert response.status_code == status.HTTP_401_UNAUTHORIZED", "\n\ndef test_update_user(client, token):\n    response = client.put(\"api/users/update_user\",\n                          json={\n                              \"id\": 12121,\n                              \"email\": \"deadpool@example.com\",\n                              \"updated_at\": \"2023-05-21T16:35:59.380Z\",\n                              \"user_pic_url\": \"string\",\n                              \"name\": \"string\",\n                              \"password_checksum\": \"123456789\"},\n                          headers={\"Authorization\": f\"Bearer {token}\"},)\n    assert response.status_code == status.HTTP_404_NOT_FOUND\n\n    response = client.put(\"api/users/update_user\",\n                          headers={\"Authorization\": f\"Bearer {token}\"},\n                          json={\n                              \"id\": 1,\n                              \"email\": \"deadpool@example.com\",\n                              \"updated_at\": \"2023-05-21T16:35:59.380Z\",\n                              \"user_pic_url\": \"str495y2074y5804ying\",\n                              \"name\": \"string\",\n                              \"password_checksum\": \"123456789\"})\n    assert response.status_code == status.HTTP_200_OK\n\n    response = client.put(\"api/users/update_user\")\n    assert response.status_code == status.HTTP_401_UNAUTHORIZED", "\n\ndef test_update_user_by_admin(client, token_second):\n    response = client.put(\"api/users/update_user_by_admin\",\n                          json={\"id\": 100,\n                                \"login\": \"deadpool_2\",\n                                \"name\": \"deadpool_2\",\n                                \"email\": \"testpool@example.com\",\n                                \"is_active\": True,\n                                \"role\": 1,\n                                \"user_pic_url\": \"\",\n                                \"password_checksum\": \"testpasswod\",\n                                \"updated_at\": \"2023-05-21T16:35:59.380Z\",},\n                          headers={\"Authorization\": f\"Bearer {token_second}\"},)\n    assert response.status_code == status.HTTP_404_NOT_FOUND\n\n    response = client.put(\"api/users/update_user_by_admin\",\n                          json={\"id\": 1,\n                                \"login\": \"TEST_USER\",\n                                \"name\": \"test3\",\n                                \"email\": \"test______test@example.com\",\n                                \"is_active\": True,\n                                \"role\": 1,\n                                \"user_pic_url\": \"\",\n                                \"password_checksum\": \"testpasswod\",\n                                \"updated_at\": \"2023-05-21T16:35:59.380Z\",},\n                          headers={\"Authorization\": f\"Bearer {token_second}\"},)\n    assert response.status_code == status.HTTP_200_OK\n    print(response.json())\n\n    response = client.put(\"api/users/update_user_by_admin\")\n    assert response.status_code == status.HTTP_401_UNAUTHORIZED", "\n\ndef test_ban_user(client, user, token):\n    response = client.put(f\"api/users/ban_user/?user_id=1\", headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == status.HTTP_200_OK\n    response = client.put(f\"api/users/ban_user/?user_id=100\", headers={\"Authorization\": f\"Bearer {token}\"})\n    assert response.status_code == status.HTTP_404_NOT_FOUND\n\n", ""]}
{"filename": "docs/conf.py", "chunked_list": ["import sys\nimport os\n\nsys.path.append(os.path.abspath('..'))\nproject = 'PhotoShare Rest API'\ncopyright = '2023, command 6 Web9 GoIT'\nauthor = 'command 6 Web9 GoIT'\nrelease = '0.1.0'\n\nextensions = ['sphinx.ext.autodoc']", "\nextensions = ['sphinx.ext.autodoc']\n\ntemplates_path = ['_templates']\nexclude_patterns = ['build', 'Thumbs.db', '.DS_Store']\n\nhtml_theme = 'nature'\nhtml_static_path = ['_static']\n", ""]}
{"filename": "migrations/env.py", "chunked_list": ["from logging.config import fileConfig\n\nfrom sqlalchemy import engine_from_config\nfrom sqlalchemy import pool\n\nfrom alembic import context\n\nfrom src.database.models import Base\nfrom src.conf.config import settings\n", "from src.conf.config import settings\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\n\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nif config.config_file_name is not None:\n    fileConfig(config.config_file_name)", "if config.config_file_name is not None:\n    fileConfig(config.config_file_name)\n\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata\ntarget_metadata = Base.metadata\n\nconfig.set_main_option(\"sqlalchemy.url\", settings.database_url)", "\nconfig.set_main_option(\"sqlalchemy.url\", settings.database_url)\n\n\n# other values from the config, defined by the needs of env.py,\n# can be acquired:\n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\n\n\ndef run_migrations_offline() -> None:\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    url = config.get_main_option(\"sqlalchemy.url\")\n    context.configure(\n        url=url,\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()", "\n\ndef run_migrations_offline() -> None:\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    url = config.get_main_option(\"sqlalchemy.url\")\n    context.configure(\n        url=url,\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()", "\n\ndef run_migrations_online() -> None:\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    connectable = engine_from_config(\n        config.get_section(config.config_ini_section, {}),\n        prefix=\"sqlalchemy.\",\n        poolclass=pool.NullPool,\n    )\n\n    with connectable.connect() as connection:\n        context.configure(\n            connection=connection, target_metadata=target_metadata\n        )\n\n        with context.begin_transaction():\n            context.run_migrations()", "\n\nif context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()\n"]}
{"filename": "migrations/versions/386af5fb453b_t_m2.py", "chunked_list": ["\"\"\"t_m2\n\nRevision ID: 386af5fb453b\nRevises: 14057e32129f\nCreate Date: 2023-05-17 22:19:03.206484\n\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\n", "import sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision = '386af5fb453b'\ndown_revision = '14057e32129f'\nbranch_labels = None\ndepends_on = None\n\n\ndef upgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_constraint('tag_to_image_image_id_fkey', 'tag_to_image', type_='foreignkey')\n    op.drop_constraint('tag_to_image_tag_id_fkey', 'tag_to_image', type_='foreignkey')\n    op.create_foreign_key(None, 'tag_to_image', 'images', ['image_id'], ['id'], ondelete='CASCADE')\n    op.create_foreign_key(None, 'tag_to_image', 'tags', ['tag_id'], ['id'], ondelete='CASCADE')", "\n\ndef upgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_constraint('tag_to_image_image_id_fkey', 'tag_to_image', type_='foreignkey')\n    op.drop_constraint('tag_to_image_tag_id_fkey', 'tag_to_image', type_='foreignkey')\n    op.create_foreign_key(None, 'tag_to_image', 'images', ['image_id'], ['id'], ondelete='CASCADE')\n    op.create_foreign_key(None, 'tag_to_image', 'tags', ['tag_id'], ['id'], ondelete='CASCADE')\n    # ### end Alembic commands ###\n", "    # ### end Alembic commands ###\n\n\ndef downgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_constraint(None, 'tag_to_image', type_='foreignkey')\n    op.drop_constraint(None, 'tag_to_image', type_='foreignkey')\n    op.create_foreign_key('tag_to_image_tag_id_fkey', 'tag_to_image', 'tags', ['tag_id'], ['id'])\n    op.create_foreign_key('tag_to_image_image_id_fkey', 'tag_to_image', 'images', ['image_id'], ['id'])\n    # ### end Alembic commands ###", "    # ### end Alembic commands ###\n"]}
{"filename": "migrations/versions/38aaf09c56da_upd.py", "chunked_list": ["\"\"\"upd\n\nRevision ID: 38aaf09c56da\nRevises: eabd5cef78d7\nCreate Date: 2023-05-16 12:52:25.829980\n\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\n", "import sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision = '38aaf09c56da'\ndown_revision = 'eabd5cef78d7'\nbranch_labels = None\ndepends_on = None\n\n\ndef upgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_table('tag_to_image')\n\n\n    op.create_table('tag_to_image',\n                sa.Column('tag_id', sa.Integer(), nullable=False),\n                sa.Column('image_id', sa.Integer(), nullable=False),\n                sa.ForeignKeyConstraint(['image_id'], ['images.id'], ),\n                sa.ForeignKeyConstraint(['tag_id'], ['tags.id'], ),\n                sa.PrimaryKeyConstraint('tag_id', 'image_id')\n                    )", "\n\ndef upgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_table('tag_to_image')\n\n\n    op.create_table('tag_to_image',\n                sa.Column('tag_id', sa.Integer(), nullable=False),\n                sa.Column('image_id', sa.Integer(), nullable=False),\n                sa.ForeignKeyConstraint(['image_id'], ['images.id'], ),\n                sa.ForeignKeyConstraint(['tag_id'], ['tags.id'], ),\n                sa.PrimaryKeyConstraint('tag_id', 'image_id')\n                    )", "\n#    op.add_column('tag_to_image', sa.Column('id', sa.Integer(), nullable=False))\n#    op.alter_column('tag_to_image', 'tag_id',\n#               existing_type=sa.INTEGER(),\n#               nullable=True)\n#    op.alter_column('tag_to_image', 'image_id',\n#               existing_type=sa.INTEGER(),\n#               nullable=True)\n#    op.drop_constraint('tag_to_image_image_id_fkey', 'tag_to_image', type_='foreignkey')\n#    op.drop_constraint('tag_to_image_tag_id_fkey', 'tag_to_image', type_='foreignkey')", "#    op.drop_constraint('tag_to_image_image_id_fkey', 'tag_to_image', type_='foreignkey')\n#    op.drop_constraint('tag_to_image_tag_id_fkey', 'tag_to_image', type_='foreignkey')\n#    op.create_foreign_key(None, 'tag_to_image', 'images', ['image_id'], ['id'], ondelete='CASCADE')\n#    op.create_foreign_key(None, 'tag_to_image', 'tags', ['tag_id'], ['id'], ondelete='CASCADE')\n    # ### end Alembic commands ###\n\n\ndef downgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_constraint(None, 'tag_to_image', type_='foreignkey')\n    op.drop_constraint(None, 'tag_to_image', type_='foreignkey')\n    op.create_foreign_key('tag_to_image_tag_id_fkey', 'tag_to_image', 'tags', ['tag_id'], ['id'])\n    op.create_foreign_key('tag_to_image_image_id_fkey', 'tag_to_image', 'images', ['image_id'], ['id'])\n    op.alter_column('tag_to_image', 'image_id',\n               existing_type=sa.INTEGER(),\n               nullable=False)\n    op.alter_column('tag_to_image', 'tag_id',\n               existing_type=sa.INTEGER(),\n               nullable=False)\n    op.drop_column('tag_to_image', 'id')", "    # ### end Alembic commands ###\n"]}
{"filename": "migrations/versions/14057e32129f_new_tabl.py", "chunked_list": ["\"\"\"new_tabl\n\nRevision ID: 14057e32129f\nRevises: 38aaf09c56da\nCreate Date: 2023-05-17 22:13:42.220180\n\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\n", "import sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision = '14057e32129f'\ndown_revision = '38aaf09c56da'\nbranch_labels = None\ndepends_on = None\n\n\ndef upgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('blacklisted_tokens',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('token', sa.String(length=255), nullable=False),\n    sa.Column('added_on', sa.DateTime(), nullable=True),\n    sa.PrimaryKeyConstraint('id'),\n    sa.UniqueConstraint('token')\n    )\n    op.alter_column('tag_to_image', 'tag_id',\n               existing_type=sa.INTEGER(),\n               nullable=False)\n    op.alter_column('tag_to_image', 'image_id',\n               existing_type=sa.INTEGER(),\n               nullable=False)", "\n\ndef upgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('blacklisted_tokens',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('token', sa.String(length=255), nullable=False),\n    sa.Column('added_on', sa.DateTime(), nullable=True),\n    sa.PrimaryKeyConstraint('id'),\n    sa.UniqueConstraint('token')\n    )\n    op.alter_column('tag_to_image', 'tag_id',\n               existing_type=sa.INTEGER(),\n               nullable=False)\n    op.alter_column('tag_to_image', 'image_id',\n               existing_type=sa.INTEGER(),\n               nullable=False)", "    # ### end Alembic commands ###\n\n\ndef downgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.alter_column('tag_to_image', 'image_id',\n               existing_type=sa.INTEGER(),\n               nullable=False)\n    op.alter_column('tag_to_image', 'tag_id',\n               existing_type=sa.INTEGER(),\n               nullable=False)\n    op.drop_table('blacklisted_tokens')", "    # ### end Alembic commands ###\n"]}
{"filename": "migrations/versions/ba6bf3572799_init.py", "chunked_list": ["\"\"\"Init\n\nRevision ID: ba6bf3572799\nRevises: \nCreate Date: 2023-05-11 23:10:14.699542\n\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\n", "import sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision = 'ba6bf3572799'\ndown_revision = None\nbranch_labels = None\ndepends_on = None\n\n\ndef upgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('tags',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('tag_name', sa.String(length=25), nullable=True),\n    sa.PrimaryKeyConstraint('id'),\n    sa.UniqueConstraint('tag_name')\n    )\n    op.create_table('users',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('login', sa.String(length=50), nullable=True),\n    sa.Column('email', sa.String(length=150), nullable=True),\n    sa.Column('role', sa.Integer(), nullable=True),\n    sa.Column('created_at', sa.DateTime(), nullable=True),\n    sa.Column('updated_at', sa.DateTime(), nullable=True),\n    sa.Column('user_pic_url', sa.String(length=255), nullable=True),\n    sa.Column('name', sa.String(length=150), nullable=True),\n    sa.Column('confirmed', sa.Boolean(), nullable=True),\n    sa.Column('is_active', sa.Boolean(), nullable=True),\n    sa.Column('password_checksum', sa.String(length=255), nullable=False),\n    sa.Column('refresh_token', sa.String(length=255), nullable=True),\n    sa.PrimaryKeyConstraint('id'),\n    sa.UniqueConstraint('email'),\n    sa.UniqueConstraint('login'),\n    sa.UniqueConstraint('name')\n    )\n    op.create_table('images',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('image_url', sa.String(length=255), nullable=False),\n    sa.Column('user_id', sa.Integer(), nullable=True),\n    sa.Column('created_at', sa.DateTime(), nullable=True),\n    sa.Column('updated_at', sa.DateTime(), nullable=True),\n    sa.Column('description', sa.String(length=255), nullable=True),\n    sa.Column('is_deleted', sa.Boolean(), nullable=True),\n    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE'),\n    sa.PrimaryKeyConstraint('id'),\n    sa.UniqueConstraint('image_url')\n    )\n    op.create_table('comments',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('user_id', sa.Integer(), nullable=True),\n    sa.Column('image_id', sa.Integer(), nullable=True),\n    sa.Column('created_at', sa.DateTime(), nullable=True),\n    sa.Column('updated_at', sa.DateTime(), nullable=True),\n    sa.Column('comment_text', sa.Text(), nullable=True),\n    sa.ForeignKeyConstraint(['image_id'], ['images.id'], ondelete='CASCADE'),\n    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE'),\n    sa.PrimaryKeyConstraint('id')\n    )\n    op.create_table('ratings',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('rate', sa.Integer(), nullable=True),\n    sa.Column('user_id', sa.Integer(), nullable=True),\n    sa.Column('image_id', sa.Integer(), nullable=True),\n    sa.ForeignKeyConstraint(['image_id'], ['images.id'], ondelete='CASCADE'),\n    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE'),\n    sa.PrimaryKeyConstraint('id')\n    )\n    op.create_table('tag_to_image',\n    sa.Column('tag_id', sa.Integer(), nullable=False),\n    sa.Column('image_id', sa.Integer(), nullable=False),\n    sa.ForeignKeyConstraint(['image_id'], ['images.id'], ),\n    sa.ForeignKeyConstraint(['tag_id'], ['tags.id'], ),\n    sa.PrimaryKeyConstraint('tag_id', 'image_id')\n    )", "\n\ndef upgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('tags',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('tag_name', sa.String(length=25), nullable=True),\n    sa.PrimaryKeyConstraint('id'),\n    sa.UniqueConstraint('tag_name')\n    )\n    op.create_table('users',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('login', sa.String(length=50), nullable=True),\n    sa.Column('email', sa.String(length=150), nullable=True),\n    sa.Column('role', sa.Integer(), nullable=True),\n    sa.Column('created_at', sa.DateTime(), nullable=True),\n    sa.Column('updated_at', sa.DateTime(), nullable=True),\n    sa.Column('user_pic_url', sa.String(length=255), nullable=True),\n    sa.Column('name', sa.String(length=150), nullable=True),\n    sa.Column('confirmed', sa.Boolean(), nullable=True),\n    sa.Column('is_active', sa.Boolean(), nullable=True),\n    sa.Column('password_checksum', sa.String(length=255), nullable=False),\n    sa.Column('refresh_token', sa.String(length=255), nullable=True),\n    sa.PrimaryKeyConstraint('id'),\n    sa.UniqueConstraint('email'),\n    sa.UniqueConstraint('login'),\n    sa.UniqueConstraint('name')\n    )\n    op.create_table('images',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('image_url', sa.String(length=255), nullable=False),\n    sa.Column('user_id', sa.Integer(), nullable=True),\n    sa.Column('created_at', sa.DateTime(), nullable=True),\n    sa.Column('updated_at', sa.DateTime(), nullable=True),\n    sa.Column('description', sa.String(length=255), nullable=True),\n    sa.Column('is_deleted', sa.Boolean(), nullable=True),\n    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE'),\n    sa.PrimaryKeyConstraint('id'),\n    sa.UniqueConstraint('image_url')\n    )\n    op.create_table('comments',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('user_id', sa.Integer(), nullable=True),\n    sa.Column('image_id', sa.Integer(), nullable=True),\n    sa.Column('created_at', sa.DateTime(), nullable=True),\n    sa.Column('updated_at', sa.DateTime(), nullable=True),\n    sa.Column('comment_text', sa.Text(), nullable=True),\n    sa.ForeignKeyConstraint(['image_id'], ['images.id'], ondelete='CASCADE'),\n    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE'),\n    sa.PrimaryKeyConstraint('id')\n    )\n    op.create_table('ratings',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('rate', sa.Integer(), nullable=True),\n    sa.Column('user_id', sa.Integer(), nullable=True),\n    sa.Column('image_id', sa.Integer(), nullable=True),\n    sa.ForeignKeyConstraint(['image_id'], ['images.id'], ondelete='CASCADE'),\n    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE'),\n    sa.PrimaryKeyConstraint('id')\n    )\n    op.create_table('tag_to_image',\n    sa.Column('tag_id', sa.Integer(), nullable=False),\n    sa.Column('image_id', sa.Integer(), nullable=False),\n    sa.ForeignKeyConstraint(['image_id'], ['images.id'], ),\n    sa.ForeignKeyConstraint(['tag_id'], ['tags.id'], ),\n    sa.PrimaryKeyConstraint('tag_id', 'image_id')\n    )", "    # ### end Alembic commands ###\n\n\ndef downgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_table('tag_to_image')\n    op.drop_table('ratings')\n    op.drop_table('comments')\n    op.drop_table('images')\n    op.drop_table('users')\n    op.drop_table('tags')", "    # ### end Alembic commands ###\n"]}
{"filename": "migrations/versions/eabd5cef78d7_users_upgrade.py", "chunked_list": ["\"\"\"users upgrade\n\nRevision ID: eabd5cef78d7\nRevises: ba6bf3572799\nCreate Date: 2023-05-13 15:27:53.669412\n\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\n", "import sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision = 'eabd5cef78d7'\ndown_revision = 'ba6bf3572799'\nbranch_labels = None\ndepends_on = None\n\n\ndef upgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_constraint('users_name_key', 'users', type_='unique')\n    op.drop_column('users', 'confirmed')", "\n\ndef upgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_constraint('users_name_key', 'users', type_='unique')\n    op.drop_column('users', 'confirmed')\n    # ### end Alembic commands ###\n\n\ndef downgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.add_column('users', sa.Column('confirmed', sa.BOOLEAN(), autoincrement=False, nullable=True))\n    op.create_unique_constraint('users_name_key', 'users', ['name'])", "\ndef downgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.add_column('users', sa.Column('confirmed', sa.BOOLEAN(), autoincrement=False, nullable=True))\n    op.create_unique_constraint('users_name_key', 'users', ['name'])\n    # ### end Alembic commands ###\n"]}
{"filename": "src/repository/images.py", "chunked_list": ["from typing import List\n\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy import and_, desc\n\nfrom src.database.models import User, Image\nfrom src.repository.tags import create_tags\nfrom src.schemas.images import ImageModel\n\n", "\n\nasync def get_images(limit: int, offset: int, user: User, db: Session) -> List[Image] | None:\n    \"\"\"\n    The get_images function returns a list of images for the specified user.\n        The limit and offset parameters are used to paginate the results.\n\n    Arguments:\n        limit (int): maximum number to retrieve\n        offset (int): number of object to skip in the search", "        limit (int): maximum number to retrieve\n        offset (int): number of object to skip in the search\n        user (User): the current user\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:\n        List[Image] | None: A list of image objects or None if no matching images were found\n    \"\"\"\n    images = db.query(Image).filter(and_(Image.user_id == user.id, Image.is_deleted == False)).\\\n        order_by(desc(Image.created_at)).limit(limit).offset(offset).all()", "    images = db.query(Image).filter(and_(Image.user_id == user.id, Image.is_deleted == False)).\\\n        order_by(desc(Image.created_at)).limit(limit).offset(offset).all()\n    return images\n\n\nasync def get_image(image_id: int, user: User, db: Session) -> Image | None:\n    \"\"\"\n    The get_image function takes in an image_id, a user object and a database session.\n    It then queries the database for an image with the given id that belongs to the given user.\n    If such an image exists, it is returned.", "    It then queries the database for an image with the given id that belongs to the given user.\n    If such an image exists, it is returned.\n\n    Arguments:\n        image_id (int): Specify the image id of the image that we want to get\n        user (User): the current user\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:\n        Image | None: Image objects or None if no matching image were found", "    Returns:\n        Image | None: Image objects or None if no matching image were found\n    \"\"\"\n    image = db.query(Image).filter(and_(Image.user_id == user.id, Image.id == image_id, Image.is_deleted == False)).\\\n        order_by(desc(Image.created_at)).first()\n    return image\n\n\nasync def create(body: ImageModel, image_url: str, user: User, db: Session) -> Image:\n    \"\"\"", "async def create(body: ImageModel, image_url: str, user: User, db: Session) -> Image:\n    \"\"\"\n    The create function creates a new image in the database.\n\n    Args:\n        body (ImageModel): The ImageModel object to be created.\n        image_url(str): Pass the image url to the database\n        user (User): the current user\n        db (Session): SQLAlchemy session object for accessing the database\n", "        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:\n        Image: The image object\n    \"\"\"\n    image = Image(description=body.description, user=user, image_url=image_url, tags=await create_tags(body.tags_text, db))\n    db.add(image)\n    db.commit()\n    db.refresh(image)\n    return image", "    db.refresh(image)\n    return image\n\n\nasync def get_image_from_id(image_id: int, user: User, db: Session) -> Image | None:\n    \"\"\"\n    The get_image_from_id function takes in an image_id and a user, and returns the image with that id.\n\n    Args:\n        image_id (int): The id of the desired Image object.", "    Args:\n        image_id (int): The id of the desired Image object.\n        user (User): the current user\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:\n        Image | None: An image from the database based on an id and a user or None if no matching image were found\n    \"\"\"\n    image = db.query(Image).filter(and_(Image.id == image_id, Image.user_id == user.id, Image.is_deleted == False)).first()\n    return image", "    image = db.query(Image).filter(and_(Image.id == image_id, Image.user_id == user.id, Image.is_deleted == False)).first()\n    return image\n\n\nasync def get_image_from_url(image_url: str, user: User, db: Session) -> Image | None:\n    \"\"\"\n    The get_image_from_url function takes in an image_url and a user object, and returns the Image object\n        associated with that url. If no such image exists, it returns None.\n\n    Args:", "\n    Args:\n        image_url(str): Pass the image url to the database\n        user (User): the current user\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:\n        Image | None: The image with the given url and user or None if no matching image were found\n    \"\"\"\n    image = db.query(Image).filter(and_(Image.image_url == image_url,", "    \"\"\"\n    image = db.query(Image).filter(and_(Image.image_url == image_url,\n                                        Image.user_id == user.id,\n                                        Image.is_deleted == False)).first()\n    return image\n\n\nasync def remove(image_id: int, user: User, db: Session) -> Image | None:\n    \"\"\"\n    The remove function is used to delete an image from the database.", "    \"\"\"\n    The remove function is used to delete an image from the database.\n        It takes in a user and an image_id, and returns the deleted image if it exists.\n\n    Args:\n        image_id (int): The id of the desired Image object.\n        user (User): the current user\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:", "\n    Returns:\n        Image | None: the Image object representing the deleted image,\n        or None if the user have no permission to delete the image or if no matching image exists in the database\n    \"\"\"\n    image = await get_image_from_id(image_id, user, db)\n    if image:\n        image.is_deleted = True\n        db.commit()\n    return image", "    return image\n\n\nasync def change_description(body: ImageModel, image_id: int, user: User, db: Session) -> Image | None:\n    \"\"\"\n    The change_description function takes in a body, image_id, user and db.\n        The function then gets the image from the id provided by the user.\n        If there is an image it changes its description to what was provided in the body.\n\n    Args:", "\n    Args:\n        body (ImageModel): The ImageModel object to be created.\n        image_id(int): The id of the desired Image object.\n        user (User): the current user\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:\n        Image: The image object with the updated description\n    \"\"\"", "        Image: The image object with the updated description\n    \"\"\"\n    image = await get_image_from_id(image_id, user, db)\n    if image:\n        image.description = body.description\n        db.commit()\n    return image\n"]}
{"filename": "src/repository/ratings.py", "chunked_list": ["from typing import List\nfrom fastapi import HTTPException\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy import and_, func, desc\nfrom starlette import status\n\nfrom src.database.models import Rating, User, Image\n\n\nasync def create_rate(image_id: int, rate: int, db: Session, user: User) -> Rating:", "\nasync def create_rate(image_id: int, rate: int, db: Session, user: User) -> Rating:\n    \"\"\"\n    The create_rate function creates a new rate for the image with the given id.\n\n    Args:\n        image_id (int): The id of the image to be rated.\n        rate (int): The rating value.\n        db (Session): SQLAlchemy session object for accessing the database\n        user (User): The User object that is creating the rate.", "        db (Session): SQLAlchemy session object for accessing the database\n        user (User): The User object that is creating the rate.\n\n    Returns:\n        Comment: the Rating object representing the new rating.\n    \"\"\"\n    is_self_image = db.query(Image).filter(Image.id == image_id).first().user_id == user.id\n    already_rated = db.query(Rating).filter(and_(Rating.image_id == image_id, Rating.user_id == user.id)).first()\n    image_exists = db.query(Image).filter(Image.id == image_id).first()\n    if is_self_image:\n        raise HTTPException(status_code=status.HTTP_423_LOCKED, detail=\"It`s not possible to rate own image.\")", "    image_exists = db.query(Image).filter(Image.id == image_id).first()\n    if is_self_image:\n        raise HTTPException(status_code=status.HTTP_423_LOCKED, detail=\"It`s not possible to rate own image.\")\n    if already_rated:\n        raise HTTPException(status_code=status.HTTP_423_LOCKED, detail=\"It`s not possible to rate twice.\")\n    if image_exists:\n        new_rate = Rating(image_id=image_id, rate=rate, user_id=user.id)\n        db.add(new_rate)\n        db.commit()\n        db.refresh(new_rate)\n        return new_rate", "    \n\nasync def delete_rate(rate_id: int, db: Session, user: User) -> None:\n    \"\"\"\n    The delete_rate function deletes a rating from the database.\n\n    Args:\n        rate_id (int): The id of the rating to be deleted.\n        db (Session): A connection to the database.\n        user (User): The User object that is removes the rate.", "        db (Session): A connection to the database.\n        user (User): The User object that is removes the rate.\n\n    Returns:\n        None\n    \"\"\"\n    rate = db.query(Rating).filter(Rating.id == rate_id).first()\n    if rate:\n        db.delete(rate)\n        db.commit()", "    return None\n\n\nasync def calculate_rating(image_id: int, db: Session, user: User) -> float | None:\n    \"\"\"\n    The calculate_rating function calculate an average rating of the image.\n\n    Args:\n        image_id (int): The id of the image for calculating rating.\n        db (Session): A connection to the database.", "        image_id (int): The id of the image for calculating rating.\n        db (Session): A connection to the database.\n        user (User): The User object which calculates the rating.\n\n    Returns:\n        float: The average rating of the image\n    \"\"\"\n    rating = db.query(func.avg(Rating.rate)).filter(Rating.image_id == image_id).scalar()\n    return rating\n    ", "    return rating\n    \n\nasync def show_images_by_rating(to_decrease: bool, db: Session, user: User) -> List[Image] | list:\n    \"\"\"\n    The show_images_by_rating function show all images in db, sorted by rating.\n\n    Args:\n        to_decrease (bool): The boolean value, that indicates the direction of sorting.\n        db (Session): A connection to the database.", "        to_decrease (bool): The boolean value, that indicates the direction of sorting.\n        db (Session): A connection to the database.\n        user (User): The User object which asks for a list of sorted images\n\n    Returns:\n        List[Image] | None: a list of Image objects sorted by rating\n        or list if no matching rate\n    \"\"\"\n    if to_decrease:\n        images = db.query(Image, func.avg(Rating.rate).label('rate')).join(Rating).order_by(desc('rate')).group_by(Image).all()\n    else:\n        images = db.query(Image, func.avg(Rating.rate).label('rate')).join(Rating).order_by('rate').group_by(Image).all()", "    if to_decrease:\n        images = db.query(Image, func.avg(Rating.rate).label('rate')).join(Rating).order_by(desc('rate')).group_by(Image).all()\n    else:\n        images = db.query(Image, func.avg(Rating.rate).label('rate')).join(Rating).order_by('rate').group_by(Image).all()\n    rez = []\n    for image in images:\n        rez.append(image.Image)\n    return rez\n", ""]}
{"filename": "src/repository/users.py", "chunked_list": ["from datetime import datetime\n\nfrom libgravatar import Gravatar\nfrom sqlalchemy.orm import Session\n\nfrom src.database.models import User, BlacklistToken\nfrom src.schemas.users import UserModel, UserChangeRole, UserUpdate, UserUpdateAdmin, UserShow\nfrom src.services.auth import auth_service\n\n", "\n\nasync def get_user_by_email(email: str, db: Session) -> User | None:\n    \"\"\"\n    Function takes in an email and a database session,\n    and returns the user with that email if it exists. If no such user exists,\n    it returns None.\n\n    Arguments:\n        email (str): Pass in the email of the user we want to find", "    Arguments:\n        email (str): Pass in the email of the user we want to find\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:\n        User | None: A user object or None if the user is not found\n    \"\"\"\n    return db.query(User).filter_by(email=email).first()\n\n", "\n\nasync def create_user(body: UserModel, db: Session) -> User:\n    \"\"\"\n    The create_user function creates a new user in the database.\n\n    Arguments:\n        body (UserModel): Pass in the UserModel object that is created from the request body\n        db (Session): SQLAlchemy session object for accessing the database\n", "        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:\n        User: A user object, which is the same as what we return from our get_user function\n    \"\"\"\n    g = Gravatar(body.email)\n    new_user = User(**body.dict(), user_pic_url=g.get_image())\n    db.add(new_user)\n    db.commit()\n    db.refresh(new_user)", "    db.commit()\n    db.refresh(new_user)\n    return new_user\n\n\nasync def update_token(user: User, refresh_token: str | None, db: Session) -> None:\n    \"\"\"\n    The update_token function updates the refresh token for a user.\n\n    Arguments:", "\n    Arguments:\n        user (User): Pass the user object to the function\n        refresh_token (str | None): Pass the refresh token to the update_token function\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:\n        None\n    \"\"\"\n    user.refresh_token = refresh_token", "    \"\"\"\n    user.refresh_token = refresh_token\n    db.commit()\n\n\nasync def update_avatar(email: str, url: str, db: Session) -> User:\n    \"\"\"\n    The update_avatar function updates the avatar of a user.\n\n    Arguments:", "\n    Arguments:\n        email (str): Find the user in the database by this email\n        url (str): Pass in the url of the avatar that we want to update\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:\n        User: A user object\n    \"\"\"\n    user = await get_user_by_email(email, db)", "    \"\"\"\n    user = await get_user_by_email(email, db)\n    user.avatar = url\n    db.commit()\n    return user\n\n\nasync def update_user(body: UserUpdate, user: User, db: Session) -> User | None:\n    \"\"\"\n    Updates user profile.", "    \"\"\"\n    Updates user profile.\n    Logged-in user can update his information.\n\n    Arguments:\n        body (UserUpdate): A set of user attributes to update\n        user (User): the current user\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:", "\n    Returns:\n        User | None: A user object or None\n    \"\"\"\n    user = db.query(User).filter(User.id == body.id).first()\n    if user:\n        user.name = body.name\n        user.email = body.email\n        user.user_pic_url = body.user_pic_url\n        user.password_checksum = auth_service.pwd_context.hash(body.password_checksum)\n        user.updated_at = datetime.now()\n        db.commit()", "    return user\n\n\nasync def update_user_by_admin(body: UserUpdateAdmin, user: User, db: Session) -> User | None:\n    \"\"\"\n    Updates user profile.\n    Logged-in admin can update any profile.\n\n    Arguments:\n        body (UserUpdateAdmin): A set of user attributes to update", "    Arguments:\n        body (UserUpdateAdmin): A set of user attributes to update\n        user (User): the current user\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:\n        User | None: A user object or None\n    \"\"\"\n    user_to_update = db.query(User).filter(User.id == body.id).first()\n    if user_to_update:\n\n        user_to_update.login = body.login\n        user_to_update.name = body.name\n        user_to_update.email = body.email\n        user_to_update.is_active = body.is_active\n        user_to_update.role = body.role\n        user_to_update.user_pic_url = body.user_pic_url\n        user_to_update.password_checksum = auth_service.pwd_context.hash(body.password_checksum)\n        user_to_update.updated_at = datetime.now()\n        db.commit()\n        return user_to_update", "    user_to_update = db.query(User).filter(User.id == body.id).first()\n    if user_to_update:\n\n        user_to_update.login = body.login\n        user_to_update.name = body.name\n        user_to_update.email = body.email\n        user_to_update.is_active = body.is_active\n        user_to_update.role = body.role\n        user_to_update.user_pic_url = body.user_pic_url\n        user_to_update.password_checksum = auth_service.pwd_context.hash(body.password_checksum)\n        user_to_update.updated_at = datetime.now()\n        db.commit()\n        return user_to_update", "    return None\n\n\nasync def change_role(body: UserChangeRole, user: User, db: Session) -> User | None:\n    \"\"\"\n    Logged-in admin can change role of any profile by ID.\n\n    Arguments:\n        body (UserChangeRole): A set of user new role\n        user (User): the current user", "        body (UserChangeRole): A set of user new role\n        user (User): the current user\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:\n        User | None: A user object or None\n    \"\"\"\n    user_to_update = db.query(User).filter(User.id == body.id).first()\n    if user_to_update:\n        user_to_update.role = body.role\n        user_to_update.updated_at = datetime.now()\n        db.commit()\n        return user_to_update", "    if user_to_update:\n        user_to_update.role = body.role\n        user_to_update.updated_at = datetime.now()\n        db.commit()\n        return user_to_update\n    return None\n\n\nasync def ban_user(user_id: int, db: Session) -> User | None:\n    \"\"\"", "async def ban_user(user_id: int, db: Session) -> User | None:\n    \"\"\"\n    Sets user status to inactive.\n\n    Arguments:\n        user_id (int): A set of user new role\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:\n        User | None: A user object or None", "    Returns:\n        User | None: A user object or None\n    \"\"\"\n    user_to_ban = db.query(User).filter(User.id == user_id).first()\n    if user_to_ban:\n        user_to_ban.is_active = False\n        db.commit()\n        return user_to_ban\n    return None\n", "    return None\n\n\nasync def get_user_profile(login: str, db: Session) -> UserShow | None:\n    \"\"\"\n    function returns a UserShow object containing the user's information.\n\n    Arguments:\n        login (str): Get the user profile of a specific user\n        db (Session): SQLAlchemy session object for accessing the database", "        login (str): Get the user profile of a specific user\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:\n        User | None: A UserShow object or None\n    \"\"\"\n    user = db.query(User).filter(User.login == login).first()\n    if user:\n        user_profile = UserShow(\n            id=user.id,\n            login=user.login,\n            email=user.email,\n            role=user.role,\n            user_pic_url=user.user_pic_url,\n            name=user.name,\n            is_active=user.is_active,\n        )\n        return user_profile", "    return None\n\n\nasync def add_to_blacklist(token: str, db: Session) -> None:\n    \"\"\"\n    Function adds a token to the blacklist.\n\n    Arguments:\n        token (str): The JWT that is being blacklisted.\n        db (Session): SQLAlchemy session object for accessing the database", "        token (str): The JWT that is being blacklisted.\n        db (Session): SQLAlchemy session object for accessing the database\n    Returns:\n        None\n    \"\"\"\n    blacklist_token = BlacklistToken(token=token, added_on=datetime.now())\n    db.add(blacklist_token)\n    db.commit()\n    db.refresh(blacklist_token)\n    return None", "    db.refresh(blacklist_token)\n    return None\n\n\nasync def is_blacklisted_token(token: str, db: Session) -> bool:\n    \"\"\"\n    Function takes checks if a token is blacklisted.\n\n    Arguments:\n        token (str): token to be checked", "    Arguments:\n        token (str): token to be checked\n        db (Session): SQLAlchemy session object for accessing the database\n    Returns:\n        bool\n    \"\"\"\n    blacklist_token = db.query(BlacklistToken).filter(BlacklistToken.token == token).first()\n    if blacklist_token:\n        return True\n    return False", "    return False\n"]}
{"filename": "src/repository/tags.py", "chunked_list": ["from typing import List\n\nfrom sqlalchemy import and_, desc\n\nfrom src.schemas.tags import TagModel\nfrom src.database.models import Tag, tag_to_image, Image\nfrom sqlalchemy.orm import Session\n\n\ndef parse_tags(tags_string: str) -> list[str]:\n    \"\"\"\n    parse a list of tags, find # and separated by spaces\n\n    Arguments:\n        tags_string (str): string to parse\n\n    Returns:\n        list[str]: list of tags\n    \"\"\"\n    result = []\n    if not tags_string:\n        return result\n    raw_tag = tags_string.split(' ')\n    for cur_tag in raw_tag:\n        if cur_tag[:1] == '#':\n            result.append(cur_tag[1:])\n            if len(result) == 5:\n                return result\n    return result", "\ndef parse_tags(tags_string: str) -> list[str]:\n    \"\"\"\n    parse a list of tags, find # and separated by spaces\n\n    Arguments:\n        tags_string (str): string to parse\n\n    Returns:\n        list[str]: list of tags\n    \"\"\"\n    result = []\n    if not tags_string:\n        return result\n    raw_tag = tags_string.split(' ')\n    for cur_tag in raw_tag:\n        if cur_tag[:1] == '#':\n            result.append(cur_tag[1:])\n            if len(result) == 5:\n                return result\n    return result", "\n\nasync def create_tags(tags_string: str, db: Session) -> List[Tag]:\n    \"\"\"\n    Create a new tags in database just if not exist\n    limit 5 tags\n\n    Arguments:\n        tags_string (str): string to create tags after parsing\n        db (Session): SQLAlchemy session object for accessing the database", "        tags_string (str): string to create tags after parsing\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:\n        List[Tag]: list with tags objects\n    \"\"\"\n    result = []\n    rw_tags = parse_tags(tags_string)\n    for tag_name in rw_tags:\n        tag = await find_tag(tag_name, db)\n        if tag:\n            result.append(tag)\n        else:\n            tag = Tag(tag_name=tag_name)\n            db.add(tag)\n            db.commit()\n            db.refresh(tag)\n            result.append(tag)", "    for tag_name in rw_tags:\n        tag = await find_tag(tag_name, db)\n        if tag:\n            result.append(tag)\n        else:\n            tag = Tag(tag_name=tag_name)\n            db.add(tag)\n            db.commit()\n            db.refresh(tag)\n            result.append(tag)", "    return result\n\n\nasync def edit_tag(tag: Tag, body: TagModel, db: Session) -> Tag | None:\n    \"\"\"\n    The edit_tag function takes in a tag object, the body of the request (which is a TagModel), and\n    the database session. It then sets the tag_name attribute of that tag to be equal to whatever was\n    passed in as part of the body. The function then commits those changes to our database and refreshes\n    the object so that it reflects any changes made by other users.\n", "    the object so that it reflects any changes made by other users.\n\n    Arguments:\n        tag (Tag): Pass the tag object to the function\n        body (TagModel): request body containing information about tag for editing\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:\n        Tag | None: tag object after editing\n        or None if the user have no permission to edite the tag or if no matching tag exists in the database", "        Tag | None: tag object after editing\n        or None if the user have no permission to edite the tag or if no matching tag exists in the database\n    \"\"\"\n    tag.tag_name = body.tag_name\n    db.commit()\n    db.refresh(tag)\n    return tag\n\n\nasync def find_tag(tag_name: str, db: Session) -> Tag | None:", "\nasync def find_tag(tag_name: str, db: Session) -> Tag | None:\n    \"\"\"\n    get tag from database by name\n\n    Arguments:\n        tag_name (str): name of tag to find\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:", "\n    Returns:\n        Tag | None: tag object\n        or None if no matching tag exists in the database\n    \"\"\"\n    tag = db.query(Tag).filter(Tag.tag_name == tag_name).first()\n    return tag\n\n\nasync def find_tag_by_id(tag_id: int, db: Session) -> Tag | None:", "\nasync def find_tag_by_id(tag_id: int, db: Session) -> Tag | None:\n    \"\"\"\n    The find_tag_by_id function takes in a tag_id and db Session object,\n    and returns the Tag object with that id. If no such tag exists, it returns None.\n\n    Args:\n        tag_id: int: Find the tag in the database\n        db: Session: Pass the database session to the function\n", "        db: Session: Pass the database session to the function\n\n    Returns:\n        A tag object or none\n    \"\"\"\n    tag = db.query(Tag).filter(Tag.id == tag_id).first()\n    return tag\n\n\nasync def delete_tag(tag_name: str, db: Session) -> Tag | None:", "\nasync def delete_tag(tag_name: str, db: Session) -> Tag | None:\n    \"\"\"\n    Delete tag from database just for Administrator role\n\n    Arguments:\n        tag_name (str): name of tag to find\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:", "\n    Returns:\n        Tag | None: tag object\n        or None if the user have no permission to delete the tag or if no matching tag exists in the database\n    \"\"\"\n    tag = await find_tag(tag_name, db)\n    if tag:\n        db.delete(tag)\n        db.commit()\n    return tag", "    return tag\n\n\nasync def get_images_by_tag(tag: str, limit: int, offset: int, db: Session) -> List[Image] | None:\n    \"\"\"\n    The get_images function returns a list of images for the specified user.\n        The limit and offset parameters are used to paginate the results.\n\n    Arguments:\n        tag (str): name of tag to find images", "    Arguments:\n        tag (str): name of tag to find images\n        offset (int): number of comments to skip in the search\n        limit (int): maximum number of comments to retrieve\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:\n        List[Image] | None: a list of Image objects with tags,\n        or None if no matching tags were found\n    \"\"\"", "        or None if no matching tags were found\n    \"\"\"\n    images = db.query(Image).join(tag_to_image).join(Tag).filter(and_(Tag.tag_name == tag, Image.is_deleted == False))\\\n        .order_by(desc(Image.created_at)).limit(limit).offset(offset).all()\n\n    return images\n"]}
{"filename": "src/repository/comments.py", "chunked_list": ["from typing import List\n\nfrom sqlalchemy import func, and_\nfrom sqlalchemy.orm import Session\n\nfrom src.database.models import User, Comment\nfrom src.schemas.comments import CommentBase\n\n\nasync def create_comment(image_id: int, body: CommentBase, db: Session, user: User) -> Comment:", "\nasync def create_comment(image_id: int, body: CommentBase, db: Session, user: User) -> Comment:\n    \"\"\"\n    Creates a new comment in the database.\n\n    Arguments:\n        image_id (int): ID of the image that the comment is being made on\n        body (CommentBase): Pass the comment_text from the request body to the function\n        db (Session): SQLAlchemy session object for accessing the database\n        user (User): the current user attempting to delete the comment", "        db (Session): SQLAlchemy session object for accessing the database\n        user (User): the current user attempting to delete the comment\n\n    Returns:\n        Comment: the Comment object representing the new comment\n    \"\"\"\n    comment = Comment(user_id=user.id,\n                      image_id=image_id,\n                      created_at=func.now(),\n                      comment_text=body.comment_text)", "                      created_at=func.now(),\n                      comment_text=body.comment_text)\n    db.add(comment)\n    db.commit()\n    db.refresh(comment)\n    return comment\n\n\nasync def edit_comment(comment_id: int, body: CommentBase, db: Session, user: User) -> Comment | None:\n    \"\"\"", "async def edit_comment(comment_id: int, body: CommentBase, db: Session, user: User) -> Comment | None:\n    \"\"\"\n    Modifies the specified comment in the database, if the current user has permission to do so.\n\n    Arguments:\n        comment_id (int): ID of the comment to be deleted\n        db (Session): SQLAlchemy session object for accessing the database\n        body (CommentBase): Pass the comment_text from the request body to the function\n        user (User): the current user attempting to edite the comment\n", "        user (User): the current user attempting to edite the comment\n\n    Returns:\n        Comment | None: the Comment object representing the modified comment,\n        or None if the user have no permission to edite the comment or if no matching comment exists in the database\n    \"\"\"\n    comment = db.query(Comment).filter(and_(Comment.id == comment_id, Comment.user_id == user.id)).first()\n    if comment:\n        comment.comment_text = body.comment_text\n        comment.updated_at = func.now()\n        db.commit()", "    return comment\n\n\nasync def delete_comment(comment_id: int, db: Session, user: User) -> Comment | None:\n    \"\"\"\n    Deletes the specified comment from the database, if the current user has permission to do so.\n\n    Arguments:\n        comment_id (int): ID of the comment to be deleted\n        db (Session): SQLAlchemy session object for accessing the database", "        comment_id (int): ID of the comment to be deleted\n        db (Session): SQLAlchemy session object for accessing the database\n        user (User): the current user attempting to delete the comment\n\n    Returns:\n        Comment | None: the Comment object representing the deleted comment,\n        or None if the user have no permission to delete the comment or if no matching comment exists in the database\n    \"\"\"\n\n    comment = db.query(Comment).filter(Comment.id == comment_id).first()\n    if comment:\n        db.delete(comment)\n        db.commit()", "\n    comment = db.query(Comment).filter(Comment.id == comment_id).first()\n    if comment:\n        db.delete(comment)\n        db.commit()\n    return comment\n\n\nasync def get_all_user_comments(skip: int, limit: int, user_id: int, db: Session) -> List[Comment] | None:\n    \"\"\"", "async def get_all_user_comments(skip: int, limit: int, user_id: int, db: Session) -> List[Comment] | None:\n    \"\"\"\n    Gets all comments from the specified user from the database.\n\n    Arguments:\n        skip (int): number of comments to skip in the search\n        limit (int): maximum number of comments to retrieve\n        user_id (int): ID of the user to retrieve comments for\n        db (Session): SQLAlchemy session object for accessing the database\n", "        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:\n        List[Comment] | None: a list of Comment objects representing the user's comments,\n        or None if no matching comments were found\n    \"\"\"\n\n    return db.query(Comment).filter(Comment.user_id == user_id).offset(skip).limit(limit).all()\n\n", "\n\nasync def get_comments_by_image_id(skip: int, limit: int, image_id: int, db: Session) -> List[Comment] | None:\n    \"\"\"\n    Gets all comments of the specified image from the database.\n\n    Arguments:\n        skip (int): number of comments to skip in the search\n        limit (int): maximum number of comments to retrieve\n        image_id (int): ID of the image to retrieve comments for", "        limit (int): maximum number of comments to retrieve\n        image_id (int): ID of the image to retrieve comments for\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:\n        List[Comment] | None: a list of Comment objects representing all comments,\n        or None if no matching comments were found\n    \"\"\"\n    return db.query(Comment).filter(Comment.image_id == image_id).offset(skip).limit(limit).all()\n", "    return db.query(Comment).filter(Comment.image_id == image_id).offset(skip).limit(limit).all()\n"]}
{"filename": "src/schemas/images.py", "chunked_list": ["from datetime import datetime\nfrom typing import Optional, List\n\nfrom pydantic import BaseModel, Field\nfrom src.schemas.tags import TagResponse\n\n\nclass ImageModel(BaseModel):\n    description: str = Field('description min_length 20 simbols', min_length=20, max_length=255)\n    tags_text: Optional[str] = Field(None, max_length=25)", "\n\nclass ImageResponse(BaseModel):\n    id: int\n    image_url: str\n    user_id: int\n    created_at: datetime\n    updated_at: Optional[datetime]\n    description: str\n    tags: List[TagResponse]\n\n    class Config:\n        orm_mode = True", "\n\nclass ImageTransformationModel(BaseModel):\n    id: int\n    transformation: str = \"standard\"\n"]}
{"filename": "src/schemas/ratings.py", "chunked_list": ["from pydantic import BaseModel\n\n\nclass AverageRatingResponse(BaseModel):\n    average_rating: float\n\n\nclass RatingModel(BaseModel):\n    rate: int\n", "\n\nclass RatingResponse(BaseModel):\n    id: int\n    rate: int\n    user_id: int\n    image_id: int\n\n    class Config:\n        orm_mode = True", "\n\n"]}
{"filename": "src/schemas/users.py", "chunked_list": ["from datetime import datetime\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass UserModel(BaseModel):\n    login: str = Field(min_length=4, max_length=12)\n    email: str = Field(min_length=4, max_length=120)\n    password_checksum: str = Field(min_length=6)", "\n\nclass UserResponse(BaseModel):\n    id: int\n    login: str\n    email: str\n    role: int\n    created_at: datetime\n    updated_at: Optional[datetime]\n    user_pic_url: Optional[str]\n    name: Optional[str]\n    is_active: bool\n    password_checksum: str\n    refresh_token: Optional[str]\n\n    class Config:\n        orm_mode = True", "\n\nclass UserChangeRole(BaseModel):\n    id: int\n    role: int\n    updated_at: Optional[datetime]\n\n    class Config:\n        orm_mode = True\n", "\n\nclass UserUpdate(BaseModel):\n    id: int\n    email: str\n    updated_at: Optional[datetime]\n    user_pic_url: Optional[str]\n    name: Optional[str]\n    password_checksum: str\n\n    class Config:\n        orm_mode = True", "\n\nclass UserUpdateAdmin(BaseModel):\n    id: int\n    login: str\n    email: str\n    role: int\n    updated_at: Optional[datetime]\n    user_pic_url: Optional[str]\n    name: Optional[str]\n    is_active: bool\n    password_checksum: str\n\n    class Config:\n        orm_mode = True", "\n\nclass UserShow(BaseModel):\n    id: int\n    login: str\n    email: str\n    role: int\n    user_pic_url: Optional[str]\n    name: Optional[str]\n    is_active: bool\n\n    class Config:\n        orm_mode = True", "\n\nclass UserDb(BaseModel):\n    id: int\n    email: str\n    created_at: datetime\n\n    class Config:\n        orm_mode = True\n", "\n\nclass TokenModel(BaseModel):\n    access_token: str\n    refresh_token: str\n    token_type: str = \"bearer\"\n"]}
{"filename": "src/schemas/tags.py", "chunked_list": ["from pydantic import BaseModel, Field\n\n\nclass TagModel(BaseModel):\n    tag_name: str = Field(max_length=30)\n\n\nclass TagResponse(BaseModel):\n    id: int\n    tag_name: str\n\n    class Config:\n        orm_mode = True", "\n\n"]}
{"filename": "src/schemas/comments.py", "chunked_list": ["from datetime import datetime\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass CommentBase(BaseModel):\n    comment_text: str = Field(max_length=1500)\n\n\nclass CommentResponse(BaseModel):\n    id: int\n    user_id: int\n    image_id: int\n    comment_text: str\n    created_at: datetime\n    updated_at: Optional[datetime]\n\n    class Config:\n        orm_mode = True", "\n\nclass CommentResponse(BaseModel):\n    id: int\n    user_id: int\n    image_id: int\n    comment_text: str\n    created_at: datetime\n    updated_at: Optional[datetime]\n\n    class Config:\n        orm_mode = True", "\n\n"]}
{"filename": "src/database/models.py", "chunked_list": ["import enum\n\nfrom sqlalchemy import Column, ForeignKey, String, Integer, DateTime, func, Boolean, Text, Table\nfrom sqlalchemy.orm import relationship, declarative_base\n\nBase = declarative_base()\n\n\ntag_to_image = Table('tag_to_image', Base.metadata,\n                     #Column('id', Integer, primary_key=True),", "tag_to_image = Table('tag_to_image', Base.metadata,\n                     #Column('id', Integer, primary_key=True),\n                     Column('tag_id', Integer, ForeignKey('tags.id', ondelete=\"CASCADE\"), nullable=False),\n                     Column('image_id', Integer, ForeignKey('images.id', ondelete=\"CASCADE\"), nullable=False),\n                     )\n\n\nclass UserRole(int, enum.Enum):\n    Admin = 1\n    Moderator = 2\n    User = 3", "\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True)\n    login = Column(String(50), unique=True)\n    email = Column(String(150), unique=True)\n    role = Column(Integer, default=UserRole.User.value)\n    created_at = Column('created_at', DateTime, default=func.now())\n    updated_at = Column('updated_at', DateTime, default=func.now())\n    user_pic_url = Column(String(255))\n    name = Column(String(150), unique=False)\n    is_active = Column(Boolean, default=True)\n    password_checksum = Column(String(255), nullable=False)\n    refresh_token = Column(String(255), nullable=True)", "\n\nclass Image(Base):\n    __tablename__ = \"images\"\n    id = Column(Integer, primary_key=True)\n    image_url = Column(String(255), unique=True, nullable=False)\n    user_id = Column(Integer, ForeignKey(User.id, ondelete=\"CASCADE\"))\n    created_at = Column('created_at', DateTime, default=func.now())\n    updated_at = Column('updated_at', DateTime, default=func.now())\n    description = Column(String(255))\n    is_deleted = Column(Boolean, default=False)\n    user = relationship('User', backref=\"images\")\n    tags = relationship(\"Tag\", secondary=tag_to_image, backref=\"images\", passive_deletes=True)", "\n\nclass Comment(Base):\n    __tablename__ = \"comments\"\n    id = Column(Integer, primary_key=True)\n    user_id = Column(Integer, ForeignKey(User.id, ondelete=\"CASCADE\"))\n    image_id = Column(Integer, ForeignKey(Image.id, ondelete=\"CASCADE\"))\n    created_at = Column('created_at', DateTime, default=func.now())\n    updated_at = Column('updated_at', DateTime)\n    comment_text = Column(Text)\n    user = relationship('User', backref=\"comments\")\n    image = relationship('Image', backref=\"comments\")", "\n\nclass Tag(Base):\n    __tablename__ = \"tags\"\n    id = Column(Integer, primary_key=True)\n    tag_name = Column(String(25), unique=True)\n\n\nclass Rating(Base):\n    __tablename__ = 'ratings'\n    id = Column(Integer, primary_key=True)\n    rate = Column(\"rate\", Integer, default=0)\n    user_id = Column(Integer, ForeignKey(User.id, ondelete=\"CASCADE\"))\n    image_id = Column(Integer, ForeignKey(Image.id, ondelete=\"CASCADE\"))\n    user = relationship('User', backref=\"ratings\")\n    image = relationship('Image', backref=\"ratings\")", "class Rating(Base):\n    __tablename__ = 'ratings'\n    id = Column(Integer, primary_key=True)\n    rate = Column(\"rate\", Integer, default=0)\n    user_id = Column(Integer, ForeignKey(User.id, ondelete=\"CASCADE\"))\n    image_id = Column(Integer, ForeignKey(Image.id, ondelete=\"CASCADE\"))\n    user = relationship('User', backref=\"ratings\")\n    image = relationship('Image', backref=\"ratings\")\n\n\nclass BlacklistToken(Base):\n    __tablename__ = 'blacklisted_tokens'\n    id = Column(Integer, primary_key=True)\n    token = Column(String(255), unique=True, nullable=False)\n    added_on = Column(DateTime, default=func.now())", "\n\nclass BlacklistToken(Base):\n    __tablename__ = 'blacklisted_tokens'\n    id = Column(Integer, primary_key=True)\n    token = Column(String(255), unique=True, nullable=False)\n    added_on = Column(DateTime, default=func.now())\n"]}
{"filename": "src/database/db.py", "chunked_list": ["\nfrom src.conf.config import settings\nfrom fastapi import HTTPException, status\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.exc import SQLAlchemyError\n\n\nSQLALCHEMY_DATABASE_URL = settings.sqlalchemy_database_url\nengine = create_engine(SQLALCHEMY_DATABASE_URL)", "SQLALCHEMY_DATABASE_URL = settings.sqlalchemy_database_url\nengine = create_engine(SQLALCHEMY_DATABASE_URL)\nDBSession = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n\n# Dependency\ndef get_db():\n    db = DBSession()\n    try:\n        yield db\n    except SQLAlchemyError as err_sql:\n        db.rollback()\n        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(err_sql))\n    finally:\n        db.close()", "\n"]}
{"filename": "src/services/cloud_image.py", "chunked_list": ["import hashlib\nimport re\nfrom io import BytesIO\nfrom uuid import uuid4\n\nimport qrcode\nimport cloudinary\nimport cloudinary.uploader\nfrom fastapi import HTTPException\nfrom starlette import status", "from fastapi import HTTPException\nfrom starlette import status\n\nfrom src.conf.config import settings\n\n\nclass CloudImage:\n    cloudinary.config(\n        cloud_name=settings.cloudinary_name,\n        api_key=settings.cloudinary_api_key,\n        api_secret=settings.cloudinary_api_secret,\n        secure=True\n    )\n\n    @staticmethod\n    def generate_name_image():\n        \"\"\"\n        The generate_name_image function generates a unique name for the image file.\n        It uses the uuid4 function to generate a random UUID, and then hashes it using SHA256.\n        The resulting hash is converted to hexadecimal format, and returned as a string.\n\n        Arguments:\n\n        Returns:\n            A string of the form &quot;photoshare/&lt;sha256 hash&gt;&quot;\n        \"\"\"\n        name = hashlib.sha256(str(uuid4()).encode('utf-8')).hexdigest()\n        return f\"photoshare/{name}\"\n    \n    @staticmethod\n    def generate_name_avatar(email: str):\n        \"\"\"\n        The generate_name_avatar function takes an email address as input and returns a unique avatar name.\n        The function uses the first 12 characters of the SHA256 hash of the email address to generate a unique string.\n        This string is then appended with &quot;web9/&quot; to create a valid S3 bucket key.\n\n        Arguments:\n            email (str): Specify the type of parameter that is expected to be passed into the function\n\n        Returns:\n            A string that is a combination of the prefix &quot;web9/&quot; and a 12-character hash of the email address\n        \"\"\"\n        name = hashlib.sha256(email.encode('utf-8')).hexdigest()[:12]\n        return f\"web9/{name}\"\n\n    @staticmethod\n    def upload(file, public_id: str, overwrite=True):\n        \"\"\"\n        The upload function takes a file and uploads it to the cloudinary server.\n            The public_id is the name of the file on cloudinary, and overwrite=True means that if there is already\n            a file with that name, it will be overwritten.\n\n        Arguments:\n            file (bite): Specify the file to be uploaded\n            public_id (str): Specify the public id of the image\n            overwrite (bool): Determine whether the image should be overwritten if it already exists\n\n        Returns:\n            A dictionary with the following keys\n        \"\"\"\n        r = cloudinary.uploader.upload(file, public_id=public_id, overwrite=overwrite)\n        return r\n    \n    @staticmethod\n    def get_url_for_avatar(public_id, r):\n        \"\"\"\n        The get_url_for_avatar function takes in a public_id and an r\n        (which is the result of a cloudinary.api.resource call)\n        and returns the URL for that avatar image, which will be used to display it on the page.\n\n        Arguments:\n            public_id (str): Identify the image in cloudinary\n            r: Get the version of the image\n\n        Returns:\n            A url of avatar\n        \"\"\"\n        src_url = cloudinary.CloudinaryImage(public_id) \\\n            .build_url(width=250, height=250, crop='fill', version=r.get('version'))\n        return src_url\n    \n    @staticmethod\n    def get_url_for_image(file_name):\n        \"\"\"\n        The get_url_for_image function takes a file name as an argument and returns the url for that image.\n        The function uses the cloudinary library to generate a url from the file name.\n\n        Arguments:\n            file_name (str): Specify the name of the file that is to be uploaded\n\n        Returns:\n            The url for the image\n        \"\"\"\n        src_url = cloudinary.utils.cloudinary_url(file_name)\n        return src_url[0]\n\n    @staticmethod\n    def get_transformation_image(public_id: str, transformation: str):\n        \"\"\"\n        The get_transformation_image function takes in a public_id and transformation string,\n            then returns the url of the transformed image. If no transformation is found, it returns None.\n\n        Arguments:\n            public_id (str): Get the public id of the image\n            transformation (str): Get the transformation name from the transformation class\n\n        Returns:\n            The url of the transformed image\n        \"\"\"\n        public_id = re.search(r'(?<=/v\\d/).+', public_id).group(0)\n        if transformation in Transformation.name.keys():\n            transformation_image_url = cloudinary.utils.cloudinary_url(public_id,\n                                                                       transformation=[Transformation.name.get(transformation)])[0]\n            return transformation_image_url\n\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Not Found\")\n\n    @staticmethod\n    async def create_qr_code_image(url: str):\n        \"\"\"\n        The create_qr_code_image function takes a URL and returns an image of the QR code for that URL.\n\n        Arguments:\n            url (str): Pass the url to be encoded into a qr code\n\n        Returns:\n            A bytesio object\n        \"\"\"\n        qr = qrcode.QRCode(\n            version=1,\n            error_correction=qrcode.constants.ERROR_CORRECT_L,\n            box_size=3,\n            border=4,\n        )\n        qr.add_data(url)\n        qr.make(fit=True)\n\n        img = qr.make_image(fill_color=\"black\", back_color=\"white\")\n\n        output = BytesIO()\n        img.save(output)\n        output.seek(0)\n        return output", "\n\nclass Standard:\n    name = \"standard\"\n    transformation = {\"width\": 500, \"height\": 500, \"gravity\": \"faces\", \"crop\": \"fill\"}\n\n\nclass Radius:\n    name = \"radius\"\n    transformation = {\"radius\": \"max\", \"width\": 500, \"height\": 500, \"gravity\": \"faces\", \"crop\": \"fill\"}", "\n\nclass Grayscale:\n    name = \"grayscale\"\n    transformation = {\"effect\": \"grayscale\", \"width\": 500, \"height\": 500, \"gravity\": \"faces\", \"crop\": \"fill\"}\n\n\nclass Cartoonify:\n    name = \"cartoonify\"\n    transformation = {\"effect\": \"cartoonify\", \"width\": 500, \"height\": 500, \"gravity\": \"faces\", \"crop\": \"fill\"}", "\n\nclass Vectorize:\n    name = \"vectorize\"\n    transformation = {\"effect\": \"vectorize:colors:2:detail:0.05\", \"width\": 500, \"height\": 500, \"gravity\": \"faces\", \"crop\": \"fill\"}\n\n\nclass Transformation:\n    \"\"\"\n    Transformation images cloudinary.\n    grayscale\n    cartoonify\n    radius\n    standard\n    vectorize\n    \"\"\"\n    name = {\n        \"grayscale\": Grayscale.transformation,\n        \"cartoonify\": Cartoonify.transformation,\n        \"radius\": Radius.transformation,\n        \"standard\": Standard.transformation,\n        \"vectorize\": Vectorize.transformation\n    }", ""]}
{"filename": "src/services/auth.py", "chunked_list": ["from datetime import datetime, timedelta\nfrom typing import Optional\n\nfrom fastapi import Depends, HTTPException, status\nfrom passlib.context import CryptContext\nfrom fastapi.security import OAuth2PasswordBearer  # Bearer token\nfrom sqlalchemy.orm import Session\nfrom jose import JWTError, jwt\n\nfrom src.database.db import get_db", "\nfrom src.database.db import get_db\nfrom src.repository import users as repository_users\nfrom src.conf.config import settings\n\n\nclass Auth:\n    pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n    SECRET_KEY = settings.secret_key\n    ALGORITHM = settings.algorithm\n    oauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/api/auth/login\")\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n\n    @classmethod\n    def token_decode(cls, token: str) -> dict:\n        \"\"\"\n            Try to decode the token\n\n        Arguments:\n            token (str): token to take decoded\n\n        Returns:\n            dict with results of decoded token\n        \"\"\"\n        try:\n            return jwt.decode(token, cls.SECRET_KEY, algorithms=[cls.ALGORITHM])\n        except JWTError:\n            raise cls.credentials_exception\n\n    @classmethod\n    async def create_access_token(cls, data: dict, expires_delta: Optional[float] = None) -> dict:\n        \"\"\"\n        The create_access_token function creates a new access token for the user.\n            The function takes in two arguments: data and expires_delta.\n            Data is a dictionary that contains all of the information about the user,\n            such as their username, email address, etc.\n            Expires_delta is an optional argument that specifies how long you want your access token to be valid\n            for (in seconds). If no value is specified then it defaults to 48 hours.\n\n        Arguments:\n            data (dict): A dictionary containing the user's id and username.\n            expires_delta (Optional[float]): The number of seconds until the token expires, defaults to None.\n\n        Returns:\n            A token that is encoded with the data, current time, expiry time and scope\n        \"\"\"\n        to_encode = data.copy()\n        if expires_delta:\n            expire = datetime.utcnow() + timedelta(seconds=expires_delta)\n        else:\n            expire = datetime.utcnow() + timedelta(hours=48)\n        to_encode.update({\"iat\": datetime.utcnow(), \"exp\": expire, \"scope\": \"access_token\"})\n        encoded_access_token = jwt.encode(to_encode, cls.SECRET_KEY, algorithm=cls.ALGORITHM)\n        return encoded_access_token\n\n    @classmethod\n    async def create_refresh_token(cls, data: dict, expires_delta: Optional[float] = None):\n        \"\"\"\n        The create_refresh_token function creates a refresh token for the user.\n\n        Arguments:\n            data (dict): A dictionary containing the user's id and username.\n            expires_delta (Optional[float]): Set the expiration time of the refresh token\n\n        Returns:\n            An encoded refresh token\n        \"\"\"\n        to_encode = data.copy()\n        if expires_delta:\n            expire = datetime.utcnow() + timedelta(seconds=expires_delta)\n        else:\n            expire = datetime.utcnow() + timedelta(days=7)\n        to_encode.update({\"iat\": datetime.utcnow(), \"exp\": expire, \"scope\": \"refresh_token\"})\n        encoded_refresh_token = jwt.encode(to_encode, cls.SECRET_KEY, algorithm=cls.ALGORITHM)\n        return encoded_refresh_token\n\n    @classmethod\n    async def get_current_user(cls, token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)):\n        \"\"\"\n        The get_current_user function is a dependency that will be used in the\n            protected endpoints. It takes a token as an argument and returns the user\n            if it's valid, or raises an exception otherwise.\n\n        Arguments:\n            token (str): Get the token from the request header\n            db (Session): SQLAlchemy session object for accessing the database\n\n        Returns:\n            A user object if the token is valid\n        \"\"\"\n\n        payload = cls.token_decode(token)\n        if payload.get(\"scope\") == \"access_token\":\n            email = payload.get(\"sub\")\n            if email is None:\n                raise cls.credentials_exception\n        else:\n            raise cls.credentials_exception\n        token_blacklisted = await repository_users.is_blacklisted_token(token, db)\n        if token_blacklisted:\n            raise cls.credentials_exception\n        user = await repository_users.get_user_by_email(email, db)\n        if user is None:\n            raise cls.credentials_exception\n        return user\n\n    @classmethod\n    async def decode_refresh_token(cls, refresh_token: str):\n        \"\"\"\n        The decode_refresh_token function is used to decode the refresh token.\n        It takes a refresh_token as an argument and returns the email of the user if it's valid.\n        If not, it raises an HTTPException with status code 401 (UNAUTHORIZED)\n        and detail 'Could not validate credentials'.\n\n        Arguments:\n            refresh_token (str): Pass the refresh token to the function\n\n        Returns:\n            The email of the user that is associated with the refresh token\n        \"\"\"\n        payload = cls.token_decode(refresh_token)\n        if payload['scope'] == 'refresh_token':\n            email = payload['sub']\n            return email\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail='Invalid scope for token')\n\n    @classmethod\n    def create_email_token(cls, data: dict):\n        \"\"\"\n        The create_email_token function takes a dictionary of data and returns a token.\n        The token is encoded with the SECRET_KEY, which is stored in the .env file.\n        The algorithm used to encode the token is also stored in the .env file.\n\n        Arguments:\n            data (dict): Pass in the data that will be encoded into the token\n\n        Returns:\n            A token that is encoded with the user's email and a secret key\n        \"\"\"\n        to_encode = data.copy()\n        expire = datetime.utcnow() + timedelta(hours=1)\n        to_encode.update({\"iat\": datetime.utcnow(), \"exp\": expire, \"scope\": \"email_token\"})\n        token = jwt.encode(to_encode, cls.SECRET_KEY, algorithm=cls.ALGORITHM)\n        return token\n\n    @classmethod\n    def get_email_from_token(cls, token: str):\n        \"\"\"\n        The get_email_from_token function takes a token as an argument and\n        returns the email associated with that token.\n        It does this by decoding the JWT using our SECRET_KEY and ALGORITHM,\n        then checking to make sure that it has a scope of 'email_token'.\n        If so, it returns the email address from the payload's sub field.\n        If not, it raises an HTTPException with status code 401 (Unauthorized)\n        and detail message &quot;Invalid scope for token&quot;.\n        If there is any other error in decoding or validating the JWT, we raise another\n        HTTPException with status code 422\n\n        Arguments:\n            token (str): Pass in the token that is sent to the user's email\n\n        Returns:\n            The email address associated with the token\n        \"\"\"\n        payload = cls.token_decode(token)\n        if payload['scope'] == 'email_token':\n            email = payload['sub']\n            return email\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail='Invalid scope for token')", "\n\nauth_service = Auth()\n"]}
{"filename": "src/services/roles.py", "chunked_list": ["from typing import List\n\nfrom fastapi import Depends, HTTPException, status, Request\n\nfrom src.database.models import User, UserRole\nfrom src.services.auth import auth_service\n\n\nclass RoleAccess:\n    def __init__(self, allowed_roles: List[UserRole]):\n        \"\"\"\n        The __init__ function is called when the class is instantiated.\n        It sets up the instance of the class, and takes in any arguments that are required to do so.\n        In this case, we're taking in a list of allowed roles.\n\n        Arguments:\n            allowed_roles (List[UserRole]): Create a list of roles that are allowed to use the command\n\n        Returns:\n            None\n        \"\"\"\n        self.allowed_roles = allowed_roles\n\n    async def __call__(self, request: Request, current_user: User = Depends(auth_service.get_current_user)):\n        \"\"\"\n        The __call__ function is the function that will be called when a user tries to access an endpoint.\n        It takes in two arguments: request and current_user. The request argument is the Request object, which contains\n        information about the HTTP request made by a client (e.g., headers, body).\n        The current_user argument is provided by Depends(auth_service.get_current_user), which means it will call\n        auth_service's getCurrentUser() function and pass its return value as an argument to __call__.\n\n        Arguments:\n            current_user (User): Get the current user from the auth_service\n            request (Request): Get the request object\n\n        Returns:\n            The decorated function\n        \"\"\"\n        if current_user.role not in self.allowed_roles:\n            raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail='Operation forbidden')", "class RoleAccess:\n    def __init__(self, allowed_roles: List[UserRole]):\n        \"\"\"\n        The __init__ function is called when the class is instantiated.\n        It sets up the instance of the class, and takes in any arguments that are required to do so.\n        In this case, we're taking in a list of allowed roles.\n\n        Arguments:\n            allowed_roles (List[UserRole]): Create a list of roles that are allowed to use the command\n\n        Returns:\n            None\n        \"\"\"\n        self.allowed_roles = allowed_roles\n\n    async def __call__(self, request: Request, current_user: User = Depends(auth_service.get_current_user)):\n        \"\"\"\n        The __call__ function is the function that will be called when a user tries to access an endpoint.\n        It takes in two arguments: request and current_user. The request argument is the Request object, which contains\n        information about the HTTP request made by a client (e.g., headers, body).\n        The current_user argument is provided by Depends(auth_service.get_current_user), which means it will call\n        auth_service's getCurrentUser() function and pass its return value as an argument to __call__.\n\n        Arguments:\n            current_user (User): Get the current user from the auth_service\n            request (Request): Get the request object\n\n        Returns:\n            The decorated function\n        \"\"\"\n        if current_user.role not in self.allowed_roles:\n            raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail='Operation forbidden')"]}
{"filename": "src/services/tags.py", "chunked_list": ["from typing import List\n\nfrom src.database.models import Tag\n\n\ndef create_transformation_tags(tags: List[Tag]) -> str:\n    \"\"\"\n    create tag for transformation operations\n\n    Arguments:\n        tags (List[Tag]): list tag objects for write tag strings\n\n    Returns:\n        List[Tag]: tag strings for new image\n    \"\"\"\n    tags_in_text = f\"#\"\n    for tag in tags:\n        tags_in_text += tag.tag_name\n\n    return tags_in_text", ""]}
{"filename": "src/conf/config.py", "chunked_list": ["from pydantic import BaseSettings\n\n\nclass Settings(BaseSettings):\n    sqlalchemy_database_url: str = 'postgresql+psycopg2://user:password@server:5432/database'\n    secret_key: str = 'secret'\n    algorithm: str = 'HS256'\n    cloudinary_name: str = 'name'\n    cloudinary_api_key: str = 'key'\n    cloudinary_api_secret: str = 'secret'\n\n    class Config:\n        env_file = \".env\"\n        env_file_encoding = \"utf-8\"", "\n\nsettings = Settings()\n"]}
{"filename": "src/routes/images.py", "chunked_list": ["from typing import List\n\nfrom fastapi import Depends, HTTPException, status, Path, APIRouter, Query, UploadFile, File, Form\nfrom sqlalchemy.orm import Session\nfrom starlette.responses import StreamingResponse\nfrom pydantic import ValidationError\n\nfrom src.database.db import get_db\nfrom src.database.models import User, UserRole\nfrom src.schemas.images import ImageModel, ImageResponse, ImageTransformationModel", "from src.database.models import User, UserRole\nfrom src.schemas.images import ImageModel, ImageResponse, ImageTransformationModel\nfrom src.repository import images as repository_images\nfrom src.services.cloud_image import CloudImage\nfrom src.services.auth import auth_service\nfrom src.services.roles import RoleAccess\nfrom src.services.tags import create_transformation_tags\n\nrouter = APIRouter(prefix=\"/images\", tags=['images'])\n", "router = APIRouter(prefix=\"/images\", tags=['images'])\n\nallowed_operation_get = RoleAccess([UserRole.Admin, UserRole.Moderator, UserRole.User])\nallowed_operation_post = RoleAccess([UserRole.Admin, UserRole.Moderator, UserRole.User])\nallowed_operation_patch = RoleAccess([UserRole.Admin, UserRole.Moderator, UserRole.User])\nallowed_operation_put = RoleAccess([UserRole.Admin, UserRole.Moderator])\nallowed_operation_delete = RoleAccess([UserRole.Admin])\n\n\n@router.post(\"/\", response_model=ImageResponse, dependencies=[Depends(allowed_operation_post)],", "\n@router.post(\"/\", response_model=ImageResponse, dependencies=[Depends(allowed_operation_post)],\n             status_code=status.HTTP_201_CREATED)\nasync def create_image(description: str = Form(),\n                       tags_text: str = Form(None),\n                       image_file: UploadFile = File(),\n                       current_user: User = Depends(auth_service.get_current_user),\n                       db: Session = Depends(get_db)):\n\n    \"\"\"", "\n    \"\"\"\n    The create_image function creates a new image in the database.\n\n    Arguments:\n        description (str): Get the description from the request body\n        tags_text (str): Get the tags from the request body\n        image_file (UploadFile): Get the file from the request\n        current_user (User): the current user\n        db (Session): SQLAlchemy session object for accessing the database", "        current_user (User): the current user\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:\n        Image: the Image object\n    \"\"\"\n    try:\n        body = ImageModel(description=description, tags_text=tags_text)\n    except ValidationError:\n        raise HTTPException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=\"UNPROCESSABLE_ENTITY\")", "    file_name = CloudImage.generate_name_image()\n    CloudImage.upload(image_file.file, file_name, overwrite=False)\n    image_url = CloudImage.get_url_for_image(file_name)\n    image = await repository_images.create(body, image_url, current_user, db)\n    return image\n\n\n@router.post(\"/transformation\", response_model=ImageResponse, dependencies=[Depends(allowed_operation_post)],\n             status_code=status.HTTP_201_CREATED)\nasync def create_transformation_image(body: ImageTransformationModel,", "             status_code=status.HTTP_201_CREATED)\nasync def create_transformation_image(body: ImageTransformationModel,\n                                      current_user: User = Depends(auth_service.get_current_user),\n                                      db: Session = Depends(get_db)):\n\n    \"\"\"\n    The create_transformation_image function creates a new image in the database.\n        The function takes an ImageTransformationModel object as input, which contains the id of the original image and\n        transformation to be applied on it. It then uses CloudImage class to get a url for transformed image\n        from cloudinary, checks if there is already an entry with that url in database and if not creates one.", "        transformation to be applied on it. It then uses CloudImage class to get a url for transformed image\n        from cloudinary, checks if there is already an entry with that url in database and if not creates one.\n        Input examples ->\"standard\" or \"radius\" or \"grayscale\" or \"cartoonify\" or \"vectorize\".\n\n    Arguments:\n        body (ImageTransformationModel): Get the id of the image that is to be transformed\n        current_user (User): the current user\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:", "\n    Returns:\n        Image: new image with the transformation applied\n    \"\"\"\n    image = await repository_images.get_image_from_id(body.id, current_user, db)\n    if not image:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Not Found\")\n    transformation_image_url = CloudImage.get_transformation_image(image.image_url, body.transformation)\n\n    tags_in_text = None\n    if len(image.tags) > 0:\n        tags_in_text = create_transformation_tags(image.tags)", "\n    tags_in_text = None\n    if len(image.tags) > 0:\n        tags_in_text = create_transformation_tags(image.tags)\n\n    body = ImageModel(description=image.description, tags_text=tags_in_text)\n    image_in_db = await repository_images.get_image_from_url(transformation_image_url, current_user, db)\n    if image_in_db:\n        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=\"Resource already exists\")\n    new_image = await repository_images.create(body, transformation_image_url, current_user, db)", "    new_image = await repository_images.create(body, transformation_image_url, current_user, db)\n    return new_image\n\n\n@router.get(\"/\", response_model=List[ImageResponse], dependencies=[Depends(allowed_operation_get)])\nasync def get_images(limit: int = Query(10, le=50), offset: int = 0,\n                     current_user: User = Depends(auth_service.get_current_user),\n                     db: Session = Depends(get_db)):\n    \"\"\"\n    The get_images function returns a list of images.", "    \"\"\"\n    The get_images function returns a list of images.\n\n    Arguments:\n        limit (int): Limit the number of images returned\n        offset (int): Specify the number of records to skip before returning results\n        current_user (User): the current user\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:", "\n    Returns:\n        List[Image]: A list of images\n    \"\"\"\n    images = await repository_images.get_images(limit, offset, current_user, db)\n    if images is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Not Found\")\n    return images\n\n", "\n\n@router.get(\"/{image_id}\", response_model=ImageResponse, dependencies=[Depends(allowed_operation_get)])\nasync def get_image(image_id: int = Path(ge=1),\n                    current_user: User = Depends(auth_service.get_current_user),\n                    db: Session = Depends(get_db)):\n    \"\"\"\n    The get_images function is a GET request that returns the image with the given ID.\n    The function takes an optional image_id parameter, which defaults to 1 if not provided.\n    It also takes a current_user parameter, which is obtained from auth_service and db parameters,", "    The function takes an optional image_id parameter, which defaults to 1 if not provided.\n    It also takes a current_user parameter, which is obtained from auth_service and db parameters,\n    which are obtained from get_db.\n\n    Arguments:\n        image_id (int): Specify the id of the image that is being requested\n        current_user (User): the current user\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:", "\n    Returns:\n        Image: image\n    \"\"\"\n    image = await repository_images.get_image(image_id, current_user, db)\n    if image is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Not Found\")\n    return image\n\n", "\n\n@router.delete(\"/{image_id}\", status_code=status.HTTP_204_NO_CONTENT, dependencies=[Depends(allowed_operation_delete)])\nasync def remove_image(image_id: int = Path(ge=1),\n                       current_user: User = Depends(auth_service.get_current_user),\n                       db: Session = Depends(get_db)):\n    \"\"\"\n    The remove_image function removes an image from the database.\n\n    Arguments:", "\n    Arguments:\n        image_id (int): Specify the id of the image to be removed\n        current_user (User): the current user\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:\n        None: The image that was removed\n    \"\"\"\n    image = await repository_images.remove(image_id, current_user, db)\n    if image is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Not Found\")", "    \"\"\"\n    image = await repository_images.remove(image_id, current_user, db)\n    if image is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Not Found\")\n    return None\n\n\n@router.patch(\"/description/{image_id}\", response_model=ImageResponse, dependencies=[Depends(allowed_operation_patch)])\nasync def update_description_image(body: ImageModel,\n                                   image_id: int = Path(ge=1),", "async def update_description_image(body: ImageModel,\n                                   image_id: int = Path(ge=1),\n                                   current_user: User = Depends(auth_service.get_current_user),\n                                   db: Session = Depends(get_db)):\n    \"\"\"\n    The update_description_image function updates the description of an image.\n        The function takes in a body, which is an ImageModel object, and an image_id.\n        It also takes in a current_user and db objects as dependencies.\n\n    Arguments:", "\n    Arguments:\n        body (ImageModel): Get the new description for the image\n        image_id (int): Get the image id from the path\n        current_user (User): the current user\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:\n        Image: The updated image\n    \"\"\"", "        Image: The updated image\n    \"\"\"\n    image = await repository_images.change_description(body, image_id, current_user, db)\n    if image is None or image.is_deleted is True:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Not Found\")\n    return image\n\n\n@router.post(\"/generate_qrcode/{image_id}\", dependencies=[Depends(allowed_operation_post)])\nasync def generate_qrcode(image_id: int = Path(ge=1),", "@router.post(\"/generate_qrcode/{image_id}\", dependencies=[Depends(allowed_operation_post)])\nasync def generate_qrcode(image_id: int = Path(ge=1),\n                          current_user: User = Depends(auth_service.get_current_user),\n                          db: Session = Depends(get_db)):\n    \"\"\"\n    The generate_qrcode function generates a QR code for the image with the given ID.\n\n    Arguments:\n        image_id (int): Get the image id from the path\n        current_user (User): the current user", "        image_id (int): Get the image id from the path\n        current_user (User): the current user\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:\n        image/png: streamingresponse\n    \"\"\"\n    image = await repository_images.get_image(image_id, current_user, db)\n    if image is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Not Found\")", "    if image is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Not Found\")\n    qr_code = await CloudImage.create_qr_code_image(image.image_url)\n    if qr_code is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Not Found\")\n    return StreamingResponse(qr_code, media_type=\"image/png\", status_code=status.HTTP_201_CREATED)\n"]}
{"filename": "src/routes/ratings.py", "chunked_list": ["from typing import List\nfrom fastapi import APIRouter, Depends, Path, status, HTTPException\n\nfrom src.database.models import User, UserRole\nfrom src.repository import ratings as repository_ratings\nfrom src.schemas.ratings import RatingResponse, AverageRatingResponse\nfrom src.schemas.images import ImageResponse\nfrom sqlalchemy.orm import Session\nfrom src.database.db import get_db\nfrom src.services.auth import auth_service", "from src.database.db import get_db\nfrom src.services.auth import auth_service\nfrom src.services.roles import RoleAccess\n\nrouter = APIRouter(prefix='/rating', tags=['ratings'])\n\nallowed_operation_get = RoleAccess([UserRole.Admin, UserRole.Moderator, UserRole.User])\nallowed_operation_post = RoleAccess([UserRole.Admin, UserRole.Moderator, UserRole.User])\nallowed_operation_put = RoleAccess([UserRole.Admin, UserRole.Moderator])\nallowed_operation_delete = RoleAccess([UserRole.Admin, UserRole.Moderator])", "allowed_operation_put = RoleAccess([UserRole.Admin, UserRole.Moderator])\nallowed_operation_delete = RoleAccess([UserRole.Admin, UserRole.Moderator])\n\n\n@router.post(\"/{image_id}/{rate}\", response_model=RatingResponse, dependencies=[Depends(allowed_operation_post)])\nasync def create_rate(image_id: int, rate: int = Path(description=\"From one to five stars of rating.\", ge=1, le=5),\n                      db: Session = Depends(get_db), current_user: User = Depends(auth_service.get_current_user)):\n    \"\"\"\n    The create_rate function creates a new rate for the image with the given ID. The function takes in an integer\n    value from 1 to 5, and returns a JSON object containing information about the newly created rate.", "    The create_rate function creates a new rate for the image with the given ID. The function takes in an integer\n    value from 1 to 5, and returns a JSON object containing information about the newly created rate.\n\n    Arguments:\n        image_id (int): rate id to be rated.\n        rate (int): value from 1 to 5\n        current_user (User): the current user\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:", "\n    Returns:\n        Rate: The new rate object\n    \"\"\"\n    new_rate = await repository_ratings.create_rate(image_id, rate, db, current_user)\n    if new_rate is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Not found\")\n    return new_rate\n\n", "\n\n@router.delete(\"/delete/{rate_id}\", status_code=status.HTTP_204_NO_CONTENT, dependencies=[Depends(allowed_operation_delete)])\nasync def delete_rate(rate_id: int, db: Session = Depends(get_db),\n                      current_user: User = Depends(auth_service.get_current_user)):\n    \"\"\"\n    The delete_rate function deletes a rate from the database.\n        The function takes in an integer, which is the id of the rate to be deleted.\n        It also takes in a Session object and a User object as parameters,\n        which are used to access and delete data from the database.", "        It also takes in a Session object and a User object as parameters,\n        which are used to access and delete data from the database.\n\n    Arguments:\n        rate_id (int): rate id to be removed\n        current_user (User): the current user\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:\n        None", "    Returns:\n        None\n    \"\"\"\n    deleted_rate = await repository_ratings.delete_rate(rate_id, db, current_user)\n    if deleted_rate is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Rate not found or not available.\")\n    return deleted_rate\n\n\n@router.get(\"/show_image_rating/{image_id}\", response_model=AverageRatingResponse)", "\n@router.get(\"/show_image_rating/{image_id}\", response_model=AverageRatingResponse)\nasync def calculate_rating(image_id: int, db: Session = Depends(get_db),\n                           current_user: User = Depends(auth_service.get_current_user)):\n    \"\"\"\n    The calculate_rating function calculate an average rating of the image.\n        The function takes in an integer, which is the id of the image.\n        It also takes in a Session object and a User object as parameters,\n        which are used to access data from the database.\n", "        which are used to access data from the database.\n\n    Arguments:\n        image_id (int): Get the image_id from the url\n        current_user (User): the current user\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:\n        dict: An average rating object\n    \"\"\"", "        dict: An average rating object\n    \"\"\"\n    average_rate = await repository_ratings.calculate_rating(image_id, db, current_user)\n    if average_rate is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Rating not found or not available.\")\n    return {\"average_rating\": average_rate}\n\n\n@router.get(\"/show_images_by_rating\", response_model=List[ImageResponse])\nasync def show_images_by_rating(to_decrease: bool, db: Session = Depends(get_db),", "@router.get(\"/show_images_by_rating\", response_model=List[ImageResponse])\nasync def show_images_by_rating(to_decrease: bool, db: Session = Depends(get_db),\n                            current_user: User = Depends(auth_service.get_current_user)):\n    \"\"\"\n    The show_images_by_rating function show all images, sorted by rating.\n        The function takes a boolean value that indicates the direction of sorting, \n        to increase the rating or to decrease it.\n        It also takes in a Session object and a User object as parameters,\n        which are used to access data from the database.\n", "        which are used to access data from the database.\n\n    Arguments:\n        to_decrease (bool): Indicates the direction of sorting.\n        current_user (User): the current user\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:\n        List[Image]: A list of Images objects, sorted by rating\n    \"\"\"", "        List[Image]: A list of Images objects, sorted by rating\n    \"\"\"\n    images_by_rating = await repository_ratings.show_images_by_rating(to_decrease, db, current_user)\n    if images_by_rating is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Images not found or not available.\")\n    return images_by_rating\n"]}
{"filename": "src/routes/auth.py", "chunked_list": ["from fastapi import Depends, HTTPException, status, APIRouter, Security, Request\nfrom fastapi.security import HTTPAuthorizationCredentials, HTTPBearer, OAuth2PasswordRequestForm\nfrom sqlalchemy.orm import Session\n\nfrom src.database.db import get_db\nfrom src.schemas.users import UserModel, UserResponse, TokenModel\nfrom src.repository import users as repository_users\nfrom src.services.auth import auth_service\n\nrouter = APIRouter(prefix=\"/auth\", tags=['auth'])", "\nrouter = APIRouter(prefix=\"/auth\", tags=['auth'])\nsecurity = HTTPBearer()\n\n\n@router.post(\"/signup\", response_model=UserResponse, status_code=status.HTTP_201_CREATED)\nasync def signup(body: UserModel, request: Request, db: Session = Depends(get_db)):\n    \"\"\"\n    The signup function creates a new user in the database.\n        It takes a UserModel object as input, which is validated by pydantic.", "    The signup function creates a new user in the database.\n        It takes a UserModel object as input, which is validated by pydantic.\n        The password is hashed using bcrypt and stored in the database.\n        A background task sends an email to the user with their username.\n\n    Arguments:\n        body (UserModel): Pass the data from the request body to the function\n        db (Session): SQLAlchemy session object for accessing the database\n        request (Request): Get the base_url of the application\n", "        request (Request): Get the base_url of the application\n\n    Returns:\n        User: The created user\n    \"\"\"\n    exist_user = await repository_users.get_user_by_email(body.email, db)\n    if exist_user:\n        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=\"Account already exists\")\n    body.password_checksum = auth_service.pwd_context.hash(body.password_checksum)\n    new_user = await repository_users.create_user(body, db)", "    body.password_checksum = auth_service.pwd_context.hash(body.password_checksum)\n    new_user = await repository_users.create_user(body, db)\n    return new_user\n\n\n@router.post(\"/login\", response_model=TokenModel)\nasync def login(body: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)):\n    \"\"\"\n    The login function is used to authenticate a user.\n        It takes the username and password from the request body,", "    The login function is used to authenticate a user.\n        It takes the username and password from the request body,\n        verifies them against the database, and returns an access token if successful.\n\n    Arguments:\n        body (OAuth2PasswordRequestForm): Get the token from the request header\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:\n        dict: JSON access_token / refresh_token / token_type", "    Returns:\n        dict: JSON access_token / refresh_token / token_type\n    \"\"\"\n    user = await repository_users.get_user_by_email(body.username, db)\n    if user is None:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Invalid email\")\n    if not user.is_active:\n        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=\"User is inactive\")\n    if not auth_service.pwd_context.verify(body.password, user.password_checksum):\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Invalid password\")", "    if not auth_service.pwd_context.verify(body.password, user.password_checksum):\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Invalid password\")\n    # Generate JWT\n    access_token = await auth_service.create_access_token(data={\"sub\": user.email})\n    refresh_token = await auth_service.create_refresh_token(data={\"sub\": user.email})\n    await repository_users.update_token(user, refresh_token, db)\n    return {\"access_token\": access_token, \"refresh_token\": refresh_token, \"token_type\": \"bearer\"}\n\n\n@router.post(\"/logout\")", "\n@router.post(\"/logout\")\nasync def logout(credentials: HTTPAuthorizationCredentials = Security(security),\n                 db: Session = Depends(get_db),\n                 current_user: UserModel = Depends(auth_service.get_current_user)):\n    \"\"\"\n    The logout function is used to logout a user.\n    It takes the credentials,\n    add access token to blacklist, and returns massage.\n", "    add access token to blacklist, and returns massage.\n\n    Arguments:\n        credentials (HTTPAuthorizationCredentials): Get the token from the request header\n        db (Session): SQLAlchemy session object for accessing the database\n        current_user (UserModel): the current user\n\n    Returns:\n        dict: JSON message\n    \"\"\"", "        dict: JSON message\n    \"\"\"\n    token = credentials.credentials\n\n    await repository_users.add_to_blacklist(token, db)\n    return {\"message\": \"USER_IS_LOGOUT\"}\n\n\n@router.get('/refresh_token', response_model=TokenModel)\nasync def refresh_token(credentials: HTTPAuthorizationCredentials = Security(security), db: Session = Depends(get_db)):", "@router.get('/refresh_token', response_model=TokenModel)\nasync def refresh_token(credentials: HTTPAuthorizationCredentials = Security(security), db: Session = Depends(get_db)):\n    \"\"\"\n    The refresh_token function is used to refresh the access token.\n        The function takes in a refresh token and returns an access_token, a new refresh_token, and the type of token.\n        If the user's current refresh_token does not match what was\n            passed into this function then it will return an error.\n\n    Arguments:\n        credentials (HTTPAuthorizationCredentials): Get the token from the request header", "    Arguments:\n        credentials (HTTPAuthorizationCredentials): Get the token from the request header\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:\n        dict: JSON access_token - refresh_token - token_type\n    \"\"\"\n    token = credentials.credentials\n    email = await auth_service.decode_refresh_token(token)\n    user = await repository_users.get_user_by_email(email, db)\n    if user.refresh_token != token:\n        await repository_users.update_token(user, None, db)\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Invalid refresh token\")", "    email = await auth_service.decode_refresh_token(token)\n    user = await repository_users.get_user_by_email(email, db)\n    if user.refresh_token != token:\n        await repository_users.update_token(user, None, db)\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Invalid refresh token\")\n\n    access_token = await auth_service.create_access_token(data={\"sub\": email})\n    refresh_token = await auth_service.create_refresh_token(data={\"sub\": email})\n    await repository_users.update_token(user, refresh_token, db)\n    return {\"access_token\": access_token, \"refresh_token\": refresh_token, \"token_type\": \"bearer\"}", "    await repository_users.update_token(user, refresh_token, db)\n    return {\"access_token\": access_token, \"refresh_token\": refresh_token, \"token_type\": \"bearer\"}\n"]}
{"filename": "src/routes/users.py", "chunked_list": ["from fastapi import APIRouter, Depends, status, UploadFile, File, HTTPException\nfrom sqlalchemy.orm import Session\n\nfrom src.database.db import get_db\nfrom src.database.models import User, UserRole, BlacklistToken\nfrom src.repository import users as repository_users\nfrom src.services.auth import auth_service\nfrom src.schemas.users import UserResponse, UserChangeRole, UserUpdate, UserUpdateAdmin, UserShow\nfrom src.services.cloud_image import CloudImage\nfrom src.services.roles import RoleAccess", "from src.services.cloud_image import CloudImage\nfrom src.services.roles import RoleAccess\n\nrouter = APIRouter(prefix=\"/users\", tags=[\"users\"])\n\nallowed_operation_get = RoleAccess([UserRole.Admin, UserRole.Moderator, UserRole.User])\nallowed_operation_post = RoleAccess([UserRole.Admin, UserRole.Moderator, UserRole.User])\nallowed_operation_put = RoleAccess([UserRole.Admin, UserRole.Moderator])\nallowed_operation_delete = RoleAccess([UserRole.Admin])\n", "allowed_operation_delete = RoleAccess([UserRole.Admin])\n\n@router.get(\"/me/\", response_model=UserResponse)\nasync def read_users_me(current_user: User = Depends(auth_service.get_current_user)):\n    \"\"\"\n    The read_users_me function is a GET request that returns the current user's information.\n        It requires authentication, and it uses the auth_service to get the current user.\n\n    Arguments:\n        current_user (User): the current user attempting to delete the comment", "    Arguments:\n        current_user (User): the current user attempting to delete the comment\n\n    Returns:\n        User: The current user object\n    \"\"\"\n    return current_user\n\n\n@router.patch('/avatar', response_model=UserResponse)", "\n@router.patch('/avatar', response_model=UserResponse)\nasync def update_avatar_user(file: UploadFile = File(), current_user: User = Depends(auth_service.get_current_user),\n                             db: Session = Depends(get_db)):\n    \"\"\"\n    The update_avatar_user function updates the avatar of a user.\n\n    Arguments:\n        file (UploadFile): object with new role\n        current_user (User): the current user", "        file (UploadFile): object with new role\n        current_user (User): the current user\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:\n        User: object after the change operation\n    \"\"\"\n    public_id = CloudImage.generate_name_avatar(current_user.email)\n    r = CloudImage.upload(file.file, public_id)\n    src_url = CloudImage.get_url_for_avatar(public_id, r)", "    r = CloudImage.upload(file.file, public_id)\n    src_url = CloudImage.get_url_for_avatar(public_id, r)\n    user = await repository_users.update_avatar(current_user.email, src_url, db)\n    return user\n\n\n@router.put(\"/update_user\", response_model=UserUpdate)\nasync def update_user(\n        body: UserUpdate,\n        user: User = Depends(auth_service.get_current_user),", "        body: UserUpdate,\n        user: User = Depends(auth_service.get_current_user),\n        db: Session = Depends(get_db)):\n    \"\"\"\n    Update user\n\n    Arguments:\n        body (UserUpdate): object with new role\n        user (User): the current user\n        db (Session): SQLAlchemy session object for accessing the database", "        user (User): the current user\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:\n        User: object after the change operation\n    \"\"\"\n    user = await repository_users.update_user(body, user, db)\n    if user is None:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND, detail=\"NOT_FOUND\")", "    return user\n\n\n@router.put(\"/update_user_by_admin\", response_model=UserUpdateAdmin, dependencies=[Depends(allowed_operation_put)])\nasync def update_user_by_admin(\n        body: UserUpdateAdmin,\n        user: User = Depends(auth_service.get_current_user),\n        db: Session = Depends(get_db)):\n    \"\"\"\n    Update user just for admin access", "    \"\"\"\n    Update user just for admin access\n\n    Arguments:\n        body (UserUpdateAdmin): object with new role\n        user (User): the current user\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:\n        User: object after the change operation", "    Returns:\n        User: object after the change operation\n    \"\"\"\n    user = await repository_users.update_user_by_admin(body, user, db)\n    if user is None:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND, detail=\"NOT_FOUND\")\n    return user\n\n", "\n\n@router.put(\"/change_role\", response_model=UserChangeRole, dependencies=[Depends(allowed_operation_put)])\nasync def change_role(body: UserChangeRole,\n                      user: User = Depends(auth_service.get_current_user),\n                      db: Session = Depends(get_db)):\n    \"\"\"\n    Change the role of a user\n\n    Arguments:", "\n    Arguments:\n        body (UserChangeRole): object with new role\n        user (User): the current user\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:\n        User: object after the change operation\n    \"\"\"\n    user = await repository_users.change_role(body, user, db)\n    if user is None:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND, detail=\"NOT_FOUND\")", "    \"\"\"\n    user = await repository_users.change_role(body, user, db)\n    if user is None:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND, detail=\"NOT_FOUND\")\n    return user\n\n\n@router.put(\"/ban_user\", response_model=UserResponse, dependencies=[Depends(allowed_operation_put)])\nasync def ban_user(user_id: int, db: Session = Depends(get_db)):", "@router.put(\"/ban_user\", response_model=UserResponse, dependencies=[Depends(allowed_operation_put)])\nasync def ban_user(user_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Take user to ban list\n\n    Arguments:\n        user_id (int): Get the username from the url path\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:", "\n    Returns:\n        User: banned user\n    \"\"\"\n    ban = await repository_users.ban_user(user_id, db)\n    if ban is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"NOT_FOUND\")\n    return ban\n\n", "\n\n@router.get(\"/user/{login}\", response_model=UserShow)\nasync def read_user_profile_by_username(login: str, db: Session = Depends(get_db),\n                                        current_user: User = Depends(auth_service.get_current_user)):\n    \"\"\"\n    The function takes in the login as an argument and returns the user profile if it exists.\n\n    Arguments:\n        login (str): Get the username from the url path", "    Arguments:\n        login (str): Get the username from the url path\n        db (Session): SQLAlchemy session object for accessing the database\n        current_user (User): the current user\n\n    Returns:\n        User: A userprofile object\n    \"\"\"\n    user_profile = await repository_users.get_user_profile(login, db)\n    if user_profile is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"NOT_FOUND\")", "    user_profile = await repository_users.get_user_profile(login, db)\n    if user_profile is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"NOT_FOUND\")\n    return user_profile\n"]}
{"filename": "src/routes/tags.py", "chunked_list": ["from typing import List\n\nfrom fastapi import APIRouter, Depends, status, HTTPException, Path\n\nfrom src.database.models import UserRole\nfrom src.repository import tags as repository_tag\nfrom src.schemas.tags import TagResponse, TagModel\nfrom src.schemas.images import ImageResponse\nfrom sqlalchemy.orm import Session\nfrom src.database.db import get_db", "from sqlalchemy.orm import Session\nfrom src.database.db import get_db\nfrom src.services.roles import RoleAccess\n\nrouter = APIRouter(prefix='/tag', tags=['tags'])\n\nallowed_operation_get = RoleAccess([UserRole.Admin, UserRole.Moderator, UserRole.User])\nallowed_operation_post = RoleAccess([UserRole.Admin, UserRole.Moderator, UserRole.User])\nallowed_operation_put = RoleAccess([UserRole.Admin, UserRole.Moderator])\nallowed_operation_delete = RoleAccess([UserRole.Admin])", "allowed_operation_put = RoleAccess([UserRole.Admin, UserRole.Moderator])\nallowed_operation_delete = RoleAccess([UserRole.Admin])\n\n\n@router.post(\"/{tags_string}\", response_model=List[TagResponse], dependencies=[Depends(allowed_operation_post)],\n             status_code=status.HTTP_201_CREATED)\nasync def create_tags(tags_string: str, db: Session = Depends(get_db)):\n    \"\"\"\n    create new tag from string find # and separated by spaces\n", "    create new tag from string find # and separated by spaces\n\n    Arguments:\n        tags_string (str): string to parse\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:\n        List[Tag]: new tags list\n    \"\"\"\n    tag = await repository_tag.create_tags(tags_string, db)", "    \"\"\"\n    tag = await repository_tag.create_tags(tags_string, db)\n    return tag\n\n\n@router.get(\"/image/{tag_name}\", response_model=List[ImageResponse], dependencies=[Depends(allowed_operation_get)])\nasync def get_images_by_tag(tag_name: str, limit: int = 10, offset: int = 0, db: Session = Depends(get_db)):\n    \"\"\"\n    route to get images by tag name\n", "    route to get images by tag name\n\n    Arguments:\n        offset (int): number of tags to skip in the search\n        limit (int): maximum number of tags to retrieve\n        tag_name (str): tag name to found\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:\n        List[Image] | None: a list of Image or None if no matching tag were found", "    Returns:\n        List[Image] | None: a list of Image or None if no matching tag were found\n    \"\"\"\n    tag = await repository_tag.get_images_by_tag(tag_name, limit, offset, db)\n    if tag is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail='Not found')\n    return tag\n\n\n@router.get(\"/{tag_name}\", response_model=TagResponse, dependencies=[Depends(allowed_operation_get)])", "\n@router.get(\"/{tag_name}\", response_model=TagResponse, dependencies=[Depends(allowed_operation_get)])\nasync def get_one(tag_name: str, db: Session = Depends(get_db)):\n    \"\"\"\n    route to get tag object by tag name\n\n    Arguments:\n        tag_name (str): tag name to found\n        db (Session): SQLAlchemy session object for accessing the database\n", "        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:\n        Tag | None: Tag or None if no matching tag were found\n    \"\"\"\n    tag = await repository_tag.find_tag(tag_name, db)\n    if tag is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail='Not found')\n    return tag\n", "    return tag\n\n\n@router.put(\"/{tag_id}\", response_model=TagResponse, dependencies=[Depends(allowed_operation_put)])\nasync def update_tag(body: TagModel, tag_id: int = Path(ge=1), db: Session = Depends(get_db)):\n    \"\"\"\n    The update_tag function updates a tag in the database.\n        The function takes an id and a body as input, and returns the updated tag.\n        If no tag is found with that id, it raises an HTTP 404 error.\n    Arguments:", "        If no tag is found with that id, it raises an HTTP 404 error.\n    Arguments:\n        body (TagModel): all need field to update\n        tag_id (int): Find the tag to be deleted\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:\n        Tag | None: Tag or None if no matching tag were found\n    \"\"\"\n    tag = await repository_tag.find_tag_by_id(tag_id, db)\n    if tag is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail='Not found')", "    \"\"\"\n    tag = await repository_tag.find_tag_by_id(tag_id, db)\n    if tag is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail='Not found')\n    edit_tag = await repository_tag.edit_tag(tag, body, db)\n    return edit_tag\n\n\n@router.delete(\"/{tag_name}\", dependencies=[Depends(allowed_operation_delete)], status_code=status.HTTP_204_NO_CONTENT)\nasync def delete(tag_name: str, db: Session = Depends(get_db)):", "@router.delete(\"/{tag_name}\", dependencies=[Depends(allowed_operation_delete)], status_code=status.HTTP_204_NO_CONTENT)\nasync def delete(tag_name: str, db: Session = Depends(get_db)):\n    \"\"\"\n    route to delete tag finded by name\n\n    Arguments:\n        tag_name (str): tag name to found\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:", "\n    Returns:\n        None\n    \"\"\"\n    tag = await repository_tag.delete_tag(tag_name, db)\n    if tag is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail='Not found')\n    return None\n\n", "\n"]}
{"filename": "src/routes/comments.py", "chunked_list": ["from typing import List\n\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\n\nfrom src.database.db import get_db\nfrom src.database.models import User, UserRole\nfrom src.repository.comments import create_comment, edit_comment, delete_comment, get_all_user_comments, \\\n    get_comments_by_image_id\nfrom src.schemas.comments import CommentBase, CommentResponse", "    get_comments_by_image_id\nfrom src.schemas.comments import CommentBase, CommentResponse\nfrom src.services.auth import auth_service\nfrom src.services.roles import RoleAccess\n\nrouter = APIRouter(prefix='/comments', tags=[\"comments\"])\n\nallowed_operation_get = RoleAccess([UserRole.Admin, UserRole.Moderator, UserRole.User])\nallowed_operation_post = RoleAccess([UserRole.Admin, UserRole.Moderator, UserRole.User])\nallowed_operation_put = RoleAccess([UserRole.Admin, UserRole.Moderator, UserRole.User])", "allowed_operation_post = RoleAccess([UserRole.Admin, UserRole.Moderator, UserRole.User])\nallowed_operation_put = RoleAccess([UserRole.Admin, UserRole.Moderator, UserRole.User])\nallowed_operation_delete = RoleAccess([UserRole.Admin])\n\n\n@router.post('/{image_id}', response_model=CommentResponse, dependencies=[Depends(allowed_operation_post)])\nasync def post_comment(image_id: int,\n                       body: CommentBase,\n                       db: Session = Depends(get_db),\n                       current_user: User = Depends(auth_service.get_current_user)):", "                       db: Session = Depends(get_db),\n                       current_user: User = Depends(auth_service.get_current_user)):\n    \"\"\"\n    Creates a new comment for an image.\n\n    Arguments:\n        image_id (int): ID of the image that the comment is being made on\n        body (CommentBase): Pass the comment_text from the request body to the function\n        db (Session): SQLAlchemy session object for accessing the database\n        current_user (User): the current user attempting to delete the comment", "        db (Session): SQLAlchemy session object for accessing the database\n        current_user (User): the current user attempting to delete the comment\n\n    Returns:\n        Comment: the Comment object\n    \"\"\"\n\n    comment = await create_comment(image_id, body, db, current_user)\n\n    return comment", "\n    return comment\n\n\n@router.put('/{comment_id}', response_model=CommentResponse, dependencies=[Depends(allowed_operation_put)])\nasync def update_comment(comment_id: int,\n                         body: CommentBase,\n                         db: Session = Depends(get_db),\n                         current_user: User = Depends(auth_service.get_current_user)):\n", "                         current_user: User = Depends(auth_service.get_current_user)):\n\n    \"\"\"\n    Modifies the specified comment in the database, if the current user has permission to do so.\n    If comment with requested id does not exist raise HTTPException with status HTTP_404_NOT_FOUND\n\n    Arguments:\n        comment_id (int): ID of the comment to be deleted\n        db (Session): SQLAlchemy session object for accessing the database\n        body (CommentBase): Pass the comment_text from the request body to the function", "        db (Session): SQLAlchemy session object for accessing the database\n        body (CommentBase): Pass the comment_text from the request body to the function\n        current_user (User): the current user attempting to edite the comment\n\n    Returns:\n        Comment: the Comment object representing the modified comment,\n    \"\"\"\n\n    updated_comment = await edit_comment(comment_id, body, db, current_user)\n\n    if not updated_comment:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND)", "    updated_comment = await edit_comment(comment_id, body, db, current_user)\n\n    if not updated_comment:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND)\n\n    return updated_comment\n\n\n@router.delete('/{comment_id}', status_code=status.HTTP_204_NO_CONTENT, dependencies=[Depends(allowed_operation_delete)])\nasync def remove_comment(comment_id: int,", "@router.delete('/{comment_id}', status_code=status.HTTP_204_NO_CONTENT, dependencies=[Depends(allowed_operation_delete)])\nasync def remove_comment(comment_id: int,\n                         db: Session = Depends(get_db),\n                         current_user: User = Depends(auth_service.get_current_user)):\n    \"\"\"\n    Deletes the specified comment from the database, if the current user has permission to do so.\n    If comment with requested id does not exist raise HTTPException with status HTTP_404_NOT_FOUND\n\n    Arguments:\n        comment_id (int): ID of the comment to be deleted", "    Arguments:\n        comment_id (int): ID of the comment to be deleted\n        db (Session): SQLAlchemy session object for accessing the database\n        current_user (User): the current user attempting to delete the comment\n\n    Returns:\n        None: If comment was success delete\n        \"\"\"\n\n    deleted_comment = await delete_comment(comment_id, db, current_user)", "\n    deleted_comment = await delete_comment(comment_id, db, current_user)\n\n    if not deleted_comment:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND)\n\n    return None\n\n\n@router.get('/user/{user_id}', response_model=List[CommentResponse], dependencies=[Depends(allowed_operation_get)])", "\n@router.get('/user/{user_id}', response_model=List[CommentResponse], dependencies=[Depends(allowed_operation_get)])\nasync def show_user_comments(user_id: int,\n                             db: Session = Depends(get_db),\n                             skip: int = 0,\n                             limit: int = 10):\n\n    \"\"\"\n    Gets a list of comments made by the specified user.\n", "    Gets a list of comments made by the specified user.\n\n    Arguments:\n        skip (int): number of comments to skip in the search\n        limit (int): maximum number of comments to retrieve\n        user_id (int): ID of the user to retrieve comments for\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:\n        List[Comment] | None: a list of Comment objects representing the user's comments,", "    Returns:\n        List[Comment] | None: a list of Comment objects representing the user's comments,\n        or None if no matching comments were found\n    \"\"\"\n    comments = await get_all_user_comments(skip, limit, user_id, db)\n    return comments\n\n\n@router.get('/image/{image_id}', response_model=List[CommentResponse], dependencies=[Depends(allowed_operation_get)])\nasync def show_comments(image_id: int,", "@router.get('/image/{image_id}', response_model=List[CommentResponse], dependencies=[Depends(allowed_operation_get)])\nasync def show_comments(image_id: int,\n                        db: Session = Depends(get_db),\n                        skip: int = 0,\n                        limit: int = 10):\n\n    \"\"\"\n    Gets all comments of the specified image from the database.\n\n    Arguments:", "\n    Arguments:\n        skip (int): number of comments to skip in the search\n        limit (int): maximum number of comments to retrieve\n        image_id (int): ID of the image to retrieve comments for\n        db (Session): SQLAlchemy session object for accessing the database\n\n    Returns:\n        List[Comment] | None: a list of Comment objects representing all comments,\n        or None if no matching comments were found", "        List[Comment] | None: a list of Comment objects representing all comments,\n        or None if no matching comments were found\n    \"\"\"\n    comments = await get_comments_by_image_id(skip, limit, image_id, db)\n    return comments\n"]}
