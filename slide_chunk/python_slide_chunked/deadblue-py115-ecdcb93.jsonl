{"filename": "setup.py", "chunked_list": ["__author__ = 'deadblue'\n\nfrom setuptools import setup\n\nsetup()\n"]}
{"filename": "py115/types.py", "chunked_list": ["__author__ = 'deadblue'\n\nfrom datetime import datetime\nfrom enum import IntEnum\n\nfrom py115._internal import oss, utils\n\n\nclass AppType(IntEnum):\n    \"\"\"App to login.\"\"\"\n\n    Web = 0\n    \"\"\"Login as web\"\"\"\n    Mac = 1\n    \"\"\"Login as MAC app\"\"\"\n    Linux = 2\n    \"\"\"Login as Linux app\"\"\"\n    Windows = 3\n    \"\"\"Login as Windows app\"\"\"", "class AppType(IntEnum):\n    \"\"\"App to login.\"\"\"\n\n    Web = 0\n    \"\"\"Login as web\"\"\"\n    Mac = 1\n    \"\"\"Login as MAC app\"\"\"\n    Linux = 2\n    \"\"\"Login as Linux app\"\"\"\n    Windows = 3\n    \"\"\"Login as Windows app\"\"\"", "\n\nclass _Base:\n    \"\"\"Base clase for all types.\"\"\"\n\n    def __repr__(self) -> str:\n        cls_name = type(self).__name__\n        attrs = ', '.join([\n            f'{k}={v}' for k, v in self.__dict__.items()\n        ])\n        return f'{cls_name}({attrs})'", "\n\nclass Credential(_Base):\n    \"\"\"Credential contains required information to identify user.\n\n    Args:\n        uid (str): The \"UID\" value in cookies.\n        cid (str): The \"CID\" value in cookies.\n        seid (str): The \"SEID\" value in cookies.\n    \"\"\"\n\n    _uid: str = None\n    _cid: str = None\n    _seid: str = None\n\n    def __init__(self, uid: str = None, cid: str = None, seid: str = None) -> None:\n        self._uid = uid\n        self._cid = cid\n        self._seid = seid\n\n    @classmethod\n    def from_dict(cls, d: dict):\n        \"\"\"Create Credential from a dict object.\n\n        Args:\n            d (dict): Dict object.\n\n        Returns:\n            py115.types.Credential: Credential object.\n        \"\"\"\n        if len(d) == 0 or not ('UID' in d and 'CID' in d and 'SEID' in d):\n            return None\n        return Credential(\n            uid=d.get('UID'),\n            cid=d.get('CID'),\n            seid=d.get('SEID')\n        )\n\n    def to_dict(self) -> dict:\n        \"\"\"Convert credential object to dict object.\n\n        Returns:\n            dict: Dict object.\n        \"\"\"\n        return {\n            'UID': self._uid,\n            'CID': self._cid,\n            'SEID': self._seid,\n        }", "\n\nclass File(_Base):\n    \"\"\"File represents a cloud file or directory.\"\"\"\n\n    file_id: str\n    \"\"\"Unique ID of the file on cloud.\"\"\"\n\n    parent_id: str\n    \"\"\"File ID of the parent directory.\"\"\"\n\n    name: str\n    \"\"\"Base name.\"\"\"\n\n    size: int\n    \"\"\"Size in bytes.\"\"\"\n\n    modified_time: datetime\n    \"\"\"Last modified datetime.\"\"\"\n\n    sha1: str\n    \"\"\"SHA-1 hash of the file in HEX encoding.\"\"\"\n\n    pickcode: str\n    \"\"\"Pickcode to download the file.\"\"\"\n\n    is_dir: bool\n    \"\"\"Is file a directory.\"\"\"\n\n    @classmethod\n    def _create(cls, raw: dict):\n        category_id = raw.get('cid')\n        file_id = raw.get('fid')\n        parent_id = raw.get('pid')\n\n        r = cls()\n        r.is_dir = file_id is None\n        r.name = raw.get('n')\n        if 'te' in raw:\n            r.modified_time = utils.parse_datetime_str(raw.get('te'))\n        else:\n            r.modified_time = utils.parse_datetime_str(raw.get('t'))\n        if r.is_dir:\n            r.file_id = category_id\n            r.parent_id = parent_id\n            r.size, r.sha1, r.pickcode = 0, None, None\n        else:\n            r.file_id = file_id\n            r.parent_id = category_id\n            r.size = raw.get('s')\n            r.sha1 = raw.get('sha')\n            r.pickcode = raw.get('pc')\n        return r\n\n    def __str__(self) -> str:\n        if self.is_dir:\n            return f'{self.name}/'\n        else:\n            return self.name", "\n\nclass DownloadTicket(_Base):\n    \"\"\"\n    DownloadTicket contains required parameters to download a file from \n    cloud storage.\n\n    Please check examples for detail usage.\n    \"\"\"\n\n    file_name: str\n    \"\"\"Base name of the file.\"\"\"\n\n    file_size: int\n    \"\"\"Size of the file.\"\"\"\n\n    url: str\n    \"\"\"Download URL.\"\"\"\n\n    headers: dict\n    \"\"\"Required headers that should be used with download URL.\"\"\"", "\n\nclass PlayTicket(_Base):\n\n    url: str\n    \"\"\"Download URL.\"\"\"\n\n    headers: dict\n    \"\"\"Required headers that should be used with download URL.\"\"\"\n", "\n\nclass UploadTicket(_Base):\n    \"\"\"\n    UploadTicket contains required parameters to upload a file to \n    cloud storage.\n\n    Please check examples for detial usage.\n    \"\"\"\n\n    is_done: bool\n    \"\"\"Is file already uploaded.\"\"\"\n\n    oss_endpoint: str\n    \"\"\"OSS endpoint address.\"\"\"\n\n    oss_token: dict\n    \"\"\"OSS token\"\"\"\n\n    bucket_name: str\n    \"\"\"OSS bucket name.\"\"\"\n\n    object_key: str\n    \"\"\"OSS object key.\"\"\"\n\n    headers: dict\n    \"\"\"Required headers that should be used in upload.\"\"\"\n\n    expiration: datetime\n    \"\"\"Expiration time of this ticket.\"\"\"\n\n    @classmethod\n    def _create(cls, raw: dict, token: dict):\n        r = cls()\n        r.is_done = raw['done']\n        if not r.is_done:\n            r.oss_endpoint = oss.ENDPOINT\n            r.oss_token = {\n                'access_key_id': token.get('access_key_id'),\n                'access_key_secret': token.get('access_key_secret'),\n                'security_token': token.get('security_token')\n            }\n            r.bucket_name = raw.get('bucket')\n            r.object_key = raw.get('object')\n            r.headers = {\n                'x-oss-callback': oss.encode_header_value(raw.get('callback')),\n                'x-oss-callback-var': oss.encode_header_value(raw.get('callback_var'))\n            }\n            r.expiration = token.get('expiration')\n        return r\n    \n    def is_valid(self) -> bool:\n        \"\"\"Check whether the ticket is valid.\n\n        Returns:\n            bool: Valid flag.\n        \"\"\"\n        return datetime.now() < self.expiration", "\n\nclass TaskStatus(IntEnum):\n    Running = 1\n    \"\"\"Task is running.\"\"\"\n    Complete = 2\n    \"\"\"Task is complete.\"\"\"\n    Failed = -1\n    \"\"\"Task is failed.\"\"\"\n    Unknown = 0\n    \"\"\"Unknown status?\"\"\"", "\n\nclass Task(_Base):\n    \"\"\"Task represents an offline task.\"\"\"\n\n    task_id: str\n    \"\"\"Unique ID of the task.\"\"\"\n\n    name: str\n    \"\"\"Task name.\"\"\"\n\n    size: int\n    \"\"\"Total size to be downloaded.\"\"\"\n\n    created_time: datetime\n    \"\"\"Task created time.\"\"\"\n\n    percent: float\n    \"\"\"Precentage of the download, 0~100.\"\"\"\n\n    file_id: str\n    \"\"\"Downloaded file ID of the task, may be None if the task does not finish.\"\"\"\n\n    file_is_dir: bool\n    \"\"\"Is the downloaded file a directory.\"\"\"\n\n    status: TaskStatus\n    \"\"\"Task status.\"\"\"\n\n    @classmethod\n    def _create(cls, raw: dict):\n        r = cls()\n        r.task_id = raw.get('info_hash')\n        r.name = raw.get('name')\n        r.size = raw.get('size', -1)\n        r.created_time = utils.make_datetime(raw.get('add_time', 0))\n        r.precent = float(raw.get('percentDone', 0))\n        r.status = TaskStatus(raw.get('status', 0))\n\n        file_id = raw.get('file_id', '')\n        del_file_id = raw.get('delete_file_id', '')\n        r.file_id = del_file_id\n        r.file_is_dir = file_id != '' and file_id == del_file_id\n        return r\n\n    def is_complete(self) -> bool:\n        \"\"\"Check is task complete.\"\"\"\n        return self.status == TaskStatus.Complete\n\n    def is_failed(self) -> bool:\n        \"\"\"Check is task failed.\"\"\"\n        return self.status == TaskStatus.Failed\n\n    def is_running(self) -> bool:\n        \"\"\"Check is task still running.\"\"\"\n        return self.status == TaskStatus.Running"]}
{"filename": "py115/cloud.py", "chunked_list": ["__author__ = 'deadblue'\n\nimport typing\n\nfrom py115._internal.protocol.client import Client\nfrom py115._internal.api import qrcode, upload, version\n\nfrom py115 import login, services\nfrom py115.types import AppType, Credential\n", "from py115.types import AppType, Credential\n\n\n_app_names = [\n    'web', 'mac', 'linux', 'windows'\n]\n\n\nclass Cloud(login._Handler):\n    \"\"\"115 cloud service.\n\n    Args:\n        credential (py115.types.Credential): Credential object.\n        protocol_kwargs (dict): Settings for underlying protocol client.\n    \"\"\"\n\n    _app_ver: str = None\n    _client: Client = None\n    _upload_helper: upload.Helper = None\n\n    def __init__(\n            self, \n            credential: Credential = None, \n            protocol_kwargs: dict = None\n        ) -> None:\n        # Config protocol client\n        protocol_kwargs = protocol_kwargs or {}\n        self._client = Client(**protocol_kwargs)\n        # Get latest app version\n        self._app_ver = self._client.execute_api(version.GetApi())\n        self._client.setup_user_agent(\n            app_version=self._app_ver\n        )\n        # Set credential\n        if credential is not None:\n            self.import_credential(credential)\n\n    def import_credential(self, credential: Credential) -> bool:\n        \"\"\"Import credential to cloud instance.\n\n        Args:\n            credential (py115.types.Credential): Credential object to identity user.\n\n        Return:\n            bool: Is credential valid.\n        \"\"\"\n        self._client.import_cookies(credential.to_dict())\n        return self._on_login()\n\n    def export_credentail(self) -> typing.Union[Credential, None]:\n        \"\"\"Export current credentail from cloud instance.\n\n        Return:\n            py115.types.Credential: Credential object, or None when credential is invalid.\n        \"\"\"\n        # TODO: Check credential before return.\n        return Credential.from_dict(\n            self._client.export_cookies()\n        )\n\n    def qrcode_login(self, app_type: AppType) -> login.QrcodeSession:\n        \"\"\"Start QRcode login session.\n\n        Args:\n            app_type (py115.types.AppType): App to login.\n\n        Returns:\n            py115.login.QrcodeSession: QRcode login session.\n        \"\"\"\n        app_name = _app_names[app_type.value]\n        token = self._client.execute_api(qrcode.TokenApi(app_name))\n        return login.QrcodeSession._create(\n            client=self._client,\n            handler=self,\n            app_name=app_name,\n            uid=token.get('uid'), \n            time=token.get('time'),\n            sign=token.get('sign')\n        )\n\n    def _on_login(self) -> bool:\n        try:\n            user_id, user_key = self._client.execute_api(upload.InfoApi())\n            self._upload_helper = upload.Helper(\n                self._app_ver, user_id, user_key\n            )\n            return True\n        except:\n            return False\n\n    def offline(self) -> services.OfflineService:\n        \"\"\"Get offline service.\n\n        Return:\n            py115.services.OfflineService: Offline service instance.\n        \"\"\"\n        return services.OfflineService._create(\n            client=self._client, \n            app_ver=self._app_ver, \n            user_id=self._upload_helper.user_id\n        )\n\n    def storage(self) -> services.StorageService:\n        \"\"\"Get storage service.\n\n        Return:\n            py115.services.StorageService: Storage service instance.\n        \"\"\"\n        return services.StorageService._create(\n            client=self._client,\n            uh=self._upload_helper\n        )", "class Cloud(login._Handler):\n    \"\"\"115 cloud service.\n\n    Args:\n        credential (py115.types.Credential): Credential object.\n        protocol_kwargs (dict): Settings for underlying protocol client.\n    \"\"\"\n\n    _app_ver: str = None\n    _client: Client = None\n    _upload_helper: upload.Helper = None\n\n    def __init__(\n            self, \n            credential: Credential = None, \n            protocol_kwargs: dict = None\n        ) -> None:\n        # Config protocol client\n        protocol_kwargs = protocol_kwargs or {}\n        self._client = Client(**protocol_kwargs)\n        # Get latest app version\n        self._app_ver = self._client.execute_api(version.GetApi())\n        self._client.setup_user_agent(\n            app_version=self._app_ver\n        )\n        # Set credential\n        if credential is not None:\n            self.import_credential(credential)\n\n    def import_credential(self, credential: Credential) -> bool:\n        \"\"\"Import credential to cloud instance.\n\n        Args:\n            credential (py115.types.Credential): Credential object to identity user.\n\n        Return:\n            bool: Is credential valid.\n        \"\"\"\n        self._client.import_cookies(credential.to_dict())\n        return self._on_login()\n\n    def export_credentail(self) -> typing.Union[Credential, None]:\n        \"\"\"Export current credentail from cloud instance.\n\n        Return:\n            py115.types.Credential: Credential object, or None when credential is invalid.\n        \"\"\"\n        # TODO: Check credential before return.\n        return Credential.from_dict(\n            self._client.export_cookies()\n        )\n\n    def qrcode_login(self, app_type: AppType) -> login.QrcodeSession:\n        \"\"\"Start QRcode login session.\n\n        Args:\n            app_type (py115.types.AppType): App to login.\n\n        Returns:\n            py115.login.QrcodeSession: QRcode login session.\n        \"\"\"\n        app_name = _app_names[app_type.value]\n        token = self._client.execute_api(qrcode.TokenApi(app_name))\n        return login.QrcodeSession._create(\n            client=self._client,\n            handler=self,\n            app_name=app_name,\n            uid=token.get('uid'), \n            time=token.get('time'),\n            sign=token.get('sign')\n        )\n\n    def _on_login(self) -> bool:\n        try:\n            user_id, user_key = self._client.execute_api(upload.InfoApi())\n            self._upload_helper = upload.Helper(\n                self._app_ver, user_id, user_key\n            )\n            return True\n        except:\n            return False\n\n    def offline(self) -> services.OfflineService:\n        \"\"\"Get offline service.\n\n        Return:\n            py115.services.OfflineService: Offline service instance.\n        \"\"\"\n        return services.OfflineService._create(\n            client=self._client, \n            app_ver=self._app_ver, \n            user_id=self._upload_helper.user_id\n        )\n\n    def storage(self) -> services.StorageService:\n        \"\"\"Get storage service.\n\n        Return:\n            py115.services.StorageService: Storage service instance.\n        \"\"\"\n        return services.StorageService._create(\n            client=self._client,\n            uh=self._upload_helper\n        )", ""]}
{"filename": "py115/__init__.py", "chunked_list": ["__author__ = 'deadblue'\n\n\"\"\"\nPython SDK for 115 cloud storage service.\n\nExample:\n\nimport py115\nimport py115.types\n", "import py115.types\n\ncloud = py115.connect(py115.types.Credential(\n    uid='', cid='', seid=''\n))\nstorage = cloud.storage()\n\nfor file in storage.list():\n    print(f'File: {file.name}')\n", "    print(f'File: {file.name}')\n\n\"\"\"\n\nVERSION = '0.0.3'\n\nimport py115.cloud\nimport py115.types\n\ndef connect(\n        credential: py115.types.Credential = None,\n        protocol_kwargs: dict=  None\n) -> py115.cloud.Cloud:\n    \"\"\"Connect to 115 cloud.\n\n    Args:\n        credential (py115.types.Credential): \n            Credential data to identity user.\n        protocol_kwargs (dict): \n            Keyword arguments for underlying protocol client.\n\n    Return:\n        py115.cloud.Cloud: Cloud instance.\n    \"\"\"\n    return py115.cloud.Cloud(\n        credential=credential, \n        protocol_kwargs=protocol_kwargs\n    )", "\ndef connect(\n        credential: py115.types.Credential = None,\n        protocol_kwargs: dict=  None\n) -> py115.cloud.Cloud:\n    \"\"\"Connect to 115 cloud.\n\n    Args:\n        credential (py115.types.Credential): \n            Credential data to identity user.\n        protocol_kwargs (dict): \n            Keyword arguments for underlying protocol client.\n\n    Return:\n        py115.cloud.Cloud: Cloud instance.\n    \"\"\"\n    return py115.cloud.Cloud(\n        credential=credential, \n        protocol_kwargs=protocol_kwargs\n    )", ""]}
{"filename": "py115/login.py", "chunked_list": ["__author__ = 'deadblue'\n\nimport logging\n\nfrom py115._internal.api import qrcode\nfrom py115._internal.protocol.client import Client\n\n\n_logger = logging.getLogger(__name__)\n", "_logger = logging.getLogger(__name__)\n\n\nclass _Handler:\n\n    def _on_login(self) -> bool:\n        return True\n\n\nclass QrcodeSession:\n    \"\"\"QRcode login session.\"\"\"\n\n    _client: Client\n    _handler: _Handler\n    _app_name: str\n    _uid: str\n    _time: int\n    _sign: str\n\n    image_data: bytes\n    \"\"\"QRcode image data\"\"\"\n\n    @classmethod\n    def _create(cls, client: Client, handler: _Handler, app_name: str, uid: str, time: int, sign: str):\n        s = cls()\n        s._client = client\n        s._handler = handler\n        s._app_name = app_name\n        s._uid = uid\n        s._time = time\n        s._sign = sign\n        s.image_data = client.fetch(qrcode.get_image_url(app_name, uid))\n        return s\n\n    def poll(self) -> bool:\n        \"\"\"Poll QRcode status.\n        This method will block until login is done, or QRcode is invalid.\n\n        Returns:\n            bool: Is login succeeded.\n        \"\"\"\n        while True:\n            # Query QRcode status\n            status = self._client.execute_api(qrcode.StatusApi(\n                uid=self._uid,\n                time=self._time,\n                sign=self._sign\n            ))\n            if status == 2:\n                # Allowed, start login\n                self._client.execute_api(qrcode.LoginApi(\n                    app_name=self._app_name,\n                    uid=self._uid\n                ))\n                return self._handler._on_login()\n                \n            elif status < 0:\n                # Canceled or Expired\n                return False\n            else:\n                # Waiting or Scanned\n                _logger.debug('Continue waiting, status: %d', status)", "\nclass QrcodeSession:\n    \"\"\"QRcode login session.\"\"\"\n\n    _client: Client\n    _handler: _Handler\n    _app_name: str\n    _uid: str\n    _time: int\n    _sign: str\n\n    image_data: bytes\n    \"\"\"QRcode image data\"\"\"\n\n    @classmethod\n    def _create(cls, client: Client, handler: _Handler, app_name: str, uid: str, time: int, sign: str):\n        s = cls()\n        s._client = client\n        s._handler = handler\n        s._app_name = app_name\n        s._uid = uid\n        s._time = time\n        s._sign = sign\n        s.image_data = client.fetch(qrcode.get_image_url(app_name, uid))\n        return s\n\n    def poll(self) -> bool:\n        \"\"\"Poll QRcode status.\n        This method will block until login is done, or QRcode is invalid.\n\n        Returns:\n            bool: Is login succeeded.\n        \"\"\"\n        while True:\n            # Query QRcode status\n            status = self._client.execute_api(qrcode.StatusApi(\n                uid=self._uid,\n                time=self._time,\n                sign=self._sign\n            ))\n            if status == 2:\n                # Allowed, start login\n                self._client.execute_api(qrcode.LoginApi(\n                    app_name=self._app_name,\n                    uid=self._uid\n                ))\n                return self._handler._on_login()\n                \n            elif status < 0:\n                # Canceled or Expired\n                return False\n            else:\n                # Waiting or Scanned\n                _logger.debug('Continue waiting, status: %d', status)", ""]}
{"filename": "py115/services.py", "chunked_list": ["__author__ = 'deadblue'\n\nimport os\nimport os.path\nimport typing\n\nfrom py115._internal.api import offline, file, dir, space, upload\nfrom py115._internal.protocol.client import Client\n\nfrom py115 import types", "\nfrom py115 import types\n\n\n_CLEAR_FLAG_MAPPING = {\n    types.TaskStatus.Complete: 1,\n    types.TaskStatus.Failed: 2,\n    types.TaskStatus.Running: 3\n}\n", "}\n\n\nclass OfflineService:\n    \"\"\"Offline task manager.\"\"\"\n\n    _client: Client = None\n    _app_ver: str = None\n    _user_id: str = None\n\n    @classmethod\n    def _create(cls, client: Client, app_ver: str, user_id: str):\n        s = cls()\n        s._client = client\n        s._app_ver = app_ver\n        s._user_id = user_id\n        return s\n\n    def list(self) -> typing.Generator[types.Task, None, None]:\n        \"\"\"Get all tasks.\n\n        Yields:\n            py115.types.Task: Task object\n        \"\"\"\n        spec = offline.ListApi()\n        while True:\n            result = self._client.execute_api(spec)\n            for t in result['tasks']:\n                yield types.Task._create(t)\n            page, page_count = result['page'], result['page_count']\n            if page < page_count:\n                spec.set_page(page + 1)\n            else:\n                break\n\n    def add_url(self, *urls: str) -> typing.Iterable[types.Task]:\n        \"\"\"Create task(s) from download URL.\n\n        Args:\n            *urls (str): Download URL, can be a http/ftp/ed2k/magnet link.\n\n        Return:\n            Iterable[py115.types.Task]: Task list for the download URLs.\n        \"\"\"\n        if len(urls) == 0:\n            return []\n        add_results = self._client.execute_api(offline.AddUrlsApi(\n            self._app_ver, self._user_id, urls\n        ))\n        return [types.Task._create(r) for r in add_results]\n\n    def delete(self, *task_ids: str):\n        \"\"\"Delete task(s).\n\n        Args:\n            *task_ids (str): The ID of tasks you wants to delete.\n        \"\"\"\n        if len(task_ids) == 0:\n            return\n        self._client.execute_api(offline.DeleteApi(task_ids))\n\n    def clear(self, status: types.TaskStatus = types.TaskStatus.Complete):\n        \"\"\"Clear tasks.\n\n        Args:\n            status (py115.types.TaskStatus): \n                Tasks in given status will be cleared. Set status to None to \n                clear all tasks.\n        \"\"\"\n        if status is None:\n            # Clear all tasks\n            flag = 1\n        else:\n            # Default to clear complete tasks.\n            flag = _CLEAR_FLAG_MAPPING.get(status, 0)\n        self._client.execute_api(offline.ClearApi(flag))", "\n\nclass StorageService:\n    \"\"\"Cloud file/directory manager.\n    \"\"\"\n\n    _client: Client = None\n    _upload_helper: upload.Helper = None\n\n    @classmethod\n    def _create(cls, client: Client, uh: upload.Helper):\n        s = cls()\n        s._client = client\n        s._upload_helper = uh\n        return s\n\n    def space(self) -> typing.Tuple[int, int]:\n        \"\"\"\n        Get total size and used size of the storage.\n\n        Returns:\n            Tuple[int, int]: Total size and used size in byte.\n        \"\"\"\n        result = self._client.execute_api(space.GetApi())\n        if result is not None:\n            total = int(result['all_total']['size'])\n            used = int(result['all_use']['size'])\n            return (total, used)\n        else:\n            return (0, 0)\n\n    def list(self, dir_id: str = '0') -> typing.Generator[types.File, None, None]:\n        \"\"\"Get files under a directory.\n\n        Args:\n            dir_id (str): Directory ID to list, default is \"0\" which means root directory.\n\n        Yields:\n            py115.types.File: File object under the directory.\n        \"\"\"\n        spec = file.ListApi(dir_id)\n        while True:\n            result = self._client.execute_api(spec)\n            for f in result['files']:\n                yield types.File._create(f)\n            next_offset = result['offset'] + len(result['files'])\n            if next_offset >= result['count']:\n                break\n            else:\n                spec.set_offset(next_offset)\n\n    def search(self, keyword: str, dir_id: str = '0'):\n        \"\"\"Recursively search files under a directory.\n\n        Args:\n            keyword (str): Keyword to search files.\n            dir_id (str): Directory ID to search.\n\n        Yields:\n            py115.types.File: File object whose name contains the keyword.\n        \"\"\"\n        spec = file.SearchApi(keyword=keyword, dir_id=dir_id)\n        while True:\n            result = self._client.execute_api(spec)\n            for f in result['files']:\n                yield types.File._create(f)\n            next_offset = result['offset'] + len(result['files'])\n            if next_offset >= result['count']:\n                break\n            else:\n                spec.set_offset(next_offset)\n\n    def move(self, target_dir_id: str, *file_ids: str):\n        \"\"\"Move files to a directory.\n\n        Args:\n            target_dir_id (str): ID of target directory where to move files.\n            *file_ids (str): ID of files to be moved.\n        \"\"\"\n        if len(file_ids) == 0:\n            return\n        self._client.execute_api(file.MoveApi(target_dir_id, file_ids))\n\n    def rename(self, file_id: str, new_name: str):\n        \"\"\"Rename file.\n        \n        Args:\n            file_id (str): ID of file to be renamed.\n            new_name (str): New name for the file.\n        \"\"\"\n        self._client.execute_api(file.RenameApi(file_id, new_name))\n\n    def delete(self, *file_ids: str):\n        \"\"\"Delete files.\n\n        Args:\n            *file_ids (str): ID of files to be deleted.\n        \"\"\"\n        if len(file_ids) == 0:\n            return\n        self._client.execute_api(file.DeleteApi(file_ids))\n\n    def make_dir(self, parent_id: str, name: str) -> types.File:\n        \"\"\"Make new directory under a directory.\n        \n        Args:\n            parent_id (str): ID of parent directory where to make new directory.\n            name (str): Name for the new directory.\n        \n        Return:\n            py115.types.File: File object of the created directory.\n        \"\"\"\n        result = self._client.execute_api(dir.AddApi(parent_id, name))\n        result['pid'] = parent_id\n        return types.File._create(result)\n\n    def request_download(self, pickcode: str) -> types.DownloadTicket:\n        \"\"\"Download file from cloud storage.\n\n        Args:\n            pickcode (str): Pick code of file.\n\n        Returns:\n            py115.types.DownloadTicket: A ticket contains all required fields to \n            download file from cloud.\n        \"\"\"\n        result = self._client.execute_api(file.DownloadApi(pickcode))\n        if result is None or 'url' not in result:\n            return None\n        ticket = types.DownloadTicket()\n        ticket.url = result['url']\n        ticket.file_name = result.get('file_name')\n        ticket.file_size = result.get('file_size')\n        # Required headers for downloading\n        cookies = self._client.export_cookies(url=result['url'])\n        ticket.headers = {\n            'User-Agent': self._client.user_agent,\n            'Cookie': '; '.join([\n                f'{k}={v}' for k, v in cookies.items()\n            ])\n        }\n        return ticket\n\n    def request_play(self, pickcode: str) -> types.PlayTicket:\n        \"\"\"Play a video file on cloud, returns required parameters as a ticket.\n\n        Args:\n            pickcode (str): Pick code of file.\n        \n        Returns:\n            py115.types.PlayTicket: A ticket contains all required fields to \n            play the media file on cloud.\n        \"\"\"\n        ticket = types.PlayTicket()\n        ticket.url = self._client.execute_api(file.VideoApi(pickcode=pickcode))\n        # Prepare headers for playing\n        cookies = self._client.export_cookies(url=ticket.url)\n        ticket.headers = {\n            'User-Agent': self._client.user_agent,\n            'Cookie': '; '.join([\n                f'{k}={v}' for k, v in cookies.items()\n            ])\n        }\n        return ticket\n\n    def request_upload(self, dir_id: str, file_path: str) -> types.UploadTicket:\n        \"\"\"Upload local file to cloud storage.\n\n        Args:\n            dir_id (str): ID of directory where to store the file.\n            file_path (str): Path of the local file.\n        \n        Return:\n            py115.types.UploadTicket: A ticket contains all required fields to\n            upload file to cloud, should be used with aliyun-oss-python-sdk.\n        \"\"\"\n        if not os.path.exists(file_path):\n            return None\n        file_name = os.path.basename(file_path)\n        with open(file_path, 'rb') as file_io:\n            return self.request_upload_data(dir_id, file_name, file_io)\n\n    def request_upload_data(\n            self, \n            dir_id: str, \n            save_name: str, \n            data_io: typing.BinaryIO, \n        ) -> types.UploadTicket:\n        \"\"\"Upload data as a file to cloud storage.\n\n        Args:\n            dir_id (str): ID of directory where to store the file.\n            save_name (str): File name to be saved.\n            data_io (BinaryIO): IO stream of data.\n\n        Return:\n            py115.types.UploadTicket: A ticket contains all required fields to\n            upload file to cloud, should be used with aliyun-oss-python-sdk.\n        \"\"\"\n        if not (data_io.readable() and data_io.seekable()):\n            return None\n        init_result = self._client.execute_api(upload.InitApi(\n            target_id=f'U_1_{dir_id}',\n            file_name=save_name,\n            file_io=data_io,\n            helper=self._upload_helper\n        ))\n        token_result = None\n        if not init_result['done']:\n            token_result = self._client.execute_api(upload.TokenApi())\n        return types.UploadTicket._create(init_result, token_result)", ""]}
{"filename": "py115/_internal/__init__.py", "chunked_list": ["__author__ = 'deadblue'\n\n"]}
{"filename": "py115/_internal/utils.py", "chunked_list": ["__author__ = 'deadblue'\n\nimport datetime\n\nimport pytz\n\n_tz_cst = pytz.FixedOffset(480)\n\ndef parse_datetime_str(s: str) -> datetime.datetime:\n    if '-' in s:\n        t = datetime.datetime.strptime(\n            s, '%Y-%m-%d %H:%M'\n        )\n        t.replace(tzinfo=_tz_cst)\n        return t\n    else:\n        return  datetime.datetime.fromtimestamp(\n            float(s), tz=_tz_cst\n        )", "def parse_datetime_str(s: str) -> datetime.datetime:\n    if '-' in s:\n        t = datetime.datetime.strptime(\n            s, '%Y-%m-%d %H:%M'\n        )\n        t.replace(tzinfo=_tz_cst)\n        return t\n    else:\n        return  datetime.datetime.fromtimestamp(\n            float(s), tz=_tz_cst\n        )", "\ndef make_datetime(ts: int) -> datetime.datetime:\n    return datetime.datetime.fromtimestamp(\n        float(ts), tz=_tz_cst\n    )\n"]}
{"filename": "py115/_internal/oss.py", "chunked_list": ["__author__ = 'deadblue'\n\nimport base64\n\nENDPOINT='https://oss-cn-shenzhen.aliyuncs.com'\n\ndef encode_header_value(v: str) -> str:\n    return base64.b64encode(v.encode()).decode()\n", ""]}
{"filename": "py115/_internal/crypto/_xor.py", "chunked_list": ["__author__ = 'deadblue'\n\n_key_seed = bytes([\n    0xf0, 0xe5, 0x69, 0xae, 0xbf, 0xdc, 0xbf, 0x8a,\n    0x1a, 0x45, 0xe8, 0xbe, 0x7d, 0xa6, 0x73, 0xb8,\n    0xde, 0x8f, 0xe7, 0xc4, 0x45, 0xda, 0x86, 0xc4,\n    0x9b, 0x64, 0x8b, 0x14, 0x6a, 0xb4, 0xf1, 0xaa,\n    0x38, 0x01, 0x35, 0x9e, 0x26, 0x69, 0x2c, 0x86,\n    0x00, 0x6b, 0x4f, 0xa5, 0x36, 0x34, 0x62, 0xa6,\n    0x2a, 0x96, 0x68, 0x18, 0xf2, 0x4a, 0xfd, 0xbd,", "    0x00, 0x6b, 0x4f, 0xa5, 0x36, 0x34, 0x62, 0xa6,\n    0x2a, 0x96, 0x68, 0x18, 0xf2, 0x4a, 0xfd, 0xbd,\n    0x6b, 0x97, 0x8f, 0x4d, 0x8f, 0x89, 0x13, 0xb7,\n    0x6c, 0x8e, 0x93, 0xed, 0x0e, 0x0d, 0x48, 0x3e,\n    0xd7, 0x2f, 0x88, 0xd8, 0xfe, 0xfe, 0x7e, 0x86,\n    0x50, 0x95, 0x4f, 0xd1, 0xeb, 0x83, 0x26, 0x34,\n    0xdb, 0x66, 0x7b, 0x9c, 0x7e, 0x9d, 0x7a, 0x81,\n    0x32, 0xea, 0xb6, 0x33, 0xde, 0x3a, 0xa9, 0x59,\n    0x34, 0x66, 0x3b, 0xaa, 0xba, 0x81, 0x60, 0x48,\n    0xb9, 0xd5, 0x81, 0x9c, 0xf8, 0x6c, 0x84, 0x77,", "    0x34, 0x66, 0x3b, 0xaa, 0xba, 0x81, 0x60, 0x48,\n    0xb9, 0xd5, 0x81, 0x9c, 0xf8, 0x6c, 0x84, 0x77,\n    0xff, 0x54, 0x78, 0x26, 0x5f, 0xbe, 0xe8, 0x1e,\n    0x36, 0x9f, 0x34, 0x80, 0x5c, 0x45, 0x2c, 0x9b,\n    0x76, 0xd5, 0x1b, 0x8f, 0xcc, 0xc3, 0xb8, 0xf5,\n])\n\nclient_key = bytes([\n    0x78, 0x06, 0xad, 0x4c, 0x33, 0x86, 0x5d, 0x18, 0x4c, 0x01, 0x3f, 0x46,\n])", "    0x78, 0x06, 0xad, 0x4c, 0x33, 0x86, 0x5d, 0x18, 0x4c, 0x01, 0x3f, 0x46,\n])\n\n\ndef derive_key(source: bytes, size: int) -> bytes:\n    key = bytearray(size)\n    for i in range(size):\n        key[i] = (source[i] + _key_seed[size * i]) & 0xff\n        key[i] ^= _key_seed[size * (size - i - 1)]\n    return bytes(key)", "\n\ndef transform(key: bytes, data: bytearray):\n    key_size, data_size = len(key), len(data)\n    mod_size = data_size % 4\n    for i in range(data_size):\n        if i < mod_size:\n            data[i] ^= key[i % key_size]\n        else:\n            data[i] ^= key[(i - mod_size) % key_size]\n    return", ""]}
{"filename": "py115/_internal/crypto/_rsa.py", "chunked_list": ["__author__ = 'deadblue'\n\nimport secrets\n\n\nclass Cipher():\n\n    def __init__(self, n: bytes, e: int) -> None:\n        self._n = int.from_bytes(n, 'big')\n        self._e = e\n        self._key_len = len(n)\n\n\n    def _encrypt_slice(self, segment: bytes) -> bytes:\n        # Make pad\n        pad_size = self._key_len - len(segment)\n        pad_buf = bytearray(pad_size)\n        pad_buf[0], pad_buf[1] = 0, 2\n        for i in range(pad_size - 3):\n            pad_buf[2 + i] = secrets.randbelow(0xff) + 1\n        pad_buf[-1] = 0\n        msg = int.from_bytes(pad_buf + segment, 'big')\n        return pow(msg, self._e, self._n).to_bytes(self._key_len, 'big')\n\n\n    def encrypt(self, plaintext: bytes) -> bytes:\n        ciphertext = bytearray()\n        remain_size = len(plaintext)\n        while remain_size > 0:\n            slice_size = self._key_len - 11\n            if slice_size > remain_size:\n                slice_size = remain_size\n            ciphertext.extend(\n                self._encrypt_slice(plaintext[:slice_size])\n            )\n            plaintext = plaintext[slice_size:]\n            remain_size -= slice_size\n        return bytes(ciphertext)\n\n\n    def _decrypt_slice(self, segment: bytes) -> bytes:\n        msg = int.from_bytes(segment, 'big')\n        ret = pow(msg, self._e, self._n).to_bytes(self._key_len, 'big')\n        for i, b in enumerate(ret):\n            if i != 0 and b == 0:\n                ret = ret[i+1:]\n                break\n        return ret\n\n\n    def decrypt(self, ciphertext: bytes) -> bytearray:\n        plaintext = bytearray()\n        remain_size = len(ciphertext)\n        while remain_size > 0:\n            slice_size = self._key_len\n            if slice_size > remain_size:\n                slice_size = remain_size\n            plaintext.extend(\n                self._decrypt_slice(ciphertext[:slice_size])\n            )\n            ciphertext = ciphertext[slice_size:]\n            remain_size -= slice_size\n        return plaintext", ""]}
{"filename": "py115/_internal/crypto/__init__.py", "chunked_list": ["__author__ = 'deadblue'\n\n"]}
{"filename": "py115/_internal/crypto/ec115.py", "chunked_list": ["__author__ = 'deadblue'\n\nimport binascii\nimport logging\nimport random\nimport struct\n\nfrom Crypto.Cipher import AES\nfrom Crypto.PublicKey import ECC\nimport lz4.block", "from Crypto.PublicKey import ECC\nimport lz4.block\n\n_server_pub_key = bytes([\n    0x04, 0x57, 0xa2, 0x92, 0x57, 0xcd, 0x23, 0x20, \n    0xe5, 0xd6, 0xd1, 0x43, 0x32, 0x2f, 0xa4, 0xbb, \n    0x8a, 0x3c, 0xf9, 0xd3, 0xcc, 0x62, 0x3e, 0xf5, \n    0xed, 0xac, 0x62, 0xb7, 0x67, 0x8a, 0x89, 0xc9, \n    0x1a, 0x83, 0xba, 0x80, 0x0d, 0x61, 0x29, 0xf5, \n    0x22, 0xd0, 0x34, 0xc8, 0x95, 0xdd, 0x24, 0x65, ", "    0x1a, 0x83, 0xba, 0x80, 0x0d, 0x61, 0x29, 0xf5, \n    0x22, 0xd0, 0x34, 0xc8, 0x95, 0xdd, 0x24, 0x65, \n    0x24, 0x3a, 0xdd, 0xc2, 0x50, 0x95, 0x3b, 0xee, \n    0xba,\n])\n\n_curve_name = 'P-224'\n\n_crc_salt = b'^j>WD3Kr?J2gLFjD4W2y@'\n", "_crc_salt = b'^j>WD3Kr?J2gLFjD4W2y@'\n\n_logger = logging.getLogger(__name__)\n\nclass Cipher:\n\n    def __init__(self) -> None:\n        # Load server public key\n        server_key = ECC.import_key(\n            encoded=_server_pub_key, curve_name=_curve_name\n        )\n        # Generate client key\n        client_key = ECC.generate(curve=_curve_name)\n        # Export client public key\n        self._pub_key = b'\\x1d' + client_key.public_key().export_key(\n            format='SEC1', compress=True\n        )\n        # ECDH key exchange\n        shared_secret = (server_key.pointQ * client_key.d).x.to_bytes(28, 'big')\n        self._aes_key = shared_secret[:16]\n        self._aes_iv = shared_secret[-16:]\n    \n    def encode_token(self, timestamp: int) -> str:\n        token = bytearray(struct.pack(\n            '<15sBII15sBI',\n            self._pub_key[:15], 0, 115, timestamp,\n            self._pub_key[15:], 0, 1\n        ))\n        r1, r2 = random.randint(0, 0xff), random.randint(0, 0xff)\n        for i in range(len(token)):\n            if i < 24:\n                token[i] = token[i] ^ r1\n            else:\n                token[i] = token[i] ^ r2\n        # Calculate and append CRC32 checksum\n        checksum = binascii.crc32(_crc_salt + token) & 0xffffffff\n        token += struct.pack('<I', checksum)\n        # Base64 encode\n        return binascii.b2a_base64(token, newline=False).decode()\n\n    def encode(self, data: bytes) -> bytes:\n        pad_size = AES.block_size - len(data) % AES.block_size\n        if pad_size != AES.block_size:\n            data += b'\\x00' * pad_size\n        encrypter = AES.new(\n            key=self._aes_key,\n            mode=AES.MODE_CBC,\n            iv=self._aes_iv\n        )\n        return encrypter.encrypt(data)\n\n    def decode(self, data: bytes) -> bytes:\n        ciphertext, tail = data[:-12], bytearray(data[-12:])\n        # Decrypt\n        decrypter = AES.new(\n            key = self._aes_key, \n            mode = AES.MODE_CBC, \n            iv = self._aes_iv\n        )\n        plaintext = decrypter.decrypt(ciphertext)\n        # Get uncompress size\n        for i in range(4):\n            tail[i] = tail[i] ^ tail[7]\n        dst_size, = struct.unpack('<I', tail[:4])\n        # Decompress\n        buf = []\n        while dst_size > 0:\n            uncompressed_size = dst_size\n            if uncompressed_size > 8192:\n                uncompressed_size = 8192\n            src_size, = struct.unpack('<H', plaintext[:2])\n            buf.append(lz4.block.decompress(\n                plaintext[2:src_size+2], uncompressed_size\n            ))\n            # Move to next block\n            plaintext = plaintext[src_size+2:]\n            dst_size -= uncompressed_size\n        return buf[0] if len(buf) == 0 else b''.join(buf)", ""]}
{"filename": "py115/_internal/crypto/m115.py", "chunked_list": ["__author__ = 'deadblue'\n\nimport base64\nimport secrets\n\nfrom py115._internal.crypto import _rsa, _xor\n\n\n_ras_n = [\n    0x86, 0x86, 0x98, 0x0c, 0x0f, 0x5a, 0x24, 0xc4, ", "_ras_n = [\n    0x86, 0x86, 0x98, 0x0c, 0x0f, 0x5a, 0x24, 0xc4, \n    0xb9, 0xd4, 0x30, 0x20, 0xcd, 0x2c, 0x22, 0x70, \n    0x3f, 0xf3, 0xf4, 0x50, 0x75, 0x65, 0x29, 0x05, \n    0x8b, 0x1c, 0xf8, 0x8f, 0x09, 0xb8, 0x60, 0x21, \n    0x36, 0x47, 0x71, 0x98, 0xa6, 0xe2, 0x68, 0x31, \n    0x49, 0x65, 0x9b, 0xd1, 0x22, 0xc3, 0x35, 0x92, \n    0xfd, 0xb5, 0xad, 0x47, 0x94, 0x4a, 0xd1, 0xea, \n    0x4d, 0x36, 0xc6, 0xb1, 0x72, 0xaa, 0xd6, 0x33, \n    0x8c, 0x3b, 0xb6, 0xac, 0x62, 0x27, 0x50, 0x2d, ", "    0x4d, 0x36, 0xc6, 0xb1, 0x72, 0xaa, 0xd6, 0x33, \n    0x8c, 0x3b, 0xb6, 0xac, 0x62, 0x27, 0x50, 0x2d, \n    0x01, 0x09, 0x93, 0xac, 0x96, 0x7d, 0x1a, 0xef, \n    0x00, 0xf0, 0xc8, 0xe0, 0x38, 0xde, 0x2e, 0x4d, \n    0x3b, 0xc2, 0xec, 0x36, 0x8a, 0xf2, 0xe9, 0xf1, \n    0x0a, 0x6f, 0x1e, 0xda, 0x4f, 0x72, 0x62, 0xf1, \n    0x36, 0x42, 0x0c, 0x07, 0xc3, 0x31, 0xb8, 0x71, \n    0xbf, 0x13, 0x9f, 0x74, 0xf3, 0x01, 0x0e, 0x3c, \n    0x4f, 0xe5, 0x7d, 0xf3, 0xaf, 0xb7, 0x16, 0x83, \n]", "    0x4f, 0xe5, 0x7d, 0xf3, 0xaf, 0xb7, 0x16, 0x83, \n]\n\n_rsa_e = 0x10001\n\n_cipher = _rsa.Cipher(_ras_n, _rsa_e)\n\n\ndef generate_key() -> bytes:\n    return secrets.token_bytes(16)", "def generate_key() -> bytes:\n    return secrets.token_bytes(16)\n\n\ndef encode(key: bytes, input: str) -> str:\n    input_data = bytearray(input.encode())\n    _xor.transform(\n        key=_xor.derive_key(key, 4),\n        data=input_data\n    )\n    input_data.reverse()\n    _xor.transform(\n        key=_xor.client_key,\n        data=input_data\n    )\n    # Prepend key\n    input_data = key + input_data\n    return base64.b64encode(\n        _cipher.encrypt(input_data)\n    ).decode()", "\n\ndef decode(key: bytes, input: str) -> str:\n    input_data = bytearray( base64.b64decode(input) )\n    plaintext = _cipher.decrypt(input_data)\n\n    server_key, plaintext = plaintext[:16], plaintext[16:]\n    _xor.transform(\n        key=_xor.derive_key(server_key, 12),\n        data=plaintext\n    )\n    plaintext.reverse()\n    _xor.transform(\n        key=_xor.derive_key(key, 4),\n        data=plaintext\n    )\n    return plaintext.decode()", ""]}
{"filename": "py115/_internal/protocol/client.py", "chunked_list": ["__author__ = 'deadblue'\n\nimport json\nimport logging\nimport time\nimport warnings\nfrom urllib.parse import urlparse\nfrom urllib3.exceptions import InsecureRequestWarning\n\nimport requests", "\nimport requests\n\nfrom py115._internal.crypto import ec115\nfrom py115._internal.protocol.api import ApiSpec, RetryException\n\n\n_logger = logging.getLogger(__name__)\n\n\nclass Client:\n\n    def __init__(self, **kwargs) -> None:\n        self._ecc = ec115.Cipher()\n        self._session = requests.Session()\n        # Configure session\n        self._user_agent = 'Mozilla/5.0'\n        self._session.headers.update({\n            'User-Agent': self._user_agent\n        })\n        # Flow control\n        self._next_request_time = 0.0\n        # Protocol client settings\n        proxy_addr = kwargs.pop('proxy', None)\n        if proxy_addr is not None and isinstance(proxy_addr, str):\n            self._session.proxies = {\n                'http': proxy_addr,\n                'https': proxy_addr\n            }\n        verify = kwargs.pop('verify', None)\n        if verify is not None and isinstance(verify, bool):\n            self._session.verify = verify\n            if not verify:\n                warnings.simplefilter('ignore', category=InsecureRequestWarning)\n\n    def import_cookies(self, cookies: dict):\n        for name, value in cookies.items():\n            self._session.cookies.set(\n                name, value,\n                domain='.115.com',\n                path='/'\n            )\n\n    def export_cookies(self, url: str = None) -> dict:\n        req_domain, req_path = '.115.com', '/'\n        if url is not None:\n            result = urlparse(url)\n            req_domain = f'.{result.hostname}'\n            req_path = f'{result.path}/'\n\n        cookie_dict = {}\n        for cookie in self._session.cookies:\n            # Check domain\n            cookie_domain = cookie.domain\n            if not cookie_domain.startswith('.'):\n                cookie_domain = f'.{cookie_domain}'\n            if not req_domain.endswith(cookie_domain): continue\n            # Check path\n            cookie_path = cookie.path\n            if not cookie_path.endswith('/'):\n                cookie_path = f'{cookie_path}/'\n            if not req_path.startswith(cookie_path): continue\n            # Add cookie to dict\n            cookie_dict[cookie.name] = cookie.value\n        return cookie_dict\n\n    def setup_user_agent(self, app_version: str):\n        self._user_agent = 'Mozilla/5.0 115Desktop/%s' % app_version\n        self._session.headers.update({\n            'User-Agent': self._user_agent\n        })\n\n    @property\n    def user_agent(self) -> str:\n        return self._user_agent\n\n    def execute_api(self, spec: ApiSpec):\n        while True:\n            try:\n                return self._execute_api_internal(spec)\n            except RetryException:\n                pass\n\n    def _execute_api_internal(self, spec: ApiSpec):\n        if spec.use_ec:\n            spec.update_qs({\n                'k_ec': self._ecc.encode_token(int(time.time()))\n            })\n        data = spec.payload\n        # Flow control\n        wait_time = self._next_request_time - time.time()\n        if wait_time > 0:\n            time.sleep(wait_time)\n        try:\n            if data is None:\n                resp = self._session.get(url=spec.url, params=spec.qs)\n            else:\n                if spec.use_ec:\n                    data = self._ecc.encode(data)\n                resp = self._session.post(\n                    url=spec.url, \n                    params=spec.qs, \n                    data=data,\n                    headers={\n                        'Content-Type': 'application/x-www-form-urlencoded'\n                    }\n                )\n        finally:\n            self._next_request_time = time.time() + spec.get_delay()\n        if spec.use_ec:\n            result = json.loads(self._ecc.decode(resp.content))\n        else:\n            result = resp.json()\n        _logger.debug('API result: %r', result)\n        return spec.parse_result(result)\n\n    def fetch(self, url: str) -> bytes:\n        resp = self._session.get(url)\n        return resp.content", "\n\nclass Client:\n\n    def __init__(self, **kwargs) -> None:\n        self._ecc = ec115.Cipher()\n        self._session = requests.Session()\n        # Configure session\n        self._user_agent = 'Mozilla/5.0'\n        self._session.headers.update({\n            'User-Agent': self._user_agent\n        })\n        # Flow control\n        self._next_request_time = 0.0\n        # Protocol client settings\n        proxy_addr = kwargs.pop('proxy', None)\n        if proxy_addr is not None and isinstance(proxy_addr, str):\n            self._session.proxies = {\n                'http': proxy_addr,\n                'https': proxy_addr\n            }\n        verify = kwargs.pop('verify', None)\n        if verify is not None and isinstance(verify, bool):\n            self._session.verify = verify\n            if not verify:\n                warnings.simplefilter('ignore', category=InsecureRequestWarning)\n\n    def import_cookies(self, cookies: dict):\n        for name, value in cookies.items():\n            self._session.cookies.set(\n                name, value,\n                domain='.115.com',\n                path='/'\n            )\n\n    def export_cookies(self, url: str = None) -> dict:\n        req_domain, req_path = '.115.com', '/'\n        if url is not None:\n            result = urlparse(url)\n            req_domain = f'.{result.hostname}'\n            req_path = f'{result.path}/'\n\n        cookie_dict = {}\n        for cookie in self._session.cookies:\n            # Check domain\n            cookie_domain = cookie.domain\n            if not cookie_domain.startswith('.'):\n                cookie_domain = f'.{cookie_domain}'\n            if not req_domain.endswith(cookie_domain): continue\n            # Check path\n            cookie_path = cookie.path\n            if not cookie_path.endswith('/'):\n                cookie_path = f'{cookie_path}/'\n            if not req_path.startswith(cookie_path): continue\n            # Add cookie to dict\n            cookie_dict[cookie.name] = cookie.value\n        return cookie_dict\n\n    def setup_user_agent(self, app_version: str):\n        self._user_agent = 'Mozilla/5.0 115Desktop/%s' % app_version\n        self._session.headers.update({\n            'User-Agent': self._user_agent\n        })\n\n    @property\n    def user_agent(self) -> str:\n        return self._user_agent\n\n    def execute_api(self, spec: ApiSpec):\n        while True:\n            try:\n                return self._execute_api_internal(spec)\n            except RetryException:\n                pass\n\n    def _execute_api_internal(self, spec: ApiSpec):\n        if spec.use_ec:\n            spec.update_qs({\n                'k_ec': self._ecc.encode_token(int(time.time()))\n            })\n        data = spec.payload\n        # Flow control\n        wait_time = self._next_request_time - time.time()\n        if wait_time > 0:\n            time.sleep(wait_time)\n        try:\n            if data is None:\n                resp = self._session.get(url=spec.url, params=spec.qs)\n            else:\n                if spec.use_ec:\n                    data = self._ecc.encode(data)\n                resp = self._session.post(\n                    url=spec.url, \n                    params=spec.qs, \n                    data=data,\n                    headers={\n                        'Content-Type': 'application/x-www-form-urlencoded'\n                    }\n                )\n        finally:\n            self._next_request_time = time.time() + spec.get_delay()\n        if spec.use_ec:\n            result = json.loads(self._ecc.decode(resp.content))\n        else:\n            result = resp.json()\n        _logger.debug('API result: %r', result)\n        return spec.parse_result(result)\n\n    def fetch(self, url: str) -> bytes:\n        resp = self._session.get(url)\n        return resp.content", ""]}
{"filename": "py115/_internal/protocol/api.py", "chunked_list": ["__author__ = 'deadblue'\n\nimport random\nimport typing\nimport urllib.parse\n\n\nclass ApiException(Exception):\n\n    def __init__(self, code: int, *args: object) -> None:\n        super().__init__(*args)\n        self._code = code\n    \n    @property\n    def error_code(self) -> int:\n        return self._code", "\n\nclass RetryException(Exception):\n\n    def __init__(self, *args: object) -> None:\n        super().__init__(*args)\n\n\n_ERROR_CODE_FIELDS = [\n    'errcode', 'errNo', 'errno', 'code'", "_ERROR_CODE_FIELDS = [\n    'errcode', 'errNo', 'errno', 'code'\n]\n\ndef find_error_code(result: dict) -> int:\n    if result.get('state', False):\n        return 0\n    for field in _ERROR_CODE_FIELDS:\n        if field not in result:\n            continue\n        ec = result[field]\n        if isinstance(ec, int) and ec > 0:\n            return ec\n    return -1", "\n\ndef _flat_params(params: dict) -> dict:\n    flatted_params = {}\n    for key, value in params.items():\n        if isinstance(value, typing.Dict):\n            for sub_k, sub_v in value.items():\n                sub_k = '%s[%s]' % (key, sub_k)\n                flatted_params[sub_k], str(sub_v)\n        elif isinstance(value, (typing.List, typing.Tuple)):\n            for sub_i, sub_v in enumerate(value):\n                sub_k = '%s[%d]' % (key, sub_i)\n                flatted_params[sub_k] = str(sub_v)\n        else:\n            flatted_params[key] = str(value)\n    return flatted_params", "\n\nclass ApiSpec:\n\n    def __init__(self, url: str, use_ec: bool = False) -> None:\n        self._url = url\n        self._use_ec = use_ec\n        self._qs = {}\n        self._form = {}\n\n    @property\n    def url(self) -> str:\n        return self._url\n\n    @property\n    def use_ec(self) -> bool:\n        return self._use_ec\n\n    @property\n    def qs(self) -> dict:\n        return self._qs\n\n    @property\n    def payload(self) -> bytes:\n        if len(self._form) > 0:\n            return urllib.parse.urlencode(self._form).encode()\n        else:\n            return None\n\n    def update_qs(self, params: dict):\n        if self._qs is None:\n            self._qs = _flat_params(params)\n        else:\n            self._qs.update(_flat_params(params))\n\n    def update_from(self, params: dict):\n        if self._form is None:\n            self._form = _flat_params(params)\n        else:\n            self._form.update(_flat_params(params))\n\n    def parse_result(self, result: dict) -> typing.Any:\n        if 'data' in result:\n            return result['data']\n        error_code = find_error_code(result)\n        if error_code == 0:\n            return None\n        else:\n            raise ApiException(error_code)\n\n    def get_delay(self) -> float:\n        return random.randint(100, 500) / 1000.0", ""]}
{"filename": "py115/_internal/protocol/__init__.py", "chunked_list": ["__author__ = 'deadblue'\n"]}
{"filename": "py115/_internal/api/offline.py", "chunked_list": ["__author__ = 'deadblue'\n\nimport typing\n\nfrom py115._internal.api import m115\nfrom py115._internal.protocol import api\n\n\nclass ListApi(api.ApiSpec):\n    \n    def __init__(self, page: int = 1) -> None:\n        super().__init__('https://lixian.115.com/lixian/', True)\n        self.update_qs({\n            'ct': 'lixian',\n            'ac': 'task_lists',\n            'page': page\n        })\n\n    def set_page(self, page: int):\n        self.update_qs({\n            'page': page\n        })\n\n    def parse_result(self, result: dict) -> typing.Any:\n        error_code = api.find_error_code(result)\n        if error_code != 0:\n            raise api.ApiException(error_code)\n        tasks = result.get('tasks', None)\n        return {\n            'page_count': result.get('page_count', 1),\n            'page': result.get('page', 1),\n            'task_count': result.get('count', 0),\n            'tasks': tasks or []\n        }", "class ListApi(api.ApiSpec):\n    \n    def __init__(self, page: int = 1) -> None:\n        super().__init__('https://lixian.115.com/lixian/', True)\n        self.update_qs({\n            'ct': 'lixian',\n            'ac': 'task_lists',\n            'page': page\n        })\n\n    def set_page(self, page: int):\n        self.update_qs({\n            'page': page\n        })\n\n    def parse_result(self, result: dict) -> typing.Any:\n        error_code = api.find_error_code(result)\n        if error_code != 0:\n            raise api.ApiException(error_code)\n        tasks = result.get('tasks', None)\n        return {\n            'page_count': result.get('page_count', 1),\n            'page': result.get('page', 1),\n            'task_count': result.get('count', 0),\n            'tasks': tasks or []\n        }", "\n\nclass DeleteApi(api.ApiSpec):\n\n    def __init__(self, task_ids: typing.Iterable[str]) -> None:\n        super().__init__('https://lixian.115.com/lixian/', True)\n        self.update_qs({\n            'ct': 'lixian',\n            'ac': 'task_del'\n        })\n        self.update_from({\n            'hash': task_ids,\n            'flag': '0',\n        })", "\n\nclass ClearApi(api.ApiSpec):\n\n    def __init__(self, flag: int) -> None:\n        super().__init__('https://lixian.115.com/lixian/', True)\n        self.update_qs({\n            'ct': 'lixian',\n            'ac': 'task_clear'\n        })\n        self.update_from({\n            'flag': flag\n        })", "\n\nclass AddUrlsApi(m115.M115ApiSpec):\n    \n    def __init__(self, app_ver: str, user_id: int, urls: typing.Iterable[str], **kwargs) -> None:\n        super().__init__('https://lixian.115.com/lixianssp/', True)\n        self.update_qs({\n            'ac': 'add_task_urls'\n        })\n        params = {\n            'ac': 'add_task_urls',\n            'app_ver': app_ver,\n            'uid': user_id,\n            'url': urls\n        }\n        save_dir_id = kwargs.pop('save_dir_id', None)\n        if save_dir_id is not None:\n            params['wp_path_id'] = save_dir_id\n        self.update_from(params)\n    \n    def parse_result(self, result: dict):\n        result = super().parse_result(result)\n        return result['result']", ""]}
{"filename": "py115/_internal/api/version.py", "chunked_list": ["__author__ = 'deadblue'\n\nfrom py115._internal.protocol.api import ApiSpec\n\nclass GetApi(ApiSpec):\n    \n    def __init__(self) -> None:\n        super().__init__('https://appversion.115.com/1/web/1.0/api/chrome')\n\n    def parse_result(self, result: dict) -> str:\n        return result['data']['linux_115']['version_code']", ""]}
{"filename": "py115/_internal/api/space.py", "chunked_list": ["__author__ = 'deadblue'\n\nfrom py115._internal.protocol import api\n\nclass GetApi(api.ApiSpec):\n\n    def __init__(self) -> None:\n        super().__init__('https://webapi.115.com/files/index_info')\n    \n    def parse_result(self, result: dict):\n        data = super().parse_result(result)\n        return data.get('space_info', None)", ""]}
{"filename": "py115/_internal/api/upload.py", "chunked_list": ["__author__ = 'deadblue'\n\nimport datetime\nimport hashlib\nimport io\nimport logging\nimport time\nimport typing\n\nfrom py115._internal.protocol import api", "\nfrom py115._internal.protocol import api\n\n\n_logger = logging.getLogger(__name__)\n\n_token_salt = 'Qclm8MGWUv59TnrR0XPg'\n\n\nclass Helper:\n\n    _app_ver: str = None\n    _user_id: str = None\n    _user_key: str = None\n    _user_hash: str = None\n\n    def __init__(self, app_ver: str, user_id: int, user_key: str) -> None:\n        self._app_ver = app_ver\n        self._user_id = str(user_id)\n        self._user_key = user_key\n        self._user_hash = hashlib.md5(\n            self._user_id.encode()\n        ).hexdigest()\n    \n    @property\n    def app_version(self) -> str:\n        return self._app_ver\n    \n    @property\n    def user_id(self) -> str:\n        return self._user_id\n\n    def calc_sig(self, file_id: str, target_id: str) -> str:\n        h1 = hashlib.sha1(\n            f'{self._user_id}{file_id}{target_id}0'.encode()\n        ).hexdigest().lower()\n        return hashlib.sha1(\n            f'{self._user_key}{h1}000000'.encode()\n        ).hexdigest().upper()\n\n    def calc_token(\n            self, \n            file_id: str,\n            file_size: int,\n            timestamp: int,\n            sign_key: str = '',\n            sign_val: str = ''\n        ) -> str:\n        token_data = ''.join([\n            _token_salt, file_id, str(file_size), sign_key, sign_val, \n            self._user_id, str(timestamp), self._user_hash, self._app_ver\n        ]).encode()\n        return hashlib.md5(token_data).hexdigest().lower()", "\nclass Helper:\n\n    _app_ver: str = None\n    _user_id: str = None\n    _user_key: str = None\n    _user_hash: str = None\n\n    def __init__(self, app_ver: str, user_id: int, user_key: str) -> None:\n        self._app_ver = app_ver\n        self._user_id = str(user_id)\n        self._user_key = user_key\n        self._user_hash = hashlib.md5(\n            self._user_id.encode()\n        ).hexdigest()\n    \n    @property\n    def app_version(self) -> str:\n        return self._app_ver\n    \n    @property\n    def user_id(self) -> str:\n        return self._user_id\n\n    def calc_sig(self, file_id: str, target_id: str) -> str:\n        h1 = hashlib.sha1(\n            f'{self._user_id}{file_id}{target_id}0'.encode()\n        ).hexdigest().lower()\n        return hashlib.sha1(\n            f'{self._user_key}{h1}000000'.encode()\n        ).hexdigest().upper()\n\n    def calc_token(\n            self, \n            file_id: str,\n            file_size: int,\n            timestamp: int,\n            sign_key: str = '',\n            sign_val: str = ''\n        ) -> str:\n        token_data = ''.join([\n            _token_salt, file_id, str(file_size), sign_key, sign_val, \n            self._user_id, str(timestamp), self._user_hash, self._app_ver\n        ]).encode()\n        return hashlib.md5(token_data).hexdigest().lower()", "\n\nclass InfoApi(api.ApiSpec):\n\n    def __init__(self) -> None:\n        super().__init__('https://proapi.115.com/app/uploadinfo')\n\n    def parse_result(self, result: dict) -> typing.Tuple[int, str]:\n        err_code = api.find_error_code(result)\n        if err_code != 0:\n            raise api.ApiException(err_code)\n        return result.get('user_id'), result.get('userkey')", "\n\nclass InitApi(api.ApiSpec):\n\n    _helper: Helper = None\n    _file_io: typing.BinaryIO = None\n\n    def __init__(\n            self, \n            target_id: str, \n            file_name: str, \n            file_io: typing.BinaryIO,\n            helper: Helper\n        ) -> None:\n        super().__init__('https://uplb.115.com/4.0/initupload.php', True)\n        self._file_io = file_io\n        self._helper = helper\n        now = int(time.time())\n        file_size, file_hash = _digest_file(file_io)\n        self.update_from({\n            'appid': '0',\n            'appversion': helper.app_version,\n            'userid': helper.user_id,\n            'filename': file_name,\n            'filesize': file_size,\n            'fileid': file_hash,\n            'target': target_id,\n            'sig': helper.calc_sig(file_hash, target_id),\n            't': now,\n            'token': helper.calc_token(file_hash, file_size, now)\n        })\n\n    def parse_result(self, result: dict):\n        status = result['status']\n        if status == 7:\n            sign_key = result['sign_key']\n            sign_val = _digest_file_range(self._file_io, result['sign_check'])\n            now = int(time.time())\n            self.update_from({\n                'sign_key': sign_key,\n                'sign_val': sign_val,\n                't': now,\n                'token': self._helper.calc_token(\n                    self._form['fileid'], \n                    self._form['filesize'],\n                    now, sign_key, sign_val\n                )\n            })\n            raise api.RetryException()\n        elif status == 2:\n            return  {\n                'done': True\n            }\n        elif status == 1:\n            return {\n                'done': False,\n                'bucket': result['bucket'],\n                'object': result['object'],\n                'callback': result['callback']['callback'],\n                'callback_var': result['callback']['callback_var']\n            }\n        else:\n            _logger.warning('Unexpected upload init status: %d', status)\n            return None", "\n\ndef _digest_file(r: typing.BinaryIO) -> typing.Tuple[int, str]:\n    h = hashlib.sha1()\n    while True:\n        chunk = r.read(4096)\n        if len(chunk) == 0: break\n        h.update(chunk)\n    file_size = r.tell()\n    file_hash = h.hexdigest().upper()\n    return file_size, file_hash", "\n\ndef _digest_file_range(r: typing.BinaryIO, check_range: str) :\n    tmp = [int(x) for x in check_range.split('-')]\n    start, length = tmp[0], tmp[1] - tmp[0] + 1\n    r.seek(start, io.SEEK_SET)\n    return hashlib.sha1(\n        r.read(length)\n    ).hexdigest().upper()\n", "\n\nclass TokenApi(api.ApiSpec):\n\n    def __init__(self) -> None:\n        super().__init__('https://uplb.115.com/3.0/gettoken.php')\n    \n    def parse_result(self, result: dict):\n        if result.get('StatusCode' '') == '200':\n            return {\n                'access_key_id': result['AccessKeyId'],\n                'access_key_secret': result['AccessKeySecret'],\n                'security_token': result['SecurityToken'],\n                'expiration': datetime.datetime.strptime(\n                    result['Expiration'], '%Y-%m-%dT%H:%M:%SZ'\n                )\n            }\n        return None", ""]}
{"filename": "py115/_internal/api/__init__.py", "chunked_list": ["__author__ = 'deadblue'\n\n"]}
{"filename": "py115/_internal/api/dir.py", "chunked_list": ["__author__ = 'deadblue'\n\nfrom py115._internal.protocol import api\n\n\nclass AddApi(api.ApiSpec):\n\n    def __init__(self, parent_id: str, dir_name: str) -> None:\n        super().__init__('https://webapi.115.com/files/add')\n        self.update_from({\n            'pid': parent_id,\n            'cname': dir_name\n        })\n    \n    def parse_result(self, result: dict) -> dict:\n        err_code = api.find_error_code(result)\n        if err_code != 0:\n            raise api.ApiException(err_code)\n        return {\n            'cid': result.get('cid'),\n            'n': result.get('cname')\n        }", "\n\nclass SortApi(api.ApiSpec):\n\n    def __init__(self, dir_id: str, order: str, asc: bool = False) -> None:\n        super().__init__('https://webapi.115.com/files/order')\n        self.update_from({\n            'file_id': dir_id,\n            'user_order': order,\n            'user_asc': '1' if asc else '0',\n            'fc_mix': '0'\n        })", ""]}
{"filename": "py115/_internal/api/file.py", "chunked_list": ["__author__ = 'deadblue'\n\nimport time\nimport typing\n\nfrom py115._internal.api import m115\nfrom py115._internal.protocol import api\n\n\nclass ListApi(api.ApiSpec):\n\n    def __init__(self, dir_id: str) -> None:\n        super().__init__(None)\n        self.update_qs({\n            'aid': '1',\n            'cid': dir_id,\n            'o': 'user_ptime',\n            'asc': '0',\n            'offset': '0',\n            'limit': '115',\n            'show_dir': '1',\n            'snap': '0',\n            'natsort': '1',\n            'format': 'json',\n        })\n\n    @property\n    def url(self) -> str:\n        order = self._qs.get('o')\n        if order == 'file_name':\n            return 'https://aps.115.com/natsort/files.php'\n        else:\n            return 'https://webapi.115.com/files'\n\n    def parse_result(self, result: dict) -> dict:\n        if result.get('state', False):\n            return {\n                'count': result.get('count'),\n                'offset': result.get('offset'),\n                'files': result.get('data')\n            }\n        else:\n            err_code = api.find_error_code(result)\n            if err_code == 20130827:\n                self._qs.update({\n                    'o': result['order'],\n                    'asc': result['is_asc'],\n                })\n                raise api.RetryException()\n            else:\n                raise api.ApiException(err_code)\n\n    def set_offset(self, offset: int):\n        self.update_qs({\n            'offset': str(offset)\n        })", "\nclass ListApi(api.ApiSpec):\n\n    def __init__(self, dir_id: str) -> None:\n        super().__init__(None)\n        self.update_qs({\n            'aid': '1',\n            'cid': dir_id,\n            'o': 'user_ptime',\n            'asc': '0',\n            'offset': '0',\n            'limit': '115',\n            'show_dir': '1',\n            'snap': '0',\n            'natsort': '1',\n            'format': 'json',\n        })\n\n    @property\n    def url(self) -> str:\n        order = self._qs.get('o')\n        if order == 'file_name':\n            return 'https://aps.115.com/natsort/files.php'\n        else:\n            return 'https://webapi.115.com/files'\n\n    def parse_result(self, result: dict) -> dict:\n        if result.get('state', False):\n            return {\n                'count': result.get('count'),\n                'offset': result.get('offset'),\n                'files': result.get('data')\n            }\n        else:\n            err_code = api.find_error_code(result)\n            if err_code == 20130827:\n                self._qs.update({\n                    'o': result['order'],\n                    'asc': result['is_asc'],\n                })\n                raise api.RetryException()\n            else:\n                raise api.ApiException(err_code)\n\n    def set_offset(self, offset: int):\n        self.update_qs({\n            'offset': str(offset)\n        })", "\n\nclass SearchApi(api.ApiSpec):\n\n    def __init__(self, keyword: str, dir_id: str) -> None:\n        super().__init__('https://webapi.115.com/files/search')\n        self.update_qs({\n            'aid': '1',\n            'cid': dir_id,\n            'offset': '0',\n            'limit': '115',\n            'format': 'json',\n            'search_value': keyword\n        })\n    \n    def parse_result(self, result: dict) -> dict:\n        if result.get('state', False):\n            return {\n                'count': result.get('count'),\n                'offset': result.get('offset'),\n                'files': result.get('data')\n            }\n        else:\n            raise api.ApiException(api.find_error_code(result))\n\n    def set_offset(self, offset: int):\n        self.update_qs({\n            'offset': str(offset)\n        })", "\n\nclass DeleteApi(api.ApiSpec):\n\n    def __init__(self, file_ids: typing.Iterable[str]) -> None:\n        super().__init__('https://webapi.115.com/rb/delete')\n        self.update_from({\n            'fid': file_ids,\n            'ignore_warn': '1'\n        })", "\n\nclass MoveApi(api.ApiSpec):\n\n    def __init__(self, parent_id: str, file_ids: typing.Iterable[str]) -> None:\n        super().__init__('https://webapi.115.com/files/move')\n        self.update_from({\n            'pid': parent_id,\n            'fid': file_ids\n        })", "\n\nclass RenameApi(api.ApiSpec):\n\n    def __init__(self, file_id: str, new_name: str) -> None:\n        super().__init__('https://webapi.115.com/files/batch_rename')\n        key = 'files_new_name[%s]' % file_id\n        self.update_from({\n            key: new_name\n        })", "\n\nclass DownloadApi(m115.M115ApiSpec):\n\n    def __init__(self, pickcode: str) -> None:\n        super().__init__('https://proapi.115.com/app/chrome/downurl', True)\n        self.update_qs({\n            't': int(time.time())\n        })\n        self.update_from({\n            'pickcode': pickcode\n        })\n\n    def parse_result(self, result: dict):\n        result = super().parse_result(result)\n        if len(result) == 0:\n            return None\n        file_id, down_info = result.popitem()\n        if 'url' in down_info and isinstance(down_info['url'], dict):\n            return {\n                'file_id': file_id,\n                'file_name': down_info['file_name'],\n                'fize_size': int(down_info['file_size']),\n                'url': down_info['url']['url'].replace('http://', 'https://')\n            }\n        else:\n            return None", "\n\nclass VideoApi(api.ApiSpec):\n\n    def __init__(self, pickcode: str) -> None:\n        super().__init__('https://webapi.115.com/files/video', False)\n        self.update_qs({'pickcode': pickcode})\n    \n    def parse_result(self, result: dict) -> str:\n        err_code = api.find_error_code(result)\n        if err_code != 0:\n            raise api.ApiException(code=err_code)\n        return result.get('video_url')", ""]}
{"filename": "py115/_internal/api/user.py", "chunked_list": ["__author__ = 'deadblue'\n\nfrom py115._internal.protocol.api import ApiSpec\n\nclass GetApi(ApiSpec):\n    def __init__(self) -> None:\n        super().__init__('https://my.115.com/?ct=ajax&ac=nav')\n"]}
{"filename": "py115/_internal/api/m115.py", "chunked_list": ["__author__ = 'deadblue'\n\nimport json\nimport urllib\n\nfrom py115._internal.crypto import m115\nfrom py115._internal.protocol import api\n\n\nclass M115ApiSpec(api.ApiSpec):\n\n    def __init__(self, url: str, use_ec: bool = False) -> None:\n        super().__init__(url, use_ec)\n        self._m_key = m115.generate_key()\n\n    @property\n    def payload(self) -> bytes:\n        data = m115.encode(self._m_key, json.dumps(self._form))\n        return urllib.parse.urlencode({\n            'data': data\n        }).encode()\n\n    def parse_result(self, result: dict):\n        data = super().parse_result(result)\n        # M115 decode\n        return json.loads(m115.decode(self._m_key, data))", "\nclass M115ApiSpec(api.ApiSpec):\n\n    def __init__(self, url: str, use_ec: bool = False) -> None:\n        super().__init__(url, use_ec)\n        self._m_key = m115.generate_key()\n\n    @property\n    def payload(self) -> bytes:\n        data = m115.encode(self._m_key, json.dumps(self._form))\n        return urllib.parse.urlencode({\n            'data': data\n        }).encode()\n\n    def parse_result(self, result: dict):\n        data = super().parse_result(result)\n        # M115 decode\n        return json.loads(m115.decode(self._m_key, data))", ""]}
{"filename": "py115/_internal/api/qrcode.py", "chunked_list": ["__author__ = 'deadblue'\n\nimport time as timelib\nimport typing\n\nfrom py115._internal.protocol import api\n\n\n_app_id_mapping = {\n    'web': 0,", "_app_id_mapping = {\n    'web': 0,\n    'mac': 7,\n    'linux': 7,\n    'windows': 7,\n}\n\n\nclass _BaseApi(api.ApiSpec):\n\n    def parse_result(self, result: dict) -> typing.Any:\n        if result.get('state', 0) != 1:\n            raise api.ApiException(code=result.get('code'))\n        return result.get('data')", "class _BaseApi(api.ApiSpec):\n\n    def parse_result(self, result: dict) -> typing.Any:\n        if result.get('state', 0) != 1:\n            raise api.ApiException(code=result.get('code'))\n        return result.get('data')\n\n\nclass TokenApi(_BaseApi):\n\n    def __init__(self, app_name: str) -> None:\n        super().__init__(\n            f'https://qrcodeapi.115.com/api/1.0/{app_name}/1.0/token', True\n        )", "class TokenApi(_BaseApi):\n\n    def __init__(self, app_name: str) -> None:\n        super().__init__(\n            f'https://qrcodeapi.115.com/api/1.0/{app_name}/1.0/token', True\n        )\n\n\nclass StatusApi(_BaseApi):\n\n    def __init__(self, uid: str, time: int, sign: str) -> None:\n        super().__init__('https://qrcodeapi.115.com/get/status/', False)\n        self.update_qs({\n            'uid': uid,\n            'time': time,\n            'sign': sign,\n            '_': int(timelib.time())\n        })\n\n    def parse_result(self, result: dict) -> int:\n        code = result.get('code', 0)\n        if code == 40199002:\n            return -9\n        elif code != 0:\n            raise api.ApiException(code)\n        result_data = result.get('data', {})\n        return result_data.get('status', 0)", "class StatusApi(_BaseApi):\n\n    def __init__(self, uid: str, time: int, sign: str) -> None:\n        super().__init__('https://qrcodeapi.115.com/get/status/', False)\n        self.update_qs({\n            'uid': uid,\n            'time': time,\n            'sign': sign,\n            '_': int(timelib.time())\n        })\n\n    def parse_result(self, result: dict) -> int:\n        code = result.get('code', 0)\n        if code == 40199002:\n            return -9\n        elif code != 0:\n            raise api.ApiException(code)\n        result_data = result.get('data', {})\n        return result_data.get('status', 0)", "\n\nclass LoginApi(_BaseApi):\n\n    def __init__(self, app_name: str, uid: str) -> None:\n        super().__init__(\n            f'https://passportapi.115.com/app/1.0/{app_name}/1.0/login/qrcode', True\n        )\n        self.update_from({\n            'account': uid,\n            'app': app_name\n        })", "\n\ndef get_image_url(app_name: str, uid: str) -> str:\n    app_id = _app_id_mapping.get(app_name, 0)\n    return f'https://qrcodeapi.115.com/api/1.0/{app_name}/1.0/qrcode?qrfrom=1&client={app_id}d&uid={uid}'\n"]}
{"filename": "docs/conf.py", "chunked_list": ["# Configuration file for the Sphinx documentation builder.\n#\n# For the full list of built-in configuration values, see the documentation:\n# https://www.sphinx-doc.org/en/master/usage/configuration.html\n\nimport sys\nimport os\n\nsys.path.insert(0, os.path.abspath(\"..\"))\n", "sys.path.insert(0, os.path.abspath(\"..\"))\n\nimport py115\n\n# -- Project information -----------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/configuration.html#project-information\n\nproject = 'PY115'\ncopyright = '2023, deadblue'\nauthor = 'deadblue'", "copyright = '2023, deadblue'\nauthor = 'deadblue'\nrelease = '0.0.1'\n\n# -- General configuration ---------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/configuration.html#general-configuration\n\nextensions = [\n    'sphinx.ext.autodoc',\n    'sphinx.ext.napoleon',", "    'sphinx.ext.autodoc',\n    'sphinx.ext.napoleon',\n    'sphinx_rtd_theme'\n]\n\ntemplates_path = ['_templates']\nexclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']\n\n# Extension configurations\nautodoc_member_order = 'bysource'", "# Extension configurations\nautodoc_member_order = 'bysource'\nautodoc_typehints = 'description'\nnapoleon_numpy_docstring = False\n\n# -- Options for HTML output -------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-html-output\n\nhtml_theme = 'sphinx_rtd_theme'\nhtml_static_path = ['_static']", "html_theme = 'sphinx_rtd_theme'\nhtml_static_path = ['_static']\n\n"]}
