{"filename": "tests/test_unit.py", "chunked_list": ["\"\"\"\n DEXSWAP Unit Test\n\"\"\"\nfrom unittest.mock import AsyncMock, patch\n\nimport pytest\nfrom web3 import EthereumTesterProvider, Web3\n\nfrom dxsp import DexSwap\nfrom dxsp.config import settings", "from dxsp import DexSwap\nfrom dxsp.config import settings\n\n\n@pytest.fixture(scope=\"session\", autouse=True)\ndef set_test_settings():\n    settings.configure(FORCE_ENV_FOR_DYNACONF=\"uniswap\")\n\n\n@pytest.fixture(name=\"dex\")\ndef DexSwap_fixture():\n    return DexSwap()", "\n@pytest.fixture(name=\"dex\")\ndef DexSwap_fixture():\n    return DexSwap()\n\n\n@pytest.fixture\ndef tester_provider():\n    return EthereumTesterProvider()\n", "\n\n@pytest.fixture(name=\"web3\")\ndef w3():\n    provider = EthereumTesterProvider()\n    return Web3(provider)\n\n\n@pytest.fixture(name=\"account\")\ndef account_fixture(web3) -> str:\n    \"\"\"setup account.\"\"\"\n    return web3.eth.accounts[0]", "@pytest.fixture(name=\"account\")\ndef account_fixture(web3) -> str:\n    \"\"\"setup account.\"\"\"\n    return web3.eth.accounts[0]\n\n\n@pytest.fixture(name=\"order\")\ndef order_params_fixture():\n    \"\"\"Return order parameters.\"\"\"\n    return {\n        'action': 'BUY',\n        'instrument': 'WBTC',\n        'quantity': 1,\n    }", "\n\n@pytest.fixture(name=\"invalid_order\")\ndef invalid_order_fixture():\n    \"\"\"Return order parameters.\"\"\"\n    return {\n        'action': 'BUY',\n        'instrument': 'NOTATHING',\n        'quantity': 1,\n    }", "\n\n@pytest.fixture(name=\"test_contract\")\ndef mock_contract(dex):\n    contract = AsyncMock()\n    contract.get_token_decimals.return_value = 18\n    contract.to_wei.return_value = 1000000000000000000\n    contract.functions.balanceOf = AsyncMock(return_value=100)\n    contract.wait_for_transaction_receipt.return_value = {\"status\": 1}\n    return contract", "\n\n@pytest.fixture(name=\"mock_dex\")\ndef mock_dex_transaction():\n    dex = DexSwap()\n    dex.w3.eth.get_transaction_count = AsyncMock(return_value=1)\n    dex.get_gas = AsyncMock(return_value=21000)\n    dex.get_gas_price = AsyncMock(return_value=1000000000)\n    dex.w3.eth.account.sign_transaction = (\n        AsyncMock(return_value=AsyncMock(rawTransaction=b'signed_transaction')))\n    dex.w3.eth.send_raw_transaction = AsyncMock(return_value=b'transaction_hash')\n    return dex", "\n\ndef test_dynaconf_is_in_testing():\n    print(settings.VALUE)\n    assert settings.VALUE == \"On Testing\"\n\n\n@pytest.mark.asyncio\nasync def test_dex(dex):\n    \"\"\"Init Testing\"\"\"", "async def test_dex(dex):\n    \"\"\"Init Testing\"\"\"\n    assert isinstance(dex, DexSwap)\n    assert dex.w3 is not None\n    assert dex.w3.net.version == \"1\"\n    assert dex.protocol_type is not None\n    assert dex.protocol_type == \"uniswap\"\n    assert dex.account.wallet_address.startswith(\"0x\")\n    assert dex.account.wallet_address == \"0x1a9C8182C09F50C8318d769245beA52c32BE35BC\"\n    assert dex.account.private_key.startswith(\"0x\")", "    assert dex.account.wallet_address == \"0x1a9C8182C09F50C8318d769245beA52c32BE35BC\"\n    assert dex.account.private_key.startswith(\"0x\")\n    assert \"1 - 32BE35BC\" in dex.account.account_number\n\n\n@pytest.mark.asyncio\nasync def test_execute_order(dex, order):\n    # sell_balance = AsyncMock()\n    # dex.get_swap = AsyncMock()\n    result = await dex.execute_order(order)", "    # dex.get_swap = AsyncMock()\n    result = await dex.execute_order(order)\n    print(f\"swap_order: {result}\")\n    assert result is not None\n\n\n@pytest.mark.asyncio\nasync def test_execute_order_invalid(dex, invalid_order):\n    result = await dex.execute_order(invalid_order)\n    print(result)", "    result = await dex.execute_order(invalid_order)\n    print(result)\n    assert result.startswith(\"\u26a0\ufe0f order execution: Invalid Token\")\n\n\n@pytest.mark.asyncio\nasync def test_get_quote(dex):\n    \"\"\"getquote Testing\"\"\"\n    result = await dex.get_quote(\"UNI\")\n    print(result)", "    result = await dex.get_quote(\"UNI\")\n    print(result)\n    assert result is not None\n    assert result.startswith(\"\ud83e\udd84\")\n\n\n@pytest.mark.asyncio\nasync def test_get_quote_BTC(account) -> str:\n    \"\"\"test token account.\"\"\"\n    with patch(\"dxsp.config.settings\", autospec=True):\n        settings.dex_wallet_address = account\n        dex = DexSwap()\n        result = await dex.get_quote('WBTC')\n        print(result)\n        assert result is not None", "    \"\"\"test token account.\"\"\"\n    with patch(\"dxsp.config.settings\", autospec=True):\n        settings.dex_wallet_address = account\n        dex = DexSwap()\n        result = await dex.get_quote('WBTC')\n        print(result)\n        assert result is not None\n\n\n@pytest.mark.asyncio", "\n@pytest.mark.asyncio\nasync def test_get_quote_invalid(dex):\n    result = await dex.get_quote(\"THISISNOTATOKEN\")\n    print(result)\n    assert result is not None\n    assert '\u26a0\ufe0f' in result\n"]}
{"filename": "tests/test_utils_explorer.py", "chunked_list": ["\"\"\"\n DEXSWAP Unit Test\n\"\"\"\nfrom unittest.mock import AsyncMock\n\nimport pytest\nfrom web3 import EthereumTesterProvider, Web3\n\nimport dxsp\nfrom dxsp import DexSwap", "import dxsp\nfrom dxsp import DexSwap\nfrom dxsp.config import settings\nfrom dxsp.utils.explorer_utils import get_account_transactions, get_explorer_abi\nfrom dxsp.utils.utils import get\n\n\n@pytest.fixture(scope=\"session\", autouse=True)\ndef set_test_settings():\n    settings.configure(FORCE_ENV_FOR_DYNACONF=\"uniswap\")", "def set_test_settings():\n    settings.configure(FORCE_ENV_FOR_DYNACONF=\"uniswap\")\n\n\n@pytest.fixture(name=\"dex\")\ndef DexSwap_fixture():\n    return DexSwap()\n\n\n@pytest.fixture\ndef tester_provider():\n    return EthereumTesterProvider()", "\n@pytest.fixture\ndef tester_provider():\n    return EthereumTesterProvider()\n\n\n@pytest.fixture(name=\"web3\")\ndef w3():\n    provider = EthereumTesterProvider()\n    return Web3(provider)", "\n\n@pytest.fixture(name=\"account\")\ndef account_fixture(web3) -> str:\n    \"\"\"setup account.\"\"\"\n    return web3.eth.accounts[0]\n\n\n@pytest.fixture(name=\"order\")\ndef order_params_fixture():\n    \"\"\"Return order parameters.\"\"\"\n    return {\n        'action': 'BUY',\n        'instrument': 'WBTC',\n        'quantity': 1,\n    }", "@pytest.fixture(name=\"order\")\ndef order_params_fixture():\n    \"\"\"Return order parameters.\"\"\"\n    return {\n        'action': 'BUY',\n        'instrument': 'WBTC',\n        'quantity': 1,\n    }\n\n", "\n\n@pytest.fixture(name=\"invalid_order\")\ndef invalid_order_fixture():\n    \"\"\"Return order parameters.\"\"\"\n    return {\n        'action': 'BUY',\n        'instrument': 'NOTATHING',\n        'quantity': 1,\n    }", "\n\n@pytest.fixture(name=\"test_contract\")\ndef mock_contract(dex):\n    contract = AsyncMock()\n    contract.get_token_decimals.return_value = 18\n    contract.to_wei.return_value = 1000000000000000000\n    contract.functions.balanceOf = AsyncMock(return_value=100)\n    contract.wait_for_transaction_receipt.return_value = {\"status\": 1}\n    return contract", "\n\n@pytest.fixture(name=\"mock_dex\")\ndef mock_dex_transaction():\n    dex = DexSwap()\n    dex.w3.eth.get_transaction_count = AsyncMock(return_value=1)\n    dex.get_gas = AsyncMock(return_value=21000)\n    dex.get_gas_price = AsyncMock(return_value=1000000000)\n    dex.w3.eth.account.sign_transaction = (\n        AsyncMock(return_value=AsyncMock(rawTransaction=b'signed_transaction')))\n    dex.w3.eth.send_raw_transaction = AsyncMock(return_value=b'transaction_hash')\n    return dex", "\n\ndef test_dynaconf_is_in_testing():\n    print(settings.VALUE)\n    assert settings.VALUE == \"On Testing\"\n\n\n\n@pytest.mark.asyncio\nasync def test_get():", "@pytest.mark.asyncio\nasync def test_get():\n    result = await get(\n        \"http://ip.jsontest.com\",\n        params=None,\n        headers=None)\n    assert result is not None\n\n\n@pytest.mark.asyncio", "\n@pytest.mark.asyncio\nasync def test_get_abi(dex, mocker):\n    mock_resp = {\"status\": \"1\", \"result\": \"0x0123456789abcdef\"}\n    mocker.patch.object(dxsp.utils.explorer_utils, \"get\", return_value=mock_resp)\n    result = await get_explorer_abi(\"0x1234567890123456789012345678901234567890\")\n    assert result == \"0x0123456789abcdef\"\n\n\n@pytest.mark.asyncio", "\n@pytest.mark.asyncio\nasync def test_invalid_get_abi():\n    result = await get_explorer_abi(\"0x1234567890123456789012345678901234567890\")\n    assert result is None\n\n\n@pytest.mark.asyncio\nasync def test_get_account_transactions(dex):\n    # Call the get_account_transactions method", "async def test_get_account_transactions(dex):\n    # Call the get_account_transactions method\n    result = await get_account_transactions(\n        '0xdAC17F958D2ee523a2206206994597C13D831ec7',\n        dex.account.wallet_address)\n    print(f\"history: {result}\")\n    assert result is not None\n    assert 'pnl' in result\n    assert 'tokenList' in result", "    assert 'tokenList' in result"]}
{"filename": "tests/test_unit_uniswap.py", "chunked_list": ["\"\"\"\n DEXSWAP Uniswap  Test\n\"\"\"\n\nimport pytest\n\nfrom dxsp import DexSwap\nfrom dxsp.config import settings\n\n", "\n\n@pytest.fixture(scope=\"session\", autouse=True)\ndef set_test_settings():\n    settings.configure(FORCE_ENV_FOR_DYNACONF=\"uniswap\")\n\n@pytest.fixture(name=\"dex\")\ndef DexSwap_fixture():\n    return DexSwap()\n", "\n@pytest.fixture(name=\"order\")\ndef order_params_fixture():\n    \"\"\"Return order parameters.\"\"\"\n    return {\n        'action': 'BUY',\n        'instrument': 'WBTC',\n        'quantity': 1,\n    }\n", "\n\ndef test_dynaconf_is_in_testing():\n    print(settings.VALUE)\n    assert settings.VALUE == \"On Testing\"\n\n\n@pytest.mark.asyncio\nasync def test_get_quote(dex):\n    result = await dex.get_quote(\"WBTC\")", "async def test_get_quote(dex):\n    result = await dex.get_quote(\"WBTC\")\n    print(f\"result: {result}\")\n    assert result is not None\n    assert result.startswith(\"\ud83e\udd84\")\n\n\n@pytest.mark.asyncio\nasync def test_get_swap(dex, order):\n    result = await dex.execute_order(order)", "async def test_get_swap(dex, order):\n    result = await dex.execute_order(order)\n    print(f\"result: {result}\")\n    assert result is not None\n"]}
{"filename": "tests/test_chain_56.py", "chunked_list": ["\"\"\"\n DEXSWAP Unit Test\n\"\"\"\n\nimport pytest\n\nfrom dxsp import DexSwap\nfrom dxsp.config import settings\n\n", "\n\n@pytest.fixture(scope=\"session\", autouse=True)\ndef set_test_settings():\n    settings.configure(FORCE_ENV_FOR_DYNACONF=\"bsc\")\n\n\n@pytest.fixture(name=\"dex\")\ndef DexSwap_fixture():\n    return DexSwap()", "def DexSwap_fixture():\n    return DexSwap()\n\n\n@pytest.fixture(name=\"order\")\ndef order_params_fixture():\n    \"\"\"Return order parameters.\"\"\"\n    return {\n        'action': 'BUY',\n        'instrument': 'WBTC',\n        'quantity': 1,\n    }", "\n\ndef test_dynaconf_is_in_testing():\n    print(settings.VALUE)\n    assert settings.VALUE == \"chain_56\"\n    assert settings.dex_wallet_address == \"0xf977814e90da44bfa03b6295a0616a897441acec\"\n    assert settings.dex_notify_invalid_token is False\n\n@pytest.mark.asyncio\nasync def test_get_quote(dex):", "@pytest.mark.asyncio\nasync def test_get_quote(dex):\n    \"\"\"getquote Testing\"\"\"\n    print(settings.VALUE)\n    quote = await dex.get_quote(\"BTCB\")\n    print(quote)\n    if quote:\n        assert settings.VALUE == \"chain_56\"\n        assert dex.w3.net.version == '56'\n        assert quote is not None\n        assert quote.startswith(\"\ud83e\udd84\")", "\n\n@pytest.mark.asyncio\nasync def test_execute_order(dex, order):\n    result = await dex.execute_order(order)\n    print(f\"result: {result}\")\n    assert result is not None\n"]}
{"filename": "tests/test_utils_contract.py", "chunked_list": ["\"\"\"\n DEXSWAP Unit Test\n\"\"\"\nimport decimal\nimport time\nfrom unittest.mock import AsyncMock, patch\n\nimport pytest\nfrom web3 import EthereumTesterProvider, Web3\n", "from web3 import EthereumTesterProvider, Web3\n\nfrom dxsp import DexSwap\nfrom dxsp.config import settings\n\n\n@pytest.fixture(scope=\"session\", autouse=True)\ndef set_test_settings():\n    settings.configure(FORCE_ENV_FOR_DYNACONF=\"uniswap\")\n", "\n\n@pytest.fixture(name=\"dex\")\ndef DexSwap_fixture():\n    return DexSwap()\n\n\n@pytest.fixture\ndef tester_provider():\n    return EthereumTesterProvider()", "def tester_provider():\n    return EthereumTesterProvider()\n\n\n@pytest.fixture(name=\"web3\")\ndef w3():\n    provider = EthereumTesterProvider()\n    return Web3(provider)\n\n", "\n\n@pytest.fixture(name=\"account\")\ndef account_fixture(web3) -> str:\n    \"\"\"setup account.\"\"\"\n    return web3.eth.accounts[0]\n\n\n@pytest.fixture(name=\"order\")\ndef order_params_fixture():\n    \"\"\"Return order parameters.\"\"\"\n    return {\n        'action': 'BUY',\n        'instrument': 'WBTC',\n        'quantity': 1,\n    }", "@pytest.fixture(name=\"order\")\ndef order_params_fixture():\n    \"\"\"Return order parameters.\"\"\"\n    return {\n        'action': 'BUY',\n        'instrument': 'WBTC',\n        'quantity': 1,\n    }\n\n", "\n\n@pytest.fixture(name=\"invalid_order\")\ndef invalid_order_fixture():\n    \"\"\"Return order parameters.\"\"\"\n    return {\n        'action': 'BUY',\n        'instrument': 'NOTATHING',\n        'quantity': 1,\n    }", "\n\n@pytest.fixture(name=\"test_contract\")\ndef mock_contract(dex):\n    contract = AsyncMock()\n    contract.get_token_decimals.return_value = 18\n    contract.to_wei.return_value = 1000000000000000000\n    contract.functions.balanceOf = AsyncMock(return_value=100)\n    contract.wait_for_transaction_receipt.return_value = {\"status\": 1}\n    return contract", "\n\n@pytest.fixture(name=\"mock_dex\")\ndef mock_dex_transaction():\n    dex = DexSwap()\n    dex.w3.eth.get_transaction_count = AsyncMock(return_value=1)\n    dex.get_gas = AsyncMock(return_value=21000)\n    dex.get_gas_price = AsyncMock(return_value=1000000000)\n    dex.w3.eth.account.sign_transaction = (\n        AsyncMock(return_value=AsyncMock(rawTransaction=b'signed_transaction')))\n    dex.w3.eth.send_raw_transaction = AsyncMock(return_value=b'transaction_hash')\n    return dex", "\n\ndef test_dynaconf_is_in_testing():\n    print(settings.VALUE)\n    assert settings.VALUE == \"On Testing\"\n\n\n@pytest.mark.asyncio\nasync def test_search_contract_address(dex):\n    result = await dex.contract_utils.search_contract_address(\"USDT\")", "async def test_search_contract_address(dex):\n    result = await dex.contract_utils.search_contract_address(\"USDT\")\n    assert result is not None\n    assert result == \"0xdAC17F958D2ee523a2206206994597C13D831ec7\"\n    print(result)\n\n\n@pytest.mark.asyncio\nasync def test_invalid_search_contract_address(dex):\n    with pytest.raises(ValueError, match='Invalid Token'):\n        await dex.contract_utils.search_contract_address(\"NOTATHING\")", "async def test_invalid_search_contract_address(dex):\n    with pytest.raises(ValueError, match='Invalid Token'):\n        await dex.contract_utils.search_contract_address(\"NOTATHING\")\n\n\n@pytest.mark.asyncio\nasync def test_get_token_contract(dex):\n    \"\"\"get_token_contract Testing\"\"\"\n    result = await dex.contract_utils.get_token_contract(\n        \"0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984\")", "    result = await dex.contract_utils.get_token_contract(\n        \"0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984\")\n    print(type(result))\n    assert result is not None\n    assert type(result) is not None\n    assert result.functions is not None\n\n\n@pytest.mark.asyncio\nasync def test_get_decimals(dex):", "@pytest.mark.asyncio\nasync def test_get_decimals(dex):\n    \"\"\"get_token_decimals Testing\"\"\"\n    result = await dex.contract_utils.get_token_decimals(\n        \"0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984\")\n    print(result)\n    time.sleep(5)\n    assert result is not None\n    assert result == 18\n", "    assert result == 18\n\n\n@pytest.mark.asyncio\nasync def test_get_decimals_stable(dex):\n    \"\"\"get_token_decimals Testing\"\"\"\n    result = await dex.contract_utils.get_token_decimals(\n        \"0xdAC17F958D2ee523a2206206994597C13D831ec7\")\n    print(result)\n    time.sleep(5)", "    print(result)\n    time.sleep(5)\n    assert result is not None\n    assert result == 6\n\n\n@pytest.mark.asyncio\nasync def test_get_token_symbol(dex):\n    \"\"\"get_token_symbol Testing\"\"\"\n    result = await dex.contract_utils.get_token_symbol(", "    \"\"\"get_token_symbol Testing\"\"\"\n    result = await dex.contract_utils.get_token_symbol(\n        \"0xdAC17F958D2ee523a2206206994597C13D831ec7\")\n    print(result)\n    assert result is not None\n    assert result == 'USDT'\n\n\n@pytest.mark.asyncio\nasync def test_get_token_name(dex):", "@pytest.mark.asyncio\nasync def test_get_token_name(dex):\n    \"\"\"get_token_symbol Testing\"\"\"\n    result = await dex.contract_utils.get_token_name(\n        \"0xdAC17F958D2ee523a2206206994597C13D831ec7\")\n    print(result)\n    assert result is not None\n    assert result == 'Tether USD'\n\n", "\n\n@pytest.mark.asyncio\nasync def test_get_token_balance(dex):\n    # Call the get_token_balance method\n    result = await dex.contract_utils.get_token_balance(\n        \"0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984\",\n        dex.account.wallet_address)\n    print(\"balance \", result)\n    print(\"balance \", type(result))", "    print(\"balance \", result)\n    print(\"balance \", type(result))\n    assert result is not None\n    assert result >= 0\n    assert isinstance(result, decimal.Decimal)\n\n\n@pytest.mark.asyncio\nasync def test_token_balance(account) -> str:\n    \"\"\"test token account.\"\"\"\n    with patch(\"dxsp.config.settings\", autospec=True):\n        settings.dex_wallet_address = account\n        # with pytest.raises(ValueError, match='No Balance'):\n        dex = DexSwap()\n        result = await dex.contract_utils.get_token_balance(\n            settings.trading_asset_address,\n            account)\n        print(result)\n        assert result is not None", "async def test_token_balance(account) -> str:\n    \"\"\"test token account.\"\"\"\n    with patch(\"dxsp.config.settings\", autospec=True):\n        settings.dex_wallet_address = account\n        # with pytest.raises(ValueError, match='No Balance'):\n        dex = DexSwap()\n        result = await dex.contract_utils.get_token_balance(\n            settings.trading_asset_address,\n            account)\n        print(result)\n        assert result is not None", "\n\n@pytest.mark.asyncio\nasync def calculate_sell_amount(dex):\n    pass\n\n\n@pytest.mark.asyncio\nasync def test_get_confirmation(dex):\n    result = await dex.contract_utils.get_confirmation(", "async def test_get_confirmation(dex):\n    result = await dex.contract_utils.get_confirmation(\n        \"0xda56e5f1a26241a03d3f96740989e432ca41ae35b5a1b44bcb37aa2cf7772771\")\n    print(result)\n    assert result is not None\n    assert result['timestamp'] is not None\n    assert result['fee'] is not None\n    assert result['confirmation'] is not None\n    assert result['confirmation'].startswith('\u2795')\n    assert '\u26fd' in result['confirmation']", "    assert result['confirmation'].startswith('\u2795')\n    assert '\u26fd' in result['confirmation']\n    assert '\ud83d\uddd3\ufe0f' in result['confirmation']\n    assert '\u2139\ufe0f' in result['confirmation']\n"]}
{"filename": "tests/__init__.py", "chunked_list": [""]}
{"filename": "tests/test_chain_5.py", "chunked_list": ["\"\"\"\n DEXSWAP Unit Test\n\"\"\"\nimport pytest\n\nfrom dxsp import DexSwap\nfrom dxsp.config import settings\n\n\n@pytest.fixture(scope=\"session\", autouse=True)\ndef set_test_settings():\n    settings.configure(FORCE_ENV_FOR_DYNACONF=\"testnet\")", "\n@pytest.fixture(scope=\"session\", autouse=True)\ndef set_test_settings():\n    settings.configure(FORCE_ENV_FOR_DYNACONF=\"testnet\")\n\n@pytest.fixture(name=\"dex\")\ndef DexSwap_fixture():\n    return DexSwap()\n\n\ndef test_dynaconf_is_in_testing():\n    print(settings.VALUE)\n    assert settings.VALUE == \"On Testnet\"\n    assert settings.dex_wallet_address == \"0x1a9C8182C09F50C8318d769245beA52c32BE35BC\"", "\n\ndef test_dynaconf_is_in_testing():\n    print(settings.VALUE)\n    assert settings.VALUE == \"On Testnet\"\n    assert settings.dex_wallet_address == \"0x1a9C8182C09F50C8318d769245beA52c32BE35BC\"\n\n\n# @pytest.mark.asyncio\n# async def test_get_quote(dex):", "# @pytest.mark.asyncio\n# async def test_get_quote(dex):\n#     \"\"\"getquote Testing\"\"\"\n#     print(settings.VALUE)\n#     quote = await dex.get_quote(\"wBTC\")\n#     print(quote)\n#     if quote:\n#         assert settings.VALUE\n#         assert dex.w3.net.version == '5'\n#         assert quote is not None", "#         assert dex.w3.net.version == '5'\n#         assert quote is not None\n#         assert quote.startswith(\"\ud83e\udd84\")\n\n\n# @pytest.mark.asyncio\n# async def test_get_swap(dex, account, order): \n#     \"\"\"test token account.\"\"\"\n#     with patch(\"dxsp.config.settings\", autospec=True):\n#         settings.dex_wallet_address = account", "#     with patch(\"dxsp.config.settings\", autospec=True):\n#         settings.dex_wallet_address = account\n#         dex = DexSwap()\n#         swap_order = await dex.execute_order(order)\n#         print(swap_order)\n\n\n# @pytest.mark.asyncio\n# async def test_get_swap_invalid(dex, order):\n#     with pytest.raises(ValueError):", "# async def test_get_swap_invalid(dex, order):\n#     with pytest.raises(ValueError):\n#         await dex.execute_order(order)"]}
{"filename": "tests/test_utils_account.py", "chunked_list": ["\"\"\"\n DEXSWAP Unit Test\n\"\"\"\nfrom unittest.mock import AsyncMock, patch\n\nimport pytest\nfrom web3 import EthereumTesterProvider, Web3\n\nfrom dxsp import DexSwap\nfrom dxsp.config import settings", "from dxsp import DexSwap\nfrom dxsp.config import settings\n\n\n@pytest.fixture(scope=\"session\", autouse=True)\ndef set_test_settings():\n    settings.configure(FORCE_ENV_FOR_DYNACONF=\"uniswap\")\n\n\n@pytest.fixture(name=\"dex\")\ndef DexSwap_fixture():\n    return DexSwap()", "\n@pytest.fixture(name=\"dex\")\ndef DexSwap_fixture():\n    return DexSwap()\n\n\n@pytest.fixture\ndef tester_provider():\n    return EthereumTesterProvider()\n", "\n\n@pytest.fixture(name=\"web3\")\ndef w3():\n    provider = EthereumTesterProvider()\n    return Web3(provider)\n\n\n@pytest.fixture(name=\"account\")\ndef account_fixture(web3) -> str:\n    \"\"\"setup account.\"\"\"\n    return web3.eth.accounts[0]", "@pytest.fixture(name=\"account\")\ndef account_fixture(web3) -> str:\n    \"\"\"setup account.\"\"\"\n    return web3.eth.accounts[0]\n\n\n@pytest.fixture(name=\"order\")\ndef order_params_fixture():\n    \"\"\"Return order parameters.\"\"\"\n    return {\n        'action': 'BUY',\n        'instrument': 'WBTC',\n        'quantity': 1,\n    }", "\n\n@pytest.fixture(name=\"invalid_order\")\ndef invalid_order_fixture():\n    \"\"\"Return order parameters.\"\"\"\n    return {\n        'action': 'BUY',\n        'instrument': 'NOTATHING',\n        'quantity': 1,\n    }", "\n\n@pytest.fixture(name=\"test_contract\")\ndef mock_contract(dex):\n    contract = AsyncMock()\n    contract.get_token_decimals.return_value = 18\n    contract.to_wei.return_value = 1000000000000000000\n    contract.functions.balanceOf = AsyncMock(return_value=100)\n    contract.wait_for_transaction_receipt.return_value = {\"status\": 1}\n    return contract", "\n\n@pytest.fixture(name=\"mock_dex\")\ndef mock_dex_transaction():\n    dex = DexSwap()\n    dex.w3.eth.get_transaction_count = AsyncMock(return_value=1)\n    dex.get_gas = AsyncMock(return_value=21000)\n    dex.get_gas_price = AsyncMock(return_value=1000000000)\n    dex.w3.eth.account.sign_transaction = (\n        AsyncMock(return_value=AsyncMock(rawTransaction=b'signed_transaction')))\n    dex.w3.eth.send_raw_transaction = AsyncMock(return_value=b'transaction_hash')\n    return dex", "\n\ndef test_dynaconf_is_in_testing():\n    print(settings.VALUE)\n    assert settings.VALUE == \"On Testing\"\n\n@pytest.mark.asyncio\nasync def test_get_info(dex):\n    result = await dex.get_info()\n    print(result)", "    result = await dex.get_info()\n    print(result)\n    assert result is not None\n\n\n@pytest.mark.asyncio\nasync def test_get_name(dex):\n    result = await dex.get_name()\n    assert isinstance(result, str)\n    assert len(result) == 8", "    assert isinstance(result, str)\n    assert len(result) == 8\n\n\n@pytest.mark.asyncio\nasync def test_get_account_balance(dex):\n    # Call the get_account_balance method\n    result = await dex.get_account_balance()\n    assert result is not None\n    assert '\u20bf' in result", "    assert result is not None\n    assert '\u20bf' in result\n\n\n@pytest.mark.asyncio\nasync def test_account_balance(account) -> str:\n    \"\"\"test balance account.\"\"\"\n    with patch(\"dxsp.config.settings\", autospec=True):\n        settings.dex_wallet_address = account\n        print(settings.dex_wallet_address)\n        dex = DexSwap()\n        print(dex.account.wallet_address)\n        result = await dex.get_account_balance()\n        print(result)\n        assert result is not None\n        assert '\u20bf' in result\n        assert '\ud83d\udcb5' in result", "\n\n@pytest.mark.asyncio\nasync def test_trading_asset_balance(account) -> str:\n    \"\"\"test token account.\"\"\"\n    with patch(\"dxsp.config.settings\", autospec=True):\n        settings.dex_wallet_address = account\n        dex = DexSwap()\n        result = await dex.get_trading_asset_balance()\n        print(result)\n        assert result is not None", "\n\n@pytest.mark.asyncio\nasync def test_get_account_position(account) -> str:\n    \"\"\"test token account.\"\"\"\n    with patch(\"dxsp.config.settings\", autospec=True):\n        settings.dex_wallet_address = account\n        # with pytest.raises(ValueError, match='No Balance'):\n        dex = DexSwap()\n        result = await dex.get_account_position()\n        print(result)\n        assert result is not None\n        assert '\ud83d\udcca' in result", "\n\n@pytest.mark.asyncio\nasync def test_get_account_transactions(dex):\n    # Call the get_account_transactions method\n    result = await dex.get_account_transactions()\n    print(f\"history: {result}\")\n    assert result is not None\n    assert 'pnl' in result\n    assert 'tokenList' in result", "    assert 'pnl' in result\n    assert 'tokenList' in result\n\n\n@pytest.mark.asyncio\nasync def test_get_account_pnl(dex):\n    # Call the get_account_pnl method\n    result = await dex.get_account_pnl()\n    print(f\"pnl: {result}\")\n    assert result is not None", "    print(f\"pnl: {result}\")\n    assert result is not None\n    assert 'Total' in result\n    assert '\ud83d\udcca' in result\n    assert 'Opened' in result\n    assert 'Margin' in result\n\n@pytest.mark.asyncio\nasync def test_get_approve(dex):\n    symbol = \"UNI\"", "async def test_get_approve(dex):\n    symbol = \"UNI\"\n    approve_receipt = None\n    try:\n        approve_receipt = await dex.get_approve(symbol)\n        print(approve_receipt)\n    except Exception as e:\n        print(f\"Error getting approve receipt: {e}\")\n    assert approve_receipt is None\n", "    assert approve_receipt is None\n\n\n@pytest.mark.asyncio\nasync def test_failed_get_approve(dex):\n    with pytest.raises(ValueError, match='Approval failed'):\n        await dex.account.get_approve(\"0xdAC17F958D2ee523a2206206994597C13D831ec7\")\n\n\n@pytest.mark.asyncio", "\n@pytest.mark.asyncio\nasync def test_get_sign(mock_dex):\n    pass\n#    transaction = MagicMock()\n#    result = await mock_dex.get_sign(transaction)\n\n#    mock_dex.get_gas.assert_called_once_with(transaction)\n#    mock_dex.get_gas_price.assert_called_once()\n#    mock_dex.w3.eth.get_transaction_count.assert_called_once_with(", "#    mock_dex.get_gas_price.assert_called_once()\n#    mock_dex.w3.eth.get_transaction_count.assert_called_once_with(\n# mock_dex.wallet_address)\n\n\n@pytest.mark.asyncio\nasync def test_get_gas(dex):\n    \"\"\"get_gas Testing\"\"\"\n    mock_tx = {\"to\": \"0x1234567890123456789012345678901234567890\",\n                \"value\": \"1000000000000000000\"}", "    mock_tx = {\"to\": \"0x1234567890123456789012345678901234567890\",\n                \"value\": \"1000000000000000000\"}\n    result = await dex.account.get_gas(mock_tx)\n    print(result)\n\n\n@pytest.mark.asyncio\nasync def test_get_gas_price(dex):\n    # Call the get_gasPrice method\n    result = await dex.account.get_gas_price()", "    # Call the get_gasPrice method\n    result = await dex.account.get_gas_price()\n    print(f\"gas_price: {result}\")\n    assert result is not None"]}
{"filename": "tests/test_unit_zerox.py", "chunked_list": ["\"\"\"\n DEXSWAP Unit Test\n\"\"\"\nfrom unittest.mock import AsyncMock, patch\n\nimport pytest\n\nfrom dxsp import DexSwap\nfrom dxsp.config import settings\n", "from dxsp.config import settings\n\n\n@pytest.fixture(scope=\"session\", autouse=True)\ndef set_test_settings():\n    settings.configure(FORCE_ENV_FOR_DYNACONF=\"zerox\")\n\n\n@pytest.fixture(name=\"dex\")\ndef DexSwap_fixture():\n    return DexSwap()", "@pytest.fixture(name=\"dex\")\ndef DexSwap_fixture():\n    return DexSwap()\n\n\n@pytest.fixture(name=\"order\")\ndef order_params_fixture():\n    \"\"\"Return order parameters.\"\"\"\n    return {\n        \"action\": \"BUY\",\n        \"instrument\": \"WBTC\",\n        \"quantity\": 1,\n    }", "\n\ndef test_dynaconf_is_in_testing():\n    print(settings.VALUE)\n    assert settings.VALUE == \"test_zerox\"\n\n\n@pytest.mark.asyncio\nasync def test_dex(dex):\n    \"\"\"Init Testing\"\"\"", "async def test_dex(dex):\n    \"\"\"Init Testing\"\"\"\n    assert isinstance(dex, DexSwap)\n    assert dex.w3 is not None\n    assert dex.protocol_type is not None\n    assert dex.protocol_type == \"0x\"\n\n\n@pytest.mark.asyncio\nasync def test_get_quote(dex):", "@pytest.mark.asyncio\nasync def test_get_quote(dex):\n    result = await dex.get_quote(\"UNI\")\n    print(\"0x quote: \", result)\n    assert dex.w3.net.version == \"1\"\n    assert result is not None\n    assert result.startswith(\"\ud83e\udd84\")\n\n\n", "\n\n@pytest.mark.asyncio\nasync def test_execute_order(dex, order):\n    result = await dex.execute_order(order)\n    print(result)\n    assert result is not None\n    assert result.startswith(\"\u26a0\ufe0f\")\n", ""]}
{"filename": "tests/test_unit_uniswap_v3.py", "chunked_list": ["\"\"\"\n DEXSWAP Uniswap  Test\n\"\"\"\n\nimport pytest\n\nfrom dxsp import DexSwap\nfrom dxsp.config import settings\n\n", "\n\n@pytest.fixture(scope=\"session\", autouse=True)\ndef set_test_settings():\n    settings.configure(FORCE_ENV_FOR_DYNACONF=\"uniswapv3\")\n\n@pytest.fixture(name=\"dex\")\ndef DexSwap_fixture():\n    return DexSwap()\n", "\n@pytest.fixture(name=\"order\")\ndef order_params_fixture():\n    \"\"\"Return order parameters.\"\"\"\n    return {\n        'action': 'BUY',\n        'instrument': 'WBTC',\n        'quantity': 1,\n    }\n", "\n\ndef test_dynaconf_is_in_testing():\n    print(settings.VALUE)\n    assert settings.VALUE == \"On uniswap3\"\n\n\n@pytest.mark.asyncio\nasync def test_get_quote(dex):\n    result = await dex.get_quote(\"WBTC\")", "async def test_get_quote(dex):\n    result = await dex.get_quote(\"WBTC\")\n    print(f\"result: {result}\")\n    assert result is not None\n    assert result.startswith(\"\ud83e\udd84\")\n\n\n@pytest.mark.asyncio\nasync def test_execute_order(dex, order):\n    result = await dex.execute_order(order)", "async def test_execute_order(dex, order):\n    result = await dex.execute_order(order)\n    print(f\"result: {result}\")\n    assert result is not None\n"]}
{"filename": "dxsp/main.py", "chunked_list": ["\"\"\"\n DEX SWAP Main\n\"\"\"\n\nimport decimal\nfrom typing import Optional\n\nfrom loguru import logger\nfrom web3 import Web3\nfrom web3.gas_strategies.time_based import medium_gas_price_strategy", "from web3 import Web3\nfrom web3.gas_strategies.time_based import medium_gas_price_strategy\n\nfrom dxsp.config import settings\nfrom dxsp.utils import AccountUtils, ContractUtils\n\n\nclass DexSwap:\n    \"\"\"\n    DEXswap  class to build a DexSwap Object\n    use to interact with the dex protocol\n\n    Args:\n        w3 (Optional[Web3]): Web3\n\n    Returns:\n        DexSwap\n\n\n    \"\"\"\n\n    def __init__(self, w3: Optional[Web3] = None):\n        \"\"\"\n        Initialize the DexSwap object to interact with\n        w3 contracts.\n\n        \"\"\"\n        self.logger = logger\n        self.w3 = w3 or Web3(Web3.HTTPProvider(settings.dex_rpc))\n        if not self.w3.net.listening:\n            raise ValueError(\"w3 not connected\")\n        self.w3.eth.set_gas_price_strategy(medium_gas_price_strategy)\n\n        self.account = AccountUtils(w3=self.w3)\n\n        self.protocol_type = settings.dex_protocol_type\n        self.protocol_version = settings.dex_protocol_version\n        self.dex_swap = None\n        self.router = None\n        self.quoter = None\n        self.contract_utils = ContractUtils(w3=self.w3)\n\n    async def get_protocol(self):\n        \"\"\"\n        Set the dex_swap object based\n        on the protocol type.\n        Currently supports:\n            1inch: currently blocked\n\n            0x\n\n            Uniswap V2 and V3\n\n        Returns:\n            dex_swap\n\n\n        \"\"\"\n        from dxsp.protocols import DexSwapOneInch, DexSwapUniswap, DexSwapZeroX\n\n        if self.protocol_type == \"0x\":\n            self.dex_swap = DexSwapZeroX()\n        elif self.protocol_type == \"1inch\":\n            self.dex_swap = DexSwapOneInch()\n        else:\n            self.dex_swap = DexSwapUniswap()\n\n    async def execute_order(self, order_params):\n        \"\"\"\n        Execute an order function.\n\n        Args:\n            order_params (dict): The order parameters.\n\n        Returns:\n            str: The trade confirmation\n\n        \"\"\"\n        try:\n            self.logger.debug(\"execute order\")\n            action = order_params.get(\"action\")\n            instrument = order_params.get(\"instrument\")\n            quantity = order_params.get(\"quantity\", 1)\n            sell_token, buy_token = (\n                (self.account.trading_asset_address, instrument)\n                if action == \"BUY\"\n                else (instrument, self.account.trading_asset_address)\n            )\n            order = await self.get_swap(sell_token, buy_token, quantity)\n            if order:\n                trade_confirmation = (\n                    f\"\u2b07\ufe0f {instrument}\" if (action == \"SELL\") else f\"\u2b06\ufe0f {instrument}\\n\"\n                )\n                trade_confirmation += order\n                return trade_confirmation\n\n        except Exception as error:\n            return f\"\u26a0\ufe0f order execution: {error}\"\n\n    async def get_swap(self, sell_token: str, buy_token: str, quantity: int) -> None:\n        \"\"\"\n        Execute a swap\n\n        Args:\n            sell_token (str): The sell token.\n            buy_token (str): The buy token.\n            quantity (int): The quantity of tokens.\n\n        Returns:\n            transactionHash\n\n\n        \"\"\"\n        try:\n            self.logger.debug(\"get swap\")\n            await self.get_protocol()\n            sell_token_address = sell_token\n            self.logger.debug(\"sell token {}\", sell_token_address)\n            if not sell_token.startswith(\"0x\"):\n                sell_token_address = await self.contract_utils.search_contract_address(\n                    sell_token\n                )\n            buy_token_address = buy_token\n            self.logger.debug(\"buy token {}\", buy_token_address)\n            if not buy_token_address.startswith(\"0x\"):\n                buy_token_address = await self.contract_utils.search_contract_address(\n                    buy_token\n                )\n            sell_amount = await self.contract_utils.calculate_sell_amount(\n                sell_token_address, self.account.wallet_address, quantity\n            )\n            sell_token_amount_wei = sell_amount * (\n                10 ** (await self.contract_utils.get_token_decimals(sell_token_address))\n            )\n            if self.protocol_type == \"0x\":\n                await self.account.get_approve(sell_token_address)\n\n            order_amount = int(\n                sell_token_amount_wei\n                * decimal.Decimal((settings.dex_trading_slippage / 100))\n            )\n            self.logger.debug(order_amount)\n            order = await self.dex_swap.get_swap(\n                sell_token_address, buy_token_address, order_amount\n            )\n\n            if not order:\n                self.logger.debug(\"swap order error\")\n                raise ValueError(\"swap order not executed\")\n\n            signed_order = await self.account.get_sign(order)\n            order_hash = str(self.w3.to_hex(signed_order))\n            receipt = self.w3.wait_for_transaction_receipt(order_hash)\n\n            if receipt[\"status\"] != 1:\n                self.logger.debug(receipt)\n                raise ValueError(\"receipt failed\")\n\n            return await self.contract_utils.get_confirmation(\n                receipt[\"transactionHash\"]\n            )\n\n        except Exception as error:\n            self.logger.debug(error)\n            raise error\n\n    async def get_quote(self, sell_token):\n        \"\"\"\n        gets a quote for a token\n\n        Args:\n            sell_token (str): The sell token.\n\n        Returns:\n            str: The quote with the trading symbol\n\n        \"\"\"\n        try:\n            await self.get_protocol()\n            buy_address = self.account.trading_asset_address\n            sell_address = await self.contract_utils.search_contract_address(sell_token)\n            quote = await self.dex_swap.get_quote(buy_address, sell_address)\n            quote = f\"\ud83e\udd84 {quote}\"\n            symbol = await self.contract_utils.get_token_symbol(\n                self.account.trading_asset_address\n            )\n            return f\"{quote} {symbol}\"\n\n        except Exception as error:\n            return f\"\u26a0\ufe0f: {error}\"\n\n    # \ud83d\udd12 USER RELATED\n\n    async def get_info(self):\n        \"\"\"\n        Get information from the account.\n\n        :return: The information retrieved from the account.\n        \"\"\"\n        return await self.account.get_info()\n\n    async def get_help(self):\n        \"\"\"\n        Retrieves help information\n        using the `account.get_help()` method.\n\n        :return: The help information.\n        :rtype: Any\n        \"\"\"\n        return await self.account.get_help()\n\n    async def get_name(self):\n        \"\"\"\n        Retrieves the name of the account.\n\n        :return: The name of the account.\n        \"\"\"\n        return await self.account.get_name()\n\n    async def get_account_balance(self):\n        \"\"\"\n        Retrieves the account balance.\n\n        :return: The account balance.\n        :rtype: float\n        \"\"\"\n        return await self.account.get_account_balance()\n\n    async def get_trading_asset_balance(self):\n        \"\"\"\n        Retrieves the trading asset balance for the current account.\n\n        :return: A dictionary containing the trading asset balance.\n                 The dictionary has the following keys:\n                 - 'asset': The asset symbol.\n                 - 'free': The free balance of the asset.\n                 - 'locked': The locked balance of the asset.\n        \"\"\"\n        return await self.account.get_trading_asset_balance()\n\n    async def get_account_position(self):\n        \"\"\"\n        Retrieves the account position.\n\n        :return: The account position.\n        :rtype: AccountPosition\n        \"\"\"\n        return await self.account.get_account_position()\n\n    async def get_account_margin(self):\n        \"\"\"\n        Retrieves the account margin.\n\n        :return: The account margin.\n        :rtype: float\n        \"\"\"\n        return await self.account.get_account_margin()\n\n    async def get_account_open_positions(self):\n        \"\"\"\n        Retrieves the open positions of the account.\n\n        :return: A list of open positions in the account.\n        \"\"\"\n        return await self.account.get_account_open_positions()\n\n    async def get_account_transactions(self, period=24):\n        \"\"\"\n        Get the account transactions\n        for a specific period.\n\n        Args:\n            period (int): The number of hours\n            for which to retrieve the transactions. Defaults to 24.\n\n        Returns:\n            List[Transaction]: A list of\n            transaction objects representing the account transactions.\n        \"\"\"\n        return await self.account.get_account_transactions(period)\n\n    async def get_account_pnl(self, period=24):\n        \"\"\"\n        Get the profit and loss (PnL)\n        for the account within a specified period.\n\n        Args:\n            period (int, optional):\n            The period in hours for which to calculate the PnL.\n            Defaults to 24.\n\n        Returns:\n            float: The profit and loss (PnL)\n            for the account within the specified period.\n        \"\"\"\n        return await self.account.get_account_pnl(period)", ""]}
{"filename": "dxsp/config.py", "chunked_list": ["\"\"\"\n DEX SWAP CONFIG\n\"\"\"\nimport os\n\nfrom dynaconf import Dynaconf\n\nROOT = os.path.dirname(__file__)\n\nsettings = Dynaconf(", "\nsettings = Dynaconf(\n    envvar_prefix=\"TT\",\n    root_path=os.path.dirname(ROOT),\n    settings_files=[\n        os.path.join(ROOT, \"default_settings.toml\"),\n        \"talky_settings.toml\",\n        \"settings.toml\",\n        \".secrets.toml\",\n    ],", "        \".secrets.toml\",\n    ],\n    load_dotenv=True,\n    environments=True,\n    default_env=\"default\",\n)\n"]}
{"filename": "dxsp/__init__.py", "chunked_list": ["__version__ = \"4.2.25\"\n\nfrom dxsp.config import settings\nfrom dxsp.main import DexSwap\nfrom dxsp.protocols import DexSwapOneInch, DexSwapUniswap, DexSwapZeroX\n"]}
{"filename": "dxsp/utils/account_utils.py", "chunked_list": ["\"\"\"\n DEX SWAP\n\ud83d\udd12 USER RELATED\n\"\"\"\nfrom typing import Optional\n\nfrom loguru import logger\nfrom web3 import Web3\n\nfrom dxsp import __version__", "\nfrom dxsp import __version__\nfrom dxsp.config import settings\nfrom dxsp.utils.contract_utils import ContractUtils\nfrom dxsp.utils.explorer_utils import get_account_transactions\n\n\nclass AccountUtils:\n\n    \"\"\"\n    Class AccountUtils to interact with private related methods\n    such as account balance, signing transactions, etc.\n\n    Args:\n        w3 (Optional[Web3]): Web3\n\n    Methods:\n        get_info()\n        get_name()\n        get_help()\n        get_account_balance()\n        get_trading_asset_balance()\n        get_account_position\n        get_account_margin\n        get_account_open_positions\n        get_account_transactions()\n        get_account_pnl\n        get_approve\n        get_sign\n        get_gas\n        get_gas_price\n\n    \"\"\"\n\n    def __init__(self, w3: Optional[Web3] = None):\n        self.logger = logger\n        self.w3 = w3 or Web3(Web3.HTTPProvider(settings.dex_rpc))\n        self.wallet_address = self.w3.to_checksum_address(settings.dex_wallet_address)\n        self.account_number = (\n            f\"{str(self.w3.net.version)} - \" f\"{str(self.wallet_address)[-8:]}\"\n        )\n        self.private_key = settings.dex_private_key\n        self.trading_asset_address = self.w3.to_checksum_address(\n            settings.trading_asset_address\n        )\n        self.contract_utils = ContractUtils(w3=self.w3)\n        self.commands = settings.dxsp_commands\n\n    async def get_info(self):\n        \"\"\"\n        Get the information about the DexSwap API.\n\n        Returns:\n            str: A string containing the version of DexSwap, the name obtained from\n                 `get_name()`, and the account number.\n        Raises:\n            Exception: If there is an error while retrieving the information.\n        \"\"\"\n        try:\n            return (\n                f\"\u2139\ufe0f DexSwap v{__version__}\\n\"\n                f\"\ud83d\udcb1 {await self.get_name()}\\n\"\n                f\"\ud83e\udeaa {self.account_number}\"\n            )\n        except Exception as error:\n            return error\n\n    async def get_name(self):\n        \"\"\"\n        Retrieves the name of the object being the\n        last 8 characters of the router contract address.\n\n        :return: A string representing\n        the name of the object.\n        \"\"\"\n        if settings.dex_router_contract_addr:\n            return str(settings.dex_router_contract_addr)[-8:]\n\n    async def get_help(self):\n        \"\"\"\n        Asynchronously retrieves the help information.\n\n        Returns:\n            str: The help information,\n            including the available commands.\n        \"\"\"\n        return f\"{self.commands}\\n\"\n\n    async def get_account_balance(self):\n        \"\"\"\n        Retrieves the account balance of the user.\n\n        Returns:\n            str: A formatted string containing\n            the account balance in Bitcoin (\u20bf) and\n            the trading asset balance like USDT (\ud83d\udcb5).\n        \"\"\"\n        account_balance = self.w3.eth.get_balance(\n            self.w3.to_checksum_address(self.wallet_address)\n        )\n        account_balance = self.w3.from_wei(account_balance, \"ether\") or 0\n        trading_asset_balance = await self.get_trading_asset_balance()\n        return f\"\u20bf {round(account_balance,5)}\\n\ud83d\udcb5 {trading_asset_balance}\"\n\n    async def get_trading_asset_balance(self):\n        \"\"\"\n        Retrieves the balance of the trading asset\n        for the current wallet address.\n\n        Returns:\n            The balance of the trading asset as a float.\n            If the balance is not available,\n            it returns 0.\n        \"\"\"\n        trading_asset_balance = await self.contract_utils.get_token_balance(\n            self.trading_asset_address, self.wallet_address\n        )\n        return trading_asset_balance if trading_asset_balance else 0\n\n    async def get_account_position(self):\n        \"\"\"\n        Retrieves the account position.\n\n        Returns:\n            str: A string representing the account position.\n        \"\"\"\n        position = \"\ud83d\udcca Position\\n\"\n        position += f\"Opened: {str(await self.get_account_open_positions())}\\n\"\n        position += f\"Margin: {str(await self.get_account_margin())}\"\n        return position\n\n    async def get_account_margin(self):\n        \"\"\"\n        Get the account margin. Not yet implemented\n\n        Returns:\n            int: The account margin.\n        \"\"\"\n        return 0\n\n    async def get_account_open_positions(self):\n        \"\"\"\n        Get the open positions for the account.\n        Not yet implemented\n\n        :return: The number of open positions\n        for the account.\n        \"\"\"\n        return 0\n\n    async def get_account_transactions(self, period=24):\n        \"\"\"\n        Retrieve the account transactions for a given period.\n        Not yet implemented\n\n        Args:\n            period (int): The time period in hours\n            to retrieve the transactions for.\n            Default is 24 hours.\n\n        Returns:\n            List[Transaction]: A list of transactions for the account.\n        \"\"\"\n        return await get_account_transactions(\n            period, self.trading_asset_address, self.wallet_address\n        )\n\n    async def get_account_pnl(self, period=24):\n        \"\"\"\n        Create a profit and loss (PnL)\n        report for the account.\n        Not yet implemented\n\n        Args:\n            period (int): The time period in hours\n            to retrieve the PnL for. Default is 24 hours.\n\n        Returns:\n            str: A string containing the PnL report.\n\n\n        \"\"\"\n        pnl_dict = await self.get_account_transactions(period)\n        pnl_report = \"\".join(\n            f\"{token} {value}\\n\" for token, value in pnl_dict[\"tokenList\"].items()\n        )\n        pnl_report += f\"Total {pnl_dict['pnl']}\\n\"\n        pnl_report += await self.get_account_position()\n\n        return pnl_report\n\n    async def get_approve(self, token_address):\n        \"\"\"\n        Given a token address, approve a token\n\n        Args:\n            token_address (str): The token address\n\n        Returns:\n            approval_tx_hash\n\n        \"\"\"\n        try:\n            contract = await self.contract_utils.get_token_contract(token_address)\n            if contract is None:\n                return\n            approved_amount = self.w3.to_wei(2**64 - 1, \"ether\")\n            owner_address = self.w3.to_checksum_address(self.wallet_address)\n            dex_router_address = self.w3.to_checksum_address(\n                settings.dex_router_contract_addr\n            )\n            allowance = contract.functions.allowance(\n                owner_address, dex_router_address\n            ).call()\n            if allowance == 0:\n                approval_tx = contract.functions.approve(\n                    dex_router_address, approved_amount\n                )\n                approval_tx_hash = await self.get_sign(approval_tx.transact())\n                return self.w3.eth.wait_for_transaction_receipt(approval_tx_hash)\n        except Exception as error:\n            raise ValueError(f\"Approval failed {error}\")\n\n    async def get_sign(self, transaction):\n        \"\"\"\n        Given a transaction, sign a transaction\n\n        Args:\n            transaction (Transaction): The transaction\n\n        Returns:\n            signed_tx_hash\n\n        \"\"\"\n        try:\n            signed_tx = self.w3.eth.account.sign_transaction(\n                transaction, self.private_key\n            )\n            return self.w3.eth.send_raw_transaction(signed_tx.rawTransaction)\n        except Exception as error:\n            raise error\n\n    async def get_gas(self, transaction):\n        \"\"\"\n        Given a transaction, get gas estimate\n\n        Args:\n            transaction (Transaction): The transaction\n\n        Returns:\n            int: The gas estimate\n\n        \"\"\"\n        gas_limit = self.w3.eth.estimate_gas(transaction) * 1.25\n        return int(self.w3.to_wei(gas_limit, \"wei\"))\n\n    async def get_gas_price(self):\n        \"\"\"\n        search get gas price\n\n        Returns:\n            int: The gas price\n\n        \"\"\"\n        return round(self.w3.from_wei(self.w3.eth.generate_gas_price(), \"gwei\"), 2)", ""]}
{"filename": "dxsp/utils/contract_utils.py", "chunked_list": ["\"\"\"\n DEX SWAP\n\u270d\ufe0f CONTRACT\n\"\"\"\n\nimport decimal\nfrom datetime import datetime\nfrom typing import Optional\n\nimport requests", "\nimport requests\nfrom loguru import logger\nfrom pycoingecko import CoinGeckoAPI\nfrom web3 import Web3\n\nfrom dxsp.config import settings\nfrom dxsp.utils.explorer_utils import get_explorer_abi\nfrom dxsp.utils.utils import get\n", "from dxsp.utils.utils import get\n\n\nclass ContractUtils:\n\n    \"\"\"\n    ContractUtils class to interact with w3 contracts\n    and with coingecko API.\n    Coingecko data is retrieve via pycoingecko\n    More info: https://github.com/man-c/pycoingecko\n\n    Args:\n        w3 (Optional[Web3]): Web3\n\n    Methods:\n        search_contract_address(self, token)\n        search_cg_platform(self)\n        search_cg(self, token)\n        search_cg_contract(token)\n        get_token_address(self, contract_list, token)\n        get_token_contract(self, token)\n        get_token_decimals(self, token_address)\n        get_token_symbol(self, token_address)\n        get_token_name(self, token_address)\n        get_token_balance(self, token_address)\n        calculate_sell_amount(self,\n            sell_token_address, wallet_address, quantity)\n        get_confirmation(self, tx_hash)\n\n    \"\"\"\n\n    def __init__(self, w3: Optional[Web3] = None):\n        self.logger = logger\n        self.w3 = w3\n        self.cg = CoinGeckoAPI()\n\n    async def search_contract_address(self, token):\n        \"\"\"\n        Search a contract function on json file\n        using tokenlist format https://github.com/Uniswap/token-lists\n        or if not in the list verify with coingecko.\n        The token list can be modified for your needs.\n        The list are defined in settings. Default settings\n        are using list under https://github.com/mraniki/tokenlist\n\n        Args:\n            token (str): The token address\n\n        Returns:\n            str: The token address in w3 checksum format\n\n        Raises:\n            ValueError: Invalid Token\n\n        \"\"\"\n        try:\n            self.logger.debug(\"Searching Token Address\")\n            contract_lists = [\n                settings.token_personal_list,\n                settings.token_testnet_list,\n                settings.token_mainnet_list,\n            ]\n            for contract_list in contract_lists:\n                self.logger.debug(\"Searching {} on {}\", token, contract_list)\n                token_address = await self.get_token_address(contract_list, token)\n                if token_address is not None:\n                    self.logger.debug(\n                        \"Found {} on {}\", token_address, contract_list\n                    )\n                    return self.w3.to_checksum_address(token_address)\n\n            self.logger.debug(\"Searching on Coingecko\")\n            token_address = await self.search_cg_contract(token)\n            if token_address is None:\n                self.logger.warning(\"Invalid Token\")\n                raise ValueError(\"Invalid Token\")\n            self.logger.debug(\"Found on Coingecko {}\", token_address)\n            return self.w3.to_checksum_address(token_address)\n        except Exception as e:\n            self.logger.error(\": {}\", e)\n            raise ValueError(\"Invalid Token\")\n\n    async def search_cg_platform(self):\n        \"\"\"\n        Search coingecko platform\n\n        Returns:\n            str: The platform\n\n        \"\"\"\n        asset_platforms = self.cg.get_asset_platforms()\n        output_dict = next(\n            x\n            for x in asset_platforms\n            if x[\"chain_identifier\"] == int(self.w3.net.version)\n        )\n        platform = output_dict[\"id\"] or None\n        self.logger.debug(\"coingecko platform identified {}\", platform)\n        return platform\n\n    async def search_cg(self, token):\n        \"\"\"\n        Search Coingecko\n\n        Args:\n            token (str): The token symbol\n\n        Returns:\n            str: The token dictionary for the platform\n\n\n        \"\"\"\n        try:\n            search_results = self.cg.search(query=token)\n            search_dict = search_results[\"coins\"]\n            filtered_dict = [x for x in search_dict if x[\"symbol\"] == token.upper()]\n            api_dict = [sub[\"api_symbol\"] for sub in filtered_dict]\n            for i in api_dict:\n                coin_dict = self.cg.get_coin_by_id(i)\n                try:\n                    if coin_dict[\"platforms\"][f\"{await self.search_cg_platform()}\"]:\n                        return coin_dict\n                except (KeyError, requests.exceptions.HTTPError):\n                    pass\n        except Exception as e:\n            self.logger.error(\"search_cg {}\", e)\n\n    async def search_cg_contract(self, token):\n        \"\"\"\n        search for a token address on coingecko\n\n        Args:\n            token (str): The token symbol\n\n        Returns:\n            str: The token address\n        \"\"\"\n        try:\n            self.logger.debug(\"Coingecko Address search for {}\", token)\n            coin_info = await self.search_cg(token)\n            return (\n                coin_info[\"platforms\"][f\"{await self.search_cg_platform()}\"]\n                if coin_info is not None\n                else None\n            )\n        except Exception as e:\n            self.logger.error(\" search_cg_contract: {}\", e)\n\n    async def get_token_address(self, token_list_url, symbol):\n        \"\"\"\n\n        Given a token symbol and json tokenlist, get token address\n\n        Args:\n            token_list_url (str): The token list url\n            symbol (str): The token symbol\n\n        Returns:\n            str: The token address\n\n        \"\"\"\n        try:\n            self.logger.debug(\"Token address search in {}\", token_list_url)\n            token_list = await get(token_list_url)\n            token_search = token_list[\"tokens\"]\n            for keyval in token_search:\n                if keyval[\"symbol\"] == symbol and keyval[\"chainId\"] == int(\n                    self.w3.net.version\n                ):\n                    self.logger.debug(\"token identified\")\n                    return keyval[\"address\"]\n            raise ValueError(\"Token not found\")\n        except Exception as e:\n            self.logger.error(\"get_token_address: {}\", e)\n            return None\n\n    async def get_token_contract(self, token_address):\n        \"\"\"\n        Given a token address, returns a contract object.\n\n        Args:\n            token_address (str): The token address\n\n        Returns:\n            Contract: The token contract\n\n        \"\"\"\n        token_abi = await get_explorer_abi(token_address)\n        if token_abi is None:\n            token_abi = await get(settings.dex_erc20_abi_url)\n        return self.w3.eth.contract(address=token_address, abi=token_abi)\n\n    async def get_token_decimals(self, token_address: str) -> Optional[int]:\n        \"\"\"\n        Get token decimals\n\n        Args:\n            token_address (str): The token address\n\n        Returns:\n            int: The token decimals\n\n        \"\"\"\n        contract = await self.get_token_contract(token_address)\n        return 18 if not contract else contract.functions.decimals().call()\n\n    async def get_token_symbol(self, token_address: str):\n        \"\"\"\n        Get token symbol\n\n        Args:\n            token_address (str): The token address\n\n        Returns:\n            str: The token symbol\n\n        \"\"\"\n        contract = await self.get_token_contract(token_address)\n        # token_name = contract.functions.name().call()\n        return contract.functions.symbol().call()\n\n    async def get_token_name(self, token_address: str):\n        \"\"\"\n        Get token symbol\n\n        Args:\n            token_address (str): The token address\n\n        Returns:\n            str: The token name\n\n        \"\"\"\n        contract = await self.get_token_contract(token_address)\n        return contract.functions.name().call()\n\n    async def get_token_balance(\n        self, token_address: str, wallet_address: str\n    ) -> Optional[int]:\n        \"\"\"\n        Get token balance\n\n        Args:\n            token_address (str): The token address\n            wallet_address (str): The wallet address\n\n        Returns:\n            int: The token balance\n\n        \"\"\"\n        contract = await self.get_token_contract(token_address)\n        if contract is None or contract.functions is None:\n            raise ValueError(\"No Balance\")\n        balance = contract.functions.balanceOf(wallet_address).call()\n        if balance is None:\n            raise ValueError(\"No Balance\")\n        return round(self.w3.from_wei(balance, \"ether\"), 5) or 0\n\n    async def calculate_sell_amount(self, sell_token_address, wallet_address, quantity):\n        \"\"\"\n        Returns amount based on risk percentage.\n\n        Args:\n            sell_token_address (str): The sell token address\n            wallet_address (str): The wallet address\n            quantity (int): The quantity\n\n        Returns:\n            float: The sell amount\n\n        \"\"\"\n        sell_balance = await self.get_token_balance(sell_token_address, wallet_address)\n        sell_contract = await self.get_token_contract(sell_token_address)\n        sell_decimals = (\n            sell_contract.functions.decimals().call()\n            if sell_contract is not None\n            else 18\n        )\n        risk_percentage = settings.trading_risk_amount\n        return (sell_balance / (risk_percentage * 10**sell_decimals)) * (\n            decimal.Decimal(quantity) / 100\n        )\n\n    async def get_confirmation(self, transactionHash):\n        \"\"\"\n\n        Returns trade confirmation.\n\n        Args:\n            transactionHash (str): The transaction hash\n\n        Returns:\n            dict: The trade confirmation\n\n        Raises:\n            Exception: Error\n\n        \"\"\"\n        try:\n            transaction = self.w3.eth.get_transaction(transactionHash)\n            block_info = self.w3.eth.get_block(transaction[\"blockNumber\"])\n            return {\n                \"timestamp\": datetime.utcfromtimestamp(block_info[\"timestamp\"]),\n                \"id\": transactionHash,\n                \"instrument\": transaction[\"to\"],\n                \"contract\": transaction[\"to\"],  # TBD To be determined.\n                \"amount\": transaction[\"value\"],\n                \"price\": transaction[\"value\"],  # TBD To be determined.\n                \"fee\": transaction[\"gas\"],\n                \"confirmation\": (\n                    f\"\u2795 Size: {round(transaction['value'], 4)}\\n\"\n                    f\"\u26ab\ufe0f Entry: {round(transaction['value'], 4)}\\n\"\n                    f\"\u2139\ufe0f {transactionHash}\\n\"\n                    f\"\u26fd {transaction['gas']}\\n\"\n                    f\"\ud83d\uddd3\ufe0f {datetime.utcfromtimestamp(block_info['timestamp'])}\"\n                ),\n            }\n        except Exception as error:\n            raise error", ""]}
{"filename": "dxsp/utils/__init__.py", "chunked_list": ["from dxsp.utils.account_utils import AccountUtils\nfrom dxsp.utils.contract_utils import ContractUtils\n"]}
{"filename": "dxsp/utils/utils.py", "chunked_list": ["\"\"\"\n DEX SWAP\n\ud83d\udee0\ufe0f W3 UTILS\n\"\"\"\n\nimport requests\nimport aiohttp\nfrom loguru import logger\n\nMAX_RESPONSE_SIZE = 5 * 1024 * 1024  # Maximum response size in bytes (e.g., 5 MB)", "\nMAX_RESPONSE_SIZE = 5 * 1024 * 1024  # Maximum response size in bytes (e.g., 5 MB)\n\nasync def get(url, params=None, headers=None):\n    \"\"\"\n    Asynchronously gets a url payload\n    and returns the response\n\n    Args:\n        url (str): The url to get", "    Args:\n        url (str): The url to get\n        params (dict, optional): The params to send. Defaults to None.\n        headers (dict, optional): The headers to send. Defaults to None.\n\n    Returns:\n        dict: The response\n\n    Raises:\n        Exception: Error", "    Raises:\n        Exception: Error\n\n    \"\"\"\n    \n    # try:\n    #     response = requests.get(url, params=params, headers=headers, timeout=20)\n    #     logger.debug(response)\n    #     if response.status_code == 200:\n    #         return response.json()", "    #     if response.status_code == 200:\n    #         return response.json()\n\n    # except Exception as error:\n    #     logger.error(\"get: {}\", error)\n\n    try:\n        async with aiohttp.ClientSession() as session:\n            async with session.get(\n             url,\n             params=None,\n             headers=None, \n             timeout=20) as response:\n                logger.debug(response)\n                if response.status == 200:\n                    if response.content_length > MAX_RESPONSE_SIZE:\n                        logger.warning(\"Response content too large, skipping...\")\n                        return None  # Return None for large responses\n                    return await response.json(content_type=None)\n\n    except Exception as error:\n        logger.error(\"get: {}\", error)", "\n"]}
{"filename": "dxsp/utils/explorer_utils.py", "chunked_list": ["\"\"\"\n DEX SWAP\nEXPLORER\n\"\"\"\n\nfrom datetime import datetime, timedelta\n\nfrom loguru import logger\n\nfrom dxsp.config import settings", "\nfrom dxsp.config import settings\nfrom dxsp.utils.utils import get\n\n\nasync def get_explorer_abi(address):\n    \"\"\"\n    Retrieves the ABI (Application Binary Interface)\n    for the contract at the given address.\n", "    for the contract at the given address.\n\n    :param address: The address of the contract.\n    :type address: str\n\n    :return: The ABI of the contract if it exists, else None.\n    :rtype: str or None\n    \"\"\"\n    if not settings.dex_block_explorer_api:\n        return None", "    if not settings.dex_block_explorer_api:\n        return None\n\n    params = {\n        \"module\": \"contract\",\n        \"action\": \"getabi\",\n        \"address\": address,\n        \"apikey\": settings.dex_block_explorer_api,\n    }\n    resp = await get(url=settings.dex_block_explorer_url, params=params)", "    }\n    resp = await get(url=settings.dex_block_explorer_url, params=params)\n    return resp[\"result\"] if resp[\"status\"] == \"1\" else None\n\n\nasync def get_account_transactions(contract_address, wallet_address, period=24):\n    \"\"\"\n    Retrieves the account transactions\n    within a specified time period\n    for the main asset activity", "    within a specified time period\n    for the main asset activity\n    Not yet implemented\n\n    :param contract_address: The address of the contract.\n    :type contract_address: str\n    :param wallet_address: The address of the wallet.\n    :type wallet_address: str\n    :param period: The time period in hours\n    :type period: int", "    :param period: The time period in hours\n    :type period: int\n\n    :return: The transactions for the account.\n    \"\"\"\n    pnl_dict = {\"pnl\": 0, \"tokenList\": {}}\n    if not settings.dex_block_explorer_api:\n        return pnl_dict\n\n    params = {", "\n    params = {\n        \"module\": \"account\",\n        \"action\": \"tokentx\",\n        \"contractaddress\": contract_address,\n        \"address\": wallet_address,\n        \"page\": \"1\",\n        \"offset\": \"100\",\n        \"startblock\": \"0\",\n        \"endblock\": \"99999999\",", "        \"startblock\": \"0\",\n        \"endblock\": \"99999999\",\n        \"sort\": \"desc\",\n        \"apikey\": settings.dex_block_explorer_api,\n    }\n\n    response = await get(url=settings.dex_block_explorer_url, params=params)\n\n    if response.get(\"status\") == \"1\" and \"result\" in response:\n        current_time = datetime.utcnow()\n        time_history_start = current_time - timedelta(hours=period)\n\n        for entry in response[\"result\"]:\n            token_symbol = entry.get(\"tokenSymbol\")\n            value = int(entry.get(\"value\", 0))\n            timestamp = int(entry.get(\"timeStamp\", 0))\n            transaction_time = datetime.utcfromtimestamp(timestamp)\n\n            if transaction_time >= time_history_start and token_symbol:\n                pnl_dict[\"tokenList\"][token_symbol] = (\n                    pnl_dict[\"tokenList\"].get(token_symbol, 0) + value\n                )\n                pnl_dict[\"pnl\"] += value", "    if response.get(\"status\") == \"1\" and \"result\" in response:\n        current_time = datetime.utcnow()\n        time_history_start = current_time - timedelta(hours=period)\n\n        for entry in response[\"result\"]:\n            token_symbol = entry.get(\"tokenSymbol\")\n            value = int(entry.get(\"value\", 0))\n            timestamp = int(entry.get(\"timeStamp\", 0))\n            transaction_time = datetime.utcfromtimestamp(timestamp)\n\n            if transaction_time >= time_history_start and token_symbol:\n                pnl_dict[\"tokenList\"][token_symbol] = (\n                    pnl_dict[\"tokenList\"].get(token_symbol, 0) + value\n                )\n                pnl_dict[\"pnl\"] += value", "\n    return pnl_dict\n"]}
{"filename": "dxsp/protocols/zerox.py", "chunked_list": ["\"\"\"\n0\ufe0f\u20e3x\n\n\"\"\"\nfrom dxsp.config import settings\nfrom dxsp.main import DexSwap\nfrom dxsp.utils.utils import get\n\n\nclass DexSwapZeroX(DexSwap):\n    \"\"\"\n    A DEXSwap sub class using 0x protocol\n    Implementation of 0x swap protocol\n    https://0x.org/docs/0x-swap-api/introduction\n\n    \"\"\"\n\n    async def get_quote(self, buy_address, sell_address, amount=1):\n        \"\"\"\n        Retrieves a quote for a token swap.\n\n        Args:\n            buy_address (str): The address of the token to be bought.\n            sell_address (str): The address of the token to be sold.\n            amount (int, optional): The amount of tokens to be sold. Defaults to 1.\n\n        Returns:\n            float: The guaranteed price for the token swap.\n        \"\"\"\n        token_decimals = await self.contract_utils.get_token_decimals(sell_address)\n        out_amount = amount * (10**token_decimals)\n        url = (\n            f\"{settings.dex_0x_url}/swap/v1/quote\"\n            f\"?buyToken={str(buy_address)}&sellToken={str(sell_address)}&sellAmount={str(out_amount)}\"\n        )\n        headers = {\"0x-api-key\": settings.dex_0x_api_key}\n        response = await get(url, params=None, headers=headers)\n        if response:\n            return float(response[\"guaranteedPrice\"])\n\n    async def get_swap(self, buy_address, sell_address, amount):\n        \"\"\"\n        Asynchronously gets a swap order by calling the `get_quote`\n        method with the specified `buy_address`,\n        `sell_address`, and `amount` parameters.\n        Then, it calls the `get_sign` method of the\n        `account` object, passing the `swap_order`\n        as an argument, and returns the result.\n\n        :param buy_address: The buy address for the swap.\n        :param sell_address: The sell address for the swap.\n        :param amount: The amount for the swap.\n\n        :return: The result of calling the `get_sign` method\n        of the `account` object with the `swap_order`\n        as an argument.\n        \"\"\"\n        swap_order = await self.get_quote(buy_address, sell_address, amount)\n        return await self.account.get_sign(swap_order)", "\nclass DexSwapZeroX(DexSwap):\n    \"\"\"\n    A DEXSwap sub class using 0x protocol\n    Implementation of 0x swap protocol\n    https://0x.org/docs/0x-swap-api/introduction\n\n    \"\"\"\n\n    async def get_quote(self, buy_address, sell_address, amount=1):\n        \"\"\"\n        Retrieves a quote for a token swap.\n\n        Args:\n            buy_address (str): The address of the token to be bought.\n            sell_address (str): The address of the token to be sold.\n            amount (int, optional): The amount of tokens to be sold. Defaults to 1.\n\n        Returns:\n            float: The guaranteed price for the token swap.\n        \"\"\"\n        token_decimals = await self.contract_utils.get_token_decimals(sell_address)\n        out_amount = amount * (10**token_decimals)\n        url = (\n            f\"{settings.dex_0x_url}/swap/v1/quote\"\n            f\"?buyToken={str(buy_address)}&sellToken={str(sell_address)}&sellAmount={str(out_amount)}\"\n        )\n        headers = {\"0x-api-key\": settings.dex_0x_api_key}\n        response = await get(url, params=None, headers=headers)\n        if response:\n            return float(response[\"guaranteedPrice\"])\n\n    async def get_swap(self, buy_address, sell_address, amount):\n        \"\"\"\n        Asynchronously gets a swap order by calling the `get_quote`\n        method with the specified `buy_address`,\n        `sell_address`, and `amount` parameters.\n        Then, it calls the `get_sign` method of the\n        `account` object, passing the `swap_order`\n        as an argument, and returns the result.\n\n        :param buy_address: The buy address for the swap.\n        :param sell_address: The sell address for the swap.\n        :param amount: The amount for the swap.\n\n        :return: The result of calling the `get_sign` method\n        of the `account` object with the `swap_order`\n        as an argument.\n        \"\"\"\n        swap_order = await self.get_quote(buy_address, sell_address, amount)\n        return await self.account.get_sign(swap_order)", ""]}
{"filename": "dxsp/protocols/__init__.py", "chunked_list": ["from .oneinch import DexSwapOneInch\nfrom .uniswap import DexSwapUniswap\nfrom .zerox import DexSwapZeroX\n"]}
{"filename": "dxsp/protocols/uniswap.py", "chunked_list": ["\"\"\"\nuniswap  \ud83e\udd84\n\"\"\"\nfrom uniswap import Uniswap\n\nfrom dxsp.config import settings\nfrom dxsp.main import DexSwap\n\n\nclass DexSwapUniswap(DexSwap):\n    \"\"\"\n    A DEXSwap sub class using uniswap-python library\n\n    More info on uniswap-python library:\n    https://github.com/uniswap-python/uniswap-python\n\n    \"\"\"\n\n    async def get_quote(self, buy_address, sell_address, amount=1):\n        \"\"\"\n        Retrieves a quote for the given buy and sell addresses.\n\n        Args:\n            buy_address (str): The address of the token to buy.\n            sell_address (str): The address of the token to sell.\n            amount (int, optional): The amount of tokens to sell. Defaults to 1.\n\n        Returns:\n            float: The calculated quote for the given buy and sell addresses.\n        \"\"\"\n        try:\n            uniswap = Uniswap(\n                address=self.account.wallet_address,\n                private_key=self.account.private_key,\n                version=self.protocol_version,\n                web3=self.w3,\n                factory_contract_addr=settings.dex_factory_contract_addr,\n                router_contract_addr=settings.dex_router_contract_addr,\n            )\n            amount_wei = amount * (\n                10 ** (await self.contract_utils.get_token_decimals(sell_address))\n            )\n            quote = uniswap.get_price_input(sell_address, buy_address, amount_wei)\n            return round(\n                float(\n                    (\n                        quote\n                        / (\n                            10\n                            ** (\n                                await self.contract_utils.get_token_decimals(\n                                    buy_address\n                                )\n                            )\n                        )\n                    )\n                ),\n                5,\n            )\n\n        except Exception as error:\n            raise ValueError(f\"Quote failed {error}\")\n\n    async def get_swap(self, sell_address, buy_address, amount):\n        \"\"\"\n        Asynchronously gets the swap\n        for the specified sell address, buy address, and amount.\n\n        :param sell_address: The address of the token being sold.\n        :type sell_address: str\n        :param buy_address: The address of the token being bought.\n        :type buy_address: str\n        :param amount: The amount of tokens to be swapped.\n        :type amount: int\n        :return: The result of the swap.\n        :rtype: Any\n        :raises ValueError: If the swap fails.\n        \"\"\"\n        try:\n            uniswap = Uniswap(\n                address=self.account.wallet_address,\n                private_key=self.account.private_key,\n                version=self.protocol_version,\n                web3=self.w3,\n                factory_contract_addr=settings.dex_factory_contract_addr,\n                router_contract_addr=settings.dex_router_contract_addr,\n            )\n            return uniswap.make_trade(sell_address, buy_address, amount)\n\n        except Exception as error:\n            self.logger.debug(error)\n            raise ValueError(f\"Swap failed {error}\")", "\nclass DexSwapUniswap(DexSwap):\n    \"\"\"\n    A DEXSwap sub class using uniswap-python library\n\n    More info on uniswap-python library:\n    https://github.com/uniswap-python/uniswap-python\n\n    \"\"\"\n\n    async def get_quote(self, buy_address, sell_address, amount=1):\n        \"\"\"\n        Retrieves a quote for the given buy and sell addresses.\n\n        Args:\n            buy_address (str): The address of the token to buy.\n            sell_address (str): The address of the token to sell.\n            amount (int, optional): The amount of tokens to sell. Defaults to 1.\n\n        Returns:\n            float: The calculated quote for the given buy and sell addresses.\n        \"\"\"\n        try:\n            uniswap = Uniswap(\n                address=self.account.wallet_address,\n                private_key=self.account.private_key,\n                version=self.protocol_version,\n                web3=self.w3,\n                factory_contract_addr=settings.dex_factory_contract_addr,\n                router_contract_addr=settings.dex_router_contract_addr,\n            )\n            amount_wei = amount * (\n                10 ** (await self.contract_utils.get_token_decimals(sell_address))\n            )\n            quote = uniswap.get_price_input(sell_address, buy_address, amount_wei)\n            return round(\n                float(\n                    (\n                        quote\n                        / (\n                            10\n                            ** (\n                                await self.contract_utils.get_token_decimals(\n                                    buy_address\n                                )\n                            )\n                        )\n                    )\n                ),\n                5,\n            )\n\n        except Exception as error:\n            raise ValueError(f\"Quote failed {error}\")\n\n    async def get_swap(self, sell_address, buy_address, amount):\n        \"\"\"\n        Asynchronously gets the swap\n        for the specified sell address, buy address, and amount.\n\n        :param sell_address: The address of the token being sold.\n        :type sell_address: str\n        :param buy_address: The address of the token being bought.\n        :type buy_address: str\n        :param amount: The amount of tokens to be swapped.\n        :type amount: int\n        :return: The result of the swap.\n        :rtype: Any\n        :raises ValueError: If the swap fails.\n        \"\"\"\n        try:\n            uniswap = Uniswap(\n                address=self.account.wallet_address,\n                private_key=self.account.private_key,\n                version=self.protocol_version,\n                web3=self.w3,\n                factory_contract_addr=settings.dex_factory_contract_addr,\n                router_contract_addr=settings.dex_router_contract_addr,\n            )\n            return uniswap.make_trade(sell_address, buy_address, amount)\n\n        except Exception as error:\n            self.logger.debug(error)\n            raise ValueError(f\"Swap failed {error}\")", ""]}
{"filename": "dxsp/protocols/oneinch.py", "chunked_list": ["\"\"\"\nOneInch \ud83e\udd84\n\"\"\"\nfrom dxsp.config import settings\nfrom dxsp.main import DexSwap\n\n\nclass DexSwapOneInch(DexSwap):\n    \"\"\"\n    A DEXSwap sub class using 1inch protocol\n    https://github.com/mraniki/dxsp/issues/189\n\n    \"\"\"\n\n    async def get_quote(self, buy_address, sell_address, amount=1):\n        \"\"\"\n        Retrieves a quote for the\n        given buy and sell addresses and amount.\n\n        Args:\n            buy_address (str): The address of the token to buy.\n            sell_address (str): The address of the token to sell.\n            amount (int, optional): The amount of tokens to buy. Defaults to 1.\n\n        Returns:\n            float: The quote amount rounded to 2 decimal places.\n        \"\"\"\n        # try:\n        pass", "        #     min_amount = self.w3.to_wei(amount, 'ether')\n        #     quote_url = (\n        #         settings.dex_1inch_url\n        #         + str(self.chain_id)\n        #         + \"/quote?fromTokenAddress=\"\n        #         + str(buy_address)\n        #         + \"&toTokenAddress=\"\n        #         + str(sell_address)\n        #         + \"&amount=\"\n        #         + str(min_amount))", "        #         + \"&amount=\"\n        #         + str(min_amount))\n        #     quote_response = await self._get(\n        #         url=quote_url,\n        #         params=None,\n        #         headers=settings.headers)\n        #     self.logger.debug(\"quote_response {}\", quote_response)\n        #     if quote_response:\n        #         quote_amount = quote_response['toTokenAmount']\n        #         self.logger.debug(\"quote_amount {}\", quote_amount)", "        #         quote_amount = quote_response['toTokenAmount']\n        #         self.logger.debug(\"quote_amount {}\", quote_amount)\n        #         # quote_decimals = quote_response['fromToken']['decimals']\n        #         quote = self.w3.from_wei(int(quote_amount), 'ether')\n        #         # /(10 ** quote_decimals))\n        #         return round(quote, 2)\n\n    #     except Exception as error:\n    #         raise ValueError(f\"Approval failed {error}\")\n", "    #         raise ValueError(f\"Approval failed {error}\")\n\n    # async def get_approve(self, token_address):\n    #     # pass\n    #     try:\n    #         pass\n    # approval_check_URL = (\n    #     settings.dex_1inch_url\n    #     + str(self.chain_id)\n    #     + \"/approve/allowance?tokenAddress=\"", "    #     + str(self.chain_id)\n    #     + \"/approve/allowance?tokenAddress=\"\n    #     + str(sell_address)\n    #     + \"&walletAddress=\"\n    #     + str(self.wallet_address))\n    # approval_response = await self._get(\n    #     url=approval_check_URL,\n    #     params=None,\n    #     headers=settings.headers)\n    # approval_check = approval_response['allowance']", "    #     headers=settings.headers)\n    # approval_check = approval_response['allowance']\n    # if (approval_check == 0):\n    #     approval_URL = (\n    #         settings.dex_1inch_url\n    #         + str(self.chain_id)\n    #         + \"/approve/transaction?tokenAddress=\"\n    #         + str(sell_address))\n    #     approval_response = await self._get(approval_URL)\n    #     return approval_response", "    #     approval_response = await self._get(approval_URL)\n    #     return approval_response\n    #     except Exception as error:\n    #         raise ValueError(f\"Approval failed {error}\")\n\n    # async def get_swap(self, sell_address, buy_address, amount):\n\n    #     try:\n    #         pass\n    # swap_url = (", "    #         pass\n    # swap_url = (\n    #     settings.dex_1inch_url\n    #     + str(self.chain_id)\n    #     + \"/swap?fromTokenAddress=\"\n    #     + sell_address\n    #     + \"&toTokenAddress=\"\n    #     + buy_address\n    #     + \"&amount=\"\n    #     + amount", "    #     + \"&amount=\"\n    #     + amount\n    #     + \"&fromAddress=\"\n    #     + self.wallet_address\n    #     + \"&slippage=\"\n    #     + settings.dex_trading_slippage\n    #     )\n    # swap_order = await self._get(\n    #     url=swap_url,\n    #     params=None,", "    #     url=swap_url,\n    #     params=None,\n    #     headers=settings.headers\n    #     )\n    # swap_order_status = swap_order['statusCode']\n    # if swap_order_status != 200:\n    #     return\n    # return swap_order\n    # except Exception as error:\n    #     raise ValueError(f\"Swap failed {error}\")", "    # except Exception as error:\n    #     raise ValueError(f\"Swap failed {error}\")\n"]}
{"filename": "examples/example.py", "chunked_list": ["\"\"\"\nDXSP Example\n\"\"\"\nimport asyncio\nimport sys\n\nimport uvicorn\nfrom fastapi import FastAPI\nfrom loguru import logger\n", "from loguru import logger\n\nfrom dxsp import DexSwap\nfrom dxsp.config import settings\n\nlogger.remove()\nlogger.add(sys.stderr, level=\"INFO\")\n \n\n", "\n\nasync def main():\n    while True:\n        # SWAP HELPER\n        dex = DexSwap()\n        # print(type(dex))\n        print(settings.VALUE)\n\n        # settings.setenv()", "\n        # settings.setenv()\n        print(dex.account)\n        symbol = 'WBTC'\n\n        # # Contract Address\n        address = await dex.contract_utils.search_contract_address(symbol)\n        print(\"address \", address)\n        # # token_contract found 0x2260fac5e5542a773aa44fbcfedf7c193bc2c599\n", "        # # token_contract found 0x2260fac5e5542a773aa44fbcfedf7c193bc2c599\n\n        # # get contract and underlying ABI\n        token_contract = await dex.contract_utils.get_token_contract(address)\n        print(\"Contract \", token_contract)\n        # Contract  <web3._utils.datatypes.Contract object at 0x10acdb050>\n\n        quote = await dex.get_quote(symbol)\n        print(\"quote \", quote)\n        # quote  \ud83e\udd84 29761.19589 USDT", "        print(\"quote \", quote)\n        # quote  \ud83e\udd84 29761.19589 USDT\n\n        # # BUY 10 USDC to SWAP with BITCOIN\n        # demo_tx = await dex.get_swap('USDT','WBTC',10)\n        # print(\"demo_tx \", demo_tx)\n\n        await asyncio.sleep(7200)\n\n", "\n\napp = FastAPI()\n\n\n@app.on_event('startup')\nasync def start():\n    asyncio.create_task(main())\n\n", "\n\n@app.get(\"/\")\ndef read_root():\n    return {\"DXSP is online\"}\n\n\n@app.get(\"/health\")\ndef health_check():\n    return {\"DXSP is online\"}", "def health_check():\n    return {\"DXSP is online\"}\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host='0.0.0.0', port=8080)\n"]}
{"filename": "docs/conf.py", "chunked_list": ["# Configuration file for the Sphinx documentation builder.\n\n\n# -- Path setup --------------------------------------------------------------\n\nimport os\nimport sys\nfrom pathlib import Path\nfrom typing import Any, Dict\n", "from typing import Any, Dict\n\nimport pydata_sphinx_theme\nfrom sphinx.application import Sphinx\n\nsys.path.insert(0, os.path.abspath('../'))\n\n\n# -- Project information -----------------------------------------------------\n", "# -- Project information -----------------------------------------------------\n\nproject = 'dxsp'\ncopyright = '2023, mraniki'\nauthor = 'mraniki'\nlanguage = \"en\"\n\n# -- General configuration ---------------------------------------------------\n\nextensions = [", "\nextensions = [\n    'sphinx.ext.autodoc',\n    'sphinx.ext.autosummary',\n    'sphinx.ext.napoleon',\n    'sphinx.ext.viewcode',\n    \"sphinx.ext.intersphinx\",\n    \"hoverxref.extension\",\n    \"sphinx.ext.extlinks\",\n    \"sphinx_design\",", "    \"sphinx.ext.extlinks\",\n    \"sphinx_design\",\n    \"myst_parser\",\n    \"sphinx_copybutton\",\n    \"notfound.extension\",\n    # \"autoapi.extension\",\n]\n\n# -- Extension configuration ---------------------------------------------------\n", "# -- Extension configuration ---------------------------------------------------\n\n# -- intersphinx ------------\n\nintersphinx_mapping = {\n    \"sphinx\": (\"https://www.sphinx-doc.org/en/master/\", None),\n    # - :doc:`sphinx:usage/extensions/intersphinx`\n    \"dynaconf\": (\"https://www.dynaconf.com\", None),\n    \"python\": (\"https://docs.python.org/3\", None),\n    \"talky\": (\"https://talky.readthedocs.io/en/latest\", None),", "    \"python\": (\"https://docs.python.org/3\", None),\n    \"talky\": (\"https://talky.readthedocs.io/en/latest\", None),\n    \"talky-dev\": (\"https://talky.readthedocs.io/en/dev/\", None),\n    \"findmyorder\": (\n        \"https://findmyorder.readthedocs.io/en/latest\", None),\n    \"dxsp\": (\"https://dxsp.readthedocs.io/en/latest\", None),\n    \"iamlistening\": (\n        \"https://iamlistening.readthedocs.io/en/latest\", None),\n    \"talkytrend\": (\"https://talkytrend.readthedocs.io/en/latest\", None),\n    \"myllm\": (\"https://myllm.readthedocs.io/en/latest\", None),", "    \"talkytrend\": (\"https://talkytrend.readthedocs.io/en/latest\", None),\n    \"myllm\": (\"https://myllm.readthedocs.io/en/latest\", None),\n    \"community\": (\"https://tt-plugins.readthedocs.io/en/latest\", None),\n}\n\nintersphinx_disabled_reftypes = [\"*\"]\n\n\n# -- hoverxref ----------------\n", "# -- hoverxref ----------------\n\nhoverxref_intersphinx = [\n    'readthedocs',\n    'sphinx',\n    'python',\n    'talky',\n    'findmyorder',\n    'dxsp',\n    'iamlistening',", "    'dxsp',\n    'iamlistening',\n    'talkytrend',\n    'myllm',\n\n]\n\n# -- autodoc --------------------\n\nautoclass_content = 'both'", "\nautoclass_content = 'both'\nautodoc_inherit_docstrings = True \nset_type_checking_flag = True \nautodoc_member_order = 'bysource'\nadd_module_names = True\n\n# -- autoapi -------------------\n\n# autoapi_type = \"python\"", "\n# autoapi_type = \"python\"\n# autoapi_dirs = ['../iamlistening']\n# autoapi_keep_files = True\n# autoapi_root = \"api\"\n# autoapi_member_order = \"groupwise\"\n\n\n# -- napoleon -------------------\n", "# -- napoleon -------------------\n\nnapoleon_google_docstring = True\n\n# -- MyST options -----------------\n\n# This allows us to use ::: to denote directives, useful for admonitions\nmyst_enable_extensions = [\"colon_fence\", \"linkify\", \"substitution\"]\nmyst_heading_anchors = 2\nmyst_substitutions = {\"rtd\": \"[Read the Docs](https://readthedocs.org/)\"}", "myst_heading_anchors = 2\nmyst_substitutions = {\"rtd\": \"[Read the Docs](https://readthedocs.org/)\"}\n\nmaster_doc = 'index'\nsource_suffix = ['.rst', '.md']\ntemplates_path = [\"_templates\"]\nexclude_patterns = [\"_build\", \"Thumbs.db\", \".DS_Store\"]\n\n# -- Sitemap ----------------------\n", "# -- Sitemap ----------------------\n\n# ReadTheDocs has its own way of generating sitemaps, etc.\nif not os.environ.get(\"READTHEDOCS\"):\n    extensions += [\"sphinx_sitemap\"]\n\n    html_baseurl = os.environ.get(\"SITEMAP_URL_BASE\", \"http://127.0.0.1:8000/\")\n    sitemap_locales = [None]\n    sitemap_url_scheme = \"{link}\"\n", "\n\n# -- Options for HTML output --------\n\nhtml_static_path = [\"_static\"]\nhtml_css_files = [\"custom.css\"]\nhtml_logo = '_static/logo.png'\nhtml_favicon = '_static/favicon.ico'\nhtml_show_sphinx = False\nhtml_show_copyright = False", "html_show_sphinx = False\nhtml_show_copyright = False\nhtml_theme = \"pydata_sphinx_theme\"\nhtml_theme_options = {\n    \"secondary_sidebar_items\": [\"page-toc\"],\n    \"logo\": {\n        \"link\": \"https://talky.readthedocs.io\",\n    },\n    \"icon_links\": [\n        {", "    \"icon_links\": [\n        {\n            \"name\": \"GitHub\",\n            \"url\": \"https://github.com/mraniki/tt/\",\n            \"icon\": \"fa-brands fa-github\",\n            \"type\": \"fontawesome\",\n        },\n        {\n            \"name\": \"Telegram\",\n            \"url\": \"https://t.me/TTTalkyTraderChat/1\",", "            \"name\": \"Telegram\",\n            \"url\": \"https://t.me/TTTalkyTraderChat/1\",\n            \"icon\": \"fa-brands fa-telegram\",\n        },\n        {\n            \"name\": \"Mastodon\",\n            \"url\": \"https://mastodon.social/@MrAniki\",\n            \"icon\": \"fa-brands fa-mastodon\",\n        },\n        {", "        },\n        {\n            \"name\": \"Tips\",\n            \"url\": \"https://coindrop.to/mraniki\",\n            \"icon\": \"fa-solid fa-burger\",\n        },\n        ],\n\n}\nhtml_context = {", "}\nhtml_context = {\n   \"default_mode\": \"dark\",\n\n}\n"]}
