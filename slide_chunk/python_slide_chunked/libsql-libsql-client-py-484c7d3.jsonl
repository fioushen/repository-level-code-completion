{"filename": "tests/test_args.py", "chunked_list": ["import pytest\n\n\n@pytest.mark.asyncio\nasync def test_pos_args_implicit_index(client):\n    rs = await client.execute(\"SELECT ?, ?\", [\"one\", \"two\"])\n    assert tuple(rs.rows[0]) == (\"one\", \"two\")\n\n\n@pytest.mark.asyncio", "\n@pytest.mark.asyncio\nasync def test_pos_args_explicit_index(client):\n    rs = await client.execute(\"SELECT ?2, ?3, ?1\", [\"one\", \"two\", \"three\"])\n    assert tuple(rs.rows[0]) == (\"two\", \"three\", \"one\")\n\n\n@pytest.mark.asyncio\nasync def test_pos_args_explicit_index_with_holes(client):\n    rs = await client.execute(\"SELECT ?3, ?1\", [\"one\", \"two\", \"three\"])", "async def test_pos_args_explicit_index_with_holes(client):\n    rs = await client.execute(\"SELECT ?3, ?1\", [\"one\", \"two\", \"three\"])\n    assert tuple(rs.rows[0]) == (\"three\", \"one\")\n\n\n@pytest.mark.asyncio\nasync def test_pos_args_implicit_and_explicit_index(client):\n    rs = await client.execute(\"SELECT ?2, ?, ?3\", [\"one\", \"two\", \"three\"])\n    assert tuple(rs.rows[0]) == (\"two\", \"three\", \"three\")\n", "    assert tuple(rs.rows[0]) == (\"two\", \"three\", \"three\")\n\n\n@pytest.mark.asyncio\n@pytest.mark.parametrize(\"sign\", [\":\", \"@\", \"$\"])\nasync def test_named_args(client, sign):\n    rs = await client.execute(\n        f\"SELECT {sign}b, {sign}a\", {\"a\": \"one\", f\"{sign}b\": \"two\"}\n    )\n    assert tuple(rs.rows[0]) == (\"two\", \"one\")", "    )\n    assert tuple(rs.rows[0]) == (\"two\", \"one\")\n\n\n@pytest.mark.asyncio\n@pytest.mark.parametrize(\"sign\", [\":\", \"@\", \"$\"])\nasync def test_named_args_used_multiple_times(client, sign):\n    rs = await client.execute(\n        f\"SELECT {sign}b, {sign}a, {sign}b || {sign}a\", {\"a\": \"one\", f\"{sign}b\": \"two\"}\n    )", "        f\"SELECT {sign}b, {sign}a, {sign}b || {sign}a\", {\"a\": \"one\", f\"{sign}b\": \"two\"}\n    )\n    assert tuple(rs.rows[0]) == (\"two\", \"one\", \"twoone\")\n\n\n@pytest.mark.asyncio\n@pytest.mark.parametrize(\"sign\", [\":\", \"@\", \"$\"])\nasync def test_named_args_and_pos_args(client, sign):\n    rs = await client.execute(\n        f\"SELECT {sign}b, {sign}a, ?1\", {\"a\": \"one\", f\"{sign}b\": \"two\"}", "    rs = await client.execute(\n        f\"SELECT {sign}b, {sign}a, ?1\", {\"a\": \"one\", f\"{sign}b\": \"two\"}\n    )\n    assert tuple(rs.rows[0]) == (\"two\", \"one\", \"two\")\n"]}
{"filename": "tests/test_network_errors.py", "chunked_list": ["import pytest\n\nimport libsql_client\n\n\n@pytest.fixture(params=[\".close_ws\", \".close_tcp\"])\ndef trigger_net_error(request):\n    return request.param\n\n", "\n\n@pytest.mark.asyncio\nasync def test_execute(ws_client, trigger_net_error):\n    with pytest.raises(libsql_client.LibsqlError) as excinfo:\n        await ws_client.execute(trigger_net_error)\n    assert excinfo.value.code == \"HRANA_WEBSOCKET_ERROR\"\n\n    rs = await ws_client.execute(\"SELECT 42\")\n    assert rs[0].astuple() == (42,)", "    rs = await ws_client.execute(\"SELECT 42\")\n    assert rs[0].astuple() == (42,)\n\n\n@pytest.mark.asyncio\nasync def test_batch(ws_client, trigger_net_error):\n    with pytest.raises(libsql_client.LibsqlError) as excinfo:\n        await ws_client.batch([\"SELECT 42\", trigger_net_error, \"SELECT 24\"])\n    assert excinfo.value.code == \"HRANA_WEBSOCKET_ERROR\"\n", "    assert excinfo.value.code == \"HRANA_WEBSOCKET_ERROR\"\n\n    rs = await ws_client.execute(\"SELECT 42\")\n    assert rs[0].astuple() == (42,)\n\n\n@pytest.mark.asyncio\nasync def test_transaction(ws_client, trigger_net_error):\n    txn = ws_client.transaction()\n\n    with pytest.raises(libsql_client.LibsqlError) as excinfo:\n        await txn.execute(trigger_net_error)", "    txn = ws_client.transaction()\n\n    with pytest.raises(libsql_client.LibsqlError) as excinfo:\n        await txn.execute(trigger_net_error)\n    assert excinfo.value.code == \"HRANA_WEBSOCKET_ERROR\"\n\n    with pytest.raises(libsql_client.LibsqlError) as excinfo:\n        await txn.commit()\n    assert excinfo.value.code == \"HRANA_WEBSOCKET_ERROR\"\n", "    assert excinfo.value.code == \"HRANA_WEBSOCKET_ERROR\"\n\n    rs = await ws_client.execute(\"SELECT 42\")\n    assert rs[0].astuple() == (42,)\n"]}
{"filename": "tests/test_execute.py", "chunked_list": ["import pytest\n\nimport libsql_client\n\n\n@pytest.mark.asyncio\nasync def test_query_value(client):\n    rs = await client.execute(\"SELECT 42\")\n    assert len(rs.columns) == 1\n    assert len(rs.rows) == 1", "    assert len(rs.columns) == 1\n    assert len(rs.rows) == 1\n    row = rs.rows[0]\n    assert len(row) == 1\n    assert row[0] == 42\n\n\n@pytest.mark.asyncio\nasync def test_query_row(client):\n    rs = await client.execute(\"SELECT 1 AS one, 'two' AS two, 0.5 AS three\")", "async def test_query_row(client):\n    rs = await client.execute(\"SELECT 1 AS one, 'two' AS two, 0.5 AS three\")\n    assert rs.columns == (\"one\", \"two\", \"three\")\n    assert len(rs.rows) == 1\n    row = rs.rows[0]\n    assert len(row) == 3\n    assert (row[0], row[1], row[2]) == (1, \"two\", 0.5)\n    assert (row[\"one\"], row[\"two\"], row[\"three\"]) == (1, \"two\", 0.5)\n\n", "\n\n@pytest.mark.asyncio\nasync def test_query_multiple_rows(client):\n    rs = await client.execute(\"VALUES (1, 'one'), (2, 'two'), (3, 'three')\")\n    assert len(rs.columns) == 2\n    assert len(rs.rows) == 3\n    assert tuple(rs.rows[0]) == (1, \"one\")\n    assert tuple(rs.rows[1]) == (2, \"two\")\n    assert tuple(rs.rows[2]) == (3, \"three\")", "    assert tuple(rs.rows[1]) == (2, \"two\")\n    assert tuple(rs.rows[2]) == (3, \"three\")\n\n\n@pytest.mark.asyncio\nasync def test_statement_without_args(client):\n    rs = await client.execute(libsql_client.Statement(\"SELECT 42\"))\n    assert rs[0][0] == 42\n\n", "\n\n@pytest.mark.asyncio\nasync def test_statement_with_args(client):\n    rs = await client.execute(libsql_client.Statement(\"SELECT ?\", [10]))\n    assert rs[0][0] == 10\n\n\n@pytest.mark.asyncio\nasync def test_error_no_such_column(client):\n    with pytest.raises(libsql_client.LibsqlError) as excinfo:\n        await client.execute(\"SELECT foo\")", "@pytest.mark.asyncio\nasync def test_error_no_such_column(client):\n    with pytest.raises(libsql_client.LibsqlError) as excinfo:\n        await client.execute(\"SELECT foo\")\n    assert \"no such column: foo\" in str(excinfo.value)\n\n\n@pytest.mark.asyncio\nasync def test_error_syntax(client):\n    with pytest.raises(libsql_client.LibsqlError) as excinfo:\n        await client.execute(\"SELECT\")", "async def test_error_syntax(client):\n    with pytest.raises(libsql_client.LibsqlError) as excinfo:\n        await client.execute(\"SELECT\")\n    assert \"unexpected end of input\" in str(excinfo.value) or \"incomplete input\" in str(\n        excinfo.value\n    )\n\n\n@pytest.mark.asyncio\nasync def test_error_multiple_statements(url, client):\n    if url.startswith(\"file:\"):\n        return pytest.skip(\n            \"sqlite3 library does not provide a robust way \"\n            \"to recognize that the user attempted to execute multiple statements\"\n        )", "@pytest.mark.asyncio\nasync def test_error_multiple_statements(url, client):\n    if url.startswith(\"file:\"):\n        return pytest.skip(\n            \"sqlite3 library does not provide a robust way \"\n            \"to recognize that the user attempted to execute multiple statements\"\n        )\n\n    with pytest.raises(libsql_client.LibsqlError) as excinfo:\n        await client.execute(\"SELECT 1; SELECT 2\")", "    with pytest.raises(libsql_client.LibsqlError) as excinfo:\n        await client.execute(\"SELECT 1; SELECT 2\")\n    assert \"one statement\" in str(excinfo.value)\n\n\n@pytest.mark.asyncio\nasync def test_rows_affected_insert(client):\n    await client.batch(\n        [\n            \"DROP TABLE IF EXISTS t\",", "        [\n            \"DROP TABLE IF EXISTS t\",\n            \"CREATE TABLE t (a)\",\n        ]\n    )\n    rs = await client.execute(\"INSERT INTO t VALUES (1), (2)\")\n    assert rs.rows_affected == 2\n\n\n@pytest.mark.asyncio", "\n@pytest.mark.asyncio\nasync def test_rows_affected_delete(client):\n    await client.batch(\n        [\n            \"DROP TABLE IF EXISTS t\",\n            \"CREATE TABLE t (a)\",\n            \"INSERT INTO t VALUES (1), (2), (3), (4), (5)\",\n        ]\n    )", "        ]\n    )\n    rs = await client.execute(\"DELETE FROM t WHERE a >= 3\")\n    assert rs.rows_affected == 3\n\n\n@pytest.mark.asyncio\nasync def test_last_insert_rowid(client):\n    await client.batch(\n        [", "    await client.batch(\n        [\n            \"DROP TABLE IF EXISTS t\",\n            \"CREATE TABLE t (a)\",\n            \"INSERT INTO t VALUES ('one'), ('two')\",\n        ]\n    )\n    insert_rs = await client.execute(\"INSERT INTO t VALUES ('three')\")\n    assert insert_rs.last_insert_rowid is not None\n    select_rs = await client.execute(", "    assert insert_rs.last_insert_rowid is not None\n    select_rs = await client.execute(\n        \"SELECT a FROM t WHERE ROWID = ?\", [insert_rs.last_insert_rowid]\n    )\n    assert select_rs[0].astuple() == (\"three\",)\n"]}
{"filename": "tests/test_sync.py", "chunked_list": ["import pytest\n\nimport libsql_client\n\n\n@pytest.fixture\ndef client_sync(url):\n    with libsql_client.create_client_sync(url) as client:\n        yield client\n", "\n\n@pytest.fixture\ndef transaction_client_sync(transaction_url):\n    with libsql_client.create_client_sync(transaction_url) as client:\n        yield client\n\n\ndef test_execute(client_sync):\n    rs = client_sync.execute(\"SELECT 1 AS one, 'two' AS two\")\n    assert rs.columns == (\"one\", \"two\")\n    assert len(rs.rows) == 1\n    assert rs.rows[0].astuple() == (1, \"two\")", "def test_execute(client_sync):\n    rs = client_sync.execute(\"SELECT 1 AS one, 'two' AS two\")\n    assert rs.columns == (\"one\", \"two\")\n    assert len(rs.rows) == 1\n    assert rs.rows[0].astuple() == (1, \"two\")\n\n\ndef test_execute_error(client_sync):\n    with pytest.raises(libsql_client.LibsqlError):\n        client_sync.execute(\"SELECT foo\")", "\n\ndef test_batch(client_sync):\n    rss = client_sync.batch(\n        [\n            \"SELECT 1+1\",\n            (\"SELECT ? AS one, ? AS two\", [10, \"two\"]),\n        ]\n    )\n    assert [len(rs) for rs in rss] == [1, 1]\n    assert rss[0][0].astuple() == (2,)\n    assert rss[1][0].astuple() == (10, \"two\")", "\n\ndef test_transaction_commit(transaction_client_sync):\n    transaction_client_sync.batch(\n        [\n            \"DROP TABLE IF EXISTS t\",\n            \"CREATE TABLE t (a)\",\n        ]\n    )\n\n    with transaction_client_sync.transaction() as transaction:\n        transaction.execute(\"INSERT INTO t VALUES ('one'), ('two')\")\n        rs = transaction.execute(\"SELECT COUNT(*) FROM t\")\n        assert rs[0][0] == 2\n        transaction.commit()\n    assert transaction.closed\n\n    rs = transaction_client_sync.execute(\"SELECT COUNT(*) FROM t\")\n    assert rs[0][0] == 2", "\n\ndef test_transaction_rollback(transaction_client_sync):\n    transaction_client_sync.batch(\n        [\n            \"DROP TABLE IF EXISTS t\",\n            \"CREATE TABLE t (a)\",\n        ]\n    )\n\n    with transaction_client_sync.transaction() as transaction:\n        transaction.execute(\"INSERT INTO t VALUES ('one'), ('two')\")\n        rs = transaction.execute(\"SELECT COUNT(*) FROM t\")\n        assert rs[0][0] == 2\n        transaction.rollback()\n    assert transaction.closed\n\n    rs = transaction_client_sync.execute(\"SELECT COUNT(*) FROM t\")\n    assert rs[0][0] == 0", "\n\ndef test_close_twice(client_sync):\n    client_sync.close()\n    client_sync.close()\n\n\ndef test_close_transaction_twice(transaction_client_sync):\n    with transaction_client_sync.transaction() as transaction:\n        transaction.close()", "\n\ndef test_close_transaction_after_client(transaction_client_sync):\n    transaction = transaction_client_sync.transaction()\n    transaction_client_sync.close()\n    transaction.close()\n"]}
{"filename": "tests/test_result.py", "chunked_list": ["import pytest\n\n\n@pytest.mark.asyncio\nasync def test_blob(client):\n    rs = await client.execute(\"SELECT X'deadbeef'\")\n    assert rs.rows[0][0] == b\"\\xde\\xad\\xbe\\xef\"\n\n\n@pytest.mark.asyncio", "\n@pytest.mark.asyncio\nasync def test_columns(client):\n    rs = await client.execute(\"SELECT 1 AS a, 2 AS b, 3 AS c\")\n    assert rs.columns == (\"a\", \"b\", \"c\")\n    row = rs.rows[0]\n    assert row[\"a\"] == 1\n    assert row[\"b\"] == 2\n    assert row[\"c\"] == 3\n", "    assert row[\"c\"] == 3\n\n\n@pytest.mark.asyncio\nasync def test_rows(client):\n    rs = await client.execute(\"VALUES (1, 'one'), (2, 'two'), (3, 'three')\")\n    assert len(rs.rows) == 3\n    assert len(rs) == 3\n\n    assert rs.rows[0][0] == 1", "\n    assert rs.rows[0][0] == 1\n    assert rs.rows[0][1] == \"one\"\n    assert rs.rows[1][0] == 2\n    assert rs.rows[1][1] == \"two\"\n    assert rs.rows[2][0] == 3\n    assert rs.rows[2][1] == \"three\"\n\n    for i in range(3):\n        assert rs[i] is rs.rows[i]", "    for i in range(3):\n        assert rs[i] is rs.rows[i]\n    assert list(rs) == rs.rows\n\n\n@pytest.mark.asyncio\nasync def test_row_repr(client):\n    rs = await client.execute(\"SELECT 42, 0.5, 'brontosaurus', NULL\")\n    assert repr(rs.rows[0]) == \"(42, 0.5, 'brontosaurus', None)\"\n", "    assert repr(rs.rows[0]) == \"(42, 0.5, 'brontosaurus', None)\"\n\n\n@pytest.mark.asyncio\nasync def test_row_slice(client):\n    rs = await client.execute(\"SELECT 'one', 'two', 'three', 'four', 'five'\")\n    assert rs.rows[0][1:3] == (\"two\", \"three\")\n\n\n@pytest.mark.asyncio", "\n@pytest.mark.asyncio\nasync def test_row_tuple(client):\n    rs = await client.execute(\"SELECT 'one', 'two', 'three'\")\n    assert tuple(rs.rows[0]) == (\"one\", \"two\", \"three\")\n\n\n@pytest.mark.asyncio\nasync def test_row_astuple(client):\n    rs = await client.execute(\"SELECT 'one', 'two', 'three'\")", "async def test_row_astuple(client):\n    rs = await client.execute(\"SELECT 'one', 'two', 'three'\")\n    assert rs.rows[0].astuple() == (\"one\", \"two\", \"three\")\n\n\n@pytest.mark.asyncio\nasync def test_row_asdict(client):\n    rs = await client.execute(\"SELECT 1 AS one, 2 AS two, 3 AS three\")\n    assert rs.rows[0].asdict() == {\"one\": 1, \"two\": 2, \"three\": 3}\n    assert rs.rows[0].asdict() == rs.rows[0]._asdict()", "    assert rs.rows[0].asdict() == {\"one\": 1, \"two\": 2, \"three\": 3}\n    assert rs.rows[0].asdict() == rs.rows[0]._asdict()\n\n\ntry:\n    import pandas\nexcept ImportError:\n    pandas = None\npandas_only = pytest.mark.skipif(pandas is None, reason=\"pandas not installed\")\n", "pandas_only = pytest.mark.skipif(pandas is None, reason=\"pandas not installed\")\n\n\n@pytest.mark.asyncio\n@pandas_only\nasync def test_pandas_from_records(client):\n    rs = await client.execute(\"SELECT 1, 'two', 3.0\")\n    data_frame = pandas.DataFrame.from_records(rs.rows)\n    assert data_frame.shape == (1, 3)\n", "    assert data_frame.shape == (1, 3)\n\n\n@pytest.mark.asyncio\n@pandas_only\nasync def test_pandas_ctor(client):\n    rs = await client.execute(\"SELECT 1 AS one, 'two' AS two, 3.0 AS three\")\n    data_frame = pandas.DataFrame(rs)\n    assert data_frame.shape == (1, 3)\n    assert tuple(data_frame.columns) == (\"one\", \"two\", \"three\")", "    assert data_frame.shape == (1, 3)\n    assert tuple(data_frame.columns) == (\"one\", \"two\", \"three\")\n"]}
{"filename": "tests/__init__.py", "chunked_list": [""]}
{"filename": "tests/test_batch.py", "chunked_list": ["import asyncio\n\nimport pytest\n\nimport libsql_client\n\n\n@pytest.mark.asyncio\nasync def test_multiple_queries(client):\n    rss = await client.batch(", "async def test_multiple_queries(client):\n    rss = await client.batch(\n        [\n            \"SELECT 1+1\",\n            (\"SELECT 1 AS one, 2 AS two\",),\n            libsql_client.Statement(\"SELECT ?\", [\"boomerang\"]),\n            (\"VALUES (?), (?)\", [\"big\", \"ben\"]),\n        ]\n    )\n", "    )\n\n    assert [len(rs) for rs in rss] == [1, 1, 1, 2]\n\n    assert rss[0][0].astuple() == (2,)\n    assert rss[1][0].asdict() == {\"one\": 1, \"two\": 2}\n    assert rss[2][0].astuple() == (\"boomerang\",)\n    assert rss[3][0].astuple() == (\"big\",)\n    assert rss[3][1].astuple() == (\"ben\",)\n", "    assert rss[3][1].astuple() == (\"ben\",)\n\n\n@pytest.mark.asyncio\nasync def test_statements_are_executed_sequentially(client):\n    rss = await client.batch(\n        [\n            \"DROP TABLE IF EXISTS t\",  # 0\n            \"CREATE TABLE t (a, b)\",  # 1\n            \"INSERT INTO t VALUES (1, 'one')\",  # 2", "            \"CREATE TABLE t (a, b)\",  # 1\n            \"INSERT INTO t VALUES (1, 'one')\",  # 2\n            \"SELECT * FROM t ORDER BY a\",  # 3\n            \"INSERT INTO t VALUES (2, 'two')\",  # 4\n            \"SELECT * FROM t ORDER BY a\",  # 5\n            \"DROP TABLE t\",  # 6\n        ]\n    )\n\n    assert len(rss) == 7", "\n    assert len(rss) == 7\n    assert [r.astuple() for r in rss[3].rows] == [(1, \"one\")]\n    assert [r.astuple() for r in rss[5].rows] == [(1, \"one\"), (2, \"two\")]\n\n\n@pytest.mark.asyncio\nasync def test_statements_are_executed_in_transaction(client):\n    await client.batch(\n        [", "    await client.batch(\n        [\n            \"DROP TABLE IF EXISTS t1\",\n            \"DROP TABLE IF EXISTS t2\",\n            \"CREATE TABLE t1 (a)\",\n            \"CREATE TABLE t2 (a)\",\n        ]\n    )\n\n    async def step(i):", "\n    async def step(i):\n        rss = await client.batch(\n            [\n                (\"INSERT INTO t1 VALUES (?)\", [i]),\n                (\"INSERT INTO t2 VALUES (?)\", [i * 10]),\n                \"SELECT SUM(a) FROM t1\",\n                \"SELECT SUM(a) FROM t2\",\n            ]\n        )", "            ]\n        )\n        sum1 = int(rss[2][0][0])\n        sum2 = int(rss[3][0][0])\n        assert sum2 == sum1 * 10\n\n    n = 100\n    await asyncio.gather(*(asyncio.create_task(step(i)) for i in range(n)))\n\n    rs1 = await client.execute(\"SELECT SUM(a) FROM t1\")", "\n    rs1 = await client.execute(\"SELECT SUM(a) FROM t1\")\n    assert rs1[0][0] == n * (n - 1) / 2\n    rs2 = await client.execute(\"SELECT SUM(a) FROM t2\")\n    assert rs2[0][0] == 10 * n * (n - 1) / 2\n\n\n@pytest.mark.asyncio\nasync def test_error(client):\n    with pytest.raises(libsql_client.LibsqlError) as excinfo:\n        await client.batch(\n            [\n                \"SELECT 1+1\",\n                \"SELECT foobar\",\n            ]\n        )", "async def test_error(client):\n    with pytest.raises(libsql_client.LibsqlError) as excinfo:\n        await client.batch(\n            [\n                \"SELECT 1+1\",\n                \"SELECT foobar\",\n            ]\n        )\n    assert \"no such column: foobar\" in str(excinfo.value)\n", "    assert \"no such column: foobar\" in str(excinfo.value)\n\n\n@pytest.mark.asyncio\nasync def test_error_rollback(client):\n    await client.batch(\n        [\n            \"DROP TABLE IF EXISTS t\",\n            \"CREATE TABLE t (a)\",\n            \"INSERT INTO t VALUES ('one')\",", "            \"CREATE TABLE t (a)\",\n            \"INSERT INTO t VALUES ('one')\",\n        ]\n    )\n\n    with pytest.raises(libsql_client.LibsqlError):\n        await client.batch(\n            [\n                \"INSERT INTO t VALUES ('two')\",\n                \"SELECT foobar\",\n                \"INSERT INTO t VALUES ('three')\",\n            ]\n        )", "\n    rs = await client.execute(\"SELECT COUNT(*) FROM t\")\n    assert rs[0][0] == 1\n"]}
{"filename": "tests/test_transaction.py", "chunked_list": ["import pytest\n\nimport libsql_client\n\n\nasync def _assert_closed(t):\n    assert t.closed\n    with pytest.raises(libsql_client.LibsqlError) as excinfo:\n        await t.execute(\"SELECT 1\")\n    assert excinfo.value.code == \"TRANSACTION_CLOSED\"", "    assert excinfo.value.code == \"TRANSACTION_CLOSED\"\n\n\n@pytest.mark.asyncio\nasync def test_multiple_queries(transaction_client):\n    with transaction_client.transaction() as t:\n        rs = await t.execute(\"SELECT 1\")\n        assert rs[0][0] == 1\n\n        rs = await t.execute(\"SELECT 1 AS one, 2 AS two, 3 AS three\")\n        assert rs[0].asdict() == {\"one\": 1, \"two\": 2, \"three\": 3}", "\n\n@pytest.mark.asyncio\nasync def test_commit(transaction_client):\n    await transaction_client.batch(\n        [\n            \"DROP TABLE IF EXISTS t\",\n            \"CREATE TABLE t (a)\",\n        ]\n    )", "        ]\n    )\n\n    with transaction_client.transaction() as t:\n        await t.execute(\"INSERT INTO t VALUES ('one')\")\n        assert not t.closed\n        await t.commit()\n        await _assert_closed(t)\n\n    rs = await transaction_client.execute(\"SELECT COUNT(*) FROM t\")", "\n    rs = await transaction_client.execute(\"SELECT COUNT(*) FROM t\")\n    assert rs[0][0] == 1\n\n\n@pytest.mark.asyncio\nasync def test_rollback(transaction_client):\n    await transaction_client.batch(\n        [\n            \"DROP TABLE IF EXISTS t\",", "        [\n            \"DROP TABLE IF EXISTS t\",\n            \"CREATE TABLE t (a)\",\n        ]\n    )\n\n    with transaction_client.transaction() as t:\n        await t.execute(\"INSERT INTO t VALUES ('one')\")\n        assert not t.closed\n        await t.rollback()\n        await _assert_closed(t)", "\n    rs = await transaction_client.execute(\"SELECT COUNT(*) FROM t\")\n    assert rs[0][0] == 0\n\n\n@pytest.mark.asyncio\nasync def test_close(transaction_client):\n    await transaction_client.batch(\n        [\n            \"DROP TABLE IF EXISTS t\",", "        [\n            \"DROP TABLE IF EXISTS t\",\n            \"CREATE TABLE t (a)\",\n        ]\n    )\n\n    t = transaction_client.transaction()\n    await t.execute(\"INSERT INTO t VALUES ('one')\")\n    assert not t.closed\n    t.close()", "    assert not t.closed\n    t.close()\n    await _assert_closed(t)\n\n    rs = await transaction_client.execute(\"SELECT COUNT(*) FROM t\")\n    assert rs[0][0] == 0\n\n\n@pytest.mark.asyncio\nasync def test_context_manager(transaction_client):\n    with transaction_client.transaction() as t:\n        assert not t.closed", "@pytest.mark.asyncio\nasync def test_context_manager(transaction_client):\n    with transaction_client.transaction() as t:\n        assert not t.closed\n    assert t.closed\n\n\n@pytest.mark.asyncio\nasync def test_close_twice(transaction_client):\n    t = transaction_client.transaction()", "async def test_close_twice(transaction_client):\n    t = transaction_client.transaction()\n    t.close()\n    t.close()\n    assert t.closed\n\n\n@pytest.mark.asyncio\nasync def test_error_does_not_rollback(transaction_client):\n    await transaction_client.batch(", "async def test_error_does_not_rollback(transaction_client):\n    await transaction_client.batch(\n        [\n            \"DROP TABLE IF EXISTS t\",\n            \"CREATE TABLE t (a)\",\n        ]\n    )\n\n    with transaction_client.transaction() as t:\n        await t.execute(\"INSERT INTO t VALUES ('one')\")\n        with pytest.raises(libsql_client.LibsqlError):\n            await t.execute(\"SELECT foobar\")\n        await t.execute(\"INSERT INTO t VALUES ('two')\")\n        await t.commit()", "    with transaction_client.transaction() as t:\n        await t.execute(\"INSERT INTO t VALUES ('one')\")\n        with pytest.raises(libsql_client.LibsqlError):\n            await t.execute(\"SELECT foobar\")\n        await t.execute(\"INSERT INTO t VALUES ('two')\")\n        await t.commit()\n\n    rs = await transaction_client.execute(\"SELECT COUNT(*) FROM t\")\n    assert rs[0][0] == 2\n", "    assert rs[0][0] == 2\n\n\n@pytest.mark.asyncio\nasync def test_transaction_not_supported(http_url):\n    async with libsql_client.create_client(http_url) as c:\n        with pytest.raises(libsql_client.LibsqlError) as excinfo:\n            c.transaction()\n        assert excinfo.value.code == \"TRANSACTIONS_NOT_SUPPORTED\"\n", "        assert excinfo.value.code == \"TRANSACTIONS_NOT_SUPPORTED\"\n"]}
{"filename": "tests/test_values.py", "chunked_list": ["from datetime import datetime\nimport math\n\nimport pytest\n\n\nasync def _roundtrip(client, arg):\n    rs = await client.execute(\"SELECT ?\", [arg])\n    return rs[0][0]\n", "    return rs[0][0]\n\n\n@pytest.mark.asyncio\nasync def test_string(client):\n    assert await _roundtrip(client, \"boomerang\") == \"boomerang\"\n\n\n@pytest.mark.asyncio\nasync def test_string_with_weird_characters(client):", "@pytest.mark.asyncio\nasync def test_string_with_weird_characters(client):\n    assert await _roundtrip(client, \"a\\n\\r\\t \") == \"a\\n\\r\\t \"\n\n\n@pytest.mark.asyncio\nasync def test_string_with_unicode(client):\n    s = \"\u017elu\u0165ou\u010dk\u00fd k\u016f\u0148 \u00fap\u011bl \u010f\u00e1belsk\u00e9 \u00f3dy\"\n    assert await _roundtrip(client, s) == s\n", "    assert await _roundtrip(client, s) == s\n\n\n@pytest.mark.asyncio\nasync def test_int_zero(client):\n    x = await _roundtrip(client, 0)\n    assert isinstance(x, int) and x == 0\n\n\n@pytest.mark.asyncio", "\n@pytest.mark.asyncio\nasync def test_float_zero(client):\n    x = await _roundtrip(client, 0.0)\n    assert isinstance(x, float) and x == 0\n\n\n@pytest.mark.asyncio\nasync def test_integer(client):\n    x = await _roundtrip(client, -2023)", "async def test_integer(client):\n    x = await _roundtrip(client, -2023)\n    assert isinstance(x, int) and x == -2023\n\n\n@pytest.mark.asyncio\nasync def test_big_integer(client):\n    with pytest.raises(OverflowError):\n        await _roundtrip(client, 2**100 + 42)\n", "\n\n@pytest.mark.asyncio\nasync def test_float(client):\n    assert await _roundtrip(client, 12.345) == 12.345\n\n\n@pytest.mark.asyncio\nasync def test_not_finite(client):\n    for x in [math.inf, -math.inf, math.nan]:\n        with pytest.raises(ValueError):\n            await _roundtrip(client, x)", "async def test_not_finite(client):\n    for x in [math.inf, -math.inf, math.nan]:\n        with pytest.raises(ValueError):\n            await _roundtrip(client, x)\n\n\n@pytest.mark.asyncio\nasync def test_bytes(client):\n    for l in [0, 1, 2, 3, 4, 100, 113, 256]:\n        b = bytes(range(l))\n        assert await _roundtrip(client, b) == b", "    for l in [0, 1, 2, 3, 4, 100, 113, 256]:\n        b = bytes(range(l))\n        assert await _roundtrip(client, b) == b\n\n\n@pytest.mark.asyncio\nasync def test_bytearray(client):\n    assert await _roundtrip(client, bytearray(b\"foobar\")) == b\"foobar\"\n\n", "\n\n@pytest.mark.asyncio\nasync def test_none(client):\n    assert await _roundtrip(client, None) is None\n\n\n@pytest.mark.asyncio\nasync def test_bool(client):\n    assert await _roundtrip(client, True) == 1", "async def test_bool(client):\n    assert await _roundtrip(client, True) == 1\n    assert await _roundtrip(client, False) == 0\n\n\n@pytest.mark.asyncio\nasync def test_datetime(client):\n    d = datetime.fromisoformat(\"2023-04-01T12:34:56+02:00\")\n    ts = 1680345296000\n    assert await _roundtrip(client, d) == ts", "    ts = 1680345296000\n    assert await _roundtrip(client, d) == ts\n"]}
{"filename": "tests/conftest.py", "chunked_list": ["import os\n\nimport pytest\nimport pytest_asyncio\n\nimport libsql_client\n\n\n@pytest.fixture\ndef http_url():\n    return os.getenv(\"HTTP_URL\", \"http://localhost:8080\")", "@pytest.fixture\ndef http_url():\n    return os.getenv(\"HTTP_URL\", \"http://localhost:8080\")\n\n\n@pytest.fixture\ndef ws_url():\n    return os.getenv(\"WS_URL\", \"ws://localhost:8080\")\n\n", "\n\n@pytest.fixture\ndef file_url(tmp_path):\n    return f\"file://{tmp_path.absolute() / 'test.db'}\"\n\n\ndef _url(request):\n    if request.param == \"http\":\n        return request.getfixturevalue(\"http_url\")\n    elif request.param == \"ws\":\n        return request.getfixturevalue(\"ws_url\")\n    elif request.param == \"file\":\n        return request.getfixturevalue(\"file_url\")\n    else:\n        assert False, f\"Bad URL request.param: {request.param!r}\"", "\n\n@pytest.fixture(params=[\"http\", \"ws\", \"file\"])\ndef url(request):\n    return _url(request)\n\n\n@pytest.fixture(params=[\"ws\", \"file\"])\ndef transaction_url(request):\n    return _url(request)", "def transaction_url(request):\n    return _url(request)\n\n\n@pytest_asyncio.fixture\nasync def client(url):\n    async with libsql_client.create_client(url) as c:\n        yield c\n\n", "\n\n@pytest_asyncio.fixture\nasync def transaction_client(transaction_url):\n    async with libsql_client.create_client(transaction_url) as c:\n        yield c\n\n\n@pytest_asyncio.fixture\nasync def ws_client(ws_url):", "@pytest_asyncio.fixture\nasync def ws_client(ws_url):\n    async with libsql_client.create_client(ws_url) as c:\n        yield c\n"]}
{"filename": "tests/test_create_client.py", "chunked_list": ["import pytest\n\nimport libsql_client\n\n\n@pytest.mark.asyncio\nasync def test_closed(url):\n    client = libsql_client.create_client(url)\n    assert not client.closed\n    await client.close()", "    assert not client.closed\n    await client.close()\n    assert client.closed\n\n\n@pytest.mark.asyncio\nasync def test_context_manager(url):\n    async with libsql_client.create_client(url) as client:\n        assert not client.closed\n    assert client.closed", "        assert not client.closed\n    assert client.closed\n\n\n@pytest.mark.asyncio\nasync def test_close_twice(url):\n    client = libsql_client.create_client(url)\n    await client.close()\n    await client.close()\n    assert client.closed", "    await client.close()\n    assert client.closed\n\n\ndef test_error_url_scheme_not_supported():\n    with pytest.raises(libsql_client.LibsqlError) as excinfo:\n        libsql_client.create_client(\"ftp://localhost\")\n    assert excinfo.value.code == \"URL_SCHEME_NOT_SUPPORTED\"\n    assert \"ftp\" in str(excinfo.value)\n", "\n\ndef test_error_url_param_not_supported():\n    with pytest.raises(libsql_client.LibsqlError) as excinfo:\n        libsql_client.create_client(\"ws://localhost?foo=bar\")\n    assert excinfo.value.code == \"URL_PARAM_NOT_SUPPORTED\"\n    assert \"foo\" in str(excinfo.value)\n\n\ndef test_error_url_scheme_incompatible_with_tls():\n    urls = [\n        \"ws://localhost?tls=1\",\n        \"wss://localhost?tls=0\",\n        \"http://localhost?tls=1\",\n        \"https://localhost?tls=0\",\n    ]\n    for url in urls:\n        with pytest.raises(libsql_client.LibsqlError) as excinfo:\n            libsql_client.create_client(url)\n        assert excinfo.value.code == \"URL_INVALID\"\n        assert \"tls\" in str(excinfo.value)", "\ndef test_error_url_scheme_incompatible_with_tls():\n    urls = [\n        \"ws://localhost?tls=1\",\n        \"wss://localhost?tls=0\",\n        \"http://localhost?tls=1\",\n        \"https://localhost?tls=0\",\n    ]\n    for url in urls:\n        with pytest.raises(libsql_client.LibsqlError) as excinfo:\n            libsql_client.create_client(url)\n        assert excinfo.value.code == \"URL_INVALID\"\n        assert \"tls\" in str(excinfo.value)", "\n\ndef test_error_invalid_value_of_tls():\n    with pytest.raises(libsql_client.LibsqlError) as excinfo:\n        libsql_client.create_client(\"libsql://localhost?tls=foo\")\n    assert excinfo.value.code == \"URL_INVALID\"\n    assert \"foo\" in str(excinfo.value)\n\n\ndef test_missing_port_in_libsql_url_without_tls():\n    with pytest.raises(libsql_client.LibsqlError) as excinfo:\n        libsql_client.create_client(\"libsql://localhost?tls=0\")\n    assert excinfo.value.code == \"URL_INVALID\"\n    assert \"port\" in str(excinfo.value)", "\ndef test_missing_port_in_libsql_url_without_tls():\n    with pytest.raises(libsql_client.LibsqlError) as excinfo:\n        libsql_client.create_client(\"libsql://localhost?tls=0\")\n    assert excinfo.value.code == \"URL_INVALID\"\n    assert \"port\" in str(excinfo.value)\n"]}
{"filename": "tests/dbapi2/test_factory.py", "chunked_list": ["# pysqlite2/test/factory.py: tests for the various factories in pysqlite\n#\n# Copyright (C) 2005-2007 Gerhard H\u00e4ring <gh@ghaering.de>\n#\n# This file is part of pysqlite.\n#\n# This software is provided 'as-is', without any express or implied\n# warranty.  In no event will the authors be held liable for any damages\n# arising from the use of this software.\n#", "# arising from the use of this software.\n#\n# Permission is granted to anyone to use this software for any purpose,\n# including commercial applications, and to alter it and redistribute it\n# freely, subject to the following restrictions:\n#\n# 1. The origin of this software must not be misrepresented; you must not\n#    claim that you wrote the original software. If you use this software\n#    in a product, an acknowledgment in the product documentation would be\n#    appreciated but is not required.", "#    in a product, an acknowledgment in the product documentation would be\n#    appreciated but is not required.\n# 2. Altered source versions must be plainly marked as such, and must not be\n#    misrepresented as being the original software.\n# 3. This notice may not be removed or altered from any source distribution.\n\nimport unittest\nfrom . import libsql_client_helpers as sqlite\nfrom collections.abc import Sequence\n", "from collections.abc import Sequence\n\n\ndef dict_factory(cursor, row):\n    d = {}\n    for idx, col in enumerate(cursor.description):\n        d[col[0]] = row[idx]\n    return d\n\nclass MyCursor(sqlite.Cursor):\n    def __init__(self, *args, **kwargs):\n        sqlite.Cursor.__init__(self, *args, **kwargs)\n        self.row_factory = dict_factory", "\nclass MyCursor(sqlite.Cursor):\n    def __init__(self, *args, **kwargs):\n        sqlite.Cursor.__init__(self, *args, **kwargs)\n        self.row_factory = dict_factory\n\nclass ConnectionFactoryTests(unittest.TestCase):\n    def test_connection_factories(self):\n        class DefectFactory(sqlite.Connection):\n            def __init__(self, *args, **kwargs):\n                return None\n        class OkFactory(sqlite.Connection):\n            def __init__(self, *args, **kwargs):\n                sqlite.Connection.__init__(self, *args, **kwargs)\n\n        for factory in DefectFactory, OkFactory:\n            with self.subTest(factory=factory):\n                con = sqlite.connect(\":memory:\", factory=factory)\n                self.assertIsInstance(con, factory)\n\n    def test_connection_factory_relayed_call(self):\n        # gh-95132: keyword args must not be passed as positional args\n        class Factory(sqlite.Connection):\n            def __init__(self, *args, **kwargs):\n                kwargs[\"isolation_level\"] = None\n                super(Factory, self).__init__(*args, **kwargs)\n\n        con = sqlite.connect(\":memory:\", factory=Factory)\n        self.assertIsNone(con.isolation_level)\n        self.assertIsInstance(con, Factory)\n\n    def test_connection_factory_as_positional_arg(self):\n        class Factory(sqlite.Connection):\n            def __init__(self, *args, **kwargs):\n                super(Factory, self).__init__(*args, **kwargs)\n\n        con = sqlite.connect(\":memory:\", 5.0, 0, None, True, Factory)\n        self.assertIsNone(con.isolation_level)\n        self.assertIsInstance(con, Factory)", "\n\nclass CursorFactoryTests(unittest.TestCase):\n    def setUp(self):\n        self.con = sqlite.connect(\":memory:\")\n\n    def tearDown(self):\n        self.con.close()\n\n    def test_is_instance(self):\n        cur = self.con.cursor()\n        self.assertIsInstance(cur, sqlite.Cursor)\n        cur = self.con.cursor(MyCursor)\n        self.assertIsInstance(cur, MyCursor)\n        cur = self.con.cursor(factory=lambda con: MyCursor(con))\n        self.assertIsInstance(cur, MyCursor)\n\n    def test_invalid_factory(self):\n        # not a callable at all\n        self.assertRaises(TypeError, self.con.cursor, None)\n        # invalid callable with not exact one argument\n        self.assertRaises(TypeError, self.con.cursor, lambda: None)\n        # invalid callable returning non-cursor\n        self.assertRaises(TypeError, self.con.cursor, lambda con: None)", "\nclass RowFactoryTestsBackwardsCompat(unittest.TestCase):\n    def setUp(self):\n        self.con = sqlite.connect(\":memory:\")\n\n    def test_is_produced_by_factory(self):\n        cur = self.con.cursor(factory=MyCursor)\n        cur.execute(\"select 4+5 as foo\")\n        row = cur.fetchone()\n        self.assertIsInstance(row, dict)\n        cur.close()\n\n    def tearDown(self):\n        self.con.close()", "\nclass RowFactoryTests(unittest.TestCase):\n    def setUp(self):\n        self.con = sqlite.connect(\":memory:\")\n\n    def test_custom_factory(self):\n        self.con.row_factory = lambda cur, row: list(row)\n        row = self.con.execute(\"select 1, 2\").fetchone()\n        self.assertIsInstance(row, list)\n\n    def test_sqlite_row_index(self):\n        self.con.row_factory = sqlite.Row\n        row = self.con.execute(\"select 1 as a_1, 2 as b\").fetchone()\n        self.assertIsInstance(row, sqlite.Row)\n\n        self.assertEqual(row[\"a_1\"], 1, \"by name: wrong result for column 'a_1'\")\n        self.assertEqual(row[\"b\"], 2, \"by name: wrong result for column 'b'\")\n\n        self.assertEqual(row[\"A_1\"], 1, \"by name: wrong result for column 'A_1'\")\n        self.assertEqual(row[\"B\"], 2, \"by name: wrong result for column 'B'\")\n\n        self.assertEqual(row[0], 1, \"by index: wrong result for column 0\")\n        self.assertEqual(row[1], 2, \"by index: wrong result for column 1\")\n        self.assertEqual(row[-1], 2, \"by index: wrong result for column -1\")\n        self.assertEqual(row[-2], 1, \"by index: wrong result for column -2\")\n\n        with self.assertRaises(IndexError):\n            row['c']\n        with self.assertRaises(IndexError):\n            row['a_\\x11']\n        with self.assertRaises(IndexError):\n            row['a\\x7f1']\n        with self.assertRaises(IndexError):\n            row[2]\n        with self.assertRaises(IndexError):\n            row[-3]\n        with self.assertRaises(IndexError):\n            row[2**1000]\n        with self.assertRaises(IndexError):\n            row[complex()]  # index must be int or string\n\n    def test_sqlite_row_index_unicode(self):\n        self.con.row_factory = sqlite.Row\n        row = self.con.execute(\"select 1 as \\xff\").fetchone()\n        self.assertEqual(row[\"\\xff\"], 1)\n        with self.assertRaises(IndexError):\n            row['\\u0178']\n        with self.assertRaises(IndexError):\n            row['\\xdf']\n\n    def test_sqlite_row_slice(self):\n        # A sqlite.Row can be sliced like a list.\n        self.con.row_factory = sqlite.Row\n        row = self.con.execute(\"select 1, 2, 3, 4\").fetchone()\n        self.assertEqual(row[0:0], ())\n        self.assertEqual(row[0:1], (1,))\n        self.assertEqual(row[1:3], (2, 3))\n        self.assertEqual(row[3:1], ())\n        # Explicit bounds are optional.\n        self.assertEqual(row[1:], (2, 3, 4))\n        self.assertEqual(row[:3], (1, 2, 3))\n        # Slices can use negative indices.\n        self.assertEqual(row[-2:-1], (3,))\n        self.assertEqual(row[-2:], (3, 4))\n        # Slicing supports steps.\n        self.assertEqual(row[0:4:2], (1, 3))\n        self.assertEqual(row[3:0:-2], (4, 2))\n\n    def test_sqlite_row_iter(self):\n        \"\"\"Checks if the row object is iterable\"\"\"\n        self.con.row_factory = sqlite.Row\n        row = self.con.execute(\"select 1 as a, 2 as b\").fetchone()\n\n        # Is iterable in correct order and produces valid results:\n        items = [col for col in row]\n        self.assertEqual(items, [1, 2])\n\n        # Is iterable the second time:\n        items = [col for col in row]\n        self.assertEqual(items, [1, 2])\n\n    def test_sqlite_row_as_tuple(self):\n        \"\"\"Checks if the row object can be converted to a tuple\"\"\"\n        self.con.row_factory = sqlite.Row\n        row = self.con.execute(\"select 1 as a, 2 as b\").fetchone()\n        t = tuple(row)\n        self.assertEqual(t, (row['a'], row['b']))\n\n    def test_sqlite_row_as_dict(self):\n        \"\"\"Checks if the row object can be correctly converted to a dictionary\"\"\"\n        self.con.row_factory = sqlite.Row\n        row = self.con.execute(\"select 1 as a, 2 as b\").fetchone()\n        d = dict(row)\n        self.assertEqual(d[\"a\"], row[\"a\"])\n        self.assertEqual(d[\"b\"], row[\"b\"])\n\n    def test_sqlite_row_hash_cmp(self):\n        \"\"\"Checks if the row object compares and hashes correctly\"\"\"\n        self.con.row_factory = sqlite.Row\n        row_1 = self.con.execute(\"select 1 as a, 2 as b\").fetchone()\n        row_2 = self.con.execute(\"select 1 as a, 2 as b\").fetchone()\n        row_3 = self.con.execute(\"select 1 as a, 3 as b\").fetchone()\n        row_4 = self.con.execute(\"select 1 as b, 2 as a\").fetchone()\n        row_5 = self.con.execute(\"select 2 as b, 1 as a\").fetchone()\n\n        self.assertTrue(row_1 == row_1)\n        self.assertTrue(row_1 == row_2)\n        self.assertFalse(row_1 == row_3)\n        self.assertFalse(row_1 == row_4)\n        self.assertFalse(row_1 == row_5)\n        self.assertFalse(row_1 == object())\n\n        self.assertFalse(row_1 != row_1)\n        self.assertFalse(row_1 != row_2)\n        self.assertTrue(row_1 != row_3)\n        self.assertTrue(row_1 != row_4)\n        self.assertTrue(row_1 != row_5)\n        self.assertTrue(row_1 != object())\n\n        with self.assertRaises(TypeError):\n            row_1 > row_2\n        with self.assertRaises(TypeError):\n            row_1 < row_2\n        with self.assertRaises(TypeError):\n            row_1 >= row_2\n        with self.assertRaises(TypeError):\n            row_1 <= row_2\n\n        self.assertEqual(hash(row_1), hash(row_2))\n\n    def test_sqlite_row_as_sequence(self):\n        \"\"\" Checks if the row object can act like a sequence \"\"\"\n        self.con.row_factory = sqlite.Row\n        row = self.con.execute(\"select 1 as a, 2 as b\").fetchone()\n\n        as_tuple = tuple(row)\n        self.assertEqual(list(reversed(row)), list(reversed(as_tuple)))\n        self.assertIsInstance(row, Sequence)\n\n    def test_fake_cursor_class(self):\n        # Issue #24257: Incorrect use of PyObject_IsInstance() caused\n        # segmentation fault.\n        # Issue #27861: Also applies for cursor factory.\n        class FakeCursor(str):\n            __class__ = sqlite.Cursor\n        self.con.row_factory = sqlite.Row\n        self.assertRaises(TypeError, self.con.cursor, FakeCursor)\n        self.assertRaises(TypeError, sqlite.Row, FakeCursor(), ())\n\n    def tearDown(self):\n        self.con.close()", "\nclass TextFactoryTests(unittest.TestCase):\n    def setUp(self):\n        self.con = sqlite.connect(\":memory:\")\n\n    def test_unicode(self):\n        austria = \"\u00d6sterreich\"\n        row = self.con.execute(\"select ?\", (austria,)).fetchone()\n        self.assertEqual(type(row[0]), str, \"type of row[0] must be unicode\")\n\n    def test_string(self):\n        self.con.text_factory = bytes\n        austria = \"\u00d6sterreich\"\n        row = self.con.execute(\"select ?\", (austria,)).fetchone()\n        self.assertEqual(type(row[0]), bytes, \"type of row[0] must be bytes\")\n        self.assertEqual(row[0], austria.encode(\"utf-8\"), \"column must equal original data in UTF-8\")\n\n    def test_custom(self):\n        self.con.text_factory = lambda x: str(x, \"utf-8\", \"ignore\")\n        austria = \"\u00d6sterreich\"\n        row = self.con.execute(\"select ?\", (austria,)).fetchone()\n        self.assertEqual(type(row[0]), str, \"type of row[0] must be unicode\")\n        self.assertTrue(row[0].endswith(\"reich\"), \"column must contain original data\")\n\n    @unittest.skip(\"not supported by libsql_client\")\n    def test_optimized_unicode(self):\n        # OptimizedUnicode is deprecated as of Python 3.10\n        with self.assertWarns(DeprecationWarning) as cm:\n            self.con.text_factory = sqlite.OptimizedUnicode\n        self.assertIn(\"factory.py\", cm.filename)\n        austria = \"\u00d6sterreich\"\n        germany = \"Deutchland\"\n        a_row = self.con.execute(\"select ?\", (austria,)).fetchone()\n        d_row = self.con.execute(\"select ?\", (germany,)).fetchone()\n        self.assertEqual(type(a_row[0]), str, \"type of non-ASCII row must be str\")\n        self.assertEqual(type(d_row[0]), str, \"type of ASCII-only row must be str\")\n\n    def tearDown(self):\n        self.con.close()", "\nclass TextFactoryTestsWithEmbeddedZeroBytes(unittest.TestCase):\n    def setUp(self):\n        self.con = sqlite.connect(\":memory:\")\n        self.con.execute(\"create table test (value text)\")\n        self.con.execute(\"insert into test (value) values (?)\", (\"a\\x00b\",))\n\n    def test_string(self):\n        # text_factory defaults to str\n        row = self.con.execute(\"select value from test\").fetchone()\n        self.assertIs(type(row[0]), str)\n        self.assertEqual(row[0], \"a\\x00b\")\n\n    def test_bytes(self):\n        self.con.text_factory = bytes\n        row = self.con.execute(\"select value from test\").fetchone()\n        self.assertIs(type(row[0]), bytes)\n        self.assertEqual(row[0], b\"a\\x00b\")\n\n    def test_bytearray(self):\n        self.con.text_factory = bytearray\n        row = self.con.execute(\"select value from test\").fetchone()\n        self.assertIs(type(row[0]), bytearray)\n        self.assertEqual(row[0], b\"a\\x00b\")\n\n    def test_custom(self):\n        # A custom factory should receive a bytes argument\n        self.con.text_factory = lambda x: x\n        row = self.con.execute(\"select value from test\").fetchone()\n        self.assertIs(type(row[0]), bytes)\n        self.assertEqual(row[0], b\"a\\x00b\")\n\n    def tearDown(self):\n        self.con.close()", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/dbapi2/test_regression.py", "chunked_list": ["# pysqlite2/test/regression.py: pysqlite regression tests\n#\n# Copyright (C) 2006-2010 Gerhard H\u00e4ring <gh@ghaering.de>\n#\n# This file is part of pysqlite.\n#\n# This software is provided 'as-is', without any express or implied\n# warranty.  In no event will the authors be held liable for any damages\n# arising from the use of this software.\n#", "# arising from the use of this software.\n#\n# Permission is granted to anyone to use this software for any purpose,\n# including commercial applications, and to alter it and redistribute it\n# freely, subject to the following restrictions:\n#\n# 1. The origin of this software must not be misrepresented; you must not\n#    claim that you wrote the original software. If you use this software\n#    in a product, an acknowledgment in the product documentation would be\n#    appreciated but is not required.", "#    in a product, an acknowledgment in the product documentation would be\n#    appreciated but is not required.\n# 2. Altered source versions must be plainly marked as such, and must not be\n#    misrepresented as being the original software.\n# 3. This notice may not be removed or altered from any source distribution.\n\nimport datetime\nimport unittest\nfrom . import libsql_client_helpers as sqlite\nimport weakref", "from . import libsql_client_helpers as sqlite\nimport weakref\nimport functools\n\nfrom test import support\nfrom unittest.mock import patch\nfrom .test_dbapi import memory_database, cx_limit\n\n\nclass RegressionTests(unittest.TestCase):\n    def setUp(self):\n        self.con = sqlite.connect(\":memory:\")\n\n    def tearDown(self):\n        self.con.close()\n\n    def test_pragma_user_version(self):\n        # This used to crash pysqlite because this pragma command returns NULL for the column name\n        cur = self.con.cursor()\n        cur.execute(\"pragma user_version\")\n\n    def test_pragma_schema_version(self):\n        # This still crashed pysqlite <= 2.2.1\n        con = sqlite.connect(\":memory:\", detect_types=sqlite.PARSE_COLNAMES)\n        try:\n            cur = self.con.cursor()\n            cur.execute(\"pragma schema_version\")\n        finally:\n            cur.close()\n            con.close()\n\n    def test_statement_reset(self):\n        # pysqlite 2.1.0 to 2.2.0 have the problem that not all statements are\n        # reset before a rollback, but only those that are still in the\n        # statement cache. The others are not accessible from the connection object.\n        con = sqlite.connect(\":memory:\", cached_statements=5)\n        cursors = [con.cursor() for x in range(5)]\n        cursors[0].execute(\"create table test(x)\")\n        for i in range(10):\n            cursors[0].executemany(\"insert into test(x) values (?)\", [(x,) for x in range(10)])\n\n        for i in range(5):\n            cursors[i].execute(\" \" * i + \"select x from test\")\n\n        con.rollback()\n\n    def test_column_name_with_spaces(self):\n        cur = self.con.cursor()\n        cur.execute('select 1 as \"foo bar [datetime]\"')\n        self.assertEqual(cur.description[0][0], \"foo bar [datetime]\")\n\n        cur.execute('select 1 as \"foo baz\"')\n        self.assertEqual(cur.description[0][0], \"foo baz\")\n\n    def test_statement_finalization_on_close_db(self):\n        # pysqlite versions <= 2.3.3 only finalized statements in the statement\n        # cache when closing the database. statements that were still\n        # referenced in cursors weren't closed and could provoke \"\n        # \"OperationalError: Unable to close due to unfinalised statements\".\n        con = sqlite.connect(\":memory:\")\n        cursors = []\n        # default statement cache size is 100\n        for i in range(105):\n            cur = con.cursor()\n            cursors.append(cur)\n            cur.execute(\"select 1 x union select \" + str(i))\n        con.close()\n\n    @unittest.skip(\"libsql_client depends on server sending autocommit mode\")\n    def test_on_conflict_rollback(self):\n        con = sqlite.connect(\":memory:\")\n        con.execute(\"create table foo(x, unique(x) on conflict rollback)\")\n        con.execute(\"insert into foo(x) values (1)\")\n        try:\n            con.execute(\"insert into foo(x) values (1)\")\n        except sqlite.DatabaseError:\n            pass\n        con.execute(\"insert into foo(x) values (2)\")\n        try:\n            con.commit()\n        except sqlite.OperationalError:\n            self.fail(\"pysqlite knew nothing about the implicit ROLLBACK\")\n\n    def test_workaround_for_buggy_sqlite_transfer_bindings(self):\n        \"\"\"\n        pysqlite would crash with older SQLite versions unless\n        a workaround is implemented.\n        \"\"\"\n        self.con.execute(\"create table foo(bar)\")\n        self.con.execute(\"drop table foo\")\n        self.con.execute(\"create table foo(bar)\")\n\n    def test_empty_statement(self):\n        \"\"\"\n        pysqlite used to segfault with SQLite versions 3.5.x. These return NULL\n        for \"no-operation\" statements\n        \"\"\"\n        self.con.execute(\"\")\n\n    @unittest.skip(\"does not make sense with libsql_client-py\")\n    def test_type_map_usage(self):\n        \"\"\"\n        pysqlite until 2.4.1 did not rebuild the row_cast_map when recompiling\n        a statement. This test exhibits the problem.\n        \"\"\"\n        SELECT = \"select * from foo\"\n        con = sqlite.connect(\":memory:\",detect_types=sqlite.PARSE_DECLTYPES)\n        cur = con.cursor()\n        cur.execute(\"create table foo(bar timestamp)\")\n        cur.execute(\"insert into foo(bar) values (?)\", (datetime.datetime.now(),))\n        cur.execute(SELECT)\n        cur.execute(\"drop table foo\")\n        cur.execute(\"create table foo(bar integer)\")\n        cur.execute(\"insert into foo(bar) values (5)\")\n        cur.execute(SELECT)\n\n    def test_bind_mutating_list(self):\n        # Issue41662: Crash when mutate a list of parameters during iteration.\n        class X:\n            def __conform__(self, protocol):\n                parameters.clear()\n                return \"...\"\n        parameters = [X(), 0]\n        con = sqlite.connect(\":memory:\",detect_types=sqlite.PARSE_DECLTYPES)\n        con.execute(\"create table foo(bar X, baz integer)\")\n        # Should not crash\n        with self.assertRaises(IndexError):\n            con.execute(\"insert into foo(bar, baz) values (?, ?)\", parameters)\n\n    @unittest.skip(\"causes sqld to close the WebSocket connection\")\n    def test_error_msg_decode_error(self):\n        # When porting the module to Python 3.0, the error message about\n        # decoding errors disappeared. This verifies they're back again.\n        with self.assertRaises(sqlite.OperationalError) as cm:\n            self.con.execute(\"select 'xxx' || ? || 'yyy' colname\",\n                             (bytes(bytearray([250])),)).fetchone()\n        msg = \"Could not decode to UTF-8 column 'colname' with text 'xxx\"\n        self.assertIn(msg, str(cm.exception))\n\n    def test_register_adapter(self):\n        \"\"\"\n        See issue 3312.\n        \"\"\"\n        self.assertRaises(TypeError, sqlite.register_adapter, {}, None)\n\n    def test_set_isolation_level(self):\n        # See issue 27881.\n        class CustomStr(str):\n            def upper(self):\n                return None\n            def __del__(self):\n                con.isolation_level = \"\"\n\n        con = sqlite.connect(\":memory:\")\n        con.isolation_level = None\n        for level in \"\", \"DEFERRED\", \"IMMEDIATE\", \"EXCLUSIVE\":\n            with self.subTest(level=level):\n                con.isolation_level = level\n                con.isolation_level = level.lower()\n                con.isolation_level = level.capitalize()\n                con.isolation_level = CustomStr(level)\n\n        # setting isolation_level failure should not alter previous state\n        con.isolation_level = None\n        con.isolation_level = \"DEFERRED\"\n        pairs = [\n            (1, TypeError), (b'', TypeError), (\"abc\", ValueError),\n            (\"IMMEDIATE\\0EXCLUSIVE\", ValueError), (\"\\xe9\", ValueError),\n        ]\n        for value, exc in pairs:\n            with self.subTest(level=value):\n                with self.assertRaises(exc):\n                    con.isolation_level = value\n                self.assertEqual(con.isolation_level, \"DEFERRED\")\n\n    def test_cursor_constructor_call_check(self):\n        \"\"\"\n        Verifies that cursor methods check whether base class __init__ was\n        called.\n        \"\"\"\n        class Cursor(sqlite.Cursor):\n            def __init__(self, con):\n                pass\n\n        con = sqlite.connect(\":memory:\")\n        cur = Cursor(con)\n        with self.assertRaises(sqlite.ProgrammingError):\n            cur.execute(\"select 4+5\").fetchall()\n        with self.assertRaisesRegex(sqlite.ProgrammingError,\n                                    r'^Base Cursor\\.__init__ not called\\.$'):\n            cur.close()\n\n    def test_str_subclass(self):\n        \"\"\"\n        The Python 3.0 port of the module didn't cope with values of subclasses of str.\n        \"\"\"\n        class MyStr(str): pass\n        self.con.execute(\"select ?\", (MyStr(\"abc\"),))\n\n    def test_connection_constructor_call_check(self):\n        \"\"\"\n        Verifies that connection methods check whether base class __init__ was\n        called.\n        \"\"\"\n        class Connection(sqlite.Connection):\n            def __init__(self, name):\n                pass\n\n        con = Connection(\":memory:\")\n        with self.assertRaises(sqlite.ProgrammingError):\n            cur = con.cursor()\n\n    def test_auto_commit(self):\n        \"\"\"\n        Verifies that creating a connection in autocommit mode works.\n        2.5.3 introduced a regression so that these could no longer\n        be created.\n        \"\"\"\n        con = sqlite.connect(\":memory:\", isolation_level=None)\n\n    def test_pragma_autocommit(self):\n        \"\"\"\n        Verifies that running a PRAGMA statement that does an autocommit does\n        work. This did not work in 2.5.3/2.5.4.\n        \"\"\"\n        cur = self.con.cursor()\n        cur.execute(\"create table foo(bar)\")\n        cur.execute(\"insert into foo(bar) values (5)\")\n\n        cur.execute(\"pragma page_size\")\n        row = cur.fetchone()\n\n    def test_connection_call(self):\n        \"\"\"\n        Call a connection with a non-string SQL request: check error handling\n        of the statement constructor.\n        \"\"\"\n        self.assertRaises(TypeError, self.con, b\"select 1\")\n\n    @unittest.skip(\"Not supported\")\n    def test_collation(self):\n        def collation_cb(a, b):\n            return 1\n        self.assertRaises(UnicodeEncodeError, self.con.create_collation,\n            # Lone surrogate cannot be encoded to the default encoding (utf8)\n            \"\\uDC80\", collation_cb)\n\n    @unittest.skip(\"does not make sense for libsql_client\")\n    def test_recursive_cursor_use(self):\n        \"\"\"\n        http://bugs.python.org/issue10811\n\n        Recursively using a cursor, such as when reusing it from a generator led to segfaults.\n        Now we catch recursive cursor usage and raise a ProgrammingError.\n        \"\"\"\n        con = sqlite.connect(\":memory:\")\n\n        cur = con.cursor()\n        cur.execute(\"create table a (bar)\")\n        cur.execute(\"create table b (baz)\")\n\n        def foo():\n            cur.execute(\"insert into a (bar) values (?)\", (1,))\n            yield 1\n\n        with self.assertRaises(sqlite.ProgrammingError):\n            cur.executemany(\"insert into b (baz) values (?)\",\n                            ((i,) for i in foo()))\n\n    def test_convert_timestamp_microsecond_padding(self):\n        \"\"\"\n        http://bugs.python.org/issue14720\n\n        The microsecond parsing of convert_timestamp() should pad with zeros,\n        since the microsecond string \"456\" actually represents \"456000\".\n        \"\"\"\n\n        con = sqlite.connect(\":memory:\", detect_types=sqlite.PARSE_DECLTYPES)\n        cur = con.cursor()\n        cur.execute(\"CREATE TABLE t (x TIMESTAMP)\")\n\n        # Microseconds should be 456000\n        cur.execute(\"INSERT INTO t (x) VALUES ('2012-04-04 15:06:00.456')\")\n\n        # Microseconds should be truncated to 123456\n        cur.execute(\"INSERT INTO t (x) VALUES ('2012-04-04 15:06:00.123456789')\")\n\n        cur.execute(\"SELECT * FROM t\")\n        values = [x[0] for x in cur.fetchall()]\n\n        self.assertEqual(values, [\n            datetime.datetime(2012, 4, 4, 15, 6, 0, 456000),\n            datetime.datetime(2012, 4, 4, 15, 6, 0, 123456),\n        ])\n\n    def test_invalid_isolation_level_type(self):\n        # isolation level is a string, not an integer\n        self.assertRaises(TypeError,\n                          sqlite.connect, \":memory:\", isolation_level=123)\n\n\n    def test_null_character(self):\n        # Issue #21147\n        cur = self.con.cursor()\n        queries = [\"\\0select 1\", \"select 1\\0\"]\n        for query in queries:\n            with self.subTest(query=query):\n                self.assertRaisesRegex(sqlite.ProgrammingError, \"null char\",\n                                       self.con.execute, query)\n            with self.subTest(query=query):\n                self.assertRaisesRegex(sqlite.ProgrammingError, \"null char\",\n                                       cur.execute, query)\n\n    @unittest.skip(\"TODO: implement this check\")\n    def test_surrogates(self):\n        con = sqlite.connect(\":memory:\")\n        self.assertRaises(UnicodeEncodeError, con, \"select '\\ud8ff'\")\n        self.assertRaises(UnicodeEncodeError, con, \"select '\\udcff'\")\n        cur = con.cursor()\n        self.assertRaises(UnicodeEncodeError, cur.execute, \"select '\\ud8ff'\")\n        self.assertRaises(UnicodeEncodeError, cur.execute, \"select '\\udcff'\")\n\n    def test_large_sql(self):\n        msg = \"query string is too large\"\n        with memory_database() as cx, cx_limit(cx) as lim:\n            cu = cx.cursor()\n\n            cx(\"select 1\".ljust(lim))\n            # use a different SQL statement; don't reuse from the LRU cache\n            cu.execute(\"select 2\".ljust(lim))\n\n            sql = \"select 3\".ljust(lim+1)\n            self.assertRaisesRegex(sqlite.DataError, msg, cx, sql)\n            self.assertRaisesRegex(sqlite.DataError, msg, cu.execute, sql)\n\n    @unittest.skip(\"Not supported\")\n    def test_commit_cursor_reset(self):\n        \"\"\"\n        Connection.commit() did reset cursors, which made sqlite3\n        to return rows multiple times when fetched from cursors\n        after commit. See issues 10513 and 23129 for details.\n        \"\"\"\n        con = sqlite.connect(\":memory:\")\n        con.executescript(\"\"\"\n        create table t(c);\n        create table t2(c);\n        insert into t values(0);\n        insert into t values(1);\n        insert into t values(2);\n        \"\"\")\n\n        self.assertEqual(con.isolation_level, \"\")\n\n        counter = 0\n        for i, row in enumerate(con.execute(\"select c from t\")):\n            with self.subTest(i=i, row=row):\n                con.execute(\"insert into t2(c) values (?)\", (i,))\n                con.commit()\n                if counter == 0:\n                    self.assertEqual(row[0], 0)\n                elif counter == 1:\n                    self.assertEqual(row[0], 1)\n                elif counter == 2:\n                    self.assertEqual(row[0], 2)\n                counter += 1\n        self.assertEqual(counter, 3, \"should have returned exactly three rows\")\n\n    @unittest.skip(\"Not supported\")\n    def test_bpo31770(self):\n        \"\"\"\n        The interpreter shouldn't crash in case Cursor.__init__() is called\n        more than once.\n        \"\"\"\n        def callback(*args):\n            pass\n        con = sqlite.connect(\":memory:\")\n        cur = sqlite.Cursor(con)\n        ref = weakref.ref(cur, callback)\n        cur.__init__(con)\n        del cur\n        # The interpreter shouldn't crash when ref is collected.\n        del ref\n        support.gc_collect()\n\n    def test_del_isolation_level_segfault(self):\n        with self.assertRaises(AttributeError):\n            del self.con.isolation_level\n\n    @unittest.skip(\"Not supported\")\n    def test_bpo37347(self):\n        class Printer:\n            def log(self, *args):\n                return sqlite.SQLITE_OK\n\n        for method in [self.con.set_trace_callback,\n                       functools.partial(self.con.set_progress_handler, n=1),\n                       self.con.set_authorizer]:\n            printer_instance = Printer()\n            method(printer_instance.log)\n            method(printer_instance.log)\n            self.con.execute(\"select 1\")  # trigger seg fault\n            method(None)\n\n    def test_return_empty_bytestring(self):\n        cur = self.con.execute(\"select X''\")\n        val = cur.fetchone()[0]\n        self.assertEqual(val, b'')\n\n    def test_table_lock_cursor_replace_stmt(self):\n        with memory_database() as con:\n            cur = con.cursor()\n            cur.execute(\"create table t(t)\")\n            cur.executemany(\"insert into t values(?)\",\n                            ((v,) for v in range(5)))\n            con.commit()\n            cur.execute(\"select t from t\")\n            cur.execute(\"drop table t\")\n            con.commit()\n\n    def test_table_lock_cursor_dealloc(self):\n        with memory_database() as con:\n            con.execute(\"create table t(t)\")\n            con.executemany(\"insert into t values(?)\",\n                            ((v,) for v in range(5)))\n            con.commit()\n            cur = con.execute(\"select t from t\")\n            del cur\n            con.execute(\"drop table t\")\n            con.commit()\n\n    @unittest.skip(\"Not supported\")\n    def test_table_lock_cursor_non_readonly_select(self):\n        with memory_database() as con:\n            con.execute(\"create table t(t)\")\n            con.executemany(\"insert into t values(?)\",\n                            ((v,) for v in range(5)))\n            con.commit()\n            def dup(v):\n                con.execute(\"insert into t values(?)\", (v,))\n                return\n            con.create_function(\"dup\", 1, dup)\n            cur = con.execute(\"select dup(t) from t\")\n            del cur\n            con.execute(\"drop table t\")\n            con.commit()\n\n    @unittest.skip(\"Not supported\")\n    def test_executescript_step_through_select(self):\n        with memory_database() as con:\n            values = [(v,) for v in range(5)]\n            with con:\n                con.execute(\"create table t(t)\")\n                con.executemany(\"insert into t values(?)\", values)\n            steps = []\n            con.create_function(\"step\", 1, lambda x: steps.append((x,)))\n            con.executescript(\"select step(t) from t\")\n            self.assertEqual(steps, values)\n\n    def test_custom_cursor_object_crash_gh_99886(self):\n        # This test segfaults on GH-99886\n        class MyCursor(sqlite.Cursor):\n            def __init__(self, *args, **kwargs):\n                super().__init__(*args, **kwargs)\n                # this can go before or after the super call; doesn't matter\n                self.some_attr = None\n\n        with memory_database() as con:\n            cur = con.cursor(MyCursor)\n            cur.close()\n            del cur", "\nclass RegressionTests(unittest.TestCase):\n    def setUp(self):\n        self.con = sqlite.connect(\":memory:\")\n\n    def tearDown(self):\n        self.con.close()\n\n    def test_pragma_user_version(self):\n        # This used to crash pysqlite because this pragma command returns NULL for the column name\n        cur = self.con.cursor()\n        cur.execute(\"pragma user_version\")\n\n    def test_pragma_schema_version(self):\n        # This still crashed pysqlite <= 2.2.1\n        con = sqlite.connect(\":memory:\", detect_types=sqlite.PARSE_COLNAMES)\n        try:\n            cur = self.con.cursor()\n            cur.execute(\"pragma schema_version\")\n        finally:\n            cur.close()\n            con.close()\n\n    def test_statement_reset(self):\n        # pysqlite 2.1.0 to 2.2.0 have the problem that not all statements are\n        # reset before a rollback, but only those that are still in the\n        # statement cache. The others are not accessible from the connection object.\n        con = sqlite.connect(\":memory:\", cached_statements=5)\n        cursors = [con.cursor() for x in range(5)]\n        cursors[0].execute(\"create table test(x)\")\n        for i in range(10):\n            cursors[0].executemany(\"insert into test(x) values (?)\", [(x,) for x in range(10)])\n\n        for i in range(5):\n            cursors[i].execute(\" \" * i + \"select x from test\")\n\n        con.rollback()\n\n    def test_column_name_with_spaces(self):\n        cur = self.con.cursor()\n        cur.execute('select 1 as \"foo bar [datetime]\"')\n        self.assertEqual(cur.description[0][0], \"foo bar [datetime]\")\n\n        cur.execute('select 1 as \"foo baz\"')\n        self.assertEqual(cur.description[0][0], \"foo baz\")\n\n    def test_statement_finalization_on_close_db(self):\n        # pysqlite versions <= 2.3.3 only finalized statements in the statement\n        # cache when closing the database. statements that were still\n        # referenced in cursors weren't closed and could provoke \"\n        # \"OperationalError: Unable to close due to unfinalised statements\".\n        con = sqlite.connect(\":memory:\")\n        cursors = []\n        # default statement cache size is 100\n        for i in range(105):\n            cur = con.cursor()\n            cursors.append(cur)\n            cur.execute(\"select 1 x union select \" + str(i))\n        con.close()\n\n    @unittest.skip(\"libsql_client depends on server sending autocommit mode\")\n    def test_on_conflict_rollback(self):\n        con = sqlite.connect(\":memory:\")\n        con.execute(\"create table foo(x, unique(x) on conflict rollback)\")\n        con.execute(\"insert into foo(x) values (1)\")\n        try:\n            con.execute(\"insert into foo(x) values (1)\")\n        except sqlite.DatabaseError:\n            pass\n        con.execute(\"insert into foo(x) values (2)\")\n        try:\n            con.commit()\n        except sqlite.OperationalError:\n            self.fail(\"pysqlite knew nothing about the implicit ROLLBACK\")\n\n    def test_workaround_for_buggy_sqlite_transfer_bindings(self):\n        \"\"\"\n        pysqlite would crash with older SQLite versions unless\n        a workaround is implemented.\n        \"\"\"\n        self.con.execute(\"create table foo(bar)\")\n        self.con.execute(\"drop table foo\")\n        self.con.execute(\"create table foo(bar)\")\n\n    def test_empty_statement(self):\n        \"\"\"\n        pysqlite used to segfault with SQLite versions 3.5.x. These return NULL\n        for \"no-operation\" statements\n        \"\"\"\n        self.con.execute(\"\")\n\n    @unittest.skip(\"does not make sense with libsql_client-py\")\n    def test_type_map_usage(self):\n        \"\"\"\n        pysqlite until 2.4.1 did not rebuild the row_cast_map when recompiling\n        a statement. This test exhibits the problem.\n        \"\"\"\n        SELECT = \"select * from foo\"\n        con = sqlite.connect(\":memory:\",detect_types=sqlite.PARSE_DECLTYPES)\n        cur = con.cursor()\n        cur.execute(\"create table foo(bar timestamp)\")\n        cur.execute(\"insert into foo(bar) values (?)\", (datetime.datetime.now(),))\n        cur.execute(SELECT)\n        cur.execute(\"drop table foo\")\n        cur.execute(\"create table foo(bar integer)\")\n        cur.execute(\"insert into foo(bar) values (5)\")\n        cur.execute(SELECT)\n\n    def test_bind_mutating_list(self):\n        # Issue41662: Crash when mutate a list of parameters during iteration.\n        class X:\n            def __conform__(self, protocol):\n                parameters.clear()\n                return \"...\"\n        parameters = [X(), 0]\n        con = sqlite.connect(\":memory:\",detect_types=sqlite.PARSE_DECLTYPES)\n        con.execute(\"create table foo(bar X, baz integer)\")\n        # Should not crash\n        with self.assertRaises(IndexError):\n            con.execute(\"insert into foo(bar, baz) values (?, ?)\", parameters)\n\n    @unittest.skip(\"causes sqld to close the WebSocket connection\")\n    def test_error_msg_decode_error(self):\n        # When porting the module to Python 3.0, the error message about\n        # decoding errors disappeared. This verifies they're back again.\n        with self.assertRaises(sqlite.OperationalError) as cm:\n            self.con.execute(\"select 'xxx' || ? || 'yyy' colname\",\n                             (bytes(bytearray([250])),)).fetchone()\n        msg = \"Could not decode to UTF-8 column 'colname' with text 'xxx\"\n        self.assertIn(msg, str(cm.exception))\n\n    def test_register_adapter(self):\n        \"\"\"\n        See issue 3312.\n        \"\"\"\n        self.assertRaises(TypeError, sqlite.register_adapter, {}, None)\n\n    def test_set_isolation_level(self):\n        # See issue 27881.\n        class CustomStr(str):\n            def upper(self):\n                return None\n            def __del__(self):\n                con.isolation_level = \"\"\n\n        con = sqlite.connect(\":memory:\")\n        con.isolation_level = None\n        for level in \"\", \"DEFERRED\", \"IMMEDIATE\", \"EXCLUSIVE\":\n            with self.subTest(level=level):\n                con.isolation_level = level\n                con.isolation_level = level.lower()\n                con.isolation_level = level.capitalize()\n                con.isolation_level = CustomStr(level)\n\n        # setting isolation_level failure should not alter previous state\n        con.isolation_level = None\n        con.isolation_level = \"DEFERRED\"\n        pairs = [\n            (1, TypeError), (b'', TypeError), (\"abc\", ValueError),\n            (\"IMMEDIATE\\0EXCLUSIVE\", ValueError), (\"\\xe9\", ValueError),\n        ]\n        for value, exc in pairs:\n            with self.subTest(level=value):\n                with self.assertRaises(exc):\n                    con.isolation_level = value\n                self.assertEqual(con.isolation_level, \"DEFERRED\")\n\n    def test_cursor_constructor_call_check(self):\n        \"\"\"\n        Verifies that cursor methods check whether base class __init__ was\n        called.\n        \"\"\"\n        class Cursor(sqlite.Cursor):\n            def __init__(self, con):\n                pass\n\n        con = sqlite.connect(\":memory:\")\n        cur = Cursor(con)\n        with self.assertRaises(sqlite.ProgrammingError):\n            cur.execute(\"select 4+5\").fetchall()\n        with self.assertRaisesRegex(sqlite.ProgrammingError,\n                                    r'^Base Cursor\\.__init__ not called\\.$'):\n            cur.close()\n\n    def test_str_subclass(self):\n        \"\"\"\n        The Python 3.0 port of the module didn't cope with values of subclasses of str.\n        \"\"\"\n        class MyStr(str): pass\n        self.con.execute(\"select ?\", (MyStr(\"abc\"),))\n\n    def test_connection_constructor_call_check(self):\n        \"\"\"\n        Verifies that connection methods check whether base class __init__ was\n        called.\n        \"\"\"\n        class Connection(sqlite.Connection):\n            def __init__(self, name):\n                pass\n\n        con = Connection(\":memory:\")\n        with self.assertRaises(sqlite.ProgrammingError):\n            cur = con.cursor()\n\n    def test_auto_commit(self):\n        \"\"\"\n        Verifies that creating a connection in autocommit mode works.\n        2.5.3 introduced a regression so that these could no longer\n        be created.\n        \"\"\"\n        con = sqlite.connect(\":memory:\", isolation_level=None)\n\n    def test_pragma_autocommit(self):\n        \"\"\"\n        Verifies that running a PRAGMA statement that does an autocommit does\n        work. This did not work in 2.5.3/2.5.4.\n        \"\"\"\n        cur = self.con.cursor()\n        cur.execute(\"create table foo(bar)\")\n        cur.execute(\"insert into foo(bar) values (5)\")\n\n        cur.execute(\"pragma page_size\")\n        row = cur.fetchone()\n\n    def test_connection_call(self):\n        \"\"\"\n        Call a connection with a non-string SQL request: check error handling\n        of the statement constructor.\n        \"\"\"\n        self.assertRaises(TypeError, self.con, b\"select 1\")\n\n    @unittest.skip(\"Not supported\")\n    def test_collation(self):\n        def collation_cb(a, b):\n            return 1\n        self.assertRaises(UnicodeEncodeError, self.con.create_collation,\n            # Lone surrogate cannot be encoded to the default encoding (utf8)\n            \"\\uDC80\", collation_cb)\n\n    @unittest.skip(\"does not make sense for libsql_client\")\n    def test_recursive_cursor_use(self):\n        \"\"\"\n        http://bugs.python.org/issue10811\n\n        Recursively using a cursor, such as when reusing it from a generator led to segfaults.\n        Now we catch recursive cursor usage and raise a ProgrammingError.\n        \"\"\"\n        con = sqlite.connect(\":memory:\")\n\n        cur = con.cursor()\n        cur.execute(\"create table a (bar)\")\n        cur.execute(\"create table b (baz)\")\n\n        def foo():\n            cur.execute(\"insert into a (bar) values (?)\", (1,))\n            yield 1\n\n        with self.assertRaises(sqlite.ProgrammingError):\n            cur.executemany(\"insert into b (baz) values (?)\",\n                            ((i,) for i in foo()))\n\n    def test_convert_timestamp_microsecond_padding(self):\n        \"\"\"\n        http://bugs.python.org/issue14720\n\n        The microsecond parsing of convert_timestamp() should pad with zeros,\n        since the microsecond string \"456\" actually represents \"456000\".\n        \"\"\"\n\n        con = sqlite.connect(\":memory:\", detect_types=sqlite.PARSE_DECLTYPES)\n        cur = con.cursor()\n        cur.execute(\"CREATE TABLE t (x TIMESTAMP)\")\n\n        # Microseconds should be 456000\n        cur.execute(\"INSERT INTO t (x) VALUES ('2012-04-04 15:06:00.456')\")\n\n        # Microseconds should be truncated to 123456\n        cur.execute(\"INSERT INTO t (x) VALUES ('2012-04-04 15:06:00.123456789')\")\n\n        cur.execute(\"SELECT * FROM t\")\n        values = [x[0] for x in cur.fetchall()]\n\n        self.assertEqual(values, [\n            datetime.datetime(2012, 4, 4, 15, 6, 0, 456000),\n            datetime.datetime(2012, 4, 4, 15, 6, 0, 123456),\n        ])\n\n    def test_invalid_isolation_level_type(self):\n        # isolation level is a string, not an integer\n        self.assertRaises(TypeError,\n                          sqlite.connect, \":memory:\", isolation_level=123)\n\n\n    def test_null_character(self):\n        # Issue #21147\n        cur = self.con.cursor()\n        queries = [\"\\0select 1\", \"select 1\\0\"]\n        for query in queries:\n            with self.subTest(query=query):\n                self.assertRaisesRegex(sqlite.ProgrammingError, \"null char\",\n                                       self.con.execute, query)\n            with self.subTest(query=query):\n                self.assertRaisesRegex(sqlite.ProgrammingError, \"null char\",\n                                       cur.execute, query)\n\n    @unittest.skip(\"TODO: implement this check\")\n    def test_surrogates(self):\n        con = sqlite.connect(\":memory:\")\n        self.assertRaises(UnicodeEncodeError, con, \"select '\\ud8ff'\")\n        self.assertRaises(UnicodeEncodeError, con, \"select '\\udcff'\")\n        cur = con.cursor()\n        self.assertRaises(UnicodeEncodeError, cur.execute, \"select '\\ud8ff'\")\n        self.assertRaises(UnicodeEncodeError, cur.execute, \"select '\\udcff'\")\n\n    def test_large_sql(self):\n        msg = \"query string is too large\"\n        with memory_database() as cx, cx_limit(cx) as lim:\n            cu = cx.cursor()\n\n            cx(\"select 1\".ljust(lim))\n            # use a different SQL statement; don't reuse from the LRU cache\n            cu.execute(\"select 2\".ljust(lim))\n\n            sql = \"select 3\".ljust(lim+1)\n            self.assertRaisesRegex(sqlite.DataError, msg, cx, sql)\n            self.assertRaisesRegex(sqlite.DataError, msg, cu.execute, sql)\n\n    @unittest.skip(\"Not supported\")\n    def test_commit_cursor_reset(self):\n        \"\"\"\n        Connection.commit() did reset cursors, which made sqlite3\n        to return rows multiple times when fetched from cursors\n        after commit. See issues 10513 and 23129 for details.\n        \"\"\"\n        con = sqlite.connect(\":memory:\")\n        con.executescript(\"\"\"\n        create table t(c);\n        create table t2(c);\n        insert into t values(0);\n        insert into t values(1);\n        insert into t values(2);\n        \"\"\")\n\n        self.assertEqual(con.isolation_level, \"\")\n\n        counter = 0\n        for i, row in enumerate(con.execute(\"select c from t\")):\n            with self.subTest(i=i, row=row):\n                con.execute(\"insert into t2(c) values (?)\", (i,))\n                con.commit()\n                if counter == 0:\n                    self.assertEqual(row[0], 0)\n                elif counter == 1:\n                    self.assertEqual(row[0], 1)\n                elif counter == 2:\n                    self.assertEqual(row[0], 2)\n                counter += 1\n        self.assertEqual(counter, 3, \"should have returned exactly three rows\")\n\n    @unittest.skip(\"Not supported\")\n    def test_bpo31770(self):\n        \"\"\"\n        The interpreter shouldn't crash in case Cursor.__init__() is called\n        more than once.\n        \"\"\"\n        def callback(*args):\n            pass\n        con = sqlite.connect(\":memory:\")\n        cur = sqlite.Cursor(con)\n        ref = weakref.ref(cur, callback)\n        cur.__init__(con)\n        del cur\n        # The interpreter shouldn't crash when ref is collected.\n        del ref\n        support.gc_collect()\n\n    def test_del_isolation_level_segfault(self):\n        with self.assertRaises(AttributeError):\n            del self.con.isolation_level\n\n    @unittest.skip(\"Not supported\")\n    def test_bpo37347(self):\n        class Printer:\n            def log(self, *args):\n                return sqlite.SQLITE_OK\n\n        for method in [self.con.set_trace_callback,\n                       functools.partial(self.con.set_progress_handler, n=1),\n                       self.con.set_authorizer]:\n            printer_instance = Printer()\n            method(printer_instance.log)\n            method(printer_instance.log)\n            self.con.execute(\"select 1\")  # trigger seg fault\n            method(None)\n\n    def test_return_empty_bytestring(self):\n        cur = self.con.execute(\"select X''\")\n        val = cur.fetchone()[0]\n        self.assertEqual(val, b'')\n\n    def test_table_lock_cursor_replace_stmt(self):\n        with memory_database() as con:\n            cur = con.cursor()\n            cur.execute(\"create table t(t)\")\n            cur.executemany(\"insert into t values(?)\",\n                            ((v,) for v in range(5)))\n            con.commit()\n            cur.execute(\"select t from t\")\n            cur.execute(\"drop table t\")\n            con.commit()\n\n    def test_table_lock_cursor_dealloc(self):\n        with memory_database() as con:\n            con.execute(\"create table t(t)\")\n            con.executemany(\"insert into t values(?)\",\n                            ((v,) for v in range(5)))\n            con.commit()\n            cur = con.execute(\"select t from t\")\n            del cur\n            con.execute(\"drop table t\")\n            con.commit()\n\n    @unittest.skip(\"Not supported\")\n    def test_table_lock_cursor_non_readonly_select(self):\n        with memory_database() as con:\n            con.execute(\"create table t(t)\")\n            con.executemany(\"insert into t values(?)\",\n                            ((v,) for v in range(5)))\n            con.commit()\n            def dup(v):\n                con.execute(\"insert into t values(?)\", (v,))\n                return\n            con.create_function(\"dup\", 1, dup)\n            cur = con.execute(\"select dup(t) from t\")\n            del cur\n            con.execute(\"drop table t\")\n            con.commit()\n\n    @unittest.skip(\"Not supported\")\n    def test_executescript_step_through_select(self):\n        with memory_database() as con:\n            values = [(v,) for v in range(5)]\n            with con:\n                con.execute(\"create table t(t)\")\n                con.executemany(\"insert into t values(?)\", values)\n            steps = []\n            con.create_function(\"step\", 1, lambda x: steps.append((x,)))\n            con.executescript(\"select step(t) from t\")\n            self.assertEqual(steps, values)\n\n    def test_custom_cursor_object_crash_gh_99886(self):\n        # This test segfaults on GH-99886\n        class MyCursor(sqlite.Cursor):\n            def __init__(self, *args, **kwargs):\n                super().__init__(*args, **kwargs)\n                # this can go before or after the super call; doesn't matter\n                self.some_attr = None\n\n        with memory_database() as con:\n            cur = con.cursor(MyCursor)\n            cur.close()\n            del cur", "\nclass RecursiveUseOfCursors(unittest.TestCase):\n    # GH-80254: sqlite3 should not segfault for recursive use of cursors.\n    msg = \"Recursive use of cursors not allowed\"\n\n    def setUp(self):\n        self.con = sqlite.connect(\":memory:\",\n                                  detect_types=sqlite.PARSE_COLNAMES)\n        self.cur = self.con.cursor()\n        self.cur.execute(\"create table test(x foo)\")\n        self.cur.executemany(\"insert into test(x) values (?)\",\n                             [(\"foo\",), (\"bar\",)])\n\n    def tearDown(self):\n        self.cur.close()\n        self.con.close()\n\n    @unittest.skip(\"does not make sense for libsql_client\")\n    def test_recursive_cursor_init(self):\n        conv = lambda x: self.cur.__init__(self.con)\n        with patch.dict(sqlite.converters, {\"INIT\": conv}):\n            self.cur.execute(f'select x as \"x [INIT]\", x from test')\n            self.assertRaisesRegex(sqlite.ProgrammingError, self.msg,\n                                   self.cur.fetchall)\n\n    def test_recursive_cursor_close(self):\n        conv = lambda x: self.cur.close()\n        with patch.dict(sqlite.converters, {\"CLOSE\": conv}):\n            self.cur.execute(f'select x as \"x [CLOSE]\", x from test')\n            self.assertRaisesRegex(sqlite.ProgrammingError, self.msg,\n                                   self.cur.fetchall)\n\n    def test_recursive_cursor_iter(self):\n        conv = lambda x, l=[]: self.cur.fetchone() if l else l.append(None)\n        with patch.dict(sqlite.converters, {\"ITER\": conv}):\n            self.cur.execute(f'select x as \"x [ITER]\", x from test')\n            self.assertRaisesRegex(sqlite.ProgrammingError, self.msg,\n                                   self.cur.fetchall)", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/dbapi2/test_types.py", "chunked_list": ["# pysqlite2/test/types.py: tests for type conversion and detection\n#\n# Copyright (C) 2005 Gerhard H\u00e4ring <gh@ghaering.de>\n#\n# This file is part of pysqlite.\n#\n# This software is provided 'as-is', without any express or implied\n# warranty.  In no event will the authors be held liable for any damages\n# arising from the use of this software.\n#", "# arising from the use of this software.\n#\n# Permission is granted to anyone to use this software for any purpose,\n# including commercial applications, and to alter it and redistribute it\n# freely, subject to the following restrictions:\n#\n# 1. The origin of this software must not be misrepresented; you must not\n#    claim that you wrote the original software. If you use this software\n#    in a product, an acknowledgment in the product documentation would be\n#    appreciated but is not required.", "#    in a product, an acknowledgment in the product documentation would be\n#    appreciated but is not required.\n# 2. Altered source versions must be plainly marked as such, and must not be\n#    misrepresented as being the original software.\n# 3. This notice may not be removed or altered from any source distribution.\n\nimport datetime\nimport unittest\nfrom . import libsql_client_helpers as sqlite\nimport sys\ntry:\n    import zlib\nexcept ImportError:\n    zlib = None", "from . import libsql_client_helpers as sqlite\nimport sys\ntry:\n    import zlib\nexcept ImportError:\n    zlib = None\n\nfrom test import support\n\n\nclass SqliteTypeTests(unittest.TestCase):\n    def setUp(self):\n        self.con = sqlite.connect(\":memory:\")\n        self.cur = self.con.cursor()\n        self.cur.execute(\"create table test(i integer, s varchar, f number, b blob)\")\n\n    def tearDown(self):\n        self.cur.close()\n        self.con.close()\n\n    def test_string(self):\n        self.cur.execute(\"insert into test(s) values (?)\", (\"\u00d6sterreich\",))\n        self.cur.execute(\"select s from test\")\n        row = self.cur.fetchone()\n        self.assertEqual(row[0], \"\u00d6sterreich\")\n\n    def test_string_with_null_character(self):\n        self.cur.execute(\"insert into test(s) values (?)\", (\"a\\0b\",))\n        self.cur.execute(\"select s from test\")\n        row = self.cur.fetchone()\n        self.assertEqual(row[0], \"a\\0b\")\n\n    def test_small_int(self):\n        self.cur.execute(\"insert into test(i) values (?)\", (42,))\n        self.cur.execute(\"select i from test\")\n        row = self.cur.fetchone()\n        self.assertEqual(row[0], 42)\n\n    def test_large_int(self):\n        num = 123456789123456789\n        self.cur.execute(\"insert into test(i) values (?)\", (num,))\n        self.cur.execute(\"select i from test\")\n        row = self.cur.fetchone()\n        self.assertEqual(row[0], num)\n\n    def test_float(self):\n        val = 3.14\n        self.cur.execute(\"insert into test(f) values (?)\", (val,))\n        self.cur.execute(\"select f from test\")\n        row = self.cur.fetchone()\n        self.assertEqual(row[0], val)\n\n    def test_blob(self):\n        sample = b\"Guglhupf\"\n        val = memoryview(sample)\n        self.cur.execute(\"insert into test(b) values (?)\", (val,))\n        self.cur.execute(\"select b from test\")\n        row = self.cur.fetchone()\n        self.assertEqual(row[0], sample)\n\n    def test_unicode_execute(self):\n        self.cur.execute(\"select '\u00d6sterreich'\")\n        row = self.cur.fetchone()\n        self.assertEqual(row[0], \"\u00d6sterreich\")\n\n    def test_too_large_int(self):\n        for value in 2**63, -2**63-1, 2**64:\n            with self.assertRaises(OverflowError):\n                self.cur.execute(\"insert into test(i) values (?)\", (value,))\n        self.cur.execute(\"select i from test\")\n        row = self.cur.fetchone()\n        self.assertIsNone(row)\n\n    @unittest.skip(\"TODO: implement this check\")\n    def test_string_with_surrogates(self):\n        for value in 0xd8ff, 0xdcff:\n            with self.assertRaises(UnicodeEncodeError):\n                self.cur.execute(\"insert into test(s) values (?)\", (chr(value),))\n        self.cur.execute(\"select s from test\")\n        row = self.cur.fetchone()\n        self.assertIsNone(row)\n\n    @unittest.skipUnless(sys.maxsize > 2**32, 'requires 64bit platform')\n    @support.bigmemtest(size=2**31, memuse=4, dry_run=False)\n    def test_too_large_string(self, maxsize):\n        with self.assertRaises(sqlite.DataError):\n            self.cur.execute(\"insert into test(s) values (?)\", ('x'*(2**31-1),))\n        with self.assertRaises(sqlite.DataError):\n            self.cur.execute(\"insert into test(s) values (?)\", ('x'*(2**31),))\n        self.cur.execute(\"select 1 from test\")\n        row = self.cur.fetchone()\n        self.assertIsNone(row)\n\n    @unittest.skipUnless(sys.maxsize > 2**32, 'requires 64bit platform')\n    @support.bigmemtest(size=2**31, memuse=3, dry_run=False)\n    def test_too_large_blob(self, maxsize):\n        with self.assertRaises(sqlite.DataError):\n            self.cur.execute(\"insert into test(s) values (?)\", (b'x'*(2**31-1),))\n        with self.assertRaises(sqlite.DataError):\n            self.cur.execute(\"insert into test(s) values (?)\", (b'x'*(2**31),))\n        self.cur.execute(\"select 1 from test\")\n        row = self.cur.fetchone()\n        self.assertIsNone(row)", "\n\nclass SqliteTypeTests(unittest.TestCase):\n    def setUp(self):\n        self.con = sqlite.connect(\":memory:\")\n        self.cur = self.con.cursor()\n        self.cur.execute(\"create table test(i integer, s varchar, f number, b blob)\")\n\n    def tearDown(self):\n        self.cur.close()\n        self.con.close()\n\n    def test_string(self):\n        self.cur.execute(\"insert into test(s) values (?)\", (\"\u00d6sterreich\",))\n        self.cur.execute(\"select s from test\")\n        row = self.cur.fetchone()\n        self.assertEqual(row[0], \"\u00d6sterreich\")\n\n    def test_string_with_null_character(self):\n        self.cur.execute(\"insert into test(s) values (?)\", (\"a\\0b\",))\n        self.cur.execute(\"select s from test\")\n        row = self.cur.fetchone()\n        self.assertEqual(row[0], \"a\\0b\")\n\n    def test_small_int(self):\n        self.cur.execute(\"insert into test(i) values (?)\", (42,))\n        self.cur.execute(\"select i from test\")\n        row = self.cur.fetchone()\n        self.assertEqual(row[0], 42)\n\n    def test_large_int(self):\n        num = 123456789123456789\n        self.cur.execute(\"insert into test(i) values (?)\", (num,))\n        self.cur.execute(\"select i from test\")\n        row = self.cur.fetchone()\n        self.assertEqual(row[0], num)\n\n    def test_float(self):\n        val = 3.14\n        self.cur.execute(\"insert into test(f) values (?)\", (val,))\n        self.cur.execute(\"select f from test\")\n        row = self.cur.fetchone()\n        self.assertEqual(row[0], val)\n\n    def test_blob(self):\n        sample = b\"Guglhupf\"\n        val = memoryview(sample)\n        self.cur.execute(\"insert into test(b) values (?)\", (val,))\n        self.cur.execute(\"select b from test\")\n        row = self.cur.fetchone()\n        self.assertEqual(row[0], sample)\n\n    def test_unicode_execute(self):\n        self.cur.execute(\"select '\u00d6sterreich'\")\n        row = self.cur.fetchone()\n        self.assertEqual(row[0], \"\u00d6sterreich\")\n\n    def test_too_large_int(self):\n        for value in 2**63, -2**63-1, 2**64:\n            with self.assertRaises(OverflowError):\n                self.cur.execute(\"insert into test(i) values (?)\", (value,))\n        self.cur.execute(\"select i from test\")\n        row = self.cur.fetchone()\n        self.assertIsNone(row)\n\n    @unittest.skip(\"TODO: implement this check\")\n    def test_string_with_surrogates(self):\n        for value in 0xd8ff, 0xdcff:\n            with self.assertRaises(UnicodeEncodeError):\n                self.cur.execute(\"insert into test(s) values (?)\", (chr(value),))\n        self.cur.execute(\"select s from test\")\n        row = self.cur.fetchone()\n        self.assertIsNone(row)\n\n    @unittest.skipUnless(sys.maxsize > 2**32, 'requires 64bit platform')\n    @support.bigmemtest(size=2**31, memuse=4, dry_run=False)\n    def test_too_large_string(self, maxsize):\n        with self.assertRaises(sqlite.DataError):\n            self.cur.execute(\"insert into test(s) values (?)\", ('x'*(2**31-1),))\n        with self.assertRaises(sqlite.DataError):\n            self.cur.execute(\"insert into test(s) values (?)\", ('x'*(2**31),))\n        self.cur.execute(\"select 1 from test\")\n        row = self.cur.fetchone()\n        self.assertIsNone(row)\n\n    @unittest.skipUnless(sys.maxsize > 2**32, 'requires 64bit platform')\n    @support.bigmemtest(size=2**31, memuse=3, dry_run=False)\n    def test_too_large_blob(self, maxsize):\n        with self.assertRaises(sqlite.DataError):\n            self.cur.execute(\"insert into test(s) values (?)\", (b'x'*(2**31-1),))\n        with self.assertRaises(sqlite.DataError):\n            self.cur.execute(\"insert into test(s) values (?)\", (b'x'*(2**31),))\n        self.cur.execute(\"select 1 from test\")\n        row = self.cur.fetchone()\n        self.assertIsNone(row)", "\n\nclass DeclTypesTests(unittest.TestCase):\n    class Foo:\n        def __init__(self, _val):\n            if isinstance(_val, bytes):\n                # sqlite3 always calls __init__ with a bytes created from a\n                # UTF-8 string when __conform__ was used to store the object.\n                _val = _val.decode('utf-8')\n            self.val = _val\n\n        def __eq__(self, other):\n            if not isinstance(other, DeclTypesTests.Foo):\n                return NotImplemented\n            return self.val == other.val\n\n        def __conform__(self, protocol):\n            if protocol is sqlite.PrepareProtocol:\n                return self.val\n            else:\n                return None\n\n        def __str__(self):\n            return \"<%s>\" % self.val\n\n    class BadConform:\n        def __init__(self, exc):\n            self.exc = exc\n        def __conform__(self, protocol):\n            raise self.exc\n\n    def setUp(self):\n        self.con = sqlite.connect(\":memory:\", detect_types=sqlite.PARSE_DECLTYPES)\n        self.cur = self.con.cursor()\n        self.cur.execute(\"\"\"\n            create table test(\n                i int,\n                s str,\n                f float,\n                b bool,\n                u unicode,\n                foo foo,\n                bin blob,\n                n1 number,\n                n2 number(5),\n                bad bad,\n                cbin cblob)\n        \"\"\")\n\n        # override float, make them always return the same number\n        sqlite.converters[\"FLOAT\"] = lambda x: 47.2\n\n        # and implement two custom ones\n        sqlite.converters[\"BOOL\"] = lambda x: bool(int(x))\n        sqlite.converters[\"FOO\"] = DeclTypesTests.Foo\n        sqlite.converters[\"BAD\"] = DeclTypesTests.BadConform\n        sqlite.converters[\"WRONG\"] = lambda x: \"WRONG\"\n        sqlite.converters[\"NUMBER\"] = float\n        sqlite.converters[\"CBLOB\"] = lambda x: b\"blobish\"\n\n    def tearDown(self):\n        del sqlite.converters[\"FLOAT\"]\n        del sqlite.converters[\"BOOL\"]\n        del sqlite.converters[\"FOO\"]\n        del sqlite.converters[\"BAD\"]\n        del sqlite.converters[\"WRONG\"]\n        del sqlite.converters[\"NUMBER\"]\n        del sqlite.converters[\"CBLOB\"]\n        self.cur.close()\n        self.con.close()\n\n    def test_string(self):\n        # default\n        self.cur.execute(\"insert into test(s) values (?)\", (\"foo\",))\n        self.cur.execute('select s as \"s [WRONG]\" from test')\n        row = self.cur.fetchone()\n        self.assertEqual(row[0], \"foo\")\n\n    def test_small_int(self):\n        # default\n        self.cur.execute(\"insert into test(i) values (?)\", (42,))\n        self.cur.execute(\"select i from test\")\n        row = self.cur.fetchone()\n        self.assertEqual(row[0], 42)\n\n    def test_large_int(self):\n        # default\n        num = 123456789123456789\n        self.cur.execute(\"insert into test(i) values (?)\", (num,))\n        self.cur.execute(\"select i from test\")\n        row = self.cur.fetchone()\n        self.assertEqual(row[0], num)\n\n    def test_float(self):\n        # custom\n        val = 3.14\n        self.cur.execute(\"insert into test(f) values (?)\", (val,))\n        self.cur.execute(\"select f from test\")\n        row = self.cur.fetchone()\n        self.assertEqual(row[0], 47.2)\n\n    def test_bool(self):\n        # custom\n        self.cur.execute(\"insert into test(b) values (?)\", (False,))\n        self.cur.execute(\"select b from test\")\n        row = self.cur.fetchone()\n        self.assertIs(row[0], False)\n\n        self.cur.execute(\"delete from test\")\n        self.cur.execute(\"insert into test(b) values (?)\", (True,))\n        self.cur.execute(\"select b from test\")\n        row = self.cur.fetchone()\n        self.assertIs(row[0], True)\n\n    def test_unicode(self):\n        # default\n        val = \"\\xd6sterreich\"\n        self.cur.execute(\"insert into test(u) values (?)\", (val,))\n        self.cur.execute(\"select u from test\")\n        row = self.cur.fetchone()\n        self.assertEqual(row[0], val)\n\n    def test_foo(self):\n        val = DeclTypesTests.Foo(\"bla\")\n        self.cur.execute(\"insert into test(foo) values (?)\", (val,))\n        self.cur.execute(\"select foo from test\")\n        row = self.cur.fetchone()\n        self.assertEqual(row[0], val)\n\n    def test_error_in_conform(self):\n        val = DeclTypesTests.BadConform(TypeError)\n        with self.assertRaises(sqlite.ProgrammingError):\n            self.cur.execute(\"insert into test(bad) values (?)\", (val,))\n        with self.assertRaises(sqlite.ProgrammingError):\n            self.cur.execute(\"insert into test(bad) values (:val)\", {\"val\": val})\n\n        val = DeclTypesTests.BadConform(KeyboardInterrupt)\n        with self.assertRaises(KeyboardInterrupt):\n            self.cur.execute(\"insert into test(bad) values (?)\", (val,))\n        with self.assertRaises(KeyboardInterrupt):\n            self.cur.execute(\"insert into test(bad) values (:val)\", {\"val\": val})\n\n    def test_unsupported_seq(self):\n        class Bar: pass\n        val = Bar()\n        with self.assertRaises(sqlite.ProgrammingError):\n            self.cur.execute(\"insert into test(f) values (?)\", (val,))\n\n    def test_unsupported_dict(self):\n        class Bar: pass\n        val = Bar()\n        with self.assertRaises(sqlite.ProgrammingError):\n            self.cur.execute(\"insert into test(f) values (:val)\", {\"val\": val})\n\n    def test_blob(self):\n        # default\n        sample = b\"Guglhupf\"\n        val = memoryview(sample)\n        self.cur.execute(\"insert into test(bin) values (?)\", (val,))\n        self.cur.execute(\"select bin from test\")\n        row = self.cur.fetchone()\n        self.assertEqual(row[0], sample)\n\n    def test_number1(self):\n        self.cur.execute(\"insert into test(n1) values (5)\")\n        value = self.cur.execute(\"select n1 from test\").fetchone()[0]\n        # if the converter is not used, it's an int instead of a float\n        self.assertEqual(type(value), float)\n\n    def test_number2(self):\n        \"\"\"Checks whether converter names are cut off at '(' characters\"\"\"\n        self.cur.execute(\"insert into test(n2) values (5)\")\n        value = self.cur.execute(\"select n2 from test\").fetchone()[0]\n        # if the converter is not used, it's an int instead of a float\n        self.assertEqual(type(value), float)\n\n    def test_convert_zero_sized_blob(self):\n        self.con.execute(\"insert into test(cbin) values (?)\", (b\"\",))\n        cur = self.con.execute(\"select cbin from test\")\n        # Zero-sized blobs with converters returns None.  This differs from\n        # blobs without a converter, where b\"\" is returned.\n        self.assertIsNone(cur.fetchone()[0])", "\n\nclass ColNamesTests(unittest.TestCase):\n    def setUp(self):\n        self.con = sqlite.connect(\":memory:\", detect_types=sqlite.PARSE_COLNAMES)\n        self.cur = self.con.cursor()\n        self.cur.execute(\"create table test(x foo)\")\n\n        sqlite.converters[\"FOO\"] = lambda x: \"[%s]\" % x.decode(\"ascii\")\n        sqlite.converters[\"BAR\"] = lambda x: \"<%s>\" % x.decode(\"ascii\")\n        sqlite.converters[\"EXC\"] = lambda x: 5/0\n        sqlite.converters[\"B1B1\"] = lambda x: \"MARKER\"\n\n    def tearDown(self):\n        del sqlite.converters[\"FOO\"]\n        del sqlite.converters[\"BAR\"]\n        del sqlite.converters[\"EXC\"]\n        del sqlite.converters[\"B1B1\"]\n        self.cur.close()\n        self.con.close()\n\n    def test_decl_type_not_used(self):\n        \"\"\"\n        Assures that the declared type is not used when PARSE_DECLTYPES\n        is not set.\n        \"\"\"\n        self.cur.execute(\"insert into test(x) values (?)\", (\"xxx\",))\n        self.cur.execute(\"select x from test\")\n        val = self.cur.fetchone()[0]\n        self.assertEqual(val, \"xxx\")\n\n    def test_none(self):\n        self.cur.execute(\"insert into test(x) values (?)\", (None,))\n        self.cur.execute(\"select x from test\")\n        val = self.cur.fetchone()[0]\n        self.assertEqual(val, None)\n\n    def test_col_name(self):\n        self.cur.execute(\"insert into test(x) values (?)\", (\"xxx\",))\n        self.cur.execute('select x as \"x y [bar]\" from test')\n        val = self.cur.fetchone()[0]\n        self.assertEqual(val, \"<xxx>\")\n\n        # Check if the stripping of colnames works. Everything after the first\n        # '[' (and the preceding space) should be stripped.\n        self.assertEqual(self.cur.description[0][0], \"x y\")\n\n    def test_case_in_converter_name(self):\n        self.cur.execute(\"select 'other' as \\\"x [b1b1]\\\"\")\n        val = self.cur.fetchone()[0]\n        self.assertEqual(val, \"MARKER\")\n\n    def test_cursor_description_no_row(self):\n        \"\"\"\n        cursor.description should at least provide the column name(s), even if\n        no row returned.\n        \"\"\"\n        self.cur.execute(\"select * from test where 0 = 1\")\n        self.assertEqual(self.cur.description[0][0], \"x\")\n\n    def test_cursor_description_insert(self):\n        self.cur.execute(\"insert into test values (1)\")\n        self.assertIsNone(self.cur.description)", "\n\n@unittest.skipIf(sqlite.sqlite_version_info < (3, 8, 3), \"CTEs not supported\")\nclass CommonTableExpressionTests(unittest.TestCase):\n\n    def setUp(self):\n        self.con = sqlite.connect(\":memory:\")\n        self.cur = self.con.cursor()\n        self.cur.execute(\"create table test(x foo)\")\n\n    def tearDown(self):\n        self.cur.close()\n        self.con.close()\n\n    def test_cursor_description_cte_simple(self):\n        self.cur.execute(\"with one as (select 1) select * from one\")\n        self.assertIsNotNone(self.cur.description)\n        self.assertEqual(self.cur.description[0][0], \"1\")\n\n    def test_cursor_description_cte_multiple_columns(self):\n        self.cur.execute(\"insert into test values(1)\")\n        self.cur.execute(\"insert into test values(2)\")\n        self.cur.execute(\"with testCTE as (select * from test) select * from testCTE\")\n        self.assertIsNotNone(self.cur.description)\n        self.assertEqual(self.cur.description[0][0], \"x\")\n\n    def test_cursor_description_cte(self):\n        self.cur.execute(\"insert into test values (1)\")\n        self.cur.execute(\"with bar as (select * from test) select * from test where x = 1\")\n        self.assertIsNotNone(self.cur.description)\n        self.assertEqual(self.cur.description[0][0], \"x\")\n        self.cur.execute(\"with bar as (select * from test) select * from test where x = 2\")\n        self.assertIsNotNone(self.cur.description)\n        self.assertEqual(self.cur.description[0][0], \"x\")", "\n\nclass ObjectAdaptationTests(unittest.TestCase):\n    def cast(obj):\n        return float(obj)\n    cast = staticmethod(cast)\n\n    def setUp(self):\n        self.con = sqlite.connect(\":memory:\")\n        try:\n            del sqlite.adapters[int]\n        except:\n            pass\n        sqlite.register_adapter(int, ObjectAdaptationTests.cast)\n        self.cur = self.con.cursor()\n\n    def tearDown(self):\n        del sqlite.adapters[(int, sqlite.PrepareProtocol)]\n        self.cur.close()\n        self.con.close()\n\n    def test_caster_is_used(self):\n        self.cur.execute(\"select ?\", (4,))\n        val = self.cur.fetchone()[0]\n        self.assertEqual(type(val), float)\n\n    def test_missing_adapter(self):\n        with self.assertRaises(sqlite.ProgrammingError):\n            sqlite.adapt(1.)  # No float adapter registered\n\n    def test_missing_protocol(self):\n        with self.assertRaises(sqlite.ProgrammingError):\n            sqlite.adapt(1, None)\n\n    def test_defect_proto(self):\n        class DefectProto():\n            def __adapt__(self):\n                return None\n        with self.assertRaises(sqlite.ProgrammingError):\n            sqlite.adapt(1., DefectProto)\n\n    def test_defect_self_adapt(self):\n        class DefectSelfAdapt(float):\n            def __conform__(self, _):\n                return None\n        with self.assertRaises(sqlite.ProgrammingError):\n            sqlite.adapt(DefectSelfAdapt(1.))\n\n    def test_custom_proto(self):\n        class CustomProto():\n            def __adapt__(self):\n                return \"adapted\"\n        self.assertEqual(sqlite.adapt(1., CustomProto), \"adapted\")\n\n    def test_adapt(self):\n        val = 42\n        self.assertEqual(float(val), sqlite.adapt(val))\n\n    def test_adapt_alt(self):\n        alt = \"other\"\n        self.assertEqual(alt, sqlite.adapt(1., None, alt))", "\n\n@unittest.skipUnless(zlib, \"requires zlib\")\nclass BinaryConverterTests(unittest.TestCase):\n    def convert(s):\n        return zlib.decompress(s)\n    convert = staticmethod(convert)\n\n    def setUp(self):\n        self.con = sqlite.connect(\":memory:\", detect_types=sqlite.PARSE_COLNAMES)\n        sqlite.register_converter(\"bin\", BinaryConverterTests.convert)\n\n    def tearDown(self):\n        self.con.close()\n\n    def test_binary_input_for_converter(self):\n        testdata = b\"abcdefg\" * 10\n        result = self.con.execute('select ? as \"x [bin]\"', (memoryview(zlib.compress(testdata)),)).fetchone()[0]\n        self.assertEqual(testdata, result)", "\nclass DateTimeTests(unittest.TestCase):\n    def setUp(self):\n        self.con = sqlite.connect(\":memory:\", detect_types=sqlite.PARSE_DECLTYPES)\n        self.cur = self.con.cursor()\n        self.cur.execute(\"create table test(d date, ts timestamp)\")\n\n    def tearDown(self):\n        self.cur.close()\n        self.con.close()\n\n    def test_sqlite_date(self):\n        d = sqlite.Date(2004, 2, 14)\n        self.cur.execute(\"insert into test(d) values (?)\", (d,))\n        self.cur.execute(\"select d from test\")\n        d2 = self.cur.fetchone()[0]\n        self.assertEqual(d, d2)\n\n    def test_sqlite_timestamp(self):\n        ts = sqlite.Timestamp(2004, 2, 14, 7, 15, 0)\n        self.cur.execute(\"insert into test(ts) values (?)\", (ts,))\n        self.cur.execute(\"select ts from test\")\n        ts2 = self.cur.fetchone()[0]\n        self.assertEqual(ts, ts2)\n\n    def test_sql_timestamp(self):\n        now = datetime.datetime.utcnow()\n        self.cur.execute(\"insert into test(ts) values (current_timestamp)\")\n        self.cur.execute(\"select ts from test\")\n        ts = self.cur.fetchone()[0]\n        self.assertEqual(type(ts), datetime.datetime)\n        self.assertEqual(ts.year, now.year)\n\n    def test_date_time_sub_seconds(self):\n        ts = sqlite.Timestamp(2004, 2, 14, 7, 15, 0, 500000)\n        self.cur.execute(\"insert into test(ts) values (?)\", (ts,))\n        self.cur.execute(\"select ts from test\")\n        ts2 = self.cur.fetchone()[0]\n        self.assertEqual(ts, ts2)\n\n    def test_date_time_sub_seconds_floating_point(self):\n        ts = sqlite.Timestamp(2004, 2, 14, 7, 15, 0, 510241)\n        self.cur.execute(\"insert into test(ts) values (?)\", (ts,))\n        self.cur.execute(\"select ts from test\")\n        ts2 = self.cur.fetchone()[0]\n        self.assertEqual(ts, ts2)", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/dbapi2/test_dump.py", "chunked_list": ["# Author: Paul Kippes <kippesp@gmail.com>\n\nimport unittest\nfrom . import libsql_client_helpers as sqlite\nfrom .test_dbapi import memory_database\n\n\nclass DumpTests(unittest.TestCase):\n    def setUp(self):\n        self.cx = sqlite.connect(\":memory:\")\n        self.cu = self.cx.cursor()\n\n    def tearDown(self):\n        self.cx.close()\n\n    @unittest.skip(\"sqld doesn't support triggers yet\")\n    def test_table_dump(self):\n        expected_sqls = [\n                \"\"\"CREATE TABLE \"index\"(\"index\" blob);\"\"\"\n                ,\n                \"\"\"INSERT INTO \"index\" VALUES(X'01');\"\"\"\n                ,\n                \"\"\"CREATE TABLE \"quoted\"\"table\"(\"quoted\"\"field\" text);\"\"\"\n                ,\n                \"\"\"INSERT INTO \"quoted\"\"table\" VALUES('quoted''value');\"\"\"\n                ,\n                \"CREATE TABLE t1(id integer primary key, s1 text, \" \\\n                \"t1_i1 integer not null, i2 integer, unique (s1), \" \\\n                \"constraint t1_idx1 unique (i2));\"\n                ,\n                \"INSERT INTO \\\"t1\\\" VALUES(1,'foo',10,20);\"\n                ,\n                \"INSERT INTO \\\"t1\\\" VALUES(2,'foo2',30,30);\"\n                ,\n                \"CREATE TABLE t2(id integer, t2_i1 integer, \" \\\n                \"t2_i2 integer, primary key (id),\" \\\n                \"foreign key(t2_i1) references t1(t1_i1));\"\n                ,\n                \"CREATE TRIGGER trigger_1 update of t1_i1 on t1 \" \\\n                \"begin \" \\\n                \"update t2 set t2_i1 = new.t1_i1 where t2_i1 = old.t1_i1; \" \\\n                \"end;\"\n                ,\n                \"CREATE VIEW v1 as select * from t1 left join t2 \" \\\n                \"using (id);\"\n                ]\n        [self.cu.execute(s) for s in expected_sqls]\n        i = self.cx.iterdump()\n        actual_sqls = [s for s in i]\n        expected_sqls = ['BEGIN TRANSACTION;'] + expected_sqls + \\\n            ['COMMIT;']\n        [self.assertEqual(expected_sqls[i], actual_sqls[i])\n            for i in range(len(expected_sqls))]\n\n    @unittest.skip(\"sqld adds more tables and this exact test fails\")\n    def test_dump_autoincrement(self):\n        expected = [\n            'CREATE TABLE \"t1\" (id integer primary key autoincrement);',\n            'INSERT INTO \"t1\" VALUES(NULL);',\n            'CREATE TABLE \"t2\" (id integer primary key autoincrement);',\n        ]\n        self.cu.executescript(\"\".join(expected))\n\n        # the NULL value should now be automatically be set to 1\n        expected[1] = expected[1].replace(\"NULL\", \"1\")\n        expected.insert(0, \"BEGIN TRANSACTION;\")\n        expected.extend([\n            'DELETE FROM \"sqlite_sequence\";',\n            'INSERT INTO \"sqlite_sequence\" VALUES(\\'t1\\',1);',\n            'COMMIT;',\n        ])\n\n        actual = [stmt for stmt in self.cx.iterdump()]\n        self.assertEqual(expected, actual)\n\n    @unittest.skip(\"sqld cannot create new db\")\n    def test_dump_autoincrement_create_new_db(self):\n        self.cu.execute(\"BEGIN TRANSACTION\")\n        self.cu.execute(\"CREATE TABLE t1 (id integer primary key autoincrement)\")\n        self.cu.execute(\"CREATE TABLE t2 (id integer primary key autoincrement)\")\n        self.cu.executemany(\"INSERT INTO t1 VALUES(?)\", ((None,) for _ in range(9)))\n        self.cu.executemany(\"INSERT INTO t2 VALUES(?)\", ((None,) for _ in range(4)))\n        self.cx.commit()\n\n        with memory_database() as cx2:\n            query = \"\".join(self.cx.iterdump())\n            cx2.executescript(query)\n            cu2 = cx2.cursor()\n\n            dataset = (\n                (\"t1\", 9),\n                (\"t2\", 4),\n            )\n            for table, seq in dataset:\n                with self.subTest(table=table, seq=seq):\n                    res = cu2.execute(\"\"\"\n                        SELECT \"seq\" FROM \"sqlite_sequence\" WHERE \"name\" == ?\n                    \"\"\", (table,))\n                    rows = res.fetchall()\n                    self.assertEqual(rows[0][0], seq)\n\n    @unittest.skip(\"sqld adds more tables and this exact test fails\")\n    def test_unorderable_row(self):\n        # iterdump() should be able to cope with unorderable row types (issue #15545)\n        class UnorderableRow:\n            def __init__(self, cursor, row):\n                self.row = row\n            def __getitem__(self, index):\n                return self.row[index]\n        self.cx.row_factory = UnorderableRow\n        CREATE_ALPHA = \"\"\"CREATE TABLE \"alpha\" (\"one\");\"\"\"\n        CREATE_BETA = \"\"\"CREATE TABLE \"beta\" (\"two\");\"\"\"\n        expected = [\n            \"BEGIN TRANSACTION;\",\n            CREATE_ALPHA,\n            CREATE_BETA,\n            \"COMMIT;\"\n            ]\n        self.cu.execute(CREATE_BETA)\n        self.cu.execute(CREATE_ALPHA)\n        got = list(self.cx.iterdump())\n        self.assertEqual(expected, got)", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/dbapi2/__init__.py", "chunked_list": [""]}
{"filename": "tests/dbapi2/test_hooks.py", "chunked_list": ["# pysqlite2/test/hooks.py: tests for various SQLite-specific hooks\n#\n# Copyright (C) 2006-2007 Gerhard H\u00e4ring <gh@ghaering.de>\n#\n# This file is part of pysqlite.\n#\n# This software is provided 'as-is', without any express or implied\n# warranty.  In no event will the authors be held liable for any damages\n# arising from the use of this software.\n#", "# arising from the use of this software.\n#\n# Permission is granted to anyone to use this software for any purpose,\n# including commercial applications, and to alter it and redistribute it\n# freely, subject to the following restrictions:\n#\n# 1. The origin of this software must not be misrepresented; you must not\n#    claim that you wrote the original software. If you use this software\n#    in a product, an acknowledgment in the product documentation would be\n#    appreciated but is not required.", "#    in a product, an acknowledgment in the product documentation would be\n#    appreciated but is not required.\n# 2. Altered source versions must be plainly marked as such, and must not be\n#    misrepresented as being the original software.\n# 3. This notice may not be removed or altered from any source distribution.\n\nimport contextlib\nfrom . import libsql_client_helpers as sqlite\nimport unittest\n", "import unittest\n\nfrom test.support.os_helper import TESTFN, unlink\n\nfrom .test_dbapi import memory_database, cx_limit\nfrom .test_userfunctions import with_tracebacks\n\n\n@unittest.skip(\"Not supported\")\nclass CollationTests(unittest.TestCase):\n    def test_create_collation_not_string(self):\n        con = sqlite.connect(\":memory:\")\n        with self.assertRaises(TypeError):\n            con.create_collation(None, lambda x, y: (x > y) - (x < y))\n\n    def test_create_collation_not_callable(self):\n        con = sqlite.connect(\":memory:\")\n        with self.assertRaises(TypeError) as cm:\n            con.create_collation(\"X\", 42)\n        self.assertEqual(str(cm.exception), 'parameter must be callable')\n\n    def test_create_collation_not_ascii(self):\n        con = sqlite.connect(\":memory:\")\n        con.create_collation(\"coll\u00e4\", lambda x, y: (x > y) - (x < y))\n\n    def test_create_collation_bad_upper(self):\n        class BadUpperStr(str):\n            def upper(self):\n                return None\n        con = sqlite.connect(\":memory:\")\n        mycoll = lambda x, y: -((x > y) - (x < y))\n        con.create_collation(BadUpperStr(\"mycoll\"), mycoll)\n        result = con.execute(\"\"\"\n            select x from (\n            select 'a' as x\n            union\n            select 'b' as x\n            ) order by x collate mycoll\n            \"\"\").fetchall()\n        self.assertEqual(result[0][0], 'b')\n        self.assertEqual(result[1][0], 'a')\n\n    def test_collation_is_used(self):\n        def mycoll(x, y):\n            # reverse order\n            return -((x > y) - (x < y))\n\n        con = sqlite.connect(\":memory:\")\n        con.create_collation(\"mycoll\", mycoll)\n        sql = \"\"\"\n            select x from (\n            select 'a' as x\n            union\n            select 'b' as x\n            union\n            select 'c' as x\n            ) order by x collate mycoll\n            \"\"\"\n        result = con.execute(sql).fetchall()\n        self.assertEqual(result, [('c',), ('b',), ('a',)],\n                         msg='the expected order was not returned')\n\n        con.create_collation(\"mycoll\", None)\n        with self.assertRaises(sqlite.OperationalError) as cm:\n            result = con.execute(sql).fetchall()\n        self.assertEqual(str(cm.exception), 'no such collation sequence: mycoll')\n\n    def test_collation_returns_large_integer(self):\n        def mycoll(x, y):\n            # reverse order\n            return -((x > y) - (x < y)) * 2**32\n        con = sqlite.connect(\":memory:\")\n        con.create_collation(\"mycoll\", mycoll)\n        sql = \"\"\"\n            select x from (\n            select 'a' as x\n            union\n            select 'b' as x\n            union\n            select 'c' as x\n            ) order by x collate mycoll\n            \"\"\"\n        result = con.execute(sql).fetchall()\n        self.assertEqual(result, [('c',), ('b',), ('a',)],\n                         msg=\"the expected order was not returned\")\n\n    def test_collation_register_twice(self):\n        \"\"\"\n        Register two different collation functions under the same name.\n        Verify that the last one is actually used.\n        \"\"\"\n        con = sqlite.connect(\":memory:\")\n        con.create_collation(\"mycoll\", lambda x, y: (x > y) - (x < y))\n        con.create_collation(\"mycoll\", lambda x, y: -((x > y) - (x < y)))\n        result = con.execute(\"\"\"\n            select x from (select 'a' as x union select 'b' as x) order by x collate mycoll\n            \"\"\").fetchall()\n        self.assertEqual(result[0][0], 'b')\n        self.assertEqual(result[1][0], 'a')\n\n    def test_deregister_collation(self):\n        \"\"\"\n        Register a collation, then deregister it. Make sure an error is raised if we try\n        to use it.\n        \"\"\"\n        con = sqlite.connect(\":memory:\")\n        con.create_collation(\"mycoll\", lambda x, y: (x > y) - (x < y))\n        con.create_collation(\"mycoll\", None)\n        with self.assertRaises(sqlite.OperationalError) as cm:\n            con.execute(\"select 'a' as x union select 'b' as x order by x collate mycoll\")\n        self.assertEqual(str(cm.exception), 'no such collation sequence: mycoll')", "@unittest.skip(\"Not supported\")\nclass CollationTests(unittest.TestCase):\n    def test_create_collation_not_string(self):\n        con = sqlite.connect(\":memory:\")\n        with self.assertRaises(TypeError):\n            con.create_collation(None, lambda x, y: (x > y) - (x < y))\n\n    def test_create_collation_not_callable(self):\n        con = sqlite.connect(\":memory:\")\n        with self.assertRaises(TypeError) as cm:\n            con.create_collation(\"X\", 42)\n        self.assertEqual(str(cm.exception), 'parameter must be callable')\n\n    def test_create_collation_not_ascii(self):\n        con = sqlite.connect(\":memory:\")\n        con.create_collation(\"coll\u00e4\", lambda x, y: (x > y) - (x < y))\n\n    def test_create_collation_bad_upper(self):\n        class BadUpperStr(str):\n            def upper(self):\n                return None\n        con = sqlite.connect(\":memory:\")\n        mycoll = lambda x, y: -((x > y) - (x < y))\n        con.create_collation(BadUpperStr(\"mycoll\"), mycoll)\n        result = con.execute(\"\"\"\n            select x from (\n            select 'a' as x\n            union\n            select 'b' as x\n            ) order by x collate mycoll\n            \"\"\").fetchall()\n        self.assertEqual(result[0][0], 'b')\n        self.assertEqual(result[1][0], 'a')\n\n    def test_collation_is_used(self):\n        def mycoll(x, y):\n            # reverse order\n            return -((x > y) - (x < y))\n\n        con = sqlite.connect(\":memory:\")\n        con.create_collation(\"mycoll\", mycoll)\n        sql = \"\"\"\n            select x from (\n            select 'a' as x\n            union\n            select 'b' as x\n            union\n            select 'c' as x\n            ) order by x collate mycoll\n            \"\"\"\n        result = con.execute(sql).fetchall()\n        self.assertEqual(result, [('c',), ('b',), ('a',)],\n                         msg='the expected order was not returned')\n\n        con.create_collation(\"mycoll\", None)\n        with self.assertRaises(sqlite.OperationalError) as cm:\n            result = con.execute(sql).fetchall()\n        self.assertEqual(str(cm.exception), 'no such collation sequence: mycoll')\n\n    def test_collation_returns_large_integer(self):\n        def mycoll(x, y):\n            # reverse order\n            return -((x > y) - (x < y)) * 2**32\n        con = sqlite.connect(\":memory:\")\n        con.create_collation(\"mycoll\", mycoll)\n        sql = \"\"\"\n            select x from (\n            select 'a' as x\n            union\n            select 'b' as x\n            union\n            select 'c' as x\n            ) order by x collate mycoll\n            \"\"\"\n        result = con.execute(sql).fetchall()\n        self.assertEqual(result, [('c',), ('b',), ('a',)],\n                         msg=\"the expected order was not returned\")\n\n    def test_collation_register_twice(self):\n        \"\"\"\n        Register two different collation functions under the same name.\n        Verify that the last one is actually used.\n        \"\"\"\n        con = sqlite.connect(\":memory:\")\n        con.create_collation(\"mycoll\", lambda x, y: (x > y) - (x < y))\n        con.create_collation(\"mycoll\", lambda x, y: -((x > y) - (x < y)))\n        result = con.execute(\"\"\"\n            select x from (select 'a' as x union select 'b' as x) order by x collate mycoll\n            \"\"\").fetchall()\n        self.assertEqual(result[0][0], 'b')\n        self.assertEqual(result[1][0], 'a')\n\n    def test_deregister_collation(self):\n        \"\"\"\n        Register a collation, then deregister it. Make sure an error is raised if we try\n        to use it.\n        \"\"\"\n        con = sqlite.connect(\":memory:\")\n        con.create_collation(\"mycoll\", lambda x, y: (x > y) - (x < y))\n        con.create_collation(\"mycoll\", None)\n        with self.assertRaises(sqlite.OperationalError) as cm:\n            con.execute(\"select 'a' as x union select 'b' as x order by x collate mycoll\")\n        self.assertEqual(str(cm.exception), 'no such collation sequence: mycoll')", "\n@unittest.skip(\"Not supported\")\nclass ProgressTests(unittest.TestCase):\n    def test_progress_handler_used(self):\n        \"\"\"\n        Test that the progress handler is invoked once it is set.\n        \"\"\"\n        con = sqlite.connect(\":memory:\")\n        progress_calls = []\n        def progress():\n            progress_calls.append(None)\n            return 0\n        con.set_progress_handler(progress, 1)\n        con.execute(\"\"\"\n            create table foo(a, b)\n            \"\"\")\n        self.assertTrue(progress_calls)\n\n    def test_opcode_count(self):\n        \"\"\"\n        Test that the opcode argument is respected.\n        \"\"\"\n        con = sqlite.connect(\":memory:\")\n        progress_calls = []\n        def progress():\n            progress_calls.append(None)\n            return 0\n        con.set_progress_handler(progress, 1)\n        curs = con.cursor()\n        curs.execute(\"\"\"\n            create table foo (a, b)\n            \"\"\")\n        first_count = len(progress_calls)\n        progress_calls = []\n        con.set_progress_handler(progress, 2)\n        curs.execute(\"\"\"\n            create table bar (a, b)\n            \"\"\")\n        second_count = len(progress_calls)\n        self.assertGreaterEqual(first_count, second_count)\n\n    def test_cancel_operation(self):\n        \"\"\"\n        Test that returning a non-zero value stops the operation in progress.\n        \"\"\"\n        con = sqlite.connect(\":memory:\")\n        def progress():\n            return 1\n        con.set_progress_handler(progress, 1)\n        curs = con.cursor()\n        self.assertRaises(\n            sqlite.OperationalError,\n            curs.execute,\n            \"create table bar (a, b)\")\n\n    def test_clear_handler(self):\n        \"\"\"\n        Test that setting the progress handler to None clears the previously set handler.\n        \"\"\"\n        con = sqlite.connect(\":memory:\")\n        action = 0\n        def progress():\n            nonlocal action\n            action = 1\n            return 0\n        con.set_progress_handler(progress, 1)\n        con.set_progress_handler(None, 1)\n        con.execute(\"select 1 union select 2 union select 3\").fetchall()\n        self.assertEqual(action, 0, \"progress handler was not cleared\")\n\n    @with_tracebacks(ZeroDivisionError, name=\"bad_progress\")\n    def test_error_in_progress_handler(self):\n        con = sqlite.connect(\":memory:\")\n        def bad_progress():\n            1 / 0\n        con.set_progress_handler(bad_progress, 1)\n        with self.assertRaises(sqlite.OperationalError):\n            con.execute(\"\"\"\n                create table foo(a, b)\n                \"\"\")\n\n    @with_tracebacks(ZeroDivisionError, name=\"bad_progress\")\n    def test_error_in_progress_handler_result(self):\n        con = sqlite.connect(\":memory:\")\n        class BadBool:\n            def __bool__(self):\n                1 / 0\n        def bad_progress():\n            return BadBool()\n        con.set_progress_handler(bad_progress, 1)\n        with self.assertRaises(sqlite.OperationalError):\n            con.execute(\"\"\"\n                create table foo(a, b)\n                \"\"\")", "\n\nclass TraceCallbackTests(unittest.TestCase):\n    @contextlib.contextmanager\n    def check_stmt_trace(self, cx, expected):\n        try:\n            traced = []\n            cx.set_trace_callback(lambda stmt: traced.append(stmt))\n            yield\n        finally:\n            self.assertEqual(traced, expected)\n            cx.set_trace_callback(None)\n\n    def test_trace_callback_used(self):\n        \"\"\"\n        Test that the trace callback is invoked once it is set.\n        \"\"\"\n        con = sqlite.connect(\":memory:\")\n        traced_statements = []\n        def trace(statement):\n            traced_statements.append(statement)\n        con.set_trace_callback(trace)\n        con.execute(\"create table foo(a, b)\")\n        self.assertTrue(traced_statements)\n        self.assertTrue(any(\"create table foo\" in stmt for stmt in traced_statements))\n\n    def test_clear_trace_callback(self):\n        \"\"\"\n        Test that setting the trace callback to None clears the previously set callback.\n        \"\"\"\n        con = sqlite.connect(\":memory:\")\n        traced_statements = []\n        def trace(statement):\n            traced_statements.append(statement)\n        con.set_trace_callback(trace)\n        con.set_trace_callback(None)\n        con.execute(\"create table foo(a, b)\")\n        self.assertFalse(traced_statements, \"trace callback was not cleared\")\n\n    def test_unicode_content(self):\n        \"\"\"\n        Test that the statement can contain unicode literals.\n        \"\"\"\n        unicode_value = '\\xf6\\xe4\\xfc\\xd6\\xc4\\xdc\\xdf\\u20ac'\n        con = sqlite.connect(\":memory:\")\n        traced_statements = []\n        def trace(statement):\n            traced_statements.append(statement)\n        con.set_trace_callback(trace)\n        con.execute(\"create table foo(x)\")\n        con.execute(\"insert into foo(x) values ('%s')\" % unicode_value)\n        con.commit()\n        self.assertTrue(any(unicode_value in stmt for stmt in traced_statements),\n                        \"Unicode data %s garbled in trace callback: %s\"\n                        % (ascii(unicode_value), ', '.join(map(ascii, traced_statements))))\n\n    def test_trace_callback_content(self):\n        # set_trace_callback() shouldn't produce duplicate content (bpo-26187)\n        traced_statements = []\n        def trace(statement):\n            traced_statements.append(statement)\n\n        queries = [\"create table foo(x)\",\n                   \"insert into foo(x) values(1)\"]\n        self.addCleanup(unlink, TESTFN)\n        con1 = sqlite.connect(TESTFN, isolation_level=None)\n        con2 = sqlite.connect(TESTFN)\n        try:\n            con1.set_trace_callback(trace)\n            cur = con1.cursor()\n            cur.execute(queries[0])\n            con2.execute(\"create table bar(x)\")\n            cur.execute(queries[1])\n        finally:\n            con1.close()\n            con2.close()\n        self.assertEqual(traced_statements, queries)\n\n    @unittest.skip(\"libsql_client doesn't support expanded sql\")\n    def test_trace_expanded_sql(self):\n        expected = [\n            \"create table t(t)\",\n            \"BEGIN \",\n            \"insert into t values(0)\",\n            \"insert into t values(1)\",\n            \"insert into t values(2)\",\n            \"COMMIT\",\n        ]\n        with memory_database() as cx, self.check_stmt_trace(cx, expected):\n            with cx:\n                cx.execute(\"create table t(t)\")\n                cx.executemany(\"insert into t values(?)\", ((v,) for v in range(3)))\n\n    @unittest.skip(\"libsql_client doesn't support expanded sql\")\n    @with_tracebacks(\n        sqlite.DataError,\n        regex=\"Expanded SQL string exceeds the maximum string length\"\n    )\n    def test_trace_too_much_expanded_sql(self):\n        # If the expanded string is too large, we'll fall back to the\n        # unexpanded SQL statement (for SQLite 3.14.0 and newer).\n        # The resulting string length is limited by the runtime limit\n        # SQLITE_LIMIT_LENGTH.\n        template = \"select 1 as a where a=\"\n        category = sqlite.SQLITE_LIMIT_LENGTH\n        with memory_database() as cx, cx_limit(cx, category=category) as lim:\n            ok_param = \"a\"\n            bad_param = \"a\" * lim\n\n            unexpanded_query = template + \"?\"\n            expected = [unexpanded_query]\n            if sqlite.sqlite_version_info < (3, 14, 0):\n                expected = []\n            with self.check_stmt_trace(cx, expected):\n                cx.execute(unexpanded_query, (bad_param,))\n\n            expanded_query = f\"{template}'{ok_param}'\"\n            with self.check_stmt_trace(cx, [expanded_query]):\n                cx.execute(unexpanded_query, (ok_param,))\n\n    @with_tracebacks(ZeroDivisionError, regex=\"division by zero\")\n    def test_trace_bad_handler(self):\n        with memory_database() as cx:\n            cx.set_trace_callback(lambda stmt: 5/0)\n            cx.execute(\"select 1\")", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/dbapi2/test_dbapi.py", "chunked_list": ["# pysqlite2/test/dbapi.py: tests for DB-API compliance\n#\n# Copyright (C) 2004-2010 Gerhard H\u00e4ring <gh@ghaering.de>\n#\n# This file is part of pysqlite.\n#\n# This software is provided 'as-is', without any express or implied\n# warranty.  In no event will the authors be held liable for any damages\n# arising from the use of this software.\n#", "# arising from the use of this software.\n#\n# Permission is granted to anyone to use this software for any purpose,\n# including commercial applications, and to alter it and redistribute it\n# freely, subject to the following restrictions:\n#\n# 1. The origin of this software must not be misrepresented; you must not\n#    claim that you wrote the original software. If you use this software\n#    in a product, an acknowledgment in the product documentation would be\n#    appreciated but is not required.", "#    in a product, an acknowledgment in the product documentation would be\n#    appreciated but is not required.\n# 2. Altered source versions must be plainly marked as such, and must not be\n#    misrepresented as being the original software.\n# 3. This notice may not be removed or altered from any source distribution.\n\nimport contextlib\nimport os\nfrom . import libsql_client_helpers as sqlite\nimport subprocess", "from . import libsql_client_helpers as sqlite\nimport subprocess\nimport sys\nimport threading\nimport unittest\nimport urllib.parse\n\nfrom test.support import (\n    SHORT_TIMEOUT, bigmemtest, check_disallow_instantiation, requires_subprocess,\n    is_emscripten, is_wasi", "    SHORT_TIMEOUT, bigmemtest, check_disallow_instantiation, requires_subprocess,\n    is_emscripten, is_wasi\n)\nfrom test.support import threading_helper\nfrom _testcapi import INT_MAX, ULLONG_MAX\nfrom os import SEEK_SET, SEEK_CUR, SEEK_END\nfrom test.support.os_helper import TESTFN, TESTFN_UNDECODABLE, unlink, temp_dir, FakePath\n\n\n# Helper for temporary memory databases\ndef memory_database(*args, **kwargs):\n    cx = sqlite.connect(\":memory:\", *args, **kwargs)\n    return contextlib.closing(cx)", "\n# Helper for temporary memory databases\ndef memory_database(*args, **kwargs):\n    cx = sqlite.connect(\":memory:\", *args, **kwargs)\n    return contextlib.closing(cx)\n\n\n# Temporarily limit a database connection parameter\n@contextlib.contextmanager\ndef cx_limit(cx, category=sqlite.SQLITE_LIMIT_SQL_LENGTH, limit=128):\n    try:\n        _prev = cx.setlimit(category, limit)\n        yield limit\n    finally:\n        cx.setlimit(category, _prev)", "@contextlib.contextmanager\ndef cx_limit(cx, category=sqlite.SQLITE_LIMIT_SQL_LENGTH, limit=128):\n    try:\n        _prev = cx.setlimit(category, limit)\n        yield limit\n    finally:\n        cx.setlimit(category, _prev)\n\n\nclass ModuleTests(unittest.TestCase):\n    def test_api_level(self):\n        self.assertEqual(sqlite.apilevel, \"2.0\",\n                         \"apilevel is %s, should be 2.0\" % sqlite.apilevel)\n\n    def test_thread_safety(self):\n        self.assertIn(sqlite.threadsafety, {0, 1, 3},\n                      \"threadsafety is %d, should be 0, 1 or 3\" %\n                      sqlite.threadsafety)\n\n    def test_param_style(self):\n        self.assertEqual(sqlite.paramstyle, \"qmark\",\n                         \"paramstyle is '%s', should be 'qmark'\" %\n                         sqlite.paramstyle)\n\n    def test_warning(self):\n        self.assertTrue(issubclass(sqlite.Warning, Exception),\n                     \"Warning is not a subclass of Exception\")\n\n    def test_error(self):\n        self.assertTrue(issubclass(sqlite.Error, Exception),\n                        \"Error is not a subclass of Exception\")\n\n    def test_interface_error(self):\n        self.assertTrue(issubclass(sqlite.InterfaceError, sqlite.Error),\n                        \"InterfaceError is not a subclass of Error\")\n\n    def test_database_error(self):\n        self.assertTrue(issubclass(sqlite.DatabaseError, sqlite.Error),\n                        \"DatabaseError is not a subclass of Error\")\n\n    def test_data_error(self):\n        self.assertTrue(issubclass(sqlite.DataError, sqlite.DatabaseError),\n                        \"DataError is not a subclass of DatabaseError\")\n\n    def test_operational_error(self):\n        self.assertTrue(issubclass(sqlite.OperationalError, sqlite.DatabaseError),\n                        \"OperationalError is not a subclass of DatabaseError\")\n\n    def test_integrity_error(self):\n        self.assertTrue(issubclass(sqlite.IntegrityError, sqlite.DatabaseError),\n                        \"IntegrityError is not a subclass of DatabaseError\")\n\n    def test_internal_error(self):\n        self.assertTrue(issubclass(sqlite.InternalError, sqlite.DatabaseError),\n                        \"InternalError is not a subclass of DatabaseError\")\n\n    def test_programming_error(self):\n        self.assertTrue(issubclass(sqlite.ProgrammingError, sqlite.DatabaseError),\n                        \"ProgrammingError is not a subclass of DatabaseError\")\n\n    def test_not_supported_error(self):\n        self.assertTrue(issubclass(sqlite.NotSupportedError,\n                                   sqlite.DatabaseError),\n                        \"NotSupportedError is not a subclass of DatabaseError\")\n\n    def test_module_constants(self):\n        consts = [\n            \"SQLITE_ABORT\",\n            \"SQLITE_ALTER_TABLE\",\n            \"SQLITE_ANALYZE\",\n            \"SQLITE_ATTACH\",\n            \"SQLITE_AUTH\",\n            \"SQLITE_BUSY\",\n            \"SQLITE_CANTOPEN\",\n            \"SQLITE_CONSTRAINT\",\n            \"SQLITE_CORRUPT\",\n            \"SQLITE_CREATE_INDEX\",\n            \"SQLITE_CREATE_TABLE\",\n            \"SQLITE_CREATE_TEMP_INDEX\",\n            \"SQLITE_CREATE_TEMP_TABLE\",\n            \"SQLITE_CREATE_TEMP_TRIGGER\",\n            \"SQLITE_CREATE_TEMP_VIEW\",\n            \"SQLITE_CREATE_TRIGGER\",\n            \"SQLITE_CREATE_VIEW\",\n            \"SQLITE_CREATE_VTABLE\",\n            \"SQLITE_DELETE\",\n            \"SQLITE_DENY\",\n            \"SQLITE_DETACH\",\n            \"SQLITE_DONE\",\n            \"SQLITE_DROP_INDEX\",\n            \"SQLITE_DROP_TABLE\",\n            \"SQLITE_DROP_TEMP_INDEX\",\n            \"SQLITE_DROP_TEMP_TABLE\",\n            \"SQLITE_DROP_TEMP_TRIGGER\",\n            \"SQLITE_DROP_TEMP_VIEW\",\n            \"SQLITE_DROP_TRIGGER\",\n            \"SQLITE_DROP_VIEW\",\n            \"SQLITE_DROP_VTABLE\",\n            \"SQLITE_EMPTY\",\n            \"SQLITE_ERROR\",\n            \"SQLITE_FORMAT\",\n            \"SQLITE_FULL\",\n            \"SQLITE_FUNCTION\",\n            \"SQLITE_IGNORE\",\n            \"SQLITE_INSERT\",\n            \"SQLITE_INTERNAL\",\n            \"SQLITE_INTERRUPT\",\n            \"SQLITE_IOERR\",\n            \"SQLITE_LOCKED\",\n            \"SQLITE_MISMATCH\",\n            \"SQLITE_MISUSE\",\n            \"SQLITE_NOLFS\",\n            \"SQLITE_NOMEM\",\n            \"SQLITE_NOTADB\",\n            \"SQLITE_NOTFOUND\",\n            \"SQLITE_OK\",\n            \"SQLITE_PERM\",\n            \"SQLITE_PRAGMA\",\n            \"SQLITE_PROTOCOL\",\n            \"SQLITE_RANGE\",\n            \"SQLITE_READ\",\n            \"SQLITE_READONLY\",\n            \"SQLITE_REINDEX\",\n            \"SQLITE_ROW\",\n            \"SQLITE_SAVEPOINT\",\n            \"SQLITE_SCHEMA\",\n            \"SQLITE_SELECT\",\n            \"SQLITE_TOOBIG\",\n            \"SQLITE_TRANSACTION\",\n            \"SQLITE_UPDATE\",\n            # Run-time limit categories\n            \"SQLITE_LIMIT_LENGTH\",\n            \"SQLITE_LIMIT_SQL_LENGTH\",\n            \"SQLITE_LIMIT_COLUMN\",\n            \"SQLITE_LIMIT_EXPR_DEPTH\",\n            \"SQLITE_LIMIT_COMPOUND_SELECT\",\n            \"SQLITE_LIMIT_VDBE_OP\",\n            \"SQLITE_LIMIT_FUNCTION_ARG\",\n            \"SQLITE_LIMIT_ATTACHED\",\n            \"SQLITE_LIMIT_LIKE_PATTERN_LENGTH\",\n            \"SQLITE_LIMIT_VARIABLE_NUMBER\",\n            \"SQLITE_LIMIT_TRIGGER_DEPTH\",\n        ]\n        if sqlite.sqlite_version_info >= (3, 7, 17):\n            consts += [\"SQLITE_NOTICE\", \"SQLITE_WARNING\"]\n        if sqlite.sqlite_version_info >= (3, 8, 3):\n            consts.append(\"SQLITE_RECURSIVE\")\n        if sqlite.sqlite_version_info >= (3, 8, 7):\n            consts.append(\"SQLITE_LIMIT_WORKER_THREADS\")\n        consts += [\"PARSE_DECLTYPES\", \"PARSE_COLNAMES\"]\n        # Extended result codes\n        consts += [\n            \"SQLITE_ABORT_ROLLBACK\",\n            \"SQLITE_BUSY_RECOVERY\",\n            \"SQLITE_CANTOPEN_FULLPATH\",\n            \"SQLITE_CANTOPEN_ISDIR\",\n            \"SQLITE_CANTOPEN_NOTEMPDIR\",\n            \"SQLITE_CORRUPT_VTAB\",\n            \"SQLITE_IOERR_ACCESS\",\n            \"SQLITE_IOERR_BLOCKED\",\n            \"SQLITE_IOERR_CHECKRESERVEDLOCK\",\n            \"SQLITE_IOERR_CLOSE\",\n            \"SQLITE_IOERR_DELETE\",\n            \"SQLITE_IOERR_DELETE_NOENT\",\n            \"SQLITE_IOERR_DIR_CLOSE\",\n            \"SQLITE_IOERR_DIR_FSYNC\",\n            \"SQLITE_IOERR_FSTAT\",\n            \"SQLITE_IOERR_FSYNC\",\n            \"SQLITE_IOERR_LOCK\",\n            \"SQLITE_IOERR_NOMEM\",\n            \"SQLITE_IOERR_RDLOCK\",\n            \"SQLITE_IOERR_READ\",\n            \"SQLITE_IOERR_SEEK\",\n            \"SQLITE_IOERR_SHMLOCK\",\n            \"SQLITE_IOERR_SHMMAP\",\n            \"SQLITE_IOERR_SHMOPEN\",\n            \"SQLITE_IOERR_SHMSIZE\",\n            \"SQLITE_IOERR_SHORT_READ\",\n            \"SQLITE_IOERR_TRUNCATE\",\n            \"SQLITE_IOERR_UNLOCK\",\n            \"SQLITE_IOERR_WRITE\",\n            \"SQLITE_LOCKED_SHAREDCACHE\",\n            \"SQLITE_READONLY_CANTLOCK\",\n            \"SQLITE_READONLY_RECOVERY\",\n        ]\n        if sqlite.sqlite_version_info >= (3, 7, 16):\n            consts += [\n                \"SQLITE_CONSTRAINT_CHECK\",\n                \"SQLITE_CONSTRAINT_COMMITHOOK\",\n                \"SQLITE_CONSTRAINT_FOREIGNKEY\",\n                \"SQLITE_CONSTRAINT_FUNCTION\",\n                \"SQLITE_CONSTRAINT_NOTNULL\",\n                \"SQLITE_CONSTRAINT_PRIMARYKEY\",\n                \"SQLITE_CONSTRAINT_TRIGGER\",\n                \"SQLITE_CONSTRAINT_UNIQUE\",\n                \"SQLITE_CONSTRAINT_VTAB\",\n                \"SQLITE_READONLY_ROLLBACK\",\n            ]\n        if sqlite.sqlite_version_info >= (3, 7, 17):\n            consts += [\n                \"SQLITE_IOERR_MMAP\",\n                \"SQLITE_NOTICE_RECOVER_ROLLBACK\",\n                \"SQLITE_NOTICE_RECOVER_WAL\",\n            ]\n        if sqlite.sqlite_version_info >= (3, 8, 0):\n            consts += [\n                \"SQLITE_BUSY_SNAPSHOT\",\n                \"SQLITE_IOERR_GETTEMPPATH\",\n                \"SQLITE_WARNING_AUTOINDEX\",\n            ]\n        if sqlite.sqlite_version_info >= (3, 8, 1):\n            consts += [\"SQLITE_CANTOPEN_CONVPATH\", \"SQLITE_IOERR_CONVPATH\"]\n        if sqlite.sqlite_version_info >= (3, 8, 2):\n            consts.append(\"SQLITE_CONSTRAINT_ROWID\")\n        if sqlite.sqlite_version_info >= (3, 8, 3):\n            consts.append(\"SQLITE_READONLY_DBMOVED\")\n        if sqlite.sqlite_version_info >= (3, 8, 7):\n            consts.append(\"SQLITE_AUTH_USER\")\n        if sqlite.sqlite_version_info >= (3, 9, 0):\n            consts.append(\"SQLITE_IOERR_VNODE\")\n        if sqlite.sqlite_version_info >= (3, 10, 0):\n            consts.append(\"SQLITE_IOERR_AUTH\")\n        if sqlite.sqlite_version_info >= (3, 14, 1):\n            consts.append(\"SQLITE_OK_LOAD_PERMANENTLY\")\n        if sqlite.sqlite_version_info >= (3, 21, 0):\n            consts += [\n                \"SQLITE_IOERR_BEGIN_ATOMIC\",\n                \"SQLITE_IOERR_COMMIT_ATOMIC\",\n                \"SQLITE_IOERR_ROLLBACK_ATOMIC\",\n            ]\n        if sqlite.sqlite_version_info >= (3, 22, 0):\n            consts += [\n                \"SQLITE_ERROR_MISSING_COLLSEQ\",\n                \"SQLITE_ERROR_RETRY\",\n                \"SQLITE_READONLY_CANTINIT\",\n                \"SQLITE_READONLY_DIRECTORY\",\n            ]\n        if sqlite.sqlite_version_info >= (3, 24, 0):\n            consts += [\"SQLITE_CORRUPT_SEQUENCE\", \"SQLITE_LOCKED_VTAB\"]\n        if sqlite.sqlite_version_info >= (3, 25, 0):\n            consts += [\"SQLITE_CANTOPEN_DIRTYWAL\", \"SQLITE_ERROR_SNAPSHOT\"]\n        if sqlite.sqlite_version_info >= (3, 31, 0):\n            consts += [\n                \"SQLITE_CANTOPEN_SYMLINK\",\n                \"SQLITE_CONSTRAINT_PINNED\",\n                \"SQLITE_OK_SYMLINK\",\n            ]\n        if sqlite.sqlite_version_info >= (3, 32, 0):\n            consts += [\n                \"SQLITE_BUSY_TIMEOUT\",\n                \"SQLITE_CORRUPT_INDEX\",\n                \"SQLITE_IOERR_DATA\",\n            ]\n        if sqlite.sqlite_version_info >= (3, 34, 0):\n            consts.append(\"SQLITE_IOERR_CORRUPTFS\")\n        for const in consts:\n            with self.subTest(const=const):\n                self.assertTrue(hasattr(sqlite, const))\n\n    def test_error_code_on_exception(self):\n        err_msg = \"Cannot connect to host\"\n        if sys.platform.startswith(\"win\"):\n            err_code = sqlite.SQLITE_CANTOPEN_ISDIR\n        else:\n            err_code = sqlite.SQLITE_CANTOPEN\n\n        with temp_dir() as db:\n            with self.assertRaisesRegex(sqlite.Error, err_msg) as cm:\n                sqlite.connect(db)\n            e = cm.exception\n            self.assertEqual(e.sqlite_errorcode, err_code)\n            self.assertTrue(e.sqlite_errorname.startswith(\"SQLITE_CANTOPEN\"))\n\n    @unittest.skip(\"sqld is not sending this error\")\n    @unittest.skipIf(sqlite.sqlite_version_info <= (3, 7, 16),\n                     \"Requires SQLite 3.7.16 or newer\")\n    def test_extended_error_code_on_exception(self):\n        with memory_database() as con:\n            with con:\n                con.execute(\"create table t(t integer check(t > 0))\")\n            errmsg = \"constraint failed\"\n            with self.assertRaisesRegex(sqlite.IntegrityError, errmsg) as cm:\n                con.execute(\"insert into t values(-1)\")\n            exc = cm.exception\n            self.assertEqual(exc.sqlite_errorcode,\n                             sqlite.SQLITE_CONSTRAINT_CHECK)\n            self.assertEqual(exc.sqlite_errorname, \"SQLITE_CONSTRAINT_CHECK\")\n\n    @unittest.skip(\"not supported by libsql_client\")\n    # sqlite3_enable_shared_cache() is deprecated on macOS and calling it may raise\n    # OperationalError on some buildbots.\n    @unittest.skipIf(sys.platform == \"darwin\", \"shared cache is deprecated on macOS\")\n    def test_shared_cache_deprecated(self):\n        for enable in (True, False):\n            with self.assertWarns(DeprecationWarning) as cm:\n                sqlite.enable_shared_cache(enable)\n            self.assertIn(\"dbapi.py\", cm.filename)\n\n    def test_disallow_instantiation(self):\n        cx = sqlite.connect(\":memory:\")\n        check_disallow_instantiation(self, type(cx(\"select 1\")))\n        check_disallow_instantiation(self, sqlite.Blob)\n\n    def test_complete_statement(self):\n        self.assertFalse(sqlite.complete_statement(\"select t\"))\n        self.assertTrue(sqlite.complete_statement(\"create table t(t);\"))", "\nclass ModuleTests(unittest.TestCase):\n    def test_api_level(self):\n        self.assertEqual(sqlite.apilevel, \"2.0\",\n                         \"apilevel is %s, should be 2.0\" % sqlite.apilevel)\n\n    def test_thread_safety(self):\n        self.assertIn(sqlite.threadsafety, {0, 1, 3},\n                      \"threadsafety is %d, should be 0, 1 or 3\" %\n                      sqlite.threadsafety)\n\n    def test_param_style(self):\n        self.assertEqual(sqlite.paramstyle, \"qmark\",\n                         \"paramstyle is '%s', should be 'qmark'\" %\n                         sqlite.paramstyle)\n\n    def test_warning(self):\n        self.assertTrue(issubclass(sqlite.Warning, Exception),\n                     \"Warning is not a subclass of Exception\")\n\n    def test_error(self):\n        self.assertTrue(issubclass(sqlite.Error, Exception),\n                        \"Error is not a subclass of Exception\")\n\n    def test_interface_error(self):\n        self.assertTrue(issubclass(sqlite.InterfaceError, sqlite.Error),\n                        \"InterfaceError is not a subclass of Error\")\n\n    def test_database_error(self):\n        self.assertTrue(issubclass(sqlite.DatabaseError, sqlite.Error),\n                        \"DatabaseError is not a subclass of Error\")\n\n    def test_data_error(self):\n        self.assertTrue(issubclass(sqlite.DataError, sqlite.DatabaseError),\n                        \"DataError is not a subclass of DatabaseError\")\n\n    def test_operational_error(self):\n        self.assertTrue(issubclass(sqlite.OperationalError, sqlite.DatabaseError),\n                        \"OperationalError is not a subclass of DatabaseError\")\n\n    def test_integrity_error(self):\n        self.assertTrue(issubclass(sqlite.IntegrityError, sqlite.DatabaseError),\n                        \"IntegrityError is not a subclass of DatabaseError\")\n\n    def test_internal_error(self):\n        self.assertTrue(issubclass(sqlite.InternalError, sqlite.DatabaseError),\n                        \"InternalError is not a subclass of DatabaseError\")\n\n    def test_programming_error(self):\n        self.assertTrue(issubclass(sqlite.ProgrammingError, sqlite.DatabaseError),\n                        \"ProgrammingError is not a subclass of DatabaseError\")\n\n    def test_not_supported_error(self):\n        self.assertTrue(issubclass(sqlite.NotSupportedError,\n                                   sqlite.DatabaseError),\n                        \"NotSupportedError is not a subclass of DatabaseError\")\n\n    def test_module_constants(self):\n        consts = [\n            \"SQLITE_ABORT\",\n            \"SQLITE_ALTER_TABLE\",\n            \"SQLITE_ANALYZE\",\n            \"SQLITE_ATTACH\",\n            \"SQLITE_AUTH\",\n            \"SQLITE_BUSY\",\n            \"SQLITE_CANTOPEN\",\n            \"SQLITE_CONSTRAINT\",\n            \"SQLITE_CORRUPT\",\n            \"SQLITE_CREATE_INDEX\",\n            \"SQLITE_CREATE_TABLE\",\n            \"SQLITE_CREATE_TEMP_INDEX\",\n            \"SQLITE_CREATE_TEMP_TABLE\",\n            \"SQLITE_CREATE_TEMP_TRIGGER\",\n            \"SQLITE_CREATE_TEMP_VIEW\",\n            \"SQLITE_CREATE_TRIGGER\",\n            \"SQLITE_CREATE_VIEW\",\n            \"SQLITE_CREATE_VTABLE\",\n            \"SQLITE_DELETE\",\n            \"SQLITE_DENY\",\n            \"SQLITE_DETACH\",\n            \"SQLITE_DONE\",\n            \"SQLITE_DROP_INDEX\",\n            \"SQLITE_DROP_TABLE\",\n            \"SQLITE_DROP_TEMP_INDEX\",\n            \"SQLITE_DROP_TEMP_TABLE\",\n            \"SQLITE_DROP_TEMP_TRIGGER\",\n            \"SQLITE_DROP_TEMP_VIEW\",\n            \"SQLITE_DROP_TRIGGER\",\n            \"SQLITE_DROP_VIEW\",\n            \"SQLITE_DROP_VTABLE\",\n            \"SQLITE_EMPTY\",\n            \"SQLITE_ERROR\",\n            \"SQLITE_FORMAT\",\n            \"SQLITE_FULL\",\n            \"SQLITE_FUNCTION\",\n            \"SQLITE_IGNORE\",\n            \"SQLITE_INSERT\",\n            \"SQLITE_INTERNAL\",\n            \"SQLITE_INTERRUPT\",\n            \"SQLITE_IOERR\",\n            \"SQLITE_LOCKED\",\n            \"SQLITE_MISMATCH\",\n            \"SQLITE_MISUSE\",\n            \"SQLITE_NOLFS\",\n            \"SQLITE_NOMEM\",\n            \"SQLITE_NOTADB\",\n            \"SQLITE_NOTFOUND\",\n            \"SQLITE_OK\",\n            \"SQLITE_PERM\",\n            \"SQLITE_PRAGMA\",\n            \"SQLITE_PROTOCOL\",\n            \"SQLITE_RANGE\",\n            \"SQLITE_READ\",\n            \"SQLITE_READONLY\",\n            \"SQLITE_REINDEX\",\n            \"SQLITE_ROW\",\n            \"SQLITE_SAVEPOINT\",\n            \"SQLITE_SCHEMA\",\n            \"SQLITE_SELECT\",\n            \"SQLITE_TOOBIG\",\n            \"SQLITE_TRANSACTION\",\n            \"SQLITE_UPDATE\",\n            # Run-time limit categories\n            \"SQLITE_LIMIT_LENGTH\",\n            \"SQLITE_LIMIT_SQL_LENGTH\",\n            \"SQLITE_LIMIT_COLUMN\",\n            \"SQLITE_LIMIT_EXPR_DEPTH\",\n            \"SQLITE_LIMIT_COMPOUND_SELECT\",\n            \"SQLITE_LIMIT_VDBE_OP\",\n            \"SQLITE_LIMIT_FUNCTION_ARG\",\n            \"SQLITE_LIMIT_ATTACHED\",\n            \"SQLITE_LIMIT_LIKE_PATTERN_LENGTH\",\n            \"SQLITE_LIMIT_VARIABLE_NUMBER\",\n            \"SQLITE_LIMIT_TRIGGER_DEPTH\",\n        ]\n        if sqlite.sqlite_version_info >= (3, 7, 17):\n            consts += [\"SQLITE_NOTICE\", \"SQLITE_WARNING\"]\n        if sqlite.sqlite_version_info >= (3, 8, 3):\n            consts.append(\"SQLITE_RECURSIVE\")\n        if sqlite.sqlite_version_info >= (3, 8, 7):\n            consts.append(\"SQLITE_LIMIT_WORKER_THREADS\")\n        consts += [\"PARSE_DECLTYPES\", \"PARSE_COLNAMES\"]\n        # Extended result codes\n        consts += [\n            \"SQLITE_ABORT_ROLLBACK\",\n            \"SQLITE_BUSY_RECOVERY\",\n            \"SQLITE_CANTOPEN_FULLPATH\",\n            \"SQLITE_CANTOPEN_ISDIR\",\n            \"SQLITE_CANTOPEN_NOTEMPDIR\",\n            \"SQLITE_CORRUPT_VTAB\",\n            \"SQLITE_IOERR_ACCESS\",\n            \"SQLITE_IOERR_BLOCKED\",\n            \"SQLITE_IOERR_CHECKRESERVEDLOCK\",\n            \"SQLITE_IOERR_CLOSE\",\n            \"SQLITE_IOERR_DELETE\",\n            \"SQLITE_IOERR_DELETE_NOENT\",\n            \"SQLITE_IOERR_DIR_CLOSE\",\n            \"SQLITE_IOERR_DIR_FSYNC\",\n            \"SQLITE_IOERR_FSTAT\",\n            \"SQLITE_IOERR_FSYNC\",\n            \"SQLITE_IOERR_LOCK\",\n            \"SQLITE_IOERR_NOMEM\",\n            \"SQLITE_IOERR_RDLOCK\",\n            \"SQLITE_IOERR_READ\",\n            \"SQLITE_IOERR_SEEK\",\n            \"SQLITE_IOERR_SHMLOCK\",\n            \"SQLITE_IOERR_SHMMAP\",\n            \"SQLITE_IOERR_SHMOPEN\",\n            \"SQLITE_IOERR_SHMSIZE\",\n            \"SQLITE_IOERR_SHORT_READ\",\n            \"SQLITE_IOERR_TRUNCATE\",\n            \"SQLITE_IOERR_UNLOCK\",\n            \"SQLITE_IOERR_WRITE\",\n            \"SQLITE_LOCKED_SHAREDCACHE\",\n            \"SQLITE_READONLY_CANTLOCK\",\n            \"SQLITE_READONLY_RECOVERY\",\n        ]\n        if sqlite.sqlite_version_info >= (3, 7, 16):\n            consts += [\n                \"SQLITE_CONSTRAINT_CHECK\",\n                \"SQLITE_CONSTRAINT_COMMITHOOK\",\n                \"SQLITE_CONSTRAINT_FOREIGNKEY\",\n                \"SQLITE_CONSTRAINT_FUNCTION\",\n                \"SQLITE_CONSTRAINT_NOTNULL\",\n                \"SQLITE_CONSTRAINT_PRIMARYKEY\",\n                \"SQLITE_CONSTRAINT_TRIGGER\",\n                \"SQLITE_CONSTRAINT_UNIQUE\",\n                \"SQLITE_CONSTRAINT_VTAB\",\n                \"SQLITE_READONLY_ROLLBACK\",\n            ]\n        if sqlite.sqlite_version_info >= (3, 7, 17):\n            consts += [\n                \"SQLITE_IOERR_MMAP\",\n                \"SQLITE_NOTICE_RECOVER_ROLLBACK\",\n                \"SQLITE_NOTICE_RECOVER_WAL\",\n            ]\n        if sqlite.sqlite_version_info >= (3, 8, 0):\n            consts += [\n                \"SQLITE_BUSY_SNAPSHOT\",\n                \"SQLITE_IOERR_GETTEMPPATH\",\n                \"SQLITE_WARNING_AUTOINDEX\",\n            ]\n        if sqlite.sqlite_version_info >= (3, 8, 1):\n            consts += [\"SQLITE_CANTOPEN_CONVPATH\", \"SQLITE_IOERR_CONVPATH\"]\n        if sqlite.sqlite_version_info >= (3, 8, 2):\n            consts.append(\"SQLITE_CONSTRAINT_ROWID\")\n        if sqlite.sqlite_version_info >= (3, 8, 3):\n            consts.append(\"SQLITE_READONLY_DBMOVED\")\n        if sqlite.sqlite_version_info >= (3, 8, 7):\n            consts.append(\"SQLITE_AUTH_USER\")\n        if sqlite.sqlite_version_info >= (3, 9, 0):\n            consts.append(\"SQLITE_IOERR_VNODE\")\n        if sqlite.sqlite_version_info >= (3, 10, 0):\n            consts.append(\"SQLITE_IOERR_AUTH\")\n        if sqlite.sqlite_version_info >= (3, 14, 1):\n            consts.append(\"SQLITE_OK_LOAD_PERMANENTLY\")\n        if sqlite.sqlite_version_info >= (3, 21, 0):\n            consts += [\n                \"SQLITE_IOERR_BEGIN_ATOMIC\",\n                \"SQLITE_IOERR_COMMIT_ATOMIC\",\n                \"SQLITE_IOERR_ROLLBACK_ATOMIC\",\n            ]\n        if sqlite.sqlite_version_info >= (3, 22, 0):\n            consts += [\n                \"SQLITE_ERROR_MISSING_COLLSEQ\",\n                \"SQLITE_ERROR_RETRY\",\n                \"SQLITE_READONLY_CANTINIT\",\n                \"SQLITE_READONLY_DIRECTORY\",\n            ]\n        if sqlite.sqlite_version_info >= (3, 24, 0):\n            consts += [\"SQLITE_CORRUPT_SEQUENCE\", \"SQLITE_LOCKED_VTAB\"]\n        if sqlite.sqlite_version_info >= (3, 25, 0):\n            consts += [\"SQLITE_CANTOPEN_DIRTYWAL\", \"SQLITE_ERROR_SNAPSHOT\"]\n        if sqlite.sqlite_version_info >= (3, 31, 0):\n            consts += [\n                \"SQLITE_CANTOPEN_SYMLINK\",\n                \"SQLITE_CONSTRAINT_PINNED\",\n                \"SQLITE_OK_SYMLINK\",\n            ]\n        if sqlite.sqlite_version_info >= (3, 32, 0):\n            consts += [\n                \"SQLITE_BUSY_TIMEOUT\",\n                \"SQLITE_CORRUPT_INDEX\",\n                \"SQLITE_IOERR_DATA\",\n            ]\n        if sqlite.sqlite_version_info >= (3, 34, 0):\n            consts.append(\"SQLITE_IOERR_CORRUPTFS\")\n        for const in consts:\n            with self.subTest(const=const):\n                self.assertTrue(hasattr(sqlite, const))\n\n    def test_error_code_on_exception(self):\n        err_msg = \"Cannot connect to host\"\n        if sys.platform.startswith(\"win\"):\n            err_code = sqlite.SQLITE_CANTOPEN_ISDIR\n        else:\n            err_code = sqlite.SQLITE_CANTOPEN\n\n        with temp_dir() as db:\n            with self.assertRaisesRegex(sqlite.Error, err_msg) as cm:\n                sqlite.connect(db)\n            e = cm.exception\n            self.assertEqual(e.sqlite_errorcode, err_code)\n            self.assertTrue(e.sqlite_errorname.startswith(\"SQLITE_CANTOPEN\"))\n\n    @unittest.skip(\"sqld is not sending this error\")\n    @unittest.skipIf(sqlite.sqlite_version_info <= (3, 7, 16),\n                     \"Requires SQLite 3.7.16 or newer\")\n    def test_extended_error_code_on_exception(self):\n        with memory_database() as con:\n            with con:\n                con.execute(\"create table t(t integer check(t > 0))\")\n            errmsg = \"constraint failed\"\n            with self.assertRaisesRegex(sqlite.IntegrityError, errmsg) as cm:\n                con.execute(\"insert into t values(-1)\")\n            exc = cm.exception\n            self.assertEqual(exc.sqlite_errorcode,\n                             sqlite.SQLITE_CONSTRAINT_CHECK)\n            self.assertEqual(exc.sqlite_errorname, \"SQLITE_CONSTRAINT_CHECK\")\n\n    @unittest.skip(\"not supported by libsql_client\")\n    # sqlite3_enable_shared_cache() is deprecated on macOS and calling it may raise\n    # OperationalError on some buildbots.\n    @unittest.skipIf(sys.platform == \"darwin\", \"shared cache is deprecated on macOS\")\n    def test_shared_cache_deprecated(self):\n        for enable in (True, False):\n            with self.assertWarns(DeprecationWarning) as cm:\n                sqlite.enable_shared_cache(enable)\n            self.assertIn(\"dbapi.py\", cm.filename)\n\n    def test_disallow_instantiation(self):\n        cx = sqlite.connect(\":memory:\")\n        check_disallow_instantiation(self, type(cx(\"select 1\")))\n        check_disallow_instantiation(self, sqlite.Blob)\n\n    def test_complete_statement(self):\n        self.assertFalse(sqlite.complete_statement(\"select t\"))\n        self.assertTrue(sqlite.complete_statement(\"create table t(t);\"))", "\n\n@unittest.skip(\"Not supported\")\nclass ConnectionTests(unittest.TestCase):\n\n    def setUp(self):\n        self.cx = sqlite.connect(\":memory:\")\n        cu = self.cx.cursor()\n        cu.execute(\"create table test(id integer primary key, name text)\")\n        cu.execute(\"insert into test(name) values (?)\", (\"foo\",))\n\n    def tearDown(self):\n        self.cx.close()\n\n    def test_commit(self):\n        self.cx.commit()\n\n    def test_commit_after_no_changes(self):\n        \"\"\"\n        A commit should also work when no changes were made to the database.\n        \"\"\"\n        self.cx.commit()\n        self.cx.commit()\n\n    def test_rollback(self):\n        self.cx.rollback()\n\n    def test_rollback_after_no_changes(self):\n        \"\"\"\n        A rollback should also work when no changes were made to the database.\n        \"\"\"\n        self.cx.rollback()\n        self.cx.rollback()\n\n    def test_cursor(self):\n        cu = self.cx.cursor()\n\n    def test_failed_open(self):\n        YOU_CANNOT_OPEN_THIS = \"/foo/bar/bla/23534/mydb.db\"\n        with self.assertRaises(sqlite.OperationalError):\n            sqlite.connect(YOU_CANNOT_OPEN_THIS)\n\n    def test_close(self):\n        self.cx.close()\n\n    def test_use_after_close(self):\n        sql = \"select 1\"\n        cu = self.cx.cursor()\n        res = cu.execute(sql)\n        self.cx.close()\n        self.assertRaises(sqlite.ProgrammingError, res.fetchall)\n        self.assertRaises(sqlite.ProgrammingError, cu.execute, sql)\n        self.assertRaises(sqlite.ProgrammingError, cu.executemany, sql, [])\n        self.assertRaises(sqlite.ProgrammingError, cu.executescript, sql)\n        self.assertRaises(sqlite.ProgrammingError, self.cx.execute, sql)\n        self.assertRaises(sqlite.ProgrammingError,\n                          self.cx.executemany, sql, [])\n        self.assertRaises(sqlite.ProgrammingError, self.cx.executescript, sql)\n        self.assertRaises(sqlite.ProgrammingError,\n                          self.cx.create_function, \"t\", 1, lambda x: x)\n        self.assertRaises(sqlite.ProgrammingError, self.cx.cursor)\n        with self.assertRaises(sqlite.ProgrammingError):\n            with self.cx:\n                pass\n\n    def test_exceptions(self):\n        # Optional DB-API extension.\n        self.assertEqual(self.cx.Warning, sqlite.Warning)\n        self.assertEqual(self.cx.Error, sqlite.Error)\n        self.assertEqual(self.cx.InterfaceError, sqlite.InterfaceError)\n        self.assertEqual(self.cx.DatabaseError, sqlite.DatabaseError)\n        self.assertEqual(self.cx.DataError, sqlite.DataError)\n        self.assertEqual(self.cx.OperationalError, sqlite.OperationalError)\n        self.assertEqual(self.cx.IntegrityError, sqlite.IntegrityError)\n        self.assertEqual(self.cx.InternalError, sqlite.InternalError)\n        self.assertEqual(self.cx.ProgrammingError, sqlite.ProgrammingError)\n        self.assertEqual(self.cx.NotSupportedError, sqlite.NotSupportedError)\n\n    def test_in_transaction(self):\n        # Can't use db from setUp because we want to test initial state.\n        cx = sqlite.connect(\":memory:\")\n        cu = cx.cursor()\n        self.assertEqual(cx.in_transaction, False)\n        cu.execute(\"create table transactiontest(id integer primary key, name text)\")\n        self.assertEqual(cx.in_transaction, False)\n        cu.execute(\"insert into transactiontest(name) values (?)\", (\"foo\",))\n        self.assertEqual(cx.in_transaction, True)\n        cu.execute(\"select name from transactiontest where name=?\", [\"foo\"])\n        row = cu.fetchone()\n        self.assertEqual(cx.in_transaction, True)\n        cx.commit()\n        self.assertEqual(cx.in_transaction, False)\n        cu.execute(\"select name from transactiontest where name=?\", [\"foo\"])\n        row = cu.fetchone()\n        self.assertEqual(cx.in_transaction, False)\n\n    def test_in_transaction_ro(self):\n        with self.assertRaises(AttributeError):\n            self.cx.in_transaction = True\n\n    def test_connection_exceptions(self):\n        exceptions = [\n            \"DataError\",\n            \"DatabaseError\",\n            \"Error\",\n            \"IntegrityError\",\n            \"InterfaceError\",\n            \"NotSupportedError\",\n            \"OperationalError\",\n            \"ProgrammingError\",\n            \"Warning\",\n        ]\n        for exc in exceptions:\n            with self.subTest(exc=exc):\n                self.assertTrue(hasattr(self.cx, exc))\n                self.assertIs(getattr(sqlite, exc), getattr(self.cx, exc))\n\n    def test_interrupt_on_closed_db(self):\n        cx = sqlite.connect(\":memory:\")\n        cx.close()\n        with self.assertRaises(sqlite.ProgrammingError):\n            cx.interrupt()\n\n    def test_interrupt(self):\n        self.assertIsNone(self.cx.interrupt())\n\n    def test_drop_unused_refs(self):\n        for n in range(500):\n            cu = self.cx.execute(f\"select {n}\")\n            self.assertEqual(cu.fetchone()[0], n)\n\n    def test_connection_limits(self):\n        category = sqlite.SQLITE_LIMIT_SQL_LENGTH\n        saved_limit = self.cx.getlimit(category)\n        try:\n            new_limit = 10\n            prev_limit = self.cx.setlimit(category, new_limit)\n            self.assertEqual(saved_limit, prev_limit)\n            self.assertEqual(self.cx.getlimit(category), new_limit)\n            msg = \"query string is too large\"\n            self.assertRaisesRegex(sqlite.DataError, msg,\n                                   self.cx.execute, \"select 1 as '16'\")\n        finally:  # restore saved limit\n            self.cx.setlimit(category, saved_limit)\n\n    def test_connection_bad_limit_category(self):\n        msg = \"'category' is out of bounds\"\n        cat = 1111\n        self.assertRaisesRegex(sqlite.ProgrammingError, msg,\n                               self.cx.getlimit, cat)\n        self.assertRaisesRegex(sqlite.ProgrammingError, msg,\n                               self.cx.setlimit, cat, 0)\n\n    def test_connection_init_bad_isolation_level(self):\n        msg = (\n            \"isolation_level string must be '', 'DEFERRED', 'IMMEDIATE', or \"\n            \"'EXCLUSIVE'\"\n        )\n        levels = (\n            \"BOGUS\",\n            \" \",\n            \"DEFERRE\",\n            \"IMMEDIAT\",\n            \"EXCLUSIV\",\n            \"DEFERREDS\",\n            \"IMMEDIATES\",\n            \"EXCLUSIVES\",\n        )\n        for level in levels:\n            with self.subTest(level=level):\n                with self.assertRaisesRegex(ValueError, msg):\n                    memory_database(isolation_level=level)\n                with memory_database() as cx:\n                    with self.assertRaisesRegex(ValueError, msg):\n                        cx.isolation_level = level\n                    # Check that the default level is not changed\n                    self.assertEqual(cx.isolation_level, \"\")\n\n    def test_connection_init_good_isolation_levels(self):\n        for level in (\"\", \"DEFERRED\", \"IMMEDIATE\", \"EXCLUSIVE\", None):\n            with self.subTest(level=level):\n                with memory_database(isolation_level=level) as cx:\n                    self.assertEqual(cx.isolation_level, level)\n                with memory_database() as cx:\n                    self.assertEqual(cx.isolation_level, \"\")\n                    cx.isolation_level = level\n                    self.assertEqual(cx.isolation_level, level)\n\n    def test_connection_reinit(self):\n        db = \":memory:\"\n        cx = sqlite.connect(db)\n        cx.text_factory = bytes\n        cx.row_factory = sqlite.Row\n        cu = cx.cursor()\n        cu.execute(\"create table foo (bar)\")\n        cu.executemany(\"insert into foo (bar) values (?)\",\n                       ((str(v),) for v in range(4)))\n        cu.execute(\"select bar from foo\")\n\n        rows = [r for r in cu.fetchmany(2)]\n        self.assertTrue(all(isinstance(r, sqlite.Row) for r in rows))\n        self.assertEqual([r[0] for r in rows], [b\"0\", b\"1\"])\n\n        cx.__init__(db)\n        cx.execute(\"create table foo (bar)\")\n        cx.executemany(\"insert into foo (bar) values (?)\",\n                       ((v,) for v in (\"a\", \"b\", \"c\", \"d\")))\n\n        # This uses the old database, old row factory, but new text factory\n        rows = [r for r in cu.fetchall()]\n        self.assertTrue(all(isinstance(r, sqlite.Row) for r in rows))\n        self.assertEqual([r[0] for r in rows], [\"2\", \"3\"])\n\n    def test_connection_bad_reinit(self):\n        cx = sqlite.connect(\":memory:\")\n        with cx:\n            cx.execute(\"create table t(t)\")\n        with temp_dir() as db:\n            self.assertRaisesRegex(sqlite.OperationalError,\n                                   \"unable to open database file\",\n                                   cx.__init__, db)\n            self.assertRaisesRegex(sqlite.ProgrammingError,\n                                   \"Base Connection.__init__ not called\",\n                                   cx.executemany, \"insert into t values(?)\",\n                                   ((v,) for v in range(3)))", "\n\n@unittest.skip(\"does not make sense with libsql_client-py\")\nclass UninitialisedConnectionTests(unittest.TestCase):\n    def setUp(self):\n        self.cx = sqlite.Connection.__new__(sqlite.Connection)\n\n    def test_uninit_operations(self):\n        funcs = (\n            lambda: self.cx.isolation_level,\n            lambda: self.cx.total_changes,\n            lambda: self.cx.in_transaction,\n            lambda: self.cx.iterdump(),\n            lambda: self.cx.cursor(),\n            lambda: self.cx.close(),\n        )\n        for func in funcs:\n            with self.subTest(func=func):\n                self.assertRaisesRegex(sqlite.ProgrammingError,\n                                       \"Base Connection.__init__ not called\",\n                                       func)", "\n\n@unittest.skip(\"Not supported\")\n@unittest.skipUnless(hasattr(sqlite.Connection, \"serialize\"),\n                     \"Needs SQLite serialize API\")\nclass SerializeTests(unittest.TestCase):\n    def test_serialize_deserialize(self):\n        with memory_database() as cx:\n            with cx:\n                cx.execute(\"create table t(t)\")\n            data = cx.serialize()\n\n            # Remove test table, verify that it was removed.\n            with cx:\n                cx.execute(\"drop table t\")\n            regex = \"no such table\"\n            with self.assertRaisesRegex(sqlite.OperationalError, regex):\n                cx.execute(\"select t from t\")\n\n            # Deserialize and verify that test table is restored.\n            cx.deserialize(data)\n            cx.execute(\"select t from t\")\n\n    def test_deserialize_wrong_args(self):\n        dataset = (\n            (BufferError, memoryview(b\"blob\")[::2]),\n            (TypeError, []),\n            (TypeError, 1),\n            (TypeError, None),\n        )\n        for exc, arg in dataset:\n            with self.subTest(exc=exc, arg=arg):\n                with memory_database() as cx:\n                    self.assertRaises(exc, cx.deserialize, arg)\n\n    def test_deserialize_corrupt_database(self):\n        with memory_database() as cx:\n            regex = \"file is not a database\"\n            with self.assertRaisesRegex(sqlite.DatabaseError, regex):\n                cx.deserialize(b\"\\0\\1\\3\")\n                # SQLite does not generate an error until you try to query the\n                # deserialized database.\n                cx.execute(\"create table fail(f)\")\n\n    @unittest.skip(\"Not supported\")\n    @unittest.skipUnless(sys.maxsize > 2**32, 'requires 64bit platform')\n    @bigmemtest(size=2**63, memuse=3, dry_run=False)\n    def test_deserialize_too_much_data_64bit(self):\n        with memory_database() as cx:\n            with self.assertRaisesRegex(OverflowError, \"'data' is too large\"):\n                cx.deserialize(b\"b\" * size)", "\n\nclass OpenTests(unittest.TestCase):\n    _sql = \"create table test(id integer)\"\n\n    def test_open_with_path_like_object(self):\n        \"\"\" Checks that we can successfully connect to a database using an object that\n            is PathLike, i.e. has __fspath__(). \"\"\"\n        path = FakePath(TESTFN)\n        self.addCleanup(unlink, path)\n        self.assertFalse(os.path.exists(path))\n        with contextlib.closing(sqlite.connect(path)) as cx:\n            self.assertTrue(os.path.exists(path))\n            cx.execute(self._sql)\n\n    @unittest.skipIf(sys.platform == \"win32\", \"skipped on Windows\")\n    @unittest.skipIf(sys.platform == \"darwin\", \"skipped on macOS\")\n    @unittest.skipIf(is_emscripten or is_wasi, \"not supported on Emscripten/WASI\")\n    @unittest.skipUnless(TESTFN_UNDECODABLE, \"only works if there are undecodable paths\")\n    def test_open_with_undecodable_path(self):\n        path = TESTFN_UNDECODABLE\n        self.addCleanup(unlink, path)\n        self.assertFalse(os.path.exists(path))\n        with contextlib.closing(sqlite.connect(path)) as cx:\n            self.assertTrue(os.path.exists(path))\n            cx.execute(self._sql)\n\n    def test_open_uri(self):\n        path = TESTFN\n        self.addCleanup(unlink, path)\n        uri = \"file:\" + urllib.parse.quote(os.fsencode(path))\n        self.assertFalse(os.path.exists(path))\n        with contextlib.closing(sqlite.connect(uri, uri=True)) as cx:\n            self.assertTrue(os.path.exists(path))\n            cx.execute(self._sql)\n\n    def test_open_unquoted_uri(self):\n        path = TESTFN\n        self.addCleanup(unlink, path)\n        uri = \"file:\" + path\n        self.assertFalse(os.path.exists(path))\n        with contextlib.closing(sqlite.connect(uri, uri=True)) as cx:\n            self.assertTrue(os.path.exists(path))\n            cx.execute(self._sql)\n\n    def test_open_uri_readonly(self):\n        path = TESTFN\n        self.addCleanup(unlink, path)\n        uri = \"file:\" + urllib.parse.quote(os.fsencode(path)) + \"?mode=ro\"\n        self.assertFalse(os.path.exists(path))\n        # Cannot create new DB\n        with self.assertRaises(sqlite.OperationalError):\n            sqlite.connect(uri, uri=True)\n        self.assertFalse(os.path.exists(path))\n        sqlite.connect(path).close()\n        self.assertTrue(os.path.exists(path))\n        # Cannot modify new DB\n        with contextlib.closing(sqlite.connect(uri, uri=True)) as cx:\n            with self.assertRaises(sqlite.OperationalError):\n                cx.execute(self._sql)\n\n    @unittest.skipIf(sys.platform == \"win32\", \"skipped on Windows\")\n    @unittest.skipIf(sys.platform == \"darwin\", \"skipped on macOS\")\n    @unittest.skipIf(is_emscripten or is_wasi, \"not supported on Emscripten/WASI\")\n    @unittest.skipUnless(TESTFN_UNDECODABLE, \"only works if there are undecodable paths\")\n    def test_open_undecodable_uri(self):\n        path = TESTFN_UNDECODABLE\n        self.addCleanup(unlink, path)\n        uri = \"file:\" + urllib.parse.quote(path)\n        self.assertFalse(os.path.exists(path))\n        with contextlib.closing(sqlite.connect(uri, uri=True)) as cx:\n            self.assertTrue(os.path.exists(path))\n            cx.execute(self._sql)\n\n    @unittest.skip(\"connecting to memory with ConnectionHrana is unsupported\")\n    def test_factory_database_arg(self):\n        def factory(database, *args, **kwargs):\n            nonlocal database_arg\n            database_arg = database\n            return sqlite.Connection(\":memory:\", *args, **kwargs)\n\n        for database in (TESTFN, os.fsencode(TESTFN),\n                         FakePath(TESTFN), FakePath(os.fsencode(TESTFN))):\n            database_arg = None\n            sqlite.connect(database, factory=factory).close()\n            self.assertEqual(database_arg, database)\n\n    def test_database_keyword(self):\n        with contextlib.closing(sqlite.connect(database=\":memory:\")) as cx:\n            self.assertEqual(type(cx), sqlite.Connection)", "\n\nclass CursorTests(unittest.TestCase):\n    def setUp(self):\n        self.cx = sqlite.connect(\":memory:\")\n        self.cu = self.cx.cursor()\n        self.cu.execute(\n            \"create table test(id integer primary key, name text, \"\n            \"income number, unique_test text unique)\"\n        )\n        self.cu.execute(\"insert into test(name) values (?)\", (\"foo\",))\n\n    def tearDown(self):\n        self.cu.close()\n        self.cx.close()\n\n    def test_execute_no_args(self):\n        self.cu.execute(\"delete from test\")\n\n    def test_execute_illegal_sql(self):\n        with self.assertRaises(sqlite.OperationalError):\n            self.cu.execute(\"select asdf\")\n\n    def test_execute_multiple_statements(self):\n        msg = \"You can only execute one statement at a time\"\n        dataset = (\n            \"select 1; select 2\",\n            \"select 1; // c++ comments are not allowed\",\n            \"select 1; *not a comment\",\n            \"select 1; -*not a comment\",\n            \"select 1; /* */ a\",\n            \"select 1; /**/a\",\n            \"select 1; -\",\n            \"select 1; /\",\n            \"select 1; -\\n- select 2\",\n            \"\"\"select 1;\n               -- comment\n               select 2\n            \"\"\",\n        )\n        for query in dataset:\n            with self.subTest(query=query):\n                with self.assertRaisesRegex(sqlite.ProgrammingError, msg):\n                    self.cu.execute(query)\n\n    @unittest.skip(\"not supported by sqld\")\n    def test_execute_with_appended_comments(self):\n        dataset = (\n            \"select 1; -- foo bar\",\n            \"select 1; --\",\n            \"select 1; /*\",  # Unclosed comments ending in \\0 are skipped.\n            \"\"\"\n            select 5+4;\n\n            /*\n            foo\n            */\n            \"\"\",\n        )\n        for query in dataset:\n            with self.subTest(query=query):\n                self.cu.execute(query)\n\n    def test_execute_wrong_sql_arg(self):\n        with self.assertRaises(TypeError):\n            self.cu.execute(42)\n\n    def test_execute_arg_int(self):\n        self.cu.execute(\"insert into test(id) values (?)\", (42,))\n\n    def test_execute_arg_float(self):\n        self.cu.execute(\"insert into test(income) values (?)\", (2500.32,))\n\n    def test_execute_arg_string(self):\n        self.cu.execute(\"insert into test(name) values (?)\", (\"Hugo\",))\n\n    def test_execute_arg_string_with_zero_byte(self):\n        self.cu.execute(\"insert into test(name) values (?)\", (\"Hu\\x00go\",))\n\n        self.cu.execute(\"select name from test where id=?\", (self.cu.lastrowid,))\n        row = self.cu.fetchone()\n        self.assertEqual(row[0], \"Hu\\x00go\")\n\n    def test_execute_non_iterable(self):\n        with self.assertRaises(sqlite.ProgrammingError) as cm:\n            self.cu.execute(\"insert into test(id) values (?)\", 42)\n        self.assertEqual(str(cm.exception), 'parameters are of unsupported type')\n\n    def test_execute_wrong_no_of_args1(self):\n        # too many parameters\n        with self.assertRaises(sqlite.ProgrammingError):\n            self.cu.execute(\"insert into test(id) values (?)\", (17, \"Egon\"))\n\n    def test_execute_wrong_no_of_args2(self):\n        # too little parameters\n        with self.assertRaises(sqlite.ProgrammingError):\n            self.cu.execute(\"insert into test(id) values (?)\")\n\n    def test_execute_wrong_no_of_args3(self):\n        # no parameters, parameters are needed\n        with self.assertRaises(sqlite.ProgrammingError):\n            self.cu.execute(\"insert into test(id) values (?)\")\n\n    def test_execute_param_list(self):\n        self.cu.execute(\"insert into test(name) values ('foo')\")\n        self.cu.execute(\"select name from test where name=?\", [\"foo\"])\n        row = self.cu.fetchone()\n        self.assertEqual(row[0], \"foo\")\n\n    def test_execute_param_sequence(self):\n        class L:\n            def __len__(self):\n                return 1\n            def __getitem__(self, x):\n                assert x == 0\n                return \"foo\"\n\n        self.cu.execute(\"insert into test(name) values ('foo')\")\n        self.cu.execute(\"select name from test where name=?\", L())\n        row = self.cu.fetchone()\n        self.assertEqual(row[0], \"foo\")\n\n    def test_execute_param_sequence_bad_len(self):\n        # Issue41662: Error in __len__() was overridden with ProgrammingError.\n        class L:\n            def __len__(self):\n                1/0\n            def __getitem__(slf, x):\n                raise AssertionError\n\n        self.cu.execute(\"insert into test(name) values ('foo')\")\n        with self.assertRaises(ZeroDivisionError):\n            self.cu.execute(\"select name from test where name=?\", L())\n\n    @unittest.skip(\"Not supported\")\n    def test_execute_too_many_params(self):\n        category = sqlite.SQLITE_LIMIT_VARIABLE_NUMBER\n        msg = \"too many SQL variables\"\n        with cx_limit(self.cx, category=category, limit=1):\n            self.cu.execute(\"select * from test where id=?\", (1,))\n            with self.assertRaisesRegex(sqlite.OperationalError, msg):\n                self.cu.execute(\"select * from test where id!=? and id!=?\",\n                                (1, 2))\n\n    def test_execute_dict_mapping(self):\n        self.cu.execute(\"insert into test(name) values ('foo')\")\n        self.cu.execute(\"select name from test where name=:name\", {\"name\": \"foo\"})\n        row = self.cu.fetchone()\n        self.assertEqual(row[0], \"foo\")\n\n    @unittest.skip(\"Not supported\")\n    def test_execute_dict_mapping_mapping(self):\n        class D(dict):\n            def __missing__(self, key):\n                return \"foo\"\n\n        self.cu.execute(\"insert into test(name) values ('foo')\")\n        self.cu.execute(\"select name from test where name=:name\", D())\n        row = self.cu.fetchone()\n        self.assertEqual(row[0], \"foo\")\n\n    def test_execute_dict_mapping_too_little_args(self):\n        self.cu.execute(\"insert into test(name) values ('foo')\")\n        with self.assertRaises(sqlite.ProgrammingError):\n            self.cu.execute(\"select name from test where name=:name and id=:id\", {\"name\": \"foo\"})\n\n    def test_execute_dict_mapping_no_args(self):\n        self.cu.execute(\"insert into test(name) values ('foo')\")\n        with self.assertRaises(sqlite.ProgrammingError):\n            self.cu.execute(\"select name from test where name=:name\")\n\n    def test_execute_dict_mapping_unnamed(self):\n        self.cu.execute(\"insert into test(name) values ('foo')\")\n        with self.assertRaises(sqlite.ProgrammingError):\n            self.cu.execute(\"select name from test where name=?\", {\"name\": \"foo\"})\n\n    def test_close(self):\n        self.cu.close()\n\n    def test_rowcount_execute(self):\n        self.cu.execute(\"delete from test\")\n        self.cu.execute(\"insert into test(name) values ('foo')\")\n        self.cu.execute(\"insert into test(name) values ('foo')\")\n        self.cu.execute(\"update test set name='bar'\")\n        self.assertEqual(self.cu.rowcount, 2)\n\n    def test_rowcount_select(self):\n        \"\"\"\n        pysqlite does not know the rowcount of SELECT statements, because we\n        don't fetch all rows after executing the select statement. The rowcount\n        has thus to be -1.\n        \"\"\"\n        self.cu.execute(\"select 5 union select 6\")\n        self.assertEqual(self.cu.rowcount, -1)\n\n    def test_rowcount_executemany(self):\n        self.cu.execute(\"delete from test\")\n        self.cu.executemany(\"insert into test(name) values (?)\", [(1,), (2,), (3,)])\n        self.assertEqual(self.cu.rowcount, 3)\n\n    @unittest.skipIf(sqlite.sqlite_version_info < (3, 35, 0),\n                     \"Requires SQLite 3.35.0 or newer\")\n    def test_rowcount_update_returning(self):\n        # gh-93421: rowcount is updated correctly for UPDATE...RETURNING queries\n        self.cu.execute(\"update test set name='bar' where name='foo' returning 1\")\n        self.assertEqual(self.cu.fetchone()[0], 1)\n        self.assertEqual(self.cu.rowcount, 1)\n\n    def test_rowcount_prefixed_with_comment(self):\n        # gh-79579: rowcount is updated even if query is prefixed with comments\n        self.cu.execute(\"\"\"\n            -- foo\n            insert into test(name) values ('foo'), ('foo')\n        \"\"\")\n        self.assertEqual(self.cu.rowcount, 2)\n        self.cu.execute(\"\"\"\n            /* -- messy *r /* /* ** *- *--\n            */\n            /* one more */ insert into test(name) values ('messy')\n        \"\"\")\n        self.assertEqual(self.cu.rowcount, 1)\n        self.cu.execute(\"/* bar */ update test set name='bar' where name='foo'\")\n        self.assertEqual(self.cu.rowcount, 3)\n\n    @unittest.skip(\"sqld doesn't allow vaccum\")\n    def test_rowcount_vaccuum(self):\n        data = ((1,), (2,), (3,))\n        self.cu.executemany(\"insert into test(income) values(?)\", data)\n        self.assertEqual(self.cu.rowcount, 3)\n        self.cx.commit()\n        self.cu.execute(\"vacuum\")\n        self.assertEqual(self.cu.rowcount, -1)\n\n    @unittest.skip(\"sqld doesn't inform, libsql_client can't account properly\")\n    def test_total_changes(self):\n        self.cu.execute(\"insert into test(name) values ('foo')\")\n        self.cu.execute(\"insert into test(name) values ('foo')\")\n        self.assertLess(2, self.cx.total_changes, msg='total changes reported wrong value')\n\n    # Checks for executemany:\n    # Sequences are required by the DB-API, iterators\n    # enhancements in pysqlite.\n\n    def test_execute_many_sequence(self):\n        self.cu.executemany(\"insert into test(income) values (?)\", [(x,) for x in range(100, 110)])\n\n    def test_execute_many_iterator(self):\n        class MyIter:\n            def __init__(self):\n                self.value = 5\n\n            def __iter__(self):\n                return self\n\n            def __next__(self):\n                if self.value == 10:\n                    raise StopIteration\n                else:\n                    self.value += 1\n                    return (self.value,)\n\n        self.cu.executemany(\"insert into test(income) values (?)\", MyIter())\n\n    def test_execute_many_generator(self):\n        def mygen():\n            for i in range(5):\n                yield (i,)\n\n        self.cu.executemany(\"insert into test(income) values (?)\", mygen())\n\n    def test_execute_many_wrong_sql_arg(self):\n        with self.assertRaises(TypeError):\n            self.cu.executemany(42, [(3,)])\n\n    def test_execute_many_select(self):\n        with self.assertRaises(sqlite.ProgrammingError):\n            self.cu.executemany(\"select ?\", [(3,)])\n\n    def test_execute_many_not_iterable(self):\n        with self.assertRaises(TypeError):\n            self.cu.executemany(\"insert into test(income) values (?)\", 42)\n\n    def test_fetch_iter(self):\n        # Optional DB-API extension.\n        self.cu.execute(\"delete from test\")\n        self.cu.execute(\"insert into test(id) values (?)\", (5,))\n        self.cu.execute(\"insert into test(id) values (?)\", (6,))\n        self.cu.execute(\"select id from test order by id\")\n        lst = []\n        for row in self.cu:\n            lst.append(row[0])\n        self.assertEqual(lst[0], 5)\n        self.assertEqual(lst[1], 6)\n\n    def test_fetchone(self):\n        self.cu.execute(\"select name from test\")\n        row = self.cu.fetchone()\n        self.assertEqual(row[0], \"foo\")\n        row = self.cu.fetchone()\n        self.assertEqual(row, None)\n\n    def test_fetchone_no_statement(self):\n        cur = self.cx.cursor()\n        row = cur.fetchone()\n        self.assertEqual(row, None)\n\n    def test_array_size(self):\n        # must default to 1\n        self.assertEqual(self.cu.arraysize, 1)\n\n        # now set to 2\n        self.cu.arraysize = 2\n\n        # now make the query return 3 rows\n        self.cu.execute(\"delete from test\")\n        self.cu.execute(\"insert into test(name) values ('A')\")\n        self.cu.execute(\"insert into test(name) values ('B')\")\n        self.cu.execute(\"insert into test(name) values ('C')\")\n        self.cu.execute(\"select name from test\")\n        res = self.cu.fetchmany()\n\n        self.assertEqual(len(res), 2)\n\n    def test_fetchmany(self):\n        self.cu.execute(\"select name from test\")\n        res = self.cu.fetchmany(100)\n        self.assertEqual(len(res), 1)\n        res = self.cu.fetchmany(100)\n        self.assertEqual(res, [])\n\n    def test_fetchmany_kw_arg(self):\n        \"\"\"Checks if fetchmany works with keyword arguments\"\"\"\n        self.cu.execute(\"select name from test\")\n        res = self.cu.fetchmany(size=100)\n        self.assertEqual(len(res), 1)\n\n    def test_fetchall(self):\n        self.cu.execute(\"select name from test\")\n        res = self.cu.fetchall()\n        self.assertEqual(len(res), 1)\n        res = self.cu.fetchall()\n        self.assertEqual(res, [])\n\n    def test_setinputsizes(self):\n        self.cu.setinputsizes([3, 4, 5])\n\n    def test_setoutputsize(self):\n        self.cu.setoutputsize(5, 0)\n\n    def test_setoutputsize_no_column(self):\n        self.cu.setoutputsize(42)\n\n    def test_cursor_connection(self):\n        # Optional DB-API extension.\n        self.assertEqual(self.cu.connection, self.cx)\n\n    def test_wrong_cursor_callable(self):\n        with self.assertRaises(TypeError):\n            def f(): pass\n            cur = self.cx.cursor(f)\n\n    def test_cursor_wrong_class(self):\n        class Foo: pass\n        foo = Foo()\n        with self.assertRaises(TypeError):\n            cur = sqlite.Cursor(foo)\n\n    def test_last_row_id_on_replace(self):\n        \"\"\"\n        INSERT OR REPLACE and REPLACE INTO should produce the same behavior.\n        \"\"\"\n        sql = '{} INTO test(id, unique_test) VALUES (?, ?)'\n        for statement in ('INSERT OR REPLACE', 'REPLACE'):\n            with self.subTest(statement=statement):\n                self.cu.execute(sql.format(statement), (1, 'foo'))\n                self.assertEqual(self.cu.lastrowid, 1)\n\n    def test_last_row_id_on_ignore(self):\n        self.cu.execute(\n            \"insert or ignore into test(unique_test) values (?)\",\n            ('test',))\n        self.assertEqual(self.cu.lastrowid, 2)\n        self.cu.execute(\n            \"insert or ignore into test(unique_test) values (?)\",\n            ('test',))\n        self.assertEqual(self.cu.lastrowid, 2)\n\n    def test_last_row_id_insert_o_r(self):\n        results = []\n        for statement in ('FAIL', 'ABORT', 'ROLLBACK'):\n            sql = 'INSERT OR {} INTO test(unique_test) VALUES (?)'\n            with self.subTest(statement='INSERT OR {}'.format(statement)):\n                self.cu.execute(sql.format(statement), (statement,))\n                results.append((statement, self.cu.lastrowid))\n                with self.assertRaises(sqlite.IntegrityError):\n                    self.cu.execute(sql.format(statement), (statement,))\n                results.append((statement, self.cu.lastrowid))\n        expected = [\n            ('FAIL', 2), ('FAIL', 2),\n            ('ABORT', 3), ('ABORT', 3),\n            ('ROLLBACK', 4), ('ROLLBACK', 4),\n        ]\n        self.assertEqual(results, expected)\n\n    def test_column_count(self):\n        # Check that column count is updated correctly for cached statements\n        select = \"select * from test\"\n        res = self.cu.execute(select)\n        old_count = len(res.description)\n        # Add a new column and execute the cached select query again\n        self.cu.execute(\"alter table test add newcol\")\n        res = self.cu.execute(select)\n        new_count = len(res.description)\n        self.assertEqual(new_count - old_count, 1)\n\n    def test_same_query_in_multiple_cursors(self):\n        cursors = [self.cx.execute(\"select 1\") for _ in range(3)]\n        for cu in cursors:\n            self.assertEqual(cu.fetchall(), [(1,)])", "\n\n@unittest.skip(\"Not supported\")\nclass BlobTests(unittest.TestCase):\n    def setUp(self):\n        self.cx = sqlite.connect(\":memory:\")\n        self.cx.execute(\"create table test(b blob)\")\n        self.data = b\"this blob data string is exactly fifty bytes long!\"\n        self.cx.execute(\"insert into test(b) values (?)\", (self.data,))\n        self.blob = self.cx.blobopen(\"test\", \"b\", 1)\n\n    def tearDown(self):\n        self.blob.close()\n        self.cx.close()\n\n    def test_blob_is_a_blob(self):\n        self.assertIsInstance(self.blob, sqlite.Blob)\n\n    def test_blob_seek_and_tell(self):\n        self.blob.seek(10)\n        self.assertEqual(self.blob.tell(), 10)\n\n        self.blob.seek(10, SEEK_SET)\n        self.assertEqual(self.blob.tell(), 10)\n\n        self.blob.seek(10, SEEK_CUR)\n        self.assertEqual(self.blob.tell(), 20)\n\n        self.blob.seek(-10, SEEK_END)\n        self.assertEqual(self.blob.tell(), 40)\n\n    def test_blob_seek_error(self):\n        msg_oor = \"offset out of blob range\"\n        msg_orig = \"'origin' should be os.SEEK_SET, os.SEEK_CUR, or os.SEEK_END\"\n        msg_of = \"seek offset results in overflow\"\n\n        dataset = (\n            (ValueError, msg_oor, lambda: self.blob.seek(1000)),\n            (ValueError, msg_oor, lambda: self.blob.seek(-10)),\n            (ValueError, msg_orig, lambda: self.blob.seek(10, -1)),\n            (ValueError, msg_orig, lambda: self.blob.seek(10, 3)),\n        )\n        for exc, msg, fn in dataset:\n            with self.subTest(exc=exc, msg=msg, fn=fn):\n                self.assertRaisesRegex(exc, msg, fn)\n\n        # Force overflow errors\n        self.blob.seek(1, SEEK_SET)\n        with self.assertRaisesRegex(OverflowError, msg_of):\n            self.blob.seek(INT_MAX, SEEK_CUR)\n        with self.assertRaisesRegex(OverflowError, msg_of):\n            self.blob.seek(INT_MAX, SEEK_END)\n\n    def test_blob_read(self):\n        buf = self.blob.read()\n        self.assertEqual(buf, self.data)\n\n    def test_blob_read_oversized(self):\n        buf = self.blob.read(len(self.data) * 2)\n        self.assertEqual(buf, self.data)\n\n    def test_blob_read_advance_offset(self):\n        n = 10\n        buf = self.blob.read(n)\n        self.assertEqual(buf, self.data[:n])\n        self.assertEqual(self.blob.tell(), n)\n\n    def test_blob_read_at_offset(self):\n        self.blob.seek(10)\n        self.assertEqual(self.blob.read(10), self.data[10:20])\n\n    def test_blob_read_error_row_changed(self):\n        self.cx.execute(\"update test set b='aaaa' where rowid=1\")\n        with self.assertRaises(sqlite.OperationalError):\n            self.blob.read()\n\n    def test_blob_write(self):\n        new_data = b\"new data\".ljust(50)\n        self.blob.write(new_data)\n        row = self.cx.execute(\"select b from test\").fetchone()\n        self.assertEqual(row[0], new_data)\n\n    def test_blob_write_at_offset(self):\n        new_data = b\"c\" * 25\n        self.blob.seek(25)\n        self.blob.write(new_data)\n        row = self.cx.execute(\"select b from test\").fetchone()\n        self.assertEqual(row[0], self.data[:25] + new_data)\n\n    def test_blob_write_advance_offset(self):\n        self.blob.write(b\"d\"*10)\n        self.assertEqual(self.blob.tell(), 10)\n\n    def test_blob_write_error_length(self):\n        with self.assertRaisesRegex(ValueError, \"data longer than blob\"):\n            self.blob.write(b\"a\" * 1000)\n\n        self.blob.seek(0, SEEK_SET)\n        n = len(self.blob)\n        self.blob.write(b\"a\" * (n-1))\n        self.blob.write(b\"a\")\n        with self.assertRaisesRegex(ValueError, \"data longer than blob\"):\n            self.blob.write(b\"a\")\n\n    def test_blob_write_error_row_changed(self):\n        self.cx.execute(\"update test set b='aaaa' where rowid=1\")\n        with self.assertRaises(sqlite.OperationalError):\n            self.blob.write(b\"aaa\")\n\n    def test_blob_write_error_readonly(self):\n        ro_blob = self.cx.blobopen(\"test\", \"b\", 1, readonly=True)\n        with self.assertRaisesRegex(sqlite.OperationalError, \"readonly\"):\n            ro_blob.write(b\"aaa\")\n        ro_blob.close()\n\n    def test_blob_open_error(self):\n        dataset = (\n            ((\"test\", \"b\", 1), {\"name\": \"notexisting\"}),\n            ((\"notexisting\", \"b\", 1), {}),\n            ((\"test\", \"notexisting\", 1), {}),\n            ((\"test\", \"b\", 2), {}),\n        )\n        regex = \"no such\"\n        for args, kwds in dataset:\n            with self.subTest(args=args, kwds=kwds):\n                with self.assertRaisesRegex(sqlite.OperationalError, regex):\n                    self.cx.blobopen(*args, **kwds)\n\n    def test_blob_length(self):\n        self.assertEqual(len(self.blob), 50)\n\n    def test_blob_get_item(self):\n        self.assertEqual(self.blob[5], ord(\"b\"))\n        self.assertEqual(self.blob[6], ord(\"l\"))\n        self.assertEqual(self.blob[7], ord(\"o\"))\n        self.assertEqual(self.blob[8], ord(\"b\"))\n        self.assertEqual(self.blob[-1], ord(\"!\"))\n\n    def test_blob_set_item(self):\n        self.blob[0] = ord(\"b\")\n        expected = b\"b\" + self.data[1:]\n        actual = self.cx.execute(\"select b from test\").fetchone()[0]\n        self.assertEqual(actual, expected)\n\n    def test_blob_set_item_with_offset(self):\n        self.blob.seek(0, SEEK_END)\n        self.assertEqual(self.blob.read(), b\"\")  # verify that we're at EOB\n        self.blob[0] = ord(\"T\")\n        self.blob[-1] = ord(\".\")\n        self.blob.seek(0, SEEK_SET)\n        expected = b\"This blob data string is exactly fifty bytes long.\"\n        self.assertEqual(self.blob.read(), expected)\n\n    def test_blob_set_slice_buffer_object(self):\n        from array import array\n        self.blob[0:5] = memoryview(b\"12345\")\n        self.assertEqual(self.blob[0:5], b\"12345\")\n\n        self.blob[0:5] = bytearray(b\"23456\")\n        self.assertEqual(self.blob[0:5], b\"23456\")\n\n        self.blob[0:5] = array(\"b\", [1, 2, 3, 4, 5])\n        self.assertEqual(self.blob[0:5], b\"\\x01\\x02\\x03\\x04\\x05\")\n\n    def test_blob_set_item_negative_index(self):\n        self.blob[-1] = 255\n        self.assertEqual(self.blob[-1], 255)\n\n    def test_blob_get_slice(self):\n        self.assertEqual(self.blob[5:14], b\"blob data\")\n\n    def test_blob_get_empty_slice(self):\n        self.assertEqual(self.blob[5:5], b\"\")\n\n    def test_blob_get_slice_negative_index(self):\n        self.assertEqual(self.blob[5:-5], self.data[5:-5])\n\n    def test_blob_get_slice_with_skip(self):\n        self.assertEqual(self.blob[0:10:2], b\"ti lb\")\n\n    def test_blob_set_slice(self):\n        self.blob[0:5] = b\"12345\"\n        expected = b\"12345\" + self.data[5:]\n        actual = self.cx.execute(\"select b from test\").fetchone()[0]\n        self.assertEqual(actual, expected)\n\n    def test_blob_set_empty_slice(self):\n        self.blob[0:0] = b\"\"\n        self.assertEqual(self.blob[:], self.data)\n\n    def test_blob_set_slice_with_skip(self):\n        self.blob[0:10:2] = b\"12345\"\n        actual = self.cx.execute(\"select b from test\").fetchone()[0]\n        expected = b\"1h2s3b4o5 \" + self.data[10:]\n        self.assertEqual(actual, expected)\n\n    def test_blob_mapping_invalid_index_type(self):\n        msg = \"indices must be integers\"\n        with self.assertRaisesRegex(TypeError, msg):\n            self.blob[5:5.5]\n        with self.assertRaisesRegex(TypeError, msg):\n            self.blob[1.5]\n        with self.assertRaisesRegex(TypeError, msg):\n            self.blob[\"a\"] = b\"b\"\n\n    def test_blob_get_item_error(self):\n        dataset = [len(self.blob), 105, -105]\n        for idx in dataset:\n            with self.subTest(idx=idx):\n                with self.assertRaisesRegex(IndexError, \"index out of range\"):\n                    self.blob[idx]\n        with self.assertRaisesRegex(IndexError, \"cannot fit 'int'\"):\n            self.blob[ULLONG_MAX]\n\n        # Provoke read error\n        self.cx.execute(\"update test set b='aaaa' where rowid=1\")\n        with self.assertRaises(sqlite.OperationalError):\n            self.blob[0]\n\n    def test_blob_set_item_error(self):\n        with self.assertRaisesRegex(TypeError, \"cannot be interpreted\"):\n            self.blob[0] = b\"multiple\"\n        with self.assertRaisesRegex(TypeError, \"cannot be interpreted\"):\n            self.blob[0] = b\"1\"\n        with self.assertRaisesRegex(TypeError, \"cannot be interpreted\"):\n            self.blob[0] = bytearray(b\"1\")\n        with self.assertRaisesRegex(TypeError, \"doesn't support.*deletion\"):\n            del self.blob[0]\n        with self.assertRaisesRegex(IndexError, \"Blob index out of range\"):\n            self.blob[1000] = 0\n        with self.assertRaisesRegex(ValueError, \"must be in range\"):\n            self.blob[0] = -1\n        with self.assertRaisesRegex(ValueError, \"must be in range\"):\n            self.blob[0] = 256\n        # Overflow errors are overridden with ValueError\n        with self.assertRaisesRegex(ValueError, \"must be in range\"):\n            self.blob[0] = 2**65\n\n    def test_blob_set_slice_error(self):\n        with self.assertRaisesRegex(IndexError, \"wrong size\"):\n            self.blob[5:10] = b\"a\"\n        with self.assertRaisesRegex(IndexError, \"wrong size\"):\n            self.blob[5:10] = b\"a\" * 1000\n        with self.assertRaisesRegex(TypeError, \"doesn't support.*deletion\"):\n            del self.blob[5:10]\n        with self.assertRaisesRegex(ValueError, \"step cannot be zero\"):\n            self.blob[5:10:0] = b\"12345\"\n        with self.assertRaises(BufferError):\n            self.blob[5:10] = memoryview(b\"abcde\")[::2]\n\n    def test_blob_sequence_not_supported(self):\n        with self.assertRaisesRegex(TypeError, \"unsupported operand\"):\n            self.blob + self.blob\n        with self.assertRaisesRegex(TypeError, \"unsupported operand\"):\n            self.blob * 5\n        with self.assertRaisesRegex(TypeError, \"is not iterable\"):\n            b\"a\" in self.blob\n\n    def test_blob_context_manager(self):\n        data = b\"a\" * 50\n        with self.cx.blobopen(\"test\", \"b\", 1) as blob:\n            blob.write(data)\n        actual = self.cx.execute(\"select b from test\").fetchone()[0]\n        self.assertEqual(actual, data)\n\n        # Check that __exit__ closed the blob\n        with self.assertRaisesRegex(sqlite.ProgrammingError, \"closed blob\"):\n            blob.read()\n\n    def test_blob_context_manager_reraise_exceptions(self):\n        class DummyException(Exception):\n            pass\n        with self.assertRaisesRegex(DummyException, \"reraised\"):\n            with self.cx.blobopen(\"test\", \"b\", 1) as blob:\n                raise DummyException(\"reraised\")\n\n\n    def test_blob_closed(self):\n        with memory_database() as cx:\n            cx.execute(\"create table test(b blob)\")\n            cx.execute(\"insert into test values (zeroblob(100))\")\n            blob = cx.blobopen(\"test\", \"b\", 1)\n            blob.close()\n\n            msg = \"Cannot operate on a closed blob\"\n            with self.assertRaisesRegex(sqlite.ProgrammingError, msg):\n                blob.read()\n            with self.assertRaisesRegex(sqlite.ProgrammingError, msg):\n                blob.write(b\"\")\n            with self.assertRaisesRegex(sqlite.ProgrammingError, msg):\n                blob.seek(0)\n            with self.assertRaisesRegex(sqlite.ProgrammingError, msg):\n                blob.tell()\n            with self.assertRaisesRegex(sqlite.ProgrammingError, msg):\n                blob.__enter__()\n            with self.assertRaisesRegex(sqlite.ProgrammingError, msg):\n                blob.__exit__(None, None, None)\n            with self.assertRaisesRegex(sqlite.ProgrammingError, msg):\n                len(blob)\n            with self.assertRaisesRegex(sqlite.ProgrammingError, msg):\n                blob[0]\n            with self.assertRaisesRegex(sqlite.ProgrammingError, msg):\n                blob[0:1]\n            with self.assertRaisesRegex(sqlite.ProgrammingError, msg):\n                blob[0] = b\"\"\n\n    def test_blob_closed_db_read(self):\n        with memory_database() as cx:\n            cx.execute(\"create table test(b blob)\")\n            cx.execute(\"insert into test(b) values (zeroblob(100))\")\n            blob = cx.blobopen(\"test\", \"b\", 1)\n            cx.close()\n            self.assertRaisesRegex(sqlite.ProgrammingError,\n                                   \"Cannot operate on a closed database\",\n                                   blob.read)", "\n\n@threading_helper.requires_working_threading()\nclass ThreadTests(unittest.TestCase):\n    def setUp(self):\n        self.con = sqlite.connect(\":memory:\")\n        self.cur = self.con.cursor()\n        self.cur.execute(\"create table test(name text, b blob)\")\n        self.cur.execute(\"insert into test values('blob', zeroblob(1))\")\n\n    def tearDown(self):\n        self.cur.close()\n        self.con.close()\n\n    @threading_helper.reap_threads\n    def _run_test(self, fn, *args, **kwds):\n        def run(err):\n            try:\n                fn(*args, **kwds)\n                err.append(\"did not raise ProgrammingError\")\n            except sqlite.ProgrammingError:\n                pass\n            except:\n                err.append(\"raised wrong exception\")\n\n        err = []\n        t = threading.Thread(target=run, kwargs={\"err\": err})\n        t.start()\n        t.join()\n        if err:\n            self.fail(\"\\n\".join(err))\n\n    def test_check_connection_thread(self):\n        fns = [\n            lambda: self.con.cursor(),\n            lambda: self.con.commit(),\n            lambda: self.con.rollback(),\n            lambda: self.con.close(),\n            lambda: self.con.set_trace_callback(None),\n            # NOTE: not supported by libsql_client\n            # lambda: self.con.set_authorizer(None),\n            # lambda: self.con.create_collation(\"foo\", None),\n            # lambda: self.con.setlimit(sqlite.SQLITE_LIMIT_LENGTH, -1),\n            # lambda: self.con.getlimit(sqlite.SQLITE_LIMIT_LENGTH),\n            # lambda: self.con.blobopen(\"test\", \"b\", 1),\n        ]\n        # NOTE: not supported by libsql_client\n        # if hasattr(sqlite.Connection, \"serialize\"):\n        #     fns.append(lambda: self.con.serialize())\n        #     fns.append(lambda: self.con.deserialize(b\"\"))\n        # if sqlite.sqlite_version_info >= (3, 25, 0):\n        #     fns.append(lambda: self.con.create_window_function(\"foo\", 0, None))\n\n        for fn in fns:\n            with self.subTest(fn=fn):\n                self._run_test(fn)\n\n    def test_check_cursor_thread(self):\n        fns = [\n            lambda: self.cur.execute(\"insert into test(name) values('a')\"),\n            lambda: self.cur.close(),\n            lambda: self.cur.execute(\"select name from test\"),\n            lambda: self.cur.fetchone(),\n        ]\n        for fn in fns:\n            with self.subTest(fn=fn):\n                self._run_test(fn)\n\n\n    @threading_helper.reap_threads\n    def test_dont_check_same_thread(self):\n        def run(con, err):\n            try:\n                con.execute(\"select 1\")\n            except sqlite.Error:\n                err.append(\"multi-threading not allowed\")\n\n        con = sqlite.connect(\":memory:\", check_same_thread=False)\n        err = []\n        t = threading.Thread(target=run, kwargs={\"con\": con, \"err\": err})\n        t.start()\n        t.join()\n        self.assertEqual(len(err), 0, \"\\n\".join(err))", "\n\nclass ConstructorTests(unittest.TestCase):\n    def test_date(self):\n        d = sqlite.Date(2004, 10, 28)\n\n    def test_time(self):\n        t = sqlite.Time(12, 39, 35)\n\n    def test_timestamp(self):\n        ts = sqlite.Timestamp(2004, 10, 28, 12, 39, 35)\n\n    def test_date_from_ticks(self):\n        d = sqlite.DateFromTicks(42)\n\n    def test_time_from_ticks(self):\n        t = sqlite.TimeFromTicks(42)\n\n    def test_timestamp_from_ticks(self):\n        ts = sqlite.TimestampFromTicks(42)\n\n    def test_binary(self):\n        b = sqlite.Binary(b\"\\0'\")", "\n@unittest.skip(\"Not supported\")\nclass ExtensionTests(unittest.TestCase):\n    def test_script_string_sql(self):\n        con = sqlite.connect(\":memory:\")\n        cur = con.cursor()\n        cur.executescript(\"\"\"\n            -- bla bla\n            /* a stupid comment */\n            create table a(i);\n            insert into a(i) values (5);\n            \"\"\")\n        cur.execute(\"select i from a\")\n        res = cur.fetchone()[0]\n        self.assertEqual(res, 5)\n\n    def test_script_syntax_error(self):\n        con = sqlite.connect(\":memory:\")\n        cur = con.cursor()\n        with self.assertRaises(sqlite.OperationalError):\n            cur.executescript(\"create table test(x); asdf; create table test2(x)\")\n\n    def test_script_error_normal(self):\n        con = sqlite.connect(\":memory:\")\n        cur = con.cursor()\n        with self.assertRaises(sqlite.OperationalError):\n            cur.executescript(\"create table test(sadfsadfdsa); select foo from hurz;\")\n\n    def test_cursor_executescript_as_bytes(self):\n        con = sqlite.connect(\":memory:\")\n        cur = con.cursor()\n        with self.assertRaises(TypeError):\n            cur.executescript(b\"create table test(foo); insert into test(foo) values (5);\")\n\n    def test_cursor_executescript_with_null_characters(self):\n        con = sqlite.connect(\":memory:\")\n        cur = con.cursor()\n        with self.assertRaises(ValueError):\n            cur.executescript(\"\"\"\n                create table a(i);\\0\n                insert into a(i) values (5);\n                \"\"\")\n\n    def test_cursor_executescript_with_surrogates(self):\n        con = sqlite.connect(\":memory:\")\n        cur = con.cursor()\n        with self.assertRaises(UnicodeEncodeError):\n            cur.executescript(\"\"\"\n                create table a(s);\n                insert into a(s) values ('\\ud8ff');\n                \"\"\")\n\n    def test_cursor_executescript_too_large_script(self):\n        msg = \"query string is too large\"\n        with memory_database() as cx, cx_limit(cx) as lim:\n            cx.executescript(\"select 'almost too large'\".ljust(lim))\n            with self.assertRaisesRegex(sqlite.DataError, msg):\n                cx.executescript(\"select 'too large'\".ljust(lim+1))\n\n    def test_cursor_executescript_tx_control(self):\n        con = sqlite.connect(\":memory:\")\n        con.execute(\"begin\")\n        self.assertTrue(con.in_transaction)\n        con.executescript(\"select 1\")\n        self.assertFalse(con.in_transaction)\n\n    def test_connection_execute(self):\n        con = sqlite.connect(\":memory:\")\n        result = con.execute(\"select 5\").fetchone()[0]\n        self.assertEqual(result, 5, \"Basic test of Connection.execute\")\n\n    def test_connection_executemany(self):\n        con = sqlite.connect(\":memory:\")\n        con.execute(\"create table test(foo)\")\n        con.executemany(\"insert into test(foo) values (?)\", [(3,), (4,)])\n        result = con.execute(\"select foo from test order by foo\").fetchall()\n        self.assertEqual(result[0][0], 3, \"Basic test of Connection.executemany\")\n        self.assertEqual(result[1][0], 4, \"Basic test of Connection.executemany\")\n\n    def test_connection_executescript(self):\n        con = sqlite.connect(\":memory:\")\n        con.executescript(\"create table test(foo); insert into test(foo) values (5);\")\n        result = con.execute(\"select foo from test\").fetchone()[0]\n        self.assertEqual(result, 5, \"Basic test of Connection.executescript\")", "\nclass ClosedConTests(unittest.TestCase):\n    def test_closed_con_cursor(self):\n        con = sqlite.connect(\":memory:\")\n        con.close()\n        with self.assertRaises(sqlite.ProgrammingError):\n            cur = con.cursor()\n\n    def test_closed_con_commit(self):\n        con = sqlite.connect(\":memory:\")\n        con.close()\n        with self.assertRaises(sqlite.ProgrammingError):\n            con.commit()\n\n    def test_closed_con_rollback(self):\n        con = sqlite.connect(\":memory:\")\n        con.close()\n        with self.assertRaises(sqlite.ProgrammingError):\n            con.rollback()\n\n    def test_closed_cur_execute(self):\n        con = sqlite.connect(\":memory:\")\n        cur = con.cursor()\n        con.close()\n        with self.assertRaises(sqlite.ProgrammingError):\n            cur.execute(\"select 4\")\n\n    @unittest.skip(\"Not supported\")\n    def test_closed_create_function(self):\n        con = sqlite.connect(\":memory:\")\n        con.close()\n        def f(x): return 17\n        with self.assertRaises(sqlite.ProgrammingError):\n            con.create_function(\"foo\", 1, f)\n\n    @unittest.skip(\"Not supported\")\n    def test_closed_create_aggregate(self):\n        con = sqlite.connect(\":memory:\")\n        con.close()\n        class Agg:\n            def __init__(self):\n                pass\n            def step(self, x):\n                pass\n            def finalize(self):\n                return 17\n        with self.assertRaises(sqlite.ProgrammingError):\n            con.create_aggregate(\"foo\", 1, Agg)\n\n    @unittest.skip(\"Not supported\")\n    def test_closed_set_authorizer(self):\n        con = sqlite.connect(\":memory:\")\n        con.close()\n        def authorizer(*args):\n            return sqlite.DENY\n        with self.assertRaises(sqlite.ProgrammingError):\n            con.set_authorizer(authorizer)\n\n    @unittest.skip(\"Not supported\")\n    def test_closed_set_progress_callback(self):\n        con = sqlite.connect(\":memory:\")\n        con.close()\n        def progress(): pass\n        with self.assertRaises(sqlite.ProgrammingError):\n            con.set_progress_handler(progress, 100)\n\n    def test_closed_call(self):\n        con = sqlite.connect(\":memory:\")\n        con.close()\n        with self.assertRaises(sqlite.ProgrammingError):\n            con()", "\nclass ClosedCurTests(unittest.TestCase):\n    def test_closed(self):\n        con = sqlite.connect(\":memory:\")\n        cur = con.cursor()\n        cur.close()\n\n        for method_name in (\"execute\", \"executemany\", \"executescript\", \"fetchall\", \"fetchmany\", \"fetchone\"):\n            if method_name in (\"execute\", \"executescript\"):\n                params = (\"select 4 union select 5\",)\n            elif method_name == \"executemany\":\n                params = (\"insert into foo(bar) values (?)\", [(3,), (4,)])\n            else:\n                params = []\n\n            with self.assertRaises(sqlite.ProgrammingError):\n                method = getattr(cur, method_name)\n                method(*params)", "\n\nclass SqliteOnConflictTests(unittest.TestCase):\n    \"\"\"\n    Tests for SQLite's \"insert on conflict\" feature.\n\n    See https://www.sqlite.org/lang_conflict.html for details.\n    \"\"\"\n\n    def setUp(self):\n        self.cx = sqlite.connect(\":memory:\")\n        self.cu = self.cx.cursor()\n        self.cu.execute(\"\"\"\n          CREATE TABLE test(\n            id INTEGER PRIMARY KEY, name TEXT, unique_name TEXT UNIQUE\n          );\n        \"\"\")\n\n    def tearDown(self):\n        self.cu.close()\n        self.cx.close()\n\n    @unittest.skip(\"libsql_client depends on server sending autocommit mode\")\n    def test_on_conflict_rollback_with_explicit_transaction(self):\n        self.cx.isolation_level = None  # autocommit mode\n        self.cu = self.cx.cursor()\n        # Start an explicit transaction.\n        self.cu.execute(\"BEGIN\")\n        self.cu.execute(\"INSERT INTO test(name) VALUES ('abort_test')\")\n        self.cu.execute(\"INSERT OR ROLLBACK INTO test(unique_name) VALUES ('foo')\")\n        with self.assertRaises(sqlite.IntegrityError):\n            self.cu.execute(\"INSERT OR ROLLBACK INTO test(unique_name) VALUES ('foo')\")\n        # Use connection to commit.\n        self.cx.commit()\n        self.cu.execute(\"SELECT name, unique_name from test\")\n        # Transaction should have rolled back and nothing should be in table.\n        self.assertEqual(self.cu.fetchall(), [])\n\n    def test_on_conflict_abort_raises_with_explicit_transactions(self):\n        # Abort cancels the current sql statement but doesn't change anything\n        # about the current transaction.\n        self.cx.isolation_level = None  # autocommit mode\n        self.cu = self.cx.cursor()\n        # Start an explicit transaction.\n        self.cu.execute(\"BEGIN\")\n        self.cu.execute(\"INSERT INTO test(name) VALUES ('abort_test')\")\n        self.cu.execute(\"INSERT OR ABORT INTO test(unique_name) VALUES ('foo')\")\n        with self.assertRaises(sqlite.IntegrityError):\n            self.cu.execute(\"INSERT OR ABORT INTO test(unique_name) VALUES ('foo')\")\n        self.cx.commit()\n        self.cu.execute(\"SELECT name, unique_name FROM test\")\n        # Expect the first two inserts to work, third to do nothing.\n        self.assertEqual(self.cu.fetchall(), [('abort_test', None), (None, 'foo',)])\n\n    def test_on_conflict_rollback_without_transaction(self):\n        # Start of implicit transaction\n        self.cu.execute(\"INSERT INTO test(name) VALUES ('abort_test')\")\n        self.cu.execute(\"INSERT OR ROLLBACK INTO test(unique_name) VALUES ('foo')\")\n        with self.assertRaises(sqlite.IntegrityError):\n            self.cu.execute(\"INSERT OR ROLLBACK INTO test(unique_name) VALUES ('foo')\")\n        self.cu.execute(\"SELECT name, unique_name FROM test\")\n        # Implicit transaction is rolled back on error.\n        self.assertEqual(self.cu.fetchall(), [])\n\n    def test_on_conflict_abort_raises_without_transactions(self):\n        # Abort cancels the current sql statement but doesn't change anything\n        # about the current transaction.\n        self.cu.execute(\"INSERT INTO test(name) VALUES ('abort_test')\")\n        self.cu.execute(\"INSERT OR ABORT INTO test(unique_name) VALUES ('foo')\")\n        with self.assertRaises(sqlite.IntegrityError):\n            self.cu.execute(\"INSERT OR ABORT INTO test(unique_name) VALUES ('foo')\")\n        # Make sure all other values were inserted.\n        self.cu.execute(\"SELECT name, unique_name FROM test\")\n        self.assertEqual(self.cu.fetchall(), [('abort_test', None), (None, 'foo',)])\n\n    def test_on_conflict_fail(self):\n        self.cu.execute(\"INSERT OR FAIL INTO test(unique_name) VALUES ('foo')\")\n        with self.assertRaises(sqlite.IntegrityError):\n            self.cu.execute(\"INSERT OR FAIL INTO test(unique_name) VALUES ('foo')\")\n        self.assertEqual(self.cu.fetchall(), [])\n\n    def test_on_conflict_ignore(self):\n        self.cu.execute(\"INSERT OR IGNORE INTO test(unique_name) VALUES ('foo')\")\n        # Nothing should happen.\n        self.cu.execute(\"INSERT OR IGNORE INTO test(unique_name) VALUES ('foo')\")\n        self.cu.execute(\"SELECT unique_name FROM test\")\n        self.assertEqual(self.cu.fetchall(), [('foo',)])\n\n    def test_on_conflict_replace(self):\n        self.cu.execute(\"INSERT OR REPLACE INTO test(name, unique_name) VALUES ('Data!', 'foo')\")\n        # There shouldn't be an IntegrityError exception.\n        self.cu.execute(\"INSERT OR REPLACE INTO test(name, unique_name) VALUES ('Very different data!', 'foo')\")\n        self.cu.execute(\"SELECT name, unique_name FROM test\")\n        self.assertEqual(self.cu.fetchall(), [('Very different data!', 'foo')])", "\n\n@requires_subprocess()\nclass MultiprocessTests(unittest.TestCase):\n    CONNECTION_TIMEOUT = SHORT_TIMEOUT / 1000.  # Defaults to 30 ms\n\n    def tearDown(self):\n        unlink(TESTFN)\n\n    def test_ctx_mgr_rollback_if_commit_failed(self):\n        # bpo-27334: ctx manager does not rollback if commit fails\n        SCRIPT = f\"\"\"if 1:\n            import sqlite3\n            def wait():\n                print(\"started\")\n                assert \"database is locked\" in input()\n\n            cx = sqlite3.connect(\"{TESTFN}\", timeout={self.CONNECTION_TIMEOUT})\n            cx.create_function(\"wait\", 0, wait)\n            with cx:\n                cx.execute(\"create table t(t)\")\n            try:\n                # execute two transactions; both will try to lock the db\n                cx.executescript('''\n                    -- start a transaction and wait for parent\n                    begin transaction;\n                    select * from t;\n                    select wait();\n                    rollback;\n\n                    -- start a new transaction; would fail if parent holds lock\n                    begin transaction;\n                    select * from t;\n                    rollback;\n                ''')\n            finally:\n                cx.close()\n        \"\"\"\n\n        # spawn child process\n        proc = subprocess.Popen(\n            [sys.executable, \"-c\", SCRIPT],\n            encoding=\"utf-8\",\n            bufsize=0,\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE,\n        )\n        self.addCleanup(proc.communicate)\n\n        # wait for child process to start\n        self.assertEqual(\"started\", proc.stdout.readline().strip())\n\n        cx = sqlite.connect(TESTFN, timeout=self.CONNECTION_TIMEOUT)\n        try:  # context manager should correctly release the db lock\n            with cx:\n                cx.execute(\"insert into t values('test')\")\n        except sqlite.OperationalError as exc:\n            proc.stdin.write(str(exc))\n        else:\n            proc.stdin.write(\"no error\")\n        finally:\n            cx.close()\n\n        # terminate child process\n        self.assertIsNone(proc.returncode)\n        try:\n            proc.communicate(input=\"end\", timeout=SHORT_TIMEOUT)\n        except subprocess.TimeoutExpired:\n            proc.kill()\n            proc.communicate()\n            raise\n        self.assertEqual(proc.returncode, 0)", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/dbapi2/libsql_client_helpers.py", "chunked_list": ["import os\nimport re\n\nfrom libsql_client.dbapi2 import *\n\n\ndburi = os.getenv(\"URL\", \"ws://localhost:8080\")\n_orig_connect = connect\n_system_schema_re = re.compile(\"^(_|sqlite_|libsql_)\")\n", "_system_schema_re = re.compile(\"^(_|sqlite_|libsql_)\")\n\n\ndef drop_user_schemas(conn):\n    try:\n        cur = conn.execute(\"SELECT name, type FROM sqlite_schema\")\n    except Exception as e:\n        print(f\"WARNING: could not list sqlite_schema: {e}\")\n        return\n\n    for name, kind in cur.fetchall():\n        if _system_schema_re.match(name):\n            continue\n        try:\n            conn.execute(f\"drop {kind} '{name}'\")\n        except Exception as e:\n            print(f\"WARNING: could not drop {kind} {name}: {e}\")", "\n\ndef connect(database, *args, **kwargs):\n    drop_schema = False\n    if database == \":memory:\":\n        # most of the test suite uses :memory: for testing, so redirect\n        # those to our test server, but drop all user schema\n        database = dburi\n        kwargs[\"uri\"] = True\n        drop_schema = True\n    elif os.path.isdir(database):\n        # tests that open a folder expect to fail\n        database = \"wss://127.0.0.1:1\"\n        kwargs[\"uri\"] = True\n    else:\n        # keep intact, but they will be using sqlite3.connect and not\n        # our code, nevertheless this helps to test our compatibility\n        pass\n\n    conn = _orig_connect(database, *args, **kwargs)\n    if drop_schema:\n        drop_user_schemas(conn)\n    return conn", ""]}
{"filename": "tests/dbapi2/test_backup.py", "chunked_list": ["from . import libsql_client_helpers as sqlite\nimport unittest\n\n\n@unittest.skip(\"Not supported\")\nclass BackupTests(unittest.TestCase):\n    def setUp(self):\n        cx = self.cx = sqlite.connect(\":memory:\")\n        cx.execute('CREATE TABLE foo (key INTEGER)')\n        cx.executemany('INSERT INTO foo (key) VALUES (?)', [(3,), (4,)])\n        cx.commit()\n\n    def tearDown(self):\n        self.cx.close()\n\n    def verify_backup(self, bckcx):\n        result = bckcx.execute(\"SELECT key FROM foo ORDER BY key\").fetchall()\n        self.assertEqual(result[0][0], 3)\n        self.assertEqual(result[1][0], 4)\n\n    def test_bad_target(self):\n        with self.assertRaises(TypeError):\n            self.cx.backup(None)\n        with self.assertRaises(TypeError):\n            self.cx.backup()\n\n    def test_bad_target_filename(self):\n        with self.assertRaises(TypeError):\n            self.cx.backup('some_file_name.db')\n\n    def test_bad_target_same_connection(self):\n        with self.assertRaises(ValueError):\n            self.cx.backup(self.cx)\n\n    def test_bad_target_closed_connection(self):\n        bck = sqlite.connect(':memory:')\n        bck.close()\n        with self.assertRaises(sqlite.ProgrammingError):\n            self.cx.backup(bck)\n\n    def test_bad_source_closed_connection(self):\n        bck = sqlite.connect(':memory:')\n        source = sqlite.connect(\":memory:\")\n        source.close()\n        with self.assertRaises(sqlite.ProgrammingError):\n            source.backup(bck)\n\n    def test_bad_target_in_transaction(self):\n        bck = sqlite.connect(':memory:')\n        bck.execute('CREATE TABLE bar (key INTEGER)')\n        bck.executemany('INSERT INTO bar (key) VALUES (?)', [(3,), (4,)])\n        with self.assertRaises(sqlite.OperationalError) as cm:\n            self.cx.backup(bck)\n        if sqlite.sqlite_version_info < (3, 8, 8):\n            self.assertEqual(str(cm.exception), 'target is in transaction')\n\n    def test_keyword_only_args(self):\n        with self.assertRaises(TypeError):\n            with sqlite.connect(':memory:') as bck:\n                self.cx.backup(bck, 1)\n\n    def test_simple(self):\n        with sqlite.connect(':memory:') as bck:\n            self.cx.backup(bck)\n            self.verify_backup(bck)\n\n    def test_progress(self):\n        journal = []\n\n        def progress(status, remaining, total):\n            journal.append(status)\n\n        with sqlite.connect(':memory:') as bck:\n            self.cx.backup(bck, pages=1, progress=progress)\n            self.verify_backup(bck)\n\n        self.assertEqual(len(journal), 2)\n        self.assertEqual(journal[0], sqlite.SQLITE_OK)\n        self.assertEqual(journal[1], sqlite.SQLITE_DONE)\n\n    def test_progress_all_pages_at_once_1(self):\n        journal = []\n\n        def progress(status, remaining, total):\n            journal.append(remaining)\n\n        with sqlite.connect(':memory:') as bck:\n            self.cx.backup(bck, progress=progress)\n            self.verify_backup(bck)\n\n        self.assertEqual(len(journal), 1)\n        self.assertEqual(journal[0], 0)\n\n    def test_progress_all_pages_at_once_2(self):\n        journal = []\n\n        def progress(status, remaining, total):\n            journal.append(remaining)\n\n        with sqlite.connect(':memory:') as bck:\n            self.cx.backup(bck, pages=-1, progress=progress)\n            self.verify_backup(bck)\n\n        self.assertEqual(len(journal), 1)\n        self.assertEqual(journal[0], 0)\n\n    def test_non_callable_progress(self):\n        with self.assertRaises(TypeError) as cm:\n            with sqlite.connect(':memory:') as bck:\n                self.cx.backup(bck, pages=1, progress='bar')\n        self.assertEqual(str(cm.exception), 'progress argument must be a callable')\n\n    def test_modifying_progress(self):\n        journal = []\n\n        def progress(status, remaining, total):\n            if not journal:\n                self.cx.execute('INSERT INTO foo (key) VALUES (?)', (remaining+1000,))\n                self.cx.commit()\n            journal.append(remaining)\n\n        with sqlite.connect(':memory:') as bck:\n            self.cx.backup(bck, pages=1, progress=progress)\n            self.verify_backup(bck)\n\n            result = bck.execute(\"SELECT key FROM foo\"\n                                 \" WHERE key >= 1000\"\n                                 \" ORDER BY key\").fetchall()\n            self.assertEqual(result[0][0], 1001)\n\n        self.assertEqual(len(journal), 3)\n        self.assertEqual(journal[0], 1)\n        self.assertEqual(journal[1], 1)\n        self.assertEqual(journal[2], 0)\n\n    def test_failing_progress(self):\n        def progress(status, remaining, total):\n            raise SystemError('nearly out of space')\n\n        with self.assertRaises(SystemError) as err:\n            with sqlite.connect(':memory:') as bck:\n                self.cx.backup(bck, progress=progress)\n        self.assertEqual(str(err.exception), 'nearly out of space')\n\n    def test_database_source_name(self):\n        with sqlite.connect(':memory:') as bck:\n            self.cx.backup(bck, name='main')\n        with sqlite.connect(':memory:') as bck:\n            self.cx.backup(bck, name='temp')\n        with self.assertRaises(sqlite.OperationalError) as cm:\n            with sqlite.connect(':memory:') as bck:\n                self.cx.backup(bck, name='non-existing')\n        self.assertIn(\"unknown database\", str(cm.exception))\n\n        self.cx.execute(\"ATTACH DATABASE ':memory:' AS attached_db\")\n        self.cx.execute('CREATE TABLE attached_db.foo (key INTEGER)')\n        self.cx.executemany('INSERT INTO attached_db.foo (key) VALUES (?)', [(3,), (4,)])\n        self.cx.commit()\n        with sqlite.connect(':memory:') as bck:\n            self.cx.backup(bck, name='attached_db')\n            self.verify_backup(bck)", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/dbapi2/test_userfunctions.py", "chunked_list": ["# pysqlite2/test/userfunctions.py: tests for user-defined functions and\n#                                  aggregates.\n#\n# Copyright (C) 2005-2007 Gerhard H\u00e4ring <gh@ghaering.de>\n#\n# This file is part of pysqlite.\n#\n# This software is provided 'as-is', without any express or implied\n# warranty.  In no event will the authors be held liable for any damages\n# arising from the use of this software.", "# warranty.  In no event will the authors be held liable for any damages\n# arising from the use of this software.\n#\n# Permission is granted to anyone to use this software for any purpose,\n# including commercial applications, and to alter it and redistribute it\n# freely, subject to the following restrictions:\n#\n# 1. The origin of this software must not be misrepresented; you must not\n#    claim that you wrote the original software. If you use this software\n#    in a product, an acknowledgment in the product documentation would be", "#    claim that you wrote the original software. If you use this software\n#    in a product, an acknowledgment in the product documentation would be\n#    appreciated but is not required.\n# 2. Altered source versions must be plainly marked as such, and must not be\n#    misrepresented as being the original software.\n# 3. This notice may not be removed or altered from any source distribution.\n\nimport contextlib\nimport functools\nimport io", "import functools\nimport io\nimport re\nimport sys\nimport unittest\nfrom . import libsql_client_helpers as sqlite\n\nfrom unittest.mock import Mock, patch\nfrom test.support import bigmemtest, catch_unraisable_exception, gc_collect\n", "from test.support import bigmemtest, catch_unraisable_exception, gc_collect\n\nfrom .test_dbapi import cx_limit\n\n\ndef with_tracebacks(exc, regex=\"\", name=\"\"):\n    \"\"\"Convenience decorator for testing callback tracebacks.\"\"\"\n    def decorator(func):\n        _regex = re.compile(regex) if regex else None\n        @functools.wraps(func)\n        def wrapper(self, *args, **kwargs):\n            with catch_unraisable_exception() as cm:\n                # First, run the test with traceback enabled.\n                with check_tracebacks(self, cm, exc, _regex, name):\n                    func(self, *args, **kwargs)\n\n            # Then run the test with traceback disabled.\n            func(self, *args, **kwargs)\n        return wrapper\n    return decorator", "\n\n@contextlib.contextmanager\ndef check_tracebacks(self, cm, exc, regex, obj_name):\n    \"\"\"Convenience context manager for testing callback tracebacks.\"\"\"\n    sqlite.enable_callback_tracebacks(True)\n    try:\n        buf = io.StringIO()\n        with contextlib.redirect_stderr(buf):\n            yield\n\n        self.assertEqual(cm.unraisable.exc_type, exc)\n        if regex:\n            msg = str(cm.unraisable.exc_value)\n            self.assertIsNotNone(regex.search(msg))\n        if obj_name:\n            self.assertEqual(cm.unraisable.object.__name__, obj_name)\n    finally:\n        sqlite.enable_callback_tracebacks(False)", "\n\ndef func_returntext():\n    return \"foo\"\ndef func_returntextwithnull():\n    return \"1\\x002\"\ndef func_returnunicode():\n    return \"bar\"\ndef func_returnint():\n    return 42\ndef func_returnfloat():\n    return 3.14", "def func_returnint():\n    return 42\ndef func_returnfloat():\n    return 3.14\ndef func_returnnull():\n    return None\ndef func_returnblob():\n    return b\"blob\"\ndef func_returnlonglong():\n    return 1<<31\ndef func_raiseexception():\n    5/0", "def func_returnlonglong():\n    return 1<<31\ndef func_raiseexception():\n    5/0\ndef func_memoryerror():\n    raise MemoryError\ndef func_overflowerror():\n    raise OverflowError\n\nclass AggrNoStep:\n    def __init__(self):\n        pass\n\n    def finalize(self):\n        return 1", "\nclass AggrNoStep:\n    def __init__(self):\n        pass\n\n    def finalize(self):\n        return 1\n\nclass AggrNoFinalize:\n    def __init__(self):\n        pass\n\n    def step(self, x):\n        pass", "class AggrNoFinalize:\n    def __init__(self):\n        pass\n\n    def step(self, x):\n        pass\n\nclass AggrExceptionInInit:\n    def __init__(self):\n        5/0\n\n    def step(self, x):\n        pass\n\n    def finalize(self):\n        pass", "\nclass AggrExceptionInStep:\n    def __init__(self):\n        pass\n\n    def step(self, x):\n        5/0\n\n    def finalize(self):\n        return 42", "\nclass AggrExceptionInFinalize:\n    def __init__(self):\n        pass\n\n    def step(self, x):\n        pass\n\n    def finalize(self):\n        5/0", "\nclass AggrCheckType:\n    def __init__(self):\n        self.val = None\n\n    def step(self, whichType, val):\n        theType = {\"str\": str, \"int\": int, \"float\": float, \"None\": type(None),\n                   \"blob\": bytes}\n        self.val = int(theType[whichType] is type(val))\n\n    def finalize(self):\n        return self.val", "\nclass AggrCheckTypes:\n    def __init__(self):\n        self.val = 0\n\n    def step(self, whichType, *vals):\n        theType = {\"str\": str, \"int\": int, \"float\": float, \"None\": type(None),\n                   \"blob\": bytes}\n        for val in vals:\n            self.val += int(theType[whichType] is type(val))\n\n    def finalize(self):\n        return self.val", "\nclass AggrSum:\n    def __init__(self):\n        self.val = 0.0\n\n    def step(self, val):\n        self.val += val\n\n    def finalize(self):\n        return self.val", "\nclass AggrText:\n    def __init__(self):\n        self.txt = \"\"\n    def step(self, txt):\n        self.txt = self.txt + txt\n    def finalize(self):\n        return self.txt\n\n", "\n\n@unittest.skip(\"Not supported\")\nclass FunctionTests(unittest.TestCase):\n    def setUp(self):\n        self.con = sqlite.connect(\":memory:\")\n\n        self.con.create_function(\"returntext\", 0, func_returntext)\n        self.con.create_function(\"returntextwithnull\", 0, func_returntextwithnull)\n        self.con.create_function(\"returnunicode\", 0, func_returnunicode)\n        self.con.create_function(\"returnint\", 0, func_returnint)\n        self.con.create_function(\"returnfloat\", 0, func_returnfloat)\n        self.con.create_function(\"returnnull\", 0, func_returnnull)\n        self.con.create_function(\"returnblob\", 0, func_returnblob)\n        self.con.create_function(\"returnlonglong\", 0, func_returnlonglong)\n        self.con.create_function(\"returnnan\", 0, lambda: float(\"nan\"))\n        self.con.create_function(\"returntoolargeint\", 0, lambda: 1 << 65)\n        self.con.create_function(\"return_noncont_blob\", 0,\n                                 lambda: memoryview(b\"blob\")[::2])\n        self.con.create_function(\"raiseexception\", 0, func_raiseexception)\n        self.con.create_function(\"memoryerror\", 0, func_memoryerror)\n        self.con.create_function(\"overflowerror\", 0, func_overflowerror)\n\n        self.con.create_function(\"isblob\", 1, lambda x: isinstance(x, bytes))\n        self.con.create_function(\"isnone\", 1, lambda x: x is None)\n        self.con.create_function(\"spam\", -1, lambda *x: len(x))\n        self.con.execute(\"create table test(t text)\")\n\n    def tearDown(self):\n        self.con.close()\n\n    def test_func_error_on_create(self):\n        with self.assertRaises(sqlite.OperationalError):\n            self.con.create_function(\"bla\", -100, lambda x: 2*x)\n\n    def test_func_too_many_args(self):\n        category = sqlite.SQLITE_LIMIT_FUNCTION_ARG\n        msg = \"too many arguments on function\"\n        with cx_limit(self.con, category=category, limit=1):\n            self.con.execute(\"select abs(-1)\");\n            with self.assertRaisesRegex(sqlite.OperationalError, msg):\n                self.con.execute(\"select max(1, 2)\");\n\n    def test_func_ref_count(self):\n        def getfunc():\n            def f():\n                return 1\n            return f\n        f = getfunc()\n        globals()[\"foo\"] = f\n        # self.con.create_function(\"reftest\", 0, getfunc())\n        self.con.create_function(\"reftest\", 0, f)\n        cur = self.con.cursor()\n        cur.execute(\"select reftest()\")\n\n    def test_func_return_text(self):\n        cur = self.con.cursor()\n        cur.execute(\"select returntext()\")\n        val = cur.fetchone()[0]\n        self.assertEqual(type(val), str)\n        self.assertEqual(val, \"foo\")\n\n    def test_func_return_text_with_null_char(self):\n        cur = self.con.cursor()\n        res = cur.execute(\"select returntextwithnull()\").fetchone()[0]\n        self.assertEqual(type(res), str)\n        self.assertEqual(res, \"1\\x002\")\n\n    def test_func_return_unicode(self):\n        cur = self.con.cursor()\n        cur.execute(\"select returnunicode()\")\n        val = cur.fetchone()[0]\n        self.assertEqual(type(val), str)\n        self.assertEqual(val, \"bar\")\n\n    def test_func_return_int(self):\n        cur = self.con.cursor()\n        cur.execute(\"select returnint()\")\n        val = cur.fetchone()[0]\n        self.assertEqual(type(val), int)\n        self.assertEqual(val, 42)\n\n    def test_func_return_float(self):\n        cur = self.con.cursor()\n        cur.execute(\"select returnfloat()\")\n        val = cur.fetchone()[0]\n        self.assertEqual(type(val), float)\n        if val < 3.139 or val > 3.141:\n            self.fail(\"wrong value\")\n\n    def test_func_return_null(self):\n        cur = self.con.cursor()\n        cur.execute(\"select returnnull()\")\n        val = cur.fetchone()[0]\n        self.assertEqual(type(val), type(None))\n        self.assertEqual(val, None)\n\n    def test_func_return_blob(self):\n        cur = self.con.cursor()\n        cur.execute(\"select returnblob()\")\n        val = cur.fetchone()[0]\n        self.assertEqual(type(val), bytes)\n        self.assertEqual(val, b\"blob\")\n\n    def test_func_return_long_long(self):\n        cur = self.con.cursor()\n        cur.execute(\"select returnlonglong()\")\n        val = cur.fetchone()[0]\n        self.assertEqual(val, 1<<31)\n\n    def test_func_return_nan(self):\n        cur = self.con.cursor()\n        cur.execute(\"select returnnan()\")\n        self.assertIsNone(cur.fetchone()[0])\n\n    def test_func_return_too_large_int(self):\n        cur = self.con.cursor()\n        self.assertRaisesRegex(sqlite.DataError, \"string or blob too big\",\n                               self.con.execute, \"select returntoolargeint()\")\n\n    @with_tracebacks(ZeroDivisionError, name=\"func_raiseexception\")\n    def test_func_exception(self):\n        cur = self.con.cursor()\n        with self.assertRaises(sqlite.OperationalError) as cm:\n            cur.execute(\"select raiseexception()\")\n            cur.fetchone()\n        self.assertEqual(str(cm.exception), 'user-defined function raised exception')\n\n    @with_tracebacks(MemoryError, name=\"func_memoryerror\")\n    def test_func_memory_error(self):\n        cur = self.con.cursor()\n        with self.assertRaises(MemoryError):\n            cur.execute(\"select memoryerror()\")\n            cur.fetchone()\n\n    @with_tracebacks(OverflowError, name=\"func_overflowerror\")\n    def test_func_overflow_error(self):\n        cur = self.con.cursor()\n        with self.assertRaises(sqlite.DataError):\n            cur.execute(\"select overflowerror()\")\n            cur.fetchone()\n\n    def test_any_arguments(self):\n        cur = self.con.cursor()\n        cur.execute(\"select spam(?, ?)\", (1, 2))\n        val = cur.fetchone()[0]\n        self.assertEqual(val, 2)\n\n    def test_empty_blob(self):\n        cur = self.con.execute(\"select isblob(x'')\")\n        self.assertTrue(cur.fetchone()[0])\n\n    def test_nan_float(self):\n        cur = self.con.execute(\"select isnone(?)\", (float(\"nan\"),))\n        # SQLite has no concept of nan; it is converted to NULL\n        self.assertTrue(cur.fetchone()[0])\n\n    def test_too_large_int(self):\n        err = \"Python int too large to convert to SQLite INTEGER\"\n        self.assertRaisesRegex(OverflowError, err, self.con.execute,\n                               \"select spam(?)\", (1 << 65,))\n\n    def test_non_contiguous_blob(self):\n        self.assertRaisesRegex(BufferError,\n                               \"underlying buffer is not C-contiguous\",\n                               self.con.execute, \"select spam(?)\",\n                               (memoryview(b\"blob\")[::2],))\n\n    @with_tracebacks(BufferError, regex=\"buffer.*contiguous\")\n    def test_return_non_contiguous_blob(self):\n        with self.assertRaises(sqlite.OperationalError):\n            cur = self.con.execute(\"select return_noncont_blob()\")\n            cur.fetchone()\n\n    def test_param_surrogates(self):\n        self.assertRaisesRegex(UnicodeEncodeError, \"surrogates not allowed\",\n                               self.con.execute, \"select spam(?)\",\n                               (\"\\ud803\\ude6d\",))\n\n    def test_func_params(self):\n        results = []\n        def append_result(arg):\n            results.append((arg, type(arg)))\n        self.con.create_function(\"test_params\", 1, append_result)\n\n        dataset = [\n            (42, int),\n            (-1, int),\n            (1234567890123456789, int),\n            (4611686018427387905, int),  # 63-bit int with non-zero low bits\n            (3.14, float),\n            (float('inf'), float),\n            (\"text\", str),\n            (\"1\\x002\", str),\n            (\"\\u02e2q\\u02e1\\u2071\\u1d57\\u1d49\", str),\n            (b\"blob\", bytes),\n            (bytearray(range(2)), bytes),\n            (memoryview(b\"blob\"), bytes),\n            (None, type(None)),\n        ]\n        for val, _ in dataset:\n            cur = self.con.execute(\"select test_params(?)\", (val,))\n            cur.fetchone()\n        self.assertEqual(dataset, results)\n\n    # Regarding deterministic functions:\n    #\n    # Between 3.8.3 and 3.15.0, deterministic functions were only used to\n    # optimize inner loops, so for those versions we can only test if the\n    # sqlite machinery has factored out a call or not. From 3.15.0 and onward,\n    # deterministic functions were permitted in WHERE clauses of partial\n    # indices, which allows testing based on syntax, iso. the query optimizer.\n    @unittest.skipIf(sqlite.sqlite_version_info < (3, 8, 3), \"Requires SQLite 3.8.3 or higher\")\n    def test_func_non_deterministic(self):\n        mock = Mock(return_value=None)\n        self.con.create_function(\"nondeterministic\", 0, mock, deterministic=False)\n        if sqlite.sqlite_version_info < (3, 15, 0):\n            self.con.execute(\"select nondeterministic() = nondeterministic()\")\n            self.assertEqual(mock.call_count, 2)\n        else:\n            with self.assertRaises(sqlite.OperationalError):\n                self.con.execute(\"create index t on test(t) where nondeterministic() is not null\")\n\n    @unittest.skipIf(sqlite.sqlite_version_info < (3, 8, 3), \"Requires SQLite 3.8.3 or higher\")\n    def test_func_deterministic(self):\n        mock = Mock(return_value=None)\n        self.con.create_function(\"deterministic\", 0, mock, deterministic=True)\n        if sqlite.sqlite_version_info < (3, 15, 0):\n            self.con.execute(\"select deterministic() = deterministic()\")\n            self.assertEqual(mock.call_count, 1)\n        else:\n            try:\n                self.con.execute(\"create index t on test(t) where deterministic() is not null\")\n            except sqlite.OperationalError:\n                self.fail(\"Unexpected failure while creating partial index\")\n\n    @unittest.skipIf(sqlite.sqlite_version_info >= (3, 8, 3), \"SQLite < 3.8.3 needed\")\n    def test_func_deterministic_not_supported(self):\n        with self.assertRaises(sqlite.NotSupportedError):\n            self.con.create_function(\"deterministic\", 0, int, deterministic=True)\n\n    def test_func_deterministic_keyword_only(self):\n        with self.assertRaises(TypeError):\n            self.con.create_function(\"deterministic\", 0, int, True)\n\n    def test_function_destructor_via_gc(self):\n        # See bpo-44304: The destructor of the user function can\n        # crash if is called without the GIL from the gc functions\n        dest = sqlite.connect(':memory:')\n        def md5sum(t):\n            return\n\n        dest.create_function(\"md5\", 1, md5sum)\n        x = dest(\"create table lang (name, first_appeared)\")\n        del md5sum, dest\n\n        y = [x]\n        y.append(y)\n\n        del x,y\n        gc_collect()\n\n    @with_tracebacks(OverflowError)\n    def test_func_return_too_large_int(self):\n        cur = self.con.cursor()\n        for value in 2**63, -2**63-1, 2**64:\n            self.con.create_function(\"largeint\", 0, lambda value=value: value)\n            with self.assertRaises(sqlite.DataError):\n                cur.execute(\"select largeint()\")\n\n    @with_tracebacks(UnicodeEncodeError, \"surrogates not allowed\", \"chr\")\n    def test_func_return_text_with_surrogates(self):\n        cur = self.con.cursor()\n        self.con.create_function(\"pychr\", 1, chr)\n        for value in 0xd8ff, 0xdcff:\n            with self.assertRaises(sqlite.OperationalError):\n                cur.execute(\"select pychr(?)\", (value,))\n\n    @unittest.skipUnless(sys.maxsize > 2**32, 'requires 64bit platform')\n    @bigmemtest(size=2**31, memuse=3, dry_run=False)\n    def test_func_return_too_large_text(self, size):\n        cur = self.con.cursor()\n        for size in 2**31-1, 2**31:\n            self.con.create_function(\"largetext\", 0, lambda size=size: \"b\" * size)\n            with self.assertRaises(sqlite.DataError):\n                cur.execute(\"select largetext()\")\n\n    @unittest.skipUnless(sys.maxsize > 2**32, 'requires 64bit platform')\n    @bigmemtest(size=2**31, memuse=2, dry_run=False)\n    def test_func_return_too_large_blob(self, size):\n        cur = self.con.cursor()\n        for size in 2**31-1, 2**31:\n            self.con.create_function(\"largeblob\", 0, lambda size=size: b\"b\" * size)\n            with self.assertRaises(sqlite.DataError):\n                cur.execute(\"select largeblob()\")\n\n    def test_func_return_illegal_value(self):\n        self.con.create_function(\"badreturn\", 0, lambda: self)\n        msg = \"user-defined function raised exception\"\n        self.assertRaisesRegex(sqlite.OperationalError, msg,\n                               self.con.execute, \"select badreturn()\")", "\n\nclass WindowSumInt:\n    def __init__(self):\n        self.count = 0\n\n    def step(self, value):\n        self.count += value\n\n    def value(self):\n        return self.count\n\n    def inverse(self, value):\n        self.count -= value\n\n    def finalize(self):\n        return self.count", "\nclass BadWindow(Exception):\n    pass\n\n\n@unittest.skip(\"Not supported\")\n@unittest.skipIf(sqlite.sqlite_version_info < (3, 25, 0),\n                 \"Requires SQLite 3.25.0 or newer\")\nclass WindowFunctionTests(unittest.TestCase):\n    def setUp(self):\n        self.con = sqlite.connect(\":memory:\")\n        self.cur = self.con.cursor()\n\n        # Test case taken from https://www.sqlite.org/windowfunctions.html#udfwinfunc\n        values = [\n            (\"a\", 4),\n            (\"b\", 5),\n            (\"c\", 3),\n            (\"d\", 8),\n            (\"e\", 1),\n        ]\n        with self.con:\n            self.con.execute(\"create table test(x, y)\")\n            self.con.executemany(\"insert into test values(?, ?)\", values)\n        self.expected = [\n            (\"a\", 9),\n            (\"b\", 12),\n            (\"c\", 16),\n            (\"d\", 12),\n            (\"e\", 9),\n        ]\n        self.query = \"\"\"\n            select x, %s(y) over (\n                order by x rows between 1 preceding and 1 following\n            ) as sum_y\n            from test order by x\n        \"\"\"\n        self.con.create_window_function(\"sumint\", 1, WindowSumInt)\n\n    def test_win_sum_int(self):\n        self.cur.execute(self.query % \"sumint\")\n        self.assertEqual(self.cur.fetchall(), self.expected)\n\n    def test_win_error_on_create(self):\n        self.assertRaises(sqlite.ProgrammingError,\n                          self.con.create_window_function,\n                          \"shouldfail\", -100, WindowSumInt)\n\n    @with_tracebacks(BadWindow)\n    def test_win_exception_in_method(self):\n        for meth in \"__init__\", \"step\", \"value\", \"inverse\":\n            with self.subTest(meth=meth):\n                with patch.object(WindowSumInt, meth, side_effect=BadWindow):\n                    name = f\"exc_{meth}\"\n                    self.con.create_window_function(name, 1, WindowSumInt)\n                    msg = f\"'{meth}' method raised error\"\n                    with self.assertRaisesRegex(sqlite.OperationalError, msg):\n                        self.cur.execute(self.query % name)\n                        self.cur.fetchall()\n\n    @with_tracebacks(BadWindow)\n    def test_win_exception_in_finalize(self):\n        # Note: SQLite does not (as of version 3.38.0) propagate finalize\n        # callback errors to sqlite3_step(); this implies that OperationalError\n        # is _not_ raised.\n        with patch.object(WindowSumInt, \"finalize\", side_effect=BadWindow):\n            name = f\"exception_in_finalize\"\n            self.con.create_window_function(name, 1, WindowSumInt)\n            self.cur.execute(self.query % name)\n            self.cur.fetchall()\n\n    @with_tracebacks(AttributeError)\n    def test_win_missing_method(self):\n        class MissingValue:\n            def step(self, x): pass\n            def inverse(self, x): pass\n            def finalize(self): return 42\n\n        class MissingInverse:\n            def step(self, x): pass\n            def value(self): return 42\n            def finalize(self): return 42\n\n        class MissingStep:\n            def value(self): return 42\n            def inverse(self, x): pass\n            def finalize(self): return 42\n\n        dataset = (\n            (\"step\", MissingStep),\n            (\"value\", MissingValue),\n            (\"inverse\", MissingInverse),\n        )\n        for meth, cls in dataset:\n            with self.subTest(meth=meth, cls=cls):\n                name = f\"exc_{meth}\"\n                self.con.create_window_function(name, 1, cls)\n                with self.assertRaisesRegex(sqlite.OperationalError,\n                                            f\"'{meth}' method not defined\"):\n                    self.cur.execute(self.query % name)\n                    self.cur.fetchall()\n\n    @with_tracebacks(AttributeError)\n    def test_win_missing_finalize(self):\n        # Note: SQLite does not (as of version 3.38.0) propagate finalize\n        # callback errors to sqlite3_step(); this implies that OperationalError\n        # is _not_ raised.\n        class MissingFinalize:\n            def step(self, x): pass\n            def value(self): return 42\n            def inverse(self, x): pass\n\n        name = \"missing_finalize\"\n        self.con.create_window_function(name, 1, MissingFinalize)\n        self.cur.execute(self.query % name)\n        self.cur.fetchall()\n\n    def test_win_clear_function(self):\n        self.con.create_window_function(\"sumint\", 1, None)\n        self.assertRaises(sqlite.OperationalError, self.cur.execute,\n                          self.query % \"sumint\")\n\n    def test_win_redefine_function(self):\n        # Redefine WindowSumInt; adjust the expected results accordingly.\n        class Redefined(WindowSumInt):\n            def step(self, value): self.count += value * 2\n            def inverse(self, value): self.count -= value * 2\n        expected = [(v[0], v[1]*2) for v in self.expected]\n\n        self.con.create_window_function(\"sumint\", 1, Redefined)\n        self.cur.execute(self.query % \"sumint\")\n        self.assertEqual(self.cur.fetchall(), expected)\n\n    def test_win_error_value_return(self):\n        class ErrorValueReturn:\n            def __init__(self): pass\n            def step(self, x): pass\n            def value(self): return 1 << 65\n\n        self.con.create_window_function(\"err_val_ret\", 1, ErrorValueReturn)\n        self.assertRaisesRegex(sqlite.DataError, \"string or blob too big\",\n                               self.cur.execute, self.query % \"err_val_ret\")", "class WindowFunctionTests(unittest.TestCase):\n    def setUp(self):\n        self.con = sqlite.connect(\":memory:\")\n        self.cur = self.con.cursor()\n\n        # Test case taken from https://www.sqlite.org/windowfunctions.html#udfwinfunc\n        values = [\n            (\"a\", 4),\n            (\"b\", 5),\n            (\"c\", 3),\n            (\"d\", 8),\n            (\"e\", 1),\n        ]\n        with self.con:\n            self.con.execute(\"create table test(x, y)\")\n            self.con.executemany(\"insert into test values(?, ?)\", values)\n        self.expected = [\n            (\"a\", 9),\n            (\"b\", 12),\n            (\"c\", 16),\n            (\"d\", 12),\n            (\"e\", 9),\n        ]\n        self.query = \"\"\"\n            select x, %s(y) over (\n                order by x rows between 1 preceding and 1 following\n            ) as sum_y\n            from test order by x\n        \"\"\"\n        self.con.create_window_function(\"sumint\", 1, WindowSumInt)\n\n    def test_win_sum_int(self):\n        self.cur.execute(self.query % \"sumint\")\n        self.assertEqual(self.cur.fetchall(), self.expected)\n\n    def test_win_error_on_create(self):\n        self.assertRaises(sqlite.ProgrammingError,\n                          self.con.create_window_function,\n                          \"shouldfail\", -100, WindowSumInt)\n\n    @with_tracebacks(BadWindow)\n    def test_win_exception_in_method(self):\n        for meth in \"__init__\", \"step\", \"value\", \"inverse\":\n            with self.subTest(meth=meth):\n                with patch.object(WindowSumInt, meth, side_effect=BadWindow):\n                    name = f\"exc_{meth}\"\n                    self.con.create_window_function(name, 1, WindowSumInt)\n                    msg = f\"'{meth}' method raised error\"\n                    with self.assertRaisesRegex(sqlite.OperationalError, msg):\n                        self.cur.execute(self.query % name)\n                        self.cur.fetchall()\n\n    @with_tracebacks(BadWindow)\n    def test_win_exception_in_finalize(self):\n        # Note: SQLite does not (as of version 3.38.0) propagate finalize\n        # callback errors to sqlite3_step(); this implies that OperationalError\n        # is _not_ raised.\n        with patch.object(WindowSumInt, \"finalize\", side_effect=BadWindow):\n            name = f\"exception_in_finalize\"\n            self.con.create_window_function(name, 1, WindowSumInt)\n            self.cur.execute(self.query % name)\n            self.cur.fetchall()\n\n    @with_tracebacks(AttributeError)\n    def test_win_missing_method(self):\n        class MissingValue:\n            def step(self, x): pass\n            def inverse(self, x): pass\n            def finalize(self): return 42\n\n        class MissingInverse:\n            def step(self, x): pass\n            def value(self): return 42\n            def finalize(self): return 42\n\n        class MissingStep:\n            def value(self): return 42\n            def inverse(self, x): pass\n            def finalize(self): return 42\n\n        dataset = (\n            (\"step\", MissingStep),\n            (\"value\", MissingValue),\n            (\"inverse\", MissingInverse),\n        )\n        for meth, cls in dataset:\n            with self.subTest(meth=meth, cls=cls):\n                name = f\"exc_{meth}\"\n                self.con.create_window_function(name, 1, cls)\n                with self.assertRaisesRegex(sqlite.OperationalError,\n                                            f\"'{meth}' method not defined\"):\n                    self.cur.execute(self.query % name)\n                    self.cur.fetchall()\n\n    @with_tracebacks(AttributeError)\n    def test_win_missing_finalize(self):\n        # Note: SQLite does not (as of version 3.38.0) propagate finalize\n        # callback errors to sqlite3_step(); this implies that OperationalError\n        # is _not_ raised.\n        class MissingFinalize:\n            def step(self, x): pass\n            def value(self): return 42\n            def inverse(self, x): pass\n\n        name = \"missing_finalize\"\n        self.con.create_window_function(name, 1, MissingFinalize)\n        self.cur.execute(self.query % name)\n        self.cur.fetchall()\n\n    def test_win_clear_function(self):\n        self.con.create_window_function(\"sumint\", 1, None)\n        self.assertRaises(sqlite.OperationalError, self.cur.execute,\n                          self.query % \"sumint\")\n\n    def test_win_redefine_function(self):\n        # Redefine WindowSumInt; adjust the expected results accordingly.\n        class Redefined(WindowSumInt):\n            def step(self, value): self.count += value * 2\n            def inverse(self, value): self.count -= value * 2\n        expected = [(v[0], v[1]*2) for v in self.expected]\n\n        self.con.create_window_function(\"sumint\", 1, Redefined)\n        self.cur.execute(self.query % \"sumint\")\n        self.assertEqual(self.cur.fetchall(), expected)\n\n    def test_win_error_value_return(self):\n        class ErrorValueReturn:\n            def __init__(self): pass\n            def step(self, x): pass\n            def value(self): return 1 << 65\n\n        self.con.create_window_function(\"err_val_ret\", 1, ErrorValueReturn)\n        self.assertRaisesRegex(sqlite.DataError, \"string or blob too big\",\n                               self.cur.execute, self.query % \"err_val_ret\")", "\n\n@unittest.skip(\"Not supported\")\nclass AggregateTests(unittest.TestCase):\n    def setUp(self):\n        self.con = sqlite.connect(\":memory:\")\n        cur = self.con.cursor()\n        cur.execute(\"\"\"\n            create table test(\n                t text,\n                i integer,\n                f float,\n                n,\n                b blob\n                )\n            \"\"\")\n        cur.execute(\"insert into test(t, i, f, n, b) values (?, ?, ?, ?, ?)\",\n            (\"foo\", 5, 3.14, None, memoryview(b\"blob\"),))\n\n        self.con.create_aggregate(\"nostep\", 1, AggrNoStep)\n        self.con.create_aggregate(\"nofinalize\", 1, AggrNoFinalize)\n        self.con.create_aggregate(\"excInit\", 1, AggrExceptionInInit)\n        self.con.create_aggregate(\"excStep\", 1, AggrExceptionInStep)\n        self.con.create_aggregate(\"excFinalize\", 1, AggrExceptionInFinalize)\n        self.con.create_aggregate(\"checkType\", 2, AggrCheckType)\n        self.con.create_aggregate(\"checkTypes\", -1, AggrCheckTypes)\n        self.con.create_aggregate(\"mysum\", 1, AggrSum)\n        self.con.create_aggregate(\"aggtxt\", 1, AggrText)\n\n    def tearDown(self):\n        #self.cur.close()\n        #self.con.close()\n        pass\n\n    def test_aggr_error_on_create(self):\n        with self.assertRaises(sqlite.OperationalError):\n            self.con.create_function(\"bla\", -100, AggrSum)\n\n    @with_tracebacks(AttributeError, name=\"AggrNoStep\")\n    def test_aggr_no_step(self):\n        cur = self.con.cursor()\n        with self.assertRaises(sqlite.OperationalError) as cm:\n            cur.execute(\"select nostep(t) from test\")\n        self.assertEqual(str(cm.exception),\n                         \"user-defined aggregate's 'step' method not defined\")\n\n    def test_aggr_no_finalize(self):\n        cur = self.con.cursor()\n        msg = \"user-defined aggregate's 'finalize' method not defined\"\n        with self.assertRaisesRegex(sqlite.OperationalError, msg):\n            cur.execute(\"select nofinalize(t) from test\")\n            val = cur.fetchone()[0]\n\n    @with_tracebacks(ZeroDivisionError, name=\"AggrExceptionInInit\")\n    def test_aggr_exception_in_init(self):\n        cur = self.con.cursor()\n        with self.assertRaises(sqlite.OperationalError) as cm:\n            cur.execute(\"select excInit(t) from test\")\n            val = cur.fetchone()[0]\n        self.assertEqual(str(cm.exception), \"user-defined aggregate's '__init__' method raised error\")\n\n    @with_tracebacks(ZeroDivisionError, name=\"AggrExceptionInStep\")\n    def test_aggr_exception_in_step(self):\n        cur = self.con.cursor()\n        with self.assertRaises(sqlite.OperationalError) as cm:\n            cur.execute(\"select excStep(t) from test\")\n            val = cur.fetchone()[0]\n        self.assertEqual(str(cm.exception), \"user-defined aggregate's 'step' method raised error\")\n\n    @with_tracebacks(ZeroDivisionError, name=\"AggrExceptionInFinalize\")\n    def test_aggr_exception_in_finalize(self):\n        cur = self.con.cursor()\n        with self.assertRaises(sqlite.OperationalError) as cm:\n            cur.execute(\"select excFinalize(t) from test\")\n            val = cur.fetchone()[0]\n        self.assertEqual(str(cm.exception), \"user-defined aggregate's 'finalize' method raised error\")\n\n    def test_aggr_check_param_str(self):\n        cur = self.con.cursor()\n        cur.execute(\"select checkTypes('str', ?, ?)\", (\"foo\", str()))\n        val = cur.fetchone()[0]\n        self.assertEqual(val, 2)\n\n    def test_aggr_check_param_int(self):\n        cur = self.con.cursor()\n        cur.execute(\"select checkType('int', ?)\", (42,))\n        val = cur.fetchone()[0]\n        self.assertEqual(val, 1)\n\n    def test_aggr_check_params_int(self):\n        cur = self.con.cursor()\n        cur.execute(\"select checkTypes('int', ?, ?)\", (42, 24))\n        val = cur.fetchone()[0]\n        self.assertEqual(val, 2)\n\n    def test_aggr_check_param_float(self):\n        cur = self.con.cursor()\n        cur.execute(\"select checkType('float', ?)\", (3.14,))\n        val = cur.fetchone()[0]\n        self.assertEqual(val, 1)\n\n    def test_aggr_check_param_none(self):\n        cur = self.con.cursor()\n        cur.execute(\"select checkType('None', ?)\", (None,))\n        val = cur.fetchone()[0]\n        self.assertEqual(val, 1)\n\n    def test_aggr_check_param_blob(self):\n        cur = self.con.cursor()\n        cur.execute(\"select checkType('blob', ?)\", (memoryview(b\"blob\"),))\n        val = cur.fetchone()[0]\n        self.assertEqual(val, 1)\n\n    def test_aggr_check_aggr_sum(self):\n        cur = self.con.cursor()\n        cur.execute(\"delete from test\")\n        cur.executemany(\"insert into test(i) values (?)\", [(10,), (20,), (30,)])\n        cur.execute(\"select mysum(i) from test\")\n        val = cur.fetchone()[0]\n        self.assertEqual(val, 60)\n\n    def test_aggr_no_match(self):\n        cur = self.con.execute(\"select mysum(i) from (select 1 as i) where i == 0\")\n        val = cur.fetchone()[0]\n        self.assertIsNone(val)\n\n    def test_aggr_text(self):\n        cur = self.con.cursor()\n        for txt in [\"foo\", \"1\\x002\"]:\n            with self.subTest(txt=txt):\n                cur.execute(\"select aggtxt(?) from test\", (txt,))\n                val = cur.fetchone()[0]\n                self.assertEqual(val, txt)", "\n\n@unittest.skip(\"Not supported\")\nclass AuthorizerTests(unittest.TestCase):\n    @staticmethod\n    def authorizer_cb(action, arg1, arg2, dbname, source):\n        if action != sqlite.SQLITE_SELECT:\n            return sqlite.SQLITE_DENY\n        if arg2 == 'c2' or arg1 == 't2':\n            return sqlite.SQLITE_DENY\n        return sqlite.SQLITE_OK\n\n    def setUp(self):\n        self.con = sqlite.connect(\":memory:\")\n        self.con.executescript(\"\"\"\n            create table t1 (c1, c2);\n            create table t2 (c1, c2);\n            insert into t1 (c1, c2) values (1, 2);\n            insert into t2 (c1, c2) values (4, 5);\n            \"\"\")\n\n        # For our security test:\n        self.con.execute(\"select c2 from t2\")\n\n        self.con.set_authorizer(self.authorizer_cb)\n\n    def tearDown(self):\n        pass\n\n    def test_table_access(self):\n        with self.assertRaises(sqlite.DatabaseError) as cm:\n            self.con.execute(\"select * from t2\")\n        self.assertIn('prohibited', str(cm.exception))\n\n    def test_column_access(self):\n        with self.assertRaises(sqlite.DatabaseError) as cm:\n            self.con.execute(\"select c2 from t1\")\n        self.assertIn('prohibited', str(cm.exception))\n\n    def test_clear_authorizer(self):\n        self.con.set_authorizer(None)\n        self.con.execute(\"select * from t2\")\n        self.con.execute(\"select c2 from t1\")", "\n\nclass AuthorizerRaiseExceptionTests(AuthorizerTests):\n    @staticmethod\n    def authorizer_cb(action, arg1, arg2, dbname, source):\n        if action != sqlite.SQLITE_SELECT:\n            raise ValueError\n        if arg2 == 'c2' or arg1 == 't2':\n            raise ValueError\n        return sqlite.SQLITE_OK\n\n    @with_tracebacks(ValueError, name=\"authorizer_cb\")\n    def test_table_access(self):\n        super().test_table_access()\n\n    @with_tracebacks(ValueError, name=\"authorizer_cb\")\n    def test_column_access(self):\n        super().test_table_access()", "\nclass AuthorizerIllegalTypeTests(AuthorizerTests):\n    @staticmethod\n    def authorizer_cb(action, arg1, arg2, dbname, source):\n        if action != sqlite.SQLITE_SELECT:\n            return 0.0\n        if arg2 == 'c2' or arg1 == 't2':\n            return 0.0\n        return sqlite.SQLITE_OK\n\nclass AuthorizerLargeIntegerTests(AuthorizerTests):\n    @staticmethod\n    def authorizer_cb(action, arg1, arg2, dbname, source):\n        if action != sqlite.SQLITE_SELECT:\n            return 2**32\n        if arg2 == 'c2' or arg1 == 't2':\n            return 2**32\n        return sqlite.SQLITE_OK", "\nclass AuthorizerLargeIntegerTests(AuthorizerTests):\n    @staticmethod\n    def authorizer_cb(action, arg1, arg2, dbname, source):\n        if action != sqlite.SQLITE_SELECT:\n            return 2**32\n        if arg2 == 'c2' or arg1 == 't2':\n            return 2**32\n        return sqlite.SQLITE_OK\n", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "tests/dbapi2/test_transactions.py", "chunked_list": ["# pysqlite2/test/transactions.py: tests transactions\n#\n# Copyright (C) 2005-2007 Gerhard H\u00e4ring <gh@ghaering.de>\n#\n# This file is part of pysqlite.\n#\n# This software is provided 'as-is', without any express or implied\n# warranty.  In no event will the authors be held liable for any damages\n# arising from the use of this software.\n#", "# arising from the use of this software.\n#\n# Permission is granted to anyone to use this software for any purpose,\n# including commercial applications, and to alter it and redistribute it\n# freely, subject to the following restrictions:\n#\n# 1. The origin of this software must not be misrepresented; you must not\n#    claim that you wrote the original software. If you use this software\n#    in a product, an acknowledgment in the product documentation would be\n#    appreciated but is not required.", "#    in a product, an acknowledgment in the product documentation would be\n#    appreciated but is not required.\n# 2. Altered source versions must be plainly marked as such, and must not be\n#    misrepresented as being the original software.\n# 3. This notice may not be removed or altered from any source distribution.\n\nimport os, unittest\nfrom . import libsql_client_helpers as sqlite\n\nfrom test.support import LOOPBACK_TIMEOUT", "\nfrom test.support import LOOPBACK_TIMEOUT\nfrom test.support.os_helper import TESTFN, unlink\n\nfrom .test_dbapi import memory_database\n\n\nTIMEOUT = LOOPBACK_TIMEOUT / 10\n\n\nclass TransactionTests(unittest.TestCase):\n    def setUp(self):\n        self.con1 = sqlite.connect(TESTFN, timeout=TIMEOUT)\n        self.cur1 = self.con1.cursor()\n\n        self.con2 = sqlite.connect(TESTFN, timeout=TIMEOUT)\n        self.cur2 = self.con2.cursor()\n\n    def tearDown(self):\n        try:\n            self.cur1.close()\n            self.con1.close()\n\n            self.cur2.close()\n            self.con2.close()\n\n        finally:\n            unlink(TESTFN)\n\n    def test_dml_does_not_auto_commit_before(self):\n        self.cur1.execute(\"create table test(i)\")\n        self.cur1.execute(\"insert into test(i) values (5)\")\n        self.cur1.execute(\"create table test2(j)\")\n        self.cur2.execute(\"select i from test\")\n        res = self.cur2.fetchall()\n        self.assertEqual(len(res), 0)\n\n    def test_insert_starts_transaction(self):\n        self.cur1.execute(\"create table test(i)\")\n        self.cur1.execute(\"insert into test(i) values (5)\")\n        self.cur2.execute(\"select i from test\")\n        res = self.cur2.fetchall()\n        self.assertEqual(len(res), 0)\n\n    def test_update_starts_transaction(self):\n        self.cur1.execute(\"create table test(i)\")\n        self.cur1.execute(\"insert into test(i) values (5)\")\n        self.con1.commit()\n        self.cur1.execute(\"update test set i=6\")\n        self.cur2.execute(\"select i from test\")\n        res = self.cur2.fetchone()[0]\n        self.assertEqual(res, 5)\n\n    def test_delete_starts_transaction(self):\n        self.cur1.execute(\"create table test(i)\")\n        self.cur1.execute(\"insert into test(i) values (5)\")\n        self.con1.commit()\n        self.cur1.execute(\"delete from test\")\n        self.cur2.execute(\"select i from test\")\n        res = self.cur2.fetchall()\n        self.assertEqual(len(res), 1)\n\n    def test_replace_starts_transaction(self):\n        self.cur1.execute(\"create table test(i)\")\n        self.cur1.execute(\"insert into test(i) values (5)\")\n        self.con1.commit()\n        self.cur1.execute(\"replace into test(i) values (6)\")\n        self.cur2.execute(\"select i from test\")\n        res = self.cur2.fetchall()\n        self.assertEqual(len(res), 1)\n        self.assertEqual(res[0][0], 5)\n\n    def test_toggle_auto_commit(self):\n        self.cur1.execute(\"create table test(i)\")\n        self.cur1.execute(\"insert into test(i) values (5)\")\n        self.con1.isolation_level = None\n        self.assertEqual(self.con1.isolation_level, None)\n        self.cur2.execute(\"select i from test\")\n        res = self.cur2.fetchall()\n        self.assertEqual(len(res), 1)\n\n        self.con1.isolation_level = \"DEFERRED\"\n        self.assertEqual(self.con1.isolation_level , \"DEFERRED\")\n        self.cur1.execute(\"insert into test(i) values (5)\")\n        self.cur2.execute(\"select i from test\")\n        res = self.cur2.fetchall()\n        self.assertEqual(len(res), 1)\n\n    def test_raise_timeout(self):\n        self.cur1.execute(\"create table test(i)\")\n        self.cur1.execute(\"insert into test(i) values (5)\")\n        with self.assertRaises(sqlite.OperationalError):\n            self.cur2.execute(\"insert into test(i) values (5)\")\n\n    def test_locking(self):\n        \"\"\"\n        This tests the improved concurrency with pysqlite 2.3.4. You needed\n        to roll back con2 before you could commit con1.\n        \"\"\"\n        self.cur1.execute(\"create table test(i)\")\n        self.cur1.execute(\"insert into test(i) values (5)\")\n        with self.assertRaises(sqlite.OperationalError):\n            self.cur2.execute(\"insert into test(i) values (5)\")\n        # NO self.con2.rollback() HERE!!!\n        self.con1.commit()\n\n    def test_rollback_cursor_consistency(self):\n        \"\"\"Check that cursors behave correctly after rollback.\"\"\"\n        con = sqlite.connect(\":memory:\")\n        cur = con.cursor()\n        cur.execute(\"create table test(x)\")\n        cur.execute(\"insert into test(x) values (5)\")\n        cur.execute(\"select 1 union select 2 union select 3\")\n\n        con.rollback()\n        self.assertEqual(cur.fetchall(), [(1,), (2,), (3,)])\n\n    def test_multiple_cursors_and_iternext(self):\n        # gh-94028: statements are cleared and reset in cursor iternext.\n\n        # Provoke the gh-94028 by using a cursor cache.\n        CURSORS = {}\n        def sql(cx, sql, *args):\n            cu = cx.cursor()\n            cu.execute(sql, args)\n            CURSORS[id(sql)] = cu\n            return cu\n\n        self.con1.execute(\"create table t(t)\")\n        sql(self.con1, \"insert into t values (?), (?), (?)\", \"u1\", \"u2\", \"u3\")\n        self.con1.commit()\n\n        # On second connection, verify rows are visible, then delete them.\n        count = sql(self.con2, \"select count(*) from t\").fetchone()[0]\n        self.assertEqual(count, 3)\n        changes = sql(self.con2, \"delete from t\").rowcount\n        self.assertEqual(changes, 3)\n        self.con2.commit()\n\n        # Back in original connection, create 2 new users.\n        sql(self.con1, \"insert into t values (?)\", \"u4\")\n        sql(self.con1, \"insert into t values (?)\", \"u5\")\n\n        # The second connection cannot see uncommitted changes.\n        count = sql(self.con2, \"select count(*) from t\").fetchone()[0]\n        self.assertEqual(count, 0)\n\n        # First connection can see its own changes.\n        count = sql(self.con1, \"select count(*) from t\").fetchone()[0]\n        self.assertEqual(count, 2)\n\n        # The second connection can now see the changes.\n        self.con1.commit()\n        count = sql(self.con2, \"select count(*) from t\").fetchone()[0]\n        self.assertEqual(count, 2)", "\n\nclass TransactionTests(unittest.TestCase):\n    def setUp(self):\n        self.con1 = sqlite.connect(TESTFN, timeout=TIMEOUT)\n        self.cur1 = self.con1.cursor()\n\n        self.con2 = sqlite.connect(TESTFN, timeout=TIMEOUT)\n        self.cur2 = self.con2.cursor()\n\n    def tearDown(self):\n        try:\n            self.cur1.close()\n            self.con1.close()\n\n            self.cur2.close()\n            self.con2.close()\n\n        finally:\n            unlink(TESTFN)\n\n    def test_dml_does_not_auto_commit_before(self):\n        self.cur1.execute(\"create table test(i)\")\n        self.cur1.execute(\"insert into test(i) values (5)\")\n        self.cur1.execute(\"create table test2(j)\")\n        self.cur2.execute(\"select i from test\")\n        res = self.cur2.fetchall()\n        self.assertEqual(len(res), 0)\n\n    def test_insert_starts_transaction(self):\n        self.cur1.execute(\"create table test(i)\")\n        self.cur1.execute(\"insert into test(i) values (5)\")\n        self.cur2.execute(\"select i from test\")\n        res = self.cur2.fetchall()\n        self.assertEqual(len(res), 0)\n\n    def test_update_starts_transaction(self):\n        self.cur1.execute(\"create table test(i)\")\n        self.cur1.execute(\"insert into test(i) values (5)\")\n        self.con1.commit()\n        self.cur1.execute(\"update test set i=6\")\n        self.cur2.execute(\"select i from test\")\n        res = self.cur2.fetchone()[0]\n        self.assertEqual(res, 5)\n\n    def test_delete_starts_transaction(self):\n        self.cur1.execute(\"create table test(i)\")\n        self.cur1.execute(\"insert into test(i) values (5)\")\n        self.con1.commit()\n        self.cur1.execute(\"delete from test\")\n        self.cur2.execute(\"select i from test\")\n        res = self.cur2.fetchall()\n        self.assertEqual(len(res), 1)\n\n    def test_replace_starts_transaction(self):\n        self.cur1.execute(\"create table test(i)\")\n        self.cur1.execute(\"insert into test(i) values (5)\")\n        self.con1.commit()\n        self.cur1.execute(\"replace into test(i) values (6)\")\n        self.cur2.execute(\"select i from test\")\n        res = self.cur2.fetchall()\n        self.assertEqual(len(res), 1)\n        self.assertEqual(res[0][0], 5)\n\n    def test_toggle_auto_commit(self):\n        self.cur1.execute(\"create table test(i)\")\n        self.cur1.execute(\"insert into test(i) values (5)\")\n        self.con1.isolation_level = None\n        self.assertEqual(self.con1.isolation_level, None)\n        self.cur2.execute(\"select i from test\")\n        res = self.cur2.fetchall()\n        self.assertEqual(len(res), 1)\n\n        self.con1.isolation_level = \"DEFERRED\"\n        self.assertEqual(self.con1.isolation_level , \"DEFERRED\")\n        self.cur1.execute(\"insert into test(i) values (5)\")\n        self.cur2.execute(\"select i from test\")\n        res = self.cur2.fetchall()\n        self.assertEqual(len(res), 1)\n\n    def test_raise_timeout(self):\n        self.cur1.execute(\"create table test(i)\")\n        self.cur1.execute(\"insert into test(i) values (5)\")\n        with self.assertRaises(sqlite.OperationalError):\n            self.cur2.execute(\"insert into test(i) values (5)\")\n\n    def test_locking(self):\n        \"\"\"\n        This tests the improved concurrency with pysqlite 2.3.4. You needed\n        to roll back con2 before you could commit con1.\n        \"\"\"\n        self.cur1.execute(\"create table test(i)\")\n        self.cur1.execute(\"insert into test(i) values (5)\")\n        with self.assertRaises(sqlite.OperationalError):\n            self.cur2.execute(\"insert into test(i) values (5)\")\n        # NO self.con2.rollback() HERE!!!\n        self.con1.commit()\n\n    def test_rollback_cursor_consistency(self):\n        \"\"\"Check that cursors behave correctly after rollback.\"\"\"\n        con = sqlite.connect(\":memory:\")\n        cur = con.cursor()\n        cur.execute(\"create table test(x)\")\n        cur.execute(\"insert into test(x) values (5)\")\n        cur.execute(\"select 1 union select 2 union select 3\")\n\n        con.rollback()\n        self.assertEqual(cur.fetchall(), [(1,), (2,), (3,)])\n\n    def test_multiple_cursors_and_iternext(self):\n        # gh-94028: statements are cleared and reset in cursor iternext.\n\n        # Provoke the gh-94028 by using a cursor cache.\n        CURSORS = {}\n        def sql(cx, sql, *args):\n            cu = cx.cursor()\n            cu.execute(sql, args)\n            CURSORS[id(sql)] = cu\n            return cu\n\n        self.con1.execute(\"create table t(t)\")\n        sql(self.con1, \"insert into t values (?), (?), (?)\", \"u1\", \"u2\", \"u3\")\n        self.con1.commit()\n\n        # On second connection, verify rows are visible, then delete them.\n        count = sql(self.con2, \"select count(*) from t\").fetchone()[0]\n        self.assertEqual(count, 3)\n        changes = sql(self.con2, \"delete from t\").rowcount\n        self.assertEqual(changes, 3)\n        self.con2.commit()\n\n        # Back in original connection, create 2 new users.\n        sql(self.con1, \"insert into t values (?)\", \"u4\")\n        sql(self.con1, \"insert into t values (?)\", \"u5\")\n\n        # The second connection cannot see uncommitted changes.\n        count = sql(self.con2, \"select count(*) from t\").fetchone()[0]\n        self.assertEqual(count, 0)\n\n        # First connection can see its own changes.\n        count = sql(self.con1, \"select count(*) from t\").fetchone()[0]\n        self.assertEqual(count, 2)\n\n        # The second connection can now see the changes.\n        self.con1.commit()\n        count = sql(self.con2, \"select count(*) from t\").fetchone()[0]\n        self.assertEqual(count, 2)", "\n\nclass RollbackTests(unittest.TestCase):\n    \"\"\"bpo-44092: sqlite3 now leaves it to SQLite to resolve rollback issues\"\"\"\n\n    def setUp(self):\n        self.con = sqlite.connect(\":memory:\")\n        self.cur1 = self.con.cursor()\n        self.cur2 = self.con.cursor()\n        with self.con:\n            self.con.execute(\"create table t(c)\");\n            self.con.executemany(\"insert into t values(?)\", [(0,), (1,), (2,)])\n        self.cur1.execute(\"begin transaction\")\n        select = \"select c from t\"\n        self.cur1.execute(select)\n        self.con.rollback()\n        self.res = self.cur2.execute(select)  # Reusing stmt from cache\n\n    def tearDown(self):\n        self.con.close()\n\n    def _check_rows(self):\n        for i, row in enumerate(self.res):\n            self.assertEqual(row[0], i)\n\n    def test_no_duplicate_rows_after_rollback_del_cursor(self):\n        del self.cur1\n        self._check_rows()\n\n    def test_no_duplicate_rows_after_rollback_close_cursor(self):\n        self.cur1.close()\n        self._check_rows()\n\n    def test_no_duplicate_rows_after_rollback_new_query(self):\n        self.cur1.execute(\"select c from t where c = 1\")\n        self._check_rows()", "\n\n\nclass SpecialCommandTests(unittest.TestCase):\n    def setUp(self):\n        self.con = sqlite.connect(\":memory:\")\n        self.cur = self.con.cursor()\n\n    def test_drop_table(self):\n        self.cur.execute(\"create table test(i)\")\n        self.cur.execute(\"insert into test(i) values (5)\")\n        self.cur.execute(\"drop table test\")\n\n    def test_pragma(self):\n        self.cur.execute(\"create table test(i)\")\n        self.cur.execute(\"insert into test(i) values (5)\")\n        self.cur.execute(\"pragma foreign_keys = ON\")\n\n    def tearDown(self):\n        self.cur.close()\n        self.con.close()", "\n\nclass TransactionalDDL(unittest.TestCase):\n    def setUp(self):\n        self.con = sqlite.connect(\":memory:\")\n\n    def test_ddl_does_not_autostart_transaction(self):\n        # For backwards compatibility reasons, DDL statements should not\n        # implicitly start a transaction.\n        self.con.execute(\"create table test(i)\")\n        self.con.rollback()\n        result = self.con.execute(\"select * from test\").fetchall()\n        self.assertEqual(result, [])\n\n    def test_immediate_transactional_ddl(self):\n        # You can achieve transactional DDL by issuing a BEGIN\n        # statement manually.\n        self.con.execute(\"begin immediate\")\n        self.con.execute(\"create table test(i)\")\n        self.con.rollback()\n        with self.assertRaises(sqlite.OperationalError):\n            self.con.execute(\"select * from test\")\n\n    def test_transactional_ddl(self):\n        # You can achieve transactional DDL by issuing a BEGIN\n        # statement manually.\n        self.con.execute(\"begin\")\n        self.con.execute(\"create table test(i)\")\n        self.con.rollback()\n        with self.assertRaises(sqlite.OperationalError):\n            self.con.execute(\"select * from test\")\n\n    def tearDown(self):\n        self.con.close()", "\n\nclass IsolationLevelFromInit(unittest.TestCase):\n    CREATE = \"create table t(t)\"\n    INSERT = \"insert into t values(1)\"\n\n    def setUp(self):\n        self.traced = []\n\n    def _run_test(self, cx):\n        cx.execute(self.CREATE)\n        cx.set_trace_callback(lambda stmt: self.traced.append(stmt))\n        with cx:\n            cx.execute(self.INSERT)\n\n    def test_isolation_level_default(self):\n        with memory_database() as cx:\n            self._run_test(cx)\n            self.assertEqual(self.traced, [\"BEGIN \", self.INSERT, \"COMMIT\"])\n\n    def test_isolation_level_begin(self):\n        with memory_database(isolation_level=\"\") as cx:\n            self._run_test(cx)\n            self.assertEqual(self.traced, [\"BEGIN \", self.INSERT, \"COMMIT\"])\n\n    def test_isolation_level_deferred(self):\n        with memory_database(isolation_level=\"DEFERRED\") as cx:\n            self._run_test(cx)\n            self.assertEqual(self.traced, [\"BEGIN DEFERRED\", self.INSERT, \"COMMIT\"])\n\n    def test_isolation_level_immediate(self):\n        with memory_database(isolation_level=\"IMMEDIATE\") as cx:\n            self._run_test(cx)\n            self.assertEqual(self.traced,\n                             [\"BEGIN IMMEDIATE\", self.INSERT, \"COMMIT\"])\n\n    def test_isolation_level_exclusive(self):\n        with memory_database(isolation_level=\"EXCLUSIVE\") as cx:\n            self._run_test(cx)\n            self.assertEqual(self.traced,\n                             [\"BEGIN EXCLUSIVE\", self.INSERT, \"COMMIT\"])\n\n    def test_isolation_level_none(self):\n        with memory_database(isolation_level=None) as cx:\n            self._run_test(cx)\n            self.assertEqual(self.traced, [self.INSERT])", "\n\nclass IsolationLevelPostInit(unittest.TestCase):\n    QUERY = \"insert into t values(1)\"\n\n    def setUp(self):\n        self.cx = sqlite.connect(\":memory:\")\n        self.cx.execute(\"create table t(t)\")\n        self.traced = []\n        self.cx.set_trace_callback(lambda stmt: self.traced.append(stmt))\n\n    def tearDown(self):\n        self.cx.close()\n\n    def test_isolation_level_default(self):\n        with self.cx:\n            self.cx.execute(self.QUERY)\n        self.assertEqual(self.traced, [\"BEGIN \", self.QUERY, \"COMMIT\"])\n\n    def test_isolation_level_begin(self):\n        self.cx.isolation_level = \"\"\n        with self.cx:\n            self.cx.execute(self.QUERY)\n        self.assertEqual(self.traced, [\"BEGIN \", self.QUERY, \"COMMIT\"])\n\n    def test_isolation_level_deferrred(self):\n        self.cx.isolation_level = \"DEFERRED\"\n        with self.cx:\n            self.cx.execute(self.QUERY)\n        self.assertEqual(self.traced, [\"BEGIN DEFERRED\", self.QUERY, \"COMMIT\"])\n\n    def test_isolation_level_immediate(self):\n        self.cx.isolation_level = \"IMMEDIATE\"\n        with self.cx:\n            self.cx.execute(self.QUERY)\n        self.assertEqual(self.traced,\n                         [\"BEGIN IMMEDIATE\", self.QUERY, \"COMMIT\"])\n\n    def test_isolation_level_exclusive(self):\n        self.cx.isolation_level = \"EXCLUSIVE\"\n        with self.cx:\n            self.cx.execute(self.QUERY)\n        self.assertEqual(self.traced,\n                         [\"BEGIN EXCLUSIVE\", self.QUERY, \"COMMIT\"])\n\n    def test_isolation_level_none(self):\n        self.cx.isolation_level = None\n        with self.cx:\n            self.cx.execute(self.QUERY)\n        self.assertEqual(self.traced, [self.QUERY])", "\n\nif __name__ == \"__main__\":\n    unittest.main()\n"]}
{"filename": "examples/dbapi2.py", "chunked_list": ["import datetime\nimport logging\nimport os\n\nfrom libsql_client import dbapi2\n\n\ndef show_rows(cursor, pfx=\"|\"):\n    table = []\n\n    table.append([repr(col[0]) for col in cursor.description])\n    sizes = [len(c) for c in table[0]]\n\n    for row in cursor:\n        r = [repr(cell) for cell in row]\n        table.append(r)\n        sizes = [max(prev, len(c)) for prev, c in zip(sizes, r)]\n\n    fmts = [\"%%-%ds\" % size for size in sizes]\n    for i, row in enumerate(table):\n        print(pfx + \" | \".join(fmt % value for fmt, value in zip(fmts, row)))\n        if i == 0:\n            print(pfx + \"-+-\".join(\"-\" * size for size in sizes))\n    print()", "\n\ndef main():\n    logging.basicConfig(level=os.getenv(\"LOG_LEVEL\", \"WARNING\"))\n    url = os.getenv(\"URL\", \"file:local.db\")\n    conn = dbapi2.connect(\n        url,\n        uri=True,\n        detect_types=dbapi2.PARSE_COLNAMES | dbapi2.PARSE_DECLTYPES,\n    )\n    conn.execute(\n        \"\"\"\n        CREATE TABLE IF NOT EXISTS users (\n            id INTEGER PRIMARY KEY,\n            email TEXT NOT NULL UNIQUE\n        )\n        \"\"\"\n    )\n\n    print(\"\\n# iterdump\")\n    for stmt in conn.iterdump():\n        print(f\"   {stmt}\")\n\n    print(\"\\n# execute\")\n\n    print(\"\\n>>> execute: no arguments, multiple values (rowcount)\")\n    cursor = conn.execute(\n        \"\"\"\n        INSERT INTO users (email) VALUES\n            ('alice@libsql.org'),\n            ('bob@example.com')\n        \"\"\"\n    )\n    print(f\"inserted rowid: {cursor.lastrowid}, affected: {cursor.rowcount}\")\n\n    print(\"\\n>>> execute: with positional arguments\")\n    cursor = conn.execute(\"INSERT INTO users (email) VALUES (?)\", (\"rob@other.com\",))\n    print(f\"inserted rowid: {cursor.lastrowid}, affected: {cursor.rowcount}\")\n\n    print(\"\\n>>> execute: with named arguments\")\n    cursor = conn.execute(\n        \"INSERT INTO users (email) VALUES (@email)\",\n        {\"email\": \"sql@other.com\"},\n    )\n    print(f\"inserted rowid: {cursor.lastrowid}, affected: {cursor.rowcount}\")\n\n    print(\"\\n# executemany\")\n\n    print(\"\\n>>> executemany: with positional arguments\")\n    cursor = conn.executemany(\n        \"INSERT INTO users (email) VALUES (?)\",\n        (\n            (\"sql2@sql.com\",),\n            (\"sql3@sql.com\",),\n        ),\n    )\n    print(f\"inserted rowid: {cursor.lastrowid}, affected: {cursor.rowcount}\")\n\n    print(\"\\n# executescript\")\n    conn.executescript(\n        \"\"\"\n        INSERT INTO users (email) VALUES ('script1@server.com');\n        INSERT INTO users (email) VALUES ('script2@server.com');\n        INSERT INTO users (email) VALUES ('script3@server.com');\n        \"\"\",\n    )\n\n    print(\"\\n# transactions\")\n    try:\n        with conn as cursor:\n            cursor.execute(\"BEGIN\")\n            cursor.execute(\"INSERT INTO users (email) VALUES ('bug!')\")\n            cursor.execute(\"INSERT INTO users (email) VALUES ('bug!')\")\n    except dbapi2.IntegrityError as e:\n        print(\"Got expected exception, should rollback transaction:\", e)\n\n    print(\"\\n# fetching: rows and description\")\n    cursor = conn.execute(\"SELECT * from users\")\n\n    show_rows(cursor)\n\n    # example based on:\n    # https://docs.python.org/3/library/sqlite3.html#default-adapters-and-converters\n    print(\"\\n# Type converters:\")\n    cursor.execute(\"create table test(d date, ts timestamp)\")\n    today = datetime.date.today()\n    now = datetime.datetime.now()\n\n    print(\"\\n>>> based on column decltype:\")\n    cursor.execute(\"insert into test(d, ts) values (?, ?)\", (today, now))\n    cursor.execute(\"select d, ts from test\")\n    show_rows(cursor)\n    conn.execute(\"DROP TABLE test\")\n\n    print(\"\\n>>> based on column names: 'd [date]', 'ts [timestamp]'\")\n    cursor.execute(\n        \"\"\"\n        select current_date as \"d [date]\",\n        current_timestamp as \"ts [timestamp]\"\n    \"\"\"\n    )\n    show_rows(cursor)\n\n    # https://docs.python.org/3/library/sqlite3.html#how-to-convert-sqlite-values-to-custom-python-types\n    class Point:\n        def __init__(self, x, y):\n            self.x, self.y = x, y\n\n        def __repr__(self):\n            return f\"Point({self.x}, {self.y})\"\n\n    def adapt_point(point):\n        return f\"{point.x};{point.y}\"\n\n    def convert_point(s):\n        x, y = list(map(float, s.split(b\";\")))\n        return Point(x, y)\n\n    # Register the adapter and converter\n    dbapi2.register_adapter(Point, adapt_point)\n    dbapi2.register_converter(\"point\", convert_point)\n    p = Point(4.0, -3.2)\n    cur = conn.execute(\"CREATE TABLE test(p point)\")\n\n    print(\"\\n>>> inserting custom type: Point\")\n    cur.execute(\"INSERT INTO test(p) VALUES(?)\", (p,))\n    cur.execute(\"SELECT p FROM test\")\n    show_rows(cur)\n    conn.execute(\"DROP TABLE test\")\n\n    cur = conn.execute(\"CREATE TABLE test(p)\")\n    cur.execute(\"INSERT INTO test(p) VALUES(?)\", (p,))\n    cur.execute('SELECT p AS \"p [point]\" FROM test')\n    show_rows(cur)\n    conn.execute(\"DROP TABLE test\")\n\n    conn.close()", "\n\nmain()\n"]}
{"filename": "examples/books.py", "chunked_list": ["import asyncio\nimport os\nimport random\n\nimport libsql_client\n\n\nasync def main():\n    url = os.getenv(\"URL\", \"file:local.db\")\n    async with libsql_client.create_client(url) as client:", "    url = os.getenv(\"URL\", \"file:local.db\")\n    async with libsql_client.create_client(url) as client:\n        await client.batch(\n            [\n                \"\"\"\n            CREATE TABLE IF NOT EXISTS book (\n                id INTEGER PRIMARY KEY,\n                title TEXT NOT NULL,\n                author_id INTEGER NOT NULL\n            )", "                author_id INTEGER NOT NULL\n            )\n            \"\"\",\n                \"\"\"\n            CREATE TABLE IF NOT EXISTS author (\n                id INTEGER PRIMARY KEY,\n                name TEXT NOT NULL\n            )\n            \"\"\",\n            ]", "            \"\"\",\n            ]\n        )\n\n        author_res = await client.execute(\n            \"INSERT INTO author (name) VALUES (?) RETURNING id\",\n            [sample_name(AUTHOR_NAME_PARTS)],\n        )\n        author_id = author_res.rows[0][0]\n", "        author_id = author_res.rows[0][0]\n\n        book_count = random.randint(1, 3)\n        for _ in range(book_count):\n            await client.execute(\n                \"INSERT INTO book (title, author_id) VALUES (?, ?)\",\n                [sample_name(BOOK_TITLE_PARTS), author_id],\n            )\n\n        books_res = await client.execute(", "\n        books_res = await client.execute(\n            \"\"\"\n            SELECT b.id, b.title, a.id, a.name\n            FROM book b JOIN author a ON b.author_id = a.id\n            ORDER BY b.id ASC\n            \"\"\"\n        )\n\n        for row in books_res.rows:\n            print(row)", "\n        for row in books_res.rows:\n            print(row)\n\n\ndef sample_name(name_parts):\n    return \" \".join([random.choice(parts) for parts in name_parts])\n\n\nAUTHOR_NAME_PARTS = [", "\nAUTHOR_NAME_PARTS = [\n    [\"Daniel\", \"Jane\", \"Mark\", \"William\", \"Milan\", \"Kazuo\", \"Sally\", \"Mieko\", \"Kim\"],\n    [\n        \"Defoe\",\n        \"Austen\",\n        \"Twain\",\n        \"Golding\",\n        \"Kundera\",\n        \"Ishiguro\",", "        \"Kundera\",\n        \"Ishiguro\",\n        \"Rooney\",\n        \"Kawakami\",\n        \"Hye-Jin\",\n    ],\n]\n\nBOOK_TITLE_PARTS = [\n    [", "BOOK_TITLE_PARTS = [\n    [\n        \"Robinson\",\n        \"Pride\",\n        \"Sense\",\n        \"Huckleberry\",\n        \"Tom\",\n        \"Lord\",\n        \"\u017divot\",\n        \"Klara\",", "        \"\u017divot\",\n        \"Klara\",\n        \"Normal\",\n        \"Breasts\",\n        \"Concerning\",\n    ],\n    [\n        \"Crusoe\",\n        \"and Prejudice\",\n        \"and Sensibility\",", "        \"and Prejudice\",\n        \"and Sensibility\",\n        \"Finn\",\n        \"Sawyer\",\n        \"of the Flies\",\n        \"je jinde\",\n        \"and The Sun\",\n        \"People\",\n        \"and Eggs\",\n        \"My Daughter\",", "        \"and Eggs\",\n        \"My Daughter\",\n    ],\n]\n\nasyncio.run(main())\n"]}
{"filename": "examples/readme.py", "chunked_list": ["import asyncio\nimport os\n\nimport libsql_client\n\n\nasync def main():\n    url = os.getenv(\"URL\", \"file:local.db\")\n    async with libsql_client.create_client(url) as client:\n        await client.batch(", "    async with libsql_client.create_client(url) as client:\n        await client.batch(\n            [\n                \"\"\"\n            CREATE TABLE IF NOT EXISTS users (\n                id INTEGER PRIMARY KEY,\n                email TEXT NOT NULL\n            )\n            \"\"\",\n                \"\"\"", "            \"\"\",\n                \"\"\"\n            INSERT INTO users (email) VALUES\n                ('alice@libsql.org'),\n                ('bob@example.com')\n            \"\"\",\n            ]\n        )\n\n        result_set = await client.execute(\"SELECT * from users\")", "\n        result_set = await client.execute(\"SELECT * from users\")\n        print(len(result_set.rows), \"rows\")\n        for row in result_set.rows:\n            print(row)\n\n\nasyncio.run(main())\n", ""]}
{"filename": "libsql_client/config.py", "chunked_list": ["from __future__ import annotations\n\nfrom typing import NamedTuple\nfrom typing import Optional\nimport urllib.parse\n\nfrom .client import LibsqlError\n\n\nclass _Config(NamedTuple):\n    scheme: str\n    authority: str\n    path: str\n    auth_token: Optional[str]\n    tls: bool", "\nclass _Config(NamedTuple):\n    scheme: str\n    authority: str\n    path: str\n    auth_token: Optional[str]\n    tls: bool\n\n\ndef _expand_config(\n    url: str, *, auth_token: Optional[str], tls: Optional[bool]\n) -> _Config:\n    url_parsed = urllib.parse.urlparse(url)\n    scheme = url_parsed.scheme\n    authority = url_parsed.netloc\n    path = url_parsed.path\n\n    qsl = urllib.parse.parse_qsl(url_parsed.query, keep_blank_values=True)\n    for key, value in qsl:\n        if key == \"authToken\":\n            auth_token = value or None\n        elif key == \"tls\":\n            if value == \"0\":\n                tls = False\n            elif value == \"1\":\n                tls = True\n            else:\n                raise LibsqlError(\n                    f\"Unknown value for the 'tls' query argument: {value!r}. \"\n                    \"Supported values are '0' and '1'\",\n                    \"URL_INVALID\",\n                )\n        else:\n            raise LibsqlError(\n                f\"Unknown URL query parameter {key!r}\", \"URL_PARAM_NOT_SUPPORTED\"\n            )\n\n    if scheme == \"libsql\":\n        if tls is False:\n            if url_parsed.port is None:\n                raise LibsqlError(\n                    \"A 'libsql:' URL with ?tls=0 must specify an explicit port\",\n                    \"URL_INVALID\",\n                )\n            scheme = \"ws\"\n        else:\n            scheme = \"wss\"\n    elif scheme in (\"http\", \"ws\") and tls is None:\n        tls = False\n\n    if tls is None:\n        tls = True\n\n    if url_parsed.params:\n        raise LibsqlError(\n            f\"Unsupported URL parameter: {url_parsed.params!r}\", \"URL_INVALID\"\n        )\n    if url_parsed.fragment:\n        raise LibsqlError(\n            f\"Unsupported URL fragment: {url_parsed.fragment!r}\", \"URL_INVALID\"\n        )\n\n    return _Config(scheme, authority, path, auth_token, tls)", "\ndef _expand_config(\n    url: str, *, auth_token: Optional[str], tls: Optional[bool]\n) -> _Config:\n    url_parsed = urllib.parse.urlparse(url)\n    scheme = url_parsed.scheme\n    authority = url_parsed.netloc\n    path = url_parsed.path\n\n    qsl = urllib.parse.parse_qsl(url_parsed.query, keep_blank_values=True)\n    for key, value in qsl:\n        if key == \"authToken\":\n            auth_token = value or None\n        elif key == \"tls\":\n            if value == \"0\":\n                tls = False\n            elif value == \"1\":\n                tls = True\n            else:\n                raise LibsqlError(\n                    f\"Unknown value for the 'tls' query argument: {value!r}. \"\n                    \"Supported values are '0' and '1'\",\n                    \"URL_INVALID\",\n                )\n        else:\n            raise LibsqlError(\n                f\"Unknown URL query parameter {key!r}\", \"URL_PARAM_NOT_SUPPORTED\"\n            )\n\n    if scheme == \"libsql\":\n        if tls is False:\n            if url_parsed.port is None:\n                raise LibsqlError(\n                    \"A 'libsql:' URL with ?tls=0 must specify an explicit port\",\n                    \"URL_INVALID\",\n                )\n            scheme = \"ws\"\n        else:\n            scheme = \"wss\"\n    elif scheme in (\"http\", \"ws\") and tls is None:\n        tls = False\n\n    if tls is None:\n        tls = True\n\n    if url_parsed.params:\n        raise LibsqlError(\n            f\"Unsupported URL parameter: {url_parsed.params!r}\", \"URL_INVALID\"\n        )\n    if url_parsed.fragment:\n        raise LibsqlError(\n            f\"Unsupported URL fragment: {url_parsed.fragment!r}\", \"URL_INVALID\"\n        )\n\n    return _Config(scheme, authority, path, auth_token, tls)", ""]}
{"filename": "libsql_client/client.py", "chunked_list": ["from __future__ import annotations\n\nfrom abc import ABC\nfrom abc import abstractmethod\nfrom datetime import datetime\nfrom typing import Any\nfrom typing import Dict\nfrom typing import List\nfrom typing import Tuple\nfrom typing import TYPE_CHECKING", "from typing import Tuple\nfrom typing import TYPE_CHECKING\nfrom typing import TypeVar\nfrom typing import Union\n\nfrom .result import ResultSet\nfrom .result import Value\n\nif TYPE_CHECKING:\n    from _typeshed import ReadableBuffer\nelse:\n    ReadableBuffer = bytes", "if TYPE_CHECKING:\n    from _typeshed import ReadableBuffer\nelse:\n    ReadableBuffer = bytes\n\nInValue = Union[Value, bool, datetime, ReadableBuffer]\nInArgs = Union[List[InValue], Tuple[InValue, ...], Dict[str, InValue], None]\nInStatement = Union[\"Statement\", str, Tuple[str], Tuple[str, InArgs]]\n\n\nclass Statement:\n    sql: str\n    args: InArgs\n\n    def __init__(self, sql: str, args: InArgs = None):\n        self.sql = sql\n        self.args = args\n\n    @staticmethod\n    def convert(stmt: InStatement, args: InArgs = None) -> Statement:\n        if isinstance(stmt, tuple):\n            if len(stmt) == 1:\n                return Statement(stmt[0], args)\n            if len(stmt) > 2:\n                raise TypeError(\n                    \"Statement must be a 1-tuple or 2-tuple, \"\n                    f\"but got a {len(stmt)}-tuple\"\n                )\n            if args:\n                raise TypeError(\n                    \"Cannot pass additional args to a statement passed as tuple\"\n                )\n            return Statement(stmt[0], stmt[1])  # type: ignore[misc]\n        if isinstance(stmt, Statement):\n            if args:\n                raise TypeError(\"Cannot pass additional args to a Statement instance\")\n            return stmt\n        return Statement(stmt, args)", "\n\nclass Statement:\n    sql: str\n    args: InArgs\n\n    def __init__(self, sql: str, args: InArgs = None):\n        self.sql = sql\n        self.args = args\n\n    @staticmethod\n    def convert(stmt: InStatement, args: InArgs = None) -> Statement:\n        if isinstance(stmt, tuple):\n            if len(stmt) == 1:\n                return Statement(stmt[0], args)\n            if len(stmt) > 2:\n                raise TypeError(\n                    \"Statement must be a 1-tuple or 2-tuple, \"\n                    f\"but got a {len(stmt)}-tuple\"\n                )\n            if args:\n                raise TypeError(\n                    \"Cannot pass additional args to a statement passed as tuple\"\n                )\n            return Statement(stmt[0], stmt[1])  # type: ignore[misc]\n        if isinstance(stmt, Statement):\n            if args:\n                raise TypeError(\"Cannot pass additional args to a Statement instance\")\n            return stmt\n        return Statement(stmt, args)", "\n\nclass LibsqlError(RuntimeError):\n    code: str\n    explanation: str\n\n    def __init__(self, message: str, code: str):\n        super(RuntimeError, self).__init__(f\"{code}: {message}\")\n        self.code = code\n        self.explanation = message", "\n\nTClient = TypeVar(\"TClient\", bound=\"Client\")\n\n\nclass Client(ABC):\n    @abstractmethod\n    async def execute(self, stmt: InStatement, args: InArgs = None) -> ResultSet:\n        pass\n\n    @abstractmethod\n    async def batch(self, stmts: List[InStatement]) -> List[ResultSet]:\n        pass\n\n    @abstractmethod\n    def transaction(self) -> Transaction:\n        pass\n\n    @abstractmethod\n    async def close(self) -> None:\n        pass\n\n    @property\n    @abstractmethod\n    def closed(self) -> bool:\n        pass\n\n    async def __aenter__(self: TClient) -> TClient:\n        return self\n\n    async def __aexit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None:\n        await self.close()", "\n\nTTransaction = TypeVar(\"TTransaction\", bound=\"Transaction\")\n\n\nclass Transaction(ABC):\n    @abstractmethod\n    async def execute(self, stmt: InStatement, args: InArgs = None) -> ResultSet:\n        ...\n\n    @abstractmethod\n    async def rollback(self) -> None:\n        ...\n\n    @abstractmethod\n    async def commit(self) -> None:\n        ...\n\n    @abstractmethod\n    def close(self) -> None:\n        ...\n\n    @property\n    @abstractmethod\n    def closed(self) -> bool:\n        ...\n\n    def __enter__(self: TTransaction) -> TTransaction:\n        return self\n\n    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None:\n        self.close()", "\n\ndef _normalize_value(in_value: InValue) -> Value:\n    if isinstance(in_value, datetime):\n        return int(in_value.timestamp() * 1000)\n    elif isinstance(in_value, bool):\n        return int(in_value)\n    elif isinstance(in_value, (str, int, float)) or in_value is None:\n        return in_value\n    return bytes(memoryview(in_value))", ""]}
{"filename": "libsql_client/__init__.py", "chunked_list": ["from .client import Client\nfrom .client import InArgs\nfrom .client import InStatement\nfrom .client import InValue\nfrom .client import LibsqlError\nfrom .client import Statement\nfrom .client import Transaction\nfrom .create_client import create_client\nfrom .result import ResultSet\nfrom .result import Row", "from .result import ResultSet\nfrom .result import Row\nfrom .result import Value\nfrom .sync import ClientSync\nfrom .sync import create_client_sync\nfrom .sync import TransactionSync\n"]}
{"filename": "libsql_client/result.py", "chunked_list": ["from __future__ import annotations\n\nfrom collections.abc import Sequence\nfrom typing import Dict\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Optional\nfrom typing import overload\nfrom typing import Tuple\nfrom typing import Union", "from typing import Tuple\nfrom typing import Union\n\nValue = Union[None, str, int, float, bytes]\n\n\nclass ResultSet:\n    \"\"\"Result of an SQL statement.\n\n    The result is composed of columns and rows.\n    Every row is represented as a `Row` object and the length of\n    every row is equal to the number of columns.\n    \"\"\"\n\n    _columns: Tuple[str, ...]\n    _rows: List[Row]\n    _rows_affected: int\n    _last_insert_rowid: Optional[int]\n    __slots__ = [\"_columns\", \"_rows\", \"_rows_affected\", \"_last_insert_rowid\"]\n\n    def __init__(\n        self,\n        columns: Tuple[str, ...],\n        rows: List[\"Row\"],\n        rows_affected: int,\n        last_insert_rowid: Optional[int],\n    ):\n        self._columns = columns\n        self._rows = rows\n        self._rows_affected = rows_affected\n        self._last_insert_rowid = last_insert_rowid\n\n    def __iter__(self) -> Iterator[\"Row\"]:\n        return self._rows.__iter__()\n\n    def __len__(self) -> int:\n        return len(self._rows)\n\n    @overload\n    def __getitem__(self, key: int) -> Row:\n        pass\n\n    @overload\n    def __getitem__(self, key: slice) -> List[Row]:\n        pass\n\n    def __getitem__(self, key: Union[int, slice]) -> Union[Row, List[Row]]:\n        return self._rows[key]\n\n    @property\n    def columns(self) -> Tuple[str, ...]:\n        return self._columns\n\n    @property\n    def rows(self) -> List[Row]:\n        return self._rows\n\n    @property\n    def rows_affected(self) -> int:\n        return self._rows_affected\n\n    @property\n    def last_insert_rowid(self) -> Optional[int]:\n        return self._last_insert_rowid", "\n\nclass Row(Sequence):\n    \"\"\"A row returned by an SQL statement.\n\n    The row values can be accessed with an index or by name.\n    \"\"\"\n\n    _column_idxs: Dict[str, int]\n    _values: Tuple[Value, ...]\n    __slots__ = [\"_column_idxs\", \"_values\"]\n\n    def __init__(self, column_idxs: Dict[str, int], values: Tuple[Value, ...]) -> None:\n        self._column_idxs = column_idxs\n        self._values = values\n\n    @overload\n    def __getitem__(self, key: int) -> Value:\n        pass\n\n    @overload\n    def __getitem__(self, key: str) -> Value:\n        pass\n\n    @overload\n    def __getitem__(self, key: slice) -> Tuple[Value, ...]:\n        pass\n\n    def __getitem__(\n        self, key: Union[int, str, slice]\n    ) -> Union[Value, Tuple[Value, ...]]:\n        \"\"\"Access a value by index or by name.\"\"\"\n        tuple_key: Union[int, slice]\n        if isinstance(key, str):\n            tuple_key = self._column_idxs[key]\n        else:\n            tuple_key = key\n        return self._values[tuple_key]\n\n    def __len__(self) -> int:\n        return len(self._values)\n\n    def __repr__(self) -> str:\n        return repr(self._values)\n\n    def astuple(self) -> Tuple[Value, ...]:\n        return self._values\n\n    def asdict(self) -> Dict[str, Value]:\n        return {key: self._values[idx] for key, idx in self._column_idxs.items()}\n\n    _asdict = asdict\n\n    @property\n    def _fields(self) -> Tuple[str, ...]:\n        return tuple(self._column_idxs.keys())", ""]}
{"filename": "libsql_client/http.py", "chunked_list": ["from __future__ import annotations\n\nfrom typing import Any\nfrom typing import cast\nfrom typing import List\nfrom typing import Optional\nimport urllib.parse\n\nimport aiohttp\nfrom typing_extensions import TypedDict", "import aiohttp\nfrom typing_extensions import TypedDict\n\nfrom .client import Client\nfrom .client import InArgs\nfrom .client import InStatement\nfrom .client import LibsqlError\nfrom .client import Transaction\nfrom .config import _Config\nfrom .hrana import proto", "from .config import _Config\nfrom .hrana import proto\nfrom .hrana.convert import _batch_results_from_proto\nfrom .hrana.convert import _batch_to_proto\nfrom .hrana.convert import _result_set_from_proto\nfrom .hrana.convert import _stmt_to_proto\nfrom .result import ResultSet\n\n\ndef _create_http_client(config: _Config) -> HttpClient:\n    assert config.scheme in (\"http\", \"https\")\n    if config.scheme == \"http\" and config.tls:\n        raise LibsqlError(\n            \"A 'http:' URL cannot opt into TLS by using ?tls=1\", \"URL_INVALID\"\n        )\n    elif config.scheme == \"https\" and not config.tls:\n        raise LibsqlError(\n            \"A 'https:' URL cannot opt out of TLS by using ?tls=0\", \"URL_INVALID\"\n        )\n\n    url = urllib.parse.urlunparse(\n        (\n            config.scheme,\n            config.authority,\n            config.path,\n            \"\",\n            \"\",\n            \"\",\n        )\n    )\n    return HttpClient(url, auth_token=config.auth_token)", "\ndef _create_http_client(config: _Config) -> HttpClient:\n    assert config.scheme in (\"http\", \"https\")\n    if config.scheme == \"http\" and config.tls:\n        raise LibsqlError(\n            \"A 'http:' URL cannot opt into TLS by using ?tls=1\", \"URL_INVALID\"\n        )\n    elif config.scheme == \"https\" and not config.tls:\n        raise LibsqlError(\n            \"A 'https:' URL cannot opt out of TLS by using ?tls=0\", \"URL_INVALID\"\n        )\n\n    url = urllib.parse.urlunparse(\n        (\n            config.scheme,\n            config.authority,\n            config.path,\n            \"\",\n            \"\",\n            \"\",\n        )\n    )\n    return HttpClient(url, auth_token=config.auth_token)", "\n\nclass HttpClient(Client):\n    _session: aiohttp.ClientSession\n    _url: str\n\n    def __init__(self, url: str, *, auth_token: Optional[str] = None):\n        headers = {\"authorization\": f\"Bearer {auth_token}\"}\n        self._session = aiohttp.ClientSession(headers=headers)\n        self._url = url\n\n    async def execute(self, stmt: InStatement, args: InArgs = None) -> ResultSet:\n        request: _ExecuteReq = {\n            \"stmt\": _stmt_to_proto(stmt, args),\n        }\n        response = await self._send(\"POST\", \"v1/execute\", request)\n        proto_res = cast(_ExecuteResp, response)[\"result\"]\n        return _result_set_from_proto(proto_res)\n\n    async def sequence(self, stmt: str) -> None:\n        raise LibsqlError(\n            \"The HTTP client does not support sequence.\",\n            \"SEQUENCE_NOT_SUPPORTED\",\n        )\n\n    async def batch(self, stmts: List[InStatement]) -> List[ResultSet]:\n        request: _BatchReq = {\n            \"batch\": _batch_to_proto(stmts),\n        }\n        response = await self._send(\"POST\", \"v1/batch\", request)\n        proto_res = cast(_BatchResp, response)[\"result\"]\n        return _batch_results_from_proto(proto_res, len(stmts))\n\n    def transaction(self) -> Transaction:\n        raise LibsqlError(\n            \"The HTTP client does not support transactions. \"\n            \"Please use a libsql:, ws: or wss: URL, so that the client \"\n            \"connects using a WebSocket.\",\n            \"TRANSACTIONS_NOT_SUPPORTED\",\n        )\n\n    async def close(self) -> None:\n        await self._session.close()\n\n    @property\n    def closed(self) -> bool:\n        return self._session.closed\n\n    async def _send(self, method: str, path: str, request_body: Any) -> Any:\n        url = urllib.parse.urljoin(self._url, path)\n        async with self._session.request(method, url, json=request_body) as resp:\n            if not resp.ok:\n                if resp.content_type == \"application/json\":\n                    resp_json = await resp.json()\n                    if \"message\" in resp_json:\n                        message = resp_json[\"message\"]\n                        code = resp_json.get(\"code\") or \"UNKNOWN\"\n                        raise LibsqlError(message, code)\n                elif resp.content_type == \"text/plain\":\n                    resp_text = await resp.text()\n                    raise LibsqlError(\n                        \"Server returned HTTP status \"\n                        f\"{resp.status} and error: {resp_text!r}\",\n                        \"SERVER_ERROR\",\n                    )\n                raise LibsqlError(\n                    f\"Server returned HTTP status {resp.status}\", \"SERVER_ERROR\"\n                )\n\n            return await resp.json()", "\n\n_ExecuteReq = TypedDict(\n    \"_ExecuteReq\",\n    {\n        \"stmt\": proto.Stmt,\n    },\n)\n_ExecuteResp = TypedDict(\n    \"_ExecuteResp\",", "_ExecuteResp = TypedDict(\n    \"_ExecuteResp\",\n    {\n        \"result\": proto.StmtResult,\n    },\n)\n\n_BatchReq = TypedDict(\n    \"_BatchReq\",\n    {", "    \"_BatchReq\",\n    {\n        \"batch\": proto.Batch,\n    },\n)\n_BatchResp = TypedDict(\n    \"_BatchResp\",\n    {\n        \"result\": proto.BatchResult,\n    },", "        \"result\": proto.BatchResult,\n    },\n)\n"]}
{"filename": "libsql_client/create_client.py", "chunked_list": ["from __future__ import annotations\n\nfrom typing import Optional\n\nfrom .client import Client\nfrom .client import LibsqlError\nfrom .config import _expand_config\nfrom .hrana import _create_hrana_client\nfrom .http import _create_http_client\nfrom .sqlite3 import _create_sqlite3_client", "from .http import _create_http_client\nfrom .sqlite3 import _create_sqlite3_client\n\n\ndef create_client(\n    url: str, *, auth_token: Optional[str] = None, tls: Optional[bool] = None\n) -> Client:\n    config = _expand_config(url, auth_token=auth_token, tls=tls)\n    if config.scheme == \"file\":\n        return _create_sqlite3_client(config)\n    elif config.scheme in (\"ws\", \"wss\"):\n        return _create_hrana_client(config)\n    elif config.scheme in (\"http\", \"https\"):\n        return _create_http_client(config)\n    else:\n        raise LibsqlError(\n            f\"Unsupported URL scheme {config.scheme!r}\", \"URL_SCHEME_NOT_SUPPORTED\"\n        )", ""]}
{"filename": "libsql_client/sqlite3.py", "chunked_list": ["from __future__ import annotations\n\nimport math\nimport sqlite3\nfrom typing import Any\nfrom typing import cast\nfrom typing import List\nfrom typing import Optional\n\nfrom .client import _normalize_value", "\nfrom .client import _normalize_value\nfrom .client import Client\nfrom .client import InArgs\nfrom .client import InStatement\nfrom .client import InValue\nfrom .client import LibsqlError\nfrom .client import Statement\nfrom .client import Transaction\nfrom .config import _Config", "from .client import Transaction\nfrom .config import _Config\nfrom .result import ResultSet\nfrom .result import Row\n\n\ndef _create_sqlite3_client(config: _Config) -> Sqlite3Client:\n    assert config.scheme == \"file\"\n    if config.authority not in (\"\", \"localhost\"):\n        raise LibsqlError(\n            f\"Invalid authority in file URL: {config.authority!r}\", \"URL_INVALID\"\n        )\n\n    client = Sqlite3Client(config.path)\n    db = client._connect()\n    try:\n        _execute_stmt(db, \"SELECT 1 AS check_that_the_database_can_be_opened\")\n    finally:\n        db.close()\n\n    return client", "\n\nclass Sqlite3Client(Client):\n    _path: str\n    _closed: bool\n\n    def __init__(self, path: str):\n        self._path = path\n        self._closed = False\n\n    async def execute(self, stmt: InStatement, args: InArgs = None) -> ResultSet:\n        db = self._connect()\n        try:\n            return _execute_stmt(db, stmt, args)\n        finally:\n            db.close()\n\n    async def batch(self, stmts: List[InStatement]) -> List[ResultSet]:\n        db = self._connect()\n        try:\n            _execute_stmt(db, \"BEGIN\")\n            result_sets = []\n            for stmt in stmts:\n                result_set = _execute_stmt(db, stmt)\n                result_sets.append(result_set)\n            _execute_stmt(db, \"COMMIT\")\n            return result_sets\n        finally:\n            db.close()\n\n    def transaction(self) -> Sqlite3Transaction:\n        db = self._connect()\n        try:\n            _execute_stmt(db, \"BEGIN\")\n            return Sqlite3Transaction(db)\n        except Exception:\n            db.close()\n            raise\n\n    async def close(self) -> None:\n        self._closed = True\n\n    @property\n    def closed(self) -> bool:\n        return self._closed\n\n    def _connect(self) -> sqlite3.Connection:\n        if self._closed:\n            raise LibsqlError(\"The client was closed\", \"CLIENT_CLOSED\")\n        return sqlite3.connect(\n            self._path,\n            isolation_level=None,\n            check_same_thread=False,\n            timeout=0,\n        )", "\n\nclass Sqlite3Transaction(Transaction):\n    database: Optional[sqlite3.Connection]\n\n    def __init__(self, database: sqlite3.Connection):\n        self.database = database\n\n    async def execute(self, stmt: InStatement, args: InArgs = None) -> ResultSet:\n        db = self._connection()\n        return _execute_stmt(db, stmt, args)\n\n    async def rollback(self) -> None:\n        if self.database is None:\n            return\n        _execute_stmt(self.database, \"ROLLBACK\")\n        self.close()\n\n    async def commit(self) -> None:\n        db = self._connection()\n        _execute_stmt(db, \"COMMIT\")\n        self.close()\n\n    def close(self) -> None:\n        db, self.database = self.database, None\n        if db is not None:\n            db.close()\n\n    @property\n    def closed(self) -> bool:\n        return self.database is None\n\n    def _connection(self) -> sqlite3.Connection:\n        if self.database is None:\n            raise LibsqlError(\"The transaction was closed\", \"TRANSACTION_CLOSED\")\n        return self.database", "\n\ndef _execute_stmt(\n    db: sqlite3.Connection, in_stmt: InStatement, in_args: InArgs = None\n) -> ResultSet:\n    stmt = Statement.convert(in_stmt, in_args)\n    sql_args: Any\n    if stmt.args is None:\n        sql_args = ()\n    elif isinstance(stmt.args, dict):\n        sql_args = {\n            _strip_arg_name(key): _value_to_sql(value)\n            for key, value in stmt.args.items()\n        }\n    else:\n        sql_args = [_value_to_sql(value) for value in stmt.args]\n\n    cursor = None\n    try:\n        cursor = db.execute(stmt.sql, sql_args)\n        sql_rows = cursor.fetchall()\n    except sqlite3.Error as e:\n        if cursor is not None:\n            cursor.close()\n\n        if hasattr(e, \"sqlite_errorname\"):\n            code = e.sqlite_errorname\n        else:\n            code = \"SQLITE\"\n        raise LibsqlError(str(e), code) from e\n\n    try:\n        columns = tuple(cast(str, desc[0]) for desc in cursor.description or ())\n        column_idxs = {column: idx for idx, column in enumerate(columns)}\n        rows = [Row(column_idxs, sql_row) for sql_row in sql_rows]\n        rows_affected = cursor.rowcount\n        last_insert_rowid = cursor.lastrowid\n        return ResultSet(columns, rows, rows_affected, last_insert_rowid)\n    finally:\n        cursor.close()", "\n\ndef _strip_arg_name(name: str) -> str:\n    if len(name) >= 1 and name[0] in (\":\", \"$\", \"@\"):\n        return name[1:]\n    return name\n\n\ndef _value_to_sql(value: InValue) -> Any:\n    if isinstance(value, float) and not math.isfinite(value):\n        raise ValueError(\"Only finite floats (not Infinity or NaN) are supported\")\n    return _normalize_value(value)", "def _value_to_sql(value: InValue) -> Any:\n    if isinstance(value, float) and not math.isfinite(value):\n        raise ValueError(\"Only finite floats (not Infinity or NaN) are supported\")\n    return _normalize_value(value)\n"]}
{"filename": "libsql_client/sync.py", "chunked_list": ["from __future__ import annotations\n\nimport asyncio\nimport collections\nimport concurrent\nfrom dataclasses import dataclass\nimport threading\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Coroutine", "from typing import Callable\nfrom typing import Coroutine\nfrom typing import Deque\nfrom typing import List\nfrom typing import Optional\nfrom typing import TypeVar\n\nfrom .client import Client\nfrom .client import InArgs\nfrom .client import InStatement", "from .client import InArgs\nfrom .client import InStatement\nfrom .client import LibsqlError\nfrom .client import Transaction\nfrom .create_client import create_client\nfrom .result import ResultSet\n\nT = TypeVar(\"T\")\n\n\ndef create_client_sync(*args: Any, **kwargs: Any) -> ClientSync:\n    executor = _AsyncExecutor()\n    try:\n        client: Client = executor.submit_func(lambda: create_client(*args, **kwargs))\n        return ClientSync(executor, client)\n    except Exception:\n        executor.close()\n        raise", "\n\ndef create_client_sync(*args: Any, **kwargs: Any) -> ClientSync:\n    executor = _AsyncExecutor()\n    try:\n        client: Client = executor.submit_func(lambda: create_client(*args, **kwargs))\n        return ClientSync(executor, client)\n    except Exception:\n        executor.close()\n        raise", "\n\nclass ClientSync:\n    _executor: _AsyncExecutor\n    _client: Client\n\n    def __init__(self, executor: _AsyncExecutor, client: Client):\n        self._executor = executor\n        self._client = client\n\n    def execute(self, stmt: InStatement, args: InArgs = None) -> ResultSet:\n        return self._executor.submit_coro(self._client.execute(stmt, args))\n\n    def batch(self, stmts: List[InStatement]) -> List[ResultSet]:\n        return self._executor.submit_coro(self._client.batch(stmts))\n\n    def transaction(self) -> TransactionSync:\n        transaction: Transaction = self._executor.submit_func(self._client.transaction)\n        return TransactionSync(self._executor, transaction)\n\n    def close(self) -> None:\n        self._executor.close_with_coro(self._client.close)\n\n    @property\n    def closed(self) -> bool:\n        return self._executor.is_closed()\n\n    def __enter__(self) -> ClientSync:\n        return self\n\n    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None:\n        self.close()", "\n\nclass TransactionSync:\n    _executor: _AsyncExecutor\n    _transaction: Transaction\n\n    def __init__(self, executor: _AsyncExecutor, transaction: Transaction):\n        self._executor = executor\n        self._transaction = transaction\n\n    def execute(self, stmt: InStatement, args: InArgs = None) -> ResultSet:\n        return self._executor.submit_coro(self._transaction.execute(stmt, args))\n\n    def rollback(self) -> None:\n        return self._executor.submit_coro(self._transaction.rollback())\n\n    def commit(self) -> None:\n        return self._executor.submit_coro(self._transaction.commit())\n\n    def close(self) -> None:\n        self._executor.submit_func_unless_closed(self._transaction.close, lambda: None)\n\n    @property\n    def closed(self) -> bool:\n        return self._executor.submit_func_unless_closed(\n            lambda: self._transaction.closed, lambda: True\n        )\n\n    def __enter__(self) -> TransactionSync:\n        return self\n\n    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None:\n        self.close()", "\n\n@dataclass\nclass _QueueItem:\n    coroutine: Coroutine[Any, Any, Any]\n    future: concurrent.futures.Future\n\n\nclass _AsyncExecutor:\n    _thread: threading.Thread\n    _loop: asyncio.AbstractEventLoop\n\n    _lock: threading.Lock\n    _closed: bool\n    _queue: Deque[Optional[_QueueItem]]\n    _waker: Optional[asyncio.Future[None]]\n\n    def __init__(self) -> None:\n        self._thread = threading.Thread(target=self._run, name=\"libsql_client\")\n        self._loop = asyncio.new_event_loop()\n\n        self._lock = threading.Lock()\n        self._closed = False\n        self._queue = collections.deque()\n        self._waker = None\n\n        self._thread.start()\n\n    def _run(self) -> None:\n        asyncio.set_event_loop(self._loop)\n        self._loop.run_until_complete(self._run_on_loop())\n        _cancel_all_tasks(self._loop)\n        self._loop.run_until_complete(self._loop.shutdown_asyncgens())\n        self._loop.close()\n\n    async def _run_on_loop(self) -> None:\n        while True:\n            item = await self._dequeue_item()\n            if item is None:\n                break\n            try:\n                item.future.set_result(await item.coroutine)\n            except Exception as e:\n                item.future.set_exception(e)\n\n        with self._lock:\n            self._closed = True\n            for item in self._queue:\n                if item is not None:\n                    item.future.set_exception(\n                        LibsqlError(\"Client is closed\", \"CLIENT_CLOSED\")\n                    )\n            self._queue.clear()\n\n    async def _dequeue_item(self) -> Optional[_QueueItem]:\n        while True:\n            with self._lock:\n                if len(self._queue) > 0:\n                    return self._queue.popleft()\n                assert self._waker is None\n                waker = self._loop.create_future()\n                self._waker = waker\n            await waker\n\n    def _enqueue_item_with_lock(self, item: Optional[_QueueItem]) -> None:\n        self._queue.append(item)\n        waker, self._waker = self._waker, None\n        if waker is not None:\n            waker_: asyncio.Future[None] = waker\n\n            def resolve_waker() -> None:\n                waker_.set_result(None)\n\n            self._loop.call_soon_threadsafe(resolve_waker)\n\n    def submit_coro(self, coro: Coroutine[Any, Any, T]) -> T:\n        with self._lock:\n            if self._closed:\n                raise LibsqlError(\"Client is closed\", \"CLIENT_CLOSED\")\n            fut: concurrent.futures.Future = concurrent.futures.Future()\n            self._enqueue_item_with_lock(_QueueItem(coro, fut))\n        return fut.result()\n\n    def submit_func(self, func: Callable[[], T]) -> T:\n        async def coro() -> T:\n            return func()\n\n        return self.submit_coro(coro())\n\n    def submit_func_unless_closed(\n        self, on_open: Callable[[], T], on_closed: Callable[[], T]\n    ) -> T:\n        async def on_open_coro() -> T:\n            return on_open()\n\n        with self._lock:\n            if self._closed:\n                return on_closed()\n            fut: concurrent.futures.Future = concurrent.futures.Future()\n            self._enqueue_item_with_lock(_QueueItem(on_open_coro(), fut))\n        return fut.result()\n\n    def close_with_coro(\n        self, coro_func: Callable[[], Coroutine[Any, Any, None]]\n    ) -> None:\n        with self._lock:\n            if self._closed:\n                return\n            fut: concurrent.futures.Future = concurrent.futures.Future()\n            self._enqueue_item_with_lock(_QueueItem(coro_func(), fut))\n            self._enqueue_item_with_lock(None)\n        self._thread.join()\n        fut.result()\n\n    def close(self) -> None:\n        async def noop() -> None:\n            return None\n\n        self.close_with_coro(noop)\n\n    def is_closed(self) -> bool:\n        with self._lock:\n            return self._closed", "class _AsyncExecutor:\n    _thread: threading.Thread\n    _loop: asyncio.AbstractEventLoop\n\n    _lock: threading.Lock\n    _closed: bool\n    _queue: Deque[Optional[_QueueItem]]\n    _waker: Optional[asyncio.Future[None]]\n\n    def __init__(self) -> None:\n        self._thread = threading.Thread(target=self._run, name=\"libsql_client\")\n        self._loop = asyncio.new_event_loop()\n\n        self._lock = threading.Lock()\n        self._closed = False\n        self._queue = collections.deque()\n        self._waker = None\n\n        self._thread.start()\n\n    def _run(self) -> None:\n        asyncio.set_event_loop(self._loop)\n        self._loop.run_until_complete(self._run_on_loop())\n        _cancel_all_tasks(self._loop)\n        self._loop.run_until_complete(self._loop.shutdown_asyncgens())\n        self._loop.close()\n\n    async def _run_on_loop(self) -> None:\n        while True:\n            item = await self._dequeue_item()\n            if item is None:\n                break\n            try:\n                item.future.set_result(await item.coroutine)\n            except Exception as e:\n                item.future.set_exception(e)\n\n        with self._lock:\n            self._closed = True\n            for item in self._queue:\n                if item is not None:\n                    item.future.set_exception(\n                        LibsqlError(\"Client is closed\", \"CLIENT_CLOSED\")\n                    )\n            self._queue.clear()\n\n    async def _dequeue_item(self) -> Optional[_QueueItem]:\n        while True:\n            with self._lock:\n                if len(self._queue) > 0:\n                    return self._queue.popleft()\n                assert self._waker is None\n                waker = self._loop.create_future()\n                self._waker = waker\n            await waker\n\n    def _enqueue_item_with_lock(self, item: Optional[_QueueItem]) -> None:\n        self._queue.append(item)\n        waker, self._waker = self._waker, None\n        if waker is not None:\n            waker_: asyncio.Future[None] = waker\n\n            def resolve_waker() -> None:\n                waker_.set_result(None)\n\n            self._loop.call_soon_threadsafe(resolve_waker)\n\n    def submit_coro(self, coro: Coroutine[Any, Any, T]) -> T:\n        with self._lock:\n            if self._closed:\n                raise LibsqlError(\"Client is closed\", \"CLIENT_CLOSED\")\n            fut: concurrent.futures.Future = concurrent.futures.Future()\n            self._enqueue_item_with_lock(_QueueItem(coro, fut))\n        return fut.result()\n\n    def submit_func(self, func: Callable[[], T]) -> T:\n        async def coro() -> T:\n            return func()\n\n        return self.submit_coro(coro())\n\n    def submit_func_unless_closed(\n        self, on_open: Callable[[], T], on_closed: Callable[[], T]\n    ) -> T:\n        async def on_open_coro() -> T:\n            return on_open()\n\n        with self._lock:\n            if self._closed:\n                return on_closed()\n            fut: concurrent.futures.Future = concurrent.futures.Future()\n            self._enqueue_item_with_lock(_QueueItem(on_open_coro(), fut))\n        return fut.result()\n\n    def close_with_coro(\n        self, coro_func: Callable[[], Coroutine[Any, Any, None]]\n    ) -> None:\n        with self._lock:\n            if self._closed:\n                return\n            fut: concurrent.futures.Future = concurrent.futures.Future()\n            self._enqueue_item_with_lock(_QueueItem(coro_func(), fut))\n            self._enqueue_item_with_lock(None)\n        self._thread.join()\n        fut.result()\n\n    def close(self) -> None:\n        async def noop() -> None:\n            return None\n\n        self.close_with_coro(noop)\n\n    def is_closed(self) -> bool:\n        with self._lock:\n            return self._closed", "\n\n# this is copied from CPython's Lib/asyncio/runners.py\ndef _cancel_all_tasks(loop: asyncio.AbstractEventLoop) -> None:\n    to_cancel = asyncio.all_tasks(loop)\n    if not to_cancel:\n        return\n\n    for task in to_cancel:\n        task.cancel()\n\n    loop.run_until_complete(asyncio.gather(*to_cancel, return_exceptions=True))\n\n    for task in to_cancel:\n        if task.cancelled():\n            continue\n        if task.exception() is not None:\n            loop.call_exception_handler(\n                {\n                    \"message\": \"unhandled exception during _AsyncExecutor shutdown\",\n                    \"exception\": task.exception(),\n                    \"task\": task,\n                }\n            )", ""]}
{"filename": "libsql_client/hrana/id_alloc.py", "chunked_list": ["from __future__ import annotations\n\nfrom typing import Set\n\n\n# An allocator of non-negative integer ids.\n#\n# This clever data structure has these \"ideal\" properties:\n# - It consumes memory proportional to the number of used ids (which is optimal).\n# - All operations are O(1) time.", "# - It consumes memory proportional to the number of used ids (which is optimal).\n# - All operations are O(1) time.\n# - The allocated ids are small (with a slight modification, we could always\n#   provide the smallest possible\n# id).\nclass IdAlloc:\n    # Set of all allocated ids\n    _used_ids: Set[int]\n    # Set of all free ids lower than `len(_used_ids)`\n    _free_ids: Set[int]\n\n    def __init__(self) -> None:\n        self._used_ids = set()\n        self._free_ids = set()\n\n    # Returns an id that was free, and marks it as used.\n    def alloc(self) -> int:\n        if len(self._free_ids) > 0:\n            free_id = self._free_ids.pop()\n            self._used_ids.add(free_id)\n\n            # maintain the invariant of `_free_ids`\n            if (len(self._used_ids) - 1) not in self._used_ids:\n                self._free_ids.add(len(self._used_ids) - 1)\n            return free_id\n\n        # the `_free_ids` set is empty, so there are no free ids lower than\n        # `len(_used_ids)` this means that `_used_ids` is a set that contains all\n        # numbers from 0 to `len(_used_ids) - 1`, so `len(_used_ids)` is free\n        free_id = len(self._used_ids)\n        self._used_ids.add(free_id)\n        return free_id\n\n    def free(self, used_id: int) -> None:\n        self._used_ids.remove(used_id)\n\n        # maintain the invariant of `_free_ids`\n        self._free_ids.discard(len(self._used_ids))\n        if used_id < len(self._used_ids):\n            self._free_ids.add(used_id)", ""]}
{"filename": "libsql_client/hrana/conn.py", "chunked_list": ["from __future__ import annotations\n\nimport asyncio\nfrom dataclasses import dataclass\nimport json\nfrom typing import Any\nfrom typing import Callable\nfrom typing import cast\nfrom typing import Dict\nfrom typing import Optional", "from typing import Dict\nfrom typing import Optional\nfrom typing import TypeVar\nfrom typing import Union\n\nimport aiohttp\n\nfrom . import proto\nfrom .convert import _error_from_proto\nfrom .id_alloc import IdAlloc", "from .convert import _error_from_proto\nfrom .id_alloc import IdAlloc\nfrom ..client import LibsqlError\n\n\n@dataclass\nclass _ResponseState:\n    type: str\n    future: asyncio.Future[proto.Response]\n", "\n\n@dataclass\nclass _StreamState:\n    stream_id: int\n    closed: Optional[BaseException]\n\n\nclass HranaConn:\n    _connect_task: asyncio.Task[aiohttp.ClientWebSocketResponse]\n    _receive_task: Optional[asyncio.Task[None]]\n    _send_task: Optional[asyncio.Task[None]]\n\n    _socket: Optional[aiohttp.ClientWebSocketResponse]\n    _send_msg_queue: asyncio.Queue[str]\n\n    _recvd_hello: bool\n    _finished_handshake: asyncio.Event\n    _response_map: Dict[int, _ResponseState]\n    _request_id_alloc: IdAlloc\n    _stream_id_alloc: IdAlloc\n    _sql_id_alloc: IdAlloc\n\n    exception: Optional[BaseException]\n\n    def __init__(\n        self, session: aiohttp.ClientSession, url: str, auth_token: Optional[str] = None\n    ):\n        self._connect_task = asyncio.create_task(self._do_connect(session, url))\n        self._connect_task.add_done_callback(self._done_connect)\n        self._receive_task = None\n        self._send_task = None\n\n        self._socket = None\n        self._send_msg_queue = asyncio.Queue()\n\n        self._recvd_hello = False\n        self._finished_handshake = asyncio.Event()\n        self._response_map = {}\n        self._request_id_alloc = IdAlloc()\n        self._stream_id_alloc = IdAlloc()\n        self._sql_id_alloc = IdAlloc()\n\n        self.exception = None\n\n        self._send({\"type\": \"hello\", \"jwt\": auth_token})\n\n    async def wait_connected(self) -> None:\n        await self._finished_handshake.wait()\n        if self.exception:\n            raise self.exception\n\n    async def _do_connect(\n        self, session: aiohttp.ClientSession, url: str\n    ) -> aiohttp.ClientWebSocketResponse:\n        return await session.ws_connect(\n            url,\n            protocols=[\"hrana2\"],\n            autoclose=False,\n            autoping=True,\n        )\n\n    def _done_connect(\n        self, task: asyncio.Task[aiohttp.ClientWebSocketResponse]\n    ) -> None:\n        e: Optional[BaseException]\n        if task.cancelled():\n            e = LibsqlError(\"The connect task was cancelled\", \"CLIENT_CLOSED\")\n        else:\n            e = task.exception()\n        if e is not None:\n            self._set_exception(e)\n\n        if self.exception is not None:\n            return\n\n        socket = task.result()\n        receive_task = asyncio.create_task(self._do_receive(socket))\n        send_task = asyncio.create_task(self._do_send(socket))\n\n        receive_task.add_done_callback(self._done_receive)\n        send_task.add_done_callback(self._done_send)\n\n        self._socket = socket\n        self._receive_task = receive_task\n        self._send_task = send_task\n\n    async def _do_receive(self, socket: aiohttp.ClientWebSocketResponse) -> None:\n        while True:\n            msg = await socket.receive()\n            if msg.type == aiohttp.WSMsgType.TEXT:\n                try:\n                    self._receive(msg.data)\n                except Exception:\n                    await socket.close(\n                        code=3007, message=\"Could not handle message\".encode()\n                    )\n                    raise\n            elif msg.type == aiohttp.WSMsgType.BINARY:\n                await socket.close(\n                    code=3003, message=\"Only text messages are accepted\".encode()\n                )\n                raise LibsqlError(\n                    \"Received a binary WebSocket message\", \"HRANA_PROTO_ERROR\"\n                )\n            elif msg.type == aiohttp.WSMsgType.PING:\n                await socket.pong(msg.data)\n            elif msg.type == aiohttp.WSMsgType.PONG:\n                pass\n            elif msg.type == aiohttp.WSMsgType.CLOSE:\n                code = cast(aiohttp.WSCloseCode, msg.data)\n                reason = cast(str, msg.extra)\n                raise LibsqlError(\n                    f\"WebSocket was closed with code {code}: {reason!r}\",\n                    \"HRANA_WEBSOCKET_ERROR\",\n                )\n            elif msg.type == aiohttp.WSMsgType.CLOSING:\n                pass\n            elif msg.type == aiohttp.WSMsgType.CLOSED:\n                raise LibsqlError(\"WebSocket was closed\", \"HRANA_WEBSOCKET_ERROR\")\n            elif msg.type == aiohttp.WSMsgType.ERROR:\n                raise msg.data\n            else:\n                raise LibsqlError(\n                    f\"Received unexpected WebSocket message {msg.type!r}\",\n                    \"HRANA_PROTO_ERROR\",\n                )\n\n    async def _do_send(self, socket: aiohttp.ClientWebSocketResponse) -> None:\n        while True:\n            msg_str = await self._send_msg_queue.get()\n            await socket.send_str(msg_str)\n\n    def _done_receive(self, task: asyncio.Task[None]) -> None:\n        e: Optional[BaseException]\n        if task.cancelled():\n            e = LibsqlError(\"The receive task was cancelled\", \"CLIENT_CLOSED\")\n        else:\n            e = task.exception()\n\n        if e is not None:\n            if self._send_task is not None:\n                self._send_task.cancel()\n            self._set_exception(e)\n\n    def _done_send(self, task: asyncio.Task[None]) -> None:\n        e: Optional[BaseException]\n        if task.cancelled():\n            e = LibsqlError(\"The send task was cancelled\", \"CLIENT_CLOSED\")\n        else:\n            e = task.exception()\n\n        if e is not None:\n            self._set_exception(e)\n\n        if self._receive_task is not None:\n            self._receive_task.cancel()\n\n    def _send(self, msg: proto.ClientMsg) -> None:\n        assert self.exception is None\n        self._send_msg_queue.put_nowait(json.dumps(msg))\n\n    def _set_exception(self, e: BaseException) -> None:\n        if self.exception is not None:\n            return\n        self.exception = e\n        self._finished_handshake.set()\n\n        for task in (self._connect_task, self._receive_task, self._send_task):\n            if task is not None:\n                task.cancel()\n\n        for request_id, response_state in self._response_map.items():\n            response_state.future.set_exception(e)\n            self._request_id_alloc.free(request_id)\n        self._response_map.clear()\n\n    def send_request(self, request: proto.Request) -> asyncio.Future[proto.Response]:\n        future = asyncio.get_running_loop().create_future()\n\n        if self.exception is not None:\n            future.set_exception(self.exception)\n            return future\n\n        request_id = self._request_id_alloc.alloc()\n        self._response_map[request_id] = _ResponseState(request[\"type\"], future)\n        self._send({\"type\": \"request\", \"request_id\": request_id, \"request\": request})\n        return future\n\n    def _receive(self, text: str) -> None:\n        if self.exception is not None:\n            return\n\n        try:\n            msg = json.loads(text)\n        except ValueError as e:\n            raise LibsqlError(\n                \"Server message is not valid JSON\", \"HRANA_PROTO_ERROR\"\n            ) from e\n\n        if msg[\"type\"] in (\"hello_ok\", \"hello_error\"):\n            if self._recvd_hello:\n                raise LibsqlError(\n                    \"Received a duplicated error response\", \"HRANA_PROTO_ERROR\"\n                )\n            self._recvd_hello = True\n            self._finished_handshake.set()\n\n            if msg[\"type\"] == \"hello_error\":\n                raise _error_from_proto(msg[\"error\"])\n            return\n        elif not self._recvd_hello:\n            raise LibsqlError(\n                \"Received a non-hello message before hello response\",\n                \"HRANA_PROTO_ERROR\",\n            )\n\n        if msg[\"type\"] == \"response_ok\":\n            request_id = int(msg[\"request_id\"])\n            response_state = self._response_map.pop(request_id, None)\n            if response_state is None:\n                raise LibsqlError(\n                    \"Received unexpected OK response\", \"HRANA_PROTO_ERROR\"\n                )\n            self._request_id_alloc.free(request_id)\n\n            try:\n                if response_state.type != msg[\"response\"][\"type\"]:\n                    raise LibsqlError(\n                        \"Received unexpected type of response\", \"HRANA_PROTO_ERROR\"\n                    )\n                response_state.future.set_result(msg[\"response\"])\n            except Exception as e:\n                response_state.future.set_exception(e)\n                raise\n        elif msg[\"type\"] == \"response_error\":\n            request_id = int(msg[\"request_id\"])\n            response_state = self._response_map.pop(request_id, None)\n            if response_state is None:\n                raise LibsqlError(\n                    \"Received unexpected error response\", \"HRANA_PROTO_ERROR\"\n                )\n            self._request_id_alloc.free(request_id)\n\n            response_state.future.set_exception(_error_from_proto(msg[\"error\"]))\n        else:\n            raise LibsqlError(\"Received unexpected message type\", \"HRANA_PROTO_ERROR\")\n\n    def open_stream(self) -> HranaStream:\n        stream_id = self._stream_id_alloc.alloc()\n        stream_state = _StreamState(stream_id, None)\n\n        def open_done(fut: asyncio.Future[proto.Response]) -> None:\n            e: Optional[BaseException]\n            if fut.cancelled():\n                e = asyncio.CancelledError(\"Stream opening was cancelled\")\n            else:\n                e = fut.exception()\n            if e is not None:\n                self._close_stream(stream_state, e)\n\n        open_fut = self.send_request(\n            {\n                \"type\": \"open_stream\",\n                \"stream_id\": stream_id,\n            }\n        )\n        open_fut.add_done_callback(open_done)\n\n        return HranaStream(self, stream_state)\n\n    def _close_stream(self, stream_state: _StreamState, e: BaseException) -> None:\n        if stream_state.closed is not None or self.exception is not None:\n            return\n        stream_state.closed = e\n\n        def close_done(fut: asyncio.Future[proto.Response]) -> None:\n            self._stream_id_alloc.free(stream_state.stream_id)\n            if not fut.cancelled():\n                fut.exception()\n\n        close_fut = self.send_request(\n            {\n                \"type\": \"close_stream\",\n                \"stream_id\": stream_state.stream_id,\n            }\n        )\n        close_fut.add_done_callback(close_done)\n\n    async def close(self) -> None:\n        self._set_exception(LibsqlError(\"Client was manually closed\", \"CLIENT_CLOSED\"))\n        if self._socket is not None:\n            await self._socket.close()\n\n    def store_sql(self, sql: str) -> int:\n        sql_id = self._sql_id_alloc.alloc()\n\n        def store_sql_done(fut: asyncio.Future[proto.Response]) -> None:\n            e: Optional[BaseException]\n            if fut.cancelled():\n                e = asyncio.CancelledError(\"store_sql was cancelled\")\n            else:\n                e = fut.exception()\n            if e is not None:\n                self._sql_id_alloc.free(sql_id)\n\n        store_sql_fut = self.send_request(\n            {\n                \"type\": \"store_sql\",\n                \"sql_id\": sql_id,\n                \"sql\": sql,\n            }\n        )\n        store_sql_fut.add_done_callback(store_sql_done)\n        return sql_id\n\n    def close_sql(self, sql_id: int) -> None:\n        if self.exception is not None:\n            return\n\n        def close_sql_done(fut: asyncio.Future[proto.Response]) -> None:\n            self._sql_id_alloc.free(sql_id)\n            if not fut.cancelled():\n                fut.exception()\n\n        close_sql_fut = self.send_request(\n            {\n                \"type\": \"close_sql\",\n                \"sql_id\": sql_id,\n            }\n        )\n        close_sql_fut.add_done_callback(close_sql_done)", "class HranaConn:\n    _connect_task: asyncio.Task[aiohttp.ClientWebSocketResponse]\n    _receive_task: Optional[asyncio.Task[None]]\n    _send_task: Optional[asyncio.Task[None]]\n\n    _socket: Optional[aiohttp.ClientWebSocketResponse]\n    _send_msg_queue: asyncio.Queue[str]\n\n    _recvd_hello: bool\n    _finished_handshake: asyncio.Event\n    _response_map: Dict[int, _ResponseState]\n    _request_id_alloc: IdAlloc\n    _stream_id_alloc: IdAlloc\n    _sql_id_alloc: IdAlloc\n\n    exception: Optional[BaseException]\n\n    def __init__(\n        self, session: aiohttp.ClientSession, url: str, auth_token: Optional[str] = None\n    ):\n        self._connect_task = asyncio.create_task(self._do_connect(session, url))\n        self._connect_task.add_done_callback(self._done_connect)\n        self._receive_task = None\n        self._send_task = None\n\n        self._socket = None\n        self._send_msg_queue = asyncio.Queue()\n\n        self._recvd_hello = False\n        self._finished_handshake = asyncio.Event()\n        self._response_map = {}\n        self._request_id_alloc = IdAlloc()\n        self._stream_id_alloc = IdAlloc()\n        self._sql_id_alloc = IdAlloc()\n\n        self.exception = None\n\n        self._send({\"type\": \"hello\", \"jwt\": auth_token})\n\n    async def wait_connected(self) -> None:\n        await self._finished_handshake.wait()\n        if self.exception:\n            raise self.exception\n\n    async def _do_connect(\n        self, session: aiohttp.ClientSession, url: str\n    ) -> aiohttp.ClientWebSocketResponse:\n        return await session.ws_connect(\n            url,\n            protocols=[\"hrana2\"],\n            autoclose=False,\n            autoping=True,\n        )\n\n    def _done_connect(\n        self, task: asyncio.Task[aiohttp.ClientWebSocketResponse]\n    ) -> None:\n        e: Optional[BaseException]\n        if task.cancelled():\n            e = LibsqlError(\"The connect task was cancelled\", \"CLIENT_CLOSED\")\n        else:\n            e = task.exception()\n        if e is not None:\n            self._set_exception(e)\n\n        if self.exception is not None:\n            return\n\n        socket = task.result()\n        receive_task = asyncio.create_task(self._do_receive(socket))\n        send_task = asyncio.create_task(self._do_send(socket))\n\n        receive_task.add_done_callback(self._done_receive)\n        send_task.add_done_callback(self._done_send)\n\n        self._socket = socket\n        self._receive_task = receive_task\n        self._send_task = send_task\n\n    async def _do_receive(self, socket: aiohttp.ClientWebSocketResponse) -> None:\n        while True:\n            msg = await socket.receive()\n            if msg.type == aiohttp.WSMsgType.TEXT:\n                try:\n                    self._receive(msg.data)\n                except Exception:\n                    await socket.close(\n                        code=3007, message=\"Could not handle message\".encode()\n                    )\n                    raise\n            elif msg.type == aiohttp.WSMsgType.BINARY:\n                await socket.close(\n                    code=3003, message=\"Only text messages are accepted\".encode()\n                )\n                raise LibsqlError(\n                    \"Received a binary WebSocket message\", \"HRANA_PROTO_ERROR\"\n                )\n            elif msg.type == aiohttp.WSMsgType.PING:\n                await socket.pong(msg.data)\n            elif msg.type == aiohttp.WSMsgType.PONG:\n                pass\n            elif msg.type == aiohttp.WSMsgType.CLOSE:\n                code = cast(aiohttp.WSCloseCode, msg.data)\n                reason = cast(str, msg.extra)\n                raise LibsqlError(\n                    f\"WebSocket was closed with code {code}: {reason!r}\",\n                    \"HRANA_WEBSOCKET_ERROR\",\n                )\n            elif msg.type == aiohttp.WSMsgType.CLOSING:\n                pass\n            elif msg.type == aiohttp.WSMsgType.CLOSED:\n                raise LibsqlError(\"WebSocket was closed\", \"HRANA_WEBSOCKET_ERROR\")\n            elif msg.type == aiohttp.WSMsgType.ERROR:\n                raise msg.data\n            else:\n                raise LibsqlError(\n                    f\"Received unexpected WebSocket message {msg.type!r}\",\n                    \"HRANA_PROTO_ERROR\",\n                )\n\n    async def _do_send(self, socket: aiohttp.ClientWebSocketResponse) -> None:\n        while True:\n            msg_str = await self._send_msg_queue.get()\n            await socket.send_str(msg_str)\n\n    def _done_receive(self, task: asyncio.Task[None]) -> None:\n        e: Optional[BaseException]\n        if task.cancelled():\n            e = LibsqlError(\"The receive task was cancelled\", \"CLIENT_CLOSED\")\n        else:\n            e = task.exception()\n\n        if e is not None:\n            if self._send_task is not None:\n                self._send_task.cancel()\n            self._set_exception(e)\n\n    def _done_send(self, task: asyncio.Task[None]) -> None:\n        e: Optional[BaseException]\n        if task.cancelled():\n            e = LibsqlError(\"The send task was cancelled\", \"CLIENT_CLOSED\")\n        else:\n            e = task.exception()\n\n        if e is not None:\n            self._set_exception(e)\n\n        if self._receive_task is not None:\n            self._receive_task.cancel()\n\n    def _send(self, msg: proto.ClientMsg) -> None:\n        assert self.exception is None\n        self._send_msg_queue.put_nowait(json.dumps(msg))\n\n    def _set_exception(self, e: BaseException) -> None:\n        if self.exception is not None:\n            return\n        self.exception = e\n        self._finished_handshake.set()\n\n        for task in (self._connect_task, self._receive_task, self._send_task):\n            if task is not None:\n                task.cancel()\n\n        for request_id, response_state in self._response_map.items():\n            response_state.future.set_exception(e)\n            self._request_id_alloc.free(request_id)\n        self._response_map.clear()\n\n    def send_request(self, request: proto.Request) -> asyncio.Future[proto.Response]:\n        future = asyncio.get_running_loop().create_future()\n\n        if self.exception is not None:\n            future.set_exception(self.exception)\n            return future\n\n        request_id = self._request_id_alloc.alloc()\n        self._response_map[request_id] = _ResponseState(request[\"type\"], future)\n        self._send({\"type\": \"request\", \"request_id\": request_id, \"request\": request})\n        return future\n\n    def _receive(self, text: str) -> None:\n        if self.exception is not None:\n            return\n\n        try:\n            msg = json.loads(text)\n        except ValueError as e:\n            raise LibsqlError(\n                \"Server message is not valid JSON\", \"HRANA_PROTO_ERROR\"\n            ) from e\n\n        if msg[\"type\"] in (\"hello_ok\", \"hello_error\"):\n            if self._recvd_hello:\n                raise LibsqlError(\n                    \"Received a duplicated error response\", \"HRANA_PROTO_ERROR\"\n                )\n            self._recvd_hello = True\n            self._finished_handshake.set()\n\n            if msg[\"type\"] == \"hello_error\":\n                raise _error_from_proto(msg[\"error\"])\n            return\n        elif not self._recvd_hello:\n            raise LibsqlError(\n                \"Received a non-hello message before hello response\",\n                \"HRANA_PROTO_ERROR\",\n            )\n\n        if msg[\"type\"] == \"response_ok\":\n            request_id = int(msg[\"request_id\"])\n            response_state = self._response_map.pop(request_id, None)\n            if response_state is None:\n                raise LibsqlError(\n                    \"Received unexpected OK response\", \"HRANA_PROTO_ERROR\"\n                )\n            self._request_id_alloc.free(request_id)\n\n            try:\n                if response_state.type != msg[\"response\"][\"type\"]:\n                    raise LibsqlError(\n                        \"Received unexpected type of response\", \"HRANA_PROTO_ERROR\"\n                    )\n                response_state.future.set_result(msg[\"response\"])\n            except Exception as e:\n                response_state.future.set_exception(e)\n                raise\n        elif msg[\"type\"] == \"response_error\":\n            request_id = int(msg[\"request_id\"])\n            response_state = self._response_map.pop(request_id, None)\n            if response_state is None:\n                raise LibsqlError(\n                    \"Received unexpected error response\", \"HRANA_PROTO_ERROR\"\n                )\n            self._request_id_alloc.free(request_id)\n\n            response_state.future.set_exception(_error_from_proto(msg[\"error\"]))\n        else:\n            raise LibsqlError(\"Received unexpected message type\", \"HRANA_PROTO_ERROR\")\n\n    def open_stream(self) -> HranaStream:\n        stream_id = self._stream_id_alloc.alloc()\n        stream_state = _StreamState(stream_id, None)\n\n        def open_done(fut: asyncio.Future[proto.Response]) -> None:\n            e: Optional[BaseException]\n            if fut.cancelled():\n                e = asyncio.CancelledError(\"Stream opening was cancelled\")\n            else:\n                e = fut.exception()\n            if e is not None:\n                self._close_stream(stream_state, e)\n\n        open_fut = self.send_request(\n            {\n                \"type\": \"open_stream\",\n                \"stream_id\": stream_id,\n            }\n        )\n        open_fut.add_done_callback(open_done)\n\n        return HranaStream(self, stream_state)\n\n    def _close_stream(self, stream_state: _StreamState, e: BaseException) -> None:\n        if stream_state.closed is not None or self.exception is not None:\n            return\n        stream_state.closed = e\n\n        def close_done(fut: asyncio.Future[proto.Response]) -> None:\n            self._stream_id_alloc.free(stream_state.stream_id)\n            if not fut.cancelled():\n                fut.exception()\n\n        close_fut = self.send_request(\n            {\n                \"type\": \"close_stream\",\n                \"stream_id\": stream_state.stream_id,\n            }\n        )\n        close_fut.add_done_callback(close_done)\n\n    async def close(self) -> None:\n        self._set_exception(LibsqlError(\"Client was manually closed\", \"CLIENT_CLOSED\"))\n        if self._socket is not None:\n            await self._socket.close()\n\n    def store_sql(self, sql: str) -> int:\n        sql_id = self._sql_id_alloc.alloc()\n\n        def store_sql_done(fut: asyncio.Future[proto.Response]) -> None:\n            e: Optional[BaseException]\n            if fut.cancelled():\n                e = asyncio.CancelledError(\"store_sql was cancelled\")\n            else:\n                e = fut.exception()\n            if e is not None:\n                self._sql_id_alloc.free(sql_id)\n\n        store_sql_fut = self.send_request(\n            {\n                \"type\": \"store_sql\",\n                \"sql_id\": sql_id,\n                \"sql\": sql,\n            }\n        )\n        store_sql_fut.add_done_callback(store_sql_done)\n        return sql_id\n\n    def close_sql(self, sql_id: int) -> None:\n        if self.exception is not None:\n            return\n\n        def close_sql_done(fut: asyncio.Future[proto.Response]) -> None:\n            self._sql_id_alloc.free(sql_id)\n            if not fut.cancelled():\n                fut.exception()\n\n        close_sql_fut = self.send_request(\n            {\n                \"type\": \"close_sql\",\n                \"sql_id\": sql_id,\n            }\n        )\n        close_sql_fut.add_done_callback(close_sql_done)", "\n\nclass HranaStream:\n    _conn: HranaConn\n    _state: _StreamState\n\n    def __init__(self, conn: HranaConn, state: _StreamState):\n        self._conn = conn\n        self._state = state\n\n    def execute(self, stmt: proto.Stmt) -> asyncio.Future[proto.StmtResult]:\n        if self._state.closed is not None:\n            raise LibsqlError(\n                \"Stream was closed\", \"STREAM_CLOSED\"\n            ) from self._state.closed\n\n        request: proto.ExecuteReq = {\n            \"type\": \"execute\",\n            \"stream_id\": self._state.stream_id,\n            \"stmt\": stmt,\n        }\n        response_fut = self._conn.send_request(request)\n\n        def get_result(response: proto.Response) -> proto.StmtResult:\n            return cast(proto.ExecuteResp, response)[\"result\"]\n\n        return _map_future(response_fut, get_result)\n\n    def sequence(self, stmt: Union[str, int]) -> asyncio.Future[None]:\n        if self._state.closed is not None:\n            raise LibsqlError(\n                \"Stream was closed\", \"STREAM_CLOSED\"\n            ) from self._state.closed\n\n        request: proto.SequenceReq\n        if isinstance(stmt, str):\n            request = {\n                \"type\": \"sequence\",\n                \"stream_id\": self._state.stream_id,\n                \"sql\": stmt,\n            }\n        else:\n            request = {\n                \"type\": \"sequence\",\n                \"stream_id\": self._state.stream_id,\n                \"sql_id\": stmt,\n            }\n\n        response_fut = self._conn.send_request(request)\n\n        def get_result(response: proto.Response) -> None:\n            return None\n\n        return _map_future(response_fut, get_result)\n\n    def batch(self, batch: proto.Batch) -> asyncio.Future[proto.BatchResult]:\n        if self._state.closed is not None:\n            raise LibsqlError(\n                \"Stream was closed\", \"STREAM_CLOSED\"\n            ) from self._state.closed\n\n        request: proto.BatchReq = {\n            \"type\": \"batch\",\n            \"stream_id\": self._state.stream_id,\n            \"batch\": batch,\n        }\n        response_fut = self._conn.send_request(request)\n\n        def get_result(response: proto.Response) -> proto.BatchResult:\n            return cast(proto.BatchResp, response)[\"result\"]\n\n        return _map_future(response_fut, get_result)\n\n    def close(self) -> None:\n        e = LibsqlError(\"Stream was manually closed\", \"STREAM_CLOSED\")\n        self._conn._close_stream(self._state, e)\n\n    @property\n    def closed(self) -> bool:\n        return self._state.closed is not None\n\n    def __enter__(self) -> HranaStream:\n        return self\n\n    def __exit__(self, _exc_type: Any, _exc_value: Any, _traceback: Any) -> None:\n        self.close()", "\n\nT = TypeVar(\"T\")\nR = TypeVar(\"R\")\n\n\ndef _map_future(fut: asyncio.Future[T], f: Callable[[T], R]) -> asyncio.Future[R]:\n    ret: asyncio.Future[R] = asyncio.get_running_loop().create_future()\n\n    def done(fut: asyncio.Future[T]) -> None:\n        if fut.cancelled():\n            ret.cancel()\n            return\n        e = fut.exception()\n        if e is None:\n            ret.set_result(f(fut.result()))\n        else:\n            ret.set_exception(e)\n\n    fut.add_done_callback(done)\n    return ret", ""]}
{"filename": "libsql_client/hrana/proto.py", "chunked_list": ["from __future__ import annotations\n\nfrom typing import List\nfrom typing import Optional\nfrom typing import Union\n\nfrom typing_extensions import Literal\nfrom typing_extensions import NotRequired\nfrom typing_extensions import TypedDict\n", "from typing_extensions import TypedDict\n\n### Errors\n\nError = TypedDict(\n    \"Error\",\n    {\n        \"message\": str,\n        \"code\": NotRequired[Optional[str]],\n    },", "        \"code\": NotRequired[Optional[str]],\n    },\n)\n\n### Values\n\nValueNull = TypedDict(\"ValueNull\", {\"type\": Literal[\"null\"]})\nValueInteger = TypedDict(\"ValueInteger\", {\"type\": Literal[\"integer\"], \"value\": str})\nValueFloat = TypedDict(\n    \"ValueFloat\", {\"type\": Literal[\"float\"], \"value\": Union[float, int]}", "ValueFloat = TypedDict(\n    \"ValueFloat\", {\"type\": Literal[\"float\"], \"value\": Union[float, int]}\n)\nValueText = TypedDict(\"ValueText\", {\"type\": Literal[\"text\"], \"value\": str})\nValueBlob = TypedDict(\"ValueBlob\", {\"type\": Literal[\"blob\"], \"base64\": str})\nValue = Union[ValueNull, ValueInteger, ValueFloat, ValueText, ValueBlob]\n\n### Execute a statement\n\nNamedArg = TypedDict(", "\nNamedArg = TypedDict(\n    \"NamedArg\",\n    {\n        \"name\": str,\n        \"value\": Value,\n    },\n)\n\nStmt = TypedDict(", "\nStmt = TypedDict(\n    \"Stmt\",\n    {\n        # NOTE: must provide one of sql or sql_id\n        \"sql\": NotRequired[str],\n        \"sql_id\": NotRequired[int],\n        \"args\": NotRequired[List[Value]],\n        \"named_args\": NotRequired[List[NamedArg]],\n        \"want_rows\": bool,", "        \"named_args\": NotRequired[List[NamedArg]],\n        \"want_rows\": bool,\n    },\n)\n\nCol = TypedDict(\n    \"Col\",\n    {\n        \"name\": Optional[str],\n        \"decltype\": NotRequired[Optional[str]],", "        \"name\": Optional[str],\n        \"decltype\": NotRequired[Optional[str]],\n    },\n)\n\nStmtResult = TypedDict(\n    \"StmtResult\",\n    {\n        \"cols\": List[Col],\n        \"rows\": List[List[Value]],", "        \"cols\": List[Col],\n        \"rows\": List[List[Value]],\n        \"affected_row_count\": int,\n        \"last_insert_rowid\": NotRequired[Optional[str]],\n    },\n)\n\nExecuteReq = TypedDict(\n    \"ExecuteReq\",\n    {", "    \"ExecuteReq\",\n    {\n        \"type\": Literal[\"execute\"],\n        \"stream_id\": int,\n        \"stmt\": Stmt,\n    },\n)\n\nExecuteResp = TypedDict(\n    \"ExecuteResp\",", "ExecuteResp = TypedDict(\n    \"ExecuteResp\",\n    {\n        \"type\": Literal[\"execute\"],\n        \"result\": StmtResult,\n    },\n)\n\n\n### Execute a sequence of SQL statements", "\n### Execute a sequence of SQL statements\n\nSequenceReq = TypedDict(\n    \"SequenceReq\",\n    {\n        \"type\": Literal[\"sequence\"],\n        \"stream_id\": int,\n        # NOTE: must provide one of sql or sql_id\n        \"sql\": NotRequired[str],", "        # NOTE: must provide one of sql or sql_id\n        \"sql\": NotRequired[str],\n        \"sql_id\": NotRequired[int],\n    },\n)\n\nSequenceResp = TypedDict(\n    \"SequenceResp\",\n    {\n        \"type\": Literal[\"sequence\"],", "    {\n        \"type\": Literal[\"sequence\"],\n    },\n)\n\n\n### Execute a batch\n\nBatchCondOk = TypedDict(\"BatchCondOk\", {\"type\": Literal[\"ok\"], \"step\": int})\nBatchCondError = TypedDict(\"BatchCondError\", {\"type\": Literal[\"error\"], \"step\": int})", "BatchCondOk = TypedDict(\"BatchCondOk\", {\"type\": Literal[\"ok\"], \"step\": int})\nBatchCondError = TypedDict(\"BatchCondError\", {\"type\": Literal[\"error\"], \"step\": int})\nBatchCondNot = TypedDict(\"BatchCondNot\", {\"type\": Literal[\"not\"], \"cond\": \"BatchCond\"})\nBatchCondAnd = TypedDict(\n    \"BatchCondAnd\", {\"type\": Literal[\"and\"], \"conds\": List[\"BatchCond\"]}\n)\nBatchCondOr = TypedDict(\n    \"BatchCondOr\", {\"type\": Literal[\"or\"], \"conds\": List[\"BatchCond\"]}\n)\nBatchCond = Union[BatchCondOk, BatchCondError, BatchCondNot, BatchCondAnd, BatchCondOr]", ")\nBatchCond = Union[BatchCondOk, BatchCondError, BatchCondNot, BatchCondAnd, BatchCondOr]\n\nBatchStep = TypedDict(\n    \"BatchStep\",\n    {\n        \"condition\": NotRequired[Optional[BatchCond]],\n        \"stmt\": Stmt,\n    },\n)", "    },\n)\n\nBatch = TypedDict(\n    \"Batch\",\n    {\n        \"steps\": List[BatchStep],\n    },\n)\n", ")\n\nBatchReq = TypedDict(\n    \"BatchReq\",\n    {\n        \"type\": Literal[\"batch\"],\n        \"stream_id\": int,\n        \"batch\": Batch,\n    },\n)", "    },\n)\n\nBatchResult = TypedDict(\n    \"BatchResult\",\n    {\n        \"step_results\": List[Optional[StmtResult]],\n        \"step_errors\": List[Optional[Error]],\n    },\n)", "    },\n)\n\nBatchResp = TypedDict(\n    \"BatchResp\",\n    {\n        \"type\": Literal[\"batch\"],\n        \"result\": BatchResult,\n    },\n)", "    },\n)\n\n### Open stream\n\nOpenStreamReq = TypedDict(\n    \"OpenStreamReq\",\n    {\n        \"type\": Literal[\"open_stream\"],\n        \"stream_id\": int,", "        \"type\": Literal[\"open_stream\"],\n        \"stream_id\": int,\n    },\n)\n\nOpenStreamResp = TypedDict(\n    \"OpenStreamResp\",\n    {\n        \"type\": Literal[\"open_stream\"],\n    },", "        \"type\": Literal[\"open_stream\"],\n    },\n)\n\n### Close stream\n\nCloseStreamReq = TypedDict(\n    \"CloseStreamReq\",\n    {\n        \"type\": Literal[\"close_stream\"],", "    {\n        \"type\": Literal[\"close_stream\"],\n        \"stream_id\": int,\n    },\n)\n\nCloseStreamResp = TypedDict(\n    \"CloseStreamResp\",\n    {\n        \"type\": Literal[\"close_stream\"],", "    {\n        \"type\": Literal[\"close_stream\"],\n    },\n)\n\n### Hello\n\nHelloMsg = TypedDict(\n    \"HelloMsg\",\n    {", "    \"HelloMsg\",\n    {\n        \"type\": Literal[\"hello\"],\n        \"jwt\": Optional[str],\n    },\n)\n\nHelloOkMsg = TypedDict(\n    \"HelloOkMsg\",\n    {", "    \"HelloOkMsg\",\n    {\n        \"type\": Literal[\"hello_ok\"],\n    },\n)\n\nHelloErrorMsg = TypedDict(\n    \"HelloErrorMsg\",\n    {\n        \"type\": Literal[\"hello_error\"],", "    {\n        \"type\": Literal[\"hello_error\"],\n        \"error\": Error,\n    },\n)\n\n### Store an SQL text on the server\n\nStoreSqlReq = TypedDict(\n    \"StoreSqlReq\",", "StoreSqlReq = TypedDict(\n    \"StoreSqlReq\",\n    {\n        \"type\": Literal[\"store_sql\"],\n        \"sql_id\": int,\n        \"sql\": str,\n    },\n)\n\nStoreSqlResp = TypedDict(", "\nStoreSqlResp = TypedDict(\n    \"StoreSqlResp\",\n    {\n        \"type\": Literal[\"store_sql\"],\n    },\n)\n\n### Close a stored SQL text\n", "### Close a stored SQL text\n\nCloseSqlReq = TypedDict(\n    \"CloseSqlReq\",\n    {\n        \"type\": Literal[\"close_sql\"],\n        \"sql_id\": int,\n    },\n)\n", ")\n\nCloseSqlResp = TypedDict(\n    \"CloseSqlResp\",\n    {\n        \"type\": Literal[\"close_sql\"],\n    },\n)\n\n", "\n\n### Request/response\n\nRequest = Union[\n    OpenStreamReq,\n    CloseStreamReq,\n    ExecuteReq,\n    BatchReq,\n    StoreSqlReq,", "    BatchReq,\n    StoreSqlReq,\n    CloseSqlReq,\n    SequenceReq,\n]\n\nRequestMsg = TypedDict(\n    \"RequestMsg\",\n    {\n        \"type\": Literal[\"request\"],", "    {\n        \"type\": Literal[\"request\"],\n        \"request_id\": int,\n        \"request\": Request,\n    },\n)\n\nResponse = Union[\n    OpenStreamResp,\n    CloseStreamResp,", "    OpenStreamResp,\n    CloseStreamResp,\n    ExecuteResp,\n    BatchResp,\n    StoreSqlResp,\n    CloseSqlResp,\n    SequenceResp,\n]\n\nResponseOkMsg = TypedDict(", "\nResponseOkMsg = TypedDict(\n    \"ResponseOkMsg\",\n    {\n        \"type\": Literal[\"response_ok\"],\n        \"request_id\": int,\n        \"response\": Response,\n    },\n)\n", ")\n\nResponseErrorMsg = TypedDict(\n    \"ResponseErrorMsg\",\n    {\n        \"type\": Literal[\"response_error\"],\n        \"request_id\": int,\n        \"error\": Error,\n    },\n)", "    },\n)\n\n## Messages\n\nClientMsg = Union[\n    HelloMsg,\n    RequestMsg,\n]\nServerMsg = Union[", "]\nServerMsg = Union[\n    HelloOkMsg,\n    HelloErrorMsg,\n    ResponseOkMsg,\n    ResponseErrorMsg,\n]\n"]}
{"filename": "libsql_client/hrana/client.py", "chunked_list": ["from __future__ import annotations\n\nimport asyncio\nfrom typing import List\nfrom typing import Optional\nfrom typing import Set\nimport urllib.parse\n\nimport aiohttp\n", "import aiohttp\n\nfrom . import proto\nfrom .conn import HranaConn\nfrom .conn import HranaStream\nfrom .convert import _batch_results_from_proto\nfrom .convert import _batch_to_proto\nfrom .convert import _result_set_from_proto\nfrom .convert import _stmt_to_proto\nfrom ..client import Client", "from .convert import _stmt_to_proto\nfrom ..client import Client\nfrom ..client import InArgs\nfrom ..client import InStatement\nfrom ..client import LibsqlError\nfrom ..client import Transaction\nfrom ..config import _Config\nfrom ..result import ResultSet\n\n\ndef _create_hrana_client(config: _Config) -> HranaClient:\n    assert config.scheme in (\"ws\", \"wss\")\n    url = _config_to_url(config)\n    return HranaClient(url, config.auth_token)", "\n\ndef _create_hrana_client(config: _Config) -> HranaClient:\n    assert config.scheme in (\"ws\", \"wss\")\n    url = _config_to_url(config)\n    return HranaClient(url, config.auth_token)\n\n\ndef _config_to_url(config: _Config) -> str:\n    if config.scheme == \"ws\" and config.tls:\n        raise LibsqlError(\n            \"A 'ws:' URL cannot opt into TLS by using ?tls=1\", \"URL_INVALID\"\n        )\n    elif config.scheme == \"wss\" and not config.tls:\n        raise LibsqlError(\n            \"A 'wss:' URL cannot opt out of TLS by using ?tls=0\", \"URL_INVALID\"\n        )\n\n    return urllib.parse.urlunparse(\n        (\n            config.scheme,\n            config.authority,\n            config.path,\n            \"\",\n            \"\",\n            \"\",\n        )\n    )", "def _config_to_url(config: _Config) -> str:\n    if config.scheme == \"ws\" and config.tls:\n        raise LibsqlError(\n            \"A 'ws:' URL cannot opt into TLS by using ?tls=1\", \"URL_INVALID\"\n        )\n    elif config.scheme == \"wss\" and not config.tls:\n        raise LibsqlError(\n            \"A 'wss:' URL cannot opt out of TLS by using ?tls=0\", \"URL_INVALID\"\n        )\n\n    return urllib.parse.urlunparse(\n        (\n            config.scheme,\n            config.authority,\n            config.path,\n            \"\",\n            \"\",\n            \"\",\n        )\n    )", "\n\nclass HranaClient(Client):\n    _session: aiohttp.ClientSession\n    _conn: HranaConn\n    _close_tasks: Set[asyncio.Task[None]]\n    _url: str\n    _auth_token: Optional[str]\n    _closed: bool\n\n    def __init__(self, url: str, auth_token: Optional[str]):\n        self._session = aiohttp.ClientSession()\n        self._close_tasks = set()\n        self._url = url\n        self._auth_token = auth_token\n        self._conn = self._open_conn()\n        self._closed = False\n\n    async def execute(self, stmt: InStatement, args: InArgs = None) -> ResultSet:\n        with self._open_stream() as stream:\n            proto_stmt = _stmt_to_proto(stmt, args)\n            proto_result_fut = stream.execute(proto_stmt)\n        return _result_set_from_proto(await proto_result_fut)\n\n    async def batch(self, stmts: List[InStatement]) -> List[ResultSet]:\n        with self._open_stream() as stream:\n            proto_batch = _batch_to_proto(stmts)\n            proto_result_fut = stream.batch(proto_batch)\n        return _batch_results_from_proto(await proto_result_fut, len(stmts))\n\n    def transaction(self) -> HranaTransaction:\n        stream = self._open_stream()\n        return HranaTransaction(stream)\n\n    def _open_stream(self) -> HranaStream:\n        if self._closed:\n            raise LibsqlError(\"The client is closed\", \"CLIENT_CLOSED\")\n\n        if self._conn.exception is not None:\n            close_task = asyncio.create_task(self._conn.close())\n            self._close_tasks.add(close_task)\n            close_task.add_done_callback(self._close_tasks.discard)\n            self._conn = self._open_conn()\n\n        return self._conn.open_stream()\n\n    def _open_conn(self) -> HranaConn:\n        return HranaConn(self._session, self._url, self._auth_token)\n\n    async def close(self) -> None:\n        await self._conn.close()\n        if len(self._close_tasks) > 0:\n            await asyncio.wait(\n                list(self._close_tasks), return_when=asyncio.ALL_COMPLETED\n            )\n        await self._session.close()\n        self._closed = True\n\n    @property\n    def closed(self) -> bool:\n        return self._closed", "\n\nclass HranaTransaction(Transaction):\n    _stream: HranaStream\n    _begin_fut: asyncio.Future[proto.StmtResult]\n\n    def __init__(self, stream: HranaStream):\n        self._stream = stream\n        self._begin_fut = stream.execute(\n            {\n                \"sql\": \"BEGIN\",\n                \"want_rows\": False,\n            }\n        )\n\n    async def execute(self, stmt: InStatement, args: InArgs = None) -> ResultSet:\n        await self._begin_fut\n        if self._stream.closed:\n            raise LibsqlError(\"The transaction is closed\", \"TRANSACTION_CLOSED\")\n\n        proto_stmt = _stmt_to_proto(stmt, args)\n        proto_result = await self._stream.execute(proto_stmt)\n        return _result_set_from_proto(proto_result)\n\n    async def rollback(self) -> None:\n        await self._begin_fut\n        if self._stream.closed:\n            return\n\n        fut = self._stream.execute(\n            {\n                \"sql\": \"ROLLBACK\",\n                \"want_rows\": False,\n            }\n        )\n        self._stream.close()\n        await fut\n\n    async def commit(self) -> None:\n        await self._begin_fut\n        if self._stream.closed:\n            raise LibsqlError(\"The transaction is closed\", \"TRANSACTION_CLOSED\")\n\n        fut = self._stream.execute(\n            {\n                \"sql\": \"COMMIT\",\n                \"want_rows\": False,\n            }\n        )\n        self._stream.close()\n        await fut\n\n    def close(self) -> None:\n        self._stream.close()\n\n    @property\n    def closed(self) -> bool:\n        return self._stream.closed", ""]}
{"filename": "libsql_client/hrana/convert.py", "chunked_list": ["from __future__ import annotations\n\nimport base64\nimport math\nfrom typing import List\n\nfrom . import proto\nfrom ..client import _normalize_value\nfrom ..client import InArgs\nfrom ..client import InStatement", "from ..client import InArgs\nfrom ..client import InStatement\nfrom ..client import InValue\nfrom ..client import LibsqlError\nfrom ..client import Statement\nfrom ..result import ResultSet\nfrom ..result import Row\nfrom ..result import Value\n\n\ndef _stmt_to_proto(in_stmt: InStatement, in_args: InArgs = None) -> proto.Stmt:\n    stmt = Statement.convert(in_stmt, in_args)\n    args: List[proto.Value] = []\n    named_args: List[proto.NamedArg] = []\n    if stmt.args is None:\n        pass\n    elif isinstance(stmt.args, dict):\n        named_args = [\n            {\"name\": key, \"value\": _value_to_proto(value)}\n            for key, value in stmt.args.items()\n        ]\n    else:\n        args = [_value_to_proto(value) for value in stmt.args]\n    return {\"sql\": stmt.sql, \"args\": args, \"named_args\": named_args, \"want_rows\": True}", "\n\ndef _stmt_to_proto(in_stmt: InStatement, in_args: InArgs = None) -> proto.Stmt:\n    stmt = Statement.convert(in_stmt, in_args)\n    args: List[proto.Value] = []\n    named_args: List[proto.NamedArg] = []\n    if stmt.args is None:\n        pass\n    elif isinstance(stmt.args, dict):\n        named_args = [\n            {\"name\": key, \"value\": _value_to_proto(value)}\n            for key, value in stmt.args.items()\n        ]\n    else:\n        args = [_value_to_proto(value) for value in stmt.args]\n    return {\"sql\": stmt.sql, \"args\": args, \"named_args\": named_args, \"want_rows\": True}", "\n\ndef _result_set_from_proto(proto_res: proto.StmtResult) -> ResultSet:\n    columns = tuple(proto_col[\"name\"] or \"\" for proto_col in proto_res[\"cols\"])\n    column_idxs = {column: idx for idx, column in enumerate(columns)}\n    rows = []\n    for proto_row in proto_res[\"rows\"]:\n        values = tuple(_value_from_proto(proto_val) for proto_val in proto_row)\n        rows.append(Row(column_idxs, values))\n    rows_affected = proto_res[\"affected_row_count\"]\n    last_insert_rowid_str = proto_res.get(\"last_insert_rowid\")\n    last_insert_rowid = (\n        int(last_insert_rowid_str) if last_insert_rowid_str is not None else None\n    )\n    return ResultSet(columns, rows, rows_affected, last_insert_rowid)", "\n\ndef _batch_to_proto(in_stmts: List[InStatement]) -> proto.Batch:\n    steps: List[proto.BatchStep] = []\n    steps.append(\n        {\n            \"stmt\": {\"sql\": \"BEGIN\", \"want_rows\": False},\n        }\n    )\n\n    for in_stmt in in_stmts:\n        steps.append(\n            {\n                \"condition\": {\n                    \"type\": \"ok\",\n                    \"step\": len(steps) - 1,\n                },\n                \"stmt\": _stmt_to_proto(in_stmt),\n            }\n        )\n\n    steps.append(\n        {\n            \"condition\": {\n                \"type\": \"ok\",\n                \"step\": len(steps) - 1,\n            },\n            \"stmt\": {\"sql\": \"COMMIT\", \"want_rows\": False},\n        }\n    )\n    steps.append(\n        {\n            \"condition\": {\n                \"type\": \"not\",\n                \"cond\": {\n                    \"type\": \"ok\",\n                    \"step\": len(steps) - 1,\n                },\n            },\n            \"stmt\": {\"sql\": \"ROLLBACK\", \"want_rows\": False},\n        }\n    )\n\n    return {\"steps\": steps}", "\n\ndef _batch_results_from_proto(\n    proto_res: proto.BatchResult, stmt_count: int\n) -> List[ResultSet]:\n    if len(proto_res[\"step_results\"]) != stmt_count + 3:\n        raise LibsqlError(\n            \"Server did not return the expected number of batch results\",\n            \"HRANA_PROTO_ERROR\",\n        )\n    if len(proto_res[\"step_errors\"]) != stmt_count + 3:\n        raise LibsqlError(\n            \"Server did not return the expected number of batch errors\",\n            \"HRANA_PROTO_ERROR\",\n        )\n\n    for proto_err in proto_res[\"step_errors\"]:\n        if proto_err is not None:\n            raise _error_from_proto(proto_err)\n\n    result_sets = []\n    for stmt_res in proto_res[\"step_results\"][1:-2]:\n        if stmt_res is None:\n            raise LibsqlError(\n                \"Server did not return a result in batch\", \"HRANA_PROTO_ERROR\"\n            )\n        result_sets.append(_result_set_from_proto(stmt_res))\n    return result_sets", "\n\ndef _error_from_proto(proto_err: proto.Error) -> LibsqlError:\n    message = proto_err[\"message\"]\n    code = proto_err.get(\"code\") or \"UNKNOWN\"\n    return LibsqlError(message, code)\n\n\ndef _value_to_proto(in_value: InValue) -> proto.Value:\n    value = _normalize_value(in_value)\n    if value is None:\n        return {\"type\": \"null\"}\n    elif isinstance(value, str):\n        return {\"type\": \"text\", \"value\": value}\n    elif isinstance(value, int):\n        if value < _MIN_INTEGER or value > _MAX_INTEGER:\n            raise OverflowError(\n                \"Integer exceeds the range of SQLite integers (64 bits, signed)\"\n            )\n        return {\"type\": \"integer\", \"value\": str(value)}\n    elif isinstance(value, float):\n        if not math.isfinite(value):\n            raise ValueError(\"Only finite floats (not Infinity or NaN) are supported\")\n        return {\"type\": \"float\", \"value\": value}\n    else:\n        try:\n            data = base64.b64encode(value).decode()\n            return {\"type\": \"blob\", \"base64\": data}\n        except TypeError:\n            raise TypeError(f\"Unsupported value of type {type(value)}\")", "def _value_to_proto(in_value: InValue) -> proto.Value:\n    value = _normalize_value(in_value)\n    if value is None:\n        return {\"type\": \"null\"}\n    elif isinstance(value, str):\n        return {\"type\": \"text\", \"value\": value}\n    elif isinstance(value, int):\n        if value < _MIN_INTEGER or value > _MAX_INTEGER:\n            raise OverflowError(\n                \"Integer exceeds the range of SQLite integers (64 bits, signed)\"\n            )\n        return {\"type\": \"integer\", \"value\": str(value)}\n    elif isinstance(value, float):\n        if not math.isfinite(value):\n            raise ValueError(\"Only finite floats (not Infinity or NaN) are supported\")\n        return {\"type\": \"float\", \"value\": value}\n    else:\n        try:\n            data = base64.b64encode(value).decode()\n            return {\"type\": \"blob\", \"base64\": data}\n        except TypeError:\n            raise TypeError(f\"Unsupported value of type {type(value)}\")", "\n\n_MIN_INTEGER = -(2**63)\n_MAX_INTEGER = 2**63 - 1\n\n\ndef _value_from_proto(value: proto.Value) -> Value:\n    if value[\"type\"] == \"null\":\n        return None\n    elif value[\"type\"] == \"text\":\n        return str(value[\"value\"])\n    elif value[\"type\"] == \"integer\":\n        return int(value[\"value\"])\n    elif value[\"type\"] == \"float\":\n        return float(value[\"value\"])\n    elif value[\"type\"] == \"blob\":\n        return base64.b64decode(value[\"base64\"] + \"====\")\n    else:\n        raise LibsqlError(f\"Unknown value type {value['type']!r}\", \"HRANA_PROTO_ERROR\")", ""]}
{"filename": "libsql_client/hrana/__init__.py", "chunked_list": ["from .client import _create_hrana_client\nfrom .client import HranaClient\nfrom .client import HranaStream\nfrom .client import HranaTransaction\n"]}
{"filename": "libsql_client/dbapi2/__main__.py", "chunked_list": ["import os\nimport os.path\nimport sys\n\nargs = sys.argv[1:]\nenv = os.environ\n\nbootstrap_path = os.path.join(\n    os.path.dirname(__file__),\n    \"_replace_modules_pythonpath\",", "    os.path.dirname(__file__),\n    \"_replace_modules_pythonpath\",\n)\n\nif not args or args[0].lower() in (\"-h\", \"--help\", \"-?\"):\n    sys.stderr.write(\n        \"Usage:\\n\"\n        \"\\t<program> [program-args...]\\n\"\n        \"\\n\"\n        \"This will execute the python program transparently \"\n        \"replacing 'sqlite3' and 'sqlite3.dbapi2' imports with \"\n        \"'libsql_client.dbapi2' by adding \"\n        f\"'{bootstrap_path}' to $PYTHONPATH\"\n        \"\\n\"\n    )\n    sys.exit(0)", "\n\npy_path = env.get(\"PYTHONPATH\", \"\")\nif not py_path:\n    py_path = bootstrap_path\nelse:\n    py_path = os.pathsep.join([bootstrap_path, py_path])\n\nenv[\"LIBSQL_PYTHONPATH_BOOTSTRAP\"] = bootstrap_path\nenv[\"PYTHONPATH\"] = py_path", "env[\"LIBSQL_PYTHONPATH_BOOTSTRAP\"] = bootstrap_path\nenv[\"PYTHONPATH\"] = py_path\n\nos.execvpe(args[0], args, env)\n"]}
{"filename": "libsql_client/dbapi2/types.py", "chunked_list": ["from __future__ import annotations\n\nfrom abc import ABCMeta\nfrom abc import abstractmethod\nimport collections\nimport collections.abc\nimport functools\nimport logging\nimport os\nimport re", "import os\nimport re\nimport sqlite3.dbapi2\nfrom sqlite3.dump import _iterdump as sqlite3_iterdump\nimport sys\nimport threading\nfrom typing import Any\nfrom typing import Callable\nfrom typing import cast\nfrom typing import ClassVar", "from typing import cast\nfrom typing import ClassVar\nfrom typing import Dict\nfrom typing import Iterable\nfrom typing import Iterator\nfrom typing import List\nfrom typing import NoReturn\nfrom typing import Optional\nfrom typing import overload\nfrom typing import Sequence", "from typing import overload\nfrom typing import Sequence\nfrom typing import Set\nfrom typing import Tuple\nfrom typing import TYPE_CHECKING\nfrom typing import TypeVar\nfrom typing import Union\nfrom weakref import WeakSet\n\nfrom typing_extensions import Literal", "\nfrom typing_extensions import Literal\nfrom typing_extensions import ParamSpec\nfrom typing_extensions import Self\n\nfrom . import _reexports\nfrom ._reexports import DatabaseError\nfrom ._reexports import DataError\nfrom ._reexports import IntegrityError\nfrom ._reexports import InterfaceError", "from ._reexports import IntegrityError\nfrom ._reexports import InterfaceError\nfrom ._reexports import InternalError\nfrom ._reexports import NotSupportedError\nfrom ._reexports import OperationalError\nfrom ._reexports import ProgrammingError\nfrom ._reexports import SQLITE_LIMIT_SQL_LENGTH\nfrom ._utils import iter_sql_statements\nfrom ._utils import log_obj\nfrom ..client import LibsqlError", "from ._utils import log_obj\nfrom ..client import LibsqlError\nfrom ..hrana import proto\nfrom ..hrana.convert import _value_from_proto\n\nif sys.version_info[:2] >= (3, 11):\n    from ._reexports import Blob\n\n_logger = logging.getLogger(__name__)\n_log_obj = functools.partial(log_obj, _logger)", "_logger = logging.getLogger(__name__)\n_log_obj = functools.partial(log_obj, _logger)\n\nP = ParamSpec(\"P\")\nT = TypeVar(\"T\")\n\n\nif TYPE_CHECKING:\n    from sqlite3.dbapi2 import _Parameters as SqlParameters\n    from sqlite3.dbapi2 import _SqliteData as SqlData\nelse:\n    SqlParameters = Any\n    SqlData = Any", "\nPathLike = Union[str, bytes, os.PathLike]\nIsolationLevel = Literal[\"\", \"DEFERRED\", \"EXCLUSIVE\", \"IMMEDIATE\"]\nisolation_level_set: Set[IsolationLevel] = {\n    \"\",\n    \"DEFERRED\",\n    \"EXCLUSIVE\",\n    \"IMMEDIATE\",\n}\n", "}\n\nSqlNativeType = Union[None, int, float, str, bytes]\nConnectionTypes = Union[sqlite3.dbapi2.Connection, \"Connection\"]\nConnectFactory = Callable[..., ConnectionTypes]\nCursorFactory = Callable[[\"Connection\"], \"Cursor\"]\nRowFactory = Callable[[\"Cursor\", Iterable[Any]], Any]\nTextFactory = Callable[[bytes], Any]\nConverterCallback = Callable[[Any], Any]\n", "ConverterCallback = Callable[[Any], Any]\n\nAuthorizerCallback = Callable[..., int]  # SQLITE_OK, SQLITE_DENY, or SQLITE_IGNORE\nProgressHandler = Callable[[], int]\nTraceCallback = Callable[[str], None]\nBackupProgressCallback = Callable[[int, int, int], None]\n\nRawResults = proto.StmtResult\nRawColumn = proto.Col\nRawRow = List[proto.Value]", "RawColumn = proto.Col\nRawRow = List[proto.Value]\n\nLEGACY_TRANSACTION_CONTROL: Literal[-1] = -1\nAutocommit = Union[bool, Literal[-1]]\n\n\ndef _get_local_default_limits() -> Dict[int, int]:\n    if sys.version_info[:2] < (3, 11):\n        return {}\n    # while this doesn't make much sense, let's keep it compatible and\n    # allows tests to pass, such as checking if SQLITE_LIMIT_SQL_LENGTH\n    # is being enforced\n    with sqlite3.dbapi2.Connection(\":memory:\") as con:\n        categories = (\n            \"SQLITE_LIMIT_LENGTH\",\n            \"SQLITE_LIMIT_SQL_LENGTH\",\n            \"SQLITE_LIMIT_COLUMN\",\n            \"SQLITE_LIMIT_EXPR_DEPTH\",\n            \"SQLITE_LIMIT_COMPOUND_SELECT\",\n            \"SQLITE_LIMIT_VDBE_OP\",\n            \"SQLITE_LIMIT_FUNCTION_ARG\",\n            \"SQLITE_LIMIT_ATTACHED\",\n            \"SQLITE_LIMIT_LIKE_PATTERN_LENGTH\",\n            \"SQLITE_LIMIT_VARIABLE_NUMBER\",\n            \"SQLITE_LIMIT_TRIGGER_DEPTH\",\n            \"SQLITE_LIMIT_WORKER_THREADS\",\n        )\n        defaults = {}\n        for category in categories:\n            cat_id = getattr(_reexports, category)\n            defaults[cat_id] = con.getlimit(cat_id)\n        return defaults", "\n\n_default_limits = _get_local_default_limits()\n\n\ndef check_valid_autocommit(value: Any) -> Autocommit:\n    \":meta private:\"\n    if value is LEGACY_TRANSACTION_CONTROL or isinstance(value, bool):\n        return value\n    raise ValueError(\n        \"autocommit must be True, False, or \" \"sqlite3.LEGACY_TRANSACTION_CONTROL\"\n    )", "\n\n_callback_tracebacks: bool = False\n\n\ndef enable_callback_tracebacks(flag: bool) -> None:\n    \"\"\"See :py:func:`sqlite3.enable_callback_tracebacks`\"\"\"\n    global _callback_tracebacks\n    _callback_tracebacks = flag\n", "\n\nclass RawExecuteResult:\n    \"\"\"Iterable over pairs of ``result, error``.\n\n    :meta private:\n    \"\"\"\n\n    results: List[Optional[RawResults]]\n    errors: List[Optional[BaseException]]\n    _idx: int\n    __slots__ = (\"results\", \"errors\", \"_idx\")\n\n    def __init__(\n        self,\n        results: List[Optional[RawResults]],\n        errors: List[Optional[BaseException]],\n    ) -> None:\n        assert len(results) == len(errors)\n        self.results = results\n        self.errors = errors\n        self._idx = 0\n\n    def __iter__(self) -> Self:\n        return self\n\n    def __next__(self) -> Tuple[Optional[RawResults], Optional[BaseException]]:\n        idx = self._idx\n        self._idx += 1\n        try:\n            return (self.results[idx], self.errors[idx])\n        except IndexError:\n            raise StopIteration", "\n\nclass Statement:\n    \":meta private:\"\n    sql: str\n    tokens: Sequence[str]\n    is_dml: bool\n    is_ddl: bool\n    __slots__ = (\"sql\", \"tokens\", \"is_dml\", \"is_ddl\")\n\n    _dml_statements: ClassVar[Set[str]] = {\n        \"INSERT\",\n        \"UPDATE\",\n        \"DELETE\",\n        \"REPLACE\",\n    }\n    _ddl_statements: ClassVar[Set[str]] = {\n        \"CREATE\",\n        \"ALTER\",\n        \"DROP\",\n    }\n\n    @overload\n    def __init__(self, sql: str) -> None:\n        ...\n\n    @overload\n    def __init__(self, sql: str, _allow_instantiation: \"Connection\") -> None:\n        ...\n\n    def __init__(self, *args: object, **kwargs: object) -> None:\n        # NOTE do this to enable test_dbapi.py\n        # ModuleTests.test_disallow_instantiation(), it will call\n        # the connection to get a Statement, but the statement itself\n        # must not be instantiated directly.\n        # Test instantiates the result of: type(cx(\"select 1\"))\n        con = kwargs.get(\"_allow_instantiation\")\n        if not isinstance(con, Connection):\n            # matches check_disallow_instantiation() body\n            tp = self.__class__\n            mod = tp.__module__\n            name = tp.__name__\n            qualname = f\"{mod}.{name}\"\n            msg = f\"cannot create '{qualname}' instances\"\n            raise TypeError(msg)\n\n        assert len(args) == 1\n        sql = args[0]\n        if not isinstance(sql, str):\n            raise TypeError(\"sql must be a str\")\n\n        if \"\\0\" in sql:\n            raise ProgrammingError(\"the query contains a null character\")\n        if sys.version_info[:2] >= (3, 11):\n            if len(sql) > con.getlimit(SQLITE_LIMIT_SQL_LENGTH):\n                raise DataError(\"query string is too large\")\n\n        self.sql = sql\n        # see pysqlite_statement_create()\n        # https://github.com/python/cpython/blob/main/Modules/_sqlite/statement.c#L32\n        # however we need to parse the statement with iter_sql_statements()\n        # as we can't use sqlite3_prepare_v2()\n        itr = iter(iter_sql_statements(sql))\n        self.tokens = next(itr)\n        assert self.tokens\n        next_stmt = next(itr, None)\n        if next_stmt and next_stmt[0].upper() != \"END\":\n            msg = \"You can only execute one statement at a time.\"\n            raise ProgrammingError(msg)\n        self.is_dml = self._check_is_dml(self.tokens)\n        self.is_ddl = self._check_is_ddl(self.tokens)\n\n    @classmethod\n    def _check_is_dml(cls, tokens: Sequence[str]) -> bool:\n        # NOTE: this matches C pysqlite_statement_create()\n        # https://github.com/python/cpython/blob/main/Modules/_sqlite/statement.c#L75-L82\n        # but it's not fully correct as the language allows: WITH ...\n        # See https://www.sqlite.org/lang_insert.html\n        # https://www.sqlite.org/lang_update.html\n        # https://www.sqlite.org/lang_delete.html\n        # Syntax:\n        #    WITH RECURSIVE table_name ( col_name, other_col)\n        #    AS NOT MATERIALIZED ( SELECT ... )\n        return tokens[0].upper() in cls._dml_statements\n\n    @classmethod\n    def _check_is_ddl(cls, tokens: Sequence[str]) -> bool:\n        return tokens[0].upper() in cls._ddl_statements\n\n    @property\n    def is_readonly(self) -> bool:\n        # mimics sqlite3_stmt_readonly()\n        return not self.is_dml and not self.is_ddl", "\n\ndef check_thread(fn: Callable[P, T]) -> Callable[P, T]:\n    \"\"\"Decorator that checks :py:class:`Connection` thread usage.\n\n    Otherwise raises ``ProgrammingError``.\n\n    :meta private:\n    \"\"\"\n\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n        self = args[0]\n        assert len(args) > 0 and isinstance(self, Connection)\n        self._do_check_thread()\n        return fn(*args, **kwargs)\n\n    return wrapper", "\n\ndef check_connection(fn: Callable[P, T]) -> Callable[P, T]:\n    \"\"\"Decorator that checks :py:class:`Connection` being valid.\n\n        Otherwise raises ``ProgrammingError``.\n\n    :meta private:\n    \"\"\"\n\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n        self = args[0]\n        assert len(args) > 0 and isinstance(self, Connection)\n        self._do_check_connection()\n        return fn(*args, **kwargs)\n\n    return wrapper", "\n\nclass Connection(metaclass=ABCMeta):\n    \"\"\"Implement :py:class:`sqlite3.Connection` for remote servers.\n\n    :meta private:\n    \"\"\"\n\n    _closed: bool\n    _thread: Optional[int]\n    _database: str\n    _timeout: float\n    _detect_types: int\n    _isolation_level: Optional[IsolationLevel]\n    _check_same_thread: bool\n    _cached_statement_getter: Callable[[str], Statement]\n    _in_transaction: bool\n    _cursors: WeakSet\n    _autocommit: Autocommit\n    _trace_callback: Optional[TraceCallback]\n    _limits: Dict[int, int]\n    row_factory: Optional[RowFactory]\n    text_factory: Optional[TextFactory]\n    cursor_factory: CursorFactory\n\n    def __init__(\n        self,\n        database: str,\n        timeout: float,\n        detect_types: int,\n        isolation_level: Optional[IsolationLevel],\n        check_same_thread: bool,\n        cached_statements: int,\n        autocommit: Autocommit,\n    ) -> None:\n        check_valid_autocommit(autocommit)  # required by test\n        self._closed = False\n        self._thread = threading.current_thread().ident\n        self._database = database\n        self._timeout = timeout\n        self._detect_types = detect_types\n        self._check_same_thread = check_same_thread\n        self._cached_statement_getter = functools.lru_cache(cached_statements)(\n            self.__call__\n        )\n        self._in_transaction = False\n        self._cursors = WeakSet()\n        self.row_factory = None\n        self.text_factory = None\n        self.cursor_factory = Cursor\n        self._autocommit = autocommit\n        self._trace_callback = None\n        self._limits = _default_limits.copy()\n        self.isolation_level = isolation_level\n        self._raw_init()  # after this point we can call the DB\n        if autocommit is False:\n            self.cursor()._query_execute(\"BEGIN\", want_rows=False)\n\n    @abstractmethod\n    def _raw_init(self) -> None:\n        raise NotImplementedError()\n\n    def __del__(self) -> None:\n        self._dbg(\"destroying\")\n        if getattr(self, \"_closed\", False):  # __init__() may have failed\n            try:\n                # do not check threads as the main thread reference may be\n                # gone before the executor executor thread\n                self._check_same_thread = False\n                self.close()\n            except Exception as e:\n                self._err(\"failed to close connection: %s\", e, exc_info=e)\n        self._inf(\"destroyed\")\n\n    def _do_check_thread(self) -> None:\n        # class may not be properly initialized, as in some unit tests\n        check = getattr(self, \"_check_same_thread\", None)\n        if check:\n            current_ident = threading.current_thread().ident\n            if self._thread != current_ident:\n                msg = (\n                    \"SQLite objects created in a thread can only be used \"\n                    \"in that same thread. \"\n                    \"The object was created in thread id \"\n                    \"%s and this is thread id %s.\" % (self._thread, current_ident)\n                )\n                raise ProgrammingError(msg)\n        elif check is None:\n            raise ProgrammingError(\"Base Connection.__init__ not called\")\n\n    def _do_check_connection(self) -> None:\n        # class may not be properly initialized, as in some unit tests\n        closed = getattr(self, \"_closed\", None)\n        if closed:\n            raise ProgrammingError(\"Cannot operate on a closed database.\")\n        elif closed is None:\n            raise ProgrammingError(\"Base Connection.__init__ not called\")\n\n    @check_connection\n    def __enter__(self) -> Self:\n        return self\n\n    def __exit__(\n        self,\n        exc_type: Any,\n        exc_value: Any,\n        traceback: Any,\n    ) -> Literal[False]:\n        # https://docs.python.org/3/library/sqlite3.html#how-to-use-the-connection-context-manager\n        # https://github.com/python/cpython/blob/main/Modules/_sqlite/connection.c#L2262\n        if exc_type is None:\n            self.commit()\n        else:\n            try:\n                self.rollback()\n            except Exception as e:  # TODO: is this explicitly needed?\n                raise e from exc_value\n        return False\n\n    @check_thread\n    @check_connection\n    def __call__(self, sql: str) -> Statement:\n        return Statement(sql, _allow_instantiation=self)\n\n    def __repr__(self) -> str:\n        return \"%s<%s>\" % (self.__class__.__name__, id(self))\n\n    @property\n    def _log_prefix(self) -> str:\n        idx = self._database.find(\"?\")\n        db = self._database if idx < 1 else self._database[:idx]\n        return \"%r: database=%r \" % (self, db)\n\n    _log = functools.partial(_log_obj)\n    _dbg = functools.partialmethod(_log, logging.DEBUG)\n    _inf = functools.partialmethod(_log, logging.INFO)\n    _err = functools.partialmethod(_log, logging.ERROR)\n\n    @property\n    def autocommit(self) -> Autocommit:\n        return self._autocommit\n\n    @autocommit.setter\n    def autocommit(self, value: Autocommit) -> None:\n        check_valid_autocommit(value)\n        if value is True:\n            if self._in_transaction:\n                self.cursor()._query_execute(\"COMMIT\", want_rows=False)\n        elif value is False:\n            if not self._in_transaction:\n                self.cursor()._query_execute(\"BEGIN\", want_rows=False)\n        self._autocommit = value\n\n    @property\n    @check_connection\n    def total_changes(self) -> int:\n        # I don't think we have a way to reliably implement it,\n        # but maybe incrementing based on cursors's rowcount will do\n        raise NotSupportedError()\n\n    @property\n    @check_connection\n    def in_transaction(self) -> bool:\n        # In C this is is retrieved from sqlite3_get_autocommit()\n        # here we try to emulate this behavior, see Cursor.execute()\n        # see pysqlite_connection_get_in_transaction()\n        # https://github.com/python/cpython/blob/main/Modules/_sqlite/connection.c#L1691\n        # see Connection._update_in_transaction()\n        return self._in_transaction\n\n    def _sqlite3_get_autocommit(self) -> bool:\n        # We don't have this, so we emulate based in in_transaction,\n        # which in C is implemented on top of sqlite3_get_autocommit(),\n        # here we reverse that logic.\n        # see pysqlite_connection_get_in_transaction()\n        # https://github.com/python/cpython/blob/main/Modules/_sqlite/connection.c#L1691\n        return not self._in_transaction\n\n    @property\n    @check_connection\n    def isolation_level(self) -> Optional[IsolationLevel]:\n        return self._isolation_level\n\n    @isolation_level.setter\n    @check_connection\n    def isolation_level(self, level: Optional[IsolationLevel]) -> None:\n        if level is not None:\n            # required by RegressionTests.test_set_isolation_level()\n            if not isinstance(level, str):\n                raise TypeError(\"level must be a str\")\n            normalized_level = str(level).upper()\n            if normalized_level not in isolation_level_set:\n                raise ValueError(f\"unknown level: {normalized_level!r}\")\n            level = cast(Optional[IsolationLevel], normalized_level)\n\n        self._isolation_level = level\n        if level is None:\n            # Execute a COMMIT to re-enable autocommit mode\n            self.commit()\n\n    @overload\n    def cursor(self, factory: CursorFactory) -> \"Cursor\":\n        ...\n\n    @overload\n    def cursor(self) -> \"Cursor\":\n        ...\n\n    @check_thread\n    @check_connection\n    def cursor(\n        self,\n        *args: CursorFactory,\n        **kwargs: CursorFactory,\n    ) -> \"Cursor\":\n        if args:\n            factory = args[0]\n        elif \"factory\" in kwargs:\n            factory = kwargs[\"factory\"]\n        else:\n            factory = self.cursor_factory\n\n        if not callable(factory):\n            raise TypeError(\"factory must be callable\")\n\n        cursor = factory(self)\n        # While isinstance() should do,\n        # RowFactoryTests.test_fake_cursor_class() tests for a hack\n        # messing up with __class__\n        cur_tp = type(cursor)\n        if not issubclass(cur_tp, Cursor):\n            raise TypeError(\"factory must return a cursor\")\n        return cursor\n\n    def _add_cursor(self, cursor: \"Cursor\") -> None:\n        self._cursors.add(cursor)\n\n    def _remove_cursor(self, cursor: \"Cursor\") -> None:\n        self._cursors.discard(cursor)\n\n    def _get_statement(self, sql: str) -> Statement:\n        return self._cached_statement_getter(sql)\n\n    def _begin_transaction(self) -> None:\n        # see begin_transaction()\n        # https://github.com/python/cpython/blob/main/Modules/_sqlite/cursor.c#L476\n        assert self.isolation_level is not None\n        self.cursor()._query_execute(\n            f\"BEGIN {self.isolation_level}\",\n            want_rows=False,\n        )\n\n    def _begin_transaction_if_needed(self, statement: Statement) -> None:\n        # _pysqlite_query_execute()\n        # https://github.com/python/cpython/blob/main/Modules/_sqlite/cursor.c#L867-L877\n        if (\n            self._autocommit is LEGACY_TRANSACTION_CONTROL\n            and self.isolation_level is not None\n            and statement.is_dml\n            and self._sqlite3_get_autocommit()\n        ):\n            self._begin_transaction()\n\n    _begin_transaction_tokens: ClassVar[Set[str]] = {\"BEGIN\"}\n    _end_transaction_tokens: ClassVar[Set[str]] = {\"END\", \"COMMIT\", \"ROLLBACK\"}\n\n    def _update_in_transaction(self, statement: Statement) -> None:\n        # we cannot query sqlite3_get_autocommit(), then emulate\n        t = statement.tokens[0].upper()\n        if t in self._begin_transaction_tokens:\n            self._in_transaction = True\n        elif t in self._end_transaction_tokens:\n            self._in_transaction = False\n\n    @check_thread\n    @check_connection\n    def commit(self) -> None:\n        \"See :py:meth:`sqlite3.Connection.commit`\"\n        # See pysqlite_connection_commit_impl()\n        # https://github.com/python/cpython/blob/main/Modules/_sqlite/connection.c#L634\n        if self._autocommit is LEGACY_TRANSACTION_CONTROL:\n            if not self._sqlite3_get_autocommit():\n                self.cursor()._query_execute(\"COMMIT\", want_rows=False)\n        elif self._autocommit is False:\n            c = self.cursor()\n            c._query_execute(\"COMMIT\", want_rows=False)\n            c._query_execute(\"BEGIN\", want_rows=False)\n\n    @check_thread\n    @check_connection\n    def rollback(self) -> None:\n        \"See :py:meth:`sqlite3.Connection.rollback`\"\n        # See pysqlite_connection_rollback_impl()\n        # https://github.com/python/cpython/blob/main/Modules/_sqlite/connection.c#L668\n        if self._autocommit is LEGACY_TRANSACTION_CONTROL:\n            if not self._sqlite3_get_autocommit():\n                self.cursor()._query_execute(\"ROLLBACK\", want_rows=False)\n        elif self._autocommit is False:\n            c = self.cursor()\n            c._query_execute(\"ROLLBACK\", want_rows=False)\n            c._query_execute(\"BEGIN\", want_rows=False)\n\n    @abstractmethod\n    def _raw_close(self) -> None:\n        raise NotImplementedError()\n\n    @check_thread\n    def close(self) -> None:\n        \"See :py:meth:`sqlite3.Connection.close`\"\n        if self._closed:\n            return\n        if self._autocommit is False and not self._sqlite3_get_autocommit():\n            self.cursor()._query_execute(\"ROLLBACK\", want_rows=False)\n        self._dbg(\"closing %d cursors\", len(self._cursors))\n        for cursor in tuple(self._cursors):  # force a copy\n            cursor.close()\n        self._dbg(\"doing low level raw-close\")\n        self._raw_close()\n        self._dbg(\"finished low level raw-close\")\n        self._closed = True\n\n    def interrupt(self) -> None:\n        \"Does nothing\"\n        pass\n\n    def execute(\n        self,\n        sql: str,\n        parameters: SqlParameters = (),\n    ) -> \"Cursor\":\n        \"See :py:meth:`sqlite3.Connection.execute`\"\n        return self.cursor().execute(sql, parameters)\n\n    def executemany(\n        self,\n        sql: str,\n        parameters: Iterable[SqlParameters],\n    ) -> \"Cursor\":\n        \"See :py:meth:`sqlite3.Connection.executemany`\"\n        return self.cursor().executemany(sql, parameters)\n\n    def executescript(self, sql_script: str) -> \"Cursor\":\n        \"See :py:meth:`sqlite3.Connection.executescript`\"\n        return self.cursor().executescript(sql_script)\n\n    @check_connection\n    def iterdump(self) -> Iterator[str]:\n        \"See :py:meth:`sqlite3.Connection.iterdump`\"\n        return sqlite3_iterdump(self)\n\n    def _get_converter(self, key: str) -> Optional[ConverterCallback]:\n        # See _pysqlite_get_converter()\n        # https://github.com/python/cpython/blob/main/Modules/_sqlite/cursor.c#L186-L207\n        upcase_key = key.upper()\n        return sqlite3.converters.get(upcase_key)\n\n    @check_thread\n    @check_connection\n    def set_trace_callback(\n        self,\n        trace_callback: Optional[TraceCallback],\n    ) -> None:\n        \"See :py:meth:`sqlite3.Connection.set_trace_callback`\"\n        self._trace_callback = trace_callback\n\n    def _trace(self, sql: str) -> None:\n        if self._trace_callback is None:\n            return\n        try:\n            self._trace_callback(sql)\n        except Exception as e:\n            if _callback_tracebacks is False:\n                return\n\n            if sys.version_info[:2] >= (3, 8):\n                # this class is in sys.pyi but doesn't exist in runtime\n                class UnraisableHookArgs:\n                    exc_type = type(e)\n                    exc_value = e\n                    exc_traceback = e.__traceback__\n                    err_msg = f\"trace callback failed: {sql}\"\n                    object = self._trace_callback  # noqa: A003\n\n                sys.unraisablehook(UnraisableHookArgs())  # type: ignore\n            else:\n                self._dbg(\"trace callback failed: %r\", sql, exc_info=e)\n\n    # BEGIN: methods that are not supported when operating as RPC\n\n    if sys.version_info[:2] >= (3, 11):\n\n        def blobopen(\n            self,\n            table: str,\n            column: str,\n            row: str,\n            *,\n            readonly: bool = False,\n            name: str = \"main\",\n        ) -> Blob:\n            \"Unsupported by libsql_client.dbapi2\"\n            raise NotSupportedError()\n\n    def create_function(\n        self,\n        name: str,\n        narg: int,\n        func: Optional[Callable[..., SqlNativeType]],\n        *,\n        deterministic: bool = False,\n    ) -> None:\n        \"Unsupported by libsql_client.dbapi2\"\n        # maybe one day support with WASM\n        raise NotSupportedError()\n\n    def create_aggregate(\n        self,\n        name: str,\n        n_arg: int,\n        aggregate_class: Optional[Callable[..., Any]],\n    ) -> None:\n        \"Unsupported by libsql_client.dbapi2\"\n        # maybe one day support with WASM\n        raise NotSupportedError()\n\n    if sys.version_info[:2] >= (3, 11):\n\n        def create_window_function(\n            self,\n            name: str,\n            num_params: int,\n            aggregate_class: Optional[Callable[..., Any]],\n        ) -> None:\n            \"Unsupported by libsql_client.dbapi2\"\n            # maybe one day support with WASM\n            raise NotSupportedError()\n\n    def create_collation(\n        self,\n        name: str,\n        _callable: Optional[Callable[[str, str], int]],\n    ) -> None:\n        \"Unsupported by libsql_client.dbapi2\"\n        # maybe one day support with WASM\n        raise NotSupportedError()\n\n    def set_authorizer(\n        self,\n        authorizer_callback: Optional[AuthorizerCallback],\n    ) -> None:\n        \"Unsupported by libsql_client.dbapi2\"\n        # maybe one day support with WASM\n        raise NotSupportedError()\n\n    def set_progress_handler(\n        self,\n        progress_handler: Optional[ProgressHandler],\n        n: int,\n    ) -> None:\n        \"Unsupported by libsql_client.dbapi2\"\n        # not likely to be supported\n        raise NotSupportedError()\n\n    def enable_load_extension(self, enabled: bool) -> None:\n        \"Unsupported by libsql_client.dbapi2\"\n        # not likely to be supported\n        raise NotSupportedError()\n\n    def load_extension(self, path: str) -> None:\n        \"Unsupported by libsql_client.dbapi2\"\n        # not likely to be supported\n        raise NotSupportedError()\n\n    def backup(\n        self,\n        target: \"Connection\",\n        *,\n        pages: int = -1,\n        progress: Optional[BackupProgressCallback] = None,\n        name: str = \"main\",\n        sleep: float = 0.250,\n    ) -> None:\n        \"Unsupported by libsql_client.dbapi2\"\n        # not likely to be supported\n        raise NotSupportedError()\n\n    if sys.version_info[:2] >= (3, 11):\n\n        def getlimit(self, category: int) -> int:\n            \"Unsupported by libsql_client.dbapi2\"\n            try:\n                return self._limits[category]\n            except KeyError:\n                raise ProgrammingError(f\"unknown category: {category}\")\n\n        def setlimit(self, category: int, limit: int) -> int:\n            \"Unsupported by libsql_client.dbapi2\"\n            old = self.getlimit(category)\n            if limit >= 0:\n                self._limits[category] = limit\n            return old\n\n        def serialize(self, *, name: str = \"main\") -> bytes:\n            # not likely to be supported\n            \"Unsupported by libsql_client.dbapi2\"\n            raise NotSupportedError()\n\n        def deserialize(self, data: bytes, *, name: str = \"main\") -> None:\n            # not likely to be supported\n            # maybe use DatabaseError since it's declared in the original doc\n            \"Unsupported by libsql_client.dbapi2\"\n            raise NotSupportedError()", "\n    # END: methods that are not supported when operating as RPC\n\n\nCursorColumnDescription = Tuple[\n    str,  # name\n    None,  # type_code: sqlite also uses None in here\n    None,  # display_size\n    None,  # internal_size\n    None,  # precision", "    None,  # internal_size\n    None,  # precision\n    None,  # scale\n    None,  # null_ok\n]\nCursorDescription = Tuple[CursorColumnDescription, ...]\nRowCastMap = Tuple[Optional[ConverterCallback], ...]\n\n\ndef tuple_row_factory(\n    cursor: \"Cursor\",\n    cells: Iterable[Any],\n) -> Tuple[Any, ...]:\n    \":meta private:\"\n    return tuple(cells)", "\ndef tuple_row_factory(\n    cursor: \"Cursor\",\n    cells: Iterable[Any],\n) -> Tuple[Any, ...]:\n    \":meta private:\"\n    return tuple(cells)\n\n\nclass Row(collections.abc.Sequence):\n    \"\"\"Implement :py:class:`sqlite3.Row`\"\"\"\n\n    _description: CursorDescription\n    _data: Tuple[Any, ...]\n    __slots__ = (\"_description\", \"_data\")\n\n    def __init__(self, cursor: \"Cursor\", data: Iterable[Any]) -> None:\n        # While isinstance() should do,\n        # RowFactoryTests.test_fake_cursor_class() tests for a hack\n        # messing up with __class__\n        cur_tp = type(cursor)\n        if not issubclass(cur_tp, Cursor):\n            cls_name = self.__class__.__name__\n            cur_name = Cursor.__name__\n            got_name = type(cursor).__name__\n            msg = f\"{cls_name} argument 1 must be {cur_name}, not {got_name}\"\n            raise TypeError(msg)\n\n        description = getattr(cursor, \"description\", None)\n        if not description:\n            raise TypeError(\"cursor lacks description\")\n\n        self._description = description\n        self._data = tuple(data)\n\n    def __hash__(self) -> int:\n        return hash(self._description) ^ hash(self._data)\n\n    def __iter__(self) -> Iterator[Any]:\n        return iter(self._data)\n\n    def __len__(self) -> int:\n        return len(self._data)\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Row):\n            return False\n        if self._description != other._description:\n            return False\n        return self._data == other._data\n\n    def __getitem__(self, idx: Union[int, str, slice]) -> Any:\n        if isinstance(idx, (int, slice)):\n            return self._data[idx]\n        elif isinstance(idx, str):\n            idx_lower = idx.lower() if idx.isascii() else None\n            # similar to equal_ignore_case() in row.c,\n            # RowFactoryTests.test_sqlite_row_index_unicode checks this\n            for i, d in enumerate(self._description):\n                d_name = d[0]\n                if d_name == idx:\n                    return self._data[i]\n                if not isinstance(d_name, str):\n                    continue\n                if idx_lower is None or not d_name.isascii():\n                    continue\n                if idx_lower == d_name.lower():\n                    return self._data[i]\n\n            raise IndexError(\"No item with that key\")\n        else:\n            raise IndexError(\"Index must be int or string\")\n\n    def keys(self) -> List[str]:\n        return [d[0] for d in self._description]", "\nclass Row(collections.abc.Sequence):\n    \"\"\"Implement :py:class:`sqlite3.Row`\"\"\"\n\n    _description: CursorDescription\n    _data: Tuple[Any, ...]\n    __slots__ = (\"_description\", \"_data\")\n\n    def __init__(self, cursor: \"Cursor\", data: Iterable[Any]) -> None:\n        # While isinstance() should do,\n        # RowFactoryTests.test_fake_cursor_class() tests for a hack\n        # messing up with __class__\n        cur_tp = type(cursor)\n        if not issubclass(cur_tp, Cursor):\n            cls_name = self.__class__.__name__\n            cur_name = Cursor.__name__\n            got_name = type(cursor).__name__\n            msg = f\"{cls_name} argument 1 must be {cur_name}, not {got_name}\"\n            raise TypeError(msg)\n\n        description = getattr(cursor, \"description\", None)\n        if not description:\n            raise TypeError(\"cursor lacks description\")\n\n        self._description = description\n        self._data = tuple(data)\n\n    def __hash__(self) -> int:\n        return hash(self._description) ^ hash(self._data)\n\n    def __iter__(self) -> Iterator[Any]:\n        return iter(self._data)\n\n    def __len__(self) -> int:\n        return len(self._data)\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Row):\n            return False\n        if self._description != other._description:\n            return False\n        return self._data == other._data\n\n    def __getitem__(self, idx: Union[int, str, slice]) -> Any:\n        if isinstance(idx, (int, slice)):\n            return self._data[idx]\n        elif isinstance(idx, str):\n            idx_lower = idx.lower() if idx.isascii() else None\n            # similar to equal_ignore_case() in row.c,\n            # RowFactoryTests.test_sqlite_row_index_unicode checks this\n            for i, d in enumerate(self._description):\n                d_name = d[0]\n                if d_name == idx:\n                    return self._data[i]\n                if not isinstance(d_name, str):\n                    continue\n                if idx_lower is None or not d_name.isascii():\n                    continue\n                if idx_lower == d_name.lower():\n                    return self._data[i]\n\n            raise IndexError(\"No item with that key\")\n        else:\n            raise IndexError(\"Index must be int or string\")\n\n    def keys(self) -> List[str]:\n        return [d[0] for d in self._description]", "\n\ndef check_cursor(fn: Callable[P, T]) -> Callable[P, T]:\n    \"\"\"Decorator that checks :py:class:`Cursor` being valid\n\n    Otherwise raises ``ProgrammingError``.\n\n    :meta private:\n    \"\"\"\n\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n        self = args[0]\n        assert len(args) > 0 and isinstance(self, Cursor)\n        self._do_check_cursor()\n        return fn(*args, **kwargs)\n\n    return wrapper", "\n\n# https://github.com/python/cpython/blob/main/Modules/_sqlite/util.c#L28-L67C2\n_exc_code_map = {\n    \"SQLITE_INTERNAL\": InternalError,\n    \"SQL_INPUT_ERROR\": OperationalError,\n    \"SQLITE_NOTFOUND\": InternalError,\n    \"SQLITE_NOMEM\": MemoryError,\n    \"SQLITE_ERROR\": OperationalError,\n    \"SQLITE_PERM\": OperationalError,", "    \"SQLITE_ERROR\": OperationalError,\n    \"SQLITE_PERM\": OperationalError,\n    \"SQLITE_ABORT\": OperationalError,\n    \"SQLITE_BUSY\": OperationalError,\n    \"SQLITE_LOCKED\": OperationalError,\n    \"SQLITE_READONLY\": OperationalError,\n    \"SQLITE_INTERRUPT\": OperationalError,\n    \"SQLITE_IOERR\": OperationalError,\n    \"SQLITE_FULL\": OperationalError,\n    \"SQLITE_CANTOPEN\": OperationalError,", "    \"SQLITE_FULL\": OperationalError,\n    \"SQLITE_CANTOPEN\": OperationalError,\n    \"SQLITE_PROTOCOL\": OperationalError,\n    \"SQLITE_EMPTY\": OperationalError,\n    \"SQLITE_SCHEMA\": OperationalError,\n    \"SQLITE_CORRUPT\": DatabaseError,\n    \"SQLITE_TOOBIG\": DataError,\n    \"SQLITE_CONSTRAINT\": IntegrityError,\n    \"SQLITE_MISMATCH\": IntegrityError,\n    \"SQLITE_MISUSE\": InterfaceError,", "    \"SQLITE_MISMATCH\": IntegrityError,\n    \"SQLITE_MISUSE\": InterfaceError,\n    \"SQLITE_RANGE\": InterfaceError,\n    \"SQLITE_UNKNOWN\": OperationalError,\n    \"PROGRAMMING_ERROR\": ProgrammingError,\n    \"ARGS_INVALID\": ProgrammingError,\n    \"UNICODE_ERROR\": OperationalError,\n    \"VALUE_ERROR\": OperationalError,\n    \"UNKNOWN\": OperationalError,\n}", "    \"UNKNOWN\": OperationalError,\n}\n\n\ndef _raise_converted_exception(exc: BaseException) -> NoReturn:\n    if not isinstance(exc, LibsqlError):\n        raise exc\n\n    code = exc.code\n    cls = None\n    while code and cls is None:\n        cls = _exc_code_map.get(code)\n        if cls is None and code.startswith(\"SQLITE_\"):\n            # fallback to mapped error, example:\n            # SQLITE_CONSTRAINT_UNIQUE -> SQLITE_CONSTRAINT\n            code = code.rsplit(\"_\", 1)[0]\n            if code == \"SQLITE\":\n                break\n        else:\n            break\n\n    if cls is None:\n        cls = DatabaseError\n\n    dbapi2_exc = cls(str(exc))\n\n    sqlite_errorcode = getattr(_reexports, exc.code, None)\n    dbapi2_exc.sqlite_errorname = exc.code  # type: ignore\n    dbapi2_exc.sqlite_errorcode = sqlite_errorcode  # type: ignore\n\n    raise dbapi2_exc from exc", "\n\ndef _get_value_bytes(value: proto.Value) -> Optional[bytes]:\n    # mimics https://www.sqlite.org/c3ref/column_blob.html\n    # usage in _pysqlite_fetch_one_row(), converter != Py_None branch at\n    # https://github.com/python/cpython/blob/main/Modules/_sqlite/cursor.c\n    v = _value_from_proto(value)\n    if v is None:\n        return None  # blob == NULL in their code\n    if isinstance(v, bytes):\n        return v\n    if isinstance(v, str):\n        return v.encode()\n    if isinstance(v, int):\n        return str(v).encode()  # ASCII rendering of the integer\n    if isinstance(v, float):\n        # https://www.sqlite.org/lang_expr.html#castexpr\n        return str(v).encode()  # converts to text\n\n    raise NotImplementedError(f\"cannot handle value type {type(v)}\")", "\n\ndef _get_value_converted(\n    value: proto.Value,\n    text_factory: Optional[TextFactory],\n) -> Any:\n    v = _value_from_proto(value)\n    if not isinstance(v, str) or text_factory is None or text_factory is str:\n        return v\n    b = v.encode()\n    if text_factory is bytes:\n        return b\n    return text_factory(b)", "\n\nclass Cursor(metaclass=ABCMeta):\n    \":meta private:\"\n    _connection: Connection\n    _description: Optional[CursorDescription]\n    _row_cast_map: Optional[RowCastMap]\n    arraysize: int\n    _lastrowid: Optional[int]\n    _rowcount: int\n    row_factory: Optional[RowFactory]\n    _rows: Optional[List[RawRow]]\n    _rows_iter_idx: int\n    _raw_results: Optional[RawExecuteResult]\n    _closed: bool\n    _locked: bool\n\n    __slots__ = (\n        \"_connection\",\n        \"_description\",\n        \"_row_cast_map\",\n        \"arraysize\",\n        \"_lastrowid\",\n        \"_rowcount\",\n        \"row_factory\",\n        \"_rows\",\n        \"_rows_iter_idx\",\n        \"_raw_results\",\n        \"_closed\",\n        \"_locked\",\n    )\n\n    def __init__(self, connection: Connection) -> None:\n        if not isinstance(connection, Connection):\n            # be safe, pass CursorTests.test_cursor_wrong_class\n            raise TypeError(\"connection must be instance of 'Connection'\")\n\n        self._connection = connection\n        self._connection._add_cursor(self)\n        self.arraysize = 1\n        self.row_factory = None\n        self._lastrowid = None  # not reset by _reset_result()\n        self._closed = False\n        self._locked = False\n        self._reset_result()\n\n    def __del__(self) -> None:\n        self._dbg(\"destroying\")\n        if getattr(self, \"_closed\", False):  # __init__() may have failed\n            try:\n                self.close()\n            except Exception as e:\n                self._err(\"failed to close cursor: %s\", e, exc_info=e)\n        self._dbg(\"destroyed\")\n\n    def __repr__(self) -> str:\n        return \"%s<%s>\" % (self.__class__.__name__, id(self))\n\n    @property\n    def _log_prefix(self) -> str:\n        return \"%r: connection=%r \" % (self, self._connection)\n\n    _log = functools.partial(_log_obj)\n    _dbg = functools.partialmethod(_log, logging.DEBUG)\n    _inf = functools.partialmethod(_log, logging.INFO)\n    _err = functools.partialmethod(_log, logging.ERROR)\n\n    def _do_check_cursor(self) -> None:\n        # class may not be properly initialized, as in some unit tests\n        closed = getattr(self, \"_closed\", None)\n        if closed:\n            raise ProgrammingError(\"Cannot operate on a closed cursor.\")\n        elif closed is None:\n            raise ProgrammingError(\"Base Cursor.__init__ not called.\")\n        self._connection._do_check_thread()\n        self._connection._do_check_connection()\n        self._do_check_locked()\n\n    def _do_check_locked(self) -> None:\n        # class may not be properly initialized, as in some unit tests\n        locked = getattr(self, \"_locked\", None)\n        if locked:\n            raise ProgrammingError(\"Recursive use of cursors not allowed\")\n        elif locked is None:\n            raise ProgrammingError(\"Base Cursor.__init__ not called.\")\n\n    def _reset_result(self, statement: Optional[Statement] = None) -> None:\n        is_dml = statement.is_dml if statement else False\n        self._description = None\n        self._row_cast_map = None\n        self._rowcount = 0 if is_dml else -1\n        self._rows = None\n        self._rows_iter_idx = 0\n        self._raw_results = None\n\n    @property\n    def connection(self) -> Connection:\n        \"Returns :py:class:`Connection`\"\n        return self._connection\n\n    @property\n    def description(self) -> Optional[CursorDescription]:\n        \"See :py:attr:`sqlite3.Cursor.description`\"\n        return self._description\n\n    @property\n    def lastrowid(self) -> Optional[int]:\n        \"See :py:attr:`sqlite3.Cursor.lastrowid`\"\n        return self._lastrowid\n\n    @property\n    def rowcount(self) -> int:\n        \"See :py:attr:`sqlite3.Cursor.rowcount`\"\n        return self._rowcount\n\n    @abstractmethod\n    def _raw_execute(\n        self,\n        sql: str,\n        parameters: Iterable[SqlParameters],\n        *,\n        want_rows: bool = True,\n    ) -> RawExecuteResult:\n        # each system should implement this one\n        raise NotImplementedError()\n\n    def _apply_raw_results(self, raw_results: RawResults) -> None:\n        row_id = raw_results[\"last_insert_rowid\"]\n        self._lastrowid = int(row_id) if row_id else None\n        if self._rowcount >= 0:  # -1 if not is_dml\n            self._rowcount += raw_results[\"affected_row_count\"]\n        self._apply_raw_results_description(raw_results)\n        self._apply_raw_results_rows(raw_results)\n\n    def _apply_raw_results_description(self, raw_results: RawResults) -> None:\n        columns = raw_results[\"cols\"]\n        if self._description is not None or len(columns) == 0:\n            return\n\n        description: List[CursorColumnDescription] = []\n        row_cast_map: List[Optional[ConverterCallback]] = []\n        for column in columns:\n            desc, cast_cb = self._get_column_description_and_cast(column)\n            description.append(desc)\n            row_cast_map.append(cast_cb)\n\n        self._description = tuple(description)\n        if row_cast_map.count(None) == len(row_cast_map):\n            self._row_cast_map = None\n        else:\n            self._row_cast_map = tuple(row_cast_map)\n\n    def _apply_raw_results_rows(self, raw_results: RawResults) -> None:\n        self._rows = raw_results[\"rows\"]\n        self._rows_iter_idx = 0\n\n    def _convert_row(self, row: RawRow) -> Any:\n        row_factory = (\n            self.row_factory or self.connection.row_factory or tuple_row_factory\n        )\n\n        return row_factory(self, self._get_cells(row))\n\n    def _get_cells(self, row: RawRow) -> Iterable[Any]:\n        # See _pysqlite_fetch_one_row()\n        # https://github.com/python/cpython/blob/main/Modules/_sqlite/cursor.c#L319\n        # https://docs.python.org/3/library/sqlite3.html#how-to-convert-sqlite-values-to-custom-python-types\n        cells = []\n        _row_cast_map = self._row_cast_map\n        text_factory = self.connection.text_factory\n        for i, v in enumerate(row):\n            if _row_cast_map is not None:\n                converter = _row_cast_map[i]\n            else:\n                converter = None\n\n            if converter is not None:\n                item = _get_value_bytes(v)\n                if item:\n                    converted = converter(item)\n                else:\n                    converted = None\n            else:\n                converted = _get_value_converted(v, text_factory)\n\n            cells.append(converted)\n\n        return cells\n\n    _row_colname_parser_re = re.compile(\n        r\"^(?P<name>[^[]+)\\s*\\[(?P<type_name>[^]]+)\\]\",\n    )\n\n    _row_decltype_parser_re = re.compile(r\"^(?P<type_name>[^ (]+)\")\n\n    def _get_column_description_and_cast(\n        self,\n        col: RawColumn,\n    ) -> Tuple[CursorColumnDescription, Optional[ConverterCallback]]:\n        name = col.get(\"name\") or \"\"\n        converter: Optional[ConverterCallback] = None\n\n        detect_types = self.connection._detect_types\n        get_converter = self.connection._get_converter\n\n        if detect_types & sqlite3.PARSE_COLNAMES:\n            m = self._row_colname_parser_re.match(name)\n            if m is not None:\n                name = m.group(\"name\").strip()\n                type_name = m.group(\"type_name\")\n                converter = get_converter(type_name)\n\n        if not converter and detect_types & sqlite3.PARSE_DECLTYPES:\n            decltype = col.get(\"decltype\") or \"\"\n            m = self._row_decltype_parser_re.match(decltype)\n            if m is not None:\n                type_name = m.group(\"type_name\")\n                converter = get_converter(type_name)\n\n        return ((name, None, None, None, None, None, None), converter)\n\n    _no_adapt_types = (int, float, str, bytes, bytearray, memoryview)\n\n    def _adapt_param_value(self, obj: Any) -> SqlData:\n        # see need_adapt(), but we can't optimize on BaseTypeAdapted\n        # https://github.com/python/cpython/blob/main/Modules/_sqlite/cursor.c#L614-L627\n        try:\n            t = type(obj)\n\n            # See pysqlite_microprotocols_adapt()\n            # https://github.com/python/cpython/blob/main/Modules/_sqlite/microprotocols.c\n            # https://peps.python.org/pep-0246/\n            proto = sqlite3.PrepareProtocol\n            key = (t, proto)\n            adapter = sqlite3.adapters.get(key)\n            if adapter is not None:\n                return adapter(obj)\n\n            # try to have the protocol adapt this object\n            adapter = getattr(proto, \"___adapt__\", None)\n            if adapter is not None:\n                adapted = adapter(obj)\n                if adapted is not None:\n                    return adapted\n\n            # and finally try to have the object adapt itself\n            adapter = getattr(obj, \"__conform__\", None)\n            if adapter is not None:\n                adapted = adapter(proto)\n                if adapted is not None:\n                    return adapted\n\n            if obj is None:\n                return obj\n            if not isinstance(obj, self._no_adapt_types):\n                memoryview(obj)  # TypeError if not bytes-like\n                return obj\n\n            return obj\n        except TypeError:\n            raise ProgrammingError(\"can't adapt\")\n\n    def _adapt_params(self, parameters: SqlParameters) -> SqlParameters:\n        if isinstance(parameters, collections.abc.Mapping):\n            return {k: self._adapt_param_value(v) for k, v in parameters.items()}\n        elif parameters:\n            # SupportsLenAndGetItem is only __len__ + __getitem__, no __iter__\n            # so create the list manually :-(\n            return [\n                self._adapt_param_value(parameters[i]) for i in range(len(parameters))\n            ]\n        return parameters\n\n    @check_cursor\n    def _query_execute(\n        self,\n        sql: str,\n        parameters: Iterable[SqlParameters] = ((),),\n        *,\n        multiple: bool = False,\n        want_rows: bool = True,\n    ) -> Self:\n        if not isinstance(sql, str):\n            # required by test CursorTests.test_execute_many_wrong_sql_arg()\n            raise TypeError(\"sql must be a str\")\n        if not sql:\n            return self\n\n        params = tuple(self._adapt_params(p) for p in parameters)\n\n        # See _pysqlite_query_execute()\n        # https://github.com/python/cpython/blob/main/Modules/_sqlite/cursor.c#L781\n        try:\n            self._dbg(\"execute: %r, %r\", sql, params)\n            statement = self._connection._get_statement(sql)\n            if multiple and statement.is_readonly:\n                msg = \"executemany() can only execute DML statements.\"\n                raise ProgrammingError(msg)\n            self._reset_result(statement)\n            self._connection._begin_transaction_if_needed(statement)\n\n            # Locking is not that meaningful with libsql_client since\n            # we don't callback to python during execution as done by\n            # create_function() and the likes. Nevertheless keep it here\n            # NOTE: _begin_transaction_if_needed() will call this function\n            # so do not lock before this point!\n            self._locked = True\n            self._raw_results = self._raw_execute(\n                sql,\n                params,\n                want_rows=want_rows,\n            )\n            for result, error in self._raw_results:\n                if error is not None:\n                    self._rowcount = -1  # as per cursor.c\n                    _raise_converted_exception(error)\n                assert result is not None\n                self._apply_raw_results(result)\n\n            self._connection._update_in_transaction(statement)\n            return self\n        finally:\n            self._locked = False\n\n    def execute(\n        self,\n        sql: str,\n        parameters: SqlParameters = (),\n    ) -> Self:\n        \"See :py:meth:`sqlite3.Cursor.execute`\"\n        if not isinstance(parameters, collections.abc.Mapping) and not (\n            hasattr(parameters, \"__len__\") and hasattr(parameters, \"__getitem__\")\n        ):\n            raise ProgrammingError(\"parameters are of unsupported type\")\n        self._query_execute(sql, (parameters,), multiple=False, want_rows=True)\n        return self\n\n    def executemany(\n        self,\n        sql: str,\n        parameters: Iterable[SqlParameters],\n    ) -> Self:\n        \"See :py:meth:`sqlite3.Cursor.executemany`\"\n        self._query_execute(sql, parameters, multiple=True, want_rows=False)\n        return self\n\n    @abstractmethod\n    def _raw_execute_script(self, sql_script: str) -> None:\n        raise NotImplementedError()\n\n    @check_cursor\n    def executescript(self, sql_script: str) -> Self:\n        \"See :py:meth:`sqlite3.Cursor.executescript`\"\n        # See pysqlite_cursor_executescript_impl()\n        # https://github.com/python/cpython/blob/main/Modules/_sqlite/cursor.c#L1046-L1060\n        if self._connection._autocommit is LEGACY_TRANSACTION_CONTROL:\n            if not self._connection._sqlite3_get_autocommit():\n                self._query_execute(\"COMMIT\", want_rows=False)\n\n        self._raw_execute_script(sql_script)\n        return self\n\n    def __iter__(self) -> Self:\n        return self\n\n    @check_cursor\n    def __next__(self) -> Any:\n        # TODO: we're just doing a single raw_results in a batch,\n        # seems to match the behavior when calling executemany() (\"multiple\")\n        if self._rows is None:\n            raise StopIteration\n\n        idx = self._rows_iter_idx\n        self._rows_iter_idx += 1\n        try:\n            row = self._rows[idx]\n        except IndexError:\n            raise StopIteration\n\n        try:\n            self._locked = True\n            return self._convert_row(row)\n        finally:\n            self._locked = False\n\n    def fetchone(self) -> Any:\n        \"See :py:meth:`sqlite3.Cursor.fetchone`\"\n        return next(self, None)\n\n    def fetchmany(self, size: Optional[int] = None) -> List[Any]:\n        \"See :py:meth:`sqlite3.Cursor.fetchmany`\"\n        if size is None or size < 1:\n            assert self.arraysize > 0\n            size = self.arraysize\n\n        result = []\n        for i, row in enumerate(self):\n            if i == size:\n                break\n            result.append(row)\n\n        return result\n\n    def fetchall(self) -> List[Any]:\n        \"See :py:meth:`sqlite3.Cursor.fetchall`\"\n        return list(self)\n\n    @abstractmethod\n    def _raw_close(self) -> None:\n        raise NotImplementedError()\n\n    def close(self) -> None:\n        \"See :py:meth:`sqlite3.Cursor.close`\"\n        # class may not be properly initialized, as in some unit tests\n        closed = getattr(self, \"_closed\", None)\n        if closed:\n            return\n        self._do_check_locked()\n        self._connection._do_check_thread()\n        self._connection._do_check_connection()\n        self.connection._remove_cursor(self)\n        self._closed = True\n        self._reset_result()\n        self._raw_close()\n\n    def setinputsizes(self, sizes: Any) -> None:\n        \"Does nothing\"\n        # Required by the DB-API. Does nothing in sqlite3.\n        pass\n\n    def setoutputsize(self, size: int, column: Any = None) -> None:\n        \"Does nothing\"\n        # Required by the DB-API. Does nothing in sqlite3.\n        pass", ""]}
{"filename": "libsql_client/dbapi2/hrana.py", "chunked_list": ["from __future__ import annotations\n\nimport asyncio\nimport collections.abc\nimport sqlite3.dbapi2\nimport sys\nfrom typing import Awaitable\nfrom typing import Callable\nfrom typing import Iterable\nfrom typing import List", "from typing import Iterable\nfrom typing import List\nfrom typing import Optional\nfrom typing import overload\nfrom typing import Tuple\nfrom typing import Type\nfrom typing import TYPE_CHECKING\nfrom typing import TypeVar\n\nimport aiohttp", "\nimport aiohttp\nfrom typing_extensions import ParamSpec\n\nfrom ._async_executor import AsyncExecutor\nfrom .types import Autocommit\nfrom .types import Connection\nfrom .types import Cursor\nfrom .types import IsolationLevel\nfrom .types import LEGACY_TRANSACTION_CONTROL", "from .types import IsolationLevel\nfrom .types import LEGACY_TRANSACTION_CONTROL\nfrom .types import OperationalError\nfrom .types import RawExecuteResult\nfrom .types import SqlParameters\nfrom ..client import LibsqlError\nfrom ..config import _expand_config\nfrom ..hrana.client import _config_to_url\nfrom ..hrana.conn import HranaConn\nfrom ..hrana.conn import HranaStream", "from ..hrana.conn import HranaConn\nfrom ..hrana.conn import HranaStream\nfrom ..hrana.convert import _error_from_proto\nfrom ..hrana.convert import _value_to_proto\nfrom ..hrana.proto import Batch\nfrom ..hrana.proto import BatchResult\nfrom ..hrana.proto import BatchStep\nfrom ..hrana.proto import Error as ErrorResult\nfrom ..hrana.proto import Stmt\nfrom ..hrana.proto import StmtResult", "from ..hrana.proto import Stmt\nfrom ..hrana.proto import StmtResult\n\n\n# TODO: we're creating a whole sync client for each connection, but we\n# could create a single thread for all connections of the same URL,\n# with a single HranaClient/HranaConn, and just get a HranaStream.\n# But this requires us to change ClientSync and other stuff, will\n# do it later.\n", "# do it later.\n\nP = ParamSpec(\"P\")\nT = TypeVar(\"T\")\n\n\ndef _create_hrana_connection(\n    session: aiohttp.ClientSession,\n    url: str,\n) -> HranaConn:\n    config = _expand_config(url, auth_token=None, tls=None)\n\n    try:\n        if config.scheme not in (\"ws\", \"wss\"):\n            raise LibsqlError(\n                \"Only 'libsql', 'ws' and 'wss' URLs are supported,\"\n                f\" got {config.scheme!r}\",\n                \"URL_INVALID\",\n            )\n        url = _config_to_url(config)\n    except LibsqlError as e:\n        if e.code == \"URL_INVALID\":\n            sqlite_err = OperationalError(str(e))\n            sqlite_err.sqlite_errorcode = 14  # type: ignore\n            sqlite_err.sqlite_errorname = \"SQLITE_CANTOPEN\"  # type: ignore\n            raise sqlite_err\n        raise\n\n    return HranaConn(session, url, config.auth_token)", "\n\ndef _conv_stmt_plain_to_stored(stmt: Stmt, sql_id: int) -> Stmt:\n    del stmt[\"sql\"]\n    stmt[\"sql_id\"] = sql_id\n    return stmt\n\n\ndef _conv_stmt(\n    sql: str,\n    parameters: SqlParameters,\n    want_rows: bool,\n) -> Stmt:\n    stmt: Stmt = {\n        \"sql\": sql,\n        \"want_rows\": want_rows,\n    }\n    if isinstance(parameters, collections.abc.Mapping):\n        stmt[\"named_args\"] = [\n            {\"name\": k, \"value\": _value_to_proto(v)} for k, v in parameters.items()\n        ]\n    elif parameters:\n        # SupportsLenAndGetItem is only __len__ + __getitem__, no __iter__\n        # so create the list manually :-(\n        args = []\n        for i in range(len(parameters)):\n            args.append(_value_to_proto(parameters[i]))\n        stmt[\"args\"] = args\n\n    return stmt", "def _conv_stmt(\n    sql: str,\n    parameters: SqlParameters,\n    want_rows: bool,\n) -> Stmt:\n    stmt: Stmt = {\n        \"sql\": sql,\n        \"want_rows\": want_rows,\n    }\n    if isinstance(parameters, collections.abc.Mapping):\n        stmt[\"named_args\"] = [\n            {\"name\": k, \"value\": _value_to_proto(v)} for k, v in parameters.items()\n        ]\n    elif parameters:\n        # SupportsLenAndGetItem is only __len__ + __getitem__, no __iter__\n        # so create the list manually :-(\n        args = []\n        for i in range(len(parameters)):\n            args.append(_value_to_proto(parameters[i]))\n        stmt[\"args\"] = args\n\n    return stmt", "\n\ndef _conv_stmts(\n    sql: str,\n    parameters: Iterable[SqlParameters],\n    want_rows: bool,\n) -> List[Stmt]:\n    return [_conv_stmt(sql, p, want_rows) for p in parameters]\n\n", "\n\n_aiohttp_error_map = (\n    (aiohttp.InvalidURL, \"SQLITE_CANTOPEN\"),\n    (aiohttp.ClientConnectionError, \"SQLITE_CANTOPEN\"),\n    (aiohttp.ClientResponseError, \"SQLITE_CANTOPEN\"),\n    (aiohttp.ClientPayloadError, \"SQLITE_IOERR\"),\n)\n\n\ndef _get_aiohttp_client_error_code(\n    error: aiohttp.ClientError,\n) -> Tuple[int, str]:\n    for error_cls, error_name in _aiohttp_error_map:\n        if isinstance(error, error_cls):\n            error_code = getattr(sqlite3.dbapi2, error_name)\n            return error_code, error_name\n    return 0, \"\"", "\n\ndef _get_aiohttp_client_error_code(\n    error: aiohttp.ClientError,\n) -> Tuple[int, str]:\n    for error_cls, error_name in _aiohttp_error_map:\n        if isinstance(error, error_cls):\n            error_code = getattr(sqlite3.dbapi2, error_name)\n            return error_code, error_name\n    return 0, \"\"", "\n\ndef _conv_stmt_result(\n    result: Optional[StmtResult],\n    error: Optional[BaseException],\n) -> RawExecuteResult:\n    if isinstance(error, aiohttp.ClientError):\n        code, name = _get_aiohttp_client_error_code(error)\n        error = OperationalError(str(error))\n        if code:\n            error.sqlite_errorcode = code  # type: ignore\n            error.sqlite_errorname = name  # type: ignore\n\n    return RawExecuteResult([result], [error])", "\n\ndef _conv_batch(stmts: List[Stmt]) -> Batch:\n    steps: List[BatchStep] = []\n\n    for i, stmt in enumerate(stmts):\n        if i == 0:\n            steps.append({\"stmt\": stmt})\n        else:\n            steps.append(\n                {\n                    \"condition\": {\"type\": \"ok\", \"step\": i - 1},\n                    \"stmt\": stmt,\n                }\n            )\n\n    return {\"steps\": steps}", "\n\ndef _conv_batch_result(resp: BatchResult) -> RawExecuteResult:\n    def conv_err(e: Optional[ErrorResult]) -> Optional[BaseException]:\n        if e is None:\n            return None\n        return _error_from_proto(e)\n\n    errors = [conv_err(e) for e in resp[\"step_errors\"]]\n    return RawExecuteResult(resp[\"step_results\"], errors)", "\n\nif TYPE_CHECKING:\n    if sys.version_info[:2] >= (3, 9):\n\n        @overload\n        def run_in_executor(\n            fn: Callable[P, Awaitable[asyncio.Future[T]]],\n        ) -> Callable[P, T]:\n            ...\n\n    @overload\n    def run_in_executor(fn: Callable[P, Awaitable[T]]) -> Callable[P, T]:\n        ...\n\n    @overload\n    def run_in_executor(fn: Callable[P, T]) -> Callable[P, T]:\n        ...", "\n\ndef run_in_executor(fn: Callable[P, T]) -> Callable[P, T]:\n    \"\"\"ConnectionHrana method decorator that runs code in the executor thread.\n\n    This will execute the decorated method body inside the\n    :py:class:`AsyncExecutor` thread by doing a ``AsyncExecutor.submit()``\n    and then ``future.result(timeout)``.\n\n    The method itself will block until the executor runs.\n\n    :meta private:\n    \"\"\"\n\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n        self = args[0]\n        assert isinstance(self, ConnectionHrana)\n        assert self._executor is not None\n\n        future = self._executor.submit(fn, *args, **kwargs)\n\n        return future.result(timeout=self._timeout)\n\n    return wrapper", "\n\nclass ConnectionHrana(Connection):\n    \"\"\"Implement :py:class:`sqlite3.Connection` for remote servers\n    using the `Hrana Protocol\n    <https://github.com/libsql/sqld/blob/main/docs/HRANA_2_SPEC.md>`_.\n    \"\"\"\n\n    _executor: Optional[AsyncExecutor]  # TODO: share\n    _session: Optional[aiohttp.ClientSession]  # TODO: share (per url)\n    _conn: Optional[HranaConn]  # TODO: share (per url)\n    _stream: Optional[HranaStream]\n    cursor_factory: Type[\"CursorHrana\"]\n\n    def __init__(\n        self,\n        database: str,\n        timeout: float = 5.0,\n        detect_types: int = 0,\n        isolation_level: Optional[IsolationLevel] = \"\",\n        check_same_thread: bool = True,\n        cached_statements: int = 128,\n        uri: bool = False,\n        autocommit: Autocommit = LEGACY_TRANSACTION_CONTROL,\n    ) -> None:\n        assert uri\n        super().__init__(\n            database=database,\n            timeout=timeout,\n            detect_types=detect_types,\n            isolation_level=isolation_level,\n            check_same_thread=check_same_thread,\n            cached_statements=cached_statements,\n            autocommit=autocommit,\n        )\n\n    def _raw_init(self) -> None:\n        self.cursor_factory = CursorHrana\n        try:\n            self._executor = self._acquire_executor()\n            self._session = self._acquire_session()\n            self._conn = self._acquire_connection(self._database)\n            self._stream = self._create_stream()\n        except Exception:\n            self._raw_close()\n            raise\n\n    def _acquire_executor(self) -> AsyncExecutor:\n        return AsyncExecutor()  # TODO: share\n\n    def _dispose_executor(self, executor: AsyncExecutor) -> None:\n        executor.shutdown()  # TODO: share\n\n    @run_in_executor\n    def _acquire_session(self) -> aiohttp.ClientSession:\n        return aiohttp.ClientSession()  # TODO: share\n\n    @run_in_executor\n    async def _dispose_session(self, session: aiohttp.ClientSession) -> None:\n        await session.close()  # TODO: share\n\n    @run_in_executor\n    async def _acquire_connection(self, url: str) -> HranaConn:\n        assert self._session is not None\n        # TODO: share (per url)\n        conn = _create_hrana_connection(self._session, url)\n        try:\n            await conn.wait_connected()\n            return conn\n        except Exception as error:\n            await conn.close()\n            exc = _conv_stmt_result(None, error).errors[0]\n            assert exc is not None  # make mypy happy\n            raise exc\n\n    @run_in_executor\n    async def _dispose_connection(self, conn: HranaConn) -> None:\n        await conn.close()  # TODO: share (per url)\n\n    @run_in_executor\n    def _create_stream(self) -> HranaStream:\n        assert self._conn is not None\n        stream = self._conn.open_stream()\n        self._inf(\"created stream: %s\", stream)\n        return stream\n\n    @run_in_executor\n    def _destroy_stream(self, stream: HranaStream) -> None:\n        self._inf(\"closing stream: %s\", stream)\n        stream.close()\n\n    @run_in_executor\n    def _raw_execute(self, stmt: Stmt) -> asyncio.Future[StmtResult]:\n        assert self._stream is not None\n        return self._stream.execute(stmt)\n\n    @run_in_executor\n    def _raw_store_sql(self, sql: str) -> int:\n        assert self._conn is not None\n        return self._conn.store_sql(sql)\n\n    @run_in_executor\n    def _raw_close_sql(self, sql_id: int) -> None:\n        assert self._conn is not None\n        return self._conn.close_sql(sql_id)\n\n    @run_in_executor\n    def _raw_execute_script(self, sql_script: str) -> asyncio.Future[None]:\n        assert self._stream is not None\n        return self._stream.sequence(sql_script)\n\n    @run_in_executor\n    def _raw_batch(self, batch: Batch) -> asyncio.Future[BatchResult]:\n        assert self._stream is not None\n        return self._stream.batch(batch)\n\n    def _raw_close(self) -> None:\n        # use of getattr as the object may fail init\n        stream = getattr(self, \"_stream\", None)\n        if stream is not None:\n            self._destroy_stream(stream)\n            self._stream = None\n\n        conn = getattr(self, \"_conn\", None)\n        if conn is not None:\n            self._dispose_connection(conn)\n            self._conn = None\n\n        session = getattr(self, \"_session\", None)\n        if session is not None:\n            self._dispose_session(session)\n            self._session = None\n\n        executor = getattr(self, \"_executor\", None)\n        if executor is not None:\n            self._dispose_executor(executor)\n            self._executor = None", "\n\nclass CursorHrana(Cursor):\n    \"\"\"Implement :py:class:`sqlite3.Cursor` for remote servers\n    using the `Hrana Protocol\n    <https://github.com/libsql/sqld/blob/main/docs/HRANA_2_SPEC.md>`_.\n    \"\"\"\n\n    connection: ConnectionHrana\n\n    def _raw_execute_one(self, stmt: Stmt) -> RawExecuteResult:\n        try:\n            if self.connection._trace_callback is not None:\n                self.connection._trace(stmt[\"sql\"])\n            result = self.connection._raw_execute(stmt)\n            return _conv_stmt_result(result, None)\n        except Exception as error:\n            return _conv_stmt_result(None, error)\n\n    def _raw_execute_multiple(self, stmts: List[Stmt]) -> RawExecuteResult:\n        sql_id = None\n        try:\n            sql = stmts[0][\"sql\"]\n            sql_id = self.connection._raw_store_sql(sql)\n            assert sql_id is not None  # keep mypy happy\n\n            stored_stmts: List[Stmt] = [\n                _conv_stmt_plain_to_stored(stmt, sql_id) for stmt in stmts\n            ]\n\n            result = self.connection._raw_batch(_conv_batch(stored_stmts))\n            if self.connection._trace_callback is not None:\n                for stmt in stmts:\n                    self.connection._trace(sql)\n            return _conv_batch_result(result)\n        except Exception as error:\n            return _conv_stmt_result(None, error)\n        finally:\n            if sql_id is not None:\n                try:\n                    self.connection._raw_close_sql(sql_id)\n                except Exception:\n                    pass\n\n    def _raw_execute(\n        self,\n        sql: str,\n        parameters: Iterable[SqlParameters],\n        *,\n        want_rows: bool = True,\n    ) -> RawExecuteResult:\n        stmts = _conv_stmts(sql, parameters, want_rows)\n        if len(stmts) == 1:\n            return self._raw_execute_one(stmts[0])\n        elif len(stmts) > 1:\n            return self._raw_execute_multiple(stmts)\n        else:\n            return RawExecuteResult([], [])\n\n    def _raw_execute_script(self, sql_script: str) -> None:\n        self.connection._raw_execute_script(sql_script)\n\n    def _raw_close(self) -> None:\n        pass  # TODO: should we do anything specific?", ""]}
{"filename": "libsql_client/dbapi2/_reexports.py", "chunked_list": ["from sqlite3.dbapi2 import adapt\nfrom sqlite3.dbapi2 import adapters\nfrom sqlite3.dbapi2 import apilevel\nfrom sqlite3.dbapi2 import Binary\nfrom sqlite3.dbapi2 import complete_statement\nfrom sqlite3.dbapi2 import converters\nfrom sqlite3.dbapi2 import DatabaseError\nfrom sqlite3.dbapi2 import DataError\nfrom sqlite3.dbapi2 import Date\nfrom sqlite3.dbapi2 import DateFromTicks", "from sqlite3.dbapi2 import Date\nfrom sqlite3.dbapi2 import DateFromTicks\nfrom sqlite3.dbapi2 import Error\nfrom sqlite3.dbapi2 import IntegrityError\nfrom sqlite3.dbapi2 import InterfaceError\nfrom sqlite3.dbapi2 import InternalError\nfrom sqlite3.dbapi2 import NotSupportedError\nfrom sqlite3.dbapi2 import OperationalError\nfrom sqlite3.dbapi2 import paramstyle\nfrom sqlite3.dbapi2 import PARSE_COLNAMES", "from sqlite3.dbapi2 import paramstyle\nfrom sqlite3.dbapi2 import PARSE_COLNAMES\nfrom sqlite3.dbapi2 import PARSE_DECLTYPES\nfrom sqlite3.dbapi2 import PrepareProtocol\nfrom sqlite3.dbapi2 import ProgrammingError\nfrom sqlite3.dbapi2 import register_adapter\nfrom sqlite3.dbapi2 import register_converter\nfrom sqlite3.dbapi2 import SQLITE_ALTER_TABLE\nfrom sqlite3.dbapi2 import SQLITE_ANALYZE\nfrom sqlite3.dbapi2 import SQLITE_ATTACH", "from sqlite3.dbapi2 import SQLITE_ANALYZE\nfrom sqlite3.dbapi2 import SQLITE_ATTACH\nfrom sqlite3.dbapi2 import SQLITE_CREATE_INDEX\nfrom sqlite3.dbapi2 import SQLITE_CREATE_TABLE\nfrom sqlite3.dbapi2 import SQLITE_CREATE_TEMP_INDEX\nfrom sqlite3.dbapi2 import SQLITE_CREATE_TEMP_TABLE\nfrom sqlite3.dbapi2 import SQLITE_CREATE_TEMP_TRIGGER\nfrom sqlite3.dbapi2 import SQLITE_CREATE_TEMP_VIEW\nfrom sqlite3.dbapi2 import SQLITE_CREATE_TRIGGER\nfrom sqlite3.dbapi2 import SQLITE_CREATE_VIEW", "from sqlite3.dbapi2 import SQLITE_CREATE_TRIGGER\nfrom sqlite3.dbapi2 import SQLITE_CREATE_VIEW\nfrom sqlite3.dbapi2 import SQLITE_CREATE_VTABLE\nfrom sqlite3.dbapi2 import SQLITE_DELETE\nfrom sqlite3.dbapi2 import SQLITE_DENY\nfrom sqlite3.dbapi2 import SQLITE_DETACH\nfrom sqlite3.dbapi2 import SQLITE_DONE\nfrom sqlite3.dbapi2 import SQLITE_DROP_INDEX\nfrom sqlite3.dbapi2 import SQLITE_DROP_TABLE\nfrom sqlite3.dbapi2 import SQLITE_DROP_TEMP_INDEX", "from sqlite3.dbapi2 import SQLITE_DROP_TABLE\nfrom sqlite3.dbapi2 import SQLITE_DROP_TEMP_INDEX\nfrom sqlite3.dbapi2 import SQLITE_DROP_TEMP_TABLE\nfrom sqlite3.dbapi2 import SQLITE_DROP_TEMP_TRIGGER\nfrom sqlite3.dbapi2 import SQLITE_DROP_TEMP_VIEW\nfrom sqlite3.dbapi2 import SQLITE_DROP_TRIGGER\nfrom sqlite3.dbapi2 import SQLITE_DROP_VIEW\nfrom sqlite3.dbapi2 import SQLITE_DROP_VTABLE\nfrom sqlite3.dbapi2 import SQLITE_FUNCTION\nfrom sqlite3.dbapi2 import SQLITE_IGNORE", "from sqlite3.dbapi2 import SQLITE_FUNCTION\nfrom sqlite3.dbapi2 import SQLITE_IGNORE\nfrom sqlite3.dbapi2 import SQLITE_INSERT\nfrom sqlite3.dbapi2 import SQLITE_OK\nfrom sqlite3.dbapi2 import SQLITE_PRAGMA\nfrom sqlite3.dbapi2 import SQLITE_READ\nfrom sqlite3.dbapi2 import SQLITE_RECURSIVE\nfrom sqlite3.dbapi2 import SQLITE_REINDEX\nfrom sqlite3.dbapi2 import SQLITE_SAVEPOINT\nfrom sqlite3.dbapi2 import SQLITE_SELECT", "from sqlite3.dbapi2 import SQLITE_SAVEPOINT\nfrom sqlite3.dbapi2 import SQLITE_SELECT\nfrom sqlite3.dbapi2 import SQLITE_TRANSACTION\nfrom sqlite3.dbapi2 import SQLITE_UPDATE\nfrom sqlite3.dbapi2 import sqlite_version\nfrom sqlite3.dbapi2 import sqlite_version_info\nfrom sqlite3.dbapi2 import threadsafety\nfrom sqlite3.dbapi2 import Time\nfrom sqlite3.dbapi2 import TimeFromTicks\nfrom sqlite3.dbapi2 import Timestamp", "from sqlite3.dbapi2 import TimeFromTicks\nfrom sqlite3.dbapi2 import Timestamp\nfrom sqlite3.dbapi2 import TimestampFromTicks\nfrom sqlite3.dbapi2 import version\nfrom sqlite3.dbapi2 import Warning\nimport sys\n\nif sys.version_info[:2] >= (3, 11):\n    from sqlite3.dbapi2 import Blob\n    from sqlite3.dbapi2 import SQLITE_ABORT\n    from sqlite3.dbapi2 import SQLITE_ABORT_ROLLBACK\n    from sqlite3.dbapi2 import SQLITE_AUTH_USER\n    from sqlite3.dbapi2 import SQLITE_AUTH\n    from sqlite3.dbapi2 import SQLITE_BUSY_RECOVERY\n    from sqlite3.dbapi2 import SQLITE_BUSY_SNAPSHOT\n    from sqlite3.dbapi2 import SQLITE_BUSY_TIMEOUT\n    from sqlite3.dbapi2 import SQLITE_BUSY\n    from sqlite3.dbapi2 import SQLITE_CANTOPEN_CONVPATH\n    from sqlite3.dbapi2 import SQLITE_CANTOPEN_DIRTYWAL\n    from sqlite3.dbapi2 import SQLITE_CANTOPEN_FULLPATH\n    from sqlite3.dbapi2 import SQLITE_CANTOPEN_ISDIR\n    from sqlite3.dbapi2 import SQLITE_CANTOPEN_NOTEMPDIR\n    from sqlite3.dbapi2 import SQLITE_CANTOPEN_SYMLINK\n    from sqlite3.dbapi2 import SQLITE_CANTOPEN\n    from sqlite3.dbapi2 import SQLITE_CONSTRAINT_CHECK\n    from sqlite3.dbapi2 import SQLITE_CONSTRAINT_COMMITHOOK\n    from sqlite3.dbapi2 import SQLITE_CONSTRAINT_FOREIGNKEY\n    from sqlite3.dbapi2 import SQLITE_CONSTRAINT_FUNCTION\n    from sqlite3.dbapi2 import SQLITE_CONSTRAINT_NOTNULL\n    from sqlite3.dbapi2 import SQLITE_CONSTRAINT_PINNED\n    from sqlite3.dbapi2 import SQLITE_CONSTRAINT_PRIMARYKEY\n    from sqlite3.dbapi2 import SQLITE_CONSTRAINT_ROWID\n    from sqlite3.dbapi2 import SQLITE_CONSTRAINT_TRIGGER\n    from sqlite3.dbapi2 import SQLITE_CONSTRAINT_UNIQUE\n    from sqlite3.dbapi2 import SQLITE_CONSTRAINT_VTAB\n    from sqlite3.dbapi2 import SQLITE_CONSTRAINT\n    from sqlite3.dbapi2 import SQLITE_CORRUPT_INDEX\n    from sqlite3.dbapi2 import SQLITE_CORRUPT_SEQUENCE\n    from sqlite3.dbapi2 import SQLITE_CORRUPT_VTAB\n    from sqlite3.dbapi2 import SQLITE_CORRUPT\n    from sqlite3.dbapi2 import SQLITE_EMPTY\n    from sqlite3.dbapi2 import SQLITE_ERROR_MISSING_COLLSEQ\n    from sqlite3.dbapi2 import SQLITE_ERROR_RETRY\n    from sqlite3.dbapi2 import SQLITE_ERROR_SNAPSHOT\n    from sqlite3.dbapi2 import SQLITE_ERROR\n    from sqlite3.dbapi2 import SQLITE_FORMAT\n    from sqlite3.dbapi2 import SQLITE_FULL\n    from sqlite3.dbapi2 import SQLITE_INTERNAL\n    from sqlite3.dbapi2 import SQLITE_INTERRUPT\n    from sqlite3.dbapi2 import SQLITE_IOERR_ACCESS\n    from sqlite3.dbapi2 import SQLITE_IOERR_AUTH\n    from sqlite3.dbapi2 import SQLITE_IOERR_BEGIN_ATOMIC\n    from sqlite3.dbapi2 import SQLITE_IOERR_BLOCKED\n    from sqlite3.dbapi2 import SQLITE_IOERR_CHECKRESERVEDLOCK\n    from sqlite3.dbapi2 import SQLITE_IOERR_CLOSE\n    from sqlite3.dbapi2 import SQLITE_IOERR_COMMIT_ATOMIC\n    from sqlite3.dbapi2 import SQLITE_IOERR_CONVPATH\n    from sqlite3.dbapi2 import SQLITE_IOERR_CORRUPTFS\n    from sqlite3.dbapi2 import SQLITE_IOERR_DATA\n    from sqlite3.dbapi2 import SQLITE_IOERR_DELETE_NOENT\n    from sqlite3.dbapi2 import SQLITE_IOERR_DELETE\n    from sqlite3.dbapi2 import SQLITE_IOERR_DIR_CLOSE\n    from sqlite3.dbapi2 import SQLITE_IOERR_DIR_FSYNC\n    from sqlite3.dbapi2 import SQLITE_IOERR_FSTAT\n    from sqlite3.dbapi2 import SQLITE_IOERR_FSYNC\n    from sqlite3.dbapi2 import SQLITE_IOERR_GETTEMPPATH\n    from sqlite3.dbapi2 import SQLITE_IOERR_LOCK\n    from sqlite3.dbapi2 import SQLITE_IOERR_MMAP\n    from sqlite3.dbapi2 import SQLITE_IOERR_NOMEM\n    from sqlite3.dbapi2 import SQLITE_IOERR_RDLOCK\n    from sqlite3.dbapi2 import SQLITE_IOERR_READ\n    from sqlite3.dbapi2 import SQLITE_IOERR_ROLLBACK_ATOMIC\n    from sqlite3.dbapi2 import SQLITE_IOERR_SEEK\n    from sqlite3.dbapi2 import SQLITE_IOERR_SHMLOCK\n    from sqlite3.dbapi2 import SQLITE_IOERR_SHMMAP\n    from sqlite3.dbapi2 import SQLITE_IOERR_SHMOPEN\n    from sqlite3.dbapi2 import SQLITE_IOERR_SHMSIZE\n    from sqlite3.dbapi2 import SQLITE_IOERR_SHORT_READ\n    from sqlite3.dbapi2 import SQLITE_IOERR_TRUNCATE\n    from sqlite3.dbapi2 import SQLITE_IOERR_UNLOCK\n    from sqlite3.dbapi2 import SQLITE_IOERR_VNODE\n    from sqlite3.dbapi2 import SQLITE_IOERR_WRITE\n    from sqlite3.dbapi2 import SQLITE_IOERR\n    from sqlite3.dbapi2 import SQLITE_LIMIT_ATTACHED\n    from sqlite3.dbapi2 import SQLITE_LIMIT_COLUMN\n    from sqlite3.dbapi2 import SQLITE_LIMIT_COMPOUND_SELECT\n    from sqlite3.dbapi2 import SQLITE_LIMIT_EXPR_DEPTH\n    from sqlite3.dbapi2 import SQLITE_LIMIT_FUNCTION_ARG\n    from sqlite3.dbapi2 import SQLITE_LIMIT_LENGTH\n    from sqlite3.dbapi2 import SQLITE_LIMIT_LIKE_PATTERN_LENGTH\n    from sqlite3.dbapi2 import SQLITE_LIMIT_SQL_LENGTH\n    from sqlite3.dbapi2 import SQLITE_LIMIT_TRIGGER_DEPTH\n    from sqlite3.dbapi2 import SQLITE_LIMIT_VARIABLE_NUMBER\n    from sqlite3.dbapi2 import SQLITE_LIMIT_VDBE_OP\n    from sqlite3.dbapi2 import SQLITE_LIMIT_WORKER_THREADS\n    from sqlite3.dbapi2 import SQLITE_LOCKED_SHAREDCACHE\n    from sqlite3.dbapi2 import SQLITE_LOCKED_VTAB\n    from sqlite3.dbapi2 import SQLITE_LOCKED\n    from sqlite3.dbapi2 import SQLITE_MISMATCH\n    from sqlite3.dbapi2 import SQLITE_MISUSE\n    from sqlite3.dbapi2 import SQLITE_NOLFS\n    from sqlite3.dbapi2 import SQLITE_NOMEM\n    from sqlite3.dbapi2 import SQLITE_NOTADB\n    from sqlite3.dbapi2 import SQLITE_NOTFOUND\n    from sqlite3.dbapi2 import SQLITE_NOTICE_RECOVER_ROLLBACK\n    from sqlite3.dbapi2 import SQLITE_NOTICE_RECOVER_WAL\n    from sqlite3.dbapi2 import SQLITE_NOTICE\n    from sqlite3.dbapi2 import SQLITE_OK_LOAD_PERMANENTLY\n    from sqlite3.dbapi2 import SQLITE_OK_SYMLINK\n    from sqlite3.dbapi2 import SQLITE_PERM\n    from sqlite3.dbapi2 import SQLITE_PROTOCOL\n    from sqlite3.dbapi2 import SQLITE_RANGE\n    from sqlite3.dbapi2 import SQLITE_READONLY_CANTINIT\n    from sqlite3.dbapi2 import SQLITE_READONLY_CANTLOCK\n    from sqlite3.dbapi2 import SQLITE_READONLY_DBMOVED\n    from sqlite3.dbapi2 import SQLITE_READONLY_DIRECTORY\n    from sqlite3.dbapi2 import SQLITE_READONLY_RECOVERY\n    from sqlite3.dbapi2 import SQLITE_READONLY_ROLLBACK\n    from sqlite3.dbapi2 import SQLITE_READONLY\n    from sqlite3.dbapi2 import SQLITE_ROW\n    from sqlite3.dbapi2 import SQLITE_SCHEMA\n    from sqlite3.dbapi2 import SQLITE_TOOBIG\n    from sqlite3.dbapi2 import SQLITE_WARNING_AUTOINDEX\n    from sqlite3.dbapi2 import SQLITE_WARNING\nelse:\n\n    class Blob:\n        pass\n\n    # Most constants were only defined in 3.11\n    #\n    # you can generate them by using getattr(sqlite3.dbapi2, name)\n    # in a newer python version\n    SQLITE_ABORT = 4\n    SQLITE_ABORT_ROLLBACK = 516\n    SQLITE_AUTH_USER = 279\n    SQLITE_AUTH = 23\n    SQLITE_BUSY_RECOVERY = 261\n    SQLITE_BUSY_SNAPSHOT = 517\n    SQLITE_BUSY_TIMEOUT = 773\n    SQLITE_BUSY = 5\n    SQLITE_CANTOPEN_CONVPATH = 1038\n    SQLITE_CANTOPEN_DIRTYWAL = 1294\n    SQLITE_CANTOPEN_FULLPATH = 782\n    SQLITE_CANTOPEN_ISDIR = 526\n    SQLITE_CANTOPEN_NOTEMPDIR = 270\n    SQLITE_CANTOPEN_SYMLINK = 1550\n    SQLITE_CANTOPEN = 14\n    SQLITE_CONSTRAINT_CHECK = 275\n    SQLITE_CONSTRAINT_COMMITHOOK = 531\n    SQLITE_CONSTRAINT_FOREIGNKEY = 787\n    SQLITE_CONSTRAINT_FUNCTION = 1043\n    SQLITE_CONSTRAINT_NOTNULL = 1299\n    SQLITE_CONSTRAINT_PINNED = 2835\n    SQLITE_CONSTRAINT_PRIMARYKEY = 1555\n    SQLITE_CONSTRAINT_ROWID = 2579\n    SQLITE_CONSTRAINT_TRIGGER = 1811\n    SQLITE_CONSTRAINT_UNIQUE = 2067\n    SQLITE_CONSTRAINT_VTAB = 2323\n    SQLITE_CONSTRAINT = 19\n    SQLITE_CORRUPT_INDEX = 779\n    SQLITE_CORRUPT_SEQUENCE = 523\n    SQLITE_CORRUPT_VTAB = 267\n    SQLITE_CORRUPT = 11\n    SQLITE_EMPTY = 16\n    SQLITE_ERROR_MISSING_COLLSEQ = 257\n    SQLITE_ERROR_RETRY = 513\n    SQLITE_ERROR_SNAPSHOT = 769\n    SQLITE_ERROR = 1\n    SQLITE_FORMAT = 24\n    SQLITE_FULL = 13\n    SQLITE_INTERNAL = 2\n    SQLITE_INTERRUPT = 9\n    SQLITE_IOERR_ACCESS = 3338\n    SQLITE_IOERR_AUTH = 7178\n    SQLITE_IOERR_BEGIN_ATOMIC = 7434\n    SQLITE_IOERR_BLOCKED = 2826\n    SQLITE_IOERR_CHECKRESERVEDLOCK = 3594\n    SQLITE_IOERR_CLOSE = 4106\n    SQLITE_IOERR_COMMIT_ATOMIC = 7690\n    SQLITE_IOERR_CONVPATH = 6666\n    SQLITE_IOERR_CORRUPTFS = 8458\n    SQLITE_IOERR_DATA = 8202\n    SQLITE_IOERR_DELETE_NOENT = 5898\n    SQLITE_IOERR_DELETE = 2570\n    SQLITE_IOERR_DIR_CLOSE = 4362\n    SQLITE_IOERR_DIR_FSYNC = 1290\n    SQLITE_IOERR_FSTAT = 1802\n    SQLITE_IOERR_FSYNC = 1034\n    SQLITE_IOERR_GETTEMPPATH = 6410\n    SQLITE_IOERR_LOCK = 3850\n    SQLITE_IOERR_MMAP = 6154\n    SQLITE_IOERR_NOMEM = 3082\n    SQLITE_IOERR_RDLOCK = 2314\n    SQLITE_IOERR_READ = 266\n    SQLITE_IOERR_ROLLBACK_ATOMIC = 7946\n    SQLITE_IOERR_SEEK = 5642\n    SQLITE_IOERR_SHMLOCK = 5130\n    SQLITE_IOERR_SHMMAP = 5386\n    SQLITE_IOERR_SHMOPEN = 4618\n    SQLITE_IOERR_SHMSIZE = 4874\n    SQLITE_IOERR_SHORT_READ = 522\n    SQLITE_IOERR_TRUNCATE = 1546\n    SQLITE_IOERR_UNLOCK = 2058\n    SQLITE_IOERR_VNODE = 6922\n    SQLITE_IOERR_WRITE = 778\n    SQLITE_IOERR = 10\n    SQLITE_LIMIT_ATTACHED = 7\n    SQLITE_LIMIT_COLUMN = 2\n    SQLITE_LIMIT_COMPOUND_SELECT = 4\n    SQLITE_LIMIT_EXPR_DEPTH = 3\n    SQLITE_LIMIT_FUNCTION_ARG = 6\n    SQLITE_LIMIT_LENGTH = 0\n    SQLITE_LIMIT_LIKE_PATTERN_LENGTH = 8\n    SQLITE_LIMIT_SQL_LENGTH = 1\n    SQLITE_LIMIT_TRIGGER_DEPTH = 10\n    SQLITE_LIMIT_VARIABLE_NUMBER = 9\n    SQLITE_LIMIT_VDBE_OP = 5\n    SQLITE_LIMIT_WORKER_THREADS = 11\n    SQLITE_LOCKED_SHAREDCACHE = 262\n    SQLITE_LOCKED_VTAB = 518\n    SQLITE_LOCKED = 6\n    SQLITE_MISMATCH = 20\n    SQLITE_MISUSE = 21\n    SQLITE_NOLFS = 22\n    SQLITE_NOMEM = 7\n    SQLITE_NOTADB = 26\n    SQLITE_NOTFOUND = 12\n    SQLITE_NOTICE_RECOVER_ROLLBACK = 539\n    SQLITE_NOTICE_RECOVER_WAL = 283\n    SQLITE_NOTICE = 27\n    SQLITE_OK_LOAD_PERMANENTLY = 256\n    SQLITE_OK_SYMLINK = 512\n    SQLITE_PERM = 3\n    SQLITE_PROTOCOL = 15\n    SQLITE_RANGE = 25\n    SQLITE_READONLY_CANTINIT = 1288\n    SQLITE_READONLY_CANTLOCK = 520\n    SQLITE_READONLY_DBMOVED = 1032\n    SQLITE_READONLY_DIRECTORY = 1544\n    SQLITE_READONLY_RECOVERY = 264\n    SQLITE_READONLY_ROLLBACK = 776\n    SQLITE_READONLY = 8\n    SQLITE_ROW = 100\n    SQLITE_SCHEMA = 17\n    SQLITE_TOOBIG = 18\n    SQLITE_WARNING_AUTOINDEX = 284\n    SQLITE_WARNING = 28", "\n\n__all__ = (\n    \"adapt\",\n    \"adapters\",\n    \"apilevel\",\n    \"Binary\",\n    \"Blob\",\n    \"complete_statement\",\n    \"converters\",", "    \"complete_statement\",\n    \"converters\",\n    \"DatabaseError\",\n    \"DataError\",\n    \"Date\",\n    \"DateFromTicks\",\n    \"Error\",\n    \"IntegrityError\",\n    \"InterfaceError\",\n    \"InternalError\",", "    \"InterfaceError\",\n    \"InternalError\",\n    \"NotSupportedError\",\n    \"OperationalError\",\n    \"paramstyle\",\n    \"PARSE_COLNAMES\",\n    \"PARSE_DECLTYPES\",\n    \"PrepareProtocol\",\n    \"ProgrammingError\",\n    \"register_adapter\",", "    \"ProgrammingError\",\n    \"register_adapter\",\n    \"register_converter\",\n    \"SQLITE_ABORT_ROLLBACK\",\n    \"SQLITE_ABORT\",\n    \"SQLITE_ALTER_TABLE\",\n    \"SQLITE_ANALYZE\",\n    \"SQLITE_ATTACH\",\n    \"SQLITE_AUTH_USER\",\n    \"SQLITE_AUTH\",", "    \"SQLITE_AUTH_USER\",\n    \"SQLITE_AUTH\",\n    \"SQLITE_BUSY_RECOVERY\",\n    \"SQLITE_BUSY_SNAPSHOT\",\n    \"SQLITE_BUSY_TIMEOUT\",\n    \"SQLITE_BUSY\",\n    \"SQLITE_CANTOPEN_CONVPATH\",\n    \"SQLITE_CANTOPEN_DIRTYWAL\",\n    \"SQLITE_CANTOPEN_FULLPATH\",\n    \"SQLITE_CANTOPEN_ISDIR\",", "    \"SQLITE_CANTOPEN_FULLPATH\",\n    \"SQLITE_CANTOPEN_ISDIR\",\n    \"SQLITE_CANTOPEN_NOTEMPDIR\",\n    \"SQLITE_CANTOPEN_SYMLINK\",\n    \"SQLITE_CANTOPEN\",\n    \"SQLITE_CONSTRAINT_CHECK\",\n    \"SQLITE_CONSTRAINT_COMMITHOOK\",\n    \"SQLITE_CONSTRAINT_FOREIGNKEY\",\n    \"SQLITE_CONSTRAINT_FUNCTION\",\n    \"SQLITE_CONSTRAINT_NOTNULL\",", "    \"SQLITE_CONSTRAINT_FUNCTION\",\n    \"SQLITE_CONSTRAINT_NOTNULL\",\n    \"SQLITE_CONSTRAINT_PINNED\",\n    \"SQLITE_CONSTRAINT_PRIMARYKEY\",\n    \"SQLITE_CONSTRAINT_ROWID\",\n    \"SQLITE_CONSTRAINT_TRIGGER\",\n    \"SQLITE_CONSTRAINT_UNIQUE\",\n    \"SQLITE_CONSTRAINT_VTAB\",\n    \"SQLITE_CONSTRAINT\",\n    \"SQLITE_CORRUPT_INDEX\",", "    \"SQLITE_CONSTRAINT\",\n    \"SQLITE_CORRUPT_INDEX\",\n    \"SQLITE_CORRUPT_SEQUENCE\",\n    \"SQLITE_CORRUPT_VTAB\",\n    \"SQLITE_CORRUPT\",\n    \"SQLITE_CREATE_INDEX\",\n    \"SQLITE_CREATE_TABLE\",\n    \"SQLITE_CREATE_TEMP_INDEX\",\n    \"SQLITE_CREATE_TEMP_TABLE\",\n    \"SQLITE_CREATE_TEMP_TRIGGER\",", "    \"SQLITE_CREATE_TEMP_TABLE\",\n    \"SQLITE_CREATE_TEMP_TRIGGER\",\n    \"SQLITE_CREATE_TEMP_VIEW\",\n    \"SQLITE_CREATE_TRIGGER\",\n    \"SQLITE_CREATE_VIEW\",\n    \"SQLITE_CREATE_VTABLE\",\n    \"SQLITE_DELETE\",\n    \"SQLITE_DENY\",\n    \"SQLITE_DETACH\",\n    \"SQLITE_DONE\",", "    \"SQLITE_DETACH\",\n    \"SQLITE_DONE\",\n    \"SQLITE_DROP_INDEX\",\n    \"SQLITE_DROP_TABLE\",\n    \"SQLITE_DROP_TEMP_INDEX\",\n    \"SQLITE_DROP_TEMP_TABLE\",\n    \"SQLITE_DROP_TEMP_TRIGGER\",\n    \"SQLITE_DROP_TEMP_VIEW\",\n    \"SQLITE_DROP_TRIGGER\",\n    \"SQLITE_DROP_VIEW\",", "    \"SQLITE_DROP_TRIGGER\",\n    \"SQLITE_DROP_VIEW\",\n    \"SQLITE_DROP_VTABLE\",\n    \"SQLITE_EMPTY\",\n    \"SQLITE_ERROR_MISSING_COLLSEQ\",\n    \"SQLITE_ERROR_RETRY\",\n    \"SQLITE_ERROR_SNAPSHOT\",\n    \"SQLITE_ERROR\",\n    \"SQLITE_FORMAT\",\n    \"SQLITE_FULL\",", "    \"SQLITE_FORMAT\",\n    \"SQLITE_FULL\",\n    \"SQLITE_FUNCTION\",\n    \"SQLITE_IGNORE\",\n    \"SQLITE_INSERT\",\n    \"SQLITE_INTERNAL\",\n    \"SQLITE_INTERRUPT\",\n    \"SQLITE_IOERR_ACCESS\",\n    \"SQLITE_IOERR_AUTH\",\n    \"SQLITE_IOERR_BEGIN_ATOMIC\",", "    \"SQLITE_IOERR_AUTH\",\n    \"SQLITE_IOERR_BEGIN_ATOMIC\",\n    \"SQLITE_IOERR_BLOCKED\",\n    \"SQLITE_IOERR_CHECKRESERVEDLOCK\",\n    \"SQLITE_IOERR_CLOSE\",\n    \"SQLITE_IOERR_COMMIT_ATOMIC\",\n    \"SQLITE_IOERR_CONVPATH\",\n    \"SQLITE_IOERR_CORRUPTFS\",\n    \"SQLITE_IOERR_DATA\",\n    \"SQLITE_IOERR_DELETE_NOENT\",", "    \"SQLITE_IOERR_DATA\",\n    \"SQLITE_IOERR_DELETE_NOENT\",\n    \"SQLITE_IOERR_DELETE\",\n    \"SQLITE_IOERR_DIR_CLOSE\",\n    \"SQLITE_IOERR_DIR_FSYNC\",\n    \"SQLITE_IOERR_FSTAT\",\n    \"SQLITE_IOERR_FSYNC\",\n    \"SQLITE_IOERR_GETTEMPPATH\",\n    \"SQLITE_IOERR_LOCK\",\n    \"SQLITE_IOERR_MMAP\",", "    \"SQLITE_IOERR_LOCK\",\n    \"SQLITE_IOERR_MMAP\",\n    \"SQLITE_IOERR_NOMEM\",\n    \"SQLITE_IOERR_RDLOCK\",\n    \"SQLITE_IOERR_READ\",\n    \"SQLITE_IOERR_ROLLBACK_ATOMIC\",\n    \"SQLITE_IOERR_SEEK\",\n    \"SQLITE_IOERR_SHMLOCK\",\n    \"SQLITE_IOERR_SHMMAP\",\n    \"SQLITE_IOERR_SHMOPEN\",", "    \"SQLITE_IOERR_SHMMAP\",\n    \"SQLITE_IOERR_SHMOPEN\",\n    \"SQLITE_IOERR_SHMSIZE\",\n    \"SQLITE_IOERR_SHORT_READ\",\n    \"SQLITE_IOERR_TRUNCATE\",\n    \"SQLITE_IOERR_UNLOCK\",\n    \"SQLITE_IOERR_VNODE\",\n    \"SQLITE_IOERR_WRITE\",\n    \"SQLITE_IOERR\",\n    \"SQLITE_LIMIT_ATTACHED\",", "    \"SQLITE_IOERR\",\n    \"SQLITE_LIMIT_ATTACHED\",\n    \"SQLITE_LIMIT_COLUMN\",\n    \"SQLITE_LIMIT_COMPOUND_SELECT\",\n    \"SQLITE_LIMIT_EXPR_DEPTH\",\n    \"SQLITE_LIMIT_FUNCTION_ARG\",\n    \"SQLITE_LIMIT_LENGTH\",\n    \"SQLITE_LIMIT_LIKE_PATTERN_LENGTH\",\n    \"SQLITE_LIMIT_SQL_LENGTH\",\n    \"SQLITE_LIMIT_TRIGGER_DEPTH\",", "    \"SQLITE_LIMIT_SQL_LENGTH\",\n    \"SQLITE_LIMIT_TRIGGER_DEPTH\",\n    \"SQLITE_LIMIT_VARIABLE_NUMBER\",\n    \"SQLITE_LIMIT_VDBE_OP\",\n    \"SQLITE_LIMIT_WORKER_THREADS\",\n    \"SQLITE_LOCKED_SHAREDCACHE\",\n    \"SQLITE_LOCKED_VTAB\",\n    \"SQLITE_LOCKED\",\n    \"SQLITE_MISMATCH\",\n    \"SQLITE_MISUSE\",", "    \"SQLITE_MISMATCH\",\n    \"SQLITE_MISUSE\",\n    \"SQLITE_NOLFS\",\n    \"SQLITE_NOMEM\",\n    \"SQLITE_NOTADB\",\n    \"SQLITE_NOTFOUND\",\n    \"SQLITE_NOTICE_RECOVER_ROLLBACK\",\n    \"SQLITE_NOTICE_RECOVER_WAL\",\n    \"SQLITE_NOTICE\",\n    \"SQLITE_OK_LOAD_PERMANENTLY\",", "    \"SQLITE_NOTICE\",\n    \"SQLITE_OK_LOAD_PERMANENTLY\",\n    \"SQLITE_OK_SYMLINK\",\n    \"SQLITE_OK\",\n    \"SQLITE_PERM\",\n    \"SQLITE_PRAGMA\",\n    \"SQLITE_PROTOCOL\",\n    \"SQLITE_RANGE\",\n    \"SQLITE_READ\",\n    \"SQLITE_READONLY_CANTINIT\",", "    \"SQLITE_READ\",\n    \"SQLITE_READONLY_CANTINIT\",\n    \"SQLITE_READONLY_CANTLOCK\",\n    \"SQLITE_READONLY_DBMOVED\",\n    \"SQLITE_READONLY_DIRECTORY\",\n    \"SQLITE_READONLY_RECOVERY\",\n    \"SQLITE_READONLY_ROLLBACK\",\n    \"SQLITE_READONLY\",\n    \"SQLITE_RECURSIVE\",\n    \"SQLITE_REINDEX\",", "    \"SQLITE_RECURSIVE\",\n    \"SQLITE_REINDEX\",\n    \"SQLITE_ROW\",\n    \"SQLITE_SAVEPOINT\",\n    \"SQLITE_SCHEMA\",\n    \"SQLITE_SELECT\",\n    \"SQLITE_TOOBIG\",\n    \"SQLITE_TRANSACTION\",\n    \"SQLITE_UPDATE\",\n    \"sqlite_version_info\",", "    \"SQLITE_UPDATE\",\n    \"sqlite_version_info\",\n    \"sqlite_version\",\n    \"SQLITE_WARNING_AUTOINDEX\",\n    \"SQLITE_WARNING\",\n    \"threadsafety\",\n    \"Time\",\n    \"TimeFromTicks\",\n    \"Timestamp\",\n    \"TimestampFromTicks\",", "    \"Timestamp\",\n    \"TimestampFromTicks\",\n    \"version\",\n    \"Warning\",\n)\n"]}
{"filename": "libsql_client/dbapi2/_utils.py", "chunked_list": ["from __future__ import annotations\n\nimport logging\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Optional\nfrom typing import Sequence\n\n\ndef log_prefix(\n    logger: logging.Logger,\n    prefix: str,\n    level: int,\n    msg: str,\n    *args: object,\n    exc_info: Optional[BaseException] = None,\n) -> None:\n    logger.log(level, prefix + msg, *args, exc_info=exc_info)", "\ndef log_prefix(\n    logger: logging.Logger,\n    prefix: str,\n    level: int,\n    msg: str,\n    *args: object,\n    exc_info: Optional[BaseException] = None,\n) -> None:\n    logger.log(level, prefix + msg, *args, exc_info=exc_info)", "\n\ndef log_obj(\n    logger: logging.Logger,\n    obj: object,\n    level: int,\n    msg: str,\n    *args: object,\n    exc_info: Optional[BaseException] = None,\n) -> None:\n    prefix = getattr(obj, \"_log_prefix\", None)\n    if prefix is None:\n        prefix = f\"{obj!r}: \"\n    log_prefix(logger, prefix, level, msg, *args, exc_info=exc_info)", "\n\n_lstrip_sql_whitespace_chars = {\" \", \"\\t\", \"\\f\", \"\\n\", \"\\r\"}\n\n\ndef lstrip_sql(sql: str) -> Optional[str]:  # noqa: C901\n    # See statement.c, lstrip_sql() function at:\n    # https://github.com/python/cpython/blob/main/Modules/_sqlite/statement.c#L134\n    # using the same names here, however in C pos is both the index (offset)\n    # and the value (ch = *pos)\n    pos = 0\n    end_pos = len(sql)\n    while pos < end_pos:\n        ch = sql[pos]\n        if ch in _lstrip_sql_whitespace_chars:\n            pos += 1  # C uses for() with trailing ++\n            continue\n\n        if ch == \"-\":\n            # Skip line comments.\n            # NOTE: in C pos[end_pos] == 0, so \"pos[1] == '-'\" is enough,\n            # Here we must compare pos + 1 < end_pos\n            if pos + 1 < end_pos and sql[pos + 1] == \"-\":\n                pos += 2\n                # NOTE: in C pos[end_pos] == 0, so they do \"pos[0]\".\n                # Here we compare pos + 1 < end_pos\n                while pos < end_pos and sql[pos] != \"\\n\":\n                    pos += 1\n                if pos >= end_pos:\n                    return None\n\n                pos += 1  # C uses for() with trailing ++\n                continue\n\n            return sql[pos:]  # not a line comment\n\n        if ch == \"/\":\n            # Skip C style comments.\n            # NOTE: in C pos[end_pos] == 0, so \"pos[1] == '*'\" is enough,\n            # Here we must compare pos + 1 < end_pos\n            if pos + 1 < end_pos and sql[pos + 1] == \"*\":\n                pos += 2\n                # NOTE: in C pos[end_pos] == 0, so they do \"pos[0]\".\n                # Here we compare pos + 1 < end_pos. To avoid a messy\n                # long line, the condition is moved into an explicit \"if\"\n                # that \"break\"s.\n                while pos < end_pos:\n                    if sql[pos] == \"*\":\n                        if pos + 1 < end_pos and sql[pos + 1] == \"/\":\n                            break\n                    pos += 1\n\n                if pos >= end_pos:\n                    return None\n\n                pos += 2  # C uses for() with trailing ++\n                continue\n\n            return sql[pos:]  # not a C style comment\n\n        return sql[pos:]\n\n    return None", "\n\n_iter_sql_delim_chars = {\";\", \",\", \"(\", \")\", \"[\", \"]\"}\n_iter_sql_stop_chars = _lstrip_sql_whitespace_chars.union(\n    _iter_sql_delim_chars,\n)\n_iter_sql_quote_chars = {'\"', \"'\"}\n\n\ndef _iter_sql_get_quoted_end(sql: str, pos: int, end_pos: int) -> int:\n    \"\"\"Find the end of the quoted string starting at ``pos``.\n\n    The returned position includes the position of the quote character,\n    that matches the one at ``pos``.\n\n    >>> def test_quote(ts):\n    ...     end = _iter_sql_get_quoted_end(ts, 0, len(ts))\n    ...     return (end, ts[:end])\n\n    >>> test_quote(\"'abc'\")\n    (5, \"'abc'\")\n    >>> test_quote('\"abc \"')\n    (6, '\"abc \"')\n\n    >>> test_quote(\"'abc' def\")\n    (5, \"'abc'\")\n    >>> test_quote('\"abc \"def')\n    (6, '\"abc \"')\n\n    It also handles escaping by double quotes, see\n    https://www.sqlite.org/faq.html#q14\n\n    >>> test_quote('\"abc\"\"def\" ghi')\n    (10, '\"abc\"\"def\"')\n    >>> test_quote('\"abc \"def\" ghi')\n    (6, '\"abc \"')\n    \"\"\"\n    if pos + 1 >= end_pos:\n        return pos\n\n    ch = sql[pos]\n    while pos + 1 < end_pos:\n        pos += 1\n        if sql[pos] == ch:\n            pos += 1\n            if pos == end_pos or sql[pos] != ch:\n                break\n\n            # escaped by double quoting: https://www.sqlite.org/faq.html#q14\n            pos += 1\n\n    return pos", "\ndef _iter_sql_get_quoted_end(sql: str, pos: int, end_pos: int) -> int:\n    \"\"\"Find the end of the quoted string starting at ``pos``.\n\n    The returned position includes the position of the quote character,\n    that matches the one at ``pos``.\n\n    >>> def test_quote(ts):\n    ...     end = _iter_sql_get_quoted_end(ts, 0, len(ts))\n    ...     return (end, ts[:end])\n\n    >>> test_quote(\"'abc'\")\n    (5, \"'abc'\")\n    >>> test_quote('\"abc \"')\n    (6, '\"abc \"')\n\n    >>> test_quote(\"'abc' def\")\n    (5, \"'abc'\")\n    >>> test_quote('\"abc \"def')\n    (6, '\"abc \"')\n\n    It also handles escaping by double quotes, see\n    https://www.sqlite.org/faq.html#q14\n\n    >>> test_quote('\"abc\"\"def\" ghi')\n    (10, '\"abc\"\"def\"')\n    >>> test_quote('\"abc \"def\" ghi')\n    (6, '\"abc \"')\n    \"\"\"\n    if pos + 1 >= end_pos:\n        return pos\n\n    ch = sql[pos]\n    while pos + 1 < end_pos:\n        pos += 1\n        if sql[pos] == ch:\n            pos += 1\n            if pos == end_pos or sql[pos] != ch:\n                break\n\n            # escaped by double quoting: https://www.sqlite.org/faq.html#q14\n            pos += 1\n\n    return pos", "\n\ndef iter_sql_tokens(sql: str) -> Iterable[str]:\n    \"\"\"Calls lstrip_sql() to get the start of the next token and yield it.\n\n    It will handle stop chars (;,[]()) as their own tokens, as well as handle\n    double and single quotes, as well as quote escaping with \\\\\n\n    >>> list(iter_sql_tokens(\"--COMMENT\\\\nBEGIN X\"))\n    ['BEGIN', 'X']\n    >>> list(iter_sql_tokens(\n    ... \"CREATE TABLE x (id INTEGER /* COMMENT */, name TEXT)\"))\n    ['CREATE', 'TABLE', 'x', '(', 'id', 'INTEGER', ',', 'name', 'TEXT', ')']\n    >>> list(iter_sql_tokens(\"SELECT; INSERT; DELETE\"))\n    ['SELECT', ';', 'INSERT', ';', 'DELETE']\n    >>> print(\"\\\\n\".join(iter_sql_tokens(\n    ... 'INSERT INTO t (a,b) VALUES(\"s -- c /* c */\", \\\\'x\\\\')'\n    ... )))\n    INSERT\n    INTO\n    t\n    (\n    a\n    ,\n    b\n    )\n    VALUES\n    (\n    \"s -- c /* c */\"\n    ,\n    'x'\n    )\n    >>> list(iter_sql_tokens('SELECT\"abc\"'))\n    ['SELECT', '\"abc\"']\n    \"\"\"\n    while sql:\n        sql = lstrip_sql(sql) or \"\"\n        if not sql:\n            break\n\n        pos = 0\n        end_pos = len(sql)\n        while pos < end_pos:\n            ch = sql[pos]\n            if ch in _iter_sql_quote_chars:\n                if pos > 0:\n                    break\n                pos = _iter_sql_get_quoted_end(sql, pos, end_pos)\n                break\n            elif ch in _iter_sql_stop_chars:\n                break\n            else:\n                pos += 1\n\n        if pos > 0:\n            yield sql[:pos]\n            sql = sql[pos:]\n        else:\n            yield sql[0]\n            sql = sql[1:]", "\n\ndef iter_sql_statements(sql: str) -> Iterable[Sequence[str]]:\n    \"\"\"Yields sql statements based on \";\" tokens.\n\n    >>> list(iter_sql_statements(\"BEGIN\"))\n    [['BEGIN']]\n    >>> list(iter_sql_statements(\"BEGIN;INSERT INTO x;COMMIT\"))\n    [['BEGIN', ';'], ['INSERT', 'INTO', 'x', ';'], ['COMMIT']]\n\n    \"\"\"\n    stmt: List[str] = []\n    for token in iter_sql_tokens(sql):\n        stmt.append(token)\n        if token == \";\":\n            yield stmt\n            stmt = []\n\n    if stmt:\n        yield stmt", ""]}
{"filename": "libsql_client/dbapi2/__init__.py", "chunked_list": ["from __future__ import annotations\n\nimport sqlite3.dbapi2\nfrom typing import Any\nfrom typing import Mapping\nfrom typing import Optional\nfrom urllib.parse import urlparse\n\nfrom ._reexports import *\nfrom .hrana import ConnectionHrana as Connection", "from ._reexports import *\nfrom .hrana import ConnectionHrana as Connection\nfrom .hrana import CursorHrana as Cursor\nfrom .types import ConnectFactory\nfrom .types import Connection as BaseConnection\nfrom .types import ConnectionTypes\nfrom .types import Cursor as BaseCursor\nfrom .types import enable_callback_tracebacks\nfrom .types import IsolationLevel\nfrom .types import LEGACY_TRANSACTION_CONTROL", "from .types import IsolationLevel\nfrom .types import LEGACY_TRANSACTION_CONTROL\nfrom .types import PathLike\nfrom .types import Row\n\n\"\"\"\nThis module implements `Python Database API Specification v2.0\n<https://peps.python.org/pep-0249/>`_\nmimicking as much as possible :py:mod:`sqlite3` in order to provide a\ndrop-in replacement. Whenever explicitly undocumented, please refer its", "mimicking as much as possible :py:mod:`sqlite3` in order to provide a\ndrop-in replacement. Whenever explicitly undocumented, please refer its\ndocumentation.\n\n\"\"\"\n__docformat__ = \"reStructuredText en\"\n\n\n_connection_handlers: Mapping[str, ConnectFactory] = {\n    \"file\": sqlite3.dbapi2.connect,", "_connection_handlers: Mapping[str, ConnectFactory] = {\n    \"file\": sqlite3.dbapi2.connect,\n    \"libsql\": Connection,\n    \"ws\": Connection,\n    \"wss\": Connection,\n}\n\n_uri_forced_databases_prefixes = (\"libsql://\", \"ws://\", \"wss://\")\n\n\ndef connect(\n    database: PathLike,\n    timeout: float = 5.0,\n    detect_types: int = 0,\n    isolation_level: Optional[IsolationLevel] = \"\",\n    check_same_thread: bool = True,\n    factory: Optional[ConnectFactory] = None,\n    cached_statements: int = 128,\n    uri: bool = False,\n    **kwargs: Any,\n) -> ConnectionTypes:\n    \"\"\"\n    Open a connection to an SQLite (local) or sqld (remote) database.\n\n    In addition to :py:func:`sqlite3.connect`, this function allows\n    connecting to remote servers using the following protocols:\n\n    - ``libsql://`` alias for ``wss://``\n    - ``ws://`` insecure web socket\n    - ``wss://`` secure web socket\n\n    If local files or ``:memory:`` is used, then the standard\n    :py:class:`sqlite3.Connection` is returned.\n\n    For remote URL, :py:class:`libsql_client.dbapi2.hrana.ConnectionHrana` is\n    returned, it should match the behavior of\n    :py:class:`sqlite3.Connection` whenever possible.\n    \"\"\"\n    if not uri and isinstance(database, str):\n        for prefix in _uri_forced_databases_prefixes:\n            if database.startswith(prefix):\n                uri = True\n                break\n\n    handler: ConnectFactory\n    if not uri:\n        handler = sqlite3.dbapi2.connect\n        if factory is not None:\n            kwargs[\"factory\"] = factory\n    else:\n        if factory is not None:\n            handler = factory\n        else:\n            assert isinstance(database, str)\n            u = urlparse(database)\n            try:\n                handler = _connection_handlers[u.scheme]\n            except KeyError as e:\n                raise ValueError(f\"unsupported uri scheme: {u.scheme}\") from e\n\n    return handler(\n        database,\n        timeout=timeout,\n        detect_types=detect_types,\n        isolation_level=isolation_level,\n        check_same_thread=check_same_thread,\n        cached_statements=cached_statements,\n        uri=uri,\n        **kwargs,\n    )", "\n\ndef connect(\n    database: PathLike,\n    timeout: float = 5.0,\n    detect_types: int = 0,\n    isolation_level: Optional[IsolationLevel] = \"\",\n    check_same_thread: bool = True,\n    factory: Optional[ConnectFactory] = None,\n    cached_statements: int = 128,\n    uri: bool = False,\n    **kwargs: Any,\n) -> ConnectionTypes:\n    \"\"\"\n    Open a connection to an SQLite (local) or sqld (remote) database.\n\n    In addition to :py:func:`sqlite3.connect`, this function allows\n    connecting to remote servers using the following protocols:\n\n    - ``libsql://`` alias for ``wss://``\n    - ``ws://`` insecure web socket\n    - ``wss://`` secure web socket\n\n    If local files or ``:memory:`` is used, then the standard\n    :py:class:`sqlite3.Connection` is returned.\n\n    For remote URL, :py:class:`libsql_client.dbapi2.hrana.ConnectionHrana` is\n    returned, it should match the behavior of\n    :py:class:`sqlite3.Connection` whenever possible.\n    \"\"\"\n    if not uri and isinstance(database, str):\n        for prefix in _uri_forced_databases_prefixes:\n            if database.startswith(prefix):\n                uri = True\n                break\n\n    handler: ConnectFactory\n    if not uri:\n        handler = sqlite3.dbapi2.connect\n        if factory is not None:\n            kwargs[\"factory\"] = factory\n    else:\n        if factory is not None:\n            handler = factory\n        else:\n            assert isinstance(database, str)\n            u = urlparse(database)\n            try:\n                handler = _connection_handlers[u.scheme]\n            except KeyError as e:\n                raise ValueError(f\"unsupported uri scheme: {u.scheme}\") from e\n\n    return handler(\n        database,\n        timeout=timeout,\n        detect_types=detect_types,\n        isolation_level=isolation_level,\n        check_same_thread=check_same_thread,\n        cached_statements=cached_statements,\n        uri=uri,\n        **kwargs,\n    )", ""]}
{"filename": "libsql_client/dbapi2/_async_executor.py", "chunked_list": ["from __future__ import annotations\n\nimport asyncio\nimport concurrent.futures\nimport functools\nimport logging\nimport queue\nimport sys\nimport threading\nfrom typing import Any", "import threading\nfrom typing import Any\nfrom typing import Awaitable\nfrom typing import Callable\nfrom typing import NamedTuple\nfrom typing import Optional\nfrom typing import overload\nfrom typing import TypeVar\n\nfrom typing_extensions import ParamSpec", "\nfrom typing_extensions import ParamSpec\n\nfrom ._utils import log_obj\nfrom ._utils import log_prefix\n\n_logger = logging.getLogger(__name__)\n_log_obj = functools.partial(log_obj, _logger)\n_log_prefix = functools.partial(log_prefix, _logger)\n", "_log_prefix = functools.partial(log_prefix, _logger)\n\nP = ParamSpec(\"P\")\nT = TypeVar(\"T\")\n\n\nclass LoopControl(NamedTuple):\n    loop: asyncio.AbstractEventLoop\n    stop_event: asyncio.Event\n", "\n\n# NOTE: keep outside of class, do not touch self, not even keep a reference\ndef _thread_main(log_prefix: str, q: queue.Queue[LoopControl]) -> None:\n    loop: Optional[asyncio.AbstractEventLoop] = None\n\n    def dbg(\n        msg: str,\n        *args: object,\n        exc_info: Optional[BaseException] = None,\n    ) -> None:\n        nonlocal loop\n        loop_str = f\" {loop!r}\" if loop else \"\"\n        prefix = f\"{log_prefix}{loop_str}: \"\n        _log_prefix(prefix, logging.DEBUG, msg, *args, exc_info=exc_info)\n\n    async def main() -> None:\n        nonlocal loop\n        stop_event = asyncio.Event()\n        loop = asyncio.get_running_loop()\n        try:\n            dbg(\"started main()\")\n            q.put_nowait(LoopControl(loop, stop_event))\n            await stop_event.wait()\n            dbg(\"finished main()\")\n        except Exception as e:\n            dbg(\"failed main(): %s\", e, exc_info=e)\n        finally:\n            loop = None\n\n    dbg(\"started thread\")\n    asyncio.run(main())\n    dbg(\"finished thread\")", "\n\nclass AsyncExecutor(threading.Thread):\n    _lock: threading.Lock\n    _control: Optional[LoopControl]\n    __slots__ = (\"_control\", \"_lock\")\n\n    def __init__(self) -> None:\n        self._control = None\n        q: queue.Queue[LoopControl] = queue.Queue(1)\n        log_prefix = f\"<{self.__class__.__name__} at {id(self):x}>\"\n        super().__init__(daemon=True, target=_thread_main, args=(log_prefix, q))\n        self._inf(\"created\")\n        self.start()\n        self._lock = threading.Lock()\n        self._control = q.get()\n        self._inf(\"thread ready\")\n\n    def __del__(self) -> None:\n        self._inf(\"destroyed\")\n        # This is really unlikely, since run() will be in the thread,\n        # and thus will hold a reference in there, but let's check it anyway\n        assert self._control is None, \"Thread is still running\"\n\n    def __repr__(self) -> str:\n        addr = hex(id(self))\n        s = \"started\" if self.is_alive() else \"stopped\"\n        if self._control is not None:\n            s += f\" loop={self._control.loop}\"\n        return f\"<{self.__class__.__name__} at {addr} name={self.name!r} {s}>\"\n\n    _log = functools.partial(_log_obj)\n    _dbg = functools.partialmethod(_log, logging.DEBUG)\n    _inf = functools.partialmethod(_log, logging.INFO)\n    _err = functools.partialmethod(_log, logging.ERROR)\n\n    def shutdown(self) -> None:\n        self._dbg(\"shuting down thread...\")\n        with self._lock:\n            if self._control is None:\n                raise RuntimeError(\"thread already down\")\n\n            loop, stop_event = self._control\n            self._control = None\n\n        async def run_in_main_loop() -> None:\n            self._dbg(\"notifying _stop_event\")\n            stop_event.set()\n\n        self._dbg(\"thread will stop\")\n        coro = run_in_main_loop()\n        future = asyncio.run_coroutine_threadsafe(coro, loop)\n        future.result()\n        self.join()\n        self._inf(\"thread did stop\")\n\n    if sys.version_info[:2] >= (3, 9):\n\n        @overload\n        def submit(\n            self,\n            fn: Callable[P, Awaitable[asyncio.Future[T]]],\n            *args: P.args,\n            **kwargs: P.kwargs,\n        ) -> concurrent.futures.Future[T]:\n            ...\n\n        @overload\n        def submit(\n            self,\n            fn: Callable[P, Awaitable[T]],\n            *args: P.args,\n            **kwargs: P.kwargs,\n        ) -> concurrent.futures.Future[T]:\n            ...\n\n        @overload\n        def submit(\n            self,\n            fn: Callable[P, T],\n            *args: P.args,\n            **kwargs: P.kwargs,\n        ) -> concurrent.futures.Future[T]:\n            ...\n\n    else:\n\n        @overload\n        def submit(\n            self,\n            fn: Callable[P, Awaitable[asyncio.Future]],\n            *args: P.args,\n            **kwargs: P.kwargs,\n        ) -> concurrent.futures.Future:\n            ...\n\n        @overload\n        def submit(\n            self,\n            fn: Callable[P, Awaitable[T]],\n            *args: P.args,\n            **kwargs: P.kwargs,\n        ) -> concurrent.futures.Future:\n            ...\n\n        @overload\n        def submit(\n            self,\n            fn: Callable[P, T],\n            *args: P.args,\n            **kwargs: P.kwargs,\n        ) -> concurrent.futures.Future:\n            ...\n\n    def submit(\n        self,\n        fn: Callable[P, T],\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -> Any:  # variants are covered by overloads\n        with self._lock:\n            return self._unlocked_submit(fn, *args, **kwargs)\n\n    def _unlocked_submit(\n        self,\n        fn: Callable[P, T],\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -> Any:  # variants are covered by overloads\n        if self._control is None:\n            raise RuntimeError(\"already down\")\n\n        async def run_in_main_loop() -> Any:\n            try:\n                self._dbg(\"calling: %s, args=%s, kwargs=%s\", fn, args, kwargs)\n                r = fn(*args, **kwargs)\n                while asyncio.iscoroutine(r) or asyncio.isfuture(r):\n                    r = await r\n                self._dbg(\n                    \"finished: %s, args=%s, kwargs=%s, result=%s\",\n                    fn,\n                    args,\n                    kwargs,\n                    r,\n                )\n                return r\n            except Exception as e:\n                self._dbg(\n                    \"failed: %s, args=%s, kwargs=%s, exc=%s\",\n                    fn,\n                    args,\n                    kwargs,\n                    e,\n                    exc_info=e,\n                )\n                raise\n\n        coro = run_in_main_loop()\n        return asyncio.run_coroutine_threadsafe(coro, self._control.loop)", ""]}
{"filename": "libsql_client/dbapi2/_replace_modules_pythonpath/sqlite3/dbapi2.py", "chunked_list": ["import os.path\nimport sys\n\n# $LIBSQL_PYTHONPATH_BOOTSTRAP is set by libsql_client.dbapi2.__main__\nbootstrap_path = os.environ[\"LIBSQL_PYTHONPATH_BOOTSTRAP\"]\n\nsqlite3_dbapi2_modname = __name__\nsqlite3_modname = sqlite3_dbapi2_modname.split(\".\")[0]\n\n# Remove itself from sys.path/$PYTHONPATH", "\n# Remove itself from sys.path/$PYTHONPATH\n#\n# This MUST be done before libsql_client.dbapi2 is imported\n# since it will use the stdlib sqlite3\nsys.path.remove(bootstrap_path)\ndel sys.modules[sqlite3_modname]\ndel sys.modules[sqlite3_dbapi2_modname]\n\nimport libsql_client.dbapi2 as wrapper_dbapi2  # noqa: I900,E402", "\nimport libsql_client.dbapi2 as wrapper_dbapi2  # noqa: I900,E402\n\nsys.modules[sqlite3_modname] = wrapper_dbapi2\nsys.modules[sqlite3_dbapi2_modname] = wrapper_dbapi2\n"]}
{"filename": "libsql_client/dbapi2/_replace_modules_pythonpath/sqlite3/__init__.py", "chunked_list": ["from .dbapi2 import *  # noqa: F401,F403\n"]}
{"filename": "docs/conf.py", "chunked_list": ["# Configuration file for the Sphinx documentation builder.\n#\n# For the full list of built-in configuration values, see the documentation:\n# https://www.sphinx-doc.org/en/master/usage/configuration.html\n\n# -- Project information -----------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/configuration.html#project-information\n\nproject = \"Python SDK for libSQL\"\ncopyright = \"2023, Chiselstrike\"", "project = \"Python SDK for libSQL\"\ncopyright = \"2023, Chiselstrike\"\nauthor = \"Chiselstrike\"\n\n# -- General configuration ---------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/configuration.html#general-configuration\n\nextensions = [\"sphinx.ext.intersphinx\", \"sphinx.ext.autodoc\"]\n\ntemplates_path = [\"_templates\"]", "\ntemplates_path = [\"_templates\"]\nexclude_patterns = [\"_build\", \"Thumbs.db\", \".DS_Store\"]\n\n# -- Options for HTML output -------------------------------------------------\n# https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-html-output\n\nhtml_theme = \"sphinxdoc\"\nhtml_static_path = [\"_static\"]\n", "html_static_path = [\"_static\"]\n\nintersphinx_mapping = {\n    \"https://docs.python.org/3/\": None,\n}\n"]}
