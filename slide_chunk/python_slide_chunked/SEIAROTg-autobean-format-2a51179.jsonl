{"filename": "autobean_format/formatter.py", "chunked_list": ["import io\nfrom autobean_refactor import models, parser as parser_lib\nfrom . import options_lib\nfrom . import formatters\n\n\ndef format(\n    model: models.RawModel,\n    parser: parser_lib.Parser,\n    options: options_lib.Options,\n    stream: io.StringIO,\n    *,\n    indent: int = 0,\n) -> None:\n    context = formatters.Context(parser=parser, options=options, indent=indent)\n    for token in formatters.format(model, context):\n        stream.write(token.raw_text)", ""]}
{"filename": "autobean_format/main.py", "chunked_list": ["import collections\nimport dataclasses\nimport difflib\nimport fileinput\nimport glob\nimport io\nimport os.path\nimport sys\nfrom contextlib import nullcontext\nfrom typing import Iterable, Iterator", "from contextlib import nullcontext\nfrom typing import Iterable, Iterator\nfrom . import formatter, options_lib\nfrom autobean_refactor import models, parser as parser_lib\n\n\n@dataclasses.dataclass(frozen=True)\nclass _File:\n    filename: str\n    text: str", "    filename: str\n    text: str\n    model: models.File\n\n\ndef _get_include_paths(path: str, file: models.File) -> Iterable[str]:\n    for directive in file.raw_directives:\n        if not isinstance(directive, models.Include):\n            continue\n        matches = glob.glob(os.path.join(os.path.dirname(path), directive.filename), recursive=True)", "            continue\n        matches = glob.glob(os.path.join(os.path.dirname(path), directive.filename), recursive=True)\n        if not matches:\n            lineno = directive.token_store.get_position(directive.first_token).line\n            raise ValueError(f'No files match {directive.filename!r} ({path}:{lineno})')\n        yield from matches\n\n\nclass _FilesFormatter:\n    def __init__(self, options: options_lib.Options) -> None:", "class _FilesFormatter:\n    def __init__(self, options: options_lib.Options) -> None:\n        self._parser = parser_lib.Parser()\n        self._options = options\n\n    def load_files(self, filename: str) -> Iterator[_File]:\n        visited = set()\n        queue = collections.deque([filename])\n\n        while queue:", "\n        while queue:\n            filename = queue.popleft()\n            if filename in visited:\n                continue\n            visited.add(filename)\n            with fileinput.input(files=filename, encoding='utf-8') as f:\n                text = ''.join(f)\n            model = self._parser.parse(text, models.File)\n            model.auto_claim_comments()", "            model = self._parser.parse(text, models.File)\n            model.auto_claim_comments()\n            yield _File(filename=filename, text=text, model=model)\n            if self._options.recursive:\n                queue.extend(_get_include_paths(filename, model))\n\n    def format_file(self, file: _File) -> str:\n        stream = io.StringIO()\n        formatter.format(file.model, self._parser, self._options, stream)\n        return stream.getvalue()", "        formatter.format(file.model, self._parser, self._options, stream)\n        return stream.getvalue()\n\n    def output_file(self, file: _File, formatted: str) -> None:\n        match self._options.output_mode:\n            case options_lib.OutputMode.STDOUT:\n                sys.stdout.write(formatted)\n                sys.stdout.flush()\n            case options_lib.OutputMode.DIFF:\n                diff = difflib.unified_diff(", "            case options_lib.OutputMode.DIFF:\n                diff = difflib.unified_diff(\n                    file.text.splitlines(keepends=True),\n                    formatted.splitlines(keepends=True),\n                    fromfile=file.filename,\n                    tofile=file.filename + ' (formatted)')\n                sys.stdout.writelines(diff)\n                sys.stdout.flush()\n            case options_lib.OutputMode.INPLACE:\n                with open(file.filename, 'w', encoding='utf-8') as f:", "            case options_lib.OutputMode.INPLACE:\n                with open(file.filename, 'w', encoding='utf-8') as f:\n                    f.write(formatted)\n\n\ndef main() -> None:\n    filename, options = options_lib.parse_args()\n\n    formatter = _FilesFormatter(options)\n", "    formatter = _FilesFormatter(options)\n\n    for file in formatter.load_files(filename):\n        formatted = formatter.format_file(file)\n        formatter.output_file(file, formatted)\n\n"]}
{"filename": "autobean_format/__init__.py", "chunked_list": [""]}
{"filename": "autobean_format/options_lib.py", "chunked_list": ["import argparse\nimport dataclasses\nimport enum\nimport re\n\n_INDENT_REGEX = re.compile('[ \\t]+')\n\n\nclass OutputMode(enum.Enum):\n    STDOUT = 'stdout'\n    DIFF = 'diff'\n    INPLACE = 'inplace'\n\n    def __str__(self) -> str:\n        return self.value", "class OutputMode(enum.Enum):\n    STDOUT = 'stdout'\n    DIFF = 'diff'\n    INPLACE = 'inplace'\n\n    def __str__(self) -> str:\n        return self.value\n\n\nclass ThousandsSeparator(enum.Enum):\n    ADD = 'add'\n    REMOVE = 'remove'\n    KEEP = 'keep'\n\n    def __str__(self) -> str:\n        return self.value", "\nclass ThousandsSeparator(enum.Enum):\n    ADD = 'add'\n    REMOVE = 'remove'\n    KEEP = 'keep'\n\n    def __str__(self) -> str:\n        return self.value\n\n", "\n\n@dataclasses.dataclass(frozen=True)\nclass Options:\n    indent: str\n    currency_column: int\n    cost_column: int\n    output_mode: OutputMode\n    thousands_separator: ThousandsSeparator\n    spaces_in_braces: bool\n    sort: bool\n    recursive: bool", "\n\ndef _indent_type(value: str) -> str:\n    if not _INDENT_REGEX.fullmatch(value):\n        raise argparse.ArgumentTypeError(\n            f'Expected a string of spaces or tabs (not number). Got {value!r}.')\n    return value\n\n\ndef parse_args() -> tuple[str, Options]:\n    parser = argparse.ArgumentParser(\n        prog='autobean-format',\n        description='Formats beancount files',\n    )\n    parser.add_argument('filename', help=\"When filename is -, read standard input and disallow --recursive\")\n    parser.add_argument('--indent', type=_indent_type, default='    ', help='Indentation string. (default: 4 spaces)')\n    parser.add_argument('--currency-column', type=int, default=80, help='Column to align currencies to. (default: %(default)s)')\n    parser.add_argument('--cost-column', type=int, default=85, help='Column to align cost and price to. (default: %(default)s)')\n    output_mode = parser.add_argument('--output-mode', choices=OutputMode, type=OutputMode, default=OutputMode.STDOUT, help='Output mode. Print to stdout, print a patch file, or update file in place. (default: %(default)s)')\n    parser.add_argument('--thousands-separator', choices=ThousandsSeparator, type=ThousandsSeparator, default=ThousandsSeparator.KEEP, help='Add, remove, or keep thousand separators (default: %(default)s)')\n    parser.add_argument('--spaces-in-braces', action='store_true', help='Add spaces around content of braces if not empty. (default: false)')\n    parser.add_argument('--sort', action='store_true', help='Sort entries by date and time. (default: false)')\n    recursive = parser.add_argument('--recursive', action='store_true', help='Recursively format included files. (default: false)')\n\n    args = parser.parse_args()\n    if args.filename == '-':\n        if args.recursive:\n            raise argparse.ArgumentError(\n                recursive, 'not supported when reading from stin')\n        if args.output_mode == OutputMode.INPLACE:\n            raise argparse.ArgumentError(\n                output_mode, 'inplace not supported when reading from stin')\n\n    return args.filename, Options(\n        indent=args.indent,\n        currency_column=args.currency_column,\n        cost_column=args.cost_column,\n        output_mode=args.output_mode,\n        thousands_separator=args.thousands_separator,\n        spaces_in_braces=args.spaces_in_braces,\n        sort=args.sort,\n        recursive=args.recursive,\n    )", "\ndef parse_args() -> tuple[str, Options]:\n    parser = argparse.ArgumentParser(\n        prog='autobean-format',\n        description='Formats beancount files',\n    )\n    parser.add_argument('filename', help=\"When filename is -, read standard input and disallow --recursive\")\n    parser.add_argument('--indent', type=_indent_type, default='    ', help='Indentation string. (default: 4 spaces)')\n    parser.add_argument('--currency-column', type=int, default=80, help='Column to align currencies to. (default: %(default)s)')\n    parser.add_argument('--cost-column', type=int, default=85, help='Column to align cost and price to. (default: %(default)s)')\n    output_mode = parser.add_argument('--output-mode', choices=OutputMode, type=OutputMode, default=OutputMode.STDOUT, help='Output mode. Print to stdout, print a patch file, or update file in place. (default: %(default)s)')\n    parser.add_argument('--thousands-separator', choices=ThousandsSeparator, type=ThousandsSeparator, default=ThousandsSeparator.KEEP, help='Add, remove, or keep thousand separators (default: %(default)s)')\n    parser.add_argument('--spaces-in-braces', action='store_true', help='Add spaces around content of braces if not empty. (default: false)')\n    parser.add_argument('--sort', action='store_true', help='Sort entries by date and time. (default: false)')\n    recursive = parser.add_argument('--recursive', action='store_true', help='Recursively format included files. (default: false)')\n\n    args = parser.parse_args()\n    if args.filename == '-':\n        if args.recursive:\n            raise argparse.ArgumentError(\n                recursive, 'not supported when reading from stin')\n        if args.output_mode == OutputMode.INPLACE:\n            raise argparse.ArgumentError(\n                output_mode, 'inplace not supported when reading from stin')\n\n    return args.filename, Options(\n        indent=args.indent,\n        currency_column=args.currency_column,\n        cost_column=args.cost_column,\n        output_mode=args.output_mode,\n        thousands_separator=args.thousands_separator,\n        spaces_in_braces=args.spaces_in_braces,\n        sort=args.sort,\n        recursive=args.recursive,\n    )", "\n"]}
{"filename": "autobean_format/formatters/base.py", "chunked_list": ["import dataclasses\nimport io\nfrom typing import Any, Callable, Iterable, Iterator, Type, TypeVar\nfrom autobean_refactor import models, parser as parser_lib\nfrom .. import options_lib\n\n_M = TypeVar('_M', bound=models.RawModel)\n\n\n@dataclasses.dataclass(frozen=True)\nclass Context:\n    parser: parser_lib.Parser\n    options: options_lib.Options\n    indent: int\n\n    def with_indented(self, indented: bool) -> 'Context':\n        if not indented:\n            return self\n        return dataclasses.replace(self, indent=self.indent + 1)\n\n    def get_indent(self) -> str:\n        return self.options.indent * self.indent", "\n@dataclasses.dataclass(frozen=True)\nclass Context:\n    parser: parser_lib.Parser\n    options: options_lib.Options\n    indent: int\n\n    def with_indented(self, indented: bool) -> 'Context':\n        if not indented:\n            return self\n        return dataclasses.replace(self, indent=self.indent + 1)\n\n    def get_indent(self) -> str:\n        return self.options.indent * self.indent", "\n\n_Formatter = Callable[[_M, Context], Iterator[models.RawTokenModel]]\n_FORMATTERS = dict[Type[models.RawModel], _Formatter[Any]]()\n\n\ndef formatter(model_type: Type[_M]) -> Callable[[_Formatter[_M]], _Formatter[_M]]:\n    def decorator(formatter: _Formatter[_M]) -> _Formatter[_M]:\n        _FORMATTERS[model_type] = formatter\n        return formatter\n    return decorator", "\n\ndef format(model: models.RawModel, context: Context) -> Iterator[models.RawTokenModel]:\n    formatter = _FORMATTERS.get(type(model))\n    if formatter:\n        yield from formatter(model, context)\n    elif isinstance(model, models.RawTokenModel):\n        yield model\n    else:\n        for child, indented in model.iter_children_formatted():\n            yield from format(child, context.with_indented(indented))", "\n\ndef collect(children: Iterable[tuple[models.RawModel, bool]], context: Context) -> str:\n    stream = io.StringIO()\n    for child, indented in children:\n        for token in format(child, context.with_indented(indented)):\n            stream.write(token.raw_text)\n    return stream.getvalue()\n", ""]}
{"filename": "autobean_format/formatters/cost.py", "chunked_list": ["from typing import Iterator\nfrom autobean_refactor import models\nfrom . import base\n\n\ndef format_cost(cost: models.UnitCost | models.TotalCost, context: base.Context) -> Iterator[models.RawTokenModel]:\n    spaces_in_braces = context.options.spaces_in_braces and next(iter(cost.raw_components), None) is not None\n\n    for child, indented in cost.iter_children_formatted():\n        if spaces_in_braces and isinstance(child, models.RightBrace | models.DblRightBrace):\n            yield models.Whitespace.from_default()\n        yield from base.format(child, context.with_indented(indented))\n        if spaces_in_braces and isinstance(child, models.LeftBrace | models.DblLeftBrace):\n            yield models.Whitespace.from_default()", "\n\nbase.formatter(models.UnitCost)(format_cost)\nbase.formatter(models.TotalCost)(format_cost)\n"]}
{"filename": "autobean_format/formatters/balance.py", "chunked_list": ["from typing import Iterator\nfrom autobean_refactor import models\nfrom ..internal import alignment, iterating\nfrom . import base\n\n\n@base.formatter(models.Balance)\ndef format_balance(open: models.Balance, context: base.Context) -> Iterator[models.RawTokenModel]:\n\n    children_it = iterating.BufferedIterator(open.iter_children_formatted())\n\n    for child, indented in children_it.take_until(lambda x: isinstance(x[0], models.Date)):\n        yield from base.format(child, context.with_indented(indented))\n\n    line = base.collect(children_it.take_until_inclusive(lambda x: isinstance(x[0], models.Eol)), context)\n    header = context.parser.parse(line, models.Balance)\n    if padding := alignment.get_padding_align_left(header.raw_currency, context.options.currency_column):\n        header.raw_account.spacing_after += padding\n    yield from header.tokens\n\n    for child, indented in children_it:\n        yield from base.format(child, context.with_indented(indented))", ""]}
{"filename": "autobean_format/formatters/tokens.py", "chunked_list": ["import re\nfrom typing import Iterator\nfrom autobean_refactor import models\nfrom . import base\n\n_NARRATION_RE = re.compile(r';;(.*?)(?:;(.*))?')\n\n\n@base.formatter(models.Indent)\ndef format_indent(indent: models.Indent, context: base.Context) -> Iterator[models.RawTokenModel]:\n    yield models.Indent.from_value(context.get_indent())", "@base.formatter(models.Indent)\ndef format_indent(indent: models.Indent, context: base.Context) -> Iterator[models.RawTokenModel]:\n    yield models.Indent.from_value(context.get_indent())\n\n\n@base.formatter(models.BlockComment)\ndef format_block_comment(comment: models.BlockComment, context: base.Context) -> Iterator[models.RawTokenModel]:\n    yield models.BlockComment.from_value(\n        value=comment.value,\n        indent=context.get_indent())", "\n\n@base.formatter(models.InlineComment)\ndef format_inline_comment(comment: models.InlineComment, context: base.Context) -> Iterator[models.RawTokenModel]:\n    match = re.fullmatch(_NARRATION_RE, comment.raw_text)\n    if not match:\n        yield models.InlineComment.from_value(comment.value)\n        return\n\n    # autobean.narration\n    raw_text = ';;'\n    narration = match.group(1).strip()\n    if narration:\n        raw_text += ' ' + narration\n    comment_part = match.group(2)\n    if comment_part is not None:\n        raw_text += ' ;'\n        comment_value = comment_part.strip()\n        if comment_value:\n            raw_text += ' ' + comment_value\n    yield models.InlineComment.from_raw_text(raw_text)", ""]}
{"filename": "autobean_format/formatters/__init__.py", "chunked_list": ["from .base import *\nfrom . import tokens\nfrom . import balance\nfrom . import cost\nfrom . import file\nfrom . import number\nfrom . import open\nfrom . import posting\nfrom . import price\n", "from . import price\n"]}
{"filename": "autobean_format/formatters/open.py", "chunked_list": ["from typing import Iterator\nfrom autobean_refactor import models\nfrom ..internal import alignment, iterating\nfrom . import base\n\n\n@base.formatter(models.Open)\ndef format_open(open: models.Open, context: base.Context) -> Iterator[models.RawTokenModel]:\n\n    children_it = iterating.BufferedIterator(open.iter_children_formatted())\n\n    for child, indented in children_it.take_until(lambda x: isinstance(x[0], models.Date)):\n        yield from base.format(child, context.with_indented(indented))\n    \n    line = base.collect(children_it.take_until_inclusive(lambda x: isinstance(x[0], models.Eol)), context)\n    header = context.parser.parse(line, models.Open)\n    if header.raw_currencies:\n        if padding := alignment.get_padding_align_left(header.raw_currencies[0], context.options.currency_column):\n            header.raw_currencies[0].spacing_before += padding\n    yield from header.tokens\n\n    for child, indented in children_it:\n        yield from base.format(child, context.with_indented(indented))", ""]}
{"filename": "autobean_format/formatters/price.py", "chunked_list": ["from typing import Iterator\nfrom autobean_refactor import models\nfrom ..internal import alignment, iterating\nfrom . import base\n\n\n@base.formatter(models.Price)\ndef format_price(open: models.Price, context: base.Context) -> Iterator[models.RawTokenModel]:\n\n    children_it = iterating.BufferedIterator(open.iter_children_formatted())\n\n    for child, indented in children_it.take_until(lambda x: isinstance(x[0], models.Date)):\n        yield from base.format(child, context.with_indented(indented))\n\n    line = base.collect(children_it.take_until_inclusive(lambda x: isinstance(x[0], models.Eol)), context)\n    header = context.parser.parse(line, models.Price)\n    if padding := alignment.get_padding_align_left(header.raw_amount.raw_currency, context.options.currency_column):\n        header.raw_amount.spacing_before += padding\n    yield from header.tokens\n\n    for child, indented in children_it:\n        yield from base.format(child, context.with_indented(indented))", ""]}
{"filename": "autobean_format/formatters/number.py", "chunked_list": ["from typing import Iterator\nfrom autobean_refactor import models\nfrom .. import options_lib\nfrom . import base\n\n\n@base.formatter(models.Number)\ndef format_number(number: models.Number, context: base.Context) -> Iterator[models.RawTokenModel]:\n    match context.options.thousands_separator:\n        case options_lib.ThousandsSeparator.ADD:", "    match context.options.thousands_separator:\n        case options_lib.ThousandsSeparator.ADD:\n            yield models.Number.from_raw_text(f'{number.value:,f}')\n        case options_lib.ThousandsSeparator.REMOVE:\n            yield models.Number.from_raw_text(f'{number.value:f}')\n        case _:\n            yield number\n"]}
{"filename": "autobean_format/formatters/posting.py", "chunked_list": ["from typing import Iterator\nfrom autobean_refactor import models\nfrom ..internal import alignment, iterating\nfrom . import base\n\n\n@base.formatter(models.Posting)\ndef format_posting(posting: models.Posting, context: base.Context) -> Iterator[models.RawTokenModel]:\n\n    children_it = iterating.BufferedIterator(posting.iter_children_formatted())\n\n    for child, indented in children_it.take_until(lambda x: isinstance(x[0], models.Indent)):\n        yield from base.format(child, context.with_indented(indented))\n\n    line = base.collect(children_it.take_until_inclusive(lambda x: isinstance(x[0], models.Eol)), context)\n    header = context.parser.parse(line, models.Posting)\n    if header.raw_currency:\n        if padding := alignment.get_padding_align_left(header.raw_currency, context.options.currency_column):\n            header.raw_account.spacing_after += padding\n    elif header.raw_number:\n        if padding := alignment.get_padding_align_right(header.raw_number, context.options.currency_column - 1):\n            header.raw_account.spacing_after += padding\n    if header.raw_cost:\n        if padding := alignment.get_padding_align_left(header.raw_cost, context.options.cost_column):\n            header.raw_cost.spacing_before += padding\n    elif header.raw_price:\n        if padding := alignment.get_padding_align_left(header.raw_price, context.options.cost_column):\n            header.raw_price.spacing_before += padding\n\n    yield from header.tokens\n\n    for child, indented in children_it:\n        yield from base.format(child, context.with_indented(indented))", ""]}
{"filename": "autobean_format/formatters/file.py", "chunked_list": ["from typing import Iterable, Iterator, Optional, Sequence, TypeAlias, TypeGuard, get_args\nfrom autobean_refactor import models\nfrom ..internal import sorting\nfrom . import base\n\n_TopLevelEntity: TypeAlias = models.Directive | models.BlockComment\n_Block: TypeAlias = Sequence[_TopLevelEntity]\n_BLANK_LINE_SURROUNDED = {\n    models.BlockComment,\n    models.IgnoredLine,", "    models.BlockComment,\n    models.IgnoredLine,\n    models.Transaction,\n}\n\n\ndef _get_category(model: _TopLevelEntity) -> str:\n    if isinstance(model, models.Pushtag | models.Poptag | models.Pushmeta | models.Popmeta):\n        return 'push_pop'\n    if isinstance(model, models.Open | models.Close | models.Commodity | models.Pad | models.Balance):\n        return 'declaration'\n    if isinstance(model, models.Plugin | models.Include | models.Option):\n        return 'directive'\n    return 'other'", "\n\ndef _should_split(prev: Optional[_TopLevelEntity], current: _TopLevelEntity) -> bool:\n    if prev is None:\n        return False\n    current_spacing = prev.spacing_after.count('\\n')\n    if current_spacing >= 2:\n        return True\n    if type(prev) in _BLANK_LINE_SURROUNDED or type(current) in _BLANK_LINE_SURROUNDED:\n        return True\n    if _get_category(prev) != _get_category(current):\n        return True\n    return False", "\n\ndef _is_directive_or_comment(model: models.RawModel) -> TypeGuard[_TopLevelEntity]:\n    return isinstance(model, get_args(_TopLevelEntity))\n\n\ndef _partition(file: models.File, context: base.Context) -> list[_Block]:\n    prev = None\n    last_block = None\n    blocks: list[_Block] = []\n    for child, indented in file.iter_children_formatted():\n        if isinstance(child, models.Whitespace | models.Newline):\n            continue\n        assert _is_directive_or_comment(child)\n        assert not indented\n        if last_block is None or _should_split(prev, child):\n            last_block = [child]\n            blocks.append(last_block)\n        else:\n            last_block.append(child)\n        prev = child\n    return blocks", "\n\ndef _render(blocks: Iterable[_Block], context: base.Context) -> Iterator[models.RawTokenModel]:\n    prev = None\n    for block in blocks:\n        if prev:\n            yield models.Newline.from_default()\n        for child in block:\n            yield from base.format(child, context)\n            yield models.Newline.from_default()\n        prev = block", "\n\n@base.formatter(models.File)\ndef format_file(file: models.File, context: base.Context) -> Iterator[models.RawTokenModel]:\n    blocks: list[_Block] = _partition(file, context)\n    if context.options.sort:\n        blocks = sorting.sort_blocks(blocks)\n    yield from _render(blocks, context)\n", ""]}
{"filename": "autobean_format/tests/numbers_test.py", "chunked_list": ["from autobean_refactor import models\nimport pytest\nfrom . import base\n\n\nclass TestNumbers(base.BaseTest):\n\n    @pytest.mark.parametrize('src,expected', [\n        ('1-2+3', '1 - 2 + 3'),\n        ('1+2*3', '1 + 2 * 3'),\n        ('1     +  2  /  5', '1 + 2 / 5'),\n        ('--+-+2', '--+-+2'),\n        ('-(2)*-3 +- 5', '-(2) * -3 + -5'),\n        ('(1+2)*3', '(1 + 2) * 3'),\n    ])\n    def test_expr(self, src: str, expected: str) -> None:\n        assert self.format(src, models.NumberExpr) == expected", ""]}
{"filename": "autobean_format/tests/sorting_test.py", "chunked_list": ["import datetime\nimport decimal\nfrom typing import Optional, Sequence, TypeAlias, cast, get_args\nfrom autobean_refactor import models\nimport pytest\nfrom ..internal import sorting\nfrom . import base\n\n_Entry: TypeAlias = models.Balance | models.Close | models.Commodity | models.Pad | models.Event | models.Query | models.Price | models.Note | models.Document | models.Custom | models.Transaction\n_TopLevelEntity: TypeAlias = models.Directive | models.BlockComment", "_Entry: TypeAlias = models.Balance | models.Close | models.Commodity | models.Pad | models.Event | models.Query | models.Price | models.Note | models.Document | models.Custom | models.Transaction\n_TopLevelEntity: TypeAlias = models.Directive | models.BlockComment\n_TestBlock: TypeAlias = list[str] | list[_TopLevelEntity]\n_PLUGIN = models.Plugin.from_value(name='test')\n_INCLUDE = models.Include.from_value(filename='test')\n_PUSHTAG = models.Pushtag.from_value(tag='test')\n\n\ndef build_dated_entry(entry: str) -> _TopLevelEntity:\n    parts = entry.split(' ', maxsplit=1)\n    date = datetime.datetime.strptime(parts[0], '%Y-%m-%d').date()\n    meta: dict[str, str | decimal.Decimal]\n    if len(parts) == 2:\n        meta = dict(time=parts[1] if ':' in parts[1] else decimal.Decimal(parts[1]))\n    else:\n        meta = {}\n    return models.Custom.from_value(date=date, type='test', values=(), meta=meta)", "def build_dated_entry(entry: str) -> _TopLevelEntity:\n    parts = entry.split(' ', maxsplit=1)\n    date = datetime.datetime.strptime(parts[0], '%Y-%m-%d').date()\n    meta: dict[str, str | decimal.Decimal]\n    if len(parts) == 2:\n        meta = dict(time=parts[1] if ':' in parts[1] else decimal.Decimal(parts[1]))\n    else:\n        meta = {}\n    return models.Custom.from_value(date=date, type='test', values=(), meta=meta)\n", "\n\ndef unbuild_entity(entity: _TopLevelEntity) -> str | _TopLevelEntity:\n    if not isinstance(entity, get_args(_Entry)):\n        return entity\n    entry: _Entry = cast(_Entry, entity)\n    time = entry.meta.get('time')\n    if time is None:\n        return str(entry.date)\n    return f'{entry.date} {time}'", "\n\ndef build_block(block: _TestBlock) -> list[_TopLevelEntity]:\n    if not block:\n        return []\n    if not isinstance(block[0], str):\n        return cast(list[_TopLevelEntity], block)\n    return [build_dated_entry(entry) for entry in cast(list[str], block)]\n\n\ndef build_blocks(blocks: list[_TestBlock]) -> list[list[_TopLevelEntity]]:\n    return [build_block(block) for block in blocks]", "\n\ndef build_blocks(blocks: list[_TestBlock]) -> list[list[_TopLevelEntity]]:\n    return [build_block(block) for block in blocks]\n\n\n# For better test output\ndef unbuild_blocks(\n        blocks: list[Sequence[models.Directive | models.BlockComment]]\n) -> list[list[str | _TopLevelEntity]]:\n    return [[unbuild_entity(entity) for entity in block] for block in blocks]", "\n\nclass TestSorting(base.BaseTest):\n\n    @pytest.mark.parametrize('blocks,sorted_blocks', [\n        pytest.param([], None, id='empty'),\n        pytest.param([['2000-01-01']], None, id='single'),\n        pytest.param([[_PLUGIN, _INCLUDE]], None, id='undated'),\n        pytest.param([['2000-01-01', '2000-01-01', '2000-01-02', '2000-01-03']], None, id='sorted'),\n        pytest.param(\n            [['2000-01-01', '2000-01-02 01:00', '2000-01-02 02:00', '2000-01-02 03:00', '2000-01-03']],\n            None,\n            id='sorted with time'),\n        pytest.param(\n            [['2000-01-01', '2000-01-02 01:00', '2000-01-02', '2000-01-02 02:00', '2000-01-02',\n              '2000-01-02 02:00', '2000-01-03']],\n            None,\n            id='sorted with optional time'),\n        pytest.param(\n            [['2000-01-01', '2000-01-02 01:00', '2000-01-02', '2000-01-02 02:00', '2000-01-02',\n              '2000-01-02 01:01', '2000-01-03']],\n            [['2000-01-01', '2000-01-02 01:00', '2000-01-02', '2000-01-02', '2000-01-02 01:01',\n              '2000-01-02 02:00', '2000-01-03']],\n            id='reorder one'),\n        pytest.param(\n            [['2000-01-05', '2000-01-04', '2000-01-03', '2000-01-02', '2000-01-01']],\n            [['2000-01-01', '2000-01-02', '2000-01-03', '2000-01-04', '2000-01-05']],\n            id='reversed',\n        ),\n        pytest.param(\n            [['2000-01-02', '2000-01-03'], ['2000-01-01', '2000-01-02 01:00']],\n            [['2000-01-01', '2000-01-02 01:00'], ['2000-01-02', '2000-01-03']],\n            id='reorder whole block',\n        ),\n        pytest.param(\n            [['2000-02-02', '2000-02-01'], [_PUSHTAG], ['2000-01-02', '2000-01-01']],\n            [['2000-02-01', '2000-02-02'], [_PUSHTAG], ['2000-01-01', '2000-01-02']],\n            id='no cross compartment',\n        ),\n        pytest.param(\n            [['2000-01-04'], ['2000-01-02'], [_INCLUDE], ['2000-01-03'], ['2000-01-01']],\n            [['2000-01-01'], ['2000-01-02'], [_INCLUDE], ['2000-01-03'], ['2000-01-04']],\n            id='retain undated directives'\n        ),\n        pytest.param(\n            [['2000-01-01', '2000-01-01', '2000-01-03', '2000-01-05'], ['2000-01-02', '2000-01-04', '2000-01-04', '2000-01-06', '2000-01-07']],\n            [['2000-01-01', '2000-01-01'], ['2000-01-02'], ['2000-01-03'], ['2000-01-04', '2000-01-04'], ['2000-01-05'], ['2000-01-06', '2000-01-07']],\n            id='split blocks',\n        ),\n        pytest.param(\n            [['2000-01-02', '2000-01-01'], ['2000-01-03', '2000-01-02']],\n            [['2000-01-01', '2000-01-02'], ['2000-01-02', '2000-01-03']],\n            id='keep blocks',\n        ),\n        pytest.param(\n            [['2000-01-01', '2000-01-01 02:00', '2000-01-01', '2000-01-01 08:00', '2000-01-01', '2000-01-01 04:00', '2000-01-01']],\n            [['2000-01-01', '2000-01-01 02:00', '2000-01-01', '2000-01-01', '2000-01-01 04:00', '2000-01-01', '2000-01-01 08:00']],\n            id='reorder with optional time',\n        ),\n        pytest.param(\n            [['2000-01-01 08:00', '2000-01-01 07:00:00', '2000-01-01 946706400', '2000-01-01 946702800000', '2000-01-01 946699200000000']],\n            [['2000-01-01 946699200000000', '2000-01-01 946702800000', '2000-01-01 946706400', '2000-01-01 07:00:00', '2000-01-01 08:00']],\n            id='distinct time units',\n        ),\n        pytest.param(\n            [['2000-01-02'], ['2000-01-02'], ['2000-01-01'], ['2000-01-01']],\n            [['2000-01-01'], ['2000-01-01'], ['2000-01-02'], ['2000-01-02']],\n            id='same sort key',\n        ),\n        pytest.param(\n            [['2000-01-01'], ['2000-01-04'], [_INCLUDE], ['2000-01-02'], ['2000-01-03']],\n            [['2000-01-01'], [_INCLUDE], ['2000-01-02'], ['2000-01-03'], ['2000-01-04']],\n            id='undated ambiguous in LIS',\n        ),\n        pytest.param(\n            [['2000-01-01'], ['2000-01-02 03:00'], ['2000-01-02'], ['2000-01-02'], ['2000-01-02 01:00'], ['2000-01-02 02:00']],\n            [['2000-01-01'], ['2000-01-02'], ['2000-01-02'], ['2000-01-02 01:00'], ['2000-01-02 02:00'], ['2000-01-02 03:00']],\n            id='untimed ambiguous in LIS',\n        ),\n    ])\n    def test_sort_blocks(self, blocks: list[_TestBlock], sorted_blocks: Optional[list[_TestBlock]]) -> None:\n        if sorted_blocks is None:\n            sorted_blocks = blocks\n        assert unbuild_blocks(sorting.sort_blocks(build_blocks(blocks))) == sorted_blocks", ""]}
{"filename": "autobean_format/tests/base.py", "chunked_list": ["import io\nfrom typing import Optional, Type\nfrom autobean_refactor import models, parser as parser_lib\nfrom autobean_format import formatter, options_lib\nimport pytest\n\n\nDEFAULT_OPTIONS = options_lib.Options(\n    indent='    ',\n    currency_column=80,", "    indent='    ',\n    currency_column=80,\n    cost_column=85,\n    output_mode=options_lib.OutputMode.STDOUT,\n    thousands_separator=options_lib.ThousandsSeparator.KEEP,\n    spaces_in_braces=False,\n    sort=False,\n    recursive=False,\n)\n", ")\n\n\nclass BaseTest:\n    @pytest.fixture(autouse=True)\n    def _setup_parser(self, parser: parser_lib.Parser) -> None:\n        self.parser = parser\n\n    def _format(self, model: models.RawModel, options: options_lib.Options, *, indent: int) -> str:\n        stream = io.StringIO()\n        formatter.format(model, self.parser, options, stream, indent=indent)\n        return stream.getvalue()\n\n    def format(\n        self,\n        text: str,\n        model_type: Type[models.RawTreeModel],\n        options: Optional[options_lib.Options] = None,\n        indent: int = 0,\n    ) -> str:\n        model = self.parser.parse(text, model_type)\n        model.auto_claim_comments()\n        return self._format(model, options or DEFAULT_OPTIONS, indent=indent)\n\n    def format_token(\n        self,\n        text: str,\n        model_type: Type[models.RawTokenModel],\n        options: Optional[options_lib.Options] = None,\n    ) -> str:\n        model = self.parser.parse_token(text, model_type)\n        return self._format(model, options or DEFAULT_OPTIONS, indent=0)", ""]}
{"filename": "autobean_format/tests/tokens_test.py", "chunked_list": ["from typing import Type\nfrom autobean_refactor import models\nimport pytest\nfrom . import base\n\n\nclass TestToken(base.BaseTest):\n\n    @pytest.mark.parametrize('model_type,src,expected', [\n        pytest.param(\n            models.InlineComment, ';!foo', '; !foo',\n            id='inline_comment',\n        ),\n        pytest.param(\n            models.InlineComment, ';!foo;bar', '; !foo;bar',\n            id='inline_comment and semicolon',\n        ),\n        pytest.param(\n            models.InlineComment, ';', ';',\n            id='inline_comment_empty',\n        ),\n        pytest.param(\n            models.InlineComment, ';;foo', ';; foo',\n            id='autobean.narration',\n        ),\n        pytest.param(\n            models.InlineComment, ';;', ';;',\n            id='empty autobean.narration',\n        ),\n        pytest.param(\n            models.InlineComment, ';;;', ';; ;',\n            id='empty autobean.narration and empty comment',\n        ),\n        pytest.param(\n            models.InlineComment, ';;;;;', ';; ; ;;',\n            id='empty autobean.narration and semicolons',\n        ),\n        pytest.param(\n            models.InlineComment, ';;foo;bar;baz', ';; foo ; bar;baz',\n            id='autobean.narration and comment',\n        ),\n    ])\n    def test_token(self, model_type: Type[models.RawTokenModel], src: str, expected: str) -> None:\n        assert self.format_token(src, model_type) == expected", ""]}
{"filename": "autobean_format/tests/file_test.py", "chunked_list": ["from autobean_refactor import models\nimport pytest\nfrom . import base\n\n\nclass TestFile(base.BaseTest):\n\n    @pytest.mark.parametrize('src,expected', [\n        pytest.param(\n            '', '',\n            id='empty',\n        ),\n        pytest.param(\n            'include \"foo.bean\"',\n            'include \"foo.bean\"\\n',\n            id='trailing_newline_add',\n        ),\n        pytest.param(\n            'include \"foo.bean\"\\n',\n            'include \"foo.bean\"\\n',\n            id='trailing_newline_existing',\n        ),\n        pytest.param(\n            'include \"foo.bean\"\\n\\n\\n\\n\\n\\ninclude \"bar.bean\"\\n\\n\\n\\n\\n',\n            'include \"foo.bean\"\\n\\ninclude \"bar.bean\"\\n',\n            id='remove_blank_lines',\n        ),\n        pytest.param(\n            'include \"foo.bean\"\\n\\n; xxx\\n\\ninclude \"bar.bean\"\\n',\n            'include \"foo.bean\"\\n\\n; xxx\\n\\ninclude \"bar.bean\"\\n',\n            id='block_comment',\n        ),\n        pytest.param(\n            'include \"foo.bean\"\\n\\n    ; xxx\\n  ; yy\\n\\ninclude \"bar.bean\"\\n',\n            'include \"foo.bean\"\\n\\n; xxx\\n; yy\\n\\ninclude \"bar.bean\"\\n',\n            id='block_comment_dedent',\n        ),\n        pytest.param(\n            'include \"foo.bean\"\\n; xxx\\ninclude \"bar.bean\"\\n; yyy\\n',\n            'include \"foo.bean\"\\n; xxx\\ninclude \"bar.bean\"\\n; yyy\\n',\n            id='surrounding_comment',\n        ),\n        pytest.param(\n            'include \"foo.bean\"\\n*xxx\\ninclude \"bar.bean\"\\n',\n            'include \"foo.bean\"\\n\\n*xxx\\n\\ninclude \"bar.bean\"\\n',\n            id='add_blank_lines',\n        ),\n        pytest.param(\n            'include \"foo.bean\"\\n*xxx\\n',\n            'include \"foo.bean\"\\n\\n*xxx\\n',\n            id='add_blank_lines_last',\n        ),\n        pytest.param(\n            'include \"foo.bean\"\\nplugin \"foo\"\\n',\n            'include \"foo.bean\"\\nplugin \"foo\"\\n',\n            id='no_blank_lines_same_category',\n        ),\n        pytest.param(\n            'include \"foo.bean\"\\npushtag #foo\\n',\n            'include \"foo.bean\"\\n\\npushtag #foo\\n',\n            id='add_blank_lines_different_category',\n        ),\n        pytest.param(\n            '2000-01-01 open Assets:Foo\\n2000-01-01 pad Assets:Foo Equity:Opening-Balances\\n2000-01-02 balance Assets:Foo                                            100.00 USD\\n',\n            '2000-01-01 open Assets:Foo\\n2000-01-01 pad Assets:Foo Equity:Opening-Balances\\n2000-01-02 balance Assets:Foo                                            100.00 USD\\n',\n            id='open_pad_balance_together',\n        ),\n    ])\n    def test_file(self, src: str, expected: str) -> None:\n        assert self.format(src, models.File) == expected  ", ""]}
{"filename": "autobean_format/tests/__init__.py", "chunked_list": [""]}
{"filename": "autobean_format/tests/posting_test.py", "chunked_list": ["from autobean_refactor import models\nimport pytest\nfrom . import base\n\n\nclass TestPosting(base.BaseTest):\n\n    @pytest.mark.parametrize('src,expected', [\n        pytest.param(\n            '    Assets:Foo   1.23  USD  ',\n            '    Assets:Foo                                                             1.23 USD',\n            id='simple',\n        ),\n        pytest.param(\n            '    Assets:Foo       ',\n            '    Assets:Foo',\n            id='no_amount',\n        ),\n        pytest.param(\n            '    Assets:Foo   USD     ',\n            '    Assets:Foo                                                                  USD',\n            id='currency_only',\n        ),\n        pytest.param(\n            '    Assets:Foo   1.23     ',\n            '    Assets:Foo                                                             1.23',\n            id='number_only',\n        ),\n        pytest.param(\n            '    Assets:Foo   1.00  GBP  @@  1.23  USD  ',\n            '    Assets:Foo                                                             1.00 GBP  @@ 1.23 USD',\n            id='price_explicit',\n        ),\n        pytest.param(\n            '    Assets:Foo   1.00  GBP  @@  ',\n            '    Assets:Foo                                                             1.00 GBP  @@',\n            id='price_implicit',\n        ),\n        pytest.param(\n            '    Assets:Foo   @@',\n            '    Assets:Foo                                                                       @@',\n            id='price_no_amount',\n        ),\n        pytest.param(\n            '    Assets:Foo  1.00 GBP   {1.23 USD}   @ 1.23 USD  ',\n            '    Assets:Foo                                                             1.00 GBP  {1.23 USD} @ 1.23 USD',\n            id='cost_and_price',\n        ),\n        pytest.param(\n            '    Assets:Foo  1.00 GBP   {}   ',\n            '    Assets:Foo                                                             1.00 GBP  {}',\n            id='cost_implicit',\n        ),\n        pytest.param(\n            '    Assets:Foo  {}   ',\n            '    Assets:Foo                                                                       {}',\n            id='cost_no_amount',\n        ),\n    ])\n    def test_posting(self, src: str, expected: str) -> None:\n        assert self.format(src, models.Posting, indent=1) == expected", ""]}
{"filename": "autobean_format/tests/price_test.py", "chunked_list": ["from autobean_refactor import models\nimport pytest\nfrom . import base\n\n\nclass TestPrice(base.BaseTest):\n\n    @pytest.mark.parametrize('src,expected', [\n        pytest.param(\n            '2000-01-01      price\\tGBP  1.23   USD',\n            '2000-01-01 price GBP                                                       1.23 USD',\n            id='simple',\n        ),\n        pytest.param(\n            '; aaa\\n2000-01-01      price\\tGBP  1.23   USD  ; xxx\\n; bbb',\n            '; aaa\\n2000-01-01 price GBP                                                       1.23 USD ; xxx\\n; bbb',\n            id='comment',\n        ),\n        pytest.param(\n            '2000-01-01 price GBPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP   1.23   USD',\n            '2000-01-01 price GBPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 1.23 USD',\n            id='no_align_currency_long_currency',\n        ),\n    ])\n    def test_price(self, src: str, expected: str) -> None:\n        assert self.format(src, models.Price) == expected  ", ""]}
{"filename": "autobean_format/tests/number_test.py", "chunked_list": ["import dataclasses\nfrom autobean_refactor import models\nimport pytest\nfrom .. import options_lib\nfrom . import base\n\n\nclass TestNumber(base.BaseTest):\n\n    @pytest.mark.parametrize('src,expected,mode', [\n        ('1234567890.0987654321', '1234567890.0987654321', 'keep'),\n        ('1,234,567,890.0987654321', '1,234,567,890.0987654321', 'keep'),\n        ('1234567890.0987654321', '1,234,567,890.0987654321', 'add'),\n        ('1234567890.0987654321', '1234567890.0987654321', 'remove'),\n        ('1,234,567,890.0987654321', '1234567890.0987654321', 'remove'),\n    ])\n    def test_thousands_separator(self, src: str, expected: str, mode: str) -> None:\n        options = dataclasses.replace(\n            base.DEFAULT_OPTIONS,\n            thousands_separator=options_lib.ThousandsSeparator(mode))\n        assert self.format_token(src, models.Number, options) == expected", ""]}
{"filename": "autobean_format/tests/cost_test.py", "chunked_list": ["import dataclasses\nfrom typing import Type\nfrom autobean_refactor import models\nimport pytest\nfrom . import base\n\n\nclass TestCost(base.BaseTest):\n\n    @pytest.mark.parametrize('src,expected,model_type', [\n        ('  {  }  ', '{}', models.UnitCost),\n        ('  {1.00USD   }  ', '{1.00 USD}', models.UnitCost),\n        ('  {{1.00      USD}}  ', '{{1.00 USD}}', models.TotalCost),\n        ('  {{1.00      USD  ,   2000-01-01}}  ', '{{1.00 USD, 2000-01-01}}', models.TotalCost),\n    ])\n    def test_cost(self, src: str, expected: str, model_type: Type[models.UnitCost | models.TotalCost]) -> None:\n        assert self.format(src, model_type) == expected\n\n    @pytest.mark.parametrize('src,expected,model_type', [\n        ('  {  }  ', '{}', models.UnitCost),\n        ('  {1.00USD}  ', '{ 1.00 USD }', models.UnitCost),\n        ('  {{1.00      USD}}  ', '{{ 1.00 USD }}', models.TotalCost),\n        ('  {{1.00      USD  ,   2000-01-01}}  ', '{{ 1.00 USD, 2000-01-01 }}', models.TotalCost),\n    ])\n    def test_spaces_in_braces(self, src: str, expected: str, model_type: Type[models.UnitCost | models.TotalCost]) -> None:\n        options = dataclasses.replace(base.DEFAULT_OPTIONS, spaces_in_braces=True)\n        assert self.format(src, model_type, options) == expected", ""]}
{"filename": "autobean_format/tests/conftest.py", "chunked_list": ["from autobean_refactor import parser as parser_lib\nimport pytest\n\n\n@pytest.fixture(scope='package')\ndef parser() -> parser_lib.Parser:\n    return parser_lib.Parser()\n"]}
{"filename": "autobean_format/tests/balance_test.py", "chunked_list": ["from autobean_refactor import models\nimport pytest\nfrom . import base\n\n\nclass TestBalance(base.BaseTest):\n\n    @pytest.mark.parametrize('src,expected', [\n        pytest.param(\n            '2000-01-01      balance\\tAssets:Foo  1.23   USD',\n            '2000-01-01 balance Assets:Foo                                              1.23 USD',\n            id='simple',\n        ),\n        pytest.param(\n            '2000-01-01      balance\\tAssets:Foo  1.23  ~   0.00   USD',\n            '2000-01-01 balance Assets:Foo                                       1.23 ~ 0.00 USD',\n            id='tolerance',\n        ),\n        pytest.param(\n            '2000-01-01      balance\\tAssets:Foo  (1.23  *   0.00)   USD',\n            '2000-01-01 balance Assets:Foo                                     (1.23 * 0.00) USD',\n            id='expr',\n        ),\n        pytest.param(\n            '; aaa\\n2000-01-01      balance\\tAssets:Foo  1.23   USD  ; xxx\\n; bbb',\n            '; aaa\\n2000-01-01 balance Assets:Foo                                              1.23 USD ; xxx\\n; bbb',\n            id='comment',\n        ),\n        pytest.param(\n            '2000-01-01 balance Assets:Foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo   1.23   USD',\n            '2000-01-01 balance Assets:Foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo 1.23 USD',\n            id='no_align_currency_long_account',\n        ),\n    ])\n    def test_balance(self, src: str, expected: str) -> None:\n        assert self.format(src, models.Balance) == expected  ", ""]}
{"filename": "autobean_format/tests/open_test.py", "chunked_list": ["from autobean_refactor import models\nimport pytest\nfrom . import base\n\n\nclass TestOpen(base.BaseTest):\n\n    @pytest.mark.parametrize('src,expected', [\n        pytest.param(\n            '2000-01-01      open\\tAssets:Foo  ',\n            '2000-01-01 open Assets:Foo',\n            id='simple',\n        ),\n        pytest.param(\n            '; aaa\\n2000-01-01      open\\tAssets:Foo  ; xxx\\n; bbb',\n            '; aaa\\n2000-01-01 open Assets:Foo ; xxx\\n; bbb',\n            id='comment',\n        ),\n        pytest.param(\n            '2000-01-01 open Assets:Foo   USD,GBP,  EUR',\n            '2000-01-01 open Assets:Foo                                                      USD, GBP, EUR',\n            id='align_currency',\n        ),\n        pytest.param(\n            '2000-01-01 open Assets:Foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo   USD,GBP,  EUR',\n            '2000-01-01 open Assets:Foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo USD, GBP, EUR',\n            id='no_align_currency_long_account',\n        ),\n        pytest.param(\n            '2000-01-01 open Assets:Foo\\n    foo: USD',\n            '2000-01-01 open Assets:Foo\\n    foo: USD',\n            id='no_align_meta_currency',\n        ),\n    ])\n    def test_open(self, src: str, expected: str) -> None:\n        assert self.format(src, models.Open) == expected  ", ""]}
{"filename": "autobean_format/internal/iterating.py", "chunked_list": ["from typing import Callable, Iterable, Iterator, Optional, TypeVar\n\n_V = TypeVar('_V')\n\n\nclass BufferedIterator(Iterator[_V]):\n    def __init__(self, iterable: Iterable[_V]) -> None:\n        self._iterator = iter(iterable)\n        self._buffer = list[_V]()\n\n    def __iter__(self) -> Iterator[_V]:\n        return self\n\n    def __next__(self) -> _V:\n        if self._buffer:\n            return self._buffer.pop(0)\n        return next(self._iterator)\n\n    def _push(self, item: _V) -> None:\n        self._buffer.append(item)\n\n    def take_until(self, predicate: Callable[[_V], bool]) -> Iterator[_V]:\n        for item in self:\n            if predicate(item):\n                self._push(item)\n                return\n            yield item\n\n    def take_until_inclusive(self, predicate: Callable[[_V], bool]) -> Iterator[_V]:\n        for item in self:\n            yield item\n            if predicate(item):\n                return", ""]}
{"filename": "autobean_format/internal/chrono.py", "chunked_list": ["import datetime\nimport decimal\nfrom typing import Optional\n\n\ndef _try_parse_time(time: str, format: str) -> Optional[datetime.time]:\n    try:\n        return datetime.datetime.strptime(time, format).time()\n    except ValueError:\n        return None", "\n\ndef try_normalize_timestring(date: datetime.date, s: str) -> Optional[int]:\n    \"\"\"Attempts to normalize time string into unix timestamp in microseconds.\"\"\"\n    time = _try_parse_time(s, '%H:%M:%S') or _try_parse_time(s, '%H:%M')\n    if time is None:\n        return None\n    dt = datetime.datetime.combine(date, time, tzinfo=datetime.timezone.utc)\n    return int(dt.timestamp() * 1000 * 1000)\n", "\n\ndef try_normalize_timestamp(timestamp: decimal.Decimal) -> Optional[int]:\n    \"\"\"Attempts to normalize timestamp into unix timestamp in microseconds.\"\"\"\n    if timestamp < 10 ** 8:\n        return None\n    elif timestamp < 10 ** 10:\n        return int(timestamp * 1000 * 1000)\n    elif timestamp < 10 ** 13:\n        return int(timestamp * 1000)\n    elif timestamp < 10 ** 16:\n        return int(timestamp)\n    else:\n        return None", ""]}
{"filename": "autobean_format/internal/__init__.py", "chunked_list": [""]}
{"filename": "autobean_format/internal/alignment.py", "chunked_list": ["from typing import Optional\nfrom autobean_refactor import models\n\n\ndef get_padding_align_left(model: models.RawModel, column: int) -> Optional[str]:\n    assert model.token_store\n    length = column - model.token_store.get_position(model.first_token).column\n    if length <= 0:\n        return None\n    return ' ' * length", "\n\ndef get_padding_align_right(model: models.RawModel, column: int) -> Optional[str]:\n    assert model.token_store\n    next_token = model.token_store.get_next(model.last_token)\n    assert next_token\n    length = column - model.token_store.get_position(next_token).column\n    if length <= 0:\n        return None\n    return ' ' * length", ""]}
{"filename": "autobean_format/internal/sorting.py", "chunked_list": ["\"\"\"Sorts entities in a less disruptive way.\n\n## Problems\n\nSorting beancount entities may sound as simple as `sorted(entities)` but doing it properly isn't trivial.\n\n* Establishing total order may not be possible.\n  * There may be undated entities (e.g. `include`)\n  * Ideally we also sort by time if specified in meta. But they may not be consistently specified.\n* Swapping entries inside and outside a pushtag / pushmeta block is not allowed.", "  * Ideally we also sort by time if specified in meta. But they may not be consistently specified.\n* Swapping entries inside and outside a pushtag / pushmeta block is not allowed.\n* Ideally we would like to reorder as few entities as possible.\n* Ideally we would like to keep the original block structure.\n\n## Solution\n\nIn order to not disrupt existing formatting, we make the assumption that the majority of the file is already sorted\nand only a few entities need to be reordered. This assumption may not be true for all files, but when it isn't, we\nreally don't know how to best preserve the existing formatting.", "and only a few entities need to be reordered. This assumption may not be true for all files, but when it isn't, we\nreally don't know how to best preserve the existing formatting.\n\nThe sorting process is:\n\n1. Partition the file into blocks based on surrounding blank lines and entities types (pushpop / undated / dated).\n  1. For each dated block, sort entities with prudent sort.\n1. Partition the blocks into compartments of blocks, split by pushpop blocks.\n1. For each compartment:\n  1. Sort blocks with prudent sort.", "1. For each compartment:\n  1. Sort blocks with prudent sort.\n\nThe prudent sort process is:\n\n1. Identify the longest non-decreasing subsequence of entities and split out the rest.\n1. Sort the rest with simple sort by dicating a total order.\n1. Merge the sorted rest into the non-decreasing subsequence.\n  * When merging blocks, this may involve split some blocks when necessary.\n", "  * When merging blocks, this may involve split some blocks when necessary.\n\n## Alternatives\n\nInstead of sorting each compartment separately, we could allow swapping entities before `pushtag #foo` and after\n`poptag #foo`, but we don't do it as it may be over-complexing due to possibly interleaving pushes.\n\nInstead of sorting out-of-order entities with simple sort, we could recurse with the same method, but we don't do it\nas it may be over-complexing and degraded performance.\n\"\"\"", "as it may be over-complexing and degraded performance.\n\"\"\"\n\nimport abc\nimport bisect\nimport decimal\nimport functools\nimport heapq\nimport itertools\nfrom typing import TYPE_CHECKING, Any, Generic, Iterable, Iterator, Optional, Self, Sequence, TypeAlias, TypeVar, cast, get_args", "import itertools\nfrom typing import TYPE_CHECKING, Any, Generic, Iterable, Iterator, Optional, Self, Sequence, TypeAlias, TypeVar, cast, get_args\n\nfrom autobean_refactor import models\nfrom . import chrono\nif TYPE_CHECKING:\n    from _typeshed import SupportsDunderLT, SupportsDunderGT\n\n_T = TypeVar('_T')\n_O = TypeVar('_O', bound='_Ordered')", "_T = TypeVar('_T')\n_O = TypeVar('_O', bound='_Ordered')\n_Entry: TypeAlias = models.Balance | models.Open | models.Close | models.Commodity | models.Pad | models.Event | models.Query | models.Price | models.Note | models.Document | models.Custom | models.Transaction\n_CompartmentSplitter: TypeAlias = models.Pushtag | models.Poptag | models.Pushmeta | models.Popmeta | models.BlockComment\n_TopLevelEntitiy = models.Directive | models.BlockComment\n\n\nclass _Ordered(Generic[_T], abc.ABC):\n\n    def __init__(self, value: _T) -> None:\n        self.value = value\n\n    # Note: a.more_successor_permissive_than(b) may not imply !(b.can_go_before(a))\n    @abc.abstractmethod\n    def more_successor_permissive_than(self, other: Self) -> bool:\n        \"\"\"Tests if successors permitted by this entity forms a proper superset of those permitted by the other entity.\"\"\"\n\n    # Note: may not be transitive\n    @abc.abstractmethod\n    def can_go_before(self, other: Self) -> bool:\n        \"\"\"Tests if this entity can go before the other entity.\"\"\"\n\n    @classmethod\n    @abc.abstractmethod\n    def min(cls, a: Self, b: Self) -> Self:\n        \"\"\"An associative function to summarize the lower bound for can_go_before.\n        \n        Formally:\n        forall x: x.can_go_before(a) && x.can_go_before(b) <=> x.can_go_before(min(a, b))\n        \"\"\"\n\n    @classmethod\n    @abc.abstractmethod\n    def max(cls, a: Self, b: Self) -> Self:\n        \"\"\"An associative function to summarize the upper bound for can_go_before.\n\n        Formally:\n        forall x: a.can_go_before(x) && b.can_go_before(x) <=> max(a, b).can_go_before(x)\n        \"\"\"\n\n    @classmethod\n    @abc.abstractmethod\n    def merge(cls, sorted: list[Self], unsorted: list[Self]) -> Iterable[Self]:\n        \"\"\"Merges a sorted list with an unsorted list into a sorted list.\n\n        The original order of `sorted` must be preserved.\n        \"\"\"\n\n    @classmethod\n    def sort(cls, values: list[Self]) -> list[Self]:\n        if _is_ordered(values):\n            return values\n        sorted, unsorted = _split_sorted_unsorted(values)\n        return list(cls.merge(sorted, unsorted))", "\n\ndef _is_ordered(entities: Sequence[_Ordered[_T]]) -> bool:\n    if not entities:\n        return True\n    it = iter(entities)\n    running_max = next(it)\n    for entity in it:\n        if not running_max.can_go_before(entity):\n            return False\n        running_max = running_max.max(running_max, entity)\n    return True", "\n\ndef _split_sorted_unsorted(\n    entities: Sequence[_O],\n) -> tuple[list[_O], list[_O]]:\n    # (running max index, entity index) -> (prev running max index, prev entity index)\n    p = dict[tuple[int, int], tuple[int, int]]()\n    m = list[tuple[int, int]]()  # length -> (running max index, last entity index)\n\n    for i, entity in enumerate(entities):\n        # first element we cannot go after\n        j = bisect.bisect_left(m, True, key=lambda item: not entities[item[0]].can_go_before(entity))\n        while j >= 0 and (j == len(m) or entity.more_successor_permissive_than(entities[m[j][0]])):\n            running_max = i\n            if j:\n                if entity.max(entity, entities[m[j - 1][0]]) is not entity:\n                    running_max = m[j - 1][0]\n                p[(running_max, i)] = m[j - 1]\n            m[j:j+1] = [(running_max, i)]\n            j -= 1\n        \n    last = m[-1] if m else None\n    sorted_i, sorted, unsorted = [], [], []\n    while last:\n        sorted_i.append(last[1])\n        last = p.get(last)\n    sorted_i.reverse()\n\n    sorted = [entities[i] for i in sorted_i]\n    j = 0\n    for i in range(len(entities)):\n        if j < len(sorted_i) and i == sorted_i[j]:\n            j += 1\n        else:\n            unsorted.append(entities[i])\n\n    return sorted, unsorted", "\n\ndef _get_entry_time(entry: _Entry) -> int | None:\n    time = entry.meta.get('time')\n    if isinstance(time, str):\n        return chrono.try_normalize_timestring(entry.date, time)\n    elif isinstance(time, decimal.Decimal):\n        return chrono.try_normalize_timestamp(time)\n    else:\n        return None", "\n\ndef _build_reversed_running_min(entities: Sequence[_O]) -> list[_O]:\n    reversed_running_min = list(entities)\n    for i in reversed(range(len(reversed_running_min) - 1)):\n        reversed_running_min[i] = reversed_running_min[i].min(\n            reversed_running_min[i], reversed_running_min[i + 1])\n    return reversed_running_min\n\n\ndef _merge_entries(sorted: Sequence['_OrderedEntry'], unsorted: Sequence['_OrderedEntry']) -> Iterator[Sequence['_OrderedEntry']]:\n    cursor_sorted, cursor_unsorted = 0, 0\n    reversed_running_min_unsorted = _build_reversed_running_min(unsorted)\n    while cursor_sorted < len(sorted) and cursor_unsorted < len(unsorted):\n        prev_cursor_sorted = cursor_sorted\n        while cursor_sorted < len(sorted) and sorted[cursor_sorted].can_go_before(reversed_running_min_unsorted[cursor_unsorted]):\n            cursor_sorted += 1\n        if cursor_sorted > prev_cursor_sorted:\n            yield sorted[prev_cursor_sorted:cursor_sorted]\n        if cursor_sorted == len(sorted):\n            break\n        prev_cursor_unsorted = cursor_unsorted\n        while cursor_unsorted < len(unsorted) and not sorted[cursor_sorted].can_go_before(reversed_running_min_unsorted[cursor_unsorted]):\n            cursor_unsorted += 1\n        yield unsorted[prev_cursor_unsorted:cursor_unsorted]\n    if cursor_sorted < len(sorted):\n        yield sorted[cursor_sorted:]\n    if cursor_unsorted < len(unsorted):\n        yield unsorted[cursor_unsorted:]", "\n\ndef _merge_entries(sorted: Sequence['_OrderedEntry'], unsorted: Sequence['_OrderedEntry']) -> Iterator[Sequence['_OrderedEntry']]:\n    cursor_sorted, cursor_unsorted = 0, 0\n    reversed_running_min_unsorted = _build_reversed_running_min(unsorted)\n    while cursor_sorted < len(sorted) and cursor_unsorted < len(unsorted):\n        prev_cursor_sorted = cursor_sorted\n        while cursor_sorted < len(sorted) and sorted[cursor_sorted].can_go_before(reversed_running_min_unsorted[cursor_unsorted]):\n            cursor_sorted += 1\n        if cursor_sorted > prev_cursor_sorted:\n            yield sorted[prev_cursor_sorted:cursor_sorted]\n        if cursor_sorted == len(sorted):\n            break\n        prev_cursor_unsorted = cursor_unsorted\n        while cursor_unsorted < len(unsorted) and not sorted[cursor_sorted].can_go_before(reversed_running_min_unsorted[cursor_unsorted]):\n            cursor_unsorted += 1\n        yield unsorted[prev_cursor_unsorted:cursor_unsorted]\n    if cursor_sorted < len(sorted):\n        yield sorted[cursor_sorted:]\n    if cursor_unsorted < len(unsorted):\n        yield unsorted[cursor_unsorted:]", "\n\nclass _OrderedEntry(_Ordered[_Entry]):\n\n    def __init__(self, entry: _Entry) -> None:\n        super().__init__(entry)\n        self.date = entry.date\n        self.time = _get_entry_time(entry)\n\n    def more_successor_permissive_than(self, other: Self) -> bool:\n        return self.date < other.date or (self.date == other.date and (\n            self.time is None and other.time is not None or\n            self.time is not None and other.time is not None and self.time < other.time))\n\n    def can_go_before(self, other: Self) -> bool:\n        return self.date < other.date or (self.date == other.date and (\n            self.time is None or other.time is None or self.time <= other.time))\n\n    @classmethod\n    def min(cls, a: Self, b: Self) -> Self:\n        if a.date < b.date or (a.date == b.date and (\n                b.time is None or (a.time is not None and a.time < b.time))):\n            return a\n        return b\n\n    @classmethod\n    def max(cls, a: Self, b: Self) -> Self:\n        if a.date < b.date or (a.date == b.date and (\n                a.time is None or (b.time is not None and a.time < b.time))):\n            return b\n        return a\n\n    def simple_sort_key(self) -> Any:\n        return (self.date, self.time or 0)\n\n    @classmethod\n    def merge(cls, sorted: list['_OrderedEntry'], unsorted: list['_OrderedEntry']) -> Iterator['_OrderedEntry']:\n        unsorted.sort(key=lambda x: x.simple_sort_key())\n        return itertools.chain.from_iterable(_merge_entries(sorted, unsorted))", "\n\n_Block = Sequence[_OrderedEntry] | Sequence[_TopLevelEntitiy]\n\n\nclass _OrderedBlock(_Ordered[_Block]):\n\n    def __init__(self, block: _Block) -> None:\n        super().__init__(block)\n        self.entries = cast(Sequence[_OrderedEntry], block) if isinstance(block[0], _OrderedEntry) else None\n\n    @classmethod\n    def from_raw_block(cls, block: Sequence[_TopLevelEntitiy]) -> Self:\n        if isinstance(block[0], get_args(_Entry)):\n            return cls(_OrderedEntry.sort([\n                _OrderedEntry(entry) for entry in cast(list[_Entry], block)]))\n        else:\n            return cls(block)\n\n    @functools.cached_property\n    def _max(self) -> Optional['_OrderedEntry']:\n        if not self.entries:\n            return None\n        return functools.reduce(_OrderedEntry.max, self.entries)\n\n    @functools.cached_property\n    def _min(self) -> Optional['_OrderedEntry']:\n        if not self.entries:\n            return None\n        return functools.reduce(_OrderedEntry.min, self.entries)\n\n    @classmethod\n    def min(cls, a: Self, b: Self) -> Self:\n        if (not b._min or (a._min and _OrderedEntry.min(a._min, b._min) is a._min)):\n            return a\n        return b\n\n    @classmethod\n    def max(cls, a: Self, b: Self) -> Self:\n        if (not a._max or (b._max and _OrderedEntry.max(a._max, b._max) is b._max)):\n            return b\n        return a\n\n    def more_successor_permissive_than(self, other: Self) -> bool:\n        return bool(\n            not self._max and other._max or  # undated is more permissive than dated\n            self._max and other._max and self._max.more_successor_permissive_than(other._max)\n        )\n\n    def can_go_before(self, other: Self) -> bool:\n        return bool(not self._max or not other._min or self._max.can_go_before(other._min))\n\n    def simple_sort_key(self) -> Any:\n        assert self._min and self._max  # undated blocks must be part of sorted\n        return (self._min.simple_sort_key(), self._max.simple_sort_key())\n\n    @classmethod\n    def merge(cls, sorted: list['_OrderedBlock'], unsorted: list['_OrderedBlock']) -> Iterator['_OrderedBlock']:\n        keyed_unsorted = [(block.simple_sort_key(), i, block) for i, block in enumerate(unsorted)]\n        heapq.heapify(keyed_unsorted)\n        cursor_sorted = 0\n        while cursor_sorted < len(sorted) and keyed_unsorted:\n            if sorted[cursor_sorted].can_go_before(keyed_unsorted[0][2]):\n                yield sorted[cursor_sorted]\n                cursor_sorted += 1\n            elif keyed_unsorted[0][2].can_go_before(sorted[cursor_sorted]):\n                yield heapq.heappop(keyed_unsorted)[2]\n            else:\n                sorted_head_entries = sorted[cursor_sorted].entries\n                cursor_sorted += 1\n                unsorted_block = heapq.heappop(keyed_unsorted)\n                unsorted_head_entries = unsorted_block[2].entries\n                assert sorted_head_entries is not None\n                assert unsorted_head_entries is not None\n                split_blocks = _merge_entries(sorted_head_entries, unsorted_head_entries)\n                for block in split_blocks:\n                    ordered_block = _OrderedBlock(block)\n                    heapq.heappush(keyed_unsorted, (ordered_block.simple_sort_key(), unsorted_block[1], ordered_block))\n        if cursor_sorted < len(sorted):\n            yield from sorted[cursor_sorted:]\n        while keyed_unsorted:\n            yield heapq.heappop(keyed_unsorted)[2]", "\n\ndef _sort_compartment(blocks: list[_OrderedBlock]) -> list[Sequence[_TopLevelEntitiy]]:\n    blocks = _OrderedBlock.sort(blocks)\n\n    sorted_blocks = list[Sequence[_TopLevelEntitiy]]()\n    for ordered_block in blocks:\n        if ordered_block.entries is not None:\n            sorted_blocks.append([entry.value for entry in ordered_block.entries])\n        else:\n            sorted_blocks.append(cast(Sequence[_TopLevelEntitiy], ordered_block.value))\n    return sorted_blocks", "\n\ndef sort_blocks(blocks: Iterable[Sequence[_TopLevelEntitiy]]) -> list[Sequence[_TopLevelEntitiy]]:\n    results = []\n    compartment = list[_OrderedBlock]()\n    for block in blocks:\n        if isinstance(block[0], get_args(_CompartmentSplitter)):\n            results.extend(_sort_compartment(compartment))\n            compartment.clear()\n            results.append(block)\n        else:\n            compartment.append(_OrderedBlock.from_raw_block(block))\n    if compartment:\n        results.extend(_sort_compartment(compartment))\n    return results", ""]}
