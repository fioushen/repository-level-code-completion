{"filename": "chronokit/__init__.py", "chunked_list": ["from . import decomposition, exponential_smoothing, preprocessing, utils"]}
{"filename": "chronokit/utils/__init__.py", "chunked_list": ["from . import vis_utils, evaluation_utils"]}
{"filename": "chronokit/utils/evaluation_utils/metrics.py", "chunked_list": ["import torch\nfrom chronokit.preprocessing.dataloader import DataLoader\n\n\"\"\"Performance evaluation metrics for model predictions\"\"\"\n\ndef mae(y_pred, y_true):\n    \"\"\"\n    Mean Absolute Error\n    \n    Arguments:\n    \n    *y_pred (array_like): Predicted values\n    *y_true (array_like): Ground truth values\n    \"\"\"\n    y_pred = DataLoader(y_pred).to_tensor()\n    y_true = DataLoader(y_true).to_tensor()      \n\n    return torch.mean(torch.abs(torch.sub(y_pred, y_true)))", "\n\ndef mse(y_pred, y_true):\n    \"\"\"\n    Mean Squared Error\n    \n    Arguments:\n    \n    *y_pred (array_like): Predicted values\n    *y_true (array_like): Ground truth values\n    \"\"\"\n    y_pred = DataLoader(y_pred).to_tensor()\n    y_true = DataLoader(y_true).to_tensor()      \n\n    return torch.mean((torch.square(torch.sub(y_pred, y_true))))", "\ndef rmse(y_pred, y_true):\n    \"\"\"\n    Root Mean Squared Error\n    \n    Arguments:\n    \n    *y_pred (array_like): Predicted values\n    *y_true (array_like): Ground truth values\n    \"\"\"\n    y_pred = DataLoader(y_pred).to_tensor()\n    y_true = DataLoader(y_true).to_tensor()  \n\n    return torch.sqrt(torch.mean((torch.square(torch.sub(y_pred, y_true)))))"]}
{"filename": "chronokit/utils/evaluation_utils/__init__.py", "chunked_list": ["from .metrics import * "]}
{"filename": "chronokit/utils/vis_utils/data_plots.py", "chunked_list": ["import matplotlib\nimport matplotlib.style\nimport matplotlib.pyplot as plt\nfrom chronokit.preprocessing.dataloader import DataLoader\n\ndef plot_decomp(trend, seasonal, remainder, figsize=(12,8), colors=None, style=None):\n    \"\"\"\n    Utility function for plotting time series decomposition results\n    \n    Arguments:\n\n    *trend (array_like): Trend component of the decomposition\n    *seasonal (array_like): Seasonal component of the decomposition\n    *remainer (array_like): Remainders of the decomposition\n    *figsize (Optional[tuple]): Size of the plot\n    *colors (Optional[iterable]): Colors of the lines/points on the plot\n    *style (Optional[str]): Style of the plot 'https://matplotlib.org/stable/gallery/style_sheets/style_sheets_reference.html'\n    \"\"\"\n    if style:\n        assert(type(style) == str), \"Provide style as a string\"\n        matplotlib.style.use(style)\n    \n    use_colors = {\"trend\": \"blue\", \"seasonal\": \"blue\", \"remainder\": \"blue\"}\n\n    if colors:\n        try:\n            iter(colors)\n        except TypeError:\n            raise TypeError(\"Provide colors as an iterable\")\n        \n        if type(colors) == dict:\n            for key in colors:\n                assert(key in list(use_colors.keys())), f\"Ensure that keys in colours dictionary are {list(use_colors.keys())}\"\n                use_colors[key] = colors[key]\n\n        else:\n            for ind, c in enumerate(colors):\n                use_colors[list(use_colors.keys())[ind]] = c\n\n    trend = DataLoader(trend).to_numpy()\n    seasonal = DataLoader(seasonal).to_numpy()\n    remainder = DataLoader(remainder).to_numpy()\n    \n    fig, axes = plt.subplots(3, 1, figsize=figsize)\n    ax1, ax2, ax3 = axes     \n    ax1.plot(range(len(trend)), trend, color=use_colors[\"trend\"])\n    ax1.set_ylabel(\"Trend\")\n    ax2.plot(range(len(seasonal)), seasonal, color=use_colors[\"seasonal\"])\n    ax2.set_ylabel(\"Seasonal\")\n    ax3.scatter(range(len(remainder)), remainder, color=use_colors[\"remainder\"])\n    ax3.set_ylabel(\"Remainder\")\n    plt.show()", "        \n\ndef plot_train_test_split(train_data, test_data, val_data=None, figsize=(12,8), title: str =None, colors=None, style=None):\n    \"\"\"\n    Utility function for plotting train test split\n    \n    Arguments:\n\n    *train_data (array_like): Training data of the split\n    *test_data (array_like): Test data of the split\n    *val_data (Optional[array_like]): Val data of the split if data is splitted as train/val/test\n    *figsize (Optional[tuple]): Size of the plot\n    *title (Optional[str]): Title of the plot\n    *colors (Optional[iterable]): Colors of the lines/points on the plot\n    *style (Optional[str]): Style of the plot 'https://matplotlib.org/stable/gallery/style_sheets/style_sheets_reference.html'\n    \"\"\"\n    \n    assert (type(title) == \"str\" or title is None), \"Plot title must be a string\"\n\n    if style:\n        assert(type(style) == str), \"Provide style as a string\"\n        matplotlib.style.use(style)\n    \n    use_colors = {\"train\": \"blue\", \"val\": \"orange\", \"test\": \"red\"}\n\n    if colors:\n        try:\n            iter(colors)\n        except TypeError:\n            raise TypeError(\"Provide colors as an iterable\")\n        \n        if type(colors) == dict:\n            for key in colors:\n                assert(key in list(use_colors.keys())), f\"Ensure that keys in colours dictionary are {list(use_colors.keys())}\"\n                use_colors[key] = colors[key]\n\n        else:\n            for ind, c in enumerate(colors):\n                use_colors[list(use_colors.keys())[ind]] = c\n\n    train = DataLoader(train_data).to_numpy()\n    test = DataLoader(test_data).to_numpy()\n\n    if val_data:\n        val = DataLoader(val_data).to_numpy()\n        plt.figure(figsize=figsize)\n        plt.plot(range(len(train)), train, label=\"Train\", color=use_colors[\"train\"])\n        plt.plot(range(len(train), len(train)+len(val_data)), val, label=\"Validation\", color=use_colors[\"val\"])\n        plt.plot(range(len(train+val_data), len(train)+len(val_data)+len(test_data)), test, label=\"Test\", color=use_colors[\"test\"])\n        plt.legend(loc=\"best\")\n        plt.title(title)\n        plt.show()\n       \n    else:\n        plt.figure(figsize=figsize)\n        plt.plot(range(len(train)), train, label=\"Train\", color=use_colors[\"train\"])\n        plt.plot(range(len(train), len(train)+len(test)), test, label=\"Test\", color=use_colors[\"test\"])\n        plt.legend(loc=\"best\")\n        plt.title(title)\n        plt.show()", "    "]}
{"filename": "chronokit/utils/vis_utils/__init__.py", "chunked_list": ["from .data_plots import *\nfrom .model_plots import *\n"]}
{"filename": "chronokit/utils/vis_utils/model_plots.py", "chunked_list": ["import matplotlib\nimport matplotlib.style\nimport matplotlib.pyplot as plt\nfrom chronokit.preprocessing.dataloader import DataLoader\nfrom chronokit.utils.evaluation_utils.metrics import * \n\ndef plot_predictions(y_true, y_pred, bounds=None, pre_vals=None, figsize=(12,8), colors=None, bounds_fill_alpha=0.7, title=None, style=None, metrics=None):\n    \"\"\"\n    Utility function for plotting prediction results of the time series model\n    \n    Arguments:\n\n    *y_true (array_like): Ground truth values\n    *y_pred (array_like): Predicted values\n    *bounds (Optional[iterable]): Confidence bounds for the prediction interval\n    *pre_vals (Optional[array_like]): Values that come before the predicted values i.e; last n-points of the training data\n    *figsize (Optional[tuple]): Size of the plot\n    *colors (Optional[iterable]): Colors of the lines/points on the plot\n    *bounds_fill_alpha (Optional[float]): Alpha for the transparency of the filled values between confidence bounds\n    *title (Optional[str]): Title of the plot\n    *style (Optional[str]): Style of the plot 'https://matplotlib.org/stable/gallery/style_sheets/style_sheets_reference.html'\n    *metrics (Optional[iterable]): Evaluation metrics to use for the predictions to report on the plot\n    \"\"\"\n    y_true = DataLoader(y_true).to_numpy()\n    y_pred = DataLoader(y_pred).to_numpy()\n\n    use_colors = {\"y_true\": \"blue\", \"y_pred\": \"orange\", \"bounds\": \"gray\", \"pre_vals\": \"black\"}\n\n    if colors:\n        try:\n            iter(colors)\n        except TypeError:\n            raise TypeError(\"Provide colors as an iterable\")\n        \n        if type(colors) == dict:\n            for key in colors:\n                assert(key in list(use_colors.keys())), f\"Ensure that keys in colours dictionary are {list(use_colors.keys())}\"\n                use_colors[key] = colors[key]\n\n        else:\n            for ind, c in enumerate(colors):\n                use_colors[list(use_colors.keys())[ind]] = c\n\n    error_bounds = None\n\n    if bounds:\n        try:\n            iter(bounds)\n        except TypeError:\n            raise TypeError(\"Provide bounds as an iterable of length 2\")\n        \n        assert (len(bounds) == 2), \"Provide bounds as an iterable of length 2\"\n\n        if type(bounds) == dict:\n\n            assert (list(bounds.keys()) == [\"upper\", \"lower\"]), \"Provide bounds dictionary keys as ['upper', 'lower']\"\n\n            for val in list(bounds.values()):\n                assert (len(val) == len(y_pred)), \"Length of bounds must match length of predictions\"\n\n            error_bounds = {\"upper\": DataLoader(bounds[\"upper\"]).to_numpy(), \"lower\": DataLoader(bounds[\"lower\"]).to_numpy()}\n\n        else:\n            for val in bounds:\n                assert (len(val) == len(y_pred)), \"Length of bounds must match length of predictions\"\n\n            error_bounds = {\"upper\": DataLoader(bounds[0]).to_numpy(), \"lower\": DataLoader(bounds[1]).to_numpy()}\n    \n    plt_metrics = None\n    if metrics:\n        plt_metrics = {}\n        try:\n            iter(metrics)\n            if type(metrics) == dict:\n                raise TypeError(\"Metrics argument cannot be a dictionary\")\n        except TypeError:\n            raise TypeError(\"Provide metrics as an iterable of length 2\")\n        \n        for i in metrics:\n            assert (type(i) == str), \"Provide metrics as an iterable with string entries\"\n            assert (i in [\"rmse\", \"mse\", \"mae\"]), \"Supported metrics are: ['rmse', 'mse' and 'mae']\"\n\n            if i == \"rmse\":\n                plt_metrics[\"RMSE\"] = rmse(y_pred, y_true).item()\n            if i == \"mse\":\n                plt_metrics[\"MSE\"] = mse(y_pred, y_true).item()\n            if i == \"mae\":\n                plt_metrics[\"MAE\"] = mae(y_pred, y_true).item()\n    \n    assert (type(title) == str or title is None), \"Plot title must be a string\"\n\n    if style:\n        assert(type(style) == str), \"Provide style as a string\"\n        matplotlib.style.use(style)\n\n    plt.figure(figsize=figsize)\n    if pre_vals is not None:\n        pre_vals = DataLoader(pre_vals).to_numpy()\n        main_plt_range = range(len(pre_vals), len(pre_vals)+len(y_pred))\n        plt.plot(range(len(pre_vals)), pre_vals, color=use_colors[\"pre_vals\"])\n    else:\n        main_plt_range = range(len(y_pred))\n    plt.plot(main_plt_range, y_true, color=use_colors[\"y_true\"], label=\"Y True\")\n    plt.plot(main_plt_range, y_pred, color=use_colors[\"y_pred\"], label=\"Y Predicted\")\n    if error_bounds:\n        plt.fill_between(main_plt_range, error_bounds[\"upper\"], error_bounds[\"lower\"], \n                         color=use_colors[\"bounds\"], alpha=bounds_fill_alpha, label=\"Prediction Error Bounds\")\n    if plt_metrics:\n        append_title = \"\"\n        for metric in plt_metrics:\n            score = plt_metrics[metric]\n            append_title += metric + f\":{score:.3f} \"\n        if title:\n            title = title + \"\\n\" + append_title\n        else:\n            title = append_title\n    plt.title(title)\n    plt.legend(loc=\"best\")\n    plt.show()", "    "]}
{"filename": "chronokit/preprocessing/dataloader.py", "chunked_list": ["import numpy as np\nimport pandas as pd\nimport torch\n\nclass DataLoader:\n\n    def __init__(self, data):\n\n        \"\"\" A class to transform given data into desirable types\n            Currently accepted data types are: 'pd.DataFrame', 'pd.Series', 'np.ndarray', 'torch.Tensor\"\"\"\n        \n        self.accepted_types = [pd.DataFrame,\n                               pd.Series,\n                               np.ndarray,\n                               torch.Tensor]\n        \n        self.data_type = type(data)\n        \n        assert (self.data_type in self.accepted_types), f\"{type(data).__name__} is not an accepted data type\"\n\n        if self.data_type == pd.DataFrame:\n\n            self.original_df = data\n            self.data = self.organize_df(data)\n        \n        else:\n            self.data = data\n    \n    def organize_df(self, df: pd.DataFrame):\n\n        \"\"\" Method for organizing a possibly unorganized dataframe while also making sure all entries are convertible to tensors\n            and keeping track of the operations done on the original dataframe\"\"\"\n\n        self.organized_df = df.copy()\n\n        self.operations = []\n\n        self.dates = None\n        self.data_columns = list(df.columns)\n\n        for ind, dtype in enumerate(df.dtypes):\n            col = df.dtypes.index[ind]\n\n            if dtype == object:\n                try:\n                    self.dates = pd.to_datetime(df[col])\n                    self.operations.append(f\"Turned entries of column'{col}' into datetime\")\n\n                    self.data_columns.remove(col)\n                    self.organized_df.pop(col)\n                    self.organized_df = self.organized_df.set_index(self.dates)\n                    self.organized_df.index.name = \"Dates\"\n                    self.operations.append(\"Set dates as an index\")\n                    \n                except:\n                    \n                    try:\n                        float_vals = df[col].values.astype(np.float32)\n                        self.organized_df[col] = float_vals\n                        self.operations.append(f\"Turned {col} entries into floats\")\n                    except:\n                        raise Exception(f\"Could not handle entries of column: '{col}' \")\n        \n        return self.organized_df.values\n\n    def to_tensor(self):\n\n        \"\"\"Turn self.data into tensors\"\"\"\n\n        if type(self.data) == torch.Tensor:\n            return self.data\n        \n        else:\n            return torch.tensor(self.data)\n        \n    def to_numpy(self):\n\n        \"\"\"Turn self.data into numpy arrays\"\"\"\n\n        if type(self.data) == np.ndarray:\n            return self.data\n        \n        else:\n            return np.array(self.data)", "        "]}
{"filename": "chronokit/preprocessing/data_transforms.py", "chunked_list": ["import numpy as np\nimport pandas as pd\nimport torch\nfrom .dataloader import DataLoader\nfrom scipy.stats import boxcox_normmax\n\nclass DataTransform:\n\n    def __init__(self):\n        \"\"\"Base class for all data transformation class to inherit from\"\"\"\n        pass\n\n    def transform_assert(self, loader: DataLoader, axis: int, scales: dict):\n        \"\"\"Make necessary assertions for transforming the data\"\"\"\n        for scale_key in scales:\n\n            scale_dict = scales[scale_key]\n\n            assert(type(scale_dict) == dict), f\"Provide {scale_key} as a dict\"\n\n        assert (loader.to_tensor().numpy().size != 0), \"Size of data must be > 0\"\n\n        if loader.data_type == pd.DataFrame:\n            data_names = list(loader.organized_df.columns)\n            for scale_dict in list(scales.values()):\n                \n                if scale_dict != {}:                \n                    assert (len(list(scale_dict.keys())) == len(data_names)), f\"Provide same amount of entries as columns\"\n                    assert (set(list(scale_dict.keys())) == set(data_names)), \"Provide with the same keys as column names\"\n\n        else:\n            assert (loader.data.ndim <= 2), \"Dimension of the data must be <= 2\"\n            assert (axis in [0, 1, -1, -2]), f\"{axis} is not a valid axis\"\n\n            if loader.data.ndim == 1:\n                assert (axis in [0,-1]), f\"{axis} is not a valid axis of data of ndim == 1\"\n                \n                for scale_key in scales:    \n                    scale_dict = scales[scale_key]\n                    if scale_dict != {}:\n                        assert (list(scale_dict.keys()) == [scale_key]), \"For data with ndim == 1, scales should be\\\n provided as {}\".format({f'{scale_key}': 'value'})\n\n            else:\n                hmap = {0: \"row\", 1: \"col\", -1: \"col\", -2: \"row\"}\n                data_names = [f\"{hmap[axis]}{i}\" for i in range(loader.data.shape[1-  axis % 2])]\n\n                for scale_dict in list(scales.values()):\n                    if scale_dict != {}:\n                        assert (len(list(scale_dict.keys())) == len(data_names)), f\"Provide same amount of entries as {hmap[axis]}s\"\n                        assert (set(list(scale_dict.keys())) == set(data_names)), f\"Provide keys as {hmap[axis]}0 for {hmap[axis]} of index 0 etc...\"\n\n    def inv_transform_assert(self, loader: DataLoader, names, scales: dict):\n        \"\"\"Make necessary assertions to inverse transforming the data\"\"\"\n        assert(type(names) == list), \"Provide names argument as a list\"\n\n        try:\n            if self.transformed_axis:\n                pass\n        except NameError:\n            raise NameError(\"Must call '.transform()' before calling '.inverse_transform()'\")\n\n        assert(type(names) == list), \"Provide names argument as a list\"\n\n        assert (loader.to_tensor().numpy().size != 0), \"Size of data must be > 0\"\n\n        transform_data = loader.to_tensor()\n\n        if names != []:\n            for scale_dict in list(scales.values()):\n                for name in names:\n                    assert(name in list(scale_dict())), f\"{name} was not in transformed data\"\n        else:\n            assert (len(loader.to_tensor().shape) == 2), \"Data must be 2 dimensional if the names argument is not provided\"\n            for scale_dict in list(scales.values()):\n                assert (loader.data.shape[1-  self.transformed_axis % 2] == len(list(scale_dict.keys()))), f\"Expecting\\\n size of axis {self.transformed_axis} = {len(list(scale_dict))} if the names argument is not provided\"", "\n\nclass BoxCox(DataTransform):\n    def __init__(self):\n        \"\"\"Box-Cox transformation for time series data\"\"\"\n        super().__init__()\n        self.lambdas = {}\n\n    def transform(self, data, axis=0, lambda_values: dict = {}):\n        \"\"\"\n        Transform given data with box-cox method\n\n        Arguments:\n\n        *data (array_like): Time series data to transform\n        *axis (int): Axis to perform the transformation on\n        *lambda_values (Optional[dict]): Lambda values for the transformation; will be estimated if given as an empty dict \n        \"\"\"\n\n        loader = DataLoader(data)\n        self.transform_assert(loader, axis, scales={\"lambda\": lambda_values})\n\n        if loader.data_type == pd.DataFrame:\n            data_names = list(loader.organized_df.columns)\n            if lambda_values == {}:\n                lambda_values = {name: None for name in data_names}\n        else:\n            if loader.data.ndim == 1:\n                if lambda_values == {}:\n                    lambda_values = {\"lambda\": None}\n            else:\n                hmap = {0: \"col\", 1: \"row\", -1: \"row\", -2: \"col\"}\n                data_names = [f\"{hmap[axis]}{i}\" for i in range(loader.data.shape[1-  axis % 2])]\n                if lambda_values == {}:\n                    lambda_values = {name: None for name in data_names}\n\n        self.transformed_axis = axis\n        transform_data = loader.to_tensor()\n        transformed = np.zeros(transform_data.shape)\n        for ind in range(len(data_names)):\n            if transform_data.ndim == 1:\n                current_data = transform_data\n\n            elif axis in [0,-2]:\n                current_data = transform_data[:, ind]\n            else:\n                current_data = transform_data[ind, :]\n            \n            name = data_names[ind]\n            lambd = lambda_values[name]\n            boxcoxed = self.__box_cox(current_data, lambd, name)\n\n            if transform_data.ndim == 1:\n                transformed = boxcoxed\n\n            elif axis in [0,-2]:\n                transformed[:, ind] = boxcoxed\n            \n            else:\n                transformed[ind, :] = boxcoxed\n\n        return transformed\n    \n    def inverse_transform(self, data, names: list = []):\n        \"\"\"\n        Inverse transform given data\n\n        Arguments:\n\n        *data (array_like): Time series data to inverse transform\n        *names (Optional[list]): Keys for data to inverse transform if partial transformation is desired  \n        \"\"\"\n        loader = DataLoader(data)\n\n        self.inv_transform_assert(loader, names, scales={\"lambda\": self.lambdas})\n\n        transform_data = loader.to_tensor()\n        transformed = np.zeros(transform_data.shape)\n\n        if names == []:\n            names = list(self.lambdas.keys())\n\n        for ind in range(len(names)):\n\n            if transform_data.ndim == 1:\n                current_data = transform_data\n\n            elif self.transformed_axis in [0,-2]:\n                current_data = transform_data[:, ind]\n            \n            else:\n                current_data = transform_data[ind, :]\n            \n            name = names[ind]\n            lambd = self.lambdas[name]\n\n            inversed = torch.exp(current_data) if lambd == 0 else torch.pow(torch.add(torch.mul(lambd, current_data), 1), 1/lambd)\n\n            if transform_data.ndim == 1:\n                transformed = inversed\n            \n            elif self.transformed_axis in [0,-2]:\n                transformed[:, ind] = inversed\n            \n            else:\n                transformed[ind, :] = inversed\n\n        return transformed\n          \n    def __box_cox(self, data, lambd=None, data_name=\"col0\"):\n        \"\"\"Perform the box-cox transformation\"\"\"\n        box_coxed = data.detach().clone()\n\n        if lambd:\n            assert(type(lambd) == float or type(lambd) == int), \"Provide lambda value as a float\"\n\n        else:  \n            lambd = boxcox_normmax(box_coxed.numpy())\n        \n        box_coxed = torch.log(box_coxed) if lambd == 0 else torch.div(torch.sub(torch.pow(box_coxed, lambd), 1), lambd)\n        self.lambdas[data_name] = lambd\n\n        return box_coxed", "\nclass StandardScaling(DataTransform):\n    def __init__(self):\n        \"\"\"Standard Scaling for time series data\"\"\"\n        self.locations = {}\n        self.scales = {}\n\n    def transform(self, data, axis=0, locations: dict = {}, scales: dict = {}):\n        \"\"\"\n        Standard scale the given data\n\n        Arguments:\n\n        *data (array_like): Time series data to transform\n        *axis (int): Axis to perform the transformation on\n        *locations (Optional[dict]): Location values to be used for scaling the data; will be taken as the mean if not given\n        *scales (Optional[dict]): Scale values to be used for scaling the data; will be taken as the std if not given\n        \"\"\"\n        loader = DataLoader(data)\n        self.transform_assert(loader, axis, scales={\"location\": locations, \"scale\": scales})\n\n        if loader.data_type == pd.DataFrame:\n            data_names = list(loader.organized_df.columns)\n            if locations == {}:\n                locations = {name: loader.organized_df[name].mean() for name in data_names}\n            if scales == {}:\n                scales = {name: loader.organized_df[name].std() for name in data_names}\n                for s in list(scales.values()):\n                    if s == 0:\n                        raise ValueError(\"cannot scale data with std = 0\")\n        else:\n            if loader.data.ndim == 1:\n                if locations == {}:\n                    locations = {\"loc\": loader.to_tensor().mean().item()}\n                if scales == {}:\n                    scales = {\"scale\": loader.to_tensor().std().item()}\n                    for s in list(scales.values()):\n                        if s == 0:\n                            raise ValueError(\"cannot scale data with std = 0\")\n            else:\n                hmap = {0: \"row\", 1: \"col\", -1: \"col\", -2: \"row\"}\n                data_names = [f\"{hmap[axis]}{i}\" for i in range(loader.data.shape[1-  axis % 2])]\n                if locations == {}:\n                    locs = loader.to_tensor().mean(axis)\n                    locations = {data_names[ind]: locs[ind].item() for ind in range(len(data_names))}\n                if scales == {}:\n                    stds = loader.to_tensor().std(axis)\n                    scales = {data_names[ind]: stds[ind].item() for ind in range(len(data_names))}\n                    for s in list(scales.values()):\n                        if s == 0:\n                            raise ValueError(\"cannot scale data with std = 0\")\n        self.locations = locations\n        self.scales = scales\n\n        self.transformed_axis = axis\n        transform_data = loader.to_tensor()\n        transformed = np.zeros(transform_data.shape)\n        for ind in range(len(data_names)):\n\n            if transform_data.ndim == 1:\n                current_data = transform_data\n\n            elif axis in [0,-2]:\n                current_data = transform_data[:, ind]\n            \n            else:\n                current_data = transform_data[ind, :]\n            \n            name = data_names[ind]\n            mu = self.locations[name]\n            sigma = self.scales[name]\n            \n            x = current_data.detach().clone()\n            standard_scaled = torch.div(torch.sub(x,mu), sigma)\n\n            if transform_data.ndim == 1:\n                transformed = standard_scaled\n\n            elif axis in [0,-2]:\n                transformed[:, ind] = standard_scaled\n            \n            else:\n                transformed[ind, :] = standard_scaled\n\n        return transformed\n    \n    def inverse_transform(self, data, names: list = []):\n        \"\"\"\n        Inverse transform given data\n\n        Arguments:\n\n        *data (array_like): Time series data to transform\n        *names (Optional[list]): Keys for data to inverse transform if partial transformation is desired  \n        \"\"\"\n        loader = DataLoader(data)\n\n        self.inv_transform_assert(loader, names, scales={\"location\": self.locations, \"scale\": self.scales})\n\n        transform_data = loader.to_tensor()\n        transformed = np.zeros(transform_data.shape)\n\n        for ind in range(len(names)):\n\n            if transform_data.ndim == 1:\n                current_data = transform_data\n\n            elif self.transformed_axis in [0,-2]:\n                current_data = transform_data[:, ind]\n            \n            else:\n                current_data = transform_data[ind, :]\n            \n            name = names[ind]\n            mu = self.locations[name]\n            sigma = self.scales[name]\n\n            x = current_data.detach().clone()\n            inversed = torch.add(torch.mul(x, sigma), mu)\n\n            if transform_data.ndim == 1:\n                transformed = inversed\n            \n            elif self.transformed_axis in [0,-2]:\n                transformed[:, ind] = inversed\n            \n            else:\n                transformed[ind, :] = inversed\n\n        return transformed", "\nclass MinMaxScaling(DataTransform):\n    def __init__(self, feature_range=(0,1)):\n        \"\"\"\n        MinMax Scaling for time series data\n\n        Arguments:\n\n        *feature_range (Optional[iterable]): Value bounds for the data to be scaled on\n        \"\"\"\n        try:\n            iter(feature_range)\n        except TypeError:\n            raise TypeError(\"Provide feature_range as an iterable\")\n\n        assert(len(feature_range) == 2), \"Provide feature_range as an iterable of length 2\"\n\n        self.lb, self.ub = feature_range\n\n        assert(self.ub > self.lb), \"Provide feature_range as (a,b) where b > a\"\n\n        self.mins = {}\n        self.maxes = {}\n\n    def transform(self, data, axis=0):\n        \"\"\"\n        MinMax scale the given data\n\n        Arguments:\n\n        *data (array_like): Time series data to transform\n        *axis (int): Axis to perform the transformation on\n        \"\"\"\n        loader = DataLoader(data)\n        self.transform_assert(loader, axis, scales={})\n\n        if loader.data_type == pd.DataFrame:\n            data_names = list(loader.organized_df.columns)\n            mins = {name: loader.organized_df[name].min() for name in data_names}\n            maxes = {name: loader.organized_df[name].max() for name in data_names}\n\n            for key in mins:\n\n                if mins[key] == maxes[key]:\n                    raise ValueError(\"Cannot scale with min(data)=max(data)\")\n\n        else:\n            if loader.data.ndim == 1:\n\n                mins = {\"min\": loader.to_numpy().min()}\n                maxes = {\"max\": loader.to_numpy().max()}\n\n                if mins[\"min\"] == maxes[\"max\"]:\n                    raise ValueError(\"Cannot scale with min(data)=max(data)\")\n                \n            else:\n                hmap = {0: \"row\", 1: \"col\", -1: \"col\", -2: \"row\"}\n                data_names = [f\"{hmap[axis]}{i}\" for i in range(loader.data.shape[1-  axis % 2])]\n                \n                mins_ = loader.to_tensor().min(axis)\n                mins = {data_names[ind]: mins_[ind] for ind in range(len(data_names))}\n                maxes_ = loader.to_tensor().max(axis)\n                maxes = {data_names[ind]: maxes_[ind] for ind in range(len(data_names))}\n\n                for key in mins:\n\n                    if mins[key] == maxes[key]:\n                        raise ValueError(\"Cannot scale with min(data)=max(data)\")\n                    \n        self.mins = mins\n        self.maxes = maxes\n\n        self.transformed_axis = axis\n        transform_data = loader.to_tensor()\n        transformed = np.zeros(transform_data.shape)\n        for ind in range(len(data_names)):\n\n            if transform_data.ndim == 1:\n                current_data = transform_data\n\n            elif axis in [0,-2]:\n                current_data = transform_data[:, ind]\n            \n            else:\n                current_data = transform_data[ind, :]\n            \n            name = data_names[ind]\n            xmin = self.mins[name]\n            xmax = self.maxes[name]\n            \n            x = current_data.detach().clone()\n            minmax_scaled = torch.div(torch.sub(x,xmin), torch.sub(xmax, xmin))\n            minmax_scaled = torch.add(torch.mul(minmax_scaled, (self.ub-self.lb)), self.lb)\n\n            if transform_data.ndim == 1:\n                transformed = minmax_scaled\n\n            elif axis in [0,-2]:\n                transformed[:, ind] = minmax_scaled\n            \n            else:\n                transformed[ind, :] = minmax_scaled\n\n        return transformed\n\n    def inverse_transform(self, data, names: list = []):\n        \"\"\"\n        Inverse transform given data\n\n        Arguments:\n\n        *data (array_like): Time series data to transform\n        *names (Optional[list]): Keys for data to inverse transform if partial transformation is desired  \n        \"\"\"\n        loader = DataLoader(data)\n\n        self.inv_transform_assert(loader, names, scales={})\n\n        transform_data = loader.to_tensor()\n        transformed = np.zeros(transform_data.shape)\n\n        for ind in range(len(names)):\n\n            if transform_data.ndim == 1:\n                current_data = transform_data\n\n            elif self.transformed_axis in [0,-2]:\n                current_data = transform_data[:, ind]\n            \n            else:\n                current_data = transform_data[ind, :]\n            \n            name = names[ind]\n            xmin = self.mins[name]\n            xmax = self.maxes[name]\n\n            x = current_data.detach().clone()\n            inversed = torch.div(torch.add(x, self.lb), (self.ub-self.lb))\n            inversed = torch.add(torch.mul(inversed, torch.sub(xmax-xmin)), xmin)\n\n            if transform_data.ndim == 1:\n                transformed = inversed\n            \n            elif self.transformed_axis in [0,-2]:\n                transformed[:, ind] = inversed\n            \n            else:\n                transformed[ind, :] = inversed"]}
{"filename": "chronokit/preprocessing/__init__.py", "chunked_list": ["from .dataloader import *\nfrom .data_transforms import *"]}
{"filename": "chronokit/decomposition/__init__.py", "chunked_list": ["from .decompositions import *\n"]}
{"filename": "chronokit/decomposition/decompositions.py", "chunked_list": ["from chronokit.preprocessing.dataloader import DataLoader\nfrom chronokit.utils.vis_utils import plot_decomp\nimport numpy as np\nimport pandas as pd\n\ndef classical_decomposition(data, seasonal_period, method = 'add', show = True):\n    \"\"\"\n    Classical Decomposition for univariate time series data\n\n    Arguments:\n\n    *data (array_like): Time series data to perform decomposition on\n    *seasonal_period (int): Seasonal period of the given data\n    *method (Optional[str]): Decomposition method to be used; \"add\" or \"mul\"\n    *show (Optional[bool]): Whether to plot the decomposition results\n\n    Chapter 6.3 of the textbook is taken as a reference:\n    'Hyndman, Rob J., and George Athanasopoulos. Forecasting: principles\n    and practice. OTexts, 2014.'\n    \"\"\"\n    data = DataLoader(data).to_numpy().copy()\n\n    if data.ndim >= 1:\n\n        data = np.squeeze(data)\n\n    number_of_cycles = len(data) // seasonal_period\n    assert (number_of_cycles >= 2), \"Data must have at least 2 full seasonal cycles\"\n\n    # Computing the trend-cycle component using moving averages\n    trend = pd.Series(data).rolling(seasonal_period,center=True).mean()\n\n    if seasonal_period % 2 == 0:\n        trend = trend.shift(-1).rolling(2).mean()\n    \n    # Detrending\n    if method == 'add':\n        detrended = data - trend.values\n    elif method == 'mul':\n        detrended = data / trend.values\n\n    # Calculating the seasonal component\n    seasonal = np.zeros(shape=(seasonal_period, number_of_cycles))*np.nan\n    for i in range(0, number_of_cycles):\n            seasonal[:, i] = detrended[i*seasonal_period:(i+1)*seasonal_period]\n    seasonal = np.nanmean(seasonal, axis=1)\n    \n    # Putting seasonality component in a numpy array same length as the original data\n    seasonal = np.array([seasonal[i%seasonal_period] for i in range(len(data))])\n    \n    # Deseasoning (Calculating remainder)\n    if method == 'add' :\n        remainder = detrended - seasonal\n    elif method == 'mul':\n        remainder = detrended / seasonal\n\n    if show:\n        plot_decomp(trend, seasonal, remainder)\n    \n    return trend, seasonal, remainder", "\n"]}
{"filename": "chronokit/exponential_smoothing/model.py", "chunked_list": ["import numpy as np\nimport torch\nfrom scipy.optimize import least_squares\nimport pandas as pd\nfrom chronokit.preprocessing.dataloader import DataLoader\nfrom .initialization import get_init_method, get_smooth_method\nimport scipy.stats as stats\n\nclass Model():\n    def __init__(self,dep_var, **kwargs):\n        \"\"\"\n        Base model class for all model classes to inherit from.\n        Child classes are expected to implement their own .fit() and .predict() methods\n        \"\"\"\n        \n        self.dep_var = DataLoader(dep_var).to_tensor()\n        self.set_kwargs(kwargs)\n\n    \n    def set_allowed_kwargs(self, kwargs: list):\n        \"\"\"This function sets the allowed keyword arguments for the model.\"\"\"\n        self.allowed_kwargs = kwargs\n\n\n    def __check_kwargs(self, kwargs: dict):\n          \"\"\"This function checks if the keyword arguments are valid.\"\"\"\n          for (k,v) in kwargs.items():\n              if k not in self.allowed_kwargs:\n                  raise ValueError(\"{key} is not a valid keyword for this model\".format(key = k))\n\n    def set_kwargs(self, kwargs: dict):\n        \"\"\"This function sets the keyword arguments for the model.\"\"\"\n        self.__check_kwargs(kwargs)\n        for (k,v) in kwargs.items():\n            self.__setattr__(k,v)", "class Model():\n    def __init__(self,dep_var, **kwargs):\n        \"\"\"\n        Base model class for all model classes to inherit from.\n        Child classes are expected to implement their own .fit() and .predict() methods\n        \"\"\"\n        \n        self.dep_var = DataLoader(dep_var).to_tensor()\n        self.set_kwargs(kwargs)\n\n    \n    def set_allowed_kwargs(self, kwargs: list):\n        \"\"\"This function sets the allowed keyword arguments for the model.\"\"\"\n        self.allowed_kwargs = kwargs\n\n\n    def __check_kwargs(self, kwargs: dict):\n          \"\"\"This function checks if the keyword arguments are valid.\"\"\"\n          for (k,v) in kwargs.items():\n              if k not in self.allowed_kwargs:\n                  raise ValueError(\"{key} is not a valid keyword for this model\".format(key = k))\n\n    def set_kwargs(self, kwargs: dict):\n        \"\"\"This function sets the keyword arguments for the model.\"\"\"\n        self.__check_kwargs(kwargs)\n        for (k,v) in kwargs.items():\n            self.__setattr__(k,v)", "\n    \nclass Smoothing_Model(Model):\n\n    def __init__(self, dep_var, trend=None,  seasonal=None,  seasonal_periods=None, damped=False, initialization_method=\"heuristic\", **kwargs):\n        \"\"\"\n        Base class for exponential smoothing methods.\n        All smoothing methods inherit from this class and is used for parameter initialization.\n        \n        Arguments:\n\n        *dep_var (array_like): Univariate time series data\n        *trend (Optional[str]): Trend component; None or \"add\"\n        *seasonal (Optional[str]): Seasonal component; None, \"add\" or \"mul\"\n        *seasonal_periods (Optional[int]): Cyclic period of the seasonal component; int or None if seasonal is None\n        *damped (bool): Damp factor of the trend component; False if trend is None\n        *initialization_method (str): Initialization method to use for the model parameters; \"heuristic\" or \"mle\"\n\n        Keyword Arguments:\n\n        ** alpha (float): Smoothing parameter for level component; takes values in (0,1)\n        ** beta (float): Smoothing parameter for trend component; takes values in (0,1)\n        ** phi (float): Damp factor for trend component; takes values in (0,1]\n        ** gamma (float): Smoothing parameter for seasonal component; takes values in (0,1)\n        \n        All of the smoothing methods have been written as the below textbook as a reference:\n        'Hyndman, Rob J., and George Athanasopoulos. Forecasting: principles\n        and practice. OTexts, 2014.'\n        \"\"\"\n        super().set_allowed_kwargs([\"alpha\", \"beta\", \"phi\", \"gamma\"])\n        super().__init__(dep_var, **kwargs)\n\n        self.trend = trend\n        self.damped = damped\n        self.seasonal = seasonal\n        self.seasonal_periods = seasonal_periods\n        self.init_method = initialization_method\n\n        self.method = get_smooth_method(error=None, trend=trend, damped=damped, seasonal=seasonal)\n        \n        self.params = {\"alpha\": 0.1, \"beta\": 0.01, \"gamma\": 0.01, \"phi\": 0.99}\n        self.init_components = {\"level\": None, \"trend\": None, \"seasonal\": None}\n        \n\n    def __estimate_params(self, init_components, params):\n        \"\"\"Estimate the best parameters to use during fitting and forecasting for the smoothing model\"\"\"\n        def func(x):\n            if self.dep_var.ndim == 1:\n                dep_var = torch.unsqueeze(self.dep_var, axis=-1)\n            else:\n                dep_var = self.dep_var\n            errs = self.method(dep_var, init_components=init_components, params=x)\n\n            return np.mean(np.square(np.array(errs)))\n\n        estimated_params = least_squares(fun=func, x0 = params, bounds=(0,1)).x\n\n        return estimated_params\n    \n    def initialize_params(self, initialize_params):\n        \"\"\"Initialize the components and the parameters to use during fitting and forecasting for the smoothing model\"\"\"\n        self.initial_level, self.initial_trend, self.initial_seasonals = get_init_method(method=self.init_method)(self.dep_var,trend=self.trend, \n                                                                                                                  seasonal=self.seasonal, \n                                                                                                                  seasonal_periods=self.seasonal_periods)\n\n        self.init_components[\"level\"] = self.initial_level,\n        self.init_components[\"trend\"] = self.initial_trend,\n        self.init_components[\"seasonal\"] = np.expand_dims(self.initial_seasonals, axis=-1)\n\n        init_params = {param: self.params[param] for param in initialize_params}\n\n        params = self.__estimate_params(\n                        init_components = [self.initial_level, self.initial_trend, self.initial_seasonals, self.seasonal_periods],\n                        params = list(init_params.values()))\n        \n        for index, param in enumerate(params):\n\n            init_params[list(init_params.keys())[index]] = param\n\n        for param in self.params:\n\n            if param in init_params:\n                self.params[param] = init_params[param]\n\n        if not self.damped:\n            self.params[\"phi\"] = 1\n    \n    def fit(self):\n        #This function will be overriden by the child class.\n        raise NotImplementedError(\"This function is not implemented yet.\")\n\n    def predict(self, h: int):\n        # This function will be overriden by the child class.\n        raise NotImplementedError(\"This function is not implemented yet.\")", "\n\nclass ETS_Model(Model):\n\n    def __init__(self, dep_var, error_type=\"add\", trend=None,  seasonal=None, seasonal_periods=None, damped=False, initialization_method=\"heuristic\", **kwargs):\n        \"\"\"\n        Base class for ETS models\n        All smoothing methods inherit from this class and is used for parameter initialization.\n        \n        Arguments:\n\n        *dep_var (array_like): Univariate time series data\n        *error_type (str): Type of error of the ETS model; \"add\" or \"mul\"\n        *trend (Optional[str]): Trend component; None or \"add\"\n        *seasonal (Optional[str]): Seasonal component; None, \"add\" or \"mul\"\n        *seasonal_periods (Optional[int]): Cyclic period of the seasonal component; int or None if seasonal is None\n        *damped (bool): Damp factor of the trend component; False if trend is None\n        *initialization_method (str): Initialization method to use for the model parameters; \"heuristic\" or \"mle\"\n\n        Keyword Arguments:\n\n        ** alpha (float): Smoothing parameter for level component; takes values in (0,1)\n        ** beta (float): Smoothing parameter for trend component; takes values in (0,1)\n        ** phi (float): Damp factor for trend component; takes values in (0,1]\n        ** gamma (float): Smoothing parameter for seasonal component; takes values in (0,1)\n        \n        All of the smoothing methods have been written as the below textbook as a reference:\n        'Hyndman, Rob J., and George Athanasopoulos. Forecasting: principles\n        and practice. OTexts, 2014.'\n        \"\"\"\n        super().set_allowed_kwargs([\"alpha\", \"beta\", \"phi\", \"gamma\"])\n        super().__init__(dep_var,  **kwargs)\n\n        self.trend = trend\n        self.damped = damped\n        self.seasonal = seasonal\n        self.seasonal_periods = seasonal_periods\n        self.error_type = error_type\n        self.init_method = initialization_method\n\n        self.method = get_smooth_method(error=error_type, trend=trend, damped=damped, seasonal=seasonal)\n\n        self.params = {\"alpha\": 0.1, \"beta\": 0.01, \"gamma\": 0.01, \"phi\": 0.99}\n        self.init_components = {\"level\": None, \"trend\": None, \"seasonal\": None}\n        \n\n    def __estimate_params(self, init_components, params):\n        \"\"\"Estimate the best parameters to use during fitting and forecasting for the smoothing model\"\"\"\n        def func(x):\n            if self.dep_var.ndim == 1:\n                dep_var = torch.unsqueeze(self.dep_var, axis=-1)\n            else:\n                dep_var = self.dep_var\n            errs = self.method(dep_var, init_components=init_components, params=x)\n\n            return np.mean(np.square(np.array(errs)))\n\n        estimated_params = least_squares(fun=func, x0 = params, bounds=(0,1)).x\n\n        return estimated_params\n    \n    def initialize_params(self, initialize_params):\n        \"\"\"Initialize the components and the parameters to use during fitting and forecasting for the smoothing model\"\"\"\n        self.initial_level, self.initial_trend, self.initial_seasonals = get_init_method(method=self.init_method)(self.dep_var,trend=self.trend, \n                                                                                                                  seasonal=self.seasonal, \n                                                                                                                  seasonal_periods=self.seasonal_periods)\n        self.init_components[\"level\"] = self.initial_level,\n        self.init_components[\"trend\"] = self.initial_trend,\n        self.init_components[\"seasonal\"] = np.expand_dims(self.initial_seasonals, axis=-1)\n\n        init_params = {param: self.params[param] for param in initialize_params}\n\n        params = self.__estimate_params(\n                        init_components = [self.initial_level, self.initial_trend, self.initial_seasonals, self.seasonal_periods],\n                        params = list(init_params.values()))\n        \n        for index, param in enumerate(params):\n\n            init_params[list(init_params.keys())[index]] = param\n\n        for param in self.params:\n\n            if param in init_params:\n                self.params[param] = init_params[param]\n\n        if not self.damped:\n            self.params[\"phi\"] = 1\n\n    def calculate_conf_level(self, conf):\n        \"\"\"Calculate the confidence level to be used for prediction intervals\"\"\"\n\n        return round(stats.norm.ppf(1 - ((1 - conf) / 2)), 2)\n    \n    def update_res_variance(self, residuals, error):\n        \"\"\"Update the variance of the residuals during fitting\"\"\"\n        residuals = torch.cat((residuals, torch.reshape(error, (1,1))))\n        res_mean = torch.sum(residuals)/residuals.shape[0]\n        residual_variance = torch.sum(torch.square(torch.sub(residuals, res_mean)))\n        residual_variance = torch.divide(residual_variance, residuals.shape[0]-1)\n\n        return residuals, res_mean, residual_variance\n    \n    def future_sample_paths(self, h, confidence):\n        \"\"\"\n        Future path sampling for ETS models with no known equations for generating prediction intervals\n        Errors are assumed to be normally distributed and random future paths are sampled from the normal distribution\n        with mean and variance calculated by the residuals during fitting \n        \"\"\"\n        q1 = (1-confidence)/2\n        q2 = 1 - q1\n\n        loc = self.residual_mean\n        scale = torch.sqrt(self.residual_variance)\n\n        sample_paths = torch.tensor([])\n\n        for iter in range(5000):\n\n            sample = torch.normal(loc, scale, size=(1,h))\n            sample_paths = torch.cat((sample_paths, sample))\n\n        q1_sample = torch.quantile(sample_paths, q1, dim=0, interpolation=\"nearest\")\n        q2_sample = torch.quantile(sample_paths, q2, dim=0, interpolation=\"nearest\")\n\n        bounds = torch.abs(torch.sub(q1_sample, q2_sample))\n\n        return bounds\n    \n    def fit(self):\n        #This function will be overriden by the child class.\n        raise NotImplementedError(\"This function is not implemented yet.\")\n\n    def predict(self, h: int, confidence: float = None):\n        # This function will be overriden by the child class.\n        raise NotImplementedError(\"This function is not implemented yet.\")", "\n\n\n\n"]}
{"filename": "chronokit/exponential_smoothing/__init__.py", "chunked_list": ["from .ETS import *\nfrom .ExponentialSmoothing import *\nfrom .model import *\nfrom .initialization import *\nfrom .models import * "]}
{"filename": "chronokit/exponential_smoothing/ExponentialSmoothing.py", "chunked_list": ["from .model import Smoothing_Model\nfrom chronokit.exponential_smoothing.models.smoothing import *\n\n\nclass ExponentialSmoothing:\n\n    def __new__(self, dep_var, trend=None, damped=False, seasonal=None, seasonal_periods=None, initialization_method=\"heuristic\", **kwargs):\n        \"\"\"\n        Exponential Smoothing model for time series data\n\n        Arguments:\n\n        *dep_var (array_like): Univariate time series data\n        *trend (Optional[str]): Trend component; None or \"add\"\n        *damped (bool): Damp factor of the trend component; False if trend is None\n        *seasonal (Optional[str]): Seasonal component; None, \"add\" or \"mul\"\n        *seasonal_periods (Optional[int]): Cyclic period of the seasonal component; int or None if seasonal is None\n        *initialization_method (str): Initialization method to use for the model parameters; \"heuristic\" or \"mle\"\n\n        Keyword Arguments:\n\n        ** alpha (float): Smoothing parameter for level component; takes values in (0,1)\n        ** beta (float): Smoothing parameter for trend component; takes values in (0,1)\n        ** phi (float): Damp factor for trend component; takes values in (0,1]\n        ** gamma (float): Smoothing parameter for seasonal component; takes values in (0,1)\n        \n        ETS models are implemented by the below textbook as a reference:\n        'Hyndman, Rob J., and George Athanasopoulos. Forecasting: principles\n        and practice. OTexts, 2014.'\n        \"\"\"\n    \n        smoothing_class = { \n                        (None, None): SES,\n                        (\"add\", None): HoltTrend,\n                        (\"add\", \"add\"): HoltWinters,\n                        (\"add\", \"mul\"): HoltWinters,\n                                                    }[trend, seasonal]\n\n        return smoothing_class(dep_var, trend=trend, seasonal=seasonal, damped=damped, \n                               seasonal_periods=seasonal_periods, initialization_method=initialization_method, **kwargs)", ""]}
{"filename": "chronokit/exponential_smoothing/ETS.py", "chunked_list": ["from .model import ETS_Model\nfrom chronokit.exponential_smoothing.models.ets_models import *\n\nclass ETS(ETS_Model):\n\n    def __new__(self, dep_var, error_type=\"add\", trend=None, damped=False, seasonal=None, seasonal_periods=None, initialization_method=\"heuristic\", **kwargs):\n        \"\"\"\n        ETS (Error,Trend,Seasonality) model for time series data\n\n        Arguments:\n\n        *dep_var (array_like): Univariate time series data\n        *error_type (str): Type of error of the ETS model; \"add\" or \"mul\"\n        *trend (Optional[str]): Trend component; None or \"add\"\n        *damped (bool): Damp factor of the trend component; False if trend is None\n        *seasonal (Optional[str]): Seasonal component; None, \"add\" or \"mul\"\n        *seasonal_periods (Optional[int]): Cyclic period of the seasonal component; int or None if seasonal is None\n        *initialization_method (str): Initialization method to use for the model parameters; \"heuristic\" or \"mle\"\n\n        Keyword Arguments:\n\n        ** alpha (float): Smoothing parameter for level component; takes values in (0,1)\n        ** beta (float): Smoothing parameter for trend component; takes values in (0,1)\n        ** phi (float): Damp factor for trend component; takes values in (0,1]\n        ** gamma (float): Smoothing parameter for seasonal component; takes values in (0,1)\n        \n        ETS models are implemented by the below textbook as a reference:\n        'Hyndman, Rob J., and George Athanasopoulos. Forecasting: principles\n        and practice. OTexts, 2014.'\n        \"\"\"\n        \n        ets_class = { \n                        (None, None, \"add\"): ETS_ANN,\n                        (None, \"add\", \"add\"): ETS_ANA,\n                        (None, \"mul\", \"add\"): ETS_ANM,\n                        (\"add\",  None, \"add\"): ETS_AAN,\n                        (\"add\", \"add\", \"add\"): ETS_AAA,\n                        (\"add\", \"mul\", \"add\"): ETS_AAM,\n\n                        (None,  None, \"mul\"): ETS_MNN,\n                        (None,  \"add\", \"mul\"): ETS_MNA,\n                        (None, \"mul\", \"mul\"): ETS_MNM,\n                        (\"add\",  None, \"mul\"): ETS_MAN,\n                        (\"add\", \"add\", \"mul\"): ETS_MAA,\n                        (\"add\", \"mul\", \"mul\"): ETS_MAM,\n                                                            }[trend, seasonal, error_type]\n\n        return ets_class(dep_var, trend=trend, seasonal=seasonal, error_type=error_type, damped=damped, \n                         seasonal_periods=seasonal_periods, initialization_method=initialization_method, **kwargs)", ""]}
{"filename": "chronokit/exponential_smoothing/models/ets_models.py", "chunked_list": ["import numpy as np\nimport torch\nfrom chronokit.exponential_smoothing.model import ETS_Model\n\n\"\"\"\nETS (Error,Trend,Seasonality) models for time series forecasting.\nAll methods have been implemented from chapter 7 of the textbook as a reference.\n'Hyndman, Rob J., and George Athanasopoulos. Forecasting: principles\nand practice. OTexts, 2014.'\n\"\"\"", "and practice. OTexts, 2014.'\n\"\"\"\n\nclass ETS_ANN(ETS_Model):\n\n    def __init__(self, dep_var, trend=None, seasonal=None, error_type=None, damped=False, seasonal_periods=None, **kwargs):\n        \"\"\"Implementation of ETS method with Additive Errors, No Trend and No Seasonality\"\"\"\n        \n        self.trend = None\n        self.damped = False\n        self.seasonal = None\n        self.seasonal_periods = None\n        self.error_type = \"add\"\n\n        super().set_allowed_kwargs([\"alpha\", \"beta\", \"phi\", \"gamma\"])\n        super().__init__(dep_var, trend=self.trend,  seasonal=self.seasonal, error_type=self.error_type, seasonal_periods=self.seasonal_periods, \n                                damped=self.damped, **kwargs)\n        \n        initialize_params = [\"alpha\"]\n       \n        self.__initialize_params(initialize_params)\n\n        self.residuals = torch.tensor([])\n    \n    def __calculate_conf_level(self, conf):\n        \"\"\"Calculate the multiplier for prediction interval\"\"\"\n        self.c = super().calculate_conf_level(conf)\n\n    def __initialize_params(self, initialize_params):\n        \"\"\"Initialize model parameters\"\"\"\n        super().initialize_params(initialize_params)\n        self.initial_level = torch.tensor(self.init_components[\"level\"])\n        self.alpha, self.beta, self.gamma, self.phi = torch.tensor(list(self.params.values()), dtype=torch.float32)\n    \n    def __update_res_variance(self, y, y_hat):\n        \"\"\"Update the residual variance\"\"\"\n        resid = torch.sub(y, y_hat)\n        self.residuals, self.residual_mean, self.residual_variance = super().update_res_variance(self.residuals, resid)\n\n    def __get_confidence_interval(self, h):\n        \"\"\"Get the confidence interval of the predictions\"\"\"\n        fc_var = torch.add(1 ,torch.mul(torch.square(self.alpha),  h-1))\n        fc_var = torch.mul(self.residual_variance, fc_var)\n        return torch.mul(self.c, torch.sqrt(fc_var))\n    \n    def __smooth_level(self, lprev):\n        \"\"\"Calculate the level\"\"\"\n        self.level = torch.add(lprev, torch.mul(self.alpha, self.error))\n    \n    def __smooth_error(self, y, y_hat):\n        \"\"\"Calculate error\"\"\"\n        self.error = torch.sub(y, y_hat)\n\n    def fit(self):\n        \"\"\"\n        Fit the model to the data according to the equations:\n        y_t = l_{t-1} + e_t\n        l_t = l_{t-1} + alpha*e_t\n        \"\"\"\n\n        self.fitted = torch.zeros(size=self.dep_var.shape)\n\n        for index, row in enumerate(self.dep_var):\n\n            if index == 0:\n                y_hat = row\n                self.level = self.initial_level\n                self.error = torch.tensor(0, dtype=torch.float32)\n                self.fitted[0] = row\n            \n            else:\n                \n                y_hat = self.level\n                self.__smooth_error(row, y_hat)\n                lprev = self.level\n                self.__smooth_level(lprev)\n                self.fitted[index] = y_hat\n            \n            self.__update_res_variance(row, y_hat)\n    \n    def predict(self, h, confidence = None):\n        \"\"\"\n        Predict the next h values of the target variable.\n\n        Arguments:\n\n        *h (int): Future time-steps to forecast\n        *confidence (Optional[float]): Confidence level to generate prediction intervals; None or values between (0,1)\n        \"\"\"\n\n        if confidence:\n            self.__calculate_conf_level(confidence)\n            \n        self.forecast = torch.tensor([])\n        upper_bounds = torch.tensor([])\n        lower_bounds = torch.tensor([])\n\n        for i in range(1,h+1):\n            \n            step_forecast = self.level\n\n            self.forecast = torch.cat((self.forecast, step_forecast))\n\n            if confidence:\n                fc_var = self.__get_confidence_interval(h=i)\n                upper_bounds = torch.cat((upper_bounds, torch.add(step_forecast, torch.abs(fc_var))))\n                lower_bounds = torch.cat((lower_bounds, torch.sub(step_forecast, torch.abs(fc_var))))\n                \n        if confidence:\n            return self.forecast, (upper_bounds, lower_bounds)\n        else:\n            return self.forecast", "\nclass ETS_AAN(ETS_Model):\n\n    def __init__(self, dep_var, trend=None, seasonal=None, error_type=None, damped=False, seasonal_periods=None, **kwargs):\n        \"\"\"Implementation of ETS method with Additive Errors, Additive Trend and No Seasonality\"\"\"\n        self.trend = \"add\"\n        self.damped = damped\n        self.seasonal = None\n        self.seasonal_periods = None\n        self.error_type = \"add\"\n\n        super().set_allowed_kwargs([\"alpha\", \"beta\", \"phi\", \"gamma\"])\n        super().__init__(dep_var, trend=self.trend,  seasonal=self.seasonal, error_type=self.error_type, seasonal_periods=self.seasonal_periods, \n                                damped=self.damped, **kwargs)\n        \n        initialize_params = [\"alpha\", \"beta\"]\n        if self.damped:\n            initialize_params.append(\"phi\")\n        self.__initialize_params(initialize_params)\n\n        self.residuals = torch.tensor([])\n    \n    def __calculate_conf_level(self, conf):\n        \"\"\"Calculate the multiplier for prediction interval\"\"\"\n\n        self.c = super().calculate_conf_level(conf)\n\n    def __initialize_params(self, initialize_params):\n        \"\"\"Initialize model parameters\"\"\"\n\n        super().initialize_params(initialize_params)\n\n        self.initial_level = torch.tensor(self.init_components[\"level\"])\n        self.initial_trend = torch.tensor(self.init_components[\"trend\"])\n\n        self.alpha, self.beta, self.gamma, self.phi = torch.tensor(list(self.params.values()), dtype=torch.float32)\n    \n    def __update_res_variance(self, y, y_hat):\n        \"\"\"Update the residual variance\"\"\"\n\n        resid = torch.sub(y, y_hat)\n\n        self.residuals, self.residual_mean, self.residual_variance = super().update_res_variance(self.residuals, resid)\n        \n    def __get_confidence_interval(self, h):\n        \"\"\"Get the confidence interval of the predictions\"\"\" \n        \n        if not self.damped:\n            fc_var = torch.add(torch.square(self.alpha), torch.mul(torch.mul(self.alpha, self.beta), h))\n            fc_var = torch.add(fc_var, torch.divide(torch.mul(torch.square(self.beta), h*(2*h-1)), 6))\n            fc_var = torch.mul(h-1, fc_var)\n            fc_var = torch.add(1, fc_var)\n            fc_var = torch.mul(self.residual_variance, fc_var)\n        \n        if self.damped:\n\n            part1 = torch.mul(torch.square(self.alpha), h-1)\n\n            part3_1 = torch.mul(torch.mul(self.beta, self.phi), h)\n            part3_1 = torch.divide(part3_1, torch.square(torch.sub(1, self.phi)))\n            part3_2 = torch.add(torch.mul(torch.mul(2, self.alpha), torch.sub(1, self.phi)), torch.mul(self.beta, self.phi))\n            part3 = torch.mul(part3_1, part3_2)\n\n            part4_1 =  torch.mul(torch.mul(self.beta, self.phi), torch.sub(1, torch.pow(self.phi, h)))\n            part4_1 = torch.divide(part4_1, torch.mul(torch.square(torch.sub(1, self.phi)), torch.sub(1, torch.square(self.phi))))\n            part4_2 = torch.mul(torch.mul(self.beta, self.phi), torch.add(1, torch.sub(torch.mul(2, self.phi), torch.pow(self.phi, h))))\n            part4_2 = torch.add(torch.mul(torch.mul(2, self.alpha), torch.sub(1, torch.square(self.phi))), part4_2)\n            part4 = torch.mul(part4_1, part4_2)\n\n            fc_var = torch.add(part1, part3)\n            fc_var = torch.sub(fc_var, part4)\n            fc_var = torch.add(1, fc_var)\n            fc_var = torch.mul(self.residual_variance, fc_var)\n\n        return torch.mul(self.c, torch.sqrt(fc_var))\n    \n    def __smooth_level(self, lprev,bprev): \n        \"\"\"Calculate the level\"\"\"\n\n        self.level = torch.add(torch.add(lprev,torch.mul(bprev, self.phi)), torch.mul(self.alpha, self.error))\n    \n    def __smooth_error(self, y, y_hat):  \n        \"\"\"Calculate error\"\"\"\n\n        self.error = torch.sub(y, y_hat)\n\n    def __smooth_trend(self, bprev):\n        \"\"\"Calculate the level\"\"\"\n\n        self.trend = torch.add(torch.mul(bprev, self.phi), torch.mul(self.beta, self.error))\n\n    def fit(self):               \n        \"\"\"\n        Fit the model to the data according to the equations:\n        y_t = l_{t-1} + phi*b_{t-1} + e_t\n        l_t = l_{t-1} + phi*b_{t-1} + alpha*e_t\n        b_t = phi*b_{t-1} + beta*e_t\n        \"\"\"\n\n        self.fitted = torch.zeros(size=self.dep_var.shape)\n\n        for index, row in enumerate(self.dep_var):\n\n            if index == 0:\n                y_hat = row\n                self.level = self.initial_level\n                self.trend = self.initial_trend\n                self.error = torch.tensor(0, dtype=torch.float32)\n                self.fitted[0] = row\n            \n            else:\n                \n                y_hat = torch.add(self.level, torch.mul(self.phi,self.trend))\n                self.__smooth_error(row, y_hat)\n                lprev, bprev = self.level, self.trend\n                self.__smooth_level(lprev, bprev)\n                self.__smooth_trend(bprev)\n                self.fitted[index] = y_hat\n            \n            self.__update_res_variance(row, y_hat)\n    \n    def predict(self, h, confidence = None):\n        \"\"\"\n        Predict the next h values of the target variable.\n\n        Arguments:\n\n        *h (int): Future time-steps to forecast\n        *confidence (Optional[float]): Confidence level to generate prediction intervals; None or values between (0,1)\n        \"\"\"\n\n        if confidence:\n            self.__calculate_conf_level(confidence)\n            \n        self.forecast = torch.tensor([])\n        upper_bounds = torch.tensor([])\n        lower_bounds = torch.tensor([])\n\n        for i in range(1,h+1):\n            \n            damp_factor = torch.sum(torch.tensor([torch.pow(self.phi, x+1) for x in range(i+1)]))\n\n            step_forecast = torch.add(self.level, torch.mul(damp_factor, self.trend))\n\n            self.forecast = torch.cat((self.forecast, step_forecast))\n\n            if confidence:\n                fc_var = self.__get_confidence_interval(h=i)\n                upper_bounds = torch.cat((upper_bounds, torch.add(step_forecast, torch.abs(fc_var))))\n                lower_bounds = torch.cat((lower_bounds, torch.sub(step_forecast, torch.abs(fc_var))))\n\n        if confidence:\n            return self.forecast, (upper_bounds, lower_bounds)\n        else:\n            return self.forecast", "        \nclass ETS_ANA(ETS_Model):\n\n    def __init__(self, dep_var, trend=None, seasonal=None, error_type=None, damped=False, seasonal_periods=None, **kwargs):\n        \"\"\"Implementation of ETS method with Additive Errors, No Trend and Additive Seasonality\"\"\"\n        self.trend = None\n        self.damped = False\n        self.seasonal = \"add\"\n        self.seasonal_periods = seasonal_periods\n        self.error_type = \"add\"\n\n        super().set_allowed_kwargs([\"alpha\", \"beta\", \"phi\", \"gamma\"])\n        super().__init__(dep_var, trend=self.trend,  seasonal=self.seasonal, error_type=self.error_type, seasonal_periods=self.seasonal_periods, \n                                damped=self.damped, **kwargs)\n        \n        initialize_params = [\"alpha\", \"gamma\"]\n        self.__initialize_params(initialize_params)\n\n        self.residuals = torch.tensor([])\n    \n    def __calculate_conf_level(self, conf):\n        \"\"\"Calculate the multiplier for prediction interval\"\"\"\n\n        self.c = super().calculate_conf_level(conf)\n\n    def __initialize_params(self, initialize_params):\n        \"\"\"Initialize model parameters\"\"\"\n\n        super().initialize_params(initialize_params)\n\n        self.initial_level = torch.tensor(self.init_components[\"level\"])\n        self.initial_seasonals = torch.tensor(self.init_components[\"seasonal\"])\n\n        self.alpha, self.beta, self.gamma, self.phi = torch.tensor(list(self.params.values()), dtype=torch.float32)\n    \n    def __update_res_variance(self, y, y_hat):\n        \"\"\"Update the residual variance\"\"\"\n\n        resid = torch.sub(y, y_hat)\n\n        self.residuals, self.residual_mean, self.residual_variance = super().update_res_variance(self.residuals, resid)\n        \n    def __get_confidence_interval(self, h):\n        \"\"\"Get the confidence interval of the predictions\"\"\"\n\n        k = int((h-1)/self.seasonal_periods)\n\n        fc_var = torch.add(1 ,torch.mul(torch.square(self.alpha),  h-1))\n        fc_var = torch.add(fc_var, torch.mul(torch.mul(self.gamma, k), torch.add(torch.mul(2, self.alpha), self.gamma)))\n        fc_var = torch.mul(self.residual_variance, fc_var)\n\n        return torch.mul(self.c, fc_var)\n    \n    def __smooth_level(self,lprev): \n        \"\"\"Calculate the level\"\"\"\n\n        self.level = torch.add(lprev, torch.mul(self.alpha, self.error))\n    \n    def __smooth_error(self, y, y_hat): \n        \"\"\"Calculate error\"\"\"\n\n        self.error = torch.sub(y, y_hat)\n\n    def __smooth_seasonal(self, seasonal):\n        \"\"\"Calculate the level\"\"\"\n\n        seasonal = torch.add(seasonal, torch.mul(self.gamma, self.error))\n        self.seasonals = torch.cat((self.seasonals, seasonal))\n\n    def fit(self): \n        \"\"\"\n        Fit the model to the data according to the equations:\n        y_t = l_{t-1} + s_{t-m} + e_t\n        l_t = l_{t-1} + alpha*e_t\n        s_t = s_{t-m} + gamma*e_t\n        \"\"\"\n\n        self.fitted = torch.zeros(size=self.dep_var.shape)\n\n        for index, row in enumerate(self.dep_var):\n\n            if index == 0:\n                y_hat = row\n                self.level = self.initial_level\n                self.error = torch.tensor(0, dtype=torch.float32)\n                seasonal = self.initial_seasonals[0]\n                self.seasonals = torch.tensor([seasonal])\n                self.fitted[0] = row\n                \n            elif index < self.seasonal_periods:\n                \n                seasonal = self.initial_seasonals[index]\n                y_hat = torch.add(self.level, seasonal)\n                lprev = self.level\n                self.__smooth_error(row, y_hat)\n                self.__smooth_level(lprev)\n                self.seasonals = torch.cat((self.seasonals, seasonal))\n\n                self.fitted[index] = y_hat\n                \n            \n            else:\n\n                seasonal = self.seasonals[-self.seasonal_periods]\n                y_hat = torch.add(self.level, seasonal)\n                lprev = self.level\n                self.__smooth_error(row, y_hat)\n                self.__smooth_level(lprev)\n                self.__smooth_seasonal(seasonal)\n\n                self.fitted[index] = y_hat\n            \n            self.__update_res_variance(row, y_hat)\n    \n    def predict(self, h, confidence = None):\n        \"\"\"\n        Predict the next h values of the target variable.\n\n        Arguments:\n\n        *h (int): Future time-steps to forecast\n        *confidence (Optional[float]): Confidence level to generate prediction intervals; None or values between (0,1)\n        \"\"\"\n        \n        if confidence:\n            self.__calculate_conf_level(confidence)\n            \n        self.forecast = torch.tensor([])\n        upper_bounds = torch.tensor([])\n        lower_bounds = torch.tensor([])\n        \n        len_s = self.seasonals.shape[0]\n\n        for i in range(1,h+1):\n\n            k = int((h-1)/self.seasonal_periods)\n            \n            step_forecast = torch.add(self.level, self.seasonals[len_s+i-self.seasonal_periods*(k+1)])\n\n            self.forecast = torch.cat((self.forecast, step_forecast))\n\n            if confidence:\n                fc_var = self.__get_confidence_interval(h=i)\n                upper_bounds = torch.cat((upper_bounds, torch.add(step_forecast, torch.abs(fc_var))))\n                lower_bounds = torch.cat((lower_bounds, torch.sub(step_forecast, torch.abs(fc_var))))\n                \n        if confidence:\n            return self.forecast, (upper_bounds, lower_bounds)\n        else:\n            return self.forecast", "\nclass ETS_AAA(ETS_Model):\n\n    def __init__(self, dep_var, trend=None, seasonal=None, error_type=None, damped=False, seasonal_periods=None, **kwargs):\n        \"\"\"Implementation of ETS method with Additive Errors, Additive Trend and Additive Seasonality\"\"\"\n        self.trend = \"add\"\n        self.damped = damped\n        self.seasonal = \"add\"\n        self.seasonal_periods = seasonal_periods\n        self.error_type = \"add\"\n\n        super().set_allowed_kwargs([\"alpha\", \"beta\", \"phi\", \"gamma\"])\n        super().__init__(dep_var, trend=self.trend,  seasonal=self.seasonal, error_type=self.error_type, seasonal_periods=self.seasonal_periods, \n                                damped=self.damped, **kwargs)\n        \n        initialize_params = [\"alpha\", \"beta\", \"gamma\"]\n        if self.damped:\n            initialize_params.append(\"phi\")\n        self.__initialize_params(initialize_params)\n\n        self.residuals = torch.tensor([])\n    \n    def __calculate_conf_level(self, conf):\n        \"\"\"Calculate the multiplier for prediction interval\"\"\"\n\n        self.c = super().calculate_conf_level(conf)\n\n    def __initialize_params(self, initialize_params):\n        \"\"\"Initialize model parameters\"\"\"\n\n        super().initialize_params(initialize_params)\n\n        self.initial_level = torch.tensor(self.init_components[\"level\"])\n        self.initial_trend = torch.tensor(self.init_components[\"trend\"])\n        self.initial_seasonals = torch.tensor(self.init_components[\"seasonal\"])\n\n        self.alpha, self.beta, self.gamma, self.phi = torch.tensor(list(self.params.values()), dtype=torch.float32)\n    \n    def __update_res_variance(self, y, y_hat):\n        \"\"\"Update the residual variance\"\"\"\n\n        resid = torch.sub(y, y_hat)\n\n        self.residuals, self.residual_mean, self.residual_variance = super().update_res_variance(self.residuals, resid)\n        \n    def __get_confidence_interval(self, h):\n        \"\"\"Get the confidence interval of the predictions\"\"\"\n\n        k = int((h-1)/self.seasonal_periods)\n        \n        if not self.damped:\n            part1 = torch.add(torch.square(self.alpha), torch.mul(torch.mul(self.alpha, self.beta), h))\n            part1 = torch.add(part1, torch.divide(torch.mul(torch.square(self.beta), h*(2*h-1)), 6))\n            part1 = torch.mul(h-1, part1)\n\n            part2 = torch.add(torch.mul(2,self.alpha), self.gamma)\n            part2= torch.add(part2, torch.mul(torch.mul(self.beta, self.seasonal_periods), k+1))\n            part2 = torch.mul(part2, torch.mul(self.gamma, k))\n\n            fc_var = torch.add(part1, part2)\n            fc_var = torch.add(1, fc_var)\n            fc_var = torch.mul(self.residual_variance, fc_var)\n        \n        if self.damped:\n\n            part1 = torch.mul(torch.square(self.alpha), h-1)\n            part2 = torch.mul(torch.mul(self.gamma, k), torch.add(torch.mul(2, self.alpha), self.gamma))\n\n            part3_1 = torch.mul(torch.mul(self.beta, self.phi), h)\n            part3_1 = torch.divide(part3_1, torch.square(torch.sub(1, self.phi)))\n            part3_2 = torch.add(torch.mul(torch.mul(2, self.alpha), torch.sub(1, self.phi)), torch.mul(self.beta, self.phi))\n            part3 = torch.mul(part3_1, part3_2)\n\n            part4_1 =  torch.mul(torch.mul(self.beta, self.phi), torch.sub(1, torch.pow(self.phi, h)))\n            part4_1 = torch.divide(part4_1, torch.mul(torch.square(torch.sub(1, self.phi)), torch.sub(1, torch.square(self.phi))))\n            part4_2 = torch.mul(torch.mul(self.beta, self.phi), torch.add(1, torch.sub(torch.mul(2, self.phi), torch.pow(self.phi, h))))\n            part4_2 = torch.add(torch.mul(torch.mul(2, self.alpha), torch.sub(1, torch.square(self.phi))), part4_2)\n            part4 = torch.mul(part4_1, part4_2)\n\n            part5_1 = torch.mul(torch.mul(2, self.beta), torch.mul(self.gamma, self.phi))\n            part5_1 = torch.divide(part5_1, torch.mul(torch.sub(1, self.phi), torch.sub(1, torch.pow(self.phi, self.seasonal_periods))))\n            part5_2 = torch.mul(torch.pow(self.phi, self.seasonal_periods), torch.sub(1, torch.pow(self.phi, torch.mul(self.seasonal_periods, k))))\n            part5_2 = torch.sub(torch.mul(k, torch.sub(1, torch.pow(self.phi, self.seasonal_periods))), part5_2)\n            part5 = torch.mul(part5_1, part5_2)\n\n            fc_var = torch.add(part1, part2)\n            fc_var = torch.add(fc_var, part3)\n            fc_var = torch.sub(fc_var, part4)\n            fc_var = torch.add(fc_var, part5)\n            fc_var = torch.add(1, fc_var)\n            fc_var = torch.mul(self.residual_variance, fc_var)\n\n        return torch.mul(self.c, torch.sqrt(fc_var))\n    \n    def __smooth_level(self, lprev,bprev):\n        \"\"\"Calculate the level\"\"\"\n\n        self.level = torch.add(lprev, torch.mul(self.phi, bprev))\n        self.level = torch.add(self.level, torch.mul(self.alpha, self.error))\n    \n    def __smooth_error(self, y, y_hat):\n        \"\"\"Calculate error\"\"\"\n\n        self.error = torch.sub(y, y_hat)\n\n    def __smooth_seasonal(self, seasonal):\n        \"\"\"Calculate seasonal\"\"\"\n        seasonal = torch.add(seasonal, torch.mul(self.gamma, self.error))\n        self.seasonals = torch.cat((self.seasonals, seasonal))\n\n    def __smooth_trend(self, bprev):\n        \"\"\"Calculate trend\"\"\"\n        self.trend = torch.add(torch.mul(self.error, self.beta), torch.mul(self.phi, bprev))\n\n    def fit(self):\n\n        \"\"\"\n        Fit the model to the data according to the equations:\n        y_t = l_{t-1} + phi*b_{t-1} + s_{t-m} + e_t\n        l_t = l_{t-1} + phi*b_{t-1} + alpha*e_t\n        b_t = phi*b_{t-1} + beta*e_t\n        s_t = s_{t-m} + gamma*e_t\n        \"\"\"\n        self.fitted = torch.zeros(size=self.dep_var.shape)\n\n        for index, row in enumerate(self.dep_var):\n            if index == 0:\n                y_hat = row\n                self.level = self.initial_level\n                self.trend = self.initial_trend\n                self.error = torch.tensor(0, dtype=torch.float32)\n                seasonal = self.initial_seasonals[0]\n                self.seasonals = torch.tensor([seasonal])\n                self.fitted[0] = row\n            \n            elif index < self.seasonal_periods:\n                \n                seasonal = self.initial_seasonals[index]\n                y_hat = torch.add(self.level, torch.add(torch.mul(self.phi, self.trend), seasonal))\n                self.__smooth_error(row, y_hat)\n                lprev, bprev = self.level, self.trend\n                self.__smooth_level(lprev, bprev)\n                self.__smooth_trend(bprev)\n                self.seasonals = torch.cat((self.seasonals, seasonal))\n                self.fitted[index] = y_hat\n            else:\n                \n                seasonal = self.seasonals[-self.seasonal_periods]\n                y_hat = torch.add(self.level, torch.add(torch.mul(self.phi, self.trend), seasonal))\n                self.__smooth_error(row, y_hat)\n                lprev, bprev = self.level, self.trend\n                self.__smooth_level(lprev, bprev)\n                self.__smooth_trend(bprev)\n                self.__smooth_seasonal(seasonal)\n                self.fitted[index] =y_hat\n\n            self.__update_res_variance(row, y_hat)\n\n    def predict(self, h, confidence = None):\n        \"\"\"\n        Predict the next h values of the target variable.\n\n        Arguments:\n\n        *h (int): Future time-steps to forecast\n        *confidence (Optional[float]): Confidence level to generate prediction intervals; None or values between (0,1)\n        \"\"\"\n\n        if confidence:\n            self.__calculate_conf_level(confidence)\n            \n        self.forecast = torch.tensor([])\n\n        upper_bounds = torch.tensor([])\n        lower_bounds = torch.tensor([])\n\n        len_s = self.seasonals.shape[0]\n\n        for i in range(1,h+1):\n            \n            damp_factor = torch.sum(torch.tensor([torch.pow(self.phi, x+1) for x in range(i+1)]))\n\n            k = int((h-1)/self.seasonal_periods)\n            \n\n            step_forecast = torch.add(self.level, torch.mul(damp_factor, self.trend))\n            step_forecast = torch.add(step_forecast, self.seasonals[len_s+i-self.seasonal_periods*(k+1)])\n\n            self.forecast = torch.cat((self.forecast, step_forecast))\n\n            if confidence:\n                fc_var = self.__get_confidence_interval(h=i)\n                upper_bounds = torch.cat((upper_bounds, torch.add(step_forecast, torch.abs(fc_var))))\n                lower_bounds = torch.cat((lower_bounds, torch.sub(step_forecast, torch.abs(fc_var))))\n                \n\n        if confidence:\n            return self.forecast, (upper_bounds, lower_bounds)\n        else:\n            return self.forecast", "\nclass ETS_ANM(ETS_Model):\n\n    def __init__(self, dep_var, trend=None, seasonal=None, error_type=None, damped=False, seasonal_periods=None, **kwargs):\n        \"\"\"Implementation of ETS method with Additive Errors, No Trend and Multiplicative Seasonality\"\"\"\n        self.trend = None\n        self.damped = False\n        self.seasonal = \"mul\"\n        self.seasonal_periods = seasonal_periods\n        self.error_type = \"add\"\n\n        super().set_allowed_kwargs([\"alpha\", \"beta\", \"phi\", \"gamma\"])\n        super().__init__(dep_var, trend=self.trend,  seasonal=self.seasonal, error_type=self.error_type, seasonal_periods=self.seasonal_periods, \n                                damped=self.damped, **kwargs)\n        \n        initialize_params = [\"alpha\", \"gamma\"]\n\n        self.__initialize_params(initialize_params)\n\n        self.residuals = torch.tensor([])\n    \n    def __calculate_conf_level(self, conf):\n        \"\"\"Calculate the multiplier for prediction interval\"\"\"\n\n        self.c = super().calculate_conf_level(conf)\n\n    def __initialize_params(self, initialize_params):\n        \"\"\"Initialize model parameters\"\"\"\n\n        super().initialize_params(initialize_params)\n\n        self.initial_level = torch.tensor(self.init_components[\"level\"])\n        self.initial_seasonals = torch.tensor(self.init_components[\"seasonal\"])\n\n        self.alpha, self.beta, self.gamma, self.phi = torch.tensor(list(self.params.values()), dtype=torch.float32)\n    \n    def __update_res_variance(self, y, y_hat):\n        \"\"\"Update the residual variance\"\"\"\n\n        resid = torch.sub(y, y_hat)\n\n        self.residuals, self.residual_mean, self.residual_variance = super().update_res_variance(self.residuals, resid)\n        \n    def __get_confidence_interval(self, h, conf):\n        \"\"\"Get the confidence interval of the predictions\"\"\"\n        return super().future_sample_paths(h, conf)\n\n    def __smooth_level(self,lprev, seasonal):\n        \"\"\"Calculate the level\"\"\"\n\n        self.level = torch.add(lprev, torch.divide(torch.mul(self.alpha, self.error), seasonal))\n    \n    def __smooth_error(self, y, y_hat):  \n        \"\"\"Calculate error\"\"\"\n\n        self.error = torch.sub(y,y_hat)\n\n    def __smooth_seasonal(self, seasonal, lprev):\n        \"\"\"Calculate the level\"\"\"\n\n        seasonal = torch.add(seasonal, torch.divide(torch.mul(self.gamma, self.error),lprev))\n        self.seasonals = torch.cat((self.seasonals, seasonal))\n\n    def fit(self):\n        \"\"\"\n        Fit the model to the data according to the equations:\n        y_t = l_{t-1}*s_{t-m} + e_t\n        l_t = l_{t-1} + alpha*e_t/s_{t-m}\n        s_t = s_{t-m} + gamma*e_t/l_{t-1}\n        \"\"\"\n\n        self.fitted = torch.zeros(size=self.dep_var.shape)\n\n        for index, row in enumerate(self.dep_var):\n\n            if index == 0:\n                y_hat = row\n                self.level = self.initial_level\n                self.error = torch.tensor(0, dtype=torch.float32)\n                seasonal = self.initial_seasonals[0]\n                self.seasonals = seasonal\n                self.fitted[0] = row\n                \n            elif index < self.seasonal_periods:\n                seasonal = self.initial_seasonals[index]\n                y_hat = torch.mul(self.level,seasonal)\n                lprev = self.level\n                self.__smooth_error(row, y_hat)\n                self.__smooth_level(lprev, seasonal)\n                self.seasonals = torch.cat((self.seasonals, seasonal))\n\n                self.fitted[index] = y_hat\n                \n            else:\n                seasonal = self.seasonals[-self.seasonal_periods]\n                y_hat = torch.mul(self.level,seasonal)\n                lprev = self.level\n                self.__smooth_error(row, y_hat)\n                self.__smooth_level(lprev, seasonal)\n                self.__smooth_seasonal(seasonal,lprev)\n\n                self.fitted[index] = y_hat\n            \n            self.__update_res_variance(row, y_hat)\n    \n    def predict(self, h, confidence = None):\n        \"\"\"\n        Predict the next h values of the target variable.\n\n        Arguments:\n\n        *h (int): Future time-steps to forecast\n        *confidence (Optional[float]): Confidence level to generate prediction intervals; None or values between (0,1)\n        \"\"\"\n\n        self.forecast = torch.tensor([])\n        \n        len_s = self.seasonals.shape[0]\n\n        for i in range(1,h+1):\n\n            k = int((h-1)/self.seasonal_periods)\n            \n            step_forecast = torch.mul(self.level, self.seasonals[len_s+i-self.seasonal_periods*(k+1)])\n\n            self.forecast = torch.cat((self.forecast, step_forecast))\n                \n        if confidence:\n            bounds = self.__get_confidence_interval(h, conf=confidence)\n            upper_bounds = torch.add(self.forecast, bounds)\n            lower_bounds = torch.sub(self.forecast, bounds)\n\n            return self.forecast, (upper_bounds, lower_bounds)\n        else:\n            return self.forecast", "\nclass ETS_AAM(ETS_Model):\n\n    def __init__(self, dep_var, trend=None, seasonal=None, error_type=None, damped=False, seasonal_periods=None, **kwargs):\n\n        \"\"\"Implementation of ETS method with Additive Errors, Additive Trend and Multiplicative Seasonality\"\"\"\n        self.trend = \"add\"\n        self.damped = damped\n        self.seasonal = \"mul\"\n        self.seasonal_periods = seasonal_periods\n        self.error_type = \"add\"\n\n        super().set_allowed_kwargs([\"alpha\", \"beta\", \"phi\", \"gamma\"])\n        super().__init__(dep_var, trend=self.trend,  seasonal=self.seasonal, error_type=self.error_type, seasonal_periods=self.seasonal_periods, \n                                damped=self.damped, **kwargs)\n        \n        initialize_params = [\"alpha\", \"beta\", \"gamma\"]\n        if self.damped:\n            initialize_params.append(\"phi\")\n        self.__initialize_params(initialize_params)\n\n        self.residuals = torch.tensor([])\n    \n    def __calculate_conf_level(self, conf):\n        \"\"\"Calculate the multiplier for prediction interval\"\"\"\n\n        self.c = super().calculate_conf_level(conf)\n\n    def __initialize_params(self, initialize_params):\n        \"\"\"Initialize model parameters\"\"\"\n\n        super().initialize_params(initialize_params)\n\n        self.initial_level = torch.tensor(self.init_components[\"level\"])\n        self.initial_trend = torch.tensor(self.init_components[\"trend\"])\n        self.initial_seasonals = torch.tensor(self.init_components[\"seasonal\"])\n\n        self.alpha, self.beta, self.gamma, self.phi = torch.tensor(list(self.params.values()), dtype=torch.float32)\n    \n    def __update_res_variance(self, y, y_hat):\n        \"\"\"Update the residual variance\"\"\"\n\n        resid = torch.sub(y, y_hat)\n\n        self.residuals, self.residual_mean, self.residual_variance = super().update_res_variance(self.residuals, resid)\n        \n    def __get_confidence_interval(self, h, conf):\n        \"\"\"Get the confidence interval of the predictions\"\"\"        \n        return super().future_sample_paths(h, conf)\n    \n    def __smooth_level(self, lprev, bprev, seasonal):\n        \"\"\"Calculate the level\"\"\"\n\n        self.level = torch.add(torch.mul(self.phi, bprev), torch.divide(torch.mul(self.alpha, self.error), seasonal))\n        self.level = torch.add(self.level, lprev)\n    \n    def __smooth_trend(self, bprev, seasonal):\n        \"\"\"Calculate trend\"\"\"\n        self.trend = torch.divide(torch.mul(self.beta, self.error), seasonal)\n        self.trend = torch.add(self.trend, torch.mul(self.phi, bprev))\n\n    def __smooth_seasonal(self, lprev, bprev):\n        \"\"\"Calculate seasonal\"\"\"\n        seasonal = torch.divide(torch.mul(self.gamma, self.error), torch.add(lprev, torch.mul(self.phi, bprev)))\n        seasonal = torch.add(seasonal, self.seasonals[-self.seasonal_periods])\n\n        self.seasonals = torch.cat((self.seasonals, seasonal))\n    \n    def __smooth_error(self, y, y_hat):\n        \"\"\"Calculate error\"\"\"\n\n        self.error = torch.sub(y, y_hat)\n\n    def fit(self):\n        \"\"\"\n        Fit the model to the data according to the equations:\n        y_t = (l_{t-1} + phi*b_{t-1})*s_{t-m} + e_t\n        l_t = l_{t-1} + phi*b_{t-1} + alpha*e_t/s_{t-m}\n        b_t = phi*b_{t-1} + beta*e_t/s_{t-m}\n        s_t = s_{t-m} + gamma*e_t/(l_{t-1} + phi*b_{t-1})\n        \"\"\"\n\n        self.fitted = torch.zeros(size=self.dep_var.shape)\n\n        for index, row in enumerate(self.dep_var):\n\n            if index == 0:\n                y_hat = row\n                self.level = self.initial_level\n                self.trend = self.initial_trend\n                self.error = torch.tensor(0, dtype=torch.float32)\n                seasonal = self.initial_seasonals[0]\n                self.seasonals = seasonal\n                self.fitted[0] = row\n            \n            elif index < self.seasonal_periods:\n                \n                seasonal = self.initial_seasonals[index]\n                y_hat = torch.mul(torch.add(self.level, torch.mul(self.phi, self.trend)), seasonal)\n                lprev, bprev = self.level, self.trend\n                self.__smooth_error(row, y_hat)\n                self.__smooth_level(lprev, bprev, seasonal)\n                self.__smooth_trend(bprev, seasonal)\n                self.seasonals = torch.cat((self.seasonals, seasonal))\n\n                self.fitted[index] = y_hat\n                \n            \n            else:\n                \n                seasonal = self.seasonals[-self.seasonal_periods]\n                y_hat = torch.mul(torch.add(self.level, torch.mul(self.phi, self.trend)), seasonal)\n                lprev, bprev = self.level, self.trend\n                self.__smooth_error(row, y_hat)\n                self.__smooth_level(lprev, bprev, seasonal)\n                self.__smooth_trend(bprev, seasonal)\n                self.__smooth_seasonal(lprev, bprev)\n\n                self.fitted[index] = y_hat\n            \n            self.__update_res_variance(row, y_hat)\n\n    \n    def predict(self, h, confidence = None):\n        \"\"\"\n        Predict the next h values of the target variable.\n\n        Arguments:\n\n        *h (int): Future time-steps to forecast\n        *confidence (Optional[float]): Confidence level to generate prediction intervals; None or values between (0,1)\n        \"\"\"\n\n        self.forecast = torch.tensor([])\n        \n        len_s = self.seasonals.shape[0]\n\n        for i in range(1,h+1):\n            \n            damp_factor = torch.sum(torch.tensor([torch.pow(self.phi, x+1) for x in range(i+1)]))\n            k = int((h-1)/self.seasonal_periods)\n            \n            step_forecast = torch.mul(self.seasonals[len_s+i-self.seasonal_periods*(k+1)], torch.add(self.level, torch.mul(damp_factor, self.trend)))\n\n            self.forecast = torch.cat((self.forecast, step_forecast))\n\n                \n        if confidence:\n            bounds = self.__get_confidence_interval(h, conf=confidence)\n            upper_bounds = torch.add(self.forecast, bounds)\n            lower_bounds = torch.sub(self.forecast, bounds)\n            \n            return self.forecast, (upper_bounds, lower_bounds)\n        else:\n            return self.forecast", "\nclass ETS_MNN(ETS_Model):\n\n    def __init__(self, dep_var, trend=None, seasonal=None, error_type=None, damped=False, seasonal_periods=None, **kwargs):\n        \"\"\"Implementation of ETS method with Multiplicative Errors, No Trend and No Seasonality\"\"\"\n        self.trend = None\n        self.damped = False\n        self.seasonal = None\n        self.seasonal_periods = None\n        self.error_type = \"mul\"\n\n        super().set_allowed_kwargs([\"alpha\", \"beta\", \"phi\", \"gamma\"])\n        super().__init__(dep_var, trend=self.trend,  seasonal=self.seasonal, error_type=self.error_type, seasonal_periods=self.seasonal_periods, \n                                damped=self.damped, **kwargs)\n        \n        initialize_params = [\"alpha\"]\n        self.__initialize_params(initialize_params)\n\n        self.residuals = torch.tensor([])\n    \n    def __calculate_conf_level(self, conf):\n        \"\"\"Calculate the multiplier for prediction interval\"\"\"\n\n        self.c = super().calculate_conf_level(conf)\n\n    def __initialize_params(self, initialize_params):\n        \"\"\"Initialize model parameters\"\"\"\n\n        super().initialize_params(initialize_params)\n\n        self.initial_level = torch.tensor(self.init_components[\"level\"])\n\n        self.alpha, self.beta, self.gamma, self.phi = torch.tensor(list(self.params.values()), dtype=torch.float32)\n    \n    def __update_res_variance(self, y, y_hat):\n        \"\"\"Update the residual variance\"\"\"\n\n        resid = torch.sub(y, y_hat)\n\n        self.residuals, self.residual_mean, self.residual_variance = super().update_res_variance(self.residuals, resid)\n\n    def __get_confidence_interval(self, h, conf):\n        \"\"\"Get the confidence interval of the predictions\"\"\"        \n        return super().future_sample_paths(h, conf)\n    \n    def __smooth_level(self, lprev):\n        \"\"\"Calculate the level\"\"\"\n\n        self.level = torch.mul(lprev, torch.add(1, torch.mul(self.alpha, self.error)))\n    \n    def __smooth_error(self, y, y_hat):\n        \"\"\"Calculate error\"\"\"\n\n        self.error = torch.divide(torch.sub(y, y_hat), y_hat)\n\n    def fit(self):\n        \"\"\"\n        Fit the model to the data according to the equations:\n        y_t = l_{t-1}*(1 + e_t)\n        l_t = l_{t-1}*(1 + alpha*e_t)\n        \"\"\"\n\n        self.fitted = torch.zeros(size=self.dep_var.shape)\n\n        for index, row in enumerate(self.dep_var):\n\n            if index == 0:\n                y_hat = row\n                self.level = self.initial_level\n                self.error = torch.tensor(0, dtype=torch.float32)\n                self.fitted[0] = row\n            \n            else:\n                y_hat = self.level\n                lprev = self.level\n                self.__smooth_error(row, y_hat)\n                self.__smooth_level(lprev)\n                self.fitted[index] = y_hat\n            \n            self.__update_res_variance(row, y_hat)\n    \n    def predict(self, h, confidence = None):\n        \"\"\"\n        Predict the next h values of the target variable.\n\n        Arguments:\n\n        *h (int): Future time-steps to forecast\n        *confidence (Optional[float]): Confidence level to generate prediction intervals; None or values between (0,1)\n        \"\"\"\n            \n        self.forecast = torch.tensor([])\n\n        for i in range(1,h+1):\n            \n            step_forecast = self.level\n\n            self.forecast = torch.cat((self.forecast, step_forecast))\n\n                \n        if confidence:\n            bounds = self.__get_confidence_interval(h, conf=confidence)\n            upper_bounds = torch.add(self.forecast, bounds)\n            lower_bounds = torch.sub(self.forecast, bounds)\n            \n            return self.forecast, (upper_bounds, lower_bounds)\n        else:\n            return self.forecast", "\nclass ETS_MAN(ETS_Model):\n\n    def __init__(self, dep_var, trend=None, seasonal=None, error_type=None, damped=False, seasonal_periods=None, **kwargs):\n        \"\"\"Implementation of ETS method with Multiplicative Errors, Additive Trend and No Seasonality\"\"\"\n        self.trend = \"add\"\n        self.damped = damped\n        self.seasonal = None\n        self.seasonal_periods = None\n        self.error_type = \"mul\"\n\n        super().set_allowed_kwargs([\"alpha\", \"beta\", \"phi\", \"gamma\"])\n        super().__init__(dep_var, trend=self.trend,  seasonal=self.seasonal, error_type=self.error_type, seasonal_periods=self.seasonal_periods, \n                                damped=self.damped, **kwargs)\n        \n        initialize_params = [\"alpha\", \"beta\"]\n        if self.damped:\n            initialize_params.append(\"phi\")\n        self.__initialize_params(initialize_params)\n\n        self.residuals = torch.tensor([])\n    \n    def __calculate_conf_level(self, conf):\n        \"\"\"Calculate the multiplier for prediction interval\"\"\"\n\n        self.c = super().calculate_conf_level(conf)\n\n    def __initialize_params(self, initialize_params):\n        \"\"\"Initialize model parameters\"\"\"\n\n        super().initialize_params(initialize_params)\n\n        self.initial_level = torch.tensor(self.init_components[\"level\"])\n        self.initial_trend = torch.tensor(self.init_components[\"trend\"])\n\n        self.alpha, self.beta, self.gamma, self.phi = torch.tensor(list(self.params.values()), dtype=torch.float32)\n    \n    def __update_res_variance(self, y, y_hat):\n        \"\"\"Update the residual variance\"\"\"\n\n        resid = torch.sub(y, y_hat)\n\n        self.residuals, self.residual_mean, self.residual_variance = super().update_res_variance(self.residuals, resid)\n        \n    def __get_confidence_interval(self, h, conf): \n        \"\"\"Get the confidence interval of the predictions\"\"\"\n        return super().future_sample_paths(h, conf)\n\n    def __smooth_level(self, lprev,bprev): #done\n        \"\"\"Calculate the level\"\"\"\n\n        self.level = torch.mul(torch.add(lprev,torch.mul(self.phi, bprev)), torch.add(1, torch.mul(self.alpha, self.error)))\n    \n    def __smooth_error(self, y, y_hat):  #done\n        \"\"\"Calculate error\"\"\"\n\n        self.error = torch.divide(torch.sub(y, y_hat), y_hat)\n    \n    def __smooth_trend(self, bprev,lprev): ##done\n        \"\"\"Calculate the trend\"\"\"\n\n        self.trend = torch.add(torch.mul(self.phi, bprev), torch.mul(self.beta, torch.mul(torch.add(lprev,torch.mul(self.phi, bprev)),self.error)))\n\n    def fit(self):\n\n        \"\"\"\n        Fit the model to the data according to the equations:\n        y_t = (l_{t-1} + phi*b_{t-1})*(1 + e_t)\n        l_t = (l_{t-1} + phi*b_{t-1})*(1 + alpha*e_t)\n        b_t = phi*b_{t-1} + beta*(l_{t-1} + phi*b_{t-1})*e_t\n        \"\"\"\n\n        self.fitted = torch.zeros(size=self.dep_var.shape)\n\n        for index, row in enumerate(self.dep_var):\n\n            if index == 0:\n                y_hat = row\n                self.level = self.initial_level\n                self.trend = self.initial_trend\n                self.error = torch.tensor(0, dtype=torch.float32)\n                self.fitted[0] = row\n            \n            else:\n                \n                y_hat = torch.add(self.level, torch.mul(self.phi,self.trend))\n                self.__smooth_error(row, y_hat)\n                lprev, bprev = self.level, self.trend\n                self.__smooth_level(lprev, bprev)\n                self.__smooth_trend(bprev, lprev)\n                self.fitted[index] = y_hat\n            \n            self.__update_res_variance(row, y_hat)\n    \n    \n    def predict(self, h, confidence = None):\n        \"\"\"\n        Predict the next h values of the target variable.\n\n        Arguments:\n\n        *h (int): Future time-steps to forecast\n        *confidence (Optional[float]): Confidence level to generate prediction intervals; None or values between (0,1)\n        \"\"\"\n\n        self.forecast = torch.tensor([])\n\n        for i in range(1,h+1):\n            \n            damp_factor = torch.sum(torch.tensor([torch.pow(self.phi, x+1) for x in range(i+1)]))\n\n            step_forecast = torch.add(self.level, torch.mul(damp_factor, self.trend))\n\n            self.forecast = torch.cat((self.forecast, step_forecast))            \n\n        if confidence:\n            bounds = self.__get_confidence_interval(h, conf=confidence)\n            upper_bounds = torch.add(self.forecast, bounds)\n            lower_bounds = torch.sub(self.forecast, bounds)\n            \n            return self.forecast, (upper_bounds, lower_bounds)\n        else:\n            return self.forecast", "\nclass ETS_MNA(ETS_Model):\n\n    def __init__(self, dep_var, trend=None, seasonal=None, error_type=None, damped=False, seasonal_periods=None, **kwargs):\n        \"\"\"Implementation of ETS method with Multiplicative Errors, No Trend and Additive Seasonality\"\"\"\n        self.trend = None\n        self.damped = False\n        self.seasonal = \"add\"\n        self.seasonal_periods = seasonal_periods\n        self.error_type = \"add\"\n\n        super().set_allowed_kwargs([\"alpha\", \"beta\", \"phi\", \"gamma\"])\n        super().__init__(dep_var, trend=self.trend,  seasonal=self.seasonal, error_type=self.error_type, seasonal_periods=self.seasonal_periods, \n                                damped=self.damped, **kwargs)\n        \n        initialize_params = [\"alpha\", \"gamma\"]\n        self.__initialize_params(initialize_params)\n\n        self.residuals = torch.tensor([])\n    \n    def __calculate_conf_level(self, conf):\n        \"\"\"Calculate the multiplier for prediction interval\"\"\"\n\n        self.c = super().calculate_conf_level(conf)\n\n    def __initialize_params(self, initialize_params):\n        \"\"\"Initialize model parameters\"\"\"\n\n        super().initialize_params(initialize_params)\n\n        self.initial_level = torch.tensor(self.init_components[\"level\"])\n        self.initial_seasonals = torch.tensor(self.init_components[\"seasonal\"])\n\n        self.alpha, self.beta, self.gamma, self.phi = torch.tensor(list(self.params.values()), dtype=torch.float32)\n    \n    def __update_res_variance(self, y, y_hat):\n        \"\"\"Update the residual variance\"\"\"\n\n        resid = torch.sub(y, y_hat)\n\n        self.residuals, self.residual_mean, self.residual_variance = super().update_res_variance(self.residuals, resid)\n        \n    def __get_confidence_interval(self, h, conf): \n        \"\"\"Get the confidence interval of the predictions\"\"\"\n        return super().future_sample_paths(h, conf)\n\n    def __smooth_level(self,lprev,seasonal):\n        \"\"\"Calculate the level\"\"\"\n\n        self.level = torch.add(lprev, torch.mul(self.alpha, torch.mul(torch.add(lprev,seasonal),self.error)))\n    \n    def __smooth_error(self, y, y_hat):\n        \"\"\"Calculate error\"\"\"\n\n        self.error = torch.divide(torch.sub(y,y_hat),y_hat)\n\n    def __smooth_seasonal(self, lprev,seasonal):\n        \"\"\"Calculate the level\"\"\"\n\n        seasonal = torch.add(seasonal, torch.mul(self.gamma, torch.mul(torch.add(lprev,seasonal),self.error)))\n        self.seasonals = torch.cat((self.seasonals, seasonal))\n\n    def fit(self): \n        \"\"\"\n        Fit the model to the data according to the equations:\n        y_t = (l_{t-1} + s_{t-m})*(1 + e_t)\n        l_t = l_{t-1} + alpha*(l_{t-1} + s_{t-m})*e_t\n        s_t = s_{t-m} + gamma*(l_{t-1} + s_{t-m})*e_t\n        \"\"\"\n\n        self.fitted = torch.zeros(size=self.dep_var.shape)\n\n        for index, row in enumerate(self.dep_var):\n\n            if index == 0:\n                y_hat = row\n                self.level = self.initial_level\n                self.error = torch.tensor(0, dtype=torch.float32)\n                seasonal = self.initial_seasonals[0]\n                self.seasonals = torch.tensor([seasonal])\n                self.fitted[0] = row\n                \n            elif index < self.seasonal_periods:\n                \n                seasonal = self.initial_seasonals[index]\n                y_hat = torch.add(self.level, seasonal)\n                lprev = self.level\n                self.__smooth_error(row, y_hat)\n                self.__smooth_level(lprev, seasonal)\n                self.seasonals = torch.cat((self.seasonals, seasonal))\n\n                self.fitted[index] = y_hat     \n            \n            else:\n\n                seasonal = self.seasonals[-self.seasonal_periods]\n                y_hat = torch.add(self.level, seasonal)\n                lprev = self.level\n                self.__smooth_error(row, y_hat)\n                self.__smooth_level(lprev, seasonal)\n                self.__smooth_seasonal(lprev, seasonal)\n\n                self.fitted[index] = y_hat\n            \n            self.__update_res_variance(row, y_hat)\n    \n    def predict(self, h, confidence = None):\n        \"\"\"\n        Predict the next h values of the target variable.\n\n        Arguments:\n\n        *h (int): Future time-steps to forecast\n        *confidence (Optional[float]): Confidence level to generate prediction intervals; None or values between (0,1)\n        \"\"\"\n            \n        self.forecast = torch.tensor([])\n\n        len_s = self.seasonals.shape[0]\n\n        for i in range(1,h+1):\n\n            k = int((h-1)/self.seasonal_periods)\n            \n            step_forecast = torch.add(self.level, self.seasonals[len_s+i-self.seasonal_periods*(k+1)])\n\n            self.forecast = torch.cat((self.forecast, step_forecast))\n                \n        if confidence:\n            bounds = self.__get_confidence_interval(h, conf=confidence)\n            upper_bounds = torch.add(self.forecast, bounds)\n            lower_bounds = torch.sub(self.forecast, bounds)\n            \n            return self.forecast, (upper_bounds, lower_bounds)\n        else:\n            return self.forecast", "\nclass ETS_MAA(ETS_Model):\n    def __init__(self, dep_var, trend=None, seasonal=None, error_type=None, damped=False, seasonal_periods=None, **kwargs):\n        \"\"\"Implementation of ETS method with Multiplicative Errors, Additive Trend and Additive Seasonality\"\"\"\n        self.trend = \"add\"\n        self.damped = damped\n        self.seasonal = \"add\"\n        self.seasonal_periods = seasonal_periods\n        self.error_type = \"mul\"\n\n        super().set_allowed_kwargs([\"alpha\", \"beta\", \"phi\", \"gamma\"])\n        super().__init__(dep_var, trend=self.trend,  seasonal=self.seasonal, error_type=self.error_type, seasonal_periods=self.seasonal_periods, \n                                damped=self.damped, **kwargs)\n        \n        initialize_params = [\"alpha\", \"beta\", \"gamma\"]\n        if self.damped:\n            initialize_params.append(\"phi\")\n        self.__initialize_params(initialize_params)\n\n        self.residuals = torch.tensor([])\n    \n    def __calculate_conf_level(self, conf):\n        \"\"\"Calculate the multiplier for prediction interval\"\"\"\n\n        self.c = super().calculate_conf_level(conf)\n\n    def __initialize_params(self, initialize_params):\n        \"\"\"Initialize model parameters\"\"\"\n\n        super().initialize_params(initialize_params)\n\n        self.initial_level = torch.tensor(self.init_components[\"level\"])\n        self.initial_trend = torch.tensor(self.init_components[\"trend\"])\n        self.initial_seasonals = torch.tensor(self.init_components[\"seasonal\"])\n\n        self.alpha, self.beta, self.gamma, self.phi = torch.tensor(list(self.params.values()), dtype=torch.float32)\n    \n    def __update_res_variance(self, y, y_hat):\n        \"\"\"Update the residual variance\"\"\"\n\n        resid = torch.sub(y, y_hat)\n\n        self.residuals, self.residual_mean, self.residual_variance = super().update_res_variance(self.residuals, resid)\n\n    def __get_confidence_interval(self, h, conf):\n        \"\"\"Get the confidence interval of the predictions\"\"\"\n        return super().future_sample_paths(h, conf)\n    \n    def __smooth_level(self, lprev,bprev,seasonal):\n        \"\"\"Calculate the level\"\"\"\n\n        self.level = torch.mul(self.alpha,torch.add(seasonal,torch.add(lprev,torch.mul(self.phi, bprev))))\n        self.level = torch.mul(self.error,self.level)\n        self.level = torch.add(self.level,torch.add(lprev,torch.mul(self.phi, bprev)))\n    \n    def __smooth_error(self, y, y_hat):\n        \"\"\"Calculate error\"\"\"\n\n        self.error = torch.divide(torch.sub(y, y_hat), y_hat)\n\n    def __smooth_seasonal(self, seasonal, lprev,bprev):\n        seasonal = torch.add(seasonal, torch.mul(self.error,torch.mul(self.gamma,torch.add(seasonal,torch.add(lprev, torch.mul(self.phi,bprev))))))\n        self.seasonals = torch.cat((self.seasonals, seasonal))\n\n    def __smooth_trend(self, lprev, bprev,seasonal):\n        self.trend = torch.add(torch.mul(self.phi, bprev), torch.mul(self.error,torch.mul(self.beta,torch.add(seasonal,torch.add(lprev,torch.mul(self.phi,bprev))))))\n\n    def fit(self):\n\n        \"\"\"\n        Fit the model to the data according to the equations:\n        y_t = (l_{t-1} + phi*b_{t-1} + s_{t-m})*(1 + e_t)\n        l_t = l_{t-1} + phi*b_{t-1} + alpha*(l_{t-1} + s_{t-m})*e_t\n        b_t = phi*b_{t-1} + beta*(l_{t-1} + phi*b_{t-1} + s_{t-m})*e_t\n        s_t = s_{t-m} + gamma*(l_{t-1} + phi*b_{t-1} + s_{t-m})*e_t\n        \"\"\"\n        self.fitted = torch.zeros(size=self.dep_var.shape)\n\n        for index, row in enumerate(self.dep_var):\n            if index == 0:\n                y_hat = row\n                self.level = self.initial_level\n                self.trend = self.initial_trend\n                self.error = torch.tensor(0, dtype=torch.float32)\n                seasonal = self.initial_seasonals[0]\n                self.seasonals = torch.tensor([seasonal])\n                self.fitted[0] = row\n            \n            elif index < self.seasonal_periods:\n                \n                seasonal = self.initial_seasonals[index]\n                y_hat = torch.add(self.level, torch.add(torch.mul(self.phi, self.trend), seasonal))\n                self.__smooth_error(row, y_hat)\n                lprev, bprev = self.level, self.trend\n                self.__smooth_level(lprev, bprev, seasonal)\n                self.__smooth_trend(lprev, bprev, seasonal)\n                self.seasonals = torch.cat((self.seasonals, seasonal))\n                self.fitted[index] = y_hat\n            else:\n                \n                seasonal = self.seasonals[-self.seasonal_periods]\n                y_hat = torch.add(self.level, torch.add(torch.mul(self.phi, self.trend), seasonal))\n                self.__smooth_error(row, y_hat)\n                lprev, bprev = self.level, self.trend\n                self.__smooth_level(lprev, bprev, seasonal)\n                self.__smooth_trend(lprev, bprev, seasonal)\n                self.__smooth_seasonal(seasonal, lprev, bprev)\n                self.fitted[index] =y_hat\n\n            self.__update_res_variance(row, y_hat)\n\n    def predict(self, h, confidence = None):\n        \"\"\"\n        Predict the next h values of the target variable.\n\n        Arguments:\n\n        *h (int): Future time-steps to forecast\n        *confidence (Optional[float]): Confidence level to generate prediction intervals; None or values between (0,1)\n        \"\"\"\n\n        self.forecast = torch.tensor([])\n\n        len_s = self.seasonals.shape[0]\n\n        for i in range(1,h+1):\n            \n            damp_factor = torch.sum(torch.tensor([torch.pow(self.phi, x+1) for x in range(i+1)]))\n            k = int((h-1)/self.seasonal_periods)\n\n            step_forecast = torch.add(self.level, torch.mul(damp_factor, self.trend))\n            step_forecast = torch.add(step_forecast, self.seasonals[len_s+i-self.seasonal_periods*(k+1)])\n\n            self.forecast = torch.cat((self.forecast, step_forecast))\n\n        if confidence:\n            bounds = self.__get_confidence_interval(h, conf=confidence)\n            upper_bounds = torch.add(self.forecast, bounds)\n            lower_bounds = torch.sub(self.forecast, bounds)\n            \n            return self.forecast, (upper_bounds, lower_bounds)\n        else:\n            return self.forecast", "\nclass ETS_MNM(ETS_Model):\n\n    def __init__(self, dep_var, trend=None, seasonal=None, error_type=None, damped=False, seasonal_periods=None, **kwargs):\n        \"\"\"Implementation of ETS method with Multiplicative Errors, No Trend and Multiplicative Seasonality\"\"\"\n        self.trend = None\n        self.damped = False\n        self.seasonal = \"mul\"\n        self.seasonal_periods = seasonal_periods\n        self.error_type = \"mul\"\n\n        super().set_allowed_kwargs([\"alpha\", \"beta\", \"phi\", \"gamma\"])\n        super().__init__(dep_var, trend=self.trend,  seasonal=self.seasonal, error_type=self.error_type, seasonal_periods=self.seasonal_periods, \n                                damped=self.damped, **kwargs)\n        \n        initialize_params = [\"alpha\", \"gamma\"]\n\n        self.__initialize_params(initialize_params)\n\n        self.residuals = torch.tensor([])\n    \n    def __calculate_conf_level(self, conf):\n        \"\"\"Calculate the multiplier for prediction interval\"\"\"\n\n        self.c = super().calculate_conf_level(conf)\n\n    def __initialize_params(self, initialize_params):\n        \"\"\"Initialize model parameters\"\"\"\n\n        super().initialize_params(initialize_params)\n\n        self.initial_level = torch.tensor(self.init_components[\"level\"])\n        self.initial_seasonals = torch.tensor(self.init_components[\"seasonal\"])\n\n        self.alpha, self.beta, self.gamma, self.phi = torch.tensor(list(self.params.values()), dtype=torch.float32)\n    \n    def __update_res_variance(self, y, y_hat):\n        \"\"\"Update the residual variance\"\"\"\n\n        resid = torch.sub(y, y_hat)\n\n        self.residuals, self.residual_mean, self.residual_variance = super().update_res_variance(self.residuals, resid)\n        \n    def __get_confidence_interval(self, h, conf):\n        \"\"\"Get the confidence interval of the predictions\"\"\"\n        return super().future_sample_paths(h, conf)\n\n    def __smooth_level(self, lprev, seasonal):\n        \"\"\"Calculate the level\"\"\"\n\n        self.level = torch.mul(lprev, torch.add(1, torch.mul(self.alpha, self.error)))\n\n    def __smooth_error(self, y, y_hat):  \n        \"\"\"Calculate error\"\"\"\n        self.error = torch.divide(torch.sub(y, y_hat), y_hat)\n\n    def __smooth_seasonal(self, seasonal, lprev):\n        \"\"\"Calculate the level\"\"\"\n\n        seasonal = torch.mul(seasonal, torch.add(1, torch.mul(self.gamma, self.error)))\n        self.seasonals = torch.cat((self.seasonals, seasonal))\n\n    def fit(self):\n        \"\"\"\n        Fit the model to the data according to the equations:\n        y_t = l_{t-1}*s_{t-m}*(1 + e_t)\n        l_t = l_{t-1}*(1 + alpha*e_t)\n        s_t = s_{t-m}*(1 + gamma*e_t)\n        \"\"\"\n\n        self.fitted = torch.zeros(size=self.dep_var.shape)\n\n        for index, row in enumerate(self.dep_var):\n\n            if index == 0:\n                y_hat = row\n                self.level = self.initial_level\n                self.error = torch.tensor(0, dtype=torch.float32)\n                seasonal = self.initial_seasonals[0]\n                self.seasonals = seasonal\n                self.fitted[0] = row\n                \n            elif index < self.seasonal_periods:\n                seasonal = self.initial_seasonals[index]\n                y_hat = torch.mul(self.level,seasonal)\n                lprev = self.level\n                self.__smooth_error(row, y_hat)\n                self.__smooth_level(lprev, seasonal)\n                self.seasonals = torch.cat((self.seasonals, seasonal))\n\n                self.fitted[index] = y_hat\n                       \n            else:\n                seasonal = self.seasonals[-self.seasonal_periods]\n                y_hat = torch.mul(self.level,seasonal)\n                lprev = self.level\n                self.__smooth_error(row, y_hat)\n                self.__smooth_level(lprev, seasonal)\n                self.__smooth_seasonal(seasonal,lprev)\n\n                self.fitted[index] = y_hat\n            \n            self.__update_res_variance(row, y_hat)\n    \n    def predict(self, h, confidence = None):\n        \"\"\"\n        Predict the next h values of the target variable.\n\n        Arguments:\n\n        *h (int): Future time-steps to forecast\n        *confidence (Optional[float]): Confidence level to generate prediction intervals; None or values between (0,1)\n        \"\"\"\n            \n        self.forecast = torch.tensor([])\n        \n        len_s = self.seasonals.shape[0]\n\n        for i in range(1,h+1):\n\n            k = int((h-1)/self.seasonal_periods)\n            \n            step_forecast = torch.mul(self.level, self.seasonals[len_s+i-self.seasonal_periods*(k+1)])\n\n            self.forecast = torch.cat((self.forecast, step_forecast))\n                \n        if confidence:\n            bounds = self.__get_confidence_interval(h, conf=confidence)\n            upper_bounds = torch.add(self.forecast, bounds)\n            lower_bounds = torch.sub(self.forecast, bounds)\n            \n            return self.forecast, (upper_bounds, lower_bounds)\n        else:\n            return self.forecast", "\nclass ETS_MAM(ETS_Model):\n\n    def __init__(self, dep_var, trend=None, seasonal=None, error_type=None, damped=False, seasonal_periods=None, **kwargs):\n        \"\"\"Implementation of ETS method with Multiplicative Errors, Additive Trend and Multiplicative Seasonality\"\"\"\n        self.trend = \"add\"\n        self.damped = damped\n        self.seasonal = \"mul\"\n        self.seasonal_periods = seasonal_periods\n        self.error_type = \"mul\"\n\n        super().set_allowed_kwargs([\"alpha\", \"beta\", \"phi\", \"gamma\"])\n        super().__init__(dep_var, trend=self.trend,  seasonal=self.seasonal, error_type=self.error_type, seasonal_periods=self.seasonal_periods, \n                                damped=self.damped, **kwargs)\n        \n        initialize_params = [\"alpha\", \"beta\", \"gamma\"]\n        if self.damped:\n            initialize_params.append(\"phi\")\n        self.__initialize_params(initialize_params)\n\n        self.residuals = torch.tensor([])\n    \n    def __calculate_conf_level(self, conf):\n        \"\"\"Calculate the multiplier for prediction interval\"\"\"\n\n        self.c = super().calculate_conf_level(conf)\n\n    def __initialize_params(self, initialize_params):\n        \"\"\"Initialize model parameters\"\"\"\n\n        super().initialize_params(initialize_params)\n\n        self.initial_level = torch.tensor(self.init_components[\"level\"])\n        self.initial_trend = torch.tensor(self.init_components[\"trend\"])\n        self.initial_seasonals = torch.tensor(self.init_components[\"seasonal\"])\n\n        self.alpha, self.beta, self.gamma, self.phi = torch.tensor(list(self.params.values()), dtype=torch.float32)\n    \n    def __update_res_variance(self, y, y_hat):\n        \"\"\"Update the residual variance\"\"\"\n\n        resid = torch.sub(y, y_hat)\n\n        self.residuals, self.residual_mean, self.residual_variance = super().update_res_variance(self.residuals, resid)\n        \n    def __get_confidence_interval(self, h, conf):\n        \"\"\"Get the confidence interval of the predictions\"\"\"        \n        return super().future_sample_paths(h, conf)\n    \n    def __smooth_level(self, lprev, bprev):\n        \"\"\"Calculate the level\"\"\"\n\n        self.level = torch.add(lprev, torch.mul(self.phi, bprev))\n        self.level = torch.mul(self.level, torch.add(1, torch.mul(self.alpha, self.error)))\n    \n    def __smooth_trend(self, lprev, bprev):\n        \"\"\"Calculate trend\"\"\"\n        self.trend = torch.mul(torch.mul(self.error, self.beta), torch.add(lprev , torch.mul(self.phi, bprev)))\n        self.trend = torch.add(self.trend, torch.mul(self.phi, bprev))\n\n    def __smooth_seasonal(self):\n        \"\"\"Calculate seasonal\"\"\"\n        seasonal = torch.mul(self.seasonals[-self.seasonal_periods], torch.add(1, torch.mul(self.gamma, self.error)))\n        self.seasonals = torch.cat((self.seasonals, seasonal))\n    \n    def __smooth_error(self, y, y_hat):\n        \"\"\"Calculate error\"\"\"\n        self.error = torch.divide(torch.sub(y, y_hat), y_hat)\n\n    def fit(self):\n        \"\"\"\n        Fit the model to the data according to the equations:\n        y_t = (l_{t-1} + phi*b_{t-1})*s_{t-m}*(1 + e_t)\n        l_t = (l_{t-1} + phi*b_{t-1})*(1 + alpha*e_t)\n        b_t = phi*b_{t-1} + beta*(l_{t-1} + phi*b_{t-1})*e_t\n        s_t = s_{t-m}*(1 + gamma*e_t)\n        \"\"\"\n\n        self.fitted = torch.zeros(size=self.dep_var.shape)\n\n        for index, row in enumerate(self.dep_var):\n\n            if index == 0:\n                y_hat = row\n                self.level = self.initial_level\n                self.trend = self.initial_trend\n                self.error = torch.tensor(0, dtype=torch.float32)\n                seasonal = self.initial_seasonals[0]\n                self.seasonals = seasonal\n                self.fitted[0] = row\n            \n            elif index < self.seasonal_periods:\n                seasonal = self.initial_seasonals[index]\n                y_hat = torch.mul(torch.add(self.level, torch.mul(self.phi, self.trend)), seasonal)\n                lprev, bprev = self.level, self.trend\n                self.__smooth_error(row, y_hat)\n                self.__smooth_level(lprev, bprev)\n                self.__smooth_trend(lprev, bprev)\n                self.seasonals = torch.cat((self.seasonals, seasonal))\n\n                self.fitted[index] = y_hat\n            \n            else:\n                seasonal = self.seasonals[-self.seasonal_periods]\n                y_hat = torch.mul(torch.add(self.level, torch.mul(self.phi, self.trend)), seasonal)\n                lprev, bprev = self.level, self.trend\n                self.__smooth_error(row, y_hat)\n                self.__smooth_level(lprev, bprev)\n                self.__smooth_trend(lprev, bprev)\n                self.__smooth_seasonal()\n\n                self.fitted[index] = y_hat\n            \n            self.__update_res_variance(row, y_hat)\n\n    \n    def predict(self, h, confidence = None):\n        \"\"\"\n        Predict the next h values of the target variable.\n\n        Arguments:\n\n        *h (int): Future time-steps to forecast\n        *confidence (Optional[float]): Confidence level to generate prediction intervals; None or values between (0,1)\n        \"\"\"\n\n        self.forecast = torch.tensor([])\n        \n        len_s = self.seasonals.shape[0]\n\n        for i in range(1,h+1):\n            \n            damp_factor = torch.sum(torch.tensor([torch.pow(self.phi, x+1) for x in range(i+1)]))\n            k = int((h-1)/self.seasonal_periods)\n            \n            step_forecast = torch.mul(self.seasonals[len_s+i-self.seasonal_periods*(k+1)], torch.add(self.level, torch.mul(damp_factor, self.trend)))\n\n            self.forecast = torch.cat((self.forecast, step_forecast))\n\n        if confidence:\n            bounds = self.__get_confidence_interval(h, conf=confidence)\n            upper_bounds = torch.add(self.forecast, bounds)\n            lower_bounds = torch.sub(self.forecast, bounds)\n            \n            return self.forecast, (upper_bounds, lower_bounds)\n        else:\n            return self.forecast"]}
{"filename": "chronokit/exponential_smoothing/models/__init__.py", "chunked_list": ["from .ets_models import *\nfrom .smoothing import *"]}
{"filename": "chronokit/exponential_smoothing/models/smoothing.py", "chunked_list": ["import numpy as np\nimport torch\nfrom chronokit.exponential_smoothing.model import Smoothing_Model\n\n\"\"\"\nExponential Smoothing models for time series forecasting.\nAll methods have been implemented from chapter 7 of the textbook as a reference.\n'Hyndman, Rob J., and George Athanasopoulos. Forecasting: principles\nand practice. OTexts, 2014.'\n\"\"\"", "and practice. OTexts, 2014.'\n\"\"\"\n\nclass SES(Smoothing_Model):\n    def __init__(self, dep_var, trend=None, seasonal=None, seasonal_periods=None, damped=False, indep_var=None, **kwargs):\n        \"\"\"Implementation of Simple Exponential Smoothing\"\"\"\n        self.trend = None\n        self.damped = False\n        self.seasonal = None\n        self.seasonal_periods = None\n\n        super().set_allowed_kwargs([\"alpha\", \"beta\", \"phi\", \"gamma\"])\n        \n        super().__init__(dep_var, self.trend, self.seasonal, self.seasonal_periods, self.damped, **kwargs)\n        \n        initialize_params = [\"alpha\"]\n        self.__initialize_params(initialize_params)\n\n    def __initialize_params(self, initialize_params):\n        \"\"\"Initialize the model parameters\"\"\"\n        super().initialize_params(initialize_params)\n\n        self.initial_level = torch.tensor(self.init_components[\"level\"])\n\n        self.alpha, self.beta, self.gamma, self.phi = torch.tensor(list(self.params.values()), dtype=torch.float32)\n\n    def __smooth_level(self, y, lprev):\n        \"\"\"Calculate level\"\"\"\n        self.level =  torch.add(torch.mul(self.alpha, y),torch.mul((1 - self.alpha), lprev))\n    \n    def fit(self):\n        \"\"\"\n        Fit the model to the data according to the equations:\n        l_t =  alpha*y_t + (1 - alpha)*l_{t-1}\n        \"\"\"\n        self.fitted = torch.zeros(self.dep_var.shape[0])\n        for index,row in enumerate(self.dep_var):\n            if index == 0:\n                self.level = self.initial_level\n                self.fitted[0] = row\n            else:\n                y_hat = self.level\n                lprev = self.level\n                self.__smooth_level(row, lprev)\n                self.fitted[index] = y_hat  \n    \n    def predict(self,h):\n        \"\"\"\n        Predict the next h values of the target variable.\n\n        Arguments:\n\n        *h (int): Future time-steps to forecast\n        \"\"\"\n        self.forecast = torch.tensor([])\n        for i in range(1,h+1):\n            step_forecast = self.level\n            self.forecast = torch.cat((self.forecast,step_forecast))\n        return self.forecast", "\n\nclass HoltTrend(Smoothing_Model):\n    def __init__(self, dep_var, trend=\"add\", seasonal=None, seasonal_periods=None, damped=False, indep_var=None, **kwargs):\n        \"\"\"Implementation of Holt's Trend Method\"\"\"\n        self.trend = \"add\"\n        self.damped = damped\n        self.seasonal = None\n        self.seasonal_periods = None\n\n        super().set_allowed_kwargs([\"alpha\", \"beta\", \"phi\", \"gamma\"])\n        super().__init__(dep_var, self.trend, self.seasonal, self.seasonal_periods, self.damped, **kwargs)\n        \n        initialize_params = [\"alpha\", \"beta\"]\n        if self.damped:\n            initialize_params.append(\"phi\")\n\n        self.__initialize_params(initialize_params)\n\n\n    def __initialize_params(self, initialize_params):\n        \"\"\"Initialize the model parameters\"\"\"\n\n        super().initialize_params(initialize_params)\n\n        self.initial_level = torch.tensor(self.init_components[\"level\"])\n        self.initial_trend = torch.tensor(self.init_components[\"trend\"])\n\n        self.alpha, self.beta, self.gamma, self.phi = torch.tensor(list(self.params.values()), dtype=torch.float32)\n\n    def __smooth_level(self, y, lprev, bprev):\n        \"\"\"Calculate level\"\"\"\n        self.level = torch.mul(torch.sub(1,self.alpha),torch.add(lprev, torch.mul(self.phi, bprev)))\n        self.level = torch.add(torch.mul(self.alpha, y), self.level)\n\n    def __smooth_trend(self, lprev, bprev):\n        \"Calculate trend\"\n        self.trend = torch.mul(self.beta, torch.sub(self.level, lprev))\n        self.trend = torch.add(self.trend, torch.mul(torch.sub(1, self.beta), torch.mul(self.phi, bprev)))\n\n    def fit(self):\n        \"\"\"\n        Fit the model to the data according to the equations:\n        l_t = alpha * y_t + (1 - alpha) * (l_{t-1} + b_{t-1})\n        b_t = beta * (l_t - l_{t-1}) + (1 - beta)*phi*b_{t-1}\n        \"\"\"\n        \n        self.fitted = torch.zeros(size=self.dep_var.shape)\n        for index, row in enumerate(self.dep_var):\n            if index == 0:\n                self.level = self.initial_level\n                self.trend = self.initial_trend\n                self.fitted[0] = row[0]\n            else:\n                y_hat = torch.add(self.level, torch.mul(self.phi, self.trend))\n                lprev, bprev = self.level, self.trend\n                self.__smooth_level(row, lprev, bprev)\n                self.__smooth_trend(lprev, bprev)\n                self.fitted[index] = y_hat\n        \n\n    def predict(self, h):\n        \"\"\"\n        Predict the next h values of the target variable.\n\n        Arguments:\n\n        *h (int): Future time-steps to forecast\n        \"\"\"\n        \n        self.forecast = torch.tensor([])\n        for i in range(1,h+1):\n\n            damp_factor = torch.sum(torch.tensor([torch.pow(self.phi, x+1) for x in range(i)]))\n\n            step_forecast = torch.add(self.level, torch.mul(damp_factor, self.trend))\n            self.forecast = torch.cat((self.forecast, step_forecast))\n            \n        return self.forecast", "    \nclass HoltWinters(Smoothing_Model):\n    def __init__(self, dep_var, trend=\"add\", seasonal=\"add\", seasonal_periods=4, damped=False, indep_var=None, **kwargs):\n        \"Implementation of Holt-Winters' Seasonal Method\"\n        self.trend = trend\n        self.damped = damped\n        self.seasonal = seasonal\n        self.seasonal_periods = seasonal_periods\n\n        super().set_allowed_kwargs([\"alpha\", \"beta\", \"phi\", \"gamma\"])\n        super().__init__(dep_var, self.trend, self.seasonal, self.seasonal_periods, self.damped, **kwargs)\n        \n        initialize_params = [\"alpha\", \"beta\", \"gamma\"]\n        if self.damped:\n            initialize_params.append(\"phi\")\n\n        self.__initialize_params(initialize_params)\n\n    def __initialize_params(self, initialize_params):\n        \"\"\"Initialize the model parameters\"\"\"\n\n        super().initialize_params(initialize_params)\n\n        self.initial_level = torch.tensor(self.init_components[\"level\"])\n        self.initial_trend = torch.tensor(self.init_components[\"trend\"])\n        self.initial_seasonals = torch.tensor(self.init_components[\"seasonal\"])\n\n        self.alpha, self.beta, self.gamma, self.phi = torch.tensor(list(self.params.values()), dtype=torch.float32)\n\n\n    def __smooth_level(self, y, lprev, bprev, seasonal):\n        \"\"\"Calculate level\"\"\"\n\n        if self.seasonal == \"add\":\n\n            self.level = torch.mul(torch.sub(1,self.alpha),torch.add(lprev, torch.mul(self.phi, bprev)))\n            self.level = torch.add(torch.mul(self.alpha, torch.sub(y, seasonal)), self.level)\n        \n        elif self.seasonal == \"mul\":\n\n            self.level = torch.mul(torch.sub(1,self.alpha),torch.add(lprev, torch.mul(self.phi, bprev)))\n            self.level = torch.add(torch.mul(self.alpha, torch.divide(y, seasonal)), self.level)\n\n\n    def __smooth_trend(self, lprev, bprev):\n        \"\"\"Calculate trend\"\"\"\n\n        self.trend = torch.mul(self.beta, torch.sub(self.level, lprev))\n        self.trend = torch.add(self.trend, torch.mul(torch.sub(1, self.beta), torch.mul(self.phi, bprev)))\n\n    def __smooth_seasonal(self,  y, lprev, bprev, seasonal):\n        '''This function calculates the smoothed trend for a given beta and level values'''\n        \n        if self.seasonal == \"add\":\n\n            seasonal = torch.mul(torch.sub(1,self.gamma), seasonal)\n            seasonal = torch.add(seasonal, torch.mul(self.gamma, torch.sub(torch.sub(y, lprev), torch.mul(self.phi, bprev))))\n            self.seasonals = torch.cat((self.seasonals, seasonal))\n\n        elif self.seasonal == \"mul\":\n\n            seasonal = torch.mul(torch.sub(1,self.gamma), seasonal)\n            seasonal = torch.add(seasonal, torch.mul(self.gamma, torch.divide(y, torch.add(lprev,torch.mul(self.phi, bprev)))))\n            self.seasonals = torch.cat((self.seasonals, seasonal))\n\n\n    def fit(self):\n        \"\"\"\n        Fit the model to the data according to the equations:\n        \n        If seasonal is additive:\n        l_t = alpha*(y_t - s_{t-m}) + (1 - alpha)*(l_{t-1} + b_{t-1})\n        b_t = beta * (l_t - l_{t-1}) + (1 - beta)*phi*b_{t-1}\n        s_t = gamma*(y_t - l_{t-1} - phi*b_{t-1}) + (1 - y)*s_{t-m}\n\n        If seasonal is multiplicative:\n        l_t = alpha*(y_t/s_{t-m}) + (1 - alpha)*(l_{t-1} + b_{t-1})\n        b_t = beta * (l_t - l_{t-1}) + (1 - beta)*phi*b_{t-1}\n        s_t = gamma*(y_t/(l_{t-1} + phi*b_{t-1})) + (1 - y)*s_{t-m}\n        \"\"\"\n        \n        self.fitted = torch.zeros(size=self.dep_var.shape)\n\n        for index, row in enumerate(self.dep_var):\n\n            if index == 0:\n                self.level = self.initial_level\n                self.trend = self.initial_trend\n                seasonal = self.initial_seasonals[0]\n                self.seasonals = torch.tensor([seasonal])\n                self.fitted[0] = row\n            \n            elif index < self.seasonal_periods:\n\n                seasonal = self.initial_seasonals[index]\n                \n                if self.seasonal == \"add\":\n                    y_hat = torch.add(seasonal, torch.add(self.level, torch.mul(self.phi, self.trend)))\n                elif self.seasonal == \"mul\":\n                    y_hat = torch.mul(seasonal, torch.add(self.level, torch.mul(self.phi, self.trend)))\n\n                lprev, bprev = self.level, self.trend\n                self.__smooth_level(row, lprev, bprev, seasonal)\n                self.__smooth_trend(lprev, bprev)\n\n                self.seasonals = torch.cat((self.seasonals, seasonal))\n\n                self.fitted[index] = y_hat\n                \n            \n            else:\n\n                seasonal = self.seasonals[-self.seasonal_periods]\n                \n                if self.seasonal == \"add\":\n                    y_hat = torch.add(seasonal, torch.add(self.level, torch.mul(self.phi, self.trend)))\n                elif self.seasonal == \"mul\":\n                    y_hat = torch.mul(seasonal, torch.add(self.level, torch.mul(self.phi, self.trend)))\n\n                lprev, bprev = self.level, self.trend\n                self.__smooth_level(row, lprev, bprev, seasonal)\n                self.__smooth_trend(lprev, bprev)\n                self.__smooth_seasonal(row, lprev, bprev, seasonal)\n\n                self.fitted[index] = y_hat\n            \n\n    def predict(self, h):\n        \"\"\"\n        Predict the next h values of the target variable.\n\n        Arguments:\n\n        *h (int): Future time-steps to forecast\n        \"\"\"\n        \n        self.forecast = torch.tensor([])\n        len_seasonal = self.seasonals.shape[0]\n        for i in range(1,h+1):\n       \n            damp_factor = torch.sum(torch.tensor([torch.pow(self.phi, x+1) for x in range(i)]))\n            k = int((i-1)/self.seasonal_periods)\n   \n            step_forecast = torch.add(self.level, torch.mul(damp_factor, self.trend))\n\n            if self.seasonal == \"mul\":\n                step_forecast = torch.mul(step_forecast, self.seasonals[len_seasonal+i-self.seasonal_periods*(k+1)])\n            elif self.seasonal == \"add\":\n                step_forecast = torch.add(step_forecast, self.seasonals[len_seasonal+i-self.seasonal_periods*(k+1)])\n            \n            self.forecast = torch.cat((self.forecast, step_forecast))\n            \n        return self.forecast", "\n\n\n            \n"]}
{"filename": "chronokit/exponential_smoothing/initialization/smoothing_methods.py", "chunked_list": ["import numpy as np\n\n\"\"\"ETS methods to use for initialization of parameters\"\"\"\n\ndef simple_exp(dep_var, init_components, params):\n\n    init_lvl, init_trend, init_seasonals, seasonal_periods = init_components          \n\n    alpha = params[0]\n\n    errors = []\n\n    for index, row in enumerate(dep_var):\n\n        if index == 0:\n\n            lvl = init_lvl\n            errors.append(0)\n\n        else:               \n\n            y_hat = lvl\n            error = row.numpy()[0] - y_hat\n            \n\n            lprev = lvl\n            lvl = alpha*row.numpy()[0] + (1-alpha)*lprev\n\n            errors.append(error)\n\n    return errors", "\ndef holt_trend(dep_var, init_components, params):\n    \n    init_lvl, init_trend, init_seasonals, seasonal_periods = init_components           \n    alpha, beta = params\n\n    errors = []\n\n    for index, row in enumerate(dep_var):\n\n        if index == 0:\n\n            lvl = init_lvl\n            trend = init_trend\n            errors.append(0) \n\n        else:               \n\n            y_hat = lvl + trend \n            error = row.numpy()[0] - y_hat\n\n            lprev, bprev = lvl, trend\n\n            lvl = alpha*row.numpy()[0] + (1-alpha)*(lprev+bprev)\n            trend = beta*(lvl-lprev) + (1-beta)*bprev\n\n            errors.append(error)\n\n    return errors", "\ndef holt_damped_trend(dep_var, init_components, params):\n    \n    init_lvl, init_trend, init_seasonals, seasonal_periods = init_components           \n    alpha, beta, phi = params\n\n    errors = []\n\n    for index, row in enumerate(dep_var):\n\n        if index == 0:\n\n            lvl = init_lvl\n            trend = init_trend\n            errors.append(0) \n\n        else:               \n\n            y_hat = lvl + phi*trend \n            error = row.numpy()[0] - y_hat\n\n            lprev, bprev = lvl, trend\n\n            lvl = alpha*row.numpy()[0] + (1-alpha)*(lprev+phi*bprev)\n            trend = beta*(lvl-lprev) + (1-beta)*phi*bprev\n\n            errors.append(error)\n\n    return errors", "\ndef hw_add(dep_var, init_components, params):\n    \n    init_lvl, init_trend, init_seasonals, seasonal_periods = init_components           \n    alpha, beta, gamma = params\n\n    errors = []\n\n    for index, row in enumerate(dep_var):\n\n        if index == 0:\n\n            lvl = init_lvl\n            trend = init_trend\n            seasonal = init_seasonals[0]\n            seasonals = [seasonal]\n            errors.append(0)\n\n        elif index < seasonal_periods:            \n\n            seasonal = init_seasonals[index]     \n\n            y_hat = lvl + trend + seasonal\n            error = row.numpy()[0] - y_hat\n\n            lprev, bprev = lvl, trend\n\n            seasonal_t = (1-gamma)*seasonal + gamma*(row.numpy()[0]-lprev-bprev)\n            lvl = alpha*(row.numpy()[0]-seasonal) + (1-alpha)*(lprev+ bprev)\n            trend = beta*(lvl - lprev) + (1-beta)*bprev\n\n            seasonals.append(seasonal_t)\n            errors.append(error)            \n\n        else:               \n\n            seasonal = seasonals[index-seasonal_periods]  \n\n            y_hat = lvl + trend + seasonal\n            error = row.numpy()[0] - y_hat\n\n            lprev, bprev = lvl, trend\n\n            seasonal_t = (1-gamma)*seasonal + gamma*(row.numpy()[0]-lprev-bprev)\n            lvl = alpha*(row.numpy()[0]-seasonal) + (1-alpha)*(lprev+ bprev)\n            trend = beta*(lvl - lprev) + (1-beta)*bprev\n\n            seasonals.append(seasonal_t)\n            errors.append(error)         \n\n    return errors", "\ndef hw_damped_add(dep_var, init_components, params):\n    \n    init_lvl, init_trend, init_seasonals, seasonal_periods = init_components           \n    alpha, beta, gamma, phi = params\n\n    errors = []\n\n    for index, row in enumerate(dep_var):\n\n        if index == 0:\n\n            lvl = init_lvl\n            trend = init_trend\n            seasonal = init_seasonals[0]\n            seasonals = [seasonal]\n            errors.append(0)\n\n        elif index < seasonal_periods:            \n\n            seasonal = init_seasonals[index]     \n\n            y_hat = lvl + phi*trend + seasonal\n            error = row.numpy()[0] - y_hat\n\n            lprev, bprev = lvl, trend\n\n            seasonal_t = (1-gamma)*seasonal + gamma*(row.numpy()[0]-lprev-phi*bprev)\n            lvl = alpha*(row.numpy()[0]-seasonal) + (1-alpha)*(lprev + phi*bprev)\n            trend = beta*(lvl - lprev) + (1-beta)*phi*bprev\n\n            seasonals.append(seasonal_t)\n            errors.append(error)            \n\n        else:               \n\n            seasonal = seasonals[index-seasonal_periods]  \n\n            y_hat = lvl + phi*trend + seasonal\n            error = row.numpy()[0] - y_hat\n\n            lprev, bprev = lvl, trend\n\n            seasonal_t = (1-gamma)*seasonal + gamma*(row.numpy()[0]-lprev-phi*bprev)\n            lvl = alpha*(row.numpy()[0]-seasonal) + (1-alpha)*(lprev + phi*bprev)\n            trend = beta*(lvl - lprev) + (1-beta)*phi*bprev\n\n            seasonals.append(seasonal_t)\n            errors.append(error)             \n\n    return errors", "\ndef hw_mul(dep_var, init_components, params):\n    \n    init_lvl, init_trend, init_seasonals, seasonal_periods = init_components           \n    alpha, beta, gamma = params\n\n    errors = []\n\n    for index, row in enumerate(dep_var):\n\n        if index == 0:\n\n            lvl = init_lvl\n            trend = init_trend\n            seasonal = init_seasonals[0]\n            seasonals = [seasonal]\n            errors.append(0)\n\n        elif index < seasonal_periods:            \n\n            seasonal = init_seasonals[index]     \n\n            y_hat = (lvl + trend)*seasonal\n            error = row.numpy()[0] - y_hat\n\n            lprev, bprev = lvl, trend\n\n            seasonal_t = (1-gamma)*seasonal + gamma*(row.numpy()[0]/(lprev+bprev))\n            lvl = alpha*(row.numpy()[0]/seasonal) + (1-alpha)*(lprev + bprev)\n            trend = beta*(lvl - lprev) + (1-beta)*bprev\n\n            seasonals.append(seasonal_t)\n            errors.append(error)            \n\n        else:               \n\n            seasonal = seasonals[index-seasonal_periods]  \n\n            y_hat = (lvl + trend)*seasonal\n            error = row.numpy()[0] - y_hat\n\n            lprev, bprev = lvl, trend\n\n            seasonal_t = (1-gamma)*seasonal + gamma*(row.numpy()[0]/(lprev+bprev))\n            lvl = alpha*(row.numpy()[0]/seasonal) + (1-alpha)*(lprev + bprev)\n            trend = beta*(lvl - lprev) + (1-beta)*bprev\n\n            seasonals.append(seasonal_t)\n            errors.append(error)            \n        \n\n    return errors", "\ndef hw_damped_mul(dep_var, init_components, params):\n    \n    init_lvl, init_trend, init_seasonals, seasonal_periods = init_components           \n    alpha, beta, gamma, phi = params\n\n    errors = []\n\n    for index, row in enumerate(dep_var):\n\n        if index == 0:\n\n            lvl = init_lvl\n            trend = init_trend\n            seasonal = init_seasonals[0]\n            seasonals = [seasonal]\n            errors.append(0)\n\n        elif index < seasonal_periods:            \n\n            seasonal = init_seasonals[index]     \n\n            y_hat = (lvl + phi*trend)*seasonal\n            error = row.numpy()[0] - y_hat\n\n            lprev, bprev = lvl, trend\n\n            seasonal_t = (1-gamma)*seasonal + gamma*(row.numpy()[0]/(lprev+phi*bprev))\n            lvl = alpha*(row.numpy()[0]/seasonal) + (1-alpha)*(lprev + phi*bprev)\n            trend = beta*(lvl - lprev) + (1-beta)*phi*bprev\n\n            seasonals.append(seasonal_t)\n            errors.append(error)            \n\n        else:               \n\n            seasonal = seasonals[index-seasonal_periods]  \n\n            y_hat = (lvl + phi*trend)*seasonal\n            error = row.numpy()[0] - y_hat\n\n            lprev, bprev = lvl, trend\n\n            seasonal_t = (1-gamma)*seasonal + gamma*(row.numpy()[0]/(lprev+phi*bprev))\n            lvl = alpha*(row.numpy()[0]/seasonal) + (1-alpha)*(lprev + phi*bprev)\n            trend = beta*(lvl - lprev) + (1-beta)*phi*bprev\n\n            seasonals.append(seasonal_t)\n            errors.append(error)                     \n\n    return errors"]}
{"filename": "chronokit/exponential_smoothing/initialization/ets_methods.py", "chunked_list": ["import numpy as np\n\n\"\"\"ETS methods to use for initialization of parameters\"\"\"\n\ndef ANN(dep_var, init_components, params):\n\n    init_lvl, init_trend, init_seasonals, seasonal_periods = init_components\n            \n    alpha = params[0]\n\n    errors = []\n\n    for index, row in enumerate(dep_var):\n\n        if index == 0:\n\n            lvl = init_lvl\n            errors.append(0)\n\n        else:               \n\n            y_hat = lvl\n            error = row.numpy()[0] - y_hat\n\n            \n\n            lvl = lvl + alpha*error\n\n            errors.append(error)\n\n    return errors", "\ndef ANA(dep_var, init_components, params):\n    \n    init_lvl, init_trend, init_seasonals, seasonal_periods = init_components      \n    alpha, gamma = params\n\n    errors = []\n\n    for index, row in enumerate(dep_var):\n\n        if index == 0:\n\n            lvl = init_lvl\n            seasonal = init_seasonals[0]\n            seasonals = [seasonal]\n            errors.append(0)\n\n        elif index < seasonal_periods:            \n\n            seasonal = init_seasonals[index]     \n\n            y_hat = lvl +seasonal\n            error = row.numpy()[0] - y_hat\n\n            lprev = lvl\n\n            seasonal_t = seasonal+(gamma*error)\n            lvl = lprev + alpha*error\n\n            seasonals.append(seasonal_t)\n            errors.append(error)            \n\n        else:               \n\n            seasonal = seasonals[index-seasonal_periods]  \n\n            y_hat = lvl + seasonal\n            error = row.numpy()[0] - y_hat\n\n            lprev = lvl\n\n            seasonal_t = seasonal+(gamma*error)\n            lvl = lprev + alpha*error\n\n            seasonals.append(seasonal_t)\n            errors.append(error)\n\n    return errors", "\ndef ANM(dep_var, init_components, params):\n    \n    init_lvl, init_trend, init_seasonals, seasonal_periods = init_components          \n    alpha, gamma = params\n\n    errors = []\n\n    for index, row in enumerate(dep_var):\n\n        if index == 0:\n\n            lvl = init_lvl\n            seasonal = init_seasonals[0]\n            seasonals = [seasonal]\n            errors.append(0)\n\n        elif index < seasonal_periods:            \n\n            seasonal = init_seasonals[index]     \n\n            y_hat = lvl*seasonal\n            error = row.numpy()[0] - y_hat\n\n            lprev = lvl\n\n            seasonal_t = seasonal+ gamma*error/lprev\n            lvl = lprev + alpha*error/seasonal\n\n            seasonals.append(seasonal_t)\n            errors.append(error)            \n\n        else:               \n\n            seasonal = seasonals[index-seasonal_periods]  \n\n            y_hat = lvl*seasonal\n            error = row.numpy()[0] - y_hat\n\n            lprev = lvl\n\n            seasonal_t = seasonal+ gamma*error/lprev\n            lvl = lprev + alpha*error/seasonal\n\n            seasonals.append(seasonal_t)\n            errors.append(error)            \n\n    return errors", "\ndef MNM(dep_var, init_components, params):\n    \n    init_lvl, init_trend, init_seasonals, seasonal_periods = init_components           \n    alpha, gamma = params\n\n    errors = []\n\n    for index, row in enumerate(dep_var):\n\n        if index == 0:\n\n            lvl = init_lvl\n            seasonal = init_seasonals[0]\n            seasonals = [seasonal]\n            errors.append(0)\n\n        elif index < seasonal_periods:            \n\n            seasonal = init_seasonals[index]     \n\n            y_hat = lvl*seasonal\n            error = (row.numpy()[0] - y_hat)/y_hat\n\n            lprev = lvl\n\n            seasonal_t = seasonal*(1 + gamma*error)\n            lvl = lprev*(1 + alpha*error)\n\n            seasonals.append(seasonal_t)\n            errors.append(error)            \n\n        else:               \n\n            seasonal = seasonals[index-seasonal_periods]  \n\n            y_hat = lvl*seasonal\n            error = (row.numpy()[0] - y_hat)/y_hat\n\n            lprev = lvl\n\n            seasonal_t = seasonal*(1 + gamma*error)\n            lvl = lprev*(1 + alpha*error)\n\n            seasonals.append(seasonal_t)\n            errors.append(error)            \n\n    return errors", "\ndef MNA(dep_var, init_components, params):\n    \n    init_lvl, init_trend, init_seasonals, seasonal_periods = init_components           \n    alpha, gamma = params\n\n    errors = []\n\n    for index, row in enumerate(dep_var):\n\n        if index == 0:\n\n            lvl = init_lvl\n            seasonal = init_seasonals[0]\n            seasonals = [seasonal]\n            errors.append(0)\n\n        elif index < seasonal_periods:            \n\n            seasonal = init_seasonals[index]     \n\n            y_hat = lvl + seasonal\n            error = (row.numpy()[0] - y_hat)/y_hat\n\n            lprev = lvl\n\n            seasonal_t = seasonal + gamma*error*(lprev+seasonal)\n            lvl = lprev + alpha*error*(lprev+ seasonal)\n\n            seasonals.append(seasonal_t)\n            errors.append(error)            \n\n        else:               \n\n            seasonal = seasonals[index-seasonal_periods]  \n\n            y_hat = lvl + seasonal\n            error = (row.numpy()[0] - y_hat)/y_hat\n\n            lprev = lvl\n\n            seasonal_t = seasonal + gamma*error*(lprev+seasonal)\n            lvl = lprev + alpha*error*(lprev+ seasonal)\n\n            seasonals.append(seasonal_t)\n            errors.append(error)\n\n    return errors", "\n\ndef MNN(dep_var, init_components, params):\n\n    init_lvl, init_trend, init_seasonals, seasonal_periods = init_components            \n    alpha = params[0]\n\n    errors = []\n\n    for index, row in enumerate(dep_var):\n\n        if index == 0:\n\n            lvl = init_lvl\n            errors.append(0)\n\n        else:               \n\n            y_hat = lvl\n            error = (row.numpy()[0] - y_hat)/y_hat\n\n            lvl = lvl*(1+alpha*error)\n\n            errors.append(error)\n\n    return errors", "\ndef AAdA(dep_var, init_components, params):\n    \n    init_lvl, init_trend, init_seasonals, seasonal_periods = init_components           \n    alpha, beta, gamma, phi = params\n\n    errors = []\n\n    for index, row in enumerate(dep_var):\n\n        if index == 0:\n\n            lvl = init_lvl\n            trend = init_trend\n            seasonal = init_seasonals[0]\n            seasonals = [seasonal]\n            errors.append(0)\n\n        elif index < seasonal_periods:            \n\n            seasonal = init_seasonals[index]     \n\n            y_hat = lvl + phi*trend + seasonal\n            error = row.numpy()[0] - y_hat\n            \n            lprev, bprev = lvl, trend\n\n            seasonal_t = seasonal + gamma*error\n            lvl = lprev + phi*bprev + alpha*error\n            trend = phi*bprev + beta*error\n\n\n            seasonals.append(seasonal_t)\n            errors.append(error)            \n\n        else:               \n\n            seasonal = seasonals[index-seasonal_periods]  \n\n            y_hat = lvl + phi*trend + seasonal\n            error = row.numpy()[0] - y_hat\n\n            lprev, bprev = lvl, trend\n\n            seasonal_t = seasonal + gamma*error\n            lvl = lprev + phi*bprev + alpha*error\n            trend = phi*bprev + beta*error\n\n            seasonals.append(seasonal_t)\n            errors.append(error)\n\n    return errors", "\ndef MAdA(dep_var, init_components, params):\n    \n    init_lvl, init_trend, init_seasonals, seasonal_periods = init_components           \n    alpha, beta, gamma, phi = params\n\n    errors = []\n\n    for index, row in enumerate(dep_var):\n\n        if index == 0:\n\n            lvl = init_lvl\n            trend = init_trend\n            seasonal = init_seasonals[0]\n            seasonals = [seasonal]\n            errors.append(0)\n\n        elif index < seasonal_periods:            \n\n            seasonal = init_seasonals[index]     \n\n            y_hat = lvl + phi*trend + seasonal\n            error = (row.numpy()[0] - y_hat)/y_hat\n            \n            lprev, bprev = lvl, trend\n\n            seasonal_t = seasonal + gamma*error\n            lvl = lprev + phi*bprev + alpha*error*(lprev + phi*bprev + seasonal)\n            trend = phi*bprev + beta*error*(lprev + phi*bprev + seasonal)\n\n            seasonals.append(seasonal_t)\n            errors.append(error)            \n\n        else:               \n\n            seasonal = seasonals[index-seasonal_periods]  \n\n            y_hat = lvl + phi*trend + seasonal\n            error = (row.numpy()[0] - y_hat)/y_hat\n\n            lprev, bprev = lvl, trend\n\n            seasonal_t = seasonal + gamma*error\n            lvl = lprev + phi*bprev + alpha*error*(lprev + phi*bprev + seasonal)\n            trend = phi*bprev + beta*error*(lprev + phi*bprev + seasonal)\n\n            seasonals.append(seasonal_t)\n            errors.append(error)\n\n    return errors", "\ndef AAdM(dep_var, init_components, params):\n    \n    init_lvl, init_trend, init_seasonals, seasonal_periods = init_components           \n    alpha, beta, gamma, phi = params\n\n    errors = []\n\n    for index, row in enumerate(dep_var):\n\n        if index == 0:\n\n            lvl = init_lvl\n            trend = init_trend\n            seasonal = init_seasonals[0]\n            seasonals = [seasonal]\n            errors.append(0)\n\n        elif index < seasonal_periods:            \n\n            seasonal = init_seasonals[index]     \n\n            y_hat = (lvl + phi*trend)*seasonal\n            error = row.numpy()[0] - y_hat\n            \n            seasonal_t = seasonal + (gamma*error)/(lvl + phi*trend)\n            lvl = lvl + phi*trend + alpha*error/seasonal\n            trend = phi*trend + beta*error/seasonal\n\n            seasonals.append(seasonal_t)\n            errors.append(error)            \n\n        else:               \n\n            seasonal = seasonals[index-seasonal_periods]  \n\n            y_hat = (lvl + phi*trend)*seasonal\n            error = row.numpy()[0] - y_hat\n\n            seasonal_t = seasonal + (gamma*error)/(lvl + phi*trend)\n            lvl = lvl + phi*trend + alpha*error/seasonal\n            trend = phi*trend + beta*error/seasonal\n\n            seasonals.append(seasonal_t)\n            errors.append(error)\n\n    return errors", "\ndef MAdM(dep_var, init_components, params):\n    \n    init_lvl, init_trend, init_seasonals, seasonal_periods = init_components           \n    alpha, beta, gamma, phi = params\n\n    errors = []\n\n    for index, row in enumerate(dep_var):\n\n        if index == 0:\n\n            lvl = init_lvl\n            trend = init_trend\n            seasonal = init_seasonals[0]\n            seasonals = [seasonal]\n            errors.append(0)\n\n        elif index < seasonal_periods:            \n\n            seasonal = init_seasonals[index]     \n\n            y_hat = (lvl + phi*trend)*seasonal\n            error = (row.numpy()[0] - y_hat)/y_hat\n\n            lprev, bprev = lvl, trend\n\n            seasonal_t = seasonal*(gamma*error + 1)\n            lvl = (lprev + phi*bprev)*(1+alpha*error)\n            trend = phi*bprev + beta*(lprev + phi*bprev)*error\n\n            seasonals.append(seasonal_t)\n            errors.append(error)            \n\n        else:               \n\n            seasonal = seasonals[index-seasonal_periods]  \n\n            y_hat = (lvl + phi*trend)*seasonal\n            error = (row.numpy()[0] - y_hat)/y_hat\n\n            lprev, bprev = lvl, trend\n\n            seasonal_t = seasonal*(gamma*error + 1)\n            lvl = (lprev + phi*bprev)*(1+alpha*error)\n            trend = phi*bprev + beta*(lprev + phi*bprev)*error\n\n            seasonals.append(seasonal_t)\n            errors.append(error)\n\n    return errors", "\ndef AAA(dep_var, init_components, params):\n    \n    init_lvl, init_trend, init_seasonals, seasonal_periods = init_components           \n    alpha, beta, gamma = params\n\n    errors = []\n\n    for index, row in enumerate(dep_var):\n\n        if index == 0:\n\n            lvl = init_lvl\n            trend = init_trend\n            seasonal = init_seasonals[0]\n            seasonals = [seasonal]\n            errors.append(0)\n\n        elif index < seasonal_periods:            \n\n            seasonal = init_seasonals[index]     \n\n            y_hat = lvl + trend +seasonal\n            error = row.numpy()[0] - y_hat\n\n            lprev, bprev = lvl, trend\n\n            seasonal_t = seasonal+ gamma*error\n            lvl = lprev + bprev+ alpha*error\n            trend = bprev + beta*error\n\n            seasonals.append(seasonal_t)\n            errors.append(error)            \n\n        else:               \n\n            seasonal = seasonals[index-seasonal_periods]  \n\n            y_hat = lvl + trend +seasonal\n            error = row.numpy()[0] - y_hat\n\n            lprev, bprev = lvl, trend\n\n            seasonal_t = seasonal+ gamma*error\n            lvl = lprev + bprev+ alpha*error\n            trend = bprev + beta*error\n\n            seasonals.append(seasonal_t)\n            errors.append(error)\n\n    return errors", "\ndef MAA(dep_var, init_components, params):\n    \n    init_lvl, init_trend, init_seasonals, seasonal_periods = init_components           \n    alpha, beta, gamma = params\n\n    errors = []\n\n    for index, row in enumerate(dep_var):\n\n        if index == 0:\n\n            lvl = init_lvl\n            trend = init_trend\n            seasonal = init_seasonals[0]\n            seasonals = [seasonal]\n            errors.append(0)\n\n        elif index < seasonal_periods:            \n\n            seasonal = init_seasonals[index]     \n\n            y_hat = lvl + trend + seasonal\n            error = (row.numpy()[0] - y_hat)/y_hat\n\n            lprev, bprev = lvl, trend\n\n            seasonal_t = seasonal+gamma*error*(lprev+bprev+seasonal)\n            lvl = lprev+bprev+alpha*(lprev+bprev+seasonal)*error\n            trend = bprev+ beta*(lprev+bprev+seasonal)*error\n\n            seasonals.append(seasonal_t)\n            errors.append(error)            \n\n        else:               \n\n            seasonal = seasonals[index-seasonal_periods]  \n\n            y_hat = lvl + trend + seasonal\n            error = (row.numpy()[0] - y_hat)/y_hat\n\n            lprev, bprev = lvl, trend\n\n            seasonal_t = seasonal+gamma*error*(lprev+bprev+seasonal)\n            lvl = lprev+bprev+alpha*(lprev+bprev+seasonal)*error\n            trend = bprev+ beta*(lprev+bprev+seasonal)*error\n\n            seasonals.append(seasonal_t)\n            errors.append(error)\n\n    return errors", "\ndef AAN(dep_var, init_components, params):\n    \n    init_lvl, init_trend, init_seasonals, seasonal_periods = init_components           \n    alpha, beta = params\n\n    errors = []\n\n    for index, row in enumerate(dep_var):\n\n        if index == 0:\n\n            lvl = init_lvl\n            trend = init_trend\n            errors.append(0) \n\n        else:               \n\n            y_hat = lvl + trend \n            error = row.numpy()[0] - y_hat\n\n            lprev, bprev = lvl, trend\n\n            lvl = lprev + bprev + alpha*error\n            trend = bprev+ beta*error\n\n            errors.append(error)\n\n    return errors", "\ndef AAdN(dep_var, init_components, params):\n    \n    init_lvl, init_trend, init_seasonals, seasonal_periods = init_components            \n    alpha, beta, phi = params\n\n    errors = []\n\n    for index, row in enumerate(dep_var):\n\n        if index == 0:\n\n            lvl = init_lvl\n            trend = init_trend\n            errors.append(0) \n\n        else:               \n\n            y_hat = lvl + phi*trend \n            error = row.numpy()[0] - y_hat\n\n            lprev, bprev = lvl, trend\n\n            lvl = lprev + phi*bprev + alpha*error\n            trend = phi*bprev+ beta*error\n\n            errors.append(error)\n\n    return errors", "\n\ndef MAN(dep_var, init_components, params):\n    \n    init_lvl, init_trend, init_seasonals, seasonal_periods = init_components            \n    alpha, beta = params\n\n    errors = []\n\n    for index, row in enumerate(dep_var):\n\n        if index == 0:\n\n            lvl = init_lvl\n            trend = init_trend\n            errors.append(0) \n\n        else:               \n\n            y_hat = lvl + trend \n            error = (row.numpy()[0] - y_hat)/y_hat\n\n            lprev, bprev = lvl, trend\n\n            lvl = (lprev+bprev)*(1+alpha*error)\n            trend = bprev+ beta*(lprev+bprev)*error\n\n            errors.append(error)\n\n    return errors", "\ndef MAdN(dep_var, init_components, params):\n    \n    init_lvl, init_trend, init_seasonals, seasonal_periods = init_components            \n    alpha, beta, phi = params\n\n    errors = []\n\n    for index, row in enumerate(dep_var):\n\n        if index == 0:\n\n            lvl = init_lvl\n            trend = init_trend\n            errors.append(0) \n\n        else:               \n\n            y_hat = lvl + phi*trend \n            error = (row.numpy()[0] - y_hat)/y_hat\n\n            lprev, bprev = lvl, trend\n\n            lvl = (lprev+phi*bprev)*(1+alpha*error)\n            trend = phi*bprev+ beta*(lprev+phi*bprev)*error\n\n            errors.append(error)\n\n    return errors", "\ndef AAM(dep_var, init_components, params):\n    \n    init_lvl, init_trend, init_seasonals, seasonal_periods = init_components           \n    alpha, beta, gamma = params\n\n    errors = []\n\n    for index, row in enumerate(dep_var):\n\n        if index == 0:\n\n            lvl = init_lvl\n            trend = init_trend\n            seasonal = init_seasonals[0]\n            seasonals = [seasonal]\n            errors.append(0)\n\n        elif index < seasonal_periods:            \n\n            seasonal = init_seasonals[index]     \n\n            y_hat = (lvl + trend)* seasonal\n            error = row.numpy()[0] - y_hat\n\n            lprev, bprev = lvl, trend\n\n            seasonal_t = seasonal + gamma*error/(lprev+bprev)\n            lvl = lprev+bprev + alpha*error/seasonal\n            trend = bprev+ beta*error/seasonal\n\n            seasonals.append(seasonal_t)\n            errors.append(error)            \n\n        else:               \n            seasonal = seasonals[index-seasonal_periods]  \n\n            y_hat = (lvl + trend)* seasonal\n            error = row.numpy()[0] - y_hat\n\n            lprev, bprev = lvl, trend\n\n            seasonal_t = seasonal + gamma*error/(lprev+bprev)\n            lvl = lprev+bprev + alpha*error/seasonal\n            trend = bprev+ beta*error/seasonal\n\n            seasonals.append(seasonal_t)\n            errors.append(error)\n\n    return errors", "\ndef MAM(dep_var, init_components, params):\n    \n    init_lvl, init_trend, init_seasonals, seasonal_periods = init_components           \n    alpha, beta, gamma = params\n\n    errors = []\n\n    for index, row in enumerate(dep_var):\n\n        if index == 0:\n\n            lvl = init_lvl\n            trend = init_trend\n            seasonal = init_seasonals[0]\n            seasonals = [seasonal]\n            errors.append(0)\n\n        elif index < seasonal_periods:            \n\n            seasonal = init_seasonals[index]     \n\n            y_hat = (lvl + trend)*seasonal\n            error = (row.numpy()[0] - y_hat)/y_hat\n\n            lprev, bprev = lvl, trend\n\n            seasonal_t = seasonal*(gamma*error + 1)\n            lvl = (lprev + bprev)*(1+alpha*error)\n            trend = bprev + beta*(lprev + bprev)*error\n\n            seasonals.append(seasonal_t)\n            errors.append(error)            \n\n        else:               \n\n            seasonal = seasonals[index-seasonal_periods]  \n\n            y_hat = (lvl + trend)*seasonal\n            error = (row.numpy()[0] - y_hat)/y_hat\n\n            lprev, bprev = lvl, trend\n\n            seasonal_t = seasonal*(gamma*error + 1)\n            lvl = (lprev + bprev)*(1+alpha*error)\n            trend = bprev + beta*(lprev + bprev)*error\n\n            seasonals.append(seasonal_t)\n            errors.append(error)\n\n    return errors"]}
{"filename": "chronokit/exponential_smoothing/initialization/__init__.py", "chunked_list": ["from .ets_methods import *\nfrom .initialization_methods import *\nfrom .smoothing_methods import *\n\n"]}
{"filename": "chronokit/exponential_smoothing/initialization/initialization_methods.py", "chunked_list": ["import numpy as np\nimport pandas as pd\nimport torch\nimport scipy.optimize as opt\nfrom scipy.stats import norm\nfrom scipy.stats import linregress\nfrom chronokit.exponential_smoothing.initialization import ets_methods, smoothing_methods\nfrom chronokit.preprocessing.dataloader import DataLoader\n\ndef get_init_method(method):\n\n    init_method = {\"heuristic\": heuristic_initialization,\n                    \"mle\": mle_initialization}[method]\n    \n    return init_method", "\ndef get_init_method(method):\n\n    init_method = {\"heuristic\": heuristic_initialization,\n                    \"mle\": mle_initialization}[method]\n    \n    return init_method\n\ndef get_smooth_method(error, trend, seasonal, damped):\n\n    if error:\n        smooth_method = { \n                            (None, False, None, \"add\"): ets_methods.ANN,\n                            (None, False, \"add\", \"add\"): ets_methods.ANA,\n                            (None, False, \"mul\", \"add\"): ets_methods.ANM,\n                            (\"add\", False, None, \"add\"): ets_methods.AAN,\n                            (\"add\", False, \"add\", \"add\"): ets_methods.AAA,\n                            (\"add\", False, \"mul\", \"add\"): ets_methods.AAM,\n                            (\"add\", True, None, \"add\"): ets_methods.AAdN,\n                            (\"add\", True, \"add\", \"add\"): ets_methods.AAdA,\n                            (\"add\", True, \"mul\", \"add\"): ets_methods.AAdM,\n\n                            (None, False, None, \"mul\"): ets_methods.MNN,\n                            (None, False, \"add\", \"mul\"): ets_methods.MNA,\n                            (None, False, \"mul\", \"mul\"): ets_methods.MNM,\n                            (\"add\", False, None, \"mul\"): ets_methods.MAN,\n                            (\"add\", False, \"add\", \"mul\"): ets_methods.MAA,\n                            (\"add\", False, \"mul\", \"mul\"): ets_methods.MAM,\n                            (\"add\", True, None, \"mul\"): ets_methods.MAdN,\n                            (\"add\", True, \"add\", \"mul\"): ets_methods.MAdA,\n                            (\"add\", True, \"mul\", \"mul\"): ets_methods.MAdM\n                        }[trend, damped, seasonal, error]\n    \n    else:\n        smooth_method = { \n                        (None, False, None): smoothing_methods.simple_exp,\n                        (\"add\", False, None): smoothing_methods.holt_trend,\n                        (\"add\", True, None): smoothing_methods.holt_damped_trend,\n                        (\"add\", False, \"add\"): smoothing_methods.hw_add,\n                        (\"add\", False, \"mul\"): smoothing_methods.hw_mul,\n                        (\"add\", True, \"add\"): smoothing_methods.hw_damped_add,\n                        (\"add\", True, \"mul\"): smoothing_methods.hw_damped_mul\n                        }[trend, damped, seasonal]\n        \n    return smooth_method", "def get_smooth_method(error, trend, seasonal, damped):\n\n    if error:\n        smooth_method = { \n                            (None, False, None, \"add\"): ets_methods.ANN,\n                            (None, False, \"add\", \"add\"): ets_methods.ANA,\n                            (None, False, \"mul\", \"add\"): ets_methods.ANM,\n                            (\"add\", False, None, \"add\"): ets_methods.AAN,\n                            (\"add\", False, \"add\", \"add\"): ets_methods.AAA,\n                            (\"add\", False, \"mul\", \"add\"): ets_methods.AAM,\n                            (\"add\", True, None, \"add\"): ets_methods.AAdN,\n                            (\"add\", True, \"add\", \"add\"): ets_methods.AAdA,\n                            (\"add\", True, \"mul\", \"add\"): ets_methods.AAdM,\n\n                            (None, False, None, \"mul\"): ets_methods.MNN,\n                            (None, False, \"add\", \"mul\"): ets_methods.MNA,\n                            (None, False, \"mul\", \"mul\"): ets_methods.MNM,\n                            (\"add\", False, None, \"mul\"): ets_methods.MAN,\n                            (\"add\", False, \"add\", \"mul\"): ets_methods.MAA,\n                            (\"add\", False, \"mul\", \"mul\"): ets_methods.MAM,\n                            (\"add\", True, None, \"mul\"): ets_methods.MAdN,\n                            (\"add\", True, \"add\", \"mul\"): ets_methods.MAdA,\n                            (\"add\", True, \"mul\", \"mul\"): ets_methods.MAdM\n                        }[trend, damped, seasonal, error]\n    \n    else:\n        smooth_method = { \n                        (None, False, None): smoothing_methods.simple_exp,\n                        (\"add\", False, None): smoothing_methods.holt_trend,\n                        (\"add\", True, None): smoothing_methods.holt_damped_trend,\n                        (\"add\", False, \"add\"): smoothing_methods.hw_add,\n                        (\"add\", False, \"mul\"): smoothing_methods.hw_mul,\n                        (\"add\", True, \"add\"): smoothing_methods.hw_damped_add,\n                        (\"add\", True, \"mul\"): smoothing_methods.hw_damped_mul\n                        }[trend, damped, seasonal]\n        \n    return smooth_method", "\ndef heuristic_initialization(data, trend=False, seasonal=None,\n                              seasonal_periods=None):\n    \"\"\"\n    Heuristic initialization method for initial components\n    See: Hyndman et al. section 2.6.1\n    \"\"\"\n\n    data = DataLoader(data).to_numpy().copy()\n\n    if data.ndim >= 1:\n\n        data = np.squeeze(data)\n\n    initial_level = None\n    initial_trend = None\n    initial_seasonal = None\n\n    assert(len(data) >= 10), \"Length of data must be >= for heuristic initialization\"\n\n    if seasonal:\n        \n        #Data must have at least 2 full seasonal cycles\n        assert (len(data) > 2*seasonal_periods), \"Length of data must be > 2*seasonal_periods\"\n\n        #Max number of seasonal cycles to be used is 5\n        seasonal_cycles = min(5, len(data)//seasonal_periods)\n        series = pd.Series(data[:seasonal_periods*seasonal_cycles])\n        moving_avg = series.rolling(seasonal_periods, center=True).mean()\n\n        if seasonal_periods % 2 == 0:\n            moving_avg = moving_avg.shift(-1).rolling(2).mean()\n\n        if seasonal == \"add\":\n            detrend = series - moving_avg\n        elif seasonal == \"mul\":\n            detrend = series/moving_avg\n     \n        initial_seasonal = np.zeros(shape=(seasonal_periods,seasonal_cycles))*np.nan\n        for i in range(0, seasonal_cycles):\n            initial_seasonal[:, i] = detrend[i*seasonal_periods:(i+1)*seasonal_periods]\n    \n        initial_seasonal = np.nanmean(initial_seasonal, axis=1)\n\n        if seasonal == \"add\":\n            #normalize so that the sum is equal to 1\n            initial_seasonal /= np.sum(initial_seasonal)\n        elif seasonal == \"mul\":\n            #normalize so that the sum is equal to m=seasonal_periods\n            initial_seasonal *= seasonal_periods/np.sum(initial_seasonal)\n\n        adjusted_data = moving_avg.dropna().values\n    \n    else:\n        adjusted_data = data.copy()\n\n    \n    result = linregress(x=np.arange(10), y=adjusted_data[:10])\n    initial_level = result[1]\n\n    if trend:\n        initial_trend = result[0]\n\n    return initial_level, initial_trend, initial_seasonal", "\n\ndef mle_initialization(data, trend=None,damped=False, seasonal=None, error_type=None,seasonal_periods=12,alpha=0.1,beta=0.01,gamma=0.01,phi=0.99):\n    \"\"\"Maximum Likelihood Estimatin for initialization of initial components\"\"\"\n \n    data = DataLoader(data).to_numpy().copy()\n    selected_model = get_smooth_method(error=error_type, trend=trend, seasonal=seasonal, damped=damped)\n\n    # Find the parameters of selected model to maximize the likelihood function.\n    params = {\n        (None, False, None): [alpha],\n        (None, False, \"add\"): [alpha, gamma],\n        (None, False, \"mul\"): [alpha, gamma],\n        (\"add\", False, None): [alpha, beta],\n        (\"add\", False, \"add\"): [alpha, beta, gamma],\n        (\"add\", False, \"mul\"): [alpha, beta, gamma],\n        (\"add\", True, None): [alpha, beta, phi],\n        (\"add\", True, \"add\"): [alpha, beta, gamma, phi],\n        (\"add\", True, \"mul\"): [alpha, beta, gamma, phi],\n    }\n    model_params = params[(trend, damped, seasonal)]\n    seasonals = np.zeros(seasonal_periods+1).tolist() # Seasonal components are initialized as zero.\n    \n    # Flattening the components and parameters to use in optimization function.\n    init_components = [data.mean(), 0] #level and trend\n    if seasonal:\n        for i in range(seasonal_periods):\n            init_components.append(1) #initialize seasonals as 1\n        \n    init_components.append(seasonal_periods)\n    init_values = init_components + model_params\n\n    def log_likelihood(init_values,data,seasonal_periods,model):\n        # Split the initial values to components, seasonal components and parameters.\n        components = init_values[:2].tolist()\n        seasonal_components = init_values[2:-len(model_params)].tolist()\n        params = init_values[-len(model_params):]\n        components = components + [seasonal_components] + [seasonal_periods]\n\n        dep_var = DataLoader(data).to_tensor().detach().clone()\n        if dep_var.ndim == 1:\n            dep_var = torch.unsqueeze(dep_var, axis=1)\n        # Calculate the log likelihood of the model.\n        errors = model(dep_var,init_components=components,params=params)\n        loc = np.array(errors).mean()\n        scale = np.array(errors).std()**2\n        log_likelihood = np.sum(norm.logpdf(errors, loc=loc, scale=scale))\n        return -log_likelihood\n\n    # Use the optimization function to find the maximum likelihood estimates with random initial values\n    result_params = opt.minimize(log_likelihood,init_values, args=(data,seasonal_periods,selected_model,))\n\n    def parse_results(result_params):\n        # Unflatten the components and parameters.\n        results = list(result_params.x)\n        initial_level, initial_trend = results[:2]\n        initial_seasonal = np.array(results[2:-len(model_params)-1])\n        if not trend:\n            initial_trend = None\n        if not seasonal:\n            initial_seasonal = None\n        init_components = (initial_level, initial_trend, initial_seasonal)\n        return init_components\n    \n    result_components = parse_results(result_params)\n\n    return result_components"]}
