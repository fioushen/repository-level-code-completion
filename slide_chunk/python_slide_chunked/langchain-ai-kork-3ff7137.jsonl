{"filename": "tests/test_interpreter.py", "chunked_list": ["from typing import Any\n\nimport pytest\n\nfrom kork import ast\nfrom kork.ast_printer import AstPrinter\nfrom kork.environment import Environment\nfrom kork.exceptions import KorkRunTimeException\nfrom kork.interpreter import run_interpreter\n", "from kork.interpreter import run_interpreter\n\n# TODO: Determine why mypy is not recognizing the import.\nfrom kork.parser import parse  # type: ignore[attr-defined]\n\n\ndef set_up_environment() -> Environment:\n    \"\"\"Prepopulate an environment with some symbols.\"\"\"\n    environment = Environment(\n        parent=None,\n        variables={},\n    )\n    environment.set_symbol(\n        \"add\",\n        ast.ExternFunctionDef(\n            name=\"add\",\n            params=ast.ParamList(\n                params=[\n                    ast.Param(name=\"a\", type_=\"number\"),\n                    ast.Param(name=\"b\", type_=\"number\"),\n                ]\n            ),\n            return_type=\"number\",\n        ).add_implementation(lambda a, b: a + b),\n    )\n    environment.set_symbol(\n        \"time\",\n        ast.ExternFunctionDef(\n            name=\"time\",\n            params=ast.ParamList(params=[]),\n            return_type=\"number\",\n        ).add_implementation(lambda: 1.0),\n    )\n    return environment", "\n\n@pytest.mark.parametrize(\n    \"code, value\",\n    [\n        # Int\n        (\"var x = 1\", 1),\n        # None\n        (\"var x = null\", None),\n        # Scientific", "        (\"var x = null\", None),\n        # Scientific\n        (\"var x = 1e2\", 100),\n        (\"var x = 1E2\", 100),\n        (\"var x = 1E-2\", 0.01),\n        # String\n        ('var x = \"hello\"', \"hello\"),\n        # Float\n        (\"var x = 5.0\", 5.0),\n        (\"var x = 5.0 + 2\", 7.0),", "        (\"var x = 5.0\", 5.0),\n        (\"var x = 5.0 + 2\", 7.0),\n        (\"var x = 5\\nvar x = 2\", 2.0),\n        (\"var x = 5;var x = 2\", 2.0),\n        (\"var x = add(1,2)\", 3.0),\n        (\"var x = time()\", 1.0),\n        # Add\n        (\"var x = 1 + 1\", 2),\n        # Subtract\n        (\"var x = 2 - 3\", -1),", "        # Subtract\n        (\"var x = 2 - 3\", -1),\n        # Unary minus\n        (\"var x = -3\", -3),\n        # Divide\n        (\"var x = 6 / 3\", 2),\n        # Multiply\n        (\"var x = 2 * 3\", 6),\n        # Operator precedence\n        (\"var x = 1 + 3 * 3\", 10),", "        # Operator precedence\n        (\"var x = 1 + 3 * 3\", 10),\n        # Grouping\n        (\"var x = (1 + 1) * 3\", 6),\n        # List\n        ('var x = [1.0,2,\"3\"]', [1.0, 2, \"3\"]),\n        # Variable declaration and assignment\n        (\"var x = 1\\nx=2\", 2),\n        # Comments\n        (\"var x = 1 # comment\", 1),", "        # Comments\n        (\"var x = 1 # comment\", 1),\n        (\"var x = 1 // Also a comment\", 1),\n        # Sum with identifiers\n        (\"var x = 2\\nvar x = 1 + x\", 3),\n        (\"var x = 2\\nvar x = 1 / x\", 0.5),\n        (\"var y = 1\\nvar z = 2\\nvar x = y + z\", 3),\n        (\"var y = 1\\nvar z = 2\\nvar x = y * z\", 2),\n        # Add binary operators\n        (\"var x = 1 + 1\", 2),", "        # Add binary operators\n        (\"var x = 1 + 1\", 2),\n        (\"var x = 1 - 1\", 0),\n        (\"var x = 1 * 3\", 3),\n        (\"var x = 8 / 2\", 4),\n        (\"var x = 9 % 3\", 0),\n        (\"var x = 9 % 5\", 4),\n        # unary rule\n        (\"var x = --3\", 3),\n        # Take powers", "        (\"var x = --3\", 3),\n        # Take powers\n        (\"var x = 2 ** 4\", 16),\n        (\"var x = 2 ^ 4\", 16),\n        (\"var x = 2 ^ -1\", 0.5),\n        (\"var x = 2 ^ -add(2, 2)\", 1 / 16),\n        (\"var x = 2 ^ +add(2, 2)\", 16),\n        (\"var y = 3; var x = 2 ^ y\", 8),\n        (\"var y = 3; var z = 2; var x = z ^ y\", 8),\n        (\"var y = 3; var z = 2; var x = z ** y\", 8),", "        (\"var y = 3; var z = 2; var x = z ^ y\", 8),\n        (\"var y = 3; var z = 2; var x = z ** y\", 8),\n        # Add binary operators involving primary and function call\n        (\"var z = 2\\nvar x = 1 + add(z, z)\", 5),\n        # Add binary operators involving function calls\n        (\"var z = 2\\nvar x = add(z, z) * add(z, z)\", 16),\n        # Repeat tests but with semi-colons\n        # Sum with identifiers\n        (\"var x = 2; x = 1 + x;\", 3),\n        (\"var x = 2; x = 1 / x;\", 0.5),", "        (\"var x = 2; x = 1 + x;\", 3),\n        (\"var x = 2; x = 1 / x;\", 0.5),\n        (\"var y = 1; z = 2; x = y + z;\", 3),\n        (\"var y = 1; z = 2; x = y * z;\", 2),\n        # Add binary operators involving primary and function call\n        (\"var z = 2; x = 1 + add(z, z);\", 5),\n        # Add binary operators involving function calls\n        (\"var z = 2; x = add(z, z) * add(z, z);\", 16),\n    ],\n)\ndef test_interpreter(code: str, value: Any) -> None:\n    \"\"\"Run program and verify value of `x` symbol is as expected.\"\"\"\n    result = run_interpreter(code, environment=set_up_environment())\n    assert result[\"environment\"].get_symbol(\"x\") == value", "    ],\n)\ndef test_interpreter(code: str, value: Any) -> None:\n    \"\"\"Run program and verify value of `x` symbol is as expected.\"\"\"\n    result = run_interpreter(code, environment=set_up_environment())\n    assert result[\"environment\"].get_symbol(\"x\") == value\n\n\ndef test_interpreter_extern_func_declaration() -> None:\n    \"\"\"Test that an extern function declaration is added to the environment.\"\"\"\n    result = run_interpreter(\"extern fn meow(x : int, y:int) -> int\")\n    env = result[\"environment\"]\n    extern_fn_declaration = env.get_symbol(\"meow\")\n    assert isinstance(extern_fn_declaration, ast.ExternFunctionDef)\n\n    # Verify that the function cannot be called.\n    result = run_interpreter(\"meow(1,2)\", environment=env)\n    assert isinstance(result[\"errors\"][0], KorkRunTimeException)\n\n    env.set_symbol(\"meow\", extern_fn_declaration.add_implementation(lambda x, y: x + y))\n\n    result = run_interpreter(\"var x = meow(1,2)\", environment=env)\n    assert result[\"environment\"].get_symbol(\"x\") == 3", "def test_interpreter_extern_func_declaration() -> None:\n    \"\"\"Test that an extern function declaration is added to the environment.\"\"\"\n    result = run_interpreter(\"extern fn meow(x : int, y:int) -> int\")\n    env = result[\"environment\"]\n    extern_fn_declaration = env.get_symbol(\"meow\")\n    assert isinstance(extern_fn_declaration, ast.ExternFunctionDef)\n\n    # Verify that the function cannot be called.\n    result = run_interpreter(\"meow(1,2)\", environment=env)\n    assert isinstance(result[\"errors\"][0], KorkRunTimeException)\n\n    env.set_symbol(\"meow\", extern_fn_declaration.add_implementation(lambda x, y: x + y))\n\n    result = run_interpreter(\"var x = meow(1,2)\", environment=env)\n    assert result[\"environment\"].get_symbol(\"x\") == 3", "\n\ndef test_cannot_invoke_undefined_variable() -> None:\n    \"\"\"Test exception is raised when referencing an undefined variable.\"\"\"\n    result = run_interpreter(\"var x = y\")\n    assert isinstance(result[\"errors\"][0], KorkRunTimeException)\n\n\ndef test_function_definition() -> None:\n    \"\"\"Test unimplemented features raise exception.\"\"\"\n    result = run_interpreter(\"def fn meow(x : int, y:int) -> int {}\")\n    assert isinstance(result[\"errors\"][0], KorkRunTimeException)", "def test_function_definition() -> None:\n    \"\"\"Test unimplemented features raise exception.\"\"\"\n    result = run_interpreter(\"def fn meow(x : int, y:int) -> int {}\")\n    assert isinstance(result[\"errors\"][0], KorkRunTimeException)\n\n\ndef test_function_invocation() -> None:\n    \"\"\"Test unimplemented features raise exception.\"\"\"\n    environment = Environment(parent=None, variables={})\n    environment.set_symbol(\n        \"meow\",\n        ast.FunctionDef(\n            name=\"meow\",\n            body=[],\n            params=ast.ParamList(\n                params=[\n                    ast.Param(name=\"a\", type_=\"number\"),\n                    ast.Param(name=\"b\", type_=\"number\"),\n                ]\n            ),\n            return_type=\"number\",\n        ),\n    )\n\n    result = run_interpreter(\"var x = meow(1,2)\", environment=environment)\n\n    run_interpreter(\"fn meow(x : int, y:int) -> int {}\\nmeow(1,2)\")\n    assert isinstance(result[\"errors\"][0], KorkRunTimeException)", "\n\n@pytest.mark.parametrize(\n    \"code, expected\",\n    [\n        (\"var x = 5\", \"var x = 5\"),\n        (\"var x = 5\\t\\t\\t\\nadd(2,3  )\", \"var x = 5\\nadd(2, 3)\"),\n        # Verify whitespace insensitivity\n        (\"extern fn add(x : int, y:int)->int\", \"extern fn add(x: int, y: int) -> int\"),\n        (", "        (\"extern fn add(x : int, y:int)->int\", \"extern fn add(x: int, y: int) -> int\"),\n        (\n            \"extern fn add  (x : int, y:int) -> int\",\n            \"extern fn add(x: int, y: int) -> int\",\n        ),\n        (\"fn add(x : int, y:int) -> int {}\", \"fn add(x: int, y: int) -> int {\\n}\"),\n        ('var x = [\"a\", [], 1, 2.0, null]', 'var x = [\"a\", [], 1, 2.0, null]'),\n        (\"var x = []; var z = 1;\", \"var x = []\\nvar z = 1\"),\n    ],\n)\ndef test_ast_parsing_and_printing(code: str, expected: str) -> None:\n    \"\"\"Test parsing of code into an AST and then printing it back as code.\"\"\"\n    program = parse(code)\n    assert AstPrinter().visit(program) == expected", "    ],\n)\ndef test_ast_parsing_and_printing(code: str, expected: str) -> None:\n    \"\"\"Test parsing of code into an AST and then printing it back as code.\"\"\"\n    program = parse(code)\n    assert AstPrinter().visit(program) == expected\n"]}
{"filename": "tests/test_examples.py", "chunked_list": ["from kork.ast_printer import AstPrinter\nfrom kork.examples import c_, format_examples, r_\n\n\ndef add_(x: int, y: int) -> int:\n    \"\"\"Add two numbers.\"\"\"\n    return x + y\n\n\ndef test_format_examples() -> None:\n    \"\"\"Test format examples.\"\"\"\n    examples = [\n        (\n            \"Add 1 and 2\",\n            r_(c_(add_, 1, 2)),\n        ),\n    ]\n\n    formatted_examples = format_examples(\n        language_name=\"meow\",\n        examples=examples,\n        ast_printer=AstPrinter(),\n    )\n\n    assert formatted_examples == [\n        (\n            \"Add 1 and 2\",\n            \"<code>var result = add_(1, 2)</code>\",\n        ),\n    ]", "\ndef test_format_examples() -> None:\n    \"\"\"Test format examples.\"\"\"\n    examples = [\n        (\n            \"Add 1 and 2\",\n            r_(c_(add_, 1, 2)),\n        ),\n    ]\n\n    formatted_examples = format_examples(\n        language_name=\"meow\",\n        examples=examples,\n        ast_printer=AstPrinter(),\n    )\n\n    assert formatted_examples == [\n        (\n            \"Add 1 and 2\",\n            \"<code>var result = add_(1, 2)</code>\",\n        ),\n    ]", ""]}
{"filename": "tests/test_foreign_functions.py", "chunked_list": ["from typing import Any, Literal, Mapping, Sequence, Union\n\nfrom kork.ast import ExternFunctionDef, Param, ParamList\nfrom kork.foreign_funcs import to_extern_func_def\n\n\n# Do not type the function below. We're testing initialization of the retriever.\ndef foo():  # type: ignore\n    pass\n", "\n\ndef bar(x: int) -> int:\n    \"\"\"Add one to x.\"\"\"\n    return x + 1\n\n\ndef zoo(x: Mapping[str, Any], q: Sequence[Union[Literal[\"a\"], Literal[\"b\"]]]) -> Any:\n    \"\"\"Add one to x.\"\"\"\n    pass", "\n\ndef test_to_extern_func_def() -> None:\n    \"\"\"Test conversion of a python function into an extern function definition.\"\"\"\n    assert to_extern_func_def(foo) == ExternFunctionDef(\n        name=\"foo\",\n        params=ParamList(params=[]),\n        # If the source function is un-typed, we assume\n        # that the return type is Any.\n        return_type=\"Any\",\n        implementation=foo,\n        doc_string=\"\",\n    )\n\n    assert to_extern_func_def(bar) == ExternFunctionDef(\n        name=\"bar\",\n        params=ParamList(params=[Param(name=\"x\", type_=\"int\")]),\n        return_type=\"int\",\n        implementation=bar,\n        doc_string=\"Add one to x.\",\n    )\n\n    assert to_extern_func_def(zoo) == ExternFunctionDef(\n        name=\"zoo\",\n        params=ParamList(\n            params=[\n                Param(name=\"x\", type_=\"Mapping[str, Any]\"),\n                Param(\n                    name=\"q\",\n                    type_=\"Sequence[Union[Literal['a'], Literal['b']]]\",\n                ),\n            ]\n        ),\n        return_type=\"Any\",\n        implementation=zoo,\n        doc_string=\"Add one to x.\",\n    )", ""]}
{"filename": "tests/test_ast.py", "chunked_list": ["from kork.ast import _to_snake_case\n\n\ndef test_snake_case() -> None:\n    assert _to_snake_case(\"Number\") == \"number\"\n    assert _to_snake_case(\"NumberWoof\") == \"number_woof\"\n"]}
{"filename": "tests/test_prompt_adapter.py", "chunked_list": ["from langchain.prompts import PromptTemplate\n\nfrom kork.prompt_adapter import FewShotPromptValue, FewShotTemplate\n\n\ndef test_few_shot_template() -> None:\n    \"\"\"Test few shot template.\"\"\"\n    prompt_template = PromptTemplate(\n        template=\"meow\\n\\n\",\n        input_variables=[],\n    )\n    few_shot_template = FewShotTemplate(\n        instruction_template=prompt_template,\n        examples=[(\"foo\", \"bar\")],\n        input_variables=[\"query\"],\n    )\n\n    prompt_value = few_shot_template.format_prompt(query=\"query\")\n\n    assert isinstance(prompt_value, FewShotPromptValue)\n    # Test to_string()\n    assert (\n        prompt_value.to_string()\n        == \"meow\\n\\nInput: foo\\n\\nOutput: bar\\n\\nInput: query\\n\\nOutput:\"\n    )\n\n    # Test to_messages()\n    messages = prompt_value.to_messages()\n    assert len(messages) == 4\n    assert messages[0].content == \"meow\"\n    assert messages[1].content == \"foo\"\n    assert messages[2].content == \"bar\"\n    assert messages[3].content == \"query\"", "\n\ndef test_few_shot_template_with_no_examples() -> None:\n    \"\"\"Test few shot template without any examples\"\"\"\n    prompt_template = PromptTemplate(\n        template=\"meow\\n\\n\",\n        input_variables=[],\n    )\n    few_shot_template = FewShotTemplate(\n        instruction_template=prompt_template,\n        examples=[],\n        input_variables=[\"query\"],\n    )\n\n    prompt_value = few_shot_template.format_prompt(query=\"query\")\n\n    assert isinstance(prompt_value, FewShotPromptValue)\n    # Test to_string()\n    assert prompt_value.to_string() == \"meow\\n\\nInput: query\\n\\nOutput:\"\n\n    # Test to_messages()\n    messages = prompt_value.to_messages()\n    assert len(messages) == 2\n    assert messages[0].content == \"meow\"\n    assert messages[1].content == \"query\"", ""]}
{"filename": "tests/test_chain.py", "chunked_list": ["from kork import AstPrinter, CodeChain, SimpleContextRetriever, run_interpreter\nfrom kork.examples import SimpleExampleRetriever\nfrom kork.exceptions import KorkRunTimeException, LLMParseException\nfrom kork.parser import parse  # type: ignore\n\nfrom .utils import ToyChatModel\n\n\ndef test_code_chain() -> None:\n    \"\"\"Test the code chain.\"\"\"\n    example_retriever = SimpleExampleRetriever(examples=[(\"Add 1 and 2\", \"add_(1, 2)\")])\n    llm = ToyChatModel(response=\"<code>var x = 1</code>\")\n    chain = CodeChain(\n        llm=llm,\n        retriever=SimpleContextRetriever(),\n        interpreter=run_interpreter,\n        ast_printer=AstPrinter(),\n        example_retriever=example_retriever,\n    )\n\n    response = chain(inputs={\"query\": \"blah\"})\n    # Why does the chain return a `query` key?\n    assert sorted(response) == [\"code\", \"environment\", \"errors\", \"query\", \"raw\"]\n    env = response.pop(\"environment\")\n    assert response == {\n        \"query\": \"blah\",\n        \"code\": \"var x = 1\",\n        \"errors\": [],\n        \"raw\": \"<code>var x = 1</code>\",\n    }\n    assert env.get_symbol(\"x\") == 1", "def test_code_chain() -> None:\n    \"\"\"Test the code chain.\"\"\"\n    example_retriever = SimpleExampleRetriever(examples=[(\"Add 1 and 2\", \"add_(1, 2)\")])\n    llm = ToyChatModel(response=\"<code>var x = 1</code>\")\n    chain = CodeChain(\n        llm=llm,\n        retriever=SimpleContextRetriever(),\n        interpreter=run_interpreter,\n        ast_printer=AstPrinter(),\n        example_retriever=example_retriever,\n    )\n\n    response = chain(inputs={\"query\": \"blah\"})\n    # Why does the chain return a `query` key?\n    assert sorted(response) == [\"code\", \"environment\", \"errors\", \"query\", \"raw\"]\n    env = response.pop(\"environment\")\n    assert response == {\n        \"query\": \"blah\",\n        \"code\": \"var x = 1\",\n        \"errors\": [],\n        \"raw\": \"<code>var x = 1</code>\",\n    }\n    assert env.get_symbol(\"x\") == 1", "\n\ndef test_bad_program() -> None:\n    \"\"\"Test the code chain.\"\"\"\n    example_retriever = SimpleExampleRetriever(examples=[(\"Add 1 and 2\", \"add_(1, 2)\")])\n    llm = ToyChatModel(response=\"<code>\\nINVALID PROGRAM\\n</code>\")\n    chain = CodeChain(\n        llm=llm,\n        retriever=SimpleContextRetriever(),\n        interpreter=run_interpreter,\n        ast_printer=AstPrinter(),\n        example_retriever=example_retriever,\n    )\n\n    response = chain(inputs={\"query\": \"blah\"})\n    # Why does the chain return a `query` key?\n    assert sorted(response) == [\"code\", \"environment\", \"errors\", \"query\", \"raw\"]\n    assert response[\"raw\"] == \"<code>\\nINVALID PROGRAM\\n</code>\"\n    assert response[\"code\"] == \"\\nINVALID PROGRAM\\n\"\n    assert response[\"environment\"] is None\n    assert response[\"errors\"] is not None\n    assert isinstance(response[\"errors\"][0], KorkRunTimeException)", "\n\ndef test_llm_output_missing_program() -> None:\n    \"\"\"Test the code chain with llm response that's missing code.\"\"\"\n    llm = ToyChatModel(response=\"oops.\")\n\n    example_retriever = SimpleExampleRetriever(examples=[(\"Add 1 and 2\", \"add_(1, 2)\")])\n\n    chain = CodeChain(\n        llm=llm,\n        retriever=SimpleContextRetriever(),\n        interpreter=run_interpreter,\n        ast_printer=AstPrinter(),\n        example_retriever=example_retriever,\n    )\n\n    response = chain(inputs={\"query\": \"blah\"})\n    # Why does the chain return a `query` key?\n    assert sorted(response) == [\"code\", \"environment\", \"errors\", \"query\", \"raw\"]\n    assert response[\"raw\"] == \"oops.\"\n    assert response[\"code\"] == \"\"\n    assert response[\"environment\"] is None\n    errors = response[\"errors\"]\n    assert len(errors) == 1\n    assert isinstance(response[\"errors\"][0], LLMParseException)", "\n\ndef test_from_defaults_instantiation() -> None:\n    \"\"\"Test from default instantiation.\"\"\"\n    llm = ToyChatModel(response=\"<code>\\nvar x = 1;\\n</code>\")\n    chain = CodeChain.from_defaults(llm=llm)\n    response = chain(inputs={\"query\": \"blah\"})\n    # Why does the chain return a `query` key?\n    assert sorted(response) == [\"code\", \"environment\", \"errors\", \"query\", \"raw\"]\n    assert response[\"environment\"].get_symbol(\"x\") == 1\n\n    # Instantiate with sequence of examples and foreign functions\n    def _do() -> int:\n        \"\"\"Do something\"\"\"\n        return 1\n\n    # Verify that we can instantiate\n    examples = [(\"Add 1 and 2\", parse(\"add_(1, 2)\"))]\n    chain2 = CodeChain.from_defaults(\n        llm=llm, examples=examples, context=[_do], language_name=\"kork\"\n    )\n\n    assert isinstance(chain2.context_retriever, SimpleContextRetriever)\n    external_func_defs = chain2.context_retriever.retrieve(\"[anything]\")\n    # Check foreign funcs\n    assert len(external_func_defs) == 1\n    assert external_func_defs[0].name == \"_do\"\n    # Check examples\n    assert isinstance(chain2.example_retriever, SimpleExampleRetriever)\n    assert chain2.example_retriever.retrieve(\"[anything]\") == [\n        # Please note that an input formatted was applied by default to the example\n        (\"```text\\nAdd 1 and 2\\n```\", \"<code>add_(1, 2)</code>\")\n    ]", ""]}
{"filename": "tests/test_retrieval.py", "chunked_list": ["from kork.ast import ExternFunctionDef, ParamList\nfrom kork.retrieval import SimpleContextRetriever\n\n\ndef foo() -> None:\n    \"\"\"Do nothing.\"\"\"\n\n\ndef bar(x: int) -> int:\n    \"\"\"Add one to x.\"\"\"\n    return x + 1", "def bar(x: int) -> int:\n    \"\"\"Add one to x.\"\"\"\n    return x + 1\n\n\ndef test_simple_retriever() -> None:\n    \"\"\"Test simple retriever\"\"\"\n    external_func = ExternFunctionDef(\n        name=\"meow\",\n        params=ParamList(params=[]),\n        return_type=\"int\",\n        implementation=None,\n    )\n    simple_retriever = SimpleContextRetriever.from_functions([foo, bar, external_func])\n    external_func_defs = simple_retriever.retrieve(\"does not matter\")\n    assert len(external_func_defs) == 3\n    assert external_func_defs[0].name == \"foo\"\n    assert external_func_defs[1].name == \"bar\"\n    assert external_func_defs[2].name == \"meow\"", ""]}
{"filename": "tests/__init__.py", "chunked_list": [""]}
{"filename": "tests/utils.py", "chunked_list": ["from typing import Any, List, Optional\n\nfrom langchain.chat_models.base import BaseChatModel\nfrom langchain.schema import AIMessage, BaseMessage, ChatGeneration, ChatResult\nfrom pydantic import Extra\n\n\nclass ToyChatModel(BaseChatModel):\n    response: str\n\n    class Config:\n        \"\"\"Configuration for this pydantic object.\"\"\"\n\n        extra = Extra.forbid\n        arbitrary_types_allowed = True\n\n    def _generate(\n        self, messages: List[BaseMessage], stop: Optional[List[str]] = None\n    ) -> ChatResult:\n        message = AIMessage(content=self.response)\n        generation = ChatGeneration(message=message)\n        return ChatResult(generations=[generation])\n\n    async def _agenerate(\n        self, messages: List[BaseMessage], stop: Optional[List[str]] = None\n    ) -> Any:\n        \"\"\"Async version of _generate.\"\"\"\n        message = AIMessage(content=self.response)\n        generation = ChatGeneration(message=message)\n        return ChatResult(generations=[generation])", ""]}
{"filename": "tests/test_environment.py", "chunked_list": ["import pytest\n\nfrom kork import ast\nfrom kork.environment import Environment\nfrom kork.exceptions import KorkRunTimeException\n\n\ndef test_accessing_variables() -> None:\n    \"\"\"Test the instantiation of the environment.\"\"\"\n    env = Environment()\n\n    with pytest.raises(KorkRunTimeException):\n        env.get_symbol(\"x\")\n\n    env.set_symbol(\"x\", 1)\n    assert env.get_symbol(\"x\") == 1", "\n\ndef test_clone() -> None:\n    \"\"\"Test env cloning.\"\"\"\n    env = Environment()\n    env.set_symbol(\"x\", 1)\n    new_env = env.clone()\n    env.set_symbol(\"y\", 2)\n    new_env.set_symbol(\"z\", 3)\n\n    assert env.variables == {\"x\": 1, \"y\": 2}\n    assert new_env.variables == {\"x\": 1, \"z\": 3}", "\n\ndef test_list_external_functions() -> None:\n    \"\"\"Test list external functions.\"\"\"\n    env = Environment()\n    assert env.list_external_functions() == []\n    func = ast.ExternFunctionDef(\n        name=\"foo\", params=ast.ParamList([]), return_type=\"Any\"\n    )\n    env.set_symbol(\"foo\", func)\n    assert env.list_external_functions() == [func]", ""]}
{"filename": "tests/test_utils.py", "chunked_list": ["from kork.utils import unwrap_code, unwrap_tag, wrap_in_tag\n\n\ndef test_unwrap_tag() -> None:\n    \"\"\"Test unwrap_tag.\"\"\"\n    # Test with an empty string\n    assert unwrap_tag(\"\", \"\") is None\n\n    # Test with a string that doesn't contain the tag\n    assert unwrap_tag(\"table\", \"This is some text.\") is None\n\n    # Test with a string that does contain the tag\n    assert unwrap_tag(\"table\", \"<table>hello</table>\") == \"hello\"\n\n    # Test with a string that does contain the tag and some stuff before and after\n    assert unwrap_tag(\"table\", \"prefix<table>hello</table>suffix\") == \"hello\"", "\n\ndef test_wrap_in_tag() -> None:\n    \"\"\"Test wrap_in_tag.\"\"\"\n    assert wrap_in_tag(\"table\", \"hello\") == \"<table>hello</table>\"\n\n\ndef test_unwrap_code() -> None:\n    \"\"\"Unwrap code.\"\"\"\n    assert unwrap_code(\"python\", \"\") is None\n    assert unwrap_code(\"python\", \"```python\\nprint('hello')\\n```\") == \"print('hello')\"", ""]}
{"filename": "kork/version.py", "chunked_list": ["\"\"\"Get the version of the package.\"\"\"\nfrom importlib import metadata\n\ntry:\n    __version__ = metadata.version(\"kork\")\nexcept metadata.PackageNotFoundError:\n    __version__ = \"local\"\n"]}
{"filename": "kork/ast_printer.py", "chunked_list": ["import abc\nfrom typing import Any, Union\n\nfrom kork import ast\n\n\nclass AbstractAstPrinter(ast.Visitor, abc.ABC):\n    @abc.abstractmethod\n    def visit(\n        self, element: Union[ast.Stmt, ast.Expr], pretty_print: bool = False\n    ) -> str:\n        \"\"\"Entry-point for printing the AST.\"\"\"", "\n\nclass AstPrinter(AbstractAstPrinter):\n    \"\"\"Default AST Printer implementation.\"\"\"\n\n    def visit(\n        self, element: Union[ast.Stmt, ast.Expr], pretty_print: bool = False\n    ) -> str:\n        \"\"\"Entry-point for printing the AST.\"\"\"\n        data = {\n            \"call_depth\": 0,\n            \"pretty_print\": pretty_print,\n        }\n        return element.accept(self, **data)\n\n    def visit_program(self, program: ast.Program, **data: Any) -> str:\n        \"\"\"Print a program.\"\"\"\n        return \"\\n\".join(stmt.accept(self, **data) for stmt in program.stmts)\n\n    def visit_extern_function_def(\n        self, extern_function_def: ast.ExternFunctionDef, **data: Any\n    ) -> str:\n        \"\"\"Print an extern function definition.\"\"\"\n        code = [\n            f\"extern fn {extern_function_def.name}\",\n            \"(\",\n            extern_function_def.params.accept(self, **data),\n            \")\",\n            \" -> \",\n            extern_function_def.return_type,\n        ]\n\n        if extern_function_def.doc_string:\n            # TODO: This is hacky for prototyping, will need to have a better\n            # way to represent the doc string.\n            doc_string = extern_function_def.doc_string.strip().split(\"\\n\")[0]\n            code.append(f\" // {doc_string}\")\n\n        return \"\".join(code)\n\n    def visit_function_call(self, call: ast.FunctionCall, **data: Any) -> str:\n        \"\"\"Print a function call.\"\"\"\n        data[\"call_depth\"] += 1\n        if data[\"pretty_print\"]:\n            call_str = f\"{call.name}(\\n\"\n            call_str += \",\\n\".join(\n                \"    \" * data[\"call_depth\"] + arg.accept(self, **data)\n                for arg in call.args\n            )\n            call_str += \"\\n\" + \"    \" * (data[\"call_depth\"] - 1) + \")\"\n        else:\n            call_str = (\n                f\"{call.name}(\"\n                f\"{', '.join(arg.accept(self, **data) for arg in call.args)}\"\n                f\")\"\n            )\n        return call_str\n\n    def visit_function_def(self, function_def: ast.FunctionDef, **data: Any) -> str:\n        \"\"\"Print a function definition.\"\"\"\n        signature = [\n            f\"fn {function_def.name}\",\n            \"(\",\n            function_def.params.accept(self, **data),\n            \")\",\n            \" -> \",\n            function_def.return_type,\n        ]\n\n        code = [\" {\"]\n        for stmt in function_def.body:\n            code.append(stmt.accept(self, **data))\n        code.append(\"}\")\n        return \"\".join(signature) + \"\\n\".join(code)\n\n    def visit_variable(self, variable: ast.Variable, **data: Any) -> str:\n        \"\"\"Print a variable.\"\"\"\n        return variable.name\n\n    def visit_var_decl(self, var_decl: ast.VarDecl, **data: Any) -> str:\n        \"\"\"Print a variable declaration.\"\"\"\n        return f\"var {var_decl.name} = {var_decl.value.accept(self, **data)}\"\n\n    def visit_assign(self, assign: ast.Assign, **data: Any) -> str:\n        \"\"\"Print an assignment.\"\"\"\n        return f\"{assign.name} = {assign.value.accept(self, **data)}\"\n\n    def visit_literal(self, literal: ast.Literal, **data: Any) -> str:\n        \"\"\"Print a literal.\"\"\"\n        value = literal.value\n        if isinstance(value, type(None)):\n            return \"null\"\n        elif isinstance(value, bool):\n            return str(value).lower()\n        elif isinstance(value, str):\n            return f'\"{value}\"'\n        elif isinstance(value, (float, int)):\n            return str(value)\n        else:\n            raise AssertionError(f\"Unknown literal type: {type(value)}\")\n\n    def visit_param_list(self, param_list: ast.ParamList, **data: Any) -> str:\n        \"\"\"Print a parameter list.\"\"\"\n        return \", \".join(param.accept(self, **data) for param in param_list.params)\n\n    def visit_param(self, param: ast.Param, **data: Any) -> str:\n        \"\"\"Print a parameter.\"\"\"\n        return f\"{param.name}: {param.type_}\"\n\n    def visit_list_(self, list_: ast.List_, **data: Any) -> str:\n        \"\"\"Print a list.\"\"\"\n        return (\n            f\"[{', '.join(element.accept(self, **data) for element in list_.elements)}]\"\n        )\n\n    def visit_unary(self, unary: ast.Unary, **data: Any) -> str:\n        \"\"\"Visit a unary expression.\"\"\"\n        return f\"{unary.operator}{unary.right.accept(self, **data)}\"\n\n    def visit_grouping(self, grouping: ast.Grouping, **data: Any) -> str:\n        return f\"({grouping.expr.accept(self, **data)})\"\n\n    def visit_binary(self, binary: ast.Binary, **data: Any) -> str:\n        \"\"\"Print a binary expression.\"\"\"\n        return (\n            f\"{binary.left.accept(self, **data)} \"\n            f\"{binary.operator} {binary.right.accept(self, **data)}\"\n        )", ""]}
{"filename": "kork/environment.py", "chunked_list": ["from __future__ import annotations\n\nimport copy\nimport dataclasses\nfrom dataclasses import field\nfrom typing import Any, Dict, List, Mapping, Optional, Sequence\n\nfrom kork import ast\nfrom kork.exceptions import KorkRunTimeException\n", "from kork.exceptions import KorkRunTimeException\n\n\n@dataclasses.dataclass\nclass Environment:\n    \"\"\"Environment for storing variables and function definitions.\"\"\"\n\n    parent: Optional[Environment] = None\n    variables: Dict[str, Any] = field(default_factory=dict)\n\n    def get_symbol(self, name: str) -> Any:\n        \"\"\"Get a symbol from the environment.\n\n        Args:\n            name: symbol name to lookup\n\n        Returns:\n            SymbolValue for the given symbol if it exists, otherwise raises an error\n        \"\"\"\n        if name in self.variables:\n            return self.variables[name]\n        elif self.parent:\n            return self.parent.get_symbol(name)\n        else:\n            raise KorkRunTimeException(f\"Variable `{name}` not found\")\n\n    def set_symbol(self, name: str, value: Any) -> Any:\n        \"\"\"Set a symbol in the environment.\"\"\"\n        # TODO: We need to determine whether want the variable to be\n        #       declared prior to be being set.\n        #       At the moment, this allows for `x = 1` without having to declare the\n        #       variable.\n        self.variables[name] = value\n        return value\n\n    def clone(self) -> Environment:\n        \"\"\"Clone a root level environment, with deep copy on variables.\n\n        Cloning functionality is provided because the environment is\n        a mutable variable.\n\n        Biggest danger is mutating the variables dict which the caller\n        may retain a reference to.\n\n        TODO(Eugene): Refactor to make this less dangerous.\n        \"\"\"\n        if self.parent is not None:\n            raise AssertionError(\"Cannot clone an environment with a parent.\")\n        return Environment(parent=None, variables=copy.deepcopy(self.variables))\n\n    def list_external_functions(self) -> List[ast.ExternFunctionDef]:\n        \"\"\"Get a list of the externally defined foreign functions.\"\"\"\n        return [\n            func\n            for func in self.variables.values()\n            if isinstance(func, ast.ExternFunctionDef)\n        ]", "\n\ndef create_environment(\n    extern_function_defs: Sequence[ast.ExternFunctionDef],\n    external_variables: Optional[Mapping[str, Any]] = None,\n) -> Environment:\n    \"\"\"Create a new environment with pre-populated state.\"\"\"\n    variables: Dict[str, Any] = {func.name: func for func in extern_function_defs}\n    environment = Environment(parent=None, variables=variables)\n\n    if external_variables:\n        for name, value in external_variables.items():\n            # At the moment, let's not clone the variable so that it can be\n            # mutated if the goal is to do mutation.\n            environment.set_symbol(name, value)\n    return environment", ""]}
{"filename": "kork/parser.py", "chunked_list": ["# type:ignore[no-untyped-def]\n\"\"\"Kork's default AST parser.\n\nKork uses Lark to parse the AST. The grammar follows closely\nthe one used in Crafting Interpreters for the Lox Programming Language.\n\nhttps://craftinginterpreters.com/appendix-i.html#expressions\n\nThe grammar and parser were clobbered together in a few hours of work.\n", "The grammar and parser were clobbered together in a few hours of work.\n\nIf you deeply care about language design, please forgive any transgressions,\nand feel free to help improve the grammar/parser/interpreter.\n\"\"\"\nfrom typing import cast\n\nfrom lark import Lark, Transformer, v_args\n\nfrom kork import ast", "\nfrom kork import ast\n\nGRAMMAR = \"\"\"\n    program: statement+\n\n    statement: function_decl\n              | extern_function_decl\n              | var_decl\n              | expr", "              | var_decl\n              | expr\n\n    function_decl: \"fn\" CNAME \"(\" [params] \")\" \"->\" type block\n    extern_function_decl: \"extern\" \"fn\" CNAME \"(\" [params] \")\" \"->\" type\n    var_decl: (\"let\" | \"const\" | \"var\") CNAME \"=\" expr [\";\"]\n    params: param (\",\" param)*\n    param: CNAME \":\" type\n    type: CNAME\n    ", "    type: CNAME\n    \n    block: \"{\" [statement+] \"}\"\n    \n    ?expr: assignment\n    \n    ?assignment: CNAME \"=\" expr [\";\"] -> variable_assign\n        | term\n        \n    !?term: term \"+\" factor -> binary", "        \n    !?term: term \"+\" factor -> binary\n        | term \"-\" factor -> binary\n        | factor\n        \n    !?factor: factor \"*\" unary -> binary\n        | factor \"/\" unary -> binary\n        | factor \"%\" unary -> binary\n        | unary\n        ", "        | unary\n        \n    !?unary: \"-\" unary -> unary_r\n        | \"+\" unary -> unary_r\n        | power\n        \n    !?power: call \"**\" unary -> binary\n        | call \"^\" unary -> binary\n        | call\n    ", "        | call\n    \n    ?call: CNAME \"(\" [args] \")\" -> function_call\n        | primary\n    \n    ?primary: numbers\n        | list\n        | string\n        | \"true\" -> true\n        | \"false\" -> false", "        | \"true\" -> true\n        | \"false\" -> false\n        | \"null\" -> null\n        | \"(\" expr \")\" -> group\n        | CNAME -> identifier\n        \n    ?numbers: SIGNED_NUMBER (\"E\"|\"e\") SIGNED_NUMBER -> scientific\n        | SIGNED_NUMBER -> number\n        \n    args: expr (\",\" expr)*", "        \n    args: expr (\",\" expr)*\n    string: ESCAPED_STRING\n    list: \"[\" [args] \"]\"\n\n    %import common.CNAME\n    %import common.SIGNED_NUMBER\n    %import common.ESCAPED_STRING\n    %import common.WS\n    %ignore WS", "    %import common.WS\n    %ignore WS\n    %ignore /#.*/\n    %ignore /\\/\\/.*/\n\"\"\"\n\n\n# mypy: ignore-errors\n\n", "\n\n@v_args(inline=True)\nclass AstParser(Transformer):\n    \"\"\"An ast parser for the given language.\"\"\"\n\n    def program(self, *items) -> ast.Program:\n        \"\"\"Create a program from the given statements.\"\"\"\n        return ast.Program(stmts=items)\n\n    def function_decl(self, name, params, return_type, block) -> ast.FunctionDef:\n        \"\"\"Function declaration from the given name, params, return type and block.\"\"\"\n        return ast.FunctionDef(\n            name=str(name),\n            params=params,\n            return_type=return_type,\n            body=block,\n        )\n\n    def extern_function_decl(self, name, params, return_type) -> ast.ExternFunctionDef:\n        \"\"\"Extern function declaration from the given name, params and return type.\"\"\"\n        return ast.ExternFunctionDef(\n            name=str(name),\n            params=params or ast.ParamList(params=[]),\n            return_type=return_type,\n        )\n\n    def statement(self, item) -> ast.Stmt:\n        \"\"\"Create a statement from the given item.\"\"\"\n        return item\n\n    def var_decl(self, name, value) -> ast.VarDecl:\n        \"\"\"Variable declaration from the given name and value.\"\"\"\n        return ast.VarDecl(\n            name=str(name),\n            value=value,\n        )\n\n    def params(self, *items) -> ast.ParamList:\n        \"\"\"Create a param list from the given items.\"\"\"\n        return ast.ParamList(params=items or [])\n\n    def unary_r(self, operator, right) -> ast.Unary:\n        \"\"\"Create a unary from the given operator and left.\"\"\"\n        op = str(operator)\n        if op not in {\"+\", \"-\"}:\n            raise ValueError(f\"Unknown operator: {op}.\")\n        return ast.Unary(operator=str(operator), right=right)\n\n    def binary(self, left, operator, right) -> ast.Binary:\n        \"\"\"Create a binary from the given left, operator and right.\"\"\"\n        op = str(operator)\n        if op not in {\"+\", \"-\", \"*\", \"/\", \"**\", \"//\", \"%\", \"^\"}:\n            raise ValueError(f\"Unknown operator: {op}.\")\n        return ast.Binary(left=left, operator=str(operator), right=right)\n\n    def param(self, name, type_) -> ast.Param:\n        \"\"\"Create a param from the given name and type.\"\"\"\n        return ast.Param(\n            name=str(name),\n            type_=type_,\n        )\n\n    def type(self, name):\n        \"\"\"Create a type from the given name.\"\"\"\n        return str(name)\n\n    def block(self, *statements):\n        \"\"\"Create a block from the given statements.\"\"\"\n        return statements or []\n\n    def group(self, expr) -> ast.Grouping:\n        \"\"\"Create a group from the given expression.\"\"\"\n        return ast.Grouping(expr=expr)\n\n    def function_call(self, name, args) -> ast.FunctionCall:\n        \"\"\"Create a function call from the given name and args.\"\"\"\n        return ast.FunctionCall(name=str(name), args=args or [])\n\n    def identifier(self, name) -> ast.Variable:\n        \"\"\"Create a variable reference from the given name.\"\"\"\n        return ast.Variable(\n            name=str(name),\n        )\n\n    def variable_assign(self, name, value) -> ast.Assign:\n        \"\"\"Create a variable assignment from the given name and value.\"\"\"\n        return ast.Assign(\n            name=str(name),\n            value=value,\n        )\n\n    def expr(self, item) -> ast.Expr:\n        \"\"\"Create an expression from the given item.\"\"\"\n        return item\n\n    def args(self, *items):\n        \"\"\"Create an argument list for a function from the given items.\"\"\"\n        return items or []\n\n    def list(self, items) -> ast.List_:\n        \"\"\"Create a list literal from the given items.\"\"\"\n        return ast.List_(\n            elements=items or [],\n        )\n\n    def true(self) -> ast.Literal:\n        \"\"\"Create a true literal.\"\"\"\n        return ast.Literal(value=True)\n\n    def false(self) -> ast.Literal:\n        \"\"\"Create a false literal.\"\"\"\n        return ast.Literal(value=False)\n\n    def null(self) -> ast.Literal:\n        \"\"\"Create a null literal.\"\"\"\n        return ast.Literal(value=None)\n\n    def number(self, item) -> ast.Literal:\n        try:\n            return ast.Literal(value=int(item))\n        except ValueError:\n            return ast.Literal(value=float(item))\n\n    def scientific(self, coefficient, exponent) -> ast.Literal:\n        return ast.Literal(value=coefficient * 10**exponent)\n\n    def string(self, item) -> ast.Literal:\n        return ast.Literal(\n            value=str(item[1:-1]),\n        )", "\n\nast_parser = Lark(GRAMMAR, parser=\"lalr\", transformer=AstParser(), start=\"program\")\n\n# PUBLIC API\n\n\ndef parse(source: str) -> ast.Program:\n    \"\"\"Parse the given source code into an AST.\"\"\"\n    return cast(ast.Program, ast_parser.parse(source))", ""]}
{"filename": "kork/chain.py", "chunked_list": ["\"\"\"Implementation of a programming chain.\"\"\"\nfrom __future__ import annotations\n\nfrom typing import (\n    Any,\n    Callable,\n    Dict,\n    List,\n    Mapping,\n    Optional,", "    Mapping,\n    Optional,\n    Sequence,\n    Tuple,\n    TypedDict,\n    Union,\n    cast,\n)\n\nfrom langchain import LLMChain", "\nfrom langchain import LLMChain\nfrom langchain.chains.base import Chain\nfrom langchain.prompts import PromptTemplate\n\ntry:\n    from langchain.base_language import BaseLanguageModel\nexcept ImportError:\n    from langchain.schema import BaseLanguageModel\nfrom pydantic import Extra", "from pydantic import Extra\n\nfrom kork import ast\nfrom kork.ast_printer import AbstractAstPrinter, AstPrinter\nfrom kork.environment import Environment, create_environment\nfrom kork.examples import (\n    AbstractExampleRetriever,\n    InputFormatter,\n    SimpleExampleRetriever,\n    format_examples,", "    SimpleExampleRetriever,\n    format_examples,\n    format_text,\n)\nfrom kork.exceptions import LLMParseException\nfrom kork.interpreter import InterpreterResult, run_interpreter\nfrom kork.prompt_adapter import FewShotTemplate\nfrom kork.retrieval import AbstractContextRetriever, FuncLike, SimpleContextRetriever\nfrom kork.utils import unwrap_tag\n", "from kork.utils import unwrap_tag\n\n_INSTRUCTION_PROMPT = \"\"\"\\\nYou are programming in a language called \"{language_name}\".\n\nYou are an expert programmer and must follow the instructions below exactly.\n\nYour goal is to translate a user query into a corresponding and valid {language_name}\nprogram.\n", "program.\n\n{external_functions_block}\n\nDo not assume that any other functions except for the ones listed above exist.\n\nWrap the program in <code> and </code> tags.\n\nStore the solution to the query in a variable called \"result\".\n", "Store the solution to the query in a variable called \"result\".\n\nHere is a sample valid program:\n\n<code>\nvar x = 1 # Assign 1 to the variable x\nvar result = 1 + 2 # Calculate the sum of 1 + 2 and assign to result\nvar result = x # Assign the value of x to result\n</code>\n", "</code>\n\nGuidelines:\n- Do not use operators, instead invoke appropriate external functions.\n- Do not declare functions, do not use loops, do not use conditionals.\n- Solve the problem only using variable declarations and function invocations.\n\nBegin!\n\"\"\"\n", "\"\"\"\n\n\n# PUBLIC API\n\n\nDEFAULT_INSTRUCTION_PROMPT = PromptTemplate(\n    input_variables=[\n        \"language_name\",\n        \"external_functions_block\",", "        \"language_name\",\n        \"external_functions_block\",\n    ],\n    template=_INSTRUCTION_PROMPT,\n)\n\n\nclass CodeResult(TypedDict):\n    \"\"\"Result of a code chain.\"\"\"\n\n    errors: Sequence[Exception]\n    raw: str\n    code: str\n    environment: Optional[Environment]  # Returned on success", "\n\n# PUBLIC API\n\nExampleTuple = Tuple[str, ast.Program]\n\n\nclass CodeChain(Chain):\n    \"\"\"A coding chain.\"\"\"\n\n    llm: BaseLanguageModel\n    \"\"\"The language model to use for the coding chain.\"\"\"\n    interpreter: Callable[[str, Environment], InterpreterResult]\n    \"\"\"The interpreter to use for the coding chain.\"\"\"\n    ast_printer: AbstractAstPrinter\n    \"\"\"The AST printer to use for the coding chain.\"\"\"\n    context_retriever: Optional[AbstractContextRetriever] = None\n    \"\"\"Context to inject into the environment and prompt.\n    \n    At the moment, this context is limited to external functions.\n    \"\"\"\n    example_retriever: Optional[AbstractExampleRetriever] = None\n    \"\"\"Examples that should be added to the prompt.\"\"\"\n    instruction_template: PromptTemplate = DEFAULT_INSTRUCTION_PROMPT\n    \"\"\"Template for the instruction prompt.\"\"\"\n    input_key: str = \"query\"\n    # Smirking kat language\n    language_name: str = \"\ud83d\ude3c\"\n    input_formatter: InputFormatter = \"triple_quotes\"\n\n    \"\"\"The smirking kat programming language; aka Kork; aka \ud83d\ude3c\"\"\"\n\n    class Config:\n        \"\"\"Configuration for this pydantic object.\"\"\"\n\n        extra = Extra.allow\n        arbitrary_types_allowed = True\n\n    @property\n    def input_keys(self) -> List[str]:\n        \"\"\"Will be whatever keys the prompt expects.\n\n        :meta private:\n        \"\"\"\n        return [self.input_key]\n\n    @property\n    def output_keys(self) -> List[str]:\n        \"\"\"Output keys to return.\n\n        :meta private:\n        \"\"\"\n        return [\"raw\", \"errors\", \"code\", \"environment\"]\n\n    def prepare_context(\n        self, query: str, variables: Optional[Mapping[str, Any]] = None\n    ) -> Tuple[Environment, FewShotTemplate]:\n        \"\"\"Get the pre-populated environment and the few shot template.\n\n        Args:\n            query: The query to prepare the context for.\n            variables: Any variables that should be added to the context.\n\n        Returns:\n            The prepopulated environment and a pre-formatted few shot template.\n        \"\"\"\n        if self.context_retriever:\n            external_function_definitions = self.context_retriever.retrieve(query)\n        else:\n            external_function_definitions = []\n\n        environment = create_environment(external_function_definitions, variables)\n\n        if self.example_retriever:\n            formatted_examples = self.example_retriever.retrieve(query)\n        else:\n            formatted_examples = []\n\n        external_functions = \"\\n\".join(\n            [\n                self.ast_printer.visit(func_declaration)\n                for func_declaration in environment.list_external_functions()\n            ]\n        )\n\n        input_variables = self.instruction_template.input_variables\n\n        formatting_variables = {}\n\n        if \"language_name\" in input_variables:\n            formatting_variables[\"language_name\"] = self.language_name\n\n        if external_functions:\n            external_functions_block = (\n                \"You have access to the following external functions:\\n\\n\"\n                f\"```{self.language_name}\\n\"\n                f\"{external_functions}\\n\"\n                \"```\\n\"\n            )\n        else:\n            external_functions_block = \"Do not assume any functions exist.\\n\"\n\n        if \"external_functions_block\" in input_variables:\n            formatting_variables[\"external_functions_block\"] = external_functions_block\n\n        prompt = self.instruction_template.partial(\n            **formatting_variables,\n        )\n\n        return environment, FewShotTemplate(\n            instruction_template=prompt,\n            examples=formatted_examples,\n            input_variables=[\"query\"],\n        )\n\n    def _call(self, inputs: Dict[str, str]) -> CodeResult:  # type: ignore\n        \"\"\"Call the chain.\"\"\"\n        # Note not using original query!!\n        # We remove the leading and trailing whitespace from the query\n        # to make things a bit more robust.\n        query = inputs[self.input_key].strip()\n\n        variables: Mapping[str, Any] = cast(\n            Mapping[str, Any], inputs.get(\"variables\", {})\n        )\n\n        if not isinstance(variables, dict):\n            raise TypeError(\n                f\"Variables must be a dictionary, got {type(variables)} instead.\"\n            )\n\n        environment, few_shot_template = self.prepare_context(query, variables)\n\n        chain = LLMChain(\n            prompt=few_shot_template,\n            llm=self.llm,\n        )\n\n        formatted_query = format_text(query, self.input_formatter)\n        llm_output = cast(str, chain.predict_and_parse(query=formatted_query))\n        code = unwrap_tag(\"code\", llm_output)\n\n        if not code:\n            return {\n                \"errors\": [\n                    LLMParseException(\n                        \"Could not find code block. Please make sure the code \"\n                        \"is wrapped in a code block.\"\n                    )\n                ],\n                \"raw\": llm_output,\n                \"code\": \"\",\n                \"environment\": None,\n            }\n\n        interpreter_result = self.interpreter(code, environment)\n\n        if interpreter_result[\"errors\"]:\n            return {\n                \"errors\": interpreter_result[\"errors\"],\n                \"raw\": llm_output,\n                \"code\": code,\n                \"environment\": None,\n            }\n\n        return {\n            \"errors\": [],\n            \"raw\": llm_output,\n            \"code\": code,\n            \"environment\": interpreter_result[\"environment\"],\n        }\n\n    @property\n    def _chain_type(self) -> str:\n        \"\"\"Used for serialization.\"\"\"\n        return \"code_chain\"\n\n    @classmethod\n    def from_defaults(\n        cls,\n        *,\n        llm: BaseLanguageModel,\n        interpreter: Callable[[str, Environment], InterpreterResult] = run_interpreter,\n        ast_printer: AbstractAstPrinter = AstPrinter(),\n        context: Union[AbstractContextRetriever, Sequence[FuncLike], None] = None,\n        examples: Union[AbstractExampleRetriever, Sequence[ExampleTuple], None] = None,\n        instruction_template: PromptTemplate = DEFAULT_INSTRUCTION_PROMPT,\n        input_key: str = \"query\",\n        # Smirking kat language\n        language_name: str = \"\ud83d\ude3c\",\n        input_formatter: InputFormatter = \"markdown_text\",\n    ) -> CodeChain:\n        \"\"\"Create a code chain from pre-configured defaults.\n\n        Args:\n            llm: The language model to use for coding\n            interpreter: The interpreter that will be used to execute the program\n            ast_printer: An ast printer that can print the AST as a text string\n            context: Either a list of functions or a context retriever.\n                               The list of functions can be a mixture of python\n                               callables and Kork external functions.\n                               All python functions will be converted into Kork\n                               external functions, and everything passed into\n                               the default context retriever.\n            examples: An example retriever or a list of examples.\n                       If a list of examples, a simple example retriever\n                       will be created.\n            instruction_template: Use to customize the instruction components of\n                                  the prompt.\n            language_name: The language name to use for the prompt.\n            input_formatter: A formatting that will be applied to the input part\n                             of each example tuple, if passing in a list of examples.\n            input_key: The input key to use.\n\n        Returns:\n            A code chain\n        \"\"\"\n        if isinstance(examples, (AbstractExampleRetriever, type(None))):\n            _example_retriever = examples\n        elif isinstance(examples, Sequence):\n            formatted_examples = format_examples(\n                language_name,\n                examples,\n                ast_printer,\n                input_formatter=input_formatter,\n            )\n            _example_retriever = SimpleExampleRetriever(examples=formatted_examples)\n        else:\n            raise TypeError(\n                f\"example_retriever must be of type `AbstractExampleRetriever` or \"\n                f\"`Sequence[ExampleTuple]`. Got {type(examples)} instead.\"\n            )\n\n        if isinstance(context, (AbstractContextRetriever, type(None))):\n            _context_retriever = context\n        elif isinstance(context, Sequence):\n            _context_retriever = SimpleContextRetriever.from_functions(context)\n        else:\n            raise TypeError(\n                f\"context_retriever must be of type `AbstractContextRetriever` or \"\n                f\"`Sequence[FunctionDefinition]`. Got {type(context)} \"\n                f\"instead.\"\n            )\n\n        return cls(\n            llm=llm,\n            interpreter=interpreter,\n            ast_printer=ast_printer,\n            context_retriever=_context_retriever,\n            example_retriever=_example_retriever,\n            instruction_template=instruction_template,\n            input_key=input_key,\n            language_name=language_name,\n            input_formatter=input_formatter,\n        )", ""]}
{"filename": "kork/__init__.py", "chunked_list": ["from kork import ast\nfrom kork.ast_printer import AstPrinter\nfrom kork.chain import CodeChain\nfrom kork.environment import Environment\nfrom kork.examples import (\n    AbstractExampleRetriever,\n    SimpleExampleRetriever,\n    c_,\n    format_examples,\n    r_,", "    format_examples,\n    r_,\n)\nfrom kork.exceptions import KorkException\nfrom kork.interpreter import InterpreterResult, run_interpreter\nfrom kork.retrieval import AbstractContextRetriever, SimpleContextRetriever\n\n__all__ = [\n    \"CodeChain\",\n    \"ast\",", "    \"CodeChain\",\n    \"ast\",\n    \"AstPrinter\",\n    \"KorkException\",\n    \"InterpreterResult\",\n    \"run_interpreter\",\n    \"AbstractContextRetriever\",\n    \"SimpleContextRetriever\",\n    \"Environment\",\n    \"c_\",", "    \"Environment\",\n    \"c_\",\n    \"r_\",\n    \"format_examples\",\n    \"AbstractExampleRetriever\",\n    \"SimpleExampleRetriever\",\n]\n"]}
{"filename": "kork/utils.py", "chunked_list": ["import re\nfrom typing import Optional\n\n\ndef wrap_in_tag(tag_name: str, content: str) -> str:\n    \"\"\"Wrap the content in an HTML style tag.\"\"\"\n    return f\"<{tag_name}>{content}</{tag_name}>\"\n\n\ndef unwrap_tag(tag_name: str, text: str) -> Optional[str]:\n    \"\"\"Extract content located inside a tag.\"\"\"\n    pattern = f\"<{tag_name}>(.*?)</{tag_name}>\"\n    content = re.compile(pattern, re.DOTALL)\n    match = content.search(text)\n    if match:\n        return match.group(1)\n    else:\n        return None", "\ndef unwrap_tag(tag_name: str, text: str) -> Optional[str]:\n    \"\"\"Extract content located inside a tag.\"\"\"\n    pattern = f\"<{tag_name}>(.*?)</{tag_name}>\"\n    content = re.compile(pattern, re.DOTALL)\n    match = content.search(text)\n    if match:\n        return match.group(1)\n    else:\n        return None", "\n\ndef unwrap_code(language_name: str, text: str) -> Optional[str]:\n    \"\"\"Extract code located inside a code tag.\"\"\"\n    pattern = f\"```{language_name}\\n(.*?)\\n```\"\n    content = re.compile(pattern, re.DOTALL)\n    match = content.search(text)\n    if match:\n        return match.group(1)\n    else:\n        return None", ""]}
{"filename": "kork/examples.py", "chunked_list": ["\"\"\"Interface to specify kork examples easily.\"\"\"\nimport abc\nfrom typing import Any, Callable, List, Literal, Sequence, Tuple, Union\n\nfrom kork import ast\nfrom kork.ast_printer import AbstractAstPrinter\nfrom kork.foreign_funcs import to_kork_function_call\nfrom kork.utils import wrap_in_tag\n\n\ndef _add_result_variable(expr: ast.Expr) -> ast.Program:\n    \"\"\"Assembles a solution from a program.\"\"\"\n    stmt = ast.VarDecl(name=\"result\", value=expr)\n    return ast.Program(stmts=[stmt])", "\n\ndef _add_result_variable(expr: ast.Expr) -> ast.Program:\n    \"\"\"Assembles a solution from a program.\"\"\"\n    stmt = ast.VarDecl(name=\"result\", value=expr)\n    return ast.Program(stmts=[stmt])\n\n\n# PUBLIC API\n", "# PUBLIC API\n\n# Use to denote different types of formatters for the input.\nInputFormatter = Union[\n    Literal[\"text_prefix\"],\n    Literal[\"triple_quotes\"],\n    Literal[\"markdown_text\"],\n    None,\n    Callable[[str], str],\n]", "    Callable[[str], str],\n]\n\n\ndef format_text(text: str, input_formatter: InputFormatter = None) -> str:\n    \"\"\"An encoder for the input text.\n\n    Args:\n        text: the text to encode\n        input_formatter: the formatter to use for the input\n            * None: use for single sentences or single paragraphs, no formatting\n            * triple_quotes: surround input with \\\"\\\"\\\", use for long text\n            * text_prefix: same as triple_quote but with `TEXT: ` prefix\n            * Callable: user provided function\n\n    Returns:\n        The encoded text if it was encoded\n    \"\"\"\n    if input_formatter == \"text_prefix\":\n        return 'Text: \"\"\"\\n' + text + '\\n\"\"\"'\n    elif input_formatter == \"triple_quotes\":\n        return '\"\"\"\\n' + text + '\\n\"\"\"'\n    elif input_formatter == \"markdown_text\":\n        return \"```text\\n\" + text + \"\\n```\"\n    elif input_formatter is None:\n        return text\n    else:\n        raise NotImplementedError(\n            f'No support for input encoding \"{input_formatter}\". '\n            ' Use one of \"long_text\" or None.'\n        )", "\n\n# Alias to create a kork function call\ndef c_(name: Callable, *args: Any) -> ast.FunctionCall:\n    \"\"\"Create a kork function call.\"\"\"\n    return to_kork_function_call(name, *args)\n\n\n# Alias to assign the expression to a variable called `result`\ndef r_(expr: ast.Expr) -> ast.Program:\n    \"\"\"Assign last program expression to a result variable.\"\"\"\n    return _add_result_variable(expr)", "# Alias to assign the expression to a variable called `result`\ndef r_(expr: ast.Expr) -> ast.Program:\n    \"\"\"Assign last program expression to a result variable.\"\"\"\n    return _add_result_variable(expr)\n\n\ndef format_examples(\n    language_name: str,\n    examples: Sequence[Tuple[str, ast.Program]],\n    ast_printer: AbstractAstPrinter,\n    input_formatter: InputFormatter = None,\n) -> List[Tuple[str, str]]:\n    \"\"\"Format examples.\"\"\"\n    formatted_examples = []\n    for example_input, desired_output in examples:\n        formatted_input = format_text(example_input, input_formatter=input_formatter)\n        formatted_examples.append(\n            (\n                formatted_input,\n                wrap_in_tag(\"code\", ast_printer.visit(desired_output)),\n            )\n        )\n\n    return formatted_examples", "\n\nclass AbstractExampleRetriever(abc.ABC):\n    \"\"\"Abstract interface for an example retriever.\n\n    An example interface must implement the `retrieve` method which\n    returns a list of relevant examples based on the given query.\n    \"\"\"\n\n    @abc.abstractmethod\n    def retrieve(self, query: str) -> List[Tuple[str, str]]:\n        \"\"\"Retrieve examples.\"\"\"", "\n\nclass SimpleExampleRetriever(AbstractExampleRetriever):\n    \"\"\"Simple example retriever.\n\n    Simple example that returns the examples it was initialized with.\n\n    Supports initialization from a list of programs.\n\n    Example:\n\n    .. code-block:: python\n\n        from kork import SimpleExampleRetriever, AstPrinter, c_, r_\n\n        simple_example_retriever = SimpleExampleRetriever.from_programs(\n            language_name=\"kork\",\n            examples=[\n                (\"add 1 2\", r_(c_(add, 1, 2))),\n                (\"add 1 2 3\", r_(c_(add, 1, 2, 3))),\n                ],\n            ast_printer=AstPrinter(),\n        )\n\n        examples = simple_example_retriever.retrieve(\"add 1 2\")\n    \"\"\"\n\n    def __init__(\n        self,\n        examples: Sequence[Tuple[str, str]],\n    ) -> None:\n        \"\"\"Initialize the retriever with a list of examples.\"\"\"\n        self._examples = examples\n\n    def retrieve(self, query: str) -> List[Tuple[str, str]]:\n        \"\"\"Retrieve examples that best match the given query.\"\"\"\n        return list(self._examples)\n\n    @classmethod\n    def from_programs(\n        cls,\n        language_name: str,\n        examples: Sequence[Tuple[str, ast.Program]],\n        ast_printer: AbstractAstPrinter,\n    ) -> \"SimpleExampleRetriever\":\n        \"\"\"Create a simple example retriever from programs.\n\n        Args:\n            language_name: The language name to use for the markdown code blocks.\n            examples: A sequence of tuples of the form (query, desired program).\n            ast_printer: The ast printer to use to format the desired output.\n\n        Returns:\n            A simple example retriever.\n        \"\"\"\n        return cls(\n            examples=format_examples(\n                language_name=language_name,\n                examples=examples,\n                ast_printer=ast_printer,\n            )\n        )", ""]}
{"filename": "kork/display.py", "chunked_list": ["\"\"\"Utils for displaying chain results in a notebook.\"\"\"\nimport base64\nimport math\nfrom html import escape\nfrom io import BytesIO\nfrom typing import Any, Optional, Sequence, TypedDict, Union\n\nfrom kork.ast_printer import AstPrinter\nfrom kork.chain import CodeResult\nfrom kork.parser import parse  # type: ignore", "from kork.chain import CodeResult\nfrom kork.parser import parse  # type: ignore\n\ntry:\n    from PIL.Image import Image\nexcept ImportError:\n    Image = None\n\n\ndef image_base64(image: Image) -> str:\n    \"\"\"Get a base64 representation of an image.\"\"\"\n    with BytesIO() as buffer:\n        image.save(buffer, \"jpeg\")\n        return base64.b64encode(buffer.getvalue()).decode()", "\ndef image_base64(image: Image) -> str:\n    \"\"\"Get a base64 representation of an image.\"\"\"\n    with BytesIO() as buffer:\n        image.save(buffer, \"jpeg\")\n        return base64.b64encode(buffer.getvalue()).decode()\n\n\ndef as_img_tag(image: Image) -> str:\n    \"\"\"Get an HTML representation of an image.\"\"\"\n    return f'<img src=\"data:image/jpeg;base64,{image_base64(image)}\">'", "def as_img_tag(image: Image) -> str:\n    \"\"\"Get an HTML representation of an image.\"\"\"\n    return f'<img src=\"data:image/jpeg;base64,{image_base64(image)}\">'\n\n\nclass HtmlResult(TypedDict):\n    \"\"\"A result that can be displayed in a notebook.\"\"\"\n\n    query: str\n    errors: str\n    raw: str\n    code: str\n    result: str\n    expected: str\n    correct: str", "\n\nclass _NoExpectedAnswer:\n    \"\"\"A sentinel class to indicate that there is no expected answer.\"\"\"\n\n\nNO_EXPECTED_ANSWER = _NoExpectedAnswer()\n\n\ndef as_html_dict(\n    code_result: CodeResult,\n    query: Optional[str] = None,\n    expected_answer: Optional[Any] = None,\n    result_key: str = \"result\",\n    pretty_print: bool = True,\n) -> HtmlResult:\n    \"\"\"Use to generate a dict that can be easily displayed in an IPython notebook.\"\"\"\n    from IPython import display as ipy_display\n\n    code = code_result[\"code\"].strip()\n\n    if pretty_print:\n        try:\n            code = AstPrinter().visit(parse(code), pretty_print=True)\n        except Exception:\n            # This is display code. Broad exception handling OK for now\n            # we can make the code more robust later.\n            code = code\n    else:\n        code = code\n\n    if code:\n        _code = ipy_display.Code(data=code)._repr_html_().strip().replace(\"\\n\", \"<br/>\")\n    else:\n        _code = code\n\n    env = code_result[\"environment\"]\n\n    result = env.variables.get(result_key, \"\") if env else \"\"\n\n    if expected_answer is NO_EXPECTED_ANSWER:\n        _correct = \"N/A\"\n    else:\n        if isinstance(expected_answer, (float, int)) and isinstance(\n            result, (float, int)\n        ):\n            correct = math.isclose(expected_answer, result)\n        else:\n            correct = bool(expected_answer == result)\n        _correct = \"\u2705\" if correct else \"\u26d4\"\n\n    query = query or code_result.get(\"query\", \"\")  # type: ignore\n\n    if Image and isinstance(result, Image):\n        _result = as_img_tag(result)\n    else:\n        _result = escape(str(result).strip())\n\n    _expected = (\n        \"\" if expected_answer is NO_EXPECTED_ANSWER else escape(str(expected_answer))\n    )\n\n    return {\n        \"query\": escape(str(query)),\n        \"errors\": escape(str(code_result[\"errors\"])),\n        \"raw\": escape(str(code_result[\"raw\"])).replace(\"\\n\", \"<br/>\"),\n        \"code\": _code,\n        \"result\": _result,\n        \"expected\": _expected,\n        \"correct\": _correct,\n    }", "\ndef as_html_dict(\n    code_result: CodeResult,\n    query: Optional[str] = None,\n    expected_answer: Optional[Any] = None,\n    result_key: str = \"result\",\n    pretty_print: bool = True,\n) -> HtmlResult:\n    \"\"\"Use to generate a dict that can be easily displayed in an IPython notebook.\"\"\"\n    from IPython import display as ipy_display\n\n    code = code_result[\"code\"].strip()\n\n    if pretty_print:\n        try:\n            code = AstPrinter().visit(parse(code), pretty_print=True)\n        except Exception:\n            # This is display code. Broad exception handling OK for now\n            # we can make the code more robust later.\n            code = code\n    else:\n        code = code\n\n    if code:\n        _code = ipy_display.Code(data=code)._repr_html_().strip().replace(\"\\n\", \"<br/>\")\n    else:\n        _code = code\n\n    env = code_result[\"environment\"]\n\n    result = env.variables.get(result_key, \"\") if env else \"\"\n\n    if expected_answer is NO_EXPECTED_ANSWER:\n        _correct = \"N/A\"\n    else:\n        if isinstance(expected_answer, (float, int)) and isinstance(\n            result, (float, int)\n        ):\n            correct = math.isclose(expected_answer, result)\n        else:\n            correct = bool(expected_answer == result)\n        _correct = \"\u2705\" if correct else \"\u26d4\"\n\n    query = query or code_result.get(\"query\", \"\")  # type: ignore\n\n    if Image and isinstance(result, Image):\n        _result = as_img_tag(result)\n    else:\n        _result = escape(str(result).strip())\n\n    _expected = (\n        \"\" if expected_answer is NO_EXPECTED_ANSWER else escape(str(expected_answer))\n    )\n\n    return {\n        \"query\": escape(str(query)),\n        \"errors\": escape(str(code_result[\"errors\"])),\n        \"raw\": escape(str(code_result[\"raw\"])).replace(\"\\n\", \"<br/>\"),\n        \"code\": _code,\n        \"result\": _result,\n        \"expected\": _expected,\n        \"correct\": _correct,\n    }", "\n\ndef display_html_results(\n    html_results: Union[Sequence[HtmlResult], HtmlResult],\n    columns: Optional[Sequence[str]] = None,\n) -> Any:\n    \"\"\"Display a sequence of HTML results as a table.\"\"\"\n    import pandas as pd\n    from IPython import display\n\n    _results = html_results if isinstance(html_results, list) else [html_results]\n\n    _columns = (\n        columns\n        if columns\n        else [\"query\", \"code\", \"result\", \"expected\", \"correct\", \"errors\", \"raw\"]\n    )\n\n    df = pd.DataFrame(_results, columns=_columns)\n    if \"query\" in df.columns:\n        df[\"query\"] = df[\"query\"].str.wrap(40)\n        df[\"query\"] = df[\"query\"].str.replace(\"\\n\", \"<br/>\")\n    df = df.style.set_properties(**{\"text-align\": \"left\"})\n    return display.HTML(df.to_html(escape=False, index=False))", "\n\ndef display_code_result(\n    code_result: CodeResult,\n    query: Optional[str] = None,\n    expected_answer: Optional[Any] = NO_EXPECTED_ANSWER,\n    columns: Optional[Sequence[str]] = None,\n    result_key: str = \"result\",\n) -> Any:\n    \"\"\"Display a code result as a table.\"\"\"\n    return display_html_results(\n        as_html_dict(\n            code_result,\n            query=query,\n            expected_answer=expected_answer,\n            result_key=result_key,\n        ),\n        columns=columns,\n    )", ""]}
{"filename": "kork/interpreter.py", "chunked_list": ["from typing import Any, Optional, Sequence, TypedDict, Union\n\nfrom lark.exceptions import LarkError\n\nfrom kork import ast\nfrom kork.environment import Environment\nfrom kork.exceptions import KorkRunTimeException\n\n# TODO: Determine why mypy is not recognizing the import.\nfrom kork.parser import parse  # type: ignore[attr-defined]", "# TODO: Determine why mypy is not recognizing the import.\nfrom kork.parser import parse  # type: ignore[attr-defined]\n\n\nclass Interpreter(ast.Visitor):\n    \"\"\"Kork's default interpreter.\"\"\"\n\n    def __init__(self, program: ast.Program, environment: Environment) -> None:\n        \"\"\"Initialize the interpreter.\"\"\"\n        self.program = program\n        self.environment = environment\n        self.last_expression_value: Any = None\n\n    def intepret(self) -> None:\n        \"\"\"Interpret the program.\"\"\"\n        self.program.accept(self)\n\n    def visit_program(self, program: ast.Program) -> None:\n        \"\"\"Visit a program.\"\"\"\n        for stmt in program.stmts:\n            stmt.accept(self)\n\n    def visit_extern_function_def(\n        self, extern_function_def: ast.ExternFunctionDef\n    ) -> None:\n        \"\"\"Visit an external function definition.\"\"\"\n        self.environment.variables[extern_function_def.name] = extern_function_def\n\n    def visit_function_call(self, call: ast.FunctionCall) -> Any:\n        \"\"\"Visit a function call.\"\"\"\n        function = self.environment.get_symbol(call.name)\n        args = [arg.accept(self) for arg in call.args]\n        if isinstance(function, ast.ExternFunctionDef):\n            if function.implementation is None:\n                raise KorkRunTimeException(\"External function has not been linked yet.\")\n            try:\n                return function.implementation(*args)\n            except Exception as e:\n                raise KorkRunTimeException(\n                    \"Encountered an exception while invoking an external function \"\n                    f\"`{call.name}` with arguments: `{args}`.\"\n                    f\"Details: {e}\"\n                )\n        elif isinstance(function, ast.FunctionDef):\n            raise KorkRunTimeException(\"Function definition is unimplemented.\")\n        else:\n            raise KorkRunTimeException(f\"Cannot call {call.name}.\")\n\n    def visit_function_def(self, function_def: ast.FunctionDef) -> None:\n        \"\"\"Visit a function definition.\"\"\"\n        self.environment.variables[function_def.name] = function_def\n\n    def visit_variable(self, variable: ast.Variable) -> Any:\n        \"\"\"Visit a variable.\"\"\"\n        return self.environment.get_symbol(variable.name)\n\n    def visit_var_decl(self, var_decl: ast.VarDecl) -> None:\n        \"\"\"Visit a variable declaration.\"\"\"\n        self.environment.variables[var_decl.name] = var_decl.value.accept(self)\n\n    def visit_unary(self, unary: ast.Unary) -> Any:\n        \"\"\"Visit a unary expression.\"\"\"\n        operator = unary.operator\n        right = unary.right.accept(self)\n        if operator == \"-\":\n            return -right\n        elif operator == \"+\":\n            return right\n        else:\n            raise ValueError(f\"Unknown operator {operator}.\")\n\n    def visit_binary(self, binary: ast.Binary) -> Any:\n        \"\"\"Visit a binary expression.\"\"\"\n        left = binary.left.accept(self)\n        right = binary.right.accept(self)\n        operator = binary.operator\n        if operator == \"+\":\n            return left + right\n        elif operator == \"-\":\n            return left - right\n        elif operator == \"*\":\n            return left * right\n        elif operator == \"/\":\n            return left / right\n        elif operator == \"**\":\n            return left**right\n        elif operator == \"%\":\n            return left % right\n        elif (\n            operator == \"^\"\n        ):  # Please note that we do not follow python convention here\n            return left**right  # Duplicating `**` operator\n        else:\n            raise ValueError(f\"Unknown operator {operator}.\")\n\n    def visit_grouping(self, grouping: ast.Grouping) -> Any:\n        \"\"\"Visit a grouping.\"\"\"\n        return grouping.expr.accept(self)\n\n    def visit_assign(self, assign: ast.Assign) -> None:\n        \"\"\"Visit an assignment.\"\"\"\n        self.environment.variables[assign.name] = assign.value.accept(self)\n\n    def visit_literal(self, literal: ast.Literal) -> Union[int, float, bool, str, None]:\n        \"\"\"Visit a number.\"\"\"\n        return literal.value\n\n    def visit_list_(self, list_: ast.List_) -> list:\n        \"\"\"Visit a list.\"\"\"\n        return [element.accept(self) for element in list_.elements]", "\n\n# PUBLIC API\n\n\nclass InterpreterResult(TypedDict):\n    \"\"\"Use this to return the result of the interpreter.\"\"\"\n\n    environment: Environment\n    errors: Sequence[Exception]", "\n\ndef run_interpreter(\n    code: str, environment: Optional[Environment] = None\n) -> InterpreterResult:\n    \"\"\"Run the interpreter with the given code.\n\n    Args:\n        code: The code to run\n        environment: The environment to run the code in\n\n    Returns:\n        the final environment after running the code (this will likely change)\n    \"\"\"\n    # TODO(Eugene): May want to refactor to avoid cloning here without introducing\n    #                mutability associated bugs.\n    environment = (\n        environment.clone() if environment else Environment(parent=None, variables={})\n    )\n    try:\n        program = parse(code)\n        interpreter = Interpreter(program, environment)\n        interpreter.intepret()\n    except (\n        LarkError,\n        KorkRunTimeException,\n        ValueError,\n        ZeroDivisionError,\n        TypeError,\n    ) as e:\n        return InterpreterResult(\n            environment=environment,\n            errors=[e],\n        )\n\n    return InterpreterResult(\n        environment=interpreter.environment,\n        errors=[],\n    )", ""]}
{"filename": "kork/ast.py", "chunked_list": ["\"\"\"The AST for the language.\n\nThe AST is a bit messy right now in terms of what's a statement vs. an expression,\nand will likely need to be cleaned up a bit in the near future.\n\"\"\"\nfrom __future__ import annotations\n\nimport abc\nimport dataclasses\nfrom typing import Any, Callable, Optional, Sequence, TypeVar, Union", "import dataclasses\nfrom typing import Any, Callable, Optional, Sequence, TypeVar, Union\n\nT = TypeVar(\"T\")\n\n\nclass Visitor(abc.ABC):\n    \"\"\"Abstract visitor interface.\"\"\"\n\n\ndef _to_snake_case(name: str) -> str:\n    \"\"\"Convert a name into snake_case.\"\"\"\n    snake_case = \"\"\n    for i, char in enumerate(name):\n        if char.isupper() and i != 0:\n            snake_case += \"_\" + char.lower()\n        else:\n            snake_case += char.lower()\n    return snake_case", "\n\ndef _to_snake_case(name: str) -> str:\n    \"\"\"Convert a name into snake_case.\"\"\"\n    snake_case = \"\"\n    for i, char in enumerate(name):\n        if char.isupper() and i != 0:\n            snake_case += \"_\" + char.lower()\n        else:\n            snake_case += char.lower()\n    return snake_case", "\n\n@dataclasses.dataclass(frozen=True)\nclass Expr(abc.ABC):\n    \"\"\"Abstract expression.\"\"\"\n\n    def accept(self, visitor: Visitor, **kwargs: Any) -> Any:\n        \"\"\"Accept implementation for a visitor.\"\"\"\n        return getattr(visitor, f\"visit_{_to_snake_case(self.__class__.__name__)}\")(\n            self, **kwargs\n        )", "\n\n@dataclasses.dataclass(frozen=True)\nclass Literal(Expr):\n    \"\"\"A literal expression.\"\"\"\n\n    value: Union[float, int, bool, None, str]\n\n\n@dataclasses.dataclass(frozen=True)\nclass Grouping(Expr):\n    \"\"\"A grouping expression.\"\"\"\n\n    expr: Expr", "\n@dataclasses.dataclass(frozen=True)\nclass Grouping(Expr):\n    \"\"\"A grouping expression.\"\"\"\n\n    expr: Expr\n\n\n@dataclasses.dataclass(frozen=True)\nclass Unary(Expr):\n    \"\"\"A unary expression.\"\"\"\n\n    operator: str\n    right: Expr", "@dataclasses.dataclass(frozen=True)\nclass Unary(Expr):\n    \"\"\"A unary expression.\"\"\"\n\n    operator: str\n    right: Expr\n\n\n@dataclasses.dataclass(frozen=True)\nclass Binary(Expr):\n    \"\"\"A binary expression.\"\"\"\n\n    left: Expr\n    operator: str\n    right: Expr", "@dataclasses.dataclass(frozen=True)\nclass Binary(Expr):\n    \"\"\"A binary expression.\"\"\"\n\n    left: Expr\n    operator: str\n    right: Expr\n\n\n@dataclasses.dataclass(frozen=True)\nclass Assign(Expr):\n    \"\"\"Assignment statement for a variable.\"\"\"\n\n    name: str\n    value: Expr", "\n@dataclasses.dataclass(frozen=True)\nclass Assign(Expr):\n    \"\"\"Assignment statement for a variable.\"\"\"\n\n    name: str\n    value: Expr\n\n\n@dataclasses.dataclass(frozen=True)\nclass Variable(Expr):\n    \"\"\"Variable reference.\"\"\"\n\n    name: str", "\n@dataclasses.dataclass(frozen=True)\nclass Variable(Expr):\n    \"\"\"Variable reference.\"\"\"\n\n    name: str\n\n\n@dataclasses.dataclass(frozen=True)\nclass List_(Expr):\n    \"\"\"List literal.\"\"\"\n\n    elements: Sequence[Expr]", "@dataclasses.dataclass(frozen=True)\nclass List_(Expr):\n    \"\"\"List literal.\"\"\"\n\n    elements: Sequence[Expr]\n\n\n@dataclasses.dataclass(frozen=True)\nclass Stmt(abc.ABC):\n    \"\"\"Abstract statement.\"\"\"\n\n    def accept(self, visitor: Visitor, **kwargs: Any) -> Any:\n        \"\"\"Accept implementation for a visitor.\"\"\"\n        return getattr(visitor, f\"visit_{_to_snake_case(self.__class__.__name__)}\")(\n            self, **kwargs\n        )", "class Stmt(abc.ABC):\n    \"\"\"Abstract statement.\"\"\"\n\n    def accept(self, visitor: Visitor, **kwargs: Any) -> Any:\n        \"\"\"Accept implementation for a visitor.\"\"\"\n        return getattr(visitor, f\"visit_{_to_snake_case(self.__class__.__name__)}\")(\n            self, **kwargs\n        )\n\n", "\n\n@dataclasses.dataclass(frozen=True)\nclass Param(Stmt):\n    \"\"\"Represent a function parameter.\"\"\"\n\n    name: str\n    type_: str\n\n", "\n\n@dataclasses.dataclass(frozen=True)\nclass ParamList(Stmt):\n    \"\"\"Represent a list of function parameters.\"\"\"\n\n    params: Sequence[Param]\n\n\n@dataclasses.dataclass(frozen=True)\nclass FunctionDef(Stmt):\n    \"\"\"Represent a function definition with an implementation.\"\"\"\n\n    name: str\n    params: ParamList\n    body: Sequence[Union[Stmt, Expr]]\n    # This is just an annotation so it's a string.\n    return_type: str", "\n@dataclasses.dataclass(frozen=True)\nclass FunctionDef(Stmt):\n    \"\"\"Represent a function definition with an implementation.\"\"\"\n\n    name: str\n    params: ParamList\n    body: Sequence[Union[Stmt, Expr]]\n    # This is just an annotation so it's a string.\n    return_type: str", "\n\n@dataclasses.dataclass(frozen=True)\nclass ExternFunctionDef(Stmt):\n    \"\"\"External function definition.\"\"\"\n\n    name: str\n    params: ParamList\n    # This is just an annotation so it's a string.\n    return_type: str\n    implementation: Optional[Callable] = None\n    doc_string: str = \"\"\n\n    def add_implementation(self, implementation: Callable) -> \"ExternFunctionDef\":\n        \"\"\"Add an implementation to an external function definition.\"\"\"\n        if self.implementation is not None:\n            raise ValueError(\"Cannot add implementation to an already implemented func\")\n        return ExternFunctionDef(\n            name=self.name,\n            params=self.params,\n            return_type=self.return_type,\n            implementation=implementation,\n        )", "\n\n@dataclasses.dataclass(frozen=True)\nclass FunctionCall(Expr):\n    \"\"\"Represent a function call.\"\"\"\n\n    name: str  # Name of function being invoked\n    args: Sequence[Expr]  # Arguments to the function call\n\n", "\n\n@dataclasses.dataclass(frozen=True)\nclass VarDecl(Stmt):\n    \"\"\"Represent a variable declaration.\"\"\"\n\n    name: str  # Name of variable\n    value: Expr  # Expression to assign to the variable\n\n", "\n\n@dataclasses.dataclass(frozen=True)\nclass Program(Stmt):\n    \"\"\"Represent a program.\"\"\"\n\n    stmts: Sequence[Union[Stmt, Expr]]\n"]}
{"filename": "kork/prompt_adapter.py", "chunked_list": ["\"\"\"A prompt adapter to allow working with both regular LLMs and Chat LLMs.\n\nThe prompt adapter supports breaking the prompt into:\n\n1) Instruction Section\n2) (Optional) Example Section\n\"\"\"\nfrom typing import Any, Callable, List, Sequence, Tuple\n\nfrom langchain import BasePromptTemplate, PromptTemplate", "\nfrom langchain import BasePromptTemplate, PromptTemplate\nfrom langchain.schema import BaseMessage, HumanMessage, PromptValue, SystemMessage\nfrom pydantic import Extra\n\n\nclass FewShotPromptValue(PromptValue):\n    \"\"\"Integration with langchain prompt format.\"\"\"\n\n    string: Callable[[], str]\n    messages: Callable[[], List[BaseMessage]]\n\n    class Config:\n        \"\"\"Configuration for this pydantic object.\"\"\"\n\n        extra = Extra.forbid\n        arbitrary_types_allowed = True\n\n    def to_string(self) -> str:\n        \"\"\"Format the prompt to a string.\"\"\"\n        return self.string()\n\n    def to_messages(self) -> List[BaseMessage]:\n        \"\"\"Get materialized messages.\"\"\"\n        return self.messages()", "\n\nclass FewShotTemplate(BasePromptTemplate):\n    \"\"\"Code prompt template.\"\"\"\n\n    instruction_template: PromptTemplate\n    examples: Sequence[Tuple[str, str]] = ()\n\n    @property\n    def _prompt_type(self) -> str:\n        \"\"\"Get the prompt type.\"\"\"\n        return \"FewShotTemplate\"\n\n    def format_prompt(self, **kwargs: Any) -> PromptValue:\n        \"\"\"Format the prompt.\"\"\"\n        if len(self.input_variables) != 1:\n            raise AssertionError(\n                f\"Expected 1 input variable, got {len(self.input_variables)}\"\n            )\n\n        query_key = self.input_variables[0]\n        query = kwargs[query_key]\n\n        def _lazy_string() -> str:\n            \"\"\"Lazy string.\"\"\"\n            return self.to_string(query)\n\n        def _lazy_messages() -> List[BaseMessage]:\n            \"\"\"Lazy messages.\"\"\"\n            return self.to_messages(query)\n\n        return FewShotPromptValue(\n            string=_lazy_string,\n            messages=_lazy_messages,\n        )\n\n    def format(self, **kwargs: Any) -> str:\n        \"\"\"Deprecated format method.\"\"\"\n        raise NotImplementedError()\n\n    def to_string(self, query: str) -> str:\n        \"\"\"Format the prompt to a string.\"\"\"\n        instruction_section = self.instruction_template.format()\n\n        examples_block = \"\"\n\n        for input_example, output_example in self.examples:\n            examples_block += f\"Input: {input_example}\\n\\nOutput: {output_example}\\n\\n\"\n\n        return instruction_section + examples_block + f\"Input: {query}\\n\\nOutput:\"\n\n    def to_messages(self, query: str) -> List[BaseMessage]:\n        \"\"\"Get materialized messages.\"\"\"\n        instruction_segment = self.instruction_template.format().strip()\n        messages: List[BaseMessage] = [SystemMessage(content=instruction_segment)]\n\n        for input_example, output_example in self.examples:\n            messages.append(HumanMessage(content=input_example.strip()))\n            messages.append(SystemMessage(content=output_example.strip()))\n\n        messages.append(HumanMessage(content=query.strip()))\n\n        return messages", ""]}
{"filename": "kork/foreign_funcs.py", "chunked_list": ["\"\"\"API to import foreign functions.\"\"\"\nimport inspect\nimport sys\nimport types\nimport typing\nfrom typing import Any, Callable, List, Mapping, Tuple, TypedDict\n\nfrom kork import ast\n\nPY_VERSION = (sys.version_info.major, sys.version_info.minor)", "\nPY_VERSION = (sys.version_info.major, sys.version_info.minor)\n\n\nclass FunctionInfo(TypedDict):\n    \"\"\"Information about a function.\"\"\"\n\n    name: str\n    args: List[Tuple[str, Any, Any]]\n    return_type: Any\n    docstring: str", "\n\ndef _type_repr(obj: Any) -> str:\n    \"\"\"Return the repr() of an object, special-casing types (internal helper).\n\n    If obj is a type, we return a shorter version than the default\n    type.__repr__, based on the module and qualified name, which is\n    typically enough to uniquely identify a type.  For everything\n    else, we fall back on repr(obj).\n    \"\"\"\n    if PY_VERSION >= (3, 9):\n        # Ignoring type for passing mypy testing with Python 3.8\n        if isinstance(obj, types.GenericAlias):  # type: ignore[attr-defined]\n            return repr(obj)\n    if isinstance(obj, type):\n        if obj.__module__ == \"builtins\":\n            return obj.__qualname__\n        return f\"{obj.__module__}.{obj.__qualname__}\"\n    if obj is ...:\n        return \"...\"\n    if isinstance(obj, types.FunctionType):\n        return obj.__name__\n    return repr(obj)", "\n\ndef _type_repr_wrapper(obj: Any) -> str:\n    \"\"\"A hack to remove all references to `typing.` in type strings.\n\n    There's likely a much better solution, but this will do for prototyping.\n\n    Args:\n        obj (Any): The object to get the type string of.\n\n    Returns:\n        str: The type string of the object.\n    \"\"\"\n    return _type_repr(obj).replace(\"typing.\", \"\")", "\n\ndef _get_stringified_type(type_hints: Mapping[str, Any], arg_name: str) -> str:\n    \"\"\"Get string version of an argument type from a mapping of type hints.\n\n    Args:\n        type_hints (Mapping[str, Any]): Mapping of argument names to types.\n        arg_name (str): Name of the argument or `return` for the return type.\n\n    Returns:\n        str: String representation of the type if it exists, otherwise Any.\n    \"\"\"\n    if arg_name in type_hints:\n        return _type_repr_wrapper(type_hints[arg_name])\n    else:\n        return \"Any\"", "\n\ndef _get_function_info(func: Callable) -> FunctionInfo:\n    \"\"\"Extract information about a function.\n\n    Args:\n        func (callable): The function to get information about.\n\n    Returns:\n        A dictionary with the following keys:\n            - name: The name of the function.\n            - args: A list of tuples containing the name and type of each argument.\n            - return_type: The type of the value returned by the function.\n            - docstring: The docstring of the function.\n    \"\"\"\n    # Get the name of the function\n    name = func.__name__\n\n    try:\n        # Get information about the function's arguments\n        type_hints = typing.get_type_hints(func)\n    except ValueError:\n        type_hints = {}\n\n    try:\n        signature = inspect.signature(func)\n        args = []\n        for arg_name, param in signature.parameters.items():\n            arg_type = _get_stringified_type(type_hints, arg_name)\n            arg_default = (\n                param.default if param.default != inspect.Parameter.empty else None\n            )\n            args.append((arg_name, arg_type, arg_default))\n\n        # Get the return type of the function\n        return_type = _get_stringified_type(type_hints, \"return\")\n    except ValueError:  # TODO: Exception is too broad, limit to correct scope\n        return_type = \"Any\"\n        args = []\n\n    # Get the docstring of the function\n    docstring = func.__doc__\n\n    # Construct and return a dictionary with the function information\n    return {\n        \"name\": name,\n        \"args\": args,\n        \"return_type\": return_type,\n        \"docstring\": docstring.strip() if docstring else \"\",\n    }", "\n\ndef _convert_to_kork_expr(value: Any) -> ast.Expr:\n    \"\"\"Convert mixed-expression value to a kork expression.\n\n    This function converts a potentially mixed python, kork expression\n    into a pure kork expression.\n\n    Args:\n        value (Any): The value to convert.\n\n    Returns:\n        An `kork` expression.\n    \"\"\"\n    if isinstance(value, ast.Expr):\n        # If it's already a kork expression, return as is\n        return value\n    elif isinstance(value, (int, float, bool, type(None), str)):\n        return ast.Literal(value=value)\n    elif isinstance(value, (list, tuple)):\n        return ast.List_(elements=[_convert_to_kork_expr(v) for v in value])\n    else:\n        raise ValueError(f\"Cannot convert {value} to an `kork` expression.\")", "\n\n# PUBLIC API\n\n\ndef to_extern_func_def(func: Callable) -> ast.ExternFunctionDef:\n    \"\"\"Convert a python function to a kork external function definition.\"\"\"\n    func_info = _get_function_info(func)\n    params = [\n        ast.Param(name=arg_name, type_=arg_type)\n        for arg_name, arg_type, _ in func_info[\"args\"]\n    ]\n    return ast.ExternFunctionDef(\n        name=func_info[\"name\"],\n        params=ast.ParamList(params=params),\n        return_type=func_info[\"return_type\"],\n        implementation=func,\n        doc_string=func_info[\"docstring\"],\n    )", "\n\ndef to_kork_function_call(func: Callable, *args: Any) -> ast.FunctionCall:\n    \"\"\"Convert a python function call to a kork function call.\"\"\"\n    return ast.FunctionCall(\n        name=func.__name__,\n        args=[_convert_to_kork_expr(arg) for arg in args],\n    )\n", ""]}
{"filename": "kork/retrieval.py", "chunked_list": ["\"\"\"Logic that attempts to surface the most relevant information for writing code.\"\"\"\nfrom __future__ import annotations\n\nimport abc\nimport dataclasses\nfrom typing import Callable, Sequence, Union\n\nfrom kork import ast\nfrom kork.foreign_funcs import to_extern_func_def\n", "from kork.foreign_funcs import to_extern_func_def\n\n\n@dataclasses.dataclass(frozen=True)\nclass AbstractContextRetriever(abc.ABC):\n    \"\"\"Abstract interface for retrieving programming context.\"\"\"\n\n    @abc.abstractmethod\n    def retrieve(self, query: str) -> Sequence[ast.ExternFunctionDef]:\n        \"\"\"Retrieve the external function definitions.\"\"\"", "\n\nFuncLike = Union[ast.ExternFunctionDef, Callable]\n\n\n@dataclasses.dataclass(frozen=True)\nclass SimpleContextRetriever(AbstractContextRetriever):\n    \"\"\"Retrieve information as was provided without any filtering or re-ranking.\"\"\"\n\n    external_functions: Sequence[ast.ExternFunctionDef] = tuple()\n\n    def __post_init__(self) -> None:\n        \"\"\"Validate the external functions.\"\"\"\n        for func in self.external_functions:\n            if not isinstance(func, ast.ExternFunctionDef):\n                raise ValueError(\n                    \"SimpleRetriever only accepts ExternFunctionDef objects in \"\n                    f\"the external_functions list. Got: {func}\"\n                )\n\n    def retrieve(self, query: str) -> Sequence[ast.ExternFunctionDef]:\n        \"\"\"Retrieve the external function definitions.\"\"\"\n        return self.external_functions\n\n    @classmethod\n    def from_functions(cls, mixed_funcs: Sequence[FuncLike]) -> SimpleContextRetriever:\n        \"\"\"Create a simple retrieval from a sequence of functions.\n\n        Args:\n            mixed_funcs: A sequence of functions or external function definitions.\n\n        Returns:\n            A simple retriever.\n        \"\"\"\n\n        external_functions = []\n\n        for func in mixed_funcs:\n            if isinstance(func, ast.ExternFunctionDef):\n                external_functions.append(func)\n            else:\n                external_functions.append(to_extern_func_def(func))\n\n        return cls(external_functions=external_functions)", ""]}
{"filename": "kork/exceptions.py", "chunked_list": ["\"\"\"Definitions for custom Kork exceptions.\"\"\"\n\n\nclass KorkException(Exception):\n    \"\"\"Generic Kork exception.\"\"\"\n\n\nclass LLMParseException(KorkException):\n    \"\"\"Failed to parse LLM output.\"\"\"\n", "\n\nclass KorkSyntaxException(KorkException):\n    \"\"\"Exceptions raised during syntax parsing.\"\"\"\n\n\nclass KorkInterpreterException(KorkException):\n    \"\"\"Exceptions raised during interpretation.\"\"\"\n\n\nclass KorkRunTimeException(KorkInterpreterException):\n    \"\"\"An exception that is raised during Kork interpreter runtime.\"\"\"", "\n\nclass KorkRunTimeException(KorkInterpreterException):\n    \"\"\"An exception that is raised during Kork interpreter runtime.\"\"\"\n"]}
{"filename": "docs/source/conf.py", "chunked_list": ["# Configuration file for the Sphinx documentation builder.\n#\n# This file only contains a selection of the most common options. For a full\n# list see the documentation:\n# https://www.sphinx-doc.org/en/master/usage/configuration.html\n\n# -- Path setup --------------------------------------------------------------\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the", "# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#\n# import os\n# import sys\n# sys.path.insert(0, os.path.abspath('.'))\n\n\n# -- Project information -----------------------------------------------------", "\n# -- Project information -----------------------------------------------------\nimport pathlib\nimport sys\nfrom typing import List\n\nimport toml\n\nROOT_FOLDER = str(pathlib.Path(__file__).parent.parent.parent)\n", "ROOT_FOLDER = str(pathlib.Path(__file__).parent.parent.parent)\n\n# Add the project root to the path\nsys.path.insert(0, ROOT_FOLDER)\n\nwith open(\"../../pyproject.toml\") as f:\n    data = toml.load(f)\n\nproject = \"Kork\"\ncopyright = \"2023, Langchain AI\"", "project = \"Kork\"\ncopyright = \"2023, Langchain AI\"\nauthor = \"Langchain AI\"\n\nversion = data[\"tool\"][\"poetry\"][\"version\"]\nrelease = version\n\nhtml_title = project + \" \" + version\n\n", "\n\n# -- General configuration ---------------------------------------------------\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom\n# ones.\nextensions = [\n    \"sphinx.ext.autodoc\",\n    \"sphinx.ext.autodoc.typehints\",", "    \"sphinx.ext.autodoc\",\n    \"sphinx.ext.autodoc.typehints\",\n    \"sphinx.ext.autosummary\",\n    \"sphinx.ext.napoleon\",\n    \"sphinx.ext.viewcode\",\n    \"myst_nb\",\n    \"sphinx_copybutton\",\n    \"IPython.sphinxext.ipython_console_highlighting\",\n]\nsource_suffix = [\".ipynb\", \".html\", \".md\", \".rst\"]", "]\nsource_suffix = [\".ipynb\", \".html\", \".md\", \".rst\"]\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\"_templates\"]\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This pattern also affects html_static_path and html_extra_path.\nexclude_patterns: List[str] = []", "# This pattern also affects html_static_path and html_extra_path.\nexclude_patterns: List[str] = []\n\n\n# -- Options for HTML output -------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = \"sphinx_book_theme\"", "#\nhtml_theme = \"sphinx_book_theme\"\n\nhtml_theme_options = {\n    \"path_to_docs\": \"docs\",\n    \"repository_url\": \"https://github.com/langchain-ai/kork\",\n    \"home_page_in_toc\": True,\n    \"show_navbar_depth\": 2,\n    \"use_sidenotes\": True,\n    \"use_repository_button\": True,", "    \"use_sidenotes\": True,\n    \"use_repository_button\": True,\n}\n\nhtml_context = {\n    \"display_github\": True,  # Integrate GitHub\n    \"github_user\": \"langchain-ai\",  # Username\n    \"github_repo\": \"kork\",  # Repo name\n    \"github_version\": \"main\",  # Version\n    \"conf_py_path\": \"/docs/\",  # Path in the checkout to the docs root", "    \"github_version\": \"main\",  # Version\n    \"conf_py_path\": \"/docs/\",  # Path in the checkout to the docs root\n}\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = [\"_static\"]\n\n# These paths are either relative to html_static_path", "\n# These paths are either relative to html_static_path\n# or fully qualified paths (eg. https://...)\nhtml_css_files = [\n    \"css/custom.css\",\n]\nhtml_logo = \"_static/parrot.png\"\n\nnb_execution_mode = \"off\"\nautosummary_generate = True", "nb_execution_mode = \"off\"\nautosummary_generate = True\n"]}
