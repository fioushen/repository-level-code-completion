{"filename": "setup.py", "chunked_list": ["\"\"\"The setup script.\"\"\"\nfrom setuptools import setup\n\nsetup()\n"]}
{"filename": "bumpversion/yaml_dump.py", "chunked_list": ["\"\"\"A simple YAML dumper to avoid extra dependencies.\"\"\"\nimport datetime\nfrom collections import UserDict\nfrom io import StringIO\nfrom textwrap import indent\nfrom typing import Any, Callable\n\nDumperFunc = Callable[[Any], str]\n\n\nclass YAMLDumpers(UserDict):\n    \"\"\"Registry of YAML dumpers.\"\"\"\n\n    def add_dumper(self, data_type: type, dumper: DumperFunc) -> None:\n        \"\"\"Add a YAML dumper.\"\"\"\n        self.data[data_type] = dumper", "\n\nclass YAMLDumpers(UserDict):\n    \"\"\"Registry of YAML dumpers.\"\"\"\n\n    def add_dumper(self, data_type: type, dumper: DumperFunc) -> None:\n        \"\"\"Add a YAML dumper.\"\"\"\n        self.data[data_type] = dumper\n\n", "\n\nYAML_DUMPERS = YAMLDumpers()\n\nINDENT = \"  \"\n\n\ndef dump(data: Any) -> str:\n    \"\"\"Dump a value to a string buffer.\"\"\"\n    data_types = type(data).__mro__\n    for data_type in data_types:\n        if data_type in YAML_DUMPERS:\n            return YAML_DUMPERS[data_types[0]](data)\n\n    return YAML_DUMPERS[str](str(data))", "\n\ndef format_str(val: str) -> str:\n    \"\"\"Return a YAML representation of a string.\"\"\"\n    val = val.replace(\"\\\\\", \"\\\\\\\\\").replace(\"\\n\", \"\\\\n\")\n    return f'\"{val}\"'\n\n\nYAML_DUMPERS.add_dumper(str, format_str)\n", "YAML_DUMPERS.add_dumper(str, format_str)\n\n\ndef format_int(val: int) -> str:\n    \"\"\"Return a YAML representation of an int.\"\"\"\n    return str(val)\n\n\nYAML_DUMPERS.add_dumper(int, format_int)\n", "YAML_DUMPERS.add_dumper(int, format_int)\n\n\ndef format_float(data: float) -> str:\n    \"\"\"Return a YAML representation of a float.\"\"\"\n    inf_value = 1e300\n\n    if data != data:\n        value = \".nan\"\n    elif data == inf_value:\n        value = \".inf\"\n    elif data == -inf_value:\n        value = \"-.inf\"\n    else:\n        value = repr(data).lower()\n        # Note that in some cases `repr(data)` represents a float number\n        # without the decimal parts.  For instance:\n        #   >>> repr(1e17)\n        #   '1e17'\n        # Unfortunately, this is not a valid float representation according\n        # to the definition of the `!!float` tag.  We fix this by adding\n        # '.0' before the 'e' symbol.\n        if \".\" not in value and \"e\" in value:\n            value = value.replace(\"e\", \".0e\", 1)\n    return str(value)", "\n\nYAML_DUMPERS.add_dumper(float, format_float)\n\n\ndef format_bool(val: bool) -> str:\n    \"\"\"Return a YAML representation of a bool.\"\"\"\n    return \"true\" if val else \"false\"\n\n", "\n\nYAML_DUMPERS.add_dumper(bool, format_bool)\n\n\ndef format_dict(val: dict) -> str:\n    \"\"\"Return a YAML representation of a dict.\"\"\"\n    buffer = StringIO()\n\n    for key, value in sorted(val.items()):\n        rendered_value = dump(value).strip()\n        if isinstance(value, (dict, list)):\n            rendered_value = f\"\\n{indent(rendered_value, INDENT)}\"\n        else:\n            rendered_value = f\" {rendered_value}\"\n        buffer.write(f\"{key}:{rendered_value}\\n\")\n\n    return buffer.getvalue()", "\n\nYAML_DUMPERS.add_dumper(dict, format_dict)\n\n\ndef format_list(val: list) -> str:\n    \"\"\"Return a string representation of a value.\"\"\"\n    buffer = StringIO()\n\n    for item in val:\n        rendered_value = dump(item).strip()\n        if isinstance(item, dict):\n            rendered_value = indent(rendered_value, INDENT).strip()\n\n        if isinstance(item, list):\n            rendered_value = f\"\\n{indent(rendered_value, INDENT)}\"\n        else:\n            rendered_value = f\" {rendered_value}\"\n        buffer.write(f\"-{rendered_value}\\n\")\n\n    return buffer.getvalue()", "\n\nYAML_DUMPERS.add_dumper(list, format_list)\n\n\ndef format_none(_: None) -> str:\n    \"\"\"Return a YAML representation of None.\"\"\"\n    return \"null\"\n\n", "\n\nYAML_DUMPERS.add_dumper(type(None), format_none)\n\n\ndef format_date(val: datetime.date) -> str:\n    \"\"\"Return a YAML representation of a date.\"\"\"\n    return val.isoformat()\n\n", "\n\nYAML_DUMPERS.add_dumper(datetime.date, format_date)\n\n\ndef format_datetime(val: datetime.datetime) -> str:\n    \"\"\"Return a string representation of a value.\"\"\"\n    return val.isoformat(\" \")\n\n", "\n\nYAML_DUMPERS.add_dumper(datetime.datetime, format_datetime)\n"]}
{"filename": "bumpversion/functions.py", "chunked_list": ["\"\"\"Generators for version parts.\"\"\"\nimport re\nfrom typing import List, Optional, Union\n\n\nclass PartFunction:\n    \"\"\"Base class for a version part function.\"\"\"\n\n    first_value: str\n    optional_value: str\n    independent: bool\n\n    def bump(self, value: str) -> str:\n        \"\"\"Increase the value.\"\"\"\n        raise NotImplementedError", "\n\nclass NumericFunction(PartFunction):\n    \"\"\"\n    This is a class that provides a numeric function for version parts.\n\n    It simply starts with the provided first_value (0 by default) and\n    increases it following the sequence of integer numbers.\n\n    The optional value of this function is equal to the first value.\n\n    This function also supports alphanumeric parts, altering just the numeric\n    part (e.g. 'r3' --> 'r4'). Only the first numeric group found in the part is\n    considered (e.g. 'r3-001' --> 'r4-001').\n    \"\"\"\n\n    FIRST_NUMERIC = re.compile(r\"(\\D*)(\\d+)(.*)\")\n\n    def __init__(self, optional_value: Optional[str] = None, first_value: Optional[str] = None):\n        if first_value is not None and not self.FIRST_NUMERIC.search(str(first_value)):\n            raise ValueError(f\"The given first value {first_value} does not contain any digit\")\n\n        self.first_value = str(first_value or 0)\n        self.optional_value = optional_value or self.first_value\n\n    def bump(self, value: Union[str, int]) -> str:\n        \"\"\"Increase the first numerical value by one.\"\"\"\n        match = self.FIRST_NUMERIC.search(str(value))\n        if not match:\n            raise ValueError(f\"The given value {value} does not contain any digit\")\n        part_prefix, part_numeric, part_suffix = match.groups()\n        bumped_numeric = int(part_numeric) + 1\n\n        return \"\".join([part_prefix, str(bumped_numeric), part_suffix])", "\n\nclass ValuesFunction(PartFunction):\n    \"\"\"\n    This is a class that provides a values list based function for version parts.\n\n    It is initialized with a list of values and iterates through them when\n    bumping the part.\n\n    The default optional value of this function is equal to the first value,\n    but may be otherwise specified.\n\n    When trying to bump a part which has already the maximum value in the list\n    you get a ValueError exception.\n    \"\"\"\n\n    def __init__(\n        self,\n        values: List[str],\n        optional_value: Optional[str] = None,\n        first_value: Optional[str] = None,\n    ):\n        if not values:\n            raise ValueError(\"Version part values cannot be empty\")\n\n        self._values = values\n\n        if optional_value is None:\n            optional_value = values[0]\n\n        if optional_value not in values:\n            raise ValueError(f\"Optional value {optional_value} must be included in values {values}\")\n\n        self.optional_value = optional_value\n\n        if not first_value:\n            first_value = values[0]\n\n        if first_value not in values:\n            raise ValueError(f\"First value {first_value} must be included in values {values}\")\n\n        self.first_value = first_value\n\n    def bump(self, value: str) -> str:\n        \"\"\"Return the item after ``value`` in the list.\"\"\"\n        try:\n            return self._values[self._values.index(value) + 1]\n        except IndexError as e:\n            raise ValueError(\n                f\"The part has already the maximum value among {self._values} and cannot be bumped.\"\n            ) from e", ""]}
{"filename": "bumpversion/__main__.py", "chunked_list": ["\"\"\"Main entrypoint for module.\"\"\"\nfrom bumpversion.cli import cli\n\ncli()\n"]}
{"filename": "bumpversion/scm.py", "chunked_list": ["\"\"\"Version control system management.\"\"\"\n\nimport logging\nimport os\nimport re\nimport subprocess\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom tempfile import NamedTemporaryFile\nfrom typing import TYPE_CHECKING, ClassVar, List, MutableMapping, Optional, Type, Union", "from tempfile import NamedTemporaryFile\nfrom typing import TYPE_CHECKING, ClassVar, List, MutableMapping, Optional, Type, Union\n\nif TYPE_CHECKING:  # pragma: no-coverage\n    from bumpversion.config import Config\n\nfrom bumpversion.exceptions import DirtyWorkingDirectoryError, SignedTagsError\n\nlogger = logging.getLogger(__name__)\n", "logger = logging.getLogger(__name__)\n\n\n@dataclass\nclass SCMInfo:\n    \"\"\"Information about the current source code manager and state.\"\"\"\n\n    tool: Optional[Type[\"SourceCodeManager\"]] = None\n    commit_sha: Optional[str] = None\n    distance_to_latest_tag: Optional[int] = None\n    current_version: Optional[str] = None\n    branch_name: Optional[str] = None\n    short_branch_name: Optional[str] = None\n    dirty: Optional[bool] = None\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __repr__(self):\n        tool_name = self.tool.__name__ if self.tool else \"No SCM tool\"\n        return (\n            f\"SCMInfo(tool={tool_name}, commit_sha={self.commit_sha}, \"\n            f\"distance_to_latest_tag={self.distance_to_latest_tag}, current_version={self.current_version}, \"\n            f\"dirty={self.dirty})\"\n        )", "\n\nclass SourceCodeManager:\n    \"\"\"Base class for version control systems.\"\"\"\n\n    _TEST_USABLE_COMMAND: ClassVar[List[str]] = []\n    _COMMIT_COMMAND: ClassVar[List[str]] = []\n    _ALL_TAGS_COMMAND: ClassVar[List[str]] = []\n\n    @classmethod\n    def commit(cls, message: str, current_version: str, new_version: str, extra_args: Optional[list] = None) -> None:\n        \"\"\"Commit the changes.\"\"\"\n        extra_args = extra_args or []\n\n        with NamedTemporaryFile(\"wb\", delete=False) as f:\n            f.write(message.encode(\"utf-8\"))\n\n        env = os.environ.copy()\n        env[\"HGENCODING\"] = \"utf-8\"\n        env[\"BUMPVERSION_CURRENT_VERSION\"] = current_version\n        env[\"BUMPVERSION_NEW_VERSION\"] = new_version\n\n        try:\n            cmd = [*cls._COMMIT_COMMAND, f.name, *extra_args]\n            subprocess.run(cmd, env=env, capture_output=True, check=True)  # noqa: S603\n        except subprocess.CalledProcessError as exc:  # pragma: no-coverage\n            err_msg = f\"Failed to run {exc.cmd}: return code {exc.returncode}, output: {exc.output}\"\n            logger.exception(err_msg)\n            raise exc\n        finally:\n            os.unlink(f.name)\n\n    @classmethod\n    def is_usable(cls) -> bool:\n        \"\"\"Is the VCS implementation usable.\"\"\"\n        try:\n            result = subprocess.run(cls._TEST_USABLE_COMMAND, check=True, capture_output=True)  # noqa: S603\n            return result.returncode == 0\n        except (FileNotFoundError, PermissionError, NotADirectoryError, subprocess.CalledProcessError):\n            return False\n\n    @classmethod\n    def assert_nondirty(cls) -> None:\n        \"\"\"Assert that the working directory is not dirty.\"\"\"\n        raise NotImplementedError()\n\n    @classmethod\n    def latest_tag_info(cls, tag_pattern: str) -> SCMInfo:\n        \"\"\"Return information about the latest tag.\"\"\"\n        raise NotImplementedError()\n\n    @classmethod\n    def add_path(cls, path: Union[str, Path]) -> None:\n        \"\"\"Add a path to the VCS.\"\"\"\n        raise NotImplementedError()\n\n    @classmethod\n    def tag(cls, name: str, sign: bool = False, message: Optional[str] = None) -> None:\n        \"\"\"Create a tag of the new_version in VCS.\"\"\"\n        raise NotImplementedError\n\n    @classmethod\n    def get_all_tags(cls) -> List[str]:\n        \"\"\"Return all tags in VCS.\"\"\"\n        try:\n            result = subprocess.run(cls._ALL_TAGS_COMMAND, text=True, check=True, capture_output=True)  # noqa: S603\n            return result.stdout.splitlines()\n        except (FileNotFoundError, PermissionError, NotADirectoryError, subprocess.CalledProcessError):\n            return []\n\n    @classmethod\n    def commit_to_scm(\n        cls,\n        files: List[Union[str, Path]],\n        config: \"Config\",\n        context: MutableMapping,\n        extra_args: Optional[List[str]] = None,\n        dry_run: bool = False,\n    ) -> None:\n        \"\"\"Commit the files to the source code management system.\"\"\"\n        if not cls.is_usable():\n            logger.error(\"SCM tool '%s' is unusable, unable to commit.\", cls.__name__)\n            return\n\n        if not config.commit:\n            logger.info(\"Would not commit\")\n            return\n\n        do_commit = not dry_run\n        logger.info(\n            \"%s %s commit\",\n            \"Preparing\" if do_commit else \"Would prepare\",\n            cls.__name__,\n        )\n        for path in files:\n            logger.info(\n                \"%s changes in file '%s' to %s\",\n                \"Adding\" if do_commit else \"Would add\",\n                path,\n                cls.__name__,\n            )\n\n            if do_commit:\n                cls.add_path(path)\n\n        commit_message = config.message.format(**context)\n\n        logger.info(\n            \"%s to %s with message '%s'\",\n            \"Committing\" if do_commit else \"Would commit\",\n            cls.__name__,\n            commit_message,\n        )\n        if do_commit:\n            cls.commit(\n                message=commit_message,\n                current_version=context[\"current_version\"],\n                new_version=context[\"new_version\"],\n                extra_args=extra_args,\n            )\n\n    @classmethod\n    def tag_in_scm(cls, config: \"Config\", context: MutableMapping, dry_run: bool = False) -> None:\n        \"\"\"Tag the current commit in the source code management system.\"\"\"\n        if not config.commit:\n            logger.info(\"Would not tag since we are not committing\")\n            return\n        if not config.tag:\n            logger.info(\"Would not tag\")\n            return\n        sign_tags = config.sign_tags\n        tag_name = config.tag_name.format(**context)\n        tag_message = config.tag_message.format(**context)\n        existing_tags = cls.get_all_tags()\n\n        do_tag = not dry_run\n\n        if tag_name in existing_tags:\n            logger.warning(\"Tag '%s' already exists. Will not tag.\", tag_name)\n            return\n\n        logger.info(\n            \"%s '%s' %s in %s and %s\",\n            \"Tagging\" if do_tag else \"Would tag\",\n            tag_name,\n            f\"with message '{tag_message}'\" if tag_message else \"without message\",\n            cls.__name__,\n            \"signing\" if sign_tags else \"not signing\",\n        )\n        if do_tag:\n            cls.tag(tag_name, sign_tags, tag_message)\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __repr__(self):\n        return f\"{self.__class__.__name__}\"", "\n\nclass Git(SourceCodeManager):\n    \"\"\"Git implementation.\"\"\"\n\n    _TEST_USABLE_COMMAND: ClassVar[List[str]] = [\"git\", \"rev-parse\", \"--git-dir\"]\n    _COMMIT_COMMAND: ClassVar[List[str]] = [\"git\", \"commit\", \"-F\"]\n    _ALL_TAGS_COMMAND: ClassVar[List[str]] = [\"git\", \"tag\", \"--list\"]\n\n    @classmethod\n    def assert_nondirty(cls) -> None:\n        \"\"\"Assert that the working directory is not dirty.\"\"\"\n        lines = [\n            line.strip()\n            for line in subprocess.check_output([\"git\", \"status\", \"--porcelain\"]).splitlines()  # noqa: S603, S607\n            if not line.strip().startswith(b\"??\")\n        ]\n\n        if lines:\n            joined_lines = b\"\\n\".join(lines).decode()\n            raise DirtyWorkingDirectoryError(f\"Git working directory is not clean:\\n\\n{joined_lines}\")\n\n    @classmethod\n    def latest_tag_info(cls, tag_pattern: str) -> SCMInfo:\n        \"\"\"Return information about the latest tag.\"\"\"\n        try:\n            # git-describe doesn't update the git-index, so we do that\n            subprocess.run([\"git\", \"update-index\", \"--refresh\", \"-q\"], capture_output=True)  # noqa: S603, S607\n        except subprocess.CalledProcessError as e:\n            logger.debug(\"Error when running git update-index: %s\", e.stderr)\n            return SCMInfo(tool=cls)\n\n        try:\n            # get info about the latest tag in git\n            # TODO: This only works if the tag name is prefixed with `v`.\n            #   Should allow for the configured format for the tag name.\n            git_cmd = [\n                \"git\",\n                \"describe\",\n                \"--dirty\",\n                \"--tags\",\n                \"--long\",\n                \"--abbrev=40\",\n                f\"--match={tag_pattern}\",\n            ]\n            result = subprocess.run(git_cmd, text=True, check=True, capture_output=True)  # noqa: S603\n            describe_out = result.stdout.strip().split(\"-\")\n\n            git_cmd = [\"git\", \"rev-parse\", \"--abbrev-ref\", \"HEAD\"]\n            result = subprocess.run(git_cmd, text=True, check=True, capture_output=True)  # noqa: S603\n            branch_name = result.stdout.strip()\n            short_branch_name = re.sub(r\"([^a-zA-Z0-9]*)\", \"\", branch_name).lower()[:20]\n        except subprocess.CalledProcessError as e:\n            logger.debug(\"Error when running git describe: %s\", e.stderr)\n            return SCMInfo(tool=cls)\n\n        info = SCMInfo(tool=cls, branch_name=branch_name, short_branch_name=short_branch_name)\n\n        if describe_out[-1].strip() == \"dirty\":\n            info.dirty = True\n            describe_out.pop()\n        else:\n            info.dirty = False\n\n        info.commit_sha = describe_out.pop().lstrip(\"g\")\n        info.distance_to_latest_tag = int(describe_out.pop())\n        info.current_version = \"-\".join(describe_out).lstrip(\"v\")\n\n        return info\n\n    @classmethod\n    def add_path(cls, path: Union[str, Path]) -> None:\n        \"\"\"Add a path to the VCS.\"\"\"\n        subprocess.check_output([\"git\", \"add\", \"--update\", str(path)])  # noqa: S603, S607\n\n    @classmethod\n    def tag(cls, name: str, sign: bool = False, message: Optional[str] = None) -> None:\n        \"\"\"\n        Create a tag of the new_version in VCS.\n\n        If only name is given, bumpversion uses a lightweight tag.\n        Otherwise, it utilizes an annotated tag.\n\n        Args:\n            name: The name of the tag\n            sign: True to sign the tag\n            message: An optional message to annotate the tag.\n        \"\"\"\n        command = [\"git\", \"tag\", name]\n        if sign:\n            command += [\"--sign\"]\n        if message:\n            command += [\"--message\", message]\n        subprocess.check_output(command)  # noqa: S603", "\n\nclass Mercurial(SourceCodeManager):\n    \"\"\"Mercurial implementation.\"\"\"\n\n    _TEST_USABLE_COMMAND: ClassVar[List[str]] = [\"hg\", \"root\"]\n    _COMMIT_COMMAND: ClassVar[List[str]] = [\"hg\", \"commit\", \"--logfile\"]\n    _ALL_TAGS_COMMAND: ClassVar[List[str]] = [\"hg\", \"log\", '--rev=\"tag()\"', '--template=\"{tags}\\n\"']\n\n    @classmethod\n    def latest_tag_info(cls, tag_pattern: str) -> SCMInfo:\n        \"\"\"Return information about the latest tag.\"\"\"\n        current_version = None\n        re_pattern = tag_pattern.replace(\"*\", \".*\")\n        result = subprocess.run(\n            [\"hg\", \"log\", \"-r\", f\"tag('re:{re_pattern}')\", \"--template\", \"{latesttag}\\n\"],  # noqa: S603, S607\n            text=True,\n            check=True,\n            capture_output=True,\n        )\n        result.check_returncode()\n        if result.stdout:\n            current_version = result.stdout.splitlines(keepends=False)[0].lstrip(\"v\")\n        is_dirty = len(subprocess.check_output([\"hg\", \"status\", \"-mard\"])) != 0  # noqa: S603, S607\n        return SCMInfo(tool=cls, current_version=current_version, dirty=is_dirty)\n\n    @classmethod\n    def assert_nondirty(cls) -> None:\n        \"\"\"Assert that the working directory is clean.\"\"\"\n        lines = [\n            line.strip()\n            for line in subprocess.check_output([\"hg\", \"status\", \"-mard\"]).splitlines()  # noqa: S603, S607\n            if not line.strip().startswith(b\"??\")\n        ]\n\n        if lines:\n            joined_lines = b\"\\n\".join(lines).decode()\n            raise DirtyWorkingDirectoryError(f\"Mercurial working directory is not clean:\\n{joined_lines}\")\n\n    @classmethod\n    def add_path(cls, path: Union[str, Path]) -> None:\n        \"\"\"Add a path to the VCS.\"\"\"\n        pass\n\n    @classmethod\n    def tag(cls, name: str, sign: bool = False, message: Optional[str] = None) -> None:\n        \"\"\"\n        Create a tag of the new_version in VCS.\n\n        If only name is given, bumpversion uses a lightweight tag.\n        Otherwise, it utilizes an annotated tag.\n\n        Args:\n            name: The name of the tag\n            sign: True to sign the tag\n            message: A optional message to annotate the tag.\n\n        Raises:\n            SignedTagsError: If ``sign`` is ``True``\n        \"\"\"\n        command = [\"hg\", \"tag\", name]\n        if sign:\n            raise SignedTagsError(\"Mercurial does not support signed tags.\")\n        if message:\n            command += [\"--message\", message]\n        subprocess.check_output(command)  # noqa: S603", "\n\ndef get_scm_info(tag_pattern: str) -> SCMInfo:\n    \"\"\"Return a dict with the latest source code management info.\"\"\"\n    if Git.is_usable():\n        return Git.latest_tag_info(tag_pattern)\n    elif Mercurial.is_usable():\n        return Mercurial.latest_tag_info(tag_pattern)\n    else:\n        return SCMInfo()", ""]}
{"filename": "bumpversion/config.py", "chunked_list": ["\"\"\"Configuration management.\"\"\"\nfrom __future__ import annotations\n\nimport itertools\nimport logging\nimport re\nfrom difflib import context_diff\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING, Any, Dict, List, Optional, Union\n", "from typing import TYPE_CHECKING, Any, Dict, List, Optional, Union\n\nfrom bumpversion.utils import labels_for_format\n\nif TYPE_CHECKING:  # pragma: no-coverage\n    from bumpversion.scm import SCMInfo\n    from bumpversion.version_part import VersionConfig\n\nfrom pydantic import BaseModel, BaseSettings, Field\n", "from pydantic import BaseModel, BaseSettings, Field\n\nfrom bumpversion.exceptions import ConfigurationError\n\nlogger = logging.getLogger(__name__)\n\n\nclass VersionPartConfig(BaseModel):\n    \"\"\"Configuration of a part of the version.\"\"\"\n\n    values: Optional[list]  # Optional. Numeric is used if missing or no items in list\n    optional_value: Optional[str]  # Optional.\n    # Defaults to first value. 0 in the case of numeric. Empty string means nothing is optional.\n    first_value: Optional[str]  # Optional. Defaults to first value in values\n    independent: bool = False", "\n\nclass FileConfig(BaseModel):\n    \"\"\"Search and replace file config.\"\"\"\n\n    filename: Optional[str]\n    glob: Optional[str]  # Conflicts with filename. If both are specified, glob wins\n    parse: Optional[str]  # If different from outer scope\n    serialize: Optional[List[str]]  # If different from outer scope\n    search: Optional[str]  # If different from outer scope\n    replace: Optional[str]  # If different from outer scope\n    ignore_missing_version: Optional[bool]", "\n\nclass Config(BaseSettings):\n    \"\"\"Bump Version configuration.\"\"\"\n\n    current_version: Optional[str]\n    parse: str\n    serialize: List[str] = Field(min_items=1)\n    search: str\n    replace: str\n    ignore_missing_version: bool\n    tag: bool\n    sign_tags: bool\n    tag_name: str\n    tag_message: Optional[str]\n    allow_dirty: bool\n    commit: bool\n    message: str\n    commit_args: Optional[str]\n    scm_info: Optional[\"SCMInfo\"]\n    parts: Dict[str, VersionPartConfig]\n    files: List[FileConfig]\n\n    class Config:\n        env_prefix = \"bumpversion_\"\n\n    def add_files(self, filename: Union[str, List[str]]) -> None:\n        \"\"\"Add a filename to the list of files.\"\"\"\n        filenames = [filename] if isinstance(filename, str) else filename\n        self.files.extend([FileConfig(filename=name) for name in filenames])  # type: ignore[call-arg]\n\n    @property\n    def version_config(self) -> \"VersionConfig\":\n        \"\"\"Return the version configuration.\"\"\"\n        from bumpversion.version_part import VersionConfig\n\n        return VersionConfig(self.parse, self.serialize, self.search, self.replace, self.parts)", "\n\nDEFAULTS = {\n    \"current_version\": None,\n    \"parse\": r\"(?P<major>\\d+)\\.(?P<minor>\\d+)\\.(?P<patch>\\d+)\",\n    \"serialize\": [\"{major}.{minor}.{patch}\"],\n    \"search\": \"{current_version}\",\n    \"replace\": \"{new_version}\",\n    \"ignore_missing_version\": False,\n    \"tag\": False,", "    \"ignore_missing_version\": False,\n    \"tag\": False,\n    \"sign_tags\": False,\n    \"tag_name\": \"v{new_version}\",\n    \"tag_message\": \"Bump version: {current_version} \u2192 {new_version}\",\n    \"allow_dirty\": False,\n    \"commit\": False,\n    \"message\": \"Bump version: {current_version} \u2192 {new_version}\",\n    \"commit_args\": None,\n    \"scm_info\": None,", "    \"commit_args\": None,\n    \"scm_info\": None,\n    \"parts\": {},\n    \"files\": [],\n}\n\nCONFIG_FILE_SEARCH_ORDER = (\n    Path(\".bumpversion.cfg\"),\n    Path(\".bumpversion.toml\"),\n    Path(\"setup.cfg\"),", "    Path(\".bumpversion.toml\"),\n    Path(\"setup.cfg\"),\n    Path(\"pyproject.toml\"),\n)\n\n\ndef get_all_file_configs(config_dict: dict) -> List[FileConfig]:\n    \"\"\"Make sure all version parts are included.\"\"\"\n    defaults = {\n        \"parse\": config_dict[\"parse\"],\n        \"serialize\": config_dict[\"serialize\"],\n        \"search\": config_dict[\"search\"],\n        \"replace\": config_dict[\"replace\"],\n        \"ignore_missing_version\": config_dict[\"ignore_missing_version\"],\n    }\n    files = [{k: v for k, v in filecfg.items() if v} for filecfg in config_dict[\"files\"]]\n    for f in files:\n        f.update({k: v for k, v in defaults.items() if k not in f})\n    return [FileConfig(**f) for f in files]", "\n\ndef get_configuration(config_file: Union[str, Path, None] = None, **overrides) -> Config:\n    \"\"\"\n    Return the configuration based on any configuration files and overrides.\n\n    Args:\n        config_file: An explicit configuration file to use, otherwise search for one\n        **overrides: Specific configuration key-values to override in the configuration\n\n    Returns:\n        The configuration\n    \"\"\"\n    from bumpversion.scm import SCMInfo, get_scm_info\n\n    config_dict = DEFAULTS.copy()\n    parsed_config = read_config_file(config_file) if config_file else {}\n\n    # We want to strip out unrecognized key-values to avoid inadvertent issues\n    config_dict.update({key: val for key, val in parsed_config.items() if key in DEFAULTS.keys()})\n\n    allowed_overrides = set(DEFAULTS.keys())\n    config_dict.update({key: val for key, val in overrides.items() if key in allowed_overrides})\n\n    # Set any missing version parts\n    config_dict[\"parts\"] = get_all_part_configs(config_dict)\n\n    # Set any missing file configuration\n    config_dict[\"files\"] = get_all_file_configs(config_dict)\n\n    # Resolve the SCMInfo class for Pydantic's BaseSettings\n    Config.update_forward_refs(SCMInfo=SCMInfo)\n    config = Config(**config_dict)  # type: ignore[arg-type]\n\n    # Get the information about the SCM\n    tag_pattern = config.tag_name.replace(\"{new_version}\", \"*\")\n    scm_info = get_scm_info(tag_pattern)\n    config.scm_info = scm_info\n\n    # Update and verify the current_version\n    config.current_version = check_current_version(config)\n\n    return config", "\n\ndef get_all_part_configs(config_dict: dict) -> Dict[str, VersionPartConfig]:\n    \"\"\"Make sure all version parts are included.\"\"\"\n    serialize = config_dict[\"serialize\"]\n    parts = config_dict[\"parts\"]\n    all_labels = set(itertools.chain.from_iterable([labels_for_format(fmt) for fmt in serialize]))\n    return {\n        label: VersionPartConfig(**parts[label]) if label in parts else VersionPartConfig()  # type: ignore[call-arg]\n        for label in all_labels\n    }", "\n\ndef check_current_version(config: Config) -> str:\n    \"\"\"\n    Returns the current version.\n\n    If the current version is not specified in the config file, command line or env variable,\n    it attempts to retrieve it via a tag.\n\n    Args:\n        config: The current configuration dictionary.\n\n    Returns:\n        The version number\n\n    Raises:\n        ConfigurationError: If it can't find the current version\n    \"\"\"\n    current_version = config.current_version\n    scm_info = config.scm_info\n\n    if current_version is None and scm_info.current_version:\n        return scm_info.current_version\n    elif current_version and scm_info.current_version and current_version != scm_info.current_version:\n        logger.warning(\n            \"Specified version (%s) does not match last tagged version (%s)\",\n            current_version,\n            scm_info.current_version,\n        )\n        return current_version\n    elif current_version:\n        return current_version\n\n    raise ConfigurationError(\"Unable to determine the current version.\")", "\n\ndef find_config_file(explicit_file: Union[str, Path, None] = None) -> Union[Path, None]:\n    \"\"\"\n    Find the configuration file, if it exists.\n\n    If no explicit configuration file is passed, it will search in several files to\n    find its configuration.\n\n    Args:\n        explicit_file: The configuration file to explicitly use.\n\n    Returns:\n        The configuration file path\n    \"\"\"\n    search_paths = [Path(explicit_file)] if explicit_file else CONFIG_FILE_SEARCH_ORDER\n    return next(\n        (cfg_file for cfg_file in search_paths if cfg_file.exists() and \"bumpversion]\" in cfg_file.read_text()),\n        None,\n    )", "\n\ndef read_config_file(config_file: Union[str, Path, None] = None) -> Dict[str, Any]:\n    \"\"\"\n    Read the configuration file, if it exists.\n\n    If no explicit configuration file is passed, it will search in several files to\n    find its configuration.\n\n    Args:\n        config_file: The configuration file to explicitly use.\n\n    Returns:\n        A dictionary of read key-values\n    \"\"\"\n    if not config_file:\n        logger.info(\"No configuration file found.\")\n        return {}\n\n    logger.info(\"Reading config file %s:\", config_file)\n    config_path = Path(config_file)\n    if config_path.suffix == \".cfg\":\n        return read_ini_file(config_path)\n    elif config_path.suffix == \".toml\":\n        return read_toml_file(config_path)\n    return {}", "\n\ndef read_ini_file(file_path: Path) -> Dict[str, Any]:  # noqa: C901\n    \"\"\"\n    Parse an INI file and return a dictionary of sections and their options.\n\n    Args:\n        file_path: The path to the INI file.\n\n    Returns:\n        dict: A dictionary of sections and their options.\n    \"\"\"\n    import configparser\n\n    from bumpversion import autocast\n\n    # Create a ConfigParser object and read the INI file\n    config_parser = configparser.RawConfigParser()\n    if file_path.name == \"setup.cfg\":\n        config_parser = configparser.ConfigParser()\n\n    config_parser.read(file_path)\n\n    # Create an empty dictionary to hold the parsed sections and options\n    bumpversion_options: Dict[str, Any] = {\"files\": [], \"parts\": {}}\n\n    # Loop through each section in the INI file\n    for section_name in config_parser.sections():\n        if not section_name.startswith(\"bumpversion\"):\n            continue\n\n        section_parts = section_name.split(\":\")\n        num_parts = len(section_parts)\n        options = {key: autocast.autocast_value(val) for key, val in config_parser.items(section_name)}\n\n        if num_parts == 1:  # bumpversion section\n            bumpversion_options.update(options)\n            serialize = bumpversion_options.get(\"serialize\", [])\n            if \"message\" in bumpversion_options and isinstance(bumpversion_options[\"message\"], list):\n                bumpversion_options[\"message\"] = \",\".join(bumpversion_options[\"message\"])\n            if not isinstance(serialize, list):\n                bumpversion_options[\"serialize\"] = [serialize]\n        elif num_parts > 1 and section_parts[1].startswith(\"file\"):\n            file_options = {\n                \"filename\": section_parts[2],\n            }\n            file_options.update(options)\n            if \"replace\" in file_options and isinstance(file_options[\"replace\"], list):\n                file_options[\"replace\"] = \"\\n\".join(file_options[\"replace\"])\n            bumpversion_options[\"files\"].append(file_options)\n        elif num_parts > 1 and section_parts[1].startswith(\"glob\"):\n            file_options = {\n                \"glob\": section_parts[2],\n            }\n            file_options.update(options)\n            if \"replace\" in file_options and isinstance(file_options[\"replace\"], list):\n                file_options[\"replace\"] = \"\\n\".join(file_options[\"replace\"])\n            bumpversion_options[\"files\"].append(file_options)\n        elif num_parts > 1 and section_parts[1].startswith(\"part\"):\n            bumpversion_options[\"parts\"][section_parts[2]] = options\n\n    # Return the dictionary of sections and options\n    return bumpversion_options", "\n\ndef read_toml_file(file_path: Path) -> Dict[str, Any]:\n    \"\"\"\n    Parse a TOML file and return the `bumpversion` section.\n\n    Args:\n        file_path: The path to the TOML file.\n\n    Returns:\n        dict: A dictionary of the `bumpversion` section.\n    \"\"\"\n    import tomlkit\n\n    # Load the TOML file\n    toml_data = tomlkit.parse(file_path.read_text()).unwrap()\n\n    return toml_data.get(\"tool\", {}).get(\"bumpversion\", {})", "\n\ndef update_config_file(\n    config_file: Union[str, Path, None], current_version: str, new_version: str, dry_run: bool = False\n) -> None:\n    \"\"\"\n    Update the current_version key in the configuration file.\n\n    If no explicit configuration file is passed, it will search in several files to\n    find its configuration.\n\n    Instead of parsing and re-writing the config file with new information, it will use\n    a regular expression to just replace the current_version value. The idea is it will\n    avoid unintentional changes (like formatting) to the config file.\n\n    Args:\n        config_file: The configuration file to explicitly use.\n        current_version: The serialized current version.\n        new_version: The serialized new version.\n        dry_run: True if the update should be a dry run.\n    \"\"\"\n    toml_current_version_regex = re.compile(\n        f'(?P<section_prefix>\\\\[tool\\\\.bumpversion]\\n[^[]*current_version\\\\s*=\\\\s*)(\\\\\"{current_version}\\\\\")',\n        re.MULTILINE,\n    )\n    cfg_current_version_regex = re.compile(\n        f\"(?P<section_prefix>\\\\[bumpversion]\\n[^[]*current_version\\\\s*=\\\\s*)(?P<version>{current_version})\",\n        re.MULTILINE,\n    )\n\n    if not config_file:\n        logger.info(\"No configuration file found to update.\")\n        return\n\n    config_path = Path(config_file)\n    existing_config = config_path.read_text()\n    if config_path.suffix == \".cfg\" and cfg_current_version_regex.search(existing_config):\n        sub_str = f\"\\\\g<section_prefix>{new_version}\"\n        new_config = cfg_current_version_regex.sub(sub_str, existing_config)\n    elif config_path.suffix == \".toml\" and toml_current_version_regex.search(existing_config):\n        sub_str = f'\\\\g<section_prefix>\"{new_version}\"'\n        new_config = toml_current_version_regex.sub(sub_str, existing_config)\n    else:\n        logger.info(\"Could not find the current version in the config file: %s.\", config_path)\n        return\n\n    logger.info(\n        \"%s to config file %s:\",\n        \"Would write\" if dry_run else \"Writing\",\n        config_path,\n    )\n\n    logger.info(\n        \"\\n\".join(\n            list(\n                context_diff(\n                    existing_config.splitlines(),\n                    new_config.splitlines(),\n                    fromfile=f\"before {config_path}\",\n                    tofile=f\"after {config_path}\",\n                    lineterm=\"\",\n                )\n            )\n        )\n    )\n\n    if not dry_run:\n        config_path.write_text(new_config)", ""]}
{"filename": "bumpversion/files.py", "chunked_list": ["\"\"\"Methods for changing files.\"\"\"\nimport glob\nimport logging\nfrom difflib import context_diff\nfrom typing import List, MutableMapping, Optional\n\nfrom bumpversion.config import FileConfig\nfrom bumpversion.exceptions import VersionNotFoundError\nfrom bumpversion.version_part import Version, VersionConfig\n", "from bumpversion.version_part import Version, VersionConfig\n\nlogger = logging.getLogger(__name__)\n\n\nclass ConfiguredFile:\n    \"\"\"A file to modify in a configured way.\"\"\"\n\n    def __init__(\n        self,\n        file_cfg: FileConfig,\n        version_config: VersionConfig,\n        search: Optional[str] = None,\n        replace: Optional[str] = None,\n    ) -> None:\n        self.path = file_cfg.filename\n        self.parse = file_cfg.parse or version_config.parse_regex.pattern\n        self.serialize = file_cfg.serialize or version_config.serialize_formats\n        self.search = search or file_cfg.search or version_config.search\n        self.replace = replace or file_cfg.replace or version_config.replace\n        self.ignore_missing_version = file_cfg.ignore_missing_version or False\n        self.version_config = VersionConfig(\n            self.parse, self.serialize, self.search, self.replace, version_config.part_configs\n        )\n\n    def contains_version(self, version: Version, context: MutableMapping) -> bool:\n        \"\"\"\n        Check whether the version is present in the file.\n\n        Args:\n            version: The version to check\n            context: The context to use\n\n        Raises:\n            VersionNotFoundError: if the version number isn't present in this file.\n\n        Returns:\n            True if the version number is in fact present.\n        \"\"\"\n        search_expression = self.search.format(**context)\n\n        if self.contains(search_expression):\n            return True\n\n        # the `search` pattern did not match, but the original supplied\n        # version number (representing the same version part values) might\n        # match instead.\n\n        # check whether `search` isn't customized, i.e. should match only\n        # very specific parts of the file\n        search_pattern_is_default = self.search == self.version_config.search\n\n        if search_pattern_is_default and self.contains(version.original):\n            # original version is present, and we're not looking for something\n            # more specific -> this is accepted as a match\n            return True\n\n        # version not found\n        if self.ignore_missing_version:\n            return False\n        raise VersionNotFoundError(f\"Did not find '{search_expression}' in file: '{self.path}'\")\n\n    def contains(self, search: str) -> bool:\n        \"\"\"Does the work of the contains_version method.\"\"\"\n        if not search:\n            return False\n\n        with open(self.path, \"rt\", encoding=\"utf-8\") as f:\n            search_lines = search.splitlines()\n            lookbehind = []\n\n            for lineno, line in enumerate(f.readlines()):\n                lookbehind.append(line.rstrip(\"\\n\"))\n\n                if len(lookbehind) > len(search_lines):\n                    lookbehind = lookbehind[1:]\n\n                if (\n                    search_lines[0] in lookbehind[0]\n                    and search_lines[-1] in lookbehind[-1]\n                    and search_lines[1:-1] == lookbehind[1:-1]\n                ):\n                    logger.info(\n                        \"Found '%s' in %s at line %s: %s\",\n                        search,\n                        self.path,\n                        lineno - (len(lookbehind) - 1),\n                        line.rstrip(),\n                    )\n                    return True\n        return False\n\n    def replace_version(\n        self, current_version: Version, new_version: Version, context: MutableMapping, dry_run: bool = False\n    ) -> None:\n        \"\"\"Replace the current version with the new version.\"\"\"\n        with open(self.path, \"rt\", encoding=\"utf-8\") as f:\n            file_content_before = f.read()\n            file_new_lines = f.newlines[0] if isinstance(f.newlines, tuple) else f.newlines\n\n        context[\"current_version\"] = self.version_config.serialize(current_version, context)\n        if new_version:\n            context[\"new_version\"] = self.version_config.serialize(new_version, context)\n\n        search_for = self.version_config.search.format(**context)\n        replace_with = self.version_config.replace.format(**context)\n\n        file_content_after = file_content_before.replace(search_for, replace_with)\n\n        if file_content_before == file_content_after and current_version.original:\n            search_for_original_formatted = self.version_config.search.format(current_version=current_version.original)\n            file_content_after = file_content_before.replace(search_for_original_formatted, replace_with)\n\n        if file_content_before != file_content_after:\n            logger.info(\"%s file %s:\", \"Would change\" if dry_run else \"Changing\", self.path)\n            logger.info(\n                \"\\n\".join(\n                    list(\n                        context_diff(\n                            file_content_before.splitlines(),\n                            file_content_after.splitlines(),\n                            fromfile=f\"before {self.path}\",\n                            tofile=f\"after {self.path}\",\n                            lineterm=\"\",\n                        )\n                    )\n                )\n            )\n        else:\n            logger.info(\"%s file %s\", \"Would not change\" if dry_run else \"Not changing\", self.path)\n\n        if not dry_run:  # pragma: no-coverage\n            with open(self.path, \"wt\", encoding=\"utf-8\", newline=file_new_lines) as f:\n                f.write(file_content_after)\n\n    def __str__(self) -> str:  # pragma: no-coverage\n        return self.path\n\n    def __repr__(self) -> str:  # pragma: no-coverage\n        return f\"<bumpversion.ConfiguredFile:{self.path}>\"", "\n\ndef resolve_file_config(\n    files: List[FileConfig], version_config: VersionConfig, search: Optional[str] = None, replace: Optional[str] = None\n) -> List[ConfiguredFile]:\n    \"\"\"\n    Resolve the files, searching and replacing values according to the FileConfig.\n\n    Args:\n        files: A list of file configurations\n        version_config: How the version should be changed\n        search: The search pattern to use instead of any configured search pattern\n        replace: The replace pattern to use instead of any configured replace pattern\n\n    Returns:\n        A list of ConfiguredFiles\n    \"\"\"\n    configured_files = []\n    for file_cfg in files:\n        if file_cfg.glob:\n            configured_files.extend(get_glob_files(file_cfg, version_config))\n        else:\n            configured_files.append(ConfiguredFile(file_cfg, version_config, search, replace))\n\n    return configured_files", "\n\ndef modify_files(\n    files: List[ConfiguredFile],\n    current_version: Version,\n    new_version: Version,\n    context: MutableMapping,\n    dry_run: bool = False,\n) -> None:\n    \"\"\"\n    Modify the files, searching and replacing values according to the FileConfig.\n\n    Args:\n        files: The list of configured files\n        current_version: The current version\n        new_version: The next version\n        context: The context used for rendering the version\n        dry_run: True if this should be a report-only job\n    \"\"\"\n    _check_files_contain_version(files, current_version, context)\n    for f in files:\n        f.replace_version(current_version, new_version, context, dry_run)", "\n\ndef get_glob_files(\n    file_cfg: FileConfig, version_config: VersionConfig, search: Optional[str] = None, replace: Optional[str] = None\n) -> List[ConfiguredFile]:\n    \"\"\"\n    Return a list of files that match the glob pattern.\n\n    Args:\n        file_cfg: The file configuration containing the glob pattern\n        version_config: The version configuration\n        search: The search pattern to use instead of any configured search pattern\n        replace: The replace pattern to use instead of any configured replace pattern\n\n    Returns:\n        A list of resolved files according to the pattern.\n    \"\"\"\n    files = []\n    for filename_glob in glob.glob(file_cfg.glob, recursive=True):\n        new_file_cfg = file_cfg.copy()\n        new_file_cfg.filename = filename_glob\n        files.append(ConfiguredFile(new_file_cfg, version_config, search, replace))\n    return files", "\n\ndef _check_files_contain_version(\n    files: List[ConfiguredFile], current_version: Version, context: MutableMapping\n) -> None:\n    \"\"\"Make sure files exist and contain version string.\"\"\"\n    logger.info(\n        \"Asserting files %s contain the version string...\",\n        \", \".join({str(f.path) for f in files}),\n    )\n    for f in files:\n        context[\"current_version\"] = f.version_config.serialize(current_version, context)\n        f.contains_version(current_version, context)", ""]}
{"filename": "bumpversion/ui.py", "chunked_list": ["\"\"\"Utilities for user interface.\"\"\"\nfrom click import UsageError, secho\n\n\ndef print_info(msg: str) -> None:\n    \"\"\"Echo a message to the console.\"\"\"\n    secho(msg)\n\n\ndef print_error(msg: str) -> None:\n    \"\"\"Raise an error and exit.\"\"\"\n    raise UsageError(msg)", "\ndef print_error(msg: str) -> None:\n    \"\"\"Raise an error and exit.\"\"\"\n    raise UsageError(msg)\n\n\ndef print_warning(msg: str) -> None:\n    \"\"\"Echo a warning to the console.\"\"\"\n    secho(f\"\\nWARNING:\\n\\n{msg}\\n\", fg=\"yellow\")\n", ""]}
{"filename": "bumpversion/show.py", "chunked_list": ["\"\"\"Functions for displaying information about the version.\"\"\"\nimport dataclasses\nfrom io import StringIO\nfrom pprint import pprint\nfrom typing import Any, Optional\n\nfrom bumpversion.bump import get_next_version\nfrom bumpversion.config import Config\nfrom bumpversion.exceptions import BadInputError\nfrom bumpversion.ui import print_error, print_info", "from bumpversion.exceptions import BadInputError\nfrom bumpversion.ui import print_error, print_info\nfrom bumpversion.utils import get_context\n\n\ndef output_default(value: dict) -> None:\n    \"\"\"Output the value with key=value or just value if there is only one item.\"\"\"\n    if len(value) == 1:\n        print_info(list(value.values())[0])\n    else:\n        buffer = StringIO()\n        pprint(value, stream=buffer)  # noqa: T203\n        print_info(buffer.getvalue())", "\n\ndef output_yaml(value: dict) -> None:\n    \"\"\"Output the value as yaml.\"\"\"\n    from bumpversion.yaml_dump import dump\n\n    print_info(dump(value))\n\n\ndef output_json(value: dict) -> None:\n    \"\"\"Output the value as json.\"\"\"\n    import json\n\n    def default_encoder(obj: Any) -> str:\n        if dataclasses.is_dataclass(obj):\n            return str(obj)\n        elif isinstance(obj, type):\n            return obj.__name__\n        raise TypeError(f\"Object of type {type(obj), str(obj)} is not JSON serializable\")\n\n    print_info(json.dumps(value, sort_keys=True, indent=2, default=default_encoder))", "\ndef output_json(value: dict) -> None:\n    \"\"\"Output the value as json.\"\"\"\n    import json\n\n    def default_encoder(obj: Any) -> str:\n        if dataclasses.is_dataclass(obj):\n            return str(obj)\n        elif isinstance(obj, type):\n            return obj.__name__\n        raise TypeError(f\"Object of type {type(obj), str(obj)} is not JSON serializable\")\n\n    print_info(json.dumps(value, sort_keys=True, indent=2, default=default_encoder))", "\n\nOUTPUTTERS = {\n    \"yaml\": output_yaml,\n    \"json\": output_json,\n    \"default\": output_default,\n}\n\n\ndef resolve_name(obj: Any, name: str, default: Any = None, err_on_missing: bool = False) -> Any:\n    \"\"\"\n    Get a key or attr ``name`` from obj or default value.\n\n    Copied and modified from Django Template variable resolutions\n\n    Resolution methods:\n\n    - Mapping key lookup\n    - Attribute lookup\n    - Sequence index\n\n    Args:\n        obj: The object to access\n        name: A dotted name to the value, such as ``mykey.0.name``\n        default: If the name cannot be resolved from the object, return this value\n        err_on_missing: Raise a `BadInputError` if the name cannot be resolved\n\n    Returns:\n        The value at the resolved name or the default value.\n\n    Raises:\n        BadInputError: If we cannot resolve the name and `err_on_missing` is `True`\n\n    # noqa: DAR401\n    \"\"\"\n    lookups = name.split(\".\")\n    current = obj\n    try:  # catch-all for unexpected failures\n        for bit in lookups:\n            try:  # dictionary lookup\n                current = current[bit]\n                # ValueError/IndexError are for numpy.array lookup on\n                # numpy < 1.9 and 1.9+ respectively\n            except (TypeError, AttributeError, KeyError, ValueError, IndexError):\n                try:  # attribute lookup\n                    current = getattr(current, bit)\n                except (TypeError, AttributeError):\n                    # Reraise if the exception was raised by a @property\n                    if bit in dir(current):\n                        raise\n                    try:  # list-index lookup\n                        current = current[int(bit)]\n                    except (\n                        IndexError,  # list index out of range\n                        ValueError,  # invalid literal for int()\n                        KeyError,  # current is a dict without `int(bit)` key\n                        TypeError,\n                    ):  # un-subscript-able object\n                        return default\n        return current\n    except Exception as e:  # noqa: BLE001 # pragma: no cover\n        if err_on_missing:\n            raise BadInputError(f\"Could not resolve '{name}'\") from e\n        else:\n            return default", "\ndef resolve_name(obj: Any, name: str, default: Any = None, err_on_missing: bool = False) -> Any:\n    \"\"\"\n    Get a key or attr ``name`` from obj or default value.\n\n    Copied and modified from Django Template variable resolutions\n\n    Resolution methods:\n\n    - Mapping key lookup\n    - Attribute lookup\n    - Sequence index\n\n    Args:\n        obj: The object to access\n        name: A dotted name to the value, such as ``mykey.0.name``\n        default: If the name cannot be resolved from the object, return this value\n        err_on_missing: Raise a `BadInputError` if the name cannot be resolved\n\n    Returns:\n        The value at the resolved name or the default value.\n\n    Raises:\n        BadInputError: If we cannot resolve the name and `err_on_missing` is `True`\n\n    # noqa: DAR401\n    \"\"\"\n    lookups = name.split(\".\")\n    current = obj\n    try:  # catch-all for unexpected failures\n        for bit in lookups:\n            try:  # dictionary lookup\n                current = current[bit]\n                # ValueError/IndexError are for numpy.array lookup on\n                # numpy < 1.9 and 1.9+ respectively\n            except (TypeError, AttributeError, KeyError, ValueError, IndexError):\n                try:  # attribute lookup\n                    current = getattr(current, bit)\n                except (TypeError, AttributeError):\n                    # Reraise if the exception was raised by a @property\n                    if bit in dir(current):\n                        raise\n                    try:  # list-index lookup\n                        current = current[int(bit)]\n                    except (\n                        IndexError,  # list index out of range\n                        ValueError,  # invalid literal for int()\n                        KeyError,  # current is a dict without `int(bit)` key\n                        TypeError,\n                    ):  # un-subscript-able object\n                        return default\n        return current\n    except Exception as e:  # noqa: BLE001 # pragma: no cover\n        if err_on_missing:\n            raise BadInputError(f\"Could not resolve '{name}'\") from e\n        else:\n            return default", "\n\ndef log_list(config: Config, version_part: Optional[str], new_version: Optional[str]) -> None:\n    \"\"\"Output configuration with new version.\"\"\"\n    ctx = get_context(config)\n    if version_part:\n        version = config.version_config.parse(config.current_version)\n        next_version = get_next_version(version, config, version_part, new_version)\n        next_version_str = config.version_config.serialize(next_version, ctx)\n\n        print_info(f\"new_version={next_version_str}\")\n\n    for key, value in config.dict(exclude={\"scm_info\", \"parts\"}).items():\n        print_info(f\"{key}={value}\")", "\n\ndef do_show(*args, config: Config, format_: str = \"default\", increment: Optional[str] = None) -> None:\n    \"\"\"Show current version or configuration information.\"\"\"\n    config_dict = config.dict()\n    ctx = get_context(config)\n\n    if increment:\n        version = config.version_config.parse(config.current_version)\n        next_version = get_next_version(version, config, increment, None)\n        next_version_str = config.version_config.serialize(next_version, ctx)\n        config_dict[\"new_version\"] = next_version_str\n\n    try:\n        if \"all\" in args or not args:\n            show_items = config_dict\n        else:\n            show_items = {key: resolve_name(config_dict, key) for key in args}\n\n        OUTPUTTERS.get(format_, OUTPUTTERS[\"default\"])(show_items)\n    except BadInputError as e:\n        print_error(e.message)", ""]}
{"filename": "bumpversion/autocast.py", "chunked_list": ["\"\"\"\nAutomatically detect the true Python type of a string and cast it to the correct type.\n\nBased on https://github.com/cgreer/cgAutoCast/blob/master/cgAutoCast.py\n\"\"\"\n\nimport contextlib\nfrom typing import Any\n\n\ndef boolify(s: str) -> bool:\n    \"\"\"Convert a string to a boolean.\"\"\"\n    if s in {\"True\", \"true\"}:\n        return True\n    if s in {\"False\", \"false\"}:\n        return False\n    raise ValueError(\"Not Boolean Value!\")", "\n\ndef boolify(s: str) -> bool:\n    \"\"\"Convert a string to a boolean.\"\"\"\n    if s in {\"True\", \"true\"}:\n        return True\n    if s in {\"False\", \"false\"}:\n        return False\n    raise ValueError(\"Not Boolean Value!\")\n", "\n\ndef noneify(s: str) -> None:\n    \"\"\"Convert a string to None.\"\"\"\n    if s == \"None\":\n        return None\n    raise ValueError(\"Not None Value!\")\n\n\ndef listify(s: str) -> list:\n    \"\"\"\n    Convert a string representation of a list into list of homogenous basic types.\n\n    Type of elements in list is determined via first element. Successive elements are\n    cast to that type.\n\n    Args:\n        s: String representation of a list.\n\n    Raises:\n        ValueError: If string does not represent a list.\n        TypeError: If string does not represent a list of homogenous basic types.\n\n    Returns:\n        List of homogenous basic types.\n    \"\"\"\n    if \",\" not in s and \"\\n\" not in s:\n        raise ValueError(\"Not a List\")\n\n    # derive the type of the variable\n    str_list = s.strip().split(\",\") if \",\" in s else s.strip().split(\"\\n\")\n    element_caster = str\n    for caster in (boolify, int, float, noneify, element_caster):\n        with contextlib.suppress(ValueError):\n            caster(str_list[0])  # type: ignore[operator]\n            element_caster = caster  # type: ignore[assignment]\n            break\n    # cast all elements\n    try:\n        return [element_caster(x) for x in str_list]\n    except ValueError as e:\n        raise TypeError(\"Autocasted list must be all same type\") from e", "\ndef listify(s: str) -> list:\n    \"\"\"\n    Convert a string representation of a list into list of homogenous basic types.\n\n    Type of elements in list is determined via first element. Successive elements are\n    cast to that type.\n\n    Args:\n        s: String representation of a list.\n\n    Raises:\n        ValueError: If string does not represent a list.\n        TypeError: If string does not represent a list of homogenous basic types.\n\n    Returns:\n        List of homogenous basic types.\n    \"\"\"\n    if \",\" not in s and \"\\n\" not in s:\n        raise ValueError(\"Not a List\")\n\n    # derive the type of the variable\n    str_list = s.strip().split(\",\") if \",\" in s else s.strip().split(\"\\n\")\n    element_caster = str\n    for caster in (boolify, int, float, noneify, element_caster):\n        with contextlib.suppress(ValueError):\n            caster(str_list[0])  # type: ignore[operator]\n            element_caster = caster  # type: ignore[assignment]\n            break\n    # cast all elements\n    try:\n        return [element_caster(x) for x in str_list]\n    except ValueError as e:\n        raise TypeError(\"Autocasted list must be all same type\") from e", "\n\ndef autocast_value(var: Any) -> Any:\n    \"\"\"\n    Guess the string representation of the variable's type.\n\n    Args:\n        var: Value to autocast.\n\n    Returns:\n        The autocasted value.\n    \"\"\"\n    if not isinstance(var, str):  # don't need to guess non-string types\n        return var\n\n    # guess string representation of var\n    for caster in (boolify, int, float, noneify, listify):\n        with contextlib.suppress(ValueError):\n            return caster(var)  # type: ignore[operator]\n\n    return var", ""]}
{"filename": "bumpversion/__init__.py", "chunked_list": ["\"\"\"Top-level package for bump-my-version.\"\"\"\n\n__version__: str = \"0.8.0\"\n"]}
{"filename": "bumpversion/utils.py", "chunked_list": ["\"\"\"General utilities.\"\"\"\nimport string\nfrom collections import ChainMap\nfrom dataclasses import asdict\nfrom typing import TYPE_CHECKING, List, Optional\n\nif TYPE_CHECKING:  # pragma: no-coverage\n    from bumpversion.config import Config\n    from bumpversion.version_part import Version\n", "\n\ndef key_val_string(d: dict) -> str:\n    \"\"\"Render the dictionary as a comma-delimited key=value string.\"\"\"\n    return \", \".join(f\"{k}={v}\" for k, v in sorted(d.items()))\n\n\ndef prefixed_environ() -> dict:\n    \"\"\"Return a dict of the environment with keys wrapped in `${}`.\"\"\"\n    import os\n\n    return {f\"${key}\": value for key, value in os.environ.items()}", "\n\ndef labels_for_format(serialize_format: str) -> List[str]:\n    \"\"\"Return a list of labels for the given serialize_format.\"\"\"\n    return [item[1] for item in string.Formatter().parse(serialize_format) if item[1]]\n\n\ndef get_context(\n    config: \"Config\", current_version: Optional[\"Version\"] = None, new_version: Optional[\"Version\"] = None\n) -> ChainMap:\n    \"\"\"Return the context for rendering messages and tags.\"\"\"\n    import datetime\n\n    ctx = ChainMap(\n        {\"current_version\": config.current_version},\n        {\"now\": datetime.datetime.now(), \"utcnow\": datetime.datetime.utcnow()},\n        prefixed_environ(),\n        asdict(config.scm_info),\n        {c: c for c in (\"#\", \";\")},\n    )\n    if current_version:\n        ctx.new_child({f\"current_{part}\": current_version[part].value for part in current_version})\n    if new_version:\n        ctx.new_child({f\"new_{part}\": new_version[part].value for part in new_version})\n    return ctx", "\n\ndef get_overrides(**kwargs) -> dict:\n    \"\"\"Return a dictionary containing only the overridden key-values.\"\"\"\n    return {key: val for key, val in kwargs.items() if val is not None}\n"]}
{"filename": "bumpversion/version_part.py", "chunked_list": ["\"\"\"Module for managing Versions and their internal parts.\"\"\"\nimport logging\nimport re\nimport string\nfrom copy import copy\nfrom typing import Any, Dict, List, MutableMapping, Optional\n\nfrom click import UsageError\n\nfrom bumpversion.config import VersionPartConfig", "\nfrom bumpversion.config import VersionPartConfig\nfrom bumpversion.exceptions import FormattingError, InvalidVersionPartError, MissingValueError\nfrom bumpversion.functions import NumericFunction, PartFunction, ValuesFunction\nfrom bumpversion.utils import key_val_string, labels_for_format\n\nlogger = logging.getLogger(__name__)\n\n\nclass VersionPart:\n    \"\"\"\n    Represent part of a version number.\n\n    Determines the PartFunction that rules how the part behaves when increased or reset\n    based on the configuration given.\n    \"\"\"\n\n    def __init__(self, config: VersionPartConfig, value: Optional[str] = None):\n        self._value = value\n        self.config = config\n        self.func: Optional[PartFunction] = None\n        if config.values:\n            self.func = ValuesFunction(config.values, config.optional_value, config.first_value)\n        else:\n            self.func = NumericFunction(config.optional_value, config.first_value or \"0\")\n\n    @property\n    def value(self) -> str:\n        \"\"\"Return the value of the part.\"\"\"\n        return self._value or self.func.optional_value\n\n    def copy(self) -> \"VersionPart\":\n        \"\"\"Return a copy of the part.\"\"\"\n        return VersionPart(self.config, self._value)\n\n    def bump(self) -> \"VersionPart\":\n        \"\"\"Return a part with bumped value.\"\"\"\n        return VersionPart(self.config, self.func.bump(self.value))\n\n    def null(self) -> \"VersionPart\":\n        \"\"\"Return a part with first value.\"\"\"\n        return VersionPart(self.config, self.func.first_value)\n\n    @property\n    def is_optional(self) -> bool:\n        \"\"\"Is the part optional?\"\"\"\n        return self.value == self.func.optional_value\n\n    @property\n    def is_independent(self) -> bool:\n        \"\"\"Is the part independent of the other parts?\"\"\"\n        return self.config.independent\n\n    def __format__(self, format_spec: str) -> str:\n        try:\n            val = int(self.value)\n        except ValueError:\n            return self.value\n        else:\n            return int.__format__(val, format_spec)\n\n    def __repr__(self) -> str:\n        return f\"<bumpversion.VersionPart:{self.func.__class__.__name__}:{self.value}>\"\n\n    def __eq__(self, other: Any) -> bool:\n        return self.value == other.value if isinstance(other, VersionPart) else False", "\nclass VersionPart:\n    \"\"\"\n    Represent part of a version number.\n\n    Determines the PartFunction that rules how the part behaves when increased or reset\n    based on the configuration given.\n    \"\"\"\n\n    def __init__(self, config: VersionPartConfig, value: Optional[str] = None):\n        self._value = value\n        self.config = config\n        self.func: Optional[PartFunction] = None\n        if config.values:\n            self.func = ValuesFunction(config.values, config.optional_value, config.first_value)\n        else:\n            self.func = NumericFunction(config.optional_value, config.first_value or \"0\")\n\n    @property\n    def value(self) -> str:\n        \"\"\"Return the value of the part.\"\"\"\n        return self._value or self.func.optional_value\n\n    def copy(self) -> \"VersionPart\":\n        \"\"\"Return a copy of the part.\"\"\"\n        return VersionPart(self.config, self._value)\n\n    def bump(self) -> \"VersionPart\":\n        \"\"\"Return a part with bumped value.\"\"\"\n        return VersionPart(self.config, self.func.bump(self.value))\n\n    def null(self) -> \"VersionPart\":\n        \"\"\"Return a part with first value.\"\"\"\n        return VersionPart(self.config, self.func.first_value)\n\n    @property\n    def is_optional(self) -> bool:\n        \"\"\"Is the part optional?\"\"\"\n        return self.value == self.func.optional_value\n\n    @property\n    def is_independent(self) -> bool:\n        \"\"\"Is the part independent of the other parts?\"\"\"\n        return self.config.independent\n\n    def __format__(self, format_spec: str) -> str:\n        try:\n            val = int(self.value)\n        except ValueError:\n            return self.value\n        else:\n            return int.__format__(val, format_spec)\n\n    def __repr__(self) -> str:\n        return f\"<bumpversion.VersionPart:{self.func.__class__.__name__}:{self.value}>\"\n\n    def __eq__(self, other: Any) -> bool:\n        return self.value == other.value if isinstance(other, VersionPart) else False", "\n\nclass Version:\n    \"\"\"The specification of a version and its parts.\"\"\"\n\n    def __init__(self, values: Dict[str, VersionPart], original: Optional[str] = None):\n        self.values = values\n        self.original = original\n\n    def __getitem__(self, key: str) -> VersionPart:\n        return self.values[key]\n\n    def __len__(self) -> int:\n        return len(self.values)\n\n    def __iter__(self):\n        return iter(self.values)\n\n    def __repr__(self):\n        return f\"<bumpversion.Version:{key_val_string(self.values)}>\"\n\n    def __eq__(self, other: Any) -> bool:\n        return (\n            all(value == other.values[key] for key, value in self.values.items())\n            if isinstance(other, Version)\n            else False\n        )\n\n    def bump(self, part_name: str, order: List[str]) -> \"Version\":\n        \"\"\"Increase the value of the given part.\"\"\"\n        bumped = False\n\n        new_values = {}\n\n        for label in order:\n            if label not in self.values:\n                continue\n            if label == part_name:\n                new_values[label] = self.values[label].bump()\n                bumped = True\n            elif bumped and not self.values[label].is_independent:\n                new_values[label] = self.values[label].null()\n            else:\n                new_values[label] = self.values[label].copy()\n\n        if not bumped:\n            raise InvalidVersionPartError(f\"No part named {part_name!r}\")\n\n        return Version(new_values)", "\n\nclass VersionConfig:\n    \"\"\"\n    Hold a complete representation of a version string.\n    \"\"\"\n\n    def __init__(\n        self,\n        parse: str,\n        serialize: List[str],\n        search: str,\n        replace: str,\n        part_configs: Optional[Dict[str, VersionPartConfig]] = None,\n    ):\n        try:\n            self.parse_regex = re.compile(parse, re.VERBOSE)\n        except re.error as e:\n            raise UsageError(f\"--parse '{parse}' is not a valid regex.\") from e\n\n        self.serialize_formats = serialize\n        self.part_configs = part_configs or {}\n        self.search = search\n        self.replace = replace\n\n    @property\n    def order(self) -> List[str]:\n        \"\"\"\n        Return the order of the labels in a serialization format.\n\n        Currently, order depends on the first given serialization format.\n        This seems like a good idea because this should be the most complete format.\n\n        Returns:\n            A list of version part labels in the order they should be rendered.\n        \"\"\"\n        return labels_for_format(self.serialize_formats[0])\n\n    def parse(self, version_string: Optional[str] = None) -> Optional[Version]:\n        \"\"\"\n        Parse a version string into a Version object.\n\n        Args:\n            version_string: Version string to parse\n\n        Returns:\n            A Version object representing the string.\n        \"\"\"\n        if not version_string:\n            return None\n\n        regexp_one_line = \"\".join([line.split(\"#\")[0].strip() for line in self.parse_regex.pattern.splitlines()])\n\n        logger.info(\n            \"Parsing version '%s' using regexp '%s'\",\n            version_string,\n            regexp_one_line,\n        )\n\n        match = self.parse_regex.search(version_string)\n\n        if not match:\n            logger.warning(\n                \"Evaluating 'parse' option: '%s' does not parse current version '%s'\",\n                self.parse_regex.pattern,\n                version_string,\n            )\n            return None\n\n        _parsed = {\n            key: VersionPart(self.part_configs[key], value)\n            for key, value in match.groupdict().items()\n            if key in self.part_configs\n        }\n        v = Version(_parsed, version_string)\n\n        logger.info(\"Parsed the following values: %s\", key_val_string(v.values))\n\n        return v\n\n    def _serialize(\n        self, version: Version, serialize_format: str, context: MutableMapping, raise_if_incomplete: bool = False\n    ) -> str:\n        \"\"\"\n        Attempts to serialize a version with the given serialization format.\n\n        Args:\n            version: The version to serialize\n            serialize_format: The serialization format to use, using Python's format string syntax\n            context: The context to use when serializing the version\n            raise_if_incomplete: Whether to raise an error if the version is incomplete\n\n        Raises:\n            FormattingError: if not serializable\n            MissingValueError: if not all parts required in the format have values\n\n        Returns:\n            The serialized version as a string\n        \"\"\"\n        values = copy(context)\n        for k in version:\n            values[k] = version[k]\n\n        # TODO dump complete context on debug level\n\n        try:\n            # test whether all parts required in the format have values\n            serialized = serialize_format.format(**values)\n\n        except KeyError as e:\n            missing_key = getattr(e, \"message\", e.args[0])\n            raise MissingValueError(\n                f\"Did not find key {missing_key!r} in {version!r} when serializing version number\"\n            ) from e\n\n        keys_needing_representation = set()\n\n        keys = list(self.order)\n        for i, k in enumerate(keys):\n            v = values[k]\n\n            if not isinstance(v, VersionPart):\n                # values coming from environment variables don't need\n                # representation\n                continue\n\n            if not v.is_optional:\n                keys_needing_representation = set(keys[: i + 1])\n\n        required_by_format = set(labels_for_format(serialize_format))\n\n        # try whether all parsed keys are represented\n        if raise_if_incomplete and not keys_needing_representation <= required_by_format:\n            missing_keys = keys_needing_representation ^ required_by_format\n            raise FormattingError(\n                f\"\"\"Could not represent '{\"', '\".join(missing_keys)}' in format '{serialize_format}'\"\"\"\n            )\n\n        return serialized\n\n    def _choose_serialize_format(self, version: Version, context: MutableMapping) -> str:\n        chosen = None\n\n        logger.debug(\"Available serialization formats: '%s'\", \"', '\".join(self.serialize_formats))\n\n        for serialize_format in self.serialize_formats:\n            try:\n                self._serialize(version, serialize_format, context, raise_if_incomplete=True)\n                # Prefer shorter or first search expression.\n                chosen_part_count = len(list(string.Formatter().parse(chosen))) if chosen else None\n                serialize_part_count = len(list(string.Formatter().parse(serialize_format)))\n                if not chosen or chosen_part_count > serialize_part_count:\n                    chosen = serialize_format\n                    logger.debug(\"Found '%s' to be a usable serialization format\", chosen)\n                else:\n                    logger.debug(\"Found '%s' usable serialization format, but it's longer\", serialize_format)\n            except FormattingError:\n                # If chosen, prefer shorter\n                if not chosen:\n                    chosen = serialize_format\n            except MissingValueError as e:\n                logger.info(e.message)\n                raise e\n\n        if not chosen:\n            raise KeyError(\"Did not find suitable serialization format\")\n\n        logger.debug(\"Selected serialization format '%s'\", chosen)\n\n        return chosen\n\n    def serialize(self, version: Version, context: MutableMapping) -> str:\n        \"\"\"\n        Serialize a version to a string.\n\n        Args:\n            version: The version to serialize\n            context: The context to use when serializing the version\n\n        Returns:\n            The serialized version as a string\n        \"\"\"\n        serialized = self._serialize(version, self._choose_serialize_format(version, context), context)\n        logger.debug(\"Serialized to '%s'\", serialized)\n        return serialized", ""]}
{"filename": "bumpversion/aliases.py", "chunked_list": ["\"\"\"Utilities for handling command aliases.\"\"\"\nfrom typing import List, Optional\n\nimport rich_click as click\nfrom click import Context\nfrom rich_click.rich_group import RichGroup\n\nfrom bumpversion.ui import print_warning\n\n\nclass AliasedGroup(RichGroup):\n    \"\"\"\n    This following example implements a subclass of Group that accepts a prefix for a command.\n\n    If there were a command called ``push``, it would accept ``pus`` as an alias (so long as it was unique)\n    \"\"\"\n\n    def get_command(self, ctx: Context, cmd_name: str) -> Optional[click.Command]:\n        \"\"\"Given a context and a command name, this returns a Command object if it exists or returns None.\"\"\"\n        rv = click.Group.get_command(self, ctx, cmd_name)\n        if rv is not None:\n            return rv\n        matches = [x for x in self.list_commands(ctx) if x.startswith(cmd_name)]\n        if not matches:\n            args = [cmd_name, *ctx.args]\n            new_ctx = self.make_context(ctx.info_name, args, parent=ctx)\n            return click.Group.get_command(self, new_ctx, \"bump\")\n        elif len(matches) == 1:\n            return click.Group.get_command(self, ctx, matches[0])\n        ctx.fail(f\"Too many matches: {', '.join(sorted(matches))}\")\n\n    def resolve_command(self, ctx: Context, args: List[str]) -> tuple:\n        \"\"\"Find the command and make sure the full command name is returned.\"\"\"\n        # always return the full command name\n        original_args = args[:]\n        _, cmd, args = super().resolve_command(ctx, args)\n\n        if cmd.name == \"bump\" and args != original_args:\n            if \"bump\" in original_args:\n                original_args.remove(\"bump\")\n            else:\n                print_warning(\n                    \"Calling bumpversion without a subcommand is deprecated. \" \"Please use `bumpversion bump` instead\"\n                )\n            return cmd.name, cmd, original_args\n        return cmd.name, cmd, args", "\n\nclass AliasedGroup(RichGroup):\n    \"\"\"\n    This following example implements a subclass of Group that accepts a prefix for a command.\n\n    If there were a command called ``push``, it would accept ``pus`` as an alias (so long as it was unique)\n    \"\"\"\n\n    def get_command(self, ctx: Context, cmd_name: str) -> Optional[click.Command]:\n        \"\"\"Given a context and a command name, this returns a Command object if it exists or returns None.\"\"\"\n        rv = click.Group.get_command(self, ctx, cmd_name)\n        if rv is not None:\n            return rv\n        matches = [x for x in self.list_commands(ctx) if x.startswith(cmd_name)]\n        if not matches:\n            args = [cmd_name, *ctx.args]\n            new_ctx = self.make_context(ctx.info_name, args, parent=ctx)\n            return click.Group.get_command(self, new_ctx, \"bump\")\n        elif len(matches) == 1:\n            return click.Group.get_command(self, ctx, matches[0])\n        ctx.fail(f\"Too many matches: {', '.join(sorted(matches))}\")\n\n    def resolve_command(self, ctx: Context, args: List[str]) -> tuple:\n        \"\"\"Find the command and make sure the full command name is returned.\"\"\"\n        # always return the full command name\n        original_args = args[:]\n        _, cmd, args = super().resolve_command(ctx, args)\n\n        if cmd.name == \"bump\" and args != original_args:\n            if \"bump\" in original_args:\n                original_args.remove(\"bump\")\n            else:\n                print_warning(\n                    \"Calling bumpversion without a subcommand is deprecated. \" \"Please use `bumpversion bump` instead\"\n                )\n            return cmd.name, cmd, original_args\n        return cmd.name, cmd, args", ""]}
{"filename": "bumpversion/bump.py", "chunked_list": ["\"\"\"Version changing methods.\"\"\"\nimport logging\nimport shlex\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING, ChainMap, List, Optional\n\nif TYPE_CHECKING:  # pragma: no-coverage\n    from bumpversion.files import ConfiguredFile\n    from bumpversion.version_part import Version\n", "\nfrom bumpversion.config import Config, update_config_file\nfrom bumpversion.exceptions import ConfigurationError\nfrom bumpversion.utils import get_context, key_val_string\n\nlogger = logging.getLogger(\"bumpversion\")\n\n\ndef get_next_version(\n    current_version: \"Version\", config: Config, version_part: Optional[str], new_version: Optional[str]\n) -> \"Version\":\n    \"\"\"\n    Bump the version_part to the next value.\n\n    Args:\n        current_version: The current version\n        config: The current configuration\n        version_part: Optional part of the version to bump\n        new_version: Optional specific version to bump to\n\n    Returns:\n        The new version\n\n    Raises:\n        ConfigurationError: If it can't generate the next version.\n    \"\"\"\n    if new_version:\n        next_version = config.version_config.parse(new_version)\n    elif version_part:\n        logger.info(\"Attempting to increment part '%s'\", version_part)\n        next_version = current_version.bump(version_part, config.version_config.order)\n    else:\n        raise ConfigurationError(\"Unable to get the next version.\")\n\n    logger.info(\"Values are now: %s\", key_val_string(next_version.values))\n    return next_version", "def get_next_version(\n    current_version: \"Version\", config: Config, version_part: Optional[str], new_version: Optional[str]\n) -> \"Version\":\n    \"\"\"\n    Bump the version_part to the next value.\n\n    Args:\n        current_version: The current version\n        config: The current configuration\n        version_part: Optional part of the version to bump\n        new_version: Optional specific version to bump to\n\n    Returns:\n        The new version\n\n    Raises:\n        ConfigurationError: If it can't generate the next version.\n    \"\"\"\n    if new_version:\n        next_version = config.version_config.parse(new_version)\n    elif version_part:\n        logger.info(\"Attempting to increment part '%s'\", version_part)\n        next_version = current_version.bump(version_part, config.version_config.order)\n    else:\n        raise ConfigurationError(\"Unable to get the next version.\")\n\n    logger.info(\"Values are now: %s\", key_val_string(next_version.values))\n    return next_version", "\n\ndef do_bump(\n    version_part: Optional[str],\n    new_version: Optional[str],\n    config: Config,\n    config_file: Optional[Path] = None,\n    dry_run: bool = False,\n) -> None:\n    \"\"\"\n    Bump the version_part to the next value or set the version to new_version.\n\n    Args:\n        version_part: The version part to bump\n        new_version: The explicit version to set\n        config: The configuration to use\n        config_file: The configuration file to update\n        dry_run: True if the operation should be a dry run\n    \"\"\"\n    from bumpversion.files import modify_files, resolve_file_config\n\n    ctx = get_context(config)\n    version = config.version_config.parse(config.current_version)\n    next_version = get_next_version(version, config, version_part, new_version)\n    next_version_str = config.version_config.serialize(next_version, ctx)\n    logger.info(\"New version will be '%s'\", next_version_str)\n\n    if config.current_version == next_version_str:\n        logger.info(\"Version is already '%s'\", next_version_str)\n        return\n\n    if dry_run:\n        logger.info(\"Dry run active, won't touch any files.\")\n\n    ctx = get_context(config, version, next_version)\n\n    configured_files = resolve_file_config(config.files, config.version_config)\n    modify_files(configured_files, version, next_version, ctx, dry_run)\n\n    update_config_file(config_file, config.current_version, next_version_str, dry_run)\n\n    commit_and_tag(config, config_file, configured_files, ctx, dry_run)", "\n\ndef commit_and_tag(\n    config: Config,\n    config_file: Optional[Path],\n    configured_files: List[\"ConfiguredFile\"],\n    ctx: ChainMap,\n    dry_run: bool = False,\n) -> None:\n    \"\"\"\n    Commit and tag the changes, if a tool is configured.\n\n    Args:\n        config: The configuration\n        config_file: The configuration file to include in the commit, if it exists\n        configured_files: A list of files to commit\n        ctx: The context used to render the tag and tag message\n        dry_run: True if the operation should be a dry run\n    \"\"\"\n    if not config.scm_info.tool:\n        return\n\n    extra_args = shlex.split(config.commit_args) if config.commit_args else []\n\n    commit_files = {f.path for f in configured_files}\n    if config_file:\n        commit_files |= {str(config_file)}\n\n    config.scm_info.tool.commit_to_scm(list(commit_files), config, ctx, extra_args, dry_run)\n    config.scm_info.tool.tag_in_scm(config, ctx, dry_run)", ""]}
{"filename": "bumpversion/exceptions.py", "chunked_list": ["\"\"\"Custom exceptions for BumpVersion.\"\"\"\nfrom typing import Optional\n\nfrom click import Context, UsageError\n\n\nclass BumpVersionError(UsageError):\n    \"\"\"Custom base class for all BumpVersion exception types.\"\"\"\n\n    def __init__(self, message: str, ctx: Optional[Context] = None):\n        self.message = message\n        self.ctx = ctx", "\n\nclass FormattingError(BumpVersionError):\n    \"\"\"We are unable to represent a version required by a format.\"\"\"\n\n    pass\n\n\nclass MissingValueError(BumpVersionError):\n    \"\"\"A part required for a version format is empty.\"\"\"\n\n    pass", "class MissingValueError(BumpVersionError):\n    \"\"\"A part required for a version format is empty.\"\"\"\n\n    pass\n\n\nclass DirtyWorkingDirectoryError(BumpVersionError):\n    \"\"\"The working directory is dirty, and it is not allowed.\"\"\"\n\n    pass", "\n\nclass SignedTagsError(BumpVersionError):\n    \"\"\"The VCS does not support signed tags.\"\"\"\n\n    pass\n\n\nclass VersionNotFoundError(BumpVersionError):\n    \"\"\"A version number was not found in a source file.\"\"\"\n\n    pass", "class VersionNotFoundError(BumpVersionError):\n    \"\"\"A version number was not found in a source file.\"\"\"\n\n    pass\n\n\nclass InvalidVersionPartError(BumpVersionError):\n    \"\"\"The specified part (e.g. 'bugfix') was not found.\"\"\"\n\n    pass", "\n\nclass ConfigurationError(BumpVersionError):\n    \"\"\"A configuration key-value is missing or in the wrong type.\"\"\"\n\n    pass\n\n\nclass BadInputError(BumpVersionError):\n    \"\"\"User input was bad.\"\"\"\n\n    pass", "class BadInputError(BumpVersionError):\n    \"\"\"User input was bad.\"\"\"\n\n    pass\n"]}
{"filename": "bumpversion/cli.py", "chunked_list": ["\"\"\"bump-my-version Command line interface.\"\"\"\nimport logging\nfrom typing import List, Optional\n\nimport rich_click as click\nfrom click.core import Context\n\nfrom bumpversion import __version__\nfrom bumpversion.aliases import AliasedGroup\nfrom bumpversion.bump import do_bump", "from bumpversion.aliases import AliasedGroup\nfrom bumpversion.bump import do_bump\nfrom bumpversion.config import find_config_file, get_configuration\nfrom bumpversion.files import modify_files, resolve_file_config\nfrom bumpversion.logging import setup_logging\nfrom bumpversion.show import do_show, log_list\nfrom bumpversion.ui import print_warning\nfrom bumpversion.utils import get_context, get_overrides\n\nlogger = logging.getLogger(__name__)", "\nlogger = logging.getLogger(__name__)\n\n\n@click.group(\n    cls=AliasedGroup,\n    invoke_without_command=True,\n    context_settings={\n        \"ignore_unknown_options\": True,\n        \"allow_interspersed_args\": True,", "        \"ignore_unknown_options\": True,\n        \"allow_interspersed_args\": True,\n    },\n    add_help_option=False,\n)\n@click.version_option(version=__version__)\n@click.pass_context\ndef cli(ctx: Context) -> None:\n    \"\"\"Version bump your Python project.\"\"\"\n    if ctx.invoked_subcommand is None:\n        ctx.invoke(bump, *ctx.args)", "\n\nclick.rich_click.OPTION_GROUPS = {\n    \"bumpversion bump\": [\n        {\n            \"name\": \"Configuration\",\n            \"options\": [\n                \"--config-file\",\n                \"--current-version\",\n                \"--new-version\",", "                \"--current-version\",\n                \"--new-version\",\n                \"--parse\",\n                \"--serialize\",\n                \"--search\",\n                \"--replace\",\n                \"--no-configured-files\",\n                \"--ignore-missing-version\",\n            ],\n        },", "            ],\n        },\n        {\n            \"name\": \"Output\",\n            \"options\": [\"--dry-run\", \"--verbose\"],\n        },\n        {\n            \"name\": \"Committing and tagging\",\n            \"options\": [\n                \"--allow-dirty\" \"--commit\",", "            \"options\": [\n                \"--allow-dirty\" \"--commit\",\n                \"--commit-args\",\n                \"--message\",\n                \"--tag\",\n                \"--tag-name\",\n                \"--tag-message\",\n                \"--sign-tags\",\n            ],\n        },", "            ],\n        },\n    ]\n}\n\n\n@cli.command(context_settings={\"ignore_unknown_options\": True})\n@click.argument(\"args\", nargs=-1, type=str)\n@click.option(\n    \"--config-file\",", "@click.option(\n    \"--config-file\",\n    metavar=\"FILE\",\n    required=False,\n    envvar=\"BUMPVERSION_CONFIG_FILE\",\n    type=click.Path(exists=True),\n    help=\"Config file to read most of the variables from.\",\n)\n@click.option(\n    \"-v\",", "@click.option(\n    \"-v\",\n    \"--verbose\",\n    count=True,\n    required=False,\n    envvar=\"BUMPVERSION_VERBOSE\",\n    help=\"Print verbose logging to stderr. Can specify several times for more verbosity.\",\n)\n@click.option(\n    \"--allow-dirty/--no-allow-dirty\",", "@click.option(\n    \"--allow-dirty/--no-allow-dirty\",\n    default=None,\n    required=False,\n    envvar=\"BUMPVERSION_ALLOW_DIRTY\",\n    help=\"Don't abort if working directory is dirty, or explicitly abort if dirty.\",\n)\n@click.option(\n    \"--current-version\",\n    metavar=\"VERSION\",", "    \"--current-version\",\n    metavar=\"VERSION\",\n    required=False,\n    envvar=\"BUMPVERSION_CURRENT_VERSION\",\n    help=\"Version that needs to be updated\",\n)\n@click.option(\n    \"--new-version\",\n    metavar=\"VERSION\",\n    required=False,", "    metavar=\"VERSION\",\n    required=False,\n    envvar=\"BUMPVERSION_NEW_VERSION\",\n    help=\"New version that should be in the files\",\n)\n@click.option(\n    \"--parse\",\n    metavar=\"REGEX\",\n    required=False,\n    envvar=\"BUMPVERSION_PARSE\",", "    required=False,\n    envvar=\"BUMPVERSION_PARSE\",\n    help=\"Regex parsing the version string\",\n)\n@click.option(\n    \"--serialize\",\n    metavar=\"FORMAT\",\n    multiple=True,\n    required=False,\n    envvar=\"BUMPVERSION_SERIALIZE\",", "    required=False,\n    envvar=\"BUMPVERSION_SERIALIZE\",\n    help=\"How to format what is parsed back to a version\",\n)\n@click.option(\n    \"--search\",\n    metavar=\"SEARCH\",\n    required=False,\n    envvar=\"BUMPVERSION_SEARCH\",\n    help=\"Template for complete string to search\",", "    envvar=\"BUMPVERSION_SEARCH\",\n    help=\"Template for complete string to search\",\n)\n@click.option(\n    \"--replace\",\n    metavar=\"REPLACE\",\n    required=False,\n    envvar=\"BUMPVERSION_REPLACE\",\n    help=\"Template for complete string to replace\",\n)", "    help=\"Template for complete string to replace\",\n)\n@click.option(\n    \"--no-configured-files\",\n    is_flag=True,\n    envvar=\"BUMPVERSION_NO_CONFIGURED_FILES\",\n    help=(\n        \"Only replace the version in files specified on the command line, \"\n        \"ignoring the files from the configuration file.\"\n    ),", "        \"ignoring the files from the configuration file.\"\n    ),\n)\n@click.option(\n    \"--ignore-missing-version\",\n    is_flag=True,\n    envvar=\"BUMPVERSION_IGNORE_MISSING_VERSION\",\n    help=\"Ignore any Version Not Found errors when searching and replacing in files.\",\n)\n@click.option(", ")\n@click.option(\n    \"--dry-run\",\n    \"-n\",\n    is_flag=True,\n    envvar=\"BUMPVERSION_DRY_RUN\",\n    help=\"Don't write any files, just pretend.\",\n)\n@click.option(\n    \"--commit/--no-commit\",", "@click.option(\n    \"--commit/--no-commit\",\n    default=None,\n    envvar=\"BUMPVERSION_COMMIT\",\n    help=\"Commit to version control\",\n)\n@click.option(\n    \"--tag/--no-tag\",\n    default=None,\n    envvar=\"BUMPVERSION_TAG\",", "    default=None,\n    envvar=\"BUMPVERSION_TAG\",\n    help=\"Create a tag in version control\",\n)\n@click.option(\n    \"--sign-tags/--no-sign-tags\",\n    default=None,\n    envvar=\"BUMPVERSION_SIGN_TAGS\",\n    help=\"Sign tags if created\",\n)", "    help=\"Sign tags if created\",\n)\n@click.option(\n    \"--tag-name\",\n    metavar=\"TAG_NAME\",\n    required=False,\n    envvar=\"BUMPVERSION_TAG_NAME\",\n    help=\"Tag name (only works with --tag)\",\n)\n@click.option(", ")\n@click.option(\n    \"--tag-message\",\n    metavar=\"TAG_MESSAGE\",\n    required=False,\n    envvar=\"BUMPVERSION_TAG_MESSAGE\",\n    help=\"Tag message\",\n)\n@click.option(\n    \"-m\",", "@click.option(\n    \"-m\",\n    \"--message\",\n    metavar=\"COMMIT_MSG\",\n    required=False,\n    envvar=\"BUMPVERSION_MESSAGE\",\n    help=\"Commit message\",\n)\n@click.option(\n    \"--commit-args\",", "@click.option(\n    \"--commit-args\",\n    metavar=\"COMMIT_ARGS\",\n    required=False,\n    envvar=\"BUMPVERSION_COMMIT_ARGS\",\n    help=\"Extra arguments to commit command\",\n)\n@click.option(\n    \"--list\",\n    \"show_list\",", "    \"--list\",\n    \"show_list\",\n    is_flag=True,\n    help=\"List machine readable information\",\n)\ndef bump(\n    # version_part: str,\n    args: list,\n    config_file: Optional[str],\n    verbose: int,\n    allow_dirty: Optional[bool],\n    current_version: Optional[str],\n    new_version: Optional[str],\n    parse: Optional[str],\n    serialize: Optional[List[str]],\n    search: Optional[str],\n    replace: Optional[str],\n    no_configured_files: bool,\n    ignore_missing_version: bool,\n    dry_run: bool,\n    commit: Optional[bool],\n    tag: Optional[bool],\n    sign_tags: Optional[bool],\n    tag_name: Optional[str],\n    tag_message: Optional[str],\n    message: Optional[str],\n    commit_args: Optional[str],\n    show_list: bool,\n) -> None:\n    \"\"\"\n    Change the version.\n\n    ARGS may contain any of the following:\n\n    VERSION_PART is the part of the version to increase, e.g. `minor` .\n    Valid values include those given in the `--serialize` / `--parse` option.\n\n    FILES are additional file(s) to modify.\n    If you want to rewrite only files specified on the command line, use with the\n    `--no-configured-files` option.\n    \"\"\"\n    setup_logging(verbose)\n\n    logger.info(\"Starting BumpVersion %s\", __version__)\n\n    overrides = get_overrides(\n        allow_dirty=allow_dirty,\n        current_version=current_version,\n        parse=parse,\n        serialize=serialize or None,\n        search=search,\n        replace=replace,\n        commit=commit,\n        tag=tag,\n        sign_tags=sign_tags,\n        tag_name=tag_name,\n        tag_message=tag_message,\n        message=message,\n        commit_args=commit_args,\n        ignore_missing_version=ignore_missing_version,\n    )\n\n    found_config_file = find_config_file(config_file)\n    config = get_configuration(found_config_file, **overrides)\n    if args:\n        if args[0] not in config.parts.keys():\n            raise click.BadArgumentUsage(f\"Unknown version part: {args[0]}\")\n        version_part = args[0]\n        files = args[1:]\n    else:\n        version_part = None\n        files = args\n\n    if show_list:\n        print_warning(\"DEPRECATED: The --list option is deprecated and will be removed in a future version.\")\n        log_list(config, version_part, new_version)\n        return\n\n    config.allow_dirty = allow_dirty if allow_dirty is not None else config.allow_dirty\n    if not config.allow_dirty and config.scm_info.tool:\n        config.scm_info.tool.assert_nondirty()\n\n    if no_configured_files:\n        config.files = []\n\n    if files:\n        config.add_files(files)\n\n    do_bump(version_part, new_version, config, found_config_file, dry_run)", "\n\n@cli.command()\n@click.argument(\"args\", nargs=-1, type=str)\n@click.option(\n    \"--config-file\",\n    metavar=\"FILE\",\n    required=False,\n    envvar=\"BUMPVERSION_CONFIG_FILE\",\n    type=click.Path(exists=True),", "    envvar=\"BUMPVERSION_CONFIG_FILE\",\n    type=click.Path(exists=True),\n    help=\"Config file to read most of the variables from.\",\n)\n@click.option(\n    \"-f\",\n    \"--format\",\n    \"format_\",\n    required=False,\n    envvar=\"BUMPVERSION_FORMAT\",", "    required=False,\n    envvar=\"BUMPVERSION_FORMAT\",\n    type=click.Choice([\"default\", \"yaml\", \"json\"], case_sensitive=False),\n    default=\"default\",\n    help=\"Config file to read most of the variables from.\",\n)\n@click.option(\n    \"-i\",\n    \"--increment\",\n    required=False,", "    \"--increment\",\n    required=False,\n    envvar=\"BUMPVERSION_INCREMENT\",\n    type=str,\n    help=\"Increment the version part and add `new_version` to the configuration.\",\n)\ndef show(args: List[str], config_file: Optional[str], format_: str, increment: Optional[str]) -> None:\n    \"\"\"Show current configuration information.\"\"\"\n    found_config_file = find_config_file(config_file)\n    config = get_configuration(found_config_file)\n\n    if not args:\n        do_show(\"all\", config=config, format_=format_, increment=increment)\n    else:\n        do_show(*args, config=config, format_=format_, increment=increment)", "\n\n@cli.command()\n@click.argument(\"files\", nargs=-1, type=str)\n@click.option(\n    \"--config-file\",\n    metavar=\"FILE\",\n    required=False,\n    envvar=\"BUMPVERSION_CONFIG_FILE\",\n    type=click.Path(exists=True),", "    envvar=\"BUMPVERSION_CONFIG_FILE\",\n    type=click.Path(exists=True),\n    help=\"Config file to read most of the variables from.\",\n)\n@click.option(\n    \"-v\",\n    \"--verbose\",\n    count=True,\n    required=False,\n    envvar=\"BUMPVERSION_VERBOSE\",", "    required=False,\n    envvar=\"BUMPVERSION_VERBOSE\",\n    help=\"Print verbose logging to stderr. Can specify several times for more verbosity.\",\n)\n@click.option(\n    \"--allow-dirty/--no-allow-dirty\",\n    default=None,\n    required=False,\n    envvar=\"BUMPVERSION_ALLOW_DIRTY\",\n    help=\"Don't abort if working directory is dirty, or explicitly abort if dirty.\",", "    envvar=\"BUMPVERSION_ALLOW_DIRTY\",\n    help=\"Don't abort if working directory is dirty, or explicitly abort if dirty.\",\n)\n@click.option(\n    \"--current-version\",\n    metavar=\"VERSION\",\n    required=False,\n    envvar=\"BUMPVERSION_CURRENT_VERSION\",\n    help=\"Version that needs to be updated\",\n)", "    help=\"Version that needs to be updated\",\n)\n@click.option(\n    \"--new-version\",\n    metavar=\"VERSION\",\n    required=False,\n    envvar=\"BUMPVERSION_NEW_VERSION\",\n    help=\"New version that should be in the files. If not specified, it will be None.\",\n)\n@click.option(", ")\n@click.option(\n    \"--parse\",\n    metavar=\"REGEX\",\n    required=False,\n    envvar=\"BUMPVERSION_PARSE\",\n    help=\"Regex parsing the version string\",\n)\n@click.option(\n    \"--serialize\",", "@click.option(\n    \"--serialize\",\n    metavar=\"FORMAT\",\n    multiple=True,\n    required=False,\n    envvar=\"BUMPVERSION_SERIALIZE\",\n    help=\"How to format what is parsed back to a version\",\n)\n@click.option(\n    \"--search\",", "@click.option(\n    \"--search\",\n    metavar=\"SEARCH\",\n    required=False,\n    envvar=\"BUMPVERSION_SEARCH\",\n    help=\"Template for complete string to search\",\n)\n@click.option(\n    \"--replace\",\n    metavar=\"REPLACE\",", "    \"--replace\",\n    metavar=\"REPLACE\",\n    required=False,\n    envvar=\"BUMPVERSION_REPLACE\",\n    help=\"Template for complete string to replace\",\n)\n@click.option(\n    \"--no-configured-files\",\n    is_flag=True,\n    envvar=\"BUMPVERSION_NO_CONFIGURED_FILES\",", "    is_flag=True,\n    envvar=\"BUMPVERSION_NO_CONFIGURED_FILES\",\n    help=(\n        \"Only replace the version in files specified on the command line, \"\n        \"ignoring the files from the configuration file.\"\n    ),\n)\n@click.option(\n    \"--ignore-missing-version\",\n    is_flag=True,", "    \"--ignore-missing-version\",\n    is_flag=True,\n    envvar=\"BUMPVERSION_IGNORE_MISSING_VERSION\",\n    help=\"Ignore any Version Not Found errors when searching and replacing in files.\",\n)\n@click.option(\n    \"--dry-run\",\n    \"-n\",\n    is_flag=True,\n    envvar=\"BUMPVERSION_DRY_RUN\",", "    is_flag=True,\n    envvar=\"BUMPVERSION_DRY_RUN\",\n    help=\"Don't write any files, just pretend.\",\n)\ndef replace(\n    files: list,\n    config_file: Optional[str],\n    verbose: int,\n    allow_dirty: Optional[bool],\n    current_version: Optional[str],\n    new_version: Optional[str],\n    parse: Optional[str],\n    serialize: Optional[List[str]],\n    search: Optional[str],\n    replace: Optional[str],\n    no_configured_files: bool,\n    ignore_missing_version: bool,\n    dry_run: bool,\n) -> None:\n    \"\"\"\n    Replace the version in files.\n\n    FILES are additional file(s) to modify.\n    If you want to rewrite only files specified on the command line, use with the\n    `--no-configured-files` option.\n    \"\"\"\n    setup_logging(verbose)\n\n    logger.info(\"Starting BumpVersion %s\", __version__)\n\n    overrides = get_overrides(\n        allow_dirty=allow_dirty,\n        current_version=current_version,\n        new_version=new_version,\n        parse=parse,\n        serialize=serialize or None,\n        commit=False,\n        tag=False,\n        sign_tags=False,\n        tag_name=None,\n        tag_message=None,\n        message=None,\n        commit_args=None,\n        ignore_missing_version=ignore_missing_version,\n    )\n\n    found_config_file = find_config_file(config_file)\n    config = get_configuration(found_config_file, **overrides)\n\n    config.allow_dirty = allow_dirty if allow_dirty is not None else config.allow_dirty\n    if not config.allow_dirty and config.scm_info.tool:\n        config.scm_info.tool.assert_nondirty()\n\n    if no_configured_files:\n        config.files = []\n\n    if files:\n        config.add_files(files)\n\n    version = config.version_config.parse(config.current_version)\n\n    if new_version:\n        next_version = config.version_config.parse(new_version)\n    else:\n        next_version = None\n\n    ctx = get_context(config, version, next_version)\n\n    configured_files = resolve_file_config(config.files, config.version_config, search, replace)\n\n    modify_files(configured_files, version, next_version, ctx, dry_run)", ""]}
{"filename": "bumpversion/logging.py", "chunked_list": ["\"\"\"Logging configuration for bumpversion.\"\"\"\nimport logging\n\nimport click\nfrom rich.logging import RichHandler\n\nlogger = logging.getLogger(\"bumpversion\")\n\nVERBOSITY = {\n    0: logging.WARNING,", "VERBOSITY = {\n    0: logging.WARNING,\n    1: logging.INFO,\n    2: logging.DEBUG,\n}\n\n\ndef setup_logging(verbose: int = 0) -> None:\n    \"\"\"Configure the logging.\"\"\"\n    logging.basicConfig(\n        level=VERBOSITY.get(verbose, logging.DEBUG),\n        format=\"%(message)s\",\n        datefmt=\"[%X]\",\n        handlers=[\n            RichHandler(\n                rich_tracebacks=True, show_level=False, show_path=False, show_time=False, tracebacks_suppress=[click]\n            )\n        ],\n    )\n    root_logger = logging.getLogger(\"\")\n    root_logger.setLevel(VERBOSITY.get(verbose, logging.DEBUG))", ""]}
{"filename": "tests/test_yaml.py", "chunked_list": ["\"\"\"Tests for the yaml serialization module.\"\"\"\nfrom pathlib import Path\n\nfrom bumpversion import yaml_dump\nfrom datetime import datetime, date\n\n\ndef test_dump_unknown():\n    assert yaml_dump.dump((1, 2)) == '\"(1, 2)\"'\n", "\n\ndef test_format_str():\n    assert yaml_dump.format_str(\"value\") == '\"value\"'\n\n\ndef test_format_int():\n    assert yaml_dump.format_int(10) == \"10\"\n\n\ndef test_format_float():\n    assert yaml_dump.format_float(1.0) == \"1.0\"\n    assert yaml_dump.format_float(1e300) == \".inf\"\n    assert yaml_dump.format_float(-1e300) == \"-.inf\"\n    assert yaml_dump.format_float(1e17) == \"1.0e+17\"\n    assert yaml_dump.format_float(float(\"nan\")) == \".nan\"", "\n\ndef test_format_float():\n    assert yaml_dump.format_float(1.0) == \"1.0\"\n    assert yaml_dump.format_float(1e300) == \".inf\"\n    assert yaml_dump.format_float(-1e300) == \"-.inf\"\n    assert yaml_dump.format_float(1e17) == \"1.0e+17\"\n    assert yaml_dump.format_float(float(\"nan\")) == \".nan\"\n\n\ndef test_format_bool():\n    assert yaml_dump.format_bool(True) == \"true\"\n    assert yaml_dump.format_bool(False) == \"false\"", "\n\ndef test_format_bool():\n    assert yaml_dump.format_bool(True) == \"true\"\n    assert yaml_dump.format_bool(False) == \"false\"\n\n\ndef test_format_dict():\n    test_dict = {\n        \"key\": \"strval\",\n        \"key2\": 30,\n        \"key3\": datetime(2023, 6, 19, 13, 45, 30),\n        \"key4\": date(2023, 6, 19),\n        \"key5\": {\"subkey\": \"subval\"},\n        \"key6\": [1, 2, 3],\n        \"key7\": None,\n        \"key8\": True,\n        \"key9\": False,\n        \"key10\": 1.43,\n    }\n    expected = (\n        'key: \"strval\"\\n'\n        \"key10: 1.43\\n\"\n        \"key2: 30\\n\"\n        \"key3: 2023-06-19 13:45:30\\n\"\n        \"key4: 2023-06-19\\n\"\n        \"key5:\\n\"\n        '  subkey: \"subval\"\\n'\n        \"key6:\\n\"\n        \"  - 1\\n\"\n        \"  - 2\\n\"\n        \"  - 3\\n\"\n        \"key7: null\\n\"\n        \"key8: true\\n\"\n        \"key9: false\\n\"\n    )\n    assert yaml_dump.format_dict(test_dict) == expected", "\n\ndef test_format_list():\n    assert yaml_dump.format_list([\"item\"]) == '- \"item\"\\n'\n    assert yaml_dump.format_list([\"item\", [\"item2\"]]) == '- \"item\"\\n-\\n  - \"item2\"\\n'\n\n\ndef test_dump_none_val():\n    assert yaml_dump.format_none(None) == \"null\"\n", "\n\ndef test_dump_date_val():\n    test_date = date(2023, 6, 19)\n    assert yaml_dump.format_date(test_date) == \"2023-06-19\"\n\n\ndef test_dump_datetime_val():\n    test_datetime = datetime(2023, 6, 19, 13, 45, 30)\n    assert yaml_dump.format_datetime(test_datetime) == \"2023-06-19 13:45:30\"", ""]}
{"filename": "tests/test_autocast.py", "chunked_list": ["\"\"\"Tests for the autocast module.\"\"\"\nimport pytest\nfrom pytest import param\n\nfrom bumpversion import autocast\n\n\n@pytest.mark.parametrize(\n    \"value, expected\",\n    [", "    \"value, expected\",\n    [\n        param(\"true\", True, id=\"true\"),\n        param(\"false\", False, id=\"false\"),\n        param(\"True\", True, id=\"True\"),\n        param(\"False\", False, id=\"False\"),\n    ],\n)\ndef test_boolify_valid(value: str, expected: bool) -> None:\n    \"\"\"Test the boolify function.\"\"\"\n    assert autocast.boolify(value) == expected", "def test_boolify_valid(value: str, expected: bool) -> None:\n    \"\"\"Test the boolify function.\"\"\"\n    assert autocast.boolify(value) == expected\n\n\n@pytest.mark.parametrize(\n    \"value\",\n    [\n        param(1, id=\"int\"),\n        param(\"string\", id=\"str\"),", "        param(1, id=\"int\"),\n        param(\"string\", id=\"str\"),\n    ],\n)\ndef test_boolify_invalid(value):\n    \"\"\"Test the boolify function.\"\"\"\n    with pytest.raises(ValueError):\n        autocast.boolify(value)\n\n\ndef test_noneify():\n    \"\"\"noneify should return None if the string is None.\"\"\"\n    assert autocast.noneify(\"None\") is None\n    with pytest.raises(ValueError):\n        autocast.noneify(\"0\")", "\n\ndef test_noneify():\n    \"\"\"noneify should return None if the string is None.\"\"\"\n    assert autocast.noneify(\"None\") is None\n    with pytest.raises(ValueError):\n        autocast.noneify(\"0\")\n\n\n@pytest.mark.parametrize(", "\n@pytest.mark.parametrize(\n    \"value,expected\",\n    [\n        param(\"1,2,3,4\", [1, 2, 3, 4], id=\"int\"),\n        param(\"1\\n2\\n3\\n4\", [1, 2, 3, 4], id=\"int\"),\n        param(\"s,t,r\", [\"s\", \"t\", \"r\"], id=\"str\"),\n        param(\"1.1,2,3.14\", [1.1, 2.0, 3.14], id=\"float\"),\n        param(\"True,False,true,false\", [True, False, True, False], id=\"bool\"),\n        param(\"None,None,None\", [None, None, None], id=\"none\"),", "        param(\"True,False,true,false\", [True, False, True, False], id=\"bool\"),\n        param(\"None,None,None\", [None, None, None], id=\"none\"),\n        param(\"\\nNone\\nNone\\nNone\\n\", [None, None, None], id=\"none with extra newlines\"),\n    ],\n)\ndef test_listify_valid(value, expected):\n    \"\"\"Test the listify function.\"\"\"\n    assert autocast.listify(value) == expected\n\n\ndef test_listify_invalid():\n    \"\"\"Every element of the list should be the same type.\"\"\"\n    with pytest.raises(TypeError):\n        autocast.listify(\"True,1,None\")\n\n    with pytest.raises(ValueError):\n        autocast.listify(\"I am not a list\")", "\n\ndef test_listify_invalid():\n    \"\"\"Every element of the list should be the same type.\"\"\"\n    with pytest.raises(TypeError):\n        autocast.listify(\"True,1,None\")\n\n    with pytest.raises(ValueError):\n        autocast.listify(\"I am not a list\")\n", "\n\n@pytest.mark.parametrize(\n    \"value,expected\",\n    [\n        param(\"true\", True, id=\"true\"),\n        param(\"false\", False, id=\"false\"),\n        param(\"True\", True, id=\"True\"),\n        param(\"False\", False, id=\"False\"),\n        param(\"1,2,3,4\", [1, 2, 3, 4], id=\"int-list\"),", "        param(\"False\", False, id=\"False\"),\n        param(\"1,2,3,4\", [1, 2, 3, 4], id=\"int-list\"),\n        param(\"s,t,r\", [\"s\", \"t\", \"r\"], id=\"str-list\"),\n        param(\"1\", 1, id=\"int\"),\n        param(\"1.0\", 1.0, id=\"float\"),\n        param(1, 1, id=\"real-int\"),\n    ],\n)\ndef test_autocast_value(value, expected):\n    \"\"\"Test basic functionality of autocast_value.\"\"\"\n    assert autocast.autocast_value(value) == expected", "def test_autocast_value(value, expected):\n    \"\"\"Test basic functionality of autocast_value.\"\"\"\n    assert autocast.autocast_value(value) == expected\n"]}
{"filename": "tests/test_scm.py", "chunked_list": ["\"\"\"Tests of the VCS module.\"\"\"\nimport subprocess\nfrom pathlib import Path\n\nimport pytest\nfrom pytest import param, LogCaptureFixture\n\nfrom bumpversion import scm\nfrom bumpversion.exceptions import DirtyWorkingDirectoryError\nfrom bumpversion.logging import setup_logging", "from bumpversion.exceptions import DirtyWorkingDirectoryError\nfrom bumpversion.logging import setup_logging\nfrom tests.conftest import get_config_data, inside_dir\n\n\ndef test_git_is_usable(git_repo: Path) -> None:\n    \"\"\"Should return true if git is available, and it is a git repo.\"\"\"\n    with inside_dir(git_repo):\n        assert scm.Git.is_usable()\n", "\n\ndef test_git_is_not_usable(tmp_path: Path) -> None:\n    \"\"\"Should return false if it is not a git repo.\"\"\"\n    with inside_dir(tmp_path):\n        assert not scm.Git.is_usable()\n\n\ndef test_git_asserts_not_dirty(git_repo: Path) -> None:\n    \"\"\"If the git repo is clean, assert_notdirty should return true.\"\"\"\n    with inside_dir(git_repo):\n        scm.Git.assert_nondirty()", "def test_git_asserts_not_dirty(git_repo: Path) -> None:\n    \"\"\"If the git repo is clean, assert_notdirty should return true.\"\"\"\n    with inside_dir(git_repo):\n        scm.Git.assert_nondirty()\n\n\ndef test_git_asserts_dirty(git_repo: Path) -> None:\n    \"\"\"If the git repo has modified files, assert_notdirty should return false.\"\"\"\n    readme = git_repo.joinpath(\"readme.md\")\n    readme.touch()\n    with pytest.raises(DirtyWorkingDirectoryError):\n        with inside_dir(git_repo):\n            subprocess.run([\"git\", \"add\", \"readme.md\"])\n            scm.Git.assert_nondirty()", "\n\ndef test_git_latest_tag_info(git_repo: Path) -> None:\n    \"\"\"Should return information about the latest tag.\"\"\"\n    readme = git_repo.joinpath(\"readme.md\")\n    readme.touch()\n\n    with inside_dir(git_repo):\n        assert scm.Git.latest_tag_info(\"v*\") == scm.SCMInfo(tool=scm.Git)\n\n        # Add a file and tag\n        subprocess.run([\"git\", \"add\", \"readme.md\"])\n        subprocess.run([\"git\", \"commit\", \"-m\", \"first\"])\n        subprocess.run([\"git\", \"tag\", \"v0.1.0\"])\n        tag_info = scm.Git.latest_tag_info(\"v*\")\n        assert tag_info.commit_sha is not None\n        assert tag_info.current_version == \"0.1.0\"\n        assert tag_info.distance_to_latest_tag == 0\n\n        # Make it dirty\n        git_repo.joinpath(\"something.md\").touch()\n        subprocess.run([\"git\", \"add\", \"something.md\"])\n        tag_info = scm.Git.latest_tag_info(\"v*\")\n        assert tag_info.commit_sha is not None\n        assert tag_info.current_version == \"0.1.0\"\n        assert tag_info.distance_to_latest_tag == 0\n        assert tag_info.dirty is True", "\n\ndef test_git_detects_existing_tag(git_repo: Path, caplog: LogCaptureFixture) -> None:\n    \"\"\"Attempting to tag when a tag exists will do nothing.\"\"\"\n    # Arrange\n    git_repo.joinpath(\"readme.md\").touch()\n    git_repo.joinpath(\"something.md\").touch()\n    overrides = {\"current_version\": \"0.1.0\", \"commit\": True, \"tag\": True}\n    context = {\n        \"current_version\": \"0.1.0\",\n        \"new_version\": \"0.2.0\",\n    }\n    setup_logging(2)\n    with inside_dir(git_repo):\n        conf, version_config, current_version = get_config_data(overrides)\n        subprocess.run([\"git\", \"add\", \"readme.md\"])\n        subprocess.run([\"git\", \"commit\", \"-m\", \"first\"])\n        subprocess.run([\"git\", \"tag\", \"v0.1.0\"])\n        subprocess.run([\"git\", \"add\", \"something.md\"])\n        subprocess.run([\"git\", \"commit\", \"-m\", \"second\"])\n        subprocess.run([\"git\", \"tag\", \"v0.2.0\"])\n\n        # Act\n        scm.Git.tag_in_scm(config=conf, context=context)\n\n    # Assert\n    assert \"Will not tag\" in caplog.text", "\n\ndef test_hg_is_not_usable(tmp_path: Path) -> None:\n    \"\"\"Should return false if it is not a mercurial repo.\"\"\"\n    with inside_dir(tmp_path):\n        assert not scm.Mercurial.is_usable()\n\n\ndef test_hg_is_usable(hg_repo: Path) -> None:\n    \"\"\"Should return false if it is not a mercurial repo.\"\"\"\n    with inside_dir(hg_repo):\n        assert scm.Mercurial.is_usable()", "def test_hg_is_usable(hg_repo: Path) -> None:\n    \"\"\"Should return false if it is not a mercurial repo.\"\"\"\n    with inside_dir(hg_repo):\n        assert scm.Mercurial.is_usable()\n\n\n@pytest.mark.parametrize(\n    [\"repo\", \"scm_command\", \"scm_class\"],\n    [\n        param(\"git_repo\", \"git\", scm.Git, id=\"git\"),", "    [\n        param(\"git_repo\", \"git\", scm.Git, id=\"git\"),\n        param(\"hg_repo\", \"hg\", scm.Mercurial, id=\"hg\"),\n    ],\n)\ndef test_commit_and_tag_from_below_scm_root(repo: str, scm_command: str, scm_class: scm.SourceCodeManager, request):\n    # Arrange\n    repo_path: Path = request.getfixturevalue(repo)\n    version_path = repo_path / \"VERSION\"\n    version_path.write_text(\"30.0.3\")\n    sub_dir_path = repo_path / \"subdir\"\n    sub_dir_path.mkdir(exist_ok=True)\n\n    overrides = {\"current_version\": \"30.0.3\", \"commit\": True, \"tag\": True, \"files\": [{\"filename\": str(version_path)}]}\n    context = {\n        \"current_version\": \"30.0.3\",\n        \"new_version\": \"30.1.0\",\n    }\n    with inside_dir(repo_path):\n        conf, version_config, current_version = get_config_data(overrides)\n        subprocess.run([scm_command, \"add\", \"VERSION\"], check=True, capture_output=True)\n        subprocess.run([scm_command, \"commit\", \"-m\", \"initial commit\"], check=True, capture_output=True)\n        with inside_dir(sub_dir_path):\n            version_path.write_text(\"30.1.0\")\n\n            # Act\n            scm_class.commit_to_scm(files=[version_path], config=conf, context=context)\n            scm_class.tag_in_scm(config=conf, context=context)\n\n        # Assert\n        tag_info = scm_class.latest_tag_info(\"v*\")\n        if scm_command == \"git\":\n            assert tag_info.commit_sha is not None\n            assert tag_info.distance_to_latest_tag == 0\n        assert tag_info.current_version == \"30.1.0\"\n        assert tag_info.dirty is False", "\n\n# write tests for no-commit, no-tag and dry-run\n@pytest.mark.parametrize(\n    [\"repo\", \"scm_command\", \"scm_class\"],\n    [\n        param(\"git_repo\", \"git\", scm.Git, id=\"git\"),\n        param(\"hg_repo\", \"hg\", scm.Mercurial, id=\"hg\"),\n    ],\n)", "    ],\n)\n@pytest.mark.parametrize(\n    [\"commit\", \"tag\", \"dry_run\", \"should_commit\", \"should_tag\"],\n    [\n        param(True, True, True, False, False, id=\"dry-run-stops-commit-and-tag\"),\n        param(True, False, False, True, False, id=\"commit-no-tag\"),\n        param(False, True, False, False, False, id=\"no-commit-stops-tag\"),\n    ],\n)\ndef test_commit_tag_dry_run_interactions(\n    repo: str,\n    scm_command: str,\n    scm_class: scm.SourceCodeManager,\n    commit: bool,\n    tag: bool,\n    dry_run: bool,\n    should_commit: bool,\n    should_tag: bool,\n    caplog: LogCaptureFixture,\n    request,\n):\n    \"\"\"Combinations of commit, tag, dry-run and should produce the expected results.\"\"\"\n    # Arrange\n    repo_path: Path = request.getfixturevalue(repo)\n    version_path = repo_path / \"VERSION\"\n    version_path.write_text(\"30.0.3\")\n\n    overrides = {\"current_version\": \"30.0.3\", \"commit\": commit, \"tag\": tag, \"files\": [{\"filename\": str(version_path)}]}\n    context = {\n        \"current_version\": \"30.0.3\",\n        \"new_version\": \"30.1.0\",\n    }\n    with inside_dir(repo_path):\n        conf, version_config, current_version = get_config_data(overrides)\n        subprocess.run([scm_command, \"add\", \"VERSION\"], check=True, capture_output=True)\n        subprocess.run([scm_command, \"commit\", \"-m\", \"initial commit\"], check=True, capture_output=True)\n        version_path.write_text(\"30.1.0\")\n        # Act\n        scm_class.commit_to_scm(files=[version_path], config=conf, context=context, dry_run=dry_run)\n        scm_class.tag_in_scm(config=conf, context=context, dry_run=dry_run)\n\n        # Assert\n        if commit and dry_run:\n            assert \"Would commit\" in caplog.text\n        elif should_commit:\n            assert \"Committing \" in caplog.text\n        else:\n            assert \"Would not commit\" in caplog.text\n\n        if tag and dry_run:\n            assert \"Would tag\" in caplog.text\n        elif should_tag:\n            assert \"Tagging \" in caplog.text\n        else:\n            assert \"Would not tag\" in caplog.text", "    ],\n)\ndef test_commit_tag_dry_run_interactions(\n    repo: str,\n    scm_command: str,\n    scm_class: scm.SourceCodeManager,\n    commit: bool,\n    tag: bool,\n    dry_run: bool,\n    should_commit: bool,\n    should_tag: bool,\n    caplog: LogCaptureFixture,\n    request,\n):\n    \"\"\"Combinations of commit, tag, dry-run and should produce the expected results.\"\"\"\n    # Arrange\n    repo_path: Path = request.getfixturevalue(repo)\n    version_path = repo_path / \"VERSION\"\n    version_path.write_text(\"30.0.3\")\n\n    overrides = {\"current_version\": \"30.0.3\", \"commit\": commit, \"tag\": tag, \"files\": [{\"filename\": str(version_path)}]}\n    context = {\n        \"current_version\": \"30.0.3\",\n        \"new_version\": \"30.1.0\",\n    }\n    with inside_dir(repo_path):\n        conf, version_config, current_version = get_config_data(overrides)\n        subprocess.run([scm_command, \"add\", \"VERSION\"], check=True, capture_output=True)\n        subprocess.run([scm_command, \"commit\", \"-m\", \"initial commit\"], check=True, capture_output=True)\n        version_path.write_text(\"30.1.0\")\n        # Act\n        scm_class.commit_to_scm(files=[version_path], config=conf, context=context, dry_run=dry_run)\n        scm_class.tag_in_scm(config=conf, context=context, dry_run=dry_run)\n\n        # Assert\n        if commit and dry_run:\n            assert \"Would commit\" in caplog.text\n        elif should_commit:\n            assert \"Committing \" in caplog.text\n        else:\n            assert \"Would not commit\" in caplog.text\n\n        if tag and dry_run:\n            assert \"Would tag\" in caplog.text\n        elif should_tag:\n            assert \"Tagging \" in caplog.text\n        else:\n            assert \"Would not tag\" in caplog.text", ""]}
{"filename": "tests/test_functions.py", "chunked_list": ["import pytest\n\nfrom bumpversion.functions import NumericFunction, ValuesFunction\n\n# NumericFunction\n\n\ndef test_numeric_init_wo_first_value():\n    func = NumericFunction()\n    assert func.first_value == \"0\"", "\n\ndef test_numeric_init_w_first_value():\n    func = NumericFunction(first_value=\"5\")\n    assert func.first_value == \"5\"\n\n\ndef test_numeric_init_non_numeric_first_value():\n    with pytest.raises(ValueError):\n        NumericFunction(first_value=\"a\")", "\n\ndef test_numeric_bump_simple_number():\n    func = NumericFunction()\n    assert func.bump(\"0\") == \"1\"\n\n\ndef test_numeric_bump_prefix_and_suffix():\n    func = NumericFunction()\n    assert func.bump(\"v0b\") == \"v1b\"", "\n\n# ValuesFunction\n\n\ndef test_values_init():\n    func = ValuesFunction([\"0\", \"1\", \"2\"])\n    assert func.optional_value == \"0\"\n    assert func.first_value == \"0\"\n", "\n\ndef test_values_init_w_correct_optional_value():\n    func = ValuesFunction([\"0\", \"1\", \"2\"], optional_value=\"1\")\n    assert func.optional_value == \"1\"\n    assert func.first_value == \"0\"\n\n\ndef test_values_init_w_correct_first_value():\n    func = ValuesFunction([\"0\", \"1\", \"2\"], first_value=\"1\")\n    assert func.optional_value == \"0\"\n    assert func.first_value == \"1\"", "def test_values_init_w_correct_first_value():\n    func = ValuesFunction([\"0\", \"1\", \"2\"], first_value=\"1\")\n    assert func.optional_value == \"0\"\n    assert func.first_value == \"1\"\n\n\ndef test_values_init_w_correct_optional_and_first_value():\n    func = ValuesFunction([\"0\", \"1\", \"2\"], optional_value=\"0\", first_value=\"1\")\n    assert func.optional_value == \"0\"\n    assert func.first_value == \"1\"", "\n\ndef test_values_init_w_empty_values():\n    with pytest.raises(ValueError):\n        ValuesFunction([])\n\n\ndef test_values_init_w_incorrect_optional_value():\n    with pytest.raises(ValueError):\n        ValuesFunction([\"0\", \"1\", \"2\"], optional_value=\"3\")", "\n\ndef test_values_init_w_incorrect_first_value():\n    with pytest.raises(ValueError):\n        ValuesFunction([\"0\", \"1\", \"2\"], first_value=\"3\")\n\n\ndef test_values_bump():\n    func = ValuesFunction([\"0\", \"5\", \"10\"])\n    assert func.bump(\"0\") == \"5\"", "\n\ndef test_values_bump_max():\n    func = ValuesFunction([\"0\", \"5\", \"10\"])\n    with pytest.raises(ValueError):\n        func.bump(\"10\")\n"]}
{"filename": "tests/test_bump.py", "chunked_list": ["\"\"\"Tests for the bump module.\"\"\"\nfrom pathlib import Path\nfrom unittest.mock import MagicMock, patch\n\nimport pytest\n\nfrom bumpversion import bump\nfrom bumpversion.exceptions import ConfigurationError\nfrom bumpversion.files import ConfiguredFile\nfrom bumpversion.scm import Git, SCMInfo", "from bumpversion.files import ConfiguredFile\nfrom bumpversion.scm import Git, SCMInfo\nfrom tests.conftest import get_config_data, inside_dir\n\n\n@pytest.fixture\ndef mock_context():\n    return {\"current_version\": \"1.2.3\", \"new_version\": \"1.2.4\"}\n\n\ndef test_get_next_version_with_new_version():\n    \"\"\"Passing a new version should return that version.\"\"\"\n    # Arrange\n    config, version_config, current_version = get_config_data({\"current_version\": \"0.1.0\"})\n    version_part = \"patch\"\n    new_version = \"1.2.3\"\n    expected_next_version = version_config.parse(\"1.2.3\")\n\n    # Act\n    actual_next_version = bump.get_next_version(current_version, config, version_part, new_version)\n\n    # Assert\n    assert actual_next_version == expected_next_version", "\n\ndef test_get_next_version_with_new_version():\n    \"\"\"Passing a new version should return that version.\"\"\"\n    # Arrange\n    config, version_config, current_version = get_config_data({\"current_version\": \"0.1.0\"})\n    version_part = \"patch\"\n    new_version = \"1.2.3\"\n    expected_next_version = version_config.parse(\"1.2.3\")\n\n    # Act\n    actual_next_version = bump.get_next_version(current_version, config, version_part, new_version)\n\n    # Assert\n    assert actual_next_version == expected_next_version", "\n\ndef test_get_next_version_with_version_part():\n    \"\"\"If a version part is provided, it should return the increment of that part.\"\"\"\n    # Arrange\n    config, version_config, current_version = get_config_data({\"current_version\": \"0.1.0\"})\n    version_part = \"major\"\n    new_version = None\n    expected_next_version = version_config.parse(\"1.0.0\")\n\n    # Act\n    actual_next_version = bump.get_next_version(current_version, config, version_part, new_version)\n\n    # Assert\n    assert actual_next_version == expected_next_version", "\n\ndef test_get_next_version_with_no_arguments():\n    # Arrange\n    current_version = MagicMock()\n    config = MagicMock()\n    version_part = None\n    new_version = None\n\n    # Act/Assert\n    with pytest.raises(ConfigurationError):\n        bump.get_next_version(current_version, config, version_part, new_version)", "\n\n@patch(\"bumpversion.files.modify_files\")\n@patch(\"bumpversion.bump.update_config_file\")\ndef test_do_bump_with_version_part(mock_update_config_file, mock_modify_files):\n    # Arrange\n    version_part = \"major\"\n    new_version = None\n    config, version_config, current_version = get_config_data(\n        {\"current_version\": \"1.2.3\", \"files\": [{\"filename\": \"foo.txt\"}, {\"filename\": \"bar.txt\"}]}\n    )\n    config.scm_info = SCMInfo()\n    dry_run = False\n\n    # Act\n    bump.do_bump(version_part, new_version, config, dry_run=dry_run)\n\n    # Assert\n    mock_modify_files.assert_called_once()\n    mock_update_config_file.assert_called_once()\n    assert {f.path for f in mock_modify_files.call_args[0][0]} == {\n        \"foo.txt\",\n        \"bar.txt\",\n    }\n    assert mock_update_config_file.call_args[0][0] is None\n    assert mock_update_config_file.call_args[0][1] == config.current_version\n    assert mock_update_config_file.call_args[0][2] == \"2.0.0\"\n    assert mock_update_config_file.call_args[0][3] is False", "\n\n@patch(\"bumpversion.files.modify_files\")\n@patch(\"bumpversion.bump.update_config_file\")\ndef test_do_bump_with_new_version(mock_update_config_file, mock_modify_files):\n    # Arrange\n    version_part = None\n    new_version = \"2.0.0\"\n    config, version_config, current_version = get_config_data(\n        {\n            \"current_version\": \"1.2.3\",\n        }\n    )\n    config.scm_info = SCMInfo()\n    dry_run = True\n\n    # Act\n    bump.do_bump(version_part, new_version, config, dry_run=dry_run)\n\n    # Assert\n    mock_modify_files.assert_called_once()\n    assert mock_modify_files.call_args[0][0] == []\n    assert mock_modify_files.call_args[0][1] == current_version\n    assert mock_modify_files.call_args[0][2] == version_config.parse(new_version)\n\n    mock_update_config_file.assert_called_once()\n    assert mock_update_config_file.call_args[0][0] is None\n    assert mock_update_config_file.call_args[0][1] is config.current_version\n    assert mock_update_config_file.call_args[0][2] == \"2.0.0\"\n    assert mock_update_config_file.call_args[0][3] is True", "\n\n@patch(\"bumpversion.files.modify_files\")\n@patch(\"bumpversion.bump.update_config_file\")\ndef test_do_bump_when_new_equals_current(mock_update_config_file, mock_modify_files, tmp_path: Path):\n    \"\"\"When the new version is the same as the current version, nothing should happen.\"\"\"\n\n    # Arrange\n    version_part = None\n    new_version = \"1.2.3\"\n\n    with inside_dir(tmp_path):\n        config, version_config, current_version = get_config_data({\"current_version\": \"1.2.3\"})\n        # Act\n        bump.do_bump(version_part, new_version, config)\n\n    # Assert\n    mock_modify_files.assert_not_called()\n    mock_update_config_file.assert_not_called()", "\n\ndef test_do_bump_with_no_arguments():\n    # Arrange\n    version_part = None\n    new_version = None\n    config, version_config, current_version = get_config_data({\"current_version\": \"1.2.3\"})\n    config.scm_info = SCMInfo()\n    dry_run = False\n\n    # Act/Assert\n    with pytest.raises(ConfigurationError):\n        bump.do_bump(version_part, new_version, config, dry_run=dry_run)", "\n\ndef test_commit_and_tag_with_no_tool():\n    config, version_config, current_version = get_config_data(\n        {\n            \"current_version\": \"1.2.3\",\n        }\n    )\n    config.scm_info = SCMInfo()\n    mock_context = MagicMock()\n\n    bump.commit_and_tag(config, None, [], mock_context, False)", "\n\ndef test_commit_and_tag_with_tool(mock_context):\n    config, version_config, current_version = get_config_data(\n        {\"current_version\": \"1.2.3\", \"files\": [{\"filename\": \"foo.txt\"}, {\"filename\": \"bar.txt\"}]}\n    )\n    config.scm_info = SCMInfo()\n    config.scm_info.tool = MagicMock(spec=Git)\n    configured_files = [ConfiguredFile(file_cfg, version_config) for file_cfg in config.files]\n    bump.commit_and_tag(config, None, configured_files, mock_context, False)\n    config.scm_info.tool.commit_to_scm.assert_called_once()\n    config.scm_info.tool.tag_in_scm.assert_called_once()\n    assert set(config.scm_info.tool.commit_to_scm.call_args[0][0]) == {\"foo.txt\", \"bar.txt\"}", "\n\ndef test_commit_and_tag_with_config_file(mock_context):\n    config, version_config, current_version = get_config_data(\n        {\"current_version\": \"1.2.3\", \"files\": [{\"filename\": \"foo.txt\"}, {\"filename\": \"bar.txt\"}]}\n    )\n    config.scm_info = SCMInfo()\n    config.scm_info.tool = MagicMock(spec=Git)\n    configured_files = [ConfiguredFile(file_cfg, version_config) for file_cfg in config.files]\n    bump.commit_and_tag(config, Path(\"pyproject.toml\"), configured_files, mock_context, False)\n    config.scm_info.tool.commit_to_scm.assert_called_once()\n    config.scm_info.tool.tag_in_scm.assert_called_once()\n    assert set(config.scm_info.tool.commit_to_scm.call_args[0][0]) == {\"foo.txt\", \"bar.txt\", \"pyproject.toml\"}", ""]}
{"filename": "tests/test_files.py", "chunked_list": ["\"\"\"File processing tests.\"\"\"\nimport os\nfrom datetime import datetime, timezone\nfrom pathlib import Path\nfrom textwrap import dedent\n\nimport pytest\nfrom pytest import param\n\nfrom bumpversion import exceptions, files", "\nfrom bumpversion import exceptions, files\nfrom bumpversion.utils import get_context\nfrom bumpversion.exceptions import VersionNotFoundError\nfrom tests.conftest import get_config_data, inside_dir\n\n\n@pytest.mark.parametrize(\n    [\"glob_pattern\", \"file_list\"],\n    [", "    [\"glob_pattern\", \"file_list\"],\n    [\n        param(\"*.txt\", {Path(\"file1.txt\"), Path(\"file2.txt\")}, id=\"simple-glob\"),\n        param(\"**/*.txt\", {Path(\"file1.txt\"), Path(\"file2.txt\"), Path(\"directory/file3.txt\")}, id=\"recursive-glob\"),\n    ],\n)\ndef test_get_glob_files(glob_pattern: str, file_list: set, fixtures_path: Path):\n    \"\"\"Get glob files should return all the globbed files and nothing else.\"\"\"\n    overrides = {\n        \"current_version\": \"1.0.0\",\n        \"parse\": r\"(?P<major>\\d+)\\.(?P<minor>\\d+)(\\.(?P<release>[a-z]+))?\",\n        \"serialize\": [\"{major}.{minor}.{release}\", \"{major}.{minor}\"],\n        \"files\": [\n            {\n                \"glob\": glob_pattern,\n            }\n        ],\n    }\n    conf, version_config, current_version = get_config_data(overrides)\n    with inside_dir(fixtures_path.joinpath(\"glob\")):\n        result = files.get_glob_files(conf.files[0], version_config)\n\n    assert len(result) == len(file_list)\n    for f in result:\n        assert Path(f.path) in file_list", "\n\ndef test_single_file_processed_twice(tmp_path: Path):\n    \"\"\"\n    Verify that a single file \"file2\" can be processed twice.\n\n    Use two file_ entries, both with a different suffix after\n    the underscore.\n    Employ different parse/serialize and search/replace configs\n    to verify correct interpretation.\n    \"\"\"\n    filepath = tmp_path.joinpath(\"file2\")\n    filepath.write_text(\"dots: 0.10.2\\ndashes: 0-10-2\")\n    overrides = {\n        \"current_version\": \"0.10.2\",\n        \"files\": [\n            {\n                \"filename\": str(filepath),\n                \"search\": \"dots: {current_version}\",\n                \"replace\": \"dots: {new_version}\",\n            },\n            {\n                \"filename\": str(filepath),\n                \"search\": \"dashes: {current_version}\",\n                \"replace\": \"dashes: {new_version}\",\n                \"parse\": r\"(?P<major>\\d+)-(?P<minor>\\d+)-(?P<patch>\\d+)\",\n                \"serialize\": [\"{major}-{minor}-{patch}\"],\n            },\n        ],\n    }\n    conf, version_config, current_version = get_config_data(overrides)\n    new_version = current_version.bump(\"patch\", version_config.order)\n    ctx = get_context(conf)\n\n    assert len(conf.files) == 2\n    for file_cfg in conf.files:\n        cfg_file = files.ConfiguredFile(file_cfg, version_config)\n        cfg_file.replace_version(current_version, new_version, ctx)\n\n    assert filepath.read_text() == \"dots: 0.10.3\\ndashes: 0-10-3\"", "\n\ndef test_multi_file_configuration(tmp_path: Path):\n    full_vers_path = tmp_path / \"FULL_VERSION.txt\"\n    full_vers_path.write_text(\"1.0.3\")\n    maj_vers_path = tmp_path / \"MAJOR_VERSION.txt\"\n    maj_vers_path.write_text(\"1\")\n    readme_path = tmp_path / \"README.txt\"\n    readme_path.write_text(\"MyAwesomeSoftware(TM) v1.0\")\n    build_num_path = tmp_path / \"BUILD_NUMBER\"\n    build_num_path.write_text(\"1.0.3+joe+38943\")\n\n    overrides = {\n        \"current_version\": \"1.0.3+joe+38943\",\n        \"parse\": r\"(?P<major>\\d+)\\.(?P<minor>\\d+)\\.(?P<patch>\\d+)(?:\\+.*)?\",\n        \"serialize\": [\n            \"{major}.{minor}.{patch}+{$USER}+{$BUILD_NUMBER}\",\n            \"{major}.{minor}.{patch}\",\n        ],\n        \"files\": [\n            {\n                \"filename\": str(full_vers_path),\n            },\n            {\n                \"filename\": str(maj_vers_path),\n                \"parse\": r\"\\d+\",\n                \"serialize\": [\"{major}\"],\n            },\n            {\n                \"filename\": str(readme_path),\n                \"parse\": r\"(?P<major>\\d+)\\.(?P<minor>\\d+)\",\n                \"serialize\": [\"{major}.{minor}\"],\n            },\n            {\n                \"filename\": str(build_num_path),\n                \"serialize\": [\"{major}.{minor}.{patch}+{$USER}+{$BUILD_NUMBER}\"],\n            },\n        ],\n    }\n    conf, version_config, current_version = get_config_data(overrides)\n    major_version = current_version.bump(\"major\", version_config.order)\n\n    os.environ[\"BUILD_NUMBER\"] = \"38944\"\n    os.environ[\"USER\"] = \"bob\"\n    ctx = get_context(conf)\n    del os.environ[\"BUILD_NUMBER\"]\n    del os.environ[\"USER\"]\n\n    for file_cfg in conf.files:\n        cfg_file = files.ConfiguredFile(file_cfg, version_config)\n        cfg_file.replace_version(current_version, major_version, ctx)\n\n    assert full_vers_path.read_text() == \"2.0.0\"\n    assert maj_vers_path.read_text() == \"2\"\n    assert readme_path.read_text() == \"MyAwesomeSoftware(TM) v2.0\"\n    assert build_num_path.read_text() == \"2.0.0+bob+38944\"\n\n    os.environ[\"BUILD_NUMBER\"] = \"38945\"\n    os.environ[\"USER\"] = \"jane\"\n    conf.current_version = \"2.0.0+bob+38944\"\n    ctx = get_context(conf)\n    del os.environ[\"BUILD_NUMBER\"]\n    del os.environ[\"USER\"]\n    major_version = version_config.parse(conf.current_version)\n    major_patch_version = major_version.bump(\"patch\", version_config.order)\n    for file_cfg in conf.files:\n        cfg_file = files.ConfiguredFile(file_cfg, version_config)\n        cfg_file.replace_version(major_version, major_patch_version, ctx)\n\n    assert full_vers_path.read_text() == \"2.0.1\"\n    assert maj_vers_path.read_text() == \"2\"\n    assert readme_path.read_text() == \"MyAwesomeSoftware(TM) v2.0\"\n    assert build_num_path.read_text() == \"2.0.1+jane+38945\"", "\n\ndef test_raises_correct_missing_version_string(tmp_path: Path):\n    full_vers_path = tmp_path / \"FULL_VERSION.txt\"\n    full_vers_path.write_text(\"3.1.0-rc+build.1031\")\n    assembly_path = tmp_path / \"AssemblyInfo.cs\"\n    assembly_path.write_text(\n        '[assembly: AssemblyFileVersion(\"3.1.0-rc+build.1031\")]\\n' '[assembly: AssemblyVersion(\"3.1.1031.0\")]'\n    )\n    csv_path = tmp_path / \"Version.csv\"\n    csv_path.write_text(\"1;3-1;0;rc;build.1031\")\n\n    overrides = {\n        \"current_version\": \"3.1.0-rc+build.1031\",\n        \"parse\": r\"(?P<major>\\d+)\\.(?P<minor>\\d+)\\.(?P<patch>\\d+)(-(?P<release>[0-9A-Za-z]+))?(\\+build\\.(?P<build>.[0-9A-Za-z]+))?\",\n        \"serialize\": [\"{major}.{minor}.{patch}-{release}+build.{build}\", \"{major}.{minor}.{patch}+build.{build}\"],\n        \"commit\": True,\n        \"message\": \"Bump version: {current_version} -> {new_version}\",\n        \"tag\": False,\n        \"tag_name\": \"{new_version}\",\n        \"tag_message\": \"Version {new_version}\",\n        \"allow_dirty\": True,\n        \"files\": [\n            {\n                \"filename\": str(full_vers_path),\n            },\n            {\n                \"filename\": str(assembly_path),\n                \"search\": '[assembly: AssemblyFileVersion(\"{current_version}\")]',\n                \"replace\": '[assembly: AssemblyFileVersion(\"{new_version}\")]',\n            },\n            {\n                \"filename\": str(assembly_path),\n                \"parse\": r\"(?P<major>\\d+)\\.(?P<minor>\\d+)\\.(?P<build>\\d+)\\.(?P<patch>\\d+)\",\n                \"serialize\": [\"{major}.{minor}.{build}.{patch}\"],\n                \"search\": '[assembly: AssemblyVersion(\"{current_version}\")]',\n                \"replace\": '[assembly: AssemblyVersion(\"{new_version}\")]',\n            },\n            {\n                \"filename\": str(csv_path),\n                \"parse\": r\"(?P<major>\\d+);(?P<minor>\\d+);(?P<patch>\\d+);(?P<release>[0-9A-Za-z]+)?;(build\\.(?P<build>.[0-9A-Za-z]+))?\",\n                \"serialize\": [\n                    \"{major};{minor};{patch};{release};build.{build}\",\n                    \"{major};{minor};{patch};;build.{build}\",\n                ],\n                \"search\": \"1;{current_version}\",\n                \"replace\": \"1;{new_version}\",\n            },\n        ],\n        \"parts\": {\n            \"release\": {\"values\": [\"beta\", \"rc\", \"final\"], \"optional_value\": \"final\"},\n            \"build\": {\n                \"first_value\": 1000,\n                \"independent\": True,\n            },\n        },\n    }\n    conf, version_config, current_version = get_config_data(overrides)\n    major_version = current_version.bump(\"patch\", version_config.order)\n\n    ctx = get_context(conf)\n\n    configured_files = [files.ConfiguredFile(file_cfg, version_config) for file_cfg in conf.files]\n\n    with pytest.raises(VersionNotFoundError) as e:\n        files.modify_files(configured_files, current_version, major_version, ctx)\n        assert e.message.startswith(\"Did not find '1;3;1;0;rc;build.1031'\")", "\n\ndef test_search_replace_to_avoid_updating_unconcerned_lines(tmp_path: Path):\n    req_path = tmp_path / \"requirements.txt\"\n    req_path.write_text(\"Django>=1.5.6,<1.6\\nMyProject==1.5.6\")\n\n    changelog_path = tmp_path / \"CHANGELOG.md\"\n    changelog_path.write_text(\n        dedent(\n            \"\"\"\n    # https://keepachangelog.com/en/1.0.0/\n\n    ## [Unreleased]\n    ### Added\n    - Foobar\n\n    ## [0.0.1] - 2014-05-31\n    ### Added\n    - This CHANGELOG file to hopefully serve as an evolving example of a\n      standardized open source project CHANGELOG.\n    \"\"\"\n        )\n    )\n\n    overrides = {\n        \"current_version\": \"1.5.6\",\n        \"files\": [\n            {\n                \"filename\": str(req_path),\n                \"search\": \"MyProject=={current_version}\",\n                \"replace\": \"MyProject=={new_version}\",\n            },\n            {\n                \"filename\": str(changelog_path),\n                \"search\": \"## [Unreleased]\",\n                \"replace\": \"## [Unreleased]\\n\\n## [{new_version}] - {utcnow:%Y-%m-%d}\",\n            },\n        ],\n    }\n\n    conf, version_config, current_version = get_config_data(overrides)\n    new_version = current_version.bump(\"minor\", version_config.order)\n\n    for file_cfg in conf.files:\n        cfg_file = files.ConfiguredFile(file_cfg, version_config)\n        cfg_file.replace_version(current_version, new_version, get_context(conf))\n\n    utc_today = datetime.now(timezone.utc).strftime(\"%Y-%m-%d\")\n    expected_chglog = dedent(\n        f\"\"\"\n    # https://keepachangelog.com/en/1.0.0/\n\n    ## [Unreleased]\n\n    ## [1.6.0] - {utc_today}\n    ### Added\n    - Foobar\n\n    ## [0.0.1] - 2014-05-31\n    ### Added\n    - This CHANGELOG file to hopefully serve as an evolving example of a\n      standardized open source project CHANGELOG.\n    \"\"\"\n    )\n\n    assert req_path.read_text() == \"Django>=1.5.6,<1.6\\nMyProject==1.6.0\"\n    assert changelog_path.read_text() == expected_chglog", "\n\ndef test_non_matching_search_does_not_modify_file(tmp_path: Path):\n    changelog_path = tmp_path / \"CHANGELOG.md\"\n    changelog_content = dedent(\n        \"\"\"\n    # Unreleased\n\n    * bullet point A\n\n    # Release v'older' (2019-09-17)\n\n    * bullet point B\n    \"\"\"\n    )\n    changelog_path.write_text(changelog_content)\n\n    overrides = {\n        \"current_version\": \"1.0.3\",\n        \"files\": [\n            {\n                \"filename\": str(changelog_path),\n                \"search\": \"Not-yet-released\",\n                \"replace\": \"Release v{new_version} ({now:%Y-%m-%d})\",\n            }\n        ],\n    }\n    conf, version_config, current_version = get_config_data(overrides)\n    new_version = current_version.bump(\"patch\", version_config.order)\n    configured_files = files.resolve_file_config(conf.files, version_config)\n    with pytest.raises(exceptions.VersionNotFoundError, match=\"Did not find 'Not-yet-released' in file:\"):\n        files.modify_files(configured_files, current_version, new_version, get_context(conf))\n\n    assert changelog_path.read_text() == changelog_content", "\n\ndef test_simple_replacement_in_utf8_file(tmp_path: Path):\n    \"\"\"Changing a file in UTF-8 should not change the non-ASCII characters.\"\"\"\n    # Arrange\n    version_path = tmp_path / \"VERSION\"\n    version_path.write_bytes(\"Kr\u00f6t1.3.0\".encode(\"utf-8\"))\n\n    overrides = {\"current_version\": \"1.3.0\", \"files\": [{\"filename\": str(version_path)}]}\n    with inside_dir(tmp_path):\n        conf, version_config, current_version = get_config_data(overrides)\n        new_version = current_version.bump(\"patch\", version_config.order)\n\n    # Act\n    for file_cfg in conf.files:\n        cfg_file = files.ConfiguredFile(file_cfg, version_config)\n        cfg_file.replace_version(current_version, new_version, get_context(conf))\n\n    # Assert\n    out = version_path.read_text()\n    assert out == \"Kr\u00f6t1.3.1\"", "\n\ndef test_multi_line_search_is_found(tmp_path: Path) -> None:\n    \"\"\"A multiline search string is found and replaced.\"\"\"\n    # Arrange\n    alphabet_path = tmp_path / \"the_alphabet.txt\"\n    alphabet_path.write_text(\"A\\nB\\nC\\n\")\n\n    overrides = {\n        \"current_version\": \"9.8.7\",\n        \"search\": \"A\\nB\\nC\",\n        \"replace\": \"A\\nB\\nC\\n{new_version}\",\n        \"files\": [{\"filename\": str(alphabet_path)}],\n    }\n    with inside_dir(tmp_path):\n        conf, version_config, current_version = get_config_data(overrides)\n        new_version = current_version.bump(\"major\", version_config.order)\n\n    # Act\n    for file_cfg in conf.files:\n        cfg_file = files.ConfiguredFile(file_cfg, version_config)\n        cfg_file.replace_version(current_version, new_version, get_context(conf))\n\n    # Assert\n    assert alphabet_path.read_text() == \"A\\nB\\nC\\n10.0.0\\n\"", "\n\ndef test_ignore_missing_version(tmp_path: Path) -> None:\n    \"\"\"If the version is not found in the file, do nothing.\"\"\"\n    # Arrange\n    version_path = tmp_path / Path(\"VERSION\")\n    version_path.write_text(\"1.2.3\")\n\n    overrides = {\n        \"current_version\": \"1.2.5\",\n        \"ignore_missing_version\": True,\n        \"files\": [{\"filename\": str(version_path)}],\n    }\n    conf, version_config, current_version = get_config_data(overrides)\n    assert conf.ignore_missing_version is True\n    new_version = current_version.bump(\"patch\", version_config.order)\n    cfg_files = [files.ConfiguredFile(file_cfg, version_config) for file_cfg in conf.files]\n\n    # Act\n    files.modify_files(cfg_files, current_version, new_version, get_context(conf))\n\n    # Assert\n    assert version_path.read_text() == \"1.2.3\"", ""]}
{"filename": "tests/__init__.py", "chunked_list": ["\"\"\"Unit test package for bumpversion.\"\"\"\n"]}
{"filename": "tests/test_config.py", "chunked_list": ["\"\"\"Test configuration parsing.\"\"\"\nimport difflib\nimport json\nfrom pathlib import Path\nfrom textwrap import dedent\n\nimport pytest\nfrom click.testing import CliRunner, Result\nfrom pytest import param\n", "from pytest import param\n\nfrom bumpversion import config\nfrom tests.conftest import inside_dir\n\n\n@pytest.fixture(params=[\".bumpversion.cfg\", \"setup.cfg\"])\ndef cfg_file(request) -> str:\n    \"\"\"Return both config-file styles ('.bumpversion.cfg', 'setup.cfg').\"\"\"\n    return request.param", "\n\n@pytest.fixture(\n    params=[\n        \"file\",\n        \"file(suffix)\",\n        \"file (suffix with space)\",\n        \"file (suffix lacking closing paren\",\n    ]\n)\ndef cfg_file_keyword(request):\n    \"\"\"Return multiple possible styles for the bumpversion:file keyword.\"\"\"\n    return request.param", "    ]\n)\ndef cfg_file_keyword(request):\n    \"\"\"Return multiple possible styles for the bumpversion:file keyword.\"\"\"\n    return request.param\n\n\n@pytest.mark.parametrize(\n    [\"conf_file\", \"expected_file\"],\n    [", "    [\"conf_file\", \"expected_file\"],\n    [\n        param(\"basic_cfg.cfg\", \"basic_cfg_expected.json\", id=\"ini basic cfg\"),\n    ],\n)\ndef test_read_ini_file(conf_file: str, expected_file: str, fixtures_path: Path) -> None:\n    \"\"\"Parsing the config file should match the expected results.\"\"\"\n    result = config.read_ini_file(fixtures_path.joinpath(conf_file))\n    expected = json.loads(fixtures_path.joinpath(expected_file).read_text())\n    assert result == expected", "\n\n@pytest.mark.parametrize(\n    [\"conf_file\", \"expected_file\"],\n    [\n        param(\"basic_cfg.toml\", \"basic_cfg_expected.json\", id=\"toml basic cfg\"),\n    ],\n)\ndef test_read_toml_file(conf_file: str, expected_file: str, fixtures_path: Path) -> None:\n    \"\"\"Parsing the config file should match the expected results.\"\"\"\n    result = config.read_toml_file(fixtures_path.joinpath(conf_file))\n    expected = json.loads(fixtures_path.joinpath(expected_file).read_text())\n    assert result == expected", "def test_read_toml_file(conf_file: str, expected_file: str, fixtures_path: Path) -> None:\n    \"\"\"Parsing the config file should match the expected results.\"\"\"\n    result = config.read_toml_file(fixtures_path.joinpath(conf_file))\n    expected = json.loads(fixtures_path.joinpath(expected_file).read_text())\n    assert result == expected\n\n\ndef test_independent_falsy_value_in_config_does_not_bump_independently(tmp_path: Path):\n    # tmp_path.joinpath(\"VERSION\").write_text(\"2.1.0-5123\")\n    config_file = tmp_path.joinpath(\".bumpversion.cfg\")\n    config_file.write_text(\n        dedent(\n            r\"\"\"\n        [bumpversion]\n        current_version: 2.1.0-5123\n        parse = (?P<major>\\d+)\\.(?P<minor>\\d+)\\.(?P<patch>\\d+)\\-(?P<build>\\d+)\n        serialize = {major}.{minor}.{patch}-{build}\n\n        [bumpversion:file:VERSION]\n\n        [bumpversion:part:build]\n        independent = 0\n        \"\"\"\n        )\n    )\n\n    conf = config.get_configuration(config_file)\n    assert conf.parts[\"build\"].independent is False", "\n\ndef test_correct_interpolation_for_setup_cfg_files(tmp_path: Path, fixtures_path: Path):\n    \"\"\"\n    Reported here: https://github.com/c4urself/bump2version/issues/21.\n    \"\"\"\n    test_fixtures_path = fixtures_path.joinpath(\"interpolation\")\n    setup_cfg = config.get_configuration(test_fixtures_path.joinpath(\"setup.cfg\"))\n    bumpversion_cfg = config.get_configuration(test_fixtures_path.joinpath(\".bumpversion.cfg\"))\n    pyproject_toml = config.get_configuration(test_fixtures_path.joinpath(\"pyproject.toml\"))\n\n    assert setup_cfg.replace == \"{now:%m-%d-%Y} v. {new_version}\"\n    assert bumpversion_cfg.replace == \"{now:%m-%d-%Y} v. {new_version}\"\n    assert pyproject_toml.replace == \"{now:%m-%d-%Y} v. {new_version}\"", "\n\ndef test_file_keyword_with_suffix_is_accepted(tmp_path: Path, cfg_file: str, cfg_file_keyword: str):\n    cfg_file_path = tmp_path / cfg_file\n    cfg_file_path.write_text(\n        \"[bumpversion]\\n\"\n        \"current_version = 0.10.2\\n\"\n        \"new_version = 0.10.3\\n\"\n        \"[bumpversion:file (foobar):file2]\\n\"\n        \"search = version {current_version}\\n\"\n        \"replace = version {new_version}\\n\"\n        f\"[bumpversion:{cfg_file_keyword}:file2]\\n\"\n        \"search = The current version is {current_version}\\n\"\n        \"replace = The current version is {new_version}\\n\"\n    )\n    setup_cfg = config.get_configuration(cfg_file_path)\n    assert len(setup_cfg.files) == 2\n    assert all(f.filename == \"file2\" for f in setup_cfg.files)", "\n\ndef test_multiple_config_files(tmp_path: Path):\n    \"\"\"If there are multiple config files, the first one with content wins.\"\"\"\n    setup_cfg = tmp_path / \"setup.cfg\"\n    setup_cfg.write_text(\"[metadata]\\nname: just-a-name\\n\")\n    bumpversion_cfg = tmp_path / \".bumpversion.cfg\"\n    bumpversion_cfg.write_text(\"\\n\")\n    pyproject_toml = tmp_path / \"pyproject.toml\"\n    pyproject_toml.write_text(\n        \"[tool.bumpversion]\\n\"\n        'current_version = \"0.10.5\"\\n'\n        'parse = \"(?P<major>\\\\\\\\d+)\\\\\\\\.(?P<minor>\\\\\\\\d+)\\\\\\\\.(?P<patch>\\\\\\\\d+)(\\\\\\\\-(?P<release>[a-z]+))?\"\\n'\n        \"serialize = [\\n\"\n        '    \"{major}.{minor}.{patch}-{release}\",\\n'\n        '    \"{major}.{minor}.{patch}\"\\n'\n        \"]\\n\"\n    )\n    with inside_dir(tmp_path):\n        cfg_file = config.find_config_file()\n        cfg = config.get_configuration(cfg_file)\n\n    assert cfg.current_version == \"0.10.5\"\n    assert cfg.parse == \"(?P<major>\\\\d+)\\\\.(?P<minor>\\\\d+)\\\\.(?P<patch>\\\\d+)(\\\\-(?P<release>[a-z]+))?\"\n    assert cfg.serialize == [\"{major}.{minor}.{patch}-{release}\", \"{major}.{minor}.{patch}\"]", "\n\ndef test_utf8_message_from_config_file(tmp_path: Path, cfg_file):\n    cfg_path = tmp_path / cfg_file\n    initial_config = (\n        \"[bumpversion]\\n\"\n        \"current_version = 500.0.0\\n\"\n        \"commit = True\\n\"\n        \"message = Nov\u00e1 verze: {current_version} \u2603, {new_version} \u2600\\n\"\n    )\n    cfg_path.write_bytes(initial_config.encode(\"utf-8\"))\n\n    with inside_dir(tmp_path):\n        cfg = config.get_configuration(cfg_path)\n\n    assert cfg.message == \"Nov\u00e1 verze: {current_version} \u2603, {new_version} \u2600\"", "\n\nCFG_EXPECTED_DIFF = (\n    \"*** \\n\"\n    \"--- \\n\"\n    \"***************\\n\"\n    \"*** 11 ****\\n\"\n    \"! current_version = 1.0.0\\n\"\n    \"--- 11 ----\\n\"\n    \"! current_version = 1.0.1\\n\"", "    \"--- 11 ----\\n\"\n    \"! current_version = 1.0.1\\n\"\n)\n\nTOML_EXPECTED_DIFF = (\n    \"*** \\n\"\n    \"--- \\n\"\n    \"***************\\n\"\n    \"*** 23 ****\\n\"\n    '! current_version = \"1.0.0\"\\n'", "    \"*** 23 ****\\n\"\n    '! current_version = \"1.0.0\"\\n'\n    \"--- 23 ----\\n\"\n    '! current_version = \"1.0.1\"\\n'\n)\n\n\n@pytest.mark.parametrize(\n    [\"cfg_file_name\", \"expected_diff\"],\n    [", "    [\"cfg_file_name\", \"expected_diff\"],\n    [\n        (\".bumpversion.cfg\", CFG_EXPECTED_DIFF),\n        (\"setup.cfg\", CFG_EXPECTED_DIFF),\n        (\"pyproject.toml\", TOML_EXPECTED_DIFF),\n    ],\n)\ndef test_update_config_file(tmp_path: Path, cfg_file_name: str, expected_diff: str, fixtures_path: Path) -> None:\n    \"\"\"\n    Make sure only the version string is updated in the config file.\n    \"\"\"\n    cfg_path = tmp_path / cfg_file_name\n    orig_path = fixtures_path / f\"basic_cfg{cfg_path.suffix}\"\n    cfg_path.write_text(orig_path.read_text())\n    original_content = orig_path.read_text().splitlines(keepends=True)\n\n    config.update_config_file(cfg_path, \"1.0.0\", \"1.0.1\")\n    new_content = cfg_path.read_text().splitlines(keepends=True)\n    difference = difflib.context_diff(original_content, new_content, n=0)\n    assert \"\".join(difference) == expected_diff", "\n\ndef test_pep440_config(git_repo: Path, fixtures_path: Path):\n    \"\"\"\n    Check the PEP440 config file.\n    \"\"\"\n    from bumpversion.utils import get_context\n    from bumpversion.bump import get_next_version\n    from bumpversion import cli\n    import subprocess\n\n    # Arrange\n\n    cfg_path = git_repo / \"pyproject.toml\"\n    orig_path = fixtures_path / \"pep440.toml\"\n    cfg_path.write_text(orig_path.read_text())\n    version_path = git_repo / \"VERSION\"\n    version_path.write_text(\"1.0.0\")\n    readme_path = git_repo / \"README.md\"\n    runner: CliRunner = CliRunner()\n\n    with inside_dir(git_repo):\n        subprocess.run([\"git\", \"add\", \"VERSION\"], check=True, capture_output=True)\n        subprocess.run([\"git\", \"commit\", \"-m\", \"initial commit\"], check=True, capture_output=True)\n        subprocess.run([\"git\", \"tag\", \"v1.0.0\"], check=True, capture_output=True)\n\n        cfg = config.get_configuration(cfg_path)\n        ctx = get_context(cfg)\n        version = cfg.version_config.parse(cfg.current_version)\n        next_version = get_next_version(version, cfg, \"patch\", None)\n        next_version_str = cfg.version_config.serialize(next_version, ctx)\n        assert next_version_str == \"1.0.1\"\n\n        subprocess.run([\"git\", \"checkout\", \"-b\", \"my-really-LONG-branch_name\"], check=True, capture_output=True)\n        readme_path.write_text(\"This is my branch!\")\n        result: Result = runner.invoke(cli.cli, [\"bump\", \"dev_label\", \"--no-tag\"])\n        assert result.exit_code == 0\n        cfg = config.get_configuration(cfg_path)\n        assert cfg.current_version == \"1.0.0.dev0+myreallylongbranchna\"", "\n        # try:\n        #     subprocess.run([\"git\", \"add\", \"README.md\"], check=True, capture_output=True)\n        #     subprocess.run([\"git\", \"commit\", \"-am\", \"my branch commit\"], check=True, capture_output=True)\n        # except subprocess.CalledProcessError as e:\n        #     print(e.stdout)\n        #     print(e.stderr)\n        #     raise\n        # result: Result = runner.invoke(cli.cli, [\"bump\", \"dev_label\", \"--no-tag\"])\n        # assert result.exit_code == 0", "        # result: Result = runner.invoke(cli.cli, [\"bump\", \"dev_label\", \"--no-tag\"])\n        # assert result.exit_code == 0\n        # cfg = config.get_configuration(cfg_path)\n        # assert cfg.current_version == \"1.0.0.dev1+myreallylongbranchna\"\n"]}
{"filename": "tests/test_version_part.py", "chunked_list": ["from pathlib import Path\n\nimport pytest\nfrom click import UsageError\nfrom pytest import LogCaptureFixture, param\n\nfrom bumpversion import config, exceptions\nfrom bumpversion.utils import get_context\nfrom bumpversion.version_part import VersionPart\nfrom tests.conftest import get_config_data, inside_dir", "from bumpversion.version_part import VersionPart\nfrom tests.conftest import get_config_data, inside_dir\n\n\n@pytest.fixture(\n    params=[\n        None,\n        (\"0\", \"1\", \"2\"),\n        (\"0\", \"3\"),\n    ]", "        (\"0\", \"3\"),\n    ]\n)\ndef version_part_config(request):\n    \"\"\"Return a three-part and a two-part version part configuration.\"\"\"\n    if request.param is None:\n        return config.VersionPartConfig()\n    else:\n        return config.VersionPartConfig(values=request.param)\n", "\n\ndef test_version_part_init(version_part_config):\n    vp = VersionPart(version_part_config, version_part_config.first_value)\n    assert vp.value is not None\n\n\ndef test_version_part_copy(version_part_config):\n    vp = VersionPart(version_part_config, version_part_config.first_value)\n    vc = vp.copy()\n    assert vp.value == vc.value\n    assert id(vp) != id(vc)", "\n\ndef test_version_part_bump(version_part_config):\n    vp = VersionPart(version_part_config, version_part_config.first_value)\n    vc = vp.bump()\n    if version_part_config.values:\n        assert vc.value == str(version_part_config.values[1])\n    else:\n        assert vc.value == \"1\"\n", "\n\ndef test_version_part_check_optional_false(version_part_config):\n    assert not VersionPart(version_part_config, version_part_config.first_value).bump().is_optional\n\n\ndef test_version_part_check_optional_true(version_part_config):\n    assert VersionPart(version_part_config, version_part_config.first_value).is_optional\n\n\ndef test_version_part_equality(version_part_config):\n    assert VersionPart(version_part_config, version_part_config.first_value) == VersionPart(\n        version_part_config, version_part_config.first_value\n    )", "\n\ndef test_version_part_equality(version_part_config):\n    assert VersionPart(version_part_config, version_part_config.first_value) == VersionPart(\n        version_part_config, version_part_config.first_value\n    )\n\n\ndef test_version_part_null(version_part_config):\n    assert VersionPart(version_part_config, version_part_config.first_value).null() == VersionPart(\n        version_part_config, version_part_config.first_value\n    )", "def test_version_part_null(version_part_config):\n    assert VersionPart(version_part_config, version_part_config.first_value).null() == VersionPart(\n        version_part_config, version_part_config.first_value\n    )\n\n\ndef test_bump_version_missing_part():\n    overrides = {\n        \"current_version\": \"1.0.0\",\n    }\n    conf, version_config, current_version = get_config_data(overrides)\n    with pytest.raises(exceptions.InvalidVersionPartError, match=\"No part named 'bugfix'\"):\n        current_version.bump(\"bugfix\", version_config.order)", "\n\ndef test_build_number_configuration():\n    overrides = {\n        \"current_version\": \"2.1.6-5123\",\n        \"parse\": r\"(?P<major>\\d+)\\.(?P<minor>\\d+)\\.(?P<patch>\\d+)\\-(?P<build>\\d+)\",\n        \"serialize\": [\"{major}.{minor}.{patch}-{build}\"],\n        \"parts\": {\n            \"build\": {\n                \"independent\": True,\n            }\n        },\n    }\n    conf, version_config, current_version = get_config_data(overrides)\n\n    build_version_bump = current_version.bump(\"build\", version_config.order)\n    assert build_version_bump.values[\"build\"].value == \"5124\"\n    assert build_version_bump.values[\"build\"].is_independent\n\n    major_version_bump = build_version_bump.bump(\"major\", version_config.order)\n    assert major_version_bump.values[\"build\"].value == \"5124\"\n    assert build_version_bump.values[\"build\"].is_independent\n    assert major_version_bump.values[\"major\"].value == \"3\"\n\n    build_version_bump = major_version_bump.bump(\"build\", version_config.order)\n    assert build_version_bump.values[\"build\"].value == \"5125\"\n    assert build_version_bump.values[\"build\"].is_independent", "\n\ndef test_serialize_with_distance_to_latest_tag():\n    \"\"\"Using ``distance_to_latest_tag`` in the serialization string outputs correctly.\"\"\"\n    from bumpversion.scm import Git, SCMInfo\n\n    overrides = {\n        \"current_version\": \"19.6.0\",\n        \"parse\": r\"(?P<major>\\d+)\\.(?P<minor>\\d+)\\.(?P<patch>\\d+).*\",\n        \"serialize\": [\"{major}.{minor}.{patch}-pre{distance_to_latest_tag}\"],\n    }\n    conf, version_config, current_version = get_config_data(overrides)\n    conf.scm_info = SCMInfo(\n        tool=Git, commit_sha=\"1234123412341234\", distance_to_latest_tag=3, current_version=\"19.6.0\", dirty=False\n    )\n    assert version_config.serialize(current_version, get_context(conf)) == \"19.6.0-pre3\"", "\n\ndef test_serialize_with_environment_var():\n    import os\n\n    os.environ[\"BUILD_NUMBER\"] = \"567\"\n    overrides = {\n        \"current_version\": \"2.3.4\",\n        \"parse\": r\"(?P<major>\\d+)\\.(?P<minor>\\d+)\\.(?P<patch>\\d+).*\",\n        \"serialize\": [\"{major}.{minor}.{patch}-pre{$BUILD_NUMBER}\"],\n    }\n    conf, version_config, current_version = get_config_data(overrides)\n    assert version_config.serialize(current_version, get_context(conf)) == \"2.3.4-pre567\"\n    del os.environ[\"BUILD_NUMBER\"]", "\n\ndef test_serialize_with_newlines():\n    overrides = {\n        \"current_version\": \"MAJOR=31\\nMINOR=0\\nPATCH=3\\n\",\n        \"parse\": r\"MAJOR=(?P<major>\\d+)\\nMINOR=(?P<minor>\\d+)\\nPATCH=(?P<patch>\\d+)\\n\",\n        \"serialize\": [\"MAJOR={major}\\nMINOR={minor}\\nPATCH={patch}\\n\"],\n    }\n    conf, version_config, current_version = get_config_data(overrides)\n    new_version = current_version.bump(\"major\", version_config.order)\n    assert version_config.serialize(new_version, get_context(conf)) == \"MAJOR=32\\nMINOR=0\\nPATCH=0\\n\"", "\n\n@pytest.mark.parametrize(\n    [\"bump_type\", \"expected\"],\n    [\n        param(\"patch\", \"0.9.1\", id=\"patch\"),\n        param(\"minor\", \"0.10\", id=\"minor\"),\n        param(\"major\", \"1\", id=\"major\"),\n    ],\n)\ndef test_serialize_three_part(bump_type: str, expected: str):\n    overrides = {\n        \"current_version\": \"0.9\",\n        \"parse\": r\"(?P<major>\\d+)(\\.(?P<minor>\\d+)(\\.(?P<patch>\\d+))?)?\",\n        \"serialize\": [\"{major}.{minor}.{patch}\", \"{major}.{minor}\", \"{major}\"],\n    }\n    conf, version_config, current_version = get_config_data(overrides)\n\n    new_version = current_version.bump(bump_type, version_config.order)\n    assert version_config.serialize(new_version, get_context(conf)) == expected", "    ],\n)\ndef test_serialize_three_part(bump_type: str, expected: str):\n    overrides = {\n        \"current_version\": \"0.9\",\n        \"parse\": r\"(?P<major>\\d+)(\\.(?P<minor>\\d+)(\\.(?P<patch>\\d+))?)?\",\n        \"serialize\": [\"{major}.{minor}.{patch}\", \"{major}.{minor}\", \"{major}\"],\n    }\n    conf, version_config, current_version = get_config_data(overrides)\n\n    new_version = current_version.bump(bump_type, version_config.order)\n    assert version_config.serialize(new_version, get_context(conf)) == expected", "\n\n@pytest.mark.parametrize(\n    [\"initial\", \"bump_type\", \"expected\"],\n    [\n        param(\"1.5.dev\", \"release\", \"1.5\", id=\"release\"),\n        param(\"1.5\", \"minor\", \"1.6.dev\", id=\"minor\"),\n    ],\n)\ndef test_bump_non_numeric_parts(initial: str, bump_type: str, expected: str):\n    overrides = {\n        \"current_version\": initial,\n        \"parse\": r\"(?P<major>\\d+)\\.(?P<minor>\\d+)(\\.(?P<release>[a-z]+))?\",\n        \"serialize\": [\"{major}.{minor}.{release}\", \"{major}.{minor}\"],\n        \"parts\": {\n            \"release\": {\n                \"optional_value\": \"gamma\",\n                \"values\": [\"dev\", \"gamma\"],\n            },\n        },\n    }\n    conf, version_config, current_version = get_config_data(overrides)\n\n    new_version = current_version.bump(bump_type, version_config.order)\n    assert version_config.serialize(new_version, get_context(conf)) == expected", ")\ndef test_bump_non_numeric_parts(initial: str, bump_type: str, expected: str):\n    overrides = {\n        \"current_version\": initial,\n        \"parse\": r\"(?P<major>\\d+)\\.(?P<minor>\\d+)(\\.(?P<release>[a-z]+))?\",\n        \"serialize\": [\"{major}.{minor}.{release}\", \"{major}.{minor}\"],\n        \"parts\": {\n            \"release\": {\n                \"optional_value\": \"gamma\",\n                \"values\": [\"dev\", \"gamma\"],\n            },\n        },\n    }\n    conf, version_config, current_version = get_config_data(overrides)\n\n    new_version = current_version.bump(bump_type, version_config.order)\n    assert version_config.serialize(new_version, get_context(conf)) == expected", "\n\n@pytest.mark.parametrize(\n    [\"initial\", \"bump_type\", \"expected\"],\n    [\n        param(\"1.alpha\", \"release\", \"1.beta\", id=\"alpha-to-beta-release\"),\n        param(\"1.beta\", \"release\", \"1\", id=\"beta-to-release\"),\n    ],\n)\ndef test_optional_value(initial: str, bump_type: str, expected: str):\n    overrides = {\n        \"current_version\": initial,\n        \"parse\": r\"(?P<num>\\d+)(\\.(?P<release>.*))?(\\.)?\",\n        \"serialize\": [\"{num}.{release}\", \"{num}\"],\n        \"parts\": {\n            \"release\": {\n                \"optional_value\": \"gamma\",\n                \"values\": [\"alpha\", \"beta\", \"gamma\"],\n            },\n        },\n    }\n    conf, version_config, current_version = get_config_data(overrides)\n\n    new_version = current_version.bump(bump_type, version_config.order)\n    assert version_config.serialize(new_version, get_context(conf)) == expected", ")\ndef test_optional_value(initial: str, bump_type: str, expected: str):\n    overrides = {\n        \"current_version\": initial,\n        \"parse\": r\"(?P<num>\\d+)(\\.(?P<release>.*))?(\\.)?\",\n        \"serialize\": [\"{num}.{release}\", \"{num}\"],\n        \"parts\": {\n            \"release\": {\n                \"optional_value\": \"gamma\",\n                \"values\": [\"alpha\", \"beta\", \"gamma\"],\n            },\n        },\n    }\n    conf, version_config, current_version = get_config_data(overrides)\n\n    new_version = current_version.bump(bump_type, version_config.order)\n    assert version_config.serialize(new_version, get_context(conf)) == expected", "\n\n@pytest.mark.parametrize(\n    [\"initial\", \"bump_type\", \"expected\"],\n    [\n        param(\"1.0a\", \"prerel\", \"1.0b\", id=\"a-to-b-release\"),\n        param(\"1.0b\", \"prerelversion\", \"1.0b1\", id=\"prerelease-version\"),\n        param(\"1.0b1\", \"prerelversion\", \"1.0b2\", id=\"prerelease-version2\"),\n        param(\"1.0b2\", \"prerel\", \"1.0c\", id=\"b2-to-c-release\"),\n        param(\"1.0c\", \"prerel\", \"1.0rc\", id=\"c-to-rc-release\"),", "        param(\"1.0b2\", \"prerel\", \"1.0c\", id=\"b2-to-c-release\"),\n        param(\"1.0c\", \"prerel\", \"1.0rc\", id=\"c-to-rc-release\"),\n        param(\"1.0rc\", \"prerel\", \"1.0\", id=\"rc-to-d-release\"),\n        param(\"1.0\", \"minor\", \"1.1dev\", id=\"minor-release\"),\n        param(\"1.1dev\", \"prerel\", \"1.1a\", id=\"dev-to-a-release\"),\n    ],\n)\ndef test_python_pre_release_release_post_release(initial: str, bump_type: str, expected: str):\n    # adapted from http://legacy.python.org/dev/peps/pep-0386/#the-new-versioning-algorithm\n    overrides = {\n        \"current_version\": initial,\n        \"parse\": r\"\"\"^\n            (?P<major>\\d+)\\.(?P<minor>\\d+)   # minimum 'N.N'\n            (?:\n                (?P<prerel>[abc]|rc|dev)     # 'a' = alpha, 'b' = beta\n                                             # 'c' or 'rc' = release candidate\n                (?:\n                    (?P<prerelversion>\\d+(?:\\.\\d+)*)\n                )?\n            )?\n            (?P<postdev>(\\.post(?P<post>\\d+))?(\\.dev(?P<dev>\\d+))?)?\"\"\",\n        \"serialize\": [\n            \"{major}.{minor}{prerel}{prerelversion}\",\n            \"{major}.{minor}{prerel}\",\n            \"{major}.{minor}\",\n        ],\n        \"parts\": {\n            \"prerel\": {\n                \"optional_value\": \"d\",\n                \"values\": [\"dev\", \"a\", \"b\", \"c\", \"rc\", \"d\"],\n            },\n        },\n    }\n    conf, version_config, current_version = get_config_data(overrides)\n\n    new_version = current_version.bump(bump_type, version_config.order)\n    assert version_config.serialize(new_version, get_context(conf)) == expected", "\n\n@pytest.mark.parametrize(\n    [\"initial\", \"bump_type\", \"expected\"],\n    [\n        param(\"0.9.4\", \"major\", \"1.1.0\", id=\"first-value-1\"),\n    ],\n)\ndef test_part_first_value(initial: str, bump_type: str, expected: str):\n    overrides = {\n        \"current_version\": initial,\n        \"parts\": {\n            \"minor\": {\n                \"first_value\": \"1\",\n            },\n        },\n    }\n    conf, version_config, current_version = get_config_data(overrides)\n\n    new_version = current_version.bump(bump_type, version_config.order)\n    assert version_config.serialize(new_version, get_context(conf)) == expected", "def test_part_first_value(initial: str, bump_type: str, expected: str):\n    overrides = {\n        \"current_version\": initial,\n        \"parts\": {\n            \"minor\": {\n                \"first_value\": \"1\",\n            },\n        },\n    }\n    conf, version_config, current_version = get_config_data(overrides)\n\n    new_version = current_version.bump(bump_type, version_config.order)\n    assert version_config.serialize(new_version, get_context(conf)) == expected", "\n\ndef test_version_part_invalid_regex_exit(tmp_path: Path) -> None:\n    \"\"\"A version part with an invalid regex should raise an exception.\"\"\"\n    # Arrange\n    overrides = {\n        \"current_version\": \"12\",\n        \"parse\": \"*kittens*\",\n    }\n    with inside_dir(tmp_path):\n        with pytest.raises(UsageError):\n            get_config_data(overrides)", "\n\ndef test_parse_doesnt_parse_current_version(tmp_path: Path, caplog: LogCaptureFixture) -> None:\n    \"\"\"A warning should be output when the parse regex doesn't parse the version.\"\"\"\n    overrides = {\"current_version\": \"12\", \"parse\": \"xxx\"}\n    with inside_dir(tmp_path):\n        get_config_data(overrides)\n\n    assert \"Evaluating 'parse' option: 'xxx' does not parse current version '12'\" in caplog.messages\n", "\n\ndef test_part_does_not_revert_to_zero_if_optional(tmp_path: Path) -> None:\n    \"\"\"A non-numeric part with the optional value should not revert to zero.\"\"\"\n    # From https://github.com/c4urself/bump2version/issues/248\n    # Arrange\n    overrides = {\n        \"current_version\": \"0.3.1\",\n        \"parse\": r\"(?P<major>\\d+)\\.(?P<minor>\\d+)\\.(?P<patch>\\d+)((?P<release>\\D+)(?P<build>\\d*))?\",\n        \"serialize\": [\n            \"{major}.{minor}.{patch}{release}{build}\",\n            \"{major}.{minor}.{patch}{release}\",\n            \"{major}.{minor}.{patch}\",\n        ],\n        \"parts\": {\n            \"release\": {\n                \"optional_value\": \"g\",\n                \"first_value\": \"g\",\n                \"values\": [\n                    \"dev\",\n                    \"a\",\n                    \"b\",\n                    \"g\",\n                ],\n            },\n        },\n    }\n    with inside_dir(tmp_path):\n        conf, version_config, current_version = get_config_data(overrides)\n\n    new_version = current_version.bump(\"build\", version_config.order)\n    assert version_config.serialize(new_version, get_context(conf)) == \"0.3.1g1\"", ""]}
{"filename": "tests/test_cli.py", "chunked_list": ["\"\"\"Tests for `bumpversion` package.\"\"\"\nimport shutil\nimport subprocess\nimport traceback\nfrom pathlib import Path\n\nimport pytest\nfrom click.testing import CliRunner, Result\nfrom pytest import param\n", "from pytest import param\n\nfrom bumpversion import __version__, cli\nfrom tests.conftest import inside_dir\n\n\ndef test_version_displays_library_version():\n    \"\"\"\n    Arrange/Act: Run the `version` subcommand.\n\n    Assert: The output matches the library version.\n    \"\"\"\n    runner: CliRunner = CliRunner()\n    result: Result = runner.invoke(cli.cli, [\"--version\"])\n    assert __version__ in result.output.strip(), \"Version number should match library version.\"", "\n\ndef test_bump_no_configured_files(mocker, tmp_path):\n    \"\"\"\n    Arrange/Act: Run the `bump` subcommand with --no-configured-files.\n\n    Assert: There is no configured files specified to modify\n    \"\"\"\n    mocked_do_bump = mocker.patch(\"bumpversion.cli.do_bump\")\n    runner: CliRunner = CliRunner()\n    with inside_dir(tmp_path):\n        result: Result = runner.invoke(\n            cli.cli, [\"bump\", \"--current-version\", \"1.0.0\", \"--no-configured-files\", \"patch\"]\n        )\n\n    if result.exit_code != 0:\n        print(result.output)\n\n    assert result.exit_code == 0\n\n    call_args = mocked_do_bump.call_args[0]\n    assert len(call_args[2].files) == 0", "\n\ndef test_bump_legacy(mocker, tmp_path):\n    \"\"\"\n    Arrange/Act: Run the `bump` subcommand with --no-configured-files.\n\n    Assert: There is no configured files specified to modify\n    \"\"\"\n    mocked_do_bump = mocker.patch(\"bumpversion.cli.do_bump\")\n    runner: CliRunner = CliRunner()\n    with inside_dir(tmp_path):\n        result: Result = runner.invoke(cli.cli, [\"--current-version\", \"1.0.0\", \"--no-configured-files\", \"patch\"])\n\n    if result.exit_code != 0:\n        print(result.output)\n\n    assert result.exit_code == 0\n\n    call_args = mocked_do_bump.call_args[0]\n    assert len(call_args[2].files) == 0", "\n\ndef test_no_configured_files_still_file_args_work(mocker, tmp_path):\n    mocked_do_bump = mocker.patch(\"bumpversion.cli.do_bump\")\n    runner: CliRunner = CliRunner()\n    with inside_dir(tmp_path):\n        result: Result = runner.invoke(\n            cli.cli, [\"bump\", \"--current-version\", \"1.0.0\", \"--no-configured-files\", \"patch\", \"do-this-file.txt\"]\n        )\n\n    if result.exit_code != 0:\n        print(result.output)\n\n    assert result.exit_code == 0\n\n    call_args = mocked_do_bump.call_args[0]\n    assert len(call_args[2].files) == 1\n    assert call_args[2].files[0].filename == \"do-this-file.txt\"", "\n\ndef test_missing_explicit_config_file(tmp_path: Path):\n    \"\"\"The command-line processor should raise an exception if the config file is missing.\"\"\"\n    with inside_dir(tmp_path):\n        runner: CliRunner = CliRunner()\n        with inside_dir(tmp_path):\n            result: Result = runner.invoke(cli.cli, [\"bump\", \"--config-file\", \"missing-file.cfg\"])\n        assert result.exit_code != 0\n        assert \"'missing-file.cfg' does not exist.\" in result.output", "\n\ndef test_cli_options_override_config(tmp_path: Path, fixtures_path: Path, mocker):\n    \"\"\"The command-line processor should override the config file.\"\"\"\n    # Arrange\n    config_path = tmp_path / \"this_config.toml\"\n    fixture_toml = fixtures_path / \"basic_cfg.toml\"\n    shutil.copy(fixture_toml, config_path)\n    runner: CliRunner = CliRunner()\n    mocked_do_bump = mocker.patch(\"bumpversion.cli.do_bump\")\n\n    # Act\n    with inside_dir(tmp_path):\n        result: Result = runner.invoke(\n            cli.cli,\n            [\n                \"bump\",\n                \"--config-file\",\n                str(config_path),\n                \"--current-version\",\n                \"1.1.0\",\n                \"--new-version\",\n                \"1.2.0\",\n                \"--allow-dirty\",\n                \"--parse\",\n                r\"XXX(?P<spam>\\d+);(?P<blob>\\d+);(?P<slurp>\\d+)\",\n                \"--serialize\",\n                \"XXX{spam};{blob};{slurp}\",\n                \"--search\",\n                \"my-search\",\n                \"--replace\",\n                \"my-replace\",\n                \"--no-commit\",\n                \"--no-tag\",\n                \"slurp\",\n                \"do-this-file.txt\",\n            ],\n        )\n\n    # Assert\n    assert result.exit_code == 0\n    assert mocked_do_bump.call_count == 1\n    assert mocked_do_bump.call_args[0][0] == \"slurp\"\n    assert mocked_do_bump.call_args[0][1] == \"1.2.0\"\n    the_config = mocked_do_bump.call_args[0][2]\n    assert the_config.current_version == \"1.1.0\"\n    assert the_config.allow_dirty\n    assert the_config.parse == r\"XXX(?P<spam>\\d+);(?P<blob>\\d+);(?P<slurp>\\d+)\"\n    assert the_config.serialize == [\"XXX{spam};{blob};{slurp}\"]\n    assert the_config.search == \"my-search\"\n    assert the_config.replace == \"my-replace\"\n    assert the_config.commit is False\n    assert the_config.tag is False\n    assert len(the_config.files) == 4\n    assert {f.filename for f in the_config.files} == {\n        \"setup.py\",\n        \"bumpversion/__init__.py\",\n        \"CHANGELOG.md\",\n        \"do-this-file.txt\",\n    }\n    assert mocked_do_bump.call_args[0][3] == config_path", "\n\n@pytest.mark.parametrize(\n    [\"repo\", \"scm_command\"],\n    [\n        param(\"git_repo\", \"git\", id=\"git\"),\n        param(\"hg_repo\", \"hg\", id=\"hg\"),\n    ],\n)\ndef test_dirty_work_dir_raises_error(repo: str, scm_command: str, request):\n    repo_path: Path = request.getfixturevalue(repo)\n    with inside_dir(repo_path):\n        # Arrange\n        repo_path.joinpath(\"dirty2\").write_text(\"i'm dirty! 1.1.1\")\n        subprocess.run([scm_command, \"add\", \"dirty2\"], check=True)\n        runner: CliRunner = CliRunner()\n\n        # Act\n        result: Result = runner.invoke(\n            cli.cli, [\"bump\", \"patch\", \"--current-version\", \"1.1.1\", \"--no-allow-dirty\", \"dirty2\"]\n        )\n\n    # Assert\n    assert result.exit_code != 0\n    assert \"working directory is not clean\" in result.output", ")\ndef test_dirty_work_dir_raises_error(repo: str, scm_command: str, request):\n    repo_path: Path = request.getfixturevalue(repo)\n    with inside_dir(repo_path):\n        # Arrange\n        repo_path.joinpath(\"dirty2\").write_text(\"i'm dirty! 1.1.1\")\n        subprocess.run([scm_command, \"add\", \"dirty2\"], check=True)\n        runner: CliRunner = CliRunner()\n\n        # Act\n        result: Result = runner.invoke(\n            cli.cli, [\"bump\", \"patch\", \"--current-version\", \"1.1.1\", \"--no-allow-dirty\", \"dirty2\"]\n        )\n\n    # Assert\n    assert result.exit_code != 0\n    assert \"working directory is not clean\" in result.output", "\n\ndef test_listing_with_version_part(tmp_path: Path, fixtures_path: Path):\n    \"\"\"The --list option should list the configuration with new_version..\"\"\"\n    # Arrange\n    config_path = tmp_path / \"pyproject.toml\"\n    toml_path = fixtures_path / \"basic_cfg.toml\"\n    shutil.copy(toml_path, config_path)\n    runner: CliRunner = CliRunner()\n\n    with inside_dir(tmp_path):\n        result: Result = runner.invoke(cli.cli, [\"bump\", \"--list\", \"patch\"])\n\n    if result.exit_code != 0:\n        print(result.output)\n        print(result.exception)\n\n    assert result.exit_code == 0\n    assert set(result.output.splitlines(keepends=False)) == {\n        \"WARNING:\",\n        \"\",\n        \"DEPRECATED: The --list option is deprecated and will be removed in a future version.\",\n        \"new_version=1.0.1-dev\",\n        \"current_version=1.0.0\",\n        \"parse=(?P<major>\\\\d+)\\\\.(?P<minor>\\\\d+)\\\\.(?P<patch>\\\\d+)(\\\\-(?P<release>[a-z]+))?\",\n        \"serialize=['{major}.{minor}.{patch}-{release}', '{major}.{minor}.{patch}']\",\n        \"search={current_version}\",\n        \"replace={new_version}\",\n        \"ignore_missing_version=False\",\n        \"tag=True\",\n        \"sign_tags=False\",\n        \"tag_name=v{new_version}\",\n        \"tag_message=Bump version: {current_version} \u2192 {new_version}\",\n        \"allow_dirty=False\",\n        \"commit=True\",\n        \"message=Bump version: {current_version} \u2192 {new_version}\",\n        \"commit_args=None\",\n        (\n            \"files=[\"\n            \"{'filename': 'setup.py', 'glob': None, 'parse': \"\n            \"'(?P<major>\\\\\\\\d+)\\\\\\\\.(?P<minor>\\\\\\\\d+)\\\\\\\\.(?P<patch>\\\\\\\\d+)(\\\\\\\\-(?P<release>[a-z]+))?', 'serialize': \"\n            \"['{major}.{minor}.{patch}-{release}', '{major}.{minor}.{patch}'], 'search': '{current_version}', \"\n            \"'replace': '{new_version}', 'ignore_missing_version': False}, \"\n            \"{'filename': 'bumpversion/__init__.py', 'glob': None, 'parse': \"\n            \"'(?P<major>\\\\\\\\d+)\\\\\\\\.(?P<minor>\\\\\\\\d+)\\\\\\\\.(?P<patch>\\\\\\\\d+)(\\\\\\\\-(?P<release>[a-z]+))?', 'serialize': \"\n            \"['{major}.{minor}.{patch}-{release}', '{major}.{minor}.{patch}'], 'search': '{current_version}', \"\n            \"'replace': '{new_version}', 'ignore_missing_version': False}, \"\n            \"{'filename': 'CHANGELOG.md', 'glob': None, 'parse': \"\n            \"'(?P<major>\\\\\\\\d+)\\\\\\\\.(?P<minor>\\\\\\\\d+)\\\\\\\\.(?P<patch>\\\\\\\\d+)(\\\\\\\\-(?P<release>[a-z]+))?', 'serialize': \"\n            \"['{major}.{minor}.{patch}-{release}', '{major}.{minor}.{patch}'], 'search': '**unreleased**', \"\n            \"'replace': '**unreleased**\\\\n**v{new_version}**', 'ignore_missing_version': False}]\"\n        ),\n    }", "\n\ndef test_listing_without_version_part(tmp_path: Path, fixtures_path: Path):\n    \"\"\"The --list option should list the configuration without new_version.\"\"\"\n    # Arrange\n    config_path = tmp_path / \"pyproject.toml\"\n    toml_path = fixtures_path / \"basic_cfg.toml\"\n    shutil.copy(toml_path, config_path)\n    runner: CliRunner = CliRunner()\n\n    with inside_dir(tmp_path):\n        result: Result = runner.invoke(cli.cli, [\"bump\", \"--list\"])\n\n    if result.exit_code != 0:\n        print(result.output)\n        print(result.exception)\n\n    assert result.exit_code == 0\n    assert set(result.output.splitlines(keepends=False)) == {\n        \"WARNING:\",\n        \"\",\n        \"DEPRECATED: The --list option is deprecated and will be removed in a future version.\",\n        \"current_version=1.0.0\",\n        \"parse=(?P<major>\\\\d+)\\\\.(?P<minor>\\\\d+)\\\\.(?P<patch>\\\\d+)(\\\\-(?P<release>[a-z]+))?\",\n        \"serialize=['{major}.{minor}.{patch}-{release}', '{major}.{minor}.{patch}']\",\n        \"search={current_version}\",\n        \"replace={new_version}\",\n        \"ignore_missing_version=False\",\n        \"tag=True\",\n        \"sign_tags=False\",\n        \"tag_name=v{new_version}\",\n        \"tag_message=Bump version: {current_version} \u2192 {new_version}\",\n        \"allow_dirty=False\",\n        \"commit=True\",\n        \"message=Bump version: {current_version} \u2192 {new_version}\",\n        \"commit_args=None\",\n        (\n            \"files=[\"\n            \"{'filename': 'setup.py', 'glob': None, 'parse': \"\n            \"'(?P<major>\\\\\\\\d+)\\\\\\\\.(?P<minor>\\\\\\\\d+)\\\\\\\\.(?P<patch>\\\\\\\\d+)(\\\\\\\\-(?P<release>[a-z]+))?', 'serialize': \"\n            \"['{major}.{minor}.{patch}-{release}', '{major}.{minor}.{patch}'], 'search': '{current_version}', \"\n            \"'replace': '{new_version}', 'ignore_missing_version': False}, \"\n            \"{'filename': 'bumpversion/__init__.py', 'glob': None, 'parse': \"\n            \"'(?P<major>\\\\\\\\d+)\\\\\\\\.(?P<minor>\\\\\\\\d+)\\\\\\\\.(?P<patch>\\\\\\\\d+)(\\\\\\\\-(?P<release>[a-z]+))?', 'serialize': \"\n            \"['{major}.{minor}.{patch}-{release}', '{major}.{minor}.{patch}'], 'search': '{current_version}', \"\n            \"'replace': '{new_version}', 'ignore_missing_version': False}, \"\n            \"{'filename': 'CHANGELOG.md', 'glob': None, 'parse': \"\n            \"'(?P<major>\\\\\\\\d+)\\\\\\\\.(?P<minor>\\\\\\\\d+)\\\\\\\\.(?P<patch>\\\\\\\\d+)(\\\\\\\\-(?P<release>[a-z]+))?', 'serialize': \"\n            \"['{major}.{minor}.{patch}-{release}', '{major}.{minor}.{patch}'], 'search': '**unreleased**', \"\n            \"'replace': '**unreleased**\\\\n**v{new_version}**', 'ignore_missing_version': False}]\"\n        ),\n    }", "\n\ndef test_non_scm_operations_if_scm_not_installed(tmp_path: Path, monkeypatch):\n    \"\"\"Everything works except SCM commands if the SCM is unusable.\"\"\"\n    # Arrange\n    monkeypatch.setenv(\"PATH\", \"\")\n\n    with inside_dir(tmp_path):\n        version_path = tmp_path / \"VERSION\"\n        version_path.write_text(\"31.0.3\")\n\n        runner: CliRunner = CliRunner()\n\n        # Act\n        runner.invoke(cli.cli, [\"bump\", \"major\", \"--current-version\", \"31.0.3\", \"VERSION\"])\n\n    # Assert\n    assert version_path.read_text() == \"32.0.0\"", "\n\n@pytest.mark.parametrize(\n    [\"version_part\"],\n    [\n        param(\"charlie\", id=\"bad_version_part\"),\n        param(\"\", id=\"missing_version_part\"),\n    ],\n)\ndef test_detects_bad_or_missing_version_part(version_part: str, tmp_path: Path, monkeypatch):\n    \"\"\"It properly detects bad or missing version part.\"\"\"\n    # Arrange\n    monkeypatch.setenv(\"PATH\", \"\")\n\n    with inside_dir(tmp_path):\n        version_path = tmp_path / \"VERSION\"\n        version_path.write_text(\"31.0.3\")\n\n        runner: CliRunner = CliRunner()\n        args = [\"bump\", \"--current-version\", \"31.0.3\"]\n        if version_part:\n            args.append(version_part)\n        args.append(\"VERSION\")\n        # Act\n        result = runner.invoke(cli.cli, args)\n\n    # Assert\n    assert result.exception is not None\n    assert \"Unknown version part:\" in result.stdout", ")\ndef test_detects_bad_or_missing_version_part(version_part: str, tmp_path: Path, monkeypatch):\n    \"\"\"It properly detects bad or missing version part.\"\"\"\n    # Arrange\n    monkeypatch.setenv(\"PATH\", \"\")\n\n    with inside_dir(tmp_path):\n        version_path = tmp_path / \"VERSION\"\n        version_path.write_text(\"31.0.3\")\n\n        runner: CliRunner = CliRunner()\n        args = [\"bump\", \"--current-version\", \"31.0.3\"]\n        if version_part:\n            args.append(version_part)\n        args.append(\"VERSION\")\n        # Act\n        result = runner.invoke(cli.cli, args)\n\n    # Assert\n    assert result.exception is not None\n    assert \"Unknown version part:\" in result.stdout", "\n\ndef test_show(tmp_path: Path, fixtures_path: Path):\n    \"\"\"The show subcommand should list the parts of the configuration.\"\"\"\n    # Arrange\n    config_path = tmp_path / \"pyproject.toml\"\n    toml_path = fixtures_path / \"basic_cfg.toml\"\n    shutil.copy(toml_path, config_path)\n    runner: CliRunner = CliRunner()\n\n    with inside_dir(tmp_path):\n        result: Result = runner.invoke(cli.cli, [\"show\", \"current_version\"])\n\n    if result.exit_code != 0:\n        print(result.output)\n        print(result.exception)\n\n    assert result.exit_code == 0\n    assert result.output.splitlines(keepends=False) == [\"1.0.0\"]", "\n\ndef test_show_and_increment(tmp_path: Path, fixtures_path: Path):\n    \"\"\"The show subcommand should incrment the version and display it.\"\"\"\n    # Arrange\n    config_path = tmp_path / \"pyproject.toml\"\n    toml_path = fixtures_path / \"basic_cfg.toml\"\n    shutil.copy(toml_path, config_path)\n    runner: CliRunner = CliRunner()\n\n    with inside_dir(tmp_path):\n        result: Result = runner.invoke(cli.cli, [\"show\", \"new_version\", \"--increment\", \"minor\"])\n\n    if result.exit_code != 0:\n        print(result.output)\n        print(result.exception)\n\n    assert result.exit_code == 0\n    assert result.output.splitlines(keepends=False) == [\"1.1.0-dev\"]", "\n\ndef test_show_no_args(tmp_path: Path, fixtures_path: Path):\n    \"\"\"The show subcommand should list the entire configuration.\"\"\"\n    # Arrange\n    config_path = tmp_path / \"pyproject.toml\"\n    toml_path = fixtures_path / \"basic_cfg.toml\"\n    expected_output = fixtures_path.joinpath(\"basic_cfg_expected.yaml\").read_text()\n\n    shutil.copy(toml_path, config_path)\n    runner: CliRunner = CliRunner()\n\n    with inside_dir(tmp_path):\n        result: Result = runner.invoke(cli.cli, [\"show\", \"--format\", \"yaml\"])\n\n    if result.exit_code != 0:\n        print(result.output)\n        print(result.exception)\n\n    assert result.exit_code == 0\n    assert result.output.strip() == expected_output.strip()", "\n\ndef test_replace(mocker, tmp_path, fixtures_path):\n    \"\"\"The replace subcommand should replace the version in the file.\"\"\"\n    # Arrange\n    toml_path = fixtures_path / \"basic_cfg.toml\"\n    config_path = tmp_path / \"pyproject.toml\"\n    shutil.copy(toml_path, config_path)\n\n    mocked_modify_files = mocker.patch(\"bumpversion.cli.modify_files\")\n    runner: CliRunner = CliRunner()\n    with inside_dir(tmp_path):\n        result: Result = runner.invoke(cli.cli, [\"replace\", \"--new-version\", \"1.1.0\"])\n\n    if result.exit_code != 0:\n        print(result.output)\n\n    assert result.exit_code == 0\n\n    call_args = mocked_modify_files.call_args[0]\n    configured_files = call_args[0]\n    assert len(configured_files) == 3\n    actual_filenames = {f.path for f in configured_files}\n    assert actual_filenames == {\"setup.py\", \"CHANGELOG.md\", \"bumpversion/__init__.py\"}", "\n\ndef test_replace_no_newversion(mocker, tmp_path, fixtures_path):\n    \"\"\"The replace subcommand should set new_version to None in the context.\"\"\"\n    # Arrange\n    toml_path = fixtures_path / \"basic_cfg.toml\"\n    config_path = tmp_path / \"pyproject.toml\"\n    shutil.copy(toml_path, config_path)\n\n    mocked_modify_files = mocker.patch(\"bumpversion.cli.modify_files\")\n    runner: CliRunner = CliRunner()\n    with inside_dir(tmp_path):\n        result: Result = runner.invoke(cli.cli, [\"replace\"])\n\n    if result.exit_code != 0:\n        print(result.output)\n\n    assert result.exit_code == 0\n\n    call_args = mocked_modify_files.call_args[0]\n    assert call_args[2] is None", "\n\ndef test_replace_specific_files(mocker, git_repo, fixtures_path):\n    \"\"\"The replace subcommand should set the files to only the specified files.\"\"\"\n    # Arrange\n    toml_path = fixtures_path / \"basic_cfg.toml\"\n    config_path = git_repo / \"pyproject.toml\"\n    shutil.copy(toml_path, config_path)\n\n    mocked_modify_files = mocker.patch(\"bumpversion.cli.modify_files\")\n    runner: CliRunner = CliRunner()\n    with inside_dir(git_repo):\n        result: Result = runner.invoke(cli.cli, [\"replace\", \"--no-configured-files\", \"VERSION\"])\n\n    if result.exit_code != 0:\n        print(result.output)\n\n    assert result.exit_code == 0\n\n    call_args = mocked_modify_files.call_args[0]\n    configured_files = call_args[0]\n    assert len(configured_files) == 1\n    assert configured_files[0].path == \"VERSION\"", "\n\nTEST_REPLACE_CONFIG = {\n    \"tool\": {\n        \"bumpversion\": {\n            \"allow_dirty\": True,\n            \"commit\": False,\n            \"current_version\": \"2.17.7\",\n            \"files\": [],\n            \"message\": \"Bump version: {current_version} \u2192 {new_version}\",", "            \"files\": [],\n            \"message\": \"Bump version: {current_version} \u2192 {new_version}\",\n            \"parse\": \"(?P<major>\\\\d+)\\\\.(?P<minor>\\\\d+)\\\\.(?P<patch>\\\\d+)\",\n            \"parts\": {\n                \"major\": {},\n                \"minor\": {},\n                \"patch\": {},\n            },\n            \"replace\": \"{new_version}\",\n            \"search\": \"{current_version}\",", "            \"replace\": \"{new_version}\",\n            \"search\": \"{current_version}\",\n            \"serialize\": [\"{major}.{minor}.{patch}\"],\n            \"sign_tags\": False,\n            \"tag\": False,\n            \"tag_message\": \"Bump version: {current_version} \u2192 {new_version}\",\n            \"tag_name\": \"v{new_version}\",\n        }\n    }\n}", "    }\n}\n\n\ndef test_replace_search_with_plain_string(tmp_path, fixtures_path):\n    \"\"\"Replace should not worry if the search or replace values have version info.\"\"\"\n    from tomlkit import dumps\n\n    # Arrange\n    config_path = tmp_path / \"pyproject.toml\"\n    config_path.write_text(dumps(TEST_REPLACE_CONFIG))\n    doc_path = tmp_path / \"docs.yaml\"\n    doc_path.write_text(\"url: https://github.com/sampleuser/workflows/main/.github/update_mailmap.py\")\n\n    runner: CliRunner = CliRunner()\n    with inside_dir(tmp_path):\n        result: Result = runner.invoke(\n            cli.cli,\n            [\n                \"replace\",\n                \"--no-configured-files\",\n                \"--search\",\n                \"/workflows/main/\",\n                \"--replace\",\n                \"/workflows/v{current_version}/\",\n                \"./docs.yaml\",\n            ],\n        )\n\n    if result.exit_code != 0:\n        print(\"Here is the output:\")\n        print(result.output)\n        print(traceback.print_exception(result.exc_info[1]))\n\n    assert result.exit_code == 0", ""]}
{"filename": "tests/conftest.py", "chunked_list": ["\"\"\"Testing fixtures for Pytest.\"\"\"\nimport subprocess\nfrom contextlib import contextmanager\nfrom pathlib import Path\nfrom typing import Generator\n\nimport pytest\n\n\n@pytest.fixture\ndef tests_path() -> Path:\n    \"\"\"Return the path containing the tests.\"\"\"\n    return Path(__file__).parent", "\n@pytest.fixture\ndef tests_path() -> Path:\n    \"\"\"Return the path containing the tests.\"\"\"\n    return Path(__file__).parent\n\n\n@pytest.fixture\ndef fixtures_path(tests_path: Path) -> Path:\n    \"\"\"Return the path containing the testing fixtures.\"\"\"\n    return tests_path / \"fixtures\"", "def fixtures_path(tests_path: Path) -> Path:\n    \"\"\"Return the path containing the testing fixtures.\"\"\"\n    return tests_path / \"fixtures\"\n\n\n@contextmanager\ndef inside_dir(dirpath: Path) -> Generator:\n    \"\"\"\n    Temporarily switch to a specific directory.\n\n    Args:\n        dirpath: Path of the directory to switch to\n    \"\"\"\n    import os\n\n    old_path = os.getcwd()\n    try:\n        os.chdir(dirpath)\n        yield\n    finally:\n        os.chdir(old_path)", "\n\ndef get_config_data(overrides: dict) -> tuple:\n    \"\"\"Get the configuration, version_config and version.\"\"\"\n    from bumpversion import config\n    from bumpversion.version_part import VersionConfig\n\n    conf = config.get_configuration(config_file=\"missing\", **overrides)\n    version_config = VersionConfig(conf.parse, conf.serialize, conf.search, conf.replace, conf.parts)\n    version = version_config.parse(conf.current_version)\n\n    return conf, version_config, version", "\n\n@pytest.fixture\ndef git_repo(tmp_path: Path) -> Path:\n    \"\"\"Generate a simple temporary git repo and return the path.\"\"\"\n    subprocess.run([\"git\", \"init\"], cwd=tmp_path, check=True, capture_output=True)\n    return tmp_path\n\n\n@pytest.fixture\ndef hg_repo(tmp_path: Path) -> Path:\n    \"\"\"Generate a simple temporary mercurial repo and return the path.\"\"\"\n    subprocess.run([\"hg\", \"init\"], cwd=tmp_path, check=True, capture_output=True)\n    return tmp_path", "\n@pytest.fixture\ndef hg_repo(tmp_path: Path) -> Path:\n    \"\"\"Generate a simple temporary mercurial repo and return the path.\"\"\"\n    subprocess.run([\"hg\", \"init\"], cwd=tmp_path, check=True, capture_output=True)\n    return tmp_path\n"]}
{"filename": "tests/test_show.py", "chunked_list": ["import shutil\nfrom dataclasses import dataclass\nfrom pathlib import Path\n\nfrom tests.conftest import get_config_data, inside_dir\n\nimport pytest\nfrom pytest import param\n\nfrom bumpversion import show", "\nfrom bumpversion import show\nfrom bumpversion import config\n\nmapping = {\"key1\": \"value1\", \"dict-key\": {\"dict-key-key1\": \"value2-1\"}}\n\nFIXTURES_PATH = Path(__file__).parent.joinpath(\"fixtures\")\n\n\n@dataclass\nclass SimpleObj:\n    \"\"\"An object for testing.\"\"\"\n\n    dict_attr: dict\n    list_attr: list\n\n    @property\n    def exc(self):\n        return self._notavailable", "\n@dataclass\nclass SimpleObj:\n    \"\"\"An object for testing.\"\"\"\n\n    dict_attr: dict\n    list_attr: list\n\n    @property\n    def exc(self):\n        return self._notavailable", "\n\ntest_obj = SimpleObj(dict_attr=mapping, list_attr=[\"a\", \"b\", \"c\", \"d\"])\n\n\n@pytest.mark.parametrize(\n    [\"name\", \"data\", \"expected\"],\n    [\n        param(\"key1\", mapping, \"value1\", id=\"simple mapping\"),\n        param(\"dict-key.dict-key-key1\", mapping, \"value2-1\", id=\"nested mapping\"),", "        param(\"key1\", mapping, \"value1\", id=\"simple mapping\"),\n        param(\"dict-key.dict-key-key1\", mapping, \"value2-1\", id=\"nested mapping\"),\n        param(\"dict_attr\", test_obj, mapping, id=\"attribute lookup\"),\n        param(\"list_attr.2\", test_obj, \"c\", id=\"list lookup\"),\n    ],\n)\ndef test_resolve_name(name: str, data, expected):\n    \"\"\"Test the resolve_name method gets the correct values.\"\"\"\n    assert show.resolve_name(data, name) == expected\n", "\n\ndef test_resolve_name_default():\n    \"\"\"Test a default value.\"\"\"\n    assert show.resolve_name(mapping, \"key3\", default=\"default\") == \"default\"\n\n\ndef test_resolve_name_property_error():\n    \"\"\"An error in a property returns default.\"\"\"\n    assert show.resolve_name(test_obj, \"exc\", default=\"default\") == \"default\"", "\n\nDEFAULT_OUTPUT = FIXTURES_PATH.joinpath(\"basic_cfg_expected.txt\").read_text().strip()\nYAML_OUTPUT = FIXTURES_PATH.joinpath(\"basic_cfg_expected.yaml\").read_text().strip()\nJSON_OUTPUT = FIXTURES_PATH.joinpath(\"basic_cfg_expected_full.json\").read_text().strip()\n\nFOUR_ARGS_DEFAULT_OUTPUT = \"{'allow_dirty': False,\\n 'current_version': '1.0.0',\\n 'sign_tags': False,\\n 'tag': True}\"\nFOUR_ARGS_YAML_OUTPUT = 'allow_dirty: false\\ncurrent_version: \"1.0.0\"\\nsign_tags: false\\ntag: true'\nFOUR_ARGS_JSON_OUTPUT = '{\"allow_dirty\": false, \"current_version\": \"1.0.0\", \"sign_tags\": false, \"tag\": true}'\n", "FOUR_ARGS_JSON_OUTPUT = '{\"allow_dirty\": false, \"current_version\": \"1.0.0\", \"sign_tags\": false, \"tag\": true}'\n\nDOTTED_DEFAULT_OUTPUT = (\n    \"{'current_version': '1.0.0',\\n 'files.1.filename': 'bumpversion/__init__.py',\\n\"\n    \" 'parts.release.values': ['dev', 'gamma']}\"\n)\nDOTTED_YAML_OUTPUT = (\n    'current_version: \"1.0.0\"\\n'\n    'files.1.filename: \"bumpversion/__init__.py\"\\n'\n    \"parts.release.values:\\n\"", "    'files.1.filename: \"bumpversion/__init__.py\"\\n'\n    \"parts.release.values:\\n\"\n    '  - \"dev\"\\n'\n    '  - \"gamma\"'\n)\nDOTTED_JSON_OUTPUT = (\n    '{\\n  \"current_version\": \"1.0.0\",'\n    '\\n  \"files.1.filename\": \"bumpversion/__init__.py\",\\n  \"parts.release.values\": [\\n    \"dev\",\\n    \"gamma\"\\n  ]\\n}'\n)\n", ")\n\n\n@pytest.mark.parametrize(\n    [\"req_args\", \"format_\", \"expected\"],\n    (\n        param(\n            [],\n            None,\n            DEFAULT_OUTPUT,", "            None,\n            DEFAULT_OUTPUT,\n            id=\"no-arguments-default\",\n        ),\n        param(\n            [],\n            \"yaml\",\n            YAML_OUTPUT,\n            id=\"no-arguments-yaml\",\n        ),", "            id=\"no-arguments-yaml\",\n        ),\n        param(\n            [],\n            \"json\",\n            JSON_OUTPUT,\n            id=\"no-arguments-json\",\n        ),\n        param(\n            [\"all\"],", "        param(\n            [\"all\"],\n            None,\n            DEFAULT_OUTPUT,\n            id=\"all-argument-default\",\n        ),\n        param(\n            [\"all\", \"current_version\"],\n            None,\n            DEFAULT_OUTPUT,", "            None,\n            DEFAULT_OUTPUT,\n            id=\"all-argument-in-args-default\",\n        ),\n        param(\n            [\"current_version\"],\n            \"default\",\n            \"1.0.0\",\n            id=\"current_version\",\n        ),", "            id=\"current_version\",\n        ),\n        param(\n            [\"current_version\", \"allow_dirty\", \"sign_tags\", \"tag\"],\n            \"default\",\n            FOUR_ARGS_DEFAULT_OUTPUT,\n            id=\"four_args_default\",\n        ),\n        param(\n            [\"files.1.filename\", \"current_version\", \"parts.release.values\"],", "        param(\n            [\"files.1.filename\", \"current_version\", \"parts.release.values\"],\n            \"default\",\n            DOTTED_DEFAULT_OUTPUT,\n            id=\"dotted-default\",\n        ),\n        param(\n            [\"files.1.filename\", \"current_version\", \"parts.release.values\"],\n            \"yaml\",\n            DOTTED_YAML_OUTPUT,", "            \"yaml\",\n            DOTTED_YAML_OUTPUT,\n            id=\"dotted-yaml\",\n        ),\n        param(\n            [\"files.1.filename\", \"current_version\", \"parts.release.values\"],\n            \"json\",\n            DOTTED_JSON_OUTPUT,\n            id=\"dotted-json\",\n        ),", "            id=\"dotted-json\",\n        ),\n    ),\n)\ndef test_do_show(\n    req_args: list, format_: str, expected: str, tmp_path: Path, fixtures_path: Path, capsys: pytest.CaptureFixture\n) -> None:\n    \"\"\"Test the show method.\"\"\"\n    config_path = tmp_path / \"pyproject.toml\"\n    toml_path = fixtures_path / \"basic_cfg.toml\"\n    shutil.copy(toml_path, config_path)\n    with inside_dir(tmp_path):\n        conf = config.get_configuration(config_file=fixtures_path.joinpath(config_path))\n        show.do_show(config=conf, format_=format_, *req_args)\n    captured = capsys.readouterr()\n    assert captured.out.strip() == expected", "\n\ndef test_do_show_increment(tmp_path: Path, fixtures_path: Path, capsys: pytest.CaptureFixture) -> None:\n    \"\"\"Test the show method with increment.\"\"\"\n    config_path = tmp_path / \"pyproject.toml\"\n    toml_path = fixtures_path / \"basic_cfg.toml\"\n    shutil.copy(toml_path, config_path)\n    with inside_dir(tmp_path):\n        conf = config.get_configuration(config_file=fixtures_path.joinpath(config_path))\n        show.do_show(\"current_version\", \"new_version\", config=conf, format_=\"default\", increment=\"minor\")\n    captured = capsys.readouterr()\n    assert captured.out.strip() == \"{'current_version': '1.0.0', 'new_version': '1.1.0-dev'}\"", ""]}
{"filename": "docsrc/conf.py", "chunked_list": ["\"\"\"\nSphinx configuration.\n\"\"\"\n# flake8: noqa\nimport os\nimport sys\nfrom datetime import date\n\nsys.path.insert(0, os.path.abspath(\"..\"))\n", "sys.path.insert(0, os.path.abspath(\"..\"))\n\nimport bumpversion\n\nproject = \"bump-my-version\"\ncopyright = f\"{date.today():%Y} Calloway Project\"\nauthor = \"Contributors\"\n\nversion = bumpversion.__version__\nrelease = bumpversion.__version__", "version = bumpversion.__version__\nrelease = bumpversion.__version__\n\n# -- General configuration ---------------------------------------------\n\nextensions = [\n    \"myst_parser\",\n    \"autodoc2\",\n    # \"sphinx.ext.autodoc\",\n    \"sphinx.ext.viewcode\",", "    # \"sphinx.ext.autodoc\",\n    \"sphinx.ext.viewcode\",\n    \"sphinx.ext.autosummary\",\n    \"sphinx.ext.intersphinx\",\n    \"sphinx.ext.autosectionlabel\",\n    \"sphinx.ext.napoleon\",\n    \"sphinx_autodoc_typehints\",\n    \"sphinx.ext.coverage\",\n    \"sphinx.ext.githubpages\",\n    \"sphinx_click\",", "    \"sphinx.ext.githubpages\",\n    \"sphinx_click\",\n    \"sphinx_copybutton\",\n]\nautosectionlabel_prefix_document = True\nautosectionlabel_maxdepth = 2\n\nautodoc2_packages = [\"../bumpversion\"]\nautodoc2_render_plugin = \"myst\"\nautodoc2_output_dir = \"reference\"", "autodoc2_render_plugin = \"myst\"\nautodoc2_output_dir = \"reference\"\nautodoc2_index_template = None\n\nautodoc_default_flags = [\n    # Make sure that any autodoc declarations show the right members\n    \"members\",\n    \"undoc-members\",\n    \"private-members\",\n]", "    \"private-members\",\n]\nautodoc_class_signature = \"separated\"\nautodoc_member_order = \"bysource\"\nautodoc_typehints = \"description\"\n\nautosummary_generate = True\n\nnapoleon_attr_annotations = True\nnapoleon_include_special_with_doc = True", "napoleon_attr_annotations = True\nnapoleon_include_special_with_doc = True\nnapoleon_include_private_with_doc = True\nnapoleon_include_init_with_doc = True\nnapoleon_use_admonition_for_examples = True\n\nmyst_enable_extensions = [\n    \"amsmath\",\n    \"colon_fence\",\n    \"deflist\",", "    \"colon_fence\",\n    \"deflist\",\n    \"dollarmath\",\n    \"linkify\",\n    \"replacements\",\n    \"smartquotes\",\n    \"substitution\",\n    \"tasklist\",\n    \"fieldlist\",\n]", "    \"fieldlist\",\n]\nintersphinx_mapping = {\n    \"python\": (\"https://docs.python.org/3\", None),\n}\n\ntemplates_path = [\"_templates\"]\nsource_suffix = [\".rst\", \".md\"]\nmaster_doc = \"index\"\nlanguage = \"en\"", "master_doc = \"index\"\nlanguage = \"en\"\nexclude_patterns = [\"_build\", \"Thumbs.db\", \".DS_Store\"]\npygments_style = \"sphinx\"\ntodo_include_todos = False\n\n\n# -- Options for HTML output -------------------------------------------\n\nhtml_theme = \"furo\"", "\nhtml_theme = \"furo\"\nhtml_static_path = [\"_static\"]\nhtml_css_files = [\n    \"css/custom.css\",\n]\nhtml_theme_options = {\n    \"footer_icons\": [\n        {\n            \"name\": \"GitHub\",", "        {\n            \"name\": \"GitHub\",\n            \"url\": \"https://github.com/callowayproject/bump-my-version\",\n            \"html\": \"\"\"\n                <svg stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" viewBox=\"0 0 16 16\">\n                    <path fill-rule=\"evenodd\" d=\"M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z\"></path>\n                </svg>\n            \"\"\",\n            \"class\": \"\",\n        },", "            \"class\": \"\",\n        },\n    ],\n}\nhtml_title = f\"Bump My Version {release}\"\n"]}
