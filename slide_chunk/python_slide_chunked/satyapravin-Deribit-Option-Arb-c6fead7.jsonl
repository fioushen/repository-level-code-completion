{"filename": "src/optarber/selection_data.py", "chunked_list": ["\nclass SelectionData:\n\tdef __init__(self):\n\t\tself.positions = []\n\t\tself.cols = 10\n\t\n\tdef clear(self):\n\t\tself.positions = []\n\t\tself.cols = 10\n\n\tdef update(self, positions):\n\t\tself.positions = positions\n\t\t\n\tdef getRows(self):\n\t\treturn len(self.positions) + 1\n\t\t\n\tdef getCols(self):\n\t\treturn self.cols\n\t\t\n\tdef getData(self, j, i):\n\t\tif j == 0:\n\t\t\tif i == 0:\n\t\t\t\treturn \"Instr\"\n\t\t\telif i == 1:\n\t\t\t\treturn \"Size\"\n\t\t\telif i == 2:\n\t\t\t\treturn \"BidAmount\"\n\t\t\telif i == 3:\n\t\t\t\treturn \"BidPrice\"\n\t\t\telif i == 4:\n\t\t\t\treturn \"AskPrice\"\n\t\t\telif i == 5:\n\t\t\t\treturn \"AskAmount\"\n\t\t\telif i == 6:\n\t\t\t\treturn \"Delta\"\n\t\t\telif i == 7:\n\t\t\t\treturn \"Gamma\"\n\t\t\telif i == 8:\n\t\t\t\treturn \"Vega\"\n\t\t\telif i == 9:\n\t\t\t\treturn \"Theta\"\n\t\t\telse:\n\t\t\t\treturn \"\"\n\t\telse:\n\t\t\top = self.positions[j-1].op\n\t\t\tsize = self.positions[j-1].size\n\t\t\t\n\t\t\tif i == 0:\n\t\t\t\treturn op.name\n\t\t\telif i == 1:\n\t\t\t\treturn size\n\t\t\telif i == 2:\n\t\t\t\treturn op.bid_amount\n\t\t\telif i == 3:\n\t\t\t\treturn op.bid_price\n\t\t\telif i == 4:\n\t\t\t\treturn op.ask_price\n\t\t\telif i == 5:\n\t\t\t\treturn op.ask_amount\n\t\t\telif i == 6:\n\t\t\t\treturn size * op.delta\n\t\t\telif i == 7:\n\t\t\t\treturn size * op.gamma\n\t\t\telif i == 8:\n\t\t\t\treturn size * op.vega\n\t\t\telif i == 9:\n\t\t\t\treturn size * op.theta\n\t\t\telse:\n\t\t\t\treturn 0"]}
{"filename": "src/optarber/optimise_params.py", "chunked_list": ["class OptimiseParams:\n    def __init__(self):\n        self.minimize = True\n        self.currObjective = \"Min Cost\"\n        self.maxDeltaPct = 0.01\n        self.minTheta = 5\n        self.minGammaBps = 0.001\n        self.putNeutral = True\n        self.callNeutral = True\n        self.positiveVega = True\n        self.longPut = True\n        self.longCall = True\n        self.maxUnit = 5\n        self.maxTotal = 15\n        self.usePositions = True\n        self.maxSpreadBps = 0.001\n        self.contract_size = 1\n        self.doubleFee = True\n\n    @staticmethod\n    def create_default():\n        return OptimiseParams()"]}
{"filename": "src/optarber/account_data.py", "chunked_list": ["\nclass AccountData:\n\tdef __init__(self):\n\t\tself.currency = None\n\t\tself.equity = 0\n\t\tself.availableMargin = 0\n\t\tself.initialMargin = 0\n\t\tself.maintenanceMargin = 0\n\t\tself.withdrawableFunds = 0\n\t\tself.PnL = 0\n\t\tself.delta = 0\n\t\tself.gamma = 0\n\t\tself.vega = 0\n\t\tself.theta = 0\n\t\tself.rows = 11\n\t\tself.cols = 2\n\t\n\tdef clear(self):\n\t\tself.currency = \"\"\n\t\tself.equity = 0\n\t\tself.availableMargin = 0\n\t\tself.initialMargin = 0\n\t\tself.maintenanceMargin = 0\n\t\tself.withdrawableFunds = 0\n\t\tself.PnL = 0\n\t\tself.delta = 0\n\t\tself.gamma = 0\n\t\tself.vega = 0\n\t\tself.theta = 0\n\t\tself.rows = 11\n\t\tself.cols = 2\n\n\tdef update(self, dict_obj):\n\t\tself.currency = dict_obj['currency']\n\t\tself.equity = dict_obj[\"equity\"]\n\t\tself.availableMargin = dict_obj[\"margin_balance\"]\n\t\tself.initialMargin = dict_obj[\"initial_margin\"]\n\t\tself.maintenanceMargin = dict_obj[\"maintenance_margin\"]\n\t\tself.withdrawableFunds = dict_obj[\"available_withdrawal_funds\"]\n\t\tself.PnL = dict_obj[\"total_pl\"]\n\t\tself.delta = dict_obj[\"options_delta\"]\n\t\tself.gamma = dict_obj[\"options_gamma\"]\n\t\tself.vega = dict_obj[\"options_vega\"]\n\t\tself.theta = dict_obj[\"options_theta\"]\n\t\t\n\tdef getRows(self):\n\t\treturn self.rows\n\t\t\n\tdef getCols(self):\n\t\treturn self.cols\n\t\t\n\tdef getData(self, i, j):\n\t\tif j == 0:\n\t\t\tif i == 0:\n\t\t\t\treturn \"Currency\"\n\t\t\telif i == 1:\n\t\t\t\treturn \"Equity\"\n\t\t\telif i == 2:\n\t\t\t\treturn \"margin_bal\"\n\t\t\telif i == 3:\n\t\t\t\treturn \"init_margin\"\n\t\t\telif i == 4:\n\t\t\t\treturn \"mnt_margin\"\n\t\t\telif i == 5:\n\t\t\t\treturn \"avlble_funds\"\n\t\t\telif i == 6:\n\t\t\t\treturn \"PnL\"\n\t\t\telif i == 7:\n\t\t\t\treturn \"Delta\"\n\t\t\telif i == 8:\n\t\t\t\treturn \"Gamma\"\n\t\t\telif i == 9:\n\t\t\t\treturn \"Vega\"\n\t\t\telif i == 10:\n\t\t\t\treturn \"Theta\"\n\t\t\telse:\n\t\t\t\treturn \"\"\n\t\telse:\n\t\t\tif i == 0:\n\t\t\t\treturn self.currency\n\t\t\telif i == 1:\n\t\t\t\treturn self.equity\n\t\t\telif i == 2:\n\t\t\t\treturn self.availableMargin\n\t\t\telif i == 3:\n\t\t\t\treturn self.initialMargin\n\t\t\telif i == 4:\n\t\t\t\treturn self.maintenanceMargin\n\t\t\telif i == 5:\n\t\t\t\treturn self.withdrawableFunds\n\t\t\telif i == 6:\n\t\t\t\treturn self.PnL\n\t\t\telif i == 7:\n\t\t\t\treturn self.delta\n\t\t\telif i == 8:\n\t\t\t\treturn self.gamma\n\t\t\telif i == 9:\n\t\t\t\treturn self.vega\n\t\t\telif i == 10:\n\t\t\t\treturn self.theta\n\t\t\telse:\n\t\t\t\treturn 0"]}
{"filename": "src/optarber/account_model.py", "chunked_list": ["from PyQt6 import QtCore, QtGui\nfrom account_data import AccountData\n\nclass AccountModel(QtCore.QAbstractTableModel): \n    def __init__(self, parent=None, *args): \n        super(AccountModel, self).__init__()\n        self.accountData = None\n\n        \n    def update(self, accountData):\n        self.accountData = accountData\n\n     \n    def rowCount(self, parent=QtCore.QModelIndex()):\n        return self.accountData.getRows()\n\n        \n    def columnCount(self, parent=QtCore.QModelIndex()):\n        return self.accountData.getCols()\n\n        \n    def data(self, index, role=QtCore.Qt):\n        if self.accountData is not None:\n            i = index.row()\n            j = index.column()\n\n            if role == QtCore.Qt.ItemDataRole.DisplayRole:\n                if j == 0 or i == 0:\n                    return '{0}'.format(self.accountData.getData(i, j))\n                elif i > 0 and j == 1:\n                    return '{:.8f}'.format(self.accountData.getData(i, j))\n            elif role == QtCore.Qt.ItemDataRole.TextAlignmentRole:\n                if j == 1:\n                    return QtCore.Qt.AlignmentFlag.AlignRight\n            elif role == QtCore.Qt.ItemDataRole.ForegroundRole:\n                if j == 1 and i > 0:\n                    if self.accountData.getData(i, j) > 0:\n                        return QtGui.QBrush(QtCore.Qt.GlobalColor.darkBlue)\n                    elif self.accountData.getData(i, j) < 0:\n                        return QtGui.QBrush(QtCore.Qt.GlobalColor.darkRed)\n            return QtCore.QVariant()"]}
{"filename": "src/optarber/position_model.py", "chunked_list": ["from PyQt6 import QtCore, QtGui\n\nclass PositionModel(QtCore.QAbstractTableModel): \n    def __init__(self, parent=None, *args): \n        super(PositionModel, self).__init__()\n        self.positionData = None\n\n        \n    def update(self, positionData):\n        self.positionData = positionData\n     \n    def rowCount(self, parent=QtCore.QModelIndex()):\n        return self.positionData.getRows()\n\n        \n    def columnCount(self, parent=QtCore.QModelIndex()):\n        return self.positionData.getCols()\n\n        \n    def data(self, index, role=QtCore.Qt):\n        if self.positionData is not None:\n            i = index.row()\n            j = index.column()\n\n            if role == QtCore.Qt.ItemDataRole.DisplayRole:\n                if j == 0 or i == 0:\n                    return '{0}'.format(self.positionData.getData(i, j))\n                elif i > 0 and j > 0:\n                    return '{:.4f}'.format(self.positionData.getData(i, j))\n            elif role == QtCore.Qt.ItemDataRole.TextAlignmentRole:\n                if j > 0 and i > 0:\n                    return QtCore.Qt.AlignmentFlag.AlignRight\n            elif role == QtCore.Qt.ItemDataRole.ForegroundRole:\n                if j > 0 and i > 0:\n                    if self.positionData.getData(i, j) > 0:\n                        return QtGui.QBrush(QtCore.Qt.GlobalColor.darkBlue)\n                    elif self.positionData.getData(i, j) < 0:\n                        return QtGui.QBrush(QtCore.Qt.GlobalColor.darkRed)\n            return QtCore.QVariant()"]}
{"filename": "src/optarber/optimizer.py", "chunked_list": ["import cvxpy as cvx\nimport numpy as np\nfrom deribit_option_position import DeribitPosition\n\nclass Optimizer:\n    def __init__(self, params, fetches, positions):\n        self.params = params\n        self.fetches = fetches\n        self.positions = positions\n\n    def compute(self):\n        option_dict = {}\n        for op in self.fetches:\n            if op.ask_price is not None and op.bid_price is not None:\n                if (op.ask_price - op.bid_price) <= self.params.maxSpreadBps:\n                    option_dict[op.name] = op\n\n        for pos in self.positions:\n            if pos.op.name not in option_dict:\n                if self.params.usePositions:\n                    option_dict[pos.op.name] = pos.op\n            else:\n                if not self.params.usePositions:\n                    option_dict.pop(pos.op.name)\n\n        option_data = list(option_dict.values())\n\n        N = len(option_data)\n        deltas = np.zeros(N)\n        gammas = np.zeros(N)\n        vegas = np.zeros(N)\n        thetas = np.zeros(N)\n        bids = np.zeros(N)\n        bidamounts = np.zeros(N)\n        askamounts = np.zeros(N)\n        asks = np.zeros(N)\n        calls = np.zeros(N)\n        puts = np.zeros(N)\n        strikes = np.zeros(N)\n\n        for i in range(0, N):\n            deltas[i] = option_data[i].delta\n            gammas[i] = option_data[i].gamma\n            vegas[i] = option_data[i].vega\n            thetas[i] = option_data[i].theta\n            bids[i] = option_data[i].bid_price\n            asks[i] = option_data[i].ask_price\n            bidamounts[i] = option_data[i].bid_amount / self.params.contract_size\n            askamounts[i] = option_data[i].ask_amount / self.params.contract_size\n            kind = 1 if option_data[i].kind[0] == 'c' else -1\n            calls[i] = max(kind, 0)\n            puts[i] = min(kind, 0)\n            strikes[i] = option_data[i].strike\n        \n        res = self._calculate(list(option_dict.keys()), deltas, gammas, vegas, thetas, bids, asks, bidamounts, askamounts, calls, puts, strikes)\n\n        selections = []\n\n        if res is not None:\n            for i, op in enumerate(option_data):\n                if res[0, i] != 0:\n                    p = DeribitPosition(op, res[0, i])\n                    selections.append(p)\n\n        return selections\n\n    def _calculate(self, option_names, deltas, gammas, vegas, thetas, bids, asks, bidamounts, askamounts, calls, puts, strikes):\n        N = len(option_names)\n\n        if N == 0:\n            return None\n        \n        x = cvx.Variable((1, N), integer=True)\n        y = cvx.Variable((1, N), integer=True)\n        p = cvx.Variable((1, N), integer=True)\n\n        obj = None\n\n        if self.params.currObjective == \"Min Cost\":\n            obj = cvx.Minimize(x@asks + y@bids)\n        elif self.params.currObjective == \"Max Gamma\":\n            obj = cvx.Maximize((x+y+p)@gammas)\n        elif self.params.currObjective == \"Max Theta\":\n            obj = cvx.Maximize((x+y+p)@thetas)\n        else:\n            return None\n        \n        cons = [(x+y+p)@deltas <= self.params.maxDeltaPct, \n                (x+y+p)@deltas >= -self.params.maxDeltaPct]\n        cons.append((x+y+p)@gammas >= self.params.minGammaBps)\n        cons.append((x+y+p)@thetas >= self.params.minTheta)\n        if self.params.positiveVega: cons.append((x+y+p)@vegas >= 0)\n        if self.params.callNeutral: cons.append((x+y+p)@calls == 0)\n        if self.params.putNeutral: cons.append((x+y+p)@puts == 0)\n        if self.params.longPut: cons.append(cvx.multiply(y[0, :] + x[0, :] + p[0, :], puts)@strikes <= 0)\n        if self.params.longCall: cons.append(cvx.multiply(y[0, :] + x[0, :] + p[0, :], calls)@strikes >= 0)\n        cons.append(x <= self.params.maxUnit)\n        cons.append(x >= 0)\n        cons.append(y >= -self.params.maxUnit)\n        cons.append(y <= 0)\n        cons.append(cvx.sum(x + cvx.pos(p)) <= self.params.maxTotal)\n        cons.append(cvx.sum(y - cvx.neg(p)) >= -self.params.maxTotal)\n        \n        sizes = np.zeros((1, N))\n        if self.params.usePositions:\n            for pos in self.positions:\n                idx = option_names.index(pos.op.name)\n                sizes[0, idx] = pos.size  / self.params.contract_size\n        cons.append(p == np.asarray(sizes))\n\n        for i in range(N):\n            cons.append(x[0, i] <= askamounts[i])\n            cons.append(y[0, i] >= -bidamounts[i])\n\n        prob = cvx.Problem(objective=obj, constraints=cons)\n        prob.solve(verbose=1)\n        \n        if prob.status == 'optimal':\n            return np.around((x.value + y.value) * self.params.contract_size, 1)\n        else:\n            return None"]}
{"filename": "src/optarber/program.py", "chunked_list": ["import sys\nfrom mainUI import Ui_optionAtillaWindow\nfrom optionAtilla import Atilla\nfrom PyQt6 import QtCore\nfrom PyQt6.QtWidgets import QApplication, QMainWindow\n\nif __name__ == '__main__':\n    app = QApplication(sys.argv)\n    window = QMainWindow()\n    ui = Ui_optionAtillaWindow()\n    ui.setupUi(window)\n    atilla = Atilla(app, \"config.ini\")\n    atilla.setWindow(ui, window)\n    window.show()\n    sys.exit(app.exec())", ""]}
{"filename": "src/optarber/optionAtilla.py", "chunked_list": ["import configparser\nfrom datetime import datetime as dt\nimport opstrat\nfrom account_data import AccountData\nfrom image_viewer import ImageViewer\nfrom position_data import PositionData\nfrom results_data import Results\nfrom selection_data import SelectionData\nfrom account_model import AccountModel\nfrom optimise_params import OptimiseParams", "from account_model import AccountModel\nfrom optimise_params import OptimiseParams\nfrom optimizer import Optimizer\nfrom deribit_option import Option\nfrom deribit_option_position import DeribitPosition\nfrom position_model import PositionModel\nfrom results_model import ResultsModel\nfrom selection_model import SelectionModel\nfrom deribit_rest import RestClient\nfrom deribit_ws import Deribit_WS", "from deribit_rest import RestClient\nfrom deribit_ws import Deribit_WS\nfrom PyQt6 import QtCore\n\nclass Atilla(QtCore.QObject):\n\tdef __init__(self, parent, config_file):\n\t\tsuper().__init__(parent)\n\t\tself.parent = parent\n\t\tself.currency = None\n\t\tself.counter = 0\n\t\tself.subscriptions = 0\n\t\tself.subscribed = set()\n\t\tself.market_cache = {}\n\t\tself.fetches = []\n\t\tself.account = AccountData()\n\t\tself.positions = PositionData()\n\t\tself.selections = SelectionData()\n\t\tself.results = Results()\n\t\tself.account_model = AccountModel(parent)\n\t\tself.position_model = PositionModel(parent)\n\t\tself.selection_model = SelectionModel(parent)\n\t\tself.results_model = ResultsModel(parent)\n\t\tself.account_model.update(self.account)\n\t\tself.position_model.update(self.positions)\n\t\tself.selection_model.update(self.selections)\n\t\tself.results_model.update(self.results)\n\t\t\n\t\tself.cfg = configparser.ConfigParser()\n\t\tself.cfg.read(config_file)\n\t\tself.client_ws = None\n\t\tself.client_rest = None\n\t\tself.window = None\n\t\tself.mainW = None\n\n\n\tdef setWindow(self, window, mainW):\n\t\tself.window = window\n\t\tself.mainW = mainW\n\t\tself.window.tableViewAccount.setModel(self.account_model)\n\t\tself.window.tableViewPositions.setModel(self.position_model)\n\t\tself.window.tableViewResults.setModel(self.results_model)\n\t\tself.window.tableViewSelections.setModel(self.selection_model)\n\t\tself.window.pushButtonConnect.clicked.connect(self.connect)\n\t\tself.window.pushButtonClose.clicked.connect(self.close)\n\t\tself.window.pushButtonFetch.clicked.connect(self.fetch)\n\t\tself.window.pushButtonPositions.clicked.connect(self.queryPos)\n\t\tself.window.pushButtonDisplay.clicked.connect(self.display)\n\t\tself.window.pushButtonCompute.clicked.connect(self.compute)\n\t\tself.window.pushButtonRefresh.clicked.connect(self.computeResults)\n\t\tself.window.pushButtonClearSelection.clicked.connect(self.clearSelections)\n\t\tself.window.pushButtonTrade.clicked.connect(self.execute)\n\t\tQtCore.QMetaObject.connectSlotsByName(self)\n\t\n\n\tdef close(self):\n\t\tself.disconnect()\n\t\tself.window.centralwidget.close()\n\n\tdef authenticate(self):\n\t\tself.client_ws.authenticate()\n\t\tprint(\"sent authenticate request\")\n\n\tdef getChanges(self):\n\t\tcurr = self.window.comboCurr.currentText()\n\t\tself.client_ws.account_summary(curr)\n\t\tself.client_ws.change_summary(curr)\n\n\n\tdef connect(self):\n\t\tself.disconnect()\n\t\tkey = self.window.comboEnv.currentText()\n\t\tcurr = self.window.comboCurr.currentText()\n\n\t\tapi_key = self.cfg[key][\"api_key\"]\n\t\tapi_secret = self.cfg[key][\"api_secret\"]\n\t\tws_url = self.cfg[key][\"ws_url\"]\n\n\t\tself.client_rest = RestClient(api_key, api_secret, False if key == \"PROD\" else True)\n\t\tself.client_ws = Deribit_WS(self.parent)\n\t\tself.client_ws.connect(self, api_key, api_secret, ws_url)\n\t\tQtCore.QTimer.singleShot(3000, self.authenticate)\n\t\tQtCore.QTimer.singleShot(6000, self.getChanges)\n\n\n\tdef onMarketData(self, mkt_data):\n\t\tinstr = mkt_data['instrument_name']\n\n\t\tif instr not in self.subscribed:\n\t\t\tself.subscribed.add(instr)\n\t\t\tself.window.progressBarFetch.setVisible(False)\n\t\t\tself.window.progressBarFetch.setValue(len(self.subscribed) * 100.0 / self.counter)\n\t\t\tself.window.progressBarFetch.setVisible(True)\n\n\t\tgreeks = mkt_data['greeks']\n\t\topt = self.market_cache[instr]\n\t\topt.delta = greeks['delta']\n\t\topt.gamma = greeks['gamma'] \n\t\topt.vega=greeks['vega']\n\t\topt.theta = greeks['theta']\n\t\topt.bid_price = mkt_data['best_bid_price']\n\t\topt.bid_amount = mkt_data['best_bid_amount']\n\t\topt.ask_price = mkt_data['best_ask_price']\n\t\topt.ask_amount = mkt_data['best_ask_amount']\n\t\tself.window.tableViewPositions.viewport().update()\n\t\tself.window.tableViewSelections.viewport().update()\n\t\t\n\tdef onAccountData(self, dict_obj):\n\t\tself.account.update(dict_obj)\n\t\tself.window.tableViewAccount.viewport().update()\n\n\tdef onPositionCreate(self, positions):\n\t\tself.position_model.beginResetModel()\n\t\tself.positions.add(positions)\n\t\tself.position_model.endResetModel()\n\t\tself.window.tableViewPositions.resizeColumnsToContents()\n\t\tself.window.tableViewPositions.viewport().update()\n\n\n\tdef onPositionData(self, positions):\n\t\tself.positions.update(positions)\n\t\tself.window.tableViewPositions.viewport().update()\n\n\tdef disconnect(self):\n\t\tif self.client_ws is not None:\n\t\t\tself.client_ws.close()\n\t\t\tself.client_ws = None\n\n\t\tself.account_model.beginResetModel()\n\t\tself.position_model.beginResetModel()\n\t\tself.selection_model.beginResetModel()\n\t\tself.results_model.beginResetModel()\n\t\tself.account.clear()\n\t\tself.positions.clear()\n\t\tself.market_cache.clear()\n\t\tself.subscribed.clear()\n\t\tself.selections.clear()\n\t\tself.results.clear()\n\t\tself.account_model.endResetModel()\n\t\tself.position_model.endResetModel()\n\t\tself.selection_model.endResetModel()\n\t\tself.results_model.endResetModel()\n\t\tself.counter = 0\n\t\tself.subscriptions = 0\n\t\tself.fetches = []\n\n\tdef queryPos(self):\n\t\tcurr = self.window.comboCurr.currentText()\n\t\tpositions = self.client_rest.getpositions(curr, \"option\")\n\t\tnow = dt.today()\n\t\tresults = []\n\t\tfor pos in positions:\n\t\t\tname = pos['instrument_name']\n\t\t\tinstr = self.client_rest.getinstrument(name)\n\t\t\texpiry = self.timestamp_to_datetime(instr['expiration_timestamp'])\n\t\t\tdays_left = (expiry - now).days\n\t\t\tsize = pos['size']\n\t\t\topt = Option(name, instr['option_type'], days_left, instr['strike'], \n\t\t                 pos['delta'] / size,pos['gamma'] / size,pos['vega'] / size, pos['theta'] / size,0,0,0,0)\n\t\t\tdpos = DeribitPosition(opt, pos['size'])\n\t\t\tresults.append(dpos)\n\t\t\tif name not in self.market_cache.keys():\n\t\t\t\tself.market_cache[name] = opt\n\t\t\t\tself.counter += 1\n\t\t\t\tQtCore.QThread.msleep(100)\n\t\t\t\tself.client_ws.ticker(name)\n\t\tself.onPositionCreate(results)\n\n\tdef fetch(self):\n\t\tself.window.progressBarFetch.setValue(0)\n\t\tself.fetches = []\n\t\tcurr = self.window.comboCurr.currentText()\n\t\tpctStrike = self.window.spinBoxStrikePercent.value() / 100.0\n\t\tminExpiry = self.window.spinBoxMinExpiry.value()\n\t\tmaxExpiry = self.window.spinBoxMaxExpiry.value()\n\t\tresponse = self.client_rest.getindex(curr)\n\t\tidxPrice = response[curr]\n\t\tnow = dt.today()\n\t\tself.queryPos()\n\t\tself.fetchInstruments(now, curr, idxPrice, pctStrike, minExpiry, maxExpiry)\n\t\tself.window.progressBarFetch.setValue(len(self.subscribed) * 100.0 / self.counter)\n\t\tself.window.labelNumOfOptions.setText(str(self.counter) + \" options\")\n\n\tdef timestamp_to_datetime(self, timestamp): \n\t\treturn dt.fromtimestamp(timestamp/1000)\n\n\n\tdef fetchInstruments(self, now, curr, idxPrice, pctStrike, minExpiry, maxExpiry):\n\t\tinstrs = self.client_rest.getinstruments(curr, \"option\")\n\t\tminStrike = (1.0 - pctStrike) * idxPrice\n\t\tmaxStrike = (1.0 + pctStrike) * idxPrice\n\n\t\tfor instr in instrs:\n\t\t\tif instr['option_type'] == 'call' and instr['strike'] < idxPrice:\n\t\t\t\tcontinue\n\n\t\t\tif instr['option_type'] == 'put' and instr['strike'] > idxPrice:\n\t\t\t\tcontinue\n\n\t\t\tif instr['strike'] >= minStrike and instr['strike'] <= maxStrike:\n\t\t\t\texpiry = instr['expiration_timestamp']\n\t\t\t\tdays_left = (self.timestamp_to_datetime(expiry) - now).days\n\n\t\t\t\tif days_left >= minExpiry and days_left <= maxExpiry:\n\t\t\t\t\tname = instr['instrument_name']\n\t\t\t\t\tif name not in self.market_cache.keys():\n\t\t\t\t\t\tself.market_cache[name] = Option(name, instr['option_type'], days_left,\n\t\t\t\t\t                                      instr['strike'], 0,0,0,0,0,0,0,0)\n\t\t\t\t\t\tself.counter += 1\n\t\t\t\t\t\tQtCore.QThread.msleep(300)\n\t\t\t\t\t\tself.client_ws.ticker(name)\n\t\t\t\t\tself.fetches.append(self.market_cache[name])\n\t\t\t\t\t\n\n\tdef display(self):\n\t\tpositions = self.positions.positions\n\t\toplist = []\n\t\tcurr = self.window.comboCurr.currentText()\n\t\t\n\t\tcontract_size = 1\n\t\tif curr == \"BTC\":\n\t\t\tcontract_size = 0.1\n\t\t\n\t\tfor posit in positions:\n\t\t\tpos = posit.op\n\t\t\top = {'op_type': pos.kind[0],\n            \t\t'strike': pos.strike,\n            \t\t'tr_type': 'b' if posit.size > 0 else 's',\n            \t\t'op_pr': pos.bid_price if posit.size < 0 else pos.ask_price,\n            \t\t'contract': abs(int(posit.size / contract_size))}\n\t\t\toplist.append(op)\n\n\t\tfor posit in self.selections.positions:\n\t\t\tpos = posit.op\n\t\t\top = {'op_type': pos.kind[0],\n            \t\t'strike': pos.strike,\n            \t\t'tr_type': 'b' if posit.size > 0 else 's',\n            \t\t'op_pr': pos.bid_price if posit.size < 0 else pos.ask_price,\n            \t\t'contract': abs(int(posit.size / contract_size))}\n\t\t\toplist.append(op)\n\n\t\tidx_price = self.client_rest.getindex(curr)[curr]\n\t\topstrat.multi_plotter(spot=idx_price, spot_range=20, op_list=oplist, save=True, file='file.png')\n\t\tviewer = ImageViewer()\n\t\tviewer.update()\n\t\tviewer.show()\n\t\tviewer.deleteLater()\n\n\tdef create_optimiser_params(self):\n\t\tcurr = self.window.comboCurr.currentText()\n\t\tparams = OptimiseParams.create_default()\n\t\t\n\t\tif curr == 'BTC':\n\t\t\tparams.contract_size = 0.1\n\t\telse:\n\t\t\tparams.contract_size = 1\n\n\t\tparams.currObjective = self.window.comboObjective.currentText()\n\t\tparams.maxDeltaPct = self.window.spinDelta.value() / 100.0\n\t\tparams.minGammaBps = self.window.spinGamma.value() / 10000.0\n\t\tparams.minTheta = self.window.spinMinTheta.value()\n\t\tparams.positiveVega = self.window.checkVega.isChecked()\n\t\tparams.putNeutral = self.window.checkPutNeutral.isChecked()\n\t\tparams.callNeutral = self.window.checkCallNeutral.isChecked()\n\t\tparams.longPut = self.window.checkLongPut.isChecked()\n\t\tparams.longCall = self.window.checkLongCall.isChecked()\n\t\tparams.usePositions = self.window.checkPositions.isChecked()\n\t\tparams.maxUnit = self.window.spinMaxUnit.value()\n\t\tparams.maxTotal = self.window.spinMaxTotal.value()\n\t\tparams.maxSpreadBps = self.window.spinBoxSpread.value() / 10000.0\n\t\tparams.doubleFee = self.window.checkDoubleFee.isChecked()\n\t\treturn params\n\n\n\tdef clearSelections(self):\n\t\tself.selection_model.beginResetModel()\n\t\tself.selections.update([])\n\t\tself.selection_model.endResetModel()\n\n\n\tdef compute(self):\n\t\tparams = self.create_optimiser_params()\n\t\toptim = Optimizer(params, self.fetches, self.positions.positions)\n\t\tselections = optim.compute()\n\t\tself.selection_model.beginResetModel()\n\t\tself.selections.update(selections)\n\t\tself.selection_model.endResetModel()\n\t\tself.window.tableViewSelections.resizeColumnsToContents()\n\t\tself.window.tableViewSelections.viewport().update()\n\t\tself.computeResults()\n\n\n\tdef computeResults(self):\n\t\tpositions = []\n\t\tpositions.extend(self.positions.positions)\n\t\tpositions.extend(self.selections.positions)\n\t\tfeeBps = 0.0006 if self.window.checkDoubleFee.isChecked() else 0.0003\n\t\t\n\t\tself.results_model.beginResetModel()\n\t\tself.results.clear()\n\t\t\n\t\tinstrs = {}\n\t\tposCheck = self.window.checkPositions.isChecked()\n\n\t\tfor pos in positions:\n\t\t\tself.results.delta += pos.size * pos.op.delta\n\t\t\tself.results.gamma += pos.size * pos.op.gamma\n\t\t\tself.results.vega += pos.size * pos.op.vega\n\t\t\tself.results.theta += pos.size * pos.op.theta\n\t\t\n\t\t\tif not posCheck and pos in self.positions.positions:\n\t\t\t\tcontinue\n\t\t\telse:\n\t\t\t\tif pos.op.name in instrs:\n\t\t\t\t\tinstrs[pos.op.name] += pos.size\n\t\t\t\telse:\n\t\t\t\t\tinstrs[pos.op.name] = pos.size\n\t\t\n\n\t\tfor pos in self.selections.positions:\n\t\t\tcost = pos.size * (pos.op.bid_price if pos.size < 0 else pos.op.ask_price)\n\t\t\tself.results.income += cost\n\t\t\tself.results.fees += min(abs(pos.size * feeBps), abs(cost) * 0.125)\n\t\n\t\tself.results.net_income = -self.results.income - self.results.fees\n\t\tcurr = self.window.comboCurr.currentText()\n\n\t\tif len(instrs) > 0:\n\t\t\tres = self.client_rest.getportfoliomargin(curr, instrs)\n\t\t\tself.results.margin = res['margin']\n\t\telse:\n\t\t\tself.results.margin = 0\n\n\t\tminExpiry = 10000000\n\t\tfor pos in positions:\n\t\t\tif pos.op.expiry < minExpiry:\n\t\t\t\tminExpiry = pos.op.expiry\n\n\t\tinstrs = {}\n\t\tfor pos in positions:\n\t\t\tif pos.op.expiry <= minExpiry:\n\t\t\t\tcontinue\n\t\t\t\n\t\t\tif not posCheck and pos in self.positions.positions:\n\t\t\t\tcontinue\n\n\t\t\tif pos.op.name not in instrs:\n\t\t\t\tinstrs[pos.op.name] = pos.size\n\t\t\telse:\n\t\t\t\tinstrs[pos.op.name] += pos.size\n\n\t\tif len(instrs) > 0:\n\t\t\tres = self.client_rest.getportfoliomargin(curr, instrs)\n\t\t\tself.results.expiryMargin = res['margin']\n\t\telse:\n\t\t\tself.results.expiryMargin = 0\n\n\t\tself.results_model.endResetModel()\n\t\tself.window.tableViewResults.resizeColumnsToContents()\n\t\tself.window.tableViewResults.viewport().update()\n\t\n\tdef execute(self):\n\t\tif len(self.selections.positions) == 0:\n\t\t\tprint(\"No positions to execute\")\n\t\t\treturn\n\t\t\n\t\tbuycalls = {}\n\t\tsellcalls = {}\n\t\tbuyputs = {}\n\t\tsellputs = {}\n\n\t\tfor pos in self.selections.positions:\n\t\t\tif pos.op.kind[0] == \"c\":\n\t\t\t\tif pos.size > 0:\n\t\t\t\t\tif pos.op.strike not in buycalls:\n\t\t\t\t\t\tbuycalls[pos.op.strike] = []\n\t\t\t\t\tbuycalls[pos.op.strike].append(pos)\n\t\t\t\telse:\n\t\t\t\t\tif pos.op.strike not in sellcalls:\n\t\t\t\t\t\tsellcalls[pos.op.strike] = []\n\t\t\t\t\tsellcalls[pos.op.strike].append(pos)\n\t\t\telse:\n\t\t\t\tif pos.size > 0:\n\t\t\t\t\tif pos.op.strike not in buyputs:\n\t\t\t\t\t\tbuyputs[pos.op.strike] = []\n\t\t\t\t\tbuyputs[pos.op.strike].append(pos)\n\t\t\t\telse:\n\t\t\t\t\tif pos.op.strike not in sellputs:\n\t\t\t\t\t\tsellputs[pos.op.strike] = []\n\t\t\t\t\tsellputs[pos.op.strike].append(pos)\n\t\t\n\t\tbuycalls = {k: v for k, v in sorted(buycalls.items(), key=lambda item: item[0], reverse=True)}\n\t\tbuyputs = {k: v for k, v in sorted(buyputs.items(), key=lambda item: item[0])}\n\t\tsellcalls = {k: v for k, v in sorted(sellcalls.items(), key=lambda item: item[0])}\n\t\tsellputs = {k: v for k, v in sorted(sellputs.items(), key=lambda item: item[0], reverse=True)}\n\n\t\tcalls = []\n\t\tputs = []\n\n\t\tfor strike in buycalls:\n\t\t\tcalls.extend(buycalls[strike])\n\n\t\tfor strike in sellcalls:\n\t\t\tcalls.extend(sellcalls[strike])\n\n\t\tfor strike in buyputs:\n\t\t\tputs.extend(buyputs[strike])\n\n\t\tfor strike in sellputs:\n\t\t\tputs.extend(sellputs[strike])\n\n\t\tself.execOptions(calls)\t\t\n\t\tself.execOptions(puts)\n\n\tdef execOptions(self, opts):\n\t\t\n\t\twhile len(opts) > 0:\n\t\t\tpos = opts[0]\n\t\t\tdel opts[0]\n\t\t\tif pos.size > 0:\n\t\t\t\tres = self.client_rest.buy(pos.op.name, pos.size, pos.op.ask_price)\n\t\t\telse:\n\t\t\t\tres = self.client_rest.sell(pos.op.name, abs(pos.size), pos.op.bid_price)\n\n\t\t\tif len(opts) > 0:\n\t\t\t\tpos = opts[-1]\n\t\t\t\tdel opts[-1]\n\t\t\t\t\n\t\t\t\tif pos.size > 0:\n\t\t\t\t\tres = self.client_rest.buy(pos.op.name, pos.size, pos.op.ask_price)\n\t\t\t\telse:\n\t\t\t\t\tres = self.client_rest.sell(pos.op.name, abs(pos.size), pos.op.bid_price)\n\n\t\t\tif 'trades' in res:\n\t\t\t\tprint(len(res['trades']))\n\t\t\telse:\n\t\t\t\tprint(res)", "\n\n\n\n\t\t\n\n\n"]}
{"filename": "src/optarber/results_data.py", "chunked_list": ["\nclass Results:\n\tdef __init__(self):\n\t\tself.delta = 0\n\t\tself.gamma = 0\n\t\tself.vega = 0\n\t\tself.theta = 0\n\t\tself.net_income = 0\n\t\tself.income = 0\n\t\tself.fees = 0\n\t\tself.margin = 0\t\t\n\t\tself.expiryMargin = 0\n\t\tself.cols = 9\n\t\n\tdef clear(self):\n\t\tself.delta = 0\n\t\tself.gamma = 0\n\t\tself.vega = 0\n\t\tself.theta = 0\n\t\tself.net_income = 0\n\t\tself.income = 0\n\t\tself.fees = 0\n\t\tself.margin = 0\t\t\n\t\tself.expiryMargin = 0\n\t\tself.cols = 9\n\n\tdef getRows(self):\n\t\treturn 2\n\t\t\n\tdef getCols(self):\n\t\treturn self.cols\n\t\t\n\tdef getData(self, j, i):\n\t\tif j == 0:\n\t\t\tif i == 0:\n\t\t\t\treturn \"Delta\"\n\t\t\telif i == 1:\n\t\t\t\treturn \"Gamma\"\n\t\t\telif i == 2:\n\t\t\t\treturn \"Vega\"\n\t\t\telif i == 3:\n\t\t\t\treturn \"Theta\"\n\t\t\telif i == 4:\n\t\t\t\treturn \"NetIncome\"\n\t\t\telif i == 5:\n\t\t\t\treturn \"Income\"\n\t\t\telif i == 6:\n\t\t\t\treturn \"Fees\"\n\t\t\telif i == 7:\n\t\t\t\treturn \"Margin\"\n\t\t\telif i == 8:\n\t\t\t\treturn \"Next Margin\"\n\t\t\telse:\n\t\t\t\treturn \"\"\n\t\telse:\n\t\t\tif i == 0:\n\t\t\t\treturn self.delta\n\t\t\telif i == 1:\n\t\t\t\treturn self.gamma\n\t\t\telif i == 2:\n\t\t\t\treturn self.vega\n\t\t\telif i == 3:\n\t\t\t\treturn self.theta\n\t\t\telif i == 4:\n\t\t\t\treturn self.net_income\n\t\t\telif i == 5:\n\t\t\t\treturn self.income\n\t\t\telif i == 6:\n\t\t\t\treturn self.fees\n\t\t\telif i == 7:\n\t\t\t\treturn self.margin\n\t\t\telif i == 8:\n\t\t\t\treturn self.expiryMargin\n\t\t\telse:\n\t\t\t\treturn 0"]}
{"filename": "src/optarber/ccxt_test.py", "chunked_list": ["import ccxt\nimport configparser\nimport json\n\nif __name__ == '__main__':\n    cfg = configparser.ConfigParser()\n    cfg.read(\"config\\\\config.ini\")\n    key = \"TEST\"\n    api_key = cfg[key][\"api_key\"]\n    api_secret = cfg[key][\"api_secret\"]\n    exch = ccxt.deribit({'apiKey': api_key, 'secret': api_secret})\n    exch.set_sandbox_mode(True)\n    exch.quoteJsonNumbers = False\n    response = exch.fetch2(\"get_portfolio_margins\", \"private\", params={\"currency\": \"BTC\"})\n    print(response)"]}
{"filename": "src/optarber/selection_model.py", "chunked_list": ["from PyQt6 import QtCore, QtGui\n\nclass SelectionModel(QtCore.QAbstractTableModel): \n    def __init__(self, parent=None, *args): \n        super(SelectionModel, self).__init__()\n        self.selectionData = None\n\n        \n    def update(self, selectionData):\n        self.selectionData = selectionData\n     \n    def rowCount(self, parent=QtCore.QModelIndex()):\n        return self.selectionData.getRows()\n\n        \n    def columnCount(self, parent=QtCore.QModelIndex()):\n        return self.selectionData.getCols()\n\n        \n    def data(self, index, role=QtCore.Qt):\n        if self.selectionData is not None:\n            i = index.row()\n            j = index.column()\n\n            if role == QtCore.Qt.ItemDataRole.DisplayRole:\n                if j == 0 or i == 0:\n                    return '{0}'.format(self.selectionData.getData(i, j))\n                elif i > 0 and j > 0:\n                    return '{:.4f}'.format(self.selectionData.getData(i, j))\n            elif role == QtCore.Qt.ItemDataRole.TextAlignmentRole:\n                if j > 0 and i > 0:\n                    return QtCore.Qt.AlignmentFlag.AlignRight\n            elif role == QtCore.Qt.ItemDataRole.ForegroundRole:\n                if j > 0 and i > 0:\n                    if self.selectionData.getData(i, j) > 0:\n                        return QtGui.QBrush(QtCore.Qt.GlobalColor.darkBlue)\n                    elif self.selectionData.getData(i, j) < 0:\n                        return QtGui.QBrush(QtCore.Qt.GlobalColor.darkRed)\n            return QtCore.QVariant()"]}
{"filename": "src/optarber/deribit_option.py", "chunked_list": ["class Option:\n    def __init__(self, name, kind, expiry, strike, delta, gamma, vega, theta, \n\t\t\t       bid_price, bid_amount, ask_price, ask_amount):\n        self.name = name\n        self.kind = kind\n        self.expiry = expiry\n        self.strike = strike\n        self.delta = delta\n        self.gamma = gamma\n        self.vega = vega\n        self.theta = theta\n        self.bid_price = bid_price\n        self.bid_amount = bid_amount\n        self.ask_price = ask_price\n        self.ask_amount = ask_amount"]}
{"filename": "src/optarber/image_viewer.py", "chunked_list": ["from PyQt6.QtWidgets import QDialog, QLabel\nfrom PyQt6.QtGui import QPixmap                                                                                                            \n                                                                                                                                \n\nclass ImageViewer(QDialog): \n    def __init__(self):  \n        super().__init__()                                                                                                                  \n        self.lbl = None\n        self.initUI()                                                                                                                 \n\n    def initUI(self):    \n        self.lbl = QLabel(self)                                                                                               \n        self.setWindowTitle('PayOff')  \n\n    def update(self):\n        pixmap = QPixmap(\"file.png\")                                                                                                        \n        self.lbl.setPixmap(pixmap)                                                                                                          ", ""]}
{"filename": "src/optarber/mainUI.py", "chunked_list": ["# Form implementation generated from reading ui file 'UI\\optionAtilla.ui'\n#\n# Created by: PyQt6 UI code generator 6.4.2\n#\n# WARNING: Any manual changes made to this file will be lost when pyuic6 is\n# run again.  Do not edit this file unless you know what you are doing.\n\n\nfrom PyQt6 import QtCore, QtGui, QtWidgets\n", "from PyQt6 import QtCore, QtGui, QtWidgets\n\n\nclass Ui_optionAtillaWindow(object):\n    def setupUi(self, optionAtillaWindow):\n        optionAtillaWindow.setObjectName(\"optionAtillaWindow\")\n        optionAtillaWindow.setWindowModality(QtCore.Qt.WindowModality.WindowModal)\n        optionAtillaWindow.resize(1269, 879)\n        optionAtillaWindow.setAutoFillBackground(False)\n        optionAtillaWindow.setStyleSheet(\"background-color: rgb(177, 177, 177);\\n\"\n\"color: rgb(0, 0, 0);\")\n        self.centralwidget = QtWidgets.QWidget(parent=optionAtillaWindow)\n        self.centralwidget.setObjectName(\"centralwidget\")\n        self.groupCriteria = QtWidgets.QGroupBox(parent=self.centralwidget)\n        self.groupCriteria.setGeometry(QtCore.QRect(0, 1, 1031, 141))\n        self.groupCriteria.setObjectName(\"groupCriteria\")\n        self.layoutWidget = QtWidgets.QWidget(parent=self.groupCriteria)\n        self.layoutWidget.setGeometry(QtCore.QRect(170, 20, 63, 71))\n        self.layoutWidget.setObjectName(\"layoutWidget\")\n        self.verticalLayout_10 = QtWidgets.QVBoxLayout(self.layoutWidget)\n        self.verticalLayout_10.setContentsMargins(0, 0, 0, 0)\n        self.verticalLayout_10.setObjectName(\"verticalLayout_10\")\n        self.labelStrikePercent = QtWidgets.QLabel(parent=self.layoutWidget)\n        self.labelStrikePercent.setObjectName(\"labelStrikePercent\")\n        self.verticalLayout_10.addWidget(self.labelStrikePercent)\n        self.labelMinExpiry = QtWidgets.QLabel(parent=self.layoutWidget)\n        self.labelMinExpiry.setObjectName(\"labelMinExpiry\")\n        self.verticalLayout_10.addWidget(self.labelMinExpiry)\n        self.labelMaxExpiry = QtWidgets.QLabel(parent=self.layoutWidget)\n        self.labelMaxExpiry.setObjectName(\"labelMaxExpiry\")\n        self.verticalLayout_10.addWidget(self.labelMaxExpiry)\n        self.pushButtonFetch = QtWidgets.QPushButton(parent=self.groupCriteria)\n        self.pushButtonFetch.setGeometry(QtCore.QRect(920, 110, 75, 23))\n        self.pushButtonFetch.setStyleSheet(\"background-color: rgb(100, 100, 100);\")\n        self.pushButtonFetch.setObjectName(\"pushButtonFetch\")\n        self.labelNumOfOptions = QtWidgets.QLabel(parent=self.groupCriteria)\n        self.labelNumOfOptions.setGeometry(QtCore.QRect(290, 52, 81, 41))\n        self.labelNumOfOptions.setObjectName(\"labelNumOfOptions\")\n        self.pushButtonCompute = QtWidgets.QPushButton(parent=self.groupCriteria)\n        self.pushButtonCompute.setGeometry(QtCore.QRect(790, 80, 91, 23))\n        self.pushButtonCompute.setObjectName(\"pushButtonCompute\")\n        self.progressBarFetch = QtWidgets.QProgressBar(parent=self.groupCriteria)\n        self.progressBarFetch.setGeometry(QtCore.QRect(10, 110, 911, 23))\n        self.progressBarFetch.setStyleSheet(\"color: rgb(0, 255, 0);\")\n        self.progressBarFetch.setProperty(\"value\", 0)\n        self.progressBarFetch.setObjectName(\"progressBarFetch\")\n        self.layoutWidget1 = QtWidgets.QWidget(parent=self.groupCriteria)\n        self.layoutWidget1.setGeometry(QtCore.QRect(376, 22, 81, 71))\n        self.layoutWidget1.setObjectName(\"layoutWidget1\")\n        self.verticalLayout = QtWidgets.QVBoxLayout(self.layoutWidget1)\n        self.verticalLayout.setContentsMargins(0, 0, 0, 0)\n        self.verticalLayout.setObjectName(\"verticalLayout\")\n        self.labelDelta = QtWidgets.QLabel(parent=self.layoutWidget1)\n        self.labelDelta.setObjectName(\"labelDelta\")\n        self.verticalLayout.addWidget(self.labelDelta)\n        self.labelMinTheta = QtWidgets.QLabel(parent=self.layoutWidget1)\n        self.labelMinTheta.setObjectName(\"labelMinTheta\")\n        self.verticalLayout.addWidget(self.labelMinTheta)\n        self.labelGamma = QtWidgets.QLabel(parent=self.layoutWidget1)\n        self.labelGamma.setObjectName(\"labelGamma\")\n        self.verticalLayout.addWidget(self.labelGamma)\n        self.layoutWidget2 = QtWidgets.QWidget(parent=self.groupCriteria)\n        self.layoutWidget2.setGeometry(QtCore.QRect(467, 20, 61, 71))\n        self.layoutWidget2.setObjectName(\"layoutWidget2\")\n        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.layoutWidget2)\n        self.verticalLayout_2.setContentsMargins(0, 0, 0, 0)\n        self.verticalLayout_2.setObjectName(\"verticalLayout_2\")\n        self.spinDelta = QtWidgets.QSpinBox(parent=self.layoutWidget2)\n        self.spinDelta.setStyleSheet(\"background-color: rgb(255, 255, 255);\\n\"\n\"color: rgb(0, 0, 0);\")\n        self.spinDelta.setReadOnly(False)\n        self.spinDelta.setMaximum(999)\n        self.spinDelta.setProperty(\"value\", 1)\n        self.spinDelta.setObjectName(\"spinDelta\")\n        self.verticalLayout_2.addWidget(self.spinDelta)\n        self.spinMinTheta = QtWidgets.QSpinBox(parent=self.layoutWidget2)\n        self.spinMinTheta.setStyleSheet(\"background-color: rgb(255, 255, 255);\\n\"\n\"color: rgb(0, 0, 0);\")\n        self.spinMinTheta.setReadOnly(False)\n        self.spinMinTheta.setMinimum(-9999)\n        self.spinMinTheta.setMaximum(9999)\n        self.spinMinTheta.setProperty(\"value\", 5)\n        self.spinMinTheta.setObjectName(\"spinMinTheta\")\n        self.verticalLayout_2.addWidget(self.spinMinTheta)\n        self.spinGamma = QtWidgets.QSpinBox(parent=self.layoutWidget2)\n        self.spinGamma.setStyleSheet(\"background-color: rgb(255, 255, 255);\\n\"\n\"color: rgb(0, 0, 0);\")\n        self.spinGamma.setReadOnly(False)\n        self.spinGamma.setMinimum(-9999)\n        self.spinGamma.setMaximum(9999)\n        self.spinGamma.setProperty(\"value\", 100)\n        self.spinGamma.setObjectName(\"spinGamma\")\n        self.verticalLayout_2.addWidget(self.spinGamma)\n        self.layoutWidget3 = QtWidgets.QWidget(parent=self.groupCriteria)\n        self.layoutWidget3.setGeometry(QtCore.QRect(10, 20, 62, 71))\n        self.layoutWidget3.setObjectName(\"layoutWidget3\")\n        self.verticalLayout_3 = QtWidgets.QVBoxLayout(self.layoutWidget3)\n        self.verticalLayout_3.setContentsMargins(0, 0, 0, 0)\n        self.verticalLayout_3.setObjectName(\"verticalLayout_3\")\n        self.labelEnv = QtWidgets.QLabel(parent=self.layoutWidget3)\n        self.labelEnv.setObjectName(\"labelEnv\")\n        self.verticalLayout_3.addWidget(self.labelEnv)\n        self.labelCurr = QtWidgets.QLabel(parent=self.layoutWidget3)\n        self.labelCurr.setObjectName(\"labelCurr\")\n        self.verticalLayout_3.addWidget(self.labelCurr)\n        self.labelObjective = QtWidgets.QLabel(parent=self.layoutWidget3)\n        self.labelObjective.setObjectName(\"labelObjective\")\n        self.verticalLayout_3.addWidget(self.labelObjective)\n        self.layoutWidget4 = QtWidgets.QWidget(parent=self.groupCriteria)\n        self.layoutWidget4.setGeometry(QtCore.QRect(80, 20, 90, 74))\n        self.layoutWidget4.setObjectName(\"layoutWidget4\")\n        self.verticalLayout_4 = QtWidgets.QVBoxLayout(self.layoutWidget4)\n        self.verticalLayout_4.setContentsMargins(0, 0, 0, 0)\n        self.verticalLayout_4.setObjectName(\"verticalLayout_4\")\n        self.comboEnv = QtWidgets.QComboBox(parent=self.layoutWidget4)\n        self.comboEnv.setStyleSheet(\"background-color: rgb(85, 255, 255);\\n\"\n\"color: rgb(0, 0, 0);\")\n        self.comboEnv.setObjectName(\"comboEnv\")\n        self.comboEnv.addItem(\"\")\n        self.comboEnv.addItem(\"\")\n        self.verticalLayout_4.addWidget(self.comboEnv)\n        self.comboCurr = QtWidgets.QComboBox(parent=self.layoutWidget4)\n        self.comboCurr.setStyleSheet(\"background-color: rgb(255, 255, 255);\\n\"\n\"color: rgb(0, 0, 0);\")\n        self.comboCurr.setObjectName(\"comboCurr\")\n        self.comboCurr.addItem(\"\")\n        self.comboCurr.addItem(\"\")\n        self.verticalLayout_4.addWidget(self.comboCurr)\n        self.comboObjective = QtWidgets.QComboBox(parent=self.layoutWidget4)\n        self.comboObjective.setStyleSheet(\"background-color: rgb(255, 255, 255);\\n\"\n\"color: rgb(0, 0, 0);\")\n        self.comboObjective.setObjectName(\"comboObjective\")\n        self.comboObjective.addItem(\"\")\n        self.comboObjective.addItem(\"\")\n        self.comboObjective.addItem(\"\")\n        self.verticalLayout_4.addWidget(self.comboObjective)\n        self.layoutWidget5 = QtWidgets.QWidget(parent=self.groupCriteria)\n        self.layoutWidget5.setGeometry(QtCore.QRect(550, 23, 104, 65))\n        self.layoutWidget5.setObjectName(\"layoutWidget5\")\n        self.verticalLayout_5 = QtWidgets.QVBoxLayout(self.layoutWidget5)\n        self.verticalLayout_5.setContentsMargins(0, 0, 0, 0)\n        self.verticalLayout_5.setObjectName(\"verticalLayout_5\")\n        self.checkPutNeutral = QtWidgets.QCheckBox(parent=self.layoutWidget5)\n        self.checkPutNeutral.setLayoutDirection(QtCore.Qt.LayoutDirection.RightToLeft)\n        self.checkPutNeutral.setChecked(True)\n        self.checkPutNeutral.setObjectName(\"checkPutNeutral\")\n        self.verticalLayout_5.addWidget(self.checkPutNeutral)\n        self.checkCallNeutral = QtWidgets.QCheckBox(parent=self.layoutWidget5)\n        self.checkCallNeutral.setLayoutDirection(QtCore.Qt.LayoutDirection.RightToLeft)\n        self.checkCallNeutral.setChecked(True)\n        self.checkCallNeutral.setObjectName(\"checkCallNeutral\")\n        self.verticalLayout_5.addWidget(self.checkCallNeutral)\n        self.checkVega = QtWidgets.QCheckBox(parent=self.layoutWidget5)\n        self.checkVega.setLayoutDirection(QtCore.Qt.LayoutDirection.RightToLeft)\n        self.checkVega.setChecked(True)\n        self.checkVega.setObjectName(\"checkVega\")\n        self.verticalLayout_5.addWidget(self.checkVega)\n        self.layoutWidget6 = QtWidgets.QWidget(parent=self.groupCriteria)\n        self.layoutWidget6.setGeometry(QtCore.QRect(665, 24, 71, 42))\n        self.layoutWidget6.setObjectName(\"layoutWidget6\")\n        self.verticalLayout_6 = QtWidgets.QVBoxLayout(self.layoutWidget6)\n        self.verticalLayout_6.setContentsMargins(0, 0, 0, 0)\n        self.verticalLayout_6.setObjectName(\"verticalLayout_6\")\n        self.checkLongCall = QtWidgets.QCheckBox(parent=self.layoutWidget6)\n        self.checkLongCall.setLayoutDirection(QtCore.Qt.LayoutDirection.RightToLeft)\n        self.checkLongCall.setChecked(False)\n        self.checkLongCall.setObjectName(\"checkLongCall\")\n        self.verticalLayout_6.addWidget(self.checkLongCall)\n        self.checkLongPut = QtWidgets.QCheckBox(parent=self.layoutWidget6)\n        self.checkLongPut.setLayoutDirection(QtCore.Qt.LayoutDirection.RightToLeft)\n        self.checkLongPut.setChecked(False)\n        self.checkLongPut.setObjectName(\"checkLongPut\")\n        self.verticalLayout_6.addWidget(self.checkLongPut)\n        self.layoutWidget7 = QtWidgets.QWidget(parent=self.groupCriteria)\n        self.layoutWidget7.setGeometry(QtCore.QRect(760, 25, 61, 41))\n        self.layoutWidget7.setObjectName(\"layoutWidget7\")\n        self.verticalLayout_7 = QtWidgets.QVBoxLayout(self.layoutWidget7)\n        self.verticalLayout_7.setContentsMargins(0, 0, 0, 0)\n        self.verticalLayout_7.setObjectName(\"verticalLayout_7\")\n        self.labelMaxUnit = QtWidgets.QLabel(parent=self.layoutWidget7)\n        self.labelMaxUnit.setObjectName(\"labelMaxUnit\")\n        self.verticalLayout_7.addWidget(self.labelMaxUnit)\n        self.labelMaxTotal = QtWidgets.QLabel(parent=self.layoutWidget7)\n        self.labelMaxTotal.setObjectName(\"labelMaxTotal\")\n        self.verticalLayout_7.addWidget(self.labelMaxTotal)\n        self.layoutWidget8 = QtWidgets.QWidget(parent=self.groupCriteria)\n        self.layoutWidget8.setGeometry(QtCore.QRect(830, 22, 61, 48))\n        self.layoutWidget8.setObjectName(\"layoutWidget8\")\n        self.verticalLayout_8 = QtWidgets.QVBoxLayout(self.layoutWidget8)\n        self.verticalLayout_8.setContentsMargins(0, 0, 0, 0)\n        self.verticalLayout_8.setObjectName(\"verticalLayout_8\")\n        self.spinMaxUnit = QtWidgets.QSpinBox(parent=self.layoutWidget8)\n        self.spinMaxUnit.setStyleSheet(\"background-color: rgb(255, 255, 255);\\n\"\n\"color: rgb(0, 0, 0);\")\n        self.spinMaxUnit.setReadOnly(False)\n        self.spinMaxUnit.setMaximum(999)\n        self.spinMaxUnit.setProperty(\"value\", 5)\n        self.spinMaxUnit.setObjectName(\"spinMaxUnit\")\n        self.verticalLayout_8.addWidget(self.spinMaxUnit)\n        self.spinMaxTotal = QtWidgets.QSpinBox(parent=self.layoutWidget8)\n        self.spinMaxTotal.setStyleSheet(\"background-color: rgb(255, 255, 255);\\n\"\n\"color: rgb(0, 0, 0);\")\n        self.spinMaxTotal.setReadOnly(False)\n        self.spinMaxTotal.setMaximum(999)\n        self.spinMaxTotal.setProperty(\"value\", 15)\n        self.spinMaxTotal.setObjectName(\"spinMaxTotal\")\n        self.verticalLayout_8.addWidget(self.spinMaxTotal)\n        self.layoutWidget9 = QtWidgets.QWidget(parent=self.groupCriteria)\n        self.layoutWidget9.setGeometry(QtCore.QRect(240, 20, 39, 74))\n        self.layoutWidget9.setObjectName(\"layoutWidget9\")\n        self.verticalLayout_9 = QtWidgets.QVBoxLayout(self.layoutWidget9)\n        self.verticalLayout_9.setContentsMargins(0, 0, 0, 0)\n        self.verticalLayout_9.setObjectName(\"verticalLayout_9\")\n        self.spinBoxStrikePercent = QtWidgets.QSpinBox(parent=self.layoutWidget9)\n        self.spinBoxStrikePercent.setStyleSheet(\"background-color: rgb(255, 255, 255);\\n\"\n\"color: rgb(0, 0, 0);\")\n        self.spinBoxStrikePercent.setProperty(\"value\", 10)\n        self.spinBoxStrikePercent.setObjectName(\"spinBoxStrikePercent\")\n        self.verticalLayout_9.addWidget(self.spinBoxStrikePercent)\n        self.spinBoxMinExpiry = QtWidgets.QSpinBox(parent=self.layoutWidget9)\n        self.spinBoxMinExpiry.setStyleSheet(\"background-color: rgb(255, 255, 255);\\n\"\n\"color: rgb(0, 0, 0);\")\n        self.spinBoxMinExpiry.setProperty(\"value\", 0)\n        self.spinBoxMinExpiry.setObjectName(\"spinBoxMinExpiry\")\n        self.verticalLayout_9.addWidget(self.spinBoxMinExpiry)\n        self.spinBoxMaxExpiry = QtWidgets.QSpinBox(parent=self.layoutWidget9)\n        self.spinBoxMaxExpiry.setStyleSheet(\"background-color: rgb(255, 255, 255);\\n\"\n\"color: rgb(0, 0, 0);\")\n        self.spinBoxMaxExpiry.setProperty(\"value\", 10)\n        self.spinBoxMaxExpiry.setObjectName(\"spinBoxMaxExpiry\")\n        self.verticalLayout_9.addWidget(self.spinBoxMaxExpiry)\n        self.checkPositions = QtWidgets.QCheckBox(parent=self.groupCriteria)\n        self.checkPositions.setGeometry(QtCore.QRect(900, 20, 121, 20))\n        self.checkPositions.setLayoutDirection(QtCore.Qt.LayoutDirection.RightToLeft)\n        self.checkPositions.setChecked(True)\n        self.checkPositions.setObjectName(\"checkPositions\")\n        self.spinBoxSpread = QtWidgets.QSpinBox(parent=self.groupCriteria)\n        self.spinBoxSpread.setGeometry(QtCore.QRect(970, 40, 51, 22))\n        self.spinBoxSpread.setStyleSheet(\"background-color: rgb(255, 255, 255);\\n\"\n\"color: rgb(0, 0, 0);\")\n        self.spinBoxSpread.setMinimum(1)\n        self.spinBoxSpread.setProperty(\"value\", 10)\n        self.spinBoxSpread.setObjectName(\"spinBoxSpread\")\n        self.labelSpread = QtWidgets.QLabel(parent=self.groupCriteria)\n        self.labelSpread.setGeometry(QtCore.QRect(906, 40, 61, 20))\n        self.labelSpread.setObjectName(\"labelSpread\")\n        self.checkDoubleFee = QtWidgets.QCheckBox(parent=self.groupCriteria)\n        self.checkDoubleFee.setGeometry(QtCore.QRect(900, 64, 121, 20))\n        self.checkDoubleFee.setLayoutDirection(QtCore.Qt.LayoutDirection.RightToLeft)\n        self.checkDoubleFee.setChecked(True)\n        self.checkDoubleFee.setObjectName(\"checkDoubleFee\")\n        self.pushButtonConnect = QtWidgets.QPushButton(parent=self.groupCriteria)\n        self.pushButtonConnect.setGeometry(QtCore.QRect(280, 20, 91, 21))\n        self.pushButtonConnect.setStyleSheet(\"background-color: rgb(100, 100, 100);\")\n        self.pushButtonConnect.setObjectName(\"pushButtonConnect\")\n        self.tableViewAccount = QtWidgets.QTableView(parent=self.centralwidget)\n        self.tableViewAccount.setGeometry(QtCore.QRect(1040, 0, 221, 671))\n        self.tableViewAccount.setAutoFillBackground(True)\n        self.tableViewAccount.setStyleSheet(\"\")\n        self.tableViewAccount.setObjectName(\"tableViewAccount\")\n        self.tableViewAccount.horizontalHeader().setVisible(False)\n        self.tableViewAccount.verticalHeader().setVisible(False)\n        self.groupBox_2 = QtWidgets.QGroupBox(parent=self.centralwidget)\n        self.groupBox_2.setGeometry(QtCore.QRect(10, 140, 1021, 101))\n        self.groupBox_2.setObjectName(\"groupBox_2\")\n        self.tableViewResults = QtWidgets.QTableView(parent=self.groupBox_2)\n        self.tableViewResults.setEnabled(True)\n        self.tableViewResults.setGeometry(QtCore.QRect(0, 20, 1011, 71))\n        self.tableViewResults.setAutoFillBackground(False)\n        self.tableViewResults.setStyleSheet(\"\")\n        self.tableViewResults.setObjectName(\"tableViewResults\")\n        self.tableViewResults.horizontalHeader().setVisible(False)\n        self.tableViewResults.horizontalHeader().setStretchLastSection(False)\n        self.tableViewResults.verticalHeader().setVisible(False)\n        self.tableViewSelections = QtWidgets.QTableView(parent=self.centralwidget)\n        self.tableViewSelections.setGeometry(QtCore.QRect(10, 250, 641, 421))\n        self.tableViewSelections.setAutoFillBackground(True)\n        self.tableViewSelections.setStyleSheet(\"\")\n        self.tableViewSelections.setObjectName(\"tableViewSelections\")\n        self.tableViewSelections.horizontalHeader().setVisible(False)\n        self.tableViewSelections.horizontalHeader().setStretchLastSection(False)\n        self.tableViewSelections.verticalHeader().setVisible(False)\n        self.tableViewPositions = QtWidgets.QTableView(parent=self.centralwidget)\n        self.tableViewPositions.setGeometry(QtCore.QRect(660, 250, 371, 421))\n        self.tableViewPositions.setAutoFillBackground(True)\n        self.tableViewPositions.setStyleSheet(\"\")\n        self.tableViewPositions.setObjectName(\"tableViewPositions\")\n        self.tableViewPositions.horizontalHeader().setVisible(False)\n        self.tableViewPositions.horizontalHeader().setStretchLastSection(False)\n        self.tableViewPositions.verticalHeader().setVisible(False)\n        self.tableViewPositions.verticalHeader().setHighlightSections(True)\n        self.pushButtonClose = QtWidgets.QPushButton(parent=self.centralwidget)\n        self.pushButtonClose.setGeometry(QtCore.QRect(1140, 810, 121, 41))\n        self.pushButtonClose.setStyleSheet(\"background-color: rgb(100, 100, 100);\")\n        self.pushButtonClose.setObjectName(\"pushButtonClose\")\n        self.tableViewCallTrades = QtWidgets.QTableView(parent=self.centralwidget)\n        self.tableViewCallTrades.setGeometry(QtCore.QRect(11, 679, 641, 121))\n        self.tableViewCallTrades.setObjectName(\"tableViewCallTrades\")\n        self.tableViewPutTrades = QtWidgets.QTableView(parent=self.centralwidget)\n        self.tableViewPutTrades.setGeometry(QtCore.QRect(660, 680, 601, 121))\n        self.tableViewPutTrades.setObjectName(\"tableViewPutTrades\")\n        self.widget = QtWidgets.QWidget(parent=self.centralwidget)\n        self.widget.setGeometry(QtCore.QRect(60, 820, 461, 25))\n        self.widget.setObjectName(\"widget\")\n        self.horizontalLayout = QtWidgets.QHBoxLayout(self.widget)\n        self.horizontalLayout.setContentsMargins(0, 0, 0, 0)\n        self.horizontalLayout.setObjectName(\"horizontalLayout\")\n        self.pushButtonDisplay = QtWidgets.QPushButton(parent=self.widget)\n        self.pushButtonDisplay.setStyleSheet(\"background-color: rgb(100, 100, 100);\")\n        self.pushButtonDisplay.setObjectName(\"pushButtonDisplay\")\n        self.horizontalLayout.addWidget(self.pushButtonDisplay)\n        self.pushButtonClearSelection = QtWidgets.QPushButton(parent=self.widget)\n        self.pushButtonClearSelection.setStyleSheet(\"background-color: rgb(100, 100, 100);\")\n        self.pushButtonClearSelection.setObjectName(\"pushButtonClearSelection\")\n        self.horizontalLayout.addWidget(self.pushButtonClearSelection)\n        self.pushButtonRefresh = QtWidgets.QPushButton(parent=self.widget)\n        self.pushButtonRefresh.setStyleSheet(\"background-color: rgb(100, 100, 100);\")\n        self.pushButtonRefresh.setObjectName(\"pushButtonRefresh\")\n        self.horizontalLayout.addWidget(self.pushButtonRefresh)\n        self.pushButtonTrade = QtWidgets.QPushButton(parent=self.widget)\n        self.pushButtonTrade.setStyleSheet(\"background-color: rgb(100, 100, 100);\")\n        self.pushButtonTrade.setObjectName(\"pushButtonTrade\")\n        self.horizontalLayout.addWidget(self.pushButtonTrade)\n        self.widget1 = QtWidgets.QWidget(parent=self.centralwidget)\n        self.widget1.setGeometry(QtCore.QRect(760, 820, 166, 25))\n        self.widget1.setObjectName(\"widget1\")\n        self.horizontalLayout_2 = QtWidgets.QHBoxLayout(self.widget1)\n        self.horizontalLayout_2.setContentsMargins(0, 0, 0, 0)\n        self.horizontalLayout_2.setObjectName(\"horizontalLayout_2\")\n        self.pushButtonPositions = QtWidgets.QPushButton(parent=self.widget1)\n        self.pushButtonPositions.setStyleSheet(\"background-color: rgb(100, 100, 100);\")\n        self.pushButtonPositions.setObjectName(\"pushButtonPositions\")\n        self.horizontalLayout_2.addWidget(self.pushButtonPositions)\n        self.pushButtonClearTrades = QtWidgets.QPushButton(parent=self.widget1)\n        self.pushButtonClearTrades.setStyleSheet(\"background-color: rgb(100, 100, 100);\")\n        self.pushButtonClearTrades.setObjectName(\"pushButtonClearTrades\")\n        self.horizontalLayout_2.addWidget(self.pushButtonClearTrades)\n        optionAtillaWindow.setCentralWidget(self.centralwidget)\n        self.statusbar = QtWidgets.QStatusBar(parent=optionAtillaWindow)\n        self.statusbar.setObjectName(\"statusbar\")\n        optionAtillaWindow.setStatusBar(self.statusbar)\n\n        self.retranslateUi(optionAtillaWindow)\n        self.pushButtonClose.clicked.connect(optionAtillaWindow.close) # type: ignore\n        QtCore.QMetaObject.connectSlotsByName(optionAtillaWindow)\n\n    def retranslateUi(self, optionAtillaWindow):\n        _translate = QtCore.QCoreApplication.translate\n        optionAtillaWindow.setWindowTitle(_translate(\"optionAtillaWindow\", \"OptionAtilla\"))\n        self.groupCriteria.setTitle(_translate(\"optionAtillaWindow\", \"Criteria\"))\n        self.labelStrikePercent.setText(_translate(\"optionAtillaWindow\", \"Strike (%)\"))\n        self.labelMinExpiry.setText(_translate(\"optionAtillaWindow\", \"Expiry (Min)\"))\n        self.labelMaxExpiry.setText(_translate(\"optionAtillaWindow\", \"Expiry (Max)\"))\n        self.pushButtonFetch.setText(_translate(\"optionAtillaWindow\", \"FETCH\"))\n        self.labelNumOfOptions.setText(_translate(\"optionAtillaWindow\", \"No. of Options \\n\"\n\"No. of Expiries\"))\n        self.pushButtonCompute.setText(_translate(\"optionAtillaWindow\", \"Compute\"))\n        self.labelDelta.setText(_translate(\"optionAtillaWindow\", \"Max Delta (%)\"))\n        self.labelMinTheta.setText(_translate(\"optionAtillaWindow\", \"Min Theta\"))\n        self.labelGamma.setText(_translate(\"optionAtillaWindow\", \"Gamma (bps)\"))\n        self.labelEnv.setText(_translate(\"optionAtillaWindow\", \"Environmnt\"))\n        self.labelCurr.setText(_translate(\"optionAtillaWindow\", \"Currency\"))\n        self.labelObjective.setText(_translate(\"optionAtillaWindow\", \"Objective\"))\n        self.comboEnv.setItemText(0, _translate(\"optionAtillaWindow\", \"TEST\"))\n        self.comboEnv.setItemText(1, _translate(\"optionAtillaWindow\", \"PROD\"))\n        self.comboCurr.setItemText(0, _translate(\"optionAtillaWindow\", \"ETH\"))\n        self.comboCurr.setItemText(1, _translate(\"optionAtillaWindow\", \"BTC\"))\n        self.comboObjective.setItemText(0, _translate(\"optionAtillaWindow\", \"Min Cost\"))\n        self.comboObjective.setItemText(1, _translate(\"optionAtillaWindow\", \"Max Gamma\"))\n        self.comboObjective.setItemText(2, _translate(\"optionAtillaWindow\", \"Max Theta\"))\n        self.checkPutNeutral.setText(_translate(\"optionAtillaWindow\", \"Put neutral        \"))\n        self.checkCallNeutral.setText(_translate(\"optionAtillaWindow\", \"Call neutral        \"))\n        self.checkVega.setText(_translate(\"optionAtillaWindow\", \"Positive Vega     \"))\n        self.checkLongCall.setText(_translate(\"optionAtillaWindow\", \"Long Call \"))\n        self.checkLongPut.setText(_translate(\"optionAtillaWindow\", \"Long Put \"))\n        self.labelMaxUnit.setText(_translate(\"optionAtillaWindow\", \"Max Unit\"))\n        self.labelMaxTotal.setText(_translate(\"optionAtillaWindow\", \"Max Total\"))\n        self.checkPositions.setText(_translate(\"optionAtillaWindow\", \"Exisiting Positions\"))\n        self.labelSpread.setText(_translate(\"optionAtillaWindow\", \"Spread (bps)\"))\n        self.checkDoubleFee.setText(_translate(\"optionAtillaWindow\", \"Double Fee\"))\n        self.pushButtonConnect.setText(_translate(\"optionAtillaWindow\", \"Connect\"))\n        self.groupBox_2.setTitle(_translate(\"optionAtillaWindow\", \"Results\"))\n        self.pushButtonClose.setText(_translate(\"optionAtillaWindow\", \"Shutdown\"))\n        self.pushButtonDisplay.setText(_translate(\"optionAtillaWindow\", \"Display Payoff\"))\n        self.pushButtonClearSelection.setText(_translate(\"optionAtillaWindow\", \"Clear Selection\"))\n        self.pushButtonRefresh.setText(_translate(\"optionAtillaWindow\", \"Refresh\"))\n        self.pushButtonTrade.setText(_translate(\"optionAtillaWindow\", \"Execute\"))\n        self.pushButtonPositions.setText(_translate(\"optionAtillaWindow\", \"Query Positions\"))\n        self.pushButtonClearTrades.setText(_translate(\"optionAtillaWindow\", \"Clear Trades\"))", ""]}
{"filename": "src/optarber/position_data.py", "chunked_list": ["\nclass PositionData:\n\tdef __init__(self):\n\t\tself.keys = {}\n\t\tself.positions = []\n\t\tself.cols = 6\n\t\n\tdef clear(self):\n\t\tself.positions = []\n\t\tself.cols = 6\n\n\tdef add(self, positions):\n\t\tself.keys = {}\n\t\tself.positions = []\n\n\t\tfor i, pos in enumerate(positions):\n\t\t\tname = pos.op.name\n\t\t\tself.keys[name] = i\n\t\t\tself.positions.append(pos)\n\n\tdef update(self, positions):\n\t\tfor pos in positions:\n\t\t\tname = pos['instrument_name']\n\t\t\tif name in self.keys:\n\t\t\t\tpos = self.positions[self.keys[name]]\n\t\t\t\tpos.size = pos['size']\n\t\t\t\topt = pos.op\n\t\t\t\topt.delta = pos['delta'] / opt.size\n\t\t\t\topt.gamma = pos['gamma'] / opt.size\n\t\t\t\topt.vega = pos['vega'] / opt.size\n\t\t\t\topt.theta = pos['theta'] / opt.size\n\t\t\n\tdef getRows(self):\n\t\treturn len(self.positions) + 1\n\t\t\n\tdef getCols(self):\n\t\treturn self.cols\n\t\t\n\tdef getData(self, j, i):\n\t\tif j == 0:\n\t\t\tif i == 0:\n\t\t\t\treturn \"Instr\"\n\t\t\telif i == 1:\n\t\t\t\treturn \"Size\"\n\t\t\telif i == 2:\n\t\t\t\treturn \"Delta\"\n\t\t\telif i == 3:\n\t\t\t\treturn \"Gamma\"\n\t\t\telif i == 4:\n\t\t\t\treturn \"Vega\"\n\t\t\telif i == 5:\n\t\t\t\treturn \"Theta\"\n\t\t\telse:\n\t\t\t\treturn \"\"\n\t\telse:\n\t\t\tpos = self.positions[j-1]\n\t\t\t\n\t\t\tif i == 0:\n\t\t\t\treturn pos.op.name\n\t\t\telif i == 1:\n\t\t\t\treturn pos.size\n\t\t\telif i == 2:\n\t\t\t\treturn pos.op.delta * pos.size\n\t\t\telif i == 3:\n\t\t\t\treturn pos.op.gamma * pos.size\n\t\t\telif i == 4:\n\t\t\t\treturn pos.op.vega * pos.size\n\t\t\telif i == 5:\n\t\t\t\treturn pos.op.theta * pos.size\n\t\t\telse:\n\t\t\t\treturn 0"]}
{"filename": "src/optarber/results_model.py", "chunked_list": ["from PyQt6 import QtCore, QtGui\n\nclass ResultsModel(QtCore.QAbstractTableModel): \n    def __init__(self, parent=None, *args): \n        super(ResultsModel, self).__init__()\n        self.results = None\n\n        \n    def update(self, results):\n        self.results = results\n     \n    def rowCount(self, parent=QtCore.QModelIndex()):\n        return self.results.getRows()\n\n        \n    def columnCount(self, parent=QtCore.QModelIndex()):\n        return self.results.getCols()\n\n        \n    def data(self, index, role=QtCore.Qt):\n        if self.results is not None:\n            i = index.row()\n            j = index.column()\n\n            if role == QtCore.Qt.ItemDataRole.DisplayRole:\n                if i == 0:\n                    return '{0}'.format(self.results.getData(i, j))\n                else:\n                    return '{:.4f}'.format(self.results.getData(i, j))\n            elif role == QtCore.Qt.ItemDataRole.TextAlignmentRole:\n                if i > 0:\n                    return QtCore.Qt.AlignmentFlag.AlignRight\n            elif role == QtCore.Qt.ItemDataRole.ForegroundRole:\n                if i > 0:\n                    if self.results.getData(i, j) > 0:\n                        return QtGui.QBrush(QtCore.Qt.GlobalColor.darkBlue)\n                    elif self.results.getData(i, j) < 0:\n                        return QtGui.QBrush(QtCore.Qt.GlobalColor.darkRed)\n            return QtCore.QVariant()"]}
{"filename": "src/optarber/deribit_rest.py", "chunked_list": ["import datetime\nimport json as json\nimport ccxt \n\nclass RestClient(object):\n    def __init__(self, key, secret, Test=True):\n        self.key = key\n        self.secret = secret\n        self.session = ccxt.deribit({'apiKey': key, 'secret': secret})\n        self.session.set_sandbox_mode(Test)\n        self.session.quoteJsonNumbers = False\n\n    def call_api(self, command, access, options):\n        response = self.session.fetch2(command, access, params=options)\n        return response\n\n    def getinstruments(self, currency, kind):\n        '''\n        to get available trading instruments\n        input:\n            currency: string ['BTC', 'ETH']\n            kind:string [eg: 'future' or 'option']\n        '''\n        assert kind in ['future','option']\n        \n        options = {\n            'currency': currency,\n            'kind':kind\n        }\n\n        response = self.call_api(\"get_instruments\", \"public\", options)\n\n        if \"result\" in response:\n            return response[\"result\"]\n        else:\n            return {}\n    \n    \n    def getportfoliomargin(self, curr, instrs):\n        \n        options = {\n             'currency':curr, \n             'simulated_positions': json.dumps(instrs),\n             'add_positions': 'true'\n        }\n\n        response = self.call_api(\"get_portfolio_margins\", \"private\", options)\n\n        if \"result\" in response:\n            return response['result']\n        else:\n            return {}\n    \n\n    def getinstrument(self, instr):\n        options = {\n            'instrument_name': instr,\n        }\n\n        response = self.call_api(\"get_instrument\", \"public\", options)\n        if \"result\" in response:\n            return response[\"result\"]\n        else:\n            return {}\n    \n    \n\n    def getindex(self, currency):\n        options = {\n            \"currency\":currency,\n            }\n\n        response = self.call_api(\"get_index\", \"public\", options)\n        if \"result\" in response:\n            return response[\"result\"]\n        else:\n            return {}\n    \n    def getopenorders(self, currency, kind):\n        '''\n        to retrieve pending orders [order not yet settled]\n        input:\n            currency: string in 'BTC' or 'ETH'\n        output:\n            [ID1, ID2...]\n        '''\n        options = {\n            \"currency\":currency,\n            \"kind\": kind\n            }\n\n        return self.call_api(\"get_open_orders_by_currency\", \"private\", options);\n\n\n    def getpositions(self, currency, kind):\n        '''\n        to retrieve position by currency\n        input:\n            currency: string in 'BTC' or 'ETH'\n        return: \n            int [size of position. positive for 'buy' and negative for 'sell'\n            \n        '''\n\n        options = {\n            \"currency\":currency,\n            \"kind\": kind\n            }\n        response = self.call_api(\"get_positions\", \"private\", options);\n\n        if \"result\" in response:\n            return response[\"result\"]\n        else:\n            return []\n    \n\n    def buy(self, instrument, quantity, price, postOnly=None, time_in_force=\"fill_or_kill\"):\n        options = {\n            \"instrument_name\": instrument,\n            \"amount\": quantity,\n            \"price\": price,\n            \"time_in_force\": time_in_force\n        }\n  \n        if postOnly:\n            options[\"postOnly\"] = postOnly\n\n        return self.call_api(\"buy\", \"private\", options)\n\n\n    def sell(self, instrument, quantity, price, postOnly=None, time_in_force=\"fill_or_kill\"):\n        options = {\n            \"instrument_name\": instrument,\n            \"amount\": quantity,\n            \"price\": price,\n            \"time_in_force\": time_in_force\n        }\n\n        if postOnly:\n            options[\"postOnly\"] = postOnly\n\n        return self.call_api(\"sell\", \"private\", options)", ""]}
{"filename": "src/optarber/deribit_option_position.py", "chunked_list": ["class DeribitPosition:\n    def __init__(self, op, size):\n        self.op = op\n        self.size = size"]}
{"filename": "src/optarber/deribit_ws.py", "chunked_list": ["import json\nfrom PyQt6 import QtCore, QtWebSockets, QtNetwork\n\n\n# create a websocket object\nclass Deribit_WS(QtCore.QObject):\n    def __init__(self, parent):\n        super().__init__(parent)\n        self.ids = { \"default\": 1,\n                     \"authenticate\": 2, \n                     \"accounts\": 3,\n                     \"changes\": 4,\n                     \"tickers\": 5,\n                    }\n        self.authenticated = False\n        self.controller = None\n\n    \n    def connect(self, controller, client_id, client_secret, client_url):\n        self.controller = controller\n        self.client_id = client_id\n        self.client_secret = client_secret\n        self.client_url = client_url\n        self.json = {\n            \"jsonrpc\" : \"2.0\",\n            \"id\" : 1,\n            \"method\" : None,\n        }\n\n        self.client =  QtWebSockets.QWebSocket(\"Deribit_Socket\",QtWebSockets.QWebSocketProtocol.Version.VersionLatest, None)\n        self.client.error.connect(self.error)\n        self.client.textMessageReceived.connect(self.onMessage)\n        \n        self.client.open(QtCore.QUrl(self.client_url))\n\n    def authenticate(self):\n        options = {\n            \"grant_type\" : \"client_credentials\",\n            \"client_id\" : self.client_id,\n            \"client_secret\" : self.client_secret\n        }\n\n        self.json[\"method\"] = \"public/auth\"\n        self.json[\"id\"] = self.ids[\"authenticate\"]\n        self.json[\"params\"] = options\n        auth = json.dumps(self.json)\n        self.client.sendTextMessage(auth)\n\n    def onMessage(self, textMessage):\n        response = json.loads(textMessage)\n        if \"id\" in response and response[\"id\"] == 2:\n            if \"result\" in response:\n                if \"token_type\" in response['result']:\n                    print(\"Authenticated\")\n                    self.authenticated = True\n        else:\n            if \"params\" in response and \"channel\" in response[\"params\"]:\n                channel = response[\"params\"][\"channel\"]\n                if channel.startswith(\"user.portfolio.\"):\n                    if \"data\" in response['params']:\n                        self.controller.onAccountData(response[\"params\"][\"data\"])\n                if channel.startswith(\"user.changes.\"):\n                    if 'data' in response:\n                        data = response['data']\n                        if 'positions' in data:\n                            self.controller.onPositionData(response[\"data\"][\"positions\"])\n                if channel.startswith(\"ticker.\"):\n                    self.controller.onMarketData(response[\"params\"][\"data\"])\n\n    def error(self, error_code):\n        print(\"error code: {}\".format(error_code))\n        print(self.client.errorString())\n\n    # send an authentication request\n    def call_api(self, request):\n        return self.client.sendTextMessage(json.dumps(request))\n\n    def limit_buy_aggressive(self, instrument_name, amount, reduce_only, price):\n        self.buy_raw(instrument_name, amount, \"limit\", reduce_only, price, False)\n    \n    def buy_market(self, instrument_name, amount, reduce_only):\n        self.buy_raw(instrument_name, amount, \"market\", reduce_only, None, False)\n\n    def limit_buy_passive(self, instrument_name, amount, reduce_only, price):\n        self.buy_raw(instrument_name, amount, \"limit\", reduce_only, price, True)\n\n    def buy_raw(self, instrument_name, amount, order_type, reduce_only, price, post_only):\n        options = {\n            \"instrument_name\" : instrument_name,\n            \"amount\" : amount,\n            \"type\" : order_type,\n            \"reduce_only\" : reduce_only,\n        }\n\n        if price:\n            options[\"price\"] = price\n        if post_only:\n            options[\"post_only\"] = post_only\n\n        self.json[\"method\"] = \"private/buy\"\n        self.json[\"id\"] = self.ids[\"default\"]\n        self.json[\"params\"] = options\n        return self.call_api(self.json)\n    \n    def limit_sell_aggressive(self, instrument_name, amount, reduce_only, price):\n        self.sell_raw(instrument_name, amount, \"limit\", reduce_only, price, False)\n    \n    def sell_market(self, instrument_name, amount, reduce_only):\n        self.sell_raw(instrument_name, amount, \"market\", reduce_only, None, False)\n\n    def limit_sell_passive(self, instrument_name, amount, reduce_only, price):\n        self.sell_raw(instrument_name, amount, \"limit\", reduce_only, price, True)\n\n    def sell_raw(self, instrument_name, amount, order_type, reduce_only, price, post_only):\n        options = {\n            \"instrument_name\" : instrument_name,\n            \"amount\" : amount,\n            \"type\" : order_type,\n            \"reduce_only\" : reduce_only,\n        }\n\n        if price:\n            options[\"price\"] = price\n        if post_only:\n            options[\"post_only\"] = post_only\n\n        self.json[\"method\"] = \"private/sell\"\n        self.json[\"id\"] = self.ids[\"default\"]\n        self.json[\"params\"] = options\n\n        return self.call_api(self.json)\n\n    def edit(self, order_id, amount, price):\n        options= {\n            \"order_id\" : order_id,\n            \"amount\" : amount,\n            \"price\" : price\n        }\n\n        self.json[\"method\"] = \"private/edit\"\n        self.json[\"id\"] = self.ids[\"default\"]\n        self.json[\"params\"] = options\n        return self.call_api(self.json)\n\n    def cancel(self, order_id):\n        options = {\"order_id\" : order_id}\n        self.json[\"method\"] = \"private/cancel\"\n        self.json[\"id\"] = self.ids[\"default\"]\n        self.json[\"params\"] = options\n        return self.call_api(self.json)\n\n    def cancel_all(self):\n        self.json[\"method\"] = \"private/cancel_all\"\n        self.json[\"id\"] = self.ids[\"default\"]\n        return self.call_api(self.json)\n\n    def change_summary(self, currency):\n        options = {\"channels\" : [\"user.changes.option.\" + currency + \".100ms\"]}\n        self.json[\"method\"] = \"private/subscribe\"\n        self.json[\"id\"] = self.ids[\"changes\"]\n        self.json[\"params\"] = options\n        return self.call_api(self.json)\n    \n    def account_summary(self, currency):\n        options = {\"channels\" : [\"user.portfolio.\" + currency]}\n        self.json[\"method\"] = \"private/subscribe\"\n        self.json[\"id\"] = self.ids[\"accounts\"]\n        self.json[\"params\"] = options\n        return self.call_api(self.json)\n\n    def ticker(self, instrument_name):\n        options = {\"channels\" : [\"ticker.\" + instrument_name + \".100ms\"]}\n        self.json[\"method\"] = \"public/subscribe\"\n        self.json[\"id\"] = self.ids[\"tickers\"]\n        self.json[\"params\"] = options\n        return self.call_api(self.json)\n\n    def unsubscribe_all_public(self):\n        self.json[\"method\"] = \"public/unsubscribe_all\"\n        options = {}\n        self.json[\"id\"] = self.ids[\"default\"]\n        self.json[\"params\"] = options\n        return self.call_api(self.json)\n    \n    def unsubscribe_all_private(self):\n        self.json[\"method\"] = \"private/unsubscribe_all\"\n        options = {}\n        self.json[\"id\"] = self.ids[\"default\"]\n        self.json[\"params\"] = options\n        return self.call_api(self.json)\n    \n    def close(self):\n        self.unsubscribe_all_private()\n        self.unsubscribe_all_public()\n        print(\"Closing websocket\")\n        self.client.close()"]}
{"filename": "src/deltahedger/program.py", "chunked_list": ["import scalper, asyncio\n\ndef main():\n\tobj = scalper.Scalper(\"config.ini\", \"Deribit\")\n\tasyncio.run(obj.run_loop())\n\nif __name__ == \"__main__\":\n    main()\n", ""]}
{"filename": "src/deltahedger/scalper.py", "chunked_list": ["import asyncio\nimport ccxt\nimport configparser\nimport logging\nimport requests\nimport time\n\nclass Scalper:\n    def __init__(self, config_file, exchange):\n        try:\n            cfg = configparser.ConfigParser()\n            cfg.read(config_file)\n            self._api_key = cfg[exchange]['api_key']\n            self._api_secret = cfg[exchange]['api_secret']\n            self.symbol = cfg[exchange]['symbol']\n            self.price_move = round(float(cfg[exchange]['price_move']), 2)\n            self.hedge_lookup = cfg[exchange]['hedge_lookup']\n            self.hedge_contract = cfg[exchange]['hedge_contract']\n            self.ladder_size = int(cfg[exchange]['ladder_size'])\n            self.tick_size = round(float(cfg[exchange]['tick_size']), 2)\n            self.delta_threshold = float(cfg[exchange]['delta_threshold'])\n            self.done = False\n            if exchange == \"Deribit\":\n                self.exchange = ccxt.deribit({'apiKey': self._api_key, 'secret': self._api_secret})\n                self.exchange.set_sandbox_mode(True)\n            else:\n                raise Exception(\"Exchange \" + exchange + \" not yet supported\")\n\n            if self.symbol != \"BTC\" and self.symbol != \"ETH\":\n                raise Exception(\"Only BTC and ETH supported symbols\")\n\n        except  Exception as e:\n            logging.error(\"Failed to initialize configuration from file \" + config_file, e)\n    \n    async def get_option_greeks(self):\n        delta = float(self.exchange.fetch_balance({'currency': str(self.symbol)})['info']['options_delta'])\n        gamma = float(self.exchange.fetch_balance({'currency': str(self.symbol)})['info']['options_gamma'])\n        return delta, gamma\n\n    async def get_hedge_delta(self):\n        lookup = self.exchange.fetch_balance({'currency': str(self.symbol)})\n        hedge_lookup = lookup['info']['delta_total_map']\n\n        if self.hedge_lookup in hedge_lookup:\n            return float(hedge_lookup[self.hedge_lookup])\n        else:\n            return 0\n\n    async def get_open_orders(self, symbol):\n        return self.exchange.fetch_open_orders(symbol)\n\n    async def get_ticker(self, symbol):\n        ticker = self.exchange.publicGetTicker({\"instrument_name\": symbol})\n        ticker = ticker['result']\n        return float(ticker[\"best_bid_price\"]), float(ticker[\"best_ask_price\"]), float(ticker['mark_price'])\n\n    async def get_order_book(self, symbol):\n        orderbook = self.exchange.fetch_l2_order_book(symbol, 40)\n        bids = orderbook['bids']\n        asks = orderbook['asks']\n        return bids, asks\n\n\n    async def get_new_delta(self, net_delta, option_gamma, move):\n        return net_delta + option_gamma * move \n\n    async def delta_hedge(self, prev_index, prev_delta):\n        # get greeks\n        option_delta, option_gamma = await self.get_option_greeks()\n        hedge_delta = await self.get_hedge_delta()\n        net_delta = option_delta + hedge_delta\n\n        proposed_bids = {}\n        proposed_asks = {}\n        best_bid_price, best_ask_price, mark_price = await self.get_ticker(self.hedge_contract)\n        index_price = (best_ask_price + best_bid_price) * 0.5\n\n        if index_price == prev_index and abs(net_delta - prev_delta) > self.delta_threshold:\n            return index_price, prev_delta\n    \n        if abs(net_delta) < self.delta_threshold:\n            print(\"not need to hedge\")\n            return index_price, net_delta\n\n        self.exchange.cancel_all_orders(self.hedge_contract)\n\n        print(\"bid price\", best_bid_price, \"ask price\", best_ask_price, \"mark price\", mark_price)\n        print(\"delta\", round(net_delta, 4), \"option delta\", round(option_delta, 4), \"hedge delta\", round(hedge_delta, 4))\n        \n        net_bid_delta = 0\n        net_ask_delta = 0        \n        \n        for ladder in range(self.ladder_size):\n            bid_price_delta = self.price_move * ladder\n            ask_price_delta = bid_price_delta\n\n            new_bid_price = round(round((best_bid_price - bid_price_delta) / self.tick_size) * self.tick_size, 2)\n            bdelta = await self.get_new_delta(net_delta, option_gamma, new_bid_price - best_bid_price) - net_bid_delta\n            \n            if bdelta * new_bid_price < -50:\n                print(\"bid ladder\", ladder, new_bid_price, abs(bdelta) * new_bid_price)\n                proposed_bids[new_bid_price] = round(abs(bdelta) * new_bid_price, 0)\n                net_bid_delta += bdelta\n\n            new_ask_price = round(round((best_ask_price + ask_price_delta) / self.tick_size) * self.tick_size, 2)\n            adelta = await self.get_new_delta(net_delta, option_gamma, new_ask_price - best_ask_price) - net_ask_delta\n            \n            if adelta * new_ask_price > 50:\n                print(\"ask ladder\", ladder, new_ask_price, adelta * new_ask_price)\n                proposed_asks[new_ask_price] = round(adelta * new_ask_price, 0)\n                net_ask_delta += adelta\n\n        # submit orders\n        for bid_price in proposed_bids:\n            print(\"bid_ladder\", bid_price, proposed_bids[bid_price])\n            self.exchange.create_limit_buy_order(self.hedge_contract, proposed_bids[bid_price], bid_price, {\"post_only\": True})\n\n        for ask_price in proposed_asks:\n            print(\"ask_ladder\", ask_price, proposed_asks[ask_price])\n            self.exchange.create_limit_sell_order(self.hedge_contract, proposed_asks[ask_price], ask_price, {\"post_only\": True})\n        \n        print(\"====================================\")\n        return index_price, net_delta\n\n    async def get_balance(self, symbol):\n        return self.exchange.fetch_balance({'currency': self.symbol})\n\n    async def run_loop(self):\n        retry_count = 0\n        post_interval = 0\n        index_price = 0\n        prev_delta = 1\n        while not self.done:\n            try:\n                index_price, prev_delta = await self.delta_hedge(index_price, prev_delta)\n                time.sleep(3)\n                post_interval += 3\n\n                if post_interval > 300:\n                    await self.send_to_telegram()\n                    post_interval = 0\n                retry_count = 0\n            except Exception as e:\n                print(\"Hedge failed\", e)\n                retry_count += 1\n                if retry_count >= 9:\n                    self.done = True\n\n    async def send_to_telegram(self):\n        apiToken = '5715880531:AAEX0uW87-SHHTGtG6Wh0wJ3z140nm0l5hU'\n        apiURL = f'https://api.telegram.org/bot{apiToken}/sendMessage'\n        chatID = '1182531369'\n\n        try:\n            message = self.exchange.fetch_balance({'currency': str(self.symbol)})['info']\n            requests.post(apiURL, json={'chat_id': chatID, 'text': message})\n        except Exception as e:\n            print(\"telegram error\", e)\n\n    def run(self):\n        self.done = False\n        loop = asyncio.get_event_loop()\n        loop.run_until_complete(self.run_loop())", ""]}
