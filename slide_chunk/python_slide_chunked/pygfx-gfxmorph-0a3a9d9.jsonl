{"filename": "setup.py", "chunked_list": ["import re\n\nfrom setuptools import find_packages, setup\n\n\nNAME = \"gfxmorph\"\nSUMMARY = \"Morphing meshes\"\n\nwith open(f\"{NAME}/__init__.py\", \"rb\") as fh:\n    init_text = fh.read().decode()\n    VERSION = re.search(r\"__version__ = \\\"(.*?)\\\"\", init_text).group(1)", "with open(f\"{NAME}/__init__.py\", \"rb\") as fh:\n    init_text = fh.read().decode()\n    VERSION = re.search(r\"__version__ = \\\"(.*?)\\\"\", init_text).group(1)\n\n\nruntime_deps = [\n    \"numpy\",\n    \"pygfx\",\n]\n", "]\n\nextras_require = {\n    \"dev\": [\n        \"black\",\n        \"flake8\",\n        \"flake8-black\",\n        \"pep8-naming\",\n        \"pytest\",\n    ],", "        \"pytest\",\n    ],\n}\n\nsetup(\n    name=NAME,\n    version=VERSION,\n    packages=find_packages(\n        exclude=[\"tests\", \"tests.*\", \"examples\", \"examples.*\", \"exp\", \"exp.*\"]\n    ),", "        exclude=[\"tests\", \"tests.*\", \"examples\", \"examples.*\", \"exp\", \"exp.*\"]\n    ),\n    # package_data={f\"{NAME}.data_files\": resources_globs},\n    python_requires=\">=3.8.0\",\n    install_requires=runtime_deps,\n    extras_require=extras_require,\n    license=\"BSD 2-Clause\",\n    description=SUMMARY,\n    long_description=open(\"README.md\").read(),\n    long_description_content_type=\"text/markdown\",", "    long_description=open(\"README.md\").read(),\n    long_description_content_type=\"text/markdown\",\n    author=\"Almar Klein\",\n    author_email=\"almar.klein@gmail.com\",\n    url=\"https://github.com/pygfx/gfxmorph\",\n    data_files=[(\"\", [\"LICENSE\"])],\n    zip_safe=True,\n    classifiers=[\n        \"Development Status :: 3 - Alpha\",\n        \"Intended Audience :: Developers\",", "        \"Development Status :: 3 - Alpha\",\n        \"Intended Audience :: Developers\",\n        \"License :: OSI Approved :: BSD License\",\n        \"Programming Language :: Python :: 3\",\n        \"Topic :: Software Development :: Libraries :: Python Modules\",\n        \"Topic :: Scientific/Engineering :: Visualization\",\n    ],\n    # entry_points={\n    #     \"pyinstaller40\": [\n    #         \"hook-dirs = pygfx.__pyinstaller:get_hook_dirs\",", "    #     \"pyinstaller40\": [\n    #         \"hook-dirs = pygfx.__pyinstaller:get_hook_dirs\",\n    #         \"tests = pygfx.__pyinstaller:get_test_dirs\",\n    #     ],\n    # },\n)\n"]}
{"filename": "example_morph.py", "chunked_list": ["\"\"\"\nExample morphing.\n\"\"\"\n\nimport json\n\nimport numpy as np\nfrom wgpu.gui.auto import WgpuCanvas, run\nimport pygfx as gfx\nimport pylinalg as la", "import pygfx as gfx\nimport pylinalg as la\nfrom gfxmorph.maybe_pygfx import smooth_sphere_geometry, DynamicMeshGeometry\nfrom gfxmorph import DynamicMesh, MeshUndoTracker\nfrom gfxmorph.meshfuncs import vertex_get_neighbours\n\n\n# %% Morph logic\n\n\nclass DynamicMeshGeometryWithSizes(DynamicMeshGeometry):\n    # This is a subclass of both gfx.Geometry and MeshChangeTracker.\n    # This illustrates how we can relatively easily associate additional\n    # buffers with the mesh. In this case we add a buffer for points\n    # sizes to show the selected vertices. If we'd instead use colors\n    # to show selected vertices, that'd work in much the same way.\n\n    def new_vertices_buffer(self, mesh):\n        super().new_vertices_buffer(mesh)\n        self.sizes = gfx.Buffer(np.zeros((self.positions.nitems,), np.float32))", "\n\nclass DynamicMeshGeometryWithSizes(DynamicMeshGeometry):\n    # This is a subclass of both gfx.Geometry and MeshChangeTracker.\n    # This illustrates how we can relatively easily associate additional\n    # buffers with the mesh. In this case we add a buffer for points\n    # sizes to show the selected vertices. If we'd instead use colors\n    # to show selected vertices, that'd work in much the same way.\n\n    def new_vertices_buffer(self, mesh):\n        super().new_vertices_buffer(mesh)\n        self.sizes = gfx.Buffer(np.zeros((self.positions.nitems,), np.float32))", "\n\ndef softlimit(i, limit):\n    \"\"\"Make i be withing <-limit, +limit>, but using soft slopes.\"\"\"\n    f = np.exp(-np.abs(i) / limit)\n    return -limit * (f - 1) * np.sign(i)\n\n\ndef gaussian_weights(f):\n    return np.exp(-0.5 * f * f)  # Gaussian kernel (sigma 1, mu 0)", "def gaussian_weights(f):\n    return np.exp(-0.5 * f * f)  # Gaussian kernel (sigma 1, mu 0)\n\n\nclass Morpher:\n    \"\"\"Container class for everything related to the mesh and morphing it.\"\"\"\n\n    def __init__(self):\n        # The object that stores & manages the data\n        self.m = DynamicMesh(None, None)\n\n        # Tracker that implement a redo stack\n        self.undo_tracker = MeshUndoTracker()\n        self.m.track_changes(self.undo_tracker)\n\n        # Tracker that maps the mesh to a gfx Geometry (with live updates)\n        self.geometry = DynamicMeshGeometryWithSizes()\n        self.m.track_changes(self.geometry)\n\n        self.state = None\n        self.radius = 0.3\n\n        self._create_world_objects()\n\n    def _create_world_objects(self):\n        # The front, to show the mesh itself.\n        self.wob_front = gfx.Mesh(\n            self.geometry,\n            gfx.materials.MeshPhongMaterial(\n                color=\"#6ff\", flat_shading=False, side=\"FRONT\"\n            ),\n        )\n\n        # The back, to show holes and protrusions.\n        self.wob_back = gfx.Mesh(\n            self.geometry,\n            gfx.materials.MeshPhongMaterial(\n                color=\"#900\", flat_shading=False, side=\"BACK\"\n            ),\n        )\n\n        # The wireframe, to show edges.\n        self.wob_wire = gfx.Mesh(\n            self.geometry,\n            gfx.materials.MeshPhongMaterial(\n                color=\"#777\",\n                opacity=0.05,\n                wireframe=True,\n                wireframe_thickness=2,\n                side=\"FRONT\",\n            ),\n        )\n\n        # Helper to show points being grabbed\n        self.wob_points = gfx.Points(\n            self.geometry,\n            gfx.PointsMaterial(color=\"yellow\", vertex_sizes=True),\n        )\n\n        # A gizmo to show the direction of movement.\n        self.wob_gizmo = gfx.Mesh(\n            gfx.cylinder_geometry(0.05, 0.05, 0.5, radial_segments=16),\n            gfx.MeshPhongMaterial(color=\"yellow\"),\n        )\n        self.wob_gizmo.visible = False\n\n        # Radius helper\n        self.wob_radius = gfx.Mesh(\n            smooth_sphere_geometry(subdivisions=2),\n            gfx.MeshPhongMaterial(color=\"yellow\", opacity=0.2, side=\"front\"),\n        )\n        self.wob_radius.visible = False\n\n        self.world_objects = gfx.Group()\n        self.world_objects.add(\n            self.wob_front,\n            self.wob_back,\n            self.wob_wire,\n            self.wob_points,\n            self.wob_gizmo,\n            self.wob_radius,\n        )\n\n    def cancel(self):\n        self.undo_tracker.cancel(self.m)\n\n    def commit(self):\n        self.undo_tracker.commit()\n\n    def undo(self):\n        self.undo_tracker.undo(self.m)\n\n    def redo(self):\n        self.undo_tracker.redo(self.m)\n\n    def highlight(self, highlight):\n        if highlight:\n            # self.wob_radius.visible = True\n            self.wob_wire.material.opacity = 0.075\n        else:\n            self.wob_radius.visible = False\n            self.wob_wire.material.opacity = 0.05\n\n    def show_morph_grab(self, fi, coord):\n        # Get pos\n        coordvec = np.array(coord).reshape(3, 1)\n        vii = self.m.faces[fi]\n        pos = (self.m.positions[vii] * coordvec).sum(axis=0) / np.sum(coordvec)\n        # Adjust world objects\n        self.wob_radius.local.position = pos\n        self.wob_radius.local.scale = self.radius\n        self.wob_radius.visible = True\n\n    def start_morph_from_vertex(self, xy, vi):\n        \"\"\"Initiate a drag, based on a vertex index.\n\n        This method may feel less precise than using ``start_morph_from_face``,\n        but is included for cases where picking capabilities are limited.\n        \"\"\"\n        assert isinstance(vi, int)\n\n        vii = [vi]\n        distances = [0]\n        pos = self.m.positions[vi].copy()\n        normal = self.m.normals[vi].copy()\n\n        return self._start_morph(xy, vii, distances, pos, normal)\n\n    def start_morph_from_face(self, xy, fi, coord):\n        \"\"\"Initiate a drag, based on a face index and face coordinates.\n\n        This allows precise grabbing of the mesh. The face coordinates\n        are barycentric coordinates; for each vertex it indicates how\n        close the grab-point is to that vertex, with 1 being on the\n        vertex and 0 being somewhere on the edge between the other two\n        vertices. A value of (0.5, 0.5, 0.5) represents the center of\n        the face.\n        \"\"\"\n        assert isinstance(fi, int)\n        assert isinstance(coord, (tuple, list)) and len(coord) == 3\n\n        vii = self.m.faces[fi]\n        coord_vec = np.array(coord).reshape(3, 1)\n        pos = (self.m.positions[vii] * coord_vec).sum(axis=0) / np.sum(coord)\n\n        normal = (self.m.normals[vii] * coord_vec).sum(axis=0)\n        normal = normal / np.linalg.norm(normal)\n        distances = np.linalg.norm(self.m.positions[vii] - pos, axis=1)\n\n        return self._start_morph(xy, vii, distances, pos, normal)\n\n    def _start_morph(self, xy, vii, ref_distances, pos, normal):\n        # Select vertices\n        self._select_vertices(vii, ref_distances)\n        if not self.state:\n            return\n\n        # Add more state\n        more_state = {\n            \"action\": \"morph\",\n            \"pos\": pos,\n            \"normal\": normal,\n            \"xy\": xy,\n        }\n        self.state.update(more_state)\n\n        # Bring gizmo into place\n        self.wob_gizmo.visible = True\n        self.wob_gizmo.world.position = pos\n        self.wob_gizmo.local.rotation = la.quat_from_vecs((0, 0, 1), normal)\n\n    def _select_vertices(self, vii, ref_distances):\n        # Cancel any pending changes to the mesh. If we were already dragging,\n        # that operation is cancelled. If other code made uncomitted changes,\n        # these are discarted too (code should have comitted).\n        self.cancel()\n        self.finish()\n\n        # Select vertices\n        search_distance = self.radius * 3  # 3 x std\n        indices, geodesic_distances = self.m.select_vertices_over_surface(\n            vii, ref_distances, search_distance\n        )\n        positions = self.m.positions[indices]\n\n        # Pre-calculate deformation weights\n        weights = gaussian_weights(geodesic_distances / self.radius).reshape(-1, 1)\n\n        # If for some (future) reason, the selection is empty, cancel\n        if len(indices) == 0:\n            return\n\n        # Update data for points that highlight the selection\n        self.geometry.sizes.data[indices] = 7  # 2 + 20*weights.flatten()\n        self.geometry.sizes.update_range(indices.min(), indices.max() + 1)\n\n        # Store state\n        self.state = {\n            \"action\": \"\",\n            \"indices\": indices,\n            \"positions\": positions,\n            \"weights\": weights,\n        }\n\n    def start_smooth(self, xy, fi, coord):\n        \"\"\"Start a smooth action.\"\"\"\n\n        assert isinstance(fi, int)\n        assert isinstance(coord, (tuple, list)) and len(coord) == 3\n\n        vii = self.m.faces[fi]\n        coord_vec = np.array(coord).reshape(3, 1)\n        pos = (self.m.positions[vii] * coord_vec).sum(axis=0) / np.sum(coord)\n        ref_distances = np.linalg.norm(self.m.positions[vii] - pos, axis=1)\n\n        # Select vertices\n        self._select_vertices(vii, ref_distances)\n        if not self.state:\n            return\n\n        # Add more state\n        more_state = {\n            \"action\": \"brush_smooth\",\n            \"xy\": xy,\n        }\n        self.state.update(more_state)\n\n    def move(self, xy):\n        if not self.state:\n            return\n        elif self.state[\"action\"] == \"morph\":\n            self.move_morph(xy)\n        elif self.state[\"action\"] == \"brush_smooth\":\n            self.move_smooth(xy)\n\n    def move_morph(self, xy):\n        if self.state is None or self.state[\"action\"] != \"morph\":\n            return\n\n        # Don't show radius during the drag\n        self.wob_radius.visible = False\n\n        # Get delta movement, and express in world coordinates\n        dxy = np.array(xy) - self.state[\"xy\"]\n        delta = self.state[\"normal\"] * (dxy[1] / 100)\n\n        # Limit the displacement, so it can never be pulled beyond the vertices participarting in the morph.\n        # We limit it to 2 sigma. Vertices up to 3 sigma are displaced.\n        delta_norm = np.linalg.norm(delta)\n        if delta_norm > 0:  # avoid zerodivision\n            delta_norm_limited = softlimit(delta_norm, 2 * self.radius)\n            delta *= delta_norm_limited / delta_norm\n        delta.shape = (1, 3)\n\n        # Apply delta to gizmo\n        self.wob_gizmo.world.position = self.state[\"pos\"] + delta\n\n        # Apply delta\n        self.m.update_vertices(\n            self.state[\"indices\"],\n            self.state[\"positions\"] + delta * self.state[\"weights\"],\n        )\n\n    def move_smooth(self, xy):\n        if self.state is None or self.state[\"action\"] != \"brush_smooth\":\n            return\n\n        # Get delta movement, and express in world coordinates.\n        # Do a smooth \"tick\" when the mouse has moved 10 px.\n        moved_pixel_dist = np.linalg.norm(np.array(xy) - self.state[\"xy\"])\n        if moved_pixel_dist > 10:\n            self._smooth_some()\n            self.state[\"xy\"] = xy\n\n    def _smooth_some(self):\n        # We only smooth each vertex with its direct neighbours, but\n        # when these little smooth operations are applied recursively,\n        # we end up with a pretty Gaussian smooth. Selecting multiple\n        # neighbouring vertices (for each vertex), and applying an\n        # actual Gaussian kernel is problematic, because we may select\n        # zero vertices at low scales (woops nothing happens), or many\n        # at high scales (woops performance).\n        smooth_factor = 0.5  # <-- can be a parameter\n        smooth_factor = max(0.0, min(1.0, smooth_factor))\n\n        faces = self.m.faces\n        positions = self.m.positions\n        vertex2faces = self.m.vertex2faces\n\n        s_indices = self.state[\"indices\"]\n        s_weights = self.state[\"weights\"]\n\n        new_positions = np.zeros((len(s_indices), 3), np.float32)\n        for i in range(len(s_indices)):\n            vi = s_indices[i]\n            w = s_weights[i]\n            p = positions[vi]\n            vii = list(vertex_get_neighbours(faces, vertex2faces, vi))\n            p_delta = (positions[vii] - p).sum(axis=0) / len(vii)\n            new_positions[i] = p + p_delta * (w * smooth_factor)\n\n        # Apply new positions\n        self.m.update_vertices(s_indices, new_positions)\n\n    def finish(self):\n        \"\"\"Stop the morph or smooth action and commit the result.\"\"\"\n        self.wob_gizmo.visible = False\n        if self.state:\n            indices = self.state[\"indices\"]\n            self.geometry.sizes.data[indices] = 0\n            self.geometry.sizes.update_range(indices.min(), indices.max() + 1)\n            self.state = None\n            self.commit()", "\n\nmorpher = Morpher()\n\n\n# %% Setup the viz\n\n\nrenderer = gfx.WgpuRenderer(WgpuCanvas())\n", "renderer = gfx.WgpuRenderer(WgpuCanvas())\n\ncamera = gfx.PerspectiveCamera()\ncamera.show_object((0, 0, 0, 8))\n\nscene = gfx.Scene()\nscene.add(gfx.Background(None, gfx.BackgroundMaterial(0.4, 0.6)))\nscene.add(camera.add(gfx.DirectionalLight()), gfx.AmbientLight())\nscene.add(morpher.world_objects)\n", "scene.add(morpher.world_objects)\n\n\n# %% Functions to modify the mesh\n\n\ndef add_sphere(dx=0, dy=0, dz=0):\n    geo = smooth_sphere_geometry(subdivisions=1)\n    positions, faces = geo.positions.data, geo.indices.data\n    positions += (dx, dy, dz)\n\n    morpher.m.add_mesh(positions, faces)\n    morpher.commit()\n\n    camera.show_object(scene)\n    renderer.request_draw()", "\n\n# %% Create key and mouse bindings\n\nprint(__doc__)\n\n\n# Create controller, also bind it to shift, so we can always hit shift and use the camera\ncontroller = gfx.OrbitController(camera, register_events=renderer)\nfor k in list(controller.controls.keys()):\n    controller.controls[\"shift+\" + k] = controller.controls[k]", "controller = gfx.OrbitController(camera, register_events=renderer)\nfor k in list(controller.controls.keys()):\n    controller.controls[\"shift+\" + k] = controller.controls[k]\n\n\n@renderer.add_event_handler(\"key_down\")\ndef on_key(e):\n    if e.key == \"1\":\n        print(\"Adding a sphere.\")\n        add_sphere()\n\n    elif e.key == \"m\":\n        print(\"Metadata:\")\n        print(json.dumps(morpher.m.metadata, indent=2))\n    elif e.key.lower() == \"z\" and (\"Control\" in e.modifiers or \"Meta\" in e.modifiers):\n        if \"Shift\" in e.modifiers:\n            morpher.redo()\n        else:\n            morpher.undo()\n        renderer.request_draw()", "\n\n@morpher.wob_front.add_event_handler(\n    \"pointer_down\",\n    \"pointer_up\",\n    \"pointer_move\",\n    \"pointer_enter\",\n    \"pointer_leave\",\n    \"wheel\",\n)\ndef on_mouse(e):\n    if \"Shift\" in e.modifiers:\n        # Don't react when shift is down, so that the controller can work\n        morpher.highlight(None)\n        renderer.request_draw()\n    elif e.type == \"pointer_down\" and e.button == 1:\n        face_index = e.pick_info[\"face_index\"]\n        face_coord = e.pick_info[\"face_coord\"]\n        morpher.start_morph_from_face((e.x, e.y), face_index, face_coord)\n        renderer.request_draw()\n        e.target.set_pointer_capture(e.pointer_id, e.root)\n    elif e.type == \"pointer_down\" and e.button == 2:\n        face_index = e.pick_info[\"face_index\"]\n        face_coord = e.pick_info[\"face_coord\"]\n        morpher.start_smooth((e.x, e.y), face_index, face_coord)\n        renderer.request_draw()\n        e.target.set_pointer_capture(e.pointer_id, e.root)\n    elif e.type == \"pointer_up\":\n        morpher.finish()\n        renderer.request_draw()\n    elif e.type == \"pointer_move\":\n        if morpher.state:\n            morpher.move((e.x, e.y))\n        else:\n            face_index = e.pick_info[\"face_index\"]\n            face_coord = e.pick_info[\"face_coord\"]\n            morpher.show_morph_grab(face_index, face_coord)\n        renderer.request_draw()\n    elif e.type == \"pointer_enter\":\n        morpher.highlight(True)\n        renderer.request_draw()\n    elif e.type == \"pointer_leave\":\n        morpher.highlight(False)\n        renderer.request_draw()\n    elif e.type == \"wheel\":\n        if not morpher.state:\n            morpher.radius *= 2 ** (e.dy / 500)\n            face_index = e.pick_info[\"face_index\"]\n            face_coord = e.pick_info[\"face_coord\"]\n            morpher.show_morph_grab(face_index, face_coord)\n            renderer.request_draw()\n            e.cancel()", "    \"wheel\",\n)\ndef on_mouse(e):\n    if \"Shift\" in e.modifiers:\n        # Don't react when shift is down, so that the controller can work\n        morpher.highlight(None)\n        renderer.request_draw()\n    elif e.type == \"pointer_down\" and e.button == 1:\n        face_index = e.pick_info[\"face_index\"]\n        face_coord = e.pick_info[\"face_coord\"]\n        morpher.start_morph_from_face((e.x, e.y), face_index, face_coord)\n        renderer.request_draw()\n        e.target.set_pointer_capture(e.pointer_id, e.root)\n    elif e.type == \"pointer_down\" and e.button == 2:\n        face_index = e.pick_info[\"face_index\"]\n        face_coord = e.pick_info[\"face_coord\"]\n        morpher.start_smooth((e.x, e.y), face_index, face_coord)\n        renderer.request_draw()\n        e.target.set_pointer_capture(e.pointer_id, e.root)\n    elif e.type == \"pointer_up\":\n        morpher.finish()\n        renderer.request_draw()\n    elif e.type == \"pointer_move\":\n        if morpher.state:\n            morpher.move((e.x, e.y))\n        else:\n            face_index = e.pick_info[\"face_index\"]\n            face_coord = e.pick_info[\"face_coord\"]\n            morpher.show_morph_grab(face_index, face_coord)\n        renderer.request_draw()\n    elif e.type == \"pointer_enter\":\n        morpher.highlight(True)\n        renderer.request_draw()\n    elif e.type == \"pointer_leave\":\n        morpher.highlight(False)\n        renderer.request_draw()\n    elif e.type == \"wheel\":\n        if not morpher.state:\n            morpher.radius *= 2 ** (e.dy / 500)\n            face_index = e.pick_info[\"face_index\"]\n            face_coord = e.pick_info[\"face_coord\"]\n            morpher.show_morph_grab(face_index, face_coord)\n            renderer.request_draw()\n            e.cancel()", "\n\n# %% Run\n\nadd_sphere()\nadd_sphere(3, 0, 0)\n\n\ndef animate():\n    renderer.render(scene, camera)", "def animate():\n    renderer.render(scene, camera)\n\n\nrenderer.request_draw(animate)\n\nrun()\n"]}
{"filename": "example_undo.py", "chunked_list": ["\"\"\"\nExample for demonstrating the dynamic mesh.\n\nKey bindings:\n\n* 1: add sphere mesh\n* 2: add 2 spheres connected by a corrupt face\n* h: remove a random face, creating a hole\n* r: repair (note, can only repair small holes)\n* m: print metadata", "* r: repair (note, can only repair small holes)\n* m: print metadata\n\n\"\"\"\n\nimport json\n\nimport numpy as np\nfrom wgpu.gui.auto import WgpuCanvas\nimport pygfx as gfx", "from wgpu.gui.auto import WgpuCanvas\nimport pygfx as gfx\nfrom gfxmorph.maybe_pygfx import smooth_sphere_geometry, DynamicMeshGeometry\nfrom gfxmorph import DynamicMesh, MeshUndoTracker\nimport observ.store\n\n\n# --- Setup the mesh\n\n\nclass MeshContainer:\n    \"\"\"Just a container to keep all stuff related to the mesh together.\"\"\"\n\n    def __init__(self):\n        # The object that stores & manages the data\n        self.dynamic_mesh = DynamicMesh(None, None)\n\n        # Tracker that implement a redo stack\n        self.undo_tracker = MeshUndoTracker()\n        self.dynamic_mesh.track_changes(self.undo_tracker)\n\n        # Tracker that maps the mesh to a gfx Geometry (with live updates)\n        self.geometry = DynamicMeshGeometry()\n        self.dynamic_mesh.track_changes(self.geometry)\n\n        # Two world objects, one for the front and one for the back (so we can clearly see holes)\n        self.ob1 = gfx.Mesh(\n            self.geometry,\n            gfx.materials.MeshPhongMaterial(\n                color=\"green\", flat_shading=False, side=\"FRONT\"\n            ),\n        )\n        self.ob2 = gfx.Mesh(\n            self.geometry,\n            gfx.materials.MeshPhongMaterial(\n                color=\"red\", flat_shading=False, side=\"BACK\"\n            ),\n        )\n\n    def get_state(self):\n        return self.undo_tracker.commit()\n\n    def set_state(self, state):\n        self.undo_tracker.apply_version(self.dynamic_mesh, state)", "\n\nclass MeshContainer:\n    \"\"\"Just a container to keep all stuff related to the mesh together.\"\"\"\n\n    def __init__(self):\n        # The object that stores & manages the data\n        self.dynamic_mesh = DynamicMesh(None, None)\n\n        # Tracker that implement a redo stack\n        self.undo_tracker = MeshUndoTracker()\n        self.dynamic_mesh.track_changes(self.undo_tracker)\n\n        # Tracker that maps the mesh to a gfx Geometry (with live updates)\n        self.geometry = DynamicMeshGeometry()\n        self.dynamic_mesh.track_changes(self.geometry)\n\n        # Two world objects, one for the front and one for the back (so we can clearly see holes)\n        self.ob1 = gfx.Mesh(\n            self.geometry,\n            gfx.materials.MeshPhongMaterial(\n                color=\"green\", flat_shading=False, side=\"FRONT\"\n            ),\n        )\n        self.ob2 = gfx.Mesh(\n            self.geometry,\n            gfx.materials.MeshPhongMaterial(\n                color=\"red\", flat_shading=False, side=\"BACK\"\n            ),\n        )\n\n    def get_state(self):\n        return self.undo_tracker.commit()\n\n    def set_state(self, state):\n        self.undo_tracker.apply_version(self.dynamic_mesh, state)", "\n\nmesh = MeshContainer()\n\n\n# --- Setup the store\n\n\nclass Store(observ.store.Store):\n    \"\"\"The observ store to track thet mesh state. In real applications\n    the store will also contain other state.\n    \"\"\"\n\n    @observ.store.mutation\n    def set_mesh_state(self, state):\n        self.state[\"mesh_state\"] = state", "class Store(observ.store.Store):\n    \"\"\"The observ store to track thet mesh state. In real applications\n    the store will also contain other state.\n    \"\"\"\n\n    @observ.store.mutation\n    def set_mesh_state(self, state):\n        self.state[\"mesh_state\"] = state\n\n", "\n\nstore = Store({\"mesh_state\": 0})\n\n# The watch() function re-calls the first function whenever any\n# observables that it uses change, and then passes the result to the\n# second function.\n_ = observ.watch(\n    lambda: store.state[\"mesh_state\"],\n    mesh.set_state,", "    lambda: store.state[\"mesh_state\"],\n    mesh.set_state,\n    sync=True,\n    immediate=True,\n)\n\n\n# --- Functions to modify the mesh\n\n", "\n\n# Convenience function to take a snapshot of the mesh\ndef save_mesh_state():\n    store.set_mesh_state(mesh.get_state())\n\n\ndef add_mesh():\n    geo = smooth_sphere_geometry(subdivisions=1)\n    positions, faces = geo.positions.data, geo.indices.data\n    positions += np.random.normal(0, 5, size=(3,))\n\n    mesh.dynamic_mesh.add_mesh(positions, faces)\n    save_mesh_state()\n\n    camera.show_object(scene)\n    renderer.request_draw()", "\n\ndef add_broken_mesh():\n    geo = smooth_sphere_geometry()\n    positions1, faces1 = geo.positions.data, geo.indices.data\n    positions1 += np.random.normal(0, 5, size=(3,))\n\n    positions2 = positions1 + (2.2, 0, 0)\n    faces2 = faces1 + len(positions1)\n\n    faces3 = [[faces2[10][0], faces2[10][1], faces1[20][0]]]\n\n    mesh.dynamic_mesh.add_mesh(\n        np.concatenate([positions1, positions2]),\n        np.concatenate([faces1, faces2, faces3]),\n    )\n\n    camera.show_object(scene)\n    renderer.request_draw()\n    save_mesh_state()", "\n\ndef breakit():\n    nfaces = len(mesh.dynamic_mesh.faces)\n    mesh.dynamic_mesh.delete_faces(np.random.randint(0, nfaces))\n    save_mesh_state()\n\n\ndef repair():\n    mesh.dynamic_mesh.repair(True)\n\n    # Only store new state if there was indeed a change\n    if mesh.undo_tracker.has_pending_changes():\n        save_mesh_state()", "def repair():\n    mesh.dynamic_mesh.repair(True)\n\n    # Only store new state if there was indeed a change\n    if mesh.undo_tracker.has_pending_changes():\n        save_mesh_state()\n\n\n# --- Setup the viz\n", "# --- Setup the viz\n\n\nrenderer = gfx.WgpuRenderer(WgpuCanvas())\n\ncamera = gfx.OrthographicCamera()\ncamera.show_object((0, 0, 0, 8))\n\nscene = gfx.Scene()\nscene.add(gfx.Background(None, gfx.BackgroundMaterial(0.4, 0.6)))", "scene = gfx.Scene()\nscene.add(gfx.Background(None, gfx.BackgroundMaterial(0.4, 0.6)))\nscene.add(camera.add(gfx.DirectionalLight()), gfx.AmbientLight())\nscene.add(mesh.ob1, mesh.ob2)\n\n\n# --- Create key bindings\n\n\nprint(__doc__)", "\nprint(__doc__)\n\n\n@renderer.add_event_handler(\"key_down\")\ndef on_key(e):\n    if e.key == \"1\":\n        print(\"Adding a sphere.\")\n        add_mesh()\n    elif e.key == \"2\":\n        print(\"Adding 2 spheres connected with a corrupt face.\")\n        add_broken_mesh()\n    elif e.key == \"h\":\n        print(\"Creating a hole.\")\n        breakit()\n    elif e.key == \"r\":\n        print(\"Repairing.\")\n        repair()\n    elif e.key == \"m\":\n        print(\"Metadata:\")\n        print(json.dumps(mesh.dynamic_mesh.metadata, indent=2))\n    elif e.key.lower() == \"z\" and (\"Control\" in e.modifiers or \"Meta\" in e.modifiers):\n        if \"Shift\" in e.modifiers:\n            store.redo()\n        else:\n            store.undo()", "\n\n# --- Run\n\n\ngfx.show(scene, camera=camera, renderer=renderer)\n"]}
{"filename": "tests/test_pygfx.py", "chunked_list": ["import numpy as np\nimport pylinalg as la\n\nfrom gfxmorph.maybe_pygfx import smooth_sphere_geometry\nfrom gfxmorph.maybe_pylinalg import volume_of_closed_mesh\nfrom testutils import run_tests\n\n\ndef test_smooth_sphere_geometry():\n    # subdivisions\n\n    g = smooth_sphere_geometry(1)\n    assert g.indices.data.shape == (60, 3)\n    assert g.positions.data.shape == (32, 3)\n\n    g = smooth_sphere_geometry(1, subdivisions=1)\n    assert g.indices.data.shape == (60 * 4, 3)\n    assert g.positions.data.shape == (60 * 4 / 2 + 2, 3)\n\n    g = smooth_sphere_geometry(1, subdivisions=2)\n    assert g.indices.data.shape == (60 * 16, 3)\n    assert g.positions.data.shape == (60 * 16 / 2 + 2, 3)\n\n    # max_edge_length\n\n    def get_edge_length(g):\n        ia, ib, _ = g.indices.data[0]\n        a, b = g.positions.data[[ia, ib]]\n        return la.vec_dist(a, b)\n\n    g = smooth_sphere_geometry(1, max_edge_length=1)\n    assert g.indices.data.shape == (60, 3)\n    assert get_edge_length(g) < 1\n\n    g = smooth_sphere_geometry(0.5, max_edge_length=0.5)\n    assert g.indices.data.shape == (60, 3)\n    assert get_edge_length(g) < 0.5\n\n    g = smooth_sphere_geometry(1, max_edge_length=0.5)\n    assert g.indices.data.shape == (60 * 4, 3)\n    assert get_edge_length(g) < 0.5\n\n    g = smooth_sphere_geometry(2, max_edge_length=1)\n    assert g.indices.data.shape == (60 * 4, 3)\n    assert get_edge_length(g) < 1\n\n    g = smooth_sphere_geometry(2, max_edge_length=0.5)\n    assert g.indices.data.shape == (60 * 16, 3)\n    assert get_edge_length(g) < 0.5\n\n    # radius, volume, and max_edge_length\n\n    for radius in (0.4, 0.8, 1.2, 1.4):\n        volume_errors = []\n        for el in (0.4, 0.3, 0.2, 0.1):\n            g = smooth_sphere_geometry(radius, max_edge_length=el)\n            assert get_edge_length(g) < el\n            assert np.allclose(np.linalg.norm(g.positions.data, axis=1), radius)\n\n            expected_v = (4 / 3) * np.pi * radius**3\n            v = volume_of_closed_mesh(g.positions.data, g.indices.data)\n            assert np.allclose(v, expected_v, atol=0.5 * el)\n            volume_errors.append(expected_v - v)\n\n        # Check that more subdivisions produces a better approximation os a sphere\n        assert volume_errors[0] > volume_errors[-1]", "def test_smooth_sphere_geometry():\n    # subdivisions\n\n    g = smooth_sphere_geometry(1)\n    assert g.indices.data.shape == (60, 3)\n    assert g.positions.data.shape == (32, 3)\n\n    g = smooth_sphere_geometry(1, subdivisions=1)\n    assert g.indices.data.shape == (60 * 4, 3)\n    assert g.positions.data.shape == (60 * 4 / 2 + 2, 3)\n\n    g = smooth_sphere_geometry(1, subdivisions=2)\n    assert g.indices.data.shape == (60 * 16, 3)\n    assert g.positions.data.shape == (60 * 16 / 2 + 2, 3)\n\n    # max_edge_length\n\n    def get_edge_length(g):\n        ia, ib, _ = g.indices.data[0]\n        a, b = g.positions.data[[ia, ib]]\n        return la.vec_dist(a, b)\n\n    g = smooth_sphere_geometry(1, max_edge_length=1)\n    assert g.indices.data.shape == (60, 3)\n    assert get_edge_length(g) < 1\n\n    g = smooth_sphere_geometry(0.5, max_edge_length=0.5)\n    assert g.indices.data.shape == (60, 3)\n    assert get_edge_length(g) < 0.5\n\n    g = smooth_sphere_geometry(1, max_edge_length=0.5)\n    assert g.indices.data.shape == (60 * 4, 3)\n    assert get_edge_length(g) < 0.5\n\n    g = smooth_sphere_geometry(2, max_edge_length=1)\n    assert g.indices.data.shape == (60 * 4, 3)\n    assert get_edge_length(g) < 1\n\n    g = smooth_sphere_geometry(2, max_edge_length=0.5)\n    assert g.indices.data.shape == (60 * 16, 3)\n    assert get_edge_length(g) < 0.5\n\n    # radius, volume, and max_edge_length\n\n    for radius in (0.4, 0.8, 1.2, 1.4):\n        volume_errors = []\n        for el in (0.4, 0.3, 0.2, 0.1):\n            g = smooth_sphere_geometry(radius, max_edge_length=el)\n            assert get_edge_length(g) < el\n            assert np.allclose(np.linalg.norm(g.positions.data, axis=1), radius)\n\n            expected_v = (4 / 3) * np.pi * radius**3\n            v = volume_of_closed_mesh(g.positions.data, g.indices.data)\n            assert np.allclose(v, expected_v, atol=0.5 * el)\n            volume_errors.append(expected_v - v)\n\n        # Check that more subdivisions produces a better approximation os a sphere\n        assert volume_errors[0] > volume_errors[-1]", "\n\nif __name__ == \"__main__\":\n    run_tests(globals())\n"]}
{"filename": "tests/test_dynamicmesh.py", "chunked_list": ["import numpy as np\nimport pytest\n\nfrom gfxmorph import maybe_pygfx\nfrom gfxmorph import DynamicMesh\nfrom testutils import run_tests\nfrom gfxmorph.mesh import MeshPathSmooth1, MeshPathSmooth2\n\n\ndef test_mesh_basics():\n    geo = maybe_pygfx.smooth_sphere_geometry(1, subdivisions=3)\n    vertices = geo.positions.data\n    faces = geo.indices.data\n\n    # Create a silly mesh consisting of a single triangle\n    triangle = [[0, 0, 0], [0, 0, 1], [0, 1, 0]]\n    m = DynamicMesh(triangle, [[0, 1, 2]])\n    assert not m.is_closed\n    assert m.get_surface_area() == 0.5\n    with pytest.raises(RuntimeError):\n        m.get_volume()  # cannot be calculated on an open mesh\n\n    # Cannot creata a null mesh\n    with pytest.raises(ValueError):\n        DynamicMesh(np.zeros((0, 3), np.float32), np.zeros((0, 3), np.int32))\n    with pytest.raises(ValueError):\n        DynamicMesh(triangle, np.zeros((0, 3), np.int32))\n    with pytest.raises(ValueError):\n        DynamicMesh(np.zeros((0, 3), np.float32), [[0, 1, 2]])\n\n    # Empty mesh\n    m = DynamicMesh(None, None)\n    assert m.get_volume() == 0.0\n    assert m.get_surface_area() == 0.0\n\n    # Creat mesh and check its volume and surface\n    m = DynamicMesh(vertices, faces)\n    expected_volume = (4 / 3) * np.pi\n    expected_area = 4 * np.pi\n    assert 0.99 * expected_area < m.get_surface_area() < expected_area\n    assert 0.99 * expected_volume < m.get_volume() < expected_volume\n    assert m.is_closed\n    assert m.component_count == 1\n    assert m.is_connected\n\n    # Metadata\n    d = m.metadata\n    assert isinstance(d, dict)\n    assert \"is_edge_manifold\" in d\n    assert \"approx_mem\" in d\n\n    # Create a mesh with two objects\n    vertices2 = np.row_stack([vertices + 10, vertices + 20])\n    faces2 = np.row_stack([faces, faces + len(vertices)])\n\n    # Check its volume\n    m = DynamicMesh(vertices2, faces2)\n    expected_volume = 2 * (4 / 3) * np.pi\n    assert 0.9 * expected_volume < m.get_volume() < expected_volume\n    assert m.is_closed\n    assert m.component_count == 2\n    assert not m.is_connected\n\n    # Now turn the meshes inside out\n    faces2[:, 1], faces2[:, 2] = faces2[:, 2].copy(), faces2[:, 1].copy()\n\n    # The repair mechanism will flip exactly what's needed to fix up the mesh!\n    m = DynamicMesh(vertices2, faces2)\n    expected_volume = 2 * (4 / 3) * np.pi\n    assert m.get_volume() < 0\n    m.repair()\n    assert 0.9 * expected_volume < m.get_volume() < expected_volume\n    assert m.is_closed\n    assert m.component_count == 2", "\ndef test_mesh_basics():\n    geo = maybe_pygfx.smooth_sphere_geometry(1, subdivisions=3)\n    vertices = geo.positions.data\n    faces = geo.indices.data\n\n    # Create a silly mesh consisting of a single triangle\n    triangle = [[0, 0, 0], [0, 0, 1], [0, 1, 0]]\n    m = DynamicMesh(triangle, [[0, 1, 2]])\n    assert not m.is_closed\n    assert m.get_surface_area() == 0.5\n    with pytest.raises(RuntimeError):\n        m.get_volume()  # cannot be calculated on an open mesh\n\n    # Cannot creata a null mesh\n    with pytest.raises(ValueError):\n        DynamicMesh(np.zeros((0, 3), np.float32), np.zeros((0, 3), np.int32))\n    with pytest.raises(ValueError):\n        DynamicMesh(triangle, np.zeros((0, 3), np.int32))\n    with pytest.raises(ValueError):\n        DynamicMesh(np.zeros((0, 3), np.float32), [[0, 1, 2]])\n\n    # Empty mesh\n    m = DynamicMesh(None, None)\n    assert m.get_volume() == 0.0\n    assert m.get_surface_area() == 0.0\n\n    # Creat mesh and check its volume and surface\n    m = DynamicMesh(vertices, faces)\n    expected_volume = (4 / 3) * np.pi\n    expected_area = 4 * np.pi\n    assert 0.99 * expected_area < m.get_surface_area() < expected_area\n    assert 0.99 * expected_volume < m.get_volume() < expected_volume\n    assert m.is_closed\n    assert m.component_count == 1\n    assert m.is_connected\n\n    # Metadata\n    d = m.metadata\n    assert isinstance(d, dict)\n    assert \"is_edge_manifold\" in d\n    assert \"approx_mem\" in d\n\n    # Create a mesh with two objects\n    vertices2 = np.row_stack([vertices + 10, vertices + 20])\n    faces2 = np.row_stack([faces, faces + len(vertices)])\n\n    # Check its volume\n    m = DynamicMesh(vertices2, faces2)\n    expected_volume = 2 * (4 / 3) * np.pi\n    assert 0.9 * expected_volume < m.get_volume() < expected_volume\n    assert m.is_closed\n    assert m.component_count == 2\n    assert not m.is_connected\n\n    # Now turn the meshes inside out\n    faces2[:, 1], faces2[:, 2] = faces2[:, 2].copy(), faces2[:, 1].copy()\n\n    # The repair mechanism will flip exactly what's needed to fix up the mesh!\n    m = DynamicMesh(vertices2, faces2)\n    expected_volume = 2 * (4 / 3) * np.pi\n    assert m.get_volume() < 0\n    m.repair()\n    assert 0.9 * expected_volume < m.get_volume() < expected_volume\n    assert m.is_closed\n    assert m.component_count == 2", "\n\ndef test_mesh_edges():\n    vertices = np.zeros((4, 3), np.float32)\n    faces = [(0, 1, 2), (0, 2, 3)]\n    m = DynamicMesh(vertices, faces)\n\n    assert m.edges.tolist() == [[0, 1], [1, 2], [2, 0], [0, 2], [2, 3], [3, 0]]\n\n\ndef test_mesh_selection_basics():\n    # Create a mesh\n    geo = maybe_pygfx.smooth_sphere_geometry(1, subdivisions=1)\n    vertices = geo.positions.data\n    faces = geo.indices.data\n    m = DynamicMesh(vertices, faces)\n\n    # Select a vertex, twice\n    i1, d1 = m.get_closest_vertex((-2, 0, 0))\n    i2, d2 = m.get_closest_vertex((+2, 0, 0))\n\n    assert i1 != i2\n    assert d1 == 1.0\n    assert d2 == 1.0\n\n    # Select over surface\n    selected1, _ = m.select_vertices_over_surface(i1, 0, 0.5)\n    selected2, _ = m.select_vertices_over_surface(i2, 0, 0.5)\n\n    # Since this mesh is very regular, the selected number must be the same\n    assert len(selected1) == 7\n    assert len(selected2) == 7\n\n    # Select over surface, with very high distance, so that the whole mesh is selected\n    selected1, _ = m.select_vertices_over_surface(i1, 0, 4)\n    selected2, _ = m.select_vertices_over_surface(i2, 0, 4)\n\n    assert np.all(selected1 == selected2)\n    assert len(selected1) == len(vertices)", "\n\ndef test_mesh_selection_basics():\n    # Create a mesh\n    geo = maybe_pygfx.smooth_sphere_geometry(1, subdivisions=1)\n    vertices = geo.positions.data\n    faces = geo.indices.data\n    m = DynamicMesh(vertices, faces)\n\n    # Select a vertex, twice\n    i1, d1 = m.get_closest_vertex((-2, 0, 0))\n    i2, d2 = m.get_closest_vertex((+2, 0, 0))\n\n    assert i1 != i2\n    assert d1 == 1.0\n    assert d2 == 1.0\n\n    # Select over surface\n    selected1, _ = m.select_vertices_over_surface(i1, 0, 0.5)\n    selected2, _ = m.select_vertices_over_surface(i2, 0, 0.5)\n\n    # Since this mesh is very regular, the selected number must be the same\n    assert len(selected1) == 7\n    assert len(selected2) == 7\n\n    # Select over surface, with very high distance, so that the whole mesh is selected\n    selected1, _ = m.select_vertices_over_surface(i1, 0, 4)\n    selected2, _ = m.select_vertices_over_surface(i2, 0, 4)\n\n    assert np.all(selected1 == selected2)\n    assert len(selected1) == len(vertices)", "\n\ndef test_mesh_path_distance():\n    \"\"\"This test validates the test_MeshPathSmooth2 class directly.\"\"\"\n\n    def follow_points1(points):\n        path = MeshPathSmooth1()\n        for p, n in zip(points, normals):\n            new_path = path.add(p, n)\n            assert new_path.dist >= path.dist\n            path = new_path\n        return path\n\n    def follow_points2(points):\n        path = MeshPathSmooth2()\n        for p, n in zip(points, normals):\n            new_path = path.add(p, n)\n            assert new_path.dist >= path.dist\n            assert new_path.dist <= new_path.edist * 1.0000001\n            path = new_path\n        return path\n\n    # Create a bunch of points on a semi-circle. The points are on a curved line,\n    # but from the surface pov this is a straight line, i.e. a geodesic.\n    # We make the distance between each two points 0.1, for easy math.\n    t = np.linspace(0, np.pi, 11)\n    points1 = np.zeros((11, 3), np.float32)\n    points1[:, 0] = np.sin(t)\n    points1[:, 1] = np.cos(t)\n    points1 /= 3.1286892  # precalculated\n    assert 0.1, np.linalg.norm(points1[0] - points1[1]) < 0.10001\n\n    # Since we rotate around the origin, we can easily calculate the surface normals\n    normals = points1 / np.linalg.norm(points1, axis=1).reshape(-1, 1)\n\n    # Follow this straight line with the smooth1 approach,\n    # just to show that it does cut corners. Not good!\n    path = follow_points1(points1)\n    assert 0.99999 < path.edist < 1.000001\n    assert 0.93 < path.dist < 0.94  # 6% shorter\n\n    # Follow the same straight line but with the smooth2 approach,\n    # that attempt to follow the surface. Much better!\n    path = follow_points2(points1)\n    assert 0.99999 < path.edist < 1.000001\n    assert 0.99999 < path.dist < 1.000001  # 0% error\n\n    # Now displace the points, simulating the irregular patterns of triangles on a mesh ...\n\n    # A subtle zig-zag\n    points2 = points1.copy()\n    points2[1:-1:2, 2] = -0.02\n    points2[2:-1:2, 2] = +0.02\n    # The path is a bit longer, but we manage to bring it back!\n    path = follow_points2(points2)\n    assert 1.06 < path.edist < 1.07  # The path is 6% longer\n    assert 1.00 < path.dist < 1.01  # Less than 1% left\n\n    # A moderate zig-zag.\n    # This represents a worst-case path through a mesh with normally sized triangles.\n    points2 = points1.copy()\n    points2[1:-1:2, 2] = -0.05\n    points2[2:-1:2, 2] = +0.05\n    # The path is much longer, but we manage to bring it back!\n    path = follow_points2(points2)\n    assert 1.35 < path.edist < 1.36  # The path is 36% longer\n    assert 1.03 < path.dist < 1.04  # Just about 3% left\n\n    # A big zig-zag.\n    # This represents a very worst-case path through very narrow triangles.\n    points2 = points1.copy()\n    points2[1:-1:2, 2] = -0.2\n    points2[2:-1:2, 2] = +0.2\n    # The path is MUCH longer, but we manage to bring it back!\n    path = follow_points2(points2)\n    assert 3.74 < path.edist < 3.75  # The path is 274% longer\n    assert 1.27 < path.dist < 1.28  # Just 27% left\n\n    # A straight line with a few points moved to the side.\n    # Depending on how the surface-distance is calculated, the opposing\n    # sides of the zig-zag may help iron out the line. This use-case\n    # does not have this effect. The current implementation does not\n    # really suffer from this effect and is able to \"straighten\"  this\n    # line just as well.\n    points2 = points1.copy()\n    points2[1:-1:4, 2] = -0.1\n    # The path is longer and we can straighten it out.\n    path = follow_points2(points2)\n    assert 1.24 < path.edist < 1.25  # The path is 25% longer\n    assert 1.02 < path.dist < 1.03  # Just 3% left", "\n\ndef test_mesh_selection_precision():\n    \"\"\"This test validates the precision of the mesh selection.\n    It implicitly tests the MeshPathSmooth2 class on real mesh data.\n    \"\"\"\n\n    # Create a mesh\n    radius = 1\n    geo = maybe_pygfx.smooth_sphere_geometry(radius, subdivisions=1)\n    vertices = geo.positions.data\n    faces = geo.indices.data\n    m = DynamicMesh(vertices, faces)\n\n    # Select top vertex, and vertices at the middle of the sphere. There\n    # is a nice line of vertices at exactly the equator of the sphere\n    # (with just a few interruptions). There are no straight lines of\n    # vertices going from the top to the equator (meridians), therefore\n    # we observe pretty uniform distance-errors.\n    assert len(vertices) == 122\n    vii_top = np.where(vertices[:, 2] == 1)[0]\n    assert len(vii_top) == 1\n    vi_top = vii_top[0]\n    vii_middle = np.where(vertices[:, 2] == 0)[0]\n    assert len(vii_middle) == 16\n\n    # The distance to each of the middle points (from the top) is ideally ...\n    circumference = 2 * np.pi * radius\n    ideal_dist = circumference / 4  # i.e. a quarter pi, numnum\n\n    # Select vertices EDGE\n    max_dist = ideal_dist * 1.1\n    selected, distances = m.select_vertices_over_surface(vi_top, 0, max_dist, \"edge\")\n    assert len(selected) < 80\n    assert not set(vii_middle).difference(selected)  # all middle points are selected\n\n    # The most awkward path to the equator costs about 8% more distance\n    vii_dists = [(vi, d) for vi, d in zip(selected, distances) if vi in vii_middle]\n    d = max(d for _, d in vii_dists)\n    assert 1.08 < d / ideal_dist < 1.09\n\n    # Select vertices SURFACE\n    max_dist = ideal_dist * 1.1\n    selected, distances = m.select_vertices_over_surface(vi_top, 0, max_dist, \"smooth2\")\n    assert len(selected) < 80\n    assert not set(vii_middle).difference(selected)  # all middle points are selected\n\n    # Now just 3% more distance\n    vii_dists = [(vi, d) for vi, d in zip(selected, distances) if vi in vii_middle]\n    d = max(d for _, d in vii_dists)\n    assert 1.02 < d / ideal_dist < 1.03\n\n    # Now flatten the sphere. In the above, because the surface is curved,\n    # the distances \"cut the corner\" and are smaller, which hides some\n    # of the error in distance. By creating a flat surface we can measure\n    # the distance of the error without this effect.\n\n    # Upate mesh\n    vertices[:, 2] = 0\n    m.update_vertices(np.arange(len(vertices)), vertices)\n\n    # The distance to each of the middle points (from the center) is ideally ...\n    ideal_dist = radius  # i.e. 1\n\n    # Select vertices EDGE\n    max_dist = ideal_dist * 1.3\n    selected, distances = m.select_vertices_over_surface(vi_top, 0, max_dist, \"edge\")\n    assert len(selected) < 102\n    assert not set(vii_middle).difference(selected)  # all middle points are selected\n\n    # The most awkward path to the equator costs about 26% more distance\n    vii_dists = [(vi, d) for vi, d in zip(selected, distances) if vi in vii_middle]\n    d = max(d for _, d in vii_dists)\n    assert 1.25 < d / ideal_dist < 1.26\n\n    # Select vertices SURFACE\n    max_dist = ideal_dist * 1.3\n    selected, distances = m.select_vertices_over_surface(vi_top, 0, max_dist, \"smooth2\")\n    assert len(selected) < 102\n    assert not set(vii_middle).difference(selected)  # all middle points are selected\n\n    # Now just 7% more distance\n    vii_dists = [(vi, d) for vi, d in zip(selected, distances) if vi in vii_middle]\n    d = max(d for _, d in vii_dists)\n    assert 1.06 < d / ideal_dist < 1.07", "\n\nif __name__ == \"__main__\":\n    run_tests(globals())\n"]}
{"filename": "tests/test_corrupt.py", "chunked_list": ["\"\"\"\nTest on adverserial cases. The word corrupt is used very generous here,\ne.g. it's also used for open manifolds.\n\"\"\"\n\nimport numpy as np\nimport pygfx as gfx\nimport pytest\n\nimport gfxmorph", "\nimport gfxmorph\n\nfrom testutils import (\n    run_tests,\n    iter_test_meshes,\n    iter_closed_meshes,\n    get_quad,\n    get_sphere,\n    iter_fans,", "    get_sphere,\n    iter_fans,\n)\n\n\n# Set to 1 to perform these tests on skcg, as a validation check\nUSE_SKCG = 0\n\nif USE_SKCG:\n    import skcg\n\n    MeshClass = skcg.Mesh\nelse:\n    MeshClass = gfxmorph.DynamicMesh", "if USE_SKCG:\n    import skcg\n\n    MeshClass = skcg.Mesh\nelse:\n    MeshClass = gfxmorph.DynamicMesh\n\n\n# %% Some basic tests first\n", "# %% Some basic tests first\n\n\ndef test_raw_meshes():\n    \"\"\"Test that the raw meshes, unchanged, are what we expect them to be.\"\"\"\n    count = 0\n    for vertices, faces, is_closed in iter_test_meshes():\n        count += 1\n        m = MeshClass(vertices, faces)\n        assert m.is_manifold\n        assert m.is_closed == is_closed\n        assert m.is_oriented\n\n    assert count == 6", "\n\ndef test_a_single_triangle():\n    \"\"\"A single triangle is an open oriented manifold.\"\"\"\n\n    vertices = [\n        [-1, -1, 0],\n        [+1, -1, 0],\n        [+1, +1, 0],\n    ]\n    faces = [\n        [0, 2, 1],\n    ]\n\n    m = MeshClass(vertices, faces)\n\n    assert m.is_manifold\n    assert not m.is_closed\n    assert m.is_oriented", "\n\ndef test_a_null_mesh():\n    m = MeshClass(None, None)\n\n    # I'm not sure what would be correct, but  I guess with zero faces all conditions are valid?\n    assert m.is_manifold\n    assert m.is_closed\n    assert m.is_oriented\n", "\n\ndef test_invalid_faces():\n    \"\"\"Test to check that faces must have valid indices for the vertices\"\"\"\n    # Copied from skcg\n    with pytest.raises(ValueError):\n        MeshClass(\n            [[0, 0, 0], [1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4]], [[0, 1, 9999]]\n        )\n\n    with pytest.raises(ValueError):\n        MeshClass([[0, 0, 0], [1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4]], [[0, 1, -1]])", "\n\n# %% Test is_manifold\n\n\ndef test_non_manifold_collapse_face_1():\n    \"\"\"Collapse a face. Now the mesh is open, and one edge has 3 faces.\"\"\"\n    for vertices, faces, is_closed in iter_test_meshes():\n        faces[1][1] = faces[1][0]\n\n        m = MeshClass(vertices, faces)\n\n        assert not m.is_edge_manifold\n        assert not m.is_vertex_manifold  # cannot have sound fans with 3-face edges\n        assert not m.is_closed  # cannot be closed if not edge manifold\n        assert not m.is_oriented  # cannot be oriented if not edge manifold\n\n        # Collapsing this face the small meshes makes it non-manifold even after repair\n        if len(faces) <= 4:\n            continue\n\n        m.repair_manifold()  # We can detect and remove collapsed faces!\n\n        assert m.is_manifold\n        assert not m.is_closed  # there's a hole in the mesh\n        assert m.is_oriented\n\n        m.repair_holes()\n\n        assert m.is_manifold\n        assert m.is_closed\n        assert m.is_oriented", "\n\ndef test_non_manifold_collapse_face_2():\n    \"\"\"Collapse a face, but at the edge, so its still edge-manifold.\"\"\"\n\n    vertices, faces, _ = get_quad()\n    faces[1][0] = faces[1][1]\n\n    m = MeshClass(vertices, faces)\n\n    assert m.is_edge_manifold\n    assert not m.is_vertex_manifold\n    assert not m.is_closed\n    assert m.is_oriented  # the collapsed face maket is non-orientable\n\n    m.repair_manifold()  # We can detect and remove collapsed faces!\n\n    assert m.is_manifold\n    assert not m.is_closed\n    assert m.is_oriented", "\n\ndef test_non_manifold_add_face_1():\n    \"\"\"Add one face to the mesh. Some edges will now have 3 faces.\"\"\"\n\n    for vertices, faces, _ in iter_test_meshes():\n        # Cannot do this on quad and tetrahedron\n        if len(vertices) <= 4:\n            continue\n\n        extra_face = faces[1].copy()\n        extra_face[1] = len(vertices) - 1\n        assert not any(set(face) == set(extra_face) for face in faces)\n        faces.append(extra_face)\n\n        m = MeshClass(vertices, faces)\n\n        assert not m.is_edge_manifold\n        assert not m.is_manifold  # double-check\n        assert not m.is_closed\n        assert not m.is_oriented\n\n        m.repair_manifold()\n\n        assert m.is_manifold\n        assert m.is_closed == (False if len(m.faces) > 0 else True)\n        assert m.is_oriented", "\n\ndef test_non_manifold_add_face_2():\n    \"\"\"Add a duplicate face to the mesh. Some edges will now have 3 faces.\"\"\"\n\n    for vertices, faces, is_closed in iter_test_meshes():\n        faces.append(faces[0])\n        faces.append(faces[0])  # add two, to make sure both are removed\n\n        m = MeshClass(vertices, faces)\n\n        assert not m.is_edge_manifold\n        assert not m.is_vertex_manifold\n        assert not m.is_closed\n        assert not m.is_oriented\n\n        m.repair_manifold()  # We can detect and remove duplicate faces!\n\n        assert m.is_edge_manifold\n        assert m.is_manifold\n        assert m.is_closed == is_closed\n        assert m.is_oriented", "\n\ndef test_non_manifold_add_face_3():\n    \"\"\"Add one face to the mesh, using one extra vertex. One edge will now have 3 faces.\"\"\"\n\n    for vertices, faces, _ in iter_test_meshes():\n        vertices.append([1, 2, 3])\n        faces.append([faces[0][0], faces[0][1], len(vertices) - 1])\n\n        m = MeshClass(vertices, faces)\n\n        assert not m.is_edge_manifold\n        assert not m.is_vertex_manifold\n        assert not m.is_closed\n        assert not m.is_oriented\n\n        m.repair_manifold()\n\n        assert m.is_manifold\n        assert m.is_closed == (False if len(m.faces) > 0 else True)\n        assert m.is_oriented", "\n\ndef test_non_manifold_add_face_4():\n    \"\"\"Add one face to the mesh, using two extra vertices. There now is connectivity via a vertex.\"\"\"\n\n    # Note (AK): this case is excluded from skcg.Mesh, because its\n    # implementation is very slow. I have changed my local version of\n    # skcg to turn the test on.\n\n    for vertices, faces, is_closed in iter_test_meshes():\n        # Break it\n\n        vertices.append([1, 2, 3])\n        vertices.append([2, 3, 4])\n        faces.append([faces[0][0], len(vertices) - 2, len(vertices) - 1])\n\n        m = MeshClass(vertices, faces)\n\n        assert m.is_edge_manifold\n        assert not m.is_vertex_manifold\n        assert not m.is_manifold\n        assert not m.is_closed  # not closed because the added face is not\n        assert m.is_oriented\n\n        # Repair it\n\n        m.repair_manifold()\n\n        assert m.is_manifold\n        assert not m.is_closed\n        assert m.is_oriented\n\n        # Repair harder\n\n        if is_closed:\n            m.repair_holes()\n\n            assert m.is_manifold\n            assert m.is_closed\n            assert m.is_oriented", "\n\ndef test_non_manifold_add_face_5():\n    \"\"\"Add one face to the mesh, using one extra vertex, connected via two vertices (no edges).\"\"\"\n\n    for vertices, faces, is_closed in iter_test_meshes():\n        # Cannot do this on quad and tetrahedron\n        if len(vertices) <= 4:\n            continue\n\n        # Break it\n\n        vertices.append([1, 2, 3])\n        extra_vi = 3 if len(vertices) == 6 else 10\n        extra_face = [1, extra_vi, len(vertices) - 1]\n        assert not any(len(set(face).intersection(extra_face)) > 1 for face in faces)\n        faces.append(extra_face)\n\n        m = MeshClass(vertices, faces)\n\n        assert m.is_edge_manifold\n        assert not m.is_vertex_manifold\n        assert not m.is_manifold\n        assert not m.is_closed\n        assert m.is_oriented\n\n        # Repair it\n\n        m.repair_manifold()\n\n        assert m.is_manifold\n        assert not m.is_closed\n        assert m.is_oriented\n\n        m.remove_small_components(2)\n        assert m.is_manifold\n        assert m.is_closed == is_closed\n        assert m.is_oriented", "\n\ndef test_non_manifold_weakly_connected_1():\n    \"\"\"Attach one part of the mesh to another part, using just one vertex.\"\"\"\n\n    # Note: This is a single connected component that *also* has a\n    # one-vertex connection. A case that I initially overlooked.\n\n    # Some hand-picked vertex pairs to connect\n    vertex_pairs = [\n        (12, 29),  # about opposite the sphere\n        (0, 21),  # one vertex in between\n    ]\n\n    vertices, faces, _ = get_sphere()\n\n    for index_to_start_from in range(len(faces)):\n        for vi1, vi2 in vertex_pairs:\n            vertices, faces, _ = get_sphere()\n\n            # Break it\n\n            faces = np.asarray(faces, np.int32)\n            faces[faces == vi2] = vi1\n            faces[0], faces[index_to_start_from] = tuple(\n                faces[index_to_start_from]\n            ), tuple(faces[0])\n\n            m = MeshClass(vertices, faces)\n\n            assert m.is_edge_manifold\n            assert not m.is_vertex_manifold\n            assert m.is_closed  # still closed!\n            assert m.is_oriented\n\n            # Repair it\n\n            m.repair_manifold()\n\n            assert m.is_manifold\n            assert m.is_closed\n            assert m.is_oriented", "\n\ndef test_non_manifold_weakly_connected_2():\n    \"\"\"Attach two meshes, using just one vertex.\"\"\"\n\n    # Stitch the test meshes together, some are open, some closed.\n\n    for vertices1, faces1, closed1 in iter_test_meshes():\n        for vertices2, faces2, closed2 in iter_test_meshes():\n            faces1 = np.array(faces1)\n            faces2 = np.array(faces2)\n            offset2 = faces1.max() + 1\n            faces = np.concatenate([faces1, faces2 + offset2])\n            vertices = vertices1 + vertices2\n\n            # Sanity check: adding individual meshes is manifold\n            m = MeshClass(vertices, faces)\n            assert m.is_edge_manifold\n            assert m.is_vertex_manifold\n            assert m.is_oriented\n            assert m.is_closed == (closed1 and closed2)\n\n            # Try this for a couple of different vertices\n            for iter in range(4):\n                # Break it (stitch together)\n\n                i1 = np.random.randint(faces1.max() + 1)\n                i2 = np.random.randint(faces2.max() + 1) + offset2\n                stitched_faces = faces.copy()\n                stitched_faces[faces == i2] = i1\n\n                m = MeshClass(vertices, stitched_faces)\n                assert m.is_edge_manifold\n                assert not m.is_vertex_manifold\n                assert m.is_oriented\n                assert m.is_closed == (closed1 and closed2)\n\n                # Repair it\n\n                m.repair_manifold()\n\n                assert m.is_manifold\n                assert m.is_closed == (closed1 and closed2)\n                assert m.is_oriented", "\n\ndef test_non_manifold_weakly_connected_3():\n    \"\"\"Attatch two fans in many different configurations, using one vertex.\"\"\"\n\n    # This tests a variety of fan topologies, and combinations\n    # thereof, to help ensure that the vertex-manifold detection is sound.\n\n    # Note that in this test we assume that the algorithm to detect\n    # vertex-manifoldness only looks at the faces incident to the vertex\n    # in question, and e.g. does not consider neighbours of these faces\n    # (except the ones incident to the same vertex).\n\n    for faces1 in iter_fans():\n        for faces2 in iter_fans():\n            faces1 = np.array(faces1)\n            faces2 = np.array(faces2)\n            offset2 = faces1.max() + 1\n            faces = np.concatenate([faces1, faces2 + offset2])\n\n            # Stub vertices\n            vertices = np.zeros((faces.max() + 1, 3), np.float32)\n\n            # Sanity check: adding individual meshes is manifold\n            m = MeshClass(vertices, faces)\n            assert m.is_edge_manifold\n            assert m.is_vertex_manifold\n            assert m.is_oriented\n            assert not m.is_closed\n\n            # Break it (stitch them together)\n\n            faces[faces == offset2] = 0\n\n            m = MeshClass(vertices, faces)\n            assert m.is_edge_manifold\n            assert not m.is_vertex_manifold\n            assert m.is_oriented\n            assert not m.is_closed  # none of these fans are closed\n\n            # Repair it\n\n            m.repair_manifold()\n\n            assert m.is_manifold\n            assert not m.is_closed\n            assert m.is_oriented", "\n\n# %% Test is_closed\n\n\ndef test_non_closed_remove_face():\n    \"\"\"Remove a face, opening up the mesh.\"\"\"\n\n    for vertices, faces, is_closed in iter_test_meshes():\n        # Does not work for quad and strip\n        if not is_closed:\n            continue\n\n        faces.pop(1)\n\n        m = MeshClass(vertices, faces)\n\n        assert m.is_manifold\n        assert not m.is_closed\n        assert m.is_oriented\n\n        m.repair_holes()\n\n        assert m.is_manifold\n        assert m.is_closed\n        assert m.is_oriented", "\n\ndef test_non_closed_planes_1():\n    \"\"\"A plane is an open mesh.\"\"\"\n\n    geo = gfx.geometries.plane_geometry()\n    vertices = geo.positions.data\n    faces = geo.indices.data\n\n    m = MeshClass(vertices, faces)\n\n    assert m.is_manifold\n    assert not m.is_closed\n    assert m.is_oriented", "\n\ndef test_non_closed_planes_2():\n    \"\"\"A Pygfx isohedron consists of a series of planes.\"\"\"\n\n    # Note: multiple components in these meshes.\n    # Note: this secretly is also a test for pygfx.\n\n    for isohedron in \"tetrahedron\", \"octahedron\", \"icosahedron\", \"dodecahedron\":\n        geo = getattr(gfx.geometries, f\"{isohedron}_geometry\")()\n        vertices = geo.positions.data\n        faces = geo.indices.data\n\n        m = MeshClass(vertices, faces)\n\n        assert m.is_manifold\n        assert not m.is_closed\n        assert m.is_oriented\n\n        # We can stitch the individual planes together!\n        m.repair_touching_boundaries(atol=1e-6)\n\n        assert m.is_manifold\n        assert m.is_closed\n        assert m.is_oriented", "\n\ndef test_non_closed_knot():\n    \"\"\"Pygfx can produce open and closed torus knots.\"\"\"\n\n    # Stitched\n\n    geo = gfx.geometries.torus_knot_geometry(stitch=True)\n    vertices = geo.positions.data\n    faces = geo.indices.data\n\n    m = MeshClass(vertices, faces)\n\n    assert m.is_manifold\n    assert m.is_closed\n    assert m.is_oriented\n\n    # Not stitched\n\n    geo = gfx.geometries.torus_knot_geometry(stitch=False)\n    vertices = geo.positions.data\n    faces = geo.indices.data\n\n    m = MeshClass(vertices, faces)\n\n    assert m.is_manifold\n    assert not m.is_closed\n    assert m.is_oriented\n\n    # Stitch the mesh back up\n    m.repair_touching_boundaries()\n\n    assert m.is_manifold\n    assert m.is_closed\n    assert m.is_oriented", "\n\ndef test_non_closed_cube():\n    \"\"\"Pygfx can produce a cube, but it's open.\"\"\"\n\n    for iter in range(2):\n        if iter == 0:\n            geo = gfx.geometries.box_geometry()\n        else:\n            geo = gfx.geometries.box_geometry(\n                width_segments=12, height_segments=12, depth_segments=12\n            )\n\n        vertices = geo.positions.data\n        faces = geo.indices.data\n\n        m = MeshClass(vertices, faces)\n\n        assert m.is_manifold\n        assert not m.is_closed\n        assert m.is_oriented\n\n        # This shape is easy to stitch into a closed manifold by deduping vertices.\n        m.repair_touching_boundaries()\n\n        assert m.is_manifold\n        assert m.is_closed\n        assert m.is_oriented", "\n\ndef test_non_closed_sphere():\n    \"\"\"Pygfx can produce a sphere, but it's open.\"\"\"\n\n    geo = gfx.geometries.sphere_geometry(1)\n\n    vertices = geo.positions.data\n    faces = geo.indices.data\n\n    m = MeshClass(vertices, faces)\n\n    assert m.is_manifold\n    assert not m.is_closed\n    assert m.is_oriented\n\n    # We can can stitch up the top, bottom and the seam that runs from\n    # top to bottom, by deduping vertices. However, this introduces\n    # some collapsed faces, which we'll need to remove.\n    m.repair_touching_boundaries()\n\n    assert m.is_manifold\n    assert m.is_closed\n    assert m.is_oriented", "\n\n# %% Test is_oriented\n\n\ndef test_non_oriented_change_winding_1():\n    \"\"\"Change the winding of one face.\"\"\"\n\n    for face_idx in [0, 1, 2, 11, 29, -3, -2, -1]:\n        for vertices, faces, is_closed in iter_test_meshes():\n            # For some face indices, the mesh has too little faces\n            face_idx = face_idx if face_idx >= 0 else len(faces) + face_idx\n            if face_idx >= len(faces):\n                continue\n\n            face = faces[face_idx]\n            faces[face_idx] = face[0], face[2], face[1]\n\n            m = MeshClass(vertices, faces)\n\n            assert m.is_manifold\n            assert m.is_closed == is_closed\n            assert not m.is_oriented\n\n            n_reversed = m.repair_orientation()\n\n            assert n_reversed == 1\n            assert m.is_manifold\n            assert m.is_closed == is_closed\n            assert m.is_oriented", "\n\ndef test_non_oriented_change_winding_2():\n    \"\"\"Change the winding of two adjacent faces.\"\"\"\n\n    for face_idx1 in [0, 1, 2, 11, 29, -3, -2, -1]:\n        for vertices, faces, is_closed in iter_test_meshes():\n            # If we reverse all faces, it will still be oriented\n            if len(faces) <= 2:\n                continue\n\n            # For some face indices, the mesh has too little faces\n            face_idx1 = face_idx1 if face_idx1 >= 0 else len(faces) + face_idx1\n            if face_idx1 >= len(faces):\n                continue\n\n            face1 = faces[face_idx1]\n            faces[face_idx1] = face1[0], face1[2], face1[1]\n            for face_idx2 in range(len(faces)):\n                if face_idx2 == face_idx1:\n                    continue\n                face2 = faces[face_idx2]\n                if face2[0] in face1:\n                    break\n            else:\n                assert False, \"WTF\"\n            face2 = faces[face_idx2]\n            faces[face_idx2] = face2[0], face2[2], face2[1]\n\n            m = MeshClass(vertices, faces)\n\n            assert m.is_manifold\n            assert m.is_closed == is_closed\n            assert not m.is_oriented\n\n            n_reversed = m.repair_orientation()\n\n            if len(faces) > 4:\n                assert n_reversed == 2\n            assert m.is_manifold\n            assert m.is_closed == is_closed\n            assert m.is_oriented", "\n\ndef test_non_oriented_inside_out():\n    for vertices, faces, _ in iter_closed_meshes():\n        # Turn the mesh inside-out\n        faces = np.asarray(faces)\n        tmp = faces[:, 0].copy()\n        faces[:, 0] = faces[:, 1]\n        faces[:, 1] = tmp\n\n        m = MeshClass(vertices, faces)\n\n        assert m.is_closed\n        assert m.get_volume() < 0\n        assert m.is_oriented  # still oriented ...\n\n        n_reversed = m.repair_orientation()\n        assert n_reversed == len(faces)  # ... but inside out\n\n        assert m.is_closed\n        assert m.get_volume() > 0  # now its all good!\n        assert m.is_oriented", "\n\ndef test_non_oriented_mobius():\n    \"\"\"A M\u00f6bius strip!\"\"\"\n\n    # This one is just a surface, really\n    geo = gfx.geometries.mobius_strip_geometry(stitch=False)\n    vertices = geo.positions.data\n    faces = geo.indices.data\n\n    m = MeshClass(vertices, faces)\n\n    assert m.is_manifold\n    assert not m.is_closed\n    assert m.is_oriented\n\n    # This is the real deal\n    geo = gfx.geometries.mobius_strip_geometry(stitch=True)\n    vertices = geo.positions.data\n    faces = geo.indices.data\n\n    m = MeshClass(vertices, faces)\n\n    assert m.is_manifold\n    assert not m.is_closed\n    assert not m.is_oriented\n\n    m.repair_orientation()\n\n    assert m.is_manifold\n    assert not m.is_closed\n    assert not m.is_oriented  # cannot repair this topology", "\n\ndef test_non_oriented_klein_bottle():\n    \"\"\"A Klein bottle!\"\"\"\n\n    # This one is just a surface, really\n    geo = gfx.geometries.klein_bottle_geometry(stitch=False)\n    vertices = geo.positions.data\n    faces = geo.indices.data\n\n    m = MeshClass(vertices, faces)\n\n    assert m.is_manifold\n    assert not m.is_closed\n    assert m.is_oriented\n\n    # This is the real deal\n    geo = gfx.geometries.klein_bottle_geometry(stitch=True)\n    vertices = geo.positions.data\n    faces = geo.indices.data\n\n    m = MeshClass(vertices, faces)\n\n    assert m.is_manifold\n    assert m.is_closed\n    assert not m.is_oriented\n\n    m.repair_orientation()\n\n    assert m.is_manifold\n    assert m.is_closed\n    assert not m.is_oriented  # cannot repair this topology", "\n\n# %% Test specific repairs\n\n\ndef test_repair_touching_boundaries1():\n    # We don't want repairs to break anything. Achieving that requies\n    # a bit of work for this particular method.\n\n    # In this test we create two exact same spheres (on the same\n    # positions). Except one has a hole, so that the mesh is open and\n    # the de-dupe alg does not exit early. The spheres should not be connected.\n\n    m = MeshClass(None, None)\n\n    vertices, faces, _ = get_sphere()\n    m.add_mesh(vertices, faces)\n    faces.pop(-1)\n    m.add_mesh(vertices, faces)\n\n    m.repair_touching_boundaries()\n\n    assert m.is_manifold\n    assert m.is_oriented\n    assert not m.is_closed\n    assert m.component_count == 2\n\n    m.repair_holes()\n\n    assert m.is_manifold\n    assert m.is_oriented\n    assert m.is_closed\n    assert m.component_count == 2", "\n\ndef test_repair_touching_boundaries2():\n    # In this test we place 3 planes that share one edge. It's a bit similar\n    # for stitching up a box geometry, except the stitching would create an\n    # edge with 3 incident faces, which would result in a non-manifold mesh.\n    # The algorithm should therefore deny this change.\n\n    m = MeshClass(None, None)\n\n    # Add 3 planes - should not be stitched\n    vertices, faces = [], []\n    for i in range(3):\n        vertices += [(0, 0, 0), (0, 0, 1), (i, 1, 1)]\n        faces.append([i * 3 + 0, i * 3 + 1, i * 3 + 2])\n    m = MeshClass(vertices, faces)\n\n    # Add 2 planes - should be stitched\n    vertices, faces = [], []\n    for i in range(2):\n        vertices += [(10, 10, 10), (10, 10, 11), (10 + i, 11, 11)]\n        faces.append([i * 3 + 0, i * 3 + 1, i * 3 + 2])\n    m.add_mesh(vertices, faces)\n\n    assert m.is_manifold\n    assert not m.is_closed\n    assert m.component_count == 5\n    assert len(m.positions) == 3 * 3 + 2 * 3\n\n    m.repair_touching_boundaries()\n\n    assert m.is_manifold\n    assert not m.is_closed\n    assert m.component_count == 4\n    assert len(m.positions) == 3 * 3 + 2 * 3 - 2", "\n\nif __name__ == \"__main__\":\n    run_tests(globals())\n"]}
{"filename": "tests/testutils.py", "chunked_list": ["from gfxmorph import maybe_pygfx\nimport pygfx as gfx\n\n\ndef run_tests(scope):\n    \"\"\"Run all test functions in the given scope.\"\"\"\n    for func in list(scope.values()):\n        if callable(func) and func.__name__.startswith(\"test_\"):\n            print(f\"Running {func.__name__} ...\")\n            func()\n    print(\"Done\")", "\n\ndef get_tetrahedron():\n    \"\"\"A closed tetrahedron as simple list objects, so we can easily add stuff to create corrupt meshes.\"\"\"\n    vertices = [\n        [-1, 0, -1 / 2**0.5],\n        [+1, 0, -1 / 2**0.5],\n        [0, -1, 1 / 2**0.5],\n        [0, +1, 1 / 2**0.5],\n    ]\n    faces = [\n        [2, 0, 1],\n        [0, 2, 3],\n        [1, 0, 3],\n        [2, 1, 3],\n    ]\n    return vertices, faces, True", "\n\ndef get_sphere():\n    geo = maybe_pygfx.smooth_sphere_geometry()\n    return geo.positions.data.tolist(), geo.indices.data.tolist(), True\n\n\ndef get_knot():\n    geo = gfx.geometries.torus_knot_geometry(\n        tubular_segments=16, radial_segments=5, stitch=True\n    )\n    return geo.positions.data.tolist(), geo.indices.data.tolist(), True", "\n\ndef get_quad():\n    vertices = [\n        [-1, -1, 0],\n        [+1, -1, 0],\n        [+1, +1, 0],\n        [-1, +1, 0],\n    ]\n    faces = [\n        [0, 2, 1],\n        [0, 3, 2],\n    ]\n    return vertices, faces, False", "\n\ndef get_fan():\n    vertices = [\n        [0, 0, 0],\n        [-1, -1, 0],\n        [+1, -1, 0],\n        [+1, +1, 0],\n        [-1, +1, 0],\n    ]\n    faces = [\n        [0, 2, 1],\n        [0, 3, 2],\n        [0, 4, 3],\n        [0, 1, 4],\n    ]\n    return vertices, faces, False", "\n\ndef get_strip():\n    # A strip of 3 triangles\n    vertices, faces, _ = get_fan()\n    faces.pop(-1)\n    return vertices, faces, False\n\n\ndef iter_fans():\n    \"\"\"Produce a series of fans to test stuff on.\"\"\"\n\n    # An open fan with 10 faces\n    open_fan = [\n        [0, 2, 1],\n        [0, 3, 2],\n        [0, 4, 3],\n        [0, 5, 4],\n        [0, 6, 5],\n        [0, 7, 6],\n        [0, 8, 7],\n        [0, 9, 8],\n        [0, 10, 9],\n        [0, 11, 10],\n    ]\n\n    # Open fans\n    for i in range(1, 11):\n        yield [x for x in open_fan[:i]]\n\n    # Closed fans\n    for i in range(2, 11):\n        fan = [x for x in open_fan[:i]]\n        fan.append([0, 1, fan[-1][1]])\n        yield fan", "\ndef iter_fans():\n    \"\"\"Produce a series of fans to test stuff on.\"\"\"\n\n    # An open fan with 10 faces\n    open_fan = [\n        [0, 2, 1],\n        [0, 3, 2],\n        [0, 4, 3],\n        [0, 5, 4],\n        [0, 6, 5],\n        [0, 7, 6],\n        [0, 8, 7],\n        [0, 9, 8],\n        [0, 10, 9],\n        [0, 11, 10],\n    ]\n\n    # Open fans\n    for i in range(1, 11):\n        yield [x for x in open_fan[:i]]\n\n    # Closed fans\n    for i in range(2, 11):\n        fan = [x for x in open_fan[:i]]\n        fan.append([0, 1, fan[-1][1]])\n        yield fan", "\n\ndef iter_test_meshes():\n    yield get_tetrahedron()  # 4 vertices, 4 faces\n    yield get_sphere()  # 32 vertices, 60 faces\n    yield get_knot()  # 80 vertices, 160 faces\n    yield get_quad()  # 4 vertices, 2 faces\n    yield get_fan()  # 5 vertices, 4 faces\n    yield get_strip()  # 5 vertices, 3 faces\n", "\n\ndef iter_closed_meshes():\n    yield get_tetrahedron()  # 4 vertices, 4 faces\n    yield get_sphere()  # 32 vertices, 60 faces\n    yield get_knot()  # 80 vertices, 160 faces\n"]}
{"filename": "tests/test_basedynamicmesh.py", "chunked_list": ["import numpy as np\nfrom testutils import run_tests, get_sphere\nfrom gfxmorph import (\n    BaseDynamicMesh as OriDynamicMesh,\n    MeshLogger,\n    MeshChangeTracker,\n)\nimport pytest\n\n\nclass IntendedRuntimeError(RuntimeError):\n    pass", "\n\nclass IntendedRuntimeError(RuntimeError):\n    pass\n\n\nclass CustomChangeTracker(MeshChangeTracker):\n    \"\"\"During these tests, we also track changes, to make sure that\n    the change tracking mechanism works as it should.\n    \"\"\"\n\n    # If MeshChangeTracker implementation raises an error it is reported\n    # but should not affect the mesh. This flag allows this class to produce errors\n    BROKEN_TRACKER = False\n\n    def init(self, mesh):\n        self.new_vertices_buffer(mesh)\n        self.new_faces_buffer(mesh)\n\n        nverts, nfaces = len(mesh.positions), len(mesh.faces)\n        self.positions = self.positions_buf2[:nverts]\n        self.normals = self.normals_buf2[:nverts]\n        self.faces = self.faces_buf2[:nfaces]\n\n    def new_faces_buffer(self, mesh):\n        self.faces_buf1 = mesh.faces.base\n        self.faces_buf2 = self.faces_buf1.copy()\n\n    def new_vertices_buffer(self, mesh):\n        self.positions_buf1 = mesh.positions.base\n        self.positions_buf2 = self.positions_buf1.copy()\n        self.normals_buf1 = mesh.normals.base\n        self.normals_buf2 = self.normals_buf1.copy()\n\n    def add_faces(self, faces):\n        new_n = len(self.faces) + len(faces)\n        self.faces = self.faces_buf2[:new_n]\n        self.faces[-len(faces) :] = faces\n        if self.BROKEN_TRACKER:\n            raise IntendedRuntimeError()\n\n    def pop_faces(self, n, old):\n        assert isinstance(n, int)\n        new_n = len(self.faces) - n\n        self.faces = self.faces_buf2[:new_n]\n        if self.BROKEN_TRACKER:\n            raise IntendedRuntimeError()\n\n    def swap_faces(self, indices1, indices2):\n        self.faces[indices1], self.faces[indices2] = (\n            self.faces[indices2],\n            self.faces[indices1],\n        )\n\n    def update_faces(self, indices, faces, old):\n        assert isinstance(indices, np.ndarray)\n        self.faces[indices] = faces\n        if self.BROKEN_TRACKER:\n            raise IntendedRuntimeError()\n\n    def add_vertices(self, positions):\n        old_n = len(self.positions)\n        new_n = old_n + len(positions)\n        self.positions = self.positions_buf2[:new_n]\n        self.normals = self.normals_buf2[:new_n]\n        self.positions[old_n:] = positions\n        self.normals[old_n:] = self.normals_buf1[old_n:new_n]\n        if self.BROKEN_TRACKER:\n            raise IntendedRuntimeError()\n\n    def pop_vertices(self, n, old):\n        assert isinstance(n, int)\n        new_len = len(self.positions) - n\n        self.positions = self.positions_buf2[:new_len]\n        self.normals = self.normals_buf2[:new_len]\n        if self.BROKEN_TRACKER:\n            raise IntendedRuntimeError()\n\n    def swap_vertices(self, indices1, indices2):\n        self.positions[indices1], self.positions[indices2] = (\n            self.positions[indices2],\n            self.positions[indices1],\n        )\n        self.normals[indices1], self.normals[indices2] = (\n            self.normals[indices2],\n            self.normals[indices1],\n        )\n\n    def update_vertices(self, indices, positions, old):\n        assert isinstance(indices, np.ndarray)\n        self.positions[indices] = positions\n        if self.BROKEN_TRACKER:\n            raise IntendedRuntimeError()\n\n    def update_normals(self, indices):\n        assert isinstance(indices, np.ndarray)\n        self.normals[indices] = self.normals_buf1[indices]\n        if self.BROKEN_TRACKER:\n            raise IntendedRuntimeError()", "\n\nclass ReplicatingMesh(OriDynamicMesh, MeshChangeTracker):\n    \"\"\"Since the API's of the change tracker matches that of the core\n    changes-api of the BaseDynamicMesh, this is all you need to\n    replicate a mesh. That in itself is a silly arguement (because when\n    would you want to replicate a mesh?) but it does look elegant.\n    \"\"\"\n\n    pass", "\n\nclass DynamicMesh(OriDynamicMesh):\n    \"\"\"A custom mesh subclass that has debug mode on, so that the\n    internal state is validated at each change. Plus we track changes\n    and check them at each step too.\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        # Add a simple replicating tracker, to test that the overlapping API does proper replications\n        self.tracker1 = ReplicatingMesh()\n        self.track_changes(self.tracker1)\n\n        # A custom change tracker that replicates the data via the buffers.\n        self.tracker2 = CustomChangeTracker()\n        self.track_changes(self.tracker2)\n\n        # Installing the abstract class does nothing, but this way we\n        # check that the API of the base class is complete and compatible.\n        self.tracker3 = MeshChangeTracker()\n        self.track_changes(self.tracker3)\n\n    def _after_change(self):\n        self.check_internal_state()\n        if self.tracker1:\n            assert np.all(self.faces == self.tracker1.faces)\n            assert np.all(self.positions == self.tracker1.positions)\n            assert np.all(self.normals == self.tracker1.normals)\n        if not self.tracker2.BROKEN_TRACKER:\n            assert np.all(self.faces == self.tracker2.faces)\n            assert np.all(self.positions == self.tracker2.positions)\n            assert np.all(self.normals == self.tracker2.normals)", "\n\ndef check_mesh(m, nverts, nfaces):\n    assert isinstance(m.positions, np.ndarray)\n    assert m.positions.flags.c_contiguous\n    assert m.positions.dtype == np.float32 and m.positions.shape == (nverts, 3)\n\n    assert isinstance(m.faces, np.ndarray)\n    assert m.faces.flags.c_contiguous\n    assert m.faces.dtype == np.int32 and m.faces.shape == (nfaces, 3)", "\n\ndef test_dynamicmesh_init():\n    vertices, faces, _ = get_sphere()\n\n    # Create a new (empty) mesh\n    m = DynamicMesh()\n\n    check_mesh(m, 0, 0)\n\n    # Add data\n    m.add_vertices(vertices)\n    m.add_faces(faces)\n\n    check_mesh(m, len(vertices), len(faces))\n\n    # Add another mesh\n    m.add_vertices(vertices)\n    m.add_faces(faces)\n\n    check_mesh(m, len(vertices) * 2, len(faces) * 2)", "\n\ndef test_dynamicmesh_broken_tracker():\n    vertices, faces, _ = get_sphere()\n\n    # Create a new (empty) mesh\n    m = DynamicMesh()\n\n    # Make the tracker raise errors\n    m.tracker2.BROKEN_TRACKER = True\n\n    # And why not add a logger too!\n    logger = MeshLogger(print)\n    m.track_changes(logger)\n\n    check_mesh(m, 0, 0)\n\n    # Add data\n    m.add_vertices(vertices)\n    m.add_faces(faces)\n\n    check_mesh(m, len(vertices), len(faces))\n\n    # Add another mesh\n    m.add_vertices(vertices)\n    m.add_faces(faces)\n\n    # Update some verts and faces\n    m.update_vertices([0, 1], m.positions[[0, 1]] * 1.1)\n    m.update_faces([10, 11], m.faces[[0, 1]])\n\n    check_mesh(m, len(vertices) * 2, len(faces) * 2)\n\n    # Remove the second mesh again\n    m.delete_faces(np.arange(len(faces), 2 * len(faces)))\n    m.delete_vertices(np.arange(len(vertices), 2 * len(vertices)))\n\n    check_mesh(m, len(vertices), len(faces))", "\n\ndef test_dynamicmesh_tracker_mechanics():\n    # Create a new (empty) mesh\n    m = DynamicMesh()\n\n    # Trackers must inherit from MeshChangeTracker\n    with pytest.raises(TypeError):\n        m.track_changes(list())\n\n    class Tracker(MeshChangeTracker):\n        def __init__(self):\n            self.count = 0\n            self.nvertices = 0\n\n        def init(self, mesh):\n            self.nvertices = len(mesh.positions)\n\n        def add_vertices(self, indices):\n            self.count += 1\n            self.nvertices += len(indices)\n\n        def pop_vertices(self, n):\n            self.nvertices -= n\n\n    t1 = Tracker()\n    t2 = Tracker()\n\n    # Add t1\n    m.track_changes(t1)\n\n    m.add_vertices([(1, 1, 1)])\n    m.add_vertices([(1, 1, 1)])\n    assert t1.count == 2\n    assert t2.count == 0\n    assert t1.nvertices == 2\n    assert t2.nvertices == 0\n\n    # Also add t2\n    m.track_changes(t2)\n\n    m.add_vertices([(2, 2, 2), (2, 2, 2)])\n    assert t1.count == 3\n    assert t2.count == 1\n    assert t1.nvertices == 4\n    assert t2.nvertices == 4\n\n    # Remove t1, so only tracking with t2\n    m.track_changes(t1, remove=True)\n\n    m.add_vertices([(3, 3, 3), (3, 3, 3)])\n    assert t1.count == 3\n    assert t2.count == 2\n    assert t1.nvertices == 4\n    assert t2.nvertices == 6\n\n    # Adding t1, twice (should not track twice as hard)\n    m.track_changes(t1)\n    m.track_changes(t1)\n\n    m.add_vertices([(4, 4, 4), (4, 4, 4)])\n    assert t1.count == 4\n    assert t2.count == 3\n    assert t1.nvertices == 8\n    assert t2.nvertices == 8\n\n    # Remove both trackers\n    m.track_changes(t1, remove=True)\n    m.track_changes(t2, remove=True)\n\n    m.add_vertices([(5, 5, 5), (5, 5, 5)])\n    assert t1.count == 4\n    assert t2.count == 3\n    assert t1.nvertices == 8\n    assert t2.nvertices == 8", "\n\ndef test_dynamicmesh_reset():\n    vertices, faces, _ = get_sphere()\n\n    # Create a new (empty) mesh\n    m = DynamicMesh()\n\n    # Init using reset\n    m.reset(vertices, faces)\n    check_mesh(m, len(vertices), len(faces))\n\n    # Modify\n    m.delete_faces([1, 2, 3])\n    m.add_vertices([(0, 0, 0), (1, 1, 1)])\n\n    # Make a snapshot\n    vertices2 = m.positions.copy()\n    faces2 = m.faces.copy()\n\n    # Clear\n    m.clear()\n    check_mesh(m, 0, 0)\n\n    # Restore snapshot\n    m.reset(vertices2, faces2)\n    check_mesh(m, len(vertices2), len(faces2))", "\n\ndef test_dynamicmesh_readonly():\n    vertices, faces, _ = get_sphere()\n\n    m = DynamicMesh()\n    m.add_vertices(vertices)\n    m.add_faces(faces)\n\n    with pytest.raises(ValueError):\n        m.faces[0] = (0, 0, 0)\n    with pytest.raises(ValueError):\n        m.positions[0] = (0, 0, 0)\n    with pytest.raises(ValueError):\n        m.normals[0] = (0, 0, 0)", "\n\ndef test_dynamicmesh_verts_before_faces():\n    vertices, faces, _ = get_sphere()\n\n    # Cannot load faces before vertices\n    m = DynamicMesh()\n    with pytest.raises(ValueError):\n        m.add_faces(faces)\n\n    # Vertices first!\n    m.add_vertices(vertices)\n    m.add_faces(faces)\n\n    # Cannot remove vertices before faces\n    with pytest.raises(ValueError):\n        m.delete_vertices(list(range(len(vertices))))\n\n    # Faces first!\n    m.delete_faces(list(range(len(faces))))\n    m.delete_vertices(list(range(len(vertices))))", "\n\ndef test_dynamicmesh_add_and_delete_faces():\n    # Deleting faces can change the order of other faces due to the\n    # defragmentation process.\n\n    vertices = [[i, i, i] for i in range(9)]\n    faces = [[0, 1, 2], [3, 4, 5], [6, 7, 8]]\n\n    m = DynamicMesh()\n    m.add_vertices(vertices)\n    m.add_faces(faces)\n    check_mesh(m, 9, 3)\n\n    assert [tuple(x) for x in m.faces] == [(0, 1, 2), (3, 4, 5), (6, 7, 8)]\n\n    # Fail add\n    with pytest.raises(ValueError):\n        m.add_faces([1, 2, 3, 4])  # Must be (castable to) Nx3\n    with pytest.raises(ValueError):\n        m.add_faces([(0, -1, 2)])  # Out of bounds\n    with pytest.raises(ValueError):\n        m.add_faces([(0, 999, 2)])  # Out of bounds\n    with pytest.raises(ValueError):\n        m.add_faces(np.zeros((0, 3), np.int32))  # Cannot add zero faces\n\n    # Fail delete\n    with pytest.raises(TypeError):\n        m.delete_faces({1, 2, 3})  # Need list or ndarray\n    with pytest.raises(ValueError):\n        m.delete_faces([0, -1])  # Out of bounds\n    with pytest.raises(ValueError):\n        m.delete_faces([0, 999])  # Out of bounds\n    with pytest.raises(ValueError):\n        m.delete_faces([])  # Cannot be empty\n    with pytest.raises(ValueError):\n        m.delete_faces(np.array([], np.int32))  # Cannot be empty\n\n    # Fail pop\n    with pytest.raises(ValueError):\n        m.pop_faces(-1)  # Must be positive\n    with pytest.raises(ValueError):\n        m.pop_faces(0)  # and nonzero\n    with pytest.raises(ValueError):\n        m.pop_faces(999)  # and within bounds\n\n    # Fail swap\n    with pytest.raises(ValueError):\n        m.swap_faces([0, 1], [2])  # Unequal lengths\n    with pytest.raises(ValueError):\n        m.swap_faces([0], [1, 2])  # Unequal lengths\n\n    # Should still be the same (or atomicity would be broken)\n    assert [tuple(x) for x in m.faces] == [(0, 1, 2), (3, 4, 5), (6, 7, 8)]\n\n    # 0\n\n    m.delete_faces([0])\n\n    assert [tuple(x) for x in m.faces] == [(6, 7, 8), (3, 4, 5)]\n\n    m.add_faces([(0, 1, 2)])\n\n    assert [tuple(x) for x in m.faces] == [(6, 7, 8), (3, 4, 5), (0, 1, 2)]\n\n    # 1\n\n    m.delete_faces([1, 1, 1, 1])  # duplicates should not matter\n\n    assert [tuple(x) for x in m.faces] == [(6, 7, 8), (0, 1, 2)]\n\n    m.add_faces([(3, 4, 5)])\n\n    assert [tuple(x) for x in m.faces] == [(6, 7, 8), (0, 1, 2), (3, 4, 5)]\n\n    # 2\n\n    m.delete_faces(2)  # int is allowed\n\n    assert [tuple(x) for x in m.faces] == [(6, 7, 8), (0, 1, 2)]\n\n    m.add_faces([(3, 4, 5)])\n\n    assert [tuple(x) for x in m.faces] == [(6, 7, 8), (0, 1, 2), (3, 4, 5)]\n\n    # all\n\n    m.delete_faces([2, 0, 1])\n\n    assert [tuple(x) for x in m.faces] == []", "\n\ndef test_dynamicmesh_update_faces():\n    vertices = [[i, i, i] for i in range(12)]\n    faces = [[0, 0, 0], [1, 1, 1], [2, 2, 2], [3, 3, 3]]\n\n    m = DynamicMesh()\n    m.add_vertices(vertices)\n    m.add_faces(faces)\n    check_mesh(m, 12, 4)\n\n    m.update_faces([1, 3], [(7, 7, 7), (8, 8, 8)])\n\n    assert [tuple(x) for x in m.faces] == [(0, 0, 0), (7, 7, 7), (2, 2, 2), (8, 8, 8)]\n\n    # Fail matching indices and faces\n    with pytest.raises(ValueError):\n        m.update_faces([1, 3, 4], [(0, 0, 0), (0, -1, 2)])  # Unequal lengths\n    with pytest.raises(ValueError):\n        m.update_faces([1], [(0, 0, 0), (0, -1, 2)])  # Unequal lengths\n\n    # Fail indices\n    with pytest.raises(ValueError):\n        m.update_faces([-1, 0], [(7, 7, 7), (8, 8, 8)])  # Out of bounds\n    with pytest.raises(ValueError):\n        m.update_faces([0, 99], [(7, 7, 7), (8, 8, 8)])  # Out of bounds\n\n    # Fail faces\n    with pytest.raises(ValueError):\n        m.update_faces([1, 3], [(0, 0, 0), (0, -1, 2)])  # Out of bounds\n    with pytest.raises(ValueError):\n        m.update_faces([1, 3], [(0, 0, 0), (0, 999, 2)])  # Out of bounds", "\n\ndef test_dynamicmesh_update_vertices():\n    vertices = [[i, i, i] for i in range(10)]\n\n    m = DynamicMesh()\n    m.add_vertices(vertices)\n    check_mesh(m, 10, 0)\n\n    assert [x[0] for x in m.positions] == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n    m.update_vertices([1, 3], [(7, 7, 7), (8, 8, 8)])\n\n    assert [x[0] for x in m.positions] == [0, 7, 2, 8, 4, 5, 6, 7, 8, 9]\n\n    # Fail matching indices and faces\n    with pytest.raises(ValueError):\n        m.update_vertices([1, 3, 4], [(0, 0, 0), (0, -1, 2)])  # Unequal lengths\n    with pytest.raises(ValueError):\n        m.update_vertices([1], [(0, 0, 0), (0, -1, 2)])  # Unequal lengths\n\n    # Fail indices\n    with pytest.raises(ValueError):\n        m.update_vertices([-1, 0], [(7, 7, 7), (8, 8, 8)])  # Out of bounds\n    with pytest.raises(ValueError):\n        m.update_vertices([0, 99], [(7, 7, 7), (8, 8, 8)])  # Out of bounds", "\n\ndef test_dynamicmesh_add_and_delete_verts():\n    vertices = [[i, i, i] for i in range(10)]\n    faces = [[0, 1, 2], [3, 4, 5], [6, 7, 8]]\n\n    m = DynamicMesh()\n    m.add_vertices(vertices)\n    m.add_faces(faces)\n    check_mesh(m, 10, 3)\n\n    assert [x[0] for x in m.positions] == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n    # Fail add\n    with pytest.raises(ValueError):\n        m.add_vertices([1, 2, 3, 4])  # Must be (castable to) Nx3\n    with pytest.raises(ValueError):\n        m.add_vertices(np.zeros((0, 3), np.float32))  # Cannot add zero verts\n\n    # Fail delete\n    with pytest.raises(TypeError):\n        m.delete_vertices({1, 2, 3})  # Need list or ndarray\n    with pytest.raises(ValueError):\n        m.delete_vertices([0, -1])  # Out of bounds\n    with pytest.raises(ValueError):\n        m.delete_vertices([0, 999])  # Out of bounds\n    with pytest.raises(ValueError):\n        m.delete_vertices([])  # Cannot be empty\n    with pytest.raises(ValueError):\n        m.delete_vertices(np.array([], np.float32))  # Cannot be empty\n\n    # Fail pop\n    with pytest.raises(ValueError):\n        m.pop_vertices(-1)  # Must be positive\n    with pytest.raises(ValueError):\n        m.pop_vertices(0)  # and nonzero\n    with pytest.raises(ValueError):\n        m.pop_vertices(999)  # and within bounds\n\n    # Fail swap\n    with pytest.raises(ValueError):\n        m.swap_vertices([1, 2, 3], [4, 5])  # Unequal lengths\n    with pytest.raises(ValueError):\n        m.swap_vertices([1, 2], [4, 5, 6])  # Unequal lengths\n\n    # Should still be the same (or atomicity would be broken)\n    assert [x[0] for x in m.positions] == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n    # Delete unused\n    m.delete_vertices([9])\n    assert [x[0] for x in m.positions] == [0, 1, 2, 3, 4, 5, 6, 7, 8]\n\n    # Cannot delete vertex that is in use\n    with pytest.raises(ValueError):\n        m.delete_vertices([0])\n    with pytest.raises(ValueError):\n        m.delete_vertices([8])\n    with pytest.raises(ValueError):\n        m.pop_vertices(3)\n\n    m.delete_faces([0, 1, 2])\n\n    m.delete_vertices(8)\n    assert [x[0] for x in m.positions] == [0, 1, 2, 3, 4, 5, 6, 7]\n\n    m.delete_vertices([2, 3])\n    assert [x[0] for x in m.positions] == [0, 1, 6, 7, 4, 5]\n\n    m.delete_vertices([0, 1, 2, 3, 4])\n    assert [x[0] for x in m.positions] == [5]", "\n\ndef test_dynamicmesh_alloc_and_dealloc_vertices():\n    m = DynamicMesh()\n\n    # Put in a few vertices\n    for i in range(8):\n        m.add_vertices([(i, i, i)])\n\n    assert len(m.positions) == 8\n    assert len(m._positions_buf) == 8\n\n    # It uses factors of 2\n    m.add_vertices([(0, 0, 0)])\n    assert len(m.positions) == 9\n    assert len(m._positions_buf) == 16\n\n    # Another round\n    for i in range(8):\n        m.add_vertices([(0, 0, 0)])\n    assert len(m.positions) == 17\n    assert len(m._positions_buf) == 32\n\n    # Fill it all the way up ...\n    for i in range(15):\n        m.add_vertices([(0, 0, 0)])\n    assert len(m.positions) == 32\n    assert len(m._positions_buf) == 32\n\n    # Now it re-allocates\n    m.add_vertices([(0, 0, 0)])\n    assert len(m.positions) == 33\n    assert len(m._positions_buf) == 64\n\n    # When deleting one vertex, shrinking the buffer back to 32 makes\n    # sense from a memory pov, but if we add/remove vertices around\n    # such a point, it's a waste of time, so we apply a hysteresis\n    # threshold.\n    m.delete_vertices(32)\n    assert len(m.positions) == 32\n    assert len(m._positions_buf) == 64\n\n    # All the way down to 1/4 th of the total size\n    m.delete_vertices(list(range(17, 32)))\n    assert len(m.positions) == 17\n    assert len(m._positions_buf) == 64\n\n    # Bumping one more will re-allocate, still leaving 2x the size\n    m.delete_vertices([16])\n    assert len(m.positions) == 16\n    assert len(m._positions_buf) == 32\n\n    # Again...\n    m.delete_vertices(list(range(9, 16)))\n    assert len(m.positions) == 9\n    assert len(m._positions_buf) == 32\n\n    # Bump\n    m.delete_vertices([8])\n    assert len(m.positions) == 8\n    assert len(m._positions_buf) == 16\n\n    # Check if the original values survived\n    for i in range(8):\n        assert m.positions[i].tolist() == [i, i, i]", "\n\ndef test_dynamicmesh_alloc_and_dealloc_faces():\n    m = DynamicMesh()\n\n    # Add some vertices to reference in the faces\n    m.add_vertices([(0, 0, 0) for i in range(100)])\n\n    # Put in a few faces\n    for i in range(8):\n        m.add_faces([(i, i, i)])\n\n    assert len(m.faces) == 8\n    assert len(m._faces_buf) == 8\n\n    # It uses factors of 2\n    m.add_faces([(0, 0, 0)])\n    assert len(m.faces) == 9\n    assert len(m._faces_buf) == 16\n\n    # Another round\n    for i in range(8):\n        m.add_faces([(0, 0, 0)])\n    assert len(m.faces) == 17\n    assert len(m._faces_buf) == 32\n\n    # Fill it all the way up ...\n    for i in range(15):\n        m.add_faces([(0, 0, 0)])\n    assert len(m.faces) == 32\n    assert len(m._faces_buf) == 32\n\n    # Now it re-allocates\n    m.add_faces([(0, 0, 0)])\n    assert len(m.faces) == 33\n    assert len(m._faces_buf) == 64\n\n    # When deleting one face, shrinking the buffer back to 32 makes\n    # sense from a memory pov, but if we add/remove faces around\n    # such a point, it's a waste of time, so we apply a hysteresis\n    # threshold.\n    m.delete_faces([32])\n    assert len(m.faces) == 32\n    assert len(m._faces_buf) == 64\n\n    # All the way down to 1/4 th of the total size\n    m.delete_faces(list(range(17, 32)))\n    assert len(m.faces) == 17\n    assert len(m._faces_buf) == 64\n\n    # Bumping one more will re-allocate, still leaving 2x the size\n    m.delete_faces([16])\n    assert len(m.faces) == 16\n    assert len(m._faces_buf) == 32\n\n    # Again...\n    m.delete_faces(list(range(9, 16)))\n    assert len(m.faces) == 9\n    assert len(m._faces_buf) == 32\n\n    # Bump\n    m.delete_faces([8])\n    assert len(m.faces) == 8\n    assert len(m._faces_buf) == 16\n\n    # Check if the original values survived\n    for i in range(8):\n        assert m.faces[i].tolist() == [i, i, i]", "\n\nif __name__ == \"__main__\":\n    test_dynamicmesh_alloc_and_dealloc_faces()\n    run_tests(globals())\n"]}
{"filename": "tests/test_undo.py", "chunked_list": ["import random\n\nimport numpy as np\nimport pygfx as gfx\nfrom gfxmorph import DynamicMesh, MeshUndoTracker\n\nfrom testutils import run_tests\nimport pytest\n\n\ndef test_undo_single_changes():\n    m = DynamicMesh(None, None)\n    undo = MeshUndoTracker()\n    m.track_changes(undo)\n\n    # Three actions\n    with undo:\n        m.add_vertices([[0, 0, 0]])\n    with undo:\n        m.add_vertices([[0, 0, 0]])\n    with undo:\n        m.add_vertices([[0, 0, 0]])\n\n    # Undo\n    assert len(m.positions) == 3\n    undo.undo(m)\n    assert len(m.positions) == 2\n    undo.undo(m)\n    assert len(m.positions) == 1\n    undo.undo(m)\n    assert len(m.positions) == 0\n\n    # Further undo does nothing\n    undo.undo(m)\n    assert len(m.positions) == 0\n\n    # Redo\n    undo.redo(m)\n    assert len(m.positions) == 1\n    undo.redo(m)\n    undo.redo(m)\n    assert len(m.positions) == 3\n\n    # Further redo does nothing\n    undo.redo(m)\n    assert len(m.positions) == 3\n\n    # Clean up\n    undo.undo(m)\n    undo.undo(m)\n    undo.undo(m)\n    assert len(m.positions) == 0", "\n\ndef test_undo_single_changes():\n    m = DynamicMesh(None, None)\n    undo = MeshUndoTracker()\n    m.track_changes(undo)\n\n    # Three actions\n    with undo:\n        m.add_vertices([[0, 0, 0]])\n    with undo:\n        m.add_vertices([[0, 0, 0]])\n    with undo:\n        m.add_vertices([[0, 0, 0]])\n\n    # Undo\n    assert len(m.positions) == 3\n    undo.undo(m)\n    assert len(m.positions) == 2\n    undo.undo(m)\n    assert len(m.positions) == 1\n    undo.undo(m)\n    assert len(m.positions) == 0\n\n    # Further undo does nothing\n    undo.undo(m)\n    assert len(m.positions) == 0\n\n    # Redo\n    undo.redo(m)\n    assert len(m.positions) == 1\n    undo.redo(m)\n    undo.redo(m)\n    assert len(m.positions) == 3\n\n    # Further redo does nothing\n    undo.redo(m)\n    assert len(m.positions) == 3\n\n    # Clean up\n    undo.undo(m)\n    undo.undo(m)\n    undo.undo(m)\n    assert len(m.positions) == 0", "\n\ndef test_undo_with_context():\n    m = DynamicMesh(None, None)\n    undo = MeshUndoTracker()\n    m.track_changes(undo)\n\n    # Three actions resulting in one undo\n    with undo:\n        m.add_vertices([[0, 0, 0]])\n        m.add_vertices([[0, 0, 0]])\n        m.add_vertices([[0, 0, 0]])\n\n    # Undo / redo\n    assert len(m.positions) == 3\n    undo.undo(m)\n    assert len(m.positions) == 0\n    undo.undo(m)\n    assert len(m.positions) == 0\n    undo.redo(m)\n    assert len(m.positions) == 3\n    undo.redo(m)\n    assert len(m.positions) == 3\n    undo.undo(m)\n    assert len(m.positions) == 0\n\n    # Can be stacked ...\n    with undo:\n        m.add_vertices([[0, 0, 0]])\n        with undo:\n            m.add_vertices([[0, 0, 0]])\n            m.add_vertices([[0, 0, 0]])\n            undo.commit()  # <--  See a commit here\n\n    # ... but ignores anything but the top level, including (accidental) commits\n    assert len(m.positions) == 3\n    undo.undo(m)\n    assert len(m.positions) == 0\n    undo.redo(m)\n    assert len(m.positions) == 3\n\n    # Cannot undo under a context\n    with pytest.raises(RuntimeError):\n        with undo:\n            undo.undo(m)\n\n    undo.undo(m)\n\n    # Neither can redo\n    with pytest.raises(RuntimeError):\n        with undo:\n            undo.redo(m)", "\n\ndef test_undo_cancel():\n    m = DynamicMesh(None, None)\n    undo = MeshUndoTracker()\n    m.track_changes(undo)\n\n    # Commit 2 actions\n    m.add_vertices([[0, 0, 0]])\n    m.add_vertices([[0, 0, 0]])\n    v = undo.commit()\n    assert v == 1\n    assert undo.get_version() == 1\n    assert not undo.has_pending_changes()\n\n    # Make an action, no commit\n    m.add_vertices([[0, 0, 0]])\n\n    assert undo.get_version() == 1\n    assert undo.has_pending_changes()\n\n    # Can cancel\n    undo.cancel(m)\n    assert undo.get_version() == 1\n    assert not undo.has_pending_changes()\n\n    # Undo discarts pending changes\n    m.add_vertices([[0, 0, 0]])\n    undo.undo(m)\n    assert undo.get_version() == 0\n    assert not undo.has_pending_changes()\n\n    # Redo does too\n    m.add_vertices([[0, 0, 0]])\n    undo.redo(m)\n    assert undo.get_version() == 1\n    assert not undo.has_pending_changes()", "\n\ndef test_undo_repairs():\n    snapshots = []\n\n    def snapshot():\n        undo.commit()\n        vertices, faces = m.export()\n        v = undo.get_version()\n        snapshots.append((v, vertices, faces))\n\n    geo = gfx.geometries.torus_knot_geometry(stitch=False)\n    vertices = geo.positions.data\n    faces = geo.indices.data\n\n    m = DynamicMesh(None, None)\n    undo = MeshUndoTracker()\n    m.track_changes(undo)\n    snapshot()\n\n    m.add_mesh(vertices, faces)\n    snapshot()\n\n    assert m.is_manifold\n    assert not m.is_closed\n    assert m.is_oriented\n\n    # Stitch the mesh back up\n    m.repair_touching_boundaries()\n    snapshot()\n\n    assert m.is_manifold\n    assert m.is_closed\n    assert m.is_oriented\n\n    # Create some holes\n    m.delete_faces([1, 123, 250, 312])\n    snapshot()\n\n    assert m.is_manifold\n    assert not m.is_closed\n    assert m.is_oriented\n\n    # Close the holes\n    m.repair(True)\n    snapshot()\n\n    assert m.is_manifold\n    assert m.is_closed\n    assert m.is_oriented\n\n    # Also move some vertices\n    ii = np.arange(10, dtype=np.int32)\n    m.update_vertices(ii, m.positions[ii] * 1.1)\n    snapshot()\n\n    assert m.is_manifold\n    assert m.is_closed\n    assert m.is_oriented\n\n    # Now backtrack all the way to the empty map\n\n    assert len(m.faces) > 0\n\n    for v, vertices, faces in reversed(snapshots):\n        undo.apply_version(m, v)\n        assert np.all(m.positions == vertices)\n        assert np.all(m.faces == faces)\n\n    assert len(m.faces) == 0\n\n    # And redo all the steps!\n\n    for v, vertices, faces in snapshots:\n        undo.apply_version(m, v)\n        assert np.all(m.positions == vertices)\n        assert np.all(m.faces == faces)\n\n    assert len(m.faces) > 0\n\n    # The order can be anything!\n\n    shuffled_snapshots = snapshots.copy()\n    random.shuffle(shuffled_snapshots)\n    assert [x[0] for x in shuffled_snapshots] != [x[0] for x in snapshots]\n\n    for v, vertices, faces in shuffled_snapshots:\n        undo.apply_version(m, v)\n        assert np.all(m.positions == vertices)\n        assert np.all(m.faces == faces)\n\n    # We can also do a step by step by step undo\n    for i in range(20):\n        undo.undo(m)\n    assert np.all(m.positions == snapshots[0][1])\n    assert np.all(m.faces == snapshots[0][2])\n\n    for i in range(20):\n        undo.redo(m)\n    assert np.all(m.positions == snapshots[-1][1])\n    assert np.all(m.faces == snapshots[-1][2])", "\n\ndef test_undo_repeated_vertex_updates():\n    m = DynamicMesh(None, None)\n    undo = MeshUndoTracker()\n    m.track_changes(undo)\n\n    # Add some vertices\n    m.add_vertices([[1, 1, 1] for i in range(10)])\n    v = undo.commit()\n    assert v == 1\n\n    # Update a bunch of vertices. This is a common case when making\n    # interactive modifications to a mesh, e.g. displacing (part of) a mesh.\n    indices = np.array([0, 2, 3], np.int32)\n    positions = m.positions[indices]\n    for i in range(20):\n        m.update_vertices(indices, positions * i)\n    v = undo.commit()\n    assert v == 2\n\n    # Check that the above resulted in a single undo-step!\n    steps = undo._undo[-1]\n    step = steps[0]\n    assert isinstance(steps, list) and len(steps) == 1\n    assert step[0] == \"update_vertices\"\n    assert np.all(step[1] == indices)\n\n    # Check the mesh\n    assert np.all(\n        m.positions[:4] == [[19, 19, 19], [1, 1, 1], [19, 19, 19], [19, 19, 19]]\n    )\n\n    # And undo\n    undo.undo(m)\n    assert np.all(m.positions[:4] == [[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]])\n\n    # Now do it again, but use a list for indices.\n    # The reason is an implementation detail ...\n    indices = [0, 2, 3]\n    positions = m.positions[indices]\n    for i in range(20):\n        m.update_vertices(indices, positions * i)\n    v = undo.commit()\n    assert v == 2\n\n    # Check the mesh\n    assert np.all(\n        m.positions[:4] == [[19, 19, 19], [1, 1, 1], [19, 19, 19], [19, 19, 19]]\n    )\n\n    # And undo\n    undo.undo(m)\n    assert np.all(m.positions[:4] == [[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]])", "\n\nif __name__ == \"__main__\":\n    run_tests(globals())\n"]}
{"filename": "tests/test_meshfuncs.py", "chunked_list": ["\"\"\"\nWe cover most mesh funcs via e.g. test_corrupt.py.\nHere we have a few more tests to test some functions more directly.\n\"\"\"\n\nfrom gfxmorph import meshfuncs\nfrom testutils import run_tests, iter_fans, get_sphere\n\n\ndef test_face_get_neighbours():\n    faces = [(0, 1, 2), (0, 2, 3), (0, 4, 5), (6, 7, 8)]\n    vertex2faces = meshfuncs.make_vertex2faces(faces)\n\n    # Check face groups for vertex 0\n    res = meshfuncs.vertex_get_incident_face_groups(faces, vertex2faces, 0)\n    assert res == [[0, 1], [2]]\n\n    # Neighbours via both edges and vertices\n    n1 = meshfuncs.face_get_neighbours1(faces, vertex2faces, 0)\n    assert n1 == {1, 2}\n\n    # Get both\n    n1, n2 = meshfuncs.face_get_neighbours2(faces, vertex2faces, 0)\n    assert n1 == {1, 2}\n    assert n2 == {1}", "\ndef test_face_get_neighbours():\n    faces = [(0, 1, 2), (0, 2, 3), (0, 4, 5), (6, 7, 8)]\n    vertex2faces = meshfuncs.make_vertex2faces(faces)\n\n    # Check face groups for vertex 0\n    res = meshfuncs.vertex_get_incident_face_groups(faces, vertex2faces, 0)\n    assert res == [[0, 1], [2]]\n\n    # Neighbours via both edges and vertices\n    n1 = meshfuncs.face_get_neighbours1(faces, vertex2faces, 0)\n    assert n1 == {1, 2}\n\n    # Get both\n    n1, n2 = meshfuncs.face_get_neighbours2(faces, vertex2faces, 0)\n    assert n1 == {1, 2}\n    assert n2 == {1}", "\n\ndef test_mesh_boundaries():\n    # An empty mesg has no boundaries (but should not fail)\n    assert meshfuncs.mesh_get_boundaries([]) == []\n\n    # Test boundaries on a bunch of fans\n    for faces in iter_fans():\n        is_closed = len(faces) >= 3 and faces[-1][1] == 1\n        boundaries = meshfuncs.mesh_get_boundaries(faces)\n        assert len(boundaries) == 1\n        boundary = boundaries[0]\n        nr_vertices_on_boundary = 3 * len(faces) - 2 * (len(faces) - 1)\n        if is_closed:\n            nr_vertices_on_boundary -= 2\n        assert len(boundary) == nr_vertices_on_boundary\n\n    # Next we'll work with a sphere. We create two holes in the sphere,\n    # with increasing size. The primary faces to remove should be far\n    # away from each-other, so that when we create larger holes, the\n    # hole's won't touch, otherwise the mesh becomes non-manifold.\n    _, faces_original, _ = get_sphere()\n    vertex2faces = meshfuncs.make_vertex2faces(faces_original)\n\n    for n_faces_to_remove_per_hole in [1, 2, 3, 4]:\n        faces = [face for face in faces_original]\n        faces2pop = []\n        for fi in (2, 30):\n            faces2pop.append(fi)\n            _, fii = meshfuncs.face_get_neighbours2(faces, vertex2faces, fi)\n            for _ in range(n_faces_to_remove_per_hole - 1):\n                faces2pop.append(fii.pop())\n\n        assert len(faces2pop) == len(set(faces2pop))  # no overlap between holes\n\n        for fi in reversed(sorted(faces2pop)):\n            faces.pop(fi)\n\n        boundaries = meshfuncs.mesh_get_boundaries(faces)\n\n        nr_vertices_on_boundary = [0, 3, 4, 5, 6, 7][n_faces_to_remove_per_hole]\n        assert len(boundaries) == 2\n        assert len(boundaries[0]) == nr_vertices_on_boundary\n        assert len(boundaries[1]) == nr_vertices_on_boundary", "\n\ndef test_mesh_get_component_labels():\n    faces = [(0, 1, 2), (0, 2, 3), (0, 4, 5), (6, 7, 8)]\n    vertex2faces = meshfuncs.make_vertex2faces(faces)\n\n    # Connected via edges\n    labels = meshfuncs.mesh_get_component_labels(faces, vertex2faces)\n    assert labels.tolist() == [0, 0, 1, 2]\n\n    # Connected via faces\n    labels = meshfuncs.mesh_get_component_labels(\n        faces, vertex2faces, via_edges_only=False\n    )\n    assert labels.tolist() == [0, 0, 0, 1]", "\n\ndef test_mesh_stitch_boundaries():\n    vertices = [\n        # triangle 1\n        (0.0, 0.0, 0.0),\n        (0.0, 1.0, 0.0),\n        (0.0, 2.0, 0.0),\n        # triangle 2\n        (0.0, 0.0, 0.0),\n        (0.0, 2.0, 0.0),\n        (0.0, 3.0, 0.0),\n        # triangle 3\n        (0.0, 0.0, 1.0),\n        (0.0, 1.0, 1.0),\n        (0.0, 2.0, 1.0),\n        # triangle 4\n        (0.0, 0.0, 1.0),\n        (0.0, 2.0001, 1.0),\n        (0.0, 3.0, 1.0),\n    ]\n    faces = [(0, 1, 2), (3, 4, 5), (6, 7, 8), (9, 10, 11)]\n\n    # Stitch without tolerance -> 3 components.\n    # Note that the last two triangles are not attached at all. Even\n    # though the (0.0, 0.0, 1.0) is a match, stitching only that vertex\n    # would make the mesh non-manifold, so its not done.\n    faces2 = meshfuncs.mesh_stitch_boundaries(vertices, faces, atol=0)\n    assert faces2.tolist() == [[0, 1, 2], [0, 2, 5], [6, 7, 8], [9, 10, 11]]\n\n    # Stitch with tolerances -> 2 components.\n    faces2 = meshfuncs.mesh_stitch_boundaries(vertices, faces, atol=0.001)\n    assert faces2.tolist() == [[0, 1, 2], [0, 2, 5], [6, 7, 8], [6, 8, 11]]", "\n\nif __name__ == \"__main__\":\n    run_tests(globals())\n"]}
{"filename": "tests/test_speed.py", "chunked_list": ["import time\n\nimport numpy as np\nimport pygfx as gfx\nfrom gfxmorph.maybe_pygfx import smooth_sphere_geometry\nfrom gfxmorph import DynamicMesh\nfrom gfxmorph import meshfuncs\nfrom skcg.core.mesh import Mesh\n\n\nclass Timer:\n    def __init__(self):\n        self.measurements = []\n\n    def tic(self):\n        self.t0 = time.perf_counter()\n\n    def toc(self, title):\n        elapsed = time.perf_counter() - self.t0\n        self.add_data(title, f\"{elapsed:0.3f}\")\n\n    def add_data(self, title, value):\n        self.measurements.append((title, str(value)))", "\n\nclass Timer:\n    def __init__(self):\n        self.measurements = []\n\n    def tic(self):\n        self.t0 = time.perf_counter()\n\n    def toc(self, title):\n        elapsed = time.perf_counter() - self.t0\n        self.add_data(title, f\"{elapsed:0.3f}\")\n\n    def add_data(self, title, value):\n        self.measurements.append((title, str(value)))", "\n\ndef iter_big_meshes():\n    geo = smooth_sphere_geometry(100, subdivisions=6)\n    vertices = geo.positions.data\n    faces = geo.indices.data\n    yield \"sphere\", vertices, faces\n\n    geo = gfx.geometries.torus_knot_geometry(100, 20, 10000, 12, stitch=True)\n    vertices = geo.positions.data\n    faces = geo.indices.data\n    yield \"knot\", vertices, faces", "\n\ndef benchmark():\n    columns = []\n\n    for name, vertices, faces in iter_big_meshes():\n        t = Timer()\n        t.add_data(\"MESH\", \"\")\n        t.add_data(\"name\", name)\n        t.add_data(\"nvertices\", len(vertices))\n        t.add_data(\"nfaces\", len(faces))\n        t.add_data(\"\", \"\")\n\n        if True:\n            t.add_data(\"NEW\", \"\")\n            t.tic()\n            m = DynamicMesh(vertices, faces)\n            t.toc(\"init\")\n\n            t.add_data(\"nbytes\", m.metadata[\"approx_mem\"])\n\n            t.tic()\n            # m.check_edge_manifold_and_closed()\n            meshfuncs.mesh_is_edge_manifold_and_closed(m.faces)\n            t.toc(\"check e-manifold & closed\")\n\n            t.tic()\n            # m.check_oriented()\n            meshfuncs.mesh_is_oriented(m.faces)\n            t.toc(\"check oriented\")\n\n            t.tic()\n            meshfuncs.mesh_get_component_labels(m.faces, m.vertex2faces)\n            t.toc(\"split components\")\n\n            t.tic()\n            meshfuncs.mesh_get_non_manifold_vertices(m.faces, m.vertex2faces)\n            t.toc(\"check v-manifold\")\n\n            t.tic()\n            # v = m.get_volume() -> slow because it checks for manifoldness, because a volume of a nonmanifold or nonmanifold mesh means nothing.\n            v = meshfuncs.mesh_get_volume(m.positions, m.faces)\n            t.toc(\"volume\")\n\n            t.tic()\n            vertices, faces = m.export()\n            t.toc(\"export\")\n\n            t.tic()\n            m.reset(None, None)\n            m.reset(vertices, faces)\n            t.toc(f\"reset\")\n\n            t.tic()\n            m.delete_faces(np.arange(0, len(m.faces), 2, np.int32))\n            t.toc(f\"delete 50% faces\")\n\n            m.reset(vertices, None)\n            t.tic()\n            m.delete_vertices(np.arange(0, len(m.positions), 2, np.int32))\n            t.toc(f\"delete 50% vertices\")\n\n            t.add_data(\"\", \"\")\n\n            # t.tic()\n            # i, d = m.get_closest_vertex((0, 0, 0))\n            # verts = m.select_vertices_over_surface(i, 65)\n            # t.toc(\"Select vertices\")\n            # t.add_data(\"\", len(verts))\n\n        if False:\n            t.add_data(\"\", \"\")\n            t.add_data(\"--\", \"--\")\n            t.add_data(\"SKCG\", \"\")\n\n            t.tic()\n            m2 = Mesh(vertices, faces)\n            t.toc(\"init\")\n\n            t.tic()\n            m2.is_manifold\n            t.toc(\"is_manifold\")\n\n            t.tic()\n            # m2.is_really_manifold\n            t.toc(\"is_manifold full\")\n\n            t.tic()\n            m2.is_closed\n            t.toc(\"is_closed\")\n\n            t.tic()\n            m2.is_oriented\n            t.toc(\"is_oriented\")\n\n            m2 = Mesh(vertices, faces)\n\n            t.tic()\n            m2.split_connected_components()\n            t.toc(\"Split components\")\n\n            t.tic()\n            v = m2.computed_interior_volume\n            t.toc(\"Volume\")\n            t.add_data(\"\", v)\n\n        columns.append(t.measurements)\n\n    for row in zip(*columns):\n        titles = [x[0] for x in row]\n        assert len(set(titles)) == 1, \"expected titles to match\"\n        print(titles[0].rjust(32), *[x[1].rjust(10) for x in row])", "\n\ndef benchmark_sphere():\n    t = Timer()\n    t.tic()\n    smooth_sphere_geometry(100, subdivisions=7)\n    t.toc(\"Create smooth spere\")\n    print(t.measurements)\n\n\nif __name__ == \"__main__\":\n    benchmark()", "\n\nif __name__ == \"__main__\":\n    benchmark()\n    # benchmark_sphere()\n"]}
{"filename": "tests/test_pylinalg.py", "chunked_list": ["import numpy as np\n\nfrom gfxmorph.maybe_pylinalg import (\n    volume_of_triangle,\n    volume_of_closed_mesh,\n)\nfrom testutils import run_tests, get_tetrahedron\n\n\ndef test_volume_of_triangle():\n    triangles = [\n        [(0, 0, 1), (0, 1, 1), (1, 1, 1)],\n        [(0, 0, 2), (0, 1, 2), (1, 1, 2)],\n        [(0, 0, 1), (0, -1, 1), (1, -1, 1)],\n        [(0, 0, 1), (0, -1, 1), (-1, 1, 1)],\n    ]\n    expected = [-1 / 6, -1 / 3, 1 / 6, -1 / 6]\n\n    # Test individual calls\n    for triangle, expect in zip(triangles, expected):\n        v = volume_of_triangle(triangle[0], triangle[1], triangle[2])\n        assert np.allclose(v, expect)\n\n    # Test batch call\n    triangles_array = np.array(triangles, np.float32)\n    v1 = triangles_array[:, 0, :]\n    v2 = triangles_array[:, 1, :]\n    v3 = triangles_array[:, 2, :]\n    volumes = volume_of_triangle(v1, v2, v3)\n    assert np.allclose(volumes, expected)", "\ndef test_volume_of_triangle():\n    triangles = [\n        [(0, 0, 1), (0, 1, 1), (1, 1, 1)],\n        [(0, 0, 2), (0, 1, 2), (1, 1, 2)],\n        [(0, 0, 1), (0, -1, 1), (1, -1, 1)],\n        [(0, 0, 1), (0, -1, 1), (-1, 1, 1)],\n    ]\n    expected = [-1 / 6, -1 / 3, 1 / 6, -1 / 6]\n\n    # Test individual calls\n    for triangle, expect in zip(triangles, expected):\n        v = volume_of_triangle(triangle[0], triangle[1], triangle[2])\n        assert np.allclose(v, expect)\n\n    # Test batch call\n    triangles_array = np.array(triangles, np.float32)\n    v1 = triangles_array[:, 0, :]\n    v2 = triangles_array[:, 1, :]\n    v3 = triangles_array[:, 2, :]\n    volumes = volume_of_triangle(v1, v2, v3)\n    assert np.allclose(volumes, expected)", "\n\ndef test_volume_of_closed_mesh():\n    # Create a regular tetrahedron\n    vertices, faces, _ = get_tetrahedron()\n    vertices = np.asarray(vertices)\n    faces = np.asarray(faces)\n\n    edge = 2\n    expected_volume = edge**3 / (6 * 2**0.5)\n\n    # Make sure the tetrahedron is not inside-out\n    for face in faces:\n        a, b, c = vertices[face]\n        assert volume_of_triangle(a, b, c) > 0\n\n    # Measure the volume of this tetrahedron\n    v = volume_of_closed_mesh(vertices, faces)\n    assert np.allclose(v, expected_volume)\n\n    # Make it twice as large (in three dimensions, so it's 4x the volume)\n    vertices *= 2\n    v = volume_of_closed_mesh(vertices, faces)\n    assert np.allclose(v, expected_volume * 8)\n\n    # Move it\n    vertices += 10\n    v = volume_of_closed_mesh(vertices, faces)\n    assert np.allclose(v, expected_volume * 8)\n\n    # Duplicate it, using faces\n    faces2 = np.row_stack([faces, faces])\n    v = volume_of_closed_mesh(vertices, faces2)\n    assert np.allclose(v, expected_volume * 16)\n\n    # Really duplicate it\n    vertices2 = np.row_stack([vertices, vertices + 10])\n    faces2 = np.row_stack([faces, faces + 4])\n    v = volume_of_closed_mesh(vertices2, faces2)\n    assert np.allclose(v, expected_volume * (8 + 8), atol=0.001)\n\n    # Reduce size of the first one\n    vertices2[:4] -= 10\n    vertices2[:4] *= 0.5\n    v = volume_of_closed_mesh(vertices2, faces2)\n    assert np.allclose(v, expected_volume * (8 + 1), atol=0.001)\n\n    # Reduce size of the second one\n    vertices2[4:] -= 20\n    vertices2[4:] *= 0.5\n    v = volume_of_closed_mesh(vertices2, faces2)\n    assert np.allclose(v, expected_volume * (1 + 1), atol=0.001)\n\n    # Move one inside out\n    faces2[:4, 1], faces2[:4, 2] = faces2[:4, 2].copy(), faces2[:4, 1].copy()\n    v = volume_of_closed_mesh(vertices2, faces2)\n    assert np.allclose(v, expected_volume * 0, atol=0.001)\n\n    # Move the other inside out too, now the volume is negative\n    faces2[4:, 1], faces2[4:, 2] = faces2[4:, 2].copy(), faces2[4:, 1].copy()\n    v = volume_of_closed_mesh(vertices2, faces2)\n    assert np.allclose(v, -expected_volume * 2, atol=0.001)", "\n\nif __name__ == \"__main__\":\n    run_tests(globals())\n"]}
{"filename": "gfxmorph/maybe_pygfx.py", "chunked_list": ["import numpy as np\nimport pylinalg as la\nimport pygfx as gfx\n\nfrom .basedynamicmesh import MeshChangeTracker\n\n\nclass DynamicMeshGeometry(gfx.Geometry, MeshChangeTracker):\n    \"\"\"A geometry class specifically for representing dynamic meshes.\n\n    This class also inherits from ``gfxmorph.MeshChangeTracker`` so\n    that the geometry can do precise updates to the GPU buffers when\n    the mesh is changed dynamically.\n    \"\"\"\n\n    def init(self, mesh):\n        self._nverts = len(mesh.positions)\n        self._nfaces = len(mesh.faces)\n        self.new_vertices_buffer(mesh)\n        self.new_faces_buffer(mesh)\n\n    def new_vertices_buffer(self, mesh):\n        self.positions = gfx.Buffer(mesh.positions.base)\n        self.normals = gfx.Buffer(mesh.normals.base)\n\n    def new_faces_buffer(self, mesh):\n        self.indices = gfx.Buffer(mesh.faces.base)\n\n    def add_faces(self, faces):\n        old_n = self._nfaces\n        self._nfaces += len(faces)\n        self.indices.update_range(old_n, self._nfaces)\n        self.indices.draw_range = 0, self._nfaces\n\n    def pop_faces(self, n, old):\n        self._nfaces -= n\n        self.indices.draw_range = 0, self._nfaces\n\n    def swap_faces(self, indices1, indices2):\n        self.indices.update_range(indices1.min(), indices1.max() + 1)\n        self.indices.update_range(indices2.min(), indices2.max() + 1)\n\n    def update_faces(self, indices, faces, old):\n        self.indices.update_range(indices.min(), indices.max() + 1)\n\n    def add_vertices(self, positions):\n        old_n = self._nverts\n        self._nverts += len(positions)\n        self.positions.update_range(old_n, self._nverts)\n\n    def pop_vertices(self, n, old):\n        self._nverts -= n\n\n    def swap_vertices(self, indices1, indices2):\n        self.positions.update_range(indices1.min(), indices1.max() + 1)\n        self.positions.update_range(indices2.min(), indices2.max() + 1)\n\n    def update_vertices(self, indices, positions, old):\n        # todo: Optimize this, both here and on the pygfx side.\n        # - We can update positions more fine-grained (using chunking).\n        # - Consider an API where a mask is passed (e.g. positions.update_mask()),\n        #   maybe this would be more efficient than using indices?\n        # - If we render with flat_shading, we don't need the normals!\n        #   So if the normal-updates are a bottleneck, it could be made optional.\n        self.positions.update_range(indices.min(), indices.max() + 1)\n\n    def update_normals(self, indices):\n        self.normals.update_range(indices.min(), indices.max() + 1)", "\n\ndef solid_tetrahedon():\n    \"\"\"The smallest/simplest possible mesh that contains a volume.\n    It is a closed orientable manifold.\n\n    \"\"\"\n    vertices = np.array(\n        [\n            [-1, 0, -1 / 2**0.5],\n            [+1, 0, -1 / 2**0.5],\n            [0, -1, 1 / 2**0.5],\n            [0, +1, 1 / 2**0.5],\n        ],\n        dtype=np.float32,\n    )\n    vertices /= np.linalg.norm(vertices, axis=1)[..., None]\n\n    faces = np.array(\n        [\n            [2, 0, 1],\n            [0, 2, 3],\n            [1, 0, 3],\n            [2, 1, 3],\n        ],\n        dtype=np.int32,\n    )\n    return vertices, faces", "\n\ndef subdivide_faces(vertices, faces):\n    r\"\"\" Subdivide a mesh.\n\n    This function subdivides the given faces, by dividing each triangle\n    into 4 new triangles, as in the image below:\n\n             /\\\n            /__\\\n           /\\  /\\\n          /__\\/__\\\n\n    The returned arrays must be processed by the caller. This is\n    intentional, because it depends on the use-case how this is best\n    done. E.g. the new vertices may be re-positioned a bit, or perhaps\n    the subdivision was applied on a subset of the total faces, and\n    merging the result requires some special indexing.\n\n    Returns\n    -------\n        new_vertices : ndarray\n            The new vertices that lie in the middle of the edges of the\n            original faces. It is the responsibility of the caller to\n            ``row_stack`` these to the original vertices.\n        new_faces : ndarray\n            The new faces. These should replace the given faces.\n    \"\"\"\n\n    # First collect unique edges. We will create one new vertex in\n    # the middle of each edge.\n    edges = faces[:, [[0, 1], [1, 2], [2, 0]]]\n    all_edges = edges.reshape(-1, 2)\n    all_edges.sort(axis=1)\n\n    # Find unique edges. We use a trick to get a 25% performance boost\n    # unique_edges, reverse_index = np.unique(all_edges, axis=0, return_inverse=True)\n    all_edges_buf = np.frombuffer(all_edges, dtype=\"V8\")\n    unique_edges_buf, reverse_index = np.unique(\n        all_edges_buf, axis=0, return_inverse=True\n    )\n    unique_edges = np.frombuffer(unique_edges_buf, dtype=np.int32).reshape(-1, 2)\n\n    # The most tricky step in this algorithm is finding the new\n    # indices (on the new faces) based on the edges on which these\n    # new vertices are placed. Using a Python dict (where the keys\n    # are edges, represented as tuples of 2 indices) works, but\n    # makes things slow.\n    #\n    # The trick: we use the reverse_index produced by `np.unique`\n    # to create a map that has the same shape as the faces array,\n    # but the indices along axis 1 represent edges instead of\n    # vertices.\n    indices_to_new_vertices = np.arange(len(unique_edges), dtype=np.int32) + len(\n        vertices\n    )\n    face_edges_to_new_indices = indices_to_new_vertices[reverse_index]\n    face_edges_to_new_indices.shape = -1, 3\n\n    # Create new vertices on the middle of the edges.\n    new_vertices = 0.5 * (vertices[unique_edges[:, 0]] + vertices[unique_edges[:, 1]])\n\n    # We replace each triangle with 4 new triangles, like this.\n    #\n    #      v2\n    #      /\\\n    #  e2 /__\\ e1\n    #    /\\  /\\\n    #   /__\\/__\\\n    # v0   e0   v1\n    #\n    smaller_faces = [\n        # face 1\n        faces[:, 0],\n        face_edges_to_new_indices[:, 0],\n        face_edges_to_new_indices[:, 2],\n        # face 2\n        faces[:, 1],\n        face_edges_to_new_indices[:, 1],\n        face_edges_to_new_indices[:, 0],\n        # face 3\n        faces[:, 2],\n        face_edges_to_new_indices[:, 2],\n        face_edges_to_new_indices[:, 1],\n        # face 4\n        face_edges_to_new_indices[:, 0],\n        face_edges_to_new_indices[:, 1],\n        face_edges_to_new_indices[:, 2],\n    ]\n    new_faces = np.column_stack(smaller_faces).reshape(-1, 3)\n\n    return new_vertices, new_faces", "\n\ndef smooth_sphere_geometry(radius=1.0, max_edge_length=None, subdivisions=None):\n    \"\"\"Generate a sphere consisting of homogenous triangles.\n\n    Creates a sphere that has its center in the local origin. The sphere\n    consists of 60 regular triangular faces and 32 vertices (a Pentakis\n    Dodecahedron). The triangles are subdivided if necessary to create\n    a smoother surface.\n\n    This geometry differs from the `sphere_geometry` in that it's\n    mathematically closed; it consists of a single contiguous surface\n    that encloses the space inside. The faces are also distributed\n    evenly over the surface, all edges have the same length, and each\n    triangle has the same number of incident faces. This means less\n    vertices are needed to create a smoother surface. The downside is\n    that one cannot easily apply a 2D texture map to this geometry.\n\n    Parameters\n    ----------\n    radius : float\n        The radius of the sphere. Vertices are placed at this distance around\n        the local origin.\n    max_edge_length : float | None\n        If given and not None, it is used to calculate the `subdivisions`.\n        The faces will be recursively subdivided until the length of each edge\n        is no more than this value (taking the given radius into account).\n    subdivisions : int | None\n        The number of times to recursively subdivide the faces. The total number of faces\n        will be ``60 * 4 ** subdivisions``. Default 0.\n\n    Returns\n    -------\n    sphere : Geometry\n        A geometry object that represents a sphere. Mathematically, the\n        mesh is an orientable closed manifold.\n\n    \"\"\"\n\n    # Dev notes:\n    #\n    # The idea of this function is to take a polyhedron, and subdivide it by\n    # splitting each edge in two, turning each face into 4 smaller faces.\n    # In the image below the triangle a-b-c is subdivided:\n    #\n    #     c\n    #     /\\\n    # ca /__\\ bc\n    #   /\\  /\\\n    #  /__\\/__\\\n    # a   ab   b\n    #\n    # Imagine this to be one triangle on a polyhedron. One can see that\n    # the new vertices are surrounded by 6 faces (3 in triangle a-b-c,\n    # and 3 more in the neighbouring triangle). One can also see that\n    # for the original vertices (e.g. a), the number of surrounding\n    # faces does not change by the subdividing process. It will only\n    # be defined by the original geometry.\n    #\n    # Therefore, in order to create a geometry that remains truely\n    # regular after subdividing it, we need to start with a polyhedron,\n    # consisting of triangles, where each vertex is shared by 6 faces.\n    # As far as I know, the Pentakis Dodecahedron (a.k.a.\n    # Kisdodecahedron) is the smallest polyhedron that meets these\n    # criteria. E.g. subdividing a Tetrahedron will result in rings\n    # around the original vertices. An Icosahedron (which has 5 faces\n    # around each vertex) would produce similar artifacts.\n    #\n    # The values of vertices and faces was taken from:\n    # Source: http://dmccooey.com/polyhedra/PentakisDodecahedron.txt\n\n    # Check radius\n    radius = float(radius)\n    if radius <= 0:\n        raise ValueError(\"Radius must be larger than zero.\")\n\n    # Determine the number of subdivisions\n    if max_edge_length is not None and subdivisions is not None:\n        raise ValueError(\n            \"Either max_edge_length or subdivisions must be given, or none, but not both.\"\n        )\n    elif max_edge_length is not None:\n        if max_edge_length <= 0:\n            raise ValueError(\"max_edge_length must be larger than zero.\")\n        # Emulate the effect of the subdivision process on two neighbouring vertices on the mesh\n        a = np.array([+0.35682207, 0.93417233, 0.0], np.float64)\n        b = np.array([-0.35682207, 0.93417233, 0.0], np.float64)\n        subdivisions = 0\n        while la.vec_dist(a, b) * radius > max_edge_length:\n            b = 0.5 * (a + b)\n            b /= np.linalg.norm(b)\n            subdivisions += 1\n    elif subdivisions is not None:\n        subdivisions = max(0, int(subdivisions))\n    else:\n        subdivisions = 0\n\n    # Calculate number of faces and vertices. Mostly to validate the result.\n    nfaces = 60 * 4**subdivisions\n    nvertices = nfaces // 2 + 2  # weird, but true\n\n    c0 = 0.927050983124842272306880251548  # == 3 * (5**0.5 - 1) / 4\n    c1 = 1.33058699733550141141687582919  # == 9 * (9 + 5**0.5) / 76\n    c2 = 2.15293498667750705708437914596  # == 9 * (7 + 5 * 5**0.5) / 76\n    c3 = 2.427050983124842272306880251548  # == 3 * (1 + 5**0.5) / 4\n\n    # Add vertices of the Pentakis Dodecahedron\n    vertices = np.array(\n        [\n            (0.0, c0, c3),\n            (0.0, c0, -c3),\n            (0.0, -c0, c3),\n            (0.0, -c0, -c3),\n            (c3, 0.0, c0),\n            (c3, 0.0, -c0),\n            (-c3, 0.0, c0),\n            (-c3, 0.0, -c0),\n            (c0, c3, 0.0),\n            (c0, -c3, 0.0),\n            (-c0, c3, 0.0),\n            (-c0, -c3, 0.0),\n            (c1, 0.0, c2),\n            (c1, 0.0, -c2),\n            (-c1, 0.0, c2),\n            (-c1, 0.0, -c2),\n            (c2, c1, 0.0),\n            (c2, -c1, 0.0),\n            (-c2, c1, 0.0),\n            (-c2, -c1, 0.0),\n            (0.0, c2, c1),\n            (0.0, c2, -c1),\n            (0.0, -c2, c1),\n            (0.0, -c2, -c1),\n            (1.5, 1.5, 1.5),\n            (1.5, 1.5, -1.5),\n            (1.5, -1.5, 1.5),\n            (1.5, -1.5, -1.5),\n            (-1.5, 1.5, 1.5),\n            (-1.5, 1.5, -1.5),\n            (-1.5, -1.5, 1.5),\n            (-1.5, -1.5, -1.5),\n        ],\n        np.float32,\n    )\n\n    # The vertices are not on the unit sphere, they seem to not even\n    # be exactly on the same sphere. So we push them to the unit sphere.\n    lengths = np.linalg.norm(vertices, axis=1)\n    vertices[:, 0] /= lengths\n    vertices[:, 1] /= lengths\n    vertices[:, 2] /= lengths\n\n    # Apply the faces of the Pentakis Dodecahedron.\n    # Except that these may recurse to create sub-faces.\n    faces = np.array(\n        [\n            (12, 0, 2),\n            (12, 2, 26),\n            (12, 26, 4),\n            (12, 4, 24),\n            (12, 24, 0),\n            (13, 3, 1),\n            (13, 1, 25),\n            (13, 25, 5),\n            (13, 5, 27),\n            (13, 27, 3),\n            (14, 2, 0),\n            (14, 0, 28),\n            (14, 28, 6),\n            (14, 6, 30),\n            (14, 30, 2),\n            (15, 1, 3),\n            (15, 3, 31),\n            (15, 31, 7),\n            (15, 7, 29),\n            (15, 29, 1),\n            (16, 4, 5),\n            (16, 5, 25),\n            (16, 25, 8),\n            (16, 8, 24),\n            (16, 24, 4),\n            (17, 5, 4),\n            (17, 4, 26),\n            (17, 26, 9),\n            (17, 9, 27),\n            (17, 27, 5),\n            (18, 7, 6),\n            (18, 6, 28),\n            (18, 28, 10),\n            (18, 10, 29),\n            (18, 29, 7),\n            (19, 6, 7),\n            (19, 7, 31),\n            (19, 31, 11),\n            (19, 11, 30),\n            (19, 30, 6),\n            (20, 8, 10),\n            (20, 10, 28),\n            (20, 28, 0),\n            (20, 0, 24),\n            (20, 24, 8),\n            (21, 10, 8),\n            (21, 8, 25),\n            (21, 25, 1),\n            (21, 1, 29),\n            (21, 29, 10),\n            (22, 11, 9),\n            (22, 9, 26),\n            (22, 26, 2),\n            (22, 2, 30),\n            (22, 30, 11),\n            (23, 9, 11),\n            (23, 11, 31),\n            (23, 31, 3),\n            (23, 3, 27),\n            (23, 27, 9),\n        ],\n        np.int32,\n    )\n\n    for _ in range(subdivisions):\n        # Subdivide!\n        new_vertices, new_faces = subdivide_faces(vertices, faces)\n\n        # Process new vertices\n        lengths = np.linalg.norm(new_vertices, axis=1)\n        new_vertices[:, 0] /= lengths\n        new_vertices[:, 1] /= lengths\n        new_vertices[:, 2] /= lengths\n        vertices = np.row_stack([vertices, new_vertices])\n\n        # The faces are simply replaced\n        faces = new_faces\n\n    # Double-check that the expected numbers match the real ones\n    assert nfaces == len(faces)\n    assert nvertices == len(vertices)\n\n    # Return as a geometry\n    return gfx.Geometry(positions=vertices * radius, indices=faces, normals=vertices)", "\n\nif __name__ == \"__main__\":\n    import time\n\n    t0 = time.perf_counter()\n    geo = smooth_sphere_geometry(100, None, 1)\n    print(time.perf_counter() - t0)\n    m = gfx.Mesh(\n        geo,\n        gfx.MeshPhongMaterial(wireframe=True, wireframe_thickness=3),\n    )\n    # m.material.side = \"FRONT\"\n\n    gfx.show(m)", ""]}
{"filename": "gfxmorph/maybe_pylinalg.py", "chunked_list": ["import numpy as np\n\n\ndef volume_of_triangle(p1, p2, p3):\n    \"\"\"Get the volume that a triangle has, the fourth point being the origin.\n\n    Assumes CCW winding. Negate the result for CW winded triangles.\n    \"\"\"\n    # https://stackoverflow.com/a/1568551\n    p1 = np.reshape(p1, (-1, 3))\n    p2 = np.reshape(p2, (-1, 3))\n    p3 = np.reshape(p3, (-1, 3))\n\n    p1x, p1y, p1z = p1[:, 0], p1[:, 1], p1[:, 2]\n    p2x, p2y, p2z = p2[:, 0], p2[:, 1], p2[:, 2]\n    p3x, p3y, p3z = p3[:, 0], p3[:, 1], p3[:, 2]\n    v321 = p3x * p2y * p1z\n    v231 = p2x * p3y * p1z\n    v312 = p3x * p1y * p2z\n    v132 = p1x * p3y * p2z\n    v213 = p2x * p1y * p3z\n    v123 = p1x * p2y * p3z\n    result = (1.0 / 6.0) * (-v321 + v231 + v312 - v132 - v213 + v123)\n\n    if not result.shape:\n        return float(result)\n    elif result.shape == (1,):\n        return float(result[0])\n    else:\n        return result", "\n\ndef volume_of_closed_mesh(vertices, faces):\n    \"\"\"Calculate the volume of the mesh.\n\n    It is assumed that all faces have consisted, and that the winding\n    is CCW (produces a negative volume if the winding is CW). It is\n    also assumed that the mesh is closed. Unclosed volumes are leaky,\n    resulting in an incorrect volume calculation.\n    \"\"\"\n\n    # Note: it's possible to get a hint on whether the volume is\n    # actually closed, by displacing the vertices and calculating the\n    # volume again. If there is a leak in the mesh, that leak will cause\n    # the second volume to be different. This depends a bit on the\n    # geometry, and it's hard to tell when errors are round-off errors,\n    # or may be an indication of a leak. Therefore its probably better\n    # to perform a proper analysis to detect the mesh being closed.\n\n    # Batch-calculate\n    volumes = volume_of_triangle(\n        vertices[faces[:, 0]], vertices[faces[:, 1]], vertices[faces[:, 2]]\n    )\n    return volumes if isinstance(volumes, float) else volumes.sum()", ""]}
{"filename": "gfxmorph/basedynamicmesh.py", "chunked_list": ["import weakref\n\nimport numpy as np\n\nfrom .tracker import MeshChangeTracker\nfrom .utils import (\n    logger,\n    Safecall,\n    check_indices,\n    as_immutable_array,", "    check_indices,\n    as_immutable_array,\n    make_vertex2faces,\n)\n\n\nEXCEPTION_IN_ATOMIC_CODE = \"Unexpected exception in code that is considered atomic!\"\n\n\nclass BaseDynamicMesh:\n    \"\"\"A mesh object that can be modified in-place.\n\n    It manages buffers that are oversized so the vertex and face array\n    can grow. When the buffer is full, a larger buffer is allocated.\n    The exposed arrays are contiguous views onto these buffers.\n\n    It also maintains a vertex2faces incidence map, and keeps the vertex\n    normals up to date. It can notify other object of changes, so that\n    any representation of the mesh  (e.g. a visualization on the GPU)\n    can be kept in sync.\n    \"\"\"\n\n    # We assume meshes with triangles (not quads).\n    # Note that there are a few places where loops are unrolled, and verts_per_face is thus hardcoded.\n    _verts_per_face = 3\n\n    def __init__(self):\n        # Caches that subclasses can use to cache stuff. When the\n        # positions/faces change, the respective caches are cleared.\n        self._cache_depending_on_verts = {}\n        self._cache_depending_on_faces = {}\n        self._cache_depending_on_verts_and_faces = {}\n\n        # A list of trackers that are notified of changes.\n        self._change_trackers = weakref.WeakValueDictionary()\n\n        # Create the buffers that contain the data, and which are larger\n        # than needed. These arrays should *only* be referenced in the\n        # allocate- and deallocate- methods.\n        self._faces_buf = np.zeros((8, self._verts_per_face), np.int32)\n        self._faces_normals_buf = np.zeros((8, 3), np.float32)\n        self._positions_buf = np.zeros((8, 3), np.float32)\n        self._normals_buf = np.zeros((8, 3), np.float32)\n\n        # We set unused positions to nan, so that code that uses the\n        # full buffer does not accidentally use invalid vertex positions.\n        self._positions_buf.fill(np.nan)\n\n        # Create faces array views. The internals operate on the ._faces array,\n        # because the public .faces is readonly\n        self._faces = self._faces_buf[:0]\n        self._faces_normals = self._faces_normals_buf[:0]\n\n        # The vertex array views. Not much harm can be done to these.\n        self._positions = self._positions_buf[:0]\n        self._normals = self._normals_buf[:0]\n\n        # Reverse map\n        # This array is jagged, because the number of faces incident\n        # to one vertex can potentially be big (e.g. the top and bottom\n        # of a sphere sampled in lon/lat directions). We could use a\n        # numpy array of lists, which has the advantage that you can\n        # do `vertex2faces[multiple_indices].sum()`. However, benchmarks\n        # show that this is *slower* than a simple list of lists. A\n        # list of sets could also work, but is slightly slower.\n        #\n        # Other data structures are also possibe, e.g. one based on\n        # shifts. These structures can be build faster, but using them\n        # is slower due to the extra indirection.\n        self._vertex2faces = []  # vi -> [fi1, fi2, ..]\n\n    @property\n    def faces(self):\n        \"\"\"The faces of the mesh.\n\n        This is a C-contiguous readonly ndarray. Note that the array\n        may change as data is added and deleted, including faces being\n        moved arround to fill holes left by deleted faces.\n        \"\"\"\n        return as_immutable_array(self._faces)\n\n    @property\n    def positions(self):\n        \"\"\"The vertex positions of the mesh.\n\n        See note on ``.faces`` for details.\n        \"\"\"\n        return as_immutable_array(self._positions)\n\n    @property\n    def normals(self):\n        \"\"\"The vertex normals of the mesh.\n\n        See note on ``.faces`` for details.\n        \"\"\"\n        return as_immutable_array(self._normals)\n\n    @property\n    def vertex2faces(self):\n        \"\"\"Maps vertex indices to a list of face indices.\n\n        This map can be used to e.g. traverse the mesh over its surface.\n\n        Although technically the map is a list that can be modified in\n        place, you should really not do that. Note that each element\n        lists face indices in arbitrary order and may contain duplicate\n        face indices.\n        \"\"\"\n        return self._vertex2faces\n\n    def track_changes(self, tracker, *, remove=False):\n        \"\"\"Track changes using a MeshChangeTracker object.\n\n        The given object is notified of updates of this mesh. If\n        ``remove`` is True, the tracker is removed instead.\n        \"\"\"\n        if not isinstance(tracker, MeshChangeTracker):\n            raise TypeError(\"Expected a MeshChangeTracker subclass.\")\n        self._change_trackers.pop(id(tracker), None)\n        if not remove:\n            self._change_trackers[id(tracker)] = tracker\n            # Init the tracker state so it starts up-to-date\n            with Safecall():\n                tracker.init(self)\n\n    def export(self):\n        \"\"\"Get a copy of the array of vertex-positions and faces.\n\n        Note that the arrays are copied because the originals are\n        modified in place when e.g. faces are removed or updated.\n        \"\"\"\n        return self.positions.copy(), self.faces.copy()\n\n    def check_internal_state(self):\n        \"\"\"Method to validate the integrity of the internal state.\n\n        In practice this check is not be needed, but it's used\n        extensively during the unit tests to make sure that all methods\n        work as intended.\n        \"\"\"\n\n        # Note: some vertices not being used is technically an ok state.\n        # It is also unavoidable, because one first adds vertices and\n        # then the faces to use them. But a bug in our internals could\n        # make the number of unused vertices grow, so maybe we'll want\n        # some sort of check for it at some point.\n        nverts = len(self.positions)\n        nfaces = len(self.faces)\n\n        # Check that all faces match a vertex\n        if nfaces > 0:\n            assert self.faces.min() >= 0\n            assert self.faces.max() < nverts\n\n        # Check sizes of arrays\n        assert len(self._faces) == nfaces\n        assert len(self._faces_normals) == nfaces\n        assert len(self._positions) == nverts\n        assert len(self._normals) == nverts\n\n        # Check that the views are based on the corresppnding buffers\n        assert self._faces.base is self._faces_buf\n        assert self._faces_normals.base is self._faces_normals_buf\n        assert self._positions.base is self._positions_buf\n        assert self._normals.base is self._normals_buf\n\n        # Check vertex2faces map\n        vertex2faces = make_vertex2faces(self.faces, nverts)\n        assert len(vertex2faces) == len(self._vertex2faces)\n        for face1, face2 in zip(vertex2faces, self._vertex2faces):\n            assert sorted(face1) == sorted(face2)\n\n    def _after_change(self):\n        \"\"\"Called after each change. Does nothing by default, but subclasses can overload this.\"\"\"\n        pass\n\n    # %% Manage normals\n\n    def _update_face_normals(self, face_indices):\n        \"\"\"Update the selected face normals.\"\"\"\n        face_indices = np.asarray(face_indices, np.int32)\n        faces = self._faces[face_indices]\n        positions = self._positions\n\n        r1 = positions[faces[:, 0], :]\n        r2 = positions[faces[:, 1], :]\n        r3 = positions[faces[:, 2], :]\n        face_normals = np.cross((r2 - r1), (r3 - r1))  # assumes CCW\n        # faces_areas = 0.5 * np.linalg.norm(face_normals, axis=1)\n\n        self._faces_normals[face_indices] = face_normals\n\n        # The thing with vertex normals is that they depend on all\n        # incident faces, so doing a partial update is tricky.\n        # * We could first undo the contribution of the selected faces. E.g.\n        #   using a list of dicts: vi -> fi -> normals. Likely slow.\n        # * Or we first select the vertex_indices (by flattening faces), and use\n        #   vertex2faces to come up with a slightly larger set of face_indices,\n        #   which we then use to update the normals for the vertex_indices (and more)\n        #   and then only update vertex_indices. Also likely slow.\n        # * Only update the face normals and vertex normals of connected components.\n        # * Or we just update all vertex normals, but notify trackers\n        #   with the indices of vertices who's normal actually changed.\n        # * Note: we could implement some form of lazy computation for the\n        #   normals, or an option to turn all this off if no normals are needed.\n        self._update_vertex_normals()\n\n        # Get indices of vertices who's normal changed\n        vertex_mask = np.zeros((len(self._positions),), bool)\n        vertex_mask[faces.flatten()] = True\n        vertex_indices = np.where(vertex_mask)[0]\n\n        # Pass on the update\n        for tracker in self._change_trackers.values():\n            with Safecall():\n                tracker.update_normals(vertex_indices)\n\n    def _update_vertex_normals(self):\n        \"\"\"Update all vertex normals.\"\"\"\n        vertex_normals = self._normals\n        vertex_normals.fill(0.0)\n        for i in range(3):\n            np.add.at(vertex_normals, self._faces[:, i], self._faces_normals)\n\n        norms = np.linalg.norm(vertex_normals, axis=1)\n\n        (zeros,) = np.where(norms == 0)\n        norms[zeros] = 1.0  # prevent divide-by-zero\n        vertex_normals /= norms[:, np.newaxis]\n        vertex_normals[zeros] = 0.0\n\n    # %% Allocation and de-allocation of the buffers\n\n    def _allocate_faces(self, n):\n        \"\"\"Increase the size of the faces view to hold n free faces at\n        the end. If necessary the underlying buffer is re-allocated.\n        \"\"\"\n        n = int(n)\n        assert n >= 1\n        nfaces1 = len(self._faces)\n        nfaces2 = nfaces1 + n\n        # Re-allocate buffer?\n        new_buffers = nfaces2 > len(self._faces_buf)\n        if new_buffers:\n            new_size = max(8, nfaces2)\n            new_size = 2 ** int(np.ceil(np.log2(new_size)))\n            self._faces_buf = np.zeros((new_size, self._verts_per_face), np.int32)\n            self._faces_buf[:nfaces1] = self._faces\n            self._faces_normals_buf = np.zeros((new_size, 3), np.float32)\n            self._faces_normals_buf[:nfaces1] = self._faces_normals\n        # Reset views\n        self._faces = self._faces_buf[:nfaces2]\n        self._faces_normals = self._faces_normals_buf[:nfaces2]\n        # Notify\n        if new_buffers:\n            for tracker in self._change_trackers.values():\n                with Safecall():\n                    tracker.new_faces_buffer(self)\n\n    def _deallocate_faces(self, n):\n        \"\"\" \"Decrease the size of the faces view, discarting the n faces\n        at the end. If it makes sense, the underlying buffer is re-allocated.\n        \"\"\"\n        n = int(n)\n        assert n >= 1\n        nfaces = len(self._faces) - n\n        # Re-allocate buffer?\n        new_buffers = nfaces <= 0.25 * len(self._faces_buf) and len(self._faces_buf) > 8\n        if new_buffers:\n            new_size = max(8, nfaces * 2)\n            new_size = 2 ** int(np.ceil(np.log2(new_size)))\n            self._faces_buf = np.zeros((new_size, self._verts_per_face), np.int32)\n            self._faces_buf[:nfaces] = self._faces[:nfaces]\n            self._faces_normals_buf = np.zeros((new_size, 3), np.float32)\n            self._faces_normals_buf[:nfaces] = self._faces_normals[:nfaces]\n        else:\n            # Tidy up\n            self._faces_buf[nfaces:] = 0\n            self._faces_normals_buf[nfaces:] = 0.0\n        # Reset views\n        self._faces = self._faces_buf[:nfaces]\n        self._faces_normals = self._faces_normals_buf[:nfaces]\n        # Notify\n        if new_buffers:\n            for tracker in self._change_trackers.values():\n                with Safecall():\n                    tracker.new_faces_buffer(self)\n\n    def _allocate_vertices(self, n):\n        \"\"\"Increase the vertex views to hold n free vertices at the end. If\n        necessary the underlying buffers are re-allocated.\n        \"\"\"\n        n = int(n)\n        assert n >= 1\n        nverts1 = len(self._positions)\n        nverts2 = nverts1 + n\n        # Re-allocate buffer?\n        new_buffers = nverts2 > len(self._positions_buf)\n        if new_buffers:\n            new_size = max(8, nverts2)\n            new_size = 2 ** int(np.ceil(np.log2(new_size)))\n            self._positions_buf = np.zeros((new_size, 3), np.float32)\n            self._positions_buf[:nverts1] = self._positions\n            self._positions_buf[nverts2:] = np.nan\n            self._normals_buf = np.zeros((new_size, 3), np.float32)\n            self._normals_buf[:nverts1] = self._normals\n        # Reset views\n        self._positions = self._positions_buf[:nverts2]\n        self._normals = self._normals_buf[:nverts2]\n        # Notify\n        if new_buffers:\n            for tracker in self._change_trackers.values():\n                with Safecall():\n                    tracker.new_vertices_buffer(self)\n\n    def _deallocate_vertices(self, n):\n        \"\"\"Decrease the size of the vertices views, discarting the n vertices\n        at the end. If it makes sense, the underlying buffer is re-allocated.\n        \"\"\"\n        n = int(n)\n        assert n >= 1\n        nverts = len(self._positions) - n\n        # Re-allocate buffer?\n        new_buffers = (\n            nverts <= 0.25 * len(self._positions_buf) and len(self._positions_buf) > 8\n        )\n        if new_buffers:\n            new_size = max(8, nverts * 2)\n            new_size = 2 ** int(np.ceil(np.log2(new_size)))\n            self._positions_buf = np.zeros((new_size, 3), np.float32)\n            self._positions_buf[:nverts] = self._positions[:nverts]\n            self._positions_buf[nverts:] = np.nan\n            self._normals_buf = np.zeros((new_size, 3), np.float32)\n            self._normals_buf[:nverts] = self._normals[:nverts]\n        else:\n            # Tidy up\n            self._positions_buf[nverts:] = np.nan\n            self._normals_buf[nverts:] = 0\n        # Reset views\n        self._positions = self._positions_buf[:nverts]\n        self._normals = self._normals_buf[:nverts]\n        # Notify\n        if new_buffers:\n            for tracker in self._change_trackers.values():\n                with Safecall():\n                    tracker.new_vertices_buffer(self)\n\n    # %% Convenience methods to modify the mesh\n\n    def clear(self):\n        \"\"\"Clear the mesh, removing all vertices and faces.\"\"\"\n        if len(self._faces):\n            self.pop_faces(len(self._faces))\n        if len(self._positions):\n            self.pop_vertices(len(self._positions))\n\n    def reset(self, positions, faces):\n        \"\"\"Reset the vertices and faces, e.g. from an export.\"\"\"\n        self.clear()\n        if positions is not None:\n            self.add_vertices(positions)\n        if faces is not None:\n            self.add_faces(faces)\n\n    def delete_faces(self, face_indices):\n        \"\"\"Delete the faces indicated by the given face indices.\n\n        The deleted faces are replaced with faces from the end of the\n        array (except for deleted faces that leave no holes because\n        they are already at the end).\n\n        An error can be raised if e.g. the indices are out of bounds.\n        \"\"\"\n\n        # --- Prepare / checks\n\n        indices = check_indices(\n            face_indices, len(self._faces), \"face indices to delete\"\n        )\n        to_delete = set(indices)\n\n        nfaces1 = len(self._faces)\n        nfaces2 = nfaces1 - len(to_delete)\n\n        to_maybe_move = set(range(nfaces2, nfaces1))  # these are for filling the holes\n        to_just_drop = to_maybe_move & to_delete  # but some of these may be at the end\n\n        indices1 = list(to_delete - to_just_drop)\n        indices2 = list(to_maybe_move - to_just_drop)\n        assert len(indices1) == len(indices2), \"Internal error\"\n\n        # --- Apply -> delegate\n\n        # Do a move, so all faces to delete are at the end\n        if len(indices1):\n            self.swap_faces(indices1, indices2)\n\n        # Pop from the end\n        self.pop_faces(len(to_delete))\n\n    def delete_vertices(self, vertex_indices):\n        \"\"\"Delete the vertices indicated by the given vertex indices.\n\n        The deleted vertices are replaced with vertices from the end of the\n        array (except for deleted vertices that leave no holes because\n        they are already at the end).\n\n        An error can be raised if e.g. the indices are out of bounds.\n        \"\"\"\n\n        # Note: defragmenting when deleting vertices is somewhat\n        # expensive because we also need to update the faces. From a\n        # technical perspective it's fine to have unused vertices, so\n        # we could just leave them as holes, which would likely be faster.\n        # However, the current implementation also has advantages:\n        #\n        # - It works the same as for the faces.\n        # - With a contiguous vertex array it is easy to check if faces are valid.\n        # - No need to select vertices that are in use (e.g. for bounding boxes).\n        # - Getting free slots for vertices is straightforward without\n        #   the need for additional structures like a set of free vertices.\n        # - The vertices and faces can at any moment be copied and be sound.\n\n        vertex2faces = self._vertex2faces\n\n        # --- Prepare / checcks\n\n        indices = check_indices(\n            vertex_indices, len(self._positions), \"vertex indices to delete\"\n        )\n        to_delete = set(indices)\n\n        nverts1 = len(self._positions)\n        nverts2 = nverts1 - len(to_delete)\n\n        to_maybe_move = set(range(nverts2, nverts1))\n        to_just_drop = to_maybe_move & to_delete\n\n        indices1 = list(to_delete - to_just_drop)\n        indices2 = list(to_maybe_move - to_just_drop)\n        assert len(indices1) == len(indices2), \"Internal error\"\n\n        # Check that none of the vertices are in use. Note that this\n        # check is done in pop_vertices, but we also perform it here\n        # to avoid swapping faces when the test fails (keep it atomic).\n        # The overhead for doing the test twice is not that bad.\n        if any(len(vertex2faces[vi]) > 0 for vi in to_delete):\n            raise ValueError(\"Vertex to delete is in use.\")\n\n        # --- Apply\n\n        # Do a move, so all vertices to delete are at the end\n        if len(indices1):\n            self.swap_vertices(indices1, indices2)\n\n        # Pop from the end\n        self.pop_vertices(len(to_delete))\n\n    # %% The core API\n\n    def add_faces(self, new_faces):\n        \"\"\"Add the given faces to the mesh.\n\n        The faces must reference existing vertices.\n        \"\"\"\n        vertex2faces = self._vertex2faces\n\n        # --- Prepare / checks\n\n        # Check incoming array\n        faces = np.asarray(new_faces, np.int32).reshape(-1, self._verts_per_face)\n        # It's fine for the mesh to have zero faces, but it's likely\n        # an error if the user calls this with an empty array.\n        if len(faces) == 0:\n            raise ValueError(\"Cannot add zero faces.\")\n        # Check sanity of the faces\n        if faces.min() < 0 or faces.max() >= len(self._positions):\n            raise ValueError(\n                \"The faces array containes indices that are out of bounds.\"\n            )\n\n        n = len(faces)\n        n1 = len(self._faces)\n        indices = np.arange(n1, n1 + n, dtype=np.int32)\n\n        # --- Apply\n\n        try:\n            self._allocate_faces(n)\n            self._faces[n1:] = faces\n            self._update_face_normals(indices)\n\n            # Update reverse map\n            for i, face in enumerate(faces):\n                fi = i + n1\n                vertex2faces[face[0]].append(fi)\n                vertex2faces[face[1]].append(fi)\n                vertex2faces[face[2]].append(fi)\n\n        except Exception:  # pragma: no cover\n            logger.warn(EXCEPTION_IN_ATOMIC_CODE)\n            raise\n\n        # --- Notify\n\n        self._cache_depending_on_faces = {}\n        self._cache_depending_on_verts_and_faces = {}\n        for tracker in self._change_trackers.values():\n            with Safecall():\n                tracker.add_faces(faces)\n        self._after_change()\n\n    def pop_faces(self, n, _old=None):\n        \"\"\"Remove the last n faces from the mesh.\"\"\"\n        vertex2faces = self._vertex2faces\n\n        # --- Prepare / checks\n\n        n = int(n)\n        if n <= 0:\n            raise ValueError(\"Number of faces to pop must be larger than zero.\")\n        if n > len(self._faces):\n            raise ValueError(\n                \"Number of faces to pop is larger than the total number of faces.\"\n            )\n\n        nfaces1 = len(self.faces)\n        nfaces2 = nfaces1 - n\n\n        # --- Apply\n\n        old_faces = self._faces[nfaces2:].copy()\n\n        try:\n            # Update reverse map. If over half the faces are removed,\n            # its faster to re-build verte2faces from scratch after\n            # de-allocating the faces, but only by a bit, so lets not.\n            for fi in range(nfaces2, nfaces1):\n                face = self._faces[fi]\n                vertex2faces[face[0]].remove(fi)\n                vertex2faces[face[1]].remove(fi)\n                vertex2faces[face[2]].remove(fi)\n\n            # Adjust the array lengths (reset views)\n            self._deallocate_faces(n)\n\n        except Exception:  # pragma: no cover\n            logger.warn(EXCEPTION_IN_ATOMIC_CODE)\n            raise\n\n        # --- Notify\n\n        self._cache_depending_on_faces = {}\n        self._cache_depending_on_verts_and_faces = {}\n        for tracker in self._change_trackers.values():\n            with Safecall():\n                tracker.pop_faces(n, old_faces)\n        self._after_change()\n\n    def swap_faces(self, face_indices1, face_indices2):\n        \"\"\"Swap the faces indicated by the given indices.\n\n        This method is public, but likely not generally useful by\n        itself. The ``delete_faces()`` method is a convenience\n        combination of ``swap_faces()`` and ``pop_faces()``.\n        \"\"\"\n\n        # Technically this can also be done with update_faces, but\n        # swapping is faster and costs significantly less memory in\n        # e.g. an undo stack.\n\n        vertex2faces = self._vertex2faces\n\n        # --- Prepare / checks\n\n        indices1 = check_indices(\n            face_indices1, len(self._faces), \"face indices to swap (1)\"\n        )\n        indices2 = check_indices(\n            face_indices2, len(self._faces), \"face indices to swap (2)\"\n        )\n\n        if not len(indices1) == len(indices2):\n            raise ValueError(\"Both index arrays must have the same length.\")\n\n        # --- Apply\n\n        try:\n            # Update reverse map (unrolled loops for small performance bump)\n            for fi1, fi2 in zip(indices1, indices2):\n                face1 = self._faces[fi1]\n                fii = vertex2faces[face1[0]]\n                fii.remove(fi1)\n                fii.append(fi2)\n                fii = vertex2faces[face1[1]]\n                fii.remove(fi1)\n                fii.append(fi2)\n                fii = vertex2faces[face1[2]]\n                fii.remove(fi1)\n                fii.append(fi2)\n                face2 = self._faces[fi2]\n                fii = vertex2faces[face2[0]]\n                fii.remove(fi2)\n                fii.append(fi1)\n                fii = vertex2faces[face2[1]]\n                fii.remove(fi2)\n                fii.append(fi1)\n                fii = vertex2faces[face2[2]]\n                fii.remove(fi2)\n                fii.append(fi1)\n\n            # Swap the faces themselves\n            for a in [self._faces, self._faces_normals]:\n                a[indices1], a[indices2] = a[indices2], a[indices1]\n\n        except Exception:  # pragma: no cover\n            logger.warn(EXCEPTION_IN_ATOMIC_CODE)\n            raise\n\n        # --- Notify\n\n        self._cache_depending_on_faces = {}\n        self._cache_depending_on_verts_and_faces = {}\n        for tracker in self._change_trackers.values():\n            with Safecall():\n                tracker.swap_faces(indices1, indices2)\n        self._after_change()\n\n    def update_faces(self, face_indices, new_faces, _old=None):\n        \"\"\"Update the value of the given faces.\"\"\"\n\n        vertex2faces = self._vertex2faces\n\n        # --- Prepare / checks\n\n        indices = check_indices(\n            face_indices, len(self._faces), \"face indices to update\"\n        )\n        faces = np.asarray(new_faces, np.int32).reshape(-1, self._verts_per_face)\n\n        if len(indices) != len(faces):\n            raise ValueError(\"Indices and faces to update have different lengths.\")\n\n        # Check sanity of the faces\n        if faces.min() < 0 or faces.max() >= len(self._positions):\n            raise ValueError(\n                \"The faces array containes indices that are out of bounds.\"\n            )\n\n        # --- Apply\n\n        old_faces = self._faces[indices]\n\n        try:\n            # Update reverse map\n            for fi, new_face in zip(indices, faces):\n                old_face = self._faces[fi]\n                vertex2faces[old_face[0]].remove(fi)\n                vertex2faces[old_face[1]].remove(fi)\n                vertex2faces[old_face[2]].remove(fi)\n                vertex2faces[new_face[0]].append(fi)\n                vertex2faces[new_face[1]].append(fi)\n                vertex2faces[new_face[2]].append(fi)\n\n            # Update\n            self._faces[indices] = faces\n            self._update_face_normals(indices)\n\n        except Exception:  # pragma: no cover\n            logger.warn(EXCEPTION_IN_ATOMIC_CODE)\n            raise\n\n        # --- Notify\n\n        self._cache_depending_on_faces = {}\n        self._cache_depending_on_verts_and_faces = {}\n        for tracker in self._change_trackers.values():\n            with Safecall():\n                tracker.update_faces(indices, faces, old_faces)\n        self._after_change()\n\n    def add_vertices(self, new_positions):\n        \"\"\"Add the given vertices to the mesh.\"\"\"\n        vertex2faces = self._vertex2faces\n\n        # --- Prepare / checks\n\n        # Check incoming array\n        positions = np.asarray(new_positions, np.float32).reshape(-1, 3)\n        if len(positions) == 0:\n            raise ValueError(\"Cannot add zero vertices.\")\n\n        n = len(positions)\n        n1 = len(self._positions)\n\n        # --- Apply\n\n        try:\n            self._allocate_vertices(n)\n            self._positions[n1:] = positions\n\n            # Update reverse map\n            vertex2faces.extend([] for i in range(n))\n\n        except Exception:  # pragma: no cover\n            logger.warn(EXCEPTION_IN_ATOMIC_CODE)\n            raise\n\n        # --- Notify\n\n        self._cache_depending_on_verts = {}\n        self._cache_depending_on_verts_and_faces = {}\n        for tracker in self._change_trackers.values():\n            with Safecall():\n                tracker.add_vertices(positions)\n        self._after_change()\n\n    def pop_vertices(self, n, _old=None):\n        \"\"\"Remove the last n vertices from the mesh.\"\"\"\n        vertex2faces = self._vertex2faces\n\n        # --- Prepare / checks\n\n        n = int(n)\n        if n <= 0:\n            raise ValueError(\"Number of vertices to pop must be larger than zero.\")\n        if n > len(self._positions):\n            raise ValueError(\n                \"Number of vertices to pop is larger than the total number of vertices.\"\n            )\n\n        nverts1 = len(self._positions)\n        nverts2 = nverts1 - n\n\n        # Check that none of the vertices are in use.\n        if any(len(vertex2faces[vi]) > 0 for vi in range(nverts2, nverts1)):\n            raise ValueError(\"Vertex to delete is in use.\")\n\n        # --- Apply\n\n        old_positions = self._positions[nverts2:].copy()\n\n        try:\n            # Drop unused vertices at the end\n            self._deallocate_vertices(nverts1 - nverts2)\n\n            # Update reverse map\n            vertex2faces[nverts2:] = []\n\n        except Exception:  # pragma: no cover\n            logger.warn(EXCEPTION_IN_ATOMIC_CODE)\n            raise\n\n        # --- Notify\n\n        self._cache_depending_on_verts = {}\n        self._cache_depending_on_verts_and_faces = {}\n        for tracker in self._change_trackers.values():\n            with Safecall():\n                tracker.pop_vertices(n, old_positions)\n        self._after_change()\n\n    def swap_vertices(self, vertex_indices1, vertex_indices2):\n        \"\"\"Move the vertices indicated by the given indices.\n\n        This method is public, but likely not generally useful by\n        itself. The ``delete_vertices()`` method is a convenience\n        combination of ``swap_vertices()`` and ``pop_vertices()``.\n        \"\"\"\n\n        vertex2faces = self._vertex2faces\n\n        # --- Prepare / checks\n\n        indices1 = check_indices(\n            vertex_indices1, len(self._positions), \"vertex indices to swap (1)\"\n        )\n        indices2 = check_indices(\n            vertex_indices2, len(self._positions), \"vertex indices to swap (2)\"\n        )\n\n        if not len(indices1) == len(indices2):\n            raise ValueError(\"Both index arrays must have the same length.\")\n\n        # --- Apply\n\n        try:\n            # Swap the vertices themselves\n            for a in [self._positions, self._normals]:\n                a[indices1], a[indices2] = a[indices2], a[indices1]\n\n            # Update the faces that refer to the moved indices\n            faces = self._faces\n            for vi1, vi2 in zip(indices1, indices2):\n                mask1 = faces == vi1\n                mask2 = faces == vi2\n                faces[mask2] = vi1\n                faces[mask1] = vi2\n\n            # Update reverse map\n            for vi1, vi2 in zip(indices1, indices2):\n                vertex2faces[vi1], vertex2faces[vi2] = (\n                    vertex2faces[vi2],\n                    vertex2faces[vi1],\n                )\n\n        except Exception:  # pragma: no cover\n            logger.warn(EXCEPTION_IN_ATOMIC_CODE)\n            raise\n\n        # --- Notify\n\n        self._cache_depending_on_verts = {}\n        self._cache_depending_on_verts_and_faces = {}\n        for tracker in self._change_trackers.values():\n            with Safecall():\n                tracker.swap_vertices(indices1, indices2)\n        self._after_change()\n\n    def update_vertices(self, vertex_indices, new_positions, _old=None):\n        \"\"\"Update the value of the given vertices.\"\"\"\n\n        vertex2faces = self._vertex2faces\n\n        # --- Prepare / checks\n\n        indices = check_indices(\n            vertex_indices, len(self._positions), \"vertex indices to update\"\n        )\n        positions = np.asarray(new_positions, np.float32).reshape(-1, 3)\n\n        if len(indices) != len(positions):\n            raise ValueError(\"Indices and positions to update have different lengths.\")\n\n        # --- Apply\n\n        old_positions = self._positions[indices]\n\n        try:\n            self._positions[indices] = positions\n\n            # Note: if the number of changed vertices is large (say 50% or more)\n            # it'd probably be more efficient to collect face_indices via a mask.\n            face_indices = set()\n            for vi in indices:\n                face_indices.update(vertex2faces[vi])\n            self._update_face_normals(list(face_indices))\n\n        except Exception:  # pragma: no cover\n            logger.warn(EXCEPTION_IN_ATOMIC_CODE)\n            raise\n\n        # --- Notify\n\n        self._cache_depending_on_verts = {}\n        self._cache_depending_on_verts_and_faces = {}\n        for tracker in self._change_trackers.values():\n            with Safecall():\n                tracker.update_vertices(indices, positions, old_positions)\n        self._after_change()", "\nclass BaseDynamicMesh:\n    \"\"\"A mesh object that can be modified in-place.\n\n    It manages buffers that are oversized so the vertex and face array\n    can grow. When the buffer is full, a larger buffer is allocated.\n    The exposed arrays are contiguous views onto these buffers.\n\n    It also maintains a vertex2faces incidence map, and keeps the vertex\n    normals up to date. It can notify other object of changes, so that\n    any representation of the mesh  (e.g. a visualization on the GPU)\n    can be kept in sync.\n    \"\"\"\n\n    # We assume meshes with triangles (not quads).\n    # Note that there are a few places where loops are unrolled, and verts_per_face is thus hardcoded.\n    _verts_per_face = 3\n\n    def __init__(self):\n        # Caches that subclasses can use to cache stuff. When the\n        # positions/faces change, the respective caches are cleared.\n        self._cache_depending_on_verts = {}\n        self._cache_depending_on_faces = {}\n        self._cache_depending_on_verts_and_faces = {}\n\n        # A list of trackers that are notified of changes.\n        self._change_trackers = weakref.WeakValueDictionary()\n\n        # Create the buffers that contain the data, and which are larger\n        # than needed. These arrays should *only* be referenced in the\n        # allocate- and deallocate- methods.\n        self._faces_buf = np.zeros((8, self._verts_per_face), np.int32)\n        self._faces_normals_buf = np.zeros((8, 3), np.float32)\n        self._positions_buf = np.zeros((8, 3), np.float32)\n        self._normals_buf = np.zeros((8, 3), np.float32)\n\n        # We set unused positions to nan, so that code that uses the\n        # full buffer does not accidentally use invalid vertex positions.\n        self._positions_buf.fill(np.nan)\n\n        # Create faces array views. The internals operate on the ._faces array,\n        # because the public .faces is readonly\n        self._faces = self._faces_buf[:0]\n        self._faces_normals = self._faces_normals_buf[:0]\n\n        # The vertex array views. Not much harm can be done to these.\n        self._positions = self._positions_buf[:0]\n        self._normals = self._normals_buf[:0]\n\n        # Reverse map\n        # This array is jagged, because the number of faces incident\n        # to one vertex can potentially be big (e.g. the top and bottom\n        # of a sphere sampled in lon/lat directions). We could use a\n        # numpy array of lists, which has the advantage that you can\n        # do `vertex2faces[multiple_indices].sum()`. However, benchmarks\n        # show that this is *slower* than a simple list of lists. A\n        # list of sets could also work, but is slightly slower.\n        #\n        # Other data structures are also possibe, e.g. one based on\n        # shifts. These structures can be build faster, but using them\n        # is slower due to the extra indirection.\n        self._vertex2faces = []  # vi -> [fi1, fi2, ..]\n\n    @property\n    def faces(self):\n        \"\"\"The faces of the mesh.\n\n        This is a C-contiguous readonly ndarray. Note that the array\n        may change as data is added and deleted, including faces being\n        moved arround to fill holes left by deleted faces.\n        \"\"\"\n        return as_immutable_array(self._faces)\n\n    @property\n    def positions(self):\n        \"\"\"The vertex positions of the mesh.\n\n        See note on ``.faces`` for details.\n        \"\"\"\n        return as_immutable_array(self._positions)\n\n    @property\n    def normals(self):\n        \"\"\"The vertex normals of the mesh.\n\n        See note on ``.faces`` for details.\n        \"\"\"\n        return as_immutable_array(self._normals)\n\n    @property\n    def vertex2faces(self):\n        \"\"\"Maps vertex indices to a list of face indices.\n\n        This map can be used to e.g. traverse the mesh over its surface.\n\n        Although technically the map is a list that can be modified in\n        place, you should really not do that. Note that each element\n        lists face indices in arbitrary order and may contain duplicate\n        face indices.\n        \"\"\"\n        return self._vertex2faces\n\n    def track_changes(self, tracker, *, remove=False):\n        \"\"\"Track changes using a MeshChangeTracker object.\n\n        The given object is notified of updates of this mesh. If\n        ``remove`` is True, the tracker is removed instead.\n        \"\"\"\n        if not isinstance(tracker, MeshChangeTracker):\n            raise TypeError(\"Expected a MeshChangeTracker subclass.\")\n        self._change_trackers.pop(id(tracker), None)\n        if not remove:\n            self._change_trackers[id(tracker)] = tracker\n            # Init the tracker state so it starts up-to-date\n            with Safecall():\n                tracker.init(self)\n\n    def export(self):\n        \"\"\"Get a copy of the array of vertex-positions and faces.\n\n        Note that the arrays are copied because the originals are\n        modified in place when e.g. faces are removed or updated.\n        \"\"\"\n        return self.positions.copy(), self.faces.copy()\n\n    def check_internal_state(self):\n        \"\"\"Method to validate the integrity of the internal state.\n\n        In practice this check is not be needed, but it's used\n        extensively during the unit tests to make sure that all methods\n        work as intended.\n        \"\"\"\n\n        # Note: some vertices not being used is technically an ok state.\n        # It is also unavoidable, because one first adds vertices and\n        # then the faces to use them. But a bug in our internals could\n        # make the number of unused vertices grow, so maybe we'll want\n        # some sort of check for it at some point.\n        nverts = len(self.positions)\n        nfaces = len(self.faces)\n\n        # Check that all faces match a vertex\n        if nfaces > 0:\n            assert self.faces.min() >= 0\n            assert self.faces.max() < nverts\n\n        # Check sizes of arrays\n        assert len(self._faces) == nfaces\n        assert len(self._faces_normals) == nfaces\n        assert len(self._positions) == nverts\n        assert len(self._normals) == nverts\n\n        # Check that the views are based on the corresppnding buffers\n        assert self._faces.base is self._faces_buf\n        assert self._faces_normals.base is self._faces_normals_buf\n        assert self._positions.base is self._positions_buf\n        assert self._normals.base is self._normals_buf\n\n        # Check vertex2faces map\n        vertex2faces = make_vertex2faces(self.faces, nverts)\n        assert len(vertex2faces) == len(self._vertex2faces)\n        for face1, face2 in zip(vertex2faces, self._vertex2faces):\n            assert sorted(face1) == sorted(face2)\n\n    def _after_change(self):\n        \"\"\"Called after each change. Does nothing by default, but subclasses can overload this.\"\"\"\n        pass\n\n    # %% Manage normals\n\n    def _update_face_normals(self, face_indices):\n        \"\"\"Update the selected face normals.\"\"\"\n        face_indices = np.asarray(face_indices, np.int32)\n        faces = self._faces[face_indices]\n        positions = self._positions\n\n        r1 = positions[faces[:, 0], :]\n        r2 = positions[faces[:, 1], :]\n        r3 = positions[faces[:, 2], :]\n        face_normals = np.cross((r2 - r1), (r3 - r1))  # assumes CCW\n        # faces_areas = 0.5 * np.linalg.norm(face_normals, axis=1)\n\n        self._faces_normals[face_indices] = face_normals\n\n        # The thing with vertex normals is that they depend on all\n        # incident faces, so doing a partial update is tricky.\n        # * We could first undo the contribution of the selected faces. E.g.\n        #   using a list of dicts: vi -> fi -> normals. Likely slow.\n        # * Or we first select the vertex_indices (by flattening faces), and use\n        #   vertex2faces to come up with a slightly larger set of face_indices,\n        #   which we then use to update the normals for the vertex_indices (and more)\n        #   and then only update vertex_indices. Also likely slow.\n        # * Only update the face normals and vertex normals of connected components.\n        # * Or we just update all vertex normals, but notify trackers\n        #   with the indices of vertices who's normal actually changed.\n        # * Note: we could implement some form of lazy computation for the\n        #   normals, or an option to turn all this off if no normals are needed.\n        self._update_vertex_normals()\n\n        # Get indices of vertices who's normal changed\n        vertex_mask = np.zeros((len(self._positions),), bool)\n        vertex_mask[faces.flatten()] = True\n        vertex_indices = np.where(vertex_mask)[0]\n\n        # Pass on the update\n        for tracker in self._change_trackers.values():\n            with Safecall():\n                tracker.update_normals(vertex_indices)\n\n    def _update_vertex_normals(self):\n        \"\"\"Update all vertex normals.\"\"\"\n        vertex_normals = self._normals\n        vertex_normals.fill(0.0)\n        for i in range(3):\n            np.add.at(vertex_normals, self._faces[:, i], self._faces_normals)\n\n        norms = np.linalg.norm(vertex_normals, axis=1)\n\n        (zeros,) = np.where(norms == 0)\n        norms[zeros] = 1.0  # prevent divide-by-zero\n        vertex_normals /= norms[:, np.newaxis]\n        vertex_normals[zeros] = 0.0\n\n    # %% Allocation and de-allocation of the buffers\n\n    def _allocate_faces(self, n):\n        \"\"\"Increase the size of the faces view to hold n free faces at\n        the end. If necessary the underlying buffer is re-allocated.\n        \"\"\"\n        n = int(n)\n        assert n >= 1\n        nfaces1 = len(self._faces)\n        nfaces2 = nfaces1 + n\n        # Re-allocate buffer?\n        new_buffers = nfaces2 > len(self._faces_buf)\n        if new_buffers:\n            new_size = max(8, nfaces2)\n            new_size = 2 ** int(np.ceil(np.log2(new_size)))\n            self._faces_buf = np.zeros((new_size, self._verts_per_face), np.int32)\n            self._faces_buf[:nfaces1] = self._faces\n            self._faces_normals_buf = np.zeros((new_size, 3), np.float32)\n            self._faces_normals_buf[:nfaces1] = self._faces_normals\n        # Reset views\n        self._faces = self._faces_buf[:nfaces2]\n        self._faces_normals = self._faces_normals_buf[:nfaces2]\n        # Notify\n        if new_buffers:\n            for tracker in self._change_trackers.values():\n                with Safecall():\n                    tracker.new_faces_buffer(self)\n\n    def _deallocate_faces(self, n):\n        \"\"\" \"Decrease the size of the faces view, discarting the n faces\n        at the end. If it makes sense, the underlying buffer is re-allocated.\n        \"\"\"\n        n = int(n)\n        assert n >= 1\n        nfaces = len(self._faces) - n\n        # Re-allocate buffer?\n        new_buffers = nfaces <= 0.25 * len(self._faces_buf) and len(self._faces_buf) > 8\n        if new_buffers:\n            new_size = max(8, nfaces * 2)\n            new_size = 2 ** int(np.ceil(np.log2(new_size)))\n            self._faces_buf = np.zeros((new_size, self._verts_per_face), np.int32)\n            self._faces_buf[:nfaces] = self._faces[:nfaces]\n            self._faces_normals_buf = np.zeros((new_size, 3), np.float32)\n            self._faces_normals_buf[:nfaces] = self._faces_normals[:nfaces]\n        else:\n            # Tidy up\n            self._faces_buf[nfaces:] = 0\n            self._faces_normals_buf[nfaces:] = 0.0\n        # Reset views\n        self._faces = self._faces_buf[:nfaces]\n        self._faces_normals = self._faces_normals_buf[:nfaces]\n        # Notify\n        if new_buffers:\n            for tracker in self._change_trackers.values():\n                with Safecall():\n                    tracker.new_faces_buffer(self)\n\n    def _allocate_vertices(self, n):\n        \"\"\"Increase the vertex views to hold n free vertices at the end. If\n        necessary the underlying buffers are re-allocated.\n        \"\"\"\n        n = int(n)\n        assert n >= 1\n        nverts1 = len(self._positions)\n        nverts2 = nverts1 + n\n        # Re-allocate buffer?\n        new_buffers = nverts2 > len(self._positions_buf)\n        if new_buffers:\n            new_size = max(8, nverts2)\n            new_size = 2 ** int(np.ceil(np.log2(new_size)))\n            self._positions_buf = np.zeros((new_size, 3), np.float32)\n            self._positions_buf[:nverts1] = self._positions\n            self._positions_buf[nverts2:] = np.nan\n            self._normals_buf = np.zeros((new_size, 3), np.float32)\n            self._normals_buf[:nverts1] = self._normals\n        # Reset views\n        self._positions = self._positions_buf[:nverts2]\n        self._normals = self._normals_buf[:nverts2]\n        # Notify\n        if new_buffers:\n            for tracker in self._change_trackers.values():\n                with Safecall():\n                    tracker.new_vertices_buffer(self)\n\n    def _deallocate_vertices(self, n):\n        \"\"\"Decrease the size of the vertices views, discarting the n vertices\n        at the end. If it makes sense, the underlying buffer is re-allocated.\n        \"\"\"\n        n = int(n)\n        assert n >= 1\n        nverts = len(self._positions) - n\n        # Re-allocate buffer?\n        new_buffers = (\n            nverts <= 0.25 * len(self._positions_buf) and len(self._positions_buf) > 8\n        )\n        if new_buffers:\n            new_size = max(8, nverts * 2)\n            new_size = 2 ** int(np.ceil(np.log2(new_size)))\n            self._positions_buf = np.zeros((new_size, 3), np.float32)\n            self._positions_buf[:nverts] = self._positions[:nverts]\n            self._positions_buf[nverts:] = np.nan\n            self._normals_buf = np.zeros((new_size, 3), np.float32)\n            self._normals_buf[:nverts] = self._normals[:nverts]\n        else:\n            # Tidy up\n            self._positions_buf[nverts:] = np.nan\n            self._normals_buf[nverts:] = 0\n        # Reset views\n        self._positions = self._positions_buf[:nverts]\n        self._normals = self._normals_buf[:nverts]\n        # Notify\n        if new_buffers:\n            for tracker in self._change_trackers.values():\n                with Safecall():\n                    tracker.new_vertices_buffer(self)\n\n    # %% Convenience methods to modify the mesh\n\n    def clear(self):\n        \"\"\"Clear the mesh, removing all vertices and faces.\"\"\"\n        if len(self._faces):\n            self.pop_faces(len(self._faces))\n        if len(self._positions):\n            self.pop_vertices(len(self._positions))\n\n    def reset(self, positions, faces):\n        \"\"\"Reset the vertices and faces, e.g. from an export.\"\"\"\n        self.clear()\n        if positions is not None:\n            self.add_vertices(positions)\n        if faces is not None:\n            self.add_faces(faces)\n\n    def delete_faces(self, face_indices):\n        \"\"\"Delete the faces indicated by the given face indices.\n\n        The deleted faces are replaced with faces from the end of the\n        array (except for deleted faces that leave no holes because\n        they are already at the end).\n\n        An error can be raised if e.g. the indices are out of bounds.\n        \"\"\"\n\n        # --- Prepare / checks\n\n        indices = check_indices(\n            face_indices, len(self._faces), \"face indices to delete\"\n        )\n        to_delete = set(indices)\n\n        nfaces1 = len(self._faces)\n        nfaces2 = nfaces1 - len(to_delete)\n\n        to_maybe_move = set(range(nfaces2, nfaces1))  # these are for filling the holes\n        to_just_drop = to_maybe_move & to_delete  # but some of these may be at the end\n\n        indices1 = list(to_delete - to_just_drop)\n        indices2 = list(to_maybe_move - to_just_drop)\n        assert len(indices1) == len(indices2), \"Internal error\"\n\n        # --- Apply -> delegate\n\n        # Do a move, so all faces to delete are at the end\n        if len(indices1):\n            self.swap_faces(indices1, indices2)\n\n        # Pop from the end\n        self.pop_faces(len(to_delete))\n\n    def delete_vertices(self, vertex_indices):\n        \"\"\"Delete the vertices indicated by the given vertex indices.\n\n        The deleted vertices are replaced with vertices from the end of the\n        array (except for deleted vertices that leave no holes because\n        they are already at the end).\n\n        An error can be raised if e.g. the indices are out of bounds.\n        \"\"\"\n\n        # Note: defragmenting when deleting vertices is somewhat\n        # expensive because we also need to update the faces. From a\n        # technical perspective it's fine to have unused vertices, so\n        # we could just leave them as holes, which would likely be faster.\n        # However, the current implementation also has advantages:\n        #\n        # - It works the same as for the faces.\n        # - With a contiguous vertex array it is easy to check if faces are valid.\n        # - No need to select vertices that are in use (e.g. for bounding boxes).\n        # - Getting free slots for vertices is straightforward without\n        #   the need for additional structures like a set of free vertices.\n        # - The vertices and faces can at any moment be copied and be sound.\n\n        vertex2faces = self._vertex2faces\n\n        # --- Prepare / checcks\n\n        indices = check_indices(\n            vertex_indices, len(self._positions), \"vertex indices to delete\"\n        )\n        to_delete = set(indices)\n\n        nverts1 = len(self._positions)\n        nverts2 = nverts1 - len(to_delete)\n\n        to_maybe_move = set(range(nverts2, nverts1))\n        to_just_drop = to_maybe_move & to_delete\n\n        indices1 = list(to_delete - to_just_drop)\n        indices2 = list(to_maybe_move - to_just_drop)\n        assert len(indices1) == len(indices2), \"Internal error\"\n\n        # Check that none of the vertices are in use. Note that this\n        # check is done in pop_vertices, but we also perform it here\n        # to avoid swapping faces when the test fails (keep it atomic).\n        # The overhead for doing the test twice is not that bad.\n        if any(len(vertex2faces[vi]) > 0 for vi in to_delete):\n            raise ValueError(\"Vertex to delete is in use.\")\n\n        # --- Apply\n\n        # Do a move, so all vertices to delete are at the end\n        if len(indices1):\n            self.swap_vertices(indices1, indices2)\n\n        # Pop from the end\n        self.pop_vertices(len(to_delete))\n\n    # %% The core API\n\n    def add_faces(self, new_faces):\n        \"\"\"Add the given faces to the mesh.\n\n        The faces must reference existing vertices.\n        \"\"\"\n        vertex2faces = self._vertex2faces\n\n        # --- Prepare / checks\n\n        # Check incoming array\n        faces = np.asarray(new_faces, np.int32).reshape(-1, self._verts_per_face)\n        # It's fine for the mesh to have zero faces, but it's likely\n        # an error if the user calls this with an empty array.\n        if len(faces) == 0:\n            raise ValueError(\"Cannot add zero faces.\")\n        # Check sanity of the faces\n        if faces.min() < 0 or faces.max() >= len(self._positions):\n            raise ValueError(\n                \"The faces array containes indices that are out of bounds.\"\n            )\n\n        n = len(faces)\n        n1 = len(self._faces)\n        indices = np.arange(n1, n1 + n, dtype=np.int32)\n\n        # --- Apply\n\n        try:\n            self._allocate_faces(n)\n            self._faces[n1:] = faces\n            self._update_face_normals(indices)\n\n            # Update reverse map\n            for i, face in enumerate(faces):\n                fi = i + n1\n                vertex2faces[face[0]].append(fi)\n                vertex2faces[face[1]].append(fi)\n                vertex2faces[face[2]].append(fi)\n\n        except Exception:  # pragma: no cover\n            logger.warn(EXCEPTION_IN_ATOMIC_CODE)\n            raise\n\n        # --- Notify\n\n        self._cache_depending_on_faces = {}\n        self._cache_depending_on_verts_and_faces = {}\n        for tracker in self._change_trackers.values():\n            with Safecall():\n                tracker.add_faces(faces)\n        self._after_change()\n\n    def pop_faces(self, n, _old=None):\n        \"\"\"Remove the last n faces from the mesh.\"\"\"\n        vertex2faces = self._vertex2faces\n\n        # --- Prepare / checks\n\n        n = int(n)\n        if n <= 0:\n            raise ValueError(\"Number of faces to pop must be larger than zero.\")\n        if n > len(self._faces):\n            raise ValueError(\n                \"Number of faces to pop is larger than the total number of faces.\"\n            )\n\n        nfaces1 = len(self.faces)\n        nfaces2 = nfaces1 - n\n\n        # --- Apply\n\n        old_faces = self._faces[nfaces2:].copy()\n\n        try:\n            # Update reverse map. If over half the faces are removed,\n            # its faster to re-build verte2faces from scratch after\n            # de-allocating the faces, but only by a bit, so lets not.\n            for fi in range(nfaces2, nfaces1):\n                face = self._faces[fi]\n                vertex2faces[face[0]].remove(fi)\n                vertex2faces[face[1]].remove(fi)\n                vertex2faces[face[2]].remove(fi)\n\n            # Adjust the array lengths (reset views)\n            self._deallocate_faces(n)\n\n        except Exception:  # pragma: no cover\n            logger.warn(EXCEPTION_IN_ATOMIC_CODE)\n            raise\n\n        # --- Notify\n\n        self._cache_depending_on_faces = {}\n        self._cache_depending_on_verts_and_faces = {}\n        for tracker in self._change_trackers.values():\n            with Safecall():\n                tracker.pop_faces(n, old_faces)\n        self._after_change()\n\n    def swap_faces(self, face_indices1, face_indices2):\n        \"\"\"Swap the faces indicated by the given indices.\n\n        This method is public, but likely not generally useful by\n        itself. The ``delete_faces()`` method is a convenience\n        combination of ``swap_faces()`` and ``pop_faces()``.\n        \"\"\"\n\n        # Technically this can also be done with update_faces, but\n        # swapping is faster and costs significantly less memory in\n        # e.g. an undo stack.\n\n        vertex2faces = self._vertex2faces\n\n        # --- Prepare / checks\n\n        indices1 = check_indices(\n            face_indices1, len(self._faces), \"face indices to swap (1)\"\n        )\n        indices2 = check_indices(\n            face_indices2, len(self._faces), \"face indices to swap (2)\"\n        )\n\n        if not len(indices1) == len(indices2):\n            raise ValueError(\"Both index arrays must have the same length.\")\n\n        # --- Apply\n\n        try:\n            # Update reverse map (unrolled loops for small performance bump)\n            for fi1, fi2 in zip(indices1, indices2):\n                face1 = self._faces[fi1]\n                fii = vertex2faces[face1[0]]\n                fii.remove(fi1)\n                fii.append(fi2)\n                fii = vertex2faces[face1[1]]\n                fii.remove(fi1)\n                fii.append(fi2)\n                fii = vertex2faces[face1[2]]\n                fii.remove(fi1)\n                fii.append(fi2)\n                face2 = self._faces[fi2]\n                fii = vertex2faces[face2[0]]\n                fii.remove(fi2)\n                fii.append(fi1)\n                fii = vertex2faces[face2[1]]\n                fii.remove(fi2)\n                fii.append(fi1)\n                fii = vertex2faces[face2[2]]\n                fii.remove(fi2)\n                fii.append(fi1)\n\n            # Swap the faces themselves\n            for a in [self._faces, self._faces_normals]:\n                a[indices1], a[indices2] = a[indices2], a[indices1]\n\n        except Exception:  # pragma: no cover\n            logger.warn(EXCEPTION_IN_ATOMIC_CODE)\n            raise\n\n        # --- Notify\n\n        self._cache_depending_on_faces = {}\n        self._cache_depending_on_verts_and_faces = {}\n        for tracker in self._change_trackers.values():\n            with Safecall():\n                tracker.swap_faces(indices1, indices2)\n        self._after_change()\n\n    def update_faces(self, face_indices, new_faces, _old=None):\n        \"\"\"Update the value of the given faces.\"\"\"\n\n        vertex2faces = self._vertex2faces\n\n        # --- Prepare / checks\n\n        indices = check_indices(\n            face_indices, len(self._faces), \"face indices to update\"\n        )\n        faces = np.asarray(new_faces, np.int32).reshape(-1, self._verts_per_face)\n\n        if len(indices) != len(faces):\n            raise ValueError(\"Indices and faces to update have different lengths.\")\n\n        # Check sanity of the faces\n        if faces.min() < 0 or faces.max() >= len(self._positions):\n            raise ValueError(\n                \"The faces array containes indices that are out of bounds.\"\n            )\n\n        # --- Apply\n\n        old_faces = self._faces[indices]\n\n        try:\n            # Update reverse map\n            for fi, new_face in zip(indices, faces):\n                old_face = self._faces[fi]\n                vertex2faces[old_face[0]].remove(fi)\n                vertex2faces[old_face[1]].remove(fi)\n                vertex2faces[old_face[2]].remove(fi)\n                vertex2faces[new_face[0]].append(fi)\n                vertex2faces[new_face[1]].append(fi)\n                vertex2faces[new_face[2]].append(fi)\n\n            # Update\n            self._faces[indices] = faces\n            self._update_face_normals(indices)\n\n        except Exception:  # pragma: no cover\n            logger.warn(EXCEPTION_IN_ATOMIC_CODE)\n            raise\n\n        # --- Notify\n\n        self._cache_depending_on_faces = {}\n        self._cache_depending_on_verts_and_faces = {}\n        for tracker in self._change_trackers.values():\n            with Safecall():\n                tracker.update_faces(indices, faces, old_faces)\n        self._after_change()\n\n    def add_vertices(self, new_positions):\n        \"\"\"Add the given vertices to the mesh.\"\"\"\n        vertex2faces = self._vertex2faces\n\n        # --- Prepare / checks\n\n        # Check incoming array\n        positions = np.asarray(new_positions, np.float32).reshape(-1, 3)\n        if len(positions) == 0:\n            raise ValueError(\"Cannot add zero vertices.\")\n\n        n = len(positions)\n        n1 = len(self._positions)\n\n        # --- Apply\n\n        try:\n            self._allocate_vertices(n)\n            self._positions[n1:] = positions\n\n            # Update reverse map\n            vertex2faces.extend([] for i in range(n))\n\n        except Exception:  # pragma: no cover\n            logger.warn(EXCEPTION_IN_ATOMIC_CODE)\n            raise\n\n        # --- Notify\n\n        self._cache_depending_on_verts = {}\n        self._cache_depending_on_verts_and_faces = {}\n        for tracker in self._change_trackers.values():\n            with Safecall():\n                tracker.add_vertices(positions)\n        self._after_change()\n\n    def pop_vertices(self, n, _old=None):\n        \"\"\"Remove the last n vertices from the mesh.\"\"\"\n        vertex2faces = self._vertex2faces\n\n        # --- Prepare / checks\n\n        n = int(n)\n        if n <= 0:\n            raise ValueError(\"Number of vertices to pop must be larger than zero.\")\n        if n > len(self._positions):\n            raise ValueError(\n                \"Number of vertices to pop is larger than the total number of vertices.\"\n            )\n\n        nverts1 = len(self._positions)\n        nverts2 = nverts1 - n\n\n        # Check that none of the vertices are in use.\n        if any(len(vertex2faces[vi]) > 0 for vi in range(nverts2, nverts1)):\n            raise ValueError(\"Vertex to delete is in use.\")\n\n        # --- Apply\n\n        old_positions = self._positions[nverts2:].copy()\n\n        try:\n            # Drop unused vertices at the end\n            self._deallocate_vertices(nverts1 - nverts2)\n\n            # Update reverse map\n            vertex2faces[nverts2:] = []\n\n        except Exception:  # pragma: no cover\n            logger.warn(EXCEPTION_IN_ATOMIC_CODE)\n            raise\n\n        # --- Notify\n\n        self._cache_depending_on_verts = {}\n        self._cache_depending_on_verts_and_faces = {}\n        for tracker in self._change_trackers.values():\n            with Safecall():\n                tracker.pop_vertices(n, old_positions)\n        self._after_change()\n\n    def swap_vertices(self, vertex_indices1, vertex_indices2):\n        \"\"\"Move the vertices indicated by the given indices.\n\n        This method is public, but likely not generally useful by\n        itself. The ``delete_vertices()`` method is a convenience\n        combination of ``swap_vertices()`` and ``pop_vertices()``.\n        \"\"\"\n\n        vertex2faces = self._vertex2faces\n\n        # --- Prepare / checks\n\n        indices1 = check_indices(\n            vertex_indices1, len(self._positions), \"vertex indices to swap (1)\"\n        )\n        indices2 = check_indices(\n            vertex_indices2, len(self._positions), \"vertex indices to swap (2)\"\n        )\n\n        if not len(indices1) == len(indices2):\n            raise ValueError(\"Both index arrays must have the same length.\")\n\n        # --- Apply\n\n        try:\n            # Swap the vertices themselves\n            for a in [self._positions, self._normals]:\n                a[indices1], a[indices2] = a[indices2], a[indices1]\n\n            # Update the faces that refer to the moved indices\n            faces = self._faces\n            for vi1, vi2 in zip(indices1, indices2):\n                mask1 = faces == vi1\n                mask2 = faces == vi2\n                faces[mask2] = vi1\n                faces[mask1] = vi2\n\n            # Update reverse map\n            for vi1, vi2 in zip(indices1, indices2):\n                vertex2faces[vi1], vertex2faces[vi2] = (\n                    vertex2faces[vi2],\n                    vertex2faces[vi1],\n                )\n\n        except Exception:  # pragma: no cover\n            logger.warn(EXCEPTION_IN_ATOMIC_CODE)\n            raise\n\n        # --- Notify\n\n        self._cache_depending_on_verts = {}\n        self._cache_depending_on_verts_and_faces = {}\n        for tracker in self._change_trackers.values():\n            with Safecall():\n                tracker.swap_vertices(indices1, indices2)\n        self._after_change()\n\n    def update_vertices(self, vertex_indices, new_positions, _old=None):\n        \"\"\"Update the value of the given vertices.\"\"\"\n\n        vertex2faces = self._vertex2faces\n\n        # --- Prepare / checks\n\n        indices = check_indices(\n            vertex_indices, len(self._positions), \"vertex indices to update\"\n        )\n        positions = np.asarray(new_positions, np.float32).reshape(-1, 3)\n\n        if len(indices) != len(positions):\n            raise ValueError(\"Indices and positions to update have different lengths.\")\n\n        # --- Apply\n\n        old_positions = self._positions[indices]\n\n        try:\n            self._positions[indices] = positions\n\n            # Note: if the number of changed vertices is large (say 50% or more)\n            # it'd probably be more efficient to collect face_indices via a mask.\n            face_indices = set()\n            for vi in indices:\n                face_indices.update(vertex2faces[vi])\n            self._update_face_normals(list(face_indices))\n\n        except Exception:  # pragma: no cover\n            logger.warn(EXCEPTION_IN_ATOMIC_CODE)\n            raise\n\n        # --- Notify\n\n        self._cache_depending_on_verts = {}\n        self._cache_depending_on_verts_and_faces = {}\n        for tracker in self._change_trackers.values():\n            with Safecall():\n                tracker.update_vertices(indices, positions, old_positions)\n        self._after_change()", ""]}
{"filename": "gfxmorph/__init__.py", "chunked_list": ["from .basedynamicmesh import BaseDynamicMesh  # noqa: F401\nfrom .mesh import DynamicMesh  # noqa: F401\nfrom .tracker import MeshChangeTracker, MeshLogger, MeshUndoTracker  # noqa: F401\nfrom . import meshfuncs  # noqa: F401\n\n\n__version__ = \"0.0.1\"\nversion_info = tuple(map(int, __version__.split(\".\")))\n", ""]}
{"filename": "gfxmorph/utils.py", "chunked_list": ["import logging\nimport traceback\n\nimport numpy as np\n\n\nlogger = logging.getLogger(\"meshmorph\")\n\n\nclass Safecall:\n    \"\"\"Context manager for doing calls that should not raise. If an exception\n    is raised, it is caught, logged, and the context exits normally.\n    \"\"\"\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if exc_val:\n            lines = traceback.format_exception(exc_type, exc_val, exc_tb)\n            logger.error(\"Exception in update callback:\\n\" + \"\".join(lines))\n        return True  # Yes, we handled the exception", "\nclass Safecall:\n    \"\"\"Context manager for doing calls that should not raise. If an exception\n    is raised, it is caught, logged, and the context exits normally.\n    \"\"\"\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if exc_val:\n            lines = traceback.format_exception(exc_type, exc_val, exc_tb)\n            logger.error(\"Exception in update callback:\\n\" + \"\".join(lines))\n        return True  # Yes, we handled the exception", "\n\ndef check_indices(indices, n, what_for):\n    \"\"\"Check indices and convert to an in32 array (if necessary).\"\"\"\n    result = None\n    typ = type(indices).__name__\n    if isinstance(indices, int):\n        result = [indices]\n    elif isinstance(indices, list):\n        result = indices\n    elif isinstance(indices, np.ndarray):\n        typ = \"ndarray:\" + \"x\".join(str(x) for x in indices.shape)\n        typ += \"x\" + indices.dtype.name\n        if indices.size == 0:\n            result = []\n        elif indices.ndim == 1 and indices.dtype.kind == \"i\":\n            result = indices\n\n    if result is None:\n        raise TypeError(\n            f\"The {what_for} must be given as int, list, or 1D int array, not {typ}.\"\n        )\n    result = np.asarray(result, np.int32)\n    if len(result) == 0:\n        raise ValueError(f\"The {what_for} must not be empty.\")\n    elif result.min() < 0:\n        raise ValueError(\"Negative indices not allowed.\")\n    elif result.max() >= n:\n        raise ValueError(\"Index out of bounds.\")\n\n    return result", "\n\ndef as_immutable_array(array):\n    \"\"\"Return a read-only view of the given array.\"\"\"\n    v = array.view()\n    v.setflags(write=False)\n    return v\n\n\ndef make_vertex2faces(faces, nverts=None):\n    \"\"\"Create a simple map to map vertex indices to a list of face indices.\"\"\"\n    faces = np.asarray(faces, np.int32)\n    if nverts is None:\n        nverts = faces.max() + 1\n\n    vertex2faces = [[] for _ in range(nverts)]\n    for fi in range(len(faces)):\n        face = faces[fi]\n        vertex2faces[face[0]].append(fi)\n        vertex2faces[face[1]].append(fi)\n        vertex2faces[face[2]].append(fi)\n    return vertex2faces", "\ndef make_vertex2faces(faces, nverts=None):\n    \"\"\"Create a simple map to map vertex indices to a list of face indices.\"\"\"\n    faces = np.asarray(faces, np.int32)\n    if nverts is None:\n        nverts = faces.max() + 1\n\n    vertex2faces = [[] for _ in range(nverts)]\n    for fi in range(len(faces)):\n        face = faces[fi]\n        vertex2faces[face[0]].append(fi)\n        vertex2faces[face[1]].append(fi)\n        vertex2faces[face[2]].append(fi)\n    return vertex2faces", ""]}
{"filename": "gfxmorph/meshfuncs.py", "chunked_list": ["import queue\n\nimport numpy as np\n\nfrom . import maybe_pylinalg\nfrom .utils import make_vertex2faces\n\n\ndef vertex_get_neighbours(faces, vertex2faces, vi):\n    \"\"\"Get a set of vertex indices that neighbour the given vertex index.\n\n    Connectedness is via the edges.\n    \"\"\"\n    neighbour_vertices = set()\n    for fi in vertex2faces[vi]:\n        neighbour_vertices.update(faces[fi])\n    neighbour_vertices.remove(vi)\n    return neighbour_vertices", "def vertex_get_neighbours(faces, vertex2faces, vi):\n    \"\"\"Get a set of vertex indices that neighbour the given vertex index.\n\n    Connectedness is via the edges.\n    \"\"\"\n    neighbour_vertices = set()\n    for fi in vertex2faces[vi]:\n        neighbour_vertices.update(faces[fi])\n    neighbour_vertices.remove(vi)\n    return neighbour_vertices", "\n\ndef face_get_neighbours1(faces, vertex2faces, fi):\n    \"\"\"Get a set of face indices that neighbour the given face index.\n\n    Connectedness is either via an edge or via a vertex.\n    \"\"\"\n    neighbour_faces = set()\n    for vi in faces[fi]:\n        neighbour_faces.update(vertex2faces[vi])\n    neighbour_faces.remove(fi)\n    return neighbour_faces", "\n\ndef face_get_neighbours2(faces, vertex2faces, fi):\n    \"\"\"Get two sets of face indices that neighbour the given face index.\n\n    The first comprises of both vertex- and edge connections, the second\n    only consists of faces connected via an edge.\n    \"\"\"\n    neighbour_faces1 = set()\n    neighbour_faces2 = set()\n    for vi in faces[fi]:\n        for fi2 in vertex2faces[vi]:\n            if fi2 == fi:\n                pass\n            elif fi2 in neighbour_faces1:\n                neighbour_faces2.add(fi2)\n            else:\n                neighbour_faces1.add(fi2)\n    return neighbour_faces1, neighbour_faces2", "\n\ndef vertex_get_incident_face_groups(\n    faces, vertex2faces, vi_check, *, face_adjacency=None\n):\n    \"\"\"Get the groups of faces incident to the given vertex.\n\n    If there are zero groups, the vertex has no incident faces. If there\n    is exactly one group, the faces incident to the given vertex form\n    a (closed or open) fan. If there is more than one group, the mesh\n    is not manifold (and can be repaired by duplicating this vertex for\n    each group).\n    \"\"\"\n\n    #\n    #   Diagram 1           Diagram 2\n    #   _________                ____\n    #  |\\       /|              |   /|\n    #  | \\  D  / |              |D / |\n    #  |  \\   /  |              | /  |\n    #  |   \\ /   |              |/ C |\n    #  | B  O  C |              O----|\n    #  |   / \\   |              |\\ B |\n    #  |  /   \\  |              | \\  |\n    #  | /  A  \\ |              |A \\ |\n    #  |/_______\\|              |___\\|\n    #\n    #\n    #   Diagram 3           Diagram 4\n    #   _________                ____\n    #  |\\       /|              |   /|\n    #  | \\  D  / | _      _     |D / |\n    #  |  \\   / _|- |    | -._  | /  |\n    #  |   \\ /.- | E|    |E   -.|/ C |\n    #  | B  O----|--|    |------O----|\n    #  |   / \\ C |              |\\ B |\n    #  |  /   \\  |              | \\  |\n    #  | /  A  \\ |              |A \\ |\n    #  |/_______\\|              |___\\|\n    #\n    #\n    # In the two diagrams above, the vertex indicated by the big O is\n    # the reference vertex. On the left (diagram 1 and 3) we see a\n    # closed fan, and on the right (diagram 2 and 4) an open fan. In\n    # the top diagrams all is well, but in the bottom diagrams (3 and\n    # 4) there is an additional face E attached to the vertex, breaking\n    # the vertex-manifold condition. Note that it does not matter\n    # whether E is a lose vertex, part of a strip, or part of an\n    # (otherwise) manifold and closed component. Note also that E can\n    # even be a face on the same component that faces a-d are part of.\n    # That component can still be edge-manifold, closed, and oriented.\n\n    # Note that the algorithm below does not detect duplicate faces or\n    # edges with 3 incident faces. Therefore, to be be vertex-manifold,\n    # a mesh must *also* be edge-manifold.\n\n    faces_to_check = set(vertex2faces[vi_check])\n    groups = []\n\n    while faces_to_check:\n        group = []\n        groups.append(group)\n        fi_next = faces_to_check.pop()\n        front = queue.deque()\n        front.append(fi_next)\n        while front:\n            fi_check = front.popleft()\n            group.append(fi_check)\n            if face_adjacency is not None:\n                neighbour_faces2 = face_adjacency[fi_check]\n            else:\n                _, neighbour_faces2 = face_get_neighbours2(\n                    faces, vertex2faces, fi_check\n                )\n            for fi in neighbour_faces2:\n                if fi in faces_to_check:\n                    faces_to_check.remove(fi)\n                    front.append(fi)\n    return groups", "\n\ndef mesh_is_edge_manifold_and_closed(faces):\n    \"\"\"Check whether the mesh is edge-manifold, and whether it is closed.\n\n    This implementation is based on vectorized numpy code and therefore very fast.\n    \"\"\"\n\n    # Special case\n    if len(faces) == 0:\n        return True, True\n\n    # Select edges\n    edges = faces[:, [[0, 1], [1, 2], [2, 0]]]\n    edges = edges.reshape(-1, 2)\n    edges.sort(axis=1)  # note, sorting!\n\n    # This line is the performance bottleneck. It is not worth\n    # combining this method with e.g. check_oriented, because this\n    # line needs to be applied to different data, so the gain would\n    # be about zero.\n    edges_blob = np.frombuffer(edges, dtype=\"V8\")  # performance trick\n    unique_blob, edge_counts = np.unique(edges_blob, return_counts=True)\n\n    # The mesh is edge-manifold if edges are shared at most by 2 faces.\n    is_edge_manifold = bool(edge_counts.max() <= 2)\n\n    # The mesh is closed if it has no edges incident to just once face.\n    # The following is equivalent to np.all(edge_counts == 2)\n    is_closed = is_edge_manifold and bool(edge_counts.min() == 2)\n\n    return is_edge_manifold, is_closed", "\n\ndef mesh_get_non_manifold_edges(faces):\n    \"\"\"Detect non-manifold edges.\n\n    These are returned as a dict ``(vi1, vi2) -> [fi1, fi2, ..]``.\n    It maps edges (pairs of vertex indices) to a list face indices incident\n    to that edge. I.e. to repair the edge, the faces incidense to each\n    edge can be removed. Afterwards, the nonmanifold vertices can be repaired,\n    followed by repairing the holes.\n\n    If the returned dictionary is empty, the mesh is edge-manifold. In\n    other words, for each edge there are either one or two incident\n    faces.\n    \"\"\"\n\n    # Special case\n    if len(faces) == 0:\n        return {}\n\n    edges = faces[:, [[0, 1], [1, 2], [2, 0]]]\n    edges = edges.reshape(-1, 2)\n    edges.sort(axis=1)  # note, sorting!\n\n    edges_blob = np.frombuffer(edges, dtype=\"V8\")  # performance trick\n    unique_blob, edge_counts = np.unique(edges_blob, return_counts=True)\n\n    # Code above is same as first part in mesh_is_edge_manifold_and_closed()\n\n    # Collect faces for each corrupt unique edge. This happens one by\n    # one. Maybe this can be vectorized, but it only hurts performance\n    # for corrupt meshes, so not a big deal.\n    nonmanifold_edges = {}\n    corrupt_indices = np.where(edge_counts > 2)[0]\n    for i in corrupt_indices:\n        eii = np.where(edges_blob == unique_blob[i])[0]\n        edge = tuple(edges[eii[0]])  # Eeach ei in eii refers to the same edge\n        fii = list(set(fi for fi in eii // 3))\n        nonmanifold_edges[edge] = fii\n\n    return nonmanifold_edges", "\n\ndef mesh_is_oriented(faces):\n    \"\"\"Check whether  the mesh is oriented. Also implies edge-manifoldness.\n\n    This implementation is based on vectorized numpy code and therefore very fast.\n    \"\"\"\n    # Special case\n    if len(faces) == 0:\n        return True\n\n    # Select edges. Note no sorting!\n    edges = faces[:, [[0, 1], [1, 2], [2, 0]]]\n    edges = edges.reshape(-1, 2)\n\n    # The magic line\n    edges_blob = np.frombuffer(edges, dtype=\"V8\")  # performance trick\n    _, edge_counts = np.unique(edges_blob, return_counts=True)\n\n    # If neighbouring faces have consistent winding, their edges\n    # are in opposing directions, so the unsorted edges should have\n    # no duplicates. Note that ths implies edge manifoldness,\n    # because if an edge is incident to more than 2 faces, one of\n    # the edges orientations would appear twice. The reverse is not\n    # necessarily true though: a mesh can be edge-manifold but not\n    # oriented.\n    is_oriented = bool(edge_counts.max() == 1)\n\n    return is_oriented", "\n\ndef mesh_get_volume(vertices, faces):\n    \"\"\"Calculate the volume of the mesh.\n\n    It is assumed that the mesh is oriented and closed. If not, the result does\n    not mean much. If the volume is negative, it is inside out.\n\n    This implementation is based on vectorized numpy code and therefore very fast.\n    \"\"\"\n    # Special case\n    if len(faces) == 0:\n        return 0\n\n    vertices = np.asarray(vertices, np.float32)\n    faces = np.asarray(faces, np.int32)\n\n    # This code is surprisingly fast, over 10x faster than the other\n    # checks. I also checked out skcg's computed_interior_volume,\n    # which uses Gauss' theorem of calculus, but that is\n    # considerably (~8x) slower.\n    return maybe_pylinalg.volume_of_closed_mesh(vertices, faces)", "\n\ndef mesh_get_surface_area(vertices, faces):\n    \"\"\"Calculate the surface area of the mesh.\"\"\"\n    vertices = np.asarray(vertices, np.float32)\n    faces = np.asarray(faces, np.int32)\n\n    r1 = vertices[faces[:, 0], :]\n    r2 = vertices[faces[:, 1], :]\n    r3 = vertices[faces[:, 2], :]\n    face_normals = np.cross((r2 - r1), (r3 - r1))  # assumes CCW\n    faces_areas = 0.5 * np.linalg.norm(face_normals, axis=1)\n    return faces_areas.sum()", "\n\ndef mesh_get_component_labels(faces, vertex2faces, *, via_edges_only=True):\n    \"\"\"Split the mesh in one or more connected components.\n\n    Returns a 1D array that contains component indices for all faces.\n    \"\"\"\n\n    # Performance notes:\n    # * Using a deque for the front increases performance a tiny bit.\n    # * Using set logic makes rather then control flow does not seem to matter much.\n    # * The labels that we're interested in we set directly in an array\n    #   so we avoid the step to go from set -> list -> array labels.\n\n    faces_to_check = set(range(len(faces)))\n\n    # Array to store component labels. (Using list vs array does not seem to affect performance.)\n    component_labels = np.empty((len(faces),), np.int32)\n    component_labels.fill(-1)\n    component_index = -1\n\n    while len(faces_to_check) > 0:\n        # Create new front - once for each connected component in the mesh\n        component_index += 1\n        fi_next = faces_to_check.pop()\n        front = queue.deque()\n        front.append(fi_next)\n\n        while front:\n            fi_check = front.popleft()\n            component_labels[fi_check] = component_index\n\n            if via_edges_only:\n                _, neighbour_faces = face_get_neighbours2(faces, vertex2faces, fi_check)\n            else:\n                neighbour_faces = face_get_neighbours1(faces, vertex2faces, fi_check)\n\n            for fi in neighbour_faces:\n                if fi in faces_to_check:\n                    faces_to_check.remove(fi)\n                    front.append(fi)\n\n    return component_labels", "\n\ndef mesh_get_non_manifold_vertices(faces, vertex2faces):\n    \"\"\"Detect non-manifold vertices.\n\n    These are returned as a dict ``vi -> [[fi1, fi2, ..], [fi3, fi4, ...]]``.\n    It maps vertex indices to a list of face-index-groups, each\n    representing a fan attached to the vertex. I.e. to repair the vertex,\n    a duplicate vertex must be created for each group (except one).\n\n    If the returned dictionary is empty, and the mesh is edge-manifold,\n    the mesh is also vertex-manifold. In other words, for each vertex,\n    the faces incident to that vertex form a closed or an open fan.\n\n    \"\"\"\n    # This implementation literally performs a test for each vertex.\n    # Since the per-vertex test involves querying neighbours a lot, it\n    # is somewhat slow. I've tried a few things to check\n    # vertex-manifoldness faster, without success. I'll summerize here\n    # for furure reference and maybe help others that walk a similar path:\n    #\n    # By splitting the mesh in connected components twice, once using\n    # vertex-connectedness, and once using edge-connectedness, it's\n    # easy to spot non-manifold edges in between components. It's even\n    # possible to do this in a single iteration! However, it does not\n    # reveal non-manifold vertices within components :/\n    #\n    # Then I tried a few ways to select suspicious faces/vertices during\n    # the algorithm that splits connected components, and then examine\n    # each suspicious vertex. Since that algorithm already walks over\n    # the surface of the mesh and requires information on the face\n    # neighbours, overhead can be combined/reused, basically resulting\n    # in getting the split components for free. That part works, but I\n    # have not been able to find a way to reliably select suspicious\n    # faces/vertices.\n    #\n    # One approach was to mark indirect neighbours (faces connected\n    # with only a vertex) as they were encountered, and unmark them\n    # when that face was seen again, but now as a direct neighbour (and\n    # via an edge that includes the suspicious vertex). Unfortunately,\n    # depending on the implementation details, this approach was either\n    # too permissive (missing corrupt vertices), slower than the brute\n    # force, or leaving so many false positives that you might as well\n    # use the brute force method.\n    #\n    # I was pretty fond of the idea to score each vertex based on its\n    # role in connecting neighbours for each face. For an indirect\n    # neighbour it scored negative points, for a direct neighbour it\n    # scored positive points. If the net score was negative, it was a\n    # suspicious vertex and examined properly. It was tuned so that it\n    # did not generates false positives for fans of 6 faces  (by scoring\n    # edge-neighbours 1.5 times higher). Interestingly, this method is\n    # able to reliably detect non-manifold vertices in a large variety\n    # of topologies. Unfortunately there are a few vertex-based\n    # fan-to-fan connections for which it fails. The example that\n    # explains this best is a fan of 3 faces connected to another fan\n    # of 3 faces. From the viewpoint of the face (annotated with 'a'\n    # below) this configuration is indiscernible from a closed 6-face\n    # fan. This means we cannot detect this case without generating a\n    # false positive for a *very* common type of fan.\n    #   __\n    #  |\\ | /|\n    #  |_\\|/_|\n    #  | /|\\a|\n    #  |/ |_\\|\n    #\n    # Conclusion: if we want a fast vertex-manifold check, we should\n    # probably just use Cython ...\n\n    # suspicious_vertices = np.unique(faces)\n    suspicious_vertices = set(faces.flat)\n\n    # Calculate face adjecency once beforehand, instead of 3x per face\n    face_adjacency = [None for _ in range(len(faces))]\n    for fi in range(len(faces)):\n        _, neighbour_faces2 = face_get_neighbours2(faces, vertex2faces, fi)\n        face_adjacency[fi] = neighbour_faces2\n\n    nonmanifold_vertices = {}\n    for vi in suspicious_vertices:\n        groups = vertex_get_incident_face_groups(\n            faces, vertex2faces, vi, face_adjacency=face_adjacency\n        )\n        if len(groups) > 1:\n            nonmanifold_vertices[vi] = groups\n\n    return nonmanifold_vertices", "\n\ndef mesh_get_boundaries(faces):\n    \"\"\"Select the boundaries of the mesh.\n\n    Returns a list of boundaries, where each boundary is a list of\n    vertices. Each boundary is a loop (the first and last vertex are\n    connected via a boundary edge), and the order of vertices is in the\n    appropriate winding direction.\n\n    This function can raise a RuntimeError if it runs into a part of\n    the mesh that is non-manifold.\n    \"\"\"\n    # Special case\n    if len(faces) == 0:\n        return []\n\n    faces = np.asarray(faces, np.int32)\n\n    # Select edges\n    edges = faces[:, [[0, 1], [1, 2], [2, 0]]]\n    edges = edges.reshape(-1, 2)\n    sorted_edges = np.sort(edges, axis=1)\n\n    # Find the unique edges\n    edges_blob = np.frombuffer(sorted_edges, dtype=\"V8\")  # performance trick\n    unique_blob, unique_index, edge_counts = np.unique(\n        edges_blob, return_index=True, return_counts=True\n    )\n    unique_edges = np.frombuffer(unique_blob, dtype=np.int32).reshape(-1, 2)\n\n    # Find the boundary edges: those that only have one incident face\n    (boundary_edge_indices,) = np.where(edge_counts == 1)\n\n    # Build map vi -> eii\n    nvertices = faces.max() + 1\n    vertex2edges = [[] for _ in range(nvertices)]\n    for ei in boundary_edge_indices:\n        vi1, vi2 = unique_edges[ei]\n        vertex2edges[vi1].append(ei)\n        vertex2edges[vi2].append(ei)\n\n    # Sanity check. Note that the mesh can still be non-manifold, as\n    # long as it's vertex-manifold along the boundaries, it's fine.\n    # Edge-manifoldness is less of an issue, because it means an edge\n    # has more than 2 faces, which makes it not a boundary anyway.\n    for vi in range(nvertices):\n        if len(vertex2edges[vi]) > 2:  # pragma: no cover\n            raise RuntimeError(\"The mesh is not vertex-manifold.\")\n\n    # Now group them into boundaries ...\n    #\n    # This looks a bit like the code we use to walk over the surface\n    # of the mesh, e.g. to find connected components. This is similar\n    # except we walk over boundaries (edges with just one incident\n    # face).\n\n    eii_to_check = set(boundary_edge_indices)\n    boundaries = []\n\n    while eii_to_check:\n        # Select arbitrary edge as starting point, and add both its edges to\n        # a list that we will build up further. The order of these initial\n        # vertices determines the direction that we walk in.\n        ei = ei_first = eii_to_check.pop()\n        original_edge = edges[unique_index[ei]]\n        boundary = [original_edge[1]]\n        boundaries.append(boundary)\n\n        while True:\n            # Get the two vertex indices on the current edge.\n            # One is the last added vertex, the other represents the direction\n            # we should move in.\n            vi1, vi2 = unique_edges[ei]\n            vi = vi2 if vi1 == boundary[-1] else vi1\n            boundary.append(vi)\n            # We look up what boundary-edges are incident to this vertex.\n            # One is the previous edge. the other will be the next.\n            ei1, ei2 = vertex2edges[vi]\n            ei = ei2 if ei1 == ei else ei1\n            # We either keep going, or have gone full circle\n            if ei in eii_to_check:\n                eii_to_check.remove(ei)\n            else:\n                if not (\n                    ei == ei_first and boundary[0] == boundary[-1]\n                ):  # pragma: no cover\n                    raise RuntimeError(\n                        \"This should not happen, but if it does, I think the mesh is not manifold.\"\n                    )\n                boundary.pop(-1)\n                break\n\n        # Sanity check for the algorithm below. It shows the assumptions\n        # that we make about the result, but that are (should be) true\n        # by the mesh being manifold and how the algorithm works.\n        # Can be uncommented when developing.\n        # edge_index = unique_index[ei]\n        # assert np.all(sorted_edges[edge_index] == unique_edges[ei])\n        # original_edge = edges[edge_index]\n        # assert boundary[0] == original_edge[1]\n        # assert boundary[1] == original_edge[0]\n\n    return boundaries", "\n\ndef mesh_get_consistent_face_orientation(faces, vertex2faces):\n    \"\"\"Make the orientation of the faces consistent.\n\n    Returns a modified copy of the faces which may have some of the\n    faces flipped. Faces are flipped by swapping the 2nd and 3d value.\n    Note that the winding of the returned array may still not be\n    consistent, when the mesh is not manifold or when it is not\n    orientable (i.e. a Mobius strip or Klein bottle).\n    \"\"\"\n\n    # This implementation walks over the surface using a front. The\n    # algorithm is similar to the one for splitting the mesh in\n    # connected components, except it does more work at the deepest\n    # nesting.\n    #\n    # It starts out from one face, and reverses the neighboring\n    # faces that don't match the winding of the current face. And\n    # so on. Faces that have been been processed cannot be reversed\n    # again. So the fix operates as a wave that flows over the mesh,\n    # with the first face defining the winding.\n    #\n    # A closed form solution for this problem does not exist. The skcg\n    # lib uses pycosat to find the solution. The below might be slower\n    # (being implemented in pure Python), but it's free of dependencies\n    # and speed matters less in a repair function, I suppose.\n\n    # Make a copy of the faces, so we can reverse them in-place.\n    faces = faces.copy()\n\n    reversed_faces = []\n    faces_to_check = set(range(len(faces)))\n\n    while len(faces_to_check) > 0:\n        # Create new front - once for each connected component in the mesh\n        vi_next = faces_to_check.pop()\n        front = queue.deque()\n        front.append(vi_next)\n\n        # Walk along the front\n        while front:\n            fi_check = front.popleft()\n            vi1, vi2, vi3 = faces[fi_check]\n            _, neighbours = face_get_neighbours2(faces, vertex2faces, fi_check)\n            for fi in neighbours:\n                if fi in faces_to_check:\n                    faces_to_check.remove(fi)\n                    front.append(fi)\n\n                    vj1, vj2, vj3 = faces[fi]\n                    matching_vertices = {vj1, vj2, vj3} & {vi1, vi2, vi3}\n                    if len(matching_vertices) == 2:\n                        if vi3 not in matching_vertices:\n                            # vi1 in matching_vertices and vi2 in matching_vertices\n                            if (\n                                (vi1 == vj1 and vi2 == vj2)\n                                or (vi1 == vj2 and vi2 == vj3)\n                                or (vi1 == vj3 and vi2 == vj1)\n                            ):\n                                reversed_faces.append(fi)\n                                faces[fi, 1], faces[fi, 2] = (\n                                    faces[fi, 2],\n                                    faces[fi, 1],\n                                )\n                        elif vi1 not in matching_vertices:\n                            # vi2 in matching_vertices and vi3 in matching_vertices\n                            if (\n                                (vi2 == vj1 and vi3 == vj2)\n                                or (vi2 == vj2 and vi3 == vj3)\n                                or (vi2 == vj3 and vi3 == vj1)\n                            ):\n                                reversed_faces.append(fi)\n                                faces[fi, 1], faces[fi, 2] = (\n                                    faces[fi, 2],\n                                    faces[fi, 1],\n                                )\n                        elif vi2 not in matching_vertices:\n                            # vi3 in matching_vertices and vi1 in matching_vertices\n                            if (\n                                (vi3 == vj1 and vi1 == vj2)\n                                or (vi3 == vj2 and vi1 == vj3)\n                                or (vi3 == vj3 and vi1 == vj1)\n                            ):\n                                reversed_faces.append(fi)\n                                faces[fi, 1], faces[fi, 2] = (\n                                    faces[fi, 2],\n                                    faces[fi, 1],\n                                )\n\n        # If over half the faces were flipped, we flip the hole thing.\n        if len(reversed_faces) > 0.5 * len(faces):\n            tmp = faces[:, 2].copy()\n            faces[:, 2] = faces[:, 1]\n            faces[:, 1] = tmp\n\n        return faces", "\n\ndef mesh_stitch_boundaries(vertices, faces, *, atol=1e-5):\n    \"\"\"Stitch touching boundaries together by de-deuplicating vertices.\n\n    Stitching only happens when it does not result in a non-manifold\n    mesh. Returns the modified faces array.\n\n    It is up to the caller to remove collapsed faces and any vertices\n    that are no longer used.\n    \"\"\"\n\n    # Make a copy of the faces that we can modify\n    vertices = np.asarray(vertices, np.float32)\n    faces = np.asarray(faces, np.int32).copy()\n\n    # Detect boundaries. A list of vertex indices (vi's)\n    boundaries = mesh_get_boundaries(faces)\n\n    # Combine to get a subset of vertices for faster checking.\n    boundary_vertices = np.concatenate(boundaries)\n    boundary_positions = vertices[boundary_vertices]\n\n    # Keep track of what vi's were already handled as a duplicate\n    duplicate_mask = np.zeros((len(vertices),), bool)\n\n    # Create a mask so we can look up the boundary index from a vi\n    boundary_mask = np.empty((len(vertices),), np.int32)\n    boundary_mask.fill(-1)\n    for i, boundary in enumerate(boundaries):\n        boundary_mask[boundary] = i\n\n    # The deduplication can cause the mesh to become non-manifold.\n    # To prevent this we appy the changes in chunks and validate\n    # the change before it is applied. These \"chunks\" are groups\n    # of boundaries that connect. To handle these groups we use a\n    # stack-based algorithm simular to those used to traverse over\n    # the surface of the mesh.\n\n    boundary_indices_to_check = set(range(len(boundaries)))\n\n    while boundary_indices_to_check:\n        boundary_indices_in_this_group = [boundary_indices_to_check.pop()]\n\n        faces_for_this_group = faces.copy()\n\n        while boundary_indices_in_this_group:\n            boundary = boundaries[boundary_indices_in_this_group.pop(0)]\n\n            # The next two pieces of code are the heart of the algorithm,\n            # most of the rest is to apply the grouping and preventing non-manifoldness.\n\n            # Collect duplicate vertices.\n            duplicate_map = {}\n            for vi in boundary:\n                if not duplicate_mask[vi]:\n                    mask3 = np.isclose(\n                        boundary_positions, vertices[vi], atol=atol or 0, rtol=0\n                    )\n                    mask = mask3.sum(axis=1) == 3  # all el's of a vertex must match\n                    if mask.sum() > 1:\n                        vii = boundary_vertices[mask]\n                        duplicate_mask[vii] = True\n                        duplicate_map[vi] = vii\n\n            # Now we apply them to a copy of the faces array. Some heavy iterations here ...\n            for vi1, vii in duplicate_map.items():\n                for vi2 in vii:\n                    if vi2 != vi1:\n                        faces_for_this_group[faces == vi2] = vi1\n\n            # See if we need to process more boundaries in this group\n            group = set()\n            for vii in duplicate_map.values():\n                group.update(boundary_mask[vii])\n            group = group & boundary_indices_to_check\n            boundary_indices_to_check.difference_update(group)\n            boundary_indices_in_this_group.extend(group)\n\n        # We've now processed one group of boundaries ...\n\n        # Check whether the new face array is manifold, taking collapsed faces into account\n        not_collapsed = np.array(\n            [len(set(f)) == len(f) for f in faces_for_this_group], bool\n        )\n        tmp_faces = faces_for_this_group[not_collapsed]\n        v2f = make_vertex2faces(tmp_faces)\n        is_edge_manifold, _ = mesh_is_edge_manifold_and_closed(tmp_faces)\n        non_manifold_verts = mesh_get_non_manifold_vertices(tmp_faces, v2f)\n        is_manifold = is_edge_manifold and not non_manifold_verts\n\n        # If it is, apply!\n        if is_manifold:\n            faces = faces_for_this_group\n\n    return faces", ""]}
{"filename": "gfxmorph/tracker.py", "chunked_list": ["import numpy as np\n\n\nclass MeshChangeTracker:\n    \"\"\"Base class for tracking changes of a BaseDynamicMesh.\n\n    To track changes, create a subclass and implementing (a subset of)\n    its methods. The instance of the subclass can then be subscribed\n    using ``dynamic_mesh.track_changes()`` to receive updates.\n\n    The methods of this class are called at specific events. Together\n    they (hopefully) provide an API to adequately track changes for a\n    number of use-cases. Such use-cases may include e.g. logging,\n    keeping an undo stack, and updating a GPU representation of the\n    mesh.\n    \"\"\"\n\n    def init(self, mesh):\n        \"\"\"Called when the tracker is subscribed to the mesh.\n\n        This enables a tracker to properly reset as needed, or e.g.\n        prevent registering to multiple meshes, etc.\n\n        You may want to take into account that the mesh already has\n        vertices and faces at the moment that the tracker is subscribed.\n        \"\"\"\n        pass\n\n    # API that is the same as changes to BaseDynamicMesh, except for the `old` argument\n\n    def add_faces(self, faces):\n        \"\"\"Called when faces are added to the mesh.\n\n        Same signature as ``DynamicMesh.add_faces``.\n        \"\"\"\n        pass\n\n    def pop_faces(self, n, old):\n        \"\"\"Called when faces are are removed from the mesh.\n\n        Same signature as ``DynamicMesh.pop_faces``, except for the ``old`` arg.\n        Note that calling ``delete_faces()`` on the mesh results in a\n        ``swap_faces()`` and a ``pop_faces()``.\n        \"\"\"\n        pass\n\n    def swap_faces(self, indices1, indices2):\n        \"\"\"Called when the mesh swaps faces (to keep the arrays contiguous).\n\n        Same signature as ``DynamicMesh.swap_faces``.\n        \"\"\"\n        pass\n\n    def update_faces(self, indices, faces, old):\n        \"\"\"Called when faces are are updated.\n\n        Same signature as ``DynamicMesh.update_faces``, except for the ``old`` arg.\n        \"\"\"\n        pass\n\n    def add_vertices(self, positions):\n        \"\"\"Called when vertices are added to the mesh.\n\n        Same signature as ``DynamicMesh.add_vertices``.\n        \"\"\"\n        pass\n\n    def pop_vertices(self, n, old):\n        \"\"\"Called when vertices are are removed from the mesh.\n\n        Same signature as ``DynamicMesh.pop_vertices``, except for the ``old`` arg.\n        Note that calling ``delete_vertices()`` on the mesh results in a\n        ``swap_vertices()`` and a ``pop_vertices()``.\n        \"\"\"\n        pass\n\n    def swap_vertices(self, indices1, indices2):\n        \"\"\"Called when the mesh swaps vertices (to keep the arrays contiguous).\n\n        Same signature as ``DynamicMesh.swap_vertices``.\n        \"\"\"\n        pass\n\n    def update_vertices(self, indices, positions, old):\n        \"\"\"Called when vertices are are updated.\n\n        Same signature as ``DynamicMesh.update_vertices``, except for the ``old`` arg.\n        \"\"\"\n        pass\n\n    # Bit of additional API, leaning somewhat towards GPU usage\n\n    def new_faces_buffer(self, mesh):\n        \"\"\"Called when a new buffer is allocated to store the faces.\n\n        This happens when more memory is needed to store the faces, or\n        when faces are deleted and the buffer can be made smaller.\n\n        The mesh is passed as an argument so the tracker has full access\n        to it to address this situation. The new buffer array can be\n        obtained via ``mesh.faces.base``.\n        \"\"\"\n        pass\n\n    def new_vertices_buffer(self, mesh):\n        \"\"\"Called when new buffers are allocated to store the vertices.\n\n        This happens when more memory is needed to store the vertices\n        (positions and normals), or when vertices are deleted and the\n        buffers can be made smaller.\n\n        The mesh is passed as an argument so the tracker has full access\n        to it to address this situation. The new buffer array can be\n        obtained via ``mesh.positions.base``.\n        \"\"\"\n        pass\n\n    def update_normals(self, indices):\n        \"\"\"Called when the given normals have changed.\n\n        It's not enought to use ``update_vertices``, because when a vertex\n        position changes, it also affects the normals of neighbouring vertices.\n\n        For reasons of performance and simplicity, the new normals are\n        not provided as an argument. If needed, store the normals buffer in\n        ``new_vertices_buffer`` and then sample the values from that.\n        \"\"\"\n        pass", "\n\nclass MeshLogger(MeshChangeTracker):\n    \"\"\"A simple logger that produces textual messages about changes to the mesh.\"\"\"\n\n    def __init__(self, print_func):\n        self.print = print_func\n\n    def add_faces(self, faces):\n        self.print(f\"Adding {len(faces)} faces.\")\n\n    def pop_faces(self, n, old):\n        self.print(f\"Removing {n} faces.\")\n\n    def update_faces(self, indices, faces, old):\n        self.print(f\"Updating {len(indices)} faces.\")\n\n    def add_vertices(self, positions):\n        self.print(f\"Adding {len(positions)} vertices.\")\n\n    def pop_vertices(self, n, old):\n        self.print(f\"Removing {n} vertices.\")\n\n    def update_vertices(self, indices, positions, old):\n        self.print(f\"Updating {len(indices)} vertices.\")", "\n\nclass MeshUndoTracker(MeshChangeTracker):\n    \"\"\"A mesh change tracker functioning as an undo stack.\n\n    To create a new version, call ``commit()``. The new version contains\n    all changes since the last commit. It is recommended to make commits\n    by using this object as a context manager. It will then prevent\n    (unintended) commits until the context exits.\n    \"\"\"\n\n    def init(self, mesh):\n        self._work_in_progress = False\n        self._pending = []\n        self._undo = []\n        self._redo = []\n        self._stack_level = 0\n\n    def __enter__(self):\n        # Can re-enter, but only the first context counts\n        self._stack_level += 1\n        return self\n\n    def __exit__(self, *args):\n        self._stack_level -= 1\n        if self._stack_level <= 0:\n            self._stack_level = 0\n            self.commit()\n\n    def add_faces(self, faces):\n        self._append((\"pop_faces\", len(faces)))\n\n    def pop_faces(self, n, old):\n        self._append((\"add_faces\", old))\n\n    def swap_faces(self, indices1, indices2):\n        self._append((\"swap_faces\", indices2, indices1))\n\n    def update_faces(self, indices, faces, old):\n        self._append((\"update_faces\", indices, old))\n\n    def add_vertices(self, positions):\n        self._append((\"pop_vertices\", len(positions)))\n\n    def pop_vertices(self, n, old):\n        self._append((\"add_vertices\", old))\n\n    def swap_vertices(self, indices1, indices2):\n        self._append((\"swap_vertices\", indices2, indices1))\n\n    def update_vertices(self, indices, positions, old):\n        self._append((\"update_vertices\", indices, old))\n\n    def _append(self, step):\n        # See if we can merge.\n        # A common case is that the mesh is deformed interactively,\n        # resulting in many updates to the same set of vertices. We can\n        # easily detect this case. We can then simply drop the new\n        # update, because the previous undo-step undoes it up to the\n        # beginning.\n        if len(self._pending) > 0:\n            last_step = self._pending[-1]\n            if step[0] == \"update_vertices\" and last_step[0] == \"update_vertices\":\n                indices, last_indices = step[1], last_step[1]\n                # If the application uses the same i32 ndarray to update the vertices,\n                # we can make this test fast. Otherwise, we need to testa bit more.\n                if indices is last_indices:\n                    return\n                elif len(indices) == len(last_indices):\n                    if np.all(indices == last_indices):\n                        return\n\n        # Add to staging list\n        self._pending.append(step)\n\n    def get_version(self):\n        \"\"\"Get the current 'version' of the mesh.\n\n        The version is an integer that increases with each version.\n        \"\"\"\n        return len(self._undo)\n\n    def has_pending_changes(self):\n        \"\"\"Get whether there are pending changes that can be comitted or cancelled.\"\"\"\n        return len(self._pending) > 0\n\n    def commit(self):\n        \"\"\"Save the current state as a new version, and return the new version number.\n\n        In other words, this commits the pending changes to the undo stack.\n        If the object is currently used as a context, this does nothing.\n        \"\"\"\n        if not (self._work_in_progress or self._stack_level > 0):\n            self._undo.append(self._pending)\n            self._pending = []\n            self._redo.clear()\n        return self.get_version()\n\n    def cancel(self, dynamic_mesh):\n        \"\"\"Cancel any uncommited changes.\n\n        Pending changes are lost.\n        \"\"\"\n        if self._pending and not self._work_in_progress:\n            dummy_target = []\n            steps = self._pending\n            self._pending = []\n            self._do(dynamic_mesh, steps, dummy_target)\n        else:\n            self._pending = []\n\n    def undo(self, dynamic_mesh):\n        \"\"\"Undo the changes of the last comitted version.\n\n        If there are pending changes, these are cancelled first. The\n        mesh is then reverted to the previous version (the version\n        before the last committed version). If the undo-stack is empty\n        (i.e. there are no changes to undo), this step does nothing.\n        \"\"\"\n        self.apply_version(dynamic_mesh, self.get_version() - 1)\n\n    def redo(self, dynamic_mesh):\n        \"\"\"Redo the last undone change.\n\n        If there are pending changes, these are cancelled first. The\n        mesh is then reverted to the version that was last undo. If the\n        redo-stack is empty (i.e. if a new commit has been made since\n        the last undo) this step does nothing.\n        \"\"\"\n        self.apply_version(dynamic_mesh, self.get_version() + 1)\n\n    def apply_version(self, dynamic_mesh, version):\n        \"\"\"Apply the given version.\n\n        If there are pending changes, these are cancelled first. If the\n        version is either the current version or out of range, this\n        step does nothing. The given mesh must be the same as the mesh\n        being tracked.\n        \"\"\"\n        if self._stack_level > 0:\n            raise RuntimeError(\n                \"Cannot undo/redo while the MeshUndoTracker is used as a context.\"\n            )\n        self.cancel(dynamic_mesh)\n        while self._undo and version < len(self._undo):\n            self._do(dynamic_mesh, self._undo.pop(-1), self._redo)\n        while self._redo and version > len(self._undo):\n            self._do(dynamic_mesh, self._redo.pop(-1), self._undo)\n\n    def _do(self, dynamic_mesh, steps, target):\n        assert len(self._pending) == 0\n        self._work_in_progress = True\n        try:\n            for step in reversed(steps):\n                method_name, *args = step\n                f = getattr(dynamic_mesh, method_name)\n                f(*args)\n        finally:\n            target.append(self._pending)\n            self._pending = []\n            self._work_in_progress = False", "\n\n# class MeshUndoTracker(MeshChangeTracker):\n#     \"\"\"A mesh change tracker functioning as an undo stack.\"\"\"\n#\n#     def init(self, mesh):\n#         # self._doing = None\n#         self._undo = []\n#         self._redo = []\n#         self._stack = None", "#         self._redo = []\n#         self._stack = None\n#         self._stack_level = 0\n#\n#     def __enter__(self):\n#         # Can re-enter, but only the first context counts\n#         self._stack_level += 1\n#         if self._stack is None:\n#             self._stack = []\n#         return self", "#             self._stack = []\n#         return self\n#\n#     def __exit__(self, *args):\n#         self._stack_level -= 1\n#         if self._stack_level <= 0:\n#             self._stack_level = 0\n#             if self._stack is not None:\n#                 if len(self._stack):\n#                     self._undo.append(self._stack)", "#                 if len(self._stack):\n#                     self._undo.append(self._stack)\n#                     self._redo.clear()\n#                 self._stack = None\n#\n#     def add_faces(self, faces):\n#         self._append((\"pop_faces\", len(faces)))\n#\n#     def pop_faces(self, n, old):\n#         self._append((\"add_faces\", old))", "#     def pop_faces(self, n, old):\n#         self._append((\"add_faces\", old))\n#\n#     def swap_faces(self, indices1, indices2):\n#         self._append((\"swap_faces\", indices2, indices1))\n#\n#     def update_faces(self, indices, faces, old):\n#         self._append((\"update_faces\", indices, old))\n#\n#     def add_vertices(self, positions):", "#\n#     def add_vertices(self, positions):\n#         self._append((\"pop_vertices\", len(positions)))\n#\n#     def pop_vertices(self, n, old):\n#         self._append((\"add_vertices\", old))\n#\n#     def swap_vertices(self, indices1, indices2):\n#         self._append((\"swap_vertices\", indices2, indices1))\n#", "#         self._append((\"swap_vertices\", indices2, indices1))\n#\n#     def update_vertices(self, indices, positions, old):\n#         self._append((\"update_vertices\", indices, old))\n#\n#     def _append(self, step):\n#         if self._stack is None:\n#             # If there is no active stack, we simply add the one step to the undo list.\n#             # create a new stack, add to that, add to undo.\n#             self._undo.append([step])", "#             # create a new stack, add to that, add to undo.\n#             self._undo.append([step])\n#             self._redo.clear()\n#\n#         else:\n#             # See if we can merge\n#             if len(self._stack) > 0:\n#                 last_step = self._stack[-1]\n#                 if last_step[0] == \"update_vertices\" and step[0] == \"update_vertices\":\n#                     print(last_step[1].__class__.__name__, step[1].__class__.__name__, last_step[1] is step[1])", "#                 if last_step[0] == \"update_vertices\" and step[0] == \"update_vertices\":\n#                     print(last_step[1].__class__.__name__, step[1].__class__.__name__, last_step[1] is step[1])\n#\n#             self._stack.append(step)\n#\n#     def get_version(self):\n#         \"\"\"Get the current 'version' of the mesh.\"\"\"\n#         return len(self._undo)\n#\n#     def apply_version(self, dynamic_mesh, version):", "#\n#     def apply_version(self, dynamic_mesh, version):\n#         \"\"\"Apply the given version. The given mesh must be the same as the mesh being tracked.\"\"\"\n#         if self._stack is not None:\n#             raise RuntimeError(\"Cannot undo/redo while under a context.\")\n#         while self._undo and version < len(self._undo):\n#             self._do(dynamic_mesh, self._undo.pop(-1), self._redo)\n#         while self._redo and version > len(self._undo):\n#             self._do(dynamic_mesh, self._redo.pop(-1), self._undo)\n#", "#             self._do(dynamic_mesh, self._redo.pop(-1), self._undo)\n#\n#     def _do(self, dynamic_mesh, steps, target):\n#         assert self._stack is None\n#         self._stack = []\n#         try:\n#             for step in reversed(steps):\n#                 method_name, *args = step\n#                 f = getattr(dynamic_mesh, method_name)\n#                 f(*args)", "#                 f = getattr(dynamic_mesh, method_name)\n#                 f(*args)\n#         finally:\n#             target.append(self._stack)\n#             self._stack = None\n#\n#     def undo(self, dynamic_mesh):\n#         \"\"\"Undo the last change.\n#\n#         This is more of an example, because in practice one \"step\" from", "#\n#         This is more of an example, because in practice one \"step\" from\n#         the application point of view likely consists of multiple raw steps.\n#         \"\"\"\n#         self.apply_version(dynamic_mesh, self.get_version() - 1)\n#\n#     def redo(self, dynamic_mesh):\n#         \"\"\"Redo the last undone change.\"\"\"\n#         self.apply_version(dynamic_mesh, self.get_version() + 1)\n#", "#         self.apply_version(dynamic_mesh, self.get_version() + 1)\n#\n#\n#     def collect(self):\n#         self._stack = []\n#\n#     def append_last(self):\n#         if self._undo:\n#             self._stack = self._undo.pop()\n#", "#             self._stack = self._undo.pop()\n#\n#     def merge_last(self):\n#         if len(self._undo) < 2:\n#             return\n#\n#         steps1 = self._undo[-2]  # Second to last -> the new last\n#         steps2 = self._undo.pop(-1)  # Last\n#\n#         laststep = steps1[-1]", "#\n#         laststep = steps1[-1]\n#         # for step in steps2:\n#\n#         steps1.extend(steps2)\n#         print(len(steps1))\n\n# Commented, because we cannot have a reference to DynamicMesh because\n# of circular imports. But this is all we need to create a mesh that\n# replicates another. Probably a useless use-case, but it does", "# of circular imports. But this is all we need to create a mesh that\n# replicates another. Probably a useless use-case, but it does\n# illustrate the elegance of the change tracker API.\n#\n# class ReplicatingMesh(DynamicMesh, MeshChangeTracker):\n#     pass\n"]}
{"filename": "gfxmorph/mesh.py", "chunked_list": ["# ## Developer notes\n#\n# Our internal arrays are larger than needed - we have free slots. This\n# is because we must be able to dynamically add and remove vertices and\n# faces.\n\n# We always make a copy of the given data:\n# - so we control the dtype.\n# - we will change the values, avoid surprises by modifying given arrays.\n# - we need the first vertex to be empty. ---> not anymore", "# - we will change the values, avoid surprises by modifying given arrays.\n# - we need the first vertex to be empty. ---> not anymore\n# - we may want to initialize with some extra size.\n#\n# Vertex indices are denoted with vi, face indices with fi.\n\nimport numpy as np\n\nfrom .basedynamicmesh import BaseDynamicMesh\n", "from .basedynamicmesh import BaseDynamicMesh\n\n# from .maybe_pylinalg import ()\n# from .maybe_pygfx import ()\nfrom . import meshfuncs\n\n\nclass DynamicMesh(BaseDynamicMesh):\n    \"\"\"Representation of a mesh, with utilities to modify it.\n\n    In addition to BaseDynamicMesh, this class adds higher level logic\n    to detect certain properties of the mesh, make repairs, and other\n    (higher level) modifications.\n    \"\"\"\n\n    def __init__(self, positions, faces):\n        super().__init__()\n        # Delegate initialization\n        if positions is not None or faces is not None:\n            self.add_mesh(positions, faces)\n\n    @property\n    def component_labels(self):\n        \"\"\"A tuple of connected components that this mesh consists of.\"\"\"\n        cache = self._cache_depending_on_faces\n        key = \"component_labels\"\n        if key not in cache:\n            cache[key] = meshfuncs.mesh_get_component_labels(\n                self.faces, self.vertex2faces\n            )\n        return cache[key]\n\n    @property\n    def component_count(self):\n        \"\"\"The number of components that this mesh consists of.\"\"\"\n        # Note that connectedness is defined as going via edges, not vertices.\n        return self.component_labels.max() + 1\n\n    @property\n    def is_connected(self):\n        \"\"\"Whether the mesh is a single connected component.\"\"\"\n        return self.component_count == 1\n\n    @property\n    def is_edge_manifold(self):\n        \"\"\"Whether the mesh is edge-manifold.\n\n        A mesh being edge-manifold means that each edge is part of\n        either 1 or 2 faces. It is one of the two condition for a mesh\n        to be manifold.\n        \"\"\"\n        cache = self._cache_depending_on_faces\n        key = \"nonmanifold_edges\"\n        if key not in cache:\n            cache[key] = meshfuncs.mesh_get_non_manifold_edges(self.faces)\n        return len(cache[key]) == 0\n\n    @property\n    def is_vertex_manifold(self):\n        \"\"\"Whether the mesh is vertex-manifold.\n\n        A mesh being vertex-manifold means that for each vertex, the\n        faces incident to that vertex form a single (closed or open)\n        fan. It is one of the two condition for a mesh to be manifold.\n\n        In contrast to edge-manifoldness, a mesh being non-vertex-manifold,\n        can still be closed and oriented.\n        \"\"\"\n        cache = self._cache_depending_on_faces\n        key = \"nonmanifold_vertices\"\n        if key not in cache:\n            cache[key] = meshfuncs.mesh_get_non_manifold_vertices(\n                self.faces, self.vertex2faces\n            )\n        return self.is_edge_manifold and len(cache[key]) == 0\n\n    @property\n    def is_manifold(self):\n        \"\"\"Whether the mesh is manifold (both edge- and vertex-manifold).\"\"\"\n        return self.is_edge_manifold and self.is_vertex_manifold\n\n    @property\n    def is_closed(self):\n        \"\"\"Whether the mesh is closed.\n\n        A closed mesh has 2 faces incident to all its edges. This\n        implies that the mesh is edge-manifold, and has no boundary\n        edges.\n        \"\"\"\n        cache = self._cache_depending_on_faces\n        key = \"is_closed\"\n        if key not in cache:\n            _, is_closed = meshfuncs.mesh_is_edge_manifold_and_closed(self.faces)\n            cache[key] = is_closed\n        return cache[key]\n\n    @property\n    def is_oriented(self):\n        \"\"\"Whether the mesh is orientable.\n\n        The mesh being orientable means that the face orientation (i.e.\n        winding) is consistent - each two neighbouring faces have the\n        same orientation. This can only be true if the mesh is edge-manifold.\n        \"\"\"\n        cache = self._cache_depending_on_faces\n        key = \"is_oriented\"\n        if key not in cache:\n            cache[key] = meshfuncs.mesh_is_oriented(self.faces)\n        return cache[key]\n\n    @property\n    def edges(self):\n        \"\"\"All edges of this mesh as pairs of vertex indices\n\n        Returns\n        -------\n        ndarray, [n_faces, 3, 2]\n            pairs of vertex-indices specifying an edge.\n            the ith edge is the edge opposite from the ith vertex of the face\n\n        \"\"\"\n        array = self.faces[:, [[0, 1], [1, 2], [2, 0]]].reshape(-1, 2)\n        array.setflags(write=False)\n        return array\n\n    @property\n    def metadata(self):\n        \"\"\"A dict with metadata about the mesh.\"\"\"\n        arrays = (\n            self._faces_buf,\n            self._positions_buf,\n            self._normals_buf,\n        )\n        nb = sum([a.nbytes for a in arrays if a is not None])\n        mem = f\"{nb/2**20:0.2f} MiB\" if nb > 2**20 else f\"{nb/2**10:0.2f} KiB\"\n\n        return {\n            \"is_edge_manifold\": self.is_edge_manifold,\n            \"is_vertex_manifold\": self.is_vertex_manifold,\n            \"is_closed\": self.is_closed,\n            \"is_oriented\": self.is_oriented,\n            \"nfaces\": len(self._faces),\n            \"nvertices\": len(self._positions),\n            \"free_vertices\": len(self._positions_buf) - len(self._positions),\n            \"free_faces\": len(self._faces_buf) - len(self._faces),\n            \"approx_mem\": mem,\n        }\n\n    # %%\n\n    def get_surface_area(self):\n        \"\"\"Get the surface area of the mesh.\"\"\"\n        return meshfuncs.mesh_get_surface_area(self.positions, self.faces)\n\n    def get_volume(self):\n        \"\"\"Get the volume of the mesh.\n\n        CCW winding is assumed. If this is negative, the mesh is\n        probably inside-out. If the mesh is not manifold, oriented, and closed,\n        this method raises an error.\n        \"\"\"\n        if not (self.is_manifold and self.is_oriented and self.is_closed):\n            raise RuntimeError(\n                \"Cannot get volume of a mesh that is not manifold, oriented and closed.\"\n            )\n        return meshfuncs.mesh_get_volume(self.positions, self.faces)\n\n    def add_mesh(self, positions, faces):\n        \"\"\"Add a (partial) mesh.\n\n        The vertices and faces are appended to the end. The values of\n        the faces are modified to still target the appropriate vertices\n        (which may now have an offset).\n        \"\"\"\n        faces = np.asarray(faces, np.int32)\n\n        # The DynamicMesh class also does some checks, but it will\n        # only check if incoming faces match any vertex, not just the\n        # ones we add here, so we perform that check here.\n        if faces.min() < 0 or faces.max() >= len(positions):\n            raise ValueError(\n                \"The faces array containes indices that are out of bounds.\"\n            )\n\n        vertex_index_offset = len(self._positions)\n        self.add_vertices(positions)\n        self.add_faces(faces + vertex_index_offset)\n\n    # %% Repairs\n\n    def repair(self, close=False):\n        \"\"\"Perform various repairs to the mesh.\n\n        If close is given and True, also try to close the mesh. The\n        resulting mesh is guaranteed to be manifold, but may not be\n        closed. It will be oriented if the topology allows it (e.g. not\n        a Klein bottle).\n        \"\"\"\n        self.repair_manifold()\n        if close:\n            self.repair_touching_boundaries()\n            self.repair_holes()\n        self.repair_orientation()\n        self.remove_unused_vertices()\n\n    def repair_manifold(self):\n        \"\"\"Repair the mesh to make it manifold.\n\n        This method includes a number of steps:\n\n        * Remove collapsed faces.\n        * Remove duplicate faces.\n        * Remove faces incident to edges that have more than 2 incident faces.\n        * Duplicate non-manifold vertices and assign them to the respective faces.\n\n        The result is always a manifold mesh, but it may have less faces\n        (it could even be empty) and the mesh may have holes where it\n        previously attached to other parts of the mesh.\n\n        Returns the number of deleted/updated faces.\n        \"\"\"\n        n_updated = 0\n\n        if self.is_manifold:\n            return n_updated\n\n        # Remove collapsed faces. A collapsed face results in the mesh\n        # being either not vertex- or not edge- manifold, depending on\n        # whether it is at a boundary.\n        collapsed_faces = np.array([len(set(f)) != len(f) for f in self.faces], bool)\n        (indices,) = np.where(collapsed_faces)\n        if len(indices):\n            self.delete_faces(indices)\n            n_updated += len(indices)\n\n        # Remove duplicate faces.\n        sorted_buf = np.frombuffer(np.sort(self.faces, axis=1), dtype=\"V12\")\n        unique_buf, counts = np.unique(sorted_buf, axis=0, return_counts=True)\n        duplicate_values = unique_buf[counts > 1]\n        indices = []\n        for value in duplicate_values:\n            (indices_for_value,) = np.where(sorted_buf == value)\n            indices.extend(indices_for_value[1:])\n        if len(indices):\n            self.delete_faces(indices)\n            n_updated += len(indices)\n\n        # Remove non-manifold edges.\n        # Use the is_edge_manifold prop to trigger 'nonmanifold_edges' to be up to date.\n        if not self.is_edge_manifold:\n            nonmanifold_edges = self._cache_depending_on_faces[\"nonmanifold_edges\"]\n            indices = []\n            for edge, fii in nonmanifold_edges.items():\n                indices.extend(fii)\n            if len(indices):\n                self.delete_faces(indices)\n                n_updated += len(indices)\n\n        # Fix non-manifold vertices.\n        # Non-manifold vertices are vertices who's incident faces do not\n        # form a single (open or closed) fan. It's tricky to find such\n        # vertices, but it's easy to repair them, once found. The vertices\n        # are duplicated and assigned to the respective fans.\n        # Use the is_vertex_manifold prop to trigger 'nonmanifold_edges' to be up to date.\n        if not self.is_vertex_manifold:\n            # We update each group individually. It may be more efficient\n            # to collect changes, but it'd also make the code more complex.\n            # Note that we can safely do this because no vertices/faces are\n            # deleted in this process, so the indices in\n            # 'nonmanifold_vertices' remain valid.\n            nonmanifold_vertices = self._cache_depending_on_faces[\n                \"nonmanifold_vertices\"\n            ]\n            for vi, groups in nonmanifold_vertices.items():\n                assert len(groups) >= 2\n                for face_indices in groups[1:]:\n                    # Add vertex\n                    self.add_vertices([self._positions[vi]])\n                    vi2 = len(self._positions) - 1\n                    # Update faces\n                    faces = self.faces[face_indices, :]\n                    faces[faces == vi] = vi2\n                    self.update_faces(face_indices, faces)\n                    n_updated += len(face_indices)\n\n        return n_updated\n\n    def repair_orientation(self):\n        \"\"\"Repair the winding of individual faces to make the mesh oriented.\n\n        Faces that do not match the winding of their neighbours are\n        flipped in a recursive algorithm. If the mesh is a close and\n        oriented manifold, but it has a negative volume, all faces are\n        flipped.\n\n        The repair can only fail if the mesh is not manifold or when\n        it is not orientable (i.e. a Mobius strip or Klein bottle).\n\n        Returns the number of faces that are flipped.\n        \"\"\"\n        n_flipped = 0\n\n        if not self.is_oriented:\n            # Try making the winding consistent\n            modified_faces = meshfuncs.mesh_get_consistent_face_orientation(\n                self.faces, self.vertex2faces\n            )\n            (indices,) = np.where(modified_faces[:, 2] != self.faces[:, 2])\n            if len(indices) > 0:\n                self.update_faces(indices, modified_faces[indices])\n            n_flipped = len(indices)\n\n        # Reverse all the faces if this is an oriented closed manifold with a negative volume.\n        if self.is_manifold and self.is_oriented and self.is_closed:\n            if self.get_volume() < 0:\n                new_faces = self.faces.copy()\n                tmp = new_faces[:, 2].copy()\n                new_faces[:, 2] = new_faces[:, 1]\n                new_faces[:, 1] = tmp\n                indices = np.arange(len(new_faces), dtype=np.int32)\n                self.update_faces(indices, new_faces)\n                n_flipped = len(new_faces)\n\n        return n_flipped\n\n    def repair_touching_boundaries(self, *, atol=1e-5):\n        \"\"\"Repair open meshes by stitching boundary vertices that are close together.\n\n        Vertices (on boundaries) that are the same or close together\n        (according to the given tolerance) are de-duplicated, thereby\n        stitching the mesh parts together. The purpose is for meshes\n        that are visually closed but mathematically open, to become\n        mathematically closed.\n\n        There is no guarantee that this results in a closed mesh,\n        because that depends entirely on the presence of near-touching\n        boundaries. If the stitching of a group of boundaries would\n        result in a non-manifold mesh, it is skipped. (So it should be\n        safe to call this method.)\n\n        Returns the number of updated faces.\n        \"\"\"\n\n        if self.is_closed:\n            return 0\n\n        # Stitch, getting a copy of the faces\n        faces = meshfuncs.mesh_stitch_boundaries(self.positions, self.faces, atol=atol)\n\n        # Check what faces have been changed in our copy.\n        changed = faces != self.faces  # Nx3\n        changed_count = changed.sum(axis=1)\n        (indices,) = np.where(changed_count > 0)\n\n        if len(indices) == 0:\n            return 0\n\n        # Update the faces\n        self.update_faces(indices, faces[indices])\n\n        # Clean up collapsed faces\n        collapsed_faces = np.array([len(set(f)) != len(f) for f in self.faces], bool)\n        if np.any(collapsed_faces):\n            self.delete_faces(np.where(collapsed_faces)[0])\n\n        # Clean up any vertices that are no longer in use\n        self.remove_unused_vertices()\n\n        return len(indices)\n\n    def repair_holes(self):\n        \"\"\"Repair holes in the mesh.\n\n        Small boundaries are removed by filling these holes with new faces.\n\n        At the moment this only repairs holes of 3 or 4 vertices (i.e.\n        1  or 2 faces), but this can later be improved. So if only small\n        holes are present, the result will be a closed mesh. However,\n        if the mesh is not manifold, this method may not be able to\n        repair all holes. Also note that e.g. the four courners of a\n        rectangular surface would be connected with new faces.\n\n        Returns the number of added faces.\n        \"\"\"\n\n        if self.is_closed:\n            return 0\n\n        # Detect boundaries.\n        try:\n            boundaries = meshfuncs.mesh_get_boundaries(self.faces)\n        except RuntimeError:\n            # The mesh probably has non-manifold edges/vertices near the boundaries,\n            # causing the algorithm in `mesh_get_boundaries()` to fail.\n            return 0\n\n        # Now we check all boundaries\n        new_faces = []\n        for boundary in boundaries:\n            assert len(boundary) >= 3  # I don't think they can be smaller, right?\n            if len(boundary) == 3:\n                new_faces.append(boundary)\n            elif len(boundary) == 4:\n                new_faces.append(boundary[:3])\n                new_faces.append(boundary[2:] + boundary[:1])\n            else:\n                pass\n                # We can apply the earcut algororithm to fill larger\n                # holes as well. Leaving this open for now.\n\n        if new_faces:\n            self.add_faces(new_faces)\n\n        return len(new_faces)\n\n    def remove_unused_vertices(self):\n        \"\"\"Delete vertices that are not used by the faces.\n\n        This is a cleanup step that is safe to apply. Though it should\n        not be necessary to call this after doing processing steps -\n        these should clean up after themselves (though they could use\n        this method for that).\n        \"\"\"\n        faces = self.faces\n\n        vertices_mask = np.zeros((len(self.positions),), bool)\n        vii = np.unique(faces.flatten())\n        vertices_mask[vii] = True\n\n        indices = np.where(~vertices_mask)[0]\n        if len(indices) > 0:\n            self.delete_vertices(indices)\n\n    def remove_small_components(self, min_faces=4):\n        \"\"\"Remove small connected components from the mesh.\"\"\"\n\n        # We need the mesh to be manifold to do this\n        self.repair_manifold()\n        assert self.is_manifold\n\n        # Get labels and their counts\n        component_labels = self.component_labels\n        labels, counts = np.unique(component_labels, return_counts=True)\n\n        # Determine what faces to remove\n        faces_to_remove = []\n        for label, count in zip(labels, counts):\n            if count < min_faces:\n                faces_to_remove.extend(np.where(component_labels == label)[0])\n\n        # Determine what vertices to remove - important to be vertex-manifold!\n        vertices_to_remove = np.unique(self.faces[faces_to_remove].flatten())\n\n        # check\n        for vi in vertices_to_remove:\n            fii, _ = np.where(self.faces == vi)\n            for fi in fii:\n                assert fi in faces_to_remove\n\n        # Apply\n        if len(faces_to_remove):\n            self.delete_faces(faces_to_remove)\n            self.delete_vertices(vertices_to_remove)\n\n    def split(self):\n        \"\"\"Return a list of Mesh objects, one for each connected component.\"\"\"\n        # I don't think we need this for our purpose, but this class is capable\n        # of doing something like this, so it could be a nice util.\n        raise NotImplementedError()\n\n    def merge(self, other):\n        raise NotImplementedError()\n\n    # %% Walk over the surface\n\n    def get_closest_vertex(self, ref_pos):\n        \"\"\"Get the vertex index closest to the given 3D point, and its distance.\"\"\"\n        ref_pos = np.asarray(ref_pos, np.float32)\n        if ref_pos.shape != (3,):\n            raise ValueError(\"ref_pos must be a position (3 values).\")\n\n        distances = np.linalg.norm(self.positions - ref_pos, axis=1)\n        vi = np.nanargmin(distances)\n        return vi, distances[vi]\n\n    def select_vertices_over_surface(\n        self, ref_vertices, ref_distances, max_distance, distance_measure=\"smooth2\"\n    ):\n        \"\"\"Select nearby vertices, starting from the given reference vertices.\n\n        Walks over the surface from the reference vertices to include\n        more vertices until the distance to a vertex (by walking over\n        the surface) exceeds the max_distance. Each reference vertex is\n        also associated with a starting distance.\n\n        By allowing multiple reference vertices it is possible to \"grab\n        the mesh\" on a precise point within a face, or using specific\n        shapes (e.g. a line piece) to grab the mesh.\n\n        Parameters\n        ----------\n        ref_vertices : int or list or ndarray\n            A single vertex index, or a set of vertex indices, to start\n            the selection from.\n        ref_distances : float or list or ndarray\n            The initial distance, or distances, corresponding to the\n            reference vertices.\n        max_distance : float\n            The maximum (geodesic) distance that a vertex can have to\n            be included in the selection.\n        distance_measure : str\n            The method to calculate the geodesic distance. With \"edge\"\n            it sums the edge lengths, with \"smooth1\" it smooths the\n            path to compensate for zig-zag patterns, with \"smooth2\" it\n            does this smarter to avoid deviating from the surface.\n            Default \"smooth2\".\n\n        Returns\n        -------\n        vertices : ndarray\n            The selected vertex indices.\n        distances : ndarray\n            The corresponding (geodesic) distances.\n        \"\"\"\n\n        # Init\n        positions = self.positions\n        normals = self.normals\n        faces = self.faces\n        vertex2faces = self.vertex2faces\n\n        # Allow singleton use\n        if isinstance(ref_vertices, (int, np.int32, np.int64)):\n            ref_vertices = [ref_vertices]\n        if isinstance(ref_distances, (float, int, np.float32, np.float64)):\n            ref_distances = [ref_distances]\n\n        # Select path class\n        if distance_measure == \"edge\":\n            MeshPath = MeshPathEdge  # noqa\n        elif distance_measure == \"smooth1\":\n            MeshPath = MeshPathSmooth1  # noqa\n        elif distance_measure == \"smooth2\":\n            MeshPath = MeshPathSmooth2  # noqa\n        else:\n            raise ValueError(\n                \"The distance_measure arg must be 'edge' 'smooth1' or 'smooth2'.\"\n            )\n\n        # The list of vertices to check for neighbours\n        vertices2check = []\n        selected_vertices = {}\n        for vi, dist in zip(ref_vertices, ref_distances):\n            vertices2check.append((vi, dist))\n            selected_vertices[vi] = MeshPath().add(positions[vi], normals[vi])\n\n        # Walk over the surface\n        while len(vertices2check) > 0:\n            vi1, cumdist = vertices2check.pop(0)\n            path1 = selected_vertices[vi1]\n            for vi2 in meshfuncs.vertex_get_neighbours(faces, vertex2faces, vi1):\n                p2 = positions[vi2]\n                n2 = normals[vi2]\n                path2 = path1.add(p2, n2)\n                if path2.dist < max_distance:\n                    # We will have a closer look if we have not yet selected this\n                    # vertex, but also if we did but found a shorter route to it.\n                    # This means that we may sometimes do duplicate work. To avoid\n                    # this, we'd need a binary heap to store the front.\n                    path2_prev = selected_vertices.get(vi2, None)\n                    if path2_prev is None or path2.dist < path2_prev.dist:\n                        selected_vertices[vi2] = path2\n                        vertices2check.append((vi2, path2.dist))\n\n        vertices = np.array(sorted(selected_vertices.keys()), np.int32)\n        distances = np.array([selected_vertices[vi].dist for vi in vertices], \"f4\")\n        return vertices, distances", "\n\nclass BaseMeshPath:\n    \"\"\"Base class to help calculate the geodesic distance of a path over a surface.\"\"\"\n\n    __slots__ = [\"positions\", \"normals\", \"edist\", \"dist\"]\n\n    mode = \"\"\n\n    def __init__(self):\n        self.positions = []\n        self.normals = []\n        self.edist = 0.0  # edge distance\n        self.dist = 0.0  # the processed distance\n\n    def add(self, p, n):\n        new = self.__class__()\n        new.positions = self.positions[-3:] + [p]\n        new.normals = self.normals[-3:] + [n]\n        new.edist = self.edist\n        new.dist = self.dist\n        d = np.linalg.norm(self.positions[-1] - p) if self.positions else 0\n        new._process_new_position(d)\n        return new\n\n    def _process_new_position(self, d):\n        self.edist += d", "\n\nclass MeshPathEdge(BaseMeshPath):\n    \"\"\"Calculate the geodesic distance by simply summing the lengths\n    of edges that the path goes over.\n    \"\"\"\n\n    __slots__ = []\n\n    def _process_new_position(self, d):\n        self.edist += d\n        self.dist += d", "\n\nclass MeshPathSmooth1(BaseMeshPath):\n    \"\"\"Calculate the geodesic distance by (virtually) repositioning\n    visited points over the surface. Simply by putting it in between\n    the neighboring points. Simple, but it (quite literally) cuts corners.\n    \"\"\"\n\n    __slots__ = []\n\n    def _process_new_position(self, d):\n        self.edist += d\n        self.dist += d\n        if len(self.positions) >= 3:\n            p, delta_dist = self._refine_position(\n                *self.positions[-3:], *self.normals[-3:]\n            )\n            self.positions[-2] = p\n            self.dist += delta_dist\n\n    def _refine_position(self, p1, p2, p3, n1, n2, n3):\n        # Get current distance\n        dist1 = np.linalg.norm(p1 - p2)\n        dist3 = np.linalg.norm(p2 - p3)\n        dist_before = dist1 + dist3\n        if dist1 == 0 or dist3 == 0:\n            return p2, 0\n\n        # Get the point on the line between p1 and p3, but positioned relatively\n        f1 = 1 - dist1 / dist_before\n        f3 = 1 - dist3 / dist_before\n        assert 0.999 < (f1 + f3) < 1.001\n        p = f1 * p1 + f3 * p3\n\n        # Calculate new distance\n        dist_after = np.linalg.norm(p1 - p) + np.linalg.norm(p - p3)\n        delta_dist = dist_after - dist_before\n\n        return p, delta_dist", "\n\nclass MeshPathSmooth2(MeshPathSmooth1):\n    \"\"\"Calculate the geodesic distance by (virtually) repositioning\n    visited points over the surface. This is still a pretty crude\n    estimate of the \"real\" geodesic distance, but quite a bit more\n    precise than simply summing the edge lenghts.\n    \"\"\"\n\n    __slots__ = []\n\n    def _refine_position(self, p1, p2, p3, n1, n2, n3):\n        # Get current distance\n        dist1 = np.linalg.norm(p1 - p2)\n        dist3 = np.linalg.norm(p2 - p3)\n        dist_before = dist1 + dist3\n        if dist1 == 0 or dist3 == 0:\n            return p2, 0\n\n        # Normalize the normal, make sure its nonzero\n        n2_len = np.linalg.norm(n2)\n        if n2_len == 0:\n            return p2, 0\n        n2 = n2 / n2_len\n\n        # Get the point on the line between p1 and p3, but positioned relatively\n        f1 = 1 - dist1 / dist_before\n        f3 = 1 - dist3 / dist_before\n        assert 0.999 < (f1 + f3) < 1.001\n        p_between = f1 * p1 + f3 * p3\n\n        # Define a plane through p2, with a normal that is a combination.\n        # Just using n2 does not seem right, since we move the point towards\n        # p1 and p3, it makes sense to include contributions of these normals.\n        plane_pos = p2\n        plane_normal = n1 + n2 + n2 + n3\n        length = np.linalg.norm(plane_normal)\n        plane_normal = n2 if length == 0 else plane_normal / length\n\n        # Project the point on the surface. The surface is estimated using the plane avove.\n        p = p_between - np.dot(plane_normal, (p_between - plane_pos)) * plane_normal\n\n        # Calculate new distance\n        dist_after = np.linalg.norm(p1 - p) + np.linalg.norm(p - p3)\n        delta_dist = dist_after - dist_before\n\n        return p, delta_dist", ""]}
