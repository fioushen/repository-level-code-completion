{"filename": "forwarder.py", "chunked_list": ["\"\"\"handles the process of the bridge between telegram and discord\"\"\"\n\nimport argparse\nimport asyncio\nimport os\nimport signal\nimport sys\nfrom asyncio import AbstractEventLoop\nfrom sqlite3 import OperationalError\nfrom typing import Tuple", "from sqlite3 import OperationalError\nfrom typing import Tuple\n\nimport discord\nimport psutil  # pylint: disable=import-error\nfrom telethon import TelegramClient\n\nfrom bridge.config import Config\nfrom bridge.core import on_restored_connectivity, start\nfrom bridge.discord_handler import start_discord", "from bridge.core import on_restored_connectivity, start\nfrom bridge.discord_handler import start_discord\nfrom bridge.enums import ProcessStateEnum\nfrom bridge.events import EventDispatcher\nfrom bridge.healtcheck_handler import healthcheck\nfrom bridge.logger import Logger\nfrom bridge.telegram_handler import start_telegram_client\n\nconfig = Config()\nlogger = Logger.init_logger(config.app.name, config.logger)", "config = Config()\nlogger = Logger.init_logger(config.app.name, config.logger)\n\n# Create a Forwader class with context manager to handle the bridge process\n# class Forwarder:\n#     \"\"\"Forwarder class.\"\"\"\n\n#     def __init__(self, loop: AbstractEventLoop, dispatcher: EventDispatcher, config: Config):\n#         \"\"\"Initialize the Forwarder class.\"\"\"\n#         self.loop = loop", "#         \"\"\"Initialize the Forwarder class.\"\"\"\n#         self.loop = loop\n#         self.dispatcher = dispatcher\n#         self.config = config\n#         self.telegram_client: TelegramClient\n#         self.discord_client: discord.Client\n\n#     async def __aenter__(self):\n#         \"\"\"Enter the context manager.\"\"\"\n#         # Start the Telegram client", "#         \"\"\"Enter the context manager.\"\"\"\n#         # Start the Telegram client\n#         self.telegram_client = await start_telegram_client(config=self.config, event_loop=self.loop)\n\n#         # Start the Discord client\n#         self.discord_client = await start_discord(self.config)\n\n#         # Start the healthcheck\n#         self.loop.create_task(healthcheck(self.dispatcher, self.telegram_client, self.discord_client))\n", "#         self.loop.create_task(healthcheck(self.dispatcher, self.telegram_client, self.discord_client))\n\n#         # Start the bridge\n#         self.loop.create_task(start(self.telegram_client, self.discord_client, self.dispatcher))\n\n#         return self\n\n#     async def __aexit__(self, exc_type, exc_val, exc_tb):\n#         \"\"\"Exit the context manager.\"\"\"\n#         # Stop the Telegram client", "#         \"\"\"Exit the context manager.\"\"\"\n#         # Stop the Telegram client\n#         if self.telegram_client is not None and self.telegram_client.is_connected():\n#             await self.telegram_client.disconnect()\n\n#         # Stop the Discord client\n#         await self.discord_client.close()\n\n\ndef create_pid_file() -> str:\n    \"\"\"Create a PID file.\"\"\"\n    logger.debug(\"Creating PID file.\")\n    # Get the process ID.\n    pid = os.getpid()\n\n    # Create the PID file.\n    bot_pid_file = f'{config.app.name}.pid'\n    process_state, _ = determine_process_state(bot_pid_file)\n\n    if process_state == ProcessStateEnum.RUNNING:\n        sys.exit(1)\n\n    try:\n        with open(bot_pid_file, \"w\", encoding=\"utf-8\") as pid_file:\n            pid_file.write(str(pid))\n    except OSError as err:\n        print(f\"Unable to create PID file: {err}\", flush=True)\n        sys.exit(0)\n\n    return bot_pid_file", "\ndef create_pid_file() -> str:\n    \"\"\"Create a PID file.\"\"\"\n    logger.debug(\"Creating PID file.\")\n    # Get the process ID.\n    pid = os.getpid()\n\n    # Create the PID file.\n    bot_pid_file = f'{config.app.name}.pid'\n    process_state, _ = determine_process_state(bot_pid_file)\n\n    if process_state == ProcessStateEnum.RUNNING:\n        sys.exit(1)\n\n    try:\n        with open(bot_pid_file, \"w\", encoding=\"utf-8\") as pid_file:\n            pid_file.write(str(pid))\n    except OSError as err:\n        print(f\"Unable to create PID file: {err}\", flush=True)\n        sys.exit(0)\n\n    return bot_pid_file", "\n\ndef remove_pid_file(pid_file: str):\n    \"\"\"Remove a PID file.\"\"\"\n    logger.debug(\"Removing PID file.\")\n    #determine if the pid file exists\n    if not os.path.isfile(pid_file):\n        logger.debug(\"PID file '%s' not found.\", pid_file)\n        return\n\n    try:\n        os.remove(pid_file)\n    except FileNotFoundError:\n        logger.error(\"PID file '%s' not found.\", pid_file)\n    except Exception as ex:  # pylint: disable=broad-except\n        logger.exception(ex)\n        logger.error(\"Failed to remove PID file '%s'.\", pid_file)", "\n\ndef determine_process_state(pid_file: str | None = None) -> Tuple[ProcessStateEnum, int]:\n    \"\"\"\n    Determine the state of the process.\n\n    The state of the process is determined by looking for the PID file. If the\n    PID file does not exist, the process is considered stopped. If the PID file\n    does exist, the process is considered running.\n\n    If the PID file exists and the PID of the process that created it is not\n    running, the process is considered stopped. If the PID file exists and the\n    PID of the process that created it is running, the process is considered\n    running.\n\n    :param pid_file: The path to the PID file.\n    :type pid_file: str\n    :return: A tuple containing the process state and the PID of the process\n    that created the PID file.\n    :rtype: Tuple[str, int]\n    \"\"\"\n\n    if pid_file is None:\n        pid_file = f'{config.app.name}.pid'\n\n    if not os.path.isfile(pid_file):\n        # The PID file does not exist, so the process is considered stopped.\n        return ProcessStateEnum.STOPPED, 0\n\n    pid = 0\n    try:\n        # Read the PID from the PID file.\n        with open(pid_file, \"r\", encoding=\"utf-8\") as bot_pid_file:\n            pid = int(bot_pid_file.read().strip())\n\n            # If the PID file exists and the PID of the process that created it\n            # is not running, the process is considered stopped.\n            if not psutil.pid_exists(pid):\n                return ProcessStateEnum.STOPPED, 0\n\n            # If the PID file exists and the PID of the process that created it\n            # is running, the process is considered running.\n            return ProcessStateEnum.RUNNING, pid\n    except ProcessLookupError:\n        # If the PID file exists and the PID of the process that created it is\n        # not running, the process is considered stopped.\n        return ProcessStateEnum.ORPHANED, 0\n    except PermissionError:\n        # If the PID file exists and the PID of the process that created it is\n        # running, the process is considered running.\n        return ProcessStateEnum.RUNNING, pid\n    except FileNotFoundError:\n        # The PID file does not exist, so the process is considered stopped.\n        return ProcessStateEnum.STOPPED, 0", "\ndef stop_bridge():\n    \"\"\"Stop the bridge.\"\"\"\n    pid_file = f'{config.app.name}.pid'\n\n    process_state, pid = determine_process_state(pid_file)\n    if process_state == ProcessStateEnum.STOPPED:\n        logger.warning(\n            \"PID file '%s' not found. The %s may not be running.\", pid_file, config.app.name)\n        return\n\n    try:\n        os.kill(pid, signal.SIGINT)\n        logger.warning(\"Sent SIGINT to the %s process with PID %s.\",\n                    config.app.name, pid)\n\n    except ProcessLookupError:\n        logger.error(\n            \"The %s process with PID %s is not running.\", config.app.name, pid)", "\n\nasync def on_shutdown(telegram_client, discord_client):\n    \"\"\"Shutdown the bridge.\"\"\"\n    logger.info(\"Starting shutdown process...\")\n    task = asyncio.current_task()\n    all_tasks = asyncio.all_tasks()\n\n    try:\n        logger.info(\"Disconnecting Telegram client...\")\n        await telegram_client.disconnect()\n        logger.info(\"Telegram client disconnected.\")\n    except (Exception, asyncio.CancelledError) as ex:  # pylint: disable=broad-except\n        logger.error(\"Error disconnecting Telegram client: %s\", {ex})", "    try:\n        logger.info(\"Disconnecting Telegram client...\")\n        await telegram_client.disconnect()\n        logger.info(\"Telegram client disconnected.\")\n    except (Exception, asyncio.CancelledError) as ex:  # pylint: disable=broad-except\n        logger.error(\"Error disconnecting Telegram client: %s\", {ex})\n\n    try:\n        logger.info(\"Disconnecting Discord client...\")\n        await discord_client.close()\n        logger.info(\"Discord client disconnected.\")\n    except (Exception, asyncio.CancelledError) as ex:  # pylint: disable=broad-except\n        logger.error(\"Error disconnecting Discord client: %s\", {ex})", "\n    # if not config.api.enabled:\n    for running_task in all_tasks:\n        if running_task is not task and not running_task.done() and not running_task.cancelled():\n            if task is not None:\n                logger.debug(\"Cancelling task %s...\", {running_task})\n                try:\n                    task.cancel()\n                except Exception as ex:  # pylint: disable=broad-except\n                    logger.error(\"Error cancelling task %s: %s\", {\n                                running_task}, {ex})", "\n\n    if not config.api.enabled:\n        logger.debug(\"Stopping event loop...\")\n        asyncio.get_running_loop().stop()\n    else:\n        remove_pid_file(f'{config.app.name}.pid')\n\n    logger.info(\"Shutdown process completed.\")\n", "    logger.info(\"Shutdown process completed.\")\n\n\nasync def shutdown(sig, tasks_loop: asyncio.AbstractEventLoop):\n    \"\"\"Shutdown the application gracefully.\"\"\"\n    logger.warning(\"shutdown received signal %s, shutting down...\", {sig})\n\n    # Cancel all tasks\n    tasks = [task for task in asyncio.all_tasks(\n    ) if task is not asyncio.current_task()]", "    tasks = [task for task in asyncio.all_tasks(\n    ) if task is not asyncio.current_task()]\n\n    for task in tasks:\n        task.cancel()\n\n    # Wait for all tasks to be cancelled\n    results = await asyncio.gather(*tasks, return_exceptions=config.app.debug)\n\n    # Check for errors\n    for result in results:\n        if isinstance(result, asyncio.CancelledError):\n            continue\n        if isinstance(result, Exception):\n            logger.error(\"Error during shutdown: %s\", result)", "\n    # Check for errors\n    for result in results:\n        if isinstance(result, asyncio.CancelledError):\n            continue\n        if isinstance(result, Exception):\n            logger.error(\"Error during shutdown: %s\", result)\n\n    if not config.api.enabled:\n        # Stop the loop\n        if tasks_loop is not None:\n            tasks_loop.stop()", "    if not config.api.enabled:\n        # Stop the loop\n        if tasks_loop is not None:\n            tasks_loop.stop()\n\n    remove_pid_file(f'{config.app.name}.pid')\n\n\nasync def handle_signal(sig, tgc: TelegramClient, dcl: discord.Client, tasks):\n    \"\"\"Handle graceful shutdown on received signal.\"\"\"", "async def handle_signal(sig, tgc: TelegramClient, dcl: discord.Client, tasks):\n    \"\"\"Handle graceful shutdown on received signal.\"\"\"\n    logger.warning(\"Received signal %s, shutting down...\", {sig})\n\n    # Disconnect clients\n    if tgc.is_connected():\n        tgc.disconnect()\n    if dcl.is_ready():\n        await dcl.close()\n", "\n    # Cancel all tasks\n    await asyncio.gather(*tasks, return_exceptions=config.app.debug)\n\n\nasync def init_clients(dispatcher: EventDispatcher) -> Tuple[TelegramClient, discord.Client]:\n    \"\"\"Handle the initialization of the bridge's clients.\"\"\"\n\n    lock = asyncio.Lock()\n    await lock.acquire()", "    lock = asyncio.Lock()\n    await lock.acquire()\n    event_loop = asyncio.get_event_loop()\n\n    telegram_client_instance = await start_telegram_client(config, event_loop)\n    discord_client_instance = await start_discord(config)\n\n    # context = {\n    #     'telegram_client': telegram_client_instance,\n    #     'discord_client': discord_client_instance,", "    #     'telegram_client': telegram_client_instance,\n    #     'discord_client': discord_client_instance,\n    #     'dispatcher': dispatcher\n    # }\n\n    lock.release()\n\n    # Set signal handlers for graceful shutdown on received signal (except on Windows)\n    # NOTE: This is not supported on Windows\n    if os.name != 'nt' and not config.api.enabled:\n        for sig in (signal.SIGINT, signal.SIGTERM):\n            event_loop.add_signal_handler(\n                sig, lambda sig=sig: asyncio.create_task(shutdown(sig, tasks_loop=event_loop)))  # type: ignore", "    # NOTE: This is not supported on Windows\n    if os.name != 'nt' and not config.api.enabled:\n        for sig in (signal.SIGINT, signal.SIGTERM):\n            event_loop.add_signal_handler(\n                sig, lambda sig=sig: asyncio.create_task(shutdown(sig, tasks_loop=event_loop)))  # type: ignore\n    if config.api.enabled:\n        for sig in (signal.SIGINT, signal.SIGTERM):\n            event_loop.add_signal_handler(\n                sig, lambda: asyncio.create_task(on_shutdown(telegram_client_instance, discord_client_instance)))\n\n    try:\n        lock = asyncio.Lock()\n        await lock.acquire()\n        # Create tasks for starting the main logic and waiting for clients to disconnect\n        start_task = event_loop.create_task(\n            start(telegram_client_instance, discord_client_instance, config)\n        )\n        telegram_wait_task = event_loop.create_task(\n            telegram_client_instance.run_until_disconnected()  # type: ignore\n        )\n        discord_wait_task = event_loop.create_task(\n            discord_client_instance.wait_until_ready()\n        )\n        api_healthcheck_task = event_loop.create_task(\n            healthcheck(dispatcher,\n                        telegram_client_instance,\n                        discord_client_instance, config.app.healthcheck_interval)\n        )\n        on_restored_connectivity_task = event_loop.create_task(\n            on_restored_connectivity(\n                config=config,\n                telegram_client=telegram_client_instance,\n                discord_client=discord_client_instance)\n        )\n        lock.release()\n\n        await asyncio.gather(start_task,\n                             telegram_wait_task,\n                             discord_wait_task,\n                             api_healthcheck_task,\n                             on_restored_connectivity_task, return_exceptions=config.app.debug)\n\n\n    except asyncio.CancelledError as ex:\n        logger.warning(\n            \"CancelledError caught: %s\", ex, exc_info=False)\n    except Exception as ex:  # pylint: disable=broad-except\n        logger.error(\"Error while running the bridge: %s\",\n                     ex, exc_info=config.app.debug)\n    finally:\n        await on_shutdown(telegram_client_instance, discord_client_instance)", "\n    try:\n        lock = asyncio.Lock()\n        await lock.acquire()\n        # Create tasks for starting the main logic and waiting for clients to disconnect\n        start_task = event_loop.create_task(\n            start(telegram_client_instance, discord_client_instance, config)\n        )\n        telegram_wait_task = event_loop.create_task(\n            telegram_client_instance.run_until_disconnected()  # type: ignore\n        )\n        discord_wait_task = event_loop.create_task(\n            discord_client_instance.wait_until_ready()\n        )\n        api_healthcheck_task = event_loop.create_task(\n            healthcheck(dispatcher,\n                        telegram_client_instance,\n                        discord_client_instance, config.app.healthcheck_interval)\n        )\n        on_restored_connectivity_task = event_loop.create_task(\n            on_restored_connectivity(\n                config=config,\n                telegram_client=telegram_client_instance,\n                discord_client=discord_client_instance)\n        )\n        lock.release()\n\n        await asyncio.gather(start_task,\n                             telegram_wait_task,\n                             discord_wait_task,\n                             api_healthcheck_task,\n                             on_restored_connectivity_task, return_exceptions=config.app.debug)\n\n\n    except asyncio.CancelledError as ex:\n        logger.warning(\n            \"CancelledError caught: %s\", ex, exc_info=False)\n    except Exception as ex:  # pylint: disable=broad-except\n        logger.error(\"Error while running the bridge: %s\",\n                     ex, exc_info=config.app.debug)\n    finally:\n        await on_shutdown(telegram_client_instance, discord_client_instance)", "\n    return telegram_client_instance, discord_client_instance\n\n\ndef start_bridge(dispatcher: EventDispatcher):\n    \"\"\"Start the bridge.\"\"\"\n\n    logger.info(\"Starting %s...\", config.app.name)\n\n    event_loop = asyncio.get_event_loop()\n\n    event_loop.set_debug(config.app.debug)\n    # Set the exception handler.\n    event_loop.set_exception_handler(event_loop_exception_handler)\n\n    # Create a PID file.\n    pid_file = create_pid_file()\n\n    # Create a task for the main coroutine.\n    main_task = event_loop.create_task(main(dispatcher=dispatcher))\n\n    try:\n        if event_loop.is_running():\n            logger.warning(\"Event loop is already running, not starting a new one.\")\n            main_task.done()\n        else:\n            # Run the event loop.\n            event_loop.run_forever()\n    except KeyboardInterrupt:\n        # Cancel the main task.\n        main_task.cancel()\n    except asyncio.CancelledError:\n        pass\n    except asyncio.LimitOverrunError as ex:\n        logger.error(\n            \"The event loop has exceeded the configured limit of pending tasks: %s\",\n            ex, exc_info=config.app.debug)\n    except Exception as ex:  # pylint: disable=broad-except\n        logger.error(\"Error while running the bridge: %s\",\n                     ex, exc_info=config.app.debug)\n    finally:\n        # Remove the PID file.\n        if not config.api.enabled:\n            remove_pid_file(pid_file)", "\n\ndef event_loop_exception_handler(event_loop: AbstractEventLoop | None, context):\n    \"\"\"Asyncio Event loop exception handler.\"\"\"\n    if event_loop is None:\n        event_loop = asyncio.get_event_loop()\n    try:\n        exception = context.get(\"exception\")\n        if not isinstance(exception, asyncio.CancelledError):\n            event_loop.default_exception_handler(context)\n        else:\n            # This error is expected during shutdown.\n            logger.warning(\"CancelledError caught during shutdown\")\n    except Exception as ex:  # pylint: disable=broad-except\n        logger.error(\n            \"Event loop exception handler failed: %s\",\n            ex,\n            exc_info=config.app.debug,\n        )", "\n\ndef daemonize_process():\n    \"\"\"Daemonize the process by forking and redirecting standard file descriptors.\"\"\"\n    # Fork the process and exit if we're the parent\n    pid = os.fork()\n    if pid > 0:\n        sys.exit()\n\n    # Start a new session\n    os.setsid()\n\n    # Fork again and exit if we're the parent\n    pid = os.fork()\n    if pid > 0:\n        sys.exit()\n\n    # Redirect standard file descriptors to /dev/null\n    with open(os.devnull, \"r\", encoding=\"utf-8\") as devnull:\n        os.dup2(devnull.fileno(), sys.stdin.fileno())\n    with open(os.devnull, \"w\", encoding=\"utf-8\") as devnull:\n        os.dup2(devnull.fileno(), sys.stdout.fileno())\n        os.dup2(devnull.fileno(), sys.stderr.fileno())", "\n\nasync def main(dispatcher: EventDispatcher):\n    \"\"\"Run the bridge.\"\"\"\n    clients = ()\n    try:\n        clients = await init_clients(dispatcher=dispatcher)\n    except KeyboardInterrupt:\n        logger.warning(\"Interrupted by user, shutting down...\")\n    except asyncio.CancelledError:\n        logger.warning(\"CancelledError caught, shutting down...\")\n    except RuntimeError as ex:\n        logger.error(\"RuntimeError caught: %s\", ex, exc_info=config.app.debug)\n    except OperationalError as ex:\n        logger.error(\"OperationalError caught: %s\", ex, exc_info=config.app.debug)\n    finally:\n        if clients:\n            telegram_client, discord_client = clients[0], clients[1]\n            if telegram_client and not telegram_client.is_connected() and not discord_client.is_ready():\n                clients = ()\n            else:\n                await on_shutdown(telegram_client, discord_client)\n                clients = ()", "\n\nasync def run_controller(dispatcher: EventDispatcher | None,\n                     event_loop: AbstractEventLoop | None = None,\n                     boot: bool = False,\n                     stop: bool = False,\n                     background: bool = False):\n    \"\"\"Init the bridge.\"\"\"\n    if not config.api.enabled:\n        logger.error(\"API mode is disabled, please use the CLI to start the bridge, or enable it in the config file.\")\n        if not config.logger.console:\n            print(\"API mode is disabled, please use the CLI to start the bridge, or enable it in the config file.\")\n        sys.exit(1)", "    if not config.api.enabled:\n        logger.error(\"API mode is disabled, please use the CLI to start the bridge, or enable it in the config file.\")\n        if not config.logger.console:\n            print(\"API mode is disabled, please use the CLI to start the bridge, or enable it in the config file.\")\n        sys.exit(1)\n\n    if boot:\n        logger.info(\"Booting %s...\", config.app.name)\n        logger.info(\"Version: %s\", config.app.version)\n        logger.info(\"Description: %s\", config.app.description)\n        logger.info(\"Log level: %s\", config.logger.level)\n        logger.info(\"Debug enabled: %s\", config.app.debug)\n        logger.info(\"Login through API enabled: %s\",\n                    config.api.telegram_login_enabled)\n\n        if background:\n            logger.info(\"Running %s in the background\", config.app.name)\n            if os.name != \"posix\":\n                logger.error(\n                    \"Background mode is only supported on POSIX systems\")\n                sys.exit(1)\n\n            if config.logger.console is True:\n                logger.error(\n                    \"Background mode requires console logging to be disabled\")\n                sys.exit(1)\n\n            logger.info(\"Starting %s in the background...\", config.app.name)\n            daemonize_process()\n\n        if event_loop is None:\n            try:\n                event_loop = asyncio.get_event_loop()\n            except RuntimeError:\n                logger.warning(\"No event loop found, creating a new one\")\n                event_loop = asyncio.new_event_loop()\n\n        asyncio.set_event_loop(event_loop)\n\n        if dispatcher is None:\n            dispatcher = EventDispatcher()\n\n        start_bridge(dispatcher=dispatcher)\n    elif stop:\n        stop_bridge()\n    else:\n        print(\"Please use --start or --stop flags to start or stop the bridge.\")", "\n\ndef controller(dispatcher: EventDispatcher | None,\n                     event_loop: AbstractEventLoop | None = None,\n                     boot: bool = False,\n                     stop: bool = False,\n                     background: bool = False):\n    \"\"\"Init the bridge.\"\"\"\n    if boot:\n        logger.info(\"Booting %s...\", config.app.name)\n        logger.info(\"Version: %s\", config.app.version)\n        logger.info(\"Description: %s\", config.app.description)\n        logger.info(\"Log level: %s\", config.logger.level)\n        logger.info(\"Debug enabled: %s\", config.app.debug)\n        logger.info(\"Login through API enabled: %s\",\n                    config.api.telegram_login_enabled)\n\n        if background:\n            logger.info(\"Running %s in the background\", config.app.name)\n            if os.name != \"posix\":\n                logger.error(\n                    \"Background mode is only supported on POSIX systems\")\n                sys.exit(1)\n\n            if config.logger.console is True:\n                logger.error(\n                    \"Background mode requires console logging to be disabled\")\n                sys.exit(1)\n\n            logger.info(\"Starting %s in the background...\", config.app.name)\n            daemonize_process()\n\n        if event_loop is None:\n            try:\n                event_loop = asyncio.get_event_loop()\n            except RuntimeError:\n                logger.warning(\"No event loop found, creating a new one\")\n                event_loop = asyncio.new_event_loop()\n\n            asyncio.set_event_loop(event_loop)\n\n        if dispatcher is None:\n            dispatcher = EventDispatcher()\n\n        start_bridge(dispatcher=dispatcher)\n    elif stop:\n        stop_bridge()\n    else:\n        print(\"Please use --start or --stop flags to start or stop the bridge.\")", "\n\nif __name__ == \"__main__\":\n    # extra precautions to prevent the bridge from running twice\n    if config.api.enabled:\n        logger.error(\"API mode is enabled, please use the API to start the bridge, or disable it to use the CLI.\")\n        if not config.logger.console:\n            print(\"API mode is enabled, please use the API to start the bridge, or disable it to use the CLI.\")\n        sys.exit(1)\n\n    parser = argparse.ArgumentParser(\n        description=\"Process handler for the bridge.\")\n    parser.add_argument(\"--start\", action=\"store_true\",\n                        help=\"Start the bridge.\")\n\n    parser.add_argument(\"--stop\", action=\"store_true\", help=\"Stop the bridge.\")\n\n    parser.add_argument(\"--background\", action=\"store_true\",\n                        help=\"Run the bridge in the background (forked).\")\n\n    parser.add_argument(\"--version\", action=\"store_true\",\n                        help=\"Get the Bridge version.\")\n\n    cmd_args = parser.parse_args()\n\n    if cmd_args.version:\n        print(f'The Bridge\\nv{config.app.version}')\n        sys.exit(0)\n\n    __start: bool = cmd_args.start\n    __stop: bool = cmd_args.stop\n    __background: bool = cmd_args.background\n\n    event_dispatcher = EventDispatcher()\n\n    controller(dispatcher=event_dispatcher, event_loop=asyncio.new_event_loop() ,boot=__start, stop=__stop, background=__background)", ""]}
{"filename": "tools/upload.py", "chunked_list": ["\"\"\"upload simulator.\"\"\"\nimport requests\n\nURL = 'http://localhost:8000/upload'\nFILE_PATH = '../config.yml'\n\nwith open(FILE_PATH, 'rb') as file:\n    files = {'file': (FILE_PATH, file, 'application/x-yaml')}\n    response = requests.post(URL, files=files, timeout=5)\n", "\nprint(response.json())\n"]}
{"filename": "bridge/openai_handler.py", "chunked_list": ["\"\"\"This module handles the communication with the OpenAI API.\"\"\"\nimport asyncio\nimport functools\n\nimport openai\nimport openai.error\n\nfrom bridge.config import Config\nfrom bridge.logger import Logger\n", "from bridge.logger import Logger\n\nconfig = Config()\nlogger = Logger.get_logger(config.app.name)\n\n\nopenai.api_key = config.openai.api_key\nopenai.organization = config.openai.organization\n\n", "\n\nasync def analyze_message_and_generate_suggestions(text: str) -> str:\n    \"\"\"analyze the message text and seek for suggestions.\"\"\"\n\n    loop = asyncio.get_event_loop()\n    try:\n        create_completion = functools.partial(\n            openai.Completion.create,\n            model=\"text-davinci-003\",\n            prompt=(\n                f\"Given the message: '{text}', suggest related actions and correlated articles with links:\\n\"\n                f\"Related Actions:\\n- ACTION1\\n- ACTION2\\n- ACTION3\\n\"\n                f\"Correlated Articles:\\n1. ARTICLE1_TITLE - ARTICLE1_LINK\\n\"\n                f\"2. ARTICLE2_TITLE - ARTICLE2_LINK\\n\"\n                f\"3. ARTICLE3_TITLE - ARTICLE3_LINK\\n\"\n            ),\n            temperature=0,\n            max_tokens=60,\n            top_p=1.0,\n            frequency_penalty=0.0,\n            presence_penalty=0.0\n        )\n\n        response = await loop.run_in_executor(None, create_completion)\n\n        suggestion = response.choices[0].text.strip() # type: ignore # pylint: disable=no-member\n        return suggestion\n    except openai.error.InvalidRequestError as ex:\n        logger.error(\"Invalid request error: %s\", {ex})\n        return \"Error generating suggestion: Invalid request.\"\n    except openai.error.RateLimitError as ex:\n        logger.error(\"Rate limit error: %s\", {ex})\n        return \"Error generating suggestion: Rate limit exceeded.\"\n    except openai.error.APIError as ex:\n        logger.error(\"API error: %s\", {ex})\n        return \"Error generating suggestion: API error.\"\n    except Exception as ex:  # pylint: disable=broad-except\n        logger.error(\"Error generating suggestion: %s\", {ex})\n        return \"Error generating suggestion.\"", "\n\nasync def analyze_message_sentiment(text: str) -> str:\n    \"\"\"analyze the message text and seek for suggestions.\"\"\"\n    loop = asyncio.get_event_loop()\n    try:\n        prompt = None\n        for prompt_line in config.openai.sentiment_analysis_prompt:\n            prompt = f\"{prompt} {prompt_line}\\n\"\n\n        if prompt is not None:\n            prompt = prompt.replace(\"#text_to_parse\", text)\n\n        logger.debug(\"openai_sentiment_analysis_prompt %s\", prompt)\n\n        create_completion = functools.partial(\n            openai.Completion.create,\n            model=\"text-davinci-003\",\n            prompt=(prompt),\n            temperature=0.7,\n            max_tokens=250,\n            top_p=1.0,\n            frequency_penalty=0.0,\n            presence_penalty=0.0\n        )\n\n        response = await loop.run_in_executor(None, create_completion)\n\n        suggestion = response.choices[0].text.strip() # type: ignore # pylint: disable=no-member\n        return suggestion\n    except openai.error.InvalidRequestError as ex:\n        logger.error(\"Invalid request error: %s\", {ex})\n        return \"Error generating suggestion: Invalid request.\"\n    except openai.error.RateLimitError as ex:\n        logger.error(\"Rate limit error: %s\", {ex})\n        return \"Error generating suggestion: Rate limit exceeded.\"\n    except openai.error.APIError as ex:\n        logger.error(\"API error: %s\", {ex})\n        return \"Error generating suggestion: API error.\"\n    except Exception as ex:  # pylint: disable=broad-except\n        logger.error(\"Error generating suggestion: %s\", {ex})\n        return \"Error generating suggestion.\"", ""]}
{"filename": "bridge/__init__.py", "chunked_list": ["\"\"\"the bridge.\"\"\"\n\ntry:\n    import bridge.discord_handler\n    import bridge.openai_handler\n    import bridge.telegram_handler.core\n    import bridge.utils\nexcept ImportError as ex:\n    raise ex\n", ""]}
{"filename": "bridge/utils.py", "chunked_list": ["\"\"\"Utility functions.\"\"\"\nfrom typing import List\n\nfrom discord import utils\nfrom telethon.tl.types import (MessageEntityBold, MessageEntityCode,\n                               MessageEntityItalic, MessageEntityPre,\n                               MessageEntityStrike, MessageEntityTextUrl)\n\nfrom bridge.config import Config\nfrom bridge.logger import Logger", "from bridge.config import Config\nfrom bridge.logger import Logger\n\nconfig = Config()\nlogger = Logger.get_logger(config.app.name)\n\n\ndef split_message(message: str, max_length: int = 2000) -> List[str]:\n    \"\"\"Split a message into multiple messages if it exceeds the max length.\"\"\"\n    if len(message) <= max_length:\n        return [message]\n\n    message_parts = []\n    while len(message) > max_length:\n        split_index = message[:max_length].rfind(\"\\n\")\n        if split_index == -1:\n            split_index = max_length\n\n        message_parts.append(message[:split_index])\n        message = message[split_index:].lstrip()\n\n    if message:\n        message_parts.append(message)\n\n    return message_parts", "\n\ndef apply_markdown(markdown_text, start, end, markdown_delimiters):\n    \"\"\"Apply Markdown delimiters to a text range.\"\"\"\n    return (\n        markdown_text[:start]\n        + markdown_delimiters[0]\n        + markdown_text[start:end]\n        + markdown_delimiters[1]\n        + markdown_text[end:],\n        # return added length\n        len(markdown_delimiters[0]) + len(markdown_delimiters[1]),\n    )", "\n\ndef telegram_entities_to_markdown(message_text: str, message_entities: list, strip_off_links: bool) -> str:\n    \"\"\"Convert Telegram entities to Markdown.\n\n    Args:\n        message_text: The text of the message.\n        message_entities: The entities of the message.\n        strip_off_links: Whether to strip off links.\n\n    Returns:\n        The message text in Markdown format.\n    \"\"\"\n\n    if not message_entities:\n        return message_text\n\n    markdown_map = {\n        MessageEntityBold: (\"**\", \"**\"),\n        MessageEntityItalic: (\"*\", \"*\"),\n        MessageEntityStrike: (\"~~\", \"~~\"),\n        MessageEntityCode: (\"`\", \"`\"),\n        MessageEntityPre: (\"```\", \"```\"),\n    }\n\n    # Create a list of tuples with start offset, end offset, entity type, and associated data.\n    entities = [\n        (entity.offset, entity.offset + entity.length, type(entity),\n         entity.url if isinstance(entity, MessageEntityTextUrl) else None)\n        for entity in message_entities\n    ]\n\n    # Sort entities by start offset in ascending order, and by end offset in descending order.\n    sorted_entities = sorted(entities, key=lambda e: (e[0], -e[1]))\n\n    message_text = utils.remove_markdown(\n        message_text, ignore_links=False)\n\n    offset_correction = 0\n\n    links = []  # To hold link text and URLs\n\n    for start, end, entity_type, url in sorted_entities:\n        start += offset_correction\n        end += offset_correction\n        markdown_delimiters = markdown_map.get(entity_type)\n\n        if markdown_delimiters:\n            message_text, correction = apply_markdown(\n                message_text, start, end, markdown_delimiters\n            )\n            offset_correction += correction\n        elif url:  # This is a MessageEntityTextUrl.\n            logger.debug(\"processing url: %s\", url)\n            links.append(f\"<{url}>\")\n            # No need to do anything here as we're only replacing the text with itself.\n\n    # Append the links at the end of the message\n    if links and not strip_off_links:\n        message_text += \"\\n\\n**Links**\\n\" + \"\\n\".join(links)\n\n    return message_text", ""]}
{"filename": "bridge/core.py", "chunked_list": ["\"\"\"A `bridge` to forward messages from Telegram to a Discord server.\"\"\"\n\nimport asyncio\nimport sys\nfrom typing import Any, Dict\n\nimport discord\nfrom telethon import TelegramClient, events\nfrom telethon.tl.types import Channel, InputChannel\n", "from telethon.tl.types import Channel, InputChannel\n\nfrom bridge.config import Config\nfrom bridge.discord_handler import (fetch_discord_reference,\n                                    forward_to_discord, get_mention_roles)\nfrom bridge.history import MessageHistoryHandler\nfrom bridge.logger import Logger\nfrom bridge.telegram_handler import (get_message_forward_hashtags,\n                                     handle_message_media,\n                                     process_message_text)", "                                     handle_message_media,\n                                     process_message_text)\n\ntg_to_discord_message_ids = {}\ndiscord_channel_mappings = {}\n\nlogger = Logger.get_logger(Config().app.name)\nhistory_manager = MessageHistoryHandler()\n\nqueued_events = asyncio.Queue()", "\nqueued_events = asyncio.Queue()\nqueued_event_ids = set()  # Set to store the IDs of queued events\n\n\nasync def add_to_queue(event):\n    \"\"\"Add unique events to the queue.\"\"\"\n    event_id = event.message.id  # This assumes that event.message.id is unique for each event\n    if event_id not in queued_event_ids:\n        await queued_events.put(event)\n        queued_event_ids.add(event_id)  # Add the event ID to the set\n        logger.info(\"Added event with ID %s to the queue\", event_id)\n    else:\n        logger.info(\n            \"Event with ID %s is already in the queue, skipping\", event_id)", "    if event_id not in queued_event_ids:\n        await queued_events.put(event)\n        queued_event_ids.add(event_id)  # Add the event ID to the set\n        logger.info(\"Added event with ID %s to the queue\", event_id)\n    else:\n        logger.info(\n            \"Event with ID %s is already in the queue, skipping\", event_id)\n\n\nasync def start(telegram_client: TelegramClient, discord_client: discord.Client, config: Config):", "\nasync def start(telegram_client: TelegramClient, discord_client: discord.Client, config: Config):\n    \"\"\"Start the bridge.\"\"\"\n    logger.info(\"Starting the bridge...\")\n\n    input_channels_entities = []\n\n    async for dialog in telegram_client.iter_dialogs():\n        if not isinstance(dialog.entity, Channel) and not isinstance(dialog.entity, InputChannel):\n            if config.telegram.log_unhandled_conversations:\n                logger.warning(\"Excluded dialog name: %s, id: %s, type: %s\",\n                               dialog.name, dialog.entity.id, type(dialog.entity))\n            continue", "        if not isinstance(dialog.entity, Channel) and not isinstance(dialog.entity, InputChannel):\n            if config.telegram.log_unhandled_conversations:\n                logger.warning(\"Excluded dialog name: %s, id: %s, type: %s\",\n                               dialog.name, dialog.entity.id, type(dialog.entity))\n            continue\n\n        for channel_mapping in config.telegram_forwarders:\n            forwarder_name = channel_mapping[\"forwarder_name\"]\n            tg_channel_id = channel_mapping[\"tg_channel_id\"]\n            mention_override = channel_mapping.get(\"mention_override\", [])\n            mention_override = {override[\"tag\"].lower(\n            ): override[\"roles\"] for override in mention_override}\n\n            discord_channel_config = {\n                \"discord_channel_id\": channel_mapping[\"discord_channel_id\"],\n                \"strip_off_links\": channel_mapping[\"strip_off_links\"],\n                \"mention_everyone\": channel_mapping[\"mention_everyone\"],\n                \"forward_everything\": channel_mapping.get(\"forward_everything\", False),\n                \"forward_hashtags\": channel_mapping.get(\"forward_hashtags\", []),\n                \"excluded_hashtags\": channel_mapping.get(\"excluded_hashtags\", []),\n                \"mention_override\": mention_override,\n                \"roles\": channel_mapping.get(\"roles\", []),\n            }\n\n            if tg_channel_id in {dialog.name, dialog.entity.id}:  # type: ignore\n                input_channels_entities.append(\n                    InputChannel(dialog.entity.id, dialog.entity.access_hash))  # type: ignore\n                discord_channel_mappings[forwarder_name] = discord_channel_config\n                logger.info(\"Registered TG channel '%s' with ID %s with Discord channel config %s\",\n                            dialog.name, dialog.entity.id, discord_channel_config)  # type: ignore", "\n    if not input_channels_entities:\n        logger.error(\"No input channels found, exiting\")\n        sys.exit(1)\n\n    async def dispatch_queued_events():\n        \"\"\"Dispatch queued events to Discord.\"\"\"\n        while not queued_events.empty():\n            event = await queued_events.get()\n            event_id = event.message.id", "            event = await queued_events.get()\n            event_id = event.message.id\n            logger.info(\"Dispatching queued TG message\")\n            await handle_new_message(event, config, telegram_client, discord_client)\n            # Remove the event ID from the set\n            queued_event_ids.remove(event_id)\n            queued_events.task_done()\n\n    # Create tasks for dispatch_queued_events and handle_restored_internet_connectivity\n    dispatch_task = asyncio.create_task(dispatch_queued_events())", "    # Create tasks for dispatch_queued_events and handle_restored_internet_connectivity\n    dispatch_task = asyncio.create_task(dispatch_queued_events())\n\n    @telegram_client.on(events.NewMessage(chats=input_channels_entities))\n    async def handler(event):\n        \"\"\"Handle new messages in the specified Telegram channels.\"\"\"\n        if config.discord.is_healthy is False and config.app.internet_connected is True:\n            await add_to_queue(event)\n            return\n", "\n        event_id = event.message.id\n        if event_id in queued_event_ids:\n            # If the event was previously queued but Discord is now available, remove it from the set\n            queued_event_ids.remove(event_id)\n\n        await asyncio.gather(dispatch_task, handle_new_message(event, config, telegram_client, discord_client))\n\n\nasync def handle_new_message(event, config: Config, telegram_client: TelegramClient, discord_client: discord.Client):  # pylint: disable=too-many-locals", "\nasync def handle_new_message(event, config: Config, telegram_client: TelegramClient, discord_client: discord.Client):  # pylint: disable=too-many-locals\n    \"\"\"Handle the processing of a new Telegram message.\"\"\"\n    logger.debug(\"processing Telegram message: %s\", event.message.id)\n\n    tg_channel_id = event.message.peer_id.channel_id\n\n    matching_forwarders = get_matching_forwarders(tg_channel_id, config)\n\n    if len(matching_forwarders) < 1:\n        logger.error(\n            \"No forwarders found for Telegram channel %s\", tg_channel_id)\n        return", "\n    if len(matching_forwarders) < 1:\n        logger.error(\n            \"No forwarders found for Telegram channel %s\", tg_channel_id)\n        return\n\n    for discord_channel_config in matching_forwarders:\n        forwarder_name = discord_channel_config[\"forwarder_name\"]\n        discord_channel_config = discord_channel_mappings.get(\n            forwarder_name)\n\n        if not discord_channel_config:\n            logger.error(\n                \"Discord channel not found for Telegram channel %s\", tg_channel_id, exc_info=True)\n            continue\n\n        discord_channel_id = discord_channel_config[\"discord_channel_id\"]\n\n        forwarder_config: Dict[str, Any] = {\n            \"mention_everyone\": discord_channel_config[\"mention_everyone\"],\n            \"strip_off_links\": discord_channel_config[\"strip_off_links\"],\n            \"forward_everything\": discord_channel_config[\"forward_everything\"],\n            \"allowed_forward_hashtags\": discord_channel_config[\"forward_hashtags\"],\n            \"disallowed_hashtags\": discord_channel_config[\"excluded_hashtags\"],\n            \"mention_override\": discord_channel_config[\"mention_override\"],\n            \"roles\": discord_channel_config[\"roles\"],\n        }\n\n        should_forward_message = forwarder_config[\"forward_everything\"]\n        mention_everyone = forwarder_config[\"mention_everyone\"]\n        strip_off_links = forwarder_config[\"strip_off_links\"]\n        mention_roles = []\n        message_forward_hashtags = []\n\n        logger.debug(\"strip_off_links: %s\", strip_off_links)\n\n        if forwarder_config[\"allowed_forward_hashtags\"] or forwarder_config[\"mention_override\"]:\n            message_forward_hashtags = get_message_forward_hashtags(\n                event.message)\n\n            matching_forward_hashtags = [\n                tag for tag in forwarder_config[\"allowed_forward_hashtags\"] if tag[\"name\"].lower() in message_forward_hashtags]\n\n            if len(matching_forward_hashtags) > 0:\n                should_forward_message = True\n                mention_everyone = any(tag.get(\"override_mention_everyone\", False)\n                                       for tag in matching_forward_hashtags)\n\n        if forwarder_config[\"disallowed_hashtags\"]:\n            message_forward_hashtags = get_message_forward_hashtags(\n                event.message)\n\n            matching_forward_hashtags = [\n                tag for tag in forwarder_config[\"disallowed_hashtags\"] if tag[\"name\"].lower() in message_forward_hashtags]\n\n            if len(matching_forward_hashtags) > 0:\n                should_forward_message = False\n\n        if not should_forward_message:\n            continue\n\n        discord_channel = discord_client.get_channel(discord_channel_id)\n        server_roles = discord_channel.guild.roles  # type: ignore\n\n        mention_roles = get_mention_roles(message_forward_hashtags,\n                                          discord_channel_config[\"mention_override\"],\n                                          config.discord.built_in_roles,\n                                          server_roles)\n\n        message_text = await process_message_text(\n            event, forwarder_config, mention_everyone, mention_roles, config.openai.enabled)\n\n        discord_reference = await fetch_discord_reference(event,\n                                                          forwarder_name,\n                                                          discord_channel) if event.message.reply_to_msg_id else None\n\n        if event.message.media:\n            sent_discord_messages = await handle_message_media(telegram_client, event,\n                                                               discord_channel,\n                                                               message_text,\n                                                               discord_reference)\n        else:\n            sent_discord_messages = await forward_to_discord(discord_channel,  # type: ignore\n                                                             message_text,\n                                                             reference=discord_reference)  # type: ignore\n\n        if sent_discord_messages:\n            logger.debug(\"Forwarded TG message %s to Discord channel %s\",\n                         sent_discord_messages[0].id, discord_channel_id)\n\n            logger.debug(\"Saving mapping data for forwarder %s\",\n                         forwarder_name)\n            main_sent_discord_message = sent_discord_messages[0]\n            await history_manager.save_mapping_data(forwarder_name, event.message.id,\n                                                    main_sent_discord_message.id)\n            logger.info(\"Forwarded TG message %s to Discord message %s\",\n                        event.message.id, main_sent_discord_message.id)\n        else:\n            await history_manager.save_missed_message(forwarder_name,\n                                                      event.message.id,\n                                                      discord_channel_id,\n                                                      None)\n            logger.error(\"Failed to forward TG message %s to Discord\",\n                         event.message.id, exc_info=config.app.debug)", "\n\ndef get_matching_forwarders(tg_channel_id, config: Config):\n    \"\"\"Get the forwarders that match the given Telegram channel ID.\"\"\"\n    return [forwarder_config for forwarder_config in config.telegram_forwarders if tg_channel_id == forwarder_config[\"tg_channel_id\"]]  # pylint: disable=line-too-long\n\n\nasync def on_restored_connectivity(config: Config, telegram_client: TelegramClient, discord_client: discord.Client):\n    \"\"\"Check and restore internet connectivity.\"\"\"\n    logger.debug(\"Checking for internet connectivity\")", "    \"\"\"Check and restore internet connectivity.\"\"\"\n    logger.debug(\"Checking for internet connectivity\")\n    while True:\n\n        if config.app.internet_connected and config.telegram.is_healthy is True:\n            logger.debug(\n                \"Internet connection active and Telegram is connected, checking for missed messages\")\n            try:\n                last_messages = await history_manager.get_last_messages_for_all_forwarders()\n\n                logger.debug(\"Last forwarded messages: %s\", last_messages)\n\n                for last_message in last_messages:\n                    forwarder_name = last_message[\"forwarder_name\"]\n                    last_tg_message_id = last_message[\"telegram_id\"]\n\n                    channel_id = config.get_telegram_channel_by_forwarder_name(\n                        forwarder_name)\n\n                    if channel_id:\n                        fetched_messages = await history_manager.fetch_messages_after(last_tg_message_id,\n                                                                                      channel_id,\n                                                                                      telegram_client)\n                        for fetched_message in fetched_messages:\n\n                            logger.debug(\n                                \"Recovered message %s from channel %s\", fetched_message.id, channel_id)\n                            event = events.NewMessage.Event(\n                                message=fetched_message)\n                            event.peer = await telegram_client.get_input_entity(\n                                channel_id)\n\n                            if config.discord.is_healthy is False:\n                                logger.warning(\"Discord is not available despite the connectivty is restored, queing TG message %s\",\n                                               event.message.id)\n                                await add_to_queue(event)\n                                continue\n                            # delay the message delivery to avoid rate limit and flood\n                            await asyncio.sleep(config.app.recoverer_delay)\n                            logger.debug(\n                                \"Forwarding recovered Telegram message %s\", event.message.id)\n                            await handle_new_message(event, config,\n                                                     telegram_client,\n                                                     discord_client)\n\n            except Exception as exception:  # pylint: disable=broad-except\n                logger.error(\n                    \"Failed to fetch missed messages: %s\", exception, exc_info=config.app.debug)", "\n        logger.debug(\"on_restored_connectivity will trigger again in for %s seconds\",\n                     config.app.healthcheck_interval)\n        await asyncio.sleep(config.app.healthcheck_interval)\n"]}
{"filename": "bridge/healtcheck_handler.py", "chunked_list": ["\"\"\"Handler for healthchecks\"\"\"\n\nimport asyncio\nimport socket\nfrom concurrent.futures import ThreadPoolExecutor\n\nimport discord\nfrom telethon import TelegramClient\n\nfrom bridge.config import Config", "\nfrom bridge.config import Config\nfrom bridge.discord_handler import DiscordClientHealth\nfrom bridge.events import EventDispatcher\nfrom bridge.logger import Logger\n\nconfig = Config.get_config_instance()\nlogger = Logger.get_logger(config.app.name)\n\ndiscord__client_health = DiscordClientHealth()", "\ndiscord__client_health = DiscordClientHealth()\n\nexecutor = ThreadPoolExecutor()\n\n\nasync def internet_connectivity_check() -> bool:\n    \"\"\"Check if the bridge has internet connectivity.\"\"\"\n    loop = asyncio.get_running_loop()\n    try:\n        # host = await loop.run_in_executor(executor, socket.gethostbyname, (\"one.one.one.one\"))\n        host = await loop.run_in_executor(executor, socket.gethostbyname, (\"google.com\"))\n        await loop.run_in_executor(executor, socket.create_connection, (host, 443), 5)\n        return True\n    except socket.gaierror as ex:\n        logger.error(\"Unable to resolve hostname: %s\", ex, exc_info=config.app.debug)\n        return False\n    except OSError as ex:\n        logger.error(\"Unable to reach the internetL %s\", ex, exc_info=config.app.debug)\n        return False", "    loop = asyncio.get_running_loop()\n    try:\n        # host = await loop.run_in_executor(executor, socket.gethostbyname, (\"one.one.one.one\"))\n        host = await loop.run_in_executor(executor, socket.gethostbyname, (\"google.com\"))\n        await loop.run_in_executor(executor, socket.create_connection, (host, 443), 5)\n        return True\n    except socket.gaierror as ex:\n        logger.error(\"Unable to resolve hostname: %s\", ex, exc_info=config.app.debug)\n        return False\n    except OSError as ex:\n        logger.error(\"Unable to reach the internetL %s\", ex, exc_info=config.app.debug)\n        return False", "\n\nasync def healthcheck(dispatcher: EventDispatcher, tgc: TelegramClient, dcl: discord.Client, interval: int = 30):\n    \"\"\"Check the health of the Discord and Telegram APIs periodically.\"\"\"\n    # Check for internet connectivity\n    while True:\n        try:\n            has_connectivity = await internet_connectivity_check()\n            if has_connectivity:\n                logger.debug(\"The bridge is online.\")\n                # set the internet connectivity status to True\n                config.app.internet_connected = True\n            else:\n                logger.warning(\"Unable to reach the internet.\")\n                # set the internet connectivity status to False\n                config.app.internet_connected = False\n                # wait for the specified interval\n                await asyncio.sleep(interval)\n                await healthcheck(dispatcher, tgc, dcl, interval)\n\n        except Exception as ex:  # pylint: disable=broad-except\n            logger.error(\n                \"An error occurred while checking internet connectivity: %s\", ex, exc_info=config.app.debug)", "\n        # Check Telegram API status\n        try:\n            if tgc.is_connected():\n                await tgc.get_me()\n                logger.debug(\"Telegram API is healthy.\")\n                # set the Telegram availability status to True\n                config.telegram.is_healthy = True\n        except ConnectionError as ex:\n            logger.error(\"Unable to reach the Telegram API: %s\", ex)\n            # set the Telegram availability status to False\n            config.telegram.is_healthy = False\n        except Exception as ex:  # pylint: disable=broad-except\n            logger.error(\n                \"An error occurred while connecting to the Telegram API: %s\", ex, exc_info=config.app.debug)\n            # set the Telegram availability status to False\n            config.telegram.is_healthy = False", "\n        # Check Discord API status\n        try:\n            discord_status, is_healthy = discord__client_health.report_status(\n                dcl,  config.discord.max_latency)\n            if is_healthy:\n                logger.debug(\"Discord API is healthy.\")\n                # set the Discord availability status to True\n                config.discord.is_healthy = True\n            else:\n                logger.warning(discord_status)\n                # set the Discord availability status to False\n                config.discord.is_healthy = False\n        except Exception as ex:  # pylint: disable=broad-except\n            logger.error(\n                \"An error occurred while connecting to the Discord API: %s\", ex, exc_info=config.app.debug)\n            # set the Discord availability status to False\n            config.discord.is_healthy = False", "\n        dispatcher.notify(\"healthcheck\", config)\n        # Sleep for the given interval and retry\n        await asyncio.sleep(interval)\n"]}
{"filename": "bridge/telegram_handler/__init__.py", "chunked_list": ["\"\"\"Initialize the telegram_handler module.\"\"\"\n\ntry:\n    from .core import (get_message_forward_hashtags, handle_message_media,\n                       process_media_message, process_message_text,\n                       process_url_message, start_telegram_client,\n                       check_telegram_session)\nexcept ImportError as ex:\n    raise ex\n", ""]}
{"filename": "bridge/telegram_handler/core.py", "chunked_list": ["\"\"\"Telegram handler.\"\"\"\nimport asyncio\nimport json\nimport os\nfrom asyncio.events import AbstractEventLoop\nfrom typing import Any, List\n\nfrom discord import Message\nfrom telethon import TelegramClient\nfrom telethon.errors.rpcerrorlist import (FloodWaitError,", "from telethon import TelegramClient\nfrom telethon.errors.rpcerrorlist import (FloodWaitError,\n                                          PhoneCodeInvalidError,\n                                          SessionPasswordNeededError,\n                                          SessionRevokedError)\nfrom telethon.tl.types import (MessageEntityHashtag, MessageEntityTextUrl,\n                               MessageEntityUrl)\n\nfrom bridge.config import Config\nfrom bridge.discord_handler import forward_to_discord", "from bridge.config import Config\nfrom bridge.discord_handler import forward_to_discord\nfrom bridge.logger import Logger\nfrom bridge.openai_handler import analyze_message_sentiment\nfrom bridge.utils import telegram_entities_to_markdown\n\nlogger = Logger.get_logger(Config().app.name)\n\ntg_to_discord_message_ids = {}\n", "tg_to_discord_message_ids = {}\n\n\n# Check if the session file and the auth file exist\n# to estabils the user has an active session\ndef check_telegram_session() -> bool:\n    \"\"\"Check if the Telegram session file exists.\"\"\"\n    config = Config.get_config_instance()\n    if os.path.isfile(f\"{config.app.name}.session\") and os.path.isfile(config.api.telegram_auth_file):\n        return True\n    return False", "\n\nasync def get_auth_value_from_file(key: str) -> str | int:\n    \"\"\"Wait for the auth file to be created and then read a value from it.\"\"\"\n    config = Config.get_config_instance()\n    # Wait for the auth file to be created with a timeout of 120 seconds\n    for _ in range(config.api.telegram_auth_request_expiration):\n        if os.path.isfile(config.api.telegram_auth_file):\n            with open(config.api.telegram_auth_file, 'r', encoding=\"utf-8\") as auth_file:\n                value = json.load(auth_file).get(key)\n            if value:\n                logger.debug(\"Got the Telegram %s\", key)\n                return value\n        await asyncio.sleep(1)", "    raise TimeoutError(f\"Timeout waiting for {key}\")\n\n\nasync def get_telegram_password(api_auth: bool) -> str:\n    \"\"\"Get the Telegram password from the API payload,\n    the `TELEGRAM_PASSWORD` environment variable, or the config file.\"\"\"\n    telegram_password = os.getenv(\"TELEGRAM_PASSWORD\", None)\n    logger.debug(\"Attempting to get the Telegram password\")\n    if telegram_password is not None:\n        return telegram_password", "    if telegram_password is not None:\n        return telegram_password\n    config = Config.get_config_instance()\n    if not api_auth:\n        return config.telegram.password\n\n    telegram_password = await get_auth_value_from_file('password')\n    return str(telegram_password)\n\n", "\n\nasync def get_telegram_auth_code(api_auth: bool) -> str | int:\n    \"\"\"Get the Telegram auth code from the API payload, or the user's input.\"\"\"\n    logger.debug(\"Attempting to get the Telegram auth code\")\n    if api_auth:\n        return await get_auth_value_from_file('code')\n\n    code = input(\"Enter the Telegram 2FA code: \")\n    if not code:\n        raise ValueError(\"No code was entered.\")", "    code = input(\"Enter the Telegram 2FA code: \")\n    if not code:\n        raise ValueError(\"No code was entered.\")\n\n    return code\n\n\nasync def start_telegram_client(config: Config, event_loop: AbstractEventLoop | None = None) -> TelegramClient: # pylint: disable=too-many-statements\n    \"\"\"Start the Telegram client.\"\"\"\n    logger.info(\"Starting Telegram client...\")", "    \"\"\"Start the Telegram client.\"\"\"\n    logger.info(\"Starting Telegram client...\")\n\n    if event_loop is None:\n        logger.debug(\"Creating a new event loop for Telegram client\")\n        event_loop = asyncio.get_event_loop()\n\n    # telethon_logger = Logger.get_telethon_logger()\n    # telethon_logger_handler = Logger.generate_handler(\n    #     f\"{config.app.name}_telegram\", config.logger)", "    # telethon_logger_handler = Logger.generate_handler(\n    #     f\"{config.app.name}_telegram\", config.logger)\n    # telethon_logger.addHandler(telethon_logger_handler)\n\n    telegram_client = TelegramClient(\n        session=config.app.name,\n        api_id=config.telegram.api_id,\n        api_hash=config.telegram.api_hash,\n        connection_retries=15,\n        retry_delay=4,", "        connection_retries=15,\n        retry_delay=4,\n        # base_logger=telethon_logger,\n        lang_code=\"en\",\n        system_lang_code=\"en\",\n        loop=event_loop,)\n\n    telegram_client.parse_mode = \"markdown\"\n    await telegram_client.connect()\n", "    await telegram_client.connect()\n\n    logger.info(\"Signing in to Telegram...\")\n\n    def code_callback():\n        return get_telegram_auth_code(config.api.telegram_login_enabled)\n\n    try:\n        await telegram_client.start(\n            phone=config.telegram.phone,\n            code_callback=code_callback,  # type: ignore\n            password=lambda: get_telegram_password(config.api.telegram_login_enabled))  # type: ignore\n    except FloodWaitError as ex:\n        logger.error(\"Telegram client failed to start: %s\",\n                     ex, exc_info=config.app.debug)\n\n        logger.warning(\n            \"Retrying Telegram client start in %s seconds\", ex.seconds)\n        await asyncio.sleep(ex.seconds)\n        await telegram_client.start(\n            phone=config.telegram.phone,\n            code_callback=code_callback,  # type: ignore\n            password=lambda: get_telegram_password(config.api.telegram_login_enabled))  # type: ignore\n\n    except SessionPasswordNeededError:\n        logger.error(\"Telegram client failed to start: %s\",\n                     \"2FA is enabled but no password was provided\",\n                     exc_info=config.app.debug)\n        # append to the json file that 2FA is enabled\n        if os.path.isfile(config.api.telegram_auth_file) and config.api.telegram_login_enabled:\n            with open(config.api.telegram_auth_file, 'r', encoding=\"utf-8\") as auth_file:\n                auth_data = json.load(auth_file)\n            auth_data[\"mfa_required\"] = True\n            auth_data[\"error\"] = \"2FA is enabled but no password was provided\"\n            with open(config.api.telegram_auth_file, 'w', encoding=\"utf-8\") as auth_file:\n                json.dump(auth_data, auth_file)\n        raise\n\n    except SessionRevokedError:\n        logger.error(\"Telegram client failed to start: %s\",\n                     \"The current session was revoked\",\n                     exc_info=config.app.debug)\n        if os.path.isfile(config.api.telegram_auth_file) and config.api.telegram_login_enabled:\n            # append to the json file that the session was revoked\n            with open(config.api.telegram_auth_file, 'r', encoding=\"utf-8\") as auth_file:\n                auth_data = json.load(auth_file)\n            auth_data[\"session_revoked\"] = True\n            auth_data[\"error\"] = \"The current session was revoked\"\n            with open(config.api.telegram_auth_file, 'w', encoding=\"utf-8\") as auth_file:\n                json.dump(auth_data, auth_file)\n        raise\n    except PhoneCodeInvalidError:\n        logger.error(\"Telegram client failed to start: %s\",\n                     \"The phone code is invalid\",\n                     exc_info=config.app.debug)\n        if os.path.isfile(config.api.telegram_auth_file) and config.api.telegram_login_enabled:\n            # append to the json file that the phone code is invalid\n            with open(config.api.telegram_auth_file, 'r', encoding=\"utf-8\") as auth_file:\n                auth_data = json.load(auth_file)\n            auth_data[\"phone_code_invalid\"] = True\n            auth_data[\"error\"] = \"The phone code is invalid\"\n            with open(config.api.telegram_auth_file, 'w', encoding=\"utf-8\") as auth_file:\n                json.dump(auth_data, auth_file)\n        raise", "\n    # os.remove(config.telegram.auth_file)\n\n    bot_identity = await telegram_client.get_me(input_peer=False)\n    logger.info(\"Telegram client started the session: %s, with identity: %s\",\n                config.app.name, bot_identity.id)  # type: ignore\n\n    return telegram_client\n\n\ndef get_message_forward_hashtags(message):\n    \"\"\"Get forward_hashtags from a message.\"\"\"\n    entities = message.entities or []\n    forward_hashtags = [entity for entity in entities if isinstance(\n        entity, MessageEntityHashtag)]\n\n    return [message.text[hashtag.offset:hashtag.offset + hashtag.length] for hashtag in forward_hashtags]   # pylint: disable=line-too-long", "\n\ndef get_message_forward_hashtags(message):\n    \"\"\"Get forward_hashtags from a message.\"\"\"\n    entities = message.entities or []\n    forward_hashtags = [entity for entity in entities if isinstance(\n        entity, MessageEntityHashtag)]\n\n    return [message.text[hashtag.offset:hashtag.offset + hashtag.length] for hashtag in forward_hashtags]   # pylint: disable=line-too-long\n", "\n\nasync def process_message_text(event, forwarder_config: dict[str, Any],\n                               mention_everyone: bool,\n                               mention_roles: List[str],\n                               openai_enabled: bool) -> str:  # pylint: disable=too-many-arguments\n    \"\"\"Process the message text and return the processed text.\"\"\"\n    message_text = event.message.message\n\n    if openai_enabled:\n        suggestions = await analyze_message_sentiment(message_text)\n        message_text = f'{message_text}\\n{suggestions}'", "\n    if openai_enabled:\n        suggestions = await analyze_message_sentiment(message_text)\n        message_text = f'{message_text}\\n{suggestions}'\n\n    if mention_everyone:\n        message_text += '\\n' + '@everyone'\n\n    if mention_roles:\n        mention_text = \", \".join(role for role in mention_roles)\n        message_text = f\"{mention_text}\\n{message_text}\"", "    if mention_roles:\n        mention_text = \", \".join(role for role in mention_roles)\n        message_text = f\"{mention_text}\\n{message_text}\"\n\n    return telegram_entities_to_markdown(message_text, event.message.entities,\n                                         forwarder_config[\"strip_off_links\"])\n\n\nasync def process_media_message(telegram_client: TelegramClient,\n                                event, discord_channel,", "async def process_media_message(telegram_client: TelegramClient,\n                                event, discord_channel,\n                                message_text, discord_reference):\n    \"\"\"Process a message that contains media.\"\"\"\n    file_path = await telegram_client.download_media(event.message)\n    try:\n        with open(file_path, \"rb\") as image_file:  # type: ignore\n            sent_discord_messages = await forward_to_discord(discord_channel,\n                                                             message_text,\n                                                             image_file=image_file,\n                                                             reference=discord_reference)\n    except OSError as ex:\n        logger.error(\n            \"An error occurred while opening the file %s: %s\",  file_path, ex)\n        return\n    finally:\n        os.remove(file_path)  # type: ignore", "\n    return sent_discord_messages\n\n\nasync def handle_message_media(telegram_client: TelegramClient, event,\n                               discord_channel, message_text,\n                               discord_reference) -> List[Message] | None:\n    \"\"\"Handle a message that contains media.\"\"\"\n    contains_url = any(isinstance(entity, (MessageEntityTextUrl,\n                                           MessageEntityUrl))", "    contains_url = any(isinstance(entity, (MessageEntityTextUrl,\n                                           MessageEntityUrl))\n                       for entity in event.message.entities or [])\n\n    if contains_url:\n        sent_discord_messages = await process_url_message(discord_channel,\n                                                          message_text,\n                                                          discord_reference)\n    else:\n        sent_discord_messages = await process_media_message(telegram_client,\n                                                            event,\n                                                            discord_channel,\n                                                            message_text,\n                                                            discord_reference)", "\n    return sent_discord_messages\n\n\nasync def process_url_message(discord_channel, message_text, discord_reference):\n    \"\"\"Process a message that contains a URL.\"\"\"\n    sent_discord_messages = await forward_to_discord(discord_channel,\n                                                     message_text,\n                                                     reference=discord_reference)\n    return sent_discord_messages", "                                                     reference=discord_reference)\n    return sent_discord_messages\n"]}
{"filename": "bridge/config/config.py", "chunked_list": ["\"\"\"Configuration handler.\"\"\"\nfrom __future__ import annotations\n\nimport os\nimport sys\nfrom typing import Any, Dict, List, Tuple\n\nimport yaml\n\n\nclass AppConfig():  # pylint: disable=too-few-public-methods\n    \"\"\"Application configuration handler.\"\"\"\n\n    def __init__(self, config_data):\n        self.name: str = config_data[\"name\"]\n        self.version: str = config_data[\"version\"]\n        self.description: str = config_data[\"description\"]\n        self.debug: bool = config_data[\"debug\"]\n        self.internet_connected: bool = False\n        self.healthcheck_interval = config_data[\"healthcheck_interval\"]\n        self.recoverer_delay: float = config_data[\"recoverer_delay\"]", "\n\nclass AppConfig():  # pylint: disable=too-few-public-methods\n    \"\"\"Application configuration handler.\"\"\"\n\n    def __init__(self, config_data):\n        self.name: str = config_data[\"name\"]\n        self.version: str = config_data[\"version\"]\n        self.description: str = config_data[\"description\"]\n        self.debug: bool = config_data[\"debug\"]\n        self.internet_connected: bool = False\n        self.healthcheck_interval = config_data[\"healthcheck_interval\"]\n        self.recoverer_delay: float = config_data[\"recoverer_delay\"]", "\n\nclass APIConfig():  # pylint: disable=too-few-public-methods\n    \"\"\"API configuration handler.\"\"\"\n\n    def __init__(self, config_data):\n        self.enabled = config_data[\"enabled\"]\n        self.cors_origins: List[str] = config_data[\"cors_origins\"]\n        self.telegram_login_enabled: bool = config_data[\"telegram_login_enabled\"]\n        self.telegram_auth_file: str = config_data[\"telegram_auth_file\"]\n        self.telegram_auth_request_expiration: int = config_data[\"telegram_auth_request_expiration\"]", "\n\nclass LoggerConfig():  # pylint: disable=too-few-public-methods\n    \"\"\"Logger configuration handler.\"\"\"\n\n    def __init__(self, config_data):\n        self.level = config_data[\"level\"]\n        self.file_max_bytes = config_data[\"file_max_bytes\"]\n        self.file_backup_count = config_data[\"file_backup_count\"]\n        self.format = config_data[\"format\"]\n        self.date_format = config_data[\"date_format\"]\n        self.console = config_data[\"console\"]", "\n\nclass TelegramConfig():  # pylint: disable=too-few-public-methods\n    \"\"\"Telegram configuration handler.\"\"\"\n\n    def __init__(self, config_data):\n        self.is_healthy: bool = False\n        self.phone = config_data[\"phone\"]\n        self.password: str = config_data[\"password\"]\n        self.api_id: int = config_data[\"api_id\"]\n        self.api_hash: str = config_data[\"api_hash\"]\n        self.log_unhandled_conversations: bool = config_data[\"log_unhandled_conversations\"]", "\n\nclass DiscordConfig():  # pylint: disable=too-few-public-methods\n    \"\"\"Discord configuration handler.\"\"\"\n\n    def __init__(self, config_data):\n        self.is_healthy: bool = False\n        self.bot_token: str = config_data[\"bot_token\"]\n        self.built_in_roles: List[str] = config_data[\"built_in_roles\"]\n        self.max_latency: float = config_data[\"max_latency\"]", "\n\nclass OpenAIConfig():  # pylint: disable=too-few-public-methods\n    \"\"\"OpenAI configuration handler.\"\"\"\n\n    def __getitem__(self, key: str) -> str:\n        return getattr(self, key)\n\n    def __init__(self, config_data):\n        self.is_healthy: bool = True\n        self.api_key: str = config_data[\"api_key\"]\n        self.organization: str = config_data[\"organization\"]\n        self.enabled: bool = config_data[\"enabled\"]\n        self.sentiment_analysis_prompt = config_data[\"sentiment_analysis_prompt\"]", "\n\nclass Config:  # pylint: disable=too-many-instance-attributes\n    \"\"\"Configuration handler.\"\"\"\n\n    _instances: Dict[str, 'Config'] = {}\n    _file_path = os.path.join(\n        os.path.curdir,\n        \"config.yml\",\n    )\n\n    def __new__(cls):\n        \"\"\"Creates a new Config instance.\"\"\"\n        if None not in cls._instances:\n            instance = super().__new__(cls)\n            instance._initialized = False\n            cls._instances[\"\"] = instance\n        return cls._instances[\"\"]\n\n    def __init__(self):\n        \"\"\"Initializes a new Config instance.\"\"\"\n        if not self._initialized:\n            self._initialized = True\n\n            self.app: AppConfig\n            self.api: APIConfig\n            self.logger: LoggerConfig\n            self.telegram: TelegramConfig\n            self.discord: DiscordConfig\n            self.openai: OpenAIConfig\n            self.telegram_forwarders = []\n\n            self.load()\n\n    def set_file_path(self, version: str):\n        \"\"\"Set the file path based on the version.\"\"\"\n        if version:\n            self._file_path = os.path.join(\n                os.path.curdir,\n                f\"config-{version}.yml\",\n            )\n        else:\n            self._file_path = os.path.join(\n                os.path.curdir,\n                \"config.yml\",\n            )\n\n    def set_version(self, version: str):\n        \"\"\"Set the version of the configuration.\"\"\"\n        if version not in Config._instances:\n            Config._instances[version] = Config()\n        Config._instances[version].set_file_path(version)\n        Config._instances[version].load()\n        return Config._instances[version]\n\n    @staticmethod\n    def get_config_instance(version: str | None = \"\") -> 'Config':\n        \"\"\"Get the configuration instance based on the version.\"\"\"\n        try:\n            return Config._instances[version] if version and version in Config._instances else Config._instances[\"\"]\n        except KeyError as ex:\n            raise ValueError(f'Invalid version: {version}') from ex\n\n    # Set the configuration instance based on the version.\n    @staticmethod\n    def set_config_instance(config: 'Config', version: str | None = \"\") -> Config:\n        \"\"\"Set the configuration instance based on the version.\"\"\"\n        if not version:\n            version = \"\"\n        if version not in Config._instances:\n            print(\"Setting config instance for version %s\", version)\n            Config._instances[version] = config\n        return config\n\n    def load(self) -> Any:\n        \"\"\"Load configuration from the 'config-{version}.yml' file.\"\"\"\n        try:\n            with open(self._file_path, 'rb') as config_file:\n                config_data = yaml.safe_load(config_file)\n        except FileNotFoundError:\n            print(\"Error: Configuration file not found.\")\n            sys.exit(1)\n        except yaml.YAMLError as ex:\n            print(\"Error parsing configuration file: %s\", ex)\n            sys.exit(1)\n\n        required_keys = [\n            \"application\",\n            \"logger\",\n            \"telegram\",\n            \"discord\",\n            \"telegram_forwarders\",\n        ]\n\n        for key in required_keys:\n            if key not in config_data:\n                print(\n                    \"Error: Key %s not found in the configuration file.\", key)\n                sys.exit(1)\n\n        valid, errors = Config.validate_config(config_data)\n\n        if not valid:\n            print(\"Error: Invalid configuration file.\")\n            for error in errors:\n                print(f\"\\n{error}\\n\")\n            sys.exit(1)\n\n        self.app = AppConfig(config_data[\"application\"])\n        self.api = APIConfig(config_data[\"api\"])\n        self.logger = LoggerConfig(config_data[\"logger\"])\n        self.telegram = TelegramConfig(config_data[\"telegram\"])\n        self.discord = DiscordConfig(config_data[\"discord\"])\n        self.openai = OpenAIConfig(config_data[\"openai\"])\n\n        self.telegram_forwarders = config_data[\"telegram_forwarders\"]\n\n        return config_data\n\n    @ staticmethod\n    def validate_openai_enabled(config: OpenAIConfig) -> Tuple[bool, str]:\n        \"\"\"Check for valid types\"\"\"\n        if config[\"enabled\"]:\n            if config[\"api_key\"] == \"\" or config[\"organization\"] == \"\" or config[\"sentiment_analysis_prompt\"] is None:\n                return False,  \"Invalid configuration: `api_key`, `organization`, and `sentiment_analysis_prompt` must be set when `enabled` is True.\"  # pylint: disable=line-too-long\n\n        return True, \"\"\n\n    @ staticmethod\n    def validate_forwarder_types(forwarder) -> Tuple[bool, str]:\n        \"\"\"Check for valid types\"\"\"\n        tg_channel_id = forwarder[\"tg_channel_id\"]\n        discord_channel_id = forwarder[\"discord_channel_id\"]\n\n        if not isinstance(tg_channel_id, int):\n            return False, f\"Invalid configuration: `tg_channel_id` must be an integer: forwarder with `tg_channel_id` {tg_channel_id}\"  # pylint: disable=line-too-long\n\n        if not isinstance(discord_channel_id, int):\n            return False, f\"Invalid configuration: `discord_channel_id` must be an integer: forwarder with `tg_channel_id` {tg_channel_id}\"  # pylint: disable=line-too-long\n\n        return True, \"\"\n\n    @ staticmethod\n    def validate_forwarder_combinations(forwarder, forwarder_combinations) -> Tuple[bool, str]:\n        \"\"\"Check for unique combination of tg_channel_id and discord_channel_id\"\"\"\n        tg_channel_id = forwarder[\"tg_channel_id\"]\n        discord_channel_id = forwarder[\"discord_channel_id\"]\n\n        combination = (tg_channel_id, discord_channel_id)\n        if combination in forwarder_combinations:\n            return False, f\"Invalid configuration: duplicate forwarder with combination {combination}\"\n\n        forwarder_combinations.add(combination)\n        return True, \"\"\n\n    @ staticmethod\n    def validate_mention_everyone_and_override(forwarder, forward_hashtags) -> Tuple[bool, str]:\n        \"\"\"Check for mention_everyone and override_mention_everyone conflict\"\"\"\n        tg_channel_id = forwarder[\"tg_channel_id\"]\n        mention_everyone = forwarder[\"mention_everyone\"]\n\n        if mention_everyone and any(tag.get(\"override_mention_everyone\", False) for tag in forward_hashtags):\n            return False, f\"Invalid configuration: `override_mention_everyone` has no effect when `mention_everyone` set to True: forwarder with `tg_channel_id` {tg_channel_id}\"  # pylint: disable=line-too-long\n\n        return True, \"\"\n\n    @ staticmethod\n    def validate_shared_hashtags(forwarders) -> Tuple[bool, str]:\n        \"\"\"Check for shared hashtags in forwarders with the same tg_channel_id\"\"\"\n        tg_channel_hashtags = {}\n        for forwarder in forwarders:\n            tg_channel_id = forwarder[\"tg_channel_id\"]\n            forward_hashtags = {tag[\"name\"].lower() for tag in forwarder.get(\n                \"forward_hashtags\", [])} if forwarder.get(\"forward_hashtags\") else set()\n\n            if forward_hashtags:  # Only process non-empty forward_hashtags\n                if tg_channel_id not in tg_channel_hashtags:\n                    tg_channel_hashtags[tg_channel_id] = [forward_hashtags]\n                else:\n                    for existing_hashtags in tg_channel_hashtags[tg_channel_id]:\n                        shared_hashtags = existing_hashtags.intersection(\n                            forward_hashtags)\n                        if shared_hashtags:\n                            return False, f\"Shared hashtags {shared_hashtags} found for forwarders with tg_channel_id {tg_channel_id}. The same message will be forwarded multiple times.\"  # pylint: disable=line-too-long\n\n                    tg_channel_hashtags[tg_channel_id].append(forward_hashtags)\n\n        return True, \"\"\n\n    @staticmethod\n    def validate_hashtags_overlap(forwarder, forward_hashtags, excluded_hashtags) -> Tuple[bool, str]:\n        \"\"\"Check for overlapping hashtags between forward_hashtags and excluded_hashtags\"\"\"\n        tg_channel_id = forwarder[\"tg_channel_id\"]\n        forward_hashtags_names = {tag[\"name\"].lower()\n                                  for tag in forward_hashtags}\n        excluded_hashtags_names = {tag[\"name\"].lower()\n                                   for tag in excluded_hashtags}\n        common_hashtags = forward_hashtags_names.intersection(\n            excluded_hashtags_names)\n        if common_hashtags:\n            return False, f\"Invalid configuration: overlapping hashtags {common_hashtags} found in forward_hashtags and excluded_hashtags for forwarder with `tg_channel_id` {tg_channel_id}\"  # pylint: disable=line-too-long\n\n        return True, \"\"\n\n    @ staticmethod\n    def validate_config(config) -> Tuple[bool, List[str]]:\n        \"\"\"Validate the configuration.\"\"\"\n        forwarders = config[\"telegram_forwarders\"]\n        forwarder_combinations = set()\n\n        valid = True\n        errors: List[str] = []\n\n        valid, error = Config.validate_openai_enabled(config[\"openai\"])\n        if not valid:\n            errors.append(error)\n\n        forwarder_error_string = \"Invalid forwarder configuration:\"\n        for forwarder in forwarders:\n            forwarder_error_string = f\"{forwarder_error_string} forwarder name: {forwarder['forwarder_name']}\"\n\n            forward_hashtags = Config.get_forward_hashtags(forwarder)\n\n            if len(forward_hashtags) <= 0 and forwarder[\"forward_everything\"] is False:\n                valid = False\n                errors.append(\n                    f'{forwarder_error_string} `forward_hashtags` must be set when `forward_everything` is False')  # pylint: disable=line-too-long\n\n            excluded_hashtags = Config.get_excluded_hashtags(forwarder)\n\n            valid, error = Config.validate_forwarder_types(forwarder)\n            if not valid:\n                errors.append(f\"{forwarder_error_string} {error}\")\n\n            valid, error = Config.validate_forwarder_combinations(\n                forwarder, forwarder_combinations)\n            if not valid:\n                errors.append(f\"{forwarder_error_string} {error}\")\n\n            valid, error = Config.validate_mention_everyone_and_override(\n                forwarder, forward_hashtags)\n            if not valid:\n                errors.append(f\"{forwarder_error_string} {error}\")\n\n            valid, error = Config.validate_hashtags_overlap(\n                forwarder, forward_hashtags, excluded_hashtags)\n            if not valid:\n                errors.append(f\"{forwarder_error_string} {error}\")\n\n        valid, error = Config.validate_shared_hashtags(forwarders)\n        if not valid:\n            errors.append(error)\n\n        valid = not errors\n        return valid, errors\n\n    @staticmethod\n    def get_excluded_hashtags(forwarder):\n        \"\"\"Get exclude_hashtags from forwarder or set an empty list.\"\"\"\n        if \"excluded_hashtags\" in forwarder:\n            excluded_hashtags = forwarder[\"excluded_hashtags\"]\n        else:\n            excluded_hashtags = []\n\n        return excluded_hashtags\n\n    @ staticmethod\n    def get_forward_hashtags(forwarder):\n        \"\"\"Get forward_hashtags from forwarder or set an empty list.\"\"\"\n        if \"forward_hashtags\" in forwarder:\n            forward_hashtags = forwarder[\"forward_hashtags\"]\n        else:\n            forward_hashtags = []\n\n        return forward_hashtags\n\n    def get_telegram_channel_by_forwarder_name(self, forwarder_name: str):\n        \"\"\"Get the Telegram channel ID associated with a given forwarder ID.\"\"\"\n        for forwarder in self.telegram_forwarders:\n            if forwarder.get(\"forwarder_name\") == forwarder_name:\n                return forwarder.get(\"tg_channel_id\")\n        return None", ""]}
{"filename": "bridge/config/__init__.py", "chunked_list": ["\"\"\"Initialize the config module.\"\"\"\n\ntry:\n    from .config import Config, LoggerConfig\nexcept ImportError as ex:\n    raise ex\n"]}
{"filename": "bridge/events/events.py", "chunked_list": ["\"\"\"Event dispatcher for the bridge.\"\"\"\n\nfrom __future__ import annotations\n\nimport asyncio\nfrom abc import ABC, abstractmethod\nfrom typing import Any, Callable, Dict, List\n\nfrom bridge.config import Config\nfrom bridge.logger import Logger", "from bridge.config import Config\nfrom bridge.logger import Logger\n\nlogger = Logger.get_logger(Config.get_config_instance().app.name)\n\n\nclass EventDispatcher:\n    \"\"\"Event dispatcher class.\"\"\"\n\n    def __init__(self, subscribers=None):\n        # a list of subscribers\n        self.subscribers: Dict[str, List[EventSubscriber]] = subscribers or {}\n\n    def add_subscriber(self, event: str, subscriber):\n        \"\"\"Add a subscriber to the event dispatcher.\n        \n        Args:\n            event: The event to subscribe to.\n            subscriber: The subscriber to add.\n        \"\"\"\n        logger.debug(\"Adding subscriber: %s\", subscriber)\n        if self.subscribers.get(event) is None:\n            self.subscribers[event] = []\n\n        if subscriber not in self.subscribers[event]:\n            try:\n                self.subscribers[event].append(subscriber)\n                logger.info(\"Subscriber added: %s\", subscriber)\n            except KeyError:\n                self.subscribers[event] = [subscriber]\n                logger.info(\"Subscriber added: %s\", subscriber)\n        else:\n            logger.info(\"Subscriber already exists: %s\", subscriber)\n\n    def remove_subscriber(self, event, subscriber):\n        \"\"\"Remove a subscriber from the event dispatcher.\"\"\"\n        if event in self.subscribers and subscriber in self.subscribers[event]:\n            self.subscribers[event].remove(subscriber)\n            logger.info(\"Subscriber removed: %s\", subscriber)\n        else:\n            logger.info(\"Subscriber not found: %s\", subscriber)\n\n    def notify(self, event, data=None):\n        \"\"\"Notify subscribers of an event.\"\"\"\n        logger.debug(\"Event dispatcher notified of event: %s - data: %s\", event, data)\n\n        if event in self.subscribers:\n            for subscriber in self.subscribers[event]:\n                logger.debug(\"Event dispatcher notifying subscriber: %s\", subscriber)\n\n                try:\n                    if hasattr(subscriber, \"update\"):\n                        # asyncio.create_task(subscriber.update(event, data))\n                        subscriber.update(event, data)\n                except EventDispatcherException as ex:\n                    message = \"The event dispatcher failed to notify its subscribers\"\n                    logger.error(\"%s - event: %s - error: %s\",  message, event, ex, exc_info=Config.get_config_instance().app.debug)\n                    # raise EventDispatcherException(message=message) from ex\n                except Exception as ex: # pylint: disable=broad-except\n                    message = \"The event dispatcher failed to notify its subscribers\"\n                    logger.error(\"%s - event: %s - error: %s\",  message, event, ex, exc_info=Config.get_config_instance().app.debug)\n                    # raise EventDispatcherException(message=message) from ex\n                else:\n                    logger.debug(\"Event dispatcher successfully notified subscriber: %s\", subscriber)\n                finally:\n                    logger.debug(\"Event dispatcher finished notifying subscriber: %s\", subscriber)\n        else:\n            logger.info(\"Event dispatcher has no subscribers for event: %s\", event)\n\n    def stop(self):\n        \"\"\"Stop the event dispatcher.\"\"\"\n        logger.debug(\"Stopping event dispatcher\")\n        self.subscribers.clear()\n        logger.info(\"Event dispatcher stopped\")", "\nclass EventDispatcherException(Exception):\n    \"\"\"Event dispatcher exception class.\"\"\"\n\n    def __init__(self, message):\n        \"\"\"Initialize the event dispatcher exception.\n        \n        Args:\n            message: The message of the event dispatcher exception.\n        \"\"\"\n        super().__init__(message)\n        self.message = message\n\n    def __str__(self):\n        \"\"\"Return the string representation of the event dispatcher exception.\"\"\"\n        return self.message\n\n    def __iter__(self):\n        \"\"\"Return the iterator for the event dispatcher exception.\"\"\"\n        return iter(self.message)\n\n    def __eq__(self, other):\n        \"\"\"Return whether this event dispatcher exception is equal to another object.\n        \n        Args:\n            other: The other object.\n        \"\"\"\n        if not isinstance(other, EventDispatcherException):\n            return False\n        return self.message == other.message\n\n    def __ne__(self, other):\n        \"\"\"Return whether this event dispatcher exception is not equal to another object.\n        \n        Args:\n            other: The other object.\n        \"\"\"\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        \"\"\"Return the hash of this event dispatcher exception.\"\"\"\n        return hash(self.message)", "\n\nclass EventSubscriber(ABC): # pylint: disable=too-few-public-methods\n    \"\"\"Event subscriber abstract base class.\"\"\"\n\n    def __init__(self, name, dispatcher: EventDispatcher, subscribers=None):\n        self.name = name\n        self.dispatcher: EventDispatcher = dispatcher\n        # self.subscribers: Dict[str, List[EventSubscriber]] = subscribers or {}\n        self.subscribers: Dict[str, Dict[str, List[Callable]]] = subscribers or {}\n\n    @abstractmethod\n    def update(self, event:str, data:Any | None = None):\n        \"\"\"\n        Update the event subscriber with a new event.\n\n        Args:\n            event (str): The event string.\n            data: The data object.\n        \"\"\"\n        if event in self.subscribers:\n            for func in self.subscribers[event]:\n                try:\n                    if asyncio.iscoroutinefunction(func) and hasattr(func, \"update\"):\n                        logger.debug(\"Event subscriber %s updating with coroutine function %s\", self.name, func)\n                        # asyncio.ensure_future(func(data))\n                        func(data) # type: ignore\n                except EventDispatcherException as ex:\n                    message = \"The event subscriber failed to update\"\n                    logger.error(\"%s - event: %s\",  message, event)\n                    raise EventDispatcherException(message=message) from ex\n\n    # Create an on_update decorator for the event subscriber.\n    def create_on_update_decorator(self):\n        \"\"\"Create an on_update decorator for the event subscriber.\"\"\"\n\n        def on_update(event: str):\n            def decorator(func):\n                def wrapper(*args, **kwargs):\n                    logger.debug(\n                        \"Decorator %s called with args %s and kwargs %s\", event, args, kwargs\n                    )\n                    result = func(*args, **kwargs)\n                    if asyncio.iscoroutine(result):\n                        result = asyncio.ensure_future(result)\n                    return result\n\n                # add the original function as a subscriber, not the wrapper\n                self.dispatcher.add_subscriber(event, wrapper)\n\n                return wrapper\n\n            return decorator\n\n        return on_update", ""]}
{"filename": "bridge/events/__init__.py", "chunked_list": ["\"\"\"The Brigde event dispatcher.\"\"\"\n\ntry:\n    from .events import (EventDispatcher, EventDispatcherException,\n                         EventSubscriber)\nexcept ImportError:\n    raise ImportError(\"Unable to import the event dispatcher.\") from None\n"]}
{"filename": "bridge/enums/request_type.py", "chunked_list": ["\"\"\"Request Type Enum\"\"\"\n\nfrom enum import Enum\n\n\nclass RequestTypeEnum(str, Enum):\n    \"\"\"Request Type Enum.\"\"\"\n    START = \"start\"\n    STOP = \"stop\"\n    RELOAD = \"reload\"\n    UPLOAD_CONFIG = \"upload_config\"\n    POST_CONFIG = \"post_config\"\n    CHANGE_CONFIG_VERSION = \"change_config_version\"", ""]}
{"filename": "bridge/enums/process_state.py", "chunked_list": ["\"\"\"Prcess State Enum\"\"\"\n\nfrom enum import Enum\n\n\nclass ProcessStateEnum(str, Enum):\n    \"\"\"Process State Enum.\"\"\"\n    RUNNING = \"running\"\n    STARTING = \"starting\"\n    STOPPED = \"stopped\"\n    STOPPING = \"stopping\"\n    PAUSED = \"paused\"\n    ORPHANED = \"orphaned\"\n    UNKNOWN = \"unknown\"", ""]}
{"filename": "bridge/enums/__init__.py", "chunked_list": ["\"\"\"Process State Enum.\"\"\"\n\ntry:\n    from .process_state import ProcessStateEnum\n    from .request_type import RequestTypeEnum\nexcept ImportError as exc:\n    raise ImportError('Failed importing ProcessStateEnum') from exc\n"]}
{"filename": "bridge/logger/formatter.py", "chunked_list": ["\"\"\"Logger formatters.\"\"\"\"\"\nimport logging\nimport sys\nfrom copy import copy\nfrom typing import Optional\n\nimport click\n\nif sys.version_info < (3, 8):  # pragma: py-gte-38\n    from typing_extensions import Literal\nelse:  # pragma: py-lt-38\n    from typing import Literal", "if sys.version_info < (3, 8):  # pragma: py-gte-38\n    from typing_extensions import Literal\nelse:  # pragma: py-lt-38\n    from typing import Literal\n\nTRACE_LOG_LEVEL = 5\n\n\nclass ColourizedFormatter(logging.Formatter):\n    \"\"\"\n    A custom log formatter class that:\n\n    * Outputs the LOG_LEVEL with an appropriate color.\n    * If a log call includes an `extras={\"color_message\": ...}` it will be used\n      for formatting the output, instead of the plain text message.\n    \"\"\"\n\n    level_name_colors = {\n        TRACE_LOG_LEVEL: lambda level_name: click.style(str(level_name), fg=\"blue\"),\n        logging.DEBUG: lambda level_name: click.style(str(level_name), fg=\"cyan\"),\n        logging.INFO: lambda level_name: click.style(str(level_name), fg=\"green\"),\n        logging.WARNING: lambda level_name: click.style(str(level_name), fg=\"yellow\"),\n        logging.ERROR: lambda level_name: click.style(str(level_name), fg=\"red\"),\n        logging.CRITICAL: lambda level_name: click.style(\n            str(level_name), fg=\"bright_red\"\n        ),\n    }\n\n    def __init__(\n        self,\n        fmt: Optional[str] = None,\n        datefmt: Optional[str] = None,\n        style: Literal[\"%\", \"{\", \"$\"] = \"%\",\n        use_colors: Optional[bool] = None,\n    ):\n        if use_colors in (True, False):\n            self.use_colors = use_colors\n        else:\n            self.use_colors = sys.stdout.isatty()\n        super().__init__(fmt=fmt, datefmt=datefmt, style=style)\n\n    def color_level_name(self, level_name: str, level_no: int) -> str:\n        \"\"\"Colorize the level name.\"\"\"\n        def default(level_name: str) -> str:\n            return str(level_name)  # pragma: no cover\n\n        func = self.level_name_colors.get(level_no, default)\n        return func(level_name)\n\n    def color_asctime(self, date: str) -> str:\n        \"\"\"Colorize the date.\"\"\"\n        return click.style(date, fg=\"bright_blue\")\n\n    def format_pid(self, pid: int) -> str:\n        \"\"\"Format the pid.\"\"\"\n        return click.style(str(pid), fg=\"blue\", bold=True)\n\n    def should_use_colors(self) -> bool:\n        \"\"\"Whether the formatter should use colors or not.\"\"\"\n        return True  # pragma: no cover\n\n    def formatMessage(self, record: logging.LogRecord) -> str:\n        recordcopy = copy(record)\n        levelname = recordcopy.levelname\n        seperator = \" \" * (8 - len(recordcopy.levelname))\n        asctime = recordcopy.asctime\n        process = recordcopy.process if recordcopy.process else 0\n        message = recordcopy.getMessage()\n\n        if self.use_colors:\n            levelname = self.color_level_name(levelname, recordcopy.levelno)\n            asctime = self.color_asctime(recordcopy.asctime)\n            process = self.format_pid(process)\n            if \"color_message\" in recordcopy.__dict__:\n                recordcopy.msg = recordcopy.__dict__[\"color_message\"]\n                recordcopy.__dict__[\"message\"] = message\n\n        recordcopy.__dict__[\"levelprefix\"] = levelname + \":\" + seperator\n        recordcopy.__dict__[\"asctime\"] = asctime + \":\"\n        recordcopy.__dict__[\"message\"] = f\"{process} - \" + message\n        return super().formatMessage(recordcopy)", "class ColourizedFormatter(logging.Formatter):\n    \"\"\"\n    A custom log formatter class that:\n\n    * Outputs the LOG_LEVEL with an appropriate color.\n    * If a log call includes an `extras={\"color_message\": ...}` it will be used\n      for formatting the output, instead of the plain text message.\n    \"\"\"\n\n    level_name_colors = {\n        TRACE_LOG_LEVEL: lambda level_name: click.style(str(level_name), fg=\"blue\"),\n        logging.DEBUG: lambda level_name: click.style(str(level_name), fg=\"cyan\"),\n        logging.INFO: lambda level_name: click.style(str(level_name), fg=\"green\"),\n        logging.WARNING: lambda level_name: click.style(str(level_name), fg=\"yellow\"),\n        logging.ERROR: lambda level_name: click.style(str(level_name), fg=\"red\"),\n        logging.CRITICAL: lambda level_name: click.style(\n            str(level_name), fg=\"bright_red\"\n        ),\n    }\n\n    def __init__(\n        self,\n        fmt: Optional[str] = None,\n        datefmt: Optional[str] = None,\n        style: Literal[\"%\", \"{\", \"$\"] = \"%\",\n        use_colors: Optional[bool] = None,\n    ):\n        if use_colors in (True, False):\n            self.use_colors = use_colors\n        else:\n            self.use_colors = sys.stdout.isatty()\n        super().__init__(fmt=fmt, datefmt=datefmt, style=style)\n\n    def color_level_name(self, level_name: str, level_no: int) -> str:\n        \"\"\"Colorize the level name.\"\"\"\n        def default(level_name: str) -> str:\n            return str(level_name)  # pragma: no cover\n\n        func = self.level_name_colors.get(level_no, default)\n        return func(level_name)\n\n    def color_asctime(self, date: str) -> str:\n        \"\"\"Colorize the date.\"\"\"\n        return click.style(date, fg=\"bright_blue\")\n\n    def format_pid(self, pid: int) -> str:\n        \"\"\"Format the pid.\"\"\"\n        return click.style(str(pid), fg=\"blue\", bold=True)\n\n    def should_use_colors(self) -> bool:\n        \"\"\"Whether the formatter should use colors or not.\"\"\"\n        return True  # pragma: no cover\n\n    def formatMessage(self, record: logging.LogRecord) -> str:\n        recordcopy = copy(record)\n        levelname = recordcopy.levelname\n        seperator = \" \" * (8 - len(recordcopy.levelname))\n        asctime = recordcopy.asctime\n        process = recordcopy.process if recordcopy.process else 0\n        message = recordcopy.getMessage()\n\n        if self.use_colors:\n            levelname = self.color_level_name(levelname, recordcopy.levelno)\n            asctime = self.color_asctime(recordcopy.asctime)\n            process = self.format_pid(process)\n            if \"color_message\" in recordcopy.__dict__:\n                recordcopy.msg = recordcopy.__dict__[\"color_message\"]\n                recordcopy.__dict__[\"message\"] = message\n\n        recordcopy.__dict__[\"levelprefix\"] = levelname + \":\" + seperator\n        recordcopy.__dict__[\"asctime\"] = asctime + \":\"\n        recordcopy.__dict__[\"message\"] = f\"{process} - \" + message\n        return super().formatMessage(recordcopy)", "\n\nclass DefaultFormatter(ColourizedFormatter):\n    \"\"\"The default formatter for the logger.\"\"\"\n    def should_use_colors(self) -> bool:\n        return sys.stderr.isatty()  # pragma: no cover\n"]}
{"filename": "bridge/logger/logger.py", "chunked_list": ["\"\"\"Create a logger for the application.\"\"\"\"\"\nimport logging\nfrom logging.handlers import RotatingFileHandler\nfrom logging import StreamHandler\nfrom bridge.config import LoggerConfig\n\nimport bridge.logger.formatter as log_formatter\n\nclass Logger(logging.Logger):\n    \"\"\"Singleton logger class. It allows to create only one instance of the logger.\"\"\"\n    _instance = None\n\n    def __new__(cls, *args):  # pylint: disable=unused-argument\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n\n    def __init__(self, name: str):\n        if not self.__dict__:\n            super().__init__(name)\n\n    def configure(self, logger_config: LoggerConfig):\n        \"\"\"Apply the logger's configuration.\"\"\"\n        level = getattr(logging, logger_config.level.upper(), None)\n\n        if level is None:\n            level = logging.INFO\n\n        # Remove all handlers associated with the logger object.\n        for logger_handler in self.handlers:\n            self.removeHandler(logger_handler)\n\n        handler = Logger.generate_handler(self.name, logger_config)\n\n        self.addHandler(handler)\n\n        # Clear handlers from the root logger\n        logging.root.handlers = []\n\n    @staticmethod\n    def generate_handler(file_name: str, logger_config: LoggerConfig) -> RotatingFileHandler | StreamHandler:\n        \"\"\"generate the handler for any external logger\"\"\"\n        level = getattr(logging, logger_config.level.upper(), None)\n\n        if level is None:\n            level = logging.INFO\n\n        formatter = log_formatter.ColourizedFormatter(use_colors=logger_config.console, fmt=logger_config.format)\n\n        if not logger_config.console:\n            # The log files will rotate when they reach 10 MB in size.\n            # The backupCount parameter is set to 5,\n            # which means that up to 5 backup files will be kept.\n            handler = RotatingFileHandler(\n                f'{file_name}.log',\n                maxBytes=logger_config.file_max_bytes,\n                backupCount=logger_config.file_backup_count)\n        else:\n            handler = logging.StreamHandler()\n\n        handler.setLevel(level)  # Set log level for the handler\n        handler.setFormatter(formatter)\n        return handler\n\n    @staticmethod\n    def get_logger(name: str) -> logging.Logger:\n        \"\"\"Get a logger for the application.\"\"\"\n        logger = Logger(name)\n        return logger\n\n    @staticmethod\n    def get_telethon_logger() -> logging.Logger:\n        \"\"\"Get the Telethon logger\"\"\"\n        logger = logging.getLogger('telethon')\n        return logger\n\n    @staticmethod\n    def init_logger(name: str, logger_config: LoggerConfig) -> logging.Logger:\n        \"\"\"Initialize a logger for the application.\"\"\"\n        logger = Logger(name)\n        logger.configure(logger_config)\n        return logger", "class Logger(logging.Logger):\n    \"\"\"Singleton logger class. It allows to create only one instance of the logger.\"\"\"\n    _instance = None\n\n    def __new__(cls, *args):  # pylint: disable=unused-argument\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n\n    def __init__(self, name: str):\n        if not self.__dict__:\n            super().__init__(name)\n\n    def configure(self, logger_config: LoggerConfig):\n        \"\"\"Apply the logger's configuration.\"\"\"\n        level = getattr(logging, logger_config.level.upper(), None)\n\n        if level is None:\n            level = logging.INFO\n\n        # Remove all handlers associated with the logger object.\n        for logger_handler in self.handlers:\n            self.removeHandler(logger_handler)\n\n        handler = Logger.generate_handler(self.name, logger_config)\n\n        self.addHandler(handler)\n\n        # Clear handlers from the root logger\n        logging.root.handlers = []\n\n    @staticmethod\n    def generate_handler(file_name: str, logger_config: LoggerConfig) -> RotatingFileHandler | StreamHandler:\n        \"\"\"generate the handler for any external logger\"\"\"\n        level = getattr(logging, logger_config.level.upper(), None)\n\n        if level is None:\n            level = logging.INFO\n\n        formatter = log_formatter.ColourizedFormatter(use_colors=logger_config.console, fmt=logger_config.format)\n\n        if not logger_config.console:\n            # The log files will rotate when they reach 10 MB in size.\n            # The backupCount parameter is set to 5,\n            # which means that up to 5 backup files will be kept.\n            handler = RotatingFileHandler(\n                f'{file_name}.log',\n                maxBytes=logger_config.file_max_bytes,\n                backupCount=logger_config.file_backup_count)\n        else:\n            handler = logging.StreamHandler()\n\n        handler.setLevel(level)  # Set log level for the handler\n        handler.setFormatter(formatter)\n        return handler\n\n    @staticmethod\n    def get_logger(name: str) -> logging.Logger:\n        \"\"\"Get a logger for the application.\"\"\"\n        logger = Logger(name)\n        return logger\n\n    @staticmethod\n    def get_telethon_logger() -> logging.Logger:\n        \"\"\"Get the Telethon logger\"\"\"\n        logger = logging.getLogger('telethon')\n        return logger\n\n    @staticmethod\n    def init_logger(name: str, logger_config: LoggerConfig) -> logging.Logger:\n        \"\"\"Initialize a logger for the application.\"\"\"\n        logger = Logger(name)\n        logger.configure(logger_config)\n        return logger", ""]}
{"filename": "bridge/logger/__init__.py", "chunked_list": ["\"\"\"logger module.\"\"\"\n\ntry:\n    from .logger import Logger\nexcept ImportError as ex:\n    raise ex\n"]}
{"filename": "bridge/discord_handler/__init__.py", "chunked_list": ["\"\"\"Initialize the discord_handler module.\"\"\"\n\ntry:\n    from .core import (fetch_discord_reference, forward_to_discord,\n                       get_mention_roles, is_builtin_mention, start_discord)\n    from .health import DiscordClientHealth\nexcept ImportError as ex:\n    raise ex\n", ""]}
{"filename": "bridge/discord_handler/core.py", "chunked_list": ["\"\"\"Discord handler.\"\"\"\nimport asyncio\nimport sys\nfrom typing import List, Sequence\n\nimport discord\nfrom discord import Message, MessageReference, TextChannel\n\nfrom bridge.config import Config\nfrom bridge.history import MessageHistoryHandler", "from bridge.config import Config\nfrom bridge.history import MessageHistoryHandler\nfrom bridge.logger import Logger\nfrom bridge.utils import split_message\n\n# from discord.abc import GuildChannel, PrivateChannel,\n\nlogger = Logger.get_logger(Config().app.name)\nhistory_manager = MessageHistoryHandler()\n", "history_manager = MessageHistoryHandler()\n\n\nasync def start_discord(config: Config) -> discord.Client:\n    \"\"\"Start the Discord client.\"\"\"\n    async def start_discord_client(discord_client: discord.Client, token: str):\n        try:\n            logger.info(\"Starting Discord client...\")\n\n            # setup discord logger\n            discord_logging_handler = Logger.generate_handler(\n                f\"{config.app.name}_discord\", config.logger)\n            discord.utils.setup_logging(handler=discord_logging_handler)\n\n            await discord_client.start(token)\n            logger.info(\"Discord client started the session: %s, with identity: %s\",\n                        config.app.name, discord_client.user.id)\n\n        except (discord.LoginFailure, TypeError) as login_failure:\n            logger.error(\n                \"Error while connecting to Discord: %s\", login_failure)\n            sys.exit(1)\n        except discord.HTTPException as http_exception:\n            logger.critical(\n                \"Discord client failed to connect with status: %s - %s\", http_exception.status, http_exception.response.reason)", "\n    discord_client = discord.Client(intents=discord.Intents.default())\n    _ = asyncio.ensure_future(\n        start_discord_client(discord_client, config.discord.bot_token))\n\n    return discord_client\n\n#  -> Optional[Union[GuildChannel, Thread, PrivateChannel]]:\n\n", "\n\nasync def forward_to_discord(discord_channel: TextChannel, message_text: str,\n                             image_file=None, reference: MessageReference = ...) -> List[Message]:\n    \"\"\"Send a message to Discord.\"\"\"\n    sent_messages = []\n    message_parts = split_message(message_text)\n    try:\n        if image_file:\n            discord_file = discord.File(image_file)\n            sent_message = await discord_channel.send(message_parts[0],\n                                                      file=discord_file,\n                                                      reference=reference)\n            sent_messages.append(sent_message)\n            message_parts.pop(0)\n\n        for part in message_parts:\n            sent_message = await discord_channel.send(part, reference=reference)\n            sent_messages.append(sent_message)\n    except discord.Forbidden:\n        logger.error(\"Discord client doesn't have permission to send messages to channel %s\",\n                     discord_channel.id, exc_info=Config().app.debug)\n    except discord.HTTPException as http_exception:\n        logger.error(\"Error while sending message to Discord: %s\",\n                     http_exception, exc_info=Config().app.debug)", "\n    return sent_messages\n\n\nasync def fetch_discord_reference(event, forwarder_name: str, discord_channel) -> MessageReference | None:\n    \"\"\"Fetch the Discord message reference.\"\"\"\n    discord_message_id = await history_manager.get_discord_message_id(\n        forwarder_name,\n        event.message.reply_to_msg_id)\n    if not discord_message_id:\n        logger.debug(\"No mapping found for TG message %s\",\n                     event.message.reply_to_msg_id)\n        return None", "        event.message.reply_to_msg_id)\n    if not discord_message_id:\n        logger.debug(\"No mapping found for TG message %s\",\n                     event.message.reply_to_msg_id)\n        return None\n\n    try:\n        messages = []\n        async for message in discord_channel.history(around=discord.Object(id=discord_message_id),   # pylint: disable=line-too-long\n                                                     limit=10):\n            messages.append(message)\n\n        discord_message = next(\n            (msg for msg in messages if msg.id == discord_message_id), None)\n        if not discord_message:\n            logger.debug(\n                \"Reference Discord message not found for TG message %s\",\n                event.message.reply_to_msg_id)\n            return None\n\n        return MessageReference.from_message(discord_message)\n    except discord.NotFound:\n        logger.debug(\"Reference Discord message not found for TG message %s\",\n                     event.message.reply_to_msg_id)\n        return None", "\n\ndef get_mention_roles(message_forward_hashtags: List[str],\n                      mention_override: dict,\n                      discord_built_in_roles: List[str],\n                      server_roles: Sequence[discord.Role]) -> List[str]:\n    \"\"\"Get the roles to mention.\"\"\"\n    mention_roles = set()\n\n    for tag in message_forward_hashtags:\n        if tag.lower() in mention_override:\n            logger.debug(\"Found mention override for tag %s: %s\",\n                         tag, mention_override[tag.lower()])\n            for role_name in mention_override[tag.lower()]:\n                if is_builtin_mention(role_name, discord_built_in_roles):\n                    mention_roles.add(\"@\" + role_name)\n                else:\n                    role = discord.utils.get(server_roles, name=role_name)\n                    if role:\n                        mention_roles.add(role.mention)\n\n    return list(mention_roles)", "\n\ndef is_builtin_mention(role_name: str, discord_built_in_roles: List[str]) -> bool:\n    \"\"\"Check if a role name is a Discord built-in mention.\"\"\"\n    return role_name.lower() in discord_built_in_roles\n"]}
{"filename": "bridge/discord_handler/health.py", "chunked_list": ["\"\"\"Core helpers for the Discord Client\"\"\"\n\nfrom typing import Tuple\n\nimport discord\n\nfrom bridge.config import Config\nfrom bridge.logger import Logger\n\nlogger = Logger.get_logger(Config.get_config_instance().app.name)", "\nlogger = Logger.get_logger(Config.get_config_instance().app.name)\n\nclass DiscordClientHealth:\n    \"\"\"A simple class to keep context for the client handler function\"\"\"\n    _instance = None\n\n    def __new__(cls, *args):  # pylint: disable=unused-argument\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n\n    @staticmethod\n    def report_status(client: discord.Client, bot_max_latency: float) -> Tuple[str, bool]:\n        \"\"\"Report the health status of a Discord Client\"\"\"\n        status: str = \"Discord Client is healthy and connected\"\n\n        if client.latency > bot_max_latency:\n            logger.debug(\"Discord Client's latency: %s - Expected: %s\", client.latency, bot_max_latency)\n            status = \"Discord Client's latency is too high\"\n            return status, False\n\n        if not client.is_ready():\n            status = \"Discord Client's internal cache is not ready\"\n            return status, False\n\n        if client.is_closed():\n            status = \"Discord Client's websocket connection is closed\"\n            return status, False\n\n        if client.user is None:\n            status = \"Discord Client is not authenticated\"\n            return status, False\n\n        return status, True", ""]}
{"filename": "bridge/history/history.py", "chunked_list": ["\"\"\"Messages history handler\"\"\"\n\nimport asyncio\nimport json\nfrom typing import Any, List, Optional\n\nimport aiofiles\nfrom telethon import TelegramClient\n\nfrom bridge.config import Config", "\nfrom bridge.config import Config\nfrom bridge.logger import Logger\n\nconfig = Config()\nlogger = Logger.get_logger(config.app.name)\n\nMESSAGES_HISTORY_FILE = \"messages_history.json\"\nMISSED_MESSAGES_HISTORY_FILE = \"missed_messages_history.json\"\n", "MISSED_MESSAGES_HISTORY_FILE = \"missed_messages_history.json\"\n\n\nclass MessageHistoryHandler:\n    \"\"\"Messages history handler.\"\"\"\n    _instance = None\n\n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._mapping_data_cache = None\n            cls._lock = asyncio.Lock()\n        return cls._instance\n\n    async def load_mapping_data(self) -> dict:\n        \"\"\"Load the mapping data from the mapping file.\"\"\"\n        async with self._lock:\n            logger.debug(\"Loading mapping data...\")\n            if self._mapping_data_cache is None:\n                try:\n                    async with aiofiles.open(MESSAGES_HISTORY_FILE, \"r\", encoding=\"utf-8\") as messages_mapping:\n                        data = json.loads(await messages_mapping.read())\n                        logger.debug(\"Loaded mapping data: %s\", data)\n                        self._mapping_data_cache = data\n                except FileNotFoundError:\n                    self._mapping_data_cache = {}\n\n            return self._mapping_data_cache\n\n    async def save_mapping_data(self, forwarder_name: str, tg_message_id: int, discord_message_id: int) -> None:\n        \"\"\"Save the mapping data to the mapping file.\"\"\"\n        # async with self._lock:\n        mapping_data = await self.load_mapping_data()\n\n        logger.debug(\"Saving mapping data: %s, %s, %s\", forwarder_name,\n                     tg_message_id, discord_message_id)\n\n        if forwarder_name not in mapping_data:\n            mapping_data[forwarder_name] = {}\n\n        mapping_data[forwarder_name][tg_message_id] = discord_message_id\n        try:\n            async with aiofiles.open(MESSAGES_HISTORY_FILE, \"w\", encoding=\"utf-8\") as messages_mapping:\n                await messages_mapping.write(json.dumps(mapping_data, indent=4))\n\n            self._mapping_data_cache = mapping_data\n\n            logger.debug(\"Mapping data saved successfully.\")\n\n            if config.app.debug:\n                logger.debug(\"Current mapping data: %s\", mapping_data)\n\n        except Exception as ex:  # pylint: disable=broad-except\n            logger.error(\n                \"An error occurred while saving mapping data: %s\", ex, exc_info=config.app.debug)\n\n    async def save_missed_message(self, forwarder_name: str, tg_message_id: int, discord_channel_id: int, exception: Any) -> None:\n        \"\"\"Save the missed message to the missed messages file.\"\"\"\n        mapping_data = await self.load_mapping_data()\n\n        logger.debug(\"Saving missed message: %s, %s, %s, %s\", forwarder_name,\n                     tg_message_id, discord_channel_id, exception)\n\n        if forwarder_name not in mapping_data:\n            mapping_data[forwarder_name] = {}\n\n        mapping_data[forwarder_name][tg_message_id] = discord_channel_id, exception\n        try:\n            async with aiofiles.open(MISSED_MESSAGES_HISTORY_FILE, \"w\", encoding=\"utf-8\") as missed_messages_mapping:\n                await missed_messages_mapping.write(json.dumps(mapping_data, indent=4))\n\n            logger.debug(\"Missed message saved successfully.\")\n\n            if config.app.debug:\n                logger.debug(\"Current missed messages data: %s\", mapping_data)\n\n        except Exception as ex:  # pylint: disable=broad-except\n            logger.error(\n                \"An error occurred while saving missed message: %s\", ex, exc_info=config.app.debug)\n\n    async def get_discord_message_id(self, forwarder_name: str, tg_message_id: int) -> Optional[int]:\n        \"\"\"Get the Discord message ID associated with the given TG message ID for the specified forwarder.\"\"\"\n        mapping_data = await self.load_mapping_data()\n        forwarder_data = mapping_data.get(forwarder_name, None)\n\n        if forwarder_data is not None:\n            return forwarder_data.get(tg_message_id, None)\n\n        return None\n\n    async def get_last_messages_for_all_forwarders(self) -> List[dict]:\n        \"\"\"Get the last messages for each forwarder.\"\"\"\n        mapping_data = await self.load_mapping_data()\n        last_messages = []\n        if mapping_data.items():\n            for forwarder_name, forwarder_data in mapping_data.items():\n                if not forwarder_data:\n                    logger.debug(\"No messages found in the history for forwarder %s\",\n                                 forwarder_name)\n                    continue\n                last_tg_message_id = max(forwarder_data, key=int)\n                logger.debug(\"Last TG message ID for forwarder %s: %s\",\n                             forwarder_name, last_tg_message_id)\n                discord_message_id = forwarder_data[last_tg_message_id]\n                last_messages.append({\n                    \"forwarder_name\": forwarder_name,\n                    \"telegram_id\": int(last_tg_message_id),\n                    \"discord_id\": discord_message_id\n                })\n        return last_messages\n\n    async def fetch_messages_after(self, last_tg_message_id: int, channel_id: int, tgc: TelegramClient) -> List:\n        \"\"\"Fetch messages after the last TG message ID.\"\"\"\n        logger.debug(\"Fetching messages after %s\", last_tg_message_id)\n        messages = []\n        async for message in tgc.iter_messages(channel_id, offset_id=last_tg_message_id, reverse=True):\n            logger.debug(\"Fetched message: %s\", message.id)\n            messages.append(message)\n        return messages", ""]}
{"filename": "bridge/history/__init__.py", "chunked_list": ["\"\"\"Initialize the history handler module.\"\"\"\n\ntry:\n    from .history import MessageHistoryHandler\nexcept ImportError as ex:\n    raise ex\n"]}
{"filename": "api/rate_limiter.py", "chunked_list": ["\"\"\"Rate Limiter for the Bridge API\"\"\"\nfrom collections import defaultdict\nfrom time import time\n\nfrom fastapi import Response\nfrom starlette.middleware.base import BaseHTTPMiddleware\nfrom starlette.status import HTTP_429_TOO_MANY_REQUESTS\n\n\n# Rate Limiting Middleware\nclass RateLimitMiddleware(BaseHTTPMiddleware):  # pylint: disable=too-few-public-methods\n    \"\"\"Rate Limiting Middleware for the Bridge API\"\"\"\n\n    def __init__(self, app, limit=100, interval=60):\n        super().__init__(app)\n        self.limit = limit\n        self.interval = interval\n        self.requests = defaultdict(list)\n\n    async def dispatch(self, request, call_next):\n        if request.client is not None:\n            client_ip = request.client.host\n        else:\n            client_ip = request.headers.get(\n                \"X-Forwarded-For\", \"\").split(\",\")[0].strip()\n        request_times = self.requests[client_ip]\n        request_times = [t for t in request_times if time() -\n                         t < self.interval]\n        self.requests[client_ip] = request_times\n\n        if len(request_times) >= self.limit:\n            return RateLimitResponse()\n\n        self.requests[client_ip].append(time())\n        return await call_next(request)", "\n# Rate Limiting Middleware\nclass RateLimitMiddleware(BaseHTTPMiddleware):  # pylint: disable=too-few-public-methods\n    \"\"\"Rate Limiting Middleware for the Bridge API\"\"\"\n\n    def __init__(self, app, limit=100, interval=60):\n        super().__init__(app)\n        self.limit = limit\n        self.interval = interval\n        self.requests = defaultdict(list)\n\n    async def dispatch(self, request, call_next):\n        if request.client is not None:\n            client_ip = request.client.host\n        else:\n            client_ip = request.headers.get(\n                \"X-Forwarded-For\", \"\").split(\",\")[0].strip()\n        request_times = self.requests[client_ip]\n        request_times = [t for t in request_times if time() -\n                         t < self.interval]\n        self.requests[client_ip] = request_times\n\n        if len(request_times) >= self.limit:\n            return RateLimitResponse()\n\n        self.requests[client_ip].append(time())\n        return await call_next(request)", "\n\nclass RateLimitResponse(Response):\n    \"\"\"Rate Limit Response for the Bridge API\"\"\"\n    media_type = \"application/json\"\n\n    def __init__(self):\n        super().__init__(\n            status_code=HTTP_429_TOO_MANY_REQUESTS,\n            content='{\"detail\": \"Too many requests\"}'\n        )", ""]}
{"filename": "api/api.py", "chunked_list": ["\"\"\"API for the bridge.\"\"\"\n\nfrom enum import Enum\n\nfrom fastapi import FastAPI\nfrom fastapi.middleware import Middleware\nfrom fastapi.middleware.cors import CORSMiddleware\n\nfrom api.models import APIConfig, ApplicationConfig, ConfigSummary\nfrom api.rate_limiter import RateLimitMiddleware", "from api.models import APIConfig, ApplicationConfig, ConfigSummary\nfrom api.rate_limiter import RateLimitMiddleware\nfrom api.routers import auth, bridge, config\nfrom bridge.config import Config\nfrom bridge.logger import Logger\n\nlogger = Logger.init_logger(Config().app.name, Config().logger)\n\n\nclass APIVersion(str, Enum):\n    \"\"\"Process State Enum.\"\"\"\n    V1 = \"/api/v1\"\n    V2 = \"/api/v2\"", "\nclass APIVersion(str, Enum):\n    \"\"\"Process State Enum.\"\"\"\n    V1 = \"/api/v1\"\n    V2 = \"/api/v2\"\n\n\nclass BridgeAPI: # pylint: disable=too-few-public-methods\n    \"\"\"Bridge API.\"\"\"\n\n    # This is the main function that starts the application\n    def __init__(self):\n        # The bridge_process variable is used to store the bridge process\n        self.bridge_process = None\n        config_instance = Config.get_config_instance()\n        # The app variable is the main FastAPI instance\n        self.app = FastAPI(\n            title=config_instance.app.name,\n            description=config_instance.app.description,\n            version=config_instance.app.version,\n            debug=config_instance.app.debug,\n            # The RateLimitMiddleware is used to limit the number of requests to 20 per minute\n            middleware=[\n                Middleware(RateLimitMiddleware, limit=20, interval=60),\n                # The CORSMiddleware is used to allow requests from the web interface\n                Middleware(CORSMiddleware,\n                           allow_origins=config_instance.api.cors_origins,\n                           allow_credentials=True,\n                           allow_methods=[\"*\"],\n                           allow_headers=[\"*\"])\n            ]\n        )\n\n        # The index function is used to return the index page\n        self.app.get(path=\"/\",\n                     tags=[\"index\"],\n                     name=\"The Telegram to Discord Bridge API\",\n                     summary=\"Summary report of the Bridge\",\n                     description=\"The Bridge API provides a way to control the telegram-discord-bridge\",\n                     response_model=ConfigSummary)(self.index)\n\n        # auth router `api/v1/auth` is used to authenticate the user\n        self.app.include_router(router=auth.router,\n                                prefix=APIVersion.V1.value)\n\n        # The bridge router is used to control the bridge: `api/v1/bridge`\n        # It contains the start, stop, and health endpoints\n        self.app.include_router(router=bridge.router,\n                                prefix=APIVersion.V1.value)\n\n        # The config router is used to control the bridge configuration: `api/v1/config`\n        self.app.include_router(router=config.router,\n                                prefix=APIVersion.V1.value)\n\n\n    def index(self):\n        \"\"\"index.\"\"\"\n        config_instance = Config.get_config_instance()\n        return ConfigSummary(\n            application=ApplicationConfig(\n                name=config_instance.app.name,\n                version=config_instance.app.version,\n                description=config_instance.app.description,\n                healthcheck_interval=config_instance.app.healthcheck_interval,\n                recoverer_delay=config_instance.app.recoverer_delay,\n                debug=config_instance.app.debug,\n            ),\n            api=APIConfig(\n                enabled=config_instance.api.enabled,\n                cors_origins=config_instance.api.cors_origins,\n                telegram_login_enabled=config_instance.api.telegram_login_enabled,\n                telegram_auth_file=config_instance.api.telegram_auth_file,\n                telegram_auth_request_expiration=config_instance.api.telegram_auth_request_expiration,\n            ))", "\n\napp = BridgeAPI().app\n"]}
{"filename": "api/__init__.py", "chunked_list": ["\"\"\"the bridge api module.\"\"\"\n"]}
{"filename": "api/routers/auth.py", "chunked_list": ["\"\"\"Bridge Auth Router.\"\"\"\nimport json\n\nfrom fastapi import APIRouter\n\nfrom api.models import (TelegramAuthResponse, TelegramAuthResponseSchema,\n                        TelegramAuthSchema)\nfrom bridge.config import Config\n\nrouter = APIRouter(", "\nrouter = APIRouter(\n    prefix=\"/auth\",\n    tags=[\"auth\"],\n)\n\n\n@router.post(\"/telegram\",\n             name=\"Telegram Auth\",\n             summary=\"Handles the Telegram authentication and authorization.\",", "             name=\"Telegram Auth\",\n             summary=\"Handles the Telegram authentication and authorization.\",\n             description=\"Authentication and authorization for the Telegram API including MFA and 2 steps auth.\",\n             response_model=TelegramAuthResponseSchema)\nasync def telegram_auth(auth: TelegramAuthSchema):\n    \"\"\"Handles the Telegram authentication and authorization.\"\"\"\n    config = Config.get_config_instance()\n\n    try:\n        # Temporarily write the auth data to the Telegram auth file.\n        with open(config.api.telegram_auth_file, 'w', encoding=\"utf-8\") as auth_file:\n            json.dump({\n                'identity': config.telegram.phone,\n                'code': auth.code,\n                'password': auth.password}, auth_file)\n    except OSError as ex:\n        return TelegramAuthResponseSchema(\n            auth=TelegramAuthResponse(\n                status=\"authentication interrupted\",\n                message=\"failed to initialize the authentication with the Telegram API.\",\n                error=ex.strerror\n            )\n        )\n    except Exception as ex: # pylint: disable=broad-except\n        return TelegramAuthResponseSchema(\n            auth=TelegramAuthResponse(\n                status=\"authentication interrupted\",\n                message=\"failed to initialize the authentication with the Telegram API.\",\n                error=str(ex)\n            )\n        )", "    try:\n        # Temporarily write the auth data to the Telegram auth file.\n        with open(config.api.telegram_auth_file, 'w', encoding=\"utf-8\") as auth_file:\n            json.dump({\n                'identity': config.telegram.phone,\n                'code': auth.code,\n                'password': auth.password}, auth_file)\n    except OSError as ex:\n        return TelegramAuthResponseSchema(\n            auth=TelegramAuthResponse(\n                status=\"authentication interrupted\",\n                message=\"failed to initialize the authentication with the Telegram API.\",\n                error=ex.strerror\n            )\n        )\n    except Exception as ex: # pylint: disable=broad-except\n        return TelegramAuthResponseSchema(\n            auth=TelegramAuthResponse(\n                status=\"authentication interrupted\",\n                message=\"failed to initialize the authentication with the Telegram API.\",\n                error=str(ex)\n            )\n        )", "\n    return TelegramAuthResponseSchema(\n        auth=TelegramAuthResponse(\n            status=\"authentication initiated successfully\",\n            message=\"authenticating the Telegram API with the provided credentials.\",\n            error=\"\"\n        )\n    )\n", ""]}
{"filename": "api/routers/config.py", "chunked_list": ["\"\"\"Config router for the API\"\"\"\n\nimport os\nfrom datetime import datetime\n\nimport magic\nimport yaml\nfrom fastapi import APIRouter, File, HTTPException, UploadFile\nfrom pydantic import ValidationError  # pylint: disable=import-error\n", "from pydantic import ValidationError  # pylint: disable=import-error\n\nfrom api.models import (APIConfig, ApplicationConfig, BaseResponse,\n                        ConfigSchema, ConfigYAMLSchema, DiscordConfig,\n                        ForwarderConfig, LoggerConfig, OpenAIConfig,\n                        TelegramConfig)\nfrom bridge.config import Config\nfrom bridge.enums import RequestTypeEnum\nfrom bridge.logger import Logger\nfrom forwarder import determine_process_state", "from bridge.logger import Logger\nfrom forwarder import determine_process_state\n\nlogger = Logger.get_logger(Config.get_config_instance().app.name)\n\nclass ConfigRouter:\n    \"\"\"Config router class.\"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"Initialize the config router.\"\"\"\n        self.config = Config.get_config_instance()\n        self.router = APIRouter(\n            prefix=\"/config\",\n            tags=[\"config\"],\n            responses={404: {\"description\": \"Not found\"}},\n            )\n\n        self.router.get(\"/\", response_model=ConfigSchema)(self.get_config)\n\n        self.router.put(\"/\", response_model=BaseResponse)(self.upload_config)\n\n        self.router.post(\"/\", response_model=BaseResponse)(self.post_config)\n\n\n    async def get_config(self) -> ConfigSchema:\n        \"\"\"Get the current config.\"\"\"\n\n        application_config = ApplicationConfig(\n            name=self.config.app.name,\n            version=self.config.app.version,\n            description=self.config.app.description,\n            debug=self.config.app.debug,\n            healthcheck_interval=self.config.app.healthcheck_interval,\n            recoverer_delay=self.config.app.recoverer_delay,\n        )\n\n        api_config = APIConfig(\n            enabled=self.config.api.enabled,\n            cors_origins=self.config.api.cors_origins,\n            telegram_login_enabled=self.config.api.telegram_login_enabled,\n            telegram_auth_file=self.config.api.telegram_auth_file,\n            telegram_auth_request_expiration=self.config.api.telegram_auth_request_expiration,\n        )\n\n        logger_config = LoggerConfig(\n            level=self.config.logger.level,\n            file_max_bytes=self.config.logger.file_max_bytes,\n            file_backup_count=self.config.logger.file_backup_count,\n            format=self.config.logger.format,\n            date_format=self.config.logger.date_format,\n            console=self.config.logger.console,\n        )\n\n        telegram_config = TelegramConfig(\n            phone=self.config.telegram.phone,\n            password=self.config.telegram.password,\n            api_id=self.config.telegram.api_id,\n            api_hash=self.config.telegram.api_hash,\n            log_unhandled_conversations=self.config.telegram.log_unhandled_conversations,\n        )\n\n        discord_config = DiscordConfig(\n            bot_token=self.config.discord.bot_token,\n            built_in_roles=self.config.discord.built_in_roles,\n            max_latency=self.config.discord.max_latency,\n        )\n\n        openai_config = OpenAIConfig(\n            api_key=self.config.openai.api_key,\n            enabled=self.config.openai.enabled,\n            organization=self.config.openai.organization,\n            sentiment_analysis_prompt=self.config.openai.sentiment_analysis_prompt,\n        )\n\n        telegram_forwarders = []\n        for forwarder in self.config.telegram_forwarders:\n            telegram_forwarders.append(\n                ForwarderConfig(\n                    forwarder_name=forwarder[\"forwarder_name\"],\n                    tg_channel_id=forwarder[\"tg_channel_id\"],\n                    discord_channel_id=forwarder[\"discord_channel_id\"],\n                    mention_everyone=forwarder[\"mention_everyone\"],\n                    forward_everything=forwarder[\"forward_everything\"],\n                    strip_off_links=forwarder[\"strip_off_links\"],\n                    forward_hashtags=forwarder[\"forward_hashtags\"] if \"forward_hashtags\" in forwarder else [],\n                    excluded_hashtags=forwarder[\"excluded_hashtags\"] if \"excluded_hashtags\" in forwarder else [],\n                    mention_override=forwarder[\"mention_override\"] if \"mention_override\" in forwarder else None,\n                )\n            )\n\n        return ConfigSchema(\n            config=ConfigYAMLSchema(\n                application=application_config,\n                logger=logger_config,\n                api=api_config,\n                telegram=telegram_config,\n                discord=discord_config,\n                openai=openai_config,\n                telegram_forwarders=telegram_forwarders,\n            )\n        )\n\n\n    async def upload_config(self, file: UploadFile = File(...)) -> BaseResponse: # pylint: disable=too-many-locals\n        \"\"\"Upload a new config file.\"\"\"\n\n        process_state, pid = determine_process_state()\n\n        response = BaseResponse(\n            resource=\"config\",\n            config_version=self.config.app.version,\n            request_type=RequestTypeEnum.UPLOAD_CONFIG,\n            bridge_status=process_state,\n            bridge_pid=pid,\n        )\n\n        content = await file.read()\n\n        mime = magic.Magic(mime=True)\n        mime_type = mime.from_buffer(content)\n\n        response.operation_status[\"mime_type\"] = mime_type\n        response.operation_status[\"file_name\"] = file.filename if file.filename else \"unknown\"\n\n        if not file.filename:\n            raise HTTPException(\n                status_code=400, detail=\"Invalid file name.\")\n\n        if file.filename.startswith(\".\") or not file.filename.endswith(\".yaml\") and not file.filename.endswith(\".yml\"):\n            raise HTTPException(\n                status_code=400, detail=\"Invalid file name.\")\n\n        if file.size is None or file.size > 1024 * 1024 * 1:\n            raise HTTPException(\n                status_code=400, detail=\"Invalid file size. Only file size less than 1MB is accepted.\")\n\n\n        logger.debug(\"Uploaded file type: %s\", mime_type)\n        if mime_type != 'text/plain':\n            raise HTTPException(\n                status_code=400, detail=\"Invalid file type. Only YAML file is accepted.\")\n\n        try:\n            new_config_file_content = yaml.safe_load(content)\n        except yaml.YAMLError as exc:\n            raise HTTPException(\n                status_code=400, detail='Invalid YAML structure in the config file.') from exc\n\n        try:\n            _ = ConfigYAMLSchema(**new_config_file_content)\n        except ValidationError as exc:\n            for error in exc.errors():\n                logger.error(error)\n            raise HTTPException(\n                status_code=400, detail=f'Invalid configuration: {exc.errors}') from exc\n\n        # validate here\n        valid, errors = self.config.validate_config(new_config_file_content)\n        if not valid:\n            raise HTTPException(\n                status_code=400, detail=f'{errors}')\n\n        new_config_file_name = f'config-{new_config_file_content[\"application\"][\"version\"]}.yml'\n\n        response.operation_status[\"new_config_file_name\"] = new_config_file_name\n\n        if os.path.exists(new_config_file_name):\n            backup_filename = f\"{new_config_file_name}_backup_{datetime.now().strftime('%Y%m%d%H%M%S')}.yml\"\n            os.rename(new_config_file_name, backup_filename)\n            response.operation_status[\"config_backup_filename\"] = backup_filename\n\n        with open(new_config_file_name, \"w\", encoding=\"utf-8\") as new_config_file:\n            yaml.dump(new_config_file_content, new_config_file)\n\n        response.success = True\n\n        return response\n\n    async def post_config(self, config: ConfigSchema) -> BaseResponse:\n        \"\"\"Post a new config file.\"\"\"\n\n        process_state, pid = determine_process_state()\n\n        response = BaseResponse(\n            resource=\"config\",\n            config_version=self.config.app.version,\n            request_type=RequestTypeEnum.POST_CONFIG,\n            bridge_status=process_state,\n            bridge_pid=pid,\n        )\n\n        valid, errors = self.config.validate_config(config.config.dict())\n        if not valid:\n            raise HTTPException(\n                status_code=400, detail=f'{errors}')\n\n        config_file_name = f'config-{config.config.application.version}.yml'\n\n        response.operation_status[\"new_config_file_name\"] = config_file_name\n\n        # validate the config with pydantic\n        try:\n            _ = ConfigYAMLSchema(**config.config.dict())\n        except ValidationError as exc:\n            for error in exc.errors():\n                logger.error(error)\n            raise HTTPException(\n                status_code=400, detail=f'Invalid configuration: {exc.errors}') from exc\n\n        if os.path.exists(config_file_name):\n            backup_filename = f\"{config_file_name}_backup_{datetime.now().strftime('%Y%m%d%H%M%S')}.yml\"\n            os.rename(config_file_name, backup_filename)\n            response.operation_status[\"config_backup_filename\"] = backup_filename\n\n        with open(config_file_name, \"w\", encoding=\"utf-8\") as new_config_file:\n            yaml.dump(config.config.dict(), new_config_file,\n                       allow_unicode=False, encoding=\"utf-8\",\n                       explicit_start=True, sort_keys=False, indent=2, default_flow_style=False)\n\n        response.success = True\n\n        return response", "\n\nrouter = ConfigRouter().router\n"]}
{"filename": "api/routers/bridge.py", "chunked_list": ["\"\"\"Bridge controller router.\"\"\"\nimport asyncio\nfrom typing import List\n\nfrom fastapi import APIRouter, WebSocket, WebSocketDisconnect\n\nfrom api.models import (BridgeResponse, BridgeResponseSchema, Health,\n                        HealthHistory, HealtHistoryManager, HealthSchema)\nfrom api.routers.health import HealthcheckSubscriber, WSConnectionManager\nfrom bridge.config import Config", "from api.routers.health import HealthcheckSubscriber, WSConnectionManager\nfrom bridge.config import Config\nfrom bridge.enums import ProcessStateEnum\nfrom bridge.events import EventDispatcher\nfrom bridge.logger import Logger\nfrom bridge.telegram_handler import check_telegram_session\nfrom forwarder import determine_process_state, run_controller\n\n# from typing import List\n", "# from typing import List\n\n\n\nlogger = Logger.get_logger(Config.get_config_instance().app.name)\n\n\nclass BridgeRouter:  # pylint: disable=too-few-public-methods\n    \"\"\"Bridge Router.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the Bridge Router.\"\"\"\n        self.dispatcher: EventDispatcher\n        HealtHistoryManager.register('HealthHistory', HealthHistory)\n\n        self.health_history_manager_instance = HealtHistoryManager()\n        self.health_history_manager_instance.start() # pylint: disable=consider-using-with # the server must stay alive as long as we want the shared object to be accessible\n        self.health_history: HealthHistory = self.health_history_manager_instance.HealthHistory() # type: ignore # pylint: disable=no-member\n\n        self.ws_connection_manager: WSConnectionManager\n\n        self.bridge_router = APIRouter(\n            prefix=\"/bridge\",\n            tags=[\"bridge\"],\n        )\n\n        self.bridge_router.post(\"/\",\n                         name=\"Start the Telegram to Discord Bridge\",\n                         summary=\"Initiate the forwarding.\",\n                         description=\"Starts the Bridge controller triggering the Telegram authentication process.\",\n                         response_model=BridgeResponseSchema)(self.start)\n\n        self.bridge_router.delete(\"/\",\n                           name=\"Stop the Telegram to Discord Bridge\",\n                           summary=\"Removes the Bridge process.\",\n                           description=\"Suspends the Bridge forwarding messages from Telegram to Discord and stops the process.\",\n                           response_model=BridgeResponseSchema)(self.stop)\n\n        self.bridge_router.get(\"/health\",\n                        name=\"Get the health status of the Bridge.\",\n                        summary=\"Determines the Bridge process status, the Telegram, Discord, and OpenAI connections health and returns a summary.\",\n                        description=\"Determines the Bridge process status, and the Telegram, Discord, and OpenAI connections health.\",\n                        response_model=HealthSchema)(self.health)\n\n        self.bridge_router.websocket(\"/health/ws\",\n                                name=\"Get the health status of the Bridge.\")(self.health_websocket_endpoint)\n\n    async def start(self):\n        \"\"\"start the bridge.\"\"\"\n        config = Config.get_config_instance()\n        pid_file = f'{config.app.name}.pid'\n        process_state, pid = determine_process_state(pid_file)\n\n        try:\n            # if the pid file is empty and the process is None,\n            # # then start the bridge\n            # if pid == 0 and self.bridge_process is not ProcessStateEnum.RUNNING:\n            #     # create a shared list of subscribers\n            #     manager = Manager()\n            #     # create a list of subscribers to pass to the event dispatcher and the healthcheck subscriber\n            #     healthcheck_subscribers: ListProxy[HealthcheckSubscriber] = manager.list()\n\n            #     self.ws_connection_manager = WSConnectionManager(self.health_history)\n\n            #     # create the event dispatcher\n            #     self.dispatcher = EventDispatcher(subscribers=healthcheck_subscribers)\n            #     self.healthcheck_subscriber = HealthcheckSubscriber('healthcheck_subscriber',\n            #                                                    self.dispatcher,\n            #                                                    self.health_history,\n            #                                                    self.ws_connection_manager,\n            #                                                    self.websocket_queue)\n            #     self.dispatcher.add_subscriber(\"healthcheck\", self.healthcheck_subscriber)\n\n            #     self.on_update = self.healthcheck_subscriber.create_on_update_decorator()\n\n            #     self.bridge_process = Process(\n            #         target=controller, args=(self.dispatcher, True, False, False,))\n\n            #     # start the bridge process\n            #     self.bridge_process.start()\n            #     # self.bridge_process.join()\n\n            if pid == 0 or process_state not in [ProcessStateEnum.RUNNING, ProcessStateEnum.STARTING]:\n                # create a shared list of subscribers\n                healthcheck_subscribers: List[HealthcheckSubscriber] = []\n\n                self.ws_connection_manager = WSConnectionManager(self.health_history)\n\n                # create the event dispatcher\n                self.dispatcher = EventDispatcher(subscribers=healthcheck_subscribers)\n                self.healthcheck_subscriber = HealthcheckSubscriber('healthcheck_subscriber',\n                                                                    self.dispatcher,\n                                                                    self.health_history,\n                                                                    self.ws_connection_manager)\n                self.dispatcher.add_subscriber(\"healthcheck\", self.healthcheck_subscriber)\n\n                self.on_update = self.healthcheck_subscriber.create_on_update_decorator()\n\n                event_loop = asyncio.get_running_loop()\n\n                # controller_task = asyncio.ensure_future(run_controller(self.dispatcher, event_loop, True, False, False,))\n\n                locker = asyncio.Lock()\n                await locker.acquire()\n                event_loop.create_task(run_controller(self.dispatcher, event_loop, True, False, False))\n                locker.release()\n\n                return BridgeResponseSchema(bridge=BridgeResponse(\n                    name=config.app.name,\n                    status=ProcessStateEnum.STARTING,\n                    process_id=pid,\n                    config_version=config.app.version,\n                    telegram_authenticated=check_telegram_session(),\n                    error=\"\",\n                ))\n        except Exception as ex: # pylint: disable=broad-except\n            logger.error(\"Error starting the bridge: %s\", ex, exc_info=Config.get_config_instance().app.debug)\n            return BridgeResponseSchema(bridge=BridgeResponse(\n                name=config.app.name,\n                status=ProcessStateEnum.STOPPED,\n                process_id=pid,\n                config_version=config.app.version,\n                telegram_authenticated=check_telegram_session(),\n                error=str(ex),\n            ))\n\n        # if the pid file is empty and the process is not None and is alive,\n        # then return that the bridge is starting\n        if pid == 0 and process_state == ProcessStateEnum.RUNNING:\n            return BridgeResponseSchema(bridge=BridgeResponse(\n                name=config.app.name,\n                status=ProcessStateEnum.ORPHANED,\n                process_id=pid,\n                config_version=config.app.version,\n                telegram_authenticated=check_telegram_session(),\n                error=\"\",\n            ))\n\n        # otherwise return the state of the process\n        return BridgeResponseSchema(bridge=BridgeResponse(\n            name=config.app.name,\n            status=ProcessStateEnum.RUNNING,\n            process_id=pid,\n            config_version=config.app.version,\n            telegram_authenticated=check_telegram_session(),\n            error=\"\",\n        ))\n\n    async def stop(self):\n        \"\"\"stop the bridge.\"\"\"\n        config = Config.get_config_instance()\n        process_state, pid = determine_process_state(pid_file=f'{config.app.name}.pid')\n\n        if process_state == ProcessStateEnum.RUNNING and pid > 0:\n            try:\n                await run_controller(dispatcher=self.dispatcher, boot=False, background=False, stop=True)\n\n                self.dispatcher.stop()\n            except asyncio.exceptions.CancelledError:\n                logger.info(\"Bridge process stopped.\")\n            except Exception as ex: # pylint: disable=broad-except\n                logger.error(\"Error stopping the bridge: %s\", ex, exc_info=Config.get_config_instance().app.debug)\n\n            return BridgeResponseSchema(bridge=BridgeResponse(\n                name=config.app.name,\n                status=ProcessStateEnum.STOPPING,\n                process_id=pid,\n                config_version=config.app.version,\n                telegram_authenticated=check_telegram_session(),\n                error=\"\",\n            ))\n\n        return BridgeResponseSchema(bridge=BridgeResponse(\n            name=config.app.name,\n            status=ProcessStateEnum.STOPPED,\n            process_id=pid,\n            config_version=config.app.version,\n            telegram_authenticated=check_telegram_session(),\n            error=\"\",\n        ))\n\n    async def health(self):\n        \"\"\"Return the health status of the Bridge.\"\"\"\n        config = Config.get_config_instance()\n        pid_file = f'{config.app.name}.pid'\n        process_state, pid = determine_process_state(pid_file)\n\n        try:\n            health_status = self.health_history.get_health_data()\n        except ValueError:\n            logger.error(\"Unable to retrieve the last health status.\")\n            return HealthSchema(\n                health=Health(\n                process_id=pid,\n            )\n        )\n\n        return HealthSchema(\n            health=Health(\n                timestamp=health_status.timestamp,\n                process_state=process_state,\n                process_id=pid,\n                status=health_status.status,\n            )\n        )\n\n    async def health_data_sender(self, websocket: WebSocket):\n        \"\"\"Send health data to the WS client.\"\"\"\n        logger.debug(\"Starting health data sender.\")\n\n        @self.on_update(\"healthcheck\")\n        async def send_health_data():\n            \"\"\"Send health data to the WS client.\"\"\"\n            logger.debug(\"Sending health data to the WS client.\")\n            try:\n                await self.ws_connection_manager.send_health_data(websocket)\n            # pylint: disable=broad-except\n            except Exception as exc:\n                logger.exception(\"Error while sending health data to the WS client: %s\", exc, exc_info=Config.get_config_instance().app.debug)\n                raise exc\n\n\n    async def health_websocket_endpoint(self, websocket: WebSocket):\n        \"\"\"Websocket endpoint.\"\"\"\n        logger.info(\"Connected to the websocket.\")\n        task = None\n        try:\n            await self.ws_connection_manager.connect(websocket)\n            task = asyncio.create_task(self.health_data_sender(websocket))\n\n            while True:\n                logger.debug(\"Waiting for message from the client.\")\n                _ = await websocket.receive_text()\n        except WebSocketDisconnect:\n            logger.info(\"Disconnecting from the websocket.\")\n            if task:\n                task.cancel()\n            await self.ws_connection_manager.disconnect(websocket)\n        except Exception as ex: # pylint: disable=broad-except\n            logger.error(\"Error in health_websocket_endpoint: %s\", ex, exc_info=Config.get_config_instance().app.debug)\n            if task:\n                task.cancel()\n            await self.ws_connection_manager.disconnect(websocket)", "\nrouter = BridgeRouter().bridge_router\n"]}
{"filename": "api/routers/__init__.py", "chunked_list": ["\"\"\"Bridge API Router.\"\"\"\n"]}
{"filename": "api/routers/health.py", "chunked_list": ["\"\"\"Bridge Health API Router.\"\"\"\n\nimport asyncio\nimport functools\nfrom datetime import datetime\nfrom typing import Any, List\n\nfrom fastapi import WebSocket\n\nfrom api.models import Health, HealthHistory, HealthSchema", "\nfrom api.models import Health, HealthHistory, HealthSchema\nfrom bridge.config import Config\nfrom bridge.enums import ProcessStateEnum\nfrom bridge.events import EventSubscriber\nfrom bridge.logger import Logger\nfrom forwarder import determine_process_state\n\nlogger = Logger.get_logger(Config.get_config_instance().app.name)\n# Initialize a global Config object", "logger = Logger.get_logger(Config.get_config_instance().app.name)\n# Initialize a global Config object\nconfig = Config()\n\nclass WSConnectionManager:\n    \"\"\"WS Connection Manager.\"\"\"\n\n    def __init__(self, health_history: HealthHistory):\n        self.active_connections: List[WebSocket] = []\n        self.health_history: HealthHistory = health_history\n        # self.websocket_subscribers: multiprocessing.Queue = multiprocessing.Queue()\n\n    def __call__(self, *args: Any, **kwds: Any) -> Any:\n        pass\n\n    async def connect(self, websocket: WebSocket):\n        \"\"\"Connect, handles the WS connections.\"\"\"\n        logger.debug(\"Connecting to %s\", websocket)\n        if isinstance(websocket, WebSocket):\n            await websocket.accept()\n            self.active_connections.append(websocket)\n\n    async def disconnect(self, websocket: WebSocket):\n        \"\"\"Disconnect, handles the WS connections.\"\"\"\n        self.active_connections.remove(websocket)\n\n    async def broadcast_health_data(self, data: Config | None = None):\n        \"\"\"Broadcast health data to all WS clients.\"\"\"\n        logger.debug(\"Broadcasting health data to %s\", self.active_connections)\n        for websocket in self.active_connections:\n            await self.send_health_data(websocket, data)\n\n    async def send_health_data(self, websocket: WebSocket, data: Config | None = None):\n        \"\"\"Send health data to the WS client.\"\"\"\n        logger.debug(\"Sending health data to %s\", websocket)\n        current_config = data if data else config.get_config_instance()\n        pid_file = f'{current_config.app.name}.pid'\n        process_state, pid = determine_process_state(pid_file)\n\n        health_status = None\n\n        try:\n            health_status = self.health_history.get_health_data()\n        except ValueError:\n            logger.error(\"Unable to retrieve the last health status.\")\n            health_data = HealthSchema(\n                health=Health(\n                process_id=pid,\n            )\n        )\n\n        health_data = HealthSchema(\n            health=Health(\n                timestamp=health_status.timestamp if health_status else 0,\n                process_state=process_state,\n                process_id=pid,\n                status=health_status.status if health_status else {},\n            )\n        )\n\n        if websocket in self.active_connections:\n            await websocket.send_json(health_data.dict())", "\n\ndef websocket_broadcast_when_healthcheck(func):\n    \"\"\"Decorator to broadcast health data when a healthcheck event is received.\"\"\"\n    @functools.wraps(func)\n    def wrapper(self, *args, **kwargs):\n        result = func(self, *args, **kwargs)\n        asyncio.create_task(self.ws_manager.broadcast_health_data())\n        return result\n    return wrapper", "\n\nclass HealthcheckSubscriber(EventSubscriber): # pylint: disable=too-few-public-methods\n    \"\"\"Healthcheck subscriber class.\"\"\"\n\n    def __init__(self, name, dispatcher, health_history: HealthHistory, ws_manager: WSConnectionManager):\n        super().__init__(name, dispatcher=dispatcher)\n        self.health_history: HealthHistory = health_history\n        self.ws_manager = ws_manager\n\n    @websocket_broadcast_when_healthcheck\n    def update(self, event:str, data: Any | None = None):\n        \"\"\"\n        Update the event subscriber with a new event.\n\n        Args:\n            event (str): The event name.\n            data (Any): The config object.\n\n        Returns:\n            None\n        \"\"\"\n        logger.debug(\"The healthcheck subscriber %s received event: %s\", self.name, event)\n\n        if data and isinstance(data, Config):\n            logger.debug(\"The healthcheck subscriber %s received config: %s\", self.name, data)\n            health_data = Health(\n                timestamp=datetime.timestamp(datetime.now()),\n                process_state=ProcessStateEnum.RUNNING,\n                process_id=0,\n                status={\n                    \"telegram\": data.telegram.is_healthy,\n                    \"discord\": data.discord.is_healthy,\n                    \"openai\": data.openai.is_healthy,\n                    \"internet\": data.app.internet_connected,\n                },)\n\n            self.health_history.add_health_data(health_data)\n        else:\n            logger.warning(\"The healthcheck subscriber %s received data: %s\", self.name, data)", ""]}
{"filename": "api/models/health_schema.py", "chunked_list": ["\"\"\"Health Schema.\"\"\"\"\"\n\nfrom typing import Dict\nfrom multiprocessing.managers import BaseManager\nfrom pydantic import BaseModel\nfrom bridge.enums import ProcessStateEnum\nfrom bridge.config import Config\nfrom bridge.logger import Logger\n\nlogger = Logger.get_logger(Config.get_config_instance().app.name)", "\nlogger = Logger.get_logger(Config.get_config_instance().app.name)\n\nclass Health(BaseModel):\n    \"\"\"Health.\"\"\"\n    timestamp: float = 0\n    process_state: ProcessStateEnum = ProcessStateEnum.UNKNOWN\n    process_id: int = 0\n    status: dict[str, bool] = {}\n", "\n\nclass HealthSchema(BaseModel):\n    \"\"\"Health Schema.\"\"\"\n    health: Health\n\n\nclass HealthHistory:\n    \"\"\"Health History.\"\"\"\n\n    # make this class a singleton\n    def __new__(cls):\n        \"\"\"Create a new Health History object.\"\"\"\n        if not hasattr(cls, 'instance'):\n            cls.instance = super(HealthHistory, cls).__new__(cls)\n        return cls.instance\n\n    def __init__(self):\n        \"\"\"Initialize the Health History.\"\"\"\n        if not hasattr(self, 'health_history'):\n            self.health_history:Dict[float, Health]  = {}\n\n    def add_health_data(self, health):\n        \"\"\"Add a health object to the health history.\"\"\"\n        logger.info('Adding health to history')\n        if not isinstance(health, Health):\n            logger.error('health must be a Health object')\n            raise TypeError('health must be a Health object')\n        if not health.timestamp > 0:\n            logger.error('health timestamp must be > 0')\n            raise ValueError('health timestamp must be > 0')\n        self.health_history[health.timestamp] = health\n\n    def get_health_data(self):\n        \"\"\"Return the last health object in the health history.\"\"\"\n\n        if not self.health_history:\n            raise ValueError('No health objects in history')\n\n        # Get the last timestamp from the history\n        last_timestamp = max(self.health_history.keys()) # type: ignore\n\n        # Get the last health object from the history\n        last_health = self.health_history[last_timestamp]\n\n        logger.info('Returning last health: %s', last_health)\n        return last_health\n\n    def get_health_history(self):\n        \"\"\"Return the health history.\"\"\"\n        return self.health_history", "\nclass HealtHistoryManager(BaseManager):\n    \"\"\"Health History Manager.\"\"\"\n"]}
{"filename": "api/models/__init__.py", "chunked_list": ["\"\"\"the bridge config schema.\"\"\"\n\ntry:\n    from .auth_schema import (TelegramAuthResponse, TelegramAuthResponseSchema,\n                              TelegramAuthSchema)\n    from .base_response_schema import BaseResponse\n    from .bridge_schema import BridgeResponse, BridgeResponseSchema\n    from .config_schema import (APIConfig, ApplicationConfig, ConfigSchema,\n                                ConfigSummary, ConfigYAMLSchema, DiscordConfig,\n                                ForwarderConfig, LoggerConfig, OpenAIConfig,\n                                TelegramConfig)\n    from .health_schema import (Health, HealthHistory, HealtHistoryManager,\n                                HealthSchema)\nexcept ImportError as ex:\n    raise ex", ""]}
{"filename": "api/models/config_schema.py", "chunked_list": ["\"\"\"config schema validation model.\"\"\"\nfrom typing import List, Optional\n\nfrom pydantic import BaseModel  # pylint: disable=import-error\n\n\nclass ForwarderConfig(BaseModel):  # pylint: disable=too-few-public-methods\n    \"\"\"Forwarder model.\"\"\"\n    forwarder_name: str\n    tg_channel_id: int\n    discord_channel_id: int\n    strip_off_links: bool\n    mention_everyone: bool\n    forward_everything: bool\n    forward_hashtags: Optional[List[dict]] = None\n    excluded_hashtags: Optional[List[dict]] = None\n    mention_override: Optional[List[dict]] = None", "\n\nclass OpenAIConfig(BaseModel):  # pylint: disable=too-few-public-methods\n    \"\"\"OpenAI config.\"\"\"\n    enabled: bool\n    api_key: str\n    organization: str\n    sentiment_analysis_prompt: List[str]\n\n\nclass DiscordConfig(BaseModel):  # pylint: disable=too-few-public-methods\n    \"\"\"Discord config.\"\"\"\n    bot_token: str\n    built_in_roles: List[str]\n    max_latency: float", "\n\nclass DiscordConfig(BaseModel):  # pylint: disable=too-few-public-methods\n    \"\"\"Discord config.\"\"\"\n    bot_token: str\n    built_in_roles: List[str]\n    max_latency: float\n\n\nclass TelegramConfig(BaseModel):  # pylint: disable=too-few-public-methods\n    \"\"\"Telegram config.\"\"\"\n    phone: str\n    password: str\n    api_id: int\n    api_hash: str\n    log_unhandled_conversations: bool", "\nclass TelegramConfig(BaseModel):  # pylint: disable=too-few-public-methods\n    \"\"\"Telegram config.\"\"\"\n    phone: str\n    password: str\n    api_id: int\n    api_hash: str\n    log_unhandled_conversations: bool\n\n\nclass LoggerConfig(BaseModel):  # pylint: disable=too-few-public-methods\n    \"\"\"Logger config.\"\"\"\n    level: str\n    file_max_bytes: int\n    file_backup_count: int\n    format: str\n    date_format: str\n    console: bool", "\n\nclass LoggerConfig(BaseModel):  # pylint: disable=too-few-public-methods\n    \"\"\"Logger config.\"\"\"\n    level: str\n    file_max_bytes: int\n    file_backup_count: int\n    format: str\n    date_format: str\n    console: bool", "\n\nclass ApplicationConfig(BaseModel):  # pylint: disable=too-few-public-methods\n    \"\"\"Application config.\"\"\"\n    name: str\n    version: str\n    description: str\n    debug: bool\n    healthcheck_interval: int\n    recoverer_delay: float", "\n\nclass APIConfig(BaseModel):  # pylint: disable=too-few-public-methods\n    \"\"\"API config.\"\"\"\n    enabled: bool\n    cors_origins: List[str]\n    telegram_login_enabled: bool\n    telegram_auth_file: str\n    telegram_auth_request_expiration: int\n", "\n\nclass ConfigSummary(BaseModel):  # pylint: disable=too-few-public-methods\n    \"\"\"Config summary.\"\"\"\n    application: ApplicationConfig\n    api: APIConfig\n\nclass ConfigYAMLSchema(BaseModel):  # pylint: disable=too-few-public-methods\n    \"\"\"Config YAML schema.\"\"\"\n    application: ApplicationConfig\n    logger: LoggerConfig\n    api: APIConfig\n    telegram: TelegramConfig\n    discord: DiscordConfig\n    openai: OpenAIConfig\n    telegram_forwarders: List[ForwarderConfig]", "\nclass ConfigSchema(BaseModel):  # pylint: disable=too-few-public-methods\n    \"\"\"Config model.\"\"\"\n    config: ConfigYAMLSchema\n"]}
{"filename": "api/models/bridge_schema.py", "chunked_list": ["\"\"\"The Bridge Schema.\"\"\"\n\nfrom pydantic import BaseModel\n\nfrom bridge.enums import ProcessStateEnum\n\n\nclass BridgeResponse(BaseModel):\n    \"\"\"Bridge Response.\"\"\"\n    name: str = \"Telegram to Discord Bridge\"\n    status: ProcessStateEnum = ProcessStateEnum.STOPPED\n    process_id: int | None = 0\n    config_version: str = \"0.0.0\"\n    telegram_authenticated: bool = False\n    error: str = \"\"", "\n\nclass BridgeResponseSchema(BaseModel):\n    \"\"\"Bridge Response Schema.\"\"\"\n    bridge: BridgeResponse\n"]}
{"filename": "api/models/auth_schema.py", "chunked_list": ["\"\"\"Auth Schema.\"\"\"\n\nfrom pydantic import BaseModel\n\n\nclass TelegramAuthSchema(BaseModel):\n    \"\"\"Telegram Auth Schema.\"\"\"\n    identity: str = \"\"\n    password: str = \"\"\n    code: str | int = 0", "\n\nclass TelegramAuthResponse(BaseModel):\n    \"\"\"Telegram Auth Response Schema.\"\"\"\n    status: str\n    message: str\n    error: str = \"\"\n    session_revoked: bool = False\n    mfa_required: bool = False\n", "\n\nclass TelegramAuthResponseSchema(BaseModel):\n    \"\"\"Telegram Auth Response Schema.\"\"\"\n    auth: TelegramAuthResponse\n"]}
{"filename": "api/models/base_response_schema.py", "chunked_list": ["\"\"\"Base API response schema.\"\"\"\n\nfrom datetime import datetime\nfrom typing import Dict, TypeAlias\n\nfrom pydantic import BaseModel  # pylint: disable=import-error\nfrom ulid import monotonic as ulid\n\nfrom bridge.enums import ProcessStateEnum, RequestTypeEnum\n", "from bridge.enums import ProcessStateEnum, RequestTypeEnum\n\nOperationStatus: TypeAlias = Dict[str, str]\n\n# OperationErrors\nErrorSummary: TypeAlias = str\nErrorDetails: TypeAlias = str\nOperationErrors: TypeAlias = Dict[ErrorSummary, ErrorDetails]\n\nclass BaseResponse(BaseModel):\n    \"\"\"Base Response.\"\"\"\n\n    resource: str\n    request_id: str = ulid.from_timestamp(datetime.timestamp(datetime.now())).str\n    request_type: RequestTypeEnum\n    bridge_status: ProcessStateEnum = ProcessStateEnum.STOPPED\n    bridge_pid: int = 0\n    config_version: str = \"0.0.0\"\n    success: bool = False\n    operation_status: OperationStatus = {}\n    operation_errors: OperationErrors = {}", "\nclass BaseResponse(BaseModel):\n    \"\"\"Base Response.\"\"\"\n\n    resource: str\n    request_id: str = ulid.from_timestamp(datetime.timestamp(datetime.now())).str\n    request_type: RequestTypeEnum\n    bridge_status: ProcessStateEnum = ProcessStateEnum.STOPPED\n    bridge_pid: int = 0\n    config_version: str = \"0.0.0\"\n    success: bool = False\n    operation_status: OperationStatus = {}\n    operation_errors: OperationErrors = {}", ""]}
