{"filename": "setup.py", "chunked_list": ["from setuptools import setup\n\nsetup(\n    name='OnlineJudge',\n    version='0.0.1',\n    packages=['OJ', 'OJ.db', 'OJ.app', 'OJ.util', 'OJ.views', 'OJ.views.admin', 'OJ.models', 'OJ.middleware'],\n    url='',\n    license='',\n    author='cslzc',\n    author_email='',", "    author='cslzc',\n    author_email='',\n    description='',\n    install_requires=[\n        'fastapi',\n        'redis',\n        'requests',\n        'SQLAlchemy',\n        'urllib3',\n        'fastapi-pagination',", "        'urllib3',\n        'fastapi-pagination',\n        'pycryptodome',\n        'PyMySQL',\n        'uvicorn',\n        'python-multipart',\n        'PyYAML',\n        'cryptography'\n    ]\n)", "    ]\n)\n"]}
{"filename": "main.py", "chunked_list": ["from OJ import OJBe\n\nif __name__ == '__main__':\n    server = OJBe(\n        'config.yaml'\n    )\n    # add custom middleware\n    # server.add_middleware(...)\n    # You can also add other routes here\n    # server.add_route(...)\n    server.start()", ""]}
{"filename": "OJ/__init__.py", "chunked_list": ["import os\nimport importlib\nimport uvicorn\nimport yaml\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi_pagination.utils import FastAPIPaginationWarning\n\nimport warnings\n", "import warnings\n\n\nclass OJBe(object):\n    available = True\n\n    def __init__(self, config_path) -> None:\n        super().__init__()\n        self.config = {}\n        self.config_path = config_path\n        self.check_config_is_available()\n        self.load_config()\n        self.host = self.config['server']['host']\n        self.port = self.config['server']['port']\n        self.app = FastAPI()\n\n        self.setup()\n\n    def setup(self):\n        db = importlib.import_module('OJ.db.database')\n        db.create_connection()\n        db.Base.metadata.create_all(db.engine)\n\n        users_mw = importlib.import_module('OJ.middleware.users')\n        urls = importlib.import_module('OJ.views')\n        self.add_middleware(users_mw.CheckLogin)\n        self.add_routes(urls.routes)\n\n        if self.config['server'].get('is_cors', 0) == 1:\n            self.add_middleware(\n                CORSMiddleware,\n                allow_origins=[\"*\"],\n                allow_credentials=True,\n                allow_methods=[\"*\"],\n                allow_headers=[\"*\"],\n            )\n\n    def check_config_is_available(self):\n        try:\n            self.config = yaml.load(open(self.config_path), yaml.Loader)\n        except:\n            assert False, 'Invalid config file.'\n        self.config['server'] = self.config.get('server', {'host': '0.0.0.0', 'port': 16808})\n        self.config['AES_KEY'] = self.config.get('AES_KEY', 'zjuerzclu')\n        self.config['test_case'] = self.config.get('test_case', {'dir': './testcases'})\n\n        assert (\n                self.config.get('mysql', None) and\n                self.config['mysql'].get('user', None) and\n                self.config['mysql'].get('host', None) and\n                self.config['mysql'].get('pass', None) and\n                self.config['mysql'].get('port', None) and\n                self.config['mysql'].get('name', None)\n        ), 'Invalid MySQL config.'\n        assert (\n                self.config.get('redis', None) and\n                self.config['redis'].get('host', None) and\n                self.config['redis'].get('pass', None) and\n                self.config['redis'].get('port', None) and\n                self.config['redis'].get('db', None)\n        ), 'Invalid Redis config.'\n\n    def load_config(self):\n        #  Server config\n        os.environ['HOST'] = self.config['server']['host']\n        os.environ['PORT'] = str(self.config['server']['port'])\n\n        #  MySQL config\n        os.environ['DB_USER'] = self.config['mysql']['user']\n        os.environ['DB_PASS'] = self.config['mysql']['pass']\n        os.environ['DB_HOST'] = self.config['mysql']['host']\n        os.environ['DB_PORT'] = self.config['mysql']['port']\n        os.environ['DB_NAME'] = self.config['mysql']['name']\n        #  Redis config\n        os.environ['REDIS_HOST'] = self.config['redis']['host']\n        os.environ['REDIS_PORT'] = self.config['redis']['port']\n        os.environ['REDIS_PASSWORD'] = self.config['redis']['pass']\n        os.environ['REDIS_DB'] = self.config['redis']['db']\n        #  AES Key\n        os.environ['AES_KEY'] = self.config['AES_KEY']\n        #  Judge server token\n        os.environ['JUDGER_TOKEN'] = self.config['JUDGER_TOKEN']\n\n    def add_route(self, route):\n        self.app.include_router(route)\n\n    def add_routes(self, routes):\n        for route in routes:\n            self.add_route(route)\n\n    def add_middleware(self, mw, **kwargs):\n        self.app.add_middleware(mw, **kwargs)\n\n    def exclude_check_login(self, path):\n        setting = importlib.import_module('OJ.app.settings')\n        setting.CHECKLOGIN_EXCLUDE_PATH.append(path)\n\n    def add_model(self, custom_base):\n        db = importlib.import_module('OJ.db.database')\n        custom_base.metadata.create_all(db.engine)\n\n    def start(self):\n        uvicorn.run(self.app, host=self.host, port=self.port)", "\n\nwarnings.simplefilter(\"ignore\", FastAPIPaginationWarning)\n"]}
{"filename": "OJ/db/database.py", "chunked_list": ["from sqlalchemy import create_engine\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\nimport importlib\n\n__all__ = ['Base', 'BaseModel']\n\nBase = declarative_base()\nSessionLocal = None\nengine = None", "SessionLocal = None\nengine = None\n\n\ndef create_connection():\n    global engine, SessionLocal\n    settings = importlib.import_module('OJ.app.settings')\n    engine = create_engine(settings.SQLALCHEMY_DATABASE_URI)\n    SessionLocal = sessionmaker(bind=engine, autocommit=False, autoflush=True)\n", "\n\nclass BaseModel(object):\n    def to_dict(self, filter_fields: list = []):\n        if not filter_fields:\n            return {c.name: getattr(self, c.name) for c in self.__table__.columns}\n        else:\n            return {c: getattr(self, c) for c in filter_fields}\n\n\ndef get_session():\n    db = SessionLocal()\n    try:\n        yield db\n        db.commit()\n    finally:\n        db.close()", "\n\ndef get_session():\n    db = SessionLocal()\n    try:\n        yield db\n        db.commit()\n    finally:\n        db.close()\n", ""]}
{"filename": "OJ/db/__init__.py", "chunked_list": [""]}
{"filename": "OJ/util/constant.py", "chunked_list": ["class PROBLEM_MODE:\n    ACM = 0\n    OI = 1\n\n\nclass PROBLEM_STATUS:\n    VISIBLE = 0\n    HIDDEN = 1\n    CONTEST_HIDDEN = 2\n    CONTEST_VISIBLE = 3", "\n\nclass ContestStatus:\n    CONTEST_NOT_START = \"1\"\n    CONTEST_ENDED = \"-1\"\n    CONTEST_UNDERWAY = \"0\"\n\n\nclass ContestRuleType:\n    ACM = 0\n    OI = 1", "class ContestRuleType:\n    ACM = 0\n    OI = 1\n\n\nclass CONTEST_TYPE:\n    NORMAL = 0\n    PASSWORD = 1\n    HIDDEN_VISIBLE = 2\n    HIDDEN_INVISIBLE = 3", "\n\nclass JudgeStatus:\n    COMPILE_ERROR = -2\n    WRONG_ANSWER = -1\n    ACCEPTED = 0\n    CPU_TIME_LIMIT_EXCEEDED = 1\n    REAL_TIME_LIMIT_EXCEEDED = 2\n    MEMORY_LIMIT_EXCEEDED = 3\n    RUNTIME_ERROR = 4\n    SYSTEM_ERROR = 5\n    PENDING = 6\n    JUDGING = 7\n    PARTIALLY_ACCEPTED = 8", "\n\nclass CacheKey:\n    waiting_queue = 'waiting_queue'\n"]}
{"filename": "OJ/util/zip_processor.py", "chunked_list": ["import json\nimport os\nimport zipfile\n\nfrom .common import *\n\n\nclass TestCaseZipProcessor(object):\n    def process_zip(self, uploaded_zip_file, spj, dir=\"\"):\n        try:\n            zip_file = zipfile.ZipFile(uploaded_zip_file, \"r\")\n        except zipfile.BadZipFile:\n            raise \"Bad zip file\"\n        name_list = zip_file.namelist()\n        test_case_list = self.filter_name_list(name_list, spj=spj, dir=dir)\n        if not test_case_list:\n            raise \"Empty file\"\n        test_case_id = rand_str()\n        test_case_dir = os.path.join('testcases', test_case_id)\n        os.mkdir(test_case_dir)\n        os.chmod(test_case_dir, 0o710)\n\n        size_cache = {}\n        md5_cache = {}\n        for item in test_case_list:\n            with open(os.path.join(test_case_dir, item), \"wb\") as f:\n                content = zip_file.read(f\"{dir}{item}\").replace(b\"\\r\\n\", b\"\\n\")\n                size_cache[item] = len(content)\n                if item.endswith(\".out\"):\n                    md5_cache[item] = hashlib.md5(content.rstrip()).hexdigest()\n                f.write(content)\n        test_case_info = {\"spj\": spj, \"test_cases\": {}}\n\n        info = []\n\n        if spj:\n            for index, item in enumerate(test_case_list):\n                data = {\"input_name\": item, \"input_size\": size_cache[item]}\n                info.append(data)\n                test_case_info[\"test_cases\"][str(index + 1)] = data\n        else:\n            # [\"1.in\", \"1.out\", \"2.in\", \"2.out\"] => [(\"1.in\", \"1.out\"), (\"2.in\", \"2.out\")]\n            test_case_list = zip(*[test_case_list[i::2] for i in range(2)])\n            for index, item in enumerate(test_case_list):\n                data = {\"stripped_output_md5\": md5_cache[item[1]],\n                        \"input_size\": size_cache[item[0]],\n                        \"output_size\": size_cache[item[1]],\n                        \"input_name\": item[0],\n                        \"output_name\": item[1]}\n                info.append(data)\n                test_case_info[\"test_cases\"][str(index + 1)] = data\n\n        with open(os.path.join(test_case_dir, \"info\"), \"w\", encoding=\"utf-8\") as f:\n            f.write(json.dumps(test_case_info, indent=4))\n\n        for item in os.listdir(test_case_dir):\n            os.chmod(os.path.join(test_case_dir, item), 0o640)\n\n        return info, test_case_id\n\n    def filter_name_list(self, name_list, spj, dir=\"\"):\n        ret = []\n        prefix = 1\n        if spj:\n            while True:\n                in_name = f\"{prefix}.in\"\n                if f\"{dir}{in_name}\" in name_list:\n                    ret.append(in_name)\n                    prefix += 1\n                    continue\n                else:\n                    return sorted(ret, key=natural_sort_key)\n        else:\n            while True:\n                in_name = f\"{prefix}.in\"\n                out_name = f\"{prefix}.out\"\n                if f\"{dir}{in_name}\" in name_list and f\"{dir}{out_name}\" in name_list:\n                    ret.append(in_name)\n                    ret.append(out_name)\n                    prefix += 1\n                    continue\n                else:\n                    return sorted(ret, key=natural_sort_key)", ""]}
{"filename": "OJ/util/cache.py", "chunked_list": ["import redis\n\nfrom OJ.app.settings import *\nfrom OJ.util.constant import *\n\n\nclass Cache(object):\n    def __init__(self, queue=CacheKey.waiting_queue, host=REDIS_HOST, port=REDIS_PORT, password=REDIS_PASSWORD,\n                 db=REDIS_DB):\n        self.queue_name = queue\n        self.client = redis.Redis(host=host, port=port, password=password, db=db)\n\n    def push(self, data):\n        self.client.rpush(self.queue_name, data)\n\n    def pop(self):\n        return self.client.lpop(self.queue_name)\n\n    def __getitem__(self, ix):\n        return self.client.lindex(self.queue_name, ix)\n\n    def __len__(self):\n        return self.client.llen(self.queue_name)", ""]}
{"filename": "OJ/util/judge.py", "chunked_list": ["import hashlib\nimport json\nimport logging\nfrom urllib.parse import urljoin\n\nfrom sqlalchemy.orm import Session\nimport requests\n\nfrom OJ.app.settings import *\nfrom OJ.db.database import engine, SessionLocal", "from OJ.app.settings import *\nfrom OJ.db.database import engine, SessionLocal\nfrom OJ.models import *\nfrom OJ.models.JudgeModel import JudgeServer\n\nlogger = logging.getLogger(__name__)\n\n\nclass ChooseJudgeServer:\n    def __init__(self, sess=Session(engine)):\n        self.server = None\n        self.sess = sess\n\n    def __enter__(self) -> [JudgeServer, None]:\n        servers = self.sess.query(JudgeServer).filter_by(is_disabled=False).order_by(\"task_number\").all()\n        servers = [s for s in servers if s.status == \"normal\"]\n        for server in servers:\n            if server.task_number <= server.cpu_core * 2:\n                server.task_number = server.task_number + 1\n                self.sess.commit()\n                self.server = server\n                return server\n        return None\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if self.server:\n            self.sess.begin()\n            server = self.sess.query(JudgeServer).filter_by(id=self.server.id).first()\n            server.task_number = server.task_number - 1\n            self.sess.commit()\n            self.sess.close()", "class ChooseJudgeServer:\n    def __init__(self, sess=Session(engine)):\n        self.server = None\n        self.sess = sess\n\n    def __enter__(self) -> [JudgeServer, None]:\n        servers = self.sess.query(JudgeServer).filter_by(is_disabled=False).order_by(\"task_number\").all()\n        servers = [s for s in servers if s.status == \"normal\"]\n        for server in servers:\n            if server.task_number <= server.cpu_core * 2:\n                server.task_number = server.task_number + 1\n                self.sess.commit()\n                self.server = server\n                return server\n        return None\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if self.server:\n            self.sess.begin()\n            server = self.sess.query(JudgeServer).filter_by(id=self.server.id).first()\n            server.task_number = server.task_number - 1\n            self.sess.commit()\n            self.sess.close()", "\n\nclass DispatcherBase(object):\n    def __init__(self):\n        self.token = hashlib.sha256(JUDGER_TOKEN.encode()).hexdigest()\n\n    def _request(self, url=JUDGER_SERVER, data=None, language=None):\n        kwargs = {\"headers\": {\"X-Judge-Server-Token\": self.token}}\n        if data:\n            kwargs[\"json\"] = data\n        try:\n            return requests.post(url, params={\n                'language': language\n            }, data=data, **kwargs).json()\n        except Exception as e:\n            logger.exception(e)", "\n\nclass JudgeDispatcher(DispatcherBase):\n\n    def __init__(self, submission_id, problem_id, session=SessionLocal(), cp_id=-1):\n        \"\"\"\n        :param submission_id: which submission\n        :param problem_id: which problem\n        :param db: db_session\n        \"\"\"\n        super().__init__()\n        self.sess = session\n        self.cp_id = cp_id\n        if cp_id > 0:\n            self.cp = self.sess.query(ContestProblem).filter_by(id=cp_id).first()\n        else:\n            self.cp = None\n        self.submission_id = submission_id\n\n        self.submission = self.sess.query(Submission).filter_by(id=self.submission_id).first()\n        self.problem_id = problem_id\n        self.contest_id = self.submission.contest_id\n        self.last_result = self.submission.result if self.submission.info else None\n        # submission.statistic_info\n        self.statistic_info = {}\n\n        if self.contest_id:\n            self.contest = self.submission.contest\n        else:\n            self.contest = None\n        self.problem = self.submission.problem\n\n    def _compute_statistic_info(self, resp_data):\n        # \u7528\u65f6\u548c\u5185\u5b58\u5360\u7528\u4fdd\u5b58\u4e3a\u591a\u4e2a\u6d4b\u8bd5\u70b9\u4e2d\u6700\u957f\u7684\u90a3\u4e2a\n        self.statistic_info[\"time_cost\"] = max([x[\"cpu_time\"] for x in resp_data])\n        self.statistic_info[\"memory_cost\"] = max([x[\"memory\"] for x in resp_data])\n        # sum up the score in OI mode\n        if self.problem.mode == PROBLEM_MODE.OI:\n            score = 0\n            try:\n                for i in range(len(resp_data)):\n                    if resp_data[i][\"result\"] == JudgeStatus.ACCEPTED:\n                        resp_data[i][\"score\"] = self.problem.test_case_score[str(i)]\n                        score += resp_data[i][\"score\"]\n                    else:\n                        resp_data[i][\"score\"] = 0\n            except IndexError:\n                logger.error(f\"Index Error raised when summing up the score in problem {self.problem.id}\")\n                self.statistic_info[\"score\"] = 0\n                return\n            self.statistic_info[\"score\"] = score\n\n    def judge(self):\n        language = self.submission.language\n        code = self.submission.code_source\n        problem = self.sess.query(ProblemInfo).filter_by(id=self.problem_id).first()\n        judge_params = {\n            'src': code,\n            'max_memory': problem.memory_limit * 1024 * 1024,\n            'test_case_id': problem.test_id,\n            'max_cpu_time': problem.time_limit\n        }\n        with ChooseJudgeServer() as server:\n            # if not server:\n            #     print('No Server')\n            #     data = {\"submission_id\": self.submission.id, \"problem_id\": self.problem_id}\n            #     submission_cache.push(json.dumps(data))\n            #     return\n            self.submission.result = JudgeStatus.JUDGING\n            self.sess.commit()\n            resp = self._request(urljoin(JUDGER_SERVER, \"/judge\"), data=judge_params, language=language)\n        if not resp:\n            self.submission.result = JudgeStatus.SYSTEM_ERROR\n            self.sess.commit()\n            return\n\n        if resp[\"err\"]:\n            self.submission.result = JudgeStatus.COMPILE_ERROR\n            self.statistic_info[\"err_info\"] = resp[\"data\"]\n            self.statistic_info[\"score\"] = 0\n            self.submission.info = resp\n        else:\n            resp[\"data\"].sort(key=lambda x: int(x[\"test_case\"]))\n            self.submission.info = resp\n            self._compute_statistic_info(resp[\"data\"])\n            error_test_case = list(filter(lambda case: case[\"result\"] != 0, resp[\"data\"]))\n            if not error_test_case:\n                self.submission.result = JudgeStatus.ACCEPTED\n            elif problem.mode == PROBLEM_MODE.ACM or len(error_test_case) == len(resp[\"data\"]):\n                self.submission.result = error_test_case[0][\"result\"]\n            else:\n                self.submission.result = JudgeStatus.PARTIALLY_ACCEPTED\n        self.sess.commit()\n        ups = self.sess.query(UserProblemStatus).filter_by(\n            user_id=self.submission.user_id,\n            problem_id=self.problem_id\n        ).first()\n        problem.submission_count = self.problem.submission_count + 1\n        if not ups:\n            ups = UserProblemStatus(\n                user_id=self.submission.user_id,\n                problem_id=self.problem_id,\n            )\n            exist = False\n        else:\n            exist = True\n        if exist and ups.is_ac:\n            return\n        if self.problem.mode == PROBLEM_MODE.OI:\n            now_score = self.statistic_info['score']\n            is_ac = self.problem.total_score == now_score\n            ups.is_ac = is_ac\n            if is_ac:\n                ups.ac_id = self.submission.id\n            ups.score = now_score\n        else:\n            is_ac = self.submission.result == JudgeStatus.ACCEPTED\n            if is_ac:\n                ups.ac_id = self.submission.id\n            ups.is_ac = is_ac\n        if not exist:\n            self.sess.add(ups)\n        self.sess.commit()\n\n        if self.contest_id:\n            self.update_contest_problem_status()\n\n        self.sess.expire_all()\n        self.sess.close_all()\n        self.sess.close()\n\n    def update_contest_problem_status(self):\n        if self.contest.rule == ContestRuleType.ACM:\n            self._update_acm_contest_rank()\n\n        elif self.contest.rule == ContestRuleType.OI:\n            self._update_oi_contest_rank()\n        problem = self.sess.query(ProblemInfo).filter_by(id=self.problem.id).first()\n        result = str(self.submission.result)\n        problem_info = problem.statistic_info\n        problem_info[result] = problem_info.get(result, 0) + 1\n        submission_count = problem.submission_count\n        if not submission_count:\n            submission_count = 0\n        ac_count = problem.ac_count\n        if not ac_count:\n            ac_count = 0\n        wa_count = problem.wa_count\n        if not wa_count:\n            wa_count = 0\n        if self.submission.result == JudgeStatus.ACCEPTED:\n            ac_count = ac_count + 1\n        else:\n            wa_count = wa_count + 1\n        self.sess.query(ProblemInfo).filter_by(id=self.problem.id).update({\n            ProblemInfo.ac_count: ac_count,\n            ProblemInfo.wa_count: wa_count,\n            ProblemInfo.submission_count: submission_count,\n            ProblemInfo.statistic_info: problem_info\n        })\n        self.sess.commit()\n\n    def _update_acm_contest_rank(self):\n        with Session(engine) as session:\n            session.begin()\n            rank = session.query(ACMRank).filter_by(cp_id=self.cp_id)\n            user_rank = rank.filter_by(user_id=self.submission.user_id).first()\n            ac_rank = rank.filter_by(is_ac=True).all()\n            if not user_rank:\n                is_ac = self.submission.result == 0\n                submission_number = 1\n                if is_ac:\n                    diff_time = datetime.datetime.now() - self.contest.start_at\n                    ac_time = diff_time.days * 24 * 3600 + diff_time.seconds\n                    total_time = ac_time\n                else:\n                    ac_time = None\n                    total_time = 20 * 60\n                is_first_ac = len(ac_rank) == 0\n                new_rank = ACMRank(\n                    user_id=self.submission.user_id,\n                    cp_id=self.cp_id,\n                    submission_id=self.submission.id,\n                    submission_number=submission_number,\n                    total_time=total_time,\n                    is_ac=is_ac,\n                    is_first_ac=is_first_ac,\n                    ac_time=ac_time\n                )\n                session.add(new_rank)\n            else:\n                if user_rank.is_ac:\n                    return\n                submission_number = user_rank.submission_number\n                user_rank.submission_number = submission_number + 1\n                is_ac = self.submission.result == 0\n                if is_ac:\n                    diff_time = datetime.datetime.now() - self.contest.start_at\n                    ac_time = diff_time.days * 24 * 3600 + diff_time.seconds\n                    total_time = submission_number * 20 * 60 + ac_time\n                else:\n                    ac_time = None\n                    total_time = user_rank.total_time + 20 * 60\n                is_first_ac = len(ac_rank) == 0 and is_ac\n                user_rank.is_ac = is_ac\n                user_rank.total_time = total_time\n                user_rank.is_first_ac = is_first_ac\n                user_rank.ac_time = ac_time\n            session.commit()\n\n    def _update_oi_contest_rank(self):\n        with Session(engine) as session:\n            session.begin()\n            rank = session.query(OIRank).filter_by(\n                user_id=self.submission.user_id,\n                cp_id=self.cp_id,\n            ).first()\n            if not rank:\n                rank = OIRank(\n                    user_id=self.submission.user_id,\n                    cp_id=self.cp_id,\n                    submission_id=self.submission_id,\n                    total_score=self.submission.statistic_info[\"score\"],\n                    submission_number=1,\n                )\n                is_ac = rank.total_score == self.problem.total_score\n                rank.is_ac = is_ac\n                if is_ac:\n                    rank.ac_time = (datetime.datetime.now() - self.contest.start_at).seconds\n                session.add(rank)\n            else:\n                last_score = rank.total_score\n                if self.submission.statistic_info[\"score\"] > last_score:\n                    last_score = self.submission.statistic_info[\"score\"]\n                rank.total_score = last_score\n                is_ac = rank.total_score == self.problem.total_score\n                rank.is_ac = is_ac\n                if is_ac:\n                    rank.ac_time = (datetime.datetime.now() - self.contest.start_at).seconds\n            session.commit()", ""]}
{"filename": "OJ/util/__init__.py", "chunked_list": ["from .common import *\nfrom .zip_processor import *\nfrom .cache import Cache\n\nsubmission_cache = Cache()\n"]}
{"filename": "OJ/util/controller.py", "chunked_list": ["from OJ.models.UserModels import UserSession, UserInfo\n\nfrom sqlalchemy.orm import Session\nfrom OJ.db.database import engine\n\n\ndef get_user(token) -> UserInfo:\n    with Session(engine) as session:\n        session.begin()\n        sess = session.query(UserSession).filter(UserSession.token == token).first()\n        if not sess:\n            return UserInfo()\n        user = sess.sess2user\n        session.close()\n        return user", ""]}
{"filename": "OJ/util/schedule.py", "chunked_list": ["import datetime\n\nfrom pydantic import BaseModel\n\n\nclass LoginForm(BaseModel):\n    username: str\n    password: str\n\n\nclass RegisterForm(BaseModel):\n    username: str\n    email: str\n    password: str\n    confirmPassword: str\n    code: str", "\n\nclass RegisterForm(BaseModel):\n    username: str\n    email: str\n    password: str\n    confirmPassword: str\n    code: str\n\n\nclass ProblemForm(BaseModel):\n    cid: str = ''\n    id: int = -1\n    title: str\n    description: str\n    inputs: str\n    outputs: str\n    samples: list\n    language: list\n    mode: int\n    is_spj: bool\n    source: str\n    time_limit: int\n    memory_limit: int\n    hints: str\n    test_id: str", "\n\nclass ProblemForm(BaseModel):\n    cid: str = ''\n    id: int = -1\n    title: str\n    description: str\n    inputs: str\n    outputs: str\n    samples: list\n    language: list\n    mode: int\n    is_spj: bool\n    source: str\n    time_limit: int\n    memory_limit: int\n    hints: str\n    test_id: str", "\n\nclass JudgeForm(BaseModel):\n    pid: str\n    language: str\n    source_code: str\n    cp_id: str = ''\n\n\nclass ContestForm(BaseModel):\n    id: int = -1\n    title: str\n    description: str\n    start_at: str\n    end_at: str\n    contest_type: int\n    password: str\n    only_id: str\n    rule: int", "\nclass ContestForm(BaseModel):\n    id: int = -1\n    title: str\n    description: str\n    start_at: str\n    end_at: str\n    contest_type: int\n    password: str\n    only_id: str\n    rule: int", ""]}
{"filename": "OJ/util/common.py", "chunked_list": ["import hashlib\nimport random\nimport re\n\n\ndef get_random_string(length=24, allowed_chars='1234567890qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM'):\n    code = ''\n    for _ in range(length):\n        code += allowed_chars[random.randint(0, len(allowed_chars) - 1)]\n    return code", "\n\ndef natural_sort_key(s, _nsre=re.compile(r\"(\\d+)\")):\n    return [int(text) if text.isdigit() else text.lower()\n            for text in re.split(_nsre, s)]\n\n\ndef rand_str(length=32, type=\"lower_hex\"):\n    if type == \"str\":\n        return get_random_string(length, allowed_chars=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\")\n    elif type == \"lower_str\":\n        return get_random_string(length, allowed_chars=\"abcdefghijklmnopqrstuvwxyz0123456789\")\n    elif type == \"lower_hex\":\n        return random.choice(\"123456789abcdef\") + get_random_string(length - 1, allowed_chars=\"0123456789abcdef\")\n    else:\n        return random.choice(\"123456789\") + get_random_string(length - 1, allowed_chars=\"0123456789\")", "\n\ndef hash256(text: str):\n    hash_object = hashlib.sha256()\n    hash_object.update(text.encode())\n    hash_value = hash_object.hexdigest()\n    return hash_value\n\n\ndef get_file_md5(file_name):\n    \"\"\"\n    \u8ba1\u7b97\u6587\u4ef6\u7684md5\n    :param file_name:\n    :return:\n    \"\"\"\n    m = hashlib.md5()  # \u521b\u5efamd5\u5bf9\u8c61\n    with open(file_name, 'rb') as fobj:\n        while True:\n            data = fobj.read(4096)\n            if not data:\n                break\n            m.update(data)  # \u66f4\u65b0md5\u5bf9\u8c61\n\n    return m.hexdigest()  # \u8fd4\u56demd5\u5bf9\u8c61", "\ndef get_file_md5(file_name):\n    \"\"\"\n    \u8ba1\u7b97\u6587\u4ef6\u7684md5\n    :param file_name:\n    :return:\n    \"\"\"\n    m = hashlib.md5()  # \u521b\u5efamd5\u5bf9\u8c61\n    with open(file_name, 'rb') as fobj:\n        while True:\n            data = fobj.read(4096)\n            if not data:\n                break\n            m.update(data)  # \u66f4\u65b0md5\u5bf9\u8c61\n\n    return m.hexdigest()  # \u8fd4\u56demd5\u5bf9\u8c61", "\n\ndef get_str_md5(content):\n    \"\"\"\n    \u8ba1\u7b97\u5b57\u7b26\u4e32md5\n    :param content:\n    :return:\n    \"\"\"\n    m = hashlib.md5(content)  # \u521b\u5efamd5\u5bf9\u8c61\n    return m.hexdigest()", ""]}
{"filename": "OJ/util/aes.py", "chunked_list": ["from Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad, unpad\nimport base64\nimport os\n\nfrom OJ.app.settings import AES_KEY\n\n\nclass AESTool:\n\n    @staticmethod\n    def encrypt_data(plaintext):\n        plaintext = str(plaintext)\n        iv = os.urandom(AES.block_size)\n        cipher = AES.new(AES_KEY.encode(), AES.MODE_CBC, iv)\n        ciphertext = cipher.encrypt(pad(plaintext.encode(), AES.block_size))\n        encrypted_data = base64.b64encode(iv + ciphertext).decode()\n        encrypted_data = encrypted_data.replace('/', '~')\n        return encrypted_data\n\n    @staticmethod\n    def decrypt_data(encrypted_data):\n        encrypted_data = encrypted_data.replace('~', '/')\n        ciphertext = base64.b64decode(encrypted_data)\n        iv = ciphertext[:AES.block_size]\n        ciphertext = ciphertext[AES.block_size:]\n        cipher = AES.new(AES_KEY.encode(), AES.MODE_CBC, iv)\n        decrypted_data = unpad(cipher.decrypt(ciphertext), AES.block_size)\n        return decrypted_data.decode()", "class AESTool:\n\n    @staticmethod\n    def encrypt_data(plaintext):\n        plaintext = str(plaintext)\n        iv = os.urandom(AES.block_size)\n        cipher = AES.new(AES_KEY.encode(), AES.MODE_CBC, iv)\n        ciphertext = cipher.encrypt(pad(plaintext.encode(), AES.block_size))\n        encrypted_data = base64.b64encode(iv + ciphertext).decode()\n        encrypted_data = encrypted_data.replace('/', '~')\n        return encrypted_data\n\n    @staticmethod\n    def decrypt_data(encrypted_data):\n        encrypted_data = encrypted_data.replace('~', '/')\n        ciphertext = base64.b64decode(encrypted_data)\n        iv = ciphertext[:AES.block_size]\n        ciphertext = ciphertext[AES.block_size:]\n        cipher = AES.new(AES_KEY.encode(), AES.MODE_CBC, iv)\n        decrypted_data = unpad(cipher.decrypt(ciphertext), AES.block_size)\n        return decrypted_data.decode()", ""]}
{"filename": "OJ/models/UserModels.py", "chunked_list": ["from sqlalchemy import Boolean, Column, ForeignKey, Integer, String, DateTime, JSON\nfrom sqlalchemy.orm import relationship\nimport datetime\n\nfrom OJ.db.database import Base, BaseModel\nfrom OJ.util.common import hash256\n\n\nclass UserInfo(Base, BaseModel):\n    __tablename__ = 'UserInfo'\n\n    id = Column(Integer, primary_key=True, index=True, autoincrement=True)\n    username = Column(String(200), unique=True, nullable=False)\n    email = Column(String(200), unique=True, nullable=False)\n    password = Column(String(200))\n    is_admin = Column(Boolean, default=False)\n    lastlogin = Column(DateTime, default=datetime.datetime.now)\n\n    real_name = Column(String(30), nullable=True)\n    accepted_number = Column(Integer, default=0)\n    total_score = Column(Integer, default=0)\n    submission_number = Column(Integer, default=0)\n\n    def check_password(self, _password):\n        return hash256(_password) == self.password\n\n    def make_password(self, _password):\n        self.password = hash256(_password)\n\n    def add_accepted_problem_number(self):\n        self.accepted_number = self.accepted_number + 1\n\n    def add_submission_number(self):\n        self.submission_number = self.submission_number + 1", "class UserInfo(Base, BaseModel):\n    __tablename__ = 'UserInfo'\n\n    id = Column(Integer, primary_key=True, index=True, autoincrement=True)\n    username = Column(String(200), unique=True, nullable=False)\n    email = Column(String(200), unique=True, nullable=False)\n    password = Column(String(200))\n    is_admin = Column(Boolean, default=False)\n    lastlogin = Column(DateTime, default=datetime.datetime.now)\n\n    real_name = Column(String(30), nullable=True)\n    accepted_number = Column(Integer, default=0)\n    total_score = Column(Integer, default=0)\n    submission_number = Column(Integer, default=0)\n\n    def check_password(self, _password):\n        return hash256(_password) == self.password\n\n    def make_password(self, _password):\n        self.password = hash256(_password)\n\n    def add_accepted_problem_number(self):\n        self.accepted_number = self.accepted_number + 1\n\n    def add_submission_number(self):\n        self.submission_number = self.submission_number + 1", "\n\nclass UserSession(Base, BaseModel):\n    __tablename__ = 'UserSession'\n\n    id = Column(Integer, primary_key=True, index=True, autoincrement=True)\n    user_id = Column(Integer, ForeignKey('UserInfo.id'), nullable=False)\n    token = Column(String(200), nullable=False)\n    sess2user = relationship('UserInfo', backref='user2sess')\n    time = Column(DateTime,\n                  onupdate=datetime.datetime.now,\n                  default=datetime.datetime.now\n                  )\n    expire_time = Column(DateTime,\n                         onupdate=datetime.datetime.now() + datetime.timedelta(days=1),\n                         default=datetime.datetime.now() + datetime.timedelta(days=1)\n                         )\n    _user = relationship('UserInfo', backref='session')\n\n    @property\n    def user(self):\n        return self._user", ""]}
{"filename": "OJ/models/SubmissionModel.py", "chunked_list": ["from sqlalchemy import Column, ForeignKey, Integer, String, DateTime, Text, JSON\nfrom sqlalchemy.orm import relationship\nimport datetime\n\nfrom OJ.db.database import Base, BaseModel\nfrom OJ.util.constant import *\n\n\nclass Submission(Base, BaseModel):\n    __tablename__ = 'Submission'\n\n    id = Column(Integer, primary_key=True, index=True, autoincrement=True)\n    user_id = Column(Integer, ForeignKey('UserInfo.id'))\n    language = Column(String(30))\n    contest_id = Column(Integer, ForeignKey('ContestInfo.id'))\n    problem_id = Column(Integer, ForeignKey('ProblemInfo.id'))\n    create_time = Column(DateTime, default=datetime.datetime.now)\n    code_source = Column(String(5000), nullable=False)\n    result = Column(Integer, default=JudgeStatus.PENDING)\n    info = Column(JSON, default={})  # judger response\n    statistic_info = Column(JSON, default={})\n\n    _user = relationship('UserInfo', backref='submissions')\n    _contest = relationship('ContestInfo', backref='submissions')\n    _problem = relationship('ProblemInfo', backref='submissions')\n\n    @property\n    def user(self):\n        return self._user\n\n    @property\n    def problem(self):\n        return self._problem\n\n    @property\n    def contest(self):\n        return self._contest\n\n    @property\n    def is_ac(self):\n        return self.result == JudgeStatus.ACCEPTED", "class Submission(Base, BaseModel):\n    __tablename__ = 'Submission'\n\n    id = Column(Integer, primary_key=True, index=True, autoincrement=True)\n    user_id = Column(Integer, ForeignKey('UserInfo.id'))\n    language = Column(String(30))\n    contest_id = Column(Integer, ForeignKey('ContestInfo.id'))\n    problem_id = Column(Integer, ForeignKey('ProblemInfo.id'))\n    create_time = Column(DateTime, default=datetime.datetime.now)\n    code_source = Column(String(5000), nullable=False)\n    result = Column(Integer, default=JudgeStatus.PENDING)\n    info = Column(JSON, default={})  # judger response\n    statistic_info = Column(JSON, default={})\n\n    _user = relationship('UserInfo', backref='submissions')\n    _contest = relationship('ContestInfo', backref='submissions')\n    _problem = relationship('ProblemInfo', backref='submissions')\n\n    @property\n    def user(self):\n        return self._user\n\n    @property\n    def problem(self):\n        return self._problem\n\n    @property\n    def contest(self):\n        return self._contest\n\n    @property\n    def is_ac(self):\n        return self.result == JudgeStatus.ACCEPTED", "\n\n\n"]}
{"filename": "OJ/models/JudgeModel.py", "chunked_list": ["from sqlalchemy import Boolean, Column, Integer, String, DateTime, Float\nimport datetime\n\nfrom OJ.db.database import Base, BaseModel\n\n\nclass JudgeServer(Base, BaseModel):\n    __tablename__ = 'JudgerServer'\n\n    id = Column(Integer, primary_key=True, index=True, autoincrement=True)\n    ip = Column(String(50), nullable=True)\n    port = Column(String(50))\n    hostname = Column(String(50))\n    judger_version = Column(String(50))\n    cpu_core = Column(Integer)\n    memory_usage = Column(Float)\n    cpu_usage = Column(Float)\n    last_heartbeat = Column(DateTime)\n    create_time = Column(DateTime, default=datetime.datetime.now)\n    task_number = Column(Integer, default=0)\n    service_url = Column(String(100))\n    is_disabled = Column(Boolean, default=False)\n\n    @property\n    def status(self):\n        # \u589e\u52a0\u4e00\u79d2\u5ef6\u65f6\uff0c\u63d0\u9ad8\u5bf9\u7f51\u7edc\u73af\u5883\u7684\u9002\u5e94\u6027\n        # if (datetime.datetime.now() - self.last_heartbeat).seconds > 6:\n        #     return \"abnormal\"\n        return \"normal\"", ""]}
{"filename": "OJ/models/ContestModel.py", "chunked_list": ["from sqlalchemy import Boolean, Column, ForeignKey, Integer, String, DateTime, BigInteger\nfrom sqlalchemy.orm import relationship\nimport datetime\n\nfrom OJ.util.constant import ContestStatus\nfrom OJ.db.database import Base, BaseModel\n\n\nclass ContestInfo(Base, BaseModel):\n    __tablename__ = 'ContestInfo'\n\n    id = Column(Integer, primary_key=True, index=True, autoincrement=True)\n    title = Column(String(200), nullable=False)\n    description = Column(String(5000), nullable=False)  # Description\n    start_at = Column(DateTime, nullable=False)\n    end_at = Column(DateTime, nullable=False)\n    # 0-->Normal 1-->Password Protected\n    # 2-->Hidden but available(visit by invitation URL)\n    # 3-->Hidden and unavailable\n    contest_type = Column(Integer, default=0)\n    password = Column(String(100), default='')  # needed if contest_type==1\n    only_id = Column(String(50), default='')  # needed if contest_type==2\n    rule = Column(Integer, default=0)  # 0-->ACM 1-->OI\n    created_by = Column(Integer, ForeignKey('UserInfo.id'))\n    _user = relationship('UserInfo', backref='contests')\n\n    @property\n    def status(self):\n        if self.start_at > datetime.datetime.now():\n            # \u6ca1\u6709\u5f00\u59cb \u8fd4\u56de1\n            return ContestStatus.CONTEST_NOT_START\n        elif self.end_at < datetime.datetime.now():\n            # \u5df2\u7ecf\u7ed3\u675f \u8fd4\u56de-1\n            return ContestStatus.CONTEST_ENDED\n        else:\n            # \u6b63\u5728\u8fdb\u884c \u8fd4\u56de0\n            return ContestStatus.CONTEST_UNDERWAY\n\n    def user(self, filed=None):\n        if not filed:\n            return self._user\n        else:\n            return getattr(self._user, filed)", "class ContestInfo(Base, BaseModel):\n    __tablename__ = 'ContestInfo'\n\n    id = Column(Integer, primary_key=True, index=True, autoincrement=True)\n    title = Column(String(200), nullable=False)\n    description = Column(String(5000), nullable=False)  # Description\n    start_at = Column(DateTime, nullable=False)\n    end_at = Column(DateTime, nullable=False)\n    # 0-->Normal 1-->Password Protected\n    # 2-->Hidden but available(visit by invitation URL)\n    # 3-->Hidden and unavailable\n    contest_type = Column(Integer, default=0)\n    password = Column(String(100), default='')  # needed if contest_type==1\n    only_id = Column(String(50), default='')  # needed if contest_type==2\n    rule = Column(Integer, default=0)  # 0-->ACM 1-->OI\n    created_by = Column(Integer, ForeignKey('UserInfo.id'))\n    _user = relationship('UserInfo', backref='contests')\n\n    @property\n    def status(self):\n        if self.start_at > datetime.datetime.now():\n            # \u6ca1\u6709\u5f00\u59cb \u8fd4\u56de1\n            return ContestStatus.CONTEST_NOT_START\n        elif self.end_at < datetime.datetime.now():\n            # \u5df2\u7ecf\u7ed3\u675f \u8fd4\u56de-1\n            return ContestStatus.CONTEST_ENDED\n        else:\n            # \u6b63\u5728\u8fdb\u884c \u8fd4\u56de0\n            return ContestStatus.CONTEST_UNDERWAY\n\n    def user(self, filed=None):\n        if not filed:\n            return self._user\n        else:\n            return getattr(self._user, filed)", "\n\nclass ContestProblem(Base, BaseModel):\n    __tablename__ = 'ContestProblem'\n\n    id = Column(Integer, primary_key=True, index=True, autoincrement=True)\n    cid = Column(Integer, ForeignKey('ContestInfo.id'), nullable=False)\n    pid = Column(Integer, ForeignKey('ProblemInfo.id'), nullable=False)\n    is_visible = Column(Boolean, default=True)\n    _contest = relationship('ContestInfo', backref='cps')\n    _problem = relationship('ProblemInfo', backref='cps')\n\n    @property\n    def contest(self):\n        return self._contest\n\n    @property\n    def problem(self):\n        return self._problem", "\n\nclass ACMRank(Base, BaseModel):\n    __tablename__ = 'ACMRank'\n\n    id = Column(Integer, primary_key=True, index=True, autoincrement=True)\n    user_id = Column(Integer, ForeignKey('UserInfo.id'), nullable=False)\n    cp_id = Column(Integer, ForeignKey('ContestProblem.id'), nullable=False)\n    submission_id = Column(Integer, ForeignKey('Submission.id'))\n    submission_number = Column(Integer, default=0)  # tries\n\n    total_time = Column(BigInteger, default=0)\n    is_ac = Column(Boolean, default=False)\n    is_first_ac = Column(Boolean, default=False)\n    ac_time = Column(Integer, default=0)\n\n    _user = relationship('UserInfo', backref='acm_ranks')\n    _cp = relationship('ContestProblem', backref='acm_rank')\n    _submission = relationship('Submission')\n\n    def user(self, filed=None):\n        if not filed:\n            return self._user\n        else:\n            return getattr(self._user, filed)\n\n    @property\n    def cp(self) -> ContestProblem:\n        return self._cp\n\n    @property\n    def contest(self) -> ContestInfo:\n        return self.cp.contest\n\n    @property\n    def problem(self):\n        return self.cp.problem", "\n\nclass OIRank(Base, BaseModel):\n    __tablename__ = 'oi_rank'\n\n    id = Column(Integer, primary_key=True, index=True, autoincrement=True)\n    user_id = Column(Integer, ForeignKey('UserInfo.id'))\n    cp_id = Column(Integer, ForeignKey('ContestProblem.id'))\n    submission_id = Column(Integer, ForeignKey('Submission.id'))\n    submission_number = Column(Integer, default=0)  # tries\n\n    total_score = Column(Integer, default=0)\n    is_ac = Column(Boolean, default=False)\n    ac_time = Column(Integer, default=0)\n\n    _user = relationship('UserInfo', backref='oi_ranks')\n    _cp = relationship('ContestProblem', backref='oi_rank')\n    _submission = relationship('Submission')\n\n    @property\n    def user(self):\n        return self._user\n\n    @property\n    def cp(self) -> ContestProblem:\n        return self._cp\n\n    @property\n    def contest(self) -> ContestInfo:\n        return self.cp.contest\n\n    @property\n    def problem(self):\n        return self.cp.problem\n\n    @property\n    def submission(self):\n        return self._submission", "\n\nclass Announcement(Base, BaseModel):\n    __tablename__ = 'Announcement'\n\n    id = Column(Integer, primary_key=True, index=True, autoincrement=True)\n    title = Column(String(200), nullable=False)\n    content = Column(String(5000), nullable=False)\n    create_time = Column(DateTime, default=datetime.datetime.now)\n    update_time = Column(DateTime, default=datetime.datetime.now, onupdate=datetime.datetime.now)\n    contest = Column(Integer, ForeignKey('ContestInfo.id'), nullable=False)\n    author = Column(Integer, ForeignKey('UserInfo.id'), nullable=False)\n    is_visible = Column(Integer, default=True)\n    _contest = relationship('ContestInfo', backref='announcements')\n    _user = relationship('UserInfo', backref='contest_announcements')\n\n    def user(self, filed=None):\n        if not filed:\n            return self._user\n        else:\n            return getattr(self._user, filed)", ""]}
{"filename": "OJ/models/ProblemModels.py", "chunked_list": ["from sqlalchemy import Boolean, Column, ForeignKey, Integer, String, DateTime, Text, JSON\nfrom sqlalchemy.orm import relationship\nimport datetime\n\nfrom OJ.db.database import Base, BaseModel\nfrom OJ.util.aes import AESTool\n\n\nclass ProblemInfo(Base, BaseModel):\n    __tablename__ = 'ProblemInfo'\n\n    id = Column(Integer, primary_key=True, index=True, autoincrement=True)\n    title = Column(String(200), nullable=False)\n    description = Column(Text, nullable=False)  # Description\n    inputs = Column(Text, nullable=False)  # Input\n    outputs = Column(Text, nullable=False)  # Output\n    language = Column(Text, nullable=False)\n    # sample input1|||sample output1+#+#sample input2|||sample output2\n    samples = Column(Text, nullable=False, default='')\n    hints = Column(Text, default='')\n    source = Column(Text, default='')\n    is_spj = Column(Boolean, default=False)  # normal judge/special judge\n    test_id = Column(String(50))\n    submission_count = Column(Integer, default=0)\n    ac_count = Column(Integer, default=0)\n    wa_count = Column(Integer, default=0)\n    time_limit = Column(Integer, default=1000)  # ms\n    memory_limit = Column(Integer, default=256)  # MB\n    mode = Column(Integer, default=0)  # 0-->ACM 1-->OI\n    # 0-->show 1-->hide\n    # 2-->contest mode but hide\n    # 3-->contest mode but show\n    status = Column(Integer, default=0)\n    test_case_score = Column(JSON, default={})\n    total_score = Column(Integer, default=0)\n    create_time = Column(DateTime, default=datetime.datetime.now)\n    created_by = Column(Integer, ForeignKey('UserInfo.id'))\n    statistic_info = Column(JSON, default={})\n    _user = relationship('UserInfo', backref='problems')\n\n\n    @property\n    def pid(self):\n        return AESTool.encrypt_data(self.id)\n\n    def user(self, filed=None):\n        if not filed:\n            return self._user\n        else:\n            return getattr(self._user, filed)", "class ProblemInfo(Base, BaseModel):\n    __tablename__ = 'ProblemInfo'\n\n    id = Column(Integer, primary_key=True, index=True, autoincrement=True)\n    title = Column(String(200), nullable=False)\n    description = Column(Text, nullable=False)  # Description\n    inputs = Column(Text, nullable=False)  # Input\n    outputs = Column(Text, nullable=False)  # Output\n    language = Column(Text, nullable=False)\n    # sample input1|||sample output1+#+#sample input2|||sample output2\n    samples = Column(Text, nullable=False, default='')\n    hints = Column(Text, default='')\n    source = Column(Text, default='')\n    is_spj = Column(Boolean, default=False)  # normal judge/special judge\n    test_id = Column(String(50))\n    submission_count = Column(Integer, default=0)\n    ac_count = Column(Integer, default=0)\n    wa_count = Column(Integer, default=0)\n    time_limit = Column(Integer, default=1000)  # ms\n    memory_limit = Column(Integer, default=256)  # MB\n    mode = Column(Integer, default=0)  # 0-->ACM 1-->OI\n    # 0-->show 1-->hide\n    # 2-->contest mode but hide\n    # 3-->contest mode but show\n    status = Column(Integer, default=0)\n    test_case_score = Column(JSON, default={})\n    total_score = Column(Integer, default=0)\n    create_time = Column(DateTime, default=datetime.datetime.now)\n    created_by = Column(Integer, ForeignKey('UserInfo.id'))\n    statistic_info = Column(JSON, default={})\n    _user = relationship('UserInfo', backref='problems')\n\n\n    @property\n    def pid(self):\n        return AESTool.encrypt_data(self.id)\n\n    def user(self, filed=None):\n        if not filed:\n            return self._user\n        else:\n            return getattr(self._user, filed)", "\n\nclass UserProblemStatus(Base, BaseModel):\n    __tablename__ = 'UserProblemStatus'\n\n    id = Column(Integer, primary_key=True, index=True, autoincrement=True)\n    user_id = Column(Integer, ForeignKey('UserInfo.id'), nullable=False)\n    problem_id = Column(Integer, ForeignKey('ProblemInfo.id'), nullable=False)\n    ac_id = Column(Integer, ForeignKey('Submission.id'))  # first ac\n    is_ac = Column(Boolean, default=False)\n    score = Column(Integer, default=0)  # if problem.mode == OI\n\n    _user = relationship('UserInfo', backref='problems_status')\n    _submission = relationship('Submission')\n    _problem = relationship('ProblemInfo', backref='users_status')\n\n    @property\n    def user(self):\n        return self._user\n\n    @property\n    def submission(self):\n        return self._submission\n\n    @property\n    def problem(self):\n        return self._problem", ""]}
{"filename": "OJ/models/__init__.py", "chunked_list": ["from .UserModels import *\nfrom .ContestModel import *\nfrom .ProblemModels import *\nfrom .SubmissionModel import *\nfrom .JudgeModel import JudgeServer\nfrom .SystemModel import SysAnnouncement\n"]}
{"filename": "OJ/models/SystemModel.py", "chunked_list": ["from sqlalchemy import Column, ForeignKey, Integer, String, DateTime, Text, JSON\nimport datetime\n\nfrom OJ.db.database import Base, BaseModel\n\n\nclass SysAnnouncement(Base, BaseModel):\n    __tablename__ = 'SysAnnouncement'\n\n    id = Column(Integer, primary_key=True, index=True, autoincrement=True)\n    title = Column(String(200), nullable=False)\n    content = Column(Text, nullable=False)\n    create_time = Column(DateTime, default=datetime.datetime.now)\n    update_time = Column(DateTime, default=datetime.datetime.now, onupdate=datetime.datetime.now)\n    author = Column(Integer, ForeignKey('UserInfo.id'), nullable=False)\n    is_visible = Column(Integer, default=True)", ""]}
{"filename": "OJ/views/contests.py", "chunked_list": ["from fastapi import APIRouter, Depends, Header, status, Response\n\nfrom sqlalchemy.orm import Session\nfrom starlette.responses import JSONResponse\n\nfrom OJ.db.database import get_session\nfrom OJ.util.constant import CONTEST_TYPE, ContestRuleType\nfrom OJ.models import ContestInfo, Announcement, ContestProblem\nfrom OJ.util.aes import AESTool\n", "from OJ.util.aes import AESTool\n\nfrom fastapi_pagination import Page, paginate, Params\n\nrouter = APIRouter(\n    prefix='/api/contest',\n    tags=['contest']\n)\n\n", "\n\n@router.get('/recent')\nasync def get_recent(db: Session = Depends(get_session)):\n    contests = db.query(ContestInfo).filter_by(contest_type=CONTEST_TYPE.NORMAL).order_by('start_at').limit(5).all()\n    result = []\n    for it in contests:\n        dic = it.to_dict()\n        dic['status'] = it.status\n        del dic['contest_type']\n        del dic['created_by']\n        del dic['password']\n        del dic['only_id']\n        dic['admin'] = it.user('username')\n        dic['rule'] = 'ACM' if dic['rule'] == 0 else 'OI'\n        result.append(dic)", "    return result\n\n\n@router.get('/all')\nasync def get_all(db: Session = Depends(get_session), params: Params = Depends()):\n    contests = db.query(ContestInfo).filter_by(contest_type=CONTEST_TYPE.NORMAL).all()\n\n    result = []\n    for it in contests:\n        dic = it.to_dict([\n            'title', 'description', 'start_at', 'end_at', 'rule', 'status'\n        ])\n        dic['admin'] = it.user('username')\n        dic['rule'] = 'ACM' if dic['rule'] == 0 else 'OI'\n        result.append(dic)", "    for it in contests:\n        dic = it.to_dict([\n            'title', 'description', 'start_at', 'end_at', 'rule', 'status'\n        ])\n        dic['admin'] = it.user('username')\n        dic['rule'] = 'ACM' if dic['rule'] == 0 else 'OI'\n        result.append(dic)\n    return paginate(result, params)\n\n", "\n\n@router.get('/detail')\nasync def get_detail(contest_id, db: Session = Depends(get_session)):\n    def get_problem_info(cp: ContestProblem):\n        pro = cp.problem\n        dic = pro.to_dict(['pid', 'title', 'submission_count', 'ac_count', ])\n        dic['ac_rate'] = 0 if pro.ac_count == 0 else (pro.ac_count / pro.submission_count) * 100\n        dic['cp_id'] = AESTool.encrypt_data(cp.id)\n        return dic", "\n    contest = db.query(ContestInfo).filter_by(id=contest_id).first()\n\n    if not contest:\n        return JSONResponse({\n            'msg': '\u6bd4\u8d5b\u4e0d\u5b58\u5728\uff0c\u5f02\u5e38\u8bbf\u95ee'\n        }, status_code=status.HTTP_404_NOT_FOUND)\n    response = contest.to_dict([\n        'id', 'title', 'description', 'start_at', 'end_at', 'rule', 'status'\n    ])", "        'id', 'title', 'description', 'start_at', 'end_at', 'rule', 'status'\n    ])\n    cps = db.query(ContestProblem).filter_by(cid=contest.id).all()\n    problems = [get_problem_info(it) for it in cps]\n    response['problems'] = problems\n    return response\n\n\n@router.get('/announcements')\nasync def get_announcements(contest_id, db: Session = Depends(get_session)):", "@router.get('/announcements')\nasync def get_announcements(contest_id, db: Session = Depends(get_session)):\n    announcements = db.query(Announcement).filter_by(contest=contest_id).order_by('update_time').all()\n    response = []\n    for it in announcements:\n        dic = it.to_dict([\n            'id', 'title', 'content', 'create_time', 'update_time'\n        ])\n        dic['author'] = it.user('username')\n        response.append(dic)", "    return response\n\n\n@router.get('/rank')\nasync def get_rank(cid, db: Session = Depends(get_session), params: Params = Depends()):\n    contest = db.query(ContestInfo).filter_by(id=cid).first()\n    if not contest:\n        return JSONResponse({\n            'msg': '\u6bd4\u8d5b\u4e0d\u5b58\u5728\uff0c\u5f02\u5e38\u8bbf\u95ee'\n        }, status_code=status.HTTP_404_NOT_FOUND)", "    cps = db.query(ContestProblem).filter_by(cid=cid).all()\n    problems = [cp.problem for cp in cps]\n    pids = {it.id: ix for ix, it in enumerate(problems)}\n    usernames = []\n    u_result = {}\n    u_rank = {}\n    cps = db.query(ContestProblem).filter_by(cid=cid).all()\n    if contest.rule == ContestRuleType.ACM:\n        for cp in cps:\n            for rank in cp.acm_rank:\n                username = rank.user('username')\n                usernames.append(username)\n                u_rank[username] = u_rank.get(username, [])\n                u_rank[username].append(rank)\n                u_result[username] = u_result.get(username, {})\n                u_result[username]['submissions'] = u_result[username].get('submissions',\n                                                                           [{} for _ in range(len(problems))])\n                u_result[username]['problems'] = u_result[username].get('problems', [0 for _ in range(len(problems))])\n                u_result[username]['problems'][pids[cp.pid]] = 1\n                u_result[username]['submission_count'] = u_result[username].get('submission_count', 0) + \\\n                                                         rank.submission_number\n\n                u_result[username]['ac_count'] = u_result[username].get('ac_count', 0) + rank.is_ac\n                u_result[username]['total_time'] = u_result[username].get('total_time', 0)\n                if rank.is_ac:\n                    u_result[username]['total_time'] += rank.total_time\n                    u_result[username]['is_ac'] = True\n                else:\n                    u_result[username]['is_ac'] = False\n                u_result[username]['submissions'][pids[cp.pid]]['total_time'] = rank.total_time\n                u_result[username]['submissions'][pids[cp.pid]]['is_ac'] = rank.is_ac\n                u_result[username]['submissions'][pids[cp.pid]]['is_first_ac'] = rank.is_first_ac\n                u_result[username]['submissions'][pids[cp.pid]]['submission_number'] = rank.submission_number", "    response = []\n    for key, val in u_result.items():\n        dic = {'username': key}\n        dic.update(val)\n        response.append(dic)\n    response.sort(key=lambda x: (-x['ac_count'], x['total_time'], x['username']))\n    return {'ranks': paginate(response, params), 'length': len(cps)}\n"]}
{"filename": "OJ/views/submission.py", "chunked_list": ["from threading import Thread\n\nfrom fastapi import APIRouter, Depends, Header, status, Response\nfrom fastapi_pagination import Params, paginate\n\nfrom sqlalchemy.orm import Session\n\nfrom OJ.util.aes import AESTool\nfrom OJ.db.database import get_session, SessionLocal\n", "from OJ.db.database import get_session, SessionLocal\n\nfrom OJ.util.controller import get_user\nfrom OJ.util.judge import JudgeDispatcher\nfrom OJ.util.constant import JudgeStatus\nfrom OJ.util.schedule import *\n\nfrom OJ.models import Submission, ProblemInfo, ContestProblem\n\nfrom typing import Union", "\nfrom typing import Union\n\nrouter = APIRouter(\n    prefix='/api/submission',\n    tags=['submissions']\n)\n\n\n@router.post(\"/judge\")", "\n@router.post(\"/judge\")\nasync def judge(form: JudgeForm, x_token: Union[str, None] = Header(None), db: Session = Depends(get_session)):\n    pid = AESTool.decrypt_data(form.pid)\n    problem = db.query(ProblemInfo).filter_by(id=pid).first()\n    if not problem:\n        return Response(status_code=status.HTTP_404_NOT_FOUND)\n    language = form.language\n    user = get_user(x_token)\n    user_id = user.id", "    user = get_user(x_token)\n    user_id = user.id\n    code_source = form.source_code\n    if form.cp_id != '':\n        cp = db.query(ContestProblem).filter_by(id=AESTool.decrypt_data(form.cp_id), pid=pid).first()\n        if cp:\n            cid = cp.cid\n        else:\n            cid = None\n    else:\n        cp = None\n        cid = None", "    submission = Submission(language=language,\n                            user_id=user_id,\n                            code_source=code_source,\n                            problem_id=pid,\n                            contest_id=cid)\n    db.add(submission)\n    db.commit()\n    if cp:\n        thread = Thread(target=SubmissionJudge, args=(submission.id, pid, cp.id))\n    else:\n        thread = Thread(target=SubmissionJudge, args=(submission.id, pid))", "    thread.start()\n    # JudgeDispatcher(submission.id, problem.id, db).judge()\n    return submission.id\n\n\ndef SubmissionJudge(sid, pid, cp_id=-1):\n    sess = SessionLocal()\n    dis = JudgeDispatcher(sid, pid, sess, cp_id)\n    dis.judge()\n", "\n\n@router.get(\"/status\")\nasync def submission_status(submission_id: int,\n                            db: Session = Depends(get_session)):\n    submission = db.query(Submission).filter_by(id=submission_id).first()\n    if not submission:\n        return Response(status_code=status.HTTP_404_NOT_FOUND)\n    if submission.result in (JudgeStatus.PENDING, JudgeStatus.JUDGING):\n        return {\n            'result': submission.result\n        }\n    else:\n        return submission.to_dict()", "    if submission.result in (JudgeStatus.PENDING, JudgeStatus.JUDGING):\n        return {\n            'result': submission.result\n        }\n    else:\n        return submission.to_dict()\n\n\n@router.get(\"/problem\")\nasync def submission_problem(pid: str, db: Session = Depends(get_session), params: Params = Depends()):", "@router.get(\"/problem\")\nasync def submission_problem(pid: str, db: Session = Depends(get_session), params: Params = Depends()):\n    pid = AESTool.decrypt_data(pid)\n    submissions = db.query(Submission).filter_by(problem_id=pid).all()\n    response = []\n    for sub in submissions:\n        response.append(sub.to_dict(['id', 'create_time', 'result', 'language']))\n    return paginate(response, params)\n", ""]}
{"filename": "OJ/views/__init__.py", "chunked_list": ["from .problems import router as problems_router\nfrom .user import router as user_router\nfrom .submission import router as sub_router\nfrom .contests import router as con_router\nfrom .admin import *\n\nroutes = [\n    problems_router,\n    user_router,\n    sub_router,", "    user_router,\n    sub_router,\n    con_router,\n    admin_problem_router,\n    admin_sys_router,\n    admin_contest_router\n]\n"]}
{"filename": "OJ/views/user.py", "chunked_list": ["from fastapi import APIRouter, Depends\nfrom fastapi.responses import JSONResponse\n\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy import or_\n\nfrom OJ.models.UserModels import UserInfo, UserSession\nfrom OJ.util.schedule import *\nfrom OJ.db.database import get_session\nfrom OJ.util import get_random_string", "from OJ.db.database import get_session\nfrom OJ.util import get_random_string\n\nrouter = APIRouter(\n    prefix='/api/user',\n    tags=['user']\n)\n\n\n@router.post(\"/login\")", "\n@router.post(\"/login\")\nasync def login(form: LoginForm, db: Session = Depends(get_session)):\n    user = db.query(UserInfo).filter_by(username=form.username).first()\n    if not user or not user.check_password(form.password):\n        return JSONResponse({\n            'status': 404,\n            'msg': 'Invalid Username or Password!'\n        }, status_code=404)\n    token = get_random_string()", "    token = get_random_string()\n    sess = db.query(UserSession).filter_by(user_id=user.id)\n    if sess.first():\n        sess.update({'token': token})\n        db.commit()\n    else:\n        sess = UserSession(user_id=user.id, token=token)\n        db.add(sess)\n        db.commit()\n    return JSONResponse({", "    return JSONResponse({\n        'msg': 'Login Successfully!',\n        'token': token,\n    })\n\n\n@router.post(\"/register\")\nasync def register(form: RegisterForm, db: Session = Depends(get_session)):\n    if form.password != form.confirmPassword:\n        return JSONResponse({\n            'status': 404,\n            'msg': '\u4e24\u6b21\u5bc6\u7801\u4e0d\u4e00\u81f4'\n        }, status_code=404)", "    if form.password != form.confirmPassword:\n        return JSONResponse({\n            'status': 404,\n            'msg': '\u4e24\u6b21\u5bc6\u7801\u4e0d\u4e00\u81f4'\n        }, status_code=404)\n    user = UserInfo(username=form.username, email=form.email)\n    user.make_password(form.password)\n    u = db.query(UserInfo).filter(or_(UserInfo.username == form.username, UserInfo.email == form.email)).first()\n    if u:\n        return JSONResponse({\n            'status': 404,\n            'msg': '\u7528\u6237\u5df2\u5b58\u5728'\n        }, status_code=404)", "    if u:\n        return JSONResponse({\n            'status': 404,\n            'msg': '\u7528\u6237\u5df2\u5b58\u5728'\n        }, status_code=404)\n    try:\n        db.add(user)\n        db.commit()\n    except Exception as e:\n        return JSONResponse({\n            'msg': e\n        }, 404)", "    return JSONResponse({\n        'msg': '\u6ce8\u518c\u6210\u529f'\n    })\n"]}
{"filename": "OJ/views/problems.py", "chunked_list": ["from typing import Union\n\nfrom fastapi import UploadFile, File, APIRouter, Depends, Header\nfrom fastapi.responses import JSONResponse\n\nimport os\nfrom sqlalchemy import desc\n\nfrom sqlalchemy.orm import Session\n", "from sqlalchemy.orm import Session\n\nfrom OJ.app.settings import PROJECT_PATH\n\nfrom OJ.db.database import get_session\nfrom OJ.util.aes import AESTool\nfrom OJ.util.common import rand_str\nfrom OJ.util.controller import get_user\nfrom OJ.util.zip_processor import TestCaseZipProcessor\nfrom OJ.util.schedule import *", "from OJ.util.zip_processor import TestCaseZipProcessor\nfrom OJ.util.schedule import *\n\nfrom OJ.models import ProblemInfo, UserProblemStatus, ContestProblem\n\nfrom fastapi_pagination import Params, paginate\n\nrouter = APIRouter(\n    prefix='/api/problem',\n    tags=['problems']", "    prefix='/api/problem',\n    tags=['problems']\n)\n\n\n@router.get(\"/hot\")\nasync def problem_hot(db: Session = Depends(get_session)):\n    problems = db.query(ProblemInfo).filter_by(status=0).order_by(desc(ProblemInfo.submission_count)).limit(5).all()\n    result = []\n    for pro in problems:\n        result.append({\n            'id': pro.id,\n            'title': pro.title,\n            'submission': pro.submission_count,\n            'ac_count': pro.ac_count,\n            'ac_rate': 0 if pro.ac_count == 0 else (pro.ac_count / pro.submission_count) * 100\n        })", "    result = []\n    for pro in problems:\n        result.append({\n            'id': pro.id,\n            'title': pro.title,\n            'submission': pro.submission_count,\n            'ac_count': pro.ac_count,\n            'ac_rate': 0 if pro.ac_count == 0 else (pro.ac_count / pro.submission_count) * 100\n        })\n    return result", "    return result\n\n\n@router.get(\"/all\")\nasync def problem_all(db: Session = Depends(get_session), params: Params = Depends()):\n    problems = db.query(ProblemInfo).filter_by(status=0).all()\n    result = []\n    for pro in problems:\n        result.append({\n            'id': AESTool.encrypt_data(pro.id),\n            'title': pro.title,\n            'submission': pro.submission_count,\n            'ac_count': pro.ac_count,\n            'ac_rate': 0 if pro.ac_count == 0 else (pro.ac_count / pro.submission_count) * 100\n        })", "    return paginate(result, params)\n\n\n@router.get(\"/detail\")\nasync def problem_detail(\n        pid, cid: int = -1,\n        x_token: Union[str, None] = Header(None),\n        db: Session = Depends(get_session)\n):\n    problem_id = AESTool.decrypt_data(pid)\n    if cid > 0:\n        cp = db.query(ContestProblem).filter_by(pid=problem_id, cid=cid).first()\n        if not cp or not cp.is_visible:\n            return JSONResponse({\n                'msg': '\u95ee\u9898\u4e0d\u5b58\u5728\uff0c\u5f02\u5e38\u8bbf\u95ee'\n            }, status_code=404)\n        problem = cp.problem\n    else:\n        cp = None\n        problem = db.query(ProblemInfo).filter_by(id=problem_id).first()\n        if not problem or problem.status > 0:\n            return JSONResponse({\n                'msg': '\u95ee\u9898\u4e0d\u5b58\u5728\uff0c\u5f02\u5e38\u8bbf\u95ee'\n            }, status_code=404)", "):\n    problem_id = AESTool.decrypt_data(pid)\n    if cid > 0:\n        cp = db.query(ContestProblem).filter_by(pid=problem_id, cid=cid).first()\n        if not cp or not cp.is_visible:\n            return JSONResponse({\n                'msg': '\u95ee\u9898\u4e0d\u5b58\u5728\uff0c\u5f02\u5e38\u8bbf\u95ee'\n            }, status_code=404)\n        problem = cp.problem\n    else:\n        cp = None\n        problem = db.query(ProblemInfo).filter_by(id=problem_id).first()\n        if not problem or problem.status > 0:\n            return JSONResponse({\n                'msg': '\u95ee\u9898\u4e0d\u5b58\u5728\uff0c\u5f02\u5e38\u8bbf\u95ee'\n            }, status_code=404)", "    user = get_user(x_token)\n    response = problem.to_dict()\n    if response['samples']:\n        response['samples'] = [(it.split('|||')[0], it.split('|||')[1]) for it in response['samples'].split('+#+#')]\n    else:\n        response['samples'] = []\n    response['language'] = response['language'].split('###')\n    response['created_by'] = problem.user('username')\n    status = db.query(UserProblemStatus).filter_by(user_id=user.id, problem_id=problem_id).first()\n    if status:\n        status = status.to_dict(['is_ac', 'score', 'submission'])\n        if status['submission']:\n            status['submission'] = status['submission'].to_dict(['result'])", "    status = db.query(UserProblemStatus).filter_by(user_id=user.id, problem_id=problem_id).first()\n    if status:\n        status = status.to_dict(['is_ac', 'score', 'submission'])\n        if status['submission']:\n            status['submission'] = status['submission'].to_dict(['result'])\n    if cp:\n        response['cp_id'] = AESTool.encrypt_data(cp.id)\n    response['status'] = status\n    return response\n", "    return response\n\n\n@router.post(\"/create\")\nasync def problem_create(form: ProblemForm, db: Session = Depends(get_session)):\n    problem = ProblemInfo(\n        title=form.title,\n        description=form.description,\n        inputs=form.inputs,\n        outputs=form.outputs,", "        inputs=form.inputs,\n        outputs=form.outputs,\n        samples=form.samples,\n        hints=form.hints,\n        source=form.source,\n        is_spj=form.is_spj,\n        test_id=form.test_id,\n        time_limit=form.time_limit,\n        memory_limit=form.memory_limit,\n        io_mode=form.io_mode,", "        memory_limit=form.memory_limit,\n        io_mode=form.io_mode,\n    )\n    db.add(problem)\n    db.commit()\n    return problem.to_dict()\n\n\n@router.post(\"/upload/testcases\")\nasync def problem_upload_testcases(file: UploadFile = File(...), spj=False):", "@router.post(\"/upload/testcases\")\nasync def problem_upload_testcases(file: UploadFile = File(...), spj=False):\n    tmp_file = f\"tmp/{rand_str()}.zip\"\n    with open(tmp_file, \"wb\") as f:\n        content = await file.read()\n        f.write(content)\n    zip_process = TestCaseZipProcessor()\n    spj = spj == 'true'\n    info, test_case_id = zip_process.process_zip(tmp_file, spj=spj)\n    os.remove(tmp_file)", "    info, test_case_id = zip_process.process_zip(tmp_file, spj=spj)\n    os.remove(tmp_file)\n    return {\"id\": test_case_id, \"info\": info, \"spj\": spj}\n\n\n@router.get(\"/testcase\")\nasync def problem_get_testcase(testcase_id):\n    path = os.path.join(PROJECT_PATH, 'testcases', testcase_id)\n    files = os.listdir(path)\n    inputs = [it for it in files if it.endswith('.in')]", "    files = os.listdir(path)\n    inputs = [it for it in files if it.endswith('.in')]\n    outputs = [it for it in files if it.endswith('.out')]\n    count = len(files)\n    return {\n        'count': count,\n        'inputs': inputs,\n        'outputs': outputs\n    }\n", "    }\n"]}
{"filename": "OJ/views/admin/contest.py", "chunked_list": ["from typing import Union\n\nfrom fastapi import APIRouter, Depends, Header, status\nfrom fastapi.responses import JSONResponse, Response\n\nfrom sqlalchemy.orm import Session\n\nfrom OJ.db.database import get_session\n\nfrom OJ.util.aes import AESTool", "\nfrom OJ.util.aes import AESTool\nfrom OJ.util.common import hash256\nfrom OJ.util.controller import get_user\nfrom OJ.util.schedule import *\n\nfrom OJ.models import ContestInfo, ContestProblem\n\nfrom fastapi_pagination import Page, Params, paginate\n", "from fastapi_pagination import Page, Params, paginate\n\nrouter = APIRouter(\n    prefix='/api/admin/contest',\n    tags=['admin contest']\n)\n\n\n@router.get(\"/all\")\nasync def contest_all(db: Session = Depends(get_session), params: Params = Depends()):", "@router.get(\"/all\")\nasync def contest_all(db: Session = Depends(get_session), params: Params = Depends()):\n    contests = db.query(ContestInfo).all()\n    result = []\n    for con in contests:\n        result.append({\n            'id': con.id,\n            'title': con.title,\n            'author': con.user('username'),\n            'start_at': con.start_at,\n            'end_at': con.end_at,\n            'status': con.status\n        })", "    return paginate(result, params)\n\n\n@router.get('/detail')\nasync def get_detail(cid, db: Session = Depends(get_session)):\n    cid = AESTool.decrypt_data(cid)\n    contest = db.query(ContestInfo).filter_by(id=cid).first()\n\n    if not contest:\n        return JSONResponse({\n            'msg': '\u6bd4\u8d5b\u4e0d\u5b58\u5728\uff0c\u5f02\u5e38\u8bbf\u95ee'\n        }, status_code=status.HTTP_404_NOT_FOUND)", "    if not contest:\n        return JSONResponse({\n            'msg': '\u6bd4\u8d5b\u4e0d\u5b58\u5728\uff0c\u5f02\u5e38\u8bbf\u95ee'\n        }, status_code=status.HTTP_404_NOT_FOUND)\n    response = contest.to_dict([\n        'id', 'title', 'description', 'start_at', 'end_at', 'rule', 'status', 'contest_type', 'only_id'\n    ])\n    return response\n\n", "\n\n@router.post(\"/add\")\nasync def contest_add(form: ContestForm, x_token: Union[str, None] = Header(None), db: Session = Depends(get_session)):\n    user = get_user(x_token)\n    contest = ContestInfo()\n    contest.title = form.title\n    contest.description = form.description\n    datetime_format = \"%Y-%m-%dT%H:%M:%S.%fZ\"\n    contest.start_at = datetime.datetime.strptime(form.start_at, datetime_format)", "    datetime_format = \"%Y-%m-%dT%H:%M:%S.%fZ\"\n    contest.start_at = datetime.datetime.strptime(form.start_at, datetime_format)\n    contest.end_at = datetime.datetime.strptime(form.end_at, datetime_format)\n    contest.contest_type = form.contest_type\n    contest.password = hash256(form.password)\n    contest.rule = form.rule\n    contest.created_by = user.id\n    db.add(contest)\n    db.commit()\n    contest.only_id = AESTool.encrypt_data(str(contest.id))", "    db.commit()\n    contest.only_id = AESTool.encrypt_data(str(contest.id))\n    db.commit()\n\n\n@router.post(\"/update\")\nasync def contest_update(form: ContestForm, x_token: Union[str, None] = Header(None),\n                         db: Session = Depends(get_session)):\n    user = get_user(x_token)\n    contest = db.query(ContestInfo).filter_by(id=form.id).first()\n    if not contest:\n        return Response('Invalid Contest ID', status_code=status.HTTP_404_NOT_FOUND)", "    user = get_user(x_token)\n    contest = db.query(ContestInfo).filter_by(id=form.id).first()\n    if not contest:\n        return Response('Invalid Contest ID', status_code=status.HTTP_404_NOT_FOUND)\n    db.commit()\n    contest.only_id = AESTool.encrypt_data(str(contest.id))\n    db.commit()\n\n\n@router.get(\"/problem\")", "\n@router.get(\"/problem\")\nasync def contest_problem_all(cid, db: Session = Depends(get_session), params: Params = Depends()):\n    cid = AESTool.decrypt_data(cid)\n    cps = db.query(ContestProblem).filter_by(cid=cid).all()\n    problems = []\n    for cp in cps:\n        pro = cp.problem\n        problems.append({\n            'id': AESTool.encrypt_data(str(pro.id)),\n            'title': pro.title,\n            'author': pro.user('username'),\n            'create_time': pro.create_time,\n            'status': pro.status == 0\n        })", "    return problems\n"]}
{"filename": "OJ/views/admin/__init__.py", "chunked_list": ["from .problem import router as admin_problem_router\nfrom .sys import router as admin_sys_router\nfrom .contest import router as admin_contest_router\n"]}
{"filename": "OJ/views/admin/sys.py", "chunked_list": ["import os\nimport hashlib\nimport json\nimport zipfile\n\nfrom fastapi import UploadFile, File, APIRouter, Depends, status\nfrom fastapi.responses import Response\n\nfrom sqlalchemy.orm import Session\n", "from sqlalchemy.orm import Session\n\nfrom OJ.db.database import get_session\nfrom OJ.util.common import rand_str\nfrom OJ.models.ProblemModels import ProblemInfo\n\nrouter = APIRouter(\n    prefix='/api/admin/sys',\n    tags=['system control']\n)", "    tags=['system control']\n)\n\n\n@router.post('/qdu/import')\nasync def qdu_export(file: UploadFile = File(...), db: Session = Depends(get_session)):\n    tmp_file = f\"tmp/{rand_str()}.zip\"\n    with open(tmp_file, \"wb\") as f:\n        content = await file.read()\n        f.write(content)\n    try:\n        zip_file = zipfile.ZipFile(tmp_file, \"r\")\n    except zipfile.BadZipFile as e:\n        print(e)\n        return Response(\"Bad zip file\", status.HTTP_500_INTERNAL_SERVER_ERROR)", "    try:\n        zip_file = zipfile.ZipFile(tmp_file, \"r\")\n    except zipfile.BadZipFile as e:\n        print(e)\n        return Response(\"Bad zip file\", status.HTTP_500_INTERNAL_SERVER_ERROR)\n    files = zip_file.namelist()\n    dic = {}\n    for f in files:\n        if len(f.strip('/').split('/')) == 1:\n            continue\n        tid = f.split('/')[0]\n        dic[tid] = dic.get(tid, {})\n        if '.json' in f:\n            dic[tid]['problem'] = f\n        if len(f.strip('/').split('/')) == 2:\n            continue\n        else:\n            dic[tid]['testcase'] = dic[tid].get('testcase', [])\n            dic[tid]['testcase'].append(f)", "    null = None\n    problems = []\n    for tid, val in dic.items():\n        problem_info = eval(zip_file.read(val['problem']).decode())\n        title = problem_info['title']\n        description = problem_info['description']['value']\n        time_limit = problem_info['time_limit']\n        memory_limit = problem_info['memory_limit']\n        samples = problem_info['samples']\n        is_spj = problem_info['spj'] is not None\n        mode = 0 if problem_info['rule_type'] == 'ACM' else 1\n        try:\n            test_case_score = {str(ix): it['score'] for ix, it in enumerate(problem_info['test_case_score'])}\n            total_score = sum([it['score'] for it in problem_info['test_case_score']])\n        except:\n            test_case_score = {}\n            total_score = 0\n        source = problem_info['source']\n        inputs = problem_info['input_description']['value']\n        outputs = problem_info['output_description']['value']\n        hint = problem_info['hint']['value']\n        samples = '+#+#'.join([it['input'] + '|||' + it['output'] for it in samples])\n        problem = ProblemInfo(\n            title=title,\n            language='cxx###c###py3###php',\n            description=description,\n            inputs=inputs,\n            outputs=outputs,\n            time_limit=time_limit,\n            memory_limit=memory_limit,\n            samples=samples,\n            is_spj=is_spj,\n            mode=mode,\n            test_case_score=test_case_score,\n            total_score=total_score,\n            source=source,\n            hints=hint,\n            created_by=1,\n        )\n        test_case_id = rand_str()\n        test_case_dir = os.path.join('testcases', test_case_id)\n        os.mkdir(test_case_dir)\n        os.chmod(test_case_dir, 0o710)\n        size_cache = {}\n        md5_cache = {}\n        test_case_list = val['testcase']\n        for item in test_case_list:\n            file_name = item.split('/')[-1]\n            print(test_case_dir, item)\n            with open(os.path.join(test_case_dir, file_name), \"wb\") as f:\n                content = zip_file.read(f\"{item}\").replace(b\"\\r\\n\", b\"\\n\")\n                size_cache[file_name] = len(content)\n                if file_name.endswith(\".out\"):\n                    md5_cache[file_name] = hashlib.md5(content.rstrip()).hexdigest()\n                f.write(content)\n        test_case_info = {\"spj\": is_spj, \"test_cases\": {}}\n\n        info = []\n        test_case_list = [it.split('/')[-1] for it in test_case_list]\n        if is_spj:\n            for index, item in enumerate(test_case_list):\n                data = {\"input_name\": item, \"input_size\": size_cache[item]}\n                info.append(data)\n                test_case_info[\"test_cases\"][str(index + 1)] = data\n        else:\n            # [\"1.in\", \"1.out\", \"2.in\", \"2.out\"] => [(\"1.in\", \"1.out\"), (\"2.in\", \"2.out\")]\n            test_case_list = zip(*[test_case_list[i::2] for i in range(2)])\n            for index, item in enumerate(test_case_list):\n                data = {\"stripped_output_md5\": md5_cache[item[1]],\n                        \"input_size\": size_cache[item[0]],\n                        \"output_size\": size_cache[item[1]],\n                        \"input_name\": item[0],\n                        \"output_name\": item[1]}\n                info.append(data)\n                test_case_info[\"test_cases\"][str(index + 1)] = data\n\n        with open(os.path.join(test_case_dir, \"info\"), \"w\", encoding=\"utf-8\") as f:\n            f.write(json.dumps(test_case_info, indent=4))\n\n        for item in os.listdir(test_case_dir):\n            os.chmod(os.path.join(test_case_dir, item), 0o640)\n        problem.test_id = test_case_id\n        db.add(problem)", "    db.commit()\n    return True\n"]}
{"filename": "OJ/views/admin/problem.py", "chunked_list": ["import os\nfrom typing import Union\n\nfrom fastapi import UploadFile, File, APIRouter, Depends, Header, status\nfrom fastapi.responses import Response\n\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy import or_, and_\n\nfrom OJ.db.database import get_session", "\nfrom OJ.db.database import get_session\nfrom OJ.util.aes import AESTool\nfrom OJ.util.common import rand_str, hash256\nfrom OJ.util.controller import get_user\nfrom OJ.util.zip_processor import TestCaseZipProcessor\nfrom OJ.util.schedule import *\n\nfrom OJ.models import ProblemInfo, ContestProblem\n", "from OJ.models import ProblemInfo, ContestProblem\n\nfrom fastapi_pagination import Params, paginate\n\nrouter = APIRouter(\n    prefix='/api/admin/problem',\n    tags=['admin problems']\n)\n\n", "\n\n@router.delete('')\nasync def delete_problem(pid: str, db: Session = Depends(get_session)):\n    pid = AESTool.decrypt_data(pid)\n    pid = AESTool.decrypt_data(pid)\n    pro = db.query(ProblemInfo).filter_by(id=pid).first()\n    if not pro:\n        return Response('Problem not found', status_code=status.HTTP_404_NOT_FOUND)\n    db.delete(pro)", "    db.delete(pro)\n    db.commit()\n    return True\n\n\n@router.get(\"/all\")\nasync def problem_all(db: Session = Depends(get_session), params: Params = Depends()):\n    problems = db.query(ProblemInfo).filter(or_(ProblemInfo.status == 0, ProblemInfo.status == 1)).all()\n    result = []\n    for pro in problems:\n        result.append({\n            'id': pro.id,\n            'title': pro.title,\n            'author': pro.user('username'),\n            'create_time': pro.create_time,\n            'status': pro.status == 0\n        })", "    result = []\n    for pro in problems:\n        result.append({\n            'id': pro.id,\n            'title': pro.title,\n            'author': pro.user('username'),\n            'create_time': pro.create_time,\n            'status': pro.status == 0\n        })\n    return paginate(result, params)", "    return paginate(result, params)\n\n\n@router.post(\"/upload/testcases\")\nasync def problem_upload_testcases(file: UploadFile = File(...), spj=False):\n    tmp_file = f\"tmp/{rand_str()}.zip\"\n    with open(tmp_file, \"wb\") as f:\n        content = await file.read()\n        f.write(content)\n    zip_process = TestCaseZipProcessor()", "    zip_process = TestCaseZipProcessor()\n    spj = spj == 'true'\n    info, test_case_id = zip_process.process_zip(tmp_file, spj=spj)\n    os.remove(tmp_file)\n    return {\"id\": test_case_id, \"info\": info, \"spj\": spj}\n\n\n@router.post(\"/update\")\nasync def problem_update(problem: ProblemForm, db: Session = Depends(get_session)):\n    pro = db.query(ProblemInfo).filter_by(id=problem.id).first()\n    if not pro:\n        return Response('Problem not found', status_code=status.HTTP_404_NOT_FOUND)", "async def problem_update(problem: ProblemForm, db: Session = Depends(get_session)):\n    pro = db.query(ProblemInfo).filter_by(id=problem.id).first()\n    if not pro:\n        return Response('Problem not found', status_code=status.HTTP_404_NOT_FOUND)\n    pro.title = problem.title\n    pro.description = problem.description\n    pro.inputs = problem.inputs\n    pro.outputs = problem.outputs\n    pro.samples = '+#+#'.join(['|||'.join(it) for it in problem.samples])\n    pro.language = '###'.join([it for it in problem.language if it in ['c', 'cxx', 'py3', 'py2', 'php', 'go', 'js']])", "    pro.samples = '+#+#'.join(['|||'.join(it) for it in problem.samples])\n    pro.language = '###'.join([it for it in problem.language if it in ['c', 'cxx', 'py3', 'py2', 'php', 'go', 'js']])\n    pro.mode = problem.mode\n    pro.is_spj = problem.is_spj\n    pro.source = problem.source\n    pro.time_limit = problem.time_limit\n    pro.memory_limit = problem.memory_limit\n    pro.hints = problem.hints\n    pro.test_id = problem.test_id\n    db.commit()", "    pro.test_id = problem.test_id\n    db.commit()\n    return True\n\n\n@router.post(\"/add\")\nasync def problem_add(problem: ProblemForm, x_token: Union[str, None] = Header(None),\n                      db: Session = Depends(get_session)):\n    if problem.cid != '':\n        sta = 3\n        try:\n            cid = AESTool.decrypt_data(problem.cid)\n        except:\n            return Response('Invalid Request', status_code=status.HTTP_400_BAD_REQUEST)\n    else:\n        sta = 1\n        cid = None", "    if problem.cid != '':\n        sta = 3\n        try:\n            cid = AESTool.decrypt_data(problem.cid)\n        except:\n            return Response('Invalid Request', status_code=status.HTTP_400_BAD_REQUEST)\n    else:\n        sta = 1\n        cid = None\n    pro = ProblemInfo()", "    pro = ProblemInfo()\n    pro.title = problem.title\n    pro.description = problem.description\n    pro.inputs = problem.inputs\n    pro.outputs = problem.outputs\n    pro.samples = '+#+#'.join(['|||'.join(it) for it in problem.samples])\n    pro.language = '###'.join([it for it in problem.language if it in ['c', 'cxx', 'py3', 'py2', 'php', 'go', 'js']])\n    pro.mode = problem.mode\n    pro.is_spj = problem.is_spj\n    pro.source = problem.source", "    pro.is_spj = problem.is_spj\n    pro.source = problem.source\n    pro.time_limit = problem.time_limit\n    pro.memory_limit = problem.memory_limit\n    pro.hints = problem.hints\n    pro.test_id = problem.test_id\n    pro.created_by = get_user(x_token).id\n    pro.status = sta\n\n    db.add(pro)", "\n    db.add(pro)\n    db.commit()\n    if cid:\n        cp = ContestProblem(cid=cid, pid=pro.id)\n        db.add(cp)\n        db.commit()\n\n    return True\n", "    return True\n\n\n@router.get(\"/visible\")\nasync def problem_visible(pid: str, s=None, db: Session = Depends(get_session)):\n    pid = AESTool.decrypt_data(pid)\n    pro = db.query(ProblemInfo).filter_by(id=pid).first()\n    if not pro:\n        return Response('Problem not found', status_code=status.HTTP_404_NOT_FOUND)\n    if s:\n        pro.status = None\n    else:\n        if pro.status == 0:\n            pro.status = 1\n        elif pro.status == 1:\n            pro.status = 0", "    if s:\n        pro.status = None\n    else:\n        if pro.status == 0:\n            pro.status = 1\n        elif pro.status == 1:\n            pro.status = 0\n    db.commit()\n    return True\n", "    return True\n"]}
{"filename": "OJ/middleware/users.py", "chunked_list": ["import typing\n\nfrom fastapi import Request, status\nfrom fastapi.responses import JSONResponse, Response\n\nfrom sqlalchemy.orm import Session\n\nfrom starlette.middleware.base import BaseHTTPMiddleware, RequestResponseEndpoint, DispatchFunction\nfrom starlette.types import ASGIApp\n", "from starlette.types import ASGIApp\n\nfrom OJ.db.database import engine\nfrom OJ.models.UserModels import UserSession\n\nfrom OJ.app.settings import CHECKLOGIN_EXCLUDE_PATH\n\n\nclass CheckLogin(BaseHTTPMiddleware):\n\n    def __init__(self, app: ASGIApp, dispatch: typing.Optional[DispatchFunction] = None) -> None:\n        super().__init__(app, dispatch)\n        self.app = app\n\n    async def dispatch(self, request: Request, call_next: RequestResponseEndpoint) -> Response:\n        if request.method == 'OPTIONS':\n            response = await call_next(request)\n            return response\n        path: str = request.get('path')\n        for it in CHECKLOGIN_EXCLUDE_PATH:\n            if path.startswith(it):\n                response = await call_next(request)\n                return response\n        else:\n            with Session(engine) as session:\n                session.begin()\n                token = request.headers.get('x-token', '')\n                sess = session.query(UserSession).filter(UserSession.token == token).first()\n                if not sess:\n                    return JSONResponse({}, status_code=status.HTTP_401_UNAUTHORIZED)\n                if path.startswith('/api/admin') and not sess.user.is_admin:\n                    return Response('NOT ACCEPTABLE REQUEST', status_code=status.HTTP_406_NOT_ACCEPTABLE)\n                response = await call_next(request)\n                session.close()\n            return response", "class CheckLogin(BaseHTTPMiddleware):\n\n    def __init__(self, app: ASGIApp, dispatch: typing.Optional[DispatchFunction] = None) -> None:\n        super().__init__(app, dispatch)\n        self.app = app\n\n    async def dispatch(self, request: Request, call_next: RequestResponseEndpoint) -> Response:\n        if request.method == 'OPTIONS':\n            response = await call_next(request)\n            return response\n        path: str = request.get('path')\n        for it in CHECKLOGIN_EXCLUDE_PATH:\n            if path.startswith(it):\n                response = await call_next(request)\n                return response\n        else:\n            with Session(engine) as session:\n                session.begin()\n                token = request.headers.get('x-token', '')\n                sess = session.query(UserSession).filter(UserSession.token == token).first()\n                if not sess:\n                    return JSONResponse({}, status_code=status.HTTP_401_UNAUTHORIZED)\n                if path.startswith('/api/admin') and not sess.user.is_admin:\n                    return Response('NOT ACCEPTABLE REQUEST', status_code=status.HTTP_406_NOT_ACCEPTABLE)\n                response = await call_next(request)\n                session.close()\n            return response", ""]}
{"filename": "OJ/middleware/__init__.py", "chunked_list": [""]}
{"filename": "OJ/app/settings.py", "chunked_list": ["import os\n\nenviron = os.environ\n# PROJECT_PATH = os.path.dirname(__file__)\nPROJECT_PATH = os.getcwd()\nTEMPLATE_FOLDER = os.path.join(PROJECT_PATH, \"templates\")\nSTATIC_FOLDER = os.path.join(PROJECT_PATH, \"static\")\nDEBUG = True  # open debug /or hot restart\n\n# ****** \u4e0a\u4f20\u914d\u7f6e", "\n# ****** \u4e0a\u4f20\u914d\u7f6e\nUPLOAD_FOLDER = '/tmp/uploads'\nALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif', 'sql'}\n\n# SQLALCHEMY_DATABASE_URI = 'sqlite:///test.db'\n\n# ****** MySQL \u914d\u7f6e\nSQLALCHEMY_DATABASE_URI = 'mysql+pymysql://{user}:{password}@{host}:{port}/{database}?charset=utf8'.format(\n    user=environ.get('DB_USER', 'DB_USER'),", "SQLALCHEMY_DATABASE_URI = 'mysql+pymysql://{user}:{password}@{host}:{port}/{database}?charset=utf8'.format(\n    user=environ.get('DB_USER', 'DB_USER'),\n    password=environ.get('DB_PASS', 'DB_PASS'),\n    host=environ.get('DB_HOST', '127.0.0.1'),\n    port=environ.get('DB_PORT', 3306),\n    database=environ.get('DB_NAME', 'DB_NAME'))\n# # SQLALCHEMY_POOL_SIZE = 15  # \u6570\u636e\u5e93\u8fde\u63a5\u6c60\u7684\u5927\u5c0f\u3002\u9ed8\u8ba4\u662f\u6570\u636e\u5e93\u5f15\u64ce\u7684\u9ed8\u8ba4\u503c \uff08\u901a\u5e38\u662f 5\uff09\u3002\n# # SQLALCHEMY_POOL_TIMEOUT = 10  # \u6307\u5b9a\u6570\u636e\u5e93\u8fde\u63a5\u6c60\u7684\u8d85\u65f6\u65f6\u95f4\u3002\u9ed8\u8ba4\u662f 10\u3002\n# # SQLALCHEMY_POOL_RECYCLE = 60 * 60 * 2  # \u81ea\u52a8\u56de\u6536\u8fde\u63a5\u7684\u79d2\u6570\u3002\n# # SQLALCHEMY_MAX_OVERFLOW = 0  # \u63a7\u5236\u5728\u8fde\u63a5\u6c60\u8fbe\u5230\u6700\u5927\u503c\u540e\u53ef\u4ee5\u521b\u5efa\u7684\u8fde\u63a5\u6570\u3002", "# # SQLALCHEMY_POOL_RECYCLE = 60 * 60 * 2  # \u81ea\u52a8\u56de\u6536\u8fde\u63a5\u7684\u79d2\u6570\u3002\n# # SQLALCHEMY_MAX_OVERFLOW = 0  # \u63a7\u5236\u5728\u8fde\u63a5\u6c60\u8fbe\u5230\u6700\u5927\u503c\u540e\u53ef\u4ee5\u521b\u5efa\u7684\u8fde\u63a5\u6570\u3002\n# SQLALCHEMY_POOL_SIZE = 30  # \u6570\u636e\u5e93\u8fde\u63a5\u6c60\u7684\u5927\u5c0f\u3002\u9ed8\u8ba4\u662f\u6570\u636e\u5e93\u5f15\u64ce\u7684\u9ed8\u8ba4\u503c \uff08\u901a\u5e38\u662f 5\uff09\u3002\n# SQLALCHEMY_POOL_TIMEOUT = 10  # \u6307\u5b9a\u6570\u636e\u5e93\u8fde\u63a5\u6c60\u7684\u8d85\u65f6\u65f6\u95f4\u3002\u9ed8\u8ba4\u662f 10\u3002\n# SQLALCHEMY_POOL_RECYCLE = 60 * 60 * 2  # \u81ea\u52a8\u56de\u6536\u8fde\u63a5\u7684\u79d2\u6570\u3002\n# SQLALCHEMY_MAX_OVERFLOW = 20  # \u63a7\u5236\u5728\u8fde\u63a5\u6c60\u8fbe\u5230\u6700\u5927\u503c\u540e\u53ef\u4ee5\u521b\u5efa\u7684\u8fde\u63a5\u6570\u3002\n\n\nREDIS_HOST = os.environ.get('REDIS_HOST', '127.0.0.1')\nREDIS_PORT = os.environ.get('REDIS_PORT', 6379)", "REDIS_HOST = os.environ.get('REDIS_HOST', '127.0.0.1')\nREDIS_PORT = os.environ.get('REDIS_PORT', 6379)\nREDIS_PASSWORD = os.environ.get('REDIS_PASSWORD', 'REDIS_PASSWORD')\nREDIS_DB = os.environ.get('REDIS_DB', '0')\nif REDIS_PASSWORD:\n    RESULT_BACKEND = f'redis://:{REDIS_PASSWORD}@{REDIS_HOST}:{REDIS_PORT}/{REDIS_DB}'\n    BROKER_URL = f'redis://:{REDIS_PASSWORD}@{REDIS_HOST}:{REDIS_PORT}/{REDIS_DB}'\nelse:\n    RESULT_BACKEND = f'redis://{REDIS_HOST}:{REDIS_PORT}/{REDIS_DB}'\n    BROKER_URL = f'redis://{REDIS_PORT}/{REDIS_DB}'", "\nHOST = environ.get('HOST', '0.0.0.0')\nPORT = environ.get('PORT', 16808)\n\nJUDGER_SERVER = 'http://{judger_host}:{judger_port}/'.format(\n    judger_host=environ.get('JUDGER_HOST', '127.0.0.1'),\n    judger_port=environ.get('JUDGER_PORT', '16358'),\n)\nJUDGER_TOKEN = environ.get('JUDGER_TOKEN', '123456')\n", "JUDGER_TOKEN = environ.get('JUDGER_TOKEN', '123456')\n\n# middleware settings\nCHECKLOGIN_EXCLUDE_PATH = [\n    '/api/user/register',\n    '/api/user/login',\n    '/api/submission/status',\n    '/api/contest/recent',\n    '/api/contest/all',\n    '/api/contest/detail',", "    '/api/contest/all',\n    '/api/contest/detail',\n    '/api/contest/announcements',\n    '/api/problem/hot',\n    '/api/problem/all',\n    '/api/problem/detail',\n    '/api/admin/sys/qdu/import',\n    '/docs',\n    '/openapi.json',\n]", "    '/openapi.json',\n]\n\nAES_KEY = environ.get('AES_KEY', 'Your_AES_KEY')\nAES_KEY = AES_KEY.ljust(16)\n\nTEST_CASE_DIR = ''\n"]}
{"filename": "OJ/app/__init__.py", "chunked_list": [""]}
