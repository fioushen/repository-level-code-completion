{"filename": "scripts/docker.py", "chunked_list": ["from scripts import CommandProcessor\n\n\ndef main():\n    commands = {\n        \"removing old packages\": \"rm -rf dist\",\n        \"building the project\": \"poetry build\",\n        \"creating docker image\": \"docker build -t sauljabin/kayak:latest -f docker/Dockerfile .\",\n    }\n    command_processor = CommandProcessor(commands)\n    command_processor.run()", "\n\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "scripts/banner.py", "chunked_list": ["from rich import box\nfrom rich.console import Console\nfrom rich.panel import Panel\n\nfrom kayak.renderables.kayak_name import KayakName\nfrom kayak.styles.colors import PRIMARY\n\n\ndef main():\n    console = Console()\n    panel = Panel.fit(KayakName(False), box=box.ROUNDED, border_style=PRIMARY)\n    console.print(panel)", "def main():\n    console = Console()\n    panel = Panel.fit(KayakName(False), box=box.ROUNDED, border_style=PRIMARY)\n    console.print(panel)\n\n\nif __name__ == \"__main__\":\n    main()\n", ""]}
{"filename": "scripts/tests.py", "chunked_list": ["from scripts import CommandProcessor\n\n\ndef main():\n    commands = {\n        \"executing tests\": \"poetry run python -m unittest -v\",\n    }\n    command_processor = CommandProcessor(commands)\n    command_processor.run()\n", "\n\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "scripts/__init__.py", "chunked_list": ["import shlex\nimport subprocess\nimport sys\n\nfrom rich.console import Console\n\n\nclass CommandProcessor:\n    def __init__(self, commands, rollback={}):\n        self.commands = commands\n        self.rollback = rollback\n        self.console = Console()\n\n    def run(self):\n        for name, command in self.commands.items():\n            result = self.execute_command(name, command)\n            if result.returncode:\n                self.console.print(\n                    \"\\n[bold red]Error[/] when executing \"\n                    f'[bold blue]\"{name}\" ([bold yellow]{command}[/])[/]:exclamation::\\n'\n                    f\"[red]{result.stdout.decode().strip()}{result.stderr.decode().strip()}[/]\\n\"\n                )\n\n                if self.rollback:\n                    self.console.print(\"[bold yellow]Rolling back:[/]\")\n                    for rollback_name, rollback_command in self.rollback.items():\n                        self.execute_command(rollback_name, rollback_command)\n\n                sys.exit(result.returncode)\n\n    def execute_command(self, name, command):\n        self.console.print()\n        self.console.print(f\"[bold blue]{name.lower()}:\")\n        self.console.print(f\"[bold yellow]{command}[/]\")\n        return subprocess.run(shlex.split(command), capture_output=True)", "\n\nif __name__ == \"__main__\":\n    test_commands = {\n        \"list files\": \"ls .\",\n        \"testing echo\": \"echo 'hello world'\",\n        \"no command\": \"false\",\n    }\n    test_rollback = {\"echo rollback\": \"echo 'error'\"}\n    command_processor = CommandProcessor(test_commands, test_rollback)\n    command_processor.run()", ""]}
{"filename": "scripts/bump.py", "chunked_list": ["import click\nimport toml\nfrom rich.console import Console\n\nfrom scripts import CommandProcessor\n\n\n@click.command()\n@click.argument(\n    \"rule\",", "@click.argument(\n    \"rule\",\n    nargs=1,\n    type=click.Choice([\"major\", \"minor\", \"patch\"], case_sensitive=False),\n)\ndef main(rule):\n    \"\"\"\n    \\b\n    Examples:\n        poetry run python -m scripts.bump major\n        poetry run python -m scripts.bump minor\n        poetry run python -m scripts.bump patch\n\n    More info at https://python-poetry.org/docs/cli/#version and https://semver.org/.\n    \"\"\"\n    bump_version(rule)\n    new_app_version = get_app_version()\n    changelog_release(new_app_version)\n\n    console = Console()\n    confirmation = console.input(\n        f\"\\n[bold]Release a new [purple]{rule}[/] version [purple]{new_app_version}[/]\"\n        \" ([green]yes[/]/[red]no[/])? [/]\"\n    )\n\n    if confirmation != \"yes\":\n        revert_changes()\n        exit(1)\n\n    confirm_changes(new_app_version)", "\n\ndef changelog_release(version):\n    init_commands = {\n        f\"bumping changelog to a [purple bold]{version}[/] version\": (\n            f\"poetry run changeloggh release {version}\"\n        ),\n    }\n    revert_commands = {\n        \"deleting changes\": \"git checkout .\",\n    }\n    command_processor = CommandProcessor(init_commands, revert_commands)\n    command_processor.run()", "\n\ndef bump_version(rule):\n    init_commands = {\n        \"checking pending changes\": \"git diff --exit-code\",\n        \"checking pending changes in stage\": \"git diff --staged --exit-code\",\n        \"checking not pushed commits\": \"git diff --exit-code main origin/main\",\n        f\"bumping to a [purple bold]{rule}[/] version\": f\"poetry version {rule}\",\n    }\n    command_processor = CommandProcessor(init_commands)\n    command_processor.run()", "\n\ndef confirm_changes(app_version):\n    confirm_commands = {\n        \"adding new version\": \"git add --all\",\n        \"committing new version\": f\"git commit -m 'bumping version to {app_version}'\",\n        \"adding new version tag\": f\"git tag v{app_version}\",\n        \"pushing new changes\": \"git push origin main\",\n        \"pushing tag\": \"git push --tags\",\n    }\n    command_processor = CommandProcessor(confirm_commands)\n    command_processor.run()", "\n\ndef revert_changes():\n    revert_commands = {\n        \"deleting changes\": \"git checkout .\",\n    }\n    command_processor = CommandProcessor(revert_commands)\n    command_processor.run()\n\n\ndef get_app_version():\n    toml_data = toml.load(\"pyproject.toml\")\n    app_version = toml_data[\"tool\"][\"poetry\"][\"version\"]\n    return app_version", "\n\ndef get_app_version():\n    toml_data = toml.load(\"pyproject.toml\")\n    app_version = toml_data[\"tool\"][\"poetry\"][\"version\"]\n    return app_version\n\n\nif __name__ == \"__main__\":\n    main()", "if __name__ == \"__main__\":\n    main()\n"]}
{"filename": "scripts/styles.py", "chunked_list": ["from scripts import CommandProcessor\n\n\ndef main():\n    commands = {\n        \"black\": \"poetry run black . --preview\",\n        \"ruff\": \"poetry run ruff . --fix\",\n    }\n    command_processor = CommandProcessor(commands)\n    command_processor.run()", "\n\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "scripts/analyze.py", "chunked_list": ["from scripts import CommandProcessor\n\n\ndef main():\n    commands = {\n        \"checking types\": \"poetry run mypy kayak/\",\n        \"black\": \"poetry run black --check .\",\n        \"ruff\": \"poetry run ruff check .\",\n    }\n    command_processor = CommandProcessor(commands)\n    command_processor.run()", "\n\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "tests/test_app.py", "chunked_list": ["from logging import DEBUG\nfrom unittest import TestCase\nfrom unittest.mock import patch\n\nfrom click.testing import CliRunner\n\nfrom kayak import VERSION\nfrom kayak.app import main\n\n\nclass TestApp(TestCase):\n    def test_print_version(self):\n        runner = CliRunner()\n        result = runner.invoke(main, [\"--version\"])\n        self.assertEqual(result.exit_code, 0)\n        self.assertIn(VERSION, result.output)\n\n    @patch(\"kayak.app.logger\")\n    def test_debug_version(self, mock_logger):\n        runner = CliRunner()\n        runner.invoke(main, [\"--debug\"])\n        mock_logger.setLevel.assert_called_once_with(DEBUG)\n        mock_logger.debug.assert_called_once_with(\"Starting in debug mode\")\n\n    def test_missing_server(self):\n        runner = CliRunner()\n        result = runner.invoke(main)\n        self.assertEqual(result.exit_code, 1)\n        self.assertIn(\"Missing argument 'SERVER'\", result.output)\n\n    def test_missing_pass(self):\n        runner = CliRunner()\n        result = runner.invoke(main, [\"--user\", \"user\"])\n        self.assertEqual(result.exit_code, 1)\n        self.assertIn(\"Please provide an --user and --password\", result.output)\n\n    def test_missing_user(self):\n        runner = CliRunner()\n        result = runner.invoke(main, [\"--password\", \"password\"])\n        self.assertEqual(result.exit_code, 1)\n        self.assertIn(\"Please provide an --user and --password\", result.output)\n\n    @patch(\"kayak.app.Tui\")\n    def test_run_tui(self, mock_class_tui):\n        runner = CliRunner()\n        runner.invoke(main, [\"--user\", \"user\", \"--password\", \"password\", \"server\"])\n        mock_class_tui.assert_called_once_with(\"server\", \"user\", \"password\")\n        mock_class_tui.return_value.run.assert_called_once_with()", "\n\nclass TestApp(TestCase):\n    def test_print_version(self):\n        runner = CliRunner()\n        result = runner.invoke(main, [\"--version\"])\n        self.assertEqual(result.exit_code, 0)\n        self.assertIn(VERSION, result.output)\n\n    @patch(\"kayak.app.logger\")\n    def test_debug_version(self, mock_logger):\n        runner = CliRunner()\n        runner.invoke(main, [\"--debug\"])\n        mock_logger.setLevel.assert_called_once_with(DEBUG)\n        mock_logger.debug.assert_called_once_with(\"Starting in debug mode\")\n\n    def test_missing_server(self):\n        runner = CliRunner()\n        result = runner.invoke(main)\n        self.assertEqual(result.exit_code, 1)\n        self.assertIn(\"Missing argument 'SERVER'\", result.output)\n\n    def test_missing_pass(self):\n        runner = CliRunner()\n        result = runner.invoke(main, [\"--user\", \"user\"])\n        self.assertEqual(result.exit_code, 1)\n        self.assertIn(\"Please provide an --user and --password\", result.output)\n\n    def test_missing_user(self):\n        runner = CliRunner()\n        result = runner.invoke(main, [\"--password\", \"password\"])\n        self.assertEqual(result.exit_code, 1)\n        self.assertIn(\"Please provide an --user and --password\", result.output)\n\n    @patch(\"kayak.app.Tui\")\n    def test_run_tui(self, mock_class_tui):\n        runner = CliRunner()\n        runner.invoke(main, [\"--user\", \"user\", \"--password\", \"password\", \"server\"])\n        mock_class_tui.assert_called_once_with(\"server\", \"user\", \"password\")\n        mock_class_tui.return_value.run.assert_called_once_with()", ""]}
{"filename": "tests/__init__.py", "chunked_list": [""]}
{"filename": "kayak/app.py", "chunked_list": ["import os\nfrom logging import DEBUG\n\nimport click\nfrom rich.console import Console\n\nfrom kayak import logger\nfrom kayak.renderables.kayak_name import KayakName\nfrom kayak.tui import Tui\n", "from kayak.tui import Tui\n\n\n@click.command()\n@click.option(\"--version\", is_flag=True, help=\"Show the app version and exit.\")\n@click.option(\n    \"--debug\",\n    is_flag=True,\n    help=\"Enable debug mode, it writes a log file in ~/.kayak/kayak.log.\",\n)", "    help=\"Enable debug mode, it writes a log file in ~/.kayak/kayak.log.\",\n)\n@click.option(\n    \"--password\",\n    prompt=True,\n    hide_input=True,\n    prompt_required=False,\n    default=lambda: os.environ.get(\"KSQLDB_PASSWORD\", None),\n    help=(\n        \"If your KSQL server is configured for authentication, then provide your password here. The\"", "    help=(\n        \"If your KSQL server is configured for authentication, then provide your password here. The\"\n        \" username must be specified separately with the --user option. Use KSQLDB_PASSWORD env\"\n        \" variable to set a default value.\"\n    ),\n)\n@click.option(\n    \"--user\",\n    default=lambda: os.environ.get(\"KSQLDB_USER\", None),\n    help=(", "    default=lambda: os.environ.get(\"KSQLDB_USER\", None),\n    help=(\n        \"If your KSQL server is configured for authentication, then provide your user name here.\"\n        \" The password must be specified separately with the --password option. Use KSQLDB_USER env\"\n        \" variable to set a default value.\"\n    ),\n)\n@click.argument(\"server\", nargs=1, required=False, default=None)\ndef main(\n    version: bool,\n    debug: bool,\n    password: str | None,\n    user: str | None,\n    server: str | None,\n) -> None:\n    \"\"\"\n    kayak is a ksqlDB TUI (text user interface).\n\n    \\b\n    SERVER  The address of the Ksql server to connect to\n            (ex: http://localhost:8088).\n            This option may occur a maximum of 1 times.\n    \"\"\"\n\n    if debug:\n        logger.setLevel(DEBUG)\n        logger.debug(\"Starting in debug mode\")\n\n    console = Console()\n\n    if version:\n        console.print(KayakName())\n        exit(0)\n\n    if [user, password].count(None) == 1:\n        console.print(\"[bold red]Please provide an --user and --password[/]\")\n        exit(1)\n\n    if server is None:\n        console.print(\"[bold red]Missing argument 'SERVER'[/]\")\n        exit(1)\n\n    tui = Tui(server, user, password)\n    tui.run()", "def main(\n    version: bool,\n    debug: bool,\n    password: str | None,\n    user: str | None,\n    server: str | None,\n) -> None:\n    \"\"\"\n    kayak is a ksqlDB TUI (text user interface).\n\n    \\b\n    SERVER  The address of the Ksql server to connect to\n            (ex: http://localhost:8088).\n            This option may occur a maximum of 1 times.\n    \"\"\"\n\n    if debug:\n        logger.setLevel(DEBUG)\n        logger.debug(\"Starting in debug mode\")\n\n    console = Console()\n\n    if version:\n        console.print(KayakName())\n        exit(0)\n\n    if [user, password].count(None) == 1:\n        console.print(\"[bold red]Please provide an --user and --password[/]\")\n        exit(1)\n\n    if server is None:\n        console.print(\"[bold red]Missing argument 'SERVER'[/]\")\n        exit(1)\n\n    tui = Tui(server, user, password)\n    tui.run()", "\n\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "kayak/__init__.py", "chunked_list": ["import logging\nfrom importlib.metadata import version\nfrom pathlib import Path\n\nNAME = \"kayak\"\n__version__ = VERSION = version(NAME)\n\n\ndef get_home() -> Path:\n    user_home = Path.home()\n    app_home = user_home.joinpath(\".\" + NAME)\n    if not app_home.exists():\n        app_home.mkdir()\n    return app_home", "def get_home() -> Path:\n    user_home = Path.home()\n    app_home = user_home.joinpath(\".\" + NAME)\n    if not app_home.exists():\n        app_home.mkdir()\n    return app_home\n\n\nLOG = get_home().joinpath(NAME + \".log\")\n", "LOG = get_home().joinpath(NAME + \".log\")\n\nlogger_handler = logging.FileHandler(LOG)\nlogger_handler.setFormatter(logging.Formatter(\"%(asctime)-15s %(levelname)-8s %(message)s\"))\n\nlogger = logging.getLogger()\nlogger.addHandler(logger_handler)\nlogger.setLevel(logging.INFO)\n", ""]}
{"filename": "kayak/tui.py", "chunked_list": ["import asyncio\nimport json\nfrom enum import Enum\nfrom typing import Any, Final, List, Literal, Type\n\nfrom rich.columns import Columns\nfrom rich.console import RenderableType\nfrom rich.json import JSON\nfrom rich.text import Text\nfrom textual.app import App, ComposeResult, CSSPathType", "from rich.text import Text\nfrom textual.app import App, ComposeResult, CSSPathType\nfrom textual.binding import Binding\nfrom textual.containers import Container, Horizontal\nfrom textual.driver import Driver\nfrom textual.keys import Keys\nfrom textual.reactive import reactive\nfrom textual.widgets import DataTable, Footer, Input, Label, Static, Switch, Tree\nfrom textual.widgets._tree import EventTreeDataType, TreeNode\n", "from textual.widgets._tree import EventTreeDataType, TreeNode\n\nfrom kayak import logger\nfrom kayak.ksql.ksql_service import KsqlService\nfrom kayak.ksql.models import Server\nfrom kayak.renderables.kayak_name import KayakName\nfrom kayak.renderables.server_info import ServerInfo\nfrom kayak.styles.colors import DESIGN, ERROR, GREEN\n\nRIGHT: Final = \"right\"", "\nRIGHT: Final = \"right\"\nLEFT: Final = \"left\"\n\n\nclass Statuses(Enum):\n    RUNNING = f\"bold {GREEN}\"\n    IDLE = \"bold\"\n    ERROR = f\"bold {ERROR}\"\n", "\n\nclass Status(Container):\n    status = reactive(Statuses.IDLE)\n\n    def render(self) -> RenderableType:\n        return Text.from_markup(f\"STATUS: [{self.status.value}]{self.status.name}[/]\")\n\n\nclass Settings(Container):\n    earliest = True\n\n    def on_switch_changed(self, event: Switch.Changed) -> None:\n        self.earliest = event.value\n\n    def compose(self) -> ComposeResult:\n        yield Label(\"SETTINGS\", classes=\"title\")\n        yield Horizontal(Static(\"EARLIEST:     \", classes=\"label\"), Switch(value=self.earliest))", "\nclass Settings(Container):\n    earliest = True\n\n    def on_switch_changed(self, event: Switch.Changed) -> None:\n        self.earliest = event.value\n\n    def compose(self) -> ComposeResult:\n        yield Label(\"SETTINGS\", classes=\"title\")\n        yield Horizontal(Static(\"EARLIEST:     \", classes=\"label\"), Switch(value=self.earliest))", "\n\nclass JsonViewer(Container, can_focus=True):\n    json = reactive(\"{}\")\n\n    def watch_json(self, json: str) -> None:\n        json_widget = self.query_one(Json)\n        json_widget.update(JSON(json, sort_keys=True))\n        self.scroll_home()\n\n    def compose(self) -> ComposeResult:\n        yield Container(Json(expand=True))", "\n\nclass Json(Static):\n    pass\n\n\nclass Editor(Container):\n    pass\n\n\nclass Header(Static):\n    server = Server()\n\n    def render(self) -> RenderableType:\n        kayak_name = KayakName()\n        ksql_info = ServerInfo(self.server)\n        return Columns([kayak_name, ksql_info], padding=3)", "\n\nclass Header(Static):\n    server = Server()\n\n    def render(self) -> RenderableType:\n        kayak_name = KayakName()\n        ksql_info = ServerInfo(self.server)\n        return Columns([kayak_name, ksql_info], padding=3)\n", "\n\nclass Tui(App[None]):\n    CSS_PATH = \"tui.css\"\n    BINDINGS = [\n        Binding(Keys.ControlC, \"quit\", \"QUIT\"),\n        # Binding(Keys.F1, \"push_screen('help')\", \"HELP\"),\n        Binding(Keys.ControlX, \"kill_query\", \"KILL QUERY\"),\n        Binding(Keys.ControlS, \"toggle_settings\", \"TOGGLE SETTINGS\"),\n    ]\n\n    status = reactive(Statuses.IDLE)\n    query_id: str | None = None\n\n    def __init__(\n        self,\n        server: str,\n        user: str | None,\n        password: str | None,\n        driver_class: Type[Driver] | None = None,\n        css_path: CSSPathType | None = None,\n        watch_css: bool = False,\n    ):\n        super().__init__(driver_class, css_path, watch_css)\n        self.ksql_service = KsqlService(server, user, password)\n        self.server = self.ksql_service.info()\n        self.topics = self.ksql_service.topics()\n        self.streams = self.ksql_service.streams()\n        self.tables = self.ksql_service.tables()\n        self.queries = self.ksql_service.queries()\n\n    def on_mount(self) -> None:\n        input_query = self.query_one(Input)\n        input_query.placeholder = \"QUERY\"\n        input_query.focus()\n\n        header = self.query_one(Header)\n        header.server = self.server\n\n        tree = self.query_one(Tree)\n        tree.show_root = False\n        tree.root.expand()\n        tree.cursor_line = -1\n\n        topics_node = tree.root.add(\"TOPICS\", expand=True, data=\"TOPICS\")\n        for topic in self.topics:\n            topics_node.add_leaf(topic.name, data=topic.name)\n\n        streams_node = tree.root.add(\"STREAMS\", expand=True, data=\"STREAMS\")\n        for stream in self.streams:\n            streams_node.add_leaf(stream.name, data=stream.name)\n\n        tables_node = tree.root.add(\"TABLES\", expand=True, data=\"TABLES\")\n        for table in self.tables:\n            tables_node.add_leaf(table.name, data=table.name)\n\n        queries_node = tree.root.add(\"QUERIES\", expand=True, data=\"QUERIES\")\n        for query in self.queries:\n            queries_node.add_leaf(query.id, data=query.id)\n\n        table_widget = self.query_one(DataTable)\n        table_widget.cursor_type = \"row\"\n\n        self.design = DESIGN\n        self.refresh_css()\n\n    async def action_kill_query(self) -> None:\n        logger.debug(\"Killing query %s\", self.query_id)\n        if self.query_id:\n            self.ksql_service.close_query(self.query_id)\n\n    async def action_toggle_settings(self) -> None:\n        input_widget = self.query_one(Input)\n\n        settings = self.query_one(Settings)\n        switch = settings.query_one(Switch)\n\n        if switch.has_focus:\n            input_widget.focus()\n        else:\n            switch.focus()\n\n    def watch_status(self, status: Statuses) -> None:\n        status_widget = self.query_one(Status)\n        status_widget.status = status\n\n    async def on_tree_node_selected(\n        self, selected_node_event: Tree.NodeSelected[EventTreeDataType]\n    ) -> None:\n        node: TreeNode[EventTreeDataType] = selected_node_event.node\n\n        if node.parent is None:\n            return\n\n        parent: TreeNode[EventTreeDataType] = node.parent\n\n        str_parent: str = str(parent.data)\n        str_child: str = str(node.data)\n\n        logger.debug(\"parent selected node: %s\", str_parent)\n        logger.debug(\"selected node: %s\", str_child)\n\n        if str_parent.upper() in [\"STREAMS\", \"TABLES\"]:\n            self.fill_input(f\"DESCRIBE {str_child};\")\n        if str_parent.upper() in [\"QUERIES\"]:\n            self.fill_input(f\"EXPLAIN {str_child};\")\n\n    def fill_input(self, value: str) -> None:\n        input_query = self.query_one(Input)\n        input_query.value = value\n        input_query.focus()\n\n    async def on_input_submitted(self, input_submitted_event: Input.Submitted) -> None:\n        input_value = input_submitted_event.value\n\n        if not input_value:\n            return\n\n        await self.action_kill_query()\n\n        settings = self.query_one(Settings)\n        json_viewer = self.query_one(JsonViewer)\n        table = self.query_one(DataTable)\n\n        if input_value.upper().startswith(\"PRINT\"):\n            self.error_state(\n                json.dumps(\n                    {\n                        \"message\": (\n                            'PRINT query is not allowed. Import the topic as a \"stream\" and use'\n                            \" SELECT\"\n                        )\n                    }\n                )\n            )\n        elif input_value.upper().startswith(\"SELECT\"):\n            table.remove_class(\"hidden\")\n            json_viewer.add_class(\"hidden\")\n            table.focus()\n\n            table.clear(columns=True)\n\n            columns = []\n\n            def on_close() -> None:\n                self.query_id = None\n                if self.status == Statuses.RUNNING:\n                    self.status = Statuses.IDLE\n\n            def on_init(data: dict[str, Any]) -> None:\n                self.status = Statuses.RUNNING\n                self.query_id = data[\"queryId\"]\n                nonlocal columns\n\n                column_names: List[str] = data[\"columnNames\"]\n                justify_list: List[Literal[\"left\", \"right\"]] = [\n                    LEFT if column_type.upper() in [\"VARCHAR\", \"STRING\"] else RIGHT\n                    for column_type in data[\"columnTypes\"]\n                ]\n\n                columns = list(\n                    zip(\n                        column_names,\n                        justify_list,\n                    )\n                )\n                logger.debug(\"adding columns: %s\", columns)\n                for column_name, justify in columns:\n                    table.add_column(Text(str(column_name), justify=justify))\n\n            def on_new_row(row: list[Any]) -> None:\n                nonlocal columns\n                zip_row = list(zip(row, [justify for column_name, justify in columns]))\n                logger.debug(\"adding row: %s\", zip_row)\n                row = [Text(str(cell), justify=justify) for cell, justify in zip_row]\n                table.add_row(*row)\n                table.scroll_end()\n\n            def on_error(code: int, content: str) -> None:\n                self.error_state(content)\n\n            asyncio.create_task(\n                self.ksql_service.query(\n                    query=input_value,\n                    earliest=settings.earliest,\n                    on_init=on_init,\n                    on_new_row=on_new_row,\n                    on_close=on_close,\n                    on_error=on_error,\n                )\n            )\n        else:\n            json_viewer.remove_class(\"hidden\")\n            table.add_class(\"hidden\")\n            json_viewer.focus()\n\n            response = self.ksql_service.statement(input_value)\n            json_viewer.json = response.text\n\n            if response.status_code != 200:\n                json_viewer.add_class(\"error\")\n                self.status = Statuses.ERROR\n            else:\n                json_viewer.remove_class(\"error\")\n                self.status = Statuses.IDLE\n\n    def error_state(self, error_content: str) -> None:\n        json_viewer = self.query_one(JsonViewer)\n        table = self.query_one(DataTable)\n        json_viewer.remove_class(\"hidden\")\n        table.add_class(\"hidden\")\n        json_viewer.focus()\n        json_viewer.json = error_content\n        json_viewer.add_class(\"error\")\n        self.status = Statuses.ERROR\n\n    def compose(self) -> ComposeResult:\n        yield Header()\n        yield Footer()\n        yield Settings(classes=\"-hidden\")\n        yield Tree(\"\")\n        with Editor():\n            yield Input()\n            yield DataTable()\n            yield JsonViewer(classes=\"hidden\")\n            yield Status()", ""]}
{"filename": "kayak/styles/colors.py", "chunked_list": ["from textual.design import ColorSystem\n\nERROR = \"#ba3c5b\"\nGREEN = \"#4EBF71\"\nPRIMARY = \"#ff5f00\"\nSECONDARY = \"#0087ff\"\n\nDESIGN = {\n    \"dark\": ColorSystem(\n        primary=PRIMARY,", "    \"dark\": ColorSystem(\n        primary=PRIMARY,\n        secondary=SECONDARY,\n        error=ERROR,\n        dark=True,\n    ),\n    \"light\": ColorSystem(\n        primary=PRIMARY,\n        secondary=SECONDARY,\n        error=ERROR,", "        secondary=SECONDARY,\n        error=ERROR,\n        dark=False,\n    ),\n}\n"]}
{"filename": "kayak/styles/__init__.py", "chunked_list": [""]}
{"filename": "kayak/renderables/kayak_name.py", "chunked_list": ["from pyfiglet import Figlet\nfrom rich.text import Text\n\nfrom kayak import NAME, VERSION\nfrom kayak.styles.colors import PRIMARY, SECONDARY\n\n\nclass KayakName:\n    def __init__(self, include_version: bool = True):\n        self.include_version = include_version\n\n    def __str__(self) -> str:\n        figlet = Figlet(font=\"chunky\")\n        text: str = figlet.renderText(NAME)\n        return text.rstrip()\n\n    def __rich__(self) -> Text:\n        text = Text(str(self), style=f\"{PRIMARY} bold\")\n\n        if self.include_version:\n            text.append(f\"v{VERSION}\", style=f\"{SECONDARY} bold\")\n\n        return text", ""]}
{"filename": "kayak/renderables/__init__.py", "chunked_list": [""]}
{"filename": "kayak/renderables/server_info.py", "chunked_list": ["from rich.table import Table\n\nfrom kayak.ksql.models import Server\nfrom kayak.styles.colors import SECONDARY\n\n\nclass ServerInfo:\n    def __init__(self, server: Server) -> None:\n        self.server = server\n\n    def __str__(self) -> str:\n        return str(self.server)\n\n    def __rich__(self) -> Table:\n        table = Table(box=None, expand=False)\n        table.add_column(style=f\"{SECONDARY} bold\")\n        table.add_column()\n\n        table.add_row(\"SERVER:\", self.server.server)\n        table.add_row(\"ID:\", self.server.id)\n        table.add_row(\"VERSION:\", self.server.version if self.server.version else \"unknown\")\n        table.add_row(\"STATUS:\", self.server.status.lower())\n        table.add_row(\"SERVICE ID:\", self.server.service_id)\n\n        return table", ""]}
{"filename": "kayak/ksql/ksql_service.py", "chunked_list": ["import asyncio\nimport json\nfrom typing import Any, Callable, Dict, List\nfrom urllib.parse import urljoin\n\nimport httpx\nfrom httpx import Response\n\nfrom kayak.ksql.models import Server, Stream, Topic, Table, Query\n", "from kayak.ksql.models import Server, Stream, Topic, Table, Query\n\nTIMEOUT_1H = 60 * 60\n\nKSQL_HEADERS = {\"Accept\": \"application/vnd.ksql.v1+json\"}\n\n\nclass KsqlService:\n    def __init__(\n        self,\n        server: str,\n        user: str | None = None,\n        password: str | None = None,\n    ):\n        self.server = server\n        self.user = user\n        self.password = password\n\n    def info(self) -> Server:\n        response = self.introspect(\"info\")\n        response.raise_for_status()\n\n        def json_to_server(obj: dict[Any, Any], server: str) -> Any:\n            if \"KsqlServerInfo\" in obj:\n                return obj[\"KsqlServerInfo\"]\n            if \"version\" in obj:\n                return Server(\n                    id=obj[\"kafkaClusterId\"],\n                    service_id=obj[\"ksqlServiceId\"],\n                    status=obj[\"serverStatus\"],\n                    version=obj[\"version\"],\n                    server=server,\n                )\n            return obj\n\n        server_obj: Server = response.json(object_hook=lambda d: json_to_server(d, self.server))\n        return server_obj\n\n    def streams(self) -> List[Stream]:\n        response = self.statement(\"LIST STREAMS;\")\n        response.raise_for_status()\n\n        def json_to_stream(obj: dict[Any, Any]) -> Any:\n            if \"streams\" in obj:\n                return obj[\"streams\"]\n            if \"name\" in obj:\n                return Stream(\n                    name=obj[\"name\"],\n                    topic=obj[\"topic\"],\n                    key_format=obj[\"keyFormat\"],\n                    value_format=obj[\"valueFormat\"],\n                )\n            return obj\n\n        streams: List[Stream] = response.json(object_hook=json_to_stream)[0]\n        return streams\n\n    def tables(self) -> List[Table]:\n        response = self.statement(\"LIST TABLES;\")\n        response.raise_for_status()\n\n        def json_to_table(obj: dict[Any, Any]) -> Any:\n            if \"tables\" in obj:\n                return obj[\"tables\"]\n            if \"name\" in obj:\n                return Table(\n                    name=obj[\"name\"],\n                    topic=obj[\"topic\"],\n                    key_format=obj[\"keyFormat\"],\n                    value_format=obj[\"valueFormat\"],\n                )\n            return obj\n\n        tables: List[Table] = response.json(object_hook=json_to_table)[0]\n        return tables\n\n    def queries(self) -> List[Query]:\n        response = self.statement(\"LIST QUERIES;\")\n        response.raise_for_status()\n\n        def json_to_query(obj: dict[Any, Any]) -> Any:\n            if \"queries\" in obj:\n                return obj[\"queries\"]\n            if \"id\" in obj:\n                return Query(\n                    id=obj[\"id\"],\n                    topics=obj[\"sinkKafkaTopics\"],\n                    query_type=obj[\"queryType\"],\n                    state=obj[\"state\"],\n                )\n            return obj\n\n        queries: List[Query] = response.json(object_hook=json_to_query)[0]\n        return queries\n\n    def topics(self) -> List[Topic]:\n        response = self.statement(\"LIST TOPICS;\")\n        response.raise_for_status()\n\n        def json_to_topic(obj: dict[Any, Any]) -> Any:\n            if \"topics\" in obj:\n                return obj[\"topics\"]\n            if \"name\" in obj:\n                return Topic(\n                    name=obj[\"name\"],\n                )\n            return obj\n\n        topic_list: List[Topic] = response.json(object_hook=json_to_topic)[0]\n        return topic_list\n\n    def auth(self) -> tuple[str, str] | None:\n        return None if None in [self.user, self.password] else (str(self.user), str(self.password))\n\n    def introspect(self, resource: str) -> Response:\n        url = urljoin(self.server, resource)\n        response = httpx.get(\n            url,\n            headers=KSQL_HEADERS,\n            auth=self.auth(),\n        )\n        return response\n\n    def statement(self, statement: str) -> Response:\n        data = {\"ksql\": statement}\n        url = urljoin(self.server, \"/ksql\")\n        response = httpx.post(\n            url,\n            json=data,\n            headers=KSQL_HEADERS,\n            auth=self.auth(),\n        )\n        return response\n\n    async def query(\n        self,\n        query: str,\n        earliest: bool = False,\n        on_init: Callable[[dict[str, Any]], None] = lambda data: None,\n        on_new_row: Callable[[list[Any]], None] = lambda row: None,\n        on_close: Callable[[], None] = lambda: None,\n        on_error: Callable[[int, str], None] = lambda code, content: None,\n    ) -> None:\n        url = urljoin(self.server, \"/query-stream\")\n        data = {\n            \"sql\": query,\n            \"properties\": {\"auto.offset.reset\": \"earliest\"} if earliest else {},\n        }\n\n        async with httpx.AsyncClient(\n            http2=True,\n            timeout=TIMEOUT_1H,\n            auth=self.auth(),\n        ) as client:\n            async with client.stream(method=\"POST\", url=url, json=data) as stream:\n                async for chunk in stream.aiter_text():\n                    if chunk:\n                        results = json.loads(chunk)\n\n                        if stream.status_code != 200:\n                            on_error(stream.status_code, chunk)\n                            break\n\n                        if isinstance(results, Dict):\n                            on_init(results)\n                        elif isinstance(results, List):\n                            on_new_row(results)\n\n        on_close()\n\n    def close_query(self, id: str) -> None:\n        url = urljoin(self.server, \"/close-query\")\n        data = {\"queryId\": id}\n        httpx.post(\n            url,\n            json=data,\n            headers=KSQL_HEADERS,\n            auth=self.auth(),\n        )", "\n\nif __name__ == \"__main__\":\n    service = KsqlService(\"http://localhost:8088\")\n\n    print(\"--REQUESTS--\")\n\n    print(\"info\", service.info())\n    print(\"streams\", service.streams())\n    print(\"topics\", service.topics())\n    print(\"tables\", service.tables())\n    print(\"queries\", service.queries())\n\n    print(\"--QUERIES--\")\n\n    asyncio.run(\n        service.query(\n            \"SELECT * FROM orders;\",\n            on_init=print,\n            on_new_row=print,\n            on_close=lambda: print(\"orders finished\"),\n        )\n    )\n\n    query_id = \"\"\n\n    async def close_query() -> None:\n        global query_id\n        await asyncio.sleep(10)\n        service.close_query(query_id)\n\n    async def pull_query() -> None:\n        def on_init(data: dict[str, Any]) -> None:\n            global query_id\n            query_id = data[\"queryId\"]\n            print(query_id)\n            print(data[\"columnTypes\"])\n\n        query = asyncio.create_task(\n            service.query(\n                \"SELECT * FROM orderSizes EMIT CHANGES;\",\n                True,\n                on_init=on_init,\n                on_new_row=print,\n                on_close=lambda: print(\"orderSizes finished\"),\n            )\n        )\n\n        close = asyncio.create_task(close_query())\n\n        await query\n        await close\n\n    asyncio.run(pull_query())\n\n    print(\"--QUERY ERROR--\")\n\n    asyncio.run(\n        service.query(\n            \"SELECT * FROM orders\",\n            on_error=lambda code, content: print(\"response status:\", code, \"content:\", content),\n            on_close=lambda: print(\"error closed\"),\n        )\n    )", ""]}
{"filename": "kayak/ksql/models.py", "chunked_list": ["import json\nfrom typing import List\n\n\nclass Server:\n    def __init__(\n        self,\n        id: str = \"\",\n        server: str = \"\",\n        service_id: str = \"\",\n        status: str = \"\",\n        version: str = \"\",\n    ) -> None:\n        self.id = id\n        self.server = server\n        self.service_id = service_id\n        self.status = status\n        self.version = version\n\n    def __repr__(self) -> str:\n        return json.dumps(\n            {\n                \"id\": self.id,\n                \"server\": self.server,\n                \"service_id\": self.service_id,\n                \"status\": self.status,\n                \"version\": self.version,\n            }\n        )\n\n    def __str__(self) -> str:\n        return repr(self)", "\n\nclass Stream:\n    def __init__(\n        self,\n        name: str = \"\",\n        topic: str = \"\",\n        key_format: str = \"\",\n        value_format: str = \"\",\n    ) -> None:\n        self.name = name\n        self.topic = topic\n        self.key_format = key_format\n        self.value_format = value_format\n\n    def __repr__(self) -> str:\n        return json.dumps(\n            {\n                \"name\": self.name,\n                \"topic\": self.topic,\n                \"key_format\": self.key_format,\n                \"value_format\": self.value_format,\n            }\n        )\n\n    def __str__(self) -> str:\n        return repr(self)", "\n\nclass Table:\n    def __init__(\n        self,\n        name: str = \"\",\n        topic: str = \"\",\n        key_format: str = \"\",\n        value_format: str = \"\",\n    ) -> None:\n        self.name = name\n        self.topic = topic\n        self.key_format = key_format\n        self.value_format = value_format\n\n    def __repr__(self) -> str:\n        return json.dumps(\n            {\n                \"name\": self.name,\n                \"topic\": self.topic,\n                \"key_format\": self.key_format,\n                \"value_format\": self.value_format,\n            }\n        )\n\n    def __str__(self) -> str:\n        return repr(self)", "\n\nclass Query:\n    def __init__(\n        self,\n        id: str = \"\",\n        topics: List[str] = [],\n        query_type: str = \"\",\n        state: str = \"\",\n    ) -> None:\n        self.id = id\n        self.topics = topics\n        self.query_type = query_type\n        self.state = state\n\n    def __repr__(self) -> str:\n        return json.dumps(\n            {\n                \"id\": self.id,\n                \"topics\": self.topics,\n                \"query_type\": self.query_type,\n                \"state\": self.state,\n            }\n        )\n\n    def __str__(self) -> str:\n        return repr(self)", "\n\nclass Topic:\n    def __init__(\n        self,\n        name: str = \"\",\n    ) -> None:\n        self.name = name\n\n    def __repr__(self) -> str:\n        return json.dumps({\"name\": self.name})\n\n    def __str__(self) -> str:\n        return repr(self)", ""]}
{"filename": "kayak/ksql/__init__.py", "chunked_list": [""]}
