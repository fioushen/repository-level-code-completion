{"filename": "setup.py", "chunked_list": ["from setuptools import setup, find_packages\nsetup(\n    name='nlpeer',\n    version='0.1',\n    author=\"Ubiquitous Knowledge Processing Lab\",\n    author_email=\"nils.dycke@tu-darmstadt.de\",\n    description=\"Code utilities for loading NLPeer data and for running experiments.\",\n    long_description=\"README.md\",\n    packages=find_packages()\n)", "    packages=find_packages()\n)"]}
{"filename": "nlpeer/__init__.py", "chunked_list": ["import json\nimport logging\nimport os\nimport re\nfrom enum import Enum\nfrom os.path import join as pjoin\nfrom typing import Callable\n\nimport numpy as np\nfrom intertext_graph import IntertextDocument", "import numpy as np\nfrom intertext_graph import IntertextDocument\n\nfrom nlpeer.utils import list_dirs\n\nNTYPE_TITLE = \"title\"\nNTYPE_HEADING = \"heading\"\nNTYPE_PARAGRAPH = \"paragraph\"\nNTYPE_ABSTRACT = \"abstract\"\nNTYPE_LIST = \"list\"", "NTYPE_ABSTRACT = \"abstract\"\nNTYPE_LIST = \"list\"\nNTYPE_LIST_ITEM = \"list_item\"\nNYTPE_ELEMENT_REFERENCE = \"elem_reference\"\nNTYPE_BIB_REFERENCE = \"bib_reference\"\nNTYPE_HEADNOTE = \"headnote\"\nNTYPE_FOOTNOTE = \"footnote\"\nNTYPE_FIGURE = \"figure\"\nNTYPE_TABLE = \"table\"\nNTYPE_FORMULA = \"formula\"", "NTYPE_TABLE = \"table\"\nNTYPE_FORMULA = \"formula\"\nNTYPE_MEDIA = \"media\"\nNTYPE_BIB_ITEM = \"bib_item\"\n\nNTYPES = []\nNTYPES += [NTYPE_TITLE]\nNTYPES += [NTYPE_HEADING]\nNTYPES += [NTYPE_PARAGRAPH]\nNTYPES += [NTYPE_ABSTRACT]", "NTYPES += [NTYPE_PARAGRAPH]\nNTYPES += [NTYPE_ABSTRACT]\nNTYPES += [NTYPE_LIST]\nNTYPES += [NTYPE_LIST_ITEM]\nNTYPES += [NYTPE_ELEMENT_REFERENCE]\nNTYPES += [NTYPE_BIB_REFERENCE]\nNTYPES += [NTYPE_HEADNOTE]\nNTYPES += [NTYPE_FOOTNOTE]\nNTYPES += [NTYPE_FIGURE]\nNTYPES += [NTYPE_TABLE]", "NTYPES += [NTYPE_FIGURE]\nNTYPES += [NTYPE_TABLE]\nNTYPES += [NTYPE_FORMULA]\nNTYPES += [NTYPE_MEDIA]\nNTYPES += [NTYPE_BIB_ITEM]\n\n\nclass DATASETS(Enum):\n    ARR22 = \"ARR-22\"\n    F1000 = \"F1000\"\n    ACL17 = \"PeerRead-ACL2017\"\n    CONLL16 = \"PeerRead-CONLL2016\"\n    COLING20 = \"COLING2020\"", "\n\nclass PAPERFORMATS(Enum):\n    PDF = \".pdf\"\n    ITG = \".itg.json\"\n    GROBID = \".tei\"\n    XML = \".xml\"\n    TEX = \".tex\"\n\n\nclass ANNOTATION_TYPES(Enum):\n    ELINKS = \"elinks\", lambda pdir, ver: pjoin(pdir, f\"v{ver}\", \"elinks.json\")\n    ILINKS_RD = \"rd_ilinks\", lambda pdir, ver: pjoin(pdir, f\"v{ver}\", \"rd_ilinks.json\")\n    ELINKS_RD = \"rd_elinks\", lambda pdir, ver: pjoin(pdir, f\"v{ver}\", \"rd_elinks.json\")\n    DIFFS = \"diff\", lambda pdir, ver: pjoin(pdir, f\"diff_{ver}_{ver+1}.json\")\n    PRAG = \"rd_review_pragmatics\", lambda pdir, ver: pjoin(pdir, f\"v{ver}\", \"rd_review_pragmatics.json\")", "\n\nclass ANNOTATION_TYPES(Enum):\n    ELINKS = \"elinks\", lambda pdir, ver: pjoin(pdir, f\"v{ver}\", \"elinks.json\")\n    ILINKS_RD = \"rd_ilinks\", lambda pdir, ver: pjoin(pdir, f\"v{ver}\", \"rd_ilinks.json\")\n    ELINKS_RD = \"rd_elinks\", lambda pdir, ver: pjoin(pdir, f\"v{ver}\", \"rd_elinks.json\")\n    DIFFS = \"diff\", lambda pdir, ver: pjoin(pdir, f\"diff_{ver}_{ver+1}.json\")\n    PRAG = \"rd_review_pragmatics\", lambda pdir, ver: pjoin(pdir, f\"v{ver}\", \"rd_review_pragmatics.json\")\n\n", "\n\nDATASET_PAPERFORMATS = {\n    DATASETS.ARR22: [PAPERFORMATS.PDF, PAPERFORMATS.ITG, PAPERFORMATS.GROBID],\n    DATASETS.F1000: [PAPERFORMATS.PDF, PAPERFORMATS.ITG, PAPERFORMATS.XML],\n    DATASETS.ACL17: [PAPERFORMATS.PDF, PAPERFORMATS.ITG, PAPERFORMATS.GROBID],\n    DATASETS.CONLL16: [PAPERFORMATS.PDF, PAPERFORMATS.ITG, PAPERFORMATS.GROBID],\n    DATASETS.COLING20: [PAPERFORMATS.PDF, PAPERFORMATS.ITG, PAPERFORMATS.GROBID, PAPERFORMATS.TEX]\n}\n", "}\n\n\ndef arr_overall_to_score(oscore):\n    match = re.match(\"^\\d+\\.?\\d* ?=?\", oscore)\n    return float(oscore[0:match.span()[1] - 1].strip())\n\n\ndef f1000_overall_to_score(oscore):\n    if oscore == \"approve\":\n        return 2\n    elif oscore == \"approve-with-reservations\":\n        return 1\n    elif oscore == \"reject\":\n        return 0\n    else:\n        raise ValueError(\"Passed overall score does not exist in the F1000 dataset\")", "def f1000_overall_to_score(oscore):\n    if oscore == \"approve\":\n        return 2\n    elif oscore == \"approve-with-reservations\":\n        return 1\n    elif oscore == \"reject\":\n        return 0\n    else:\n        raise ValueError(\"Passed overall score does not exist in the F1000 dataset\")\n", "\n\nDATASET_REVIEW_OVERALL_SCALES = {\n    DATASETS.ARR22: (arr_overall_to_score, np.arange(1, 5 + 0.5, 0.5)),\n    DATASETS.F1000: (f1000_overall_to_score, np.arange(0, 3, 1)),\n    DATASETS.ACL17: (lambda x: int(x), np.arange(1, 5+1, 1)),\n    DATASETS.CONLL16: (lambda x: int(x), np.arange(1, 5+1, 1)),\n    DATASETS.COLING20: (lambda x: int(x), np.arange(1, 5+1, 1))\n}\n", "}\n\n\nclass PaperReviewDataset:\n    \"\"\"\n    Dataset of papers and reviews indexed by paper IDs.\n\n    \"\"\"\n    datapath = None\n    _dataset_type = None\n    paper_ids = []\n    paper_dirs = {}\n    index = 0\n    _version = None\n\n    cache = None\n\n    def __init__(self, base_path: str,\n                 dataset: DATASETS,\n                 version: int,\n                 paper_format:PAPERFORMATS=PAPERFORMATS.ITG,\n                 hold_in_memory:bool=True,\n                 preload:bool=False):\n        # get path\n        datapath = pjoin(base_path, dataset.value, \"data\")\n        assert os.path.exists(datapath), f\"The passed dataset does not exist in the given directory {datapath}\"\n\n        self.datapath = datapath\n        self._dataset_type = dataset\n        self._version = version\n\n        # warn on memory\n        assert not preload or hold_in_memory, \"Invalid configuration. Can only preload if holding in memory\"\n\n        if preload:\n            logging.info(f\"You are loading {dataset.name} completely into memory. For large datasets this is \"\n                         f\"discouraged.\")\n\n        # setup loader\n        self._setup(hold_in_memory, preload, version, paper_format)\n\n    @property\n    def dataset_type(self):\n        return self._dataset_type\n\n    @dataset_type.setter\n    def dataset_type(self, dataset_type):\n        self._dataset_type = dataset_type\n\n    @property\n    def version(self):\n        return self._version\n\n    @version.setter\n    def version(self, version):\n        self._version = version\n\n    def ids(self):\n        return [pid for pid in self.paper_ids]\n\n    def file_path(self):\n        return os.path.sep.join(self.datapath.split(os.path.sep)[:-2])\n\n    @staticmethod\n    def _get_version_dir(pdir, version):\n        vdir = pjoin(pdir, f\"v{version}\")\n        return vdir if os.path.exists(vdir) else None\n\n    def load(self, paper_dir):\n        paper_id = paper_dir.split(os.path.sep)[-2]\n\n        # get metadata\n        meta_path = pjoin(paper_dir, \"meta.json\")\n        assert os.path.exists(meta_path), f\"Path to paper metadata does not exist: {meta_path}\"\n\n        with open(meta_path, \"r\") as fp:\n            paper_meta = json.load(fp)\n\n        # get doc\n        if self.paper_format == PAPERFORMATS.ITG:\n            itg_path = pjoin(paper_dir, f\"paper{self.paper_format.value}\")\n            assert os.path.exists(itg_path), f\"Path to the ITG version of the paper does not exist: {itg_path}\"\n\n            with open(itg_path, \"r\") as fp:\n                paper = IntertextDocument.load_json(fp)\n        else:\n            raise ValueError(f\"Paper format {self.paper_format} is currently not supported for loading!\")\n\n        # get reviews\n        review_path = pjoin(paper_dir, \"reviews.json\")\n        assert os.path.exists(review_path), f\"Path to the reviews of the paper do not exist: {review_path}\"\n\n        with open(review_path, \"r\") as fp:\n            reviews = json.load(fp)\n\n        return paper_id, paper_meta, paper, reviews\n\n    def _setup(self, hold_in_memory, preload, version, paper_format):\n        paper_dirs = map(lambda x: PaperReviewDataset._get_version_dir(x, version), list_dirs(self.datapath))\n        paper_dirs = filter(lambda x: x is not None, paper_dirs)\n\n        # fill management vars\n        self.paper_dirs = dict([(pd.split(os.path.sep)[-2], pd) for pd in paper_dirs])\n        self.paper_ids = list(self.paper_dirs.keys())\n        self.paper_format = paper_format\n        self.cache = None\n        self.index = 0\n\n        # if all data should be loaded at once and held in memory, do so\n        if hold_in_memory:\n            if preload:\n                self.cache = {pid: self.load(pd) for pid, pd in paper_dirs}\n            else:\n                self.cache = {}\n\n    def __len__(self):\n        return len(self.paper_ids)\n\n    def __getitem__(self, idx):\n        if type(idx) == str:\n            assert idx in self.paper_ids, \"Passed paper ID string is not part of this dataset\"\n            pid = idx\n        elif type(idx) == int:\n            assert 0 <= idx < len(self.paper_ids), f\"Passed paper index {idx} is out of range\"\n            pid = self.paper_ids[idx]\n        elif type(idx) == list:\n            return [self[lx] for lx in idx]\n        else:\n            raise TypeError(f\"The passed index type {type(idx)} is not supported for this dataset\")\n\n        # with cached data\n        if self.cache is not None:\n            if pid in self.cache:\n                return self.cache[pid]\n            else:\n                self.cache[pid] = self.load(self.paper_dirs[pid])\n                return self.cache[pid]\n\n        # regular loading\n        return self.load(self.paper_dirs[pid])\n\n    def __next__(self):\n        self.index += 1\n\n        if self.index-1 >= len(self):\n            raise StopIteration()\n\n        return self[self.index-1]\n\n    def __iter__(self):\n        while True:\n            try:\n                yield next(self)\n            except StopIteration:\n                break\n\n        self.index = 0\n\n    def filter_paperwise(self, paperwise_filter: Callable):\n        matched_paper_ids = [paper[0] for paper in self if paperwise_filter(paper)]\n        non_matched_paper_ids = [pid for pid in self.paper_ids if pid not in matched_paper_ids]\n\n        self.paper_ids = matched_paper_ids\n        for nm in non_matched_paper_ids:\n            del self.paper_dirs[nm]\n\n            if self.cache is not None and nm in self.cache:\n                del self.cache[nm]\n\n        # just to be sure, reset as the index is invalid as of now\n        self.index = 0", "\n\nclass ReviewPaperDataset(PaperReviewDataset):\n    \"\"\"\n    Dataset of papers and reviews indexed by review IDs.\n    \"\"\"\n    review_ids = []\n    paperwise_review_ids = {}\n    force_hold_in_memory = False\n\n    def __init__(self, base_path: str, dataset: DATASETS, version: int, paper_format:PAPERFORMATS=PAPERFORMATS.ITG, hold_in_memory:bool=False, preload:bool=False):\n        # hold data in memory by default, but add an own cleaning strategy while loading by index\n        self.force_hold_in_memory = hold_in_memory\n\n        super().__init__(base_path, dataset, version, paper_format, True, preload)\n\n    def _setup(self, hold_in_memory, preload, version, paper_format):\n        # load file pointers as in the paper review dataset\n        super()._setup(hold_in_memory, preload, version, paper_format)\n\n        assert all(\"%\" not in pid for pid in self.paper_ids), \"There exist malformed paper ids. % is not permitted\"\n\n        # index the reviews\n        self.review_ids = []\n        self.paperwise_review_ids = {}\n        for pid in self.paper_ids:\n            pdir = self.paper_dirs[pid]\n            rfile = pjoin(pdir, \"reviews.json\")\n\n            with open(rfile, \"r\") as rfs:\n                new_rids = [f\"{pid}%{str(i)}\" for i in range(len(json.load(rfs)))]\n\n                self.paperwise_review_ids[pid] = self.paperwise_review_ids.get(pid, []) \\\n                                                 + [len(self.review_ids) + rid for rid in range(len(new_rids))]\n                self.review_ids += new_rids\n\n    def ids(self):\n        return [pid for pid in self.review_ids]\n\n    @staticmethod\n    def _review_wise_sample(data, review_num):\n        paper_id, paper_meta, paper, reviews = data\n\n        return paper_id, paper_meta, paper, review_num, reviews[review_num]\n\n    def __len__(self):\n        # override by review ids' length\n        return len(self.review_ids)\n\n    def __getitem__(self, idx):\n        # override to fetch by index on reviews\n        if type(idx) == str:\n            assert idx in self.review_ids, \"Passed review ID string is not part of this dataset\"\n            assert idx.count(\"%\") == 1, \"Passed review ID string is malformed. % is only allowed as a separator.\"\n            rid = idx\n        elif type(idx) == int:\n            assert 0 <= idx < len(self.review_ids), f\"Passed review index {idx} is out of range\"\n            rid = self.review_ids[idx]\n        elif type(idx) == list:\n            return [self[lx] for lx in idx]\n        else:\n            raise TypeError(f\"The passed index type {type(idx)} is not supported for this dataset\")\n\n        # determine pid and review number\n        pid, rnum = rid.split(\"%\")[0], int(rid.split(\"%\")[1])\n\n        # with cached data (always the case)\n        if pid in self.cache:\n            res = self._review_wise_sample(self.cache[pid], rnum)\n        else:\n            self.cache[pid] = self.load(self.paper_dirs[pid])\n            res = self._review_wise_sample(self.cache[pid], rnum)\n\n        # cache cleaning strategy: discard loaded papers if the rnum is the last one\n        if not self.force_hold_in_memory and rnum == len(self.cache[pid][3]):\n            del self.cache[pid]\n\n        # return result\n        return res\n\n    def filter_paperwise(self, paperwise_filter: Callable):\n        # filter paper ids, such that paper_ids only old the still permitted ones\n        # cache is cleared, too\n        matched_paper_ids, non_matched_paper_ids = [], []\n        for pid in self.paper_ids:\n            paper = super().__getitem__(pid)\n            if paperwise_filter(paper):\n                matched_paper_ids += [pid]\n            else:\n                non_matched_paper_ids += [pid]\n\n        self.paper_ids = matched_paper_ids\n        for nm in non_matched_paper_ids:\n            del self.paper_dirs[nm]\n\n            if self.cache is not None and nm in self.cache:\n                del self.cache[nm]\n\n        # get review ids to remove\n        reviewids_to_remove = [r for pid, revs in self.paperwise_review_ids.items() if pid in non_matched_paper_ids\n                                 for r in revs ]\n        for pid in non_matched_paper_ids:\n            del self.paperwise_review_ids[pid]\n\n        for rid in reviewids_to_remove:\n            self.review_ids.remove(rid)\n\n        # just to make sure, in case someone is iterating over this (index would be wrong now)\n        self.index = 0", "\n\nclass PaperReviewAnnotations:\n    \"\"\"\n    Extends a given paper review dataset by annotations according to the specified annotaiton type.\n\n    \"\"\"\n    cache = None\n\n    def __init__(self, annotation_type: ANNOTATION_TYPES, dataset: PaperReviewDataset):\n        base_path = dataset.file_path()\n\n        annopath = pjoin(base_path, dataset.dataset_type.value, \"annotations\")\n        assert os.path.exists(annopath), f\"The passed dataset does not exist in the given directory {annopath}\"\n\n        self.annopath = annopath\n        self._annotation_type = annotation_type\n\n        assert type(dataset) != ReviewPaperDataset, \"ReviewPaperDatasets not supported.\"\n        self.dataset = dataset\n\n        # setup loader\n        self._setup()\n\n        self.index = 0\n\n    def _setup(self):\n        version = self.dataset.version\n\n        anno_paper_dirs = list_dirs(self.annopath)\n        anno_paper_dirs = filter(lambda x: os.path.exists(self._annotation_type.value[1](x, version)), anno_paper_dirs)\n\n        # fill management vars\n        self.anno_paper_dirs = dict([(os.path.basename(pd), pd) for pd in anno_paper_dirs])\n        self.anno_pids = list(self.anno_paper_dirs.keys())\n        self._extract_annotations = lambda x: self._annotation_type.value[1](x, version)\n\n        self.cache = {}\n\n    def ids(self):\n        return self.anno_pids\n\n    def __len__(self):\n        return len(self.anno_paper_dirs)\n\n    def __getitem__(self, idx):\n        if type(idx) == str:\n            assert idx in self.anno_pids, \"Passed paper ID string is not part of this dataset\"\n            pid = idx\n        elif type(idx) == int:\n            assert 0 <= idx < len(self.anno_pids), f\"Passed paper index {idx} is out of range\"\n            pid = self.anno_pids[idx]\n        elif type(idx) == list:\n            return [self[lx] for lx in idx]\n        else:\n            raise TypeError(f\"The passed index type {type(idx)} is not supported for this dataset\")\n\n        d = self.dataset[pid]\n\n        # get annotation\n        if pid not in self.cache:\n            anno_path = self._extract_annotations(self.anno_paper_dirs[pid])\n            with open(anno_path, \"r\") as jf:\n                self.cache[pid] = json.load(jf)\n\n        return d, self.cache[pid]\n\n    def __next__(self):\n        self.index += 1\n\n        if self.index-1 >= len(self):\n            raise StopIteration()\n\n        return self[self.index-1]\n\n    def __iter__(self):\n        while True:\n            try:\n                yield next(self)\n            except StopIteration:\n                break\n\n        self.index = 0", "\n"]}
{"filename": "nlpeer/utils.py", "chunked_list": ["from os import walk, path\n\n\ndef list_files(dir_path, level=1):\n    for e in walk(dir_path):\n        level -= 1\n        if level > 0:\n            continue\n\n        files = [path.join(path.abspath(e[0]), f) for f in e[2]]\n        for f in files:\n            yield f\n        break", "\n\ndef list_dirs(dir_path, level=1):\n    for e in walk(dir_path):\n        level -= 1\n        if level > 0:\n            continue\n\n        files = [path.join(path.abspath(e[0]), f) for f in e[1]]\n        for f in files:\n            yield f\n        break", "\n\n"]}
{"filename": "nlpeer/data/__init__.py", "chunked_list": ["import json\nfrom collections import Counter\nfrom typing import Callable, Collection, List\n\nimport numpy as np\n\nimport sklearn.utils\nfrom sklearn.model_selection import train_test_split\n\nfrom nlpeer import DATASETS, PaperReviewDataset, ReviewPaperDataset", "\nfrom nlpeer import DATASETS, PaperReviewDataset, ReviewPaperDataset\nfrom nlpeer.utils import list_dirs\n\n\ndef filter_gte_x_reviews(dataset: PaperReviewDataset, x: int):\n    \"\"\"\n    Discards papers with less than x reviews.\n\n    :param dataset: dataset to be filtered\n    :param x: the threshold of min number of reviews\n    :return: void\n    \"\"\"\n    def gte0_reviews(paper_data):\n        paper_id, paper_meta, paper, reviews = paper_data\n\n        return len(reviews) >= x\n\n    dataset.filter_paperwise(gte0_reviews)", "\n\ndef load_splits_from_file(file_path: str, dataset_type: DATASETS = None):\n    \"\"\"\n    For a given dataset type and file path, loads the splits from file as lists of indexes.\n\n    :param file_path: path to the split file\n    :param dataset_type: type of the dataset to verify the split matches\n    :return: the list of splits\n    \"\"\"\n    with open(file_path, \"r\") as file:\n        split_data = json.load(file)\n\n    if dataset_type is not None:\n        assert split_data[\"dataset_type\"] == dataset_type.name, \\\n            f\"Mismatch of dataset types during loading. Expected {dataset_type}\"\n\n    return split_data[\"splits\"]", "\n\ndef store_splits_to_file(dataset: PaperReviewDataset, splits: Collection, out_path: str, random_gen):\n    \"\"\"\n    Stores the given splits for the given dataset to disk.\n\n    :param dataset: the dataset split by the given splits\n    :param splits: the list of split indexes\n    :param out_path: the output path to store the split\n    :param random_gen: random seed to store along\n    :return:\n    \"\"\"\n    jsplits = {\n        \"dataset_type\": dataset.dataset_type.name,\n        \"dataset\": dataset.__class__.__name__,\n        \"splits\": [\n            [[s, dataset.ids()[s]] for s in split] for split in splits\n        ],\n        \"random\": str(random_gen)\n    }\n\n    with open(out_path, \"w+\") as file:\n        json.dump(jsplits, file)", "\n\ndef paperwise_random_split(dataset: PaperReviewDataset, splits: List[float], random_seed: int):\n    \"\"\"\n    Splits the given dataset by papers with the given split proportions.\n    Automatically splits considering the distribution of reviews per paper for stratification.\n\n    :param dataset: dataset to be split\n    :param splits: the split proportions as a list of floats\n    :param random_seed: random seed for shuffling\n    :return: the splits\n    \"\"\"\n    # handle review paper datasets\n    if type(dataset) == ReviewPaperDataset:\n        reviews_per_paper = list(dataset.paperwise_review_ids.items())\n\n        def strat_criterion(rpp):\n            return len(rpp[1])\n\n        split_indices = paperwise_stratified_split(reviews_per_paper,\n                                                   splits,\n                                                   stratification_criterion=strat_criterion,\n                                                   random_seed=random_seed)\n\n        rid_splits = []\n        for split_i in split_indices:\n            covered_papers = [reviews_per_paper[i] for i in split_i]\n            rid_splits += [[ridx for pid, ridxs in covered_papers for ridx in ridxs]]\n        return rid_splits\n\n    # handle paper review datasets (split by paper proportions, that's it; ignore review proportions)\n    else:\n        # for consistency of randomness, we use the same method but without stratification\n        split_indices = paperwise_stratified_split(dataset, splits, stratification_criterion=None, random_seed=random_seed)\n\n        return [s.tolist() for s in split_indices]", "\n\ndef paperwise_stratified_split(dataset: Collection, splits: List[float], stratification_criterion: Callable, random_seed: int):\n    \"\"\"\n    Splits the given dataset by a stratification criterion given as function on papers.\n\n    :param dataset: the dataset to be split\n    :param splits: the split proportions\n    :param stratification_criterion: the callable stratification criterion mapping to discrete values\n    :param random_seed: random seed for shuffling\n    :return: the splits\n    \"\"\"\n    assert np.round(sum(splits), 1) == 1.0, f\"Split sizes need to add evenly to 1.0. Given sum: {sum(splits)}\"\n\n    # get \"class label\" for stratification\n    indices = np.arange(0, len(dataset))\n    if stratification_criterion is None:\n        strat_labels = np.array([\"nostrat\" for i in indices])\n    else:\n        strat_labels = np.array([stratification_criterion(s) for s in dataset])\n\n    # prep iterative splitting\n    out = []\n    to_split = (indices, strat_labels, 0)\n    split_further = None\n\n    # perform sequence of splits (until the last one, which is implied)\n    for original_split_size in splits[:-1]:\n        ixs, lbls, split_sofar = to_split\n\n        split_size = original_split_size / (1-split_sofar) if split_sofar > 0 else original_split_size\n\n        # lbl occurs only once: prohibited by scipy -- remove beforehand\n        single_label_instances = []\n        for l, c in Counter(lbls).items():\n            if c > 1:\n                continue\n            instances = lbls == l\n\n            single_label_instances += [ixs[instances][0]]\n            ixs = ixs[np.logical_not(instances)]\n            lbls = lbls[np.logical_not(instances)]\n\n        bi_split = train_test_split(ixs, test_size=split_size, stratify=lbls, random_state=random_seed)\n        split_further, split_done = bi_split[0], bi_split[1]\n\n        # add at random to one of the splits\n        if len(single_label_instances) > 0:\n            split_i = round(split_size*len(single_label_instances))\n\n            single_label_instances = sklearn.utils.shuffle(single_label_instances, random_state=random_seed)\n\n            split_further = np.append(split_further, single_label_instances[:split_i]).astype(int)\n            split_done = np.append(split_done, single_label_instances[split_i:]).astype(int)\n\n        out += [split_done]\n        to_split = (split_further, strat_labels[split_further], split_sofar + original_split_size)\n\n    # add left-over split\n    out += [split_further]\n\n    rout = []\n    for s in out:\n        rout += [sklearn.utils.shuffle(s)]\n\n    return rout", ""]}
{"filename": "nlpeer/data/create/__init__.py", "chunked_list": [""]}
{"filename": "nlpeer/data/create/clean.py", "chunked_list": ["import os\nimport re\nimport logging\nfrom io import BytesIO\n\nimport PyPDF2\nfrom PyPDF2 import PdfFileReader, PdfFileWriter\nfrom PyPDF2.generic import ContentStream, TextStringObject, NameObject, NumberObject\n\n", "\n\nline_num_matcher = re.compile(\"^\\d{3,4}$\")\n\n\ndef clean_pdf_draft(pdf_path, with_meta_data=False):\n    line_accu = 0\n\n    def _is_line_number(operands):\n        global line_num_matcher\n        nonlocal line_accu\n\n        text = operands[0][0]\n\n        if not isinstance(text, TextStringObject):\n            return False\n\n        if not line_num_matcher.match(text):\n            return False\n\n        lnum = int(text)\n        is_incremental = lnum == line_accu + 1\n        is_first = lnum == 0 and line_accu == 0\n\n        if not is_incremental and not is_first:\n            return False\n\n        line_accu = lnum\n        return True\n\n    def _is_author_information(operands):\n        if len(operands) != 1:\n            return False\n\n        return \"\".join([str(o) for o in operands[0] if isinstance(o, TextStringObject)]) == \"AnonymousACLsubmission\"\n\n    def _parse_lines(lines):\n        res = []\n        for line in lines:\n            line_number = str(line[0][0][0])\n            contents = [lii for l in line[1] for li in l for lii in li]\n\n            parsed = \"\"\n            for c in contents:\n                if type(c) == TextStringObject:\n                    parsed += str(c)\n                elif type(c) == NumberObject and int(c) < 0:\n                    parsed += \" \"\n\n            res += [(line_number, parsed)]\n        return res\n\n    out_dir = pdf_path[:-len(pdf_path.split(os.path.sep)[-1])]\n    out_path = os.path.join(out_dir, \"clean.pdf\")\n\n    try:\n        pdf_reader = PdfFileReader(pdf_path)\n    except PyPDF2.errors.PdfReadError as err:\n        if \"PDF starts with\" in str(err):\n            logging.info(\"Invalid PDF header format -- seeking a point of entry\")\n\n            with open(pdf_path, \"rb\") as bf:\n                b = bf.read(1024)\n                index = b.find(b\"%PDF-\")\n                if index == -1:\n                    raise err\n\n            with open(pdf_path, \"rb\") as bf:\n                bf.seek(index)\n                bstream = BytesIO(bf.read())\n\n            pdf_reader = PdfFileReader(bstream)\n        else:\n            raise err\n\n    pdf_writer = PdfFileWriter()\n\n    pages = []\n    lines = []\n    for page in pdf_reader.pages:\n        content_object = page[\"/Contents\"].getObject()\n        content = ContentStream(content_object, pdf_reader)\n\n        line_content = []\n        page_content = []\n\n        # Loop over all pdf elements\n        # source https://gist.github.com/668/2c8f936697ded94394ff4a6ffa4ae87e\n        to_delete = []\n        op_i = 0\n        first_line = True\n        for operands, operator in content.operations:\n            # You might adapt this part depending on your PDF file\n            # > Below the operators inferred from https://pypdf2.readthedocs.io/en/latest/_modules/PyPDF2/_page.html\n            # > Check PDF iso standard for actual and full list\n            #\n            # Tf = text font\n            # Tfs = text font size\n            # Tc = character spacing\n            # Th = horizontal scaling\n            # Tl = leading\n            # Tmode = text rendering mode\n            # Trise = text rise\n            # Tw = word spacing\n            # Tj, ', \", TJ = Text showing [the actual text]\n            # T* = text positioning\n            # ...\n            if operator == b\"TJ\":\n                if _is_line_number(operands):\n                    to_delete += [op_i]\n\n                    # first line of the page -- get the last entry in line_content as a content\n                    if first_line:\n                        page_content += [(operands, [line_content[-1]] if len(line_content) > 0 else [])]\n                        first_line = False\n                    else:\n                        page_content += [(operands, line_content)]\n\n                    line_content = []\n                elif _is_author_information(operands):\n                    to_delete += [op_i]\n                else:\n                    line_content += [operands]\n\n            op_i +=1\n\n        # delete elements from PDF\n        acc = 0\n        for d in sorted(to_delete):\n            del content.operations[d - acc]\n            acc += 1\n\n        # todo try setting the rendered pane to the covered subset in ACL pdfs to guarantee excluding of weird fields\n        #page.mediabox.upper_right = (page.mediabox.right / 2, page.mediabox.top / 2)\n\n        # Set the modified content as content object on the page\n        page.__setitem__(NameObject('/Contents'), content)\n\n        # parse the lines\n        page_content = _parse_lines(page_content)\n\n        # store page (start and end line) and lines\n        if len(page_content) > 0:\n            pages += [(page_content[0], page_content[-1])]\n            lines += page_content\n\n        # Add the page to the output\n        pdf_writer.addPage(page)\n\n    meta = {}\n    meta[\"num_pages\"] = len(pages)\n    meta[\"num_lines\"] = len(lines)\n    meta[\"lines\"] = lines\n    meta[\"pages\"] = pages\n\n    references_line = [l for l in lines if l[1].strip() == \"References\"]\n    if len(references_line) > 0 and len(references_line[0]) > 0:\n        meta[\"bib_page_index\"] = next(i for i, p in enumerate(pages) if int(p[0][0]) <= int(references_line[0][0]) <= int(p[1][0]))\n    else:\n        meta[\"bib_page_index\"] = None\n\n    # override document info to a default value\n    pdf_writer.add_metadata({\n        \"author\": \"Anonymous\",\n        \"author_raw\": \"Anonymous\"\n    })\n\n    # write to file\n    with open(out_path, \"wb\") as output_file:\n        pdf_writer.write(output_file)\n\n    # default warning for validation\n    if line_accu < 500:\n        logging.info(f\"WARNING: Encountered a very low number of lines ({line_accu} < 500) in {output_file}.\")\n\n    return meta"]}
{"filename": "nlpeer/data/create/utils.py", "chunked_list": ["import logging\nimport os\nimport re\nimport shutil\nfrom os.path import join as pjoin\n\nimport spacy\nfrom spacy import Language\nfrom spacy.symbols import  ORTH\nfrom intertext_graph.itsentsplitter import SpacySplitter", "from spacy.symbols import  ORTH\nfrom intertext_graph.itsentsplitter import SpacySplitter\n\n\nclass PDFProcessingError(BaseException):\n    def __init__(self, cause, ex=None):\n        self.cause = cause\n        self.underlying_exception = ex\n\n\ndef create_output_data_path(benchmark_dir_path, dataset_name):\n    out_path = pjoin(benchmark_dir_path, dataset_name)\n\n    if not os.path.exists(out_path):\n        logging.info(f\"Creating {out_path}\")\n        os.mkdir(out_path)\n\n    # create out path data\n    out_path = pjoin(out_path, \"data\")\n    if os.path.exists(out_path):\n        logging.info(f\"WARNING: Deleting old data directory {out_path}\")\n        shutil.rmtree(out_path)\n    os.mkdir(out_path)\n\n    return out_path", "\n\ndef create_output_data_path(benchmark_dir_path, dataset_name):\n    out_path = pjoin(benchmark_dir_path, dataset_name)\n\n    if not os.path.exists(out_path):\n        logging.info(f\"Creating {out_path}\")\n        os.mkdir(out_path)\n\n    # create out path data\n    out_path = pjoin(out_path, \"data\")\n    if os.path.exists(out_path):\n        logging.info(f\"WARNING: Deleting old data directory {out_path}\")\n        shutil.rmtree(out_path)\n    os.mkdir(out_path)\n\n    return out_path", "\n\ndef sentence_split_review(review, splitter=None):\n    if splitter is None:\n        splitter = SpacySplitter(spacy.load('en_core_sci_sm'))\n\n    res = {}\n    for field, text in review[\"report\"].items():\n        if text is not None:\n            res[field] = splitter.split(text)\n\n    review[\"meta\"][\"sentences\"] = res\n\n    return review", "\n\ndef get_review_sentences(review):\n    res = {}\n    for field, sents in review[\"meta\"][\"sentences\"].items():\n        txt = review[\"report\"][field]\n\n        res[field] = [txt[s[0]:s[1]] for s in sents]\n\n    return res", "\n\n@Language.component(\"linebreak_component\")\ndef _split_on_special_token(doc):\n    for token in doc[:-1]:\n        if token.text == \"<br>\":\n            doc[token.i + 1].is_sent_start = True\n\n    return doc\n", "\n\ndef clean_and_split_review(review):\n    # setup special splitting\n    def augmented_clean(txt):\n        res = txt.strip()  # strip unnecessary whitespaces\n\n        res = re.sub(r\"\\n{2,}\", \" <br> \", res)  # clear line break\n        res = re.sub(r\" <br> [*\\-] \", \" <br> - \", res)  # replaced line break with an itemize\n        res = re.sub(r\"\\n[*\\-] \", \" <br> - \", res)  # non-replaced line break with an itemize\n        res = re.sub(r\"^\\* \", \"- \", res)\n\n        return res\n\n    # splitter\n    nlp = spacy.load('en_core_sci_sm', exclude=[\"ner\", \"tagger\", \"parser\", \"lemmatizer\"])\n    nlp.add_pipe(\"sentencizer\")\n\n    nlp.tokenizer.add_special_case(\"<br>\", [{ORTH: \"<br>\"}])\n    nlp.add_pipe(\"linebreak_component\", name=\"linebreaking\", first=True)\n\n    sentences = {}\n    report = {}\n    for field, text in review[\"report\"].items():\n        if text is not None:\n            cleaned = augmented_clean(text)\n            processed = nlp(cleaned)\n\n            # get sentences and replace the <br> parts by actual line breaks\n            new_text = [s.text for s in processed.sents]\n            for i, t in enumerate(new_text):\n                if t == \"<br>\" and i > 0:\n                    new_text[i-1] = new_text[i-1] + \"\\n\"\n\n            # update sentences to exclude <br> ones and replace any br left in a sentence\n            new_text = [t.replace(\"<br>\", \"\") for t in new_text if t != \"<br>\"]\n\n            # if line breaks do not occur at the beginning or ending of a sentence, they should be discarded\n            tmp = []\n            for t in new_text:\n                if len(t) > 1:\n                    e = t[0]+ t[1:-1].replace(\"\\n\", \" \") + t[-1]\n                else:\n                    e = t\n\n                if e[-1] not in [\" \", \"\\n\", \"\\t\"]:\n                    e += \" \"\n\n                tmp += [e]\n\n            new_text = tmp\n            report[field] = \"\".join(new_text)\n\n            sentences[field] = []\n            ix = 0\n            for s in new_text:\n                sentences[field] += [(ix, ix+len(s))]\n                ix += len(s)\n\n    review[\"meta\"][\"sentences\"] = sentences\n    review[\"report\"] = report\n\n    return review"]}
{"filename": "nlpeer/data/create/parse.py", "chunked_list": ["import copy\nimport logging\nfrom copy import deepcopy\nfrom typing import Any, Optional, Tuple, List, Dict\nfrom xml.etree import ElementTree\n\nimport os.path\n\nfrom grobid_client.grobid_client import GrobidClient, ServerUnavailableException\nfrom intertext_graph.itgraph import IntertextDocument, Node, Edge, Etype, SpanNode", "from grobid_client.grobid_client import GrobidClient, ServerUnavailableException\nfrom intertext_graph.itgraph import IntertextDocument, Node, Edge, Etype, SpanNode\nfrom intertext_graph.itsentsplitter import SentenceSplitter, IntertextSentenceSplitter, make_sentence_nodes\nfrom intertext_graph.parsers.f1000_xml_parser import F1000XMLParser\nfrom intertext_graph.parsers.itparser import IntertextParser\n\n#\n# Constants\n#\n", "#\n\n\n# GROBID\nfrom lxml import etree\n\nfrom nlpeer import NTYPES, NTYPE_TITLE, NTYPE_HEADING, NTYPE_PARAGRAPH, NTYPE_ABSTRACT, NTYPE_LIST, NTYPE_LIST_ITEM, \\\n    NYTPE_ELEMENT_REFERENCE, NTYPE_BIB_REFERENCE, NTYPE_HEADNOTE, NTYPE_FOOTNOTE, NTYPE_FIGURE, NTYPE_TABLE, \\\n    NTYPE_FORMULA, NTYPE_MEDIA, NTYPE_BIB_ITEM\n", "    NTYPE_FORMULA, NTYPE_MEDIA, NTYPE_BIB_ITEM\n\nGROBID_CONF = {}\nGROBID_HOST = os.environ.get(\"GROBID_HOST\")\nif GROBID_HOST:\n    GROBID_CONF[\"grobid_server\"] = GROBID_HOST\nGROBID_PORT = os.environ.get(\"GROBID_PORT\")\nif GROBID_PORT:\n    GROBID_CONF[\"grobid_port\"] = GROBID_PORT\n", "\n# todo: currently the bibliography is not parsed as part of the text, but as isolated nodes. Might make sense to add!\n\n#\n# Classes\n#\n\n\nclass TEIXMLParser(IntertextParser):\n    \"\"\"\n    Parser to transform a TEI XML document into an IntertextDocument.\n\n    Author: Nils Dycke\n    Co-author: Jan-Micha Bodensohn (scaffolding and base paragraph parser)\n    \"\"\"\n\n    def __init__(self, xml_file_path: str):\n        \"\"\"\n        Initialize the TEIXMLParser for a particular paper.\n\n        :param xml_file_path: filepath of the TEI XML file (GROBID output)\n        \"\"\"\n        super(TEIXMLParser, self).__init__(xml_file_path)\n        self._xml_file_path: str = xml_file_path\n\n    def __call__(self) -> IntertextDocument:\n        \"\"\"\n        Parse the TEI XML document into an IntertextDocument.\n\n        :return: the IntertextDocument\n        \"\"\"\n        return self._parse_document()\n\n    @classmethod\n    def _batch_func(cls, path: Any) -> Any:\n        raise NotImplementedError  # TODO: implement this\n\n    @staticmethod\n    def _parse_section_content(section, prefix):\n        sub_graph = IntertextDocument([], [], prefix)\n        graph_refs = []\n        figures = {}\n\n        # add artificial root node\n        root = Node(\"root\", ntype=NTYPE_TITLE)\n        sub_graph.add_node(root)\n\n        predecessor = root\n        list_parent = None\n        for child in section:\n            # add paragraphs\n            if child.tag == f\"{prefix}p\":\n                paragraph = child\n\n                # get text\n                paragraph_text, children_ix = TEIXMLParser._flatten_xml_element_with_child_ix(paragraph)\n                TEIXMLParser._check_text(paragraph_text, \"paragraph\")\n\n                # get references in text\n                reference_ixs = [(t, pre_ix, pre_ix + contl) for (t, pre_ix, contl) in children_ix if\n                                 t.tag == f\"{prefix}ref\"]\n\n                # ACL layout specific --> lists start with bulletpoints\n                if paragraph_text[0] == \"\\u2022\":\n                    if list_parent is None:\n                        list_parent = TEIXMLParser._add_node(sub_graph, \"\", NTYPE_LIST, predecessor=predecessor,\n                                                             parent=root)\n                        predecessor = list_parent\n                    li = TEIXMLParser._add_node(sub_graph, paragraph_text, NTYPE_LIST_ITEM, predecessor=predecessor,\n                                                parent=list_parent)\n                    predecessor = li\n                else:\n                    if list_parent is not None:\n                        # no list type paragraph any more: erase existing list parent\n                        list_parent = None\n\n                    p = TEIXMLParser._add_node(sub_graph, paragraph_text, NTYPE_PARAGRAPH, predecessor=predecessor,\n                                               parent=root)\n                    predecessor = p\n\n                if len(reference_ixs) > 0:\n                    graph_refs += [(predecessor, reference_ixs)]\n\n            elif child.tag == f\"{prefix}figure\":\n                fxid, figure = TEIXMLParser._parse_figure(sub_graph, child, prefix, predecessor, root)\n                predecessor = figure\n                figures[fxid] = figure\n            elif child.tag == f\"{prefix}head\":\n                # head -- ignoring them\n                pass\n            elif child.tag == f\"{prefix}formula\":\n                # get text\n                formula_text = TEIXMLParser._flatten_xml_element(child)\n                TEIXMLParser._check_text(formula_text, \"formula\")\n\n                p = TEIXMLParser._add_node(sub_graph, formula_text, NTYPE_FORMULA, predecessor=predecessor, parent=root)\n                predecessor = p\n            else:\n                # add the rest\n                logging.info(f\"UNKNOWN TAG {section.tag} within section -- adding as flattend version.\")\n                paragraph_text, children_ix = TEIXMLParser._flatten_xml_element_with_child_ix(child)\n                TEIXMLParser._check_text(paragraph_text, \"paragraph\")\n\n                # get references in text\n                reference_ixs = [(t, pre_ix, pre_ix + contl) for (t, pre_ix, contl) in children_ix if\n                                 t.tag == f\"{prefix}ref\"]\n\n                p = TEIXMLParser._add_node(sub_graph, paragraph_text, NTYPE_PARAGRAPH, predecessor=predecessor,\n                                           parent=root)\n                predecessor = p\n\n                if len(reference_ixs) > 0:\n                    graph_refs += [(predecessor, reference_ixs)]\n\n        return sub_graph, predecessor, graph_refs, figures\n\n    def _parse_abstract(self, doc, abstract, prefix, predecessor, article_title):\n        abstract_title = self._add_node(doc, \"Abstract\", NTYPE_ABSTRACT, predecessor=predecessor, parent=article_title)\n        predecessor = abstract_title\n\n        if abstract is None:\n            return abstract_title, predecessor\n\n        content = \"\"\n        merge = False\n        for child in abstract:\n            # get text (including any possible children)\n            text = self._flatten_xml_element(child)\n            self._check_text(text, \"abstract paragraph\")\n\n            content += text\n\n            if child.tag != f\"{prefix}p\":\n                # if non-paragraph, treat as hick-up by GROBID and append to content of next node and force merge\n                logging.info(f\"Unexpected paragraph tag '{child.tag}' in the abstract! Treating as in-line text.\")\n\n                merge = True\n                content += \" \"\n            elif merge and predecessor.ntype == NTYPE_PARAGRAPH:\n                # if a previous element was erroneously inserted, merge this paragraph with the previous one\n                predecessor.content += \" \" + text\n\n                merge = False\n                content = \"\"\n            else:\n                # no merging required or cannot merge with previous node: simply add a new one with all content\n                predecessor = self._add_node(doc, content, NTYPE_PARAGRAPH, predecessor=predecessor,\n                                             parent=abstract_title)\n\n                merge = False\n                content = \"\"\n\n        # if there is still content left (no paragraph follows a hick-up)\n        if len(content) > 0:\n            predecessor = self._add_node(doc, content.strip(), NTYPE_PARAGRAPH, predecessor=predecessor,\n                                         parent=abstract_title)\n\n        return abstract_title, predecessor\n\n    @staticmethod\n    def _parse_figure(doc, figure, prefix, predecessor, parent):\n        head = figure.find(f\"{prefix}head\")\n        label = figure.find(f\"{prefix}label\")\n        xid = figure.get('{http://www.w3.org/XML/1998/namespace}id')\n        figDesc = figure.find(f\"{prefix}figDesc\")\n\n        if head is None:\n            return None, None\n\n        if \"type\" in figure.attrib and figure.attrib[\"type\"] == \"table\":\n            table = figure.find(f\"{prefix}table\")\n\n            table_node = TEIXMLParser._add_node(doc,\n                                                head.text if head.text is not None else \"\",\n                                                NTYPE_TABLE,\n                                                meta={\"label\": label.text if label is not None else None,\n                                                      \"id\": xid,\n                                                      \"caption\": figDesc.text if figDesc is not None else None},\n                                                predecessor=predecessor,\n                                                parent=parent)\n            predecessor = table_node\n\n            table_content = TEIXMLParser._add_node(doc,\n                                                   str(ElementTree.tostring(table)),\n                                                   NTYPE_MEDIA,\n                                                   meta={},\n                                                   predecessor=predecessor,\n                                                   parent=table_node)\n            predecessor = table_content\n        else:\n            graphic = figure.find(f\"{prefix}graphic\")\n\n            figure_node = TEIXMLParser._add_node(doc,\n                                                 head.text if head.text is not None else \"\",\n                                                 NTYPE_FIGURE,\n                                                 meta={\"label\": label.text if label is not None else None,\n                                                       \"id\": xid,\n                                                       \"caption\": figDesc.text if figDesc is not None else None},\n                                                 predecessor=predecessor,\n                                                 parent=parent)\n            predecessor = figure_node\n\n            figure_content = TEIXMLParser._add_node(doc,\n                                                    TEIXMLParser._flatten_xml_element(graphic) if graphic else \"\",\n                                                    NTYPE_MEDIA,\n                                                    meta={},\n                                                    predecessor=predecessor,\n                                                    parent=figure_node)\n            predecessor = figure_content\n\n        return xid, predecessor\n\n    @staticmethod\n    def _parse_bibitem(bib_item, prefix):\n        xid = bib_item.get('{http://www.w3.org/XML/1998/namespace}id')\n        publishing_info = bib_item.find(f\"{prefix}monogr\")\n        paper_info = bib_item.find(f\"{prefix}analytic\")\n\n        # parse publishing information\n        if publishing_info:\n            pub_title = publishing_info.find(f\"{prefix}title\")\n            pub_title = pub_title.text if pub_title is not None else None\n\n            pub = publishing_info.find(f\"{prefix}imprint/{prefix}publisher\")\n            pub = pub.text if pub is not None else None\n\n            pub_date = publishing_info.find(f\"{prefix}imprint/{prefix}date\")\n            pub_date = pub_date.attrib[\"when\"] if pub_date is not None and \"when\" in pub_date.attrib else None\n        else:\n            pub_title = None\n            pub = None\n            pub_date = None\n\n        # add paper information if present\n        if paper_info:\n            title = paper_info.find(f\"{prefix}title\")\n            title = title.text if title is not None else None\n\n            authors = paper_info.findall(f\"{prefix}author/{prefix}persName\")\n\n            author_names = []\n            for a in authors:\n                forename = a.find(f'{prefix}forename')\n                surname = a.find(f'{prefix}surname')\n                canonical_author = f\"{forename.text if forename is not None else ''} {surname.text if surname is not None else ''}\"\n\n                author_names += [canonical_author] if len(canonical_author) > 0 else []\n        else:\n            title = None\n            author_names = None\n\n        return xid, title, author_names, pub_title, pub, pub_date\n\n    @staticmethod\n    def _flatten_xml_element(element):\n        stack = [(element, -1, None)]\n\n        while True:\n            elem, pred, content = stack.pop(-1)\n\n            # visiting node the first time\n            if content is None:\n                content = elem.text if elem.text else \"\"\n\n                # revisit element after children\n                stack += [(elem, pred, content)]\n\n                # add children\n                stack += reversed([(child, len(stack) - 1, None) for child in elem])\n            else:\n                # revisiting the node (content is set)\n                suffix = elem.tail if elem.tail else \"\"\n\n                if pred >= 0:\n                    pre_elem, pre_pred, pre_content = stack[pred]\n                    stack[pred] = (pre_elem, pre_pred, pre_content + content + suffix)\n                else:\n                    # terminating at parent most element\n                    return content + suffix\n\n                # don't add to stack again\n        # should always terminate\n\n    @staticmethod\n    def _flatten_xml_element_with_child_ix(element):\n        # xml element, predecessor ix, pred. merged ixs, parsed content\n        stack = [(element, -1, [], None)]\n\n        while True:\n            elem, pred, mergedix, content = stack.pop(-1)\n\n            # visiting node the first time\n            if content is None:\n                content = elem.text if elem.text else \"\"\n\n                # revisit element after children\n                stack += [(elem, pred, mergedix, content)]\n\n                # add children\n                stack += reversed([(child, len(stack) - 1, [], None) for child in elem])\n            else:\n                # revisiting the node (content is set)\n                suffix = elem.tail if elem.tail else \"\"\n\n                if pred >= 0:\n                    pre_elem, pre_pred, pre_mergedix, pre_content = stack[pred]\n\n                    new_mergedix = pre_mergedix + \\\n                                   [(elem, len(pre_content), len(content))] + \\\n                                   [(t, prel + len(pre_content), contl) for (t, prel, contl) in mergedix]\n\n                    stack[pred] = (pre_elem, pre_pred, new_mergedix, pre_content + content + suffix)\n                else:\n                    # terminating at parent most element\n                    return content + suffix, mergedix\n\n                # don't add to stack again\n        # should always terminate\n\n    @staticmethod\n    def _add_node(doc, content, ntype, meta=None, predecessor=None, parent=None):\n        new_node = Node(\n            content=content,\n            ntype=ntype,\n            meta=meta\n        )\n        doc.add_node(new_node)\n\n        if parent is not None:\n            parent_edge = Edge(\n                src_node=parent,\n                tgt_node=new_node,\n                etype=Etype.PARENT\n            )\n            doc.add_edge(parent_edge)\n\n        if predecessor is not None:\n            next_edge = Edge(\n                src_node=predecessor,\n                tgt_node=new_node,\n                etype=Etype.NEXT\n            )\n            doc.add_edge(next_edge)\n\n        return new_node\n\n    @staticmethod\n    def _add_subtree(doc, subTree, lastSubTree, targetParent, targetPredecessor):\n        # add nodes\n        new_nodes = {}\n        for n in subTree.nodes:\n            new_n = TEIXMLParser._add_node(doc, n.content, n.ntype, n.meta)\n            new_nodes[n.ix] = new_n\n\n        # add edges\n        for e in subTree.edges:\n            new_e = Edge(\n                src_node=new_nodes[e.src_node.ix],\n                tgt_node=new_nodes[e.tgt_node.ix],\n                etype=e.etype\n            )\n            doc.add_edge(new_e)\n\n        # get pseudo root and replace parent edges\n        new_pseudo_root = new_nodes[subTree.root.ix]\n        for ce in new_pseudo_root.get_edges(Etype.PARENT, outgoing=True, incoming=False):\n            new_parent = Edge(\n                src_node=targetParent,\n                tgt_node=ce.tgt_node,\n                etype=Etype.PARENT\n            )\n            doc.add_edge(new_parent)\n            doc.remove_edge(ce)\n\n        # if no other nodes except root: skip the next part\n        new_pseudo_next_edges = new_pseudo_root.get_edges(Etype.NEXT, outgoing=True, incoming=False)\n        if len(new_pseudo_next_edges) > 0:\n            new_pseudo_next = new_pseudo_next_edges[0]\n            new_next = Edge(\n                src_node=targetPredecessor,\n                tgt_node=new_pseudo_next.tgt_node,\n                etype=Etype.NEXT\n            )\n            doc.add_edge(new_next)\n            doc.remove_edge(new_pseudo_next)\n\n        doc.remove_node(new_pseudo_root)\n\n        # output\n        start_subtree = targetParent\n        end_subtree = new_nodes[lastSubTree.ix] if len(new_pseudo_next_edges) > 0 else None\n\n        return start_subtree, end_subtree, new_nodes\n\n    def _parse_document(self) -> IntertextDocument:\n        \"\"\"\n        Parse the given TEI XML document.\n\n        :return: resulting IntertextDocument\n        \"\"\"\n        # create intertext document\n        prefix = self._xml_file_path.split(os.path.sep)[-1]\n\n        itg_doc = IntertextDocument(\n            nodes=[],\n            edges=[],\n            prefix=prefix\n        )\n\n        # the content of the document is completely derived from the TEI XML file\n        tree = ElementTree.parse(self._xml_file_path)\n        prefix = \"{http://www.tei-c.org/ns/1.0}\"\n\n        # create article title as root\n        title = tree.getroot().find(f\"{prefix}teiHeader/{prefix}fileDesc/{prefix}titleStmt/{prefix}title\").text\n        title = title if title is not None else \"\"\n        article_title_node = self._add_node(itg_doc, title, NTYPE_TITLE)\n        predecessor = article_title_node\n\n        #\n        # PARSE THE ABSTRACT\n        #\n        abstract = tree.getroot().find(f\"{prefix}teiHeader/{prefix}profileDesc/{prefix}abstract/{prefix}div\")\n        abstract_title_node, predecessor = self._parse_abstract(itg_doc, abstract, prefix, predecessor,\n                                                                article_title_node)\n\n        #\n        # PARSE BODY\n        #\n        body = tree.getroot().find(f\"{prefix}text/{prefix}body\")\n\n        body_refs = []\n        body_figs = {}\n        content_graph = []\n        last_section_title = []\n        for section in body.findall(f\"{prefix}div\"):\n            content, last_elem, refs, figures = self._parse_section_content(section, prefix)\n\n            head = section.find(f\"{prefix}head\")\n            if head is None:\n                logging.info(f\"Div without a heading in {self._xml_file_path}.\")\n\n            # empty section\n            if len(content.edges) == 0 and len(content.nodes) <= 1 and head is None:\n                logging.info(f\"Encountered empty section in {self._xml_file_path}.\")\n\n            content_graph += [(content, last_elem, refs, figures)]\n\n            # fixme currently erroneous head nodes (e.g. with text, but without number) are discarded entirely\n            if head is not None and \"n\" in head.attrib:\n                # pop current content\n                current_content, current_last, current_refs, current_figures = content_graph.pop(-1)\n\n                # add previous contents to the predecessor if existent, else create a dummy section first\n                if len(content_graph) > 0:\n                    if len(last_section_title) == 0:\n                        dummy_node = self._add_node(itg_doc, \"\", NTYPE_HEADING, {\"section\": \"1\"},\n                                                    predecessor=article_title_node, parent=article_title_node)\n                        last_section_title += [dummy_node]\n                        predecessor = dummy_node\n\n                    pred_parent = last_section_title[-1]\n                    for c, l, r, f in content_graph:\n                        sub_root, sub_last, node_map = self._add_subtree(itg_doc, c, l, pred_parent, predecessor)\n                        predecessor = sub_last if sub_last is not None else predecessor\n\n                        mapped_refs = [(node_map[n.ix], ref) for n, ref in r]\n                        body_refs += mapped_refs\n\n                        mapped_figs = {fxid: node_map[fig.ix] for fxid, fig in f.items()}\n                        body_figs.update(mapped_figs)\n\n                    # reset content stack -- added all previous contents\n                    content_graph = []\n\n                # get section name and number\n                section_name = head.text\n                section_n = head.attrib[\"n\"]\n                self._check_text(section_name, \"section title\")\n\n                # find parent node\n                section_parent_node = None\n                if len(last_section_title) == 0:\n                    # is first section\n                    section_parent_node = article_title_node\n                else:\n                    for st in last_section_title:\n                        st_n = st.meta[\"section\"]\n\n                        if self._is_child_section_count(section_n, st_n):\n                            section_parent_node = st\n                            break\n\n                    if section_parent_node is None:\n                        section_parent_node = article_title_node\n\n                # add new section title with content\n                section_title_node = self._add_node(itg_doc,\n                                                    section_name,\n                                                    NTYPE_HEADING,\n                                                    {\"section\": section_n},\n                                                    predecessor=predecessor,\n                                                    parent=section_parent_node)\n                predecessor = section_title_node\n                last_section_title += [section_title_node]\n\n                sub_root, sub_last, node_map = self._add_subtree(itg_doc, current_content, current_last,\n                                                                 section_title_node,\n                                                                 predecessor)\n                predecessor = sub_last if sub_last is not None else predecessor\n\n                mapped_refs = [(node_map[n.ix], r) for n, r in refs]\n                body_refs += mapped_refs\n\n                mapped_figs = {fxid: node_map[fig.ix] for fxid, fig in current_figures.items()}\n                body_figs.update(mapped_figs)\n\n        # add left-over content-graph elements\n        if len(content_graph) > 0:\n            if len(last_section_title) == 0:\n                dummy_node = self._add_node(itg_doc, \"\", NTYPE_HEADING, {\"section\": \"1\"},\n                                            predecessor=article_title_node, parent=article_title_node)\n                last_section_title += [dummy_node]\n                predecessor = dummy_node\n\n            pred_parent = last_section_title[-1]\n            for c, l, r, f in content_graph:\n                sub_root, sub_last, node_map = self._add_subtree(itg_doc, c, l, pred_parent, predecessor)\n                predecessor = sub_last if sub_last is not None else predecessor\n\n                mapped_refs = [(node_map[n.ix], ref) for n, ref in r]\n                body_refs += mapped_refs\n\n                mapped_figs = {fxid: node_map[fig.ix] for fxid, fig in f.items()}\n                body_figs.update(mapped_figs)\n\n        for figure in body.findall(f\"{prefix}figure\"):\n            fxid, figure_node = self._parse_figure(itg_doc, figure, prefix, predecessor, article_title_node)\n            predecessor = figure_node\n            body_figs[fxid] = figure_node\n\n        #\n        ## PARSE BACK MATTER\n        #\n        back = tree.getroot().find(f\"{prefix}text/{prefix}back\")\n\n        bibliography = {}\n        for bib_item in back.findall(f\"{prefix}div/{prefix}listBibl/{prefix}biblStruct\"):\n            xid, title, authors, pub_title, pub, pub_date = self._parse_bibitem(bib_item, prefix)\n\n            bib_node = self._add_node(itg_doc, f\"{', '.join(authors) if authors is not None else 'UNKNOWN'}, \"\n                                               f\"{title}, \"\n                                               f\"{pub_date if pub_date else ''}, \"\n                                               f\"{pub_title if pub_title else ''}, \"\n                                               f\"{pub if pub else ''}.\",\n                                      ntype=NTYPE_BIB_ITEM,\n                                      meta={\"xid\": xid,\n                                            \"authors\": authors,\n                                            \"title\": title,\n                                            \"pub_date\": pub_date,\n                                            \"pub_title\": pub_title,\n                                            \"pub\": pub})\n            bibliography[xid] = bib_node\n\n        #\n        ## ADD REFERENCES\n        #\n        for node, refs in body_refs:\n            for r in refs:\n                xml_elem, start, end = r\n                rtype = xml_elem.attrib[\"type\"]\n\n                # skip invalid references with missing target (for now)\n                if \"target\" not in xml_elem.attrib:\n                    continue\n\n                rtarget = xml_elem.attrib[\"target\"][1:]\n\n                # add span node\n                ref_node = SpanNode(\n                    ntype=NTYPE_BIB_REFERENCE if rtype == \"bibr\" else NYTPE_ELEMENT_REFERENCE,\n                    src_node=node,\n                    start=start,\n                    end=end,\n                    meta={\"from_xml_type\": rtype, \"from_xml_target\": rtarget}\n                )\n                itg_doc.add_node(ref_node)\n\n                # add link (where possible)\n                target_node = None\n                if rtype == \"bibr\" and rtarget in bibliography:\n                    target_node = bibliography[rtarget]\n                elif (rtype == \"figure\" or rtype == \"table\") and target_node in body_figs:\n                    target_node = body_figs[rtarget]\n\n                if target_node:\n                    link = Edge(ref_node, target_node, etype=Etype.LINK)\n                    itg_doc.add_edge(link)\n\n        return itg_doc\n\n    @staticmethod\n    def _check_text(text: str, element_name: str) -> str:\n        assert isinstance(text, str), f\"{element_name} is not a string, but a {type(text)}!\"\n        return text\n\n    @staticmethod\n    def _compare_section_counts(cntA: str, cntB: str) -> int:\n        nAs = cntA.split(\".\")\n        nBs = cntB.split(\".\")\n\n        for i, nA in enumerate(nAs):\n            if len(nBs) <= i:\n                return 1  # b higher level than a (a > b)\n            nB = nBs[i]\n            if int(nA) != int(nB):\n                return -1 if int(nA) < int(nB) else 1  # a earlier than b (a < b)\n\n        return 0 if len(nAs) == len(nBs) else -1  # a higher level than b (a < b), else equal\n\n    @staticmethod\n    def _is_child_section_count(cntA: str, cntB: str) -> bool:\n        return cntA.startswith(cntB)", "class TEIXMLParser(IntertextParser):\n    \"\"\"\n    Parser to transform a TEI XML document into an IntertextDocument.\n\n    Author: Nils Dycke\n    Co-author: Jan-Micha Bodensohn (scaffolding and base paragraph parser)\n    \"\"\"\n\n    def __init__(self, xml_file_path: str):\n        \"\"\"\n        Initialize the TEIXMLParser for a particular paper.\n\n        :param xml_file_path: filepath of the TEI XML file (GROBID output)\n        \"\"\"\n        super(TEIXMLParser, self).__init__(xml_file_path)\n        self._xml_file_path: str = xml_file_path\n\n    def __call__(self) -> IntertextDocument:\n        \"\"\"\n        Parse the TEI XML document into an IntertextDocument.\n\n        :return: the IntertextDocument\n        \"\"\"\n        return self._parse_document()\n\n    @classmethod\n    def _batch_func(cls, path: Any) -> Any:\n        raise NotImplementedError  # TODO: implement this\n\n    @staticmethod\n    def _parse_section_content(section, prefix):\n        sub_graph = IntertextDocument([], [], prefix)\n        graph_refs = []\n        figures = {}\n\n        # add artificial root node\n        root = Node(\"root\", ntype=NTYPE_TITLE)\n        sub_graph.add_node(root)\n\n        predecessor = root\n        list_parent = None\n        for child in section:\n            # add paragraphs\n            if child.tag == f\"{prefix}p\":\n                paragraph = child\n\n                # get text\n                paragraph_text, children_ix = TEIXMLParser._flatten_xml_element_with_child_ix(paragraph)\n                TEIXMLParser._check_text(paragraph_text, \"paragraph\")\n\n                # get references in text\n                reference_ixs = [(t, pre_ix, pre_ix + contl) for (t, pre_ix, contl) in children_ix if\n                                 t.tag == f\"{prefix}ref\"]\n\n                # ACL layout specific --> lists start with bulletpoints\n                if paragraph_text[0] == \"\\u2022\":\n                    if list_parent is None:\n                        list_parent = TEIXMLParser._add_node(sub_graph, \"\", NTYPE_LIST, predecessor=predecessor,\n                                                             parent=root)\n                        predecessor = list_parent\n                    li = TEIXMLParser._add_node(sub_graph, paragraph_text, NTYPE_LIST_ITEM, predecessor=predecessor,\n                                                parent=list_parent)\n                    predecessor = li\n                else:\n                    if list_parent is not None:\n                        # no list type paragraph any more: erase existing list parent\n                        list_parent = None\n\n                    p = TEIXMLParser._add_node(sub_graph, paragraph_text, NTYPE_PARAGRAPH, predecessor=predecessor,\n                                               parent=root)\n                    predecessor = p\n\n                if len(reference_ixs) > 0:\n                    graph_refs += [(predecessor, reference_ixs)]\n\n            elif child.tag == f\"{prefix}figure\":\n                fxid, figure = TEIXMLParser._parse_figure(sub_graph, child, prefix, predecessor, root)\n                predecessor = figure\n                figures[fxid] = figure\n            elif child.tag == f\"{prefix}head\":\n                # head -- ignoring them\n                pass\n            elif child.tag == f\"{prefix}formula\":\n                # get text\n                formula_text = TEIXMLParser._flatten_xml_element(child)\n                TEIXMLParser._check_text(formula_text, \"formula\")\n\n                p = TEIXMLParser._add_node(sub_graph, formula_text, NTYPE_FORMULA, predecessor=predecessor, parent=root)\n                predecessor = p\n            else:\n                # add the rest\n                logging.info(f\"UNKNOWN TAG {section.tag} within section -- adding as flattend version.\")\n                paragraph_text, children_ix = TEIXMLParser._flatten_xml_element_with_child_ix(child)\n                TEIXMLParser._check_text(paragraph_text, \"paragraph\")\n\n                # get references in text\n                reference_ixs = [(t, pre_ix, pre_ix + contl) for (t, pre_ix, contl) in children_ix if\n                                 t.tag == f\"{prefix}ref\"]\n\n                p = TEIXMLParser._add_node(sub_graph, paragraph_text, NTYPE_PARAGRAPH, predecessor=predecessor,\n                                           parent=root)\n                predecessor = p\n\n                if len(reference_ixs) > 0:\n                    graph_refs += [(predecessor, reference_ixs)]\n\n        return sub_graph, predecessor, graph_refs, figures\n\n    def _parse_abstract(self, doc, abstract, prefix, predecessor, article_title):\n        abstract_title = self._add_node(doc, \"Abstract\", NTYPE_ABSTRACT, predecessor=predecessor, parent=article_title)\n        predecessor = abstract_title\n\n        if abstract is None:\n            return abstract_title, predecessor\n\n        content = \"\"\n        merge = False\n        for child in abstract:\n            # get text (including any possible children)\n            text = self._flatten_xml_element(child)\n            self._check_text(text, \"abstract paragraph\")\n\n            content += text\n\n            if child.tag != f\"{prefix}p\":\n                # if non-paragraph, treat as hick-up by GROBID and append to content of next node and force merge\n                logging.info(f\"Unexpected paragraph tag '{child.tag}' in the abstract! Treating as in-line text.\")\n\n                merge = True\n                content += \" \"\n            elif merge and predecessor.ntype == NTYPE_PARAGRAPH:\n                # if a previous element was erroneously inserted, merge this paragraph with the previous one\n                predecessor.content += \" \" + text\n\n                merge = False\n                content = \"\"\n            else:\n                # no merging required or cannot merge with previous node: simply add a new one with all content\n                predecessor = self._add_node(doc, content, NTYPE_PARAGRAPH, predecessor=predecessor,\n                                             parent=abstract_title)\n\n                merge = False\n                content = \"\"\n\n        # if there is still content left (no paragraph follows a hick-up)\n        if len(content) > 0:\n            predecessor = self._add_node(doc, content.strip(), NTYPE_PARAGRAPH, predecessor=predecessor,\n                                         parent=abstract_title)\n\n        return abstract_title, predecessor\n\n    @staticmethod\n    def _parse_figure(doc, figure, prefix, predecessor, parent):\n        head = figure.find(f\"{prefix}head\")\n        label = figure.find(f\"{prefix}label\")\n        xid = figure.get('{http://www.w3.org/XML/1998/namespace}id')\n        figDesc = figure.find(f\"{prefix}figDesc\")\n\n        if head is None:\n            return None, None\n\n        if \"type\" in figure.attrib and figure.attrib[\"type\"] == \"table\":\n            table = figure.find(f\"{prefix}table\")\n\n            table_node = TEIXMLParser._add_node(doc,\n                                                head.text if head.text is not None else \"\",\n                                                NTYPE_TABLE,\n                                                meta={\"label\": label.text if label is not None else None,\n                                                      \"id\": xid,\n                                                      \"caption\": figDesc.text if figDesc is not None else None},\n                                                predecessor=predecessor,\n                                                parent=parent)\n            predecessor = table_node\n\n            table_content = TEIXMLParser._add_node(doc,\n                                                   str(ElementTree.tostring(table)),\n                                                   NTYPE_MEDIA,\n                                                   meta={},\n                                                   predecessor=predecessor,\n                                                   parent=table_node)\n            predecessor = table_content\n        else:\n            graphic = figure.find(f\"{prefix}graphic\")\n\n            figure_node = TEIXMLParser._add_node(doc,\n                                                 head.text if head.text is not None else \"\",\n                                                 NTYPE_FIGURE,\n                                                 meta={\"label\": label.text if label is not None else None,\n                                                       \"id\": xid,\n                                                       \"caption\": figDesc.text if figDesc is not None else None},\n                                                 predecessor=predecessor,\n                                                 parent=parent)\n            predecessor = figure_node\n\n            figure_content = TEIXMLParser._add_node(doc,\n                                                    TEIXMLParser._flatten_xml_element(graphic) if graphic else \"\",\n                                                    NTYPE_MEDIA,\n                                                    meta={},\n                                                    predecessor=predecessor,\n                                                    parent=figure_node)\n            predecessor = figure_content\n\n        return xid, predecessor\n\n    @staticmethod\n    def _parse_bibitem(bib_item, prefix):\n        xid = bib_item.get('{http://www.w3.org/XML/1998/namespace}id')\n        publishing_info = bib_item.find(f\"{prefix}monogr\")\n        paper_info = bib_item.find(f\"{prefix}analytic\")\n\n        # parse publishing information\n        if publishing_info:\n            pub_title = publishing_info.find(f\"{prefix}title\")\n            pub_title = pub_title.text if pub_title is not None else None\n\n            pub = publishing_info.find(f\"{prefix}imprint/{prefix}publisher\")\n            pub = pub.text if pub is not None else None\n\n            pub_date = publishing_info.find(f\"{prefix}imprint/{prefix}date\")\n            pub_date = pub_date.attrib[\"when\"] if pub_date is not None and \"when\" in pub_date.attrib else None\n        else:\n            pub_title = None\n            pub = None\n            pub_date = None\n\n        # add paper information if present\n        if paper_info:\n            title = paper_info.find(f\"{prefix}title\")\n            title = title.text if title is not None else None\n\n            authors = paper_info.findall(f\"{prefix}author/{prefix}persName\")\n\n            author_names = []\n            for a in authors:\n                forename = a.find(f'{prefix}forename')\n                surname = a.find(f'{prefix}surname')\n                canonical_author = f\"{forename.text if forename is not None else ''} {surname.text if surname is not None else ''}\"\n\n                author_names += [canonical_author] if len(canonical_author) > 0 else []\n        else:\n            title = None\n            author_names = None\n\n        return xid, title, author_names, pub_title, pub, pub_date\n\n    @staticmethod\n    def _flatten_xml_element(element):\n        stack = [(element, -1, None)]\n\n        while True:\n            elem, pred, content = stack.pop(-1)\n\n            # visiting node the first time\n            if content is None:\n                content = elem.text if elem.text else \"\"\n\n                # revisit element after children\n                stack += [(elem, pred, content)]\n\n                # add children\n                stack += reversed([(child, len(stack) - 1, None) for child in elem])\n            else:\n                # revisiting the node (content is set)\n                suffix = elem.tail if elem.tail else \"\"\n\n                if pred >= 0:\n                    pre_elem, pre_pred, pre_content = stack[pred]\n                    stack[pred] = (pre_elem, pre_pred, pre_content + content + suffix)\n                else:\n                    # terminating at parent most element\n                    return content + suffix\n\n                # don't add to stack again\n        # should always terminate\n\n    @staticmethod\n    def _flatten_xml_element_with_child_ix(element):\n        # xml element, predecessor ix, pred. merged ixs, parsed content\n        stack = [(element, -1, [], None)]\n\n        while True:\n            elem, pred, mergedix, content = stack.pop(-1)\n\n            # visiting node the first time\n            if content is None:\n                content = elem.text if elem.text else \"\"\n\n                # revisit element after children\n                stack += [(elem, pred, mergedix, content)]\n\n                # add children\n                stack += reversed([(child, len(stack) - 1, [], None) for child in elem])\n            else:\n                # revisiting the node (content is set)\n                suffix = elem.tail if elem.tail else \"\"\n\n                if pred >= 0:\n                    pre_elem, pre_pred, pre_mergedix, pre_content = stack[pred]\n\n                    new_mergedix = pre_mergedix + \\\n                                   [(elem, len(pre_content), len(content))] + \\\n                                   [(t, prel + len(pre_content), contl) for (t, prel, contl) in mergedix]\n\n                    stack[pred] = (pre_elem, pre_pred, new_mergedix, pre_content + content + suffix)\n                else:\n                    # terminating at parent most element\n                    return content + suffix, mergedix\n\n                # don't add to stack again\n        # should always terminate\n\n    @staticmethod\n    def _add_node(doc, content, ntype, meta=None, predecessor=None, parent=None):\n        new_node = Node(\n            content=content,\n            ntype=ntype,\n            meta=meta\n        )\n        doc.add_node(new_node)\n\n        if parent is not None:\n            parent_edge = Edge(\n                src_node=parent,\n                tgt_node=new_node,\n                etype=Etype.PARENT\n            )\n            doc.add_edge(parent_edge)\n\n        if predecessor is not None:\n            next_edge = Edge(\n                src_node=predecessor,\n                tgt_node=new_node,\n                etype=Etype.NEXT\n            )\n            doc.add_edge(next_edge)\n\n        return new_node\n\n    @staticmethod\n    def _add_subtree(doc, subTree, lastSubTree, targetParent, targetPredecessor):\n        # add nodes\n        new_nodes = {}\n        for n in subTree.nodes:\n            new_n = TEIXMLParser._add_node(doc, n.content, n.ntype, n.meta)\n            new_nodes[n.ix] = new_n\n\n        # add edges\n        for e in subTree.edges:\n            new_e = Edge(\n                src_node=new_nodes[e.src_node.ix],\n                tgt_node=new_nodes[e.tgt_node.ix],\n                etype=e.etype\n            )\n            doc.add_edge(new_e)\n\n        # get pseudo root and replace parent edges\n        new_pseudo_root = new_nodes[subTree.root.ix]\n        for ce in new_pseudo_root.get_edges(Etype.PARENT, outgoing=True, incoming=False):\n            new_parent = Edge(\n                src_node=targetParent,\n                tgt_node=ce.tgt_node,\n                etype=Etype.PARENT\n            )\n            doc.add_edge(new_parent)\n            doc.remove_edge(ce)\n\n        # if no other nodes except root: skip the next part\n        new_pseudo_next_edges = new_pseudo_root.get_edges(Etype.NEXT, outgoing=True, incoming=False)\n        if len(new_pseudo_next_edges) > 0:\n            new_pseudo_next = new_pseudo_next_edges[0]\n            new_next = Edge(\n                src_node=targetPredecessor,\n                tgt_node=new_pseudo_next.tgt_node,\n                etype=Etype.NEXT\n            )\n            doc.add_edge(new_next)\n            doc.remove_edge(new_pseudo_next)\n\n        doc.remove_node(new_pseudo_root)\n\n        # output\n        start_subtree = targetParent\n        end_subtree = new_nodes[lastSubTree.ix] if len(new_pseudo_next_edges) > 0 else None\n\n        return start_subtree, end_subtree, new_nodes\n\n    def _parse_document(self) -> IntertextDocument:\n        \"\"\"\n        Parse the given TEI XML document.\n\n        :return: resulting IntertextDocument\n        \"\"\"\n        # create intertext document\n        prefix = self._xml_file_path.split(os.path.sep)[-1]\n\n        itg_doc = IntertextDocument(\n            nodes=[],\n            edges=[],\n            prefix=prefix\n        )\n\n        # the content of the document is completely derived from the TEI XML file\n        tree = ElementTree.parse(self._xml_file_path)\n        prefix = \"{http://www.tei-c.org/ns/1.0}\"\n\n        # create article title as root\n        title = tree.getroot().find(f\"{prefix}teiHeader/{prefix}fileDesc/{prefix}titleStmt/{prefix}title\").text\n        title = title if title is not None else \"\"\n        article_title_node = self._add_node(itg_doc, title, NTYPE_TITLE)\n        predecessor = article_title_node\n\n        #\n        # PARSE THE ABSTRACT\n        #\n        abstract = tree.getroot().find(f\"{prefix}teiHeader/{prefix}profileDesc/{prefix}abstract/{prefix}div\")\n        abstract_title_node, predecessor = self._parse_abstract(itg_doc, abstract, prefix, predecessor,\n                                                                article_title_node)\n\n        #\n        # PARSE BODY\n        #\n        body = tree.getroot().find(f\"{prefix}text/{prefix}body\")\n\n        body_refs = []\n        body_figs = {}\n        content_graph = []\n        last_section_title = []\n        for section in body.findall(f\"{prefix}div\"):\n            content, last_elem, refs, figures = self._parse_section_content(section, prefix)\n\n            head = section.find(f\"{prefix}head\")\n            if head is None:\n                logging.info(f\"Div without a heading in {self._xml_file_path}.\")\n\n            # empty section\n            if len(content.edges) == 0 and len(content.nodes) <= 1 and head is None:\n                logging.info(f\"Encountered empty section in {self._xml_file_path}.\")\n\n            content_graph += [(content, last_elem, refs, figures)]\n\n            # fixme currently erroneous head nodes (e.g. with text, but without number) are discarded entirely\n            if head is not None and \"n\" in head.attrib:\n                # pop current content\n                current_content, current_last, current_refs, current_figures = content_graph.pop(-1)\n\n                # add previous contents to the predecessor if existent, else create a dummy section first\n                if len(content_graph) > 0:\n                    if len(last_section_title) == 0:\n                        dummy_node = self._add_node(itg_doc, \"\", NTYPE_HEADING, {\"section\": \"1\"},\n                                                    predecessor=article_title_node, parent=article_title_node)\n                        last_section_title += [dummy_node]\n                        predecessor = dummy_node\n\n                    pred_parent = last_section_title[-1]\n                    for c, l, r, f in content_graph:\n                        sub_root, sub_last, node_map = self._add_subtree(itg_doc, c, l, pred_parent, predecessor)\n                        predecessor = sub_last if sub_last is not None else predecessor\n\n                        mapped_refs = [(node_map[n.ix], ref) for n, ref in r]\n                        body_refs += mapped_refs\n\n                        mapped_figs = {fxid: node_map[fig.ix] for fxid, fig in f.items()}\n                        body_figs.update(mapped_figs)\n\n                    # reset content stack -- added all previous contents\n                    content_graph = []\n\n                # get section name and number\n                section_name = head.text\n                section_n = head.attrib[\"n\"]\n                self._check_text(section_name, \"section title\")\n\n                # find parent node\n                section_parent_node = None\n                if len(last_section_title) == 0:\n                    # is first section\n                    section_parent_node = article_title_node\n                else:\n                    for st in last_section_title:\n                        st_n = st.meta[\"section\"]\n\n                        if self._is_child_section_count(section_n, st_n):\n                            section_parent_node = st\n                            break\n\n                    if section_parent_node is None:\n                        section_parent_node = article_title_node\n\n                # add new section title with content\n                section_title_node = self._add_node(itg_doc,\n                                                    section_name,\n                                                    NTYPE_HEADING,\n                                                    {\"section\": section_n},\n                                                    predecessor=predecessor,\n                                                    parent=section_parent_node)\n                predecessor = section_title_node\n                last_section_title += [section_title_node]\n\n                sub_root, sub_last, node_map = self._add_subtree(itg_doc, current_content, current_last,\n                                                                 section_title_node,\n                                                                 predecessor)\n                predecessor = sub_last if sub_last is not None else predecessor\n\n                mapped_refs = [(node_map[n.ix], r) for n, r in refs]\n                body_refs += mapped_refs\n\n                mapped_figs = {fxid: node_map[fig.ix] for fxid, fig in current_figures.items()}\n                body_figs.update(mapped_figs)\n\n        # add left-over content-graph elements\n        if len(content_graph) > 0:\n            if len(last_section_title) == 0:\n                dummy_node = self._add_node(itg_doc, \"\", NTYPE_HEADING, {\"section\": \"1\"},\n                                            predecessor=article_title_node, parent=article_title_node)\n                last_section_title += [dummy_node]\n                predecessor = dummy_node\n\n            pred_parent = last_section_title[-1]\n            for c, l, r, f in content_graph:\n                sub_root, sub_last, node_map = self._add_subtree(itg_doc, c, l, pred_parent, predecessor)\n                predecessor = sub_last if sub_last is not None else predecessor\n\n                mapped_refs = [(node_map[n.ix], ref) for n, ref in r]\n                body_refs += mapped_refs\n\n                mapped_figs = {fxid: node_map[fig.ix] for fxid, fig in f.items()}\n                body_figs.update(mapped_figs)\n\n        for figure in body.findall(f\"{prefix}figure\"):\n            fxid, figure_node = self._parse_figure(itg_doc, figure, prefix, predecessor, article_title_node)\n            predecessor = figure_node\n            body_figs[fxid] = figure_node\n\n        #\n        ## PARSE BACK MATTER\n        #\n        back = tree.getroot().find(f\"{prefix}text/{prefix}back\")\n\n        bibliography = {}\n        for bib_item in back.findall(f\"{prefix}div/{prefix}listBibl/{prefix}biblStruct\"):\n            xid, title, authors, pub_title, pub, pub_date = self._parse_bibitem(bib_item, prefix)\n\n            bib_node = self._add_node(itg_doc, f\"{', '.join(authors) if authors is not None else 'UNKNOWN'}, \"\n                                               f\"{title}, \"\n                                               f\"{pub_date if pub_date else ''}, \"\n                                               f\"{pub_title if pub_title else ''}, \"\n                                               f\"{pub if pub else ''}.\",\n                                      ntype=NTYPE_BIB_ITEM,\n                                      meta={\"xid\": xid,\n                                            \"authors\": authors,\n                                            \"title\": title,\n                                            \"pub_date\": pub_date,\n                                            \"pub_title\": pub_title,\n                                            \"pub\": pub})\n            bibliography[xid] = bib_node\n\n        #\n        ## ADD REFERENCES\n        #\n        for node, refs in body_refs:\n            for r in refs:\n                xml_elem, start, end = r\n                rtype = xml_elem.attrib[\"type\"]\n\n                # skip invalid references with missing target (for now)\n                if \"target\" not in xml_elem.attrib:\n                    continue\n\n                rtarget = xml_elem.attrib[\"target\"][1:]\n\n                # add span node\n                ref_node = SpanNode(\n                    ntype=NTYPE_BIB_REFERENCE if rtype == \"bibr\" else NYTPE_ELEMENT_REFERENCE,\n                    src_node=node,\n                    start=start,\n                    end=end,\n                    meta={\"from_xml_type\": rtype, \"from_xml_target\": rtarget}\n                )\n                itg_doc.add_node(ref_node)\n\n                # add link (where possible)\n                target_node = None\n                if rtype == \"bibr\" and rtarget in bibliography:\n                    target_node = bibliography[rtarget]\n                elif (rtype == \"figure\" or rtype == \"table\") and target_node in body_figs:\n                    target_node = body_figs[rtarget]\n\n                if target_node:\n                    link = Edge(ref_node, target_node, etype=Etype.LINK)\n                    itg_doc.add_edge(link)\n\n        return itg_doc\n\n    @staticmethod\n    def _check_text(text: str, element_name: str) -> str:\n        assert isinstance(text, str), f\"{element_name} is not a string, but a {type(text)}!\"\n        return text\n\n    @staticmethod\n    def _compare_section_counts(cntA: str, cntB: str) -> int:\n        nAs = cntA.split(\".\")\n        nBs = cntB.split(\".\")\n\n        for i, nA in enumerate(nAs):\n            if len(nBs) <= i:\n                return 1  # b higher level than a (a > b)\n            nB = nBs[i]\n            if int(nA) != int(nB):\n                return -1 if int(nA) < int(nB) else 1  # a earlier than b (a < b)\n\n        return 0 if len(nAs) == len(nBs) else -1  # a higher level than b (a < b), else equal\n\n    @staticmethod\n    def _is_child_section_count(cntA: str, cntB: str) -> bool:\n        return cntA.startswith(cntB)", "\n\nclass F1000XMLParserBM(F1000XMLParser):\n    \"\"\"\n    The F1000XMLParserBM is an extension of the F1000XMLParser provided by the ITG library. To standardize\n    the benchmark structure, we need to adapt the given parsing strategy.\n\n    We can translate some nodes post-hoc (assuming that the rough parsing structure is the same and semantics fit):\n        article-title -> title\n        title -> heading\n        p -> paragraph\n        abstract = abstract\n\n        supplementary_material -> paragraph\n        preformat -> paragraph\n        disp-quote -> paragraph\n\n        label && label.content.startswith(\"Figure\") -> figure\n            > fig                                   -> media\n\n        label && label.content.startswith(\"Table\") -> table\n            > table-wrap                           -> media\n\n        label && label.content.startswith(\"Algorithm\") -> figure\n            > boxed text\n\n        math -> formula\n\n        boxed-text -> figure #TODO\n        table-warp -> table #todo\n\n    We need to add or refactor other node types:\n        * \"ref\" is bib_item, but we parse more meta-information (i.e. authors etc.)\n        * lists and list-items are so-far not mapped.\n        * in-line references to figures and bibitems are not tagged as span nodes so far\n\n    Additionally, the parser delivers us meta-data on authors etc, which we should include in the benchmark. To keep\n    things clean, we will decouple this.\n    \"\"\"\n\n    def __init__(self, xml_file_path: str):\n        \"\"\"\n        Initialize the F1000XMLParserBM for a particular paper.\n\n        :param xml_file_path: filepath of the F1000 XML file\n        \"\"\"\n        super(F1000XMLParserBM, self).__init__(xml_file_path)\n        self._xml_file_path: str = xml_file_path\n\n        self.ntype_mapping = {\n            \"title\": NTYPE_HEADING,\n            \"article-title\": NTYPE_TITLE,\n            \"p\": NTYPE_PARAGRAPH,\n            \"supplementary-material\": NTYPE_PARAGRAPH,\n            \"preformat\": NTYPE_PARAGRAPH,\n            \"disp-quote\": NTYPE_PARAGRAPH,\n            \"list\": NTYPE_LIST,\n            \"list-item\": NTYPE_LIST_ITEM,\n            \"disp-formula\": NTYPE_FORMULA,\n            \"def-list\": NTYPE_LIST\n        }\n\n        self.complex_ntype_mapping = [\n            (F1000XMLParserBM._is_figure_ntype, F1000XMLParserBM._convert_to_figure_node),\n            (F1000XMLParserBM._is_table_ntype, F1000XMLParserBM._convert_to_table_node),\n            (F1000XMLParserBM._is_other_media_ntype, F1000XMLParserBM._convert_to_figure_node)\n        ]\n\n    @staticmethod\n    def _is_other_media_ntype(node):\n        return node.ntype == \"label\"\n\n    @staticmethod\n    def _is_figure_ntype(node):\n        return (node.ntype == \"label\" and\n                (node.content.lower().startswith(\"figure\") or\n                 node.content.lower().startswith(\"algorithm\") or\n                 node.content.lower().startswith(\"box\")) or\n                node.content.lower().startswith(\"listing\")) or \\\n               (node.ntype == \"fig\") or \\\n               (node.ntype == \"caption\") or \\\n               (node.ntype == \"boxed-text\")\n\n    @staticmethod\n    def _is_table_ntype(node):\n        return (node.ntype == \"label\" and node.content.lower().startswith(\"table\")) or \\\n               (\"table\" in node.ntype)\n\n    @staticmethod\n    def _convert_to_figure_node(node):\n        # adapt top node of type label or of type fig\n        node.ntype = NTYPE_FIGURE\n        node.meta = {\n            \"label\": node.content,\n            \"id\": node.meta[\"id\"] if \"id\" in node.meta else None,\n            \"caption\": node.meta[\"caption\"] if \"caption\" in node.meta else None\n        }\n\n        # get figure child node (\"the content\") from top node, if existent\n        fig_node = node.get_edges(Etype.PARENT, incoming=False, outgoing=True)\n        if len(fig_node) > 0:\n            fig_node = fig_node[0].tgt_node\n\n            # adapt children node of type fig\n            fig_node.ntype = NTYPE_MEDIA\n            fig_node.meta = {\n                \"id\": fig_node.meta[\"id\"] if \"id\" in fig_node.meta else None,\n                \"uri\": fig_node.meta[\"uri\"] if \"uri\" in fig_node.meta else None\n            }\n\n    @staticmethod\n    def _convert_to_table_node(node):\n        # adapt top node of type label\n        node.ntype = NTYPE_TABLE\n        node.meta = {\n            \"label\": node.content,\n            \"id\": node.meta[\"id\"] if \"id\" in node.meta else None,\n            \"caption\": node.meta[\"caption\"] if \"caption\" in node.meta else None\n        }\n\n        # get table child node from label node\n        tbl_node = node.get_edges(Etype.PARENT, incoming=False, outgoing=True)\n        if len(tbl_node) > 0:\n            tbl_node = tbl_node[0].tgt_node\n\n            # adapt children node of type table-wrap\n            tbl_node.ntype = NTYPE_MEDIA\n            tbl_node.meta = {\n                \"id\": tbl_node.meta[\"id\"] if \"id\" in tbl_node.meta else None,\n                \"uri\": tbl_node.meta[\"uri\"] if \"uri\" in tbl_node.meta else None\n            }\n\n    def __call__(self) -> IntertextDocument:\n        \"\"\"\n        Parse the F1000 XML document into an IntertextDocument.\n\n        :return: the IntertextDocument\n        \"\"\"\n        return self._parse_document()\n\n    def _parse_refs(self, ref_list: etree._Element) -> None:\n        for ref in ref_list:\n            target_xmlid = ref.attrib['id']\n\n            label = ref.find(\"label\")\n            label = label.text if label is not None else None\n\n            citation = ref.find(\"mixed-citation\")\n\n            title = citation.find(\"article-title\")\n            title = ''.join([e.strip() for e in title.itertext()]) if title is not None else None\n\n            pub_date = citation.find(\"year\")\n            pub_date = pub_date.text if pub_date is not None else None\n\n            if citation is not None:\n                pub_info = [i for i in citation.findall(\"*\") if i.tag not in [\"article-title\", \"person-group\", \"year\"]]\n                pub_text = \"\".join([\" \".join([t.strip() for t in i.itertext()]) for i in pub_info])\n            else:\n                pub_text = None\n\n            authors = citation.findall(\"person-group[@person-group-type='author']/name\")\n            author_list = []\n            for a in authors:\n                name_components = []\n                given = a.find(\"given-names\")\n                name_components += [given.text] if given is not None and given.text is not None else []\n                suffix = a.find(\"suffix\")\n                name_components += [suffix.text] if suffix is not None and suffix.text is not None else []\n                surname = a.find(\"surname\")\n                name_components += [surname.text] if surname is not None and surname.text is not None else []\n\n                author_list += [\" \".join(name_components)]\n\n            bib_item = Node(f\"{', '.join(author_list) if len(author_list) > 0 else 'UNKNOWN'}, \" +\n                            f\"{title if title is not None else 'UNKNOWN'}, \" +\n                            f\"{pub_date if pub_date is not None else ''}, \" +\n                            f\"{pub_text if pub_text is not None else ''}\",\n                            ntype=NTYPE_BIB_ITEM,\n                            meta={\"xid\": target_xmlid,\n                                  \"id\": label,\n                                  \"authors\": author_list,\n                                  \"title\": title,\n                                  \"pub_date\": pub_date,\n                                  \"pub\": pub_text})\n\n            self._xref_targets[target_xmlid] = bib_item\n\n    # copied from f1000 xml parser and adapted to support empty nodes\n    def _make_node(self, element: etree._Element, stringify: bool = False, meta: Dict[str, Any] = None) -> Optional[\n        Node]:\n        if stringify:\n            content = self._stringify(element)\n            if content:\n                content = self._parse_whitespace(content)\n            if content:\n                return super(F1000XMLParser, self)._make_node(content, element.tag, meta)\n        else:\n            content = \"\"\n            return super(F1000XMLParser, self)._make_node(content, element.tag, meta)\n\n    # copied from F1000 parser and adapted\n    def _split_element(cls, element: etree._Element, selector: str) -> List[etree._Element]:\n        \"\"\"Split an element before and after the selector.\"\"\"\n        node = deepcopy(element)\n\n        children = [c for c in node]\n        split_child = node.xpath(selector)[0]\n        split_child_i = children.index(split_child)\n\n        assert split_child_i != -1, \"something went wrong splitting an element. Invalid selector passed.\"\n\n        c_before = node[:max(split_child_i, 0)]\n        c_after = node[min(split_child_i + 1, len(children)):]\n\n        root_before = etree.Element(element.tag, element.attrib, element.nsmap)\n        root_before.text = element.text\n        for c in c_before:\n            root_before.append(c)\n\n        root_after = etree.Element(element.tag, element.attrib, element.nsmap)\n        root_after.tail = element.tail\n        for c in c_after:\n            root_after.append(c)\n\n        return [root_before, split_child, root_after]\n\n    # copied from f1000_xml_parser.py with minor adaptions\n    def _parse_element(self, element: etree._Element) -> Tuple[Optional[Node], List[etree._Element]]:\n        children = list(element)\n        if children:\n            # Parse nodes with children, i.e. subtrees\n            if element.tag == 'body':\n                return None, children\n            elif element.tag == 'abstract':\n                node = self._make_node(element, stringify=False)\n                node.content = \"Abstract\"\n            elif element.tag == 'sec':\n                # Move the title child to the root node of a section\n                title_element = element.xpath('title')\n                if title_element and title_element[0].text:\n                    meta = {'section': self._generate_sec_index(element)}\n                    if 'id' in element.attrib:\n                        meta['id'] = element.attrib['id']\n                    if 'sec-type' in element.attrib:\n                        meta['sec-type'] = element.attrib['sec-type']\n                    node = self._make_node(title_element[0], stringify=True, meta=meta)\n                    children.remove(title_element[0])\n                    # Keep track of potential xref targets\n                    if meta and 'id' in meta:\n                        self._xref_targets[meta['id']] = node\n                else:\n                    # Section has no title\n                    node = None\n            elif element.tag == 'list':\n                # Concatenate list items with new line\n                node = self._make_node(element, stringify=False)\n                # add children\n                children = element.xpath('list-item')\n            elif element.tag == \"list-item\":\n                node = self._make_node(element, stringify=True)\n                children = []\n            elif element.tag == \"def-list\":\n                node = self._make_node(element, stringify=False)\n                # add children\n                children = element.xpath(\"def-item\")\n            elif element.tag == \"def-item\":\n                t = element.xpath(\"term\")\n                d = element.xpath(\"def\")\n\n                if t and d:\n                    content = f\"{self._stringify(t[0])}: {self._stringify(d[0])}\"\n                    node = super(F1000XMLParser, self)._make_node(content, \"list-item\")\n                    children = []\n                else:\n                    return None, []\n            elif element.tag == 'p':\n                # Stringify paragraphs, drop all inline tags\n                tags = [e.tag for e in element]\n                if 'boxed-text' in tags:\n                    # Boxed text has to be processed before other nested types as is might contain these as children\n                    return None, self._elevate_element(element, 'boxed-text')\n                elif element.xpath(\"table-wrap\"):\n                    return None, self._split_element(element, \"table-wrap\")\n                elif element.xpath('preformat'):\n                    # Elevate immediate children but ignore nested inline tags\n                    return None, self._elevate_element(element, 'preformat')\n                elif 'list' in tags:\n                    # Split paragraph before and after an inline list\n                    # A human would probably read this as separate paragraphs\n                    return None, self._split_element(element, 'list')\n                elif \"disp-formula\" in tags:\n                    #if len(children) > 1: #todo verify\n                    #    return None, self._split_element(element, \"disp-formula\")\n                    #else:\n                    #    return self._make_node(children[0], stringify=True), []\n                    return None, self._split_element(element, \"disp-formula\")\n\n                meta = None\n                # Add metadata for xrefs which will later be parsed into edges\n                if 'xref' in tags:\n                    xrefs = self._collect_xrefs(element)\n                    if xrefs:\n                        meta = {'xrefs': xrefs}\n                # Drop inline xref\n                etree.strip_tags(element, 'xref')\n                node = self._make_node(element, stringify=True, meta=meta)\n                # Drop children\n                children = []\n            elif element.tag in ['fig', 'table-wrap', 'boxed-text']:\n                # Get optional meta data\n                meta = self._parse_node_meta(element)\n                label_element = element.xpath('label')\n                caption_element = element.xpath('caption')\n                if label_element:\n                    # Move the label child to the root node\n                    node = self._make_node(element.xpath('label')[0], stringify=True, meta=meta)\n                    # Remove the label tag and do another recursive call to parse element as an XML node\n                    etree.strip_elements(element, 'label', with_tail=False)\n                    children = [element]\n                elif caption_element:\n                    # Move the caption child to the root node\n                    node = self._make_node(element.xpath('caption')[0], stringify=True, meta=meta)\n                    # Remove the label tag and do another recursive call to parse element as an XML node\n                    etree.strip_elements(element, 'caption', with_tail=False)\n                    children = [element]\n                else:\n                    # Handle second recursive call or cases where there is no label\n                    node = self._make_xml_node(element, meta=meta)\n                    # Drop children\n                    children = []\n                # Keep track of potential xref targets\n                if meta and 'id' in meta:\n                    self._xref_targets[meta['id']] = node\n            elif 'formula' in element.tag:\n                meta = self._parse_node_meta(element)\n                node = self._make_node(element, stringify=True, meta=meta)\n                children = []\n            else:\n                node = self._make_xml_node(element)\n                # Drop children\n                children = []\n        else:\n            # Parse leaf nodes with potential inline tags\n            node = self._make_node(element, stringify=True)\n        return node, children\n\n    def _parse_document(self):\n        # prep\n        prefix = self._xml_file_path.split(os.path.sep)[-1]\n\n        # parse main document with the standard parser, but exchanged sub-routines\n        doc = self._parse(self._root, None, prefix)\n\n        if doc is None:\n            raise ValueError(f\"The passed F1000 XML {self._xml_file_path} could not be parsed. Body not found.\")\n\n        # replace old node types by new ones, where an easy type mapping suffices\n        nodes_by_ntype = [(newtype, [n for n in doc.nodes if n.ntype == oldtype]) for oldtype, newtype in\n                          self.ntype_mapping.items()]\n        for newtype, nodes in nodes_by_ntype:\n            for n in nodes:\n                n.ntype = newtype\n\n        # realize the more complex mappings on node level\n        for criterion, mapping in self.complex_ntype_mapping:\n            matching_nodes = filter(criterion, doc.nodes)\n            for mn in matching_nodes:\n                mapping(mn)\n\n        # verify validity\n        invalid_types = set([n.ntype for n in doc.nodes if n.ntype not in NTYPES])\n        if len(invalid_types) > 0:\n            logging.warning(\n                f\"Found invalid node types in the document {self._xml_file_path} after parsing: {str(invalid_types)}\")\n\n        # discard any invalid node types\n        to_remove = []\n        for n in doc.nodes:\n            if n in invalid_types:\n                to_remove += [n]\n\n        for n in to_remove:\n            doc.remove_node(n)\n\n        # add span nodes for citations and references\n        # todo currently full paragraphs are regarded as the source of a link, we want that to be span nodes\n\n        return doc", "\n\nclass F1000XMLParserMetadata(F1000XMLParser):\n    \"\"\"\n    The F1000XMLParserMetadata is simply a reduced version of the F1000XMLParser meant to extract\n    only metadata on the paper including reviews, change notes and metadata on the publication.\n\n    \"\"\"\n\n    def __init__(self, xml_file_path: str):\n        \"\"\"\n        Initialize the F1000XMLParserBM for a particular paper.\n\n        :param xml_file_path: filepath of the F1000 XML file\n        \"\"\"\n        super(F1000XMLParserMetadata, self).__init__(xml_file_path)\n        self._xml_file_path: str = xml_file_path\n\n    def __call__(self) -> IntertextDocument:\n        \"\"\"\n        Parse the F1000 XML document into an IntertextDocument.\n\n        :return: the IntertextDocument\n        \"\"\"\n        return self._parse_all_metadata()\n\n    def _parse_all_metadata(self):\n        # prep\n        prefix = self._xml_file_path.split(os.path.sep)[-1]\n\n        # use standard meta parser\n        self._parse_meta()\n\n        # add meta fields\n        meta_node = self._root.find('.//article-meta')\n        subs = meta_node.findall(\".//article-categories/subj-group/subject\")\n        self._meta[\"subjects\"] = [s.text for s in\n                                  subs[2:]]  # first always = article type, not subject; second always = articles\n\n        # add year\n        year = meta_node.find(\".//pub-date[@pub-type='epub']/year\")\n        self._meta[\"year\"] = year.text if year is not None else None #todo verify\n\n        # add license information\n        license_node = meta_node.find(\".//permissions\")\n        self._meta[\"license\"] = self._stringify(license_node)\n\n        # ** COPIED FROM PARENT CLASS __call__ method **\n        # ** START **\n        # Reviews\n        reviews = {}\n        for review in self._root.xpath('.//sub-article[@article-type=\"ref-report\"]'):\n            review_id = review.attrib['id']\n            license = review.find('.//license').attrib['{http://www.w3.org/1999/xlink}href']\n            recommendation = review.find('.//meta-value').text  # TODO: A bit dirty here\n            doi = review.find('.//front-stub/article-id[@pub-id-type=\"doi\"]').text\n            contributors = [\n                {\n                    'surname': contrib.find('.//name/surname').text,\n                    'given-names': contrib.find('.//name/given-names').text\n                } for contrib in review.find('.//front-stub/contrib-group')\n                if contrib.tag == 'contrib' and (contrib.find('.//name/surname') is not None)\n            ]\n            #todo get license\n            meta = {'review_id': review_id,\n                    'license': license,\n                    'recommendation': recommendation,\n                    'doi': doi,\n                    'contributors': contributors}\n            reviews[review_id] = self._parse(review, meta, review_id)\n\n        # Revision comment\n        version_changes = self._root.xpath('.//sec[@sec-type=\"version-changes\"]')\n        if version_changes:\n            # TODO: Check if any nodes need additional parsing\n            nodes, edges = self._parse_tree(version_changes[-1])\n            self._add_supplementary_edges(nodes, edges)\n            if prefix:\n                prefix = f'revision_{prefix}'\n            revision = IntertextDocument(nodes, edges, prefix or 'revision')\n        else:\n            revision = None\n        # ** END **\n\n        return self._meta, reviews, revision", "\n\nclass IntertextSentenceSplitterBM(IntertextSentenceSplitter):\n    def __init__(self, itg: IntertextDocument, splitter: SentenceSplitter = None,\n                 gold: Dict[str, List[Dict[str, str]]] = {}):\n        super().__init__(itg, splitter, gold)\n\n    def _get_sentences_from_itg(self) -> List[SpanNode]:\n\n        sentence_nodes = []\n        for node in self.itg.nodes:\n            if node.ntype in [NTYPE_PARAGRAPH, NTYPE_ABSTRACT, NTYPE_HEADING, NTYPE_TITLE, NTYPE_LIST_ITEM]:\n                boundaries = self.splitter.split(node.content)\n\n                new_sentence_nodes = make_sentence_nodes(\n                    node,\n                    boundaries\n                )\n\n                sentence_nodes += new_sentence_nodes\n\n        return sentence_nodes", "\n\nclass IntertextLayoutTagger:\n    def __init__(self, itg, position_information):\n        self.itg = itg\n        self.posinfo = position_information\n\n    def tag_text_with_position_information(self):\n        out = copy.deepcopy(self.itg)\n        out.meta.update({\n            \"position_tag_type\": \"from_draft\"\n        })\n\n        new_root = self.itg.root\n        line_nodes = []\n        lines_per_node = {}\n        for line in self.posinfo[\"lines\"]:\n            li, lt = line\n\n            lt_like = lt.lower().strip()\n            if lt.endswith(\"-\"):\n                lt_like = lt_like[:-1]\n\n            pix = next(i for i,p in enumerate(self.posinfo[\"pages\"]) if int(p[0][0]) <= int(li) <= int(p[1][0]))\n\n            for node in self.itg._unroll_graph(new_root):\n                if node.ntype in [NTYPE_PARAGRAPH, NTYPE_LIST_ITEM, NTYPE_TITLE, NTYPE_HEADING,\n                                  NTYPE_ABSTRACT, NTYPE_FORMULA, NTYPE_BIB_ITEM]:\n                    if lt_like in node.content.lower().strip():\n                        str_idx = node.content.lower().find(lt_like)\n                        new_root = node\n\n                        posi_node = SpanNode(ntype=\"line\",\n                                             src_node=node,\n                                             start=str_idx,\n                                             end=str_idx + len(lt_like),\n                                             meta={\"created_by\": \"IntertextLayoutTagger\", \"line\": li, \"page\": pix+1})\n                        posi_node.ix = f\"{node.ix}@{len(line_nodes)}_{li}\"\n                        line_nodes += [posi_node]\n\n                        for nn in self.itg.breadcrumbs(node, Etype.PARENT):\n                            lpn = lines_per_node.get(nn.ix, [])\n                            lines_per_node[nn.ix] = [min(lpn + [li]), max(lpn + [li])]\n\n                        break\n\n        layout_nodes = []\n        for n, lpn in lines_per_node.items():\n            pix0 = next(i for i, p in enumerate(self.posinfo[\"pages\"]) if int(p[0][0]) <= int(lpn[0]) <= int(p[1][0]))\n            pix1 = next(i for i, p in enumerate(self.posinfo[\"pages\"]) if int(p[0][0]) <= int(lpn[1]) <= int(p[1][0]))\n\n            node = self.itg.get_node_by_ix(n)\n\n            posi_node = SpanNode(ntype=\"line_range\",\n                                 src_node=node,\n                                 start=0,\n                                 end=len(node.content),\n                                 meta={\"created_by\": \"IntertextLayoutTagger\",\n                                       \"line_start\": lpn[0],\n                                       \"line_end\":lpn[1],\n                                       \"page_start\": pix0,\n                                       \"page_end\": pix1})\n\n            posi_node.ix = f\"{n}@{lpn[0]}-{lpn[1]}\"\n            layout_nodes += [posi_node]\n\n        # todo future: propagate the layout information to the parents until root\n\n        for n in line_nodes + layout_nodes:\n            out.add_node(n)\n            edge = out.get_edge_by_ix(f'{n.src_node.ix}_{n.ix}_link')\n            meta = {\"created_by\": \"IntertextLayoutTagger\"}\n            if edge.meta is None:\n                edge.meta = meta\n            else:\n                edge.meta.update(meta)\n\n        return out", "\n\n#\n## Functions\n#\n\ndef f1000xml_to_itg(xml_path):\n    assert os.path.exists(xml_path) and os.path.isfile(xml_path), \"provided file path to the XML does not exist. \" \\\n                                                                  \"Cannot parse.\"\n\n    parser = F1000XMLParserBM(xml_path)\n    itg_doc = parser()\n\n    return itg_doc", "\n\ndef pdf_to_tei(pdf_path, config=None):\n    assert os.path.exists(pdf_path) and os.path.isfile(pdf_path), \"provided file path to the PDF does not exist. \" \\\n                                                                  \"Cannot parse.\"\n\n    try:\n        client = GrobidClient(**GROBID_CONF)\n    except ServerUnavailableException as e:\n        print(\"GROBID server not available. ERROR during pdf parsing.\")\n        raise e\n\n    # use default config if none is provided\n    if config is None:\n        # no consolidation\n        config = {\n            \"generateIDs\": False,\n            \"consolidate_header\": False,\n            \"consolidate_citations\": False,\n            \"include_raw_citations\": False,\n            \"include_raw_affiliations\": False,\n            \"tei_coordinates\": False,\n            \"segment_sentences\": False\n        }\n\n    _, status, parsed = client.process_pdf(\"processFulltextDocument\",\n                                           pdf_path,\n                                           **config)\n\n    return status, parsed", "\n\ndef tei_to_itg(tei):\n    parser = TEIXMLParser(tei)\n    itg_doc = parser()\n\n    return itg_doc\n"]}
{"filename": "nlpeer/data/collect/coling20.py", "chunked_list": ["import argparse\nimport json\nimport os\nfrom os.path import join as pjoin\nfrom os.path import basename\nimport xml.etree.ElementTree as ET\n\nfrom tqdm import tqdm\n\nfrom nlpeer.data.collect import retrieve_matched, fetch_camera_ready_mapping", "\nfrom nlpeer.data.collect import retrieve_matched, fetch_camera_ready_mapping\nfrom nlpeer.data.datasets.parse import pdf_to_tei\nfrom nlpeer.data.datasets.utils import PDFProcessingError\nfrom nlpeer.data.utils import list_files\n\n\ndef load_coling2020_papers(path):\n    basepath = pjoin(path, \"COLING-2020/COLING2020_XY/COLING2020_XY\")\n\n    papers_path = pjoin(basepath, \"paper_pdf\")\n    reviews_path = pjoin(basepath, \"reviews\")\n\n    reviewed_paper_ids = [int(basename(f).split(\"_\")[0]) for f in list_files(reviews_path)]\n    papers = {int(basename(f).split(\".\")[0]): f for f in list_files(papers_path) if int(basename(f).split(\".\")[0]) in reviewed_paper_ids}\n\n    result = {}\n    for pid, p_path in tqdm(papers.items(), desc=\"Iterating over papers\"):\n        status, tei = pdf_to_tei(p_path)\n\n        if status != 200:\n            raise PDFProcessingError(\"GROBID Parsing Error\")\n\n        root = ET.fromstring(tei)\n        prefix = \"{http://www.tei-c.org/ns/1.0}\"\n\n        # create article title as root\n        title = root.find(f\"{prefix}teiHeader/{prefix}fileDesc/{prefix}titleStmt/{prefix}title\").text\n        title = title if title is not None else \"\"\n\n        abstract = root.find(f\"{prefix}teiHeader/{prefix}profileDesc/{prefix}abstract/{prefix}div\")\n        if abstract:\n            children = list(abstract)\n            if children:\n                abstract = ' '.join(abstract.itertext()).strip()\n            else:\n                abstract = abstract.text\n        else:\n            abstract = \"\"\n\n        result[pid] = {\n            \"title\": title,\n            \"abstract\": abstract\n        }\n\n    print(f\"Loaded {len(papers)} papers for matching\")\n\n    with open(pjoin(path, \"extracted_titles_and_abstracts.json\"), \"w+\") as f:\n        json.dump(result, f)\n\n    return result", "\n\ndef main(args):\n    if not os.path.isdir(args.data_path):\n        raise ValueError(f\"The passed data directory {args.data_path} does not exist\")\n\n    out_path = pjoin(args.data_path, \"COLING2020_camera_ready\")\n\n    # create output directories if necessary\n    if not os.path.exists(out_path):\n        os.mkdir(out_path)\n\n    if args.download_approved:\n        match_table = pjoin(out_path, \"COLING2020_approved.csv\")\n\n        if not os.path.exists(match_table):\n            raise ValueError(f\"The passed output directories do not contain an approved matching table. Make sure \"\n                             f\"that you manually verified the matches produced in the first step. Simply rename the \"\n                             f\"file afterwards -- the resulting file path should be {match_table}.\")\n\n        retrieve_matched(match_table, outfolder=out_path)\n    else:\n        papers = load_coling2020_papers(args.data_path)\n        fetch_camera_ready_mapping(papers, \"COLING2020\", out_path, \"external/acl-anthology/data\")", "\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Script for matching PeerRead's COLING2020 papers against\"\n                                                 \"the ACL anthology. You need to call this script from the top-most\"\n                                                 \"project directory as a working directory and have installed the\"\n                                                 \"ACL anthology package. As this requires manual evaluation of the \"\n                                                 \"matches, this is a two step script. Start the script without a\"\n                                                 \"download_approved parameter to generate a matching table and after\"\n                                                 \"approving the table (renaming it in <dataset>_approved.csv) you can\"\n                                                 \"run the script again with the download flag set to retrieve the\"\n                                                 \"matched PDFs from the ACL anthology.\")\n    parser.add_argument(\n        \"--data_path\", type=str, help=\"Path to the directory containing all datasets including a directory PeerRead \"\n                                      \"with the data to process \",\n                        required=True\n    )\n    parser.add_argument(\n        \"--download_approved\", default=False, required=False, type=bool, help=\"Downloads the matched PDFs from the \"\n                                                                              \"anthology based on the approved paper \"\n                                                                              \"tables in the output directories. You \"\n                                                                              \"need to run the command twice, \"\n                                                                              \"first without this flag and then with \"\n                                                                              \"this flag set. \"\n    )\n\n    args = parser.parse_args()\n\n    main(args)"]}
{"filename": "nlpeer/data/collect/__init__.py", "chunked_list": ["import heapq\nimport json\nimport os\nimport time\nimport urllib\n\nimport pandas as pd\nfrom tqdm import tqdm\n\n\nif \"acl-anthology\" not in os.environ[\"PYTHONPATH\"]:\n    print(\"WARNING: The ACL anthology library might be missing from your Python path! Required for matching!\")", "\n\nif \"acl-anthology\" not in os.environ[\"PYTHONPATH\"]:\n    print(\"WARNING: The ACL anthology library might be missing from your Python path! Required for matching!\")\n\nfrom anthology import Anthology\nfrom nltk.translate.bleu_score import sentence_bleu\nfrom os.path import join as pjoin\n\nANTHOLOGY_DATA_PATH = os.environ.get(\"ACL_ANTHOLOGY_DATAPATH\")", "\nANTHOLOGY_DATA_PATH = os.environ.get(\"ACL_ANTHOLOGY_DATAPATH\")\nANTHOLOGY_DATA_MAP = {\n    \"ACL2017\": \"P17\",\n    \"CONLL2016\": \"K16\",\n    \"COLING2020\": \"2020.coling\"\n}\n\n\ndef in_accepted_venue(accepted_at, paper_id):\n    return paper_id.startswith(ANTHOLOGY_DATA_MAP[accepted_at])", "\ndef in_accepted_venue(accepted_at, paper_id):\n    return paper_id.startswith(ANTHOLOGY_DATA_MAP[accepted_at])\n\n\ndef fetch_camera_ready_mapping(papers, venue, outpath, anthology_path=None):\n    if anthology_path is None:\n        anthology_path = ANTHOLOGY_DATA_PATH\n\n    a = Anthology(anthology_path)\n\n    anthology_papers = filter(lambda x: any(v for v in ANTHOLOGY_DATA_MAP.values() if x[0].startswith(v)),\n                              a.papers.items())\n    anthology_papers = list(map(lambda p: (\n        p[0], p[1].get_title(\"text\"), p[1].get_abstract(), p[1].as_citeproc_json()[0][\"author\"], p[1].pdf),\n                                anthology_papers))\n\n    misses = {}\n    matches = {}\n\n    for pid, p in tqdm(papers.items()):\n        rel_papers = filter(lambda x: in_accepted_venue(venue, x[0]), anthology_papers)\n\n        top_k = []\n        max_k = 5\n        for ap in rel_papers:\n            apid, aptitle, apabs, apauthors, apurl = ap\n\n            if \"title\" in p and p[\"title\"] is not None:\n                title_score = match_title(p[\"title\"], aptitle)\n            else:\n                title_score = 0\n\n            if \"abstract\" in p and p[\"abstract\"] is not None:\n                abs_score = match_abstracts(p[\"abstract\"], apabs)\n            else:\n                abs_score = 0\n\n            perfect_matched = (title_score > 0.9 and abs_score > 0.9)\n            certainty = (title_score + abs_score) / 2\n            uncertainty = 1 - certainty  # lower uncertainty == better == more certain\n\n            entry = {\"anthology_id\": apid,\n                     \"url\": apurl,\n                     \"title\": aptitle,\n                     \"authors\": apauthors,\n                     \"tscore\": title_score,\n                     \"absscore\": abs_score\n                     }\n\n            if perfect_matched:\n                print(f\"Perfect match on {pid}\")\n                top_k = [(uncertainty, title_score, abs_score, entry[\"anthology_id\"], entry)]\n                break\n            elif uncertainty < 0.9:\n                if len(top_k) < max_k:\n                    try:\n                        heapq.heappush(top_k, (uncertainty, title_score, abs_score, entry[\"anthology_id\"], entry))\n                    except TypeError as e:\n                        # could not replace, because there is an element with the same score\n                        # ignore\n                        heapq.heapify(top_k)\n                elif top_k[0][0] > uncertainty:\n                    try:\n                        heapq.heapreplace(top_k, (uncertainty, title_score, abs_score, entry[\"anthology_id\"], entry))\n                    except TypeError as e:\n                        # could not replace, because there is an element with the same score\n                        # ignore\n                        heapq.heapify(top_k)\n\n        if len(top_k) == 0:\n            print(f\"Miss on {pid}\")\n            misses[pid] = {\n                \"title\": p[\"title\"] if \"title\" in p else None,\n                \"accepted\": venue\n            }\n        else:\n            matches[pid] = {\n                \"title\": p[\"title\"] if \"title\" in p else None,\n                \"accepted\": venue,\n                \"matches\": [e[4] for e in top_k]\n            }\n\n    with open(os.path.join(outpath, f\"{venue}_matching.json\"), \"w+\") as file:\n        json.dump(matches, file)\n\n    if len(misses) > 0:\n        with open(os.path.join(outpath, f\"{venue}_missed.json\"), \"w+\") as file:\n            json.dump(misses, file)\n\n    df = pd.DataFrame({\"sid\": list(papers.keys()),\n                       \"title\": [p[\"title\"] for p in papers.values()],\n                       \"match\": [(matches[pid][\"matches\"][0][\"url\"] if pid in matches else \"\") for pid in\n                                 papers],\n                       \"tscore\": [(matches[sid][\"matches\"][0][\"tscore\"] if sid in matches else \"\") for sid in\n                                  papers],\n                       \"absscore\": [(matches[sid][\"matches\"][0][\"absscore\"] if sid in matches else \"\") for sid in\n                                    papers],\n                       \"other_matches\": [(len(matches[sid][\"matches\"]) if sid in matches else \"\") for sid in\n                                         papers]\n                       })\n    df.to_csv(os.path.join(outpath, f\"{venue}_to_be_approved.csv\"))", "\n\ndef match_abstracts(absPR, absACL):\n    absPR = absPR.strip().lower()\n    absACL = absACL.strip().lower()\n\n    if absPR == absACL:\n        return 1\n    else:\n        return sentence_bleu([absPR.split(\" \")], absACL.split(\" \"), weights=(1 / 3, 1 / 3, 1 / 3))  # uses 3-grams", "\n\ndef match_title(titlePR, titleACL):\n    titlePR = titlePR.strip().lower()\n    titleACL = titleACL.strip().lower()\n\n    if titlePR == titleACL:\n        return 1\n    else:\n        return sentence_bleu([titlePR.split(\" \")], titleACL.split(\" \"), weights=(2 / 3, 1 / 3))  # uses pairs", "\n\ndef aggregate_mappings(paths):\n    res = []\n\n    for p in paths:\n        df = pd.read_csv(p)\n        sid_to_match = df[[\"sid\", \"match\"]]\n        res += [sid_to_match]\n\n    res = pd.concat(res, ignore_index=True)\n\n    return list(res.transpose().to_dict().values())", "\n\ndef get_pdf(url, out):\n    for i in range(4):\n        try:\n            return urllib.request.urlretrieve(url, out)\n        except urllib.error.URLError as e:\n            print(e)\n            time.sleep(3)\n\n    print(f\">> Failed on {url}\")", "\n\ndef retrieve_matched(mapping_file, outfolder):\n    sid_to_aclurl = aggregate_mappings([mapping_file])\n    for e in tqdm(sid_to_aclurl, desc=\"Iterating over matching pairs\"):\n        sid = e[\"sid\"]\n        aclurl = e[\"match\"]\n\n        get_pdf(aclurl, pjoin(outfolder, f\"{sid}.pdf\"))\n\n    pd.DataFrame.from_records(sid_to_aclurl).to_csv(pjoin(outfolder, \"sid_to_url.csv\"))", ""]}
{"filename": "nlpeer/data/collect/peerread.py", "chunked_list": ["import argparse\nimport json\nimport os\n\nfrom nlpeer.data.collect import retrieve_matched, fetch_camera_ready_mapping\nfrom nlpeer.data.utils import list_files\nfrom os.path import join as pjoin\n\n\ndef load_peerread_papers(datapath):\n    papers = {}\n\n    for s in [\"train\", \"dev\", \"test\"]:\n        s_path = pjoin(datapath, s)\n\n        parsed_path = pjoin(s_path, \"reviews\")\n\n        for p in list_files(parsed_path):\n            pid = os.path.basename(p)[:-len('.json')]\n\n            with open(pjoin(parsed_path, f\"{pid}.json\"), \"r\") as jf:\n                reviews_for_paper = json.load(jf)\n\n            papers[pid] = {\"title\": reviews_for_paper[\"title\"], \"abstract\": reviews_for_paper[\"abstract\"]}\n\n    print(f\"Loaded {len(papers)} papers for matching\")\n\n    return papers", "\ndef load_peerread_papers(datapath):\n    papers = {}\n\n    for s in [\"train\", \"dev\", \"test\"]:\n        s_path = pjoin(datapath, s)\n\n        parsed_path = pjoin(s_path, \"reviews\")\n\n        for p in list_files(parsed_path):\n            pid = os.path.basename(p)[:-len('.json')]\n\n            with open(pjoin(parsed_path, f\"{pid}.json\"), \"r\") as jf:\n                reviews_for_paper = json.load(jf)\n\n            papers[pid] = {\"title\": reviews_for_paper[\"title\"], \"abstract\": reviews_for_paper[\"abstract\"]}\n\n    print(f\"Loaded {len(papers)} papers for matching\")\n\n    return papers", "\n\ndef main(args):\n    if not os.path.isdir(args.data_path):\n        raise ValueError(f\"The passed data directory {args.data_path} does not exist\")\n\n    if not os.path.isdir(pjoin(args.data_path, \"PeerRead\")):\n        raise ValueError(\n            f\"The passed data directory {args.data_path} does not contain the peer read corpus under PeerRead\")\n\n    acl17_path = pjoin(args.data_path, \"PeerRead\", \"data\", \"acl_2017\")\n    conll16_path = pjoin(args.data_path, \"PeerRead\", \"data\", \"conll_2016\")\n\n    if not os.path.exists(acl17_path) or not os.path.exists(conll16_path):\n        raise ValueError(\n            f\"The paths for the ACL17 and CONLL16 don't exist on these paths: {acl17_path}, {conll16_path}\")\n\n    acl17_out_path = pjoin(args.data_path, \"ACL2017_camera_ready\")\n    conll16_out_path = pjoin(args.data_path, \"CONLL2016_camera_ready\")\n\n    # create output directories if necessary\n    if not os.path.exists(acl17_out_path):\n        os.mkdir(acl17_out_path)\n\n    if not os.path.isdir(conll16_out_path):\n        os.mkdir(conll16_out_path)\n\n    if args.download_approved:\n        acl_match_table = pjoin(acl17_out_path, \"ACL2017_approved.csv\")\n        conll_match_table = pjoin(conll16_out_path, \"CONLL2016_approved.csv\")\n\n        if not os.path.exists(acl_match_table) or not os.path.exists(conll_match_table):\n            raise ValueError(f\"The passed output directories do not contain an approved matching table. Make sure \"\n                             f\"that you manually verified the matches produced in the first step. Simply rename the \"\n                             f\"file afterwards -- the resulting file paths should be {acl_match_table} and \"\n                             f\"{conll_match_table}\")\n\n        retrieve_matched(acl_match_table, outfolder=acl17_out_path)\n        retrieve_matched(conll_match_table, outfolder=conll16_path)\n    else:\n        acl17_papers = load_peerread_papers(acl17_path)\n        fetch_camera_ready_mapping(acl17_papers, \"ACL2017\", acl17_out_path, \"external/acl-anthology/data\")\n\n        conll16_papers = load_peerread_papers(conll16_path)\n        fetch_camera_ready_mapping(conll16_papers, \"CONLL16\", conll16_out_path, \"external/acl-anthology/data\")", "\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Script for matching PeerRead's ACL2017 and CONLL16 papers against\"\n                                                 \"the ACL anthology. You need to call this script from the top-most\"\n                                                 \"project directory as a working directory and have installed the\"\n                                                 \"ACL anthology package. As this requires manual evaluation of the \"\n                                                 \"matches, this is a two step script. Start the script without a\"\n                                                 \"download_approved parameter to generate a matching table and after\"\n                                                 \"approving the table (renaming it in <dataset>_approved.csv) you can\"\n                                                 \"run the script again with the download flag set to retrieve the\"\n                                                 \"matched PDFs from the ACL anthology.\")\n    parser.add_argument(\n        \"--data_path\", type=str, help=\"Path to the directory containing all datasets including a directory PeerRead \"\n                                      \"with the data to process \"\n    )\n    parser.add_argument(\n        \"--download_approved\", default=False, required=False, type=bool, help=\"Downloads the matched PDFs from the \"\n                                                                              \"anthology based on the approved paper \"\n                                                                              \"tables in the output directories. You \"\n                                                                              \"need to run the command twice, \"\n                                                                              \"first without this flag and then with \"\n                                                                              \"this flag set. \"\n    )\n\n    args = parser.parse_args()\n\n    main(args)", ""]}
{"filename": "nlpeer/data/annotate/explicit_links.py", "chunked_list": ["import argparse\nimport json\nimport logging\nimport os\nimport re\nfrom os.path import join as pjoin\nfrom typing import List, Tuple, Dict\n\nimport fuzzysearch\nimport pandas as pd", "import fuzzysearch\nimport pandas as pd\nfrom intertext_graph.itgraph import IntertextDocument, SpanNode\nfrom tqdm import tqdm\n\nfrom nlpeer import NTYPE_TITLE, NTYPE_HEADING, NTYPE_ABSTRACT, NTYPE_FIGURE, NTYPE_TABLE, NTYPE_BIB_ITEM, DATASETS\nfrom nlpeer.data.utils import list_dirs, list_files\n\nOUT_PATH = os.environ.get(\"OUT_PATH\")\n", "OUT_PATH = os.environ.get(\"OUT_PATH\")\n\nfrom external.f1000rd.analysis.exp_linker import replace_ordinal_string_with_number, \\\n    split_quote, strip_numbers_from_title\n\n\ndef store_collection_meta(meta, base_path):\n    if os.path.exists(pjoin(base_path, \"meta.json\")):\n        with open(pjoin(base_path,\"meta.json\"), \"r\") as f:\n            prev = json.load(f)\n    else:\n        prev = {}\n\n    prev[\"ELINKS\"] = meta\n    with open(pjoin(base_path, \"meta.json\"), \"w+\") as f:\n        json.dump(prev, f)", "\n\n# adapted from F1000RD/analysis/exp_linker\ndef load_static_patterns(path=None):\n    def_path = \"resources/exp_patterns.tsv\" if path is None else path\n\n    logging.info(f\"Loading static patterns from {def_path}\")\n\n    # static patterns\n    patterns_df = pd.read_csv(\n        def_path,\n        delimiter='\\t'\n    )\n    return [\n        (row.pattern, row.type)\n        for row in patterns_df.itertuples()\n    ]", "\n\n# adapted from F1000RD/analysis/exp_linker\ndef load_patterns(paper_doc: IntertextDocument):\n    # get headings\n    headings = []\n    for node in paper_doc.nodes:\n        if node.ntype == NTYPE_HEADING:\n            headings += [node.content]\n        elif node.ntype == NTYPE_ABSTRACT:\n            headings += [node.content]\n\n    # generate patterns from headings\n    hd_patterns = make_patterns_from_section_titles(headings)\n\n    return hd_patterns", "\n# adapted from F1000RD\ndef make_patterns_from_section_titles(section_titles: [str]):\n    \"\"\"\n    Make patterns from section titles\n    strip off numbering\n    \"\"\"\n\n    # Lambda functions that return regex patterns\n    TEMPLATES = [\n        lambda x: rf'^.{{,3}}(?P<ix>{x}).{{,3}}$', # Review headline with section title\n        lambda x: rf'\\bthe (?P<ix>{x})', # \"the results\"\n        lambda x: rf'^.{{,3}}(?P<ix>{x}) ?[-:;.]', # \"Results: bla bla\"\n        lambda x: rf'(in|under) (?P<ix>{x})', # \"in methods\"\n        lambda x: rf'\\b[\"\u201d\u201c\u2018\u2019\\'\u00ab\u2039\u00bb\u203a\u201e\u201c\u201f\u201d\u2019\u275d\u275e\u276e\u276f\u2e42\u301d\u301e\u301f\uff02\u201a\u2018\u201b\u275b\u275c\u275f](?P<ix>{x})[\"\u201d\u201c\u2018\u2019\\'\u00ab\u2039\u00bb\u203a\u201e\u201c\u201f\u201d\u2019\u275d\u275e\u276e\u276f\u2e42\u301d\u301e\u301f\uff02\u201a\u2018\u201b\u275b\u275c\u275f]\\b'\n        # Section title in quotation marks of various kinds\n    ]\n\n    # Make pattern for each combination of section title and pattern template\n    patterns = []\n    for section_title in section_titles:\n        for template_func in TEMPLATES:\n            stripped_title = strip_numbers_from_title(re.escape(section_title.lower()))\n            pattern = template_func(stripped_title)\n            patterns.append((pattern, 'sec-name'))\n\n    return patterns", "\n# adapted from F1000RD/analysis/exp_linker\ndef find_pointers(txt: str, patterns: List[Tuple[str, str]]) -> List[Tuple[str, str]]:\n    out = []\n    for pat, cat in patterns:\n        res = re.finditer(pat, txt.lower())\n        for r in res:\n            value = r.group('ix')\n            value = replace_ordinal_string_with_number(\n                value\n            )\n            out += [(cat, value, r.regs[0])]\n\n    return out", "\n# extended F1000RD\ndef find_targets_for_sec_name(tgt_itg: IntertextDocument, match_text: str):\n    \"\"\"Handle \"sec-name\" matches\"\"\"\n    ret = []\n    META = {\n        'exp': ['sec-name']\n    }\n\n    # Handle title, abstract and regular section names separately, because\n    # they link to different ntypes\n    if match_text == 'title':\n        for tgt_node in tgt_itg.nodes:\n            if tgt_node.ntype == NTYPE_TITLE:\n                ret.append(tuple((META, tgt_node)))\n    elif match_text == 'abstract':\n        for tgt_node in tgt_itg.nodes:\n            if tgt_node.ntype == NTYPE_ABSTRACT:\n                ret.append(tuple((META, tgt_node)))\n    else:\n        for tgt_node in tgt_itg.nodes:\n            if tgt_node.ntype == NTYPE_HEADING:\n                if match_text in tgt_node.content.lower():\n                    ret.append(tuple((META, tgt_node)))\n\n    return ret", "\n#extended F1000RD\ndef find_targets_for_sec_ix(tgt_itg: IntertextDocument, match_text: str):\n    \"\"\"Handle section index matches\"\"\"\n    ret = []\n    META = {\n        'exp': ['sec-ix']\n    }\n\n    for tgt_node in tgt_itg.nodes:\n        if tgt_node.ntype == NTYPE_HEADING:\n            try:\n                if tgt_node.meta['section'] == match_text:\n                    ret.append(tuple((META, tgt_node)))\n            except KeyError:\n                continue\n\n    return ret", "\n# extended F1000RD\ndef find_targets_for_fig_ix(tgt_itg: IntertextDocument, match_text: str):\n    \"\"\"Handles figure index matches\"\"\"\n    ret = []\n    META = {\n        'exp': ['fig-ix']\n    }\n\n    for tgt_node in tgt_itg.nodes:\n        if tgt_node.ntype == NTYPE_FIGURE:\n            try:\n                if tgt_node.meta['label'] == f'{match_text}':\n                    ret.append(tuple((META, tgt_node)))\n            except KeyError:\n                continue\n\n    return ret", "\n# extended F1000RD\ndef find_targets_for_table_ix(tgt_itg: IntertextDocument,  match_text: str):\n    \"\"\"Handles table index matches\"\"\"\n    ret = []\n    META = {\n        'exp': ['table-ix']\n    }\n\n    for tgt_node in tgt_itg.nodes:\n        if tgt_node.ntype == NTYPE_TABLE:\n            try:\n                if tgt_node.meta['label'] == f'{match_text}':\n                    ret.append(tuple((META, tgt_node)))\n            except KeyError:\n                continue\n\n    return ret", "\n# from F1000RD\ndef find_targets_for_quote(tgt_itg: IntertextDocument, match_text: str):\n    \"\"\"Find targets for quotes\"\"\"\n\n    # Hard code the hyperparameters\n    # The maximum Levenshtein distance for two strings to be counted as a match\n    # The higher the value, the more hits are obtained (probably resulting in lower\n    # precision)\n    MAX_LEVENSHTEIN_DISTANCE = 2\n    # The maximum number of hits for a single quote\n    # This is to not bet trapped by very unspecific quotes / partial quotes such as \"and\",\n    # which have countless hits\n    # A higher number probably increases recall, but reduces precision\n    MAX_N_HITS = 2\n\n    ret = []\n    META={\n        'exp': ['quote']\n    }\n\n    # Split quote when it has gaps (\"bla [...] bla\")\n    partial_quotes = split_quote(match_text)\n\n    # For each split check if matches can be found\n    for tgt_node in tgt_itg.nodes:\n        if type(tgt_node) == SpanNode:\n            continue\n\n        partial_quote_idx = 0\n        content_start_pos = 0\n        match = True\n\n        # Go over each partial quote, look for matches\n        # If match found, for the next quote only look for matches after\n        # the previously found match\n        while (partial_quote_idx < len(partial_quotes)) & match:\n            partial_quote = partial_quotes[partial_quote_idx]\n            search_res = fuzzysearch.find_near_matches(\n                partial_quote,\n                tgt_node.content[content_start_pos:].lower(),\n                max_l_dist=MAX_LEVENSHTEIN_DISTANCE\n            )\n\n            if len(search_res) > 0:\n                top_res = sorted(search_res, key=lambda x: x.dist)[0]\n                content_start_pos = top_res.end + 1\n                partial_quote_idx += 1\n            else:\n                match = False\n\n        if match:\n            ret.append(tuple((META, tgt_node)))\n\n            # Check if more than MAX_N_HITS matches were found for the quote\n            # If yes, return no results\n            if len(ret) > MAX_N_HITS:\n                ret = []\n                break\n\n    return ret", "\ndef find_targets_for_ref_ix(tgt_itg: IntertextDocument,  match_text: str):\n    \"\"\"Find links to references\"\"\"\n    ret = []\n    META = {\n        'exp': ['ref-ix']\n    }\n\n    for tgt_node in tgt_itg.nodes:\n        if (tgt_node.ntype == NTYPE_BIB_ITEM):\n            try:\n                if tgt_node.meta['id'] == f'ref-{match_text}':\n                    ret.append(tuple((META, tgt_node)))\n            except KeyError:\n                continue\n\n    return ret", "\n\ndef find_targets_for_line(tgt_itg: IntertextDocument, match_text: str):\n    \"\"\" Find links for line references\"\"\"\n    ret = []\n    META = {\n        'exp': ['line']\n    }\n\n    for tgt_node in tgt_itg.nodes:\n        if type(tgt_node) == SpanNode and tgt_node.ntype == \"line\":\n            l = tgt_node.meta[\"line\"]\n            if int(l) == int(match_text):\n                ret += [(META, tgt_node)]\n                break  # perfect match, break\n        elif type(tgt_node) == SpanNode and tgt_node.ntype == \"line_range\":\n            ls, le = tgt_node.meta[\"line_start\"], tgt_node.meta[\"line_end\"]\n            if int(ls) <= int(match_text) <= int(le):\n                ret += [(META, tgt_node)]\n                # range match, continue looking for perfect matches\n\n    if len(ret) > 1:\n        line_node = [(m, t) for (m, t) in ret if \"line\" in t.meta]\n        if len(line_node) > 0:\n            return line_node\n        else:\n            best_range, best_match = int(ret[0][1].meta[\"line_end\"]) - int(ret[0][1].meta[\"line_start\"]), ret[0]\n            for m, t in ret[1:]:\n                w = int(t.meta[\"line_end\"]) - int(t.meta[\"line_start\"])\n                if w < best_range:\n                    best_range = w\n                    best_match = (m, t)\n            return [best_match]\n    else:\n        return ret", "\n\n# extended F1000RD\ndef find_anchors_for_match(doc, match):\n    mtype, mtxt = match\n\n    if mtype == 'sec-name':\n        return find_targets_for_sec_name(doc, mtxt)\n    elif mtype == 'sec-ix':\n        return find_targets_for_sec_ix(doc, mtxt)\n    elif mtype == 'fig-ix':\n        return find_targets_for_fig_ix(doc, mtxt)\n    elif mtype == 'table-ix':\n        return find_targets_for_table_ix(doc, mtxt)\n    elif mtype == 'quote':\n        return find_targets_for_quote(doc, mtxt)\n    elif mtype == 'ref-ix':\n        return find_targets_for_ref_ix(doc, mtxt)\n    elif mtype == \"line\":\n        return find_targets_for_line(doc, mtxt)\n    else:\n        return None", "\n# adapted from F1000RD/analysis/exp_linker\ndef find_anchors_in_paper(pointers, paper):\n    links = {}\n    for sec in pointers:\n        pointer_types = list(set([(t, txt) for (t, txt, span) in pointers[sec]]))\n        links_by_type = []\n\n        for match in pointer_types:\n            found_targets = find_anchors_for_match(paper, match)\n            if found_targets is None or len(found_targets) == 0:\n                links_by_type += [None]\n            else:\n                links_by_type += [(match, found_targets[0][0], found_targets[0][1])]\n\n        links[sec] = [[(pt,l) for pt, l in zip(pointer_types, links_by_type) if pt[0] == pointer[0] and pt[1] == pointer[1]][0][1] for pointer in pointers[sec]]\n\n    return links", "\n\ndef find_pointers_in_review(review, patterns):\n    report = review[\"report\"]\n\n    pointers = {}\n    for sec in report:\n        section = report[sec]\n\n        if section is None:\n            continue\n\n        pointers[sec] = find_pointers(section, patterns)\n\n    return pointers", "\n\ndef create(dataset_type: DATASETS, bm_path=None):\n    # paths\n    bm_path = OUT_PATH if bm_path is None else bm_path\n    dataset_path = pjoin(bm_path, dataset_type.value, \"data\")\n    out_path =pjoin(bm_path, dataset_type.value, \"annotations\")\n\n    if not os.path.exists(out_path):\n        os.mkdir(out_path)\n\n    # meta info on dataset\n    collection_meta = {\n        \"dataset\": \"Benchmark Explicit Links by F1000RD REGEX Linker\",\n        \"annotation_types\": [\n            \"elinks\"\n        ]\n    }\n    store_collection_meta(collection_meta, out_path)\n\n    # load patterns\n    static_patterns = load_static_patterns()\n\n    # iterate papers and reviews\n    for ppath in tqdm(list_dirs(dataset_path), desc=\"iterating over papers\"):\n        pid = os.path.basename(ppath)\n\n        for vpath in list_dirs(ppath):\n            version = os.path.basename(vpath)\n\n            if \"reviews.json\" not in [os.path.basename(f) for f in list_files(vpath)]:\n                continue\n\n            # input\n            with open(pjoin(vpath, \"paper.itg.json\"), \"r\") as f:\n                pdoc = IntertextDocument.load_json(f)\n\n            with open(pjoin(vpath, \"reviews.json\"), \"r\") as f:\n                reviews = json.load(f)\n\n            if len(reviews) == 0:\n                continue\n\n            # do matching\n            dyn_patterns = load_patterns(pdoc)\n\n            links_per_rev = {}\n            pointers_per_rev = {}\n            for r in reviews:\n                pointers = find_pointers_in_review(r, static_patterns + dyn_patterns)\n                links = find_anchors_in_paper(pointers, pdoc)\n\n                pointers_per_rev[r[\"rid\"]], links_per_rev[r[\"rid\"]] = pointers, links\n\n            # output\n            output = {}\n            for rid in pointers_per_rev:\n                pointers, links = pointers_per_rev[rid], links_per_rev[rid]\n                output[rid] = {}\n\n                for sec in pointers:\n                    output[rid][sec] = []\n\n                    for p, l in zip(pointers[sec], links[sec]):\n                        ptype, ptxt, pspan = p\n\n                        if l is None:\n                            output[rid][sec] += [{\n                                \"type\": ptype,\n                                \"rev_span\": pspan,\n                                \"rev_text\": ptxt,\n                                \"paper_target\": None\n                            }]\n                        else:\n                            lmatch, lmeta, lnode = l\n\n                            output[rid][sec] += [{\n                                \"type\": ptype,\n                                \"rev_span\": pspan,\n                                \"rev_text\": ptxt,\n                                \"paper_target\": lnode.ix\n                            }]\n\n            links_out_path = pjoin(out_path, pid, version, \"elinks.json\")\n            if not os.path.exists(pjoin(out_path, pid)):\n                os.mkdir(pjoin(out_path, pid))\n            if not os.path.exists(pjoin(out_path, pid, version)):\n                os.mkdir(pjoin(out_path, pid, version))\n\n            with open(links_out_path, \"w+\") as f:\n                json.dump(output, f)", "\n\ndef arg_parse():\n    parser = argparse.ArgumentParser(description=\"Creating the F1000 dataset within the benchmark\")\n    parser.add_argument(\n        \"--bm_path\", type=str, required=True, help=\"Path to the directory of the benchmark dataset\"\n    )\n    parser.add_argument(\n        \"--dataset_type\", type=str, required=False, choices=[d.name for d in DATASETS], default=None, help=\"Dataset type\"\n    )\n\n    return parser", "\n\ndef main(args):\n    logging.basicConfig(level=\"INFO\")\n\n    if args.dataset_type is None:\n        for d in DATASETS:\n            create(d, args.bm_path)\n    else:\n        create(DATASETS[args.dataset_type], args.bm_path)", "\nif __name__ == \"__main__\":\n    parser = arg_parse()\n    main(parser.parse_args())"]}
{"filename": "nlpeer/data/annotate/__init__.py", "chunked_list": [""]}
{"filename": "nlpeer/data/annotate/f1000rd.py", "chunked_list": ["import argparse\nimport json\nimport logging\nimport os\nimport re\n\nfrom os.path import join as pjoin\n\nimport fuzzysearch\nimport pandas as pd", "import fuzzysearch\nimport pandas as pd\nfrom intertext_graph.itgraph import IntertextDocument, SpanNode\nfrom nltk.translate.bleu_score import sentence_bleu\nfrom tqdm import tqdm\n\nfrom nlpeer import NTYPE_ABSTRACT\nfrom nlpeer.data.datasets.utils import get_review_sentences\nfrom nlpeer.data.utils import list_dirs, list_files\n", "from nlpeer.data.utils import list_dirs, list_files\n\nDATA_PATH = os.environ.get(\"F1000_RD_PATH\")\nOUT_PATH = os.environ.get(\"OUT_PATH\")\n\n\ndef store_collection_meta(meta, base_path):\n    if os.path.exists(pjoin(base_path, \"meta.json\")):\n        with open(pjoin(base_path,\"meta.json\"), \"r\") as f:\n            prev = json.load(f)\n    else:\n        prev = {}\n\n    prev[\"F1000RD\"] = meta\n    with open(pjoin(base_path, \"meta.json\"), \"w+\") as f:\n        json.dump(prev, f)", "\n\ndef load_review_reports(path):\n    revs = {}\n    rid_map = {}\n    for paper_path in list_dirs(path):\n        pid = os.path.basename(paper_path)\n\n        revs[pid] = {}\n        for r in list_files(pjoin(paper_path, \"reviews\")):\n            with open(r, \"r\") as f:\n                report = IntertextDocument.load_json(f)\n\n            rid = os.path.basename(r)[:-len(\".json\")]\n            revs[pid][rid] = report\n            rid_map[rid] = pid\n\n    return revs, rid_map", "\n\ndef load_papers(path):\n    papers = {}\n    for paper_path in list_dirs(path):\n        pid = os.path.basename(paper_path)\n\n        with open(pjoin(paper_path, \"v1.json\"), \"r\") as f:\n            papers[pid] = IntertextDocument.load_json(f)\n\n    return papers", "\n\ndef match_and_update_review_sentences(review_rd:IntertextDocument, review_orig):\n    new_sentences = []\n    matched = {}\n    review_text = review_orig[\"report\"][\"main\"]\n    review_sentences = get_review_sentences(review_orig)[\"main\"]\n    review_sentences_cleaned = [re.sub(\"[^A-Za-z1-9 \\-]\", \"\", s.lower()).strip() for s in review_sentences]\n\n    unmatched = []\n    for snode in review_rd.nodes:\n        if type(snode) != SpanNode:\n            continue\n\n        sentence = snode.content\n\n        # perfect match -- add to matches, done\n        start_match, end_match = -1, -1\n        if sentence.lower() in review_text.lower():\n            start_match = review_text.lower().find(sentence.lower())\n            end_match = start_match + len(sentence)\n        else:\n            search_res = fuzzysearch.find_near_matches(\n                sentence.lower(),\n                review_text.lower(),\n                max_l_dist=2\n            )\n\n            if 0 < len(search_res) <= 3:\n                best = list(sorted(search_res, key= lambda x: x.dist))[0]\n                start_match = best.start\n                end_match = best.end\n\n        if start_match < 0:\n            unmatched += [(snode.start, snode.end, sentence)]\n            continue\n\n        new_sentences += [(start_match, end_match)]\n        matched[snode.ix] = len(new_sentences) - 1\n\n    review_orig[\"meta\"][\"sentences\"][\"main\"] = [[nsent[0], nsent[1]] for nsent in new_sentences]\n\n    return matched, unmatched", "\n\ndef annotate_review_sentences(sentence_mapping, label_map):\n    errors = []\n    annotations = {}\n    for six, label in label_map.items():\n        if six in sentence_mapping:\n            annotations[sentence_mapping[six]] = label\n        else:\n            errors += [six]\n\n    return annotations, errors", "\n\ndef match_and_update_paper_sentences(paper_rd: IntertextDocument, paper_orig:IntertextDocument):\n    def is_in_node(sentence, node):\n        return sentence.lower().strip() in node.content.lower()\n\n    def heuristic_match(sentence):\n        # todo\n        return None\n\n    # add sentence nodes from the F1000RD version\n    matched = {}\n    matched_nodes = {}\n    unmatched = []\n    for snode in paper_rd.nodes:\n        if type(snode) != SpanNode or snode.ntype != \"s\":\n            continue\n\n        sentence = snode.content\n\n        match = False\n        for cnode in paper_orig.nodes:\n            if type(cnode) == SpanNode:\n                continue\n\n            # account for listings, which are represented differently in F1000RD\n            if not is_in_node(sentence, cnode):\n                while sentence[0] == \"-\":\n                    sentence = sentence[1:]\n\n            if is_in_node(sentence, cnode):\n                start_orig = cnode.content.lower().find(sentence.lower())\n                matched[snode.ix] = (cnode.ix, start_orig, start_orig + len(sentence.strip().lower()))\n                matched_nodes[snode.src_node.ix] = cnode.ix\n                match = True\n                break\n\n        if not match:\n            # special case \"abstract\"\n            if sentence.lower().strip() == \"abstract\":\n                oanode, osnode = None, None\n                oanodes = [n for n in paper_orig.nodes if n.ntype == NTYPE_ABSTRACT]\n                if len(oanodes) > 0:\n                    oanode = oanodes[0]\n                    osnodes = [n for n in paper_orig.nodes if type(n) == SpanNode and n.ntype == \"s\" and n.src_node.ix == oanode.ix]\n\n                    if len(osnodes) > 0:\n                        osnode = osnodes[0]\n\n                if oanode is not None:\n                    matched[snode.ix] = (oanode.ix, osnode.start, osnode.end)\n                    matched_nodes[snode.src_node.ix] = oanode.ix\n            else:\n                best_match = heuristic_match(sentence)    # not implemented atm\n\n                if best_match is None:\n                    unmatched += [(snode.start, snode.end, sentence)]\n                else:\n                    matched[snode.ix] = (best_match[0].ix, best_match[1], best_match[2])\n                    matched_nodes[snode.src_node.ix] = best_match[0].ix\n\n    # extend node matching by exact texts\n    for cnode in paper_rd.nodes:\n        if type(cnode) == SpanNode or cnode.ix in matched_nodes:\n            continue\n\n        c = cnode.content.strip().lower()\n\n        for conode in paper_orig.nodes:\n            if type(conode) == SpanNode:\n                continue\n\n            if c == conode.content.strip().lower():\n                matched_nodes[cnode.ix] = conode.ix\n\n    # delete previous setence nodes\n    to_delete = []\n    for n in paper_orig.nodes:\n        if type(n) == SpanNode and n.ntype == \"s\":\n            to_delete += [n]\n\n    for n in to_delete:\n        paper_orig.remove_node(n)\n\n    match_map = {}\n    for rd_ix in matched:\n        orig_ix, orig_start, orig_end = matched[rd_ix]\n        sentNode = SpanNode(ntype=\"s\",\n                            src_node=paper_orig.get_node_by_ix(orig_ix),\n                            start=orig_start,\n                            end=orig_end,\n                            meta=paper_rd.get_node_by_ix(rd_ix).meta)\n        #todo update ix to match pattern of pid_ver_nodenum@sentnum\n        paper_orig.add_node(sentNode)\n        match_map[rd_ix] = sentNode.ix\n\n    return match_map, matched_nodes, unmatched", "\n\ndef create(in_path=None, out_path=None):\n    # paths\n    in_path = DATA_PATH if in_path is None else in_path\n    out_path = OUT_PATH if out_path is None else out_path\n\n    out_f1000_path = pjoin(out_path, \"F1000\", \"data\")\n    out_annotations_path = pjoin(out_path, \"F1000\", \"annotations\")\n\n    assert out_path is not None and in_path is not None, \"Cannot create F1000RD dataset. In and/or out paths are \" \\\n                                                         \"missing! \"\n\n    logging.info(f\"Loading data from {in_path}\")\n    logging.info(f\"Storing data at {out_path}\")\n\n    if not os.path.exists(out_annotations_path):\n        os.mkdir(out_annotations_path)\n\n    # paths\n    prag_path = pjoin(in_path, \"data\", \"simple\", \"prag.csv\")\n    exp_links_path = pjoin(in_path, \"data\", \"simple\", \"exp_links.csv\")\n    imp_links_path = pjoin(in_path, \"data\", \"simple\", \"imp_links.csv\")\n    itgs_path = pjoin(in_path, \"data\", \"itg\")\n\n    # meta info on dataset\n    collection_meta = {\n        \"dataset_timestamp\": os.path.getmtime(itgs_path),\n        \"origin_dataset\": \"F1000RD\",\n        \"annotation_types\": [\n            \"rd_review_pragmatics\",\n            \"rd_elinks\",\n            \"rd_ilinks\"\n        ]\n    }\n    with open(pjoin(in_path, \"LICENSE.txt\"), \"r\") as f:\n        collection_meta[\"license\"] = f.read().strip()\n\n    store_collection_meta(collection_meta, out_annotations_path)\n\n    # load review reports per paper and papers\n    pid_to_reviews, rid_map = load_review_reports(itgs_path)\n    pid_to_papers = load_papers(itgs_path)\n\n    # copying review annotations\n    logging.info(\"Adding annotations from F1000RD to F1000/annotations\")\n\n    prags = pd.read_csv(prag_path, header=0)\n    elinks = pd.read_csv(exp_links_path, header=0)\n    ilinks = pd.read_csv(imp_links_path, header=0)\n\n    match_error = []\n    anno_error = []\n    prag_annotations, elink_annotations, ilink_annotations = {}, {}, {}\n    for rid in tqdm(rid_map, desc=\"Iterating over reviews\"):\n        pid = rid_map[rid]\n        rd_review = pid_to_reviews[pid][rid]\n        rd_paper = pid_to_papers[pid]\n\n        # get reference review from F1000 to transfer annotations\n        orig_reviews_path = pjoin(out_f1000_path, pid, \"v1\", \"reviews.json\")\n        with open(orig_reviews_path, \"r\") as f:\n            orig_reviews = json.load(f)\n        orig_review = next(r for r in orig_reviews if r[\"rid\"] == rid)\n\n        # update sentences in the review\n        rev_matched_sents, rev_unmatched_sents = match_and_update_review_sentences(rd_review, orig_review)\n        if len(rev_unmatched_sents) > 0:\n            match_error += [(\"review\", rid, r) for r in rev_unmatched_sents]\n\n        # store changed review sentences\n        with open(orig_reviews_path, \"w+\") as f:\n            json.dump(orig_reviews, f)\n\n        # get reference paper from F1000 to transfer annotations\n        orig_paper_path = pjoin(out_f1000_path, pid, \"v1\", \"paper.itg.json\")\n        with open(orig_paper_path, \"r\") as f:\n            orig_paper = IntertextDocument.load_json(f)\n\n        # update paper sentences\n        paper_matched_sents, matched_nodes, paper_unmatched_sents = match_and_update_paper_sentences(rd_paper, orig_paper)\n        if len(paper_unmatched_sents) > 0:\n            match_error += [(\"paper\", pid, r) for r in paper_unmatched_sents]\n        paper_matched_sents.update(matched_nodes)\n\n        # store changed paper sentences\n        with open(orig_paper_path, \"w+\")as f:\n            orig_paper.save_json(f)\n\n        # pragmatics\n        pmap = {}\n        for _, pentry in prags[prags.review_id == rid].iterrows():\n            pmap[pentry[\"review_sentence_id\"]] = pentry[\"prag\"]\n        pannos, errs = annotate_review_sentences(rev_matched_sents, pmap)\n\n        anno_error += [(\"prag\", pid, rid, e) for e in errs]\n\n        if pid not in prag_annotations:\n            prag_annotations[pid] = {}\n        if rid not in prag_annotations[pid]:\n            prag_annotations[pid][rid] = pannos\n\n        # explicit links\n        errs = explicit_link_annotations(elink_annotations, elinks, paper_matched_sents, pid, rev_matched_sents, rid, orig_review)\n        anno_error += [(\"elink\", pid, rid, e) for e in errs]\n\n        # implicit links\n        errs = implicit_link_annotations(ilink_annotations, ilinks, paper_matched_sents, pid,\n                                 rev_matched_sents, rid)\n        anno_error += [(\"ilink\", pid, rid, e) for e in errs]\n\n    # ignore boilerplate not matched errors\n    anno_error = [e for e in anno_error if not(e[0] == \"prag\" and e[-1].endswith(\"_0@0\"))]\n\n    # write to annotations\n    for o, a in [(\"rd_review_pragmatics\", prag_annotations),\n                 (\"rd_elinks\", elink_annotations),\n                 (\"rd_ilinks\", ilink_annotations)]:\n        for pid in a:\n            if len(a[pid]) == 0:\n                continue\n\n            if not os.path.exists(pjoin(out_annotations_path, pid)):\n                os.mkdir(pjoin(out_annotations_path, pid))\n            if not os.path.exists(pjoin(out_annotations_path, pid, \"v1\")):\n                os.mkdir(pjoin(out_annotations_path, pid, \"v1\"))\n\n            p_path = pjoin(out_annotations_path, pid, \"v1\", f\"{o}.json\")\n            with open(p_path, \"w+\") as f:\n                json.dump(a[pid], f)\n\n    # log errors\n    logging.info(\"Matching Errors\")\n    for e in match_error:\n        if e[2][2].strip().startswith(\"Reviewer response for version\"):\n            continue\n\n        logging.info(f\"Failed to match for {e[0]} {e[1]} with start= {e[2][0]}; end= {e[2][1]} and sentence: {e[2][2]}\")\n\n    logging.warning(\"Annotation Transfer Errors\")\n    for e in anno_error:\n        logging.warning(f\"Failed to transfer annotations: {e}\")", "\n\ndef implicit_link_annotations(ilink_annotations, ilinks, paper_matched_sents, pid, rev_matched_sents,\n                             rid):\n    errors = []\n    rows = list(ilinks[ilinks.review_id == rid].iterrows())\n    if len(rows) > 0:\n        if pid not in ilink_annotations:\n            ilink_annotations[pid] = {}\n        if rid not in ilink_annotations[pid]:\n            ilink_annotations[pid][rid] = {}\n\n        for _, entry in rows:\n            new_rsent_id = rev_matched_sents[entry[\"review_sentence_id\"]] if entry[\n                                                                                 \"review_sentence_id\"] in rev_matched_sents else None\n            new_psent_id = paper_matched_sents[entry[\"paper_sentence_id\"]] if entry[\n                                                                                  \"paper_sentence_id\"] in paper_matched_sents else None\n\n            imp_a = entry[\"imp_a\"] if pd.notna(entry[\"imp_a\"]) else 0\n            imp_b = entry[\"imp_b\"] if pd.notna(entry[\"imp_b\"]) else 0\n            linked = int(imp_a) + int(imp_b)\n\n            if linked > 0 and (new_psent_id is None or new_rsent_id is None):\n                errors += [(entry[\"review_sentence_id\"], entry[\"paper_sentence_id\"])]\n                continue\n\n            if linked > 0:\n                ilink_annotations[pid][rid][new_rsent_id] = (new_psent_id, linked)\n\n    return errors", "\n\ndef explicit_link_annotations(elink_annotations, elinks, paper_matched_sents, pid, rev_matched_sents, rid, review):\n    errors = []\n    rows = list(elinks[elinks.review_id == rid].iterrows())\n    if len(rows) > 0:\n        if pid not in elink_annotations:\n            elink_annotations[pid] = {}\n        if rid not in elink_annotations[pid]:\n            elink_annotations[pid][rid] = {\"main\": []}\n\n        for _, entry in rows:\n            new_rsent_id = rev_matched_sents[entry[\"review_sentence_id\"]] if entry[\n                                                                                 \"review_sentence_id\"] in rev_matched_sents else None\n            new_psent_id = paper_matched_sents[entry[\"paper_sentence_id\"]] if entry[\n                                                                                  \"paper_sentence_id\"] in paper_matched_sents else None\n\n            if new_psent_id is None or new_rsent_id is None:\n                errors += [(entry[\"type\"], entry[\"review_sentence_id\"], entry[\"paper_sentence_id\"], entry[\"review_text\"], entry[\"paper_text\"])]\n                continue\n\n            sent_span = review[\"meta\"][\"sentences\"][\"main\"][int(new_rsent_id)]\n            sent = review[\"report\"][\"main\"][sent_span[0]: sent_span[1]]\n\n            elink_annotations[pid][rid][\"main\"] += [{\"type\": entry[\"type\"], \"rev_span\": sent_span, \"rev_text\": sent}]\n\n    return errors", "\n\ndef arg_parse():\n    parser = argparse.ArgumentParser(description=\"Creating the F1000 dataset within the benchmark\")\n    parser.add_argument(\n        \"--data_path\", type=str, help=\"Path to the directory of the F1000 dataset.\"\n    )\n    parser.add_argument(\n        \"--output_directory\", type=str, help=\"Path to the top directory of the benchmark dataset.\"\n    )\n\n    return parser", "\n\ndef main(args):\n    logging.basicConfig(level=\"INFO\")\n\n    create(args.data_path, args.output_directory)\n\n\nif __name__ == \"__main__\":\n    parser = arg_parse()\n    main(parser.parse_args())", "if __name__ == \"__main__\":\n    parser = arg_parse()\n    main(parser.parse_args())"]}
{"filename": "nlpeer/tasks/__init__.py", "chunked_list": ["import random\nfrom typing import Tuple, List\n\nimport numpy as np\nimport sklearn\nimport sklearn.metrics\nimport spacecutter.losses\nimport torch\nimport torchmetrics\nfrom intertext_graph import Node, Etype, IntertextDocument, SpanNode", "import torchmetrics\nfrom intertext_graph import Node, Etype, IntertextDocument, SpanNode\nfrom torch.nn import CrossEntropyLoss, NLLLoss\nfrom torch.optim import AdamW\nfrom torch.utils.data import Dataset\n\nfrom nlpeer.data import paperwise_stratified_split\nfrom nlpeer import NTYPE_TITLE, NTYPE_HEADING, NTYPE_PARAGRAPH, NTYPE_ABSTRACT, DATASETS, ANNOTATION_TYPES, \\\n    DATASET_REVIEW_OVERALL_SCALES, PaperReviewDataset, ReviewPaperDataset, PaperReviewAnnotations\n", "    DATASET_REVIEW_OVERALL_SCALES, PaperReviewDataset, ReviewPaperDataset, PaperReviewAnnotations\n\n\ndef get_optimizer(name):\n    if name == \"adam\":\n        return AdamW\n    else:\n        raise ValueError(\"Unknown optimizer\")\n\n\ndef get_loss_function(name, **kwargs):\n    name = name.lower()\n\n    if name == \"mse\":\n        return torch.nn.MSELoss()\n    elif name == \"mrse\":\n        return lambda x, y: torch.sqrt(torch.nn.MSELoss()(x, y)) #fixme\n    elif name == \"cll\": # cumulative link loss\n        ## https://people.csail.mit.edu/jrennie/papers/ijcai05-preference.pdf\n        ## https://fa.bianp.net/blog/2013/loss-functions-for-ordinal-regression/\n        ## https://www.ethanrosenthal.com/2018/12/06/spacecutter-ordinal-regression/\n        return spacecutter.losses.CumulativeLinkLoss()\n    elif name == \"ce\":\n        return CrossEntropyLoss()\n    elif name == \"nll\":\n        return NLLLoss()\n    elif name == \"nll-weighted\":\n        return NLLLoss(weight=torch.tensor([0.4, 0.6]))\n    elif name == \"acc_reg_3\":\n        def acc_at_reg_intervals_3(x, y):\n            acc = torchmetrics.Accuracy().cuda()\n\n            x2 = torch.add(torch.round(torch.multiply(x, 2)), 1).to(torch.int)\n            y2 = torch.add(torch.round(torch.multiply(y, 2)), 1).to(torch.int)\n            return acc(x2, y2)\n\n        return acc_at_reg_intervals_3\n    elif name == \"acc\":\n        return torchmetrics.Accuracy()\n    elif name == \"f1-micro\":\n        return lambda x, y: sklearn.metrics.f1_score(x, y, average=\"micro\")\n    elif name == \"f1-macro\":\n        return lambda x, y: sklearn.metrics.f1_score(x, y, average=\"macro\")\n    elif name == \"f1-macro-rounded\":\n        sc = kwargs[\"score_range\"]\n\n        def metric(x, y):\n            print(\"x......\", x.tolist())\n            print(\"y.......\", y.tolist())\n\n            xh = histogram([(s-min(sc)) / (max(sc) - min(sc)) for s in sc], x.tolist())\n            yh = histogram([(s-min(sc)) / (max(sc) - min(sc)) for s in sc], y.tolist())\n            print(\"xh\", xh)\n            print(\"yh\", yh)\n\n            tbucketed = [int(k) for k in xh[-1]]\n            pbucketed = [int(k) for k in yh[-1]]\n\n            return sklearn.metrics.f1_score(tbucketed, pbucketed, average=\"macro\")\n\n        return metric\n    else:\n        raise ValueError(f\"Unknown loss function {name}\")", "\n\ndef get_loss_function(name, **kwargs):\n    name = name.lower()\n\n    if name == \"mse\":\n        return torch.nn.MSELoss()\n    elif name == \"mrse\":\n        return lambda x, y: torch.sqrt(torch.nn.MSELoss()(x, y)) #fixme\n    elif name == \"cll\": # cumulative link loss\n        ## https://people.csail.mit.edu/jrennie/papers/ijcai05-preference.pdf\n        ## https://fa.bianp.net/blog/2013/loss-functions-for-ordinal-regression/\n        ## https://www.ethanrosenthal.com/2018/12/06/spacecutter-ordinal-regression/\n        return spacecutter.losses.CumulativeLinkLoss()\n    elif name == \"ce\":\n        return CrossEntropyLoss()\n    elif name == \"nll\":\n        return NLLLoss()\n    elif name == \"nll-weighted\":\n        return NLLLoss(weight=torch.tensor([0.4, 0.6]))\n    elif name == \"acc_reg_3\":\n        def acc_at_reg_intervals_3(x, y):\n            acc = torchmetrics.Accuracy().cuda()\n\n            x2 = torch.add(torch.round(torch.multiply(x, 2)), 1).to(torch.int)\n            y2 = torch.add(torch.round(torch.multiply(y, 2)), 1).to(torch.int)\n            return acc(x2, y2)\n\n        return acc_at_reg_intervals_3\n    elif name == \"acc\":\n        return torchmetrics.Accuracy()\n    elif name == \"f1-micro\":\n        return lambda x, y: sklearn.metrics.f1_score(x, y, average=\"micro\")\n    elif name == \"f1-macro\":\n        return lambda x, y: sklearn.metrics.f1_score(x, y, average=\"macro\")\n    elif name == \"f1-macro-rounded\":\n        sc = kwargs[\"score_range\"]\n\n        def metric(x, y):\n            print(\"x......\", x.tolist())\n            print(\"y.......\", y.tolist())\n\n            xh = histogram([(s-min(sc)) / (max(sc) - min(sc)) for s in sc], x.tolist())\n            yh = histogram([(s-min(sc)) / (max(sc) - min(sc)) for s in sc], y.tolist())\n            print(\"xh\", xh)\n            print(\"yh\", yh)\n\n            tbucketed = [int(k) for k in xh[-1]]\n            pbucketed = [int(k) for k in yh[-1]]\n\n            return sklearn.metrics.f1_score(tbucketed, pbucketed, average=\"macro\")\n\n        return metric\n    else:\n        raise ValueError(f\"Unknown loss function {name}\")", "\n\ndef histogram(score_range, scores):\n    buckets = score_range\n\n    # create buckets\n    bucket_names, counts, full = [], [], []\n    for i, left in enumerate(buckets):\n        right = buckets[i + 1] if i < len(buckets) - 1 else np.infty\n\n        bucket_names += [f\"{left}-{right}\"]\n        counts += [0]\n\n    # fill in  scores\n    for s in scores:\n        # round to left most\n        if s < buckets[0]:\n            s = buckets[0]\n\n        for i, left in enumerate(buckets):\n            right = buckets[i + 1] if i < len(buckets) - 1 else np.infty\n\n            if left <= s < right:\n                counts[i] += 1\n                full += [left]\n\n    return bucket_names, counts, full", "\n\ndef merge_configs(config, default_config):\n    to_expand = [(config, default_config)]\n    while len(to_expand) > 0:\n        c, oc = to_expand.pop(0)\n\n        for k, v in oc.items():\n            if k not in c:\n                c[k] = v\n            elif type(c[k]) == dict:\n                to_expand += [(c[k], v)]", "            # else ignore oc config, use the conf you already have\n\n\ndef join_review_fields(review_report):\n    with_main = \"main\" in review_report and review_report[\"main\"] is not None\n\n    return \"\\n\".join(f\"{fname.title()}\\n\"+ ftext.replace('\\n', '') + f\"\\n\" for (fname, ftext) in review_report.items() if fname != \"main\") \\\n           + (review_report[\"main\"].replace(\"\\n\", \"\") + \"\\n\" if with_main else \"\")\n\n\nclass ReviewScorePredictionDataset(Dataset):\n    \"\"\"\n    Task:\n        Review x paper (abs) -> review score\n    \"\"\"\n    def __init__(self, dataset: ReviewPaperDataset, transform=None, target_transform=None):\n        self.data = dataset\n\n        self.transform = transform\n        self.target_transform = target_transform\n\n    def ids(self):\n        return self.data.ids()\n\n    def __len__(self):\n        return len(self.data)\n\n    def __getitem__(self, idx):\n        if idx >= len(self):\n            raise IndexError()\n\n        paper_id, paper_meta, paper, review_num, review = self.data[idx]\n\n        extract_oscore = DATASET_REVIEW_OVERALL_SCALES[self.data.dataset_type][0]\n        oscore = extract_oscore(review[\"scores\"][\"overall\"])\n\n        if self.target_transform:\n            oscore = self.target_transform(oscore)\n\n        sample = {\n            \"pid\": paper_id,\n            \"abstract\": paper_meta[\"abstract\"],\n            \"paper\": paper,\n            \"rid\": review_num,\n            \"review\": join_review_fields(review[\"report\"]),\n        }\n\n        if self.transform:\n            sample = self.transform(sample)\n\n        return sample, np.float32(oscore)\n\n    def to_dict(self, idxs:list=None):\n        entries = list(range(len(self))) if idxs is None else idxs\n\n        sam0, _ = self[entries[0]]\n        fields = list(sam0.keys())\n        df = {f: [] for f in fields + [\"oscore\"]}\n\n        for i in entries:\n            sample, score = self[i]\n            for f in fields:\n                df[f] += [sample[f]]\n            df[\"oscore\"] += [score]\n\n        return df", "\n\nclass ReviewScorePredictionDataset(Dataset):\n    \"\"\"\n    Task:\n        Review x paper (abs) -> review score\n    \"\"\"\n    def __init__(self, dataset: ReviewPaperDataset, transform=None, target_transform=None):\n        self.data = dataset\n\n        self.transform = transform\n        self.target_transform = target_transform\n\n    def ids(self):\n        return self.data.ids()\n\n    def __len__(self):\n        return len(self.data)\n\n    def __getitem__(self, idx):\n        if idx >= len(self):\n            raise IndexError()\n\n        paper_id, paper_meta, paper, review_num, review = self.data[idx]\n\n        extract_oscore = DATASET_REVIEW_OVERALL_SCALES[self.data.dataset_type][0]\n        oscore = extract_oscore(review[\"scores\"][\"overall\"])\n\n        if self.target_transform:\n            oscore = self.target_transform(oscore)\n\n        sample = {\n            \"pid\": paper_id,\n            \"abstract\": paper_meta[\"abstract\"],\n            \"paper\": paper,\n            \"rid\": review_num,\n            \"review\": join_review_fields(review[\"report\"]),\n        }\n\n        if self.transform:\n            sample = self.transform(sample)\n\n        return sample, np.float32(oscore)\n\n    def to_dict(self, idxs:list=None):\n        entries = list(range(len(self))) if idxs is None else idxs\n\n        sam0, _ = self[entries[0]]\n        fields = list(sam0.keys())\n        df = {f: [] for f in fields + [\"oscore\"]}\n\n        for i in entries:\n            sample, score = self[i]\n            for f in fields:\n                df[f] += [sample[f]]\n            df[\"oscore\"] += [score]\n\n        return df", "\n\ndef abstract_with_review_only(sep_token=\"<s>\", truncate_paper=None, truncate_review=None):\n    assert truncate_paper is None or 0 <= truncate_paper, \"None or int >= 0 expected for paper truncation\"\n    assert truncate_review is None or 0 <= truncate_review, \"None or int >= 0 expected for review truncation\"\n\n    def get_abs(sample):\n        if truncate_paper is None:\n            abs = sample[\"abstract\"]\n        else:\n            abs = sample[\"abstract\"][:min(len(sample[\"abstract\"]), truncate_paper)]\n\n        if truncate_review is None:\n            rev = sample[\"review\"]\n        else:\n            rev = sample[\"review\"][:min(len(sample[\"review\"]), truncate_review)]\n\n        return {\"txt\": rev + sep_token + abs}\n\n    return get_abs", "\n\nclass PragmaticLabelingDataset(Dataset):\n    \"\"\"\n    Task:\n        Review sentece -> review score\n    \"\"\"\n\n    def __init__(self, dataset: PaperReviewDataset, transform=None, target_transform=None):\n        self.data = dataset\n\n        assert self.data.dataset_type in [DATASETS.ARR22, DATASETS.F1000], \\\n            \"Only ARR3Y and F1000 are supported for loading a pragmatic labeling dataset\"\n\n        self.transform = transform\n        self.target_transform = target_transform\n\n        self._setup()\n\n    def _setup(self):\n        if self.data.dataset_type == DATASETS.ARR22:\n            def get_sentences_with_pragmatics(sample):\n                paper_id, paper_meta, paper, reviews = sample\n\n                out = {}\n                for review in reviews:\n                    rout = []\n                    for f, l in [(\"paper_summary\", \"neutral\"), (\"summary_of_strengths\", \"strength\"),\n                                 (\"summary_of_weaknesses\", \"weakness\"), (\"comments,_suggestions_and_typos\", \"request\")]:\n                        txt = review[\"report\"][f]\n                        if txt is None:\n                            continue\n\n                        sent_spans = review[\"meta\"][\"sentences\"][f]\n                        sentences = [txt[s[0]:s[1]].strip() for s in sent_spans]\n\n                        # discard too short sentences (likely erroneous splitting and without content)\n                        sentences = [s for s in sentences if len(s) > 5]\n\n                        rout += [(l, s) for s in sentences]\n                    out[review[\"rid\"]] = rout\n\n                return out\n\n            paper_wise_sents = {sid: get_sentences_with_pragmatics(self.data[sid]) for sid in self.data.ids()}\n            # discard too short sentences (bad splitting, noisy examples)\n            paper_wise_sents = {sid: {rid: [(i[0], i[1].strip().replace(\"\\n\", \" \")) for i in s if len(i[1]) > 6]\n                                      for rid, s in sents.items()}\n                                for sid, sents in paper_wise_sents.items()}\n        elif self.data.dataset_type == DATASETS.F1000:\n            self.annos = PaperReviewAnnotations(annotation_type=ANNOTATION_TYPES.PRAG,\n                                                dataset=self.data)\n\n            def f1000rd_to_labelset(lbl):\n                if lbl == \"Strength\":\n                    return \"strength\"\n                elif lbl == \"Weakness\":\n                    return \"weakness\"\n                elif lbl == \"Todo\":\n                    return \"request\"\n                elif lbl in [\"Structure\", \"Recap\", \"Other\"]:\n                    return \"neutral\"\n                else:\n                    raise ValueError(f\"Passed label {lbl} is not part of the F1000RD label set!\")\n\n            def get_sentences_with_pragmatics(sample):\n                anno = sample[1]\n                paper_id, paper_meta, paper, reviews = sample[0]\n\n                out = {}\n                for review in reviews:\n                    if review[\"rid\"] not in anno:\n                        continue\n\n                    txt = review[\"report\"][\"main\"]\n                    sent_spans = review[\"meta\"][\"sentences\"][\"main\"]\n                    sentences = [txt[s[0]:s[1]].strip() for s in sent_spans]\n\n                    out[review[\"rid\"]] = [(f1000rd_to_labelset(a), sentences[int(i)]) for i, a in\n                                          anno[review[\"rid\"]].items()]\n\n                return out\n\n            paper_wise_sents = {p[0][0]: get_sentences_with_pragmatics(p) for p in self.annos}\n\n        review_wise_sents = {f\"{sid}%{k}\": v for sid, sents in paper_wise_sents.items() for k, v in sents.items()}\n        covered_reviews = list(review_wise_sents.keys())\n\n        self.sentences = {f\"{rid}_{i}\": s for rid in covered_reviews for i, s in enumerate(review_wise_sents[rid])}\n        self.sentence_ids = list(self.sentences.keys())\n\n    def ids(self):\n        return self.sentence_ids\n\n    def __len__(self):\n        return len(self.sentence_ids)\n\n    def __getitem__(self, idx):\n        if idx >= len(self):\n            raise IndexError(f\"Index {idx} out of range for this dataset\")\n\n        sid = self.sentence_ids[idx]\n        label, sentence = self.sentences[sid]\n\n        if self.target_transform:\n            label = self.target_transform(label)\n\n        pid, ridi = tuple(sid.split(\"%\"))\n        rid = tuple(ridi.split(\"_\"))[0]\n\n        paper_id, paper_meta, paper, reviews = self.data[pid]\n        review = next(r for r in reviews if r[\"rid\"] == rid)\n\n        sample = {\n            \"pid\": paper_id,\n            \"rid\": rid,\n            \"review\": join_review_fields(review[\"report\"]),\n            \"sentence\": sentence\n        }\n\n        if self.transform:\n            sample = self.transform(sample)\n\n        return sample, label\n\n    def to_dict(self, idxs:list=None):\n        entries = list(range(len(self))) if idxs is None else idxs\n\n        sam0, _ = self[entries[0]]\n        fields = list(sam0.keys())\n        df = {f: [] for f in fields + [\"label\"]}\n\n        for i in entries:\n            sample, lbl = self[i]\n            for f in fields:\n                df[f] += [sample[f]]\n            df[\"label\"] += [lbl]\n\n        return df", "\n\ndef random_split_pragmatic_labeling_dataset(dataset: PragmaticLabelingDataset, splits: list, random_seed: int = None):\n    ids = dataset.ids()\n\n    shuffled_ids = sklearn.utils.shuffle(ids, random_state=random_seed)\n    split_idx = [list(idx) for idx in paperwise_stratified_split(shuffled_ids, splits, None, random_seed)]\n    split_ids = [list(np.array(ids)[idx]) for idx in split_idx]\n\n    return split_idx, split_ids", "\n\ndef review_sentence_no_context():\n    def transform(sample):\n        return {\"txt\": sample[\"sentence\"].strip()}\n\n    return transform\n\n\ndef get_class_map_pragmatics():\n    labels = [\"strength\", \"weakness\", \"request\", \"neutral\"]\n\n    return {\n        l: i for i, l in enumerate(labels)\n    }", "\ndef get_class_map_pragmatics():\n    labels = [\"strength\", \"weakness\", \"request\", \"neutral\"]\n\n    return {\n        l: i for i, l in enumerate(labels)\n    }\n\n\nclass SkimmingDataset(Dataset):\n    \"\"\"\n    Task:\n        For each paper paragraph, determine whether it was referenced in a review\n    \"\"\"\n\n    def __init__(self, dataset: PaperReviewDataset,\n                 transform=None,\n                 target_transform=None,\n                 selected_types=None,\n                 sampling:str=\"random\",\n                 sample_size:int=5):\n        self.data = dataset\n\n        self.transform = transform\n        self.target_transform = target_transform\n\n        self.samples = None\n        self.sample_ids = None\n\n        self.selected_types = selected_types\n        self.sampling = sampling\n        self.sample_size = sample_size\n\n        self._setup()\n\n    @classmethod\n    def _get_linked_paper_nodes(cls, el_sample):\n        paper_data, elinks = el_sample\n        paper_id, paper_meta, paper, reviews, = paper_data\n\n        res = []\n        for rid in elinks:\n            for els in elinks[rid].values():\n                for el in els:\n                    anchor = el[\"paper_target\"]\n                    ltype = el[\"type\"]\n\n                    if anchor is not None:\n                        res += [(anchor, ltype)]\n\n        return res, paper\n\n    def _sample(self, positive, negative, doc) -> Tuple[List[List[Node]], List[List[Node]], List[str]]:\n        # we cannot deal with no negatives or positives -- we always need both in the mix\n        if len(positive) == 0 or len(negative) == 0:\n            return [], [], []\n\n        if self.sampling == \"random\":\n            negative = [n for n in negative if len(n.content) > 10] # quality assure paragraphs\n            paras = positive + negative\n\n            positive_sampled, negative_sampled, sampled_ids = [], [], []\n            for n in positive:\n                # make random choices until you include at least one negative\n                while True:\n                    random_paragraphs = random.choices([p for p in paras if p != n], k=self.sample_size-1)\n                    if len(set(random_paragraphs).intersection(set(negative))) > 0:\n                        break\n\n                positive_sampled += [[n] + [p for p in random_paragraphs if p in positive]]\n                negative_sampled += [[p for p in random_paragraphs if p in negative]]\n                sampled_ids += [n.ix]\n\n        elif self.sampling == \"close\":\n            paras = positive + negative\n\n            positive_sampled, negative_sampled, sampled_ids = [], [], []\n            for n in positive:\n                close_paragraphs = list(sorted(paras, key=lambda x: doc.tree_distance(n, x, Etype.NEXT)))\n                close_paragraphs = [p for p in close_paragraphs if p != n]\n\n                top_close = close_paragraphs[:min(len(close_paragraphs), self.sample_size-1)]\n\n                positive_sampled += [[n] + [p for p in top_close if p in positive]]\n                negative_sampled += [[p for p in top_close if p in negative]]\n                sampled_ids += [n.ix]\n\n        elif self.sampling == \"full\":\n            positive_sampled = [positive for p in positive]\n            negative_sampled = [negative for p in positive]\n            sampled_ids = [p.ix for p in positive]\n\n        elif self.sampling == \"none\":\n            positive_sampled = [positive]\n            negative_sampled = [negative]\n            sampled_ids = [\"all\"]\n\n        else:\n            raise NotImplementedError(f\"Given sampling strategy {self.sampling} does not exist.\")\n\n        return positive_sampled, negative_sampled, sampled_ids\n\n    def _sample_pos_neg_paragraphs(self, anchors, pdoc: IntertextDocument):\n        # all paragraphs\n        paras = [n for n in pdoc.nodes if n.ntype == NTYPE_PARAGRAPH]\n\n        # for each anchor, search for the matching paragraph node and add this to the positives\n        pos = []\n        for a, t in filter(lambda x: self.selected_types is None or x[1] in self.selected_types, anchors):\n            n = pdoc.get_node_by_ix(a)\n            if type(n) == SpanNode:\n                n = n.src_node\n\n            for p in pdoc.breadcrumbs(n, Etype.PARENT):\n                if p in paras:\n                    pos += [p]\n                    break\n\n        # for now: don't reflect frequency of references\n        pos = list(set(pos))\n\n        # pick only \"relevant paragraphs\" of size > 10\n        neg = [n for n in paras if n not in pos]\n\n        # sampling strategy\n        return self._sample(pos, neg, pdoc)\n\n    def _setup(self):\n        self.elink_annos = PaperReviewAnnotations(annotation_type=ANNOTATION_TYPES.ELINKS,\n                                                  dataset=self.data)\n\n        elinks_per_paper = {p[0][0]: self._get_linked_paper_nodes(p) for p in self.elink_annos}\n\n        batches = {}\n        for pid, sample in elinks_per_paper.items():\n            anchors, pdoc = sample\n\n            pos, neg, ix = self._sample_pos_neg_paragraphs(anchors, pdoc)\n\n            for i, ix in enumerate(ix):\n                batches[f\"{pid}%{ix}\"] = pos[i], neg[i]\n\n        self.samples = batches\n        self.sample_ids = list(batches.keys())\n\n    def ids(self):\n        return self.sample_ids\n\n    def __len__(self):\n        return len(self.sample_ids)\n\n    def __getitem__(self, idx):\n        if idx >= len(self):\n            raise IndexError(f\"Index {idx} out of range for this dataset\")\n\n        sid = self.sample_ids[idx]\n        positives, negatives = self.samples[sid]\n\n        if self.target_transform:\n            plabel = self.target_transform(\"positive\")\n            nlabel = self.target_transform(\"negative\")\n        else:\n            plabel = \"positive\"\n            nlabel = \"negative\"\n\n        if self.transform:\n            positives = [self.transform(p) for p in positives]\n            negatives = [self.transform(n) for n in negatives]\n\n        return positives, negatives, [plabel for p in positives], [nlabel for n in negatives]\n\n    def to_dict(self, idxs: list = None):\n        entries = list(range(len(self))) if idxs is None else idxs\n\n        pos0, neg0, pos0_lbls, neg0_lbls = self[entries[0]]\n        fields = list(pos0[0].keys())\n\n        df = {\"positives\": [],\n              \"negatives\": []}\n\n        for i in entries:\n            positives, negatives, pos_labels, neg_labels = self[i]\n\n            # create nested data frame for positives and negatives and fill as usual\n            pos_samples = {f: [] for f in fields + [\"label\"]}\n            neg_samples = {f: [] for f in fields + [\"label\"]}\n            for f in fields:\n                pos_samples[f] += [p[f] for p in positives]\n                neg_samples[f] += [p[f] for p in negatives]\n\n            neg_samples[\"label\"] += neg_labels\n            pos_samples[\"label\"] += pos_labels\n\n            # append to overall dataframe-style dict\n            df[\"positives\"] += [pos_samples]\n            df[\"negatives\"] += [neg_samples]\n\n        return df", "\nclass SkimmingDataset(Dataset):\n    \"\"\"\n    Task:\n        For each paper paragraph, determine whether it was referenced in a review\n    \"\"\"\n\n    def __init__(self, dataset: PaperReviewDataset,\n                 transform=None,\n                 target_transform=None,\n                 selected_types=None,\n                 sampling:str=\"random\",\n                 sample_size:int=5):\n        self.data = dataset\n\n        self.transform = transform\n        self.target_transform = target_transform\n\n        self.samples = None\n        self.sample_ids = None\n\n        self.selected_types = selected_types\n        self.sampling = sampling\n        self.sample_size = sample_size\n\n        self._setup()\n\n    @classmethod\n    def _get_linked_paper_nodes(cls, el_sample):\n        paper_data, elinks = el_sample\n        paper_id, paper_meta, paper, reviews, = paper_data\n\n        res = []\n        for rid in elinks:\n            for els in elinks[rid].values():\n                for el in els:\n                    anchor = el[\"paper_target\"]\n                    ltype = el[\"type\"]\n\n                    if anchor is not None:\n                        res += [(anchor, ltype)]\n\n        return res, paper\n\n    def _sample(self, positive, negative, doc) -> Tuple[List[List[Node]], List[List[Node]], List[str]]:\n        # we cannot deal with no negatives or positives -- we always need both in the mix\n        if len(positive) == 0 or len(negative) == 0:\n            return [], [], []\n\n        if self.sampling == \"random\":\n            negative = [n for n in negative if len(n.content) > 10] # quality assure paragraphs\n            paras = positive + negative\n\n            positive_sampled, negative_sampled, sampled_ids = [], [], []\n            for n in positive:\n                # make random choices until you include at least one negative\n                while True:\n                    random_paragraphs = random.choices([p for p in paras if p != n], k=self.sample_size-1)\n                    if len(set(random_paragraphs).intersection(set(negative))) > 0:\n                        break\n\n                positive_sampled += [[n] + [p for p in random_paragraphs if p in positive]]\n                negative_sampled += [[p for p in random_paragraphs if p in negative]]\n                sampled_ids += [n.ix]\n\n        elif self.sampling == \"close\":\n            paras = positive + negative\n\n            positive_sampled, negative_sampled, sampled_ids = [], [], []\n            for n in positive:\n                close_paragraphs = list(sorted(paras, key=lambda x: doc.tree_distance(n, x, Etype.NEXT)))\n                close_paragraphs = [p for p in close_paragraphs if p != n]\n\n                top_close = close_paragraphs[:min(len(close_paragraphs), self.sample_size-1)]\n\n                positive_sampled += [[n] + [p for p in top_close if p in positive]]\n                negative_sampled += [[p for p in top_close if p in negative]]\n                sampled_ids += [n.ix]\n\n        elif self.sampling == \"full\":\n            positive_sampled = [positive for p in positive]\n            negative_sampled = [negative for p in positive]\n            sampled_ids = [p.ix for p in positive]\n\n        elif self.sampling == \"none\":\n            positive_sampled = [positive]\n            negative_sampled = [negative]\n            sampled_ids = [\"all\"]\n\n        else:\n            raise NotImplementedError(f\"Given sampling strategy {self.sampling} does not exist.\")\n\n        return positive_sampled, negative_sampled, sampled_ids\n\n    def _sample_pos_neg_paragraphs(self, anchors, pdoc: IntertextDocument):\n        # all paragraphs\n        paras = [n for n in pdoc.nodes if n.ntype == NTYPE_PARAGRAPH]\n\n        # for each anchor, search for the matching paragraph node and add this to the positives\n        pos = []\n        for a, t in filter(lambda x: self.selected_types is None or x[1] in self.selected_types, anchors):\n            n = pdoc.get_node_by_ix(a)\n            if type(n) == SpanNode:\n                n = n.src_node\n\n            for p in pdoc.breadcrumbs(n, Etype.PARENT):\n                if p in paras:\n                    pos += [p]\n                    break\n\n        # for now: don't reflect frequency of references\n        pos = list(set(pos))\n\n        # pick only \"relevant paragraphs\" of size > 10\n        neg = [n for n in paras if n not in pos]\n\n        # sampling strategy\n        return self._sample(pos, neg, pdoc)\n\n    def _setup(self):\n        self.elink_annos = PaperReviewAnnotations(annotation_type=ANNOTATION_TYPES.ELINKS,\n                                                  dataset=self.data)\n\n        elinks_per_paper = {p[0][0]: self._get_linked_paper_nodes(p) for p in self.elink_annos}\n\n        batches = {}\n        for pid, sample in elinks_per_paper.items():\n            anchors, pdoc = sample\n\n            pos, neg, ix = self._sample_pos_neg_paragraphs(anchors, pdoc)\n\n            for i, ix in enumerate(ix):\n                batches[f\"{pid}%{ix}\"] = pos[i], neg[i]\n\n        self.samples = batches\n        self.sample_ids = list(batches.keys())\n\n    def ids(self):\n        return self.sample_ids\n\n    def __len__(self):\n        return len(self.sample_ids)\n\n    def __getitem__(self, idx):\n        if idx >= len(self):\n            raise IndexError(f\"Index {idx} out of range for this dataset\")\n\n        sid = self.sample_ids[idx]\n        positives, negatives = self.samples[sid]\n\n        if self.target_transform:\n            plabel = self.target_transform(\"positive\")\n            nlabel = self.target_transform(\"negative\")\n        else:\n            plabel = \"positive\"\n            nlabel = \"negative\"\n\n        if self.transform:\n            positives = [self.transform(p) for p in positives]\n            negatives = [self.transform(n) for n in negatives]\n\n        return positives, negatives, [plabel for p in positives], [nlabel for n in negatives]\n\n    def to_dict(self, idxs: list = None):\n        entries = list(range(len(self))) if idxs is None else idxs\n\n        pos0, neg0, pos0_lbls, neg0_lbls = self[entries[0]]\n        fields = list(pos0[0].keys())\n\n        df = {\"positives\": [],\n              \"negatives\": []}\n\n        for i in entries:\n            positives, negatives, pos_labels, neg_labels = self[i]\n\n            # create nested data frame for positives and negatives and fill as usual\n            pos_samples = {f: [] for f in fields + [\"label\"]}\n            neg_samples = {f: [] for f in fields + [\"label\"]}\n            for f in fields:\n                pos_samples[f] += [p[f] for p in positives]\n                neg_samples[f] += [p[f] for p in negatives]\n\n            neg_samples[\"label\"] += neg_labels\n            pos_samples[\"label\"] += pos_labels\n\n            # append to overall dataframe-style dict\n            df[\"positives\"] += [pos_samples]\n            df[\"negatives\"] += [neg_samples]\n\n        return df", "\n\ndef get_paragraph_text(with_struct=False, with_meta=False):\n    def get_text(paragraph):\n        res = [paragraph.content]\n\n        if with_struct or with_meta:\n            parent = None\n            title = None\n            depth = 0\n            edges = [e for e in paragraph.incoming_edges if e.etype == Etype.PARENT]\n            while len(edges) > 0:\n                edge = edges.pop()\n                depth += 1\n\n                if edge.src_node.ntype in [NTYPE_HEADING, NTYPE_ABSTRACT] and parent is None:\n                    parent = edge.src_node\n                elif edge.src_node.ntype in [NTYPE_TITLE]:\n                    title = edge.src_node\n\n                edges += [e for e in edge.src_node.incoming_edges if e.etype == Etype.PARENT]\n\n                if title is not None and parent is not None:\n                    break\n\n            if with_meta:\n                res = [str(depth)] + res if depth > 0 else res\n\n            res = ([(parent.meta[\"section\"] if parent.meta and \"section\" in parent.meta else \"\") + \"; \" + parent.content] + res) if parent is not None else res\n            res = ([title.content] + res) if title is not None else res\n\n        return {\n            \"txt\": \"<s>\".join(res)\n        }\n\n    return get_text", "\n\ndef get_class_map_skimming():\n    labels = [\"negative\", \"positive\"]\n\n    return {\n        l: i for i, l in enumerate(labels)\n    }\n", ""]}
{"filename": "nlpeer/tasks/review_score/train.py", "chunked_list": ["import argparse\nimport os\nimport time\nimport uuid\nfrom random import random\n\nfrom pytorch_lightning import Trainer, seed_everything\nfrom pytorch_lightning.callbacks import ModelCheckpoint, EarlyStopping\nfrom pytorch_lightning.loggers import WandbLogger\n", "from pytorch_lightning.loggers import WandbLogger\n\nimport torch\nimport wandb\n\nfrom nlpeer.data import DATASETS\nfrom nlpeer.tasks import merge_configs\nfrom nlpeer.tasks.review_score.data import ReviewScorePredictionDataModule\n\nOUT_PATH = None", "\nOUT_PATH = None\nBENCHMARK_PATH = None\nDEVICE = \"gpu\" if torch.cuda.is_available() else \"cpu\"\n\n\ndef get_default_config():\n    global BENCHMARK_PATH, DEVICE\n\n    assert BENCHMARK_PATH is not None and os.path.exists(BENCHMARK_PATH),\\\n        f\"Provided benchmark path is None or does not exist: {BENCHMARK_PATH}\"\n\n    return {\n        \"data_loader\": {\n            \"num_workers\": 8,\n            \"shuffle\": True\n        },\n        \"dataset\": {\n            \"benchmark_path\": BENCHMARK_PATH\n        },\n        \"machine\": {\n            \"device\": DEVICE\n        }\n    }", "\n\ndef setup(config):\n    # get module and transforms\n    if config[\"model\"][\"type\"] in [\"roberta\", \"biobert\", \"scibert\"]:\n        from nlpeer.tasks.review_score.models.TransformerBased import from_config\n        module = from_config(config)\n    elif config[\"model\"][\"type\"].startswith(\"baseline\"):\n        from nlpeer.tasks.review_score.models.baseline import from_config\n        module = from_config(config)\n    else:\n        raise ValueError(f\"The provided model type {config['model']['type']} is not supported\")\n\n    input_transform, target_transform = module.get_prepare_input(DATASETS[config[\"dataset\"][\"type\"]])\n    tokenizer = module.get_tokenizer()\n\n    # load data module\n    data_module = ReviewScorePredictionDataModule(benchmark_path=config[\"dataset\"][\"benchmark_path\"],\n                                                  dataset_type=DATASETS[config[\"dataset\"][\"type\"]],\n                                                  in_transform=input_transform,\n                                                  target_transform=target_transform,\n                                                  tokenizer=tokenizer,\n                                                  filter=config[\"dataset\"][\"filter\"] if \"filter\" in config[\"dataset\"] else None,\n                                                  data_loader_config=config[\"data_loader\"],\n                                                  paper_version=config[\"dataset\"][\"paper_version\"])\n\n    return module, data_module", "\n\ndef train(model, data_module, params, logger=None, debug=False):\n    global OUT_PATH\n\n    print(f\"RUN = {wandb.run.name}\")\n    wandb.log({\"config\": params})\n\n    chkp_dir = os.path.join(OUT_PATH, f\"checkpoints/{params['dataset']['type']}/{params['model']['type']}\")\n    checkpoint_callback = ModelCheckpoint(monitor=\"val_loss\",\n                                          mode=\"min\",\n                                          dirpath=chkp_dir,\n                                          filename=\"{epoch}-{val_loss}-\" + str(uuid.uuid4()),\n                                          save_top_k=1,\n                                          #every_n_train_steps=10\n                                          )\n    early_stop_callback = EarlyStopping(monitor=\"val_loss\",\n                                        mode=\"min\",\n                                        patience=8,\n                                        min_delta=0.001)\n\n    trainer = Trainer(logger=logger,\n                      log_every_n_steps=1,\n                      limit_train_batches=0.1 if debug else 1.0,\n                      #devices=1,\n                      max_epochs=params[\"train\"][\"epochs\"],\n                      accelerator=params[\"machine\"][\"device\"],\n                      callbacks=[checkpoint_callback, early_stop_callback])\n\n    # fit the model\n    trainer.fit(model, data_module)\n\n    # run final validation step\n    res = trainer.validate(model.load_from_checkpoint(checkpoint_callback.best_model_path), data_module)\n    print(res)\n\n    # output best model path\n    wandb.log({\"best_model\": checkpoint_callback.best_model_path})\n    print(f\"best_model = {checkpoint_callback.best_model_path}\")", "\n\ndef run(config, debug=False, project=None):\n    global OUT_PATH\n\n    dconfig = get_default_config()\n    merge_configs(config, dconfig)\n\n    # set seed and log\n    seed = int(time.time()) % 100000\n    config[\"random_seed\"] = seed\n    seed_everything(seed)\n\n    # actual training\n    model, data = setup(config)\n    train(model, data, config, WandbLogger(dir=os.path.join(OUT_PATH, \"logs\"), project=project), debug)", "\n\ndef main(args):\n    global BENCHMARK_PATH, OUT_PATH\n    BENCHMARK_PATH = args.benchmark_path\n    OUT_PATH = args.store_results\n\n    assert os.path.exists(BENCHMARK_PATH) and os.path.exists(OUT_PATH),\\\n        f\"Benchmark or out path do not exist. Check {BENCHMARK_PATH} and {OUT_PATH} again.\"\n\n    # use default config (basically for debugging)\n    dconf = {\n        \"dataset\": {\n            \"type\": args.dataset,\n            \"paper_version\": 1\n        },\n        \"model\": {\n            \"type\": args.model\n        },\n        \"train\": {\n            \"epochs\": 20,\n            \"train_loss\": \"mse\",\n            \"dev_loss\": \"mse\",\n            \"optimizer\": \"adam\",\n            \"learning_rate\": 2e-5 if args.lr is None else args.lr,\n            \"epsilon\": 1e-8\n        },\n        \"data_loader\": {\n            \"batch_size\": 16 if args.batch_size is None else args.batch_size\n        }\n    }\n    if args.downsample:\n        def drop_random(pid):\n            dec = random()\n            return dec <= args.downsample\n\n        dconf[\"dataset\"][\"filter\"] = drop_random\n\n    print(\"Using default config...\" + str(dconf))\n    runs = args.repeat if args.repeat else 1\n\n    for i in range(runs):\n        run(dconf, debug= args.debug, project=args.project if args.project is not None else \"RSP_train\")", "\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--benchmark_path\", required=True, type=str, help=\"Path to the benchmark dir\")\n    parser.add_argument(\"--store_results\", required=True, type=str, help=\"Path for logs + results\")\n    parser.add_argument(\"--dataset\", required=False, choices=[d.name for d in DATASETS], help=\"Dataset name if no sweep provided\")\n    parser.add_argument(\"--model\", required=False, type=str, help=\"model name if no sweep provided\")\n    parser.add_argument(\"--lr\", required=False, type=float, help=\"learning rate (opt)\")\n    parser.add_argument(\"--downsample\", required=False, type=float, help=\"downsample ratio, if present\")\n    parser.add_argument(\"--batch_size\", required=False, type=int, help=\"batch size (opt)\")\n    parser.add_argument(\"--repeat\", required=False, type=int, default=1, help=\"Number of repetitions\")\n    parser.add_argument(\"--debug\", required=False, type=bool, default=False, help=\"Number of repetitions\")\n\n    parser.add_argument(\"--project\", required=False, type=str, help=\"Project name in WANDB\")\n\n    args = parser.parse_args()\n\n    assert args.project is not None and args.repeat is not None, \"Project name required for running a wandb sweep\"\n\n    assert args.dataset is not None and args.model is not None,\\\n        \"Dataset type required if not loading from sweep config\"\n\n    main(args)", ""]}
{"filename": "nlpeer/tasks/review_score/evaluate.py", "chunked_list": ["import argparse\nimport simplejson\nimport json\nimport os\nfrom copy import copy\nfrom typing import Callable\nimport plotly.graph_objects as go\n\nfrom os.path import join as pjoin\n", "from os.path import join as pjoin\n\nimport numpy as np\nimport scipy.stats\nfrom scipy.stats import entropy\nimport sklearn\nimport torch\nimport wandb\nfrom pytorch_lightning import Trainer\nfrom pytorch_lightning.loggers import WandbLogger", "from pytorch_lightning import Trainer\nfrom pytorch_lightning.loggers import WandbLogger\n\nimport nlpeer.tasks\nfrom nlpeer import DATASETS, PAPERFORMATS, DATASET_REVIEW_OVERALL_SCALES, ReviewPaperDataset\nfrom nlpeer.data.utils import list_files\nfrom nlpeer.tasks import histogram\nfrom nlpeer.tasks.review_score import train\nfrom nlpeer.tasks.review_score.data import ReviewScorePredictionDataModule\n", "from nlpeer.tasks.review_score.data import ReviewScorePredictionDataModule\n\nOUT_PATH = None\nBENCHMARK_PATH = None\nDEVICE = \"gpu\" if torch.cuda.is_available() else \"cpu\"\n\n\ndef get_default_config():\n    global BENCHMARK_PATH, DEVICE\n\n    assert BENCHMARK_PATH is not None and os.path.exists(BENCHMARK_PATH), \\\n        f\"Provided benchmark path is None or does not exist: {BENCHMARK_PATH}\"\n\n    return {\n        \"data_loader\": {\n            \"num_workers\": 0,\n            \"shuffle\": False\n        },\n        \"dataset\": {\n            \"benchmark_path\": BENCHMARK_PATH,\n            \"splits_from_file\": True\n        },\n        \"machine\": {\n            \"device\": DEVICE\n        }\n    }", "\n\n# 1. Diversity\ndef relative_diversity(score_range, true_scores, predicted_scores, log=False):\n    true_histogram = histogram(score_range, true_scores)\n    pred_histogram = histogram(score_range, predicted_scores)\n\n    kldiv = entropy(pred_histogram[1], qk=true_histogram[1], base=2)\n\n    if log:\n        t1 = wandb.Table(data=[[bucket, cnt] for bucket, cnt in zip(true_histogram[0], true_histogram[1])],\n                         columns=[\"score\", \"cnt\"])\n        t2 = wandb.Table(data=[[bucket, cnt] for bucket, cnt in zip(pred_histogram[0], pred_histogram[1])],\n                         columns=[\"score\", \"cnt\"])\n\n        fig = go.Figure()\n        fig.add_trace(\n            go.Bar(x=list(true_histogram[0]), y=true_histogram[1], name=\"True Scores\"))\n        fig.add_trace(\n            go.Bar(x=list(pred_histogram[0]), y=pred_histogram[1], name=\"Pred Scores\"))\n\n        wandb.log({f\"diversity_hist\": fig})\n\n        t3 = wandb.Table(data=[[p] for p in predicted_scores],\n                         columns=[\"scores\"])\n        wandb.log({f\"diversity_fine_hist\": wandb.plot.histogram(t3, \"scores\", title=\"Predicted score dist\")})\n\n        wandb.log({\"diversity_true\": t1})\n        wandb.log({\"diversity_model\": t2})\n        wandb.log({\"kl_divergence\": kldiv})\n\n    return {\n        \"kldiv\": float(kldiv),\n        \"true_histogram\": true_histogram,\n        \"pred_histogram\": pred_histogram,\n        \"true_mean\": float(np.mean(true_histogram[2])),\n        \"true_std\": float(np.std(true_histogram[2])),\n        \"pred_mean_rounded\": float(np.mean(pred_histogram[2])),\n        \"pred_std_rounded\": float(np.std(pred_histogram[2])),\n        \"pred_mean\": float(np.mean(predicted_scores)),\n        \"pred_std\": float(np.std(predicted_scores)),\n    }", "\n\n# 2. MRSE plus rounded classification loss\ndef error(score_range, true_scores, predicted_scores, log=False):\n    # mrse\n    mrse = sklearn.metrics.mean_squared_error(true_scores, predicted_scores)\n\n    # r2\n    r2 = sklearn.metrics.r2_score(true_scores, predicted_scores)\n\n    # rounded classification loss\n    tbucketed = [int(x) for x in histogram(score_range, true_scores)[-1]]\n    pbucketed = [int(x) for x in histogram(score_range, predicted_scores)[-1]]\n\n    print(\"true\", tbucketed)\n    print(\"predicted\", pbucketed)\n\n    f1_micro = sklearn.metrics.f1_score(tbucketed, pbucketed, average=\"micro\")\n    f1_macro = sklearn.metrics.f1_score(tbucketed, pbucketed, average=\"macro\")\n    # cll = train.get_loss_function(\"CLL\")(torch.Tensor(pbucketed).reshape(), torch.Tensor(tbucketed).flatten())\n\n    if log:\n        wandb.log({\"mrse\": mrse})\n        wandb.log({\"r^2\": r2})\n        wandb.log({\"f1_micro_rounded\": f1_micro})\n        wandb.log({\"f1_macro_rounded\": f1_macro})\n        # wandb.log({\"cumulative_link_loss\": cll})\n\n    return {\n        \"mrse\": float(mrse),\n        \"r^2\": float(r2),\n        \"f1_micro\": float(f1_micro),\n        \"f1_macro\": float(f1_macro)\n    }", "\n\n# 3. Fairness by paper-type (long vs. short; dataset vs. method; F1000 categories)\ndef relative_fairness(true_scores, predicted_scores, original_dataset, index_map, paper_criterion: Callable,\n                      criterion_name: str, log=False):\n    crit_per_sample = np.array([paper_criterion(original_dataset[index_map[i]]) for i in range(len(true_scores))])\n    crits = set(crit_per_sample)\n\n    samples_per_crit = {c: crit_per_sample == c for c in crits}\n    true_scores_per_crit = {c: np.array(true_scores)[samples_per_crit[c]] for c in crits}\n    predicted_scores_per_crit = {c: np.array(predicted_scores)[samples_per_crit[c]] for c in crits}\n\n    if len(crits) <= 1:\n        print(\"Fairness not applicable -- only one class present!\")\n        wandb.log({f\"fairness_{criterion_name}\": \"not applicable, only one class present\"})\n        return {}, {}\n\n    # \"human fairness\"\n    h, m, = {}, {}\n    # h[\"pearson\"] = scipy.stats.pearsonr(true_scores, crit_per_sample)con\n    # h[\"spearman\"] = scipy.stats.spearmanr(true_scores, crit_per_sample)\n    # h[\"kendalltau\"] = scipy.stats.kendalltau(true_scores, crit_per_sample)\n    # h[\"point_biserial\"] = scipy.stats.pointbiserialr(np.array([predicted_scores_per_crit[s] for s in crit_per_sample]), true_scores)\n    annova = scipy.stats.f_oneway(*[true_scores_per_crit[c] for c in crits])\n    h[\"human_annova\"] = {\"stat\": float(annova.statistic), \"pvalue\": float(annova.pvalue)}\n\n    # \"model fairness\"\n    # m[\"pearson\"] = scipy.stats.pearsonr(predicted_scores, crit_per_sample)\n    # m[\"spearman\"] = scipy.stats.spearmanr(predicted_scores, crit_per_sample)\n    # m[\"kendalltau\"] = scipy.stats.kendalltau(predicted_scores, crit_per_sample)\n    # m[\"point_biserial\"] = scipy.stats.pointbiserialr(predicted_scores, true_scores)\n    annova = scipy.stats.f_oneway(*[predicted_scores_per_crit[c] for c in crits])\n    m[\"model_annova\"] = {\"stat\": float(annova.statistic), \"pvalue\": float(annova.pvalue)}\n\n    if log:\n        scores_per_crit = [(\"true\", true_scores_per_crit), (\"pred\", predicted_scores_per_crit)]\n        means = {}\n        stds = {}\n        for t, spc in scores_per_crit:\n            means[t] = []\n            stds[t] = []\n\n            for crit in crits:\n                means[t] += [np.mean(spc[crit])]\n                stds[t] += [np.std(spc[crit])]\n\n        fig = go.Figure()\n        fig.add_trace(\n            go.Bar(x=list(crits), y=means[\"true\"], error_y=dict(type=\"data\", array=stds[\"true\"]), name=\"True Scores\"))\n        fig.add_trace(\n            go.Bar(x=list(crits), y=means[\"pred\"], error_y=dict(type=\"data\", array=stds[\"pred\"]), name=\"Pred Scores\"))\n\n        wandb.log({f\"fairness_{criterion_name}\": fig})\n\n        wandb.log({\"human_fairness\": h, \"model_fairness\": m})\n\n    return h, m", "\n\ndef get_criterion(criterion_name, dataset_type):\n    if criterion_name == \"paper_type\":\n        if dataset_type == DATASETS.F1000:\n            def f1000_paper_type(p):\n                return p[1][\"atype\"]\n\n            return f1000_paper_type\n        elif dataset_type in [DATASETS.ARR22, DATASETS.ACL17, DATASETS.CONLL16]:\n            def staracl_paper_type(p):\n                if \"bib_page_index\" not in p[1]:\n                    return \"short\"\n\n                bindex = p[1][\"bib_page_index\"]\n                if bindex is None or bindex < 8:\n                    return \"short\"\n                else:\n                    return \"long\"\n\n            return staracl_paper_type\n        elif dataset_type == DATASETS.COLING20:\n            def coling_paper_type(p):\n                t = p[1][\"type\"]\n                return \"long\" if t.lower() == \"long paper\" else \"short\"\n\n            return coling_paper_type\n    else:\n        raise ValueError(f\"No such criterion exists: {criterion_name}\")", "\n\ndef setup(config):\n    assert \"load_path\" in config[\"model\"], \"Provide a 'load_path' attribute in the config.model to load a checkpoint\"\n\n    if config[\"model\"][\"type\"] in [\"roberta\", \"biobert\", \"scibert\"]:\n        from nlpeer.tasks.review_score.models.TransformerBased import from_config\n        module = from_config(config)\n    elif config[\"model\"][\"type\"].startswith(\"baseline\"):\n        from nlpeer.tasks.review_score.models.baseline import from_config\n        module = from_config(config)\n    else:\n        raise ValueError(\"The provided model type is not supported\")\n\n    input_transform, target_transform = module.get_prepare_input(DATASETS[config[\"dataset\"][\"type\"]])\n    tokenizer = module.get_tokenizer()\n\n    # prepare data (loading splits from disk)\n    data_module = ReviewScorePredictionDataModule(benchmark_path=config[\"dataset\"][\"benchmark_path\"],\n                                                  dataset_type=DATASETS[config[\"dataset\"][\"type\"]],\n                                                  in_transform=input_transform,\n                                                  target_transform=target_transform,\n                                                  tokenizer=tokenizer,\n                                                  data_loader_config=config[\"data_loader\"],\n                                                  paper_version=config[\"dataset\"][\"paper_version\"])\n    original_data = ReviewPaperDataset(config[\"dataset\"][\"benchmark_path\"],\n                                       DATASETS[config[\"dataset\"][\"type\"]],\n                                       config[\"dataset\"][\"paper_version\"],\n                                       PAPERFORMATS.ITG)\n\n    # mapping between split indexes and original dataset (trivial in this case)\n    imap = {i: i for i in range(len(original_data))}\n\n    return module, data_module, original_data, imap", "\n\ndef get_predictions(model, data_module, params, logger, debug=False):\n    trainer = Trainer(logger=logger,\n                      log_every_n_steps=1,\n                      limit_predict_batches=0.1 if debug else 1.0,\n                      accelerator=params[\"machine\"][\"device\"])\n\n    return trainer.predict(model, data_module)\n", "\n\ndef run(config, debug=False):\n    global OUT_PATH\n\n    cname = f\"{config['dataset']['type']}_{config['model']['type']}\"\n\n    with wandb.init(dir=os.path.join(OUT_PATH, \"logs\"), config=config, project=config[\"project\"], name=cname):\n        dconfig = get_default_config()\n        tasks.merge_configs(config, dconfig)\n\n        wandb_logger = WandbLogger(dir=os.path.join(OUT_PATH, \"logs\"), config=config)\n\n        print(f\"Starting evaluation with config {config}\")\n\n        # get model checkpoints and config paths\n        model_load_path = pjoin(config[\"model\"][\"load_path\"], config[\"model\"][\"type\"])\n        print(model_load_path)\n        mconf_path = pjoin(model_load_path, \"config.json\") if os.path.exists(\n            pjoin(model_load_path, \"config.json\")) else None\n        checkpoints = [c for c in list_files(model_load_path) if os.path.basename(c) != \"config.json\"]\n\n        assert len(checkpoints) > 0, f\"Model load path {model_load_path} directory lacks checkpoints: {checkpoints}\"\n\n        # load the model config\n        mconf = copy(config)\n\n        accu_res = evaluation(checkpoints, config, mconf, wandb_logger, debug)\n        mean_res = compute_mean_stats(accu_res)\n\n        wandb.log({\"mean_res\": mean_res})\n\n        mean_res[\"accu\"] = accu_res\n\n        def np_encoder(object):\n            if isinstance(object, np.generic):\n                return object.item()\n            else:\n                return None\n\n        with open(pjoin(OUT_PATH, f\"rsp_eval_{config['dataset']['type']}_{config['model']['type']}.json\"), \"w+\") as f:\n            simplejson.dump(mean_res, f, indent=4, ignore_nan=True, default=np_encoder)", "\n\ndef compute_mean_stats(accu_res):\n    mean_res = {}\n    for s in accu_res:\n        for t in s:\n            if type(s[t]) != dict:\n                continue\n\n            if t not in mean_res:\n                mean_res[t] = {}\n\n            for k, v in s[t].items():\n                try:\n                    vf = float(v)\n                except (ValueError, TypeError):\n                    continue\n\n                if k not in mean_res[t]:\n                    mean_res[t][k] = []\n\n                mean_res[t][k] += [vf]\n    for t in mean_res:\n        for k, v in mean_res[t].items():\n            mean_res[t][k] = {\"mean\": float(np.mean(v)), \"median\": float(np.median(v)), \"std\": float(np.std(v))}\n\n    return mean_res", "\n\ndef evaluation(checkpoints, config, model_config, wandb_logger, debug=False):\n    accu_res = []\n    for cpath in checkpoints:\n        # define setup config\n        model_config[\"model\"][\"load_path\"] = cpath\n        model_config[\"dataset\"] = config[\"dataset\"]\n        model_config[\"data_loader\"] = config[\"data_loader\"]\n        model_config[\"machine\"] = config[\"machine\"]\n\n        # prep evaluation\n        model, data_module, original_dataset, imap = setup(model_config)\n        score_range = DATASET_REVIEW_OVERALL_SCALES[original_dataset.dataset_type][1]\n\n        predictions = get_predictions(model, data_module, config, wandb_logger, debug)\n        labels = torch.cat([x[\"labels\"] for x in predictions]).detach().cpu().tolist()\n        predictions = torch.cat([x[\"predictions\"] for x in predictions]).detach().cpu().tolist()\n\n        # assuming normalization of outputs\n        predictions = [(i * (np.max(score_range) - np.min(score_range))) + np.min(score_range) for i in\n                       predictions]\n\n        labels = [(i * (np.max(score_range) - np.min(score_range))) + np.min(score_range) for i in\n                       labels]\n\n        # evaluate\n        eval_conf = config[\"evaluation\"]\n\n        res = {}\n        if \"diversity\" in eval_conf and eval_conf[\"diversity\"]:\n            res[\"diversity\"] = relative_diversity(score_range, labels, predictions, True)\n        if \"error\" in eval_conf and eval_conf[\"error\"]:\n            res[\"error\"] = error(score_range, labels, predictions, True)\n        if \"fairness\" in eval_conf and eval_conf[\"fairness\"] is not None:\n            criterion_name = eval_conf[\"fairness\"][\"criterion\"]\n            paper_criterion = get_criterion(criterion_name, original_dataset.dataset_type)\n            res[\"fairness\"] = relative_fairness(labels,\n                                                predictions,\n                                                original_dataset,\n                                                imap,\n                                                paper_criterion,\n                                                criterion_name,\n                                                True)\n        res[\"predictions\"] = predictions\n\n        accu_res += [res]\n    return accu_res", "\n\ndef main(args):\n    global BENCHMARK_PATH, OUT_PATH\n    BENCHMARK_PATH = args.benchmark_dir\n    OUT_PATH = args.store_results\n\n    assert os.path.exists(BENCHMARK_PATH) and os.path.exists(OUT_PATH), \\\n        f\"Benchmark or out path do not exist. Check {BENCHMARK_PATH} and {OUT_PATH} again.\"\n\n    config = {\n        \"name\": f\"Evaluation\",\n        \"project\": args.project,\n        \"random_seed\": {\n            \"value\": 29491\n        },\n        \"model\": {\n            \"type\": args.model_type,\n            \"load_path\": pjoin(args.chkp_dir, f\"{DATASETS[args.dataset].name}\"),\n            \"normalized_output\": False   #not pretty\n        },\n        \"data_loader\": {\n            \"batch_size\": 8\n        },\n        \"dataset\": {\n            \"type\": DATASETS[args.dataset].name,\n            \"paper_version\": args.paper_version\n        },\n        \"evaluation\": {\n            \"diversity\": True,\n            \"error\": True,\n            \"fairness\": {\n                \"criterion\": \"paper_type\"\n            }\n        }\n    }\n\n    run(config, debug= args.debug)", "    # wandb.agent(args.sweep_id.strip(), function=run, project=args.project, count=10)\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--benchmark_dir\", required=True, type=str, help=\"Path to the benchmark dir\")\n    parser.add_argument(\"--project\", required=True, type=str, help=\"Project name in WANDB\")\n    parser.add_argument(\"--store_results\", required=True, type=str, help=\"Path for logs + results\")\n    parser.add_argument(\"--chkp_dir\", required=True, type=str, help=\"Path to load the checkpoints from\")\n    parser.add_argument(\"--dataset\", required=True, choices=[d.name for d in DATASETS], help=\"Name of the dataset\")\n    parser.add_argument(\"--model_type\", required=True, type=str, help=\"Model type e.g. biobert\")\n    parser.add_argument(\"--paper_version\", required=False, default=1, type=int, help=\"Version of the paper\")\n    parser.add_argument(\"--debug\", required=False, default=False, type=bool, help=\"Turn on debugging\")\n\n    args = parser.parse_args()\n    main(args)", ""]}
{"filename": "nlpeer/tasks/review_score/__init__.py", "chunked_list": [""]}
{"filename": "nlpeer/tasks/review_score/data.py", "chunked_list": ["import argparse\nimport os\nfrom copy import copy\nfrom os.path import join as pjoin\n\nimport sklearn\nfrom pytorch_lightning import LightningDataModule\nfrom torch.utils.data import DataLoader\nfrom datasets import Dataset, DatasetDict\n", "from datasets import Dataset, DatasetDict\n\nfrom nlpeer.data import filter_gte_x_reviews, load_splits_from_file, \\\n    store_splits_to_file, paperwise_random_split\nfrom nlpeer import DATASETS, PAPERFORMATS, ReviewPaperDataset\nfrom nlpeer.tasks import ReviewScorePredictionDataset\n\n\nclass ReviewScorePredictionDataModule(LightningDataModule):\n    def __init__(self, benchmark_path: str,\n                 dataset_type: DATASETS,\n                 in_transform,\n                 target_transform,\n                 tokenizer,\n                 data_loader_config,\n                 paper_version=1,\n                 filter=None,\n                 paper_format=PAPERFORMATS.ITG):\n        super().__init__()\n\n        self.base_path = benchmark_path\n        self.dataset_type = dataset_type\n        self.paper_version = paper_version\n        self.paper_format = paper_format\n\n        self.in_transform = in_transform\n        self.target_transform = target_transform\n        self.tokenizer = tokenizer\n\n        self.splits = self._load_splits_idx()\n        self.dataset = None\n        self.filter = filter\n\n        self.data_loader_config = data_loader_config\n\n    def _load_splits_idx(self):\n        fp = pjoin(self.base_path, self.dataset_type.value, \"splits\", \"rsp_split.json\")\n\n        assert os.path.exists(fp) and os.path.isfile(fp), \\\n            f\"Cannot setup ReviewScorePrediction splits, as {fp} does not exist.\"\n\n        return load_splits_from_file(fp, self.dataset_type)\n\n    def setup(self, stage: str | None) -> None:\n        '''called one each GPU separately - stage defines if we are at fit or test step'''\n\n        # load all data\n        full_dataset = ReviewPaperDataset(self.base_path, self.dataset_type, self.paper_version, self.paper_format)\n\n        rsp_data = ReviewScorePredictionDataset(full_dataset,\n                                                transform=self.in_transform,\n                                                target_transform=self.target_transform)\n\n\n        # assign each review a split by its rid loaded from disk\n        split_ixs = []\n        for s in self.splits:\n            split_ixs += [[rsp_data.ids().index(rid) for i, rid in s]]\n\n        # discard train samples\n        if self.filter:\n            split_ixs[0] = [s for s in split_ixs[0] if self.filter(s)]\n\n        print(f\"{len(split_ixs[0])} Training samples loaded\")\n\n        self.dataset = DatasetDict({\n            \"train\": Dataset.from_dict(rsp_data.to_dict(split_ixs[0])),\n            \"dev\": Dataset.from_dict(rsp_data.to_dict(split_ixs[1])),\n            \"test\": Dataset.from_dict(rsp_data.to_dict(split_ixs[2])),\n        })\n\n        for split in self.dataset.keys():\n            self.dataset[split] = self.dataset[split].map(\n                self.convert_to_features,\n                batched=True,\n                remove_columns=[\"txt\", \"oscore\"]\n            )\n            self.dataset[split].set_format(type=\"torch\")\n\n    def train_dataloader(self):\n        \"\"\"returns training dataloader\"\"\"\n        dl_config = copy(self.data_loader_config)\n        dl_config[\"shuffle\"] = True\n\n        return DataLoader(self.dataset[\"train\"], **dl_config)\n\n    def val_dataloader(self):\n        \"\"\"returns validation dataloader\"\"\"\n        dl_config = copy(self.data_loader_config)\n        dl_config[\"shuffle\"] = False\n\n        return DataLoader(self.dataset[\"dev\"], **dl_config)\n\n    def test_dataloader(self):\n        \"\"\"returns test dataloader\"\"\"\n        dl_config = copy(self.data_loader_config)\n        dl_config[\"shuffle\"] = False\n\n        return DataLoader(self.dataset[\"test\"], **dl_config)\n\n    def predict_dataloader(self):\n        \"\"\"returns test dataloader\"\"\"\n        dl_config = copy(self.data_loader_config)\n        dl_config[\"shuffle\"] = False\n\n        return DataLoader(self.dataset[\"test\"], **dl_config)\n\n    def convert_to_features(self, sample_batch, indices=None):\n        labels = sample_batch[\"oscore\"]\n        input_raw = sample_batch[\"txt\"]\n\n        features = self.tokenizer(input_raw)\n        features[\"labels\"] = labels\n\n        return features", "class ReviewScorePredictionDataModule(LightningDataModule):\n    def __init__(self, benchmark_path: str,\n                 dataset_type: DATASETS,\n                 in_transform,\n                 target_transform,\n                 tokenizer,\n                 data_loader_config,\n                 paper_version=1,\n                 filter=None,\n                 paper_format=PAPERFORMATS.ITG):\n        super().__init__()\n\n        self.base_path = benchmark_path\n        self.dataset_type = dataset_type\n        self.paper_version = paper_version\n        self.paper_format = paper_format\n\n        self.in_transform = in_transform\n        self.target_transform = target_transform\n        self.tokenizer = tokenizer\n\n        self.splits = self._load_splits_idx()\n        self.dataset = None\n        self.filter = filter\n\n        self.data_loader_config = data_loader_config\n\n    def _load_splits_idx(self):\n        fp = pjoin(self.base_path, self.dataset_type.value, \"splits\", \"rsp_split.json\")\n\n        assert os.path.exists(fp) and os.path.isfile(fp), \\\n            f\"Cannot setup ReviewScorePrediction splits, as {fp} does not exist.\"\n\n        return load_splits_from_file(fp, self.dataset_type)\n\n    def setup(self, stage: str | None) -> None:\n        '''called one each GPU separately - stage defines if we are at fit or test step'''\n\n        # load all data\n        full_dataset = ReviewPaperDataset(self.base_path, self.dataset_type, self.paper_version, self.paper_format)\n\n        rsp_data = ReviewScorePredictionDataset(full_dataset,\n                                                transform=self.in_transform,\n                                                target_transform=self.target_transform)\n\n\n        # assign each review a split by its rid loaded from disk\n        split_ixs = []\n        for s in self.splits:\n            split_ixs += [[rsp_data.ids().index(rid) for i, rid in s]]\n\n        # discard train samples\n        if self.filter:\n            split_ixs[0] = [s for s in split_ixs[0] if self.filter(s)]\n\n        print(f\"{len(split_ixs[0])} Training samples loaded\")\n\n        self.dataset = DatasetDict({\n            \"train\": Dataset.from_dict(rsp_data.to_dict(split_ixs[0])),\n            \"dev\": Dataset.from_dict(rsp_data.to_dict(split_ixs[1])),\n            \"test\": Dataset.from_dict(rsp_data.to_dict(split_ixs[2])),\n        })\n\n        for split in self.dataset.keys():\n            self.dataset[split] = self.dataset[split].map(\n                self.convert_to_features,\n                batched=True,\n                remove_columns=[\"txt\", \"oscore\"]\n            )\n            self.dataset[split].set_format(type=\"torch\")\n\n    def train_dataloader(self):\n        \"\"\"returns training dataloader\"\"\"\n        dl_config = copy(self.data_loader_config)\n        dl_config[\"shuffle\"] = True\n\n        return DataLoader(self.dataset[\"train\"], **dl_config)\n\n    def val_dataloader(self):\n        \"\"\"returns validation dataloader\"\"\"\n        dl_config = copy(self.data_loader_config)\n        dl_config[\"shuffle\"] = False\n\n        return DataLoader(self.dataset[\"dev\"], **dl_config)\n\n    def test_dataloader(self):\n        \"\"\"returns test dataloader\"\"\"\n        dl_config = copy(self.data_loader_config)\n        dl_config[\"shuffle\"] = False\n\n        return DataLoader(self.dataset[\"test\"], **dl_config)\n\n    def predict_dataloader(self):\n        \"\"\"returns test dataloader\"\"\"\n        dl_config = copy(self.data_loader_config)\n        dl_config[\"shuffle\"] = False\n\n        return DataLoader(self.dataset[\"test\"], **dl_config)\n\n    def convert_to_features(self, sample_batch, indices=None):\n        labels = sample_batch[\"oscore\"]\n        input_raw = sample_batch[\"txt\"]\n\n        features = self.tokenizer(input_raw)\n        features[\"labels\"] = labels\n\n        return features", "\n\ndef create_and_store_splits(full_data: ReviewPaperDataset,\n                            out_dir,\n                            splits: list[float],\n                            random_gen: int = None):\n    splits = paperwise_random_split(full_data, splits, random_gen)\n\n    out_path = os.path.join(out_dir, \"rsp_split.json\")\n    store_splits_to_file(full_data, splits, out_path, random_gen)\n\n    return out_path", "\n\ndef prepare_dataset_splits(benchmark_path, paper_version, splits, random_gen, datasets=None):\n    if datasets is None:\n        datasets = [d for d in DATASETS]\n\n    out_files = []\n    for d in datasets:\n        full_dataset = ReviewPaperDataset(benchmark_path,\n                                          d,\n                                          paper_version,\n                                          PAPERFORMATS.ITG)\n\n        # filter by >= 1 review per paper\n        filter_gte_x_reviews(full_dataset, 1)\n\n        out_path = os.path.join(benchmark_path, d.value, \"splits\")\n        if not os.path.exists(out_path):\n            os.mkdir(out_path)\n\n        out_files += [create_and_store_splits(full_dataset, out_path, splits, random_gen)]\n\n    return out_files", "\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--benchmark_dir\", required=True, help=\"Path to the benchmark directory\")\n    parser.add_argument(\"--paper_version\", required=True, help=\"Which paper version\", type=int)\n    parser.add_argument(\"--random_seed\", required=True, help=\"Random seed to generate random splits\", type=int)\n    parser.add_argument(\"--datasets\", nargs=\"*\", required=False, help=\"list of datasets, if applicable\", type=str)\n\n    args = parser.parse_args()\n\n    prepare_dataset_splits(args.benchmark_dir,\n                           args.paper_version,\n                           [0.7, 0.1, 0.2],\n                           args.random_seed,\n                           [DATASETS[d] for d in args.datasets])"]}
{"filename": "nlpeer/tasks/review_score/models/baseline.py", "chunked_list": ["import argparse\nimport os\nfrom collections import Counter\nfrom typing import Any\n\nimport numpy as np\nimport torch\nimport wandb\nimport pytorch_lightning as pl\n", "import pytorch_lightning as pl\n\nfrom nlpeer import DATASETS, DATASET_REVIEW_OVERALL_SCALES\nfrom nlpeer.tasks.review_score.data import load_dataset_splits\n\n\nclass LitBaselineModule(pl.LightningModule):\n    def __init__(self, score):\n        super().__init__()\n\n        self.default_score = score\n\n    def forward(self, inputs) -> Any:\n        return {\"predictions\": torch.tensor([self.default_score for i in range(inputs[\"labels\"].shape[0])]),\n                \"labels\": inputs[\"labels\"]}\n\n    def predict_step(self, batch, batch_idx: int, dataloader_idx: int = None):\n        return self(batch)\n\n    def get_tokenizer(self):\n        return lambda lot: {\"nocontent\": [[l] for l in lot]}\n\n    def get_prepare_input(self, dataset_type: DATASETS):\n        input_transform = lambda x: {\"txt\": \"\"}\n        target_transform = None\n\n        return input_transform, target_transform", "\n\ndef from_config(config):\n    assert config[\"model\"][\"type\"].startswith(\"baseline\"),\\\n        \"Loading config for a baseline model, but passed a non-baseline config!\"\n\n    # module\n    model_params = config[\"model\"]\n    if \"load_path\" in model_params:\n        with open(model_params[\"load_path\"], \"r\") as file:\n            score = float(file.read().strip())\n    else:\n        score = model_params[\"score\"]\n\n    module = LitBaselineModule(score)\n\n    # use tokenizer and transforms that do nothing, but bring the data into the right format\n    tokenizer = lambda lot: {\"nocontent\": [[l] for l in lot]}\n    input_transform = lambda x: [1]\n    target_transform = None\n\n    return module", "\n\ndef compute_baselines(config):\n    train, dev, _ = load_dataset_splits(config[\"dataset\"][\"benchmark_path\"],\n                                               config[\"dataset\"][\"paper_version\"],\n                                               config[\"dataset\"][\"type\"],\n                                               None,\n                                               None,\n                                               None)\n\n    rev_scores = [train[i][1] for i in range(len(train))]\n    rev_scores += [dev[i][1] for i in range(len(dev))]\n\n    # avg. review score\n    avg_score = np.mean(rev_scores)\n\n    # avg. rounded review score\n    scale = DATASET_REVIEW_OVERALL_SCALES[config[\"dataset\"][\"type\"]][1]\n    avg_rounded_score = scale[np.argmin(np.abs(scale - avg_score))]\n\n    # majority\n    maj_score = Counter(rev_scores).most_common(1)[0][0]\n\n    return {\n        \"average_score\": avg_score,\n        \"average_rounded_score\": avg_rounded_score,\n        \"majority_score\": maj_score\n    }", "\n\ndef main(args):\n    if args.dataset == \"ALL\":\n        datasets = list(DATASETS)\n    else:\n        datasets = [DATASETS[args.dataset]]\n\n    with wandb.init(project=args.project):\n        for d in datasets:\n            config = {\n                \"dataset\":{\n                    \"benchmark_path\": args.benchmark_dir,\n                    \"paper_version\": args.paper_version,\n                    \"type\": d\n                }\n            }\n\n            baselines = compute_baselines(config)\n            tbl = wandb.Table(data=[[k, v] for k,v in baselines.items()], columns=[\"type\", \"value\"])\n            wandb.log({f\"baseline_{d.name}\": tbl})\n\n            for k, v in baselines.items():\n                if not os.path.exists(os.path.join(args.out_dir, d.name)):\n                    os.mkdir(os.path.join(args.out_dir, d.name))\n\n                if not os.path.exists(os.path.join(args.out_dir, d.name, f\"baseline_{k}\")):\n                    os.mkdir(os.path.join(args.out_dir, d.name, f\"baseline_{k}\"))\n\n                with open(os.path.join(args.out_dir, d.name, f\"baseline_{k}\", \"score.txt\"), \"w+\") as f:\n                    f.write(str(v))", "\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--benchmark_dir\", required=True, type=str, help=\"Path to the benchmark dir\")\n    parser.add_argument(\"--out_dir\", required=True, type=str, help=\"Path to store output\")\n    parser.add_argument(\"--project\", required=True, type=str, help=\"Project associated with the sweep\")\n    parser.add_argument(\"--dataset\", required=True, choices=[d.name for d in DATASETS] + [\"ALL\"], help=\"Name of the dataset\")\n    parser.add_argument(\"--paper_version\", required=False, default=1, type=int, help=\"Version of the paper\")\n\n    args = parser.parse_args()\n    main(args)"]}
{"filename": "nlpeer/tasks/review_score/models/__init__.py", "chunked_list": [""]}
{"filename": "nlpeer/tasks/review_score/models/TransformerBased.py", "chunked_list": ["from typing import Callable, Optional\n\nimport numpy as np\nimport pytorch_lightning as pl\nimport torch\nfrom pytorch_lightning.utilities.types import STEP_OUTPUT\nfrom transformers import AutoTokenizer, AutoModelForSequenceClassification, get_linear_schedule_with_warmup, \\\n    AutoConfig\n\n# model", "\n# model\nfrom nlpeer.data import DATASETS\nfrom nlpeer import DATASET_REVIEW_OVERALL_SCALES\nfrom nlpeer.tasks import get_optimizer, get_loss_function, abstract_with_review_only\n\n\nclass LitTransformerRspModule(pl.LightningModule):\n    def __init__(self,\n                 model_type,\n                 train_loss,\n                 dev_loss,\n                 optimizer,\n                 weight_decay: float = 0.1,\n                 warmup_ratio: int = 0.06,\n                 **kwargs):\n        super().__init__()\n\n        # save hyperparameters\n        self.save_hyperparameters()\n\n        # optimizer args\n        self.optimizer = optimizer\n\n        # define model\n        self.config = AutoConfig.from_pretrained(model_type, num_labels=1)\n        self.model = AutoModelForSequenceClassification.from_pretrained(model_type, config=self.config)\n        self.model_type = model_type\n\n        # use provided losses\n        self.train_loss = train_loss\n        self.dev_loss = dev_loss\n\n    def forward(self, **inputs):\n        return self.model(**inputs)\n\n    def training_step(self, batch, batch_idx):\n        out = self(**batch)\n        loss, logits = out[0], out[1]\n\n        targets = batch[\"labels\"]\n        pred = logits.squeeze() if logits.size()[0] > 1 else logits\n        tloss = self.train_loss(pred, targets)\n\n        self.log(\"train_loss\", tloss)\n\n        return loss\n\n    def validation_step(self, batch, batch_idx) -> Optional[STEP_OUTPUT]:\n        out = self(**batch)\n        loss, logits = out[0], out[1]\n\n        targets = batch[\"labels\"].to(torch.float32)\n        pred = logits.squeeze() if logits.size()[0] > 1 else logits\n        vloss = self.dev_loss(pred, targets)\n\n        self.log(\"val_loss\", vloss)\n\n        return loss\n\n    def configure_optimizers(self):\n        no_decay = [\"bias\", \"LayerNorm.weight\"]\n        optimizer_grouped_parameters = [\n            {\n                \"params\": [p for n, p in self.model.named_parameters() if not any(nd in n for nd in no_decay)],\n                \"weight_decay\": self.hparams.weight_decay,\n            },\n            {\n                \"params\": [p for n, p in self.model.named_parameters() if any(nd in n for nd in no_decay)],\n                \"weight_decay\": 0.0,\n            },\n        ]\n        optimizer = self.optimizer(optimizer_grouped_parameters, lr=self.hparams.lr, eps=self.hparams.eps)\n\n        scheduler = get_linear_schedule_with_warmup(\n            optimizer,\n            num_warmup_steps=self.hparams.warmup_ratio * self.trainer.estimated_stepping_batches,\n            num_training_steps=self.trainer.estimated_stepping_batches,\n        )\n        scheduler = {\"scheduler\": scheduler, \"interval\": \"step\", \"frequency\": 1}\n\n        return [optimizer], [scheduler]\n\n    def predict_step(self, batch, batch_idx: int, dataloader_idx: int = None):\n        out = self(**batch)\n        loss, logits = out[0], out[1]\n\n        return {\"loss\": loss,\n                \"predictions\": logits.flatten(),\n                \"labels\": batch[\"labels\"].to(torch.float32)}\n\n    def on_predict_epoch_end(self, results):\n        preds = torch.cat([x['predictions'] for x in results[0]]).detach().cpu().numpy()\n        labels = torch.cat([x['labels'] for x in results[0]]).detach().cpu().numpy()\n\n        return {\"predictions\": preds, \"labels\": labels}\n\n    def get_tokenizer(self) -> Callable:\n        tokenizer = AutoTokenizer.from_pretrained(self.model_type)\n\n        def tokenize(dataset):\n            return tokenizer(dataset, padding=\"max_length\", truncation=True, max_length=512)\n\n        return tokenize\n\n    def get_prepare_input(self, dataset_type: DATASETS) -> tuple[Callable, Callable or None]:\n        input_transform = abstract_with_review_only()\n\n        # target normalize\n        review_scale = DATASET_REVIEW_OVERALL_SCALES[dataset_type][1]\n\n        def normalize_overall_score(s):\n            min_val = np.min(review_scale)\n            max_val = np.max(review_scale)\n\n            return (s - min_val) / float(max_val - min_val)\n\n        target_transform = normalize_overall_score\n\n        return input_transform, target_transform", "\n\ndef from_config(config):\n    # load from config\n    if config and \"model\" in config and \"train\" in config and \"load_path\" not in config[\"model\"]:\n        model_params = config[\"model\"]\n\n        if model_params[\"type\"] in [\"biobert\", \"roberta\", \"scibert\"]: #aliases\n            if model_params[\"type\"] == \"roberta\":\n                mtype = \"roberta-base\"\n            elif model_params[\"type\"] == \"biobert\":\n                mtype = \"dmis-lab/biobert-v1.1\"\n            elif model_params[\"type\"] == \"scibert\":\n                mtype = \"allenai/scibert_scivocab_uncased\"\n        else:\n            mtype = model_params[\"type\"]\n\n        return LitTransformerRspModule(model_type=mtype,\n                                       train_loss=get_loss_function(config[\"train\"][\"train_loss\"]),\n                                       dev_loss=get_loss_function(config[\"train\"][\"dev_loss\"], **config[\"train\"][\"dev_loss_kwargs\"] if \"dev_loss_kwargs\" in config[\"train\"] else {}),\n                                       optimizer=get_optimizer(config[\"train\"][\"optimizer\"]),\n                                       lr=config[\"train\"][\"learning_rate\"],\n                                       eps=config[\"train\"][\"epsilon\"])\n    # from disk\n    elif config and \"model\" in config and \"load_path\" in config[\"model\"]:\n        return LitTransformerRspModule.load_from_checkpoint(config[\"model\"][\"load_path\"])\n    else:\n        raise ValueError(\"Malformed config. Requires training regime and/or a model path to load from\")"]}
{"filename": "nlpeer/tasks/skimming/train.py", "chunked_list": ["import argparse\nimport os\nimport time\nimport uuid\n\nfrom pytorch_lightning import Trainer, seed_everything\nfrom pytorch_lightning.callbacks import ModelCheckpoint, EarlyStopping\nfrom pytorch_lightning.loggers import WandbLogger\n\nimport torch", "\nimport torch\nimport wandb\n\nfrom nlpeer.data import DATASETS\nfrom nlpeer.tasks.skimming.data import SkimmingDataModule\n\nOUT_PATH = None\nBENCHMARK_PATH = None\nDEVICE = \"gpu\" if torch.cuda.is_available() else \"cpu\"", "BENCHMARK_PATH = None\nDEVICE = \"gpu\" if torch.cuda.is_available() else \"cpu\"\n\n\ndef get_default_config():\n    global BENCHMARK_PATH, DEVICE\n\n    assert BENCHMARK_PATH is not None and os.path.exists(BENCHMARK_PATH), \\\n        f\"Provided benchmark path is None or does not exist: {BENCHMARK_PATH}\"\n\n    return {\n        \"data_loader\": {\n            \"num_workers\": 8,\n            \"shuffle\": True\n        },\n        \"dataset\": {\n            \"benchmark_path\": BENCHMARK_PATH\n        },\n        \"machine\": {\n            \"device\": DEVICE\n        }\n    }", "\n\ndef merge_configs(config, default_config):\n    to_expand = [(config, default_config)]\n    while len(to_expand) > 0:\n        c, oc = to_expand.pop(0)\n\n        for k, v in oc.items():\n            if k not in c:\n                c[k] = v\n            elif type(c[k]) == dict:\n                to_expand += [(c[k], v)]", "            # else ignore oc config, use the conf you already have\n\n\ndef setup(config, debug=False):\n    # get module and transforms\n    if config[\"model\"][\"type\"] in [\"roberta\", \"biobert\", \"scibert\"]:\n        from nlpeer.tasks.skimming.models.TransformerBased import from_config\n        module = from_config(config)\n    elif config[\"model\"][\"type\"].startswith(\"baseline\"):\n        # from tasks.stance_detection.models.baseline import from_config\n        # module = from_config(config)\n        raise NotImplementedError()\n    else:\n        raise ValueError(f\"The provided model type {config['model']['type']} is not supported\")\n\n    input_transform, target_transform = module.get_prepare_input()\n    tokenizer = module.get_tokenizer()\n\n    if debug:\n        config[\"data_loader\"][\"num_workers\"] = 0\n\n    # load data module\n    data_module = SkimmingDataModule(benchmark_path=config[\"dataset\"][\"benchmark_path\"],\n                                          dataset_type=DATASETS[config[\"dataset\"][\"type\"]],\n                                          in_transform=input_transform,\n                                          target_transform=target_transform,\n                                          tokenizer=tokenizer,\n                                          sampling_strategy=\"random\",\n                                          sampling_size=5, # tood load from params\n                                          data_loader_config=config[\"data_loader\"],\n                                          paper_version=config[\"dataset\"][\"paper_version\"])\n\n    return module, data_module", "\n\ndef train(model, data_module, params, logger=None, debug=False):\n    global OUT_PATH\n\n    print(f\"RUN = {wandb.run.name}\")\n\n    chkp_dir = os.path.join(OUT_PATH, f\"checkpoints/{params['dataset']['type']}/{params['model']['type']}\")\n    checkpoint_callback = ModelCheckpoint(monitor=\"val_loss\",\n                                          mode=\"max\",\n                                          dirpath=chkp_dir,\n                                          filename=\"{epoch}-{val_loss}-\" + str(uuid.uuid4()),\n                                          save_top_k=1,\n                                          # every_n_train_steps=10\n                                          )\n    early_stop_callback = EarlyStopping(monitor=\"val_loss\",\n                                        mode=\"max\",\n                                        patience=8,\n                                        min_delta=0.005)\n\n    trainer = Trainer(logger=logger,\n                      log_every_n_steps=1,\n                      limit_train_batches=0.05 if debug else 1.0,\n                      # devices=1,\n                      max_epochs=params[\"train\"][\"epochs\"],\n                      accelerator=params[\"machine\"][\"device\"],\n                      callbacks=[checkpoint_callback, early_stop_callback])\n\n    # fit the model\n    trainer.fit(model, data_module)\n\n    # output best model path\n    wandb.log({\"best_model\": checkpoint_callback.best_model_path})\n    print(f\"best_model = {checkpoint_callback.best_model_path}\")", "\n\ndef run(config, debug=False, project=None):\n    global OUT_PATH\n\n    dconfig = get_default_config()\n    merge_configs(config, dconfig)\n\n    # set seed and log\n    seed = int(time.time()) % 100000\n    config[\"random_seed\"] = seed\n    seed_everything(seed)\n\n    # actual training\n    model, data = setup(config, debug)\n    train(model, data, config, WandbLogger(dir=os.path.join(OUT_PATH, \"logs\"), project=project), debug)", "\n\ndef main(args):\n    global BENCHMARK_PATH, OUT_PATH\n    BENCHMARK_PATH = args.benchmark_path\n    OUT_PATH = args.store_results\n\n    assert os.path.exists(BENCHMARK_PATH) and os.path.exists(OUT_PATH), \\\n        f\"Benchmark or out path do not exist. Check {BENCHMARK_PATH} and {OUT_PATH} again.\"\n\n    # use default config (basically for debugging)\n    dconf = {\n        \"dataset\": {\n            \"type\": args.dataset,\n            \"paper_version\": 1\n        },\n        \"model\": {\n            \"type\": args.model\n        },\n        \"train\": {\n            \"epochs\": 20,\n            \"train_loss\": \"ce\",\n            \"dev_loss\": \"acc\",\n            \"optimizer\": \"adam\",\n            \"learning_rate\": 2e-5 if args.lr is None else args.lr,\n            \"epsilon\": 1e-8,\n            \"structure_labels\": False if args.structure_labels is None else args.structure_labels\n        },\n        \"data_loader\": {\n            \"batch_size\": 2 if args.batch_size is None else args.batch_size\n        }\n    }\n    runs = args.repeat if args.repeat else 1\n\n    for i in range(runs):\n        run(dconf, debug=args.debug, project=args.project if args.project is not None else \"Skimming_train\")", "\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--benchmark_path\", required=True, type=str, help=\"Path to the benchmark dir\")\n    parser.add_argument(\"--store_results\", required=True, type=str, help=\"Path for logs + results\")\n    parser.add_argument(\"--dataset\", required=False, choices=[d.name for d in DATASETS],\n                        help=\"Dataset name if no sweep provided\")\n    parser.add_argument(\"--model\", required=False, type=str, help=\"model name if no sweep provided\")\n    parser.add_argument(\"--lr\", required=False, type=float, help=\"learning rate (opt)\")\n    parser.add_argument(\"--structure_labels\", required=False, type=bool, help=\"True, if to use structure labels as input\")\n    parser.add_argument(\"--batch_size\", required=False, type=int, help=\"batch size (opt)\")\n    parser.add_argument(\"--repeat\", required=False, type=int, default=1, help=\"Number of repetitions\")\n    parser.add_argument(\"--debug\", required=False, type=bool, default=False, help=\"Number of repetitions\")\n\n    parser.add_argument(\"--project\", required=False, type=str, help=\"Project name in WANDB\")\n\n    args = parser.parse_args()\n\n    assert args.project is not None and args.repeat is not None, \"Project name required for running a wandb sweep\"\n\n    assert args.dataset is not None and args.model is not None, \\\n        \"Dataset type required if not loading from sweep config\"\n\n    main(args)", ""]}
{"filename": "nlpeer/tasks/skimming/evaluate.py", "chunked_list": ["import argparse\nimport simplejson\nimport json\nimport os\nfrom copy import copy\nfrom typing import Callable\nfrom collections import Counter\nimport plotly.graph_objects as go\n\nfrom os.path import join as pjoin", "\nfrom os.path import join as pjoin\n\nimport numpy as np\nimport scipy.stats\nimport sklearn\nimport torch\nimport wandb\nfrom pytorch_lightning import Trainer\nfrom pytorch_lightning.loggers import WandbLogger", "from pytorch_lightning import Trainer\nfrom pytorch_lightning.loggers import WandbLogger\n\nimport nlpeer.tasks\nfrom nlpeer import DATASETS\nfrom nlpeer.tasks import get_class_map_skimming\nfrom nlpeer.data.utils import list_files\nfrom nlpeer.tasks.skimming.data import SkimmingDataModule\nfrom nlpeer.tasks.stance_detection.data import StanceDetectionDataModule\n", "from nlpeer.tasks.stance_detection.data import StanceDetectionDataModule\n\nOUT_PATH = None\nBENCHMARK_PATH = None\nDEVICE = \"gpu\" if torch.cuda.is_available() else \"cpu\"\n\n\ndef get_default_config():\n    global BENCHMARK_PATH, DEVICE\n\n    assert BENCHMARK_PATH is not None and os.path.exists(BENCHMARK_PATH), \\\n        f\"Provided benchmark path is None or does not exist: {BENCHMARK_PATH}\"\n\n    return {\n        \"data_loader\": {\n            \"num_workers\": 0,\n            \"shuffle\": False\n        },\n        \"dataset\": {\n            \"benchmark_path\": BENCHMARK_PATH,\n            \"splits_from_file\": True\n        },\n        \"machine\": {\n            \"device\": DEVICE\n        }\n    }", "\n\n# 1. F1-score + accuracy + confusion matrix\ndef classification_error(true_scores, predicted_scores, log=False):\n    majority_score = get_class_map_skimming()[\"negative\"]\n\n    f1_accu, prec_accu, rec_accu, acc_accu = [], [], [], []\n    base_f1_accu, base_prec_accu, base_rec_accu, base_acc_accu = [], [], [], []\n    for sample_t, sample_p in zip(true_scores, predicted_scores):\n        f1_accu += [sklearn.metrics.f1_score(sample_t, sample_p, pos_label=get_class_map_skimming()[\"positive\"])]\n        prec_accu += [sklearn.metrics.precision_score(sample_t, sample_p, pos_label=get_class_map_skimming()[\"positive\"])]\n        rec_accu += [sklearn.metrics.recall_score(sample_t, sample_p, pos_label=get_class_map_skimming()[\"positive\"])]\n        acc_accu += [sklearn.metrics.accuracy_score(sample_t, sample_p)]\n\n        majority_baseline = [majority_score for s in sample_t]\n        base_f1_accu += [sklearn.metrics.f1_score(sample_t, sample_p, pos_label=get_class_map_skimming()[\"positive\"])]\n        base_prec_accu += [sklearn.metrics.precision_score(sample_t, sample_p, pos_label=get_class_map_skimming()[\"positive\"])]\n        base_rec_accu += [sklearn.metrics.recall_score(sample_t, sample_p, pos_label=get_class_map_skimming()[\"positive\"])]\n        base_acc_accu += [sklearn.metrics.accuracy_score(sample_t, majority_baseline)]\n\n    if log:\n        wandb.log({\"f1\": {\"mean\": np.mean(f1_accu), \"std\": np.std(f1_accu)}})\n        wandb.log({\"prec\": {\"mean\": np.mean(prec_accu), \"std\": np.std(prec_accu)}})\n        wandb.log({\"rec\": {\"mean\": np.mean(rec_accu), \"std\": np.std(rec_accu)}})\n        wandb.log({\"accuracy\": {\"mean\": np.mean(acc_accu), \"std\": np.std(acc_accu)}})\n        wandb.log({\"labels\": get_class_map_skimming()})\n        wandb.log(\n            {\"baseline\": {\"f1\": {\"mean\": np.mean(base_f1_accu), \"std\": np.std(base_f1_accu)},\n                          \"prec\": {\"mean\": np.mean(base_prec_accu), \"std\": np.std(base_prec_accu)},\n                          \"rec\": {\"mean\": np.mean(base_rec_accu), \"std\": np.std(base_rec_accu)},\n                          \"accuracy\": {\"mean\": np.mean(base_acc_accu), \"std\": np.std(base_acc_accu)}}})\n\n    return {\n        \"f1\": {\"mean\": float(np.mean(f1_accu)), \"std\": float(np.std(f1_accu))},\n        \"prec\": {\"mean\": float(np.mean(prec_accu)), \"std\": float(np.std(prec_accu))},\n        \"rec\": {\"mean\": float(np.mean(rec_accu)), \"std\": float(np.std(rec_accu))},\n        \"accuracy\": {\"mean\": float(np.mean(acc_accu)), \"std\": float(np.std(acc_accu))},\n        \"base_f1\": {\"mean\": float(np.mean(base_f1_accu)), \"std\": float(np.std(base_f1_accu))},\n        \"base_prec\": {\"mean\": float(np.mean(base_prec_accu)), \"std\": float(np.std(base_prec_accu))},\n        \"base_rec\": {\"mean\": float(np.mean(base_rec_accu)), \"std\": float(np.std(base_rec_accu))},\n        \"base_accuracy\": {\"mean\": float(np.mean(base_acc_accu)), \"std\": float(np.std(base_acc_accu))},\n    }", "\n\ndef rank_measures(true_scores, estimated_scores, ks:list):\n    accu = []\n    auroc_accu = []\n    aupr_accu = []\n    mrr = []\n    for true_s, estimated_s in zip(true_scores, estimated_scores):\n        ranking = list(sorted(zip(true_s, estimated_s), key=lambda x: x[1], reverse=True))\n\n        measures_at_k = {}\n        for k in ks:\n            if k > len(ranking):\n                measures_at_k[f\"precision@{k}\"] = np.nan\n                measures_at_k[f\"recall@{k}\"] = np.nan\n\n            measures_at_k[f\"precision@{k}\"] = sklearn.metrics.precision_score([r[0] for r in ranking[:k]], [get_class_map_skimming()[\"positive\"] for r in ranking[:k]], pos_label=get_class_map_skimming()[\"positive\"])\n            measures_at_k[f\"recall@{k}\"] = sklearn.metrics.recall_score([r[0] for r in ranking[:k]], [get_class_map_skimming()[\"positive\"] for r in ranking[:k]], pos_label=get_class_map_skimming()[\"positive\"])\n\n        auroc = sklearn.metrics.roc_auc_score(true_s, estimated_s)\n        auroc_accu += [auroc]\n\n        pr_curve = sklearn.metrics.precision_recall_curve(true_s, estimated_s)\n        au_pr_curve = sklearn.metrics.auc(pr_curve[1], pr_curve[0])\n        aupr_accu += [au_pr_curve]\n\n        accu += [measures_at_k]\n\n        mrr += [1 / (1+float(next(i for i, r in enumerate(ranking) if r[0] == get_class_map_skimming()[\"positive\"])))]\n\n    result_at_k = {}\n    mean_prec = {f\"mean_precision@{k}\": float(np.nanmean([m[f\"precision@{k}\"] for m in accu])) for k in ks}\n    std_prec = {f\"std_precision@{k}\": float(np.nanstd([m[f\"precision@{k}\"] for m in accu])) for k in ks}\n    result_at_k.update(mean_prec)\n    result_at_k.update(std_prec)\n\n    mean_rec = {f\"mean_recall@{k}\": float(np.nanmean([m[f\"recall@{k}\"] for m in accu])) for k in ks}\n    std_rec = {f\"std_recall@{k}\": float(np.nanstd([m[f\"recall@{k}\"] for m in accu])) for k in ks}\n    result_at_k.update(mean_rec)\n    result_at_k.update(std_rec)\n\n    result_auroc = {}\n    result_auroc[\"mean_auroc\"] = float(np.nanmean(auroc_accu))\n    result_auroc[\"std_auroc\"] = float(np.nanstd(auroc_accu))\n\n    result_aupr = {}\n    result_aupr[\"mean_aupr\"] = float(np.nanmean(aupr_accu))\n    result_aupr[\"std_aupr\"] = float(np.nanstd(aupr_accu))\n\n    result_mrr = {\"mean_reciprocal_rank\": float(np.mean(mrr)), \"std_reciprocal_rank\": float(np.std(mrr))}\n\n    return result_at_k, result_auroc, result_aupr, result_mrr", "\n\n# 2. Ranking error\ndef ranking_error(true_relevance, estimated_relevance, log=False):\n    precision_recall, auroc, aupr, mrr = rank_measures(true_relevance, estimated_relevance, ks=[2, 3, 4, 5, 6, 8])\n\n    random_baseline = [[float(x) for x in np.random.random(len(x)).tolist()] for x in true_relevance]\n    base_pr, base_auroc, base_aupr, base_mrr = rank_measures(true_relevance, random_baseline, ks=[2, 3, 4, 5, 6, 8])\n\n    if log:\n        wandb.log({\"precision_recall_at_k\": precision_recall})\n        wandb.log({\"AUROC\": auroc})\n        wandb.log({\"AU_PR_Curve\": aupr})\n        wandb.log({\"MRR\": mrr})\n\n    return {\n        \"precision_recall_at_k\": precision_recall,\n        \"auroc\": auroc,\n        \"au_pr_curve\": aupr,\n        \"mrr\": mrr,\n        \"baseline\": {\n            \"precision_recall_at_k\": base_pr,\n            \"auroc\": base_auroc,\n            \"au_pr_curve\": base_aupr,\n            \"mrr\": base_mrr,\n        }\n    }", "\ndef setup(config):\n    assert \"load_path\" in config[\"model\"], \"Provide a 'load_path' attribute in the config.model to load a checkpoint\"\n\n    if config[\"model\"][\"type\"] in [\"roberta\", \"biobert\", \"scibert\"]:\n        from nlpeer.tasks.skimming.models.TransformerBased import from_config\n        module = from_config(config)\n    elif config[\"model\"][\"type\"] in [\"baseline\"]:\n        from nlpeer.tasks.skimming.models.LengthBaseline import from_config\n        module = from_config(config)\n    else:\n        raise ValueError(\"The provided model type is not supported\")\n\n    input_transform, target_transform = module.get_prepare_input()\n    tokenizer = module.get_tokenizer()\n\n    # prepare data (loading splits from disk)\n    data_module_main = SkimmingDataModule(benchmark_path=config[\"dataset\"][\"benchmark_path\"],\n                                          dataset_type=DATASETS[config[\"dataset\"][\"type\"]],\n                                          in_transform=input_transform,\n                                          target_transform=target_transform,\n                                          tokenizer=tokenizer,\n                                          sampling_strategy=\"random\", #todo load from params\n                                          sampling_size=5, # tood load from params\n                                          data_loader_config=config[\"data_loader\"],\n                                          paper_version=config[\"dataset\"][\"paper_version\"])\n\n    return module, data_module_main, (input_transform, target_transform, tokenizer)", "\n\ndef get_predictions(model, data_module, params, logger, debug=False):\n    trainer = Trainer(logger=logger,\n                      log_every_n_steps=1,\n                      devices=1,\n                      limit_predict_batches= 0.4 if debug else 1.0,\n                      accelerator=params[\"machine\"][\"device\"])\n\n    # accuracy as a loss/performance metric is stored with device information -- discard for predictions.\n    model.dev_loss = None\n    model.train_loss = None\n    model.to(\"cuda\" if params[\"machine\"][\"device\"] == \"gpu\" else params[\"machine\"][\"device\"])\n\n    return trainer.predict(model, data_module)", "\n\ndef run(config, debug=False):\n    global OUT_PATH\n\n    cname = f\"{config['dataset']['type']}_{config['model']['type']}\"\n\n    with wandb.init(dir=os.path.join(OUT_PATH, \"logs\"), config=config, project=config[\"project\"], name=cname):\n        dconfig = get_default_config()\n        if debug:\n            dconfig[\"data_loader\"][\"num_workers\"] = 0\n\n        tasks.merge_configs(config, dconfig)\n\n        wandb_logger = WandbLogger(dir=os.path.join(OUT_PATH, \"logs\"), config=config)\n\n        print(f\"Starting evaluation with config {config}\")\n\n        # get model checkpoints and config paths\n        model_load_path = pjoin(config[\"model\"][\"load_path\"], config[\"model\"][\"type\"])\n        mconf_path = pjoin(model_load_path, \"config.json\") if os.path.exists(\n            pjoin(model_load_path, \"config.json\")) else None\n        checkpoints = [c for c in list_files(model_load_path) if os.path.basename(c) != \"config.json\"]\n\n        if len(checkpoints) == 0:\n            print(f\"WARNING: Model load path directory lacks checkpoints: {checkpoints}\")\n\n        if config[\"model\"][\"type\"] in [\"baseline\"]:\n            checkpoints = [f\"baseline-{config['model']['thresh']}\"]\n\n        # load the model config\n        mconf = copy(config)\n\n        print(\"Evaluation...\")\n\n        accu_res = evaluation(checkpoints, config, mconf, wandb_logger, debug)\n        mean_res = compute_mean_stats(accu_res)\n\n        wandb.log({\"mean_res\": mean_res})\n\n        mean_res[\"accu\"] = accu_res\n\n        def np_encoder(object):\n            if isinstance(object, np.generic):\n                return object.item()\n            else:\n                return None\n\n        print(\"Storing results\")\n\n        with open(pjoin(OUT_PATH, f\"skimming_eval_{config['dataset']['type']}_{config['model']['type']}.json\"),\n                  \"w+\") as f:\n            simplejson.dump(mean_res, f, indent=4, ignore_nan=True, default=np_encoder)", "\n\ndef compute_mean_stats(accu_res):\n    mean_res = {}\n    for s in accu_res:\n        for t in s:\n            if type(s[t]) != dict:\n                continue\n\n            if t not in mean_res:\n                mean_res[t] = {}\n\n            for k, v in s[t].items():\n                try:\n                    vf = float(v)\n                except (ValueError, TypeError):\n                    continue\n\n                if k not in mean_res[t]:\n                    mean_res[t][k] = []\n\n                mean_res[t][k] += [vf]\n    for t in mean_res:\n        for k, v in mean_res[t].items():\n            mean_res[t][k] = {\"mean\": float(np.mean(v)), \"median\": float(np.median(v)), \"std\": float(np.std(v))}\n\n    return mean_res", "\n\ndef compute_nested_mean_stats(accu_res):\n    mean_res = {}\n    for s in accu_res:\n        measures = [([], list(s.items()))]\n        while len(measures) > 0:\n            prefix, items = measures.pop()\n\n            for key, val in items:\n                if type(val) == dict:\n                    measures += [(prefix + [key], list(val.items()))]\n                elif type(val) not in [str, list]:\n                    cur_position = mean_res\n                    for p in prefix:\n                        if p not in cur_position:\n                            cur_position[p] = {}\n\n                        cur_position = cur_position[p]\n\n                    if key not in cur_position:\n                        cur_position[key] = [val]\n                    else:\n                        cur_position[key] += [val]\n                else:\n                    raise ValueError(f\"Not supported type {type(val)} found. Cannot aggregate.\")\n\n    pointers = [([], list(mean_res.items()))]\n    while len(pointers) > 0:\n        prefix, items = pointers.pop()\n\n        for key, val in items:\n            if type(val) == dict:\n                pointers += [(prefix + [key], list(val.items()))]\n            else:\n                cur_position = mean_res\n                for p in prefix:\n                    if p not in cur_position:\n                        cur_position[p] = {}\n\n                    cur_position = cur_position[p]\n\n                measurements = val[:]\n                cur_position[key] = np.mean(measurements), np.median(measurements), np.std(measurements)\n\n    return mean_res", "\n\ndef evaluation(checkpoints, config, model_config, wandb_logger, debug=False):\n    accu_res = []\n    for cpath in checkpoints:\n        # define setup config\n        model_config[\"model\"][\"load_path\"] = cpath\n        model_config[\"dataset\"] = config[\"dataset\"]\n        model_config[\"data_loader\"] = config[\"data_loader\"]\n        model_config[\"machine\"] = config[\"machine\"]\n\n        # prep evaluation\n        model, data_module_main, transforms = setup(model_config)\n\n        predictions = get_predictions(model, data_module_main, config, wandb_logger, debug)\n\n        labels, estimates, pred_labels, rankings = [], [] , [], []\n        for batch in predictions:\n            es = [sample.detach().cpu().tolist() for sample in batch[\"logits\"]]\n\n            labels += [sample.detach().cpu().tolist() for sample in batch[\"labels\"]]\n            estimates += es\n            pred_labels += [sample.detach().cpu().tolist() for sample in batch[\"predictions\"]]\n\n            rankings += [[s[get_class_map_skimming()[\"positive\"]] for s in e] for e in es]\n\n        print(\"labels\", labels)\n        print(\"predicted\", pred_labels)\n        print(\"rankings\", rankings)\n        print(\"estimates\", estimates)\n\n        # evaluate\n        eval_conf = config[\"evaluation\"]\n\n        res = {}\n        if \"error\" in eval_conf and eval_conf[\"error\"]:\n            res[\"error\"] = classification_error(labels, pred_labels, True)\n\n        if \"ranking_error\" in eval_conf and eval_conf[\"ranking_error\"]:\n            res[\"ranking_error\"] = ranking_error(labels, rankings, True)\n\n        res[\"predicted_ranking\"] = rankings\n        res[\"true_labels\"] = labels\n\n        accu_res += [res]\n    return accu_res", "\n\ndef main(args):\n    global BENCHMARK_PATH, OUT_PATH\n    BENCHMARK_PATH = args.benchmark_dir\n    OUT_PATH = args.store_results\n\n    assert os.path.exists(BENCHMARK_PATH) and os.path.exists(OUT_PATH), \\\n        f\"Benchmark or out path do not exist. Check {BENCHMARK_PATH} and {OUT_PATH} again.\"\n\n    config = {\n        \"name\": f\"Evaluation\",\n        \"project\": args.project,\n        \"random_seed\": {\n            \"value\": 6295629\n        },\n        \"model\": {\n            \"type\": args.model_type,\n            \"load_path\": pjoin(args.chkp_dir, f\"{DATASETS[args.dataset].name}\")\n        },\n        \"data_loader\": {\n            \"batch_size\": 2\n        },\n        \"dataset\": {\n            \"type\": DATASETS[args.dataset].name,\n            \"paper_version\": args.paper_version\n        },\n        \"evaluation\": {\n            \"error\": True,\n            \"ranking_error\": True,\n            \"domain_ransfer\": False\n        }\n    }\n\n    run(config, debug=args.debug)", "\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--benchmark_dir\", required=True, type=str, help=\"Path to the benchmark dir\")\n    parser.add_argument(\"--project\", required=True, type=str, help=\"Project name in WANDB\")\n    parser.add_argument(\"--store_results\", required=True, type=str, help=\"Path for logs + results\")\n    parser.add_argument(\"--debug\", required=False, default=False, type=bool, help=\"Set true for debugging\")\n    parser.add_argument(\"--chkp_dir\", required=True, type=str, help=\"Path to load the checkpoints from\")\n    parser.add_argument(\"--dataset\", required=True, choices=[d.name for d in DATASETS], help=\"Name of the dataset\")\n    parser.add_argument(\"--model_type\", required=True, type=str, help=\"Model type e.g. biobert\")\n    parser.add_argument(\"--paper_version\", required=False, default=1, type=int, help=\"Version of the paper\")\n\n    args = parser.parse_args()\n    main(args)", ""]}
{"filename": "nlpeer/tasks/skimming/__init__.py", "chunked_list": [""]}
{"filename": "nlpeer/tasks/skimming/data.py", "chunked_list": ["import argparse\nimport json\nimport os\nfrom collections import Counter\nfrom copy import copy\nfrom os.path import join as pjoin\n\nfrom datasets import DatasetDict, Dataset\nfrom pytorch_lightning import LightningDataModule\nfrom torch.utils.data import DataLoader", "from pytorch_lightning import LightningDataModule\nfrom torch.utils.data import DataLoader\n\nfrom nlpeer.data import paperwise_stratified_split\nfrom nlpeer import DATASETS, PAPERFORMATS, PaperReviewDataset\nfrom nlpeer.tasks import SkimmingDataset\n\n\nclass SkimmingDataModule(LightningDataModule):\n    def __init__(self, benchmark_path: str,\n                 dataset_type: DATASETS,\n                 in_transform,\n                 target_transform,\n                 tokenizer,\n                 data_loader_config,\n                 sampling_strategy: str = \"random\",\n                 sampling_size: int = 5,\n                 paper_version=1,\n                 paper_format=PAPERFORMATS.ITG):\n        super().__init__()\n\n        self.base_path = benchmark_path\n        self.dataset_type = dataset_type\n        self.paper_version = paper_version\n        self.paper_format = paper_format\n\n        self.in_transform = in_transform\n        self.target_transform = target_transform\n        self.tokenizer = tokenizer\n\n        self.sampling_strategy = sampling_strategy\n        self.sampling_size = sampling_size\n\n        self.splits = self._load_splits_idx()\n        self.full_data = None\n        self.train_data = None\n        self.dev_data = None\n        self.test_data = None\n\n        self.data_loader_config = data_loader_config\n\n    def _load_splits_idx(self):\n        fp = pjoin(self.base_path, self.dataset_type.value, \"splits\", \"skimming_split.json\")\n\n        assert os.path.exists(fp) and os.path.isfile(\n            fp), f\"Cannot setup Actionability splits, as {fp} does not exist.\"\n\n        with open(fp, \"r\") as file:\n            split_data = json.load(file)\n\n        return split_data[\"splits\"]\n\n    def setup(self, stage: str | None) -> None:\n        '''called one each GPU separately - stage defines if we are at fit or test step'''\n        full_dataset = PaperReviewDataset(self.base_path,\n                                          self.dataset_type,\n                                          self.paper_version,\n                                          self.paper_format,\n                                          hold_in_memory=True)\n\n        sk_dataset = SkimmingDataset(full_dataset,\n                                     self.in_transform,\n                                     self.target_transform,\n                                     selected_types=[\"quote\", \"line\", \"sec-ix\", \"sec-name\"],\n                                     sampling=self.sampling_strategy,\n                                     sample_size=self.sampling_size)\n\n        # \"none\" sampling strategy for testing\n        sk_dataset_test = SkimmingDataset(full_dataset,\n                                          self.in_transform,\n                                          self.target_transform,\n                                          selected_types=[\"quote\", \"line\", \"sec-ix\", \"sec-name\"],\n                                          sampling=\"none\")\n\n        # load splits\n        split_ixs = []\n        for s in self.splits[:2]:\n            split_ixs += [[sk_dataset.ids().index(rid) for i, rid in s]]\n\n        # load test split by pids (instead of pid%node_id (of positive nodes))\n        test_pids = set([rid.split(\"%\")[0] for i, rid in self.splits[2]])\n        split_ixs += [[sk_dataset_test.ids().index(pid+\"%all\") for pid in test_pids]]\n\n        self.dataset = DatasetDict({\n            \"train\": Dataset.from_dict(sk_dataset.to_dict(split_ixs[0])),\n            \"dev\": Dataset.from_dict(sk_dataset.to_dict(split_ixs[1])),\n            \"test\": Dataset.from_dict(sk_dataset_test.to_dict(split_ixs[2])),\n        })\n\n        for split in self.dataset.keys():\n            print(f\"Setting up {split}\")\n            self.dataset[split] = self.dataset[split].map(\n                self.convert_to_features,\n                batched=False\n            )\n            self.dataset[split].set_format(type=\"torch\")\n\n        print(\"Dataset initialized\")\n\n    @staticmethod\n    def _collate_batches(batch):\n        result = {\"positives\": [], \"negatives\": []}\n        for t in result:\n            for s in batch:\n                result[t] += [s[t]]\n\n        return result\n\n    def train_dataloader(self):\n        '''returns training dataloader'''\n        dl_config = copy(self.data_loader_config)\n        dl_config[\"shuffle\"] = True\n\n        return DataLoader(self.dataset[\"train\"], **dl_config, collate_fn=self._collate_batches)\n\n    def val_dataloader(self):\n        '''returns validation dataloader'''\n        dl_config = copy(self.data_loader_config)\n        dl_config[\"shuffle\"] = False\n\n        return DataLoader(self.dataset[\"dev\"], **dl_config, collate_fn=self._collate_batches)\n\n    def test_dataloader(self):\n        '''returns test dataloader'''\n        dl_config = copy(self.data_loader_config)\n        dl_config[\"shuffle\"] = False\n\n        return DataLoader(self.dataset[\"test\"], **dl_config, collate_fn=self._collate_batches)\n\n    def predict_dataloader(self):\n        '''returns test dataloader'''\n        dl_config = copy(self.data_loader_config)\n        dl_config[\"shuffle\"] = False\n\n        return DataLoader(self.dataset[\"test\"], **dl_config, collate_fn=self._collate_batches)\n\n    def convert_to_features(self, sample, indices=None):\n        # here we get: sample_batch[\"positives\"] -> list of dicts (likewise for negatives)\n        # iterate over positives and negatives\n        # now we get the relevant features (txt, label) from each of the entries and apply the tokenizer\n        # we output a dict of {\"positives\": [mapped feats], \"negatives\": [...]}\n\n        features = {\"positives\": None, \"negatives\": None}\n        for t in features:\n            items = sample[t]\n\n            input_raw = items[\"txt\"]\n            labels = items[\"label\"]\n\n            features[t] = self.tokenizer(input_raw)\n            features[t][\"labels\"] = labels\n\n        return features", "class SkimmingDataModule(LightningDataModule):\n    def __init__(self, benchmark_path: str,\n                 dataset_type: DATASETS,\n                 in_transform,\n                 target_transform,\n                 tokenizer,\n                 data_loader_config,\n                 sampling_strategy: str = \"random\",\n                 sampling_size: int = 5,\n                 paper_version=1,\n                 paper_format=PAPERFORMATS.ITG):\n        super().__init__()\n\n        self.base_path = benchmark_path\n        self.dataset_type = dataset_type\n        self.paper_version = paper_version\n        self.paper_format = paper_format\n\n        self.in_transform = in_transform\n        self.target_transform = target_transform\n        self.tokenizer = tokenizer\n\n        self.sampling_strategy = sampling_strategy\n        self.sampling_size = sampling_size\n\n        self.splits = self._load_splits_idx()\n        self.full_data = None\n        self.train_data = None\n        self.dev_data = None\n        self.test_data = None\n\n        self.data_loader_config = data_loader_config\n\n    def _load_splits_idx(self):\n        fp = pjoin(self.base_path, self.dataset_type.value, \"splits\", \"skimming_split.json\")\n\n        assert os.path.exists(fp) and os.path.isfile(\n            fp), f\"Cannot setup Actionability splits, as {fp} does not exist.\"\n\n        with open(fp, \"r\") as file:\n            split_data = json.load(file)\n\n        return split_data[\"splits\"]\n\n    def setup(self, stage: str | None) -> None:\n        '''called one each GPU separately - stage defines if we are at fit or test step'''\n        full_dataset = PaperReviewDataset(self.base_path,\n                                          self.dataset_type,\n                                          self.paper_version,\n                                          self.paper_format,\n                                          hold_in_memory=True)\n\n        sk_dataset = SkimmingDataset(full_dataset,\n                                     self.in_transform,\n                                     self.target_transform,\n                                     selected_types=[\"quote\", \"line\", \"sec-ix\", \"sec-name\"],\n                                     sampling=self.sampling_strategy,\n                                     sample_size=self.sampling_size)\n\n        # \"none\" sampling strategy for testing\n        sk_dataset_test = SkimmingDataset(full_dataset,\n                                          self.in_transform,\n                                          self.target_transform,\n                                          selected_types=[\"quote\", \"line\", \"sec-ix\", \"sec-name\"],\n                                          sampling=\"none\")\n\n        # load splits\n        split_ixs = []\n        for s in self.splits[:2]:\n            split_ixs += [[sk_dataset.ids().index(rid) for i, rid in s]]\n\n        # load test split by pids (instead of pid%node_id (of positive nodes))\n        test_pids = set([rid.split(\"%\")[0] for i, rid in self.splits[2]])\n        split_ixs += [[sk_dataset_test.ids().index(pid+\"%all\") for pid in test_pids]]\n\n        self.dataset = DatasetDict({\n            \"train\": Dataset.from_dict(sk_dataset.to_dict(split_ixs[0])),\n            \"dev\": Dataset.from_dict(sk_dataset.to_dict(split_ixs[1])),\n            \"test\": Dataset.from_dict(sk_dataset_test.to_dict(split_ixs[2])),\n        })\n\n        for split in self.dataset.keys():\n            print(f\"Setting up {split}\")\n            self.dataset[split] = self.dataset[split].map(\n                self.convert_to_features,\n                batched=False\n            )\n            self.dataset[split].set_format(type=\"torch\")\n\n        print(\"Dataset initialized\")\n\n    @staticmethod\n    def _collate_batches(batch):\n        result = {\"positives\": [], \"negatives\": []}\n        for t in result:\n            for s in batch:\n                result[t] += [s[t]]\n\n        return result\n\n    def train_dataloader(self):\n        '''returns training dataloader'''\n        dl_config = copy(self.data_loader_config)\n        dl_config[\"shuffle\"] = True\n\n        return DataLoader(self.dataset[\"train\"], **dl_config, collate_fn=self._collate_batches)\n\n    def val_dataloader(self):\n        '''returns validation dataloader'''\n        dl_config = copy(self.data_loader_config)\n        dl_config[\"shuffle\"] = False\n\n        return DataLoader(self.dataset[\"dev\"], **dl_config, collate_fn=self._collate_batches)\n\n    def test_dataloader(self):\n        '''returns test dataloader'''\n        dl_config = copy(self.data_loader_config)\n        dl_config[\"shuffle\"] = False\n\n        return DataLoader(self.dataset[\"test\"], **dl_config, collate_fn=self._collate_batches)\n\n    def predict_dataloader(self):\n        '''returns test dataloader'''\n        dl_config = copy(self.data_loader_config)\n        dl_config[\"shuffle\"] = False\n\n        return DataLoader(self.dataset[\"test\"], **dl_config, collate_fn=self._collate_batches)\n\n    def convert_to_features(self, sample, indices=None):\n        # here we get: sample_batch[\"positives\"] -> list of dicts (likewise for negatives)\n        # iterate over positives and negatives\n        # now we get the relevant features (txt, label) from each of the entries and apply the tokenizer\n        # we output a dict of {\"positives\": [mapped feats], \"negatives\": [...]}\n\n        features = {\"positives\": None, \"negatives\": None}\n        for t in features:\n            items = sample[t]\n\n            input_raw = items[\"txt\"]\n            labels = items[\"label\"]\n\n            features[t] = self.tokenizer(input_raw)\n            features[t][\"labels\"] = labels\n\n        return features", "\n\ndef store_splits(dataset, splits, random_gen, out_path):\n    jsplits = {\n        \"dataset_type\": dataset.data.dataset_type.name,\n        \"dataset\": dataset.__class__.__name__,\n        \"splits\": [\n            [[int(s), dataset.ids()[s]] for s in split] for split in splits\n        ],\n        \"random\": str(random_gen)\n    }\n\n    with open(out_path, \"w+\") as f:\n        json.dump(jsplits, f)", "\n\ndef create_and_store_splits(full_data: SkimmingDataset,\n                            out_dir,\n                            splits: list[float],\n                            random_gen: int = None):\n    # covered papers\n    pid_samples = [i.split(\"%\")[0] for i in full_data.ids()]\n    pids = list(set(pid_samples))\n\n    hist = Counter(pid_samples)\n    max = hist.most_common()[0][1]\n    min = hist.most_common()[-1][1]\n    bucket_num = 5\n    bucket_step = (max - min) // (bucket_num + 1)\n    bucket_step = bucket_step if bucket_step > 0 else 1\n\n    def bucketed_samples_per_pid(pid):\n        s = hist[pid] - min\n        return s // bucket_step\n\n    splitted_pids_ix = paperwise_stratified_split(pids, splits, bucketed_samples_per_pid, random_gen)\n    splitted_pids = [[pids[i] for i in split] for split in splitted_pids_ix]\n    split_ix, split_ids = [], []\n    for spids in splitted_pids:\n        ix_of_split = []\n        id_of_split = []\n        for pid in spids:\n            matching_samples = [(i, iid) for i, iid in enumerate(full_data.ids()) if iid.split(\"%\")[0] == pid]\n            ix_of_split += [ix for ix, iid in matching_samples]\n            id_of_split += [iid for ix, iid in matching_samples]\n\n        split_ix += [ix_of_split]\n        split_ids += [id_of_split]\n\n    out_path = os.path.join(out_dir, \"skimming_split.json\")\n    store_splits(full_data, split_ix, random_gen, out_path)\n\n    return out_path", "\n\ndef prepare_dataset_splits(benchmark_path, paper_version, splits, random_gen, datasets=None):\n    if datasets is None:\n        datasets = [d for d in DATASETS]\n\n    out_files = []\n    for d in datasets:\n        full_dataset = PaperReviewDataset(benchmark_path,\n                                          d,\n                                          paper_version,\n                                          PAPERFORMATS.ITG)\n\n        sk_dataset = SkimmingDataset(full_dataset,\n                                     selected_types=[\"quote\", \"line\", \"sec-ix\", \"sec-name\"],\n                                     sampling=\"full\")\n\n        out_path = os.path.join(benchmark_path, d.value, \"splits\")\n        if not os.path.exists(out_path):\n            os.mkdir(out_path)\n\n        out_files += [create_and_store_splits(sk_dataset, out_path, splits, random_gen)]\n\n    return out_files", "\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--benchmark_dir\", required=True, help=\"Path to the benchmark directory\")\n    parser.add_argument(\"--paper_version\", required=True, help=\"Which paper version\", type=int)\n    parser.add_argument(\"--random_seed\", required=True, help=\"Random seed to generate random splits\", type=int)\n    parser.add_argument(\"--datasets\", nargs=\"*\", required=False, help=\"list of datasets, if applicable\", type=str)\n\n    args = parser.parse_args()\n\n    prepare_dataset_splits(args.benchmark_dir,\n                           args.paper_version,\n                           [0.7, 0.1, 0.2],\n                           args.random_seed,\n                           [DATASETS[d] for d in\n                            (args.datasets if args.datasets is not None else [d.name for d in DATASETS])])", ""]}
{"filename": "nlpeer/tasks/skimming/models/LengthBaseline.py", "chunked_list": ["import argparse\nimport logging\nfrom typing import Callable, Optional\n\nimport numpy as np\nimport pytorch_lightning as pl\nimport torch\nimport wandb\nfrom pytorch_lightning.utilities.types import STEP_OUTPUT\nfrom transformers import AutoModel, AutoTokenizer, AutoModelForSequenceClassification, AutoConfig, \\", "from pytorch_lightning.utilities.types import STEP_OUTPUT\nfrom transformers import AutoModel, AutoTokenizer, AutoModelForSequenceClassification, AutoConfig, \\\n    get_linear_schedule_with_warmup\n\n# model\nfrom nlpeer import DATASETS, DATASET_REVIEW_OVERALL_SCALES\nfrom nlpeer.tasks import get_optimizer, get_loss_function, get_paragraph_text, get_class_map_skimming\n\n\nclass LitBaselineSkimmingModule(pl.LightningModule):\n    def __init__(self,\n                 **kwargs):\n        super().__init__()\n\n        # save hyperparameters\n        self.save_hyperparameters()\n\n    def forward(self, inputs):\n        return torch.Tensor([(len(i)) for i in inputs[\"txt\"]])\n\n    def training_step(self, batch, batch_idx):\n        return None\n\n    def validation_step(self, batch, batch_idx) -> Optional[STEP_OUTPUT]:\n        positives = batch[\"positives\"]\n        negatives = batch[\"negatives\"]\n\n        batch_size = len(positives)\n\n        total_vloss = None\n        for i in range(batch_size):\n            out_p = self(positives[i])\n            targets_p = positives[i][\"labels\"].to(torch.int32)\n\n            out_n = self(negatives[i])\n            targets_n = negatives[i][\"labels\"].to(torch.int32)\n\n            vloss = self.dev_loss(torch.cat((out_p, out_n), 0).flatten(), torch.cat((targets_p, targets_n), 0).flatten())\n            total_vloss = total_vloss + vloss if total_vloss is not None else vloss\n\n        self.log(\"val_loss\", total_vloss / float(batch_size))\n\n        return total_vloss / float(batch_size)\n\n    def predict_step(self, batch, batch_idx: int, dataloader_idx: int = None):\n        positives = batch[\"positives\"]\n        negatives = batch[\"negatives\"]\n\n        batch_size = len(positives)\n\n        targets, predictions, logits = [],[], []\n        for i in range(batch_size):\n            out_p = self(positives[i])\n            targets_p = positives[i][\"labels\"].to(torch.int32)\n\n            out_n = self(negatives[i])\n            targets_n = negatives[i][\"labels\"].to(torch.int32)\n\n            targets += [torch.concat((targets_p.flatten(), targets_n.flatten()), 0)]\n            predictions += [torch.concat((torch.Tensor([(1 if p > self.thresh else 0) for p in out_p]).flatten(), torch.Tensor([(1 if p > self.thresh else 0) for p in out_n]).flatten()), 0)]\n            logits += [torch.concat((torch.Tensor([[0, x] for x in out_p.flatten()]),\n                                     torch.Tensor([[0, x] for x in out_n.flatten()])), 0)]\n\n        return {\"predictions\": predictions, \"labels\": targets, \"logits\": logits}\n\n    def on_predict_epoch_end(self, results):\n        preds = [[y.detach().cpu().numpy() for y in x[\"predictions\"]] for x in results[0]]\n        labels = [[y.detach().cpu().numpy() for y in x[\"labels\"]] for x in results[0]]\n        logits = [[y.detach().cpu().numpy() for y in x[\"logits\"]] for x in results[0]]\n\n        return {\"predictions\": preds, \"labels\": labels, \"logits\": logits}\n\n    def get_tokenizer(self) -> Callable:\n        def tokenize(dataset):\n            return {\"txt\": dataset}\n\n        return tokenize\n\n    def get_prepare_input(self) -> tuple[Callable, Callable or None]:\n        input_transform = get_paragraph_text()\n        target_transform = lambda x: get_class_map_skimming()[x]\n\n        return input_transform, target_transform", "\nclass LitBaselineSkimmingModule(pl.LightningModule):\n    def __init__(self,\n                 **kwargs):\n        super().__init__()\n\n        # save hyperparameters\n        self.save_hyperparameters()\n\n    def forward(self, inputs):\n        return torch.Tensor([(len(i)) for i in inputs[\"txt\"]])\n\n    def training_step(self, batch, batch_idx):\n        return None\n\n    def validation_step(self, batch, batch_idx) -> Optional[STEP_OUTPUT]:\n        positives = batch[\"positives\"]\n        negatives = batch[\"negatives\"]\n\n        batch_size = len(positives)\n\n        total_vloss = None\n        for i in range(batch_size):\n            out_p = self(positives[i])\n            targets_p = positives[i][\"labels\"].to(torch.int32)\n\n            out_n = self(negatives[i])\n            targets_n = negatives[i][\"labels\"].to(torch.int32)\n\n            vloss = self.dev_loss(torch.cat((out_p, out_n), 0).flatten(), torch.cat((targets_p, targets_n), 0).flatten())\n            total_vloss = total_vloss + vloss if total_vloss is not None else vloss\n\n        self.log(\"val_loss\", total_vloss / float(batch_size))\n\n        return total_vloss / float(batch_size)\n\n    def predict_step(self, batch, batch_idx: int, dataloader_idx: int = None):\n        positives = batch[\"positives\"]\n        negatives = batch[\"negatives\"]\n\n        batch_size = len(positives)\n\n        targets, predictions, logits = [],[], []\n        for i in range(batch_size):\n            out_p = self(positives[i])\n            targets_p = positives[i][\"labels\"].to(torch.int32)\n\n            out_n = self(negatives[i])\n            targets_n = negatives[i][\"labels\"].to(torch.int32)\n\n            targets += [torch.concat((targets_p.flatten(), targets_n.flatten()), 0)]\n            predictions += [torch.concat((torch.Tensor([(1 if p > self.thresh else 0) for p in out_p]).flatten(), torch.Tensor([(1 if p > self.thresh else 0) for p in out_n]).flatten()), 0)]\n            logits += [torch.concat((torch.Tensor([[0, x] for x in out_p.flatten()]),\n                                     torch.Tensor([[0, x] for x in out_n.flatten()])), 0)]\n\n        return {\"predictions\": predictions, \"labels\": targets, \"logits\": logits}\n\n    def on_predict_epoch_end(self, results):\n        preds = [[y.detach().cpu().numpy() for y in x[\"predictions\"]] for x in results[0]]\n        labels = [[y.detach().cpu().numpy() for y in x[\"labels\"]] for x in results[0]]\n        logits = [[y.detach().cpu().numpy() for y in x[\"logits\"]] for x in results[0]]\n\n        return {\"predictions\": preds, \"labels\": labels, \"logits\": logits}\n\n    def get_tokenizer(self) -> Callable:\n        def tokenize(dataset):\n            return {\"txt\": dataset}\n\n        return tokenize\n\n    def get_prepare_input(self) -> tuple[Callable, Callable or None]:\n        input_transform = get_paragraph_text()\n        target_transform = lambda x: get_class_map_skimming()[x]\n\n        return input_transform, target_transform", "\n\ndef from_config(config):\n    return LitBaselineSkimmingModule()"]}
{"filename": "nlpeer/tasks/skimming/models/__init__.py", "chunked_list": [""]}
{"filename": "nlpeer/tasks/skimming/models/TransformerBased.py", "chunked_list": ["import argparse\nimport logging\nfrom typing import Callable, Optional\n\nimport numpy as np\nimport pytorch_lightning as pl\nimport torch\nimport wandb\nfrom pytorch_lightning.utilities.types import STEP_OUTPUT\nfrom transformers import AutoModel, AutoTokenizer, AutoModelForSequenceClassification, AutoConfig, \\", "from pytorch_lightning.utilities.types import STEP_OUTPUT\nfrom transformers import AutoModel, AutoTokenizer, AutoModelForSequenceClassification, AutoConfig, \\\n    get_linear_schedule_with_warmup\n\n# model\nfrom nlpeer.data import DATASETS\nfrom nlpeer import DATASET_REVIEW_OVERALL_SCALES\nfrom nlpeer.tasks import get_optimizer, get_loss_function, get_paragraph_text, get_class_map_skimming\n\n\nclass LitTransformerSkimmingModule(pl.LightningModule):\n    def __init__(self,\n                 model_type,\n                 train_loss,\n                 dev_loss,\n                 optimizer,\n                 num_labels,\n                 learning_mode=\"pointwise\",\n                 structure_labels=False,\n                 weight_decay: float = 0.1,\n                 warmup_ratio: int = 0.06,\n                 **kwargs):\n        super().__init__()\n\n        # save hyperparameters\n        self.save_hyperparameters()\n\n        # optimizer args\n        self.optimizer = optimizer\n\n        # define model\n        self.config = AutoConfig.from_pretrained(model_type, num_labels=num_labels)\n        self.model = AutoModelForSequenceClassification.from_pretrained(model_type, config=self.config)\n        self.model_type = model_type\n\n        self.structure_labels = structure_labels\n\n        # use provided losses\n        self.train_loss = train_loss\n        self.dev_loss = dev_loss\n\n    def forward(self, **inputs):\n        return self.model(**inputs)\n\n    def training_step(self, batch, batch_idx):\n        positives = batch[\"positives\"]\n        negatives = batch[\"negatives\"]\n\n        batch_size = len(positives)\n\n        total_tloss = None\n        for i in range(batch_size):\n            out_p = self(attention_mask=positives[i][\"attention_mask\"], input_ids=positives[i][\"input_ids\"],\n                         labels=positives[i][\"labels\"])\n            loss_p, logits_p = out_p[0], out_p[1]\n            targets_p = positives[i][\"labels\"]\n\n            out_n = self(attention_mask=negatives[i][\"attention_mask\"], input_ids=negatives[i][\"input_ids\"],\n                         labels=negatives[i][\"labels\"])\n            loss_n, logits_n = out_n[0], out_n[1]\n            targets_n = negatives[i][\"labels\"]\n\n            tloss = self.train_loss(torch.cat((logits_p, logits_n), 0), torch.cat((targets_p, targets_n), 0))\n            total_tloss = total_tloss + tloss if total_tloss is not None else tloss\n\n        self.log(\"train_loss\", total_tloss)\n\n        return total_tloss\n\n    def validation_step(self, batch, batch_idx) -> Optional[STEP_OUTPUT]:\n        positives = batch[\"positives\"]\n        negatives = batch[\"negatives\"]\n\n        batch_size = len(positives)\n\n        total_vloss = None\n        for i in range(batch_size):\n            out_p = self(attention_mask=positives[i][\"attention_mask\"], input_ids=positives[i][\"input_ids\"], labels=positives[i][\"labels\"])\n            loss_p, logits_p = out_p[0], out_p[1]\n\n            predictions_p = torch.argmax(logits_p, axis=1).to(torch.int32)\n            targets_p = positives[i][\"labels\"].to(torch.int32)\n\n            out_n = self(attention_mask=negatives[i][\"attention_mask\"], input_ids=negatives[i][\"input_ids\"], labels=negatives[i][\"labels\"])\n            loss_n, logits_n = out_n[0], out_n[1]\n\n            predictions_n = torch.argmax(logits_n, axis=1).to(torch.int32)\n            targets_n = negatives[i][\"labels\"].to(torch.int32)\n\n            vloss = self.dev_loss(torch.cat((predictions_p, predictions_n), 0).flatten(), torch.cat((targets_p, targets_n), 0).flatten())\n            total_vloss = total_vloss + vloss if total_vloss is not None else vloss\n\n        self.log(\"val_loss\", total_vloss / float(batch_size))\n\n        return total_vloss / float(batch_size)\n\n    def predict_step(self, batch, batch_idx: int, dataloader_idx: int = None):\n        positives = batch[\"positives\"]\n        negatives = batch[\"negatives\"]\n\n        batch_size = len(positives)\n\n        softmax = torch.nn.Softmax(dim=1)\n\n        targets = []\n        predictions = []\n        logits = []\n        for i in range(batch_size):\n            out_p = self(attention_mask=positives[i][\"attention_mask\"], input_ids=positives[i][\"input_ids\"],\n                         labels=positives[i][\"labels\"])\n            loss_p, logits_p = out_p[0], out_p[1]\n\n            predictions_p = torch.argmax(logits_p, axis=1).to(torch.int32)\n            targets_p = positives[i][\"labels\"].to(torch.int32)\n\n            out_n = self(attention_mask=negatives[i][\"attention_mask\"], input_ids=negatives[i][\"input_ids\"],\n                         labels=negatives[i][\"labels\"])\n            loss_n, logits_n = out_n[0], out_n[1]\n\n            predictions_n = torch.argmax(logits_n, axis=1).to(torch.int32)\n            targets_n = negatives[i][\"labels\"].to(torch.int32)\n\n            targets += [torch.concat((targets_p.flatten(), targets_n.flatten()), 0)]\n            predictions += [torch.concat((predictions_p.flatten(), predictions_n.flatten()), 0)]\n            logits += [torch.concat((softmax(logits_p), softmax(logits_n)), 0)]\n\n        return {\"predictions\": predictions, \"logits\": logits, \"labels\": targets}\n\n    def on_predict_epoch_end(self, results):\n        preds = [[y.detach().cpu().numpy() for y in x[\"predictions\"]] for x in results[0]]\n        labels = [[y.detach().cpu().numpy() for y in x[\"labels\"]] for x in results[0]]\n        logits = [[y.detach().cpu().numpy() for y in x[\"logits\"]]for x in results[0]]\n\n        return {\"predictions\": preds, \"labels\": labels, \"logits\": logits}\n\n    def configure_optimizers(self):\n        no_decay = [\"bias\", \"LayerNorm.weight\"]\n        optimizer_grouped_parameters = [\n            {\n                \"params\": [p for n, p in self.model.named_parameters() if not any(nd in n for nd in no_decay)],\n                \"weight_decay\": self.hparams.weight_decay,\n            },\n            {\n                \"params\": [p for n, p in self.model.named_parameters() if any(nd in n for nd in no_decay)],\n                \"weight_decay\": 0.0,\n            },\n        ]\n        optimizer = self.optimizer(optimizer_grouped_parameters, lr=self.hparams.lr, eps=self.hparams.eps)\n\n        scheduler = get_linear_schedule_with_warmup(\n            optimizer,\n            num_warmup_steps=self.hparams.warmup_ratio * self.trainer.estimated_stepping_batches,\n            num_training_steps=self.trainer.estimated_stepping_batches,\n        )\n        scheduler = {\"scheduler\": scheduler, \"interval\": \"step\", \"frequency\": 1}\n\n        return [optimizer], [scheduler]\n\n\n    def get_tokenizer(self) -> Callable:\n        tokenizer = AutoTokenizer.from_pretrained(self.model_type, use_fast=True)\n\n        def tokenize(dataset):\n            return tokenizer(dataset, padding=\"max_length\", truncation=True, max_length=512)\n\n        return tokenize\n\n    def get_prepare_input(self) -> tuple[Callable, Callable or None]:\n        input_transform = get_paragraph_text(self.structure_labels)\n        target_transform = lambda x: get_class_map_skimming()[x]\n\n        return input_transform, target_transform", "\n\nclass LitTransformerSkimmingModule(pl.LightningModule):\n    def __init__(self,\n                 model_type,\n                 train_loss,\n                 dev_loss,\n                 optimizer,\n                 num_labels,\n                 learning_mode=\"pointwise\",\n                 structure_labels=False,\n                 weight_decay: float = 0.1,\n                 warmup_ratio: int = 0.06,\n                 **kwargs):\n        super().__init__()\n\n        # save hyperparameters\n        self.save_hyperparameters()\n\n        # optimizer args\n        self.optimizer = optimizer\n\n        # define model\n        self.config = AutoConfig.from_pretrained(model_type, num_labels=num_labels)\n        self.model = AutoModelForSequenceClassification.from_pretrained(model_type, config=self.config)\n        self.model_type = model_type\n\n        self.structure_labels = structure_labels\n\n        # use provided losses\n        self.train_loss = train_loss\n        self.dev_loss = dev_loss\n\n    def forward(self, **inputs):\n        return self.model(**inputs)\n\n    def training_step(self, batch, batch_idx):\n        positives = batch[\"positives\"]\n        negatives = batch[\"negatives\"]\n\n        batch_size = len(positives)\n\n        total_tloss = None\n        for i in range(batch_size):\n            out_p = self(attention_mask=positives[i][\"attention_mask\"], input_ids=positives[i][\"input_ids\"],\n                         labels=positives[i][\"labels\"])\n            loss_p, logits_p = out_p[0], out_p[1]\n            targets_p = positives[i][\"labels\"]\n\n            out_n = self(attention_mask=negatives[i][\"attention_mask\"], input_ids=negatives[i][\"input_ids\"],\n                         labels=negatives[i][\"labels\"])\n            loss_n, logits_n = out_n[0], out_n[1]\n            targets_n = negatives[i][\"labels\"]\n\n            tloss = self.train_loss(torch.cat((logits_p, logits_n), 0), torch.cat((targets_p, targets_n), 0))\n            total_tloss = total_tloss + tloss if total_tloss is not None else tloss\n\n        self.log(\"train_loss\", total_tloss)\n\n        return total_tloss\n\n    def validation_step(self, batch, batch_idx) -> Optional[STEP_OUTPUT]:\n        positives = batch[\"positives\"]\n        negatives = batch[\"negatives\"]\n\n        batch_size = len(positives)\n\n        total_vloss = None\n        for i in range(batch_size):\n            out_p = self(attention_mask=positives[i][\"attention_mask\"], input_ids=positives[i][\"input_ids\"], labels=positives[i][\"labels\"])\n            loss_p, logits_p = out_p[0], out_p[1]\n\n            predictions_p = torch.argmax(logits_p, axis=1).to(torch.int32)\n            targets_p = positives[i][\"labels\"].to(torch.int32)\n\n            out_n = self(attention_mask=negatives[i][\"attention_mask\"], input_ids=negatives[i][\"input_ids\"], labels=negatives[i][\"labels\"])\n            loss_n, logits_n = out_n[0], out_n[1]\n\n            predictions_n = torch.argmax(logits_n, axis=1).to(torch.int32)\n            targets_n = negatives[i][\"labels\"].to(torch.int32)\n\n            vloss = self.dev_loss(torch.cat((predictions_p, predictions_n), 0).flatten(), torch.cat((targets_p, targets_n), 0).flatten())\n            total_vloss = total_vloss + vloss if total_vloss is not None else vloss\n\n        self.log(\"val_loss\", total_vloss / float(batch_size))\n\n        return total_vloss / float(batch_size)\n\n    def predict_step(self, batch, batch_idx: int, dataloader_idx: int = None):\n        positives = batch[\"positives\"]\n        negatives = batch[\"negatives\"]\n\n        batch_size = len(positives)\n\n        softmax = torch.nn.Softmax(dim=1)\n\n        targets = []\n        predictions = []\n        logits = []\n        for i in range(batch_size):\n            out_p = self(attention_mask=positives[i][\"attention_mask\"], input_ids=positives[i][\"input_ids\"],\n                         labels=positives[i][\"labels\"])\n            loss_p, logits_p = out_p[0], out_p[1]\n\n            predictions_p = torch.argmax(logits_p, axis=1).to(torch.int32)\n            targets_p = positives[i][\"labels\"].to(torch.int32)\n\n            out_n = self(attention_mask=negatives[i][\"attention_mask\"], input_ids=negatives[i][\"input_ids\"],\n                         labels=negatives[i][\"labels\"])\n            loss_n, logits_n = out_n[0], out_n[1]\n\n            predictions_n = torch.argmax(logits_n, axis=1).to(torch.int32)\n            targets_n = negatives[i][\"labels\"].to(torch.int32)\n\n            targets += [torch.concat((targets_p.flatten(), targets_n.flatten()), 0)]\n            predictions += [torch.concat((predictions_p.flatten(), predictions_n.flatten()), 0)]\n            logits += [torch.concat((softmax(logits_p), softmax(logits_n)), 0)]\n\n        return {\"predictions\": predictions, \"logits\": logits, \"labels\": targets}\n\n    def on_predict_epoch_end(self, results):\n        preds = [[y.detach().cpu().numpy() for y in x[\"predictions\"]] for x in results[0]]\n        labels = [[y.detach().cpu().numpy() for y in x[\"labels\"]] for x in results[0]]\n        logits = [[y.detach().cpu().numpy() for y in x[\"logits\"]]for x in results[0]]\n\n        return {\"predictions\": preds, \"labels\": labels, \"logits\": logits}\n\n    def configure_optimizers(self):\n        no_decay = [\"bias\", \"LayerNorm.weight\"]\n        optimizer_grouped_parameters = [\n            {\n                \"params\": [p for n, p in self.model.named_parameters() if not any(nd in n for nd in no_decay)],\n                \"weight_decay\": self.hparams.weight_decay,\n            },\n            {\n                \"params\": [p for n, p in self.model.named_parameters() if any(nd in n for nd in no_decay)],\n                \"weight_decay\": 0.0,\n            },\n        ]\n        optimizer = self.optimizer(optimizer_grouped_parameters, lr=self.hparams.lr, eps=self.hparams.eps)\n\n        scheduler = get_linear_schedule_with_warmup(\n            optimizer,\n            num_warmup_steps=self.hparams.warmup_ratio * self.trainer.estimated_stepping_batches,\n            num_training_steps=self.trainer.estimated_stepping_batches,\n        )\n        scheduler = {\"scheduler\": scheduler, \"interval\": \"step\", \"frequency\": 1}\n\n        return [optimizer], [scheduler]\n\n\n    def get_tokenizer(self) -> Callable:\n        tokenizer = AutoTokenizer.from_pretrained(self.model_type, use_fast=True)\n\n        def tokenize(dataset):\n            return tokenizer(dataset, padding=\"max_length\", truncation=True, max_length=512)\n\n        return tokenize\n\n    def get_prepare_input(self) -> tuple[Callable, Callable or None]:\n        input_transform = get_paragraph_text(self.structure_labels)\n        target_transform = lambda x: get_class_map_skimming()[x]\n\n        return input_transform, target_transform", "\n\ndef from_config(config):\n    # load from config\n    if config and \"model\" in config and \"train\" in config and \"load_path\" not in config[\"model\"]:\n        model_params = config[\"model\"]\n\n        if model_params[\"type\"] in [\"biobert\", \"roberta\", \"scibert\"]:  # aliases\n            if model_params[\"type\"] == \"roberta\":\n                mtype = \"roberta-base\"\n            elif model_params[\"type\"] == \"biobert\":\n                mtype = \"dmis-lab/biobert-v1.1\"\n            elif model_params[\"type\"] == \"scibert\":\n                mtype = \"allenai/scibert_scivocab_uncased\"\n        else:\n            mtype = model_params[\"type\"]\n\n        return LitTransformerSkimmingModule(model_type=mtype,\n                                                 train_loss=get_loss_function(config[\"train\"][\"train_loss\"]),\n                                                 dev_loss=get_loss_function(config[\"train\"][\"dev_loss\"],\n                                                                            **config[\"train\"][\n                                                                                \"dev_loss_kwargs\"] if \"dev_loss_kwargs\" in\n                                                                                                      config[\n                                                                                                          \"train\"] else {}),\n                                                 optimizer=get_optimizer(config[\"train\"][\"optimizer\"]),\n                                                 lr=config[\"train\"][\"learning_rate\"],\n                                                 eps=config[\"train\"][\"epsilon\"],\n                                                 structure_labels=config[\"train\"][\"structure_labels\"],\n                                                 num_labels=len(get_class_map_skimming()))\n    # from disk\n    elif config and \"model\" in config and \"load_path\" in config[\"model\"]:\n        return LitTransformerSkimmingModule.load_from_checkpoint(config[\"model\"][\"load_path\"])\n    else:\n        raise ValueError(\"Malformed config. Requires training regime and/or a model path to load from\")", ""]}
{"filename": "nlpeer/tasks/pragmatic_labeling/train.py", "chunked_list": ["import argparse\nimport os\nimport time\nimport uuid\n\nfrom pytorch_lightning import Trainer, seed_everything\nfrom pytorch_lightning.callbacks import ModelCheckpoint, EarlyStopping\nfrom pytorch_lightning.loggers import WandbLogger\n\nimport torch", "\nimport torch\nimport wandb\n\nfrom nlpeer.data import DATASETS\n\nfrom nlpeer.tasks.pragmatic_labeling.data import PragmaticLabelingDataModule\n\nOUT_PATH = None\nBENCHMARK_PATH = None", "OUT_PATH = None\nBENCHMARK_PATH = None\nDEVICE = \"gpu\" if torch.cuda.is_available() else \"cpu\"\n\n\ndef get_default_config():\n    global BENCHMARK_PATH, DEVICE\n\n    assert BENCHMARK_PATH is not None and os.path.exists(BENCHMARK_PATH), \\\n        f\"Provided benchmark path is None or does not exist: {BENCHMARK_PATH}\"\n\n    return {\n        \"data_loader\": {\n            \"num_workers\": 8,\n            \"shuffle\": True\n        },\n        \"dataset\": {\n            \"benchmark_path\": BENCHMARK_PATH\n        },\n        \"machine\": {\n            \"device\": DEVICE\n        }\n    }", "\n\ndef merge_configs(config, default_config):\n    to_expand = [(config, default_config)]\n    while len(to_expand) > 0:\n        c, oc = to_expand.pop(0)\n\n        for k, v in oc.items():\n            if k not in c:\n                c[k] = v\n            elif type(c[k]) == dict:\n                to_expand += [(c[k], v)]", "            # else ignore oc config, use the conf you already have\n\n\ndef setup(config, debug=False):\n    # get module and transforms\n    if config[\"model\"][\"type\"] in [\"roberta\", \"biobert\", \"scibert\"]:\n        from nlpeer.tasks.pragmatic_labeling.models.TransformerBased import from_config\n        module = from_config(config)\n    elif config[\"model\"][\"type\"].startswith(\"baseline\"):\n        # from tasks.stance_detection.models.baseline import from_config\n        # module = from_config(config)\n        raise NotImplementedError()\n    else:\n        raise ValueError(f\"The provided model type {config['model']['type']} is not supported\")\n\n    input_transform, target_transform = module.get_prepare_input()\n    tokenizer = module.get_tokenizer()\n\n    if debug:\n        config[\"data_loader\"][\"num_workers\"] = 0\n\n    # load data module\n    data_module = PragmaticLabelingDataModule(benchmark_path=config[\"dataset\"][\"benchmark_path\"],\n                                            dataset_type=DATASETS[config[\"dataset\"][\"type\"]],\n                                            in_transform=input_transform,\n                                            target_transform=target_transform,\n                                            tokenizer=tokenizer,\n                                            data_loader_config=config[\"data_loader\"],\n                                            paper_version=config[\"dataset\"][\"paper_version\"])\n\n    data_module.setup(\"fit\")\n\n    return module, data_module", "\n\ndef train(model, data_module, params, logger=None, debug=False):\n    global OUT_PATH\n\n    print(f\"RUN = {wandb.run.name}\")\n\n    chkp_dir = os.path.join(OUT_PATH, f\"checkpoints/{params['dataset']['type']}/{params['model']['type']}\")\n    checkpoint_callback = ModelCheckpoint(monitor=\"val_loss\",\n                                          mode=\"max\",\n                                          dirpath=chkp_dir,\n                                          filename=\"{epoch}-{val_loss}-\" + str(uuid.uuid4()),\n                                          save_top_k=1,\n                                          # every_n_train_steps=10\n                                          )\n    early_stop_callback = EarlyStopping(monitor=\"val_loss\",\n                                        mode=\"max\",\n                                        patience=8,\n                                        min_delta=0.001)\n\n    trainer = Trainer(logger=logger,\n                      log_every_n_steps=1,\n                      limit_train_batches=0.1 if debug else 1.0,\n                      # devices=1,\n                      max_epochs=params[\"train\"][\"epochs\"],\n                      accelerator=params[\"machine\"][\"device\"],\n                      callbacks=[checkpoint_callback, early_stop_callback])\n\n    # fit the model\n    trainer.fit(model, data_module)\n\n    # output best model path\n    wandb.log({\"best_model\": checkpoint_callback.best_model_path})\n    print(f\"best_model = {checkpoint_callback.best_model_path}\")", "\n\ndef run(config, debug=False, project=None):\n    global OUT_PATH\n\n    dconfig = get_default_config()\n    merge_configs(config, dconfig)\n\n    # set seed and log\n    seed = int(time.time()) % 100000\n    config[\"random_seed\"] = seed\n    seed_everything(seed)\n\n    # actual training\n    model, data = setup(config, debug)\n    train(model, data, config, WandbLogger(dir=os.path.join(OUT_PATH, \"logs\"), project=project), debug)", "\n\ndef main(args):\n    global BENCHMARK_PATH, OUT_PATH\n    BENCHMARK_PATH = args.benchmark_path\n    OUT_PATH = args.store_results\n\n    assert os.path.exists(BENCHMARK_PATH) and os.path.exists(OUT_PATH), \\\n        f\"Benchmark or out path do not exist. Check {BENCHMARK_PATH} and {OUT_PATH} again.\"\n\n    # use default config (basically for debugging)\n    dconf = {\n        \"dataset\": {\n            \"type\": args.dataset,\n            \"paper_version\": 1\n        },\n        \"model\": {\n            \"type\": args.model\n        },\n        \"train\": {\n            \"epochs\": 20,\n            \"train_loss\": \"nll\",\n            \"dev_loss\": \"acc\",\n            \"optimizer\": \"adam\",\n            \"learning_rate\": 2e-5 if args.lr is None else args.lr,\n            \"epsilon\": 1e-8\n        },\n        \"data_loader\": {\n            \"batch_size\": 16 if args.batch_size is None else args.batch_size\n        }\n    }\n    runs = args.repeat if args.repeat else 1\n\n    for i in range(runs):\n        run(dconf, debug=args.debug, project=args.project if args.project is not None else \"RSP_train\")", "\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--benchmark_path\", required=True, type=str, help=\"Path to the benchmark dir\")\n    parser.add_argument(\"--store_results\", required=True, type=str, help=\"Path for logs + results\")\n    parser.add_argument(\"--dataset\", required=False, choices=[d.name for d in DATASETS],\n                        help=\"Dataset name if no sweep provided\")\n    parser.add_argument(\"--model\", required=False, type=str, help=\"model name if no sweep provided\")\n    parser.add_argument(\"--lr\", required=False, type=float, help=\"learning rate (opt)\")\n    parser.add_argument(\"--batch_size\", required=False, type=int, help=\"batch size (opt)\")\n    parser.add_argument(\"--repeat\", required=False, type=int, default=1, help=\"Number of repetitions\")\n    parser.add_argument(\"--debug\", required=False, type=bool, default=False, help=\"Number of repetitions\")\n\n    parser.add_argument(\"--project\", required=False, type=str, help=\"Project name in WANDB\")\n\n    args = parser.parse_args()\n\n    assert args.project is not None and args.repeat is not None, \"Project name required for running a wandb sweep\"\n\n    assert args.dataset is not None and args.model is not None, \\\n        \"Dataset type required if not loading from sweep config\"\n\n    main(args)", ""]}
{"filename": "nlpeer/tasks/pragmatic_labeling/evaluate.py", "chunked_list": ["import argparse\nfrom collections import Counter\n\nimport simplejson\nimport json\nimport os\nfrom copy import copy\nfrom typing import Callable\nimport plotly.graph_objects as go\n", "import plotly.graph_objects as go\n\nfrom os.path import join as pjoin\n\nimport numpy as np\nimport scipy.stats\nimport sklearn\nimport torch\nimport wandb\nfrom pytorch_lightning import Trainer", "import wandb\nfrom pytorch_lightning import Trainer\nfrom pytorch_lightning.loggers import WandbLogger\n\nimport tasks\nfrom nlpeer import DATASETS\nfrom nlpeer.tasks import get_class_map_pragmatics\nfrom nlpeer.data.utils import list_files\nfrom nlpeer.tasks.pragmatic_labeling.data import PragmaticLabelingDataModule\n", "from nlpeer.tasks.pragmatic_labeling.data import PragmaticLabelingDataModule\n\nOUT_PATH = None\nBENCHMARK_PATH = None\nDEVICE = \"gpu\" if torch.cuda.is_available() else \"cpu\"\n\n\ndef get_default_config():\n    global BENCHMARK_PATH, DEVICE\n\n    assert BENCHMARK_PATH is not None and os.path.exists(BENCHMARK_PATH), \\\n        f\"Provided benchmark path is None or does not exist: {BENCHMARK_PATH}\"\n\n    return {\n        \"data_loader\": {\n            \"num_workers\": 0,\n            \"shuffle\": False\n        },\n        \"dataset\": {\n            \"benchmark_path\": BENCHMARK_PATH,\n            \"splits_from_file\": True\n        },\n        \"machine\": {\n            \"device\": DEVICE\n        }\n    }", "\n\n# 1. F1-score + accuracy + confusion matrix\ndef error(true_scores, predicted_scores, log=False):\n    f1_micro = tasks.get_loss_function(\"F1-micro\")(predicted_scores, true_scores)\n    f1_macro = tasks.get_loss_function(\"F1-macro\")(predicted_scores, true_scores)\n    accuracy = sklearn.metrics.accuracy_score(predicted_scores, true_scores)\n    confusion_matrix = sklearn.metrics.confusion_matrix(true_scores, predicted_scores, labels=list(get_class_map_pragmatics().values()))\n\n    majority_score = Counter(true_scores).most_common(1)[0][0]\n    majority_baseline = [majority_score for s in true_scores]\n\n    f1_micro_baseline = sklearn.metrics.f1_score(true_scores, majority_baseline, average=\"micro\")\n    f1_macro_baseline = sklearn.metrics.f1_score(true_scores, majority_baseline, average=\"macro\")\n    accuracy_baseline = sklearn.metrics.accuracy_score(true_scores, majority_baseline)\n\n    if log:\n        wandb.log({\"f1_micro\": f1_micro})\n        wandb.log({\"f1_macro\": f1_macro})\n        wandb.log({\"accuracy\": accuracy})\n        wandb.log({\n            \"confusion_matrix\":\n                       wandb.Table(data=confusion_matrix, columns=list(get_class_map_pragmatics().keys()))\n            })\n        wandb.log({\"labels\": get_class_map_pragmatics()})\n        wandb.log({\"baseline\": {\"f1_micro\": f1_micro_baseline, \"f1_macro\": f1_macro_baseline, \"accuracy\": accuracy_baseline}})\n\n    return {\n        \"accuracy\": float(accuracy),\n        \"f1_micro\": float(f1_micro),\n        \"f1_macro\": float(f1_macro),\n        \"confusion_matrix\": str(confusion_matrix),\n        \"labels\": get_class_map_pragmatics(),\n        \"baseline_f1_micro\": float(f1_micro_baseline),\n        \"baseline_f1_macro\": float(f1_macro_baseline),\n        \"baseline_accuracy\": float(accuracy_baseline)\n    }", "\n\ndef setup(config):\n    assert \"load_path\" in config[\"model\"], \"Provide a 'load_path' attribute in the config.model to load a checkpoint\"\n\n    if config[\"model\"][\"type\"] in [\"roberta\", \"biobert\", \"scibert\"]:\n        from nlpeer.tasks.pragmatic_labeling.models.TransformerBased import from_config\n        module = from_config(config)\n    else:\n        raise ValueError(\"The provided model type is not supported\")\n\n    input_transform, target_transform = module.get_prepare_input()\n    tokenizer = module.get_tokenizer()\n\n    # prepare data (loading splits from disk)\n    data_module_main = PragmaticLabelingDataModule(benchmark_path=config[\"dataset\"][\"benchmark_path\"],\n                                                 dataset_type=DATASETS[config[\"dataset\"][\"type\"]],\n                                                 in_transform=input_transform,\n                                                 target_transform=target_transform,\n                                                 tokenizer=tokenizer,\n                                                 data_loader_config=config[\"data_loader\"],\n                                                 paper_version=config[\"dataset\"][\"paper_version\"])\n\n    return module, data_module_main, (input_transform, target_transform, tokenizer)", "\n\ndef resetup(config, transforms):\n    input_transform, target_transform, tokenizer = transforms\n\n    other = DATASETS.F1000 if config[\"dataset\"][\"type\"] == DATASETS.ARR22.name else DATASETS.ARR22\n    data_module_secondary = PragmaticLabelingDataModule(benchmark_path=config[\"dataset\"][\"benchmark_path\"],\n                                                      dataset_type=other,\n                                                      in_transform=input_transform,\n                                                      target_transform=target_transform,\n                                                      tokenizer=tokenizer,\n                                                      data_loader_config=config[\"data_loader\"],\n                                                      paper_version=config[\"dataset\"][\"paper_version\"])\n\n    return data_module_secondary", "\n\ndef get_predictions(model, data_module, params, logger, debug=False):\n    trainer = Trainer(logger=logger,\n                      log_every_n_steps=1,\n                      devices=1,\n                      limit_predict_batches= 0.1 if debug else 1.0,\n                      accelerator=params[\"machine\"][\"device\"])\n\n    # accuracy as a loss/performance metric is stored with device information -- discard for predictions.\n    model.dev_loss = None\n    model.train_loss = None\n    model.to(\"cuda\" if params[\"machine\"][\"device\"] == \"gpu\" else params[\"machine\"][\"device\"])\n\n    return trainer.predict(model, data_module)", "\n\ndef run(config, debug=False):\n    global OUT_PATH\n\n    cname = f\"{config['dataset']['type']}_{config['model']['type']}\"\n\n    with wandb.init(dir=os.path.join(OUT_PATH, \"logs\"), config=config, project=config[\"project\"], name=cname):\n        dconfig = get_default_config()\n        tasks.merge_configs(config, dconfig)\n\n        wandb_logger = WandbLogger(dir=os.path.join(OUT_PATH, \"logs\"), config=config)\n\n        print(f\"Starting evaluation with config {config}\")\n\n        # get model checkpoints and config paths\n        model_load_path = pjoin(config[\"model\"][\"load_path\"], config[\"model\"][\"type\"])\n        mconf_path = pjoin(model_load_path, \"config.json\") if os.path.exists(\n            pjoin(model_load_path, \"config.json\")) else None\n        checkpoints = [c for c in list_files(model_load_path) if os.path.basename(c) != \"config.json\"]\n\n        assert len(checkpoints) > 0, f\"Model load path directory lacks checkpoints: {checkpoints}\"\n\n        # load the model config\n        mconf = copy(config)\n\n        print(\"Evaluation...\")\n\n        accu_res = evaluation(checkpoints, config, mconf, wandb_logger, debug)\n        mean_res = compute_mean_stats(accu_res)\n\n        wandb.log({\"mean_res\": mean_res})\n\n        mean_res[\"accu\"] = accu_res\n\n        def np_encoder(object):\n            if isinstance(object, np.generic):\n                return object.item()\n            else:\n                return None\n\n        print(\"Storing results\")\n\n        with open(pjoin(OUT_PATH, f\"stance_eval_{config['dataset']['type']}_{config['model']['type']}.json\"),\n                  \"w+\") as f:\n            simplejson.dump(mean_res, f, indent=4, ignore_nan=True, default=np_encoder)", "\n\ndef compute_mean_stats(accu_res):\n    mean_res = {}\n    for s in accu_res:\n        for t in s:\n            if type(s[t]) != dict:\n                continue\n\n            if t not in mean_res:\n                mean_res[t] = {}\n\n            for k, v in s[t].items():\n                try:\n                    vf = float(v)\n                except (ValueError, TypeError):\n                    continue\n\n                if k not in mean_res[t]:\n                    mean_res[t][k] = []\n\n                mean_res[t][k] += [vf]\n    for t in mean_res:\n        for k, v in mean_res[t].items():\n            mean_res[t][k] = {\"mean\": float(np.mean(v)), \"median\": float(np.median(v)), \"std\": float(np.std(v))}\n\n    return mean_res", "\n\ndef evaluation(checkpoints, config, model_config, wandb_logger, debug=False):\n    accu_res = []\n    for cpath in checkpoints:\n        # define setup config\n        model_config[\"model\"][\"load_path\"] = cpath\n        model_config[\"dataset\"] = config[\"dataset\"]\n        model_config[\"data_loader\"] = config[\"data_loader\"]\n        model_config[\"machine\"] = config[\"machine\"]\n\n        # prep evaluation\n        model, data_module_main, transforms = setup(model_config)\n\n        predictions = get_predictions(model, data_module_main, config, wandb_logger, debug)\n        labels = torch.cat([x[\"labels\"] for x in predictions]).detach().cpu().tolist()\n        predictions = torch.cat([x[\"predictions\"] for x in predictions]).detach().cpu().tolist()\n\n        print(predictions)\n        print(labels)\n\n        # evaluate\n        eval_conf = config[\"evaluation\"]\n\n        res = {}\n        if \"error\" in eval_conf and eval_conf[\"error\"]:\n            res[\"error\"] = error(labels, predictions, True)\n\n        if \"domain_ransfer\" in eval_conf and eval_conf[\"domain_ransfer\"]:\n            data_module_sec = resetup(config, transforms)\n\n            predictions2 = get_predictions(model, data_module_sec, config, wandb_logger, debug)\n            labels2 = torch.cat([x[\"labels\"] for x in predictions2]).detach().cpu().tolist()\n            predictions2 = torch.cat([x[\"predictions\"] for x in predictions2]).detach().cpu().tolist()\n\n            print(predictions2)\n            print(labels2)\n\n            res[f\"transfer_from_{config['dataset']['type']}_to_{data_module_sec.dataset_type.name}\"] = error(labels2, predictions2, True)\n\n        accu_res += [res]\n    return accu_res", "\n\ndef main(args):\n    global BENCHMARK_PATH, OUT_PATH\n    BENCHMARK_PATH = args.benchmark_dir\n    OUT_PATH = args.store_results\n\n    assert os.path.exists(BENCHMARK_PATH) and os.path.exists(OUT_PATH), \\\n        f\"Benchmark or out path do not exist. Check {BENCHMARK_PATH} and {OUT_PATH} again.\"\n\n    config = {\n        \"name\": f\"Evaluation\",\n        \"project\": args.project,\n        \"random_seed\": {\n            \"value\": 29491\n        },\n        \"model\": {\n            \"type\": args.model_type,\n            \"load_path\": pjoin(args.chkp_dir, f\"{DATASETS[args.dataset].name}\")\n        },\n        \"data_loader\": {\n            \"batch_size\": 15\n        },\n        \"dataset\": {\n            \"type\": DATASETS[args.dataset].name,\n            \"paper_version\": args.paper_version\n        },\n        \"evaluation\": {\n            \"error\": True,\n            \"domain_ransfer\": True\n        }\n    }\n\n    run(config, debug=args.debug)", "\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--benchmark_dir\", required=True, type=str, help=\"Path to the benchmark dir\")\n    parser.add_argument(\"--project\", required=True, type=str, help=\"Project name in WANDB\")\n    parser.add_argument(\"--store_results\", required=True, type=str, help=\"Path for logs + results\")\n    parser.add_argument(\"--debug\", required=False, default=False, type=bool, help=\"Set true for debugging\")\n    parser.add_argument(\"--chkp_dir\", required=True, type=str, help=\"Path to load the checkpoints from\")\n    parser.add_argument(\"--dataset\", required=True, choices=[d.name for d in DATASETS], help=\"Name of the dataset\")\n    parser.add_argument(\"--model_type\", required=True, type=str, help=\"Model type e.g. biobert\")\n    parser.add_argument(\"--paper_version\", required=False, default=1, type=int, help=\"Version of the paper\")\n\n    args = parser.parse_args()\n    main(args)", ""]}
{"filename": "nlpeer/tasks/pragmatic_labeling/__init__.py", "chunked_list": [""]}
{"filename": "nlpeer/tasks/pragmatic_labeling/data.py", "chunked_list": ["import argparse\nimport json\nimport os\nfrom copy import copy\nfrom os.path import join as pjoin\n\nfrom datasets import DatasetDict, Dataset\nfrom pytorch_lightning import LightningDataModule\nfrom torch.utils.data import DataLoader\n", "from torch.utils.data import DataLoader\n\nfrom nlpeer import DATASETS, PAPERFORMATS, PaperReviewDataset\nfrom nlpeer.tasks import PragmaticLabelingDataset, random_split_pragmatic_labeling_dataset\n\n\nclass PragmaticLabelingDataModule(LightningDataModule):\n    def __init__(self, benchmark_path: str,\n                 dataset_type: DATASETS,\n                 in_transform,\n                 target_transform,\n                 tokenizer,\n                 data_loader_config,\n                 paper_version=1,\n                 paper_format=PAPERFORMATS.ITG):\n        super().__init__()\n\n        self.base_path = benchmark_path\n        self.dataset_type = dataset_type\n        self.paper_version = paper_version\n        self.paper_format = paper_format\n\n        self.in_transform = in_transform\n        self.target_transform = target_transform\n        self.tokenizer = tokenizer\n\n        self.splits = self._load_splits_idx()\n        self.full_data = None\n        self.train_data = None\n        self.dev_data = None\n        self.test_data = None\n\n        self.data_loader_config = data_loader_config\n\n    def _load_splits_idx(self):\n        fp = pjoin(self.base_path, self.dataset_type.value, \"splits\", \"prag_split.json\")\n\n        assert os.path.exists(fp) and os.path.isfile(\n            fp), f\"Cannot setup Pragmatic Labeling splits, as {fp} does not exist.\"\n\n        with open(fp, \"r\") as file:\n            split_data = json.load(file)\n\n        return split_data[\"splits\"]\n\n    def setup(self, stage: str | None) -> None:\n        '''called one each GPU separately - stage defines if we are at fit or test step'''\n        full_dataset = PaperReviewDataset(self.base_path,\n                                          self.dataset_type,\n                                          self.paper_version,\n                                          self.paper_format,\n                                          hold_in_memory=True)\n\n        sd_dataset = PragmaticLabelingDataset(full_dataset, self.in_transform, self.target_transform)\n\n        split_ixs = []\n        for s in self.splits:\n            split_ixs += [[sd_dataset.ids().index(rid) for i, rid in s]]\n\n        self.dataset = DatasetDict({\n            \"train\": Dataset.from_dict(sd_dataset.to_dict(split_ixs[0])),\n            \"dev\": Dataset.from_dict(sd_dataset.to_dict(split_ixs[1])),\n            \"test\": Dataset.from_dict(sd_dataset.to_dict(split_ixs[2])),\n        })\n\n        for split in self.dataset.keys():\n            print(f\"Setting up {split}\")\n            self.dataset[split] = self.dataset[split].map(\n                self.convert_to_features,\n                batched=True,\n                remove_columns=[\"txt\", \"label\"]\n            )\n            self.dataset[split].set_format(type=\"torch\")\n\n        print(\"Dataset initialized\")\n\n    def train_dataloader(self):\n        '''returns training dataloader'''\n        dl_config = copy(self.data_loader_config)\n        dl_config[\"shuffle\"] = True\n\n        return DataLoader(self.dataset[\"train\"], **dl_config)\n\n    def val_dataloader(self):\n        '''returns validation dataloader'''\n        dl_config = copy(self.data_loader_config)\n        dl_config[\"shuffle\"] = False\n\n        return DataLoader(self.dataset[\"dev\"], **dl_config)\n\n    def test_dataloader(self):\n        '''returns test dataloader'''\n        dl_config = copy(self.data_loader_config)\n        dl_config[\"shuffle\"] = False\n\n        return DataLoader(self.dataset[\"test\"], **dl_config)\n\n    def predict_dataloader(self):\n        '''returns test dataloader'''\n        dl_config = copy(self.data_loader_config)\n        dl_config[\"shuffle\"] = False\n\n        return DataLoader(self.dataset[\"test\"], **dl_config)\n\n    def convert_to_features(self, sample_batch, indices=None):\n        labels = sample_batch[\"label\"]\n        input_raw = sample_batch[\"txt\"]\n\n        features = self.tokenizer(input_raw)\n        features[\"labels\"] = labels\n\n        return features", "\n\ndef store_splits(dataset, splits, random_gen, out_path):\n    jsplits = {\n        \"dataset_type\": dataset.data.dataset_type.name,\n        \"dataset\": dataset.__class__.__name__,\n        \"splits\": [\n            [[int(s), dataset.ids()[s]] for s in split] for split in splits\n        ],\n        \"random\": str(random_gen)\n    }\n\n    with open(out_path, \"w+\") as f:\n        json.dump(jsplits, f)", "\n\ndef create_and_store_splits(full_data: PragmaticLabelingDataset,\n                            out_dir,\n                            splits: list[float],\n                            random_gen: int = None):\n    split_ix, split_ids = random_split_pragmatic_labeling_dataset(full_data, splits, random_gen)\n\n    out_path = os.path.join(out_dir, \"prag_split.json\")\n    store_splits(full_data, split_ix, random_gen, out_path)\n\n    return out_path", "\n\ndef prepare_dataset_splits(benchmark_path, paper_version, splits, random_gen, datasets=None):\n    if datasets is None:\n        datasets = [d for d in DATASETS]\n\n    out_files = []\n    for d in datasets:\n        full_dataset = PaperReviewDataset(benchmark_path,\n                                          d,\n                                          paper_version,\n                                          PAPERFORMATS.ITG)\n\n        sd_dataset = PragmaticLabelingDataset(full_dataset)\n\n        out_path = os.path.join(benchmark_path, d.value, \"splits\")\n        if not os.path.exists(out_path):\n            os.mkdir(out_path)\n\n        out_files += [create_and_store_splits(sd_dataset, out_path, splits, random_gen)]\n\n    return out_files", "\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--benchmark_dir\", required=True, help=\"Path to the benchmark directory\")\n    parser.add_argument(\"--paper_version\", required=True, help=\"Which paper version\", type=int)\n    parser.add_argument(\"--random_seed\", required=True, help=\"Random seed to generate random splits\", type=int)\n    parser.add_argument(\"--datasets\", nargs=\"*\", required=False, help=\"list of datasets, if applicable\", type=str)\n\n    args = parser.parse_args()\n\n    assert set(DATASETS[d] for d in args.datasets).issubset({DATASETS.ARR22, DATASETS.F1000}), \\\n        \"Only ARR22 and F1000 supported for stance classification and hence splitting\"\n\n    prepare_dataset_splits(args.benchmark_dir,\n                           args.paper_version,\n                           [0.7, 0.1, 0.2],\n                           args.random_seed,\n                           [DATASETS[d] for d in args.datasets])", ""]}
{"filename": "nlpeer/tasks/pragmatic_labeling/models/__init__.py", "chunked_list": [""]}
{"filename": "nlpeer/tasks/pragmatic_labeling/models/TransformerBased.py", "chunked_list": ["from typing import Callable, Optional\n\nimport pytorch_lightning as pl\nimport torch\nfrom pytorch_lightning.utilities.types import STEP_OUTPUT\nfrom transformers import AutoModel, AutoTokenizer, AutoModelForSequenceClassification, AutoConfig, \\\n    get_linear_schedule_with_warmup\n\n# model\nfrom nlpeer.tasks import get_optimizer, get_loss_function, review_sentence_no_context, get_class_map_pragmatics", "# model\nfrom nlpeer.tasks import get_optimizer, get_loss_function, review_sentence_no_context, get_class_map_pragmatics\n\n\nclass LitTransformerPragmaticLabelingModule(pl.LightningModule):\n    def __init__(self,\n                 model_type,\n                 train_loss,\n                 dev_loss,\n                 optimizer,\n                 num_labels,\n                 weight_decay: float = 0.1,\n                 warmup_ratio: int = 0.06,\n                 **kwargs):\n        super().__init__()\n\n        # save hyperparameters\n        self.save_hyperparameters()\n\n        # optimizer args\n        self.optimizer = optimizer\n\n        # define model\n        self.config = AutoConfig.from_pretrained(model_type, num_labels=num_labels)\n        self.model = AutoModelForSequenceClassification.from_pretrained(model_type, config=self.config)\n        self.model_type = model_type\n\n        # use provided losses\n        self.train_loss = train_loss\n        self.dev_loss = dev_loss\n\n    def forward(self, **inputs):\n        return self.model(**inputs)\n\n    def training_step(self, batch, batch_idx):\n        out = self(**batch)\n        loss, logits = out[0], out[1]\n\n        targets = batch[\"labels\"]\n\n        tloss = self.train_loss(logits, targets)\n        self.log(\"train_loss\", tloss)\n\n        return loss\n\n    def validation_step(self, batch, batch_idx) -> Optional[STEP_OUTPUT]:\n        out = self(**batch)\n        loss, logits = out[0], out[1]\n\n        targets = batch[\"labels\"].to(torch.int32)\n        predictions = torch.argmax(logits, axis=1).to(torch.int32)\n\n        vloss = self.dev_loss(predictions, targets)\n\n        self.log(\"val_loss\", vloss)\n\n        return vloss\n\n    def configure_optimizers(self):\n        no_decay = [\"bias\", \"LayerNorm.weight\"]\n        optimizer_grouped_parameters = [\n            {\n                \"params\": [p for n, p in self.model.named_parameters() if not any(nd in n for nd in no_decay)],\n                \"weight_decay\": self.hparams.weight_decay,\n            },\n            {\n                \"params\": [p for n, p in self.model.named_parameters() if any(nd in n for nd in no_decay)],\n                \"weight_decay\": 0.0,\n            },\n        ]\n        optimizer = self.optimizer(optimizer_grouped_parameters, lr=self.hparams.lr, eps=self.hparams.eps)\n\n        scheduler = get_linear_schedule_with_warmup(\n            optimizer,\n            num_warmup_steps=self.hparams.warmup_ratio * self.trainer.estimated_stepping_batches,\n            num_training_steps=self.trainer.estimated_stepping_batches,\n        )\n        scheduler = {\"scheduler\": scheduler, \"interval\": \"step\", \"frequency\": 1}\n\n        return [optimizer], [scheduler]\n\n    def predict_step(self, batch, batch_idx: int, dataloader_idx: int = None):\n        out = self(**batch)\n        loss, logits = out[0], out[1]\n\n        targets = batch[\"labels\"].to(torch.int32)\n        predictions = torch.argmax(logits, axis=1).to(torch.int32)\n\n        return {\"loss\": loss, \"predictions\": predictions, \"logits\": logits, \"labels\": targets}\n\n    def on_predict_epoch_end(self, results):\n        preds = torch.cat([x['predictions'] for x in results[0]]).detach().cpu().numpy()\n        labels = torch.cat([x['labels'] for x in results[0]]).detach().cpu().numpy()\n        logits = torch.cat([x['logits'] for x in results[0]]).detach().cpu().numpy()\n\n        return {\"predictions\": preds, \"labels\": labels, \"logits\": logits}\n\n    def get_tokenizer(self) -> Callable:\n        tokenizer = AutoTokenizer.from_pretrained(self.model_type, use_fast=True)\n\n        def tokenize(dataset):\n            return tokenizer(dataset, padding=\"max_length\", truncation=True, max_length=512)\n\n        return tokenize\n\n    def get_prepare_input(self) -> tuple[Callable, Callable or None]:\n        input_transform = review_sentence_no_context()\n        target_transform = lambda x: get_class_map_pragmatics()[x]\n\n        return input_transform, target_transform", "\n\ndef from_config(config):\n    # load from config\n    if config and \"model\" in config and \"train\" in config and \"load_path\" not in config[\"model\"]:\n        model_params = config[\"model\"]\n\n        if model_params[\"type\"] in [\"biobert\", \"roberta\", \"scibert\"]:  # aliases\n            if model_params[\"type\"] == \"roberta\":\n                mtype = \"roberta-base\"\n            elif model_params[\"type\"] == \"biobert\":\n                mtype = \"dmis-lab/biobert-v1.1\"\n            elif model_params[\"type\"] == \"scibert\":\n                mtype = \"allenai/scibert_scivocab_uncased\"\n        else:\n            mtype = model_params[\"type\"]\n\n        return LitTransformerPragmaticLabelingModule(model_type=mtype,\n                                                     train_loss=get_loss_function(config[\"train\"][\"train_loss\"]),\n                                                     dev_loss=get_loss_function(config[\"train\"][\"dev_loss\"], **config[\"train\"][\n                                              \"dev_loss_kwargs\"] if \"dev_loss_kwargs\" in config[\"train\"] else {}),\n                                                     optimizer=get_optimizer(config[\"train\"][\"optimizer\"]),\n                                                     lr=config[\"train\"][\"learning_rate\"],\n                                                     eps=config[\"train\"][\"epsilon\"],\n                                                     num_labels=len(get_class_map_pragmatics()))\n    # from disk\n    elif config and \"model\" in config and \"load_path\" in config[\"model\"]:\n        return LitTransformerPragmaticLabelingModule.load_from_checkpoint(config[\"model\"][\"load_path\"])\n    else:\n        raise ValueError(\"Malformed config. Requires training regime and/or a model path to load from\")"]}
