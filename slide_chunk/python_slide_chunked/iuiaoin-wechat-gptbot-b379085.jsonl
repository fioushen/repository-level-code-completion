{"filename": "app.py", "chunked_list": ["from channel.wechat import WeChatChannel\nfrom config import load_config\nfrom utils.log import logger\nfrom utils.print import color_print\nfrom plugins.manager import PluginManager\n\n\nif __name__ == \"__main__\":\n    try:\n        # load config\n        load_config()\n\n        # print banner\n        color_print(\"WeChat GPTBot\")\n\n        # load plugins\n        PluginManager().load_plugins()\n\n        # start wechat channel\n        WeChatChannel().startup()\n    except Exception as e:\n        logger.error(\"App startup failed!\")\n        logger.exception(e)", ""]}
{"filename": "config.py", "chunked_list": ["import json\nimport os\nfrom utils.log import logger\n\nconfig = {}\n\n\ndef load_config():\n    global config\n    config_path = \"config.json\"\n    if not os.path.exists(config_path):\n        raise Exception(\"Config file is not exist, please create config.json according to config.template.json\")\n\n    config_str = read_file(config_path)\n    # deserialize json string to dict\n    config = json.loads(config_str)\n    logger.info(f\"Load config: {config}\")", "\n\ndef read_file(path):\n    with open(path, mode=\"r\", encoding=\"utf-8\") as f:\n        return f.read()\n\n\ndef conf():\n    return config\n", ""]}
{"filename": "plugins/built_in.py", "chunked_list": ["from config import conf\nfrom common.singleton import singleton\nfrom common.session import Session\nfrom common.reply import Reply, ReplyType\nfrom plugins.event import Event\nfrom utils.query_key import QueryKey\n\n\n@singleton\nclass Cmd:\n    def __init__(self, plugins: dict):\n        self.config = conf()\n        self.plugins = plugins\n\n    def will_generate_reply(self, event: Event):\n        query = event.context.query\n        session_id = event.context.session_id\n        if query == self.config.get(\"clear_current_session_command\", \"#clear session\"):\n            Session.clear_session(session_id)\n            event.reply = Reply(ReplyType.TEXT, \"The session has been cleared\")\n            event.bypass()\n        elif query == self.config.get(\n            \"clear_all_sessions_command\", \"#clear all sessions\"\n        ):\n            Session.clear_all_session()\n            event.reply = Reply(ReplyType.TEXT, \"All sessions have been cleared\")\n            event.bypass()\n        elif query == self.config.get(\"query_key_command\", \"#query key\"):\n            event.reply = Reply(ReplyType.TEXT, QueryKey.get_key())\n            event.bypass()\n        elif query.startswith(\"#help \"):\n            plugin_name = query.split(\" \")[1]\n            reply_text = f\"No plugin named {plugin_name}\"\n            for name in self.plugins:\n                if name == plugin_name:\n                    reply_text = self.plugins[name].help()\n                    break\n            event.reply = Reply(ReplyType.TEXT, reply_text)\n            event.bypass()", "@singleton\nclass Cmd:\n    def __init__(self, plugins: dict):\n        self.config = conf()\n        self.plugins = plugins\n\n    def will_generate_reply(self, event: Event):\n        query = event.context.query\n        session_id = event.context.session_id\n        if query == self.config.get(\"clear_current_session_command\", \"#clear session\"):\n            Session.clear_session(session_id)\n            event.reply = Reply(ReplyType.TEXT, \"The session has been cleared\")\n            event.bypass()\n        elif query == self.config.get(\n            \"clear_all_sessions_command\", \"#clear all sessions\"\n        ):\n            Session.clear_all_session()\n            event.reply = Reply(ReplyType.TEXT, \"All sessions have been cleared\")\n            event.bypass()\n        elif query == self.config.get(\"query_key_command\", \"#query key\"):\n            event.reply = Reply(ReplyType.TEXT, QueryKey.get_key())\n            event.bypass()\n        elif query.startswith(\"#help \"):\n            plugin_name = query.split(\" \")[1]\n            reply_text = f\"No plugin named {plugin_name}\"\n            for name in self.plugins:\n                if name == plugin_name:\n                    reply_text = self.plugins[name].help()\n                    break\n            event.reply = Reply(ReplyType.TEXT, reply_text)\n            event.bypass()", ""]}
{"filename": "plugins/manager.py", "chunked_list": ["import json\nimport re\nimport os\nimport importlib\nfrom common.singleton import singleton\nfrom config import conf\nfrom utils.log import logger\nfrom typing import Set\nfrom dulwich import porcelain\nfrom utils.package import install_file", "from dulwich import porcelain\nfrom utils.package import install_file\nfrom plugins.plugin import Plugin\nfrom common.emitter import Emitter\nfrom plugins.event import Event, EventType\nfrom plugins.built_in import Cmd\n\n\n@singleton\nclass PluginManager(Emitter):\n    def __init__(self):\n        super().__init__()\n        self._plugins = {}\n        self._configs = {}\n        self.built_in(self._plugins)\n\n    def register(self, cls: Plugin):\n        name = cls.name\n        config = self._configs.get(name)\n        self._plugins[name] = cls(config)\n        return cls\n\n    def load_plugins(self):\n        new_plugins = self.check_plugins()\n        failed_plugins = self.install_plugins(new_plugins)\n        all_plugins = conf().get(\"plugins\") or []\n        plugins = [\n            plugin for plugin in all_plugins if plugin[\"name\"] not in failed_plugins\n        ]\n        self.import_plugins(plugins)\n        self.activate_plugins(plugins)\n\n    def check_plugins(self) -> Set[str]:\n        logger.info(\"Checking plugins...\")\n        plugins = conf().get(\"plugins\") or []\n        existed_plugins = self.get_existed()\n        new_plugins = set()\n        for plugin in plugins:\n            if plugin[\"name\"] not in existed_plugins:\n                new_plugins.add(plugin[\"name\"])\n        return new_plugins\n\n    def install_plugins(self, plugins: Set[str]) -> Set[str]:\n        failed_plugins = set()\n        if len(plugins) == 0:\n            logger.info(\"All plugins are installed\")\n            return failed_plugins\n        else:\n            logger.info(f\"Installing plugins: {plugins}\")\n            source = dict()\n            try:\n                with open(\"./plugins/source.json\", \"r\", encoding=\"utf-8\") as f:\n                    source = json.load(f)\n            except Exception as e:\n                logger.error(f\"Invalid plugin source: {e}\")\n                return plugins\n            for plugin_name in plugins:\n                if plugin_name in source:\n                    repo = source[plugin_name][\"repo\"]\n                    match = re.match(\n                        r\"^(https?:\\/\\/|git@)([^\\/:]+)[\\/:]([^\\/:]+)\\/(.+).git$\", repo\n                    )\n                    if not match:\n                        failed_plugins.add(plugin_name)\n                        logger.error(f\"Invalid repo: {repo}\")\n                    else:\n                        try:\n                            dirname = os.path.join(\"./plugins\", plugin_name)\n                            porcelain.clone(repo, dirname, checkout=True)\n                            dependency_path = os.path.join(dirname, \"requirements.txt\")\n                            if os.path.exists(dependency_path):\n                                logger.info(\n                                    f\"Installing dependencies for {plugin_name}\"\n                                )\n                                install_file(dependency_path)\n                            logger.info(f\"Install plugin {plugin_name} successfully\")\n                        except Exception as e:\n                            failed_plugins.add(plugin_name)\n                            logger.error(f\"Fail to install plugin {plugin_name}: {e}\")\n                else:\n                    failed_plugins.add(plugin_name)\n                    logger.error(f\"Plugin {plugin_name} is not found in source.json\")\n            return failed_plugins\n\n    def get_existed(self) -> Set[str]:\n        plugins_dir = os.path.abspath(\"./plugins\")\n        existed_plugins = set()\n        for plugin_name in os.listdir(plugins_dir):\n            plugin_path = os.path.join(plugins_dir, plugin_name)\n            if os.path.isdir(plugin_path):\n                # detect __init__.py in the plugin directory\n                module_path = os.path.join(plugin_path, \"__init__.py\")\n                if os.path.isfile(module_path):\n                    existed_plugins.add(plugin_name)\n        return existed_plugins\n\n    def import_plugins(self, plugins: list) -> None:\n        for plugin in plugins:\n            try:\n                self._configs[plugin[\"name\"]] = plugin\n                importlib.import_module(f\"plugins.{plugin['name']}\")\n            except Exception as e:\n                logger.exception(f\"Failed to load plugin {plugin['name']}: {e}\")\n\n    def activate_plugins(self, plugins: list) -> None:\n        for plugin in plugins:\n            instance = self._plugins.get(plugin[\"name\"])\n            if instance is not None:\n                self.on(EventType.DID_RECEIVE_MESSAGE, instance.did_receive_message)\n                self.on(EventType.WILL_GENERATE_REPLY, instance.will_generate_reply)\n                self.on(EventType.WILL_DECORATE_REPLY, instance.will_decorate_reply)\n                self.on(EventType.WILL_SEND_REPLY, instance.will_send_reply)\n\n    def emit(self, event: Event) -> Event:\n        listeners = self.__events__.get(event.type)\n        if listeners is not None and len(listeners) > 0:\n            for fn in listeners:\n                if event.is_proceed:\n                    fn(event)\n                else:\n                    break\n        return event\n\n    def built_in(self, plugins: dict):\n        self.on(EventType.WILL_GENERATE_REPLY, Cmd(plugins).will_generate_reply)", "@singleton\nclass PluginManager(Emitter):\n    def __init__(self):\n        super().__init__()\n        self._plugins = {}\n        self._configs = {}\n        self.built_in(self._plugins)\n\n    def register(self, cls: Plugin):\n        name = cls.name\n        config = self._configs.get(name)\n        self._plugins[name] = cls(config)\n        return cls\n\n    def load_plugins(self):\n        new_plugins = self.check_plugins()\n        failed_plugins = self.install_plugins(new_plugins)\n        all_plugins = conf().get(\"plugins\") or []\n        plugins = [\n            plugin for plugin in all_plugins if plugin[\"name\"] not in failed_plugins\n        ]\n        self.import_plugins(plugins)\n        self.activate_plugins(plugins)\n\n    def check_plugins(self) -> Set[str]:\n        logger.info(\"Checking plugins...\")\n        plugins = conf().get(\"plugins\") or []\n        existed_plugins = self.get_existed()\n        new_plugins = set()\n        for plugin in plugins:\n            if plugin[\"name\"] not in existed_plugins:\n                new_plugins.add(plugin[\"name\"])\n        return new_plugins\n\n    def install_plugins(self, plugins: Set[str]) -> Set[str]:\n        failed_plugins = set()\n        if len(plugins) == 0:\n            logger.info(\"All plugins are installed\")\n            return failed_plugins\n        else:\n            logger.info(f\"Installing plugins: {plugins}\")\n            source = dict()\n            try:\n                with open(\"./plugins/source.json\", \"r\", encoding=\"utf-8\") as f:\n                    source = json.load(f)\n            except Exception as e:\n                logger.error(f\"Invalid plugin source: {e}\")\n                return plugins\n            for plugin_name in plugins:\n                if plugin_name in source:\n                    repo = source[plugin_name][\"repo\"]\n                    match = re.match(\n                        r\"^(https?:\\/\\/|git@)([^\\/:]+)[\\/:]([^\\/:]+)\\/(.+).git$\", repo\n                    )\n                    if not match:\n                        failed_plugins.add(plugin_name)\n                        logger.error(f\"Invalid repo: {repo}\")\n                    else:\n                        try:\n                            dirname = os.path.join(\"./plugins\", plugin_name)\n                            porcelain.clone(repo, dirname, checkout=True)\n                            dependency_path = os.path.join(dirname, \"requirements.txt\")\n                            if os.path.exists(dependency_path):\n                                logger.info(\n                                    f\"Installing dependencies for {plugin_name}\"\n                                )\n                                install_file(dependency_path)\n                            logger.info(f\"Install plugin {plugin_name} successfully\")\n                        except Exception as e:\n                            failed_plugins.add(plugin_name)\n                            logger.error(f\"Fail to install plugin {plugin_name}: {e}\")\n                else:\n                    failed_plugins.add(plugin_name)\n                    logger.error(f\"Plugin {plugin_name} is not found in source.json\")\n            return failed_plugins\n\n    def get_existed(self) -> Set[str]:\n        plugins_dir = os.path.abspath(\"./plugins\")\n        existed_plugins = set()\n        for plugin_name in os.listdir(plugins_dir):\n            plugin_path = os.path.join(plugins_dir, plugin_name)\n            if os.path.isdir(plugin_path):\n                # detect __init__.py in the plugin directory\n                module_path = os.path.join(plugin_path, \"__init__.py\")\n                if os.path.isfile(module_path):\n                    existed_plugins.add(plugin_name)\n        return existed_plugins\n\n    def import_plugins(self, plugins: list) -> None:\n        for plugin in plugins:\n            try:\n                self._configs[plugin[\"name\"]] = plugin\n                importlib.import_module(f\"plugins.{plugin['name']}\")\n            except Exception as e:\n                logger.exception(f\"Failed to load plugin {plugin['name']}: {e}\")\n\n    def activate_plugins(self, plugins: list) -> None:\n        for plugin in plugins:\n            instance = self._plugins.get(plugin[\"name\"])\n            if instance is not None:\n                self.on(EventType.DID_RECEIVE_MESSAGE, instance.did_receive_message)\n                self.on(EventType.WILL_GENERATE_REPLY, instance.will_generate_reply)\n                self.on(EventType.WILL_DECORATE_REPLY, instance.will_decorate_reply)\n                self.on(EventType.WILL_SEND_REPLY, instance.will_send_reply)\n\n    def emit(self, event: Event) -> Event:\n        listeners = self.__events__.get(event.type)\n        if listeners is not None and len(listeners) > 0:\n            for fn in listeners:\n                if event.is_proceed:\n                    fn(event)\n                else:\n                    break\n        return event\n\n    def built_in(self, plugins: dict):\n        self.on(EventType.WILL_GENERATE_REPLY, Cmd(plugins).will_generate_reply)", ""]}
{"filename": "plugins/plugin.py", "chunked_list": ["from abc import ABC, abstractmethod\nfrom plugins.event import Event\n\n\nclass Plugin(ABC):\n    name = None\n\n    def __init__(self, config: dict):\n        super().__init__()\n        if self.name is None:\n            raise NotImplementedError(\"Plugin name is not defined\")\n        self.config = config\n\n    @abstractmethod\n    def did_receive_message(self, event: Event):\n        pass\n\n    @abstractmethod\n    def will_generate_reply(self, event: Event):\n        pass\n\n    @abstractmethod\n    def will_decorate_reply(self, event: Event):\n        pass\n\n    @abstractmethod\n    def will_send_reply(self, event: Event):\n        pass\n\n    @abstractmethod\n    def help(self, **kwargs) -> str:\n        return \"No help docs\"", ""]}
{"filename": "plugins/__init__.py", "chunked_list": ["from .event import EventType, EventAction, Event\nfrom .manager import PluginManager\nfrom .plugin import Plugin\nfrom utils.log import logger\nfrom common.reply import Reply, ReplyType\n\n__all__ = [\n    \"EventType\",\n    \"EventAction\",\n    \"Event\",", "    \"EventAction\",\n    \"Event\",\n    \"PluginManager\",\n    \"Plugin\",\n    \"logger\",\n    \"Reply\",\n    \"ReplyType\",\n]\n\nregister = PluginManager().register", "\nregister = PluginManager().register\n"]}
{"filename": "plugins/event.py", "chunked_list": ["from enum import Enum\nfrom pydantic import BaseModel\nfrom common.context import Context\nfrom common.reply import Reply\nfrom channel.message import Message\nfrom channel.channel import Channel\n\n\nclass EventType(Enum):\n    DID_RECEIVE_MESSAGE = 1  # receive message\n    WILL_GENERATE_REPLY = 2  # generate reply\n    WILL_DECORATE_REPLY = 3  # decorate reply\n    WILL_SEND_REPLY = 4  # send reply\n\n    def __str__(self):\n        return self.name", "class EventType(Enum):\n    DID_RECEIVE_MESSAGE = 1  # receive message\n    WILL_GENERATE_REPLY = 2  # generate reply\n    WILL_DECORATE_REPLY = 3  # decorate reply\n    WILL_SEND_REPLY = 4  # send reply\n\n    def __str__(self):\n        return self.name\n\n\nclass EventAction(Enum):\n    PROCEED = 1  # proceed the plugin chain\n    STOP = 2  # stop the plugin chain\n    BYPASS = 3  # bypass the plugin chain and default logic", "\n\nclass EventAction(Enum):\n    PROCEED = 1  # proceed the plugin chain\n    STOP = 2  # stop the plugin chain\n    BYPASS = 3  # bypass the plugin chain and default logic\n\n\nclass Event(BaseModel):\n    class Config:\n        arbitrary_types_allowed = True\n\n    type: EventType = None\n    channel: Channel = None\n    message: Message = None\n    context: Context = None\n    reply: Reply = None\n    action: EventAction = EventAction.PROCEED\n\n    def __init__(self, type: EventType, data: dict):\n        super().__init__()\n        self.type = type\n        self.channel = data.get(\"channel\")\n        self.message = data.get(\"message\")\n        self.context = data.get(\"context\")\n        self.reply = data.get(\"reply\")\n\n    def proceed(self):\n        self.action = EventAction.PROCEED\n\n    def stop(self):\n        self.action = EventAction.STOP\n\n    def bypass(self):\n        self.action = EventAction.BYPASS\n\n    @property\n    def is_proceed(self) -> bool:\n        return self.action == EventAction.PROCEED\n\n    @property\n    def is_stop(self) -> bool:\n        return self.action == EventAction.STOP\n\n    @property\n    def is_bypass(self) -> bool:\n        return self.action == EventAction.BYPASS", "class Event(BaseModel):\n    class Config:\n        arbitrary_types_allowed = True\n\n    type: EventType = None\n    channel: Channel = None\n    message: Message = None\n    context: Context = None\n    reply: Reply = None\n    action: EventAction = EventAction.PROCEED\n\n    def __init__(self, type: EventType, data: dict):\n        super().__init__()\n        self.type = type\n        self.channel = data.get(\"channel\")\n        self.message = data.get(\"message\")\n        self.context = data.get(\"context\")\n        self.reply = data.get(\"reply\")\n\n    def proceed(self):\n        self.action = EventAction.PROCEED\n\n    def stop(self):\n        self.action = EventAction.STOP\n\n    def bypass(self):\n        self.action = EventAction.BYPASS\n\n    @property\n    def is_proceed(self) -> bool:\n        return self.action == EventAction.PROCEED\n\n    @property\n    def is_stop(self) -> bool:\n        return self.action == EventAction.STOP\n\n    @property\n    def is_bypass(self) -> bool:\n        return self.action == EventAction.BYPASS", ""]}
{"filename": "utils/query_key.py", "chunked_list": ["import requests\nfrom config import conf\n\n\nclass QueryKey(object):\n    def get_key():\n        api_base = conf().get(\"openai_api_base\")\n        if api_base:\n            api_base = api_base\n        else:\n            api_base = \"https://api.openai.com/v1\"\n        subscription_url = api_base + \"/dashboard/billing/credit_grants\"\n        headers = {\n            \"Authorization\": \"Bearer \" + conf().get(\"openai_sensitive_id\"),\n            \"Content-Type\": \"application/json\",\n        }\n        subscription_response = requests.get(subscription_url, headers=headers)\n        if subscription_response.status_code == 200:\n            data = subscription_response.json()\n            total_granted = data.get(\"total_granted\")\n            total_used = data.get(\"total_used\")\n            total_available = data.get(\"total_available\")\n        else:\n            return subscription_response.text\n\n        return (\n            f\"## Total:\\t{total_granted:.2f}$  \\n\"\n            f\"## Used:\\t{total_used:.2f}$  \\n\"\n            f\"## Available:\\t{total_available:.2f}$  \\n\"\n        )", ""]}
{"filename": "utils/log.py", "chunked_list": ["import logging\nimport sys\n\n\ndef _get_logger():\n    log = logging.getLogger(\"log\")\n    log.setLevel(logging.INFO)\n    console_handle = logging.StreamHandler(sys.stdout)\n    console_handle.setFormatter(\n        logging.Formatter(\n            \"[%(levelname)s][%(asctime)s][%(filename)s:%(lineno)d] - %(message)s\", datefmt=\"%Y-%m-%d %H:%M:%S\"\n        )\n    )\n    log.addHandler(console_handle)\n    return log", "\n\n# log handler\nlogger = _get_logger()\n"]}
{"filename": "utils/check.py", "chunked_list": ["def check_prefix(content, prefix_list):\n    for prefix in prefix_list:\n        if content.startswith(prefix):\n            return prefix\n    return None\n\n\ndef is_wx_account(id):\n    if id is None:\n        return False\n    return not id.lower().startswith(\"gh_\")", ""]}
{"filename": "utils/print.py", "chunked_list": ["from pyfiglet import Figlet\nfrom termcolor import cprint\n\n\ndef color_print(text, color=\"green\"):\n    content = Figlet(font=\"slant\", width=2000).renderText(text)\n    cprint(content, color)\n"]}
{"filename": "utils/api.py", "chunked_list": ["from utils import const\nfrom utils.gen import gen_id\nimport requests\nimport json\nfrom utils.log import logger\nfrom utils.const import MessageType\n\n\ndef fetch(path, data):\n    base_data = {\n        \"id\": gen_id(),\n        \"type\": \"null\",\n        \"roomid\": \"null\",\n        \"wxid\": \"null\",\n        \"content\": \"null\",\n        \"nickname\": \"null\",\n        \"ext\": \"null\",\n    }\n    base_data.update(data)\n    url = f\"http://{const.IP}:{const.PORT}/{path}\"\n    response = requests.post(url, json={\"para\": base_data}, timeout=5)\n    return response.json()", "def fetch(path, data):\n    base_data = {\n        \"id\": gen_id(),\n        \"type\": \"null\",\n        \"roomid\": \"null\",\n        \"wxid\": \"null\",\n        \"content\": \"null\",\n        \"nickname\": \"null\",\n        \"ext\": \"null\",\n    }\n    base_data.update(data)\n    url = f\"http://{const.IP}:{const.PORT}/{path}\"\n    response = requests.post(url, json={\"para\": base_data}, timeout=5)\n    return response.json()", "\n\ndef get_personal_info():\n    path = \"/api/get_personal_info\"\n    data = {\n        \"type\": MessageType.PERSONAL_INFO.value,\n        \"content\": \"op:personal info\",\n    }\n    try:\n        response = fetch(path, data)\n        content = json.loads(response[\"content\"])\n        logger.info(\n            f\"\"\"\n                wechat login info:\n                \n                nickName: {content['wx_name']}\n                account: {content['wx_code']}\n                wechatId: {content['wx_id']}\n                startTime: {response['time']}\n                \"\"\"\n        )\n        return content\n    except Exception as e:\n        logger.error(\"Get personal info failed!\")\n        logger.exception(e)", "\n\n# get sender's nickname in group chat\ndef get_sender_name(room_id, sender_id):\n    path = \"api/getmembernick\"\n    data = {\n        \"type\": MessageType.CHATROOM_MEMBER_NICK.value,\n        \"wxid\": sender_id,\n        \"roomid\": room_id or \"null\",\n    }\n    response = fetch(path, data)\n    return json.loads(response[\"content\"])[\"nick\"]", "\n\ndef send_txt(msg, wx_id):\n    path = \"api/sendtxtmsg\"\n    data = {\n        \"type\": MessageType.TXT_MSG.value,\n        \"content\": msg,\n        \"wxid\": wx_id,\n    }\n    response = fetch(path, data)\n    if response[\"status\"] == const.SUCCESS:\n        logger.info(\"text sent successfully\")\n    else:\n        logger.error(f\"[Server Error]: {response.text}\")", "\n\ndef send_image(img_path, wx_id):\n    path = \"api/sendpic\"\n    data = {\n        \"type\": MessageType.PIC_MSG.value,\n        \"content\": img_path,\n        \"wxid\": wx_id,\n    }\n    response = fetch(path, data)\n    if response[\"status\"] == const.SUCCESS:\n        logger.info(\"image sent successfully\")\n    else:\n        logger.error(f\"[Server Error]: {response.text}\")", "\n\ndef send_file(file_path, wx_id):\n    path = \"api/sendattatch\"\n    data = {\n        \"type\": MessageType.ATTACH_FILE.value,\n        \"content\": file_path,\n        \"wxid\": wx_id,\n    }\n    response = fetch(path, data)\n    if response[\"status\"] == const.SUCCESS:\n        logger.info(\"file sent successfully\")\n    else:\n        logger.error(f\"[Server Error]: {response.text}\")", ""]}
{"filename": "utils/package.py", "chunked_list": ["import subprocess\nimport sys\n\n\ndef install(package):\n    subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", package])\n\n\ndef install_file(file):\n    subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", \"-r\", file])", "def install_file(file):\n    subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", \"-r\", file])\n"]}
{"filename": "utils/const.py", "chunked_list": ["from enum import Enum\n\n# server\nIP = \"127.0.0.1\"\nPORT = \"5555\"\nSERVER = f\"ws://{IP}:{PORT}\"\n\n# \"SUCCSESSED\" should be a typo in the hook server\ud83d\ude02\nSUCCESS = \"SUCCSESSED\"\n", "SUCCESS = \"SUCCSESSED\"\n\n\nclass MessageType(Enum):\n    RECV_TXT_MSG = 1\n    RECV_PIC_MSG = 3\n    RECV_TXT_CITE_MSG = 49\n    PIC_MSG = 500\n    AT_MSG = 550\n    TXT_MSG = 555\n    USER_LIST = 5000\n    GET_USER_LIST_SUCCESS = 5001\n    GET_USER_LIST_FAIL = 5002\n    ATTACH_FILE = 5003\n    HEART_BEAT = 5005\n    CHATROOM_MEMBER = 5010\n    CHATROOM_MEMBER_NICK = 5020\n    PERSONAL_INFO = 6500\n    PERSONAL_DETAIL = 6550\n    DEBUG_SWITCH = 6000\n    DESTROY_ALL = 9999\n    JOIN_ROOM = 10000", ""]}
{"filename": "utils/gen.py", "chunked_list": ["import time\n\ndef gen_id():\n    return time.strftime(\"%Y%m%d%H%M%S\")"]}
{"filename": "utils/serialize.py", "chunked_list": ["import os\nimport time\nimport json\nimport requests\nfrom channel.message import Message\nfrom utils.log import logger\nfrom utils.const import MessageType\nfrom utils.gen import gen_id\n\n\ndef serialize_img(image_url: str) -> str:\n    return serialize_file(image_url, \"png\")", "\n\ndef serialize_img(image_url: str) -> str:\n    return serialize_file(image_url, \"png\")\n\n\ndef serialize_video(video_url: str) -> str:\n    return serialize_file(video_url, \"mp4\")\n\n\ndef serialize_file(file_url: str, suffix: str) -> str:\n    try:\n        # download file\n        path = os.path.abspath(\"./assets\")\n        file_name = int(time.time() * 1000)\n        response = requests.get(file_url, stream=True)\n        response.raise_for_status()  # Raise exception if invalid response\n\n        with open(f\"{path}\\\\{file_name}.{suffix}\", \"wb+\") as f:\n            for chunk in response.iter_content(chunk_size=8192):\n                if chunk:  # filter out keep-alive new chunks\n                    f.write(chunk)\n            f.close()\n        img_path = os.path.abspath(f\"{path}\\\\{file_name}.{suffix}\").replace(\n            \"\\\\\", \"\\\\\\\\\"\n        )\n        return img_path\n    except Exception as e:\n        logger.error(f\"[Download File Error]: {e}\")", "\n\ndef serialize_file(file_url: str, suffix: str) -> str:\n    try:\n        # download file\n        path = os.path.abspath(\"./assets\")\n        file_name = int(time.time() * 1000)\n        response = requests.get(file_url, stream=True)\n        response.raise_for_status()  # Raise exception if invalid response\n\n        with open(f\"{path}\\\\{file_name}.{suffix}\", \"wb+\") as f:\n            for chunk in response.iter_content(chunk_size=8192):\n                if chunk:  # filter out keep-alive new chunks\n                    f.write(chunk)\n            f.close()\n        img_path = os.path.abspath(f\"{path}\\\\{file_name}.{suffix}\").replace(\n            \"\\\\\", \"\\\\\\\\\"\n        )\n        return img_path\n    except Exception as e:\n        logger.error(f\"[Download File Error]: {e}\")", "\n\ndef serialize_text(text: str, msg: Message) -> str:\n    msg_type = MessageType.AT_MSG.value if msg.is_group else MessageType.TXT_MSG.value\n    msg = {\n        \"id\": gen_id(),\n        \"type\": msg_type,\n        \"roomid\": msg.room_id or \"null\",\n        \"wxid\": msg.sender_id or \"null\",\n        \"content\": text,\n        \"nickname\": msg.sender_name or \"null\",\n        \"ext\": \"null\",\n    }\n    return json.dumps(msg)", ""]}
{"filename": "common/singleton.py", "chunked_list": ["def singleton(cls):\n    instances = {}\n\n    def get_instance(*args, **kwargs):\n        if cls not in instances:\n            instances[cls] = cls(*args, **kwargs)\n        return instances[cls]\n\n    return get_instance\n", ""]}
{"filename": "common/context.py", "chunked_list": ["from pydantic import BaseModel\nfrom enum import Enum\nfrom config import conf\n\n\nclass ContextType(Enum):\n    CREATE_TEXT = 1\n    CREATE_IMAGE = 2\n\n    def __str__(self):\n        return self.name", "\n\nclass Context(BaseModel):\n    session_id: str = None\n    type: ContextType = ContextType.CREATE_TEXT\n    query: str = None\n    system_prompt: str = None\n\n    def __init__(self):\n        super().__init__()\n        self.system_prompt = conf().get(\"role_desc\")", ""]}
{"filename": "common/session.py", "chunked_list": ["from common.expired_dict import ExpiredDict\nfrom config import conf\nfrom common.context import Context\n\n\nclass Session(object):\n    all_sessions = ExpiredDict(conf().get(\"session_expired_duration\") or 3600)\n\n    @staticmethod\n    def build_session_query(context: Context):\n        \"\"\"\n        build query with conversation history\n        e.g.  [\n            {\"role\": \"system\", \"content\": \"You are a helpful assistant.\"},\n            {\"role\": \"user\", \"content\": \"Who won the world series in 2020?\"},\n            {\"role\": \"assistant\", \"content\": \"The Los Angeles Dodgers won the World Series in 2020.\"},\n            {\"role\": \"user\", \"content\": \"Where was it played?\"}\n        ]\n        :param query: query content\n        :param session_id: session id\n        :return: query content with conversaction\n        \"\"\"\n        session = Session.all_sessions.get(context.session_id, [])\n        if len(session) == 0:\n            system_item = {\"role\": \"system\", \"content\": context.system_prompt}\n            session.append(system_item)\n            Session.all_sessions[context.session_id] = session\n        user_item = {\"role\": \"user\", \"content\": context.query}\n        session.append(user_item)\n        return session\n\n    @staticmethod\n    def save_session(answer, session_id, total_tokens):\n        max_tokens = conf().get(\"max_tokens\")\n        session = Session.all_sessions.get(session_id)\n        if session:\n            # append conversation\n            gpt_item = {\"role\": \"assistant\", \"content\": answer}\n            session.append(gpt_item)\n\n        # discard exceed limit conversation\n        Session.discard_exceed_conversation(session, max_tokens, total_tokens)\n\n    @staticmethod\n    def discard_exceed_conversation(session, max_tokens, total_tokens):\n        dec_tokens = int(total_tokens)\n        while dec_tokens > max_tokens:\n            # pop first conversation\n            if len(session) > 3:\n                session.pop(1)\n                session.pop(1)\n            else:\n                break\n            dec_tokens = dec_tokens - max_tokens\n\n    @staticmethod\n    def clear_session(session_id):\n        Session.all_sessions[session_id] = []\n\n    @staticmethod\n    def clear_all_session():\n        Session.all_sessions.clear()", ""]}
{"filename": "common/expired_dict.py", "chunked_list": ["from datetime import datetime, timedelta\n\n\nclass ExpiredDict(dict):\n    def __init__(self, expired_duration):\n        super().__init__()\n        self.expired_duration = expired_duration\n\n    def __getitem__(self, key):\n        value, expired_time = super().__getitem__(key)\n        if datetime.now() > expired_time:\n            del self[key]\n            raise KeyError(f\"expired {key}\")\n        self.__setitem__(key, value)\n        return value\n\n    def __setitem__(self, key, value):\n        expired_time = datetime.now() + timedelta(seconds=self.expired_duration)\n        super().__setitem__(key, (value, expired_time))\n\n    def get(self, key, default=None):\n        try:\n            return self[key]\n        except KeyError:\n            return default", ""]}
{"filename": "common/emitter.py", "chunked_list": ["from enum import Enum\nfrom typing import Callable\n\n\nclass Emitter:\n    def __init__(self):\n        self.__events__ = {}\n\n    # subscribe event\n    def on(self, type: Enum, fn: Callable) -> None:\n        if type not in self.__events__:\n            self.__events__[type] = []\n        if not self.has(type, fn):\n            self.__events__[type].append(fn)\n\n    # unsubscribe event\n    def off(self, type: Enum, fn: Callable) -> None:\n        listeners = self.__events__.get(type)\n        if listeners is not None and len(listeners) > 0:\n            listeners.remove(fn)\n\n    # check if the function has subscribed the event\n    def has(self, type: Enum, fn: Callable) -> bool:\n        listeners = self.__events__.get(type)\n        if listeners is None or len(listeners) == 0:\n            return False\n        return fn in listeners\n\n    # emit event\n    def emit(self, type: Enum, *args, **kwargs) -> None:\n        listeners = self.__events__.get(type)\n        if listeners is not None and len(listeners) > 0:\n            for fn in listeners:\n                fn(*args, **kwargs)\n\n    # subscribe event and unsubscribe after once\n    def once(self, type: Enum, fn: Callable) -> None:\n        def once_fn(*args, **kwargs):\n            fn(*args, **kwargs)\n            self.off(type, once_fn)\n\n        self.on(type, once_fn)", ""]}
{"filename": "common/reply.py", "chunked_list": ["from enum import Enum\nfrom pydantic import BaseModel\n\n\nclass ReplyType(Enum):\n    TEXT = 1\n    IMAGE = 2\n    VIDEO = 3\n\n    def __str__(self):\n        return self.name", "\n\nclass Reply(BaseModel):\n    type: ReplyType = None\n    content: str = None\n\n    def __init__(self, type: ReplyType, content: str):\n        super().__init__()\n        self.type = type\n        self.content = content\n\n    def __str__(self):\n        return f\"Reply(type={self.type}, content={self.content})\"", ""]}
{"filename": "bot/bot.py", "chunked_list": ["import litellm\nfrom common.context import Context\nfrom config import conf\nfrom common.singleton import singleton\nfrom common.reply import Reply\n\n\n@singleton\nclass Bot:\n    def __init__(self):\n        use_azure_chatgpt = conf().get(\"use_azure_chatgpt\", False)\n        model = conf().get(\"model\", \"gpt-3.5-turbo\")\n        if use_azure_chatgpt:\n            from bot.azure_chatgpt import AzureChatGPTBot\n\n            self.bot = AzureChatGPTBot()\n\n        elif model in litellm.open_ai_chat_completion_models:\n            from bot.chatgpt import ChatGPTBot\n\n            self.bot = ChatGPTBot()\n        else:\n            # see litellm supported models here:\n            # https://litellm.readthedocs.io/en/latest/supported/\n            from bot.litellm import LiteLLMChatGPTBot\n\n            self.bot = LiteLLMChatGPTBot()\n\n    def reply(self, context: Context) -> Reply:\n        return self.bot.reply(context)", "class Bot:\n    def __init__(self):\n        use_azure_chatgpt = conf().get(\"use_azure_chatgpt\", False)\n        model = conf().get(\"model\", \"gpt-3.5-turbo\")\n        if use_azure_chatgpt:\n            from bot.azure_chatgpt import AzureChatGPTBot\n\n            self.bot = AzureChatGPTBot()\n\n        elif model in litellm.open_ai_chat_completion_models:\n            from bot.chatgpt import ChatGPTBot\n\n            self.bot = ChatGPTBot()\n        else:\n            # see litellm supported models here:\n            # https://litellm.readthedocs.io/en/latest/supported/\n            from bot.litellm import LiteLLMChatGPTBot\n\n            self.bot = LiteLLMChatGPTBot()\n\n    def reply(self, context: Context) -> Reply:\n        return self.bot.reply(context)", ""]}
{"filename": "bot/azure_chatgpt.py", "chunked_list": ["import openai\nfrom bot.chatgpt import ChatGPTBot\nfrom config import conf\n\n\nclass AzureChatGPTBot(ChatGPTBot):\n    def __init__(self):\n        super().__init__()\n        openai.api_type = \"azure\"\n        openai.api_version = \"2023-06-01-preview\"\n        self.args[\"deployment_id\"] = conf().get(\"azure_deployment_id\")", ""]}
{"filename": "bot/chatgpt.py", "chunked_list": ["import openai\nfrom config import conf\nfrom utils.log import logger\nfrom common.session import Session\nfrom common.reply import Reply, ReplyType\nfrom common.context import ContextType, Context\n\n\nclass ChatGPTBot:\n    def __init__(self):\n        openai.api_key = conf().get(\"openai_api_key\")\n        api_base = conf().get(\"openai_api_base\")\n        proxy = conf().get(\"proxy\")\n        if api_base:\n            openai.api_base = api_base\n        if proxy:\n            openai.proxy = proxy\n        self.name = self.__class__.__name__\n        self.args = {\n            \"model\": conf().get(\"model\"),\n            \"temperature\": conf().get(\"temperature\"),\n        }\n\n    def reply(self, context: Context) -> Reply:\n        query = context.query\n        logger.info(f\"[{self.name}] Query={query}\")\n        if context.type == ContextType.CREATE_IMAGE:\n            return self.reply_img(query)\n        else:\n            session_id = context.session_id\n            session = Session.build_session_query(context)\n            response = self.reply_text(session)\n            logger.info(f\"[{self.name}] Response={response['content']}\")\n            if response[\"completion_tokens\"] > 0:\n                Session.save_session(\n                    response[\"content\"], session_id, response[\"total_tokens\"]\n                )\n            return Reply(ReplyType.TEXT, response[\"content\"])\n\n    def reply_img(self, query) -> Reply:\n        create_image_size = conf().get(\"create_image_size\", \"256x256\")\n        try:\n            response = openai.Image.create(prompt=query, n=1, size=create_image_size)\n            image_url = response[\"data\"][0][\"url\"]\n            logger.info(f\"[{self.name}] Image={image_url}\")\n            return Reply(ReplyType.IMAGE, image_url)\n        except Exception as e:\n            logger.error(f\"[{self.name}] Create image failed: {e}\")\n            return Reply(ReplyType.TEXT, \"Image created failed\")\n\n    def reply_text(self, session):\n        try:\n            response = openai.ChatCompletion.create(\n                messages=session,\n                top_p=1.0,\n                frequency_penalty=0.0,\n                presence_penalty=0.0,\n                **self.args,\n            )\n            return {\n                \"total_tokens\": response[\"usage\"][\"total_tokens\"],\n                \"completion_tokens\": response[\"usage\"][\"completion_tokens\"],\n                \"content\": response.choices[0][\"message\"][\"content\"],\n            }\n        except Exception as e:\n            result = {\"completion_tokens\": 0, \"content\": \"Please ask me again\"}\n            if isinstance(e, openai.error.RateLimitError):\n                logger.warn(f\"[{self.name}] RateLimitError: {e}\")\n                result[\"content\"] = \"Ask too frequently, please try again in 20s\"\n            elif isinstance(e, openai.error.APIConnectionError):\n                logger.warn(f\"[{self.name}] APIConnectionError: {e}\")\n                result[\n                    \"content\"\n                ] = \"I cannot connect the server, please check the network and try again\"\n            elif isinstance(e, openai.error.Timeout):\n                logger.warn(f\"[{self.name}] Timeout: {e}\")\n                result[\"content\"] = \"I didn't receive your message, please try again\"\n            elif isinstance(e, openai.error.APIError):\n                logger.warn(f\"[{self.name}] APIError: {e}\")\n            else:\n                logger.exception(f\"[{self.name}] Exception: {e}\")\n        return result", "class ChatGPTBot:\n    def __init__(self):\n        openai.api_key = conf().get(\"openai_api_key\")\n        api_base = conf().get(\"openai_api_base\")\n        proxy = conf().get(\"proxy\")\n        if api_base:\n            openai.api_base = api_base\n        if proxy:\n            openai.proxy = proxy\n        self.name = self.__class__.__name__\n        self.args = {\n            \"model\": conf().get(\"model\"),\n            \"temperature\": conf().get(\"temperature\"),\n        }\n\n    def reply(self, context: Context) -> Reply:\n        query = context.query\n        logger.info(f\"[{self.name}] Query={query}\")\n        if context.type == ContextType.CREATE_IMAGE:\n            return self.reply_img(query)\n        else:\n            session_id = context.session_id\n            session = Session.build_session_query(context)\n            response = self.reply_text(session)\n            logger.info(f\"[{self.name}] Response={response['content']}\")\n            if response[\"completion_tokens\"] > 0:\n                Session.save_session(\n                    response[\"content\"], session_id, response[\"total_tokens\"]\n                )\n            return Reply(ReplyType.TEXT, response[\"content\"])\n\n    def reply_img(self, query) -> Reply:\n        create_image_size = conf().get(\"create_image_size\", \"256x256\")\n        try:\n            response = openai.Image.create(prompt=query, n=1, size=create_image_size)\n            image_url = response[\"data\"][0][\"url\"]\n            logger.info(f\"[{self.name}] Image={image_url}\")\n            return Reply(ReplyType.IMAGE, image_url)\n        except Exception as e:\n            logger.error(f\"[{self.name}] Create image failed: {e}\")\n            return Reply(ReplyType.TEXT, \"Image created failed\")\n\n    def reply_text(self, session):\n        try:\n            response = openai.ChatCompletion.create(\n                messages=session,\n                top_p=1.0,\n                frequency_penalty=0.0,\n                presence_penalty=0.0,\n                **self.args,\n            )\n            return {\n                \"total_tokens\": response[\"usage\"][\"total_tokens\"],\n                \"completion_tokens\": response[\"usage\"][\"completion_tokens\"],\n                \"content\": response.choices[0][\"message\"][\"content\"],\n            }\n        except Exception as e:\n            result = {\"completion_tokens\": 0, \"content\": \"Please ask me again\"}\n            if isinstance(e, openai.error.RateLimitError):\n                logger.warn(f\"[{self.name}] RateLimitError: {e}\")\n                result[\"content\"] = \"Ask too frequently, please try again in 20s\"\n            elif isinstance(e, openai.error.APIConnectionError):\n                logger.warn(f\"[{self.name}] APIConnectionError: {e}\")\n                result[\n                    \"content\"\n                ] = \"I cannot connect the server, please check the network and try again\"\n            elif isinstance(e, openai.error.Timeout):\n                logger.warn(f\"[{self.name}] Timeout: {e}\")\n                result[\"content\"] = \"I didn't receive your message, please try again\"\n            elif isinstance(e, openai.error.APIError):\n                logger.warn(f\"[{self.name}] APIError: {e}\")\n            else:\n                logger.exception(f\"[{self.name}] Exception: {e}\")\n        return result", ""]}
{"filename": "bot/litellm.py", "chunked_list": ["from bot.chatgpt import ChatGPTBot\nimport openai\nimport litellm\nfrom litellm import completion\nfrom utils.log import logger\nfrom config import conf\n\n\nclass LiteLLMChatGPTBot(ChatGPTBot):\n    def __init__(self):\n        api_key = conf().get(\"openai_api_key\")\n        model = conf().get(\"model\", \"gpt-3.5-turbo\")\n        api_base = conf().get(\"openai_api_base\")\n        proxy = conf().get(\"proxy\")\n\n        if model in litellm.cohere_models:\n            litellm.cohere_key = api_key\n        elif model in litellm.anthropic_models:\n            litellm.anthropic_key = api_key\n        else:\n            litellm.openai_key = api_key\n\n        if api_base:\n            litellm.api_base = api_base\n        if proxy:\n            openai.proxy = proxy\n        self.name = self.__class__.__name__\n        self.args = {\n            \"model\": model,\n            \"temperature\": conf().get(\"temperature\"),\n        }\n\n    def reply_text(self, session):\n        try:\n            response = completion(\n                messages=session,\n                top_p=1.0,\n                frequency_penalty=0.0,\n                presence_penalty=0.0,\n                **self.args,\n            )\n            return {\n                \"total_tokens\": response[\"usage\"][\"total_tokens\"],\n                \"completion_tokens\": response[\"usage\"][\"completion_tokens\"],\n                \"content\": response.choices[0][\"message\"][\"content\"],\n            }\n        except Exception as e:\n            result = {\"completion_tokens\": 0, \"content\": \"Please ask me again\"}\n            if isinstance(e, openai.error.RateLimitError):\n                logger.warn(f\"[{self.name}] RateLimitError: {e}\")\n                result[\"content\"] = \"Ask too frequently, please try again in 20s\"\n            elif isinstance(e, openai.error.APIConnectionError):\n                logger.warn(f\"[{self.name}] APIConnectionError: {e}\")\n                result[\n                    \"content\"\n                ] = \"I cannot connect the server, please check the network and try again\"\n            elif isinstance(e, openai.error.Timeout):\n                logger.warn(f\"[{self.name}] Timeout: {e}\")\n                result[\"content\"] = \"I didn't receive your message, please try again\"\n            elif isinstance(e, openai.error.APIError):\n                logger.warn(f\"[{self.name}] APIError: {e}\")\n            else:\n                logger.exception(f\"[{self.name}] Exception: {e}\")\n        return result", "class LiteLLMChatGPTBot(ChatGPTBot):\n    def __init__(self):\n        api_key = conf().get(\"openai_api_key\")\n        model = conf().get(\"model\", \"gpt-3.5-turbo\")\n        api_base = conf().get(\"openai_api_base\")\n        proxy = conf().get(\"proxy\")\n\n        if model in litellm.cohere_models:\n            litellm.cohere_key = api_key\n        elif model in litellm.anthropic_models:\n            litellm.anthropic_key = api_key\n        else:\n            litellm.openai_key = api_key\n\n        if api_base:\n            litellm.api_base = api_base\n        if proxy:\n            openai.proxy = proxy\n        self.name = self.__class__.__name__\n        self.args = {\n            \"model\": model,\n            \"temperature\": conf().get(\"temperature\"),\n        }\n\n    def reply_text(self, session):\n        try:\n            response = completion(\n                messages=session,\n                top_p=1.0,\n                frequency_penalty=0.0,\n                presence_penalty=0.0,\n                **self.args,\n            )\n            return {\n                \"total_tokens\": response[\"usage\"][\"total_tokens\"],\n                \"completion_tokens\": response[\"usage\"][\"completion_tokens\"],\n                \"content\": response.choices[0][\"message\"][\"content\"],\n            }\n        except Exception as e:\n            result = {\"completion_tokens\": 0, \"content\": \"Please ask me again\"}\n            if isinstance(e, openai.error.RateLimitError):\n                logger.warn(f\"[{self.name}] RateLimitError: {e}\")\n                result[\"content\"] = \"Ask too frequently, please try again in 20s\"\n            elif isinstance(e, openai.error.APIConnectionError):\n                logger.warn(f\"[{self.name}] APIConnectionError: {e}\")\n                result[\n                    \"content\"\n                ] = \"I cannot connect the server, please check the network and try again\"\n            elif isinstance(e, openai.error.Timeout):\n                logger.warn(f\"[{self.name}] Timeout: {e}\")\n                result[\"content\"] = \"I didn't receive your message, please try again\"\n            elif isinstance(e, openai.error.APIError):\n                logger.warn(f\"[{self.name}] APIError: {e}\")\n            else:\n                logger.exception(f\"[{self.name}] Exception: {e}\")\n        return result", ""]}
{"filename": "channel/channel.py", "chunked_list": ["from abc import ABC, abstractmethod\n\n\nclass Channel(ABC):\n    @abstractmethod\n    def handle_message(self, msg):\n        pass\n\n    @abstractmethod\n    def handle_group(self, msg):\n        pass\n\n    @abstractmethod\n    def handle_single(self, msg):\n        pass\n\n    @abstractmethod\n    def decorate_reply(self, reply, msg):\n        pass\n\n    @abstractmethod\n    def handle_reply(self, msg, context):\n        pass\n\n    @abstractmethod\n    def send(self, reply, msg):\n        pass", ""]}
{"filename": "channel/wechat.py", "chunked_list": ["import json\nimport warnings\nimport websocket\nfrom bs4 import BeautifulSoup\nimport requests\nfrom utils.log import logger\nfrom utils import const\nimport os\nfrom bot.bot import Bot\nfrom common.singleton import singleton", "from bot.bot import Bot\nfrom common.singleton import singleton\nfrom config import conf\nfrom utils.check import check_prefix, is_wx_account\nfrom common.reply import ReplyType, Reply\nfrom channel.message import Message\nfrom utils.api import get_personal_info, send_image, send_file\nfrom utils.const import MessageType\nfrom utils.serialize import serialize_img, serialize_text, serialize_video\nfrom plugins.manager import PluginManager", "from utils.serialize import serialize_img, serialize_text, serialize_video\nfrom plugins.manager import PluginManager\nfrom common.context import ContextType, Context\nfrom plugins.event import EventType, Event\nfrom channel.channel import Channel\n\n\n@singleton\nclass WeChatChannel(Channel):\n    def __init__(self):\n        requests.packages.urllib3.disable_warnings()\n        warnings.filterwarnings(\"ignore\")\n        os.environ[\"TF_CPP_MIN_LOG_LEVEL\"] = \"1\"\n        self.personal_info = get_personal_info()\n        self.ws = websocket.WebSocketApp(\n            const.SERVER,\n            on_open=self.on_open,\n            on_message=self.on_message,\n            on_error=self.on_error,\n            on_close=self.on_close,\n        )\n\n    def startup(self):\n        logger.info(\"App startup successfully!\")\n        self.ws.run_forever()\n\n    def on_message(self, ws, message):\n        raw_msg = json.loads(message)\n        msg_type = raw_msg[\"type\"]\n        handlers = {\n            MessageType.AT_MSG.value: self.handle_message,\n            MessageType.TXT_MSG.value: self.handle_message,\n            MessageType.PIC_MSG.value: self.handle_message,\n            MessageType.RECV_PIC_MSG.value: self.handle_message,\n            MessageType.RECV_TXT_MSG.value: self.handle_message,\n            MessageType.RECV_TXT_CITE_MSG.value: self.handle_cite_message,\n            MessageType.HEART_BEAT.value: self.noop,\n        }\n        handlers.get(msg_type, logger.info)(raw_msg)\n\n    def noop(self, raw_msg):\n        pass\n\n    def handle_cite_message(self, raw_msg):\n        xml_msg = (\n            raw_msg[\"content\"][\"content\"]\n            .replace(\"&amp;\", \"&\")\n            .replace(\"&lt;\", \"<\")\n            .replace(\"&gt;\", \">\")\n        )\n        soup = BeautifulSoup(xml_msg, \"lxml\")\n        cooked_msg = {\n            \"content\": soup.select_one(\"title\").text,\n            \"id\": raw_msg[\"id\"],\n            \"id1\": raw_msg[\"content\"][\"id2\"],\n            \"id2\": \"\",\n            \"id3\": \"\",\n            \"srvid\": raw_msg[\"srvid\"],\n            \"time\": raw_msg[\"time\"],\n            \"type\": raw_msg[\"type\"],\n            \"wxid\": raw_msg[\"content\"][\"id1\"],\n        }\n        self.handle_message(cooked_msg)\n\n    def handle_message(self, raw_msg):\n        if \"wxid\" not in raw_msg and raw_msg[\"status\"] == const.SUCCESS:\n            logger.info(\"message sent successfully\")\n            return\n        # ignore message sent by self\n        if raw_msg[\"id2\"] == self.personal_info[\"wx_id\"]:\n            logger.info(\"message sent by self, ignore\")\n            return\n        msg = Message(raw_msg, self.personal_info)\n        logger.info(f\"message received: {msg}\")\n        e = PluginManager().emit(\n            Event(EventType.DID_RECEIVE_MESSAGE, {\"channel\": self, \"message\": msg})\n        )\n        if e.is_bypass:\n            return self.send(e.reply, e.message)\n        if e.message.is_group:\n            self.handle_group(e.message)\n        else:\n            self.handle_single(e.message)\n\n    def handle_group(self, msg: Message):\n        session_independent = conf().get(\"chat_group_session_independent\")\n        context = Context()\n        context.session_id = msg.sender_id if session_independent else msg.room_id\n        if msg.is_at:\n            query = msg.content.replace(f\"@{msg.receiver_name}\", \"\", 1).strip()\n            context.query = query\n            create_image_prefix = conf().get(\"create_image_prefix\")\n            match_prefix = check_prefix(query, create_image_prefix)\n            if match_prefix:\n                context.type = ContextType.CREATE_IMAGE\n            self.handle_reply(msg, context)\n\n    def handle_single(self, msg: Message):\n        # ignore message sent by public/subscription account\n        if not is_wx_account(msg.sender_id):\n            logger.info(\"message sent by public/subscription account, ignore\")\n            return\n        context = Context()\n        context.session_id = msg.sender_id\n        query = msg.content\n        single_chat_prefix = conf().get(\"single_chat_prefix\")\n        if single_chat_prefix is not None and len(single_chat_prefix) > 0:\n            match_chat_prefix = check_prefix(query, single_chat_prefix)\n            if match_chat_prefix is not None:\n                query = query.replace(match_chat_prefix, \"\", 1).strip()\n            else:\n                logger.info(\"your message is not start with single_chat_prefix, ignore\")\n                return\n        context.query = query\n        create_image_prefix = conf().get(\"create_image_prefix\")\n        match_image_prefix = check_prefix(query, create_image_prefix)\n        if match_image_prefix:\n            context.type = ContextType.CREATE_IMAGE\n        self.handle_reply(msg, context)\n\n    def decorate_reply(self, reply: Reply, msg: Message) -> Reply:\n        if reply.type == ReplyType.TEXT:\n            group_chat_reply_prefix = conf().get(\"group_chat_reply_prefix\", \"\")\n            group_chat_reply_suffix = conf().get(\"group_chat_reply_suffix\", \"\")\n            single_chat_reply_prefix = conf().get(\"single_chat_reply_prefix\", \"\")\n            single_chat_reply_suffix = conf().get(\"single_chat_reply_suffix\", \"\")\n            reply_text = reply.content\n            if msg.is_group:\n                reply_text = (\n                    group_chat_reply_prefix + reply_text + group_chat_reply_suffix\n                )\n            else:\n                reply_text = (\n                    single_chat_reply_prefix + reply_text + single_chat_reply_suffix\n                )\n            reply.content = reply_text\n        return reply\n\n    def handle_reply(self, msg: Message, context: Context):\n        e1 = PluginManager().emit(\n            Event(\n                EventType.WILL_GENERATE_REPLY,\n                {\"channel\": self, \"message\": msg, \"context\": context},\n            )\n        )\n        if e1.is_bypass:\n            return self.send(e1.reply, e1.message)\n\n        rawReply = Bot().reply(e1.context)\n\n        e2 = PluginManager().emit(\n            Event(\n                EventType.WILL_DECORATE_REPLY,\n                {\n                    \"channel\": self,\n                    \"message\": e1.message,\n                    \"context\": e1.context,\n                    \"reply\": rawReply,\n                },\n            )\n        )\n        if e2.is_bypass:\n            return self.send(e2.reply, e2.message)\n\n        reply = self.decorate_reply(rawReply, msg)\n\n        e3 = PluginManager().emit(\n            Event(\n                EventType.WILL_SEND_REPLY,\n                {\n                    \"channel\": self,\n                    \"message\": e2.message,\n                    \"context\": e2.context,\n                    \"reply\": reply,\n                },\n            )\n        )\n        self.send(e3.reply, e3.message)\n\n    def send(self, reply: Reply, msg: Message):\n        if reply is None:\n            return\n        if reply.type == ReplyType.IMAGE:\n            img_path = serialize_img(reply.content)\n            wx_id = msg.room_id if msg.is_group else msg.sender_id\n            send_image(img_path, wx_id)\n        elif reply.type == ReplyType.VIDEO:\n            file_path = serialize_video(reply.content)\n            wx_id = msg.room_id if msg.is_group else msg.sender_id\n            send_file(file_path, wx_id)\n        else:\n            reply_msg = serialize_text(reply.content, msg)\n            self.ws.send(reply_msg)\n\n    def on_open(self, ws):\n        logger.info(\"[Websocket] connected\")\n\n    def on_close(self, ws):\n        logger.info(\"[Websocket] disconnected\")\n\n    def on_error(self, ws, error):\n        logger.error(f\"[Websocket] Error: {error}\")", "class WeChatChannel(Channel):\n    def __init__(self):\n        requests.packages.urllib3.disable_warnings()\n        warnings.filterwarnings(\"ignore\")\n        os.environ[\"TF_CPP_MIN_LOG_LEVEL\"] = \"1\"\n        self.personal_info = get_personal_info()\n        self.ws = websocket.WebSocketApp(\n            const.SERVER,\n            on_open=self.on_open,\n            on_message=self.on_message,\n            on_error=self.on_error,\n            on_close=self.on_close,\n        )\n\n    def startup(self):\n        logger.info(\"App startup successfully!\")\n        self.ws.run_forever()\n\n    def on_message(self, ws, message):\n        raw_msg = json.loads(message)\n        msg_type = raw_msg[\"type\"]\n        handlers = {\n            MessageType.AT_MSG.value: self.handle_message,\n            MessageType.TXT_MSG.value: self.handle_message,\n            MessageType.PIC_MSG.value: self.handle_message,\n            MessageType.RECV_PIC_MSG.value: self.handle_message,\n            MessageType.RECV_TXT_MSG.value: self.handle_message,\n            MessageType.RECV_TXT_CITE_MSG.value: self.handle_cite_message,\n            MessageType.HEART_BEAT.value: self.noop,\n        }\n        handlers.get(msg_type, logger.info)(raw_msg)\n\n    def noop(self, raw_msg):\n        pass\n\n    def handle_cite_message(self, raw_msg):\n        xml_msg = (\n            raw_msg[\"content\"][\"content\"]\n            .replace(\"&amp;\", \"&\")\n            .replace(\"&lt;\", \"<\")\n            .replace(\"&gt;\", \">\")\n        )\n        soup = BeautifulSoup(xml_msg, \"lxml\")\n        cooked_msg = {\n            \"content\": soup.select_one(\"title\").text,\n            \"id\": raw_msg[\"id\"],\n            \"id1\": raw_msg[\"content\"][\"id2\"],\n            \"id2\": \"\",\n            \"id3\": \"\",\n            \"srvid\": raw_msg[\"srvid\"],\n            \"time\": raw_msg[\"time\"],\n            \"type\": raw_msg[\"type\"],\n            \"wxid\": raw_msg[\"content\"][\"id1\"],\n        }\n        self.handle_message(cooked_msg)\n\n    def handle_message(self, raw_msg):\n        if \"wxid\" not in raw_msg and raw_msg[\"status\"] == const.SUCCESS:\n            logger.info(\"message sent successfully\")\n            return\n        # ignore message sent by self\n        if raw_msg[\"id2\"] == self.personal_info[\"wx_id\"]:\n            logger.info(\"message sent by self, ignore\")\n            return\n        msg = Message(raw_msg, self.personal_info)\n        logger.info(f\"message received: {msg}\")\n        e = PluginManager().emit(\n            Event(EventType.DID_RECEIVE_MESSAGE, {\"channel\": self, \"message\": msg})\n        )\n        if e.is_bypass:\n            return self.send(e.reply, e.message)\n        if e.message.is_group:\n            self.handle_group(e.message)\n        else:\n            self.handle_single(e.message)\n\n    def handle_group(self, msg: Message):\n        session_independent = conf().get(\"chat_group_session_independent\")\n        context = Context()\n        context.session_id = msg.sender_id if session_independent else msg.room_id\n        if msg.is_at:\n            query = msg.content.replace(f\"@{msg.receiver_name}\", \"\", 1).strip()\n            context.query = query\n            create_image_prefix = conf().get(\"create_image_prefix\")\n            match_prefix = check_prefix(query, create_image_prefix)\n            if match_prefix:\n                context.type = ContextType.CREATE_IMAGE\n            self.handle_reply(msg, context)\n\n    def handle_single(self, msg: Message):\n        # ignore message sent by public/subscription account\n        if not is_wx_account(msg.sender_id):\n            logger.info(\"message sent by public/subscription account, ignore\")\n            return\n        context = Context()\n        context.session_id = msg.sender_id\n        query = msg.content\n        single_chat_prefix = conf().get(\"single_chat_prefix\")\n        if single_chat_prefix is not None and len(single_chat_prefix) > 0:\n            match_chat_prefix = check_prefix(query, single_chat_prefix)\n            if match_chat_prefix is not None:\n                query = query.replace(match_chat_prefix, \"\", 1).strip()\n            else:\n                logger.info(\"your message is not start with single_chat_prefix, ignore\")\n                return\n        context.query = query\n        create_image_prefix = conf().get(\"create_image_prefix\")\n        match_image_prefix = check_prefix(query, create_image_prefix)\n        if match_image_prefix:\n            context.type = ContextType.CREATE_IMAGE\n        self.handle_reply(msg, context)\n\n    def decorate_reply(self, reply: Reply, msg: Message) -> Reply:\n        if reply.type == ReplyType.TEXT:\n            group_chat_reply_prefix = conf().get(\"group_chat_reply_prefix\", \"\")\n            group_chat_reply_suffix = conf().get(\"group_chat_reply_suffix\", \"\")\n            single_chat_reply_prefix = conf().get(\"single_chat_reply_prefix\", \"\")\n            single_chat_reply_suffix = conf().get(\"single_chat_reply_suffix\", \"\")\n            reply_text = reply.content\n            if msg.is_group:\n                reply_text = (\n                    group_chat_reply_prefix + reply_text + group_chat_reply_suffix\n                )\n            else:\n                reply_text = (\n                    single_chat_reply_prefix + reply_text + single_chat_reply_suffix\n                )\n            reply.content = reply_text\n        return reply\n\n    def handle_reply(self, msg: Message, context: Context):\n        e1 = PluginManager().emit(\n            Event(\n                EventType.WILL_GENERATE_REPLY,\n                {\"channel\": self, \"message\": msg, \"context\": context},\n            )\n        )\n        if e1.is_bypass:\n            return self.send(e1.reply, e1.message)\n\n        rawReply = Bot().reply(e1.context)\n\n        e2 = PluginManager().emit(\n            Event(\n                EventType.WILL_DECORATE_REPLY,\n                {\n                    \"channel\": self,\n                    \"message\": e1.message,\n                    \"context\": e1.context,\n                    \"reply\": rawReply,\n                },\n            )\n        )\n        if e2.is_bypass:\n            return self.send(e2.reply, e2.message)\n\n        reply = self.decorate_reply(rawReply, msg)\n\n        e3 = PluginManager().emit(\n            Event(\n                EventType.WILL_SEND_REPLY,\n                {\n                    \"channel\": self,\n                    \"message\": e2.message,\n                    \"context\": e2.context,\n                    \"reply\": reply,\n                },\n            )\n        )\n        self.send(e3.reply, e3.message)\n\n    def send(self, reply: Reply, msg: Message):\n        if reply is None:\n            return\n        if reply.type == ReplyType.IMAGE:\n            img_path = serialize_img(reply.content)\n            wx_id = msg.room_id if msg.is_group else msg.sender_id\n            send_image(img_path, wx_id)\n        elif reply.type == ReplyType.VIDEO:\n            file_path = serialize_video(reply.content)\n            wx_id = msg.room_id if msg.is_group else msg.sender_id\n            send_file(file_path, wx_id)\n        else:\n            reply_msg = serialize_text(reply.content, msg)\n            self.ws.send(reply_msg)\n\n    def on_open(self, ws):\n        logger.info(\"[Websocket] connected\")\n\n    def on_close(self, ws):\n        logger.info(\"[Websocket] disconnected\")\n\n    def on_error(self, ws, error):\n        logger.error(f\"[Websocket] Error: {error}\")", ""]}
{"filename": "channel/message.py", "chunked_list": ["from pydantic import BaseModel\nfrom utils.api import get_sender_name\n\n\nclass Message(BaseModel):\n    room_id: str = None\n    sender_id: str = None\n    sender_name: str = None\n    receiver_id: str = None\n    receiver_name: str = None\n    content: str = None\n    type: int = None  # MessageType value\n    is_group: bool = False\n    is_at: bool = False\n    create_time: str = None\n    _raw_msg: dict = None\n\n    def __init__(self, msg, info):\n        super().__init__()\n        self._raw_msg = msg\n        self.receiver_id = info[\"wx_id\"]\n        self.receiver_name = info[\"wx_name\"]\n        self.content = msg[\"content\"].strip()\n        self.type = msg[\"type\"]\n        self.create_time = msg[\"time\"]\n        if \"@chatroom\" in msg[\"wxid\"]:\n            self.is_group = True\n            self.room_id = msg[\"wxid\"]\n            self.sender_id = msg[\"id1\"]\n            self.is_at = f\"@{self.receiver_name}\" in self.content\n        else:\n            self.is_group = False\n            self.sender_id = msg[\"wxid\"]\n        self.sender_name = get_sender_name(self.room_id, self.sender_id)\n\n    def __str__(self):\n        return f\"Message(room_id={self.room_id}, sender_id={self.sender_id}, sender_name={self.sender_name}, receiver_id={self.receiver_id}, receiver_name={self.receiver_name}, content={self.content}, type={self.type}, is_group={self.is_group}, create_time={self.create_time}, is_at={self.is_at})\"", ""]}
