{"filename": "run.py", "chunked_list": ["#!/usr/bin/env python3\n\n# MIT License\n \n# Copyright (c) 2023 Advanced Micro Devices, Inc.\n \n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell", "# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n \n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n \n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,", "# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\nimport argparse\nimport time", "import argparse\nimport time\n\nfrom logger import logger\nfrom system_config.SystemConfig import SystemConfig\n\n\ndef checkMces(config, description):\n    mces = config.checkMCEs(force=True)\n    if mces:\n        logger.warning(\"Post-Test check detected MCE. Check log for details\")\n        for mce in mces:\n            logger.results(description, \"\", [], False, [], True, \"\", \"\", str(mce))", "\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"settings_file\")\n    parser.add_argument(\"--run_dir\", type=str)\n    parser.add_argument(\"--log_dir\", type=str)\n    args = parser.parse_args()\n\n    try:\n        config = SystemConfig(\n            args.settings_file,\n            args.run_dir,\n            args.log_dir,\n        )\n    except RuntimeError as ex:\n        print(\"Failed to detect the configuration needed to run La Hacienda\")\n        print(ex)\n        exit(1)\n\n    # Clear MCE's before running any tests\n    checkMces(config, \"PRETEST Detection\")\n    config.clearMCEs()\n    # Importing this after setting the logging level\n    from test_factories.TestFactory import TestFactory\n\n    testFactory = TestFactory(config)\n\n    startTime = time.perf_counter()\n    while True:\n        try:\n            test = testFactory.getNextTest()\n        except StopIteration:\n            checkMces(config, \"POSTTEST Detection\")\n            logger.info(\"Finished executing all tests\")\n            exit(0)\n        if not test.execute():\n            logger.warning(\"Test Failed, see logs for details\")", ""]}
{"filename": "logger.py", "chunked_list": ["# MIT License\n \n# Copyright (c) 2023 Advanced Micro Devices, Inc.\n \n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:", "# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n \n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n \n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER", "# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\nimport logging\nimport os\nfrom logging.handlers import RotatingFileHandler\n", "from logging.handlers import RotatingFileHandler\n\n\nclass logger:\n    \"\"\"Logger singleton that takes care of logging the results, warnings, and errors to the appropriate locations\n\n    Attributes:\n        level: an integer representation of the log level to log\n        log_dir: the directory to output all the log files\n\n        BARE: No warnings, info, or debug messages. Only output file\n        ALL: Output file and logs warnings to stream\n        EXCESS: Output file and logs info to stream\n        DEBUG: Output file and logs debug messages to debug file\n\n    Static Methods:\n        log_level_help_str(): returns a string that defines the differt log levels\n\n    Class Methods:\n        set_log_level(int): sets log level\n        set_log_dir(str): sets the log directory and creates it if it doesn't exist\n\n        debug(msg): log a debugging message\n        info(msg): log an info message\n        warning(msg): log a warning message\n        error(msg): log an error message\n        critical(msg): log a critical message\n        results(cls,cmdNum,cmdLine,cores,isACF,acfFailingcores,isMCE,sysUptime,acfDetails,mceDetails):\n            log a test result to the results file\n\n        cmd(cmdNum, cmdLine, sysUptime): log a command to the pending command file before running the test\n\n\n    Protected Methods:\n        _set_stream_handler()\n        _get_debug_file_handler()\n        _set_results_logger()\n        _get_results_handler()\n        _set_cmd_logger()\n        _get_cmd_handler()\n    \"\"\"\n\n    level = 10\n    # TODO: make these read only\n    BARE = 0\n    ALL = 10\n    EXCESS = 20\n    DEBUG = 30\n\n    log_dir = \"logs\"\n\n    __results_logger = None\n    __cmd_logger = None\n    __logger = None\n\n    @classmethod\n    def set_log_level(cls, logLevel: int):\n        \"\"\"Set the log level\n        Log Levels:\n            0: bare minimum, only output file\n            10: output file and warning messages\n            20: output file, warning, and info messages\n            30: all messages, debug messages output to a debug log file\n        \"\"\"\n        cls.level = logLevel\n        cls._check_log_dir()\n        cls.__logger = logging.getLogger(__name__)\n        cls.__logger.setLevel(logging.DEBUG)\n        cls.__logger.addHandler(cls._get_debug_file_handler())\n        cls.__logger.addHandler(cls._get_stream_handler())\n\n    @classmethod\n    def _check_log_dir(cls):\n        if not os.path.exists(cls.log_dir):\n            os.makedirs(cls.log_dir)\n\n    @staticmethod\n    def log_level_help_str():\n        retStr = (\n            \"Log Levels:\\n\"\n            \"0: bare minimum, only output file\\n\"\n            \"10: output file and warning messages\\n\"\n            \"20: output file, warning, and info messages\\n\"\n            \"30: all messages, debug messages output to a debug log file\\n\"\n        )\n        return retStr\n\n    @classmethod\n    def cmd(cls, cmdNum, cmdLine, cores, sysUptime=\"\"):\n        if not cls.__cmd_logger:\n            cls._set_cmd_logger()\n        coreStr = \",\".join(cores)\n        cls.__cmd_logger.info('\"{}\",\"{}\",\"{}\",\"{}\"'.format(sysUptime, cmdNum, cmdLine, coreStr))\n\n    @classmethod\n    def results(\n        cls,\n        cmdNum,\n        cmdLine,\n        cores,\n        isACF,\n        acfFailingcores,\n        isMCE,\n        sysUptime=\"\",\n        acfDetails=\"\",\n        mceDetails=\"\",\n    ):\n        if not cls.__results_logger:\n            cls._set_results_logger()\n        coreStr = \",\".join(cores)\n        cls.__results_logger.info(\n            '\"{}\",\"{}\",\"{}\",\"{}\",\"{}\",\"{}\",\"{}\",\"{}\",\"{}\"'.format(\n                sysUptime,\n                cmdNum,\n                cmdLine,\n                coreStr,\n                isACF,\n                acfFailingcores,\n                acfDetails,\n                isMCE,\n                mceDetails,\n            )\n        )\n\n    @classmethod\n    def debug(cls, msg):\n        if cls.level >= cls.DEBUG:\n            cls.__logger.debug(msg)\n\n    @classmethod\n    def info(cls, msg):\n        if cls.level >= cls.EXCESS:\n            cls.__logger.info(msg)\n\n    @classmethod\n    def warning(cls, msg):\n        if cls.level >= cls.ALL:\n            cls.__logger.warning(msg)\n\n    @classmethod\n    def error(cls, msg):\n        cls.__logger.error(msg)\n\n    @classmethod\n    def critical(cls, msg):\n        cls.__logger.error(msg)\n\n    @classmethod\n    def set_log_dir(cls, logDir: str):\n        cls.log_dir = logDir\n        cls._check_log_dir()\n\n    @classmethod\n    def _get_debug_file_handler(cls):\n        if cls.level < cls.DEBUG:\n            return logging.NullHandler()\n        else:\n            file_handler = logging.FileHandler(\"{}/debug.log\".format(cls.log_dir))\n            file_handler.setLevel(logging.DEBUG)\n            file_handler.setFormatter(logging.Formatter(\"%(asctime)s - %(levelname)s - %(message)s\"))\n            return file_handler\n\n    @classmethod\n    def _get_stream_handler(cls):\n        handler = logging.StreamHandler()\n        handler.setFormatter(logging.Formatter(\"%(asctime)s - %(levelname)s - %(message)s\"))\n        handler.setLevel(logging.WARNING)\n        return handler\n\n    @classmethod\n    def _get_results_handler(cls):\n        file_handler = logging.FileHandler(\"{}/cmd_results_list.log.csv\".format(cls.log_dir))\n        file_handler.setLevel(logging.INFO)\n        file_handler.setFormatter(logging.Formatter('\"%(asctime)s\",%(message)s'))\n        return file_handler\n\n    @classmethod\n    def _set_results_logger(cls):\n        if cls.__results_logger is None:\n            cls._check_log_dir()\n            cls.__results_logger = logging.getLogger(__name__ + \"results\")\n            cls.__results_logger.setLevel(logging.INFO)\n            cls.__results_logger.addHandler(cls._get_results_handler())\n            cls.__results_logger.info(\n                \"System Uptime,Command Number,Command Line,Cores Ran,ACF,ACF Failing Cores,ACF Details,MCE,MCE Failing\"\n                \" Cores,MCE Details\"\n            )\n\n    @classmethod\n    def _get_cmd_handler(cls):\n        file_handler = RotatingFileHandler(\"{}/cur_cmd\".format(cls.log_dir), mode=\"w\", maxBytes=10, backupCount=1)\n        file_handler.setLevel(logging.INFO)\n        file_handler.setFormatter(logging.Formatter(\"%(asctime)s,%(message)s\"))\n        return file_handler\n\n    @classmethod\n    def _set_cmd_logger(cls):\n        if cls.__cmd_logger is None:\n            cls._check_log_dir()\n            cls.__cmd_logger = logging.getLogger(__name__ + \"cmd\")\n            cls.__cmd_logger.setLevel(logging.INFO)\n            cls.__cmd_logger.addHandler(cls._get_cmd_handler())\n            cls.__cmd_logger.info(\"System Uptime,Command Number,Command Line,Cores\")", ""]}
{"filename": "mce_read/MsrRegister.py", "chunked_list": ["# Copyright (C) 2023 Advanced Micro Devices, Inc\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n# documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the\n# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\n# Software.\n#", "# Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n# WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE X\n# CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n#\n# Except as contained in this notice, the name of Advanced Micro Devices, Inc shall not be used in advertising or\n# otherwise to promote the sale, use or other dealings in this Software without prior written authorization from\n# Advanced Micro Devices, Inc.", "# otherwise to promote the sale, use or other dealings in this Software without prior written authorization from\n# Advanced Micro Devices, Inc.\n#\n#\n# Disclaimer\n# The information presented in this document is for informational purposes only and may contain technical inaccuracies,\n# omissions, and typographical errors. The information contained herein is subject to change and may be rendered\n# inaccurate for many reasons, including but not limited to product and roadmap changes, component and motherboard\n# version changes, new model and/or product releases, product differences between differing manufacturers, software\n# changes, BIOS flashes, firmware upgrades, or the like. Any computer system has risks of security vulnerabilities that", "# version changes, new model and/or product releases, product differences between differing manufacturers, software\n# changes, BIOS flashes, firmware upgrades, or the like. Any computer system has risks of security vulnerabilities that\n# cannot be completely prevented or mitigated. AMD assumes no obligation to update or otherwise correct or revise this\n# information. However, AMD reserves the right to revise this information and to make changes from time to time to the\n# content hereof without obligation of AMD to notify any person of such revisions or changes.\n#     THIS INFORMATION IS PROVIDED \u2018AS IS.\u201d AMD MAKES NO REPRESENTATIONS OR WARRANTIES WITH RESPECT TO THE CONTENTS\n# HEREOF AND ASSUMES NO RESPONSIBILITY FOR ANY INACCURACIES, ERRORS, OR OMISSIONS THAT MAY APPEAR IN THIS INFORMATION.\n# AMD SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR ANY PARTICULAR\n# PURPOSE. IN NO EVENT WILL AMD BE LIABLE TO ANY PERSON FOR ANY RELIANCE, DIRECT, INDIRECT, SPECIAL, OR OTHER\n# CONSEQUENTIAL DAMAGES ARISING FROM THE USE OF ANY INFORMATION CONTAINED HEREIN, EVEN IF AMD IS EXPRESSLY ADVISED OF", "# PURPOSE. IN NO EVENT WILL AMD BE LIABLE TO ANY PERSON FOR ANY RELIANCE, DIRECT, INDIRECT, SPECIAL, OR OTHER\n# CONSEQUENTIAL DAMAGES ARISING FROM THE USE OF ANY INFORMATION CONTAINED HEREIN, EVEN IF AMD IS EXPRESSLY ADVISED OF\n# THE POSSIBILITY OF SUCH DAMAGES.\n# AMD, the AMD Arrow logo, Open Field Health Check (OFHC) and combinations thereof are trademarks of Advanced Micro\n# Devices, Inc. Other product names used in this publication are for identification purposes only and may be\n# trademarks of their respective companies.\n# \u00a9 2023 Advanced Micro Devices, Inc. All rights reserved.\n\nimport os\nfrom ctypes import c_uint32, c_uint64, sizeof", "import os\nfrom ctypes import c_uint32, c_uint64, sizeof\n\nfrom logger import logger\n\n\nclass PerCoreMSRRegister:\n    def __init__(self, core_id):\n        self.core_id = core_id\n        msrFilename = \"/dev/cpu/{}/msr\".format(self.core_id)\n        try:\n            self._fd = os.open(msrFilename, (os.O_RDWR))\n        except OSError as ex:\n            raise RuntimeError(\"Failed to open MSR File for core {}. Message: {}\".format(self.core_id, ex))\n\n    def __del__(self):\n        # close FD\n        try:\n            os.close(self._fd)\n        except AttributeError:\n            logger.warning(\n                \"Failed to close msr read/write file descriptors. Could be a result of failing to open File.\"\n            )\n\n    def getCoreId(self):\n        return self.core_id\n\n    def read(self, reg: c_uint32):\n        if self._fd < 0:\n            raise RuntimeError(\"MSR Regsiter: Does not have MSR file handle for cpu: {}.\".format(self.core_id))\n        try:\n            data = os.pread(self._fd, sizeof(c_uint64), reg.value)\n        except OSError as e:\n            raise RuntimeError(\n                \"MSR Regsiter: Does not have MSR file handle for cpu: {}. Message: {}\".format(self.core_id, e)\n            )\n        return data\n\n    def write(self, reg: c_uint32, data: c_uint64):\n        raise NotImplementedError(\"Write MSR Registers has not been successfully implemented\")\n        if self._fd < 0:\n            raise RuntimeError(\"MSR Regsiter: Does not have MSR file handle for cpu: {}.\".format(self.core_id))\n\n        dataByteString = data.value.to_bytes(sizeof(data), \"little\")\n        try:\n            data = os.pwrite(self._fd, dataByteString, reg.value)\n        except OSError as e:\n            raise RuntimeError(\n                \"MSR Regsiter: Does not have MSR file handle for cpu: {}. Message: {}\".format(self.core_id, e)\n            )", "\n\nclass MSRRegister:\n    def __init__(self, num_logical_cores):\n        self.perCoreMsrRegister = [PerCoreMSRRegister(c) for c in range(num_logical_cores)]\n\n    def read(self, reg: c_uint32, cpu: int):\n        if cpu > len(self.perCoreMsrRegister):\n            raise RuntimeError(\n                \"Invalid core id: {}. Only {} logical cores are present\".format(cpu, len(self.perCoreMsrRegister))\n            )\n        return int.from_bytes(self.perCoreMsrRegister[cpu].read(reg), \"little\")\n\n    def write(self, reg: c_uint32, data: c_uint64, cpu: int):\n        if cpu > len(self.perCoreMsrRegister):\n            raise RuntimeError(\n                \"Invalid core id: {}. Only {} logical cores are present\".format(cpu, len(self.perCoreMsrRegister))\n            )\n        return self.perCoreMsrRegister[cpu].write(reg, data)", ""]}
{"filename": "mce_read/MceCheck.py", "chunked_list": ["# MIT License\n \n# Copyright (c) 2023 Advanced Micro Devices, Inc.\n \n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:", "# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n \n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n \n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER", "# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\n\n\n\nfrom ctypes import Structure, Union, c_uint, c_uint32, c_uint64", "\nfrom ctypes import Structure, Union, c_uint, c_uint32, c_uint64\n\nfrom mce_read.MsrRegister import MSRRegister\nfrom system_config.cpuinfo import CpuInfo, GetSocketId\n\n\nclass GMCC_Data(Structure):\n    _fields_ = [\n        (\"count\", c_uint32, 8),\n        (\"McgCtlP\", c_uint32, 1),\n        (\"reserved\", c_uint64, 55),\n    ]", "\n\nclass GMCC_RegisterData(Union):\n    _fields_ = [\n        (\"data\", GMCC_Data),\n        (\"raw\", c_uint64),\n    ]\n\n\nclass MSR_0179_GlobalMachineCheckCapabilities:\n    def __init__(self):\n        self.MSR_MCG_CAP = c_uint(0x179)\n        self._register = GMCC_RegisterData()\n\n    def read(self, msr: MSRRegister, core_id: int):\n        self._register.raw = msr.read(self.MSR_MCG_CAP, core_id)\n\n    def getRegister(self):\n        return self._register.data", "\nclass MSR_0179_GlobalMachineCheckCapabilities:\n    def __init__(self):\n        self.MSR_MCG_CAP = c_uint(0x179)\n        self._register = GMCC_RegisterData()\n\n    def read(self, msr: MSRRegister, core_id: int):\n        self._register.raw = msr.read(self.MSR_MCG_CAP, core_id)\n\n    def getRegister(self):\n        return self._register.data", "\n\nclass GMCS_Data(Structure):\n    _fields_ = [\n        (\"ripv\", c_uint32, 1),\n        (\"eipv\", c_uint32, 1),\n        (\"mcip\", c_uint32, 1),\n        (\"reserved\", c_uint64, 61),\n    ]\n", "\n\nclass GMCS_Register(Union):\n    _fields_ = [\n        (\"data\", GMCS_Data),\n        (\"raw\", c_uint64),\n    ]\n\n\nclass MSR_017A_GlobalMachineCheckStatus:\n    def __init__(self):\n        self.MSR_MCG_CTL = c_uint(0x17A)\n        self._register = GMCS_Register()\n\n    def read(self, msr: MSRRegister, core_id):\n        self._register.raw = msr.read(self.MSR_MCG_CTL, core_id)\n\n    def getRegister(self):\n        return self._register.data", "\nclass MSR_017A_GlobalMachineCheckStatus:\n    def __init__(self):\n        self.MSR_MCG_CTL = c_uint(0x17A)\n        self._register = GMCS_Register()\n\n    def read(self, msr: MSRRegister, core_id):\n        self._register.raw = msr.read(self.MSR_MCG_CTL, core_id)\n\n    def getRegister(self):\n        return self._register.data", "\n\nclass GMCERC_Data(Structure):\n    _fields_ = [\n        (\"mc_n_en_core\", c_uint32, 7),\n        (\"mc_n_en\", c_uint64, 57),\n    ]\n\n\nclass GMCERC_Register(Union):\n    _fields_ = [\n        (\"data\", GMCERC_Data),\n        (\"raw\", c_uint64),\n    ]", "\nclass GMCERC_Register(Union):\n    _fields_ = [\n        (\"data\", GMCERC_Data),\n        (\"raw\", c_uint64),\n    ]\n\n\nclass MSR_017B_GlobalMachineCheckExceptionReportingControl:\n    def __init__(self):\n        self.MSR_MCG_CTL = 0x17B\n        self._register = GMCERC_Register(self.Data())\n\n    def read(self, msr: MSRRegister, core_id):\n        self._register.raw = msr.read(self.MSR_MCG_CTL, core_id)\n\n    def write(self, msr: MSRRegister, data: GMCERC_Data, core_id: int):\n        self._register = data\n        msr.write(self.MSR_MCG_CTL, self._regiser.raw, data, core_id)", "class MSR_017B_GlobalMachineCheckExceptionReportingControl:\n    def __init__(self):\n        self.MSR_MCG_CTL = 0x17B\n        self._register = GMCERC_Register(self.Data())\n\n    def read(self, msr: MSRRegister, core_id):\n        self._register.raw = msr.read(self.MSR_MCG_CTL, core_id)\n\n    def write(self, msr: MSRRegister, data: GMCERC_Data, core_id: int):\n        self._register = data\n        msr.write(self.MSR_MCG_CTL, self._regiser.raw, data, core_id)", "\n\nclass MCAStatusData(Structure):\n    _fields_ = [\n        (\"error_code\", c_uint32, 16),  # bit 0 - 15\n        (\"error_code_ext\", c_uint32, 6),  # bit 16-21\n        (\"reserv22\", c_uint32, 2),  # bit 22-23\n        (\"addr_lsb\", c_uint32, 6),  # bit 24-29\n        (\"reserv30\", c_uint32, 2),  # bit 30-31\n        (\"error_code_id\", c_uint32, 6),  # bit 32-37\n        (\"reserv38\", c_uint32, 2),  # bit 38-39\n        (\"scrub\", c_uint32, 1),  # bit 40\n        (\"reserv41\", c_uint32, 2),  # bit 41-42\n        (\"poison\", c_uint32, 1),  # bit 43\n        (\"deferred\", c_uint32, 1),  # bit 44\n        (\"uecc\", c_uint32, 1),  # bit 45\n        (\"cecc\", c_uint32, 1),  # bit 46\n        (\"reserv47\", c_uint32, 5),  # bit 47-51\n        (\"transparent\", c_uint32, 1),  # bit 52\n        (\"syndv\", c_uint32, 1),  # bit 53\n        (\"reserv54\", c_uint32, 1),  # bit 54\n        (\"tcc\", c_uint32, 1),  # bit 56\n        (\"err_core_id_val\", c_uint32, 1),  # bit 56\n        (\"pcc\", c_uint32, 1),  # bit 57\n        (\"addrv\", c_uint32, 1),  # bit 58\n        (\"miscv\", c_uint32, 1),  # bit 59\n        (\"en\", c_uint32, 1),  # bit 60\n        (\"uc\", c_uint32, 1),  # bit 61\n        (\"overflow\", c_uint32, 1),  # bit 62\n        (\"val\", c_uint32, 1),  # bit 63\n    ]", "\n\nclass MCAStatusRegister(Union):\n    _fields_ = [(\"raw\", c_uint64), (\"data\", MCAStatusData)]\n\n    def __str__(self):\n        (\n            \"error_code: {}; \"\n            + \"error_code_ext: {}; \"\n            + \"addr_lsb: {}; \"\n            + \"err_code_id: {}; \"\n            + \"reserv38: {}; \"\n            + \"scrub: {}; \"\n            + \"poison: {}; \"\n            + \"deferred: {}; \"\n            + \"uecc: {}; \"\n            + \"cecc: {}; \"\n            + \"transparent: {}; \"\n            + \"syndv: {}; \"\n            + \"tcc: {}; \"\n            + \"err_core_id_val: {}; \"\n            + \"pcc: {}; \"\n            + \"addrv: {}; \"\n            + \"miscv: {}; \"\n            + \"en: {}; \"\n            + \"uc: {}; \"\n            + \"overflow: {}; \"\n            + \"val: {}; \"\n        ).format(\n            self.data.error_code,\n            self.data.error_code_ext,\n            self.data.addr_lsb,\n            self.data.error_code_id,\n            self.data.reserv38,\n            self.data.scrub,\n            self.data.poison,\n            self.data.deferred,\n            self.data.uecc,\n            self.data.cecc,\n            self.data.transparent,\n            self.data.syndv,\n            self.data.tcc,\n            self.data.err_core_id_val,\n            self.data.pcc,\n            self.data.addrv,\n            self.data.miscv,\n            self.data.en,\n            self.data.uc,\n            self.data.overflow,\n            self.data.val,\n        )", "\n\nclass MCAAddressData(Structure):\n    _fields_ = [\n        (\"error_addr\", c_uint64, 57),  # bit 0-56\n        (\"reserved\", c_uint32, 7),  # bit 57-63\n    ]\n\n\nclass MCAAddressRegister(Union):\n    _fields_ = [\n        (\"raw\", c_uint64),\n        (\"data\", MCAAddressData),\n    ]", "\nclass MCAAddressRegister(Union):\n    _fields_ = [\n        (\"raw\", c_uint64),\n        (\"data\", MCAAddressData),\n    ]\n\n\nclass MCADestat(Structure):\n    _fields_ = [\n        (\"error_code\", c_uint32, 16),  # bit 0-15\n        (\"error_code_ext\", c_uint32, 6),  # bit 16-21\n        (\"reserv0\", c_uint32, 2),  # bit 22-23\n        (\"addr_lsb\", c_uint32, 6),  # bit 24-29\n        (\"reserv1\", c_uint32, 14),  # bit 30-43\n        (\"deferred\", c_uint32, 1),  # bit 44\n        (\"reserv2\", c_uint32, 8),  # bit 45-52\n        (\"syndv\", c_uint32, 1),  # bit 53\n        (\"reserv3\", c_uint32, 4),  # bit 54-57\n        (\"addrv\", c_uint32, 1),  # bit 58\n        (\"reserv4\", c_uint32, 3),  # bit 59-61\n        (\"overflow\", c_uint32, 1),  # bit 62\n        (\"val\", c_uint32, 1),  # bit 63\n    ]", "class MCADestat(Structure):\n    _fields_ = [\n        (\"error_code\", c_uint32, 16),  # bit 0-15\n        (\"error_code_ext\", c_uint32, 6),  # bit 16-21\n        (\"reserv0\", c_uint32, 2),  # bit 22-23\n        (\"addr_lsb\", c_uint32, 6),  # bit 24-29\n        (\"reserv1\", c_uint32, 14),  # bit 30-43\n        (\"deferred\", c_uint32, 1),  # bit 44\n        (\"reserv2\", c_uint32, 8),  # bit 45-52\n        (\"syndv\", c_uint32, 1),  # bit 53\n        (\"reserv3\", c_uint32, 4),  # bit 54-57\n        (\"addrv\", c_uint32, 1),  # bit 58\n        (\"reserv4\", c_uint32, 3),  # bit 59-61\n        (\"overflow\", c_uint32, 1),  # bit 62\n        (\"val\", c_uint32, 1),  # bit 63\n    ]", "\n\nclass MCADestatRegister(Union):\n    _fields_ = [\n        (\"raw\", c_uint64),\n        (\"data\", MCADestat),\n    ]\n\n\nclass MCADummy(Structure):\n    _fields_ = [(\"data_lo\", c_uint32, 32), (\"data_hi\", c_uint32, 32)]", "\nclass MCADummy(Structure):\n    _fields_ = [(\"data_lo\", c_uint32, 32), (\"data_hi\", c_uint32, 32)]\n\n\nclass MCADummyRegister(Union):\n    _fields_ = [\n        (\"raw\", c_uint64),\n        (\"data\", MCADummy),\n    ]", "\n\nclass MCABank:\n    def __init__(self):\n        self.core_id = 0\n        self.bank_id = 0\n        self.status = MCAStatusRegister()\n        self.address = MCAAddressRegister()\n        self.synd = MCADummyRegister()\n        self.ipid = MCADummyRegister()\n        self.misc0 = MCADummyRegister()\n        self.destat = MCADestatRegister()\n        self.deaddr = MCADummyRegister()\n\n    def __str__(self):\n        if self.status.data.val != 1:\n            return \"\"\n\n        msg = \"MCE DETECTED [{}];\".format(\"UNCORRECTED\" if self.status.data.uc == 1 else \"CORRECTED\")\n        msg += \"CORE: {};\".format(self.core_id)\n        msg += \"SOCKET: {};\".format(GetSocketId(self.core_id))\n        msg += \"BANK: {};\".format(self.bank_id)\n        msg += \"ERROR CODE EXT: {};\".format(self.status.data.error_code_ext)\n        msg += \"STATUS: {};\".format(\"UNCORRECTED\" if self.status.data.uc == 1 else \"CORRECTED\")\n        msg += \"MCA_STATUS: {};\".format(hex(self.status.raw))\n        if self.status.data.addrv:\n            msg += \"MCA_ADDR: {};\".format(hex(self.address.raw))\n        if self.status.data.syndv:\n            msg += \"MCA_SYND: {};\".format(hex(self.synd.raw))\n        msg += \"\" + \"MCA_IPID: {};\".format(hex(self.ipid.raw))\n        if self.status.data.miscv:\n            msg += \"MCA_MISC0: {};\".format(hex(self.misc0.raw))\n        if self.destat.data.val:\n            msg += \"MCA_DESTAT: {};\".format(hex(self.destat.raw))\n            msg += \"MCA_DEADDR: {};\".format(hex(self.deaddr.raw))\n        msg += \"STATUS DECODE: {}\".format(str(self.status.raw))\n        return msg", "\n\nclass MCECheck:\n    def __init__(self, msrReg: MSRRegister):\n        self.msr = msrReg\n\n    def check(self):\n        cpuInfo = CpuInfo()\n        mceBankList = []\n        for core_id in range(cpuInfo.num_logical_cores):\n            # Read Global Machine Check Capabilities of each Core\n            mc_capabilities = MSR_0179_GlobalMachineCheckCapabilities()\n            mc_capabilities.read(self.msr, core_id)\n            mc_cap_data = mc_capabilities.getRegister()\n            if mc_cap_data.count == 0:\n                raise RuntimeError(\"Error: Number of error reporting banks visible to core {} is 0.\".format(core_id))\n\n            class mca_bank_msr_regs(Structure):\n                _fields_ = [\n                    (\"ctl\", c_uint32),\n                    (\"status\", c_uint32),\n                    (\"addr\", c_uint32),\n                    (\"misc0\", c_uint32),\n                    (\"config\", c_uint32),\n                    (\"ipid\", c_uint32),\n                    (\"synd\", c_uint32),\n                    (\"destat\", c_uint32),\n                    (\"deaddr\", c_uint32),\n                ]\n\n                def __init__(self):\n                    ctl = 0xC0002000\n                    status = 0xC0002001\n                    addr = 0xC0002002\n                    misc0 = 0xC0002003\n                    config = 0xC0002004\n                    ipid = 0xC0002005\n                    synd = 0xC0002006\n                    destat = 0xC0002007\n                    deaddr = 0xC0002008\n                    super().__init__(ctl, status, addr, misc0, config, ipid, synd, destat, deaddr)\n\n            reg = mca_bank_msr_regs()\n            for bank_i in range(mc_cap_data.count):\n                mca_bank = MCABank()\n                mca_bank.core_id = core_id\n                mca_bank.bank_id = bank_i\n                mca_bank_status_msr_addr = c_uint(reg.status + bank_i * 16)\n\n                mca_bank.status.raw = 0x0\n                # Step0: Read MCA Status\n                mca_bank.status.raw = self.msr.read(mca_bank_status_msr_addr, core_id)\n\n                if mca_bank.status.data.val == 1:\n                    # Step 1: Check for valid MISC0\n                    if mca_bank.status.data.miscv:\n                        mca_bank_misc0_msr_addr = c_uint32(reg.misc0 + bank_i * 16)\n                        mca_bank.misc0.raw = self.msr.read(mca_bank_misc0_msr_addr, core_id)\n\n                    # Step 2: Check for valid Addr\n                    if mca_bank.status.data.addrv:\n                        mca_bank_addr_msr_addr = c_uint32(reg.addr + bank_i * 16)\n                        mca_bank.address.raw = self.msr.read(mca_bank_addr_msr_addr, core_id)\n\n                    # Step 3: Check for valid Synd\n                    if mca_bank.status.data.syndv:\n                        mca_bank_synd_msr_addr = c_uint32(reg.synd + bank_i * 16)\n                        mca_bank.synd.raw = self.msr.read(mca_bank_synd_msr_addr, core_id)\n\n                    # Step 4: Check for valid Ipid\n                    mca_bank_ipid_msr_addr = c_uint32(reg.ipid + bank_i * 16)\n                    mca_bank.ipid.raw = self.msr.read(mca_bank_ipid_msr_addr, core_id)\n\n                    # Step 5: Check for valid Destat\n                    mca_bank_destat_msr_addr = c_uint32(reg.destat + bank_i * 16)\n                    mca_bank.destat.raw = self.msr.read(mca_bank_destat_msr_addr, core_id)\n\n                    # Step 6: Check for valid Deaddr\n                    mca_bank_deaddr_msr_addr = c_uint32(reg.deaddr + bank_i * 16)\n                    mca_bank.deaddr.raw = self.msr.read(mca_bank_deaddr_msr_addr, core_id)\n                    mceBankList.append(mca_bank)\n        return mceBankList", ""]}
{"filename": "param_factories/__init__.py", "chunked_list": [""]}
{"filename": "param_factories/ParamFactory.py", "chunked_list": ["# MIT License\n \n# Copyright (c) 2023 Advanced Micro Devices, Inc.\n \n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:", "# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n \n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n \n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER", "# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\nfrom param_iterators.BinaryIter import BinaryIter\nfrom param_iterators.ListIter import ListIter\n\n\nclass ParamFactory:\n    \"\"\"Iterates through all parameters specified in the TestConfig\n\n    Protected Attributes:\n        _argIters: Dict of args to iterators\n        _constantArgs: Dict of args to value that don't iterate\n        _triggerIter: iter to\n\n\n    Methods:\n        getNextParams(): iterates the parameters\n        getParams(): Returns the current parameters\n    \"\"\"\n\n    def __init__(self, testConfig):\n        self._argIters = {}\n        self._constantArgs = {}\n        prevIter = []\n        for arg in testConfig.arguments:\n            if not arg.isConstant:\n                if arg.isFlag:\n                    self._argIters[arg.cmdLineOption] = BinaryIter(arg.cmdLineOption, prevIter)\n                else:\n                    self._argIters[arg.cmdLineOption] = ListIter(arg.values, arg.cmdLineOption, prevIter)\n                prevIter = [self._argIters[arg.cmdLineOption]]\n            else:\n                if arg.isFlag:\n                    self._constantArgs[arg.cmdLineOption] = \"\"\n                else:\n                    self._constantArgs[arg.cmdLineOption] = arg.values[0]\n        if prevIter:\n            self._triggerIter = prevIter[0]\n        else:\n            self._triggerIter = ListIter([], \"Test Trigger\")\n\n    def getNextParams(self):\n        \"\"\"Increments the parameters and sets the curParams to the\n        newly updated params\n        \"\"\"\n        self._triggerIter.update()\n\n    def getParams(self):\n        \"\"\"Returns the current set of parameters\"\"\"\n        curArgs = self._constantArgs.copy()\n        for arg, curIter in self._argIters.items():\n            if isinstance(curIter, BinaryIter):\n                if curIter.current():\n                    curArgs[arg] = \"\"\n            else:\n                curArgs[arg] = curIter.current()\n        return curArgs", "\n\nclass ParamFactory:\n    \"\"\"Iterates through all parameters specified in the TestConfig\n\n    Protected Attributes:\n        _argIters: Dict of args to iterators\n        _constantArgs: Dict of args to value that don't iterate\n        _triggerIter: iter to\n\n\n    Methods:\n        getNextParams(): iterates the parameters\n        getParams(): Returns the current parameters\n    \"\"\"\n\n    def __init__(self, testConfig):\n        self._argIters = {}\n        self._constantArgs = {}\n        prevIter = []\n        for arg in testConfig.arguments:\n            if not arg.isConstant:\n                if arg.isFlag:\n                    self._argIters[arg.cmdLineOption] = BinaryIter(arg.cmdLineOption, prevIter)\n                else:\n                    self._argIters[arg.cmdLineOption] = ListIter(arg.values, arg.cmdLineOption, prevIter)\n                prevIter = [self._argIters[arg.cmdLineOption]]\n            else:\n                if arg.isFlag:\n                    self._constantArgs[arg.cmdLineOption] = \"\"\n                else:\n                    self._constantArgs[arg.cmdLineOption] = arg.values[0]\n        if prevIter:\n            self._triggerIter = prevIter[0]\n        else:\n            self._triggerIter = ListIter([], \"Test Trigger\")\n\n    def getNextParams(self):\n        \"\"\"Increments the parameters and sets the curParams to the\n        newly updated params\n        \"\"\"\n        self._triggerIter.update()\n\n    def getParams(self):\n        \"\"\"Returns the current set of parameters\"\"\"\n        curArgs = self._constantArgs.copy()\n        for arg, curIter in self._argIters.items():\n            if isinstance(curIter, BinaryIter):\n                if curIter.current():\n                    curArgs[arg] = \"\"\n            else:\n                curArgs[arg] = curIter.current()\n        return curArgs", ""]}
{"filename": "tests/__init__.py", "chunked_list": [""]}
{"filename": "tests/Test.py", "chunked_list": ["# MIT License\n \n# Copyright (c) 2023 Advanced Micro Devices, Inc.\n \n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:", "# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n \n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n \n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER", "# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\nfrom multiprocessing import Pool\nfrom subprocess import PIPE, Popen\n\nfrom logger import logger", "\nfrom logger import logger\n\n\ndef execTestOnCore(cmdLine, core):\n    \"\"\"Execute Test on one core\n    Top level function for Pickability\n    \"\"\"\n    cmdLine = \"numactl --physcpubind={} {}\".format(core, cmdLine)\n    p = Popen(cmdLine, shell=True, stdout=PIPE, stderr=PIPE)\n    stdout, stderr = p.communicate()\n    return core, stdout.decode(\"utf-8\"), stderr.decode(\"utf-8\"), p.returncode", "\n\nclass Test:\n    \"\"\"Takes care of pretest setup execution of the test, and posttest clean-up and MCE logging\n\n    Protected Attributes:\n        _testNum: int: Test number being executed in La Hacienda run\n        _cmdLine: str: The command line without numactl\n        _cores: list[int]: set of all the cores to execute commandline on\n        _uptime: str: system uptime\n        _checkMCEs: reference to SystemConfig's checkMCE method\n\n    Methods:\n        execute()->bool: returns boolean representing if the test passed.\n            this will run _pretest setup and _posttest teardown. If you extend\n            the test class you can inherit these methods to provide more setup or teardown\n\n    Protected Methods:\n        _buildCmdLine(execLoc, paramDict, coreGroup)->None:\n        _posttest(stdout, stderr, returncode)->bool: Returns if the test passed. Logs the output. Any aditional cleanup\n        _pretest()->None: logs the command line being executed\n        _checkTestResults()->bool:\n    \"\"\"\n\n    def __init__(self, paramDict, execLoc, testNum, coreGroup, checkMCEs):\n        \"\"\"\n        Args:\n            paramDict: A dictionary containing all params and their values\n            execLoc: the location of the executable\n            logHeading: The heading to put into the log file\n            testNumber: The number of the test in the run\n            coreGroup: List of cores to run the test on simultaniously\n        \"\"\"\n        self._testNum = testNum\n        self._cores = coreGroup\n        self._buildCmdLine(execLoc, paramDict)\n        self._uptime = \"\"\n        self._checkMCEs = checkMCEs\n\n    def execute(self):\n        \"\"\"Run pretest setup, executes test, and posttest detection and cleanup\"\"\"\n\n        self._pretest()\n\n        with Pool(len(self._cores)) as pool:\n            res = pool.starmap(execTestOnCore, [(self._cmdLine, str(c)) for c in self._cores])\n\n        return self._posttest(res)\n\n    def _pretest(self):\n        \"\"\"Run any pretest setup and logging\"\"\"\n        if logger.level >= logger.EXCESS:\n            # log cmd number\n            logger.debug(\"Command Number: {}\".format(self._testNum))\n\n            # log time\n            timeCmd = \"cat /proc/uptime\"\n            p = Popen(timeCmd, shell=True, stdout=PIPE, stderr=PIPE)\n            stdout, stderr = p.communicate()\n            output = stdout.decode(\"utf-8\")\n            self._uptime = output.split(\" \")[0]\n        logger.cmd(\n            self._testNum,\n            self._cmdLine,\n            self._cores,\n            self._uptime,\n        )\n\n    def _posttest(self, results):\n        \"\"\"Logs output and any cleanup needed\"\"\"\n        failingACFCores = []\n        acfDetails = []\n        for core, stdout, stderr, returncode in results:\n            logger.debug(\n                \"CMD#: {}, CORE: {}, STDOUT: {}, STDERR: {}, RETURNCODE: {}\".format(\n                    self._testNum, core, stdout, stderr, returncode\n                )\n            )\n            if returncode != 0:\n                details = \"Test number {} on core {} return a non-zero exit code: {}, stdout: {}, stderr: {}\".format(\n                    self._testNum, core, returncode, stdout, stderr\n                )\n                logger.error(details)\n                acfDetails.append(details)\n                failingACFCores.append(core)\n\n        mces = self._checkMCEs()\n\n        isACF = bool(failingACFCores)\n        logger.results(\n            self._testNum,\n            self._cmdLine,\n            self._cores,\n            isACF,\n            failingACFCores,\n            bool(mces),\n            self._uptime,\n            \";\".join(acfDetails),\n            \";;\".join([str(m) for m in mces]),\n        )\n\n        return (not isACF) and (not mces)\n\n    def _buildCmdLine(self, execLoc, params):\n        \"\"\"Is call from the init fuction and sets the command line\n        of this test to the cmdLine variable\n        \"\"\"\n        self._cmdLine = execLoc\n        for arg, value in params.items():\n            self._cmdLine += \" {} {}\".format(arg, value)", ""]}
{"filename": "test_factories/TestFactory.py", "chunked_list": ["# MIT License\n \n# Copyright (c) 2023 Advanced Micro Devices, Inc.\n \n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:", "# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n \n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n \n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER", "# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\nfrom logger import logger\nfrom param_factories.ParamFactory import ParamFactory\nfrom param_iterators.ListIter import ListIter\nfrom tests.Test import Test", "from param_iterators.ListIter import ListIter\nfrom tests.Test import Test\n\n\nclass TestFactory:\n    \"\"\"Keeps track of ochestraiting the order of tests and serving up the next tests with parameters\n\n    Protected Attributes:\n        _testIter: ListIter that keeps track of what test to execute next\n        _testFactoryDict: Tuple of execLocation and ParamIter, keeps track\n            of all the test's ParamIters to iterate through all different\n            parameters of each test\n        _testCounter: int current test number\n        _coreIter: core iterator that give the current core set to run on\n        _checkMCEs: reference to SystemConfig checkMCEs method\n\n    Methods:\n        getNextTest: returns the next test to execute\n\n    \"\"\"\n\n    def __init__(self, sysConfig):\n        \"\"\"inits the test dictionary\n\n        Args:\n            sysConfig: SystemConfig object with tests and configuration\n        \"\"\"\n        self.__initTestDict(sysConfig)\n        self._testCounter = 0\n        self._coreIter = ListIter(items=sysConfig.coreConfig.cores, name=\"DivisionIter\")\n        self._testIter = ListIter(\n            items=list(self._testFactoryDict.keys()), name=\"TestIter\", subscribers=[self._coreIter]\n        )\n        self._checkMCEs = sysConfig.checkMCEs\n\n    def __initTestDict(self, sysConfig):\n        self._testFactoryDict = {}\n        for testConfig in sysConfig.testConfigs:\n            self._testFactoryDict[testConfig.name] = (testConfig.binary, ParamFactory(testConfig))\n        logger.info(\n            \"TestFactoryDict has been initialized with the following tests: {}\".format(self._testFactoryDict.keys())\n        )\n\n    def getNextTest(self):\n        \"\"\"Returns the next test to execute\n\n        Raises:\n            StopIteration: Raises when there are no more test to execute\n            RuntimeError: Raises when a test is not supported\n        \"\"\"\n        self._testCounter += 1\n        useNextParams = False\n        # The first test, we don't need to update the test\n        if self._testCounter != 1:\n            try:\n                self._testIter.update()\n                logger.debug(\"{}: Current test: {}\".format(__name__, self._testIter.current()))\n            except StopIteration:\n                logger.debug(\"{}: Get next parameters\".format(__name__))\n                useNextParams = True\n\n        if useNextParams:\n            self._testIter.resetCount(resetSubs=True)\n            removeTests = []\n            for testName in self._testFactoryDict.keys():\n                try:\n                    self._testFactoryDict[testName][1].getNextParams()\n                except StopIteration:\n                    # Once test is finished iterating over all possible\n                    # commands, remove the test from Test Iter\n                    removeTests.append(testName)\n                    logger.debug(\"{}: Remove test {}\".format(__name__, removeTests))\n\n            if len(removeTests) == len(self._testFactoryDict):\n                raise StopIteration\n\n            if len(removeTests) > 0:\n                for test in removeTests:\n                    del self._testFactoryDict[test]\n                self._testIter = ListIter(\n                    items=list(self._testFactoryDict.keys()),\n                    name=\"Updated TestIter\",\n                    subscribers=self._testIter.subscribers,\n                )\n\n        testExecLoc, curTestFactory = self._testFactoryDict[self._testIter.current()]\n        params = curTestFactory.getParams()\n\n        test = Test(params, testExecLoc, self._testCounter, self._coreIter.current(), self._checkMCEs)\n        return test", ""]}
{"filename": "test_factories/__init__.py", "chunked_list": [""]}
{"filename": "unittests/test_param_factory.py", "chunked_list": ["# MIT License\n \n# Copyright (c) 2023 Advanced Micro Devices, Inc.\n \n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:", "# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n \n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n \n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER", "# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\nfrom unittest import TestCase\nfrom unittest.mock import NonCallableMagicMock\n\nfrom param_factories.ParamFactory import ParamFactory", "\nfrom param_factories.ParamFactory import ParamFactory\nfrom system_config.SystemConfig import TestArgConfig, TestConfig\n\n\nclass TestParamFactory(TestCase):\n    def setUp(self):\n        pass\n\n    def testConstantParam(self):\n        # Setup\n        testConfig = NonCallableMagicMock(spec=TestConfig)\n        constArg = NonCallableMagicMock(spec=TestArgConfig)\n        constArg.isFlag = False\n        constArg.isConstant = True\n        constArg.cmdLineOption = \"-a\"\n        constArg.values = [\"value_a\"]\n        testConfig.arguments = [constArg]\n\n        # Run\n        factory = ParamFactory(testConfig)\n        params = factory.getParams()\n\n        # Test Results\n        self.assertEqual(params, {\"-a\": \"value_a\"})\n        self.assertRaises(StopIteration, factory.getNextParams)\n\n    def testConstantFlagParam(self):\n        # Setup\n        testConfig = NonCallableMagicMock(spec=TestConfig)\n        constFlagArg = NonCallableMagicMock(spec=TestArgConfig)\n        constFlagArg.isFlag = True\n        constFlagArg.isConstant = True\n        constFlagArg.cmdLineOption = \"-b\"\n        testConfig.arguments = [constFlagArg]\n\n        # Run\n        factory = ParamFactory(testConfig)\n        params = factory.getParams()\n\n        # Test Results\n        self.assertEqual(params, {\"-b\": \"\"})\n        self.assertRaises(StopIteration, factory.getNextParams)\n\n    def testFlagParam(self):\n        # Setup\n        testConfig = NonCallableMagicMock(spec=TestConfig)\n        flagArg = NonCallableMagicMock(spec=TestArgConfig)\n        flagArg.isFlag = True\n        flagArg.isConstant = False\n        flagArg.cmdLineOption = \"-b\"\n        testConfig.arguments = [flagArg]\n\n        # Run\n        factory = ParamFactory(testConfig)\n        params = []\n        # True case\n        params.append(factory.getParams())\n        # False case\n        factory.getNextParams()\n        params.append(factory.getParams())\n\n        # Test Results\n        self.assertEqual(params[0], {\"-b\": \"\"})\n        self.assertEqual(params[1], {})\n        self.assertRaises(StopIteration, factory.getNextParams)\n\n    def testListParam(self):\n        # Setup\n        testConfig = NonCallableMagicMock(spec=TestConfig)\n        listArg = NonCallableMagicMock(spec=TestArgConfig)\n        listArg.isFlag = False\n        listArg.isConstant = False\n        listArg.cmdLineOption = \"-a\"\n        listArg.values = [\"val1\", \"val2\", \"val3\"]\n        testConfig.arguments = [listArg]\n\n        # Run\n        factory = ParamFactory(testConfig)\n        params = []\n        # val1\n        params.append(factory.getParams())\n        # val2\n        factory.getNextParams()\n        params.append(factory.getParams())\n        # val3\n        factory.getNextParams()\n        params.append(factory.getParams())\n\n        # Test Results\n        self.assertEqual(params[0], {\"-a\": \"val1\"})\n        self.assertEqual(params[1], {\"-a\": \"val2\"})\n        self.assertEqual(params[2], {\"-a\": \"val3\"})\n        self.assertRaises(StopIteration, factory.getNextParams)\n\n    def testNoParam(self):\n        # Setup\n        testConfig = NonCallableMagicMock(spec=TestConfig)\n        testConfig.arguments = []\n\n        # Run\n        factory = ParamFactory(testConfig)\n        params = factory.getParams()\n\n        # Test Results\n        self.assertEqual(params, {})\n        self.assertRaises(StopIteration, factory.getNextParams)\n\n    def testFlagAndListParams(self):\n        # Setup\n        testConfig = NonCallableMagicMock(spec=TestConfig)\n        # list\n        listArg = NonCallableMagicMock(spec=TestArgConfig)\n        listArg.isFlag = False\n        listArg.isConstant = False\n        listArg.cmdLineOption = \"-a\"\n        listArg.values = [\"val1\", \"val2\", \"val3\"]\n\n        # flag\n        flagArg = NonCallableMagicMock(spec=TestArgConfig)\n        flagArg.isFlag = True\n        flagArg.isConstant = False\n        flagArg.cmdLineOption = \"-b\"\n\n        testConfig.arguments = [listArg, flagArg]\n\n        # Run\n        factory = ParamFactory(testConfig)\n        params = []\n        # val1\n        params.append(factory.getParams())\n        # val2\n        factory.getNextParams()\n        params.append(factory.getParams())\n        # val3\n        factory.getNextParams()\n        params.append(factory.getParams())\n        # val4\n        factory.getNextParams()\n        params.append(factory.getParams())\n        # val5\n        factory.getNextParams()\n        params.append(factory.getParams())\n        # val6\n        factory.getNextParams()\n        params.append(factory.getParams())\n\n        # Test Results\n        self.assertEqual(params[0], {\"-a\": \"val1\", \"-b\": \"\"})\n        self.assertEqual(params[1], {\"-a\": \"val1\"})\n        self.assertEqual(params[2], {\"-a\": \"val2\", \"-b\": \"\"})\n        self.assertEqual(params[3], {\"-a\": \"val2\"})\n        self.assertEqual(params[4], {\"-a\": \"val3\", \"-b\": \"\"})\n        self.assertEqual(params[5], {\"-a\": \"val3\"})\n        self.assertRaises(StopIteration, factory.getNextParams)\n\n    def testConstantFlagAndListParams(self):\n        # Setup\n        testConfig = NonCallableMagicMock(spec=TestConfig)\n        # list\n        listArg = NonCallableMagicMock(spec=TestArgConfig)\n        listArg.isFlag = False\n        listArg.isConstant = False\n        listArg.cmdLineOption = \"-a\"\n        listArg.values = [\"val1\", \"val2\", \"val3\"]\n\n        # flag\n        flagArg = NonCallableMagicMock(spec=TestArgConfig)\n        flagArg.isFlag = True\n        flagArg.isConstant = True\n        flagArg.cmdLineOption = \"-b\"\n\n        testConfig.arguments = [listArg, flagArg]\n\n        # Run\n        factory = ParamFactory(testConfig)\n        params = []\n        # val1\n        params.append(factory.getParams())\n        # val2\n        factory.getNextParams()\n        params.append(factory.getParams())\n        # val3\n        factory.getNextParams()\n        params.append(factory.getParams())\n\n        # Test Results\n        self.assertEqual(params[0], {\"-a\": \"val1\", \"-b\": \"\"})\n        self.assertEqual(params[1], {\"-a\": \"val2\", \"-b\": \"\"})\n        self.assertEqual(params[2], {\"-a\": \"val3\", \"-b\": \"\"})\n        self.assertRaises(StopIteration, factory.getNextParams)\n\n    def testThreeListParams(self):\n        # Setup\n        testConfig = NonCallableMagicMock(spec=TestConfig)\n        # list 1\n        listArg1 = NonCallableMagicMock(spec=TestArgConfig)\n        listArg1.isFlag = False\n        listArg1.isConstant = False\n        listArg1.cmdLineOption = \"-a\"\n        listArg1.values = [\"val1\", \"val2\"]\n        # list 2\n        listArg2 = NonCallableMagicMock(spec=TestArgConfig)\n        listArg2.isFlag = False\n        listArg2.isConstant = False\n        listArg2.cmdLineOption = \"-b\"\n        listArg2.values = [\"val3\", \"val4\"]\n        # list 3\n        listArg3 = NonCallableMagicMock(spec=TestArgConfig)\n        listArg3.isFlag = False\n        listArg3.isConstant = False\n        listArg3.cmdLineOption = \"--last\"\n        listArg3.values = [\"val5\", \"val6\"]\n\n        testConfig.arguments = [listArg1, listArg2, listArg3]\n\n        # Run\n        factory = ParamFactory(testConfig)\n        params = []\n        # val1\n        params.append(factory.getParams())\n        # val2\n        factory.getNextParams()\n        params.append(factory.getParams())\n        # val3\n        factory.getNextParams()\n        params.append(factory.getParams())\n        # val4\n        factory.getNextParams()\n        params.append(factory.getParams())\n        # val5\n        factory.getNextParams()\n        params.append(factory.getParams())\n        # val6\n        factory.getNextParams()\n        params.append(factory.getParams())\n        # val7\n        factory.getNextParams()\n        params.append(factory.getParams())\n        # val8\n        factory.getNextParams()\n        params.append(factory.getParams())\n\n        # Test Results\n        self.assertEqual(params[0], {\"-a\": \"val1\", \"-b\": \"val3\", \"--last\": \"val5\"})\n        self.assertEqual(params[1], {\"-a\": \"val1\", \"-b\": \"val3\", \"--last\": \"val6\"})\n        self.assertEqual(params[2], {\"-a\": \"val1\", \"-b\": \"val4\", \"--last\": \"val5\"})\n        self.assertEqual(params[3], {\"-a\": \"val1\", \"-b\": \"val4\", \"--last\": \"val6\"})\n        self.assertEqual(params[4], {\"-a\": \"val2\", \"-b\": \"val3\", \"--last\": \"val5\"})\n        self.assertEqual(params[5], {\"-a\": \"val2\", \"-b\": \"val3\", \"--last\": \"val6\"})\n        self.assertEqual(params[6], {\"-a\": \"val2\", \"-b\": \"val4\", \"--last\": \"val5\"})\n        self.assertEqual(params[7], {\"-a\": \"val2\", \"-b\": \"val4\", \"--last\": \"val6\"})\n        self.assertRaises(StopIteration, factory.getNextParams)", ""]}
{"filename": "unittests/test_testexec.py", "chunked_list": ["# MIT License\n \n# Copyright (c) 2023 Advanced Micro Devices, Inc.\n \n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:", "# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n \n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n \n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER", "# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\nimport unittest\nfrom subprocess import PIPE\nfrom unittest.mock import MagicMock, call, patch\n", "from unittest.mock import MagicMock, call, patch\n\nfrom tests.Test import Test\n\n\n@patch(\"tests.Test.Popen\", autospec=True)\n@patch(\"tests.Test.logger\", autospec=True)\nclass TestTestExecution(unittest.TestCase):\n    def setUp(self):\n        # Setup test parameters\n        params = {\n            \"-a\": \"\",\n            \"-b\": \"value1\",\n        }\n        execLoc = \"/path/to/exec\"\n        testNum = 19\n\n        cores = [x for x in range(6)]\n\n        self.checkMCEMock = MagicMock()\n        self.checkMCEMock.return_value = []\n        # Run item under test\n        self.test = Test(params, execLoc, testNum, cores, self.checkMCEMock)\n\n    def _getACFDetailString(self, core):\n        return (\n            \"Test number {} on core {} return a non-zero exit code: 1, stdout: Failure occurred, stderr: This is the\"\n            \" failure details\".format(self.test._testNum, core)\n        )\n\n    def _getACFTuple(self, core):\n        return (core, \"Failure occurred\", \"This is the failure details\", 1)\n\n    def testCmdLineBuilding(self, poolMock, loggerMock):\n        # Test results\n        self.assertEqual(self.test._cmdLine, \"/path/to/exec -a  -b value1\")\n\n    @patch(\"tests.Test.Pool\", autospec=True)\n    def testCmdExecZeroExit(self, poolMock, loggerMock, popenMock):\n        # Setup\n        poolMock.return_value.__enter__.return_value.starmap.return_value = [\n            (core, \"\", \"\", 0) for core in self.test._cores\n        ]\n        popenMock.return_value.communicate.return_value = (b\"\", b\"\")\n        popenMock.return_value.returncode = 0\n        loggerMock.level.__ge__.return_value = True\n\n        # Run\n        testPassed = self.test.execute()\n\n        # Check Results\n        self.assertTrue(testPassed)\n\n    @patch(\"tests.Test.Pool\", autospec=True)\n    def testCmdExecNonZeroExit(self, poolMock, loggerMock, popenMock):\n        # Setup\n        poolMock.return_value.__enter__.return_value.starmap.return_value = [\n            (core, \"\", \"\", 0) if core != 2 else self._getACFTuple(core) for core in self.test._cores\n        ]\n        popenMock.return_value.communicate.return_value = (b\"\", b\"\")\n        popenMock.return_value.returncode = 0\n        loggerMock.level.__ge__.return_value = True\n\n        # Run\n        testPassed = self.test.execute()\n\n        # Check Results\n        self.assertFalse(testPassed)\n        loggerMock.results.assert_called_with(\n            self.test._testNum,\n            self.test._cmdLine,\n            self.test._cores,\n            True,\n            [2],\n            False,\n            self.test._uptime,\n            self._getACFDetailString(2),\n            \"\",\n        )\n\n    @patch(\"tests.Test.Pool\", autospec=True)\n    def testTestResultsPass64Core(self, poolMock, loggerMock, popenMock):\n        self.test._cores = [i for i in range(64)]\n        poolMock.return_value.__enter__.return_value.starmap.return_value = [\n            (core, \"\", \"\", 0) for core in self.test._cores\n        ]\n        popenMock.return_value.communicate.return_value = (b\"\", b\"\")\n        popenMock.return_value.returncode = 0\n        loggerMock.level.__ge__.return_value = True\n\n        # Run\n        testPassed = self.test.execute()\n\n        # Check Results\n        self.assertTrue(testPassed)\n\n    @patch(\"tests.Test.Pool\", autospec=True)\n    def testTestResultsPass1Core(self, poolMock, loggerMock, popenMock):\n        # Setup\n        self.test._cores = [i for i in range(1)]\n        poolMock.return_value.__enter__.return_value.starmap.return_value = [\n            (core, \"\", \"\", 0) for core in self.test._cores\n        ]\n        popenMock.return_value.communicate.return_value = (b\"\", b\"\")\n        popenMock.return_value.returncode = 0\n        loggerMock.level.__ge__.return_value = True\n\n        # Run\n        testPassed = self.test.execute()\n\n        # Check Results\n        self.assertTrue(testPassed)\n\n    # ACF Fails\n    @patch(\"tests.Test.Pool\", autospec=True)\n    def testTestResultsACF64Core(self, poolMock, loggerMock, popenMock):\n        # Setup\n        self.test._cores = [i for i in range(64)]\n        poolMock.return_value.__enter__.return_value.starmap.return_value = [\n            (core, \"\", \"\", 0) if core != 33 else self._getACFTuple(core) for core in self.test._cores\n        ]\n        popenMock.return_value.communicate.return_value = (b\"\", b\"\")\n        popenMock.return_value.returncode = 0\n\n        loggerMock.level.__ge__.return_value = True\n\n        # Run\n        testPassed = self.test.execute()\n\n        # Check Results\n        self.assertFalse(testPassed)\n        loggerMock.results.assert_called_with(\n            self.test._testNum,\n            self.test._cmdLine,\n            self.test._cores,\n            True,\n            [33],\n            False,\n            self.test._uptime,\n            self._getACFDetailString(33),\n            \"\",\n        )\n\n    @patch(\"tests.Test.Pool\", autospec=True)\n    def testTestResultsACF1Core(self, poolMock, loggerMock, popenMock):\n        self.test._cores = [\"0\"]\n        poolMock.return_value.__enter__.return_value.starmap.return_value = [self._getACFTuple(0)]\n        popenMock.return_value.communicate.return_value = (b\"\", b\"\")\n        popenMock.return_value.returncode = 0\n        loggerMock.level.__ge__.return_value = False\n\n        # Run\n        testPassed = self.test.execute()\n\n        # Check Results\n        self.assertFalse(testPassed)\n        loggerMock.results.assert_called_with(\n            self.test._testNum,\n            self.test._cmdLine,\n            self.test._cores,\n            True,\n            [0],\n            False,\n            self.test._uptime,\n            self._getACFDetailString(0),\n            \"\",\n        )\n\n    # MCE Fails\n    @patch(\"tests.Test.Pool\", autospec=True)\n    def testTestResultsMCE64Core(self, poolMock, loggerMock, popenMock):\n        # Setup\n        self.test._cores = [i for i in range(64)]\n        poolMock.return_value.__enter__.return_value.starmap.return_value = [\n            (core, \"\", \"\", 0) for core in self.test._cores\n        ]\n        popenMock.return_value.communicate.return_value = (b\"\", b\"\")\n        popenMock.return_value.returncode = 0\n\n        loggerMock.level.__ge__.return_value = True\n\n        self.checkMCEMock.return_value = [\"This is MCE\"]\n\n        # Run\n        testPassed = self.test.execute()\n\n        # Check Results\n        self.assertFalse(testPassed)\n        loggerMock.results.assert_called_with(\n            self.test._testNum,\n            self.test._cmdLine,\n            self.test._cores,\n            False,\n            [],\n            True,\n            self.test._uptime,\n            \"\",\n            \"This is MCE\",\n        )\n\n    @patch(\"tests.Test.Pool\", autospec=True)\n    def testTestResultsMCE1Core(self, poolMock, loggerMock, popenMock):\n        self.test._cores = [\"0\"]\n        poolMock.return_value.__enter__.return_value.starmap.return_value = [(0, \"\", \"\", 0)]\n        popenMock.return_value.communicate.return_value = (b\"\", b\"\")\n        popenMock.return_value.returncode = 0\n        loggerMock.level.__ge__.return_value = False\n\n        self.checkMCEMock.return_value = [\"This is MCE\"]\n        # Run\n        testPassed = self.test.execute()\n\n        # Check Results\n        self.assertFalse(testPassed)\n        loggerMock.results.assert_called_with(\n            self.test._testNum,\n            self.test._cmdLine,\n            self.test._cores,\n            False,\n            [],\n            True,\n            self.test._uptime,\n            \"\",\n            \"This is MCE\",\n        )\n\n    # More than one MCE\n    @patch(\"tests.Test.Pool\", autospec=True)\n    def testTestResults2MCEs1Core(self, poolMock, loggerMock, popenMock):\n        self.test._cores = [\"0\"]\n        poolMock.return_value.__enter__.return_value.starmap.return_value = [(0, \"\", \"\", 0)]\n        popenMock.return_value.communicate.return_value = (b\"\", b\"\")\n        popenMock.return_value.returncode = 0\n        loggerMock.level.__ge__.return_value = False\n\n        self.checkMCEMock.return_value = [\"This is MCE1\", \"This is MCE2\"]\n        # Run\n        testPassed = self.test.execute()\n\n        # Check Results\n        self.assertFalse(testPassed)\n        loggerMock.results.assert_called_with(\n            self.test._testNum,\n            self.test._cmdLine,\n            self.test._cores,\n            False,\n            [],\n            True,\n            self.test._uptime,\n            \"\",\n            \"This is MCE1;;This is MCE2\",\n        )\n\n    # MCE & ACF\n    @patch(\"tests.Test.Pool\", autospec=True)\n    def testTestResultsMCE_ACF1Core(self, poolMock, loggerMock, popenMock):\n        self.test._cores = [\"0\"]\n        poolMock.return_value.__enter__.return_value.starmap.return_value = [self._getACFTuple(0)]\n        popenMock.return_value.communicate.return_value = (b\"\", b\"\")\n        popenMock.return_value.returncode = 0\n        loggerMock.level.__ge__.return_value = False\n\n        self.checkMCEMock.return_value = [\"This is MCE1\", \"This is MCE2\"]\n        # Run\n        testPassed = self.test.execute()\n\n        # Check Results\n        self.assertFalse(testPassed)\n        loggerMock.results.assert_called_with(\n            self.test._testNum,\n            self.test._cmdLine,\n            self.test._cores,\n            True,\n            [0],\n            True,\n            self.test._uptime,\n            self._getACFDetailString(0),\n            \"This is MCE1;;This is MCE2\",\n        )\n\n    def testCallPopenWithNumactl(self, loggerMock, popenMock):\n        # Setup\n        popenMock.return_value.communicate.return_value = (b\"\", b\"\")\n        popenMock.return_value.returncode = 0\n\n        cmds = [\n            call(\"numactl --physcpubind={} {}\".format(core, self.test._cmdLine), shell=True, stdout=PIPE, stderr=PIPE)\n            for core in self.test._cores\n        ]\n        loggerMock.level.__ge__.return_value = False\n\n        # Run\n\n        from multiprocessing.pool import Pool\n\n        with patch.object(Pool, \"starmap\", new=lambda p, f, args: [f(cmd, core) for cmd, core in args]):\n            self.test.execute()\n\n        # Check Results\n        popenMock.assert_has_calls(cmds, any_order=True)", ""]}
{"filename": "unittests/test_paramiter.py", "chunked_list": ["# MIT License\n \n# Copyright (c) 2023 Advanced Micro Devices, Inc.\n \n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:", "# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n \n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n \n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER", "# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\nfrom unittest import TestCase\nfrom unittest.mock import NonCallableMagicMock\n\nfrom param_iterators.BinaryIter import BinaryIter", "\nfrom param_iterators.BinaryIter import BinaryIter\nfrom param_iterators.ListIter import ListIter\nfrom param_iterators.ParamIter import ParamIter\n\n\nclass TestParamIter(TestCase):\n    def setUp(self):\n        pass\n\n    def testListUpdateIter(self):\n        # Setup\n        vals = [x for x in range(5)]\n        listIter = ListIter(vals, \"testing list iter\")\n\n        # Run\n        # only iterate to n-1 because the update at n will cause StopIteration\n        for expected in vals[:-1]:\n            self.assertEqual(listIter.current(), expected)\n            listIter.update()\n\n        self.assertEqual(listIter.current(), vals[-1])\n        self.assertRaises(StopIteration, listIter.update)\n\n    def testBinaryUpdateIter(self):\n        # Setup\n        binIter = BinaryIter(\"testing bin iter\")\n        # Run\n        results = []\n        results.append(binIter.current())\n        binIter.update()\n        results.append(binIter.current())\n        # Test Results\n        self.assertRaises(StopIteration, binIter.update)\n        self.assertEqual(len(results), 2)\n        self.assertTrue(True in results)\n        self.assertTrue(False in results)\n\n    def testParamIterUpdateWithSubscriber(self):\n        # Setup\n        mockIter = NonCallableMagicMock(spec=ParamIter)\n        paramIter = ListIter([0], \"single param iter\", subscribers=[mockIter])\n\n        # Run\n        paramIter.update()\n\n        # Check Results\n        mockIter.update.assert_called_once()\n\n    def testParamIterResetWithSubscriber(self):\n        # Setup\n        mockIter = NonCallableMagicMock(spec=ParamIter)\n        paramIter = ListIter([0], \"single param iter\", subscribers=[mockIter])\n\n        # Run\n        paramIter.resetCount()\n\n        # Check Results\n        mockIter.resetCount.assert_not_called()\n\n    def testParamIterResetWithSubscriber_resetSubs(self):\n        # Setup\n        mockIter = NonCallableMagicMock(spec=ParamIter)\n        paramIter = ListIter([0], \"single param iter\", subscribers=[mockIter])\n\n        # Run\n        paramIter.resetCount(resetSubs=True)\n\n        # Check Results\n        mockIter.resetCount.assert_called_once()", ""]}
{"filename": "unittests/test_testfactory.py", "chunked_list": ["# MIT License\n \n# Copyright (c) 2023 Advanced Micro Devices, Inc.\n \n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:", "# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n \n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n \n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER", "# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\nfrom unittest import TestCase\nfrom unittest.mock import MagicMock, NonCallableMagicMock, patch\n\nfrom param_factories.ParamFactory import ParamFactory", "\nfrom param_factories.ParamFactory import ParamFactory\nfrom system_config.SystemConfig import CoreConfig, SystemConfig, TestConfig\nfrom test_factories.TestFactory import TestFactory\n\n\n@patch(\"test_factories.TestFactory.ParamFactory\", autospec=True)\n@patch(\"test_factories.TestFactory.Test\", autospec=True)\nclass TestTestFactory(TestCase):\n    def setUp(self):\n        pass\n\n    def testOneTestOneCoreConfig(self, testMock, paramFactoryMock):\n        binaryPath = \"/path/to/test/binary\"\n        testName = \"test1\"\n        # Setup\n        testConfigMock = NonCallableMagicMock(spec=TestConfig)\n        testConfigMock.name = testName\n        testConfigMock.binary = binaryPath\n\n        coreConfigMock = NonCallableMagicMock(spec=CoreConfig)\n        coreConfigMock.cores = [[\"0\"]]\n\n        sysConfigMock = NonCallableMagicMock(spec=[SystemConfig, \"isConstantMceChecking\", \"checkMCEs\"])\n        sysConfigMock.checkMCEs = MagicMock()\n        sysConfigMock.testConfigs = [testConfigMock]\n        sysConfigMock.coreConfig = coreConfigMock\n\n        params = [{\"-a\": \"val1\", \"-b\": \"\"}, {\"-a\": \"va11\"}, {\"-a\": \"val2\", \"-b\": \"\"}, {\"-a\": \"val2\"}]\n\n        paramFactoryInstance = paramFactoryMock.return_value\n        paramFactoryInstance.getParams.side_effect = params\n        paramFactoryInstance.getNextParams.side_effect = [None, None, None, StopIteration]\n\n        # Run\n        testFactory = TestFactory(sysConfigMock)\n\n        # Test\n        testFactory.getNextTest()\n        testMock.assert_called_with(params[0], binaryPath, 1, coreConfigMock.cores[0], sysConfigMock.checkMCEs)\n        testFactory.getNextTest()\n        testMock.assert_called_with(params[1], binaryPath, 2, coreConfigMock.cores[0], sysConfigMock.checkMCEs)\n        testFactory.getNextTest()\n        testMock.assert_called_with(params[2], binaryPath, 3, coreConfigMock.cores[0], sysConfigMock.checkMCEs)\n        testFactory.getNextTest()\n        testMock.assert_called_with(params[3], binaryPath, 4, coreConfigMock.cores[0], sysConfigMock.checkMCEs)\n        self.assertRaises(StopIteration, testFactory.getNextTest)\n\n    def testOneTestMultipleCoreConfigs(self, testMock, paramFactoryMock):\n        binaryPath = \"/path/to/test/binary\"\n        testName = \"test1\"\n        # Setup\n        testConfigMock = NonCallableMagicMock(spec=TestConfig)\n        testConfigMock.name = testName\n        testConfigMock.binary = binaryPath\n\n        coreConfigMock = NonCallableMagicMock(spec=CoreConfig)\n        coreConfigMock.cores = [[str(x)] for x in range(4)]\n\n        sysConfigMock = NonCallableMagicMock(spec=[SystemConfig, \"isConstantMceChecking\", \"checkMCEs\"])\n        sysConfigMock.checkMCEs = MagicMock()\n        sysConfigMock.testConfigs = [testConfigMock]\n        sysConfigMock.coreConfig = coreConfigMock\n\n        params = [{\"-a\": \"val1\", \"-b\": \"\"}, {\"-a\": \"va11\"}, {\"-a\": \"val2\", \"-b\": \"\"}, {\"-a\": \"val2\"}]\n\n        paramFactoryInstance = paramFactoryMock.return_value\n        paramFactoryInstance.getParams.side_effect = params\n        paramFactoryInstance.getNextParams.side_effect = [None if i != 4 else StopIteration for i in range(5)]\n\n        # Run\n        testFactory = TestFactory(sysConfigMock)\n\n        # Test\n        testFactory.getNextTest()\n        testMock.assert_called_with(params[0], binaryPath, 1, coreConfigMock.cores[0], sysConfigMock.checkMCEs)\n        testFactory.getNextTest()\n        testMock.assert_called_with(params[1], binaryPath, 2, coreConfigMock.cores[1], sysConfigMock.checkMCEs)\n        testFactory.getNextTest()\n        testMock.assert_called_with(params[2], binaryPath, 3, coreConfigMock.cores[2], sysConfigMock.checkMCEs)\n        testFactory.getNextTest()\n        testMock.assert_called_with(params[3], binaryPath, 4, coreConfigMock.cores[3], sysConfigMock.checkMCEs)\n        self.assertRaises(StopIteration, testFactory.getNextTest)\n\n    def testTwoTest(self, testMock, paramFactoryMock):\n        binaryPath1 = \"/path/to/test1/binary\"\n        testName1 = \"test1\"\n        binaryPath2 = \"/path/to/test2/binary\"\n        testName2 = \"test2\"\n        # Setup\n        testConfig1 = NonCallableMagicMock(spec=TestConfig)\n        testConfig1.name = testName1\n        testConfig1.binary = binaryPath1\n\n        testConfig2 = NonCallableMagicMock(spec=TestConfig)\n        testConfig2.name = testName2\n        testConfig2.binary = binaryPath2\n\n        coreConfigMock = NonCallableMagicMock(spec=CoreConfig)\n        coreConfigMock.cores = [[0]]\n\n        sysConfigMock = NonCallableMagicMock(spec=[SystemConfig, \"isConstantMceChecking\", \"checkMCEs\"])\n        sysConfigMock.checkMCEs = MagicMock()\n        sysConfigMock.testConfigs = [testConfig1, testConfig2]\n        sysConfigMock.coreConfig = coreConfigMock\n\n        params1 = [{\"-a\": \"val1\", \"-b\": \"\"}, {\"-a\": \"va11\"}, {\"-a\": \"val2\", \"-b\": \"\"}, {\"-a\": \"val2\"}]\n        params2 = [\n            {\"-a\": \"val1a\", \"-b\": \"no\"},\n            {\"-a\": \"va11a\"},\n            {\"-a\": \"val2a\", \"-b\": \"no\"},\n            {\"-a\": \"val2a\"},\n        ]\n        getNextParam1SideEffects = [None, None, None, StopIteration]\n        getNextParam2SideEffects = [None, None, None, StopIteration]\n\n        paramFactoryInstance1 = NonCallableMagicMock(spec=ParamFactory)\n        paramFactoryInstance1.getParams.side_effect = params1\n        paramFactoryInstance1.getNextParams.side_effects = getNextParam1SideEffects\n        paramFactoryInstance2 = NonCallableMagicMock(spec=ParamFactory)\n        paramFactoryInstance2.getParams.side_effect = params2\n        paramFactoryInstance2.getNextParams.side_effects = getNextParam2SideEffects\n        paramFactoryMock.side_effect = [paramFactoryInstance1, paramFactoryInstance2]\n\n        # Run\n        testFactory = TestFactory(sysConfigMock)\n\n        # Test\n        testFactory.getNextTest()\n        testMock.assert_called_with(params1[0], binaryPath1, 1, coreConfigMock.cores[0], sysConfigMock.checkMCEs)\n        testFactory.getNextTest()\n        testMock.assert_called_with(params2[0], binaryPath2, 2, coreConfigMock.cores[0], sysConfigMock.checkMCEs)\n        testFactory.getNextTest()\n        testMock.assert_called_with(params1[1], binaryPath1, 3, coreConfigMock.cores[0], sysConfigMock.checkMCEs)\n        testFactory.getNextTest()\n        testMock.assert_called_with(params2[1], binaryPath2, 4, coreConfigMock.cores[0], sysConfigMock.checkMCEs)\n        testFactory.getNextTest()\n        testMock.assert_called_with(params1[2], binaryPath1, 5, coreConfigMock.cores[0], sysConfigMock.checkMCEs)\n        testFactory.getNextTest()\n        testMock.assert_called_with(params2[2], binaryPath2, 6, coreConfigMock.cores[0], sysConfigMock.checkMCEs)\n        testFactory.getNextTest()\n        testMock.assert_called_with(params1[3], binaryPath1, 7, coreConfigMock.cores[0], sysConfigMock.checkMCEs)\n        testFactory.getNextTest()\n        testMock.assert_called_with(params2[3], binaryPath2, 8, coreConfigMock.cores[0], sysConfigMock.checkMCEs)\n        self.assertRaises(StopIteration, testFactory.getNextTest)\n\n    def testTwoTest_MulitpleCoreConfigs(self, testMock, paramFactoryMock):\n        binaryPath1 = \"/path/to/test1/binary\"\n        testName1 = \"test1\"\n        binaryPath2 = \"/path/to/test2/binary\"\n        testName2 = \"test2\"\n        # Setup\n        testConfig1 = NonCallableMagicMock(spec=TestConfig)\n        testConfig1.name = testName1\n        testConfig1.binary = binaryPath1\n\n        testConfig2 = NonCallableMagicMock(spec=TestConfig)\n        testConfig2.name = testName2\n        testConfig2.binary = binaryPath2\n\n        coreConfigMock = NonCallableMagicMock(spec=CoreConfig)\n        coreConfigMock.cores = [[str(x)] for x in range(4)]\n\n        sysConfigMock = NonCallableMagicMock(spec=[SystemConfig, \"isConstantMceChecking\", \"checkMCEs\"])\n        sysConfigMock.checkMCEs = MagicMock()\n        sysConfigMock.testConfigs = [testConfig1, testConfig2]\n        sysConfigMock.coreConfig = coreConfigMock\n\n        params1 = [{\"-a\": \"val1\", \"-b\": \"\"}, {\"-a\": \"va11\"}, {\"-a\": \"val2\", \"-b\": \"\"}, {\"-a\": \"val2\"}] * 4\n        params2 = [\n            {\"-a\": \"val1a\", \"-b\": \"no\"},\n            {\"-a\": \"va11a\"},\n            {\"-a\": \"val2a\", \"-b\": \"no\"},\n            {\"-a\": \"val2a\"},\n        ] * 4\n        getNextParam1SideEffects = [None if i != 16 else StopIteration for i in range(17)]\n        getNextParam2SideEffects = [None if i != 16 else StopIteration for i in range(17)]\n\n        paramFactoryInstance1 = NonCallableMagicMock(spec=ParamFactory)\n        paramFactoryInstance1.getParams.side_effect = params1\n        paramFactoryInstance1.getNextParams.side_effects = getNextParam1SideEffects\n\n        paramFactoryInstance2 = NonCallableMagicMock(spec=ParamFactory)\n        paramFactoryInstance2.getParams.side_effect = params2\n        paramFactoryInstance2.getNextParams.side_effects = getNextParam2SideEffects\n        paramFactoryMock.side_effect = [paramFactoryInstance1, paramFactoryInstance2]\n\n        # Run\n        testFactory = TestFactory(sysConfigMock)\n\n        # Test\n        for i in range(16):\n            testFactory.getNextTest()\n            testMock.assert_called_with(\n                params1[i], binaryPath1, 2 * i + 1, coreConfigMock.cores[i % 4], sysConfigMock.checkMCEs\n            )\n            testFactory.getNextTest()\n            testMock.assert_called_with(\n                params2[i], binaryPath2, 2 * i + 2, coreConfigMock.cores[i % 4], sysConfigMock.checkMCEs\n            )\n        self.assertRaises(StopIteration, testFactory.getNextTest)\n\n    def testTwoTestDifferentSizesOfParams(self, testMock, paramFactoryMock):\n        binaryPath1 = \"/path/to/test1/binary\"\n        testName1 = \"test1\"\n        binaryPath2 = \"/path/to/test2/binary\"\n        testName2 = \"test2\"\n        # Setup\n        testConfig1 = NonCallableMagicMock(spec=TestConfig)\n        testConfig1.name = testName1\n        testConfig1.binary = binaryPath1\n\n        testConfig2 = NonCallableMagicMock(spec=TestConfig)\n        testConfig2.name = testName2\n        testConfig2.binary = binaryPath2\n\n        coreConfigMock = NonCallableMagicMock(spec=CoreConfig)\n        coreConfigMock.cores = [[\"0\"]]\n\n        sysConfigMock = NonCallableMagicMock(spec=[SystemConfig, \"isConstantMceChecking\", \"checkMCEs\"])\n        sysConfigMock.checkMCEs = MagicMock()\n        sysConfigMock.testConfigs = [testConfig1, testConfig2]\n        sysConfigMock.coreConfig = coreConfigMock\n\n        params1 = [{\"-a\": \"val1\", \"-b\": \"\"}, {\"-a\": \"va11\"}]\n        getNextParam1SideEffects = [None, StopIteration]\n        params2 = [\n            {\"-a\": \"val1a\", \"-b\": \"no\"},\n            {\"-a\": \"va11a\"},\n            {\"-a\": \"val2a\", \"-b\": \"no\"},\n            {\"-a\": \"val2a\"},\n        ]\n        getNextParam2SideEffects = [None, None, None, StopIteration]\n\n        paramFactoryInstance1 = NonCallableMagicMock(spec=ParamFactory)\n        paramFactoryInstance1.getParams.side_effect = params1\n        paramFactoryInstance1.getNextParams.side_effect = getNextParam1SideEffects\n        paramFactoryInstance2 = NonCallableMagicMock(spec=ParamFactory)\n        paramFactoryInstance2.getParams.side_effect = params2\n        paramFactoryInstance2.getNextParams.side_effect = getNextParam2SideEffects\n        paramFactoryMock.side_effect = [paramFactoryInstance1, paramFactoryInstance2]\n\n        # Run\n        testFactory = TestFactory(sysConfigMock)\n\n        # Test\n        testFactory.getNextTest()\n        testMock.assert_called_with(params1[0], binaryPath1, 1, coreConfigMock.cores[0], sysConfigMock.checkMCEs)\n        testFactory.getNextTest()\n        testMock.assert_called_with(params2[0], binaryPath2, 2, coreConfigMock.cores[0], sysConfigMock.checkMCEs)\n        testFactory.getNextTest()\n        testMock.assert_called_with(params1[1], binaryPath1, 3, coreConfigMock.cores[0], sysConfigMock.checkMCEs)\n        testFactory.getNextTest()\n        testMock.assert_called_with(params2[1], binaryPath2, 4, coreConfigMock.cores[0], sysConfigMock.checkMCEs)\n        testFactory.getNextTest()\n        testMock.assert_called_with(params2[2], binaryPath2, 5, coreConfigMock.cores[0], sysConfigMock.checkMCEs)\n        testFactory.getNextTest()\n        testMock.assert_called_with(params2[3], binaryPath2, 6, coreConfigMock.cores[0], sysConfigMock.checkMCEs)\n        self.assertRaises(StopIteration, testFactory.getNextTest)\n\n    def testTwoTestDifferentSizesOfParams_MulitpleCoreConfig(self, testMock, paramFactoryMock):\n        binaryPath1 = \"/path/to/test1/binary\"\n        testName1 = \"test1\"\n        binaryPath2 = \"/path/to/test2/binary\"\n        testName2 = \"test2\"\n        # Setup\n        testConfig1 = NonCallableMagicMock(spec=TestConfig)\n        testConfig1.name = testName1\n        testConfig1.binary = binaryPath1\n\n        testConfig2 = NonCallableMagicMock(spec=TestConfig)\n        testConfig2.name = testName2\n        testConfig2.binary = binaryPath2\n\n        coreConfigMock = NonCallableMagicMock(spec=CoreConfig)\n        coreConfigMock.cores = [[str(x)] for x in range(4)]\n\n        sysConfigMock = NonCallableMagicMock(spec=[SystemConfig, \"isConstantMceChecking\", \"checkMCEs\"])\n        sysConfigMock.checkMCEs = MagicMock()\n        sysConfigMock.testConfigs = [testConfig1, testConfig2]\n        sysConfigMock.coreConfig = coreConfigMock\n\n        params1 = [{\"-a\": \"val1\", \"-b\": \"\"}] * 4 + [{\"-a\": \"va11\"}] * 4\n        getNextParam1SideEffects = [None, StopIteration]  # for _ in range(1)]\n\n        params2 = (\n            ([{\"-a\": \"val1a\", \"-b\": \"no\"}] * 4)\n            + ([{\"-a\": \"va11a\"}] * 4)\n            + ([{\"-a\": \"val2a\", \"-b\": \"no\"}] * 4)\n            + ([{\"-a\": \"val2a\"}] * 4)\n        )\n        getNextParam2SideEffects = [None if i < 3 else StopIteration for i in range(4)]\n\n        paramFactoryInstance1 = NonCallableMagicMock(spec=ParamFactory)\n        paramFactoryInstance1.getParams.side_effect = params1\n        paramFactoryInstance1.getNextParams.side_effect = getNextParam1SideEffects\n        paramFactoryInstance2 = NonCallableMagicMock(spec=ParamFactory)\n        paramFactoryInstance2.getParams.side_effect = params2\n        paramFactoryInstance2.getNextParams.side_effect = getNextParam2SideEffects\n        paramFactoryMock.side_effect = [paramFactoryInstance1, paramFactoryInstance2]\n\n        # Run\n        testFactory = TestFactory(sysConfigMock)\n\n        # Test\n        testNum = 0\n        for i in range(max(len(params1), len(params2))):\n            if i < len(params1):\n                testNum += 1\n                testFactory.getNextTest()\n                testMock.assert_called_with(\n                    params1[i], binaryPath1, testNum, coreConfigMock.cores[i % 4], sysConfigMock.checkMCEs\n                )\n\n            testNum += 1\n            testFactory.getNextTest()\n            testMock.assert_called_with(\n                params2[i], binaryPath2, testNum, coreConfigMock.cores[i % 4], sysConfigMock.checkMCEs\n            )\n        self.assertRaises(StopIteration, testFactory.getNextTest)", "class TestTestFactory(TestCase):\n    def setUp(self):\n        pass\n\n    def testOneTestOneCoreConfig(self, testMock, paramFactoryMock):\n        binaryPath = \"/path/to/test/binary\"\n        testName = \"test1\"\n        # Setup\n        testConfigMock = NonCallableMagicMock(spec=TestConfig)\n        testConfigMock.name = testName\n        testConfigMock.binary = binaryPath\n\n        coreConfigMock = NonCallableMagicMock(spec=CoreConfig)\n        coreConfigMock.cores = [[\"0\"]]\n\n        sysConfigMock = NonCallableMagicMock(spec=[SystemConfig, \"isConstantMceChecking\", \"checkMCEs\"])\n        sysConfigMock.checkMCEs = MagicMock()\n        sysConfigMock.testConfigs = [testConfigMock]\n        sysConfigMock.coreConfig = coreConfigMock\n\n        params = [{\"-a\": \"val1\", \"-b\": \"\"}, {\"-a\": \"va11\"}, {\"-a\": \"val2\", \"-b\": \"\"}, {\"-a\": \"val2\"}]\n\n        paramFactoryInstance = paramFactoryMock.return_value\n        paramFactoryInstance.getParams.side_effect = params\n        paramFactoryInstance.getNextParams.side_effect = [None, None, None, StopIteration]\n\n        # Run\n        testFactory = TestFactory(sysConfigMock)\n\n        # Test\n        testFactory.getNextTest()\n        testMock.assert_called_with(params[0], binaryPath, 1, coreConfigMock.cores[0], sysConfigMock.checkMCEs)\n        testFactory.getNextTest()\n        testMock.assert_called_with(params[1], binaryPath, 2, coreConfigMock.cores[0], sysConfigMock.checkMCEs)\n        testFactory.getNextTest()\n        testMock.assert_called_with(params[2], binaryPath, 3, coreConfigMock.cores[0], sysConfigMock.checkMCEs)\n        testFactory.getNextTest()\n        testMock.assert_called_with(params[3], binaryPath, 4, coreConfigMock.cores[0], sysConfigMock.checkMCEs)\n        self.assertRaises(StopIteration, testFactory.getNextTest)\n\n    def testOneTestMultipleCoreConfigs(self, testMock, paramFactoryMock):\n        binaryPath = \"/path/to/test/binary\"\n        testName = \"test1\"\n        # Setup\n        testConfigMock = NonCallableMagicMock(spec=TestConfig)\n        testConfigMock.name = testName\n        testConfigMock.binary = binaryPath\n\n        coreConfigMock = NonCallableMagicMock(spec=CoreConfig)\n        coreConfigMock.cores = [[str(x)] for x in range(4)]\n\n        sysConfigMock = NonCallableMagicMock(spec=[SystemConfig, \"isConstantMceChecking\", \"checkMCEs\"])\n        sysConfigMock.checkMCEs = MagicMock()\n        sysConfigMock.testConfigs = [testConfigMock]\n        sysConfigMock.coreConfig = coreConfigMock\n\n        params = [{\"-a\": \"val1\", \"-b\": \"\"}, {\"-a\": \"va11\"}, {\"-a\": \"val2\", \"-b\": \"\"}, {\"-a\": \"val2\"}]\n\n        paramFactoryInstance = paramFactoryMock.return_value\n        paramFactoryInstance.getParams.side_effect = params\n        paramFactoryInstance.getNextParams.side_effect = [None if i != 4 else StopIteration for i in range(5)]\n\n        # Run\n        testFactory = TestFactory(sysConfigMock)\n\n        # Test\n        testFactory.getNextTest()\n        testMock.assert_called_with(params[0], binaryPath, 1, coreConfigMock.cores[0], sysConfigMock.checkMCEs)\n        testFactory.getNextTest()\n        testMock.assert_called_with(params[1], binaryPath, 2, coreConfigMock.cores[1], sysConfigMock.checkMCEs)\n        testFactory.getNextTest()\n        testMock.assert_called_with(params[2], binaryPath, 3, coreConfigMock.cores[2], sysConfigMock.checkMCEs)\n        testFactory.getNextTest()\n        testMock.assert_called_with(params[3], binaryPath, 4, coreConfigMock.cores[3], sysConfigMock.checkMCEs)\n        self.assertRaises(StopIteration, testFactory.getNextTest)\n\n    def testTwoTest(self, testMock, paramFactoryMock):\n        binaryPath1 = \"/path/to/test1/binary\"\n        testName1 = \"test1\"\n        binaryPath2 = \"/path/to/test2/binary\"\n        testName2 = \"test2\"\n        # Setup\n        testConfig1 = NonCallableMagicMock(spec=TestConfig)\n        testConfig1.name = testName1\n        testConfig1.binary = binaryPath1\n\n        testConfig2 = NonCallableMagicMock(spec=TestConfig)\n        testConfig2.name = testName2\n        testConfig2.binary = binaryPath2\n\n        coreConfigMock = NonCallableMagicMock(spec=CoreConfig)\n        coreConfigMock.cores = [[0]]\n\n        sysConfigMock = NonCallableMagicMock(spec=[SystemConfig, \"isConstantMceChecking\", \"checkMCEs\"])\n        sysConfigMock.checkMCEs = MagicMock()\n        sysConfigMock.testConfigs = [testConfig1, testConfig2]\n        sysConfigMock.coreConfig = coreConfigMock\n\n        params1 = [{\"-a\": \"val1\", \"-b\": \"\"}, {\"-a\": \"va11\"}, {\"-a\": \"val2\", \"-b\": \"\"}, {\"-a\": \"val2\"}]\n        params2 = [\n            {\"-a\": \"val1a\", \"-b\": \"no\"},\n            {\"-a\": \"va11a\"},\n            {\"-a\": \"val2a\", \"-b\": \"no\"},\n            {\"-a\": \"val2a\"},\n        ]\n        getNextParam1SideEffects = [None, None, None, StopIteration]\n        getNextParam2SideEffects = [None, None, None, StopIteration]\n\n        paramFactoryInstance1 = NonCallableMagicMock(spec=ParamFactory)\n        paramFactoryInstance1.getParams.side_effect = params1\n        paramFactoryInstance1.getNextParams.side_effects = getNextParam1SideEffects\n        paramFactoryInstance2 = NonCallableMagicMock(spec=ParamFactory)\n        paramFactoryInstance2.getParams.side_effect = params2\n        paramFactoryInstance2.getNextParams.side_effects = getNextParam2SideEffects\n        paramFactoryMock.side_effect = [paramFactoryInstance1, paramFactoryInstance2]\n\n        # Run\n        testFactory = TestFactory(sysConfigMock)\n\n        # Test\n        testFactory.getNextTest()\n        testMock.assert_called_with(params1[0], binaryPath1, 1, coreConfigMock.cores[0], sysConfigMock.checkMCEs)\n        testFactory.getNextTest()\n        testMock.assert_called_with(params2[0], binaryPath2, 2, coreConfigMock.cores[0], sysConfigMock.checkMCEs)\n        testFactory.getNextTest()\n        testMock.assert_called_with(params1[1], binaryPath1, 3, coreConfigMock.cores[0], sysConfigMock.checkMCEs)\n        testFactory.getNextTest()\n        testMock.assert_called_with(params2[1], binaryPath2, 4, coreConfigMock.cores[0], sysConfigMock.checkMCEs)\n        testFactory.getNextTest()\n        testMock.assert_called_with(params1[2], binaryPath1, 5, coreConfigMock.cores[0], sysConfigMock.checkMCEs)\n        testFactory.getNextTest()\n        testMock.assert_called_with(params2[2], binaryPath2, 6, coreConfigMock.cores[0], sysConfigMock.checkMCEs)\n        testFactory.getNextTest()\n        testMock.assert_called_with(params1[3], binaryPath1, 7, coreConfigMock.cores[0], sysConfigMock.checkMCEs)\n        testFactory.getNextTest()\n        testMock.assert_called_with(params2[3], binaryPath2, 8, coreConfigMock.cores[0], sysConfigMock.checkMCEs)\n        self.assertRaises(StopIteration, testFactory.getNextTest)\n\n    def testTwoTest_MulitpleCoreConfigs(self, testMock, paramFactoryMock):\n        binaryPath1 = \"/path/to/test1/binary\"\n        testName1 = \"test1\"\n        binaryPath2 = \"/path/to/test2/binary\"\n        testName2 = \"test2\"\n        # Setup\n        testConfig1 = NonCallableMagicMock(spec=TestConfig)\n        testConfig1.name = testName1\n        testConfig1.binary = binaryPath1\n\n        testConfig2 = NonCallableMagicMock(spec=TestConfig)\n        testConfig2.name = testName2\n        testConfig2.binary = binaryPath2\n\n        coreConfigMock = NonCallableMagicMock(spec=CoreConfig)\n        coreConfigMock.cores = [[str(x)] for x in range(4)]\n\n        sysConfigMock = NonCallableMagicMock(spec=[SystemConfig, \"isConstantMceChecking\", \"checkMCEs\"])\n        sysConfigMock.checkMCEs = MagicMock()\n        sysConfigMock.testConfigs = [testConfig1, testConfig2]\n        sysConfigMock.coreConfig = coreConfigMock\n\n        params1 = [{\"-a\": \"val1\", \"-b\": \"\"}, {\"-a\": \"va11\"}, {\"-a\": \"val2\", \"-b\": \"\"}, {\"-a\": \"val2\"}] * 4\n        params2 = [\n            {\"-a\": \"val1a\", \"-b\": \"no\"},\n            {\"-a\": \"va11a\"},\n            {\"-a\": \"val2a\", \"-b\": \"no\"},\n            {\"-a\": \"val2a\"},\n        ] * 4\n        getNextParam1SideEffects = [None if i != 16 else StopIteration for i in range(17)]\n        getNextParam2SideEffects = [None if i != 16 else StopIteration for i in range(17)]\n\n        paramFactoryInstance1 = NonCallableMagicMock(spec=ParamFactory)\n        paramFactoryInstance1.getParams.side_effect = params1\n        paramFactoryInstance1.getNextParams.side_effects = getNextParam1SideEffects\n\n        paramFactoryInstance2 = NonCallableMagicMock(spec=ParamFactory)\n        paramFactoryInstance2.getParams.side_effect = params2\n        paramFactoryInstance2.getNextParams.side_effects = getNextParam2SideEffects\n        paramFactoryMock.side_effect = [paramFactoryInstance1, paramFactoryInstance2]\n\n        # Run\n        testFactory = TestFactory(sysConfigMock)\n\n        # Test\n        for i in range(16):\n            testFactory.getNextTest()\n            testMock.assert_called_with(\n                params1[i], binaryPath1, 2 * i + 1, coreConfigMock.cores[i % 4], sysConfigMock.checkMCEs\n            )\n            testFactory.getNextTest()\n            testMock.assert_called_with(\n                params2[i], binaryPath2, 2 * i + 2, coreConfigMock.cores[i % 4], sysConfigMock.checkMCEs\n            )\n        self.assertRaises(StopIteration, testFactory.getNextTest)\n\n    def testTwoTestDifferentSizesOfParams(self, testMock, paramFactoryMock):\n        binaryPath1 = \"/path/to/test1/binary\"\n        testName1 = \"test1\"\n        binaryPath2 = \"/path/to/test2/binary\"\n        testName2 = \"test2\"\n        # Setup\n        testConfig1 = NonCallableMagicMock(spec=TestConfig)\n        testConfig1.name = testName1\n        testConfig1.binary = binaryPath1\n\n        testConfig2 = NonCallableMagicMock(spec=TestConfig)\n        testConfig2.name = testName2\n        testConfig2.binary = binaryPath2\n\n        coreConfigMock = NonCallableMagicMock(spec=CoreConfig)\n        coreConfigMock.cores = [[\"0\"]]\n\n        sysConfigMock = NonCallableMagicMock(spec=[SystemConfig, \"isConstantMceChecking\", \"checkMCEs\"])\n        sysConfigMock.checkMCEs = MagicMock()\n        sysConfigMock.testConfigs = [testConfig1, testConfig2]\n        sysConfigMock.coreConfig = coreConfigMock\n\n        params1 = [{\"-a\": \"val1\", \"-b\": \"\"}, {\"-a\": \"va11\"}]\n        getNextParam1SideEffects = [None, StopIteration]\n        params2 = [\n            {\"-a\": \"val1a\", \"-b\": \"no\"},\n            {\"-a\": \"va11a\"},\n            {\"-a\": \"val2a\", \"-b\": \"no\"},\n            {\"-a\": \"val2a\"},\n        ]\n        getNextParam2SideEffects = [None, None, None, StopIteration]\n\n        paramFactoryInstance1 = NonCallableMagicMock(spec=ParamFactory)\n        paramFactoryInstance1.getParams.side_effect = params1\n        paramFactoryInstance1.getNextParams.side_effect = getNextParam1SideEffects\n        paramFactoryInstance2 = NonCallableMagicMock(spec=ParamFactory)\n        paramFactoryInstance2.getParams.side_effect = params2\n        paramFactoryInstance2.getNextParams.side_effect = getNextParam2SideEffects\n        paramFactoryMock.side_effect = [paramFactoryInstance1, paramFactoryInstance2]\n\n        # Run\n        testFactory = TestFactory(sysConfigMock)\n\n        # Test\n        testFactory.getNextTest()\n        testMock.assert_called_with(params1[0], binaryPath1, 1, coreConfigMock.cores[0], sysConfigMock.checkMCEs)\n        testFactory.getNextTest()\n        testMock.assert_called_with(params2[0], binaryPath2, 2, coreConfigMock.cores[0], sysConfigMock.checkMCEs)\n        testFactory.getNextTest()\n        testMock.assert_called_with(params1[1], binaryPath1, 3, coreConfigMock.cores[0], sysConfigMock.checkMCEs)\n        testFactory.getNextTest()\n        testMock.assert_called_with(params2[1], binaryPath2, 4, coreConfigMock.cores[0], sysConfigMock.checkMCEs)\n        testFactory.getNextTest()\n        testMock.assert_called_with(params2[2], binaryPath2, 5, coreConfigMock.cores[0], sysConfigMock.checkMCEs)\n        testFactory.getNextTest()\n        testMock.assert_called_with(params2[3], binaryPath2, 6, coreConfigMock.cores[0], sysConfigMock.checkMCEs)\n        self.assertRaises(StopIteration, testFactory.getNextTest)\n\n    def testTwoTestDifferentSizesOfParams_MulitpleCoreConfig(self, testMock, paramFactoryMock):\n        binaryPath1 = \"/path/to/test1/binary\"\n        testName1 = \"test1\"\n        binaryPath2 = \"/path/to/test2/binary\"\n        testName2 = \"test2\"\n        # Setup\n        testConfig1 = NonCallableMagicMock(spec=TestConfig)\n        testConfig1.name = testName1\n        testConfig1.binary = binaryPath1\n\n        testConfig2 = NonCallableMagicMock(spec=TestConfig)\n        testConfig2.name = testName2\n        testConfig2.binary = binaryPath2\n\n        coreConfigMock = NonCallableMagicMock(spec=CoreConfig)\n        coreConfigMock.cores = [[str(x)] for x in range(4)]\n\n        sysConfigMock = NonCallableMagicMock(spec=[SystemConfig, \"isConstantMceChecking\", \"checkMCEs\"])\n        sysConfigMock.checkMCEs = MagicMock()\n        sysConfigMock.testConfigs = [testConfig1, testConfig2]\n        sysConfigMock.coreConfig = coreConfigMock\n\n        params1 = [{\"-a\": \"val1\", \"-b\": \"\"}] * 4 + [{\"-a\": \"va11\"}] * 4\n        getNextParam1SideEffects = [None, StopIteration]  # for _ in range(1)]\n\n        params2 = (\n            ([{\"-a\": \"val1a\", \"-b\": \"no\"}] * 4)\n            + ([{\"-a\": \"va11a\"}] * 4)\n            + ([{\"-a\": \"val2a\", \"-b\": \"no\"}] * 4)\n            + ([{\"-a\": \"val2a\"}] * 4)\n        )\n        getNextParam2SideEffects = [None if i < 3 else StopIteration for i in range(4)]\n\n        paramFactoryInstance1 = NonCallableMagicMock(spec=ParamFactory)\n        paramFactoryInstance1.getParams.side_effect = params1\n        paramFactoryInstance1.getNextParams.side_effect = getNextParam1SideEffects\n        paramFactoryInstance2 = NonCallableMagicMock(spec=ParamFactory)\n        paramFactoryInstance2.getParams.side_effect = params2\n        paramFactoryInstance2.getNextParams.side_effect = getNextParam2SideEffects\n        paramFactoryMock.side_effect = [paramFactoryInstance1, paramFactoryInstance2]\n\n        # Run\n        testFactory = TestFactory(sysConfigMock)\n\n        # Test\n        testNum = 0\n        for i in range(max(len(params1), len(params2))):\n            if i < len(params1):\n                testNum += 1\n                testFactory.getNextTest()\n                testMock.assert_called_with(\n                    params1[i], binaryPath1, testNum, coreConfigMock.cores[i % 4], sysConfigMock.checkMCEs\n                )\n\n            testNum += 1\n            testFactory.getNextTest()\n            testMock.assert_called_with(\n                params2[i], binaryPath2, testNum, coreConfigMock.cores[i % 4], sysConfigMock.checkMCEs\n            )\n        self.assertRaises(StopIteration, testFactory.getNextTest)", ""]}
{"filename": "unittests/test_sysconfig.py", "chunked_list": ["# MIT License\n \n# Copyright (c) 2023 Advanced Micro Devices, Inc.\n \n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:", "# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n \n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n \n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER", "# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\nimport unittest\nfrom subprocess import PIPE, Popen\nfrom unittest.mock import NonCallableMagicMock, call, patch\n", "from unittest.mock import NonCallableMagicMock, call, patch\n\nfrom system_config.SystemConfig import CoreConfig, SystemConfig\n\n\n@patch.object(SystemConfig, \"_checkDependencies\")\n@patch.object(SystemConfig, \"_setCheckInterval\")\n@patch(\"system_config.SystemConfig.CoreConfig\", autospec=True)\n@patch(\"system_config.SystemConfig.os.path.isfile\")\n@patch(\"system_config.SystemConfig.CpuInfo\", autospec=True)", "@patch(\"system_config.SystemConfig.os.path.isfile\")\n@patch(\"system_config.SystemConfig.CpuInfo\", autospec=True)\n@patch(\"system_config.SystemConfig.logger\", autospec=True)\nclass TestConfigParsing(unittest.TestCase):\n    TEST_FILE_DIR = \"unittests/test_files/config_files\"\n\n    def setUp(self):\n        self.runDir = None\n        self.logDir = None\n\n    def _checkConfig1TestConfigs(self, testConfigs):\n        self.assertEqual(len(testConfigs), 2)\n        # Check First Test Config\n        firstTest = testConfigs[0]\n        self.assertEqual(firstTest.name, \"test1\")\n        self.assertEqual(firstTest.binary, \"/path/to/binary1\")\n        # Check Config arguments\n        self.assertEqual(len(firstTest.arguments), 4)\n        arg1 = firstTest.arguments[0]\n        arg2 = firstTest.arguments[1]\n        arg3 = firstTest.arguments[2]\n        arg4 = firstTest.arguments[3]\n        # Test1 Arg 1\n        self.assertFalse(arg1.isConstant)\n        self.assertFalse(arg1.isFlag)\n        self.assertEqual(arg1.cmdLineOption, \"--arg-1\")\n        self.assertEqual(len(arg1.values), 2)\n        self.assertEqual(arg1.values[0], \"Value1\")\n        self.assertEqual(arg1.values[1], \"Value2\")\n        # Test1 Arg2\n        self.assertFalse(arg2.isConstant)\n        self.assertFalse(arg2.isFlag)\n        self.assertEqual(arg2.cmdLineOption, \"-b\")\n        self.assertEqual(len(arg2.values), 2)\n        self.assertEqual(arg2.values[0], \"Value3\")\n        self.assertEqual(arg2.values[1], \"Value4\")\n        # Test1 Arg3\n        self.assertTrue(arg3.isConstant)\n        self.assertFalse(arg3.isFlag)\n        self.assertEqual(arg3.cmdLineOption, \"-c\")\n        self.assertEqual(len(arg3.values), 1)\n        self.assertEqual(arg3.values[0], \"Value5\")\n        # Test1 Arg4\n        self.assertTrue(arg4.isConstant)\n        self.assertTrue(arg4.isFlag)\n        self.assertEqual(arg4.cmdLineOption, \"-d\")\n        self.assertEqual(len(arg4.values), 0)\n\n        # Check Second Test Config\n        secondTest = testConfigs[1]\n        self.assertEqual(secondTest.name, \"test2\")\n        self.assertEqual(secondTest.binary, \"/path/to/binary2\")\n        self.assertEqual(len(secondTest.arguments), 4)\n        arg1 = secondTest.arguments[0]\n        arg2 = secondTest.arguments[1]\n        arg3 = secondTest.arguments[2]\n        arg4 = secondTest.arguments[3]\n        # Test1 Arg 1\n        self.assertFalse(arg1.isConstant)\n        self.assertFalse(arg1.isFlag)\n        self.assertEqual(arg1.cmdLineOption, \"-a\")\n        self.assertEqual(len(arg1.values), 2)\n        self.assertEqual(arg1.values[0], \"Value1\")\n        self.assertEqual(arg1.values[1], \"Value2\")\n        # Test1 Arg2\n        self.assertFalse(arg2.isConstant)\n        self.assertFalse(arg2.isFlag)\n        self.assertEqual(arg2.cmdLineOption, \"-b\")\n        self.assertEqual(len(arg2.values), 2)\n        self.assertEqual(arg2.values[0], \"Value3\")\n        self.assertEqual(arg2.values[1], \"Value4\")\n        # Test1 Arg3\n        self.assertFalse(arg3.isConstant)\n        self.assertFalse(arg3.isFlag)\n        self.assertEqual(arg3.cmdLineOption, \"-c\")\n        self.assertEqual(len(arg3.values), 2)\n        self.assertEqual(arg3.values[0], \"Value5\")\n        self.assertEqual(arg3.values[1], \"Value6\")\n        # Test1 Arg4\n        self.assertFalse(arg4.isConstant)\n        self.assertTrue(arg4.isFlag)\n        self.assertEqual(arg4.cmdLineOption, \"-d\")\n        self.assertEqual(len(arg4.values), 0)\n\n    def testImportYML(\n        self, loggerMock, cpuInfoMock, isfileMock, coreConfigMock, setCheckIntervalMock, checkDependenciesMock\n    ):\n        configFile = \"{}/valid_config1.yml\".format(self.TEST_FILE_DIR)\n        cpuInfoMock.return_value.is_smt_enabled = True\n        cpuInfoMock.return_value.num_logical_cores = 8\n\n        # Setup Mock\n        isfileMock.return_value = True\n\n        # Run\n        sysConfig = SystemConfig(configFile, self.runDir, self.logDir)\n\n        # Check Results\n        # Check system config\n        self.assertEqual(len(sysConfig.testConfigs), 2)\n        self.assertEqual(sysConfig.logDir, \"/var/logs\")\n        self.assertEqual(sysConfig.runDir, \"/home/user/la-hacienda\")\n        self.assertEqual(sysConfig.isConstantMceChecking, False)\n        # Check init of logger\n        loggerMock.set_log_level.assert_called_with(loggerMock.DEBUG)\n        loggerMock.set_log_dir.assert_called_with(\"/var/logs\")\n\n        self._checkConfig1TestConfigs(sysConfig.testConfigs)\n\n    def testImportJSON(\n        self, loggerMock, cpuInfoMock, isfileMock, coreConfigMock, setCheckIntervalMock, checkDependenciesMock\n    ):\n        configFile = \"{}/valid_config1.json\".format(self.TEST_FILE_DIR)\n        cpuInfoMock.return_value.is_smt_enabled = True\n        cpuInfoMock.return_value.num_logical_cores = 8\n\n        # Setup Mock\n        isfileMock.return_value = True\n\n        # Run\n        sysConfig = SystemConfig(configFile, self.runDir, self.logDir)\n\n        # Check Results\n        self.assertEqual(len(sysConfig.testConfigs), 2)\n        self.assertEqual(sysConfig.logDir, \"/var/logs\")\n        self.assertEqual(sysConfig.runDir, \"/home/user/la-hacienda\")\n        self.assertEqual(sysConfig.isConstantMceChecking, False)\n        # Check log initialization\n        loggerMock.set_log_level.assert_called_with(loggerMock.DEBUG)\n        loggerMock.set_log_dir.assert_called_with(\"/var/logs\")\n        # Check Test Config\n        self._checkConfig1TestConfigs(sysConfig.testConfigs)\n\n    def _checkConfig2TestConfigs(self, testConfigs):\n        self.assertEqual(len(testConfigs), 2)\n        # Check First Test Config\n        firstTest = testConfigs[0]\n        self.assertEqual(firstTest.name, \"test1\")\n        self.assertEqual(firstTest.binary, \"/path/to/binary1\")\n        self.assertEqual(len(firstTest.arguments), 0)\n\n        # Check Second Test Config\n        secondTest = testConfigs[1]\n        self.assertEqual(secondTest.name, \"test2\")\n        self.assertEqual(secondTest.binary, \"/path/to/binary2\")\n        self.assertEqual(len(secondTest.arguments), 4)\n        arg1 = secondTest.arguments[0]\n        arg2 = secondTest.arguments[1]\n        arg3 = secondTest.arguments[2]\n        arg4 = secondTest.arguments[3]\n        # Test1 Arg 1\n        self.assertFalse(arg1.isConstant)\n        self.assertFalse(arg1.isFlag)\n        self.assertEqual(arg1.cmdLineOption, \"-a\")\n        self.assertEqual(len(arg1.values), 2)\n        self.assertEqual(arg1.values[0], \"Value1\")\n        self.assertEqual(arg1.values[1], \"Value2\")\n        # Test1 Arg2\n        self.assertFalse(arg2.isConstant)\n        self.assertFalse(arg2.isFlag)\n        self.assertEqual(arg2.cmdLineOption, \"-b\")\n        self.assertEqual(len(arg2.values), 2)\n        self.assertEqual(arg2.values[0], \"Value3\")\n        self.assertEqual(arg2.values[1], \"Value4\")\n        # Test1 Arg3\n        self.assertFalse(arg3.isConstant)\n        self.assertFalse(arg3.isFlag)\n        self.assertEqual(arg3.cmdLineOption, \"-c\")\n        self.assertEqual(len(arg3.values), 2)\n        self.assertEqual(arg3.values[0], \"Value5\")\n        self.assertEqual(arg3.values[1], \"Value6\")\n        # Test1 Arg4\n        self.assertFalse(arg4.isConstant)\n        self.assertTrue(arg4.isFlag)\n        self.assertEqual(arg4.cmdLineOption, \"-d\")\n        self.assertEqual(len(arg4.values), 0)\n\n    def testImportNoArgTestYML(\n        self, loggerMock, cpuInfoMock, isfileMock, coreConfigMock, setCheckIntervalMock, checkDependenciesMock\n    ):\n        configFile = \"{}/valid_config2.yml\".format(self.TEST_FILE_DIR)\n\n        # Setup Mock\n        cpuInfoMock.return_value.is_smt_enabled = True\n        cpuInfoMock.return_value.num_logical_cores = 8\n        isfileMock.return_value = True\n\n        # Run\n        sysConfig = SystemConfig(configFile, self.runDir, self.logDir)\n\n        # Check Results\n        self.assertEqual(len(sysConfig.testConfigs), 2)\n        self.assertEqual(sysConfig.logDir, \"/var/logs\")\n        self.assertEqual(sysConfig.runDir, \"/home/user/la-hacienda\")\n        self.assertEqual(sysConfig.isConstantMceChecking, True)\n        loggerMock.set_log_level.assert_called_with(loggerMock.DEBUG)\n        loggerMock.set_log_dir.assert_called_with(\"/var/logs\")\n        self._checkConfig2TestConfigs(sysConfig.testConfigs)\n\n    def testImportNoArgTestJSON(\n        self, loggerMock, cpuInfoMock, isfileMock, coreConfigMock, setCheckIntervalMock, checkDependenciesMock\n    ):\n        configFile = \"{}/valid_config2.json\".format(self.TEST_FILE_DIR)\n\n        # Setup Mock\n        isfileMock.return_value = True\n        cpuInfoMock.return_value.is_smt_enabled = True\n        cpuInfoMock.return_value.num_logical_cores = 8\n\n        # Run\n        sysConfig = SystemConfig(configFile, self.runDir, self.logDir)\n\n        # Check Results\n        self.assertEqual(len(sysConfig.testConfigs), 2)\n        self.assertEqual(sysConfig.logDir, \"/var/logs\")\n        self.assertEqual(sysConfig.runDir, \"/home/user/la-hacienda\")\n        self.assertEqual(sysConfig.isConstantMceChecking, True)\n        loggerMock.set_log_level.assert_called_with(loggerMock.DEBUG)\n        loggerMock.set_log_dir.assert_called_with(\"/var/logs\")\n        self._checkConfig2TestConfigs(sysConfig.testConfigs)\n\n    def _checkConfig3TestConfigs(self, testConfigs):\n        self.assertEqual(len(testConfigs), 1)\n        # Check Second Test Config\n        firstTest = testConfigs[0]\n        self.assertEqual(firstTest.name, \"test1\")\n        self.assertEqual(firstTest.binary, \"/path/to/binary1\")\n        self.assertEqual(len(firstTest.arguments), 1)\n        arg1 = firstTest.arguments[0]\n        # Test1 Arg 1\n        self.assertFalse(arg1.isConstant)\n        self.assertFalse(arg1.isFlag)\n        self.assertEqual(arg1.cmdLineOption, \"--arg-1\")\n        self.assertEqual(len(arg1.values), 2)\n        self.assertEqual(arg1.values[0], \"Value1\")\n        self.assertEqual(arg1.values[1], \"Value2\")\n\n    def testImportOnlyTestYML(\n        self, loggerMock, cpuInfoMock, isfileMock, coreConfigMock, setCheckIntervalMock, checkDependenciesMock\n    ):\n        configFile = \"{}/valid_config3.yml\".format(self.TEST_FILE_DIR)\n        cpuInfoMock.return_value.is_smt_enabled = True\n        cpuInfoMock.return_value.num_logical_cores = 8\n\n        # Setup Mock\n        isfileMock.return_value = True\n\n        # Run\n        sysConfig = SystemConfig(configFile, \".\", \"logs\")\n\n        # Check Results\n        self.assertEqual(len(sysConfig.testConfigs), 1)\n        self.assertEqual(sysConfig.logDir, \"logs\")\n        self.assertEqual(sysConfig.runDir, \".\")\n        self.assertEqual(sysConfig.isConstantMceChecking, True)\n        loggerMock.set_log_level.assert_called_with(loggerMock.ALL)\n        loggerMock.set_log_dir.assert_called_with(\"logs\")\n        self._checkConfig3TestConfigs(sysConfig.testConfigs)\n\n    def testImportOnlyTestJSON(\n        self, loggerMock, cpuInfoMock, isfileMock, coreConfigMock, setCheckIntervalMock, checkDependenciesMock\n    ):\n        configFile = \"{}/valid_config3.json\".format(self.TEST_FILE_DIR)\n\n        # Setup Mock\n        isfileMock.return_value = True\n        cpuInfoMock.return_value.is_smt_enabled = True\n        cpuInfoMock.return_value.num_logical_cores = 8\n\n        # Run\n        sysConfig = SystemConfig(configFile, \".\", \"logs\")\n\n        # Check Results\n        self.assertEqual(len(sysConfig.testConfigs), 1)\n        self.assertEqual(sysConfig.logDir, \"logs\")\n        self.assertEqual(sysConfig.runDir, \".\")\n        self.assertEqual(sysConfig.isConstantMceChecking, True)\n        loggerMock.set_log_level.assert_called_with(loggerMock.ALL)\n        loggerMock.set_log_dir.assert_called_with(\"logs\")\n        self._checkConfig3TestConfigs(sysConfig.testConfigs)\n\n    @patch(\"system_config.SystemConfig.shutil.which\", autospec=True)\n    def testImportBinaryInPath(\n        self,\n        whichMock,\n        loggerMock,\n        cpuInfoMock,\n        isfileMock,\n        coreConfigMock,\n        setCheckIntervalMock,\n        checkDependenciesMock,\n    ):\n        configFile = \"{}/valid_config1.yml\".format(self.TEST_FILE_DIR)\n        cpuInfoMock.return_value.is_smt_enabled = True\n        cpuInfoMock.return_value.num_logical_cores = 8\n\n        # Setup Mock\n        isfileMock.side_effect = lambda f: \"binary\" not in f\n        whichMock.return_value = \"/a/path\"\n\n        # Run\n        sysConfig = SystemConfig(configFile, self.runDir, self.logDir)\n\n        # Check Results\n        whichMock.assert_called()\n        # Check system config\n        self.assertEqual(len(sysConfig.testConfigs), 2)\n        self.assertEqual(sysConfig.logDir, \"/var/logs\")\n        self.assertEqual(sysConfig.runDir, \"/home/user/la-hacienda\")\n        self.assertEqual(sysConfig.isConstantMceChecking, False)\n        # Check init of logger\n        loggerMock.set_log_level.assert_called_with(loggerMock.DEBUG)\n        loggerMock.set_log_dir.assert_called_with(\"/var/logs\")\n\n        self._checkConfig1TestConfigs(sysConfig.testConfigs)\n\n    @patch(\"system_config.SystemConfig.shutil.which\", autospec=True)\n    def testImportBinaryNotFound(\n        self,\n        whichMock,\n        loggerMock,\n        cpuInfoMock,\n        isfileMock,\n        coreConfigMock,\n        setCheckIntervalMock,\n        checkDependenciesMock,\n    ):\n        configFile = \"{}/valid_config1.yml\".format(self.TEST_FILE_DIR)\n        cpuInfoMock.return_value.is_smt_enabled = True\n        cpuInfoMock.return_value.num_logical_cores = 8\n\n        # Setup Mock\n        isfileMock.side_effect = lambda f: \"binary\" not in f\n        whichMock.return_value = None\n\n        # Run & Check Results\n        self.assertRaises(RuntimeError, SystemConfig, configFile, self.runDir, self.logDir)\n\n    def testImportOnlyTestNoCmdLineArgsYML(\n        self, loggerMock, cpuInfoMock, isfileMock, coreConfigMock, setCheckIntervalMock, checkDependenciesMock\n    ):\n        configFile = \"{}/valid_config3.yml\".format(self.TEST_FILE_DIR)\n\n        # Setup Mock\n        isfileMock.return_value = True\n\n        # Run & Check\n        self.assertRaises(RuntimeError, SystemConfig, configFile, self.runDir, self.logDir)\n\n    def testImportOnlyTestNoCmdLineArgsJSON(\n        self, loggerMock, cpuInfoMock, isfileMock, coreConfigMock, setCheckIntervalMock, checkDependenciesMock\n    ):\n        configFile = \"{}/valid_config3.json\".format(self.TEST_FILE_DIR)\n\n        # Setup Mock\n        isfileMock.return_value = True\n\n        # Run & Check\n        self.assertRaises(RuntimeError, SystemConfig, configFile, self.runDir, self.logDir)\n\n    def testImportNoTestsYML(\n        self, loggerMock, cpuInfoMock, isfileMock, coreConfigMock, setCheckIntervalMock, checkDependenciesMock\n    ):\n        configFile = \"{}/invalid_config1.yml\".format(self.TEST_FILE_DIR)\n        self.assertRaises(RuntimeError, SystemConfig, configFile, self.runDir, self.logDir)\n\n    def testImportNoTestJSON(\n        self, loggerMock, cpuInfoMock, isfileMock, coreConfigMock, setCheckIntervalMock, checkDependenciesMock\n    ):\n        configFile = \"{}/invalid_config1.json\".format(self.TEST_FILE_DIR)\n        self.assertRaises(RuntimeError, SystemConfig, configFile, self.runDir, self.logDir)\n\n    def testImportInvalidConstantArgYML(\n        self, loggerMock, cpuInfoMock, isfileMock, coreConfigMock, setCheckIntervalMock, checkDependenciesMock\n    ):\n        configFile = \"{}/invalid_config2.yml\".format(self.TEST_FILE_DIR)\n        self.assertRaises(RuntimeError, SystemConfig, configFile, self.runDir, self.logDir)\n\n    def testImportInvalidConstantArgJSON(\n        self, loggerMock, cpuInfoMock, isfileMock, coreConfigMock, setCheckIntervalMock, checkDependenciesMock\n    ):\n        configFile = \"{}/invalid_config2.json\".format(self.TEST_FILE_DIR)\n        self.assertRaises(RuntimeError, SystemConfig, configFile, self.runDir, self.logDir)\n\n    def testImportInvalidFlagArgYML(\n        self, loggerMock, cpuInfoMock, isfileMock, coreConfigMock, setCheckIntervalMock, checkDependenciesMock\n    ):\n        configFile = \"{}/invalid_config3.yml\".format(self.TEST_FILE_DIR)\n        self.assertRaises(RuntimeError, SystemConfig, configFile, self.runDir, self.logDir)\n\n    def testImportInvalidFlagArgJSON(\n        self, loggerMock, cpuInfoMock, isfileMock, coreConfigMock, setCheckIntervalMock, checkDependenciesMock\n    ):\n        configFile = \"{}/invalid_config3.json\".format(self.TEST_FILE_DIR)\n        self.assertRaises(RuntimeError, SystemConfig, configFile, self.runDir, self.logDir)\n\n    def testImportInvalidTypeYML(\n        self, loggerMock, cpuInfoMock, isfileMock, coreConfigMock, setCheckIntervalMock, checkDependenciesMock\n    ):\n        configFile = \"{}/invalid_config4.yml\".format(self.TEST_FILE_DIR)\n        self.assertRaises(TypeError, SystemConfig, configFile, self.runDir, self.logDir)\n\n    def testImportInvalidTypeJSON(\n        self, loggerMock, cpuInfoMock, isfileMock, coreConfigMock, setCheckIntervalMock, checkDependenciesMock\n    ):\n        configFile = \"{}/invalid_config4.json\".format(self.TEST_FILE_DIR)\n        self.assertRaises(TypeError, SystemConfig, configFile, self.runDir, self.logDir)\n\n    def testImportInvalidType2YML(\n        self, loggerMock, cpuInfoMock, isfileMock, coreConfigMock, setCheckIntervalMock, checkDependenciesMock\n    ):\n        configFile = \"{}/invalid_config5.yml\".format(self.TEST_FILE_DIR)\n        self.assertRaises(TypeError, SystemConfig, configFile, self.runDir, self.logDir)\n\n    def testImportInvalidType2JSON(\n        self, loggerMock, cpuInfoMock, isfileMock, coreConfigMock, setCheckIntervalMock, checkDependenciesMock\n    ):\n        configFile = \"{}/invalid_config5.json\".format(self.TEST_FILE_DIR)\n        self.assertRaises(TypeError, SystemConfig, configFile, self.runDir, self.logDir)\n\n    def testImportInvalidJSONFile(\n        self, loggerMock, cpuInfoMock, isfileMock, coreConfigMock, setCheckIntervalMock, checkDependenciesMock\n    ):\n        configFile = \"{}/invalid_config6.json\".format(self.TEST_FILE_DIR)\n        self.assertRaises(RuntimeError, SystemConfig, configFile, self.runDir, self.logDir)\n\n    def testImportInvalidYMLFile(\n        self, loggerMock, cpuInfoMock, isfileMock, coreConfigMock, setCheckIntervalMock, checkDependenciesMock\n    ):\n        configFile = \"{}/invalid_config6.yml\".format(self.TEST_FILE_DIR)\n        self.assertRaises(RuntimeError, SystemConfig, configFile, self.runDir, self.logDir)", "\n\n@patch.object(SystemConfig, \"_setCheckInterval\")\n@patch.object(SystemConfig, \"_importConfig\")\n@patch.object(SystemConfig, \"_setupMCEDetection\")\n@patch(\"system_config.SystemConfig.logger\", autospec=True)\n@patch(\"system_config.SystemConfig.CpuInfo\", autospec=True)\n@patch(\"system_config.SystemConfig.datetime\", autospec=True)\n@patch(\"system_config.SystemConfig.Popen\", autospec=True)\n@patch(\"system_config.SystemConfig.os.path.isdir\", autospec=True)\nclass TestDependencyChecking(unittest.TestCase):\n    def setUp(self):\n        pass\n\n    def testEdacDependency(\n        self,\n        isDirMock,\n        popenMock,\n        datetimeMock,\n        cpuInfoMock,\n        loggerMock,\n        setupMceDetectMock,\n        importConfigMock,\n        setCheckIntervalMock,\n    ):\n        # Setup\n        popenMock.return_value.communicate.return_value = b\"1\", b\"\"\n        popenMock.return_value.returncode = 0\n\n        isDirMock.return_value = True\n\n        # Run\n        SystemConfig(NonCallableMagicMock(), NonCallableMagicMock(), NonCallableMagicMock())\n\n        # Test\n        # Just test to ensure no exceptions are raised\n        self.assertTrue(True)\n\n    def testEdacDependencyNoOSModule(\n        self,\n        isDirMock,\n        popenMock,\n        datetimeMock,\n        cpuInfoMock,\n        loggerMock,\n        setupMceDetectMock,\n        importConfigMock,\n        setCheckIntervalMock,\n    ):\n        # Setup\n        popenMock.return_value.communicate.return_value = b\"0\", b\"\"\n        popenMock.return_value.returncode = 0\n\n        isDirMock.return_value = True\n\n        # Run\n        SystemConfig(NonCallableMagicMock(), NonCallableMagicMock(), NonCallableMagicMock())\n\n        # Test\n        # Just test to ensure no exceptions are raised\n        self.assertTrue(True)\n\n    def testEdacDependencyNoOSModuleNoMCDir(\n        self,\n        isDirMock,\n        popenMock,\n        datetimeMock,\n        cpuInfoMock,\n        loggerMock,\n        setupMceDetectMock,\n        importConfigMock,\n        setCheckIntervalMock,\n    ):\n        # Setup\n        popenMock.return_value.communicate.return_value = b\"0\", b\"\"\n        popenMock.return_value.returncode = 0\n\n        isDirMock.return_value = False\n\n        # Run & Test\n        self.assertRaises(\n            RuntimeError, SystemConfig, NonCallableMagicMock(), NonCallableMagicMock(), NonCallableMagicMock()\n        )", "@patch(\"system_config.SystemConfig.Popen\", autospec=True)\n@patch(\"system_config.SystemConfig.os.path.isdir\", autospec=True)\nclass TestDependencyChecking(unittest.TestCase):\n    def setUp(self):\n        pass\n\n    def testEdacDependency(\n        self,\n        isDirMock,\n        popenMock,\n        datetimeMock,\n        cpuInfoMock,\n        loggerMock,\n        setupMceDetectMock,\n        importConfigMock,\n        setCheckIntervalMock,\n    ):\n        # Setup\n        popenMock.return_value.communicate.return_value = b\"1\", b\"\"\n        popenMock.return_value.returncode = 0\n\n        isDirMock.return_value = True\n\n        # Run\n        SystemConfig(NonCallableMagicMock(), NonCallableMagicMock(), NonCallableMagicMock())\n\n        # Test\n        # Just test to ensure no exceptions are raised\n        self.assertTrue(True)\n\n    def testEdacDependencyNoOSModule(\n        self,\n        isDirMock,\n        popenMock,\n        datetimeMock,\n        cpuInfoMock,\n        loggerMock,\n        setupMceDetectMock,\n        importConfigMock,\n        setCheckIntervalMock,\n    ):\n        # Setup\n        popenMock.return_value.communicate.return_value = b\"0\", b\"\"\n        popenMock.return_value.returncode = 0\n\n        isDirMock.return_value = True\n\n        # Run\n        SystemConfig(NonCallableMagicMock(), NonCallableMagicMock(), NonCallableMagicMock())\n\n        # Test\n        # Just test to ensure no exceptions are raised\n        self.assertTrue(True)\n\n    def testEdacDependencyNoOSModuleNoMCDir(\n        self,\n        isDirMock,\n        popenMock,\n        datetimeMock,\n        cpuInfoMock,\n        loggerMock,\n        setupMceDetectMock,\n        importConfigMock,\n        setCheckIntervalMock,\n    ):\n        # Setup\n        popenMock.return_value.communicate.return_value = b\"0\", b\"\"\n        popenMock.return_value.returncode = 0\n\n        isDirMock.return_value = False\n\n        # Run & Test\n        self.assertRaises(\n            RuntimeError, SystemConfig, NonCallableMagicMock(), NonCallableMagicMock(), NonCallableMagicMock()\n        )", "\n\nclass TestCoreConfig(unittest.TestCase):\n    def setUp(self):\n        self.configDict = {\n            \"SMT\": True,\n            \"All\": True,\n            \"Halfs\": [0, 1],\n            \"Quarters\": [0, 1, 2, 3],\n            \"CCDs\": [0, 1, 2],\n            \"Cores\": [0, 1, 2, 3, 4, 5, 6, 7],\n        }\n        self.cpuInfo = NonCallableMagicMock(spec=\"system_config.cpuinfo.CpuInfo\")\n        self.cpuInfo.ccds_per_socket = 3\n        self.cpuInfo.num_physical_cores = 24\n        self.cpuInfo.num_logical_cores = 48\n        self.cpuInfo.cores_per_ccd = 8\n        self.cpuInfo.num_sockets = 2\n        self.cpuInfo.is_smt_enabled = True\n        self.runDir = \".\"\n\n    def _get_listcore_str(self, division, thread=0, sockets=\"all\"):\n        return call(\n            \"{}/list_cores.sh {} {} {} {} {} {}\".format(\n                self.runDir,\n                self.cpuInfo.cores_per_ccd,\n                self.cpuInfo.ccds_per_socket,\n                self.cpuInfo.num_sockets,\n                division,\n                thread,\n                sockets,\n            ),\n            shell=True,\n            stdout=PIPE,\n            stderr=PIPE,\n        )\n\n    def test_CoreConfig_init_valid_cores(self):\n        self.configDict = {\"SMT\": True, \"Cores\": True}\n        coreConfig = CoreConfig(self.configDict, self.cpuInfo, self.runDir)\n\n        self.assertEqual(coreConfig.cores, [[str(x)] for x in range(self.cpuInfo.num_logical_cores)])\n\n    @patch(\"system_config.SystemConfig.os.path.isfile\")\n    @patch(\"system_config.SystemConfig.Popen\", autospec=True)\n    def test_CoreConfig_init_valid_ccd(self, popenMock, isfileMock):\n        self.configDict = {\"SMT\": True, \"CCDs\": True}\n        popenMock.return_value.communicate.return_value = b\"STDOUT\", b\"\"\n        popenMock.return_value.returncode = 0\n        isfileMock.return_value = True\n        coreConfig = CoreConfig(self.configDict, self.cpuInfo, self.runDir)\n        self.assertEqual(coreConfig.smt, True)\n        listCoreCalls = [\n            self._get_listcore_str(\"0\", thread=0),\n            self._get_listcore_str(\"1\", thread=0),\n            self._get_listcore_str(\"2\", thread=0),\n            self._get_listcore_str(\"0\", thread=1),\n            self._get_listcore_str(\"1\", thread=1),\n            self._get_listcore_str(\"2\", thread=1),\n            call().communicate(),\n        ]\n        popenMock.assert_has_calls(\n            listCoreCalls,\n            any_order=True,\n        )\n\n    @patch(\"system_config.SystemConfig.os.path.isfile\")\n    @patch(\"system_config.SystemConfig.Popen\", autospec=True)\n    def test_CoreConfig_init_valid_quarts(self, popenMock, isfileMock):\n        self.configDict = {\"SMT\": True, \"Quarters\": True}\n        popenMock.return_value.communicate.return_value = b\"STDOUT\", b\"\"\n        popenMock.return_value.returncode = 0\n        isfileMock.return_value = True\n        coreConfig = CoreConfig(self.configDict, self.cpuInfo, self.runDir)\n        self.assertEqual(coreConfig.smt, True)\n        listCoreCalls = [\n            self._get_listcore_str(\"quart0\", thread=0),\n            self._get_listcore_str(\"quart1\", thread=0),\n            self._get_listcore_str(\"quart2\", thread=0),\n            self._get_listcore_str(\"quart3\", thread=0),\n            self._get_listcore_str(\"quart0\", thread=1),\n            self._get_listcore_str(\"quart1\", thread=1),\n            self._get_listcore_str(\"quart2\", thread=1),\n            self._get_listcore_str(\"quart3\", thread=1),\n            call().communicate(),\n        ]\n        popenMock.assert_has_calls(\n            listCoreCalls,\n            any_order=True,\n        )\n\n    @patch(\"system_config.SystemConfig.os.path.isfile\")\n    @patch(\"system_config.SystemConfig.Popen\", autospec=True)\n    def test_CoreConfig_init_valid_halfs(self, popenMock, isfileMock):\n        self.configDict = {\"SMT\": True, \"Halfs\": True}\n        popenMock.return_value.communicate.return_value = b\"STDOUT\", b\"\"\n        popenMock.return_value.returncode = 0\n        isfileMock.return_value = True\n        coreConfig = CoreConfig(self.configDict, self.cpuInfo, self.runDir)\n        self.assertEqual(coreConfig.smt, True)\n        listCoreCalls = [\n            self._get_listcore_str(\"half0\", thread=0),\n            self._get_listcore_str(\"half1\", thread=0),\n            self._get_listcore_str(\"half0\", thread=1),\n            self._get_listcore_str(\"half1\", thread=1),\n            call().communicate(),\n        ]\n        popenMock.assert_has_calls(\n            listCoreCalls,\n            any_order=True,\n        )\n\n    @patch(\"system_config.SystemConfig.os.path.isfile\")\n    @patch(\"system_config.SystemConfig.Popen\", autospec=True)\n    def test_CoreConfig_init_valid(self, popenMock, isfileMock):\n        popenMock.return_value.communicate.return_value = b\"STDOUT\", b\"\"\n        popenMock.return_value.returncode = 0\n        isfileMock.return_value = True\n        coreConfig = CoreConfig(self.configDict, self.cpuInfo, self.runDir)\n        self.assertEqual(coreConfig.smt, True)\n        listCoreCalls = [\n            self._get_listcore_str(\"all\"),\n            self._get_listcore_str(\"half0\"),\n            self._get_listcore_str(\"half1\"),\n            self._get_listcore_str(\"quart0\"),\n            self._get_listcore_str(\"quart1\"),\n            self._get_listcore_str(\"quart2\"),\n            self._get_listcore_str(\"quart3\"),\n            self._get_listcore_str(\"0\"),\n            self._get_listcore_str(\"1\"),\n            self._get_listcore_str(\"2\"),\n            self._get_listcore_str(\"all\", thread=1),\n            self._get_listcore_str(\"half0\", thread=1),\n            self._get_listcore_str(\"half1\", thread=1),\n            self._get_listcore_str(\"quart0\", thread=1),\n            self._get_listcore_str(\"quart1\", thread=1),\n            self._get_listcore_str(\"quart2\", thread=1),\n            self._get_listcore_str(\"quart3\", thread=1),\n            self._get_listcore_str(\"0\", thread=1),\n            self._get_listcore_str(\"1\", thread=1),\n            self._get_listcore_str(\"2\", thread=1),\n            call().communicate(),\n        ]\n        popenMock.assert_has_calls(\n            listCoreCalls,\n            any_order=True,\n        )\n\n    @patch(\"system_config.SystemConfig.os.path.isfile\")\n    @patch(\"system_config.SystemConfig.Popen\", autospec=True)\n    def test_CoreConfig_init_sockets(self, popenMock, isfileMock):\n        popenMock.return_value.communicate.return_value = b\"STDOUT\", b\"\"\n        popenMock.return_value.returncode = 0\n        self.configDict[\"Sockets\"] = [0, 1, [0, 1]]\n        coreConfig = CoreConfig(self.configDict, self.cpuInfo, self.runDir)\n        self.assertEqual(coreConfig.sockets, [\"0\", \"1\", \"all\"])\n        listCoreCalls = [\n            self._get_listcore_str(\"all\", sockets=0),\n            self._get_listcore_str(\"half0\", sockets=0),\n            self._get_listcore_str(\"half1\", sockets=0),\n            self._get_listcore_str(\"quart0\", sockets=0),\n            self._get_listcore_str(\"quart1\", sockets=0),\n            self._get_listcore_str(\"quart2\", sockets=0),\n            self._get_listcore_str(\"quart3\", sockets=0),\n            self._get_listcore_str(\"0\", sockets=0),\n            self._get_listcore_str(\"1\", sockets=0),\n            self._get_listcore_str(\"2\", sockets=0),\n            self._get_listcore_str(\"all\", sockets=1),\n            self._get_listcore_str(\"half0\", sockets=1),\n            self._get_listcore_str(\"half1\", sockets=1),\n            self._get_listcore_str(\"quart0\", sockets=1),\n            self._get_listcore_str(\"quart1\", sockets=1),\n            self._get_listcore_str(\"quart2\", sockets=1),\n            self._get_listcore_str(\"quart3\", sockets=1),\n            self._get_listcore_str(\"0\", sockets=1),\n            self._get_listcore_str(\"1\", sockets=1),\n            self._get_listcore_str(\"2\", sockets=1),\n            self._get_listcore_str(\"all\"),\n            self._get_listcore_str(\"half0\"),\n            self._get_listcore_str(\"half1\"),\n            self._get_listcore_str(\"quart0\"),\n            self._get_listcore_str(\"quart1\"),\n            self._get_listcore_str(\"quart2\"),\n            self._get_listcore_str(\"quart3\"),\n            self._get_listcore_str(\"0\"),\n            self._get_listcore_str(\"1\"),\n            self._get_listcore_str(\"2\"),\n            self._get_listcore_str(\"all\", sockets=0, thread=1),\n            self._get_listcore_str(\"half0\", sockets=0, thread=1),\n            self._get_listcore_str(\"half1\", sockets=0, thread=1),\n            self._get_listcore_str(\"quart0\", sockets=0, thread=1),\n            self._get_listcore_str(\"quart1\", sockets=0, thread=1),\n            self._get_listcore_str(\"quart2\", sockets=0, thread=1),\n            self._get_listcore_str(\"quart3\", sockets=0, thread=1),\n            self._get_listcore_str(\"0\", sockets=0, thread=1),\n            self._get_listcore_str(\"1\", sockets=0, thread=1),\n            self._get_listcore_str(\"2\", sockets=0, thread=1),\n            self._get_listcore_str(\"all\", sockets=1, thread=1),\n            self._get_listcore_str(\"half0\", sockets=1, thread=1),\n            self._get_listcore_str(\"half1\", sockets=1, thread=1),\n            self._get_listcore_str(\"quart0\", sockets=1, thread=1),\n            self._get_listcore_str(\"quart1\", sockets=1, thread=1),\n            self._get_listcore_str(\"quart2\", sockets=1, thread=1),\n            self._get_listcore_str(\"quart3\", sockets=1, thread=1),\n            self._get_listcore_str(\"0\", sockets=1, thread=1),\n            self._get_listcore_str(\"1\", sockets=1, thread=1),\n            self._get_listcore_str(\"2\", sockets=1, thread=1),\n            self._get_listcore_str(\"all\", thread=1),\n            self._get_listcore_str(\"half0\", thread=1),\n            self._get_listcore_str(\"half1\", thread=1),\n            self._get_listcore_str(\"quart0\", thread=1),\n            self._get_listcore_str(\"quart1\", thread=1),\n            self._get_listcore_str(\"quart2\", thread=1),\n            self._get_listcore_str(\"quart3\", thread=1),\n            self._get_listcore_str(\"0\", thread=1),\n            self._get_listcore_str(\"1\", thread=1),\n            self._get_listcore_str(\"2\", thread=1),\n            call().communicate(),\n        ]\n        popenMock.assert_has_calls(listCoreCalls, any_order=True)\n\n    def test_CoreConfig_init_invalid_sockets(self):\n        self.configDict[\"Sockets\"] = [4]\n        with self.assertRaises(RuntimeError):\n            CoreConfig(self.configDict, self.cpuInfo, self.runDir)\n\n    def test_CoreConfig_init_invalid_sockets_2(self):\n        self.cpuInfo.num_sockets = 1\n        self.configDict[\"Sockets\"] = [1]\n        with self.assertRaises(RuntimeError):\n            CoreConfig(self.configDict, self.cpuInfo, self.runDir)\n\n    def test_CoreConfig_init_missing_SMT(self):\n        del self.configDict[\"SMT\"]\n        with self.assertRaises(RuntimeError):\n            CoreConfig(self.configDict, self.cpuInfo, self.runDir)\n\n    def test_CoreConfig_init_SMT_not_enabled(self):\n        self.cpuInfo.is_smt_enabled = False\n        with self.assertRaises(RuntimeError):\n            CoreConfig(self.configDict, self.cpuInfo, self.runDir)\n\n    def test_CoreConfig_init_invalid_All(self):\n        self.configDict[\"All\"] = [0]\n        with self.assertRaises(RuntimeError):\n            CoreConfig(self.configDict, self.cpuInfo, self.runDir)\n\n    def test_CoreConfig_init_invalid_Halfs(self):\n        self.configDict[\"Halfs\"] = [0, 1, 2]\n        with self.assertRaises(RuntimeError):\n            CoreConfig(self.configDict, self.cpuInfo, self.runDir)\n\n    def test_CoreConfig_init_invalid_Quarters(self):\n        self.configDict[\"Quarters\"] = [0, 1, 2, 3, 4]\n        with self.assertRaises(RuntimeError):\n            CoreConfig(self.configDict, self.cpuInfo, self.runDir)\n\n    def test_CoreConfig_init_invalid_CCDs(self):\n        self.configDict[\"CCDs\"] = [0, 1, 2, 3]\n        with self.assertRaises(RuntimeError):\n            CoreConfig(self.configDict, self.cpuInfo, self.runDir)", "\n\nclass TestListCoreScript(unittest.TestCase):\n    def setUp(self):\n        self.maxDiff = None\n        self.runDir = \".\"\n        self.cores_per_ccd = 8\n        self.ccds_per_socket = 8\n        self.num_sockets = 2\n\n    def _get_listcore_str(self, division, thread=0, sockets=\"all\"):\n        return \"{}/list_cores.sh {} {} {} {} {} {}\".format(\n            self.runDir,\n            self.cores_per_ccd,\n            self.ccds_per_socket,\n            self.num_sockets,\n            division,\n            thread,\n            sockets,\n        )\n\n    # Two Sockets\n    def testTwoSocketAll(self):\n        expected = \" \".join([str(x) for x in range(self.cores_per_ccd * self.ccds_per_socket * self.num_sockets)])\n        expected += \" \\n\"\n\n        p = Popen(self._get_listcore_str(\"all\"), shell=True, stdout=PIPE, stderr=PIPE)\n        stdout, stderr = p.communicate()\n        stdout, stderr = stdout.decode(\"utf-8\"), stderr.decode(\"utf-8\")\n\n        self.assertEqual(p.returncode, 0)\n        self.assertEqual(stdout, expected)\n\n    def testTwoSocketHalf0(self):\n        halfCoreCount = int(self.cores_per_ccd * self.ccds_per_socket / 2)\n        expected = \" \".join([str(x) for x in range(halfCoreCount)])\n        expected += \" \"\n        expected += \" \".join(\n            [\n                str(x)\n                for x in range(halfCoreCount * self.num_sockets, halfCoreCount + (halfCoreCount * self.num_sockets))\n            ]\n        )\n        expected += \" \\n\"\n\n        p = Popen(self._get_listcore_str(\"half0\"), shell=True, stdout=PIPE, stderr=PIPE)\n        stdout, stderr = p.communicate()\n        stdout, stderr = stdout.decode(\"utf-8\"), stderr.decode(\"utf-8\")\n\n        self.assertEqual(p.returncode, 0)\n        self.assertEqual(stdout, expected)\n\n    def testTwoSocketQuart1(self):\n        quartCoreCount = int(self.cores_per_ccd * self.ccds_per_socket / 4)\n        expected = \" \".join([str(x) for x in range(quartCoreCount, 2 * quartCoreCount)])\n        expected += \" \"\n        expected += \" \".join(\n            [\n                str(x)\n                for x in range(\n                    (3 * quartCoreCount) + (quartCoreCount * self.num_sockets),\n                    4 * quartCoreCount + (quartCoreCount * self.num_sockets),\n                )\n            ]\n        )\n        expected += \" \\n\"\n\n        p = Popen(self._get_listcore_str(\"quart1\"), shell=True, stdout=PIPE, stderr=PIPE)\n        stdout, stderr = p.communicate()\n        stdout, stderr = stdout.decode(\"utf-8\"), stderr.decode(\"utf-8\")\n\n        self.assertEqual(p.returncode, 0)\n        self.assertEqual(stdout, expected)\n\n    def testTwoSocketCCD1(self):\n        expected = \" \".join([str(x) for x in range(self.cores_per_ccd, 2 * self.cores_per_ccd)])\n        expected += \" \"\n        expected += \" \".join(\n            [\n                str(x)\n                for x in range(\n                    (7 * self.cores_per_ccd) + (self.cores_per_ccd * self.num_sockets),\n                    8 * self.cores_per_ccd + (self.cores_per_ccd * self.num_sockets),\n                )\n            ]\n        )\n        expected += \" \\n\"\n\n        p = Popen(self._get_listcore_str(\"1\"), shell=True, stdout=PIPE, stderr=PIPE)\n        stdout, stderr = p.communicate()\n        stdout, stderr = stdout.decode(\"utf-8\"), stderr.decode(\"utf-8\")\n\n        self.assertEqual(p.returncode, 0)\n        self.assertEqual(stdout, expected)\n\n    # All Sockets 1P\n    def testAllSockets_1P_CCD3(self):\n        expected = \" \".join([str(x) for x in range(3 * self.cores_per_ccd, 4 * self.cores_per_ccd)])\n        expected += \" \\n\"\n        self.num_sockets = 1\n\n        p = Popen(self._get_listcore_str(\"3\"), shell=True, stdout=PIPE, stderr=PIPE)\n        stdout, stderr = p.communicate()\n        stdout, stderr = stdout.decode(\"utf-8\"), stderr.decode(\"utf-8\")\n\n        # self.assertEqual(stderr, \"\")\n        self.assertEqual(p.returncode, 0)\n        self.assertEqual(stdout, expected)\n\n    # Socket 0\n    def testSocket0All(self):\n        numCores = self.cores_per_ccd * self.ccds_per_socket\n        expected = \" \".join([str(x) for x in range(numCores)])\n        expected += \" \\n\"\n\n        p = Popen(self._get_listcore_str(\"all\", sockets=\"0\"), shell=True, stdout=PIPE, stderr=PIPE)\n        stdout, stderr = p.communicate()\n        stdout, stderr = stdout.decode(\"utf-8\"), stderr.decode(\"utf-8\")\n\n        self.assertEqual(p.returncode, 0)\n        self.assertEqual(stdout, expected)\n\n    def testSocket0Half1(self):\n        halfCoreCount = int(self.cores_per_ccd * self.ccds_per_socket / 2)\n        expected = \" \".join([str(x) for x in range(halfCoreCount, halfCoreCount * 2)])\n        expected += \" \\n\"\n\n        p = Popen(self._get_listcore_str(\"half1\", sockets=\"0\"), shell=True, stdout=PIPE, stderr=PIPE)\n        stdout, stderr = p.communicate()\n        stdout, stderr = stdout.decode(\"utf-8\"), stderr.decode(\"utf-8\")\n\n        self.assertEqual(p.returncode, 0)\n        self.assertEqual(stdout, expected)\n\n    def testSocket0Quart0(self):\n        quartCoreCount = int(self.cores_per_ccd * self.ccds_per_socket / 4)\n        expected = \" \".join([str(x) for x in range(quartCoreCount)])\n        expected += \" \\n\"\n\n        p = Popen(self._get_listcore_str(\"quart0\", sockets=\"0\"), shell=True, stdout=PIPE, stderr=PIPE)\n        stdout, stderr = p.communicate()\n        stdout, stderr = stdout.decode(\"utf-8\"), stderr.decode(\"utf-8\")\n\n        self.assertEqual(p.returncode, 0)\n        self.assertEqual(stdout, expected)\n\n    def testSocket0CCD2(self):\n        expected = \" \".join([str(x) for x in range(2 * self.cores_per_ccd, 3 * self.cores_per_ccd)])\n        expected += \" \\n\"\n\n        p = Popen(self._get_listcore_str(\"2\", sockets=\"0\"), shell=True, stdout=PIPE, stderr=PIPE)\n        stdout, stderr = p.communicate()\n        stdout, stderr = stdout.decode(\"utf-8\"), stderr.decode(\"utf-8\")\n\n        # self.assertEqual(stderr, \"\")\n        self.assertEqual(p.returncode, 0)\n        self.assertEqual(stdout, expected)\n\n    # Socket 1\n    def testSocket1All(self):\n        coresPerSocket = self.cores_per_ccd * self.ccds_per_socket\n        expected = \" \".join([str(x) for x in range(coresPerSocket, coresPerSocket * 2)])\n        expected += \" \\n\"\n\n        p = Popen(self._get_listcore_str(\"all\", sockets=\"1\"), shell=True, stdout=PIPE, stderr=PIPE)\n        stdout, stderr = p.communicate()\n        stdout, stderr = stdout.decode(\"utf-8\"), stderr.decode(\"utf-8\")\n\n        self.assertEqual(p.returncode, 0)\n        self.assertEqual(stdout, expected)\n\n    def testSocket1Half0(self):\n        coresPerSocket = self.cores_per_ccd * self.ccds_per_socket\n        expected = \" \".join([str(x) for x in range(coresPerSocket, coresPerSocket + coresPerSocket // 2)])\n        expected += \" \\n\"\n\n        p = Popen(self._get_listcore_str(\"half0\", sockets=\"1\"), shell=True, stdout=PIPE, stderr=PIPE)\n        stdout, stderr = p.communicate()\n        stdout, stderr = stdout.decode(\"utf-8\"), stderr.decode(\"utf-8\")\n\n        # self.assertEqual(stderr, \"\")\n        self.assertEqual(p.returncode, 0)\n        self.assertEqual(stdout, expected)\n\n    def testSocket1CCD5(self):\n        coresPerSocket = self.cores_per_ccd * self.ccds_per_socket\n        expected = \" \".join(\n            [\n                str(x)\n                for x in range((5 * self.cores_per_ccd) + coresPerSocket, (6 * self.cores_per_ccd) + coresPerSocket)\n            ]\n        )\n        expected += \" \\n\"\n\n        p = Popen(self._get_listcore_str(\"5\", sockets=\"1\"), shell=True, stdout=PIPE, stderr=PIPE)\n        stdout, stderr = p.communicate()\n        stdout, stderr = stdout.decode(\"utf-8\"), stderr.decode(\"utf-8\")\n\n        self.assertEqual(p.returncode, 0)\n        self.assertEqual(stdout, expected)\n\n    # Socket 0 Thread 0\n    def testSocket0Thread0(self):\n        coresPerSocket = self.cores_per_ccd * self.ccds_per_socket\n        expected = \" \".join([str(x) for x in range(coresPerSocket)])\n        expected += \" \\n\"\n\n        p = Popen(self._get_listcore_str(\"all\", sockets=\"0\", thread=\"0\"), shell=True, stdout=PIPE, stderr=PIPE)\n        stdout, stderr = p.communicate()\n        stdout, stderr = stdout.decode(\"utf-8\"), stderr.decode(\"utf-8\")\n\n        self.assertEqual(p.returncode, 0)\n        self.assertEqual(stdout, expected)\n\n    # Socket 1 Thread 0\n    def testSocket1Thread0(self):\n        coresPerSocket = self.cores_per_ccd * self.ccds_per_socket\n        expected = \" \".join([str(x) for x in range(coresPerSocket, 2 * coresPerSocket)])\n        expected += \" \\n\"\n\n        p = Popen(self._get_listcore_str(\"all\", thread=\"0\", sockets=\"1\"), shell=True, stdout=PIPE, stderr=PIPE)\n        stdout, stderr = p.communicate()\n        stdout, stderr = stdout.decode(\"utf-8\"), stderr.decode(\"utf-8\")\n\n        self.assertEqual(p.returncode, 0)\n        self.assertEqual(stdout, expected)\n\n    # Socket 0 Thread 1\n    def testSocket0Thread1(self):\n        coresPerSocket = self.cores_per_ccd * self.ccds_per_socket\n        expected = \" \".join([str(x) for x in range(2 * coresPerSocket, 3 * coresPerSocket)])\n        expected += \" \\n\"\n\n        p = Popen(self._get_listcore_str(\"all\", thread=\"1\", sockets=\"0\"), shell=True, stdout=PIPE, stderr=PIPE)\n        stdout, stderr = p.communicate()\n        stdout, stderr = stdout.decode(\"utf-8\"), stderr.decode(\"utf-8\")\n\n        self.assertEqual(p.returncode, 0)\n        self.assertEqual(stdout, expected)\n\n    # Socket 1 Thread 1\n    def testSocket1Thread1(self):\n        coresPerSocket = self.cores_per_ccd * self.ccds_per_socket\n        expected = \" \".join([str(x) for x in range(3 * coresPerSocket, 4 * coresPerSocket)])\n        expected += \" \\n\"\n\n        p = Popen(self._get_listcore_str(\"all\", thread=\"1\", sockets=\"1\"), shell=True, stdout=PIPE, stderr=PIPE)\n        stdout, stderr = p.communicate()\n        stdout, stderr = stdout.decode(\"utf-8\"), stderr.decode(\"utf-8\")\n\n        self.assertEqual(p.returncode, 0)\n        self.assertEqual(stdout, expected)", ""]}
{"filename": "unittests/test_mcecheck.py", "chunked_list": ["# MIT License\n \n# Copyright (c) 2023 Advanced Micro Devices, Inc.\n \n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:", "# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n \n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n \n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER", "# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\nfrom ctypes import c_uint64\nfrom unittest import TestCase\nfrom unittest.mock import NonCallableMagicMock, patch\n", "from unittest.mock import NonCallableMagicMock, patch\n\nfrom mce_read.MceCheck import GMCC_RegisterData, MCECheck\nfrom mce_read.MsrRegister import MSRRegister\n\n\n@patch(\"mce_read.MceCheck.CpuInfo\", autospec=True)\n@patch(\"mce_read.MceCheck.MSR_0179_GlobalMachineCheckCapabilities\", autospec=True)\nclass TestMCECheck(TestCase):\n    def setUp(self):\n        self.msrReg = NonCallableMagicMock(spec=MSRRegister)\n        self.mceCheck = MCECheck(self.msrReg)\n\n        # Base Register Addresses\n        self.statusAddr = 0xC0002001\n        self.addrAddr = 0xC0002002\n        self.misc0Addr = 0xC0002003\n        self.configAddr = 0xC0002004\n        self.ipidAddr = 0xC0002005\n        self.synd = 0xC0002006\n        self.destatAddr = 0xC0002007\n        self.deaddrAddr = 0xC0002008\n\n    def testInit(self, mcCapMock, cpuInfoMock):\n        self.assertEqual(self.mceCheck.msr, self.msrReg)\n\n    def testCheckNoMCEs(self, mcCapMock, cpuInfoMock):\n        # Setup\n        cpuInfoMock.return_value.num_logical_cores = 1\n\n        gmccRegData = NonCallableMagicMock(spec=GMCC_RegisterData)\n        numOfBanks = 5\n        gmccRegData.count = numOfBanks\n        mcCapMock.return_value.getRegister.return_value = gmccRegData\n\n        self.msrReg.read.return_value = c_uint64(0x0)\n\n        # Run\n        mces = self.mceCheck.check()\n\n        # Test\n        self.assertEqual(len(mces), 0)\n        self.msrReg.read.assert_called()\n\n    def testCheck1MCEs(self, mcCapMock, cpuInfoMock):\n        # TODO test reading each MCA Info Register\n        # Setup\n        cpuInfoMock.return_value.num_logical_cores = 128\n\n        gmccRegData = NonCallableMagicMock(spec=GMCC_RegisterData)\n        numOfBanks = 1\n        gmccRegData.count = numOfBanks\n        mcCapMock.return_value.getRegister.return_value = gmccRegData\n\n        def getMsrSideEffect(addr, coreId):\n            if coreId != 0:\n                return c_uint64(0x0)\n            else:\n                return c_uint64(0x8000000000000000)\n\n        self.msrReg.read.side_effect = getMsrSideEffect\n\n        # Run\n        mces = self.mceCheck.check()\n\n        # Test\n        self.assertEqual(len(mces), 1)\n\n    def testCheckMoreMCEs(self, mcCapMock, cpuInfoMock):\n        # Setup\n        cpuInfoMock.return_value.num_logical_cores = 5\n        gmccRegData = NonCallableMagicMock(spec=GMCC_RegisterData)\n        numOfBanks = 5\n        gmccRegData.count = numOfBanks\n        mcCapMock.return_value.getRegister.return_value = gmccRegData\n\n        def getMsrSideEffect(addr, coreId):\n            if coreId != 4:\n                return c_uint64(0x0)\n            else:\n                return c_uint64(0x8000000000000000)\n\n        self.msrReg.read.side_effect = getMsrSideEffect\n\n        # Run\n        mces = self.mceCheck.check()\n\n        # Test\n        self.assertEqual(len(mces), 5)\n\n    def testCheckBankNotCompatable(self, mcCapMock, cpuInfoMock):\n        # Setup\n        cpuInfoMock.return_value.num_logical_cores = 5\n\n        gmccRegData = NonCallableMagicMock(spec=GMCC_RegisterData)\n        gmccRegData.count = 0\n        mcCapMock.return_value.getRegister.return_value = gmccRegData\n\n        # Run & Test\n        self.assertRaises(RuntimeError, self.mceCheck.check)", "class TestMCECheck(TestCase):\n    def setUp(self):\n        self.msrReg = NonCallableMagicMock(spec=MSRRegister)\n        self.mceCheck = MCECheck(self.msrReg)\n\n        # Base Register Addresses\n        self.statusAddr = 0xC0002001\n        self.addrAddr = 0xC0002002\n        self.misc0Addr = 0xC0002003\n        self.configAddr = 0xC0002004\n        self.ipidAddr = 0xC0002005\n        self.synd = 0xC0002006\n        self.destatAddr = 0xC0002007\n        self.deaddrAddr = 0xC0002008\n\n    def testInit(self, mcCapMock, cpuInfoMock):\n        self.assertEqual(self.mceCheck.msr, self.msrReg)\n\n    def testCheckNoMCEs(self, mcCapMock, cpuInfoMock):\n        # Setup\n        cpuInfoMock.return_value.num_logical_cores = 1\n\n        gmccRegData = NonCallableMagicMock(spec=GMCC_RegisterData)\n        numOfBanks = 5\n        gmccRegData.count = numOfBanks\n        mcCapMock.return_value.getRegister.return_value = gmccRegData\n\n        self.msrReg.read.return_value = c_uint64(0x0)\n\n        # Run\n        mces = self.mceCheck.check()\n\n        # Test\n        self.assertEqual(len(mces), 0)\n        self.msrReg.read.assert_called()\n\n    def testCheck1MCEs(self, mcCapMock, cpuInfoMock):\n        # TODO test reading each MCA Info Register\n        # Setup\n        cpuInfoMock.return_value.num_logical_cores = 128\n\n        gmccRegData = NonCallableMagicMock(spec=GMCC_RegisterData)\n        numOfBanks = 1\n        gmccRegData.count = numOfBanks\n        mcCapMock.return_value.getRegister.return_value = gmccRegData\n\n        def getMsrSideEffect(addr, coreId):\n            if coreId != 0:\n                return c_uint64(0x0)\n            else:\n                return c_uint64(0x8000000000000000)\n\n        self.msrReg.read.side_effect = getMsrSideEffect\n\n        # Run\n        mces = self.mceCheck.check()\n\n        # Test\n        self.assertEqual(len(mces), 1)\n\n    def testCheckMoreMCEs(self, mcCapMock, cpuInfoMock):\n        # Setup\n        cpuInfoMock.return_value.num_logical_cores = 5\n        gmccRegData = NonCallableMagicMock(spec=GMCC_RegisterData)\n        numOfBanks = 5\n        gmccRegData.count = numOfBanks\n        mcCapMock.return_value.getRegister.return_value = gmccRegData\n\n        def getMsrSideEffect(addr, coreId):\n            if coreId != 4:\n                return c_uint64(0x0)\n            else:\n                return c_uint64(0x8000000000000000)\n\n        self.msrReg.read.side_effect = getMsrSideEffect\n\n        # Run\n        mces = self.mceCheck.check()\n\n        # Test\n        self.assertEqual(len(mces), 5)\n\n    def testCheckBankNotCompatable(self, mcCapMock, cpuInfoMock):\n        # Setup\n        cpuInfoMock.return_value.num_logical_cores = 5\n\n        gmccRegData = NonCallableMagicMock(spec=GMCC_RegisterData)\n        gmccRegData.count = 0\n        mcCapMock.return_value.getRegister.return_value = gmccRegData\n\n        # Run & Test\n        self.assertRaises(RuntimeError, self.mceCheck.check)", ""]}
{"filename": "unittests/test_msrregister.py", "chunked_list": ["# MIT License\n \n# Copyright (c) 2023 Advanced Micro Devices, Inc.\n \n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:", "# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n \n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n \n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER", "# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\nfrom ctypes import c_uint32, c_uint64\nfrom os import O_RDWR\nfrom unittest import TestCase, skip\nfrom unittest.mock import call, patch", "from unittest import TestCase, skip\nfrom unittest.mock import call, patch\n\nfrom mce_read.MsrRegister import MSRRegister, PerCoreMSRRegister\n\n\nclass TestMSRRegister(TestCase):\n    def setUp(self):\n        pass\n\n    @patch(\"mce_read.MsrRegister.os.open\", autospec=True)\n    def testPerCoreInit(self, openMock):\n        # Setup\n        cpuNum = 9\n\n        # Test\n        reg = PerCoreMSRRegister(cpuNum)\n\n        # Check Results\n        self.assertEqual(reg.core_id, cpuNum)\n        openMock.assert_called_with(\"/dev/cpu/{}/msr\".format(cpuNum), O_RDWR)\n        self.assertEqual(reg._fd, openMock.return_value)\n\n    @patch(\"mce_read.MsrRegister.os.open\", autospec=True)\n    def testPerCoreOSError(self, openMock):\n        # Setup\n        cpuNum = 9\n        openMock.side_effect = OSError(\"Mock OSError on open\")\n\n        # Test & Check Results\n        # Patch logger to ignore warning in __del__ function\n        with patch(\"mce_read.MsrRegister.logger\", autospec=True):\n            self.assertRaises(RuntimeError, PerCoreMSRRegister, cpuNum)\n\n    @patch(\"mce_read.MsrRegister.os\", autospec=True)\n    def testGetCoreId(self, openMock):\n        # Setup\n        cpuId = 5\n        # Run\n        reg = PerCoreMSRRegister(cpuId)\n        # Test\n        self.assertEqual(reg.getCoreId(), cpuId)\n\n    @patch(\"mce_read.MsrRegister.os\", autospec=True)\n    def testRead(self, osMock):\n        # Setup\n        cpuId = 45\n        regAddr = c_uint32(0xF0)\n        regData = bytes.fromhex(\"2B\")\n        osMock.pread.return_value = regData\n        osMock.open.return_value = 5\n        reg = PerCoreMSRRegister(cpuId)\n        # Run\n        data = reg.read(regAddr)\n        # Test\n        self.assertEqual(data, regData)\n\n    @patch(\"mce_read.MsrRegister.os\", autospec=True)\n    def testReadZeroFD(self, osMock):\n        # Setup\n        cpuId = 45\n        regAddr = c_uint32(0xF0)\n        regData = bytes.fromhex(\"2B\")\n        osMock.pread.return_value = regData\n        osMock.open.return_value = -1\n        reg = PerCoreMSRRegister(cpuId)\n        # Run & Test\n        self.assertRaises(RuntimeError, reg.read, regAddr)\n\n    @patch(\"mce_read.MsrRegister.os\", autospec=True)\n    def testReadOSError(self, osMock):\n        # Setup\n        cpuId = 45\n        regAddr = c_uint32(0xF0)\n        osMock.pread.side_effect = OSError\n        osMock.open.return_value = 1\n        reg = PerCoreMSRRegister(cpuId)\n        # Run & Test\n        self.assertRaises(RuntimeError, reg.read, regAddr)\n\n    @skip(\"Write not successfully implemented\")\n    @patch(\"mce_read.MsrRegister.os\", autospec=True)\n    def testWrite(self, osMock):\n        # Setup\n        cpuId = 45\n        regAddr = c_uint32(0xF0)\n        regData = c_uint64(0x12BB49FC1A6B3C)\n        osMock.pwrite.return_value = None\n        osMock.open.return_value = 5\n        osMock.close.return_value = None\n        reg = PerCoreMSRRegister(cpuId)\n        # Run\n        reg.write(regAddr, regData)\n        # Test\n        osMock.pwrite.assert_called_with(reg._fd, b\"0x12BB49FC1A6B3C4D\", regData)\n\n    @skip(\"Write not successfully implemented\")\n    @patch(\"mce_read.MsrRegister.os\", autospec=True)\n    def testwriteZeroFD(self, osMock):\n        # Setup\n        cpuId = 45\n        regAddr = c_uint32(0xF0)\n        regData = c_uint64(0x12BC49FC1A6B3C4D)\n        osMock.pwrite.return_value = regData\n        osMock.open.return_value = -1\n        reg = PerCoreMSRRegister(cpuId)\n        # Run & Test\n        self.assertRaises(RuntimeError, reg.write, regAddr, regData)\n\n    @skip(\"Write not successfully implemented\")\n    @patch(\"mce_read.MsrRegister.os\", autospec=True)\n    def testwriteOSError(self, osMock):\n        # Setup\n        cpuId = 45\n        regData = c_uint64(0x12BC49FC1A6B3C4D)\n        regAddr = c_uint32(0xF0)\n        osMock.pwrite.side_effect = OSError\n        osMock.open.return_value = 1\n        reg = PerCoreMSRRegister(cpuId)\n        # Run & Test\n        self.assertRaises(RuntimeError, reg.write, regAddr, regData)\n\n    @patch(\"mce_read.MsrRegister.PerCoreMSRRegister\", autospec=True)\n    def testMSRRegisterInit(self, perCoreMock):\n        # Setup\n        numCores = 20\n        # Run\n        reg = MSRRegister(numCores)\n        # Test\n        self.assertEqual(len(reg.perCoreMsrRegister), numCores)\n        perCoreMock.assert_has_calls([call(c) for c in range(numCores)], any_order=True)\n\n    @patch(\"mce_read.MsrRegister.PerCoreMSRRegister\", autospec=True)\n    def testMsrRegisterRead(self, perCoreMock):\n        # Setup\n        numCores = 200\n        regAddr = c_uint32(0xF0)\n        reg = MSRRegister(numCores)\n        perCoreMock.return_value.read.return_value = b\"\\xFF\"\n        # Run\n        retVal = reg.read(regAddr, 0)\n        # Test\n        perCoreMock.return_value.read.assert_called()\n        self.assertEqual(retVal, 255)\n\n    @patch(\"mce_read.MsrRegister.PerCoreMSRRegister\", autospec=True)\n    def testMsrRegisterReadInvalidCore(self, perCoreMock):\n        # Setup\n        numCores = 9\n        regAddr = c_uint32(0xF0)\n\n        # Run\n        reg = MSRRegister(numCores)\n\n        # Test\n        self.assertRaises(RuntimeError, reg.read, regAddr, 99)\n\n    @skip(\"Write not successfully implemented\")\n    @patch(\"mce_read.MsrRegister.PerCoreMSRRegister\", autospec=True)\n    def testMsrRegisterwrite(self, perCoreMock):\n        # Setup\n        numCores = 200\n        regAddr = c_uint32(0xF0)\n        regData = c_uint64(0x12BC49FC1A6B3C4D)\n        reg = MSRRegister(numCores)\n        perCoreMock.write.return_value = b\"\\xFF\"\n        # Run\n        retVal = reg.write(regAddr, regData, 0)\n        # Test\n        self.assertEquals(retVal, 255)\n\n    @skip(\"Write not successfully implemented\")\n    @patch(\"mce_read.MsrRegister.PerCoreMSRRegister\", autospec=True)\n    def testMsrRegisterwriteInvalidCore(self, perCoreMock):\n        # Setup\n        numCores = 9\n        regAddr = c_uint32(0xF0)\n        regData = c_uint64(0x12BC49FC1A6B3C4D)\n\n        # Run\n        reg = MSRRegister(numCores)\n\n        # Test\n        self.assertRaises(RuntimeError, reg.write, regAddr, regData, 99)", ""]}
{"filename": "param_iterators/BinaryIter.py", "chunked_list": ["# MIT License\n \n# Copyright (c) 2023 Advanced Micro Devices, Inc.\n \n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:", "# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n \n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n \n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER", "# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\nfrom param_iterators.ParamIter import ParamIter\n\n\nclass BinaryIter(ParamIter):\n    \"\"\"Iterates True and False\"\"\"\n\n    def __init__(self, name, subscribers=[]):\n        self.count = 0\n        self.val = [True, False]\n        self.name = name\n        super().__init__(subscribers)\n\n    def __iter__(self):\n        return self\n\n    def resetCount(self, resetSubs=False):\n        self.count = 0\n        super().resetCount(resetSubs)\n\n    def current(self):\n        return self.val[self.count]\n\n    def __str__(self):\n        return self.name", "\nclass BinaryIter(ParamIter):\n    \"\"\"Iterates True and False\"\"\"\n\n    def __init__(self, name, subscribers=[]):\n        self.count = 0\n        self.val = [True, False]\n        self.name = name\n        super().__init__(subscribers)\n\n    def __iter__(self):\n        return self\n\n    def resetCount(self, resetSubs=False):\n        self.count = 0\n        super().resetCount(resetSubs)\n\n    def current(self):\n        return self.val[self.count]\n\n    def __str__(self):\n        return self.name", ""]}
{"filename": "param_iterators/__init__.py", "chunked_list": [""]}
{"filename": "param_iterators/ParamIter.py", "chunked_list": ["# MIT License\n \n# Copyright (c) 2023 Advanced Micro Devices, Inc.\n \n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:", "# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n \n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n \n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER", "# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\nfrom abc import abstractmethod\n\nfrom logger import logger\nfrom param_iterators.IterPublisher import IterPublisher", "from logger import logger\nfrom param_iterators.IterPublisher import IterPublisher\nfrom param_iterators.IterSubscriber import IterSubscriber\n\n\nclass ParamIter(IterPublisher, IterSubscriber):\n    \"\"\"Iterator Super class for different types of Iterators\n\n    Iterators should be publishers and subscribers.\n    When Update gets called, they should iterate and if there are subscribers,\n    they should notify the subscribers to iterate and reset it's count unless the subscribers\n    are all finished iterating(raise StopIteration)\n\n    Methods:\n        update()->None: Updates the count of iterator, if count is greater than max count,\n            then it notifies subscribers, if no subscribers raise StopIteration\n        resetCount(resetSubs)->None: Resets the iterator to zero, if resetSubs is true, then it also resets\n            all subscribers\n        current()->Object: gets the current value of the iterator\n    \"\"\"\n\n    def __init__(self, subscribers=[], controller=None):\n        self.controller = controller\n        if self.controller:\n            # The controller should set the current value immediately\n            # for example if psm is set to -11, we should set the value on the controller before doing anything else\n            self.controller.update(self.current())\n        super().__init__(subscribers)\n\n    def update(self):\n        logger.debug(\"Param Iter Update\")\n        self.count += 1\n        try:\n            self.current()\n            if self.controller:\n                logger.debug(\"A controller exists, updating controller: {}\".format(self.controller))\n                self.controller.update(self.current())\n        except (StopIteration, IndexError):\n            logger.debug(\"Exception Raised, notifying subscribers\")\n            notified = self.notify()\n            if notified:\n                logger.debug(\"Subscribers notified, reset count\")\n                self.count = 0\n                self.resetCount()\n            else:\n                logger.debug(\"No Subscribers, raise exception\")\n                raise StopIteration\n\n    def resetCount(self, resetSubs=False):\n        if not resetSubs:\n            return\n        for sub in self.subscribers:\n            if isinstance(sub, ParamIter):\n                sub.resetCount()\n\n    @abstractmethod\n    def current(self):\n        pass", ""]}
{"filename": "param_iterators/IterPublisher.py", "chunked_list": ["# MIT License\n \n# Copyright (c) 2023 Advanced Micro Devices, Inc.\n \n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:", "# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n \n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n \n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER", "# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\nfrom logger import logger\nfrom param_iterators.IterSubscriber import IterSubscriber\n\n\nclass IterPublisher:\n    \"\"\"Publisher that calls update on Subscribers\n\n    Implement this class to make an Iterator able to notify another iterator(subscriber) when it needs to update\n    \"\"\"\n\n    def __init__(self, subscribers=[]):\n        logger.debug(\"Initialized {} with subscribers: {}\".format(self, subscribers))\n        self.subscribers = subscribers\n\n    def addSubscriber(self, subscriber):\n        if not isinstance(subscriber, IterSubscriber):\n            raise RuntimeError(\n                \"Attempted to add subscriber \"\n                + \"'{}' that doesn't \".format(subscriber.__class__)\n                + \"inherit IterSubscriber\"\n            )\n        self.subscribers.append(subscriber)\n\n    def removeSubscriber(self, subscriber):\n        self.subscribers.remove(subscriber)\n\n    def notify(self):\n        \"\"\"Notifies all subscribers to incrment.\n\n        Returns if any subscribers were notified\n        \"\"\"\n        if len(self.subscribers) == 0:\n            return False\n        for sub in self.subscribers:\n            sub.update()\n\n        return True", "\n\nclass IterPublisher:\n    \"\"\"Publisher that calls update on Subscribers\n\n    Implement this class to make an Iterator able to notify another iterator(subscriber) when it needs to update\n    \"\"\"\n\n    def __init__(self, subscribers=[]):\n        logger.debug(\"Initialized {} with subscribers: {}\".format(self, subscribers))\n        self.subscribers = subscribers\n\n    def addSubscriber(self, subscriber):\n        if not isinstance(subscriber, IterSubscriber):\n            raise RuntimeError(\n                \"Attempted to add subscriber \"\n                + \"'{}' that doesn't \".format(subscriber.__class__)\n                + \"inherit IterSubscriber\"\n            )\n        self.subscribers.append(subscriber)\n\n    def removeSubscriber(self, subscriber):\n        self.subscribers.remove(subscriber)\n\n    def notify(self):\n        \"\"\"Notifies all subscribers to incrment.\n\n        Returns if any subscribers were notified\n        \"\"\"\n        if len(self.subscribers) == 0:\n            return False\n        for sub in self.subscribers:\n            sub.update()\n\n        return True", ""]}
{"filename": "param_iterators/DictIter.py", "chunked_list": ["# MIT License\n \n# Copyright (c) 2023 Advanced Micro Devices, Inc.\n \n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:", "# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n \n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n \n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER", "# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\nfrom param_iterators.ParamIter import ParamIter\n\n\nclass DictIter(ParamIter):\n    def __init__(self, valDict, name, subscribers=[]):\n        self.count = 0\n        self.valDict = valDict\n        self.name = name\n        self.maxCount = len(self.valDict.keys())\n        super().__init__(subscribers)\n\n    def __iter__(self):\n        return self\n\n    def resetCount(self, resetSubs=False):\n        self.count = 0\n        super().resetCount(resetSubs)\n\n    def current(self):\n        if self.count >= self.maxCount:\n            raise StopIteration\n\n        key = [*self.valDict][self.count]\n        val = self.valDict[key]\n        return key, val\n\n    def __str__(self):\n        return f\"{self.name} {self.valDict}\"", "\nclass DictIter(ParamIter):\n    def __init__(self, valDict, name, subscribers=[]):\n        self.count = 0\n        self.valDict = valDict\n        self.name = name\n        self.maxCount = len(self.valDict.keys())\n        super().__init__(subscribers)\n\n    def __iter__(self):\n        return self\n\n    def resetCount(self, resetSubs=False):\n        self.count = 0\n        super().resetCount(resetSubs)\n\n    def current(self):\n        if self.count >= self.maxCount:\n            raise StopIteration\n\n        key = [*self.valDict][self.count]\n        val = self.valDict[key]\n        return key, val\n\n    def __str__(self):\n        return f\"{self.name} {self.valDict}\"", ""]}
{"filename": "param_iterators/ListIter.py", "chunked_list": ["# MIT License\n \n# Copyright (c) 2023 Advanced Micro Devices, Inc.\n \n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:", "# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n \n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n \n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER", "# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\nfrom param_iterators.ParamIter import ParamIter\n\n\nclass ListIter(ParamIter):\n    def __init__(self, items, name, subscribers=[], controller=None):\n        self.count = 0\n        self.items = items\n        self.name = name\n        super().__init__(subscribers, controller)\n\n    def resetCount(self, resetSubs=False):\n        self.count = 0\n        super().resetCount(resetSubs)\n\n    def current(self):\n        return self.items[self.count]\n\n    def __str__(self):\n        return \"{} {}\".format(self.name, self.items)", "\nclass ListIter(ParamIter):\n    def __init__(self, items, name, subscribers=[], controller=None):\n        self.count = 0\n        self.items = items\n        self.name = name\n        super().__init__(subscribers, controller)\n\n    def resetCount(self, resetSubs=False):\n        self.count = 0\n        super().resetCount(resetSubs)\n\n    def current(self):\n        return self.items[self.count]\n\n    def __str__(self):\n        return \"{} {}\".format(self.name, self.items)", ""]}
{"filename": "param_iterators/IterSubscriber.py", "chunked_list": ["# MIT License\n \n# Copyright (c) 2023 Advanced Micro Devices, Inc.\n \n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:", "# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n \n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n \n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER", "# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\nfrom abc import ABC, abstractmethod\n\n\nclass IterSubscriber(ABC):\n    \"\"\"Subscriber that gets calls by Publisher\n\n    Implement this class to make an Iterator able to get notified by another iterator(publisher) when it needs to update\n    \"\"\"\n\n    @abstractmethod\n    def update(self):\n        pass", "\nclass IterSubscriber(ABC):\n    \"\"\"Subscriber that gets calls by Publisher\n\n    Implement this class to make an Iterator able to get notified by another iterator(publisher) when it needs to update\n    \"\"\"\n\n    @abstractmethod\n    def update(self):\n        pass", ""]}
{"filename": "param_iterators/DictListIter.py", "chunked_list": ["# MIT License\n \n# Copyright (c) 2023 Advanced Micro Devices, Inc.\n \n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:", "# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n \n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n \n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER", "# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\nfrom logger import logger\nfrom param_iterators.ParamIter import ParamIter\n\n\nclass DictListIter(ParamIter):\n    def __init__(self, valDict, name, subscribers=[]):\n        logger.debug(f\"Initializing {name} with {valDict}\")\n        self.count = 0\n        self.valDict = valDict\n        self.name = name\n        self.maxCount = 0\n        for key, val in valDict.items():\n            self.maxCount += len(val)\n        super().__init__(subscribers)\n\n    def __iter__(self):\n        return self\n\n    def resetCount(self, resetSubs=False):\n        self.count = 0\n        super().resetCount(resetSubs)\n\n    def current(self):\n        logger.debug(f\"Getting current {self.name} with count {self.count} max count: {self.maxCount}\")\n        if self.count >= self.maxCount:\n            raise StopIteration\n\n        keyLen = len(self.valDict.keys())\n        key = [*self.valDict][self.count % keyLen]\n\n        valOptLen = len(self.valDict[key])\n        valOptIndex = int(self.count / keyLen) % valOptLen\n\n        return key, self.valDict[key][valOptIndex]\n\n    def __str__(self):\n        return f\"{self.name} {self.valDict}\"", "\n\nclass DictListIter(ParamIter):\n    def __init__(self, valDict, name, subscribers=[]):\n        logger.debug(f\"Initializing {name} with {valDict}\")\n        self.count = 0\n        self.valDict = valDict\n        self.name = name\n        self.maxCount = 0\n        for key, val in valDict.items():\n            self.maxCount += len(val)\n        super().__init__(subscribers)\n\n    def __iter__(self):\n        return self\n\n    def resetCount(self, resetSubs=False):\n        self.count = 0\n        super().resetCount(resetSubs)\n\n    def current(self):\n        logger.debug(f\"Getting current {self.name} with count {self.count} max count: {self.maxCount}\")\n        if self.count >= self.maxCount:\n            raise StopIteration\n\n        keyLen = len(self.valDict.keys())\n        key = [*self.valDict][self.count % keyLen]\n\n        valOptLen = len(self.valDict[key])\n        valOptIndex = int(self.count / keyLen) % valOptLen\n\n        return key, self.valDict[key][valOptIndex]\n\n    def __str__(self):\n        return f\"{self.name} {self.valDict}\"", ""]}
{"filename": "system_config/SystemConfig.py", "chunked_list": ["# MIT License\n \n# Copyright (c) 2023 Advanced Micro Devices, Inc.\n \n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:", "# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n \n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n \n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER", "# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\nimport atexit\nimport os\nimport resource\nimport shutil", "import resource\nimport shutil\nfrom datetime import datetime\nfrom subprocess import PIPE, Popen\nfrom time import sleep\n\nfrom logger import logger\nfrom mce_read.MceCheck import MCECheck\nfrom mce_read.MsrRegister import MSRRegister\nfrom system_config.cpuinfo import CpuInfo", "from mce_read.MsrRegister import MSRRegister\nfrom system_config.cpuinfo import CpuInfo\n\n\nclass SystemConfig:\n    \"\"\"Contains information about the System and  Test Configuration\n\n    Attributes:\n        runDir: Directory where `list_core.sh` is located\n        logDir: Directory containing all log files\n        checkDMESG: Boolean to signify if DMESG is checked for MCEs\n        testConfigs: List of TestConfig\n        cpuInfo: CpuInfo containing information about the core configuration\n        coreConfig: Configurations on how to allcoate the run of the tests on the CPU\n        isConstantMceChecking: Boolean to determine if we should check for MCE after every command\n        _mceChecker: reads msr registers to check for MCEs with the `check()` instance method\n\n    Methods:\n        clearMCEs(): Tells OS to flush MCEs\n        checkMCEs()->[]: Check for MCEs and returns a list of all MCEs detected\n    Protected Methods:\n        _importSettings(configData)->None\n        _importTests(configData)->None\n        _importCoreConfig(configData)->None\n        _checkRoot()->None\n        _checkDependencies()->None\n        _importConfig(configPath)->None\n        _importJson(configPath)->dict\n        _importYml(configPath)->dict\n        _setCheckInterval()->None\n        _setResourceLimits()->None\n    \"\"\"\n\n    def __init__(\n        self,\n        config,\n        runDir,\n        logDir,\n    ):\n        \"\"\"Saves config file in a structured way\n\n        Handles all the different options in the command line, config file,\n        and checks the system meets the requirements in order for the framework\n        to correctly function\n\n        Args:\n            config: string of the location of the config YAML or JSON file\n            runDir: string of directory containing `list_cores.sh`\n\n        Raises:\n            RuntimeError: An error has occurred reading the configuration\n                or with the system configuration\n        \"\"\"\n\n        self._checkDependencies()\n\n        self.startTime = datetime.now()\n\n        self.cpuInfo = CpuInfo()\n\n        self.testConfigs = []\n\n        self.runDir = runDir\n        self.logDir = logDir\n\n        self._setCheckInterval()\n        atexit.register(self._setCheckInterval, 10000)\n\n        self._importConfig(config)\n\n        self._setupMCEDetection()\n\n        # debug printing settings\n        logger.debug(\"La Hacienda input variables:\")\n        logger.debug(\"Run Directory: {}\".format(self.runDir))\n        logger.debug(\"Start Time: {}\".format(self.startTime))\n        logger.debug(\"Log Directory: {}\".format(self.logDir))\n\n    def checkMCEs(self, force=False):\n        if self.isConstantMceChecking or force:\n            return self._mceChecker.check()\n        else:\n            return []\n\n    def clearMCEs(self):\n        \"\"\"Tells the OS to read any MCE's and clear after reading.\n\n        Changes check interval to 1, sleeps, then sets to 10000 to\n        flush MCEs then prevent MCEs from being caught and cleared during execution\n        Disclaimer: There is currently a kernel bug that makes the MCE dissapear,\n        but this is a known issue and currently being worked.\n        \"\"\"\n        logger.warning(\"Flushing MCEs. This will cause previous MCEs to show up in the OS's DMESG\")\n        logger.warning(\n            \"On earlier kernels, this does not function as intended and will cause the OS to `clear` the MCE without\"\n            \" outputing to DMESG\"\n        )\n        self._setCheckInterval(1)\n        sleep(2)\n        self._setCheckInterval()\n\n    def _importSettings(self, configData):\n        \"\"\"Imports the tool level settings\n\n        Args:\n            configData: Dictionary from config file definied in README.md\n        \"\"\"\n        # Log Directory\n        if not self.logDir:\n            self.logDir = configData[\"Log_Directory\"]\n        logger.set_log_dir(self.logDir)\n\n        # Logging Level\n        if \"Log_Level\" in configData:\n            if configData[\"Log_Level\"] == \"Bare\":\n                logger.set_log_level(logger.BARE)\n            elif configData[\"Log_Level\"] == \"All\":\n                logger.set_log_level(logger.ALL)\n            elif configData[\"Log_Level\"] == \"Excess\":\n                logger.set_log_level(logger.EXCESS)\n            elif configData[\"Log_Level\"] == \"Debug\":\n                logger.set_log_level(logger.DEBUG)\n            else:\n                logger.set_log_level(logger.DEBUG)\n                logger.warning(\"Log level '{}' invalid\".format(configData[\"Log_Level\"]))\n                logger.warning(\"Valid log levels are: Bare, All, Excess, or Debug\")\n                logger.warning(\"Setting Log Level to 'DEBUG'\")\n        else:\n            # Default log level if not provied\n            logger.set_log_level(logger.ALL)\n            logger.warning(\"No log level specified in configuration or command line setting log level to default\")\n\n        logger.info(\"Set log level to: {}\".format(logger.level))\n\n        # Run Directory\n        if not self.runDir:\n            self.runDir = configData[\"Run_Directory\"]\n\n        if \"Constant_MCE_Checking\" in configData:\n            self.isConstantMceChecking = configData[\"Constant_MCE_Checking\"]\n        else:\n            # Default is to check after every command\n            self.isConstantMceChecking = True\n\n        if self.isConstantMceChecking:\n            logger.warning(\n                \"Checking for MCE's after every command will result in MCE's being logged in the output for the failing\"\n                \" command AND all commands after, because the MCE will not be cleared. The MCE is not cleared to allow\"\n                \" the OS to catch the MCE\"\n            )\n\n    def _importTests(self, configData):\n        \"\"\"Import and Test arguments in configuration file\n\n        Takes the configuration file and verifies that is correctly formed\n\n        Args:\n            configData: Dictionary of the sturture of the configuration file\n\n        Raises:\n            RuntimeError: A unexpected configuration was specifed.\n        \"\"\"\n\n        try:\n            # General Test Data:\n            if \"Tests\" in configData:\n                for test in configData[\"Tests\"]:\n                    self.testConfigs.append(TestConfig(test))\n            if len(self.testConfigs) == 0:\n                raise RuntimeError(\"No tests found in configuration. See README for help.\")\n        except KeyError as e:\n            logger.error(\"Failed to get required YAML Attribute: {}\".format(e.args[0]))\n            raise RuntimeError(\"Settings YAML file is incorrect\")\n\n    def _importCoreConfig(self, configData):\n        \"\"\"Imports all the core configuration\"\"\"\n        try:\n            coreConfig = configData[\"Core_Config\"]\n        except KeyError:\n            logger.error(\"Missing 'Core_Config' option in configuration file.\")\n            raise RuntimeError(\"Incorrect configuration file. Please see 'README.md' for required format\")\n        self.coreConfig = CoreConfig(coreConfig, self.cpuInfo, self.runDir)\n\n    def _checkRoot(self):\n        # Check root user\n        rootCmd = \"whoami\"\n        p = Popen(rootCmd, shell=True, stdout=PIPE, stderr=PIPE)\n        stdout, stderr = p.communicate()\n        returncode = p.returncode\n        if returncode != 0 or stdout.decode(\"utf-8\").strip(\"\\n\") != \"root\":\n            raise RuntimeError(\"You must execute the script as root to use MSR options, exiting...\")\n\n    def _checkDependencies(self):\n        \"\"\"Checks for recommended dependencies for La Hacienda\n\n        Dependencies that are required will raise a RuntimeError others will log a warning\n\n        Raises:\n            RuntimeError: When a required dependency is not met\n        \"\"\"\n        # Check EDAC module support\n        edacCmd = \"lsmod | grep -i -c edac\"\n        p = Popen(edacCmd, shell=True, stdout=PIPE, stderr=PIPE)\n        stdout, stderr = p.communicate()\n        returncode = p.returncode\n        if (returncode != 0 or int(stdout.decode(\"utf-8\")) == 0) and not os.path.isdir(\n            \"/sys/devices/system/edac/mc/mc0\"\n        ):\n            raise RuntimeError(\"No kernel module found for edac (Error Detection and Correction) found, exiting...\")\n\n        # Virtual Address space randomization disabled\n        vrandCmd = \"cat /proc/sys/kernel/randomize_va_space\"\n        p = Popen(vrandCmd, shell=True, stdout=PIPE, stderr=PIPE)\n        stdout, stderr = p.communicate()\n        returncode = p.returncode\n        if returncode != 0 or int(stdout.decode(\"utf-8\")) != 0:\n            logger.warning(\"/proc/sys/kernel/randomize_va_space not set to 0 (disabled)\")\n\n        # Check fatal signals enabled\n        fatalSigCmd = \"cat /proc/sys/kernel/print-fatal-signals\"\n        p = Popen(fatalSigCmd, shell=True, stdout=PIPE, stderr=PIPE)\n        stdout, stderr = p.communicate()\n        returncode = p.returncode\n        if returncode != 0 or int(stdout.decode(\"utf-8\").strip(\"\\n\")) != 1:\n            logger.warning(\"/proc/sys/kernel/print-fatal-signals not set to 1 (enabled)\")\n\n        # Check NUMABALANCING\n        numaCmd = \"cat /proc/sys/kernel/numa_balancing\"\n        p = Popen(numaCmd, shell=True, stdout=PIPE, stderr=PIPE)\n        stdout, stderr = p.communicate()\n        returncode = p.returncode\n        if returncode != 0 or int(stdout.decode(\"utf-8\")) != 0:\n            logger.warning(\"/proc/sys/kernel/numa_balancing not set to 0 (disabled)\")\n\n        # Check NUMACTL\n        numaCtlCmd = \"numactl -s\"\n        p = Popen(numaCtlCmd, shell=True, stdout=PIPE, stderr=PIPE)\n        stdout, stderr = p.communicate()\n        returncode = p.returncode\n        if returncode != 0:\n            raise RuntimeError(\n                \"'numactl' is not in your $PATH variable. Please ensure 'numactl' is installed and in $PATH\"\n            )\n\n    def _importConfig(self, configPath):\n        \"\"\"determinies what configuration input the user is using and calls the function\n        to import that configuration as a dictionary\n\n        Args:\n            configPath: path to configuration file\n        \"\"\"\n        configDict = {}\n        if os.path.isfile(configPath):\n            # Configuration is either yaml or json file\n            fileExt = os.path.splitext(configPath)[1]\n            if fileExt == \".json\":\n                configDict = self._importJson(configPath)\n            elif fileExt == \".yaml\" or fileExt == \".yml\":\n                configDict = self._importYml(configPath)\n            else:\n                raise RuntimeError(\n                    \"La Hacienda only supports YAML or JSON files, however filename is {}\".format(configPath)\n                )\n        else:\n            # Configuration is a JSON string\n            import json\n\n            try:\n                configDict = json.loads(configPath)\n            except json.JSONDecodeError as e:\n                raise RuntimeError(\"Failed to load JSON settings string: {}, {}\".format(configPath, e))\n\n        # Import the settings:\n        try:\n            self._importSettings(configDict)\n            self._importTests(configDict)\n            self._importCoreConfig(configDict)\n        except KeyError as e:\n            raise RuntimeError(\n                \"Failed to import configuration file, please ensure you have specified all required Parameters in\"\n                \" configuration file. {}\".format(e)\n            )\n\n    def _importJson(self, configPath):\n        \"\"\"Imports JSON config file\"\"\"\n        import json\n\n        try:\n            with open(configPath) as jsonFile:\n                jsonData = json.load(jsonFile)\n        except json.JSONDecodeError as e:\n            raise RuntimeError(\"Failed to load JSON settings file: {}, {}\".format(configPath, e))\n        return jsonData\n\n    def _importYml(self, ymlPath):\n        \"\"\"Imports YAML config file\"\"\"\n        try:\n            import yaml\n        except ImportError:\n            raise RuntimeError(\"Unable to import PyYAML. Please ensure you have installed PyYAML with pip\")\n\n        try:\n            with open(ymlPath) as ymlFile:\n                ymlData = yaml.safe_load(ymlFile)\n        except yaml.YAMLError as e:\n            raise RuntimeError(\"Failed to load YAML settings file: {}, {}\".format(ymlPath, e))\n        return ymlData\n\n    def _setCheckInterval(self, intervalVal: int = 1000000):\n        \"\"\"\n        Set machine check interval very high so it doesn't interfere with Tim's test catching MCEs\n        \"\"\"\n        checkIntervalFile = \"/sys/devices/system/machinecheck/machinecheck0/check_interval\"\n        with open(checkIntervalFile, \"w\") as mc:\n            mc.write(str(intervalVal))\n\n    def _setResourceLimits(self):\n        \"\"\"Sets resource limits\n\n        unable to set LOCKS or NOFILE limits\n        \"\"\"\n        limit = (resource.RLIM_INFINITY, resource.RLIM_INFINITY)\n        resource.setrlimit(resource.RLIMIT_AS, limit)\n        resource.setrlimit(resource.RLIMIT_CORE, limit)\n        resource.setrlimit(resource.RLIMIT_CPU, limit)\n        resource.setrlimit(resource.RLIMIT_DATA, limit)\n        resource.setrlimit(resource.RLIMIT_FSIZE, limit)\n        # resource.setrlimit(resource.RLIMIT_LOCKS, limit)\n        resource.setrlimit(resource.RLIMIT_MEMLOCK, limit)\n        resource.setrlimit(resource.RLIMIT_NPROC, limit)\n        resource.setrlimit(resource.RLIMIT_RSS, limit)\n        resource.setrlimit(resource.RLIMIT_SIGPENDING, limit)\n        resource.setrlimit(resource.RLIMIT_STACK, limit)\n\n        # flimit = (10000000, 10000000)\n        # resource.setrlimit(resource.RLIMIT_NOFILE, flimit)\n\n    def _setupMCEDetection(self):\n        \"\"\"Sets up the _mceChecker to check for MCEs after each command\"\"\"\n        self._setResourceLimits()\n        msrReg = MSRRegister(self.cpuInfo.num_logical_cores)\n        self._mceChecker = MCECheck(msrReg)", "\n\nclass CoreConfig:\n    \"\"\"Contains the configuration where to run the tests.\n\n    Attributes:\n        sockets: list of values for sockets\n        smt: list of values for SMT, valid values are boolean\n        cores: list of values for Cores division to run each time.\n\n        _listCoreFile: location of the list_cores.sh file\n\n    Methods:\n        _getCoreList(partition, threadList, sockets): returns the list of cores for the division\n\n        _getItemAsList(item): options that can be either a boolean or list and converts it to the appropriate format\n        _checkConfigIntegrity(): ensures that there are two sockets if two sockets are specified the Core_Config\n    \"\"\"\n\n    def __init__(self, configDict, cpuInfo, runDir):\n        \"\"\"Checks vality of configDict from configDict\n\n        Options looking for in configDict\n            Sockets: (optional, defaults to all)\n            SMT: bool\n            All: bool\n            Halfs: bool/list of ints\n            Quarters: bool/list of ints\n            CCDs: bool/list of ints\n            Cores: bool/list of ints\n\n        Args:\n            configDict: Dictionary containing all required keys and values for the Core_Config\n            cpuInfo: CPUInfo class containing CPU Topology\n            runDir: directory containing list_cores.sh\n\n        Raises:\n            RuntimeError: if a configuration doesn't have the required keys or format\n        \"\"\"\n        self.cpuInfo = cpuInfo\n\n        # SMT\n        try:\n            self.smt = configDict[\"SMT\"]\n        except KeyError:\n            raise RuntimeError(\"Incorrect config file format, 'SMT' requried to be specified in 'Core_Config'.\")\n\n        self._checkConfigIntegrity(configDict)\n\n        self._listCoreFile = \"{}/list_cores.sh\".format(runDir)\n        self.sockets = []\n        if \"Sockets\" in configDict:\n            sockets = self._getItemAsList(configDict[\"Sockets\"])\n            for s in sockets:\n                if isinstance(s, list) and len(s) == 2:\n                    # already vetted that sockets only contains the correct values\n                    # in the _checkConfigIntegrity function\n                    self.sockets.append(\"all\")\n                else:\n                    self.sockets.append(str(s))\n        else:\n            logger.info(\"Sockets not specified in configuration file, setting to all\")\n            self.sockets = [\"all\"]\n\n        self.cores = []\n        coreDivisions = []\n        threadlist = [0, 1] if self.smt else [0]\n\n        if \"All\" in configDict and configDict[\"All\"]:\n            if not isinstance(configDict[\"All\"], bool):\n                raise RuntimeError(\n                    \"Unknown type for 'All' division in 'Cores_Config'. Only, boolean values are supported\"\n                )\n            coreDivisions.append(\"all\")\n        if \"Halfs\" in configDict:\n            if isinstance(configDict[\"Halfs\"], bool) and configDict[\"Halfs\"]:\n                coreDivisions.append(\"half0\")\n                coreDivisions.append(\"half1\")\n            elif isinstance(configDict[\"Halfs\"], list):\n                for num in configDict[\"Halfs\"]:\n                    if num > 1 or num < 0:\n                        raise RuntimeError(\n                            \"Invalid half specified '{}' in 'Core_Config'. There are only 2 halfs in a whole. Valid\"\n                            \" values are (0,1)\".format(num)\n                        )\n                    coreDivisions.append(\"half{}\".format(num))\n            else:\n                raise RuntimeError(\n                    \"Unknown type for 'Halfs' division in 'Cores_Config'. Only, list and boolean values are supported\"\n                )\n        if \"Quarters\" in configDict:\n            if isinstance(configDict[\"Quarters\"], bool) and configDict[\"Quarters\"]:\n                coreDivisions.append(\"quart0\")\n                coreDivisions.append(\"quart1\")\n                coreDivisions.append(\"quart2\")\n                coreDivisions.append(\"quart3\")\n            elif isinstance(configDict[\"Quarters\"], list):\n                for num in configDict[\"Quarters\"]:\n                    if num > 3 or num < 0:\n                        raise RuntimeError(\n                            \"Invalid Quarter specified '{}' in 'Core_Config'. There are only 4 quarters in a whole\"\n                            .format(num)\n                        )\n                    coreDivisions.append(\"quart{}\".format(num))\n            else:\n                raise RuntimeError(\n                    \"Unknown type for Quarters division in 'Cores_Config'. Only, list and boolean values are supported\"\n                )\n        if \"CCDs\" in configDict:\n            if isinstance(configDict[\"CCDs\"], bool) and configDict[\"CCDs\"]:\n                for num in range(self.cpuInfo.ccds_per_socket):\n                    coreDivisions.append(str(num))\n            elif isinstance(configDict[\"CCDs\"], list):\n                for num in configDict[\"CCDs\"]:\n                    if num > self.cpuInfo.ccds_per_socket:\n                        raise RuntimeError(\n                            \"Invalid CCD specified '{}' in 'Core_Config'. There are only {} CCDs in a socket\".format(\n                                num, self.cpuInfo.ccds_per_socket\n                            )\n                        )\n                    coreDivisions.append(str(num))\n            else:\n                raise RuntimeError(\n                    \"Unknown type for 'CCDs' division in 'Cores_Config'. Only, list and boolean values are supported\"\n                )\n        for socket in self.sockets:\n            for corediv in coreDivisions:\n                self.cores.append(self._getCoreList(corediv, threadlist, socket))\n\n        if \"Cores\" in configDict:\n            if isinstance(configDict[\"Cores\"], bool) and configDict[\"Cores\"]:\n                for num in range(self.cpuInfo.num_logical_cores):\n                    self.cores.append([str(num)])\n            elif isinstance(configDict[\"Cores\"], list):\n                for core in configDict[\"Cores\"]:\n                    if core >= self.cpuInfo.num_logical_cores:\n                        raise RuntimeError(\n                            \"Invalid Core specified '{}' in 'Core_Config'. There are only {} logical cores\".format(\n                                core, self.cpuInfo.num_logical_cores\n                            )\n                        )\n                    self.cores.append([str(core)])\n\n        if not self.cores and not self.coreDivisions:\n            raise RuntimeError(\n                \"Incorrect configuration file format. It is required to specify at least one core division or core\"\n                \" specified to run tests.\"\n            )\n\n    def _getItemAsList(self, item):\n        if isinstance(item, bool):\n            return [item]\n        elif isinstance(item, list):\n            return item\n        else:\n            raise RuntimeError(\"Incorrect 'Core_Config' format in configuration file.\")\n\n    def _getCoreList(self, partition, threadList, sockets):\n        \"\"\"Uses the CPUInfo topology to create a core list for given divisions\n\n        Returns a list of cores\n        Args:\n            partition: str with options: all, half0, half1, quart0, quart1, quart2, quart3, 0, 1, 2, 3, 4, 5, 6...\n                where the individual numbers are the CCD numbers.\n            threadList: list of threads,\n            sockets: string, either 0, 1 or all\n        \"\"\"\n        coreList = \"\"\n        if not os.path.isfile(self._listCoreFile):\n            raise RuntimeError(\n                \"{} does not exist, please ensure you specified the correct Run_Directory.\".format(self._listCoreFile)\n            )\n        for thread in threadList:\n            cmd = (\n                \"{} {} \".format(self._listCoreFile, self.cpuInfo.cores_per_ccd)\n                + \"{} {} {} \".format(self.cpuInfo.ccds_per_socket, self.cpuInfo.num_sockets, partition)\n                + \"{} {}\".format(thread, sockets)\n            )\n            p = Popen(cmd, shell=True, stdout=PIPE, stderr=PIPE)\n            stdout, stderr = p.communicate()\n            returncode = p.returncode\n            cmdOutput = stdout.decode(\"utf-8\")\n            if returncode != 0:\n                raise RuntimeError(\"list cores command failed to execute. {}\".format(stderr.decode(\"utf-8\")))\n            coreList += str(cmdOutput).strip(\"\\n\") + \" \"\n\n        return coreList.split()\n\n    def _checkConfigIntegrity(self, config):\n        \"\"\"Ensures that the 'Cores_Config' section matches the CPU Topology\n\n        Checks if SMT is enabled, it's also enabled on the CPU\n        Number of CCDs isn't more than the number of CCDs on the CPU\n        Cores isn't more than the number of cores on the CPU\n        Sockets is only 0, 1, or [0, 1]\n\n        Args:\n            config: the 'Cores_Config' option dictionary\n        \"\"\"\n\n        if self.smt and not self.cpuInfo.is_smt_enabled:\n            raise RuntimeError(\"Configuration File specifies use SMT, but the CPU doesn't have SMT enabled\")\n\n        # CCDs\n        if \"CCDs\" in config:\n            if isinstance(config[\"CCDs\"], list):\n                for ccd in config[\"CCDs\"]:\n                    if ccd >= self.cpuInfo.ccds_per_socket:\n                        raise RuntimeError(\n                            \"Configuration File specifies CCD {}, but the CPU only has {}\".format(\n                                ccd, self.cpuInfo.ccds_per_socket\n                            )\n                        )\n            elif not isinstance(config[\"CCDs\"], bool):\n                raise RuntimeError(\"'CCDs' configuration item can only be a list or boolean\")\n        # Cores\n        if \"Cores\" in config:\n            if isinstance(config[\"Cores\"], list):\n                for core in config[\"Cores\"]:\n                    if core >= self.cpuInfo.num_physical_cores:\n                        raise RuntimeError(\n                            \"Configuration File specifies Core {}, but the CPU only has {}\".format(\n                                core, self.cpuInfo.num_physical_cores\n                            )\n                        )\n            elif not isinstance(config[\"Cores\"], bool):\n                raise RuntimeError(\"Cores Configuration item can only be a list or boolean\")\n\n        # Sockets\n        if \"Sockets\" in config:\n            if not isinstance(config[\"Sockets\"], list):\n                raise RuntimeError(\"'Sockets' configuration item can only be a list\")\n            for s in config[\"Sockets\"]:\n                if isinstance(s, list):\n                    if len(s) != 2 or 0 not in s or 1 not in s or self.cpuInfo.num_sockets != 2:\n                        raise RuntimeError(\n                            \"The only valid options for 'Socket' configuration item are 0, 1, or [0,1] given a  2P\"\n                            f\" system, '{s}' was provided in the configuration file.\"\n                        )\n                elif s + 1 > self.cpuInfo.num_sockets:\n                    raise RuntimeError(\n                        f\"The configuration file specifies more sockets than are availble on the system. Socket {s} is\"\n                        f\" specified, however the system only has {self.cpuInfo.num_sockets} active sockets\"\n                    )", "\n\nclass TestConfig:\n    \"\"\"Contains the configuration for each test\n\n    Attributes:\n        name: string that defines the name of the test\n        binary: path to test binary\n        arguments: list of TestConfigArguments for test to use\n    \"\"\"\n\n    def __init__(self, config):\n        \"\"\"parses the config dictionary into a class object\n\n        Args:\n            config: config dictionary\n\n        Raises:\n            RuntimeException: When the test doesn't have the required format\n        \"\"\"\n        try:\n            self.name = config[\"Name\"]\n            self.binary = os.path.expandvars(config[\"Binary\"])\n            if not os.path.isfile(self.binary) and not shutil.which(self.binary):\n                raise RuntimeError(\"Binary path '{}' specified for {} does not exist\".format(self.binary, self.name))\n            self.arguments = []\n        except KeyError as e:\n            raise RuntimeError(\"Configuration File's Test does not have expected values. {}\".format(e))\n        try:\n            for arg in config[\"Args\"]:\n                self.arguments.append(TestArgConfig(arg))\n        except KeyError:\n            logger.warning(\n                \"There are no arguments for test '{}', ensure you don't require arguemnts for this binary\".format(\n                    self.name\n                )\n            )", "\n\nclass TestArgConfig:\n    \"\"\"Stores the arguments and values specified in the configuration file\n\n    Attributes:\n        cmdLineOption: string of the complete cmd line flag\n            ex: `--run` or `-a\n        values: list of possible values for the argument\n        isConstant: boolean to determine if you want the argument to always show\n            up in cmd line\n        isFlag: boolean to determine if the argument is just a flag and\n            no value associated with arg\n    \"\"\"\n\n    def __init__(self, arg):\n        \"\"\"Parses the arg dictionary\n\n        Args:\n            name: string of name of arg specified in config file\n            arg: the arg dictionary from the config file\n\n        Raises:\n            RuntimeError: if the arg dictionary is missing a key or malformed\n        \"\"\"\n\n        self.name = list(arg.keys())[0]\n        self.values = []\n        argData = arg[self.name]\n        try:\n            self.isConstant = False if \"Constant\" not in argData else argData[\"Constant\"]\n            self.isFlag = False if \"Flag\" not in argData else argData[\"Flag\"]\n            self.cmdLineOption = argData[\"Option\"]\n            if not self.isFlag:\n                self.values = argData[\"Values\"]\n        except KeyError as e:\n            raise RuntimeError(\"Configuration File's Test Args does not have expected values. {}\".format(e))\n        # Check Types\n        if not isinstance(self.values, list):\n            raise TypeError(\"The 'Values' option is required to be a list, even for a constant argument.\")\n\n        # Ensure constant and flag contraints are valid\n        if self.isConstant and len(self.values) > 1:\n            raise RuntimeError(\n                \"Configuration File's Test Arg '{}' is incorrect. An argument cannot be constant and have multiple\"\n                \" values. {}\".format(self.name, self.values)\n            )\n        if self.isFlag and \"Values\" in argData and len(argData[\"Values\"]) > 0:\n            raise RuntimeError(\n                \"Configuration File's Test Arg '{}' is incorrect. An argument cannot be a flag and have values\".format(\n                    self.name\n                )\n            )", ""]}
{"filename": "system_config/__init__.py", "chunked_list": [""]}
{"filename": "system_config/cpuinfo.py", "chunked_list": ["# MIT License\n \n# Copyright (c) 2023 Advanced Micro Devices, Inc.\n \n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:", "# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n \n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n \n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER", "# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\nimport os\nimport sys\nfrom io import open\n", "from io import open\n\n\ndef GetSocketId(cpu_id: int):\n    f = \"/sys/devices/system/cpu/cpu{}/topology/physical_package_id\".format(cpu_id)\n    if not os.path.isfile(f):\n        raise RuntimeError(\n            \"Failed to get socket id for cpu core {}. Please ensure you are root and valid core id.\".format(cpu_id)\n        )\n\n    try:\n        with open(f, \"r\") as ppFile:\n            pId = ppFile.read(1)\n    except OSError:\n        raise RuntimeError(\n            \"Failed to get socket id for cpu core {}. Please ensure you are root and valid core id.\".format(cpu_id)\n        )\n\n    pId = int(pId.strip(\"\\n\"))\n    return pId", "\n\nclass CpuInfo:\n    \"\"\"Contains info about the core configuration of the CPU\n\n    Attributes:\n        is_smt_enabled: boolean for multithreading\n        num_logical_cores: integer representing total number of logical cores\n        num_physical_cores: integer representing the total number of physical cores\n        cores_per_ccd: integer representing the total number of cores in each CCD\n        ccds_per_socket: integer representing number of CCDs in each socket\n        num_sockets: integer representing the number of populated sockets\n\n\n    \"\"\"\n\n    def __init__(self):\n        self.file_name = \"/proc/cpuinfo\"\n        self.topology = {}\n        self.is_smt_enabled = False\n        self.num_logical_cores = 0\n        self.ccds_per_socket = 0\n        self.num_sockets = 0\n        self.num_physical_cores = 0\n        self.Enumerate()\n        self.cores_per_ccd = int(self.num_physical_cores / (self.ccds_per_socket * self.num_sockets))\n\n    def Enumerate(self):\n        self.cpuinfo = {}\n        ccds = {}\n        try:\n            f = open(self.file_name, encoding=\"utf-8\")\n            core_id = 0\n            for line in f:\n                x = [x.strip() for x in line.split(\":\")]\n                if len(x) == 2:\n                    if x[0] == \"processor\":\n                        core_id = x[1]\n                        self.cpuinfo[int(core_id)] = {}\n                    self.cpuinfo[int(core_id)][x[0]] = x[1]\n        except OSError:\n            print(\"Could not open/read file:{}\".format(self.file_name))\n            sys.exit()\n        finally:\n            f.close()\n\n        for key, value in self.cpuinfo.items():\n            if int(value[\"physical id\"]) not in self.topology:\n                self.topology[int(value[\"physical id\"])] = {}\n            self.topology[int(value[\"physical id\"])][int(key)] = value\n\n        if len(self.topology[0]) != int(self.topology[0][0][\"cpu cores\"]):\n            self.is_smt_enabled = True\n        else:\n            self.is_smt_enabled = False\n\n        self.num_logical_cores = len(self.cpuinfo)\n        self.num_physical_cores = int(len(self.cpuinfo) / (2 if self.is_smt_enabled else 1))\n        self.num_sockets = len(self.topology)\n        v1 = int(self.cpuinfo[0][\"apicid\"])\n        v2 = int(self.cpuinfo[1][\"apicid\"])\n        div_fact = v2 - v1\n        for key, value in self.cpuinfo.items():\n            apicid = int(value[\"apicid\"])\n            if self.is_smt_enabled:\n                apicid = (apicid >> 4) & 0x1F\n            else:\n                if int(value[\"cpu family\"]) == 25 and int(value[\"model\"]) >= 1:\n                    apicid = (apicid >> (1 + div_fact)) & 0x1F\n                else:\n                    apicid = (apicid >> 3) & 0x1F\n            ccds[apicid] = 1\n        self.ccds_per_socket = int(len(ccds) / self.num_sockets)", ""]}
