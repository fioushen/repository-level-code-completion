{"filename": "install.py", "chunked_list": ["import launch\nimport os\n\ncurrent_dir = os.path.dirname(os.path.realpath(__file__))\nreq_file = os.path.join(current_dir, \"requirements.txt\")\n\nwith open(req_file) as file:\n    for lib in file:\n        lib = lib.strip()\n        if not launch.is_installed(lib):\n            launch.run_pip(\n                f\"install {lib}\",\n                f\"sd-webui-segment-anything requirement: {lib}\")", ""]}
{"filename": "scripts/auto.py", "chunked_list": ["import os\nimport gc\nimport glob\nimport copy\nfrom PIL import Image\nfrom collections import OrderedDict\nimport numpy as np\nimport torch\nimport cv2\nfrom sam_hq.automatic import SamAutomaticMaskGeneratorHQ", "import cv2\nfrom sam_hq.automatic import SamAutomaticMaskGeneratorHQ\nfrom modules import scripts, shared\nfrom modules.paths import extensions_dir\nfrom modules.devices import torch_gc\n\n\nglobal_sam: SamAutomaticMaskGeneratorHQ = None\nsem_seg_cache = OrderedDict()\nsam_annotator_dir = os.path.join(scripts.basedir(), \"annotator\")", "sem_seg_cache = OrderedDict()\nsam_annotator_dir = os.path.join(scripts.basedir(), \"annotator\")\noriginal_uniformer_inference_segmentor = None\n\n\ndef pad64(x):\n    return int(np.ceil(float(x) / 64.0) * 64 - x)\n\n\ndef safer_memory(x):\n    # Fix many MAC/AMD problems\n    return np.ascontiguousarray(x.copy()).copy()", "\ndef safer_memory(x):\n    # Fix many MAC/AMD problems\n    return np.ascontiguousarray(x.copy()).copy()\n\n\ndef resize_image_with_pad(input_image, resolution):\n    from annotator.util import HWC3\n    img = HWC3(input_image)\n    H_raw, W_raw, _ = img.shape\n    k = float(resolution) / float(min(H_raw, W_raw))\n    interpolation = cv2.INTER_CUBIC if k > 1 else cv2.INTER_AREA\n    H_target = int(np.round(float(H_raw) * k))\n    W_target = int(np.round(float(W_raw) * k))\n    img = cv2.resize(img, (W_target, H_target), interpolation=interpolation)\n    H_pad, W_pad = pad64(H_target), pad64(W_target)\n    img_padded = np.pad(img, [[0, H_pad], [0, W_pad], [0, 0]], mode='edge')\n\n    def remove_pad(x):\n        return safer_memory(x[:H_target, :W_target])\n\n    return safer_memory(img_padded), remove_pad", "\n\ndef blend_image_and_seg(image, seg, alpha=0.5):\n    image_blend = image * (1 - alpha) + np.array(seg) * alpha\n    return Image.fromarray(image_blend.astype(np.uint8))\n\n\ndef create_symbolic_link():\n    cnet_annotator_dir = os.path.join(extensions_dir, \"sd-webui-controlnet/annotator\")\n    if os.path.isdir(cnet_annotator_dir):\n        if not os.path.isdir(sam_annotator_dir):\n            os.symlink(cnet_annotator_dir, sam_annotator_dir, target_is_directory=True)\n        return True\n    return False", "\n\ndef clear_sem_sam_cache():\n    sem_seg_cache.clear()\n    gc.collect()\n    torch_gc()\n    \n\ndef sem_sam_garbage_collect():\n    if shared.cmd_opts.lowvram:\n        for model_key, model in sem_seg_cache:\n            if model_key == \"uniformer\":\n                from annotator.uniformer import unload_uniformer_model\n                unload_uniformer_model()\n            else:\n                model.unload_model()\n    gc.collect()\n    torch_gc()", "def sem_sam_garbage_collect():\n    if shared.cmd_opts.lowvram:\n        for model_key, model in sem_seg_cache:\n            if model_key == \"uniformer\":\n                from annotator.uniformer import unload_uniformer_model\n                unload_uniformer_model()\n            else:\n                model.unload_model()\n    gc.collect()\n    torch_gc()", "\n\ndef strengthen_sem_seg(class_ids, img):\n    print(\"Auto SAM strengthening semantic segmentation\")\n    import pycocotools.mask as maskUtils\n    semantc_mask = copy.deepcopy(class_ids)\n    annotations = global_sam.generate(img)\n    annotations = sorted(annotations, key=lambda x: x['area'], reverse=True)\n    print(f\"Auto SAM generated {len(annotations)} masks\")\n    for ann in annotations:\n        valid_mask = torch.tensor(maskUtils.decode(ann['segmentation'])).bool()\n        propose_classes_ids = torch.tensor(class_ids[valid_mask])\n        num_class_proposals = len(torch.unique(propose_classes_ids))\n        if num_class_proposals == 1:\n            semantc_mask[valid_mask] = propose_classes_ids[0].numpy()\n            continue\n        top_1_propose_class_ids = torch.bincount(propose_classes_ids.flatten()).topk(1).indices\n        semantc_mask[valid_mask] = top_1_propose_class_ids.numpy()\n    print(\"Auto SAM strengthen process end\")\n    return semantc_mask", "\n\ndef random_segmentation(img):\n    print(\"Auto SAM generating random segmentation for Edit-Anything\")\n    img_np = np.array(img.convert(\"RGB\"))\n    annotations = global_sam.generate(img_np)\n    # annotations = sorted(annotations, key=lambda x: x['area'], reverse=True)\n    print(f\"Auto SAM generated {len(annotations)} masks\")\n    H, W, _ = img_np.shape\n    color_map = np.zeros((H, W, 3), dtype=np.uint8)\n    detected_map_tmp = np.zeros((H, W), dtype=np.uint16)\n    for idx, annotation in enumerate(annotations):\n        current_seg = annotation['segmentation']\n        color_map[current_seg] = np.random.randint(0, 255, (3))\n        detected_map_tmp[current_seg] = idx + 1\n    detected_map = np.zeros((detected_map_tmp.shape[0], detected_map_tmp.shape[1], 3))\n    detected_map[:, :, 0] = detected_map_tmp % 256\n    detected_map[:, :, 1] = detected_map_tmp // 256\n    from annotator.util import HWC3\n    detected_map = HWC3(detected_map.astype(np.uint8))\n    print(\"Auto SAM generation process end\")\n    return [blend_image_and_seg(img_np, color_map), Image.fromarray(color_map), Image.fromarray(detected_map)], \\\n        \"Random segmentation done. Left above (0) is blended image, right above (1) is random segmentation, left below (2) is Edit-Anything control input.\"", "\n\ndef image_layer_image(layout_input_image, layout_output_path):\n    img_np = np.array(layout_input_image.convert(\"RGB\"))\n    annotations = global_sam.generate(img_np)\n    print(f\"AutoSAM generated {len(annotations)} annotations\")\n    annotations = sorted(annotations, key=lambda x: x['area'])\n    for idx, annotation in enumerate(annotations):\n        img_tmp = np.zeros((img_np.shape[0], img_np.shape[1], 3))\n        img_tmp[annotation['segmentation']] = img_np[annotation['segmentation']]\n        img_np[annotation['segmentation']] = np.array([0, 0, 0])\n        img_tmp = Image.fromarray(img_tmp.astype(np.uint8))\n        img_tmp.save(os.path.join(layout_output_path, f\"{idx}.png\"))\n    img_np = Image.fromarray(img_np.astype(np.uint8))\n    img_np.save(os.path.join(layout_output_path, \"leftover.png\"))", "\n\ndef image_layer_internal(layout_input_image_or_path, layout_output_path):\n    if isinstance(layout_input_image_or_path, str):\n        print(\"Image layer division batch processing\")\n        all_files = glob.glob(os.path.join(layout_input_image_or_path, \"*\"))\n        for image_index, input_image_file in enumerate(all_files):\n            print(f\"Processing {image_index}/{len(all_files)} {input_image_file}\")\n            try:\n                input_image = Image.open(input_image_file)\n                output_directory = os.path.join(layout_output_path, os.path.splitext(os.path.basename(input_image_file))[0])\n                from pathlib import Path\n                Path(output_directory).mkdir(exist_ok=True)\n            except:\n                print(f\"File {input_image_file} not image, skipped.\")\n                continue\n            image_layer_image(input_image, output_directory)\n    else:\n        image_layer_image(layout_input_image_or_path, layout_output_path)\n    return \"Done\"", "\n\ndef inject_uniformer_inference_segmentor(model, img):\n    original_result = original_uniformer_inference_segmentor(model, img)\n    original_result[0] = strengthen_sem_seg(original_result[0], img)\n    return original_result\n\n\ndef inject_uniformer_show_result_pyplot(model, img, result, palette=None, fig_size=(15, 10), opacity=0.5, title='', block=True):\n    return result[0]", "def inject_uniformer_show_result_pyplot(model, img, result, palette=None, fig_size=(15, 10), opacity=0.5, title='', block=True):\n    return result[0]\n\n\ndef inject_oneformer_semantic_run(img, predictor, metadata):\n    predictions = predictor(img[:, :, ::-1], \"semantic\")  # Predictor of OneFormer must use BGR image !!!\n    original_result = predictions[\"sem_seg\"].argmax(dim=0).cpu().numpy()\n    from annotator.oneformer.oneformer.demo.visualizer import Visualizer, ColorMode\n    visualizer_map = Visualizer(img, is_img=False, metadata=metadata, instance_mode=ColorMode.IMAGE)\n    out_map = visualizer_map.draw_sem_seg(torch.tensor(strengthen_sem_seg(original_result, img), device='cpu'), alpha=1, is_text=False).get_image()\n    return out_map", "\n\ndef inject_oneformer_semantic_run_categorical_mask(img, predictor, metadata):\n    predictions = predictor(img[:, :, ::-1], \"semantic\")  # Predictor of OneFormer must use BGR image !!!\n    original_result = predictions[\"sem_seg\"].argmax(dim=0).cpu().numpy()\n    return strengthen_sem_seg(original_result, img)\n\n\ndef inject_oneformer_detector_call(self, img):\n    if self.model is None:\n        self.load_model()\n    self.model.model.to(self.device)\n    return inject_oneformer_semantic_run(img, self.model, self.metadata)", "def inject_oneformer_detector_call(self, img):\n    if self.model is None:\n        self.load_model()\n    self.model.model.to(self.device)\n    return inject_oneformer_semantic_run(img, self.model, self.metadata)\n\n\ndef inject_oneformer_detector_call_categorical_mask(self, img):\n    if self.model is None:\n        self.load_model()\n    self.model.model.to(self.device)\n    return inject_oneformer_semantic_run_categorical_mask(img, self.model, self.metadata)", "\n\ndef _uniformer(img):\n    if \"uniformer\" not in sem_seg_cache:\n        from annotator.uniformer import apply_uniformer\n        sem_seg_cache[\"uniformer\"] = apply_uniformer\n    result = sem_seg_cache[\"uniformer\"](img)\n    return result\n\n\ndef _oneformer(img, dataset=\"coco\"):\n    oneformer_key = f\"oneformer_{dataset}\"\n    if oneformer_key not in sem_seg_cache:\n        from annotator.oneformer import OneformerDetector\n        sem_seg_cache[oneformer_key] = OneformerDetector(OneformerDetector.configs[dataset])\n    result = sem_seg_cache[oneformer_key](img)\n    return result", "\n\ndef _oneformer(img, dataset=\"coco\"):\n    oneformer_key = f\"oneformer_{dataset}\"\n    if oneformer_key not in sem_seg_cache:\n        from annotator.oneformer import OneformerDetector\n        sem_seg_cache[oneformer_key] = OneformerDetector(OneformerDetector.configs[dataset])\n    result = sem_seg_cache[oneformer_key](img)\n    return result\n", "\n\ndef semantic_segmentation(input_image, annotator_name, processor_res, \n                          use_pixel_perfect, resize_mode, target_W, target_H):\n    if input_image is None:\n        return [], \"No input image.\"\n    if \"seg\" in annotator_name:\n        if not os.path.isdir(os.path.join(scripts.basedir(), \"annotator\")) and not create_symbolic_link():\n            return [], \"ControlNet extension not found.\"\n        global original_uniformer_inference_segmentor\n        input_image_np = np.array(input_image)\n        processor_res = pixel_perfect_lllyasviel(input_image_np, processor_res, use_pixel_perfect, resize_mode, target_W, target_H)\n        input_image, remove_pad = resize_image_with_pad(input_image_np, processor_res)\n        print(\"Generating semantic segmentation without SAM\")\n        if annotator_name == \"seg_ufade20k\":\n            original_semseg = _uniformer(input_image)\n            print(\"Generating semantic segmentation with SAM\")\n            import annotator.uniformer as uniformer\n            original_uniformer_inference_segmentor = uniformer.inference_segmentor\n            uniformer.inference_segmentor = inject_uniformer_inference_segmentor\n            sam_semseg = _uniformer(input_image)\n            uniformer.inference_segmentor = original_uniformer_inference_segmentor\n            original_semseg = remove_pad(original_semseg)\n            sam_semseg = remove_pad(sam_semseg)\n            input_image = remove_pad(input_image)\n            output_gallery = [original_semseg, sam_semseg, blend_image_and_seg(input_image, original_semseg), blend_image_and_seg(input_image, sam_semseg)]\n            return output_gallery, \"Uniformer semantic segmentation of ade20k done. Left is segmentation before SAM, right is segmentation after SAM.\"\n        else:\n            dataset = annotator_name.split('_')[-1][2:]\n            original_semseg = _oneformer(input_image, dataset=dataset)\n            print(\"Generating semantic segmentation with SAM\")\n            from annotator.oneformer import OneformerDetector\n            original_oneformer_call = OneformerDetector.__call__\n            OneformerDetector.__call__ = inject_oneformer_detector_call\n            sam_semseg = _oneformer(input_image, dataset=dataset)\n            OneformerDetector.__call__ = original_oneformer_call\n            original_semseg = remove_pad(original_semseg)\n            sam_semseg = remove_pad(sam_semseg)\n            input_image = remove_pad(input_image)\n            output_gallery = [original_semseg, sam_semseg, blend_image_and_seg(input_image, original_semseg), blend_image_and_seg(input_image, sam_semseg)]\n            return output_gallery, f\"Oneformer semantic segmentation of {dataset} done. Left is segmentation before SAM, right is segmentation after SAM.\"\n    else:\n        return random_segmentation(input_image)", "\n\ndef categorical_mask_image(crop_processor, crop_processor_res, crop_category_input, crop_input_image,\n                           crop_pixel_perfect, crop_resize_mode, target_W, target_H):\n    if crop_input_image is None:\n        return \"No input image.\"\n    if not os.path.isdir(os.path.join(scripts.basedir(), \"annotator\")) and not create_symbolic_link():\n        return \"ControlNet extension not found.\"\n    filter_classes = crop_category_input.split('+')\n    if len(filter_classes) == 0:\n        return \"No class selected.\"\n    try:\n        filter_classes = [int(i) for i in filter_classes]\n    except:\n        return \"Illegal class id. You may have input some string.\"\n    crop_input_image_np = np.array(crop_input_image)\n    crop_processor_res = pixel_perfect_lllyasviel(crop_input_image_np, crop_processor_res, crop_pixel_perfect, crop_resize_mode, target_W, target_H)\n    crop_input_image, remove_pad = resize_image_with_pad(crop_input_image_np, crop_processor_res)\n    crop_input_image_copy = copy.deepcopy(crop_input_image)\n    global original_uniformer_inference_segmentor\n    print(f\"Generating categories with processor {crop_processor}\")\n    if crop_processor == \"seg_ufade20k\":\n        import annotator.uniformer as uniformer\n        original_uniformer_inference_segmentor = uniformer.inference_segmentor\n        uniformer.inference_segmentor = inject_uniformer_inference_segmentor\n        tmp_ouis = uniformer.show_result_pyplot\n        uniformer.show_result_pyplot = inject_uniformer_show_result_pyplot\n        sam_semseg = _uniformer(crop_input_image)\n        uniformer.inference_segmentor = original_uniformer_inference_segmentor\n        uniformer.show_result_pyplot = tmp_ouis\n    else:\n        dataset = crop_processor.split('_')[-1][2:]\n        from annotator.oneformer import OneformerDetector\n        original_oneformer_call = OneformerDetector.__call__\n        OneformerDetector.__call__ = inject_oneformer_detector_call_categorical_mask\n        sam_semseg = _oneformer(crop_input_image, dataset=dataset)\n        OneformerDetector.__call__ = original_oneformer_call\n    sam_semseg = remove_pad(sam_semseg)\n    mask = np.zeros(sam_semseg.shape, dtype=np.bool_)\n    for i in filter_classes:\n        mask[sam_semseg == i] = True\n    return mask, remove_pad(crop_input_image_copy)", "\n\ndef register_auto_sam(sam, \n    auto_sam_points_per_side, auto_sam_points_per_batch, auto_sam_pred_iou_thresh, \n    auto_sam_stability_score_thresh, auto_sam_stability_score_offset, auto_sam_box_nms_thresh, \n    auto_sam_crop_n_layers, auto_sam_crop_nms_thresh, auto_sam_crop_overlap_ratio, \n    auto_sam_crop_n_points_downscale_factor, auto_sam_min_mask_region_area, auto_sam_output_mode):\n    global global_sam\n    global_sam = SamAutomaticMaskGeneratorHQ(\n        sam, auto_sam_points_per_side, auto_sam_points_per_batch, \n        auto_sam_pred_iou_thresh, auto_sam_stability_score_thresh, \n        auto_sam_stability_score_offset, auto_sam_box_nms_thresh, \n        auto_sam_crop_n_layers, auto_sam_crop_nms_thresh, auto_sam_crop_overlap_ratio, \n        auto_sam_crop_n_points_downscale_factor, None, \n        auto_sam_min_mask_region_area, auto_sam_output_mode)", "\n\ndef pixel_perfect_lllyasviel(input_image, processor_res, use_pixel_perfect, resize_mode, target_W, target_H):\n    preprocessor_resolution = processor_res\n    if use_pixel_perfect:\n        raw_H, raw_W, _ = input_image.shape\n        k0 = float(target_H) / float(raw_H)\n        k1 = float(target_W) / float(raw_W)\n        if resize_mode == 2:\n            estimation = min(k0, k1) * float(min(raw_H, raw_W))\n        else:\n            estimation = max(k0, k1) * float(min(raw_H, raw_W))\n        preprocessor_resolution = int(np.round(float(estimation) / 64.0)) * 64\n        print(f'Pixel Perfect Mode (written by lllyasviel) Enabled.')\n        print(f'resize_mode = {str(resize_mode)}')\n        print(f'raw_H = {raw_H}')\n        print(f'raw_W = {raw_W}')\n        print(f'target_H = {target_H}')\n        print(f'target_W = {target_W}')\n        print(f'estimation = {estimation}')\n    print(f'preprocessor resolution = {preprocessor_resolution}')\n    return preprocessor_resolution", ""]}
{"filename": "scripts/dino.py", "chunked_list": ["import os\nimport gc\nimport cv2\nimport copy\nimport torch\nfrom collections import OrderedDict\n\nfrom modules import scripts, shared\nfrom modules.devices import device, torch_gc, cpu\nimport local_groundingdino", "from modules.devices import device, torch_gc, cpu\nimport local_groundingdino\n\n\ndino_model_cache = OrderedDict()\nsam_extension_dir = scripts.basedir()\ndino_model_dir = os.path.join(sam_extension_dir, \"models/grounding-dino\")\ndino_model_list = [\"GroundingDINO_SwinT_OGC (694MB)\", \"GroundingDINO_SwinB (938MB)\"]\ndino_model_info = {\n    \"GroundingDINO_SwinT_OGC (694MB)\": {", "dino_model_info = {\n    \"GroundingDINO_SwinT_OGC (694MB)\": {\n        \"checkpoint\": \"groundingdino_swint_ogc.pth\",\n        \"config\": os.path.join(dino_model_dir, \"GroundingDINO_SwinT_OGC.py\"),\n        \"url\": \"https://huggingface.co/ShilongLiu/GroundingDINO/resolve/main/groundingdino_swint_ogc.pth\",\n    },\n    \"GroundingDINO_SwinB (938MB)\": {\n        \"checkpoint\": \"groundingdino_swinb_cogcoor.pth\",\n        \"config\": os.path.join(dino_model_dir, \"GroundingDINO_SwinB.cfg.py\"),\n        \"url\": \"https://huggingface.co/ShilongLiu/GroundingDINO/resolve/main/groundingdino_swinb_cogcoor.pth\"", "        \"config\": os.path.join(dino_model_dir, \"GroundingDINO_SwinB.cfg.py\"),\n        \"url\": \"https://huggingface.co/ShilongLiu/GroundingDINO/resolve/main/groundingdino_swinb_cogcoor.pth\"\n    },\n}\ndino_install_issue_text = \"permanently switch to local groundingdino on Settings/Segment Anything or submit an issue to https://github.com/IDEA-Research/Grounded-Segment-Anything/issues.\"\n\n\ndef install_goundingdino():\n    if shared.opts.data.get(\"sam_use_local_groundingdino\", False):\n        print(\"Using local groundingdino.\")\n        return False\n\n    def verify_dll(install_local=True):\n        try:\n            from groundingdino import _C\n            print(\"GroundingDINO dynamic library have been successfully built.\")\n            return True\n        except Exception:\n            import traceback\n            traceback.print_exc()\n            def run_pip_uninstall(command, desc=None):\n                from launch import python, run\n                default_command_live = (os.environ.get('WEBUI_LAUNCH_LIVE_OUTPUT') == \"1\")\n                return run(f'\"{python}\" -m pip uninstall -y {command}', desc=f\"Uninstalling {desc}\", errdesc=f\"Couldn't uninstall {desc}\", live=default_command_live)\n            if install_local:\n                print(f\"Failed to build dymanic library. Will uninstall GroundingDINO from pip and fall back to local groundingdino this time. Please {dino_install_issue_text}\")\n                run_pip_uninstall(\n                    f\"groundingdino\",\n                    f\"sd-webui-segment-anything requirement: groundingdino\")\n            else:\n                print(f\"Failed to build dymanic library. Will uninstall GroundingDINO from pip and re-try installing from GitHub source code. Please {dino_install_issue_text}\")\n                run_pip_uninstall(\n                    f\"uninstall groundingdino\",\n                    f\"sd-webui-segment-anything requirement: groundingdino\")\n            return False\n\n    import launch\n    if launch.is_installed(\"groundingdino\"):\n        print(\"Found GroundingDINO in pip. Verifying if dynamic library build success.\")\n        if verify_dll(install_local=False):\n            return True\n    try:\n        launch.run_pip(\n            f\"install git+https://github.com/IDEA-Research/GroundingDINO\",\n            f\"sd-webui-segment-anything requirement: groundingdino\")\n        print(\"GroundingDINO install success. Verifying if dynamic library build success.\")\n        return verify_dll()\n    except Exception:\n        import traceback\n        traceback.print_exc()\n        print(f\"GroundingDINO install failed. Will fall back to local groundingdino this time. Please {dino_install_issue_text}\")\n        return False", "\n\ndef show_boxes(image_np, boxes, color=(255, 0, 0, 255), thickness=2, show_index=False):\n    if boxes is None:\n        return image_np\n\n    image = copy.deepcopy(image_np)\n    for idx, box in enumerate(boxes):\n        x, y, w, h = box\n        cv2.rectangle(image, (x, y), (w, h), color, thickness)\n        if show_index:\n            font = cv2.FONT_HERSHEY_SIMPLEX\n            text = str(idx)\n            textsize = cv2.getTextSize(text, font, 1, 2)[0]\n            cv2.putText(image, text, (x, y+textsize[1]), font, 1, color, thickness)\n\n    return image", "\n\ndef clear_dino_cache():\n    dino_model_cache.clear()\n    gc.collect()\n    torch_gc()\n\n\ndef load_dino_model(dino_checkpoint, dino_install_success):\n    print(f\"Initializing GroundingDINO {dino_checkpoint}\")\n    if dino_checkpoint in dino_model_cache:\n        dino = dino_model_cache[dino_checkpoint]\n        if shared.cmd_opts.lowvram:\n            dino.to(device=device)\n    else:\n        clear_dino_cache()\n        if dino_install_success:\n            from groundingdino.models import build_model\n            from groundingdino.util.slconfig import SLConfig\n            from groundingdino.util.utils import clean_state_dict\n        else:\n            from local_groundingdino.models import build_model\n            from local_groundingdino.util.slconfig import SLConfig\n            from local_groundingdino.util.utils import clean_state_dict\n        args = SLConfig.fromfile(dino_model_info[dino_checkpoint][\"config\"])\n        dino = build_model(args)\n        checkpoint = torch.hub.load_state_dict_from_url(\n            dino_model_info[dino_checkpoint][\"url\"], dino_model_dir)\n        dino.load_state_dict(clean_state_dict(\n            checkpoint['model']), strict=False)\n        dino.to(device=device)\n        dino_model_cache[dino_checkpoint] = dino\n    dino.eval()\n    return dino", "def load_dino_model(dino_checkpoint, dino_install_success):\n    print(f\"Initializing GroundingDINO {dino_checkpoint}\")\n    if dino_checkpoint in dino_model_cache:\n        dino = dino_model_cache[dino_checkpoint]\n        if shared.cmd_opts.lowvram:\n            dino.to(device=device)\n    else:\n        clear_dino_cache()\n        if dino_install_success:\n            from groundingdino.models import build_model\n            from groundingdino.util.slconfig import SLConfig\n            from groundingdino.util.utils import clean_state_dict\n        else:\n            from local_groundingdino.models import build_model\n            from local_groundingdino.util.slconfig import SLConfig\n            from local_groundingdino.util.utils import clean_state_dict\n        args = SLConfig.fromfile(dino_model_info[dino_checkpoint][\"config\"])\n        dino = build_model(args)\n        checkpoint = torch.hub.load_state_dict_from_url(\n            dino_model_info[dino_checkpoint][\"url\"], dino_model_dir)\n        dino.load_state_dict(clean_state_dict(\n            checkpoint['model']), strict=False)\n        dino.to(device=device)\n        dino_model_cache[dino_checkpoint] = dino\n    dino.eval()\n    return dino", "\n\ndef load_dino_image(image_pil, dino_install_success):\n    if dino_install_success:\n        import groundingdino.datasets.transforms as T\n    else:\n        from local_groundingdino.datasets import transforms as T\n    transform = T.Compose(\n        [\n            T.RandomResize([800], max_size=1333),\n            T.ToTensor(),\n            T.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225]),\n        ]\n    )\n    image, _ = transform(image_pil, None)  # 3, h, w\n    return image", "\n\ndef get_grounding_output(model, image, caption, box_threshold):\n    caption = caption.lower()\n    caption = caption.strip()\n    if not caption.endswith(\".\"):\n        caption = caption + \".\"\n    image = image.to(device)\n    with torch.no_grad():\n        outputs = model(image[None], captions=[caption])\n    if shared.cmd_opts.lowvram:\n        model.to(cpu)\n    logits = outputs[\"pred_logits\"].sigmoid()[0]  # (nq, 256)\n    boxes = outputs[\"pred_boxes\"][0]  # (nq, 4)\n\n    # filter output\n    logits_filt = logits.clone()\n    boxes_filt = boxes.clone()\n    filt_mask = logits_filt.max(dim=1)[0] > box_threshold\n    logits_filt = logits_filt[filt_mask]  # num_filt, 256\n    boxes_filt = boxes_filt[filt_mask]  # num_filt, 4\n\n    return boxes_filt.cpu()", "\n\ndef dino_predict_internal(input_image, dino_model_name, text_prompt, box_threshold):\n    install_success = install_goundingdino()\n    print(\"Running GroundingDINO Inference\")\n    dino_image = load_dino_image(input_image.convert(\"RGB\"), install_success)\n    dino_model = load_dino_model(dino_model_name, install_success)\n    install_success = install_success or shared.opts.data.get(\"sam_use_local_groundingdino\", False)\n\n    boxes_filt = get_grounding_output(\n        dino_model, dino_image, text_prompt, box_threshold\n    )\n\n    H, W = input_image.size[1], input_image.size[0]\n    for i in range(boxes_filt.size(0)):\n        boxes_filt[i] = boxes_filt[i] * torch.Tensor([W, H, W, H])\n        boxes_filt[i][:2] -= boxes_filt[i][2:] / 2\n        boxes_filt[i][2:] += boxes_filt[i][:2]\n    gc.collect()\n    torch_gc()\n    return boxes_filt, install_success", ""]}
{"filename": "scripts/sam.py", "chunked_list": ["import gc\nimport os\nimport copy\nimport glob\nimport numpy as np\nfrom PIL import Image\nimport torch\nimport gradio as gr\nfrom collections import OrderedDict\nfrom scipy.ndimage import binary_dilation", "from collections import OrderedDict\nfrom scipy.ndimage import binary_dilation\nfrom modules import scripts, shared, script_callbacks\nfrom modules.ui import gr_show\nfrom modules.ui_components import FormRow\nfrom modules.safe import unsafe_torch_load, load\nfrom modules.processing import StableDiffusionProcessingImg2Img, StableDiffusionProcessing\nfrom modules.devices import device, torch_gc, cpu\nfrom modules.paths import models_path\nfrom sam_hq.predictor import SamPredictorHQ", "from modules.paths import models_path\nfrom sam_hq.predictor import SamPredictorHQ\nfrom sam_hq.build_sam_hq import sam_model_registry\nfrom scripts.dino import dino_model_list, dino_predict_internal, show_boxes, clear_dino_cache, dino_install_issue_text\nfrom scripts.auto import clear_sem_sam_cache, register_auto_sam, semantic_segmentation, sem_sam_garbage_collect, image_layer_internal, categorical_mask_image\nfrom scripts.process_params import SAMProcessUnit, max_cn_num\n\n\nrefresh_symbol = '\\U0001f504'       # \ud83d\udd04\nsam_model_cache = OrderedDict()", "refresh_symbol = '\\U0001f504'       # \ud83d\udd04\nsam_model_cache = OrderedDict()\nscripts_sam_model_dir = os.path.join(scripts.basedir(), \"models/sam\") \nsd_sam_model_dir = os.path.join(models_path, \"sam\")\nsam_model_dir = sd_sam_model_dir if os.path.exists(sd_sam_model_dir) else scripts_sam_model_dir \nsam_model_list = [f for f in os.listdir(sam_model_dir) if os.path.isfile(os.path.join(sam_model_dir, f)) and f.split('.')[-1] != 'txt']\nsam_device = device\n\n\ntxt2img_width: gr.Slider = None", "\ntxt2img_width: gr.Slider = None\ntxt2img_height: gr.Slider = None\nimg2img_width: gr.Slider = None\nimg2img_height: gr.Slider = None\n\n\nclass ToolButton(gr.Button, gr.components.FormComponent):\n    \"\"\"Small button with single emoji as text, fits inside gradio forms\"\"\"\n\n    def __init__(self, **kwargs):\n        super().__init__(variant=\"tool\", **kwargs)\n\n    def get_block_name(self):\n        return \"button\"", "        \n\ndef show_masks(image_np, masks: np.ndarray, alpha=0.5):\n    image = copy.deepcopy(image_np)\n    np.random.seed(0)\n    for mask in masks:\n        color = np.concatenate([np.random.random(3), np.array([0.6])], axis=0)\n        image[mask] = image[mask] * (1 - alpha) + 255 * color.reshape(1, 1, -1) * alpha\n    return image.astype(np.uint8)\n", "\n\ndef update_mask(mask_gallery, chosen_mask, dilation_amt, input_image):\n    print(\"Dilation Amount: \", dilation_amt)\n    if isinstance(mask_gallery, list):\n        mask_image = Image.open(mask_gallery[chosen_mask + 3]['name'])\n    else:\n        mask_image = mask_gallery\n    binary_img = np.array(mask_image.convert('1'))\n    if dilation_amt:\n        mask_image, binary_img = dilate_mask(binary_img, dilation_amt)\n    blended_image = Image.fromarray(show_masks(np.array(input_image), binary_img.astype(np.bool_)[None, ...]))\n    matted_image = np.array(input_image)\n    matted_image[~binary_img] = np.array([0, 0, 0, 0])\n    return [blended_image, mask_image, Image.fromarray(matted_image)]", "\n\ndef load_sam_model(sam_checkpoint):\n    model_type = sam_checkpoint.split('.')[0]\n    if 'hq' not in model_type and 'mobile' not in model_type:\n        model_type = '_'.join(model_type.split('_')[:-1])\n    sam_checkpoint_path = os.path.join(sam_model_dir, sam_checkpoint)\n    torch.load = unsafe_torch_load\n    sam = sam_model_registry[model_type](checkpoint=sam_checkpoint_path)\n    sam.to(device=sam_device)\n    sam.eval()\n    torch.load = load\n    return sam", "\n\ndef clear_sam_cache():\n    sam_model_cache.clear()\n    gc.collect()\n    torch_gc()\n\n\ndef clear_cache():\n    clear_sam_cache()\n    clear_dino_cache()\n    clear_sem_sam_cache()", "def clear_cache():\n    clear_sam_cache()\n    clear_dino_cache()\n    clear_sem_sam_cache()\n\n\ndef garbage_collect(sam):\n    if shared.cmd_opts.lowvram:\n        sam.to(cpu)\n    gc.collect()\n    torch_gc()", "\n\ndef refresh_sam_models(*inputs):\n    global sam_model_list\n    sam_model_list = [f for f in os.listdir(sam_model_dir) if os.path.isfile(\n        os.path.join(sam_model_dir, f)) and f.split('.')[-1] != 'txt']\n    dd = inputs[0]\n    if dd in sam_model_list:\n        selected = dd\n    elif len(sam_model_list) > 0:\n        selected = sam_model_list[0]\n    else:\n        selected = None\n    return gr.Dropdown.update(choices=sam_model_list, value=selected)", "\n\ndef init_sam_model(sam_model_name):\n    print(f\"Initializing SAM to {sam_device}\")\n    if sam_model_name in sam_model_cache:\n        sam = sam_model_cache[sam_model_name]\n        if shared.cmd_opts.lowvram or (str(sam_device) not in str(sam.device)):\n            sam.to(device=sam_device)\n        return sam\n    elif sam_model_name in sam_model_list:\n        clear_sam_cache()\n        sam_model_cache[sam_model_name] = load_sam_model(sam_model_name)\n        return sam_model_cache[sam_model_name]\n    else:\n        raise Exception(\n            f\"{sam_model_name} not found, please download model to models/sam.\")", "\n\ndef dilate_mask(mask, dilation_amt):\n    x, y = np.meshgrid(np.arange(dilation_amt), np.arange(dilation_amt))\n    center = dilation_amt // 2\n    dilation_kernel = ((x - center)**2 + (y - center)**2 <= center**2).astype(np.uint8)\n    dilated_binary_img = binary_dilation(mask, dilation_kernel)\n    dilated_mask = Image.fromarray(dilated_binary_img.astype(np.uint8) * 255)\n    return dilated_mask, dilated_binary_img\n", "\n\ndef create_mask_output(image_np, masks, boxes_filt):\n    print(\"Creating output image\")\n    mask_images, masks_gallery, matted_images = [], [], []\n    boxes_filt = boxes_filt.numpy().astype(int) if boxes_filt is not None else None\n    for mask in masks:\n        masks_gallery.append(Image.fromarray(np.any(mask, axis=0)))\n        blended_image = show_masks(show_boxes(image_np, boxes_filt), mask)\n        mask_images.append(Image.fromarray(blended_image))\n        image_np_copy = copy.deepcopy(image_np)\n        image_np_copy[~np.any(mask, axis=0)] = np.array([0, 0, 0, 0])\n        matted_images.append(Image.fromarray(image_np_copy))\n    return mask_images + masks_gallery + matted_images", "\n\ndef create_mask_batch_output(\n    input_image_file, dino_batch_dest_dir, \n    image_np, masks, boxes_filt, batch_dilation_amt, \n    dino_batch_save_image, dino_batch_save_mask, dino_batch_save_background, dino_batch_save_image_with_mask):\n    print(\"Creating batch output image\")\n    filename, ext = os.path.splitext(os.path.basename(input_image_file))\n    ext = \".png\" # JPEG not compatible with RGBA\n    for idx, mask in enumerate(masks):\n        blended_image = show_masks(show_boxes(image_np, boxes_filt), mask)\n        merged_mask = np.any(mask, axis=0)\n        if dino_batch_save_background:\n            merged_mask = ~merged_mask\n        if batch_dilation_amt:\n            _, merged_mask = dilate_mask(merged_mask, batch_dilation_amt)\n        image_np_copy = copy.deepcopy(image_np)\n        image_np_copy[~merged_mask] = np.array([0, 0, 0, 0])\n        if dino_batch_save_image:\n            output_image = Image.fromarray(image_np_copy)\n            output_image.save(os.path.join(dino_batch_dest_dir, f\"{filename}_{idx}_output{ext}\"))\n        if dino_batch_save_mask:\n            output_mask = Image.fromarray(merged_mask)\n            output_mask.save(os.path.join(dino_batch_dest_dir, f\"{filename}_{idx}_mask{ext}\"))\n        if dino_batch_save_image_with_mask:\n            output_blend = Image.fromarray(blended_image)\n            output_blend.save(os.path.join(dino_batch_dest_dir, f\"{filename}_{idx}_blend{ext}\"))", "\n\ndef sam_predict(sam_model_name, input_image, positive_points, negative_points,\n                dino_checkbox, dino_model_name, text_prompt, box_threshold,\n                dino_preview_checkbox, dino_preview_boxes_selection):\n    print(\"Start SAM Processing\")\n    if sam_model_name is None:\n        return [], \"SAM model not found. Please download SAM model from extension README.\"\n    if input_image is None:\n        return [], \"SAM requires an input image. Please upload an image first.\"\n    image_np = np.array(input_image)\n    image_np_rgb = image_np[..., :3]\n    dino_enabled = dino_checkbox and text_prompt is not None\n    boxes_filt = None\n    sam_predict_result = \" done.\"\n    if dino_enabled:\n        boxes_filt, install_success = dino_predict_internal(input_image, dino_model_name, text_prompt, box_threshold)\n        if dino_preview_checkbox is not None and dino_preview_checkbox and dino_preview_boxes_selection is not None:\n            valid_indices = [int(i) for i in dino_preview_boxes_selection if int(i) < boxes_filt.shape[0]]\n            boxes_filt = boxes_filt[valid_indices]\n    sam = init_sam_model(sam_model_name)\n    print(f\"Running SAM Inference {image_np_rgb.shape}\")\n    predictor = SamPredictorHQ(sam, 'hq' in sam_model_name)\n    predictor.set_image(image_np_rgb)\n    if dino_enabled and boxes_filt.shape[0] > 1:\n        sam_predict_status = f\"SAM inference with {boxes_filt.shape[0]} boxes, point prompts discarded\"\n        print(sam_predict_status)\n        transformed_boxes = predictor.transform.apply_boxes_torch(boxes_filt, image_np.shape[:2])\n        masks, _, _ = predictor.predict_torch(\n            point_coords=None,\n            point_labels=None,\n            boxes=transformed_boxes.to(sam_device),\n            multimask_output=True)\n        masks = masks.permute(1, 0, 2, 3).cpu().numpy()\n    else:\n        num_box = 0 if boxes_filt is None else boxes_filt.shape[0]\n        num_points = len(positive_points) + len(negative_points)\n        if num_box == 0 and num_points == 0:\n            garbage_collect(sam)\n            if dino_enabled and dino_preview_checkbox and num_box == 0:\n                return [], \"It seems that you are using a high box threshold with no point prompts. Please lower your box threshold and re-try.\"\n            return [], \"You neither added point prompts nor enabled GroundingDINO. Segmentation cannot be generated.\"\n        sam_predict_status = f\"SAM inference with {num_box} box, {len(positive_points)} positive prompts, {len(negative_points)} negative prompts\"\n        print(sam_predict_status)\n        point_coords = np.array(positive_points + negative_points)\n        point_labels = np.array([1] * len(positive_points) + [0] * len(negative_points))\n        box = copy.deepcopy(boxes_filt[0].numpy()) if boxes_filt is not None and boxes_filt.shape[0] > 0 else None\n        masks, _, _ = predictor.predict(\n            point_coords=point_coords if len(point_coords) > 0 else None,\n            point_labels=point_labels if len(point_coords) > 0 else None,\n            box=box,\n            multimask_output=True)\n        masks = masks[:, None, ...]\n    garbage_collect(sam)\n    return create_mask_output(image_np, masks, boxes_filt), sam_predict_status + sam_predict_result + (f\" However, GroundingDINO installment has failed. Your process automatically fall back to local groundingdino. Check your terminal for more detail and {dino_install_issue_text}.\" if (dino_enabled and not install_success) else \"\")", "\n\ndef dino_predict(input_image, dino_model_name, text_prompt, box_threshold):\n    if input_image is None:\n        return None, gr.update(), gr.update(visible=True, value=f\"GroundingDINO requires input image.\")\n    if text_prompt is None or text_prompt == \"\":\n        return None, gr.update(), gr.update(visible=True, value=f\"GroundingDINO requires text prompt.\")\n    image_np = np.array(input_image)\n    boxes_filt, install_success = dino_predict_internal(input_image, dino_model_name, text_prompt, box_threshold)\n    boxes_filt = boxes_filt.numpy()\n    boxes_choice = [str(i) for i in range(boxes_filt.shape[0])]\n    return Image.fromarray(show_boxes(image_np, boxes_filt.astype(int), show_index=True)), gr.update(choices=boxes_choice, value=boxes_choice), gr.update(visible=False) if install_success else gr.update(visible=True, value=f\"GroundingDINO installment failed. Your process automatically fall back to local groundingdino. See your terminal for more detail and {dino_install_issue_text}\")", "\n\ndef dino_batch_process(\n    batch_sam_model_name, batch_dino_model_name, batch_text_prompt, batch_box_threshold, batch_dilation_amt,\n    dino_batch_source_dir, dino_batch_dest_dir,\n    dino_batch_output_per_image, dino_batch_save_image, dino_batch_save_mask, dino_batch_save_background, dino_batch_save_image_with_mask):\n    if batch_text_prompt is None or batch_text_prompt == \"\":\n        return \"Please add text prompts to generate masks\"\n    print(\"Start batch processing\")\n    sam = init_sam_model(batch_sam_model_name)\n    predictor = SamPredictorHQ(sam, 'hq' in batch_sam_model_name)\n\n    if not os.path.exists(dino_batch_dest_dir):\n        os.makedirs(dino_batch_dest_dir)\n        print(f\"Destination directory created: {dino_batch_dest_dir}\")\n    \n    process_info = \"\"\n    install_success = True\n    all_files = glob.glob(os.path.join(dino_batch_source_dir, \"*\"))\n    for image_index, input_image_file in enumerate(all_files):\n        print(f\"Processing {image_index}/{len(all_files)} {input_image_file}\")\n        try:\n            input_image = Image.open(input_image_file).convert(\"RGBA\")\n        except:\n            print(f\"File {input_image_file} not image, skipped.\")\n            continue\n        image_np = np.array(input_image)\n        image_np_rgb = image_np[..., :3]\n\n        boxes_filt, install_success = dino_predict_internal(input_image, batch_dino_model_name, batch_text_prompt, batch_box_threshold)\n        if boxes_filt is None or boxes_filt.shape[0] == 0:\n            msg = f\"GroundingDINO generated 0 box for image {input_image_file}, please lower the box threshold if you want any segmentation for this image. \"\n            print(msg)\n            process_info += (msg + \"\\n\")\n            continue\n        \n        predictor.set_image(image_np_rgb)\n        transformed_boxes = predictor.transform.apply_boxes_torch(boxes_filt, image_np.shape[:2])\n        masks, _, _ = predictor.predict_torch(\n            point_coords=None,\n            point_labels=None,\n            boxes=transformed_boxes.to(sam_device),\n            multimask_output=(dino_batch_output_per_image == 1))\n        \n        masks = masks.permute(1, 0, 2, 3).cpu().numpy()\n        boxes_filt = boxes_filt.cpu().numpy().astype(int)\n        \n        create_mask_batch_output(\n            input_image_file, dino_batch_dest_dir, \n            image_np, masks, boxes_filt, batch_dilation_amt, \n            dino_batch_save_image, dino_batch_save_mask, dino_batch_save_background, dino_batch_save_image_with_mask)\n    \n    garbage_collect(sam)\n    return process_info + \"Done\" + (\"\" if install_success else f\". However, GroundingDINO installment has failed. Your process automatically fall back to local groundingdino. See your terminal for more detail and {dino_install_issue_text}\")", "\n\ndef cnet_seg(\n    sam_model_name, cnet_seg_input_image, cnet_seg_processor, cnet_seg_processor_res, \n    cnet_seg_pixel_perfect, cnet_seg_resize_mode, target_W, target_H,\n    auto_sam_points_per_side, auto_sam_points_per_batch, auto_sam_pred_iou_thresh, \n    auto_sam_stability_score_thresh, auto_sam_stability_score_offset, auto_sam_box_nms_thresh, \n    auto_sam_crop_n_layers, auto_sam_crop_nms_thresh, auto_sam_crop_overlap_ratio, \n    auto_sam_crop_n_points_downscale_factor, auto_sam_min_mask_region_area):\n    print(f\"Start semantic segmentation with processor {cnet_seg_processor}\")\n    auto_sam_output_mode = \"coco_rle\" if \"seg\" in cnet_seg_processor else \"binary_mask\"\n    sam = load_sam_model(sam_model_name)\n    predictor = SamPredictorHQ(sam, 'hq' in sam_model_name)\n    register_auto_sam(predictor, auto_sam_points_per_side, auto_sam_points_per_batch, auto_sam_pred_iou_thresh, \n    auto_sam_stability_score_thresh, auto_sam_stability_score_offset, auto_sam_box_nms_thresh, \n    auto_sam_crop_n_layers, auto_sam_crop_nms_thresh, auto_sam_crop_overlap_ratio, \n    auto_sam_crop_n_points_downscale_factor, auto_sam_min_mask_region_area, auto_sam_output_mode)\n    outputs = semantic_segmentation(cnet_seg_input_image, cnet_seg_processor, cnet_seg_processor_res,\n                                    cnet_seg_pixel_perfect, cnet_seg_resize_mode, target_W, target_H)\n    sem_sam_garbage_collect()\n    garbage_collect(sam)\n    return outputs", "\n\ndef image_layout(\n    sam_model_name, layout_input_image_or_path, layout_output_path, \n    auto_sam_points_per_side, auto_sam_points_per_batch, auto_sam_pred_iou_thresh, \n    auto_sam_stability_score_thresh, auto_sam_stability_score_offset, auto_sam_box_nms_thresh, \n    auto_sam_crop_n_layers, auto_sam_crop_nms_thresh, auto_sam_crop_overlap_ratio, \n    auto_sam_crop_n_points_downscale_factor, auto_sam_min_mask_region_area):\n    print(\"Start processing image layout\")\n    sam = load_sam_model(sam_model_name)\n    predictor = SamPredictorHQ(sam, 'hq' in sam_model_name)\n    register_auto_sam(predictor, auto_sam_points_per_side, auto_sam_points_per_batch, auto_sam_pred_iou_thresh, \n    auto_sam_stability_score_thresh, auto_sam_stability_score_offset, auto_sam_box_nms_thresh, \n    auto_sam_crop_n_layers, auto_sam_crop_nms_thresh, auto_sam_crop_overlap_ratio, \n    auto_sam_crop_n_points_downscale_factor, auto_sam_min_mask_region_area, \"binary_mask\")\n    outputs = image_layer_internal(layout_input_image_or_path, layout_output_path)\n    sem_sam_garbage_collect()\n    garbage_collect(sam)\n    return outputs", "\n\ndef categorical_mask(\n    sam_model_name, crop_processor, crop_processor_res, \n    crop_pixel_perfect, crop_resize_mode, target_W, target_H,\n    crop_category_input, crop_input_image, \n    auto_sam_points_per_side, auto_sam_points_per_batch, auto_sam_pred_iou_thresh, \n    auto_sam_stability_score_thresh, auto_sam_stability_score_offset, auto_sam_box_nms_thresh, \n    auto_sam_crop_n_layers, auto_sam_crop_nms_thresh, auto_sam_crop_overlap_ratio, \n    auto_sam_crop_n_points_downscale_factor, auto_sam_min_mask_region_area):\n    print(\"Start processing categorical mask\")\n    sam = load_sam_model(sam_model_name)\n    predictor = SamPredictorHQ(sam, 'hq' in sam_model_name)\n    register_auto_sam(predictor, auto_sam_points_per_side, auto_sam_points_per_batch, auto_sam_pred_iou_thresh, \n    auto_sam_stability_score_thresh, auto_sam_stability_score_offset, auto_sam_box_nms_thresh, \n    auto_sam_crop_n_layers, auto_sam_crop_nms_thresh, auto_sam_crop_overlap_ratio, \n    auto_sam_crop_n_points_downscale_factor, auto_sam_min_mask_region_area, \"coco_rle\")\n    outputs, resized_input_image = categorical_mask_image(crop_processor, crop_processor_res, crop_category_input, crop_input_image,\n                                                          crop_pixel_perfect, crop_resize_mode, target_W, target_H)\n    resized_input_image_pil = Image.fromarray(resized_input_image).convert(\"RGBA\")\n    resized_input_image_np = np.array(resized_input_image_pil)\n    sem_sam_garbage_collect()\n    garbage_collect(sam)\n    if isinstance(outputs, str):\n        return [], outputs, None\n    output_gallery = create_mask_output(resized_input_image_np, outputs[None, None, ...], None)\n    return output_gallery, \"Done\", resized_input_image_pil", "\n\ndef categorical_mask_batch(\n    sam_model_name, crop_processor, crop_processor_res, \n    crop_pixel_perfect, crop_resize_mode, target_W, targe_H,\n    crop_category_input, crop_batch_dilation_amt, crop_batch_source_dir, crop_batch_dest_dir, \n    crop_batch_save_image, crop_batch_save_mask, crop_batch_save_image_with_mask, crop_batch_save_background, \n    auto_sam_points_per_side, auto_sam_points_per_batch, auto_sam_pred_iou_thresh, \n    auto_sam_stability_score_thresh, auto_sam_stability_score_offset, auto_sam_box_nms_thresh, \n    auto_sam_crop_n_layers, auto_sam_crop_nms_thresh, auto_sam_crop_overlap_ratio, \n    auto_sam_crop_n_points_downscale_factor, auto_sam_min_mask_region_area):\n    print(\"Start processing categorical mask in batch\")\n    sam = load_sam_model(sam_model_name)\n    predictor = SamPredictorHQ(sam, 'hq' in sam_model_name)\n    register_auto_sam(predictor, auto_sam_points_per_side, auto_sam_points_per_batch, auto_sam_pred_iou_thresh, \n    auto_sam_stability_score_thresh, auto_sam_stability_score_offset, auto_sam_box_nms_thresh, \n    auto_sam_crop_n_layers, auto_sam_crop_nms_thresh, auto_sam_crop_overlap_ratio, \n    auto_sam_crop_n_points_downscale_factor, auto_sam_min_mask_region_area, \"coco_rle\")\n    all_files = glob.glob(os.path.join(crop_batch_source_dir, \"*\"))\n    process_info = \"\"\n    for image_index, input_image_file in enumerate(all_files):\n        print(f\"Processing {image_index}/{len(all_files)} {input_image_file}\")\n        try:\n            crop_input_image = Image.open(input_image_file).convert(\"RGB\")\n        except:\n            print(f\"File {input_image_file} not image, skipped.\")\n            continue\n        outputs, resized_input_image = categorical_mask_image(crop_processor, crop_processor_res, crop_category_input, crop_input_image, \n                                                              crop_pixel_perfect, crop_resize_mode, target_W, targe_H)\n        if isinstance(outputs, str):\n            outputs = f\"Image {image_index}: {outputs}\"\n            print(outputs)\n            process_info += outputs + \"\\n\"\n            continue\n        resized_input_image_pil = Image.fromarray(resized_input_image).convert(\"RGBA\")\n        resized_input_image_np = np.array(resized_input_image_pil)\n        create_mask_batch_output(\n            input_image_file, crop_batch_dest_dir, \n            resized_input_image_np, outputs[None, None, ...], None, crop_batch_dilation_amt, \n            crop_batch_save_image, crop_batch_save_mask, crop_batch_save_background, crop_batch_save_image_with_mask)\n    sem_sam_garbage_collect()\n    garbage_collect(sam)\n    return process_info + \"Done\"", "\n\ndef priorize_sam_scripts(is_img2img):\n    cnet_idx, sam_idx = None, None\n    if is_img2img:\n        for idx, s in enumerate(scripts.scripts_img2img.alwayson_scripts):\n            if s.title() == \"Segment Anything\":\n                sam_idx = idx\n            elif s.title() == \"ControlNet\":\n                cnet_idx = idx\n        if cnet_idx is not None and sam_idx is not None and cnet_idx < sam_idx:\n            scripts.scripts_img2img.alwayson_scripts[cnet_idx], scripts.scripts_img2img.alwayson_scripts[\n                sam_idx] = scripts.scripts_img2img.alwayson_scripts[sam_idx], scripts.scripts_img2img.alwayson_scripts[cnet_idx]\n    else:\n        for idx, s in enumerate(scripts.scripts_txt2img.alwayson_scripts):\n            if s.title() == \"Segment Anything\":\n                sam_idx = idx\n            elif s.title() == \"ControlNet\":\n                cnet_idx = idx\n        if cnet_idx is not None and sam_idx is not None and cnet_idx < sam_idx:\n            scripts.scripts_txt2img.alwayson_scripts[cnet_idx], scripts.scripts_txt2img.alwayson_scripts[\n                sam_idx] = scripts.scripts_txt2img.alwayson_scripts[sam_idx], scripts.scripts_txt2img.alwayson_scripts[cnet_idx]", "\n\ndef ui_sketch_inner():\n    sam_inpaint_color_sketch = gr.Image(label=\"Color sketch inpainting\", source=\"upload\", interactive=True, type=\"pil\", tool=\"color-sketch\", image_mode=\"RGBA\")\n    sam_inpaint_mask_alpha = gr.Slider(label=\"Mask transparency\")\n    return sam_inpaint_color_sketch, sam_inpaint_mask_alpha    \n\n\ndef ui_sketch(sam_input_image, is_img2img):\n    with gr.Column(visible=False):\n        sam_sketch_checkbox = gr.Checkbox(value=False, label=\"Enable Sketch\")\n        with gr.Column(visible=False) as sketch_column:\n            sam_inpaint_copy_button = gr.Button(value=\"Copy from input image\")\n            sam_inpaint_color_sketch, sam_inpaint_mask_alpha = ui_sketch_inner()\n        sam_inpaint_copy_button.click(\n                fn=lambda x: x,\n                inputs=[sam_input_image],\n                outputs=[sam_inpaint_color_sketch])\n        sam_sketch_checkbox.change(\n            fn=gr_show,\n            inputs=[sam_sketch_checkbox],\n            outputs=[sketch_column],\n            show_progress=False)\n    return sam_sketch_checkbox, sam_inpaint_color_sketch, sam_inpaint_mask_alpha", "def ui_sketch(sam_input_image, is_img2img):\n    with gr.Column(visible=False):\n        sam_sketch_checkbox = gr.Checkbox(value=False, label=\"Enable Sketch\")\n        with gr.Column(visible=False) as sketch_column:\n            sam_inpaint_copy_button = gr.Button(value=\"Copy from input image\")\n            sam_inpaint_color_sketch, sam_inpaint_mask_alpha = ui_sketch_inner()\n        sam_inpaint_copy_button.click(\n                fn=lambda x: x,\n                inputs=[sam_input_image],\n                outputs=[sam_inpaint_color_sketch])\n        sam_sketch_checkbox.change(\n            fn=gr_show,\n            inputs=[sam_sketch_checkbox],\n            outputs=[sketch_column],\n            show_progress=False)\n    return sam_sketch_checkbox, sam_inpaint_color_sketch, sam_inpaint_mask_alpha", "\ndef ui_dilation(sam_output_mask_gallery, sam_output_chosen_mask, sam_input_image):\n    sam_dilation_checkbox = gr.Checkbox(value=False, label=\"Expand Mask\")\n    with gr.Column(visible=False) as dilation_column:\n        sam_dilation_amt = gr.Slider(minimum=0, maximum=100, default=0, value=0, label=\"Specify the amount that you wish to expand the mask by (recommend 30)\")\n        sam_dilation_output_gallery = gr.Gallery(label=\"Expanded Mask\").style(grid=3)\n        sam_dilation_submit = gr.Button(value=\"Update Mask\")\n        sam_dilation_submit.click(\n            fn=update_mask,\n            inputs=[sam_output_mask_gallery, sam_output_chosen_mask, sam_dilation_amt, sam_input_image],\n            outputs=[sam_dilation_output_gallery])\n    sam_dilation_checkbox.change(\n        fn=gr_show,\n        inputs=[sam_dilation_checkbox],\n        outputs=[dilation_column],\n        show_progress=False)\n    return sam_dilation_checkbox, sam_dilation_output_gallery", "\n\ndef ui_inpaint(is_img2img, max_cn):\n    with FormRow():\n        if is_img2img:\n            inpaint_upload_enable_label = \"Copy to Inpaint Upload\" + (\" & img2img ControlNet Inpainting\" if max_cn > 0 else \"\")\n        else:\n            inpaint_upload_enable_label = \"Copy to txt2img ControlNet Inpainting\" if max_cn > 0 else \"\"\n        inpaint_upload_enable = gr.Checkbox(value=False, label=inpaint_upload_enable_label, visible=(len(inpaint_upload_enable_label) > 0))\n        cnet_inpaint_invert = gr.Checkbox(value=False, label='ControlNet inpaint not masked', visible=((max_cn > 0) and not is_img2img))\n        cnet_inpaint_idx = gr.Radio(value=\"0\" if max_cn > 0 else None, choices=[str(i) for i in range(max_cn)], label='ControlNet Inpaint Index', type=\"index\", visible=((max_cn > 0) and not is_img2img))\n    return inpaint_upload_enable, cnet_inpaint_invert, cnet_inpaint_idx", "\n\ndef ui_batch(is_dino):\n    dino_batch_dilation_amt = gr.Slider(minimum=0, maximum=100, default=0, value=0, label=\"Specify the amount that you wish to expand the mask by (recommend 0-10)\")\n    dino_batch_source_dir = gr.Textbox(label=\"Source directory\")\n    dino_batch_dest_dir = gr.Textbox(label=\"Destination directory\")\n    with gr.Row():\n        dino_batch_output_per_image = gr.Radio(choices=[\"1\", \"3\"], value=\"3\", type=\"index\", label=\"Output per image: \", visible=is_dino)\n        dino_batch_save_image = gr.Checkbox(value=True, label=\"Save masked image\")\n        dino_batch_save_mask = gr.Checkbox(value=True, label=\"Save mask\")\n        dino_batch_save_image_with_mask = gr.Checkbox(value=True, label=\"Save original image with mask and bounding box\")\n        dino_batch_save_background = gr.Checkbox(value=False, label=\"Save background instead of foreground\")\n    dino_batch_run_button = gr.Button(value=\"Start batch process\")\n    dino_batch_progress = gr.Text(value=\"\", label=\"GroundingDINO batch progress status\")\n    return dino_batch_dilation_amt, dino_batch_source_dir, dino_batch_dest_dir, dino_batch_output_per_image, dino_batch_save_image, dino_batch_save_mask, dino_batch_save_image_with_mask, dino_batch_save_background, dino_batch_run_button, dino_batch_progress", "\n\ndef ui_processor(use_random=True, use_cnet=True):\n    processor_choices = [\"seg_ufade20k\", \"seg_ofade20k\", \"seg_ofcoco\"]\n    if use_random:\n        processor_choices.append(\"random\")\n    with gr.Row():\n        cnet_seg_processor = gr.Radio(choices=processor_choices, value=\"seg_ufade20k\", label=\"Choose preprocessor for semantic segmentation: \")\n        cnet_seg_processor_res = gr.Slider(label=\"Preprocessor resolution\", value=512, minimum=64, maximum=2048, step=1)\n        cnet_seg_resize_mode = gr.Radio(choices=[\"Just Resize\", \"Crop and Resize\", \"Resize and Fill\"], value=\"Crop and Resize\", label=\"Resize Mode\", type=\"index\", visible=False)\n        if use_random and use_cnet:\n            cnet_seg_gallery_input = gr.Radio(\n                choices=[\"1\", \"2\"], value=\"2\", type=\"index\", visible=False, \n                label=\"Select ControlNet input from random segmentation gallery. Choose 2 for Edit-Anything ControlNet.\")\n        else:\n            cnet_seg_gallery_input = gr.Label(visible=False)\n    with gr.Row():\n        cnet_seg_pixel_perfect = gr.Checkbox(value=False, label=\"Enable Pixel Perfect from lllyasviel. \"\n                                             \"Configure your target width and height on txt2img/img2img default panel before preview if you wish to enable pixel perfect.\")\n        if use_random and use_cnet:\n            cnet_seg_processor.change(\n                fn=lambda x, y: (gr_show(x==\"random\"), gr_show(x!=\"random\"), gr_show(x!=\"random\" and not y), gr_show(x!=\"random\" and y)),\n                inputs=[cnet_seg_processor, cnet_seg_pixel_perfect],\n                outputs=[cnet_seg_gallery_input, cnet_seg_pixel_perfect, cnet_seg_processor_res, cnet_seg_resize_mode],\n                show_progress=False)\n    cnet_seg_pixel_perfect.change(\n        fn=lambda x: (gr_show(x), gr_show(not x)),\n        inputs=[cnet_seg_pixel_perfect],\n        outputs=[cnet_seg_resize_mode, cnet_seg_processor_res],\n        show_progress=False)\n    return cnet_seg_processor, cnet_seg_processor_res, cnet_seg_gallery_input, cnet_seg_pixel_perfect, cnet_seg_resize_mode", "\n\nclass Script(scripts.Script):\n\n    def title(self):\n        return 'Segment Anything'\n\n    def show(self, is_img2img):\n        return scripts.AlwaysVisible\n\n    def ui(self, is_img2img):\n        if max_cn_num() > 0:\n            priorize_sam_scripts(is_img2img)\n        tab_prefix = (\"img2img\" if is_img2img else \"txt2img\") + \"_sam_\"\n        ui_process = ()\n        with gr.Accordion('Segment Anything', open=False):\n            with gr.Row():\n                with gr.Column(scale=10):\n                    with gr.Row():\n                        sam_model_name = gr.Dropdown(label=\"SAM Model\", choices=sam_model_list, value=sam_model_list[0] if len(sam_model_list) > 0 else None)\n                        sam_refresh_models = ToolButton(value=refresh_symbol)\n                        sam_refresh_models.click(refresh_sam_models, sam_model_name, sam_model_name)\n                with gr.Column(scale=1):\n                    sam_use_cpu = gr.Checkbox(value=False, label=\"Use CPU for SAM\")\n                    def change_sam_device(use_cpu=False):\n                        global sam_device\n                        sam_device = \"cpu\" if use_cpu else device\n                    sam_use_cpu.change(fn=change_sam_device, inputs=[sam_use_cpu], show_progress=False)\n            with gr.Tabs():\n                with gr.TabItem(label=\"Single Image\"):\n                    gr.HTML(value=\"<p>Left click the image to add one positive point (black dot). Right click the image to add one negative point (red dot). Left click the point to remove it.</p>\")\n                    sam_input_image = gr.Image(label=\"Image for Segment Anything\", elem_id=f\"{tab_prefix}input_image\", source=\"upload\", type=\"pil\", image_mode=\"RGBA\")\n                    sam_remove_dots = gr.Button(value=\"Remove all point prompts\")\n                    sam_dummy_component = gr.Label(visible=False)\n                    sam_remove_dots.click(\n                        fn=lambda _: None,\n                        _js=\"samRemoveDots\",\n                        inputs=[sam_dummy_component],\n                        outputs=None)\n                    gr.HTML(value=\"<p>GroundingDINO + Segment Anything can achieve [text prompt]->[object detection]->[segmentation]</p>\")\n                    dino_checkbox = gr.Checkbox(value=False, label=\"Enable GroundingDINO\", elem_id=f\"{tab_prefix}dino_enable_checkbox\")\n                    with gr.Column(visible=False) as dino_column:\n                        gr.HTML(value=\"<p>Due to the limitation of Segment Anything, when there are point prompts, at most 1 box prompt will be allowed; when there are multiple box prompts, no point prompts are allowed.</p>\")\n                        dino_model_name = gr.Dropdown(label=\"GroundingDINO Model (Auto download from huggingface)\", choices=dino_model_list, value=dino_model_list[0])\n                        dino_text_prompt = gr.Textbox(placeholder=\"You must enter text prompts to enable groundingdino. Otherwise this extension will fall back to point prompts only.\", label=\"GroundingDINO Detection Prompt\", elem_id=f\"{tab_prefix}dino_text_prompt\")\n                        dino_box_threshold = gr.Slider(label=\"GroundingDINO Box Threshold\", minimum=0.0, maximum=1.0, value=0.3, step=0.001)\n                        dino_preview_checkbox = gr.Checkbox(value=False, label=\"I want to preview GroundingDINO detection result and select the boxes I want.\", elem_id=f\"{tab_prefix}dino_preview_checkbox\")\n                        with gr.Column(visible=False) as dino_preview:\n                            dino_preview_boxes = gr.Image(show_label=False, type=\"pil\", image_mode=\"RGBA\")\n                            dino_preview_boxes_button = gr.Button(value=\"Generate bounding box\", elem_id=f\"{tab_prefix}dino_run_button\")\n                            dino_preview_boxes_selection = gr.CheckboxGroup(label=\"Select your favorite boxes: \", elem_id=f\"{tab_prefix}dino_preview_boxes_selection\")\n                            dino_preview_result = gr.Text(value=\"\", label=\"GroundingDINO preview status\", visible=False)\n                            dino_preview_boxes_button.click(\n                                fn=dino_predict,\n                                _js=\"submit_dino\",\n                                inputs=[sam_input_image, dino_model_name, dino_text_prompt, dino_box_threshold],\n                                outputs=[dino_preview_boxes, dino_preview_boxes_selection, dino_preview_result])\n                        dino_preview_checkbox.change(\n                            fn=gr_show,\n                            inputs=[dino_preview_checkbox],\n                            outputs=[dino_preview],\n                            show_progress=False)\n                    dino_checkbox.change(\n                        fn=gr_show,\n                        inputs=[dino_checkbox],\n                        outputs=[dino_column],\n                        show_progress=False)\n                    sam_output_mask_gallery = gr.Gallery(label='Segment Anything Output').style(grid=3)\n                    sam_submit = gr.Button(value=\"Preview Segmentation\", elem_id=f\"{tab_prefix}run_button\")\n                    sam_result = gr.Text(value=\"\", label=\"Segment Anything status\")\n                    sam_submit.click(\n                        fn=sam_predict,\n                        _js='submit_sam',\n                        inputs=[sam_model_name, sam_input_image,        # SAM\n                                sam_dummy_component, sam_dummy_component,   # Point prompts\n                                dino_checkbox, dino_model_name, dino_text_prompt, dino_box_threshold,  # DINO prompts\n                                dino_preview_checkbox, dino_preview_boxes_selection],  # DINO preview prompts\n                        outputs=[sam_output_mask_gallery, sam_result])\n                    with FormRow():\n                        sam_output_chosen_mask = gr.Radio(label=\"Choose your favorite mask: \", value=\"0\", choices=[\"0\", \"1\", \"2\"], type=\"index\")\n                        gr.Checkbox(value=False, label=\"Preview automatically when add/remove points\", elem_id=f\"{tab_prefix}realtime_preview_checkbox\")\n                    sam_inpaint_upload_enable, sam_cnet_inpaint_invert, sam_cnet_inpaint_idx = ui_inpaint(is_img2img, max_cn_num())\n                    sam_dilation_checkbox, sam_dilation_output_gallery = ui_dilation(sam_output_mask_gallery, sam_output_chosen_mask, sam_input_image)\n                    sam_single_image_process = (\n                        sam_inpaint_upload_enable, sam_cnet_inpaint_invert, sam_cnet_inpaint_idx,\n                        sam_input_image, sam_output_mask_gallery, sam_output_chosen_mask, \n                        sam_dilation_checkbox, sam_dilation_output_gallery)\n                    ui_process += sam_single_image_process\n\n                with gr.TabItem(label=\"Batch Process\"):\n                    gr.Markdown(value=\"You may configurate the following items and generate masked image for all images under a directory. This mode is designed for generating LoRA/LyCORIS training set.\")\n                    gr.Markdown(value=\"The current workflow is [text prompt]->[object detection]->[segmentation]. Semantic segmentation support is in Auto SAM panel.\")\n                    dino_batch_model_name = gr.Dropdown(label=\"GroundingDINO Model (Auto download from huggingface)\", choices=dino_model_list, value=dino_model_list[0])\n                    dino_batch_text_prompt = gr.Textbox(label=\"GroundingDINO Detection Prompt\")\n                    dino_batch_box_threshold = gr.Slider(label=\"GroundingDINO Box Threshold\", minimum=0.0, maximum=1.0, value=0.3, step=0.001)\n                    dino_batch_dilation_amt, dino_batch_source_dir, dino_batch_dest_dir, dino_batch_output_per_image, dino_batch_save_image, dino_batch_save_mask, dino_batch_save_image_with_mask, dino_batch_save_background, dino_batch_run_button, dino_batch_progress = ui_batch(True)\n                    dino_batch_run_button.click(\n                        fn=dino_batch_process,\n                        inputs=[sam_model_name, dino_batch_model_name, dino_batch_text_prompt, dino_batch_box_threshold, dino_batch_dilation_amt,\n                                dino_batch_source_dir, dino_batch_dest_dir, dino_batch_output_per_image, \n                                dino_batch_save_image, dino_batch_save_mask, dino_batch_save_background, dino_batch_save_image_with_mask],\n                        outputs=[dino_batch_progress])\n                    \n                with gr.TabItem(label=\"Auto SAM\"):\n                    gr.Markdown(\"Auto SAM is mainly for semantic segmentation and image layout generation, which is supported based on ControlNet. You must have ControlNet extension installed, and you should not change its directory name (sd-webui-controlnet).\")\n                    gr.Markdown(\"The annotator directory inside the SAM extension directory is only a symbolic link. This is to save your space and make the extension repository clean.\")\n\n                    with gr.Accordion(label=\"Auto SAM Config\", open=False):\n                        gr.Markdown(\"You may configurate automatic sam generation. See [here](https://github.com/facebookresearch/segment-anything/blob/main/segment_anything/automatic_mask_generator.py#L35-L96) for explanation of each parameter. If you still cannot understand, use default.\")\n                        with gr.Row():\n                            auto_sam_points_per_side = gr.Number(label=\"points_per_side\", value=32, precision=0)\n                            auto_sam_points_per_batch = gr.Number(label=\"points_per_batch\", value=64, precision=0)\n                            auto_sam_pred_iou_thresh = gr.Slider(minimum=0, maximum=1, value=0.88, step=0.01, label=\"pred_iou_thresh\")\n                            auto_sam_stability_score_thresh = gr.Slider(minimum=0, maximum=1, value=0.95, step=0.01, label=\"stability_score_thresh\")\n                            auto_sam_stability_score_offset = gr.Number(label=\"stability_score_offset\", value=1)\n                        with gr.Row():\n                            auto_sam_box_nms_thresh = gr.Slider(label=\"box_nms_thresh\", value=0.7, minimum=0, maximum=1, step=0.01)\n                            auto_sam_crop_n_layers = gr.Number(label=\"crop_n_layers\", value=0, precision=0)\n                            auto_sam_crop_nms_thresh = gr.Slider(label=\"crop_nms_thresh\", value=0.7, minimum=0, maximum=1, step=0.01)\n                            auto_sam_crop_overlap_ratio = gr.Slider(label=\"crop_overlap_ratio\", value=512/1500, minimum=0, maximum=1, step=0.01)\n                            auto_sam_crop_n_points_downscale_factor = gr.Number(label=\"crop_n_points_downscale_factor\", value=1, precision=0)\n                        auto_sam_min_mask_region_area = gr.Number(label=\"min_mask_region_area\", value=0, precision=0)\n                        auto_sam_config = (auto_sam_points_per_side, auto_sam_points_per_batch, auto_sam_pred_iou_thresh, \n                                           auto_sam_stability_score_thresh, auto_sam_stability_score_offset, auto_sam_box_nms_thresh, \n                                           auto_sam_crop_n_layers, auto_sam_crop_nms_thresh, auto_sam_crop_overlap_ratio, \n                                           auto_sam_crop_n_points_downscale_factor, auto_sam_min_mask_region_area)\n\n                    with gr.Tabs():\n                        with gr.TabItem(label=\"ControlNet\"):\n                            gr.Markdown(\n                                \"You can enhance semantic segmentation for control_v11p_sd15_seg from lllyasviel. \"\n                                \"You can also utilize [Edit-Anything](https://github.com/sail-sg/EditAnything) and generate images according to random segmentation which preserve image layout.\")\n                            cnet_seg_processor, cnet_seg_processor_res, cnet_seg_gallery_input, cnet_seg_pixel_perfect, cnet_seg_resize_mode = ui_processor(use_cnet=(max_cn_num() > 0))\n                            cnet_seg_input_image = gr.Image(label=\"Image for Auto Segmentation\", source=\"upload\", type=\"pil\", image_mode=\"RGBA\")\n                            cnet_seg_output_gallery = gr.Gallery(label=\"Auto segmentation output\").style(grid=2)\n                            cnet_seg_submit = gr.Button(value=\"Preview segmentation image\")\n                            cnet_seg_status = gr.Text(value=\"\", label=\"Segmentation status\")\n                            cnet_seg_submit.click(\n                                fn=cnet_seg,\n                                inputs=[sam_model_name, cnet_seg_input_image, cnet_seg_processor, cnet_seg_processor_res, cnet_seg_pixel_perfect, cnet_seg_resize_mode, img2img_width if is_img2img else txt2img_width, img2img_height if is_img2img else txt2img_height, *auto_sam_config],\n                                outputs=[cnet_seg_output_gallery, cnet_seg_status])\n                            with gr.Row(visible=(max_cn_num() > 0)):\n                                cnet_seg_enable_copy = gr.Checkbox(value=False, label='Copy to ControlNet Segmentation')\n                                cnet_seg_idx = gr.Radio(value=\"0\" if max_cn_num() > 0 else None, choices=[str(i) for i in range(max_cn_num())], label='ControlNet Segmentation Index', type=\"index\")\n                            auto_sam_process = (cnet_seg_output_gallery, cnet_seg_enable_copy, cnet_seg_idx, cnet_seg_gallery_input)\n                            ui_process += auto_sam_process\n\n                        with gr.TabItem(label=\"Image Layout\"):\n                            gr.Markdown(\"You can generate image layout either in single image or in batch. Since there might be A LOT of outputs, there is no gallery for preview. You need to go to the output folder for either single image or batch process.\")\n                            layout_mode = gr.Radio(choices=[\"single image\", \"batch process\"], value=\"single image\", type=\"index\", label=\"Choose mode: \")\n                            layout_input_image = gr.Image(label=\"Image for Image Layout\", source=\"upload\", type=\"pil\", image_mode=\"RGBA\")\n                            layout_input_path = gr.Textbox(label=\"Input path\", placeholder=\"Enter input path\", visible=False)\n                            layout_output_path = gr.Textbox(label=\"Output path\", placeholder=\"Enter output path\")\n                            layout_submit_single = gr.Button(value=\"Generate layout for single image\")\n                            layout_submit_batch = gr.Button(value=\"Generate layout for batch process\", visible=False)\n                            layout_status = gr.Text(value=\"\", label=\"Image layout status\")\n                            def layout_show(mode):\n                                is_single = mode == 0\n                                return gr_show(is_single), gr_show(is_single), gr_show(not is_single), gr_show(not is_single)\n                            layout_mode.change(\n                                fn=layout_show,\n                                inputs=[layout_mode],\n                                outputs=[layout_input_image, layout_submit_single, layout_input_path, layout_submit_batch])\n                            layout_submit_single.click(\n                                fn=image_layout,\n                                inputs=[sam_model_name, layout_input_image, layout_output_path, *auto_sam_config],\n                                outputs=[layout_status])\n                            layout_submit_batch.click(\n                                fn=image_layout,\n                                inputs=[sam_model_name, layout_input_path, layout_output_path, *auto_sam_config],\n                                outputs=[layout_status])\n\n                        with gr.TabItem(label=\"Mask by Category\"):\n                            gr.Markdown(\n                                \"You can mask images by their categories via semantic segmentation. Please enter category ids (integers), separated by `+`. \"\n                                \"Visit [here](https://github.com/Mikubill/sd-webui-controlnet/blob/main/annotator/oneformer/oneformer/data/datasets/register_ade20k_panoptic.py#L12-L207) for ade20k \"\n                                \"and [here](https://github.com/Mikubill/sd-webui-controlnet/blob/main/annotator/oneformer/detectron2/data/datasets/builtin_meta.py#L20-L153) for coco to get category->id map. Note that coco jumps some numbers, so the actual ID is line_number - 21.\")\n                            crop_processor, crop_processor_res, _, crop_pixel_perfect, crop_resize_mode = ui_processor(False)\n                            crop_category_input = gr.Textbox(placeholder=\"Enter categody ids, separated by +. For example, if you want bed+person, your input should be 7+12 for ade20k and 59+0 for coco.\", label=\"Enter category IDs\")\n                            with gr.Tabs():\n                                with gr.TabItem(label=\"Single Image\"):\n                                    crop_input_image = gr.Image(label=\"Image to be masked\", source=\"upload\", type=\"pil\", image_mode=\"RGBA\")\n                                    crop_output_gallery = gr.Gallery(label=\"Output\").style(grid=3)\n                                    crop_padding = gr.Number(value=-2, visible=False, interactive=False, precision=0)\n                                    crop_resized_image = gr.Image(label=\"Resized image\", source=\"upload\", type=\"pil\", image_mode=\"RGBA\", visible=False)\n                                    crop_submit = gr.Button(value=\"Preview mask\")\n                                    crop_result = gr.Text(value=\"\", label=\"Categorical mask status\")\n                                    crop_submit.click(\n                                        fn=categorical_mask,\n                                        inputs=[sam_model_name, crop_processor, crop_processor_res, crop_pixel_perfect, crop_resize_mode, \n                                                img2img_width if is_img2img else txt2img_width, img2img_height if is_img2img else txt2img_height, \n                                                crop_category_input, crop_input_image, *auto_sam_config],\n                                        outputs=[crop_output_gallery, crop_result, crop_resized_image])\n                                    crop_inpaint_enable, crop_cnet_inpaint_invert, crop_cnet_inpaint_idx = ui_inpaint(is_img2img, max_cn_num())\n                                    crop_dilation_checkbox, crop_dilation_output_gallery = ui_dilation(crop_output_gallery, crop_padding, crop_resized_image)\n                                    crop_single_image_process = (\n                                        crop_inpaint_enable, crop_cnet_inpaint_invert, crop_cnet_inpaint_idx, \n                                        crop_resized_image, crop_output_gallery, crop_padding, \n                                        crop_dilation_checkbox, crop_dilation_output_gallery)\n                                    ui_process += crop_single_image_process\n\n                                with gr.TabItem(label=\"Batch Process\"):\n                                    crop_batch_dilation_amt, crop_batch_source_dir, crop_batch_dest_dir, _, crop_batch_save_image, crop_batch_save_mask, crop_batch_save_image_with_mask, crop_batch_save_background, crop_batch_run_button, crop_batch_progress = ui_batch(False)\n                                    crop_batch_run_button.click(\n                                        fn=categorical_mask_batch,\n                                        inputs=[sam_model_name, crop_processor, crop_processor_res, crop_pixel_perfect, crop_resize_mode, \n                                                img2img_width if is_img2img else txt2img_width, img2img_height if is_img2img else txt2img_height, \n                                                crop_category_input, crop_batch_dilation_amt, crop_batch_source_dir, crop_batch_dest_dir, \n                                                crop_batch_save_image, crop_batch_save_mask, crop_batch_save_image_with_mask, crop_batch_save_background, *auto_sam_config],\n                                        outputs=[crop_batch_progress])\n                            \n                            \n                with gr.TabItem(label=\"Upload Mask to ControlNet Inpainting\"):\n                    gr.Markdown(\"This panel is for those who want to upload mask to ControlNet inpainting. It is not part of the SAM feature. It might be removed someday when ControlNet support uploading image and mask. \"\n                                \"It serves as a temporarily workaround to overcome the unavailability of image with mask uploading feature in ControlNet extension.\")\n                    with gr.Row():\n                        cnet_upload_enable = gr.Checkbox(value=False, label=\"Enable uploading manually created mask to SAM.\")\n                        cnet_upload_num = gr.Radio(value=\"0\", choices=[str(i) for i in range(max_cn_num())], label='ControlNet Inpaint Number', type=\"index\")\n                    with gr.Column(visible=False) as cnet_upload_panel:\n                        cnet_upload_img_inpaint = gr.Image(label=\"Image for ControlNet Inpaint\", show_label=False, source=\"upload\", interactive=True, type=\"pil\")\n                        cnet_upload_mask_inpaint = gr.Image(label=\"Mask for ControlNet Inpaint\", source=\"upload\", interactive=True, type=\"pil\")\n                    cnet_upload_enable.change(\n                        fn=gr_show,\n                        inputs=[cnet_upload_enable],\n                        outputs=[cnet_upload_panel],\n                        show_progress=False)\n                    cnet_upload_process = (cnet_upload_enable, cnet_upload_num, cnet_upload_img_inpaint, cnet_upload_mask_inpaint)\n                    ui_process += cnet_upload_process\n\n                with gr.Row():\n                    switch = gr.Button(value=\"Switch to Inpaint Upload\")\n                    unload = gr.Button(value=\"Unload all models from memory\")\n                    uncheck = gr.Button(value=\"Uncheck all copies\")\n                    switch.click(\n                        fn=lambda _: None,\n                        _js=\"switchToInpaintUpload\",\n                        inputs=[sam_dummy_component],\n                        outputs=None)\n                    unload.click(\n                        fn=clear_cache,\n                        inputs=[],\n                        outputs=[])\n                    uncheck.click(\n                        fn=lambda _: (gr.update(value=False), gr.update(value=False), gr.update(value=False)),\n                        inputs=None,\n                        outputs=[sam_inpaint_upload_enable, cnet_seg_enable_copy, crop_inpaint_enable],\n                        show_progress=False)\n        \n        return ui_process\n\n    def process(self, p: StableDiffusionProcessing, *args):\n        is_img2img = isinstance(p, StableDiffusionProcessingImg2Img)\n        process_unit = SAMProcessUnit(args, is_img2img)\n        process_unit.set_process_attributes(p)", "\n\ndef on_after_component(component, **_kwargs):\n    global txt2img_width\n    if getattr(component, 'elem_id', None) == 'txt2img_width':\n        txt2img_width = component\n        return\n\n    global txt2img_height\n    if getattr(component, 'elem_id', None) == 'txt2img_height':\n        txt2img_height = component\n        return\n\n    global img2img_width\n    if getattr(component, 'elem_id', None) == 'img2img_width':\n        img2img_width = component\n        return\n\n    global img2img_height\n    if getattr(component, 'elem_id', None) == 'img2img_height':\n        img2img_height = component\n        return", "\n\n\ndef on_ui_settings():\n    section = ('segment_anything', \"Segment Anything\")\n    shared.opts.add_option(\"sam_use_local_groundingdino\", shared.OptionInfo(False, \"Use local groundingdino to bypass C++ problem\", section=section))\n\n\nscript_callbacks.on_ui_settings(on_ui_settings)\nscript_callbacks.on_after_component(on_after_component)", "script_callbacks.on_ui_settings(on_ui_settings)\nscript_callbacks.on_after_component(on_after_component)\n"]}
{"filename": "scripts/api.py", "chunked_list": ["import os\nfrom fastapi import FastAPI, Body\nfrom pydantic import BaseModel\nfrom typing import Any, Optional, List\nimport gradio as gr\nfrom PIL import Image\nimport numpy as np\n\nfrom modules.api.api import encode_pil_to_base64, decode_base64_to_image\nfrom scripts.sam import sam_predict, dino_predict, update_mask, cnet_seg, categorical_mask", "from modules.api.api import encode_pil_to_base64, decode_base64_to_image\nfrom scripts.sam import sam_predict, dino_predict, update_mask, cnet_seg, categorical_mask\nfrom scripts.sam import sam_model_list\n\n\ndef decode_to_pil(image):\n    if os.path.exists(image):\n        return Image.open(image)\n    elif type(image) is str:\n        return decode_base64_to_image(image)\n    elif type(image) is Image.Image:\n        return image\n    elif type(image) is np.ndarray:\n        return Image.fromarray(image)\n    else:\n        Exception(\"Not an image\")", "\n\ndef encode_to_base64(image):\n    if type(image) is str:\n        return image\n    elif type(image) is Image.Image:\n        return encode_pil_to_base64(image).decode()\n    elif type(image) is np.ndarray:\n        pil = Image.fromarray(image)\n        return encode_pil_to_base64(pil).decode()\n    else:\n        Exception(\"Invalid type\")", "\n\ndef sam_api(_: gr.Blocks, app: FastAPI):    \n    @app.get(\"/sam/heartbeat\")\n    async def heartbeat():\n        return {            \n            \"msg\": \"Success!\"\n        }\n\n    @app.get(\"/sam/sam-model\", description='Query available SAM model')\n    async def api_sam_model() -> List[str]:\n        return sam_model_list\n\n    class SamPredictRequest(BaseModel):\n        sam_model_name: str = \"sam_vit_h_4b8939.pth\"\n        input_image: str\n        sam_positive_points: List[List[float]] = []\n        sam_negative_points: List[List[float]] = []\n        dino_enabled: bool = False\n        dino_model_name: Optional[str] = \"GroundingDINO_SwinT_OGC (694MB)\"\n        dino_text_prompt: Optional[str] = None\n        dino_box_threshold: Optional[float] = 0.3\n        dino_preview_checkbox: bool = False\n        dino_preview_boxes_selection: Optional[List[int]] = None\n\n    @app.post(\"/sam/sam-predict\")\n    async def api_sam_predict(payload: SamPredictRequest = Body(...)) -> Any:\n        print(f\"SAM API /sam/sam-predict received request\")\n        payload.input_image = decode_to_pil(payload.input_image).convert('RGBA')\n        sam_output_mask_gallery, sam_message = sam_predict(\n            payload.sam_model_name,\n            payload.input_image,\n            payload.sam_positive_points,\n            payload.sam_negative_points,\n            payload.dino_enabled,\n            payload.dino_model_name,\n            payload.dino_text_prompt,\n            payload.dino_box_threshold,\n            payload.dino_preview_checkbox,\n            payload.dino_preview_boxes_selection)\n        print(f\"SAM API /sam/sam-predict finished with message: {sam_message}\")\n        result = {\n            \"msg\": sam_message,\n        }\n        if len(sam_output_mask_gallery) == 9:\n            result[\"blended_images\"] = list(map(encode_to_base64, sam_output_mask_gallery[:3]))\n            result[\"masks\"] = list(map(encode_to_base64, sam_output_mask_gallery[3:6]))\n            result[\"masked_images\"] = list(map(encode_to_base64, sam_output_mask_gallery[6:]))\n        return result\n\n    class DINOPredictRequest(BaseModel):\n        input_image: str\n        dino_model_name: str = \"GroundingDINO_SwinT_OGC (694MB)\"\n        text_prompt: str\n        box_threshold: float = 0.3\n\n    @app.post(\"/sam/dino-predict\")\n    async def api_dino_predict(payload: DINOPredictRequest = Body(...)) -> Any:\n        print(f\"SAM API /sam/dino-predict received request\")\n        payload.input_image = decode_to_pil(payload.input_image)\n        dino_output_img, _, dino_msg = dino_predict(\n            payload.input_image,\n            payload.dino_model_name,\n            payload.text_prompt,\n            payload.box_threshold)\n        if \"value\" in dino_msg:\n            dino_msg = dino_msg[\"value\"]\n        else:\n            dino_msg = \"Done\"\n        print(f\"SAM API /sam/dino-predict finished with message: {dino_msg}\")\n        return {\n            \"msg\": dino_msg,\n            \"image_with_box\": encode_to_base64(dino_output_img) if dino_output_img is not None else None,\n        }\n\n    class DilateMaskRequest(BaseModel):\n        input_image: str\n        mask: str\n        dilate_amount: int = 10\n\n    @app.post(\"/sam/dilate-mask\")\n    async def api_dilate_mask(payload: DilateMaskRequest = Body(...)) -> Any:\n        print(f\"SAM API /sam/dilate-mask received request\")\n        payload.input_image = decode_to_pil(payload.input_image).convert(\"RGBA\")\n        payload.mask = decode_to_pil(payload.mask)\n        dilate_result = list(map(encode_to_base64, update_mask(payload.mask, 0, payload.dilate_amount, payload.input_image)))\n        print(f\"SAM API /sam/dilate-mask finished\")\n        return {\"blended_image\": dilate_result[0], \"mask\": dilate_result[1], \"masked_image\": dilate_result[2]}\n\n    \n    class AutoSAMConfig(BaseModel):\n        points_per_side: Optional[int] = 32\n        points_per_batch: int = 64\n        pred_iou_thresh: float = 0.88\n        stability_score_thresh: float = 0.95\n        stability_score_offset: float = 1.0\n        box_nms_thresh: float = 0.7\n        crop_n_layers: int = 0\n        crop_nms_thresh: float = 0.7\n        crop_overlap_ratio: float = 512 / 1500\n        crop_n_points_downscale_factor: int = 1\n        min_mask_region_area: int = 0\n\n    class ControlNetSegRequest(BaseModel):\n        sam_model_name: str = \"sam_vit_h_4b8939.pth\"\n        input_image: str\n        processor: str = \"seg_ofade20k\"\n        processor_res: int = 512\n        pixel_perfect: bool = False\n        resize_mode: Optional[int] = 1 # 0: just resize, 1: crop and resize, 2: resize and fill\n        target_W: Optional[int] = None\n        target_H: Optional[int] = None\n\n    @app.post(\"/sam/controlnet-seg\")\n    async def api_controlnet_seg(payload: ControlNetSegRequest = Body(...),\n                                 autosam_conf: AutoSAMConfig = Body(...)) -> Any:\n        print(f\"SAM API /sam/controlnet-seg received request\")\n        payload.input_image = decode_to_pil(payload.input_image)\n        cnet_seg_img, cnet_seg_msg = cnet_seg(\n            payload.sam_model_name,\n            payload.input_image,\n            payload.processor,\n            payload.processor_res,\n            payload.pixel_perfect,\n            payload.resize_mode,\n            payload.target_W,\n            payload.target_H,\n            autosam_conf.points_per_side,\n            autosam_conf.points_per_batch,\n            autosam_conf.pred_iou_thresh,\n            autosam_conf.stability_score_thresh,\n            autosam_conf.stability_score_offset,\n            autosam_conf.box_nms_thresh,\n            autosam_conf.crop_n_layers,\n            autosam_conf.crop_nms_thresh,\n            autosam_conf.crop_overlap_ratio,\n            autosam_conf.crop_n_points_downscale_factor,\n            autosam_conf.min_mask_region_area)\n        cnet_seg_img = list(map(encode_to_base64, cnet_seg_img))\n        print(f\"SAM API /sam/controlnet-seg finished with message {cnet_seg_msg}\")\n        result = {\n            \"msg\": cnet_seg_msg,\n        }\n        if len(cnet_seg_img) == 3:\n            result[\"blended_images\"]        = cnet_seg_img[0]\n            result[\"random_seg\"]   = cnet_seg_img[1]\n            result[\"edit_anything_control\"] = cnet_seg_img[2]\n        elif len(cnet_seg_img) == 4:\n            result[\"sem_presam\"]        = cnet_seg_img[0]\n            result[\"sem_postsam\"]       = cnet_seg_img[1]\n            result[\"blended_presam\"]    = cnet_seg_img[2]\n            result[\"blended_postsam\"]   = cnet_seg_img[3]\n        return result\n    \n    class CategoryMaskRequest(BaseModel):\n        sam_model_name: str = \"sam_vit_h_4b8939.pth\"\n        processor: str = \"seg_ofade20k\"\n        processor_res: int = 512\n        pixel_perfect: bool = False\n        resize_mode: Optional[int] = 1\n        target_W: Optional[int] = None\n        target_H: Optional[int] = None\n        category: str\n        input_image: str\n    \n    @app.post(\"/sam/category-mask\")\n    async def api_category_mask(payload: CategoryMaskRequest = Body(...),\n                                autosam_conf: AutoSAMConfig = Body(...)) -> Any:\n        print(f\"SAM API /sam/category-mask received request\")\n        payload.input_image = decode_to_pil(payload.input_image)\n        category_mask_img, category_mask_msg, resized_input_img = categorical_mask(\n            payload.sam_model_name,\n            payload.processor,\n            payload.processor_res,\n            payload.pixel_perfect,\n            payload.resize_mode,\n            payload.target_W,\n            payload.target_H,\n            payload.category,\n            payload.input_image,\n            autosam_conf.points_per_side,\n            autosam_conf.points_per_batch,\n            autosam_conf.pred_iou_thresh,\n            autosam_conf.stability_score_thresh,\n            autosam_conf.stability_score_offset,\n            autosam_conf.box_nms_thresh,\n            autosam_conf.crop_n_layers,\n            autosam_conf.crop_nms_thresh,\n            autosam_conf.crop_overlap_ratio,\n            autosam_conf.crop_n_points_downscale_factor,\n            autosam_conf.min_mask_region_area)\n        category_mask_img = list(map(encode_to_base64, category_mask_img))\n        print(f\"SAM API /sam/category-mask finished with message {category_mask_msg}\")\n        result = {\n            \"msg\": category_mask_msg,\n        }\n        if len(category_mask_img) == 3:\n            result[\"blended_image\"] = category_mask_img[0]\n            result[\"mask\"]          = category_mask_img[1]\n            result[\"masked_image\"]  = category_mask_img[2]\n        if resized_input_img is not None:\n            result[\"resized_input\"] = encode_to_base64(resized_input_img)\n        return result", "\n\ntry:\n    import modules.script_callbacks as script_callbacks\n    script_callbacks.on_app_started(sam_api)\nexcept:\n    print(\"SAM Web UI API failed to initialize\")"]}
{"filename": "scripts/process_params.py", "chunked_list": ["from typing import Tuple, List, Dict\nfrom PIL import Image, ImageOps, ImageEnhance, ImageFilter\nimport numpy as np\nfrom modules import shared\n\n\ndef max_cn_num():\n    if shared.opts.data is None:\n        return 1\n    return int(shared.opts.data.get('control_net_max_models_num', 1))", "\n\nclass SAMInpaintUnit:\n    def __init__(self, args: Tuple, is_img2img=False):\n        self.is_img2img = is_img2img\n\n        self.inpaint_upload_enable: bool = False\n        self.cnet_inpaint_invert: bool = False\n        self.cnet_inpaint_idx: int = 0\n        self.input_image = None\n        self.output_mask_gallery: List[Dict] = None\n        self.output_chosen_mask: int = 0\n        self.dilation_checkbox: bool = False\n        self.dilation_output_gallery: List[Dict] = None\n        self.init_sam_single_image_process(args)\n\n    \n    def init_sam_single_image_process(self, args):\n        self.inpaint_upload_enable      = args[0]\n        self.cnet_inpaint_invert        = args[1]\n        self.cnet_inpaint_idx           = args[2]\n        self.input_image                = args[3]\n        self.output_mask_gallery        = args[4]\n        self.output_chosen_mask         = args[5]\n        self.dilation_checkbox          = args[6]\n        self.dilation_output_gallery    = args[7]\n\n\n    def get_input_and_mask(self, mask_blur):\n        image, mask = None, None\n        if self.inpaint_upload_enable and self.input_image is not None and self.output_mask_gallery is not None:\n            if self.dilation_checkbox and self.dilation_output_gallery is not None:\n                mask = Image.open(self.dilation_output_gallery[1]['name']).convert('L')\n            elif self.output_mask_gallery is not None:\n                mask = Image.open(self.output_mask_gallery[self.output_chosen_mask + 3]['name']).convert('L')\n            if mask is not None and self.cnet_inpaint_invert:\n                mask = ImageOps.invert(mask)\n            # if self.is_img2img and self.sketch_checkbox and self.inpaint_color_sketch is not None and mask is not None:\n            #     alpha = np.expand_dims(np.array(mask) / 255, axis=-1)\n            #     image = np.uint8(np.array(self.inpaint_color_sketch) * alpha + np.array(self.input_image) * (1 - alpha))\n            #     mask = ImageEnhance.Brightness(mask).enhance(1 - self.inpaint_mask_alpha / 100)\n            #     blur = ImageFilter.GaussianBlur(mask_blur)\n            #     image = Image.composite(image.filter(blur), self.input_image, mask.filter(blur)).convert(\"RGB\")\n            # else:\n            image = self.input_image\n        return image, mask", "\n\n\nclass SAMProcessUnit:\n    def __init__(self, args: Tuple, is_img2img=False):\n        self.is_img2img = is_img2img\n        self.sam_inpaint_unit = SAMInpaintUnit(args, is_img2img)\n\n        args = args[8:]\n        self.cnet_seg_output_gallery: List[Dict]    = None\n        self.cnet_seg_enable_copy: bool             = False\n        self.cnet_seg_idx: int                      = 0\n        self.cnet_seg_gallery_input: int            = 0\n        self.init_cnet_seg_process(args)\n\n        args = args[4:]\n        self.crop_inpaint_unit = SAMInpaintUnit(args, is_img2img)\n\n        args = args[8:]\n        self.cnet_upload_enable: bool                   = False\n        self.cnet_upload_num: int                       = 0\n        self.cnet_upload_img_inpaint: Image.Image       = None\n        self.cnet_upload_mask_inpaint: Image.Image      = None\n        self.init_cnet_upload_process(args)\n        \n        \n    def init_cnet_seg_process(self, args):\n        self.cnet_seg_output_gallery    = args[0]\n        self.cnet_seg_enable_copy       = args[1]\n        self.cnet_seg_idx               = args[2]\n        self.cnet_seg_gallery_input     = args[3]\n    \n\n    def init_cnet_upload_process(self, args):\n        self.cnet_upload_enable         = args[0]\n        self.cnet_upload_num            = args[1]\n        self.cnet_upload_img_inpaint    = args[2] \n        self.cnet_upload_mask_inpaint   = args[3]\n\n    \n    def set_process_attributes(self, p):\n        inpaint_mask_blur = getattr(p, \"mask_blur\", 0)\n        inpaint_image, inpaint_mask = self.sam_inpaint_unit.get_input_and_mask(inpaint_mask_blur)\n        inpaint_cn_num = self.sam_inpaint_unit.cnet_inpaint_idx\n        if inpaint_image is None:\n            inpaint_image, inpaint_mask = self.crop_inpaint_unit.get_input_and_mask(inpaint_mask_blur)\n            inpaint_cn_num = self.crop_inpaint_unit.cnet_inpaint_idx\n        if inpaint_image is not None and inpaint_mask is not None:\n            if self.is_img2img:\n                p.init_images = [inpaint_image]\n                p.image_mask = inpaint_mask\n            else:\n                self.set_p_value(p, 'control_net_input_image', inpaint_cn_num, \n                                {\"image\": inpaint_image, \"mask\": inpaint_mask.convert(\"L\")})\n        \n        if self.cnet_seg_enable_copy and self.cnet_seg_output_gallery is not None:\n            cnet_seg_gallery_index = 1\n            if len(self.cnet_seg_output_gallery) == 3 and self.cnet_seg_gallery_input is not None:\n                cnet_seg_gallery_index += self.cnet_seg_gallery_input\n            self.set_p_value(p, 'control_net_input_image', self.cnet_seg_idx, \n                             Image.open(self.cnet_seg_output_gallery[cnet_seg_gallery_index]['name']))\n        \n        if self.cnet_upload_enable and self.cnet_upload_img_inpaint is not None and self.cnet_upload_mask_inpaint is not None:\n            self.set_p_value(p, 'control_net_input_image', self.cnet_upload_num, \n                            {\"image\": self.cnet_upload_img_inpaint, \"mask\": self.cnet_upload_mask_inpaint.convert(\"L\")})\n\n\n    def set_p_value(self, p, attr: str, idx: int, v):\n        value = getattr(p, attr, None)\n        if isinstance(value, list):\n            value[idx] = v\n        else:\n            # if value is None, ControlNet uses default value\n            value = [value] * max_cn_num()\n            value[idx] = v\n        setattr(p, attr, value)", ""]}
{"filename": "local_groundingdino/util/get_tokenlizer.py", "chunked_list": ["from transformers import AutoTokenizer, BertModel, BertTokenizer, RobertaModel, RobertaTokenizerFast\nimport os\n\ndef get_tokenlizer(text_encoder_type):\n    if not isinstance(text_encoder_type, str):\n        # print(\"text_encoder_type is not a str\")\n        if hasattr(text_encoder_type, \"text_encoder_type\"):\n            text_encoder_type = text_encoder_type.text_encoder_type\n        elif text_encoder_type.get(\"text_encoder_type\", False):\n            text_encoder_type = text_encoder_type.get(\"text_encoder_type\")\n        elif os.path.isdir(text_encoder_type) and os.path.exists(text_encoder_type):\n            pass\n        else:\n            raise ValueError(\n                \"Unknown type of text_encoder_type: {}\".format(type(text_encoder_type))\n            )\n    print(\"final text_encoder_type: {}\".format(text_encoder_type))\n\n    tokenizer = AutoTokenizer.from_pretrained(text_encoder_type)\n    return tokenizer", "\n\ndef get_pretrained_language_model(text_encoder_type):\n    if text_encoder_type == \"bert-base-uncased\" or (os.path.isdir(text_encoder_type) and os.path.exists(text_encoder_type)):\n        return BertModel.from_pretrained(text_encoder_type)\n    if text_encoder_type == \"roberta-base\":\n        return RobertaModel.from_pretrained(text_encoder_type)\n\n    raise ValueError(\"Unknown text_encoder_type {}\".format(text_encoder_type))\n", ""]}
{"filename": "local_groundingdino/util/box_ops.py", "chunked_list": ["# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved\n\"\"\"\nUtilities for bounding box manipulation and GIoU.\n\"\"\"\nimport torch\nfrom torchvision.ops.boxes import box_area\n\n\ndef box_cxcywh_to_xyxy(x):\n    x_c, y_c, w, h = x.unbind(-1)\n    b = [(x_c - 0.5 * w), (y_c - 0.5 * h), (x_c + 0.5 * w), (y_c + 0.5 * h)]\n    return torch.stack(b, dim=-1)", "def box_cxcywh_to_xyxy(x):\n    x_c, y_c, w, h = x.unbind(-1)\n    b = [(x_c - 0.5 * w), (y_c - 0.5 * h), (x_c + 0.5 * w), (y_c + 0.5 * h)]\n    return torch.stack(b, dim=-1)\n\n\ndef box_xyxy_to_cxcywh(x):\n    x0, y0, x1, y1 = x.unbind(-1)\n    b = [(x0 + x1) / 2, (y0 + y1) / 2, (x1 - x0), (y1 - y0)]\n    return torch.stack(b, dim=-1)", "\n\n# modified from torchvision to also return the union\ndef box_iou(boxes1, boxes2):\n    area1 = box_area(boxes1)\n    area2 = box_area(boxes2)\n\n    # import ipdb; ipdb.set_trace()\n    lt = torch.max(boxes1[:, None, :2], boxes2[:, :2])  # [N,M,2]\n    rb = torch.min(boxes1[:, None, 2:], boxes2[:, 2:])  # [N,M,2]\n\n    wh = (rb - lt).clamp(min=0)  # [N,M,2]\n    inter = wh[:, :, 0] * wh[:, :, 1]  # [N,M]\n\n    union = area1[:, None] + area2 - inter\n\n    iou = inter / (union + 1e-6)\n    return iou, union", "\n\ndef generalized_box_iou(boxes1, boxes2):\n    \"\"\"\n    Generalized IoU from https://giou.stanford.edu/\n\n    The boxes should be in [x0, y0, x1, y1] format\n\n    Returns a [N, M] pairwise matrix, where N = len(boxes1)\n    and M = len(boxes2)\n    \"\"\"\n    # degenerate boxes gives inf / nan results\n    # so do an early check\n    assert (boxes1[:, 2:] >= boxes1[:, :2]).all()\n    assert (boxes2[:, 2:] >= boxes2[:, :2]).all()\n    # except:\n    #     import ipdb; ipdb.set_trace()\n    iou, union = box_iou(boxes1, boxes2)\n\n    lt = torch.min(boxes1[:, None, :2], boxes2[:, :2])\n    rb = torch.max(boxes1[:, None, 2:], boxes2[:, 2:])\n\n    wh = (rb - lt).clamp(min=0)  # [N,M,2]\n    area = wh[:, :, 0] * wh[:, :, 1]\n\n    return iou - (area - union) / (area + 1e-6)", "\n\n# modified from torchvision to also return the union\ndef box_iou_pairwise(boxes1, boxes2):\n    area1 = box_area(boxes1)\n    area2 = box_area(boxes2)\n\n    lt = torch.max(boxes1[:, :2], boxes2[:, :2])  # [N,2]\n    rb = torch.min(boxes1[:, 2:], boxes2[:, 2:])  # [N,2]\n\n    wh = (rb - lt).clamp(min=0)  # [N,2]\n    inter = wh[:, 0] * wh[:, 1]  # [N]\n\n    union = area1 + area2 - inter\n\n    iou = inter / union\n    return iou, union", "\n\ndef generalized_box_iou_pairwise(boxes1, boxes2):\n    \"\"\"\n    Generalized IoU from https://giou.stanford.edu/\n\n    Input:\n        - boxes1, boxes2: N,4\n    Output:\n        - giou: N, 4\n    \"\"\"\n    # degenerate boxes gives inf / nan results\n    # so do an early check\n    assert (boxes1[:, 2:] >= boxes1[:, :2]).all()\n    assert (boxes2[:, 2:] >= boxes2[:, :2]).all()\n    assert boxes1.shape == boxes2.shape\n    iou, union = box_iou_pairwise(boxes1, boxes2)  # N, 4\n\n    lt = torch.min(boxes1[:, :2], boxes2[:, :2])\n    rb = torch.max(boxes1[:, 2:], boxes2[:, 2:])\n\n    wh = (rb - lt).clamp(min=0)  # [N,2]\n    area = wh[:, 0] * wh[:, 1]\n\n    return iou - (area - union) / area", "\n\ndef masks_to_boxes(masks):\n    \"\"\"Compute the bounding boxes around the provided masks\n\n    The masks should be in format [N, H, W] where N is the number of masks, (H, W) are the spatial dimensions.\n\n    Returns a [N, 4] tensors, with the boxes in xyxy format\n    \"\"\"\n    if masks.numel() == 0:\n        return torch.zeros((0, 4), device=masks.device)\n\n    h, w = masks.shape[-2:]\n\n    y = torch.arange(0, h, dtype=torch.float)\n    x = torch.arange(0, w, dtype=torch.float)\n    y, x = torch.meshgrid(y, x)\n\n    x_mask = masks * x.unsqueeze(0)\n    x_max = x_mask.flatten(1).max(-1)[0]\n    x_min = x_mask.masked_fill(~(masks.bool()), 1e8).flatten(1).min(-1)[0]\n\n    y_mask = masks * y.unsqueeze(0)\n    y_max = y_mask.flatten(1).max(-1)[0]\n    y_min = y_mask.masked_fill(~(masks.bool()), 1e8).flatten(1).min(-1)[0]\n\n    return torch.stack([x_min, y_min, x_max, y_max], 1)", "\n\nif __name__ == \"__main__\":\n    x = torch.rand(5, 4)\n    y = torch.rand(3, 4)\n    iou, union = box_iou(x, y)\n    import ipdb\n\n    ipdb.set_trace()\n", ""]}
{"filename": "local_groundingdino/util/inference.py", "chunked_list": ["from typing import Tuple, List\n\nimport cv2\nimport numpy as np\nimport supervision as sv\nimport torch\nfrom PIL import Image\nfrom torchvision.ops import box_convert\n\nimport local_groundingdino.datasets.transforms as T", "\nimport local_groundingdino.datasets.transforms as T\nfrom local_groundingdino.models import build_model\nfrom local_groundingdino.util.misc import clean_state_dict\nfrom local_groundingdino.util.slconfig import SLConfig\nfrom local_groundingdino.util.utils import get_phrases_from_posmap\n\n# ----------------------------------------------------------------------------------------------------------------------\n# OLD API\n# ----------------------------------------------------------------------------------------------------------------------", "# OLD API\n# ----------------------------------------------------------------------------------------------------------------------\n\n\ndef preprocess_caption(caption: str) -> str:\n    result = caption.lower().strip()\n    if result.endswith(\".\"):\n        return result\n    return result + \".\"\n", "\n\ndef load_model(model_config_path: str, model_checkpoint_path: str, device: str = \"cuda\"):\n    args = SLConfig.fromfile(model_config_path)\n    args.device = device\n    model = build_model(args)\n    checkpoint = torch.load(model_checkpoint_path, map_location=\"cpu\")\n    model.load_state_dict(clean_state_dict(checkpoint[\"model\"]), strict=False)\n    model.eval()\n    return model", "\n\ndef load_image(image_path: str) -> Tuple[np.array, torch.Tensor]:\n    transform = T.Compose(\n        [\n            T.RandomResize([800], max_size=1333),\n            T.ToTensor(),\n            T.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225]),\n        ]\n    )\n    image_source = Image.open(image_path).convert(\"RGB\")\n    image = np.asarray(image_source)\n    image_transformed, _ = transform(image_source, None)\n    return image, image_transformed", "\n\ndef predict(\n        model,\n        image: torch.Tensor,\n        caption: str,\n        box_threshold: float,\n        text_threshold: float,\n        device: str = \"cuda\"\n) -> Tuple[torch.Tensor, torch.Tensor, List[str]]:\n    caption = preprocess_caption(caption=caption)\n\n    model = model.to(device)\n    image = image.to(device)\n\n    with torch.no_grad():\n        outputs = model(image[None], captions=[caption])\n\n    prediction_logits = outputs[\"pred_logits\"].cpu().sigmoid()[0]  # prediction_logits.shape = (nq, 256)\n    prediction_boxes = outputs[\"pred_boxes\"].cpu()[0]  # prediction_boxes.shape = (nq, 4)\n\n    mask = prediction_logits.max(dim=1)[0] > box_threshold\n    logits = prediction_logits[mask]  # logits.shape = (n, 256)\n    boxes = prediction_boxes[mask]  # boxes.shape = (n, 4)\n\n    tokenizer = model.tokenizer\n    tokenized = tokenizer(caption)\n\n    phrases = [\n        get_phrases_from_posmap(logit > text_threshold, tokenized, tokenizer).replace('.', '')\n        for logit\n        in logits\n    ]\n\n    return boxes, logits.max(dim=1)[0], phrases", "\n\ndef annotate(image_source: np.ndarray, boxes: torch.Tensor, logits: torch.Tensor, phrases: List[str]) -> np.ndarray:\n    h, w, _ = image_source.shape\n    boxes = boxes * torch.Tensor([w, h, w, h])\n    xyxy = box_convert(boxes=boxes, in_fmt=\"cxcywh\", out_fmt=\"xyxy\").numpy()\n    detections = sv.Detections(xyxy=xyxy)\n\n    labels = [\n        f\"{phrase} {logit:.2f}\"\n        for phrase, logit\n        in zip(phrases, logits)\n    ]\n\n    box_annotator = sv.BoxAnnotator()\n    annotated_frame = cv2.cvtColor(image_source, cv2.COLOR_RGB2BGR)\n    annotated_frame = box_annotator.annotate(scene=annotated_frame, detections=detections, labels=labels)\n    return annotated_frame", "\n\n# ----------------------------------------------------------------------------------------------------------------------\n# NEW API\n# ----------------------------------------------------------------------------------------------------------------------\n\n\nclass Model:\n\n    def __init__(\n        self,\n        model_config_path: str,\n        model_checkpoint_path: str,\n        device: str = \"cuda\"\n    ):\n        self.model = load_model(\n            model_config_path=model_config_path,\n            model_checkpoint_path=model_checkpoint_path,\n            device=device\n        ).to(device)\n        self.device = device\n\n    def predict_with_caption(\n        self,\n        image: np.ndarray,\n        caption: str,\n        box_threshold: float = 0.35,\n        text_threshold: float = 0.25\n    ) -> Tuple[sv.Detections, List[str]]:\n        \"\"\"\n        import cv2\n\n        image = cv2.imread(IMAGE_PATH)\n\n        model = Model(model_config_path=CONFIG_PATH, model_checkpoint_path=WEIGHTS_PATH)\n        detections, labels = model.predict_with_caption(\n            image=image,\n            caption=caption,\n            box_threshold=BOX_THRESHOLD,\n            text_threshold=TEXT_THRESHOLD\n        )\n\n        import supervision as sv\n\n        box_annotator = sv.BoxAnnotator()\n        annotated_image = box_annotator.annotate(scene=image, detections=detections, labels=labels)\n        \"\"\"\n        processed_image = Model.preprocess_image(image_bgr=image).to(self.device)\n        boxes, logits, phrases = predict(\n            model=self.model,\n            image=processed_image,\n            caption=caption,\n            box_threshold=box_threshold,\n            text_threshold=text_threshold, \n            device=self.device)\n        source_h, source_w, _ = image.shape\n        detections = Model.post_process_result(\n            source_h=source_h,\n            source_w=source_w,\n            boxes=boxes,\n            logits=logits)\n        return detections, phrases\n\n    def predict_with_classes(\n        self,\n        image: np.ndarray,\n        classes: List[str],\n        box_threshold: float,\n        text_threshold: float\n    ) -> sv.Detections:\n        \"\"\"\n        import cv2\n\n        image = cv2.imread(IMAGE_PATH)\n\n        model = Model(model_config_path=CONFIG_PATH, model_checkpoint_path=WEIGHTS_PATH)\n        detections = model.predict_with_classes(\n            image=image,\n            classes=CLASSES,\n            box_threshold=BOX_THRESHOLD,\n            text_threshold=TEXT_THRESHOLD\n        )\n\n\n        import supervision as sv\n\n        box_annotator = sv.BoxAnnotator()\n        annotated_image = box_annotator.annotate(scene=image, detections=detections)\n        \"\"\"\n        caption = \". \".join(classes)\n        processed_image = Model.preprocess_image(image_bgr=image).to(self.device)\n        boxes, logits, phrases = predict(\n            model=self.model,\n            image=processed_image,\n            caption=caption,\n            box_threshold=box_threshold,\n            text_threshold=text_threshold,\n            device=self.device)\n        source_h, source_w, _ = image.shape\n        detections = Model.post_process_result(\n            source_h=source_h,\n            source_w=source_w,\n            boxes=boxes,\n            logits=logits)\n        class_id = Model.phrases2classes(phrases=phrases, classes=classes)\n        detections.class_id = class_id\n        return detections\n\n    @staticmethod\n    def preprocess_image(image_bgr: np.ndarray) -> torch.Tensor:\n        transform = T.Compose(\n            [\n                T.RandomResize([800], max_size=1333),\n                T.ToTensor(),\n                T.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225]),\n            ]\n        )\n        image_pillow = Image.fromarray(cv2.cvtColor(image_bgr, cv2.COLOR_BGR2RGB))\n        image_transformed, _ = transform(image_pillow, None)\n        return image_transformed\n\n    @staticmethod\n    def post_process_result(\n            source_h: int,\n            source_w: int,\n            boxes: torch.Tensor,\n            logits: torch.Tensor\n    ) -> sv.Detections:\n        boxes = boxes * torch.Tensor([source_w, source_h, source_w, source_h])\n        xyxy = box_convert(boxes=boxes, in_fmt=\"cxcywh\", out_fmt=\"xyxy\").numpy()\n        confidence = logits.numpy()\n        return sv.Detections(xyxy=xyxy, confidence=confidence)\n\n    @staticmethod\n    def phrases2classes(phrases: List[str], classes: List[str]) -> np.ndarray:\n        class_ids = []\n        for phrase in phrases:\n            try:\n                class_ids.append(classes.index(phrase))\n            except ValueError:\n                class_ids.append(None)\n        return np.array(class_ids)", ""]}
{"filename": "local_groundingdino/util/slio.py", "chunked_list": ["# ==========================================================\n# Modified from mmcv\n# ==========================================================\n\nimport json\nimport pickle\nfrom abc import ABCMeta, abstractmethod\nfrom pathlib import Path\n\nimport yaml", "\nimport yaml\n\ntry:\n    from yaml import CLoader as Loader, CDumper as Dumper\nexcept ImportError:\n    from yaml import Loader, Dumper\n\n\n# ===========================", "\n# ===========================\n# Rigister handler\n# ===========================\n\n\nclass BaseFileHandler(metaclass=ABCMeta):\n    @abstractmethod\n    def load_from_fileobj(self, file, **kwargs):\n        pass\n\n    @abstractmethod\n    def dump_to_fileobj(self, obj, file, **kwargs):\n        pass\n\n    @abstractmethod\n    def dump_to_str(self, obj, **kwargs):\n        pass\n\n    def load_from_path(self, filepath, mode=\"r\", **kwargs):\n        with open(filepath, mode) as f:\n            return self.load_from_fileobj(f, **kwargs)\n\n    def dump_to_path(self, obj, filepath, mode=\"w\", **kwargs):\n        with open(filepath, mode) as f:\n            self.dump_to_fileobj(obj, f, **kwargs)", "\n\nclass JsonHandler(BaseFileHandler):\n    def load_from_fileobj(self, file):\n        return json.load(file)\n\n    def dump_to_fileobj(self, obj, file, **kwargs):\n        json.dump(obj, file, **kwargs)\n\n    def dump_to_str(self, obj, **kwargs):\n        return json.dumps(obj, **kwargs)", "\n\nclass PickleHandler(BaseFileHandler):\n    def load_from_fileobj(self, file, **kwargs):\n        return pickle.load(file, **kwargs)\n\n    def load_from_path(self, filepath, **kwargs):\n        return super(PickleHandler, self).load_from_path(filepath, mode=\"rb\", **kwargs)\n\n    def dump_to_str(self, obj, **kwargs):\n        kwargs.setdefault(\"protocol\", 2)\n        return pickle.dumps(obj, **kwargs)\n\n    def dump_to_fileobj(self, obj, file, **kwargs):\n        kwargs.setdefault(\"protocol\", 2)\n        pickle.dump(obj, file, **kwargs)\n\n    def dump_to_path(self, obj, filepath, **kwargs):\n        super(PickleHandler, self).dump_to_path(obj, filepath, mode=\"wb\", **kwargs)", "\n\nclass YamlHandler(BaseFileHandler):\n    def load_from_fileobj(self, file, **kwargs):\n        kwargs.setdefault(\"Loader\", Loader)\n        return yaml.load(file, **kwargs)\n\n    def dump_to_fileobj(self, obj, file, **kwargs):\n        kwargs.setdefault(\"Dumper\", Dumper)\n        yaml.dump(obj, file, **kwargs)\n\n    def dump_to_str(self, obj, **kwargs):\n        kwargs.setdefault(\"Dumper\", Dumper)\n        return yaml.dump(obj, **kwargs)", "\n\nfile_handlers = {\n    \"json\": JsonHandler(),\n    \"yaml\": YamlHandler(),\n    \"yml\": YamlHandler(),\n    \"pickle\": PickleHandler(),\n    \"pkl\": PickleHandler(),\n}\n", "}\n\n# ===========================\n# load and dump\n# ===========================\n\n\ndef is_str(x):\n    \"\"\"Whether the input is an string instance.\n\n    Note: This method is deprecated since python 2 is no longer supported.\n    \"\"\"\n    return isinstance(x, str)", "\n\ndef slload(file, file_format=None, **kwargs):\n    \"\"\"Load data from json/yaml/pickle files.\n\n    This method provides a unified api for loading data from serialized files.\n\n    Args:\n        file (str or :obj:`Path` or file-like object): Filename or a file-like\n            object.\n        file_format (str, optional): If not specified, the file format will be\n            inferred from the file extension, otherwise use the specified one.\n            Currently supported formats include \"json\", \"yaml/yml\" and\n            \"pickle/pkl\".\n\n    Returns:\n        The content from the file.\n    \"\"\"\n    if isinstance(file, Path):\n        file = str(file)\n    if file_format is None and is_str(file):\n        file_format = file.split(\".\")[-1]\n    if file_format not in file_handlers:\n        raise TypeError(f\"Unsupported format: {file_format}\")\n\n    handler = file_handlers[file_format]\n    if is_str(file):\n        obj = handler.load_from_path(file, **kwargs)\n    elif hasattr(file, \"read\"):\n        obj = handler.load_from_fileobj(file, **kwargs)\n    else:\n        raise TypeError('\"file\" must be a filepath str or a file-object')\n    return obj", "\n\ndef sldump(obj, file=None, file_format=None, **kwargs):\n    \"\"\"Dump data to json/yaml/pickle strings or files.\n\n    This method provides a unified api for dumping data as strings or to files,\n    and also supports custom arguments for each file format.\n\n    Args:\n        obj (any): The python object to be dumped.\n        file (str or :obj:`Path` or file-like object, optional): If not\n            specified, then the object is dump to a str, otherwise to a file\n            specified by the filename or file-like object.\n        file_format (str, optional): Same as :func:`load`.\n\n    Returns:\n        bool: True for success, False otherwise.\n    \"\"\"\n    if isinstance(file, Path):\n        file = str(file)\n    if file_format is None:\n        if is_str(file):\n            file_format = file.split(\".\")[-1]\n        elif file is None:\n            raise ValueError(\"file_format must be specified since file is None\")\n    if file_format not in file_handlers:\n        raise TypeError(f\"Unsupported format: {file_format}\")\n\n    handler = file_handlers[file_format]\n    if file is None:\n        return handler.dump_to_str(obj, **kwargs)\n    elif is_str(file):\n        handler.dump_to_path(obj, file, **kwargs)\n    elif hasattr(file, \"write\"):\n        handler.dump_to_fileobj(obj, file, **kwargs)\n    else:\n        raise TypeError('\"file\" must be a filename str or a file-object')", ""]}
{"filename": "local_groundingdino/util/slconfig.py", "chunked_list": ["# ==========================================================\n# Modified from mmcv\n# ==========================================================\nimport ast\nimport os\nimport os.path as osp\nimport shutil\nimport sys\nimport tempfile\nfrom argparse import Action", "import tempfile\nfrom argparse import Action\nfrom importlib import import_module\n\nfrom addict import Dict\nfrom yapf.yapflib.yapf_api import FormatCode\n\nBASE_KEY = \"_base_\"\nDELETE_KEY = \"_delete_\"\nRESERVED_KEYS = [\"filename\", \"text\", \"pretty_text\", \"get\", \"dump\", \"merge_from_dict\"]", "DELETE_KEY = \"_delete_\"\nRESERVED_KEYS = [\"filename\", \"text\", \"pretty_text\", \"get\", \"dump\", \"merge_from_dict\"]\n\n\ndef check_file_exist(filename, msg_tmpl='file \"{}\" does not exist'):\n    if not osp.isfile(filename):\n        raise FileNotFoundError(msg_tmpl.format(filename))\n\n\nclass ConfigDict(Dict):\n    def __missing__(self, name):\n        raise KeyError(name)\n\n    def __getattr__(self, name):\n        try:\n            value = super(ConfigDict, self).__getattr__(name)\n        except KeyError:\n            ex = AttributeError(f\"'{self.__class__.__name__}' object has no \" f\"attribute '{name}'\")\n        except Exception as e:\n            ex = e\n        else:\n            return value\n        raise ex", "\nclass ConfigDict(Dict):\n    def __missing__(self, name):\n        raise KeyError(name)\n\n    def __getattr__(self, name):\n        try:\n            value = super(ConfigDict, self).__getattr__(name)\n        except KeyError:\n            ex = AttributeError(f\"'{self.__class__.__name__}' object has no \" f\"attribute '{name}'\")\n        except Exception as e:\n            ex = e\n        else:\n            return value\n        raise ex", "\n\nclass SLConfig(object):\n    \"\"\"\n    config files.\n    only support .py file as config now.\n\n    ref: mmcv.utils.config\n\n    Example:\n        >>> cfg = Config(dict(a=1, b=dict(b1=[0, 1])))\n        >>> cfg.a\n        1\n        >>> cfg.b\n        {'b1': [0, 1]}\n        >>> cfg.b.b1\n        [0, 1]\n        >>> cfg = Config.fromfile('tests/data/config/a.py')\n        >>> cfg.filename\n        \"/home/kchen/projects/mmcv/tests/data/config/a.py\"\n        >>> cfg.item4\n        'test'\n        >>> cfg\n        \"Config [path: /home/kchen/projects/mmcv/tests/data/config/a.py]: \"\n        \"{'item1': [1, 2], 'item2': {'a': 0}, 'item3': True, 'item4': 'test'}\"\n    \"\"\"\n\n    @staticmethod\n    def _validate_py_syntax(filename):\n        with open(filename) as f:\n            content = f.read()\n        try:\n            ast.parse(content)\n        except SyntaxError:\n            raise SyntaxError(\"There are syntax errors in config \" f\"file {filename}\")\n\n    @staticmethod\n    def _file2dict(filename):\n        filename = osp.abspath(osp.expanduser(filename))\n        check_file_exist(filename)\n        if filename.lower().endswith(\".py\"):\n            with tempfile.TemporaryDirectory() as temp_config_dir:\n                temp_config_file = tempfile.NamedTemporaryFile(dir=temp_config_dir, suffix=\".py\")\n                temp_config_name = osp.basename(temp_config_file.name)\n                if os.name == 'nt':\n                    temp_config_file.close()\n                shutil.copyfile(filename, osp.join(temp_config_dir, temp_config_name))\n                temp_module_name = osp.splitext(temp_config_name)[0]\n                sys.path.insert(0, temp_config_dir)\n                SLConfig._validate_py_syntax(filename)\n                mod = import_module(temp_module_name)\n                sys.path.pop(0)\n                cfg_dict = {\n                    name: value for name, value in mod.__dict__.items() if not name.startswith(\"__\")\n                }\n                # delete imported module\n                del sys.modules[temp_module_name]\n                # close temp file\n                temp_config_file.close()\n        elif filename.lower().endswith((\".yml\", \".yaml\", \".json\")):\n            from .slio import slload\n\n            cfg_dict = slload(filename)\n        else:\n            raise IOError(\"Only py/yml/yaml/json type are supported now!\")\n\n        cfg_text = filename + \"\\n\"\n        with open(filename, \"r\") as f:\n            cfg_text += f.read()\n\n        # parse the base file\n        if BASE_KEY in cfg_dict:\n            cfg_dir = osp.dirname(filename)\n            base_filename = cfg_dict.pop(BASE_KEY)\n            base_filename = base_filename if isinstance(base_filename, list) else [base_filename]\n\n            cfg_dict_list = list()\n            cfg_text_list = list()\n            for f in base_filename:\n                _cfg_dict, _cfg_text = SLConfig._file2dict(osp.join(cfg_dir, f))\n                cfg_dict_list.append(_cfg_dict)\n                cfg_text_list.append(_cfg_text)\n\n            base_cfg_dict = dict()\n            for c in cfg_dict_list:\n                if len(base_cfg_dict.keys() & c.keys()) > 0:\n                    raise KeyError(\"Duplicate key is not allowed among bases\")\n                    # TODO Allow the duplicate key while warnning user\n                base_cfg_dict.update(c)\n\n            base_cfg_dict = SLConfig._merge_a_into_b(cfg_dict, base_cfg_dict)\n            cfg_dict = base_cfg_dict\n\n            # merge cfg_text\n            cfg_text_list.append(cfg_text)\n            cfg_text = \"\\n\".join(cfg_text_list)\n\n        return cfg_dict, cfg_text\n\n    @staticmethod\n    def _merge_a_into_b(a, b):\n        \"\"\"merge dict `a` into dict `b` (non-inplace).\n            values in `a` will overwrite `b`.\n            copy first to avoid inplace modification\n\n        Args:\n            a ([type]): [description]\n            b ([type]): [description]\n\n        Returns:\n            [dict]: [description]\n        \"\"\"\n        # import ipdb; ipdb.set_trace()\n        if not isinstance(a, dict):\n            return a\n\n        b = b.copy()\n        for k, v in a.items():\n            if isinstance(v, dict) and k in b and not v.pop(DELETE_KEY, False):\n\n                if not isinstance(b[k], dict) and not isinstance(b[k], list):\n                    # if :\n                    # import ipdb; ipdb.set_trace()\n                    raise TypeError(\n                        f\"{k}={v} in child config cannot inherit from base \"\n                        f\"because {k} is a dict in the child config but is of \"\n                        f\"type {type(b[k])} in base config. You may set \"\n                        f\"`{DELETE_KEY}=True` to ignore the base config\"\n                    )\n                b[k] = SLConfig._merge_a_into_b(v, b[k])\n            elif isinstance(b, list):\n                try:\n                    _ = int(k)\n                except:\n                    raise TypeError(\n                        f\"b is a list, \" f\"index {k} should be an int when input but {type(k)}\"\n                    )\n                b[int(k)] = SLConfig._merge_a_into_b(v, b[int(k)])\n            else:\n                b[k] = v\n\n        return b\n\n    @staticmethod\n    def fromfile(filename):\n        cfg_dict, cfg_text = SLConfig._file2dict(filename)\n        return SLConfig(cfg_dict, cfg_text=cfg_text, filename=filename)\n\n    def __init__(self, cfg_dict=None, cfg_text=None, filename=None):\n        if cfg_dict is None:\n            cfg_dict = dict()\n        elif not isinstance(cfg_dict, dict):\n            raise TypeError(\"cfg_dict must be a dict, but \" f\"got {type(cfg_dict)}\")\n        for key in cfg_dict:\n            if key in RESERVED_KEYS:\n                raise KeyError(f\"{key} is reserved for config file\")\n\n        super(SLConfig, self).__setattr__(\"_cfg_dict\", ConfigDict(cfg_dict))\n        super(SLConfig, self).__setattr__(\"_filename\", filename)\n        if cfg_text:\n            text = cfg_text\n        elif filename:\n            with open(filename, \"r\") as f:\n                text = f.read()\n        else:\n            text = \"\"\n        super(SLConfig, self).__setattr__(\"_text\", text)\n\n    @property\n    def filename(self):\n        return self._filename\n\n    @property\n    def text(self):\n        return self._text\n\n    @property\n    def pretty_text(self):\n\n        indent = 4\n\n        def _indent(s_, num_spaces):\n            s = s_.split(\"\\n\")\n            if len(s) == 1:\n                return s_\n            first = s.pop(0)\n            s = [(num_spaces * \" \") + line for line in s]\n            s = \"\\n\".join(s)\n            s = first + \"\\n\" + s\n            return s\n\n        def _format_basic_types(k, v, use_mapping=False):\n            if isinstance(v, str):\n                v_str = f\"'{v}'\"\n            else:\n                v_str = str(v)\n\n            if use_mapping:\n                k_str = f\"'{k}'\" if isinstance(k, str) else str(k)\n                attr_str = f\"{k_str}: {v_str}\"\n            else:\n                attr_str = f\"{str(k)}={v_str}\"\n            attr_str = _indent(attr_str, indent)\n\n            return attr_str\n\n        def _format_list(k, v, use_mapping=False):\n            # check if all items in the list are dict\n            if all(isinstance(_, dict) for _ in v):\n                v_str = \"[\\n\"\n                v_str += \"\\n\".join(\n                    f\"dict({_indent(_format_dict(v_), indent)}),\" for v_ in v\n                ).rstrip(\",\")\n                if use_mapping:\n                    k_str = f\"'{k}'\" if isinstance(k, str) else str(k)\n                    attr_str = f\"{k_str}: {v_str}\"\n                else:\n                    attr_str = f\"{str(k)}={v_str}\"\n                attr_str = _indent(attr_str, indent) + \"]\"\n            else:\n                attr_str = _format_basic_types(k, v, use_mapping)\n            return attr_str\n\n        def _contain_invalid_identifier(dict_str):\n            contain_invalid_identifier = False\n            for key_name in dict_str:\n                contain_invalid_identifier |= not str(key_name).isidentifier()\n            return contain_invalid_identifier\n\n        def _format_dict(input_dict, outest_level=False):\n            r = \"\"\n            s = []\n\n            use_mapping = _contain_invalid_identifier(input_dict)\n            if use_mapping:\n                r += \"{\"\n            for idx, (k, v) in enumerate(input_dict.items()):\n                is_last = idx >= len(input_dict) - 1\n                end = \"\" if outest_level or is_last else \",\"\n                if isinstance(v, dict):\n                    v_str = \"\\n\" + _format_dict(v)\n                    if use_mapping:\n                        k_str = f\"'{k}'\" if isinstance(k, str) else str(k)\n                        attr_str = f\"{k_str}: dict({v_str}\"\n                    else:\n                        attr_str = f\"{str(k)}=dict({v_str}\"\n                    attr_str = _indent(attr_str, indent) + \")\" + end\n                elif isinstance(v, list):\n                    attr_str = _format_list(k, v, use_mapping) + end\n                else:\n                    attr_str = _format_basic_types(k, v, use_mapping) + end\n\n                s.append(attr_str)\n            r += \"\\n\".join(s)\n            if use_mapping:\n                r += \"}\"\n            return r\n\n        cfg_dict = self._cfg_dict.to_dict()\n        text = _format_dict(cfg_dict, outest_level=True)\n        # copied from setup.cfg\n        yapf_style = dict(\n            based_on_style=\"pep8\",\n            blank_line_before_nested_class_or_def=True,\n            split_before_expression_after_opening_paren=True,\n        )\n        text, _ = FormatCode(text, style_config=yapf_style, verify=True)\n\n        return text\n\n    def __repr__(self):\n        return f\"Config (path: {self.filename}): {self._cfg_dict.__repr__()}\"\n\n    def __len__(self):\n        return len(self._cfg_dict)\n\n    def __getattr__(self, name):\n        # # debug\n        # print('+'*15)\n        # print('name=%s' % name)\n        # print(\"addr:\", id(self))\n        # # print('type(self):', type(self))\n        # print(self.__dict__)\n        # print('+'*15)\n        # if self.__dict__ == {}:\n        #     raise ValueError\n\n        return getattr(self._cfg_dict, name)\n\n    def __getitem__(self, name):\n        return self._cfg_dict.__getitem__(name)\n\n    def __setattr__(self, name, value):\n        if isinstance(value, dict):\n            value = ConfigDict(value)\n        self._cfg_dict.__setattr__(name, value)\n\n    def __setitem__(self, name, value):\n        if isinstance(value, dict):\n            value = ConfigDict(value)\n        self._cfg_dict.__setitem__(name, value)\n\n    def __iter__(self):\n        return iter(self._cfg_dict)\n\n    def dump(self, file=None):\n        # import ipdb; ipdb.set_trace()\n        if file is None:\n            return self.pretty_text\n        else:\n            with open(file, \"w\") as f:\n                f.write(self.pretty_text)\n\n    def merge_from_dict(self, options):\n        \"\"\"Merge list into cfg_dict\n\n        Merge the dict parsed by MultipleKVAction into this cfg.\n\n        Examples:\n            >>> options = {'model.backbone.depth': 50,\n            ...            'model.backbone.with_cp':True}\n            >>> cfg = Config(dict(model=dict(backbone=dict(type='ResNet'))))\n            >>> cfg.merge_from_dict(options)\n            >>> cfg_dict = super(Config, self).__getattribute__('_cfg_dict')\n            >>> assert cfg_dict == dict(\n            ...     model=dict(backbone=dict(depth=50, with_cp=True)))\n\n        Args:\n            options (dict): dict of configs to merge from.\n        \"\"\"\n        option_cfg_dict = {}\n        for full_key, v in options.items():\n            d = option_cfg_dict\n            key_list = full_key.split(\".\")\n            for subkey in key_list[:-1]:\n                d.setdefault(subkey, ConfigDict())\n                d = d[subkey]\n            subkey = key_list[-1]\n            d[subkey] = v\n\n        cfg_dict = super(SLConfig, self).__getattribute__(\"_cfg_dict\")\n        super(SLConfig, self).__setattr__(\n            \"_cfg_dict\", SLConfig._merge_a_into_b(option_cfg_dict, cfg_dict)\n        )\n\n    # for multiprocess\n    def __setstate__(self, state):\n        self.__init__(state)\n\n    def copy(self):\n        return SLConfig(self._cfg_dict.copy())\n\n    def deepcopy(self):\n        return SLConfig(self._cfg_dict.deepcopy())", "\n\nclass DictAction(Action):\n    \"\"\"\n    argparse action to split an argument into KEY=VALUE form\n    on the first = and append to a dictionary. List options should\n    be passed as comma separated values, i.e KEY=V1,V2,V3\n    \"\"\"\n\n    @staticmethod\n    def _parse_int_float_bool(val):\n        try:\n            return int(val)\n        except ValueError:\n            pass\n        try:\n            return float(val)\n        except ValueError:\n            pass\n        if val.lower() in [\"true\", \"false\"]:\n            return True if val.lower() == \"true\" else False\n        if val.lower() in [\"none\", \"null\"]:\n            return None\n        return val\n\n    def __call__(self, parser, namespace, values, option_string=None):\n        options = {}\n        for kv in values:\n            key, val = kv.split(\"=\", maxsplit=1)\n            val = [self._parse_int_float_bool(v) for v in val.split(\",\")]\n            if len(val) == 1:\n                val = val[0]\n            options[key] = val\n        setattr(namespace, self.dest, options)", ""]}
{"filename": "local_groundingdino/util/__init__.py", "chunked_list": ["# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved\n"]}
{"filename": "local_groundingdino/util/utils.py", "chunked_list": ["import argparse\nimport json\nimport warnings\nfrom collections import OrderedDict\nfrom copy import deepcopy\nfrom typing import Any, Dict, List\n\nimport numpy as np\nimport torch\nfrom transformers import AutoTokenizer", "import torch\nfrom transformers import AutoTokenizer\n\nfrom local_groundingdino.util.slconfig import SLConfig\n\n\ndef slprint(x, name=\"x\"):\n    if isinstance(x, (torch.Tensor, np.ndarray)):\n        print(f\"{name}.shape:\", x.shape)\n    elif isinstance(x, (tuple, list)):\n        print(\"type x:\", type(x))\n        for i in range(min(10, len(x))):\n            slprint(x[i], f\"{name}[{i}]\")\n    elif isinstance(x, dict):\n        for k, v in x.items():\n            slprint(v, f\"{name}[{k}]\")\n    else:\n        print(f\"{name}.type:\", type(x))", "\n\ndef clean_state_dict(state_dict):\n    new_state_dict = OrderedDict()\n    for k, v in state_dict.items():\n        if k[:7] == \"module.\":\n            k = k[7:]  # remove `module.`\n        new_state_dict[k] = v\n    return new_state_dict\n", "\n\ndef renorm(\n    img: torch.FloatTensor, mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]\n) -> torch.FloatTensor:\n    # img: tensor(3,H,W) or tensor(B,3,H,W)\n    # return: same as img\n    assert img.dim() == 3 or img.dim() == 4, \"img.dim() should be 3 or 4 but %d\" % img.dim()\n    if img.dim() == 3:\n        assert img.size(0) == 3, 'img.size(0) shoule be 3 but \"%d\". (%s)' % (\n            img.size(0),\n            str(img.size()),\n        )\n        img_perm = img.permute(1, 2, 0)\n        mean = torch.Tensor(mean)\n        std = torch.Tensor(std)\n        img_res = img_perm * std + mean\n        return img_res.permute(2, 0, 1)\n    else:  # img.dim() == 4\n        assert img.size(1) == 3, 'img.size(1) shoule be 3 but \"%d\". (%s)' % (\n            img.size(1),\n            str(img.size()),\n        )\n        img_perm = img.permute(0, 2, 3, 1)\n        mean = torch.Tensor(mean)\n        std = torch.Tensor(std)\n        img_res = img_perm * std + mean\n        return img_res.permute(0, 3, 1, 2)", "\n\nclass CocoClassMapper:\n    def __init__(self) -> None:\n        self.category_map_str = {\n            \"1\": 1,\n            \"2\": 2,\n            \"3\": 3,\n            \"4\": 4,\n            \"5\": 5,\n            \"6\": 6,\n            \"7\": 7,\n            \"8\": 8,\n            \"9\": 9,\n            \"10\": 10,\n            \"11\": 11,\n            \"13\": 12,\n            \"14\": 13,\n            \"15\": 14,\n            \"16\": 15,\n            \"17\": 16,\n            \"18\": 17,\n            \"19\": 18,\n            \"20\": 19,\n            \"21\": 20,\n            \"22\": 21,\n            \"23\": 22,\n            \"24\": 23,\n            \"25\": 24,\n            \"27\": 25,\n            \"28\": 26,\n            \"31\": 27,\n            \"32\": 28,\n            \"33\": 29,\n            \"34\": 30,\n            \"35\": 31,\n            \"36\": 32,\n            \"37\": 33,\n            \"38\": 34,\n            \"39\": 35,\n            \"40\": 36,\n            \"41\": 37,\n            \"42\": 38,\n            \"43\": 39,\n            \"44\": 40,\n            \"46\": 41,\n            \"47\": 42,\n            \"48\": 43,\n            \"49\": 44,\n            \"50\": 45,\n            \"51\": 46,\n            \"52\": 47,\n            \"53\": 48,\n            \"54\": 49,\n            \"55\": 50,\n            \"56\": 51,\n            \"57\": 52,\n            \"58\": 53,\n            \"59\": 54,\n            \"60\": 55,\n            \"61\": 56,\n            \"62\": 57,\n            \"63\": 58,\n            \"64\": 59,\n            \"65\": 60,\n            \"67\": 61,\n            \"70\": 62,\n            \"72\": 63,\n            \"73\": 64,\n            \"74\": 65,\n            \"75\": 66,\n            \"76\": 67,\n            \"77\": 68,\n            \"78\": 69,\n            \"79\": 70,\n            \"80\": 71,\n            \"81\": 72,\n            \"82\": 73,\n            \"84\": 74,\n            \"85\": 75,\n            \"86\": 76,\n            \"87\": 77,\n            \"88\": 78,\n            \"89\": 79,\n            \"90\": 80,\n        }\n        self.origin2compact_mapper = {int(k): v - 1 for k, v in self.category_map_str.items()}\n        self.compact2origin_mapper = {int(v - 1): int(k) for k, v in self.category_map_str.items()}\n\n    def origin2compact(self, idx):\n        return self.origin2compact_mapper[int(idx)]\n\n    def compact2origin(self, idx):\n        return self.compact2origin_mapper[int(idx)]", "\n\ndef to_device(item, device):\n    if isinstance(item, torch.Tensor):\n        return item.to(device)\n    elif isinstance(item, list):\n        return [to_device(i, device) for i in item]\n    elif isinstance(item, dict):\n        return {k: to_device(v, device) for k, v in item.items()}\n    else:\n        raise NotImplementedError(\n            \"Call Shilong if you use other containers! type: {}\".format(type(item))\n        )", "\n\n#\ndef get_gaussian_mean(x, axis, other_axis, softmax=True):\n    \"\"\"\n\n    Args:\n        x (float): Input images(BxCxHxW)\n        axis (int): The index for weighted mean\n        other_axis (int): The other index\n\n    Returns: weighted index for axis, BxC\n\n    \"\"\"\n    mat2line = torch.sum(x, axis=other_axis)\n    # mat2line = mat2line / mat2line.mean() * 10\n    if softmax:\n        u = torch.softmax(mat2line, axis=2)\n    else:\n        u = mat2line / (mat2line.sum(2, keepdim=True) + 1e-6)\n    size = x.shape[axis]\n    ind = torch.linspace(0, 1, size).to(x.device)\n    batch = x.shape[0]\n    channel = x.shape[1]\n    index = ind.repeat([batch, channel, 1])\n    mean_position = torch.sum(index * u, dim=2)\n    return mean_position", "\n\ndef get_expected_points_from_map(hm, softmax=True):\n    \"\"\"get_gaussian_map_from_points\n        B,C,H,W -> B,N,2 float(0, 1) float(0, 1)\n        softargmax function\n\n    Args:\n        hm (float): Input images(BxCxHxW)\n\n    Returns:\n        weighted index for axis, BxCx2. float between 0 and 1.\n\n    \"\"\"\n    # hm = 10*hm\n    B, C, H, W = hm.shape\n    y_mean = get_gaussian_mean(hm, 2, 3, softmax=softmax)  # B,C\n    x_mean = get_gaussian_mean(hm, 3, 2, softmax=softmax)  # B,C\n    # return torch.cat((x_mean.unsqueeze(-1), y_mean.unsqueeze(-1)), 2)\n    return torch.stack([x_mean, y_mean], dim=2)", "\n\n# Positional encoding (section 5.1)\n# borrow from nerf\nclass Embedder:\n    def __init__(self, **kwargs):\n        self.kwargs = kwargs\n        self.create_embedding_fn()\n\n    def create_embedding_fn(self):\n        embed_fns = []\n        d = self.kwargs[\"input_dims\"]\n        out_dim = 0\n        if self.kwargs[\"include_input\"]:\n            embed_fns.append(lambda x: x)\n            out_dim += d\n\n        max_freq = self.kwargs[\"max_freq_log2\"]\n        N_freqs = self.kwargs[\"num_freqs\"]\n\n        if self.kwargs[\"log_sampling\"]:\n            freq_bands = 2.0 ** torch.linspace(0.0, max_freq, steps=N_freqs)\n        else:\n            freq_bands = torch.linspace(2.0**0.0, 2.0**max_freq, steps=N_freqs)\n\n        for freq in freq_bands:\n            for p_fn in self.kwargs[\"periodic_fns\"]:\n                embed_fns.append(lambda x, p_fn=p_fn, freq=freq: p_fn(x * freq))\n                out_dim += d\n\n        self.embed_fns = embed_fns\n        self.out_dim = out_dim\n\n    def embed(self, inputs):\n        return torch.cat([fn(inputs) for fn in self.embed_fns], -1)", "\n\ndef get_embedder(multires, i=0):\n    import torch.nn as nn\n\n    if i == -1:\n        return nn.Identity(), 3\n\n    embed_kwargs = {\n        \"include_input\": True,\n        \"input_dims\": 3,\n        \"max_freq_log2\": multires - 1,\n        \"num_freqs\": multires,\n        \"log_sampling\": True,\n        \"periodic_fns\": [torch.sin, torch.cos],\n    }\n\n    embedder_obj = Embedder(**embed_kwargs)\n    embed = lambda x, eo=embedder_obj: eo.embed(x)\n    return embed, embedder_obj.out_dim", "\n\nclass APOPMeter:\n    def __init__(self) -> None:\n        self.tp = 0\n        self.fp = 0\n        self.tn = 0\n        self.fn = 0\n\n    def update(self, pred, gt):\n        \"\"\"\n        Input:\n            pred, gt: Tensor()\n        \"\"\"\n        assert pred.shape == gt.shape\n        self.tp += torch.logical_and(pred == 1, gt == 1).sum().item()\n        self.fp += torch.logical_and(pred == 1, gt == 0).sum().item()\n        self.tn += torch.logical_and(pred == 0, gt == 0).sum().item()\n        self.tn += torch.logical_and(pred == 1, gt == 0).sum().item()\n\n    def update_cm(self, tp, fp, tn, fn):\n        self.tp += tp\n        self.fp += fp\n        self.tn += tn\n        self.tn += fn", "\n\ndef inverse_sigmoid(x, eps=1e-5):\n    x = x.clamp(min=0, max=1)\n    x1 = x.clamp(min=eps)\n    x2 = (1 - x).clamp(min=eps)\n    return torch.log(x1 / x2)\n\n\ndef get_raw_dict(args):\n    \"\"\"\n    return the dicf contained in args.\n\n    e.g:\n        >>> with open(path, 'w') as f:\n                json.dump(get_raw_dict(args), f, indent=2)\n    \"\"\"\n    if isinstance(args, argparse.Namespace):\n        return vars(args)\n    elif isinstance(args, dict):\n        return args\n    elif isinstance(args, SLConfig):\n        return args._cfg_dict\n    else:\n        raise NotImplementedError(\"Unknown type {}\".format(type(args)))", "\ndef get_raw_dict(args):\n    \"\"\"\n    return the dicf contained in args.\n\n    e.g:\n        >>> with open(path, 'w') as f:\n                json.dump(get_raw_dict(args), f, indent=2)\n    \"\"\"\n    if isinstance(args, argparse.Namespace):\n        return vars(args)\n    elif isinstance(args, dict):\n        return args\n    elif isinstance(args, SLConfig):\n        return args._cfg_dict\n    else:\n        raise NotImplementedError(\"Unknown type {}\".format(type(args)))", "\n\ndef stat_tensors(tensor):\n    assert tensor.dim() == 1\n    tensor_sm = tensor.softmax(0)\n    entropy = (tensor_sm * torch.log(tensor_sm + 1e-9)).sum()\n\n    return {\n        \"max\": tensor.max(),\n        \"min\": tensor.min(),\n        \"mean\": tensor.mean(),\n        \"var\": tensor.var(),\n        \"std\": tensor.var() ** 0.5,\n        \"entropy\": entropy,\n    }", "\n\nclass NiceRepr:\n    \"\"\"Inherit from this class and define ``__nice__`` to \"nicely\" print your\n    objects.\n\n    Defines ``__str__`` and ``__repr__`` in terms of ``__nice__`` function\n    Classes that inherit from :class:`NiceRepr` should redefine ``__nice__``.\n    If the inheriting class has a ``__len__``, method then the default\n    ``__nice__`` method will return its length.\n\n    Example:\n        >>> class Foo(NiceRepr):\n        ...    def __nice__(self):\n        ...        return 'info'\n        >>> foo = Foo()\n        >>> assert str(foo) == '<Foo(info)>'\n        >>> assert repr(foo).startswith('<Foo(info) at ')\n\n    Example:\n        >>> class Bar(NiceRepr):\n        ...    pass\n        >>> bar = Bar()\n        >>> import pytest\n        >>> with pytest.warns(None) as record:\n        >>>     assert 'object at' in str(bar)\n        >>>     assert 'object at' in repr(bar)\n\n    Example:\n        >>> class Baz(NiceRepr):\n        ...    def __len__(self):\n        ...        return 5\n        >>> baz = Baz()\n        >>> assert str(baz) == '<Baz(5)>'\n    \"\"\"\n\n    def __nice__(self):\n        \"\"\"str: a \"nice\" summary string describing this module\"\"\"\n        if hasattr(self, \"__len__\"):\n            # It is a common pattern for objects to use __len__ in __nice__\n            # As a convenience we define a default __nice__ for these objects\n            return str(len(self))\n        else:\n            # In all other cases force the subclass to overload __nice__\n            raise NotImplementedError(f\"Define the __nice__ method for {self.__class__!r}\")\n\n    def __repr__(self):\n        \"\"\"str: the string of the module\"\"\"\n        try:\n            nice = self.__nice__()\n            classname = self.__class__.__name__\n            return f\"<{classname}({nice}) at {hex(id(self))}>\"\n        except NotImplementedError as ex:\n            warnings.warn(str(ex), category=RuntimeWarning)\n            return object.__repr__(self)\n\n    def __str__(self):\n        \"\"\"str: the string of the module\"\"\"\n        try:\n            classname = self.__class__.__name__\n            nice = self.__nice__()\n            return f\"<{classname}({nice})>\"\n        except NotImplementedError as ex:\n            warnings.warn(str(ex), category=RuntimeWarning)\n            return object.__repr__(self)", "\n\ndef ensure_rng(rng=None):\n    \"\"\"Coerces input into a random number generator.\n\n    If the input is None, then a global random state is returned.\n\n    If the input is a numeric value, then that is used as a seed to construct a\n    random state. Otherwise the input is returned as-is.\n\n    Adapted from [1]_.\n\n    Args:\n        rng (int | numpy.random.RandomState | None):\n            if None, then defaults to the global rng. Otherwise this can be an\n            integer or a RandomState class\n    Returns:\n        (numpy.random.RandomState) : rng -\n            a numpy random number generator\n\n    References:\n        .. [1] https://gitlab.kitware.com/computer-vision/kwarray/blob/master/kwarray/util_random.py#L270  # noqa: E501\n    \"\"\"\n\n    if rng is None:\n        rng = np.random.mtrand._rand\n    elif isinstance(rng, int):\n        rng = np.random.RandomState(rng)\n    else:\n        rng = rng\n    return rng", "\n\ndef random_boxes(num=1, scale=1, rng=None):\n    \"\"\"Simple version of ``kwimage.Boxes.random``\n\n    Returns:\n        Tensor: shape (n, 4) in x1, y1, x2, y2 format.\n\n    References:\n        https://gitlab.kitware.com/computer-vision/kwimage/blob/master/kwimage/structs/boxes.py#L1390\n\n    Example:\n        >>> num = 3\n        >>> scale = 512\n        >>> rng = 0\n        >>> boxes = random_boxes(num, scale, rng)\n        >>> print(boxes)\n        tensor([[280.9925, 278.9802, 308.6148, 366.1769],\n                [216.9113, 330.6978, 224.0446, 456.5878],\n                [405.3632, 196.3221, 493.3953, 270.7942]])\n    \"\"\"\n    rng = ensure_rng(rng)\n\n    tlbr = rng.rand(num, 4).astype(np.float32)\n\n    tl_x = np.minimum(tlbr[:, 0], tlbr[:, 2])\n    tl_y = np.minimum(tlbr[:, 1], tlbr[:, 3])\n    br_x = np.maximum(tlbr[:, 0], tlbr[:, 2])\n    br_y = np.maximum(tlbr[:, 1], tlbr[:, 3])\n\n    tlbr[:, 0] = tl_x * scale\n    tlbr[:, 1] = tl_y * scale\n    tlbr[:, 2] = br_x * scale\n    tlbr[:, 3] = br_y * scale\n\n    boxes = torch.from_numpy(tlbr)\n    return boxes", "\n\nclass ModelEma(torch.nn.Module):\n    def __init__(self, model, decay=0.9997, device=None):\n        super(ModelEma, self).__init__()\n        # make a copy of the model for accumulating moving average of weights\n        self.module = deepcopy(model)\n        self.module.eval()\n\n        # import ipdb; ipdb.set_trace()\n\n        self.decay = decay\n        self.device = device  # perform ema on different device from model if set\n        if self.device is not None:\n            self.module.to(device=device)\n\n    def _update(self, model, update_fn):\n        with torch.no_grad():\n            for ema_v, model_v in zip(\n                self.module.state_dict().values(), model.state_dict().values()\n            ):\n                if self.device is not None:\n                    model_v = model_v.to(device=self.device)\n                ema_v.copy_(update_fn(ema_v, model_v))\n\n    def update(self, model):\n        self._update(model, update_fn=lambda e, m: self.decay * e + (1.0 - self.decay) * m)\n\n    def set(self, model):\n        self._update(model, update_fn=lambda e, m: m)", "\n\nclass BestMetricSingle:\n    def __init__(self, init_res=0.0, better=\"large\") -> None:\n        self.init_res = init_res\n        self.best_res = init_res\n        self.best_ep = -1\n\n        self.better = better\n        assert better in [\"large\", \"small\"]\n\n    def isbetter(self, new_res, old_res):\n        if self.better == \"large\":\n            return new_res > old_res\n        if self.better == \"small\":\n            return new_res < old_res\n\n    def update(self, new_res, ep):\n        if self.isbetter(new_res, self.best_res):\n            self.best_res = new_res\n            self.best_ep = ep\n            return True\n        return False\n\n    def __str__(self) -> str:\n        return \"best_res: {}\\t best_ep: {}\".format(self.best_res, self.best_ep)\n\n    def __repr__(self) -> str:\n        return self.__str__()\n\n    def summary(self) -> dict:\n        return {\n            \"best_res\": self.best_res,\n            \"best_ep\": self.best_ep,\n        }", "\n\nclass BestMetricHolder:\n    def __init__(self, init_res=0.0, better=\"large\", use_ema=False) -> None:\n        self.best_all = BestMetricSingle(init_res, better)\n        self.use_ema = use_ema\n        if use_ema:\n            self.best_ema = BestMetricSingle(init_res, better)\n            self.best_regular = BestMetricSingle(init_res, better)\n\n    def update(self, new_res, epoch, is_ema=False):\n        \"\"\"\n        return if the results is the best.\n        \"\"\"\n        if not self.use_ema:\n            return self.best_all.update(new_res, epoch)\n        else:\n            if is_ema:\n                self.best_ema.update(new_res, epoch)\n                return self.best_all.update(new_res, epoch)\n            else:\n                self.best_regular.update(new_res, epoch)\n                return self.best_all.update(new_res, epoch)\n\n    def summary(self):\n        if not self.use_ema:\n            return self.best_all.summary()\n\n        res = {}\n        res.update({f\"all_{k}\": v for k, v in self.best_all.summary().items()})\n        res.update({f\"regular_{k}\": v for k, v in self.best_regular.summary().items()})\n        res.update({f\"ema_{k}\": v for k, v in self.best_ema.summary().items()})\n        return res\n\n    def __repr__(self) -> str:\n        return json.dumps(self.summary(), indent=2)\n\n    def __str__(self) -> str:\n        return self.__repr__()", "\n\ndef targets_to(targets: List[Dict[str, Any]], device):\n    \"\"\"Moves the target dicts to the given device.\"\"\"\n    excluded_keys = [\n        \"questionId\",\n        \"tokens_positive\",\n        \"strings_positive\",\n        \"tokens\",\n        \"dataset_name\",\n        \"sentence_id\",\n        \"original_img_id\",\n        \"nb_eval\",\n        \"task_id\",\n        \"original_id\",\n        \"token_span\",\n        \"caption\",\n        \"dataset_type\",\n    ]\n    return [\n        {k: v.to(device) if k not in excluded_keys else v for k, v in t.items()} for t in targets\n    ]", "\n\ndef get_phrases_from_posmap(\n    posmap: torch.BoolTensor, tokenized: Dict, tokenizer: AutoTokenizer\n):\n    assert isinstance(posmap, torch.Tensor), \"posmap must be torch.Tensor\"\n    if posmap.dim() == 1:\n        non_zero_idx = posmap.nonzero(as_tuple=True)[0].tolist()\n        token_ids = [tokenized[\"input_ids\"][i] for i in non_zero_idx]\n        return tokenizer.decode(token_ids)\n    else:\n        raise NotImplementedError(\"posmap must be 1-dim\")", ""]}
{"filename": "local_groundingdino/util/misc.py", "chunked_list": ["# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved\n\"\"\"\nMisc functions, including distributed helpers.\n\nMostly copy-paste from torchvision references.\n\"\"\"\nimport colorsys\nimport datetime\nimport functools\nimport io", "import functools\nimport io\nimport json\nimport os\nimport pickle\nimport subprocess\nimport time\nfrom collections import OrderedDict, defaultdict, deque\nfrom typing import List, Optional\n", "from typing import List, Optional\n\nimport numpy as np\nimport torch\nimport torch.distributed as dist\n\n# needed due to empty tensor bug in pytorch and torchvision 0.5\nimport torchvision\nfrom torch import Tensor\n", "from torch import Tensor\n\n__torchvision_need_compat_flag = float(torchvision.__version__.split(\".\")[1]) < 7\nif __torchvision_need_compat_flag:\n    from torchvision.ops import _new_empty_tensor\n    from torchvision.ops.misc import _output_size\n\n\nclass SmoothedValue(object):\n    \"\"\"Track a series of values and provide access to smoothed values over a\n    window or the global series average.\n    \"\"\"\n\n    def __init__(self, window_size=20, fmt=None):\n        if fmt is None:\n            fmt = \"{median:.4f} ({global_avg:.4f})\"\n        self.deque = deque(maxlen=window_size)\n        self.total = 0.0\n        self.count = 0\n        self.fmt = fmt\n\n    def update(self, value, n=1):\n        self.deque.append(value)\n        self.count += n\n        self.total += value * n\n\n    def synchronize_between_processes(self):\n        \"\"\"\n        Warning: does not synchronize the deque!\n        \"\"\"\n        if not is_dist_avail_and_initialized():\n            return\n        t = torch.tensor([self.count, self.total], dtype=torch.float64, device=\"cuda\")\n        dist.barrier()\n        dist.all_reduce(t)\n        t = t.tolist()\n        self.count = int(t[0])\n        self.total = t[1]\n\n    @property\n    def median(self):\n        d = torch.tensor(list(self.deque))\n        if d.shape[0] == 0:\n            return 0\n        return d.median().item()\n\n    @property\n    def avg(self):\n        d = torch.tensor(list(self.deque), dtype=torch.float32)\n        return d.mean().item()\n\n    @property\n    def global_avg(self):\n        if os.environ.get(\"SHILONG_AMP\", None) == \"1\":\n            eps = 1e-4\n        else:\n            eps = 1e-6\n        return self.total / (self.count + eps)\n\n    @property\n    def max(self):\n        return max(self.deque)\n\n    @property\n    def value(self):\n        return self.deque[-1]\n\n    def __str__(self):\n        return self.fmt.format(\n            median=self.median,\n            avg=self.avg,\n            global_avg=self.global_avg,\n            max=self.max,\n            value=self.value,\n        )", "class SmoothedValue(object):\n    \"\"\"Track a series of values and provide access to smoothed values over a\n    window or the global series average.\n    \"\"\"\n\n    def __init__(self, window_size=20, fmt=None):\n        if fmt is None:\n            fmt = \"{median:.4f} ({global_avg:.4f})\"\n        self.deque = deque(maxlen=window_size)\n        self.total = 0.0\n        self.count = 0\n        self.fmt = fmt\n\n    def update(self, value, n=1):\n        self.deque.append(value)\n        self.count += n\n        self.total += value * n\n\n    def synchronize_between_processes(self):\n        \"\"\"\n        Warning: does not synchronize the deque!\n        \"\"\"\n        if not is_dist_avail_and_initialized():\n            return\n        t = torch.tensor([self.count, self.total], dtype=torch.float64, device=\"cuda\")\n        dist.barrier()\n        dist.all_reduce(t)\n        t = t.tolist()\n        self.count = int(t[0])\n        self.total = t[1]\n\n    @property\n    def median(self):\n        d = torch.tensor(list(self.deque))\n        if d.shape[0] == 0:\n            return 0\n        return d.median().item()\n\n    @property\n    def avg(self):\n        d = torch.tensor(list(self.deque), dtype=torch.float32)\n        return d.mean().item()\n\n    @property\n    def global_avg(self):\n        if os.environ.get(\"SHILONG_AMP\", None) == \"1\":\n            eps = 1e-4\n        else:\n            eps = 1e-6\n        return self.total / (self.count + eps)\n\n    @property\n    def max(self):\n        return max(self.deque)\n\n    @property\n    def value(self):\n        return self.deque[-1]\n\n    def __str__(self):\n        return self.fmt.format(\n            median=self.median,\n            avg=self.avg,\n            global_avg=self.global_avg,\n            max=self.max,\n            value=self.value,\n        )", "\n\n@functools.lru_cache()\ndef _get_global_gloo_group():\n    \"\"\"\n    Return a process group based on gloo backend, containing all the ranks\n    The result is cached.\n    \"\"\"\n\n    if dist.get_backend() == \"nccl\":\n        return dist.new_group(backend=\"gloo\")\n\n    return dist.group.WORLD", "\n\ndef all_gather_cpu(data):\n    \"\"\"\n    Run all_gather on arbitrary picklable data (not necessarily tensors)\n    Args:\n        data: any picklable object\n    Returns:\n        list[data]: list of data gathered from each rank\n    \"\"\"\n\n    world_size = get_world_size()\n    if world_size == 1:\n        return [data]\n\n    cpu_group = _get_global_gloo_group()\n\n    buffer = io.BytesIO()\n    torch.save(data, buffer)\n    data_view = buffer.getbuffer()\n    device = \"cuda\" if cpu_group is None else \"cpu\"\n    tensor = torch.ByteTensor(data_view).to(device)\n\n    # obtain Tensor size of each rank\n    local_size = torch.tensor([tensor.numel()], device=device, dtype=torch.long)\n    size_list = [torch.tensor([0], device=device, dtype=torch.long) for _ in range(world_size)]\n    if cpu_group is None:\n        dist.all_gather(size_list, local_size)\n    else:\n        print(\"gathering on cpu\")\n        dist.all_gather(size_list, local_size, group=cpu_group)\n    size_list = [int(size.item()) for size in size_list]\n    max_size = max(size_list)\n    assert isinstance(local_size.item(), int)\n    local_size = int(local_size.item())\n\n    # receiving Tensor from all ranks\n    # we pad the tensor because torch all_gather does not support\n    # gathering tensors of different shapes\n    tensor_list = []\n    for _ in size_list:\n        tensor_list.append(torch.empty((max_size,), dtype=torch.uint8, device=device))\n    if local_size != max_size:\n        padding = torch.empty(size=(max_size - local_size,), dtype=torch.uint8, device=device)\n        tensor = torch.cat((tensor, padding), dim=0)\n    if cpu_group is None:\n        dist.all_gather(tensor_list, tensor)\n    else:\n        dist.all_gather(tensor_list, tensor, group=cpu_group)\n\n    data_list = []\n    for size, tensor in zip(size_list, tensor_list):\n        tensor = torch.split(tensor, [size, max_size - size], dim=0)[0]\n        buffer = io.BytesIO(tensor.cpu().numpy())\n        obj = torch.load(buffer)\n        data_list.append(obj)\n\n    return data_list", "\n\ndef all_gather(data):\n    \"\"\"\n    Run all_gather on arbitrary picklable data (not necessarily tensors)\n    Args:\n        data: any picklable object\n    Returns:\n        list[data]: list of data gathered from each rank\n    \"\"\"\n\n    if os.getenv(\"CPU_REDUCE\") == \"1\":\n        return all_gather_cpu(data)\n\n    world_size = get_world_size()\n    if world_size == 1:\n        return [data]\n\n    # serialized to a Tensor\n    buffer = pickle.dumps(data)\n    storage = torch.ByteStorage.from_buffer(buffer)\n    tensor = torch.ByteTensor(storage).to(\"cuda\")\n\n    # obtain Tensor size of each rank\n    local_size = torch.tensor([tensor.numel()], device=\"cuda\")\n    size_list = [torch.tensor([0], device=\"cuda\") for _ in range(world_size)]\n    dist.all_gather(size_list, local_size)\n    size_list = [int(size.item()) for size in size_list]\n    max_size = max(size_list)\n\n    # receiving Tensor from all ranks\n    # we pad the tensor because torch all_gather does not support\n    # gathering tensors of different shapes\n    tensor_list = []\n    for _ in size_list:\n        tensor_list.append(torch.empty((max_size,), dtype=torch.uint8, device=\"cuda\"))\n    if local_size != max_size:\n        padding = torch.empty(size=(max_size - local_size,), dtype=torch.uint8, device=\"cuda\")\n        tensor = torch.cat((tensor, padding), dim=0)\n    dist.all_gather(tensor_list, tensor)\n\n    data_list = []\n    for size, tensor in zip(size_list, tensor_list):\n        buffer = tensor.cpu().numpy().tobytes()[:size]\n        data_list.append(pickle.loads(buffer))\n\n    return data_list", "\n\ndef reduce_dict(input_dict, average=True):\n    \"\"\"\n    Args:\n        input_dict (dict): all the values will be reduced\n        average (bool): whether to do average or sum\n    Reduce the values in the dictionary from all processes so that all processes\n    have the averaged results. Returns a dict with the same fields as\n    input_dict, after reduction.\n    \"\"\"\n    world_size = get_world_size()\n    if world_size < 2:\n        return input_dict\n    with torch.no_grad():\n        names = []\n        values = []\n        # sort the keys so that they are consistent across processes\n        for k in sorted(input_dict.keys()):\n            names.append(k)\n            values.append(input_dict[k])\n        values = torch.stack(values, dim=0)\n        dist.all_reduce(values)\n        if average:\n            values /= world_size\n        reduced_dict = {k: v for k, v in zip(names, values)}\n    return reduced_dict", "\n\nclass MetricLogger(object):\n    def __init__(self, delimiter=\"\\t\"):\n        self.meters = defaultdict(SmoothedValue)\n        self.delimiter = delimiter\n\n    def update(self, **kwargs):\n        for k, v in kwargs.items():\n            if isinstance(v, torch.Tensor):\n                v = v.item()\n            assert isinstance(v, (float, int))\n            self.meters[k].update(v)\n\n    def __getattr__(self, attr):\n        if attr in self.meters:\n            return self.meters[attr]\n        if attr in self.__dict__:\n            return self.__dict__[attr]\n        raise AttributeError(\"'{}' object has no attribute '{}'\".format(type(self).__name__, attr))\n\n    def __str__(self):\n        loss_str = []\n        for name, meter in self.meters.items():\n            # print(name, str(meter))\n            # import ipdb;ipdb.set_trace()\n            if meter.count > 0:\n                loss_str.append(\"{}: {}\".format(name, str(meter)))\n        return self.delimiter.join(loss_str)\n\n    def synchronize_between_processes(self):\n        for meter in self.meters.values():\n            meter.synchronize_between_processes()\n\n    def add_meter(self, name, meter):\n        self.meters[name] = meter\n\n    def log_every(self, iterable, print_freq, header=None, logger=None):\n        if logger is None:\n            print_func = print\n        else:\n            print_func = logger.info\n\n        i = 0\n        if not header:\n            header = \"\"\n        start_time = time.time()\n        end = time.time()\n        iter_time = SmoothedValue(fmt=\"{avg:.4f}\")\n        data_time = SmoothedValue(fmt=\"{avg:.4f}\")\n        space_fmt = \":\" + str(len(str(len(iterable)))) + \"d\"\n        if torch.cuda.is_available():\n            log_msg = self.delimiter.join(\n                [\n                    header,\n                    \"[{0\" + space_fmt + \"}/{1}]\",\n                    \"eta: {eta}\",\n                    \"{meters}\",\n                    \"time: {time}\",\n                    \"data: {data}\",\n                    \"max mem: {memory:.0f}\",\n                ]\n            )\n        else:\n            log_msg = self.delimiter.join(\n                [\n                    header,\n                    \"[{0\" + space_fmt + \"}/{1}]\",\n                    \"eta: {eta}\",\n                    \"{meters}\",\n                    \"time: {time}\",\n                    \"data: {data}\",\n                ]\n            )\n        MB = 1024.0 * 1024.0\n        for obj in iterable:\n            data_time.update(time.time() - end)\n            yield obj\n            # import ipdb; ipdb.set_trace()\n            iter_time.update(time.time() - end)\n            if i % print_freq == 0 or i == len(iterable) - 1:\n                eta_seconds = iter_time.global_avg * (len(iterable) - i)\n                eta_string = str(datetime.timedelta(seconds=int(eta_seconds)))\n                if torch.cuda.is_available():\n                    print_func(\n                        log_msg.format(\n                            i,\n                            len(iterable),\n                            eta=eta_string,\n                            meters=str(self),\n                            time=str(iter_time),\n                            data=str(data_time),\n                            memory=torch.cuda.max_memory_allocated() / MB,\n                        )\n                    )\n                else:\n                    print_func(\n                        log_msg.format(\n                            i,\n                            len(iterable),\n                            eta=eta_string,\n                            meters=str(self),\n                            time=str(iter_time),\n                            data=str(data_time),\n                        )\n                    )\n            i += 1\n            end = time.time()\n        total_time = time.time() - start_time\n        total_time_str = str(datetime.timedelta(seconds=int(total_time)))\n        print_func(\n            \"{} Total time: {} ({:.4f} s / it)\".format(\n                header, total_time_str, total_time / len(iterable)\n            )\n        )", "\n\ndef get_sha():\n    cwd = os.path.dirname(os.path.abspath(__file__))\n\n    def _run(command):\n        return subprocess.check_output(command, cwd=cwd).decode(\"ascii\").strip()\n\n    sha = \"N/A\"\n    diff = \"clean\"\n    branch = \"N/A\"\n    try:\n        sha = _run([\"git\", \"rev-parse\", \"HEAD\"])\n        subprocess.check_output([\"git\", \"diff\"], cwd=cwd)\n        diff = _run([\"git\", \"diff-index\", \"HEAD\"])\n        diff = \"has uncommited changes\" if diff else \"clean\"\n        branch = _run([\"git\", \"rev-parse\", \"--abbrev-ref\", \"HEAD\"])\n    except Exception:\n        pass\n    message = f\"sha: {sha}, status: {diff}, branch: {branch}\"\n    return message", "\n\ndef collate_fn(batch):\n    # import ipdb; ipdb.set_trace()\n    batch = list(zip(*batch))\n    batch[0] = nested_tensor_from_tensor_list(batch[0])\n    return tuple(batch)\n\n\ndef _max_by_axis(the_list):\n    # type: (List[List[int]]) -> List[int]\n    maxes = the_list[0]\n    for sublist in the_list[1:]:\n        for index, item in enumerate(sublist):\n            maxes[index] = max(maxes[index], item)\n    return maxes", "\ndef _max_by_axis(the_list):\n    # type: (List[List[int]]) -> List[int]\n    maxes = the_list[0]\n    for sublist in the_list[1:]:\n        for index, item in enumerate(sublist):\n            maxes[index] = max(maxes[index], item)\n    return maxes\n\n\nclass NestedTensor(object):\n    def __init__(self, tensors, mask: Optional[Tensor]):\n        self.tensors = tensors\n        self.mask = mask\n        if mask == \"auto\":\n            self.mask = torch.zeros_like(tensors).to(tensors.device)\n            if self.mask.dim() == 3:\n                self.mask = self.mask.sum(0).to(bool)\n            elif self.mask.dim() == 4:\n                self.mask = self.mask.sum(1).to(bool)\n            else:\n                raise ValueError(\n                    \"tensors dim must be 3 or 4 but {}({})\".format(\n                        self.tensors.dim(), self.tensors.shape\n                    )\n                )\n\n    def imgsize(self):\n        res = []\n        for i in range(self.tensors.shape[0]):\n            mask = self.mask[i]\n            maxH = (~mask).sum(0).max()\n            maxW = (~mask).sum(1).max()\n            res.append(torch.Tensor([maxH, maxW]))\n        return res\n\n    def to(self, device):\n        # type: (Device) -> NestedTensor # noqa\n        cast_tensor = self.tensors.to(device)\n        mask = self.mask\n        if mask is not None:\n            assert mask is not None\n            cast_mask = mask.to(device)\n        else:\n            cast_mask = None\n        return NestedTensor(cast_tensor, cast_mask)\n\n    def to_img_list_single(self, tensor, mask):\n        assert tensor.dim() == 3, \"dim of tensor should be 3 but {}\".format(tensor.dim())\n        maxH = (~mask).sum(0).max()\n        maxW = (~mask).sum(1).max()\n        img = tensor[:, :maxH, :maxW]\n        return img\n\n    def to_img_list(self):\n        \"\"\"remove the padding and convert to img list\n\n        Returns:\n            [type]: [description]\n        \"\"\"\n        if self.tensors.dim() == 3:\n            return self.to_img_list_single(self.tensors, self.mask)\n        else:\n            res = []\n            for i in range(self.tensors.shape[0]):\n                tensor_i = self.tensors[i]\n                mask_i = self.mask[i]\n                res.append(self.to_img_list_single(tensor_i, mask_i))\n            return res\n\n    @property\n    def device(self):\n        return self.tensors.device\n\n    def decompose(self):\n        return self.tensors, self.mask\n\n    def __repr__(self):\n        return str(self.tensors)\n\n    @property\n    def shape(self):\n        return {\"tensors.shape\": self.tensors.shape, \"mask.shape\": self.mask.shape}", "\n\nclass NestedTensor(object):\n    def __init__(self, tensors, mask: Optional[Tensor]):\n        self.tensors = tensors\n        self.mask = mask\n        if mask == \"auto\":\n            self.mask = torch.zeros_like(tensors).to(tensors.device)\n            if self.mask.dim() == 3:\n                self.mask = self.mask.sum(0).to(bool)\n            elif self.mask.dim() == 4:\n                self.mask = self.mask.sum(1).to(bool)\n            else:\n                raise ValueError(\n                    \"tensors dim must be 3 or 4 but {}({})\".format(\n                        self.tensors.dim(), self.tensors.shape\n                    )\n                )\n\n    def imgsize(self):\n        res = []\n        for i in range(self.tensors.shape[0]):\n            mask = self.mask[i]\n            maxH = (~mask).sum(0).max()\n            maxW = (~mask).sum(1).max()\n            res.append(torch.Tensor([maxH, maxW]))\n        return res\n\n    def to(self, device):\n        # type: (Device) -> NestedTensor # noqa\n        cast_tensor = self.tensors.to(device)\n        mask = self.mask\n        if mask is not None:\n            assert mask is not None\n            cast_mask = mask.to(device)\n        else:\n            cast_mask = None\n        return NestedTensor(cast_tensor, cast_mask)\n\n    def to_img_list_single(self, tensor, mask):\n        assert tensor.dim() == 3, \"dim of tensor should be 3 but {}\".format(tensor.dim())\n        maxH = (~mask).sum(0).max()\n        maxW = (~mask).sum(1).max()\n        img = tensor[:, :maxH, :maxW]\n        return img\n\n    def to_img_list(self):\n        \"\"\"remove the padding and convert to img list\n\n        Returns:\n            [type]: [description]\n        \"\"\"\n        if self.tensors.dim() == 3:\n            return self.to_img_list_single(self.tensors, self.mask)\n        else:\n            res = []\n            for i in range(self.tensors.shape[0]):\n                tensor_i = self.tensors[i]\n                mask_i = self.mask[i]\n                res.append(self.to_img_list_single(tensor_i, mask_i))\n            return res\n\n    @property\n    def device(self):\n        return self.tensors.device\n\n    def decompose(self):\n        return self.tensors, self.mask\n\n    def __repr__(self):\n        return str(self.tensors)\n\n    @property\n    def shape(self):\n        return {\"tensors.shape\": self.tensors.shape, \"mask.shape\": self.mask.shape}", "\n\ndef nested_tensor_from_tensor_list(tensor_list: List[Tensor]):\n    # TODO make this more general\n    if tensor_list[0].ndim == 3:\n        if torchvision._is_tracing():\n            # nested_tensor_from_tensor_list() does not export well to ONNX\n            # call _onnx_nested_tensor_from_tensor_list() instead\n            return _onnx_nested_tensor_from_tensor_list(tensor_list)\n\n        # TODO make it support different-sized images\n        max_size = _max_by_axis([list(img.shape) for img in tensor_list])\n        # min_size = tuple(min(s) for s in zip(*[img.shape for img in tensor_list]))\n        batch_shape = [len(tensor_list)] + max_size\n        b, c, h, w = batch_shape\n        dtype = tensor_list[0].dtype\n        device = tensor_list[0].device\n        tensor = torch.zeros(batch_shape, dtype=dtype, device=device)\n        mask = torch.ones((b, h, w), dtype=torch.bool, device=device)\n        for img, pad_img, m in zip(tensor_list, tensor, mask):\n            pad_img[: img.shape[0], : img.shape[1], : img.shape[2]].copy_(img)\n            m[: img.shape[1], : img.shape[2]] = False\n    else:\n        raise ValueError(\"not supported\")\n    return NestedTensor(tensor, mask)", "\n\n# _onnx_nested_tensor_from_tensor_list() is an implementation of\n# nested_tensor_from_tensor_list() that is supported by ONNX tracing.\n@torch.jit.unused\ndef _onnx_nested_tensor_from_tensor_list(tensor_list: List[Tensor]) -> NestedTensor:\n    max_size = []\n    for i in range(tensor_list[0].dim()):\n        max_size_i = torch.max(\n            torch.stack([img.shape[i] for img in tensor_list]).to(torch.float32)\n        ).to(torch.int64)\n        max_size.append(max_size_i)\n    max_size = tuple(max_size)\n\n    # work around for\n    # pad_img[: img.shape[0], : img.shape[1], : img.shape[2]].copy_(img)\n    # m[: img.shape[1], :img.shape[2]] = False\n    # which is not yet supported in onnx\n    padded_imgs = []\n    padded_masks = []\n    for img in tensor_list:\n        padding = [(s1 - s2) for s1, s2 in zip(max_size, tuple(img.shape))]\n        padded_img = torch.nn.functional.pad(img, (0, padding[2], 0, padding[1], 0, padding[0]))\n        padded_imgs.append(padded_img)\n\n        m = torch.zeros_like(img[0], dtype=torch.int, device=img.device)\n        padded_mask = torch.nn.functional.pad(m, (0, padding[2], 0, padding[1]), \"constant\", 1)\n        padded_masks.append(padded_mask.to(torch.bool))\n\n    tensor = torch.stack(padded_imgs)\n    mask = torch.stack(padded_masks)\n\n    return NestedTensor(tensor, mask=mask)", "\n\ndef setup_for_distributed(is_master):\n    \"\"\"\n    This function disables printing when not in master process\n    \"\"\"\n    import builtins as __builtin__\n\n    builtin_print = __builtin__.print\n\n    def print(*args, **kwargs):\n        force = kwargs.pop(\"force\", False)\n        if is_master or force:\n            builtin_print(*args, **kwargs)\n\n    __builtin__.print = print", "\n\ndef is_dist_avail_and_initialized():\n    if not dist.is_available():\n        return False\n    if not dist.is_initialized():\n        return False\n    return True\n\n\ndef get_world_size():\n    if not is_dist_avail_and_initialized():\n        return 1\n    return dist.get_world_size()", "\n\ndef get_world_size():\n    if not is_dist_avail_and_initialized():\n        return 1\n    return dist.get_world_size()\n\n\ndef get_rank():\n    if not is_dist_avail_and_initialized():\n        return 0\n    return dist.get_rank()", "def get_rank():\n    if not is_dist_avail_and_initialized():\n        return 0\n    return dist.get_rank()\n\n\ndef is_main_process():\n    return get_rank() == 0\n\n\ndef save_on_master(*args, **kwargs):\n    if is_main_process():\n        torch.save(*args, **kwargs)", "\n\ndef save_on_master(*args, **kwargs):\n    if is_main_process():\n        torch.save(*args, **kwargs)\n\n\ndef init_distributed_mode(args):\n    if \"WORLD_SIZE\" in os.environ and os.environ[\"WORLD_SIZE\"] != \"\":  # 'RANK' in os.environ and\n        args.rank = int(os.environ[\"RANK\"])\n        args.world_size = int(os.environ[\"WORLD_SIZE\"])\n        args.gpu = args.local_rank = int(os.environ[\"LOCAL_RANK\"])\n\n        # launch by torch.distributed.launch\n        # Single node\n        #   python -m torch.distributed.launch --nproc_per_node=8 main.py --world-size 1 --rank 0 ...\n        # Multi nodes\n        #   python -m torch.distributed.launch --nproc_per_node=8 main.py --world-size 2 --rank 0 --dist-url 'tcp://IP_OF_NODE0:FREEPORT' ...\n        #   python -m torch.distributed.launch --nproc_per_node=8 main.py --world-size 2 --rank 1 --dist-url 'tcp://IP_OF_NODE0:FREEPORT' ...\n        # args.rank = int(os.environ.get('OMPI_COMM_WORLD_RANK'))\n        # local_world_size = int(os.environ['GPU_PER_NODE_COUNT'])\n        # args.world_size = args.world_size * local_world_size\n        # args.gpu = args.local_rank = int(os.environ['LOCAL_RANK'])\n        # args.rank = args.rank * local_world_size + args.local_rank\n        print(\n            \"world size: {}, rank: {}, local rank: {}\".format(\n                args.world_size, args.rank, args.local_rank\n            )\n        )\n        print(json.dumps(dict(os.environ), indent=2))\n    elif \"SLURM_PROCID\" in os.environ:\n        args.rank = int(os.environ[\"SLURM_PROCID\"])\n        args.gpu = args.local_rank = int(os.environ[\"SLURM_LOCALID\"])\n        args.world_size = int(os.environ[\"SLURM_NPROCS\"])\n\n        print(\n            \"world size: {}, world rank: {}, local rank: {}, device_count: {}\".format(\n                args.world_size, args.rank, args.local_rank, torch.cuda.device_count()\n            )\n        )\n    else:\n        print(\"Not using distributed mode\")\n        args.distributed = False\n        args.world_size = 1\n        args.rank = 0\n        args.local_rank = 0\n        return\n\n    print(\"world_size:{} rank:{} local_rank:{}\".format(args.world_size, args.rank, args.local_rank))\n    args.distributed = True\n    torch.cuda.set_device(args.local_rank)\n    args.dist_backend = \"nccl\"\n    print(\"| distributed init (rank {}): {}\".format(args.rank, args.dist_url), flush=True)\n\n    torch.distributed.init_process_group(\n        backend=args.dist_backend,\n        world_size=args.world_size,\n        rank=args.rank,\n        init_method=args.dist_url,\n    )\n\n    print(\"Before torch.distributed.barrier()\")\n    torch.distributed.barrier()\n    print(\"End torch.distributed.barrier()\")\n    setup_for_distributed(args.rank == 0)", "\n\n@torch.no_grad()\ndef accuracy(output, target, topk=(1,)):\n    \"\"\"Computes the precision@k for the specified values of k\"\"\"\n    if target.numel() == 0:\n        return [torch.zeros([], device=output.device)]\n    maxk = max(topk)\n    batch_size = target.size(0)\n\n    _, pred = output.topk(maxk, 1, True, True)\n    pred = pred.t()\n    correct = pred.eq(target.view(1, -1).expand_as(pred))\n\n    res = []\n    for k in topk:\n        correct_k = correct[:k].view(-1).float().sum(0)\n        res.append(correct_k.mul_(100.0 / batch_size))\n    return res", "\n\n@torch.no_grad()\ndef accuracy_onehot(pred, gt):\n    \"\"\"_summary_\n\n    Args:\n        pred (_type_): n, c\n        gt (_type_): n, c\n    \"\"\"\n    tp = ((pred - gt).abs().sum(-1) < 1e-4).float().sum()\n    acc = tp / gt.shape[0] * 100\n    return acc", "\n\ndef interpolate(input, size=None, scale_factor=None, mode=\"nearest\", align_corners=None):\n    # type: (Tensor, Optional[List[int]], Optional[float], str, Optional[bool]) -> Tensor\n    \"\"\"\n    Equivalent to nn.functional.interpolate, but with support for empty batch sizes.\n    This will eventually be supported natively by PyTorch, and this\n    class can go away.\n    \"\"\"\n    if __torchvision_need_compat_flag < 0.7:\n        if input.numel() > 0:\n            return torch.nn.functional.interpolate(input, size, scale_factor, mode, align_corners)\n\n        output_shape = _output_size(2, input, size, scale_factor)\n        output_shape = list(input.shape[:-2]) + list(output_shape)\n        return _new_empty_tensor(input, output_shape)\n    else:\n        return torchvision.ops.misc.interpolate(input, size, scale_factor, mode, align_corners)", "\n\nclass color_sys:\n    def __init__(self, num_colors) -> None:\n        self.num_colors = num_colors\n        colors = []\n        for i in np.arange(0.0, 360.0, 360.0 / num_colors):\n            hue = i / 360.0\n            lightness = (50 + np.random.rand() * 10) / 100.0\n            saturation = (90 + np.random.rand() * 10) / 100.0\n            colors.append(\n                tuple([int(j * 255) for j in colorsys.hls_to_rgb(hue, lightness, saturation)])\n            )\n        self.colors = colors\n\n    def __call__(self, idx):\n        return self.colors[idx]", "\n\ndef inverse_sigmoid(x, eps=1e-3):\n    x = x.clamp(min=0, max=1)\n    x1 = x.clamp(min=eps)\n    x2 = (1 - x).clamp(min=eps)\n    return torch.log(x1 / x2)\n\n\ndef clean_state_dict(state_dict):\n    new_state_dict = OrderedDict()\n    for k, v in state_dict.items():\n        if k[:7] == \"module.\":\n            k = k[7:]  # remove `module.`\n        new_state_dict[k] = v\n    return new_state_dict", "\ndef clean_state_dict(state_dict):\n    new_state_dict = OrderedDict()\n    for k, v in state_dict.items():\n        if k[:7] == \"module.\":\n            k = k[7:]  # remove `module.`\n        new_state_dict[k] = v\n    return new_state_dict\n", ""]}
{"filename": "local_groundingdino/models/registry.py", "chunked_list": ["# ------------------------------------------------------------------------\n# Grounding DINO\n# url: https://github.com/IDEA-Research/GroundingDINO\n# Copyright (c) 2023 IDEA. All Rights Reserved.\n# Licensed under the Apache License, Version 2.0 [see LICENSE for details]\n# ------------------------------------------------------------------------\n# -*- coding: utf-8 -*-\n# @Author: Yihao Chen\n# @Date:   2021-08-16 16:03:17\n# @Last Modified by:   Shilong Liu", "# @Date:   2021-08-16 16:03:17\n# @Last Modified by:   Shilong Liu\n# @Last Modified time: 2022-01-23 15:26\n# modified from mmcv\n\nimport inspect\nfrom functools import partial\n\n\nclass Registry(object):\n    def __init__(self, name):\n        self._name = name\n        self._module_dict = dict()\n\n    def __repr__(self):\n        format_str = self.__class__.__name__ + \"(name={}, items={})\".format(\n            self._name, list(self._module_dict.keys())\n        )\n        return format_str\n\n    def __len__(self):\n        return len(self._module_dict)\n\n    @property\n    def name(self):\n        return self._name\n\n    @property\n    def module_dict(self):\n        return self._module_dict\n\n    def get(self, key):\n        return self._module_dict.get(key, None)\n\n    def registe_with_name(self, module_name=None, force=False):\n        return partial(self.register, module_name=module_name, force=force)\n\n    def register(self, module_build_function, module_name=None, force=False):\n        \"\"\"Register a module build function.\n        Args:\n            module (:obj:`nn.Module`): Module to be registered.\n        \"\"\"\n        if not inspect.isfunction(module_build_function):\n            raise TypeError(\n                \"module_build_function must be a function, but got {}\".format(\n                    type(module_build_function)\n                )\n            )\n        if module_name is None:\n            module_name = module_build_function.__name__\n        if not force and module_name in self._module_dict:\n            raise KeyError(\"{} is already registered in {}\".format(module_name, self.name))\n        self._module_dict[module_name] = module_build_function\n\n        return module_build_function", "\nclass Registry(object):\n    def __init__(self, name):\n        self._name = name\n        self._module_dict = dict()\n\n    def __repr__(self):\n        format_str = self.__class__.__name__ + \"(name={}, items={})\".format(\n            self._name, list(self._module_dict.keys())\n        )\n        return format_str\n\n    def __len__(self):\n        return len(self._module_dict)\n\n    @property\n    def name(self):\n        return self._name\n\n    @property\n    def module_dict(self):\n        return self._module_dict\n\n    def get(self, key):\n        return self._module_dict.get(key, None)\n\n    def registe_with_name(self, module_name=None, force=False):\n        return partial(self.register, module_name=module_name, force=force)\n\n    def register(self, module_build_function, module_name=None, force=False):\n        \"\"\"Register a module build function.\n        Args:\n            module (:obj:`nn.Module`): Module to be registered.\n        \"\"\"\n        if not inspect.isfunction(module_build_function):\n            raise TypeError(\n                \"module_build_function must be a function, but got {}\".format(\n                    type(module_build_function)\n                )\n            )\n        if module_name is None:\n            module_name = module_build_function.__name__\n        if not force and module_name in self._module_dict:\n            raise KeyError(\"{} is already registered in {}\".format(module_name, self.name))\n        self._module_dict[module_name] = module_build_function\n\n        return module_build_function", "\n\nMODULE_BUILD_FUNCS = Registry(\"model build functions\")\n"]}
{"filename": "local_groundingdino/models/__init__.py", "chunked_list": ["# ------------------------------------------------------------------------\n# Grounding DINO\n# url: https://github.com/IDEA-Research/GroundingDINO\n# Copyright (c) 2023 IDEA. All Rights Reserved.\n# Licensed under the Apache License, Version 2.0 [see LICENSE for details]\n# ------------------------------------------------------------------------\n# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved\nfrom .GroundingDINO import build_groundingdino\n\n\ndef build_model(args):\n    # we use register to maintain models from catdet6 on.\n    from .registry import MODULE_BUILD_FUNCS\n\n    assert args.modelname in MODULE_BUILD_FUNCS._module_dict\n    build_func = MODULE_BUILD_FUNCS.get(args.modelname)\n    model = build_func(args)\n    return model", "\n\ndef build_model(args):\n    # we use register to maintain models from catdet6 on.\n    from .registry import MODULE_BUILD_FUNCS\n\n    assert args.modelname in MODULE_BUILD_FUNCS._module_dict\n    build_func = MODULE_BUILD_FUNCS.get(args.modelname)\n    model = build_func(args)\n    return model", ""]}
{"filename": "local_groundingdino/models/GroundingDINO/ms_deform_attn.py", "chunked_list": ["# ------------------------------------------------------------------------\n# Grounding DINO\n# url: https://github.com/IDEA-Research/GroundingDINO\n# Copyright (c) 2023 IDEA. All Rights Reserved.\n# Licensed under the Apache License, Version 2.0 [see LICENSE for details]\n# ------------------------------------------------------------------------\n# Deformable DETR\n# Copyright (c) 2020 SenseTime. All Rights Reserved.\n# Licensed under the Apache License, Version 2.0 [see LICENSE for details]\n# ------------------------------------------------------------------------------------------------", "# Licensed under the Apache License, Version 2.0 [see LICENSE for details]\n# ------------------------------------------------------------------------------------------------\n# Modified from:\n# https://github.com/fundamentalvision/Deformable-DETR/blob/main/models/ops/functions/ms_deform_attn_func.py\n# https://github.com/fundamentalvision/Deformable-DETR/blob/main/models/ops/modules/ms_deform_attn.py\n# https://github.com/open-mmlab/mmcv/blob/master/mmcv/ops/multi_scale_deform_attn.py\n# ------------------------------------------------------------------------------------------------\n\nimport math\nimport warnings", "import math\nimport warnings\nfrom typing import Optional\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom torch.nn.init import constant_, xavier_uniform_\n\n", "\n\n# helpers\ndef _is_power_of_2(n):\n    if (not isinstance(n, int)) or (n < 0):\n        raise ValueError(\"invalid input for _is_power_of_2: {} (type: {})\".format(n, type(n)))\n    return (n & (n - 1) == 0) and n != 0\n\n\ndef multi_scale_deformable_attn_pytorch(\n    value: torch.Tensor,\n    value_spatial_shapes: torch.Tensor,\n    sampling_locations: torch.Tensor,\n    attention_weights: torch.Tensor,\n) -> torch.Tensor:\n\n    bs, _, num_heads, embed_dims = value.shape\n    _, num_queries, num_heads, num_levels, num_points, _ = sampling_locations.shape\n    value_list = value.split([H_ * W_ for H_, W_ in value_spatial_shapes], dim=1)\n    sampling_grids = 2 * sampling_locations - 1\n    sampling_value_list = []\n    for level, (H_, W_) in enumerate(value_spatial_shapes):\n        # bs, H_*W_, num_heads, embed_dims ->\n        # bs, H_*W_, num_heads*embed_dims ->\n        # bs, num_heads*embed_dims, H_*W_ ->\n        # bs*num_heads, embed_dims, H_, W_\n        value_l_ = (\n            value_list[level].flatten(2).transpose(1, 2).reshape(bs * num_heads, embed_dims, H_, W_)\n        )\n        # bs, num_queries, num_heads, num_points, 2 ->\n        # bs, num_heads, num_queries, num_points, 2 ->\n        # bs*num_heads, num_queries, num_points, 2\n        sampling_grid_l_ = sampling_grids[:, :, :, level].transpose(1, 2).flatten(0, 1)\n        # bs*num_heads, embed_dims, num_queries, num_points\n        sampling_value_l_ = F.grid_sample(\n            value_l_, sampling_grid_l_, mode=\"bilinear\", padding_mode=\"zeros\", align_corners=False\n        )\n        sampling_value_list.append(sampling_value_l_)\n    # (bs, num_queries, num_heads, num_levels, num_points) ->\n    # (bs, num_heads, num_queries, num_levels, num_points) ->\n    # (bs, num_heads, 1, num_queries, num_levels*num_points)\n    attention_weights = attention_weights.transpose(1, 2).reshape(\n        bs * num_heads, 1, num_queries, num_levels * num_points\n    )\n    output = (\n        (torch.stack(sampling_value_list, dim=-2).flatten(-2) * attention_weights)\n        .sum(-1)\n        .view(bs, num_heads * embed_dims, num_queries)\n    )\n    return output.transpose(1, 2).contiguous()", "\ndef multi_scale_deformable_attn_pytorch(\n    value: torch.Tensor,\n    value_spatial_shapes: torch.Tensor,\n    sampling_locations: torch.Tensor,\n    attention_weights: torch.Tensor,\n) -> torch.Tensor:\n\n    bs, _, num_heads, embed_dims = value.shape\n    _, num_queries, num_heads, num_levels, num_points, _ = sampling_locations.shape\n    value_list = value.split([H_ * W_ for H_, W_ in value_spatial_shapes], dim=1)\n    sampling_grids = 2 * sampling_locations - 1\n    sampling_value_list = []\n    for level, (H_, W_) in enumerate(value_spatial_shapes):\n        # bs, H_*W_, num_heads, embed_dims ->\n        # bs, H_*W_, num_heads*embed_dims ->\n        # bs, num_heads*embed_dims, H_*W_ ->\n        # bs*num_heads, embed_dims, H_, W_\n        value_l_ = (\n            value_list[level].flatten(2).transpose(1, 2).reshape(bs * num_heads, embed_dims, H_, W_)\n        )\n        # bs, num_queries, num_heads, num_points, 2 ->\n        # bs, num_heads, num_queries, num_points, 2 ->\n        # bs*num_heads, num_queries, num_points, 2\n        sampling_grid_l_ = sampling_grids[:, :, :, level].transpose(1, 2).flatten(0, 1)\n        # bs*num_heads, embed_dims, num_queries, num_points\n        sampling_value_l_ = F.grid_sample(\n            value_l_, sampling_grid_l_, mode=\"bilinear\", padding_mode=\"zeros\", align_corners=False\n        )\n        sampling_value_list.append(sampling_value_l_)\n    # (bs, num_queries, num_heads, num_levels, num_points) ->\n    # (bs, num_heads, num_queries, num_levels, num_points) ->\n    # (bs, num_heads, 1, num_queries, num_levels*num_points)\n    attention_weights = attention_weights.transpose(1, 2).reshape(\n        bs * num_heads, 1, num_queries, num_levels * num_points\n    )\n    output = (\n        (torch.stack(sampling_value_list, dim=-2).flatten(-2) * attention_weights)\n        .sum(-1)\n        .view(bs, num_heads * embed_dims, num_queries)\n    )\n    return output.transpose(1, 2).contiguous()", "\n\nclass MultiScaleDeformableAttention(nn.Module):\n    \"\"\"Multi-Scale Deformable Attention Module used in Deformable-DETR\n\n    `Deformable DETR: Deformable Transformers for End-to-End Object Detection.\n    <https://arxiv.org/pdf/2010.04159.pdf>`_.\n\n    Args:\n        embed_dim (int): The embedding dimension of Attention. Default: 256.\n        num_heads (int): The number of attention heads. Default: 8.\n        num_levels (int): The number of feature map used in Attention. Default: 4.\n        num_points (int): The number of sampling points for each query\n            in each head. Default: 4.\n        img2col_steps (int): The step used in image_to_column. Defualt: 64.\n            dropout (float): Dropout layer used in output. Default: 0.1.\n        batch_first (bool): if ``True``, then the input and output tensor will be\n            provided as `(bs, n, embed_dim)`. Default: False. `(n, bs, embed_dim)`\n    \"\"\"\n\n    def __init__(\n        self,\n        embed_dim: int = 256,\n        num_heads: int = 8,\n        num_levels: int = 4,\n        num_points: int = 4,\n        img2col_step: int = 64,\n        batch_first: bool = False,\n    ):\n        super().__init__()\n        if embed_dim % num_heads != 0:\n            raise ValueError(\n                \"embed_dim must be divisible by num_heads, but got {} and {}\".format(\n                    embed_dim, num_heads\n                )\n            )\n        head_dim = embed_dim // num_heads\n\n        self.batch_first = batch_first\n\n        if not _is_power_of_2(head_dim):\n            warnings.warn(\n                \"\"\"\n                You'd better set d_model in MSDeformAttn to make sure that\n                each dim of the attention head a power of 2, which is more efficient.\n                \"\"\"\n            )\n\n        self.im2col_step = img2col_step\n        self.embed_dim = embed_dim\n        self.num_heads = num_heads\n        self.num_levels = num_levels\n        self.num_points = num_points\n        self.sampling_offsets = nn.Linear(embed_dim, num_heads * num_levels * num_points * 2)\n        self.attention_weights = nn.Linear(embed_dim, num_heads * num_levels * num_points)\n        self.value_proj = nn.Linear(embed_dim, embed_dim)\n        self.output_proj = nn.Linear(embed_dim, embed_dim)\n\n        self.init_weights()\n\n    def _reset_parameters(self):\n        return self.init_weights()\n\n    def init_weights(self):\n        \"\"\"\n        Default initialization for Parameters of Module.\n        \"\"\"\n        constant_(self.sampling_offsets.weight.data, 0.0)\n        thetas = torch.arange(self.num_heads, dtype=torch.float32) * (\n            2.0 * math.pi / self.num_heads\n        )\n        grid_init = torch.stack([thetas.cos(), thetas.sin()], -1)\n        grid_init = (\n            (grid_init / grid_init.abs().max(-1, keepdim=True)[0])\n            .view(self.num_heads, 1, 1, 2)\n            .repeat(1, self.num_levels, self.num_points, 1)\n        )\n        for i in range(self.num_points):\n            grid_init[:, :, i, :] *= i + 1\n        with torch.no_grad():\n            self.sampling_offsets.bias = nn.Parameter(grid_init.view(-1))\n        constant_(self.attention_weights.weight.data, 0.0)\n        constant_(self.attention_weights.bias.data, 0.0)\n        xavier_uniform_(self.value_proj.weight.data)\n        constant_(self.value_proj.bias.data, 0.0)\n        xavier_uniform_(self.output_proj.weight.data)\n        constant_(self.output_proj.bias.data, 0.0)\n\n    def freeze_sampling_offsets(self):\n        print(\"Freeze sampling offsets\")\n        self.sampling_offsets.weight.requires_grad = False\n        self.sampling_offsets.bias.requires_grad = False\n\n    def freeze_attention_weights(self):\n        print(\"Freeze attention weights\")\n        self.attention_weights.weight.requires_grad = False\n        self.attention_weights.bias.requires_grad = False\n\n    def forward(\n        self,\n        query: torch.Tensor,\n        key: Optional[torch.Tensor] = None,\n        value: Optional[torch.Tensor] = None,\n        query_pos: Optional[torch.Tensor] = None,\n        key_padding_mask: Optional[torch.Tensor] = None,\n        reference_points: Optional[torch.Tensor] = None,\n        spatial_shapes: Optional[torch.Tensor] = None,\n        level_start_index: Optional[torch.Tensor] = None,\n        **kwargs\n    ) -> torch.Tensor:\n\n        \"\"\"Forward Function of MultiScaleDeformableAttention\n\n        Args:\n            query (torch.Tensor): Query embeddings with shape\n                `(num_query, bs, embed_dim)`\n            key (torch.Tensor): Key embeddings with shape\n                `(num_key, bs, embed_dim)`\n            value (torch.Tensor): Value embeddings with shape\n                `(num_key, bs, embed_dim)`\n            query_pos (torch.Tensor): The position embedding for `query`. Default: None.\n            key_padding_mask (torch.Tensor): ByteTensor for `query`, with shape `(bs, num_key)`,\n                indicating which elements within `key` to be ignored in attention.\n            reference_points (torch.Tensor): The normalized reference points\n                with shape `(bs, num_query, num_levels, 2)`,\n                all elements is range in [0, 1], top-left (0, 0),\n                bottom-right (1, 1), including padding are.\n                or `(N, Length_{query}, num_levels, 4)`, add additional\n                two dimensions `(h, w)` to form reference boxes.\n            spatial_shapes (torch.Tensor): Spatial shape of features in different levels.\n                With shape `(num_levels, 2)`, last dimension represents `(h, w)`.\n            level_start_index (torch.Tensor): The start index of each level. A tensor with\n                shape `(num_levels, )` which can be represented as\n                `[0, h_0 * w_0, h_0 * w_0 + h_1 * w_1, ...]`.\n\n        Returns:\n            torch.Tensor: forward results with shape `(num_query, bs, embed_dim)`\n        \"\"\"\n\n        if value is None:\n            value = query\n\n        if query_pos is not None:\n            query = query + query_pos\n\n        if not self.batch_first:\n            # change to (bs, num_query ,embed_dims)\n            query = query.permute(1, 0, 2)\n            value = value.permute(1, 0, 2)\n\n        bs, num_query, _ = query.shape\n        bs, num_value, _ = value.shape\n\n        assert (spatial_shapes[:, 0] * spatial_shapes[:, 1]).sum() == num_value\n\n        value = self.value_proj(value)\n        if key_padding_mask is not None:\n            value = value.masked_fill(key_padding_mask[..., None], float(0))\n        value = value.view(bs, num_value, self.num_heads, -1)\n        sampling_offsets = self.sampling_offsets(query).view(\n            bs, num_query, self.num_heads, self.num_levels, self.num_points, 2\n        )\n        attention_weights = self.attention_weights(query).view(\n            bs, num_query, self.num_heads, self.num_levels * self.num_points\n        )\n        attention_weights = attention_weights.softmax(-1)\n        attention_weights = attention_weights.view(\n            bs,\n            num_query,\n            self.num_heads,\n            self.num_levels,\n            self.num_points,\n        )\n\n        # bs, num_query, num_heads, num_levels, num_points, 2\n        if reference_points.shape[-1] == 2:\n            offset_normalizer = torch.stack([spatial_shapes[..., 1], spatial_shapes[..., 0]], -1)\n            sampling_locations = (\n                reference_points[:, :, None, :, None, :]\n                + sampling_offsets / offset_normalizer[None, None, None, :, None, :]\n            )\n        elif reference_points.shape[-1] == 4:\n            sampling_locations = (\n                reference_points[:, :, None, :, None, :2]\n                + sampling_offsets\n                / self.num_points\n                * reference_points[:, :, None, :, None, 2:]\n                * 0.5\n            )\n        else:\n            raise ValueError(\n                \"Last dim of reference_points must be 2 or 4, but get {} instead.\".format(\n                    reference_points.shape[-1]\n                )\n            )\n\n        output = multi_scale_deformable_attn_pytorch(\n            value, spatial_shapes, sampling_locations, attention_weights\n        )\n\n        output = self.output_proj(output)\n\n        if not self.batch_first:\n            output = output.permute(1, 0, 2)\n\n        return output", "\n\ndef create_dummy_class(klass, dependency, message=\"\"):\n    \"\"\"\n    When a dependency of a class is not available, create a dummy class which throws ImportError\n    when used.\n\n    Args:\n        klass (str): name of the class.\n        dependency (str): name of the dependency.\n        message: extra message to print\n    Returns:\n        class: a class object\n    \"\"\"\n    err = \"Cannot import '{}', therefore '{}' is not available.\".format(dependency, klass)\n    if message:\n        err = err + \" \" + message\n\n    class _DummyMetaClass(type):\n        # throw error on class attribute access\n        def __getattr__(_, __):  # noqa: B902\n            raise ImportError(err)\n\n    class _Dummy(object, metaclass=_DummyMetaClass):\n        # throw error on constructor\n        def __init__(self, *args, **kwargs):\n            raise ImportError(err)\n\n    return _Dummy", "\n\ndef create_dummy_func(func, dependency, message=\"\"):\n    \"\"\"\n    When a dependency of a function is not available, create a dummy function which throws\n    ImportError when used.\n\n    Args:\n        func (str): name of the function.\n        dependency (str or list[str]): name(s) of the dependency.\n        message: extra message to print\n    Returns:\n        function: a function object\n    \"\"\"\n    err = \"Cannot import '{}', therefore '{}' is not available.\".format(dependency, func)\n    if message:\n        err = err + \" \" + message\n\n    if isinstance(dependency, (list, tuple)):\n        dependency = \",\".join(dependency)\n\n    def _dummy(*args, **kwargs):\n        raise ImportError(err)\n\n    return _dummy", ""]}
{"filename": "local_groundingdino/models/GroundingDINO/transformer_vanilla.py", "chunked_list": ["# ------------------------------------------------------------------------\n# Grounding DINO\n# url: https://github.com/IDEA-Research/GroundingDINO\n# Copyright (c) 2023 IDEA. All Rights Reserved.\n# Licensed under the Apache License, Version 2.0 [see LICENSE for details]\n# ------------------------------------------------------------------------\n# Copyright (c) Aishwarya Kamath & Nicolas Carion. Licensed under the Apache License 2.0. All Rights Reserved\n# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved\n\"\"\"\nDETR Transformer class.", "\"\"\"\nDETR Transformer class.\n\nCopy-paste from torch.nn.Transformer with modifications:\n    * positional encodings are passed in MHattention\n    * extra LN at the end of encoder is removed\n    * decoder returns a stack of activations from all decoding layers\n\"\"\"\nfrom typing import Optional\n", "from typing import Optional\n\nimport torch\nfrom torch import Tensor, nn\n\nfrom .utils import (\n    _get_activation_fn,\n    _get_clones,\n)\n", ")\n\n\nclass TextTransformer(nn.Module):\n    def __init__(self, num_layers, d_model=256, nheads=8, dim_feedforward=2048, dropout=0.1):\n        super().__init__()\n        self.num_layers = num_layers\n        self.d_model = d_model\n        self.nheads = nheads\n        self.dim_feedforward = dim_feedforward\n        self.norm = None\n\n        single_encoder_layer = TransformerEncoderLayer(\n            d_model=d_model, nhead=nheads, dim_feedforward=dim_feedforward, dropout=dropout\n        )\n        self.layers = _get_clones(single_encoder_layer, num_layers)\n\n    def forward(self, memory_text: torch.Tensor, text_attention_mask: torch.Tensor):\n        \"\"\"\n\n        Args:\n            text_attention_mask: bs, num_token\n            memory_text: bs, num_token, d_model\n\n        Raises:\n            RuntimeError: _description_\n\n        Returns:\n            output: bs, num_token, d_model\n        \"\"\"\n\n        output = memory_text.transpose(0, 1)\n\n        for layer in self.layers:\n            output = layer(output, src_key_padding_mask=text_attention_mask)\n\n        if self.norm is not None:\n            output = self.norm(output)\n\n        return output.transpose(0, 1)", "\n\nclass TransformerEncoderLayer(nn.Module):\n    def __init__(\n        self,\n        d_model,\n        nhead,\n        dim_feedforward=2048,\n        dropout=0.1,\n        activation=\"relu\",\n        normalize_before=False,\n    ):\n        super().__init__()\n        self.self_attn = nn.MultiheadAttention(d_model, nhead, dropout=dropout)\n        # Implementation of Feedforward model\n        self.linear1 = nn.Linear(d_model, dim_feedforward)\n        self.dropout = nn.Dropout(dropout)\n        self.linear2 = nn.Linear(dim_feedforward, d_model)\n\n        self.norm1 = nn.LayerNorm(d_model)\n        self.norm2 = nn.LayerNorm(d_model)\n        self.dropout1 = nn.Dropout(dropout)\n        self.dropout2 = nn.Dropout(dropout)\n\n        self.activation = _get_activation_fn(activation)\n        self.normalize_before = normalize_before\n        self.nhead = nhead\n\n    def with_pos_embed(self, tensor, pos: Optional[Tensor]):\n        return tensor if pos is None else tensor + pos\n\n    def forward(\n        self,\n        src,\n        src_mask: Optional[Tensor] = None,\n        src_key_padding_mask: Optional[Tensor] = None,\n        pos: Optional[Tensor] = None,\n    ):\n        # repeat attn mask\n        if src_mask.dim() == 3 and src_mask.shape[0] == src.shape[1]:\n            # bs, num_q, num_k\n            src_mask = src_mask.repeat(self.nhead, 1, 1)\n\n        q = k = self.with_pos_embed(src, pos)\n\n        src2 = self.self_attn(q, k, value=src, attn_mask=src_mask)[0]\n\n        # src2 = self.self_attn(q, k, value=src, attn_mask=src_mask, key_padding_mask=src_key_padding_mask)[0]\n        src = src + self.dropout1(src2)\n        src = self.norm1(src)\n        src2 = self.linear2(self.dropout(self.activation(self.linear1(src))))\n        src = src + self.dropout2(src2)\n        src = self.norm2(src)\n        return src", ""]}
{"filename": "local_groundingdino/models/GroundingDINO/bertwarper.py", "chunked_list": ["# ------------------------------------------------------------------------\n# Grounding DINO\n# url: https://github.com/IDEA-Research/GroundingDINO\n# Copyright (c) 2023 IDEA. All Rights Reserved.\n# Licensed under the Apache License, Version 2.0 [see LICENSE for details]\n# ------------------------------------------------------------------------\n\nimport torch\nfrom torch import nn\nfrom transformers.modeling_outputs import BaseModelOutputWithPoolingAndCrossAttentions", "from torch import nn\nfrom transformers.modeling_outputs import BaseModelOutputWithPoolingAndCrossAttentions\n\n\nclass BertModelWarper(nn.Module):\n    def __init__(self, bert_model):\n        super().__init__()\n        # self.bert = bert_modelc\n\n        self.config = bert_model.config\n        self.embeddings = bert_model.embeddings\n        self.encoder = bert_model.encoder\n        self.pooler = bert_model.pooler\n\n        self.get_extended_attention_mask = bert_model.get_extended_attention_mask\n        self.invert_attention_mask = bert_model.invert_attention_mask\n        self.get_head_mask = bert_model.get_head_mask\n\n    def forward(\n        self,\n        input_ids=None,\n        attention_mask=None,\n        token_type_ids=None,\n        position_ids=None,\n        head_mask=None,\n        inputs_embeds=None,\n        encoder_hidden_states=None,\n        encoder_attention_mask=None,\n        past_key_values=None,\n        use_cache=None,\n        output_attentions=None,\n        output_hidden_states=None,\n        return_dict=None,\n    ):\n        r\"\"\"\n        encoder_hidden_states  (:obj:`torch.FloatTensor` of shape :obj:`(batch_size, sequence_length, hidden_size)`, `optional`):\n            Sequence of hidden-states at the output of the last layer of the encoder. Used in the cross-attention if\n            the model is configured as a decoder.\n        encoder_attention_mask (:obj:`torch.FloatTensor` of shape :obj:`(batch_size, sequence_length)`, `optional`):\n            Mask to avoid performing attention on the padding token indices of the encoder input. This mask is used in\n            the cross-attention if the model is configured as a decoder. Mask values selected in ``[0, 1]``:\n\n            - 1 for tokens that are **not masked**,\n            - 0 for tokens that are **masked**.\n        past_key_values (:obj:`tuple(tuple(torch.FloatTensor))` of length :obj:`config.n_layers` with each tuple having 4 tensors of shape :obj:`(batch_size, num_heads, sequence_length - 1, embed_size_per_head)`):\n            Contains precomputed key and value hidden states of the attention blocks. Can be used to speed up decoding.\n\n            If :obj:`past_key_values` are used, the user can optionally input only the last :obj:`decoder_input_ids`\n            (those that don't have their past key value states given to this model) of shape :obj:`(batch_size, 1)`\n            instead of all :obj:`decoder_input_ids` of shape :obj:`(batch_size, sequence_length)`.\n        use_cache (:obj:`bool`, `optional`):\n            If set to :obj:`True`, :obj:`past_key_values` key value states are returned and can be used to speed up\n            decoding (see :obj:`past_key_values`).\n        \"\"\"\n        output_attentions = (\n            output_attentions if output_attentions is not None else self.config.output_attentions\n        )\n        output_hidden_states = (\n            output_hidden_states\n            if output_hidden_states is not None\n            else self.config.output_hidden_states\n        )\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n\n        if self.config.is_decoder:\n            use_cache = use_cache if use_cache is not None else self.config.use_cache\n        else:\n            use_cache = False\n\n        if input_ids is not None and inputs_embeds is not None:\n            raise ValueError(\"You cannot specify both input_ids and inputs_embeds at the same time\")\n        elif input_ids is not None:\n            input_shape = input_ids.size()\n            batch_size, seq_length = input_shape\n        elif inputs_embeds is not None:\n            input_shape = inputs_embeds.size()[:-1]\n            batch_size, seq_length = input_shape\n        else:\n            raise ValueError(\"You have to specify either input_ids or inputs_embeds\")\n\n        device = input_ids.device if input_ids is not None else inputs_embeds.device\n\n        # past_key_values_length\n        past_key_values_length = (\n            past_key_values[0][0].shape[2] if past_key_values is not None else 0\n        )\n\n        if attention_mask is None:\n            attention_mask = torch.ones(\n                ((batch_size, seq_length + past_key_values_length)), device=device\n            )\n        if token_type_ids is None:\n            token_type_ids = torch.zeros(input_shape, dtype=torch.long, device=device)\n\n        # We can provide a self-attention mask of dimensions [batch_size, from_seq_length, to_seq_length]\n        # ourselves in which case we just need to make it broadcastable to all heads.\n        extended_attention_mask: torch.Tensor = self.get_extended_attention_mask(\n            attention_mask, input_shape, device\n        )\n\n        # If a 2D or 3D attention mask is provided for the cross-attention\n        # we need to make broadcastable to [batch_size, num_heads, seq_length, seq_length]\n        if self.config.is_decoder and encoder_hidden_states is not None:\n            encoder_batch_size, encoder_sequence_length, _ = encoder_hidden_states.size()\n            encoder_hidden_shape = (encoder_batch_size, encoder_sequence_length)\n            if encoder_attention_mask is None:\n                encoder_attention_mask = torch.ones(encoder_hidden_shape, device=device)\n            encoder_extended_attention_mask = self.invert_attention_mask(encoder_attention_mask)\n        else:\n            encoder_extended_attention_mask = None\n        # if os.environ.get('IPDB_SHILONG_DEBUG', None) == 'INFO':\n        #     import ipdb; ipdb.set_trace()\n\n        # Prepare head mask if needed\n        # 1.0 in head_mask indicate we keep the head\n        # attention_probs has shape bsz x n_heads x N x N\n        # input head_mask has shape [num_heads] or [num_hidden_layers x num_heads]\n        # and head_mask is converted to shape [num_hidden_layers x batch x num_heads x seq_length x seq_length]\n        head_mask = self.get_head_mask(head_mask, self.config.num_hidden_layers)\n\n        embedding_output = self.embeddings(\n            input_ids=input_ids,\n            position_ids=position_ids,\n            token_type_ids=token_type_ids,\n            inputs_embeds=inputs_embeds,\n            past_key_values_length=past_key_values_length,\n        )\n\n        encoder_outputs = self.encoder(\n            embedding_output,\n            attention_mask=extended_attention_mask,\n            head_mask=head_mask,\n            encoder_hidden_states=encoder_hidden_states,\n            encoder_attention_mask=encoder_extended_attention_mask,\n            past_key_values=past_key_values,\n            use_cache=use_cache,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n        )\n        sequence_output = encoder_outputs[0]\n        pooled_output = self.pooler(sequence_output) if self.pooler is not None else None\n\n        if not return_dict:\n            return (sequence_output, pooled_output) + encoder_outputs[1:]\n\n        return BaseModelOutputWithPoolingAndCrossAttentions(\n            last_hidden_state=sequence_output,\n            pooler_output=pooled_output,\n            past_key_values=encoder_outputs.past_key_values,\n            hidden_states=encoder_outputs.hidden_states,\n            attentions=encoder_outputs.attentions,\n            cross_attentions=encoder_outputs.cross_attentions,\n        )", "\n\nclass TextEncoderShell(nn.Module):\n    def __init__(self, text_encoder):\n        super().__init__()\n        self.text_encoder = text_encoder\n        self.config = self.text_encoder.config\n\n    def forward(self, **kw):\n        # feed into text encoder\n        return self.text_encoder(**kw)", "\n\ndef generate_masks_with_special_tokens(tokenized, special_tokens_list, tokenizer):\n    \"\"\"Generate attention mask between each pair of special tokens\n    Args:\n        input_ids (torch.Tensor): input ids. Shape: [bs, num_token]\n        special_tokens_mask (list): special tokens mask.\n    Returns:\n        torch.Tensor: attention mask between each special tokens.\n    \"\"\"\n    input_ids = tokenized[\"input_ids\"]\n    bs, num_token = input_ids.shape\n    # special_tokens_mask: bs, num_token. 1 for special tokens. 0 for normal tokens\n    special_tokens_mask = torch.zeros((bs, num_token), device=input_ids.device).bool()\n    for special_token in special_tokens_list:\n        special_tokens_mask |= input_ids == special_token\n\n    # idxs: each row is a list of indices of special tokens\n    idxs = torch.nonzero(special_tokens_mask)\n\n    # generate attention mask and positional ids\n    attention_mask = (\n        torch.eye(num_token, device=input_ids.device).bool().unsqueeze(0).repeat(bs, 1, 1)\n    )\n    position_ids = torch.zeros((bs, num_token), device=input_ids.device)\n    previous_col = 0\n    for i in range(idxs.shape[0]):\n        row, col = idxs[i]\n        if (col == 0) or (col == num_token - 1):\n            attention_mask[row, col, col] = True\n            position_ids[row, col] = 0\n        else:\n            attention_mask[row, previous_col + 1 : col + 1, previous_col + 1 : col + 1] = True\n            position_ids[row, previous_col + 1 : col + 1] = torch.arange(\n                0, col - previous_col, device=input_ids.device\n            )\n\n        previous_col = col\n\n    # # padding mask\n    # padding_mask = tokenized['attention_mask']\n    # attention_mask = attention_mask & padding_mask.unsqueeze(1).bool() & padding_mask.unsqueeze(2).bool()\n\n    return attention_mask, position_ids.to(torch.long)", "\n\ndef generate_masks_with_special_tokens_and_transfer_map(tokenized, special_tokens_list, tokenizer):\n    \"\"\"Generate attention mask between each pair of special tokens\n    Args:\n        input_ids (torch.Tensor): input ids. Shape: [bs, num_token]\n        special_tokens_mask (list): special tokens mask.\n    Returns:\n        torch.Tensor: attention mask between each special tokens.\n    \"\"\"\n    input_ids = tokenized[\"input_ids\"]\n    bs, num_token = input_ids.shape\n    # special_tokens_mask: bs, num_token. 1 for special tokens. 0 for normal tokens\n    special_tokens_mask = torch.zeros((bs, num_token), device=input_ids.device).bool()\n    for special_token in special_tokens_list:\n        special_tokens_mask |= input_ids == special_token\n\n    # idxs: each row is a list of indices of special tokens\n    idxs = torch.nonzero(special_tokens_mask)\n\n    # generate attention mask and positional ids\n    attention_mask = (\n        torch.eye(num_token, device=input_ids.device).bool().unsqueeze(0).repeat(bs, 1, 1)\n    )\n    position_ids = torch.zeros((bs, num_token), device=input_ids.device)\n    cate_to_token_mask_list = [[] for _ in range(bs)]\n    previous_col = 0\n    for i in range(idxs.shape[0]):\n        row, col = idxs[i]\n        if (col == 0) or (col == num_token - 1):\n            attention_mask[row, col, col] = True\n            position_ids[row, col] = 0\n        else:\n            attention_mask[row, previous_col + 1 : col + 1, previous_col + 1 : col + 1] = True\n            position_ids[row, previous_col + 1 : col + 1] = torch.arange(\n                0, col - previous_col, device=input_ids.device\n            )\n            c2t_maski = torch.zeros((num_token), device=input_ids.device).bool()\n            c2t_maski[previous_col + 1 : col] = True\n            cate_to_token_mask_list[row].append(c2t_maski)\n        previous_col = col\n\n    cate_to_token_mask_list = [\n        torch.stack(cate_to_token_mask_listi, dim=0)\n        for cate_to_token_mask_listi in cate_to_token_mask_list\n    ]\n\n    # # padding mask\n    # padding_mask = tokenized['attention_mask']\n    # attention_mask = attention_mask & padding_mask.unsqueeze(1).bool() & padding_mask.unsqueeze(2).bool()\n\n    return attention_mask, position_ids.to(torch.long), cate_to_token_mask_list", ""]}
{"filename": "local_groundingdino/models/GroundingDINO/transformer.py", "chunked_list": ["# ------------------------------------------------------------------------\n# Grounding DINO\n# url: https://github.com/IDEA-Research/GroundingDINO\n# Copyright (c) 2023 IDEA. All Rights Reserved.\n# Licensed under the Apache License, Version 2.0 [see LICENSE for details]\n# ------------------------------------------------------------------------\n# DINO\n# Copyright (c) 2022 IDEA. All Rights Reserved.\n# Licensed under the Apache License, Version 2.0 [see LICENSE for details]\n# ------------------------------------------------------------------------", "# Licensed under the Apache License, Version 2.0 [see LICENSE for details]\n# ------------------------------------------------------------------------\n# Conditional DETR Transformer class.\n# Copyright (c) 2021 Microsoft. All Rights Reserved.\n# Licensed under the Apache License, Version 2.0 [see LICENSE for details]\n# ------------------------------------------------------------------------\n# Modified from DETR (https://github.com/facebookresearch/detr)\n# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n# ------------------------------------------------------------------------\n", "# ------------------------------------------------------------------------\n\nfrom typing import Optional\n\nimport torch\nimport torch.utils.checkpoint as checkpoint\nfrom torch import Tensor, nn\n\nfrom local_groundingdino.util.misc import inverse_sigmoid\n", "from local_groundingdino.util.misc import inverse_sigmoid\n\nfrom .fuse_modules import BiAttentionBlock\nfrom .ms_deform_attn import MultiScaleDeformableAttention as MSDeformAttn\nfrom .transformer_vanilla import TransformerEncoderLayer\nfrom .utils import (\n    MLP,\n    _get_activation_fn,\n    _get_clones,\n    gen_encoder_output_proposals,", "    _get_clones,\n    gen_encoder_output_proposals,\n    gen_sineembed_for_position,\n    get_sine_pos_embed,\n)\n\n\nclass Transformer(nn.Module):\n    def __init__(\n        self,\n        d_model=256,\n        nhead=8,\n        num_queries=300,\n        num_encoder_layers=6,\n        num_unicoder_layers=0,\n        num_decoder_layers=6,\n        dim_feedforward=2048,\n        dropout=0.0,\n        activation=\"relu\",\n        normalize_before=False,\n        return_intermediate_dec=False,\n        query_dim=4,\n        num_patterns=0,\n        # for deformable encoder\n        num_feature_levels=1,\n        enc_n_points=4,\n        dec_n_points=4,\n        # init query\n        learnable_tgt_init=False,\n        # two stage\n        two_stage_type=\"no\",  # ['no', 'standard', 'early', 'combine', 'enceachlayer', 'enclayer1']\n        embed_init_tgt=False,\n        # for text\n        use_text_enhancer=False,\n        use_fusion_layer=False,\n        use_checkpoint=False,\n        use_transformer_ckpt=False,\n        use_text_cross_attention=False,\n        text_dropout=0.1,\n        fusion_dropout=0.1,\n        fusion_droppath=0.0,\n    ):\n        super().__init__()\n        self.num_feature_levels = num_feature_levels\n        self.num_encoder_layers = num_encoder_layers\n        self.num_unicoder_layers = num_unicoder_layers\n        self.num_decoder_layers = num_decoder_layers\n        self.num_queries = num_queries\n        assert query_dim == 4\n\n        # choose encoder layer type\n        encoder_layer = DeformableTransformerEncoderLayer(\n            d_model, dim_feedforward, dropout, activation, num_feature_levels, nhead, enc_n_points\n        )\n\n        if use_text_enhancer:\n            text_enhance_layer = TransformerEncoderLayer(\n                d_model=d_model,\n                nhead=nhead // 2,\n                dim_feedforward=dim_feedforward // 2,\n                dropout=text_dropout,\n            )\n        else:\n            text_enhance_layer = None\n\n        if use_fusion_layer:\n            feature_fusion_layer = BiAttentionBlock(\n                v_dim=d_model,\n                l_dim=d_model,\n                embed_dim=dim_feedforward // 2,\n                num_heads=nhead // 2,\n                dropout=fusion_dropout,\n                drop_path=fusion_droppath,\n            )\n        else:\n            feature_fusion_layer = None\n\n        encoder_norm = nn.LayerNorm(d_model) if normalize_before else None\n        assert encoder_norm is None\n        self.encoder = TransformerEncoder(\n            encoder_layer,\n            num_encoder_layers,\n            d_model=d_model,\n            num_queries=num_queries,\n            text_enhance_layer=text_enhance_layer,\n            feature_fusion_layer=feature_fusion_layer,\n            use_checkpoint=use_checkpoint,\n            use_transformer_ckpt=use_transformer_ckpt,\n        )\n\n        # choose decoder layer type\n        decoder_layer = DeformableTransformerDecoderLayer(\n            d_model,\n            dim_feedforward,\n            dropout,\n            activation,\n            num_feature_levels,\n            nhead,\n            dec_n_points,\n            use_text_cross_attention=use_text_cross_attention,\n        )\n\n        decoder_norm = nn.LayerNorm(d_model)\n        self.decoder = TransformerDecoder(\n            decoder_layer,\n            num_decoder_layers,\n            decoder_norm,\n            return_intermediate=return_intermediate_dec,\n            d_model=d_model,\n            query_dim=query_dim,\n            num_feature_levels=num_feature_levels,\n        )\n\n        self.d_model = d_model\n        self.nhead = nhead\n        self.dec_layers = num_decoder_layers\n        self.num_queries = num_queries  # useful for single stage model only\n        self.num_patterns = num_patterns\n        if not isinstance(num_patterns, int):\n            Warning(\"num_patterns should be int but {}\".format(type(num_patterns)))\n            self.num_patterns = 0\n\n        if num_feature_levels > 1:\n            if self.num_encoder_layers > 0:\n                self.level_embed = nn.Parameter(torch.Tensor(num_feature_levels, d_model))\n            else:\n                self.level_embed = None\n\n        self.learnable_tgt_init = learnable_tgt_init\n        assert learnable_tgt_init, \"why not learnable_tgt_init\"\n        self.embed_init_tgt = embed_init_tgt\n        if (two_stage_type != \"no\" and embed_init_tgt) or (two_stage_type == \"no\"):\n            self.tgt_embed = nn.Embedding(self.num_queries, d_model)\n            nn.init.normal_(self.tgt_embed.weight.data)\n        else:\n            self.tgt_embed = None\n\n        # for two stage\n        self.two_stage_type = two_stage_type\n        assert two_stage_type in [\"no\", \"standard\"], \"unknown param {} of two_stage_type\".format(\n            two_stage_type\n        )\n        if two_stage_type == \"standard\":\n            # anchor selection at the output of encoder\n            self.enc_output = nn.Linear(d_model, d_model)\n            self.enc_output_norm = nn.LayerNorm(d_model)\n            self.two_stage_wh_embedding = None\n\n        if two_stage_type == \"no\":\n            self.init_ref_points(num_queries)  # init self.refpoint_embed\n\n        self.enc_out_class_embed = None\n        self.enc_out_bbox_embed = None\n\n        self._reset_parameters()\n\n    def _reset_parameters(self):\n        for p in self.parameters():\n            if p.dim() > 1:\n                nn.init.xavier_uniform_(p)\n        for m in self.modules():\n            if isinstance(m, MSDeformAttn):\n                m._reset_parameters()\n        if self.num_feature_levels > 1 and self.level_embed is not None:\n            nn.init.normal_(self.level_embed)\n\n    def get_valid_ratio(self, mask):\n        _, H, W = mask.shape\n        valid_H = torch.sum(~mask[:, :, 0], 1)\n        valid_W = torch.sum(~mask[:, 0, :], 1)\n        valid_ratio_h = valid_H.float() / H\n        valid_ratio_w = valid_W.float() / W\n        valid_ratio = torch.stack([valid_ratio_w, valid_ratio_h], -1)\n        return valid_ratio\n\n    def init_ref_points(self, use_num_queries):\n        self.refpoint_embed = nn.Embedding(use_num_queries, 4)\n\n    def forward(self, srcs, masks, refpoint_embed, pos_embeds, tgt, attn_mask=None, text_dict=None):\n        \"\"\"\n        Input:\n            - srcs: List of multi features [bs, ci, hi, wi]\n            - masks: List of multi masks [bs, hi, wi]\n            - refpoint_embed: [bs, num_dn, 4]. None in infer\n            - pos_embeds: List of multi pos embeds [bs, ci, hi, wi]\n            - tgt: [bs, num_dn, d_model]. None in infer\n\n        \"\"\"\n        # prepare input for encoder\n        src_flatten = []\n        mask_flatten = []\n        lvl_pos_embed_flatten = []\n        spatial_shapes = []\n        for lvl, (src, mask, pos_embed) in enumerate(zip(srcs, masks, pos_embeds)):\n            bs, c, h, w = src.shape\n            spatial_shape = (h, w)\n            spatial_shapes.append(spatial_shape)\n\n            src = src.flatten(2).transpose(1, 2)  # bs, hw, c\n            mask = mask.flatten(1)  # bs, hw\n            pos_embed = pos_embed.flatten(2).transpose(1, 2)  # bs, hw, c\n            if self.num_feature_levels > 1 and self.level_embed is not None:\n                lvl_pos_embed = pos_embed + self.level_embed[lvl].view(1, 1, -1)\n            else:\n                lvl_pos_embed = pos_embed\n            lvl_pos_embed_flatten.append(lvl_pos_embed)\n            src_flatten.append(src)\n            mask_flatten.append(mask)\n        src_flatten = torch.cat(src_flatten, 1)  # bs, \\sum{hxw}, c\n        mask_flatten = torch.cat(mask_flatten, 1)  # bs, \\sum{hxw}\n        lvl_pos_embed_flatten = torch.cat(lvl_pos_embed_flatten, 1)  # bs, \\sum{hxw}, c\n        spatial_shapes = torch.as_tensor(\n            spatial_shapes, dtype=torch.long, device=src_flatten.device\n        )\n        level_start_index = torch.cat(\n            (spatial_shapes.new_zeros((1,)), spatial_shapes.prod(1).cumsum(0)[:-1])\n        )\n        valid_ratios = torch.stack([self.get_valid_ratio(m) for m in masks], 1)\n\n        # two stage\n        enc_topk_proposals = enc_refpoint_embed = None\n\n        #########################################################\n        # Begin Encoder\n        #########################################################\n        memory, memory_text = self.encoder(\n            src_flatten,\n            pos=lvl_pos_embed_flatten,\n            level_start_index=level_start_index,\n            spatial_shapes=spatial_shapes,\n            valid_ratios=valid_ratios,\n            key_padding_mask=mask_flatten,\n            memory_text=text_dict[\"encoded_text\"],\n            text_attention_mask=~text_dict[\"text_token_mask\"],\n            # we ~ the mask . False means use the token; True means pad the token\n            position_ids=text_dict[\"position_ids\"],\n            text_self_attention_masks=text_dict[\"text_self_attention_masks\"],\n        )\n        #########################################################\n        # End Encoder\n        # - memory: bs, \\sum{hw}, c\n        # - mask_flatten: bs, \\sum{hw}\n        # - lvl_pos_embed_flatten: bs, \\sum{hw}, c\n        # - enc_intermediate_output: None or (nenc+1, bs, nq, c) or (nenc, bs, nq, c)\n        # - enc_intermediate_refpoints: None or (nenc+1, bs, nq, c) or (nenc, bs, nq, c)\n        #########################################################\n        text_dict[\"encoded_text\"] = memory_text\n        # if os.environ.get(\"SHILONG_AMP_INFNAN_DEBUG\") == '1':\n        #     if memory.isnan().any() | memory.isinf().any():\n        #         import ipdb; ipdb.set_trace()\n\n        if self.two_stage_type == \"standard\":\n            output_memory, output_proposals = gen_encoder_output_proposals(\n                memory, mask_flatten, spatial_shapes\n            )\n            output_memory = self.enc_output_norm(self.enc_output(output_memory))\n\n            if text_dict is not None:\n                enc_outputs_class_unselected = self.enc_out_class_embed(output_memory, text_dict)\n            else:\n                enc_outputs_class_unselected = self.enc_out_class_embed(output_memory)\n\n            topk_logits = enc_outputs_class_unselected.max(-1)[0]\n            enc_outputs_coord_unselected = (\n                self.enc_out_bbox_embed(output_memory) + output_proposals\n            )  # (bs, \\sum{hw}, 4) unsigmoid\n            topk = self.num_queries\n\n            topk_proposals = torch.topk(topk_logits, topk, dim=1)[1]  # bs, nq\n\n            # gather boxes\n            refpoint_embed_undetach = torch.gather(\n                enc_outputs_coord_unselected, 1, topk_proposals.unsqueeze(-1).repeat(1, 1, 4)\n            )  # unsigmoid\n            refpoint_embed_ = refpoint_embed_undetach.detach()\n            init_box_proposal = torch.gather(\n                output_proposals, 1, topk_proposals.unsqueeze(-1).repeat(1, 1, 4)\n            ).sigmoid()  # sigmoid\n\n            # gather tgt\n            tgt_undetach = torch.gather(\n                output_memory, 1, topk_proposals.unsqueeze(-1).repeat(1, 1, self.d_model)\n            )\n            if self.embed_init_tgt:\n                tgt_ = (\n                    self.tgt_embed.weight[:, None, :].repeat(1, bs, 1).transpose(0, 1)\n                )  # nq, bs, d_model\n            else:\n                tgt_ = tgt_undetach.detach()\n\n            if refpoint_embed is not None:\n                refpoint_embed = torch.cat([refpoint_embed, refpoint_embed_], dim=1)\n                tgt = torch.cat([tgt, tgt_], dim=1)\n            else:\n                refpoint_embed, tgt = refpoint_embed_, tgt_\n\n        elif self.two_stage_type == \"no\":\n            tgt_ = (\n                self.tgt_embed.weight[:, None, :].repeat(1, bs, 1).transpose(0, 1)\n            )  # nq, bs, d_model\n            refpoint_embed_ = (\n                self.refpoint_embed.weight[:, None, :].repeat(1, bs, 1).transpose(0, 1)\n            )  # nq, bs, 4\n\n            if refpoint_embed is not None:\n                refpoint_embed = torch.cat([refpoint_embed, refpoint_embed_], dim=1)\n                tgt = torch.cat([tgt, tgt_], dim=1)\n            else:\n                refpoint_embed, tgt = refpoint_embed_, tgt_\n\n            if self.num_patterns > 0:\n                tgt_embed = tgt.repeat(1, self.num_patterns, 1)\n                refpoint_embed = refpoint_embed.repeat(1, self.num_patterns, 1)\n                tgt_pat = self.patterns.weight[None, :, :].repeat_interleave(\n                    self.num_queries, 1\n                )  # 1, n_q*n_pat, d_model\n                tgt = tgt_embed + tgt_pat\n\n            init_box_proposal = refpoint_embed_.sigmoid()\n\n        else:\n            raise NotImplementedError(\"unknown two_stage_type {}\".format(self.two_stage_type))\n        #########################################################\n        # End preparing tgt\n        # - tgt: bs, NQ, d_model\n        # - refpoint_embed(unsigmoid): bs, NQ, d_model\n        #########################################################\n\n        #########################################################\n        # Begin Decoder\n        #########################################################\n        hs, references = self.decoder(\n            tgt=tgt.transpose(0, 1),\n            memory=memory.transpose(0, 1),\n            memory_key_padding_mask=mask_flatten,\n            pos=lvl_pos_embed_flatten.transpose(0, 1),\n            refpoints_unsigmoid=refpoint_embed.transpose(0, 1),\n            level_start_index=level_start_index,\n            spatial_shapes=spatial_shapes,\n            valid_ratios=valid_ratios,\n            tgt_mask=attn_mask,\n            memory_text=text_dict[\"encoded_text\"],\n            text_attention_mask=~text_dict[\"text_token_mask\"],\n            # we ~ the mask . False means use the token; True means pad the token\n        )\n        #########################################################\n        # End Decoder\n        # hs: n_dec, bs, nq, d_model\n        # references: n_dec+1, bs, nq, query_dim\n        #########################################################\n\n        #########################################################\n        # Begin postprocess\n        #########################################################\n        if self.two_stage_type == \"standard\":\n            hs_enc = tgt_undetach.unsqueeze(0)\n            ref_enc = refpoint_embed_undetach.sigmoid().unsqueeze(0)\n        else:\n            hs_enc = ref_enc = None\n        #########################################################\n        # End postprocess\n        # hs_enc: (n_enc+1, bs, nq, d_model) or (1, bs, nq, d_model) or (n_enc, bs, nq, d_model) or None\n        # ref_enc: (n_enc+1, bs, nq, query_dim) or (1, bs, nq, query_dim) or (n_enc, bs, nq, d_model) or None\n        #########################################################\n\n        return hs, references, hs_enc, ref_enc, init_box_proposal", "        # hs: (n_dec, bs, nq, d_model)\n        # references: sigmoid coordinates. (n_dec+1, bs, bq, 4)\n        # hs_enc: (n_enc+1, bs, nq, d_model) or (1, bs, nq, d_model) or None\n        # ref_enc: sigmoid coordinates. \\\n        #           (n_enc+1, bs, nq, query_dim) or (1, bs, nq, query_dim) or None\n\n\nclass TransformerEncoder(nn.Module):\n    def __init__(\n        self,\n        encoder_layer,\n        num_layers,\n        d_model=256,\n        num_queries=300,\n        enc_layer_share=False,\n        text_enhance_layer=None,\n        feature_fusion_layer=None,\n        use_checkpoint=False,\n        use_transformer_ckpt=False,\n    ):\n        \"\"\"_summary_\n\n        Args:\n            encoder_layer (_type_): _description_\n            num_layers (_type_): _description_\n            norm (_type_, optional): _description_. Defaults to None.\n            d_model (int, optional): _description_. Defaults to 256.\n            num_queries (int, optional): _description_. Defaults to 300.\n            enc_layer_share (bool, optional): _description_. Defaults to False.\n\n        \"\"\"\n        super().__init__()\n        # prepare layers\n        self.layers = []\n        self.text_layers = []\n        self.fusion_layers = []\n        if num_layers > 0:\n            self.layers = _get_clones(encoder_layer, num_layers, layer_share=enc_layer_share)\n\n            if text_enhance_layer is not None:\n                self.text_layers = _get_clones(\n                    text_enhance_layer, num_layers, layer_share=enc_layer_share\n                )\n            if feature_fusion_layer is not None:\n                self.fusion_layers = _get_clones(\n                    feature_fusion_layer, num_layers, layer_share=enc_layer_share\n                )\n        else:\n            self.layers = []\n            del encoder_layer\n\n            if text_enhance_layer is not None:\n                self.text_layers = []\n                del text_enhance_layer\n            if feature_fusion_layer is not None:\n                self.fusion_layers = []\n                del feature_fusion_layer\n\n        self.query_scale = None\n        self.num_queries = num_queries\n        self.num_layers = num_layers\n        self.d_model = d_model\n\n        self.use_checkpoint = use_checkpoint\n        self.use_transformer_ckpt = use_transformer_ckpt\n\n    @staticmethod\n    def get_reference_points(spatial_shapes, valid_ratios, device):\n        reference_points_list = []\n        for lvl, (H_, W_) in enumerate(spatial_shapes):\n\n            ref_y, ref_x = torch.meshgrid(\n                torch.linspace(0.5, H_ - 0.5, H_, dtype=torch.float32, device=device),\n                torch.linspace(0.5, W_ - 0.5, W_, dtype=torch.float32, device=device),\n            )\n            ref_y = ref_y.reshape(-1)[None] / (valid_ratios[:, None, lvl, 1] * H_)\n            ref_x = ref_x.reshape(-1)[None] / (valid_ratios[:, None, lvl, 0] * W_)\n            ref = torch.stack((ref_x, ref_y), -1)\n            reference_points_list.append(ref)\n        reference_points = torch.cat(reference_points_list, 1)\n        reference_points = reference_points[:, :, None] * valid_ratios[:, None]\n        return reference_points\n\n    def forward(\n        self,\n        # for images\n        src: Tensor,\n        pos: Tensor,\n        spatial_shapes: Tensor,\n        level_start_index: Tensor,\n        valid_ratios: Tensor,\n        key_padding_mask: Tensor,\n        # for texts\n        memory_text: Tensor = None,\n        text_attention_mask: Tensor = None,\n        pos_text: Tensor = None,\n        text_self_attention_masks: Tensor = None,\n        position_ids: Tensor = None,\n    ):\n        \"\"\"\n        Input:\n            - src: [bs, sum(hi*wi), 256]\n            - pos: pos embed for src. [bs, sum(hi*wi), 256]\n            - spatial_shapes: h,w of each level [num_level, 2]\n            - level_start_index: [num_level] start point of level in sum(hi*wi).\n            - valid_ratios: [bs, num_level, 2]\n            - key_padding_mask: [bs, sum(hi*wi)]\n\n            - memory_text: bs, n_text, 256\n            - text_attention_mask: bs, n_text\n                False for no padding; True for padding\n            - pos_text: bs, n_text, 256\n\n            - position_ids: bs, n_text\n        Intermedia:\n            - reference_points: [bs, sum(hi*wi), num_level, 2]\n        Outpus:\n            - output: [bs, sum(hi*wi), 256]\n        \"\"\"\n\n        output = src\n\n        # preparation and reshape\n        if self.num_layers > 0:\n            reference_points = self.get_reference_points(\n                spatial_shapes, valid_ratios, device=src.device\n            )\n\n        if self.text_layers:\n            # generate pos_text\n            bs, n_text, text_dim = memory_text.shape\n            if pos_text is None and position_ids is None:\n                pos_text = (\n                    torch.arange(n_text, device=memory_text.device)\n                    .float()\n                    .unsqueeze(0)\n                    .unsqueeze(-1)\n                    .repeat(bs, 1, 1)\n                )\n                pos_text = get_sine_pos_embed(pos_text, num_pos_feats=256, exchange_xy=False)\n            if position_ids is not None:\n                pos_text = get_sine_pos_embed(\n                    position_ids[..., None], num_pos_feats=256, exchange_xy=False\n                )\n\n        # main process\n        for layer_id, layer in enumerate(self.layers):\n            # if output.isnan().any() or memory_text.isnan().any():\n            #     if os.environ.get('IPDB_SHILONG_DEBUG', None) == 'INFO':\n            #         import ipdb; ipdb.set_trace()\n            if self.fusion_layers:\n                if self.use_checkpoint:\n                    output, memory_text = checkpoint.checkpoint(\n                        self.fusion_layers[layer_id],\n                        output,\n                        memory_text,\n                        key_padding_mask,\n                        text_attention_mask,\n                    )\n                else:\n                    output, memory_text = self.fusion_layers[layer_id](\n                        v=output,\n                        l=memory_text,\n                        attention_mask_v=key_padding_mask,\n                        attention_mask_l=text_attention_mask,\n                    )\n\n            if self.text_layers:\n                memory_text = self.text_layers[layer_id](\n                    src=memory_text.transpose(0, 1),\n                    src_mask=~text_self_attention_masks,  # note we use ~ for mask here\n                    src_key_padding_mask=text_attention_mask,\n                    pos=(pos_text.transpose(0, 1) if pos_text is not None else None),\n                ).transpose(0, 1)\n\n            # main process\n            if self.use_transformer_ckpt:\n                output = checkpoint.checkpoint(\n                    layer,\n                    output,\n                    pos,\n                    reference_points,\n                    spatial_shapes,\n                    level_start_index,\n                    key_padding_mask,\n                )\n            else:\n                output = layer(\n                    src=output,\n                    pos=pos,\n                    reference_points=reference_points,\n                    spatial_shapes=spatial_shapes,\n                    level_start_index=level_start_index,\n                    key_padding_mask=key_padding_mask,\n                )\n\n        return output, memory_text", "\n\nclass TransformerDecoder(nn.Module):\n    def __init__(\n        self,\n        decoder_layer,\n        num_layers,\n        norm=None,\n        return_intermediate=False,\n        d_model=256,\n        query_dim=4,\n        num_feature_levels=1,\n    ):\n        super().__init__()\n        if num_layers > 0:\n            self.layers = _get_clones(decoder_layer, num_layers)\n        else:\n            self.layers = []\n        self.num_layers = num_layers\n        self.norm = norm\n        self.return_intermediate = return_intermediate\n        assert return_intermediate, \"support return_intermediate only\"\n        self.query_dim = query_dim\n        assert query_dim in [2, 4], \"query_dim should be 2/4 but {}\".format(query_dim)\n        self.num_feature_levels = num_feature_levels\n\n        self.ref_point_head = MLP(query_dim // 2 * d_model, d_model, d_model, 2)\n        self.query_pos_sine_scale = None\n\n        self.query_scale = None\n        self.bbox_embed = None\n        self.class_embed = None\n\n        self.d_model = d_model\n\n        self.ref_anchor_head = None\n\n    def forward(\n        self,\n        tgt,\n        memory,\n        tgt_mask: Optional[Tensor] = None,\n        memory_mask: Optional[Tensor] = None,\n        tgt_key_padding_mask: Optional[Tensor] = None,\n        memory_key_padding_mask: Optional[Tensor] = None,\n        pos: Optional[Tensor] = None,\n        refpoints_unsigmoid: Optional[Tensor] = None,  # num_queries, bs, 2\n        # for memory\n        level_start_index: Optional[Tensor] = None,  # num_levels\n        spatial_shapes: Optional[Tensor] = None,  # bs, num_levels, 2\n        valid_ratios: Optional[Tensor] = None,\n        # for text\n        memory_text: Optional[Tensor] = None,\n        text_attention_mask: Optional[Tensor] = None,\n    ):\n        \"\"\"\n        Input:\n            - tgt: nq, bs, d_model\n            - memory: hw, bs, d_model\n            - pos: hw, bs, d_model\n            - refpoints_unsigmoid: nq, bs, 2/4\n            - valid_ratios/spatial_shapes: bs, nlevel, 2\n        \"\"\"\n        output = tgt\n\n        intermediate = []\n        reference_points = refpoints_unsigmoid.sigmoid()\n        ref_points = [reference_points]\n\n        for layer_id, layer in enumerate(self.layers):\n\n            if reference_points.shape[-1] == 4:\n                reference_points_input = (\n                    reference_points[:, :, None]\n                    * torch.cat([valid_ratios, valid_ratios], -1)[None, :]\n                )  # nq, bs, nlevel, 4\n            else:\n                assert reference_points.shape[-1] == 2\n                reference_points_input = reference_points[:, :, None] * valid_ratios[None, :]\n            query_sine_embed = gen_sineembed_for_position(\n                reference_points_input[:, :, 0, :]\n            )  # nq, bs, 256*2\n\n            # conditional query\n            raw_query_pos = self.ref_point_head(query_sine_embed)  # nq, bs, 256\n            pos_scale = self.query_scale(output) if self.query_scale is not None else 1\n            query_pos = pos_scale * raw_query_pos\n            # if os.environ.get(\"SHILONG_AMP_INFNAN_DEBUG\") == '1':\n            #     if query_pos.isnan().any() | query_pos.isinf().any():\n            #         import ipdb; ipdb.set_trace()\n\n            # main process\n            output = layer(\n                tgt=output,\n                tgt_query_pos=query_pos,\n                tgt_query_sine_embed=query_sine_embed,\n                tgt_key_padding_mask=tgt_key_padding_mask,\n                tgt_reference_points=reference_points_input,\n                memory_text=memory_text,\n                text_attention_mask=text_attention_mask,\n                memory=memory,\n                memory_key_padding_mask=memory_key_padding_mask,\n                memory_level_start_index=level_start_index,\n                memory_spatial_shapes=spatial_shapes,\n                memory_pos=pos,\n                self_attn_mask=tgt_mask,\n                cross_attn_mask=memory_mask,\n            )\n            if output.isnan().any() | output.isinf().any():\n                print(f\"output layer_id {layer_id} is nan\")\n                try:\n                    num_nan = output.isnan().sum().item()\n                    num_inf = output.isinf().sum().item()\n                    print(f\"num_nan {num_nan}, num_inf {num_inf}\")\n                except Exception as e:\n                    print(e)\n                    # if os.environ.get(\"SHILONG_AMP_INFNAN_DEBUG\") == '1':\n                    #     import ipdb; ipdb.set_trace()\n\n            # iter update\n            if self.bbox_embed is not None:\n                # box_holder = self.bbox_embed(output)\n                # box_holder[..., :self.query_dim] += inverse_sigmoid(reference_points)\n                # new_reference_points = box_holder[..., :self.query_dim].sigmoid()\n\n                reference_before_sigmoid = inverse_sigmoid(reference_points)\n                delta_unsig = self.bbox_embed[layer_id](output)\n                outputs_unsig = delta_unsig + reference_before_sigmoid\n                new_reference_points = outputs_unsig.sigmoid()\n\n                reference_points = new_reference_points.detach()\n                # if layer_id != self.num_layers - 1:\n                ref_points.append(new_reference_points)\n\n            intermediate.append(self.norm(output))\n\n        return [\n            [itm_out.transpose(0, 1) for itm_out in intermediate],\n            [itm_refpoint.transpose(0, 1) for itm_refpoint in ref_points],\n        ]", "\n\nclass DeformableTransformerEncoderLayer(nn.Module):\n    def __init__(\n        self,\n        d_model=256,\n        d_ffn=1024,\n        dropout=0.1,\n        activation=\"relu\",\n        n_levels=4,\n        n_heads=8,\n        n_points=4,\n    ):\n        super().__init__()\n\n        # self attention\n        self.self_attn = MSDeformAttn(\n            embed_dim=d_model,\n            num_levels=n_levels,\n            num_heads=n_heads,\n            num_points=n_points,\n            batch_first=True,\n        )\n        self.dropout1 = nn.Dropout(dropout)\n        self.norm1 = nn.LayerNorm(d_model)\n\n        # ffn\n        self.linear1 = nn.Linear(d_model, d_ffn)\n        self.activation = _get_activation_fn(activation, d_model=d_ffn)\n        self.dropout2 = nn.Dropout(dropout)\n        self.linear2 = nn.Linear(d_ffn, d_model)\n        self.dropout3 = nn.Dropout(dropout)\n        self.norm2 = nn.LayerNorm(d_model)\n\n    @staticmethod\n    def with_pos_embed(tensor, pos):\n        return tensor if pos is None else tensor + pos\n\n    def forward_ffn(self, src):\n        src2 = self.linear2(self.dropout2(self.activation(self.linear1(src))))\n        src = src + self.dropout3(src2)\n        src = self.norm2(src)\n        return src\n\n    def forward(\n        self, src, pos, reference_points, spatial_shapes, level_start_index, key_padding_mask=None\n    ):\n        # self attention\n        # import ipdb; ipdb.set_trace()\n        src2 = self.self_attn(\n            query=self.with_pos_embed(src, pos),\n            reference_points=reference_points,\n            value=src,\n            spatial_shapes=spatial_shapes,\n            level_start_index=level_start_index,\n            key_padding_mask=key_padding_mask,\n        )\n        src = src + self.dropout1(src2)\n        src = self.norm1(src)\n\n        # ffn\n        src = self.forward_ffn(src)\n\n        return src", "\n\nclass DeformableTransformerDecoderLayer(nn.Module):\n    def __init__(\n        self,\n        d_model=256,\n        d_ffn=1024,\n        dropout=0.1,\n        activation=\"relu\",\n        n_levels=4,\n        n_heads=8,\n        n_points=4,\n        use_text_feat_guide=False,\n        use_text_cross_attention=False,\n    ):\n        super().__init__()\n\n        # cross attention\n        self.cross_attn = MSDeformAttn(\n            embed_dim=d_model,\n            num_levels=n_levels,\n            num_heads=n_heads,\n            num_points=n_points,\n            batch_first=True,\n        )\n        self.dropout1 = nn.Dropout(dropout) if dropout > 0 else nn.Identity()\n        self.norm1 = nn.LayerNorm(d_model)\n\n        # cross attention text\n        if use_text_cross_attention:\n            self.ca_text = nn.MultiheadAttention(d_model, n_heads, dropout=dropout)\n            self.catext_dropout = nn.Dropout(dropout) if dropout > 0 else nn.Identity()\n            self.catext_norm = nn.LayerNorm(d_model)\n\n        # self attention\n        self.self_attn = nn.MultiheadAttention(d_model, n_heads, dropout=dropout)\n        self.dropout2 = nn.Dropout(dropout) if dropout > 0 else nn.Identity()\n        self.norm2 = nn.LayerNorm(d_model)\n\n        # ffn\n        self.linear1 = nn.Linear(d_model, d_ffn)\n        self.activation = _get_activation_fn(activation, d_model=d_ffn, batch_dim=1)\n        self.dropout3 = nn.Dropout(dropout) if dropout > 0 else nn.Identity()\n        self.linear2 = nn.Linear(d_ffn, d_model)\n        self.dropout4 = nn.Dropout(dropout) if dropout > 0 else nn.Identity()\n        self.norm3 = nn.LayerNorm(d_model)\n\n        self.key_aware_proj = None\n        self.use_text_feat_guide = use_text_feat_guide\n        assert not use_text_feat_guide\n        self.use_text_cross_attention = use_text_cross_attention\n\n    def rm_self_attn_modules(self):\n        self.self_attn = None\n        self.dropout2 = None\n        self.norm2 = None\n\n    @staticmethod\n    def with_pos_embed(tensor, pos):\n        return tensor if pos is None else tensor + pos\n\n    def forward_ffn(self, tgt):\n        with torch.cuda.amp.autocast(enabled=False):\n            tgt2 = self.linear2(self.dropout3(self.activation(self.linear1(tgt))))\n        tgt = tgt + self.dropout4(tgt2)\n        tgt = self.norm3(tgt)\n        return tgt\n\n    def forward(\n        self,\n        # for tgt\n        tgt: Optional[Tensor],  # nq, bs, d_model\n        tgt_query_pos: Optional[Tensor] = None,  # pos for query. MLP(Sine(pos))\n        tgt_query_sine_embed: Optional[Tensor] = None,  # pos for query. Sine(pos)\n        tgt_key_padding_mask: Optional[Tensor] = None,\n        tgt_reference_points: Optional[Tensor] = None,  # nq, bs, 4\n        memory_text: Optional[Tensor] = None,  # bs, num_token, d_model\n        text_attention_mask: Optional[Tensor] = None,  # bs, num_token\n        # for memory\n        memory: Optional[Tensor] = None,  # hw, bs, d_model\n        memory_key_padding_mask: Optional[Tensor] = None,\n        memory_level_start_index: Optional[Tensor] = None,  # num_levels\n        memory_spatial_shapes: Optional[Tensor] = None,  # bs, num_levels, 2\n        memory_pos: Optional[Tensor] = None,  # pos for memory\n        # sa\n        self_attn_mask: Optional[Tensor] = None,  # mask used for self-attention\n        cross_attn_mask: Optional[Tensor] = None,  # mask used for cross-attention\n    ):\n        \"\"\"\n        Input:\n            - tgt/tgt_query_pos: nq, bs, d_model\n            -\n        \"\"\"\n        assert cross_attn_mask is None\n\n        # self attention\n        if self.self_attn is not None:\n            # import ipdb; ipdb.set_trace()\n            q = k = self.with_pos_embed(tgt, tgt_query_pos)\n            tgt2 = self.self_attn(q, k, tgt, attn_mask=self_attn_mask)[0]\n            tgt = tgt + self.dropout2(tgt2)\n            tgt = self.norm2(tgt)\n\n        if self.use_text_cross_attention:\n            tgt2 = self.ca_text(\n                self.with_pos_embed(tgt, tgt_query_pos),\n                memory_text.transpose(0, 1),\n                memory_text.transpose(0, 1),\n                key_padding_mask=text_attention_mask,\n            )[0]\n            tgt = tgt + self.catext_dropout(tgt2)\n            tgt = self.catext_norm(tgt)\n\n        tgt2 = self.cross_attn(\n            query=self.with_pos_embed(tgt, tgt_query_pos).transpose(0, 1),\n            reference_points=tgt_reference_points.transpose(0, 1).contiguous(),\n            value=memory.transpose(0, 1),\n            spatial_shapes=memory_spatial_shapes,\n            level_start_index=memory_level_start_index,\n            key_padding_mask=memory_key_padding_mask,\n        ).transpose(0, 1)\n        tgt = tgt + self.dropout1(tgt2)\n        tgt = self.norm1(tgt)\n\n        # ffn\n        tgt = self.forward_ffn(tgt)\n\n        return tgt", "\n\ndef build_transformer(args):\n    return Transformer(\n        d_model=args.hidden_dim,\n        dropout=args.dropout,\n        nhead=args.nheads,\n        num_queries=args.num_queries,\n        dim_feedforward=args.dim_feedforward,\n        num_encoder_layers=args.enc_layers,\n        num_decoder_layers=args.dec_layers,\n        normalize_before=args.pre_norm,\n        return_intermediate_dec=True,\n        query_dim=args.query_dim,\n        activation=args.transformer_activation,\n        num_patterns=args.num_patterns,\n        num_feature_levels=args.num_feature_levels,\n        enc_n_points=args.enc_n_points,\n        dec_n_points=args.dec_n_points,\n        learnable_tgt_init=True,\n        # two stage\n        two_stage_type=args.two_stage_type,  # ['no', 'standard', 'early']\n        embed_init_tgt=args.embed_init_tgt,\n        use_text_enhancer=args.use_text_enhancer,\n        use_fusion_layer=args.use_fusion_layer,\n        use_checkpoint=args.use_checkpoint,\n        use_transformer_ckpt=args.use_transformer_ckpt,\n        use_text_cross_attention=args.use_text_cross_attention,\n        text_dropout=args.text_dropout,\n        fusion_dropout=args.fusion_dropout,\n        fusion_droppath=args.fusion_droppath,\n    )", ""]}
{"filename": "local_groundingdino/models/GroundingDINO/__init__.py", "chunked_list": ["# ------------------------------------------------------------------------\n# Grounding DINO\n# url: https://github.com/IDEA-Research/GroundingDINO\n# Copyright (c) 2023 IDEA. All Rights Reserved.\n# Licensed under the Apache License, Version 2.0 [see LICENSE for details]\n# ------------------------------------------------------------------------\n# Conditional DETR\n# Copyright (c) 2021 Microsoft. All Rights Reserved.\n# Licensed under the Apache License, Version 2.0 [see LICENSE for details]\n# ------------------------------------------------------------------------", "# Licensed under the Apache License, Version 2.0 [see LICENSE for details]\n# ------------------------------------------------------------------------\n# Copied from DETR (https://github.com/facebookresearch/detr)\n# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n# ------------------------------------------------------------------------\n\nfrom .groundingdino import build_groundingdino\n"]}
{"filename": "local_groundingdino/models/GroundingDINO/utils.py", "chunked_list": ["# ------------------------------------------------------------------------\n# Grounding DINO\n# url: https://github.com/IDEA-Research/GroundingDINO\n# Copyright (c) 2023 IDEA. All Rights Reserved.\n# Licensed under the Apache License, Version 2.0 [see LICENSE for details]\n# ------------------------------------------------------------------------\n\nimport copy\nimport math\n", "import math\n\nimport torch\nimport torch.nn.functional as F\nfrom torch import Tensor, nn\n\n\ndef _get_clones(module, N, layer_share=False):\n    # import ipdb; ipdb.set_trace()\n    if layer_share:\n        return nn.ModuleList([module for i in range(N)])\n    else:\n        return nn.ModuleList([copy.deepcopy(module) for i in range(N)])", "\n\ndef get_sine_pos_embed(\n    pos_tensor: torch.Tensor,\n    num_pos_feats: int = 128,\n    temperature: int = 10000,\n    exchange_xy: bool = True,\n):\n    \"\"\"generate sine position embedding from a position tensor\n    Args:\n        pos_tensor (torch.Tensor): shape: [..., n].\n        num_pos_feats (int): projected shape for each float in the tensor.\n        temperature (int): temperature in the sine/cosine function.\n        exchange_xy (bool, optional): exchange pos x and pos y. \\\n            For example, input tensor is [x,y], the results will be [pos(y), pos(x)]. Defaults to True.\n    Returns:\n        pos_embed (torch.Tensor): shape: [..., n*num_pos_feats].\n    \"\"\"\n    scale = 2 * math.pi\n    dim_t = torch.arange(num_pos_feats, dtype=torch.float32, device=pos_tensor.device)\n    dim_t = temperature ** (2 * torch.div(dim_t, 2, rounding_mode=\"floor\") / num_pos_feats)\n\n    def sine_func(x: torch.Tensor):\n        sin_x = x * scale / dim_t\n        sin_x = torch.stack((sin_x[..., 0::2].sin(), sin_x[..., 1::2].cos()), dim=3).flatten(2)\n        return sin_x\n\n    pos_res = [sine_func(x) for x in pos_tensor.split([1] * pos_tensor.shape[-1], dim=-1)]\n    if exchange_xy:\n        pos_res[0], pos_res[1] = pos_res[1], pos_res[0]\n    pos_res = torch.cat(pos_res, dim=-1)\n    return pos_res", "\n\ndef gen_encoder_output_proposals(\n    memory: Tensor, memory_padding_mask: Tensor, spatial_shapes: Tensor, learnedwh=None\n):\n    \"\"\"\n    Input:\n        - memory: bs, \\sum{hw}, d_model\n        - memory_padding_mask: bs, \\sum{hw}\n        - spatial_shapes: nlevel, 2\n        - learnedwh: 2\n    Output:\n        - output_memory: bs, \\sum{hw}, d_model\n        - output_proposals: bs, \\sum{hw}, 4\n    \"\"\"\n    N_, S_, C_ = memory.shape\n    proposals = []\n    _cur = 0\n    for lvl, (H_, W_) in enumerate(spatial_shapes):\n        mask_flatten_ = memory_padding_mask[:, _cur : (_cur + H_ * W_)].view(N_, H_, W_, 1)\n        valid_H = torch.sum(~mask_flatten_[:, :, 0, 0], 1)\n        valid_W = torch.sum(~mask_flatten_[:, 0, :, 0], 1)\n\n        # import ipdb; ipdb.set_trace()\n\n        grid_y, grid_x = torch.meshgrid(\n            torch.linspace(0, H_ - 1, H_, dtype=torch.float32, device=memory.device),\n            torch.linspace(0, W_ - 1, W_, dtype=torch.float32, device=memory.device),\n        )\n        grid = torch.cat([grid_x.unsqueeze(-1), grid_y.unsqueeze(-1)], -1)  # H_, W_, 2\n\n        scale = torch.cat([valid_W.unsqueeze(-1), valid_H.unsqueeze(-1)], 1).view(N_, 1, 1, 2)\n        grid = (grid.unsqueeze(0).expand(N_, -1, -1, -1) + 0.5) / scale\n\n        if learnedwh is not None:\n            # import ipdb; ipdb.set_trace()\n            wh = torch.ones_like(grid) * learnedwh.sigmoid() * (2.0**lvl)\n        else:\n            wh = torch.ones_like(grid) * 0.05 * (2.0**lvl)\n\n        # scale = torch.cat([W_[None].unsqueeze(-1), H_[None].unsqueeze(-1)], 1).view(1, 1, 1, 2).repeat(N_, 1, 1, 1)\n        # grid = (grid.unsqueeze(0).expand(N_, -1, -1, -1) + 0.5) / scale\n        # wh = torch.ones_like(grid) / scale\n        proposal = torch.cat((grid, wh), -1).view(N_, -1, 4)\n        proposals.append(proposal)\n        _cur += H_ * W_\n    # import ipdb; ipdb.set_trace()\n    output_proposals = torch.cat(proposals, 1)\n    output_proposals_valid = ((output_proposals > 0.01) & (output_proposals < 0.99)).all(\n        -1, keepdim=True\n    )\n    output_proposals = torch.log(output_proposals / (1 - output_proposals))  # unsigmoid\n    output_proposals = output_proposals.masked_fill(memory_padding_mask.unsqueeze(-1), float(\"inf\"))\n    output_proposals = output_proposals.masked_fill(~output_proposals_valid, float(\"inf\"))\n\n    output_memory = memory\n    output_memory = output_memory.masked_fill(memory_padding_mask.unsqueeze(-1), float(0))\n    output_memory = output_memory.masked_fill(~output_proposals_valid, float(0))\n\n    # output_memory = output_memory.masked_fill(memory_padding_mask.unsqueeze(-1), float('inf'))\n    # output_memory = output_memory.masked_fill(~output_proposals_valid, float('inf'))\n\n    return output_memory, output_proposals", "\n\nclass RandomBoxPerturber:\n    def __init__(\n        self, x_noise_scale=0.2, y_noise_scale=0.2, w_noise_scale=0.2, h_noise_scale=0.2\n    ) -> None:\n        self.noise_scale = torch.Tensor(\n            [x_noise_scale, y_noise_scale, w_noise_scale, h_noise_scale]\n        )\n\n    def __call__(self, refanchors: Tensor) -> Tensor:\n        nq, bs, query_dim = refanchors.shape\n        device = refanchors.device\n\n        noise_raw = torch.rand_like(refanchors)\n        noise_scale = self.noise_scale.to(device)[:query_dim]\n\n        new_refanchors = refanchors * (1 + (noise_raw - 0.5) * noise_scale)\n        return new_refanchors.clamp_(0, 1)", "\n\ndef sigmoid_focal_loss(\n    inputs, targets, num_boxes, alpha: float = 0.25, gamma: float = 2, no_reduction=False\n):\n    \"\"\"\n    Loss used in RetinaNet for dense detection: https://arxiv.org/abs/1708.02002.\n    Args:\n        inputs: A float tensor of arbitrary shape.\n                The predictions for each example.\n        targets: A float tensor with the same shape as inputs. Stores the binary\n                 classification label for each element in inputs\n                (0 for the negative class and 1 for the positive class).\n        alpha: (optional) Weighting factor in range (0,1) to balance\n                positive vs negative examples. Default = -1 (no weighting).\n        gamma: Exponent of the modulating factor (1 - p_t) to\n               balance easy vs hard examples.\n    Returns:\n        Loss tensor\n    \"\"\"\n    prob = inputs.sigmoid()\n    ce_loss = F.binary_cross_entropy_with_logits(inputs, targets, reduction=\"none\")\n    p_t = prob * targets + (1 - prob) * (1 - targets)\n    loss = ce_loss * ((1 - p_t) ** gamma)\n\n    if alpha >= 0:\n        alpha_t = alpha * targets + (1 - alpha) * (1 - targets)\n        loss = alpha_t * loss\n\n    if no_reduction:\n        return loss\n\n    return loss.mean(1).sum() / num_boxes", "\n\nclass MLP(nn.Module):\n    \"\"\"Very simple multi-layer perceptron (also called FFN)\"\"\"\n\n    def __init__(self, input_dim, hidden_dim, output_dim, num_layers):\n        super().__init__()\n        self.num_layers = num_layers\n        h = [hidden_dim] * (num_layers - 1)\n        self.layers = nn.ModuleList(\n            nn.Linear(n, k) for n, k in zip([input_dim] + h, h + [output_dim])\n        )\n\n    def forward(self, x):\n        for i, layer in enumerate(self.layers):\n            x = F.relu(layer(x)) if i < self.num_layers - 1 else layer(x)\n        return x", "\n\ndef _get_activation_fn(activation, d_model=256, batch_dim=0):\n    \"\"\"Return an activation function given a string\"\"\"\n    if activation == \"relu\":\n        return F.relu\n    if activation == \"gelu\":\n        return F.gelu\n    if activation == \"glu\":\n        return F.glu\n    if activation == \"prelu\":\n        return nn.PReLU()\n    if activation == \"selu\":\n        return F.selu\n\n    raise RuntimeError(f\"activation should be relu/gelu, not {activation}.\")", "\n\ndef gen_sineembed_for_position(pos_tensor):\n    # n_query, bs, _ = pos_tensor.size()\n    # sineembed_tensor = torch.zeros(n_query, bs, 256)\n    scale = 2 * math.pi\n    dim_t = torch.arange(128, dtype=torch.float32, device=pos_tensor.device)\n    dim_t = 10000 ** (2 * (torch.div(dim_t, 2, rounding_mode='floor')) / 128)\n    x_embed = pos_tensor[:, :, 0] * scale\n    y_embed = pos_tensor[:, :, 1] * scale\n    pos_x = x_embed[:, :, None] / dim_t\n    pos_y = y_embed[:, :, None] / dim_t\n    pos_x = torch.stack((pos_x[:, :, 0::2].sin(), pos_x[:, :, 1::2].cos()), dim=3).flatten(2)\n    pos_y = torch.stack((pos_y[:, :, 0::2].sin(), pos_y[:, :, 1::2].cos()), dim=3).flatten(2)\n    if pos_tensor.size(-1) == 2:\n        pos = torch.cat((pos_y, pos_x), dim=2)\n    elif pos_tensor.size(-1) == 4:\n        w_embed = pos_tensor[:, :, 2] * scale\n        pos_w = w_embed[:, :, None] / dim_t\n        pos_w = torch.stack((pos_w[:, :, 0::2].sin(), pos_w[:, :, 1::2].cos()), dim=3).flatten(2)\n\n        h_embed = pos_tensor[:, :, 3] * scale\n        pos_h = h_embed[:, :, None] / dim_t\n        pos_h = torch.stack((pos_h[:, :, 0::2].sin(), pos_h[:, :, 1::2].cos()), dim=3).flatten(2)\n\n        pos = torch.cat((pos_y, pos_x, pos_w, pos_h), dim=2)\n    else:\n        raise ValueError(\"Unknown pos_tensor shape(-1):{}\".format(pos_tensor.size(-1)))\n    return pos", "\n\nclass ContrastiveEmbed(nn.Module):\n    def __init__(self, max_text_len=256):\n        \"\"\"\n        Args:\n            max_text_len: max length of text.\n        \"\"\"\n        super().__init__()\n        self.max_text_len = max_text_len\n\n    def forward(self, x, text_dict):\n        \"\"\"_summary_\n\n        Args:\n            x (_type_): _description_\n            text_dict (_type_): _description_\n            {\n                'encoded_text': encoded_text, # bs, 195, d_model\n                'text_token_mask': text_token_mask, # bs, 195\n                        # True for used tokens. False for padding tokens\n            }\n        Returns:\n            _type_: _description_\n        \"\"\"\n        assert isinstance(text_dict, dict)\n\n        y = text_dict[\"encoded_text\"]\n        text_token_mask = text_dict[\"text_token_mask\"]\n\n        res = x @ y.transpose(-1, -2)\n        res.masked_fill_(~text_token_mask[:, None, :], float(\"-inf\"))\n\n        # padding to max_text_len\n        new_res = torch.full((*res.shape[:-1], self.max_text_len), float(\"-inf\"), device=res.device)\n        new_res[..., : res.shape[-1]] = res\n\n        return new_res", ""]}
{"filename": "local_groundingdino/models/GroundingDINO/fuse_modules.py", "chunked_list": ["# ------------------------------------------------------------------------\n# Grounding DINO\n# url: https://github.com/IDEA-Research/GroundingDINO\n# Copyright (c) 2023 IDEA. All Rights Reserved.\n# Licensed under the Apache License, Version 2.0 [see LICENSE for details]\n# ------------------------------------------------------------------------\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F", "import torch.nn as nn\nimport torch.nn.functional as F\nfrom timm.models.layers import DropPath\n\n\nclass FeatureResizer(nn.Module):\n    \"\"\"\n    This class takes as input a set of embeddings of dimension C1 and outputs a set of\n    embedding of dimension C2, after a linear transformation, dropout and normalization (LN).\n    \"\"\"\n\n    def __init__(self, input_feat_size, output_feat_size, dropout, do_ln=True):\n        super().__init__()\n        self.do_ln = do_ln\n        # Object feature encoding\n        self.fc = nn.Linear(input_feat_size, output_feat_size, bias=True)\n        self.layer_norm = nn.LayerNorm(output_feat_size, eps=1e-12)\n        self.dropout = nn.Dropout(dropout)\n\n    def forward(self, encoder_features):\n        x = self.fc(encoder_features)\n        if self.do_ln:\n            x = self.layer_norm(x)\n        output = self.dropout(x)\n        return output", "\n\ndef l1norm(X, dim, eps=1e-8):\n    \"\"\"L1-normalize columns of X\"\"\"\n    norm = torch.abs(X).sum(dim=dim, keepdim=True) + eps\n    X = torch.div(X, norm)\n    return X\n\n\ndef l2norm(X, dim, eps=1e-8):\n    \"\"\"L2-normalize columns of X\"\"\"\n    norm = torch.pow(X, 2).sum(dim=dim, keepdim=True).sqrt() + eps\n    X = torch.div(X, norm)\n    return X", "\ndef l2norm(X, dim, eps=1e-8):\n    \"\"\"L2-normalize columns of X\"\"\"\n    norm = torch.pow(X, 2).sum(dim=dim, keepdim=True).sqrt() + eps\n    X = torch.div(X, norm)\n    return X\n\n\ndef func_attention(query, context, smooth=1, raw_feature_norm=\"softmax\", eps=1e-8):\n    \"\"\"\n    query: (n_context, queryL, d)\n    context: (n_context, sourceL, d)\n    \"\"\"\n    batch_size_q, queryL = query.size(0), query.size(1)\n    batch_size, sourceL = context.size(0), context.size(1)\n\n    # Get attention\n    # --> (batch, d, queryL)\n    queryT = torch.transpose(query, 1, 2)\n\n    # (batch, sourceL, d)(batch, d, queryL)\n    # --> (batch, sourceL, queryL)\n    attn = torch.bmm(context, queryT)\n    if raw_feature_norm == \"softmax\":\n        # --> (batch*sourceL, queryL)\n        attn = attn.view(batch_size * sourceL, queryL)\n        attn = nn.Softmax()(attn)\n        # --> (batch, sourceL, queryL)\n        attn = attn.view(batch_size, sourceL, queryL)\n    elif raw_feature_norm == \"l2norm\":\n        attn = l2norm(attn, 2)\n    elif raw_feature_norm == \"clipped_l2norm\":\n        attn = nn.LeakyReLU(0.1)(attn)\n        attn = l2norm(attn, 2)\n    else:\n        raise ValueError(\"unknown first norm type:\", raw_feature_norm)\n    # --> (batch, queryL, sourceL)\n    attn = torch.transpose(attn, 1, 2).contiguous()\n    # --> (batch*queryL, sourceL)\n    attn = attn.view(batch_size * queryL, sourceL)\n    attn = nn.Softmax()(attn * smooth)\n    # --> (batch, queryL, sourceL)\n    attn = attn.view(batch_size, queryL, sourceL)\n    # --> (batch, sourceL, queryL)\n    attnT = torch.transpose(attn, 1, 2).contiguous()\n\n    # --> (batch, d, sourceL)\n    contextT = torch.transpose(context, 1, 2)\n    # (batch x d x sourceL)(batch x sourceL x queryL)\n    # --> (batch, d, queryL)\n    weightedContext = torch.bmm(contextT, attnT)\n    # --> (batch, queryL, d)\n    weightedContext = torch.transpose(weightedContext, 1, 2)\n\n    return weightedContext, attnT", "def func_attention(query, context, smooth=1, raw_feature_norm=\"softmax\", eps=1e-8):\n    \"\"\"\n    query: (n_context, queryL, d)\n    context: (n_context, sourceL, d)\n    \"\"\"\n    batch_size_q, queryL = query.size(0), query.size(1)\n    batch_size, sourceL = context.size(0), context.size(1)\n\n    # Get attention\n    # --> (batch, d, queryL)\n    queryT = torch.transpose(query, 1, 2)\n\n    # (batch, sourceL, d)(batch, d, queryL)\n    # --> (batch, sourceL, queryL)\n    attn = torch.bmm(context, queryT)\n    if raw_feature_norm == \"softmax\":\n        # --> (batch*sourceL, queryL)\n        attn = attn.view(batch_size * sourceL, queryL)\n        attn = nn.Softmax()(attn)\n        # --> (batch, sourceL, queryL)\n        attn = attn.view(batch_size, sourceL, queryL)\n    elif raw_feature_norm == \"l2norm\":\n        attn = l2norm(attn, 2)\n    elif raw_feature_norm == \"clipped_l2norm\":\n        attn = nn.LeakyReLU(0.1)(attn)\n        attn = l2norm(attn, 2)\n    else:\n        raise ValueError(\"unknown first norm type:\", raw_feature_norm)\n    # --> (batch, queryL, sourceL)\n    attn = torch.transpose(attn, 1, 2).contiguous()\n    # --> (batch*queryL, sourceL)\n    attn = attn.view(batch_size * queryL, sourceL)\n    attn = nn.Softmax()(attn * smooth)\n    # --> (batch, queryL, sourceL)\n    attn = attn.view(batch_size, queryL, sourceL)\n    # --> (batch, sourceL, queryL)\n    attnT = torch.transpose(attn, 1, 2).contiguous()\n\n    # --> (batch, d, sourceL)\n    contextT = torch.transpose(context, 1, 2)\n    # (batch x d x sourceL)(batch x sourceL x queryL)\n    # --> (batch, d, queryL)\n    weightedContext = torch.bmm(contextT, attnT)\n    # --> (batch, queryL, d)\n    weightedContext = torch.transpose(weightedContext, 1, 2)\n\n    return weightedContext, attnT", "\n\nclass BiMultiHeadAttention(nn.Module):\n    def __init__(self, v_dim, l_dim, embed_dim, num_heads, dropout=0.1, cfg=None):\n        super(BiMultiHeadAttention, self).__init__()\n\n        self.embed_dim = embed_dim\n        self.num_heads = num_heads\n        self.head_dim = embed_dim // num_heads\n        self.v_dim = v_dim\n        self.l_dim = l_dim\n\n        assert (\n            self.head_dim * self.num_heads == self.embed_dim\n        ), f\"embed_dim must be divisible by num_heads (got `embed_dim`: {self.embed_dim} and `num_heads`: {self.num_heads}).\"\n        self.scale = self.head_dim ** (-0.5)\n        self.dropout = dropout\n\n        self.v_proj = nn.Linear(self.v_dim, self.embed_dim)\n        self.l_proj = nn.Linear(self.l_dim, self.embed_dim)\n        self.values_v_proj = nn.Linear(self.v_dim, self.embed_dim)\n        self.values_l_proj = nn.Linear(self.l_dim, self.embed_dim)\n\n        self.out_v_proj = nn.Linear(self.embed_dim, self.v_dim)\n        self.out_l_proj = nn.Linear(self.embed_dim, self.l_dim)\n\n        self.stable_softmax_2d = True\n        self.clamp_min_for_underflow = True\n        self.clamp_max_for_overflow = True\n\n        self._reset_parameters()\n\n    def _shape(self, tensor: torch.Tensor, seq_len: int, bsz: int):\n        return tensor.view(bsz, seq_len, self.num_heads, self.head_dim).transpose(1, 2).contiguous()\n\n    def _reset_parameters(self):\n        nn.init.xavier_uniform_(self.v_proj.weight)\n        self.v_proj.bias.data.fill_(0)\n        nn.init.xavier_uniform_(self.l_proj.weight)\n        self.l_proj.bias.data.fill_(0)\n        nn.init.xavier_uniform_(self.values_v_proj.weight)\n        self.values_v_proj.bias.data.fill_(0)\n        nn.init.xavier_uniform_(self.values_l_proj.weight)\n        self.values_l_proj.bias.data.fill_(0)\n        nn.init.xavier_uniform_(self.out_v_proj.weight)\n        self.out_v_proj.bias.data.fill_(0)\n        nn.init.xavier_uniform_(self.out_l_proj.weight)\n        self.out_l_proj.bias.data.fill_(0)\n\n    def forward(self, v, l, attention_mask_v=None, attention_mask_l=None):\n        \"\"\"_summary_\n\n        Args:\n            v (_type_): bs, n_img, dim\n            l (_type_): bs, n_text, dim\n            attention_mask_v (_type_, optional): _description_. bs, n_img\n            attention_mask_l (_type_, optional): _description_. bs, n_text\n\n        Returns:\n            _type_: _description_\n        \"\"\"\n        # if os.environ.get('IPDB_SHILONG_DEBUG', None) == 'INFO':\n        #     import ipdb; ipdb.set_trace()\n        bsz, tgt_len, _ = v.size()\n\n        query_states = self.v_proj(v) * self.scale\n        key_states = self._shape(self.l_proj(l), -1, bsz)\n        value_v_states = self._shape(self.values_v_proj(v), -1, bsz)\n        value_l_states = self._shape(self.values_l_proj(l), -1, bsz)\n\n        proj_shape = (bsz * self.num_heads, -1, self.head_dim)\n        query_states = self._shape(query_states, tgt_len, bsz).view(*proj_shape)\n        key_states = key_states.view(*proj_shape)\n        value_v_states = value_v_states.view(*proj_shape)\n        value_l_states = value_l_states.view(*proj_shape)\n\n        src_len = key_states.size(1)\n        attn_weights = torch.bmm(query_states, key_states.transpose(1, 2))  # bs*nhead, nimg, ntxt\n\n        if attn_weights.size() != (bsz * self.num_heads, tgt_len, src_len):\n            raise ValueError(\n                f\"Attention weights should be of size {(bsz * self.num_heads, tgt_len, src_len)}, but is {attn_weights.size()}\"\n            )\n\n        if self.stable_softmax_2d:\n            attn_weights = attn_weights - attn_weights.max()\n\n        if self.clamp_min_for_underflow:\n            attn_weights = torch.clamp(\n                attn_weights, min=-50000\n            )  # Do not increase -50000, data type half has quite limited range\n        if self.clamp_max_for_overflow:\n            attn_weights = torch.clamp(\n                attn_weights, max=50000\n            )  # Do not increase 50000, data type half has quite limited range\n\n        attn_weights_T = attn_weights.transpose(1, 2)\n        attn_weights_l = attn_weights_T - torch.max(attn_weights_T, dim=-1, keepdim=True)[0]\n        if self.clamp_min_for_underflow:\n            attn_weights_l = torch.clamp(\n                attn_weights_l, min=-50000\n            )  # Do not increase -50000, data type half has quite limited range\n        if self.clamp_max_for_overflow:\n            attn_weights_l = torch.clamp(\n                attn_weights_l, max=50000\n            )  # Do not increase 50000, data type half has quite limited range\n\n        # mask vison for language\n        if attention_mask_v is not None:\n            attention_mask_v = (\n                attention_mask_v[:, None, None, :].repeat(1, self.num_heads, 1, 1).flatten(0, 1)\n            )\n            attn_weights_l.masked_fill_(attention_mask_v, float(\"-inf\"))\n\n        attn_weights_l = attn_weights_l.softmax(dim=-1)\n\n        # mask language for vision\n        if attention_mask_l is not None:\n            attention_mask_l = (\n                attention_mask_l[:, None, None, :].repeat(1, self.num_heads, 1, 1).flatten(0, 1)\n            )\n            attn_weights.masked_fill_(attention_mask_l, float(\"-inf\"))\n        attn_weights_v = attn_weights.softmax(dim=-1)\n\n        attn_probs_v = F.dropout(attn_weights_v, p=self.dropout, training=self.training)\n        attn_probs_l = F.dropout(attn_weights_l, p=self.dropout, training=self.training)\n\n        attn_output_v = torch.bmm(attn_probs_v, value_l_states)\n        attn_output_l = torch.bmm(attn_probs_l, value_v_states)\n\n        if attn_output_v.size() != (bsz * self.num_heads, tgt_len, self.head_dim):\n            raise ValueError(\n                f\"`attn_output_v` should be of size {(bsz, self.num_heads, tgt_len, self.head_dim)}, but is {attn_output_v.size()}\"\n            )\n\n        if attn_output_l.size() != (bsz * self.num_heads, src_len, self.head_dim):\n            raise ValueError(\n                f\"`attn_output_l` should be of size {(bsz, self.num_heads, src_len, self.head_dim)}, but is {attn_output_l.size()}\"\n            )\n\n        attn_output_v = attn_output_v.view(bsz, self.num_heads, tgt_len, self.head_dim)\n        attn_output_v = attn_output_v.transpose(1, 2)\n        attn_output_v = attn_output_v.reshape(bsz, tgt_len, self.embed_dim)\n\n        attn_output_l = attn_output_l.view(bsz, self.num_heads, src_len, self.head_dim)\n        attn_output_l = attn_output_l.transpose(1, 2)\n        attn_output_l = attn_output_l.reshape(bsz, src_len, self.embed_dim)\n\n        attn_output_v = self.out_v_proj(attn_output_v)\n        attn_output_l = self.out_l_proj(attn_output_l)\n\n        return attn_output_v, attn_output_l", "\n\n# Bi-Direction MHA (text->image, image->text)\nclass BiAttentionBlock(nn.Module):\n    def __init__(\n        self,\n        v_dim,\n        l_dim,\n        embed_dim,\n        num_heads,\n        dropout=0.1,\n        drop_path=0.0,\n        init_values=1e-4,\n        cfg=None,\n    ):\n        \"\"\"\n        Inputs:\n            embed_dim - Dimensionality of input and attention feature vectors\n            hidden_dim - Dimensionality of hidden layer in feed-forward network\n                         (usually 2-4x larger than embed_dim)\n            num_heads - Number of heads to use in the Multi-Head Attention block\n            dropout - Amount of dropout to apply in the feed-forward network\n        \"\"\"\n        super(BiAttentionBlock, self).__init__()\n\n        # pre layer norm\n        self.layer_norm_v = nn.LayerNorm(v_dim)\n        self.layer_norm_l = nn.LayerNorm(l_dim)\n        self.attn = BiMultiHeadAttention(\n            v_dim=v_dim, l_dim=l_dim, embed_dim=embed_dim, num_heads=num_heads, dropout=dropout\n        )\n\n        # add layer scale for training stability\n        self.drop_path = DropPath(drop_path) if drop_path > 0.0 else nn.Identity()\n        self.gamma_v = nn.Parameter(init_values * torch.ones((v_dim)), requires_grad=True)\n        self.gamma_l = nn.Parameter(init_values * torch.ones((l_dim)), requires_grad=True)\n\n    def forward(self, v, l, attention_mask_v=None, attention_mask_l=None):\n        v = self.layer_norm_v(v)\n        l = self.layer_norm_l(l)\n        delta_v, delta_l = self.attn(\n            v, l, attention_mask_v=attention_mask_v, attention_mask_l=attention_mask_l\n        )\n        # v, l = v + delta_v, l + delta_l\n        v = v + self.drop_path(self.gamma_v * delta_v)\n        l = l + self.drop_path(self.gamma_l * delta_l)\n        return v, l", "\n    # def forward(self, v:List[torch.Tensor], l, attention_mask_v=None, attention_mask_l=None)\n"]}
{"filename": "local_groundingdino/models/GroundingDINO/groundingdino.py", "chunked_list": ["# ------------------------------------------------------------------------\n# Grounding DINO\n# url: https://github.com/IDEA-Research/GroundingDINO\n# Copyright (c) 2023 IDEA. All Rights Reserved.\n# Licensed under the Apache License, Version 2.0 [see LICENSE for details]\n# ------------------------------------------------------------------------\n# Conditional DETR model and criterion classes.\n# Copyright (c) 2021 Microsoft. All Rights Reserved.\n# Licensed under the Apache License, Version 2.0 [see LICENSE for details]\n# ------------------------------------------------------------------------", "# Licensed under the Apache License, Version 2.0 [see LICENSE for details]\n# ------------------------------------------------------------------------\n# Modified from DETR (https://github.com/facebookresearch/detr)\n# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n# ------------------------------------------------------------------------\n# Modified from Deformable DETR (https://github.com/fundamentalvision/Deformable-DETR)\n# Copyright (c) 2020 SenseTime. All Rights Reserved.\n# ------------------------------------------------------------------------\nimport copy\nfrom typing import List", "import copy\nfrom typing import List\n\nimport torch\nimport torch.nn.functional as F\nfrom torch import nn\n\nfrom local_groundingdino.util import get_tokenlizer\nfrom local_groundingdino.util.misc import (\n    NestedTensor,", "from local_groundingdino.util.misc import (\n    NestedTensor,\n    inverse_sigmoid,\n    nested_tensor_from_tensor_list,\n)\n\nfrom ..registry import MODULE_BUILD_FUNCS\nfrom .backbone import build_backbone\nfrom .bertwarper import (\n    BertModelWarper,", "from .bertwarper import (\n    BertModelWarper,\n    generate_masks_with_special_tokens_and_transfer_map,\n)\nfrom .transformer import build_transformer\nfrom .utils import MLP, ContrastiveEmbed\n\n\nclass GroundingDINO(nn.Module):\n    \"\"\"This is the Cross-Attention Detector module that performs object detection\"\"\"\n\n    def __init__(\n        self,\n        backbone,\n        transformer,\n        num_queries,\n        aux_loss=False,\n        iter_update=False,\n        query_dim=2,\n        num_feature_levels=1,\n        nheads=8,\n        # two stage\n        two_stage_type=\"no\",  # ['no', 'standard']\n        dec_pred_bbox_embed_share=True,\n        two_stage_class_embed_share=True,\n        two_stage_bbox_embed_share=True,\n        num_patterns=0,\n        dn_number=100,\n        dn_box_noise_scale=0.4,\n        dn_label_noise_ratio=0.5,\n        dn_labelbook_size=100,\n        text_encoder_type=\"bert-base-uncased\",\n        sub_sentence_present=True,\n        max_text_len=256,\n    ):\n        \"\"\"Initializes the model.\n        Parameters:\n            backbone: torch module of the backbone to be used. See backbone.py\n            transformer: torch module of the transformer architecture. See transformer.py\n            num_queries: number of object queries, ie detection slot. This is the maximal number of objects\n                         Conditional DETR can detect in a single image. For COCO, we recommend 100 queries.\n            aux_loss: True if auxiliary decoding losses (loss at each decoder layer) are to be used.\n        \"\"\"\n        super().__init__()\n        self.num_queries = num_queries\n        self.transformer = transformer\n        self.hidden_dim = hidden_dim = transformer.d_model\n        self.num_feature_levels = num_feature_levels\n        self.nheads = nheads\n        self.max_text_len = 256\n        self.sub_sentence_present = sub_sentence_present\n\n        # setting query dim\n        self.query_dim = query_dim\n        assert query_dim == 4\n\n        # for dn training\n        self.num_patterns = num_patterns\n        self.dn_number = dn_number\n        self.dn_box_noise_scale = dn_box_noise_scale\n        self.dn_label_noise_ratio = dn_label_noise_ratio\n        self.dn_labelbook_size = dn_labelbook_size\n\n        # bert\n        self.tokenizer = get_tokenlizer.get_tokenlizer(text_encoder_type)\n        self.bert = get_tokenlizer.get_pretrained_language_model(text_encoder_type)\n        self.bert.pooler.dense.weight.requires_grad_(False)\n        self.bert.pooler.dense.bias.requires_grad_(False)\n        self.bert = BertModelWarper(bert_model=self.bert)\n\n        self.feat_map = nn.Linear(self.bert.config.hidden_size, self.hidden_dim, bias=True)\n        nn.init.constant_(self.feat_map.bias.data, 0)\n        nn.init.xavier_uniform_(self.feat_map.weight.data)\n        # freeze\n\n        # special tokens\n        self.specical_tokens = self.tokenizer.convert_tokens_to_ids([\"[CLS]\", \"[SEP]\", \".\", \"?\"])\n\n        # prepare input projection layers\n        if num_feature_levels > 1:\n            num_backbone_outs = len(backbone.num_channels)\n            input_proj_list = []\n            for _ in range(num_backbone_outs):\n                in_channels = backbone.num_channels[_]\n                input_proj_list.append(\n                    nn.Sequential(\n                        nn.Conv2d(in_channels, hidden_dim, kernel_size=1),\n                        nn.GroupNorm(32, hidden_dim),\n                    )\n                )\n            for _ in range(num_feature_levels - num_backbone_outs):\n                input_proj_list.append(\n                    nn.Sequential(\n                        nn.Conv2d(in_channels, hidden_dim, kernel_size=3, stride=2, padding=1),\n                        nn.GroupNorm(32, hidden_dim),\n                    )\n                )\n                in_channels = hidden_dim\n            self.input_proj = nn.ModuleList(input_proj_list)\n        else:\n            assert two_stage_type == \"no\", \"two_stage_type should be no if num_feature_levels=1 !!!\"\n            self.input_proj = nn.ModuleList(\n                [\n                    nn.Sequential(\n                        nn.Conv2d(backbone.num_channels[-1], hidden_dim, kernel_size=1),\n                        nn.GroupNorm(32, hidden_dim),\n                    )\n                ]\n            )\n\n        self.backbone = backbone\n        self.aux_loss = aux_loss\n        self.box_pred_damping = box_pred_damping = None\n\n        self.iter_update = iter_update\n        assert iter_update, \"Why not iter_update?\"\n\n        # prepare pred layers\n        self.dec_pred_bbox_embed_share = dec_pred_bbox_embed_share\n        # prepare class & box embed\n        _class_embed = ContrastiveEmbed()\n\n        _bbox_embed = MLP(hidden_dim, hidden_dim, 4, 3)\n        nn.init.constant_(_bbox_embed.layers[-1].weight.data, 0)\n        nn.init.constant_(_bbox_embed.layers[-1].bias.data, 0)\n\n        if dec_pred_bbox_embed_share:\n            box_embed_layerlist = [_bbox_embed for i in range(transformer.num_decoder_layers)]\n        else:\n            box_embed_layerlist = [\n                copy.deepcopy(_bbox_embed) for i in range(transformer.num_decoder_layers)\n            ]\n        class_embed_layerlist = [_class_embed for i in range(transformer.num_decoder_layers)]\n        self.bbox_embed = nn.ModuleList(box_embed_layerlist)\n        self.class_embed = nn.ModuleList(class_embed_layerlist)\n        self.transformer.decoder.bbox_embed = self.bbox_embed\n        self.transformer.decoder.class_embed = self.class_embed\n\n        # two stage\n        self.two_stage_type = two_stage_type\n        assert two_stage_type in [\"no\", \"standard\"], \"unknown param {} of two_stage_type\".format(\n            two_stage_type\n        )\n        if two_stage_type != \"no\":\n            if two_stage_bbox_embed_share:\n                assert dec_pred_bbox_embed_share\n                self.transformer.enc_out_bbox_embed = _bbox_embed\n            else:\n                self.transformer.enc_out_bbox_embed = copy.deepcopy(_bbox_embed)\n\n            if two_stage_class_embed_share:\n                assert dec_pred_bbox_embed_share\n                self.transformer.enc_out_class_embed = _class_embed\n            else:\n                self.transformer.enc_out_class_embed = copy.deepcopy(_class_embed)\n\n            self.refpoint_embed = None\n\n        self._reset_parameters()\n\n    def _reset_parameters(self):\n        # init input_proj\n        for proj in self.input_proj:\n            nn.init.xavier_uniform_(proj[0].weight, gain=1)\n            nn.init.constant_(proj[0].bias, 0)\n\n    def init_ref_points(self, use_num_queries):\n        self.refpoint_embed = nn.Embedding(use_num_queries, self.query_dim)\n\n    def forward(self, samples: NestedTensor, targets: List = None, **kw):\n        \"\"\"The forward expects a NestedTensor, which consists of:\n           - samples.tensor: batched images, of shape [batch_size x 3 x H x W]\n           - samples.mask: a binary mask of shape [batch_size x H x W], containing 1 on padded pixels\n\n        It returns a dict with the following elements:\n           - \"pred_logits\": the classification logits (including no-object) for all queries.\n                            Shape= [batch_size x num_queries x num_classes]\n           - \"pred_boxes\": The normalized boxes coordinates for all queries, represented as\n                           (center_x, center_y, width, height). These values are normalized in [0, 1],\n                           relative to the size of each individual image (disregarding possible padding).\n                           See PostProcess for information on how to retrieve the unnormalized bounding box.\n           - \"aux_outputs\": Optional, only returned when auxilary losses are activated. It is a list of\n                            dictionnaries containing the two above keys for each decoder layer.\n        \"\"\"\n        if targets is None:\n            captions = kw[\"captions\"]\n        else:\n            captions = [t[\"caption\"] for t in targets]\n        len(captions)\n\n        # encoder texts\n        tokenized = self.tokenizer(captions, padding=\"longest\", return_tensors=\"pt\").to(\n            samples.device\n        )\n        (\n            text_self_attention_masks,\n            position_ids,\n            cate_to_token_mask_list,\n        ) = generate_masks_with_special_tokens_and_transfer_map(\n            tokenized, self.specical_tokens, self.tokenizer\n        )\n\n        if text_self_attention_masks.shape[1] > self.max_text_len:\n            text_self_attention_masks = text_self_attention_masks[\n                :, : self.max_text_len, : self.max_text_len\n            ]\n            position_ids = position_ids[:, : self.max_text_len]\n            tokenized[\"input_ids\"] = tokenized[\"input_ids\"][:, : self.max_text_len]\n            tokenized[\"attention_mask\"] = tokenized[\"attention_mask\"][:, : self.max_text_len]\n            tokenized[\"token_type_ids\"] = tokenized[\"token_type_ids\"][:, : self.max_text_len]\n\n        # extract text embeddings\n        if self.sub_sentence_present:\n            tokenized_for_encoder = {k: v for k, v in tokenized.items() if k != \"attention_mask\"}\n            tokenized_for_encoder[\"attention_mask\"] = text_self_attention_masks\n            tokenized_for_encoder[\"position_ids\"] = position_ids\n        else:\n            # import ipdb; ipdb.set_trace()\n            tokenized_for_encoder = tokenized\n\n        bert_output = self.bert(**tokenized_for_encoder)  # bs, 195, 768\n\n        encoded_text = self.feat_map(bert_output[\"last_hidden_state\"])  # bs, 195, d_model\n        text_token_mask = tokenized.attention_mask.bool()  # bs, 195\n        # text_token_mask: True for nomask, False for mask\n        # text_self_attention_masks: True for nomask, False for mask\n\n        if encoded_text.shape[1] > self.max_text_len:\n            encoded_text = encoded_text[:, : self.max_text_len, :]\n            text_token_mask = text_token_mask[:, : self.max_text_len]\n            position_ids = position_ids[:, : self.max_text_len]\n            text_self_attention_masks = text_self_attention_masks[\n                :, : self.max_text_len, : self.max_text_len\n            ]\n\n        text_dict = {\n            \"encoded_text\": encoded_text,  # bs, 195, d_model\n            \"text_token_mask\": text_token_mask,  # bs, 195\n            \"position_ids\": position_ids,  # bs, 195\n            \"text_self_attention_masks\": text_self_attention_masks,  # bs, 195,195\n        }\n\n        # import ipdb; ipdb.set_trace()\n\n        if isinstance(samples, (list, torch.Tensor)):\n            samples = nested_tensor_from_tensor_list(samples)\n        features, poss = self.backbone(samples)\n\n        srcs = []\n        masks = []\n        for l, feat in enumerate(features):\n            src, mask = feat.decompose()\n            srcs.append(self.input_proj[l](src))\n            masks.append(mask)\n            assert mask is not None\n        if self.num_feature_levels > len(srcs):\n            _len_srcs = len(srcs)\n            for l in range(_len_srcs, self.num_feature_levels):\n                if l == _len_srcs:\n                    src = self.input_proj[l](features[-1].tensors)\n                else:\n                    src = self.input_proj[l](srcs[-1])\n                m = samples.mask\n                mask = F.interpolate(m[None].float(), size=src.shape[-2:]).to(torch.bool)[0]\n                pos_l = self.backbone[1](NestedTensor(src, mask)).to(src.dtype)\n                srcs.append(src)\n                masks.append(mask)\n                poss.append(pos_l)\n\n        input_query_bbox = input_query_label = attn_mask = dn_meta = None\n        hs, reference, hs_enc, ref_enc, init_box_proposal = self.transformer(\n            srcs, masks, input_query_bbox, poss, input_query_label, attn_mask, text_dict\n        )\n\n        # deformable-detr-like anchor update\n        outputs_coord_list = []\n        for dec_lid, (layer_ref_sig, layer_bbox_embed, layer_hs) in enumerate(\n            zip(reference[:-1], self.bbox_embed, hs)\n        ):\n            layer_delta_unsig = layer_bbox_embed(layer_hs)\n            layer_outputs_unsig = layer_delta_unsig + inverse_sigmoid(layer_ref_sig)\n            layer_outputs_unsig = layer_outputs_unsig.sigmoid()\n            outputs_coord_list.append(layer_outputs_unsig)\n        outputs_coord_list = torch.stack(outputs_coord_list)\n\n        # output\n        outputs_class = torch.stack(\n            [\n                layer_cls_embed(layer_hs, text_dict)\n                for layer_cls_embed, layer_hs in zip(self.class_embed, hs)\n            ]\n        )\n        out = {\"pred_logits\": outputs_class[-1], \"pred_boxes\": outputs_coord_list[-1]}\n\n        # # for intermediate outputs\n        # if self.aux_loss:\n        #     out['aux_outputs'] = self._set_aux_loss(outputs_class, outputs_coord_list)\n\n        # # for encoder output\n        # if hs_enc is not None:\n        #     # prepare intermediate outputs\n        #     interm_coord = ref_enc[-1]\n        #     interm_class = self.transformer.enc_out_class_embed(hs_enc[-1], text_dict)\n        #     out['interm_outputs'] = {'pred_logits': interm_class, 'pred_boxes': interm_coord}\n        #     out['interm_outputs_for_matching_pre'] = {'pred_logits': interm_class, 'pred_boxes': init_box_proposal}\n\n        return out\n\n    @torch.jit.unused\n    def _set_aux_loss(self, outputs_class, outputs_coord):\n        # this is a workaround to make torchscript happy, as torchscript\n        # doesn't support dictionary with non-homogeneous values, such\n        # as a dict having both a Tensor and a list.\n        return [\n            {\"pred_logits\": a, \"pred_boxes\": b}\n            for a, b in zip(outputs_class[:-1], outputs_coord[:-1])\n        ]", "class GroundingDINO(nn.Module):\n    \"\"\"This is the Cross-Attention Detector module that performs object detection\"\"\"\n\n    def __init__(\n        self,\n        backbone,\n        transformer,\n        num_queries,\n        aux_loss=False,\n        iter_update=False,\n        query_dim=2,\n        num_feature_levels=1,\n        nheads=8,\n        # two stage\n        two_stage_type=\"no\",  # ['no', 'standard']\n        dec_pred_bbox_embed_share=True,\n        two_stage_class_embed_share=True,\n        two_stage_bbox_embed_share=True,\n        num_patterns=0,\n        dn_number=100,\n        dn_box_noise_scale=0.4,\n        dn_label_noise_ratio=0.5,\n        dn_labelbook_size=100,\n        text_encoder_type=\"bert-base-uncased\",\n        sub_sentence_present=True,\n        max_text_len=256,\n    ):\n        \"\"\"Initializes the model.\n        Parameters:\n            backbone: torch module of the backbone to be used. See backbone.py\n            transformer: torch module of the transformer architecture. See transformer.py\n            num_queries: number of object queries, ie detection slot. This is the maximal number of objects\n                         Conditional DETR can detect in a single image. For COCO, we recommend 100 queries.\n            aux_loss: True if auxiliary decoding losses (loss at each decoder layer) are to be used.\n        \"\"\"\n        super().__init__()\n        self.num_queries = num_queries\n        self.transformer = transformer\n        self.hidden_dim = hidden_dim = transformer.d_model\n        self.num_feature_levels = num_feature_levels\n        self.nheads = nheads\n        self.max_text_len = 256\n        self.sub_sentence_present = sub_sentence_present\n\n        # setting query dim\n        self.query_dim = query_dim\n        assert query_dim == 4\n\n        # for dn training\n        self.num_patterns = num_patterns\n        self.dn_number = dn_number\n        self.dn_box_noise_scale = dn_box_noise_scale\n        self.dn_label_noise_ratio = dn_label_noise_ratio\n        self.dn_labelbook_size = dn_labelbook_size\n\n        # bert\n        self.tokenizer = get_tokenlizer.get_tokenlizer(text_encoder_type)\n        self.bert = get_tokenlizer.get_pretrained_language_model(text_encoder_type)\n        self.bert.pooler.dense.weight.requires_grad_(False)\n        self.bert.pooler.dense.bias.requires_grad_(False)\n        self.bert = BertModelWarper(bert_model=self.bert)\n\n        self.feat_map = nn.Linear(self.bert.config.hidden_size, self.hidden_dim, bias=True)\n        nn.init.constant_(self.feat_map.bias.data, 0)\n        nn.init.xavier_uniform_(self.feat_map.weight.data)\n        # freeze\n\n        # special tokens\n        self.specical_tokens = self.tokenizer.convert_tokens_to_ids([\"[CLS]\", \"[SEP]\", \".\", \"?\"])\n\n        # prepare input projection layers\n        if num_feature_levels > 1:\n            num_backbone_outs = len(backbone.num_channels)\n            input_proj_list = []\n            for _ in range(num_backbone_outs):\n                in_channels = backbone.num_channels[_]\n                input_proj_list.append(\n                    nn.Sequential(\n                        nn.Conv2d(in_channels, hidden_dim, kernel_size=1),\n                        nn.GroupNorm(32, hidden_dim),\n                    )\n                )\n            for _ in range(num_feature_levels - num_backbone_outs):\n                input_proj_list.append(\n                    nn.Sequential(\n                        nn.Conv2d(in_channels, hidden_dim, kernel_size=3, stride=2, padding=1),\n                        nn.GroupNorm(32, hidden_dim),\n                    )\n                )\n                in_channels = hidden_dim\n            self.input_proj = nn.ModuleList(input_proj_list)\n        else:\n            assert two_stage_type == \"no\", \"two_stage_type should be no if num_feature_levels=1 !!!\"\n            self.input_proj = nn.ModuleList(\n                [\n                    nn.Sequential(\n                        nn.Conv2d(backbone.num_channels[-1], hidden_dim, kernel_size=1),\n                        nn.GroupNorm(32, hidden_dim),\n                    )\n                ]\n            )\n\n        self.backbone = backbone\n        self.aux_loss = aux_loss\n        self.box_pred_damping = box_pred_damping = None\n\n        self.iter_update = iter_update\n        assert iter_update, \"Why not iter_update?\"\n\n        # prepare pred layers\n        self.dec_pred_bbox_embed_share = dec_pred_bbox_embed_share\n        # prepare class & box embed\n        _class_embed = ContrastiveEmbed()\n\n        _bbox_embed = MLP(hidden_dim, hidden_dim, 4, 3)\n        nn.init.constant_(_bbox_embed.layers[-1].weight.data, 0)\n        nn.init.constant_(_bbox_embed.layers[-1].bias.data, 0)\n\n        if dec_pred_bbox_embed_share:\n            box_embed_layerlist = [_bbox_embed for i in range(transformer.num_decoder_layers)]\n        else:\n            box_embed_layerlist = [\n                copy.deepcopy(_bbox_embed) for i in range(transformer.num_decoder_layers)\n            ]\n        class_embed_layerlist = [_class_embed for i in range(transformer.num_decoder_layers)]\n        self.bbox_embed = nn.ModuleList(box_embed_layerlist)\n        self.class_embed = nn.ModuleList(class_embed_layerlist)\n        self.transformer.decoder.bbox_embed = self.bbox_embed\n        self.transformer.decoder.class_embed = self.class_embed\n\n        # two stage\n        self.two_stage_type = two_stage_type\n        assert two_stage_type in [\"no\", \"standard\"], \"unknown param {} of two_stage_type\".format(\n            two_stage_type\n        )\n        if two_stage_type != \"no\":\n            if two_stage_bbox_embed_share:\n                assert dec_pred_bbox_embed_share\n                self.transformer.enc_out_bbox_embed = _bbox_embed\n            else:\n                self.transformer.enc_out_bbox_embed = copy.deepcopy(_bbox_embed)\n\n            if two_stage_class_embed_share:\n                assert dec_pred_bbox_embed_share\n                self.transformer.enc_out_class_embed = _class_embed\n            else:\n                self.transformer.enc_out_class_embed = copy.deepcopy(_class_embed)\n\n            self.refpoint_embed = None\n\n        self._reset_parameters()\n\n    def _reset_parameters(self):\n        # init input_proj\n        for proj in self.input_proj:\n            nn.init.xavier_uniform_(proj[0].weight, gain=1)\n            nn.init.constant_(proj[0].bias, 0)\n\n    def init_ref_points(self, use_num_queries):\n        self.refpoint_embed = nn.Embedding(use_num_queries, self.query_dim)\n\n    def forward(self, samples: NestedTensor, targets: List = None, **kw):\n        \"\"\"The forward expects a NestedTensor, which consists of:\n           - samples.tensor: batched images, of shape [batch_size x 3 x H x W]\n           - samples.mask: a binary mask of shape [batch_size x H x W], containing 1 on padded pixels\n\n        It returns a dict with the following elements:\n           - \"pred_logits\": the classification logits (including no-object) for all queries.\n                            Shape= [batch_size x num_queries x num_classes]\n           - \"pred_boxes\": The normalized boxes coordinates for all queries, represented as\n                           (center_x, center_y, width, height). These values are normalized in [0, 1],\n                           relative to the size of each individual image (disregarding possible padding).\n                           See PostProcess for information on how to retrieve the unnormalized bounding box.\n           - \"aux_outputs\": Optional, only returned when auxilary losses are activated. It is a list of\n                            dictionnaries containing the two above keys for each decoder layer.\n        \"\"\"\n        if targets is None:\n            captions = kw[\"captions\"]\n        else:\n            captions = [t[\"caption\"] for t in targets]\n        len(captions)\n\n        # encoder texts\n        tokenized = self.tokenizer(captions, padding=\"longest\", return_tensors=\"pt\").to(\n            samples.device\n        )\n        (\n            text_self_attention_masks,\n            position_ids,\n            cate_to_token_mask_list,\n        ) = generate_masks_with_special_tokens_and_transfer_map(\n            tokenized, self.specical_tokens, self.tokenizer\n        )\n\n        if text_self_attention_masks.shape[1] > self.max_text_len:\n            text_self_attention_masks = text_self_attention_masks[\n                :, : self.max_text_len, : self.max_text_len\n            ]\n            position_ids = position_ids[:, : self.max_text_len]\n            tokenized[\"input_ids\"] = tokenized[\"input_ids\"][:, : self.max_text_len]\n            tokenized[\"attention_mask\"] = tokenized[\"attention_mask\"][:, : self.max_text_len]\n            tokenized[\"token_type_ids\"] = tokenized[\"token_type_ids\"][:, : self.max_text_len]\n\n        # extract text embeddings\n        if self.sub_sentence_present:\n            tokenized_for_encoder = {k: v for k, v in tokenized.items() if k != \"attention_mask\"}\n            tokenized_for_encoder[\"attention_mask\"] = text_self_attention_masks\n            tokenized_for_encoder[\"position_ids\"] = position_ids\n        else:\n            # import ipdb; ipdb.set_trace()\n            tokenized_for_encoder = tokenized\n\n        bert_output = self.bert(**tokenized_for_encoder)  # bs, 195, 768\n\n        encoded_text = self.feat_map(bert_output[\"last_hidden_state\"])  # bs, 195, d_model\n        text_token_mask = tokenized.attention_mask.bool()  # bs, 195\n        # text_token_mask: True for nomask, False for mask\n        # text_self_attention_masks: True for nomask, False for mask\n\n        if encoded_text.shape[1] > self.max_text_len:\n            encoded_text = encoded_text[:, : self.max_text_len, :]\n            text_token_mask = text_token_mask[:, : self.max_text_len]\n            position_ids = position_ids[:, : self.max_text_len]\n            text_self_attention_masks = text_self_attention_masks[\n                :, : self.max_text_len, : self.max_text_len\n            ]\n\n        text_dict = {\n            \"encoded_text\": encoded_text,  # bs, 195, d_model\n            \"text_token_mask\": text_token_mask,  # bs, 195\n            \"position_ids\": position_ids,  # bs, 195\n            \"text_self_attention_masks\": text_self_attention_masks,  # bs, 195,195\n        }\n\n        # import ipdb; ipdb.set_trace()\n\n        if isinstance(samples, (list, torch.Tensor)):\n            samples = nested_tensor_from_tensor_list(samples)\n        features, poss = self.backbone(samples)\n\n        srcs = []\n        masks = []\n        for l, feat in enumerate(features):\n            src, mask = feat.decompose()\n            srcs.append(self.input_proj[l](src))\n            masks.append(mask)\n            assert mask is not None\n        if self.num_feature_levels > len(srcs):\n            _len_srcs = len(srcs)\n            for l in range(_len_srcs, self.num_feature_levels):\n                if l == _len_srcs:\n                    src = self.input_proj[l](features[-1].tensors)\n                else:\n                    src = self.input_proj[l](srcs[-1])\n                m = samples.mask\n                mask = F.interpolate(m[None].float(), size=src.shape[-2:]).to(torch.bool)[0]\n                pos_l = self.backbone[1](NestedTensor(src, mask)).to(src.dtype)\n                srcs.append(src)\n                masks.append(mask)\n                poss.append(pos_l)\n\n        input_query_bbox = input_query_label = attn_mask = dn_meta = None\n        hs, reference, hs_enc, ref_enc, init_box_proposal = self.transformer(\n            srcs, masks, input_query_bbox, poss, input_query_label, attn_mask, text_dict\n        )\n\n        # deformable-detr-like anchor update\n        outputs_coord_list = []\n        for dec_lid, (layer_ref_sig, layer_bbox_embed, layer_hs) in enumerate(\n            zip(reference[:-1], self.bbox_embed, hs)\n        ):\n            layer_delta_unsig = layer_bbox_embed(layer_hs)\n            layer_outputs_unsig = layer_delta_unsig + inverse_sigmoid(layer_ref_sig)\n            layer_outputs_unsig = layer_outputs_unsig.sigmoid()\n            outputs_coord_list.append(layer_outputs_unsig)\n        outputs_coord_list = torch.stack(outputs_coord_list)\n\n        # output\n        outputs_class = torch.stack(\n            [\n                layer_cls_embed(layer_hs, text_dict)\n                for layer_cls_embed, layer_hs in zip(self.class_embed, hs)\n            ]\n        )\n        out = {\"pred_logits\": outputs_class[-1], \"pred_boxes\": outputs_coord_list[-1]}\n\n        # # for intermediate outputs\n        # if self.aux_loss:\n        #     out['aux_outputs'] = self._set_aux_loss(outputs_class, outputs_coord_list)\n\n        # # for encoder output\n        # if hs_enc is not None:\n        #     # prepare intermediate outputs\n        #     interm_coord = ref_enc[-1]\n        #     interm_class = self.transformer.enc_out_class_embed(hs_enc[-1], text_dict)\n        #     out['interm_outputs'] = {'pred_logits': interm_class, 'pred_boxes': interm_coord}\n        #     out['interm_outputs_for_matching_pre'] = {'pred_logits': interm_class, 'pred_boxes': init_box_proposal}\n\n        return out\n\n    @torch.jit.unused\n    def _set_aux_loss(self, outputs_class, outputs_coord):\n        # this is a workaround to make torchscript happy, as torchscript\n        # doesn't support dictionary with non-homogeneous values, such\n        # as a dict having both a Tensor and a list.\n        return [\n            {\"pred_logits\": a, \"pred_boxes\": b}\n            for a, b in zip(outputs_class[:-1], outputs_coord[:-1])\n        ]", "\n\n@MODULE_BUILD_FUNCS.registe_with_name(module_name=\"groundingdino\")\ndef build_groundingdino(args):\n\n    backbone = build_backbone(args)\n    transformer = build_transformer(args)\n\n    dn_labelbook_size = args.dn_labelbook_size\n    dec_pred_bbox_embed_share = args.dec_pred_bbox_embed_share\n    sub_sentence_present = args.sub_sentence_present\n\n    model = GroundingDINO(\n        backbone,\n        transformer,\n        num_queries=args.num_queries,\n        aux_loss=True,\n        iter_update=True,\n        query_dim=4,\n        num_feature_levels=args.num_feature_levels,\n        nheads=args.nheads,\n        dec_pred_bbox_embed_share=dec_pred_bbox_embed_share,\n        two_stage_type=args.two_stage_type,\n        two_stage_bbox_embed_share=args.two_stage_bbox_embed_share,\n        two_stage_class_embed_share=args.two_stage_class_embed_share,\n        num_patterns=args.num_patterns,\n        dn_number=0,\n        dn_box_noise_scale=args.dn_box_noise_scale,\n        dn_label_noise_ratio=args.dn_label_noise_ratio,\n        dn_labelbook_size=dn_labelbook_size,\n        text_encoder_type=args.text_encoder_type,\n        sub_sentence_present=sub_sentence_present,\n        max_text_len=args.max_text_len,\n    )\n\n    return model", ""]}
{"filename": "local_groundingdino/models/GroundingDINO/backbone/swin_transformer.py", "chunked_list": ["# ------------------------------------------------------------------------\n# Grounding DINO\n# url: https://github.com/IDEA-Research/GroundingDINO\n# Copyright (c) 2023 IDEA. All Rights Reserved.\n# Licensed under the Apache License, Version 2.0 [see LICENSE for details]\n# ------------------------------------------------------------------------\n# DINO\n# Copyright (c) 2022 IDEA. All Rights Reserved.\n# Licensed under the Apache License, Version 2.0 [see LICENSE for details]\n# --------------------------------------------------------", "# Licensed under the Apache License, Version 2.0 [see LICENSE for details]\n# --------------------------------------------------------\n# modified from https://github.com/SwinTransformer/Swin-Transformer-Object-Detection/blob/master/mmdet/models/backbones/swin_transformer.py\n# --------------------------------------------------------\n\nimport numpy as np\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.utils.checkpoint as checkpoint", "import torch.nn.functional as F\nimport torch.utils.checkpoint as checkpoint\nfrom timm.models.layers import DropPath, to_2tuple, trunc_normal_\n\nfrom local_groundingdino.util.misc import NestedTensor\n\n\nclass Mlp(nn.Module):\n    \"\"\"Multilayer perceptron.\"\"\"\n\n    def __init__(\n        self, in_features, hidden_features=None, out_features=None, act_layer=nn.GELU, drop=0.0\n    ):\n        super().__init__()\n        out_features = out_features or in_features\n        hidden_features = hidden_features or in_features\n        self.fc1 = nn.Linear(in_features, hidden_features)\n        self.act = act_layer()\n        self.fc2 = nn.Linear(hidden_features, out_features)\n        self.drop = nn.Dropout(drop)\n\n    def forward(self, x):\n        x = self.fc1(x)\n        x = self.act(x)\n        x = self.drop(x)\n        x = self.fc2(x)\n        x = self.drop(x)\n        return x", "\n\ndef window_partition(x, window_size):\n    \"\"\"\n    Args:\n        x: (B, H, W, C)\n        window_size (int): window size\n    Returns:\n        windows: (num_windows*B, window_size, window_size, C)\n    \"\"\"\n    B, H, W, C = x.shape\n    x = x.view(B, H // window_size, window_size, W // window_size, window_size, C)\n    windows = x.permute(0, 1, 3, 2, 4, 5).contiguous().view(-1, window_size, window_size, C)\n    return windows", "\n\ndef window_reverse(windows, window_size, H, W):\n    \"\"\"\n    Args:\n        windows: (num_windows*B, window_size, window_size, C)\n        window_size (int): Window size\n        H (int): Height of image\n        W (int): Width of image\n    Returns:\n        x: (B, H, W, C)\n    \"\"\"\n    B = int(windows.shape[0] / (H * W / window_size / window_size))\n    x = windows.view(B, H // window_size, W // window_size, window_size, window_size, -1)\n    x = x.permute(0, 1, 3, 2, 4, 5).contiguous().view(B, H, W, -1)\n    return x", "\n\nclass WindowAttention(nn.Module):\n    \"\"\"Window based multi-head self attention (W-MSA) module with relative position bias.\n    It supports both of shifted and non-shifted window.\n    Args:\n        dim (int): Number of input channels.\n        window_size (tuple[int]): The height and width of the window.\n        num_heads (int): Number of attention heads.\n        qkv_bias (bool, optional):  If True, add a learnable bias to query, key, value. Default: True\n        qk_scale (float | None, optional): Override default qk scale of head_dim ** -0.5 if set\n        attn_drop (float, optional): Dropout ratio of attention weight. Default: 0.0\n        proj_drop (float, optional): Dropout ratio of output. Default: 0.0\n    \"\"\"\n\n    def __init__(\n        self,\n        dim,\n        window_size,\n        num_heads,\n        qkv_bias=True,\n        qk_scale=None,\n        attn_drop=0.0,\n        proj_drop=0.0,\n    ):\n\n        super().__init__()\n        self.dim = dim\n        self.window_size = window_size  # Wh, Ww\n        self.num_heads = num_heads\n        head_dim = dim // num_heads\n        self.scale = qk_scale or head_dim**-0.5\n\n        # define a parameter table of relative position bias\n        self.relative_position_bias_table = nn.Parameter(\n            torch.zeros((2 * window_size[0] - 1) * (2 * window_size[1] - 1), num_heads)\n        )  # 2*Wh-1 * 2*Ww-1, nH\n\n        # get pair-wise relative position index for each token inside the window\n        coords_h = torch.arange(self.window_size[0])\n        coords_w = torch.arange(self.window_size[1])\n        coords = torch.stack(torch.meshgrid([coords_h, coords_w]))  # 2, Wh, Ww\n        coords_flatten = torch.flatten(coords, 1)  # 2, Wh*Ww\n        relative_coords = coords_flatten[:, :, None] - coords_flatten[:, None, :]  # 2, Wh*Ww, Wh*Ww\n        relative_coords = relative_coords.permute(1, 2, 0).contiguous()  # Wh*Ww, Wh*Ww, 2\n        relative_coords[:, :, 0] += self.window_size[0] - 1  # shift to start from 0\n        relative_coords[:, :, 1] += self.window_size[1] - 1\n        relative_coords[:, :, 0] *= 2 * self.window_size[1] - 1\n        relative_position_index = relative_coords.sum(-1)  # Wh*Ww, Wh*Ww\n        self.register_buffer(\"relative_position_index\", relative_position_index)\n\n        self.qkv = nn.Linear(dim, dim * 3, bias=qkv_bias)\n        self.attn_drop = nn.Dropout(attn_drop)\n        self.proj = nn.Linear(dim, dim)\n        self.proj_drop = nn.Dropout(proj_drop)\n\n        trunc_normal_(self.relative_position_bias_table, std=0.02)\n        self.softmax = nn.Softmax(dim=-1)\n\n    def forward(self, x, mask=None):\n        \"\"\"Forward function.\n        Args:\n            x: input features with shape of (num_windows*B, N, C)\n            mask: (0/-inf) mask with shape of (num_windows, Wh*Ww, Wh*Ww) or None\n        \"\"\"\n        B_, N, C = x.shape\n        qkv = (\n            self.qkv(x)\n            .reshape(B_, N, 3, self.num_heads, C // self.num_heads)\n            .permute(2, 0, 3, 1, 4)\n        )\n        q, k, v = qkv[0], qkv[1], qkv[2]  # make torchscript happy (cannot use tensor as tuple)\n\n        q = q * self.scale\n        attn = q @ k.transpose(-2, -1)\n\n        relative_position_bias = self.relative_position_bias_table[\n            self.relative_position_index.view(-1)\n        ].view(\n            self.window_size[0] * self.window_size[1], self.window_size[0] * self.window_size[1], -1\n        )  # Wh*Ww,Wh*Ww,nH\n        relative_position_bias = relative_position_bias.permute(\n            2, 0, 1\n        ).contiguous()  # nH, Wh*Ww, Wh*Ww\n        attn = attn + relative_position_bias.unsqueeze(0)\n\n        if mask is not None:\n            nW = mask.shape[0]\n            attn = attn.view(B_ // nW, nW, self.num_heads, N, N) + mask.unsqueeze(1).unsqueeze(0)\n            attn = attn.view(-1, self.num_heads, N, N)\n            attn = self.softmax(attn)\n        else:\n            attn = self.softmax(attn)\n\n        attn = self.attn_drop(attn)\n\n        x = (attn @ v).transpose(1, 2).reshape(B_, N, C)\n        x = self.proj(x)\n        x = self.proj_drop(x)\n        return x", "\n\nclass SwinTransformerBlock(nn.Module):\n    \"\"\"Swin Transformer Block.\n    Args:\n        dim (int): Number of input channels.\n        num_heads (int): Number of attention heads.\n        window_size (int): Window size.\n        shift_size (int): Shift size for SW-MSA.\n        mlp_ratio (float): Ratio of mlp hidden dim to embedding dim.\n        qkv_bias (bool, optional): If True, add a learnable bias to query, key, value. Default: True\n        qk_scale (float | None, optional): Override default qk scale of head_dim ** -0.5 if set.\n        drop (float, optional): Dropout rate. Default: 0.0\n        attn_drop (float, optional): Attention dropout rate. Default: 0.0\n        drop_path (float, optional): Stochastic depth rate. Default: 0.0\n        act_layer (nn.Module, optional): Activation layer. Default: nn.GELU\n        norm_layer (nn.Module, optional): Normalization layer.  Default: nn.LayerNorm\n    \"\"\"\n\n    def __init__(\n        self,\n        dim,\n        num_heads,\n        window_size=7,\n        shift_size=0,\n        mlp_ratio=4.0,\n        qkv_bias=True,\n        qk_scale=None,\n        drop=0.0,\n        attn_drop=0.0,\n        drop_path=0.0,\n        act_layer=nn.GELU,\n        norm_layer=nn.LayerNorm,\n    ):\n        super().__init__()\n        self.dim = dim\n        self.num_heads = num_heads\n        self.window_size = window_size\n        self.shift_size = shift_size\n        self.mlp_ratio = mlp_ratio\n        assert 0 <= self.shift_size < self.window_size, \"shift_size must in 0-window_size\"\n\n        self.norm1 = norm_layer(dim)\n        self.attn = WindowAttention(\n            dim,\n            window_size=to_2tuple(self.window_size),\n            num_heads=num_heads,\n            qkv_bias=qkv_bias,\n            qk_scale=qk_scale,\n            attn_drop=attn_drop,\n            proj_drop=drop,\n        )\n\n        self.drop_path = DropPath(drop_path) if drop_path > 0.0 else nn.Identity()\n        self.norm2 = norm_layer(dim)\n        mlp_hidden_dim = int(dim * mlp_ratio)\n        self.mlp = Mlp(\n            in_features=dim, hidden_features=mlp_hidden_dim, act_layer=act_layer, drop=drop\n        )\n\n        self.H = None\n        self.W = None\n\n    def forward(self, x, mask_matrix):\n        \"\"\"Forward function.\n        Args:\n            x: Input feature, tensor size (B, H*W, C).\n            H, W: Spatial resolution of the input feature.\n            mask_matrix: Attention mask for cyclic shift.\n        \"\"\"\n        B, L, C = x.shape\n        H, W = self.H, self.W\n        assert L == H * W, \"input feature has wrong size\"\n\n        shortcut = x\n        x = self.norm1(x)\n        x = x.view(B, H, W, C)\n\n        # pad feature maps to multiples of window size\n        pad_l = pad_t = 0\n        pad_r = (self.window_size - W % self.window_size) % self.window_size\n        pad_b = (self.window_size - H % self.window_size) % self.window_size\n        x = F.pad(x, (0, 0, pad_l, pad_r, pad_t, pad_b))\n        _, Hp, Wp, _ = x.shape\n\n        # cyclic shift\n        if self.shift_size > 0:\n            shifted_x = torch.roll(x, shifts=(-self.shift_size, -self.shift_size), dims=(1, 2))\n            attn_mask = mask_matrix\n        else:\n            shifted_x = x\n            attn_mask = None\n\n        # partition windows\n        x_windows = window_partition(\n            shifted_x, self.window_size\n        )  # nW*B, window_size, window_size, C\n        x_windows = x_windows.view(\n            -1, self.window_size * self.window_size, C\n        )  # nW*B, window_size*window_size, C\n\n        # W-MSA/SW-MSA\n        attn_windows = self.attn(x_windows, mask=attn_mask)  # nW*B, window_size*window_size, C\n\n        # merge windows\n        attn_windows = attn_windows.view(-1, self.window_size, self.window_size, C)\n        shifted_x = window_reverse(attn_windows, self.window_size, Hp, Wp)  # B H' W' C\n\n        # reverse cyclic shift\n        if self.shift_size > 0:\n            x = torch.roll(shifted_x, shifts=(self.shift_size, self.shift_size), dims=(1, 2))\n        else:\n            x = shifted_x\n\n        if pad_r > 0 or pad_b > 0:\n            x = x[:, :H, :W, :].contiguous()\n\n        x = x.view(B, H * W, C)\n\n        # FFN\n        x = shortcut + self.drop_path(x)\n        x = x + self.drop_path(self.mlp(self.norm2(x)))\n\n        return x", "\n\nclass PatchMerging(nn.Module):\n    \"\"\"Patch Merging Layer\n    Args:\n        dim (int): Number of input channels.\n        norm_layer (nn.Module, optional): Normalization layer.  Default: nn.LayerNorm\n    \"\"\"\n\n    def __init__(self, dim, norm_layer=nn.LayerNorm):\n        super().__init__()\n        self.dim = dim\n        self.reduction = nn.Linear(4 * dim, 2 * dim, bias=False)\n        self.norm = norm_layer(4 * dim)\n\n    def forward(self, x, H, W):\n        \"\"\"Forward function.\n        Args:\n            x: Input feature, tensor size (B, H*W, C).\n            H, W: Spatial resolution of the input feature.\n        \"\"\"\n        B, L, C = x.shape\n        assert L == H * W, \"input feature has wrong size\"\n\n        x = x.view(B, H, W, C)\n\n        # padding\n        pad_input = (H % 2 == 1) or (W % 2 == 1)\n        if pad_input:\n            x = F.pad(x, (0, 0, 0, W % 2, 0, H % 2))\n\n        x0 = x[:, 0::2, 0::2, :]  # B H/2 W/2 C\n        x1 = x[:, 1::2, 0::2, :]  # B H/2 W/2 C\n        x2 = x[:, 0::2, 1::2, :]  # B H/2 W/2 C\n        x3 = x[:, 1::2, 1::2, :]  # B H/2 W/2 C\n        x = torch.cat([x0, x1, x2, x3], -1)  # B H/2 W/2 4*C\n        x = x.view(B, -1, 4 * C)  # B H/2*W/2 4*C\n\n        x = self.norm(x)\n        x = self.reduction(x)\n\n        return x", "\n\nclass BasicLayer(nn.Module):\n    \"\"\"A basic Swin Transformer layer for one stage.\n    Args:\n        dim (int): Number of feature channels\n        depth (int): Depths of this stage.\n        num_heads (int): Number of attention head.\n        window_size (int): Local window size. Default: 7.\n        mlp_ratio (float): Ratio of mlp hidden dim to embedding dim. Default: 4.\n        qkv_bias (bool, optional): If True, add a learnable bias to query, key, value. Default: True\n        qk_scale (float | None, optional): Override default qk scale of head_dim ** -0.5 if set.\n        drop (float, optional): Dropout rate. Default: 0.0\n        attn_drop (float, optional): Attention dropout rate. Default: 0.0\n        drop_path (float | tuple[float], optional): Stochastic depth rate. Default: 0.0\n        norm_layer (nn.Module, optional): Normalization layer. Default: nn.LayerNorm\n        downsample (nn.Module | None, optional): Downsample layer at the end of the layer. Default: None\n        use_checkpoint (bool): Whether to use checkpointing to save memory. Default: False.\n    \"\"\"\n\n    def __init__(\n        self,\n        dim,\n        depth,\n        num_heads,\n        window_size=7,\n        mlp_ratio=4.0,\n        qkv_bias=True,\n        qk_scale=None,\n        drop=0.0,\n        attn_drop=0.0,\n        drop_path=0.0,\n        norm_layer=nn.LayerNorm,\n        downsample=None,\n        use_checkpoint=False,\n    ):\n        super().__init__()\n        self.window_size = window_size\n        self.shift_size = window_size // 2\n        self.depth = depth\n        self.use_checkpoint = use_checkpoint\n\n        # build blocks\n        self.blocks = nn.ModuleList(\n            [\n                SwinTransformerBlock(\n                    dim=dim,\n                    num_heads=num_heads,\n                    window_size=window_size,\n                    shift_size=0 if (i % 2 == 0) else window_size // 2,\n                    mlp_ratio=mlp_ratio,\n                    qkv_bias=qkv_bias,\n                    qk_scale=qk_scale,\n                    drop=drop,\n                    attn_drop=attn_drop,\n                    drop_path=drop_path[i] if isinstance(drop_path, list) else drop_path,\n                    norm_layer=norm_layer,\n                )\n                for i in range(depth)\n            ]\n        )\n\n        # patch merging layer\n        if downsample is not None:\n            self.downsample = downsample(dim=dim, norm_layer=norm_layer)\n        else:\n            self.downsample = None\n\n    def forward(self, x, H, W):\n        \"\"\"Forward function.\n        Args:\n            x: Input feature, tensor size (B, H*W, C).\n            H, W: Spatial resolution of the input feature.\n        \"\"\"\n\n        # calculate attention mask for SW-MSA\n        Hp = int(np.ceil(H / self.window_size)) * self.window_size\n        Wp = int(np.ceil(W / self.window_size)) * self.window_size\n        img_mask = torch.zeros((1, Hp, Wp, 1), device=x.device)  # 1 Hp Wp 1\n        h_slices = (\n            slice(0, -self.window_size),\n            slice(-self.window_size, -self.shift_size),\n            slice(-self.shift_size, None),\n        )\n        w_slices = (\n            slice(0, -self.window_size),\n            slice(-self.window_size, -self.shift_size),\n            slice(-self.shift_size, None),\n        )\n        cnt = 0\n        for h in h_slices:\n            for w in w_slices:\n                img_mask[:, h, w, :] = cnt\n                cnt += 1\n\n        mask_windows = window_partition(\n            img_mask, self.window_size\n        )  # nW, window_size, window_size, 1\n        mask_windows = mask_windows.view(-1, self.window_size * self.window_size)\n        attn_mask = mask_windows.unsqueeze(1) - mask_windows.unsqueeze(2)\n        attn_mask = attn_mask.masked_fill(attn_mask != 0, float(-100.0)).masked_fill(\n            attn_mask == 0, float(0.0)\n        )\n\n        for blk in self.blocks:\n            blk.H, blk.W = H, W\n            if self.use_checkpoint:\n                x = checkpoint.checkpoint(blk, x, attn_mask)\n            else:\n                x = blk(x, attn_mask)\n        if self.downsample is not None:\n            x_down = self.downsample(x, H, W)\n            Wh, Ww = (H + 1) // 2, (W + 1) // 2\n            return x, H, W, x_down, Wh, Ww\n        else:\n            return x, H, W, x, H, W", "\n\nclass PatchEmbed(nn.Module):\n    \"\"\"Image to Patch Embedding\n    Args:\n        patch_size (int): Patch token size. Default: 4.\n        in_chans (int): Number of input image channels. Default: 3.\n        embed_dim (int): Number of linear projection output channels. Default: 96.\n        norm_layer (nn.Module, optional): Normalization layer. Default: None\n    \"\"\"\n\n    def __init__(self, patch_size=4, in_chans=3, embed_dim=96, norm_layer=None):\n        super().__init__()\n        patch_size = to_2tuple(patch_size)\n        self.patch_size = patch_size\n\n        self.in_chans = in_chans\n        self.embed_dim = embed_dim\n\n        self.proj = nn.Conv2d(in_chans, embed_dim, kernel_size=patch_size, stride=patch_size)\n        if norm_layer is not None:\n            self.norm = norm_layer(embed_dim)\n        else:\n            self.norm = None\n\n    def forward(self, x):\n        \"\"\"Forward function.\"\"\"\n        # padding\n        _, _, H, W = x.size()\n        if W % self.patch_size[1] != 0:\n            x = F.pad(x, (0, self.patch_size[1] - W % self.patch_size[1]))\n        if H % self.patch_size[0] != 0:\n            x = F.pad(x, (0, 0, 0, self.patch_size[0] - H % self.patch_size[0]))\n\n        x = self.proj(x)  # B C Wh Ww\n        if self.norm is not None:\n            Wh, Ww = x.size(2), x.size(3)\n            x = x.flatten(2).transpose(1, 2)\n            x = self.norm(x)\n            x = x.transpose(1, 2).view(-1, self.embed_dim, Wh, Ww)\n\n        return x", "\n\nclass SwinTransformer(nn.Module):\n    \"\"\"Swin Transformer backbone.\n        A PyTorch impl of : `Swin Transformer: Hierarchical Vision Transformer using Shifted Windows`  -\n          https://arxiv.org/pdf/2103.14030\n    Args:\n        pretrain_img_size (int): Input image size for training the pretrained model,\n            used in absolute postion embedding. Default 224.\n        patch_size (int | tuple(int)): Patch size. Default: 4.\n        in_chans (int): Number of input image channels. Default: 3.\n        embed_dim (int): Number of linear projection output channels. Default: 96.\n        depths (tuple[int]): Depths of each Swin Transformer stage.\n        num_heads (tuple[int]): Number of attention head of each stage.\n        window_size (int): Window size. Default: 7.\n        mlp_ratio (float): Ratio of mlp hidden dim to embedding dim. Default: 4.\n        qkv_bias (bool): If True, add a learnable bias to query, key, value. Default: True\n        qk_scale (float): Override default qk scale of head_dim ** -0.5 if set.\n        drop_rate (float): Dropout rate.\n        attn_drop_rate (float): Attention dropout rate. Default: 0.\n        drop_path_rate (float): Stochastic depth rate. Default: 0.2.\n        norm_layer (nn.Module): Normalization layer. Default: nn.LayerNorm.\n        ape (bool): If True, add absolute position embedding to the patch embedding. Default: False.\n        patch_norm (bool): If True, add normalization after patch embedding. Default: True.\n        out_indices (Sequence[int]): Output from which stages.\n        frozen_stages (int): Stages to be frozen (stop grad and set eval mode).\n            -1 means not freezing any parameters.\n        use_checkpoint (bool): Whether to use checkpointing to save memory. Default: False.\n        dilation (bool): if True, the output size if 16x downsample, ow 32x downsample.\n    \"\"\"\n\n    def __init__(\n        self,\n        pretrain_img_size=224,\n        patch_size=4,\n        in_chans=3,\n        embed_dim=96,\n        depths=[2, 2, 6, 2],\n        num_heads=[3, 6, 12, 24],\n        window_size=7,\n        mlp_ratio=4.0,\n        qkv_bias=True,\n        qk_scale=None,\n        drop_rate=0.0,\n        attn_drop_rate=0.0,\n        drop_path_rate=0.2,\n        norm_layer=nn.LayerNorm,\n        ape=False,\n        patch_norm=True,\n        out_indices=(0, 1, 2, 3),\n        frozen_stages=-1,\n        dilation=False,\n        use_checkpoint=False,\n    ):\n        super().__init__()\n\n        self.pretrain_img_size = pretrain_img_size\n        self.num_layers = len(depths)\n        self.embed_dim = embed_dim\n        self.ape = ape\n        self.patch_norm = patch_norm\n        self.out_indices = out_indices\n        self.frozen_stages = frozen_stages\n        self.dilation = dilation\n\n        # if use_checkpoint:\n        #     print(\"use_checkpoint!!!!!!!!!!!!!!!!!!!!!!!!\")\n\n        # split image into non-overlapping patches\n        self.patch_embed = PatchEmbed(\n            patch_size=patch_size,\n            in_chans=in_chans,\n            embed_dim=embed_dim,\n            norm_layer=norm_layer if self.patch_norm else None,\n        )\n\n        # absolute position embedding\n        if self.ape:\n            pretrain_img_size = to_2tuple(pretrain_img_size)\n            patch_size = to_2tuple(patch_size)\n            patches_resolution = [\n                pretrain_img_size[0] // patch_size[0],\n                pretrain_img_size[1] // patch_size[1],\n            ]\n\n            self.absolute_pos_embed = nn.Parameter(\n                torch.zeros(1, embed_dim, patches_resolution[0], patches_resolution[1])\n            )\n            trunc_normal_(self.absolute_pos_embed, std=0.02)\n\n        self.pos_drop = nn.Dropout(p=drop_rate)\n\n        # stochastic depth\n        dpr = [\n            x.item() for x in torch.linspace(0, drop_path_rate, sum(depths))\n        ]  # stochastic depth decay rule\n\n        # build layers\n        self.layers = nn.ModuleList()\n        # prepare downsample list\n        downsamplelist = [PatchMerging for i in range(self.num_layers)]\n        downsamplelist[-1] = None\n        num_features = [int(embed_dim * 2**i) for i in range(self.num_layers)]\n        if self.dilation:\n            downsamplelist[-2] = None\n            num_features[-1] = int(embed_dim * 2 ** (self.num_layers - 1)) // 2\n        for i_layer in range(self.num_layers):\n            layer = BasicLayer(\n                # dim=int(embed_dim * 2 ** i_layer),\n                dim=num_features[i_layer],\n                depth=depths[i_layer],\n                num_heads=num_heads[i_layer],\n                window_size=window_size,\n                mlp_ratio=mlp_ratio,\n                qkv_bias=qkv_bias,\n                qk_scale=qk_scale,\n                drop=drop_rate,\n                attn_drop=attn_drop_rate,\n                drop_path=dpr[sum(depths[:i_layer]) : sum(depths[: i_layer + 1])],\n                norm_layer=norm_layer,\n                # downsample=PatchMerging if (i_layer < self.num_layers - 1) else None,\n                downsample=downsamplelist[i_layer],\n                use_checkpoint=use_checkpoint,\n            )\n            self.layers.append(layer)\n\n        # num_features = [int(embed_dim * 2 ** i) for i in range(self.num_layers)]\n        self.num_features = num_features\n\n        # add a norm layer for each output\n        for i_layer in out_indices:\n            layer = norm_layer(num_features[i_layer])\n            layer_name = f\"norm{i_layer}\"\n            self.add_module(layer_name, layer)\n\n        self._freeze_stages()\n\n    def _freeze_stages(self):\n        if self.frozen_stages >= 0:\n            self.patch_embed.eval()\n            for param in self.patch_embed.parameters():\n                param.requires_grad = False\n\n        if self.frozen_stages >= 1 and self.ape:\n            self.absolute_pos_embed.requires_grad = False\n\n        if self.frozen_stages >= 2:\n            self.pos_drop.eval()\n            for i in range(0, self.frozen_stages - 1):\n                m = self.layers[i]\n                m.eval()\n                for param in m.parameters():\n                    param.requires_grad = False\n\n    # def init_weights(self, pretrained=None):\n    #     \"\"\"Initialize the weights in backbone.\n    #     Args:\n    #         pretrained (str, optional): Path to pre-trained weights.\n    #             Defaults to None.\n    #     \"\"\"\n\n    #     def _init_weights(m):\n    #         if isinstance(m, nn.Linear):\n    #             trunc_normal_(m.weight, std=.02)\n    #             if isinstance(m, nn.Linear) and m.bias is not None:\n    #                 nn.init.constant_(m.bias, 0)\n    #         elif isinstance(m, nn.LayerNorm):\n    #             nn.init.constant_(m.bias, 0)\n    #             nn.init.constant_(m.weight, 1.0)\n\n    #     if isinstance(pretrained, str):\n    #         self.apply(_init_weights)\n    #         logger = get_root_logger()\n    #         load_checkpoint(self, pretrained, strict=False, logger=logger)\n    #     elif pretrained is None:\n    #         self.apply(_init_weights)\n    #     else:\n    #         raise TypeError('pretrained must be a str or None')\n\n    def forward_raw(self, x):\n        \"\"\"Forward function.\"\"\"\n        x = self.patch_embed(x)\n\n        Wh, Ww = x.size(2), x.size(3)\n        if self.ape:\n            # interpolate the position embedding to the corresponding size\n            absolute_pos_embed = F.interpolate(\n                self.absolute_pos_embed, size=(Wh, Ww), mode=\"bicubic\"\n            )\n            x = (x + absolute_pos_embed).flatten(2).transpose(1, 2)  # B Wh*Ww C\n        else:\n            x = x.flatten(2).transpose(1, 2)\n        x = self.pos_drop(x)\n\n        outs = []\n        for i in range(self.num_layers):\n            layer = self.layers[i]\n            x_out, H, W, x, Wh, Ww = layer(x, Wh, Ww)\n            # import ipdb; ipdb.set_trace()\n\n            if i in self.out_indices:\n                norm_layer = getattr(self, f\"norm{i}\")\n                x_out = norm_layer(x_out)\n\n                out = x_out.view(-1, H, W, self.num_features[i]).permute(0, 3, 1, 2).contiguous()\n                outs.append(out)\n        # in:\n        #   torch.Size([2, 3, 1024, 1024])\n        # outs:\n        #   [torch.Size([2, 192, 256, 256]), torch.Size([2, 384, 128, 128]), \\\n        #       torch.Size([2, 768, 64, 64]), torch.Size([2, 1536, 32, 32])]\n        return tuple(outs)\n\n    def forward(self, tensor_list: NestedTensor):\n        x = tensor_list.tensors\n\n        \"\"\"Forward function.\"\"\"\n        x = self.patch_embed(x)\n\n        Wh, Ww = x.size(2), x.size(3)\n        if self.ape:\n            # interpolate the position embedding to the corresponding size\n            absolute_pos_embed = F.interpolate(\n                self.absolute_pos_embed, size=(Wh, Ww), mode=\"bicubic\"\n            )\n            x = (x + absolute_pos_embed).flatten(2).transpose(1, 2)  # B Wh*Ww C\n        else:\n            x = x.flatten(2).transpose(1, 2)\n        x = self.pos_drop(x)\n\n        outs = []\n        for i in range(self.num_layers):\n            layer = self.layers[i]\n            x_out, H, W, x, Wh, Ww = layer(x, Wh, Ww)\n\n            if i in self.out_indices:\n                norm_layer = getattr(self, f\"norm{i}\")\n                x_out = norm_layer(x_out)\n\n                out = x_out.view(-1, H, W, self.num_features[i]).permute(0, 3, 1, 2).contiguous()\n                outs.append(out)\n        # in:\n        #   torch.Size([2, 3, 1024, 1024])\n        # out:\n        #   [torch.Size([2, 192, 256, 256]), torch.Size([2, 384, 128, 128]), \\\n        #       torch.Size([2, 768, 64, 64]), torch.Size([2, 1536, 32, 32])]\n\n        # collect for nesttensors\n        outs_dict = {}\n        for idx, out_i in enumerate(outs):\n            m = tensor_list.mask\n            assert m is not None\n            mask = F.interpolate(m[None].float(), size=out_i.shape[-2:]).to(torch.bool)[0]\n            outs_dict[idx] = NestedTensor(out_i, mask)\n\n        return outs_dict\n\n    def train(self, mode=True):\n        \"\"\"Convert the model into training mode while keep layers freezed.\"\"\"\n        super(SwinTransformer, self).train(mode)\n        self._freeze_stages()", "\n\ndef build_swin_transformer(modelname, pretrain_img_size, **kw):\n    assert modelname in [\n        \"swin_T_224_1k\",\n        \"swin_B_224_22k\",\n        \"swin_B_384_22k\",\n        \"swin_L_224_22k\",\n        \"swin_L_384_22k\",\n    ]\n\n    model_para_dict = {\n        \"swin_T_224_1k\": dict(\n            embed_dim=96, depths=[2, 2, 6, 2], num_heads=[3, 6, 12, 24], window_size=7\n        ),\n        \"swin_B_224_22k\": dict(\n            embed_dim=128, depths=[2, 2, 18, 2], num_heads=[4, 8, 16, 32], window_size=7\n        ),\n        \"swin_B_384_22k\": dict(\n            embed_dim=128, depths=[2, 2, 18, 2], num_heads=[4, 8, 16, 32], window_size=12\n        ),\n        \"swin_L_224_22k\": dict(\n            embed_dim=192, depths=[2, 2, 18, 2], num_heads=[6, 12, 24, 48], window_size=7\n        ),\n        \"swin_L_384_22k\": dict(\n            embed_dim=192, depths=[2, 2, 18, 2], num_heads=[6, 12, 24, 48], window_size=12\n        ),\n    }\n    kw_cgf = model_para_dict[modelname]\n    kw_cgf.update(kw)\n    model = SwinTransformer(pretrain_img_size=pretrain_img_size, **kw_cgf)\n    return model", "\n\nif __name__ == \"__main__\":\n    model = build_swin_transformer(\"swin_L_384_22k\", 384, dilation=True)\n    x = torch.rand(2, 3, 1024, 1024)\n    y = model.forward_raw(x)\n    import ipdb\n\n    ipdb.set_trace()\n    x = torch.rand(2, 3, 384, 384)\n    y = model.forward_raw(x)", ""]}
{"filename": "local_groundingdino/models/GroundingDINO/backbone/backbone.py", "chunked_list": ["# ------------------------------------------------------------------------\n# Grounding DINO\n# url: https://github.com/IDEA-Research/GroundingDINO\n# Copyright (c) 2023 IDEA. All Rights Reserved.\n# Licensed under the Apache License, Version 2.0 [see LICENSE for details]\n# ------------------------------------------------------------------------\n# Conditional DETR\n# Copyright (c) 2021 Microsoft. All Rights Reserved.\n# Licensed under the Apache License, Version 2.0 [see LICENSE for details]\n# ------------------------------------------------------------------------", "# Licensed under the Apache License, Version 2.0 [see LICENSE for details]\n# ------------------------------------------------------------------------\n# Copied from DETR (https://github.com/facebookresearch/detr)\n# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n# ------------------------------------------------------------------------\n\n\"\"\"\nBackbone modules.\n\"\"\"\n", "\"\"\"\n\nfrom typing import Dict, List\n\nimport torch\nimport torch.nn.functional as F\nimport torchvision\nfrom torch import nn\nfrom torchvision.models._utils import IntermediateLayerGetter\n", "from torchvision.models._utils import IntermediateLayerGetter\n\nfrom local_groundingdino.util.misc import NestedTensor, is_main_process\n\nfrom .position_encoding import build_position_encoding\nfrom .swin_transformer import build_swin_transformer\n\n\nclass FrozenBatchNorm2d(torch.nn.Module):\n    \"\"\"\n    BatchNorm2d where the batch statistics and the affine parameters are fixed.\n\n    Copy-paste from torchvision.misc.ops with added eps before rqsrt,\n    without which any other models than torchvision.models.resnet[18,34,50,101]\n    produce nans.\n    \"\"\"\n\n    def __init__(self, n):\n        super(FrozenBatchNorm2d, self).__init__()\n        self.register_buffer(\"weight\", torch.ones(n))\n        self.register_buffer(\"bias\", torch.zeros(n))\n        self.register_buffer(\"running_mean\", torch.zeros(n))\n        self.register_buffer(\"running_var\", torch.ones(n))\n\n    def _load_from_state_dict(\n        self, state_dict, prefix, local_metadata, strict, missing_keys, unexpected_keys, error_msgs\n    ):\n        num_batches_tracked_key = prefix + \"num_batches_tracked\"\n        if num_batches_tracked_key in state_dict:\n            del state_dict[num_batches_tracked_key]\n\n        super(FrozenBatchNorm2d, self)._load_from_state_dict(\n            state_dict, prefix, local_metadata, strict, missing_keys, unexpected_keys, error_msgs\n        )\n\n    def forward(self, x):\n        # move reshapes to the beginning\n        # to make it fuser-friendly\n        w = self.weight.reshape(1, -1, 1, 1)\n        b = self.bias.reshape(1, -1, 1, 1)\n        rv = self.running_var.reshape(1, -1, 1, 1)\n        rm = self.running_mean.reshape(1, -1, 1, 1)\n        eps = 1e-5\n        scale = w * (rv + eps).rsqrt()\n        bias = b - rm * scale\n        return x * scale + bias", "class FrozenBatchNorm2d(torch.nn.Module):\n    \"\"\"\n    BatchNorm2d where the batch statistics and the affine parameters are fixed.\n\n    Copy-paste from torchvision.misc.ops with added eps before rqsrt,\n    without which any other models than torchvision.models.resnet[18,34,50,101]\n    produce nans.\n    \"\"\"\n\n    def __init__(self, n):\n        super(FrozenBatchNorm2d, self).__init__()\n        self.register_buffer(\"weight\", torch.ones(n))\n        self.register_buffer(\"bias\", torch.zeros(n))\n        self.register_buffer(\"running_mean\", torch.zeros(n))\n        self.register_buffer(\"running_var\", torch.ones(n))\n\n    def _load_from_state_dict(\n        self, state_dict, prefix, local_metadata, strict, missing_keys, unexpected_keys, error_msgs\n    ):\n        num_batches_tracked_key = prefix + \"num_batches_tracked\"\n        if num_batches_tracked_key in state_dict:\n            del state_dict[num_batches_tracked_key]\n\n        super(FrozenBatchNorm2d, self)._load_from_state_dict(\n            state_dict, prefix, local_metadata, strict, missing_keys, unexpected_keys, error_msgs\n        )\n\n    def forward(self, x):\n        # move reshapes to the beginning\n        # to make it fuser-friendly\n        w = self.weight.reshape(1, -1, 1, 1)\n        b = self.bias.reshape(1, -1, 1, 1)\n        rv = self.running_var.reshape(1, -1, 1, 1)\n        rm = self.running_mean.reshape(1, -1, 1, 1)\n        eps = 1e-5\n        scale = w * (rv + eps).rsqrt()\n        bias = b - rm * scale\n        return x * scale + bias", "\n\nclass BackboneBase(nn.Module):\n    def __init__(\n        self,\n        backbone: nn.Module,\n        train_backbone: bool,\n        num_channels: int,\n        return_interm_indices: list,\n    ):\n        super().__init__()\n        for name, parameter in backbone.named_parameters():\n            if (\n                not train_backbone\n                or \"layer2\" not in name\n                and \"layer3\" not in name\n                and \"layer4\" not in name\n            ):\n                parameter.requires_grad_(False)\n\n        return_layers = {}\n        for idx, layer_index in enumerate(return_interm_indices):\n            return_layers.update(\n                {\"layer{}\".format(5 - len(return_interm_indices) + idx): \"{}\".format(layer_index)}\n            )\n\n        # if len:\n        #     if use_stage1_feature:\n        #         return_layers = {\"layer1\": \"0\", \"layer2\": \"1\", \"layer3\": \"2\", \"layer4\": \"3\"}\n        #     else:\n        #         return_layers = {\"layer2\": \"0\", \"layer3\": \"1\", \"layer4\": \"2\"}\n        # else:\n        #     return_layers = {'layer4': \"0\"}\n        self.body = IntermediateLayerGetter(backbone, return_layers=return_layers)\n        self.num_channels = num_channels\n\n    def forward(self, tensor_list: NestedTensor):\n        xs = self.body(tensor_list.tensors)\n        out: Dict[str, NestedTensor] = {}\n        for name, x in xs.items():\n            m = tensor_list.mask\n            assert m is not None\n            mask = F.interpolate(m[None].float(), size=x.shape[-2:]).to(torch.bool)[0]\n            out[name] = NestedTensor(x, mask)\n        # import ipdb; ipdb.set_trace()\n        return out", "\n\nclass Backbone(BackboneBase):\n    \"\"\"ResNet backbone with frozen BatchNorm.\"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        train_backbone: bool,\n        dilation: bool,\n        return_interm_indices: list,\n        batch_norm=FrozenBatchNorm2d,\n    ):\n        if name in [\"resnet18\", \"resnet34\", \"resnet50\", \"resnet101\"]:\n            backbone = getattr(torchvision.models, name)(\n                replace_stride_with_dilation=[False, False, dilation],\n                pretrained=is_main_process(),\n                norm_layer=batch_norm,\n            )\n        else:\n            raise NotImplementedError(\"Why you can get here with name {}\".format(name))\n        # num_channels = 512 if name in ('resnet18', 'resnet34') else 2048\n        assert name not in (\"resnet18\", \"resnet34\"), \"Only resnet50 and resnet101 are available.\"\n        assert return_interm_indices in [[0, 1, 2, 3], [1, 2, 3], [3]]\n        num_channels_all = [256, 512, 1024, 2048]\n        num_channels = num_channels_all[4 - len(return_interm_indices) :]\n        super().__init__(backbone, train_backbone, num_channels, return_interm_indices)", "\n\nclass Joiner(nn.Sequential):\n    def __init__(self, backbone, position_embedding):\n        super().__init__(backbone, position_embedding)\n\n    def forward(self, tensor_list: NestedTensor):\n        xs = self[0](tensor_list)\n        out: List[NestedTensor] = []\n        pos = []\n        for name, x in xs.items():\n            out.append(x)\n            # position encoding\n            pos.append(self[1](x).to(x.tensors.dtype))\n\n        return out, pos", "\n\ndef build_backbone(args):\n    \"\"\"\n    Useful args:\n        - backbone: backbone name\n        - lr_backbone:\n        - dilation\n        - return_interm_indices: available: [0,1,2,3], [1,2,3], [3]\n        - backbone_freeze_keywords:\n        - use_checkpoint: for swin only for now\n\n    \"\"\"\n    position_embedding = build_position_encoding(args)\n    train_backbone = True\n    if not train_backbone:\n        raise ValueError(\"Please set lr_backbone > 0\")\n    return_interm_indices = args.return_interm_indices\n    assert return_interm_indices in [[0, 1, 2, 3], [1, 2, 3], [3]]\n    args.backbone_freeze_keywords\n    use_checkpoint = getattr(args, \"use_checkpoint\", False)\n\n    if args.backbone in [\"resnet50\", \"resnet101\"]:\n        backbone = Backbone(\n            args.backbone,\n            train_backbone,\n            args.dilation,\n            return_interm_indices,\n            batch_norm=FrozenBatchNorm2d,\n        )\n        bb_num_channels = backbone.num_channels\n    elif args.backbone in [\n        \"swin_T_224_1k\",\n        \"swin_B_224_22k\",\n        \"swin_B_384_22k\",\n        \"swin_L_224_22k\",\n        \"swin_L_384_22k\",\n    ]:\n        pretrain_img_size = int(args.backbone.split(\"_\")[-2])\n        backbone = build_swin_transformer(\n            args.backbone,\n            pretrain_img_size=pretrain_img_size,\n            out_indices=tuple(return_interm_indices),\n            dilation=False,\n            use_checkpoint=use_checkpoint,\n        )\n\n        bb_num_channels = backbone.num_features[4 - len(return_interm_indices) :]\n    else:\n        raise NotImplementedError(\"Unknown backbone {}\".format(args.backbone))\n\n    assert len(bb_num_channels) == len(\n        return_interm_indices\n    ), f\"len(bb_num_channels) {len(bb_num_channels)} != len(return_interm_indices) {len(return_interm_indices)}\"\n\n    model = Joiner(backbone, position_embedding)\n    model.num_channels = bb_num_channels\n    assert isinstance(\n        bb_num_channels, List\n    ), \"bb_num_channels is expected to be a List but {}\".format(type(bb_num_channels))\n    # import ipdb; ipdb.set_trace()\n    return model", ""]}
{"filename": "local_groundingdino/models/GroundingDINO/backbone/position_encoding.py", "chunked_list": ["# ------------------------------------------------------------------------\n# Grounding DINO\n# url: https://github.com/IDEA-Research/GroundingDINO\n# Copyright (c) 2023 IDEA. All Rights Reserved.\n# Licensed under the Apache License, Version 2.0 [see LICENSE for details]\n# ------------------------------------------------------------------------\n# DINO\n# Copyright (c) 2022 IDEA. All Rights Reserved.\n# Licensed under the Apache License, Version 2.0 [see LICENSE for details]\n# ------------------------------------------------------------------------", "# Licensed under the Apache License, Version 2.0 [see LICENSE for details]\n# ------------------------------------------------------------------------\n# Conditional DETR\n# Copyright (c) 2021 Microsoft. All Rights Reserved.\n# Licensed under the Apache License, Version 2.0 [see LICENSE for details]\n# ------------------------------------------------------------------------\n# Copied from DETR (https://github.com/facebookresearch/detr)\n# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n# ------------------------------------------------------------------------\n", "# ------------------------------------------------------------------------\n\n\"\"\"\nVarious positional encodings for the transformer.\n\"\"\"\nimport math\n\nimport torch\nfrom torch import nn\n", "from torch import nn\n\nfrom local_groundingdino.util.misc import NestedTensor\n\n\nclass PositionEmbeddingSine(nn.Module):\n    \"\"\"\n    This is a more standard version of the position embedding, very similar to the one\n    used by the Attention is all you need paper, generalized to work on images.\n    \"\"\"\n\n    def __init__(self, num_pos_feats=64, temperature=10000, normalize=False, scale=None):\n        super().__init__()\n        self.num_pos_feats = num_pos_feats\n        self.temperature = temperature\n        self.normalize = normalize\n        if scale is not None and normalize is False:\n            raise ValueError(\"normalize should be True if scale is passed\")\n        if scale is None:\n            scale = 2 * math.pi\n        self.scale = scale\n\n    def forward(self, tensor_list: NestedTensor):\n        x = tensor_list.tensors\n        mask = tensor_list.mask\n        assert mask is not None\n        not_mask = ~mask\n        y_embed = not_mask.cumsum(1, dtype=torch.float32)\n        x_embed = not_mask.cumsum(2, dtype=torch.float32)\n        if self.normalize:\n            eps = 1e-6\n            # if os.environ.get(\"SHILONG_AMP\", None) == '1':\n            #     eps = 1e-4\n            # else:\n            #     eps = 1e-6\n            y_embed = y_embed / (y_embed[:, -1:, :] + eps) * self.scale\n            x_embed = x_embed / (x_embed[:, :, -1:] + eps) * self.scale\n\n        dim_t = torch.arange(self.num_pos_feats, dtype=torch.float32, device=x.device)\n        dim_t = self.temperature ** (2 * (dim_t // 2) / self.num_pos_feats)\n\n        pos_x = x_embed[:, :, :, None] / dim_t\n        pos_y = y_embed[:, :, :, None] / dim_t\n        pos_x = torch.stack(\n            (pos_x[:, :, :, 0::2].sin(), pos_x[:, :, :, 1::2].cos()), dim=4\n        ).flatten(3)\n        pos_y = torch.stack(\n            (pos_y[:, :, :, 0::2].sin(), pos_y[:, :, :, 1::2].cos()), dim=4\n        ).flatten(3)\n        pos = torch.cat((pos_y, pos_x), dim=3).permute(0, 3, 1, 2)\n        return pos", "\n\nclass PositionEmbeddingSineHW(nn.Module):\n    \"\"\"\n    This is a more standard version of the position embedding, very similar to the one\n    used by the Attention is all you need paper, generalized to work on images.\n    \"\"\"\n\n    def __init__(\n        self, num_pos_feats=64, temperatureH=10000, temperatureW=10000, normalize=False, scale=None\n    ):\n        super().__init__()\n        self.num_pos_feats = num_pos_feats\n        self.temperatureH = temperatureH\n        self.temperatureW = temperatureW\n        self.normalize = normalize\n        if scale is not None and normalize is False:\n            raise ValueError(\"normalize should be True if scale is passed\")\n        if scale is None:\n            scale = 2 * math.pi\n        self.scale = scale\n\n    def forward(self, tensor_list: NestedTensor):\n        x = tensor_list.tensors\n        mask = tensor_list.mask\n        assert mask is not None\n        not_mask = ~mask\n        y_embed = not_mask.cumsum(1, dtype=torch.float32)\n        x_embed = not_mask.cumsum(2, dtype=torch.float32)\n\n        # import ipdb; ipdb.set_trace()\n\n        if self.normalize:\n            eps = 1e-6\n            y_embed = y_embed / (y_embed[:, -1:, :] + eps) * self.scale\n            x_embed = x_embed / (x_embed[:, :, -1:] + eps) * self.scale\n\n        dim_tx = torch.arange(self.num_pos_feats, dtype=torch.float32, device=x.device)\n        dim_tx = self.temperatureW ** (2 * (torch.div(dim_tx, 2, rounding_mode='floor')) / self.num_pos_feats)\n        pos_x = x_embed[:, :, :, None] / dim_tx\n\n        dim_ty = torch.arange(self.num_pos_feats, dtype=torch.float32, device=x.device)\n        dim_ty = self.temperatureH ** (2 * (torch.div(dim_ty, 2, rounding_mode='floor')) / self.num_pos_feats)\n        pos_y = y_embed[:, :, :, None] / dim_ty\n\n        pos_x = torch.stack(\n            (pos_x[:, :, :, 0::2].sin(), pos_x[:, :, :, 1::2].cos()), dim=4\n        ).flatten(3)\n        pos_y = torch.stack(\n            (pos_y[:, :, :, 0::2].sin(), pos_y[:, :, :, 1::2].cos()), dim=4\n        ).flatten(3)\n        pos = torch.cat((pos_y, pos_x), dim=3).permute(0, 3, 1, 2)\n\n        # import ipdb; ipdb.set_trace()\n\n        return pos", "\n\nclass PositionEmbeddingLearned(nn.Module):\n    \"\"\"\n    Absolute pos embedding, learned.\n    \"\"\"\n\n    def __init__(self, num_pos_feats=256):\n        super().__init__()\n        self.row_embed = nn.Embedding(50, num_pos_feats)\n        self.col_embed = nn.Embedding(50, num_pos_feats)\n        self.reset_parameters()\n\n    def reset_parameters(self):\n        nn.init.uniform_(self.row_embed.weight)\n        nn.init.uniform_(self.col_embed.weight)\n\n    def forward(self, tensor_list: NestedTensor):\n        x = tensor_list.tensors\n        h, w = x.shape[-2:]\n        i = torch.arange(w, device=x.device)\n        j = torch.arange(h, device=x.device)\n        x_emb = self.col_embed(i)\n        y_emb = self.row_embed(j)\n        pos = (\n            torch.cat(\n                [\n                    x_emb.unsqueeze(0).repeat(h, 1, 1),\n                    y_emb.unsqueeze(1).repeat(1, w, 1),\n                ],\n                dim=-1,\n            )\n            .permute(2, 0, 1)\n            .unsqueeze(0)\n            .repeat(x.shape[0], 1, 1, 1)\n        )\n        return pos", "\n\ndef build_position_encoding(args):\n    N_steps = args.hidden_dim // 2\n    if args.position_embedding in (\"v2\", \"sine\"):\n        # TODO find a better way of exposing other arguments\n        position_embedding = PositionEmbeddingSineHW(\n            N_steps,\n            temperatureH=args.pe_temperatureH,\n            temperatureW=args.pe_temperatureW,\n            normalize=True,\n        )\n    elif args.position_embedding in (\"v3\", \"learned\"):\n        position_embedding = PositionEmbeddingLearned(N_steps)\n    else:\n        raise ValueError(f\"not supported {args.position_embedding}\")\n\n    return position_embedding", ""]}
{"filename": "local_groundingdino/models/GroundingDINO/backbone/__init__.py", "chunked_list": ["from .backbone import build_backbone\n"]}
{"filename": "local_groundingdino/datasets/transforms.py", "chunked_list": ["# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved\n\"\"\"\nTransforms and data augmentation for both image + bbox.\n\"\"\"\nimport os\nimport random\n\nimport PIL\nimport torch\nimport torchvision.transforms as T", "import torch\nimport torchvision.transforms as T\nimport torchvision.transforms.functional as F\n\nfrom local_groundingdino.util.box_ops import box_xyxy_to_cxcywh\nfrom local_groundingdino.util.misc import interpolate\n\n\ndef crop(image, target, region):\n    cropped_image = F.crop(image, *region)\n\n    target = target.copy()\n    i, j, h, w = region\n\n    # should we do something wrt the original size?\n    target[\"size\"] = torch.tensor([h, w])\n\n    fields = [\"labels\", \"area\", \"iscrowd\", \"positive_map\"]\n\n    if \"boxes\" in target:\n        boxes = target[\"boxes\"]\n        max_size = torch.as_tensor([w, h], dtype=torch.float32)\n        cropped_boxes = boxes - torch.as_tensor([j, i, j, i])\n        cropped_boxes = torch.min(cropped_boxes.reshape(-1, 2, 2), max_size)\n        cropped_boxes = cropped_boxes.clamp(min=0)\n        area = (cropped_boxes[:, 1, :] - cropped_boxes[:, 0, :]).prod(dim=1)\n        target[\"boxes\"] = cropped_boxes.reshape(-1, 4)\n        target[\"area\"] = area\n        fields.append(\"boxes\")\n\n    if \"masks\" in target:\n        # FIXME should we update the area here if there are no boxes?\n        target[\"masks\"] = target[\"masks\"][:, i : i + h, j : j + w]\n        fields.append(\"masks\")\n\n    # remove elements for which the boxes or masks that have zero area\n    if \"boxes\" in target or \"masks\" in target:\n        # favor boxes selection when defining which elements to keep\n        # this is compatible with previous implementation\n        if \"boxes\" in target:\n            cropped_boxes = target[\"boxes\"].reshape(-1, 2, 2)\n            keep = torch.all(cropped_boxes[:, 1, :] > cropped_boxes[:, 0, :], dim=1)\n        else:\n            keep = target[\"masks\"].flatten(1).any(1)\n\n        for field in fields:\n            if field in target:\n                target[field] = target[field][keep]\n\n    if os.environ.get(\"IPDB_SHILONG_DEBUG\", None) == \"INFO\":\n        # for debug and visualization only.\n        if \"strings_positive\" in target:\n            target[\"strings_positive\"] = [\n                _i for _i, _j in zip(target[\"strings_positive\"], keep) if _j\n            ]\n\n    return cropped_image, target", "def crop(image, target, region):\n    cropped_image = F.crop(image, *region)\n\n    target = target.copy()\n    i, j, h, w = region\n\n    # should we do something wrt the original size?\n    target[\"size\"] = torch.tensor([h, w])\n\n    fields = [\"labels\", \"area\", \"iscrowd\", \"positive_map\"]\n\n    if \"boxes\" in target:\n        boxes = target[\"boxes\"]\n        max_size = torch.as_tensor([w, h], dtype=torch.float32)\n        cropped_boxes = boxes - torch.as_tensor([j, i, j, i])\n        cropped_boxes = torch.min(cropped_boxes.reshape(-1, 2, 2), max_size)\n        cropped_boxes = cropped_boxes.clamp(min=0)\n        area = (cropped_boxes[:, 1, :] - cropped_boxes[:, 0, :]).prod(dim=1)\n        target[\"boxes\"] = cropped_boxes.reshape(-1, 4)\n        target[\"area\"] = area\n        fields.append(\"boxes\")\n\n    if \"masks\" in target:\n        # FIXME should we update the area here if there are no boxes?\n        target[\"masks\"] = target[\"masks\"][:, i : i + h, j : j + w]\n        fields.append(\"masks\")\n\n    # remove elements for which the boxes or masks that have zero area\n    if \"boxes\" in target or \"masks\" in target:\n        # favor boxes selection when defining which elements to keep\n        # this is compatible with previous implementation\n        if \"boxes\" in target:\n            cropped_boxes = target[\"boxes\"].reshape(-1, 2, 2)\n            keep = torch.all(cropped_boxes[:, 1, :] > cropped_boxes[:, 0, :], dim=1)\n        else:\n            keep = target[\"masks\"].flatten(1).any(1)\n\n        for field in fields:\n            if field in target:\n                target[field] = target[field][keep]\n\n    if os.environ.get(\"IPDB_SHILONG_DEBUG\", None) == \"INFO\":\n        # for debug and visualization only.\n        if \"strings_positive\" in target:\n            target[\"strings_positive\"] = [\n                _i for _i, _j in zip(target[\"strings_positive\"], keep) if _j\n            ]\n\n    return cropped_image, target", "\n\ndef hflip(image, target):\n    flipped_image = F.hflip(image)\n\n    w, h = image.size\n\n    target = target.copy()\n    if \"boxes\" in target:\n        boxes = target[\"boxes\"]\n        boxes = boxes[:, [2, 1, 0, 3]] * torch.as_tensor([-1, 1, -1, 1]) + torch.as_tensor(\n            [w, 0, w, 0]\n        )\n        target[\"boxes\"] = boxes\n\n    if \"masks\" in target:\n        target[\"masks\"] = target[\"masks\"].flip(-1)\n\n    return flipped_image, target", "\n\ndef resize(image, target, size, max_size=None):\n    # size can be min_size (scalar) or (w, h) tuple\n\n    def get_size_with_aspect_ratio(image_size, size, max_size=None):\n        w, h = image_size\n        if max_size is not None:\n            min_original_size = float(min((w, h)))\n            max_original_size = float(max((w, h)))\n            if max_original_size / min_original_size * size > max_size:\n                size = int(round(max_size * min_original_size / max_original_size))\n\n        if (w <= h and w == size) or (h <= w and h == size):\n            return (h, w)\n\n        if w < h:\n            ow = size\n            oh = int(size * h / w)\n        else:\n            oh = size\n            ow = int(size * w / h)\n\n        return (oh, ow)\n\n    def get_size(image_size, size, max_size=None):\n        if isinstance(size, (list, tuple)):\n            return size[::-1]\n        else:\n            return get_size_with_aspect_ratio(image_size, size, max_size)\n\n    size = get_size(image.size, size, max_size)\n    rescaled_image = F.resize(image, size)\n\n    if target is None:\n        return rescaled_image, None\n\n    ratios = tuple(float(s) / float(s_orig) for s, s_orig in zip(rescaled_image.size, image.size))\n    ratio_width, ratio_height = ratios\n\n    target = target.copy()\n    if \"boxes\" in target:\n        boxes = target[\"boxes\"]\n        scaled_boxes = boxes * torch.as_tensor(\n            [ratio_width, ratio_height, ratio_width, ratio_height]\n        )\n        target[\"boxes\"] = scaled_boxes\n\n    if \"area\" in target:\n        area = target[\"area\"]\n        scaled_area = area * (ratio_width * ratio_height)\n        target[\"area\"] = scaled_area\n\n    h, w = size\n    target[\"size\"] = torch.tensor([h, w])\n\n    if \"masks\" in target:\n        target[\"masks\"] = (\n            interpolate(target[\"masks\"][:, None].float(), size, mode=\"nearest\")[:, 0] > 0.5\n        )\n\n    return rescaled_image, target", "\n\ndef pad(image, target, padding):\n    # assumes that we only pad on the bottom right corners\n    padded_image = F.pad(image, (0, 0, padding[0], padding[1]))\n    if target is None:\n        return padded_image, None\n    target = target.copy()\n    # should we do something wrt the original size?\n    target[\"size\"] = torch.tensor(padded_image.size[::-1])\n    if \"masks\" in target:\n        target[\"masks\"] = torch.nn.functional.pad(target[\"masks\"], (0, padding[0], 0, padding[1]))\n    return padded_image, target", "\n\nclass ResizeDebug(object):\n    def __init__(self, size):\n        self.size = size\n\n    def __call__(self, img, target):\n        return resize(img, target, self.size)\n\n\nclass RandomCrop(object):\n    def __init__(self, size):\n        self.size = size\n\n    def __call__(self, img, target):\n        region = T.RandomCrop.get_params(img, self.size)\n        return crop(img, target, region)", "\n\nclass RandomCrop(object):\n    def __init__(self, size):\n        self.size = size\n\n    def __call__(self, img, target):\n        region = T.RandomCrop.get_params(img, self.size)\n        return crop(img, target, region)\n", "\n\nclass RandomSizeCrop(object):\n    def __init__(self, min_size: int, max_size: int, respect_boxes: bool = False):\n        # respect_boxes:    True to keep all boxes\n        #                   False to tolerence box filter\n        self.min_size = min_size\n        self.max_size = max_size\n        self.respect_boxes = respect_boxes\n\n    def __call__(self, img: PIL.Image.Image, target: dict):\n        init_boxes = len(target[\"boxes\"])\n        max_patience = 10\n        for i in range(max_patience):\n            w = random.randint(self.min_size, min(img.width, self.max_size))\n            h = random.randint(self.min_size, min(img.height, self.max_size))\n            region = T.RandomCrop.get_params(img, [h, w])\n            result_img, result_target = crop(img, target, region)\n            if (\n                not self.respect_boxes\n                or len(result_target[\"boxes\"]) == init_boxes\n                or i == max_patience - 1\n            ):\n                return result_img, result_target\n        return result_img, result_target", "\n\nclass CenterCrop(object):\n    def __init__(self, size):\n        self.size = size\n\n    def __call__(self, img, target):\n        image_width, image_height = img.size\n        crop_height, crop_width = self.size\n        crop_top = int(round((image_height - crop_height) / 2.0))\n        crop_left = int(round((image_width - crop_width) / 2.0))\n        return crop(img, target, (crop_top, crop_left, crop_height, crop_width))", "\n\nclass RandomHorizontalFlip(object):\n    def __init__(self, p=0.5):\n        self.p = p\n\n    def __call__(self, img, target):\n        if random.random() < self.p:\n            return hflip(img, target)\n        return img, target", "\n\nclass RandomResize(object):\n    def __init__(self, sizes, max_size=None):\n        assert isinstance(sizes, (list, tuple))\n        self.sizes = sizes\n        self.max_size = max_size\n\n    def __call__(self, img, target=None):\n        size = random.choice(self.sizes)\n        return resize(img, target, size, self.max_size)", "\n\nclass RandomPad(object):\n    def __init__(self, max_pad):\n        self.max_pad = max_pad\n\n    def __call__(self, img, target):\n        pad_x = random.randint(0, self.max_pad)\n        pad_y = random.randint(0, self.max_pad)\n        return pad(img, target, (pad_x, pad_y))", "\n\nclass RandomSelect(object):\n    \"\"\"\n    Randomly selects between transforms1 and transforms2,\n    with probability p for transforms1 and (1 - p) for transforms2\n    \"\"\"\n\n    def __init__(self, transforms1, transforms2, p=0.5):\n        self.transforms1 = transforms1\n        self.transforms2 = transforms2\n        self.p = p\n\n    def __call__(self, img, target):\n        if random.random() < self.p:\n            return self.transforms1(img, target)\n        return self.transforms2(img, target)", "\n\nclass ToTensor(object):\n    def __call__(self, img, target):\n        return F.to_tensor(img), target\n\n\nclass RandomErasing(object):\n    def __init__(self, *args, **kwargs):\n        self.eraser = T.RandomErasing(*args, **kwargs)\n\n    def __call__(self, img, target):\n        return self.eraser(img), target", "\n\nclass Normalize(object):\n    def __init__(self, mean, std):\n        self.mean = mean\n        self.std = std\n\n    def __call__(self, image, target=None):\n        image = F.normalize(image, mean=self.mean, std=self.std)\n        if target is None:\n            return image, None\n        target = target.copy()\n        h, w = image.shape[-2:]\n        if \"boxes\" in target:\n            boxes = target[\"boxes\"]\n            boxes = box_xyxy_to_cxcywh(boxes)\n            boxes = boxes / torch.tensor([w, h, w, h], dtype=torch.float32)\n            target[\"boxes\"] = boxes\n        return image, target", "\n\nclass Compose(object):\n    def __init__(self, transforms):\n        self.transforms = transforms\n\n    def __call__(self, image, target):\n        for t in self.transforms:\n            image, target = t(image, target)\n        return image, target\n\n    def __repr__(self):\n        format_string = self.__class__.__name__ + \"(\"\n        for t in self.transforms:\n            format_string += \"\\n\"\n            format_string += \"    {0}\".format(t)\n        format_string += \"\\n)\"\n        return format_string", ""]}
{"filename": "local_groundingdino/datasets/__init__.py", "chunked_list": [""]}
{"filename": "models/grounding-dino/GroundingDINO_SwinT_OGC.py", "chunked_list": ["batch_size = 1\nmodelname = \"groundingdino\"\nbackbone = \"swin_T_224_1k\"\nposition_embedding = \"sine\"\npe_temperatureH = 20\npe_temperatureW = 20\nreturn_interm_indices = [1, 2, 3]\nbackbone_freeze_keywords = None\nenc_layers = 6\ndec_layers = 6", "enc_layers = 6\ndec_layers = 6\npre_norm = False\ndim_feedforward = 2048\nhidden_dim = 256\ndropout = 0.0\nnheads = 8\nnum_queries = 900\nquery_dim = 4\nnum_patterns = 0", "query_dim = 4\nnum_patterns = 0\nnum_feature_levels = 4\nenc_n_points = 4\ndec_n_points = 4\ntwo_stage_type = \"standard\"\ntwo_stage_bbox_embed_share = False\ntwo_stage_class_embed_share = False\ntransformer_activation = \"relu\"\ndec_pred_bbox_embed_share = True", "transformer_activation = \"relu\"\ndec_pred_bbox_embed_share = True\ndn_box_noise_scale = 1.0\ndn_label_noise_ratio = 0.5\ndn_label_coef = 1.0\ndn_bbox_coef = 1.0\nembed_init_tgt = True\ndn_labelbook_size = 2000\nmax_text_len = 256\ntext_encoder_type = \"bert-base-uncased\"", "max_text_len = 256\ntext_encoder_type = \"bert-base-uncased\"\nuse_text_enhancer = True\nuse_fusion_layer = True\nuse_checkpoint = True\nuse_transformer_ckpt = True\nuse_text_cross_attention = True\ntext_dropout = 0.0\nfusion_dropout = 0.0\nfusion_droppath = 0.1", "fusion_dropout = 0.0\nfusion_droppath = 0.1\nsub_sentence_present = True\n"]}
{"filename": "models/grounding-dino/GroundingDINO_SwinB.cfg.py", "chunked_list": ["batch_size = 1\nmodelname = \"groundingdino\"\nbackbone = \"swin_B_384_22k\"\nposition_embedding = \"sine\"\npe_temperatureH = 20\npe_temperatureW = 20\nreturn_interm_indices = [1, 2, 3]\nbackbone_freeze_keywords = None\nenc_layers = 6\ndec_layers = 6", "enc_layers = 6\ndec_layers = 6\npre_norm = False\ndim_feedforward = 2048\nhidden_dim = 256\ndropout = 0.0\nnheads = 8\nnum_queries = 900\nquery_dim = 4\nnum_patterns = 0", "query_dim = 4\nnum_patterns = 0\nnum_feature_levels = 4\nenc_n_points = 4\ndec_n_points = 4\ntwo_stage_type = \"standard\"\ntwo_stage_bbox_embed_share = False\ntwo_stage_class_embed_share = False\ntransformer_activation = \"relu\"\ndec_pred_bbox_embed_share = True", "transformer_activation = \"relu\"\ndec_pred_bbox_embed_share = True\ndn_box_noise_scale = 1.0\ndn_label_noise_ratio = 0.5\ndn_label_coef = 1.0\ndn_bbox_coef = 1.0\nembed_init_tgt = True\ndn_labelbook_size = 2000\nmax_text_len = 256\ntext_encoder_type = \"bert-base-uncased\"", "max_text_len = 256\ntext_encoder_type = \"bert-base-uncased\"\nuse_text_enhancer = True\nuse_fusion_layer = True\nuse_checkpoint = True\nuse_transformer_ckpt = True\nuse_text_cross_attention = True\ntext_dropout = 0.0\nfusion_dropout = 0.0\nfusion_droppath = 0.1", "fusion_dropout = 0.0\nfusion_droppath = 0.1\nsub_sentence_present = True\n"]}
{"filename": "sam_hq/build_sam_hq.py", "chunked_list": ["# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport torch\n\nfrom functools import partial\n", "from functools import partial\n\nfrom .modeling.mask_decoder_hq import MaskDecoderHQ\nfrom .modeling.image_encoder import ImageEncoderViTHQ\nfrom .modeling.tiny_vit import TinyViT\nfrom segment_anything.modeling import PromptEncoder, Sam, TwoWayTransformer, MaskDecoder\nfrom segment_anything import build_sam_vit_h, build_sam_vit_l, build_sam_vit_b\n\n\ndef build_sam_hq_vit_h(checkpoint=None):\n    return _build_sam_hq(\n        encoder_embed_dim=1280,\n        encoder_depth=32,\n        encoder_num_heads=16,\n        encoder_global_attn_indexes=[7, 15, 23, 31],\n        checkpoint=checkpoint,\n    )", "\ndef build_sam_hq_vit_h(checkpoint=None):\n    return _build_sam_hq(\n        encoder_embed_dim=1280,\n        encoder_depth=32,\n        encoder_num_heads=16,\n        encoder_global_attn_indexes=[7, 15, 23, 31],\n        checkpoint=checkpoint,\n    )\n", "\n\ndef build_sam_hq_vit_l(checkpoint=None):\n    return _build_sam_hq(\n        encoder_embed_dim=1024,\n        encoder_depth=24,\n        encoder_num_heads=16,\n        encoder_global_attn_indexes=[5, 11, 17, 23],\n        checkpoint=checkpoint,\n    )", "\n\ndef build_sam_hq_vit_b(checkpoint=None):\n    return _build_sam_hq(\n        encoder_embed_dim=768,\n        encoder_depth=12,\n        encoder_num_heads=12,\n        encoder_global_attn_indexes=[2, 5, 8, 11],\n        checkpoint=checkpoint,\n    )", "\n\ndef build_mobile_sam(checkpoint=None):\n    return _build_mobile_sam(checkpoint)\n\n\nsam_model_registry = {\n    \"sam_vit_h\": build_sam_vit_h,\n    \"sam_vit_l\": build_sam_vit_l,\n    \"sam_vit_b\": build_sam_vit_b,", "    \"sam_vit_l\": build_sam_vit_l,\n    \"sam_vit_b\": build_sam_vit_b,\n    \"sam_hq_vit_h\": build_sam_hq_vit_h,\n    \"sam_hq_vit_l\": build_sam_hq_vit_l,\n    \"sam_hq_vit_b\": build_sam_hq_vit_b,\n    \"mobile_sam\": build_mobile_sam,\n}\n\n\ndef _load_sam_checkpoint(sam: Sam, checkpoint=None):\n    sam.eval()\n    if checkpoint is not None:\n        with open(checkpoint, \"rb\") as f:\n            state_dict = torch.load(f)\n        info = sam.load_state_dict(state_dict, strict=False)\n        print(info)\n    for _, p in sam.named_parameters():\n        p.requires_grad = False\n    return sam", "\ndef _load_sam_checkpoint(sam: Sam, checkpoint=None):\n    sam.eval()\n    if checkpoint is not None:\n        with open(checkpoint, \"rb\") as f:\n            state_dict = torch.load(f)\n        info = sam.load_state_dict(state_dict, strict=False)\n        print(info)\n    for _, p in sam.named_parameters():\n        p.requires_grad = False\n    return sam", "\ndef _build_sam_hq(\n    encoder_embed_dim,\n    encoder_depth,\n    encoder_num_heads,\n    encoder_global_attn_indexes,\n    checkpoint=None,\n):\n    prompt_embed_dim = 256\n    image_size = 1024\n    vit_patch_size = 16\n    image_embedding_size = image_size // vit_patch_size\n    sam = Sam(\n        image_encoder=ImageEncoderViTHQ(\n            depth=encoder_depth,\n            embed_dim=encoder_embed_dim,\n            img_size=image_size,\n            mlp_ratio=4,\n            norm_layer=partial(torch.nn.LayerNorm, eps=1e-6),\n            num_heads=encoder_num_heads,\n            patch_size=vit_patch_size,\n            qkv_bias=True,\n            use_rel_pos=True,\n            global_attn_indexes=encoder_global_attn_indexes,\n            window_size=14,\n            out_chans=prompt_embed_dim,\n        ),\n        prompt_encoder=PromptEncoder(\n            embed_dim=prompt_embed_dim,\n            image_embedding_size=(image_embedding_size, image_embedding_size),\n            input_image_size=(image_size, image_size),\n            mask_in_chans=16,\n        ),\n        mask_decoder=MaskDecoderHQ(\n            num_multimask_outputs=3,\n            transformer=TwoWayTransformer(\n                depth=2,\n                embedding_dim=prompt_embed_dim,\n                mlp_dim=2048,\n                num_heads=8,\n            ),\n            transformer_dim=prompt_embed_dim,\n            iou_head_depth=3,\n            iou_head_hidden_dim=256,\n            vit_dim=encoder_embed_dim,\n        ),\n        pixel_mean=[123.675, 116.28, 103.53],\n        pixel_std=[58.395, 57.12, 57.375],\n    )\n    return _load_sam_checkpoint(sam, checkpoint)", "\n\ndef _build_mobile_sam(checkpoint=None):\n    prompt_embed_dim = 256\n    image_size = 1024\n    vit_patch_size = 16\n    image_embedding_size = image_size // vit_patch_size\n    mobile_sam = Sam(\n        image_encoder=TinyViT(\n            img_size=1024, in_chans=3, num_classes=1000,\n            embed_dims=[64, 128, 160, 320],\n            depths=[2, 2, 6, 2],\n            num_heads=[2, 4, 5, 10],\n            window_sizes=[7, 7, 14, 7],\n            mlp_ratio=4.,\n            drop_rate=0.,\n            drop_path_rate=0.0,\n            use_checkpoint=False,\n            mbconv_expand_ratio=4.0,\n            local_conv_size=3,\n            layer_lr_decay=0.8\n        ),\n        prompt_encoder=PromptEncoder(\n        embed_dim=prompt_embed_dim,\n        image_embedding_size=(image_embedding_size, image_embedding_size),\n        input_image_size=(image_size, image_size),\n        mask_in_chans=16,\n        ),\n        mask_decoder=MaskDecoder(\n                num_multimask_outputs=3,\n                transformer=TwoWayTransformer(\n                depth=2,\n                embedding_dim=prompt_embed_dim,\n                mlp_dim=2048,\n                num_heads=8,\n            ),\n            transformer_dim=prompt_embed_dim,\n            iou_head_depth=3,\n            iou_head_hidden_dim=256,\n        ),\n        pixel_mean=[123.675, 116.28, 103.53],\n        pixel_std=[58.395, 57.12, 57.375],\n    )\n    return _load_sam_checkpoint(mobile_sam, checkpoint)", ""]}
{"filename": "sam_hq/predictor.py", "chunked_list": ["from typing import Optional, Tuple\nimport numpy as np\nimport torch\nfrom segment_anything import SamPredictor\nfrom segment_anything.modeling import Sam\n\n\nclass SamPredictorHQ(SamPredictor):\n\n    def __init__(\n        self,\n        sam_model: Sam,\n        sam_is_hq: bool = False,\n    ) -> None:\n        \"\"\"\n        Uses SAM to calculate the image embedding for an image, and then\n        allow repeated, efficient mask prediction given prompts.\n\n        Arguments:\n          sam_model (Sam): The model to use for mask prediction.\n        \"\"\"\n        super().__init__(sam_model=sam_model)\n        self.is_hq = sam_is_hq\n    \n\n    @torch.no_grad()\n    def set_torch_image(\n        self,\n        transformed_image: torch.Tensor,\n        original_image_size: Tuple[int, ...],\n    ) -> None:\n        \"\"\"\n        Calculates the image embeddings for the provided image, allowing\n        masks to be predicted with the 'predict' method. Expects the input\n        image to be already transformed to the format expected by the model.\n\n        Arguments:\n          transformed_image (torch.Tensor): The input image, with shape\n            1x3xHxW, which has been transformed with ResizeLongestSide.\n          original_image_size (tuple(int, int)): The size of the image\n            before transformation, in (H, W) format.\n        \"\"\"\n        assert (\n            len(transformed_image.shape) == 4\n            and transformed_image.shape[1] == 3\n            and max(*transformed_image.shape[2:]) == self.model.image_encoder.img_size\n        ), f\"set_torch_image input must be BCHW with long side {self.model.image_encoder.img_size}.\"\n        self.reset_image()\n\n        self.original_size = original_image_size\n        self.input_size = tuple(transformed_image.shape[-2:])\n        input_image = self.model.preprocess(transformed_image)\n        if self.is_hq:\n            self.features, self.interm_features = self.model.image_encoder(input_image)\n        else:\n            self.features = self.model.image_encoder(input_image)\n        self.is_image_set = True\n\n\n    @torch.no_grad()\n    def predict_torch(\n        self,\n        point_coords: Optional[torch.Tensor],\n        point_labels: Optional[torch.Tensor],\n        boxes: Optional[torch.Tensor] = None,\n        mask_input: Optional[torch.Tensor] = None,\n        multimask_output: bool = True,\n        return_logits: bool = False,\n    ) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n        \"\"\"\n        Predict masks for the given input prompts, using the currently set image.\n        Input prompts are batched torch tensors and are expected to already be\n        transformed to the input frame using ResizeLongestSide.\n\n        Arguments:\n          point_coords (torch.Tensor or None): A BxNx2 array of point prompts to the\n            model. Each point is in (X,Y) in pixels.\n          point_labels (torch.Tensor or None): A BxN array of labels for the\n            point prompts. 1 indicates a foreground point and 0 indicates a\n            background point.\n          boxes (np.ndarray or None): A Bx4 array given a box prompt to the\n            model, in XYXY format.\n          mask_input (np.ndarray): A low resolution mask input to the model, typically\n            coming from a previous prediction iteration. Has form Bx1xHxW, where\n            for SAM, H=W=256. Masks returned by a previous iteration of the\n            predict method do not need further transformation.\n          multimask_output (bool): If true, the model will return three masks.\n            For ambiguous input prompts (such as a single click), this will often\n            produce better masks than a single prediction. If only a single\n            mask is needed, the model's predicted quality score can be used\n            to select the best mask. For non-ambiguous prompts, such as multiple\n            input prompts, multimask_output=False can give better results.\n          return_logits (bool): If true, returns un-thresholded masks logits\n            instead of a binary mask.\n\n        Returns:\n          (torch.Tensor): The output masks in BxCxHxW format, where C is the\n            number of masks, and (H, W) is the original image size.\n          (torch.Tensor): An array of shape BxC containing the model's\n            predictions for the quality of each mask.\n          (torch.Tensor): An array of shape BxCxHxW, where C is the number\n            of masks and H=W=256. These low res logits can be passed to\n            a subsequent iteration as mask input.\n        \"\"\"\n        if not self.is_image_set:\n            raise RuntimeError(\"An image must be set with .set_image(...) before mask prediction.\")\n\n        if point_coords is not None:\n            points = (point_coords, point_labels)\n        else:\n            points = None\n\n        # Embed prompts\n        sparse_embeddings, dense_embeddings = self.model.prompt_encoder(\n            points=points,\n            boxes=boxes,\n            masks=mask_input,\n        )\n\n        # Predict masks\n        if self.is_hq:\n            low_res_masks, iou_predictions = self.model.mask_decoder(\n                image_embeddings=self.features,\n                image_pe=self.model.prompt_encoder.get_dense_pe(),\n                sparse_prompt_embeddings=sparse_embeddings,\n                dense_prompt_embeddings=dense_embeddings,\n                multimask_output=multimask_output,\n                hq_token_only=False,\n                interm_embeddings=self.interm_features,\n            )\n        else:\n            low_res_masks, iou_predictions = self.model.mask_decoder(\n                image_embeddings=self.features,\n                image_pe=self.model.prompt_encoder.get_dense_pe(),\n                sparse_prompt_embeddings=sparse_embeddings,\n                dense_prompt_embeddings=dense_embeddings,\n                multimask_output=multimask_output,\n            )\n        # Upscale the masks to the original image resolution\n        masks = self.model.postprocess_masks(low_res_masks, self.input_size, self.original_size)\n\n        if not return_logits:\n            masks = masks > self.model.mask_threshold\n\n        return masks, iou_predictions, low_res_masks", ""]}
{"filename": "sam_hq/automatic.py", "chunked_list": ["# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport numpy as np\n\nfrom typing import List, Optional\n", "from typing import List, Optional\n\nfrom segment_anything import SamAutomaticMaskGenerator\nfrom segment_anything.utils.amg import build_all_layer_point_grids\nfrom .predictor import SamPredictorHQ\n\n\nclass SamAutomaticMaskGeneratorHQ(SamAutomaticMaskGenerator):\n    def __init__(\n        self,\n        model: SamPredictorHQ,\n        points_per_side: Optional[int] = 32,\n        points_per_batch: int = 64,\n        pred_iou_thresh: float = 0.88,\n        stability_score_thresh: float = 0.95,\n        stability_score_offset: float = 1.0,\n        box_nms_thresh: float = 0.7,\n        crop_n_layers: int = 0,\n        crop_nms_thresh: float = 0.7,\n        crop_overlap_ratio: float = 512 / 1500,\n        crop_n_points_downscale_factor: int = 1,\n        point_grids: Optional[List[np.ndarray]] = None,\n        min_mask_region_area: int = 0,\n        output_mode: str = \"binary_mask\",\n    ) -> None:\n        \"\"\"\n        Using a SAM model, generates masks for the entire image.\n        Generates a grid of point prompts over the image, then filters\n        low quality and duplicate masks. The default settings are chosen\n        for SAM with a ViT-H backbone.\n\n        Arguments:\n          model (Sam): The SAM model to use for mask prediction.\n          points_per_side (int or None): The number of points to be sampled\n            along one side of the image. The total number of points is\n            points_per_side**2. If None, 'point_grids' must provide explicit\n            point sampling.\n          points_per_batch (int): Sets the number of points run simultaneously\n            by the model. Higher numbers may be faster but use more GPU memory.\n          pred_iou_thresh (float): A filtering threshold in [0,1], using the\n            model's predicted mask quality.\n          stability_score_thresh (float): A filtering threshold in [0,1], using\n            the stability of the mask under changes to the cutoff used to binarize\n            the model's mask predictions.\n          stability_score_offset (float): The amount to shift the cutoff when\n            calculated the stability score.\n          box_nms_thresh (float): The box IoU cutoff used by non-maximal\n            suppression to filter duplicate masks.\n          crop_n_layers (int): If >0, mask prediction will be run again on\n            crops of the image. Sets the number of layers to run, where each\n            layer has 2**i_layer number of image crops.\n          crop_nms_thresh (float): The box IoU cutoff used by non-maximal\n            suppression to filter duplicate masks between different crops.\n          crop_overlap_ratio (float): Sets the degree to which crops overlap.\n            In the first crop layer, crops will overlap by this fraction of\n            the image length. Later layers with more crops scale down this overlap.\n          crop_n_points_downscale_factor (int): The number of points-per-side\n            sampled in layer n is scaled down by crop_n_points_downscale_factor**n.\n          point_grids (list(np.ndarray) or None): A list over explicit grids\n            of points used for sampling, normalized to [0,1]. The nth grid in the\n            list is used in the nth crop layer. Exclusive with points_per_side.\n          min_mask_region_area (int): If >0, postprocessing will be applied\n            to remove disconnected regions and holes in masks with area smaller\n            than min_mask_region_area. Requires opencv.\n          output_mode (str): The form masks are returned in. Can be 'binary_mask',\n            'uncompressed_rle', or 'coco_rle'. 'coco_rle' requires pycocotools.\n            For large resolutions, 'binary_mask' may consume large amounts of\n            memory.\n        \"\"\"\n\n        assert (points_per_side is None) != (\n            point_grids is None\n        ), \"Exactly one of points_per_side or point_grid must be provided.\"\n        if points_per_side is not None:\n            self.point_grids = build_all_layer_point_grids(\n                points_per_side,\n                crop_n_layers,\n                crop_n_points_downscale_factor,\n            )\n        elif point_grids is not None:\n            self.point_grids = point_grids\n        else:\n            raise ValueError(\"Can't have both points_per_side and point_grid be None.\")\n\n        assert output_mode in [\n            \"binary_mask\",\n            \"uncompressed_rle\",\n            \"coco_rle\",\n        ], f\"Unknown output_mode {output_mode}.\"\n        if output_mode == \"coco_rle\":\n            from pycocotools import mask as mask_utils  # type: ignore # noqa: F401\n\n        if min_mask_region_area > 0:\n            import cv2  # type: ignore # noqa: F401\n\n        self.predictor = model\n        self.points_per_batch = points_per_batch\n        self.pred_iou_thresh = pred_iou_thresh\n        self.stability_score_thresh = stability_score_thresh\n        self.stability_score_offset = stability_score_offset\n        self.box_nms_thresh = box_nms_thresh\n        self.crop_n_layers = crop_n_layers\n        self.crop_nms_thresh = crop_nms_thresh\n        self.crop_overlap_ratio = crop_overlap_ratio\n        self.crop_n_points_downscale_factor = crop_n_points_downscale_factor\n        self.min_mask_region_area = min_mask_region_area\n        self.output_mode = output_mode", ""]}
{"filename": "sam_hq/modeling/tiny_vit.py", "chunked_list": ["# --------------------------------------------------------\n# TinyViT Model Architecture\n# Copyright (c) 2022 Microsoft\n# Adapted from LeViT and Swin Transformer\n#   LeViT: (https://github.com/facebookresearch/levit)\n#   Swin: (https://github.com/microsoft/swin-transformer)\n# Build the TinyViT Model\n# --------------------------------------------------------\n\nimport itertools", "\nimport itertools\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.utils.checkpoint as checkpoint\nfrom timm.models.layers import DropPath as TimmDropPath,\\\n    to_2tuple, trunc_normal_\nfrom timm.models.registry import register_model\nfrom typing import Tuple", "from timm.models.registry import register_model\nfrom typing import Tuple\n\n\nclass Conv2d_BN(torch.nn.Sequential):\n    def __init__(self, a, b, ks=1, stride=1, pad=0, dilation=1,\n                 groups=1, bn_weight_init=1):\n        super().__init__()\n        self.add_module('c', torch.nn.Conv2d(\n            a, b, ks, stride, pad, dilation, groups, bias=False))\n        bn = torch.nn.BatchNorm2d(b)\n        torch.nn.init.constant_(bn.weight, bn_weight_init)\n        torch.nn.init.constant_(bn.bias, 0)\n        self.add_module('bn', bn)\n\n    @torch.no_grad()\n    def fuse(self):\n        c, bn = self._modules.values()\n        w = bn.weight / (bn.running_var + bn.eps)**0.5\n        w = c.weight * w[:, None, None, None]\n        b = bn.bias - bn.running_mean * bn.weight / \\\n            (bn.running_var + bn.eps)**0.5\n        m = torch.nn.Conv2d(w.size(1) * self.c.groups, w.size(\n            0), w.shape[2:], stride=self.c.stride, padding=self.c.padding, dilation=self.c.dilation, groups=self.c.groups)\n        m.weight.data.copy_(w)\n        m.bias.data.copy_(b)\n        return m", "\n\nclass DropPath(TimmDropPath):\n    def __init__(self, drop_prob=None):\n        super().__init__(drop_prob=drop_prob)\n        self.drop_prob = drop_prob\n\n    def __repr__(self):\n        msg = super().__repr__()\n        msg += f'(drop_prob={self.drop_prob})'\n        return msg", "\n\nclass PatchEmbed(nn.Module):\n    def __init__(self, in_chans, embed_dim, resolution, activation):\n        super().__init__()\n        img_size: Tuple[int, int] = to_2tuple(resolution)\n        self.patches_resolution = (img_size[0] // 4, img_size[1] // 4)\n        self.num_patches = self.patches_resolution[0] * \\\n            self.patches_resolution[1]\n        self.in_chans = in_chans\n        self.embed_dim = embed_dim\n        n = embed_dim\n        self.seq = nn.Sequential(\n            Conv2d_BN(in_chans, n // 2, 3, 2, 1),\n            activation(),\n            Conv2d_BN(n // 2, n, 3, 2, 1),\n        )\n\n    def forward(self, x):\n        return self.seq(x)", "\n\nclass MBConv(nn.Module):\n    def __init__(self, in_chans, out_chans, expand_ratio,\n                 activation, drop_path):\n        super().__init__()\n        self.in_chans = in_chans\n        self.hidden_chans = int(in_chans * expand_ratio)\n        self.out_chans = out_chans\n\n        self.conv1 = Conv2d_BN(in_chans, self.hidden_chans, ks=1)\n        self.act1 = activation()\n\n        self.conv2 = Conv2d_BN(self.hidden_chans, self.hidden_chans,\n                               ks=3, stride=1, pad=1, groups=self.hidden_chans)\n        self.act2 = activation()\n\n        self.conv3 = Conv2d_BN(\n            self.hidden_chans, out_chans, ks=1, bn_weight_init=0.0)\n        self.act3 = activation()\n\n        self.drop_path = DropPath(\n            drop_path) if drop_path > 0. else nn.Identity()\n\n    def forward(self, x):\n        shortcut = x\n\n        x = self.conv1(x)\n        x = self.act1(x)\n\n        x = self.conv2(x)\n        x = self.act2(x)\n\n        x = self.conv3(x)\n\n        x = self.drop_path(x)\n\n        x += shortcut\n        x = self.act3(x)\n\n        return x", "\n\nclass PatchMerging(nn.Module):\n    def __init__(self, input_resolution, dim, out_dim, activation):\n        super().__init__()\n\n        self.input_resolution = input_resolution\n        self.dim = dim\n        self.out_dim = out_dim\n        self.act = activation()\n        self.conv1 = Conv2d_BN(dim, out_dim, 1, 1, 0)\n        stride_c=2\n        if(out_dim==320 or out_dim==448 or out_dim==576):\n            stride_c=1\n        self.conv2 = Conv2d_BN(out_dim, out_dim, 3, stride_c, 1, groups=out_dim)\n        self.conv3 = Conv2d_BN(out_dim, out_dim, 1, 1, 0)\n\n    def forward(self, x):\n        if x.ndim == 3:\n            H, W = self.input_resolution\n            B = len(x)\n            # (B, C, H, W)\n            x = x.view(B, H, W, -1).permute(0, 3, 1, 2)\n\n        x = self.conv1(x)\n        x = self.act(x)\n\n        x = self.conv2(x)\n        x = self.act(x)\n        x = self.conv3(x)\n        x = x.flatten(2).transpose(1, 2)\n        return x", "\n\nclass ConvLayer(nn.Module):\n    def __init__(self, dim, input_resolution, depth,\n                 activation,\n                 drop_path=0., downsample=None, use_checkpoint=False,\n                 out_dim=None,\n                 conv_expand_ratio=4.,\n                 ):\n\n        super().__init__()\n        self.dim = dim\n        self.input_resolution = input_resolution\n        self.depth = depth\n        self.use_checkpoint = use_checkpoint\n\n        # build blocks\n        self.blocks = nn.ModuleList([\n            MBConv(dim, dim, conv_expand_ratio, activation,\n                   drop_path[i] if isinstance(drop_path, list) else drop_path,\n                   )\n            for i in range(depth)])\n\n        # patch merging layer\n        if downsample is not None:\n            self.downsample = downsample(\n                input_resolution, dim=dim, out_dim=out_dim, activation=activation)\n        else:\n            self.downsample = None\n\n    def forward(self, x):\n        for blk in self.blocks:\n            if self.use_checkpoint:\n                x = checkpoint.checkpoint(blk, x)\n            else:\n                x = blk(x)\n        if self.downsample is not None:\n            x = self.downsample(x)\n        return x", "\n\nclass Mlp(nn.Module):\n    def __init__(self, in_features, hidden_features=None,\n                 out_features=None, act_layer=nn.GELU, drop=0.):\n        super().__init__()\n        out_features = out_features or in_features\n        hidden_features = hidden_features or in_features\n        self.norm = nn.LayerNorm(in_features)\n        self.fc1 = nn.Linear(in_features, hidden_features)\n        self.fc2 = nn.Linear(hidden_features, out_features)\n        self.act = act_layer()\n        self.drop = nn.Dropout(drop)\n\n    def forward(self, x):\n        x = self.norm(x)\n\n        x = self.fc1(x)\n        x = self.act(x)\n        x = self.drop(x)\n        x = self.fc2(x)\n        x = self.drop(x)\n        return x", "\n\nclass Attention(torch.nn.Module):\n    def __init__(self, dim, key_dim, num_heads=8,\n                 attn_ratio=4,\n                 resolution=(14, 14),\n                 ):\n        super().__init__()\n        # (h, w)\n        assert isinstance(resolution, tuple) and len(resolution) == 2\n        self.num_heads = num_heads\n        self.scale = key_dim ** -0.5\n        self.key_dim = key_dim\n        self.nh_kd = nh_kd = key_dim * num_heads\n        self.d = int(attn_ratio * key_dim)\n        self.dh = int(attn_ratio * key_dim) * num_heads\n        self.attn_ratio = attn_ratio\n        h = self.dh + nh_kd * 2\n\n        self.norm = nn.LayerNorm(dim)\n        self.qkv = nn.Linear(dim, h)\n        self.proj = nn.Linear(self.dh, dim)\n\n        points = list(itertools.product(\n            range(resolution[0]), range(resolution[1])))\n        N = len(points)\n        attention_offsets = {}\n        idxs = []\n        for p1 in points:\n            for p2 in points:\n                offset = (abs(p1[0] - p2[0]), abs(p1[1] - p2[1]))\n                if offset not in attention_offsets:\n                    attention_offsets[offset] = len(attention_offsets)\n                idxs.append(attention_offsets[offset])\n        self.attention_biases = torch.nn.Parameter(\n            torch.zeros(num_heads, len(attention_offsets)))\n        self.register_buffer('attention_bias_idxs',\n                             torch.LongTensor(idxs).view(N, N),\n                             persistent=False)\n\n    @torch.no_grad()\n    def train(self, mode=True):\n        super().train(mode)\n        if mode and hasattr(self, 'ab'):\n            del self.ab\n        else:\n            self.ab = self.attention_biases[:, self.attention_bias_idxs]\n\n    def forward(self, x):  # x (B,N,C)\n        B, N, _ = x.shape\n\n        # Normalization\n        x = self.norm(x)\n\n        qkv = self.qkv(x)\n        # (B, N, num_heads, d)\n        q, k, v = qkv.view(B, N, self.num_heads, -\n                           1).split([self.key_dim, self.key_dim, self.d], dim=3)\n        # (B, num_heads, N, d)\n        q = q.permute(0, 2, 1, 3)\n        k = k.permute(0, 2, 1, 3)\n        v = v.permute(0, 2, 1, 3)\n\n        attn = (\n            (q @ k.transpose(-2, -1)) * self.scale\n            +\n            (self.attention_biases[:, self.attention_bias_idxs]\n             if self.training else self.ab)\n        )\n        attn = attn.softmax(dim=-1)\n        x = (attn @ v).transpose(1, 2).reshape(B, N, self.dh)\n        x = self.proj(x)\n        return x", "\n\nclass TinyViTBlock(nn.Module):\n    r\"\"\" TinyViT Block.\n\n    Args:\n        dim (int): Number of input channels.\n        input_resolution (tuple[int, int]): Input resulotion.\n        num_heads (int): Number of attention heads.\n        window_size (int): Window size.\n        mlp_ratio (float): Ratio of mlp hidden dim to embedding dim.\n        drop (float, optional): Dropout rate. Default: 0.0\n        drop_path (float, optional): Stochastic depth rate. Default: 0.0\n        local_conv_size (int): the kernel size of the convolution between\n                               Attention and MLP. Default: 3\n        activation: the activation function. Default: nn.GELU\n    \"\"\"\n\n    def __init__(self, dim, input_resolution, num_heads, window_size=7,\n                 mlp_ratio=4., drop=0., drop_path=0.,\n                 local_conv_size=3,\n                 activation=nn.GELU,\n                 ):\n        super().__init__()\n        self.dim = dim\n        self.input_resolution = input_resolution\n        self.num_heads = num_heads\n        assert window_size > 0, 'window_size must be greater than 0'\n        self.window_size = window_size\n        self.mlp_ratio = mlp_ratio\n\n        self.drop_path = DropPath(\n            drop_path) if drop_path > 0. else nn.Identity()\n\n        assert dim % num_heads == 0, 'dim must be divisible by num_heads'\n        head_dim = dim // num_heads\n\n        window_resolution = (window_size, window_size)\n        self.attn = Attention(dim, head_dim, num_heads,\n                              attn_ratio=1, resolution=window_resolution)\n\n        mlp_hidden_dim = int(dim * mlp_ratio)\n        mlp_activation = activation\n        self.mlp = Mlp(in_features=dim, hidden_features=mlp_hidden_dim,\n                       act_layer=mlp_activation, drop=drop)\n\n        pad = local_conv_size // 2\n        self.local_conv = Conv2d_BN(\n            dim, dim, ks=local_conv_size, stride=1, pad=pad, groups=dim)\n\n    def forward(self, x):\n        H, W = self.input_resolution\n        B, L, C = x.shape\n        assert L == H * W, \"input feature has wrong size\"\n        res_x = x\n        if H == self.window_size and W == self.window_size:\n            x = self.attn(x)\n        else:\n            x = x.view(B, H, W, C)\n            pad_b = (self.window_size - H %\n                     self.window_size) % self.window_size\n            pad_r = (self.window_size - W %\n                     self.window_size) % self.window_size\n            padding = pad_b > 0 or pad_r > 0\n\n            if padding:\n                x = F.pad(x, (0, 0, 0, pad_r, 0, pad_b))\n\n            pH, pW = H + pad_b, W + pad_r\n            nH = pH // self.window_size\n            nW = pW // self.window_size\n            # window partition\n            x = x.view(B, nH, self.window_size, nW, self.window_size, C).transpose(2, 3).reshape(\n                B * nH * nW, self.window_size * self.window_size, C)\n            x = self.attn(x)\n            # window reverse\n            x = x.view(B, nH, nW, self.window_size, self.window_size,\n                       C).transpose(2, 3).reshape(B, pH, pW, C)\n\n            if padding:\n                x = x[:, :H, :W].contiguous()\n\n            x = x.view(B, L, C)\n\n        x = res_x + self.drop_path(x)\n\n        x = x.transpose(1, 2).reshape(B, C, H, W)\n        x = self.local_conv(x)\n        x = x.view(B, C, L).transpose(1, 2)\n\n        x = x + self.drop_path(self.mlp(x))\n        return x\n\n    def extra_repr(self) -> str:\n        return f\"dim={self.dim}, input_resolution={self.input_resolution}, num_heads={self.num_heads}, \" \\\n               f\"window_size={self.window_size}, mlp_ratio={self.mlp_ratio}\"", "\n\nclass BasicLayer(nn.Module):\n    \"\"\" A basic TinyViT layer for one stage.\n\n    Args:\n        dim (int): Number of input channels.\n        input_resolution (tuple[int]): Input resolution.\n        depth (int): Number of blocks.\n        num_heads (int): Number of attention heads.\n        window_size (int): Local window size.\n        mlp_ratio (float): Ratio of mlp hidden dim to embedding dim.\n        drop (float, optional): Dropout rate. Default: 0.0\n        drop_path (float | tuple[float], optional): Stochastic depth rate. Default: 0.0\n        downsample (nn.Module | None, optional): Downsample layer at the end of the layer. Default: None\n        use_checkpoint (bool): Whether to use checkpointing to save memory. Default: False.\n        local_conv_size: the kernel size of the depthwise convolution between attention and MLP. Default: 3\n        activation: the activation function. Default: nn.GELU\n        out_dim: the output dimension of the layer. Default: dim\n    \"\"\"\n\n    def __init__(self, dim, input_resolution, depth, num_heads, window_size,\n                 mlp_ratio=4., drop=0.,\n                 drop_path=0., downsample=None, use_checkpoint=False,\n                 local_conv_size=3,\n                 activation=nn.GELU,\n                 out_dim=None,\n                 ):\n\n        super().__init__()\n        self.dim = dim\n        self.input_resolution = input_resolution\n        self.depth = depth\n        self.use_checkpoint = use_checkpoint\n\n        # build blocks\n        self.blocks = nn.ModuleList([\n            TinyViTBlock(dim=dim, input_resolution=input_resolution,\n                         num_heads=num_heads, window_size=window_size,\n                         mlp_ratio=mlp_ratio,\n                         drop=drop,\n                         drop_path=drop_path[i] if isinstance(\n                             drop_path, list) else drop_path,\n                         local_conv_size=local_conv_size,\n                         activation=activation,\n                         )\n            for i in range(depth)])\n\n        # patch merging layer\n        if downsample is not None:\n            self.downsample = downsample(\n                input_resolution, dim=dim, out_dim=out_dim, activation=activation)\n        else:\n            self.downsample = None\n\n    def forward(self, x):\n        for blk in self.blocks:\n            if self.use_checkpoint:\n                x = checkpoint.checkpoint(blk, x)\n            else:\n                x = blk(x)\n        if self.downsample is not None:\n            x = self.downsample(x)\n        return x\n\n    def extra_repr(self) -> str:\n        return f\"dim={self.dim}, input_resolution={self.input_resolution}, depth={self.depth}\"", "\nclass LayerNorm2d(nn.Module):\n    def __init__(self, num_channels: int, eps: float = 1e-6) -> None:\n        super().__init__()\n        self.weight = nn.Parameter(torch.ones(num_channels))\n        self.bias = nn.Parameter(torch.zeros(num_channels))\n        self.eps = eps\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        u = x.mean(1, keepdim=True)\n        s = (x - u).pow(2).mean(1, keepdim=True)\n        x = (x - u) / torch.sqrt(s + self.eps)\n        x = self.weight[:, None, None] * x + self.bias[:, None, None]\n        return x", "class TinyViT(nn.Module):\n    def __init__(self, img_size=224, in_chans=3, num_classes=1000,\n                 embed_dims=[96, 192, 384, 768], depths=[2, 2, 6, 2],\n                 num_heads=[3, 6, 12, 24],\n                 window_sizes=[7, 7, 14, 7],\n                 mlp_ratio=4.,\n                 drop_rate=0.,\n                 drop_path_rate=0.1,\n                 use_checkpoint=False,\n                 mbconv_expand_ratio=4.0,\n                 local_conv_size=3,\n                 layer_lr_decay=1.0,\n                 ):\n        super().__init__()\n        self.img_size=img_size\n        self.num_classes = num_classes\n        self.depths = depths\n        self.num_layers = len(depths)\n        self.mlp_ratio = mlp_ratio\n\n        activation = nn.GELU\n\n        self.patch_embed = PatchEmbed(in_chans=in_chans,\n                                      embed_dim=embed_dims[0],\n                                      resolution=img_size,\n                                      activation=activation)\n\n        patches_resolution = self.patch_embed.patches_resolution\n        self.patches_resolution = patches_resolution\n\n        # stochastic depth\n        dpr = [x.item() for x in torch.linspace(0, drop_path_rate,\n                                                sum(depths))]  # stochastic depth decay rule\n\n        # build layers\n        self.layers = nn.ModuleList()\n        for i_layer in range(self.num_layers):\n            kwargs = dict(dim=embed_dims[i_layer],\n                        input_resolution=(patches_resolution[0] // (2 ** (i_layer-1 if i_layer == 3 else i_layer)),\n                                patches_resolution[1] // (2 ** (i_layer-1 if i_layer == 3 else i_layer))),\n                        #   input_resolution=(patches_resolution[0] // (2 ** i_layer),\n                        #                     patches_resolution[1] // (2 ** i_layer)),\n                          depth=depths[i_layer],\n                          drop_path=dpr[sum(depths[:i_layer]):sum(depths[:i_layer + 1])],\n                          downsample=PatchMerging if (\n                              i_layer < self.num_layers - 1) else None,\n                          use_checkpoint=use_checkpoint,\n                          out_dim=embed_dims[min(\n                              i_layer + 1, len(embed_dims) - 1)],\n                          activation=activation,\n                          )\n            if i_layer == 0:\n                layer = ConvLayer(\n                    conv_expand_ratio=mbconv_expand_ratio,\n                    **kwargs,\n                )\n            else:\n                layer = BasicLayer(\n                    num_heads=num_heads[i_layer],\n                    window_size=window_sizes[i_layer],\n                    mlp_ratio=self.mlp_ratio,\n                    drop=drop_rate,\n                    local_conv_size=local_conv_size,\n                    **kwargs)\n            self.layers.append(layer)\n\n        # Classifier head\n        self.norm_head = nn.LayerNorm(embed_dims[-1])\n        self.head = nn.Linear(\n            embed_dims[-1], num_classes) if num_classes > 0 else torch.nn.Identity()\n\n        # init weights\n        self.apply(self._init_weights)\n        self.set_layer_lr_decay(layer_lr_decay)\n        self.neck = nn.Sequential(\n            nn.Conv2d(\n                embed_dims[-1],\n                256,\n                kernel_size=1,\n                bias=False,\n            ),\n            LayerNorm2d(256),\n            nn.Conv2d(\n                256,\n                256,\n                kernel_size=3,\n                padding=1,\n                bias=False,\n            ),\n            LayerNorm2d(256),\n        )\n    def set_layer_lr_decay(self, layer_lr_decay):\n        decay_rate = layer_lr_decay\n\n        # layers -> blocks (depth)\n        depth = sum(self.depths)\n        lr_scales = [decay_rate ** (depth - i - 1) for i in range(depth)]\n        print(\"LR SCALES:\", lr_scales)\n\n        def _set_lr_scale(m, scale):\n            for p in m.parameters():\n                p.lr_scale = scale\n\n        self.patch_embed.apply(lambda x: _set_lr_scale(x, lr_scales[0]))\n        i = 0\n        for layer in self.layers:\n            for block in layer.blocks:\n                block.apply(lambda x: _set_lr_scale(x, lr_scales[i]))\n                i += 1\n            if layer.downsample is not None:\n                layer.downsample.apply(\n                    lambda x: _set_lr_scale(x, lr_scales[i - 1]))\n        assert i == depth\n        for m in [self.norm_head, self.head]:\n            m.apply(lambda x: _set_lr_scale(x, lr_scales[-1]))\n\n        for k, p in self.named_parameters():\n            p.param_name = k\n\n        def _check_lr_scale(m):\n            for p in m.parameters():\n                assert hasattr(p, 'lr_scale'), p.param_name\n\n        self.apply(_check_lr_scale)\n\n    def _init_weights(self, m):\n        if isinstance(m, nn.Linear):\n            trunc_normal_(m.weight, std=.02)\n            if isinstance(m, nn.Linear) and m.bias is not None:\n                nn.init.constant_(m.bias, 0)\n        elif isinstance(m, nn.LayerNorm):\n            nn.init.constant_(m.bias, 0)\n            nn.init.constant_(m.weight, 1.0)\n\n    @torch.jit.ignore\n    def no_weight_decay_keywords(self):\n        return {'attention_biases'}\n\n    def forward_features(self, x):\n        # x: (N, C, H, W)\n        x = self.patch_embed(x)\n\n        x = self.layers[0](x)\n        start_i = 1\n\n        for i in range(start_i, len(self.layers)):\n            layer = self.layers[i]\n            x = layer(x)\n        B,_,C=x.size()\n        x = x.view(B, 64, 64, C)\n        x=x.permute(0, 3, 1, 2)\n        x=self.neck(x)\n        return x\n\n    def forward(self, x):\n        x = self.forward_features(x)\n        #x = self.norm_head(x)\n        #x = self.head(x)\n        return x", ""]}
{"filename": "sam_hq/modeling/image_encoder.py", "chunked_list": ["import torch\nfrom segment_anything.modeling import ImageEncoderViT\n\n# This class and its supporting functions below lightly adapted from the ViTDet backbone available at: https://github.com/facebookresearch/detectron2/blob/main/detectron2/modeling/backbone/vit.py # noqa\nclass ImageEncoderViTHQ(ImageEncoderViT):\n    \n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        x = self.patch_embed(x)\n        if self.pos_embed is not None:\n            x = x + self.pos_embed\n\n        interm_embeddings=[]\n        for blk in self.blocks:\n            x = blk(x)\n            if blk.window_size == 0:\n                interm_embeddings.append(x)\n\n        x = self.neck(x.permute(0, 3, 1, 2))\n\n        return x, interm_embeddings"]}
{"filename": "sam_hq/modeling/mask_decoder_hq.py", "chunked_list": ["# Copyright (c) Meta Platforms, Inc. and affiliates.\n# Modified by HQ-SAM team\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F", "from torch import nn\nfrom torch.nn import functional as F\n\nfrom typing import List, Tuple, Type\n\nfrom segment_anything.modeling.common import LayerNorm2d\n\n\nclass MaskDecoderHQ(nn.Module):\n    def __init__(\n        self,\n        *,\n        transformer_dim: int,\n        transformer: nn.Module,\n        num_multimask_outputs: int = 3,\n        activation: Type[nn.Module] = nn.GELU,\n        iou_head_depth: int = 3,\n        iou_head_hidden_dim: int = 256,\n        vit_dim: int = 1024,\n    ) -> None:\n        \"\"\"\n        Predicts masks given an image and prompt embeddings, using a\n        transformer architecture.\n\n        Arguments:\n          transformer_dim (int): the channel dimension of the transformer\n          transformer (nn.Module): the transformer used to predict masks\n          num_multimask_outputs (int): the number of masks to predict\n            when disambiguating masks\n          activation (nn.Module): the type of activation to use when\n            upscaling masks\n          iou_head_depth (int): the depth of the MLP used to predict\n            mask quality\n          iou_head_hidden_dim (int): the hidden dimension of the MLP\n            used to predict mask quality\n        \"\"\"\n        super().__init__()\n        self.transformer_dim = transformer_dim\n        self.transformer = transformer\n\n        self.num_multimask_outputs = num_multimask_outputs\n\n        self.iou_token = nn.Embedding(1, transformer_dim)\n        self.num_mask_tokens = num_multimask_outputs + 1\n        self.mask_tokens = nn.Embedding(self.num_mask_tokens, transformer_dim)\n\n        self.output_upscaling = nn.Sequential(\n            nn.ConvTranspose2d(transformer_dim, transformer_dim // 4, kernel_size=2, stride=2),\n            LayerNorm2d(transformer_dim // 4),\n            activation(),\n            nn.ConvTranspose2d(transformer_dim // 4, transformer_dim // 8, kernel_size=2, stride=2),\n            activation(),\n        )\n        self.output_hypernetworks_mlps = nn.ModuleList(\n            [\n                MLP(transformer_dim, transformer_dim, transformer_dim // 8, 3)\n                for i in range(self.num_mask_tokens)\n            ]\n        )\n\n        self.iou_prediction_head = MLP(\n            transformer_dim, iou_head_hidden_dim, self.num_mask_tokens, iou_head_depth\n        )\n\n        # HQ-SAM parameters\n        self.hf_token = nn.Embedding(1, transformer_dim) # HQ-Ouptput-Token\n        self.hf_mlp = MLP(transformer_dim, transformer_dim, transformer_dim // 8, 3) # corresponding new MLP layer for HQ-Ouptput-Token\n        self.num_mask_tokens = self.num_mask_tokens + 1\n        \n        # three conv fusion layers for obtaining HQ-Feature\n        self.compress_vit_feat = nn.Sequential(\n                                        nn.ConvTranspose2d(vit_dim, transformer_dim, kernel_size=2, stride=2),\n                                        LayerNorm2d(transformer_dim),\n                                        nn.GELU(), \n                                        nn.ConvTranspose2d(transformer_dim, transformer_dim // 8, kernel_size=2, stride=2))\n        \n        self.embedding_encoder = nn.Sequential(\n                                        nn.ConvTranspose2d(transformer_dim, transformer_dim // 4, kernel_size=2, stride=2),\n                                        LayerNorm2d(transformer_dim // 4),\n                                        nn.GELU(),\n                                        nn.ConvTranspose2d(transformer_dim // 4, transformer_dim // 8, kernel_size=2, stride=2),\n                                    )\n        self.embedding_maskfeature = nn.Sequential(\n                                        nn.Conv2d(transformer_dim // 8, transformer_dim // 4, 3, 1, 1), \n                                        LayerNorm2d(transformer_dim // 4),\n                                        nn.GELU(),\n                                        nn.Conv2d(transformer_dim // 4, transformer_dim // 8, 3, 1, 1))\n\n\n\n    def forward(\n        self,\n        image_embeddings: torch.Tensor,\n        image_pe: torch.Tensor,\n        sparse_prompt_embeddings: torch.Tensor,\n        dense_prompt_embeddings: torch.Tensor,\n        multimask_output: bool,\n        hq_token_only: bool = False,\n        interm_embeddings: torch.Tensor = None,\n    ) -> Tuple[torch.Tensor, torch.Tensor]:\n        \"\"\"\n        Predict masks given image and prompt embeddings.\n\n        Arguments:\n          image_embeddings (torch.Tensor): the embeddings from the ViT image encoder\n          image_pe (torch.Tensor): positional encoding with the shape of image_embeddings\n          sparse_prompt_embeddings (torch.Tensor): the embeddings of the points and boxes\n          dense_prompt_embeddings (torch.Tensor): the embeddings of the mask inputs\n          multimask_output (bool): Whether to return multiple masks or a single\n            mask.\n\n        Returns:\n          torch.Tensor: batched predicted masks\n          torch.Tensor: batched predictions of mask quality\n        \"\"\"\n        vit_features = interm_embeddings[0].permute(0, 3, 1, 2) # early-layer ViT feature, after 1st global attention block in ViT\n        hq_features = self.embedding_encoder(image_embeddings) + self.compress_vit_feat(vit_features)\n\n        masks, iou_pred, masks_hq = self.predict_masks(\n            image_embeddings=image_embeddings,\n            image_pe=image_pe,\n            sparse_prompt_embeddings=sparse_prompt_embeddings,\n            dense_prompt_embeddings=dense_prompt_embeddings,\n            hq_features=hq_features,\n        )\n\n        # Select the correct mask or masks for output\n        # if multimask_output:\n        #     # mask with highest score\n        #     mask_slice = slice(1,self.num_mask_tokens-1)\n        #     iou_pred = iou_pred[:, mask_slice]\n        #     iou_pred, max_iou_idx = torch.max(iou_pred,dim=1)\n        #     iou_pred = iou_pred.unsqueeze(1)\n        #     masks_multi = masks[:, mask_slice, :, :]\n        #     masks_sam = masks_multi[torch.arange(masks_multi.size(0)),max_iou_idx].unsqueeze(1)\n        # else:\n        #     # single mask output, default\n        #     mask_slice = slice(0, 1)\n        #     iou_pred = iou_pred[:,mask_slice]\n        #     masks_sam = masks[:,mask_slice]\n        if multimask_output:\n            mask_slice = slice(1, None)\n        else:\n            mask_slice = slice(0, 1)\n        masks_sam = masks[:, mask_slice, :, :]\n        iou_pred = iou_pred[:, mask_slice]\n        if hq_token_only:\n            masks = masks_hq\n        else:\n            masks = masks_sam + masks_hq\n        # Prepare output\n        return masks, iou_pred\n\n    def predict_masks(\n        self,\n        image_embeddings: torch.Tensor,\n        image_pe: torch.Tensor,\n        sparse_prompt_embeddings: torch.Tensor,\n        dense_prompt_embeddings: torch.Tensor,\n        hq_features: torch.Tensor,\n    ) -> Tuple[torch.Tensor, torch.Tensor]:\n        \"\"\"Predicts masks. See 'forward' for more details.\"\"\"\n        # Concatenate output tokens\n        output_tokens = torch.cat([self.iou_token.weight, self.mask_tokens.weight, self.hf_token.weight], dim=0)\n        output_tokens = output_tokens.unsqueeze(0).expand(sparse_prompt_embeddings.size(0), -1, -1)\n        tokens = torch.cat((output_tokens, sparse_prompt_embeddings), dim=1)\n\n        # Expand per-image data in batch direction to be per-mask\n        src = torch.repeat_interleave(image_embeddings, tokens.shape[0], dim=0)\n        src = src + dense_prompt_embeddings\n        pos_src = torch.repeat_interleave(image_pe, tokens.shape[0], dim=0)\n        b, c, h, w = src.shape\n\n        # Run the transformer\n        hs, src = self.transformer(src, pos_src, tokens)\n        iou_token_out = hs[:, 0, :]\n        mask_tokens_out = hs[:, 1 : (1 + self.num_mask_tokens), :]\n\n        # Upscale mask embeddings and predict masks using the mask tokens\n        src = src.transpose(1, 2).view(b, c, h, w)\n\n        upscaled_embedding_sam = self.output_upscaling(src)\n        upscaled_embedding_hq = self.embedding_maskfeature(upscaled_embedding_sam) + hq_features.repeat(b,1,1,1)\n\n        hyper_in_list: List[torch.Tensor] = []\n        for i in range(self.num_mask_tokens):\n            if i < self.num_mask_tokens - 1:\n                hyper_in_list.append(self.output_hypernetworks_mlps[i](mask_tokens_out[:, i, :]))\n            else:\n                hyper_in_list.append(self.hf_mlp(mask_tokens_out[:, i, :]))\n\n        hyper_in = torch.stack(hyper_in_list, dim=1)\n        b, c, h, w = upscaled_embedding_sam.shape\n\n        masks_sam = (hyper_in[:,:self.num_mask_tokens-1] @ upscaled_embedding_sam.view(b, c, h * w)).view(b, -1, h, w)\n        masks_sam_hq = (hyper_in[:,self.num_mask_tokens-1:] @ upscaled_embedding_hq.view(b, c, h * w)).view(b, -1, h, w)\n        # masks = torch.cat([masks_sam,masks_sam_hq],dim=1)\n        # Generate mask quality predictions\n        iou_pred = self.iou_prediction_head(iou_token_out)\n\n        return masks_sam, iou_pred, masks_sam_hq", "class MaskDecoderHQ(nn.Module):\n    def __init__(\n        self,\n        *,\n        transformer_dim: int,\n        transformer: nn.Module,\n        num_multimask_outputs: int = 3,\n        activation: Type[nn.Module] = nn.GELU,\n        iou_head_depth: int = 3,\n        iou_head_hidden_dim: int = 256,\n        vit_dim: int = 1024,\n    ) -> None:\n        \"\"\"\n        Predicts masks given an image and prompt embeddings, using a\n        transformer architecture.\n\n        Arguments:\n          transformer_dim (int): the channel dimension of the transformer\n          transformer (nn.Module): the transformer used to predict masks\n          num_multimask_outputs (int): the number of masks to predict\n            when disambiguating masks\n          activation (nn.Module): the type of activation to use when\n            upscaling masks\n          iou_head_depth (int): the depth of the MLP used to predict\n            mask quality\n          iou_head_hidden_dim (int): the hidden dimension of the MLP\n            used to predict mask quality\n        \"\"\"\n        super().__init__()\n        self.transformer_dim = transformer_dim\n        self.transformer = transformer\n\n        self.num_multimask_outputs = num_multimask_outputs\n\n        self.iou_token = nn.Embedding(1, transformer_dim)\n        self.num_mask_tokens = num_multimask_outputs + 1\n        self.mask_tokens = nn.Embedding(self.num_mask_tokens, transformer_dim)\n\n        self.output_upscaling = nn.Sequential(\n            nn.ConvTranspose2d(transformer_dim, transformer_dim // 4, kernel_size=2, stride=2),\n            LayerNorm2d(transformer_dim // 4),\n            activation(),\n            nn.ConvTranspose2d(transformer_dim // 4, transformer_dim // 8, kernel_size=2, stride=2),\n            activation(),\n        )\n        self.output_hypernetworks_mlps = nn.ModuleList(\n            [\n                MLP(transformer_dim, transformer_dim, transformer_dim // 8, 3)\n                for i in range(self.num_mask_tokens)\n            ]\n        )\n\n        self.iou_prediction_head = MLP(\n            transformer_dim, iou_head_hidden_dim, self.num_mask_tokens, iou_head_depth\n        )\n\n        # HQ-SAM parameters\n        self.hf_token = nn.Embedding(1, transformer_dim) # HQ-Ouptput-Token\n        self.hf_mlp = MLP(transformer_dim, transformer_dim, transformer_dim // 8, 3) # corresponding new MLP layer for HQ-Ouptput-Token\n        self.num_mask_tokens = self.num_mask_tokens + 1\n        \n        # three conv fusion layers for obtaining HQ-Feature\n        self.compress_vit_feat = nn.Sequential(\n                                        nn.ConvTranspose2d(vit_dim, transformer_dim, kernel_size=2, stride=2),\n                                        LayerNorm2d(transformer_dim),\n                                        nn.GELU(), \n                                        nn.ConvTranspose2d(transformer_dim, transformer_dim // 8, kernel_size=2, stride=2))\n        \n        self.embedding_encoder = nn.Sequential(\n                                        nn.ConvTranspose2d(transformer_dim, transformer_dim // 4, kernel_size=2, stride=2),\n                                        LayerNorm2d(transformer_dim // 4),\n                                        nn.GELU(),\n                                        nn.ConvTranspose2d(transformer_dim // 4, transformer_dim // 8, kernel_size=2, stride=2),\n                                    )\n        self.embedding_maskfeature = nn.Sequential(\n                                        nn.Conv2d(transformer_dim // 8, transformer_dim // 4, 3, 1, 1), \n                                        LayerNorm2d(transformer_dim // 4),\n                                        nn.GELU(),\n                                        nn.Conv2d(transformer_dim // 4, transformer_dim // 8, 3, 1, 1))\n\n\n\n    def forward(\n        self,\n        image_embeddings: torch.Tensor,\n        image_pe: torch.Tensor,\n        sparse_prompt_embeddings: torch.Tensor,\n        dense_prompt_embeddings: torch.Tensor,\n        multimask_output: bool,\n        hq_token_only: bool = False,\n        interm_embeddings: torch.Tensor = None,\n    ) -> Tuple[torch.Tensor, torch.Tensor]:\n        \"\"\"\n        Predict masks given image and prompt embeddings.\n\n        Arguments:\n          image_embeddings (torch.Tensor): the embeddings from the ViT image encoder\n          image_pe (torch.Tensor): positional encoding with the shape of image_embeddings\n          sparse_prompt_embeddings (torch.Tensor): the embeddings of the points and boxes\n          dense_prompt_embeddings (torch.Tensor): the embeddings of the mask inputs\n          multimask_output (bool): Whether to return multiple masks or a single\n            mask.\n\n        Returns:\n          torch.Tensor: batched predicted masks\n          torch.Tensor: batched predictions of mask quality\n        \"\"\"\n        vit_features = interm_embeddings[0].permute(0, 3, 1, 2) # early-layer ViT feature, after 1st global attention block in ViT\n        hq_features = self.embedding_encoder(image_embeddings) + self.compress_vit_feat(vit_features)\n\n        masks, iou_pred, masks_hq = self.predict_masks(\n            image_embeddings=image_embeddings,\n            image_pe=image_pe,\n            sparse_prompt_embeddings=sparse_prompt_embeddings,\n            dense_prompt_embeddings=dense_prompt_embeddings,\n            hq_features=hq_features,\n        )\n\n        # Select the correct mask or masks for output\n        # if multimask_output:\n        #     # mask with highest score\n        #     mask_slice = slice(1,self.num_mask_tokens-1)\n        #     iou_pred = iou_pred[:, mask_slice]\n        #     iou_pred, max_iou_idx = torch.max(iou_pred,dim=1)\n        #     iou_pred = iou_pred.unsqueeze(1)\n        #     masks_multi = masks[:, mask_slice, :, :]\n        #     masks_sam = masks_multi[torch.arange(masks_multi.size(0)),max_iou_idx].unsqueeze(1)\n        # else:\n        #     # single mask output, default\n        #     mask_slice = slice(0, 1)\n        #     iou_pred = iou_pred[:,mask_slice]\n        #     masks_sam = masks[:,mask_slice]\n        if multimask_output:\n            mask_slice = slice(1, None)\n        else:\n            mask_slice = slice(0, 1)\n        masks_sam = masks[:, mask_slice, :, :]\n        iou_pred = iou_pred[:, mask_slice]\n        if hq_token_only:\n            masks = masks_hq\n        else:\n            masks = masks_sam + masks_hq\n        # Prepare output\n        return masks, iou_pred\n\n    def predict_masks(\n        self,\n        image_embeddings: torch.Tensor,\n        image_pe: torch.Tensor,\n        sparse_prompt_embeddings: torch.Tensor,\n        dense_prompt_embeddings: torch.Tensor,\n        hq_features: torch.Tensor,\n    ) -> Tuple[torch.Tensor, torch.Tensor]:\n        \"\"\"Predicts masks. See 'forward' for more details.\"\"\"\n        # Concatenate output tokens\n        output_tokens = torch.cat([self.iou_token.weight, self.mask_tokens.weight, self.hf_token.weight], dim=0)\n        output_tokens = output_tokens.unsqueeze(0).expand(sparse_prompt_embeddings.size(0), -1, -1)\n        tokens = torch.cat((output_tokens, sparse_prompt_embeddings), dim=1)\n\n        # Expand per-image data in batch direction to be per-mask\n        src = torch.repeat_interleave(image_embeddings, tokens.shape[0], dim=0)\n        src = src + dense_prompt_embeddings\n        pos_src = torch.repeat_interleave(image_pe, tokens.shape[0], dim=0)\n        b, c, h, w = src.shape\n\n        # Run the transformer\n        hs, src = self.transformer(src, pos_src, tokens)\n        iou_token_out = hs[:, 0, :]\n        mask_tokens_out = hs[:, 1 : (1 + self.num_mask_tokens), :]\n\n        # Upscale mask embeddings and predict masks using the mask tokens\n        src = src.transpose(1, 2).view(b, c, h, w)\n\n        upscaled_embedding_sam = self.output_upscaling(src)\n        upscaled_embedding_hq = self.embedding_maskfeature(upscaled_embedding_sam) + hq_features.repeat(b,1,1,1)\n\n        hyper_in_list: List[torch.Tensor] = []\n        for i in range(self.num_mask_tokens):\n            if i < self.num_mask_tokens - 1:\n                hyper_in_list.append(self.output_hypernetworks_mlps[i](mask_tokens_out[:, i, :]))\n            else:\n                hyper_in_list.append(self.hf_mlp(mask_tokens_out[:, i, :]))\n\n        hyper_in = torch.stack(hyper_in_list, dim=1)\n        b, c, h, w = upscaled_embedding_sam.shape\n\n        masks_sam = (hyper_in[:,:self.num_mask_tokens-1] @ upscaled_embedding_sam.view(b, c, h * w)).view(b, -1, h, w)\n        masks_sam_hq = (hyper_in[:,self.num_mask_tokens-1:] @ upscaled_embedding_hq.view(b, c, h * w)).view(b, -1, h, w)\n        # masks = torch.cat([masks_sam,masks_sam_hq],dim=1)\n        # Generate mask quality predictions\n        iou_pred = self.iou_prediction_head(iou_token_out)\n\n        return masks_sam, iou_pred, masks_sam_hq", "\n\n# Lightly adapted from\n# https://github.com/facebookresearch/MaskFormer/blob/main/mask_former/modeling/transformer/transformer_predictor.py # noqa\nclass MLP(nn.Module):\n    def __init__(\n        self,\n        input_dim: int,\n        hidden_dim: int,\n        output_dim: int,\n        num_layers: int,\n        sigmoid_output: bool = False,\n    ) -> None:\n        super().__init__()\n        self.num_layers = num_layers\n        h = [hidden_dim] * (num_layers - 1)\n        self.layers = nn.ModuleList(\n            nn.Linear(n, k) for n, k in zip([input_dim] + h, h + [output_dim])\n        )\n        self.sigmoid_output = sigmoid_output\n\n    def forward(self, x):\n        for i, layer in enumerate(self.layers):\n            x = F.relu(layer(x)) if i < self.num_layers - 1 else layer(x)\n        if self.sigmoid_output:\n            x = F.sigmoid(x)\n        return x", ""]}
