{"filename": "settings.py", "chunked_list": ["\"\"\"\nNetORC configuration file.\n\nWe have kept the default connection and secret parameters used by modules in this file.\nThis is not best practice, we recommend overriding these using a .env or a secret manager, see: <link>\n\n\"\"\"\nimport os\n\nfrom pydantic import BaseSettings, RedisDsn, DirectoryPath, PostgresDsn", "\nfrom pydantic import BaseSettings, RedisDsn, DirectoryPath, PostgresDsn\n\n\nclass Settings(BaseSettings):\n    \"\"\"NetORC settings management\"\"\"\n\n    # Header key used for authentication.\n    api_key_header = \"netorc-x-token\"\n\n    # We recommend changing the postgres db credentials.\n    database: PostgresDsn = \"postgresql://netorc:netorc123@netorc-postgres:5432/netorc\"\n\n    # We recommend changing the redis credentials.\n    redis: RedisDsn = \"redis://netorc-redis:6379\"  # TODO: redis or rediss\n\n    # Check this is the correct timezone.\n    timezone: str = \"Europe/London\"\n    utc: bool = True\n\n    # Censors celery configuration, passwords, api keys.\n    # We do NOT recommend to change this setting.\n    censored: bool = True\n\n    # Tasks can be queued with a priority.\n    # This is \"best effort\" and does not guarantee a faster execution.\n    # We do NOT recommend to change this setting.\n    priority_levels: int = 10  # 0-9\n\n    # Log outputs\n    log_console: bool = True\n    log_file: bool = True\n    log_syslog: bool = True\n\n    # The default log level is set to info.\n    # To change this value, see: https://docs.python.org/3/library/logging.html#logging-levels\n    log_level: int = 20\n    log_format: str = \"%(asctime)s %(levelname)s: %(message)s\"\n\n    # Syslog messages are sent using UDP, for TCP, see <link>.\n    # LOG_USER facility.\n    syslog_server: str = \"localhost\"\n    syslog_port: int = 514\n\n    # Default task directory.\n    task_dir: DirectoryPath = \"worker/tasks\"\n\n    class Config:\n        \"\"\"Modify the behaviour of settings management\"\"\"\n\n        env_file = \".env\"\n        env_file_encoding = \"utf-8\"", "\n\nsettings = Settings()\n\ntasks = [\n    (str(settings.task_dir) + \"/\" + x).replace(\"/\", \".\").strip(\".py\")\n    for x in os.listdir(str(settings.task_dir))\n    if not x.startswith(\"__\") and x.endswith(\".py\")\n]\n", "]\n"]}
{"filename": "manage.py", "chunked_list": ["\"\"\"\nmanage.py\n\"\"\"\nimport argparse\nimport getpass\n\nfrom core.db import tables, migrate\nfrom core.security import secret\nfrom core.security.user import create_user\n", "from core.security.user import create_user\n\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"action\", choices=[\"migrate\", \"createsuperuser\"])\n    args = parser.parse_args()\n\n    if args.action == \"migrate\":\n        migrate.migrate()\n\n    if args.action == \"createsuperuser\":\n        superuser = tables.User()\n        superuser.username = input(\"Username: \")\n\n        while True:\n            password = getpass.getpass(prompt=\"Password: \")\n            if not secret.validator(password):\n                print(\"Password does not meet security requirements, please try again.\")\n            else:\n                superuser.password = password\n                break\n\n        while True:\n            api_key = getpass.getpass(prompt=\"API key: \")\n            if not secret.validator(api_key):\n                print(\"API key does not meet security requirements, please try again.\")\n            else:\n                superuser.api_key = api_key\n                break\n\n        try:\n            db_superuser = create_user(superuser)\n            print(f\"User: {db_superuser.username}, created.\")\n\n        except Exception:\n            raise", "\n\nif __name__ == \"__main__\":\n    main()\n"]}
{"filename": "tests/test_manage.py", "chunked_list": [""]}
{"filename": "tests/test_settings.py", "chunked_list": [""]}
{"filename": "tests/__init__.py", "chunked_list": [""]}
{"filename": "tests/core/test_db.py", "chunked_list": [""]}
{"filename": "tests/core/test_redis.py", "chunked_list": [""]}
{"filename": "tests/core/__init__.py", "chunked_list": [""]}
{"filename": "tests/worker/test_lock.py", "chunked_list": ["from core.task.decorators import lock_task\n\n\ndef test_lock_task():\n    @lock_task\n    def example():\n        return True\n\n    assert example(task_lock_key=\"netorc_test\")\n    assert example()", ""]}
{"filename": "tests/worker/__init__.py", "chunked_list": [""]}
{"filename": "core/__init__.py", "chunked_list": [""]}
{"filename": "core/task/lock.py", "chunked_list": ["\"\"\"\ntask_lock.py\n\"\"\"\nimport time\nimport uuid\n\nimport redis\n\nfrom core.addons.exceptions import TaskLockAddError\nfrom core.metrics.logging import logger", "from core.addons.exceptions import TaskLockAddError\nfrom core.metrics.logging import logger\nfrom settings import settings\n\n\nclass TaskLock:\n    \"\"\"Distributed lock mechanism to Add/Remove lock on a task\"\"\"\n\n    def __init__(self, task_lock_key: str = None, timeout: int = 30):\n        try:\n            self.conn = redis.from_url(settings.redis)\n            self.conn.ping()\n            logger.info(\"Connected to redis instance: %s\", settings.redis)\n        except redis.exceptions.ConnectionError as exc:\n            logger.critical(\n                \"An exception occurred connecting to redis instance: %s\",\n                settings.redis,\n            )\n            raise exc\n\n        self.task_lock_key = \"lock:\" + task_lock_key\n        self.uid = str(uuid.uuid4())\n        self.timeout = timeout\n\n    def add(self):\n        \"\"\"Add the lock\n\n        :returns: True\n        \"\"\"\n        end = time.time() + self.timeout\n        while time.time() < end:\n            try:\n                if self.conn.setnx(self.task_lock_key, self.uid):\n                    logger.info(\"Added %s with uid: %s\", self.task_lock_key, self.uid)\n                    return True\n                time.sleep(0.01)\n            except Exception as exc:\n                logger.error(\n                    \"An exception occurred adding %s with uid %s\",\n                    self.task_lock_key,\n                    self.uid,\n                )\n                raise exc\n        raise TaskLockAddError\n\n    def remove(self):\n        \"\"\"Remove the lock\n\n        :returns: True\n        \"\"\"\n\n        pipe = self.conn.pipeline(True)\n        while True:\n            try:\n                pipe.watch(self.task_lock_key)\n                if self.conn.get(self.task_lock_key).decode(\"utf-8\") == self.uid:\n                    pipe.multi()\n                    pipe.delete(self.task_lock_key)\n                    pipe.execute()\n                    logger.info(\"Removed %s with uid: %s\", self.task_lock_key, self.uid)\n                    return True\n                pipe.unwatch()\n                break\n            except redis.exceptions.WatchError as exc:\n                logger.critical(\n                    \"Key changed during transaction, failed to remove %s with uid: %s\",\n                    self.task_lock_key,\n                    self.uid,\n                )\n                raise exc", ""]}
{"filename": "core/task/decorators.py", "chunked_list": ["\"\"\"\ndecorators.py\n\"\"\"\nfrom functools import wraps\n\nfrom core.addons.exceptions import TaskLockAddError\nfrom core.metrics.logging import logger\nfrom core.task.lock import TaskLock\n\n\ndef lock_task(func):\n    \"\"\"Applied to tasks which require synchronous execution.\n    Workers will acquire a lock on the task before execution.\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        if \"task_lock_key\" in kwargs:\n            task_lock_key = kwargs.get(\"task_lock_key\")\n            logger.debug(\n                \"Found task lock key for %s, using: %s as key\",\n                func.__name__,\n                task_lock_key,\n            )\n            kwargs.pop(\"task_lock_key\")\n        else:\n            task_lock_key = func.__name__\n            logger.debug(\n                \"No task lock key found for %s, using: %s as key\",\n                func.__name__,\n                task_lock_key,\n            )\n\n        try:\n            try:\n                lock = TaskLock(task_lock_key)\n\n            except Exception as exc:\n                raise exc\n\n            lock.add()\n\n        except TaskLockAddError as exc:\n            logger.error(\n                \"Unable to add lock for task: %s, with key: %s\",\n                func.__name__,\n                task_lock_key,\n            )\n            raise exc\n\n        try:\n            return func(*args, **kwargs)\n\n        except Exception as exc:\n            logger.error(\"An exception occurred when executing: %s\", func.__name__)\n            raise exc\n\n        finally:\n            try:\n                lock.remove()\n\n            except Exception as exc:\n                raise exc\n\n    return wrapper", "\n\ndef lock_task(func):\n    \"\"\"Applied to tasks which require synchronous execution.\n    Workers will acquire a lock on the task before execution.\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        if \"task_lock_key\" in kwargs:\n            task_lock_key = kwargs.get(\"task_lock_key\")\n            logger.debug(\n                \"Found task lock key for %s, using: %s as key\",\n                func.__name__,\n                task_lock_key,\n            )\n            kwargs.pop(\"task_lock_key\")\n        else:\n            task_lock_key = func.__name__\n            logger.debug(\n                \"No task lock key found for %s, using: %s as key\",\n                func.__name__,\n                task_lock_key,\n            )\n\n        try:\n            try:\n                lock = TaskLock(task_lock_key)\n\n            except Exception as exc:\n                raise exc\n\n            lock.add()\n\n        except TaskLockAddError as exc:\n            logger.error(\n                \"Unable to add lock for task: %s, with key: %s\",\n                func.__name__,\n                task_lock_key,\n            )\n            raise exc\n\n        try:\n            return func(*args, **kwargs)\n\n        except Exception as exc:\n            logger.error(\"An exception occurred when executing: %s\", func.__name__)\n            raise exc\n\n        finally:\n            try:\n                lock.remove()\n\n            except Exception as exc:\n                raise exc\n\n    return wrapper", "\n\ndef queue_task(func, priority: int = 0, *args, **kwargs):\n    \"\"\"Applied to tasks. Allows the calling of a Celery task\n    and its arguments to be abstracted.\n    \"\"\"\n\n    @wraps(func)\n    def wrapper():\n        try:\n            getattr(func, \"apply_async\")\n\n        except Exception as exc:\n            logger.error(\n                \"Function %s is not a celery task, have you missed a decorator?\",\n                func.__name__,\n            )\n            raise exc\n\n        try:\n            task = func.apply_async(args=[*args], kwargs={**kwargs}, priority=priority)\n            return task\n\n        except Exception as exc:\n            logger.error(\"An exception occurred when queuing: %s\", func.__name__)\n            raise exc\n\n    return wrapper()", ""]}
{"filename": "core/task/__init__.py", "chunked_list": [""]}
{"filename": "core/security/secret.py", "chunked_list": ["def validator(secret: str) -> bool:\n    \"\"\"\n    Validates a secret string meets security conditions.\n\n    Args:\n        secret: string.\n\n    Returns:\n        False, if a condition is not met.\n        True, if all conditions are met.\n\n    \"\"\"\n\n    special_characters = \"!#$%&'()*+,-./:;<=>?@[\\]^_`{|}~\"\n\n    if len(secret) <= 8:\n        return False\n\n    if not any(x.isupper() for x in secret):\n        return False\n\n    if not any(x.isdigit() for x in secret):\n        return False\n\n    if not any(x in special_characters for x in secret):\n        return False\n\n    return True", ""]}
{"filename": "core/security/__init__.py", "chunked_list": [""]}
{"filename": "core/security/user.py", "chunked_list": ["from typing import Callable\n\nfrom passlib.hash import pbkdf2_sha256\n\nfrom core import db\nfrom core.db.tables import User\nfrom core.metrics.logging import logger\n\n\ndef create_user(user: User, session: Callable = db.get_session):\n    \"\"\"\n    Creates a new database user based on User object.\n    Hashes user password and api key using SHA256.\n\n    Args:\n        user: User object\n        session: database session\n\n    Returns:\n        user: database user object\n    \"\"\"\n\n    user.password = pbkdf2_sha256.hash(user.password)\n    user.api_key = pbkdf2_sha256.hash(user.api_key)\n\n    with session() as _session:\n        try:\n            _session.add(user)\n            _session.commit()\n            logger.info(\"User: %s, created\", user.username)\n            return user\n\n        except Exception as exc:\n            raise", "\ndef create_user(user: User, session: Callable = db.get_session):\n    \"\"\"\n    Creates a new database user based on User object.\n    Hashes user password and api key using SHA256.\n\n    Args:\n        user: User object\n        session: database session\n\n    Returns:\n        user: database user object\n    \"\"\"\n\n    user.password = pbkdf2_sha256.hash(user.password)\n    user.api_key = pbkdf2_sha256.hash(user.api_key)\n\n    with session() as _session:\n        try:\n            _session.add(user)\n            _session.commit()\n            logger.info(\"User: %s, created\", user.username)\n            return user\n\n        except Exception as exc:\n            raise", ""]}
{"filename": "core/metrics/__init__.py", "chunked_list": [""]}
{"filename": "core/metrics/logging.py", "chunked_list": ["\"\"\"\nlogger.py\n\"\"\"\nimport logging.handlers\n\nfrom settings import settings\n\nlogger = logging.getLogger(__name__)\n\nlogger.setLevel(settings.log_level)", "\nlogger.setLevel(settings.log_level)\nformatter = logging.Formatter(settings.log_format)\n\nif settings.log_console is True:\n    console = logging.StreamHandler()\n    console.setFormatter(formatter)\n    logger.addHandler(console)\n\nif settings.log_file is True:\n    file = logging.handlers.RotatingFileHandler(\n        filename=\"logs/netorc.log\", mode=\"w\", maxBytes=10000000, backupCount=5\n    )\n    file.setFormatter(formatter)\n    logger.addHandler(file)", "\nif settings.log_file is True:\n    file = logging.handlers.RotatingFileHandler(\n        filename=\"logs/netorc.log\", mode=\"w\", maxBytes=10000000, backupCount=5\n    )\n    file.setFormatter(formatter)\n    logger.addHandler(file)\n\nif settings.log_syslog is True:\n    syslog = logging.handlers.SysLogHandler(\n        address=(settings.syslog_server, settings.syslog_port)\n    )\n    syslog.setFormatter(formatter)\n    logger.addHandler(syslog)", "if settings.log_syslog is True:\n    syslog = logging.handlers.SysLogHandler(\n        address=(settings.syslog_server, settings.syslog_port)\n    )\n    syslog.setFormatter(formatter)\n    logger.addHandler(syslog)\n"]}
{"filename": "core/addons/__init__.py", "chunked_list": [""]}
{"filename": "core/addons/celery.py", "chunked_list": ["\"\"\"\ncelery.py\n\"\"\"\nfrom celery import Celery\n\nfrom settings import settings, tasks\n\ncelery = Celery(include=tasks)\n\n# Time", "\n# Time\ncelery.conf.timezone = settings.timezone\ncelery.conf.enable_utc = settings.utc\n\n# Broker & Backend\ncelery.conf.broker_url = settings.redis\ncelery.conf.result_backend = settings.redis\n\n# Censored", "\n# Censored\ncelery.conf.humanize(with_defaults=False, censored=settings.censored)\ncelery.conf.table(with_defaults=False, censored=settings.censored)\n\n# Priorities\ncelery.conf.broker_transport_options = {\n    \"priority_steps\": list(range(settings.priority_levels)),\n    \"sep\": \":\",\n    \"queue_order_strategy\": \"priority\",", "    \"sep\": \":\",\n    \"queue_order_strategy\": \"priority\",\n}\n\nif __name__ == \"__main__\":\n    celery.start()\n"]}
{"filename": "core/addons/exceptions.py", "chunked_list": ["\"\"\"\nexceptions.py\n\"\"\"\n\n\nclass APIError(Exception):\n    def __init__(\n            self,\n            status_code: int,\n            code: str,\n            reason: str,\n            message: str = None,\n            reference_error: str = None,\n    ):\n        self.status_code = status_code\n        self.code = code\n        self.reason = reason\n        self.message = message\n        self.reference_error = reference_error", "\n\nclass TaskLockAddError(Exception):\n    def __init__(self):\n        self.message = (\n            \"Unable to add lock to task. A task using the same key is running.\"\n        )\n        super().__init__(self.message)\n", ""]}
{"filename": "core/db/models.py", "chunked_list": ["\"\"\"\nmodels.py\n\"\"\"\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom sqlmodel import SQLModel\n\n\nclass UserCreate(SQLModel):\n    firstname: Optional[str]\n    lastname: Optional[str]\n    email: Optional[str]\n    username: str\n    password: str\n    api_key: str", "\nclass UserCreate(SQLModel):\n    firstname: Optional[str]\n    lastname: Optional[str]\n    email: Optional[str]\n    username: str\n    password: str\n    api_key: str\n\n\nclass UserRead(SQLModel):\n    firstname: Optional[str]\n    lastname: Optional[str]\n    email: Optional[str]\n    username: str\n    created: datetime\n    last_updated: datetime", "\n\nclass UserRead(SQLModel):\n    firstname: Optional[str]\n    lastname: Optional[str]\n    email: Optional[str]\n    username: str\n    created: datetime\n    last_updated: datetime\n", ""]}
{"filename": "core/db/__init__.py", "chunked_list": ["from contextlib import contextmanager\n\nfrom sqlmodel import create_engine, Session\n\nfrom settings import settings\n\nengine = create_engine(settings.database, echo=True)\n\n\ndef require_db_session():\n    with Session(engine) as session:\n        try:\n            yield session\n        except Exception:\n            session.rollback()\n            raise\n        finally:\n            session.close()", "\ndef require_db_session():\n    with Session(engine) as session:\n        try:\n            yield session\n        except Exception:\n            session.rollback()\n            raise\n        finally:\n            session.close()", "\n\n@contextmanager\ndef get_session():\n    with Session(engine) as session:\n        try:\n            yield session\n\n        except Exception:\n            session.rollback()\n            raise\n\n        finally:\n            session.close()", ""]}
{"filename": "core/db/tables.py", "chunked_list": ["\"\"\"\ntables.py\n\"\"\"\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom sqlmodel import Field, SQLModel\n\n\nclass User(SQLModel, table=True):\n    username: str = Field(index=True, primary_key=True)\n    firstname: Optional[str]\n    lastname: Optional[str]\n    email: Optional[str]\n    password: str\n    api_key: str\n    created: datetime = Field(default_factory=datetime.utcnow, nullable=False)\n    last_updated: datetime = Field(default_factory=datetime.utcnow, nullable=False)", "\nclass User(SQLModel, table=True):\n    username: str = Field(index=True, primary_key=True)\n    firstname: Optional[str]\n    lastname: Optional[str]\n    email: Optional[str]\n    password: str\n    api_key: str\n    created: datetime = Field(default_factory=datetime.utcnow, nullable=False)\n    last_updated: datetime = Field(default_factory=datetime.utcnow, nullable=False)", "\n\nclass Service(SQLModel, table=True):\n    id: str = Field(primary_key=True)\n    name: str = Field(index=True)\n    description: str = Field(max_length=256, default=None)\n    service_type: Optional[str] = Field(default=None, foreign_key=\"servicetype.name\", nullable=True)\n    service_resource: Optional[str] = Field(default=None)\n    category: str  # Customer facing or resource facing services\n    state: str = Field(index=True)  # States include, inactive, active and terminated\n    start_date: datetime\n    end_date: datetime = Field(default=None)\n    href: str", "\n\nclass ServiceType(SQLModel, table=True):\n    id: str = Field(primary_key=True)\n    name: str = Field(index=True, unique=True)\n    description: str = Field(max_length=256, default=None)\n    version: Optional[int] = Field(default=None)  # Service specific version\n    href: str\n", ""]}
{"filename": "core/db/migrate.py", "chunked_list": ["from sqlmodel import SQLModel\n\nfrom core import db\nfrom core.metrics.logging import logger\n\n\ndef migrate() -> bool:\n    try:\n        SQLModel.metadata.create_all(db.engine)\n        logger.info(\"Successfully migrated tables to database\")\n        return True\n\n    except Exception as exc:\n        logger.error(\"Error migrating tables to database: %s\", exc)\n        raise", ""]}
{"filename": "api/main.py", "chunked_list": ["from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse, HTMLResponse\nfrom fastapi.staticfiles import StaticFiles\n\nfrom api.services import service, admin\nfrom core.addons.exceptions import APIError\n\nfastapi = FastAPI(title=\"NetORC\", version=\"pre-release\")\n# from api.headers import require_general_authentication_header\n# dependencies=[require_general_authentication_header]", "# from api.headers import require_general_authentication_header\n# dependencies=[require_general_authentication_header]\nfastapi.include_router(service.router)\nfastapi.include_router(admin.router)\nfastapi.mount(\"/static\", StaticFiles(directory=\"api/landing/page\"))\n\n\n@fastapi.exception_handler(APIError)\nasync def exception_handler(request: Request, exc: APIError):\n    \"\"\"", "async def exception_handler(request: Request, exc: APIError):\n    \"\"\"\n    Exception handler for APIError. Ensures meaningful errors are sent to users/systems.\n\n    Args:\n        request: The request object.\n        exc: APIException object.\n\n    Returns:\n        A json response body using attributes of the exc object.", "    Returns:\n        A json response body using attributes of the exc object.\n    \"\"\"\n\n    # Optional attributes\n    if None not in (\n            exc.message,\n            exc.reference_error,\n    ):\n        return JSONResponse(\n            status_code=exc.status_code,\n            content={\n                \"code\": exc.code,\n                \"reason\": exc.reason,\n                \"message\": exc.message,\n                \"status\": exc.status_code,\n                \"referenceError\": exc.reference_error,\n            },\n        )", "    # Mandatory attributes\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"code\": exc.code, \"reason\": exc.reason},\n    )\n\n\n@fastapi.get(\"/\", response_class=HTMLResponse)\nasync def landing_page():\n    with open(\"api/landing/page/html/landing.html\", \"r\") as html:\n        return html.read()", "async def landing_page():\n    with open(\"api/landing/page/html/landing.html\", \"r\") as html:\n        return html.read()\n"]}
{"filename": "api/headers.py", "chunked_list": ["from typing import Any\n\nfrom fastapi import Response, Depends, Security\nfrom fastapi.security.api_key import APIKeyHeader\nfrom passlib.hash import pbkdf2_sha256\nfrom sqlmodel import Session, select\n\nfrom core.addons.exceptions import APIError\nfrom core.db import require_db_session\nfrom core.db.tables import User", "from core.db import require_db_session\nfrom core.db.tables import User\nfrom settings import settings\n\n\nasync def general_http_headers(response: Response) -> Any:\n    \"\"\"\n    Adds keys,values to response headers. E.g, Cache-Control\n\n    Args:", "\n    Args:\n        response: starlette response object\n\n    Returns:\n        None\n\n    \"\"\"\n    response.headers[\"cache-control\"] = \"no-cache, no-store\"\n", "    response.headers[\"cache-control\"] = \"no-cache, no-store\"\n\n\nrequire_general_http_headers = Depends(general_http_headers)\n\napi_key_header = APIKeyHeader(name=settings.api_key_header, auto_error=False)\n\n\ndef general_authentication_header(api_key: str = Security(api_key_header),\n                                  session: Session = Depends(require_db_session)) -> Any:\n    \"\"\"\n    Retrieves api key in request header and checks api key exists in user db.\n\n    Args:\n        api_key: request api key\n        session: db session dependency.\n\n    Raises:\n        APIException: 401 and 500 status codes.\n    \"\"\"\n    try:\n        if not api_key:\n            raise APIError(status_code=401, code=\"General Authentication Header\", reason=\"Unauthorised request\")\n\n        query = select(User)\n        result = session.exec(query).all()\n        check = [x.api_key for x in result if\n                 x.api_key.startswith(\"$pbkdf2-sha256\") and pbkdf2_sha256.verify(api_key, x.api_key)]\n\n        if not check:\n            raise APIError(status_code=401, code=\"General Authentication Header\", reason=\"Unauthorised request\")\n\n    except APIError:\n        raise\n\n    except Exception as exc:\n        raise APIError(status_code=500, code=\"General Authentication Header\", reason=\"Runtime error occurred\") from exc", "def general_authentication_header(api_key: str = Security(api_key_header),\n                                  session: Session = Depends(require_db_session)) -> Any:\n    \"\"\"\n    Retrieves api key in request header and checks api key exists in user db.\n\n    Args:\n        api_key: request api key\n        session: db session dependency.\n\n    Raises:\n        APIException: 401 and 500 status codes.\n    \"\"\"\n    try:\n        if not api_key:\n            raise APIError(status_code=401, code=\"General Authentication Header\", reason=\"Unauthorised request\")\n\n        query = select(User)\n        result = session.exec(query).all()\n        check = [x.api_key for x in result if\n                 x.api_key.startswith(\"$pbkdf2-sha256\") and pbkdf2_sha256.verify(api_key, x.api_key)]\n\n        if not check:\n            raise APIError(status_code=401, code=\"General Authentication Header\", reason=\"Unauthorised request\")\n\n    except APIError:\n        raise\n\n    except Exception as exc:\n        raise APIError(status_code=500, code=\"General Authentication Header\", reason=\"Runtime error occurred\") from exc", "\n\nrequire_general_authentication_header = Depends(general_authentication_header)\n"]}
{"filename": "api/__init__.py", "chunked_list": [""]}
{"filename": "api/services/__init__.py", "chunked_list": [""]}
{"filename": "api/services/admin.py", "chunked_list": ["from typing import List\n\nfrom fastapi import APIRouter, Depends\nfrom sqlmodel import Session, select\n\nfrom core import db\nfrom core.addons.exceptions import APIError\nfrom core.db.models import UserRead, UserCreate\nfrom core.db.tables import User\nfrom core.security.user import create_user", "from core.db.tables import User\nfrom core.security.user import create_user\n\nrouter = APIRouter(prefix=\"/api/admin/v1\", tags=[\"Administration\"])\n\n\n@router.get(\"/users\", response_model=List[UserRead])\ndef get_users(username: str = None, session: Session = Depends(db.require_db_session)) -> list:\n    \"\"\"\n    Returns a list of user/'s from the db.\n\n    Args:\n        username: an optional username filter.\n        session: db session dependency.\n\n    Returns:\n        Dictionary/s enclosed in a list containing attributes for a user/s.\n\n    Raises:\n        APIException: 500 status code.\n    \"\"\"\n    try:\n        if username is not None:\n            user = session.get(User, username)\n            if not user:\n                raise APIError(status_code=404, code=\"Get Users\", reason=\"User not found\")\n\n            return [user]\n\n        query = select(User)\n        result = session.exec(query)\n        users = [x for x in result]\n        if not users:\n            raise APIError(status_code=404, code=\"Get Users\", reason=\"No users found\")\n\n    except APIError:\n        raise\n\n    except Exception as exc:\n        raise APIError(status_code=500, code=\"Get Users\", reason=\"Runtime error occurred\") from exc", "\n\n@router.post(\"/users\", response_model=UserRead)\ndef post_users(user_create: UserCreate):\n    \"\"\"\n    Creates new users.\n\n    Args:\n        user_create: UserCreate object.\n\n    Returns:\n        db_user: database User object.\n\n    Raises:\n        APIException: 500 status code.\n\n    \"\"\"\n    user = User()\n    user_data = user_create.dict(exclude_unset=True)\n    for k, v in user_data.items():\n        setattr(user, k, v)\n\n    try:\n        db_user = create_user(user)\n        return db_user\n\n    except Exception as exc:\n        raise APIError(status_code=500, code=\"Post User\", reason=\"Runtime error occurred\") from exc", "\n\n@router.patch(\"/users\")\ndef patch_users():\n    pass\n\n\n@router.delete(\"/users\")\ndef delete_users():\n    pass", "def delete_users():\n    pass\n"]}
{"filename": "api/services/service.py", "chunked_list": ["\"\"\"\nservice.py\n\"\"\"\nfrom typing import List\n\nfrom fastapi import APIRouter, Depends\nfrom sqlmodel import Session, select\n\nfrom core.addons.exceptions import APIError\nfrom core.db import require_db_session", "from core.addons.exceptions import APIError\nfrom core.db import require_db_session\nfrom core.db.tables import Service\n\nrouter = APIRouter(\n    prefix=\"/api/services/v1\",\n    tags=[\"Services\"],\n)\n\n", "\n\n@router.get(\"/service\", response_model=List[Service])\ndef get_services(id: str = None, session: Session = Depends(require_db_session)) -> list:\n    \"\"\"\n    Returns a list of service/'s from the db.\n\n    Args:\n        id: an optional service id filter.\n        session: db session dependency.\n\n    Returns:\n        A list of dictionary/s containing attributes for a service.\n\n    Raises:\n        APIException: 500 status code.\n    \"\"\"\n    try:\n        if id is not None:\n            service = session.get(Service, id)\n            if not service:\n                raise APIError(status_code=404, code=\"Get Services\", reason=\"Service not found\")\n            return [service]\n\n        query = select(Service)\n        result = session.exec(query)\n        services = [x for x in result]\n        if not services:\n            raise APIError(status_code=404, code=\"Get Services\", reason=\"No services found\")\n\n        return services\n\n    except APIError:\n        raise\n\n    except Exception as exc:\n        raise APIError(status_code=500, code=\"Get Services\", reason=\"Runtime error occurred\") from exc", "\n\n@router.post(\"/service\", response_model=List[Service])\nasync def post_services(service: Service) -> list:\n    \"\"\"\n    Creates new service/s. The service/s is added to the db once the task completes.\n\n    Args:\n\n    Returns:", "\n    Returns:\n\n    Raises:\n    \"\"\"\n    return []\n\n\n@router.patch(\"/service/{id}\", response_model=Service)\nasync def patch_services(id: int) -> list:", "@router.patch(\"/service/{id}\", response_model=Service)\nasync def patch_services(id: int) -> list:\n    \"\"\"\n    Amend a service. The service is updated in the db once the task completes.\n\n    Args:\n\n    Returns:\n\n    Raises:", "\n    Raises:\n    \"\"\"\n    return []\n\n\n@router.delete(\"/service/{id}\", response_model=Service)\nasync def delete_services(id: int) -> list:\n    \"\"\"\n    Remove a service. The service is deleted in the db once the task completes.", "    \"\"\"\n    Remove a service. The service is deleted in the db once the task completes.\n\n    Args:\n\n    Returns:\n\n    Raises:\n    \"\"\"\n    return []", "    \"\"\"\n    return []\n"]}
{"filename": "worker/__init__.py", "chunked_list": [""]}
{"filename": "worker/tasks/example.py", "chunked_list": ["\"\"\"\nexample.py\n\n`lock_task` can be used to ensure tasks are executed\nsynchronously with each worker obtaining the lock before \nexecuting the task. \n\nfor more information, see <link>\n\n\"\"\"", "\n\"\"\"\nimport time\n\nfrom core.addons.celery import celery\nfrom core.task.decorators import lock_task\n\n\n@celery.task()\n@lock_task\ndef example_task() -> None:\n    print(\"Starting task\")\n    time.sleep(2)\n    print(\"Finished task\")\n    return 8", "@celery.task()\n@lock_task\ndef example_task() -> None:\n    print(\"Starting task\")\n    time.sleep(2)\n    print(\"Finished task\")\n    return 8\n"]}
{"filename": "worker/tasks/__init__.py", "chunked_list": [""]}
