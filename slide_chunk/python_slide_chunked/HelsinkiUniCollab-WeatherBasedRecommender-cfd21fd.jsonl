{"filename": "recommender-back/tasks.py", "chunked_list": ["from invoke import task\n\n@task\ndef start(ctx):\n    ctx.run(\"poetry run flask --app src/app --debug run\", pty=True)\n\n@task\ndef test(ctx):\n    ctx.run(\"poetry run pytest -s src/tests\", pty=True)\n", "\n@task\ndef pylint(ctx):\n    ctx.run(\"poetry run pylint src\", pty=True)\n"]}
{"filename": "recommender-back/src/app.py", "chunked_list": ["import os\nfrom flask import Flask\nfrom flask_caching import Cache\nfrom flask_cors import CORS\nfrom dotenv import load_dotenv\nfrom .config import Config\n\nload_dotenv()\n\nif os.environ.get('CACHE_MODE') == 'simple':\n    CACHE_TYPE = 'SimpleCache'\nelse:\n    CACHE_TYPE = 'redis'", "\nif os.environ.get('CACHE_MODE') == 'simple':\n    CACHE_TYPE = 'SimpleCache'\nelse:\n    CACHE_TYPE = 'redis'\n\nconfig = {\n    \"DEBUG\": True,\n    \"CACHE_TYPE\": CACHE_TYPE,\n    \"CACHE_REDIS_URL\": Config.CACHE_REDIS_URL,", "    \"CACHE_TYPE\": CACHE_TYPE,\n    \"CACHE_REDIS_URL\": Config.CACHE_REDIS_URL,\n    \"CACHE_DEFAULT_TIMEOUT\": 3600\n}\n\napp = Flask(__name__)\napp.config.from_mapping(config)\nCORS(app)\n\ncache = Cache(app)", "\ncache = Cache(app)\n\nfrom src import routes\n"]}
{"filename": "recommender-back/src/config.py", "chunked_list": ["class Config:\n    BBOX = '24.5,60,25.5,60.5'\n    BBOX_AQI = '24.857740,60.137557,25.226838,60.278260'\n    TIMESTEP = 60\n    PARAMETERS = 'Temperature,Humidity,WindUMS,WindVMS,PrecipitationAmount,TotalCloudCover'\n    AQI_PARAMS = 'AQIndex'\n    FMI_QUERY_URL = 'http://opendata.fmi.fi/wfs?service=WFS&version=2.0.0&request=getFeature&storedquery_id='\n    AQI_QUERY = 'fmi::forecast::enfuser::airquality::helsinki-metropolitan::grid'\n    FILEREF_MEMBER = './/{http://www.opengis.net/gml/3.2}fileReference'\n    FORECAST_PARAMETERS = 'Temperature,Humidity,WindUMS,WindVMS,PrecipitationAmount,TotalCloudCover'\n    AIRQUALITY_PARAMETERS = 'AQINDEX_PT1H_avg'\n    CACHE_REDIS_URL = 'redis://redis:6379/0'\n    AQI_CACHE_TO = 86400", ""]}
{"filename": "recommender-back/src/__init__.py", "chunked_list": [""]}
{"filename": "recommender-back/src/routes.py", "chunked_list": ["import json\nimport requests\nimport os\nfrom .config import Config\nfrom flask import jsonify, request\nfrom .app import app, cache\nfrom .apis.aqi import AQI\nfrom .apis.forecast import Forecast\nfrom .apis.current import Current\nfrom .apis.pathing import GreenPathsAPI", "from .apis.current import Current\nfrom .apis.pathing import GreenPathsAPI\nfrom .apis import manager\nfrom .services.data_fetcher import DataFetcher\n\nweather_fetcher = DataFetcher()\n\n@app.route(\"/\", methods=[\"GET\"])\ndef index():\n    \"\"\"\n    Handler for the root endpoint.\n\n    Returns:\n        A JSON response containing a greeting message.\n\n    \"\"\"\n    data = {\"message\": \"Hello from the backend!\", \"status\": 200}\n    return jsonify(data)", "def index():\n    \"\"\"\n    Handler for the root endpoint.\n\n    Returns:\n        A JSON response containing a greeting message.\n\n    \"\"\"\n    data = {\"message\": \"Hello from the backend!\", \"status\": 200}\n    return jsonify(data)", "\n\n@app.route(\"/api/forecast\", methods=[\"GET\"])\n@cache.cached()\ndef get_forecast():\n    \"\"\"\n    Handler for the '/api/forecast' endpoint. Caching 1 hour.\n\n    Returns:\n        Forecast for the POI's.\n    \"\"\"\n    forecast = Forecast(weather_fetcher)\n    fore_query_time = forecast.update_data()\n    fore_query_time_str = fore_query_time.strftime('%Y-%m-%d %H:%M:%S')\n\n    aqi_data =  None\n\n    aqi_data_url = os.environ.get(\"REACT_APP_BACKEND_URL\") + f\"/api/aqi/?forecast_q_time={fore_query_time_str}\"\n    response = requests.get(aqi_data_url, timeout=1200)\n    aqi_data = response.json()\n\n    pois = manager.get_pois()\n    poi_forecast = forecast.get_closest_poi_coordinates_data(pois, aqi_data)\n\n    result = json.dumps(poi_forecast)\n\n    return result", "\n\n@app.route(\"/api/aqi/\", methods=[\"GET\"])\n@cache.cached(timeout=Config.AQI_CACHE_TO)\ndef get_aqi_forecast():\n    \"\"\"\n    Handler for the '/api/aqi' endpoint. Caching 24 hours.\n\n    Returns:\n        string: Aqi forecast for the POI's in json format\n    \"\"\"\n    forecast_q_time = request.args.get(\"forecast_q_time\")\n    aqi = AQI()\n    aqi.download_netcdf_and_store(forecast_q_time)\n    pois = manager.get_pois()\n    aqi_data = aqi.to_json(pois)\n    result = json.dumps(aqi_data)\n    return result", "\n\n@app.route(\"/api/poi/\", methods=[\"GET\"])\ndef get_poi_data():\n    \"\"\"\n    Handler for the '/api/poi' endpoint.\n\n    Returns:\n        Poi data if errors have not occurred.\n    \"\"\"\n    return manager.get_pois_as_json()", "\n\n@app.route(\"/api/poi/<accessibility>\", methods=[\"GET\"])\ndef get_poi_acessible_poi_data(accessibility):\n    \"\"\"\n    Handler for the '/api/poi' endpoint.\n\n    Returns:\n        POI-data if errors have not occurred.\n    \"\"\"\n    return manager.get_pois_as_json(accessibility)", "\n\n@app.route(\"/api/simulator\", methods=[\"POST\"])\ndef get_simulated_poi_data():\n    \"\"\"\n    Handler for the '/api/poi' endpoint.\n\n    Returns:\n        Poi data if errors have not occurred.\n    \"\"\"\n    data = request.get_json()\n    air_temperature = data.get('air_temperature')\n    wind_speed = data.get('wind_speed')\n    humidity = data.get('humidity')\n    precipitation = data.get('precipitation')\n    cloud_amount = data.get('cloud_amount')\n    air_quality = data.get('air_quality')\n    current_time = data.get('current_time')\n    sunrise = data.get('sunrise')\n    sunset = data.get('sunset')\n    if '' in [air_temperature, wind_speed, humidity, precipitation, cloud_amount, air_quality, current_time, sunrise, sunset]:\n        return jsonify({\"error\": \"Missing parameters\"}), 400\n    return manager.get_simulated_pois_as_json(air_temperature, wind_speed, humidity,\n                                              precipitation, cloud_amount, air_quality, current_time, sunrise, sunset)", "\n\n@app.route(\"/api/warning\", methods=[\"GET\"])\n@cache.cached()\ndef get_weather_warning():\n    \"\"\"\n    Handler for the '/api/warning' endpoint. \n\n    Returns:\n        Boolean according to if there is weather warning.\n    \"\"\"\n    current = Current(weather_fetcher)\n    warning = current.get_current_weather_warning(\"Helsinki Kaisaniemi\")\n    return jsonify(warning)", "\n\n@app.route('/path', methods=['GET'])\ndef get_path():\n    \"\"\"\n    Handler for the '/api/path' endpoint.\n\n    Returns:\n        Coordinates for the route based on request parameters.\n    \"\"\"\n    start_coords = request.args.get('start', None)\n    end_coords = request.args.get('end', None)\n\n    if not start_coords or not end_coords:\n        return jsonify({\"error\": \"Missing start or end coordinates\"}), 400\n\n    try:\n        start_coords = tuple(map(float, start_coords.split(',')))\n        end_coords = tuple(map(float, end_coords.split(',')))\n    except ValueError:\n        return jsonify({\"error\": \"Invalid coordinates\"}), 400\n\n    green_paths = GreenPathsAPI(start_coords, end_coords)\n    if route_coordinates := green_paths.route_coordinates:\n        return jsonify(route_coordinates), 200\n    return jsonify({\"error\": \"Could not fetch route data\"}), 500", "\n@app.errorhandler(404)\ndef not_found_error(error):\n    \"\"\"\n    Error handler for the 404 (Not Found) error.\n    \"\"\"\n    error_data = {\"message\": \"Resource not found\", \"status\": error.code}\n    return jsonify(error_data), 404\n\n", "\n\n@app.errorhandler(500)\ndef internal_error(error):\n    \"\"\"\n    Error handler for the 500 (Internal Server Error) error.\n    \"\"\"\n    error_data = {\"message\": \"Internal server error\", \"status\": error.code}\n    return jsonify(error_data), 500\n", ""]}
{"filename": "recommender-back/src/apis/times.py", "chunked_list": ["import datetime as dt\nimport pytz\nfrom datetime import datetime\nfrom suntime import Sun\nfrom dateutil import tz\n\n\ndef get_sun_data():\n    '''\n    Get info of sunrise and sunset based on date.\n\n    Returns:\n        Tuple: sunrise and sunset in formatted string.\n    '''\n    date = dt.date.today()\n    sun = Sun(60.192059, 24.945831)\n    sunrise = sun.get_local_sunrise_time(date)\n    sunset = sun.get_local_sunset_time(date)\n    str_sunrise = sunrise.strftime('%H:%M')\n    str_sunset = sunset.strftime('%H:%M')\n    return str_sunrise, str_sunset", "\n\ndef get_current_time(plus=None):\n    '''\n    Retrieves the current time as a formatted string.\n\n    plus; number of hours added to datetime.now()\n\n    Returns:\n        str: The current time in the formatted string.\n    '''\n    if plus is None:\n        time = dt.datetime.now()\n    else:\n        time = dt.datetime.now() + dt.timedelta(hours=plus)\n\n    return time.strftime('%H:%M')", "\n\ndef utc_to_finnish(datetime):\n    '''\n    Converts a UTC datetime object to the corresponding time in the Finnish timezone.\n\n    Args:\n        datetime (datetime): The UTC datetime object to be converted.\n\n    Returns:\n        datetime: The datetime object converted to the Finnish timezone.\n    '''\n    set_utc = datetime.replace(tzinfo=tz.UTC)\n    get_timezone = tz.gettz('Europe/Helsinki')\n    return set_utc.astimezone(get_timezone)", "\n\ndef forecast_q_time_to_finnish(fore_q_time):\n    '''\n    Converts forecast query time into Finnish time format\n\n    Returns:\n        string: converted time in Finnish timezone format\n    '''\n    finland_tz = pytz.timezone('Europe/Helsinki')\n    fore_q_time_datetime = datetime.strptime(fore_q_time, '%Y-%m-%d %H:%M:%S')\n    fore_q_time_finnish = fore_q_time_datetime.replace(tzinfo=pytz.utc).astimezone(finland_tz)\n    return fore_q_time_finnish", "\n\ndef get_forecast_times():\n    '''\n    Retrieves the current time, start time, and end time for a forecast.\n\n    Returns:\n        Tuple: A tuple containing the current time, start time, and end time as formatted strings.\n    '''\n    current_time = dt.datetime.now(dt.timezone.utc)\n    start_time = current_time.strftime('%Y-%m-%dT%H:%M:%SZ')\n    end_time = (current_time + dt.timedelta(days=1, hours=1)\n                ).strftime('%Y-%m-%dT%H:%M:%SZ')\n    return current_time, start_time, end_time", "\ndef time_from_string(time_str):\n    '''\n    Converts a given time string or datetime.datetime object into a datetime.time object.\n\n    Args:\n        time_str (Union[str, datetime.datetime]): The time representation, either as a string formatted as \"%H:%M\" or as a datetime.datetime object.\n\n    Returns:\n        datetime.time: The time extracted from the input.\n\n    Raises:\n        ValueError: If the provided string is not formatted correctly.\n    '''\n    if isinstance(time_str, dt.datetime):\n        return time_str.time()\n    return dt.datetime.strptime(time_str, \"%H:%M\").time()", ""]}
{"filename": "recommender-back/src/apis/poi.py", "chunked_list": ["import math\nfrom . import times\n\n\nclass PointOfInterest:\n    def __init__(self, name=None, latitude=None, longitude=None, not_accessible_for=None, categories=None):\n        self.sun = times.get_sun_data()\n        self.name = name\n        self.latitude = latitude\n        self.longitude = longitude\n        self.not_accessible_for = not_accessible_for\n        self.categories = []\n        self.categories = categories\n        self.weather = {}\n        self.categorytype = None\n\n    def calculate_score(self, cur_time=None, sunrise=None, sunset=None):\n        '''\n        Chooses which algorithm to use in scoring.\n        Must be manually handled to adjust when adding new points of interest.\n        '''\n        indoor_categories = ['Sport halls']\n        outdoor_categories = ['Open air pools and beaches',\n                              'Athletic fields and venues', 'Neighbourhood sports facilities and parks']\n        if sunrise is None and sunset is None:\n            sunrise, sunset = self.sun\n        \n        sunrise_time = times.time_from_string(sunrise)\n        sunset_time = times.time_from_string(sunset)\n\n        for category in self.categories:\n            for timeinterval, data in enumerate(self.weather.values()):\n                if cur_time is None:\n                    cur_time = times.get_current_time(timeinterval)\n                current_time = times.time_from_string(cur_time)\n                wind_speed = float(data.get('Wind speed').split(' ')[0])\n                precipitation = float(data.get('Precipitation').split(' ')[0])\n                clouds = float(data.get('Cloud amount').split(' ')[0]) * 0.01\n                temperature = float(data.get('Air temperature').split(' ')[0])\n                humidity = float(data.get('Humidity').split(' ')[0]) * 0.01\n\n                if category in outdoor_categories:\n                    self.categorytype = \"Outdoor\"\n                    data['Score'] = self._outdoor_score(temperature, wind_speed, humidity,\n                                                        precipitation, clouds, sunrise_time, sunset_time, current_time)\n                elif category in indoor_categories:\n                    self.categorytype = \"Indoor\"\n                    data['Score'] = self._indoor_score(temperature, wind_speed, humidity,\n                                                       precipitation, clouds, sunrise_time, sunset_time, current_time)\n\n    def _outdoor_score(self, temperature, wind_speed, humidity, precipitation, clouds, sunrise_time, sunset_time, current_time):\n        '''\n        Calculates the score for an outdoor point of interest based on weather conditions.\n\n        Returns:\n            float: The calculated score for the outdoor point of interest.\n        '''\n        precipitation_weight = 0.35\n        temperature_weight = 0.3\n        clouds_weight = 0.04\n        wind_speed_weight = 0.04\n        # Scoring\n        score = precipitation_weight * math.exp(-precipitation)\n        temperature_comp = 0\n        \n        if 20 <= temperature <= 25:\n            temperature_comp = 1\n        elif temperature < 20:\n            temperature_comp = math.exp(-0.1 * (20 - temperature))\n        else:\n            temperature_comp = math.exp(0.1 * (25 - temperature))\n        score += temperature_weight * temperature_comp\n        if sunrise_time <= current_time <= sunset_time:\n            day_time_weight = 0.2\n            score += day_time_weight\n        # score += air_weight * math.exp(0.5 * 1- air)\n        score += clouds_weight * math.exp(-clouds)\n        score += wind_speed_weight * math.exp(-wind_speed)\n        if 0.4 <= humidity <= 0.55:\n            humidity_weight = 0.02\n\n            score += humidity_weight\n        return round(score, 2)\n\n    def _indoor_score(self, temperature, wind_speed, humidity, precipitation, clouds, sunrise_time, sunset_time, current_time):\n        # Weights\n        precipitation_weight = 0.7\n        temperature_weight = 0.1\n        clouds_weight = 0.04\n        wind_speed_weight = 0.03\n        # Scoring\n        score = precipitation_weight * (1 - math.exp(-10 * precipitation))\n        temperature_comp = 0\n        if 20 <= temperature <= 25:\n            temperature_comp = 0\n        elif temperature < 20:\n            temperature_comp = 1 - math.exp(-0.04 * (20 - temperature))\n        else:\n            temperature_comp = 1 - math.exp(0.2 * (25 - temperature))\n        score += temperature_weight * temperature_comp\n        if sunrise_time <= current_time <= sunset_time:\n            day_time_weight = 0.06\n            score += day_time_weight\n        # score += air_weight * (1 - math.exp(0.5 * 1- air))\n        score += clouds_weight * (1 - math.exp(-3 * clouds))\n        score += wind_speed_weight * (1 - math.exp(-0.3 * wind_speed))\n        if humidity < 0.4 or humidity > 0.55:\n            humidity_weight = 0.02\n\n            score += humidity_weight\n        return round(score, 2)\n\n    def set_simulated_weather(self, air_temperature, wind_speed, humidity,\n                              precipitation, cloud_amount, air_quality):\n        '''\n        Sets simulated weather data to test score calculations.\n        '''\n        self.weather = {\n            \"Weather\": {\n                \"Air temperature\": f\"{air_temperature} \u00b0C\",\n                \"Wind speed\": f\"{wind_speed} m/s\",\n                \"Humidity\": f\"{humidity} %\",\n                \"Precipitation\": f\"{precipitation} mm\",\n                \"Cloud amount\": f\"{cloud_amount} %\",\n                \"Air quality\": air_quality,\n            }\n        }\n\n    def get_json(self):\n        '''\n        Returns a JSON representation of the POI.\n        '''\n        return {'name': self.name, 'weather': self.weather,\n                'latitude': self.latitude, 'longitude': self.longitude,\n                'category': self.categories[-1], 'catetype': self.categorytype}", ""]}
{"filename": "recommender-back/src/apis/current.py", "chunked_list": ["import copy\nimport math\nfrom .poi import PointOfInterest\nfrom ..services.data_fetcher import DataFetcher\nfrom ..config import Config\n\n\nclass Current:\n    def __init__(self, fetcher: DataFetcher):\n        self.fetcher = fetcher\n        self.weather = None\n        self.aqi = None\n        self.get_current_weather()\n        self.get_current_air_quality()\n\n    def get_current_weather(self):\n        '''\n        Retrieves the current weather data for various stations.\n\n        Returns:\n            dict: A dictionary containing the current weather data for each station.\n        '''\n\n        obs = self.fetcher.get_current_weather_data(Config.BBOX, True)\n        data = {}\n        for station, metadata in obs.location_metadata.items():\n            weatherdata = {\n                'Air temperature': str(obs.data[station]['t2m']['values'][-1]) + ' \u00b0C',\n                'Wind speed': str(obs.data[station]['ws_10min']['values'][-1]) + ' m/s',\n                'Humidity': str(obs.data[station]['rh']['values'][-1]) + ' %',\n                'Precipitation': str(obs.data[station]['ri_10min']['values'][-1])\n                + ' mm',\n                'Cloud amount': str(obs.data[station]['n_man']['values'][-1]) + ' %',\n            }\n            for value in list(weatherdata):\n                if 'nan' in str(weatherdata[value]):\n                    weatherdata.pop(value)\n            if weatherdata:\n                weatherdata['Latitude'] = metadata['latitude']\n                weatherdata['Longitude'] = metadata['longitude']\n                data[station] = weatherdata\n        self.weather = data\n\n    def get_current_weather_warning(self, station):\n        '''\n        Retrieves the wind speed for one station and calculates if it's too high.\n\n        Returns:\n            boolean: If the wind speed is too high.\n        '''\n        weather = self.weather.get(station)\n        wind_speed = weather['Wind speed'].split(' ')[0]\n        return float(wind_speed) > 17\n\n    def get_current_air_quality(self):\n        '''\n        Retrieves the current AQI data for various stations.\n\n        Returns:\n            dict: A dictionary containing the current weather data for each station.\n        '''\n        raw_aqi_data = self.get_latest_air_quality()\n        self.aqi = self.parse_latest_aqi_data(raw_aqi_data)\n\n    def get_latest_air_quality(self):\n        '''\n        Retrieves the Air Quality Index data for the last 24 hours within specified area\n        '''\n        return self.fetcher.get_current_air_quality_data(\n            Config.BBOX, True, Config.AIRQUALITY_PARAMETERS\n        )\n\n    def parse_latest_aqi_data(self, raw_aqi_data: dict):\n        '''\n        Finds latest aqi value and coordinates that is not nan for each station.\n\n        Returns:\n            dict: A dictionary containing stations and their aqi and coordinates.\n        '''\n        latest_aqi_data = {}\n        for station, metadata in raw_aqi_data.location_metadata.items():\n            values = raw_aqi_data.data[station]['AQINDEX_PT1H_avg']['values']\n            latest_aqi_value = next((v for v in reversed(values) if not math.isnan(v)), 'nan')\n            if latest_aqi_value == 'nan':\n                continue\n            aqi = {\n                'Air quality': f'{str(latest_aqi_value)} AQI',\n                'Latitude': metadata['latitude'],\n                'Longitude': metadata['longitude'],\n            }\n            latest_aqi_data[station] = aqi\n        return latest_aqi_data\n\n    def find_nearest_stations_aqi(self, aqi, lat, lon):\n        '''\n        Calculates the closest stations index in the list of AQI-stations,\n        and returns the index of it.\n        '''\n        smallest, nearest = float('inf'), ''\n        for station in aqi:\n            dist = abs(aqi[station]['Latitude'] - lat)\\\n                + abs(aqi[station]['Longitude'] - lon)\n            if dist < smallest:\n                smallest, nearest = dist, station\n        return nearest\n\n    def find_nearest_stations_weather_data(self, poi: PointOfInterest):\n        '''\n        Finds the nearest weather station to a given point of interest (POI) and adds its weather data to the POI,\n        also adds the Air Quality Index data.\n\n        Args:\n            poi (PointOfInterest): The POI for which weather data needs to be added.\n\n        Returns:\n            PointOfInterest: The modified POI with weather information.\n\n        '''\n        lat = poi.latitude\n        lon = poi.longitude\n        weather = copy.deepcopy(self.weather)\n        missing_fields = [\n            'Air temperature',\n            'Wind speed',\n            'Precipitation',\n            'Cloud amount',\n            'Humidity',\n        ]\n        returned = {}\n        aqi = copy.deepcopy(self.aqi)\n        while True:\n            smallest, nearest = float('inf'), ''\n            for station in weather:\n                dist = abs(weather[station]['Latitude'] - lat) + abs(\n                    weather[station]['Longitude'] - lon\n                )\n                if dist < smallest:\n                    smallest, nearest = dist, station\n            for key, value in weather[nearest].items():\n                if key not in ['Latitude', 'Longitude']:\n                    returned.setdefault(key, value)\n                    if key in missing_fields:\n                        missing_fields.remove(key)\n            if not missing_fields or not weather:\n                smallest, nearest = float('inf'), ''\n                if len(aqi) > 0:\n                    nearest = self.find_nearest_stations_aqi(aqi, lat, lon)\n                    returned.setdefault(\n                        'Air quality', aqi[nearest]['Air quality'])\n                break\n            del weather[nearest]\n        poi.weather['Current'] = returned\n        return poi", ""]}
{"filename": "recommender-back/src/apis/manager.py", "chunked_list": ["import os\nimport json\nimport requests\nfrom requests import Timeout\nfrom .current import Current\nfrom .poi import PointOfInterest\nfrom ..services.data_fetcher import DataFetcher\nfrom ..db.db import get_collection\nfrom ..services.poi_init import init_pois\n\ndef get_simulated_pois_as_json(air_temperature, wind_speed, humidity,\n                                              precipitation, cloud_amount, air_quality, current_time, sunrise, sunset):\n    \"\"\"\n    Retrieves points of interest (POIs) from a JSON file and enriches them with simulated weather data.\n\n    Returns:\n        str: JSON string containing the POIs with calculated scores.\n\n    Raises:\n        KeyError: If an error occurs while processing the data.\n    \"\"\"\n    try:\n        pois = get_pois()\n        updated_data = []\n        for poi in pois:\n            poi.set_simulated_weather(air_temperature, wind_speed, humidity,\n                                            precipitation, cloud_amount, air_quality)\n            poi.calculate_score(current_time, sunrise, sunset)\n            updated_data.append(poi.get_json())\n        return json.dumps(updated_data)\n    except KeyError as error:\n        return {\"message\": \"An error occurred\", \"status\": 500, \"error\": str(error)}\n    except Timeout as error:\n        return {\"message\": \"Forecast timed out\", \"status\": 500, \"error\": str(error)}", "from ..services.poi_init import init_pois\n\ndef get_simulated_pois_as_json(air_temperature, wind_speed, humidity,\n                                              precipitation, cloud_amount, air_quality, current_time, sunrise, sunset):\n    \"\"\"\n    Retrieves points of interest (POIs) from a JSON file and enriches them with simulated weather data.\n\n    Returns:\n        str: JSON string containing the POIs with calculated scores.\n\n    Raises:\n        KeyError: If an error occurs while processing the data.\n    \"\"\"\n    try:\n        pois = get_pois()\n        updated_data = []\n        for poi in pois:\n            poi.set_simulated_weather(air_temperature, wind_speed, humidity,\n                                            precipitation, cloud_amount, air_quality)\n            poi.calculate_score(current_time, sunrise, sunset)\n            updated_data.append(poi.get_json())\n        return json.dumps(updated_data)\n    except KeyError as error:\n        return {\"message\": \"An error occurred\", \"status\": 500, \"error\": str(error)}\n    except Timeout as error:\n        return {\"message\": \"Forecast timed out\", \"status\": 500, \"error\": str(error)}", "\n\ndef get_pois_as_json(accessibility=False, category=\"All\"):\n    \"\"\"\n    Retrieves points of interest (POIs) from MongoDB and enriches them with current weather data.\n\n    Returns:\n        str: JSON string containing the POIs with weather information.\n\n    Raises:\n        KeyError: If an error occurs while processing the data.\n    \"\"\"\n    try:\n        pois = get_pois()\n        weather_fetcher = DataFetcher()\n        current = Current(weather_fetcher)\n        url = os.environ.get(\"REACT_APP_BACKEND_URL\") + \"/api/forecast\"\n        response = requests.get(url, timeout=1200)\n        forecast_data = response.json()\n        updated_data = []\n        for poi in pois:\n            if category not in poi.categories:\n                continue\n            poi: PointOfInterest = current.find_nearest_stations_weather_data(poi)\n            poi = find_nearest_coordinate_forecast_data(poi, forecast_data)\n            poi.calculate_score()\n            if accessibility in poi.not_accessible_for:\n                continue\n            updated_data.append(poi.get_json())\n        return json.dumps(updated_data)\n    except KeyError as error:\n        return {\"message\": \"An error occurred\", \"status\": 500, \"error\": str(error)}\n    except Timeout as error:\n        return {\"message\": \"Forecast timed out\", \"status\": 500, \"error\": str(error)}", "\n\ndef find_nearest_coordinate_forecast_data(poi: PointOfInterest, forecast_data):\n    \"\"\"\n    Retrieves all points of interest (POIs) from JSON files and merges them together.\n\n    Args:\n        category (list): List of categories of POIs to retrieve. If None, default categories will be used.\n\n    Returns:\n        list: List of all POIs.\n    \"\"\"\n    try:\n        lat = poi.latitude\n        lon = poi.longitude\n        coord_key = f\"{lat}, {lon}\"\n        for hour in forecast_data:\n            data = forecast_data[hour]\n            if forecast_data is None or coord_key not in data:\n                return poi\n\n            time_key = f\"{hour[11:16]}\"\n            poi.weather[time_key] = data[coord_key]\n    except TypeError:\n        print(\"Failed to find nearest coordinate forecast data. TypeError occurred.\")\n\n    return poi", "\ndef get_pois():\n    \"\"\"\n    Fetches and converts mongoDB documents into POI -objects.\n\n    Args:\n        test (bool): A flag to indicate if the test environment is used.\n\n    Returns:\n        list: List of POI -objects.\n    \"\"\"\n    collection = get_collection()\n    if collection.count_documents({}) == 0:\n        init_pois()\n    all_documents = collection.find({})\n    pois = []\n    for poi in all_documents:\n        poi = PointOfInterest(poi['name'], poi['latitude'], poi['longitude'],\n                            poi['not_accessible_for'], poi['categories'])\n        pois.append(poi)\n    return pois"]}
{"filename": "recommender-back/src/apis/aqi.py", "chunked_list": ["import numpy as np\nimport tempfile\nimport requests\nimport defusedxml.ElementTree as ET\nimport time\nfrom urllib.parse import urlencode\nfrom netCDF4 import Dataset\nfrom ..config import Config\nfrom datetime import timedelta\nfrom .times import get_forecast_times, forecast_q_time_to_finnish", "from datetime import timedelta\nfrom .times import get_forecast_times, forecast_q_time_to_finnish\nfrom scipy.spatial import cKDTree\n\nclass AQI:\n    def __init__(self):\n        \"\"\"A class representing a single AQI object\n\n        Args:\n            data (numpy array): aqi data as numpy array\n            dataset (netcdf): netcdf dataset containing the aqi data\n            datetimes (dict): dictionary containing datetimes and aqi objects\n            coord_kdtree (cKDTree): kdtree containing all possible lat, lon pairs\n        \"\"\"\n        self.data = None\n        self.dataset = None\n        self.datetimes = None\n        self.coords_kdtree = None\n\n    def download_netcdf_and_store(self, forecast_q_time):\n        \"\"\"Downloads netcdf file, parses it and stores the data in the object.\n           The temporary file is deleted afterwards.\n        \"\"\"\n        netcdf_file_url = self._parse_xml()\n\n        with tempfile.NamedTemporaryFile(delete=True) as temp_file:\n            netcdf_file_name = temp_file.name\n            self._download_to_file(netcdf_file_url, netcdf_file_name, 5)\n            self.dataset = Dataset(netcdf_file_name)\n            self._parse_netcdf(forecast_q_time)\n\n    def _parse_xml(self):\n        \"\"\"Parses the fmi open data xml file\n\n        Returns:\n            string: url link of latest queried netcdf file\n        \"\"\"\n        url = self._get_xml_url()\n        req = requests.get(url)\n        content = req.content\n        xml = ET.fromstring(content)\n        file_reference = xml.findall(Config.FILEREF_MEMBER)\n        latest_file_url = file_reference[-1].text\n        return latest_file_url\n\n    def _get_xml_url(self):\n        \"\"\"Fetches the xml file url based on query\n\n        Returns:\n            string: xml file url\n        \"\"\"\n        _, start_time, end_time = get_forecast_times()\n        args = {'starttime': start_time,\n                'endtime': end_time,\n                'parameters': Config.AQI_PARAMS,\n                'bbox': Config.BBOX_AQI}\n        xml_url = Config.FMI_QUERY_URL + Config.AQI_QUERY + \"&\" + urlencode(args)\n        return xml_url\n\n    def _parse_netcdf(self, forecast_q_time):\n        \"\"\"Parses the given netcdf file\n\n        Returns:\n            dict: A dictionary of datetimes keys and AQI object values\n        \"\"\"\n        latitudes = self.dataset.variables['lat'][:]\n        longitudes = self.dataset.variables['lon'][:]\n        times = self.dataset.variables['time'][:]\n        aqi = self.dataset.variables['index_of_airquality_194'][:]\n\n        forecast_time = forecast_q_time_to_finnish(forecast_q_time) + timedelta(hours=1)\n\n        datetimes = {}\n        for time in times:\n            forecast_datetime = forecast_time + timedelta(hours=int(time))\n            forecast_datetime = forecast_datetime.replace(minute=0, second=0, microsecond=0)\n            aqi_data = aqi[int(time)]\n\n            non_zero_lat_indices, non_zero_lon_indices = np.where(aqi_data != 0)\n\n            filtered_coords = (\n                np.column_stack(\n                (\n                    latitudes[non_zero_lat_indices],\n                    longitudes[non_zero_lon_indices]\n                )\n            )\n        )\n\n            coords_kdtree = cKDTree(filtered_coords)\n            filtered_aqi = aqi_data[non_zero_lat_indices, non_zero_lon_indices]\n\n            aqi_obj = AQI()\n            aqi_obj.data = filtered_aqi\n            aqi_obj.coords_kdtree = coords_kdtree\n            datetimes[forecast_datetime] = aqi_obj\n\n        self.datetimes = datetimes\n        self.dataset.close()\n\n    def to_json(self, pois):\n            \"\"\"Converts the parsed netcdf data into JSON format and calculates nearest AQI values for POIs.\n\n            Args:\n                pois (list): List of POI objects.\n\n            Returns:\n                dict: AQI data in JSON format with nearest AQI values for POIs\n            \"\"\"\n            data = {}\n            for datetime in self.datetimes:\n                time_str = datetime.strftime('%Y-%m-%d %H:%M:%S')\n                aqi_object = self.datetimes[datetime]\n\n                nearest_aqi_values = {}\n                for poi in pois:\n                    lat_poi, lon_poi = float(poi.latitude), float(poi.longitude)\n                    _, closest_index = aqi_object.coords_kdtree.query([lat_poi, lon_poi])\n                    aqi_value = aqi_object.data[closest_index]\n                    poi_coords = f'{lat_poi}, {lon_poi}'\n                    nearest_aqi_values[poi_coords] = {'Air Quality Index': str(aqi_value)}\n\n                data[time_str] = nearest_aqi_values\n\n            return data\n\n    def _download_to_file(self, url, file_name, max_retries):\n            \"\"\"Downloads the file content\n\n            Args:\n                url (string): url of the file to be downloaded\n                file_name (string): name of the file\n                max_retries (int): maximum number of retries\n            \"\"\"\n            for retry_attempt in range(max_retries-1):\n                try:\n                    start_time = time.time()\n                    print('Downloading AQI data')\n                    with open(file_name, 'wb') as file:\n                        response = requests.get(url, stream=True)\n                        for chunk in response.iter_content(chunk_size=10*1024*1024):\n                            file.write(chunk)\n                        print('Finished downloading. Parsing data...')\n                        end_time = time.time()\n                        print(f'{end_time - start_time} seconds')\n                        return\n                except (requests.RequestException, ConnectionResetError) as e:\n                    print(f\"Download attempt {retry_attempt + 1} failed with error: {str(e)}\")\n                    if retry_attempt < max_retries:\n                        print(f'Retrying...')\n                    else:\n                        print(f\"Maximum retries reached. Download failed.\")", ""]}
{"filename": "recommender-back/src/apis/forecast.py", "chunked_list": ["import math\nimport time\nimport numpy as np\nfrom .times import utc_to_finnish, get_forecast_times\nfrom ..config import Config\nfrom ..services.data_fetcher import DataFetcher\n\n\nclass Forecast:\n    def __init__(self, fetcher: DataFetcher):\n        self.fetcher = fetcher\n        self.data = None\n        self.valid_times = None\n        self.data_levels = None\n        self.coordinates = None\n\n    def update_data(self):\n        \"\"\"\n        Updates the forecast data.\n        Fetches the latest data and updates class properties if new data is available.\n        \"\"\"\n        current, start, end = get_forecast_times()\n        print(f\"Query for the new Grid object at time: {current} UTC\")\n        forecast_data = self.get_latest_forecast(start, end)\n        \n        latest_forecast = max(forecast_data.data.keys())\n        if not self.data or latest_forecast > max(self.data.keys()):\n            self.data = forecast_data.data[latest_forecast]\n            self.parse_forecast_data()\n            self.update_forecast_properties()\n\n        return current\n\n    def get_latest_forecast(self, start, end):\n        \"\"\"\n        Retrieves the latest forecast data within the specified time range.\n        Args:\n            start (datetime): The start time for the data retrieval.\n            end (datetime): The end time for the data retrieval.\n        Returns:\n            Grid: The forecast grid data within the specified time range.\n        \"\"\"\n        return self.fetcher.get_forecast_data(\n            start, end, Config.BBOX, Config.TIMESTEP, Config.FORECAST_PARAMETERS\n        )\n\n    def parse_forecast_data(self):\n        \"\"\"\n        Parses the forecast data with retry attempts on failure.\n        Raises:\n            ConnectionResetError: If a ConnectionResetError occurs during parsing after maximum number of retry attempts.\n        \"\"\"\n        max_retries = 3\n        retry_delay = 5  # delay in seconds\n\n        for attempt in range(max_retries):\n            try:\n                self.data.parse(delete=True)\n                break\n            except (ConnectionResetError, TimeoutError) as error:\n                print(f\"Error during parsing: {error}\")\n                if attempt < max_retries - 1:\n                    time.sleep(retry_delay)\n                    print(f\"Retrying parsing ({attempt + 1} out of {max_retries})...\")\n                else:\n                    print(f\"Parsing failed after {max_retries} attempts due to {type(error).__name__}.\")\n                    raise\n            except Exception as error:  # Generic exception handler\n                print(f\"Unexpected error during parsing: {error}\")\n                if attempt < max_retries - 1:\n                    time.sleep(retry_delay)\n                    print(f\"Retrying parsing ({attempt + 1} out of {max_retries})...\")\n                else:\n                    print(f\"Parsing failed after {max_retries} attempts due to unexpected error.\")\n                    raise\n\n    def update_forecast_properties(self):\n        \"\"\"\n        Updates forecast properties based on the latest parsed data.\n        \"\"\"\n        self.valid_times = self.data.data.keys()\n        earliest_step = min(self.valid_times)\n        self.data_levels = self.data.data[earliest_step].keys()\n        self.coordinates = np.dstack((self.data.latitudes, self.data.longitudes))\n\n    def get_data(self):\n        \"\"\"\n        Gets all the forecast data from the grid.\n\n        Returns:\n            dict: A dictionary containing all the forecast data.\n        \"\"\"\n        data = {}\n        for date_time in self.valid_times:\n            local_time = utc_to_finnish(date_time)\n            time_str = local_time.strftime(\"%Y-%m-%d %H:%M:%S\")\n            coordinates_data = {}\n            for level in self.data_levels:\n                datasets = self.data.data[date_time][level]\n                for dataset_name, dataset in datasets.items():\n                    unit = dataset[\"units\"]\n                    data_array = dataset[\"data\"]\n                    for (lat_index, lon_index), data_value in np.ndenumerate(\n                        data_array\n                    ):\n                        latitude = self.coordinates[lat_index, lon_index, 0]\n                        longitude = self.coordinates[lat_index, lon_index, 1]\n                        key = str((latitude, longitude))\n                        if key not in coordinates_data:\n                            coordinates_data[key] = []\n                        coordinates_data[key].append(\n                            {\"Dataset\": dataset_name, \"Unit\": unit, \"Data\": data_value}\n                        )\n            data[time_str] = coordinates_data\n        return data\n\n    def get_coordinates(self):\n        \"\"\"\n        Returns all available coordinates within the bounding box area.\n\n        Returns:\n            list: List of coordinate pairs.\n        \"\"\"\n        flattened_coords = [\n            tuple(coord) for sublist in self.coordinates for coord in sublist\n        ]\n\n        unique_coords = set(flattened_coords)\n        return list(unique_coords)\n\n    def get_closest_poi_coordinates_data(self, pois, aqi_data):\n        \"\"\"\n        Finds the nearest coordinates forecast data for all of the POI's coordinates.\n\n        Args:\n            pois (list): List of POI objects.\n\n        Returns:\n            dict: A dictionary containing the nearest coordinates forecast data for each hour.\n        \"\"\"\n        data = self.get_data()\n        coordinates = self.get_coordinates()\n        closest_coordinates_fore = self.calculate_shortest_weather(pois, coordinates)\n\n        returned_data = {hour: {} for hour in data}\n\n        for hour, hour_data in data.items():\n            for poi_coord, nearest in closest_coordinates_fore.items():\n                nearest_str = f\"({nearest[0]}, {nearest[1]})\"\n                if nearest_str in hour_data:\n                    forecast = hour_data[nearest_str]\n                    returned_data[hour][\n                        f\"{poi_coord[0]}, {poi_coord[1]}\"\n                    ] = self.parse_forecast(forecast)\n\n        if aqi_data:\n            for datetime, poi_coords in aqi_data.items():\n                for poi_coord, air_quality in poi_coords.items():\n                    aqi_value = air_quality['Air Quality Index']\n                    returned_data[datetime][poi_coord]['Air quality'] = f'{aqi_value} AQI'\n\n        return returned_data\n\n    def parse_forecast(self, forecast):\n        \"\"\"\n        Parses the desired data from the forecast grid.\n\n        Args:\n            forecast (list): List of forecast data.\n\n        Returns:\n            dict: A dictionary containing the parsed forecast data.\n        \"\"\"\n        for value in forecast:\n            if value[\"Dataset\"] == \"2 metre temperature\":\n                temperature = round(value[\"Data\"] - 273.15, 1)\n            elif value[\"Dataset\"] == \"2 metre relative humidity\":\n                humidity = round(value[\"Data\"], 1)\n            elif value[\"Dataset\"] == \"10 metre U wind component\":\n                u_wind = value[\"Data\"]\n            elif value[\"Dataset\"] == \"10 metre V wind component\":\n                v_wind = value[\"Data\"]\n            elif value[\"Dataset\"] == \"surface precipitation amount, rain, convective\":\n                precipitation = round(value[\"Data\"], 1)\n            elif value[\"Dataset\"] == \"Total Cloud Cover\":\n                cloudcoverage = round(value[\"Data\"], 1)\n\n        wind_speed = self.calculate_wind_speed_and_direction(u_wind, v_wind)\n\n        return {\n            \"Air temperature\": f\"{str(temperature)} \u00b0C\",\n            \"Humidity\": f\"{str(humidity)} %\",\n            \"Wind speed\": f\"{wind_speed} m/s\",\n            \"Precipitation\": f\"{precipitation} mm\",\n            \"Cloud amount\": f\"{cloudcoverage} %\",\n        }\n\n    def calculate_wind_speed_and_direction(self, u_wind, v_wind):\n        \"\"\"\n        Calculates the wind speed and direction based on the U and V components.\n\n        Args:\n            u_wind (float): U component of the wind.\n            v_wind (float): V component of the wind.\n\n        Returns:\n            tuple: A tuple containing the wind speed and direction.\n        \"\"\"\n        wind_speed = math.sqrt(u_wind**2 + v_wind**2)\n        wind_direction = math.atan2(u_wind, v_wind) * (180 / math.pi)\n        wind_direction = (wind_direction + 360) % 360\n        return round(wind_speed, 1)\n\n    def calculate_shortest_weather(self, pois, fore_coordinates):\n        \"\"\"Calculates the nearest weather forecast data for a given poi\n\n        Args:\n            pois (list): List of POI objects.\n            fore_coordinates (list): List of weather forecast coordinates as tuples\n\n        Returns:\n            list: a list containing pois and their nearest forecast weather coordinate\n        \"\"\"\n        closest_coordinates = {}\n        for poi in pois:\n            smallest = float(\"inf\")\n            nearest = []\n            lat = float(poi.latitude)\n            lon = float(poi.longitude)\n            for coordinate in fore_coordinates:\n                dist = abs(coordinate[0] - lat) + abs(coordinate[1] - lon)\n                if dist < smallest:\n                    smallest = dist\n                    nearest = [coordinate[0], coordinate[1]]\n            closest_coordinates[(lat, lon)] = nearest\n        return closest_coordinates", "class Forecast:\n    def __init__(self, fetcher: DataFetcher):\n        self.fetcher = fetcher\n        self.data = None\n        self.valid_times = None\n        self.data_levels = None\n        self.coordinates = None\n\n    def update_data(self):\n        \"\"\"\n        Updates the forecast data.\n        Fetches the latest data and updates class properties if new data is available.\n        \"\"\"\n        current, start, end = get_forecast_times()\n        print(f\"Query for the new Grid object at time: {current} UTC\")\n        forecast_data = self.get_latest_forecast(start, end)\n        \n        latest_forecast = max(forecast_data.data.keys())\n        if not self.data or latest_forecast > max(self.data.keys()):\n            self.data = forecast_data.data[latest_forecast]\n            self.parse_forecast_data()\n            self.update_forecast_properties()\n\n        return current\n\n    def get_latest_forecast(self, start, end):\n        \"\"\"\n        Retrieves the latest forecast data within the specified time range.\n        Args:\n            start (datetime): The start time for the data retrieval.\n            end (datetime): The end time for the data retrieval.\n        Returns:\n            Grid: The forecast grid data within the specified time range.\n        \"\"\"\n        return self.fetcher.get_forecast_data(\n            start, end, Config.BBOX, Config.TIMESTEP, Config.FORECAST_PARAMETERS\n        )\n\n    def parse_forecast_data(self):\n        \"\"\"\n        Parses the forecast data with retry attempts on failure.\n        Raises:\n            ConnectionResetError: If a ConnectionResetError occurs during parsing after maximum number of retry attempts.\n        \"\"\"\n        max_retries = 3\n        retry_delay = 5  # delay in seconds\n\n        for attempt in range(max_retries):\n            try:\n                self.data.parse(delete=True)\n                break\n            except (ConnectionResetError, TimeoutError) as error:\n                print(f\"Error during parsing: {error}\")\n                if attempt < max_retries - 1:\n                    time.sleep(retry_delay)\n                    print(f\"Retrying parsing ({attempt + 1} out of {max_retries})...\")\n                else:\n                    print(f\"Parsing failed after {max_retries} attempts due to {type(error).__name__}.\")\n                    raise\n            except Exception as error:  # Generic exception handler\n                print(f\"Unexpected error during parsing: {error}\")\n                if attempt < max_retries - 1:\n                    time.sleep(retry_delay)\n                    print(f\"Retrying parsing ({attempt + 1} out of {max_retries})...\")\n                else:\n                    print(f\"Parsing failed after {max_retries} attempts due to unexpected error.\")\n                    raise\n\n    def update_forecast_properties(self):\n        \"\"\"\n        Updates forecast properties based on the latest parsed data.\n        \"\"\"\n        self.valid_times = self.data.data.keys()\n        earliest_step = min(self.valid_times)\n        self.data_levels = self.data.data[earliest_step].keys()\n        self.coordinates = np.dstack((self.data.latitudes, self.data.longitudes))\n\n    def get_data(self):\n        \"\"\"\n        Gets all the forecast data from the grid.\n\n        Returns:\n            dict: A dictionary containing all the forecast data.\n        \"\"\"\n        data = {}\n        for date_time in self.valid_times:\n            local_time = utc_to_finnish(date_time)\n            time_str = local_time.strftime(\"%Y-%m-%d %H:%M:%S\")\n            coordinates_data = {}\n            for level in self.data_levels:\n                datasets = self.data.data[date_time][level]\n                for dataset_name, dataset in datasets.items():\n                    unit = dataset[\"units\"]\n                    data_array = dataset[\"data\"]\n                    for (lat_index, lon_index), data_value in np.ndenumerate(\n                        data_array\n                    ):\n                        latitude = self.coordinates[lat_index, lon_index, 0]\n                        longitude = self.coordinates[lat_index, lon_index, 1]\n                        key = str((latitude, longitude))\n                        if key not in coordinates_data:\n                            coordinates_data[key] = []\n                        coordinates_data[key].append(\n                            {\"Dataset\": dataset_name, \"Unit\": unit, \"Data\": data_value}\n                        )\n            data[time_str] = coordinates_data\n        return data\n\n    def get_coordinates(self):\n        \"\"\"\n        Returns all available coordinates within the bounding box area.\n\n        Returns:\n            list: List of coordinate pairs.\n        \"\"\"\n        flattened_coords = [\n            tuple(coord) for sublist in self.coordinates for coord in sublist\n        ]\n\n        unique_coords = set(flattened_coords)\n        return list(unique_coords)\n\n    def get_closest_poi_coordinates_data(self, pois, aqi_data):\n        \"\"\"\n        Finds the nearest coordinates forecast data for all of the POI's coordinates.\n\n        Args:\n            pois (list): List of POI objects.\n\n        Returns:\n            dict: A dictionary containing the nearest coordinates forecast data for each hour.\n        \"\"\"\n        data = self.get_data()\n        coordinates = self.get_coordinates()\n        closest_coordinates_fore = self.calculate_shortest_weather(pois, coordinates)\n\n        returned_data = {hour: {} for hour in data}\n\n        for hour, hour_data in data.items():\n            for poi_coord, nearest in closest_coordinates_fore.items():\n                nearest_str = f\"({nearest[0]}, {nearest[1]})\"\n                if nearest_str in hour_data:\n                    forecast = hour_data[nearest_str]\n                    returned_data[hour][\n                        f\"{poi_coord[0]}, {poi_coord[1]}\"\n                    ] = self.parse_forecast(forecast)\n\n        if aqi_data:\n            for datetime, poi_coords in aqi_data.items():\n                for poi_coord, air_quality in poi_coords.items():\n                    aqi_value = air_quality['Air Quality Index']\n                    returned_data[datetime][poi_coord]['Air quality'] = f'{aqi_value} AQI'\n\n        return returned_data\n\n    def parse_forecast(self, forecast):\n        \"\"\"\n        Parses the desired data from the forecast grid.\n\n        Args:\n            forecast (list): List of forecast data.\n\n        Returns:\n            dict: A dictionary containing the parsed forecast data.\n        \"\"\"\n        for value in forecast:\n            if value[\"Dataset\"] == \"2 metre temperature\":\n                temperature = round(value[\"Data\"] - 273.15, 1)\n            elif value[\"Dataset\"] == \"2 metre relative humidity\":\n                humidity = round(value[\"Data\"], 1)\n            elif value[\"Dataset\"] == \"10 metre U wind component\":\n                u_wind = value[\"Data\"]\n            elif value[\"Dataset\"] == \"10 metre V wind component\":\n                v_wind = value[\"Data\"]\n            elif value[\"Dataset\"] == \"surface precipitation amount, rain, convective\":\n                precipitation = round(value[\"Data\"], 1)\n            elif value[\"Dataset\"] == \"Total Cloud Cover\":\n                cloudcoverage = round(value[\"Data\"], 1)\n\n        wind_speed = self.calculate_wind_speed_and_direction(u_wind, v_wind)\n\n        return {\n            \"Air temperature\": f\"{str(temperature)} \u00b0C\",\n            \"Humidity\": f\"{str(humidity)} %\",\n            \"Wind speed\": f\"{wind_speed} m/s\",\n            \"Precipitation\": f\"{precipitation} mm\",\n            \"Cloud amount\": f\"{cloudcoverage} %\",\n        }\n\n    def calculate_wind_speed_and_direction(self, u_wind, v_wind):\n        \"\"\"\n        Calculates the wind speed and direction based on the U and V components.\n\n        Args:\n            u_wind (float): U component of the wind.\n            v_wind (float): V component of the wind.\n\n        Returns:\n            tuple: A tuple containing the wind speed and direction.\n        \"\"\"\n        wind_speed = math.sqrt(u_wind**2 + v_wind**2)\n        wind_direction = math.atan2(u_wind, v_wind) * (180 / math.pi)\n        wind_direction = (wind_direction + 360) % 360\n        return round(wind_speed, 1)\n\n    def calculate_shortest_weather(self, pois, fore_coordinates):\n        \"\"\"Calculates the nearest weather forecast data for a given poi\n\n        Args:\n            pois (list): List of POI objects.\n            fore_coordinates (list): List of weather forecast coordinates as tuples\n\n        Returns:\n            list: a list containing pois and their nearest forecast weather coordinate\n        \"\"\"\n        closest_coordinates = {}\n        for poi in pois:\n            smallest = float(\"inf\")\n            nearest = []\n            lat = float(poi.latitude)\n            lon = float(poi.longitude)\n            for coordinate in fore_coordinates:\n                dist = abs(coordinate[0] - lat) + abs(coordinate[1] - lon)\n                if dist < smallest:\n                    smallest = dist\n                    nearest = [coordinate[0], coordinate[1]]\n            closest_coordinates[(lat, lon)] = nearest\n        return closest_coordinates", ""]}
{"filename": "recommender-back/src/apis/pathing.py", "chunked_list": ["import requests\n\nclass GreenPathsAPI:\n    \"\"\"\n    A class for fetching route information from the Green Paths API and plotting the route on a map.\n        Parameters:\n        start_coords (tuple): Tuple containing the latitude and longitude of the starting point.\n        end_coords (tuple): Tuple containing the latitude and longitude of the ending point.\n        travel_mode (str, optional): Mode of travel, can be 'walk' or 'bike'. Defaults to 'walk'.\n        routing_mode (str, optional): Routing mode, can be 'fast', 'short', 'clean', 'quiet', or 'safe' (for bikes).\n            Defaults to 'fast'.\n    \"\"\"\n    def __init__(self, start_coords, end_coords, travel_mode=\"walk\", routing_mode=\"fast\"):\n        self.start_coords = start_coords\n        self.end_coords = end_coords\n        self.travel_mode = travel_mode\n        self.routing_mode = routing_mode\n        self.api_response = self.fetch_api_data()\n        self.route_coordinates = self.extract_path_coordinates()\n\n    def fetch_api_data(self):\n        \"\"\"\n        Fetches route data from the Green Paths API.\n        Returns:\n            dict: JSON response containing route information or None if an error occurred.\n        \"\"\"\n        url = f\"https://www.greenpaths.fi/paths/{self.travel_mode}/{self.routing_mode}/{self.start_coords[0]},{self.start_coords[1]}/{self.end_coords[0]},{self.end_coords[1]}\"\n        try:\n            response = requests.get(url)\n            response.raise_for_status()\n            return response.json()\n        except requests.exceptions.RequestException as e:\n            print(f\"Failed to fetch data from the API: {e}\")\n            return None\n\n    def extract_path_coordinates(self):\n        \"\"\"\n        Extracts the latitude and longitude coordinates of the route from the API response.\n        Returns:\n            list: List of tuples containing latitude and longitude coordinates of the route or empty list if no data.\n        \"\"\"\n        path_coordinates = []\n\n        if not self.api_response:\n            return path_coordinates\n\n        path_fc = self.api_response.get(\"path_FC\") or {}\n        if not path_fc:\n            return path_coordinates\n\n        for feature in path_fc.get(\"features\", []):\n            geometry = feature.get(\"geometry\", {})\n            if geometry.get(\"type\") == \"LineString\" and geometry.get(\"coordinates\"):\n                path_coordinates.extend(geometry.get(\"coordinates\"))\n\n        return path_coordinates", ""]}
{"filename": "recommender-back/src/tests/routes_test.py", "chunked_list": ["import unittest\nfrom ..app import app\n\n\nclass AppTestCase(unittest.TestCase):\n    def setUp(self):\n        app.testing = True\n        self.client = app.test_client()\n\n    def test_index_route(self):\n        response = self.client.get('/')\n        data = response.get_json()\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(data['message'], 'Hello from the backend!')\n        self.assertEqual(data['status'], 200)\n\n    def test_not_found_error_handler(self):\n        response = self.client.get('/nonexistent')\n        error_data = response.get_json()\n        self.assertEqual(response.status_code, 404)\n        self.assertEqual(error_data['message'], 'Resource not found')\n        self.assertEqual(error_data['status'], 404)", "\n\nif __name__ == '__main__':\n    unittest.main()\n"]}
{"filename": "recommender-back/src/tests/mock_data.py", "chunked_list": ["from src.apis.poi import PointOfInterest\n\nMOCK_POIS = [\n    PointOfInterest(name=\"POI 1\", latitude=60.201231, longitude=24.973478, categories=[\"Sport Halls\"], not_accessible_for=[]),\n    PointOfInterest(name=\"POI 2\", latitude=60.1998, longitude=24.968672, categories=[\"Sport Halls\"], not_accessible_for=[]),\n    PointOfInterest(name=\"POI 3\", latitude=60.189543, longitude=24.921326, categories=[\"Open air pools and beaches\"], not_accessible_for=[])\n]"]}
{"filename": "recommender-back/src/tests/__init__.py", "chunked_list": [""]}
{"filename": "recommender-back/src/tests/apis/poi_test.py", "chunked_list": ["import unittest\nfrom unittest.mock import patch\nfrom datetime import datetime\nfrom src.apis.poi import PointOfInterest\n\nclass TestPointOfInterest(unittest.TestCase):\n    def setUp(self):\n        self.poi = PointOfInterest()\n\n    def test_outdoor_score(self):\n        temperature = 23\n        wind_speed = 5\n        humidity = 0.5\n        precipitation = 20\n        clouds = 0.6\n        sunrise = datetime(2023, 6, 23, 6, 0)\n        sunset = datetime(2023, 6, 23, 18, 0)\n        cur_time = datetime(2023, 6, 23, 12, 0)\n\n        expected_score = 0.54\n        score = self.poi._outdoor_score(temperature, wind_speed, humidity, precipitation, clouds, sunrise, sunset, cur_time)\n        self.assertAlmostEqual(score, expected_score, places=6)\n        \n        temperature = 7\n        \n        expected_score = 0.32\n        score = self.poi._outdoor_score(temperature, wind_speed, humidity, precipitation, clouds, sunrise, sunset, cur_time)\n        self.assertAlmostEqual(score, expected_score, places=6)\n        \n        temperature = 45\n        \n        expected_score = 0.28\n        score = self.poi._outdoor_score(temperature, wind_speed, humidity, precipitation, clouds, sunrise, sunset, cur_time)\n        self.assertAlmostEqual(score, expected_score, places=6)\n\n    def test_indoor_score(self):\n        temperature = 22\n        wind_speed = 2\n        humidity = 0.45\n        precipitation = 200\n        clouds = 0.8\n        sunrise = datetime(2023, 6, 23, 6, 0)\n        sunset = datetime(2023, 6, 23, 18, 0)\n        cur_time = datetime(2023, 6, 23, 20, 0)\n\n        expected_score = 0.75\n        score = self.poi._indoor_score(temperature, wind_speed, humidity, precipitation, clouds, sunrise, sunset, cur_time)\n        self.assertAlmostEqual(score, expected_score, places=6)\n        \n        temperature = 7\n        \n        expected_score = 0.79\n        score = self.poi._indoor_score(temperature, wind_speed, humidity, precipitation, clouds, sunrise, sunset, cur_time)\n        self.assertAlmostEqual(score, expected_score, places=6)\n        \n        temperature = 45\n        \n        expected_score = 0.85\n        score = self.poi._indoor_score(temperature, wind_speed, humidity, precipitation, clouds, sunrise, sunset, cur_time)\n        self.assertAlmostEqual(score, expected_score, places=6)\n\n    def test_calculate_score_chooses_indoor(self):\n        with patch('src.apis.times.get_current_time') as mock_get_current_time:\n            weather = {'20:00':{'Wind speed':'2.0 m/s','Precipitation':'200 mm','Cloud amount':'0.6 %',\n                    'Air temperature':'22.0 *C','Humidity':'0.45 %'}}\n\n            sun = ('06:00','18:00')\n            mock_get_current_time.return_value = '20:00'\n            categories = ['Sport halls']\n\n            test_poi = PointOfInterest(categories=categories)\n            test_poi.weather = weather\n            test_poi.sun = sun\n\n            expected_score = 0.73\n\n            test_poi.calculate_score()\n            score = test_poi.weather['20:00']['Score']\n\n            self.assertAlmostEqual(score, expected_score, places=6)\n\n    def test_calculate_score_chooses_outdoor(self):\n        with patch('src.apis.times.get_current_time') as mock_get_current_time:\n            weather = {'12:00':{'Wind speed':'5.0 m/s','Precipitation':'20 mm','Cloud amount':'0.6 %',\n                    'Air temperature':'23.0 *C','Humidity':'0.5 %'}}\n\n            sun = ('06:00','18:00')\n            mock_get_current_time.return_value = '12:00'\n            categories = ['Open air pools and beaches']\n\n            test_poi = PointOfInterest(categories=categories)\n            test_poi.weather = weather\n            test_poi.sun = sun\n\n            expected_score = 0.54\n\n            test_poi.calculate_score()\n            score = test_poi.weather['12:00']['Score']\n\n            self.assertAlmostEqual(score, expected_score, places=6)\n      \n    def test_json_in_correct_form(self):\n        weather = {'12:00':{'Wind speed':'5.0 m/s','Precipitation':'20 mm','Cloud amount':'0.6 %',\n                'Air temperature':'23.0 *C','Humidity':'0.5 %'}}\n\n        sun = ('06:00','18:00')\n        categories = ['Open air pools and beaches']\n\n        test_poi = PointOfInterest(name= 'Test POI', latitude=21, longitude=61, categories=categories)\n        test_poi.weather = weather\n        test_poi.sun = sun\n        expected_json = {\"name\": 'Test POI', \"weather\": {\"12:00\": {\"Wind speed\": \"5.0 m/s\", \"Precipitation\": \"20 mm\", \"Cloud amount\": \"0.6 %\", \"Air temperature\": \"23.0 *C\", \"Humidity\": \"0.5 %\"}}, \"latitude\": 21, \"longitude\": 61, \"category\": \"Open air pools and beaches\", \"catetype\": None}\n\n        test_json = test_poi.get_json()\n        \n        self.assertEqual(test_json, expected_json)", "\nif __name__ == '__main__':\n    unittest.main()\n\n\n"]}
{"filename": "recommender-back/src/tests/apis/pathing_test.py", "chunked_list": ["import unittest\nfrom src.apis.pathing import GreenPathsAPI\n\nclass TestGreenPathsAPI(unittest.TestCase):\n    def test_fetch_api_data(self):\n        start_coords = (60.172808, 24.909591)\n        end_coords = (60.204516, 24.962033)\n        green_paths = GreenPathsAPI(start_coords, end_coords)\n        api_response = green_paths.api_response\n        self.assertIsInstance(api_response, dict)\n\n        expected_keys = [\"path_FC\", \"edge_FC\"]\n        for key in expected_keys:\n            self.assertIn(key, api_response)\n\n        expected_types = {\n            \"path_FC\": dict,\n            \"edge_FC\": dict,\n        }\n\n        for key, expected_type in expected_types.items():\n            self.assertIsInstance(api_response[key], expected_type)\n\n    def test_extract_path_coordinates(self):\n        start_coords = (60.172808, 24.909591)\n        end_coords = (60.204516, 24.962033)\n        green_paths = GreenPathsAPI(start_coords, end_coords)\n        route_coordinates = green_paths.route_coordinates\n\n        self.assertIsInstance(route_coordinates, list)\n        self.assertTrue(route_coordinates, \"No route coordinates available.\")\n\n        for coord in route_coordinates:\n            self.assertIsInstance(coord, list)\n            self.assertEqual(len(coord), 2)\n\n        for latitude, longitude in route_coordinates:\n            self.assertIsInstance(latitude, (int, float))\n            self.assertIsInstance(longitude, (int, float))\n            self.assertGreaterEqual(latitude, -90.0)\n            self.assertLessEqual(latitude, 90.0)\n            self.assertGreaterEqual(longitude, -180.0)\n            self.assertLessEqual(longitude, 180.0)", "\nif __name__ == '__main__':\n    unittest.main()"]}
{"filename": "recommender-back/src/tests/apis/times_test.py", "chunked_list": ["import unittest\nfrom unittest.mock import patch\nfrom datetime import datetime\nfrom src.apis.times import get_current_time\n\n\nclass TimesTest(unittest.TestCase):\n    @patch('src.apis.times.dt.datetime')\n    def test_current_time_is_returned_correctly_when_plus_is_not_set(self, mock_datetime):\n        mock_datetime.now.return_value = datetime(2023, 7, 19, 15, 30)\n\n        current_time = get_current_time()\n        expected_time = '15:30'\n\n        self.assertEqual(current_time, expected_time)\n\n    @patch('src.apis.times.dt.datetime')\n    def test_current_time_is_returned_correctly_when_plus_is_set(self, mock_datetime):\n        mock_datetime.now.return_value = datetime(2023, 7, 19, 15, 30)\n\n        current_time = get_current_time(plus=3)\n        expected_time = '18:30'\n\n        self.assertEqual(current_time, expected_time)", ""]}
{"filename": "recommender-back/src/tests/apis/forecast_test.py", "chunked_list": ["import unittest\nimport numpy as np\nfrom datetime import datetime\nfrom unittest.mock import MagicMock, PropertyMock, patch\nfrom src.apis.forecast import Forecast\nfrom src.apis.poi import PointOfInterest\nfrom src.services.data_fetcher import DataFetcher\n\n\nclass ForecastTest(unittest.TestCase):\n    def setUp(self):\n        self.forecast = Forecast(DataFetcher())\n        self.grid_by_datetime = MagicMock()\n        self.mock_grid = MagicMock()\n\n        self.grid_by_datetime.data = {datetime(2023, 6, 19, 5, 0): self.mock_grid}\n\n        self.mock_grid_data = PropertyMock(\n            return_value={\n                datetime(2023, 6, 19, 5, 0): {\n                    0: {\n                        \"Mean sea level pressure\": {\n                            \"units\": \"Pa\",\n                            \"data\": np.array([[10300, 10500, 10600, 10700, 10800]]),\n                        }\n                    },\n                    2: {\n                        \"2 metre temperature\": {\n                            \"units\": \"K\",\n                            \"data\": np.array([[288.2, 287.3, 283.5, 291.4, 287.7]]),\n                        },\n                        \"2 metre relative humidity\": {\n                            \"units\": \"%\",\n                            \"data\": np.array([[51, 52, 53, 54, 55]]),\n                        },\n                    },\n                    10: {\n                        \"10 metre U wind component\": {\n                            \"units\": \"m s**-1\",\n                            \"data\": np.array([[7, 9, 3, 2, 5]]),\n                        },\n                        \"10 metre V wind component\": {\n                            \"units\": \"m s**-1\",\n                            \"data\": np.array([[-1, -2, -3, 3, -2]]),\n                        },\n                        \"surface precipitation amount, rain, convective\": {\n                            \"units\": \"kg m**-2\",\n                            \"data\": np.array([[2, 3, 4, 5, 6]]),\n                        },\n                        \"Total Cloud Cover\": {\n                            \"units\": \"%\",\n                            \"data\": np.array([[23, 24, 25, 26, 27]]),\n                        },\n                    },\n                }\n            }\n        )\n\n        type(self.mock_grid).data = self.mock_grid_data\n        type(self.mock_grid).latitudes = PropertyMock(\n            return_value=np.array([[60.1, 60.2, 60.3, 60.4, 60.5]])\n        )\n        type(self.mock_grid).longitudes = PropertyMock(\n            return_value=np.array([[24.6, 24.7, 24.8, 24.9, 25.0]])\n        )\n\n    @patch(\"src.services.data_fetcher.DataFetcher.get_forecast_data\")\n    def test_data_is_updated_correctly(self, mock_download_stored_query):\n        mock_download_stored_query.return_value = self.grid_by_datetime\n\n        self.forecast.update_data()\n\n        # Check that data contains a grid object\n        self.assertIsInstance(self.forecast.data, type(self.mock_grid))\n\n        # Check that coordinates are now pairs\n        np.testing.assert_array_equal(\n            self.forecast.coordinates,\n            np.array(\n                [((60.1, 24.6), (60.2, 24.7), (60.3, 24.8), (60.4, 24.9), (60.5, 25.0))]\n            ),\n        )\n\n        # Check that valid_times returns datetime dict_keys\n        expected_valid_times = self.grid_by_datetime.data.keys()\n        self.assertEqual(self.forecast.valid_times, expected_valid_times)\n\n        # Check that all data levels match\n        expected_data_levels = []\n        for datetime_data in self.mock_grid.data.values():\n            data_levels = datetime_data.keys()\n            expected_data_levels.extend(data_levels)\n        self.assertListEqual(list(self.forecast.data_levels), expected_data_levels)\n\n    @patch(\"src.services.data_fetcher.DataFetcher.get_forecast_data\")\n    def test_get_data_returns_data_correctly(self, mock_download_stored_query):\n        mock_download_stored_query.return_value = self.grid_by_datetime\n        self.forecast.update_data()\n        data = self.forecast.get_data()\n\n        expected_data = {\n            \"2023-06-19 08:00:00\": {\n                \"(60.1, 24.6)\": [\n                    {\"Dataset\": \"Mean sea level pressure\", \"Unit\": \"Pa\", \"Data\": 10300},\n                    {\"Dataset\": \"2 metre temperature\", \"Unit\": \"K\", \"Data\": 288.2},\n                    {\"Dataset\": \"2 metre relative humidity\", \"Unit\": \"%\", \"Data\": 51},\n                    {\n                        \"Dataset\": \"10 metre U wind component\",\n                        \"Unit\": \"m s**-1\",\n                        \"Data\": 7,\n                    },\n                    {\n                        \"Dataset\": \"10 metre V wind component\",\n                        \"Unit\": \"m s**-1\",\n                        \"Data\": -1,\n                    },\n                    {\n                        \"Dataset\": \"surface precipitation amount, rain, convective\",\n                        \"Unit\": \"kg m**-2\",\n                        \"Data\": 2,\n                    },\n                    {\"Dataset\": \"Total Cloud Cover\", \"Unit\": \"%\", \"Data\": 23},\n                ],\n                \"(60.2, 24.7)\": [\n                    {\"Dataset\": \"Mean sea level pressure\", \"Unit\": \"Pa\", \"Data\": 10500},\n                    {\"Dataset\": \"2 metre temperature\", \"Unit\": \"K\", \"Data\": 287.3},\n                    {\"Dataset\": \"2 metre relative humidity\", \"Unit\": \"%\", \"Data\": 52},\n                    {\n                        \"Dataset\": \"10 metre U wind component\",\n                        \"Unit\": \"m s**-1\",\n                        \"Data\": 9,\n                    },\n                    {\n                        \"Dataset\": \"10 metre V wind component\",\n                        \"Unit\": \"m s**-1\",\n                        \"Data\": -2,\n                    },\n                    {\n                        \"Dataset\": \"surface precipitation amount, rain, convective\",\n                        \"Unit\": \"kg m**-2\",\n                        \"Data\": 3,\n                    },\n                    {\"Dataset\": \"Total Cloud Cover\", \"Unit\": \"%\", \"Data\": 24},\n                ],\n                \"(60.3, 24.8)\": [\n                    {\"Dataset\": \"Mean sea level pressure\", \"Unit\": \"Pa\", \"Data\": 10600},\n                    {\"Dataset\": \"2 metre temperature\", \"Unit\": \"K\", \"Data\": 283.5},\n                    {\"Dataset\": \"2 metre relative humidity\", \"Unit\": \"%\", \"Data\": 53},\n                    {\n                        \"Dataset\": \"10 metre U wind component\",\n                        \"Unit\": \"m s**-1\",\n                        \"Data\": 3,\n                    },\n                    {\n                        \"Dataset\": \"10 metre V wind component\",\n                        \"Unit\": \"m s**-1\",\n                        \"Data\": -3,\n                    },\n                    {\n                        \"Dataset\": \"surface precipitation amount, rain, convective\",\n                        \"Unit\": \"kg m**-2\",\n                        \"Data\": 4,\n                    },\n                    {\"Dataset\": \"Total Cloud Cover\", \"Unit\": \"%\", \"Data\": 25},\n                ],\n                \"(60.4, 24.9)\": [\n                    {\"Dataset\": \"Mean sea level pressure\", \"Unit\": \"Pa\", \"Data\": 10700},\n                    {\"Dataset\": \"2 metre temperature\", \"Unit\": \"K\", \"Data\": 291.4},\n                    {\"Dataset\": \"2 metre relative humidity\", \"Unit\": \"%\", \"Data\": 54},\n                    {\n                        \"Dataset\": \"10 metre U wind component\",\n                        \"Unit\": \"m s**-1\",\n                        \"Data\": 2,\n                    },\n                    {\n                        \"Dataset\": \"10 metre V wind component\",\n                        \"Unit\": \"m s**-1\",\n                        \"Data\": 3,\n                    },\n                    {\n                        \"Dataset\": \"surface precipitation amount, rain, convective\",\n                        \"Unit\": \"kg m**-2\",\n                        \"Data\": 5,\n                    },\n                    {\"Dataset\": \"Total Cloud Cover\", \"Unit\": \"%\", \"Data\": 26},\n                ],\n                \"(60.5, 25.0)\": [\n                    {\"Dataset\": \"Mean sea level pressure\", \"Unit\": \"Pa\", \"Data\": 10800},\n                    {\"Dataset\": \"2 metre temperature\", \"Unit\": \"K\", \"Data\": 287.7},\n                    {\"Dataset\": \"2 metre relative humidity\", \"Unit\": \"%\", \"Data\": 55},\n                    {\n                        \"Dataset\": \"10 metre U wind component\",\n                        \"Unit\": \"m s**-1\",\n                        \"Data\": 5,\n                    },\n                    {\n                        \"Dataset\": \"10 metre V wind component\",\n                        \"Unit\": \"m s**-1\",\n                        \"Data\": -2,\n                    },\n                    {\n                        \"Dataset\": \"surface precipitation amount, rain, convective\",\n                        \"Unit\": \"kg m**-2\",\n                        \"Data\": 6,\n                    },\n                    {\"Dataset\": \"Total Cloud Cover\", \"Unit\": \"%\", \"Data\": 27},\n                ],\n            }\n        }\n\n        self.assertEqual(data, expected_data)\n\n    @patch(\"src.services.data_fetcher.DataFetcher.get_forecast_data\")\n    def test_closest_poi_coordinate_data_is_fetched_correctly(\n        self, mock_download_stored_query\n    ):\n        mock_download_stored_query.return_value = self.grid_by_datetime\n        self.forecast.update_data()\n\n        poi = PointOfInterest()\n        poi.latitude = 60.15\n        poi.longitude = 24.65\n\n        aqi_data = {}\n\n        data = self.forecast.get_closest_poi_coordinates_data([poi], aqi_data)\n\n        expected_data = {\n            \"2023-06-19 08:00:00\": {\n                \"60.15, 24.65\": {\n                    \"Air temperature\": \"15.1 \u00b0C\",\n                    \"Cloud amount\": \"23 %\",\n                    \"Humidity\": \"51 %\",\n                    \"Precipitation\": \"2 mm\",\n                    \"Wind speed\": \"7.1 m/s\",\n                }\n            }\n        }\n\n        self.assertEqual(data, expected_data)\n\n    def test_get_coordinates_returns_correct_list_of_pairs(self):\n        self.forecast.coordinates = np.dstack(\n            (self.mock_grid.latitudes, self.mock_grid.longitudes)\n        )\n        coordinates = self.forecast.get_coordinates()\n        for lat, lon in zip(\n            self.mock_grid.latitudes.flatten(), self.mock_grid.longitudes.flatten()\n        ):\n            assert any(np.allclose([lat, lon], coord) for coord in coordinates)\n\n    def test_forecast_data_is_parsed_correctly(self):\n        data = [\n            {\"Dataset\": \"2 metre temperature\", \"Unit\": \"K\", \"Data\": 280.0},\n            {\"Dataset\": \"2 metre relative humidity\", \"Unit\": \"%\", \"Data\": 64.013},\n            {\"Dataset\": \"10 metre U wind component\", \"Unit\": \"m s**-1\", \"Data\": 1.223},\n            {\"Dataset\": \"10 metre V wind component\", \"Unit\": \"m s**-1\", \"Data\": -4.7},\n            {\n                \"Dataset\": \"surface precipitation amount, rain, convective\",\n                \"Unit\": \"kg m**-2\",\n                \"Data\": 0.0231,\n            },\n            {\"Dataset\": \"Total Cloud Cover\", \"Unit\": \"%\", \"Data\": 23.2},\n        ]\n\n        expected_parsed_data = {\n            \"Air temperature\": \"6.9 \u00b0C\",\n            \"Humidity\": \"64.0 %\",\n            \"Wind speed\": \"4.9 m/s\",\n            \"Precipitation\": \"0.0 mm\",\n            \"Cloud amount\": \"23.2 %\",\n        }\n\n        parsed_data = self.forecast.parse_forecast(data)\n\n        self.assertEqual(parsed_data, expected_parsed_data)", "\nclass ForecastTest(unittest.TestCase):\n    def setUp(self):\n        self.forecast = Forecast(DataFetcher())\n        self.grid_by_datetime = MagicMock()\n        self.mock_grid = MagicMock()\n\n        self.grid_by_datetime.data = {datetime(2023, 6, 19, 5, 0): self.mock_grid}\n\n        self.mock_grid_data = PropertyMock(\n            return_value={\n                datetime(2023, 6, 19, 5, 0): {\n                    0: {\n                        \"Mean sea level pressure\": {\n                            \"units\": \"Pa\",\n                            \"data\": np.array([[10300, 10500, 10600, 10700, 10800]]),\n                        }\n                    },\n                    2: {\n                        \"2 metre temperature\": {\n                            \"units\": \"K\",\n                            \"data\": np.array([[288.2, 287.3, 283.5, 291.4, 287.7]]),\n                        },\n                        \"2 metre relative humidity\": {\n                            \"units\": \"%\",\n                            \"data\": np.array([[51, 52, 53, 54, 55]]),\n                        },\n                    },\n                    10: {\n                        \"10 metre U wind component\": {\n                            \"units\": \"m s**-1\",\n                            \"data\": np.array([[7, 9, 3, 2, 5]]),\n                        },\n                        \"10 metre V wind component\": {\n                            \"units\": \"m s**-1\",\n                            \"data\": np.array([[-1, -2, -3, 3, -2]]),\n                        },\n                        \"surface precipitation amount, rain, convective\": {\n                            \"units\": \"kg m**-2\",\n                            \"data\": np.array([[2, 3, 4, 5, 6]]),\n                        },\n                        \"Total Cloud Cover\": {\n                            \"units\": \"%\",\n                            \"data\": np.array([[23, 24, 25, 26, 27]]),\n                        },\n                    },\n                }\n            }\n        )\n\n        type(self.mock_grid).data = self.mock_grid_data\n        type(self.mock_grid).latitudes = PropertyMock(\n            return_value=np.array([[60.1, 60.2, 60.3, 60.4, 60.5]])\n        )\n        type(self.mock_grid).longitudes = PropertyMock(\n            return_value=np.array([[24.6, 24.7, 24.8, 24.9, 25.0]])\n        )\n\n    @patch(\"src.services.data_fetcher.DataFetcher.get_forecast_data\")\n    def test_data_is_updated_correctly(self, mock_download_stored_query):\n        mock_download_stored_query.return_value = self.grid_by_datetime\n\n        self.forecast.update_data()\n\n        # Check that data contains a grid object\n        self.assertIsInstance(self.forecast.data, type(self.mock_grid))\n\n        # Check that coordinates are now pairs\n        np.testing.assert_array_equal(\n            self.forecast.coordinates,\n            np.array(\n                [((60.1, 24.6), (60.2, 24.7), (60.3, 24.8), (60.4, 24.9), (60.5, 25.0))]\n            ),\n        )\n\n        # Check that valid_times returns datetime dict_keys\n        expected_valid_times = self.grid_by_datetime.data.keys()\n        self.assertEqual(self.forecast.valid_times, expected_valid_times)\n\n        # Check that all data levels match\n        expected_data_levels = []\n        for datetime_data in self.mock_grid.data.values():\n            data_levels = datetime_data.keys()\n            expected_data_levels.extend(data_levels)\n        self.assertListEqual(list(self.forecast.data_levels), expected_data_levels)\n\n    @patch(\"src.services.data_fetcher.DataFetcher.get_forecast_data\")\n    def test_get_data_returns_data_correctly(self, mock_download_stored_query):\n        mock_download_stored_query.return_value = self.grid_by_datetime\n        self.forecast.update_data()\n        data = self.forecast.get_data()\n\n        expected_data = {\n            \"2023-06-19 08:00:00\": {\n                \"(60.1, 24.6)\": [\n                    {\"Dataset\": \"Mean sea level pressure\", \"Unit\": \"Pa\", \"Data\": 10300},\n                    {\"Dataset\": \"2 metre temperature\", \"Unit\": \"K\", \"Data\": 288.2},\n                    {\"Dataset\": \"2 metre relative humidity\", \"Unit\": \"%\", \"Data\": 51},\n                    {\n                        \"Dataset\": \"10 metre U wind component\",\n                        \"Unit\": \"m s**-1\",\n                        \"Data\": 7,\n                    },\n                    {\n                        \"Dataset\": \"10 metre V wind component\",\n                        \"Unit\": \"m s**-1\",\n                        \"Data\": -1,\n                    },\n                    {\n                        \"Dataset\": \"surface precipitation amount, rain, convective\",\n                        \"Unit\": \"kg m**-2\",\n                        \"Data\": 2,\n                    },\n                    {\"Dataset\": \"Total Cloud Cover\", \"Unit\": \"%\", \"Data\": 23},\n                ],\n                \"(60.2, 24.7)\": [\n                    {\"Dataset\": \"Mean sea level pressure\", \"Unit\": \"Pa\", \"Data\": 10500},\n                    {\"Dataset\": \"2 metre temperature\", \"Unit\": \"K\", \"Data\": 287.3},\n                    {\"Dataset\": \"2 metre relative humidity\", \"Unit\": \"%\", \"Data\": 52},\n                    {\n                        \"Dataset\": \"10 metre U wind component\",\n                        \"Unit\": \"m s**-1\",\n                        \"Data\": 9,\n                    },\n                    {\n                        \"Dataset\": \"10 metre V wind component\",\n                        \"Unit\": \"m s**-1\",\n                        \"Data\": -2,\n                    },\n                    {\n                        \"Dataset\": \"surface precipitation amount, rain, convective\",\n                        \"Unit\": \"kg m**-2\",\n                        \"Data\": 3,\n                    },\n                    {\"Dataset\": \"Total Cloud Cover\", \"Unit\": \"%\", \"Data\": 24},\n                ],\n                \"(60.3, 24.8)\": [\n                    {\"Dataset\": \"Mean sea level pressure\", \"Unit\": \"Pa\", \"Data\": 10600},\n                    {\"Dataset\": \"2 metre temperature\", \"Unit\": \"K\", \"Data\": 283.5},\n                    {\"Dataset\": \"2 metre relative humidity\", \"Unit\": \"%\", \"Data\": 53},\n                    {\n                        \"Dataset\": \"10 metre U wind component\",\n                        \"Unit\": \"m s**-1\",\n                        \"Data\": 3,\n                    },\n                    {\n                        \"Dataset\": \"10 metre V wind component\",\n                        \"Unit\": \"m s**-1\",\n                        \"Data\": -3,\n                    },\n                    {\n                        \"Dataset\": \"surface precipitation amount, rain, convective\",\n                        \"Unit\": \"kg m**-2\",\n                        \"Data\": 4,\n                    },\n                    {\"Dataset\": \"Total Cloud Cover\", \"Unit\": \"%\", \"Data\": 25},\n                ],\n                \"(60.4, 24.9)\": [\n                    {\"Dataset\": \"Mean sea level pressure\", \"Unit\": \"Pa\", \"Data\": 10700},\n                    {\"Dataset\": \"2 metre temperature\", \"Unit\": \"K\", \"Data\": 291.4},\n                    {\"Dataset\": \"2 metre relative humidity\", \"Unit\": \"%\", \"Data\": 54},\n                    {\n                        \"Dataset\": \"10 metre U wind component\",\n                        \"Unit\": \"m s**-1\",\n                        \"Data\": 2,\n                    },\n                    {\n                        \"Dataset\": \"10 metre V wind component\",\n                        \"Unit\": \"m s**-1\",\n                        \"Data\": 3,\n                    },\n                    {\n                        \"Dataset\": \"surface precipitation amount, rain, convective\",\n                        \"Unit\": \"kg m**-2\",\n                        \"Data\": 5,\n                    },\n                    {\"Dataset\": \"Total Cloud Cover\", \"Unit\": \"%\", \"Data\": 26},\n                ],\n                \"(60.5, 25.0)\": [\n                    {\"Dataset\": \"Mean sea level pressure\", \"Unit\": \"Pa\", \"Data\": 10800},\n                    {\"Dataset\": \"2 metre temperature\", \"Unit\": \"K\", \"Data\": 287.7},\n                    {\"Dataset\": \"2 metre relative humidity\", \"Unit\": \"%\", \"Data\": 55},\n                    {\n                        \"Dataset\": \"10 metre U wind component\",\n                        \"Unit\": \"m s**-1\",\n                        \"Data\": 5,\n                    },\n                    {\n                        \"Dataset\": \"10 metre V wind component\",\n                        \"Unit\": \"m s**-1\",\n                        \"Data\": -2,\n                    },\n                    {\n                        \"Dataset\": \"surface precipitation amount, rain, convective\",\n                        \"Unit\": \"kg m**-2\",\n                        \"Data\": 6,\n                    },\n                    {\"Dataset\": \"Total Cloud Cover\", \"Unit\": \"%\", \"Data\": 27},\n                ],\n            }\n        }\n\n        self.assertEqual(data, expected_data)\n\n    @patch(\"src.services.data_fetcher.DataFetcher.get_forecast_data\")\n    def test_closest_poi_coordinate_data_is_fetched_correctly(\n        self, mock_download_stored_query\n    ):\n        mock_download_stored_query.return_value = self.grid_by_datetime\n        self.forecast.update_data()\n\n        poi = PointOfInterest()\n        poi.latitude = 60.15\n        poi.longitude = 24.65\n\n        aqi_data = {}\n\n        data = self.forecast.get_closest_poi_coordinates_data([poi], aqi_data)\n\n        expected_data = {\n            \"2023-06-19 08:00:00\": {\n                \"60.15, 24.65\": {\n                    \"Air temperature\": \"15.1 \u00b0C\",\n                    \"Cloud amount\": \"23 %\",\n                    \"Humidity\": \"51 %\",\n                    \"Precipitation\": \"2 mm\",\n                    \"Wind speed\": \"7.1 m/s\",\n                }\n            }\n        }\n\n        self.assertEqual(data, expected_data)\n\n    def test_get_coordinates_returns_correct_list_of_pairs(self):\n        self.forecast.coordinates = np.dstack(\n            (self.mock_grid.latitudes, self.mock_grid.longitudes)\n        )\n        coordinates = self.forecast.get_coordinates()\n        for lat, lon in zip(\n            self.mock_grid.latitudes.flatten(), self.mock_grid.longitudes.flatten()\n        ):\n            assert any(np.allclose([lat, lon], coord) for coord in coordinates)\n\n    def test_forecast_data_is_parsed_correctly(self):\n        data = [\n            {\"Dataset\": \"2 metre temperature\", \"Unit\": \"K\", \"Data\": 280.0},\n            {\"Dataset\": \"2 metre relative humidity\", \"Unit\": \"%\", \"Data\": 64.013},\n            {\"Dataset\": \"10 metre U wind component\", \"Unit\": \"m s**-1\", \"Data\": 1.223},\n            {\"Dataset\": \"10 metre V wind component\", \"Unit\": \"m s**-1\", \"Data\": -4.7},\n            {\n                \"Dataset\": \"surface precipitation amount, rain, convective\",\n                \"Unit\": \"kg m**-2\",\n                \"Data\": 0.0231,\n            },\n            {\"Dataset\": \"Total Cloud Cover\", \"Unit\": \"%\", \"Data\": 23.2},\n        ]\n\n        expected_parsed_data = {\n            \"Air temperature\": \"6.9 \u00b0C\",\n            \"Humidity\": \"64.0 %\",\n            \"Wind speed\": \"4.9 m/s\",\n            \"Precipitation\": \"0.0 mm\",\n            \"Cloud amount\": \"23.2 %\",\n        }\n\n        parsed_data = self.forecast.parse_forecast(data)\n\n        self.assertEqual(parsed_data, expected_parsed_data)", ""]}
{"filename": "recommender-back/src/tests/apis/current_test.py", "chunked_list": ["import unittest\nfrom unittest import mock\nfrom unittest.mock import MagicMock\nfrom src.app import app\nfrom src.apis.poi import PointOfInterest\nfrom src.apis.current import Current\nfrom src.services.data_fetcher import DataFetcher\n\n\nclass CurrentTest(unittest.TestCase):\n    def setUp(self):\n        app.testing = True\n        self.client = app.test_client()\n        self.item = PointOfInterest(longitude=24.65, latitude=60.15)\n        self.fetcher = DataFetcher()\n        self.expected_item = {\n            'Air temperature': '10.5 \u00b0C',\n            'Wind speed': '10.0 m/s',\n            'Precipitation': '10.0 %',\n            'Cloud amount': '5.0 %',\n            'Humidity': '60.0 %',\n            'Air quality': '1.0 AQI'\n        }\n\n    def test_get_current_weather(self):\n        with mock.patch(\n            \"src.services.data_fetcher.DataFetcher.get_current_weather_data\"\n        ) as mock_download:\n            mock_response = MagicMock()\n            mock_response.location_metadata = {\n                'station1': {'latitude': 60.1, 'longitude': 24.6},\n                'station2': {'latitude': 60.2, 'longitude': 24.7},\n            }\n            mock_response.data = {\n                'station1': {\n                    't2m': {'values': [10.5]},\n                    'ws_10min': {'values': ['nan']},\n                    'ri_10min': {'values': ['nan']},\n                    'n_man': {'values': ['nan']},\n                    'rh': {'values': ['nan']},\n                    'AQINDEX_PT1H_avg': {'values': ['nan']}\n                },\n                'station2': {\n                    't2m': {'values': [11.2]},\n                    'ws_10min': {'values': ['nan']},\n                    'ri_10min': {'values': ['nan']},\n                    'n_man': {'values': ['nan']},\n                    'rh': {'values': ['nan']},\n                    'AQINDEX_PT1H_avg': {'values': ['nan']}\n                }\n            }\n            mock_download.return_value = mock_response\n            self.current = Current(self.fetcher)\n            expected_data = {\n                'station1': {\n                    'Air temperature': '10.5 \u00b0C',\n                    'Latitude': 60.1,\n                    'Longitude': 24.6,\n                },\n                'station2': {\n                    'Air temperature': '11.2 \u00b0C',\n                    'Latitude': 60.2,\n                    'Longitude': 24.7,\n                },\n            }\n            self.assertEqual(self.current.weather, expected_data)\n\n    def test_weather_warning(self):\n        self.current = Current(self.fetcher)\n        self.current.weather = {\n            'station1': {\n                'Air temperature': '10.5 \u00b0C',\n                'Wind speed': '18.0 m/s',\n                'Precipitation': '10.0 %'\n            },\n            'station2': {\n                'Air temperature': '10.5 \u00b0C',\n                'Wind speed': '10.0 m/s',\n                'Precipitation': '10.0 %'\n            }\n        }\n        self.assertTrue(self.current.get_current_weather_warning('station1'))\n        self.assertFalse(self.current.get_current_weather_warning('station2'))\n\n    def test_find_nearest_stations_weather_data(self):\n        self.current = Current(self.fetcher)\n        self.current.weather = {\n            'station1': {\n                'Latitude': 60.1,\n                'Longitude': 24.6,\n                'Air temperature': '10.5 \u00b0C',\n                'Wind speed': '10.0 m/s',\n                'Precipitation': '10.0 %',\n                'Cloud amount': '5.0 %',\n                'Humidity': '60.0 %',\n                'Air quality': '1.0 AQI'\n            },\n            'station2': {\n                'Latitude': 60.5,\n                'Longitude': 26.0,\n                'Air temperature': '11.2 \u00b0C',\n                'Wind speed': '10.0 m/s',\n                'Precipitation': '10.0 %',\n                'Cloud amount': '5.0 %',\n                'Humidity': '60.0 %',\n                'Air quality': '1.0 AQI'\n            }\n        }\n\n        self.current.find_nearest_stations_weather_data(self.item)\n        self.assertEqual(self.item.weather[\"Current\"], self.expected_item)\n\n    def test_find_nearest_stations_weather_data_with_missing_fields(self):\n        self.current = Current(self.fetcher)\n        self.current.weather = {\n            'station1': {\n                'Latitude': 60.1,\n                'Longitude': 24.6,\n                'Air temperature': '10.5 \u00b0C',\n                'Precipitation': '10.0 %',\n                'Cloud amount': '5.0 %',\n                'Humidity': '60.0 %',\n                'Air quality': '1.0 AQI'\n            },\n            'station2': {\n                'Latitude': 60.5,\n                'Longitude': 26.0,\n                'Wind speed': '10.0 m/s',\n                'Precipitation': '10.0 %',\n                'Cloud amount': '5.0 %',\n                'Humidity': '60.0 %',\n                'Air quality': '1.0 AQI'\n            }\n        }\n\n        self.current.find_nearest_stations_weather_data(self.item)\n        self.assertEqual(self.item.weather[\"Current\"], self.expected_item)", "\nclass CurrentTest(unittest.TestCase):\n    def setUp(self):\n        app.testing = True\n        self.client = app.test_client()\n        self.item = PointOfInterest(longitude=24.65, latitude=60.15)\n        self.fetcher = DataFetcher()\n        self.expected_item = {\n            'Air temperature': '10.5 \u00b0C',\n            'Wind speed': '10.0 m/s',\n            'Precipitation': '10.0 %',\n            'Cloud amount': '5.0 %',\n            'Humidity': '60.0 %',\n            'Air quality': '1.0 AQI'\n        }\n\n    def test_get_current_weather(self):\n        with mock.patch(\n            \"src.services.data_fetcher.DataFetcher.get_current_weather_data\"\n        ) as mock_download:\n            mock_response = MagicMock()\n            mock_response.location_metadata = {\n                'station1': {'latitude': 60.1, 'longitude': 24.6},\n                'station2': {'latitude': 60.2, 'longitude': 24.7},\n            }\n            mock_response.data = {\n                'station1': {\n                    't2m': {'values': [10.5]},\n                    'ws_10min': {'values': ['nan']},\n                    'ri_10min': {'values': ['nan']},\n                    'n_man': {'values': ['nan']},\n                    'rh': {'values': ['nan']},\n                    'AQINDEX_PT1H_avg': {'values': ['nan']}\n                },\n                'station2': {\n                    't2m': {'values': [11.2]},\n                    'ws_10min': {'values': ['nan']},\n                    'ri_10min': {'values': ['nan']},\n                    'n_man': {'values': ['nan']},\n                    'rh': {'values': ['nan']},\n                    'AQINDEX_PT1H_avg': {'values': ['nan']}\n                }\n            }\n            mock_download.return_value = mock_response\n            self.current = Current(self.fetcher)\n            expected_data = {\n                'station1': {\n                    'Air temperature': '10.5 \u00b0C',\n                    'Latitude': 60.1,\n                    'Longitude': 24.6,\n                },\n                'station2': {\n                    'Air temperature': '11.2 \u00b0C',\n                    'Latitude': 60.2,\n                    'Longitude': 24.7,\n                },\n            }\n            self.assertEqual(self.current.weather, expected_data)\n\n    def test_weather_warning(self):\n        self.current = Current(self.fetcher)\n        self.current.weather = {\n            'station1': {\n                'Air temperature': '10.5 \u00b0C',\n                'Wind speed': '18.0 m/s',\n                'Precipitation': '10.0 %'\n            },\n            'station2': {\n                'Air temperature': '10.5 \u00b0C',\n                'Wind speed': '10.0 m/s',\n                'Precipitation': '10.0 %'\n            }\n        }\n        self.assertTrue(self.current.get_current_weather_warning('station1'))\n        self.assertFalse(self.current.get_current_weather_warning('station2'))\n\n    def test_find_nearest_stations_weather_data(self):\n        self.current = Current(self.fetcher)\n        self.current.weather = {\n            'station1': {\n                'Latitude': 60.1,\n                'Longitude': 24.6,\n                'Air temperature': '10.5 \u00b0C',\n                'Wind speed': '10.0 m/s',\n                'Precipitation': '10.0 %',\n                'Cloud amount': '5.0 %',\n                'Humidity': '60.0 %',\n                'Air quality': '1.0 AQI'\n            },\n            'station2': {\n                'Latitude': 60.5,\n                'Longitude': 26.0,\n                'Air temperature': '11.2 \u00b0C',\n                'Wind speed': '10.0 m/s',\n                'Precipitation': '10.0 %',\n                'Cloud amount': '5.0 %',\n                'Humidity': '60.0 %',\n                'Air quality': '1.0 AQI'\n            }\n        }\n\n        self.current.find_nearest_stations_weather_data(self.item)\n        self.assertEqual(self.item.weather[\"Current\"], self.expected_item)\n\n    def test_find_nearest_stations_weather_data_with_missing_fields(self):\n        self.current = Current(self.fetcher)\n        self.current.weather = {\n            'station1': {\n                'Latitude': 60.1,\n                'Longitude': 24.6,\n                'Air temperature': '10.5 \u00b0C',\n                'Precipitation': '10.0 %',\n                'Cloud amount': '5.0 %',\n                'Humidity': '60.0 %',\n                'Air quality': '1.0 AQI'\n            },\n            'station2': {\n                'Latitude': 60.5,\n                'Longitude': 26.0,\n                'Wind speed': '10.0 m/s',\n                'Precipitation': '10.0 %',\n                'Cloud amount': '5.0 %',\n                'Humidity': '60.0 %',\n                'Air quality': '1.0 AQI'\n            }\n        }\n\n        self.current.find_nearest_stations_weather_data(self.item)\n        self.assertEqual(self.item.weather[\"Current\"], self.expected_item)", ""]}
{"filename": "recommender-back/src/tests/apis/manager_test.py", "chunked_list": ["import unittest\nfrom unittest.mock import patch\nfrom src.db.db import get_collection\nfrom src.apis.manager import get_pois, find_nearest_coordinate_forecast_data, get_pois_as_json\nfrom src.apis.poi import PointOfInterest\nfrom src.app import app\nfrom src.tests.mock_data import MOCK_POIS\nimport json\n\nclass TestManger(unittest.TestCase):\n    def setUp(self):\n        self.client = app.test_client()\n        self.fore = {\n            \"2023-07-20 12:00:00\": {\n                \"60.201231, 24.973478\": {\n                    \"Air temperature\": \"20.5 \u00b0C\",\n                    \"Humidity\": \"58.2 %\",\n                    \"Wind speed\": \"3.8 m/s\",\n                    \"Precipitation\": \"0.0 mm\",\n                    \"Cloud amount\": \"20.3 %\"\n                },\n                \"60.1998, 24.968672\": {\n                    \"Air temperature\": \"19.8 \u00b0C\",\n                    \"Humidity\": \"61.4 %\",\n                    \"Wind speed\": \"4.1 m/s\",\n                    \"Precipitation\": \"0.0 mm\",\n                    \"Cloud amount\": \"15.7 %\"\n                },\n                \"60.189543, 24.921326\": {\n                    \"Air temperature\": \"21.2 \u00b0C\",\n                    \"Humidity\": \"54.6 %\",\n                    \"Wind speed\": \"3.4 m/s\",\n                    \"Precipitation\": \"0.0 mm\",\n                    \"Cloud amount\": \"24.9 %\"\n                }\n            },\n            \"2023-07-20 13:30:00\": {\n                \"60.201231, 24.973478\": {\n                    \"Air temperature\": \"21.8 \u00b0C\",\n                    \"Humidity\": \"52.9 %\",\n                    \"Wind speed\": \"4.5 m/s\",\n                    \"Precipitation\": \"0.0 mm\",\n                    \"Cloud amount\": \"12.1 %\"\n                },\n                \"60.1998, 24.968672\": {\n                    \"Air temperature\": \"20.3 \u00b0C\",\n                    \"Humidity\": \"59.0 %\",\n                    \"Wind speed\": \"4.0 m/s\",\n                    \"Precipitation\": \"0.0 mm\",\n                    \"Cloud amount\": \"18.5 %\"\n                },\n                \"60.189543, 24.921326\": {\n                    \"Air temperature\": \"22.0 \u00b0C\",\n                    \"Humidity\": \"50.3 %\",\n                    \"Wind speed\": \"3.2 m/s\",\n                    \"Precipitation\": \"0.0 mm\",\n                    \"Cloud amount\": \"29.4 %\"\n                }\n            },\n            \"2023-07-20 15:15:00\": {\n                \"60.201231, 24.973478\": {\n                    \"Air temperature\": \"22.5 \u00b0C\",\n                    \"Humidity\": \"49.1 %\",\n                    \"Wind speed\": \"4.8 m/s\",\n                    \"Precipitation\": \"0.0 mm\",\n                    \"Cloud amount\": \"8.6 %\"\n                },\n                \"60.1998, 24.968672\": {\n                    \"Air temperature\": \"20.8 \u00b0C\",\n                    \"Humidity\": \"56.7 %\",\n                    \"Wind speed\": \"3.9 m/s\",\n                    \"Precipitation\": \"0.0 mm\",\n                    \"Cloud amount\": \"16.9 %\"\n                },\n                \"60.189543, 24.921326\": {\n                    \"Air temperature\": \"22.8 \u00b0C\",\n                    \"Humidity\": \"47.6 %\",\n                    \"Wind speed\": \"3.7 m/s\",\n                    \"Precipitation\": \"0.0 mm\",\n                    \"Cloud amount\": \"34.2 %\"\n                }\n            }\n        }\n\n    def test_get_simulated_pois_as_json(self):\n        params = {\n            \"air_temperature\": 10,\n            \"wind_speed\": 5,\n            \"humidity\": 10,\n            \"precipitation\": 5,\n            \"cloud_amount\": 10,\n            \"air_quality\": 2,\n            \"current_time\": '16:00',\n            'sunrise': '6:00',\n            'sunset': '22:00',\n        }\n\n        response = self.client.post(\n            '/api/simulator', \n            json=params,\n        )\n\n        data = json.loads(response.text)\n        tested = data[0]['weather']['Weather']\n        del tested['Score']\n        equals = {'Air temperature': '10 \u00b0C',\n                'Wind speed': '5 m/s',\n                'Humidity': '10 %',\n                'Precipitation': '5 mm',\n                'Cloud amount': '10 %',\n                'Air quality': 2}\n        self.assertEqual(tested, equals)\n\n    @patch('src.db.db.get_collection')\n    def test_get_pois_returns_list(self, mock_get_collection):\n        mock_get_collection.return_value.find.return_value = MOCK_POIS\n        \n        result = get_pois()\n        \n        self.assertIsInstance(result, list)\n\n    @patch('src.db.db.get_collection')\n    def test_get_pois_contains_items(self, mock_get_collection):\n        mock_get_collection.return_value.find.return_value = MOCK_POIS\n        result = get_pois()\n        self.assertTrue(len(result) > 0)\n\n    def test_get_pois_all_items_are_point_of_interest_objects(self):\n        result = get_pois()\n        for poi in result:\n            self.assertIsInstance(poi, PointOfInterest)\n\n    def test_get_pois_structure(self):\n        result = get_pois()\n        for poi in result:\n            self.assertTrue(hasattr(poi, 'name'))\n            self.assertTrue(hasattr(poi, 'latitude'))\n            self.assertTrue(hasattr(poi, 'longitude'))\n            self.assertTrue(hasattr(poi, 'not_accessible_for'))\n            self.assertTrue(hasattr(poi, 'categories'))\n\n    def test_get_pois_coordinates_valid(self):\n        result = get_pois()\n        for poi in result:\n            self.assertIsInstance(poi.latitude, float)\n            self.assertIsInstance(poi.longitude, float)\n\n    def test_find_nearest_coordinates(self):\n        pois = get_pois()\n        for onepoi in pois:\n            res = find_nearest_coordinate_forecast_data(onepoi, self.fore)\n            self.assertEqual(len(res.weather), 3)\n            break", "\nclass TestManger(unittest.TestCase):\n    def setUp(self):\n        self.client = app.test_client()\n        self.fore = {\n            \"2023-07-20 12:00:00\": {\n                \"60.201231, 24.973478\": {\n                    \"Air temperature\": \"20.5 \u00b0C\",\n                    \"Humidity\": \"58.2 %\",\n                    \"Wind speed\": \"3.8 m/s\",\n                    \"Precipitation\": \"0.0 mm\",\n                    \"Cloud amount\": \"20.3 %\"\n                },\n                \"60.1998, 24.968672\": {\n                    \"Air temperature\": \"19.8 \u00b0C\",\n                    \"Humidity\": \"61.4 %\",\n                    \"Wind speed\": \"4.1 m/s\",\n                    \"Precipitation\": \"0.0 mm\",\n                    \"Cloud amount\": \"15.7 %\"\n                },\n                \"60.189543, 24.921326\": {\n                    \"Air temperature\": \"21.2 \u00b0C\",\n                    \"Humidity\": \"54.6 %\",\n                    \"Wind speed\": \"3.4 m/s\",\n                    \"Precipitation\": \"0.0 mm\",\n                    \"Cloud amount\": \"24.9 %\"\n                }\n            },\n            \"2023-07-20 13:30:00\": {\n                \"60.201231, 24.973478\": {\n                    \"Air temperature\": \"21.8 \u00b0C\",\n                    \"Humidity\": \"52.9 %\",\n                    \"Wind speed\": \"4.5 m/s\",\n                    \"Precipitation\": \"0.0 mm\",\n                    \"Cloud amount\": \"12.1 %\"\n                },\n                \"60.1998, 24.968672\": {\n                    \"Air temperature\": \"20.3 \u00b0C\",\n                    \"Humidity\": \"59.0 %\",\n                    \"Wind speed\": \"4.0 m/s\",\n                    \"Precipitation\": \"0.0 mm\",\n                    \"Cloud amount\": \"18.5 %\"\n                },\n                \"60.189543, 24.921326\": {\n                    \"Air temperature\": \"22.0 \u00b0C\",\n                    \"Humidity\": \"50.3 %\",\n                    \"Wind speed\": \"3.2 m/s\",\n                    \"Precipitation\": \"0.0 mm\",\n                    \"Cloud amount\": \"29.4 %\"\n                }\n            },\n            \"2023-07-20 15:15:00\": {\n                \"60.201231, 24.973478\": {\n                    \"Air temperature\": \"22.5 \u00b0C\",\n                    \"Humidity\": \"49.1 %\",\n                    \"Wind speed\": \"4.8 m/s\",\n                    \"Precipitation\": \"0.0 mm\",\n                    \"Cloud amount\": \"8.6 %\"\n                },\n                \"60.1998, 24.968672\": {\n                    \"Air temperature\": \"20.8 \u00b0C\",\n                    \"Humidity\": \"56.7 %\",\n                    \"Wind speed\": \"3.9 m/s\",\n                    \"Precipitation\": \"0.0 mm\",\n                    \"Cloud amount\": \"16.9 %\"\n                },\n                \"60.189543, 24.921326\": {\n                    \"Air temperature\": \"22.8 \u00b0C\",\n                    \"Humidity\": \"47.6 %\",\n                    \"Wind speed\": \"3.7 m/s\",\n                    \"Precipitation\": \"0.0 mm\",\n                    \"Cloud amount\": \"34.2 %\"\n                }\n            }\n        }\n\n    def test_get_simulated_pois_as_json(self):\n        params = {\n            \"air_temperature\": 10,\n            \"wind_speed\": 5,\n            \"humidity\": 10,\n            \"precipitation\": 5,\n            \"cloud_amount\": 10,\n            \"air_quality\": 2,\n            \"current_time\": '16:00',\n            'sunrise': '6:00',\n            'sunset': '22:00',\n        }\n\n        response = self.client.post(\n            '/api/simulator', \n            json=params,\n        )\n\n        data = json.loads(response.text)\n        tested = data[0]['weather']['Weather']\n        del tested['Score']\n        equals = {'Air temperature': '10 \u00b0C',\n                'Wind speed': '5 m/s',\n                'Humidity': '10 %',\n                'Precipitation': '5 mm',\n                'Cloud amount': '10 %',\n                'Air quality': 2}\n        self.assertEqual(tested, equals)\n\n    @patch('src.db.db.get_collection')\n    def test_get_pois_returns_list(self, mock_get_collection):\n        mock_get_collection.return_value.find.return_value = MOCK_POIS\n        \n        result = get_pois()\n        \n        self.assertIsInstance(result, list)\n\n    @patch('src.db.db.get_collection')\n    def test_get_pois_contains_items(self, mock_get_collection):\n        mock_get_collection.return_value.find.return_value = MOCK_POIS\n        result = get_pois()\n        self.assertTrue(len(result) > 0)\n\n    def test_get_pois_all_items_are_point_of_interest_objects(self):\n        result = get_pois()\n        for poi in result:\n            self.assertIsInstance(poi, PointOfInterest)\n\n    def test_get_pois_structure(self):\n        result = get_pois()\n        for poi in result:\n            self.assertTrue(hasattr(poi, 'name'))\n            self.assertTrue(hasattr(poi, 'latitude'))\n            self.assertTrue(hasattr(poi, 'longitude'))\n            self.assertTrue(hasattr(poi, 'not_accessible_for'))\n            self.assertTrue(hasattr(poi, 'categories'))\n\n    def test_get_pois_coordinates_valid(self):\n        result = get_pois()\n        for poi in result:\n            self.assertIsInstance(poi.latitude, float)\n            self.assertIsInstance(poi.longitude, float)\n\n    def test_find_nearest_coordinates(self):\n        pois = get_pois()\n        for onepoi in pois:\n            res = find_nearest_coordinate_forecast_data(onepoi, self.fore)\n            self.assertEqual(len(res.weather), 3)\n            break", "\nif __name__ == '__main__':\n    unittest.main()\n"]}
{"filename": "recommender-back/src/tests/db/models_test.py", "chunked_list": ["import unittest\nfrom src.db.db import get_db\nfrom src.db.models import Poi\n\nclass TestManger(unittest.TestCase):\n    def test_saving_pois(self):\n        db = get_db()\n        collection = db['pois']\n        collection.delete_many({})\n        poi = Poi(\"Test POI\", \"21\", \"61\", [], [{\"category\": \"test\"}])\n        poi.save()\n        self.assertEqual(len(poi.get_all()), 1)\n        collection.delete_many({})", "\nif __name__ == '__main__':\n    unittest.main()\n"]}
{"filename": "recommender-back/src/tests/db/db_test.py", "chunked_list": ["import unittest\nfrom src.db.db import get_db, get_collection\n\nclass TestManger(unittest.TestCase):\n    def test_getting_db(self):\n        db = get_db()\n        self.assertEqual(db.name, \"poidata\") \n\n\n    def test_getting_collection(self):\n        collection = get_collection()\n        collection.delete_many({})\n        self.assertEqual(collection.count_documents({}), 0)", "\nif __name__ == '__main__':\n    unittest.main()\n"]}
{"filename": "recommender-back/src/tests/services/data_fetcher_test.py", "chunked_list": ["from unittest import TestCase\nfrom unittest.mock import patch\nfrom src.services.data_fetcher import DataFetcher\n\n\nclass TestDataFetcher(TestCase):\n    def setUp(self):\n        self.fetcher = DataFetcher()\n        self.start = \"start\"\n        self.end = \"end\"\n        self.bbox = \"bbox\"\n        self.timestep = \"timestep\"\n        self.parameters = \"parameters\"\n        self.timeseries = \"timeseries\"\n\n    @patch(\"src.services.data_fetcher.download_stored_query\")\n    def test_get_forecast_data(self, mock_download):\n        mock_download.return_value = \"mock forecast data\"\n\n        result = self.fetcher.get_forecast_data(\n            self.start, self.end, self.bbox, self.timestep, self.parameters\n        )\n\n        mock_download.assert_called_once_with(\n            \"fmi::forecast::harmonie::surface::grid\",\n            args=[\n                f\"starttime={self.start}\",\n                f\"endtime={self.end}\",\n                f\"bbox={self.bbox}\",\n                f\"timestep={self.timestep}\",\n                f\"parameters={self.parameters}\",\n            ],\n        )\n        self.assertEqual(result, \"mock forecast data\")\n\n    @patch(\"src.services.data_fetcher.download_stored_query\")\n    def test_get_current_weather_data(self, mock_download):\n        mock_download.return_value = \"mock weather data\"\n\n        result = self.fetcher.get_current_weather_data(self.bbox, self.timeseries)\n\n        mock_download.assert_called_once_with(\n            \"fmi::observations::weather::multipointcoverage\",\n            args=[f\"bbox={self.bbox}\", f\"timeseries={self.timeseries}\"],\n        )\n        self.assertEqual(result, \"mock weather data\")", ""]}
{"filename": "recommender-back/src/db/models.py", "chunked_list": ["from .db import get_db\n\ndb = get_db()\npois_collection = db['pois']  \n\nclass Poi:\n    def __init__(self, name, latitude, longitude, accessibility, categories):\n        self.name = name\n        self.latitude = latitude\n        self.longitude = longitude\n        self.accessibility = accessibility\n        self.categories = categories\n\n    def save(self):\n        pois_collection.insert_one({\n            'name': self.name,\n            'latitude': self.latitude,\n            'longitude': self.longitude,\n            'not_accessible_for': self.accessibility,\n            'categories': self.categories\n        })\n\n    def get_all(test=False):\n        all_documents = pois_collection.find()\n        pois = list(all_documents)\n        return pois", ""]}
{"filename": "recommender-back/src/db/db.py", "chunked_list": ["import os\nfrom dotenv import load_dotenv\nfrom pymongo import MongoClient\n\nload_dotenv()\nif 'MONGO_URI' in os.environ:\n        mongo_uri = os.environ['MONGO_URI']\nelse:\n    mongo_uri = os.environ.get('DEVELOPMENT_DB_URI')\nprint(' * Connecting to MongoDB')", "print(' * Connecting to MongoDB')\n\ndef get_db():\n    try:\n        client = MongoClient(mongo_uri)\n        db = client.get_database('poidata')\n        return db\n        \n    except Exception as e:\n        print(' * Error connecting to MongoDB:', str(e))\n        return None", "    \ndef get_collection():\n    try:\n        db = get_db()\n        collection=db['pois']\n        return collection          \n    except Exception as e:\n        print(' * Error getting collection in MongoDB:', str(e))\n        return None\n", "\n"]}
{"filename": "recommender-back/src/static/scoring_plot_local.py", "chunked_list": ["# File to easily test the scoring without deps to anything\n# Includes basic plot structure\n\n# This file contains duplicated code of poi.py\n\nimport pandas as pd\nimport seaborn as sns\nimport math as math\nfrom matplotlib import pyplot as plt\n", "from matplotlib import pyplot as plt\n\n# Outdoor\ndef get_out_score(temperature, wind_speed, humidity, precipitation, clouds, sunrise, sunset, cur_time):\n    # Weights\n    precipitation_weight = 0.35\n    temperature_weight = 0.3\n    clouds_weight = 0.04\n    wind_speed_weight = 0.04\n    humidity_weight = 0.02\n\n\n    # Scoring\n    score = precipitation_weight * math.exp(-precipitation)\n    temperature_comp = 0\n    if 20 <= temperature <= 25:\n        temperature_comp = 1\n    elif temperature < 20:\n        temperature_comp = math.exp(-0.1 * (20 - temperature))\n    else:\n        temperature_comp = math.exp(0.1 * (25 - temperature))\n    score += temperature_weight * temperature_comp\n    if sunrise <= cur_time <= sunset:\n        day_time_weight = 0.2\n        score += day_time_weight\n    # score += air_weight * math.exp(0.5 * 1- air)\n    score += clouds_weight * math.exp(-clouds)\n    score += wind_speed_weight * math.exp(-wind_speed)\n    if 0.4 <= humidity <= 0.55:\n        humidity_weight = 0.02\n\n        score += humidity_weight\n    return score", "\n# Indoor\ndef get_in_score(temperature, wind_speed, humidity, precipitation, clouds, sunrise, sunset, cur_time):\n    # Weights\n    precipitation_weight = 0.7\n    temperature_weight = 0.1\n    clouds_weight = 0.04\n    wind_speed_weight = 0.03\n    # Scoring\n    score = precipitation_weight * (1 - math.exp(-10 * precipitation))\n    temperature_comp = 0\n    if 20 <= temperature <= 25:\n        temperature_comp = 0\n    elif temperature < 20:\n        temperature_comp = 1 - math.exp(-0.04 * (20 - temperature))\n    else:\n        temperature_comp = 1 - math.exp(0.2 * (25 - temperature))\n    score += temperature_weight * temperature_comp\n    if sunrise > cur_time or cur_time > sunset:\n        day_time_weight = 0.06\n        score += day_time_weight\n    # score += air_weight * (1 - math.exp(0.5 * 1- air))\n    score += clouds_weight * (1 - math.exp(-3 * clouds))\n    score += wind_speed_weight * (1 - math.exp(-0.3 * wind_speed))\n    if humidity < 0.4 or humidity > 0.55:\n        humidity_weight = 0.02\n\n        score += humidity_weight\n    return score", "\ndef build_chart(var_vals, scores, label):\n    var_df= pd.DataFrame({\"var\" : var_vals, \"score\" : scores})\n    fig, ax= plt.subplots(figsize=(4, 4))\n    sns.lineplot(data=var_df, x=\"var\", y=\"score\", ax=ax)\n    ax.set_xlabel(label, fontsize=15)\n    ax.set_ylabel(\"score\", fontsize=15)\n    ax.tick_params(labelsize=15)\n    plt.tight_layout()\n    plt.show()", "\n\nif __name__ == \"__main__\":\n\n    print('Outdoor')\n    print(\"min\", get_out_score(-40, 20, 0.9, 20, 0.9,\"06:00\", '20:00', '23:00'))\n    # expected 0.017006412949531466\n    print(\"max\", get_out_score(24, 0, 0.5, 0, 0, '06:00' , '20:00', '10:00'))\n    # expected 1\n    print('Indoor')\n    print(\"min\", get_in_score(24, 0, 0.5, 0, 0, '06:00' , '20:00', '10:00'))\n    # expected 0 \n    print(\"max\", get_in_score(-40, 20, 0.9, 20, 0.9,\"06:00\", '20:00', '23:00'))\n    # expected 0.9813988574343381\n    # Not reaching the wanted scores bcs AQI still missing\n\n    # Plot for temp outdoor\n    var_vals= [*range(-40, 40)]\n    scores = [get_out_score(var, 0, 0.5, 0, 0,\"06:00\", '20:00', '23:00') for var in var_vals]\n    build_chart(var_vals, scores, \"temperature\")", ""]}
{"filename": "recommender-back/src/services/poi_init.py", "chunked_list": ["import os\nimport json\nimport copy\nfrom ..apis.poi import PointOfInterest\nfrom ..db.models import Poi\n\ndef init_pois():\n    '''\n    Retrieves all points of interest (POIs) from JSON files and merges them together.\n\n    Args:\n        category (list): List of categories of POIs to retrieve. If None, default categories will be used.\n\n    Returns:\n        list: List of all POIs.\n\n    '''\n    try:\n        print(' * Initiliazing POIs to MongoDB')\n        file_path = os.path.join(os.path.dirname(__file__), '..', 'static', 'pois.json')\n        with open(file_path, 'r', encoding='utf-8') as file:\n            data = json.load(file)\n            pois = filter_duplicates(iterate_items(data, []))\n            for poi in pois:\n                Poi.save(Poi(poi.name, poi.latitude, poi.longitude, poi.not_accessible_for, poi.categories))\n        return pois\n    except FileNotFoundError:\n        print(' * Error: pois.json not found.')\n    except Exception as e:\n        print(f' * Error occurred while initializing POIs: {e}')", "\ndef filter_duplicates(pois):\n    uniques = {}\n    for poi in pois:\n        name = poi.name\n        if name not in uniques:\n            uniques[name] = poi\n    return list(uniques.values())\n\ndef iterate_items(data, categories):\n    '''\n    Recursively iterates over the data and constructs a list of PointOfInterest objects.\n\n    Args:\n        data (list or dict): The data to iterate over.\n        categories (list): The list of categories associated with the current data level.\n\n    Returns:\n        list: List of PointOfInterest objects constructed from the data.\n\n    '''\n    pois = []\n    if isinstance(data, list):\n        for item in data:\n            name = item['name']['fi']\n            longitude = item['location']['coordinates'][0]\n            latitude = item['location']['coordinates'][1]\n            not_accessible_for = list(item['accessibility_shortcoming_count'].keys())\n            poi = PointOfInterest(name, latitude, longitude,\n                                  not_accessible_for, categories)\n            pois.append(poi)\n    else:\n        for key, item in data.items():\n            categories.append(key)\n            pois.extend(iterate_items(item, copy.deepcopy(categories)))\n            categories.pop()\n    return pois", "\ndef iterate_items(data, categories):\n    '''\n    Recursively iterates over the data and constructs a list of PointOfInterest objects.\n\n    Args:\n        data (list or dict): The data to iterate over.\n        categories (list): The list of categories associated with the current data level.\n\n    Returns:\n        list: List of PointOfInterest objects constructed from the data.\n\n    '''\n    pois = []\n    if isinstance(data, list):\n        for item in data:\n            name = item['name']['fi']\n            longitude = item['location']['coordinates'][0]\n            latitude = item['location']['coordinates'][1]\n            not_accessible_for = list(item['accessibility_shortcoming_count'].keys())\n            poi = PointOfInterest(name, latitude, longitude,\n                                  not_accessible_for, categories)\n            pois.append(poi)\n    else:\n        for key, item in data.items():\n            categories.append(key)\n            pois.extend(iterate_items(item, copy.deepcopy(categories)))\n            categories.pop()\n    return pois", ""]}
{"filename": "recommender-back/src/services/data_fetcher.py", "chunked_list": ["'''\nThis module provides functionality for fetching forecast and current weather data\nusing the Finnish Meteorological Institute's open data interface.\n'''\nfrom typing import Dict\nfrom fmiopendata.wfs import download_stored_query\n\n\nclass DataFetcher:\n    '''\n    This class provides methods for fetching forecast and current weather data\n    using the Finnish Meteorological Institute's open data interface.\n    '''\n\n    def get_forecast_data(\n        self, start: str, end: str, bbox: str, timestep: int, parameters: str\n    ) -> Dict:\n        '''\n        Fetches forecast data for a specified time range, area, timestep and parameters.\n        Args:\n            start (str): The start time of the forecast period in ISO format.\n            end (str): The end time of the forecast period in ISO format.\n            bbox (str): Bounding box for the forecast area in format 'xmin,ymin,xmax,ymax'.\n            timestep (int): The timestep in minutes for the forecast data.\n            parameters (str): Comma-separated list of parameters to fetch.\n        Returns:\n            dict: A dictionary containing the forecast data.\n        '''\n        return download_stored_query(\n            'fmi::forecast::harmonie::surface::grid',\n            args=[\n                f'starttime={start}',\n                f'endtime={end}',\n                f'bbox={bbox}',\n                f'timestep={timestep}',\n                f'parameters={parameters}',\n            ],\n        )\n\n    def get_current_weather_data(self, bbox: str, timeseries: bool) -> Dict:\n        '''\n        Fetches current weather data for a specified area and timeseries.\n        Args:\n            bbox (str): Bounding box for the forecast area in format 'xmin,ymin,xmax,ymax'.\n            timeseries (bool): Whether to fetch data as a time series or not.\n        Returns:\n            dict: A dictionary containing the current weather data.\n        '''\n        return download_stored_query(\n            'fmi::observations::weather::multipointcoverage',\n            args=[\n                f'bbox={bbox}',\n                f'timeseries={timeseries}',\n            ],\n        )\n\n    def get_current_air_quality_data(self, bbox: str, timeseries: bool, parameters: str) -> Dict:\n        '''\n        Fetches current weather data for a specified area and timeseries.\n        Args:\n            bbox (str): Bounding box for the forecast area in format 'xmin,ymin,xmax,ymax'.\n            timeseries (bool): Whether to fetch data as a time series or not.\n        Returns:\n            dict: A dictionary containing the current weather data.\n        '''\n        return download_stored_query(\n            'urban::observations::airquality::hourly::multipointcoverage',\n            args=[\n                f'bbox={bbox}',\n                f'timeseries={timeseries}',\n                f'parameters={parameters}',\n            ],\n        )", "class DataFetcher:\n    '''\n    This class provides methods for fetching forecast and current weather data\n    using the Finnish Meteorological Institute's open data interface.\n    '''\n\n    def get_forecast_data(\n        self, start: str, end: str, bbox: str, timestep: int, parameters: str\n    ) -> Dict:\n        '''\n        Fetches forecast data for a specified time range, area, timestep and parameters.\n        Args:\n            start (str): The start time of the forecast period in ISO format.\n            end (str): The end time of the forecast period in ISO format.\n            bbox (str): Bounding box for the forecast area in format 'xmin,ymin,xmax,ymax'.\n            timestep (int): The timestep in minutes for the forecast data.\n            parameters (str): Comma-separated list of parameters to fetch.\n        Returns:\n            dict: A dictionary containing the forecast data.\n        '''\n        return download_stored_query(\n            'fmi::forecast::harmonie::surface::grid',\n            args=[\n                f'starttime={start}',\n                f'endtime={end}',\n                f'bbox={bbox}',\n                f'timestep={timestep}',\n                f'parameters={parameters}',\n            ],\n        )\n\n    def get_current_weather_data(self, bbox: str, timeseries: bool) -> Dict:\n        '''\n        Fetches current weather data for a specified area and timeseries.\n        Args:\n            bbox (str): Bounding box for the forecast area in format 'xmin,ymin,xmax,ymax'.\n            timeseries (bool): Whether to fetch data as a time series or not.\n        Returns:\n            dict: A dictionary containing the current weather data.\n        '''\n        return download_stored_query(\n            'fmi::observations::weather::multipointcoverage',\n            args=[\n                f'bbox={bbox}',\n                f'timeseries={timeseries}',\n            ],\n        )\n\n    def get_current_air_quality_data(self, bbox: str, timeseries: bool, parameters: str) -> Dict:\n        '''\n        Fetches current weather data for a specified area and timeseries.\n        Args:\n            bbox (str): Bounding box for the forecast area in format 'xmin,ymin,xmax,ymax'.\n            timeseries (bool): Whether to fetch data as a time series or not.\n        Returns:\n            dict: A dictionary containing the current weather data.\n        '''\n        return download_stored_query(\n            'urban::observations::airquality::hourly::multipointcoverage',\n            args=[\n                f'bbox={bbox}',\n                f'timeseries={timeseries}',\n                f'parameters={parameters}',\n            ],\n        )", ""]}
