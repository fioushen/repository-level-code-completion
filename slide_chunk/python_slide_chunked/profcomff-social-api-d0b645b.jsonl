{"filename": "social/settings.py", "chunked_list": ["import os\nfrom functools import lru_cache\n\nfrom pydantic import ConfigDict, PostgresDsn\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings):\n    \"\"\"Application settings\"\"\"\n\n    model_config = ConfigDict(case_sensitive=True, env_file=\".env\", extra=\"allow\")\n\n    DB_DSN: PostgresDsn = 'postgresql://postgres@localhost:5432/postgres'\n    ROOT_PATH: str = '/' + os.getenv('APP_NAME', '')\n\n    CORS_ALLOW_ORIGINS: list[str] = ['*']\n    CORS_ALLOW_CREDENTIALS: bool = True\n    CORS_ALLOW_METHODS: list[str] = ['*']\n    CORS_ALLOW_HEADERS: list[str] = ['*']\n\n    TELEGRAM_BOT_TOKEN: str | None = None\n\n    GITHUB_APP_ID: int | None = None\n    GITHUB_WEBHOOK_SECRET: str | None = None\n    GITHUB_PRIVATE_KEY: str | None = None", "\n\n@lru_cache\ndef get_settings() -> Settings:\n    settings = Settings()\n    return settings\n"]}
{"filename": "social/__main__.py", "chunked_list": ["import uvicorn\n\nfrom social.routes.base import app\n\n\nif __name__ == '__main__':\n    uvicorn.run(app)\n"]}
{"filename": "social/__init__.py", "chunked_list": ["import os\n\n\n__version__ = os.getenv('APP_VERSION', 'dev')\n"]}
{"filename": "social/exceptions.py", "chunked_list": [""]}
{"filename": "social/handlers_github/base.py", "chunked_list": ["import logging\nimport re\nfrom typing import Any, Callable\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass EventProcessor:\n    \"\"\"\u041f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0440 \u0441\u043e\u0431\u044b\u0442\u0438\u044f\n\n    \u0418\u043c\u0435\u0435\u0442 \u0444\u0438\u043b\u044c\u0442\u0440\u044b \u0432 \u043e\u0434\u043d\u043e\u043c \u0438\u0437 \u0444\u043e\u0440\u043c\u0430\u0442\u043e\u0432\n    - `\u043f\u043e\u043b\u0435 = \u043c\u0430\u0441\u043a\u0430-\u0440\u0435\u0433\u0443\u043b\u044f\u0440\u043d\u043e\u0435 \u0432\u044b\u0440\u0430\u0436\u0435\u043d\u0438\u0435`\n    - `\u043f\u043e\u043b\u0435 = lambda-\u0444\u0443\u043d\u043a\u0446\u0438\u044f`\n    - `\u043f\u043e\u043b\u0435 = ...`, \u043f\u0440\u043e\u0441\u0442\u043e \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u043e\u0432\u0430\u043d\u0438\u044f\n\n    \u0415\u0441\u043b\u0438 \u0440\u0435\u0433\u0443\u043b\u044f\u0440\u043d\u043e\u0435 \u0432\u044b\u0440\u0430\u0436\u0435\u043d\u0438\u0435 \u0443\u0434\u043e\u0432\u043b\u0435\u0442\u0432\u043e\u0440\u0435\u043d\u043e, \u0437\u0430\u043f\u0443\u0441\u043a\u0430\u0435\u0442 \u0444\u0443\u043d\u043a\u0446\u0438\u044e\n    \"\"\"\n\n    def __init__(self, filters: dict[str, str | Callable], function: Callable[[dict[str, Any]], None]):\n        self.function = function\n        self.filters = {}\n\n        for field, checker in filters.items():\n            if isinstance(checker, str):\n                logger.debug(\"Regex filter\")\n                self.filters[field] = re.compile(checker).match\n            elif callable(checker):\n                logger.debug(\"Lambda filter\")\n                self.filters[field] = checker\n            elif checker is ...:\n                self.filters[field] = lambda x: True\n            else:\n                raise TypeError(\"Filter should be regex or lambda\")\n\n    def _check(self, event: dict) -> bool:\n        for field, checker in self.filters.items():\n            if (value := event.get(field, ...)) is not ... and checker(value):\n                logger.debug(\"field `%s` check ok\", field)\n                continue\n            else:\n                logger.debug(\"field `%s` check fail\", field)\n                return False\n        return True\n\n    def check_and_process(self, event: dict) -> bool | None:\n        if self._check(event):\n            try:\n                logger.debug(\"Starting fuction\")\n                self.function(event)\n            except Exception as exc:\n                logger.error(\"Can't process event, processor error\", exc_info=True)\n                return None\n            return True\n        return False", "class EventProcessor:\n    \"\"\"\u041f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0440 \u0441\u043e\u0431\u044b\u0442\u0438\u044f\n\n    \u0418\u043c\u0435\u0435\u0442 \u0444\u0438\u043b\u044c\u0442\u0440\u044b \u0432 \u043e\u0434\u043d\u043e\u043c \u0438\u0437 \u0444\u043e\u0440\u043c\u0430\u0442\u043e\u0432\n    - `\u043f\u043e\u043b\u0435 = \u043c\u0430\u0441\u043a\u0430-\u0440\u0435\u0433\u0443\u043b\u044f\u0440\u043d\u043e\u0435 \u0432\u044b\u0440\u0430\u0436\u0435\u043d\u0438\u0435`\n    - `\u043f\u043e\u043b\u0435 = lambda-\u0444\u0443\u043d\u043a\u0446\u0438\u044f`\n    - `\u043f\u043e\u043b\u0435 = ...`, \u043f\u0440\u043e\u0441\u0442\u043e \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u043e\u0432\u0430\u043d\u0438\u044f\n\n    \u0415\u0441\u043b\u0438 \u0440\u0435\u0433\u0443\u043b\u044f\u0440\u043d\u043e\u0435 \u0432\u044b\u0440\u0430\u0436\u0435\u043d\u0438\u0435 \u0443\u0434\u043e\u0432\u043b\u0435\u0442\u0432\u043e\u0440\u0435\u043d\u043e, \u0437\u0430\u043f\u0443\u0441\u043a\u0430\u0435\u0442 \u0444\u0443\u043d\u043a\u0446\u0438\u044e\n    \"\"\"\n\n    def __init__(self, filters: dict[str, str | Callable], function: Callable[[dict[str, Any]], None]):\n        self.function = function\n        self.filters = {}\n\n        for field, checker in filters.items():\n            if isinstance(checker, str):\n                logger.debug(\"Regex filter\")\n                self.filters[field] = re.compile(checker).match\n            elif callable(checker):\n                logger.debug(\"Lambda filter\")\n                self.filters[field] = checker\n            elif checker is ...:\n                self.filters[field] = lambda x: True\n            else:\n                raise TypeError(\"Filter should be regex or lambda\")\n\n    def _check(self, event: dict) -> bool:\n        for field, checker in self.filters.items():\n            if (value := event.get(field, ...)) is not ... and checker(value):\n                logger.debug(\"field `%s` check ok\", field)\n                continue\n            else:\n                logger.debug(\"field `%s` check fail\", field)\n                return False\n        return True\n\n    def check_and_process(self, event: dict) -> bool | None:\n        if self._check(event):\n            try:\n                logger.debug(\"Starting fuction\")\n                self.function(event)\n            except Exception as exc:\n                logger.error(\"Can't process event, processor error\", exc_info=True)\n                return None\n            return True\n        return False", "\n\nEVENT_PROCESSORS: list[EventProcessor] = []\n\n\ndef event(**filters: str):\n    \"\"\"\u041f\u043e\u043c\u0435\u0447\u0430\u0435\u0442 \u0444\u0443\u043d\u043a\u0446\u0438\u044e \u043a\u0430\u043a \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u0441\u043e\u0431\u044b\u0442\u0438\u0439 GitHub, \u0437\u0430\u0434\u0430\u0435\u0442 \u0444\u0438\u043b\u044c\u0442\u0440\u044b \u0434\u043b\u044f \u0437\u0430\u043f\u0443\u0441\u043a\u0430\"\"\"\n\n    def deco(func: Callable):\n        EVENT_PROCESSORS.append(EventProcessor(filters, func))\n        return func\n\n    return deco", "\n\ndef process_event(event: dict):\n    for processor in EVENT_PROCESSORS:\n        if processor.check_and_process(event):\n            break\n    else:\n        logger.debug(\"Event without processor\")\n", ""]}
{"filename": "social/handlers_github/__init__.py", "chunked_list": ["from . import profcomff_issues\nfrom .base import process_event\n\n\n__all__ = (\"process_event\", \"profcomff_issues\")\n"]}
{"filename": "social/handlers_github/profcomff_issues.py", "chunked_list": ["import datetime\nimport logging\n\nfrom social.handlers_github.base import event\nfrom social.utils.github_api import get_github\n\n\nlogger = logging.getLogger(__name__)\ngithub = get_github('profcomff')\n", "github = get_github('profcomff')\n\n\nPROJECT_NODE_ID = \"PVT_kwDOBaPiZM4AFiz-\"  # \u0414\u043e\u0441\u043a\u0430 \u0422\u0432\u043e\u0439 \u0424\u0424\nDEADLINE_FIELD_NODE_ID = \"PVTF_lADOBaPiZM4AFiz-zgHTmbk\"  # \u041f\u043e\u043b\u0435 Deadline \u0434\u043b\u044f \u0437\u0430\u0434\u0430\u0447 \u043d\u0430 \u0434\u043e\u0441\u043a\u0435 \u0422\u0432\u043e\u0439 \u0424\u0424\nTAKEN_FIELD_NODE_ID = \"PVTF_lADOBaPiZM4AFiz-zgHTme8\"  # \u041f\u043e\u043b\u0435 Taken \u0434\u043b\u044f \u0437\u0430\u0434\u0430\u0447 \u043d\u0430 \u0434\u043e\u0441\u043a\u0435 \u0422\u0432\u043e\u0439 \u0424\u0424\n\n\n@event(issue=..., action=\"opened\")\ndef issue_opened(event):\n    \"\"\"\u041f\u0440\u0438 \u043e\u0442\u043a\u0440\u044b\u0442\u0438\u0438 \u043d\u043e\u0432\u043e\u0439 issue \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u0442 \u0435\u0435 \u043d\u0430 \u0434\u043e\u0441\u043a\u0443 \"\u0422\u0432\u043e\u0439 \u0424\u0424\" \"\"\"\n    logger.debug(\"Issue %s created (node_id=%s)\", event[\"issue\"].get(\"url\"), event[\"issue\"].get(\"node_id\"))\n    r = github.request_gql(\n        'social/handlers_github/profcomff_issues.graphql',\n        'AddToScrum',\n        projectId=PROJECT_NODE_ID,\n        contentId=event[\"issue\"].get(\"node_id\"),\n    )\n    logging.debug(\"Response %s\", r)", "@event(issue=..., action=\"opened\")\ndef issue_opened(event):\n    \"\"\"\u041f\u0440\u0438 \u043e\u0442\u043a\u0440\u044b\u0442\u0438\u0438 \u043d\u043e\u0432\u043e\u0439 issue \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u0442 \u0435\u0435 \u043d\u0430 \u0434\u043e\u0441\u043a\u0443 \"\u0422\u0432\u043e\u0439 \u0424\u0424\" \"\"\"\n    logger.debug(\"Issue %s created (node_id=%s)\", event[\"issue\"].get(\"url\"), event[\"issue\"].get(\"node_id\"))\n    r = github.request_gql(\n        'social/handlers_github/profcomff_issues.graphql',\n        'AddToScrum',\n        projectId=PROJECT_NODE_ID,\n        contentId=event[\"issue\"].get(\"node_id\"),\n    )\n    logging.debug(\"Response %s\", r)", "\n\n@event(issue=..., action=\"assigned\")\ndef issue_opened(event):\n    \"\"\"\n    \u041f\u0440\u0438 \u043d\u0430\u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0438 \u0438\u0441\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044f \u0434\u043b\u044f issue,\n    \u0435\u0441\u043b\u0438 \u0434\u0435\u0434\u043b\u0430\u0439\u043d \u043d\u0435 \u043d\u0430\u0437\u043d\u0430\u0447\u0435\u043d, \u0442\u043e \u043d\u0430\u0437\u043d\u0430\u0447\u0438\u0442\u044c \u0434\u0435\u0434\u043b\u0430\u0439\u043d +\u043d\u0435\u0434\u0435\u043b\u044e \u043e\u0442 \u0442\u0435\u043a\u0443\u0449\u0435\u0439 \u0434\u0430\u0442\u044b\n    \u0435\u0441\u043b\u0438 \u0434\u0435\u0434\u043b\u0430\u0439\u043d \u043f\u0440\u043e\u0441\u0440\u043e\u0447\u0435\u043d (\u0442\u043e \u0435\u0441\u0442\u044c \u0441\u043c\u0435\u043d\u0430 \u0438\u0441\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044f), \u0442\u043e \u043d\u0430\u0437\u043d\u0430\u0447\u0430\u0435\u0442 \u0434\u0435\u0434\u043b\u0430\u0439\u043d +\u043d\u0435\u0434\u0435\u043b\u044e \u043e\u0442 \u0442\u0435\u043a\u0443\u0449\u0435\u0439 \u0434\u0430\u0442\u044b\n\n    \u0442\u0430\u043a \u0436\u0435 \u043f\u0440\u0438 \u043d\u0430\u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0438 \u0438\u0441\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044f \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u044c taken_date \u043d\u0430 \u0442\u0435\u043a\u0443\u0449\u0438\u0439 \u0434\u0435\u043d\u044c\n    \u0432\u043f\u043e\u0441\u043b\u0435\u0434\u0441\u0442\u0432\u0438\u0438 \u043d\u0435 \u043c\u0435\u043d\u044f\u0442\u044c, \u0434\u0430\u0436\u0435 \u043f\u0440\u0438 \u0441\u043c\u0435\u043d\u0435 \u0438\u0441\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044f\n    \"\"\"\n\n    # \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 project_item_id, \u0434\u0435\u0434\u0435\u043b\u0430\u0439\u043d\u0430 \u0438 \u0434\u0430\u0442\u044b \u0432\u0437\u044f\u0442\u0438\u044f \u0432 \u0440\u0430\u0431\u043e\u0442\u0443 \u0434\u043b\u044f \u0442\u0435\u043a\u0443\u0449\u0435\u0439 issue\n    logger.debug(\"Issue %s assigned (node_id=%s)\", event[\"issue\"].get(\"url\"), event[\"issue\"].get(\"node_id\"))\n    r = github.request_gql(\n        'social/handlers_github/profcomff_issues.graphql',\n        'GetIssueDeadlineField',\n        issueId=event[\"issue\"].get(\"node_id\"),\n    )\n    logging.debug(\"Get Project Fields: %s\", r)\n\n    # \u041f\u0430\u0440\u0441\u0438\u043d\u0433 \u043f\u043e\u043b\u0435\u0439\n    project_item_id = r['node']['projectItems']['nodes'][0]['id']\n    deadline_date = None\n    taken_date = None\n    for node in r['node']['projectItems']['nodes'][0]['fieldValues']['nodes']:\n        if len(node) != 0 and node['field']['name'] == 'Deadline':\n            deadline_date = datetime.datetime.strptime(node['date'], '%Y-%m-%d').date()\n        if len(node) != 0 and node['field']['name'] == 'Taken':\n            taken_date = datetime.datetime.strptime(node['date'], '%Y-%m-%d').date()\n\n    # \u0418\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u0435 \u0434\u0435\u0434\u043b\u0430\u0439\u043d\u0430 \u0435\u0441\u043b\u0438 \u0442\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044f\n    if deadline_date is None or deadline_date < datetime.date.today():\n        new_deadline_date = str((datetime.date.today() + datetime.timedelta(days=7)))\n        logging.debug(f\"Try to change DeadlineDate from {deadline_date} to {new_deadline_date}\")\n        r = github.request_gql(\n            'social/handlers_github/profcomff_issues.graphql',\n            'SetFieldDateValue',\n            projectId=PROJECT_NODE_ID,\n            itemId=project_item_id,\n            fieldId=DEADLINE_FIELD_NODE_ID,\n            newDate=new_deadline_date\n        )\n        logging.debug(\"Deadline change response: %s\", r)\n\n    # \u0418\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u0435 \u0434\u0430\u0442\u044b \u0432\u0437\u044f\u0442\u0438\u044f \u0432 \u0440\u0430\u0431\u043e\u0442\u0443 \u0435\u0441\u043b\u0438 \u043d\u0435 \u043d\u0430\u0437\u043d\u0430\u0447\u0435\u043d\u0430\n    if taken_date is None:\n        new_taken_date = str(datetime.date.today())\n        logging.debug(f\"Try to change TakenDate from {taken_date} to {new_taken_date}\")\n        r = github.request_gql(\n            'social/handlers_github/profcomff_issues.graphql',\n            'SetFieldDateValue',\n            projectId=PROJECT_NODE_ID,\n            itemId=project_item_id,\n            fieldId=TAKEN_FIELD_NODE_ID,\n            newDate=new_taken_date\n        )\n        logging.debug(\"Taken change response: %s\", r)", ""]}
{"filename": "social/utils/model.py", "chunked_list": ["from pydantic import BaseModel\n\n\nclass Base(BaseModel):\n    def __repr__(self) -> str:\n        attrs = []\n        for k, v in self.__class__.schema().items():\n            attrs.append(f\"{k}={v}\")\n        return \"{}({})\".format(self.__class__.__name__, ', '.join(attrs))\n\n    class Config:\n        orm_mode = True", ""]}
{"filename": "social/utils/github_api.py", "chunked_list": ["import logging\nimport os.path\nimport time\nfrom datetime import datetime\nfrom functools import lru_cache\n\nimport jwt\nimport requests\nfrom gql import Client, gql\nfrom gql.transport.requests import RequestsHTTPTransport", "from gql import Client, gql\nfrom gql.transport.requests import RequestsHTTPTransport\nfrom graphql import DocumentNode\n\nfrom social.settings import get_settings\n\n\nlogger = logging.getLogger(__name__)\nsettings = get_settings()\n", "settings = get_settings()\n\n\nclass GitHub:\n    def __init__(self, app_id: int, pem: str, org: str):\n        self._app_id = app_id  # App ID\n        self._pem: bytes = pem.encode()  # App secret key\n        self._org = org  # Name of organization to log into\n        self._jwt = None\n        self._jwt_expire = None\n        self._org_token = None\n        self._org_token_expire = None\n        self._client = None\n        self.client  # \u0427\u0438\u0441\u0442\u043e \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043d\u0430 \u0432\u0435\u0440\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435\n\n    def _reauth(self) -> tuple[str, time.time]:\n        signing_key = jwt.jwk_from_pem(self._pem)\n\n        issued = time.time() - 60\n        expiration = time.time() + 600\n        logger.debug('JWT issued at %s, expire at %s', issued, expiration)\n\n        payload = {\n            # Issued at time\n            'iat': int(issued),\n            # JWT expiration time (10 minutes maximum)\n            'exp': int(expiration),\n            # GitHub App's identifier\n            'iss': self._app_id,\n        }\n\n        # Create JWT\n        jwt_instance = jwt.JWT()\n        encoded_jwt = jwt_instance.encode(payload, signing_key, alg='RS256')\n\n        self._jwt, self._jwt_expire = encoded_jwt, expiration\n\n    def _update_org_token(self):\n        if self._jwt is None or self._jwt_expire is None or self._jwt_expire <= time.time():\n            self._reauth()\n        r = requests.get(\n            f'https://api.github.com/orgs/{self._org}/installation',\n            headers={\n                \"Accept\": \"application/vnd.github+json\",\n                \"Authorization\": f\"Bearer {self._jwt}\",\n                \"X-GitHub-Api-Version\": \"2022-11-28\",\n            },\n        )\n        logger.debug(\"Installation request: %s\", r)\n        installation_token_url = r.json()['access_tokens_url']\n\n        logger.debug(\"access_tokens_url: %s\", installation_token_url)\n        r = requests.post(\n            installation_token_url,\n            headers={\n                \"Accept\": \"application/vnd.github+json\",\n                \"Authorization\": f\"Bearer {self._jwt}\",\n                \"X-GitHub-Api-Version\": \"2022-11-28\",\n            },\n        ).json()\n        logger.debug(\"Token request: %s\", r)\n        self._org_token = r['token']\n        self._org_token_expire = datetime.fromisoformat(r['expires_at']).replace(tzinfo=None)\n\n    @property\n    def client(self):\n        if (\n            self._client is None\n            or self._org_token is None\n            or self._org_token_expire is None\n            or self._org_token_expire <= datetime.utcnow()\n        ):\n            logger.debug(\"Updating token\")\n            self._update_org_token()\n            transport = RequestsHTTPTransport(\n                url='https://api.github.com/graphql',\n                verify=True,\n                retries=1,\n                headers={'Authorization': f'Bearer {self._org_token}'},\n            )\n            self._client = Client(transport=transport)\n        return self._client\n\n    @lru_cache(30)\n    def _read_gql(self, path: str):\n        with open(path) as f:\n            return gql(f.read())\n\n    def request_gql(self, file_or_query, operation_name, **params):\n        logger.debug(os.path.exists(file_or_query))\n        if os.path.exists(file_or_query):\n            return self.client.execute(self._read_gql(file_or_query), params, operation_name)\n        if isinstance(file_or_query, DocumentNode):\n            return self.client.execute(file_or_query, params, operation_name)\n        else:\n            return self.client.execute(gql(file_or_query), params, operation_name)", "\n\n@lru_cache()\ndef get_github(org):\n    github = GitHub(settings.GITHUB_APP_ID, settings.GITHUB_PRIVATE_KEY, org)\n    return github\n"]}
{"filename": "social/utils/__init__.py", "chunked_list": [""]}
{"filename": "social/handlers_telegram/handlers_viribus.py", "chunked_list": ["\"\"\"\u0420\u0430\u0431\u043e\u0442\u0430 \u0441 \u0447\u0430\u0442\u043e\u043c Viribus Unitis https://t.me/ViribusUnitisGroup\n\n\u0414\u043b\u044f \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u043d\u043e\u0432\u043e\u0433\u043e \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u0430 \u0441\u043e\u0437\u0434\u0430\u0439 \u0430\u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u0443\u044e \u0444\u0443\u043d\u043a\u0446\u0438\u044e \u0432 \u043a\u043e\u043d\u0446\u0435 \u0444\u0430\u0439\u043b\u0430 \u0441 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430\u043c\u0438\nUpdate \u0438 Context, \u0430 \u043f\u043e\u0442\u043e\u043c \u0437\u0430\u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0438\u0440\u0443\u0439 \u0435\u0435 \u0432\u043d\u0443\u0442\u0440\u0438 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 `register_handlers`.\n\"\"\"\nimport logging\nfrom random import choice\nfrom string import ascii_letters, digits, punctuation\nfrom textwrap import dedent\n", "from textwrap import dedent\n\nfrom telegram import Update\nfrom telegram.error import TelegramError\nfrom telegram.ext import Application, CommandHandler, MessageHandler\nfrom telegram.ext.filters import Chat\n\nfrom social.settings import get_settings\n\nfrom .utils import CustomContext", "\nfrom .utils import CustomContext\n\n\nlogger = logging.getLogger(__name__)\nsettings = get_settings()\n\nCHAT_ID = -1001758480664\nMAIN_TOPIC_ID = 55106\n", "MAIN_TOPIC_ID = 55106\n\nGREETINGS = [\n    \"\"\"\n    \u041f\u0440\u0438\u0432\u0435\u0442, [{name}](tg://user?id={id}), \u0438 \u0434\u043e\u0431\u0440\u043e \u043f\u043e\u0436\u0430\u043b\u043e\u0432\u0430\u0442\u044c \u0432 \u043d\u0430\u0448 \u043a\u043b\u0443\u0431!\n\n    \u0420\u0430\u0441\u0441\u043a\u0430\u0436\u0438, \u0447\u0442\u043e \u043f\u0440\u0438\u0432\u0435\u043b\u043e \u0442\u0435\u0431\u044f \u043a \u043d\u0430\u043c \u0438 \u043e\u0442\u043a\u0443\u0434\u0430 \u043e \u043d\u0430\u0441 \u0443\u0437\u043d\u0430\u043b(\u0430)?\n    \"\"\",\n    \"\"\"\n    \u0417\u0434\u0440\u0430\u0432\u0441\u0442\u0432\u0443\u0439, [{name}](tg://user?id={id}). \u0414\u043e\u0431\u0440\u043e \u043f\u043e\u0436\u0430\u043b\u043e\u0432\u0430\u0442\u044c \u0432 Viribus unitis!", "    \"\"\"\n    \u0417\u0434\u0440\u0430\u0432\u0441\u0442\u0432\u0443\u0439, [{name}](tg://user?id={id}). \u0414\u043e\u0431\u0440\u043e \u043f\u043e\u0436\u0430\u043b\u043e\u0432\u0430\u0442\u044c \u0432 Viribus unitis!\n\n    \u041a\u0430\u043a \u0442\u044b \u043e \u043d\u0430\u0441 \u0443\u0437\u043d\u0430\u043b(\u0430)? \u0420\u0430\u0441\u0441\u043a\u0430\u0436\u0438 \u043e \u0441\u0432\u043e\u0435\u043c \u043e\u043f\u044b\u0442\u0435 \u0432 IT.\n    \"\"\",\n    \"\"\"\n    \u0412\u0441\u0435\u043c \u043f\u0440\u0438\u0432\u0435\u0442! \u0423 \u043d\u0430\u0441 \u043d\u043e\u0432\u044b\u0439 \u0443\u0447\u0430\u0441\u0442\u043d\u0438\u043a, \u0434\u0430\u0432\u0430\u0439\u0442\u0435 \u043f\u0440\u0438\u0432\u0435\u0442\u0441\u0442\u0432\u043e\u0432\u0430\u0442\u044c [{name}](tg://user?id={id}). \n    \n    \u0427\u0435\u043c \u0443\u0432\u043b\u0435\u043a\u0430\u0435\u0448\u044c\u0441\u044f \u0432 IT, \u0438 \u043a\u0430\u043a \u043d\u0430\u0448\u0435\u043b(\u043b\u0430) \u043d\u0430\u0448 \u0447\u0430\u0442?\n    \"\"\",", "    \u0427\u0435\u043c \u0443\u0432\u043b\u0435\u043a\u0430\u0435\u0448\u044c\u0441\u044f \u0432 IT, \u0438 \u043a\u0430\u043a \u043d\u0430\u0448\u0435\u043b(\u043b\u0430) \u043d\u0430\u0448 \u0447\u0430\u0442?\n    \"\"\",\n    \"\"\"\n    \u041f\u0440\u0438\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u0435\u043c \u043d\u0430 \u0431\u043e\u0440\u0442\u0443, [{name}](tg://user?id={id})!\n\n    \u041c\u044b \u0432\u0441\u0435\u0433\u0434\u0430 \u0440\u0430\u0434\u044b \u043d\u043e\u0432\u044b\u043c \u0438\u0434\u0435\u044f\u043c \u0438 \u043e\u043f\u044b\u0442\u0443. \u041f\u043e\u0434\u0435\u043b\u0438\u0441\u044c, \u043f\u043e\u0436\u0430\u043b\u0443\u0439\u0441\u0442\u0430, \u0441\u0432\u043e\u0438\u043c \u043f\u0443\u0442\u0435\u043c \u0432 IT \u0438 \u043a\u0430\u043a\u0438\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c \u0442\u044b \u043d\u0430\u0441 \u043d\u0430\u0448\u0435\u043b(\u043b\u0430)?\n    \"\"\",\n    \"\"\"\n    \u0421\u0430\u043b\u044e\u0442, [{name}](tg://user?id={id})! \u041f\u0440\u0438\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u0435\u043c \u0442\u0435\u0431\u044f \u0432 \u043d\u0430\u0448\u0435\u043c \u0443\u044e\u0442\u043d\u043e\u043c IT \u0443\u0433\u043e\u043b\u043a\u0435!\n", "    \u0421\u0430\u043b\u044e\u0442, [{name}](tg://user?id={id})! \u041f\u0440\u0438\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u0435\u043c \u0442\u0435\u0431\u044f \u0432 \u043d\u0430\u0448\u0435\u043c \u0443\u044e\u0442\u043d\u043e\u043c IT \u0443\u0433\u043e\u043b\u043a\u0435!\n\n    \u041a\u0430\u043a\u0438\u0435 \u043d\u0430\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f IT \u0442\u0435\u0431\u0435 \u0438\u043d\u0442\u0435\u0440\u0435\u0441\u043d\u044b \u0438 \u0433\u0434\u0435 \u0442\u044b \u0443\u0441\u043b\u044b\u0448\u0430\u043b(\u0430) \u043e \u043d\u0430\u0441?\n    \"\"\",\n    \"\"\"\n    \u041f\u0440\u0438\u0432\u0435\u0442\u0438\u043a, [{name}](tg://user?id={id})! \u0414\u043e\u0431\u0440\u043e \u043f\u043e\u0436\u0430\u043b\u043e\u0432\u0430\u0442\u044c \u0432 \u043d\u0430\u0448 IT \u043a\u043b\u0443\u0431!\n\n    \u041c\u044b \u0437\u0434\u0435\u0441\u044c, \u0447\u0442\u043e\u0431\u044b \u043e\u0431\u0443\u0447\u0430\u0442\u044c\u0441\u044f \u0438 \u0434\u0435\u043b\u0438\u0442\u044c\u0441\u044f \u043e\u043f\u044b\u0442\u043e\u043c. \u0420\u0430\u0441\u0441\u043a\u0430\u0436\u0438 \u043d\u0430\u043c \u043d\u0435\u043c\u043d\u043e\u0433\u043e \u043e \u0441\u0432\u043e\u0435\u043c \u043e\u043f\u044b\u0442\u0435 \u0438 \u043a\u0430\u043a \u0442\u044b \u043d\u0430\u0441 \u043d\u0430\u0448\u0435\u043b(\u043b\u0430)?\n    \"\"\",\n    \"\"\"", "    \"\"\",\n    \"\"\"\n    \u041f\u0440\u0438\u0432\u0435\u0442, [{name}](tg://user?id={id})! \u0414\u043e\u0431\u0440\u043e \u043f\u043e\u0436\u0430\u043b\u043e\u0432\u0430\u0442\u044c \u0432 \u043d\u0430\u0448\u0435 IT \u0441\u043e\u043e\u0431\u0449\u0435\u0441\u0442\u0432\u043e!\n\n    \u0427\u0442\u043e \u0437\u0430\u0438\u043d\u0442\u0435\u0440\u0435\u0441\u043e\u0432\u0430\u043b\u043e \u0442\u0435\u0431\u044f \u0432 \u043d\u0430\u0448\u0435\u043c \u043a\u043b\u0443\u0431\u0435 \u0438 \u0433\u0434\u0435 \u0443\u0437\u043d\u0430\u043b(\u0430) \u043e \u043d\u0430\u0441?\n    \"\"\",\n    \"\"\"\n    \u041f\u0440\u0438\u044f\u0442\u043d\u043e \u043f\u043e\u0437\u043d\u0430\u043a\u043e\u043c\u0438\u0442\u044c\u0441\u044f, [{name}](tg://user?id={id})! \u041c\u044b \u0437\u0434\u0435\u0441\u044c, \u0447\u0442\u043e\u0431\u044b \u043e\u0431\u0441\u0443\u0436\u0434\u0430\u0442\u044c \u0432\u0441\u0451, \u0447\u0442\u043e \u0441\u0432\u044f\u0437\u0430\u043d\u043e \u0441 IT.\n\n    \u041a\u0430\u043a\u0438\u0435 \u0442\u0435\u043c\u044b \u0432 IT \u0442\u0435\u0431\u044f \u0431\u043e\u043b\u044c\u0448\u0435 \u0432\u0441\u0435\u0433\u043e \u0438\u043d\u0442\u0435\u0440\u0435\u0441\u0443\u044e\u0442 \u0438 \u0433\u0434\u0435 \u0442\u044b \u0443\u0437\u043d\u0430\u043b(\u0430) \u043e \u043d\u0430\u0441?", "\n    \u041a\u0430\u043a\u0438\u0435 \u0442\u0435\u043c\u044b \u0432 IT \u0442\u0435\u0431\u044f \u0431\u043e\u043b\u044c\u0448\u0435 \u0432\u0441\u0435\u0433\u043e \u0438\u043d\u0442\u0435\u0440\u0435\u0441\u0443\u044e\u0442 \u0438 \u0433\u0434\u0435 \u0442\u044b \u0443\u0437\u043d\u0430\u043b(\u0430) \u043e \u043d\u0430\u0441?\n    \"\"\"\n]\n\n\ndef register_handlers(app: Application):\n    app.add_handler(CommandHandler(filters=Chat(CHAT_ID), callback=change_slug, command=\"slug\"))\n    app.add_handler(MessageHandler(filters=Chat(CHAT_ID), callback=delete_system_message))\n    logger.info(\"Viribus Unitis handlers activated\")", "\n\nasync def delete_system_message(update: Update, context: CustomContext):\n    \"\"\"\u0423\u0434\u0430\u043b\u044f\u0435\u0442 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f \u0432 \u0441\u0435\u0440\u0432\u0438\u0441\u043d\u043e\u043c \u043a\u0430\u043d\u0430\u043b\u0435 \u0438 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442 \u043f\u0440\u0438\u0432\u0435\u0442\u0441\u0442\u0432\u0435\u043d\u043d\u044b\u0435 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f\"\"\"\n    for user in update.effective_message.new_chat_members:\n        await context.bot.send_message(\n            chat_id=CHAT_ID,\n            message_thread_id=MAIN_TOPIC_ID,\n            text=dedent(choice(GREETINGS)).format(name=user.name, id=user.id),\n            parse_mode='markdown',\n        )\n        logger.info(f\"User {user.name} greeting sent\")", "\n    if update.effective_message.message_thread_id is None and not update.effective_user.is_bot:\n        res = await update.effective_message.delete()\n        logger.info(f\"Non-bot message to general channel handled, delete status = {res}\")\n\n\nasync def change_slug(update: Update, context: CustomContext):\n    \"\"\"\u0415\u0441\u043b\u0438 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0430\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u043e\u043c, \u0442\u043e \u043e\u043d \u043c\u043e\u0436\u0435\u0442 \u043f\u043e\u043c\u0435\u043d\u044f\u0442\u044c \u043d\u0430\u0434\u043f\u0438\u0441\u044c \u0443 \u0438\u043c\u0435\u043d\u0438\"\"\"\n    logger.info(f'Trying to change slug via command {update.effective_message.text}')\n    slug = ' '.join(context.args) if context.args else ''\n    if len(slug) == 0:\n        await context.bot.send_message(\n            chat_id=update.effective_message.chat.id,\n            reply_to_message_id=update.effective_message.id,\n            text=dedent(\n                \"\"\"\n                \u042d\u0442\u0430 \u043a\u043e\u043c\u0430\u043d\u0434\u0430 \u043c\u0435\u043d\u044f\u0435\u0442 \u0442\u0435\u043a\u0441\u0442, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043f\u0438\u0448\u0435\u0442\u0441\u044f \u0441\u043f\u0440\u0430\u0432\u0430 \u043e\u0442 \u0438\u043c\u0435\u043d\u0438 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0432 \u044d\u0442\u043e\u043c \u0447\u0430\u0442\u0435\n                \u0422\u0435\u043a\u0441\u0442 \u0442\u043e\u043b\u0436\u0435\u043d \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0442\u044c \u0442\u043e\u043b\u044c\u043a\u043e \u0431\u0443\u043a\u0432\u044b, \u0446\u0438\u0444\u0440\u044b, \u043f\u0440\u043e\u0431\u0435\u043b\u044b \u0438 \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u0443\u044e \u043f\u0443\u043d\u043a\u0442\u0443\u0430\u0446\u0438\u044e, \u043d\u0435 \u0431\u043e\u043b\u0435\u0435 16 \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432\n                \u041d\u0430\u043f\u0438\u0448\u0438 `/slug \u0442\u0435\u043a\u0441\u0442` \u0434\u043b\u044f \u043f\u0440\u0438\u043c\u0435\u043d\u0435\u043d\u0438\u044f\n            \"\"\"\n            ),\n            parse_mode='markdown',\n        )\n        return", "    logger.info(f'Trying to change slug via command {update.effective_message.text}')\n    slug = ' '.join(context.args) if context.args else ''\n    if len(slug) == 0:\n        await context.bot.send_message(\n            chat_id=update.effective_message.chat.id,\n            reply_to_message_id=update.effective_message.id,\n            text=dedent(\n                \"\"\"\n                \u042d\u0442\u0430 \u043a\u043e\u043c\u0430\u043d\u0434\u0430 \u043c\u0435\u043d\u044f\u0435\u0442 \u0442\u0435\u043a\u0441\u0442, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043f\u0438\u0448\u0435\u0442\u0441\u044f \u0441\u043f\u0440\u0430\u0432\u0430 \u043e\u0442 \u0438\u043c\u0435\u043d\u0438 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0432 \u044d\u0442\u043e\u043c \u0447\u0430\u0442\u0435\n                \u0422\u0435\u043a\u0441\u0442 \u0442\u043e\u043b\u0436\u0435\u043d \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0442\u044c \u0442\u043e\u043b\u044c\u043a\u043e \u0431\u0443\u043a\u0432\u044b, \u0446\u0438\u0444\u0440\u044b, \u043f\u0440\u043e\u0431\u0435\u043b\u044b \u0438 \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u0443\u044e \u043f\u0443\u043d\u043a\u0442\u0443\u0430\u0446\u0438\u044e, \u043d\u0435 \u0431\u043e\u043b\u0435\u0435 16 \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432\n                \u041d\u0430\u043f\u0438\u0448\u0438 `/slug \u0442\u0435\u043a\u0441\u0442` \u0434\u043b\u044f \u043f\u0440\u0438\u043c\u0435\u043d\u0435\u043d\u0438\u044f\n            \"\"\"\n            ),\n            parse_mode='markdown',\n        )\n        return", "    if len(slug) > 16:\n        await context.bot.send_message(\n            chat_id=update.effective_message.chat.id,\n            reply_to_message_id=update.effective_message.id,\n            text=\"\u0421\u0442\u0430\u0442\u0443\u0441 \u0434\u043e\u043b\u0436\u0435\u043d \u0431\u044b\u0442\u044c \u043d\u0435 \u0431\u043e\u043b\u044c\u0448\u0435 16 \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432\",\n        )\n        return\n    if len(set(slug.lower()) - set(digits + ascii_letters + punctuation + '\u0430\u0431\u0432\u0433\u0434\u0435\u0451\u0436\u0437\u0438\u043a\u043b\u043c\u043d\u043e\u043f\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044a\u044b\u044c\u044d\u044e\u044f ')) != 0:\n        await context.bot.send_message(\n            chat_id=update.effective_message.chat.id,\n            reply_to_message_id=update.effective_message.id,\n            text=\"\u0422\u0435\u043a\u0441\u0442 \u0442\u043e\u043b\u0436\u0435\u043d \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0442\u044c \u0442\u043e\u043b\u044c\u043a\u043e \u0431\u0443\u043a\u0432\u044b, \u0446\u0438\u0444\u0440\u044b, \u043f\u0440\u043e\u0431\u0435\u043b\u044b \u0438 \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u0443\u044e \u043f\u0443\u043d\u043a\u0442\u0443\u0430\u0446\u0438\u044e, \u043d\u0435 \u0431\u043e\u043b\u0435\u0435 16 \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432\",\n        )\n        return", "    if update.effective_user.id not in [a.user.id for a in await update.effective_chat.get_administrators()]:\n        await context.bot.send_message(\n            chat_id=update.effective_message.chat.id,\n            reply_to_message_id=update.effective_message.id,\n            text=\"\u0422\u043e\u043b\u044c\u043a\u043e \u0430\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u044b \u043c\u043e\u0433\u0443\u0442 \u0438\u043c\u0435\u0442\u044c \u043f\u043e\u044f\u0441\u043d\u044f\u044e\u0449\u0438\u0439 \u0442\u0435\u043a\u0441\u0442\",\n        )\n        return\n\n    try:\n        res = await context.bot.set_chat_administrator_custom_title(CHAT_ID, update.effective_user.id, slug)\n    except TelegramError as e:\n        logger.error(e, exc_info=True)\n        res = False", "    try:\n        res = await context.bot.set_chat_administrator_custom_title(CHAT_ID, update.effective_user.id, slug)\n    except TelegramError as e:\n        logger.error(e, exc_info=True)\n        res = False\n    if not res:\n        logger.info('Can not change value', exc_info=True)\n        await context.bot.send_message(\n            chat_id=update.effective_message.chat.id,\n            reply_to_message_id=update.effective_message.id,\n            text=\"\u0427\u0442\u043e-\u0442\u043e \u043f\u043e\u0448\u043b\u043e \u043d\u0435 \u0442\u0430\u043a \u0438 \u043f\u043e\u043c\u0435\u043d\u044f\u0442\u044c \u0442\u0435\u043a\u0441\u0442 \u043d\u0435 \u043f\u043e\u043b\u0443\u0447\u0438\u043b\u043e\u0441\u044c :(\",\n        )", ""]}
{"filename": "social/handlers_telegram/base.py", "chunked_list": ["import logging\nfrom functools import lru_cache\nfrom textwrap import dedent\n\nfrom telegram import Update\nfrom telegram.ext import Application, CommandHandler, ContextTypes\n\nfrom social.settings import get_settings\n\nfrom .handlers_viribus import register_handlers", "\nfrom .handlers_viribus import register_handlers\nfrom .utils import CustomContext\n\n\nlogger = logging.getLogger(__name__)\nsettings = get_settings()\n\n\n@lru_cache()\ndef get_application():\n    context_types = ContextTypes(context=CustomContext)\n    app = Application.builder().token(settings.TELEGRAM_BOT_TOKEN).updater(None).context_types(context_types).build()\n    logger.info(\"Telegram API initialized successfully\")\n    # \u041e\u0431\u0449\u0438\u0435 \u0445\u044d\u043d\u0434\u043b\u0435\u0440\u044b\n    app.add_handler(CommandHandler(callback=send_help, command=\"help\"))\n\n    # \u0425\u044d\u043d\u0434\u043b\u0435\u0440\u044b \u043a\u043e\u043d\u043a\u0440\u0435\u0442\u043d\u044b\u0445 \u0447\u0430\u0442\u043e\u0432\n    register_handlers(app)\n    \n    return app", "\n@lru_cache()\ndef get_application():\n    context_types = ContextTypes(context=CustomContext)\n    app = Application.builder().token(settings.TELEGRAM_BOT_TOKEN).updater(None).context_types(context_types).build()\n    logger.info(\"Telegram API initialized successfully\")\n    # \u041e\u0431\u0449\u0438\u0435 \u0445\u044d\u043d\u0434\u043b\u0435\u0440\u044b\n    app.add_handler(CommandHandler(callback=send_help, command=\"help\"))\n\n    # \u0425\u044d\u043d\u0434\u043b\u0435\u0440\u044b \u043a\u043e\u043d\u043a\u0440\u0435\u0442\u043d\u044b\u0445 \u0447\u0430\u0442\u043e\u0432\n    register_handlers(app)\n    \n    return app", "\n\nasync def send_help(update: Update, context: CustomContext):\n    await context.bot.send_message(\n        chat_id=update.effective_message.chat.id,\n        reply_to_message_id=update.effective_message.id,\n        text=dedent(\n            \"\"\"\n            \u041f\u0440\u0438\u0432\u0435\u0442, \u044f \u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0435\u043d\u043d\u044b\u0439 \u0437\u0430 \u043f\u0435\u0447\u0435\u043d\u044c\u043a\u0438!\n            \u041c\u043e\u044f \u043e\u0441\u043d\u043e\u0432\u043d\u0430\u044f \u0446\u0435\u043b\u044c \u2013 \u043f\u043e\u043c\u043e\u0433\u0430\u0442\u044c \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u043c \u043a\u043e\u043c\u044c\u044e\u043d\u0438\u0442\u0438 \u0440\u0430\u0441\u0442\u0438", "            \u041f\u0440\u0438\u0432\u0435\u0442, \u044f \u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0435\u043d\u043d\u044b\u0439 \u0437\u0430 \u043f\u0435\u0447\u0435\u043d\u044c\u043a\u0438!\n            \u041c\u043e\u044f \u043e\u0441\u043d\u043e\u0432\u043d\u0430\u044f \u0446\u0435\u043b\u044c \u2013 \u043f\u043e\u043c\u043e\u0433\u0430\u0442\u044c \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u043c \u043a\u043e\u043c\u044c\u044e\u043d\u0438\u0442\u0438 \u0440\u0430\u0441\u0442\u0438\n        \"\"\"\n        ),\n        parse_mode='markdown',\n    )\n"]}
{"filename": "social/handlers_telegram/__init__.py", "chunked_list": ["from .base import get_application\n\n\n__all__ = ('get_application',)\n"]}
{"filename": "social/handlers_telegram/utils.py", "chunked_list": ["from dataclasses import dataclass\n\nfrom telegram.ext import Application, CallbackContext, ExtBot\n\n\n@dataclass\nclass WebhookUpdate:\n    \"\"\"Simple dataclass to wrap a custom update type\"\"\"\n\n    user_id: int\n    payload: str", "\n\nclass CustomContext(CallbackContext[ExtBot, dict, dict, dict]):\n    \"\"\"\n    Custom CallbackContext class that makes `user_data` available for updates of type\n    `WebhookUpdate`.\n    \"\"\"\n\n    @classmethod\n    def from_update(\n        cls,\n        update: object,\n        application: \"Application\",\n    ) -> \"CustomContext\":\n        if isinstance(update, WebhookUpdate):\n            return cls(application=application, user_id=update.user_id)\n        return super().from_update(update, application)", ""]}
{"filename": "social/models/base.py", "chunked_list": ["import re\n\nfrom sqlalchemy.ext.declarative import as_declarative, declared_attr\n\n\n@as_declarative()\nclass Base:\n    \"\"\"Base class for all database entities\"\"\"\n\n    @classmethod\n    @declared_attr\n    def __tablename__(cls) -> str:\n        \"\"\"Generate database table name automatically.\n        Convert CamelCase class name to snake_case db table name.\n        \"\"\"\n        return re.sub(r\"(?<!^)(?=[A-Z])\", \"_\", cls.__name__).lower()\n\n    def __repr__(self) -> str:\n        attrs = []\n        for c in self.__table__.columns:\n            attrs.append(f\"{c.name}={getattr(self, c.name)}\")\n        return \"{}({})\".format(self.__class__.__name__, ', '.join(attrs))", ""]}
{"filename": "social/models/__init__.py", "chunked_list": [""]}
{"filename": "social/models/webhook_storage.py", "chunked_list": ["from enum import Enum\n\nimport sqlalchemy as sa\nfrom sqlalchemy.orm import Mapped, mapped_column\n\nfrom .base import Base\n\n\nclass WebhookSystems(str, Enum):\n    TELEGRAM = 'telegram'\n    GITHUB = 'github'", "class WebhookSystems(str, Enum):\n    TELEGRAM = 'telegram'\n    GITHUB = 'github'\n\n\nclass WebhookStorage(Base):\n    id: Mapped[int] = mapped_column(sa.Integer, primary_key=True)\n    system: Mapped[WebhookSystems] = mapped_column(sa.Enum(WebhookSystems, native_enum=False))\n    message: Mapped[sa.JSON] = mapped_column(sa.JSON(True))\n", ""]}
{"filename": "social/routes/base.py", "chunked_list": ["from fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi_sqlalchemy import DBSessionMiddleware\n\nfrom social import __version__\nfrom social.handlers_telegram import get_application as get_telegram\nfrom social.settings import get_settings\n\nfrom .github import router as github_rourer\nfrom .telegram import router as telegram_rourer", "from .github import router as github_rourer\nfrom .telegram import router as telegram_rourer\n\n\nsettings = get_settings()\napp = FastAPI(\n    title='\u0421\u0435\u0440\u0432\u0438\u0441 \u043c\u043e\u043d\u0438\u0442\u043e\u0440\u0438\u043d\u0433\u0430 \u0430\u043a\u0442\u0438\u0432\u043d\u043e\u0441\u0442\u0438',\n    description=('\u0421\u0435\u0440\u0432\u0435\u0440\u043d\u0430\u044f \u0447\u0430\u0441\u0442\u044c \u0441\u0435\u0440\u0432\u0438\u0441\u0430 \u0434\u043b\u044f \u0432\u044b\u0434\u0430\u0447\u0438 \u043f\u0435\u0447\u0435\u043d\u0435\u043a \u0437\u0430 \u0430\u043a\u0442\u0438\u0432\u043d\u043e\u0441\u0442\u0438'),\n    version=__version__,\n    # \u041d\u0430\u0441\u0442\u0440\u0430\u0438\u0432\u0430\u0435\u043c \u0438\u043d\u0442\u0435\u0440\u043d\u0435\u0442 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u044e", "    version=__version__,\n    # \u041d\u0430\u0441\u0442\u0440\u0430\u0438\u0432\u0430\u0435\u043c \u0438\u043d\u0442\u0435\u0440\u043d\u0435\u0442 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u044e\n    root_path=settings.ROOT_PATH if __version__ != 'dev' else '/',\n    docs_url=None if __version__ != 'dev' else '/docs',\n    redoc_url=None,\n)\ntelegram = get_telegram()\n\n\napp.add_middleware(", "\napp.add_middleware(\n    DBSessionMiddleware,\n    db_url=str(settings.DB_DSN),\n    engine_args={\"pool_pre_ping\": True, \"isolation_level\": \"AUTOCOMMIT\"},\n)\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=settings.CORS_ALLOW_ORIGINS,", "    CORSMiddleware,\n    allow_origins=settings.CORS_ALLOW_ORIGINS,\n    allow_credentials=settings.CORS_ALLOW_CREDENTIALS,\n    allow_methods=settings.CORS_ALLOW_METHODS,\n    allow_headers=settings.CORS_ALLOW_HEADERS,\n)\n\n\n@app.on_event(\"startup\")\nasync def startup():", "@app.on_event(\"startup\")\nasync def startup():\n    await telegram.initialize()\n    await telegram.start()\n\n\n@app.on_event(\"shutdown\")\nasync def shutdown():\n    await telegram.stop()\n    await telegram.shutdown()", "    await telegram.stop()\n    await telegram.shutdown()\n\n\napp.include_router(github_rourer)\napp.include_router(telegram_rourer)\n"]}
{"filename": "social/routes/__init__.py", "chunked_list": [""]}
{"filename": "social/routes/github.py", "chunked_list": ["import logging\n\nfrom fastapi import APIRouter, BackgroundTasks, Request\nfrom fastapi_sqlalchemy import db\n\nfrom social.handlers_github import process_event\nfrom social.models.webhook_storage import WebhookStorage, WebhookSystems\nfrom social.settings import get_settings\n\n", "\n\nrouter = APIRouter(prefix=\"/github\", tags=[\"webhooks\"])\nsettings = get_settings()\nlogger = logging.getLogger(__name__)\n\n\n@router.post('')\nasync def github_webhook(request: Request, background_tasks: BackgroundTasks):\n    \"\"\"\u041f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u0442 \u043b\u044e\u0431\u043e\u0439 POST \u0437\u0430\u043f\u0440\u043e\u0441 \u043e\u0442 github\"\"\"", "async def github_webhook(request: Request, background_tasks: BackgroundTasks):\n    \"\"\"\u041f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u0442 \u043b\u044e\u0431\u043e\u0439 POST \u0437\u0430\u043f\u0440\u043e\u0441 \u043e\u0442 github\"\"\"\n    request_data = await request.json()\n    logger.debug(request_data)\n\n    db.session.add(\n        WebhookStorage(\n            system=WebhookSystems.GITHUB,\n            message=request_data,\n        )", "            message=request_data,\n        )\n    )\n    db.session.commit()\n\n    background_tasks.add_task(process_event, request_data)\n\n    return\n", ""]}
{"filename": "social/routes/telegram.py", "chunked_list": ["import logging\n\nfrom fastapi import APIRouter, Request\nfrom fastapi_sqlalchemy import db\nfrom telegram import Update\n\nfrom social.handlers_telegram import get_application\nfrom social.models.webhook_storage import WebhookStorage, WebhookSystems\nfrom social.settings import get_settings\n", "from social.settings import get_settings\n\n\nrouter = APIRouter(prefix=\"/telegram\", tags=[\"webhooks\"])\nsettings = get_settings()\nlogger = logging.getLogger(__name__)\napplication = get_application()\n\n\n@router.post('')", "\n@router.post('')\nasync def telegram_webhook(request: Request):\n    \"\"\"\u041f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u0442 \u043b\u044e\u0431\u043e\u0439 POST \u0437\u0430\u043f\u0440\u043e\u0441 \u043e\u0442 Telegram\"\"\"\n    request_data = await request.json()\n    logger.debug(request_data)\n\n    db.session.add(\n        WebhookStorage(\n            system=WebhookSystems.TELEGRAM,", "        WebhookStorage(\n            system=WebhookSystems.TELEGRAM,\n            message=request_data,\n        )\n    )\n    db.session.commit()\n\n    await application.update_queue.put(Update.de_json(data=request_data, bot=application.bot))\n    return\n", "    return\n"]}
{"filename": "tests/__init__.py", "chunked_list": [""]}
{"filename": "tests/conftest.py", "chunked_list": [""]}
{"filename": "tests/github_processor.py", "chunked_list": ["from datetime import datetime\n\nimport pytest\n\nfrom social.handlers_github.base import EventProcessor\n\n\n@pytest.fixture\ndef event():\n    return {\n        \"action\": \"resolved\",\n        \"created_at\": \"2023-03-12T18:18:13Z\",\n        \"updated_at\": \"2023-03-12T18:29:58Z\",\n        \"has_issues\": True,\n        \"has_projects\": False,\n        \"topics\": [\n          \"auth-service\"\n        ],\n        \"id\": 94626404,\n    }", "def event():\n    return {\n        \"action\": \"resolved\",\n        \"created_at\": \"2023-03-12T18:18:13Z\",\n        \"updated_at\": \"2023-03-12T18:29:58Z\",\n        \"has_issues\": True,\n        \"has_projects\": False,\n        \"topics\": [\n          \"auth-service\"\n        ],\n        \"id\": 94626404,\n    }", "\n\ndef test_str_filter(event: dict):\n    p = EventProcessor(\n        dict(action=\"resolved\"),\n        lambda e: None\n    )\n    assert p.check_and_process(event) is True\n\n\ndef test_lambda_filter(event: dict):\n    p = EventProcessor(\n        {\n            \"created_at\": lambda v: datetime.fromisoformat(v).month == 3\n        },\n        lambda e: None\n    )\n    assert p.check_and_process(event) is True", "\n\ndef test_lambda_filter(event: dict):\n    p = EventProcessor(\n        {\n            \"created_at\": lambda v: datetime.fromisoformat(v).month == 3\n        },\n        lambda e: None\n    )\n    assert p.check_and_process(event) is True", "\ndef test_str_filter_fail(event: dict):\n    p = EventProcessor(\n        dict(action=\"approved\"),\n        lambda e: None\n    )\n    assert p.check_and_process(event) is False\n\n\ndef test_lambda_filter_fail(event: dict):\n    p = EventProcessor(\n        {\n            \"created_at\": lambda v: datetime.fromisoformat(v).year < 2023\n        },\n        lambda e: None\n    )\n    assert p.check_and_process(event) is False", "\ndef test_lambda_filter_fail(event: dict):\n    p = EventProcessor(\n        {\n            \"created_at\": lambda v: datetime.fromisoformat(v).year < 2023\n        },\n        lambda e: None\n    )\n    assert p.check_and_process(event) is False\n", "\n\ndef test_regex_filter(event: dict):\n    p = EventProcessor(\n        {\n            \"created_at\": \"2023\",\n            \"updated_at\": r\"\\d\\d\\d\\d-\\d\\d-\\d\\d\",\n        },\n        lambda e: None\n    )\n    assert p.check_and_process(event) is True", ""]}
{"filename": "migrations/env.py", "chunked_list": ["from logging.config import fileConfig\n\nfrom alembic import context\nfrom sqlalchemy import engine_from_config, pool\n\nfrom social.models.base import Base\nfrom social.settings import get_settings\n\n\n# this is the Alembic Config object, which provides", "\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\nsettings = get_settings()\n\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nif config.config_file_name is not None:\n    fileConfig(config.config_file_name)", "if config.config_file_name is not None:\n    fileConfig(config.config_file_name)\n\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata\ntarget_metadata = Base.metadata\n\n# other values from the config, defined by the needs of env.py,", "\n# other values from the config, defined by the needs of env.py,\n# can be acquired:\n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\n\n\ndef run_migrations_offline():\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    url = config.get_main_option(\"sqlalchemy.url\")\n    context.configure(\n        url=url,\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()", "\n\ndef run_migrations_online():\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    configuration = config.get_section(config.config_ini_section)\n    configuration['sqlalchemy.url'] = str(settings.DB_DSN)\n    connectable = engine_from_config(\n        configuration,\n        prefix=\"sqlalchemy.\",\n        poolclass=pool.NullPool,\n    )\n\n    with connectable.connect() as connection:\n        context.configure(connection=connection, target_metadata=target_metadata)\n\n        with context.begin_transaction():\n            context.run_migrations()", "\n\nif context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()\n"]}
{"filename": "migrations/versions/57c72962d2b4_webhook_storage.py", "chunked_list": ["\"\"\"webhook storage\n\nRevision ID: 57c72962d2b4\nRevises:\nCreate Date: 2023-03-12 14:22:34.958257\n\n\"\"\"\nimport sqlalchemy as sa\nfrom alembic import op\n", "from alembic import op\n\n\n# revision identifiers, used by Alembic.\nrevision = '57c72962d2b4'\ndown_revision = None\nbranch_labels = None\ndepends_on = None\n\n\ndef upgrade():\n    op.create_table(\n        'webhook_storage',\n        sa.Column('id', sa.Integer(), nullable=False),\n        sa.Column('system', sa.Enum('TELEGRAM', 'GITHUB', name='webhooksystems', native_enum=False), nullable=False),\n        sa.Column('message', sa.JSON(none_as_null=True), nullable=False),\n        sa.PrimaryKeyConstraint('id'),\n    )", "\n\ndef upgrade():\n    op.create_table(\n        'webhook_storage',\n        sa.Column('id', sa.Integer(), nullable=False),\n        sa.Column('system', sa.Enum('TELEGRAM', 'GITHUB', name='webhooksystems', native_enum=False), nullable=False),\n        sa.Column('message', sa.JSON(none_as_null=True), nullable=False),\n        sa.PrimaryKeyConstraint('id'),\n    )", "\n\ndef downgrade():\n    op.drop_table('webhook_storage')\n"]}
