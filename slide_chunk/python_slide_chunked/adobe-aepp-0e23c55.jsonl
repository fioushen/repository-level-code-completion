{"filename": "setup.py", "chunked_list": ["#  Copyright 2023 Adobe. All rights reserved.\n#  This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License. You may obtain a copy\n#  of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software distributed under\n#  the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n#  OF ANY KIND, either express or implied. See the License for the specific language\n#  governing permissions and limitations under the License.\n", "#  governing permissions and limitations under the License.\n\nimport codecs\nimport os\n\nimport setuptools\n\ndef read(rel_path: str):\n    here = os.path.abspath(os.path.dirname(__file__))\n    with codecs.open(os.path.join(here, rel_path), 'r') as fp:\n        return fp.read()", "\n\ndef get_version(rel_path: str):\n    for line in read(rel_path).splitlines():\n        if line.startswith('__version__'):\n            delim = '\"' if '\"' in line else \"'\"\n            return line.split(delim)[1]\n    else:\n        raise RuntimeError(\"Unable to find version string.\")\n\nwith open(\"README.md\", \"r\") as fh:\n    long_description = fh.read()", "\nwith open(\"README.md\", \"r\") as fh:\n    long_description = fh.read()\n\nsetuptools.setup(\n    name=\"aepp\",  # Replace with your own username\n    version=get_version(\"aepp/__version__.py\"),\n    author=\"Julien Piccini\",\n    author_email=\"piccini.julien@gmail.com\",\n    description=\"Package to manage AEP API endpoint and some helper functions\",", "    author_email=\"piccini.julien@gmail.com\",\n    description=\"Package to manage AEP API endpoint and some helper functions\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    url=\"https://github.com/adobe/aepp\",\n    packages=setuptools.find_packages(),\n    include_package_data=True,\n    classifiers=[\n        \"Programming Language :: Python :: 3\",\n        \"Operating System :: OS Independent\",", "        \"Programming Language :: Python :: 3\",\n        \"Operating System :: OS Independent\",\n        \"License :: OSI Approved :: GNU General Public License v3 (GPLv3)\",\n        \"Topic :: Utilities\",\n        \"Topic :: Internet\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Development Status :: 2 - Pre-Alpha\"\n    ],\n    python_requires='>=3.6',\n    install_requires=['pandas', \"requests\",", "    python_requires='>=3.6',\n    install_requires=['pandas', \"requests\",\n                      \"PyJWT\", \"pathlib2\", \"pathlib\", \"PyJWT[crypto]\", \"tenacity\"],\n)\n"]}
{"filename": "tests/schema_test.py", "chunked_list": ["#  Copyright 2023 Adobe. All rights reserved.\n#  This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License. You may obtain a copy\n#  of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software distributed under\n#  the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n#  OF ANY KIND, either express or implied. See the License for the specific language\n#  governing permissions and limitations under the License.\n", "#  governing permissions and limitations under the License.\n\nfrom aepp.schema import Schema\nimport unittest\nfrom unittest.mock import patch, MagicMock\n\n\nclass SchemaTest(unittest.TestCase):\n\n    @patch(\"aepp.connector.AdobeRequest\")\n    def test_schema_get_resource(self, mock_connector):\n        instance_conn = mock_connector.return_value\n        instance_conn.getData.return_value = \"foo\"\n        schema_obj = Schema()\n        result = schema_obj.getResource(MagicMock(), MagicMock(), MagicMock(), MagicMock())\n        assert(result is not None)\n        instance_conn.getData.assert_called_once()\n\n    @patch(\"aepp.connector.AdobeRequest\")\n    def test_schema_update_sandbox(self, mock_connector):\n        schema_obj = Schema()\n        test_sandbox = \"prod\"\n        schema_obj.updateSandbox(test_sandbox)\n        assert(schema_obj.sandbox == test_sandbox)\n\n    @patch(\"aepp.connector.AdobeRequest\")\n    def test_schema_get_stats(self, mock_connector):\n        instance_conn = mock_connector.return_value\n        instance_conn.getData.return_value = MagicMock()\n        schema_obj = Schema()\n        stats_result = schema_obj.getStats()\n        assert (stats_result is not None)\n        assert(stats_result == instance_conn.getData.return_value)\n        instance_conn.getData.assert_called_once()\n\n    @patch(\"aepp.connector.AdobeRequest\")\n    def test_schema_get_tenant_id(self, mock_connector):\n        instance_conn = mock_connector.return_value\n        instance_conn.getStats.return_value = MagicMock()\n        schema_obj = Schema()\n        tenant_id_result = schema_obj.getTenantId()\n        assert (tenant_id_result is not None)\n        instance_conn.getData.assert_called_once()\n\n    @patch(\"aepp.connector.AdobeRequest\")\n    def test_schema_get_behavior(self, mock_connector):\n        instance_conn = mock_connector.return_value\n        instance_conn.getData.return_value = {\"results\":[1234,5678]}\n        schema_obj = Schema()\n        stats_result = schema_obj.getBehaviors()\n        assert (stats_result is not None)\n        assert (stats_result == instance_conn.getData.return_value.get(\"results\"))\n        instance_conn.getData.assert_called_once()"]}
{"filename": "tests/catalog_test.py", "chunked_list": ["#  Copyright 2023 Adobe. All rights reserved.\n#  This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License. You may obtain a copy\n#  of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software distributed under\n#  the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n#  OF ANY KIND, either express or implied. See the License for the specific language\n#  governing permissions and limitations under the License.\n", "#  governing permissions and limitations under the License.\n\nfrom aepp.schema import Schema\nimport unittest\nfrom unittest.mock import patch, MagicMock\n\n\nclass CatalogTest(unittest.TestCase):\n\n    def test_catalog_get_catalog__resource(self):\n        assert True\n\n    def test_catalog_decode_stream_batch(self):\n        assert True\n\n\n    def test_catalog_json_stream_messages(self):\n        assert True\n\n    def test_catalog_get_batches(self):\n        assert True\n\n    def test_catalog_get_failed_batches_df(self):\n        assert True\n\n    def test_catalog_get_batch(self):\n        assert True\n\n    def test_catalog_create_batch(self):\n        assert True\n\n    def test_catalog_get_resources(self):\n        assert True\n\n    def test_catalog_get_data_sets(self):\n        assert True\n\n    def test_catalog_create_datasets(self):\n        assert True\n\n    def test_catalog_get_data_set(self):\n        assert True\n\n    def test_catalog_delete_data_set(self):\n        assert True\n\n    def test_catalog_get_data_set_views(self):\n        assert True\n\n    def test_catalog_get_data_set_view(self):\n        assert True\n\n    def test_catalog_get_dataset_view_files(self):\n        assert True\n\n    def test_catalog_enable_dataset_profile(self):\n       assert True\n\n    def test_catalog_enable_dataset_identity(self):\n        assert True\n\n    def test_catalog_disable_dataset_profile(self):\n        assert True\n\n    def test_catalog_disable_dataset_identity(self):\n        assert True\n\n    def test_catalog_create_union_profile_dataset(self):\n        assert True\n\n    def test_catalog_get_mapper_errors(self):\n        assert True"]}
{"filename": "tests/__init__.py", "chunked_list": ["#  Copyright 2023 Adobe. All rights reserved.\n#  This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License. You may obtain a copy\n#  of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software distributed under\n#  the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n#  OF ANY KIND, either express or implied. See the License for the specific language\n#  governing permissions and limitations under the License.\n", "#  governing permissions and limitations under the License.\n\n"]}
{"filename": "tests/destinationinstanceservice_test.py", "chunked_list": ["#  Copyright 2023 Adobe. All rights reserved.\n#  This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License. You may obtain a copy\n#  of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software distributed under\n#  the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n#  OF ANY KIND, either express or implied. See the License for the specific language\n#  governing permissions and limitations under the License.\n", "#  governing permissions and limitations under the License.\n\nfrom aepp.destinationinstanceservice import DestinationInstanceService\nimport unittest\nfrom unittest.mock import patch, MagicMock, ANY\n\n\nclass DestinationInstanceServiceTest(unittest.TestCase):\n    ADHOC_INPUT = {\"flow1\": [\"dataset1\"], \"flow2\": [\"dataset2\", \"dataset3\"]}\n    ADHOC_EXPECTED_PAYLOAD = {'activationInfo': {'destinations': [{'flowId': 'flow1', 'datasets': [{'id': 'dataset1'}]}, {'flowId': 'flow2', 'datasets': [{'id': 'dataset2'}, {'id': 'dataset3'}]}]}}\n    \n    @patch(\"aepp.connector.AdobeRequest\")\n    def test_create_adhoc_dataset_export(self, mock_connector):\n        instance_conn = mock_connector.return_value\n        instance_conn.postData.return_value = {'foo'}\n        destination_instance_service_obj = DestinationInstanceService()\n        result = destination_instance_service_obj.createAdHocDatasetExport(self.ADHOC_INPUT)\n        assert(result is not None)\n        instance_conn.postData.assert_called_once()\n        instance_conn.postData.assert_called_with(ANY, data=self.ADHOC_EXPECTED_PAYLOAD)\n\n    @patch(\"aepp.connector.AdobeRequest\")\n    def test_create_adhoc_dataset_export_invalid_input(self, mock_connector):\n        destination_instance_service_obj = DestinationInstanceService()\n        with self.assertRaises(Exception) as cm:\n            destination_instance_service_obj.createAdHocDatasetExport(None)\n        self.assertEqual('Require a dict for defining the flowId to datasetIds mapping', str(cm.exception))", "    "]}
{"filename": "tests/datasets_test.py", "chunked_list": ["#  Copyright 2023 Adobe. All rights reserved.\n#  This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License. You may obtain a copy\n#  of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software distributed under\n#  the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n#  OF ANY KIND, either express or implied. See the License for the specific language\n#  governing permissions and limitations under the License.\n", "#  governing permissions and limitations under the License.\n\nfrom aepp.schema import Schema\nimport unittest\nfrom unittest.mock import patch, MagicMock\n\nclass DatasetsTest(unittest.TestCase):\n\n    def test_datasets_get_label_schema(self):\n        assert True\n\n    def test_datasets_head_label(self):\n        assert True\n\n    def test_datasets_delete_labels(self):\n        assert True\n\n    def test_datasets_create_labels(self):\n        assert True\n\n    def test_datasets_update_labels(self):\n        assert True", ""]}
{"filename": "tests/flowservice_test.py", "chunked_list": ["#  Copyright 2023 Adobe. All rights reserved.\n#  This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License. You may obtain a copy\n#  of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software distributed under\n#  the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n#  OF ANY KIND, either express or implied. See the License for the specific language\n#  governing permissions and limitations under the License.\n", "#  governing permissions and limitations under the License.\n\nfrom aepp.schema import Schema\nimport unittest\nfrom unittest.mock import patch, MagicMock\n\n\nclass FlowserviceTest(unittest.TestCase):\n\n    def test_flowservice_get_resource(self):\n        assert True\n\n    def test_flowservice_get_connections(self):\n        assert True\n\n    def test_flowservice_create_connection(self):\n        assert True\n\n    def test_flowservice_create_streaming_connection(self):\n        assert True\n\n    def test_flowservice_get_connection(self):\n        assert True\n\n    def test_flowservice_connection(self):\n        assert True\n\n    def test_flowservice_delete_connection(self):\n        assert True\n\n    def test_flowservice_get_connection_specs(self):\n        assert True\n\n    def test_flowservice_get_connection_specs_map(self):\n        assert True\n\n    def test_flowservice_get_connection_spec(self):\n        assert True\n\n    def test_flowservice_get_connection_specid_from_name(self):\n        assert True\n\n    def test_flowservice_get_flows(self):\n        assert True\n\n    def test_flowservice_get_flow(self):\n        assert True\n\n    def test_flowservice_delete_flow(self):\n        assert True\n\n    def test_flowservice_create_flow(self):\n        assert True\n\n    def test_flowservice_create_flow_data_lake_to_data_landing_zone(self):\n        assert True\n\n    def test_flowservice_create_data_landing_zone_to_datalake(self):\n        assert True\n\n    def test_flowservice_updateFlow(self):\n        assert True\n\n    def test_flowservice_get_flow_specs(self):\n        assert True\n\n    def test_flowservice_get_flow_spec_id_from_names(self):\n         assert True\n\n    def test_flowservice_get_flow_spec(self):\n        assert True\n\n    def test_flowservice_get_runs(self):\n        assert True\n\n    def test_flowservice_create_run(self):\n        assert True\n\n    def test_flowservice_get_run(self):\n        assert True\n\n    def test_flowservice_get_source_connections(self):\n        assert True\n\n    def test_flowservice_get_source_connection(self):\n        assert True\n\n\n    def test_flowsevrice_delete_source_connection(self):\n        assert True\n\n    def test_flowservice_create_source_connection(self):\n        assert True\n\n    def test_flowservice_create_source_connection_streaming(self):\n        assert True\n\n    def test_flowservice_create_source_connectionDataLandingZone(self):\n        assert True\n\n    def test_flowservice_create_source_connection_datalake(self):\n        assert True\n\n    def test_flowservice_update_source_connection(self):\n        assert True\n\n\n    def test_flowservice_get_target_connections(self):\n        assert True\n\n    def test_flowservice_get_target_connection(self):\n        assert True\n\n    def test_flowservice_delete_target_connection(self):\n        assert True\n\n    def test_flowservice_create_target_connection(self):\n        assert True\n\n    def test_flowservice_create_target_connection_data_landin_zone(self):\n        assert True\n\n    def test_flowservice_create_target_connection_datalake(self):\n        assert True\n\n    def test_flowservice_update_target_connection(self):\n        assert True\n\n    def test_flowservice_update_policy(self):\n        assert True\n\n    def test_flowservice_get_landing_zone_container(self):\n        assert True\n\n    def test_flowservice_get_landing_zone_credential(self):\n        assert True\n\n    def test_flowservice_explore_landing_zone(self):\n        assert True\n\n    def test_flowservice_get_landing_zone_content(self):\n        assert True", ""]}
{"filename": "tests/exportDatasetToDatalandingZone_test.py", "chunked_list": ["#  Copyright 2023 Adobe. All rights reserved.\n#  This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License. You may obtain a copy\n#  of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software distributed under\n#  the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n#  OF ANY KIND, either express or implied. See the License for the specific language\n#  governing permissions and limitations under the License.\n", "#  governing permissions and limitations under the License.\n\nfrom aepp.exportDatasetToDataLandingZone import ExportDatasetToDataLandingZone\nimport unittest\nfrom unittest.mock import patch, MagicMock, ANY\nfrom tenacity import RetryError\n\n\nclass ExportDatasetToDataLandingZoneTest(unittest.TestCase):\n    flow_response = {\n        \"id\": \"df193495-9837-407f-9d50-e51efc067cb5\",\n        \"sourceConnectionIds\": [\n            \"78754315-852c-4c4e-8f1a-d12b83264f3f\"\n        ],\n        \"state\": \"disabled\",\n        \"etag\": \"test_etag\"}\n\n    connection_spec = {\n        \"name\": \"test\",\n        \"id\": \"test_connection_id\"\n    }\n\n\n    source_connection = {\n        \"id\": \"test_source_connection_id\",\n        \"params\": {\n            \"datasets\": [{\n                \"dataSetId\": \"test\"\n            }]}\n    }\n\n    base_connection = {\n        \"id\": \"test_base_connection_id\"\n    }\n\n    target_connection = {\n        \"id\": \"test_target_connection_id\"\n    }\n\n    flow_run = {\n        \"items\": [\n            {\n                \"id\": \"test_id\",\n                \"metrics\": {\n                    \"durationSummary\": {\n                        \"startedAtUTC\": 1691184699,\n                        \"completedAtUTC\": 1691184819\n                    },\n                    \"fileSummary\": {\n                        \"outputFileCount\": 24\n                    },\n                    \"sizeSummary\": {\n                        \"outputBytes\": 77494320\n                    },\n                    \"recordSummary\": {\n                        \"outputRecordCount\": 1065802\n                    }\n                }\n            }\n        ]\n    }\n\n    adhoc_success_response = {\n        \"destinations\":[\n            {\n                \"datasets\":[\n                    {\n                        \"id\":\"641ce00b8f31811b98dd3b56\",\n                        \"statusURL\":\"https: //platform-stage.adobe.io/data/foundation/flowservice/runs/aa39ad3d-24ba-4579-9cdc-55536c408721\",\n                        \"flowId\":\"3eaa2c0b-e24b-46bd-8eee-bbaf9d6cf2cb\"\n                    }\n                ]\n            }\n        ]\n    }\n\n\n    adhoc_non_retry_error = {\n        \"error_code\": \"401013\",\n        \"message\": \"Oauth token is not valid\"\n    }\n\n    adhoc_retry_error = {\n        \"message\": \"Following order ID(s) are not ready for dataset export\"\n    }\n\n    config = {\n        \"org_id\": \"3ADF23C463D98F640A494032@AdobeOrg\",\n        \"client_id\": \"35e6e4d205274c4ca1418805ac41153b\",\n        \"tech_id\": \"test005@techacct.adobe.com\",\n        \"pathToKey\": \"/Users/Downloads/config/private.key\",\n        \"auth_code\": \"\",\n        \"secret\": \"test\",\n        \"date_limit\": 0,\n        \"sandbox\": \"prod\",\n        \"environment\": \"stage\",\n        \"token\": \"token\",\n        \"jwtTokenEndpoint\": \"https://ims-na1.adobelogin.com/ims/exchange/jwt/\",\n        \"oauthTokenEndpoint\": \"\",\n        \"imsEndpoint\": \"https://ims-na1-stg1.adobelogin.com\",\n        \"private_key\": \"\"\n    }\n\n    @patch('aepp.utils.Utils.check_if_exists', MagicMock(return_value = \"test_dataflow_id\"))\n    @patch('aepp.flowservice.FlowService.getFlow', MagicMock(return_value = flow_response))\n    @patch('aepp.flowservice.FlowService.getSourceConnection', MagicMock(return_value = source_connection))\n    @patch('aepp.flowservice.FlowService.getRun', MagicMock(return_value = flow_run))\n    @patch('aepp.destinationinstanceservice.DestinationInstanceService.createAdHocDatasetExport', MagicMock(return_value = adhoc_success_response))\n    @patch(\"aepp.connector.AdobeRequest\", MagicMock())\n    def test_create_dataflow_if_exist(self):\n        export_obj = ExportDatasetToDataLandingZone(config= self.config, header= MagicMock())\n        export_obj.createDataFlowRunIfNotExists(dataset_id=\"test\", compression_type=\"gzip\", data_format=\"parquet\", export_path=\"test\", on_schedule=False, config_path=\"test\", entity_name=\"test\", initial_delay=0)\n\n    @patch('aepp.utils.Utils.check_if_exists', MagicMock(return_value = \"test_dataflow_id\"))\n    @patch('aepp.flowservice.FlowService.getFlow', MagicMock(return_value = flow_response))\n    @patch('aepp.flowservice.FlowService.getSourceConnection', MagicMock(return_value = source_connection))\n    @patch(\"aepp.connector.AdobeRequest\", MagicMock())\n    def test_create_dataflow_on_schedule(self):\n        export_obj = ExportDatasetToDataLandingZone(config= self.config, header= MagicMock())\n        export_obj.createDataFlowRunIfNotExists(dataset_id=\"test\", compression_type=\"gzip\", data_format=\"parquet\", export_path=\"test\", on_schedule=True, config_path=\"test\",entity_name=\"test\", initial_delay=0)\n\n    @patch('aepp.flowservice.FlowService.createConnection', MagicMock(return_value = base_connection))\n    @patch('aepp.flowservice.FlowService.getConnectionSpecIdFromName', MagicMock(return_value = connection_spec))\n    @patch('aepp.flowservice.FlowService.createSourceConnection', MagicMock(return_value = source_connection))\n    @patch('aepp.flowservice.FlowService.createTargetConnection', MagicMock(return_value = target_connection))\n    @patch('aepp.flowservice.FlowService.createFlow', MagicMock(return_value = flow_response))\n    @patch('aepp.utils.Utils.save_field_in_config', MagicMock())\n    @patch(\"aepp.connector.AdobeRequest\", MagicMock())\n    def test_create_dataflow_if_not_exist(self):\n        export_obj = ExportDatasetToDataLandingZone(config= self.config, header= MagicMock())\n        return_dataflow_id = export_obj.createDataFlow(dataset_id=\"test\", compression_type=\"gzip\", data_format=\"parquet\", export_path=\"test\", on_schedule=False, config_path=\"test\", entity_name=\"test\")\n        assert (return_dataflow_id == self.flow_response[\"id\"])\n\n    @patch('aepp.destinationinstanceservice.DestinationInstanceService.createAdHocDatasetExport', MagicMock(return_value = adhoc_success_response))\n    @patch(\"aepp.connector.AdobeRequest\", MagicMock())\n    def test_retry_on_success_response(self):\n        export_obj = ExportDatasetToDataLandingZone(config= self.config, header= MagicMock())\n        assert(export_obj.retryOnNotReadyException(\"test\", \"test\", 1, 1) == self.adhoc_success_response)\n\n    @patch('aepp.destinationinstanceservice.DestinationInstanceService.createAdHocDatasetExport', MagicMock(return_value = adhoc_non_retry_error))\n    @patch(\"aepp.connector.AdobeRequest\", MagicMock())\n    def test_no_retry_error(self):\n        export_obj = ExportDatasetToDataLandingZone(config= self.config, header= MagicMock())\n        assert (export_obj.retryOnNotReadyException(\"test\", \"test\", 1, 1) == self.adhoc_non_retry_error)\n\n    @patch('aepp.destinationinstanceservice.DestinationInstanceService.createAdHocDatasetExport', MagicMock(return_value = adhoc_retry_error))\n    @patch(\"aepp.connector.AdobeRequest\", MagicMock())\n    def test_retry_error(self):\n        export_obj = ExportDatasetToDataLandingZone(config= self.config, header= MagicMock())\n        try:\n            export_obj.retryOnNotReadyException(\"test\", \"test\", 1, 1)\n            self.fail(\"expect a retry error\")\n        except RetryError:\n            pass", "class ExportDatasetToDataLandingZoneTest(unittest.TestCase):\n    flow_response = {\n        \"id\": \"df193495-9837-407f-9d50-e51efc067cb5\",\n        \"sourceConnectionIds\": [\n            \"78754315-852c-4c4e-8f1a-d12b83264f3f\"\n        ],\n        \"state\": \"disabled\",\n        \"etag\": \"test_etag\"}\n\n    connection_spec = {\n        \"name\": \"test\",\n        \"id\": \"test_connection_id\"\n    }\n\n\n    source_connection = {\n        \"id\": \"test_source_connection_id\",\n        \"params\": {\n            \"datasets\": [{\n                \"dataSetId\": \"test\"\n            }]}\n    }\n\n    base_connection = {\n        \"id\": \"test_base_connection_id\"\n    }\n\n    target_connection = {\n        \"id\": \"test_target_connection_id\"\n    }\n\n    flow_run = {\n        \"items\": [\n            {\n                \"id\": \"test_id\",\n                \"metrics\": {\n                    \"durationSummary\": {\n                        \"startedAtUTC\": 1691184699,\n                        \"completedAtUTC\": 1691184819\n                    },\n                    \"fileSummary\": {\n                        \"outputFileCount\": 24\n                    },\n                    \"sizeSummary\": {\n                        \"outputBytes\": 77494320\n                    },\n                    \"recordSummary\": {\n                        \"outputRecordCount\": 1065802\n                    }\n                }\n            }\n        ]\n    }\n\n    adhoc_success_response = {\n        \"destinations\":[\n            {\n                \"datasets\":[\n                    {\n                        \"id\":\"641ce00b8f31811b98dd3b56\",\n                        \"statusURL\":\"https: //platform-stage.adobe.io/data/foundation/flowservice/runs/aa39ad3d-24ba-4579-9cdc-55536c408721\",\n                        \"flowId\":\"3eaa2c0b-e24b-46bd-8eee-bbaf9d6cf2cb\"\n                    }\n                ]\n            }\n        ]\n    }\n\n\n    adhoc_non_retry_error = {\n        \"error_code\": \"401013\",\n        \"message\": \"Oauth token is not valid\"\n    }\n\n    adhoc_retry_error = {\n        \"message\": \"Following order ID(s) are not ready for dataset export\"\n    }\n\n    config = {\n        \"org_id\": \"3ADF23C463D98F640A494032@AdobeOrg\",\n        \"client_id\": \"35e6e4d205274c4ca1418805ac41153b\",\n        \"tech_id\": \"test005@techacct.adobe.com\",\n        \"pathToKey\": \"/Users/Downloads/config/private.key\",\n        \"auth_code\": \"\",\n        \"secret\": \"test\",\n        \"date_limit\": 0,\n        \"sandbox\": \"prod\",\n        \"environment\": \"stage\",\n        \"token\": \"token\",\n        \"jwtTokenEndpoint\": \"https://ims-na1.adobelogin.com/ims/exchange/jwt/\",\n        \"oauthTokenEndpoint\": \"\",\n        \"imsEndpoint\": \"https://ims-na1-stg1.adobelogin.com\",\n        \"private_key\": \"\"\n    }\n\n    @patch('aepp.utils.Utils.check_if_exists', MagicMock(return_value = \"test_dataflow_id\"))\n    @patch('aepp.flowservice.FlowService.getFlow', MagicMock(return_value = flow_response))\n    @patch('aepp.flowservice.FlowService.getSourceConnection', MagicMock(return_value = source_connection))\n    @patch('aepp.flowservice.FlowService.getRun', MagicMock(return_value = flow_run))\n    @patch('aepp.destinationinstanceservice.DestinationInstanceService.createAdHocDatasetExport', MagicMock(return_value = adhoc_success_response))\n    @patch(\"aepp.connector.AdobeRequest\", MagicMock())\n    def test_create_dataflow_if_exist(self):\n        export_obj = ExportDatasetToDataLandingZone(config= self.config, header= MagicMock())\n        export_obj.createDataFlowRunIfNotExists(dataset_id=\"test\", compression_type=\"gzip\", data_format=\"parquet\", export_path=\"test\", on_schedule=False, config_path=\"test\", entity_name=\"test\", initial_delay=0)\n\n    @patch('aepp.utils.Utils.check_if_exists', MagicMock(return_value = \"test_dataflow_id\"))\n    @patch('aepp.flowservice.FlowService.getFlow', MagicMock(return_value = flow_response))\n    @patch('aepp.flowservice.FlowService.getSourceConnection', MagicMock(return_value = source_connection))\n    @patch(\"aepp.connector.AdobeRequest\", MagicMock())\n    def test_create_dataflow_on_schedule(self):\n        export_obj = ExportDatasetToDataLandingZone(config= self.config, header= MagicMock())\n        export_obj.createDataFlowRunIfNotExists(dataset_id=\"test\", compression_type=\"gzip\", data_format=\"parquet\", export_path=\"test\", on_schedule=True, config_path=\"test\",entity_name=\"test\", initial_delay=0)\n\n    @patch('aepp.flowservice.FlowService.createConnection', MagicMock(return_value = base_connection))\n    @patch('aepp.flowservice.FlowService.getConnectionSpecIdFromName', MagicMock(return_value = connection_spec))\n    @patch('aepp.flowservice.FlowService.createSourceConnection', MagicMock(return_value = source_connection))\n    @patch('aepp.flowservice.FlowService.createTargetConnection', MagicMock(return_value = target_connection))\n    @patch('aepp.flowservice.FlowService.createFlow', MagicMock(return_value = flow_response))\n    @patch('aepp.utils.Utils.save_field_in_config', MagicMock())\n    @patch(\"aepp.connector.AdobeRequest\", MagicMock())\n    def test_create_dataflow_if_not_exist(self):\n        export_obj = ExportDatasetToDataLandingZone(config= self.config, header= MagicMock())\n        return_dataflow_id = export_obj.createDataFlow(dataset_id=\"test\", compression_type=\"gzip\", data_format=\"parquet\", export_path=\"test\", on_schedule=False, config_path=\"test\", entity_name=\"test\")\n        assert (return_dataflow_id == self.flow_response[\"id\"])\n\n    @patch('aepp.destinationinstanceservice.DestinationInstanceService.createAdHocDatasetExport', MagicMock(return_value = adhoc_success_response))\n    @patch(\"aepp.connector.AdobeRequest\", MagicMock())\n    def test_retry_on_success_response(self):\n        export_obj = ExportDatasetToDataLandingZone(config= self.config, header= MagicMock())\n        assert(export_obj.retryOnNotReadyException(\"test\", \"test\", 1, 1) == self.adhoc_success_response)\n\n    @patch('aepp.destinationinstanceservice.DestinationInstanceService.createAdHocDatasetExport', MagicMock(return_value = adhoc_non_retry_error))\n    @patch(\"aepp.connector.AdobeRequest\", MagicMock())\n    def test_no_retry_error(self):\n        export_obj = ExportDatasetToDataLandingZone(config= self.config, header= MagicMock())\n        assert (export_obj.retryOnNotReadyException(\"test\", \"test\", 1, 1) == self.adhoc_non_retry_error)\n\n    @patch('aepp.destinationinstanceservice.DestinationInstanceService.createAdHocDatasetExport', MagicMock(return_value = adhoc_retry_error))\n    @patch(\"aepp.connector.AdobeRequest\", MagicMock())\n    def test_retry_error(self):\n        export_obj = ExportDatasetToDataLandingZone(config= self.config, header= MagicMock())\n        try:\n            export_obj.retryOnNotReadyException(\"test\", \"test\", 1, 1)\n            self.fail(\"expect a retry error\")\n        except RetryError:\n            pass"]}
{"filename": "tests/dataaccess_test.py", "chunked_list": ["#  Copyright 2023 Adobe. All rights reserved.\n#  This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License. You may obtain a copy\n#  of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software distributed under\n#  the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n#  OF ANY KIND, either express or implied. See the License for the specific language\n#  governing permissions and limitations under the License.\n", "#  governing permissions and limitations under the License.\n\nfrom aepp.schema import Schema\nimport unittest\nfrom unittest.mock import patch, MagicMock\n\nclass DataAccessTest(unittest.TestCase):\n\n    def test_dataaccess_get_batch_files(self):\n        assert True\n\n    def test_dataaccess_get_batch_failed(self):\n        assert True\n\n    def test_dataaccess_get_batch_meta(self):\n        assert True\n\n    def test_dataaccess_getHeadFile(self):\n        assert True\n\n    def test_dataaccess_get_files(self):\n        assert True\n\n    def test_dataaccess_get_preview(self):\n        assert True\n\n    def test_dataaccess_get_resource(self):\n        assert True"]}
{"filename": "aepp/catalog.py", "chunked_list": ["#  Copyright 2023 Adobe. All rights reserved.\n#  This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License. You may obtain a copy\n#  of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software distributed under\n#  the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n#  OF ANY KIND, either express or implied. See the License for the specific language\n#  governing permissions and limitations under the License.\n", "#  governing permissions and limitations under the License.\n\nimport aepp\nfrom dataclasses import dataclass\nfrom aepp import connector\nimport pandas as pd\nfrom copy import deepcopy\nfrom typing import Union\nimport time\nimport codecs", "import time\nimport codecs\nimport json\nimport logging\nfrom itertools import zip_longest\nimport re\nfrom .configs import ConnectObject\n\n@dataclass\nclass _Data:\n\n    def __init__(self):\n        self.table_names = {}\n        self.schema_ref = {}\n        self.ids = {}", "@dataclass\nclass _Data:\n\n    def __init__(self):\n        self.table_names = {}\n        self.schema_ref = {}\n        self.ids = {}\n\n\nclass Catalog:\n    \"\"\"\n    Catalog class from the AEP API. This class helps you to find where the data are coming from in AEP.\n    More details here : https://www.adobe.io/apis/experienceplatform/home/api-reference.html#\n    It possess a data attribute that is containing information about your datasets. \n    Arguments:\n        config : OPTIONAL : config object in the config module (DO NOT MODIFY)\n        header : OPTIONAL : header object  in the config module (DO NOT MODIFY)\n        loggingObject : OPTIONAL : If you want to set logging capability for your actions.\n    kwargs:\n        kwargs value will update the header\n    \"\"\"\n    loggingEnabled = False\n    logger = None\n\n    def __init__(self,\n                config : Union[dict,ConnectObject]=aepp.config.config_object,\n                header : dict=aepp.config.header,\n                loggingObject:dict=None,\n                **kwargs):\n        if loggingObject is not None and sorted([\"level\",\"stream\",\"format\",\"filename\",\"file\"]) == sorted(list(loggingObject.keys())):\n            self.loggingEnabled = True\n            self.logger = logging.getLogger(f\"{__name__}\")\n            self.logger.setLevel(loggingObject[\"level\"])\n            if type(loggingObject[\"format\"]) == str:\n                formatter = logging.Formatter(loggingObject[\"format\"])\n            elif type(loggingObject[\"format\"]) == logging.Formatter:\n                formatter = loggingObject[\"format\"]\n            if loggingObject[\"file\"]:\n                fileHandler = logging.FileHandler(loggingObject[\"filename\"])\n                fileHandler.setFormatter(formatter)\n                self.logger.addHandler(fileHandler)\n            if loggingObject[\"stream\"]:\n                streamHandler = logging.StreamHandler()\n                streamHandler.setFormatter(formatter)\n                self.logger.addHandler(streamHandler)\n        if type(config) == dict: ## Supporting either default setup or passing a ConnectObject\n            config = config\n        elif type(config) == ConnectObject:\n            header = config.getConfigHeader()\n            config = config.getConfigObject()\n        self.connector = connector.AdobeRequest(\n            config=config, \n            header=header,\n            loggingEnabled=self.loggingEnabled,\n            logger=self.logger)\n        self.header = self.connector.header\n        self.header.update(**kwargs)\n        if kwargs.get('sandbox',None) is not None: ## supporting sandbox setup on class instanciation\n            self.sandbox = kwargs.get('sandbox')\n            self.connector.config[\"sandbox\"] = kwargs.get('sandbox')\n            self.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n            self.connector.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n        else:\n            self.sandbox = self.connector.config[\"sandbox\"]\n        self.endpoint = aepp.config.endpoints['global']+aepp.config.endpoints[\"catalog\"]\n        self.data = _Data()\n\n    def getResource(self,endpoint:str=None,params:dict=None,format:str='json',save:bool=False,**kwargs)->dict:\n        \"\"\"\n        Template for requesting data with a GET method.\n        Arguments:\n            endpoint : REQUIRED : The URL to GET\n            params: OPTIONAL : dictionary of the params to fetch\n            format : OPTIONAL : Type of response returned. Possible values:\n                json : default\n                txt : text file\n                raw : a response object from the requests module\n        \"\"\"\n        if endpoint is None:\n            raise ValueError(\"Require an endpoint\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Using getResource with following format ({format}) to the following endpoint: {endpoint}\")\n        res = self.connector.getData(endpoint,params=params,format=format)\n        if save:\n            if format == 'json':\n                aepp.saveFile(module=\"catalog\",file=res,filename=f\"resource_{int(time.time())}\",type_file=\"json\",encoding=kwargs.get(\"encoding\",'utf-8'))\n            elif format == 'txt':\n                aepp.saveFile(module=\"catalog\",file=res,filename=f\"resource_{int(time.time())}\",type_file=\"txt\",encoding=kwargs.get(\"encoding\",'utf-8'))\n            else:\n                print(\"element is an object. Output is unclear. No save made.\\nPlease save this element manually\")\n        return res\n    \n    def decodeStreamBatch(self,message:str)->dict:\n        \"\"\"\n        Decode the full txt batch via the codecs module.\n        Usually the full batch is returned by the getResource method with format == \"txt\".\n        Arguments:\n            message: REQUIRED : the text file return from the failed batch message.\n        \n        return None when issue is raised\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting decodeStreamBatch\")\n        try: \n            decodeMessage = codecs.escape_decode(message)[0].decode().replace('\"body\":\"{','\"body\":{').replace('}\",\"header\":\"{','},\"header\":{').replace('}\",\"_errors\":\"{','},\"_errors\":{').replace('}\"','}')\n            return decodeMessage\n        except:\n            print(\"Issue decoding the message.\")\n            return None\n\n    def jsonStreamMessages(self,message:str,verbose:bool = False)->list:\n        \"\"\"\n        Try to create a list of dictionary messages from the decoded stream batch extracted from the decodeStreamBatch method.\n        Arguments:\n            message : REQUIRED : a decoded text file, usually returned from the decodeStreamBatch method\n            verbose : OPTIONAL : print errors and information on the decoding.\n        \n        return None when issue is raised\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting jsonStreamMessages\")\n        try:\n            myList = []\n            myYield:iter = (line for line in message.split(\"\\n\"))\n            countLine,countErrors = 0,0\n            for element in myYield:\n                countLine +=1\n                try:\n                    myList.append(json.loads(element))\n\n                except Exception as e:\n                    countErrors+=1\n                    if verbose:\n                        print(e)\n            if verbose:\n                print(f\"error rate is {(countErrors/countLine)*100:.2f}%\")\n            return myList\n        except:\n            print(\"Issue creating a stream of messages.\")\n            if self.loggingEnabled:\n                self.logger.info(f\"Issue creating a stream of messages\")\n            return None\n\n    def getLastBatches(self,dataSetId:str=None)->list:\n        \"\"\"\n        Returns the last batch from a specific datasetId.\n        Arguments:\n            dataSetId : OPTIONAL : the datasetId to be retrieved the batch about\n\n        \"\"\"\n        path = \"/lastBatches\"\n        params = {}\n        if dataSetId is not None:\n            params['dataSetId'] = dataSetId\n        res = self.connector.getData(self.endpoint+path,params=params)\n        return res\n        \n\n    def getBatches(self,limit:int=10, n_results:int=None,output:str='raw',**kwargs)->Union[pd.DataFrame,dict]:\n        \"\"\"\n        Retrieve a list of batches.\n        Arguments:\n            limit : Limit response to a specified positive number of objects. Ex. limit=10 (max = 100)\n            n_results : OPTIONAL :  number of result you want to get in total. (will loop)\n            output : OPTIONAL : Can be \"raw\" response (dict) or \"dataframe\".\n        Possible kwargs:\n            created : Filter by the Unix timestamp (in milliseconds) when this object was persisted.\n            createdAfter : Exclusively filter records created after this timestamp. \n            createdBefore : Exclusively filter records created before this timestamp.\n            start : Returns results from a specific offset of objects. This was previously called offset. (see next line)\n                offset : Will offset to the next limit (sort of pagination)        \n            updated : Filter by the Unix timestamp (in milliseconds) for the time of last modification.\n            createdUser : Filter by the ID of the user who created this object.\n            dataSet : Used to filter on the related object: &dataSet=dataSetId.\n            version : Filter by Semantic version of the account. Updated when the object is modified.\n            status : Filter by the current (mutable) status of the batch.\n            orderBy : Sort parameter and direction for sorting the response. \n                Ex. orderBy=asc:created,updated. This was previously called sort.\n            properties : A comma separated whitelist of top-level object properties to be returned in the response. \n                Used to cut down the number of properties and amount of data returned in the response bodies.\n            size : The number of bytes processed in the batch.\n        # /Batches/get_batch\n        more details : https://www.adobe.io/apis/experienceplatform/home/api-reference.html\n        \"\"\"\n        path = \"/batches\"\n        limit = min([limit,100])\n        params = {'limit':limit,**kwargs}\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getBatches with output format {output}\")\n        ## looping to retrieve pagination\n        if n_results is not None:\n            list_return = {}\n            params['start'] = 0\n            res = self.connector.getData(self.endpoint+path,\n                            headers=self.header, params=params)\n            list_return.update(**res)\n            while len(list_return) < n_results and len(res) != 0:\n                params['start'] += limit\n                res = self.connector.getData(self.endpoint+path,\n                            headers=self.header, params=params)\n                list_return.update(**res)\n            if output==\"dataframe\":\n                return pd.DataFrame(list_return).T\n            return list_return\n        res = self.connector.getData(self.endpoint+path,\n                            headers=self.header, params=params)\n        if output==\"dataframe\":\n            return pd.DataFrame(res).T\n        return res\n\n    def getFailedBatchesDF(self,limit:int=10,n_results: str=None,orderBy:str=\"desc:created\",**kwargs)->pd.DataFrame:\n        \"\"\"\n        Abstraction of getBatches method that focus on failed batches and return a dataframe with the batchId and errors.\n        Also adding some meta data information from the batch information provided.\n        Arguments:\n            limit : Limit response to a specified positive number of objects. Ex. limit=10 (max = 100)\n            n_results : OPTIONAL :  number of result you want to get in total. (will loop)\n            orderBy : OPTIONAL : The order of the batch. Default \"desc:created\"\n        Possible kwargs: Any additional parameter for filtering the requests\n        \"\"\"\n        res = self.getBatches(status=\"failed\",orderBy=orderBy,limit=limit,n_results=n_results,**kwargs)\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getFailedBatchesDF\")\n        dict_failed = {}\n        for batch in res:\n            if res.get(batch,{}).get('relatedObjects',[{'type':'unknown'}])[0]['type'] == \"dataSet\":\n                datasetId = res[batch]['relatedObjects'][0]['id']\n            dict_failed[batch] = {\n                \"timestamp\" : res[batch]['created'],\n                \"recordsSize\" : res[batch].get('metrics',{}).get('recordsSize',0),\n                \"invalidRecordsProfile\" : res[batch].get('metrics',{}).get('invalidRecordsProfile',0),\n                \"invalidRecordsIdentity\" : res[batch].get('metrics',{}).get('invalidRecordsIdentity',0),\n                \"invalidRecordCount\" : res[batch].get('metrics',{}).get('invalidRecordCount',0),\n                \"invalidRecordsStreamingValidation\" : res[batch].get('metrics',{}).get('invalidRecordsStreamingValidation',0),\n                \"invalidRecordsMapper\" : res[batch].get('metrics',{}).get('invalidRecordsMapper',0),\n                \"invalidRecordsUnknown\" : res[batch].get('metrics',{}).get('invalidRecordsUnknown',0),\n                \"errorCode\" : [er['code'] for er in res[batch]['errors']],\n                \"errorMessage\" : [er['description'] for er in res[batch]['errors']],\n                \"flowId\" : res[batch].get('tags',{}).get('flowId',[None])[0],\n                \"dataSetId\" : datasetId,\n                \"sandbox\" : res[batch]['sandboxId'],\n            }\n        df = pd.DataFrame(dict_failed).T\n        return df\n\n    def getBatch(self, batch_id: str = None)->dict:\n        \"\"\"\n        Get a specific batch id.\n        Arguments:\n            batch_id : REQUIRED : batch ID to be retrieved.\n        \"\"\"\n        if batch_id is None:\n            raise Exception(\"batch_id parameter is required.\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getBatch for the following batch : {batch_id}\")\n        path = f\"/batches/{batch_id}\"\n        res = self.connector.getData(self.endpoint+path,\n                            headers=self.header)\n        return res\n    \n    def createBatch(self, object:dict=None,**kwargs) -> dict:\n        \"\"\"\n        Create a new batch.\n        Arguments:\n            object : REQUIRED : Object that define the data to be onboarded.\n                see reference here: https://www.adobe.io/apis/experienceplatform/home/api-reference.html#/Batches/postBatch\n        \"\"\"\n        if object is None:\n            raise Exception('expecting a definition of the data to be uploaded.')\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createBatch\")\n        path = \"/batches\"\n        res = self.connector.postData(self.endpoint+path,data=object,\n                            headers=self.header)\n        return res\n\n    def getResources(self, **kwargs)->list:\n        \"\"\"\n        Retrieve a list of resource links for the Catalog Service.\n        Possible kwargs:\n            limit : Limit response to a specified positive number of objects. Ex. limit=10\n            orderBy : Sort parameter and direction for sorting the response. \n                Ex. orderBy=asc:created,updated. This was previously called sort.\n            property : A comma separated whitelist of top-level object properties to be returned in the response. \n                Used to cut down the number of properties and amount of data returned in the response bodies.\n        \"\"\"\n        path = \"/\"\n        params = {**kwargs}\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getResources\")\n        res = self.connector.getData(self.endpoint+path,\n                            headers=self.header, params=params)\n        return res\n\n\n    def getDataSets(self,limit:int=100,output:str=\"raw\",**kwargs)->dict:\n        \"\"\"\n        Return a list of a datasets.\n        Arguments:\n            limit : REQUIRED : amount of dataset to be retrieved per call. \n            output : OPTIONAL : Default is \"raw\", other option is \"df\" for dataframe output\n        Possible kwargs:\n            state : The state related to a dataset.\n            created : Filter by the Unix timestamp (in milliseconds) when this object was persisted.\n            updated : Filter by the Unix timestamp (in milliseconds) for the time of last modification.\n            name : Filter by the a descriptive, human-readable name for this DataSet.\n            namespace : One of the registered platform acronyms that identify the platform.\n            version : Filter by Semantic version of the account. Updated when the object is modified.\n            property : Regex used to filter objects in the response. Ex. property=name~^test.\n            # /Datasets/get_data_sets\n            more possibilities : https://www.adobe.io/apis/experienceplatform/home/api-reference.html\n        \"\"\"\n        path = \"/dataSets\"\n        params = {\"limit\":limit,**kwargs}\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getDataSets\")\n        res = self.connector.getData(self.endpoint+path, params=params)\n        data = deepcopy(res)\n        ## prepare pagination if needed\n        start = 1\n        while len(res) == limit:\n            start +=limit\n            params = {\"limit\":limit,\"start\":start,**kwargs}\n            res = self.connector.getData(self.endpoint+path, params=params)\n            data.update(res)\n        try:\n            if self.loggingEnabled:\n                self.logger.debug(f\"Starting caching results\")\n            self.data.table_names = {\n                data[key]['name']: data[key]['tags']['adobe/pqs/table'] for key in data}\n            self.data.schema_ref = {\n                data[key]['name']: data[key]['schemaRef']\n                for key in data if 'schemaRef' in data[key].keys()\n            }\n            self.data.ids = {\n                data[key]['name']: key for key in data\n            }\n        except Exception as e:\n            if self.loggingEnabled:\n                self.logger.warning(f\"Error caching results : {e}\")\n            print(e)\n            print(\"Couldn't populate the data object from the instance.\")\n        if output == \"df\":\n            df = pd.DataFrame(data).T\n            return df\n        return data\n\n    def createDataSets(self, \n                data: dict = None,\n                name:str=None, \n                schemaId:str=None, \n                profileEnabled:bool=False,\n                identityEnabled:bool=False,\n                upsert:bool=False,\n                tags:dict=None,\n                systemLabels:list[str]=None,\n                **kwargs)-> dict:\n        \"\"\"\n        Create a new dataSets based either on preconfigured setup or by passing the full dictionary for creation.\n        Arguments:\n            data : REQUIRED : If you want to pass the dataset object directly (not require the name and schemaId then)\n                more info: https://www.adobe.io/apis/experienceplatform/home/api-reference.html#/Datasets/postDataset\n            name : REQUIRED : if you wish to create a dataset via autocompletion. Provide a name.\n            schemaId : REQUIRED : The schema $id reference for creating your dataSet.\n            profileEnabled : OPTIONAL : If the dataset to be created with profile enbaled\n            identityEnabled : OPTIONAL : If the dataset should create new identities\n            upsert : OPTIONAL : If the dataset to be created with profile enbaled and Upsert capability.\n            tags : OPTIONAL : set of attribute to add as tags.\n            systemLabels : OPTIONAL : A list of string to attribute system based label on creation.\n        possible kwargs\n            requestDataSource : Set to true if you want Catalog to create a dataSource on your behalf; otherwise, pass a dataSourceId in the body.\n        \"\"\"\n        path = \"/dataSets\"\n        params = {\"requestDataSource\": kwargs.get(\"requestDataSource\", False)}\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createDataSets\")\n        if data is not None or isinstance(data, dict) == True:\n            res = self.connector.postData(self.endpoint+path, params=params,\n                             data=data)\n        elif name is not None and schemaId is not None:\n            data = {\n                \"name\":name,\n                \"schemaRef\": {\n                    \"id\": schemaId,\n                    \"contentType\": \"application/vnd.adobe.xed+json;version=1\"\n                },\n                \"fileDescription\": {\n                    \"persisted\": True,\n                    \"containerFormat\": \"parquet\",\n                    \"format\": \"parquet\"\n                },\n                \"tags\" : {}\n            }\n            if profileEnabled:\n                data['tags'][\"unifiedProfile\"] = [\"enabled: true\"]\n            if identityEnabled:\n                data['tags'][\"unifiedIdentity\"] = [\"enabled: true\"]\n            if upsert:\n                data['tags']['unifiedProfile'] = [\"enabled: true\",\"isUpsert: true\"]\n            if tags is not None and type(tags) == dict:\n                for key in tags:\n                    data['tags'][key] = tags[key]\n            if systemLabels is not None and type(systemLabels) == list:\n                data[\"systemLabels\"] = systemLabels\n            res = self.connector.postData(self.endpoint+path, params=params,\n                             data=data)\n        return res\n\n    def getDataSet(self, datasetId: str = None) -> dict:\n        \"\"\"\n        Return a single dataset.\n        Arguments:\n            datasetId : REQUIRED : Id of the dataset to be retrieved.\n        \"\"\"\n        if datasetId is None:\n            raise Exception(\"Expected a datasetId argument\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getDataset for : {datasetId}\")\n        path = f\"/dataSets/{datasetId}\"\n        res = self.connector.getData(self.endpoint+path, headers=self.header)\n        return res\n\n    def getDataSetObservableSchema(self, datasetId: str = None,appendDatasetInfo:bool=False) -> dict:\n        \"\"\"\n        Return a single dataset observable schema.\n        Which means that the fields that has been used in that dataset.\n        Arguments:\n            datasetId : REQUIRED : Id of the dataset for which the observable schema should be retrieved.\n            appendDatasetInfo : OPTIONAL : If set to True, it will append the \"datasetId\" into the dictionary return\n        \"\"\"\n        if datasetId is None:\n            raise Exception(\"Expected a datasetId argument\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getDataset for : {datasetId}\")\n        path = f\"/dataSets/{datasetId}\"\n        params = {\"properties\" : \"observableSchema\"}\n        res = self.connector.getData(self.endpoint+path,params=params, headers=self.header)\n        data = res[list(res.keys())[0]] ## accessing the observableSchema\n        if appendDatasetInfo:\n            data['datasetId'] = datasetId\n        return data\n\n    def deleteDataSet(self, datasetId: str = None) -> None:\n        \"\"\"\n        Delete a dataset by its id.\n        Arguments:\n            datasetId : REQUIRED : Id of the dataset to be deleted.\n        \"\"\"\n        if datasetId is None:\n            raise Exception(\"Expected a datasetId argument\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteDataset for : {datasetId}\")\n        path = f\"/dataSets/{datasetId}\"\n        res = self.connector.deleteData(self.endpoint+path, headers=self.header)\n        return res\n\n    ## Apparently deprecated.\n    def getDataSetViews(self, datasetId: str = None, **kwargs):\n        \"\"\"\n        Get views of the datasets.\n        Arguments:\n            datasetId : REQUIRED : Id of the dataset to be looked down.\n        Possible kwargs:\n            limit : Limit response to a specified positive number of objects. Ex. limit=10\n            orderBy : Sort parameter and direction for sorting the response. Ex. orderBy=asc:created,updated.\n            start : Returns results from a specific offset of objects. This was previously called offset. Ex. start=3.\n            property : Regex used to filter objects in the response. Ex. property=name~^test.\n        \"\"\"\n        if datasetId is None:\n            raise Exception(\"Expected a datasetId argument\")\n        path = f\"/dataSets/{datasetId}/views\"\n        params = {**kwargs}\n        res = self.connector.getData(self.endpoint+path, headers=self.header)\n        return res\n\n    def getDataSetView(self, datasetId: str = None, viewId: str = None):\n        \"\"\"\n        Get a specific view on a specific dataset.\n        Arguments:\n            datasetId : REQUIRED : ID of the dataset to be looked down.\n            viewId : REQUIRED : ID of the view to be look upon.\n        \"\"\"\n        if datasetId is None or viewId is None:\n            raise Exception(\"Expected a datasetId and an viewId argument\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getDataSetView for datasetId: {datasetId} & viewId: {viewId}\")\n        path = f\"/dataSets/{datasetId}/views/{viewId}\"\n        res = self.connector.getData(self.endpoint+path, headers=self.header)\n        return res\n\n    def getDataSetViewFiles(self, datasetId: str = None, viewId: str = None):\n        \"\"\"\n        Returns the list of files attached to a view in a Dataset.\n        Arguments:\n            datasetId : REQUIRED : ID of the dataset to be looked down.\n            viewId : REQUIRED : ID of the view to be look upon.\n        \"\"\"\n        if datasetId is None or viewId is None:\n            raise Exception(\"Expected a datasetId and an viewId argument\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getDataSetViewFiles for datasetId: {datasetId} & viewId: {viewId}\")\n        path = f\"/dataSets/{datasetId}/views/{viewId}/files\"\n        res = self.connector.getData(self.endpoint+path, headers=self.header)\n        return res\n    \n    def enableDatasetProfile(self,datasetId:str=None,upsert:bool=False)->dict:\n        \"\"\"\n        Enable a dataset for profile with upsert.\n        Arguments:\n            datasetId : REQUIRED : Dataset ID to be enabled for profile\n            upsert : OPTIONAL : If you wish to enabled the dataset for upsert.\n        \"\"\"\n        if datasetId is None:\n            raise ValueError(\"Require a datasetId\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting enableDatasetProfile for datasetId: {datasetId}\")\n        path = f\"/dataSets/{datasetId}\"\n        privateHeader = deepcopy(self.header)\n        privateHeader['Content-Type'] = \"application/json-patch+json\"\n        data = [\n            { \n                \"op\": \"add\", \n                \"path\": \"/tags/unifiedProfile\",\n                \"value\": [\"enabled:true\"] }\n            ]\n        if upsert:\n            data[0]['value'] = [\"enabled:true\",\"isUpsert:true\"]\n        res = self.connector.patchData(self.endpoint+path, data=data,headers=privateHeader)\n        return res\n    \n    def enableDatasetIdentity(self,datasetId:str=None)->dict:\n        \"\"\"\n        Enable a dataset for profile with upsert.\n        Arguments:\n            datasetId : REQUIRED : Dataset ID to be enabled for Identity\n        \"\"\"\n        if datasetId is None:\n            raise ValueError(\"Require a datasetId\")\n        path = f\"/dataSets/{datasetId}\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting enableDatasetIdentity for datasetId: {datasetId}\")\n        data = [\n            { \n                \"op\": \"add\", \n                \"path\": \"/tags/unifiedIdentity\",\n                \"value\": [\"enabled:true\"] }\n            ]\n        privateHeader = deepcopy(self.header)\n        privateHeader['Content-Type'] = \"application/json-patch+json\"\n        res = self.connector.patchData(self.endpoint+path, data=data,headers=privateHeader)\n        return res\n    \n    def disableDatasetProfile(self,datasetId: str = None)->dict:\n        \"\"\"\n        Disable the dataset for Profile ingestion.\n        Arguments:\n            datasetId : REQUIRED : Dataset ID to be disabled for profile\n        \"\"\"\n        path = f\"/dataSets/{datasetId}\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting disableDatasetProfile for datasetId: {datasetId}\")\n        data = [\n            { \n                \"op\": \"replace\", \n                \"path\": \"/tags/unifiedProfile\",\n                \"value\": [\"enabled:false\"] }\n            ]\n        res = self.connector.patchData(self.endpoint+path, data=data)\n        return res\n    \n    def disableDatasetIdentity(self,datasetId:str=None)->dict:\n        \"\"\"\n        Enable a dataset for profile with upsert.\n        Arguments:\n            datasetId : REQUIRED : Dataset ID to be disabled for Identity\n        \"\"\"\n        if datasetId is None:\n            raise ValueError(\"Require a datasetId\")\n        path = f\"/dataSets/{datasetId}\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting disableDatasetIdentity for datasetId: {datasetId}\")\n        data = [\n            { \n                \"op\": \"add\", \n                \"path\": \"/tags/unifiedIdentity\",\n                \"value\": [\"enabled:false\"] }\n            ]\n        res = self.connector.patchData(self.endpoint+path, data=data)\n        return res\n    \n    def createUnionProfileDataset(self)->dict:\n        \"\"\"\n        Create a dataset with an union Profile schema.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createUnionProfileDataset\")\n        path = \"/dataSets/\"\n        data = {\n        \"name\": \"Profile Data Export\",\n        \"schemaRef\": {\n          \"id\": \"https://ns.adobe.com/xdm/context/profile__union\",\n          \"contentType\": \"application/vnd.adobe.xed+json;version=1\"\n            }\n        }\n        res = self.connector.postData(self.endpoint+path, data=data)\n        return res\n    \n    def getMapperErrors(self,limit:int=100,n_results:str=None,**kwargs)->pd.DataFrame:\n        \"\"\"\n        Get failed batches for Mapper errors, based on error code containing \"MAPPER\".\n        Arguments:\n            limit : OPTIONAL : Number of results per requests\n            n_results : OPTIONAL : Total number of results wanted.\n        Possible kwargs:\n            created : Filter by the Unix timestamp (in milliseconds) when this object was persisted.\n            createdAfter : Exclusively filter records created after this timestamp. \n            createdBefore : Exclusively filter records created before this timestamp.\n            start : Returns results from a specific offset of objects. This was previously called offset. (see next line)\n                offset : Will offset to the next limit (sort of pagination)        \n            updated : Filter by the Unix timestamp (in milliseconds) for the time of last modification.\n            createdUser : Filter by the ID of the user who created this object.\n            dataSet : Used to filter on the related object: &dataSet=dataSetId.\n            version : Filter by Semantic version of the account. Updated when the object is modified.\n            status : Filter by the current (mutable) status of the batch.\n            orderBy : Sort parameter and direction for sorting the response. \n                Ex. orderBy=asc:created,updated. This was previously called sort.\n            properties : A comma separated whitelist of top-level object properties to be returned in the response. \n                Used to cut down the number of properties and amount of data returned in the response bodies.\n            size : The number of bytes processed in the batch.\n        \"\"\"\n        df = self.getFailedBatchesDF(limit=limit,n_results=n_results,**kwargs)\n        df['errorCodeStr'] = df['errorCode'].astype(str)\n        df_mapper = df[df['errorCodeStr'].str.contains('DPMAP')]\n        del df_mapper[\"errorCodeStr\"]\n        dict_result = {}\n        for index,row in df_mapper.iterrows():\n            errorCodes = []\n            errorMessages = []\n            destinationPaths = []\n            expectedTypes = []\n            actualTypes = []\n            sourceFields = []\n            destinationFields = []\n            for code,message in zip_longest(row['errorCode'],row['errorMessage']):\n                if 'MAPPER' in code:\n                    errorMessages.append(message)\n                    errorCodes.append(code)\n                    matchDestPath = re.search('destination path (.+?)\\. ',message)\n                    if matchDestPath:\n                        destinationPaths.append(matchDestPath.group(1))\n                    matchExpectedTypes = re.search('expected data type was: ([A-Z]+?), ',message)\n                    if matchExpectedTypes:\n                        expectedTypes.append(matchExpectedTypes.group(1))\n                    matchActualTypes = re.search('actual data type was: ([A-Z]+?)\\. ',message)\n                    if matchActualTypes:\n                        actualTypes.append(matchActualTypes.group(1))\n                    matchSourceField = re.search('sourceField: (.+?) destinationField',message)\n                    if matchSourceField:\n                        sourceFields.append(matchSourceField.group(1))\n                    matchDestinationField = re.search('destinationField: (.+?)$',message)\n                    if matchDestinationField:\n                        destinationFields.append(matchDestinationField.group(1))\n            for message,code,destPath,expType,actType,source,dest in zip_longest(errorMessages,errorCodes,destinationPaths,expectedTypes,actualTypes,sourceFields,destinationFields):\n                dict_result[f\"{row.name}-{code}\"] = {\n                    \"timestamp\" : row['timestamp'],\n                    \"batchId\" : row.name,\n                    \"datasetId\": row['dataSetId'],\n                    \"flowId\":row[\"flowId\"],\n                    \"invalidRecordCount\" : row[\"invalidRecordCount\"],\n                    \"invalidRecordsMapper\": row[\"invalidRecordsMapper\"],\n                    \"errorCode\" : code,\n                    \"errorMessage\":message,\n                    \"destinationPath\" : destPath,\n                    \"expectedType\":expType,\n                    \"actualType\":actType,\n                    \"sourceField\":source,\n                    \"destinationField\":dest\n                }\n        df_final = pd.DataFrame(dict_result).T\n        return df_final", "\nclass Catalog:\n    \"\"\"\n    Catalog class from the AEP API. This class helps you to find where the data are coming from in AEP.\n    More details here : https://www.adobe.io/apis/experienceplatform/home/api-reference.html#\n    It possess a data attribute that is containing information about your datasets. \n    Arguments:\n        config : OPTIONAL : config object in the config module (DO NOT MODIFY)\n        header : OPTIONAL : header object  in the config module (DO NOT MODIFY)\n        loggingObject : OPTIONAL : If you want to set logging capability for your actions.\n    kwargs:\n        kwargs value will update the header\n    \"\"\"\n    loggingEnabled = False\n    logger = None\n\n    def __init__(self,\n                config : Union[dict,ConnectObject]=aepp.config.config_object,\n                header : dict=aepp.config.header,\n                loggingObject:dict=None,\n                **kwargs):\n        if loggingObject is not None and sorted([\"level\",\"stream\",\"format\",\"filename\",\"file\"]) == sorted(list(loggingObject.keys())):\n            self.loggingEnabled = True\n            self.logger = logging.getLogger(f\"{__name__}\")\n            self.logger.setLevel(loggingObject[\"level\"])\n            if type(loggingObject[\"format\"]) == str:\n                formatter = logging.Formatter(loggingObject[\"format\"])\n            elif type(loggingObject[\"format\"]) == logging.Formatter:\n                formatter = loggingObject[\"format\"]\n            if loggingObject[\"file\"]:\n                fileHandler = logging.FileHandler(loggingObject[\"filename\"])\n                fileHandler.setFormatter(formatter)\n                self.logger.addHandler(fileHandler)\n            if loggingObject[\"stream\"]:\n                streamHandler = logging.StreamHandler()\n                streamHandler.setFormatter(formatter)\n                self.logger.addHandler(streamHandler)\n        if type(config) == dict: ## Supporting either default setup or passing a ConnectObject\n            config = config\n        elif type(config) == ConnectObject:\n            header = config.getConfigHeader()\n            config = config.getConfigObject()\n        self.connector = connector.AdobeRequest(\n            config=config, \n            header=header,\n            loggingEnabled=self.loggingEnabled,\n            logger=self.logger)\n        self.header = self.connector.header\n        self.header.update(**kwargs)\n        if kwargs.get('sandbox',None) is not None: ## supporting sandbox setup on class instanciation\n            self.sandbox = kwargs.get('sandbox')\n            self.connector.config[\"sandbox\"] = kwargs.get('sandbox')\n            self.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n            self.connector.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n        else:\n            self.sandbox = self.connector.config[\"sandbox\"]\n        self.endpoint = aepp.config.endpoints['global']+aepp.config.endpoints[\"catalog\"]\n        self.data = _Data()\n\n    def getResource(self,endpoint:str=None,params:dict=None,format:str='json',save:bool=False,**kwargs)->dict:\n        \"\"\"\n        Template for requesting data with a GET method.\n        Arguments:\n            endpoint : REQUIRED : The URL to GET\n            params: OPTIONAL : dictionary of the params to fetch\n            format : OPTIONAL : Type of response returned. Possible values:\n                json : default\n                txt : text file\n                raw : a response object from the requests module\n        \"\"\"\n        if endpoint is None:\n            raise ValueError(\"Require an endpoint\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Using getResource with following format ({format}) to the following endpoint: {endpoint}\")\n        res = self.connector.getData(endpoint,params=params,format=format)\n        if save:\n            if format == 'json':\n                aepp.saveFile(module=\"catalog\",file=res,filename=f\"resource_{int(time.time())}\",type_file=\"json\",encoding=kwargs.get(\"encoding\",'utf-8'))\n            elif format == 'txt':\n                aepp.saveFile(module=\"catalog\",file=res,filename=f\"resource_{int(time.time())}\",type_file=\"txt\",encoding=kwargs.get(\"encoding\",'utf-8'))\n            else:\n                print(\"element is an object. Output is unclear. No save made.\\nPlease save this element manually\")\n        return res\n    \n    def decodeStreamBatch(self,message:str)->dict:\n        \"\"\"\n        Decode the full txt batch via the codecs module.\n        Usually the full batch is returned by the getResource method with format == \"txt\".\n        Arguments:\n            message: REQUIRED : the text file return from the failed batch message.\n        \n        return None when issue is raised\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting decodeStreamBatch\")\n        try: \n            decodeMessage = codecs.escape_decode(message)[0].decode().replace('\"body\":\"{','\"body\":{').replace('}\",\"header\":\"{','},\"header\":{').replace('}\",\"_errors\":\"{','},\"_errors\":{').replace('}\"','}')\n            return decodeMessage\n        except:\n            print(\"Issue decoding the message.\")\n            return None\n\n    def jsonStreamMessages(self,message:str,verbose:bool = False)->list:\n        \"\"\"\n        Try to create a list of dictionary messages from the decoded stream batch extracted from the decodeStreamBatch method.\n        Arguments:\n            message : REQUIRED : a decoded text file, usually returned from the decodeStreamBatch method\n            verbose : OPTIONAL : print errors and information on the decoding.\n        \n        return None when issue is raised\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting jsonStreamMessages\")\n        try:\n            myList = []\n            myYield:iter = (line for line in message.split(\"\\n\"))\n            countLine,countErrors = 0,0\n            for element in myYield:\n                countLine +=1\n                try:\n                    myList.append(json.loads(element))\n\n                except Exception as e:\n                    countErrors+=1\n                    if verbose:\n                        print(e)\n            if verbose:\n                print(f\"error rate is {(countErrors/countLine)*100:.2f}%\")\n            return myList\n        except:\n            print(\"Issue creating a stream of messages.\")\n            if self.loggingEnabled:\n                self.logger.info(f\"Issue creating a stream of messages\")\n            return None\n\n    def getLastBatches(self,dataSetId:str=None)->list:\n        \"\"\"\n        Returns the last batch from a specific datasetId.\n        Arguments:\n            dataSetId : OPTIONAL : the datasetId to be retrieved the batch about\n\n        \"\"\"\n        path = \"/lastBatches\"\n        params = {}\n        if dataSetId is not None:\n            params['dataSetId'] = dataSetId\n        res = self.connector.getData(self.endpoint+path,params=params)\n        return res\n        \n\n    def getBatches(self,limit:int=10, n_results:int=None,output:str='raw',**kwargs)->Union[pd.DataFrame,dict]:\n        \"\"\"\n        Retrieve a list of batches.\n        Arguments:\n            limit : Limit response to a specified positive number of objects. Ex. limit=10 (max = 100)\n            n_results : OPTIONAL :  number of result you want to get in total. (will loop)\n            output : OPTIONAL : Can be \"raw\" response (dict) or \"dataframe\".\n        Possible kwargs:\n            created : Filter by the Unix timestamp (in milliseconds) when this object was persisted.\n            createdAfter : Exclusively filter records created after this timestamp. \n            createdBefore : Exclusively filter records created before this timestamp.\n            start : Returns results from a specific offset of objects. This was previously called offset. (see next line)\n                offset : Will offset to the next limit (sort of pagination)        \n            updated : Filter by the Unix timestamp (in milliseconds) for the time of last modification.\n            createdUser : Filter by the ID of the user who created this object.\n            dataSet : Used to filter on the related object: &dataSet=dataSetId.\n            version : Filter by Semantic version of the account. Updated when the object is modified.\n            status : Filter by the current (mutable) status of the batch.\n            orderBy : Sort parameter and direction for sorting the response. \n                Ex. orderBy=asc:created,updated. This was previously called sort.\n            properties : A comma separated whitelist of top-level object properties to be returned in the response. \n                Used to cut down the number of properties and amount of data returned in the response bodies.\n            size : The number of bytes processed in the batch.\n        # /Batches/get_batch\n        more details : https://www.adobe.io/apis/experienceplatform/home/api-reference.html\n        \"\"\"\n        path = \"/batches\"\n        limit = min([limit,100])\n        params = {'limit':limit,**kwargs}\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getBatches with output format {output}\")\n        ## looping to retrieve pagination\n        if n_results is not None:\n            list_return = {}\n            params['start'] = 0\n            res = self.connector.getData(self.endpoint+path,\n                            headers=self.header, params=params)\n            list_return.update(**res)\n            while len(list_return) < n_results and len(res) != 0:\n                params['start'] += limit\n                res = self.connector.getData(self.endpoint+path,\n                            headers=self.header, params=params)\n                list_return.update(**res)\n            if output==\"dataframe\":\n                return pd.DataFrame(list_return).T\n            return list_return\n        res = self.connector.getData(self.endpoint+path,\n                            headers=self.header, params=params)\n        if output==\"dataframe\":\n            return pd.DataFrame(res).T\n        return res\n\n    def getFailedBatchesDF(self,limit:int=10,n_results: str=None,orderBy:str=\"desc:created\",**kwargs)->pd.DataFrame:\n        \"\"\"\n        Abstraction of getBatches method that focus on failed batches and return a dataframe with the batchId and errors.\n        Also adding some meta data information from the batch information provided.\n        Arguments:\n            limit : Limit response to a specified positive number of objects. Ex. limit=10 (max = 100)\n            n_results : OPTIONAL :  number of result you want to get in total. (will loop)\n            orderBy : OPTIONAL : The order of the batch. Default \"desc:created\"\n        Possible kwargs: Any additional parameter for filtering the requests\n        \"\"\"\n        res = self.getBatches(status=\"failed\",orderBy=orderBy,limit=limit,n_results=n_results,**kwargs)\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getFailedBatchesDF\")\n        dict_failed = {}\n        for batch in res:\n            if res.get(batch,{}).get('relatedObjects',[{'type':'unknown'}])[0]['type'] == \"dataSet\":\n                datasetId = res[batch]['relatedObjects'][0]['id']\n            dict_failed[batch] = {\n                \"timestamp\" : res[batch]['created'],\n                \"recordsSize\" : res[batch].get('metrics',{}).get('recordsSize',0),\n                \"invalidRecordsProfile\" : res[batch].get('metrics',{}).get('invalidRecordsProfile',0),\n                \"invalidRecordsIdentity\" : res[batch].get('metrics',{}).get('invalidRecordsIdentity',0),\n                \"invalidRecordCount\" : res[batch].get('metrics',{}).get('invalidRecordCount',0),\n                \"invalidRecordsStreamingValidation\" : res[batch].get('metrics',{}).get('invalidRecordsStreamingValidation',0),\n                \"invalidRecordsMapper\" : res[batch].get('metrics',{}).get('invalidRecordsMapper',0),\n                \"invalidRecordsUnknown\" : res[batch].get('metrics',{}).get('invalidRecordsUnknown',0),\n                \"errorCode\" : [er['code'] for er in res[batch]['errors']],\n                \"errorMessage\" : [er['description'] for er in res[batch]['errors']],\n                \"flowId\" : res[batch].get('tags',{}).get('flowId',[None])[0],\n                \"dataSetId\" : datasetId,\n                \"sandbox\" : res[batch]['sandboxId'],\n            }\n        df = pd.DataFrame(dict_failed).T\n        return df\n\n    def getBatch(self, batch_id: str = None)->dict:\n        \"\"\"\n        Get a specific batch id.\n        Arguments:\n            batch_id : REQUIRED : batch ID to be retrieved.\n        \"\"\"\n        if batch_id is None:\n            raise Exception(\"batch_id parameter is required.\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getBatch for the following batch : {batch_id}\")\n        path = f\"/batches/{batch_id}\"\n        res = self.connector.getData(self.endpoint+path,\n                            headers=self.header)\n        return res\n    \n    def createBatch(self, object:dict=None,**kwargs) -> dict:\n        \"\"\"\n        Create a new batch.\n        Arguments:\n            object : REQUIRED : Object that define the data to be onboarded.\n                see reference here: https://www.adobe.io/apis/experienceplatform/home/api-reference.html#/Batches/postBatch\n        \"\"\"\n        if object is None:\n            raise Exception('expecting a definition of the data to be uploaded.')\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createBatch\")\n        path = \"/batches\"\n        res = self.connector.postData(self.endpoint+path,data=object,\n                            headers=self.header)\n        return res\n\n    def getResources(self, **kwargs)->list:\n        \"\"\"\n        Retrieve a list of resource links for the Catalog Service.\n        Possible kwargs:\n            limit : Limit response to a specified positive number of objects. Ex. limit=10\n            orderBy : Sort parameter and direction for sorting the response. \n                Ex. orderBy=asc:created,updated. This was previously called sort.\n            property : A comma separated whitelist of top-level object properties to be returned in the response. \n                Used to cut down the number of properties and amount of data returned in the response bodies.\n        \"\"\"\n        path = \"/\"\n        params = {**kwargs}\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getResources\")\n        res = self.connector.getData(self.endpoint+path,\n                            headers=self.header, params=params)\n        return res\n\n\n    def getDataSets(self,limit:int=100,output:str=\"raw\",**kwargs)->dict:\n        \"\"\"\n        Return a list of a datasets.\n        Arguments:\n            limit : REQUIRED : amount of dataset to be retrieved per call. \n            output : OPTIONAL : Default is \"raw\", other option is \"df\" for dataframe output\n        Possible kwargs:\n            state : The state related to a dataset.\n            created : Filter by the Unix timestamp (in milliseconds) when this object was persisted.\n            updated : Filter by the Unix timestamp (in milliseconds) for the time of last modification.\n            name : Filter by the a descriptive, human-readable name for this DataSet.\n            namespace : One of the registered platform acronyms that identify the platform.\n            version : Filter by Semantic version of the account. Updated when the object is modified.\n            property : Regex used to filter objects in the response. Ex. property=name~^test.\n            # /Datasets/get_data_sets\n            more possibilities : https://www.adobe.io/apis/experienceplatform/home/api-reference.html\n        \"\"\"\n        path = \"/dataSets\"\n        params = {\"limit\":limit,**kwargs}\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getDataSets\")\n        res = self.connector.getData(self.endpoint+path, params=params)\n        data = deepcopy(res)\n        ## prepare pagination if needed\n        start = 1\n        while len(res) == limit:\n            start +=limit\n            params = {\"limit\":limit,\"start\":start,**kwargs}\n            res = self.connector.getData(self.endpoint+path, params=params)\n            data.update(res)\n        try:\n            if self.loggingEnabled:\n                self.logger.debug(f\"Starting caching results\")\n            self.data.table_names = {\n                data[key]['name']: data[key]['tags']['adobe/pqs/table'] for key in data}\n            self.data.schema_ref = {\n                data[key]['name']: data[key]['schemaRef']\n                for key in data if 'schemaRef' in data[key].keys()\n            }\n            self.data.ids = {\n                data[key]['name']: key for key in data\n            }\n        except Exception as e:\n            if self.loggingEnabled:\n                self.logger.warning(f\"Error caching results : {e}\")\n            print(e)\n            print(\"Couldn't populate the data object from the instance.\")\n        if output == \"df\":\n            df = pd.DataFrame(data).T\n            return df\n        return data\n\n    def createDataSets(self, \n                data: dict = None,\n                name:str=None, \n                schemaId:str=None, \n                profileEnabled:bool=False,\n                identityEnabled:bool=False,\n                upsert:bool=False,\n                tags:dict=None,\n                systemLabels:list[str]=None,\n                **kwargs)-> dict:\n        \"\"\"\n        Create a new dataSets based either on preconfigured setup or by passing the full dictionary for creation.\n        Arguments:\n            data : REQUIRED : If you want to pass the dataset object directly (not require the name and schemaId then)\n                more info: https://www.adobe.io/apis/experienceplatform/home/api-reference.html#/Datasets/postDataset\n            name : REQUIRED : if you wish to create a dataset via autocompletion. Provide a name.\n            schemaId : REQUIRED : The schema $id reference for creating your dataSet.\n            profileEnabled : OPTIONAL : If the dataset to be created with profile enbaled\n            identityEnabled : OPTIONAL : If the dataset should create new identities\n            upsert : OPTIONAL : If the dataset to be created with profile enbaled and Upsert capability.\n            tags : OPTIONAL : set of attribute to add as tags.\n            systemLabels : OPTIONAL : A list of string to attribute system based label on creation.\n        possible kwargs\n            requestDataSource : Set to true if you want Catalog to create a dataSource on your behalf; otherwise, pass a dataSourceId in the body.\n        \"\"\"\n        path = \"/dataSets\"\n        params = {\"requestDataSource\": kwargs.get(\"requestDataSource\", False)}\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createDataSets\")\n        if data is not None or isinstance(data, dict) == True:\n            res = self.connector.postData(self.endpoint+path, params=params,\n                             data=data)\n        elif name is not None and schemaId is not None:\n            data = {\n                \"name\":name,\n                \"schemaRef\": {\n                    \"id\": schemaId,\n                    \"contentType\": \"application/vnd.adobe.xed+json;version=1\"\n                },\n                \"fileDescription\": {\n                    \"persisted\": True,\n                    \"containerFormat\": \"parquet\",\n                    \"format\": \"parquet\"\n                },\n                \"tags\" : {}\n            }\n            if profileEnabled:\n                data['tags'][\"unifiedProfile\"] = [\"enabled: true\"]\n            if identityEnabled:\n                data['tags'][\"unifiedIdentity\"] = [\"enabled: true\"]\n            if upsert:\n                data['tags']['unifiedProfile'] = [\"enabled: true\",\"isUpsert: true\"]\n            if tags is not None and type(tags) == dict:\n                for key in tags:\n                    data['tags'][key] = tags[key]\n            if systemLabels is not None and type(systemLabels) == list:\n                data[\"systemLabels\"] = systemLabels\n            res = self.connector.postData(self.endpoint+path, params=params,\n                             data=data)\n        return res\n\n    def getDataSet(self, datasetId: str = None) -> dict:\n        \"\"\"\n        Return a single dataset.\n        Arguments:\n            datasetId : REQUIRED : Id of the dataset to be retrieved.\n        \"\"\"\n        if datasetId is None:\n            raise Exception(\"Expected a datasetId argument\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getDataset for : {datasetId}\")\n        path = f\"/dataSets/{datasetId}\"\n        res = self.connector.getData(self.endpoint+path, headers=self.header)\n        return res\n\n    def getDataSetObservableSchema(self, datasetId: str = None,appendDatasetInfo:bool=False) -> dict:\n        \"\"\"\n        Return a single dataset observable schema.\n        Which means that the fields that has been used in that dataset.\n        Arguments:\n            datasetId : REQUIRED : Id of the dataset for which the observable schema should be retrieved.\n            appendDatasetInfo : OPTIONAL : If set to True, it will append the \"datasetId\" into the dictionary return\n        \"\"\"\n        if datasetId is None:\n            raise Exception(\"Expected a datasetId argument\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getDataset for : {datasetId}\")\n        path = f\"/dataSets/{datasetId}\"\n        params = {\"properties\" : \"observableSchema\"}\n        res = self.connector.getData(self.endpoint+path,params=params, headers=self.header)\n        data = res[list(res.keys())[0]] ## accessing the observableSchema\n        if appendDatasetInfo:\n            data['datasetId'] = datasetId\n        return data\n\n    def deleteDataSet(self, datasetId: str = None) -> None:\n        \"\"\"\n        Delete a dataset by its id.\n        Arguments:\n            datasetId : REQUIRED : Id of the dataset to be deleted.\n        \"\"\"\n        if datasetId is None:\n            raise Exception(\"Expected a datasetId argument\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteDataset for : {datasetId}\")\n        path = f\"/dataSets/{datasetId}\"\n        res = self.connector.deleteData(self.endpoint+path, headers=self.header)\n        return res\n\n    ## Apparently deprecated.\n    def getDataSetViews(self, datasetId: str = None, **kwargs):\n        \"\"\"\n        Get views of the datasets.\n        Arguments:\n            datasetId : REQUIRED : Id of the dataset to be looked down.\n        Possible kwargs:\n            limit : Limit response to a specified positive number of objects. Ex. limit=10\n            orderBy : Sort parameter and direction for sorting the response. Ex. orderBy=asc:created,updated.\n            start : Returns results from a specific offset of objects. This was previously called offset. Ex. start=3.\n            property : Regex used to filter objects in the response. Ex. property=name~^test.\n        \"\"\"\n        if datasetId is None:\n            raise Exception(\"Expected a datasetId argument\")\n        path = f\"/dataSets/{datasetId}/views\"\n        params = {**kwargs}\n        res = self.connector.getData(self.endpoint+path, headers=self.header)\n        return res\n\n    def getDataSetView(self, datasetId: str = None, viewId: str = None):\n        \"\"\"\n        Get a specific view on a specific dataset.\n        Arguments:\n            datasetId : REQUIRED : ID of the dataset to be looked down.\n            viewId : REQUIRED : ID of the view to be look upon.\n        \"\"\"\n        if datasetId is None or viewId is None:\n            raise Exception(\"Expected a datasetId and an viewId argument\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getDataSetView for datasetId: {datasetId} & viewId: {viewId}\")\n        path = f\"/dataSets/{datasetId}/views/{viewId}\"\n        res = self.connector.getData(self.endpoint+path, headers=self.header)\n        return res\n\n    def getDataSetViewFiles(self, datasetId: str = None, viewId: str = None):\n        \"\"\"\n        Returns the list of files attached to a view in a Dataset.\n        Arguments:\n            datasetId : REQUIRED : ID of the dataset to be looked down.\n            viewId : REQUIRED : ID of the view to be look upon.\n        \"\"\"\n        if datasetId is None or viewId is None:\n            raise Exception(\"Expected a datasetId and an viewId argument\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getDataSetViewFiles for datasetId: {datasetId} & viewId: {viewId}\")\n        path = f\"/dataSets/{datasetId}/views/{viewId}/files\"\n        res = self.connector.getData(self.endpoint+path, headers=self.header)\n        return res\n    \n    def enableDatasetProfile(self,datasetId:str=None,upsert:bool=False)->dict:\n        \"\"\"\n        Enable a dataset for profile with upsert.\n        Arguments:\n            datasetId : REQUIRED : Dataset ID to be enabled for profile\n            upsert : OPTIONAL : If you wish to enabled the dataset for upsert.\n        \"\"\"\n        if datasetId is None:\n            raise ValueError(\"Require a datasetId\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting enableDatasetProfile for datasetId: {datasetId}\")\n        path = f\"/dataSets/{datasetId}\"\n        privateHeader = deepcopy(self.header)\n        privateHeader['Content-Type'] = \"application/json-patch+json\"\n        data = [\n            { \n                \"op\": \"add\", \n                \"path\": \"/tags/unifiedProfile\",\n                \"value\": [\"enabled:true\"] }\n            ]\n        if upsert:\n            data[0]['value'] = [\"enabled:true\",\"isUpsert:true\"]\n        res = self.connector.patchData(self.endpoint+path, data=data,headers=privateHeader)\n        return res\n    \n    def enableDatasetIdentity(self,datasetId:str=None)->dict:\n        \"\"\"\n        Enable a dataset for profile with upsert.\n        Arguments:\n            datasetId : REQUIRED : Dataset ID to be enabled for Identity\n        \"\"\"\n        if datasetId is None:\n            raise ValueError(\"Require a datasetId\")\n        path = f\"/dataSets/{datasetId}\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting enableDatasetIdentity for datasetId: {datasetId}\")\n        data = [\n            { \n                \"op\": \"add\", \n                \"path\": \"/tags/unifiedIdentity\",\n                \"value\": [\"enabled:true\"] }\n            ]\n        privateHeader = deepcopy(self.header)\n        privateHeader['Content-Type'] = \"application/json-patch+json\"\n        res = self.connector.patchData(self.endpoint+path, data=data,headers=privateHeader)\n        return res\n    \n    def disableDatasetProfile(self,datasetId: str = None)->dict:\n        \"\"\"\n        Disable the dataset for Profile ingestion.\n        Arguments:\n            datasetId : REQUIRED : Dataset ID to be disabled for profile\n        \"\"\"\n        path = f\"/dataSets/{datasetId}\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting disableDatasetProfile for datasetId: {datasetId}\")\n        data = [\n            { \n                \"op\": \"replace\", \n                \"path\": \"/tags/unifiedProfile\",\n                \"value\": [\"enabled:false\"] }\n            ]\n        res = self.connector.patchData(self.endpoint+path, data=data)\n        return res\n    \n    def disableDatasetIdentity(self,datasetId:str=None)->dict:\n        \"\"\"\n        Enable a dataset for profile with upsert.\n        Arguments:\n            datasetId : REQUIRED : Dataset ID to be disabled for Identity\n        \"\"\"\n        if datasetId is None:\n            raise ValueError(\"Require a datasetId\")\n        path = f\"/dataSets/{datasetId}\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting disableDatasetIdentity for datasetId: {datasetId}\")\n        data = [\n            { \n                \"op\": \"add\", \n                \"path\": \"/tags/unifiedIdentity\",\n                \"value\": [\"enabled:false\"] }\n            ]\n        res = self.connector.patchData(self.endpoint+path, data=data)\n        return res\n    \n    def createUnionProfileDataset(self)->dict:\n        \"\"\"\n        Create a dataset with an union Profile schema.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createUnionProfileDataset\")\n        path = \"/dataSets/\"\n        data = {\n        \"name\": \"Profile Data Export\",\n        \"schemaRef\": {\n          \"id\": \"https://ns.adobe.com/xdm/context/profile__union\",\n          \"contentType\": \"application/vnd.adobe.xed+json;version=1\"\n            }\n        }\n        res = self.connector.postData(self.endpoint+path, data=data)\n        return res\n    \n    def getMapperErrors(self,limit:int=100,n_results:str=None,**kwargs)->pd.DataFrame:\n        \"\"\"\n        Get failed batches for Mapper errors, based on error code containing \"MAPPER\".\n        Arguments:\n            limit : OPTIONAL : Number of results per requests\n            n_results : OPTIONAL : Total number of results wanted.\n        Possible kwargs:\n            created : Filter by the Unix timestamp (in milliseconds) when this object was persisted.\n            createdAfter : Exclusively filter records created after this timestamp. \n            createdBefore : Exclusively filter records created before this timestamp.\n            start : Returns results from a specific offset of objects. This was previously called offset. (see next line)\n                offset : Will offset to the next limit (sort of pagination)        \n            updated : Filter by the Unix timestamp (in milliseconds) for the time of last modification.\n            createdUser : Filter by the ID of the user who created this object.\n            dataSet : Used to filter on the related object: &dataSet=dataSetId.\n            version : Filter by Semantic version of the account. Updated when the object is modified.\n            status : Filter by the current (mutable) status of the batch.\n            orderBy : Sort parameter and direction for sorting the response. \n                Ex. orderBy=asc:created,updated. This was previously called sort.\n            properties : A comma separated whitelist of top-level object properties to be returned in the response. \n                Used to cut down the number of properties and amount of data returned in the response bodies.\n            size : The number of bytes processed in the batch.\n        \"\"\"\n        df = self.getFailedBatchesDF(limit=limit,n_results=n_results,**kwargs)\n        df['errorCodeStr'] = df['errorCode'].astype(str)\n        df_mapper = df[df['errorCodeStr'].str.contains('DPMAP')]\n        del df_mapper[\"errorCodeStr\"]\n        dict_result = {}\n        for index,row in df_mapper.iterrows():\n            errorCodes = []\n            errorMessages = []\n            destinationPaths = []\n            expectedTypes = []\n            actualTypes = []\n            sourceFields = []\n            destinationFields = []\n            for code,message in zip_longest(row['errorCode'],row['errorMessage']):\n                if 'MAPPER' in code:\n                    errorMessages.append(message)\n                    errorCodes.append(code)\n                    matchDestPath = re.search('destination path (.+?)\\. ',message)\n                    if matchDestPath:\n                        destinationPaths.append(matchDestPath.group(1))\n                    matchExpectedTypes = re.search('expected data type was: ([A-Z]+?), ',message)\n                    if matchExpectedTypes:\n                        expectedTypes.append(matchExpectedTypes.group(1))\n                    matchActualTypes = re.search('actual data type was: ([A-Z]+?)\\. ',message)\n                    if matchActualTypes:\n                        actualTypes.append(matchActualTypes.group(1))\n                    matchSourceField = re.search('sourceField: (.+?) destinationField',message)\n                    if matchSourceField:\n                        sourceFields.append(matchSourceField.group(1))\n                    matchDestinationField = re.search('destinationField: (.+?)$',message)\n                    if matchDestinationField:\n                        destinationFields.append(matchDestinationField.group(1))\n            for message,code,destPath,expType,actType,source,dest in zip_longest(errorMessages,errorCodes,destinationPaths,expectedTypes,actualTypes,sourceFields,destinationFields):\n                dict_result[f\"{row.name}-{code}\"] = {\n                    \"timestamp\" : row['timestamp'],\n                    \"batchId\" : row.name,\n                    \"datasetId\": row['dataSetId'],\n                    \"flowId\":row[\"flowId\"],\n                    \"invalidRecordCount\" : row[\"invalidRecordCount\"],\n                    \"invalidRecordsMapper\": row[\"invalidRecordsMapper\"],\n                    \"errorCode\" : code,\n                    \"errorMessage\":message,\n                    \"destinationPath\" : destPath,\n                    \"expectedType\":expType,\n                    \"actualType\":actType,\n                    \"sourceField\":source,\n                    \"destinationField\":dest\n                }\n        df_final = pd.DataFrame(dict_result).T\n        return df_final", "    \nclass ObservableSchemaManager:\n\n    def __init__(self,observableSchema:dict=None)->None:\n        \"\"\"\n        Arguments:\n            observableSchema : dictionary of the data stored in the \"observableSchema\" key\n        \"\"\"\n        if 'observableSchema' in observableSchema.keys():\n            self.observableSchema = observableSchema['observableSchema']\n        else:\n            self.observableSchema = observableSchema\n        self.schemaId = self.observableSchema.get('$id')\n        self.title = self.observableSchema.get('title')\n    \n    def __str__(self)->str:\n        return json.dumps(self.observableSchema,indent=2)\n    \n    def __repr__(self)->dict:\n        return json.dumps(self.observableSchema,indent=2)\n    \n    def __simpleDeepMerge__(self,base:dict,append:dict)->dict:\n        \"\"\"\n        Loop through the keys of 2 dictionary and append the new found key of append to the base.\n        Arguments:\n            base : The base you want to extend\n            append : the new dictionary to append\n        \"\"\"\n        if type(append) == list:\n            append = append[0]\n        for key in append:\n            if type(base)==dict:\n                if key in base.keys():\n                    self.__simpleDeepMerge__(base[key],append[key])\n                else:\n                    base[key] = append[key]\n            elif type(base)==list:\n                base = base[0]\n                if type(base) == dict:\n                    if key in base.keys():\n                        self.__simpleDeepMerge__(base[key],append[key])\n                    else:\n                        base[key] = append[key]\n        return base\n    \n    def __accessorAlgo__(self,mydict:dict,path:list=None)->dict:\n        \"\"\"\n        recursive method to retrieve all the elements.\n        Arguments:\n            mydict : REQUIRED : The dictionary containing the elements to fetch (in \"properties\" key)\n            path : the path with dot notation.\n        \"\"\"\n        path = self.__cleanPath__(path)\n        pathSplit = path.split('.')\n        key = pathSplit[0]\n        if 'customFields' in mydict.keys():\n            level = self.__accessorAlgo__(mydict.get('customFields',{}).get('properties',{}),'.'.join(pathSplit))\n            if 'error' not in level.keys():\n                return level\n        if 'property' in mydict.keys() :\n            level = self.__accessorAlgo__(mydict.get('property',{}).get('properties',{}),'.'.join(pathSplit))\n            return level\n        level = mydict.get(key,None)\n        if level is not None:\n            if level[\"type\"] == \"object\":\n                levelProperties = mydict[key].get('properties',None)\n                if levelProperties is not None:\n                    level = self.__accessorAlgo__(levelProperties,'.'.join(pathSplit[1:]))\n                return level\n            elif level[\"type\"] == \"array\":\n                levelProperties = mydict[key]['items'].get('properties',None)\n                if levelProperties is not None:\n                    level = self.__accessorAlgo__(levelProperties,'.'.join(pathSplit[1:]))\n                return level\n            else:\n                if len(pathSplit) > 1: \n                    return {'error':f'cannot find the key \"{pathSplit[1]}\"'}\n                return level\n        else:\n            if key == \"\":\n                return mydict\n            return {'error':f'cannot find the key \"{key}\"'}\n\n    def __searchAlgo__(self,mydict:dict,string:str=None,partialMatch:bool=False,caseSensitive:bool=False,results:list=None,path:str=None,completePath:str=None)->list:\n        \"\"\"\n        recursive method to retrieve all the elements.\n        Arguments:\n            mydict : REQUIRED : The dictionary containing the elements to fetch (start with fieldGroup definition)\n            string : the string to look for with dot notation.\n            partialMatch : if you want to use partial match\n            caseSensitive : to see if we should lower case everything\n            results : the list of results to return\n            path : the path currently set\n            completePath : the complete path from the start.\n        \"\"\"\n        finalPath = None\n        if results is None:\n            results=[]\n        for key in mydict:\n            if caseSensitive == False:\n                keyComp = key.lower()\n                string = string.lower()\n            else:\n                keyComp = key\n                string = string\n            if partialMatch:\n                if string in keyComp:\n                    ### checking if element is an array without deeper object level\n                    if mydict[key].get('type') == 'array' and mydict[key]['items'].get('properties',None) is None:\n                        finalPath = path + f\".{key}[]\"\n                        if path is not None:\n                            finalPath = path + f\".{key}\"\n                        else:\n                            finalPath = f\"{key}\"\n                    else:\n                        if path is not None:\n                            finalPath = path + f\".{key}\"\n                        else:\n                            finalPath = f\"{key}\"\n                    value = deepcopy(mydict[key])\n                    value['path'] = finalPath\n                    value['queryPath'] = self.__cleanPath__(finalPath)\n                    if completePath is None:\n                        value['completePath'] = f\"/definitions/{key}\"\n                    else:\n                        value['completePath'] = completePath + \"/\" + key\n                    results.append({key:value})\n            else:\n                if caseSensitive == False:\n                    if keyComp == string:\n                        if path is not None:\n                            finalPath = path + f\".{key}\"\n                        else:\n                            finalPath = key\n                        value = deepcopy(mydict[key])\n                        value['path'] = finalPath\n                        value['queryPath'] = self.__cleanPath__(finalPath)\n                        if completePath is None:\n                            value['completePath'] = f\"/definitions/{key}\"\n                        else:\n                            value['completePath'] = completePath + \"/\" + key\n                        results.append({key:value})\n                else:\n                    if keyComp == string:\n                        if path is not None:\n                            finalPath = path + f\".{key}\"\n                        else:\n                            finalPath = key\n                        value = deepcopy(mydict[key])\n                        value['path'] = finalPath\n                        value['queryPath'] = self.__cleanPath__(finalPath)\n                        if completePath is None:\n                            value['completePath'] = f\"/definitions/{key}\"\n                        else:\n                            value['completePath'] = completePath + \"/\" + key\n                        results.append({key:value})\n            ## loop through keys\n            if mydict[key].get(\"type\") == \"object\" or 'properties' in mydict[key].keys():\n                levelProperties = mydict[key].get('properties',{})\n                if levelProperties != dict():\n                    if completePath is None:\n                        tmp_completePath = f\"/definitions/{key}\"\n                    else:\n                        tmp_completePath = f\"{completePath}/{key}\"\n                    tmp_completePath += f\"/properties\"\n                    if path is None:\n                        if key != \"property\" and key != \"customFields\" :\n                            tmp_path = key\n                        else:\n                            tmp_path = None\n                    else:\n                        tmp_path = f\"{path}.{key}\"\n                    results = self.__searchAlgo__(levelProperties,string,partialMatch,caseSensitive,results,tmp_path,tmp_completePath)\n            elif mydict[key].get(\"type\") == \"array\":\n                levelProperties = mydict[key]['items'].get('properties',{})\n                if levelProperties != dict():\n                    if completePath is None:\n                        tmp_completePath = f\"/definitions/{key}\"\n                    else:\n                        tmp_completePath = f\"{completePath}/{key}\"\n                    tmp_completePath += f\"/items/properties\"\n                    if levelProperties is not None:\n                        if path is None:\n                            if key != \"property\" and key != \"customFields\":\n                                tmp_path = key\n                            else:\n                                tmp_path = None\n                        else:\n                            tmp_path = f\"{path}.{key}[]{{}}\"\n                        results = self.__searchAlgo__(levelProperties,string,partialMatch,caseSensitive,results,tmp_path,tmp_completePath)\n        return results\n    \n    def __transformationDict__(self,mydict:dict=None,typed:bool=False,dictionary:dict=None)->dict:\n        \"\"\"\n        Transform the current XDM schema to a dictionary.\n        \"\"\"\n        if dictionary is None:\n            dictionary = {}\n        else:\n            dictionary = dictionary\n        for key in mydict:\n            if type(mydict[key]) == dict:\n                if mydict[key].get('type') == 'object' or 'properties' in mydict[key].keys():\n                    properties = mydict[key].get('properties',None)\n                    if properties is not None:\n                        if key != \"property\" and key != \"customFields\":\n                            if key not in dictionary.keys():\n                                dictionary[key] = {}\n                            self.__transformationDict__(mydict[key]['properties'],typed,dictionary=dictionary[key])\n                        else:\n                            self.__transformationDict__(mydict[key]['properties'],typed,dictionary=dictionary)\n                elif mydict[key].get('type') == 'array':\n                    levelProperties = mydict[key]['items'].get('properties',None)\n                    if levelProperties is not None:\n                        dictionary[key] = [{}]\n                        self.__transformationDict__(levelProperties,typed,dictionary[key][0])\n                    else:\n                        if typed:\n                            dictionary[key] = [mydict[key]['items'].get('type','object')]\n                        else:\n                            dictionary[key] = []\n                else:\n                    if typed:\n                        dictionary[key] = mydict[key].get('type','object')\n                    else:\n                        dictionary[key] = \"\"\n        return dictionary \n\n    def __transformationDF__(self,mydict:dict=None,dictionary:dict=None,path:str=None,queryPath:bool=False,description:bool=False,xdmType:bool=False)->dict:\n        \"\"\"\n        Transform the current XDM schema to a dictionary.\n        Arguments:\n            mydict : the fieldgroup\n            dictionary : the dictionary that gather the paths\n            path : path that is currently being developed\n            queryPath: boolean to tell if we want to add the query path\n            description : boolean to tell if you want to retrieve the description\n            xdmType : boolean to know if you want to retrieve the xdm Type\n        \"\"\"\n        if dictionary is None:\n            dictionary = {'path':[],'type':[]}\n            if queryPath:\n                dictionary['querypath'] = []\n            if description:\n                dictionary['description'] = []\n        else:\n            dictionary = dictionary\n        for key in mydict:\n            if type(mydict[key]) == dict:\n                if mydict[key].get('type') == 'object':\n                    if path is None:\n                        if key != \"property\" and key != \"customFields\":\n                            tmp_path = key\n                        else:\n                            tmp_path = None\n                    else:\n                        tmp_path = f\"{path}.{key}\"\n                    if tmp_path is not None:\n                        dictionary[\"path\"].append(tmp_path)\n                        dictionary[\"type\"].append(f\"{mydict[key].get('type')}\")\n                        if queryPath:\n                            dictionary[\"querypath\"].append(self.__cleanPath__(tmp_path))\n                        if description:\n                            dictionary[\"description\"].append(f\"{mydict[key].get('description','')}\")\n                    properties = mydict[key].get('properties',None)\n                    if properties is not None:\n                        self.__transformationDF__(properties,dictionary,tmp_path,queryPath,description)\n                elif mydict[key].get('type') == 'array':\n                    levelProperties = mydict[key]['items'].get('properties',None)\n                    if levelProperties is not None:\n                        if path is None:\n                            tmp_path = key\n                        else :\n                            tmp_path = f\"{path}.{key}[]{{}}\"\n                        dictionary[\"path\"].append(tmp_path)\n                        dictionary[\"type\"].append(f\"[{mydict[key]['items'].get('type')}]\")\n                        if queryPath and tmp_path is not None:\n                            dictionary[\"querypath\"].append(self.__cleanPath__(tmp_path))\n                        if description and tmp_path is not None:\n                            dictionary[\"description\"].append(mydict[key]['items'].get('description',''))\n                        self.__transformationDF__(levelProperties,dictionary,tmp_path,queryPath,description)\n                    else:\n                        finalpath = f\"{path}.{key}\"\n                        dictionary[\"path\"].append(finalpath)\n                        dictionary[\"type\"].append(f\"[{mydict[key]['items'].get('type')}]\")\n                        if queryPath and finalpath is not None:\n                            dictionary[\"querypath\"].append(self.__cleanPath__(finalpath))\n                        if description and finalpath is not None:\n                            dictionary[\"description\"].append(mydict[key]['items'].get('description',''))\n                else:\n                    if path is not None:\n                        finalpath = f\"{path}.{key}\"\n                    else:\n                        finalpath = f\"{key}\"\n                    dictionary[\"path\"].append(finalpath)\n                    dictionary[\"type\"].append(mydict[key].get('type','object'))\n                    if queryPath and finalpath is not None:\n                        dictionary[\"querypath\"].append(self.__cleanPath__(finalpath))\n                    if description and finalpath is not None:\n                        dictionary[\"description\"].append(mydict[key].get('description',''))\n\n        return dictionary\n    \n    def searchField(self,string:str=None,partialMatch:bool=True,caseSensitive:bool=False)-> dict:\n        \"\"\"\n        Search a field in the observable schema.\n        Arguments:\n            string : REQUIRED : the string to look for for one of the field\n            partialMatch : OPTIONAL : if you want to look for complete string or not. (default True)\n            caseSensitive : OPTIONAL : if you want to compare with case sensitivity or not. (default False)\n        \"\"\"\n        definition = self.observableSchema.get('properties',{})\n        data = self.__searchAlgo__(definition,string,partialMatch,caseSensitive)\n        return data\n    \n    def to_dataframe(self,save:bool=False,queryPath:bool=False,description:bool=False)->pd.DataFrame:\n        \"\"\"\n        Generate a dataframe with the row representing each possible path.\n        Arguments:\n            save : OPTIONAL : If you wish to save it with the title used by the field group.\n                save as csv with the title used. Not title, used \"unknown_fieldGroup_\" + timestamp.\n            queryPath : OPTIONAL : If you want to have the query path to be used.\n            description : OPTIONAL : If you want to have the description used\n        \"\"\"\n        definition = self.observableSchema.get('properties',{})\n        data = self.__transformationDF__(definition,queryPath=queryPath,description=description)\n        df = pd.DataFrame(data)\n        if save:\n            title = self.observableSchema.get('title',f'unknown_fieldGroup_{str(int(time.time()))}')\n            df.to_csv(f\"{title}.csv\",index=False)\n        return df\n    \n    def to_dict(self,typed:bool=True,save:bool=False)->dict:\n        \"\"\"\n        Generate a dictionary representing the field group constitution\n        Arguments:\n            typed : OPTIONAL : If you want the type associated with the field group to be given.\n            save : OPTIONAL : If you wish to save the dictionary in a JSON file\n        \"\"\"\n        definition = self.observableSchema.get('properties',{})\n        data = self.__transformationDict__(definition,typed)\n        if save:\n            filename = self.observableSchema.get('title',f'unknown_fieldGroup_{str(int(time.time()))}')\n            aepp.saveFile(module='catalog',file=data,filename=f\"{filename}.json\",type_file='json')\n        return data\n\n    def compareSchemaAvailability(self,schemaManager:'SchemaManager'=None)->dict:\n        \"\"\"\n        A method to compare the existing schema with the observable schema and find out the difference in them.\n        It output a dataframe with all of the path, the field group, the type (if provided) and the part availability (in that dataset)\n        Arguments:\n            SchemaManager : REQUIRED : the SchemaManager class instance for that schema.\n        \"\"\"\n        if schemaManager is None:\n            raise ValueError(\"Require a SchemaManager class instance\")\n        df_schema = schemaManager.to_dataframe()\n        df_obs = self.to_dataframe()\n        df_merge = df_schema.merge(df_obs,left_on='path',right_on='path',how='left',indicator=True)\n        df_merge = df_merge.rename(columns={\"_merge\": \"availability\",'type_x':'type'})\n        df_merge = df_merge.drop(\"type_y\",axis=1)\n        df_merge['availability'] = df_merge['availability'].str.replace('left_only','schema_only')\n        df_merge['availability'] = df_merge['availability'].str.replace('both','schema_dataset')\n        return df_merge"]}
{"filename": "aepp/schema.py", "chunked_list": ["#  Copyright 2023 Adobe. All rights reserved.\n#  This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License. You may obtain a copy\n#  of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software distributed under\n#  the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n#  OF ANY KIND, either express or implied. See the License for the specific language\n#  governing permissions and limitations under the License.\n", "#  governing permissions and limitations under the License.\n\n# Internal Library\nimport aepp\nfrom dataclasses import dataclass\nfrom aepp import connector\nfrom copy import deepcopy\nfrom typing import Union\nimport time\nimport logging", "import time\nimport logging\nimport pandas as pd\nimport json\nimport re\nfrom .configs import ConnectObject\n\njson_extend = [\n    {\n        \"op\": \"replace\",", "    {\n        \"op\": \"replace\",\n        \"path\": \"/meta:intendedToExtend\",\n        \"value\": [\n            \"https://ns.adobe.com/xdm/context/profile\",\n            \"https://ns.adobe.com/xdm/context/experienceevent\",\n        ],\n    }\n]\n", "]\n\n\n@dataclass\nclass _Data:\n    def __init__(self):\n        self.schemas = {}\n        self.schemas_id = {}\n        self.schemas_altId = {}\n        self.fieldGroups_id = {}\n        self.fieldGroups_altId = {}\n        self.fieldGroups = {}", "\n\nclass Schema:\n    \"\"\"\n    This class is a wrapper around the schema registry API for Adobe Experience Platform.\n    More documentation on these endpoints can be found here :\n    https://www.adobe.io/apis/experienceplatform/home/api-reference.html#!acpdr/swagger-specs/schema-registry.yaml\n\n    When Patching a schema, you can use the PATCH_OBJ reference to help you.\n    \"\"\"\n\n    schemas = {}  # caching\n\n    ## logging capability\n    loggingEnabled = False\n    logger = None\n\n    _schemaClasses = {\n        \"event\": \"https://ns.adobe.com/xdm/context/experienceevent\",\n        \"profile\": \"https://ns.adobe.com/xdm/context/profile\",\n    }\n    PATCH_OBJ = [{\"op\": \"add\", \"path\": \"/meta:immutableTags-\", \"value\": \"union\"}]\n    DESCRIPTOR_TYPES =[\"xdm:descriptorIdentity\",\"xdm:alternateDisplayInfo\",\"xdm:descriptorOneToOne\",\"xdm:descriptorReferenceIdentity\",\"xdm:descriptorDeprecated\"]\n\n    def __init__(\n        self,\n        containerId: str = \"tenant\",\n        config: Union[dict,ConnectObject] = aepp.config.config_object,\n        header=aepp.config.header,\n        loggingObject: dict = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Copy the token and header and initiate the object to retrieve schema elements.\n        Arguments:\n            containerId : OPTIONAL : \"tenant\"(default) or \"global\"\n            loggingObject : OPTIONAL : logging object to log messages.\n            config : OPTIONAL : config object in the config module.\n            header : OPTIONAL : header object  in the config module.\n        possible kwargs:\n            x-sandbox-name : name of the sandbox you want to use (default : \"prod\").\n        \"\"\"\n        if loggingObject is not None and sorted(\n            [\"level\", \"stream\", \"format\", \"filename\", \"file\"]\n        ) == sorted(list(loggingObject.keys())):\n            self.loggingEnabled = True\n            self.logger = logging.getLogger(f\"{__name__}\")\n            self.logger.setLevel(loggingObject[\"level\"])\n            if type(loggingObject[\"format\"]) == str:\n                formatter = logging.Formatter(loggingObject[\"format\"])\n            elif type(loggingObject[\"format\"]) == logging.Formatter:\n                formatter = loggingObject[\"format\"]\n            if loggingObject[\"file\"]:\n                fileHandler = logging.FileHandler(loggingObject[\"filename\"])\n                fileHandler.setFormatter(formatter)\n                self.logger.addHandler(fileHandler)\n            if loggingObject[\"stream\"]:\n                streamHandler = logging.StreamHandler()\n                streamHandler.setFormatter(formatter)\n                self.logger.addHandler(streamHandler)\n        if type(config) == dict: ## Supporting either default setup or passing a ConnectObject\n            config = config\n        elif type(config) == ConnectObject:\n            header = config.getConfigHeader()\n            config = config.getConfigObject()\n        self.connector = connector.AdobeRequest(\n            config=config,\n            header=header,\n            loggingEnabled=self.loggingEnabled,\n            logger=self.logger,\n        )\n        self.header = self.connector.header\n        self.header[\"Accept\"] = \"application/vnd.adobe.xed+json\"\n        self.connector.header['Accept'] = \"application/vnd.adobe.xed+json\"\n        if kwargs.get('sandbox',None) is not None: ## supporting sandbox setup on class instanciation\n            self.sandbox = kwargs.get('sandbox')\n            self.connector.config[\"sandbox\"] = kwargs.get('sandbox')\n            self.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n            self.connector.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n        else:\n            self.sandbox = self.connector.config[\"sandbox\"]\n        self.header.update(**kwargs)\n        self.endpoint = (\n            aepp.config.endpoints[\"global\"] + aepp.config.endpoints[\"schemas\"]\n        )\n        self.container = containerId\n        self.data = _Data()\n\n    def getResource(\n        self,\n        endpoint: str = None,\n        params: dict = None,\n        format: str = \"json\",\n        save: bool = False,\n        **kwargs,\n    ) -> dict:\n        \"\"\"\n        Template for requesting data with a GET method.\n        Arguments:\n            endpoint : REQUIRED : The URL to GET\n            params: OPTIONAL : dictionary of the params to fetch\n            format : OPTIONAL : Type of response returned. Possible values:\n                json : default\n                txt : text file\n                raw : a response object from the requests module\n        \"\"\"\n        if endpoint is None:\n            raise ValueError(\"Require an endpoint\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getResource\")\n        res = self.connector.getData(endpoint, params=params, format=format)\n        if save:\n            if format == \"json\":\n                aepp.saveFile(\n                    module=\"catalog\",\n                    file=res,\n                    filename=f\"resource_{int(time.time())}\",\n                    type_file=\"json\",\n                    encoding=kwargs.get(\"encoding\", \"utf-8\"),\n                )\n            elif format == \"txt\":\n                aepp.saveFile(\n                    module=\"catalog\",\n                    file=res,\n                    filename=f\"resource_{int(time.time())}\",\n                    type_file=\"txt\",\n                    encoding=kwargs.get(\"encoding\", \"utf-8\"),\n                )\n            else:\n                print(\n                    \"element is an object. Output is unclear. No save made.\\nPlease save this element manually\"\n                )\n        return res\n\n    def updateSandbox(self, sandbox: str = None) -> None:\n        \"\"\"\n        Update the sandbox used in your request.\n        Arguments:\n            sandbox : REQUIRED : name of the sandbox to be used\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting updateSandbox\")\n        if not sandbox:\n            raise ValueError(\"`sandbox` must be specified in the arguments.\")\n        self.header[\"x-sandbox-name\"] = sandbox\n        self.sandbox = sandbox\n\n    def getStats(self) -> list:\n        \"\"\"\n        Returns a list of the last actions realized on the Schema for this instance of AEP.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getStats\")\n        path = \"/stats/\"\n        res = self.connector.getData(self.endpoint + path, headers=self.header)\n        return res\n\n    def getTenantId(self) -> str:\n        \"\"\"\n        Return the tenantID for the AEP instance.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getTenantId\")\n        res = self.getStats()\n        tenant = res[\"tenantId\"]\n        return tenant\n\n    def getBehaviors(self)->list:\n        \"\"\"\n        Return a list of behaviors.\n        \"\"\"\n        path = \"/global/behaviors\"\n        res = self.connector.getData(self.endpoint + path)\n        data = res.get(\"results\",[])\n        return data\n\n    def getBehavior(self,behaviorId:str=None)->dict:\n        \"\"\"\n        Retrieve a specific behavior for class creation.\n        Arguments:\n            behaviorId : REQUIRED : the behavior ID to be retrieved.\n        \"\"\"\n        if behaviorId is None:\n            raise Exception(\"Require a behavior ID\")\n        path = f\"/global/behaviors/{behaviorId}\"\n        res = self.connector.getData(self.endpoint + path)\n        return res\n\n    def getSchemas(\n            self, \n            classFilter: str = None,\n            excludeAdhoc: bool = False,\n            output: str = 'raw',\n            **kwargs\n    ) -> list:\n        \"\"\"\n        Returns the list of schemas retrieved for that instances in a \"results\" list.\n        Arguments:\n            classFilter : OPTIONAL : filter to a specific class.\n                Example :\n                    https://ns.adobe.com/xdm/context/experienceevent\n                    https://ns.adobe.com/xdm/context/profile\n                    https://ns.adobe.com/xdm/data/adhoc\n            excludeAdhoc : OPTIONAL : exclude the adhoc schemas\n            output : OPTIONAL : either \"raw\" for a list or \"df\" for dataframe\n        Possible kwargs:\n            debug : if set to true, will print the result when error happens\n            format : if set to \"xed\", returns the full JSON for each resource (default : \"xed-id\" -  short summary)\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getSchemas\")\n        path = f\"/{self.container}/schemas/\"\n        start = kwargs.get(\"start\", 0)\n        params = {\"start\": start}\n        if classFilter is not None:\n            params[\"property\"] = f\"meta:intendedToExtend=={classFilter}\"\n        if excludeAdhoc:\n            params[\"property\"] = \"meta:extends!=https://ns.adobe.com/xdm/data/adhoc\"\n        verbose = kwargs.get(\"debug\", False)\n        privateHeader = deepcopy(self.header)\n        format = kwargs.get(\"format\", \"xed-id\")\n        privateHeader[\"Accept\"] = f\"application/vnd.adobe.{format}+json\"\n        res = self.connector.getData(\n            self.endpoint + path, params=params, headers=privateHeader, verbose=verbose\n        )\n        if kwargs.get(\"debug\", False):\n            if \"results\" not in res.keys():\n                print(res)\n        data = res.get(\"results\",[])\n        if len(data) == 0:\n            return res\n        page = res.get(\"_page\",{})\n        nextPage = page.get('next',None)\n        while nextPage is not None:\n            params['start'] = nextPage\n            res = self.connector.getData(\n            self.endpoint + path, params=params, headers=privateHeader, verbose=verbose\n            )\n            data += res.get('results',[])\n            page = res.get(\"_page\",{'next':None})\n            nextPage = page.get('next',None)\n        self.data.schemas_id = {schem[\"title\"]: schem[\"$id\"] for schem in data}\n        self.data.schemas_altId = {\n            schem[\"title\"]: schem[\"meta:altId\"] for schem in data\n        }\n        if output == 'df':\n            df = pd.DataFrame(data)\n            return df\n        return data\n\n    def getSchema(\n        self,\n        schemaId: str = None,\n        version: int = 1,\n        full: bool = True,\n        desc: bool = False,\n        deprecated:bool=False,\n        schema_type: str = \"xdm\",\n        flat: bool = False,\n        save: bool = False,\n        **kwargs,\n    ) -> dict:\n        \"\"\"\n        Get the Schema. Requires a schema id.\n        Response provided depends on the header set, you can change the Accept header with kwargs.\n        Arguments:\n            schemaId : REQUIRED : $id or meta:altId\n            version : OPTIONAL : Version of the Schema asked (default 1)\n            full : OPTIONAL : True (default) will return the full schema.False just the relationships.\n            desc : OPTIONAL : If set to True, return the identity used as the descriptor.\n            deprecated : OPTIONAL : Display the deprecated field from that schema\n            flat : OPTIONAL : If set to True, return a flat schema for pathing.\n            schema_type : OPTIONAL : set the type of output you want (xdm or xed) Default : xdm.\n            save : OPTIONAL : save the result in json file (default False)\n        Possible kwargs:\n            Accept : Accept header to change the type of response.\n            # /Schemas/lookup_schema\n            more details held here : https://www.adobe.io/apis/experienceplatform/home/api-reference.html\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getSchema\")\n        privateHeader = deepcopy(self.header)\n        if schemaId is None:\n            raise Exception(\"Require a schemaId as a parameter\")\n        update_full,update_desc,update_flat,update_deprecated=\"\",\"\",\"\",\"\"\n        if full:\n            update_full = \"-full\"\n        if desc:\n            update_desc = \"-desc\"\n        if flat:\n            update_flat = \"-flat\"\n        if deprecated:\n            update_deprecated = \"-deprecated\"\n        if schema_type != \"xdm\" and schema_type != \"xed\":\n            raise ValueError(\"schema_type parameter can only be xdm or xed\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getSchema\")\n        privateHeader['Accept'] = f\"application/vnd.adobe.{schema_type}{update_full}{update_desc}{update_flat}{update_deprecated}+json; version={version}\"\n        if kwargs.get(\"Accept\", None) is not None:\n            privateHeader[\"Accept\"] = kwargs.get(\"Accept\", self.header[\"Accept\"])\n        privateHeader[\"Accept-Encoding\"] = \"identity\"\n        if schemaId.startswith(\"https://\"):\n            from urllib import parse\n            schemaId = parse.quote_plus(schemaId)\n        path = f\"/{self.container}/schemas/{schemaId}\"\n        res = self.connector.getData(self.endpoint + path, headers=privateHeader)\n        if \"title\" not in res.keys() and \"notext\" not in privateHeader[\"Accept\"]:\n            print(\"Issue with the request. See response.\")\n            return res\n        if save:\n            aepp.saveFile(\n                module=\"schema\", file=res, filename=res[\"title\"], type_file=\"json\"\n            )\n        if \"title\" in res.keys():\n            self.data.schemas[res[\"title\"]] = res\n        else:\n            print(\"no title in the response. Not saved in the data object.\")\n        return res\n\n    def getSchemaPaths(\n        self, schemaId: str, simplified: bool = True, save: bool = False\n    ) -> list:\n        \"\"\"\n        Returns a list of the path available in your schema. BETA.\n        Arguments:\n            schemaId : REQUIRED : The schema you want to retrieve the paths for\n            simplified : OPTIONAL : Default True, only returns the list of paths for your schemas.\n            save : OPTIONAL : Save your schema paths in a file. Always the NOT simplified version.\n        \"\"\"\n        if schemaId is None:\n            raise Exception(\"Require a schemaId as a parameter\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getSchemaPaths\")\n        res = self.getSchema(schemaId, flat=True)\n        keys = res[\"properties\"].keys()\n        paths = [\n            key.replace(\"/\", \".\").replace(\"xdm:\", \"\").replace(\"@\", \"_\") for key in keys\n        ]\n        if save:\n            aepp.saveFile(\n                module=\"schema\",\n                file=res,\n                filename=f\"{res['title']}_paths\",\n                type_file=\"json\",\n            )\n        if simplified:\n            return paths\n        return res\n\n    def getSchemaSample(\n        self, schemaId: str = None, save: bool = False, version: int = 1\n    ) -> dict:\n        \"\"\"\n        Generate a sample data from a schema id.\n        Arguments:\n            schema_id : REQUIRED : The schema ID for the sample data to be created.\n            save : OPTIONAL : save the result in json file (default False)\n            version : OPTIONAL : version of the schema to request\n        \"\"\"\n        privateHeader = deepcopy(self.header)\n        import random\n\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getSchemaSample\")\n        rand_number = random.randint(1, 10e10)\n        if schemaId is None:\n            raise Exception(\"Require an ID for the schema\")\n        if schemaId.startswith(\"https://\"):\n            from urllib import parse\n\n            schemaId = parse.quote_plus(schemaId)\n        path = f\"/rpc/sampledata/{schemaId}\"\n        accept_update = f\"application/vnd.adobe.xed+json; version={version}\"\n        privateHeader[\"Accept\"] = accept_update\n        res = self.connector.getData(self.endpoint + path, headers=privateHeader)\n        if save:\n            schema = self.getSchema(schemaId=schemaId, full=False)\n            aepp.saveFile(\n                module=\"schema\",\n                file=res,\n                filename=f\"{schema['title']}_{rand_number}\",\n                type_file=\"json\",\n            )\n        return res\n\n    def patchSchema(self, schemaId: str = None, changes: list = None, **kwargs) -> dict:\n        \"\"\"\n        Enable to patch the Schema with operation.\n        Arguments:\n            schema_id : REQUIRED : $id or meta:altId\n            change : REQUIRED : List of changes that need to take place.\n            Example:\n                [\n                    {\n                        \"op\": \"add\",\n                        \"path\": \"/allOf\",\n                        \"value\": {'$ref': 'https://ns.adobe.com/emeaconsulting/mixins/fb5b3cd49707d27367b93e07d1ac1f2f7b2ae8d051e65f8d',\n                    'type': 'object',\n                    'meta:xdmType': 'object'}\n                    }\n                ]\n        information : http://jsonpatch.com/\n        \"\"\"\n        if schemaId is None:\n            raise Exception(\"Require an ID for the schema\")\n        if type(changes) == dict:\n            changes = list(changes)\n        if schemaId.startswith(\"https://\"):\n            from urllib import parse\n\n            schemaId = parse.quote_plus(schemaId)\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting patchSchema\")\n        path = f\"/{self.container}/schemas/{schemaId}\"\n        res = self.connector.patchData(\n            self.endpoint + path, data=changes)\n        return res\n\n    def putSchema(self, schemaId: str = None, schemaDef: dict = None, **kwargs) -> dict:\n        \"\"\"\n        A PUT request essentially re-writes the schema, therefore the request body must include all fields required to create (POST) a schema.\n        This is especially useful when updating a lot of information in the schema at once.\n        Arguments:\n            schemaId : REQUIRED : $id or meta:altId\n            schemaDef : REQUIRED : dictionary of the new schema.\n            It requires a allOf list that contains all the attributes that are required for creating a schema.\n            #/Schemas/replace_schema\n            More information on : https://www.adobe.io/apis/experienceplatform/home/api-reference.html\n        \"\"\"\n        if schemaId is None:\n            raise Exception(\"Require an ID for the schema\")\n        if schemaId.startswith(\"https://\"):\n            from urllib import parse\n            schemaId = parse.quote_plus(schemaId)\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting putSchema\")\n        path = f\"/{self.container}/schemas/{schemaId}\"\n        res = self.connector.putData(\n            self.endpoint + path, data=schemaDef, headers=self.header\n        )\n        return res\n\n    def deleteSchema(self, schemaId: str = None, **kwargs) -> str:\n        \"\"\"\n        Delete the request\n        Arguments:\n            schema_id : REQUIRED : $id or meta:altId\n            It requires a allOf list that contains all the attributes that are required for creating a schema.\n            #/Schemas/replace_schema\n            More information on : https://www.adobe.io/apis/experienceplatform/home/api-reference.html\n        \"\"\"\n        if schemaId is None:\n            raise Exception(\"Require an ID for the schema\")\n        if schemaId.startswith(\"https://\"):\n            from urllib import parse\n            schemaId = parse.quote_plus(schemaId)\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteSchema\")\n        path = f\"/{self.container}/schemas/{schemaId}\"\n        res = self.connector.deleteData(self.endpoint + path)\n        return res\n\n    def createSchema(self, schema: dict = None) -> dict:\n        \"\"\"\n        Create a Schema based on the data that are passed in the Argument.\n        Arguments:\n            schema : REQUIRED : The schema definition that needs to be created.\n        \"\"\"\n        path = f\"/{self.container}/schemas/\"\n        if type(schema) != dict:\n            raise TypeError(\"Expecting a dictionary\")\n        if \"allOf\" not in schema.keys():\n            raise Exception(\n                \"The schema must include an \u2018allOf\u2019 attribute (a list) referencing the $id of the base class the schema will implement.\"\n            )\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createSchema\")\n        res = self.connector.postData(\n            self.endpoint + path, data=schema\n        )\n        return res\n\n    def createExperienceEventSchema(\n        self,\n        name: str = None,\n        mixinIds: Union[list, dict] = None,\n        fieldGroupIds : Union[list, dict] = None,\n        description: str = \"\",\n    ) -> dict:\n        \"\"\"\n        Create an ExperienceEvent schema based on the list mixin ID provided.\n        Arguments:\n            name : REQUIRED : Name of your schema\n            mixinIds : REQUIRED : dict of mixins $id and their type [\"object\" or \"array\"] to create the ExperienceEvent schema\n                Example {'mixinId1':'object','mixinId2':'array'}\n                if just a list is passed, it infers a 'object type'\n            fieldGroupIds : REQUIRED : List of fieldGroup $id to create the Indiviudal Profile schema\n                Example {'fgId1':'object','fgId2':'array'}\n                if just a list is passed, it infers a 'object type'\n            description : OPTIONAL : Schema description\n        \"\"\"\n        if name is None:\n            raise ValueError(\"Require a name\")\n        if mixinIds is None and fieldGroupIds is None:\n            raise ValueError(\"Require a mixin ids or a field group id\")\n        if mixinIds is None and fieldGroupIds is not None:\n            mixinIds = fieldGroupIds\n        obj = {\n            \"title\": name,\n            \"description\": description,\n            \"allOf\": [\n                {\n                    \"$ref\": \"https://ns.adobe.com/xdm/context/experienceevent\",\n                    \"type\": \"object\",\n                    \"meta:xdmType\": \"object\",\n                }\n            ],\n        }\n        if type(mixinIds) == list:\n            for mixin in mixinIds:\n                obj[\"allOf\"].append(\n                    {\"$ref\": mixin, \"type\": \"object\", \"meta:xdmType\": \"object\"}\n                )\n        if type(mixinIds) == dict:\n            for mixin in mixinIds:\n                if mixinIds[mixin] == \"array\":\n                    subObj = {\n                        \"$ref\": mixin,\n                        \"type\": mixinIds[mixin],\n                        \"meta:xdmType\": mixinIds[mixin],\n                        \"items\": {\"$ref\": mixin},\n                    }\n                    obj[\"allOf\"].append(subObj)\n                else:\n                    subObj = {\n                        \"$ref\": mixin,\n                        \"type\": mixinIds[mixin],\n                        \"meta:xdmType\": mixinIds[mixin],\n                    }\n                    obj[\"allOf\"].append(subObj)\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createExperienceEventSchema\")\n        res = self.createSchema(obj)\n        return res\n\n    def createProfileSchema(\n        self,\n        name: str = None,\n        mixinIds: Union[list, dict] = None,\n        fieldGroupIds : Union[list, dict] = None,\n        description: str = \"\",\n        **kwargs\n    ) -> dict:\n        \"\"\"\n        Create an IndividualProfile schema based on the list mixin ID provided.\n        Arguments:\n            name : REQUIRED : Name of your schema\n            mixinIds : REQUIRED : List of mixins $id to create the Indiviudal Profile schema\n                Example {'mixinId1':'object','mixinId2':'array'}\n                if just a list is passed, it infers a 'object type'\n            fieldGroupIds : REQUIRED : List of fieldGroup $id to create the Indiviudal Profile schema\n                Example {'fgId1':'object','fgId2':'array'}\n                if just a list is passed, it infers a 'object type'\n            description : OPTIONAL : Schema description\n        \"\"\"\n        if name is None:\n            raise ValueError(\"Require a name\")\n        if mixinIds is None and fieldGroupIds is None:\n            raise ValueError(\"Require a mixin ids or a field group id\")\n        if mixinIds is None and fieldGroupIds is not None:\n            mixinIds = fieldGroupIds\n        obj = {\n            \"title\": name,\n            \"description\": description,\n            \"allOf\": [\n                {\n                    \"$ref\": \"https://ns.adobe.com/xdm/context/profile\",\n                    \"type\": \"object\",\n                    \"meta:xdmType\": \"object\",\n                }\n            ],\n        }\n        if type(mixinIds) == list:\n            for mixin in mixinIds:\n                obj[\"allOf\"].append(\n                    {\"$ref\": mixin, \"type\": \"object\", \"meta:xdmType\": \"object\"}\n                )\n        if type(mixinIds) == dict:\n            for mixin in mixinIds:\n                if mixinIds[mixin] == \"array\":\n                    subObj = {\n                        \"$ref\": mixin,\n                        \"type\": mixinIds[mixin],\n                        \"meta:xdmType\": mixinIds[mixin],\n                        \"items\": {\"$ref\": mixin},\n                    }\n                    obj[\"allOf\"].append(subObj)\n                else:\n                    subObj = {\n                        \"$ref\": mixin,\n                        \"type\": mixinIds[mixin],\n                        \"meta:xdmType\": mixinIds[mixin],\n                    }\n                    obj[\"allOf\"].append(subObj)\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createProfileSchema\")\n        res = self.createSchema(obj)\n        return res\n    \n    def addFieldGroupToSchema(self,schemaId:str=None,fieldGroupIds:Union[list,dict]=None)->dict:\n        \"\"\"\n        Take the list of field group ID to extend the schema.\n        Return the definition of the new schema with added field groups.\n        Arguments\n            schemaId : REQUIRED : The ID of the schema (alt:metaId or $id)\n            fieldGroupIds : REQUIRED : The IDs of the fields group to add. It can be a list or dictionary.\n                Example {'fgId1':'object','fgId2':'array'}\n                if just a list is passed, it infers a 'object type'\n        \"\"\"\n        if schemaId is None:\n            raise ValueError(\"Require a schema ID\")\n        if fieldGroupIds is None:\n            raise ValueError(\"Require a list of field group to add\")\n        schemaDef = self.getSchema(schemaId,full=False)\n        allOf = schemaDef.get('allOf',[])\n        if type(allOf) != list:\n            raise TypeError(\"Expecting a list for 'allOf' key\")\n        if type(fieldGroupIds) == list:\n            for mixin in fieldGroupIds:\n                allOf.append(\n                    {\"$ref\": mixin, \"type\": \"object\", \"meta:xdmType\": \"object\"}\n                )\n        if type(fieldGroupIds) == dict:\n            for mixin in fieldGroupIds:\n                if fieldGroupIds[mixin] == \"array\":\n                    subObj = {\n                        \"$ref\": mixin,\n                        \"type\": fieldGroupIds[mixin],\n                        \"meta:xdmType\": fieldGroupIds[mixin],\n                        \"items\": {\"$ref\": mixin},\n                    }\n                    allOf.append(subObj)\n                else:\n                    subObj = {\n                        \"$ref\": mixin,\n                        \"type\": fieldGroupIds[mixin],\n                        \"meta:xdmType\": fieldGroupIds[mixin],\n                    }\n                    allOf.append(subObj)\n        res = self.putSchema(schemaId,schemaDef)\n        return res        \n\n    def getClasses(self, \n                   prop:str=None,\n                   orderBy:str=None,\n                   limit:int=300, \n                   output:str='raw',\n                   excludeAdhoc: bool = False,\n                   **kwargs):\n        \"\"\"\n        Return the classes of the AEP Instances.\n        Arguments:\n            prop : OPTIONAL : A comma-separated list of top-level object properties to be returned in the response. \n                            For example, property=meta:intendedToExtend==https://ns.adobe.com/xdm/context/profile\n            oderBy : OPTIONAL : Sort the listed resources by specified fields. For example orderby=title\n            limit : OPTIONAL : Number of resources to return per request, default 300 - the max.\n            excludeAdhoc : OPTIONAL : Exlcude the Adhoc classes that have been created.\n            output : OPTIONAL : type of output, default \"raw\", can be \"df\" for dataframe.\n        kwargs:\n            debug : if set to True, will print result for errors\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getClasses\")\n        privateHeader = deepcopy(self.header)\n        privateHeader.update({\"Accept\": \"application/vnd.adobe.xdm-id+json\"})\n        params = {\"limit\":limit}\n        if excludeAdhoc:\n            params[\"property\"] = \"meta:extends!=https://ns.adobe.com/xdm/data/adhoc\"\n        if prop is not None:\n            if 'property' not in params.keys():\n                params[\"property\"] = prop\n            else:\n                params[\"property\"] += prop\n        if orderBy is not None:\n            params['orderby'] = orderBy\n        path = f\"/{self.container}/classes/\"\n        verbose = kwargs.get(\"verbose\", False)\n        res = self.connector.getData(\n            self.endpoint + path, headers=privateHeader, params=params, verbose=verbose\n        )\n        if kwargs.get(\"debug\", False):\n            if \"results\" not in res.keys():\n                print(res)\n        data = res[\"results\"]\n        page = res[\"_page\"]\n        while page[\"next\"] is not None:\n            params[\"start\"]= page[\"next\"]\n            res = self.connector.getData(\n                self.endpoint + path, headers=privateHeader, params=params, verbose=verbose\n            )\n            data += res[\"results\"]\n            page = res[\"_page\"]\n        if output==\"df\":\n            df = pd.DataFrame(data)\n            return df\n        return data\n        \n    def getClassesGlobal(self, \n                   prop:str=None,\n                   orderBy:str=None,\n                   limit:int=300, \n                   output:str='raw',\n                   **kwargs):\n        \"\"\"\n        Return the classes of the AEP Instances.\n        Arguments:\n            prop : OPTIONAL : A comma-separated list of top-level object properties to be returned in the response. \n                            For example, property=meta:intendedToExtend==https://ns.adobe.com/xdm/context/profile\n            oderBy : OPTIONAL : Sort the listed resources by specified fields. For example orderby=title\n            limit : OPTIONAL : Number of resources to return per request, default 300 - the max.\n            output : OPTIONAL : type of output, default \"raw\", can be \"df\" for dataframe.\n        kwargs:\n            debug : if set to True, will print result for errors\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getClasses\")\n        privateHeader = deepcopy(self.header)\n        privateHeader.update({\"Accept\": \"application/vnd.adobe.xdm-id+json\"})\n        params = {\"limit\":limit}\n        if prop is not None:\n            if 'property' not in params.keys():\n                params[\"property\"] = prop\n            else:\n                params[\"property\"] += prop\n        if orderBy is not None:\n            params['orderby'] = orderBy\n        path = f\"/global/classes/\"\n        verbose = kwargs.get(\"verbose\", False)\n        res = self.connector.getData(\n            self.endpoint + path, headers=privateHeader, params=params, verbose=verbose\n        )\n        if kwargs.get(\"debug\", False):\n            if \"results\" not in res.keys():\n                print(res)\n        data = res[\"results\"]\n        page = res[\"_page\"]\n        while page[\"next\"] is not None:\n            params[\"start\"]= page[\"next\"]\n            res = self.connector.getData(\n                self.endpoint + path, headers=privateHeader, params=params, verbose=verbose\n            )\n            data += res[\"results\"]\n            page = res[\"_page\"]\n        if output==\"df\":\n            df = pd.DataFrame(data)\n            return df\n        return data\n\n    def getClass(\n        self,\n        classId: str = None,\n        full: bool = True,\n        desc: bool = False,\n        deprecated: bool = False,\n        xtype : str = \"xdm\",\n        version: int = 1,\n        save: bool = False,\n    ):\n        \"\"\"\n        Return a specific class.\n        Arguments:\n            classId : REQUIRED : the meta:altId or $id from the class\n            full : OPTIONAL : True (default) will return the full schema.False just the relationships.\n            desc : OPTIONAL : If set to True, return the descriptors.\n            deprecated : OPTIONAL : Display the deprecated field from that schema (False by default)\n            xtype : OPTIONAL : either \"xdm\" (default) or \"xed\". \n            version : OPTIONAL : the version of the class to retrieve.\n            save : OPTIONAL : To save the result of the request in a JSON file.\n        \"\"\"\n        privateHeader = deepcopy(self.header)\n        if classId is None:\n            raise Exception(\"Require a class_id\")\n        if classId.startswith(\"https://\"):\n            from urllib import parse\n            classId = parse.quote_plus(classId)\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getClass\")\n        privateHeader[\"Accept-Encoding\"] = \"identity\"\n        updateFull,updateDesc, updateDeprecated = \"\",\"\",\"\"\n        if full:\n            updateFull = \"-full\"\n        if desc:\n            updateDesc = \"-desc\"\n        if deprecated:\n            updateDeprecated = \"-deprecated\"\n        privateHeader.update(\n                {\"Accept\": f\"application/vnd.adobe.{xtype}{updateFull}{updateDesc}{updateDeprecated}+json; version=\" + str(version)}\n            )\n        path = f\"/{self.container}/classes/{classId}\"\n        res = self.connector.getData(self.endpoint + path, headers=privateHeader)\n        if save:\n            aepp.saveFile(\n                module=\"schema\", file=res, filename=res[\"title\"], type_file=\"json\"\n            )\n        return res\n\n    def createClass(self, class_obj: dict = None,title:str=None, class_template:str=None, **kwargs):\n        \"\"\"\n        Create a class based on the object pass. It should include the \"allOff\" element.\n        Arguments:\n            class_obj : REQUIRED : You can pass a complete object to create a class, include a title and a \"allOf\" element.\n            title : REQUIRED : Title of the class if you want to pass individual elements\n            class_template : REQUIRED : type of behavior for the class, either \"https://ns.adobe.com/xdm/data/record\" or \"https://ns.adobe.com/xdm/data/time-series\"\n        Possible kwargs: \n            description : To add a description to a class.\n        \"\"\"\n        path = f\"/{self.container}/classes/\"\n        \n        if class_obj is not None:\n            if type(class_obj) != dict:\n                raise TypeError(\"Expecting a dictionary\")\n            if \"allOf\" not in class_obj.keys():\n                raise Exception(\n                    \"The class object must include an \u2018allOf\u2019 attribute (a list) referencing the $id of the base class the schema will implement.\"\n                )\n        elif class_obj is None and title is not None and class_template is not None:\n            class_obj = {\n                \"type\": \"object\",\n                \"title\": title,\n                \"description\": \"Generated by aepp\",\n                \"allOf\": [\n                    {\n                    \"$ref\": class_template\n                    }\n                ]\n                }\n        if kwargs.get(\"descriptor\",\"\") != \"\":\n            class_obj['descriptor'] = kwargs.get(\"descriptor\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createClass\")\n        res = self.connector.postData(\n            self.endpoint + path, data=class_obj\n        )\n        return res\n    \n    def putClass(self,classId:str=None,class_obj:dict=None)->dict:\n        \"\"\"\n        Replace the current definition with the new definition.\n        Arguments:\n            classId : REQUIRED : The class to be updated ($id or meta:altId)\n            class_obj : REQUIRED : The dictionary defining the new class definition\n        \"\"\"\n        if classId is None:\n            raise Exception(\"Require a classId\")\n        if classId.startswith(\"https://\"):\n            from urllib import parse\n            classId = parse.quote_plus(classId)\n        if class_obj is None:\n            raise Exception(\"Require a new definition for the class\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting putClass\")\n        path = f\"/{self.container}/classes/{classId}\"\n        res = self.connector.putData(self.endpoint + path,data=class_obj)\n        return res\n\n    def patchClass(self,classId:str=None,operation:list=None)->dict:\n        \"\"\"\n        Patch a class with the operation specified such as:\n        update = [{\n            \"op\": \"replace\",\n            \"path\": \"title\",\n            \"value\": \"newTitle\"\n        }]\n        Possible operation value : \"replace\", \"remove\", \"add\"\n        Arguments:\n            classId : REQUIRED : The class to be updated  ($id or meta:altId)\n            operation : REQUIRED : List of operation to realize on the class\n        \"\"\"\n        if classId is None:\n            raise Exception(\"Require a classId\")\n        if classId.startswith(\"https://\"):\n            from urllib import parse\n            classId = parse.quote_plus(classId)\n        if operation is None or type(operation) != list:\n            raise Exception(\"Require a list of operation for the class\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting patchClass\")\n        path = f\"/{self.container}/classes/{classId}\"\n        res = self.connector.patchData(self.endpoint + path,data=operation)\n        return res\n\n    def deleteClass(self,classId: str = None)->str:\n        \"\"\"\n        Delete a class based on the its ID.\n        Arguments:\n            classId : REQUIRED : The class to be deleted  ($id or meta:altId)\n        \"\"\"\n        if classId is None:\n            raise Exception(\"Require a classId\")\n        if classId.startswith(\"https://\"):\n            from urllib import parse\n            classId = parse.quote_plus(classId)\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting patchClass\")\n        path = f\"/{self.container}/classes/{classId}\"\n        res = self.connector.deleteData(self.endpoint + path)\n        return res\n\n    def getFieldGroups(self, format: str = \"xdm\", **kwargs) -> list:\n        \"\"\"\n        returns the fieldGroups of the account.\n        Arguments:\n            format : OPTIONAL : either \"xdm\" or \"xed\" format\n        kwargs:\n            debug : if set to True, will print result for errors\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getFieldGroups\")\n        path = f\"/{self.container}/fieldgroups/\"\n        start = kwargs.get(\"start\", 0)\n        params = {\"start\": start}\n        verbose = kwargs.get(\"debug\", False)\n        privateHeader = deepcopy(self.header)\n        privateHeader[\"Accept\"] = f\"application/vnd.adobe.{format}+json\"\n        res = self.connector.getData(\n            self.endpoint + path, headers=privateHeader, params=params, verbose=verbose\n        )\n        if kwargs.get(\"verbose\", False):\n            if \"results\" not in res.keys():\n                print(res)\n        data = res[\"results\"]\n        page = res.get(\"_page\",{})\n        nextPage = page.get('next',None)\n        while nextPage is not None:\n            params['start'] = nextPage\n            res = self.connector.getData(\n            self.endpoint + path, headers=privateHeader, params=params, verbose=verbose\n            )\n            data += res.get(\"results\")\n            page = res.get(\"_page\",{})\n            nextPage = page.get('next',None)\n        self.data.fieldGroups_id = {mix[\"title\"]: mix[\"$id\"] for mix in data}\n        self.data.fieldGroups_altId = {mix[\"title\"]: mix[\"meta:altId\"] for mix in data}\n        return data\n    \n    def getFieldGroupsGlobal(self,format: str = \"xdm\",output:str='raw', **kwargs)->list:\n        \"\"\"\n        returns the global fieldGroups of the account.\n        Arguments:\n            format : OPTIONAL : either \"xdm\" or \"xed\" format\n            output : OPTIONAL : either \"raw\" (default) or \"df\" for dataframe \n        kwargs:\n            debug : if set to True, will print result for errors\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getFieldGroups\")\n        path = f\"/global/fieldgroups/\"\n        start = kwargs.get(\"start\", 0)\n        params = {\"start\": start}\n        verbose = kwargs.get(\"debug\", False)\n        privateHeader = deepcopy(self.header)\n        privateHeader[\"Accept\"] = f\"application/vnd.adobe.{format}+json\"\n        res = self.connector.getData(\n            self.endpoint + path, headers=privateHeader, params=params, verbose=verbose\n        )\n        if kwargs.get(\"verbose\", False):\n            if \"results\" not in res.keys():\n                print(res)\n        data = res[\"results\"]\n        page = res.get(\"_page\",{})\n        nextPage = page.get('next',None)\n        while nextPage is not None:\n            params['start'] = nextPage\n            res = self.connector.getData(\n            self.endpoint + path, headers=privateHeader, params=params, verbose=verbose\n            )\n            data += res.get(\"results\")\n            page = res.get(\"_page\",{})\n            nextPage = page.get('next',None)\n        self.data.fieldGroups_id = {mix[\"title\"]: mix[\"$id\"] for mix in data}\n        self.data.fieldGroups_altId = {mix[\"title\"]: mix[\"meta:altId\"] for mix in data}\n        if output == 'df':\n            df = pd.DataFrame(data)\n            return df\n        return data\n\n    # def getMixin(\n    #     self,\n    #     mixinId: str = None,\n    #     version: int = 1,\n    #     full: bool = True,\n    #     save: bool = False,\n    # ):\n    #     \"\"\"\n    #     Returns a specific mixin / field group.\n    #     Arguments:\n    #         mixinId : REQUIRED : meta:altId or $id\n    #         version : OPTIONAL : version of the mixin\n    #         full : OPTIONAL : True (default) will return the full schema.False just the relationships.\n    #     \"\"\"\n    #     if mixinId.startswith(\"https://\"):\n    #         from urllib import parse\n\n    #         mixinId = parse.quote_plus(mixinId)\n    #     if self.loggingEnabled:\n    #         self.logger.debug(f\"Starting getMixin\")\n    #     privateHeader = deepcopy(self.header)\n    #     privateHeader[\"Accept-Encoding\"] = \"identity\"\n    #     if full:\n    #         accept_full = \"-full\"\n    #     else:\n    #         accept_full = \"\"\n    #     update_accept = (\n    #         f\"application/vnd.adobe.xed{accept_full}+json; version={version}\"\n    #     )\n    #     privateHeader.update({\"Accept\": update_accept})\n    #     path = f\"/{self.container}/mixins/{mixinId}\"\n    #     res = self.connector.getData(self.endpoint + path, headers=privateHeader)\n    #     if save:\n    #         aepp.saveFile(\n    #             module=\"schema\", file=res, filename=res[\"title\"], type_file=\"json\"\n    #         )\n    #     if \"title\" in res.keys():\n    #         self.data.mixins[res[\"title\"]] = res\n    #     return res\n\n    def getFieldGroup(\n        self,\n        fieldGroupId: str = None,\n        version: int = 1,\n        full: bool = True,\n        desc: bool = False,\n        type: str = 'xed',\n        flat: bool = False,\n        deprecated: bool = False,\n        save: bool = False,\n    ):\n        \"\"\"\n        Returns a specific mixin / field group.\n        Arguments:\n            fieldGroupId : REQUIRED : meta:altId or $id\n            version : OPTIONAL : version of the mixin\n            full : OPTIONAL : True (default) will return the full schema.False just the relationships\n            desc : OPTIONAL : Add descriptor of the field group\n            type : OPTIONAL : Either \"xed\" (default) or \"xdm\"\n            flat : OPTIONAL : if the fieldGroup is flat (false by default)\n            deprecated : OPTIONAL : Display the deprecated fields from that schema\n            save : Save the fieldGroup to a JSON file\n        \"\"\"\n        if fieldGroupId.startswith(\"https://\"):\n            from urllib import parse\n            fieldGroupId = parse.quote_plus(fieldGroupId)\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getFieldGroup\")\n        privateHeader = deepcopy(self.header)\n        privateHeader[\"Accept-Encoding\"] = \"identity\"\n        accept_full, accept_desc,accept_flat,accept_deprec= \"\",\"\",\"\",\"\"\n        if full:\n            accept_full = \"-full\"\n        if desc:\n            accept_desc = \"-desc\"\n        if flat:\n            accept_flat = \"-flat\"\n        if deprecated:\n            accept_deprec = \"-deprecated\"\n        update_accept = (\n            f\"application/vnd.adobe.{type}{accept_full}{accept_desc}{accept_flat}{accept_deprec}+json; version={version}\"\n        )\n        privateHeader.update({\"Accept\": update_accept})\n        path = f\"/{self.container}/fieldgroups/{fieldGroupId}\"\n        res = self.connector.getData(self.endpoint + path, headers=privateHeader)\n        if save:\n            aepp.saveFile(\n                module=\"schema\", file=res, filename=res[\"title\"], type_file=\"json\"\n            )\n        if \"title\" in res.keys():\n            self.data.fieldGroups[res[\"title\"]] = res\n        return res\n\n    def copyMixin(\n        self, mixin: dict = None, tenantId: str = None, title: str = None\n    ) -> dict:\n        \"\"\"\n        Copy the dictionary returned by getMixin to the only required elements for copying it over.\n        Arguments:\n            mixin : REQUIRED : the object retrieved from the getMixin.\n            tenantId : OPTIONAL : if you want to change the tenantId (if None doesn't rename)\n            name : OPTIONAL : rename your mixin (if None, doesn't rename it)\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting copyMixin\")\n        if mixin is None:\n            raise ValueError(\"Require a mixin  object\")\n        mixin_obj = deepcopy(mixin)\n        oldTenant = mixin_obj[\"meta:tenantNamespace\"]\n        if \"definitions\" in mixin_obj.keys():\n            obj = {\n                \"type\": mixin_obj[\"type\"],\n                \"title\": title or mixin_obj[\"title\"],\n                \"description\": mixin_obj[\"description\"],\n                \"meta:intendedToExtend\": mixin_obj[\"meta:intendedToExtend\"],\n                \"definitions\": mixin_obj.get(\"definitions\"),\n                \"allOf\": mixin_obj.get(\n                    \"allOf\",\n                    [\n                        {\n                            \"$ref\": \"#/definitions/property\",\n                            \"type\": \"object\",\n                            \"meta:xdmType\": \"object\",\n                        }\n                    ],\n                ),\n            }\n        elif \"properties\" in mixin_obj.keys():\n            obj = {\n                \"type\": mixin_obj[\"type\"],\n                \"title\": title or mixin_obj[\"title\"],\n                \"description\": mixin_obj[\"description\"],\n                \"meta:intendedToExtend\": mixin_obj[\"meta:intendedToExtend\"],\n                \"definitions\": {\n                    \"property\": {\n                        \"properties\": mixin_obj[\"properties\"],\n                        \"type\": \"object\",\n                        \"['meta:xdmType']\": \"object\",\n                    }\n                },\n                \"allOf\": mixin_obj.get(\n                    \"allOf\",\n                    [\n                        {\n                            \"$ref\": \"#/definitions/property\",\n                            \"type\": \"object\",\n                            \"meta:xdmType\": \"object\",\n                        }\n                    ],\n                ),\n            }\n        if tenantId is not None:\n            if tenantId.startswith(\"_\") == False:\n                tenantId = f\"_{tenantId}\"\n            obj[\"definitions\"][\"property\"][\"properties\"][tenantId] = obj[\"definitions\"][\n                \"property\"\n            ][\"properties\"][oldTenant]\n            del obj[\"definitions\"][\"property\"][\"properties\"][oldTenant]\n        return obj\n\n    def copyFieldGroup(\n        self, fieldGroup: dict = None, tenantId: str = None, title: str = None\n    ) -> dict:\n        \"\"\"\n        Copy the dictionary returned by getMixin to the only required elements for copying it over.\n        Arguments:\n            fieldGroup : REQUIRED : the object retrieved from the getFieldGroup.\n            tenantId : OPTIONAL : if you want to change the tenantId (if None doesn't rename)\n            name : OPTIONAL : rename your mixin (if None, doesn't rename it)\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting copyFieldGroup\")\n        if fieldGroup is None:\n            raise ValueError(\"Require a mixin  object\")\n        mixin_obj = deepcopy(fieldGroup)\n        oldTenant = mixin_obj[\"meta:tenantNamespace\"]\n        if \"definitions\" in mixin_obj.keys():\n            obj = {\n                \"type\": mixin_obj[\"type\"],\n                \"title\": title or mixin_obj[\"title\"],\n                \"description\": mixin_obj[\"description\"],\n                \"meta:intendedToExtend\": mixin_obj[\"meta:intendedToExtend\"],\n                \"definitions\": mixin_obj.get(\"definitions\"),\n                \"allOf\": mixin_obj.get(\n                    \"allOf\",\n                    [\n                        {\n                            \"$ref\": \"#/definitions/property\",\n                            \"type\": \"object\",\n                            \"meta:xdmType\": \"object\",\n                        }\n                    ],\n                ),\n            }\n        elif \"properties\" in mixin_obj.keys():\n            obj = {\n                \"type\": mixin_obj[\"type\"],\n                \"title\": title or mixin_obj[\"title\"],\n                \"description\": mixin_obj[\"description\"],\n                \"meta:intendedToExtend\": mixin_obj[\"meta:intendedToExtend\"],\n                \"definitions\": {\n                    \"property\": {\n                        \"properties\": mixin_obj[\"properties\"],\n                        \"type\": \"object\",\n                        \"['meta:xdmType']\": \"object\",\n                    }\n                },\n                \"allOf\": mixin_obj.get(\n                    \"allOf\",\n                    [\n                        {\n                            \"$ref\": \"#/definitions/property\",\n                            \"type\": \"object\",\n                            \"meta:xdmType\": \"object\",\n                        }\n                    ],\n                ),\n            }\n        if tenantId is not None:\n            if tenantId.startswith(\"_\") == False:\n                tenantId = f\"_{tenantId}\"\n            if 'property' in obj[\"definitions\"].keys():\n                obj[\"definitions\"][\"property\"][\"properties\"][tenantId] = obj[\"definitions\"][\"property\"][\"properties\"][oldTenant]\n                del obj[\"definitions\"][\"property\"][\"properties\"][oldTenant]\n            elif 'customFields' in obj[\"definitions\"].keys():\n                obj[\"definitions\"][\"customFields\"][\"properties\"][tenantId] = obj[\"definitions\"][\"customFields\"][\"properties\"][oldTenant]\n                del obj[\"definitions\"][\"customFields\"][\"properties\"][oldTenant]\n        return obj\n\n    def createMixin(self, mixin_obj: dict = None) -> dict:\n        \"\"\"\n        Create a mixin based on the dictionary passed.\n        Arguments :\n            mixin_obj : REQUIRED : the object required for creating the mixin.\n            Should contain title, type, definitions\n        \"\"\"\n        if mixin_obj is None:\n            raise Exception(\"Require a mixin object\")\n        if (\n            \"title\" not in mixin_obj\n            or \"type\" not in mixin_obj\n            or \"definitions\" not in mixin_obj\n        ):\n            raise AttributeError(\n                \"Require to have at least title, type, definitions set in the object.\"\n            )\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createMixin\")\n        path = f\"/{self.container}/mixins/\"\n        res = self.connector.postData(\n            self.endpoint + path, data=mixin_obj)\n        return res\n\n    def createFieldGroup(self, fieldGroup_obj: dict = None) -> dict:\n        \"\"\"\n        Create a mixin based on the dictionary passed.\n        Arguments :\n            fieldGroup_obj : REQUIRED : the object required for creating the field group.\n            Should contain title, type, definitions\n        \"\"\"\n        if fieldGroup_obj is None:\n            raise Exception(\"Require a mixin object\")\n        if (\n            \"title\" not in fieldGroup_obj\n            or \"type\" not in fieldGroup_obj\n            or \"definitions\" not in fieldGroup_obj\n        ):\n            raise AttributeError(\n                \"Require to have at least title, type, definitions set in the object.\"\n            )\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createFieldGroup\")\n        path = f\"/{self.container}/fieldgroups/\"\n        res = self.connector.postData(\n            self.endpoint + path, data=fieldGroup_obj)\n        return res\n\n    def deleteMixin(self, mixinId: str = None):\n        \"\"\"\n        Arguments:\n            mixinId : meta:altId or $id\n        \"\"\"\n        if mixinId is None:\n            raise Exception(\"Require an ID\")\n        if mixinId.startswith(\"https://\"):\n            from urllib import parse\n\n            mixinId = parse.quote_plus(mixinId)\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteMixin\")\n        path = f\"/{self.container}/mixins/{mixinId}\"\n        res = self.connector.deleteData(self.endpoint + path)\n        return res\n\n    def deleteFieldGroup(self, fieldGroupId: str = None):\n        \"\"\"\n        Arguments:\n            fieldGroupId : meta:altId or $id\n        \"\"\"\n        if fieldGroupId is None:\n            raise Exception(\"Require an ID\")\n        if fieldGroupId.startswith(\"https://\"):\n            from urllib import parse\n\n            fieldGroupId = parse.quote_plus(fieldGroupId)\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteFieldGroup\")\n        path = f\"/{self.container}/fieldgroups/{fieldGroupId}\"\n        res = self.connector.deleteData(self.endpoint + path)\n        return res\n\n    def patchMixin(self, mixinId: str = None, changes: list = None):\n        \"\"\"\n        Update the mixin with the operation described in the changes.\n        Arguments:\n            mixinId : REQUIRED : meta:altId or $id\n            changes : REQUIRED : dictionary on what to update on that mixin.\n            Example:\n                [\n                    {\n                        \"op\": \"add\",\n                        \"path\": \"/allOf\",\n                        \"value\": {'$ref': 'https://ns.adobe.com/emeaconsulting/mixins/fb5b3cd49707d27367b93e07d1ac1f2f7b2ae8d051e65f8d',\n                    'type': 'object',\n                    'meta:xdmType': 'object'}\n                    }\n                ]\n        information : http://jsonpatch.com/\n        \"\"\"\n        if mixinId is None or changes is None:\n            raise Exception(\"Require an ID and changes\")\n        if mixinId.startswith(\"https://\"):\n            from urllib import parse\n\n            mixinId = parse.quote_plus(mixinId)\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting patchMixin\")\n        path = f\"/{self.container}/mixins/{mixinId}\"\n        if type(changes) == dict:\n            changes = list(changes)\n        res = self.connector.patchData(\n            self.endpoint + path, data=changes)\n        return res\n\n    def patchFieldGroup(self, fieldGroupId: str = None, changes: list = None):\n        \"\"\"\n        Update the mixin with the operation described in the changes.\n        Arguments:\n            fieldGroupId : REQUIRED : meta:altId or $id\n            changes : REQUIRED : dictionary on what to update on that mixin.\n            Example:\n                [\n                    {\n                        \"op\": \"add\",\n                        \"path\": \"/allOf\",\n                        \"value\": {'$ref': 'https://ns.adobe.com/emeaconsulting/mixins/fb5b3cd49707d27367b93e07d1ac1f2f7b2ae8d051e65f8d',\n                    'type': 'object',\n                    'meta:xdmType': 'object'}\n                    }\n                ]\n        information : http://jsonpatch.com/\n        \"\"\"\n        if fieldGroupId is None or changes is None:\n            raise Exception(\"Require an ID and changes\")\n        if fieldGroupId.startswith(\"https://\"):\n            from urllib import parse\n\n            fieldGroupId = parse.quote_plus(fieldGroupId)\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting patchFieldGroup\")\n        path = f\"/{self.container}/fieldgroups/{fieldGroupId}\"\n        if type(changes) == dict:\n            changes = list(changes)\n        res = self.connector.patchData(\n            self.endpoint + path, data=changes)\n        return res\n\n    def putMixin(self, mixinId: str = None, mixinObj: dict = None, **kwargs) -> dict:\n        \"\"\"\n        A PUT request essentially re-writes the schema, therefore the request body must include all fields required to create (POST) a schema.\n        This is especially useful when updating a lot of information in the schema at once.\n        Arguments:\n            mixinId : REQUIRED : $id or meta:altId\n            mixinObj : REQUIRED : dictionary of the new schema.\n            It requires a allOf list that contains all the attributes that are required for creating a schema.\n            #/Schemas/replace_schema\n            More information on : https://www.adobe.io/apis/experienceplatform/home/api-reference.html\n        \"\"\"\n        if mixinId is None:\n            raise Exception(\"Require an ID for the schema\")\n        if mixinId.startswith(\"https://\"):\n            from urllib import parse\n\n            mixinId = parse.quote_plus(mixinId)\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting putMixin\")\n        path = f\"/{self.container}/mixins/{mixinId}\"\n        res = self.connector.putData(\n            self.endpoint + path, data=mixinObj)\n        return res\n\n    def putFieldGroup(\n        self, fieldGroupId: str = None, fieldGroupObj: dict = None, **kwargs\n    ) -> dict:\n        \"\"\"\n        A PUT request essentially re-writes the schema, therefore the request body must include all fields required to create (POST) a schema.\n        This is especially useful when updating a lot of information in the schema at once.\n        Arguments:\n            fieldGroupId : REQUIRED : $id or meta:altId\n            fieldGroupObj : REQUIRED : dictionary of the new Field Group.\n            It requires a allOf list that contains all the attributes that are required for creating a schema.\n            #/Schemas/replace_schema\n            More information on : https://www.adobe.io/apis/experienceplatform/home/api-reference.html\n        \"\"\"\n        if fieldGroupId is None:\n            raise Exception(\"Require an ID for the schema\")\n        if fieldGroupId.startswith(\"https://\"):\n            from urllib import parse\n\n            fieldGroupId = parse.quote_plus(fieldGroupId)\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting putMixin\")\n        path = f\"/{self.container}/fieldgroups/{fieldGroupId}\"\n        res = self.connector.putData(\n            self.endpoint + path, data=fieldGroupObj)\n        return res\n\n    def getUnions(self, **kwargs):\n        \"\"\"\n        Get all of the unions that has been set for the tenant.\n        Returns a dictionary.\n\n        Possibility to add option using kwargs\n        \"\"\"\n        path = f\"/{self.container}/unions\"\n        params = {}\n        if len(kwargs) > 0:\n            for key in kwargs.key():\n                if key == \"limit\":\n                    if int(kwargs[\"limit\"]) > 500:\n                        kwargs[\"limit\"] = 500\n                params[key] = kwargs.get(key, \"\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getUnions\")\n        res = self.connector.getData(\n            self.endpoint + path, params=params)\n        data = res[\"results\"]  # issue when requesting directly results.\n        return data\n\n    def getUnion(self, union_id: str = None, version: int = 1):\n        \"\"\"\n        Get a specific union type. Returns a dictionnary\n        Arguments :\n            union_id : REQUIRED :  meta:altId or $id\n            version : OPTIONAL : version of the union schema required.\n        \"\"\"\n        if union_id is None:\n            raise Exception(\"Require an ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getUnion\")\n        if union_id.startswith(\"https://\"):\n            from urllib import parse\n\n            union_id = parse.quote_plus(union_id)\n        path = f\"/{self.container}/unions/{union_id}\"\n        privateHeader = deepcopy(self.header)\n        privateHeader.update(\n            {\"Accept\": \"application/vnd.adobe.xdm-full+json; version=\" + str(version)}\n        )\n        res = self.connector.getData(self.endpoint + path, headers=privateHeader)\n        return res\n\n    def getXDMprofileSchema(self):\n        \"\"\"\n        Returns a list of all schemas that are part of the XDM Individual Profile.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getXDMprofileSchema\")\n        path = \"/tenant/schemas?property=meta:immutableTags==union&property=meta:class==https://ns.adobe.com/xdm/context/profile\"\n        res = self.connector.getData(self.endpoint + path)\n        return res\n\n    def getDataTypes(self, **kwargs):\n        \"\"\"\n        Get the data types from a container.\n        Possible kwargs:\n            properties : str :limit the amount of properties return by comma separated list.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getDataTypes\")\n        path = f\"/{self.container}/datatypes/\"\n        params = {}\n        if kwargs.get(\"properties\", None) is not None:\n            params = {\"properties\": kwargs.get(\"properties\", \"title,$id\")}\n        privateHeader = deepcopy(self.header)\n        privateHeader.update({\"Accept\": \"application/vnd.adobe.xdm-id+json\"})\n        res = self.connector.getData(\n            self.endpoint + path, headers=privateHeader, params=params\n        )\n        data = res[\"results\"]\n        page = res.get(\"_page\",{})\n        nextPage = page.get('next',None)\n        while nextPage is not None:\n            res = self.connector.getData(\n            self.endpoint + path, headers=privateHeader, params=params\n            )\n            data += res.get(\"results\",[])\n            page = res.get(\"_page\",{})\n            nextPage = page.get('next',None)\n        return data\n\n    def getDataType(\n        self, dataTypeId: str = None, version: str = \"1\", save: bool = False\n    ):\n        \"\"\"\n        Retrieve a specific data type id\n        Argument:\n            dataTypeId : REQUIRED : The resource meta:altId or URL encoded $id URI.\n        \"\"\"\n        if dataTypeId is None:\n            raise Exception(\"Require a dataTypeId\")\n        if dataTypeId.startswith(\"https://\"):\n            from urllib import parse\n\n            dataTypeId = parse.quote_plus(dataTypeId)\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getDataType\")\n        privateHeader = deepcopy(self.header)\n        privateHeader.update(\n            {\"Accept\": \"application/vnd.adobe.xdm-full+json; version=\" + version}\n        )\n        path = f\"/{self.container}/datatypes/{dataTypeId}\"\n        res = self.connector.getData(self.endpoint + path, headers=privateHeader)\n        if save:\n            aepp.saveFile(\n                module=\"schema\", file=res, filename=res[\"title\"], type_file=\"json\"\n            )\n        return res\n\n    def createDataType(self, dataTypeObj: dict = None)->dict:\n        \"\"\"\n        Create Data Type based on the object passed.\n        \"\"\"\n        if dataTypeObj is None:\n            raise Exception(\"Require a dictionary to create the Data Type\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createDataTypes\")\n        path = f\"/{self.container}/datatypes/\"\n        res = self.connector.postData(\n            self.endpoint + path, data=dataTypeObj)\n        return res\n    \n    def patchDataType(self,dataTypeId:str=None,operations:list=None)->dict:\n        \"\"\"\n        Patch an existing data type with the operation provided.\n        Arguments:\n            dataTypeId : REQUIRED : The Data Type ID to be used\n            operations : REQUIRED : The list of operation to be applied on that Data Type.\n                    Example : '[\n                                {\n                                \"op\": \"replace\",\n                                \"path\": \"/loyaltyLevel/meta:enum\",\n                                \"value\": {\n                                    \"ultra-platinum\": \"Ultra Platinum\",\n                                    \"platinum\": \"Platinum\",\n                                    \"gold\": \"Gold\",\n                                    \"silver\": \"Silver\",\n                                    \"bronze\": \"Bronze\"\n                                }\n                                }\n                            ]'\n        \"\"\"\n        if dataTypeId is None:\n            raise Exception(\"Require a a data type ID\")\n        if operations is None:\n            raise Exception(\"Require a list of operation to patch\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting patchDataType\")\n        path = f\"/{self.container}/datatypes/{dataTypeId}\"\n        res = self.connector.patchData(\n            self.endpoint + path, data=operations)\n        return res\n\n    \n    def putDataType(self,dataTypeId:str=None,dataTypeObj:dict=None)->dict:\n        \"\"\"\n        Replace an existing data type definition with the new definition provided.\n        Arguments:\n            dataTypeId : REQUIRED : The Data Type ID to be replaced\n            dataTypeObj : REQUIRED : The new Data Type definition.\n        \"\"\"\n        if dataTypeId is None:\n            raise Exception(\"Require a a data type ID\")\n        if dataTypeObj is None:\n            raise Exception(\"Require a dictionary to replace the Data Type definition\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting putDataType\")\n        path = f\"/{self.container}/datatypes/{dataTypeId}\"\n        res = self.connector.putData(\n            self.endpoint + path, data=dataTypeObj)\n        return res\n\n    def getDescriptors(\n        self,\n        type_desc: str = None,\n        id_desc: bool = False,\n        link_desc: bool = False,\n        save: bool = False,\n        **kwargs,\n    ) -> list:\n        \"\"\"\n        Return a list of all descriptors contains in that tenant id.\n        By default return a v2 for pagination.\n        Arguments:\n            type_desc : OPTIONAL : if you want to filter for a specific type of descriptor. None default.\n                (possible value : \"xdm:descriptorIdentity\")\n            id_desc : OPTIONAL : if you want to return only the id.\n            link_desc : OPTIONAL : if you want to return only the paths.\n            save : OPTIONAL : Boolean that would save your descriptors in the schema folder. (default False)\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getDescriptors\")\n        path = f\"/{self.container}/descriptors/\"\n        params = {\"start\": kwargs.get(\"start\", 0)}\n        if type_desc is not None:\n            params[\"property\"] = f\"@type=={type_desc}\"\n        if id_desc:\n            update_id = \"-id\"\n        else:\n            update_id = \"\"\n        if link_desc:\n            update_link = \"-link\"\n        else:\n            update_link = \"\"\n        privateHeader = deepcopy(self.header)\n        privateHeader[\n            \"Accept\"\n        ] = f\"application/vnd.adobe.xdm-v2{update_link}{update_id}+json\"\n        res = self.connector.getData(\n            self.endpoint + path, params=params, headers=privateHeader\n        )\n        data = res[\"results\"]\n        page = res[\"_page\"]\n        while page[\"next\"] is not None:\n            data += self.getDescriptors(start=page[\"next\"])\n        if save:\n            aepp.saveFile(\n                module=\"schema\", file=data, filename=\"descriptors\", type_file=\"json\"\n            )\n        return data\n\n    def getDescriptor(self, descriptorId: str = None, save: bool = False) -> dict:\n        \"\"\"\n        Return a specific descriptor\n        Arguments:\n            descriptorId : REQUIRED : descriptor ID to return (@id).\n            save : OPTIONAL : Boolean that would save your descriptors in the schema folder. (default False)\n        \"\"\"\n        if descriptorId is None:\n            raise Exception(\"Require a descriptor id\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getDescriptor\")\n        path = f\"/{self.container}/descriptors/{descriptorId}\"\n        privateHeader = deepcopy(self.header)\n        privateHeader[\"Accept\"] = f\"application/vnd.adobe.xdm+json\"\n        res = self.connector.getData(self.endpoint + path, headers=privateHeader)\n        if save:\n            aepp.saveFile(\n                module=\"schema\",\n                file=res,\n                filename=f'{res[\"@id\"]}_descriptors',\n                type_file=\"json\",\n            )\n        return res\n\n    def createDescriptor(\n        self,\n        descriptorObj:dict = None,\n        desc_type: str = \"xdm:descriptorIdentity\",\n        sourceSchema: str = None,\n        sourceProperty: str = None,\n        namespace: str = None,\n        primary: bool = None,\n        **kwargs,\n    ) -> dict:\n        \"\"\"\n        Create a descriptor attached to a specific schema.\n        Arguments:\n            descriptorObj : REQUIRED : If you wish to pass the whole object.\n            desc_type : REQUIRED : the type of descriptor to create.(default Identity)\n            sourceSchema : REQUIRED : the schema attached to your identity ()\n            sourceProperty : REQUIRED : the path to the field\n            namespace : REQUIRED : the namespace used for the identity\n            primary : OPTIONAL : Boolean (True or False) to define if it is a primary identity or not (default None).\n        possible kwargs:\n            version : version of the creation (default 1)\n            xdm:property : type of property\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createDescriptor\")\n        path = f\"/tenant/descriptors\"\n        if descriptorObj:\n            res = self.connector.postData(\n            self.endpoint + path, data=descriptorObj)\n        else:\n            if sourceSchema is None or sourceProperty is None:\n                raise Exception(\"Missing required arguments.\")\n            obj = {\n                \"@type\": desc_type,\n                \"xdm:sourceSchema\": sourceSchema,\n                \"xdm:sourceVersion\": kwargs.get(\"version\", 1),\n                \"xdm:sourceProperty\": sourceProperty,\n            }\n            if namespace is not None:\n                obj[\"xdm:namespace\"] = namespace\n            if primary is not None:\n                obj[\"xdm:isPrimary\"] = primary\n            for key in kwargs:\n                if 'xdm:' in key:\n                    obj[key] = kwargs.get(key)\n            res = self.connector.postData(\n                self.endpoint + path, data=obj)\n        return res\n\n    def deleteDescriptor(self, descriptor_id: str = None) -> str:\n        \"\"\"\n        Delete a specific descriptor.\n        Arguments:\n            descriptor_id : REQUIRED : the descriptor id to delete\n        \"\"\"\n        if descriptor_id is None:\n            raise Exception(\"Require a descriptor id\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteDescriptor\")\n        path = f\"/{self.container}/descriptors/{descriptor_id}\"\n        privateHeader = deepcopy(self.header)\n        privateHeader[\"Accept\"] = f\"application/vnd.adobe.xdm+json\"\n        res = self.connector.deleteData(self.endpoint + path, headers=privateHeader)\n        return res\n\n    def putDescriptor(\n        self,\n        descriptorId: str = None,\n        descriptorObj:dict = None,\n        desc_type: str = \"xdm:descriptorIdentity\",\n        sourceSchema: str = None,\n        sourceProperty: str = None,\n        namespace: str = None,\n        xdmProperty: str = \"xdm:code\",\n        primary: bool = False,\n        **kwargs\n    ) -> dict:\n        \"\"\"\n        Replace the descriptor with the new definition. It updates the whole definition.\n        Arguments:\n            descriptorId : REQUIRED : the descriptor id to replace\n            descriptorObj : REQUIRED : The full descriptor object if you want to pass it directly.\n            desc_type : REQUIRED : the type of descriptor to create.(default Identity)\n            sourceSchema : REQUIRED : the schema attached to your identity ()\n            sourceProperty : REQUIRED : the path to the field\n            namespace : REQUIRED : the namespace used for the identity\n            xdmProperty : OPTIONAL : xdm code for the descriptor (default : xdm:code)\n            primary : OPTIONAL : Boolean to define if it is a primary identity or not (default False).\n        \"\"\"\n        if descriptorId is None:\n            raise Exception(\"Require a descriptor id\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting putDescriptor\")\n        path = f\"/{self.container}/descriptors/{descriptorId}\"\n        if sourceSchema is None or sourceProperty is None or namespace is None:\n            raise Exception(\"Missing required arguments.\")\n        if descriptorObj is not None and type(descriptorObj) == dict:\n            obj = descriptorObj\n        else:\n            obj = {\n            \"@type\": desc_type,\n            \"xdm:sourceSchema\": sourceSchema,\n            \"xdm:sourceVersion\": 1,\n            \"xdm:sourceProperty\": sourceProperty,\n            \"xdm:namespace\": namespace,\n            \"xdm:property\": xdmProperty,\n            \"xdm:isPrimary\": primary,\n            }\n            for key in kwargs:\n                if 'xdm:' in key:\n                    obj[key] = kwargs.get(key)\n        res = self.connector.putData(\n            self.endpoint + path, data=obj)\n        return res\n\n\n    def getAuditLogs(self, resourceId: str = None) -> list:\n        \"\"\"\n        Returns the list of the changes made to a ressource (schema, class, mixin).\n        Arguments:\n            resourceId : REQUIRED : The \"$id\" or \"meta:altId\" of the resource.\n        \"\"\"\n        if not resourceId:\n            raise ValueError(\"resourceId should be included as a parameter\")\n        if resourceId.startswith(\"https://\"):\n            from urllib import parse\n            resourceId = parse.quote_plus(resourceId)\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createDescriptor\")\n        path: str = f\"/rpc/auditlog/{resourceId}\"\n        res: list = self.connector.getData(self.endpoint + path)\n        return res\n    \n    def exportResource(self,resourceId:str=None,Accept:str=\"application/vnd.adobe.xed+json; version=1\")->dict:\n        \"\"\"\n        Return all the associated references required for importing the resource in a new sandbox or a new Org.\n        Argument:\n            resourceId : REQUIRED : The $id or meta:altId of the resource to export.\n            Accept : OPTIONAL : If you want to change the Accept header of the request.\n        \"\"\"\n        if resourceId is None:\n            raise ValueError(\"Require a resource ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting exportResource for resourceId : {resourceId}\")\n        if resourceId.startswith(\"https://\"):\n            from urllib import parse\n            resourceId = parse.quote_plus(resourceId)\n        privateHeader = deepcopy(self.header)\n        privateHeader['Accept'] = Accept\n        path = f\"/rpc/export/{resourceId}\"\n        res = self.connector.getData(self.endpoint +path,headers=privateHeader)\n        return res\n\n    def importResource(self,dataResource:dict = None)->dict:\n        \"\"\"\n        Import a resource based on the export method.\n        Arguments:\n            dataResource : REQUIRED : dictionary of the resource retrieved.\n        \"\"\"\n        if dataResource is None:\n            raise ValueError(\"a dictionary presenting the resource to be imported should be included as a parameter\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting importResource\")\n        path: str = f\"/rpc/export/\"\n        res: list = self.connector.postData(self.endpoint + path, data=dataResource)\n        return res\n\n    def extendFieldGroup(self,fieldGroupId:str=None,values:list=None,tenant:str='tenant')->dict:\n        \"\"\"\n        Patch a Field Group to extend its compatibility with ExperienceEvents, IndividualProfile and Record.\n        Arguments:\n            fieldGroupId : REQUIRED : meta:altId or $id of the field group.\n            values : OPTIONAL : If you want to pass the behavior you want to extend the field group to.\n                Examples: [\"https://ns.adobe.com/xdm/context/profile\",\n                      \"https://ns.adobe.com/xdm/context/experienceevent\",\n                    ]\n                by default profile and experienceEvent will be added to the FieldGroup.\n            tenant : OPTIONAL : default \"tenant\", possible value 'global'\n        \"\"\"\n        if fieldGroupId is None:\n            raise Exception(\"Require a field Group ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting extendFieldGroup\")\n        path = f\"/{tenant}/fieldgroups/{fieldGroupId}\"\n        if values is not None:\n            list_fgs = values\n        else:\n            list_fgs = [\"https://ns.adobe.com/xdm/context/profile\",\n                      \"https://ns.adobe.com/xdm/context/experienceevent\"]\n        operation = [\n           { \n            \"op\": \"replace\",\n            \"path\": \"/meta:intendedToExtend\",\n            \"value\": list_fgs\n            }\n        ]\n        res = self.connector.patchData(self.endpoint + path,data=operation)\n        return res\n    \n    def enableSchemaForRealTime(self,schemaId:str=None)->dict:\n        \"\"\"\n        Enable a schema for real time based on its ID.\n        Arguments:\n            schemaId : REQUIRED : The schema ID required to be updated\n        \"\"\"\n        if schemaId is None:\n            raise Exception(\"Require a schema ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting enableSchemaForRealTime\")\n        path = f\"/{self.container}/schemas/{schemaId}/\"\n        operation = [\n           { \n            \"op\": \"add\",\n            \"path\": \"/meta:immutableTags\",\n            \"value\": [\"union\"]\n            }\n        ]\n        res = self.connector.patchData(self.endpoint + path,data=operation)\n        return res\n    \n    def FieldGroupManager(self,fieldGroup:Union[dict,str,None],title:str=None,fg_class:list=[\"experienceevent\",\"profile\"]) -> 'FieldGroupManager':\n         \"\"\"\n         Generate a field group Manager instance using the information provided by the schema instance.\n         Arguments:\n             fieldGroup : OPTIONAL : the field group definition as dictionary OR the ID to access it OR nothing if you want to start from scratch\n             title : OPTIONAL : If you wish to change the tile of the field group.\n         \"\"\"\n         tenantId = self.getTenantId()\n         return FieldGroupManager(tenantId=tenantId,fieldGroup=fieldGroup,title=title,fg_class=fg_class,schemaAPI=self)\n    \n    def SchemaManager(self,schema:Union[dict,str],fieldGroups:list=None) -> 'FieldGroupManager':\n         \"\"\"\n         Generate a Schema Manager instance using the information provided by the schema instance.\n         Arguments:\n            schema : OPTIONAL : the schema definition as dictionary OR the ID to access it OR Nothing if you want to start from scratch\n            fieldGroups : OPTIONAL : If you wish to add a list of fieldgroups.\n            fgManager : OPTIONAL : If you wish to handle the different field group passed into a Field Group Manager instance and have additional methods available.\n         \"\"\"\n         return SchemaManager(schema=schema,fieldGroups=fieldGroups,schemaAPI=self)\n\n    def compareDFschemas(self,df1,df2,**kwargs)->dict:\n        \"\"\"\n        Compare 2 schema dataframe returned by the SchemaManager `to_dataframe` method.\n        Arguments:\n            df1 : REQUIRED : the first schema dataframe to compare\n            df2 : REQUIRED : the second schema dataframe to compare\n        possible keywords:\n            title1 : title of the schema used in the dataframe 1 (default df1)\n            title2 : title of the schema used in the dataframe 2 (default df2)\n        The title1 and title2 will be used instead of df1 or df2 in the results keys presented below.\n\n        Results: \n            Results are stored in a dictionary with these keys:\n            - df1 (or title1) : copy of the dataframe 1 passed\n            - df2 (or title2) : copy of the dataframe 2 passed\n            - fielgroups: dictionary containing\n                - aligned : boolean to define if the schema dataframes contain the same field groups\n                - df1_missingFieldGroups : tuple of field groups missing on df1 compare to df2\n                - df2_missingFieldGroups : tuple of field groups missing on df2 compare to df1\n            - paths: dictionary containing\n                - aligned : boolean to define if the schema dataframes contain the same fields.\n                - df1_missing : tuple of the paths missing in df1 compare to df2\n                - df2_missing : tuple of the paths missing in df2 compare to df1\n            - type_issues: list of all the paths that are not of the same type in both schemas.\n        \"\"\"\n        if type(df1) != pd.DataFrame or type(df2) != pd.DataFrame:\n            raise TypeError('Require dataframes to be passed')\n        if 'path' not in df1.columns or 'type' not in df1.columns or 'fieldGroup' not in df1.columns:\n            raise AttributeError('Your data frame 1 is incomplete, it does not contain one of the following columns : path, type, fieldGroup')\n        if 'path' not in df2.columns or 'type' not in df2.columns or 'fieldGroup' not in df2.columns:\n            raise AttributeError('Your data frame 2 is incomplete, it does not contain one of the following columns : path, type, fieldGroup')\n        name1 = kwargs.get('title1','df1')\n        name2 = kwargs.get('title2','df2')\n        dict_result = {f'{name1}':df1.copy(),f'{name2}':df2.copy()}\n        fieldGroups1 = tuple(sorted(df1.fieldGroup.unique()))\n        fieldGroups2 = tuple(sorted(df2.fieldGroup.unique()))\n        if fieldGroups1 == fieldGroups2:\n            dict_result['fieldGroups'] = {'aligned':True}\n        else:\n            dict_result['fieldGroups'] = {'aligned':False}\n            dict_result['fieldGroups'][f'{name1}_missingFieldGroups'] = tuple(set(fieldGroups2).difference(set(fieldGroups1)))\n            dict_result['fieldGroups'][f'{name2}_missingFieldGroups'] = tuple(set(fieldGroups1).difference(set(fieldGroups2)))\n        path_df1 = tuple(sorted(df1.path.unique()))\n        path_df2 = tuple(sorted(df2.path.unique()))\n        if path_df1 == path_df2:\n            dict_result['paths'] = {'aligned':True}\n        else:\n            dict_result['paths'] = {'aligned':False}\n            list_path_missing_from_df2 = list(set(path_df2).difference(set(path_df1)))\n            list_path_missing_from_df1 = tuple(set(path_df1).difference(set(path_df2)))\n            dict_result['paths'][f'{name1}_missing'] = df2[df2[\"path\"].isin(list_path_missing_from_df2)]\n            dict_result['paths'][f'{name2}_missing'] = df1[df1[\"path\"].isin(list_path_missing_from_df1)]\n        common_paths = tuple(set(path_df2).intersection(set(path_df1)))\n        dict_result['type_issues'] = [] \n        for path in common_paths:\n            if df1[df1['path'] == path]['type'].values[0] != df2[df2['path'] == path]['type'].values[0]:\n                dict_result['type_issues'].append(path)\n        return dict_result", "\n\n\nclass FieldGroupManager:\n    \"\"\"\n    Class that reads and generate custom field groups\n    \"\"\"\n\n    def __init__(self,\n                fieldGroup:Union[dict,str]=None,\n                title:str=None,\n                fg_class:list=[\"experienceevent\",\"profile\"],\n                schemaAPI:'Schema'=None,\n                config: Union[dict,ConnectObject] = aepp.config.config_object,\n                )->None:\n        \"\"\"\n        Instantiator for field group creation.\n        Arguments:\n            fieldGroup : OPTIONAL : the field group definition as dictionary OR the $id/altId to access it.\n                If you pass the $id or altId, you should pass the schemaAPI instance or have uploaded a configuration file.\n            title : OPTIONAL : If you want to name the field group.\n            fg_class : OPTIONAL : the class that will support this field group.\n                by default events and profile, possible value : \"record\"\n            schemaAPI : OPTIONAL : The instance of the Schema class. Provide a way to connect to the API.\n            config : OPTIONAL : The config object in case you want to override the configuration.\n        \"\"\"\n        self.EDITABLE = False\n        self.fieldGroup = {}\n        if schemaAPI is not None and type(schemaAPI) == Schema:\n            self.schemaAPI = schemaAPI\n        else:\n            self.schemaAPI = Schema(config=config)\n        self.tenantId = f\"_{self.schemaAPI.getTenantId()}\"\n        if fieldGroup is not None:\n            if type(fieldGroup) == dict:\n                if fieldGroup.get(\"meta:resourceType\",None) == \"mixins\":\n                    if fieldGroup.get('definitions',None) is not None:\n                        if 'mixins' in fieldGroup.get('$id'):\n                            self.fieldGroup = self.schemaAPI.getFieldGroup(fieldGroup['$id'],full=False)\n                            if '/datatypes/' in str(self.fieldGroup): ## if custom datatype used in Field Group \n                                self.fieldGroup = self.schemaAPI.getFieldGroup(fieldGroup['$id'],full=True)\n                            else:\n                                self.EDITABLE = True\n                        else:\n                            tmp_def = self.schemaAPI.getFieldGroup(fieldGroup['$id'],full=True) ## handling default mixins\n                            tmp_def['definitions'] = tmp_def['properties']\n                            self.fieldGroup = tmp_def\n                    else:\n                        self.fieldGroup = self.schemaAPI.getFieldGroup(fieldGroup['$id'],full=False)\n            elif type(fieldGroup) == str and (fieldGroup.startswith('https:') or fieldGroup.startswith(f'{self.tenantId}.')):\n                if self.schemaAPI is None:\n                    raise Exception(\"You try to retrieve the fieldGroup definition from the id, but no API has been passed in the schemaAPI parameter.\")\n                if 'mixins' in fieldGroup:\n                    self.fieldGroup = self.schemaAPI.getFieldGroup(fieldGroup,full=False)\n                    if '/datatypes/' in str(self.fieldGroup): ## if custom datatype used in Field Group \n                        self.fieldGroup = self.schemaAPI.getFieldGroup(fieldGroup['$id'],full=True)\n                    else:\n                        self.EDITABLE = True\n                else: ## handling default mixins\n                    tmp_def = self.schemaAPI.getFieldGroup(fieldGroup,full=True) ## handling default mixins\n                    tmp_def['definitions'] = tmp_def['properties']\n                    self.fieldGroup = tmp_def\n            else:\n                raise ValueError(\"the element pass is not a field group definition\")\n        else:\n            self.EDITABLE = True\n            self.fieldGroup = {\n                \"title\" : \"\",\n                \"meta:resourceType\":\"mixins\",\n                \"description\" : \"\",\n                \"type\": \"object\",\n                \"definitions\":{\n                    \"customFields\":{\n                        \"type\" : \"object\",\n                        \"properties\":{\n                            self.tenantId:{\n                                \"properties\":{},\n                                \"type\" : \"object\"\n                            },\n                        }\n                    },\n                    \"property\":{\n                        \"type\" : \"object\",\n                        \"properties\":{\n                            self.tenantId:{\n                                \"properties\":{},\n                                \"type\" : \"object\"\n                            },\n                        }\n                    },\n                },\n                'allOf':[{\n                    \"$ref\": \"#/definitions/customFields\",\n                    \"type\": \"object\"\n                },\n                {\n                    \"$ref\": \"#/definitions/property\",\n                    \"type\": \"object\"\n                }],\n                \"meta:intendedToExtend\":[],\n                \"meta:containerId\": \"tenant\",\n                \"meta:tenantNamespace\": self.tenantId,\n            }\n            if self.fieldGroup.get(\"meta:intendedToExtend\") == []:\n                for cls in fg_class:\n                    if 'experienceevent' in cls or \"https://ns.adobe.com/xdm/context/experienceevent\" ==cls:\n                        self.fieldGroup[\"meta:intendedToExtend\"].append(\"https://ns.adobe.com/xdm/context/experienceevent\")\n                    elif \"profile\" in cls or \"https://ns.adobe.com/xdm/context/profile\" == cls:\n                        self.fieldGroup[\"meta:intendedToExtend\"].append(\"https://ns.adobe.com/xdm/context/profile\")\n                    elif \"record\" in cls or \"https://ns.adobe.com/xdm/data/record\" == cls:\n                        self.fieldGroup[\"meta:intendedToExtend\"].append(\"https://ns.adobe.com/xdm/context/profile\")\n        if len(self.fieldGroup.get('allOf',[]))>1:\n            ### handling the custom field group based on existing ootb field groups\n            for element in self.fieldGroup.get('allOf'):\n                if element.get('$ref') != '#/definitions/customFields' and element.get('$ref') != '#/definitions/property':\n                    additionalDefinition = self.schemaAPI.getFieldGroup(element.get('$ref'),full=True)\n                    self.fieldGroup['definitions'] = self.__simpleDeepMerge__(self.fieldGroup['definitions'],additionalDefinition.get('properties'))\n        self.__setAttributes__(self.fieldGroup)\n        if title is not None:\n            self.fieldGroup['title'] = title\n            self.title = title\n        \n    \n    def __setAttributes__(self,fieldGroup:dict)->None:\n        uniqueId = fieldGroup.get('id',str(int(time.time()*100))[-7:])\n        self.title = self.fieldGroup.get('title',f'unknown:{uniqueId}')\n        if self.fieldGroup.get('$id',False):\n            self.id = self.fieldGroup.get('$id')\n        if self.fieldGroup.get('meta:altId',False):\n            self.altId = self.fieldGroup.get('meta:altId')\n    \n    def __str__(self)->str:\n        return json.dumps(self.fieldGroup,indent=2)\n    \n    def __repr__(self)->dict:\n        return json.dumps(self.fieldGroup,indent=2)\n    \n    def __simpleDeepMerge__(self,base:dict,append:dict)->dict:\n        \"\"\"\n        Loop through the keys of 2 dictionary and append the new found key of append to the base.\n        Arguments:\n            base : The base you want to extend\n            append : the new dictionary to append\n        \"\"\"\n        if type(append) == list:\n            append = append[0]\n        for key in append:\n            if type(base)==dict:\n                if key in base.keys():\n                    self.__simpleDeepMerge__(base[key],append[key])\n                else:\n                    base[key] = append[key]\n            elif type(base)==list:\n                base = base[0]\n                if type(base) == dict:\n                    if key in base.keys():\n                        self.__simpleDeepMerge__(base[key],append[key])\n                    else:\n                        base[key] = append[key]\n        return base\n    \n    def __accessorAlgo__(self,mydict:dict,path:list=None)->dict:\n        \"\"\"\n        recursive method to retrieve all the elements.\n        Arguments:\n            mydict : REQUIRED : The dictionary containing the elements to fetch (in \"properties\" key)\n            path : the path with dot notation.\n        \"\"\"\n        path = self.__cleanPath__(path)\n        pathSplit = path.split('.')\n        key = pathSplit[0]\n        if 'customFields' in mydict.keys():\n            level = self.__accessorAlgo__(mydict.get('customFields',{}).get('properties',{}),'.'.join(pathSplit))\n            if 'error' not in level.keys():\n                return level\n        if 'property' in mydict.keys() :\n            level = self.__accessorAlgo__(mydict.get('property',{}).get('properties',{}),'.'.join(pathSplit))\n            return level\n        level = mydict.get(key,None)\n        if level is not None:\n            if level[\"type\"] == \"object\":\n                levelProperties = mydict[key].get('properties',None)\n                if levelProperties is not None:\n                    level = self.__accessorAlgo__(levelProperties,'.'.join(pathSplit[1:]))\n                return level\n            elif level[\"type\"] == \"array\":\n                levelProperties = mydict[key]['items'].get('properties',None)\n                if levelProperties is not None:\n                    level = self.__accessorAlgo__(levelProperties,'.'.join(pathSplit[1:]))\n                return level\n            else:\n                if len(pathSplit) > 1: \n                    return {'error':f'cannot find the key \"{pathSplit[1]}\"'}\n                return level\n        else:\n            if key == \"\":\n                return mydict\n            return {'error':f'cannot find the key \"{key}\"'}\n\n    def __searchAlgo__(self,mydict:dict,string:str=None,partialMatch:bool=False,caseSensitive:bool=False,results:list=None,path:str=None,completePath:str=None)->list:\n        \"\"\"\n        recursive method to retrieve all the elements.\n        Arguments:\n            mydict : REQUIRED : The dictionary containing the elements to fetch (start with fieldGroup definition)\n            string : the string to look for with dot notation.\n            partialMatch : if you want to use partial match\n            caseSensitive : to see if we should lower case everything\n            results : the list of results to return\n            path : the path currently set\n            completePath : the complete path from the start.\n        \"\"\"\n        finalPath = None\n        if results is None:\n            results=[]\n        for key in mydict:\n            if caseSensitive == False:\n                keyComp = key.lower()\n                string = string.lower()\n            else:\n                keyComp = key\n                string = string\n            if partialMatch:\n                if string in keyComp:\n                    ### checking if element is an array without deeper object level\n                    if mydict[key].get('type') == 'array' and mydict[key]['items'].get('properties',None) is None:\n                        finalPath = path + f\".{key}[]\"\n                        if path is not None:\n                            finalPath = path + f\".{key}\"\n                        else:\n                            finalPath = f\"{key}\"\n                    else:\n                        if path is not None:\n                            finalPath = path + f\".{key}\"\n                        else:\n                            finalPath = f\"{key}\"\n                    value = deepcopy(mydict[key])\n                    value['path'] = finalPath\n                    value['queryPath'] = self.__cleanPath__(finalPath)\n                    if completePath is None:\n                        value['completePath'] = f\"/definitions/{key}\"\n                    else:\n                        value['completePath'] = completePath + \"/\" + key\n                    results.append({key:value})\n            else:\n                if caseSensitive == False:\n                    if keyComp == string:\n                        if path is not None:\n                            finalPath = path + f\".{key}\"\n                        else:\n                            finalPath = key\n                        value = deepcopy(mydict[key])\n                        value['path'] = finalPath\n                        value['queryPath'] = self.__cleanPath__(finalPath)\n                        if completePath is None:\n                            value['completePath'] = f\"/definitions/{key}\"\n                        else:\n                            value['completePath'] = completePath + \"/\" + key\n                        results.append({key:value})\n                else:\n                    if keyComp == string:\n                        if path is not None:\n                            finalPath = path + f\".{key}\"\n                        else:\n                            finalPath = key\n                        value = deepcopy(mydict[key])\n                        value['path'] = finalPath\n                        value['queryPath'] = self.__cleanPath__(finalPath)\n                        if completePath is None:\n                            value['completePath'] = f\"/definitions/{key}\"\n                        else:\n                            value['completePath'] = completePath + \"/\" + key\n                        results.append({key:value})\n            ## loop through keys\n            if mydict[key].get(\"type\") == \"object\" or 'properties' in mydict[key].keys():\n                levelProperties = mydict[key].get('properties',{})\n                if levelProperties != dict():\n                    if completePath is None:\n                        tmp_completePath = f\"/definitions/{key}\"\n                    else:\n                        tmp_completePath = f\"{completePath}/{key}\"\n                    tmp_completePath += f\"/properties\"\n                    if path is None:\n                        if key != \"property\" and key != \"customFields\" :\n                            tmp_path = key\n                        else:\n                            tmp_path = None\n                    else:\n                        tmp_path = f\"{path}.{key}\"\n                    results = self.__searchAlgo__(levelProperties,string,partialMatch,caseSensitive,results,tmp_path,tmp_completePath)\n            elif mydict[key].get(\"type\") == \"array\":\n                levelProperties = mydict[key]['items'].get('properties',{})\n                if levelProperties != dict():\n                    if completePath is None:\n                        tmp_completePath = f\"/definitions/{key}\"\n                    else:\n                        tmp_completePath = f\"{completePath}/{key}\"\n                    tmp_completePath += f\"/items/properties\"\n                    if levelProperties is not None:\n                        if path is None:\n                            if key != \"property\" and key != \"customFields\":\n                                tmp_path = key\n                            else:\n                                tmp_path = None\n                        else:\n                            tmp_path = f\"{path}.{key}[]{{}}\"\n                        results = self.__searchAlgo__(levelProperties,string,partialMatch,caseSensitive,results,tmp_path,tmp_completePath)\n        return results\n\n    def __searchAttrAlgo__(self,mydict:dict,key:str=None,value:str=None,regex:bool=False, originalField:str=None, results:list=None)->list:\n        \"\"\"\n        recursive method to retrieve all the elements.\n        Arguments:\n            mydict : REQUIRED : The dictionary containing the elements to fetch (start with fieldGroup definition)\n            key : key of the attribute\n            value : the value of that key to look for.\n            regex : if the regex match should be used.\n            originalField : the key used to dig deeper.\n            results : the list of results to return\n        \"\"\"\n        if results is None:\n            results=[]\n        for k in mydict:\n            if key == k:\n                if regex:\n                    checkValue = deepcopy(mydict[k])\n                    if type(checkValue) == list or type(checkValue) == dict:\n                        checkValue = json.dumps(checkValue)\n                    if re.match(value,checkValue):\n                        if originalField is not None and originalField != 'property' and originalField != 'properties' and originalField != 'items':\n                            results.append(originalField)\n                else:\n                    if mydict[k] == value:\n                        if originalField is not None and originalField != 'property' and originalField != 'properties' and originalField != 'items':\n                            results.append(originalField)\n            ## recursive action for objects and array\n            if type(mydict[k]) == dict:\n                if k == \"properties\" or k == 'items':\n                    self.__searchAttrAlgo__(mydict[k],key,value,regex,originalField,results)\n                else:\n                    self.__searchAttrAlgo__(mydict[k],key,value,regex,k,results)\n        return results\n    \n    def __transformationDict__(self,mydict:dict=None,typed:bool=False,dictionary:dict=None)->dict:\n        \"\"\"\n        Transform the current XDM schema to a dictionary.\n        \"\"\"\n        if dictionary is None:\n            dictionary = {}\n        else:\n            dictionary = dictionary\n        for key in mydict:\n            if type(mydict[key]) == dict:\n                if mydict[key].get('type') == 'object' or 'properties' in mydict[key].keys():\n                    properties = mydict[key].get('properties',None)\n                    if properties is not None:\n                        if key != \"property\" and key != \"customFields\":\n                            if key not in dictionary.keys():\n                                dictionary[key] = {}\n                            self.__transformationDict__(mydict[key]['properties'],typed,dictionary=dictionary[key])\n                        else:\n                            self.__transformationDict__(mydict[key]['properties'],typed,dictionary=dictionary)\n                elif mydict[key].get('type') == 'array':\n                    levelProperties = mydict[key]['items'].get('properties',None)\n                    if levelProperties is not None:\n                        dictionary[key] = [{}]\n                        self.__transformationDict__(levelProperties,typed,dictionary[key][0])\n                    else:\n                        if typed:\n                            dictionary[key] = [mydict[key]['items'].get('type','object')]\n                        else:\n                            dictionary[key] = []\n                else:\n                    if typed:\n                        dictionary[key] = mydict[key].get('type','object')\n                    else:\n                        dictionary[key] = \"\"\n        return dictionary \n\n    def __transformationDF__(self,mydict:dict=None,dictionary:dict=None,path:str=None,queryPath:bool=False,description:bool=False,xdmType:bool=False)->dict:\n        \"\"\"\n        Transform the current XDM schema to a dictionary.\n        Arguments:\n            mydict : the fieldgroup\n            dictionary : the dictionary that gather the paths\n            path : path that is currently being developed\n            queryPath: boolean to tell if we want to add the query path\n            description : boolean to tell if you want to retrieve the description\n            xdmType : boolean to know if you want to retrieve the xdm Type\n        \"\"\"\n        if dictionary is None:\n            dictionary = {'path':[],'type':[]}\n            if queryPath:\n                dictionary['querypath'] = []\n            if description:\n                dictionary['description'] = []\n        else:\n            dictionary = dictionary\n        for key in mydict:\n            if type(mydict[key]) == dict:\n                if mydict[key].get('type') == 'object' or 'properties' in mydict[key].keys():\n                    if path is None:\n                        if key != \"property\" and key != \"customFields\":\n                            tmp_path = key\n                        else:\n                            tmp_path = None\n                    else:\n                        tmp_path = f\"{path}.{key}\"\n                    if tmp_path is not None:\n                        dictionary[\"path\"].append(tmp_path)\n                        dictionary[\"type\"].append(f\"{mydict[key].get('type')}\")\n                        if queryPath:\n                            dictionary[\"querypath\"].append(self.__cleanPath__(tmp_path))\n                        if description:\n                            dictionary[\"description\"].append(f\"{mydict[key].get('description','')}\")\n                    properties = mydict[key].get('properties',None)\n                    if properties is not None:\n                        self.__transformationDF__(properties,dictionary,tmp_path,queryPath,description)\n                elif mydict[key].get('type') == 'array':\n                    levelProperties = mydict[key]['items'].get('properties',None)\n                    if levelProperties is not None:\n                        if path is None:\n                            tmp_path = key\n                        else :\n                            tmp_path = f\"{path}.{key}[]{{}}\"\n                        dictionary[\"path\"].append(tmp_path)\n                        dictionary[\"type\"].append(f\"[{mydict[key]['items'].get('type')}]\")\n                        if queryPath and tmp_path is not None:\n                            dictionary[\"querypath\"].append(self.__cleanPath__(tmp_path))\n                        if description and tmp_path is not None:\n                            dictionary[\"description\"].append(mydict[key]['items'].get('description',''))\n                        self.__transformationDF__(levelProperties,dictionary,tmp_path,queryPath,description)\n                    else:\n                        finalpath = f\"{path}.{key}\"\n                        dictionary[\"path\"].append(finalpath)\n                        dictionary[\"type\"].append(f\"[{mydict[key]['items'].get('type')}]\")\n                        if queryPath and finalpath is not None:\n                            dictionary[\"querypath\"].append(self.__cleanPath__(finalpath))\n                        if description and finalpath is not None:\n                            dictionary[\"description\"].append(mydict[key]['items'].get('description',''))\n                else:\n                    if path is not None:\n                        finalpath = f\"{path}.{key}\"\n                    else:\n                        finalpath = f\"{key}\"\n                    dictionary[\"path\"].append(finalpath)\n                    dictionary[\"type\"].append(mydict[key].get('type','object'))\n                    if queryPath and finalpath is not None:\n                        dictionary[\"querypath\"].append(self.__cleanPath__(finalpath))\n                    if description and finalpath is not None:\n                        dictionary[\"description\"].append(mydict[key].get('description',''))\n\n        return dictionary\n    \n    def __setField__(self,completePathList:list=None,fieldGroup:dict=None,newField:str=None,obj:dict=None)->dict:\n        \"\"\"\n        Create a field with the attribute provided\n        Arguments:\n            completePathList : list of path to use for creation of the field.\n            fieldGroup : the self.fieldgroup attribute\n            newField : name of the new field to create\n            obj : the object associated with the new field\n        \"\"\"\n        foundFlag = False ## Flag to set if the operation has been realized or not\n        lastField = completePathList[-1]\n        fieldGroup = deepcopy(fieldGroup)\n        for key in fieldGroup:\n            level = fieldGroup.get(key,None)\n            if type(level) == dict and key in completePathList:\n                if 'properties' in level.keys():\n                    if key != lastField:\n                        res,foundFlag = self.__setField__(completePathList,fieldGroup[key]['properties'],newField,obj)\n                        fieldGroup[key]['properties'] = res\n                    else:\n                        fieldGroup[key]['properties'][newField] = obj\n                        foundFlag = True\n                        return fieldGroup,foundFlag\n                elif 'items' in level.keys():\n                    if 'properties' in  fieldGroup[key].get('items',{}).keys():\n                        if key != lastField:\n                            res, foundFlag = self.__setField__(completePathList,fieldGroup[key]['items']['properties'],newField,obj)\n                            fieldGroup[key]['items']['properties'] = res\n                        else:\n                            fieldGroup[key]['items']['properties'][newField] = obj\n                            foundFlag = True\n                            return fieldGroup,foundFlag\n        return fieldGroup,foundFlag\n    \n    def __removeKey__(self,completePathList:list=None,fieldGroup:dict=None)->dict:\n        \"\"\"\n        Remove the key and all element based on the path provided.\n        Arugments:\n            completePathList : list of path to use for identifying the key to remove\n            fieldGroup : the self.fieldgroup attribute\n        \"\"\"\n        lastField = deepcopy(completePathList).pop()\n        success = False\n        for key in fieldGroup:\n            level = fieldGroup.get(key,None)\n            if type(level) == dict and key in completePathList:\n                if 'properties' in level.keys():\n                    if lastField in level['properties'].keys():\n                        level['properties'].pop(lastField)\n                        success = True\n                        return success\n                    else:\n                        sucess = self.__removeKey__(completePathList,fieldGroup[key]['properties'])\n                        return sucess\n                elif 'items' in level.keys():\n                    if 'properties' in level.get('items',{}).keys():\n                        if lastField in level.get('items',{}).get('properties'):\n                            level['items']['properties'].pop(lastField)\n                            success = True\n                            return success\n                        else:\n                            success = self.__removeKey__(completePathList,fieldGroup[key]['items']['properties'])\n                            return success\n        return success \n\n    def __transformFieldType__(self,dataType:str=None)->dict:\n        \"\"\"\n        return the object with the type and possible meta attribute.\n        \"\"\"\n        obj = {}\n        if dataType == 'double':\n            obj['type'] = \"number\"\n        elif dataType == 'long':\n            obj['type'] = \"integer\"\n            obj['maximum'] = 9007199254740991\n            obj['minimum'] = -9007199254740991\n        elif dataType == \"short\":\n            obj['type'] = \"integer\"\n            obj['maximum'] = 32768\n            obj['minimum'] = -32768\n        elif dataType == \"date\":\n            obj['type'] = \"string\"\n            obj['format'] = \"date\"\n        elif dataType == \"DateTime\":\n            obj['type'] = \"string\"\n            obj['format'] = \"date-time\"\n        elif dataType == \"byte\":\n            obj['type'] = \"integer\"\n            obj['maximum'] = 128\n            obj['minimum'] = -128\n        else:\n            obj['type'] = dataType\n        return obj\n\n    def __cleanPath__(self,string:str=None)->str:\n        \"\"\"\n        An abstraction to clean the path string and remove the following characters : [,],{,}\n        Arguments:\n            string : REQUIRED : a string \n        \"\"\"\n        return string.replace('[','').replace(']','').replace(\"{\",'').replace('}','')\n    \n    def setTitle(self,name:str=None)->None:\n        \"\"\"\n        Set a name for the schema.\n        Arguments:\n            name : REQUIRED : a string to be used for the title of the FieldGroup\n        \"\"\"\n        self.fieldGroup['title'] = name\n        return None\n\n    def getField(self,path:str)->dict:\n        \"\"\"\n        Returns the field definition you want want to obtain.\n        Arguments:\n            path : REQUIRED : path with dot notation to which field you want to access\n        \"\"\"\n        definition = self.fieldGroup.get('definitions',self.fieldGroup.get('properties',{}))\n        data = self.__accessorAlgo__(definition,path)\n        return data\n\n    def searchField(self,string:str,partialMatch:bool=True,caseSensitive:bool=False)->list:\n        \"\"\"\n        Search for a field name based the string passed.\n        By default, partial match is enabled and allow case sensitivity option.\n        Arguments:\n            string : REQUIRED : the string to look for for one of the field\n            partialMatch : OPTIONAL : if you want to look for complete string or not. (default True)\n            caseSensitive : OPTIONAL : if you want to compare with case sensitivity or not. (default False)\n        \"\"\"\n        definition = self.fieldGroup.get('definitions',self.fieldGroup.get('properties',{}))\n        data = self.__searchAlgo__(definition,string,partialMatch,caseSensitive)\n        return data\n    \n    def searchAttribute(self,attr:dict=None,regex:bool=False,extendedResults:bool=False,joinType:str='outer', **kwargs)->list:\n        \"\"\"\n        Search for an attribute on the field of the field groups.\n        Returns either the list of fields that match this search or their full definitions.\n        Arguments:\n            attr : REQUIRED : a dictionary of key value pair(s).  Example : {\"type\" : \"string\"} \n                NOTE : If you wish to have the array type on top of the array results, use the key \"arrayType\". Example : {\"type\" : \"array\",\"arrayType\":\"string\"}\n                        This will automatically set the joinType to \"inner\". Use type for normal search. \n            regex : OPTIONAL : if you want your value of your key to be matched via regex.\n                Note that regex will turn every comparison value to string for a \"match\" comparison.\n            extendedResults : OPTIONAL : If you want to have the result to contain all details of these fields. (default False)\n            joinType : OPTIONAL : If you pass multiple key value pairs, how do you want to get the match.\n                outer : provide the fields if any of the key value pair is matched.\n                inner : provide the fields if all the key value pair matched.\n        \"\"\"\n        resultsDict = {f\"{key}\":[] for key in attr.keys()}\n        if 'arrayType' in attr.keys(): ## forcing inner join\n            joinType = 'inner'\n        definition = self.fieldGroup.get('definitions',self.fieldGroup.get('properties',{}))\n        for key in attr:\n            if key == \"arrayType\":\n                resultsDict[key] += self.__searchAttrAlgo__(definition,\"type\",attr[key],regex)\n            else:\n                resultsDict[key] += self.__searchAttrAlgo__(definition,key,attr[key],regex)\n        result_combi = []\n        if joinType == 'outer':\n            for key in resultsDict:\n                result_combi += resultsDict[key]\n            result_combi = set(result_combi)\n        elif joinType == 'inner':\n            result_combi = set()\n            for key in resultsDict:\n                resultsDict[key] = set(resultsDict[key])\n                if len(result_combi) == 0:\n                    result_combi = resultsDict[key]\n                else:\n                    result_combi = result_combi.intersection(resultsDict[key]) \n        if extendedResults:\n            result_extended = []\n            for field in result_combi:\n                result_extended += self.searchField(field,partialMatch=False,caseSensitive=True)\n            return result_extended\n        return list(result_combi)\n\n        \n    def addFieldOperation(self,path:str,dataType:str=None,title:str=None,objectComponents:dict=None,array:bool=False,enumValues:dict=None,enumType:bool=None,**kwargs)->None:\n        \"\"\"\n        Return the operation to be used on the field group with the Patch method (patchFieldGroup), based on the element passed in argument.\n        Arguments:\n            path : REQUIRED : path with dot notation where you want to create that new field.\n                In case of array of objects, use the \"[]{}\" notation\n            dataType : REQUIRED : the field type you want to create\n                A type can be any of the following: \"string\",\"boolean\",\"double\",\"long\",\"integer\",\"short\",\"byte\",\"date\",\"dateTime\",\"boolean\",\"object\",\"array\"\n                NOTE : \"array\" type is to be used for array of objects. If the type is string array, use the boolean \"array\" parameter.\n            title : OPTIONAL : if you want to have a custom title.\n            objectComponents: OPTIONAL : A dictionary with the name of the fields contain in the \"object\" or \"array of objects\" specify, with their typed.\n                Example : {'field1':'string','field2':'double'}\n            array : OPTIONAL : Boolean. If the element to create is an array. False by default.\n            enumValues : OPTIONAL : If your field is an enum, provid a dictionary of value and display name, such as : {'value':'display'}\n            enumType: OPTIONAL: If your field is an enum, indicates whether it is an enum (True) or suggested values (False)\n        possible kwargs:\n            defaultPath : Define which path to take by default for adding new field on tenant. Default \"property\", possible alternative : \"customFields\"\n        \"\"\"\n        if self.EDITABLE == False:\n            raise Exception(\"The Field Group is not Editable via Field Group Manager\")\n        typeTyped = [\"string\",\"boolean\",\"double\",\"long\",\"integer\",\"short\",\"byte\",\"date\",\"dateTime\",\"boolean\",\"object\",'array']\n        if dataType not in typeTyped:\n            raise TypeError('Expecting one of the following type : \"string\",\"boolean\",\"double\",\"long\",\"integer\",\"short\",\"byte\",\"date\",\"dateTime\",\"boolean\",\"object\"')\n        if dataType == 'object' and objectComponents is None:\n            raise AttributeError('Require a dictionary providing the object component')       \n        if title is None:\n            title = self.__cleanPath__(path.split('.').pop())\n        if title == 'items' or title == 'properties':\n            raise Exception('\"item\" and \"properties\" are 2 reserved keywords')\n        pathSplit = path.split('.')\n        if pathSplit[0] == '':\n            del pathSplit[0]\n        completePath = ['definitions',kwargs.get('defaultPath','property')]\n        for p in pathSplit:\n            if '[]{}' in p:\n                completePath.append(self.__cleanPath__(p))\n                completePath.append('items')\n                completePath.append('properties')\n            else:\n                completePath.append(self.__cleanPath__(p))\n                completePath.append('properties')\n        finalPath = '/' + '/'.join(completePath)\n        operation = [{\n            \"op\" : \"add\",\n            \"path\" : finalPath,\n            \"value\": {}\n        }]\n        if dataType != 'object' and dataType != \"array\":\n            if array: # array argument set to true\n                operation[0]['value']['type'] = 'array'\n                operation[0]['value']['items'] = self.__transformFieldType__(dataType)\n            else:\n                operation[0]['value'] = self.__transformFieldType__(dataType)\n        else: \n            if dataType == \"object\":\n                operation[0]['value']['type'] = self.__transformFieldType__(dataType)\n                operation[0]['value']['properties'] = {key:self.__transformFieldType__(value) for key, value in zip(objectComponents.keys(),objectComponents.values())}\n        operation[0]['value']['title'] = title\n        if enumValues is not None and type(enumValues) == dict:\n            if array == False:\n                operation[0]['value']['meta:enum'] = enumValues\n                if enumType:\n                    operation[0]['value']['enum'] = list(enumValues.keys())\n            else:\n                operation[0]['value']['items']['meta:enum'] = enumValues\n                if enumType:\n                    operation[0]['value']['items']['enum'] = list(enumValues.keys())\n        return operation\n\n    def addField(self,path:str,dataType:str=None,title:str=None,objectComponents:dict=None,array:bool=False,enumValues:dict=None,enumType:bool=None,**kwargs)->dict:\n        \"\"\"\n        Add the field to the existing fieldgroup definition.\n        Returns False when the field could not be inserted.\n        Arguments:\n            path : REQUIRED : path with dot notation where you want to create that new field. New field name should be included.\n            dataType : REQUIRED : the field type you want to create\n                A type can be any of the following: \"string\",\"boolean\",\"double\",\"long\",\"integer\",\"short\",\"byte\",\"date\",\"dateTime\",\"boolean\",\"object\",\"array\"\n                NOTE : \"array\" type is to be used for array of objects. If the type is string array, use the boolean \"array\" parameter.\n            title : OPTIONAL : if you want to have a custom title.\n            objectComponents: OPTIONAL : A dictionary with the name of the fields contain in the \"object\" or \"array of objects\" specify, with their typed.\n                Example : {'field1:'string','field2':'double'}\n            array : OPTIONAL : Boolean. If the element to create is an array. False by default.\n            enumValues : OPTIONAL : If your field is an enum, provid a dictionary of value and display name, such as : {'value':'display'}\n            enumType: OPTIONAL: If your field is an enum, indicates whether it is an enum (True) or suggested values (False)\n        possible kwargs:\n            defaultPath : Define which path to take by default for adding new field on tenant. Default \"property\", possible alternative : \"customFields\"\n        \"\"\"\n        if self.EDITABLE == False:\n            raise Exception(\"The Field Group is not Editable via Field Group Manager\")\n        if path is None:\n            raise ValueError(\"path must provided\")\n        typeTyped = [\"string\",\"boolean\",\"double\",\"long\",\"integer\",\"short\",\"byte\",\"date\",\"dateTime\",\"boolean\",\"object\",'array']\n        if dataType not in typeTyped:\n            raise TypeError('Expecting one of the following type : \"string\",\"boolean\",\"double\",\"long\",\"integer\",\"short\",\"byte\",\"date\",\"dateTime\",\"boolean\",\"object\",\"bytes\"')\n        if dataType == 'object' and objectComponents is None:\n            raise AttributeError('Require a dictionary providing the object component')\n        if title is None:\n            title = self.__cleanPath__(path.split('.').pop())\n        if title == 'items' or title == 'properties':\n            raise Exception('\"item\" and \"properties\" are 2 reserved keywords')\n        pathSplit = self.__cleanPath__(path).split('.')\n        if pathSplit[0] == '':\n            del pathSplit[0]\n        newField = pathSplit.pop()\n        obj = {}\n        if dataType == 'object':\n            obj = { 'type':'object', 'title':title,\n                'properties':{key:self.__transformFieldType__(objectComponents[key]) for key in objectComponents }\n            }\n        elif dataType == 'array':\n            obj = { 'type':'array', 'title':title,\n                \"items\":{\n                    'type':'object',\n                    'properties':{key:self.__transformFieldType__(objectComponents[key]) for key in objectComponents }\n                }\n            }\n        else:\n            obj = self.__transformFieldType__(dataType)\n            obj['title']= title\n            if array:\n                obj['type'] = \"array\"\n                obj['items'] = self.__transformFieldType__(dataType)\n        if enumValues is not None and type(enumValues) == dict:\n            if array == False:\n                obj['meta:enum'] = enumValues\n                if enumType:\n                    obj['enum'] = list(enumValues.keys())\n            else:\n                obj['items']['meta:enum'] = enumValues\n                if enumType:\n                    obj['items']['enum'] = list(enumValues.keys())\n        completePath:list[str] = [kwargs.get('defaultPath','property')] + pathSplit\n        customFields,foundFlag = self.__setField__(completePath, self.fieldGroup['definitions'],newField,obj)\n        if foundFlag == False:\n            return False\n        else:\n            self.fieldGroup['definitions'] = customFields\n            return self.fieldGroup\n        \n    def removeField(self,path:str)->dict:\n        \"\"\"\n        Remove a field from the definition based on the path provided.\n        NOTE: A path that has received data cannot be removed from a schema or field group.\n        Argument:\n            path : REQUIRED : The path to be removed from the definition.\n        \"\"\"\n        if self.EDITABLE == False:\n            raise Exception(\"The Field Group is not Editable via Field Group Manager\")\n        if path is None:\n            raise ValueError('Require a path to remove it')\n        pathSplit = self.__cleanPath__(path).split('.')\n        if pathSplit[0] == '':\n            del pathSplit[0]\n        success = False\n        ## Try customFields\n        completePath:list[str] = ['customFields'] + pathSplit\n        success = self.__removeKey__(completePath,self.fieldGroup['definitions'])\n        ## Try property\n        if success == False:\n            completePath:list[str] = ['property'] + pathSplit\n            success = self.__removeKey__(completePath,self.fieldGroup['definitions'])\n        return success\n\n    def to_dict(self,typed:bool=True,save:bool=False)->dict:\n        \"\"\"\n        Generate a dictionary representing the field group constitution\n        Arguments:\n            typed : OPTIONAL : If you want the type associated with the field group to be given.\n            save : OPTIONAL : If you wish to save the dictionary in a JSON file\n        \"\"\"\n        definition = self.fieldGroup.get('definitions',self.fieldGroup.get('properties',{}))\n        data = self.__transformationDict__(definition,typed)\n        if save:\n            filename = self.fieldGroup.get('title',f'unknown_fieldGroup_{str(int(time.time()))}')\n            aepp.saveFile(module='schema',file=data,filename=f\"{filename}.json\",type_file='json')\n        return data\n\n    def to_dataframe(self,save:bool=False,queryPath:bool=False,description:bool=False)->pd.DataFrame:\n        \"\"\"\n        Generate a dataframe with the row representing each possible path.\n        Arguments:\n            save : OPTIONAL : If you wish to save it with the title used by the field group.\n                save as csv with the title used. Not title, used \"unknown_fieldGroup_\" + timestamp.\n            queryPath : OPTIONAL : If you want to have the query path to be used.\n            description : OPTIONAL : If you want to have the description used\n        \"\"\"\n        definition = self.fieldGroup.get('definitions',self.fieldGroup.get('properties',{}))\n        data = self.__transformationDF__(definition,queryPath=queryPath,description=description)\n        df = pd.DataFrame(data)\n        if save:\n            title = self.fieldGroup.get('title',f'unknown_fieldGroup_{str(int(time.time()))}')\n            df.to_csv(f\"{title}.csv\",index=False)\n        return df\n    \n    def to_xdm(self)->dict:\n        \"\"\"\n        Return the fieldgroup definition as XDM\n        \"\"\"\n        return self.fieldGroup\n\n    def patchFieldGroup(self,operations:list=None)->dict:\n        \"\"\"\n        Patch the field group with the given operation.\n        Arguments:\n            operation : REQUIRED : The list of operation to realise\n        \"\"\"\n        if self.EDITABLE == False:\n            raise Exception(\"The Field Group is not Editable via Field Group Manager\")\n        if operations is None or type(operations) != list:\n            raise ValueError('Require a list of operations')\n        if self.schemaAPI is None:\n            Exception('Require a schema API connection. Pass the instance of a Schema class or import a configuration file.')\n        res = self.schemaAPI.patchFieldGroup(self.id,operations)\n        if 'status' in res.keys():\n            if res['status'] >= 400:\n                print(res['title'])\n                return res\n            else:\n                return res\n        self.fieldGroup = res\n        self.__setAttributes__(self.fieldGroup)\n        return res\n    \n    def updateFieldGroup(self)->dict:\n        \"\"\"\n        Use the PUT method to push the current field group representation to AEP via API request.\n        \"\"\"\n        if self.EDITABLE == False:\n            raise Exception(\"The Field Group is not Editable via Field Group Manager\")\n        if self.schemaAPI is None:\n            Exception('Require a schema API connection. Pass the instance of a Schema class or import a configuration file.')\n        res = self.schemaAPI.putFieldGroup(self.id,self.to_xdm())\n        if 'status' in res.keys():\n            if res['status'] >= 400:\n                print(res['title'])\n                return res\n            else:\n                return res\n        self.fieldGroup = res\n        self.__setAttributes__(self.fieldGroup)\n        return res\n    \n    def createFieldGroup(self)->dict:\n        \"\"\"\n        Use the POST method to create the field group in the organization.\n        \"\"\"\n        if self.schemaAPI is None:\n            Exception('Require a schema API connection. Pass the instance of a Schema class or import a configuration file.')\n        res = self.schemaAPI.createFieldGroup(self.to_xdm())\n        if 'status' in res.keys():\n            if res['status'] >= 400:\n                print(res['title'])\n                return res\n            else:\n                return res\n        self.fieldGroup = res\n        self.__setAttributes__(self.fieldGroup)\n        return res", "\n\nclass SchemaManager:\n    \"\"\"\n    A class to handle the schema management.\n    \"\"\"\n    DESCRIPTOR_TYPES =[\"xdm:descriptorIdentity\",\"xdm:alternateDisplayInfo\",\"xdm:descriptorOneToOne\",\"xdm:descriptorReferenceIdentity\",\"xdm:descriptorDeprecated\"]\n\n    def __init__(self,schema:Union[str,dict],\n                fieldGroups:list=None,\n                schemaAPI:'Schema'=None,\n                schemaClass:str=None,\n                config: Union[dict,ConnectObject] = aepp.config.config_object,\n                )->None:\n        \"\"\"\n        Instantiate the Schema Manager instance.\n        Arguments:\n            schemaId : OPTIONAL : Either a schemaId ($id or altId) or the schema dictionary itself.\n                If schemaId is passed, you need to provide the schemaAPI connection as well.\n            fieldGroups : OPTIONAL : Possible to specify a list of fieldGroup. \n                Either a list of fieldGroupIds (schemaAPI should be provided as well) or list of dictionary definition \n            schemaAPI : OPTIONAL : It is required if $id or altId are used. It is the instance of the Schema class.\n            schemaClass : OPTIONAL : If you want to set the class to be a specific class.\n                Default value is profile: \"https://ns.adobe.com/xdm/context/profile\", can be replaced with any class definition.\n                Possible default value: \"https://ns.adobe.com/xdm/context/experienceevent\", \"https://ns.adobe.com/xdm/context/segmentdefinition\"\n            config : OPTIONAL : The config object in case you want to override the configuration.\n        \"\"\"\n        self.fieldGroupIds=[]\n        self.fieldGroupsManagers = []\n        self.title = None\n        if schemaAPI is not None:\n            self.schemaAPI = schemaAPI\n        else:\n            self.schemaAPI = Schema(config=config)\n        if type(schema) == dict:\n            self.schema = schema\n            self.__setAttributes__(self.schema)\n            allOf = self.schema.get(\"allOf\",[])\n            if len(allOf) == 0:\n                Warning(\"You have passed a schema with -full attribute, you should pass one referencing the fieldGroups.\\n Using the meta:extends reference if possible\")\n                self.fieldGroupIds = [ref for ref in self.schema['meta:extends'] if ('/mixins/' in ref or '/experience/' in ref or '/context/' in ref) and ref != self.classId]\n                self.schema['allOf'] = [{\"$ref\":ref} for ref in self.schema['meta:extends'] if ('/mixins/' in ref or 'xdm/class' in ref or 'xdm/context/' in ref) and ref != self.classId]\n            else:\n                self.fieldGroupIds = [obj['$ref'] for obj in allOf if ('/mixins/' in obj['$ref'] or '/experience/' in obj['$ref'] or '/context/' in obj['$ref']) and obj['$ref'] != self.classId]\n            if self.schemaAPI is None:\n                Warning(\"No schema instance has been passed or config file imported.\\n Aborting the creation of field Group Manager\")\n            else:\n                for ref in self.fieldGroupIds:\n                    if '/mixins/' in ref:\n                        definition = self.schemaAPI.getFieldGroup(ref,full=False)\n                    else:\n                        definition = self.schemaAPI.getFieldGroup(ref,full=True)\n                        definition['definitions'] = definition['properties']\n                    self.fieldGroupsManagers.append(FieldGroupManager(fieldGroup=definition,schemaAPI=self.schemaAPI))\n        elif type(schema) == str:\n            if self.schemaAPI is None:\n                Warning(\"No schema instance has been passed or config file imported.\\n Aborting the retrieveal of the Schema Definition\")\n            else:\n                self.schema = self.schemaAPI.getSchema(schema,full=False)\n                self.__setAttributes__(self.schema)\n                allOf = self.schema.get(\"allOf\",[])\n                self.fieldGroupIds = [obj.get('$ref','') for obj in allOf if ('/mixins/' in obj.get('$ref','') or '/experience/' in obj.get('$ref','') or '/context/' in obj.get('$ref','')) and obj.get('$ref','') != self.classId]\n                if self.schemaAPI is None:\n                    Warning(\"fgManager is set to True but no schema instance has been passed.\\n Aborting the creation of field Group Manager\")\n                else:\n                    for ref in self.fieldGroupIds:\n                        if '/mixins/' in ref:\n                            definition = self.schemaAPI.getFieldGroup(ref,full=False)\n                        elif ref == '':\n                            pass\n                        else:\n                            ## if the fieldGroup is an OOTB one\n                            definition = self.schemaAPI.getFieldGroup(ref,full=True)\n                            definition['definitions'] = definition['properties']\n                        self.fieldGroupsManagers.append(FieldGroupManager(fieldGroup=definition,schemaAPI=self.schemaAPI))\n        elif schema is None:\n            self.schema = {\n                    \"title\": None,\n                    \"description\": \"power by aepp\",\n                    \"allOf\": [\n                            {\n                            \"$ref\": \"https://ns.adobe.com/xdm/context/profile\"\n                            }\n                        ]\n                    }\n        if schemaClass is not None:\n            self.schema['allOf'][0]['$ref'] = schemaClass\n        if fieldGroups is not None and type(fieldGroups) == list:\n            if fieldGroups[0] == str:\n                for fgId in fieldGroups:\n                    self.fieldGroupIds.append(fgId)\n                    if self.schemaAPI is None:\n                        Warning(\"fgManager is set to True but no schema instance has been passed.\\n Aborting the creation of field Group Manager\")\n                    else:\n                        definition = self.schemaAPI.getFieldGroup(ref)\n                        self.fieldGroupsManagers.append(FieldGroupManager(definition,schemaAPI=self.schemaAPI))\n            elif fieldGroups[0] == dict:\n                for fg in fieldGroups:\n                    self.fieldGroupIds.append(fg.get('$id'))\n                    self.fieldGroupsManagers.append(FieldGroupManager(fg,schemaAPI=self.schemaAPI))\n        self.fieldGroupTitles= tuple(fg.title for fg in self.fieldGroupsManagers)\n        self.fieldGroups = {fg.id:fg.title for fg in self.fieldGroupsManagers}\n    \n    def __setAttributes__(self,schemaDef:dict)->None:\n        \"\"\"\n        Set some basic attributes\n        \"\"\"\n        if schemaDef.get('title'):\n            self.title = schemaDef.get('title')\n        if schemaDef.get('$id'):\n            self.id = schemaDef.get('$id')\n        if schemaDef.get('meta:altId'):\n            self.altId = schemaDef.get('meta:altId')\n        if schemaDef.get('meta:class'):\n            self.classId = schemaDef.get('meta:class')\n\n    def __str__(self)->str:\n        return json.dumps(self.schema,indent=2)\n    \n    def __repr__(self)->str:\n        return json.dumps(self.schema,indent=2)\n\n    def __simpleDeepMerge__(self,base:dict,append:dict)->dict:\n        \"\"\"\n        Loop through the keys of 2 dictionary and append the new found key of append to the base.\n        Arguments:\n            base : The base you want to extend\n            append : the new dictionary to append\n        \"\"\"\n        if type(append) == list:\n            append = append[0]\n        for key in append:\n            if type(base)==dict:\n                if key in base.keys():\n                    self.__simpleDeepMerge__(base[key],append[key])\n                else:\n                    base[key] = append[key]\n            elif type(base)==list:\n                base = base[0]\n                if type(base) == dict:\n                    if key in base.keys():\n                        self.__simpleDeepMerge__(base[key],append[key])\n                    else:\n                        base[key] = append[key]\n        return base\n\n    def searchField(self,string:str=None,partialMatch:bool=True,caseSensitive:bool=True)->list:\n        \"\"\"\n        Search for a field in the different field group.\n        You would need to have set fgManager attribute during instantiation or use the convertFieldGroups\n        Arguments:\n            string : REQUIRED : The string you are looking for\n            partialMatch : OPTIONAL : If you want to use partial match (default True)\n            caseSensitive : OPTIONAL : If you want to remove the case sensitivity.\n        \"\"\"\n        myResults = []\n        for fgmanager in self.fieldGroupsManagers:\n            res = fgmanager.searchField(string,partialMatch,caseSensitive)\n            for r in res:\n                r['fieldGroup'] = fgmanager.title\n            myResults += res\n        return myResults\n    \n    def searchAttribute(self,attr:dict=None,regex:bool=False,extendedResults:bool=False,joinType:str='outer', **kwargs)->list:\n        \"\"\"\n        Search for an attribute and its value based on the keyword\n        Arguments:\n            attr : REQUIRED : a dictionary of key value pair(s).  Example : {\"type\" : \"string\"} \n                NOTE : If you wish to have the array type, use the key \"arrayType\". Example : {\"type\" : \"array\",\"arrayType\":\"string\"} \n            regex : OPTIONAL : if you want your value of your key to be matched via regex.\n                Note that regex will turn every comparison value to string for a \"match\" comparison.\n            extendedResults : OPTIONAL : If you want to have the result to contain all details of these fields. (default False)\n            joinType : OPTIONAL : If you pass multiple key value pairs, how do you want to get the match.\n                outer : provide the fields if any of the key value pair is matched. (default)\n                inner : provide the fields if all the key value pair matched.\n        \"\"\"\n        myResults = []\n        for fgmanager in self.fieldGroupsManagers:\n            res = fgmanager.searchAttribute(attr=attr,regex=regex,extendedResults=extendedResults,joinType=joinType)\n            if extendedResults:\n                for r in res:\n                    r['fieldGroup'] = fgmanager.title\n            myResults += res\n        return myResults\n    \n    def addFieldGroup(self,fieldGroup:Union[str,dict]=None)->Union[None,'FieldGroupManager']:\n        \"\"\"\n        Add a field groups to field Group object and the schema. \n        return the specific FieldGroup Manager instance.\n        Arguments:\n            fieldGroup : REQUIRED : The fieldGroup ID or the dictionary definition connecting to the API.\n                if a fieldGroup ID is provided, you should have added a schemaAPI previously.\n        \"\"\"\n        if type(fieldGroup) == dict:\n            if fieldGroup.get('$id') not in [fg for fg in self.fieldGroupIds]:\n                self.fieldGroupIds.append(fieldGroup['$id'])\n                self.schema['allOf'].append({'$ref':fieldGroup['$id'],\"type\": \"object\"})\n                \n        elif type(fieldGroup) == str:\n            if fieldGroup not in [fg for fg in self.fieldGroupIds]:\n                self.fieldGroupIds.append(fieldGroup)\n                self.schema['allOf'].append({'$ref':fieldGroup,\"type\": \"object\"})\n                if self.schemaAPI is None:\n                    raise AttributeError('Missing the schema API attribute. Please use the addSchemaAPI method to add it.')\n                else:\n                    fieldGroup = self.schemaAPI.getFieldGroup(fieldGroup)\n        fbManager = FieldGroupManager(fieldGroup=fieldGroup)\n        self.fieldGroupsManagers.append(fbManager)\n        self.fieldGroupTitles = tuple(fgm.title for fgm in self.fieldGroupsManagers)\n        self.fieldGroups = {fgm.id:fgm.title for fgm in self.fieldGroupsManagers}\n        return fbManager\n    \n    def getFieldGroupManager(self,fieldgroup:str=None)->'FieldGroupManager':\n        \"\"\"\n        Return a field group Manager of a specific name.\n        Only possible if fgManager was set to True during instanciation.\n        Argument:\n            fieldgroup : REQUIRED : The title or the $id of the field group to retrieve.\n        \"\"\"\n        if self.getFieldGroupManager is not None:\n            if \"ns.adobe.com\" in fieldgroup: ## id\n                return [fg for fg in self.fieldGroupsManagers if fg.id == fieldgroup][0]\n            else:\n                return [fg for fg in self.fieldGroupsManagers if fg.title == fieldgroup][0]\n        else:\n            raise Exception(\"The field group manager was not set to True during instanciation. No Field Group Manager to return\")\n\n    def setTitle(self,name:str=None)->None:\n        \"\"\"\n        Set a name for the schema.\n        Arguments:\n            name : REQUIRED : a string to be used for the title of the FieldGroup\n        \"\"\"\n        self.schema['title'] = name\n        self.title = name\n        return None\n\n    def to_dataframe(self,save:bool=False,queryPath: bool = False,description:bool = False)->pd.DataFrame:\n        \"\"\"\n        Extract the information from the Field Group to DataFrame. You need to have instanciated the Field Group manager.\n        Arguments:\n            save : OPTIONAL : If you wish to save it with the title used by the field group.\n                save as csv with the title used. Not title, used \"unknown_schema_\" + timestamp.\n            queryPath : OPTIONAL : If you want to have the query path to be used.\n        \"\"\"\n        df = pd.DataFrame({'path':[],'type':[],'fieldGroup':[]})\n        for fgmanager in self.fieldGroupsManagers:\n            tmp_df = fgmanager.to_dataframe(queryPath=queryPath,description=description)\n            tmp_df['fieldGroup'] = fgmanager.title\n            df = pd.concat([df,tmp_df],ignore_index=True)\n        if save:\n            title = self.schema.get('title',f'unknown_schema_{str(int(time.time()))}.csv')\n            df.to_csv(f\"{title}.csv\",index=False)\n        df = df[~df.duplicated('path')].reset_index(drop=True)\n        return df\n    \n    def to_dict(self)->dict:\n        \"\"\"\n        Return a dictionary of the whole schema. You need to have instanciated the Field Group Manager\n        \"\"\"\n        list_dict = [fbm.to_dict() for fbm in self.fieldGroupsManagers]\n        result = {}\n        for mydict in list_dict:\n            result = self.__simpleDeepMerge__(result,mydict)\n        return result\n\n    def createSchema(self)->dict:\n        \"\"\"\n        Send a createSchema request to AEP to create the schema.\n        It removes the \"$id\" if one was provided to avoid overriding existing ID.\n        \"\"\"\n        if self.schemaAPI is None:\n            raise Exception(\"Require a Schema instance to connect to the API\")\n        res = self.schemaAPI.createSchema(self.schema)\n        self.schema = res\n        self.__setAttributes__(self.schema)\n        return res\n\n    def updateSchema(self)->dict:\n        \"\"\"\n        Use the PUT method to replace the existing schema with the new definition.\n        \"\"\"\n        if self.schemaAPI is None:\n            raise Exception(\"Require a Schema instance to connect to the API\")\n        res = self.schemaAPI.putSchema(self.id,self.schema)\n        if 'status' in res.keys():\n            if res['status'] == 400:\n                print(res['title'])\n                return res\n            else:\n                return res\n        self.schema = res\n        self.__setAttributes__(self.schema)\n        return res\n    \n    def createDescriptorOperation(self,descType:str=None,\n                                completePath:str=None,\n                                identityNSCode:str=None,\n                                identityPrimary:bool=False,\n                                alternateTitle:str=None,\n                                alternateDescription:str=None,\n                                lookupSchema:str=None,\n                                targetCompletePath:str=None,\n                                )->dict:\n        \"\"\"\n        Create a descriptor object to be used in the createDescriptor.\n        You can see the type of descriptor available in the DESCRIPTOR_TYPES attribute and also on the official documentation:\n        https://experienceleague.adobe.com/docs/experience-platform/xdm/api/descriptors.html?lang=en#appendix\n        Arguments:\n            descType : REQUIRED : The type to be used.\n                it can only be one of the following value: \"xdm:descriptorIdentity\",\"xdm:alternateDisplayInfo\",\"xdm:descriptorOneToOne\",\"xdm:descriptorReferenceIdentity\",\"xdm:descriptorDeprecated\"\n            completePath : REQUIRED : the complete path of the field you want to attach a descriptor.\n                Example: '/definitions/customFields/properties/_tenant/properties/tenantObject/properties/field'\n            identityNSCode : OPTIONAL : if the descriptor is identity related, the namespace CODE  used.\n            identityPrimary : OPTIONAL : If the primary descriptor added is the primary identity.\n            alternateTitle : OPTIONAL : if the descriptor is alternateDisplay, the alternate title to be used.\n            alternateDescription : OPTIONAL if you wish to add a new description.\n            lookupSchema : OPTIONAL : The schema ID for the lookup if the descriptor is for lookup setup\n            targetCompletePath : OPTIONAL : if you have the complete path for the field in the target lookup schema.\n        \"\"\"\n        if descType not in self.DESCRIPTOR_TYPES:\n            raise Exception(f\"The value provided ({descType}) is not supported by this method\")\n        if completePath is None:\n            raise ValueError(\"Require a field complete path\")\n        if descType == \"xdm:descriptorIdentity\":\n            obj = {\n                \"@type\": descType,\n                \"xdm:sourceSchema\": self.id,\n                \"xdm:sourceVersion\": 1,\n                \"xdm:sourceProperty\": completePath,\n                \"xdm:namespace\": identityNSCode,\n                \"xdm:property\": \"xdm:code\",\n                \"xdm:isPrimary\": identityPrimary\n            }\n        elif descType == \"xdm:alternateDisplayInfo\":\n            if alternateTitle is None:\n                raise ValueError(\"Require an alternate title\")\n            obj = {\n                \"@type\": descType,\n                \"xdm:sourceSchema\": self.id,\n                \"xdm:sourceVersion\": 1,\n                \"xdm:sourceProperty\": completePath,\n                \"xdm:title\": {\n                    \"en_us\": alternateTitle\n                    }\n                }\n            if alternateDescription is not None:\n                obj[\"xdm:description\"] = {\n                    \"en_us\":alternateDescription\n                }\n        elif descType == \"xdm:descriptorOneToOne\":\n            obj = {\n                \"@type\": descType,\n                \"xdm:sourceSchema\":self.id,\n                \"xdm:sourceVersion\": 1,\n                \"xdm:sourceProperty\":completePath,\n                \"xdm:destinationSchema\":lookupSchema,\n                \"xdm:destinationVersion\": 1,\n            }\n            if targetCompletePath is not None:\n                obj[\"xdm:destinationProperty\"] = targetCompletePath\n        elif descType == \"xdm:descriptorReferenceIdentity\":\n            obj = {\n                \"@type\": descType,\n                \"xdm:sourceSchema\": self.id,\n                \"xdm:sourceVersion\": 1,\n                \"xdm:sourceProperty\": completePath,\n                \"xdm:identityNamespace\": identityNSCode\n                }\n        elif descType == \"xdm:descriptorDeprecated\":\n            obj = {\n                \"@type\": descType,\n                \"xdm:sourceSchema\": self.id,\n                \"xdm:sourceVersion\": 1,\n                \"xdm:sourceProperty\": completePath\n            }\n        return obj\n    \n    def createDescriptor(self,descriptor:dict=None)->dict:\n        \"\"\"\n        Create a descriptor attached to that class bsaed on the creatorDescriptor operation provided. \n        Arguments:\n            descriptor : REQUIRED : The operation to add a descriptor to the schema.\n        \"\"\"\n        if descriptor is None:\n            raise ValueError('Require an operation to be used')\n        res = self.schemaAPI.createDescriptor(descriptor)\n        return res\n\n    def compareObservableSchema(self,observableSchemaManager:'ObservableSchemaManager'=None)->pd.DataFrame:\n        \"\"\"\n        A method to compare the existing schema with the observable schema and find out the difference in them.\n        It output a dataframe with all of the path, the field group, the type (if provided) and the part availability (in that dataset)\n        Arguments:\n            observableSchemaManager : REQUIRED : the ObservableSchemaManager class instance.\n        \"\"\"\n        df_schema = self.to_dataframe()\n        df_obs = observableSchemaManager.to_dataframe()\n        df_merge = df_schema.merge(df_obs,left_on='path',right_on='path',how='left',indicator=True)\n        df_merge = df_merge.rename(columns={\"_merge\": \"availability\",'type_x':'type'})\n        df_merge = df_merge.drop(\"type_y\",axis=1)\n        df_merge['availability'] = df_merge['availability'].str.replace('left_only','schema_only')\n        df_merge['availability'] = df_merge['availability'].str.replace('both','schema_dataset')\n        return df_merge"]}
{"filename": "aepp/identity.py", "chunked_list": ["#  Copyright 2023 Adobe. All rights reserved.\n#  This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License. You may obtain a copy\n#  of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software distributed under\n#  the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n#  OF ANY KIND, either express or implied. See the License for the specific language\n#  governing permissions and limitations under the License.\n", "#  governing permissions and limitations under the License.\n\nimport aepp\nfrom aepp import connector\nfrom copy import deepcopy\nimport logging\nfrom typing import Union\nfrom .configs import ConnectObject\n\nclass Identity:\n    \"\"\"\n    Class to manage and retrieve Identity information.\n    #!acpdr/swagger-specs/id-service-api.yaml\n    This is based on the following API reference : https://www.adobe.io/apis/experienceplatform/home/api-reference.html\n    \"\"\"\n\n    ## logging capability\n    loggingEnabled = False\n    logger = None\n\n    def __init__(\n        self,\n        region: str = \"nld2\",\n        config: Union[dict,ConnectObject] = aepp.config.config_object,\n        header: dict = aepp.config.header,\n        loggingObject: dict = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Require a region.\n        By default, the NLD2 will be selected. (other choice : va7)\n        Additional kwargs will update the header.\n        more info : https://docs.adobe.com/content/help/en/experience-platform/identity/api/getting-started.html\n        Arguments:\n            region : REQUIRED : either nld2 or va7\n            loggingObject : OPTIONAL : logging object to log messages.\n            config : OPTIONAL : config object in the config module. (DO NOT MODIFY)\n            header : OPTIONAL : header object  in the config module. (DO NOT MODIFY)\n        \"\"\"\n        if loggingObject is not None and sorted(\n            [\"level\", \"stream\", \"format\", \"filename\", \"file\"]\n        ) == sorted(list(loggingObject.keys())):\n            self.loggingEnabled = True\n            self.logger = logging.getLogger(f\"{__name__}\")\n            self.logger.setLevel(loggingObject[\"level\"])\n            if type(loggingObject[\"format\"]) == str:\n                formatter = logging.Formatter(loggingObject[\"format\"])\n            elif type(loggingObject[\"format\"]) == logging.Formatter:\n                formatter = loggingObject[\"format\"]\n            if loggingObject[\"file\"]:\n                fileHandler = logging.FileHandler(loggingObject[\"filename\"])\n                fileHandler.setFormatter(formatter)\n                self.logger.addHandler(fileHandler)\n            if loggingObject[\"stream\"]:\n                streamHandler = logging.StreamHandler()\n                streamHandler.setFormatter(formatter)\n                self.logger.addHandler(streamHandler)\n        if type(config) == dict: ## Supporting either default setup or passing a ConnectObject\n            config = config\n        elif type(config) == ConnectObject:\n            header = config.getConfigHeader()\n            config = config.getConfigObject()\n        self.connector = connector.AdobeRequest(\n            config=config,\n            header=header,\n            loggingEnabled=self.loggingEnabled,\n            logger=self.logger,\n        )\n        self.header = self.connector.header\n        self.header.update(**kwargs)\n        if kwargs.get('sandbox',None) is not None: ## supporting sandbox setup on class instanciation\n            self.sandbox = kwargs.get('sandbox')\n            self.connector.config[\"sandbox\"] = kwargs.get('sandbox')\n            self.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n            self.connector.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n        else:\n            self.sandbox = self.connector.config[\"sandbox\"]\n        self.endpoint = (\n            f\"https://platform-{region}.adobe.io\" + aepp.config.endpoints[\"identity\"]\n        )\n\n    def getIdentity(\n        self, id_str: str = None, nsid: str = None, namespace: str = None\n    ) -> dict:\n        \"\"\"\n        Given the namespace and an ID in that namespace, returns XID string.\n        Arguments:\n            id_str : REQUIRED : Id in given namespace (ECID value)\n            nsid : REQUIRED : namespace id. (e.g. 411)\n            namespace : OPTIONAL : namespace code (e.g. adcloud)\n        \"\"\"\n        if id_str is None or (namespace is None and nsid is None):\n            raise Exception(\n                \"Expecting that id_str and (namespace or nsid) arguments to be filled.\"\n            )\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getIdentity\")\n        params = {\"id\": id_str}\n        if nsid is not None:\n            params[\"nsid\"] = nsid\n        if namespace is not None:\n            params[\"namespace\"] = namespace\n        path = \"/identity/identity\"\n        privateHeader = deepcopy(self.header)\n        privateHeader[\"Accept\"] = \"application/json\"\n        privateHeader[\"x-uis-cst-ctx\"] = \"stub\"\n        res = self.connector.getData(\n            self.endpoint + path, headers=privateHeader, params=params\n        )\n        return res\n\n    def getIdentities(self, only_custom: bool = False, save: bool = False) -> list:\n        \"\"\"\n        Get the list of all identity namespaces available in the organization.\n        Arguments:\n            only_custom : OPTIONAL : if set to True, return only customer made identities (default False)\n            save : OPTIONAL : if set to True, save the result in its respective folder (default False)\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getIdentities\")\n        path = \"/idnamespace/identities\"\n        res = self.connector.getData(self.endpoint + path, headers=self.header)\n        if only_custom:\n            res = [identity for identity in res if identity[\"custom\"] == True]\n        if save:\n            aepp.saveFile(\n                module=\"identity\", file=res, filename=\"identities\", type_file=\"json\"\n            )\n        return res\n\n    def getIdentityDetail(self, id_str: str = None, save: bool = False) -> dict:\n        \"\"\"\n        List details of a specific identity namespace by its ID.\n        Arguments:\n            id_str : REQUIRED : identity of the \"id\" field.\n            save : OPTIONAL : if set to True, save the result in a file, in its respective folder (default False)\n        \"\"\"\n        if id_str is None:\n            raise Exception(\"Expected an id for the Identity\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getIdentityDetail\")\n        path = f\"/idnamespace/identities/{id_str}\"\n        res = self.connector.getData(self.endpoint + path, headers=self.header)\n        if save:\n            filename = f\"identity_{res['code']}\"\n            aepp.saveFile(\n                module=\"identity\", file=res, filename=filename, type_file=\"json\"\n            )\n        return res\n\n    def createIdentity(\n        self,\n        name: str = None,\n        code: str = None,\n        idType: str = None,\n        description: str = None,\n        dict_identity: dict = None,\n    ) -> dict:\n        \"\"\"\n        List details of a specific identity namespace by its ID.\n        Arguments:\n            name : REQUIRED : Display name of the identity\n            code : REQUIRED : Identity Symbol for user interface.\n            idType : REQUIRED : one of those : COOKIE, CROSS_DEVICE, DEVICE, EMAIL, MOBILE, NON_PEOPLE or PHONE.\n            description : OPTIONAL : description for this identity\n            dict_identity : OPTIONAL : you can use this to directly pass the dictionary.\n        \"\"\"\n        creation_dict = {}\n        if name is None or code is None or idType is None:\n            raise Exception(\n                \"Expecting that name, code and idType to be filled with value\"\n            )\n        creation_dict[\"name\"] = name\n        creation_dict[\"code\"] = code\n        creation_dict[\"idType\"] = idType\n        if description is not None:\n            creation_dict[\"description\"] = description\n        if \" \" in code:\n            raise TypeError(\"code can only contain one word with letter and numbers\")\n        if idType not in [\n            \"COOKIE\",\n            \"CROSS_DEVICE\",\n            \"DEVICE\",\n            \"EMAIL\",\n            \"MOBILE\",\n            \"NON_PEOPLE\",\n            \"PHONE\",\n        ]:\n            raise TypeError(\n                \"idType could only be one of those : COOKIE, CROSS_DEVICE, DEVICE, EMAIL, MOBILE, NON_PEOPLE, PHONE\"\n            )\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createIdentity\")\n        if dict_identity is not None:\n            creation_dict = dict_identity\n        path = \"/idnamespace/identities\"\n        res = self.connector.postData(\n            self.endpoint + path, headers=self.header, data=creation_dict\n        )\n        return res\n\n    def updateIdentity(\n        self,\n        id_str: str = None,\n        name: str = None,\n        code: str = None,\n        idType: str = None,\n        description: str = None,\n    ) -> dict:\n        \"\"\"\n        Update identity based on its ID.\n        Arguments:\n            id_str: REQUIRED : ID of the identity namespace to update.\n            name : REQUIRED : Display name of the identity\n            code : REQUIRED : Identity Symbol for user interface.\n            idType : REQUIRED : one of those : COOKIE, CROSS_DEVICE, DEVICE, EMAIL, MOBILE, NON_PEOPLE or PHONE.\n            description : OPTIONAL : description for this identity\n        \"\"\"\n        if id_str is None:\n            raise Exception(\"Require an id\")\n        if name is None or code is None or idType is None:\n            raise Exception(\n                \"Expecting that name, code and idType to be filled with value\"\n            )\n        if idType not in [\n            \"COOKIE\",\n            \"CROSS_DEVICE\",\n            \"DEVICE\",\n            \"EMAIL\",\n            \"MOBILE\",\n            \"NON_PEOPLE\",\n            \"PHONE\",\n        ]:\n            raise TypeError(\n                \"idType could only be one of those : COOKIE, CROSS_DEVICE, DEVICE, EMAIL, MOBILE, NON_PEOPLE, PHONE\"\n            )\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting updateIdentity\")\n        path = f\"/idnamespace/identities/{id_str}\"\n        data = {\n            \"name\": name,\n            \"code\": code,\n            \"idType\": idType,\n            \"description\": description,\n        }\n        res = self.connector.putData(\n            self.endpoint + path, headers=self.header, data=data\n        )\n        return res\n\n    def getIdentitiesIMS(self, imsOrg: str = None) -> list:\n        \"\"\"\n        Returns all identities from the IMS Org itself.\n        Only shared ones if IMS Org doesn't match the IMS Org sent in the header.\n        Arguments:\n            imsOrg : OPTIONAL : the IMS org. If not set, takes the current one automatically.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getIdentitiesIMS\")\n        ims_org = imsOrg or self.connector.config[\"org_id\"]\n        path = f\"/idnamespace/orgs/{ims_org}/identities\"\n        res = self.connector.getData(self.endpoint + path, headers=self.header)\n        return res\n\n    def getClustersMembers(\n        self,\n        xid: str = None,\n        nsid: str = \"411\",\n        namespace: str = \"adcloud\",\n        id_value: str = None,\n        graphType: str = \"private\",\n    ) -> dict:\n        \"\"\"\n        Given an XID return all XIDs, in the same or other namespaces, that are linked to it by the device graph type.\n        The related XIDs are considered to be part of the same cluster.\n        It is required to pass either xid or (namespace/nsid & id) pair to get cluster members.\n        Arguments:\n            xid : REQUIRED : Identity string returns by the getIdentity method.\n            nsid : OPTIONAL : namespace id (default : 411)\n            namespace : OPTIONAL : namespace code. (default : adcloud)\n            id_value : OPTIONAL : ID of the customer in given namespace.\n            graphType : OPTIONAL : Graph type (output type) you want to get the cluster from. (default private)\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getClustersMembers\")\n        temp_header = deepcopy(self.header)\n        temp_header[\"Accept\"] = \"application/json\"\n        temp_header[\"x-uis-cst-ctx\"] = \"stub\"\n        path = \"/identity/cluster/members\"\n        params = {}\n        if xid is not None:\n            params[\"xid\"] = xid\n            params[\"graph-type\"] = graphType\n            res = self.connector.getData(\n                self.endpoint + path, params=params, headers=temp_header\n            )\n            return res\n        elif xid is None and id_value is not None:\n            params[\"nsid\"] = nsid\n            params[\"namespace\"] = namespace\n            params[\"id\"] = id_value\n            params[\"graph-type\"] = graphType\n            res = self.connector.getData(\n                self.endpoint + path, params=params, headers=temp_header\n            )\n            return res\n\n    def postClustersMembers(\n        self, xids: list = None, version: float = 1.0, graphType: str = \"private\"\n    ) -> dict:\n        \"\"\"\n        Given set of identities, returns all linked identities in cluster corresponding to each identity.\n        Arguments:\n            xids : REQUIRED : list of identity as returned by getIdentity method.\n            version : OPTIONAL : Version of the clusterMembers (default 1.0)\n            graphType : OPTIONAL : Graph type (output type) you want to get the cluster from. (default private)\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting postClustersMembers\")\n        temp_header = deepcopy(self.header)\n        temp_header[\"Accept\"] = \"application/vnd.adobe.identity+json;version=1.2\"\n        temp_header[\"x-uis-cst-ctx\"] = \"stub\"\n        path = \"/identity/cluster/members\"\n        if type(xids) != list:\n            raise TypeError(\"xids must be of type list\")\n        list_body = [\n            {\"xid\": [{\"xid\": xid}], \"graph-type\": graphType, \"version\": version}\n            for xid in xids\n        ]\n        res = self.connector.postData(\n            self.endpoint + path, data=list_body, headers=temp_header\n        )\n        return res\n\n    def getClusterHistory(\n        self,\n        xid: str = None,\n        nsid: int = 411,\n        namespace: str = \"adcloud\",\n        id_value: str = None,\n        graphType: str = \"private\",\n    ) -> dict:\n        \"\"\"\n        Given an XID, return all cluster associations with that XID.\n        It is required to pass either xid or (namespace/nsid & id) pair to get cluster history.\n        Arguments:\n            xid : REQUIRED : Identity string returns by the getIdentity method.\n            nsid : OPTIONAL : namespace id (default : 411)\n            namespace : OPTIONAL : namespace code. (default : adcloud)\n            id_value : OPTIONAL : ID of the customer in given namespace.\n            graphType : OPTIONAL : Graph type (output type) you want to get the cluster from. (default private)\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getClusterHistory\")\n        temp_header = deepcopy(self.header)\n        temp_header[\"Accept\"] = \"application/vnd.adobe.identity+json;version=1.2\"\n        temp_header[\"x-uis-cst-ctx\"] = \"stub\"\n        path = \"/identity/cluster/history\"\n        params = {}\n        if xid is not None:\n            params[\"xid\"] = xid\n            params[\"graph-type\"] = graphType\n            res = aepp._getData(\n                self.endpoint + path, params=params, headers=temp_header\n            )\n            return res\n        elif xid is None and id_value is not None:\n            params[\"nsid\"] = nsid\n            params[\"namespace\"] = namespace\n            params[\"id\"] = id_value\n            params[\"graph-type\"] = graphType\n            res = self.connector.getData(\n                self.endpoint + path, params=params, headers=temp_header\n            )\n            return res\n\n    def getIdentityMapping(\n        self,\n        xid: str = None,\n        targetNs: int = None,\n        nsid: int = 411,\n        namespace: str = \"adcloud\",\n        id_value: str = None,\n        graphType: str = \"private\",\n    ) -> dict:\n        \"\"\"\n        Given an XID, returns all XID mappings in the requested namespace (targetNs).\n        It is required to pass either xid or (namespace/nsid & id) pair to get mappings in required namespace.\n        Arguments:\n            xid : REQUIRED : Identity string returns by the getIdentity method.\n            nsid : OPTIONAL : namespace id (default : 411)\n            namespace : OPTIONAL : namespace code. (default : adcloud)\n            id_value : OPTIONAL : ID of the customer in given namespace.\n            graphType : OPTIONAL : Graph type (output type) you want to get the cluster from. (default private)\n            targetNs : OPTIONAL : The namespace you want to get the mappings from.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getIdentityMapping\")\n        temp_header = deepcopy(self.header)\n        temp_header[\"Accept\"] = \"application/vnd.adobe.identity+json;version=1.2\"\n        temp_header[\"x-uis-cst-ctx\"] = \"stub\"\n        path = \"/identity/mapping\"\n        params = {}\n        if xid is not None:\n            params[\"xid\"] = xid\n            params[\"graph-type\"] = graphType\n            params[\"targetNs\"] = targetNs\n            res = self.connector.getData(\n                self.endpoint + path, params=params, headers=temp_header\n            )\n            return res\n        elif xid is None and id_value is not None:\n            params[\"nsid\"] = nsid\n            params[\"namespace\"] = namespace\n            params[\"id\"] = id_value\n            params[\"targetNs\"] = targetNs\n            params[\"graph-type\"] = graphType\n            res = self.connector.getData(\n                self.endpoint + path, params=params, headers=temp_header\n            )\n            return res\n\n    def postIdentityMapping(\n        self, xids: list = None, targetNs: int = 411, version: float = 1.0\n    ) -> dict:\n        \"\"\"\n        Given an identity, returns all identity mappings in requested namespace (target namespace).\n        Arguments:\n            xids : REQUIRED : List of identities\n            targetNs : REQUIRED : Target Namespace (default 411)\n            version : OPTIONAL : version of the mapping\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting postIdentityMapping\")\n        temp_header = deepcopy(self.header)\n        temp_header[\"Accept\"] = \"application/vnd.adobe.identity+json;version=1.2\"\n        temp_header[\"x-uis-cst-ctx\"] = \"stub\"\n        path = \"/identity/mapping\"\n        if type(xids) != list:\n            raise TypeError(\"xids must be of type list\")\n        list_body = [\n            {\"xid\": [{\"xid\": xid}], \"version\": version, \"targetNs\": targetNs}\n            for xid in xids\n        ]\n        res = self.connector.postData(\n            self.endpoint + path, data=list_body, headers=temp_header\n        )\n        return res", "\nclass Identity:\n    \"\"\"\n    Class to manage and retrieve Identity information.\n    #!acpdr/swagger-specs/id-service-api.yaml\n    This is based on the following API reference : https://www.adobe.io/apis/experienceplatform/home/api-reference.html\n    \"\"\"\n\n    ## logging capability\n    loggingEnabled = False\n    logger = None\n\n    def __init__(\n        self,\n        region: str = \"nld2\",\n        config: Union[dict,ConnectObject] = aepp.config.config_object,\n        header: dict = aepp.config.header,\n        loggingObject: dict = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Require a region.\n        By default, the NLD2 will be selected. (other choice : va7)\n        Additional kwargs will update the header.\n        more info : https://docs.adobe.com/content/help/en/experience-platform/identity/api/getting-started.html\n        Arguments:\n            region : REQUIRED : either nld2 or va7\n            loggingObject : OPTIONAL : logging object to log messages.\n            config : OPTIONAL : config object in the config module. (DO NOT MODIFY)\n            header : OPTIONAL : header object  in the config module. (DO NOT MODIFY)\n        \"\"\"\n        if loggingObject is not None and sorted(\n            [\"level\", \"stream\", \"format\", \"filename\", \"file\"]\n        ) == sorted(list(loggingObject.keys())):\n            self.loggingEnabled = True\n            self.logger = logging.getLogger(f\"{__name__}\")\n            self.logger.setLevel(loggingObject[\"level\"])\n            if type(loggingObject[\"format\"]) == str:\n                formatter = logging.Formatter(loggingObject[\"format\"])\n            elif type(loggingObject[\"format\"]) == logging.Formatter:\n                formatter = loggingObject[\"format\"]\n            if loggingObject[\"file\"]:\n                fileHandler = logging.FileHandler(loggingObject[\"filename\"])\n                fileHandler.setFormatter(formatter)\n                self.logger.addHandler(fileHandler)\n            if loggingObject[\"stream\"]:\n                streamHandler = logging.StreamHandler()\n                streamHandler.setFormatter(formatter)\n                self.logger.addHandler(streamHandler)\n        if type(config) == dict: ## Supporting either default setup or passing a ConnectObject\n            config = config\n        elif type(config) == ConnectObject:\n            header = config.getConfigHeader()\n            config = config.getConfigObject()\n        self.connector = connector.AdobeRequest(\n            config=config,\n            header=header,\n            loggingEnabled=self.loggingEnabled,\n            logger=self.logger,\n        )\n        self.header = self.connector.header\n        self.header.update(**kwargs)\n        if kwargs.get('sandbox',None) is not None: ## supporting sandbox setup on class instanciation\n            self.sandbox = kwargs.get('sandbox')\n            self.connector.config[\"sandbox\"] = kwargs.get('sandbox')\n            self.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n            self.connector.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n        else:\n            self.sandbox = self.connector.config[\"sandbox\"]\n        self.endpoint = (\n            f\"https://platform-{region}.adobe.io\" + aepp.config.endpoints[\"identity\"]\n        )\n\n    def getIdentity(\n        self, id_str: str = None, nsid: str = None, namespace: str = None\n    ) -> dict:\n        \"\"\"\n        Given the namespace and an ID in that namespace, returns XID string.\n        Arguments:\n            id_str : REQUIRED : Id in given namespace (ECID value)\n            nsid : REQUIRED : namespace id. (e.g. 411)\n            namespace : OPTIONAL : namespace code (e.g. adcloud)\n        \"\"\"\n        if id_str is None or (namespace is None and nsid is None):\n            raise Exception(\n                \"Expecting that id_str and (namespace or nsid) arguments to be filled.\"\n            )\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getIdentity\")\n        params = {\"id\": id_str}\n        if nsid is not None:\n            params[\"nsid\"] = nsid\n        if namespace is not None:\n            params[\"namespace\"] = namespace\n        path = \"/identity/identity\"\n        privateHeader = deepcopy(self.header)\n        privateHeader[\"Accept\"] = \"application/json\"\n        privateHeader[\"x-uis-cst-ctx\"] = \"stub\"\n        res = self.connector.getData(\n            self.endpoint + path, headers=privateHeader, params=params\n        )\n        return res\n\n    def getIdentities(self, only_custom: bool = False, save: bool = False) -> list:\n        \"\"\"\n        Get the list of all identity namespaces available in the organization.\n        Arguments:\n            only_custom : OPTIONAL : if set to True, return only customer made identities (default False)\n            save : OPTIONAL : if set to True, save the result in its respective folder (default False)\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getIdentities\")\n        path = \"/idnamespace/identities\"\n        res = self.connector.getData(self.endpoint + path, headers=self.header)\n        if only_custom:\n            res = [identity for identity in res if identity[\"custom\"] == True]\n        if save:\n            aepp.saveFile(\n                module=\"identity\", file=res, filename=\"identities\", type_file=\"json\"\n            )\n        return res\n\n    def getIdentityDetail(self, id_str: str = None, save: bool = False) -> dict:\n        \"\"\"\n        List details of a specific identity namespace by its ID.\n        Arguments:\n            id_str : REQUIRED : identity of the \"id\" field.\n            save : OPTIONAL : if set to True, save the result in a file, in its respective folder (default False)\n        \"\"\"\n        if id_str is None:\n            raise Exception(\"Expected an id for the Identity\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getIdentityDetail\")\n        path = f\"/idnamespace/identities/{id_str}\"\n        res = self.connector.getData(self.endpoint + path, headers=self.header)\n        if save:\n            filename = f\"identity_{res['code']}\"\n            aepp.saveFile(\n                module=\"identity\", file=res, filename=filename, type_file=\"json\"\n            )\n        return res\n\n    def createIdentity(\n        self,\n        name: str = None,\n        code: str = None,\n        idType: str = None,\n        description: str = None,\n        dict_identity: dict = None,\n    ) -> dict:\n        \"\"\"\n        List details of a specific identity namespace by its ID.\n        Arguments:\n            name : REQUIRED : Display name of the identity\n            code : REQUIRED : Identity Symbol for user interface.\n            idType : REQUIRED : one of those : COOKIE, CROSS_DEVICE, DEVICE, EMAIL, MOBILE, NON_PEOPLE or PHONE.\n            description : OPTIONAL : description for this identity\n            dict_identity : OPTIONAL : you can use this to directly pass the dictionary.\n        \"\"\"\n        creation_dict = {}\n        if name is None or code is None or idType is None:\n            raise Exception(\n                \"Expecting that name, code and idType to be filled with value\"\n            )\n        creation_dict[\"name\"] = name\n        creation_dict[\"code\"] = code\n        creation_dict[\"idType\"] = idType\n        if description is not None:\n            creation_dict[\"description\"] = description\n        if \" \" in code:\n            raise TypeError(\"code can only contain one word with letter and numbers\")\n        if idType not in [\n            \"COOKIE\",\n            \"CROSS_DEVICE\",\n            \"DEVICE\",\n            \"EMAIL\",\n            \"MOBILE\",\n            \"NON_PEOPLE\",\n            \"PHONE\",\n        ]:\n            raise TypeError(\n                \"idType could only be one of those : COOKIE, CROSS_DEVICE, DEVICE, EMAIL, MOBILE, NON_PEOPLE, PHONE\"\n            )\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createIdentity\")\n        if dict_identity is not None:\n            creation_dict = dict_identity\n        path = \"/idnamespace/identities\"\n        res = self.connector.postData(\n            self.endpoint + path, headers=self.header, data=creation_dict\n        )\n        return res\n\n    def updateIdentity(\n        self,\n        id_str: str = None,\n        name: str = None,\n        code: str = None,\n        idType: str = None,\n        description: str = None,\n    ) -> dict:\n        \"\"\"\n        Update identity based on its ID.\n        Arguments:\n            id_str: REQUIRED : ID of the identity namespace to update.\n            name : REQUIRED : Display name of the identity\n            code : REQUIRED : Identity Symbol for user interface.\n            idType : REQUIRED : one of those : COOKIE, CROSS_DEVICE, DEVICE, EMAIL, MOBILE, NON_PEOPLE or PHONE.\n            description : OPTIONAL : description for this identity\n        \"\"\"\n        if id_str is None:\n            raise Exception(\"Require an id\")\n        if name is None or code is None or idType is None:\n            raise Exception(\n                \"Expecting that name, code and idType to be filled with value\"\n            )\n        if idType not in [\n            \"COOKIE\",\n            \"CROSS_DEVICE\",\n            \"DEVICE\",\n            \"EMAIL\",\n            \"MOBILE\",\n            \"NON_PEOPLE\",\n            \"PHONE\",\n        ]:\n            raise TypeError(\n                \"idType could only be one of those : COOKIE, CROSS_DEVICE, DEVICE, EMAIL, MOBILE, NON_PEOPLE, PHONE\"\n            )\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting updateIdentity\")\n        path = f\"/idnamespace/identities/{id_str}\"\n        data = {\n            \"name\": name,\n            \"code\": code,\n            \"idType\": idType,\n            \"description\": description,\n        }\n        res = self.connector.putData(\n            self.endpoint + path, headers=self.header, data=data\n        )\n        return res\n\n    def getIdentitiesIMS(self, imsOrg: str = None) -> list:\n        \"\"\"\n        Returns all identities from the IMS Org itself.\n        Only shared ones if IMS Org doesn't match the IMS Org sent in the header.\n        Arguments:\n            imsOrg : OPTIONAL : the IMS org. If not set, takes the current one automatically.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getIdentitiesIMS\")\n        ims_org = imsOrg or self.connector.config[\"org_id\"]\n        path = f\"/idnamespace/orgs/{ims_org}/identities\"\n        res = self.connector.getData(self.endpoint + path, headers=self.header)\n        return res\n\n    def getClustersMembers(\n        self,\n        xid: str = None,\n        nsid: str = \"411\",\n        namespace: str = \"adcloud\",\n        id_value: str = None,\n        graphType: str = \"private\",\n    ) -> dict:\n        \"\"\"\n        Given an XID return all XIDs, in the same or other namespaces, that are linked to it by the device graph type.\n        The related XIDs are considered to be part of the same cluster.\n        It is required to pass either xid or (namespace/nsid & id) pair to get cluster members.\n        Arguments:\n            xid : REQUIRED : Identity string returns by the getIdentity method.\n            nsid : OPTIONAL : namespace id (default : 411)\n            namespace : OPTIONAL : namespace code. (default : adcloud)\n            id_value : OPTIONAL : ID of the customer in given namespace.\n            graphType : OPTIONAL : Graph type (output type) you want to get the cluster from. (default private)\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getClustersMembers\")\n        temp_header = deepcopy(self.header)\n        temp_header[\"Accept\"] = \"application/json\"\n        temp_header[\"x-uis-cst-ctx\"] = \"stub\"\n        path = \"/identity/cluster/members\"\n        params = {}\n        if xid is not None:\n            params[\"xid\"] = xid\n            params[\"graph-type\"] = graphType\n            res = self.connector.getData(\n                self.endpoint + path, params=params, headers=temp_header\n            )\n            return res\n        elif xid is None and id_value is not None:\n            params[\"nsid\"] = nsid\n            params[\"namespace\"] = namespace\n            params[\"id\"] = id_value\n            params[\"graph-type\"] = graphType\n            res = self.connector.getData(\n                self.endpoint + path, params=params, headers=temp_header\n            )\n            return res\n\n    def postClustersMembers(\n        self, xids: list = None, version: float = 1.0, graphType: str = \"private\"\n    ) -> dict:\n        \"\"\"\n        Given set of identities, returns all linked identities in cluster corresponding to each identity.\n        Arguments:\n            xids : REQUIRED : list of identity as returned by getIdentity method.\n            version : OPTIONAL : Version of the clusterMembers (default 1.0)\n            graphType : OPTIONAL : Graph type (output type) you want to get the cluster from. (default private)\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting postClustersMembers\")\n        temp_header = deepcopy(self.header)\n        temp_header[\"Accept\"] = \"application/vnd.adobe.identity+json;version=1.2\"\n        temp_header[\"x-uis-cst-ctx\"] = \"stub\"\n        path = \"/identity/cluster/members\"\n        if type(xids) != list:\n            raise TypeError(\"xids must be of type list\")\n        list_body = [\n            {\"xid\": [{\"xid\": xid}], \"graph-type\": graphType, \"version\": version}\n            for xid in xids\n        ]\n        res = self.connector.postData(\n            self.endpoint + path, data=list_body, headers=temp_header\n        )\n        return res\n\n    def getClusterHistory(\n        self,\n        xid: str = None,\n        nsid: int = 411,\n        namespace: str = \"adcloud\",\n        id_value: str = None,\n        graphType: str = \"private\",\n    ) -> dict:\n        \"\"\"\n        Given an XID, return all cluster associations with that XID.\n        It is required to pass either xid or (namespace/nsid & id) pair to get cluster history.\n        Arguments:\n            xid : REQUIRED : Identity string returns by the getIdentity method.\n            nsid : OPTIONAL : namespace id (default : 411)\n            namespace : OPTIONAL : namespace code. (default : adcloud)\n            id_value : OPTIONAL : ID of the customer in given namespace.\n            graphType : OPTIONAL : Graph type (output type) you want to get the cluster from. (default private)\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getClusterHistory\")\n        temp_header = deepcopy(self.header)\n        temp_header[\"Accept\"] = \"application/vnd.adobe.identity+json;version=1.2\"\n        temp_header[\"x-uis-cst-ctx\"] = \"stub\"\n        path = \"/identity/cluster/history\"\n        params = {}\n        if xid is not None:\n            params[\"xid\"] = xid\n            params[\"graph-type\"] = graphType\n            res = aepp._getData(\n                self.endpoint + path, params=params, headers=temp_header\n            )\n            return res\n        elif xid is None and id_value is not None:\n            params[\"nsid\"] = nsid\n            params[\"namespace\"] = namespace\n            params[\"id\"] = id_value\n            params[\"graph-type\"] = graphType\n            res = self.connector.getData(\n                self.endpoint + path, params=params, headers=temp_header\n            )\n            return res\n\n    def getIdentityMapping(\n        self,\n        xid: str = None,\n        targetNs: int = None,\n        nsid: int = 411,\n        namespace: str = \"adcloud\",\n        id_value: str = None,\n        graphType: str = \"private\",\n    ) -> dict:\n        \"\"\"\n        Given an XID, returns all XID mappings in the requested namespace (targetNs).\n        It is required to pass either xid or (namespace/nsid & id) pair to get mappings in required namespace.\n        Arguments:\n            xid : REQUIRED : Identity string returns by the getIdentity method.\n            nsid : OPTIONAL : namespace id (default : 411)\n            namespace : OPTIONAL : namespace code. (default : adcloud)\n            id_value : OPTIONAL : ID of the customer in given namespace.\n            graphType : OPTIONAL : Graph type (output type) you want to get the cluster from. (default private)\n            targetNs : OPTIONAL : The namespace you want to get the mappings from.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getIdentityMapping\")\n        temp_header = deepcopy(self.header)\n        temp_header[\"Accept\"] = \"application/vnd.adobe.identity+json;version=1.2\"\n        temp_header[\"x-uis-cst-ctx\"] = \"stub\"\n        path = \"/identity/mapping\"\n        params = {}\n        if xid is not None:\n            params[\"xid\"] = xid\n            params[\"graph-type\"] = graphType\n            params[\"targetNs\"] = targetNs\n            res = self.connector.getData(\n                self.endpoint + path, params=params, headers=temp_header\n            )\n            return res\n        elif xid is None and id_value is not None:\n            params[\"nsid\"] = nsid\n            params[\"namespace\"] = namespace\n            params[\"id\"] = id_value\n            params[\"targetNs\"] = targetNs\n            params[\"graph-type\"] = graphType\n            res = self.connector.getData(\n                self.endpoint + path, params=params, headers=temp_header\n            )\n            return res\n\n    def postIdentityMapping(\n        self, xids: list = None, targetNs: int = 411, version: float = 1.0\n    ) -> dict:\n        \"\"\"\n        Given an identity, returns all identity mappings in requested namespace (target namespace).\n        Arguments:\n            xids : REQUIRED : List of identities\n            targetNs : REQUIRED : Target Namespace (default 411)\n            version : OPTIONAL : version of the mapping\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting postIdentityMapping\")\n        temp_header = deepcopy(self.header)\n        temp_header[\"Accept\"] = \"application/vnd.adobe.identity+json;version=1.2\"\n        temp_header[\"x-uis-cst-ctx\"] = \"stub\"\n        path = \"/identity/mapping\"\n        if type(xids) != list:\n            raise TypeError(\"xids must be of type list\")\n        list_body = [\n            {\"xid\": [{\"xid\": xid}], \"version\": version, \"targetNs\": targetNs}\n            for xid in xids\n        ]\n        res = self.connector.postData(\n            self.endpoint + path, data=list_body, headers=temp_header\n        )\n        return res", ""]}
{"filename": "aepp/configs.py", "chunked_list": ["#  Copyright 2023 Adobe. All rights reserved.\n#  This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License. You may obtain a copy\n#  of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software distributed under\n#  the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n#  OF ANY KIND, either express or implied. See the License for the specific language\n#  governing permissions and limitations under the License.\n", "#  governing permissions and limitations under the License.\n\nimport json\nimport os\nfrom pathlib import Path\nfrom typing import Optional\nimport json\n\n# Non standard libraries\nfrom .config import config_object, header, endpoints", "# Non standard libraries\nfrom .config import config_object, header, endpoints\nfrom aepp import connector\n\ndef find_path(path: str) -> Optional[Path]:\n    \"\"\"Checks if the file denoted by the specified `path` exists and returns the Path object\n    for the file.\n\n    If the file under the `path` does not exist and the path denotes an absolute path, tries\n    to find the file by converting the absolute path to a relative path.\n\n    If the file does not exist with either the absolute and the relative path, returns `None`.\n    \"\"\"\n    if Path(path).exists():\n        return Path(path)\n    elif path.startswith(\"/\") and Path(\".\" + path).exists():\n        return Path(\".\" + path)\n    elif path.startswith(\"\\\\\") and Path(\".\" + path).exists():\n        return Path(\".\" + path)\n    else:\n        return None", "\n\ndef createConfigFile(\n    destination: str = \"config_aep_template.json\",\n    sandbox: str = \"prod\",\n    environment: str = \"prod\",\n    verbose: object = False,\n    auth_type: str = \"oauthV2\",\n    **kwargs,\n) -> None:\n    \"\"\"\n    This function will create a 'config_admin.json' file where you can store your access data.\n    Arguments:\n        destination : OPTIONAL : if you wish to save the file at a specific location.\n        sandbox : OPTIONAL : You can directly set your sandbox name in this parameter.\n        verbose : OPTIONAL : set to true, gives you a print stateent where is the location.\n        auth_type : OPTIONAL : type of authentication, either \"jwt\" or \"oauthV2\" or \"oauthV1\". Default is oauthV2\n    \"\"\"\n    json_data: dict = {\n        \"org_id\": \"<orgID>\",\n        \"client_id\": \"<client_id>\",\n        \"secret\": \"<YourSecret>\",\n        \"sandbox-name\": sandbox,\n        \"environment\": environment\n    }\n    if auth_type == \"jwt\":\n        json_data[\"tech_id\"] = \"<something>@techacct.adobe.com\"\n        json_data[\"pathToKey\"] = \"<path/to/your/privatekey.key>\"\n    elif auth_type == \"oauthV2\":\n        json_data[\"scopes\"] = \"<scopes>\"\n    elif auth_type == \"oauthV1\":\n        json_data[\"auth_code\"] = \"<auth_code>\"\n    else:\n        raise ValueError(\"unsupported authentication type, currently only jwt, oauthV1 and oauthV2 are supported\")\n    if \".json\" not in destination:\n        destination: str = f\"{destination}.json\"\n    with open(destination, \"w\") as cf:\n        cf.write(json.dumps(json_data, indent=4))\n    if verbose:\n        print(\n            f\" file created at this location : {os.getcwd()}{os.sep}{destination}.json\"\n        )", "\n\ndef importConfigFile(\n    path: str = None,\n    connectInstance: bool = False,\n    auth_type: str = None,\n    sandbox:str = None,\n):\n    \"\"\"Reads the file denoted by the supplied `path` and retrieves the configuration information\n    from it.\n\n    Arguments:\n        path: REQUIRED : path to the configuration file. Can be either a fully-qualified or relative.\n        connectInstance : OPTIONAL : If you want to return an instance of the ConnectObject class\n        auth_type : OPTIONAL : type of authentication, either \"jwt\" or \"oauthV1\" or \"oauthV2\". Detected based on keys present in config file.\n        sandbox : OPTIONAL : The sandbox to connect it.\n\n    Example of path value.\n    \"config.json\"\n    \"./config.json\"\n    \"/my-folder/config.json\"\n    \"\"\"\n    if path is None:\n        raise ValueError(\"require a path to a configuration file to be provided\")\n     \n    config_file_path: Optional[Path] = find_path(path)\n    if config_file_path is None:\n        raise FileNotFoundError(\n            f\"Unable to find the configuration file under path `{path}`.\"\n        )\n    with open(config_file_path, \"r\") as file:\n        provided_config = json.load(file)\n        provided_keys = list(provided_config.keys())\n        if \"api_key\" in provided_keys:\n            ## old naming for client_id\n            client_id = provided_config[\"api_key\"]\n        elif \"client_id\" in provided_keys:\n            client_id = provided_config[\"client_id\"]\n        else:\n            raise RuntimeError(\n                f\"Either an `api_key` or a `client_id` should be provided.\"\n            )\n        if auth_type is None:\n            if 'scopes' in provided_keys:\n                auth_type = 'oauthV2'\n            elif 'tech_id' in provided_keys and \"pathToKey\" in provided_keys:\n                auth_type = 'jwt'\n            elif 'auth_code' in provided_keys:\n                auth_type = 'oauthV1'\n        args = {\n            \"org_id\": provided_config[\"org_id\"],\n            \"client_id\": client_id,\n            \"secret\": provided_config[\"secret\"],\n            \"sandbox\": provided_config.get(\"sandbox-name\", \"prod\"),\n            \"environment\": provided_config.get(\"environment\", \"prod\"),\n            \"connectInstance\": connectInstance\n        }\n        if sandbox is not None: ## overriding sandbox from parameter\n            args[\"sandbox\"] = sandbox\n        if auth_type == \"jwt\":\n            args[\"tech_id\"] = provided_config[\"tech_id\"]\n            args[\"path_to_key\"] = provided_config[\"pathToKey\"]\n        elif auth_type == \"oauthV2\":\n            args[\"scopes\"] = provided_config[\"scopes\"].replace(' ','')\n        elif auth_type == \"oauthV1\":\n            args[\"auth_code\"] = provided_config[\"auth_code\"]\n        else:\n            raise ValueError(\"unsupported authentication type, currently only jwt and oauth are supported\")\n        myInstance = configure(**args)\n\n    if connectInstance:\n        return myInstance", "\n\ndef configure(\n    org_id: str = None,\n    tech_id: str = None,\n    secret: str = None,\n    client_id: str = None,\n    path_to_key: str = None,\n    private_key: str = None,\n    sandbox: str = \"prod\",\n    connectInstance: bool = False,\n    environment: str = \"prod\",\n    scopes: str = None,\n    auth_code:str=None\n):\n    \"\"\"Performs programmatic configuration of the API using provided values.\n    Arguments:\n        org_id : REQUIRED : Organization ID\n        tech_id : OPTIONAL : Technical Account ID\n        secret : REQUIRED : secret generated for your connection\n        client_id : REQUIRED : The client_id (old api_key) provided by the JWT connection.\n        path_to_key : REQUIRED : If you have a file containing your private key value.\n        private_key : REQUIRED : If you do not use a file but pass a variable directly.\n        sandbox : OPTIONAL : If not provided, default to prod\n        connectInstance : OPTIONAL : If you want to return an instance of the ConnectObject class\n        environment : OPTIONAL : If not provided, default to prod\n        scopes : OPTIONAL : The scope define in your project for your API connection. Oauth V2, for clients and customers.\n        auth_code : OPTIONAL : If an authorization code is used directly instead of generating via JWT. Oauth V1 only, for adobe internal services.\n    \"\"\"\n    if not org_id:\n        raise ValueError(\"`org_id` must be specified in the configuration.\")\n    if not client_id:\n        raise ValueError(\"`client_id` must be specified in the configuration.\")\n    if not secret:\n        raise ValueError(\"`secret` must be specified in the configuration.\")\n    if (scopes is not None and (path_to_key is not None or private_key is not None) and auth_code is not None) \\\n            or (scopes is None and path_to_key is None and private_key is None and auth_code is None):\n        raise ValueError(\"either `scopes` needs to be specified or one of `private_key` or `path_to_key` or an `auth_code`\")\n    config_object[\"org_id\"] = org_id\n    header[\"x-gw-ims-org-id\"] = org_id\n    config_object[\"client_id\"] = client_id\n    header[\"x-api-key\"] = client_id\n    config_object[\"tech_id\"] = tech_id\n    config_object[\"secret\"] = secret\n    config_object[\"pathToKey\"] = path_to_key\n    config_object[\"private_key\"] = private_key\n    config_object[\"scopes\"] = scopes\n    config_object[\"auth_code\"] = auth_code\n    config_object[\"sandbox\"] = sandbox\n    header[\"x-sandbox-name\"] = sandbox\n\n    # ensure we refer to the right environment endpoints\n    config_object[\"environment\"] = environment\n    if environment == \"prod\":\n        endpoints[\"global\"] = \"https://platform.adobe.io\"\n        config_object[\"imsEndpoint\"] = \"https://ims-na1.adobelogin.com\"\n    else:\n        endpoints[\"global\"] = f\"https://platform-{environment}.adobe.io\"\n        config_object[\"imsEndpoint\"] = \"https://ims-na1-stg1.adobelogin.com\"\n    endpoints[\"streaming\"][\"inlet\"] = f\"{endpoints['global']}/data/core/edge\"\n    config_object[\"jwtTokenEndpoint\"] = f\"{config_object['imsEndpoint']}/ims/exchange/jwt\"\n    config_object[\"oauthTokenEndpointV1\"] = f\"{config_object['imsEndpoint']}/ims/token/v1\"\n    config_object[\"oauthTokenEndpointV2\"] = f\"{config_object['imsEndpoint']}/ims/token/v2\"\n    # ensure the reset of the state by overwriting possible values from previous import.\n    config_object[\"date_limit\"] = 0\n    config_object[\"token\"] = \"\"\n    if connectInstance:\n        myInstance = ConnectObject(\n            org_id=org_id,\n            tech_id=tech_id,\n            secret=secret,\n            client_id=client_id,\n            path_to_key = path_to_key,\n            private_key = private_key,\n            sandbox=sandbox,\n            scopes=scopes,\n            auth_code=auth_code\n        )\n        return myInstance", "\n\ndef get_private_key_from_config(config: dict) -> str:\n    \"\"\"\n    Returns the private key directly or read a file to return the private key.\n    \"\"\"\n    private_key = config.get(\"private_key\")\n    if private_key is not None:\n        return private_key\n    private_key_path = find_path(config[\"pathToKey\"])\n    if private_key_path is None:\n        raise FileNotFoundError(\n            f'Unable to find the private key under path `{config[\"pathToKey\"]}`.'\n        )\n    with open(Path(private_key_path), \"r\") as f:\n        private_key = f.read()\n    return private_key", "\n\ndef generateLoggingObject(level:str=\"WARNING\",filename:str=\"aepp.log\") -> dict:\n    \"\"\"\n    Generates a dictionary for the logging object with basic configuration.\n    You can find the information for the different possible values on the logging documentation.\n        https://docs.python.org/3/library/logging.html\n    Arguments:\n        level : OPTIONAL : Level of the logger to display information (NOTSET, DEBUG,INFO,WARNING,EROR,CRITICAL)\n            default WARNING\n        filename : OPTIONAL : name of the file for debugging. default aepp.log\n    Output:\n        level : Level of the logger to display information (NOTSET, DEBUG,INFO,WARNING,EROR,CRITICAL)\n        stream : If the logger should display print statements\n        file : If the logger should write the messages to a file\n        filename : name of the file where log are written\n        format : format of the logs\n    \"\"\"\n    myObject = {\n        \"level\": level,\n        \"stream\": True,\n        \"file\": False,\n        \"format\": \"%(asctime)s::%(name)s::%(funcName)s::%(levelname)s::%(message)s::%(lineno)d\",\n        \"filename\": filename,\n    }\n    return myObject", "\nclass ConnectObject:\n    \"\"\"\n    A connect Object class that keep tracks of the configuration loaded during the importConfigFile operation or during configure operation.\n    \n    \"\"\"\n\n    def __init__(self,\n            org_id: str = None,\n            tech_id: str = None,\n            secret: str = None,\n            client_id: str = None,\n            path_to_key: str = None,\n            private_key: str = None,\n            scopes:str=None,\n            sandbox: str = \"prod\",\n            environment: str = \"prod\",\n            auth_code:str=None,\n            **kwargs)->None:\n        \"\"\"\n        Take a config object and save the configuration directly in the instance of the class.\n        \"\"\"\n        self.header = {\"Accept\": \"application/json\",\n          \"Content-Type\": \"application/json\",\n          \"Authorization\": \"\",\n          \"x-api-key\": client_id,\n          \"x-gw-ims-org-id\": org_id,\n          \"x-sandbox-name\": sandbox\n          }\n        ## setting environment prod vs non-prod for token generation\n        if environment == \"prod\":\n            self.globalEndpoint = \"https://platform.adobe.io\"\n            self.imsEndpoint = \"https://ims-na1.adobelogin.com\"\n        else:\n            self.globalEndpoint = f\"https://platform-{environment}.adobe.io\"\n            self.imsEndpoint = \"https://ims-na1-stg1.adobelogin.com\"\n        self.streamInletEndpoint = f\"{self.globalEndpoint}/data/core/edge\"\n        self.jwtEndpoint = f\"{self.imsEndpoint}/ims/exchange/jwt\"\n        self.oauthEndpointV1 = f\"{self.imsEndpoint}/ims/token/v1\"\n        self.oauthEndpointV2 = f\"{self.imsEndpoint}/ims/token/v2\"\n        self.org_id = org_id\n        self.tech_id = tech_id\n        self.client_id = client_id\n        self.secret = secret\n        self.pathToKey = path_to_key\n        self.privateKey = private_key\n        self.sandbox = sandbox\n        self.scopes = scopes\n        self.token = \"\"\n        self.__configObject__ = {\n            \"org_id\": self.org_id,\n            \"client_id\": self.client_id,\n            \"tech_id\": self.tech_id,\n            \"pathToKey\": self.pathToKey,\n            \"private_key\": self.privateKey,\n            \"secret\": self.secret,\n            \"date_limit\" : 0,\n            \"sandbox\": self.sandbox,\n            \"token\": \"\",\n            \"imsEndpoint\" : self.imsEndpoint,\n            \"jwtTokenEndpoint\" : self.jwtEndpoint,\n            \"oauthTokenEndpointV1\" : self.oauthEndpointV1,\n            \"oauthTokenEndpointV2\" : self.oauthEndpointV2,\n            \"scopes\": self.scopes\n        }\n    \n    def connect(self)->None:\n        \"\"\"\n        Generate a token and provide a connector instance in that class.\n        \"\"\"\n        self.connector = connector.AdobeRequest(self.__configObject__,self.header)\n        self.token = self.connector.token\n        self.header['Authorization'] = 'bearer '+self.token\n    \n    def getConfigObject(self)->dict:\n        \"\"\"\n        Return the config object expected.\n        \"\"\"\n        return self.__configObject__\n    \n    def getConfigHeader(self)->dict:\n        \"\"\"\n        Return the default header\n        \"\"\"\n        return self.header\n\n    def setSandbox(self,sandbox:str=None)->dict:\n        \"\"\"\n        Update the sandbox used\n        \"\"\"\n        if sandbox is None:\n            return None\n        self.sandbox = sandbox\n        self.header[\"x-sandbox-name\"] = sandbox\n        self.__configObject__[\"sandbox\"] = sandbox\n        return self.getConfigObject()", ""]}
{"filename": "aepp/sandboxes.py", "chunked_list": ["#  Copyright 2023 Adobe. All rights reserved.\n#  This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License. You may obtain a copy\n#  of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software distributed under\n#  the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n#  OF ANY KIND, either express or implied. See the License for the specific language\n#  governing permissions and limitations under the License.\n", "#  governing permissions and limitations under the License.\n\nimport aepp\nfrom aepp import connector\nimport logging\nfrom typing import Union\nfrom .configs import ConnectObject\n\n\nclass Sandboxes:\n    \"\"\"\n    A collection of methods to realize actions on the sandboxes.\n    It comes from the sandbox API:\n    https://www.adobe.io/apis/experienceplatform/home/api-reference.html#!acpdr/swagger-specs/sandbox-api.yaml\n    \"\"\"\n\n    ## logging capability\n    loggingEnabled = False\n    logger = None\n\n    def __init__(\n        self,\n        config: Union[dict,ConnectObject] = aepp.config.config_object,\n        header: dict = aepp.config.header,\n        loggingObject: dict = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Instantiate the sandbox class.\n        Arguments:\n            config : OPTIONAL : config object in the config module. (DO NOT MODIFY)\n            header : OPTIONAL : header object  in the config module. (DO NOT MODIFY)\n            loggingObject : OPTIONAL : logging object to log messages.\n        Additional kwargs will update the header.\n        \"\"\"\n        if loggingObject is not None and sorted(\n            [\"level\", \"stream\", \"format\", \"filename\", \"file\"]\n        ) == sorted(list(loggingObject.keys())):\n            self.loggingEnabled = True\n            self.logger = logging.getLogger(f\"{__name__}\")\n            self.logger.setLevel(loggingObject[\"level\"])\n            if type(loggingObject[\"format\"]) == str:\n                formatter = logging.Formatter(loggingObject[\"format\"])\n            elif type(loggingObject[\"format\"]) == logging.Formatter:\n                formatter = loggingObject[\"format\"]\n            if loggingObject[\"file\"]:\n                fileHandler = logging.FileHandler(loggingObject[\"filename\"])\n                fileHandler.setFormatter(formatter)\n                self.logger.addHandler(fileHandler)\n            if loggingObject[\"stream\"]:\n                streamHandler = logging.StreamHandler()\n                streamHandler.setFormatter(formatter)\n                self.logger.addHandler(streamHandler)\n        if type(config) == dict: ## Supporting either default setup or passing a ConnectObject\n            config = config\n        elif type(config) == ConnectObject:\n            header = config.getConfigHeader()\n            config = config.getConfigObject()\n        self.connector = connector.AdobeRequest(\n            config=config,\n            header=header,\n            loggingEnabled=self.loggingEnabled,\n            loggingObject=self.logger,\n        )\n        self.header = self.connector.header\n        self.header.update(**kwargs)\n        if kwargs.get('sandbox',None) is not None: ## supporting sandbox setup on class instanciation\n            self.sandbox = kwargs.get('sandbox')\n            self.connector.config[\"sandbox\"] = kwargs.get('sandbox')\n            self.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n            self.connector.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n        else:\n            self.sandbox = self.connector.config[\"sandbox\"]\n        self.endpoint = (\n            aepp.config.endpoints[\"global\"] + aepp.config.endpoints[\"sandboxes\"]\n        )\n\n    def getSandboxes(self) -> list:\n        \"\"\"\n        Return the list of all the sandboxes\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getSandboxes\")\n        path = self.endpoint + \"/sandboxes\"\n        res = self.connector.getData(path)\n        data = res[\"sandboxes\"]\n        return data\n\n    def getSandboxTypes(self) -> list:\n        \"\"\"\n        Return the list of all the sandboxes types.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getSandboxTyoes\")\n        path = self.endpoint + \"/sandboxTypes\"\n        res = self.connector.getData(path)\n        data = res[\"sandboxTypes\"]\n        return data\n\n    def createSandbox(\n        self, name: str = None, title: str = None, type_sandbox: str = \"development\"\n    ) -> dict:\n        \"\"\"\n        Create a new sandbox in your AEP instance.\n        Arguments:\n            name : REQUIRED : name of your sandbox\n            title : REQUIRED : display name of your sandbox\n            type_sandbox : OPTIONAL : type of your sandbox. default : development.\n        \"\"\"\n        if name is None or title is None:\n            raise Exception(\"name and title cannot be empty\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createSandbox\")\n        path = self.endpoint + \"/sandboxes\"\n        data = {\"name\": name, \"title\": title, \"type\": type_sandbox}\n        res = self.connector.postData(path, data=data)\n        return res\n\n    def getSandbox(self, name: str) -> dict:\n        \"\"\"\n        retrieve a Sandbox information by name\n        Argument:\n            name : REQUIRED : name of Sandbox\n        \"\"\"\n        if name is None:\n            raise Exception(\"Expected a name as parameter\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getSandbox\")\n        path = self.endpoint + f\"/sandboxes/{name}\"\n        res = self.connector.getData(path)\n        return res\n\n    def getSandboxId(self, name: str) -> str:\n        \"\"\"\n        Retrieve the ID of a sandbox by name.\n        Argument:\n            name : REQUIRED : name of Sandbox\n        \"\"\"\n        return self.getSandbox(name)[\"id\"]\n\n    def deleteSandbox(self, name: str) -> dict:\n        \"\"\"\n        Delete a sandbox by its name.\n        Arguments:\n            name : REQUIRED : sandbox to be deleted.\n        \"\"\"\n        if name is None:\n            raise Exception(\"Expected a name as parameter\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteSandbox\")\n        path = self.endpoint + f\"/sandboxes/{name}\"\n        res = self.connector.deleteData(path)\n        return res\n\n    def resetSandbox(self, name: str) -> dict:\n        \"\"\"\n        Reset a sandbox by its name. Sandbox will be empty.\n        Arguments:\n            name : REQUIRED : sandbox name to be deleted.\n        \"\"\"\n        if name is None:\n            raise Exception(\"Expected a sandbox name as parameter\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting resetSandbox\")\n        path = self.endpoint + f\"/sandboxes/{name}\"\n        res = self.connector.putData(path, data={'action':'reset'})\n        return res\n\n    def updateSandbox(self, name: str, action: dict = None) -> dict:\n        \"\"\"\n        Update the Sandbox with the action provided.\n        Arguments:\n            name : REQUIRED : sandbox name to be updated.\n            action : REQUIRED : dictionary defining the action to realize on that sandbox.\n        \"\"\"\n        if name is None:\n            raise Exception(\"Expected a sandbox name as parameter\")\n        if action is None or type(action) != dict:\n            raise Exception(\"Expected a dictionary to pass the action\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting updateSandboxes\")\n        path = self.endpoint + f\"/sandboxes/{name}\"\n        res = self.connector.patchData(path, data=action)\n        return res", "\nclass Sandboxes:\n    \"\"\"\n    A collection of methods to realize actions on the sandboxes.\n    It comes from the sandbox API:\n    https://www.adobe.io/apis/experienceplatform/home/api-reference.html#!acpdr/swagger-specs/sandbox-api.yaml\n    \"\"\"\n\n    ## logging capability\n    loggingEnabled = False\n    logger = None\n\n    def __init__(\n        self,\n        config: Union[dict,ConnectObject] = aepp.config.config_object,\n        header: dict = aepp.config.header,\n        loggingObject: dict = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Instantiate the sandbox class.\n        Arguments:\n            config : OPTIONAL : config object in the config module. (DO NOT MODIFY)\n            header : OPTIONAL : header object  in the config module. (DO NOT MODIFY)\n            loggingObject : OPTIONAL : logging object to log messages.\n        Additional kwargs will update the header.\n        \"\"\"\n        if loggingObject is not None and sorted(\n            [\"level\", \"stream\", \"format\", \"filename\", \"file\"]\n        ) == sorted(list(loggingObject.keys())):\n            self.loggingEnabled = True\n            self.logger = logging.getLogger(f\"{__name__}\")\n            self.logger.setLevel(loggingObject[\"level\"])\n            if type(loggingObject[\"format\"]) == str:\n                formatter = logging.Formatter(loggingObject[\"format\"])\n            elif type(loggingObject[\"format\"]) == logging.Formatter:\n                formatter = loggingObject[\"format\"]\n            if loggingObject[\"file\"]:\n                fileHandler = logging.FileHandler(loggingObject[\"filename\"])\n                fileHandler.setFormatter(formatter)\n                self.logger.addHandler(fileHandler)\n            if loggingObject[\"stream\"]:\n                streamHandler = logging.StreamHandler()\n                streamHandler.setFormatter(formatter)\n                self.logger.addHandler(streamHandler)\n        if type(config) == dict: ## Supporting either default setup or passing a ConnectObject\n            config = config\n        elif type(config) == ConnectObject:\n            header = config.getConfigHeader()\n            config = config.getConfigObject()\n        self.connector = connector.AdobeRequest(\n            config=config,\n            header=header,\n            loggingEnabled=self.loggingEnabled,\n            loggingObject=self.logger,\n        )\n        self.header = self.connector.header\n        self.header.update(**kwargs)\n        if kwargs.get('sandbox',None) is not None: ## supporting sandbox setup on class instanciation\n            self.sandbox = kwargs.get('sandbox')\n            self.connector.config[\"sandbox\"] = kwargs.get('sandbox')\n            self.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n            self.connector.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n        else:\n            self.sandbox = self.connector.config[\"sandbox\"]\n        self.endpoint = (\n            aepp.config.endpoints[\"global\"] + aepp.config.endpoints[\"sandboxes\"]\n        )\n\n    def getSandboxes(self) -> list:\n        \"\"\"\n        Return the list of all the sandboxes\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getSandboxes\")\n        path = self.endpoint + \"/sandboxes\"\n        res = self.connector.getData(path)\n        data = res[\"sandboxes\"]\n        return data\n\n    def getSandboxTypes(self) -> list:\n        \"\"\"\n        Return the list of all the sandboxes types.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getSandboxTyoes\")\n        path = self.endpoint + \"/sandboxTypes\"\n        res = self.connector.getData(path)\n        data = res[\"sandboxTypes\"]\n        return data\n\n    def createSandbox(\n        self, name: str = None, title: str = None, type_sandbox: str = \"development\"\n    ) -> dict:\n        \"\"\"\n        Create a new sandbox in your AEP instance.\n        Arguments:\n            name : REQUIRED : name of your sandbox\n            title : REQUIRED : display name of your sandbox\n            type_sandbox : OPTIONAL : type of your sandbox. default : development.\n        \"\"\"\n        if name is None or title is None:\n            raise Exception(\"name and title cannot be empty\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createSandbox\")\n        path = self.endpoint + \"/sandboxes\"\n        data = {\"name\": name, \"title\": title, \"type\": type_sandbox}\n        res = self.connector.postData(path, data=data)\n        return res\n\n    def getSandbox(self, name: str) -> dict:\n        \"\"\"\n        retrieve a Sandbox information by name\n        Argument:\n            name : REQUIRED : name of Sandbox\n        \"\"\"\n        if name is None:\n            raise Exception(\"Expected a name as parameter\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getSandbox\")\n        path = self.endpoint + f\"/sandboxes/{name}\"\n        res = self.connector.getData(path)\n        return res\n\n    def getSandboxId(self, name: str) -> str:\n        \"\"\"\n        Retrieve the ID of a sandbox by name.\n        Argument:\n            name : REQUIRED : name of Sandbox\n        \"\"\"\n        return self.getSandbox(name)[\"id\"]\n\n    def deleteSandbox(self, name: str) -> dict:\n        \"\"\"\n        Delete a sandbox by its name.\n        Arguments:\n            name : REQUIRED : sandbox to be deleted.\n        \"\"\"\n        if name is None:\n            raise Exception(\"Expected a name as parameter\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteSandbox\")\n        path = self.endpoint + f\"/sandboxes/{name}\"\n        res = self.connector.deleteData(path)\n        return res\n\n    def resetSandbox(self, name: str) -> dict:\n        \"\"\"\n        Reset a sandbox by its name. Sandbox will be empty.\n        Arguments:\n            name : REQUIRED : sandbox name to be deleted.\n        \"\"\"\n        if name is None:\n            raise Exception(\"Expected a sandbox name as parameter\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting resetSandbox\")\n        path = self.endpoint + f\"/sandboxes/{name}\"\n        res = self.connector.putData(path, data={'action':'reset'})\n        return res\n\n    def updateSandbox(self, name: str, action: dict = None) -> dict:\n        \"\"\"\n        Update the Sandbox with the action provided.\n        Arguments:\n            name : REQUIRED : sandbox name to be updated.\n            action : REQUIRED : dictionary defining the action to realize on that sandbox.\n        \"\"\"\n        if name is None:\n            raise Exception(\"Expected a sandbox name as parameter\")\n        if action is None or type(action) != dict:\n            raise Exception(\"Expected a dictionary to pass the action\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting updateSandboxes\")\n        path = self.endpoint + f\"/sandboxes/{name}\"\n        res = self.connector.patchData(path, data=action)\n        return res", ""]}
{"filename": "aepp/dataaccess.py", "chunked_list": ["#  Copyright 2023 Adobe. All rights reserved.\n#  This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License. You may obtain a copy\n#  of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software distributed under\n#  the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n#  OF ANY KIND, either express or implied. See the License for the specific language\n#  governing permissions and limitations under the License.\n", "#  governing permissions and limitations under the License.\n\nimport aepp\nfrom aepp import connector\nimport logging\nimport time\nimport io\nfrom typing import Union\nfrom .configs import ConnectObject\n\nclass DataAccess:\n    \"\"\"\n    A class providing methods based on the Data Access API\n    https://www.adobe.io/apis/experienceplatform/home/api-reference.html#!acpdr/swagger-specs/data-access-api.yaml\n    \"\"\"\n\n    ## logging capability\n    loggingEnabled = False\n    logger = None\n\n    def __init__(\n        self,\n        config: Union[dict,ConnectObject] = aepp.config.config_object,\n        header: dict = aepp.config.header,\n        loggingObject: dict = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Instantiate the DataAccess class.\n        Arguments:\n            config : OPTIONAL : config object in the config module. (DO NOT MODIFY)\n            header : OPTIONAL : header object  in the config module. (DO NOT MODIFY)\n            loggingObject : OPTIONAL : logging object to log messages.\n        Additional kwargs will update the header.\n        \"\"\"\n        if loggingObject is not None and sorted(\n            [\"level\", \"stream\", \"format\", \"filename\", \"file\"]\n        ) == sorted(list(loggingObject.keys())):\n            self.loggingEnabled = True\n            self.logger = logging.getLogger(f\"{__name__}\")\n            self.logger.setLevel(loggingObject[\"level\"])\n            if type(loggingObject[\"format\"]) == str:\n                formatter = logging.Formatter(loggingObject[\"format\"])\n            elif type(loggingObject[\"format\"]) == logging.Formatter:\n                formatter = loggingObject[\"format\"]\n            if loggingObject[\"file\"]:\n                fileHandler = logging.FileHandler(loggingObject[\"filename\"])\n                fileHandler.setFormatter(formatter)\n                self.logger.addHandler(fileHandler)\n            if loggingObject[\"stream\"]:\n                streamHandler = logging.StreamHandler()\n                streamHandler.setFormatter(formatter)\n                self.logger.addHandler(streamHandler)\n        if type(config) == dict: ## Supporting either default setup or passing a ConnectObject\n            config = config\n        elif type(config) == ConnectObject:\n            header = config.getConfigHeader()\n            config = config.getConfigObject()\n        self.connector = connector.AdobeRequest(\n            config=config,\n            header=header,\n            loggingEnabled=self.loggingEnabled,\n            loggingObject=self.logger,\n        )\n        self.header = self.connector.header\n        self.header.update(**kwargs)\n        if kwargs.get('sandbox',None) is not None: ## supporting sandbox setup on class instanciation\n            self.sandbox = kwargs.get('sandbox')\n            self.connector.config[\"sandbox\"] = kwargs.get('sandbox')\n            self.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n            self.connector.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n        else:\n            self.sandbox = self.connector.config[\"sandbox\"]\n        self.endpoint = (\n            aepp.config.endpoints[\"global\"] + aepp.config.endpoints[\"dataaccess\"]\n        )\n\n    def getBatchFiles(\n        self, batchId: str = None, verbose: bool = False, **kwargs\n    ) -> list:\n        \"\"\"\n        List all dataset files under a batch.\n        Arguments:\n            batchId : REQUIRED : The batch ID to look for.\n        Possible kwargs:\n            limit : A paging parameter to specify number of results per page.\n            start : A paging parameter to specify start of new page. For example: page=1\n        \"\"\"\n        if batchId is None:\n            raise ValueError(\"Require a batchId to be specified.\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getBatchFiles\")\n        params = {}\n        if kwargs.get(\"limit\", None) is not None:\n            params[\"limit\"] = str(kwargs.get(\"limit\"))\n        if kwargs.get(\"start\", None) is not None:\n            params[\"start\"] = str(kwargs.get(\"start\"))\n        path = f\"/batches/{batchId}/files\"\n        res = self.connector.getData(\n            self.endpoint + path, params=params, verbose=verbose\n        )\n        try:\n            return res[\"data\"]\n        except:\n            return res\n\n    def getBatchFailed(\n        self, batchId: str = None, path: str = None, verbose: bool = False, **kwargs\n    ) -> list:\n        \"\"\"\n        Lists all the dataset files under a failed batch.\n        Arguments:\n            batchId : REQUIRED : The batch ID to look for.\n            path : OPTIONAL : The full name of the file. The contents of the file would be downloaded if this parameter is provided.\n                For example: path=profiles.csv\n        Possible kwargs:\n            limit : A paging parameter to specify number of results per page.\n            start : A paging parameter to specify start of new page. For example: page=1\n        \"\"\"\n        if batchId is None:\n            raise ValueError(\"Require a batchId to be specified.\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getBatchFailed\")\n        params = {}\n        if kwargs.get(\"limit\", None) is not None:\n            params[\"limit\"] = str(kwargs.get(\"limit\"))\n        if kwargs.get(\"start\", None) is not None:\n            params[\"start\"] = str(kwargs.get(\"start\"))\n        if path is not None:\n            params[\"path\"] = path\n        pathEndpoint = f\"/batches/{batchId}/failed\"\n        res = self.connector.getData(\n            self.endpoint + pathEndpoint, params=params, verbose=verbose\n        )\n        try:\n            return res[\"data\"]\n        except:\n            return res\n\n    def getBatchMeta(self, batchId: str = None, path: str = None, **kwargs) -> dict:\n        \"\"\"\n        Lists files under a batch\u2019s meta directory or download a specific file under it. The files under a batch\u2019s meta directory may include the following:\n            row_errors: A directory containing 0 or more files with parsing, conversion, and/or validation errors found at the row level.\n            input_files: A directory containing metadata for 1 or more input files submitted with the batch.\n            row_errors_sample.json: A root level file containing the sampled set of row errors for the UX.\n        Arguments:\n            batchId : REQUIRED : The batch ID to look for.\n            path : OPTIONAL : The full name of the file. The contents of the file would be downloaded if this parameter is provided.\n                Possible values for this query include the following:\n                    row_errors\n                    input_files\n                    row_errors_sample.json\n        Possible kwargs:\n            limit : A paging parameter to specify number of results per page.\n            start : A paging parameter to specify start of new page. For example: page=1\n        \"\"\"\n        if batchId is None:\n            raise ValueError(\"Require a batchId to be specified.\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getBatchMeta\")\n        params = {}\n        if kwargs.get(\"limit\", None) is not None:\n            params[\"limit\"] = str(kwargs.get(\"limit\"))\n        if kwargs.get(\"start\", None) is not None:\n            params[\"start\"] = str(kwargs.get(\"start\"))\n        if path is not None:\n            params[\"path\"] = path\n        pathEndpoint = f\"/batches/{batchId}/meta\"\n        res = self.connector.getData(\n            self.endpoint + pathEndpoint, headers=self.header, params=params\n        )\n        return res\n\n    def getHeadFile(\n        self,\n        dataSetFileId: str = None,\n        path: str = None,\n        verbose: bool = False,\n    ) -> dict:\n        \"\"\"\n        Get headers regarding a file.\n        Arguments:\n            dataSetFileId : REQURED : The ID of the dataset file you are retrieving.\n            path : REQUIRED : The full name of the file identified.\n                For example: path=profiles.csv\n        \"\"\"\n        if dataSetFileId is None or path is None:\n            raise ValueError(\"Require a dataSetFileId and a path for that method\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getHeadFile\")\n        params = {\"path\": path}\n        pathEndpoint = f\"/files/{dataSetFileId}\"\n        res = self.connector.headData(\n            self.endpoint + pathEndpoint, params=params, verbose=verbose\n        )\n        return res\n\n    def getFiles(\n        self,\n        dataSetFileId: str = None,\n        path: str = None,\n        range: str = None,\n        start: str = None,\n        limit: int = None,\n    ) -> Union[dict,bytes]:\n        \"\"\"\n        Returns either a complete file or a directory of chunked data that makes up the file.\n        The response contains a data array that may contain a single entry or a list of files belonging to that directory.\n        Arguments:\n            dataSetFileId : REQUIRED : The ID of the dataset file you are retrieving.\n            path : OPTIONAL : The full name of the file. The contents of the file would be downloaded if this parameter is provided.\n                For example: path=profiles.csv\n                if the extension is .parquet, it will try to return the parquet data decoded (io.BytesIO). \n            range : OPTIONAL : The range of bytes requested. For example: Range: bytes=0-100000\n            start : OPTIONAL : A paging parameter to specify start of new page. For example: start=fileName.csv\n            limit : OPTIONAL : A paging parameter to specify number of results per page. For example: limit=10\n        \"\"\"\n        if dataSetFileId is None:\n            raise ValueError(\"Require a dataSetFileId\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getFiles\")\n        params = {}\n        if path is not None:\n            params[\"path\"] = path\n        if range is not None:\n            params[\"range\"] = range\n        if start is not None:\n            params[\"start\"] = start\n        if limit is not None:\n            params[\"limit\"] = limit\n        pathEndpoint = f\"/files/{dataSetFileId}\"\n        if path is None:\n            res: dict = self.connector.getData(\n                self.endpoint + pathEndpoint, headers=self.header, params=params\n            )\n        else:\n            if path.endswith('.parquet'):\n                data = self.getResource(self.endpoint + pathEndpoint,params={\"path\":path},format='raw')\n                res = io.BytesIO(data.content)\n            else:\n                data = self.getResource(self.endpoint + pathEndpoint,params={\"path\":path},format='raw')\n                res = data.content\n        return res\n\n    def getPreview(self, datasetId: str = None) -> list:\n        \"\"\"\n        Give a preview of a specific dataset\n        Arguments:\n            datasetId : REQUIRED : the dataset ID to preview\n        \"\"\"\n        if datasetId is None:\n            raise ValueError(\"Require a datasetId\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getPreview\")\n        path = f\"/datasets/{datasetId}/preview\"\n        res: dict = self.connector.getData(self.endpoint + path, headers=self.header)\n        try:\n            return res[\"data\"]\n        except:\n            return res\n\n    def getResource(\n        self,\n        endpoint: str = None,\n        params: dict = None,\n        format: str = \"json\",\n        save: bool = False,\n        **kwargs,\n    ) -> dict:\n        \"\"\"\n        Template for requesting data with a GET method.\n        Arguments:\n            endpoint : REQUIRED : The URL to GET\n            params: OPTIONAL : dictionary of the params to fetch\n            format : OPTIONAL : Type of response returned. Possible values:\n                json : default\n                txt : text file\n                raw : a response object from the requests module\n        \"\"\"\n        if endpoint is None:\n            raise ValueError(\"Require an endpoint\")\n        if self.loggingEnabled:\n            self.logger.debug(\n                f\"Using getResource with following format ({format}) to the following endpoint: {endpoint}\"\n            )\n        res = self.connector.getData(endpoint, params=params, format=format)\n        if save:\n            if format == \"json\":\n                aepp.saveFile(\n                    module=\"catalog\",\n                    file=res,\n                    filename=f\"resource_{int(time.time())}\",\n                    type_file=\"json\",\n                    encoding=kwargs.get(\"encoding\", \"utf-8\"),\n                )\n            elif format == \"txt\":\n                aepp.saveFile(\n                    module=\"catalog\",\n                    file=res,\n                    filename=f\"resource_{int(time.time())}\",\n                    type_file=\"txt\",\n                    encoding=kwargs.get(\"encoding\", \"utf-8\"),\n                )\n            else:\n                print(\n                    \"element is an object. Output is unclear. No save made.\\nPlease save this element manually\"\n                )\n        return res", "from .configs import ConnectObject\n\nclass DataAccess:\n    \"\"\"\n    A class providing methods based on the Data Access API\n    https://www.adobe.io/apis/experienceplatform/home/api-reference.html#!acpdr/swagger-specs/data-access-api.yaml\n    \"\"\"\n\n    ## logging capability\n    loggingEnabled = False\n    logger = None\n\n    def __init__(\n        self,\n        config: Union[dict,ConnectObject] = aepp.config.config_object,\n        header: dict = aepp.config.header,\n        loggingObject: dict = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Instantiate the DataAccess class.\n        Arguments:\n            config : OPTIONAL : config object in the config module. (DO NOT MODIFY)\n            header : OPTIONAL : header object  in the config module. (DO NOT MODIFY)\n            loggingObject : OPTIONAL : logging object to log messages.\n        Additional kwargs will update the header.\n        \"\"\"\n        if loggingObject is not None and sorted(\n            [\"level\", \"stream\", \"format\", \"filename\", \"file\"]\n        ) == sorted(list(loggingObject.keys())):\n            self.loggingEnabled = True\n            self.logger = logging.getLogger(f\"{__name__}\")\n            self.logger.setLevel(loggingObject[\"level\"])\n            if type(loggingObject[\"format\"]) == str:\n                formatter = logging.Formatter(loggingObject[\"format\"])\n            elif type(loggingObject[\"format\"]) == logging.Formatter:\n                formatter = loggingObject[\"format\"]\n            if loggingObject[\"file\"]:\n                fileHandler = logging.FileHandler(loggingObject[\"filename\"])\n                fileHandler.setFormatter(formatter)\n                self.logger.addHandler(fileHandler)\n            if loggingObject[\"stream\"]:\n                streamHandler = logging.StreamHandler()\n                streamHandler.setFormatter(formatter)\n                self.logger.addHandler(streamHandler)\n        if type(config) == dict: ## Supporting either default setup or passing a ConnectObject\n            config = config\n        elif type(config) == ConnectObject:\n            header = config.getConfigHeader()\n            config = config.getConfigObject()\n        self.connector = connector.AdobeRequest(\n            config=config,\n            header=header,\n            loggingEnabled=self.loggingEnabled,\n            loggingObject=self.logger,\n        )\n        self.header = self.connector.header\n        self.header.update(**kwargs)\n        if kwargs.get('sandbox',None) is not None: ## supporting sandbox setup on class instanciation\n            self.sandbox = kwargs.get('sandbox')\n            self.connector.config[\"sandbox\"] = kwargs.get('sandbox')\n            self.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n            self.connector.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n        else:\n            self.sandbox = self.connector.config[\"sandbox\"]\n        self.endpoint = (\n            aepp.config.endpoints[\"global\"] + aepp.config.endpoints[\"dataaccess\"]\n        )\n\n    def getBatchFiles(\n        self, batchId: str = None, verbose: bool = False, **kwargs\n    ) -> list:\n        \"\"\"\n        List all dataset files under a batch.\n        Arguments:\n            batchId : REQUIRED : The batch ID to look for.\n        Possible kwargs:\n            limit : A paging parameter to specify number of results per page.\n            start : A paging parameter to specify start of new page. For example: page=1\n        \"\"\"\n        if batchId is None:\n            raise ValueError(\"Require a batchId to be specified.\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getBatchFiles\")\n        params = {}\n        if kwargs.get(\"limit\", None) is not None:\n            params[\"limit\"] = str(kwargs.get(\"limit\"))\n        if kwargs.get(\"start\", None) is not None:\n            params[\"start\"] = str(kwargs.get(\"start\"))\n        path = f\"/batches/{batchId}/files\"\n        res = self.connector.getData(\n            self.endpoint + path, params=params, verbose=verbose\n        )\n        try:\n            return res[\"data\"]\n        except:\n            return res\n\n    def getBatchFailed(\n        self, batchId: str = None, path: str = None, verbose: bool = False, **kwargs\n    ) -> list:\n        \"\"\"\n        Lists all the dataset files under a failed batch.\n        Arguments:\n            batchId : REQUIRED : The batch ID to look for.\n            path : OPTIONAL : The full name of the file. The contents of the file would be downloaded if this parameter is provided.\n                For example: path=profiles.csv\n        Possible kwargs:\n            limit : A paging parameter to specify number of results per page.\n            start : A paging parameter to specify start of new page. For example: page=1\n        \"\"\"\n        if batchId is None:\n            raise ValueError(\"Require a batchId to be specified.\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getBatchFailed\")\n        params = {}\n        if kwargs.get(\"limit\", None) is not None:\n            params[\"limit\"] = str(kwargs.get(\"limit\"))\n        if kwargs.get(\"start\", None) is not None:\n            params[\"start\"] = str(kwargs.get(\"start\"))\n        if path is not None:\n            params[\"path\"] = path\n        pathEndpoint = f\"/batches/{batchId}/failed\"\n        res = self.connector.getData(\n            self.endpoint + pathEndpoint, params=params, verbose=verbose\n        )\n        try:\n            return res[\"data\"]\n        except:\n            return res\n\n    def getBatchMeta(self, batchId: str = None, path: str = None, **kwargs) -> dict:\n        \"\"\"\n        Lists files under a batch\u2019s meta directory or download a specific file under it. The files under a batch\u2019s meta directory may include the following:\n            row_errors: A directory containing 0 or more files with parsing, conversion, and/or validation errors found at the row level.\n            input_files: A directory containing metadata for 1 or more input files submitted with the batch.\n            row_errors_sample.json: A root level file containing the sampled set of row errors for the UX.\n        Arguments:\n            batchId : REQUIRED : The batch ID to look for.\n            path : OPTIONAL : The full name of the file. The contents of the file would be downloaded if this parameter is provided.\n                Possible values for this query include the following:\n                    row_errors\n                    input_files\n                    row_errors_sample.json\n        Possible kwargs:\n            limit : A paging parameter to specify number of results per page.\n            start : A paging parameter to specify start of new page. For example: page=1\n        \"\"\"\n        if batchId is None:\n            raise ValueError(\"Require a batchId to be specified.\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getBatchMeta\")\n        params = {}\n        if kwargs.get(\"limit\", None) is not None:\n            params[\"limit\"] = str(kwargs.get(\"limit\"))\n        if kwargs.get(\"start\", None) is not None:\n            params[\"start\"] = str(kwargs.get(\"start\"))\n        if path is not None:\n            params[\"path\"] = path\n        pathEndpoint = f\"/batches/{batchId}/meta\"\n        res = self.connector.getData(\n            self.endpoint + pathEndpoint, headers=self.header, params=params\n        )\n        return res\n\n    def getHeadFile(\n        self,\n        dataSetFileId: str = None,\n        path: str = None,\n        verbose: bool = False,\n    ) -> dict:\n        \"\"\"\n        Get headers regarding a file.\n        Arguments:\n            dataSetFileId : REQURED : The ID of the dataset file you are retrieving.\n            path : REQUIRED : The full name of the file identified.\n                For example: path=profiles.csv\n        \"\"\"\n        if dataSetFileId is None or path is None:\n            raise ValueError(\"Require a dataSetFileId and a path for that method\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getHeadFile\")\n        params = {\"path\": path}\n        pathEndpoint = f\"/files/{dataSetFileId}\"\n        res = self.connector.headData(\n            self.endpoint + pathEndpoint, params=params, verbose=verbose\n        )\n        return res\n\n    def getFiles(\n        self,\n        dataSetFileId: str = None,\n        path: str = None,\n        range: str = None,\n        start: str = None,\n        limit: int = None,\n    ) -> Union[dict,bytes]:\n        \"\"\"\n        Returns either a complete file or a directory of chunked data that makes up the file.\n        The response contains a data array that may contain a single entry or a list of files belonging to that directory.\n        Arguments:\n            dataSetFileId : REQUIRED : The ID of the dataset file you are retrieving.\n            path : OPTIONAL : The full name of the file. The contents of the file would be downloaded if this parameter is provided.\n                For example: path=profiles.csv\n                if the extension is .parquet, it will try to return the parquet data decoded (io.BytesIO). \n            range : OPTIONAL : The range of bytes requested. For example: Range: bytes=0-100000\n            start : OPTIONAL : A paging parameter to specify start of new page. For example: start=fileName.csv\n            limit : OPTIONAL : A paging parameter to specify number of results per page. For example: limit=10\n        \"\"\"\n        if dataSetFileId is None:\n            raise ValueError(\"Require a dataSetFileId\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getFiles\")\n        params = {}\n        if path is not None:\n            params[\"path\"] = path\n        if range is not None:\n            params[\"range\"] = range\n        if start is not None:\n            params[\"start\"] = start\n        if limit is not None:\n            params[\"limit\"] = limit\n        pathEndpoint = f\"/files/{dataSetFileId}\"\n        if path is None:\n            res: dict = self.connector.getData(\n                self.endpoint + pathEndpoint, headers=self.header, params=params\n            )\n        else:\n            if path.endswith('.parquet'):\n                data = self.getResource(self.endpoint + pathEndpoint,params={\"path\":path},format='raw')\n                res = io.BytesIO(data.content)\n            else:\n                data = self.getResource(self.endpoint + pathEndpoint,params={\"path\":path},format='raw')\n                res = data.content\n        return res\n\n    def getPreview(self, datasetId: str = None) -> list:\n        \"\"\"\n        Give a preview of a specific dataset\n        Arguments:\n            datasetId : REQUIRED : the dataset ID to preview\n        \"\"\"\n        if datasetId is None:\n            raise ValueError(\"Require a datasetId\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getPreview\")\n        path = f\"/datasets/{datasetId}/preview\"\n        res: dict = self.connector.getData(self.endpoint + path, headers=self.header)\n        try:\n            return res[\"data\"]\n        except:\n            return res\n\n    def getResource(\n        self,\n        endpoint: str = None,\n        params: dict = None,\n        format: str = \"json\",\n        save: bool = False,\n        **kwargs,\n    ) -> dict:\n        \"\"\"\n        Template for requesting data with a GET method.\n        Arguments:\n            endpoint : REQUIRED : The URL to GET\n            params: OPTIONAL : dictionary of the params to fetch\n            format : OPTIONAL : Type of response returned. Possible values:\n                json : default\n                txt : text file\n                raw : a response object from the requests module\n        \"\"\"\n        if endpoint is None:\n            raise ValueError(\"Require an endpoint\")\n        if self.loggingEnabled:\n            self.logger.debug(\n                f\"Using getResource with following format ({format}) to the following endpoint: {endpoint}\"\n            )\n        res = self.connector.getData(endpoint, params=params, format=format)\n        if save:\n            if format == \"json\":\n                aepp.saveFile(\n                    module=\"catalog\",\n                    file=res,\n                    filename=f\"resource_{int(time.time())}\",\n                    type_file=\"json\",\n                    encoding=kwargs.get(\"encoding\", \"utf-8\"),\n                )\n            elif format == \"txt\":\n                aepp.saveFile(\n                    module=\"catalog\",\n                    file=res,\n                    filename=f\"resource_{int(time.time())}\",\n                    type_file=\"txt\",\n                    encoding=kwargs.get(\"encoding\", \"utf-8\"),\n                )\n            else:\n                print(\n                    \"element is an object. Output is unclear. No save made.\\nPlease save this element manually\"\n                )\n        return res", ""]}
{"filename": "aepp/policy.py", "chunked_list": ["#  Copyright 2023 Adobe. All rights reserved.\n#  This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License. You may obtain a copy\n#  of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software distributed under\n#  the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n#  OF ANY KIND, either express or implied. See the License for the specific language\n#  governing permissions and limitations under the License.\n", "#  governing permissions and limitations under the License.\n\nimport aepp\nimport typing\nfrom aepp import connector\nimport logging\nfrom .configs import ConnectObject\n\nclass Policy:\n    \"\"\"\n    Class to manage and retrieve DULE policy.\n    This is based on the following API reference : https://www.adobe.io/apis/experienceplatform/home/api-reference.html#/\n    \"\"\"\n\n    ## logging capability\n    loggingEnabled = False\n    logger = None\n\n    def __init__(\n        self,\n        config: typing.Union[dict,ConnectObject] = aepp.config.config_object,\n        header: dict = aepp.config.header,\n        loggingObject: dict = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Instantiate the class to manage DULE rules and statement directly.\n        Arguments:\n            config : OPTIONAL : config object in the config module. (DO NOT MODIFY)\n            header : OPTIONAL : header object  in the config module. (DO NOT MODIFY)\n            loggingObject : OPTIONAL : logging object to log messages.\n        \"\"\"\n        if loggingObject is not None and sorted(\n            [\"level\", \"stream\", \"format\", \"filename\", \"file\"]\n        ) == sorted(list(loggingObject.keys())):\n            self.loggingEnabled = True\n            self.logger = logging.getLogger(f\"{__name__}\")\n            self.logger.setLevel(loggingObject[\"level\"])\n            if type(loggingObject[\"format\"]) == str:\n                formatter = logging.Formatter(loggingObject[\"format\"])\n            elif type(loggingObject[\"format\"]) == logging.Formatter:\n                formatter = loggingObject[\"format\"]\n            if loggingObject[\"file\"]:\n                fileHandler = logging.FileHandler(loggingObject[\"filename\"])\n                fileHandler.setFormatter(formatter)\n                self.logger.addHandler(fileHandler)\n            if loggingObject[\"stream\"]:\n                streamHandler = logging.StreamHandler()\n                streamHandler.setFormatter(formatter)\n                self.logger.addHandler(streamHandler)\n        if type(config) == dict: ## Supporting either default setup or passing a ConnectObject\n            config = config\n        elif type(config) == ConnectObject:\n            header = config.getConfigHeader()\n            config = config.getConfigObject()\n        self.connector = connector.AdobeRequest(\n            config=config,\n            header=header,\n            loggingEnabled=self.loggingEnabled,\n            loggingObject=self.logger,\n        )\n        self.header = self.connector.header\n        self.header.update(**kwargs)\n        if kwargs.get('sandbox',None) is not None: ## supporting sandbox setup on class instanciation\n            self.sandbox = kwargs.get('sandbox')\n            self.connector.config[\"sandbox\"] = kwargs.get('sandbox')\n            self.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n            self.connector.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n        else:\n            self.sandbox = self.connector.config[\"sandbox\"]\n        self.endpoint = (\n            aepp.config.endpoints[\"global\"] + aepp.config.endpoints[\"policy\"]\n        )\n\n    def getEnabledCorePolicies(self) -> dict:\n        \"\"\"\n        Retrieve a list of all enabled core policies.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getEnabledCorePolicies\")\n        path = \"/enabledCorePolicies\"\n        res = self.connector.getData(self.endpoint + path)\n        return res\n\n    def createEnabledCorePolicies(self, policyIds: list) -> dict:\n        \"\"\"\n        Create or update the list of enabled core policies. (PUT)\n        Argument:\n            policyIds : REQUIRED : list of core policy ID to enable\n        \"\"\"\n        path = \"/enabledCorePolicies\"\n        if policyIds is None or type(policyIds) != list:\n            raise ValueError(\"Require a list of policy ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createEnabledCorePolicies\")\n        obj = policyIds\n        res = self.connector.putData(self.endpoint + path, data=obj)\n        return res\n\n    def bulkEval(self, data: dict = None) -> dict:\n        \"\"\"\n        Enable to pass a list of policies to check against a list of dataSet.\n        Argument:\n            data : REQUIRED : Dictionary describing the set of label and datasets.\n                see https://www.adobe.io/apis/experienceplatform/home/api-reference.html#/Bulk_evaluation/bulkEvalPost\n        \"\"\"\n        path = \"/bulk-eval\"\n        if data is None:\n            raise Exception(\n                \"Requires a dictionary to set the labels and dataSets to check\"\n            )\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting bulkEval\")\n        res = self.connector.postData(self.endpoint + path, data=data)\n        return res\n\n    def getPoliciesCore(self, **kwargs) -> dict:\n        \"\"\"\n        Returns the core policies in place in the Organization.\n        Possible kwargs:\n            limit : A positive integer, providing a hint as to the maximum number of resources to return in one page of results.\n            property : Filter responses based on a property and optional existence or relational values.\n            Only the \u2018name\u2019 property is supported for core resources.\n            For custom resources, additional supported property values include 'status\u2019, 'created\u2019, 'createdClient\u2019, 'createdUser\u2019, 'updated\u2019, 'updatedClient\u2019, and 'updatedUser\u2019\n            orderby : A comma-separated list of properties by which the returned list of resources will be sorted.\n            start : Requests items whose \u2018orderby\u2019 property value are strictly greater than the supplied \u2018start\u2019 value.\n            duleLabels : A comma-separated list of DULE labels. Return only those policies whose \"deny\" expression references any of the labels in this list\n            marketingAction : Restrict returned policies to those that reference the given marketing action.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getPoliciesCore\")\n        path = \"/policies/core\"\n        params = {**kwargs}\n        res = self.connector.getData(\n            self.endpoint + path, params=params, headers=self.header\n        )\n        return res\n\n    def getPoliciesCoreId(self, policy_id: str = None):\n        \"\"\"\n        Return a specific core policy by its id.\n        Arguments:\n            policy_id : REQUIRED : policy_id to retrieve.\n        \"\"\"\n        if policy_id is None:\n            raise Exception(\"Expected a policy id\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getPoliciesCoreId\")\n        path = f\"/policies/core/{policy_id}\"\n        res = self.connector.getData(self.endpoint + path, headers=self.header)\n        return res\n\n    def getPoliciesCustoms(self, **kwargs):\n        \"\"\"\n        Returns the custom policies in place in the Organization.\n        Possible kwargs:\n            limit : A positive integer, providing a hint as to the maximum number of resources to return in one page of results.\n            property : Filter responses based on a property and optional existence or relational values.\n            Only the \u2018name\u2019 property is supported for core resources.\n            For custom resources, additional supported property values include 'status\u2019, 'created\u2019, 'createdClient\u2019, 'createdUser\u2019, 'updated\u2019, 'updatedClient\u2019, and 'updatedUser\u2019\n            orderby : A comma-separated list of properties by which the returned list of resources will be sorted.\n            start : Requests items whose \u2018orderby\u2019 property value are strictly greater than the supplied \u2018start\u2019 value.\n            duleLabels : A comma-separated list of DULE labels. Return only those policies whose \"deny\" expression references any of the labels in this list\n            marketingAction : Restrict returned policies to those that reference the given marketing action.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getPoliciesCustoms\")\n        path = \"/policies/custom\"\n        params = {**kwargs}\n        res = self.connector.getData(\n            self.endpoint + path, params=params, headers=self.header\n        )\n        return res\n\n    def getPoliciesCustom(self, policy_id: str = None):\n        \"\"\"\n        Return a specific custom policy by its id.\n        Arguments:\n            policy_id: REQUIRED: policy_id to retrieve.\n        \"\"\"\n        if policy_id is None:\n            raise Exception(\"Expected a policy id\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getPoliciesCustom\")\n        path = f\"/policies/custom/{policy_id}\"\n        res = self.connector.getData(self.endpoint + path, headers=self.header)\n        return res\n\n    def createPolicy(self, policy: typing.Union(dict, typing.IO) = None):\n        \"\"\"\n        Create a custom policy.\n        Arguments:\n            policy : REQUIRED : A dictionary contaning the policy you would like to implement.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createPolicy\")\n        path = \"/policies/custom\"\n        res = self.connector.postData(self.endpoint + path, data=policy)\n        return res\n\n    def getCoreLabels(self, prop: str = None, limit: int = 100) -> list:\n        \"\"\"\n        Retrieve a list of core labels.\n        Arguments:\n            prop : OPTIONAL : Filters responses based on whether a specific property exists, or whose value passes a conditional expression\n                Example: prop=\"name==C1\".\n                Only the \u201cname\u201d property is supported for core resources.\n            limit : OPTIONAL : number of results to be returned. Default 100\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getCoreLabels\")\n        params = {\"limit\": limit}\n        if prop is not None:\n            params[\"property\"] = prop\n        path = \"/labels/core\"\n        res = self.connector.getData(\n            self.endpoint + path, params=params, headers=self.header\n        )\n        data = res[\"children\"]\n        nextPage = res[\"_links\"][\"page\"].get(\"href\", \"\")\n        while nextPage != \"\":\n            params[\"start\"] = nextPage\n            res = self.connector.getData(\n                self.endpoint + path, params=params, headers=self.header\n            )\n            data += res[\"children\"]\n            nextPage = res[\"_links\"][\"page\"].get(\"href\", \"\")\n        return data\n\n    def getCoreLabel(self, labelName: str = None) -> dict:\n        \"\"\"\n        Returns a specific Label by its name.\n        Argument:\n            labelName : REQUIRED : The name of the core label.\n        \"\"\"\n        if labelName is None:\n            raise ValueError(\"Require a label name\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getCoreLabel\")\n        path = f\"/labels/core/{labelName}\"\n        res = self.connector.getData(self.endpoint + path)\n        return res\n\n    def getCustomLabels(self, prop: str = None, limit: int = 100) -> list:\n        \"\"\"\n        Retrieve a list of custom labels.\n        Arguments:\n            prop : OPTIONAL : Filters responses based on whether a specific property exists, or whose value passes a conditional expression\n                Example: prop=\"name==C1\".\n                Property values include \"status\", \"created\", \"createdClient\", \"createdUser\", \"updated\", \"updatedClient\", and \"updatedUser\".\n            limit : OPTIONAL : number of results to be returned. Default 100\n        \"\"\"\n        params = {\"limit\": limit}\n        if prop is not None:\n            params[\"property\"] = prop\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getCustomLabels\")\n        path = \"/labels/custom\"\n        res = self.connector.getData(\n            self.endpoint + path, params=params, headers=self.header\n        )\n        data = res[\"children\"]\n        nextPage = res[\"_links\"][\"page\"].get(\"href\", \"\")\n        while nextPage != \"\":\n            params[\"start\"] = nextPage\n            res = self.connector.getData(\n                self.endpoint + path, params=params, headers=self.header\n            )\n            data += res[\"children\"]\n            nextPage = res[\"_links\"][\"page\"].get(\"href\", \"\")\n        return data\n\n    def getCustomLabel(self, labelName: str = None) -> dict:\n        \"\"\"\n        Returns a specific Label by its name.\n        Argument:\n            labelName : REQUIRED : The name of the custom label.\n        \"\"\"\n        if labelName is None:\n            raise ValueError(\"Require a label name\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getCustomLabel\")\n        path = f\"/labels/custom/{labelName}\"\n        res = self.connector.getData(self.endpoint + path)\n        return res\n\n    def updateCustomLabel(self, labelName: str = None, data: dict = None) -> dict:\n        \"\"\"\n        Update a specific Label by its name. (PUT method)\n        Argument:\n            labelName : REQUIRED : The name of the custom label.\n            data : REQUIRED : Data to replace the old definition\n                Example:\n                {\n                    \"name\": \"L2\",\n                    \"category\": \"Custom\",\n                    \"friendlyName\": \"Purchase History Data\",\n                    \"description\": \"Data containing information on past transactions\"\n                }\n        \"\"\"\n        if labelName is None:\n            raise ValueError(\"Require a label name\")\n        if data is None or type(data) != dict:\n            raise ValueError(\"Require a dictionary data to be passed\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting updateCustomLabel\")\n        path = f\"/labels/custom/{labelName}\"\n        res = self.connector.putData(self.endpoint + path, data=data)\n        return res\n\n    def getMarketingActionsCores(\n        self, prop: str = None, limit: int = 10, **kwargs\n    ) -> list:\n        \"\"\"\n        Retrieve a list of core marketing actions.\n        Arguments:\n            prop : OPTIONAL : Filters responses based on whether a specific property exists, or whose value passes a conditional expression (e.g. \"prop=name==C1\").\n            Only the \u201cname\u201d property is supported for core resources.\n            limit : OPTIONAL : number of results to be returned.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getMarketingActionsCores\")\n        path = \"/marketingActions/core\"\n        params = {\"limit\": limit}\n        if prop is not None:\n            params[\"property\"] = prop\n        res = self.connector.getData(self.endpoint + path, params=params)\n        data = res[\"children\"]\n        nextPage = res[\"_links\"][\"page\"].get(\"href\", \"\")\n        while nextPage != \"\":\n            params[\"start\"] = nextPage\n            res = self.connector.getData(self.endpoint + path, params=params)\n            data += res[\"children\"]\n            nextPage = res[\"_links\"][\"page\"].get(\"href\", \"\")\n        return data\n    \n    def getMarketingActionsCore(self, mktActionName:str=None)->dict:\n        \"\"\"\n        Get a specific marketing action core by marketing Action Name.\n        Arguments:\n            mktActionName : REQUIRED : The marketing action name to be provided.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getMarketingActionsCore\")\n        if mktActionName is None:\n            raise ValueError(\"Must provide a Marketing Action Name\")\n        path = f\"/marketingActions/core/{mktActionName}\"\n        data = self.connector.getData(self.endpoint+path)\n        return data\n\n    def getCustomMarketingActions(self,prop:str=None,limit:int=10,**kwargs)->list:\n        \"\"\"\n        Retrieve a list of custom Marketing Actions\n        Arguments:\n            prop : OPTIONAL : Filters responses based on whether a specific property exists, or whose value passes a conditional expression (e.g. ?property=name==C1). Only the name property is supported for core resources. \n                For custom resources, additional supported property values include \"status\", \"created\", \"createdClient\", \"createdUser\", \"updated\", \"updatedClient\", and \"updatedUser\"\n        Possible kwargs:\n            orderby : A comma-separated list of properties by which the returned list of resources will be sorted.\n            start : Indicates the pagination value for the returned list. This value should be obtained from a previous call's _page.next property. Should be omitted for a first page of results.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getCustomMarketingActions\")\n        params = {\"limit\" : limit}\n        if prop is not None:\n            params[\"property\"] = prop\n        if kwargs.get('orderby',None) is not None:\n            params[\"orderby\"] = kwargs.get('orderby')\n        if kwargs.get('start',None) is not None:\n            params['start'] = kwargs.get('start')\n        path = f\"/marketingActions/custom\"\n        res = self.connector.getData(self.endpoint + path,params = params)\n        data = res['children']\n        nextPage = res.get(\"_page\",{}).get('next','')\n        while nextPage!= \"\":\n            params['start'] = nextPage\n            res = self.connector.getData(self.endpoint + path,params = params)\n            data += res['children']\n            nextPage = res.get(\"_page\",{}).get('next','')\n        return data\n    \n    def getCustomMarketingAction(self,mktActionName:str=None)->dict:\n        \"\"\"\n        Return a specific marketing action\n        Arguments:\n            mktActionName : REQUIRED : The marketing action name to be returned.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getCustomMarketingAction\")\n        if mktActionName is None:\n            raise ValueError(\"Require a custom marketing action name\")\n        path = f\"/marketingActions/custom/{mktActionName}\"\n        data = self.connector.getData(self.endpoint+path)\n        return data\n    \n    def createOrupdateCustomMarketingAction(self,name:str=None,description:str=\"\")->dict:\n        \"\"\"\n        Create or update a custom marketing action based on the parameter provided.\n        Arguments:\n            name : REQUIRED : The name of the custom marketing action\n            description : OPTIONAL : the description for that custom marketing action.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createOrupdateCustomMarketingAction\")\n        if name is None:\n            raise ValueError(\"Require a name for your custom marketing action\")\n        path = f\"/marketingActions/custom/{name}\"\n        data = {\n            \"name\":name,\n            \"description\" : description\n        }\n        res = self.connector.putData(self.endpoint+path,data=data)\n        return res\n    \n    def deleteCustomMarketingAction(self,mktActionName:str=None)->dict:\n        \"\"\"\n        Delete a specific custom Marketing action\n        Arguments:\n            mktActionName : REQUIRED : The marketing action name to be deleted.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteCustomMarketingAction\")\n        if mktActionName is None:\n            raise ValueError(\"Require a marketing action name to be deleted\")\n        path = f\"/marketingActions/custom/{mktActionName}\"\n        res = self.connector.deleteData(self.endpoint+path)\n        return res\n    \n    def evaluateMarketingActionDataset(self,\n                                typeMktAction:str=\"core\",\n                                mktActionName:str=None,\n                                entityType:str=\"dataSet\",\n                                entityId:str=None,\n                                entityMeta:list=None,\n                                draftEvaluation:bool=False,\n                                )->dict:\n        \"\"\"\n        Evaluate either Marketing Action core or custom based on parameter again some field on a datasetId.\n        Arguments\n            typeMktAction : REQUIRED : Default to \"core\", can be \"custom\"\n            mktActionName : REQUIRED : The name of the marketing action to be evaluated\n            entityType : REQUIRED : The type of entity to be tested against. Usually \"dataSet\", so set as default.\n            entityId : REQUIRED : The Id of the entity to be tested.\n            entityMeta : REQUIRED : A list of field to be tested for the marketing action in case of a dataset.\n            draftEvaluation : OPTIONAL : If true, the system checks for policy violations among policies with DRAFT status as well as ENABLED status. Otherwise, only ENABLED policies are checked.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting evaluateMarketingActionDataset\")\n        if typeMktAction is None:\n            raise ValueError(\"Should have typeMktAction defined. Either 'core' or 'custom'\")\n        if mktActionName is None:\n            raise ValueError(\"Should have mktActionName defined.\")\n        if entityType is None:\n            raise ValueError(\"Should have entityType defined.\")\n        if entityId is None:\n            raise ValueError(\"Should have entityId defined.\")\n        params = {}\n        path = f\"/marketingActions/{typeMktAction}/{mktActionName}/constraints\"\n        data = [\n                    {\n                    \"entityType\": entityType,\n                    \"entityId\": entityId,\n                    }\n                ]\n        if entityMeta is not None:\n            data[0]['entityMeta']={\"fields\":entityMeta}\n        if draftEvaluation:\n            params[\"includeDraft\"] = True\n        res = self.connector.postData(self.endpoint+path,data=data)\n        return res\n    \n    def evaluateMarketingActionUsageLabel(self,\n                                          typeMktAction:str='core',\n                                          mktActionName:str=None,\n                                          duleLabels:str=None,\n                                          draftEvaluation:bool=False\n                                          )->dict:\n        \"\"\"\n        This call returns a set of constraints that would govern an attempt to perform the given marketing action on a hypothetical source of data containing specific data usage labels.\n        Arguments:\n            typeMktAction : REQUIRED : Default to \"core\", can be \"custom\"\n            mktActionName : REQUIRED : The name of the marketing action to be evaluated\n            duleLabels : REQUIRED: A comma-separated list of data usage labels that would be present on data that you want to test for policy violations.\n            draftEvaluation : OPTIONAL : If true, the system checks for policy violations among policies with DRAFT status as well as ENABLED status. Otherwise, only ENABLED policies are checked.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting evaluateMarketingActionDataset\")\n        if typeMktAction is None:\n            raise ValueError(\"Should have typeMktAction defined. Either 'core' or 'custom'\")\n        if mktActionName is None:\n            raise ValueError(\"Should have mktActionName defined.\")\n        if duleLabels is None:\n            raise ValueError(\"Should have duleLabels defined.\")\n        path = f\"marketingActions/{typeMktAction}/{mktActionName}/constraints\"\n        params = {\"duleLabels\":duleLabels}\n        if draftEvaluation:\n            params['includeDraft'] = draftEvaluation\n        res = self.connector.getData(self.endpoint+path,params=params)\n        return res", "class Policy:\n    \"\"\"\n    Class to manage and retrieve DULE policy.\n    This is based on the following API reference : https://www.adobe.io/apis/experienceplatform/home/api-reference.html#/\n    \"\"\"\n\n    ## logging capability\n    loggingEnabled = False\n    logger = None\n\n    def __init__(\n        self,\n        config: typing.Union[dict,ConnectObject] = aepp.config.config_object,\n        header: dict = aepp.config.header,\n        loggingObject: dict = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Instantiate the class to manage DULE rules and statement directly.\n        Arguments:\n            config : OPTIONAL : config object in the config module. (DO NOT MODIFY)\n            header : OPTIONAL : header object  in the config module. (DO NOT MODIFY)\n            loggingObject : OPTIONAL : logging object to log messages.\n        \"\"\"\n        if loggingObject is not None and sorted(\n            [\"level\", \"stream\", \"format\", \"filename\", \"file\"]\n        ) == sorted(list(loggingObject.keys())):\n            self.loggingEnabled = True\n            self.logger = logging.getLogger(f\"{__name__}\")\n            self.logger.setLevel(loggingObject[\"level\"])\n            if type(loggingObject[\"format\"]) == str:\n                formatter = logging.Formatter(loggingObject[\"format\"])\n            elif type(loggingObject[\"format\"]) == logging.Formatter:\n                formatter = loggingObject[\"format\"]\n            if loggingObject[\"file\"]:\n                fileHandler = logging.FileHandler(loggingObject[\"filename\"])\n                fileHandler.setFormatter(formatter)\n                self.logger.addHandler(fileHandler)\n            if loggingObject[\"stream\"]:\n                streamHandler = logging.StreamHandler()\n                streamHandler.setFormatter(formatter)\n                self.logger.addHandler(streamHandler)\n        if type(config) == dict: ## Supporting either default setup or passing a ConnectObject\n            config = config\n        elif type(config) == ConnectObject:\n            header = config.getConfigHeader()\n            config = config.getConfigObject()\n        self.connector = connector.AdobeRequest(\n            config=config,\n            header=header,\n            loggingEnabled=self.loggingEnabled,\n            loggingObject=self.logger,\n        )\n        self.header = self.connector.header\n        self.header.update(**kwargs)\n        if kwargs.get('sandbox',None) is not None: ## supporting sandbox setup on class instanciation\n            self.sandbox = kwargs.get('sandbox')\n            self.connector.config[\"sandbox\"] = kwargs.get('sandbox')\n            self.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n            self.connector.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n        else:\n            self.sandbox = self.connector.config[\"sandbox\"]\n        self.endpoint = (\n            aepp.config.endpoints[\"global\"] + aepp.config.endpoints[\"policy\"]\n        )\n\n    def getEnabledCorePolicies(self) -> dict:\n        \"\"\"\n        Retrieve a list of all enabled core policies.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getEnabledCorePolicies\")\n        path = \"/enabledCorePolicies\"\n        res = self.connector.getData(self.endpoint + path)\n        return res\n\n    def createEnabledCorePolicies(self, policyIds: list) -> dict:\n        \"\"\"\n        Create or update the list of enabled core policies. (PUT)\n        Argument:\n            policyIds : REQUIRED : list of core policy ID to enable\n        \"\"\"\n        path = \"/enabledCorePolicies\"\n        if policyIds is None or type(policyIds) != list:\n            raise ValueError(\"Require a list of policy ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createEnabledCorePolicies\")\n        obj = policyIds\n        res = self.connector.putData(self.endpoint + path, data=obj)\n        return res\n\n    def bulkEval(self, data: dict = None) -> dict:\n        \"\"\"\n        Enable to pass a list of policies to check against a list of dataSet.\n        Argument:\n            data : REQUIRED : Dictionary describing the set of label and datasets.\n                see https://www.adobe.io/apis/experienceplatform/home/api-reference.html#/Bulk_evaluation/bulkEvalPost\n        \"\"\"\n        path = \"/bulk-eval\"\n        if data is None:\n            raise Exception(\n                \"Requires a dictionary to set the labels and dataSets to check\"\n            )\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting bulkEval\")\n        res = self.connector.postData(self.endpoint + path, data=data)\n        return res\n\n    def getPoliciesCore(self, **kwargs) -> dict:\n        \"\"\"\n        Returns the core policies in place in the Organization.\n        Possible kwargs:\n            limit : A positive integer, providing a hint as to the maximum number of resources to return in one page of results.\n            property : Filter responses based on a property and optional existence or relational values.\n            Only the \u2018name\u2019 property is supported for core resources.\n            For custom resources, additional supported property values include 'status\u2019, 'created\u2019, 'createdClient\u2019, 'createdUser\u2019, 'updated\u2019, 'updatedClient\u2019, and 'updatedUser\u2019\n            orderby : A comma-separated list of properties by which the returned list of resources will be sorted.\n            start : Requests items whose \u2018orderby\u2019 property value are strictly greater than the supplied \u2018start\u2019 value.\n            duleLabels : A comma-separated list of DULE labels. Return only those policies whose \"deny\" expression references any of the labels in this list\n            marketingAction : Restrict returned policies to those that reference the given marketing action.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getPoliciesCore\")\n        path = \"/policies/core\"\n        params = {**kwargs}\n        res = self.connector.getData(\n            self.endpoint + path, params=params, headers=self.header\n        )\n        return res\n\n    def getPoliciesCoreId(self, policy_id: str = None):\n        \"\"\"\n        Return a specific core policy by its id.\n        Arguments:\n            policy_id : REQUIRED : policy_id to retrieve.\n        \"\"\"\n        if policy_id is None:\n            raise Exception(\"Expected a policy id\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getPoliciesCoreId\")\n        path = f\"/policies/core/{policy_id}\"\n        res = self.connector.getData(self.endpoint + path, headers=self.header)\n        return res\n\n    def getPoliciesCustoms(self, **kwargs):\n        \"\"\"\n        Returns the custom policies in place in the Organization.\n        Possible kwargs:\n            limit : A positive integer, providing a hint as to the maximum number of resources to return in one page of results.\n            property : Filter responses based on a property and optional existence or relational values.\n            Only the \u2018name\u2019 property is supported for core resources.\n            For custom resources, additional supported property values include 'status\u2019, 'created\u2019, 'createdClient\u2019, 'createdUser\u2019, 'updated\u2019, 'updatedClient\u2019, and 'updatedUser\u2019\n            orderby : A comma-separated list of properties by which the returned list of resources will be sorted.\n            start : Requests items whose \u2018orderby\u2019 property value are strictly greater than the supplied \u2018start\u2019 value.\n            duleLabels : A comma-separated list of DULE labels. Return only those policies whose \"deny\" expression references any of the labels in this list\n            marketingAction : Restrict returned policies to those that reference the given marketing action.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getPoliciesCustoms\")\n        path = \"/policies/custom\"\n        params = {**kwargs}\n        res = self.connector.getData(\n            self.endpoint + path, params=params, headers=self.header\n        )\n        return res\n\n    def getPoliciesCustom(self, policy_id: str = None):\n        \"\"\"\n        Return a specific custom policy by its id.\n        Arguments:\n            policy_id: REQUIRED: policy_id to retrieve.\n        \"\"\"\n        if policy_id is None:\n            raise Exception(\"Expected a policy id\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getPoliciesCustom\")\n        path = f\"/policies/custom/{policy_id}\"\n        res = self.connector.getData(self.endpoint + path, headers=self.header)\n        return res\n\n    def createPolicy(self, policy: typing.Union(dict, typing.IO) = None):\n        \"\"\"\n        Create a custom policy.\n        Arguments:\n            policy : REQUIRED : A dictionary contaning the policy you would like to implement.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createPolicy\")\n        path = \"/policies/custom\"\n        res = self.connector.postData(self.endpoint + path, data=policy)\n        return res\n\n    def getCoreLabels(self, prop: str = None, limit: int = 100) -> list:\n        \"\"\"\n        Retrieve a list of core labels.\n        Arguments:\n            prop : OPTIONAL : Filters responses based on whether a specific property exists, or whose value passes a conditional expression\n                Example: prop=\"name==C1\".\n                Only the \u201cname\u201d property is supported for core resources.\n            limit : OPTIONAL : number of results to be returned. Default 100\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getCoreLabels\")\n        params = {\"limit\": limit}\n        if prop is not None:\n            params[\"property\"] = prop\n        path = \"/labels/core\"\n        res = self.connector.getData(\n            self.endpoint + path, params=params, headers=self.header\n        )\n        data = res[\"children\"]\n        nextPage = res[\"_links\"][\"page\"].get(\"href\", \"\")\n        while nextPage != \"\":\n            params[\"start\"] = nextPage\n            res = self.connector.getData(\n                self.endpoint + path, params=params, headers=self.header\n            )\n            data += res[\"children\"]\n            nextPage = res[\"_links\"][\"page\"].get(\"href\", \"\")\n        return data\n\n    def getCoreLabel(self, labelName: str = None) -> dict:\n        \"\"\"\n        Returns a specific Label by its name.\n        Argument:\n            labelName : REQUIRED : The name of the core label.\n        \"\"\"\n        if labelName is None:\n            raise ValueError(\"Require a label name\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getCoreLabel\")\n        path = f\"/labels/core/{labelName}\"\n        res = self.connector.getData(self.endpoint + path)\n        return res\n\n    def getCustomLabels(self, prop: str = None, limit: int = 100) -> list:\n        \"\"\"\n        Retrieve a list of custom labels.\n        Arguments:\n            prop : OPTIONAL : Filters responses based on whether a specific property exists, or whose value passes a conditional expression\n                Example: prop=\"name==C1\".\n                Property values include \"status\", \"created\", \"createdClient\", \"createdUser\", \"updated\", \"updatedClient\", and \"updatedUser\".\n            limit : OPTIONAL : number of results to be returned. Default 100\n        \"\"\"\n        params = {\"limit\": limit}\n        if prop is not None:\n            params[\"property\"] = prop\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getCustomLabels\")\n        path = \"/labels/custom\"\n        res = self.connector.getData(\n            self.endpoint + path, params=params, headers=self.header\n        )\n        data = res[\"children\"]\n        nextPage = res[\"_links\"][\"page\"].get(\"href\", \"\")\n        while nextPage != \"\":\n            params[\"start\"] = nextPage\n            res = self.connector.getData(\n                self.endpoint + path, params=params, headers=self.header\n            )\n            data += res[\"children\"]\n            nextPage = res[\"_links\"][\"page\"].get(\"href\", \"\")\n        return data\n\n    def getCustomLabel(self, labelName: str = None) -> dict:\n        \"\"\"\n        Returns a specific Label by its name.\n        Argument:\n            labelName : REQUIRED : The name of the custom label.\n        \"\"\"\n        if labelName is None:\n            raise ValueError(\"Require a label name\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getCustomLabel\")\n        path = f\"/labels/custom/{labelName}\"\n        res = self.connector.getData(self.endpoint + path)\n        return res\n\n    def updateCustomLabel(self, labelName: str = None, data: dict = None) -> dict:\n        \"\"\"\n        Update a specific Label by its name. (PUT method)\n        Argument:\n            labelName : REQUIRED : The name of the custom label.\n            data : REQUIRED : Data to replace the old definition\n                Example:\n                {\n                    \"name\": \"L2\",\n                    \"category\": \"Custom\",\n                    \"friendlyName\": \"Purchase History Data\",\n                    \"description\": \"Data containing information on past transactions\"\n                }\n        \"\"\"\n        if labelName is None:\n            raise ValueError(\"Require a label name\")\n        if data is None or type(data) != dict:\n            raise ValueError(\"Require a dictionary data to be passed\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting updateCustomLabel\")\n        path = f\"/labels/custom/{labelName}\"\n        res = self.connector.putData(self.endpoint + path, data=data)\n        return res\n\n    def getMarketingActionsCores(\n        self, prop: str = None, limit: int = 10, **kwargs\n    ) -> list:\n        \"\"\"\n        Retrieve a list of core marketing actions.\n        Arguments:\n            prop : OPTIONAL : Filters responses based on whether a specific property exists, or whose value passes a conditional expression (e.g. \"prop=name==C1\").\n            Only the \u201cname\u201d property is supported for core resources.\n            limit : OPTIONAL : number of results to be returned.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getMarketingActionsCores\")\n        path = \"/marketingActions/core\"\n        params = {\"limit\": limit}\n        if prop is not None:\n            params[\"property\"] = prop\n        res = self.connector.getData(self.endpoint + path, params=params)\n        data = res[\"children\"]\n        nextPage = res[\"_links\"][\"page\"].get(\"href\", \"\")\n        while nextPage != \"\":\n            params[\"start\"] = nextPage\n            res = self.connector.getData(self.endpoint + path, params=params)\n            data += res[\"children\"]\n            nextPage = res[\"_links\"][\"page\"].get(\"href\", \"\")\n        return data\n    \n    def getMarketingActionsCore(self, mktActionName:str=None)->dict:\n        \"\"\"\n        Get a specific marketing action core by marketing Action Name.\n        Arguments:\n            mktActionName : REQUIRED : The marketing action name to be provided.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getMarketingActionsCore\")\n        if mktActionName is None:\n            raise ValueError(\"Must provide a Marketing Action Name\")\n        path = f\"/marketingActions/core/{mktActionName}\"\n        data = self.connector.getData(self.endpoint+path)\n        return data\n\n    def getCustomMarketingActions(self,prop:str=None,limit:int=10,**kwargs)->list:\n        \"\"\"\n        Retrieve a list of custom Marketing Actions\n        Arguments:\n            prop : OPTIONAL : Filters responses based on whether a specific property exists, or whose value passes a conditional expression (e.g. ?property=name==C1). Only the name property is supported for core resources. \n                For custom resources, additional supported property values include \"status\", \"created\", \"createdClient\", \"createdUser\", \"updated\", \"updatedClient\", and \"updatedUser\"\n        Possible kwargs:\n            orderby : A comma-separated list of properties by which the returned list of resources will be sorted.\n            start : Indicates the pagination value for the returned list. This value should be obtained from a previous call's _page.next property. Should be omitted for a first page of results.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getCustomMarketingActions\")\n        params = {\"limit\" : limit}\n        if prop is not None:\n            params[\"property\"] = prop\n        if kwargs.get('orderby',None) is not None:\n            params[\"orderby\"] = kwargs.get('orderby')\n        if kwargs.get('start',None) is not None:\n            params['start'] = kwargs.get('start')\n        path = f\"/marketingActions/custom\"\n        res = self.connector.getData(self.endpoint + path,params = params)\n        data = res['children']\n        nextPage = res.get(\"_page\",{}).get('next','')\n        while nextPage!= \"\":\n            params['start'] = nextPage\n            res = self.connector.getData(self.endpoint + path,params = params)\n            data += res['children']\n            nextPage = res.get(\"_page\",{}).get('next','')\n        return data\n    \n    def getCustomMarketingAction(self,mktActionName:str=None)->dict:\n        \"\"\"\n        Return a specific marketing action\n        Arguments:\n            mktActionName : REQUIRED : The marketing action name to be returned.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getCustomMarketingAction\")\n        if mktActionName is None:\n            raise ValueError(\"Require a custom marketing action name\")\n        path = f\"/marketingActions/custom/{mktActionName}\"\n        data = self.connector.getData(self.endpoint+path)\n        return data\n    \n    def createOrupdateCustomMarketingAction(self,name:str=None,description:str=\"\")->dict:\n        \"\"\"\n        Create or update a custom marketing action based on the parameter provided.\n        Arguments:\n            name : REQUIRED : The name of the custom marketing action\n            description : OPTIONAL : the description for that custom marketing action.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createOrupdateCustomMarketingAction\")\n        if name is None:\n            raise ValueError(\"Require a name for your custom marketing action\")\n        path = f\"/marketingActions/custom/{name}\"\n        data = {\n            \"name\":name,\n            \"description\" : description\n        }\n        res = self.connector.putData(self.endpoint+path,data=data)\n        return res\n    \n    def deleteCustomMarketingAction(self,mktActionName:str=None)->dict:\n        \"\"\"\n        Delete a specific custom Marketing action\n        Arguments:\n            mktActionName : REQUIRED : The marketing action name to be deleted.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteCustomMarketingAction\")\n        if mktActionName is None:\n            raise ValueError(\"Require a marketing action name to be deleted\")\n        path = f\"/marketingActions/custom/{mktActionName}\"\n        res = self.connector.deleteData(self.endpoint+path)\n        return res\n    \n    def evaluateMarketingActionDataset(self,\n                                typeMktAction:str=\"core\",\n                                mktActionName:str=None,\n                                entityType:str=\"dataSet\",\n                                entityId:str=None,\n                                entityMeta:list=None,\n                                draftEvaluation:bool=False,\n                                )->dict:\n        \"\"\"\n        Evaluate either Marketing Action core or custom based on parameter again some field on a datasetId.\n        Arguments\n            typeMktAction : REQUIRED : Default to \"core\", can be \"custom\"\n            mktActionName : REQUIRED : The name of the marketing action to be evaluated\n            entityType : REQUIRED : The type of entity to be tested against. Usually \"dataSet\", so set as default.\n            entityId : REQUIRED : The Id of the entity to be tested.\n            entityMeta : REQUIRED : A list of field to be tested for the marketing action in case of a dataset.\n            draftEvaluation : OPTIONAL : If true, the system checks for policy violations among policies with DRAFT status as well as ENABLED status. Otherwise, only ENABLED policies are checked.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting evaluateMarketingActionDataset\")\n        if typeMktAction is None:\n            raise ValueError(\"Should have typeMktAction defined. Either 'core' or 'custom'\")\n        if mktActionName is None:\n            raise ValueError(\"Should have mktActionName defined.\")\n        if entityType is None:\n            raise ValueError(\"Should have entityType defined.\")\n        if entityId is None:\n            raise ValueError(\"Should have entityId defined.\")\n        params = {}\n        path = f\"/marketingActions/{typeMktAction}/{mktActionName}/constraints\"\n        data = [\n                    {\n                    \"entityType\": entityType,\n                    \"entityId\": entityId,\n                    }\n                ]\n        if entityMeta is not None:\n            data[0]['entityMeta']={\"fields\":entityMeta}\n        if draftEvaluation:\n            params[\"includeDraft\"] = True\n        res = self.connector.postData(self.endpoint+path,data=data)\n        return res\n    \n    def evaluateMarketingActionUsageLabel(self,\n                                          typeMktAction:str='core',\n                                          mktActionName:str=None,\n                                          duleLabels:str=None,\n                                          draftEvaluation:bool=False\n                                          )->dict:\n        \"\"\"\n        This call returns a set of constraints that would govern an attempt to perform the given marketing action on a hypothetical source of data containing specific data usage labels.\n        Arguments:\n            typeMktAction : REQUIRED : Default to \"core\", can be \"custom\"\n            mktActionName : REQUIRED : The name of the marketing action to be evaluated\n            duleLabels : REQUIRED: A comma-separated list of data usage labels that would be present on data that you want to test for policy violations.\n            draftEvaluation : OPTIONAL : If true, the system checks for policy violations among policies with DRAFT status as well as ENABLED status. Otherwise, only ENABLED policies are checked.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting evaluateMarketingActionDataset\")\n        if typeMktAction is None:\n            raise ValueError(\"Should have typeMktAction defined. Either 'core' or 'custom'\")\n        if mktActionName is None:\n            raise ValueError(\"Should have mktActionName defined.\")\n        if duleLabels is None:\n            raise ValueError(\"Should have duleLabels defined.\")\n        path = f\"marketingActions/{typeMktAction}/{mktActionName}/constraints\"\n        params = {\"duleLabels\":duleLabels}\n        if draftEvaluation:\n            params['includeDraft'] = draftEvaluation\n        res = self.connector.getData(self.endpoint+path,params=params)\n        return res"]}
{"filename": "aepp/config.py", "chunked_list": ["#  Copyright 2023 Adobe. All rights reserved.\n#  This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License. You may obtain a copy\n#  of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software distributed under\n#  the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n#  OF ANY KIND, either express or implied. See the License for the specific language\n#  governing permissions and limitations under the License.\n", "#  governing permissions and limitations under the License.\n\nimport aepp\n\nconfig_object = {\n    \"org_id\": \"\",\n    \"client_id\": \"\",\n    \"tech_id\": \"\",\n    \"pathToKey\": \"\",\n    \"scopes\": \"\",", "    \"pathToKey\": \"\",\n    \"scopes\": \"\",\n    \"secret\": \"\",\n    \"date_limit\": 0,\n    \"sandbox\": \"\",\n    \"environment\": \"\",\n    \"token\": \"\",\n    \"jwtTokenEndpoint\": \"\",\n    \"oauthTokenEndpointV1\": \"\",\n    \"oauthTokenEndpointV2\": \"\",", "    \"oauthTokenEndpointV1\": \"\",\n    \"oauthTokenEndpointV2\": \"\",\n    \"imsEndpoint\": \"\"\n}\n\nheader = {\"Accept\": \"application/json\",\n          \"Content-Type\": \"application/json\",\n          \"Authorization\": \"\",\n          \"x-api-key\": config_object[\"client_id\"],\n          \"x-gw-ims-org-id\": config_object[\"org_id\"],", "          \"x-api-key\": config_object[\"client_id\"],\n          \"x-gw-ims-org-id\": config_object[\"org_id\"],\n          \"x-sandbox-name\": \"prod\"\n          }\n\n# endpoints\nendpoints = {\n    # global endpoint is https://platform.adobe.io in prod, otherwise https://platform-$ENV.adobe.io\n    \"global\": \"\",\n    \"schemas\": \"/data/foundation/schemaregistry\",", "    \"global\": \"\",\n    \"schemas\": \"/data/foundation/schemaregistry\",\n    \"query\": \"/data/foundation/query\",\n    \"catalog\": \"/data/foundation/catalog\",\n    \"policy\": \"/data/foundation/dulepolicy\",\n    \"segmentation\": \"/data/core/ups\",\n    \"export\": \"/data/foundation/export\",\n    \"identity\": \"/data/core/\",\n    \"sandboxes\": \"/data/foundation/sandbox-management\",\n    \"sensei\": \"/data/sensei\",", "    \"sandboxes\": \"/data/foundation/sandbox-management\",\n    \"sensei\": \"/data/sensei\",\n    \"access\": \"/data/foundation/access-control\",\n    \"flow\": \"/data/foundation/flowservice\",\n    \"privacy\": \"/data/core/privacy\",\n    \"dataaccess\": \"/data/foundation/export\",\n    \"mapping\": \"/data/foundation/conversion\",\n    \"policy\": \"/data/foundation/dulepolicy\",\n    \"dataset\": \"/data/foundation/dataset\",\n    \"ingestion\": \"/data/foundation/import\",", "    \"dataset\": \"/data/foundation/dataset\",\n    \"ingestion\": \"/data/foundation/import\",\n    \"observability\": \"/data/infrastructure/observability/insights\",\n    \"destinationAuthoring\": \"/data/core/activation/authoring\",\n    \"destinationInstance\" : \"/data/core/activation/disflowprovider\",\n    \"streaming\": {\n        \"inlet\": \"\",\n        \"collection\": \"https://dcs.adobedc.net\"\n    },\n    \"audit\": \"/data/foundation\"", "    },\n    \"audit\": \"/data/foundation\"\n}"]}
{"filename": "aepp/ingestion.py", "chunked_list": ["#  Copyright 2023 Adobe. All rights reserved.\n#  This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License. You may obtain a copy\n#  of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software distributed under\n#  the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n#  OF ANY KIND, either express or implied. See the License for the specific language\n#  governing permissions and limitations under the License.\n", "#  governing permissions and limitations under the License.\n\nimport aepp\nfrom aepp import connector\nfrom copy import deepcopy\nimport requests\nfrom typing import Union\nimport logging\nimport json\nfrom pathlib import Path", "import json\nfrom pathlib import Path\nfrom .configs import ConnectObject\n\nclass DataIngestion:\n    \"\"\"\n    Class that manages sending data via authenticated methods.\n    For Batch and Streaming messages.\n    \"\"\"\n\n    loggingEnabled = False\n    logger = None\n\n    def __init__(\n        self,\n        config: Union[dict,ConnectObject] = aepp.config.config_object,\n        header: dict = aepp.config.header,\n        loggingObject: dict = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Instantiate the DataAccess class.\n        Arguments:\n            config : OPTIONAL : config object in the config module.\n            header : OPTIONAL : header object  in the config module.\n        Additional kwargs will update the header.\n        \"\"\"\n        requests.packages.urllib3.disable_warnings()\n        if loggingObject is not None and sorted(\n            [\"level\", \"stream\", \"format\", \"filename\", \"file\"]\n        ) == sorted(list(loggingObject.keys())):\n            self.loggingEnabled = True\n            self.logger = logging.getLogger(f\"{__name__}\")\n            self.logger.setLevel(loggingObject[\"level\"])\n            if type(loggingObject[\"format\"]) == str:\n                formatter = logging.Formatter(loggingObject[\"format\"])\n            elif type(loggingObject[\"format\"]) == logging.Formatter:\n                formatter = loggingObject[\"format\"]\n            if loggingObject[\"file\"]:\n                fileHandler = logging.FileHandler(loggingObject[\"filename\"])\n                fileHandler.setFormatter(formatter)\n                self.logger.addHandler(fileHandler)\n            if loggingObject[\"stream\"]:\n                streamHandler = logging.StreamHandler()\n                streamHandler.setFormatter(formatter)\n                self.logger.addHandler(streamHandler)\n        if type(config) == dict: ## Supporting either default setup or passing a ConnectObject\n            config = config\n        elif type(config) == ConnectObject:\n            header = config.getConfigHeader()\n            config = config.getConfigObject()\n        self.connector = connector.AdobeRequest(\n            config=config, \n            header=header,\n            logger=self.logger,\n            loggingEnabled=self.loggingEnabled)\n        self.header = self.connector.header\n        self.header.update(**kwargs)\n        if kwargs.get('sandbox',None) is not None: ## supporting sandbox setup on class instanciation\n            self.sandbox = kwargs.get('sandbox')\n            self.connector.config[\"sandbox\"] = kwargs.get('sandbox')\n            self.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n            self.connector.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n        else:\n            self.sandbox = self.connector.config[\"sandbox\"]\n        self.endpoint = (\n            aepp.config.endpoints[\"global\"] + aepp.config.endpoints[\"ingestion\"]\n        )\n        self.endpoint_streaming = aepp.config.endpoints[\"streaming\"][\"collection\"]\n        self.STREAMING_REFERENCE = {\n            \"header\": {\n                \"schemaRef\": {\n                    \"id\": \"https://ns.adobe.com/{TENANT_ID}/schemas/{SCHEMA_ID}\",\n                    \"contentType\": \"application/vnd.adobe.xed-full+json;version={SCHEMA_VERSION}\",\n                },\n                \"imsOrgId\": \"{IMS_ORG_ID}\",\n                \"datasetId\": \"{DATASET_ID}\",\n                \"createdAt\": \"1526283801869\",\n                \"source\": {\"name\": \"{SOURCE_NAME}\"},\n            },\n            \"body\": {\n                \"xdmMeta\": {\n                    \"schemaRef\": {\n                        \"id\": \"https://ns.adobe.com/{TENANT_ID}/schemas/{SCHEMA_ID}\",\n                        \"contentType\": \"application/vnd.adobe.xed-full+json;version={SCHEMA_VERSION}\",\n                    }\n                },\n                \"xdmEntity\": {\n                    \"person\": {\n                        \"name\": {\n                            \"firstName\": \"Jane\",\n                            \"middleName\": \"F\",\n                            \"lastName\": \"Doe\",\n                        },\n                        \"birthDate\": \"1969-03-14\",\n                        \"gender\": \"female\",\n                    },\n                    \"workEmail\": {\n                        \"primary\": True,\n                        \"address\": \"janedoe@example.com\",\n                        \"type\": \"work\",\n                        \"status\": \"active\",\n                    },\n                },\n            },\n        }\n\n    def createBatch(\n        self,\n        datasetId: str = None,\n        format: str = \"json\",\n        multiline: bool = False,\n        enableDiagnostic: bool = False,\n        partialIngestionPercentage: int = 0,\n        **kwargs\n    ) -> dict:\n        \"\"\"\n        Create a new batch in Catalog Service.\n        Arguments:\n            datasetId : REQUIRED : The Dataset ID for the batch to upload data to.\n            format : REQUIRED : the format of the data send.(default json)\n            multiline : OPTIONAL : If you wish to upload multi-line JSON.\n        Possible kwargs:\n            replay : the replay object to replay a batch.\n            https://experienceleague.adobe.com/docs/experience-platform/ingestion/batch/api-overview.html?lang=en#replay-a-batch\n        \"\"\"\n        if datasetId is None:\n            raise ValueError(\"Require a dataSetId\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Using createBatch with following format ({format})\")\n        obj = {\n            \"datasetId\": datasetId,\n            \"inputFormat\": {\"format\": format, \"isMultiLineJson\": False},\n        }\n        if len(kwargs.get('replay',{}))>0:\n            obj['replay'] = kwargs.get('replay')\n        if multiline is True:\n            obj[\"inputFormat\"][\"isMultiLineJson\"] = True\n        if enableDiagnostic != False:\n            obj[\"enableErrorDiagnostics\"] = True\n        if partialIngestionPercentage > 0:\n            obj[\"partialIngestionPercentage\"] = partialIngestionPercentage\n        path = \"/batches\"\n        res = self.connector.postData(self.endpoint + path, data=obj)\n        return res\n\n    def deleteBatch(self, batchId: str = None) -> str:\n        \"\"\"\n        Delete a batch by applying the revert action on it.\n        Argument:\n            batchId : REQUIRED : Batch ID to be deleted\n        \"\"\"\n        if batchId is None:\n            raise ValueError(\"Require a batchId argument\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteBatch for ID: ({batchId})\")\n        path = f\"/batches/{batchId}\"\n        params = {\"action\": \"REVERT\"}\n        res = self.connector.postData(self.endpoint + path, params=params)\n        return res\n\n    def replayBatch(self, datasetId: str = None, batchIds: list = None) -> dict:\n        \"\"\"\n        You can replay a batch that has already been ingested. You need to provide the datasetId and the list of batch to be replay.\n        Once specify through that action, you will need to re-upload batch information via uploadSmallFile method with JSON format and then specify the completion.\n        You will need to re-use the batchId provided for the re-upload.\n        Arguments:\n            dataSetId : REQUIRED : The dataset ID attached to the batch\n            batchIds : REQUIRED : The list of batchID to replay.\n        \"\"\"\n        if datasetId is None:\n            raise ValueError(\"Require a dataset ID\")\n        if batchIds is None or type(batchIds) != list:\n            raise ValueError(\"Require a list of batch ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting replayBatch for dataset ID: ({datasetId})\")\n        path = \"/batches\"\n        predecessors = [f\"${batchId}\" for batchId in batchIds]\n        data = {\n            \"datasetId\": datasetId,\n            \"inputFormat\": {\"format\": \"json\"},\n            \"replay\": {\"predecessors\": predecessors, \"reason\": \"replace\"},\n        }\n        res = self.connector.patchData(self.endpoint + path, data=data)\n        return res\n\n    def uploadSmallFile(\n        self,\n        batchId: str = None,\n        datasetId: str = None,\n        filePath: str = None,\n        data: Union[list, dict,str] = None,\n        verbose: bool = False,\n    ) -> dict:\n        \"\"\"\n        Upload a small file (<256 MB) to the filePath location in the dataset.\n        Arguments:\n            batchId : REQUIRED : The batchId referencing the batch processed created beforehand.\n            datasetId : REQUIRED : The dataSetId related to where the data are ingested to.\n            filePath : REQUIRED : the filePath that will store the value.\n            data : REQUIRED : The data to be uploaded (following the type provided). List or Dictionary, depending if multiline is enabled.\n                You can also pass a JSON file path. If the element is a string and ends with \".json\", the file will be loaded and transform automatically to a dictionary. \n            verbose: OPTIONAL : if you wish to see comments around the\n        \"\"\"\n        if batchId is None:\n            raise Exception(\"require a batchId\")\n        if datasetId is None:\n            raise Exception(\"require a dataSetId\")\n        if filePath is None:\n            raise Exception(\"require a filePath value\")\n        if data is None:\n            raise Exception(\"require data to be passed\")\n        if verbose:\n            print(f\"Your data is in {type(data)} format\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"uploadSmallFile as format: ({type(data)})\")\n        privateHeader = deepcopy(self.header)\n        privateHeader[\"Content-Type\"] = \"application/octet-stream\"\n        path = f\"/batches/{batchId}/datasets/{datasetId}/files/{filePath}\"\n        if type(data) == str:\n            if '.json' in data:\n                with open(Path(path),'r') as f:\n                    data = json.load(f)\n        res = self.connector.putData(\n            self.endpoint + path, data=data, headers=privateHeader\n        )\n        return res\n\n    def uploadSmallFileFinish(\n        self, batchId: str = None, action: str = \"COMPLETE\", verbose: bool = False\n    ) -> dict:\n        \"\"\"\n        Send an action to signify that the import is done.\n        Arguments:\n            batchId : REQUIRED : The batchId referencing the batch processed created beforehand.\n            action : REQUIRED : either one of these actions:\n                COMPLETE (default value)\n                ABORT\n                FAIL\n                REVERT\n        \"\"\"\n        if batchId is None:\n            raise Exception(\"require a batchId\")\n        if action is None or action not in [\"COMPLETE\", \"ABORT\", \"FAIL\", \"REVERT\"]:\n            raise Exception(\"Not a valid action has been passed\")\n        path = f\"/batches/{batchId}\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Finishing upload for batch ID: ({batchId})\")\n        params = {\"action\": action}\n        res = self.connector.postData(\n            self.endpoint + path, params=params, verbose=verbose\n        )\n        return res\n\n    def uploadLargeFileStartEnd(\n        self,\n        batchId: str = None,\n        datasetId: str = None,\n        filePath: str = None,\n        action: str = \"INITIALIZE\",\n    ) -> dict:\n        \"\"\"\n        Start / End the upload of a large file with a POST method defining the action (see parameter)\n        Arguments:\n            batchId : REQUIRED : The batchId referencing the batch processed created beforehand.\n            datasetId : REQUIRED : The dataSetId related to where the data are ingested to.\n            filePath : REQUIRED : the filePath that will store the value.\n            action : REQUIRED : Action to either INITIALIZE or COMPLETE the upload.\n        \"\"\"\n        if batchId is None:\n            raise Exception(\"require a batchId\")\n        if datasetId is None:\n            raise Exception(\"require a dataSetId\")\n        if filePath is None:\n            raise Exception(\"require a filePath value\")\n        params = {\"action\": action}\n        if self.loggingEnabled:\n            self.logger.debug(\n                f\"Starting or Ending large upload for batch ID: ({batchId})\"\n            )\n        path = f\"/batches/{batchId}/datasets/{datasetId}/files/{filePath}\"\n        res = self.connector.postData(self.endpoint + path, params=params)\n        return res\n\n    def uploadLargeFilePart(\n        self,\n        batchId: str = None,\n        datasetId: str = None,\n        filePath: str = None,\n        data: bytes = None,\n        contentRange: str = None,\n    ) -> dict:\n        \"\"\"\n        Continue the upload of a large file with a PATCH method.\n        Arguments:\n            batchId : REQUIRED : The batchId referencing the batch processed created beforehand.\n            datasetId : REQUIRED : The dataSetId related to where the data are ingested to.\n            filePath : REQUIRED : the filePath that will store the value.\n            data : REQUIRED : The data to be uploaded (in bytes)\n            contentRange : REQUIRED : The range of bytes of the file being uploaded with this request.\n        \"\"\"\n        if batchId is None:\n            raise Exception(\"require a batchId\")\n        if datasetId is None:\n            raise Exception(\"require a dataSetId\")\n        if filePath is None:\n            raise Exception(\"require a filePath value\")\n        if data is None:\n            raise Exception(\"require data to be passed\")\n        if contentRange is None:\n            raise Exception(\"require the content range to be passed\")\n        privateHeader = deepcopy(self.header)\n        privateHeader[\"Content-Type\"] = \"application/octet-stream\"\n        privateHeader[\"Content-Range\"] = contentRange\n        if self.loggingEnabled:\n            self.logger.debug(f\"Uploading large part for batch ID: ({batchId})\")\n        path = f\"/batches/{batchId}/datasets/{datasetId}/files/{filePath}\"\n        res = requests.patch(self.endpoint + path, data=data, headers=privateHeader, verify=False)\n        res_json = res.json()\n        return res_json\n\n    def headFileStatus(\n        self, batchId: str = None, datasetId: str = None, filePath: str = None\n    ) -> dict:\n        \"\"\"\n        Check the status of a large file upload.\n        Arguments:\n            batchId : REQUIRED : The batchId referencing the batch processed created beforehand.\n            datasetId : REQUIRED : The dataSetId related to where the data are ingested to.\n            filePath : REQUIRED : the filePath that reference the file.\n        \"\"\"\n        if batchId is None:\n            raise Exception(\"require a batchId\")\n        if datasetId is None:\n            raise Exception(\"require a dataSetId\")\n        if filePath is None:\n            raise Exception(\"require a filePath value\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Head File Status batch ID: ({batchId})\")\n        path = f\"/batches/{batchId}/datasets/{datasetId}/files/{filePath}\"\n        res = self.connector.headData(self.endpoint + path)\n        return res\n\n    def getPreviewBatchDataset(\n        self,\n        batchId: str = None,\n        datasetId: str = None,\n        format: str = \"json\",\n        delimiter: str = \",\",\n        quote: str = '\"',\n        escape: str = \"\\\\\",\n        charset: str = \"utf-8\",\n        header: bool = True,\n        nrow: int = 5,\n    ) -> dict:\n        \"\"\"\n        Generates a data preview for the files uploaded to the batch so far. The preview can be generated for all the batch datasets collectively or for the selected datasets.\n        Arguments:\n            batchId : REQUIRED : The batchId referencing the batch processed created beforehand.\n            datasetId : REQUIRED : The dataSetId related to where the data are ingested to.\n            format : REQUIRED : Format of the file ('json' default)\n            delimiter : OPTIONAL : The delimiter to use for parsing column values.\n            quote : OPTIONAL : The quote value to use while parsing data.\n            escape : OPTIONAL : The escape character to use while parsing data.\n            charset : OPTIONAL : The encoding to be used (default utf-8)\n            header : OPTIONAL : The flag to indicate if the header is supplied in the dataset files.\n            nrow : OPTIONAL : The number of rows to parse. (default 5) - cannot be 10 or greater\n        \"\"\"\n        if batchId is None:\n            raise Exception(\"require a batchId\")\n        if datasetId is None:\n            raise Exception(\"require a dataSetId\")\n        if format is None:\n            raise Exception(\"require a format type\")\n        params = {\n            \"delimiter\": delimiter,\n            \"quote\": quote,\n            \"escape\": escape,\n            \"charset\": charset,\n            \"header\": header,\n            \"nrow\": nrow,\n        }\n        if self.loggingEnabled:\n            self.logger.debug(f\"getPreviewBatchDataset for dataset ID: ({datasetId})\")\n        path = f\"/batches/{batchId}/datasets/{datasetId}/preview\"\n        res = self.connector.getData(self.endpoint + path, params=params)\n        return res\n\n    def streamMessage(\n        self,\n        inletId: str = None,\n        data: dict = None,\n        flowId: str = None,\n        syncValidation: bool = False,\n    ) -> dict:\n        \"\"\"\n        Send a dictionary to the connection for streaming ingestion.\n        Arguments:\n            inletId : REQUIRED : the connection ID to be used for ingestion\n            data : REQUIRED : The data that you want to ingest to Platform.\n            flowId : OPTIONAL : The flow ID for the stream inlet.\n            syncValidation : OPTIONAL : An optional query parameter, intended for development purposes.\n                If set to true, it can be used for immediate feedback to determine if the request was successfully sent.\n        \"\"\"\n        privateHeader = deepcopy(self.header)\n        if inletId is None:\n            raise Exception(\"Require a connectionId to be present\")\n        if data is None and type(data) != dict:\n            raise Exception(\"Require a dictionary to be send for ingestion\")\n        if flowId is not None:\n            privateHeader['x-adobe-flow-id'] = flowId\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting Streaming single message\")\n        params = {\"syncValidation\": syncValidation}\n        path = f\"/collection/{inletId}\"\n        res = self.connector.postData(\n            self.endpoint_streaming + path, data=data, params=params, headers=privateHeader\n        )\n        return res\n\n    def streamMessages(\n        self,\n        inletId: str = None,\n        data: list = None,\n        flowId: str = None,\n        syncValidation: bool = False,\n    ) -> dict:\n        \"\"\"\n        Send a dictionary to the connection for streaming ingestion.\n        Arguments:\n            inletId : REQUIRED : the connection ID to be used for ingestion\n            data : REQUIRED : The list of data that you want to ingest to Platform.\n            flowId : OPTIONAL : The flow ID for the stream inlet.\n            syncValidation : OPTIONAL : An optional query parameter, intended for development purposes.\n                If set to true, it can be used for immediate feedback to determine if the request was successfully sent.\n        \"\"\"\n        privateHeader = deepcopy(self.header)\n        if inletId is None:\n            raise Exception(\"Require a connectionId to be present\")\n        if data is None and type(data) != list:\n            raise Exception(\"Require a list of dictionary to be send for ingestion\")\n        if flowId is not None:\n            privateHeader['x-adobe-flow-id'] = flowId\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting Streaming multiple messages\")\n        params = {\"syncValidation\": syncValidation}\n        data = {\"messages\": data}\n        path = f\"/collection/batch/{inletId}\"\n        res = self.connector.postData(\n            self.endpoint_streaming + path, data=data, params=params, headers=privateHeader\n        )\n        return res", ""]}
{"filename": "aepp/customerprofile.py", "chunked_list": ["#  Copyright 2023 Adobe. All rights reserved.\n#  This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License. You may obtain a copy\n#  of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software distributed under\n#  the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n#  OF ANY KIND, either express or implied. See the License for the specific language\n#  governing permissions and limitations under the License.\n", "#  governing permissions and limitations under the License.\n\n# Internal Library\nimport aepp\nfrom aepp import connector\nfrom copy import deepcopy\nimport pandas as pd\nimport logging\nfrom typing import Union\nfrom .configs import ConnectObject", "from typing import Union\nfrom .configs import ConnectObject\n\n\nclass Profile:\n    \"\"\"\n    A class containing the different methods exposed on Customer Profile API.\n    The API documentation is available:\n    https://www.adobe.io/apis/experienceplatform/home/api-reference.html#!acpdr/swagger-specs/real-time-customer-profile.yaml\n    \"\"\"\n\n    ## logging capability\n    loggingEnabled = False\n    logger = None\n\n    def __init__(\n        self,\n        config: Union[dict,ConnectObject] = aepp.config.config_object,\n        header: dict = aepp.config.header,\n        loggingObject: dict = None,\n        **kwargs,\n    ):\n        \"\"\"\n            This will instantiate the profile class\n            Arguments:\n                config : OPTIONAL : config object in the config module.\n                header : OPTIONAL : header object  in the config module.\n                loggingObject : OPTIONAL : logging object to log messages.\n        kwargs:\n            kwargsvaluewillupdatetheheader\n        \"\"\"\n        if loggingObject is not None and sorted(\n            [\"level\", \"stream\", \"format\", \"filename\", \"file\"]\n        ) == sorted(list(loggingObject.keys())):\n            self.loggingEnabled = True\n            self.logger = logging.getLogger(f\"{__name__}\")\n            self.logger.setLevel(loggingObject[\"level\"])\n            if type(loggingObject[\"format\"]) == str:\n                formatter = logging.Formatter(loggingObject[\"format\"])\n            elif type(loggingObject[\"format\"]) == logging.Formatter:\n                formatter = loggingObject[\"format\"]\n            if loggingObject[\"file\"]:\n                fileHandler = logging.FileHandler(loggingObject[\"filename\"])\n                fileHandler.setFormatter(formatter)\n                self.logger.addHandler(fileHandler)\n            if loggingObject[\"stream\"]:\n                streamHandler = logging.StreamHandler()\n                streamHandler.setFormatter(formatter)\n                self.logger.addHandler(streamHandler)\n        if type(config) == dict: ## Supporting either default setup or passing a ConnectObject\n            config = config\n        elif type(config) == ConnectObject:\n            header = config.getConfigHeader()\n            config = config.getConfigObject()\n        self.connector = connector.AdobeRequest(\n            config=config,\n            header=header,\n            loggingEnabled=self.loggingEnabled,\n            logger=self.logger,\n        )\n        self.header = self.connector.header\n        self.header[\"Accept\"] = \"application/vnd.adobe.xdm+json\"\n        self.header.update(**kwargs)\n        if kwargs.get('sandbox',None) is not None: ## supporting sandbox setup on class instanciation\n            self.sandbox = kwargs.get('sandbox')\n            self.connector.config[\"sandbox\"] = kwargs.get('sandbox')\n            self.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n            self.connector.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n        else:\n            self.sandbox = self.connector.config[\"sandbox\"]\n        # same endpoint than segmentation\n        self.endpoint = (\n            aepp.config.endpoints[\"global\"] + aepp.config.endpoints[\"segmentation\"]\n        )\n\n    def getEntity(\n        self,\n        schema_name: str = \"_xdm.context.profile\",\n        entityId: str = None,\n        entityIdNS: str = None,\n        mergePoliciyId: str = None,\n        **kwargs,\n    ) -> dict:\n        \"\"\"\n        Returns an entity by ID or Namespace.\n        Arguments:\n            schema_name : REQUIRED : class name of the schema to be retrieved. default : _xdm.context.profile\n            entityId : OPTIONAL : identity ID\n            entityIdNS : OPTIONAL : Identity Namespace code. Required if entityId is used (except for native identity)\n            mergePoliciyId : OPTIONAL : Id of the merge policy.\n        Possible kwargs:\n            fields : path of the elements to be retrieved, separated by comma. Ex : \"person.name.firstName,person.name.lastName\"\n            relatedSchema_name : If schema.name is \"_xdm.context.experienceevent\", this value must specify the schema for the profile entity that the time series events are related to.\n            relatedEntityId : ID of the entity that the ExperienceEvents are associated with. Used when looking up ExperienceEvents. For Native XID lookup, use relatedEntityId=<XID> and leave relatedEntityIdNS absent;\n            For ID:NS lookup, use both relatedEntityId and relatedEntityIdNS fields.\n            relatedEntityIdNS : Identity Namespace code of the related entity ID of ExperienceEvent. Used when looking up ExperienceEvents. If this field is used, entityId cannot be empty.\n            startTime : Start time of Time range filter for ExperienceEvents. Should be at millisecond granularity. Included. Default: From beginning.\n            endTime : End time of Time range filter for ExperienceEvents. Should be at millisecond granularity. Excluded. Default: To the end.\n            limit : Number of records to return from the result. Only for time-series objects. Default: 1000\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getEntity\")\n        path = \"/access/entities\"\n        params = {\n            \"schema.name\": schema_name,\n            \"entityId\": entityId,\n            \"entityIdNS\": entityIdNS,\n            \"mergePoliciyId\": mergePoliciyId,\n        }\n        if schema_name == \"_xdm.context.experienceevent\":\n            params[\"relatedSchema.name\"] = kwargs.get(\n                \"relatedSchema_name\", \"_xdm.context.profile\"\n            )\n            params[\"relatedEntityId\"] = kwargs.get(\"relatedEntityId\", entityId)\n            params[\"relatedEntityIdNS\"] = kwargs.get(\"relatedEntityIdNS\", None)\n            params[\"limit\"] = kwargs.get(\"limit\", 1000)\n            params[\"startTime\"] = kwargs.get(\"startTime\", None)\n            params[\"endTime\"] = kwargs.get(\"endTime\", None)\n        params[\"fields\"] = kwargs.get(\"fields\", None)\n        res = self.connector.getData(\n            self.endpoint + path, params=params, headers=self.header\n        )\n        return res\n\n    def getEntities(self, request_data: dict = None) -> dict:\n        \"\"\"\n        Get a number of different identities from ID or namespaces.\n        Argument:\n            request_data : Required : A dictionary that contains fields for the search.\n            Example\n            {\n                \"schema\": {\n                    \"name\": \"_xdm.context.profile\"\n                },\n                \"relatedSchema\": {\n                    \"name\": \"_xdm.context.profile\"\n                },\n                \"fields\": [\n                    \"person.name.firstName\"\n                ],\n                \"identities\": [\n                    {\n                    \"entityId\": \"69935279872410346619186588147492736556\",\n                    \"entityIdNS\": {\n                        \"code\": \"CRMID\"\n                        }\n                    },\n                    ,\n                {\n                    \"entityId\":\"89149270342662559642753730269986316900\",\n                    \"entityIdNS\":{\n                        \"code\":\"ECID\"\n                        }\n                    ],\n                \"timeFilter\": {\n                    \"startTime\": 1539838505,\n                    \"endTime\": 1539838510\n                },\n                \"limit\": 10,\n                \"orderby\": \"-timestamp\",\n                \"withCA\": True\n            }\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getEntities\")\n        path = \"/access/entities\"\n        if request_data is None or type(request_data) != dict:\n            raise Exception(\"Expected a dictionary to fetch entities\")\n        res = self.connector.postData(\n            self.endpoint + path, data=request_data, headers=self.header\n        )\n        return res\n\n    def deleteEntity(\n        self, schema_name: str = None, entityId: str = None, entityIdNS: str = None\n    ) -> str:\n        \"\"\"\n        Delete a specific entity\n        Arguments:\n            schema_name : REQUIRED : Name of the associated XDM schema.\n            entityId : REQUIRED : entity ID\n            entityIdNS : OPTIONAL : entity ID Namespace\n        \"\"\"\n        path = \"/access/entities\"\n        params = {}\n        if schema_name is None:\n            raise Exception(\"Expected a schema name\")\n        else:\n            params[\"schema.name\"] = schema_name\n        if entityId is not None:\n            params[\"entityId\"] = entityId\n        if entityIdNS is not None:\n            params[\"entityIdNS\"] = entityIdNS\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteEntity\")\n        res = self.connector.deleteData(\n            self.endpoint + path, params=params, headers=self.header\n        )\n        return res\n    \n    def createExportJob(self,\n            exportDefinition:dict=None,\n            fields:list=None,\n            mergePolicyId:str=None,\n            additionalFields:dict=None,\n            datasetId:str=None,\n            schemaName:str=\"_xdm.context.profile\",\n            segmentPerBatch:bool=False,\n            )->dict:\n        \"\"\"\n        Create an export of the profile information of the user.\n        You can pass directly the payload or you can pass different arguments to create that export job.\n        Documentation: https://experienceleague.adobe.com/docs/experience-platform/profile/api/export-jobs.html?lang=en\n        Arguments: \n            exportDefinition : OPTIONAL : The complete definition of the export\n        If not provided, use the following parameters:\n            fields : OPTIONAL : Limits the data fields to be included in the export to only those provided in this parameter. \n                    Omitting this value will result in all fields being included in the exported data.\n            mergePolicyId : OPTIONAL : MergePolicyId to use for data combination.\n            additionalFields : OPTIONAL : Controls the time-series event fields exported for child or associated objects by providing one or more of the following settings:\n            datasetId : OPTIONAL : the datasetId to be used for the export.\n            schemaName : OPTIONAL : Schema associated with the dataset.\n            segmentPerBatch : OPTIONAL : A Boolean value that, if not provided, defaults to false. A value of false exports all segment IDs into a single batch ID. A value of true exports one segment ID into one batch ID.\n        \"\"\"\n        if exportDefinition is not None and type(exportDefinition) == dict:\n            data = exportDefinition\n        elif fields is not None and mergePolicyId is not None and datasetId is not None and schemaName is not None:\n            data = {}\n            data['fields'] = ','.join(fields)\n            data['mergePolicy'] = {\n                \"id\": mergePolicyId,\n                \"version\": 1\n            }\n            data['destination'] = {\n                \"datasetId\": datasetId,\n                \"segmentPerBatch\": segmentPerBatch\n            }\n            data['schema'] = {\n                \"name\": schemaName,\n            }\n            if additionalFields is not None:\n                data['additionalFields'] = additionalFields\n        else:\n            raise ValueError(\"Require the definition or arguments to be used\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createExportJob\")\n        path = f\"/export/jobs\"\n        res = self.connector.postData(self.endpoint + path, data=data)\n        return res\n\n    def getExportJobs(self,limit:int=100)->dict:\n        \"\"\"\n        Returns all export jobs\n        Arguments:\n            limit : OPTIONAL : Number of jobs to return\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getExportJobs\")\n        path = \"/export/jobs/\"\n        params = {\"limit\":limit}\n        res = self.connector.getData(self.endpoint+path,params=params)\n        return res\n    \n    def getExportJob(self, exportId:str=None)->dict:\n        \"\"\"\n        Returns an export job status\n        Arguments:\n            exportId : OPTIONAL : The id of the export job you want to access.\n        \"\"\"\n        if exportId is None:\n            raise ValueError(\"Require an export ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getExportJob with ID: {exportId}\")\n        path = f\"/export/jobs/{exportId}\"\n        res = self.connector.getData(self.endpoint+path)\n        return res\n\n    def deleteExportJob(self, exportId:str=None)->dict:\n        \"\"\"\n        Delete an export job\n        Arguments:\n            exportId : OPTIONAL : The id of the export job you want to delete.\n        \"\"\"\n        if exportId is None:\n            raise ValueError(\"Require an export ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteExportJob with ID: {exportId}\")\n        path = f\"/export/jobs/{exportId}\"\n        res = self.connector.deleteData(self.endpoint+path)\n        return res\n\n\n\n    def getMergePolicies(self, limit: int = 100) -> dict:\n        \"\"\"\n        Returns the list of merge policies hosted in this instance.\n        Arguments:\n            limit : OPTIONAL : amount of merge policies returned by pages.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getMergePolicies\")\n        path = \"/config/mergePolicies\"\n        params = {\"limit\": limit}\n        res = self.connector.getData(\n            self.endpoint + path, params=params, headers=self.header\n        )\n        data = res[\"children\"]\n        nextPage = res[\"_links\"][\"next\"].get(\"href\", \"\")\n        while nextPage != \"\":\n            path = \"/config/mergePolicies?\" + nextPage.split(\"?\")[1]\n            res = self.connector.getData(\n                self.endpoint + path, params=params, headers=self.header\n            )\n            data += res[\"children\"]\n            nextPage = res[\"_links\"][\"next\"].get(\"href\", \"\")\n        return data\n\n    def getMergePolicy(self, policy_id: str = None) -> dict:\n        \"\"\"\n        Return a specific merge policy.\n        Arguments:\n            policy_id : REQUIRED : id of the the policy id to be returned.\n        \"\"\"\n        if policy_id is None:\n            raise Exception(\"Missing the policy id\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getMergePolicy\")\n        path = f\"/config/mergePolicies/{policy_id}\"\n        res = self.connector.getData(self.endpoint + path, headers=self.header)\n        return res\n\n    def createMergePolicy(self, policy: dict = None) -> dict:\n        \"\"\"\n        Arguments:\n            policy: REQUIRED : The dictionary defining the policy\n        Refer to the documentation : https://experienceleague.adobe.com/docs/experience-platform/profile/api/merge-policies.html\n        Example of JSON:\n        {\n            \"name\": \"real-time-customer-profile-default\",\n            \"imsOrgId\": \"1BD6382559DF0C130A49422D@AdobeOrg\",\n            \"schema\": {\n                \"name\": \"_xdm.context.profile\"\n            },\n            \"default\": False,\n            \"identityGraph\": {\n                \"type\": \"pdg\"\n            },\n            \"attributeMerge\": {\n                \"type\": \"timestampOrdered\",\n                \"order\": [\n                \"string\"\n                ]\n            },\n            \"updateEpoch\": 1234567890\n        }\n        \"\"\"\n        path = \"/config/mergePolicies\"\n        if policy is None:\n            raise ValueError(\"Require a dictionary\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createMergePolicy\")\n        res = self.connector.postData(\n            self.endpoint + path, data=policy, headers=self.header\n        )\n        return res\n\n    def updateMergePolicy(self, mergePolicyId: str = None, policy: dict = None) -> dict:\n        \"\"\"\n        Update a merge policy by replacing its definition. (PUT method)\n        Arguments:\n            mergePolicyId : REQUIRED : The merge Policy Id\n            policy : REQUIRED : a dictionary giving the definition of the merge policy\n            Refer to the documentation : https://experienceleague.adobe.com/docs/experience-platform/profile/api/merge-policies.html\n        Example of JSON:\n        {\n            \"name\": \"real-time-customer-profile-default\",\n            \"imsOrgId\": \"1BD6382559DF0C130A49422D@AdobeOrg\",\n            \"schema\": {\n                \"name\": \"_xdm.context.profile\"\n            },\n            \"default\": False,\n            \"identityGraph\": {\n                \"type\": \"pdg\"\n            },\n            \"attributeMerge\": {\n                \"type\": \"timestampOrdered\",\n                \"order\": [\n                \"string\"\n                ]\n            },\n            \"updateEpoch\": 1234567890\n        }\n        attributeMerge can be \"dataSetPrecedence\" or \"timestampOrdered\". Please provide a list of dataSetId on \"order\" when using the first option.\n        \"\"\"\n        if mergePolicyId is None:\n            raise ValueError(\"Require a mergePolicyId\")\n        if policy is None or type(policy) != dict:\n            raise ValueError(\"Require a dictionary to update the merge policy\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting updateMergePolicy\")\n        path = f\"/config/mergePolicies/{mergePolicyId}\"\n        res = self.connector.putData(\n            self.endpoint + path, data=policy, headers=self.header\n        )\n        return res\n\n    def patchMergePolicy(\n        self, mergePolicyId: str = None, operations: list = None\n    ) -> str:\n        \"\"\"\n        Update a merge policy by replacing its definition.\n        Arguments:\n            mergePolicyId : REQUIRED : The merge Policy Id\n            operations : REQUIRED : a list of operations to realize on the merge policy\n            Refer to the documentation : https://experienceleague.adobe.com/docs/experience-platform/profile/api/merge-policies.html\n        Example of operation:\n        [\n            {\n                \"op\": \"add\",\n                \"path\": \"/identityGraph.type\",\n                \"value\": \"pdg\"\n            }\n        ]\n        \"\"\"\n        if mergePolicyId is None:\n            raise ValueError(\"Require a mergePolicyId\")\n        if operations is None or type(operations) != list:\n            raise ValueError(\"Require a dictionary to update the merge policy\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting patchMergePolicy\")\n        path = f\"/config/mergePolicies/{mergePolicyId}\"\n        res = self.connector.patchData(\n            self.endpoint + path, data=operations, headers=self.header\n        )\n        return res\n\n    def deleteMergePolicy(self, mergePolicyId: str = None) -> str:\n        \"\"\"\n        Delete a merge policy by its ID.\n        Arguments:\n            mergePolicyId : REQUIRED : The merge Policy to be deleted\n        \"\"\"\n        if mergePolicyId is None:\n            raise ValueError(\"Require a mergePolicyId\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteMergePolicy\")\n        path = f\"/config/mergePolicies/{mergePolicyId}\"\n        res = self.connector.deleteData(self.endpoint + path)\n        return res\n\n    def getPreviewStatus(self) -> dict:\n        \"\"\"\n        View the details for the last successful sample job that was run for the IMS Organization.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getPreviewStatus\")\n        path = \"/previewsamplestatus\"\n        privateHeader = deepcopy(self.header)\n        privateHeader[\"Accept\"] = \"application/json\"\n        res = self.connector.getData(self.endpoint + path, headers=privateHeader)\n        return res\n\n    def getPreviewDataSet(self, date: str = None, output: str = \"raw\") -> dict:\n        \"\"\"\n        View a report showing the distribution of profiles by dataset.\n        Arguments:\n            date : OPTIONAL : Format: YYYY-MM-DD.\n                If multiple reports were run on the date, the most recent report for that date will be returned.\n                If a report does not exist for the specified date, a 404 error will be returned.\n                If no date is specified, the most recent report will be returned.\n                Example: date=2024-12-31\n            output : OPTIONAL : if you want to have a dataframe returns. Use \"df\", default \"raw\"\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getPreviewDataSet\")\n        path = \"/previewsamplestatus/report/dataset\"\n        params = {}\n        if date is not None:\n            params[\"date\"] = date\n        privateHeader = deepcopy(self.header)\n        privateHeader[\"Accept\"] = \"application/json\"\n        res = self.connector.getData(self.endpoint + path, headers=privateHeader)\n        if output == \"df\":\n            df = pd.DataFrame(res[\"data\"])\n            return df\n        return res\n\n    def getPreviewDataSetOverlap(self, date: str = None, output: str = \"raw\") -> dict:\n        \"\"\"\n        Method to find the overlap of identities with datasets.\n        Arguments:\n            date : OPTIONAL : Format: YYYY-MM-DD.\n                If multiple reports were run on the date, the most recent report for that date will be returned.\n                If a report does not exist for the specified date, a 404 error will be returned.\n                If no date is specified, the most recent report will be returned.\n                Example: date=2024-12-31\n            output : OPTIONAL : if you want to have a dataframe returns. Use \"df\", default \"raw\"\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getPreviewDataSetOverlap\")\n        path = \"/previewsamplestatus/report/dataset/overlap\"\n        params = {}\n        if date is not None:\n            params[\"date\"] = date\n        privateHeader = deepcopy(self.header)\n        privateHeader[\"Accept\"] = \"application/json\"\n        privateHeader[\"x-model-name\"] = \"_xdm.context.profile\"\n        res = self.connector.getData(self.endpoint + path, headers=privateHeader)\n        if output == \"df\":\n            df = pd.DataFrame(res[\"data\"])\n            return df\n        return res\n\n    def getPreviewNamespace(self, date: str = None, output: str = \"raw\") -> dict:\n        \"\"\"\n        View a report showing the distribution of profiles by namespace.\n        Arguments:\n            date : OPTIONAL : Format: YYYY-MM-DD.\n                If multiple reports were run on the date, the most recent report for that date will be returned.\n                If a report does not exist for the specified date, a 404 error will be returned.\n                If no date is specified, the most recent report will be returned.\n                Example: date=2024-12-31\n            output : OPTIONAL : if you want to have a dataframe returns. Use \"df\", default \"raw\"\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getPreviewNamespace\")\n        path = \"/previewsamplestatus/report/namespace\"\n        params = {}\n        if date is not None:\n            params[\"date\"] = date\n        privateHeader = deepcopy(self.header)\n        privateHeader[\"Accept\"] = \"application/json\"\n        res = self.connector.getData(self.endpoint + path, headers=privateHeader)\n        if output == \"df\":\n            df = pd.DataFrame(res[\"data\"])\n            return df\n        return res\n\n    def createDeleteSystemJob(self, dataSetId: str = None, batchId: str = None) -> dict:\n        \"\"\"\n        Delete all the data for a batch or a dataSet based on their ids.\n        Note: you cannot delete batch from record type dataset. You can overwrite them to correct the issue.\n        Only Time Series and record type datasets can be deleted.\n        Arguments:\n            dataSetId : REQUIRED : dataSetId to be deleted\n            batchId : REQUIRED : batchId to be deleted.\n        More info: https://www.adobe.io/apis/experienceplatform/home/api-reference.html#/Profile_System_Jobs/createDeleteRequest\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createDeleteSystemJob\")\n        path = \"/system/jobs\"\n        if dataSetId is not None:\n            obj = {\"dataSetId\": dataSetId}\n            res = self.connector.postData(self.endpoint + path, data=obj)\n            return res\n        elif batchId is not None:\n            obj = {\"batchId\": batchId}\n            res = self.connector.postData(self.endpoint + path, data=obj)\n            return res\n        else:\n            raise ValueError(\"Require a dataSetId or a batchId\")\n\n    def getDeleteSystemJobs(\n        self, page: int = 0, limit: int = 100, n_results: int = 100\n    ) -> dict:\n        \"\"\"\n        Retrieve a list of all delete requests (Profile System Jobs) created by your organization.\n        Arguments:\n            page : OPTIONAL : Return a specific page of results, as per the create time of the request. For example, page=0\n            limit : OPTIONAL : Limit response to a specific number of objects. Must be a positive number. For example, limit=10\n            n_results : OPTIONAL : Number of total result to retrieve.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getDeleteSystemJobs\")\n        path = \"/system/jobs\"\n        params = {\"page\": page, \"limit\": limit}\n        res = self.connector.getData(self.endpoint + path, params=params)\n        data = res[\"children\"]\n        count = len(data)\n        nextPage = res[\"_page\"].get(\"next\", \"\")\n        while nextPage != \"\" and count < n_results:\n            page += 1\n            params = {\"page\": page, \"limit\": limit}\n            res = self.connector.getData(\n                self.endpoint + path, params=params, headers=self.header\n            )\n            count += len(res[\"children\"])\n            data += res[\"children\"]\n            nextPage = res[\"_page\"].get(\"next\", \"\")\n        return data\n\n    def getDeleteSystemJob(self, jobId: str = None) -> dict:\n        \"\"\"\n        Get a specific delete system job by its ID.\n        Arguments:\n            jobId : REQUIRED : Job ID to be retrieved.\n        \"\"\"\n        if jobId is None:\n            raise ValueError(\"Require a system Job ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getDeleteSystemJob\")\n        path = f\"/system/jobs/{jobId}\"\n        res = self.connector.getData(self.endpoint + path, headers=self.header)\n        return res\n\n    def deleteDeleteSystemJob(self, jobId: str = None) -> dict:\n        \"\"\"\n        Delete a specific delete system job by its ID.\n        Arguments:\n            jobId : REQUIRED : Job ID to be deleted.\n        \"\"\"\n        if jobId is None:\n            raise ValueError(\"Require a system Job ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteDeleteSystemJob\")\n        path = f\"/system/jobs/{jobId}\"\n        res = self.connector.deleteData(self.endpoint + path, headers=self.header)\n        return res\n\n    def getComputedAttributes(self) -> list:\n        \"\"\"\n        Retrieve the list of computed attributes set up in your organization.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getComputedAttributes\")\n        path = \"/config/computedAttributes\"\n        res = self.connector.getData(self.endpoint + path)\n        data = res[\"children\"]\n        nextPage = res[\"_page\"].get(\"next\", \"\")\n        # while nextPage != \"\":\n        #     res = self.connector.getData(self.endpoint+path,\n        #                     params=params, headers=self.header)\n        #     data += res['children']\n        #     nextPage = res['_page'].get('next','')\n        return res\n\n    def getComputedAttribute(self, attributeId: str = None) -> dict:\n        \"\"\"\n        Returns a single computed attribute.\n        Arguments:\n            attributeId : REQUIRED : The computed attribute ID.\n        \"\"\"\n        if attributeId is None:\n            raise ValueError(\"Require a computed attribute ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getComputedAttribute\")\n        path = f\"/config/computedAttributes/{attributeId}\"\n        res = self.connector.getData(self.endpoint + path)\n        return res\n\n    def deleteComputedAttribute(self, attributeId: str = None) -> dict:\n        \"\"\"\n        Delete a specific computed attribute.\n        Arguments:\n            attributeId : REQUIRED : The computed attribute ID to be deleted.\n        \"\"\"\n        if attributeId is None:\n            raise ValueError(\"Require a computed attribute ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteComputedAttributes\")\n        path = f\"/config/computedAttributes/{attributeId}\"\n        res = self.connector.deleteData(self.endpoint + path)\n        return res\n\n    def getDestinations(self) -> dict:\n        \"\"\"\n        Retrieve a list of edge projection destinations. The latest definitions are returned.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getDestinations\")\n        path = \"/config/destinations\"\n        res = self.connector.getData(self.endpoint + path)\n        return res\n\n    def createDestination(self, destinationConfig: dict = None) -> dict:\n        \"\"\"\n        Create a new edge projection destination. Assume that there is time between creation and propagation of this information to the edge.\n        Arguments:\n            destinationConfig : REQUIRED : the destination configuration\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createDestination\")\n        privateHeader = deepcopy(self.header)\n        privateHeader[\n            \"Content-Type\"\n        ] = \"application/vnd.adobe.platform.projectionDestination+json; version=1\"\n        if destinationConfig is None:\n            raise ValueError(\"Require a destination configuration object\")\n        path = \"/config/destinations\"\n        res = self.connector.postData(\n            self.endpoint + path, data=destinationConfig, headers=privateHeader\n        )\n        return res\n\n    def getDestination(self, destinationId: str = None) -> dict:\n        \"\"\"\n        Get a specific destination based on its ID.\n        Arguments:\n            destinationId : REQUIRED : The destination ID to be retrieved\n        \"\"\"\n        if destinationId is None:\n            raise ValueError(\"Require a destination ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getDestination\")\n        path = f\"/config/destinations/{destinationId}\"\n        res = self.connector.getData(self.endpoint + path)\n        return res\n\n    def deleteDestination(self, destinationId: str = None) -> dict:\n        \"\"\"\n        Delete a specific destination based on its ID.\n        Arguments:\n            destinationId : REQUIRED : The destination ID to be deleted\n        \"\"\"\n        if destinationId is None:\n            raise ValueError(\"Require a destination ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteDestination\")\n        path = f\"/config/destinations/{destinationId}\"\n        res = self.connector.deleteData(self.endpoint + path)\n        return res\n\n    def updateDestination(\n        self, destinationId: str = None, destinationConfig: dict = None\n    ) -> dict:\n        \"\"\"\n        Update a specific destination based on its ID. (PUT request)\n        Arguments:\n            destinationId : REQUIRED : The destination ID to be updated\n            destinationConfig : REQUIRED : the destination config object to replace the old one.\n        \"\"\"\n        if destinationId is None:\n            raise ValueError(\"Require a destination ID\")\n        if destinationConfig is None:\n            raise ValueError(\"Require a dictionation for updating the destination\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting updateDestination\")\n        privateHeader = deepcopy(self.header)\n        privateHeader[\n            \"Content-Type\"\n        ] = \"application/vnd.adobe.platform.projectionDestination+json\"\n        path = f\"/config/destinations/{destinationId}\"\n        res = self.connector.putData(\n            self.endpoint + path, data=destinationConfig, headers=privateHeader\n        )\n        return res\n\n    def getProjections(self, schemaName: str = None, name: str = None) -> dict:\n        \"\"\"\n        Retrieve a list of edge projection configurations. The latest definitions are returned.\n        Arguments:\n            schemaName : OPTIONAL : The name of the schema class associated with the projection configuration you want to access.\n                example : _xdm.context.profile\n            name : OPTIONAL : The name of the projection configuration you want to access.\n                if name is specified, schemaName is also required.\n        \"\"\"\n        path = \"/config/projections\"\n        params = {}\n        if name is not None and schemaName is None:\n            raise AttributeError(\n                \"You must specify a schema name when setting a projection name\"\n            )\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getProjections\")\n        if schemaName is not None:\n            params[\"schemaName\"] = schemaName\n        if name is not None:\n            params[\"name\"] = name\n        res = self.connector.getData(\n            self.endpoint + path, params=params, headers=self.headers\n        )\n        return res\n\n    def getProjection(self, projectionId: str = None) -> dict:\n        \"\"\"\n        Retrieve a single projection based on its ID.\n        Arguments:\n            projectionId : REQUIRED : the projection ID to be retrieved.\n        \"\"\"\n        if projectionId is None:\n            raise ValueError(\"Require a projection ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getProjection\")\n        path = f\"/config/projections/{projectionId}\"\n        res = self.connector.getData(self.endpoint + path)\n        return res\n\n    def deleteProjection(self, projectionId: str = None) -> dict:\n        \"\"\"\n        Delete a single projection based on its ID.\n        Arguments:\n            projectionId : REQUIRED : the projection ID to be deleted.\n        \"\"\"\n        if projectionId is None:\n            raise ValueError(\"Require a projection ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteProjection\")\n        path = f\"/config/projections/{projectionId}\"\n        res = self.connector.deleteData(self.endpoint + path)\n        return res\n\n    def createProjection(\n        self, schemaName: str = None, projectionConfig: dict = None\n    ) -> dict:\n        \"\"\"\n        Create a projection\n        Arguments:\n            schemaName : REQUIRED : XDM schema namess\n            projectionConfig : REQUIRED : the object definiing the projection\n        \"\"\"\n        if schemaName is None:\n            raise ValueError(\"Require a schema name specified\")\n        if projectionConfig is None:\n            raise ValueError(\"Require a projection configuration\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createProjection\")\n        path = \"/config/projections\"\n        params = {\"schemaName\": schemaName}\n        privateHeader = deepcopy(self.header)\n        privateHeader[\n            \"Content-Type\"\n        ] = \"application/vnd.adobe.platform.projectionConfig+json; version=1\"\n        res = self.connector.postData(\n            self.endpoint + path,\n            params=params,\n            data=projectionConfig,\n            privateHeader=privateHeader,\n        )\n        return res\n\n    def updateProjection(\n        self, projectionId: str = None, projectionConfig: dict = None\n    ) -> dict:\n        \"\"\"\n        Update a projection based on its ID.(PUT request)\n        Arguments:\n            projectionId : REQUIRED : The ID of the projection to be updated.\n            projectionConfig : REQUIRED : the object definiing the projection\n        \"\"\"\n        if projectionId is None:\n            raise ValueError(\"Require a projectionId\")\n        if projectionConfig is None:\n            raise ValueError(\"Require a projection Configuration object\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting updateProjection\")\n        privateHeader = deepcopy(self.header)\n        privateHeader[\n            \"Content-Type\"\n        ] = \"application/vnd.adobe.platform.projectionConfig+json\"\n        path = f\"/config/projections/{projectionId}\"\n        res = self.connector.putData(\n            self.endpoint + path, data=projectionConfig, headers=privateHeader\n        )\n        return res", ""]}
{"filename": "aepp/queryservice.py", "chunked_list": ["#  Copyright 2023 Adobe. All rights reserved.\n#  This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License. You may obtain a copy\n#  of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software distributed under\n#  the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n#  OF ANY KIND, either express or implied. See the License for the specific language\n#  governing permissions and limitations under the License.\n", "#  governing permissions and limitations under the License.\n\n# Internal Library\nfrom aepp import connector\nimport pandas as pd\nfrom typing import Union\nimport re\nimport aepp\nimport time\nimport logging", "import time\nimport logging\nfrom .configs import ConnectObject\n\nclass QueryService:\n    \"\"\"\n    QueryService class is to be used in order to generate queries, scheduled queries or retrieve past queries.\n    \"\"\"\n\n    QUERYSAMPLE = {\n        \"dbName\": \"string\",\n        \"sql\": \"SELECT $key from $key1 where $key > $key2;\",\n        \"queryParameters\": {\"key\": \"value\", \"key1\": \"value1\", \"key2\": \"value2\"},\n        \"templateId\": \"123\",\n        \"name\": \"string\",\n        \"description\": \"powered by aepp\",\n        \"insertIntoParameters\": {\"datasetName\": \"string\"},\n        \"ctasParameters\": {\n            \"datasetName\": \"myDatasetName\",\n            \"description\": \"powered by aepp\",\n            \"targetSchemaTitle\": \"mySchemaName\",\n        },\n    }\n    SCHEDULESAMPLE = {\n        \"query\": {\n            \"dbName\": \"string\",\n            \"sql\": \"SELECT $key from $key1 where $key > $key2;\",\n            \"queryParameters\": {\"key\": \"value\", \"key1\": \"value1\", \"key2\": \"value2\"},\n            \"templateId\": \"123\",\n            \"name\": \"string\",\n            \"description\": \"string\",\n            \"insertIntoParameters\": {\"datasetName\": \"string\"},\n            \"ctasParameters\": {\n                \"datasetName\": \"string\",\n                \"description\": \"string\",\n                \"targetSchemaTitle\": \"mySchemaName\",\n            },\n        },\n        \"schedule\": {\n            \"schedule\": \"string\",\n            \"startDate\": \"string\",\n            \"endDate\": \"string\",\n            \"maxActiveRuns\": 0,\n        },\n    }\n    TEMPLATESAMPLE = {\n        \"sql\": \"SELECT $key from $key1 where $key > $key2;\",\n        \"queryParameters\": {\"key\": \"value\", \"key1\": \"value1\", \"key2\": \"value2\"},\n        \"name\": \"string\",\n    }\n\n    ## logging capability\n    loggingEnabled = False\n    logger = None\n\n    def __init__(\n        self,\n        config: Union[dict,ConnectObject] = aepp.config.config_object,\n        header:dict = aepp.config.header,\n        loggingObject: dict = None,\n        **kwargs,\n    ) -> None:\n        \"\"\"\n        Instanciate the class for Query Service call.\n        Arguments:\n            config : OPTIONAL : config object in the config module. (DO NOT MODIFY)\n            header : OPTIONAL : header object  in the config module. (DO NOT MODIFY)\n            loggingObject : OPTIONAL : If you want to set logging capability for your actions.\n        kwargs:\n            kwargs will update the header\n        \"\"\"\n        if loggingObject is not None and sorted(\n            [\"level\", \"stream\", \"format\", \"filename\", \"file\"]\n        ) == sorted(list(loggingObject.keys())):\n            self.loggingEnabled = True\n            self.logger = logging.getLogger(f\"{__name__}\")\n            self.logger.setLevel(loggingObject[\"level\"])\n            if type(loggingObject[\"format\"]) == str:\n                formatter = logging.Formatter(loggingObject[\"format\"])\n            elif type(loggingObject[\"format\"]) == logging.Formatter:\n                formatter = loggingObject[\"format\"]\n            if loggingObject[\"file\"]:\n                fileHandler = logging.FileHandler(loggingObject[\"filename\"])\n                fileHandler.setFormatter(formatter)\n                self.logger.addHandler(fileHandler)\n            if loggingObject[\"stream\"]:\n                streamHandler = logging.StreamHandler()\n                streamHandler.setFormatter(formatter)\n                self.logger.addHandler(streamHandler)\n        if type(config) == dict: ## Supporting either default setup or passing a ConnectObject\n            config = config\n        elif type(config) == ConnectObject:\n            header = config.getConfigHeader()\n            config = config.getConfigObject()\n        self.connector = connector.AdobeRequest(\n            config=config,\n            header=header,\n            loggingEnabled=self.loggingEnabled,\n            logger=self.logger,\n        )\n        self.header = self.connector.header\n        # self.header.update({\"Accept\": \"application/json\"})\n        self.header.update(**kwargs)\n        if kwargs.get('sandbox',None) is not None: ## supporting sandbox setup on class instanciation\n            self.sandbox = kwargs.get('sandbox')\n            self.connector.config[\"sandbox\"] = kwargs.get('sandbox')\n            self.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n            self.connector.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n        else:\n            self.sandbox = self.connector.config[\"sandbox\"]\n        self.endpoint = aepp.config.endpoints[\"global\"] + aepp.config.endpoints[\"query\"]\n\n    def getResource(\n        self,\n        endpoint: str = None,\n        params: dict = None,\n        format: str = \"json\",\n        save: bool = False,\n        **kwargs,\n    ) -> dict:\n        \"\"\"\n        Template for requesting data with a GET method.\n        Arguments:\n            endpoint : REQUIRED : The URL to GET\n            params: OPTIONAL : dictionary of the params to fetch\n            format : OPTIONAL : Type of response returned. Possible values:\n                json : default\n                txt : text file\n                raw : a response object from the requests module\n        \"\"\"\n        if endpoint is None:\n            raise ValueError(\"Require an endpoint\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getResource\")\n        res = self.connector.getData(endpoint, params=params, format=format)\n        if save:\n            if format == \"json\":\n                aepp.saveFile(\n                    module=\"catalog\",\n                    file=res,\n                    filename=f\"resource_{int(time.time())}\",\n                    type_file=\"json\",\n                    encoding=kwargs.get(\"encoding\", \"utf-8\"),\n                )\n            elif format == \"txt\":\n                aepp.saveFile(\n                    module=\"catalog\",\n                    file=res,\n                    filename=f\"resource_{int(time.time())}\",\n                    type_file=\"txt\",\n                    encoding=kwargs.get(\"encoding\", \"utf-8\"),\n                )\n            else:\n                print(\n                    \"element is an object. Output is unclear. No save made.\\nPlease save this element manually\"\n                )\n        return res\n\n    def connection(self) -> dict:\n        \"\"\"\n        Create a connection for interactive interface.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Getting a connection\")\n        path = \"/connection_parameters\"\n        res = self.connector.getData(self.endpoint + path, headers=self.header)\n        return res\n\n    def getQueries(\n        self,\n        orderby: str = None,\n        limit: int = 1000,\n        start: int = None,\n        n_results: int = 1000,\n        property: str = None,\n        **kwargs,\n    ) -> list:\n        \"\"\"\n        Retrieve the queries from your organization.\n        Arguments:\n            orderby : OPTIONAL : possibility to order by \"created\" or \"updated\".\n            prepend with \"+\" for ASC and \"-\" for DESC. To be escaped (default: -)\n            limit : OPTIONAL : number of of records to fetch per page. (default 1000)\n            start : OPTIONAL : when to start (depending on your orderby)\n            property : OPTIONAL : Comma-separated filters. List of properties that allow filtering with all operators:\n                        \"created\"\n                        \"updated\"\n                        \"state\"\n                        \"id\"\n                    with following operators >, <, >=, <=, ==, !=, ~\n                \"referenced_datasets\", \"scheduleId\", \"templateId\", and \"userId\" can only be used with ==. Multiple datasets ID with \"||\"\n                \"SQL\" can only be used with ~ (WITHOUT COMMA)\n            n_results : OPTIONAL : total number of results returned (default 1000, set to \"inf\" to retrieve everything)\n        possible kwargs:\n            excludeSoftDeleted: Whether to include any queries that have been soft deleted. Defaults to true.\n            excludeHidden : Whether to include any queries that have been found to be not interesting, as they were not user driven. Examples include CURSOR definitions, FETCH, and Metadata queries. Defaults to true.\n            isPrevLink : Field indicating if the URI is a previous link.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getQueries\")\n        path = \"/queries\"\n        arguments = {\"limit\": 1000}\n        n_results = float(n_results)\n        if orderby is not None:\n            if orderby == \"+\":\n                orderby = \"%2B\"\n            arguments[\"orderby\"] = orderby\n        if start is not None:\n            arguments[\"start\"] = start\n        if limit is not None:\n            arguments[\"limit\"] = limit\n        if property is not None:\n            arguments[\"property\"] = property\n        if len(kwargs.keys()) > 0:\n            arguments[\"excludeSoftDeleted\"] = kwargs.get(\"excludeSoftDeleted\", True)\n            arguments[\"excludeHidden\"] = kwargs.get(\"excludeHidden\", True)\n            arguments[\"isPrevLink\"] = kwargs.get(\"isPrevLink\", \"\")\n        res:dict = self.connector.getData(self.endpoint + path, params=arguments)\n        data:list = res.get(\"queries\",[])\n        nextPage = res.get(\"_links\",{}).get(\"next\", {}).get(\"href\", \"\")\n        while nextPage != \"\":\n            hrefParams = nextPage.split(\"?\")[1]\n            orderBy = re.search(\"orderby=(.+?)(&|$)\", hrefParams)\n            start = re.search(\"start=(.+?)(&|$)\", hrefParams)\n            arguments[\"start\"] = start.group(1)\n            arguments[\"orderby\"] = orderBy.group(1)\n            res = self.connector.getData(self.endpoint + path, params=arguments)\n            data += res.get(\"queries\", [])\n            nextPage = res.get(\"_links\", {}).get(\"next\", {}).get(\"href\", \"\")\n            if n_results < float(\n                len(data)\n            ):  ## forcing exit when reaching number of results asked\n                nextPage = \"\"\n        return data\n\n    def postQueries(\n        self,\n        data: dict = None,\n        name: str = None,\n        dbname: str = \"prod:all\",\n        sql: str = None,\n        templateId: str = None,\n        queryParameters: dict = None,\n        insertIntoParameters: dict = None,\n        ctasParameters: dict = None,\n        description: str = \"\",\n        **kwargs,\n    ) -> dict:\n        \"\"\"\n        Create a query.\n        Arguments:\n            data : OPTIONAL : If you want to pass the full query statement.\n            name : REQUIRED : Name of the query\n            dbname : REQUIRED : the dataset name (default prod:all)\n            sql: REQUIRED : the SQL query as a string.\n            queryParameters : OPTIONAL : in case you are using template, providing the paramter in a dictionary.\n            insertIntoParameters : OPTIONAL : in case you want to insert the result to an existing dataset\n                example : {\n                    \"datasetName\": \"string\"\n                }\n            ctasParameters: OPTIONAL : in case you want to create a dataset out of that query, dictionary is required with \"datasetName\" and \"description\".\n                example : {\n                    \"datasetName\": \"string\",\n                    \"description\": \"string\",\n                    \"targetSchemaTitle\":\"string\"\n                    }\n                    targetSchemaTitle if you want to use a precreated schema.\n        \"\"\"\n        path = \"/queries\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting postQuery\")\n        if data is None:\n            if (sql is None and templateId is None) or name is None:\n                raise AttributeError(\"You are missing required arguments.\")\n            if type(ctasParameters) is dict:\n                if (\n                    \"datasetName\" not in ctasParameters.keys()\n                    or \"description\" not in ctasParameters.keys()\n                ):\n                    raise KeyError(\n                        'Expecting \"datasetName\" and \"description\" as part of the the ctasParameters dictionary.'\n                    )\n            data = {\n                \"name\": name,\n                \"description\": description,\n                \"dbName\": dbname\n            }\n            if sql is not None:\n                data[\"sql\"] = sql\n            if templateId is not None:\n                data[\"templateId\"] = templateId\n            if queryParameters is not None:\n                data[\"queryParameters\"] = queryParameters\n            if ctasParameters is not None:\n                data[\"ctasParameters\"] = ctasParameters\n            if insertIntoParameters is not None:\n                data[\"insertIntoParameters\"] = insertIntoParameters\n        res = self.connector.postData(\n            self.endpoint + path, data=data, headers=self.header\n        )\n        return res\n\n    def getQuery(self, queryId: str = None) -> dict:\n        \"\"\"\n        Request the query status by ID.\n        Argument :\n            queryid : REQUIRED : the query id to check\n        \"\"\"\n        if queryId is None:\n            raise AttributeError('Expected \"queryId\" to be filled')\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getQuery\")\n        path = f\"/queries/{queryId}\"\n        res = self.connector.getData(self.endpoint + path, headers=self.header)\n        return res\n\n    def cancelQuery(self, queryId: str = None) -> dict:\n        \"\"\"\n        Cancel a specific query based on its ID.\n        Argument:\n            queryId : REQUIRED : the query ID to cancel\n        \"\"\"\n        if queryId is None:\n            raise AttributeError('Expected \"queryId\" to be filled')\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting cancelQuery\")\n        path = f\"/queries/{queryId}\"\n        data = {\"op\": \"cancel\"}\n        res = self.connector.patchData(self.endpoint + path, data=data)\n        return res\n\n    def deleteQuery(self, queryId: str = None) -> dict:\n        \"\"\"\n        Delete a specific query based on its ID.\n        Argument:\n            queryId : REQUIRED : the query ID to delete\n        \"\"\"\n        if queryId is None:\n            raise AttributeError('Expected \"queryId\" to be filled')\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteQuery\")\n        path = f\"/queries/{queryId}\"\n        res = self.connector.deleteData(self.endpoint + path)\n        return res\n\n    def getSchedules(self, n_results: int = 1000, **kwargs) -> list:\n        \"\"\"\n        Retrieve a list of scheduled queries for the AEP instance.\n        Arguments:\n            n_results : OPTIONAL : Total number of scheduled queries retrieved. To get them all, use \"inf\"\n        possibile kwargs:\n            orderby : + for ASC and - for DESC\n            limit : number of record to fetch\n            start : specific start (use with orderby)\n            property : Comma-separated filters.\n                created ; ex : created>2017-04-05T13:30:00Z\n                templateId ; ex : templateId==123412354\n                userId ; ex : userId==12341235\n        \"\"\"\n        n_results = float(n_results)\n        if kwargs.get(\"orderby\", None) is not None:\n            if kwargs.get(\"orderby\", \"-\") == \"+\":\n                kwargs.get(\"orderby\", \"-\") == \"%2B\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getSchedules\")\n        path = \"/schedules\"\n        params = {**kwargs}\n        res = self.connector.getData(self.endpoint + path, params=params)\n        data = res[\"schedules\"]\n        nextPage = res[\"_links\"].get(\"next\", {}).get(\"href\", \"\")\n        while nextPage != \"\":\n            hrefParams = nextPage.split(\"?\")[1]\n            orderBy = re.search(\"orderby=(.+?)(&|$)\", hrefParams)\n            start = re.search(\"start=(.+?)(&|$)\", hrefParams)\n            params[\"start\"] = start.group(1)\n            params[\"orderby\"] = orderBy.group(1)\n            res = self.connector.getData(self.endpoint + path, params=params)\n            data += res.get(\"schedules\", [])\n            nextPage = res[\"_links\"].get(\"next\", {}).get(\"href\", \"\")\n            if len(data) > float(n_results):\n                nextPage = \"\"\n        return data\n\n    def getSchedule(self, scheduleId: str = None) -> dict:\n        \"\"\"\n        Get a details about a schedule query.\n        Arguments:\n            scheduleId : REQUIRED : the schedule id\n        \"\"\"\n        if scheduleId is None:\n            raise Exception(\"scheduleId is required\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getSchedule\")\n        path = f\"/schedules/{scheduleId}\"\n        res = self.connector.getData(self.endpoint + path)\n        return res\n\n    def getScheduleRuns(self, scheduleId: str = None) -> list:\n        \"\"\"\n        Get the different jobs ran for this schedule\n        Arguments:\n            scheduleId : REQUIRED : the schedule id\n        \"\"\"\n        if scheduleId is None:\n            raise Exception(\"scheduleId is required\")\n        path = f\"/schedules/{scheduleId}/runs\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getScheduleRuns\")\n        params = {}\n        res = self.connector.getData(self.endpoint + path)\n        data = res[\"runsSchedules\"]\n        nextPage = res[\"_links\"].get(\"next\", {}).get(\"href\", \"\")\n        while nextPage != \"\":\n            hrefParams = nextPage.split(\"?\")[1]\n            orderBy = re.search(\"orderby=(.+?)(&|$)\", hrefParams)\n            start = re.search(\"start=(.+?)(&|$)\", hrefParams)\n            params[\"start\"] = start.group(1)\n            params[\"orderby\"] = orderBy.group(1)\n            res = self.connector.getData(self.endpoint + path, params=params)\n            data += res.get(\"runsSchedules\", [])\n            nextPage = res[\"_links\"].get(\"next\", {}).get(\"href\", \"\")\n        return data\n\n    def getScheduleRun(self, scheduleId: str = None, runId: str = None) -> dict:\n        \"\"\"\n        Get the different jobs ran for this schedule\n        Arguments:\n            scheduleId : REQUIRED : the schedule id\n            runId : REQUIRED : the run ID you want to retrieve.\n        \"\"\"\n        if scheduleId is None or runId is None:\n            raise Exception(\"scheduleId and jobId are required\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getScheduleRun\")\n        path = f\"/schedules/{scheduleId}/runs/{runId}\"\n        res = self.connector.getData(self.endpoint + path)\n        return res\n\n    def createSchedule(\n        self,\n        scheduleQuery: dict = None,\n        name: str = None,\n        dbname: str = \"prod:all\",\n        sql: str = None,\n        templateId: str = None,\n        queryParameters: dict = None,\n        insertIntoParameters: dict = None,\n        ctasParameters: dict = None,\n        schedule: dict = None,\n        description: str = \"\",\n        **kwargs,\n    ) -> dict:\n        \"\"\"\n        Create a scheduled query.\n        Arguments:\n            scheduleQuery: REQUIRED : a dictionary containing the query and the schedule.\n            name : OPTIONAL : Name of the query\n            dbname : OPTIONAL : the dataset name (default prod:all)\n            sql: OPTIONAL : the SQL query as a string.\n            templateId : OPTIONAL : The Template ID to be used\n            queryParameters : OPTIONAL : in case you are using template, providing the paramter in a dictionary.\n            ctasParameters: OPTIONAL : in case you want to create a dataset out of that query, dictionary is required with \"datasetName\" and \"description\".\n            schedule : OPTIONAL : Dictionary giving the instruction to schedule the query.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createSchedule\")\n        if scheduleQuery is None:\n            if name is None or (sql is None and templateId is None) or schedule is None:\n                raise Exception(\n                    \"Expecting either scheduleQUery dictionary or data in parameters\"\n                )\n            scheduleQuery = {\n                \"query\": {\n                    \"name\": name,\n                    \"description\": description,\n                    \"dbName\": dbname\n                },\n                \"schedule\": schedule,\n            }\n            if sql is not None:\n                scheduleQuery[\"query\"][\"sql\"] = sql\n            if templateId is not None:\n                scheduleQuery[\"query\"][\"templateId\"] = templateId\n            if queryParameters is not None:\n                scheduleQuery[\"query\"][\"queryParameters\"] = queryParameters\n            if ctasParameters is not None:\n                scheduleQuery[\"query\"][\"ctasParameters\"] = ctasParameters\n            if insertIntoParameters is not None:\n                scheduleQuery[\"query\"][\"insertIntoParameters\"] = insertIntoParameters\n        if type(scheduleQuery) != dict:\n            raise Exception(\"scheduleQuery is required and should be dictionary. \")\n        if (\n            \"query\" not in scheduleQuery.keys()\n            or \"schedule\" not in scheduleQuery.keys()\n        ):\n            raise Exception(\n                'scheduleQuery dictonary is expected to contain \"schedule\" or \"query\" keys.'\n            )\n        path = \"/schedules\"\n        res = self.connector.postData(self.endpoint + path, data=scheduleQuery)\n        return res\n\n    def deleteSchedule(self, scheduleId: str = None) -> Union[str, dict]:\n        \"\"\"\n        Delete a scheduled query.\n        Arguments:\n            scheduleId : REQUIRED : id of the schedule.\n        \"\"\"\n        if scheduleId is None:\n            raise Exception(\"Missing scheduleId\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteSchedules\")\n        path = f\"/schedules/{scheduleId}\"\n        res = self.connector.deleteData(self.endpoint + path)\n        return res\n\n    def disableSchedule(self, scheduleId: str = None) -> dict:\n        \"\"\"\n        Disable a scheduled query.\n        Arguments:\n            scheduleId : REQUIRED : id of the schedule.\n        \"\"\"\n        if scheduleId is None:\n            raise Exception(\"Missing scheduleId\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting disableSchedules\")\n        obj = {\"body\": [{\"op\": \"replace\", \"path\": \"/state\", \"value\": \"disable\"}]}\n        path = f\"/schedules/{scheduleId}\"\n        res = self.connector.patchData(\n            self.endpoint + path, data=obj, headers=self.header\n        )\n        return res\n\n    def enableSchedule(self, scheduleId: str = None) -> dict:\n        \"\"\"\n        Enable a scheduled query.\n        Arguments:\n            scheduleId : REQUIRED : id of the schedule.\n        \"\"\"\n        if scheduleId is None:\n            raise Exception(\"Missing scheduleId\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting enableSchedule\")\n        obj = {\"body\": [{\"op\": \"replace\", \"path\": \"/state\", \"value\": \"enable\"}]}\n        path = f\"/schedules/{scheduleId}\"\n        res = self.connector.patchData(\n            self.endpoint + path, data=obj, headers=self.header\n        )\n        return res\n\n    def updateSchedule(self, scheduleId: str = None, update_obj: list = None) -> dict:\n        \"\"\"\n        Update the schedule query with the object pass.\n        Arguments:\n            scheduleId : REQUIRED : id of the schedule.\n            update_obj : REQUIRED : List of patch operations\n        \"\"\"\n        if scheduleId is None:\n            raise Exception(\"Missing scheduleId\")\n        if update_obj is None:\n            raise Exception(\"Missing update_obj to generate the operation.\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting updateSchedules\")\n        path = f\"/schedules/{scheduleId}\"\n        res = self.connector.patchData(\n            self.endpoint + path, data=update_obj, headers=self.header\n        )\n        return res\n\n    def getTemplates(self, n_results: int = 1000, **kwargs) -> dict:\n        \"\"\"\n        Retrieve the list of template for this instance.\n        Arguments:\n            n_results : OPTIONAL : number of total results to retrieve. To get them all, use \"inf\".\n        possible kwargs:\n            limit : Hint on number of records to fetch per page. default (50)\n            orderby : Field to order results by. Supported fields: created, updated. Prepend property name with + for ASC,- for DESC order. Default is -created.\n            start : Start value of property specified using orderby.\n            property : Comma-separated filters.List of properties that allow filtering:\n                    name\n                    userId\n                    lastUpdatedBy\n                operations:\n                    \u2018~\u2019 (contains). This operator can only be used on the name property.\n                    \u2018==\u2019 (equal to). This operator can be used on both the userId and the lastUpdatedBy properties.\n        more details here : https://www.adobe.io/apis/experienceplatform/home/api-reference.html#/Query-Templates/get_query_templates\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getTemplates\")\n        path = \"/query-templates\"\n        n_results = float(n_results)  # changing inf to float inf\n        params = {**kwargs}\n        params[\"limit\"] = kwargs.get(\"limit\", 50)\n        res = self.connector.getData(\n            self.endpoint + path, headers=self.header, params=params\n        )\n        data = res[\"templates\"]\n        nextPage = res[\"_links\"].get(\"next\", {}).get(\"href\", \"\")\n        while nextPage != \"\":\n            hrefParams = nextPage.split(\"?\")[1]\n            orderBy = re.search(\"orderby=(.+?)(&|$)\", hrefParams)\n            start = re.search(\"start=(.+?)(&|$)\", hrefParams)\n            params[\"start\"] = start.group(1)\n            params[\"orderby\"] = orderBy.group(1)\n            res = self.connector.getData(self.endpoint + path, params=params)\n            data += res.get(\"templates\", [])\n            nextPage = res.get(\"_links\", {}).get(\"next\", {}).get(\"href\", \"\")\n            if len(data) > float(n_results):\n                nextPage = \"\"\n        return data\n\n    def getTemplate(self, templateId: str = None) -> dict:\n        \"\"\"\n        Retrieve a specific template ID.\n        Arguments:\n            templateId : REQUIRED : template ID to be retrieved.\n        \"\"\"\n        if templateId is None:\n            raise ValueError(\"Require a template ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getTemplate\")\n        path = f\"/query-templates/{templateId}\"\n        res = self.connector.getData(self.endpoint + path)\n        return res\n\n    def deleteTemplate(self, templateId: str = None) -> dict:\n        \"\"\"\n        Delete a template based on its ID.\n        Arguments:\n            templateId : REQUIRED : template ID to be deleted.\n        \"\"\"\n        if templateId is None:\n            raise ValueError(\"Require a template ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteTemplate\")\n        path = f\"/query-templates/{templateId}\"\n        res = self.connector.deleteData(self.endpoint + path)\n        return res\n\n    def createQueryTemplate(self, queryData: dict = None) -> dict:\n        \"\"\"\n        Create a query template based on the dictionary passed.\n        Arguments:\n            queryData : REQUIED : An object that contains \"sql\", \"queryParameter\" and \"name\" keys.\n        more info : https://www.adobe.io/apis/experienceplatform/home/api-reference.html#/Query-Templates/create_query_template\n        \"\"\"\n        path = \"/query-templates\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createTemplate\")\n        if isinstance(queryData, dict):\n            if (\n                \"sql\" not in queryData.keys()\n                or \"queryParameters\" not in queryData.keys()\n                or \"name\" not in queryData.keys()\n            ):\n                raise KeyError(\n                    \"Minimum key value are not respected.\\nPlease see here for more info :\\nhttps://www.adobe.io/apis/experienceplatform/home/api-reference.html#/Query-Templates/create_query_template \"\n                )\n        else:\n            raise Exception(\"expected a dictionary for queryData\")\n        res = self.connector.postData(\n            self.endpoint + path, headers=self.header, data=queryData\n        )\n        return res\n    \n    def getDatasetStatistics(self,datasetId:str=None,statisticType:str=\"table HTTP/1.1\")->dict:\n        \"\"\"\n        Returns statistics on the dataset size.\n        Arguments:\n            datasetId : REQUIRED : The dataset ID to look for.\n            statisticType : OPTIONAL : The type of statistic to retrieve.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getDatasetStatistics\")\n        if datasetId is None:\n            raise Exception(\"A datasetId is required\")\n        path = \"/statistics\"\n        params = {\"dataSet\":datasetId,\"statisticType\":statisticType}\n        res = self.connector.getData(self.endpoint + path,params=params)\n        return res\n    \n    def getAlertSubscriptions(self,n_results: int = 1000, **kwargs)->list:\n        \"\"\"\n        Get the list of alerts subscriptions.\n        Arguments:\n            n_results : OPTIONAL : The total number of result you want.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getAlertSubscriptions\")\n        params = {\"page\":kwargs.get(\"page\",0)}\n        path = f\"/alert-subscriptions\"\n        res = self.connector.getData(self.endpoint + path,params=params)\n        data = res.get(\"alerts\")\n        count = res.get(\"_page\",{}).get('count',0)\n        nextpage = res.get('_links',{}).get('next',{}).get('href','')\n        while nextpage != \"\" and count <n_results:\n            params[\"page\"] += 1\n            res = self.connector.getData(self.endpoint + path,params=params)\n            data += res.get(\"alerts\")\n            count += res.get(\"_page\",{}).get('count',0)\n            nextpage = res.get('_links',{}).get('next',{}).get('href','')\n        return data\n    \n    def createAlertSubscription(self,assetId:str=None,alertType:str=None,emails:list=None,inAEP:bool=True,inEmail:bool=True)->dict:\n        \"\"\"\n        Create a subscription to an asset (queryID or scheduleID) for a list of predefined users.\n        Arguments:\n            assetId : REQUIRED : The schedule ID or query ID.\n            alertType : REQUIRED : The type of alert to listen to. (start, success, failure)\n            emails : REQUIRED : A list of email addresses that subscribes to that alert.\n            inAEP : OPTIONAL : If the Alert should show up in AEP UI. (default True)\n            inEmail : OPTIONAL : If the Alert should be sent via email. (default True)\n                NOTE: Consider setting your email address for notification via this tutorial:\n                https://experienceleague.adobe.com/docs/experience-platform/observability/alerts/ui.html?lang=en#enable-email-alerts\n        \"\"\"\n        if assetId is None:\n            raise ValueError(\"Require an asset ID\")\n        if alertType is None:\n            raise ValueError(\"Require an alert type\")\n        if emails is None or type(emails) != list:\n            raise ValueError(\"Require a list of email addresses\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createAlertSubscription for asset: {assetId}\")\n        path = f\"/alert-subscriptions\"\n        data = {\n            \"assetId\": assetId,\n            \"alertType\": alertType,\n            \"subscriptions\":{\n                \"emailIds\" : emails,\n                \"inContextNotifications\" : inAEP,\n                \"emailNotifications\":inEmail\n            }  \n        }\n        res = self.connector.postData(self.endpoint+path, data=data)\n        return res\n    \n    def deleteAlertSubscription(self,assetId:str=None, alertType:str=None)->dict:\n        \"\"\"\n        Delete a subscription for a specific alert on a specifc assetId.\n        Arguments\n            assetId : REQUIRED : A query ID or a schedule ID that you want to delete the alert for.\n            alertType : REQUIRED : The state of query execution that triggers the alert to be deleted. (start, success, failure).\n        \"\"\"\n        if assetId is None:\n            raise ValueError(\"Require an asset ID\")\n        if alertType is None:\n            raise ValueError(\"Require an alert type\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteAlertSubscription for asset: {assetId}\")\n        path = f\"/alert-subscriptions/{assetId}/{alertType}\"\n        res = self.connector.deleteData(self.endpoint + path)\n        return res\n    \n    def getAlertSubscriptionsTypeId(self,assetId:str=None, alertType:str=None)->dict:\n        \"\"\"\n        Retrieve the subscriptions made about a specific asset ID and with or without alertType specification\n        Arguments:\n            assetId : REQUIRED : A query or schedule ID that you want the subscription information for.\n            alertType : OPTIONAL : This property describes the state of query execution that triggers an alert.\n                        (start, success, failure).\n        \"\"\"\n        if assetId is None:\n            raise ValueError(\"Require an asset ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getAlertSubscriptionsTypeId for asset: {assetId}\")\n        if alertType is None:\n            path = f\"/alert-subscriptions/{assetId}\"\n        elif alertType is not None and type(alertType) == str:\n            path = f\"/alert-subscriptions/{assetId}/{alertType}\"\n        res = self.connector.getData(self.endpoint + path)\n        return res.get('alerts')\n    \n    def patchAlert(self,assetId:str=None, alertType:str=None,action:str=\"disable\")->dict:\n        \"\"\"\n        Disable or Enable an alert by providing the assetId and the alertType.\n        Arguments:\n            assetId : REQUIRED : A query or schedule ID that you want the subscription information for.\n            alertType : REQUIRED : This property describes the state of query execution that triggers an alert.\n                        (start, success, failure)\n            action : OPTIONAL : the action to take on that Alert. \"disable\" (default) or \"enable\"\n        \"\"\"\n        if assetId is None:\n            raise ValueError(\"Require an asset ID\")\n        if alertType is None:\n            raise ValueError(\"Require an alert Type\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting patchAlert for asset: {assetId}, action : {action}\")\n        path = f\"/alert-subscriptions/{assetId}/{alertType}\"\n        data = {\n            \"op\":\"replace\",\n            \"path\":\"/status\",\n            \"value\":action\n        }\n        res = self.connector.patchData(self.endpoint + path,data=data)\n        return res\n    \n    def getUserAlerts(self,email:str=None)->list:\n        \"\"\"\n        Get the alert that a specific user is subscribed to.\n        Argument:\n            email : REQUIRED : the email address of the user\n        \"\"\"\n        if email is None:\n            raise ValueError(\"Require a valid email address\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getUserAlerts for user: {email}\")\n        params = {'page':0}\n        path = f\"/alert-subscriptions/user-subscriptions/{email}\"\n        res = self.connector.getData(self.endpoint + path)\n        data = res.get('items')\n        nextPage = res.get('_links',{}).get('next',{}).get('href','')\n        while nextPage != \"\":\n            params['page'] +=1\n            res = self.connector.getData(self.endpoint + path,params=params)\n            data += res.get('items')\n            nextPage = res.get('_links',{}).get('next',{}).get('href','')\n        return data\n    \n    def createAcceleratedQuery(self,name:str=None,dbName:str=None,sql:str=None,templateId:str=None,description:str=\"power by aepp\")->dict:\n        \"\"\"\n        Create an accelerated query statement based on either an SQL statement or a template ID.\n        Arguments:\n            name : REQUIRED : Name of your query\n            dbName : REQUIRED : The name of the database you are making an accelerated query to. \n                        The value for dbName should take the format of {SANDBOX_NAME}:{ACCELERATED_STORE_DATABASE}:{ACCELERATED_STORE_SCHEMA}\n            sql : REQUIRED : Either this parameter with a SQL statement or a templateId in the \"templateId\" parameter.\n            templateId : REQUIRED : Either this parameter with a template ID or a SQL statement in the \"sql\" parameter.\n            description : OPTIONAL : An optional comment on the intent of the query to help other users understand its purpose. Max 1000 bytes.\n        \"\"\"\n        if name is None:\n            raise ValueError(\"Require a name\")\n        if dbName is None or len(dbName.split(\":\")) != 3:\n            raise ValueError(\"Require a dbName such as : {SANDBOX_NAME}:{ACCELERATED_STORE_DATABASE}:{ACCELERATED_STORE_SCHEMA}\")\n        if templateId is None and sql is None:\n            raise SyntaxError(\"Require either an sql or a templateId parameter\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createAcceleratedQuery with name: {name}\")\n        path = f\"/accelerated-queries\"\n        data = {\n            \"name\" : name,\n            \"dbName\":dbName,\n            \"description\":description,    \n        }\n        if sql is not None:\n            data['sql'] = sql\n        elif templateId is not None:\n            data['templateId'] = templateId\n        res = self.connector.postData(self.endpoint+path, data=data)\n        return res", "\n\n\n\n\nclass InteractiveQuery:\n    \"\"\"\n    Provide the instance connected to PostgreSQL database and you can return the result directly in your notebook.\n    This class requires that you have used connection method in the QueryService.\n    The object returned by the connection method should be used when creating this object.\n    USING PyGreSQL\n\n    \"\"\"\n    \n    config_object = {}\n    ## logging capability\n    loggingEnabled = False\n    logger = None\n\n    def __init__(self, conn_object: dict = None, loggingObject: dict = None):\n        \"\"\"\n        Importing the pg (PyGreSQL) library and instantiating the connection via the conn_object pass over the instantiation method.\n        Arguments:\n            conn_object : REQUIRED : The dictionary returned via the queryservice api \"connection\"\n        \"\"\"\n        from pg import DB\n        if conn_object is None:\n            raise AttributeError(\n                \"You are missing the conn_object. Use the QueryService to retrieve the object.\"\n            )\n        self.dbname = conn_object[\"dbName\"]\n        self.host = conn_object[\"host\"]\n        self.port = conn_object[\"port\"]\n        self.user = conn_object[\"username\"]\n        self.passwd = conn_object[\"token\"]\n        self.websocketHost = conn_object[\"websocketHost\"]\n        self.config_object = {\n            \"dbname\": self.dbname,\n            \"host\": self.host,\n            \"user\": self.user,\n            \"passwd\": self.passwd,\n            \"port\": self.port,\n        }\n        self.db = DB(**self.config_object)\n        if loggingObject is not None and sorted(\n            [\"level\", \"stream\", \"format\", \"filename\", \"file\"]\n        ) == sorted(list(loggingObject.keys())):\n            self.loggingEnabled = True\n            self.logger = logging.getLogger(f\"{__name__}\")\n            self.logger.setLevel(loggingObject[\"level\"])\n            formatter = logging.Formatter(loggingObject[\"format\"])\n            if loggingObject[\"file\"]:\n                fileHandler = logging.FileHandler(loggingObject[\"filename\"])\n                fileHandler.setFormatter(formatter)\n                self.logger.addHandler(fileHandler)\n            if loggingObject[\"stream\"]:\n                streamHandler = logging.StreamHandler()\n                streamHandler.setFormatter(formatter)\n                self.logger.addHandler(streamHandler)\n\n    def query(\n        self, sql: str = None, output: str = \"dataframe\"\n    ) -> Union[pd.DataFrame, object]:\n        \"\"\"\n        Query the database and return different type of data, depending the format parameters.\n        Requests are limited to return 50 K rows\n        Arguments:\n            sql : REQUIRED : the SQL request you want to realize.\n            output : OPTIONAL : the format you would like to be returned.\n            Possible format:\n                \"raw\" : return the instance of the query object.\n                \"dataframe\" : return a dataframe with the data. (default)\n        \"\"\"\n        if sql is None:\n            raise Exception(\"Required a SQL query\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting query:\\n {sql}\")\n        query = self.db.query(sql)\n        if output == \"raw\":\n            return query\n        elif output == \"dataframe\":\n            data = query.getresult()\n            columns = query.listfields()\n            df = pd.DataFrame(data, columns=columns)\n            return df\n        else:\n            raise KeyError(\"You didn't specify a correct value.\")\n\n    def transformToDataFrame(self, query: object = None) -> pd.DataFrame:\n        \"\"\"\n        This will return you a dataFrame\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting transformToDataFrame\")\n        data = query.getresult()\n        columns = query.listfields()\n        df = pd.DataFrame(data, columns=columns)\n        return df\n\n    def queryIdentity(\n        self,\n        identityId: str = None,\n        fields: list = None,\n        tableName: str = None,\n        output: str = \"dataframe\",\n        fieldId: str = \"ECID\",\n        limit: str = None,\n        save: bool = False,\n        verbose: bool = False,\n    ) -> Union[pd.DataFrame, object]:\n        \"\"\"\n        Return the elements that you have passed in field list and return the output selected.\n        Arguments:\n            identityId : REQUIRED : The ID you want to retrieve\n            fields : REQUIRED : a list of fields you want to return for that ID in your table.\n                example : ['person.name']\n            tableName : REQUIRED : The dataset table name to use\n            output : OPTIONAL : the format you would like to be returned.\n            Possible format:\n                \"raw\" : return the instance of the query object.\n                \"dataframe\" : return a dataframe with the data. (default)\n            fieldId : OPTIONAL : If you want your selection to be based on another field than ECID in IdentityMap.\n            limit : OPTIONAL : If you wish to set a LIMIT on number of row returned.\n            save : OPTIONAL : will save a csv file\n            verbose : OPTIONAL : will display some comment\n        \"\"\"\n        if identityId is None:\n            raise ValueError(\"Require an identity value\")\n        if type(fields) != list:\n            raise ValueError(\"Require a list of fields to be returned\")\n        if tableName is None:\n            raise ValueError(\"Require a dataset table name\")\n        if fieldId == \"ECID\":\n            condition = f\"WHERE identityMap['ECID'][0].id = '{identityId}'\"\n        elif fieldId != \"ECID\" and fieldId is not None:\n            condition = f\"WHERE {fieldId} = '{identityId}'\"\n        else:\n            condition = \"\"\n        if limit is None:\n            limit = \"\"\n        else:\n            limit = f\"LIMIT {limit}\"\n        sql = f\"SELECT {','.join(fields)} FROM {tableName} {condition} {limit}\"\n        if verbose:\n            print(sql)\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting queryIdentity:\\n {sql}\")\n        res = self.query(sql=sql, output=output)\n        if verbose:\n            print(f\"Data is returned in the {output} format\")\n        if save:\n            if isinstance(res, pd.DataFrame):\n                res.to_csv(f\"{identityId}.csv\", index=False)\n            else:\n                data = res.getresult()\n                columns = res.listfields()\n                df = pd.DataFrame(data, columns=columns)\n                df.to_csv(f\"{identityId}.csv\", index=False)\n        return res", "\nclass InteractiveQuery2:\n    \"\"\"\n    Provide the instance connected to PostgreSQL database and you can return the result directly in your notebook.\n    This class requires that you have used connection method in the QueryService.\n    The object returned by the connection method should be used when creating this object.\n    USING psycopg2\n    \"\"\"\n    \n    config_object = {}\n    ## logging capability\n    loggingEnabled = False\n    logger = None\n\n    def __init__(self, conn_object: dict = None, loggingObject: dict = None):\n        \"\"\"\n        Importing the psycopg2 library and instantiating the connection via the conn_object pass over the instantiation method.\n        Arguments:\n            conn_object : REQUIRED : The dictionary returned via the queryservice api \"connection\"\n        \"\"\"\n        import psycopg2\n        if conn_object is None:\n            raise AttributeError(\n                \"You are missing the conn_object. Use the QueryService to retrieve the object.\"\n            )\n        self.dbname = conn_object[\"dbName\"]\n        self.host = conn_object[\"host\"]\n        self.port = conn_object[\"port\"]\n        self.user = conn_object[\"username\"]\n        self.passwd = conn_object[\"token\"]\n        self.config_object = {\n            \"dbname\": self.dbname,\n            \"host\": self.host,\n            \"user\": self.user,\n            \"password\": self.passwd,\n            \"port\": self.port,\n        }\n        self.connect = psycopg2.connect(**self.config_object)\n        if loggingObject is not None and sorted(\n            [\"level\", \"stream\", \"format\", \"filename\", \"file\"]\n        ) == sorted(list(loggingObject.keys())):\n            self.loggingEnabled = True\n            self.logger = logging.getLogger(f\"{__name__}\")\n            self.logger.setLevel(loggingObject[\"level\"])\n            formatter = logging.Formatter(loggingObject[\"format\"])\n            if loggingObject[\"file\"]:\n                fileHandler = logging.FileHandler(loggingObject[\"filename\"])\n                fileHandler.setFormatter(formatter)\n                self.logger.addHandler(fileHandler)\n            if loggingObject[\"stream\"]:\n                streamHandler = logging.StreamHandler()\n                streamHandler.setFormatter(formatter)\n                self.logger.addHandler(streamHandler)\n\n    def query(\n        self, sql: str = None, output: str = \"dataframe\"\n    ) -> Union[pd.DataFrame, object]:\n        \"\"\"\n        Query the database and return different type of data, depending the format parameters.\n        Requests are limited to return 50 K rows\n        Arguments:\n            sql : REQUIRED : the SQL request you want to realize.\n            output : OPTIONAL : the format you would like to be returned.\n            Possible format:\n                \"raw\" : return the instance of the query object.\n                \"dataframe\" : return a dataframe with the data. (default)\n        \"\"\"\n        if sql is None:\n            raise Exception(\"Required a SQL query\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting query:\\n {sql}\")\n        cursor = self.connect.cursor()\n        cursor.execute(sql)\n        if output == \"raw\":\n            return cursor\n        elif output == \"dataframe\":\n            df = pd.DataFrame(cursor.fetchall())\n            df.columns = [col[0] for col in cursor.description]\n            return df\n        else:\n            raise KeyError(\"You didn't specify a correct value.\")\n\n    def transformToDataFrame(self, query: object = None) -> pd.DataFrame:\n        \"\"\"\n        Taking the raw output of the query method use with raw and returning a DataFrame\n        Arguments:\n            cursor : REQUIRED : The cursor that has been returned \n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting transformToDataFrame\")\n        df = pd.DataFrame(query.fetchall())\n        df.columns = [col[0] for col in query.description]\n        return df\n\n    def queryIdentity(\n        self,\n        identityId: str = None,\n        fields: list = None,\n        tableName: str = None,\n        output: str = \"dataframe\",\n        fieldId: str = \"ECID\",\n        limit: str = None,\n        save: bool = False,\n    ) -> Union[pd.DataFrame, object]:\n        \"\"\"\n        Return the elements that you have passed in field list and return the output selected.\n        Arguments:\n            identityId : REQUIRED : The ID you want to retrieve\n            fields : REQUIRED : a list of fields you want to return for that ID in your table.\n                example : ['person.name']\n            tableName : REQUIRED : The dataset table name to use\n            output : OPTIONAL : the format you would like to be returned.\n            Possible format:\n                \"raw\" : return the instance of the query object.\n                \"dataframe\" : return a dataframe with the data. (default)\n            fieldId : OPTIONAL : If you want your selection to be based on another field than ECID in IdentityMap.\n            limit : OPTIONAL : If you wish to set a LIMIT on number of row returned.\n            save : OPTIONAL : will save a csv file\n        \"\"\"\n        if identityId is None:\n            raise ValueError(\"Require an identity value\")\n        if type(fields) != list:\n            raise ValueError(\"Require a list of fields to be returned\")\n        if tableName is None:\n            raise ValueError(\"Require a dataset table name\")\n        if fieldId == \"ECID\":\n            condition = f\"WHERE identityMap['ECID'][0].id = '{identityId}'\"\n        elif fieldId != \"ECID\" and fieldId is not None:\n            condition = f\"WHERE {fieldId} = '{identityId}'\"\n        else:\n            condition = \"\"\n        if limit is None:\n            limit = \"\"\n        else:\n            limit = f\"LIMIT {limit}\"\n        sql = f\"SELECT {','.join(fields)} FROM {tableName} {condition} {limit}\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting queryIdentity:\\n {sql}\")\n        res = self.query(sql)\n        if save:\n            if isinstance(res, pd.DataFrame):\n                res.to_csv(f\"{identityId}.csv\", index=False)\n            else:\n                df = pd.DataFrame(res.fetchall())\n                df.columns = [col[0] for col in res.description]\n                df.to_csv(f\"{identityId}.csv\", index=False)\n        return res", ""]}
{"filename": "aepp/accesscontrol.py", "chunked_list": ["#  Copyright 2023 Adobe. All rights reserved.\n#  This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License. You may obtain a copy\n#  of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software distributed under\n#  the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n#  OF ANY KIND, either express or implied. See the License for the specific language\n#  governing permissions and limitations under the License.\n", "#  governing permissions and limitations under the License.\n\nimport aepp\nfrom aepp import connector\nimport logging\nfrom .configs import ConnectObject\nfrom typing import Union\n\nclass AccessControl:\n    \"\"\"\n    Access Control API endpoints.\n    Complete documentation is available:\n    https://www.adobe.io/apis/experienceplatform/home/api-reference.html#!acpdr/swagger-specs/access-control.yaml\n    \"\"\"\n\n    ## logging capability\n    loggingEnabled = False\n    logger = None\n\n    def __init__(\n        self,\n        config: Union[dict,ConnectObject] = aepp.config.config_object,\n        header: dict =aepp.config.header,\n        loggingObject: dict = None,\n        **kwargs,\n    ) -> None:\n        \"\"\"\n        Instantiate the access controle API wrapper.\n        Arguments:\n            config : OPTIONAL : config object in the config module. (DO NOT MODIFY)\n            header : OPTIONAL : header object  in the config module. (DO NOT MODIFY)\n            loggingObject : OPTIONAL : logging object to log messages.\n        kwargs :\n            header options\n        \"\"\"\n        if loggingObject is not None and sorted(\n            [\"level\", \"stream\", \"format\", \"filename\", \"file\"]\n        ) == sorted(list(loggingObject.keys())):\n            self.loggingEnabled = True\n            self.logger = logging.getLogger(f\"{__name__}\")\n            self.logger.setLevel(loggingObject[\"level\"])\n            if type(loggingObject[\"format\"]) == str:\n                formatter = logging.Formatter(loggingObject[\"format\"])\n            elif type(loggingObject[\"format\"]) == logging.Formatter:\n                formatter = loggingObject[\"format\"]\n            if loggingObject[\"file\"]:\n                fileHandler = logging.FileHandler(loggingObject[\"filename\"])\n                fileHandler.setFormatter(formatter)\n                self.logger.addHandler(fileHandler)\n            if loggingObject[\"stream\"]:\n                streamHandler = logging.StreamHandler()\n                streamHandler.setFormatter(formatter)\n                self.logger.addHandler(streamHandler)\n        if type(config) == dict: ## Supporting either default setup or passing a ConnectObject\n            config = config\n        elif type(config) == ConnectObject:\n            header = config.getConfigHeader()\n            config = config.getConfigObject()\n        self.connector = connector.AdobeRequest(\n            config=config,\n            header=header,\n            loggingEnabled=self.loggingEnabled,\n            logger=self.logger,\n        )\n        if kwargs.get('sandbox',None) is not None: ## supporting sandbox setup on class instanciation\n            self.sandbox = kwargs.get('sandbox')\n            self.connector.config[\"sandbox\"] = kwargs.get('sandbox')\n            self.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n            self.connector.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n        else:\n            self.sandbox = self.connector.config[\"sandbox\"]\n        self.header = self.connector.header\n        self.header.update(**kwargs)\n        self.endpoint = (\n            aepp.config.endpoints[\"global\"] + aepp.config.endpoints[\"access\"]\n        )\n\n    def getReferences(self) -> dict:\n        \"\"\"\n        List all available permission names and resource types.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getReferences\")\n        path = \"/acl/reference\"\n        res = self.connector.getData(self.endpoint + path, headers=self.header)\n        return res\n\n    def postEffectivePolicies(self, listElements: list = None):\n        \"\"\"\n        List all effective policies for a user on given resources within a sandbox.\n        Arguments:\n            listElements : REQUIRED : List of resource urls. Example url : /resource-types/{resourceName} or /permissions/{highLevelPermissionName}\n        \"\"\"\n        if type(listElements) != list:\n            raise TypeError(\"listElements should be a list of elements\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting postEffectivePolicies\")\n        path = \"/acl/effective-policies\"\n        res = self.connector.postData(\n            self.endpoint + path, data=listElements, headers=self.header\n        )\n        return res", "class AccessControl:\n    \"\"\"\n    Access Control API endpoints.\n    Complete documentation is available:\n    https://www.adobe.io/apis/experienceplatform/home/api-reference.html#!acpdr/swagger-specs/access-control.yaml\n    \"\"\"\n\n    ## logging capability\n    loggingEnabled = False\n    logger = None\n\n    def __init__(\n        self,\n        config: Union[dict,ConnectObject] = aepp.config.config_object,\n        header: dict =aepp.config.header,\n        loggingObject: dict = None,\n        **kwargs,\n    ) -> None:\n        \"\"\"\n        Instantiate the access controle API wrapper.\n        Arguments:\n            config : OPTIONAL : config object in the config module. (DO NOT MODIFY)\n            header : OPTIONAL : header object  in the config module. (DO NOT MODIFY)\n            loggingObject : OPTIONAL : logging object to log messages.\n        kwargs :\n            header options\n        \"\"\"\n        if loggingObject is not None and sorted(\n            [\"level\", \"stream\", \"format\", \"filename\", \"file\"]\n        ) == sorted(list(loggingObject.keys())):\n            self.loggingEnabled = True\n            self.logger = logging.getLogger(f\"{__name__}\")\n            self.logger.setLevel(loggingObject[\"level\"])\n            if type(loggingObject[\"format\"]) == str:\n                formatter = logging.Formatter(loggingObject[\"format\"])\n            elif type(loggingObject[\"format\"]) == logging.Formatter:\n                formatter = loggingObject[\"format\"]\n            if loggingObject[\"file\"]:\n                fileHandler = logging.FileHandler(loggingObject[\"filename\"])\n                fileHandler.setFormatter(formatter)\n                self.logger.addHandler(fileHandler)\n            if loggingObject[\"stream\"]:\n                streamHandler = logging.StreamHandler()\n                streamHandler.setFormatter(formatter)\n                self.logger.addHandler(streamHandler)\n        if type(config) == dict: ## Supporting either default setup or passing a ConnectObject\n            config = config\n        elif type(config) == ConnectObject:\n            header = config.getConfigHeader()\n            config = config.getConfigObject()\n        self.connector = connector.AdobeRequest(\n            config=config,\n            header=header,\n            loggingEnabled=self.loggingEnabled,\n            logger=self.logger,\n        )\n        if kwargs.get('sandbox',None) is not None: ## supporting sandbox setup on class instanciation\n            self.sandbox = kwargs.get('sandbox')\n            self.connector.config[\"sandbox\"] = kwargs.get('sandbox')\n            self.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n            self.connector.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n        else:\n            self.sandbox = self.connector.config[\"sandbox\"]\n        self.header = self.connector.header\n        self.header.update(**kwargs)\n        self.endpoint = (\n            aepp.config.endpoints[\"global\"] + aepp.config.endpoints[\"access\"]\n        )\n\n    def getReferences(self) -> dict:\n        \"\"\"\n        List all available permission names and resource types.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getReferences\")\n        path = \"/acl/reference\"\n        res = self.connector.getData(self.endpoint + path, headers=self.header)\n        return res\n\n    def postEffectivePolicies(self, listElements: list = None):\n        \"\"\"\n        List all effective policies for a user on given resources within a sandbox.\n        Arguments:\n            listElements : REQUIRED : List of resource urls. Example url : /resource-types/{resourceName} or /permissions/{highLevelPermissionName}\n        \"\"\"\n        if type(listElements) != list:\n            raise TypeError(\"listElements should be a list of elements\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting postEffectivePolicies\")\n        path = \"/acl/effective-policies\"\n        res = self.connector.postData(\n            self.endpoint + path, data=listElements, headers=self.header\n        )\n        return res", ""]}
{"filename": "aepp/flowservice.py", "chunked_list": ["#  Copyright 2023 Adobe. All rights reserved.\n#  This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License. You may obtain a copy\n#  of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software distributed under\n#  the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n#  OF ANY KIND, either express or implied. See the License for the specific language\n#  governing permissions and limitations under the License.\n", "#  governing permissions and limitations under the License.\n\nimport aepp\nfrom aepp import connector\nfrom copy import deepcopy\nimport time,json\nimport logging\nfrom dataclasses import dataclass\nfrom typing import Union\nfrom .configs import ConnectObject", "from typing import Union\nfrom .configs import ConnectObject\n\n@dataclass\nclass _Data:\n    def __init__(self):\n        self.flowId = {}\n        self.flowSpecId = {}\n\n\nclass FlowService:\n    \"\"\"\n    The Flow Service manage the ingestion part of the data in AEP.\n    For more information, relate to the API Documentation, you can directly refer to the official documentation:\n        https://www.adobe.io/apis/experienceplatform/home/api-reference.html#!acpdr/swagger-specs/flow-service.yaml\n        https://experienceleague.adobe.com/docs/experience-platform/sources/home.html\n        https://experienceleague.adobe.com/docs/experience-platform/destinations/home.html\n    \"\"\"\n\n    PATCH_REFERENCE = [\n        {\n            \"op\": \"Add\",\n            \"path\": \"/auth/params\",\n            \"value\": {\n                \"description\": \"A new description to provide further context on a specified connection or flow.\"\n            },\n        }\n    ]\n\n    ## logging capability\n    loggingEnabled = False\n    logger = None\n\n    def __init__(\n        self,\n        config: Union[dict,ConnectObject] = aepp.config.config_object,\n        header: dict = aepp.config.header,\n        loggingObject: dict = None,\n        **kwargs,\n    ):\n        \"\"\"\n        initialize the Flow Service instance.\n        Arguments:\n            config : OPTIONAL : config object in the config module.\n            header : OPTIONAL : header object  in the config module.\n            loggingObject : OPTIONAL : A dictionary presenting the configuration of the logging service.\n        \"\"\"\n        if loggingObject is not None and sorted(\n            [\"level\", \"stream\", \"format\", \"filename\", \"file\"]\n        ) == sorted(list(loggingObject.keys())):\n            self.loggingEnabled = True\n            self.logger = logging.getLogger(f\"{__name__}\")\n            self.logger.setLevel(loggingObject[\"level\"])\n            if type(loggingObject[\"format\"]) == str:\n                formatter = logging.Formatter(loggingObject[\"format\"])\n            elif type(loggingObject[\"format\"]) == logging.Formatter:\n                formatter = loggingObject[\"format\"]\n            if loggingObject[\"file\"]:\n                fileHandler = logging.FileHandler(loggingObject[\"filename\"])\n                fileHandler.setFormatter(formatter)\n                self.logger.addHandler(fileHandler)\n            if loggingObject[\"stream\"]:\n                streamHandler = logging.StreamHandler()\n                streamHandler.setFormatter(formatter)\n                self.logger.addHandler(streamHandler)\n        if type(config) == dict: ## Supporting either default setup or passing a ConnectObject\n            config = config\n        elif type(config) == ConnectObject:\n            header = config.getConfigHeader()\n            config = config.getConfigObject()\n        self.connector = connector.AdobeRequest(\n            config=config,\n            header=header,\n            loggingEnabled=self.loggingEnabled,\n            logger=self.logger,\n        )\n        self.header = self.connector.header\n        self.header.update(**kwargs)\n        if kwargs.get('sandbox',None) is not None: ## supporting sandbox setup on class instanciation\n            self.sandbox = kwargs.get('sandbox')\n            self.connector.config[\"sandbox\"] = kwargs.get('sandbox')\n            self.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n            self.connector.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n        else:\n            self.sandbox = self.connector.config[\"sandbox\"]\n        self.endpoint = aepp.config.endpoints[\"global\"] + aepp.config.endpoints[\"flow\"]\n        self.endpoint_gloal = aepp.config.endpoints[\"global\"]\n        self.data = _Data()\n\n    def getResource(\n        self,\n        endpoint: str = None,\n        params: dict = None,\n        format: str = \"json\",\n        save: bool = False,\n        **kwargs,\n    ) -> dict:\n        \"\"\"\n        Template for requesting data with a GET method.\n        Arguments:\n            endpoint : REQUIRED : The URL to GET\n            params: OPTIONAL : dictionary of the params to fetch\n            format : OPTIONAL : Type of response returned. Possible values:\n                json : default\n                txt : text file\n                raw : a response object from the requests module\n        \"\"\"\n        if endpoint is None:\n            raise ValueError(\"Require an endpoint\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getResource\")\n        res = self.connector.getData(endpoint, params=params, format=format)\n        if save:\n            if format == \"json\":\n                aepp.saveFile(\n                    module=\"catalog\",\n                    file=res,\n                    filename=f\"resource_{int(time.time())}\",\n                    type_file=\"json\",\n                    encoding=kwargs.get(\"encoding\", \"utf-8\"),\n                )\n            elif format == \"txt\":\n                aepp.saveFile(\n                    module=\"catalog\",\n                    file=res,\n                    filename=f\"resource_{int(time.time())}\",\n                    type_file=\"txt\",\n                    encoding=kwargs.get(\"encoding\", \"utf-8\"),\n                )\n            else:\n                print(\n                    \"element is an object. Output is unclear. No save made.\\nPlease save this element manually\"\n                )\n        return res\n\n    def getConnections(\n        self, limit: int = 20, n_results: int = 100, count: bool = False, **kwargs\n    ) -> list:\n        \"\"\"\n        Returns the list of connections available.\n        Arguments:\n            limit : OPTIONAL : number of result returned per request (default 20)\n            n_results : OPTIONAL : number of total result returned (default 100, set to \"inf\" for retrieving everything)\n            count : OPTIONAL : if set to True, just returns the number of connections\n        kwargs will be added as query parameters\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getConnections\")\n        params = {\"limit\": limit}\n        if count:\n            params[\"count\"] = count\n        for kwarg in kwargs:\n            params[kwarg] = kwargs[kwarg]\n        path = \"/connections\"\n        res = self.connector.getData(self.endpoint + path, params=params)\n        try:\n            data = res[\"items\"]\n            continuationToken = res.get(\"_links\", {}).get(\"next\", {}).get(\"href\", \"\")\n            while continuationToken != \"\" and len(data) < float(n_results):\n                res = self.connector.getData(\n                    self.endpoint + continuationToken, params=params\n                )\n                data += res[\"items\"]\n                continuationToken = (\n                    res.get(\"_links\", {}).get(\"next\", {}).get(\"href\", \"\")\n                )\n            return data\n        except:\n            return res\n\n    def createConnection(\n        self,\n        data: dict = None,\n        name: str = None,\n        auth: dict = None,\n        connectionSpec: dict = None,\n        **kwargs,\n    ) -> dict:\n        \"\"\"\n        Create a connection based on either the data being passed or the information passed.\n        Arguments:\n            data : REQUIRED : dictionary containing the different elements required for the creation of the connection.\n\n            In case you didn't pass a data parameter, you can pass different information.\n            name : REQUIRED : name of the connection.\n            auth : REQUIRED : dictionary that contains \"specName\" and \"params\"\n                specName : string that names of the the type of authentication to be used with the base connection.\n                params : dict that contains credentials and values necessary to authenticate and create a connection.\n            connectionSpec : REQUIRED : dictionary containing the \"id\" and \"verison\" key.\n                id : The specific connection specification ID associated with source\n                version : Specifies the version of the connection specification ID. Omitting this value will default to the most recent version\n        Possible kwargs:\n            responseType : by default json, but you can request 'raw' that return the requests response object.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createConnection\")\n        path = \"/connections\"\n        if data is not None:\n            if (\n                \"name\" not in data.keys()\n                or \"auth\" not in data.keys()\n                or \"connectionSpec\" not in data.keys()\n            ):\n                raise Exception(\n                    \"Require some keys to be present : name, auth, connectionSpec\"\n                )\n            obj = data\n            res = self.connector.postData(self.endpoint + path, data=obj,format=kwargs.get('responseType','json'))\n            return res\n        elif data is None:\n            if \"specName\" not in auth.keys() or \"params\" not in auth.keys():\n                raise Exception(\n                    \"Require some keys to be present in auth dict : specName, params\"\n                )\n            if \"id\" not in connectionSpec.keys():\n                raise Exception(\n                    \"Require some keys to be present in connectionSpec dict : id\"\n                )\n            if name is None:\n                raise Exception(\"Require a name to be present\")\n            obj = {\"name\": name, \"auth\": auth, \"connectionSpec\": connectionSpec}\n            res = self.connector.postData(self.endpoint + path, data=obj,format=kwargs.get('responseType','json'))\n            return res\n\n    def createStreamingConnection(\n        self,\n        name: str = None,\n        sourceId: str = None,\n        dataType: str = \"xdm\",\n        paramName: str = None,\n        description: str = \"provided by aepp\",\n        **kwargs,\n    ) -> dict:\n        \"\"\"\n        Create a Streaming connection based on the following connectionSpec :\n        \"connectionSpec\": {\n                \"id\": \"bc7b00d6-623a-4dfc-9fdb-f1240aeadaeb\",\n                \"version\": \"1.0\",\n            },\n            with provider ID : 521eee4d-8cbe-4906-bb48-fb6bd4450033\n        Arguments:\n            name : REQUIRED : Name of the Connection.\n            sourceId : REQUIRED : The ID of the streaming connection you want to create (random string possible).\n            dataType : REQUIRED : The type of data to ingest (default xdm)\n            paramName : REQUIRED : The name of the streaming connection you want to create.\n            description : OPTIONAL : if you want to add a description\n        kwargs possibility:\n            specName : if you want to modify the specification Name.(Default : \"Streaming Connection\")\n            responseType : by default json, but you can request 'raw' that return the requests response object.\n        \"\"\"\n        if name is None:\n            raise ValueError(\"Require a name for the connection\")\n        if sourceId is None:\n            raise Exception(\"Require an ID for the connection\")\n        if dataType is None:\n            raise Exception(\"Require a dataType specified\")\n        if paramName is None:\n            raise ValueError(\"Require a name for the Streaming Connection\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createStreamingConnection\")\n        obj = {\n            \"name\": name,\n            \"providerId\": \"521eee4d-8cbe-4906-bb48-fb6bd4450033\",\n            \"description\": description,\n            \"connectionSpec\": {\n                \"id\": \"bc7b00d6-623a-4dfc-9fdb-f1240aeadaeb\",\n                \"version\": \"1.0\",\n            },\n            \"auth\": {\n                \"specName\": kwargs.get(\"specName\", \"Streaming Connection\"),\n                \"params\": {\n                    \"sourceId\": sourceId,\n                    \"dataType\": dataType,\n                    \"name\": paramName,\n                },\n            },\n        }\n        res = self.createConnection(data=obj,responseType=kwargs.get('responseType','json'))\n        return res\n\n    def getConnection(self, connectionId: str = None) -> dict:\n        \"\"\"\n        Returns a specific connection object.\n        Argument:\n            connectionId : REQUIRED : The ID of the connection you wish to retrieve.\n        \"\"\"\n        if connectionId is None:\n            raise Exception(\"Require a connectionId to be present\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getConnection\")\n        path = f\"/connections/{connectionId}\"\n        res = self.connector.getData(self.endpoint + path)\n        return res\n\n    def connectionTest(self, connectionId: str = None) -> dict:\n        \"\"\"\n        Test a specific connection ID.\n        Argument:\n            connectionId : REQUIRED : The ID of the connection you wish to test.\n        \"\"\"\n        if connectionId is None:\n            raise Exception(\"Require a connectionId to be present\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting connectionTest\")\n        path: str = f\"/connections/{connectionId}/test\"\n        res: dict = self.connector.getData(self.endpoint + path)\n        return res\n\n    def deleteConnection(self, connectionId: str = None) -> dict:\n        \"\"\"\n        Delete a specific connection ID.\n        Argument:\n            connectionId : REQUIRED : The ID of the connection you wish to delete.\n        \"\"\"\n        if connectionId is None:\n            raise Exception(\"Require a connectionId to be present\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteConnection\")\n        path: str = f\"/connections/{connectionId}\"\n        res: dict = self.connector.deleteData(self.endpoint + path)\n        return res\n\n    def getConnectionSpecs(self) -> list:\n        \"\"\"\n        Returns the list of connectionSpecs in that instance.\n        If that doesn't work, return the response.\n        \"\"\"\n        path: str = \"/connectionSpecs\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getConnectionSpecs\")\n        res: dict = self.connector.getData(self.endpoint + path)\n        try:\n            data: list = res[\"items\"]\n            return data\n        except:\n            return res\n\n    def getConnectionSpecsMap(self) -> dict:\n        \"\"\"\n        Returns a mapping of connection spec name to connection spec ID.\n        If that doesn't work, return the response.\n        \"\"\"\n        specs_info = self.getConnectionSpecs()\n        return {spec[\"name\"]: spec[\"id\"] for spec in specs_info if \"id\" in spec and \"name\" in spec}\n\n    def getConnectionSpec(self, specId: str = None) -> dict:\n        \"\"\"\n        Returns the detail for a specific connection.\n        Arguments:\n            specId : REQUIRED : The specification ID of a connection\n        \"\"\"\n        if specId is None:\n            raise Exception(\"Require a specId to be present\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getConnectionSpec\")\n        path: str = f\"/connectionSpecs/{specId}\"\n        res: dict = self.connector.getData(self.endpoint + path)\n        return res.get('items',[{}])[0]\n\n    def getConnectionSpecIdFromName(self, name: str = None) -> int:\n        \"\"\"\n        Returns the connection spec ID corresponding to a connection spec name.\n        Arguments:\n            name : REQUIRED : The specification name of a connection\n        \"\"\"\n        if name is None:\n            raise Exception(\"Require a name to be present\")\n        spec_name_to_id = self.getConnectionSpecsMap()\n        if name not in spec_name_to_id:\n            raise Exception(f\"Connection spec name '{name}' not found\")\n        return spec_name_to_id[name]\n\n    def getFlows(\n        self,\n        limit: int = 10,\n        n_results: int = 100,\n        prop: str = None,\n        filterMappingSetIds: list = None,\n        filterSourceIds: list = None,\n        filterTargetIds: list = None,\n        **kwargs,\n    ) -> list:\n        \"\"\"\n        Returns the flows set between Source and Target connection.\n        Arguments:\n            limit : OPTIONAL : number of results returned\n            n_results : OPTIONAL : total number of results returned (default 100, set to \"inf\" for retrieving everything)\n            prop : OPTIONAL : comma separated list of top-level object properties to be returned in the response.\n                Used to cut down the amount of data returned in the response body.\n                For example, prop=id==3416976c-a9ca-4bba-901a-1f08f66978ff,6a8d82bc-1caf-45d1-908d-cadabc9d63a6,3c9b37f8-13a6-43d8-bad3-b863b941fedd.\n            filterMappingSetId : OPTIONAL : returns only the flow that possess the mappingSetId passed in a list.\n            filterSourceIds : OPTIONAL : returns only the flow that possess the sourceConnectionIds passed in a list.\n            filterTargetIds : OPTIONAL : returns only the flow that possess the targetConnectionIds passed in a list.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getFlows\")\n        params: dict = {\"limit\": limit, \"count\": kwargs.get(\"count\", False)}\n        if property is not None:\n            params[\"property\"] = prop\n        if kwargs.get(\"continuationToken\", False) != False:\n            params[\"continuationToken\"] = kwargs.get(\"continuationToken\")\n        path: str = \"/flows\"\n        res: dict = self.connector.getData(self.endpoint + path, params=params)\n        token: str = res.get(\"_links\", {}).get(\"next\", {}).get(\"href\", \"\")\n        items = res[\"items\"]\n        while token != \"\" and len(items) < float(n_results):\n            continuationToken = token.split(\"=\")[1]\n            params[\"continuationToken\"] = continuationToken\n            res = self.connector.getData(self.endpoint + path, params=params)\n            token = res[\"_links\"].get(\"next\", {}).get(\"href\", \"\")\n            items += res[\"items\"]\n        self.data.flowId = {item[\"name\"]: item[\"id\"] for item in items}\n        self.data.flowSpecId = {item[\"name\"]: item.get(\"flowSpec\",{}).get('id') for item in items}\n        if filterMappingSetIds is not None:\n            filteredItems = []\n            for mappingsetId in filterMappingSetIds:\n                for item in items:\n                    if \"transformations\" in item.keys():\n                        for element in item[\"transformations\"]:\n                            if element[\"params\"].get(\"mappingId\", \"\") == mappingsetId:\n                                filteredItems.append(item)\n            items = filteredItems\n        if filterSourceIds is not None:\n            filteredItems = []\n            for sourceId in filterSourceIds:\n                for item in items:\n                    if sourceId in item[\"sourceConnectionIds\"]:\n                        filteredItems.append(item)\n            items = filteredItems\n        if filterTargetIds is not None:\n            filteredItems = []\n            for targetId in filterTargetIds:\n                for item in items:\n                    if targetId in item[\"targetConnectionIds\"]:\n                        filteredItems.append(item)\n            items = filteredItems\n        return items\n\n    def getFlow(self, flowId: str = None) -> dict:\n        \"\"\"\n        Returns the details of a specific flow.\n        Arguments:\n            flowId : REQUIRED : the flow ID to be returned\n        \"\"\"\n        if flowId is None:\n            raise Exception(\"Require a flowId to be present\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getFlow\")\n        path: str = f\"/flows/{flowId}\"\n        res: dict = self.connector.getData(self.endpoint + path)\n        return res.get('items',[{}])[0]\n\n    def deleteFlow(self, flowId: str = None) -> dict:\n        \"\"\"\n        Delete a specific flow by its ID.\n        Arguments:\n            flowId : REQUIRED : the flow ID to be returned\n        \"\"\"\n        if flowId is None:\n            raise Exception(\"Require a flowId to be present\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteFlow\")\n        path: str = f\"/flows/{flowId}\"\n        res: dict = self.connector.deleteData(self.endpoint + path)\n        return res\n\n    def createFlow(\n        self,\n        flow_spec_id: str,\n        name: str = None,\n        source_connection_id: str = None,\n        target_connection_id: str = None,\n        schedule_start_time: str = None,\n        schedule_frequency: str = \"minute\",\n        schedule_interval: int = 15,\n        transformation_mapping_id: str = None,\n        transformation_name: str = None,\n        transformation_version: int = 0,\n        obj: dict = None,\n        version: str = \"1.0\"\n    ) -> dict:\n        \"\"\"\n        Create a flow with the API.\n        Arguments:\n            obj : REQUIRED : body to create the flow service.\n                Details can be seen at https://www.adobe.io/apis/experienceplatform/home/api-reference.html#/Flows/postFlow\n                requires following keys : name, flowSpec, sourceConnectionIds, targetConnectionIds, transformations, scheduleParams.\n        \"\"\"\n        if obj is None:\n            if any(param is None for param in [name, source_connection_id, target_connection_id]):\n                raise KeyError(\"Require either obj or all of 'name', 'source_connection_id', 'target_connection_id'\")\n            if schedule_frequency not in (\"minute\", \"hour\"):\n                raise ValueError(\"schedule frequency has to be either minute or hour\")\n            obj = {\n                \"name\": name,\n                \"flowSpec\": {\n                    \"id\": flow_spec_id,\n                    \"version\": version\n                },\n                \"sourceConnectionIds\": [\n                    source_connection_id\n                ],\n                \"targetConnectionIds\": [\n                    target_connection_id\n                ],\n                \"transformations\": [],\n                \"scheduleParams\": {}\n            }\n            if schedule_start_time is not None:\n                obj[\"scheduleParams\"][\"startTime\"] = schedule_start_time\n            if schedule_frequency is not None:\n                obj[\"scheduleParams\"][\"frequency\"] = schedule_frequency\n            if schedule_interval is not None:\n                obj[\"scheduleParams\"][\"interval\"] = str(schedule_interval)\n            if transformation_mapping_id is not None:\n                obj[\"transformations\"] = [\n                    {\n                        \"name\": transformation_name,\n                        \"params\": {\n                            \"mappingId\": transformation_mapping_id,\n                            \"mappingVersion\": transformation_version\n                        }\n                    }\n                ]\n        else:\n            if \"name\" not in obj.keys():\n                raise KeyError(\"missing 'name' parameter in the dictionary\")\n            if \"flowSpec\" not in obj.keys():\n                raise KeyError(\"missing 'flowSpec' parameter in the dictionary\")\n            if \"sourceConnectionIds\" not in obj.keys():\n                raise KeyError(\"missing 'sourceConnectionIds' parameter in the dictionary\")\n            if \"targetConnectionIds\" not in obj.keys():\n                raise KeyError(\"missing 'targetConnectionIds' parameter in the dictionary\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createFlow\")\n        path: str = \"/flows\"\n        res: dict = self.connector.postData(self.endpoint + path, data=obj)\n        return res\n\n    def createFlowDataLakeToDataLandingZone(\n        self,\n        name: str,\n        source_connection_id: str,\n        target_connection_id: str,\n        schedule_start_time: str,\n        schedule_frequency: str = \"hour\",\n        schedule_interval: int = 3,\n        transformation_mapping_id: str = None,\n        transformation_name: str = None,\n        transformation_version: int = 0,\n        version: str = \"1.0\",\n        flow_spec_name: str = \"Data Landing Zone\",\n        source_spec_name: str = \"activation-datalake\",\n        target_spec_name: str = \"Data Landing Zone\"\n    ) -> dict:\n        \"\"\"\n        Create a Data Flow to move data from Data Lake to the Data Landing Zone.\n        Arguments:\n            name : REQUIRED : The name of the Data Flow.\n            source_connection_id : REQUIRED : The ID of the source connection tied to Data Lake.\n            target_connection_id : REQUIRED : The ID of the target connection tied to Data Landing Zone.\n            schedule_start_time : REQUIRED : The time from which the Data Flow should start running.\n            schedule_frequency : OPTIONAL : The granularity of the Data Flow. Currently only \"hour\" supported.\n            schedule_interval : OPTIONAL : The interval on which the Data Flow runs. Either 3, 6, 9, 12 or 24. Default to 3.\n            transformation_mapping_id : OPTIONAL : If a transformation is required, its mapping ID.\n            transformation_name : OPTIONAL : If a transformation is required, its name.\n            transformation_version : OPTIONAL : If a transformation is required, its version.\n            version : OPTIONAL : The version of the Data Flow.\n            flow_spec_name : OPTIONAL : The name of the Data Flow specification. Same for all customers.\n        \"\"\"\n        flow_spec_id = self.getFlowSpecIdFromNames(flow_spec_name, source_spec_name, target_spec_name)\n        return self.createFlow(\n            flow_spec_id=flow_spec_id,\n            name=name,\n            source_connection_id=source_connection_id,\n            target_connection_id=target_connection_id,\n            schedule_start_time=schedule_start_time,\n            schedule_frequency=schedule_frequency,\n            schedule_interval=schedule_interval,\n            transformation_mapping_id=transformation_mapping_id,\n            transformation_name=transformation_name,\n            transformation_version=transformation_version,\n            version=version\n        )\n\n    def createFlowDataLandingZoneToDataLake(\n        self,\n        name: str,\n        source_connection_id: str,\n        target_connection_id: str,\n        schedule_start_time: str,\n        schedule_frequency: str = \"minute\",\n        schedule_interval: int = 15,\n        transformation_mapping_id: str = None,\n        transformation_name: str = None,\n        transformation_version: int = 0,\n        version: str = \"1.0\",\n        flow_spec_name: str = \"CloudStorageToAEP\",\n        source_spec_name: str = \"landing-zone\",\n        target_spec_name: str = \"datalake\"\n    ) -> dict:\n        \"\"\"\n        Create a Data Flow to move data from Data Lake to the Data Landing Zone.\n        Arguments:\n            name : REQUIRED : The name of the Data Flow.\n            source_connection_id : REQUIRED : The ID of the source connection tied to Data Lake.\n            target_connection_id : REQUIRED : The ID of the target connection tied to Data Landing Zone.\n            schedule_start_time : REQUIRED : The time from which the Data Flow should start running.\n            schedule_frequency : OPTIONAL : The granularity of the Data Flow. Can be \"hour\" or \"minute\". Default to \"minute\".\n            schedule_interval : OPTIONAL : The interval on which the Data Flow runs. Default to 15\n            transformation_mapping_id : OPTIONAL : If a transformation is required, its mapping ID.\n            transformation_name : OPTIONAL : If a transformation is required, its name.\n            transformation_version : OPTIONAL : If a transformation is required, its version.\n            version : OPTIONAL : The version of the Data Flow.\n            flow_spec_name : OPTIONAL : The name of the Data Flow specification. Same for all customers.\n        \"\"\"\n        flow_spec_id = self.getFlowSpecIdFromNames(flow_spec_name, source_spec_name, target_spec_name)\n        return self.createFlow(\n            flow_spec_id=flow_spec_id,\n            name=name,\n            source_connection_id=source_connection_id,\n            target_connection_id=target_connection_id,\n            schedule_start_time=schedule_start_time,\n            schedule_frequency=schedule_frequency,\n            schedule_interval=schedule_interval,\n            transformation_mapping_id=transformation_mapping_id,\n            transformation_name=transformation_name,\n            transformation_version=transformation_version,\n            version=version\n        )\n\n    def updateFlow(\n        self, flowId: str = None, etag: str = None, updateObj: list = None\n    ) -> dict:\n        \"\"\"\n        update the flow based on the operation provided.\n        Arguments:\n            flowId : REQUIRED : the ID of the flow to Patch.\n            etag : REQUIRED : ETAG value for patching the Flow.\n            updateObj : REQUIRED : List of operation to realize on the flow.\n\n            Follow the following structure:\n            [\n                {\n                    \"op\": \"Add\",\n                    \"path\": \"/auth/params\",\n                    \"value\": {\n                    \"description\": \"A new description to provide further context on a specified connection or flow.\"\n                    }\n                }\n            ]\n        \"\"\"\n        if flowId is None:\n            raise Exception(\"Require a flow ID to be present\")\n        if etag is None:\n            raise Exception(\"Require etag to be present\")\n        if updateObj is None:\n            raise Exception(\"Require a list with data to be present\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting updateFlow\")\n        privateHeader = deepcopy(self.header)\n        privateHeader[\"if-match\"] = etag\n        path: str = f\"/flows/{flowId}\"\n        res: dict = self.connector.patchData(\n            self.endpoint + path, headers=privateHeader, data=updateObj\n        )\n        return res\n\n    def getFlowSpecs(self, prop: str = None) -> list:\n        \"\"\"\n        Returns the flow specifications.\n        Arguments:\n            prop : OPTIONAL : A comma separated list of top-level object properties to be returned in the response.\n                Used to cut down the amount of data returned in the response body.\n                For example, prop=id==3416976c-a9ca-4bba-901a-1f08f66978ff,6a8d82bc-1caf-45d1-908d-cadabc9d63a6,3c9b37f8-13a6-43d8-bad3-b863b941fedd.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getFlowSpecs\")\n        path: str = \"/flowSpecs\"\n        params = {}\n        if prop is not None:\n            params[\"property\"] = prop\n        res: dict = self.connector.getData(self.endpoint + path, params=params)\n        items: list = res[\"items\"]\n        return items\n\n    def getFlowSpecIdFromNames(\n        self,\n        flow_spec_name: str,\n        source_spec_name: str = None,\n        target_spec_name: str = None\n    ) -> str:\n        \"\"\"\n        Return the Flow specification ID corresponding to some conditions..\n        Arguments:\n            flow_spec_name : REQUIRED : The flow specification name to look for\n            source_spec_name : OPTIONAL : Additional filter to only return a flow with a source specification ID.\n            target_spec_name : OPTIONAL : Additional filter to only return a flow with a target specification ID.\n        \"\"\"\n        flows = self.getFlowSpecs(f\"name=={flow_spec_name}\")\n        if source_spec_name is not None:\n            source_spec_id = self.getConnectionSpecIdFromName(source_spec_name)\n            flows = [flow for flow in flows if source_spec_id in flow[\"sourceConnectionSpecIds\"]]\n        if target_spec_name is not None:\n            target_spec_id = self.getConnectionSpecIdFromName(target_spec_name)\n            flows = [flow for flow in flows if target_spec_id in flow[\"targetConnectionSpecIds\"]]\n        if len(flows) != 1:\n            raise Exception(f\"Expected a single flow specification mapping to flow name '{flow_spec_name}', \"\n                            f\"source spec name '{source_spec_name}' and target spec name '{target_spec_name}'\"\n                            f\"but got {len(flows)}\")\n        flow_spec_id = flows[0][\"id\"]\n        return flow_spec_id\n\n    def getFlowSpec(self, flowSpecId) -> dict:\n        \"\"\"\n        Return the detail of a specific flow ID Spec\n        Arguments:\n            flowSpecId : REQUIRED : The flow ID spec to be checked\n        \"\"\"\n        if flowSpecId is None:\n            raise Exception(\"Require a flowSpecId to be present\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getFlowSpec\")\n        path: str = f\"/flowSpecs/{flowSpecId}\"\n        res: dict = self.connector.getData(self.endpoint + path)\n        return res.get('items',[{}])[0]\n\n    def getRuns(\n        self, limit: int = 10, n_results: int = 100, prop: str = None, **kwargs\n    ) -> list:\n        \"\"\"\n        Returns the list of runs. Runs are instances of a flow execution.\n        Arguments:\n            limit : OPTIONAL : number of results returned per request\n            n_results : OPTIONAL : total number of results returned (default 100, set to \"inf\" for retrieving everything)\n            prop : OPTIONAL : comma separated list of top-level object properties to be returned in the response.\n                Used to cut down the amount of data returned in the response body.\n                For example, prop=id==3416976c-a9ca-4bba-901a-1f08f66978ff,6a8d82bc-1caf-45d1-908d-cadabc9d63a6,3c9b37f8-13a6-43d8-bad3-b863b941fedd.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getRuns\")\n        path = \"/runs\"\n        params = {\"limit\": limit, \"count\": kwargs.get(\"count\", False)}\n        if prop is not None:\n            params[\"property\"] = prop\n        if kwargs.get(\"continuationToken\", False):\n            params[\"continuationToken\"] = kwargs.get(\"continuationToken\")\n        res: dict = self.connector.getData(self.endpoint + path, params=params)\n        items: list = res.get(\"items\",[])\n        nextPage = res[\"_links\"].get(\"next\", {}).get(\"href\", \"\")\n        while nextPage != \"\" and len(items) < float(n_results):\n            token: str = res[\"_links\"][\"next\"].get(\"href\", \"\")\n            continuationToken: str = token.split(\"=\")[1]\n            params[\"continuationToken\"] = continuationToken\n            res = self.connector.getData(self.endpoint + path, params=params)\n            items += res.get('items')\n            nextPage = res[\"_links\"].get(\"next\", {}).get(\"href\", \"\")\n        return items\n\n    def createRun(self, flowId: str = None, status: str = \"active\") -> dict:\n        \"\"\"\n        Generate a run based on the flowId.\n        Arguments:\n            flowId : REQUIRED : the flow ID to run\n            stats : OPTIONAL : Status of the flow\n        \"\"\"\n        path = \"/runs\"\n        if flowId is None:\n            raise Exception(\"Require a flowId to be present\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createRun\")\n        obj = {\"flowId\": flowId, \"status\": status}\n        res: dict = self.connector.postData(self.endpoint + path, data=obj)\n        return res\n\n    def getRun(self, runId: str = None) -> dict:\n        \"\"\"\n        Return a specific runId.\n        Arguments:\n            runId : REQUIRED : the run ID to return\n        \"\"\"\n        if runId is None:\n            raise Exception(\"Require a runId to be present\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getRun\")\n        path: str = f\"/runs/{runId}\"\n        res: dict = self.connector.getData(self.endpoint + path)\n        return res\n\n    def getSourceConnections(self, n_results: int = 100, **kwargs) -> list:\n        \"\"\"\n        Return the list of source connections\n        Arguments:\n            n_results : OPTIONAL : total number of results returned (default 100, set to \"inf\" for retrieving everything)\n        kwargs will be added as query parameterss\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getSourceConnections\")\n        params = {**kwargs}\n        path: str = f\"/sourceConnections\"\n        res: dict = self.connector.getData(self.endpoint + path, params=params)\n        data: list = res[\"items\"]\n        nextPage = res[\"_links\"].get(\"next\", {}).get(\"href\", \"\")\n        while nextPage != \"\" and len(data) < float(n_results):\n            continuationToken = nextPage.split(\"=\")[1]\n            params[\"continuationToken\"] = continuationToken\n            res: dict = self.connector.getData(self.endpoint + path, params=params)\n            data += res[\"items\"]\n            nextPage = res[\"_links\"].get(\"next\", {}).get(\"href\", \"\")\n        return data\n\n    def getSourceConnection(self, sourceConnectionId: str = None) -> dict:\n        \"\"\"\n        Return detail of the sourceConnection ID\n        Arguments:\n            sourceConnectionId : REQUIRED : The source connection ID to be retrieved\n        \"\"\"\n        if sourceConnectionId is None:\n            raise Exception(\"Require a sourceConnectionId to be present\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getSourceConnection\")\n        path: str = f\"/sourceConnections/{sourceConnectionId}\"\n        res: dict = self.connector.getData(self.endpoint + path)\n        return res.get('items',[{}])[0]\n\n    def deleteSourceConnection(self, sourceConnectionId: str = None) -> dict:\n        \"\"\"\n        Delete a sourceConnection ID\n        Arguments:\n            sourceConnectionId : REQUIRED : The source connection ID to be deleted\n        \"\"\"\n        if sourceConnectionId is None:\n            raise Exception(\"Require a sourceConnectionId to be present\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteSourceConnection\")\n        path: str = f\"/sourceConnections/{sourceConnectionId}\"\n        res: dict = self.connector.deleteData(self.endpoint + path)\n        return res\n\n    def createSourceConnection(self, data: dict = None) -> dict:\n        \"\"\"\n        Create a sourceConnection based on the dictionary passed.\n        Arguments:\n            obj : REQUIRED : the data to be passed for creation of the Source Connection.\n                Details can be seen at https://www.adobe.io/apis/experienceplatform/home/api-reference.html#/Source_connections/postSourceConnection\n                requires following keys : name, baseConnectionId, data, params, connectionSpec.\n        \"\"\"\n        if data is None:\n            raise Exception(\"Require a dictionary with data to be present\")\n        if \"name\" not in data.keys():\n            raise KeyError(\"Require a 'name' key in the dictionary passed\")\n        if \"connectionSpec\" not in data.keys():\n            raise KeyError(\"Require a 'connectionSpec' key in the dictionary passed\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createSourceConnection\")\n        path: str = f\"/sourceConnections\"\n        res: dict = self.connector.postData(self.endpoint + path, data=data)\n        return res\n\n    def createSourceConnectionStreaming(\n        self,\n        connectionId: str = None,\n        name: str = None,\n        format: str = \"delimited\",\n        description: str = \"\",\n        spec_name: str = \"Streaming Connection\"\n    ) -> dict:\n        \"\"\"\n        Create a source connection based on streaming connection created.\n        Arguments:\n            connectionId : REQUIRED : The Streaming connection ID.\n            name : REQUIRED : Name of the Connection.\n            format : REQUIRED : format of the data sent (default : delimited)\n            description : REQUIRED : Description of of the Connection Source.\n            spec_name : OPTIONAL : The name of the source specification corresponding to Streaming.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createSourceConnectionStreaming\")\n        spec_id = self.getConnectionSpecIdFromName(spec_name)\n        obj = {\n            \"name\": name,\n            \"providerId\": \"521eee4d-8cbe-4906-bb48-fb6bd4450033\",\n            \"description\": description,\n            \"baseConnectionId\": connectionId,\n            \"connectionSpec\": {\n                \"id\": spec_id,\n                \"version\": \"1.0\",\n            },\n            \"data\": {\"format\": format},\n        }\n        res = self.createSourceConnection(data=obj)\n        return res\n    \n    def createSourceConnectionDataLandingZone(\n        self,\n        name: str = None,\n        format: str = \"delimited\",\n        path: str = None,\n        type: str = \"file\",\n        recursive: bool = False,\n        spec_name: str = \"landing-zone\"\n    ) -> dict:\n        \"\"\"\n        Create a new data landing zone connection.\n        Arguments:\n            name : REQUIRED : A name for the connection\n            format : REQUIRED : The type of data type loaded. Default \"delimited\". Can be \"json\" or \"parquet\" \n            path : REQUIRED : The path to the data you want to ingest. Can be a single file or folder.\n            type : OPTIONAL : Use \"file\" if path refers to individual file, otherwise \"folder\".\n            recursive : OPTIONAL : Whether to look for files recursively under the path or not.\n            spec_name : OPTIONAL : The name of the source specification corresponding to Data Landing Zone.\n        \"\"\"\n        if name is None:\n            raise ValueError(\"Require a name for the connection\")\n        spec_id = self.getConnectionSpecIdFromName(spec_name)\n        obj = {\n            \"name\": name,\n            \"data\": {\n                \"format\": format\n            },\n            \"params\": {\n                \"path\": path,\n                \"type\": type,\n                \"recursive\": recursive\n            },\n            \"connectionSpec\": {\n                \"id\": spec_id,\n                \"version\": \"1.0\"\n            }\n        }\n        res = self.createSourceConnection(obj)\n        return res\n\n    def createSourceConnectionDataLake(\n        self,\n        name: str = None,\n        format: str = \"delimited\",\n        dataset_ids: list = [],\n        spec_name: str = \"activation-datalake\"\n    ) -> dict:\n        \"\"\"\n        Create a new data lake connection.\n        Arguments:\n            name : REQUIRED : A name for the connection\n            format : REQUIRED : The type of data type loaded. Default \"delimited\". Can be \"json\" or \"parquet\"\n            dataset_ids : REQUIRED : A list of dataset IDs acting as a source of data.\n            spec_name : OPTIONAL : The name of the source specification corresponding to Data Lake.\n        \"\"\"\n        if name is None:\n            raise ValueError(\"Require a name for the connection\")\n        if len(dataset_ids) == 0:\n            raise ValueError(\"Expected at least 1 dataset ID to be passed\")\n        spec_id = self.getConnectionSpecIdFromName(spec_name)\n        obj = {\n            \"name\": name,\n            \"data\": {\n                \"format\": format\n            },\n            \"connectionSpec\": {\n                \"id\": spec_id,\n                \"version\": \"1.0\"\n            },\n            \"params\": {\n                \"datasets\": [{\n                    \"dataSetId\": dataset_id,\n                } for dataset_id in dataset_ids]\n            }\n        }\n        res = self.createSourceConnection(obj)\n        return res\n\n    def updateSourceConnection(\n        self, sourceConnectionId: str = None, etag: str = None, updateObj: list = None\n    ) -> dict:\n        \"\"\"\n        Update a source connection based on the ID provided with the object provided.\n        Arguments:\n            sourceConnectionId : REQUIRED : The source connection ID to be updated\n            etag: REQUIRED : A header containing the etag value of the connection or flow to be updated.\n            updateObj : REQUIRED : The operation call used to define the action needed to update the connection. Operations include add, replace, and remove.\n        \"\"\"\n        if sourceConnectionId is None:\n            raise Exception(\"Require a sourceConnection to be present\")\n        if etag is None:\n            raise Exception(\"Require etag to be present\")\n        if updateObj is None:\n            raise Exception(\"Require a list with data to be present\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting updateSourceConnection\")\n        privateHeader = deepcopy(self.header)\n        privateHeader[\"if-match\"] = etag\n        path: str = f\"/sourceConnections/{sourceConnectionId}\"\n        res: dict = self.connector.patchData(\n            self.endpoint + path, headers=privateHeader, data=updateObj\n        )\n        return res\n\n    def getTargetConnections(self, n_results: int = 100, **kwargs) -> dict:\n        \"\"\"\n        Return the target connections\n        Arguments:\n            n_results : OPTIONAL : total number of results returned (default 100, set to \"inf\" for retrieving everything)\n        kwargs will be added as query parameterss\n        \"\"\"\n        params = {**kwargs}\n        path: str = f\"/targetConnections\"\n        res: dict = self.connector.getData(self.endpoint + path, params=params)\n        data: list = res[\"items\"]\n        nextPage = res[\"_links\"].get(\"next\", {}).get(\"href\", \"\")\n        while nextPage != \"\" and len(data) < float(n_results):\n            continuationToken = nextPage.split(\"=\")[1]\n            params[\"continuationToken\"] = continuationToken\n            res: dict = self.connector.getData(self.endpoint + path, params=params)\n            data += res[\"items\"]\n            nextPage = res[\"_links\"].get(\"next\", {}).get(\"href\", \"\")\n        return data\n\n    def getTargetConnection(self, targetConnectionId: str = None) -> dict:\n        \"\"\"\n        Retrieve a specific Target connection detail.\n        Arguments:\n            targetConnectionId : REQUIRED : The target connection ID is a unique identifier used to create a flow.\n        \"\"\"\n        if targetConnectionId is None:\n            raise Exception(\"Require a target connection ID to be present\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getTargetConnection\")\n        path: str = f\"/targetConnections/{targetConnectionId}\"\n        res: dict = self.connector.getData(self.endpoint + path)\n        return res.get('items',[None])[0]\n\n    def deleteTargetConnection(self, targetConnectionId: str = None) -> dict:\n        \"\"\"\n        Delete a specific Target connection detail\n        Arguments:\n             targetConnectionId : REQUIRED : The target connection ID to be deleted\n        \"\"\"\n        if targetConnectionId is None:\n            raise Exception(\"Require a target connection ID to be present\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteTargetConnection\")\n        path: str = f\"/targetConnections/{targetConnectionId}\"\n        res: dict = self.connector.deleteData(self.endpoint + path)\n        return res\n\n    def createTargetConnection(\n        self,\n        name: str = None,\n        connectionSpecId: str = None,\n        datasetId: str = None,\n        format: str = \"parquet_xdm\",\n        version: str = \"1.0\",\n        description: str = \"\",\n        data: dict = None,\n    ) -> dict:\n        \"\"\"\n        Create a new target connection\n        Arguments:\n                name : REQUIRED : The name of the target connection\n                connectionSpecId : REQUIRED : The connectionSpecId to use.\n                datasetId : REQUIRED : The dataset ID that is the target\n                version : REQUIRED : version to be used (1.0 by default)\n                format : REQUIRED : Data format to be used (parquet_xdm by default)\n                description : OPTIONAL : description of your target connection\n                data : OPTIONAL : If you pass the complete dictionary for creation\n        Details can be seen at https://www.adobe.io/apis/experienceplatform/home/api-reference.html#/Target_connections/postTargetConnection\n        requires following keys : name, data, params, connectionSpec.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createTargetConnection\")\n        path: str = f\"/targetConnections\"\n        if data is not None and type(data) == dict:\n            obj = data\n            res: dict = self.connector.postData(self.endpoint + path, data=obj)\n        else:\n            if name is None:\n                raise ValueError(\"Require a name to be passed\")\n            if connectionSpecId is None:\n                raise ValueError(\"Require a connectionSpec Id to be passed\")\n            if datasetId is None:\n                raise ValueError(\"Require a datasetId to be passed\")\n            obj = {\n                \"name\": name,\n                \"description\": description,\n                \"connectionSpec\": {\"id\": connectionSpecId, \"version\": version},\n                \"data\": {\"format\": format},\n                \"params\": {\"dataSetId\": datasetId},\n            }\n            res: dict = self.connector.postData(self.endpoint + path, data=obj)\n        return res\n\n    def createTargetConnectionDataLandingZone(\n        self,\n        name: str = None,\n        format: str = \"delimited\",\n        path: str = None,\n        type: str = \"file\",\n        version: str = \"1.0\",\n        description: str = \"\",\n        spec_name: str = \"Data Landing Zone\"\n    ) -> dict:\n        \"\"\"\n        Create a target connection to the Data Landing Zone\n        Arguments:\n                name : REQUIRED : The name of the target connection\n                format : REQUIRED : Data format to be used\n                path : REQUIRED : The path to the data you want to ingest. Can be a single file or folder.\n                type : OPTIONAL : Use \"file\" if path refers to individual file, otherwise \"folder\".\n                version : REQUIRED : version of your target destination\n                description : OPTIONAL : description of your target destination.\n                spec_name : OPTIONAL : The name of the target specification corresponding to Data Lake.\n        \"\"\"\n        if name is None:\n            raise ValueError(\"Require a name for the connection\")\n        spec_id = self.getConnectionSpecIdFromName(spec_name)\n        obj = {\n            \"name\": name,\n            \"description\": description,\n            \"data\": {\n                \"format\": format\n            },\n            \"params\": {\n                \"path\": path,\n                \"type\": type\n            },\n            \"connectionSpec\": {\n                \"id\": spec_id,\n                \"version\": version\n            }\n        }\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createTargetConnectionDataLandingZone\")\n        res = self.createTargetConnection(data=obj)\n        return res\n\n    def createTargetConnectionDataLake(\n        self,\n        name: str = None,\n        datasetId: str = None,\n        schemaId: str = None,\n        format: str = \"delimited\",\n        version: str = \"1.0\",\n        description: str = \"\",\n        spec_name: str = \"datalake\"\n    ) -> dict:\n        \"\"\"\n        Create a target connection to the AEP Data Lake.\n        Arguments:\n            name : REQUIRED : The name of your target Destination\n            datasetId : REQUIRED : the dataset ID of your target destination.\n            schemaId : REQUIRED : The schema ID of your dataSet. (NOT meta:altId)\n            format : REQUIRED : format of your data inserted\n            version : REQUIRED : version of your target destination\n            description : OPTIONAL : description of your target destination.\n            spec_name : OPTIONAL : The name of the target specification corresponding to Data Lake.\n        \"\"\"\n        if name is None:\n            raise ValueError(\"Require a name for the connection\")\n        spec_id = self.getConnectionSpecIdFromName(spec_name)\n        targetObj = {\n            \"name\": name,\n            \"description\": description,\n            \"data\": {\n                \"format\": format,\n                \"schema\": {\n                    \"id\": schemaId,\n                    \"version\": \"application/vnd.adobe.xed-full+json;version=1.0\",\n                },\n            },\n            \"params\": {\"dataSetId\": datasetId},\n            \"connectionSpec\": {\n                \"id\": spec_id,\n                \"version\": version,\n            },\n        }\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createTargetConnectionDataLake\")\n        res = self.createTargetConnection(data=targetObj)\n        return res\n\n    def updateTargetConnection(\n        self, targetConnectionId: str = None, etag: str = None, updateObj: list = None\n    ) -> dict:\n        \"\"\"\n        Update a target connection based on the ID provided with the object provided.\n        Arguments:\n            targetConnectionId : REQUIRED : The target connection ID to be updated\n            etag: REQUIRED : A header containing the etag value of the connection or flow to be updated.\n            updateObj : REQUIRED : The operation call used to define the action needed to update the connection. Operations include add, replace, and remove.\n        \"\"\"\n        if targetConnectionId is None:\n            raise Exception(\"Require a sourceConnection to be present\")\n        if etag is None:\n            raise Exception(\"Require etag to be present\")\n        if updateObj is None:\n            raise Exception(\"Require a dictionary with data to be present\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting updateTargetConnection\")\n        privateHeader = deepcopy(self.header)\n        privateHeader[\"if-match\"] = etag\n        path: str = f\"/targetConnections/{targetConnectionId}\"\n        res: dict = self.connector.patchData(\n            self.endpoint + path, headers=privateHeader, data=updateObj\n        )\n        return res\n    \n    def updatePolicy(self,flowId:str=None, policies:Union[list,str]=None, operation:str=\"Replace\")->dict:\n        \"\"\"\n        By passing the policy IDs as a list, we update the Policies apply to this Flow.\n        Arguments:\n            flowId : REQUIRED : The Flow ID to be updated\n            policies : REQUIRED : The list of policies Id to add to the Flow\n                example of value: \"/dulepolicy/marketingActions/06621fe3q-44t3-3zu4t-90c2-y653rt3hk4o499\"\n            operation : OPTIONAL : By default \"replace\" the current policies. It can be an \"add\" operation.\n        \"\"\"\n        if flowId is None:\n            raise ValueError(\"Require a Flow ID\")\n        if policies is None:\n            raise ValueError(\"Require a list of policy ID\")\n        if type(policies) == str:\n            policies = [policies]\n        if type(policies) != list:\n            raise TypeError(\"The policiy ID were not passed via a string or a list of string\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting updatePolicy\")\n        op = [\n            {\n                \"op\" : operation,\n                \"path\":\"/policy\",\n                \"value\":{\n                    \"enforcementRefs\":policies\n                }\n\n            }\n        ]\n        res = self.updateFlow(flowId=flowId, operation=op)\n        return res\n    \n    def getLandingZoneContainer(\n        self,\n        dlz_type: str = \"user_drop_zone\"\n    ) -> dict:\n        \"\"\"\n        Returns a dictionary of the available Data Landing Zone container information.\n        Arguments:\n            dlz_type : OPTIONAL : The type of DLZ container - default to \"user_drop_zone\" but can be \"dlz_destination\"\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getLandingZoneContainer\")\n        path = f\"/data/foundation/connectors/landingzone\"\n        params = {\"type\": dlz_type}\n        res = self.connector.getData(self.endpoint_gloal + path, params=params)\n        return res\n\n    def getLandingZoneContainerName(\n        self,\n        dlz_type: str = \"user_drop_zone\"\n    ) -> str:\n        \"\"\"\n        Returns the name of the DLZ container corresponding to this type.\n        Arguments:\n            dlz_type : OPTIONAL : The type of DLZ container - default to \"user_drop_zone\" but can be \"dlz_destination\"\n        \"\"\"\n        return self.getLandingZoneContainer(dlz_type=dlz_type)[\"containerName\"]\n\n    def getLandingZoneContainerTTL(\n        self,\n        dlz_type: str = \"user_drop_zone\"\n    ) -> int:\n        \"\"\"\n        Returns the TTL in days of the DLZ container corresponding to this type.\n        Arguments:\n            dlz_type : OPTIONAL : The type of DLZ container - default to \"user_drop_zone\" but can be \"dlz_destination\"\n        \"\"\"\n        return int(self.getLandingZoneContainer(dlz_type=dlz_type)[\"containerTTL\"])\n    \n    def getLandingZoneCredential(\n        self,\n        dlz_type: str = \"user_drop_zone\"\n    ) -> dict:\n        \"\"\"\n        Returns a dictionary with the credential to be used in order to create a new zone\n        Arguments:\n            dlz_type : OPTIONAL : The type of DLZ container - default to \"user_drop_zone\" but can be \"dlz_destination\"\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getLandingZoneCredential\")\n        path = f\"/data/foundation/connectors/landingzone/credentials\"\n        params = {\"type\": dlz_type}\n        res = self.connector.getData(self.endpoint_gloal + path,params=params)\n        return res\n\n    def getLandingZoneSASUri(\n        self,\n        dlz_type: str = \"user_drop_zone\"\n    ) -> str:\n        \"\"\"\n        Returns the SAS URI of the DLZ container corresponding to this type.\n        Arguments:\n            dlz_type : OPTIONAL : The type of DLZ container - default to \"user_drop_zone\" but can be \"dlz_destination\"\n        \"\"\"\n        return self.getLandingZoneCredential(dlz_type=dlz_type)[\"SASUri\"]\n\n    def getLandingZoneSASToken(\n        self,\n        dlz_type: str = \"user_drop_zone\"\n    ) -> str:\n        \"\"\"\n        Returns the SAS token of the DLZ container corresponding to this type.\n        Arguments:\n            dlz_type : OPTIONAL : The type of DLZ container - default to \"user_drop_zone\" but can be \"dlz_destination\"\n        \"\"\"\n        return self.getLandingZoneCredential(dlz_type=dlz_type)[\"SASToken\"]\n\n    def getLandingZoneStorageAccountName(\n        self,\n        dlz_type: str = \"user_drop_zone\"\n    ) -> str:\n        \"\"\"\n        Returns the storage account name of the DLZ container corresponding to this type.\n        Arguments:\n            dlz_type : OPTIONAL : The type of DLZ container - default to \"user_drop_zone\" but can be \"dlz_destination\"\n        \"\"\"\n        return self.getLandingZoneCredential(dlz_type=dlz_type)[\"storageAccountName\"]\n\n    def exploreLandingZone(self,fileType:str='delimited')->list:\n        \"\"\"\n        Return the structure of your landing zones\n        Arguments:\n            fileType : OPTIONAL : The type of the file to see.\n        \"\"\"\n        path =\"/connectionSpecs/26f526f2-58f4-4712-961d-e41bf1ccc0e8/explore\"\n        params = {\"objectType\":\"root\"}\n        res = self.connector.getData(self.endpoint + path,params=params)\n        return res\n\n    def getLandingZoneContent(self,fileType:str=\"delimited\",file:str=None,determineProperties:bool=True,preview:bool=True)->list:\n        \"\"\"\n        Return the structure of your landing zones\n        Arguments:\n            fileType : OPTIONAL : The type of the file to see.\n                Possible option : \"delimited\", \"json\" or \"parquet\"\n            file : OPTIONAL : the path to the specific file.\n            determineProperties : OPTIONAL : replace other parameter to auto-detect file properties.\n            preview : OPTIONAL : If you wish to see a preview of the file.\n        \"\"\"\n        path =\"/connectionSpecs/26f526f2-58f4-4712-961d-e41bf1ccc0e8/explore\"\n        params = {\"objectType\":\"file\",\"preview\":preview,}\n        if determineProperties:\n            params['determineProperties'] = True\n        if determineProperties == False and fileType is not None:\n            params['FILE_TYPE'] = fileType\n        if file:\n            params['object'] = file\n        res = self.connector.getData(self.endpoint + path,params=params)\n        return res\n\n    def postFlowAction(self,flowId:str,action:str)->dict:\n        if flowId is None:\n            raise Exception(\"Requires a flowId to be present\")\n        if action is None:\n            raise Exception(\"Requires an action to be present\")\n        path = \"/flows/\" + flowId + \"/action?op=\" + action\n        privateHeader = deepcopy(self.header)\n        privateHeader.pop(\"Content-Type\")\n        res = self.connector.postData(endpoint=self.endpoint + path, headers=privateHeader)\n        return res", "\n\nclass FlowService:\n    \"\"\"\n    The Flow Service manage the ingestion part of the data in AEP.\n    For more information, relate to the API Documentation, you can directly refer to the official documentation:\n        https://www.adobe.io/apis/experienceplatform/home/api-reference.html#!acpdr/swagger-specs/flow-service.yaml\n        https://experienceleague.adobe.com/docs/experience-platform/sources/home.html\n        https://experienceleague.adobe.com/docs/experience-platform/destinations/home.html\n    \"\"\"\n\n    PATCH_REFERENCE = [\n        {\n            \"op\": \"Add\",\n            \"path\": \"/auth/params\",\n            \"value\": {\n                \"description\": \"A new description to provide further context on a specified connection or flow.\"\n            },\n        }\n    ]\n\n    ## logging capability\n    loggingEnabled = False\n    logger = None\n\n    def __init__(\n        self,\n        config: Union[dict,ConnectObject] = aepp.config.config_object,\n        header: dict = aepp.config.header,\n        loggingObject: dict = None,\n        **kwargs,\n    ):\n        \"\"\"\n        initialize the Flow Service instance.\n        Arguments:\n            config : OPTIONAL : config object in the config module.\n            header : OPTIONAL : header object  in the config module.\n            loggingObject : OPTIONAL : A dictionary presenting the configuration of the logging service.\n        \"\"\"\n        if loggingObject is not None and sorted(\n            [\"level\", \"stream\", \"format\", \"filename\", \"file\"]\n        ) == sorted(list(loggingObject.keys())):\n            self.loggingEnabled = True\n            self.logger = logging.getLogger(f\"{__name__}\")\n            self.logger.setLevel(loggingObject[\"level\"])\n            if type(loggingObject[\"format\"]) == str:\n                formatter = logging.Formatter(loggingObject[\"format\"])\n            elif type(loggingObject[\"format\"]) == logging.Formatter:\n                formatter = loggingObject[\"format\"]\n            if loggingObject[\"file\"]:\n                fileHandler = logging.FileHandler(loggingObject[\"filename\"])\n                fileHandler.setFormatter(formatter)\n                self.logger.addHandler(fileHandler)\n            if loggingObject[\"stream\"]:\n                streamHandler = logging.StreamHandler()\n                streamHandler.setFormatter(formatter)\n                self.logger.addHandler(streamHandler)\n        if type(config) == dict: ## Supporting either default setup or passing a ConnectObject\n            config = config\n        elif type(config) == ConnectObject:\n            header = config.getConfigHeader()\n            config = config.getConfigObject()\n        self.connector = connector.AdobeRequest(\n            config=config,\n            header=header,\n            loggingEnabled=self.loggingEnabled,\n            logger=self.logger,\n        )\n        self.header = self.connector.header\n        self.header.update(**kwargs)\n        if kwargs.get('sandbox',None) is not None: ## supporting sandbox setup on class instanciation\n            self.sandbox = kwargs.get('sandbox')\n            self.connector.config[\"sandbox\"] = kwargs.get('sandbox')\n            self.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n            self.connector.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n        else:\n            self.sandbox = self.connector.config[\"sandbox\"]\n        self.endpoint = aepp.config.endpoints[\"global\"] + aepp.config.endpoints[\"flow\"]\n        self.endpoint_gloal = aepp.config.endpoints[\"global\"]\n        self.data = _Data()\n\n    def getResource(\n        self,\n        endpoint: str = None,\n        params: dict = None,\n        format: str = \"json\",\n        save: bool = False,\n        **kwargs,\n    ) -> dict:\n        \"\"\"\n        Template for requesting data with a GET method.\n        Arguments:\n            endpoint : REQUIRED : The URL to GET\n            params: OPTIONAL : dictionary of the params to fetch\n            format : OPTIONAL : Type of response returned. Possible values:\n                json : default\n                txt : text file\n                raw : a response object from the requests module\n        \"\"\"\n        if endpoint is None:\n            raise ValueError(\"Require an endpoint\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getResource\")\n        res = self.connector.getData(endpoint, params=params, format=format)\n        if save:\n            if format == \"json\":\n                aepp.saveFile(\n                    module=\"catalog\",\n                    file=res,\n                    filename=f\"resource_{int(time.time())}\",\n                    type_file=\"json\",\n                    encoding=kwargs.get(\"encoding\", \"utf-8\"),\n                )\n            elif format == \"txt\":\n                aepp.saveFile(\n                    module=\"catalog\",\n                    file=res,\n                    filename=f\"resource_{int(time.time())}\",\n                    type_file=\"txt\",\n                    encoding=kwargs.get(\"encoding\", \"utf-8\"),\n                )\n            else:\n                print(\n                    \"element is an object. Output is unclear. No save made.\\nPlease save this element manually\"\n                )\n        return res\n\n    def getConnections(\n        self, limit: int = 20, n_results: int = 100, count: bool = False, **kwargs\n    ) -> list:\n        \"\"\"\n        Returns the list of connections available.\n        Arguments:\n            limit : OPTIONAL : number of result returned per request (default 20)\n            n_results : OPTIONAL : number of total result returned (default 100, set to \"inf\" for retrieving everything)\n            count : OPTIONAL : if set to True, just returns the number of connections\n        kwargs will be added as query parameters\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getConnections\")\n        params = {\"limit\": limit}\n        if count:\n            params[\"count\"] = count\n        for kwarg in kwargs:\n            params[kwarg] = kwargs[kwarg]\n        path = \"/connections\"\n        res = self.connector.getData(self.endpoint + path, params=params)\n        try:\n            data = res[\"items\"]\n            continuationToken = res.get(\"_links\", {}).get(\"next\", {}).get(\"href\", \"\")\n            while continuationToken != \"\" and len(data) < float(n_results):\n                res = self.connector.getData(\n                    self.endpoint + continuationToken, params=params\n                )\n                data += res[\"items\"]\n                continuationToken = (\n                    res.get(\"_links\", {}).get(\"next\", {}).get(\"href\", \"\")\n                )\n            return data\n        except:\n            return res\n\n    def createConnection(\n        self,\n        data: dict = None,\n        name: str = None,\n        auth: dict = None,\n        connectionSpec: dict = None,\n        **kwargs,\n    ) -> dict:\n        \"\"\"\n        Create a connection based on either the data being passed or the information passed.\n        Arguments:\n            data : REQUIRED : dictionary containing the different elements required for the creation of the connection.\n\n            In case you didn't pass a data parameter, you can pass different information.\n            name : REQUIRED : name of the connection.\n            auth : REQUIRED : dictionary that contains \"specName\" and \"params\"\n                specName : string that names of the the type of authentication to be used with the base connection.\n                params : dict that contains credentials and values necessary to authenticate and create a connection.\n            connectionSpec : REQUIRED : dictionary containing the \"id\" and \"verison\" key.\n                id : The specific connection specification ID associated with source\n                version : Specifies the version of the connection specification ID. Omitting this value will default to the most recent version\n        Possible kwargs:\n            responseType : by default json, but you can request 'raw' that return the requests response object.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createConnection\")\n        path = \"/connections\"\n        if data is not None:\n            if (\n                \"name\" not in data.keys()\n                or \"auth\" not in data.keys()\n                or \"connectionSpec\" not in data.keys()\n            ):\n                raise Exception(\n                    \"Require some keys to be present : name, auth, connectionSpec\"\n                )\n            obj = data\n            res = self.connector.postData(self.endpoint + path, data=obj,format=kwargs.get('responseType','json'))\n            return res\n        elif data is None:\n            if \"specName\" not in auth.keys() or \"params\" not in auth.keys():\n                raise Exception(\n                    \"Require some keys to be present in auth dict : specName, params\"\n                )\n            if \"id\" not in connectionSpec.keys():\n                raise Exception(\n                    \"Require some keys to be present in connectionSpec dict : id\"\n                )\n            if name is None:\n                raise Exception(\"Require a name to be present\")\n            obj = {\"name\": name, \"auth\": auth, \"connectionSpec\": connectionSpec}\n            res = self.connector.postData(self.endpoint + path, data=obj,format=kwargs.get('responseType','json'))\n            return res\n\n    def createStreamingConnection(\n        self,\n        name: str = None,\n        sourceId: str = None,\n        dataType: str = \"xdm\",\n        paramName: str = None,\n        description: str = \"provided by aepp\",\n        **kwargs,\n    ) -> dict:\n        \"\"\"\n        Create a Streaming connection based on the following connectionSpec :\n        \"connectionSpec\": {\n                \"id\": \"bc7b00d6-623a-4dfc-9fdb-f1240aeadaeb\",\n                \"version\": \"1.0\",\n            },\n            with provider ID : 521eee4d-8cbe-4906-bb48-fb6bd4450033\n        Arguments:\n            name : REQUIRED : Name of the Connection.\n            sourceId : REQUIRED : The ID of the streaming connection you want to create (random string possible).\n            dataType : REQUIRED : The type of data to ingest (default xdm)\n            paramName : REQUIRED : The name of the streaming connection you want to create.\n            description : OPTIONAL : if you want to add a description\n        kwargs possibility:\n            specName : if you want to modify the specification Name.(Default : \"Streaming Connection\")\n            responseType : by default json, but you can request 'raw' that return the requests response object.\n        \"\"\"\n        if name is None:\n            raise ValueError(\"Require a name for the connection\")\n        if sourceId is None:\n            raise Exception(\"Require an ID for the connection\")\n        if dataType is None:\n            raise Exception(\"Require a dataType specified\")\n        if paramName is None:\n            raise ValueError(\"Require a name for the Streaming Connection\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createStreamingConnection\")\n        obj = {\n            \"name\": name,\n            \"providerId\": \"521eee4d-8cbe-4906-bb48-fb6bd4450033\",\n            \"description\": description,\n            \"connectionSpec\": {\n                \"id\": \"bc7b00d6-623a-4dfc-9fdb-f1240aeadaeb\",\n                \"version\": \"1.0\",\n            },\n            \"auth\": {\n                \"specName\": kwargs.get(\"specName\", \"Streaming Connection\"),\n                \"params\": {\n                    \"sourceId\": sourceId,\n                    \"dataType\": dataType,\n                    \"name\": paramName,\n                },\n            },\n        }\n        res = self.createConnection(data=obj,responseType=kwargs.get('responseType','json'))\n        return res\n\n    def getConnection(self, connectionId: str = None) -> dict:\n        \"\"\"\n        Returns a specific connection object.\n        Argument:\n            connectionId : REQUIRED : The ID of the connection you wish to retrieve.\n        \"\"\"\n        if connectionId is None:\n            raise Exception(\"Require a connectionId to be present\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getConnection\")\n        path = f\"/connections/{connectionId}\"\n        res = self.connector.getData(self.endpoint + path)\n        return res\n\n    def connectionTest(self, connectionId: str = None) -> dict:\n        \"\"\"\n        Test a specific connection ID.\n        Argument:\n            connectionId : REQUIRED : The ID of the connection you wish to test.\n        \"\"\"\n        if connectionId is None:\n            raise Exception(\"Require a connectionId to be present\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting connectionTest\")\n        path: str = f\"/connections/{connectionId}/test\"\n        res: dict = self.connector.getData(self.endpoint + path)\n        return res\n\n    def deleteConnection(self, connectionId: str = None) -> dict:\n        \"\"\"\n        Delete a specific connection ID.\n        Argument:\n            connectionId : REQUIRED : The ID of the connection you wish to delete.\n        \"\"\"\n        if connectionId is None:\n            raise Exception(\"Require a connectionId to be present\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteConnection\")\n        path: str = f\"/connections/{connectionId}\"\n        res: dict = self.connector.deleteData(self.endpoint + path)\n        return res\n\n    def getConnectionSpecs(self) -> list:\n        \"\"\"\n        Returns the list of connectionSpecs in that instance.\n        If that doesn't work, return the response.\n        \"\"\"\n        path: str = \"/connectionSpecs\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getConnectionSpecs\")\n        res: dict = self.connector.getData(self.endpoint + path)\n        try:\n            data: list = res[\"items\"]\n            return data\n        except:\n            return res\n\n    def getConnectionSpecsMap(self) -> dict:\n        \"\"\"\n        Returns a mapping of connection spec name to connection spec ID.\n        If that doesn't work, return the response.\n        \"\"\"\n        specs_info = self.getConnectionSpecs()\n        return {spec[\"name\"]: spec[\"id\"] for spec in specs_info if \"id\" in spec and \"name\" in spec}\n\n    def getConnectionSpec(self, specId: str = None) -> dict:\n        \"\"\"\n        Returns the detail for a specific connection.\n        Arguments:\n            specId : REQUIRED : The specification ID of a connection\n        \"\"\"\n        if specId is None:\n            raise Exception(\"Require a specId to be present\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getConnectionSpec\")\n        path: str = f\"/connectionSpecs/{specId}\"\n        res: dict = self.connector.getData(self.endpoint + path)\n        return res.get('items',[{}])[0]\n\n    def getConnectionSpecIdFromName(self, name: str = None) -> int:\n        \"\"\"\n        Returns the connection spec ID corresponding to a connection spec name.\n        Arguments:\n            name : REQUIRED : The specification name of a connection\n        \"\"\"\n        if name is None:\n            raise Exception(\"Require a name to be present\")\n        spec_name_to_id = self.getConnectionSpecsMap()\n        if name not in spec_name_to_id:\n            raise Exception(f\"Connection spec name '{name}' not found\")\n        return spec_name_to_id[name]\n\n    def getFlows(\n        self,\n        limit: int = 10,\n        n_results: int = 100,\n        prop: str = None,\n        filterMappingSetIds: list = None,\n        filterSourceIds: list = None,\n        filterTargetIds: list = None,\n        **kwargs,\n    ) -> list:\n        \"\"\"\n        Returns the flows set between Source and Target connection.\n        Arguments:\n            limit : OPTIONAL : number of results returned\n            n_results : OPTIONAL : total number of results returned (default 100, set to \"inf\" for retrieving everything)\n            prop : OPTIONAL : comma separated list of top-level object properties to be returned in the response.\n                Used to cut down the amount of data returned in the response body.\n                For example, prop=id==3416976c-a9ca-4bba-901a-1f08f66978ff,6a8d82bc-1caf-45d1-908d-cadabc9d63a6,3c9b37f8-13a6-43d8-bad3-b863b941fedd.\n            filterMappingSetId : OPTIONAL : returns only the flow that possess the mappingSetId passed in a list.\n            filterSourceIds : OPTIONAL : returns only the flow that possess the sourceConnectionIds passed in a list.\n            filterTargetIds : OPTIONAL : returns only the flow that possess the targetConnectionIds passed in a list.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getFlows\")\n        params: dict = {\"limit\": limit, \"count\": kwargs.get(\"count\", False)}\n        if property is not None:\n            params[\"property\"] = prop\n        if kwargs.get(\"continuationToken\", False) != False:\n            params[\"continuationToken\"] = kwargs.get(\"continuationToken\")\n        path: str = \"/flows\"\n        res: dict = self.connector.getData(self.endpoint + path, params=params)\n        token: str = res.get(\"_links\", {}).get(\"next\", {}).get(\"href\", \"\")\n        items = res[\"items\"]\n        while token != \"\" and len(items) < float(n_results):\n            continuationToken = token.split(\"=\")[1]\n            params[\"continuationToken\"] = continuationToken\n            res = self.connector.getData(self.endpoint + path, params=params)\n            token = res[\"_links\"].get(\"next\", {}).get(\"href\", \"\")\n            items += res[\"items\"]\n        self.data.flowId = {item[\"name\"]: item[\"id\"] for item in items}\n        self.data.flowSpecId = {item[\"name\"]: item.get(\"flowSpec\",{}).get('id') for item in items}\n        if filterMappingSetIds is not None:\n            filteredItems = []\n            for mappingsetId in filterMappingSetIds:\n                for item in items:\n                    if \"transformations\" in item.keys():\n                        for element in item[\"transformations\"]:\n                            if element[\"params\"].get(\"mappingId\", \"\") == mappingsetId:\n                                filteredItems.append(item)\n            items = filteredItems\n        if filterSourceIds is not None:\n            filteredItems = []\n            for sourceId in filterSourceIds:\n                for item in items:\n                    if sourceId in item[\"sourceConnectionIds\"]:\n                        filteredItems.append(item)\n            items = filteredItems\n        if filterTargetIds is not None:\n            filteredItems = []\n            for targetId in filterTargetIds:\n                for item in items:\n                    if targetId in item[\"targetConnectionIds\"]:\n                        filteredItems.append(item)\n            items = filteredItems\n        return items\n\n    def getFlow(self, flowId: str = None) -> dict:\n        \"\"\"\n        Returns the details of a specific flow.\n        Arguments:\n            flowId : REQUIRED : the flow ID to be returned\n        \"\"\"\n        if flowId is None:\n            raise Exception(\"Require a flowId to be present\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getFlow\")\n        path: str = f\"/flows/{flowId}\"\n        res: dict = self.connector.getData(self.endpoint + path)\n        return res.get('items',[{}])[0]\n\n    def deleteFlow(self, flowId: str = None) -> dict:\n        \"\"\"\n        Delete a specific flow by its ID.\n        Arguments:\n            flowId : REQUIRED : the flow ID to be returned\n        \"\"\"\n        if flowId is None:\n            raise Exception(\"Require a flowId to be present\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteFlow\")\n        path: str = f\"/flows/{flowId}\"\n        res: dict = self.connector.deleteData(self.endpoint + path)\n        return res\n\n    def createFlow(\n        self,\n        flow_spec_id: str,\n        name: str = None,\n        source_connection_id: str = None,\n        target_connection_id: str = None,\n        schedule_start_time: str = None,\n        schedule_frequency: str = \"minute\",\n        schedule_interval: int = 15,\n        transformation_mapping_id: str = None,\n        transformation_name: str = None,\n        transformation_version: int = 0,\n        obj: dict = None,\n        version: str = \"1.0\"\n    ) -> dict:\n        \"\"\"\n        Create a flow with the API.\n        Arguments:\n            obj : REQUIRED : body to create the flow service.\n                Details can be seen at https://www.adobe.io/apis/experienceplatform/home/api-reference.html#/Flows/postFlow\n                requires following keys : name, flowSpec, sourceConnectionIds, targetConnectionIds, transformations, scheduleParams.\n        \"\"\"\n        if obj is None:\n            if any(param is None for param in [name, source_connection_id, target_connection_id]):\n                raise KeyError(\"Require either obj or all of 'name', 'source_connection_id', 'target_connection_id'\")\n            if schedule_frequency not in (\"minute\", \"hour\"):\n                raise ValueError(\"schedule frequency has to be either minute or hour\")\n            obj = {\n                \"name\": name,\n                \"flowSpec\": {\n                    \"id\": flow_spec_id,\n                    \"version\": version\n                },\n                \"sourceConnectionIds\": [\n                    source_connection_id\n                ],\n                \"targetConnectionIds\": [\n                    target_connection_id\n                ],\n                \"transformations\": [],\n                \"scheduleParams\": {}\n            }\n            if schedule_start_time is not None:\n                obj[\"scheduleParams\"][\"startTime\"] = schedule_start_time\n            if schedule_frequency is not None:\n                obj[\"scheduleParams\"][\"frequency\"] = schedule_frequency\n            if schedule_interval is not None:\n                obj[\"scheduleParams\"][\"interval\"] = str(schedule_interval)\n            if transformation_mapping_id is not None:\n                obj[\"transformations\"] = [\n                    {\n                        \"name\": transformation_name,\n                        \"params\": {\n                            \"mappingId\": transformation_mapping_id,\n                            \"mappingVersion\": transformation_version\n                        }\n                    }\n                ]\n        else:\n            if \"name\" not in obj.keys():\n                raise KeyError(\"missing 'name' parameter in the dictionary\")\n            if \"flowSpec\" not in obj.keys():\n                raise KeyError(\"missing 'flowSpec' parameter in the dictionary\")\n            if \"sourceConnectionIds\" not in obj.keys():\n                raise KeyError(\"missing 'sourceConnectionIds' parameter in the dictionary\")\n            if \"targetConnectionIds\" not in obj.keys():\n                raise KeyError(\"missing 'targetConnectionIds' parameter in the dictionary\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createFlow\")\n        path: str = \"/flows\"\n        res: dict = self.connector.postData(self.endpoint + path, data=obj)\n        return res\n\n    def createFlowDataLakeToDataLandingZone(\n        self,\n        name: str,\n        source_connection_id: str,\n        target_connection_id: str,\n        schedule_start_time: str,\n        schedule_frequency: str = \"hour\",\n        schedule_interval: int = 3,\n        transformation_mapping_id: str = None,\n        transformation_name: str = None,\n        transformation_version: int = 0,\n        version: str = \"1.0\",\n        flow_spec_name: str = \"Data Landing Zone\",\n        source_spec_name: str = \"activation-datalake\",\n        target_spec_name: str = \"Data Landing Zone\"\n    ) -> dict:\n        \"\"\"\n        Create a Data Flow to move data from Data Lake to the Data Landing Zone.\n        Arguments:\n            name : REQUIRED : The name of the Data Flow.\n            source_connection_id : REQUIRED : The ID of the source connection tied to Data Lake.\n            target_connection_id : REQUIRED : The ID of the target connection tied to Data Landing Zone.\n            schedule_start_time : REQUIRED : The time from which the Data Flow should start running.\n            schedule_frequency : OPTIONAL : The granularity of the Data Flow. Currently only \"hour\" supported.\n            schedule_interval : OPTIONAL : The interval on which the Data Flow runs. Either 3, 6, 9, 12 or 24. Default to 3.\n            transformation_mapping_id : OPTIONAL : If a transformation is required, its mapping ID.\n            transformation_name : OPTIONAL : If a transformation is required, its name.\n            transformation_version : OPTIONAL : If a transformation is required, its version.\n            version : OPTIONAL : The version of the Data Flow.\n            flow_spec_name : OPTIONAL : The name of the Data Flow specification. Same for all customers.\n        \"\"\"\n        flow_spec_id = self.getFlowSpecIdFromNames(flow_spec_name, source_spec_name, target_spec_name)\n        return self.createFlow(\n            flow_spec_id=flow_spec_id,\n            name=name,\n            source_connection_id=source_connection_id,\n            target_connection_id=target_connection_id,\n            schedule_start_time=schedule_start_time,\n            schedule_frequency=schedule_frequency,\n            schedule_interval=schedule_interval,\n            transformation_mapping_id=transformation_mapping_id,\n            transformation_name=transformation_name,\n            transformation_version=transformation_version,\n            version=version\n        )\n\n    def createFlowDataLandingZoneToDataLake(\n        self,\n        name: str,\n        source_connection_id: str,\n        target_connection_id: str,\n        schedule_start_time: str,\n        schedule_frequency: str = \"minute\",\n        schedule_interval: int = 15,\n        transformation_mapping_id: str = None,\n        transformation_name: str = None,\n        transformation_version: int = 0,\n        version: str = \"1.0\",\n        flow_spec_name: str = \"CloudStorageToAEP\",\n        source_spec_name: str = \"landing-zone\",\n        target_spec_name: str = \"datalake\"\n    ) -> dict:\n        \"\"\"\n        Create a Data Flow to move data from Data Lake to the Data Landing Zone.\n        Arguments:\n            name : REQUIRED : The name of the Data Flow.\n            source_connection_id : REQUIRED : The ID of the source connection tied to Data Lake.\n            target_connection_id : REQUIRED : The ID of the target connection tied to Data Landing Zone.\n            schedule_start_time : REQUIRED : The time from which the Data Flow should start running.\n            schedule_frequency : OPTIONAL : The granularity of the Data Flow. Can be \"hour\" or \"minute\". Default to \"minute\".\n            schedule_interval : OPTIONAL : The interval on which the Data Flow runs. Default to 15\n            transformation_mapping_id : OPTIONAL : If a transformation is required, its mapping ID.\n            transformation_name : OPTIONAL : If a transformation is required, its name.\n            transformation_version : OPTIONAL : If a transformation is required, its version.\n            version : OPTIONAL : The version of the Data Flow.\n            flow_spec_name : OPTIONAL : The name of the Data Flow specification. Same for all customers.\n        \"\"\"\n        flow_spec_id = self.getFlowSpecIdFromNames(flow_spec_name, source_spec_name, target_spec_name)\n        return self.createFlow(\n            flow_spec_id=flow_spec_id,\n            name=name,\n            source_connection_id=source_connection_id,\n            target_connection_id=target_connection_id,\n            schedule_start_time=schedule_start_time,\n            schedule_frequency=schedule_frequency,\n            schedule_interval=schedule_interval,\n            transformation_mapping_id=transformation_mapping_id,\n            transformation_name=transformation_name,\n            transformation_version=transformation_version,\n            version=version\n        )\n\n    def updateFlow(\n        self, flowId: str = None, etag: str = None, updateObj: list = None\n    ) -> dict:\n        \"\"\"\n        update the flow based on the operation provided.\n        Arguments:\n            flowId : REQUIRED : the ID of the flow to Patch.\n            etag : REQUIRED : ETAG value for patching the Flow.\n            updateObj : REQUIRED : List of operation to realize on the flow.\n\n            Follow the following structure:\n            [\n                {\n                    \"op\": \"Add\",\n                    \"path\": \"/auth/params\",\n                    \"value\": {\n                    \"description\": \"A new description to provide further context on a specified connection or flow.\"\n                    }\n                }\n            ]\n        \"\"\"\n        if flowId is None:\n            raise Exception(\"Require a flow ID to be present\")\n        if etag is None:\n            raise Exception(\"Require etag to be present\")\n        if updateObj is None:\n            raise Exception(\"Require a list with data to be present\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting updateFlow\")\n        privateHeader = deepcopy(self.header)\n        privateHeader[\"if-match\"] = etag\n        path: str = f\"/flows/{flowId}\"\n        res: dict = self.connector.patchData(\n            self.endpoint + path, headers=privateHeader, data=updateObj\n        )\n        return res\n\n    def getFlowSpecs(self, prop: str = None) -> list:\n        \"\"\"\n        Returns the flow specifications.\n        Arguments:\n            prop : OPTIONAL : A comma separated list of top-level object properties to be returned in the response.\n                Used to cut down the amount of data returned in the response body.\n                For example, prop=id==3416976c-a9ca-4bba-901a-1f08f66978ff,6a8d82bc-1caf-45d1-908d-cadabc9d63a6,3c9b37f8-13a6-43d8-bad3-b863b941fedd.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getFlowSpecs\")\n        path: str = \"/flowSpecs\"\n        params = {}\n        if prop is not None:\n            params[\"property\"] = prop\n        res: dict = self.connector.getData(self.endpoint + path, params=params)\n        items: list = res[\"items\"]\n        return items\n\n    def getFlowSpecIdFromNames(\n        self,\n        flow_spec_name: str,\n        source_spec_name: str = None,\n        target_spec_name: str = None\n    ) -> str:\n        \"\"\"\n        Return the Flow specification ID corresponding to some conditions..\n        Arguments:\n            flow_spec_name : REQUIRED : The flow specification name to look for\n            source_spec_name : OPTIONAL : Additional filter to only return a flow with a source specification ID.\n            target_spec_name : OPTIONAL : Additional filter to only return a flow with a target specification ID.\n        \"\"\"\n        flows = self.getFlowSpecs(f\"name=={flow_spec_name}\")\n        if source_spec_name is not None:\n            source_spec_id = self.getConnectionSpecIdFromName(source_spec_name)\n            flows = [flow for flow in flows if source_spec_id in flow[\"sourceConnectionSpecIds\"]]\n        if target_spec_name is not None:\n            target_spec_id = self.getConnectionSpecIdFromName(target_spec_name)\n            flows = [flow for flow in flows if target_spec_id in flow[\"targetConnectionSpecIds\"]]\n        if len(flows) != 1:\n            raise Exception(f\"Expected a single flow specification mapping to flow name '{flow_spec_name}', \"\n                            f\"source spec name '{source_spec_name}' and target spec name '{target_spec_name}'\"\n                            f\"but got {len(flows)}\")\n        flow_spec_id = flows[0][\"id\"]\n        return flow_spec_id\n\n    def getFlowSpec(self, flowSpecId) -> dict:\n        \"\"\"\n        Return the detail of a specific flow ID Spec\n        Arguments:\n            flowSpecId : REQUIRED : The flow ID spec to be checked\n        \"\"\"\n        if flowSpecId is None:\n            raise Exception(\"Require a flowSpecId to be present\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getFlowSpec\")\n        path: str = f\"/flowSpecs/{flowSpecId}\"\n        res: dict = self.connector.getData(self.endpoint + path)\n        return res.get('items',[{}])[0]\n\n    def getRuns(\n        self, limit: int = 10, n_results: int = 100, prop: str = None, **kwargs\n    ) -> list:\n        \"\"\"\n        Returns the list of runs. Runs are instances of a flow execution.\n        Arguments:\n            limit : OPTIONAL : number of results returned per request\n            n_results : OPTIONAL : total number of results returned (default 100, set to \"inf\" for retrieving everything)\n            prop : OPTIONAL : comma separated list of top-level object properties to be returned in the response.\n                Used to cut down the amount of data returned in the response body.\n                For example, prop=id==3416976c-a9ca-4bba-901a-1f08f66978ff,6a8d82bc-1caf-45d1-908d-cadabc9d63a6,3c9b37f8-13a6-43d8-bad3-b863b941fedd.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getRuns\")\n        path = \"/runs\"\n        params = {\"limit\": limit, \"count\": kwargs.get(\"count\", False)}\n        if prop is not None:\n            params[\"property\"] = prop\n        if kwargs.get(\"continuationToken\", False):\n            params[\"continuationToken\"] = kwargs.get(\"continuationToken\")\n        res: dict = self.connector.getData(self.endpoint + path, params=params)\n        items: list = res.get(\"items\",[])\n        nextPage = res[\"_links\"].get(\"next\", {}).get(\"href\", \"\")\n        while nextPage != \"\" and len(items) < float(n_results):\n            token: str = res[\"_links\"][\"next\"].get(\"href\", \"\")\n            continuationToken: str = token.split(\"=\")[1]\n            params[\"continuationToken\"] = continuationToken\n            res = self.connector.getData(self.endpoint + path, params=params)\n            items += res.get('items')\n            nextPage = res[\"_links\"].get(\"next\", {}).get(\"href\", \"\")\n        return items\n\n    def createRun(self, flowId: str = None, status: str = \"active\") -> dict:\n        \"\"\"\n        Generate a run based on the flowId.\n        Arguments:\n            flowId : REQUIRED : the flow ID to run\n            stats : OPTIONAL : Status of the flow\n        \"\"\"\n        path = \"/runs\"\n        if flowId is None:\n            raise Exception(\"Require a flowId to be present\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createRun\")\n        obj = {\"flowId\": flowId, \"status\": status}\n        res: dict = self.connector.postData(self.endpoint + path, data=obj)\n        return res\n\n    def getRun(self, runId: str = None) -> dict:\n        \"\"\"\n        Return a specific runId.\n        Arguments:\n            runId : REQUIRED : the run ID to return\n        \"\"\"\n        if runId is None:\n            raise Exception(\"Require a runId to be present\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getRun\")\n        path: str = f\"/runs/{runId}\"\n        res: dict = self.connector.getData(self.endpoint + path)\n        return res\n\n    def getSourceConnections(self, n_results: int = 100, **kwargs) -> list:\n        \"\"\"\n        Return the list of source connections\n        Arguments:\n            n_results : OPTIONAL : total number of results returned (default 100, set to \"inf\" for retrieving everything)\n        kwargs will be added as query parameterss\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getSourceConnections\")\n        params = {**kwargs}\n        path: str = f\"/sourceConnections\"\n        res: dict = self.connector.getData(self.endpoint + path, params=params)\n        data: list = res[\"items\"]\n        nextPage = res[\"_links\"].get(\"next\", {}).get(\"href\", \"\")\n        while nextPage != \"\" and len(data) < float(n_results):\n            continuationToken = nextPage.split(\"=\")[1]\n            params[\"continuationToken\"] = continuationToken\n            res: dict = self.connector.getData(self.endpoint + path, params=params)\n            data += res[\"items\"]\n            nextPage = res[\"_links\"].get(\"next\", {}).get(\"href\", \"\")\n        return data\n\n    def getSourceConnection(self, sourceConnectionId: str = None) -> dict:\n        \"\"\"\n        Return detail of the sourceConnection ID\n        Arguments:\n            sourceConnectionId : REQUIRED : The source connection ID to be retrieved\n        \"\"\"\n        if sourceConnectionId is None:\n            raise Exception(\"Require a sourceConnectionId to be present\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getSourceConnection\")\n        path: str = f\"/sourceConnections/{sourceConnectionId}\"\n        res: dict = self.connector.getData(self.endpoint + path)\n        return res.get('items',[{}])[0]\n\n    def deleteSourceConnection(self, sourceConnectionId: str = None) -> dict:\n        \"\"\"\n        Delete a sourceConnection ID\n        Arguments:\n            sourceConnectionId : REQUIRED : The source connection ID to be deleted\n        \"\"\"\n        if sourceConnectionId is None:\n            raise Exception(\"Require a sourceConnectionId to be present\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteSourceConnection\")\n        path: str = f\"/sourceConnections/{sourceConnectionId}\"\n        res: dict = self.connector.deleteData(self.endpoint + path)\n        return res\n\n    def createSourceConnection(self, data: dict = None) -> dict:\n        \"\"\"\n        Create a sourceConnection based on the dictionary passed.\n        Arguments:\n            obj : REQUIRED : the data to be passed for creation of the Source Connection.\n                Details can be seen at https://www.adobe.io/apis/experienceplatform/home/api-reference.html#/Source_connections/postSourceConnection\n                requires following keys : name, baseConnectionId, data, params, connectionSpec.\n        \"\"\"\n        if data is None:\n            raise Exception(\"Require a dictionary with data to be present\")\n        if \"name\" not in data.keys():\n            raise KeyError(\"Require a 'name' key in the dictionary passed\")\n        if \"connectionSpec\" not in data.keys():\n            raise KeyError(\"Require a 'connectionSpec' key in the dictionary passed\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createSourceConnection\")\n        path: str = f\"/sourceConnections\"\n        res: dict = self.connector.postData(self.endpoint + path, data=data)\n        return res\n\n    def createSourceConnectionStreaming(\n        self,\n        connectionId: str = None,\n        name: str = None,\n        format: str = \"delimited\",\n        description: str = \"\",\n        spec_name: str = \"Streaming Connection\"\n    ) -> dict:\n        \"\"\"\n        Create a source connection based on streaming connection created.\n        Arguments:\n            connectionId : REQUIRED : The Streaming connection ID.\n            name : REQUIRED : Name of the Connection.\n            format : REQUIRED : format of the data sent (default : delimited)\n            description : REQUIRED : Description of of the Connection Source.\n            spec_name : OPTIONAL : The name of the source specification corresponding to Streaming.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createSourceConnectionStreaming\")\n        spec_id = self.getConnectionSpecIdFromName(spec_name)\n        obj = {\n            \"name\": name,\n            \"providerId\": \"521eee4d-8cbe-4906-bb48-fb6bd4450033\",\n            \"description\": description,\n            \"baseConnectionId\": connectionId,\n            \"connectionSpec\": {\n                \"id\": spec_id,\n                \"version\": \"1.0\",\n            },\n            \"data\": {\"format\": format},\n        }\n        res = self.createSourceConnection(data=obj)\n        return res\n    \n    def createSourceConnectionDataLandingZone(\n        self,\n        name: str = None,\n        format: str = \"delimited\",\n        path: str = None,\n        type: str = \"file\",\n        recursive: bool = False,\n        spec_name: str = \"landing-zone\"\n    ) -> dict:\n        \"\"\"\n        Create a new data landing zone connection.\n        Arguments:\n            name : REQUIRED : A name for the connection\n            format : REQUIRED : The type of data type loaded. Default \"delimited\". Can be \"json\" or \"parquet\" \n            path : REQUIRED : The path to the data you want to ingest. Can be a single file or folder.\n            type : OPTIONAL : Use \"file\" if path refers to individual file, otherwise \"folder\".\n            recursive : OPTIONAL : Whether to look for files recursively under the path or not.\n            spec_name : OPTIONAL : The name of the source specification corresponding to Data Landing Zone.\n        \"\"\"\n        if name is None:\n            raise ValueError(\"Require a name for the connection\")\n        spec_id = self.getConnectionSpecIdFromName(spec_name)\n        obj = {\n            \"name\": name,\n            \"data\": {\n                \"format\": format\n            },\n            \"params\": {\n                \"path\": path,\n                \"type\": type,\n                \"recursive\": recursive\n            },\n            \"connectionSpec\": {\n                \"id\": spec_id,\n                \"version\": \"1.0\"\n            }\n        }\n        res = self.createSourceConnection(obj)\n        return res\n\n    def createSourceConnectionDataLake(\n        self,\n        name: str = None,\n        format: str = \"delimited\",\n        dataset_ids: list = [],\n        spec_name: str = \"activation-datalake\"\n    ) -> dict:\n        \"\"\"\n        Create a new data lake connection.\n        Arguments:\n            name : REQUIRED : A name for the connection\n            format : REQUIRED : The type of data type loaded. Default \"delimited\". Can be \"json\" or \"parquet\"\n            dataset_ids : REQUIRED : A list of dataset IDs acting as a source of data.\n            spec_name : OPTIONAL : The name of the source specification corresponding to Data Lake.\n        \"\"\"\n        if name is None:\n            raise ValueError(\"Require a name for the connection\")\n        if len(dataset_ids) == 0:\n            raise ValueError(\"Expected at least 1 dataset ID to be passed\")\n        spec_id = self.getConnectionSpecIdFromName(spec_name)\n        obj = {\n            \"name\": name,\n            \"data\": {\n                \"format\": format\n            },\n            \"connectionSpec\": {\n                \"id\": spec_id,\n                \"version\": \"1.0\"\n            },\n            \"params\": {\n                \"datasets\": [{\n                    \"dataSetId\": dataset_id,\n                } for dataset_id in dataset_ids]\n            }\n        }\n        res = self.createSourceConnection(obj)\n        return res\n\n    def updateSourceConnection(\n        self, sourceConnectionId: str = None, etag: str = None, updateObj: list = None\n    ) -> dict:\n        \"\"\"\n        Update a source connection based on the ID provided with the object provided.\n        Arguments:\n            sourceConnectionId : REQUIRED : The source connection ID to be updated\n            etag: REQUIRED : A header containing the etag value of the connection or flow to be updated.\n            updateObj : REQUIRED : The operation call used to define the action needed to update the connection. Operations include add, replace, and remove.\n        \"\"\"\n        if sourceConnectionId is None:\n            raise Exception(\"Require a sourceConnection to be present\")\n        if etag is None:\n            raise Exception(\"Require etag to be present\")\n        if updateObj is None:\n            raise Exception(\"Require a list with data to be present\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting updateSourceConnection\")\n        privateHeader = deepcopy(self.header)\n        privateHeader[\"if-match\"] = etag\n        path: str = f\"/sourceConnections/{sourceConnectionId}\"\n        res: dict = self.connector.patchData(\n            self.endpoint + path, headers=privateHeader, data=updateObj\n        )\n        return res\n\n    def getTargetConnections(self, n_results: int = 100, **kwargs) -> dict:\n        \"\"\"\n        Return the target connections\n        Arguments:\n            n_results : OPTIONAL : total number of results returned (default 100, set to \"inf\" for retrieving everything)\n        kwargs will be added as query parameterss\n        \"\"\"\n        params = {**kwargs}\n        path: str = f\"/targetConnections\"\n        res: dict = self.connector.getData(self.endpoint + path, params=params)\n        data: list = res[\"items\"]\n        nextPage = res[\"_links\"].get(\"next\", {}).get(\"href\", \"\")\n        while nextPage != \"\" and len(data) < float(n_results):\n            continuationToken = nextPage.split(\"=\")[1]\n            params[\"continuationToken\"] = continuationToken\n            res: dict = self.connector.getData(self.endpoint + path, params=params)\n            data += res[\"items\"]\n            nextPage = res[\"_links\"].get(\"next\", {}).get(\"href\", \"\")\n        return data\n\n    def getTargetConnection(self, targetConnectionId: str = None) -> dict:\n        \"\"\"\n        Retrieve a specific Target connection detail.\n        Arguments:\n            targetConnectionId : REQUIRED : The target connection ID is a unique identifier used to create a flow.\n        \"\"\"\n        if targetConnectionId is None:\n            raise Exception(\"Require a target connection ID to be present\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getTargetConnection\")\n        path: str = f\"/targetConnections/{targetConnectionId}\"\n        res: dict = self.connector.getData(self.endpoint + path)\n        return res.get('items',[None])[0]\n\n    def deleteTargetConnection(self, targetConnectionId: str = None) -> dict:\n        \"\"\"\n        Delete a specific Target connection detail\n        Arguments:\n             targetConnectionId : REQUIRED : The target connection ID to be deleted\n        \"\"\"\n        if targetConnectionId is None:\n            raise Exception(\"Require a target connection ID to be present\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteTargetConnection\")\n        path: str = f\"/targetConnections/{targetConnectionId}\"\n        res: dict = self.connector.deleteData(self.endpoint + path)\n        return res\n\n    def createTargetConnection(\n        self,\n        name: str = None,\n        connectionSpecId: str = None,\n        datasetId: str = None,\n        format: str = \"parquet_xdm\",\n        version: str = \"1.0\",\n        description: str = \"\",\n        data: dict = None,\n    ) -> dict:\n        \"\"\"\n        Create a new target connection\n        Arguments:\n                name : REQUIRED : The name of the target connection\n                connectionSpecId : REQUIRED : The connectionSpecId to use.\n                datasetId : REQUIRED : The dataset ID that is the target\n                version : REQUIRED : version to be used (1.0 by default)\n                format : REQUIRED : Data format to be used (parquet_xdm by default)\n                description : OPTIONAL : description of your target connection\n                data : OPTIONAL : If you pass the complete dictionary for creation\n        Details can be seen at https://www.adobe.io/apis/experienceplatform/home/api-reference.html#/Target_connections/postTargetConnection\n        requires following keys : name, data, params, connectionSpec.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createTargetConnection\")\n        path: str = f\"/targetConnections\"\n        if data is not None and type(data) == dict:\n            obj = data\n            res: dict = self.connector.postData(self.endpoint + path, data=obj)\n        else:\n            if name is None:\n                raise ValueError(\"Require a name to be passed\")\n            if connectionSpecId is None:\n                raise ValueError(\"Require a connectionSpec Id to be passed\")\n            if datasetId is None:\n                raise ValueError(\"Require a datasetId to be passed\")\n            obj = {\n                \"name\": name,\n                \"description\": description,\n                \"connectionSpec\": {\"id\": connectionSpecId, \"version\": version},\n                \"data\": {\"format\": format},\n                \"params\": {\"dataSetId\": datasetId},\n            }\n            res: dict = self.connector.postData(self.endpoint + path, data=obj)\n        return res\n\n    def createTargetConnectionDataLandingZone(\n        self,\n        name: str = None,\n        format: str = \"delimited\",\n        path: str = None,\n        type: str = \"file\",\n        version: str = \"1.0\",\n        description: str = \"\",\n        spec_name: str = \"Data Landing Zone\"\n    ) -> dict:\n        \"\"\"\n        Create a target connection to the Data Landing Zone\n        Arguments:\n                name : REQUIRED : The name of the target connection\n                format : REQUIRED : Data format to be used\n                path : REQUIRED : The path to the data you want to ingest. Can be a single file or folder.\n                type : OPTIONAL : Use \"file\" if path refers to individual file, otherwise \"folder\".\n                version : REQUIRED : version of your target destination\n                description : OPTIONAL : description of your target destination.\n                spec_name : OPTIONAL : The name of the target specification corresponding to Data Lake.\n        \"\"\"\n        if name is None:\n            raise ValueError(\"Require a name for the connection\")\n        spec_id = self.getConnectionSpecIdFromName(spec_name)\n        obj = {\n            \"name\": name,\n            \"description\": description,\n            \"data\": {\n                \"format\": format\n            },\n            \"params\": {\n                \"path\": path,\n                \"type\": type\n            },\n            \"connectionSpec\": {\n                \"id\": spec_id,\n                \"version\": version\n            }\n        }\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createTargetConnectionDataLandingZone\")\n        res = self.createTargetConnection(data=obj)\n        return res\n\n    def createTargetConnectionDataLake(\n        self,\n        name: str = None,\n        datasetId: str = None,\n        schemaId: str = None,\n        format: str = \"delimited\",\n        version: str = \"1.0\",\n        description: str = \"\",\n        spec_name: str = \"datalake\"\n    ) -> dict:\n        \"\"\"\n        Create a target connection to the AEP Data Lake.\n        Arguments:\n            name : REQUIRED : The name of your target Destination\n            datasetId : REQUIRED : the dataset ID of your target destination.\n            schemaId : REQUIRED : The schema ID of your dataSet. (NOT meta:altId)\n            format : REQUIRED : format of your data inserted\n            version : REQUIRED : version of your target destination\n            description : OPTIONAL : description of your target destination.\n            spec_name : OPTIONAL : The name of the target specification corresponding to Data Lake.\n        \"\"\"\n        if name is None:\n            raise ValueError(\"Require a name for the connection\")\n        spec_id = self.getConnectionSpecIdFromName(spec_name)\n        targetObj = {\n            \"name\": name,\n            \"description\": description,\n            \"data\": {\n                \"format\": format,\n                \"schema\": {\n                    \"id\": schemaId,\n                    \"version\": \"application/vnd.adobe.xed-full+json;version=1.0\",\n                },\n            },\n            \"params\": {\"dataSetId\": datasetId},\n            \"connectionSpec\": {\n                \"id\": spec_id,\n                \"version\": version,\n            },\n        }\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createTargetConnectionDataLake\")\n        res = self.createTargetConnection(data=targetObj)\n        return res\n\n    def updateTargetConnection(\n        self, targetConnectionId: str = None, etag: str = None, updateObj: list = None\n    ) -> dict:\n        \"\"\"\n        Update a target connection based on the ID provided with the object provided.\n        Arguments:\n            targetConnectionId : REQUIRED : The target connection ID to be updated\n            etag: REQUIRED : A header containing the etag value of the connection or flow to be updated.\n            updateObj : REQUIRED : The operation call used to define the action needed to update the connection. Operations include add, replace, and remove.\n        \"\"\"\n        if targetConnectionId is None:\n            raise Exception(\"Require a sourceConnection to be present\")\n        if etag is None:\n            raise Exception(\"Require etag to be present\")\n        if updateObj is None:\n            raise Exception(\"Require a dictionary with data to be present\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting updateTargetConnection\")\n        privateHeader = deepcopy(self.header)\n        privateHeader[\"if-match\"] = etag\n        path: str = f\"/targetConnections/{targetConnectionId}\"\n        res: dict = self.connector.patchData(\n            self.endpoint + path, headers=privateHeader, data=updateObj\n        )\n        return res\n    \n    def updatePolicy(self,flowId:str=None, policies:Union[list,str]=None, operation:str=\"Replace\")->dict:\n        \"\"\"\n        By passing the policy IDs as a list, we update the Policies apply to this Flow.\n        Arguments:\n            flowId : REQUIRED : The Flow ID to be updated\n            policies : REQUIRED : The list of policies Id to add to the Flow\n                example of value: \"/dulepolicy/marketingActions/06621fe3q-44t3-3zu4t-90c2-y653rt3hk4o499\"\n            operation : OPTIONAL : By default \"replace\" the current policies. It can be an \"add\" operation.\n        \"\"\"\n        if flowId is None:\n            raise ValueError(\"Require a Flow ID\")\n        if policies is None:\n            raise ValueError(\"Require a list of policy ID\")\n        if type(policies) == str:\n            policies = [policies]\n        if type(policies) != list:\n            raise TypeError(\"The policiy ID were not passed via a string or a list of string\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting updatePolicy\")\n        op = [\n            {\n                \"op\" : operation,\n                \"path\":\"/policy\",\n                \"value\":{\n                    \"enforcementRefs\":policies\n                }\n\n            }\n        ]\n        res = self.updateFlow(flowId=flowId, operation=op)\n        return res\n    \n    def getLandingZoneContainer(\n        self,\n        dlz_type: str = \"user_drop_zone\"\n    ) -> dict:\n        \"\"\"\n        Returns a dictionary of the available Data Landing Zone container information.\n        Arguments:\n            dlz_type : OPTIONAL : The type of DLZ container - default to \"user_drop_zone\" but can be \"dlz_destination\"\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getLandingZoneContainer\")\n        path = f\"/data/foundation/connectors/landingzone\"\n        params = {\"type\": dlz_type}\n        res = self.connector.getData(self.endpoint_gloal + path, params=params)\n        return res\n\n    def getLandingZoneContainerName(\n        self,\n        dlz_type: str = \"user_drop_zone\"\n    ) -> str:\n        \"\"\"\n        Returns the name of the DLZ container corresponding to this type.\n        Arguments:\n            dlz_type : OPTIONAL : The type of DLZ container - default to \"user_drop_zone\" but can be \"dlz_destination\"\n        \"\"\"\n        return self.getLandingZoneContainer(dlz_type=dlz_type)[\"containerName\"]\n\n    def getLandingZoneContainerTTL(\n        self,\n        dlz_type: str = \"user_drop_zone\"\n    ) -> int:\n        \"\"\"\n        Returns the TTL in days of the DLZ container corresponding to this type.\n        Arguments:\n            dlz_type : OPTIONAL : The type of DLZ container - default to \"user_drop_zone\" but can be \"dlz_destination\"\n        \"\"\"\n        return int(self.getLandingZoneContainer(dlz_type=dlz_type)[\"containerTTL\"])\n    \n    def getLandingZoneCredential(\n        self,\n        dlz_type: str = \"user_drop_zone\"\n    ) -> dict:\n        \"\"\"\n        Returns a dictionary with the credential to be used in order to create a new zone\n        Arguments:\n            dlz_type : OPTIONAL : The type of DLZ container - default to \"user_drop_zone\" but can be \"dlz_destination\"\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getLandingZoneCredential\")\n        path = f\"/data/foundation/connectors/landingzone/credentials\"\n        params = {\"type\": dlz_type}\n        res = self.connector.getData(self.endpoint_gloal + path,params=params)\n        return res\n\n    def getLandingZoneSASUri(\n        self,\n        dlz_type: str = \"user_drop_zone\"\n    ) -> str:\n        \"\"\"\n        Returns the SAS URI of the DLZ container corresponding to this type.\n        Arguments:\n            dlz_type : OPTIONAL : The type of DLZ container - default to \"user_drop_zone\" but can be \"dlz_destination\"\n        \"\"\"\n        return self.getLandingZoneCredential(dlz_type=dlz_type)[\"SASUri\"]\n\n    def getLandingZoneSASToken(\n        self,\n        dlz_type: str = \"user_drop_zone\"\n    ) -> str:\n        \"\"\"\n        Returns the SAS token of the DLZ container corresponding to this type.\n        Arguments:\n            dlz_type : OPTIONAL : The type of DLZ container - default to \"user_drop_zone\" but can be \"dlz_destination\"\n        \"\"\"\n        return self.getLandingZoneCredential(dlz_type=dlz_type)[\"SASToken\"]\n\n    def getLandingZoneStorageAccountName(\n        self,\n        dlz_type: str = \"user_drop_zone\"\n    ) -> str:\n        \"\"\"\n        Returns the storage account name of the DLZ container corresponding to this type.\n        Arguments:\n            dlz_type : OPTIONAL : The type of DLZ container - default to \"user_drop_zone\" but can be \"dlz_destination\"\n        \"\"\"\n        return self.getLandingZoneCredential(dlz_type=dlz_type)[\"storageAccountName\"]\n\n    def exploreLandingZone(self,fileType:str='delimited')->list:\n        \"\"\"\n        Return the structure of your landing zones\n        Arguments:\n            fileType : OPTIONAL : The type of the file to see.\n        \"\"\"\n        path =\"/connectionSpecs/26f526f2-58f4-4712-961d-e41bf1ccc0e8/explore\"\n        params = {\"objectType\":\"root\"}\n        res = self.connector.getData(self.endpoint + path,params=params)\n        return res\n\n    def getLandingZoneContent(self,fileType:str=\"delimited\",file:str=None,determineProperties:bool=True,preview:bool=True)->list:\n        \"\"\"\n        Return the structure of your landing zones\n        Arguments:\n            fileType : OPTIONAL : The type of the file to see.\n                Possible option : \"delimited\", \"json\" or \"parquet\"\n            file : OPTIONAL : the path to the specific file.\n            determineProperties : OPTIONAL : replace other parameter to auto-detect file properties.\n            preview : OPTIONAL : If you wish to see a preview of the file.\n        \"\"\"\n        path =\"/connectionSpecs/26f526f2-58f4-4712-961d-e41bf1ccc0e8/explore\"\n        params = {\"objectType\":\"file\",\"preview\":preview,}\n        if determineProperties:\n            params['determineProperties'] = True\n        if determineProperties == False and fileType is not None:\n            params['FILE_TYPE'] = fileType\n        if file:\n            params['object'] = file\n        res = self.connector.getData(self.endpoint + path,params=params)\n        return res\n\n    def postFlowAction(self,flowId:str,action:str)->dict:\n        if flowId is None:\n            raise Exception(\"Requires a flowId to be present\")\n        if action is None:\n            raise Exception(\"Requires an action to be present\")\n        path = \"/flows/\" + flowId + \"/action?op=\" + action\n        privateHeader = deepcopy(self.header)\n        privateHeader.pop(\"Content-Type\")\n        res = self.connector.postData(endpoint=self.endpoint + path, headers=privateHeader)\n        return res", "\nclass FlowManager:\n    \"\"\"\n    A class that abstract the different information retrieved by the Flow ID in order to provide all relationships inside that Flow.\n    It takes a flow id and dig to all relationship inside that flow.\n    \"\"\"\n\n    def __init__(self,\n                flowId:str=None,\n                config: dict = aepp.config.config_object,\n                header=aepp.config.header)->None:\n        \"\"\"\n        Instantiate a Flow Manager Instance based on the flow ID.\n        Arguments:\n            flowId : REQUIRED : A flow ID\n        \"\"\"\n        from aepp import schema, catalog,dataprep,flowservice\n        self.schemaAPI = schema.Schema(config=config)\n        self.catalogAPI = catalog.Catalog(config=config)\n        self.mapperAPI = dataprep.DataPrep(config=config)\n        self.flowAPI = flowservice.FlowService(config=config)\n        self.flowData = self.flowAPI.getFlow(flowId)\n        self.__setAttributes__(self.flowData)\n        self.flowMapping = None\n        self.datasetId = None\n        self.flowSpec = {'id' : self.flowData.get('flowSpec',{}).get('id')}\n        self.flowSourceConnection = {'id' : self.flowData.get('sourceConnectionIds',[None])[0]}\n        self.flowTargetConnection = {'id' : self.flowData.get('targetConnectionIds',[None])[0]}\n        sourceConnections:list = self.flowData.get('inheritedAttributes',{}).get('sourceConnections',[{}])\n        self.connectionInfo = {}\n        for element in sourceConnections:\n            if 'typeInfo' in element.keys():\n                self.connectionInfo = {'id':element.get('id'),'name':element.get('typeInfo',{}).get('id')}\n            if 'baseConnection' in element.keys():\n                self.connectionInfo = {'id':element.get('baseConnection',{}).get('id'),'name':None}\n        if self.connectionInfo.get('id',None) is not None and self.connectionInfo.get('name',None) is None:\n            self.connectionInfo['name'] = self.flowAPI.getConnection(self.connectionInfo['id']).get('items',[{}])[0].get('name')\n        for trans in self.flowData.get('transformations',[{}]):\n            if trans.get('name') == 'Mapping':\n                self.flowMapping = {'id':trans.get('params',{}).get('mappingId')}\n        ## Flow Spec part\n        if self.flowSpec['id'] is not None:\n            flowSpecData = self.flowAPI.getFlowSpec(self.flowSpec['id'])\n            self.flowSpec['name'] = flowSpecData['name']\n            self.flowSpec['frequency'] = flowSpecData.get('attributes',{}).get('frequency')\n        ## Source Connection part\n        if self.flowSourceConnection['id'] is not None:\n            sourceConnData = self.flowAPI.getSourceConnection(self.flowSourceConnection['id'])\n            self.flowSourceConnection['data'] = sourceConnData.get('data')\n            self.flowSourceConnection['params'] = sourceConnData.get('params')\n            self.flowSourceConnection['connectionSpec'] = sourceConnData.get('connectionSpec')\n            if self.flowSourceConnection['connectionSpec'].get('id') is not None:\n                connSpec = self.flowAPI.getConnectionSpec(self.flowSourceConnection['connectionSpec'].get('id'))\n                self.flowSourceConnection['connectionSpec']['name'] = connSpec.get('name')\n            if connSpec.get('sourceSpec',{}).get('attributes',{}).get('uiAttributes',{}).get('isSource',False):\n                self.connectionType = 'source'\n            elif  connSpec.get('attributes',{}).get('isDestination',False):\n                self.connectionType = 'destination'\n            self.frequency = connSpec.get('sourceSpec',{}).get('attributes',{}).get('uiAttributes',{}).get('frequency',{}).get('key','unknown')\n        ## Target Connection part\n        if self.flowTargetConnection['id'] is not None:\n            targetConnData = self.flowAPI.getTargetConnection(self.flowTargetConnection['id'])\n            self.flowTargetConnection['name']:str = targetConnData.get('name')\n            self.flowTargetConnection['data']:dict = targetConnData.get('data',{})\n            self.flowTargetConnection['params']:dict = targetConnData.get('params',{})\n            for key, value in self.flowTargetConnection['params'].items():\n                if key == 'datasetId':\n                    self.datasetId = value\n            self.flowTargetConnection['connectionSpec']:dict = targetConnData.get('connectionSpec',{})\n            if self.flowTargetConnection['connectionSpec'].get('id',None) is not None:\n                connSpec = self.flowAPI.getConnectionSpec(self.flowSourceConnection['connectionSpec'].get('id'))\n                self.flowTargetConnection['connectionSpec']['name'] = connSpec.get('name')\n        ## Catalog part\n        if 'dataSetId' in self.flowTargetConnection['params'].keys():\n            datasetInfo = self.catalogAPI.getDataSet(self.flowTargetConnection['params']['dataSetId'])\n            if 'status' in datasetInfo.keys():\n                if datasetInfo['status'] == 404:\n                    self.flowTargetConnection['params']['datasetName'] = 'DELETED'\n            else:\n                self.flowTargetConnection['params']['datasetName'] = datasetInfo[list(datasetInfo.keys())[0]].get('name')\n        ## Schema part\n        if 'schema' in self.flowTargetConnection.get('data',{}).keys():\n            if self.flowTargetConnection.get('data',{}).get('schema',None) is not None:\n                ## handling inconsistency in the response\n                schemaId = self.flowTargetConnection['data']['schema'].get('id',self.flowTargetConnection['data']['schema'].get('schemaId',None))\n                if schemaId is not None:\n                    schemaInfo = self.schemaAPI.getSchema(schemaId,full=False)\n                    self.flowTargetConnection['data']['schema']['name'] = schemaInfo.get('title')\n        ## Mapping\n        if self.flowMapping is not None:\n            mappingInfo = self.mapperAPI.getMappingSet(self.flowMapping['id'])\n            self.flowMapping['createdDate'] = time.ctime(mappingInfo.get('createdDate')/1000)\n            self.flowMapping['createdDateTS'] = mappingInfo.get('createdDate')\n            self.flowMapping['updatedAtTS'] = mappingInfo.get('updatedAt',None)\n            if self.flowMapping['updatedAtTS'] is None:\n                self.flowMapping['updatedAt'] = None\n            else:\n                self.flowMapping['updatedAt'] = time.ctime(mappingInfo.get('updatedAt',0)/1000)\n            self.getMapping = lambda : self.mapperAPI.getMappingSet(self.flowMapping['id'])\n\n    def __setAttributes__(self,flowData:dict)->None:\n        \"\"\"\n        Set the attributes\n        \"\"\"\n        self.id = flowData.get('id')\n        self.etag = flowData.get('etag')\n        self.sandbox = flowData.get('sandboxName')\n        self.name = flowData.get('name')\n        self.version = flowData.get('version')\n        self.state = flowData.get('state')\n\n\n    def __repr__(self)->str:\n        data = {\n                \"id\" : self.id,\n                \"name\": self.name,\n                \"version\":self.version,\n                \"connectionName\" : self.connectionInfo.get('name','unknown'),\n                \"frequency\" : self.frequency,\n                \"flowSpecs\": self.flowSpec,\n                \"sourceConnection\": self.flowSourceConnection,\n                \"targetConnection\": self.flowTargetConnection,\n            }\n        if self.flowMapping is not None:\n            data['mapping'] = self.flowMapping\n        return json.dumps(data,indent=2)\n    \n    def __str__(self)->str:\n        data = {\n                \"id\" : self.id,\n                \"name\": self.name,\n                \"version\":self.version,\n                \"connectionName\" : self.connectionInfo.get('name','unknown'),\n                \"frequency\" : self.frequency,\n                \"flowSpecs\": self.flowSpec,\n                \"sourceConnection\": self.flowSourceConnection,\n                \"targetConnection\": self.flowTargetConnection,\n            }\n        if self.flowMapping is not None:\n            data['mapping'] = self.flowMapping\n        return json.dumps(data,indent=2)\n\n    def summary(self):\n        data = {\n                \"id\" : self.id,\n                \"name\": self.name,\n                \"version\":self.version,\n                \"connectionName\" : self.connectionInfo.get('name','unknown'),\n                \"frequency\" : self.frequency,\n                \"flowSpecs\": self.flowSpec,\n                \"sourceConnection\": self.flowSourceConnection,\n                \"targetConnection\": self.flowTargetConnection,\n            }\n        if self.flowMapping is not None:\n            data['mapping'] = self.flowMapping\n        return data\n\n    def getFlowSpec(self)->dict:\n        \"\"\"\n        Return a dictionary of the flow Spec.\n        \"\"\"\n        if self.flowSpec['id'] is not None:\n            flowSpecData = self.flowAPI.getFlowSpec(self.flowSpec['id'])\n            return flowSpecData\n\n    def getSourceConnection(self)->dict:\n        \"\"\"\n        Return a dictionary of the connection information\n        \"\"\"\n        if self.flowSourceConnection['id'] is not None:\n            sourceConnData = self.flowAPI.getSourceConnection(self.flowSourceConnection['id'])\n            return sourceConnData\n    \n    def getConnectionSpec(self)->dict:\n        \"\"\"\n        return a dictionary of the source connection spec information\n        \"\"\"\n        if self.flowSourceConnection['connectionSpec'].get('id') is not None:\n            connSpec = self.flowAPI.getConnectionSpec(self.flowSourceConnection['connectionSpec'].get('id'))\n            return connSpec\n    \n    def getTargetConnection(self)->dict:\n        \"\"\"\n        return a dictionary of the target connection\n        \"\"\"\n        if self.flowTargetConnection['id'] is not None:\n            targetConnData = self.flowAPI.getTargetConnection(self.flowTargetConnection['id'])\n            return targetConnData\n    \n    def getTargetConnectionSpec(self)->dict:\n        \"\"\"\n        return a dictionary of the target connection spec\n        \"\"\"\n        if self.flowTargetConnection['connectionSpec'].get('id') is not None:\n            connSpec = self.flowAPI.getConnectionSpec(self.flowSourceConnection['connectionSpec'].get('id'))\n            return connSpec\n    \n    def getRuns(self,limit:int=10,n_results=100)->list:\n        \"\"\"\n        Returns the last run of the flow.\n        Arguments:\n            limit : OPTIONAL : Amount of item per requests\n            n_results : OPTIONAL : Total amount of item to return\n        \"\"\"\n        runs = self.flowAPI.getRuns(limit,n_results,prop=f\"flowId=={self.id}\")\n        return runs\n    \n    def updateFlow(self, operations:list=None)->dict:\n        \"\"\"\n        Update the flow with the operation provided.\n        Argument:\n            operations : REQUIRED : The operation to set on the PATCH method\n                Example : \n            [\n                {\n                    \"op\": \"Add\",\n                    \"path\": \"/auth/params\",\n                    \"value\": {\n                    \"description\": \"A new description to provide further context on a specified connection or flow.\"\n                    }\n                }\n            ]\n        \"\"\"\n        if operations is None:\n            raise ValueError(\"No operations has been passed\")\n        res = self.flowAPI.updateFlow(self.id,self.etag,operations)\n        self.flowData = res\n        self.__setAttributes__(res)\n        return res\n    \n    def updateFlowMapping(self,mappingId:str)->dict:\n        \"\"\"\n        Update the flow with the latest version of the mapping Id provided.\n        Arguments:\n            mappingId : REQUIRED : The mapping Id to be used for update.\n        \"\"\"\n        transformations = deepcopy(self.flowData.get('transformations',{}))\n        myMapping = self.mapperAPI.getMappingSet(mappingId)\n        myVersion = myMapping.get('version',0)\n        operation = {}\n        myIndex = None\n        for index, transformation in enumerate(transformations):\n            if transformation.get('name') == 'Mapping':\n                myIndex=index\n                operation['mappingId'] = mappingId\n                operation['mappingVersion'] = myVersion\n        if myIndex is not None:\n            patchOperation = [{'op': 'replace',\n            'path': f'/transformations/{myIndex}',\n            'value': {'name': 'Mapping',\n            'params': {'mappingId': operation['params']['mappingId'],\n            'mappingVersion': operation['params']['mappingVersion']}}}\n            ]\n        else:\n            raise Exception('Could not find a mapping transformation in the flow')\n        res = self.updateFlow(self.id,self.etag,patchOperation)\n        self.flowData = res\n        self.__setAttributes__(res)\n        return res", ""]}
{"filename": "aepp/__init__.py", "chunked_list": ["#  Copyright 2023 Adobe. All rights reserved.\n#  This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License. You may obtain a copy\n#  of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software distributed under\n#  the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n#  OF ANY KIND, either express or implied. See the License for the specific language\n#  governing permissions and limitations under the License.\n", "#  governing permissions and limitations under the License.\n\n# Internal Library\nfrom aepp import config\nfrom aepp import connector\nfrom .configs import *\nfrom .__version__ import __version__\nfrom typing import Union\n\n## other libraries", "\n## other libraries\nfrom copy import deepcopy\nfrom pathlib import Path\nimport json\n\nconnection = None\n\n\ndef home(product: str = None, limit: int = 50):\n    \"\"\"\n    Return the IMS Organization setup and the container existing for the organization\n    Arguments:\n        product : OPTIONAL : specify one or more product contexts for which to return containers. If absent, containers for all contexts that you have rights to will be returned. The product parameter can be repeated for multiple contexts. An example of this parameter is product=acp\n        limit : OPTIONAL : Optional limit on number of results returned (default = 50).\n    \"\"\"\n    global connection\n    if connection is None:\n        connection = connector.AdobeRequest(\n            config_object=config.config_object, header=config.header\n        )\n    endpoint = config.endpoints[\"global\"] + \"/data/core/xcore/\"\n    params = {\"product\": product, \"limit\": limit}\n    myHeader = deepcopy(connection.header)\n    myHeader[\"Accept\"] = \"application/vnd.adobe.platform.xcore.home.hal+json\"\n    res = connection.getData(endpoint, params=params, headers=myHeader)\n    return res", "\ndef home(product: str = None, limit: int = 50):\n    \"\"\"\n    Return the IMS Organization setup and the container existing for the organization\n    Arguments:\n        product : OPTIONAL : specify one or more product contexts for which to return containers. If absent, containers for all contexts that you have rights to will be returned. The product parameter can be repeated for multiple contexts. An example of this parameter is product=acp\n        limit : OPTIONAL : Optional limit on number of results returned (default = 50).\n    \"\"\"\n    global connection\n    if connection is None:\n        connection = connector.AdobeRequest(\n            config_object=config.config_object, header=config.header\n        )\n    endpoint = config.endpoints[\"global\"] + \"/data/core/xcore/\"\n    params = {\"product\": product, \"limit\": limit}\n    myHeader = deepcopy(connection.header)\n    myHeader[\"Accept\"] = \"application/vnd.adobe.platform.xcore.home.hal+json\"\n    res = connection.getData(endpoint, params=params, headers=myHeader)\n    return res", "\n\ndef getPlatformEvents(\n    limit: int = 50, n_results: Union[int, str] = \"inf\", prop: str = None, **kwargs\n) -> dict:\n    \"\"\"\n    Timestamped records of observed activities in Platform. The API allows you to query events over the last 90 days and create export requests.\n    Arguments:\n        limit : OPTIONAL : Number of events to retrieve per request (50 by default)\n        n_results : OPTIONAL : Number of total event to retrieve per request.\n        prop : OPTIONAL : An array that contains one or more of a comma-separated list of properties (prop=\"action==create,assetType==Sandbox\")\n            If you want to filter results using multiple values for a single filter, pass in a comma-separated list of values. (prop=\"action==create,update\")\n    \"\"\"\n    global connection\n    if connection is None:\n        connection = connector.AdobeRequest(\n            config_object=config.config_object, header=config.header\n        )\n    endpoint = \"https://platform.adobe.io/data/foundation/audit/events\"\n    params = {\"limit\": limit}\n    if prop is not None:\n        params[\"property\"] = prop\n    # myHeader = deepcopy(connection.header)\n    lastPage = False\n    data = list()\n    while lastPage != True:\n        res = connection.getData(endpoint, params=params)\n        data += res.get(\"_embedded\", {}).get(\"events\", [])\n        nextPage = res.get(\"_links\", {}).get(\"next\", {}).get('href','')\n        if float(len(data)) >= float(n_results):\n            lastPage = True\n        if nextPage == \"\" and lastPage != True:\n            lastPage = True\n        else:\n            start = nextPage.split(\"start=\")[1].split(\"&\")[0]\n            queryId = nextPage.split(\"queryId=\")[1].split(\"&\")[0]\n            params[\"queryId\"] = queryId\n            params[\"start\"] = start\n    return data", "\n\ndef saveFile(\n    module: str = None,\n    file: object = None,\n    filename: str = None,\n    type_file: str = \"json\",\n    encoding: str = \"utf-8\",\n):\n    \"\"\"\n    Save the file in the approriate folder depending on the module sending the information.\n     Arguments:\n          module: REQUIRED: Module requesting the save file.\n          file: REQUIRED: an object containing the file to save.\n          filename: REQUIRED: the filename to be used.\n          type_file: REQUIRED: the type of file to be saveed(default: json)\n          encoding : OPTIONAL : encoding used to write the file.\n    \"\"\"\n    if module is None:\n        raise ValueError(\"Require the module to create a folder\")\n    if file is None or filename is None:\n        raise ValueError(\"Require a object for file and a name for the file\")\n    here = Path(Path.cwd())\n    folder = module.capitalize()\n    new_location = Path.joinpath(here, folder)\n    if new_location.exists() == False:\n        new_location.mkdir()\n    if type_file == \"json\":\n        filename = f\"{filename}.json\"\n        complete_path = Path.joinpath(new_location, filename)\n        with open(complete_path, \"w\", encoding=encoding) as f:\n            f.write(json.dumps(file, indent=4))\n    else:\n        filename = f\"{filename}.txt\"\n        complete_path = Path.joinpath(new_location, filename)\n        with open(complete_path, \"w\", encoding=encoding) as f:\n            f.write(file)", ""]}
{"filename": "aepp/destination.py", "chunked_list": ["#  Copyright 2023 Adobe. All rights reserved.\n#  This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License. You may obtain a copy\n#  of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software distributed under\n#  the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n#  OF ANY KIND, either express or implied. See the License for the specific language\n#  governing permissions and limitations under the License.\n", "#  governing permissions and limitations under the License.\n\n# Internal Library\nimport aepp\nfrom aepp import connector\nfrom aepp import config\nfrom copy import deepcopy\nfrom typing import Union\nimport time\nimport logging", "import time\nimport logging\nfrom .configs import ConnectObject\n\nclass Authoring:\n    \"\"\"\n    This class is referring to Destination Authoring capability for AEP. \n    It is a suite of configuration APIs that allow you to configure destination integration patterns for Experience Platform to deliver audience and profile data to your endpoint, based on data and authentication formats of your choice.\n    More information on the API, available at: https://developer.adobe.com/experience-platform-apis/references/destination-authoring/\n    \"\"\"\n\n    def __init__(self, \n        config: Union[dict,ConnectObject] = aepp.config.config_object,\n        header: dict = aepp.config.header,\n        loggingObject: dict = None,\n        **kwargs,):\n        \"\"\"\n        Instanciating the class for Authoring.\n\n        Arguments:\n            loggingObject : OPTIONAL : logging object to log messages.\n            config : OPTIONAL : config object in the config module.\n            header : OPTIONAL : header object  in the config module.\n        possible kwargs:\n        \"\"\"\n        if loggingObject is not None and sorted(\n            [\"level\", \"stream\", \"format\", \"filename\", \"file\"]\n        ) == sorted(list(loggingObject.keys())):\n            self.loggingEnabled = True\n            self.logger = logging.getLogger(f\"{__name__}\")\n            self.logger.setLevel(loggingObject[\"level\"])\n            if type(loggingObject[\"format\"]) == str:\n                formatter = logging.Formatter(loggingObject[\"format\"])\n            elif type(loggingObject[\"format\"]) == logging.Formatter:\n                formatter = loggingObject[\"format\"]\n            if loggingObject[\"file\"]:\n                fileHandler = logging.FileHandler(loggingObject[\"filename\"])\n                fileHandler.setFormatter(formatter)\n                self.logger.addHandler(fileHandler)\n            if loggingObject[\"stream\"]:\n                streamHandler = logging.StreamHandler()\n                streamHandler.setFormatter(formatter)\n                self.logger.addHandler(streamHandler)\n        if type(config) == dict: ## Supporting either default setup or passing a ConnectObject\n            config = config\n        elif type(config) == ConnectObject:\n            header = config.getConfigHeader()\n            config = config.getConfigObject()\n        self.connector = connector.AdobeRequest(\n            config=config,\n            header=header,\n            loggingEnabled=self.loggingEnabled,\n            logger=self.logger,\n        )\n        self.header = self.connector.header\n        # self.header.update({\"Accept\": \"application/json\"})\n        self.header.update(**kwargs)\n        if kwargs.get('sandbox',None) is not None: ## supporting sandbox setup on class instanciation\n            self.sandbox = kwargs.get('sandbox')\n            self.connector.config[\"sandbox\"] = kwargs.get('sandbox')\n            self.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n            self.connector.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n        else:\n            self.sandbox = self.connector.config[\"sandbox\"]\n        self.endpoint = config.endpoints[\"global\"] + config.endpoints[\"destinationAuthoring\"]\n    \n    def getDestinations(self)->list:\n        \"\"\"\n        Return a list of all destination SDK authored by the organization.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getDestinations\")\n        path = \"/destinations\"\n        res = self.connector.getData(self.endpoint + path)\n        return res\n    \n    def getDestination(self, destinationId:str = None)->dict:\n        \"\"\"\n        Return a destination specific configuration.\n        Arguments:\n            destinationId : REQUIRED : The destination ID to be retrieved\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getDestination with ID : {destinationId}\")\n        if destinationId is None:\n            raise ValueError(\"Require a destination ID\")\n        path = f\"/destinations/{destinationId}\"\n        res = self.connector.getData(self.endpoint + path)\n        return res\n    \n    def deleteDestination(self, destinationId: str = None)->dict:\n        \"\"\"\n        Delete a specific destination based on its ID.\n        Arguments:\n            destinationId : REQUIRED : The destination ID to be deleted\n        \"\"\"\n        if destinationId is None:\n            raise ValueError(\"Require a destination ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteDestination with ID: {destinationId}\")\n        path = f\"/destinations/{destinationId}\"\n        res = self.connector.deleteData(self.endpoint + path)\n        return res\n    \n    def createDestination(self, destinationObj: dict = None)->dict:\n        \"\"\"\n        Create a destination based on the definition passed in argument.\n        Arguments:\n            destinationObj : REQUIRED : Object containing the definition of the destination.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createDestination\")\n        if destinationObj is None or type(destinationObj) != dict:\n            raise Exception(\"Require a dictionary defining the destination configuration\")\n        path = \"/destinations\"\n        res = self.connector.postData(self.endpoint + path, data=destinationObj)\n        return res\n\n    def updateDestination(self, destinationId:str=None,destinationObj: dict = None)->dict:\n        \"\"\"\n        Create a destination based on the definition passed in argument.\n        Arguments:\n            destinationId : REQUIRED : The destination ID to be updated\n            destinationObj : REQUIRED : Object containing the definition of the destination.\n        \"\"\"\n        if destinationId is None:\n            raise ValueError(\"Require a destination ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting updateDestination with ID: {destinationId}\")\n        if destinationObj is None or type(destinationObj) != dict:\n            raise Exception(\"Require a dictionary defining the destination configuration\")\n        path = \"/destinations\"\n        res = self.connector.putData(self.endpoint + path, data=destinationObj)\n        return res\n    \n    def getDestinationServers(self)->list:\n        \"\"\"\n        Retrieve a list of all destination server configurations for your IMS Organization\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getDestinationServers\")\n        path = \"/destination-servers\"\n        res = self.connector.getData(self.endpoint + path)\n        return res\n    \n    def getDestinationServer(self,serverId:str=None)->dict:\n        \"\"\"\n        Retrieve a specific destination server configuration by its ID.\n        Arguments:\n            serverId : REQUIRED : destination server ID of the server\n        \"\"\"\n        if serverId is None:\n            raise ValueError(\"Require a server ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getDestinationServer with ID: {serverId}\")\n        path = f\"/destination-servers/{serverId}\"\n        res = self.connector.getData(self.endpoint + path)\n        return res\n    \n    def deleteDestinationServer(self,serverId:str = None)->dict:\n        \"\"\"\n        Delete a destination server by its ID.\n        Arguments:\n            serverId : REQUIRED : destination server ID to be deleted\n        \"\"\"\n        if serverId is None:\n            raise ValueError(\"Require a server ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteDestinationServer with ID: {serverId}\")\n        path = f\"/destination-servers/{serverId}\"\n        res = self.connector.deleteData(self.endpoint + path)\n        return res\n\n    def createDestinationServer(self,serverObj:dict=None)->dict:\n        \"\"\"\n        Create a new destination server configuration.\n        Arguments:\n            serverObj : REQUIRED : dictionary containing the server destination configuration\n        \"\"\"\n        path = \"/destination-servers\"\n        if serverObj is None:\n            raise ValueError(\"Require a dictionary containing the server configuration\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createDestinationServer\")\n        res = self.connector.postData(self.endpoint + path, data=serverObj)\n        return res\n\n    def updateDestinationServer(self,serverId:str=None, serverObj: dict = None)->dict:\n        \"\"\"\n        Update the destination with a new definition (PUT request)\n        Arguments:\n            serverId : REQUIRED : destination server ID to be updated\n            serverObj : REQUIRED : dictionary containing the server configuration\n        \"\"\"\n        if serverId is None:\n            raise ValueError(\"Require a destination server ID\")\n        if serverObj is None or type(serverObj) != dict:\n            raise Exception(\"Require a dictionary defining the server destination configuration\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting updateDestinationServer with ID: {serverId}\")\n        path = f\"/destination-servers/{serverId}\"\n        res = self.connector.putData(self.endpoint+path, data=serverObj)\n        return res\n    \n    def getAudienceTemplates(self)->list:\n        \"\"\"\n        Return a list of all audience templates for your IMS Organization\n        \"\"\"\n        path = \"/audience-templates\"\n        res = self.connector.getData(self.endpoint+path)\n        return res\n    \n    def getAudienceTemplate(self,audienceId:str=None)->dict:\n        \"\"\"\n        Return a specific Audience Template.\n        Arguments:\n            audienceId : REQUIRED : The ID of the audience template configuration that you want to retrieve.\n        \"\"\"\n        if audienceId is None:\n            raise ValueError(\"Require an audience ID\")\n        path = f\"/audience-templates/{audienceId}\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getAudienceTemplate with ID: {audienceId}\")\n        res = self.connector.getData(self.endpoint + path)\n        return res\n    \n    def deleteAudienceTemplate(self,audienceId:str=None)->dict:\n        \"\"\"\n        Delete a specific Audience Template.\n        Arguments:\n            audienceId : REQUIRED : The ID of the audience template configuration that you want to delete\n        \"\"\"\n        if audienceId is None:\n            raise ValueError(\"Require an audience ID\")\n        path = f\"/audience-templates/{audienceId}\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteAudienceTemplate with ID: {audienceId}\")\n        res = self.connector.deleteData(self.endpoint + path)\n        return res\n\n    def createAudienceTemplate(self,templateObj:dict=None)->dict:\n        \"\"\"\n        Create a specific Audience Template based on a dictionary definition passed as parameter.\n        Arguments:\n            templateObj : REQUIRED : The ID of the audience template configuration that you want to retrieve.\n        \"\"\"\n        path = f\"/audience-templates/\"\n        if templateObj is None and type(templateObj) != dict:\n            raise ValueError(\"Require a dictionary for Audience template definition\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createAudienceTemplate\")\n        res = self.connector.postData(self.endpoint + path,data=templateObj)\n        return res\n    \n    def updateAudienceTemplate(self,audienceId:str=None,templateObj:dict=None)->dict:\n        \"\"\"\n        Update a specific Audience Template based on a dictionary definition passed as parameter.\n        Arguments:\n            audienceId : REQUIRED : The ID of the audience template configuration that you want to delete\n            templateObj : REQUIRED : The ID of the audience template configuration that you want to retrieve.\n        \"\"\"\n        path = f\"/audience-templates/{audienceId}\"\n        if audienceId is None:\n            raise ValueError(\"Require an audience template ID\")\n        if templateObj is  None and type(templateObj) != dict:\n            raise ValueError(\"Require a dictionary for Audience template definition\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting updateAudienceTemplate with ID: {audienceId}\")\n        res = self.connector.postData(self.endpoint + path,data=templateObj)\n        return res\n\n    def getCredentials(self)->list:\n        \"\"\"\n        Retrieve a list of all credentials configurations for your IMS Organization \n        \"\"\"\n        path = \"/credentials\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getCredentials\")\n        res = self.connector.getData(self.endpoint + path)\n        return res\n    \n    def getCredential(self,credentialId:str=None)->dict:\n        \"\"\"\n        Return a specific credential based on its ID.\n        Arguments:\n            credentialId : REQUIRED : The ID of the credential to retrieve\n        \"\"\"\n        if credentialId is None:\n            raise ValueError(\"Require a credential ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getCredential with ID: {credentialId}\")\n        path = f\"/credentials/{credentialId}\"\n        res = self.connector.getData(self.endpoint + path)\n        return res\n    \n    def deleteCredential(self,credentialId:str=None)->dict:\n        \"\"\"\n        Delete a specific credential based on its ID\n        Arguments:\n            credentialId : REQUIRED : Credential ID to be deleted\n        \"\"\"\n        if credentialId is None:\n            raise ValueError(\"Require a credential ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteCredential with ID: {credentialId}\")\n        path = f\"/credentials/{credentialId}\"\n        res = self.connector.deleteData(self.endpoint + path)\n        return res\n    \n    def createCredential(self,credentialObj:dict=None)->dict:\n        \"\"\"\n        Create a credential configuration based on the dictionary passed.\n        Arguments:\n            credentialObj : REQUIRED : The credential object definition\n        \"\"\"\n        if credentialObj is None or type(credentialObj) != dict:\n            raise ValueError(\"Require a dictionary for definition\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createCredential\")\n        path = \"/credentials\"\n        res = self.connector.postData(self.endpoint + path,data=credentialObj)\n        return res\n    \n    def updateCredential(self,credentialId:str=None,credentialObj:dict=None)->dict:\n        \"\"\"\n        Update the credential configuration based on the dictionary and the credential ID passed.\n        Arguments:\n            credentialId : REQUIRED : The credentialId to be updated\n            credentialObj : REQUIRED : The credential object definition\n        \"\"\"\n        if credentialObj is None or type(credentialObj) != dict:\n            raise ValueError(\"Require a dictionary for definition\")\n        path = f\"/credentials/{credentialId}\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting updateCredential with ID: {credentialId}\")\n        res = self.connector.putData(self.endpoint + path,data=credentialObj)\n        return res\n    \n    def getSampleProfile(self,destinationInstanceId:str=None,destinationId:str=None,count:int=100)->dict:\n        \"\"\"\n        Generate a sample profile of a destination given the correct arguments.\n        Arguments:\n            destinationInstanceId : REQUIRED : Also known as order ID. The ID of the destination instance based on which you are generating sample profiles. (example: \"49966037-32cd-4457-a105-2cbf9c01826a\")\n                                    Documentation on how to retrieve it: https://experienceleague.adobe.com/docs/experience-platform/destinations/destination-sdk/api/developer-tools-reference/destination-testing-api.html?lang=en#get-destination-instance-id\n            destinationId : REQUIRED : he ID of the destination configuration based on which you are generating sample profiles. The destination ID that you should use here is the ID that corresponds to a destination configuration, created using the createDestination method.\n            count : OPTIONAL : The number of sample profiles that you are generating. The parameter can take values between 1 - 1000.\n        \"\"\"\n        if destinationId is None:\n            raise ValueError(\"Require a destination ID\")\n        if destinationInstanceId is None:\n            raise ValueError(\"Require a destination instance ID\")\n        path = \"/sample-profiles\"\n        params = {\n            \"destinationInstanceId\" : destinationInstanceId,\n            \"destinationId\" : destinationId,\n            \"count\" : count\n        }\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getSampleProfile\")\n        res = self.connector.getData(self.endpoint + path,params=params)\n        return res\n    \n    def getSampleDestination(self,destinationConfigId:str=None)->dict:\n        \"\"\"\n        Returns a sample template corresponding to the destinationID passed.\n        Argument:\n            destinationConfigId : REQUIRED : The ID of the destination configuration for which you are generating a message transformation template.\n                                            The destination ID that you should use here is the ID that corresponds to a destination configuration, created using the createDestination method\n        \"\"\"\n        if destinationConfigId is None:\n            raise ValueError(\"A Destination configuration ID must be specified\")\n        path = f\"/testing/template/sample/{destinationConfigId}\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getSampleDestination with ID: {destinationConfigId}\")\n        res = self.connector.getData(self.endpoint + path)\n        return res\n\n    def generateTestProfile(self,destinationId:str=None,template:str=None,profiles:list=None)->str:\n        \"\"\"\n        Generate exported data by making a POST request to the testing/template/render endpoint and providing the destination ID of the destination configuration and the template you created using the sample template API endpoint\n        Arguments:\n            destinationId : REQUIRED : The ID of the destination configuration for which you are rendering exported data.\n            template : REQUIRED : The character-escaped version of the template based on which you are rendering exported data.\n            profiles : OPTIONAL : list of dictionary returned by the getSampleProfile method\n        \"\"\"\n        if destinationId is None:\n            raise ValueError(\"Require a destination ID\")\n        if template is None and type(template) != str:\n            raise ValueError(\"Must provide a string that is an escape version of the template\")\n        path = f\"/testing/template/render\"\n        data = {\n            \"destinationId\": destinationId,\n            \"template\": template,\n        }\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getSampleDestination with ID: {destinationId}\")\n        if profiles is not None and type(profiles) == list:\n            data['profiles'] = profiles\n        res = self.connector.postData(self.endpoint+path, data=data)\n        return res\n    \n    def sendMessageToPartner(self,destinationInstanceId:str=None,profiles:list=None)->dict:\n        \"\"\"\n        Test the connection to your destination by sending messages to the partner endpoint.\n        Optionally, you can send a list of profiles in the request. If you do not send any profiles, Experience Platform generates those internally. \n        In this case, you can view the profiles that were used for validation in the response you receive from your getSampleProfile endpoint.\n        Arguments:\n            destinationInstanceId : REQUIRED : Also known as order ID. The ID of the destination instance based on which you are generating sample profiles.\n                                            See documentation for info on how to retrieve it: https://experienceleague.adobe.com/docs/experience-platform/destinations/destination-sdk/api/developer-tools-reference/destination-testing-api.html?lang=en#get-destination-instance-id\n            profiles : OPTIONAL : list of dictionary returned by the getSampleProfile method\n        \"\"\"\n        if destinationInstanceId is None:\n            raise ValueError(\"Require a destination instance ID\")\n        path = f\"/testing/destinationInstance/{destinationInstanceId}\"\n        data = []\n        if profiles is not None:\n            data = profiles\n        res = self.connector.postData(self.endpoint+path,data=data)\n        return res\n\n    def getSubmissions(self)->list:\n        \"\"\"\n        List of all destinations submitted for publishing for your IMS Organization\n        \"\"\"\n        path = \"/destinations/publish\"\n        res = self.connector.getData(self.endpoint+path)\n        return res\n    \n    def getSubmission(self,destinationConfigId:str=None)->dict:\n        \"\"\"\n        Get a specific destination submission status based on the ID passed.\n        Argument:\n            destinationConfigId : REQUIRED : The ID of the destination configuration you have submitted for publishing.\n        \"\"\"\n        if destinationConfigId is None:\n            raise ValueError(\"Destination configuration ID is required\")\n        path = f\"/destinations/publish/{destinationConfigId}\"\n        res = self.connector.getData(self.endpoint+path)\n        return res\n    \n    def SubmitDestination(self,destinationObj:dict=None)->dict:\n        \"\"\"\n        Submit a destination configuration for publishing\n        Arguments:\n            destinationObj : REQUIRED : The object defining the destination config. (DestinationId, Access, AllowedOrgs)\n        \"\"\"\n        path = \"/destinations/publish/\"\n        if destinationObj is None:\n            raise ValueError(\"A destination object must be specified\")\n        res = self.connector.postData(self.endpoint+path,data=destinationObj)\n        return res\n\n    def updateSubmissionRequest(self,destinationConfigId:str,destinationObj:dict=None)->dict:\n        \"\"\"\n        Update the allowed organizations in a destination publish request. \n        Arguments:\n           destinationConfigId : REQUIRED : The ID of the destination configuration you have submitted for publishing.\n           destinationObj : REQUIRED : The object defining the destination config. (DestinationId, Access, AllowedOrgs)\n        \"\"\"\n        if destinationConfigId is None:\n            raise ValueError(\"Require of destinationConfigId value\")\n        if destinationObj is None:\n            raise ValueError(\"Require a dictionary for defining\")\n        path = f\"/destinations/publish/{destinationConfigId}\"\n        res = self.connector.putData(self.endpoint+path,data=destinationObj)\n        return res", "\n"]}
{"filename": "aepp/connector.py", "chunked_list": ["#  Copyright 2023 Adobe. All rights reserved.\n#  This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License. You may obtain a copy\n#  of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software distributed under\n#  the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n#  OF ANY KIND, either express or implied. See the License for the specific language\n#  governing permissions and limitations under the License.\n", "#  governing permissions and limitations under the License.\n\n## Internal modules\nfrom aepp import config, configs\n\n## External module\nimport json\nimport os\nfrom dataclasses import dataclass\nfrom typing import Dict, Optional, Union", "from dataclasses import dataclass\nfrom typing import Dict, Optional, Union\nfrom copy import deepcopy\nimport time\nimport requests\nfrom requests import Response\nfrom pathlib import Path\nimport jwt\n\n@dataclass\nclass TokenInfo:\n    \"\"\"\n    Represents an IMS token along with metadata associated to it.\n    \"\"\"\n    token: str\n    expiry: int", "\n@dataclass\nclass TokenInfo:\n    \"\"\"\n    Represents an IMS token along with metadata associated to it.\n    \"\"\"\n    token: str\n    expiry: int\n\n\nclass AdobeRequest:\n    \"\"\"\n    Handle request to Audience Manager and taking care that the request have a valid token set each time.\n    \"\"\"\n\n    loggingEnabled = False\n\n    def __init__(\n        self,\n        config: Union[dict,configs.ConnectObject] = config.config_object,\n        header: dict = config.header,\n        endpoints: dict = config.endpoints,\n        verbose: bool = False,\n        loggingEnabled: bool = False,\n        logger: object = None,\n        retry: int = 0,\n        **kwargs,\n    ) -> None:\n        \"\"\"\n        Set the connector to be used for handling request to AAM\n        Arguments:\n            config_object : OPTIONAL : Require the importConfig file to have been used.\n            header : OPTIONAL : Header that you are already using.\n            endpoints : OPTIONAL : Maps service to their endpoint.\n            verbose : OPTIONAL : display comment while running\n            loggingEnabled : OPTIONAL : if the logging is enable for that instance.\n            logger : OPTIONAL : instance of the logger created\n            retry : OPTIONAL : When GET request fails, if set to an int, it will retry this number of time\n        \"\"\"\n        if type(config) != dict:\n            config = config.getConfigObject()\n        if config[\"org_id\"] == \"\":\n            raise Exception(\n                \"You have to upload the configuration file with importConfigFile or configure method.\"\n            )\n        self.config = deepcopy(config)\n        self.header = deepcopy(header)\n        self.endpoints = deepcopy(endpoints)\n        self.loggingEnabled = loggingEnabled\n        self.logger = logger\n        self.retry = retry\n        requests.packages.urllib3.disable_warnings()\n        if self.config[\"token\"] == \"\" or time.time() > self.config[\"date_limit\"]:\n            if self.config[\"private_key\"] is not None or self.config[\"pathToKey\"] is not None:\n                self.connectionType = 'jwt'\n                token_info = self.get_jwt_token_and_expiry_for_config(\n                    config=self.config,\n                    verbose=verbose,\n                    aepScope=kwargs.get(\"aepScope\"),\n                    privacyScope=kwargs.get(\"privacyScope\"),\n                )\n            elif self.config[\"scopes\"] is not None:\n                self.connectionType = 'oauthV2'\n                token_info = self.get_oauth_token_and_expiry_for_config(\n                    config=self.config,\n                    verbose=verbose\n                )\n            else:\n                self.connectionType = 'oauthV1'\n                token_info = self.get_oauth_token_and_expiry_for_config(\n                    config=self.config,\n                    verbose=verbose\n                )\n            self.token = token_info.token\n            self.config[\"token\"] = self.token\n            if self.connectionType == 'jwt':\n                timeScale = 1000 ## jwt returns milliseconds expiry\n            elif self.connectionType == 'oauthV1' or self.connectionType == 'oauthV2':\n                timeScale = 1 ## oauth returns seconds expiry\n            self.config[\"date_limit\"] = (\n                time.time() + token_info.expiry / timeScale - 500\n            )\n            self.header.update({\"Authorization\": f\"Bearer {self.token}\"})\n        # x-sandbox-id is required when using non-user token, but forbidden for user token\n        if self.connectionType == 'oauthV1' and \"x-sandbox-id\" not in self.header:\n            self.update_sandbox_id(self.config[\"sandbox\"])\n\n    def _find_path(self, path: str) -> Optional[Path]:\n        \"\"\"Checks if the file denoted by the specified `path` exists and returns the Path object\n        for the file.\n\n        If the file under the `path` does not exist and the path denotes an absolute path, tries\n        to find the file by converting the absolute path to a relative path.\n\n        If the file does not exist with either the absolute and the relative path, returns `None`.\n        \"\"\"\n        if Path(path).exists():\n            return Path(path)\n        elif path.startswith(\"/\") and Path(\".\" + path).exists():\n            return Path(\".\" + path)\n        elif path.startswith(\"\\\\\") and Path(\".\" + path).exists():\n            return Path(\".\" + path)\n        else:\n            return None\n\n    def get_oauth_token_and_expiry_for_config(\n        self,\n        config: Union[dict,configs.ConnectObject],\n        verbose: bool = False,\n        save: bool = False\n    ) -> TokenInfo:\n        \"\"\"\n        Retrieve the access token by using the OAuth information provided by the user\n        during the import importConfigFile function.\n        Arguments :\n            config : REQUIRED : Configuration object.\n            verbose : OPTIONAL : Default False. If set to True, print information.\n            save : OPTIONAL : Default False. If set to True, save the toke in the .\n        \"\"\"\n        if type(config)!= dict:\n            config = config.getConfigObject()\n        if self.connectionType == 'oauthV1':\n            oauth_payload = {\n                \"grant_type\": \"authorization_code\",\n                \"client_id\": config[\"client_id\"],\n                \"client_secret\": config[\"secret\"],\n                \"code\": config[\"auth_code\"]\n            }\n            response = requests.post(\n                config[\"oauthTokenEndpointV1\"], data=oauth_payload, verify=False\n            )\n        elif self.connectionType == 'oauthV2':\n            oauth_payload = {\n                \"grant_type\": \"client_credentials\",\n                \"client_id\": config[\"client_id\"],\n                \"client_secret\": config[\"secret\"],\n                \"scope\": config[\"scopes\"]\n            }\n            response = requests.post(\n                config[\"oauthTokenEndpointV2\"], data=oauth_payload, verify=False\n            )\n        return self._token_postprocess(response=response, verbose=verbose, save=save)\n\n    def get_jwt_token_and_expiry_for_config(\n        self,\n        config: Union[dict,configs.ConnectObject],\n        verbose: bool = False,\n        save: bool = False,\n        **kwargs\n    ) -> TokenInfo:\n        \"\"\"\n        Retrieve the access token by using the JWT information provided by the user\n        during the import importConfigFile function.\n        Arguments :\n            config : REQUIRED : Configuration object.\n            verbose : OPTIONAL : Default False. If set to True, print information.\n            save : OPTIONAL : Default False. If set to True, save the toke in the .\n        \"\"\"\n        if type(config) != dict:\n            config = config.getConfigObject()\n        private_key = configs.get_private_key_from_config(config)\n        header_jwt = {\n            \"cache-control\": \"no-cache\",\n            \"content-type\": \"application/x-www-form-urlencoded\",\n        }\n        now_plus_24h = int(time.time()) + 24 * 60 * 60\n        jwt_payload = {\n            \"exp\": now_plus_24h,\n            \"iss\": config[\"org_id\"],\n            \"sub\": config[\"tech_id\"],\n            f\"{self.config['imsEndpoint']}/s/ent_dataservices_sdk\": True,\n            \"aud\": f'{self.config[\"imsEndpoint\"]}/c/{config[\"client_id\"]}',\n        }\n        # privacy topic\n        if kwargs.get(\"privacyScope\", False):\n            jwt_payload[f\"{self.config['imsEndpoint']}/s/ent_gdpr_sdk\"] = True\n        if kwargs.get(\"aepScope\", True) is False:\n            del jwt_payload[f\"{self.config['imsEndpoint']}/s/ent_dataservices_sdk\"]\n        encoded_jwt = self._get_jwt(payload=jwt_payload, private_key=private_key)\n\n        payload = {\n            \"client_id\": config[\"client_id\"],\n            \"client_secret\": config[\"secret\"],\n            \"jwt_token\": encoded_jwt,\n        }\n        response = requests.post(\n            config[\"jwtTokenEndpoint\"], headers=header_jwt, data=payload, verify=False\n        )\n        return self._token_postprocess(response=response, verbose=verbose, save=save)\n\n    def _token_postprocess(\n        self,\n        response: Response,\n        verbose: bool = False,\n        save: bool = False\n    ) -> TokenInfo:\n        \"\"\"\n        Parse the IMS response to extract token information\n        Arguments :\n            response : REQUIRED : API response payload from IMS.\n            verbose : OPTIONAL : Default False. If set to True, print information.\n            save : OPTIONAL : Default False. If set to True, save the toke in the .\n        \"\"\"\n        json_response = response.json()\n        try:\n            self.token = json_response[\"access_token\"]\n            self.config[\"token\"] = self.token\n        except KeyError:\n            print(\"Issue retrieving token\")\n            print(json_response)\n        expiry = json_response[\"expires_in\"]\n        if save:\n            with open(\"token.txt\", \"w\") as f:\n                f.write(self.token)\n            print(f\"token has been saved here: {os.getcwd()}{os.sep}token.txt\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"token retrieved: {self.token}\")\n        if verbose:\n            print(\"token valid till : \" + time.ctime(time.time() + expiry))\n        if self.loggingEnabled:\n            self.logger.debug(\n                f\"token valid till : {time.ctime(time.time() + expiry)}\"\n            )\n        return TokenInfo(token=self.token, expiry=expiry)\n\n    def _get_jwt(self, payload: dict, private_key: str) -> str:\n        \"\"\"\n        Ensure that jwt enconding return the same type (str) as versions < 2.0.0 returned bytes and >2.0.0 return strings.\n        \"\"\"\n        token: Union[str, bytes] = jwt.encode(payload, private_key, algorithm=\"RS256\")\n        if isinstance(token, bytes):\n            return token.decode(\"utf-8\")\n        return token\n\n    def _checkingDate(self) -> None:\n        \"\"\"\n        Checking if the token is still valid\n        \"\"\"\n        now = time.time()\n        if now > self.config[\"date_limit\"]:\n            if self.loggingEnabled:\n                self.logger.warning(\"token expired. Trying to retrieve a new token\")\n            if self.connectionType == 'jwt':\n                token_with_expiry = self.get_jwt_token_and_expiry_for_config(config=self.config)\n            elif self.connectionType == 'oauthV1' or self.connectionType == 'oauthV2':\n                token_with_expiry = self.get_oauth_token_and_expiry_for_config(config=self.config)\n            self.token = token_with_expiry[\"token\"]\n            self.config[\"token\"] = self.token\n            if self.loggingEnabled:\n                self.logger.info(\"new token retrieved : {self.token}\")\n            self.header.update({\"Authorization\": f\"Bearer {self.token}\"})\n            if self.connectionType == 'jwt':\n                timeScale = 1000 ## jwt returns milliseconds expiry\n            elif self.connectionType == 'oauthV1' or self.connectionType == 'oauthV2':\n                timeScale = 1 ## oauth returns seconds expiry\n            self.config[\"date_limit\"] = (\n                time.time() + token_with_expiry[\"expiry\"] / timeScale - 500\n            )\n\n    def updateSandbox(self, sandbox: str) -> None:\n        \"\"\"\n        Update the sandbox used for the request\n        Arguments:\n            sandbox : REQUIRED : the sandbox to use for the requests\n        \"\"\"\n        if not sandbox:\n            raise Exception(\"require a sandbox\")\n        self.header[\"x-sandbox-name\"] = sandbox\n\n    def update_sandbox_id(self, sandbox: str) -> None:\n        \"\"\"\n        Update the sandbox ID used for the request.\n        This is required when using non-user credentials. Only internal adobe tools and oauth V1 can access this.\n        Arguments:\n            sandbox : REQUIRED : the sandbox name to use for the requests\n        \"\"\"\n        if not sandbox:\n            raise Exception(\"require a sandbox\")\n        endpoint = f\"{self.endpoints['global']}{self.endpoints['sandboxes']}/sandboxes/{sandbox}\"\n        res = self.getData(endpoint)\n        if \"id\" not in res:\n            raise Exception(\"sandbox Id not found\")\n        sandbox_id = res[\"id\"]\n        self.header[\"x-sandbox-id\"] = sandbox_id\n\n    def getData(\n        self,\n        endpoint: str,\n        params: dict = None,\n        data: dict = None,\n        headers: dict = None,\n        *args,\n        **kwargs,\n    ):\n        \"\"\"\n        Abstraction for getting data\n        \"\"\"\n        self._checkingDate()\n        if headers is None:\n            headers = self.header\n        if self.loggingEnabled:\n            self.logger.debug(\n                f\"Start GET request to {endpoint} with header: {json.dumps(headers)}\"\n            )\n        if params is None and data is None:\n            res = requests.get(endpoint, headers=headers, verify=False)\n        elif params is not None and data is None:\n            if self.loggingEnabled:\n                self.logger.debug(f\"params: {json.dumps(params)}\")\n            res = requests.get(endpoint, headers=headers, params=params, verify=False)\n        elif params is None and data is not None:\n            if self.loggingEnabled:\n                self.logger.debug(f\"data: {json.dumps(data)}\")\n            res = requests.get(endpoint, headers=headers, data=data, verify=False)\n        elif params is not None and data is not None:\n            if self.loggingEnabled:\n                self.logger.debug(f\"params: {json.dumps(params)}\")\n                self.logger.debug(f\"data: {json.dumps(data)}\")\n            res = requests.get(endpoint, headers=headers, params=params, data=data, verify=False)\n        if self.loggingEnabled:\n            self.logger.debug(f\"endpoint used: {res.request.url}\")\n            self.logger.debug(f\"params used: {params}\")\n        try:\n            if kwargs.get(\"format\", \"json\") == \"json\":\n                res_json = res.json()\n            if kwargs.get(\"format\", \"json\") == \"txt\":\n                res_json = res.text\n            elif kwargs.get(\"format\", \"json\") == \"raw\":\n                res_json = res\n            else:\n                res_json = res.json()\n        except:\n            if kwargs.get(\"verbose\", False):\n                print(res.text)\n            if self.loggingEnabled:\n                self.logger.warning(f\"error: {res.text}\")\n            res_json = {\"error\": \"Request Error - could not generate json\"}\n            if self.retry > 0:\n                if self.loggingEnabled:\n                    self.logger.info(f\"starting retry: {self.retry} to do\")\n                for each in range(self.retry):\n                    if \"error\" in res_json.keys():\n                        time.sleep(5)\n                        res_json = self.getData(\n                            endpoint, params, data, headers, **kwargs\n                        )\n        try:  ## sometimes list is being returned\n            if type(res_json) == dict:\n                if \"errorMessage\" in res_json.keys():\n                    if self.loggingEnabled:\n                        self.logger.error(\n                            f\"GET method failed: {res.status_code}, {res['errorMessage']}\"\n                        )\n                    print(f\"status code : {res.status_code}\")\n                    print(f\"error message : {res['errorMessage']}\")\n        except:\n            pass\n        ## returning some errors in the console\n        if type(res_json) == dict:\n            if 'status' in res_json.keys() and 'report' in res_json.keys():\n                if self.loggingEnabled:\n                    self.logger.warning(json.dumps(res_json,indent=2))\n        return res_json\n\n    def headData(\n        self, endpoint: str, params: dict = None, headers: dict = None, *args, **kwargs\n    ):\n        \"\"\"\n        Abstraction for the head method.\n        \"\"\"\n        self._checkingDate()\n        if headers is None:\n            headers = self.header\n        if self.loggingEnabled:\n            self.logger.debug(\n                f\"Start GET request to {endpoint} with header: {json.dumps(headers)}\"\n            )\n        if params is None:\n            res = requests.head(endpoint, headers=headers, verify=False)\n        if params is not None:\n            res = requests.head(endpoint, headers=headers, params=params, verify=False)\n        try:\n            res_header = res.headers()\n        except:\n            if kwargs.get(\"verbose\", False):\n                print(\"error generating the JSON response\")\n                print(f\"status: {res.status_code}\")\n                print(res.text)\n            if res.status_code != 200:\n                res_header = res.headers()\n            else:\n                res_header = {}\n        return res_header\n\n    def postData(\n        self,\n        endpoint: str,\n        params: dict = None,\n        data: dict = None,\n        bytesData: bytes = None,\n        headers: dict = None,\n        *args,\n        **kwargs,\n    ):\n        \"\"\"\n        Abstraction for posting data\n        \"\"\"\n        self._checkingDate()\n        if headers is None:\n            headers = self.header\n        if self.loggingEnabled:\n            self.logger.debug(\n                f\"Start POST request to {endpoint} with header: {json.dumps(headers)}\"\n            )\n        if params is None and data is None:\n            res = requests.post(endpoint, headers=headers, verify=False)\n        elif params is not None and data is None:\n            if self.loggingEnabled:\n                self.logger.debug(f\"params: {json.dumps(params)}\")\n            res = requests.post(endpoint, headers=headers, params=params, verify=False)\n        elif params is None and data is not None:\n            if self.loggingEnabled:\n                self.logger.debug(f\"data: {json.dumps(data)}\")\n            res = requests.post(endpoint, headers=headers, data=json.dumps(data), verify=False)\n        elif params is not None and data is not None:\n            if self.loggingEnabled:\n                self.logger.debug(f\"params: {json.dumps(params)}\")\n                self.logger.debug(f\"data: {json.dumps(data)}\")\n            res = requests.post(\n                endpoint, headers=headers, params=params, data=json.dumps(data), verify=False\n            )\n        elif bytesData is not None:\n            if self.loggingEnabled:\n                self.logger.debug(f\"bytes data used\")\n            res = requests.post(\n                endpoint, headers=headers, params=params, data=bytesData, verify=False\n            )\n        try:\n            formatUse = kwargs.get(\"format\", \"json\")\n            if self.loggingEnabled:\n                self.logger.debug(f\"format used: {formatUse}\")\n            if formatUse == \"json\":\n                res_json = res.json()\n            elif formatUse == \"txt\":\n                res_json = res.text\n            elif formatUse == \"raw\":\n                res_json = res\n            else:\n                res_json = res.json()\n        except:\n            if kwargs.get(\"verbose\", False):\n                print(\"error generating the JSON response\")\n                print(f\"status: {res.status_code}\")\n                print(res.text)\n            if res.status_code != 200:\n                try:\n                    res_json = res.json()\n                except:\n                    res_json = {\"error\": \"Request Error - could not generate JSON\"}\n            else:\n                res_json = {}\n        try:  ## sometimes list is being returned\n            if \"errorMessage\" in res_json.keys():\n                print(f\"status code : {res.status_code}\")\n        except:\n            pass\n        return res_json\n\n    def patchData(\n        self,\n        endpoint: str,\n        params: dict = None,\n        data=None,\n        headers: dict = None,\n        *args,\n        **kwargs,\n    ):\n        \"\"\"\n        Abstraction for deleting data\n        \"\"\"\n        self._checkingDate()\n        if headers is None:\n            headers = self.header\n        if self.loggingEnabled:\n            self.logger.debug(\n                f\"Start PATCH request to {endpoint} with header: {json.dumps(headers)}\"\n            )\n        if params is not None and data is None:\n            if self.loggingEnabled:\n                self.logger.debug(f\"params: {json.dumps(params)}\")\n            res = requests.patch(endpoint, headers=headers, params=params, verify=False)\n        elif params is None and data is not None:\n            if self.loggingEnabled:\n                self.logger.debug(f\"data: {json.dumps(data)}\")\n            res = requests.patch(endpoint, headers=headers, data=json.dumps(data), verify=False)\n        elif params is not None and data is not None:\n            if self.loggingEnabled:\n                self.logger.debug(f\"params: {json.dumps(params)}\")\n                self.logger.debug(f\"data: {json.dumps(data)}\")\n            res = requests.patch(\n                endpoint, headers=headers, params=params, data=json.dumps(data), verify=False\n            )\n        try:\n            res_json = res.json()\n        except:\n            if kwargs.get(\"verbose\", False):\n                print(\"error generating the JSON response\")\n                print(f\"status: {res.status_code}\")\n                print(res.text)\n            if self.loggingEnabled:\n                self.logger.error(\n                    f\"error with the response {res.status_code}: {res.text}\"\n                )\n            if res.status_code != 200:\n                try:\n                    res_json = res.json()\n                except:\n                    res_json = {\"error\": \"Request Error - could not generate JSON\"}\n            else:\n                res_json = {}\n        return res_json\n\n    def putData(\n        self,\n        endpoint: str,\n        params: dict = None,\n        data=None,\n        headers: dict = None,\n        *args,\n        **kwargs,\n    ):\n        \"\"\"\n        Abstraction for deleting data\n        \"\"\"\n        self._checkingDate()\n        if headers is None:\n            headers = self.header\n        if self.loggingEnabled:\n            self.logger.debug(\n                f\"Start PUT request to {endpoint} with header: {json.dumps(headers)}\"\n            )\n        if params is not None and data is None:\n            if self.loggingEnabled:\n                self.logger.debug(f\"params: {json.dumps(params)}\")\n            res = requests.put(endpoint, headers=headers, params=params, verify=False)\n        elif params is None and data is not None:\n            if self.loggingEnabled:\n                self.logger.debug(f\"data: {json.dumps(data)}\")\n            res = requests.put(endpoint, headers=headers, data=json.dumps(data), verify=False)\n        elif params is not None and data is not None:\n            if self.loggingEnabled:\n                self.logger.debug(f\"params: {json.dumps(params)}\")\n                self.logger.debug(f\"data: {json.dumps(data)}\")\n            res = requests.put(\n                endpoint, headers=headers, params=params, data=json.dumps(data), verify=False\n            )\n        try:\n            res_json = res.json()\n        except:\n            if kwargs.get(\"verbose\", False):\n                print(\"error generating the JSON response\")\n                print(f\"status: {res.status_code}\")\n                print(res.text)\n            if self.loggingEnabled:\n                self.logger.error(\n                    f\"error with the response {res.status_code}: {res.text}\"\n                )\n            if res.status_code != 200:\n                res_json = {\"error\": res.text}\n            else:\n                res_json = {}\n        return res_json\n\n    def deleteData(\n        self, endpoint: str, params: dict = None, headers: dict = None, *args, **kwargs\n    ):\n        \"\"\"\n        Abstraction for deleting data\n        \"\"\"\n        self._checkingDate()\n        if headers is None:\n            headers = self.header\n        if self.loggingEnabled:\n            self.logger.debug(\n                f\"Start PUT request to {endpoint} with header: {json.dumps(headers)}\"\n            )\n        if params is None:\n            res = requests.delete(endpoint, headers=headers, verify=False)\n        elif params is not None:\n            res = requests.delete(endpoint, headers=headers, params=params, verify=False)\n        try:\n            status_code = res.status_code\n            if status_code >= 400:\n                if self.loggingEnabled:\n                    self.logger.error(\n                        f\"error with the response {res.status_code}: {res.text}\"\n                    )\n                return res.json()\n        except:\n            if kwargs.get(\"verbose\", False):\n                print(res.text)\n            status_code = res.status_code\n        return status_code", "\n\nclass AdobeRequest:\n    \"\"\"\n    Handle request to Audience Manager and taking care that the request have a valid token set each time.\n    \"\"\"\n\n    loggingEnabled = False\n\n    def __init__(\n        self,\n        config: Union[dict,configs.ConnectObject] = config.config_object,\n        header: dict = config.header,\n        endpoints: dict = config.endpoints,\n        verbose: bool = False,\n        loggingEnabled: bool = False,\n        logger: object = None,\n        retry: int = 0,\n        **kwargs,\n    ) -> None:\n        \"\"\"\n        Set the connector to be used for handling request to AAM\n        Arguments:\n            config_object : OPTIONAL : Require the importConfig file to have been used.\n            header : OPTIONAL : Header that you are already using.\n            endpoints : OPTIONAL : Maps service to their endpoint.\n            verbose : OPTIONAL : display comment while running\n            loggingEnabled : OPTIONAL : if the logging is enable for that instance.\n            logger : OPTIONAL : instance of the logger created\n            retry : OPTIONAL : When GET request fails, if set to an int, it will retry this number of time\n        \"\"\"\n        if type(config) != dict:\n            config = config.getConfigObject()\n        if config[\"org_id\"] == \"\":\n            raise Exception(\n                \"You have to upload the configuration file with importConfigFile or configure method.\"\n            )\n        self.config = deepcopy(config)\n        self.header = deepcopy(header)\n        self.endpoints = deepcopy(endpoints)\n        self.loggingEnabled = loggingEnabled\n        self.logger = logger\n        self.retry = retry\n        requests.packages.urllib3.disable_warnings()\n        if self.config[\"token\"] == \"\" or time.time() > self.config[\"date_limit\"]:\n            if self.config[\"private_key\"] is not None or self.config[\"pathToKey\"] is not None:\n                self.connectionType = 'jwt'\n                token_info = self.get_jwt_token_and_expiry_for_config(\n                    config=self.config,\n                    verbose=verbose,\n                    aepScope=kwargs.get(\"aepScope\"),\n                    privacyScope=kwargs.get(\"privacyScope\"),\n                )\n            elif self.config[\"scopes\"] is not None:\n                self.connectionType = 'oauthV2'\n                token_info = self.get_oauth_token_and_expiry_for_config(\n                    config=self.config,\n                    verbose=verbose\n                )\n            else:\n                self.connectionType = 'oauthV1'\n                token_info = self.get_oauth_token_and_expiry_for_config(\n                    config=self.config,\n                    verbose=verbose\n                )\n            self.token = token_info.token\n            self.config[\"token\"] = self.token\n            if self.connectionType == 'jwt':\n                timeScale = 1000 ## jwt returns milliseconds expiry\n            elif self.connectionType == 'oauthV1' or self.connectionType == 'oauthV2':\n                timeScale = 1 ## oauth returns seconds expiry\n            self.config[\"date_limit\"] = (\n                time.time() + token_info.expiry / timeScale - 500\n            )\n            self.header.update({\"Authorization\": f\"Bearer {self.token}\"})\n        # x-sandbox-id is required when using non-user token, but forbidden for user token\n        if self.connectionType == 'oauthV1' and \"x-sandbox-id\" not in self.header:\n            self.update_sandbox_id(self.config[\"sandbox\"])\n\n    def _find_path(self, path: str) -> Optional[Path]:\n        \"\"\"Checks if the file denoted by the specified `path` exists and returns the Path object\n        for the file.\n\n        If the file under the `path` does not exist and the path denotes an absolute path, tries\n        to find the file by converting the absolute path to a relative path.\n\n        If the file does not exist with either the absolute and the relative path, returns `None`.\n        \"\"\"\n        if Path(path).exists():\n            return Path(path)\n        elif path.startswith(\"/\") and Path(\".\" + path).exists():\n            return Path(\".\" + path)\n        elif path.startswith(\"\\\\\") and Path(\".\" + path).exists():\n            return Path(\".\" + path)\n        else:\n            return None\n\n    def get_oauth_token_and_expiry_for_config(\n        self,\n        config: Union[dict,configs.ConnectObject],\n        verbose: bool = False,\n        save: bool = False\n    ) -> TokenInfo:\n        \"\"\"\n        Retrieve the access token by using the OAuth information provided by the user\n        during the import importConfigFile function.\n        Arguments :\n            config : REQUIRED : Configuration object.\n            verbose : OPTIONAL : Default False. If set to True, print information.\n            save : OPTIONAL : Default False. If set to True, save the toke in the .\n        \"\"\"\n        if type(config)!= dict:\n            config = config.getConfigObject()\n        if self.connectionType == 'oauthV1':\n            oauth_payload = {\n                \"grant_type\": \"authorization_code\",\n                \"client_id\": config[\"client_id\"],\n                \"client_secret\": config[\"secret\"],\n                \"code\": config[\"auth_code\"]\n            }\n            response = requests.post(\n                config[\"oauthTokenEndpointV1\"], data=oauth_payload, verify=False\n            )\n        elif self.connectionType == 'oauthV2':\n            oauth_payload = {\n                \"grant_type\": \"client_credentials\",\n                \"client_id\": config[\"client_id\"],\n                \"client_secret\": config[\"secret\"],\n                \"scope\": config[\"scopes\"]\n            }\n            response = requests.post(\n                config[\"oauthTokenEndpointV2\"], data=oauth_payload, verify=False\n            )\n        return self._token_postprocess(response=response, verbose=verbose, save=save)\n\n    def get_jwt_token_and_expiry_for_config(\n        self,\n        config: Union[dict,configs.ConnectObject],\n        verbose: bool = False,\n        save: bool = False,\n        **kwargs\n    ) -> TokenInfo:\n        \"\"\"\n        Retrieve the access token by using the JWT information provided by the user\n        during the import importConfigFile function.\n        Arguments :\n            config : REQUIRED : Configuration object.\n            verbose : OPTIONAL : Default False. If set to True, print information.\n            save : OPTIONAL : Default False. If set to True, save the toke in the .\n        \"\"\"\n        if type(config) != dict:\n            config = config.getConfigObject()\n        private_key = configs.get_private_key_from_config(config)\n        header_jwt = {\n            \"cache-control\": \"no-cache\",\n            \"content-type\": \"application/x-www-form-urlencoded\",\n        }\n        now_plus_24h = int(time.time()) + 24 * 60 * 60\n        jwt_payload = {\n            \"exp\": now_plus_24h,\n            \"iss\": config[\"org_id\"],\n            \"sub\": config[\"tech_id\"],\n            f\"{self.config['imsEndpoint']}/s/ent_dataservices_sdk\": True,\n            \"aud\": f'{self.config[\"imsEndpoint\"]}/c/{config[\"client_id\"]}',\n        }\n        # privacy topic\n        if kwargs.get(\"privacyScope\", False):\n            jwt_payload[f\"{self.config['imsEndpoint']}/s/ent_gdpr_sdk\"] = True\n        if kwargs.get(\"aepScope\", True) is False:\n            del jwt_payload[f\"{self.config['imsEndpoint']}/s/ent_dataservices_sdk\"]\n        encoded_jwt = self._get_jwt(payload=jwt_payload, private_key=private_key)\n\n        payload = {\n            \"client_id\": config[\"client_id\"],\n            \"client_secret\": config[\"secret\"],\n            \"jwt_token\": encoded_jwt,\n        }\n        response = requests.post(\n            config[\"jwtTokenEndpoint\"], headers=header_jwt, data=payload, verify=False\n        )\n        return self._token_postprocess(response=response, verbose=verbose, save=save)\n\n    def _token_postprocess(\n        self,\n        response: Response,\n        verbose: bool = False,\n        save: bool = False\n    ) -> TokenInfo:\n        \"\"\"\n        Parse the IMS response to extract token information\n        Arguments :\n            response : REQUIRED : API response payload from IMS.\n            verbose : OPTIONAL : Default False. If set to True, print information.\n            save : OPTIONAL : Default False. If set to True, save the toke in the .\n        \"\"\"\n        json_response = response.json()\n        try:\n            self.token = json_response[\"access_token\"]\n            self.config[\"token\"] = self.token\n        except KeyError:\n            print(\"Issue retrieving token\")\n            print(json_response)\n        expiry = json_response[\"expires_in\"]\n        if save:\n            with open(\"token.txt\", \"w\") as f:\n                f.write(self.token)\n            print(f\"token has been saved here: {os.getcwd()}{os.sep}token.txt\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"token retrieved: {self.token}\")\n        if verbose:\n            print(\"token valid till : \" + time.ctime(time.time() + expiry))\n        if self.loggingEnabled:\n            self.logger.debug(\n                f\"token valid till : {time.ctime(time.time() + expiry)}\"\n            )\n        return TokenInfo(token=self.token, expiry=expiry)\n\n    def _get_jwt(self, payload: dict, private_key: str) -> str:\n        \"\"\"\n        Ensure that jwt enconding return the same type (str) as versions < 2.0.0 returned bytes and >2.0.0 return strings.\n        \"\"\"\n        token: Union[str, bytes] = jwt.encode(payload, private_key, algorithm=\"RS256\")\n        if isinstance(token, bytes):\n            return token.decode(\"utf-8\")\n        return token\n\n    def _checkingDate(self) -> None:\n        \"\"\"\n        Checking if the token is still valid\n        \"\"\"\n        now = time.time()\n        if now > self.config[\"date_limit\"]:\n            if self.loggingEnabled:\n                self.logger.warning(\"token expired. Trying to retrieve a new token\")\n            if self.connectionType == 'jwt':\n                token_with_expiry = self.get_jwt_token_and_expiry_for_config(config=self.config)\n            elif self.connectionType == 'oauthV1' or self.connectionType == 'oauthV2':\n                token_with_expiry = self.get_oauth_token_and_expiry_for_config(config=self.config)\n            self.token = token_with_expiry[\"token\"]\n            self.config[\"token\"] = self.token\n            if self.loggingEnabled:\n                self.logger.info(\"new token retrieved : {self.token}\")\n            self.header.update({\"Authorization\": f\"Bearer {self.token}\"})\n            if self.connectionType == 'jwt':\n                timeScale = 1000 ## jwt returns milliseconds expiry\n            elif self.connectionType == 'oauthV1' or self.connectionType == 'oauthV2':\n                timeScale = 1 ## oauth returns seconds expiry\n            self.config[\"date_limit\"] = (\n                time.time() + token_with_expiry[\"expiry\"] / timeScale - 500\n            )\n\n    def updateSandbox(self, sandbox: str) -> None:\n        \"\"\"\n        Update the sandbox used for the request\n        Arguments:\n            sandbox : REQUIRED : the sandbox to use for the requests\n        \"\"\"\n        if not sandbox:\n            raise Exception(\"require a sandbox\")\n        self.header[\"x-sandbox-name\"] = sandbox\n\n    def update_sandbox_id(self, sandbox: str) -> None:\n        \"\"\"\n        Update the sandbox ID used for the request.\n        This is required when using non-user credentials. Only internal adobe tools and oauth V1 can access this.\n        Arguments:\n            sandbox : REQUIRED : the sandbox name to use for the requests\n        \"\"\"\n        if not sandbox:\n            raise Exception(\"require a sandbox\")\n        endpoint = f\"{self.endpoints['global']}{self.endpoints['sandboxes']}/sandboxes/{sandbox}\"\n        res = self.getData(endpoint)\n        if \"id\" not in res:\n            raise Exception(\"sandbox Id not found\")\n        sandbox_id = res[\"id\"]\n        self.header[\"x-sandbox-id\"] = sandbox_id\n\n    def getData(\n        self,\n        endpoint: str,\n        params: dict = None,\n        data: dict = None,\n        headers: dict = None,\n        *args,\n        **kwargs,\n    ):\n        \"\"\"\n        Abstraction for getting data\n        \"\"\"\n        self._checkingDate()\n        if headers is None:\n            headers = self.header\n        if self.loggingEnabled:\n            self.logger.debug(\n                f\"Start GET request to {endpoint} with header: {json.dumps(headers)}\"\n            )\n        if params is None and data is None:\n            res = requests.get(endpoint, headers=headers, verify=False)\n        elif params is not None and data is None:\n            if self.loggingEnabled:\n                self.logger.debug(f\"params: {json.dumps(params)}\")\n            res = requests.get(endpoint, headers=headers, params=params, verify=False)\n        elif params is None and data is not None:\n            if self.loggingEnabled:\n                self.logger.debug(f\"data: {json.dumps(data)}\")\n            res = requests.get(endpoint, headers=headers, data=data, verify=False)\n        elif params is not None and data is not None:\n            if self.loggingEnabled:\n                self.logger.debug(f\"params: {json.dumps(params)}\")\n                self.logger.debug(f\"data: {json.dumps(data)}\")\n            res = requests.get(endpoint, headers=headers, params=params, data=data, verify=False)\n        if self.loggingEnabled:\n            self.logger.debug(f\"endpoint used: {res.request.url}\")\n            self.logger.debug(f\"params used: {params}\")\n        try:\n            if kwargs.get(\"format\", \"json\") == \"json\":\n                res_json = res.json()\n            if kwargs.get(\"format\", \"json\") == \"txt\":\n                res_json = res.text\n            elif kwargs.get(\"format\", \"json\") == \"raw\":\n                res_json = res\n            else:\n                res_json = res.json()\n        except:\n            if kwargs.get(\"verbose\", False):\n                print(res.text)\n            if self.loggingEnabled:\n                self.logger.warning(f\"error: {res.text}\")\n            res_json = {\"error\": \"Request Error - could not generate json\"}\n            if self.retry > 0:\n                if self.loggingEnabled:\n                    self.logger.info(f\"starting retry: {self.retry} to do\")\n                for each in range(self.retry):\n                    if \"error\" in res_json.keys():\n                        time.sleep(5)\n                        res_json = self.getData(\n                            endpoint, params, data, headers, **kwargs\n                        )\n        try:  ## sometimes list is being returned\n            if type(res_json) == dict:\n                if \"errorMessage\" in res_json.keys():\n                    if self.loggingEnabled:\n                        self.logger.error(\n                            f\"GET method failed: {res.status_code}, {res['errorMessage']}\"\n                        )\n                    print(f\"status code : {res.status_code}\")\n                    print(f\"error message : {res['errorMessage']}\")\n        except:\n            pass\n        ## returning some errors in the console\n        if type(res_json) == dict:\n            if 'status' in res_json.keys() and 'report' in res_json.keys():\n                if self.loggingEnabled:\n                    self.logger.warning(json.dumps(res_json,indent=2))\n        return res_json\n\n    def headData(\n        self, endpoint: str, params: dict = None, headers: dict = None, *args, **kwargs\n    ):\n        \"\"\"\n        Abstraction for the head method.\n        \"\"\"\n        self._checkingDate()\n        if headers is None:\n            headers = self.header\n        if self.loggingEnabled:\n            self.logger.debug(\n                f\"Start GET request to {endpoint} with header: {json.dumps(headers)}\"\n            )\n        if params is None:\n            res = requests.head(endpoint, headers=headers, verify=False)\n        if params is not None:\n            res = requests.head(endpoint, headers=headers, params=params, verify=False)\n        try:\n            res_header = res.headers()\n        except:\n            if kwargs.get(\"verbose\", False):\n                print(\"error generating the JSON response\")\n                print(f\"status: {res.status_code}\")\n                print(res.text)\n            if res.status_code != 200:\n                res_header = res.headers()\n            else:\n                res_header = {}\n        return res_header\n\n    def postData(\n        self,\n        endpoint: str,\n        params: dict = None,\n        data: dict = None,\n        bytesData: bytes = None,\n        headers: dict = None,\n        *args,\n        **kwargs,\n    ):\n        \"\"\"\n        Abstraction for posting data\n        \"\"\"\n        self._checkingDate()\n        if headers is None:\n            headers = self.header\n        if self.loggingEnabled:\n            self.logger.debug(\n                f\"Start POST request to {endpoint} with header: {json.dumps(headers)}\"\n            )\n        if params is None and data is None:\n            res = requests.post(endpoint, headers=headers, verify=False)\n        elif params is not None and data is None:\n            if self.loggingEnabled:\n                self.logger.debug(f\"params: {json.dumps(params)}\")\n            res = requests.post(endpoint, headers=headers, params=params, verify=False)\n        elif params is None and data is not None:\n            if self.loggingEnabled:\n                self.logger.debug(f\"data: {json.dumps(data)}\")\n            res = requests.post(endpoint, headers=headers, data=json.dumps(data), verify=False)\n        elif params is not None and data is not None:\n            if self.loggingEnabled:\n                self.logger.debug(f\"params: {json.dumps(params)}\")\n                self.logger.debug(f\"data: {json.dumps(data)}\")\n            res = requests.post(\n                endpoint, headers=headers, params=params, data=json.dumps(data), verify=False\n            )\n        elif bytesData is not None:\n            if self.loggingEnabled:\n                self.logger.debug(f\"bytes data used\")\n            res = requests.post(\n                endpoint, headers=headers, params=params, data=bytesData, verify=False\n            )\n        try:\n            formatUse = kwargs.get(\"format\", \"json\")\n            if self.loggingEnabled:\n                self.logger.debug(f\"format used: {formatUse}\")\n            if formatUse == \"json\":\n                res_json = res.json()\n            elif formatUse == \"txt\":\n                res_json = res.text\n            elif formatUse == \"raw\":\n                res_json = res\n            else:\n                res_json = res.json()\n        except:\n            if kwargs.get(\"verbose\", False):\n                print(\"error generating the JSON response\")\n                print(f\"status: {res.status_code}\")\n                print(res.text)\n            if res.status_code != 200:\n                try:\n                    res_json = res.json()\n                except:\n                    res_json = {\"error\": \"Request Error - could not generate JSON\"}\n            else:\n                res_json = {}\n        try:  ## sometimes list is being returned\n            if \"errorMessage\" in res_json.keys():\n                print(f\"status code : {res.status_code}\")\n        except:\n            pass\n        return res_json\n\n    def patchData(\n        self,\n        endpoint: str,\n        params: dict = None,\n        data=None,\n        headers: dict = None,\n        *args,\n        **kwargs,\n    ):\n        \"\"\"\n        Abstraction for deleting data\n        \"\"\"\n        self._checkingDate()\n        if headers is None:\n            headers = self.header\n        if self.loggingEnabled:\n            self.logger.debug(\n                f\"Start PATCH request to {endpoint} with header: {json.dumps(headers)}\"\n            )\n        if params is not None and data is None:\n            if self.loggingEnabled:\n                self.logger.debug(f\"params: {json.dumps(params)}\")\n            res = requests.patch(endpoint, headers=headers, params=params, verify=False)\n        elif params is None and data is not None:\n            if self.loggingEnabled:\n                self.logger.debug(f\"data: {json.dumps(data)}\")\n            res = requests.patch(endpoint, headers=headers, data=json.dumps(data), verify=False)\n        elif params is not None and data is not None:\n            if self.loggingEnabled:\n                self.logger.debug(f\"params: {json.dumps(params)}\")\n                self.logger.debug(f\"data: {json.dumps(data)}\")\n            res = requests.patch(\n                endpoint, headers=headers, params=params, data=json.dumps(data), verify=False\n            )\n        try:\n            res_json = res.json()\n        except:\n            if kwargs.get(\"verbose\", False):\n                print(\"error generating the JSON response\")\n                print(f\"status: {res.status_code}\")\n                print(res.text)\n            if self.loggingEnabled:\n                self.logger.error(\n                    f\"error with the response {res.status_code}: {res.text}\"\n                )\n            if res.status_code != 200:\n                try:\n                    res_json = res.json()\n                except:\n                    res_json = {\"error\": \"Request Error - could not generate JSON\"}\n            else:\n                res_json = {}\n        return res_json\n\n    def putData(\n        self,\n        endpoint: str,\n        params: dict = None,\n        data=None,\n        headers: dict = None,\n        *args,\n        **kwargs,\n    ):\n        \"\"\"\n        Abstraction for deleting data\n        \"\"\"\n        self._checkingDate()\n        if headers is None:\n            headers = self.header\n        if self.loggingEnabled:\n            self.logger.debug(\n                f\"Start PUT request to {endpoint} with header: {json.dumps(headers)}\"\n            )\n        if params is not None and data is None:\n            if self.loggingEnabled:\n                self.logger.debug(f\"params: {json.dumps(params)}\")\n            res = requests.put(endpoint, headers=headers, params=params, verify=False)\n        elif params is None and data is not None:\n            if self.loggingEnabled:\n                self.logger.debug(f\"data: {json.dumps(data)}\")\n            res = requests.put(endpoint, headers=headers, data=json.dumps(data), verify=False)\n        elif params is not None and data is not None:\n            if self.loggingEnabled:\n                self.logger.debug(f\"params: {json.dumps(params)}\")\n                self.logger.debug(f\"data: {json.dumps(data)}\")\n            res = requests.put(\n                endpoint, headers=headers, params=params, data=json.dumps(data), verify=False\n            )\n        try:\n            res_json = res.json()\n        except:\n            if kwargs.get(\"verbose\", False):\n                print(\"error generating the JSON response\")\n                print(f\"status: {res.status_code}\")\n                print(res.text)\n            if self.loggingEnabled:\n                self.logger.error(\n                    f\"error with the response {res.status_code}: {res.text}\"\n                )\n            if res.status_code != 200:\n                res_json = {\"error\": res.text}\n            else:\n                res_json = {}\n        return res_json\n\n    def deleteData(\n        self, endpoint: str, params: dict = None, headers: dict = None, *args, **kwargs\n    ):\n        \"\"\"\n        Abstraction for deleting data\n        \"\"\"\n        self._checkingDate()\n        if headers is None:\n            headers = self.header\n        if self.loggingEnabled:\n            self.logger.debug(\n                f\"Start PUT request to {endpoint} with header: {json.dumps(headers)}\"\n            )\n        if params is None:\n            res = requests.delete(endpoint, headers=headers, verify=False)\n        elif params is not None:\n            res = requests.delete(endpoint, headers=headers, params=params, verify=False)\n        try:\n            status_code = res.status_code\n            if status_code >= 400:\n                if self.loggingEnabled:\n                    self.logger.error(\n                        f\"error with the response {res.status_code}: {res.text}\"\n                    )\n                return res.json()\n        except:\n            if kwargs.get(\"verbose\", False):\n                print(res.text)\n            status_code = res.status_code\n        return status_code", ""]}
{"filename": "aepp/destinationinstanceservice.py", "chunked_list": ["#  Copyright 2023 Adobe. All rights reserved.\n#  This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License. You may obtain a copy\n#  of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software distributed under\n#  the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n#  OF ANY KIND, either express or implied. See the License for the specific language\n#  governing permissions and limitations under the License.\n", "#  governing permissions and limitations under the License.\n\n# Internal Library\nimport aepp\nfrom aepp import connector\nfrom typing import Union\nimport logging\nfrom .configs import ConnectObject\n\nclass DestinationInstanceService:\n    loggingEnabled = False\n    logger = None\n    \"\"\"\n    This class is referring to Destination Instance Service capability for AEP.\n    \"\"\"\n    def __init__(self,\n        config: Union[dict,ConnectObject] = aepp.config.config_object,\n        header: dict = aepp.config.header,\n        loggingObject: dict = None,\n        **kwargs,):\n        \"\"\"\n        Instantiating the class for destination instance service\n\n        Arguments:\n            loggingObject : OPTIONAL : logging object to log messages.\n            config : OPTIONAL : config object in the config module.\n            header : OPTIONAL : header object  in the config module.\n        possible kwargs:\n        \"\"\"\n        if loggingObject is not None and sorted(\n            [\"level\", \"stream\", \"format\", \"filename\", \"file\"]\n        ) == sorted(list(loggingObject.keys())):\n            self.loggingEnabled = True\n            self.logger = logging.getLogger(f\"{__name__}\")\n            self.logger.setLevel(loggingObject[\"level\"])\n            if type(loggingObject[\"format\"]) == str:\n                formatter = logging.Formatter(loggingObject[\"format\"])\n            elif type(loggingObject[\"format\"]) == logging.Formatter:\n                formatter = loggingObject[\"format\"]\n            if loggingObject[\"file\"]:\n                fileHandler = logging.FileHandler(loggingObject[\"filename\"])\n                fileHandler.setFormatter(formatter)\n                self.logger.addHandler(fileHandler)\n            if loggingObject[\"stream\"]:\n                streamHandler = logging.StreamHandler()\n                streamHandler.setFormatter(formatter)\n                self.logger.addHandler(streamHandler)\n        if type(config) == dict: ## Supporting either default setup or passing a ConnectObject\n            config = config\n        elif type(config) == ConnectObject:\n            header = config.getConfigHeader()\n            config = config.getConfigObject()\n        self.connector = connector.AdobeRequest(\n            config=config,\n            header=header,\n            loggingEnabled=self.loggingEnabled,\n            logger=self.logger,\n        )\n        self.header = self.connector.header\n        # self.header.update({\"Accept\": \"application/json\"})\n        self.header.update(**kwargs)\n        if kwargs.get('sandbox',None) is not None: ## supporting sandbox setup on class instantiation\n            self.sandbox = kwargs.get('sandbox')\n            self.connector.config[\"sandbox\"] = kwargs.get('sandbox')\n            self.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n            self.connector.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n        else:\n            self.sandbox = self.connector.config[\"sandbox\"]\n        self.endpoint = aepp.config.endpoints[\"global\"] + aepp.config.endpoints[\"destinationInstance\"]\n        \n        \n    def createAdHocDatasetExport(self, flowIdToDatasetIds: dict = None)->dict:\n        \"\"\"\n        Create an Adhoc Request based on the flowId and the datasetId passed in argument.\n        Arguments:\n            flowIdToDatasetIds : REQUIRED :  dict containing the definition of flowId to datasetIds\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting creating adhoc dataset export\")\n        if flowIdToDatasetIds is None or type(flowIdToDatasetIds) != dict:\n            raise Exception(\"Require a dict for defining the flowId to datasetIds mapping\")\n        activationInfo = {'activationInfo': {'destinations': []}};\n        for flowId, datasetIds in flowIdToDatasetIds.items():\n            destination = {'flowId': flowId, 'datasets': []}\n            for datasetId in datasetIds:\n                dataset = {'id': datasetId}\n                destination['datasets'].append(dataset)\n            activationInfo['activationInfo']['destinations'].append(destination)\n        self.header.update({\"Accept\":\"application/vnd.adobe.adhoc.dataset.activation+json; version=1\"})\n        path = \"/adhocrun\"\n        res = self.connector.postData(self.endpoint + path, data=activationInfo)\n        return res", "\nclass DestinationInstanceService:\n    loggingEnabled = False\n    logger = None\n    \"\"\"\n    This class is referring to Destination Instance Service capability for AEP.\n    \"\"\"\n    def __init__(self,\n        config: Union[dict,ConnectObject] = aepp.config.config_object,\n        header: dict = aepp.config.header,\n        loggingObject: dict = None,\n        **kwargs,):\n        \"\"\"\n        Instantiating the class for destination instance service\n\n        Arguments:\n            loggingObject : OPTIONAL : logging object to log messages.\n            config : OPTIONAL : config object in the config module.\n            header : OPTIONAL : header object  in the config module.\n        possible kwargs:\n        \"\"\"\n        if loggingObject is not None and sorted(\n            [\"level\", \"stream\", \"format\", \"filename\", \"file\"]\n        ) == sorted(list(loggingObject.keys())):\n            self.loggingEnabled = True\n            self.logger = logging.getLogger(f\"{__name__}\")\n            self.logger.setLevel(loggingObject[\"level\"])\n            if type(loggingObject[\"format\"]) == str:\n                formatter = logging.Formatter(loggingObject[\"format\"])\n            elif type(loggingObject[\"format\"]) == logging.Formatter:\n                formatter = loggingObject[\"format\"]\n            if loggingObject[\"file\"]:\n                fileHandler = logging.FileHandler(loggingObject[\"filename\"])\n                fileHandler.setFormatter(formatter)\n                self.logger.addHandler(fileHandler)\n            if loggingObject[\"stream\"]:\n                streamHandler = logging.StreamHandler()\n                streamHandler.setFormatter(formatter)\n                self.logger.addHandler(streamHandler)\n        if type(config) == dict: ## Supporting either default setup or passing a ConnectObject\n            config = config\n        elif type(config) == ConnectObject:\n            header = config.getConfigHeader()\n            config = config.getConfigObject()\n        self.connector = connector.AdobeRequest(\n            config=config,\n            header=header,\n            loggingEnabled=self.loggingEnabled,\n            logger=self.logger,\n        )\n        self.header = self.connector.header\n        # self.header.update({\"Accept\": \"application/json\"})\n        self.header.update(**kwargs)\n        if kwargs.get('sandbox',None) is not None: ## supporting sandbox setup on class instantiation\n            self.sandbox = kwargs.get('sandbox')\n            self.connector.config[\"sandbox\"] = kwargs.get('sandbox')\n            self.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n            self.connector.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n        else:\n            self.sandbox = self.connector.config[\"sandbox\"]\n        self.endpoint = aepp.config.endpoints[\"global\"] + aepp.config.endpoints[\"destinationInstance\"]\n        \n        \n    def createAdHocDatasetExport(self, flowIdToDatasetIds: dict = None)->dict:\n        \"\"\"\n        Create an Adhoc Request based on the flowId and the datasetId passed in argument.\n        Arguments:\n            flowIdToDatasetIds : REQUIRED :  dict containing the definition of flowId to datasetIds\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting creating adhoc dataset export\")\n        if flowIdToDatasetIds is None or type(flowIdToDatasetIds) != dict:\n            raise Exception(\"Require a dict for defining the flowId to datasetIds mapping\")\n        activationInfo = {'activationInfo': {'destinations': []}};\n        for flowId, datasetIds in flowIdToDatasetIds.items():\n            destination = {'flowId': flowId, 'datasets': []}\n            for datasetId in datasetIds:\n                dataset = {'id': datasetId}\n                destination['datasets'].append(dataset)\n            activationInfo['activationInfo']['destinations'].append(destination)\n        self.header.update({\"Accept\":\"application/vnd.adobe.adhoc.dataset.activation+json; version=1\"})\n        path = \"/adhocrun\"\n        res = self.connector.postData(self.endpoint + path, data=activationInfo)\n        return res", ""]}
{"filename": "aepp/utils.py", "chunked_list": ["#  Copyright 2023 Adobe. All rights reserved.\n#  This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License. You may obtain a copy\n#  of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software distributed under\n#  the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n#  OF ANY KIND, either express or implied. See the License for the specific language\n#  governing permissions and limitations under the License.\n", "#  governing permissions and limitations under the License.\n\n# internal library\nfrom configparser import ConfigParser\n\nclass Utils:\n\n    @staticmethod\n    def check_if_exists(section, field_name, config_path):\n        config = ConfigParser()\n        config.read(config_path)\n        return config.get(section, field_name) or None\n\n\n    @staticmethod\n    def save_field_in_config(section, field_name, value, config_path):\n        config = ConfigParser()\n        config.read(config_path)\n        config.set(section, field_name, value)\n        with open(config_path, \"w\") as configfile:\n            config.write(configfile)"]}
{"filename": "aepp/exportDatasetToDataLandingZone.py", "chunked_list": ["#  Copyright 2023 Adobe. All rights reserved.\n#  This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License. You may obtain a copy\n#  of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software distributed under\n#  the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n#  OF ANY KIND, either express or implied. See the License for the specific language\n#  governing permissions and limitations under the License.\n", "#  governing permissions and limitations under the License.\n\n# Internal Library\n\nimport aepp\nfrom aepp import flowservice\nfrom aepp import destinationinstanceservice\nimport time\nimport logging\nfrom typing import Union", "import logging\nfrom typing import Union\nfrom aepp.utils import Utils\nfrom .configs import ConnectObject\nfrom tenacity import Retrying\nfrom tenacity import retry_if_result\nfrom tenacity import wait_fixed\nfrom tenacity import stop_after_attempt\nfrom dataclasses import dataclass,asdict,field\n", "from dataclasses import dataclass,asdict,field\n\n@dataclass\nclass Flow:\n    name: str = None\n    flowSpec: dict = field(default_factory=dict)\n    sourceConnectionIds: list = field(default_factory=list)\n    targetConnectionIds: list= field(default_factory=list)\n    scheduleParams: dict = field(default_factory=dict)\n    transformations: list = field(default_factory=list)\n\n    def __init__(self,\n                 name: str,\n                 flow_spec: dict,\n                 source_connection_id: str,\n                 target_connection_id: str,\n                 schedule_params: dict,\n                 transformations: dict\n                 ):\n        self.name = name\n        self.sourceConnectionIds = [source_connection_id]\n        self.targetConnectionIds = [target_connection_id]\n        self.flowSpec = flow_spec\n        self.scheduleParams = schedule_params\n        self.transformations = transformations", "@dataclass\nclass ScheduleParams:\n    interval: int = 0\n    timeUnit: str = None\n    startTime: int = 0\n    def __init__(self,\n                 interval: int,\n                 timeUnit: str,\n                 startTime: int):\n        self.interval = interval\n        self.timeUnit = timeUnit\n        self.startTime = startTime", "\n@dataclass\nclass FlowOp:\n    op: str = None\n    path: str = None\n    value: dict = field(default_factory=dict)\n\n    def __init__(self,\n                 op: str,\n                 path: str,\n                 value: dict):\n        self.op = op\n        self.path = path\n        self.value = value", "\nclass ExportDatasetToDataLandingZone:\n    \"\"\"\n    A class for exporting dataset to cloud storage functionality\n    Attributes\n    ----------\n    flow_conn : module\n        flow service connection\n    dis_conn : module\n        destination instance service connection\n    \"\"\"\n\n    ## logging capability\n    loggingEnabled = False\n    logger = None\n\n    flow_conn = None\n    dis_conn = None\n    #fixed connection spec id for Data Landing Zone, reference: https://experienceleague.adobe.com/docs/experience-platform/destinations/api/export-datasets.html?lang=en\n    DLZ_CONNECTION_SPEC_ID = \"10440537-2a7b-4583-ac39-ed38d4b848e8\"\n    #fixed flow spec id for Data Landing Zone, reference: https://experienceleague.adobe.com/docs/experience-platform/destinations/api/export-datasets.html?lang=en\n    DLZ_FLOW_SEPC_ID = \"cd2fc47e-e838-4f38-a581-8fff2f99b63a\"\n    def __init__(\n            self,\n            config: Union[dict,ConnectObject] = aepp.config.config_object,\n            header: dict = aepp.config.header,\n            loggingObject: dict = None\n    ):\n        \"\"\"\n        initialize the Export Dataset to Data Landing Zone.\n        Arguments:\n            config : OPTIONAL : config object in the config module.\n            header : OPTIONAL : header object  in the config module.\n        \"\"\"\n\n        self.flow_conn = flowservice.FlowService(config=config, header=header)\n        self.dis_conn = destinationinstanceservice.DestinationInstanceService(config=config, header=header)\n        if loggingObject is not None and sorted(\n                [\"level\", \"stream\", \"format\", \"filename\", \"file\"]\n        ) == sorted(list(loggingObject.keys())):\n            self.loggingEnabled = True\n            self.logger = logging.getLogger(f\"{__name__}\")\n            self.logger.setLevel(loggingObject[\"level\"])\n            if type(loggingObject[\"format\"]) == str:\n                formatter = logging.Formatter(loggingObject[\"format\"])\n            elif type(loggingObject[\"format\"]) == logging.Formatter:\n                formatter = loggingObject[\"format\"]\n            if loggingObject[\"file\"]:\n                fileHandler = logging.FileHandler(loggingObject[\"filename\"])\n                fileHandler.setFormatter(formatter)\n                self.logger.addHandler(fileHandler)\n            if loggingObject[\"stream\"]:\n                streamHandler = logging.StreamHandler()\n                streamHandler.setFormatter(formatter)\n                self.logger.addHandler(streamHandler)\n\n    def createDataFlowRunIfNotExists(\n            self,\n            dataset_id: str,\n            compression_type: str,\n            data_format: str,\n            export_path: str,\n            on_schedule: bool,\n            config_path: str,\n            entity_name: str,\n            initial_delay: int = 600) -> str:\n        \"\"\"\n        Create a data flow if not being saved in config file\n        Arguments:\n          dataset_id : REQUIRED : The dataset that needs to be exported\n          compression_type: REQUIRED : define compression type to use when saving data to file. Possible values:\n            gzip\n            none\n          data_format : REQUIRED : define the data format . Possible values:\n            json\n            parquet\n          export_path : REQUIRED : define the folder path in your dlz container\n          on_schedule: REQUIRED: define whether you would like to have the export following a fixed schedule or not\n          config_path: REQUIRED: define the path of your aepp config file\n        Returns:\n            dataflow_id(str)\n        \"\"\"\n        dataflow_id = Utils.check_if_exists(\"Platform\", \"dataflow_id\", config_path)\n        if dataflow_id is not None:\n            if self.loggingEnabled:\n                self.logger.info(f\"Flow {dataflow_id} has already existed in config\")\n            flow = self.flow_conn.getFlow(dataflow_id)\n            source_connection_id = flow[\"sourceConnectionIds\"][0]\n            source_connection = self.flow_conn.getSourceConnection(source_connection_id)\n            exist_dataset_id = source_connection[\"params\"][\"datasets\"][0][\"dataSetId\"]\n            if exist_dataset_id != dataset_id:\n                dataflow_id = self.createDataFlow(dataset_id, compression_type, data_format, export_path, on_schedule, config_path, entity_name)\n            elif flow[\"state\"] == \"disabled\":\n                self.flow_conn.postFlowAction(dataflow_id, \"enable\")\n                if self.loggingEnabled:\n                    self.logger.info(f\"Flow {dataflow_id} with dataset {dataset_id} is enabled\")\n        else:\n            dataflow_id = self.createDataFlow(dataset_id, compression_type, data_format, export_path, on_schedule, config_path, entity_name)\n        self.createFlowRun(dataflow_id, dataset_id, on_schedule, initial_delay)\n        return dataflow_id\n\n    def createDataFlow(\n            self,\n            dataset_id: str,\n            compression_type: str,\n            data_format: str,\n            export_path: str,\n            on_schedule: bool,\n            config_path: str,\n            entity_name: str):\n        \"\"\"\n        Create a data flow as it is not saved in config\n        Arguments:\n          dataset_id : REQUIRED : The dataset that needs to be exported\n          compression_type: REQUIRED : define compression type to use when saving data to file. Possible values:\n            gzip\n            none\n          data_format : REQUIRED : define the data format . Possible values:\n            json\n            parquet\n          export_path : REQUIRED : define the folder path in your dlz container\n          on_schedule: REQUIRED: define whether you would like to have the export following a fixed schedule or not\n          config_path: REQUIRED: define the config file path\n          entity_name: REQUIRED: define the name of flow entities\n        \"\"\"\n        base_connection_id = self.createBaseConnection(entity_name)\n        source_connection_id = self.createSourceConnection(dataset_id, entity_name)\n        target_connection_id = self.createTargetConnection(base_connection_id, compression_type, data_format, export_path, entity_name)\n        dataflow_id = self.createFlow(source_connection_id, target_connection_id, on_schedule, entity_name)\n        #save dataflow_id to config\n        Utils.save_field_in_config(\"Platform\", \"dataflow_id\", dataflow_id, config_path)\n        return dataflow_id\n\n    def createBaseConnection(self, entity_name) -> str:\n        \"\"\"\n        Create a base connection for Data Landing Zone Destination\n        Returns:\n            base_connection_id(str)\n        \"\"\"\n        base_connection_res = self.flow_conn.createConnection(data={\n            \"name\": entity_name,\n            \"auth\": None,\n            \"connectionSpec\": {\n                \"id\": self.DLZ_CONNECTION_SPEC_ID,\n                \"version\": \"1.0\"\n            }\n        })\n        try:\n            base_connection_id = base_connection_res[\"id\"]\n            if self.loggingEnabled:\n                self.logger.info(\"baseConnection \" + base_connection_id + \" has been created\")\n            return base_connection_id\n        except KeyError:\n            raise RuntimeError(f\"Error when creating base connection: {base_connection_res}\")\n\n    def createSourceConnection(self, dataset_id: str, entity_name: str) -> str:\n        \"\"\"\n        Create a source connection for Data Landing Zone Destination\n        Arguments:\n          dataset_id : REQUIRED : The dataset that needs to be exported\n          entity_name: REQUIRED: define the name of source connection\n        Returns:\n          source_connection_id(str)\n        \"\"\"\n        source_res = self.flow_conn.createSourceConnectionDataLake(\n            name= entity_name,\n            dataset_ids=[dataset_id],\n            format=\"parquet\"\n        )\n        try:\n            source_connection_id = source_res[\"id\"]\n            if self.loggingEnabled:\n                self.logger.info(\"sourceConnection \" + source_connection_id + \" has been created.\")\n            return source_connection_id\n        except KeyError:\n            raise RuntimeError(f\"Error when creating source connection: {source_res}\")\n\n    def createTargetConnection(self, base_connection_id: str, compression_type: str, data_format: str, export_path: str, entity_name: str) -> str:\n        \"\"\"\n        Create a target connection for Data Landing Zone Destination\n        Arguments:\n            base_connection_id : REQUIRED : The base connection id created in previous step\n            compression_type: REQUIRED : define compression type to use when saving data to file. Possible values:\n                gzip\n                none\n            data_format : REQUIRED : define the data format . Possible values:\n                json\n                parquet\n            export_path : REQUIRED : define the folder path in your dlz container\n            entity_name: REQUIRED: define the name of target connection\n        Returns:\n          target_connection_id(str)\n        \"\"\"\n        target_res = self.flow_conn.createTargetConnection(\n            data={\n                \"name\": entity_name,\n                \"baseConnectionId\": base_connection_id,\n                \"params\": {\n                    \"mode\": \"Server-to-server\",\n                    \"compression\": compression_type,\n                    \"datasetFileType\": data_format,\n                    \"path\": export_path\n                },\n                \"connectionSpec\": {\n                    \"id\": self.DLZ_CONNECTION_SPEC_ID,\n                    \"version\": \"1.0\"\n                }\n            }\n        )\n        try:\n            target_connection_id = target_res[\"id\"]\n            if self.loggingEnabled:\n                self.logger.info(\"targetConnection \" + target_connection_id + \" has been created\")\n            return target_connection_id\n        except KeyError:\n            raise RuntimeError(f\"Error when creating target connection: {target_res}\")\n\n    def createFlow(self, source_connection_id: str, target_connection_id: str, on_schedule: bool, entity_name: str) -> str:\n        \"\"\"\n        Create a data flow for Data Landing Zone Destination\n        Arguments:\n          source_connection_id : REQUIRED : The source connection id created in previous step\n          target_connection_id : REQUIRED : The target connection id created in previous step\n          on_schedule: REQUIRED: define whether you would like to have the export following a fixed schedule or not\n          entity_name: REQUIRED: define the name of the flow\n        Returns:\n          dataflow_id(str)\n        \"\"\"\n        if on_schedule:\n            schedule_params = asdict(ScheduleParams(interval=3, timeUnit=\"hour\", startTime=int(time.time())))\n        else:\n            schedule_params = asdict(ScheduleParams(interval=1, timeUnit=\"day\", startTime=int(time.time() + 60*60*24*365)))\n\n        flow_data = Flow(\n            name = entity_name,\n            flow_spec = {\n                \"id\": self.DLZ_FLOW_SEPC_ID,\n                \"version\": \"1.0\"\n            },\n            source_connection_id = source_connection_id,\n            target_connection_id = target_connection_id,\n            schedule_params = schedule_params,\n            transformations = []\n        )\n        flow_obj = asdict(flow_data)\n        flow_res = self.flow_conn.createFlow(\n            obj = flow_obj,\n            flow_spec_id = self.DLZ_FLOW_SEPC_ID\n        )\n        try:\n            dataflow_id = flow_res[\"id\"]\n            if self.loggingEnabled:\n                self.logger.info(\"dataflow \" + dataflow_id + \" has been created\")\n            return dataflow_id\n        except KeyError:\n            raise RuntimeError(f\"Error when creating data flow: {flow_res}\")\n\n    def createFlowRun(self, dataflow_id: str, dataset_id: str, on_schedule: bool, initial_delay: int = 300):\n        \"\"\"\n        Create a data flow run\n        Arguments:\n          dataflow_id : REQUIRED : The flow that needs to be triggered a flow run\n          dataset_id : REQUIRED : The dataset that needs to be exported\n          on_schedule: REQUIRED: define whether you would like to have the export following a fixed schedule or not\n        \"\"\"\n        if not on_schedule:\n            #set up initial delay due to hollow refresh time interval\n            if self.loggingEnabled:\n                self.logger.info(f\"Waiting for flow {dataflow_id} to be refreshed after {initial_delay} seconds\")\n            time.sleep(initial_delay)\n            if self.loggingEnabled:\n                self.logger.info(f\"Start create adhoc dataset export for flow {dataflow_id} with dataset {dataset_id }\")\n            res = self.retryOnNotReadyException(dataflow_id = dataflow_id, dataset_id= dataset_id)\n            flow_run_id = res[\"destinations\"][0][\"datasets\"][0][\"statusURL\"].rsplit('/', 1)[-1]\n            #check if flowRun has finished\n            finished = False\n            while not finished:\n                try:\n                    run = self.flow_conn.getRun(runId = flow_run_id)[\"items\"][0]\n                    run_id = run[\"id\"]\n                    run_started_at = run[\"metrics\"][\"durationSummary\"][\"startedAtUTC\"]\n                    run_ended_at = run[\"metrics\"][\"durationSummary\"][\"completedAtUTC\"]\n                    run_duration_secs = (run_ended_at - run_started_at) / 1000\n                    run_size_mb = run[\"metrics\"][\"sizeSummary\"][\"outputBytes\"] / 1024. / 1024.\n                    run_num_rows = run[\"metrics\"][\"recordSummary\"][\"outputRecordCount\"]\n                    run_num_files = run[\"metrics\"][\"fileSummary\"][\"outputFileCount\"]\n                    if self.loggingEnabled:\n                        self.logger.info(f\"Run ID {run_id} completed with: duration={run_duration_secs} secs; size={run_size_mb} MB; num_rows={run_num_rows}; num_files={run_num_files}\")\n                    finished = True\n                except Exception as e:\n                    if self.loggingEnabled:\n                        self.logger.warn(f\"No runs completed yet for flow {dataflow_id}\")\n                    time.sleep(30)\n            #push the startDate to a year from now\n            start_time = int(time.time() + 60*60*24*365)\n            op = [asdict(FlowOp(op=\"Replace\", path=\"/scheduleParams\", value={\"startTime\": start_time}))]\n            flow_res = self.flow_conn.getFlow(dataflow_id)\n            etag = flow_res[\"etag\"]\n            self.flow_conn.updateFlow(dataflow_id,etag,op)\n            #disable flow after the adhoc run is completed\n            self.flow_conn.postFlowAction(dataflow_id, \"disable\")\n\n    def checkIfRetry(self, res: dict):\n        \"\"\"\n        check whether retry is needed base on the error message\n        Arguments:\n        res : REQUIRED : response from adhoc dataset export\n        Returns:\n          if retry is needed or not(boolean)\n        \"\"\"\n        error = str(res)\n        if self.loggingEnabled:\n            self.logger.info(f\"Checking if retry is needed for adhoc dataset export response {res}\")\n        return error.find(\"Following order ID(s) are not ready for dataset export\") != -1\n\n\n    def retryOnNotReadyException(self, dataflow_id: str, dataset_id: str, wait_time: int = 60, max_attempts: int= 5):\n        \"\"\"\n        retry adhoc dataset export based on the error type\n        Arguments:\n              dataflow_id : REQUIRED : The flow that needs to be triggered a flow run\n              dataset_id : REQUIRED : The dataset that needs to be exported\n              wait_time: OPTIONAL: the wait time between each retry\n              max_attempts: OPTIONAL: the maximum retry attempts\n        \"\"\"\n        retryer = Retrying(retry = retry_if_result(self.checkIfRetry),wait= wait_fixed(wait_time), stop=stop_after_attempt(max_attempts))\n        return retryer(self.dis_conn.createAdHocDatasetExport, {dataflow_id: [dataset_id]})"]}
{"filename": "aepp/datasets.py", "chunked_list": ["#  Copyright 2023 Adobe. All rights reserved.\n#  This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License. You may obtain a copy\n#  of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software distributed under\n#  the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n#  OF ANY KIND, either express or implied. See the License for the specific language\n#  governing permissions and limitations under the License.\n", "#  governing permissions and limitations under the License.\n\nimport aepp\nfrom aepp import connector\nfrom copy import deepcopy\nimport logging\nfrom typing import Union\nfrom .configs import ConnectObject\n\n\nclass DataSets:\n    \"\"\"\n    Class that provides methods to manage labels of datasets.\n    A complete documentation ca be found here:\n    https://www.adobe.io/apis/experienceplatform/home/api-reference.html#!acpdr/swagger-specs/dataset-service.yaml\n    \"\"\"\n\n    ## logging capability\n    loggingEnabled = False\n    logger = None\n\n    REFERENCE_LABELS_CREATION = {\n        \"labels\": [[\"C1\", \"C2\"]],\n        \"optionalLabels\": [\n            {\n                \"option\": {\n                    \"id\": \"https://ns.adobe.com/{TENANT_ID}/schemas/{SCHEMA_ID}\",\n                    \"contentType\": \"application/vnd.adobe.xed-full+json;version=1\",\n                    \"schemaPath\": \"/properties/repositoryCreatedBy\",\n                },\n                \"labels\": [[\"S1\", \"S2\"]],\n            }\n        ],\n    }\n\n    def __init__(\n        self,\n        config: Union[dict,ConnectObject] = aepp.config.config_object,\n        header: dict = aepp.config.header,\n        loggingObject: dict = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Instantiate the DataSet class.\n        Arguments:\n            config : OPTIONAL : config object in the config module. (DO NOT MODIFY)\n            header : OPTIONAL : header object  in the config module. (DO NOT MODIFY)\n            loggingObject : OPTIONAL : logging object to log messages.\n        Additional kwargs will update the header.\n        \"\"\"\n        if loggingObject is not None and sorted(\n            [\"level\", \"stream\", \"format\", \"filename\", \"file\"]\n        ) == sorted(list(loggingObject.keys())):\n            self.loggingEnabled = True\n            self.logger = logging.getLogger(f\"{__name__}\")\n            self.logger.setLevel(loggingObject[\"level\"])\n            if type(loggingObject[\"format\"]) == str:\n                formatter = logging.Formatter(loggingObject[\"format\"])\n            elif type(loggingObject[\"format\"]) == logging.Formatter:\n                formatter = loggingObject[\"format\"]\n            if loggingObject[\"file\"]:\n                fileHandler = logging.FileHandler(loggingObject[\"filename\"])\n                fileHandler.setFormatter(formatter)\n                self.logger.addHandler(fileHandler)\n            if loggingObject[\"stream\"]:\n                streamHandler = logging.StreamHandler()\n                streamHandler.setFormatter(formatter)\n                self.logger.addHandler(streamHandler)\n        if type(config) == dict: ## Supporting either default setup or passing a ConnectObject\n            config = config\n        elif type(config) == ConnectObject:\n            header = config.getConfigHeader()\n            config = config.getConfigObject()\n        self.connector = connector.AdobeRequest(\n            config=config,\n            header=header,\n            loggingEnabled=self.loggingEnabled,\n            logger=self.logger,\n        )\n        self.header = self.connector.header\n        self.header.update(**kwargs)\n        if kwargs.get('sandbox',None) is not None: ## supporting sandbox setup on class instanciation\n            self.sandbox = kwargs.get('sandbox')\n            self.connector.config[\"sandbox\"] = kwargs.get('sandbox')\n            self.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n            self.connector.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n        else:\n            self.sandbox = self.connector.config[\"sandbox\"]\n        self.endpoint = (\n            aepp.config.endpoints[\"global\"] + aepp.config.endpoints[\"dataset\"]\n        )\n\n    def getLabelSchemaTests(self, dataSetId: str = None) -> dict:\n        \"\"\"\n        Return the labels assigned to a dataSet\n        Argument:\n            dataSetId : REQUIRED : the dataSet ID to retrieve the labels\n        \"\"\"\n        if dataSetId is None:\n            raise ValueError(\"Require a dataSet ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getLabels\")\n        path = f\"/datasets/{dataSetId}/labels\"\n        res = self.connector.getData(self.endpoint + path)\n        return res\n\n    def headLabels(self, dataSetId: str = None) -> dict:\n        \"\"\"\n        Return the head assigned to a dataSet\n        Argument:\n            dataSetId : REQUIRED : the dataSet ID to retrieve the head data\n        \"\"\"\n        if dataSetId is None:\n            raise ValueError(\"Require a dataSet ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting headLabels\")\n        path = f\"/datasets/{dataSetId}/labels\"\n        res = self.connector.headData(self.endpoint + path)\n        return res\n\n    def deleteLabels(self, dataSetId: str = None, ifMatch: str = None) -> dict:\n        \"\"\"\n        Delete the labels of a dataset.\n        Arguments:\n            dataSetId : REQUIRED : The dataset ID to delete the labels for.\n            ifMatch : REQUIRED : the value is from the header etag of the headLabels. (use the headLabels method)\n        \"\"\"\n        if dataSetId is None:\n            raise ValueError(\"Require a dataSet ID\")\n        if ifMatch is None:\n            raise ValueError(\"Require the ifMatch parameter\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteLabels\")\n        path = f\"/datasets/{dataSetId}/labels\"\n        privateHeader = deepcopy(self.header)\n        privateHeader[\"If-Match\"] = ifMatch\n        res = self.connector.deleteData(self.endpoint + path, headers=privateHeader)\n        return res\n\n    def createLabels(self, dataSetId: str = None, data: dict = None) -> dict:\n        \"\"\"\n        Assign labels to a dataset.\n        Arguments:\n            dataSetId : REQUIRED : The dataset ID to delete the labels for.\n            data : REQUIRED : Dictionary setting the labels to be added.\n                more info https://www.adobe.io/apis/experienceplatform/home/api-reference.html#/Datasets/postDatasetLabels\n        \"\"\"\n        if dataSetId is None:\n            raise ValueError(\"Require a dataSet ID\")\n        if data is None or type(data) != dict:\n            raise ValueError(\"Require a dictionary to pass labels\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createLabels\")\n        path = f\"/datasets/{dataSetId}/labels\"\n        res = self.connector.postData(self.endpoint + path, data=data)\n        return res\n\n    def updateLabels(\n        self, dataSetId: str = None, data: dict = None, ifMatch: str = None\n    ) -> dict:\n        \"\"\"\n        Update the labels (PUT method)\n            dataSetId : REQUIRED : The dataset ID to delete the labels for.\n            data : REQUIRED : Dictionary setting the labels to be added.\n                more info https://www.adobe.io/apis/experienceplatform/home/api-reference.html#/Datasets/postDatasetLabels\n            ifMatch : REQUIRED : the value is from the header etag of the headLabels.(use the headLabels method)\n        \"\"\"\n        if dataSetId is None:\n            raise ValueError(\"Require a dataSet ID\")\n        if data is None or type(data) != dict:\n            raise ValueError(\"Require a dictionary to pass labels\")\n        if ifMatch is None:\n            raise ValueError(\"Require the ifMatch parameter\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting updateLabels\")\n        path = f\"/datasets/{dataSetId}/labels\"\n        privateHeader = deepcopy(self.header)\n        privateHeader[\"If-Match\"] = ifMatch\n        res = self.connector.putData(\n            self.endpoint + path, data=data, headers=privateHeader\n        )\n        return res", "\n\nclass DataSets:\n    \"\"\"\n    Class that provides methods to manage labels of datasets.\n    A complete documentation ca be found here:\n    https://www.adobe.io/apis/experienceplatform/home/api-reference.html#!acpdr/swagger-specs/dataset-service.yaml\n    \"\"\"\n\n    ## logging capability\n    loggingEnabled = False\n    logger = None\n\n    REFERENCE_LABELS_CREATION = {\n        \"labels\": [[\"C1\", \"C2\"]],\n        \"optionalLabels\": [\n            {\n                \"option\": {\n                    \"id\": \"https://ns.adobe.com/{TENANT_ID}/schemas/{SCHEMA_ID}\",\n                    \"contentType\": \"application/vnd.adobe.xed-full+json;version=1\",\n                    \"schemaPath\": \"/properties/repositoryCreatedBy\",\n                },\n                \"labels\": [[\"S1\", \"S2\"]],\n            }\n        ],\n    }\n\n    def __init__(\n        self,\n        config: Union[dict,ConnectObject] = aepp.config.config_object,\n        header: dict = aepp.config.header,\n        loggingObject: dict = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Instantiate the DataSet class.\n        Arguments:\n            config : OPTIONAL : config object in the config module. (DO NOT MODIFY)\n            header : OPTIONAL : header object  in the config module. (DO NOT MODIFY)\n            loggingObject : OPTIONAL : logging object to log messages.\n        Additional kwargs will update the header.\n        \"\"\"\n        if loggingObject is not None and sorted(\n            [\"level\", \"stream\", \"format\", \"filename\", \"file\"]\n        ) == sorted(list(loggingObject.keys())):\n            self.loggingEnabled = True\n            self.logger = logging.getLogger(f\"{__name__}\")\n            self.logger.setLevel(loggingObject[\"level\"])\n            if type(loggingObject[\"format\"]) == str:\n                formatter = logging.Formatter(loggingObject[\"format\"])\n            elif type(loggingObject[\"format\"]) == logging.Formatter:\n                formatter = loggingObject[\"format\"]\n            if loggingObject[\"file\"]:\n                fileHandler = logging.FileHandler(loggingObject[\"filename\"])\n                fileHandler.setFormatter(formatter)\n                self.logger.addHandler(fileHandler)\n            if loggingObject[\"stream\"]:\n                streamHandler = logging.StreamHandler()\n                streamHandler.setFormatter(formatter)\n                self.logger.addHandler(streamHandler)\n        if type(config) == dict: ## Supporting either default setup or passing a ConnectObject\n            config = config\n        elif type(config) == ConnectObject:\n            header = config.getConfigHeader()\n            config = config.getConfigObject()\n        self.connector = connector.AdobeRequest(\n            config=config,\n            header=header,\n            loggingEnabled=self.loggingEnabled,\n            logger=self.logger,\n        )\n        self.header = self.connector.header\n        self.header.update(**kwargs)\n        if kwargs.get('sandbox',None) is not None: ## supporting sandbox setup on class instanciation\n            self.sandbox = kwargs.get('sandbox')\n            self.connector.config[\"sandbox\"] = kwargs.get('sandbox')\n            self.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n            self.connector.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n        else:\n            self.sandbox = self.connector.config[\"sandbox\"]\n        self.endpoint = (\n            aepp.config.endpoints[\"global\"] + aepp.config.endpoints[\"dataset\"]\n        )\n\n    def getLabelSchemaTests(self, dataSetId: str = None) -> dict:\n        \"\"\"\n        Return the labels assigned to a dataSet\n        Argument:\n            dataSetId : REQUIRED : the dataSet ID to retrieve the labels\n        \"\"\"\n        if dataSetId is None:\n            raise ValueError(\"Require a dataSet ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getLabels\")\n        path = f\"/datasets/{dataSetId}/labels\"\n        res = self.connector.getData(self.endpoint + path)\n        return res\n\n    def headLabels(self, dataSetId: str = None) -> dict:\n        \"\"\"\n        Return the head assigned to a dataSet\n        Argument:\n            dataSetId : REQUIRED : the dataSet ID to retrieve the head data\n        \"\"\"\n        if dataSetId is None:\n            raise ValueError(\"Require a dataSet ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting headLabels\")\n        path = f\"/datasets/{dataSetId}/labels\"\n        res = self.connector.headData(self.endpoint + path)\n        return res\n\n    def deleteLabels(self, dataSetId: str = None, ifMatch: str = None) -> dict:\n        \"\"\"\n        Delete the labels of a dataset.\n        Arguments:\n            dataSetId : REQUIRED : The dataset ID to delete the labels for.\n            ifMatch : REQUIRED : the value is from the header etag of the headLabels. (use the headLabels method)\n        \"\"\"\n        if dataSetId is None:\n            raise ValueError(\"Require a dataSet ID\")\n        if ifMatch is None:\n            raise ValueError(\"Require the ifMatch parameter\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteLabels\")\n        path = f\"/datasets/{dataSetId}/labels\"\n        privateHeader = deepcopy(self.header)\n        privateHeader[\"If-Match\"] = ifMatch\n        res = self.connector.deleteData(self.endpoint + path, headers=privateHeader)\n        return res\n\n    def createLabels(self, dataSetId: str = None, data: dict = None) -> dict:\n        \"\"\"\n        Assign labels to a dataset.\n        Arguments:\n            dataSetId : REQUIRED : The dataset ID to delete the labels for.\n            data : REQUIRED : Dictionary setting the labels to be added.\n                more info https://www.adobe.io/apis/experienceplatform/home/api-reference.html#/Datasets/postDatasetLabels\n        \"\"\"\n        if dataSetId is None:\n            raise ValueError(\"Require a dataSet ID\")\n        if data is None or type(data) != dict:\n            raise ValueError(\"Require a dictionary to pass labels\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createLabels\")\n        path = f\"/datasets/{dataSetId}/labels\"\n        res = self.connector.postData(self.endpoint + path, data=data)\n        return res\n\n    def updateLabels(\n        self, dataSetId: str = None, data: dict = None, ifMatch: str = None\n    ) -> dict:\n        \"\"\"\n        Update the labels (PUT method)\n            dataSetId : REQUIRED : The dataset ID to delete the labels for.\n            data : REQUIRED : Dictionary setting the labels to be added.\n                more info https://www.adobe.io/apis/experienceplatform/home/api-reference.html#/Datasets/postDatasetLabels\n            ifMatch : REQUIRED : the value is from the header etag of the headLabels.(use the headLabels method)\n        \"\"\"\n        if dataSetId is None:\n            raise ValueError(\"Require a dataSet ID\")\n        if data is None or type(data) != dict:\n            raise ValueError(\"Require a dictionary to pass labels\")\n        if ifMatch is None:\n            raise ValueError(\"Require the ifMatch parameter\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting updateLabels\")\n        path = f\"/datasets/{dataSetId}/labels\"\n        privateHeader = deepcopy(self.header)\n        privateHeader[\"If-Match\"] = ifMatch\n        res = self.connector.putData(\n            self.endpoint + path, data=data, headers=privateHeader\n        )\n        return res", ""]}
{"filename": "aepp/observability.py", "chunked_list": ["#  Copyright 2023 Adobe. All rights reserved.\n#  This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License. You may obtain a copy\n#  of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software distributed under\n#  the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n#  OF ANY KIND, either express or implied. See the License for the specific language\n#  governing permissions and limitations under the License.\n", "#  governing permissions and limitations under the License.\n\nimport aepp\nfrom aepp import connector\nimport pandas as pd\nimport logging\nfrom typing import Union\nfrom .configs import ConnectObject\n\nclass Observability:\n    \"\"\"\n    A class that presents the different methods available on the Observability API from AEP.\n    A complete documentation of the methods can be found here:\n    https://www.adobe.io/apis/experienceplatform/home/api-reference.html#!acpdr/swagger-specs/observability-insights.yaml\n    \"\"\"\n\n    ## logging capability\n    loggingEnabled = False\n    logger = None\n\n    def __init__(\n        self,\n        config: Union[dict,ConnectObject] = aepp.config.config_object,\n        header: dict = aepp.config.header,\n        loggingObject: dict = None,\n        **kwargs,\n    ) -> None:\n        \"\"\"\n        Instanciate the observability API methods class.\n        Arguments:\n            loggingObject : OPTIONAL : logging object to log messages.\n            config : OPTIONAL : config object in the config module. (DO NOT MODIFY)\n            header : OPTIONAL : header object  in the config module. (DO NOT MODIFY)\n        \"\"\"\n        if loggingObject is not None and sorted(\n            [\"level\", \"stream\", \"format\", \"filename\", \"file\"]\n        ) == sorted(list(loggingObject.keys())):\n            self.loggingEnabled = True\n            self.logger = logging.getLogger(f\"{__name__}\")\n            self.logger.setLevel(loggingObject[\"level\"])\n            if type(loggingObject[\"format\"]) == str:\n                formatter = logging.Formatter(loggingObject[\"format\"])\n            elif type(loggingObject[\"format\"]) == logging.Formatter:\n                formatter = loggingObject[\"format\"]\n            if loggingObject[\"file\"]:\n                fileHandler = logging.FileHandler(loggingObject[\"filename\"])\n                fileHandler.setFormatter(formatter)\n                self.logger.addHandler(fileHandler)\n            if loggingObject[\"stream\"]:\n                streamHandler = logging.StreamHandler()\n                streamHandler.setFormatter(formatter)\n                self.logger.addHandler(streamHandler)\n        if type(config) == dict: ## Supporting either default setup or passing a ConnectObject\n            config = config\n        elif type(config) == ConnectObject:\n            header = config.getConfigHeader()\n            config = config.getConfigObject()\n        self.connector = connector.AdobeRequest(\n            config=config,\n            header=header,\n            loggingEnabled=self.loggingEnabled,\n            logger=self.logger,\n        )\n        self.header = self.connector.header\n        self.header.update(**kwargs)\n        if kwargs.get('sandbox',None) is not None: ## supporting sandbox setup on class instanciation\n            self.sandbox = kwargs.get('sandbox')\n            self.connector.config[\"sandbox\"] = kwargs.get('sandbox')\n            self.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n            self.connector.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n        else:\n            self.sandbox = self.connector.config[\"sandbox\"]\n        self.endpoint = (\n            aepp.config.endpoints[\"global\"] + aepp.config.endpoints[\"observability\"]\n        )\n        self.POST_METRICS = {\n            \"start\": \"2020-07-14T00:00:00.000Z\",\n            \"end\": \"2020-07-22T00:00:00.000Z\",\n            \"granularity\": \"day\",\n            \"metrics\": [\n                {\n                    \"name\": \"timeseries.ingestion.dataset.recordsuccess.count\",\n                    \"filters\": [\n                        {\n                            \"name\": \"dataSetId\",\n                            \"value\": \"5edcfb2fbb642119194c7d94|5eddb21420f516191b7a8dad\",\n                            \"groupBy\": True,\n                        }\n                    ],\n                    \"aggregator\": \"sum\",\n                    \"downsample\": \"sum\",\n                },\n                {\n                    \"name\": \"timeseries.ingestion.dataset.dailysize\",\n                    \"filters\": [\n                        {\n                            \"name\": \"dataSetId\",\n                            \"value\": \"5eddb21420f516191b7a8dad\",\n                            \"groupBy\": False,\n                        }\n                    ],\n                    \"aggregator\": \"sum\",\n                    \"downsample\": \"sum\",\n                },\n            ],\n        }\n        self._loadREFERENCES()\n\n    def _loadREFERENCES(self):\n        \"\"\"\n        Load document as attributes if possible\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Loading references\")\n        try:\n            import importlib.resources as pkg_resources\n\n            pathIdentity = pkg_resources.path(\"aepp\", \"observability_identity.pickle\")\n            pathIngestion = pkg_resources.path(\"aepp\", \"observability_ingestion.pickle\")\n            pathGDPR = pkg_resources.path(\"aepp\", \"observability_gdpr.pickle\")\n            pathQS = pkg_resources.path(\"aepp\", \"observability_queryService.pickle\")\n            pathRLTime = pkg_resources.path(\"aepp\", \"observability_realTime.pickle\")\n        except ImportError:\n            # Try backported to PY<37 with pkg_resources.\n            if self.loggingEnabled:\n                self.logger.debug(f\"Loading references - ImportError - 2nd try\")\n            try:\n                import pkg_resources\n\n                pathIdentity = pkg_resources.resource_filename(\n                    \"aepp\", \"observability_identity.pickle\"\n                )\n                pathIngestion = pkg_resources.resource_filename(\n                    \"aepp\", \"observability_ingestion.pickle\"\n                )\n                pathGDPR = pkg_resources.resource_filename(\n                    \"aepp\", \"observability_gdpr.pickle\"\n                )\n                pathQS = pkg_resources.resource_filename(\n                    \"aepp\", \"observability_queryService.pickle\"\n                )\n                pathRLTime = pkg_resources.resource_filename(\n                    \"aepp\", \"observability_realTime.pickle\"\n                )\n            except:\n                print(\"no supported files\")\n                if self.loggingEnabled:\n                    self.logger.debug(f\"Failed loading references\")\n        try:\n            with pathIdentity as f:\n                self.REFERENCE_IDENTITY = pd.read_pickle(f)\n                self.REFERENCE_IDENTITY = self.REFERENCE_IDENTITY.style.set_properties(\n                    subset=[\"Insights metric\"], **{\"width\": \"100px\"}\n                )\n            with pathIngestion as f:\n                self.REFERENCE_INGESTION = pd.read_pickle(f)\n                self.REFERENCE_INGESTION = (\n                    self.REFERENCE_INGESTION.style.set_properties(\n                        subset=[\"Insights metric\"], **{\"width\": \"100px\"}\n                    )\n                )\n            with pathGDPR as f:\n                self.REFERENCE_GDPR = pd.read_pickle(f)\n                self.REFERENCE_GDPR = self.REFERENCE_GDPR.style.set_properties(\n                    subset=[\"Insights metric\"], **{\"width\": \"100px\"}\n                )\n            with pathRLTime as f:\n                self.REFERENCE_REALTIME = pd.read_pickle(f)\n                self.REFERENCE_REALTIME = self.REFERENCE_REALTIME.style.set_properties(\n                    subset=[\"Insights metric\"], **{\"width\": \"100px\"}\n                )\n            with pathQS as f:\n                self.REFERENCE_QUERYSERVICE = pd.read_pickle(f)\n                self.REFERENCE_QUERYSERVICE = (\n                    self.REFERENCE_QUERYSERVICE.style.set_properties(\n                        subset=[\"Insights metric\"], **{\"width\": \"100px\"}\n                    )\n                )\n        except:\n            if self.loggingEnabled:\n                self.logger.debug(f\"Failed loading references - backup to None\")\n            self.REFERENCE_IDENTITY = None\n            self.REFERENCE_INGESTION = None\n            self.REFERENCE_QUERYSERVICE = None\n            self.REFERENCE_GDPR = None\n            self.REFERENCE_REALTIME = None\n\n    def createMetricsReport(self, data: dict = None) -> dict:\n        \"\"\"\n        Using the POST method to retrieve metrics specified in the data dictionary.\n        Please use the different REFERENCES attributes to know which metrics are supported.\n        You have a template for the data dictionary on the POST_METRICS attribute.\n        Arguments:\n            data : REQUIRED : The metrics requested in the report creation.\n                You can use the POST_METRICS attribute to see a template.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createMetricsReport\")\n        path = \"/metrics\"\n        res = self.connector.postData(self.endpoint + path, data=data)\n        return res", "\nclass Observability:\n    \"\"\"\n    A class that presents the different methods available on the Observability API from AEP.\n    A complete documentation of the methods can be found here:\n    https://www.adobe.io/apis/experienceplatform/home/api-reference.html#!acpdr/swagger-specs/observability-insights.yaml\n    \"\"\"\n\n    ## logging capability\n    loggingEnabled = False\n    logger = None\n\n    def __init__(\n        self,\n        config: Union[dict,ConnectObject] = aepp.config.config_object,\n        header: dict = aepp.config.header,\n        loggingObject: dict = None,\n        **kwargs,\n    ) -> None:\n        \"\"\"\n        Instanciate the observability API methods class.\n        Arguments:\n            loggingObject : OPTIONAL : logging object to log messages.\n            config : OPTIONAL : config object in the config module. (DO NOT MODIFY)\n            header : OPTIONAL : header object  in the config module. (DO NOT MODIFY)\n        \"\"\"\n        if loggingObject is not None and sorted(\n            [\"level\", \"stream\", \"format\", \"filename\", \"file\"]\n        ) == sorted(list(loggingObject.keys())):\n            self.loggingEnabled = True\n            self.logger = logging.getLogger(f\"{__name__}\")\n            self.logger.setLevel(loggingObject[\"level\"])\n            if type(loggingObject[\"format\"]) == str:\n                formatter = logging.Formatter(loggingObject[\"format\"])\n            elif type(loggingObject[\"format\"]) == logging.Formatter:\n                formatter = loggingObject[\"format\"]\n            if loggingObject[\"file\"]:\n                fileHandler = logging.FileHandler(loggingObject[\"filename\"])\n                fileHandler.setFormatter(formatter)\n                self.logger.addHandler(fileHandler)\n            if loggingObject[\"stream\"]:\n                streamHandler = logging.StreamHandler()\n                streamHandler.setFormatter(formatter)\n                self.logger.addHandler(streamHandler)\n        if type(config) == dict: ## Supporting either default setup or passing a ConnectObject\n            config = config\n        elif type(config) == ConnectObject:\n            header = config.getConfigHeader()\n            config = config.getConfigObject()\n        self.connector = connector.AdobeRequest(\n            config=config,\n            header=header,\n            loggingEnabled=self.loggingEnabled,\n            logger=self.logger,\n        )\n        self.header = self.connector.header\n        self.header.update(**kwargs)\n        if kwargs.get('sandbox',None) is not None: ## supporting sandbox setup on class instanciation\n            self.sandbox = kwargs.get('sandbox')\n            self.connector.config[\"sandbox\"] = kwargs.get('sandbox')\n            self.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n            self.connector.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n        else:\n            self.sandbox = self.connector.config[\"sandbox\"]\n        self.endpoint = (\n            aepp.config.endpoints[\"global\"] + aepp.config.endpoints[\"observability\"]\n        )\n        self.POST_METRICS = {\n            \"start\": \"2020-07-14T00:00:00.000Z\",\n            \"end\": \"2020-07-22T00:00:00.000Z\",\n            \"granularity\": \"day\",\n            \"metrics\": [\n                {\n                    \"name\": \"timeseries.ingestion.dataset.recordsuccess.count\",\n                    \"filters\": [\n                        {\n                            \"name\": \"dataSetId\",\n                            \"value\": \"5edcfb2fbb642119194c7d94|5eddb21420f516191b7a8dad\",\n                            \"groupBy\": True,\n                        }\n                    ],\n                    \"aggregator\": \"sum\",\n                    \"downsample\": \"sum\",\n                },\n                {\n                    \"name\": \"timeseries.ingestion.dataset.dailysize\",\n                    \"filters\": [\n                        {\n                            \"name\": \"dataSetId\",\n                            \"value\": \"5eddb21420f516191b7a8dad\",\n                            \"groupBy\": False,\n                        }\n                    ],\n                    \"aggregator\": \"sum\",\n                    \"downsample\": \"sum\",\n                },\n            ],\n        }\n        self._loadREFERENCES()\n\n    def _loadREFERENCES(self):\n        \"\"\"\n        Load document as attributes if possible\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Loading references\")\n        try:\n            import importlib.resources as pkg_resources\n\n            pathIdentity = pkg_resources.path(\"aepp\", \"observability_identity.pickle\")\n            pathIngestion = pkg_resources.path(\"aepp\", \"observability_ingestion.pickle\")\n            pathGDPR = pkg_resources.path(\"aepp\", \"observability_gdpr.pickle\")\n            pathQS = pkg_resources.path(\"aepp\", \"observability_queryService.pickle\")\n            pathRLTime = pkg_resources.path(\"aepp\", \"observability_realTime.pickle\")\n        except ImportError:\n            # Try backported to PY<37 with pkg_resources.\n            if self.loggingEnabled:\n                self.logger.debug(f\"Loading references - ImportError - 2nd try\")\n            try:\n                import pkg_resources\n\n                pathIdentity = pkg_resources.resource_filename(\n                    \"aepp\", \"observability_identity.pickle\"\n                )\n                pathIngestion = pkg_resources.resource_filename(\n                    \"aepp\", \"observability_ingestion.pickle\"\n                )\n                pathGDPR = pkg_resources.resource_filename(\n                    \"aepp\", \"observability_gdpr.pickle\"\n                )\n                pathQS = pkg_resources.resource_filename(\n                    \"aepp\", \"observability_queryService.pickle\"\n                )\n                pathRLTime = pkg_resources.resource_filename(\n                    \"aepp\", \"observability_realTime.pickle\"\n                )\n            except:\n                print(\"no supported files\")\n                if self.loggingEnabled:\n                    self.logger.debug(f\"Failed loading references\")\n        try:\n            with pathIdentity as f:\n                self.REFERENCE_IDENTITY = pd.read_pickle(f)\n                self.REFERENCE_IDENTITY = self.REFERENCE_IDENTITY.style.set_properties(\n                    subset=[\"Insights metric\"], **{\"width\": \"100px\"}\n                )\n            with pathIngestion as f:\n                self.REFERENCE_INGESTION = pd.read_pickle(f)\n                self.REFERENCE_INGESTION = (\n                    self.REFERENCE_INGESTION.style.set_properties(\n                        subset=[\"Insights metric\"], **{\"width\": \"100px\"}\n                    )\n                )\n            with pathGDPR as f:\n                self.REFERENCE_GDPR = pd.read_pickle(f)\n                self.REFERENCE_GDPR = self.REFERENCE_GDPR.style.set_properties(\n                    subset=[\"Insights metric\"], **{\"width\": \"100px\"}\n                )\n            with pathRLTime as f:\n                self.REFERENCE_REALTIME = pd.read_pickle(f)\n                self.REFERENCE_REALTIME = self.REFERENCE_REALTIME.style.set_properties(\n                    subset=[\"Insights metric\"], **{\"width\": \"100px\"}\n                )\n            with pathQS as f:\n                self.REFERENCE_QUERYSERVICE = pd.read_pickle(f)\n                self.REFERENCE_QUERYSERVICE = (\n                    self.REFERENCE_QUERYSERVICE.style.set_properties(\n                        subset=[\"Insights metric\"], **{\"width\": \"100px\"}\n                    )\n                )\n        except:\n            if self.loggingEnabled:\n                self.logger.debug(f\"Failed loading references - backup to None\")\n            self.REFERENCE_IDENTITY = None\n            self.REFERENCE_INGESTION = None\n            self.REFERENCE_QUERYSERVICE = None\n            self.REFERENCE_GDPR = None\n            self.REFERENCE_REALTIME = None\n\n    def createMetricsReport(self, data: dict = None) -> dict:\n        \"\"\"\n        Using the POST method to retrieve metrics specified in the data dictionary.\n        Please use the different REFERENCES attributes to know which metrics are supported.\n        You have a template for the data dictionary on the POST_METRICS attribute.\n        Arguments:\n            data : REQUIRED : The metrics requested in the report creation.\n                You can use the POST_METRICS attribute to see a template.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createMetricsReport\")\n        path = \"/metrics\"\n        res = self.connector.postData(self.endpoint + path, data=data)\n        return res", ""]}
{"filename": "aepp/privacyservice.py", "chunked_list": ["#  Copyright 2023 Adobe. All rights reserved.\n#  This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License. You may obtain a copy\n#  of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software distributed under\n#  the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n#  OF ANY KIND, either express or implied. See the License for the specific language\n#  governing permissions and limitations under the License.\n", "#  governing permissions and limitations under the License.\n\nimport aepp\nfrom aepp import connector\nimport logging\nfrom typing import Union\nfrom .configs import ConnectObject\n\nclass Privacy:\n    \"\"\"\n    Class to instanciate a Privacy API connection. Ensure you have the correct access within you Adobe IO connection.\n    Information about that class can be found here : https://docs.adobe.com/content/help/en/experience-platform/privacy/api/privacy-jobs.html\n    \"\"\"\n\n    SAMPLE_PAYLOAD = {\n        \"companyContexts\": [{\"namespace\": \"imsOrgID\", \"value\": \"{IMS_ORG}\"}],\n        \"users\": [\n            {\n                \"key\": \"DavidSmith\",\n                \"action\": [\"access\"],\n                \"userIDs\": [\n                    {\n                        \"namespace\": \"email\",\n                        \"value\": \"dsmith@acme.com\",\n                        \"type\": \"standard\",\n                    },\n                    {\n                        \"namespace\": \"ECID\",\n                        \"type\": \"standard\",\n                        \"value\": \"443636576799758681021090721276\",\n                        \"isDeletedClientSide\": False,\n                    },\n                ],\n            },\n            {\n                \"key\": \"user12345\",\n                \"action\": [\"access\", \"delete\"],\n                \"userIDs\": [\n                    {\n                        \"namespace\": \"email\",\n                        \"value\": \"ajones@acme.com\",\n                        \"type\": \"standard\",\n                    },\n                    {\n                        \"namespace\": \"loyaltyAccount\",\n                        \"value\": \"12AD45FE30R29\",\n                        \"type\": \"integrationCode\",\n                    },\n                ],\n            },\n        ],\n        \"include\": [\"Analytics\", \"AudienceManager\"],\n        \"expandIds\": False,\n        \"priority\": \"normal\",\n        \"analyticsDeleteMethod\": \"anonymize\",\n        \"regulation\": \"ccpa\",\n    }\n    ## logging capability\n    loggingEnabled = False\n    logger = None\n\n    def __init__(\n        self,\n        privacyScope: bool = True,\n        aepScope: bool = False,\n        config: Union[dict,ConnectObject] = aepp.config.config_object,\n        header: dict = aepp.config.header,\n        loggingObject: dict = None,\n        **kwargs,\n    ) -> None:\n        \"\"\"\n        Instanciate the class for Privacy Service call.\n        Arguments:\n            privacyScope : REQUIRED : set the connection retrieved process with the Privacy JWT scope (default True).\n            aepScope : OPTIONAL : set the connection retrieved process with the AEP JWT scope if set to True (default False).\n            config : OPTIONAL : config object in the config module.\n            header : OPTIONAL : header object  in the config module.\n        kwargs:\n            kwargs will update the header\n        \"\"\"\n        if loggingObject is not None and sorted(\n            [\"level\", \"stream\", \"format\", \"filename\", \"file\"]\n        ) == sorted(list(loggingObject.keys())):\n            self.loggingEnabled = True\n            self.logger = logging.getLogger(f\"{__name__}\")\n            self.logger.setLevel(loggingObject[\"level\"])\n            if type(loggingObject[\"format\"]) == str:\n                formatter = logging.Formatter(loggingObject[\"format\"])\n            elif type(loggingObject[\"format\"]) == logging.Formatter:\n                formatter = loggingObject[\"format\"]\n            if loggingObject[\"file\"]:\n                fileHandler = logging.FileHandler(loggingObject[\"filename\"])\n                fileHandler.setFormatter(formatter)\n                self.logger.addHandler(fileHandler)\n            if loggingObject[\"stream\"]:\n                streamHandler = logging.StreamHandler()\n                streamHandler.setFormatter(formatter)\n                self.logger.addHandler(streamHandler)\n        if type(config) == dict: ## Supporting either default setup or passing a ConnectObject\n            config = config\n        elif type(config) == ConnectObject:\n            header = config.getConfigHeader()\n            config = config.getConfigObject()\n        self.connector = connector.AdobeRequest(\n            config=config,\n            header=header,\n            aepScope=aepScope,\n            privacyScope=privacyScope,\n            loggingEnabled=self.loggingEnabled,\n            logger=self.logger,\n        )\n        self.header = self.connector.header\n        self.header.update(**kwargs)\n        self.endpoint = (\n            aepp.config.endpoints[\"global\"] + aepp.config.endpoints[\"privacy\"]\n        )\n\n    def getJobs(\n        self, regulation: str = None, limit: int = 50, status: str = None, **kwargs\n    ) -> dict:\n        \"\"\"\n        Returns the job that are being processed on Adobe.\n        Arguments:\n            regulation : REQUIRED : The privacy regulation to return jobs from. (gdpr, ccpa, pdpa_tha)\n            limit : OPTIONAL : The number of jobs to return in the response body.(default 50)\n            status : OPTIONAL : Filters jobs by processing status. (complete, processing, submitted, error)\n        Possible kwargs: see documentation : https://www.adobe.io/apis/experienceplatform/home/api-reference.html#/Privacy_Jobs/fetchAllJobs\n        \"\"\"\n        if regulation is None:\n            raise Exception(\"Required regulation parameter\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getJobs\")\n        path = \"/jobs\"\n        params = {\"size\": limit, \"regulation\": regulation}\n        if status is not None:\n            params[\"status\"] = status\n        if len(kwargs) > 0:\n            for key in kwargs:\n                params[key] = str(kwargs[key])\n        res = self.connector.getData(\n            self.endpoint + path, params=params, headers=self.header\n        )\n        return res\n\n    def getJob(self, jobId: str = None) -> dict:\n        \"\"\"\n        Return a specific job by its job ID.\n        Arguments:\n            jobId : REQUIRED : the Job ID to fetch\n        \"\"\"\n        if jobId is None:\n            raise Exception(\"Require a job ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getJob\")\n        path = f\"/jobs/{jobId}\"\n        res = self.connector.getData(self.endpoint + path, headers=self.header)\n        return res\n\n    def postJob(self, data: dict = None) -> dict:\n        \"\"\"\n        Return a specific job by its job ID.\n        Arguments:\n            data : REQUIRED : data to be send in order to start a job.\n            You can use the SAMPLE_PAYLOAD to help you create the data.\n        \"\"\"\n        if data is None or type(data) != dict:\n            raise Exception(\"Require a dictionary to be passed\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting postJob\")\n        path = \"/jobs/\"\n        res = self.connector.postData(\n            self.endpoint + path, data=data, headers=self.header\n        )\n        return res\n\n    def postChildJob(self, jobId: str = None, data: dict = None) -> dict:\n        \"\"\"\n        This is to add a job on a parent Job.\n        Argument:\n            jobId : REQUIRED : the Job ID to append the job to\n            data : REQUIRED : dictionary of data to be added.\n        \"\"\"\n        if jobId is None:\n            raise Exception(\"Require a job ID\")\n        if data is None or type(data) != dict:\n            raise Exception(\"Require a dictionary to be passed\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting gpostChildJob\")\n        path = f\"/jobs/{jobId}/child-job\"\n        res = self.connector.postData(\n            self.endpoint + path, data=data, headers=self.header\n        )\n        return res", "class Privacy:\n    \"\"\"\n    Class to instanciate a Privacy API connection. Ensure you have the correct access within you Adobe IO connection.\n    Information about that class can be found here : https://docs.adobe.com/content/help/en/experience-platform/privacy/api/privacy-jobs.html\n    \"\"\"\n\n    SAMPLE_PAYLOAD = {\n        \"companyContexts\": [{\"namespace\": \"imsOrgID\", \"value\": \"{IMS_ORG}\"}],\n        \"users\": [\n            {\n                \"key\": \"DavidSmith\",\n                \"action\": [\"access\"],\n                \"userIDs\": [\n                    {\n                        \"namespace\": \"email\",\n                        \"value\": \"dsmith@acme.com\",\n                        \"type\": \"standard\",\n                    },\n                    {\n                        \"namespace\": \"ECID\",\n                        \"type\": \"standard\",\n                        \"value\": \"443636576799758681021090721276\",\n                        \"isDeletedClientSide\": False,\n                    },\n                ],\n            },\n            {\n                \"key\": \"user12345\",\n                \"action\": [\"access\", \"delete\"],\n                \"userIDs\": [\n                    {\n                        \"namespace\": \"email\",\n                        \"value\": \"ajones@acme.com\",\n                        \"type\": \"standard\",\n                    },\n                    {\n                        \"namespace\": \"loyaltyAccount\",\n                        \"value\": \"12AD45FE30R29\",\n                        \"type\": \"integrationCode\",\n                    },\n                ],\n            },\n        ],\n        \"include\": [\"Analytics\", \"AudienceManager\"],\n        \"expandIds\": False,\n        \"priority\": \"normal\",\n        \"analyticsDeleteMethod\": \"anonymize\",\n        \"regulation\": \"ccpa\",\n    }\n    ## logging capability\n    loggingEnabled = False\n    logger = None\n\n    def __init__(\n        self,\n        privacyScope: bool = True,\n        aepScope: bool = False,\n        config: Union[dict,ConnectObject] = aepp.config.config_object,\n        header: dict = aepp.config.header,\n        loggingObject: dict = None,\n        **kwargs,\n    ) -> None:\n        \"\"\"\n        Instanciate the class for Privacy Service call.\n        Arguments:\n            privacyScope : REQUIRED : set the connection retrieved process with the Privacy JWT scope (default True).\n            aepScope : OPTIONAL : set the connection retrieved process with the AEP JWT scope if set to True (default False).\n            config : OPTIONAL : config object in the config module.\n            header : OPTIONAL : header object  in the config module.\n        kwargs:\n            kwargs will update the header\n        \"\"\"\n        if loggingObject is not None and sorted(\n            [\"level\", \"stream\", \"format\", \"filename\", \"file\"]\n        ) == sorted(list(loggingObject.keys())):\n            self.loggingEnabled = True\n            self.logger = logging.getLogger(f\"{__name__}\")\n            self.logger.setLevel(loggingObject[\"level\"])\n            if type(loggingObject[\"format\"]) == str:\n                formatter = logging.Formatter(loggingObject[\"format\"])\n            elif type(loggingObject[\"format\"]) == logging.Formatter:\n                formatter = loggingObject[\"format\"]\n            if loggingObject[\"file\"]:\n                fileHandler = logging.FileHandler(loggingObject[\"filename\"])\n                fileHandler.setFormatter(formatter)\n                self.logger.addHandler(fileHandler)\n            if loggingObject[\"stream\"]:\n                streamHandler = logging.StreamHandler()\n                streamHandler.setFormatter(formatter)\n                self.logger.addHandler(streamHandler)\n        if type(config) == dict: ## Supporting either default setup or passing a ConnectObject\n            config = config\n        elif type(config) == ConnectObject:\n            header = config.getConfigHeader()\n            config = config.getConfigObject()\n        self.connector = connector.AdobeRequest(\n            config=config,\n            header=header,\n            aepScope=aepScope,\n            privacyScope=privacyScope,\n            loggingEnabled=self.loggingEnabled,\n            logger=self.logger,\n        )\n        self.header = self.connector.header\n        self.header.update(**kwargs)\n        self.endpoint = (\n            aepp.config.endpoints[\"global\"] + aepp.config.endpoints[\"privacy\"]\n        )\n\n    def getJobs(\n        self, regulation: str = None, limit: int = 50, status: str = None, **kwargs\n    ) -> dict:\n        \"\"\"\n        Returns the job that are being processed on Adobe.\n        Arguments:\n            regulation : REQUIRED : The privacy regulation to return jobs from. (gdpr, ccpa, pdpa_tha)\n            limit : OPTIONAL : The number of jobs to return in the response body.(default 50)\n            status : OPTIONAL : Filters jobs by processing status. (complete, processing, submitted, error)\n        Possible kwargs: see documentation : https://www.adobe.io/apis/experienceplatform/home/api-reference.html#/Privacy_Jobs/fetchAllJobs\n        \"\"\"\n        if regulation is None:\n            raise Exception(\"Required regulation parameter\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getJobs\")\n        path = \"/jobs\"\n        params = {\"size\": limit, \"regulation\": regulation}\n        if status is not None:\n            params[\"status\"] = status\n        if len(kwargs) > 0:\n            for key in kwargs:\n                params[key] = str(kwargs[key])\n        res = self.connector.getData(\n            self.endpoint + path, params=params, headers=self.header\n        )\n        return res\n\n    def getJob(self, jobId: str = None) -> dict:\n        \"\"\"\n        Return a specific job by its job ID.\n        Arguments:\n            jobId : REQUIRED : the Job ID to fetch\n        \"\"\"\n        if jobId is None:\n            raise Exception(\"Require a job ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getJob\")\n        path = f\"/jobs/{jobId}\"\n        res = self.connector.getData(self.endpoint + path, headers=self.header)\n        return res\n\n    def postJob(self, data: dict = None) -> dict:\n        \"\"\"\n        Return a specific job by its job ID.\n        Arguments:\n            data : REQUIRED : data to be send in order to start a job.\n            You can use the SAMPLE_PAYLOAD to help you create the data.\n        \"\"\"\n        if data is None or type(data) != dict:\n            raise Exception(\"Require a dictionary to be passed\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting postJob\")\n        path = \"/jobs/\"\n        res = self.connector.postData(\n            self.endpoint + path, data=data, headers=self.header\n        )\n        return res\n\n    def postChildJob(self, jobId: str = None, data: dict = None) -> dict:\n        \"\"\"\n        This is to add a job on a parent Job.\n        Argument:\n            jobId : REQUIRED : the Job ID to append the job to\n            data : REQUIRED : dictionary of data to be added.\n        \"\"\"\n        if jobId is None:\n            raise Exception(\"Require a job ID\")\n        if data is None or type(data) != dict:\n            raise Exception(\"Require a dictionary to be passed\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting gpostChildJob\")\n        path = f\"/jobs/{jobId}/child-job\"\n        res = self.connector.postData(\n            self.endpoint + path, data=data, headers=self.header\n        )\n        return res", ""]}
{"filename": "aepp/__version__.py", "chunked_list": ["__version__ = \"0.3.1-4\"\n"]}
{"filename": "aepp/dataprep.py", "chunked_list": ["#  Copyright 2023 Adobe. All rights reserved.\n#  This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License. You may obtain a copy\n#  of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software distributed under\n#  the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n#  OF ANY KIND, either express or implied. See the License for the specific language\n#  governing permissions and limitations under the License.\n", "#  governing permissions and limitations under the License.\n\nimport aepp\nfrom aepp import connector\nfrom copy import deepcopy\nimport pandas as pd\nfrom typing import Union\nimport re\nimport logging\nfrom .configs import ConnectObject", "import logging\nfrom .configs import ConnectObject\n\n\nclass DataPrep:\n    \"\"\"\n    This class instanciate the data prep capability.\n    The data prep is mostly use for the mapping service and you can find some documentation on this in the following part:\n        https://www.adobe.io/apis/experienceplatform/home/api-reference.html#!acpdr/swagger-specs/data-prep.yaml\n        https://experienceleague.adobe.com/docs/experience-platform/data-prep/home.html\n    \"\"\"\n\n    ## logging capability\n    loggingEnabled = False\n    logger = None\n\n    def __init__(\n        self,\n        config: Union[dict,ConnectObject] = aepp.config.config_object,\n        header: dict = aepp.config.header,\n        loggingObject: dict = None,\n        **kwargs,\n    ) -> None:\n        \"\"\"\n            This will instantiate the Mapping class\n            Arguments:\n                config : OPTIONAL : config object in the config module. (DO NOT MODIFY)\n                header : OPTIONAL : header object  in the config module. (DO NOT MODIFY)\n                loggingObject : OPTIONAL : logging object to log messages.\n        kwargs:\n            kwargs value will update the header\n        \"\"\"\n        if loggingObject is not None and sorted(\n            [\"level\", \"stream\", \"format\", \"filename\", \"file\"]\n        ) == sorted(list(loggingObject.keys())):\n            self.loggingEnabled = True\n            self.logger = logging.getLogger(f\"{__name__}\")\n            self.logger.setLevel(loggingObject[\"level\"])\n            if type(loggingObject[\"format\"]) == str:\n                formatter = logging.Formatter(loggingObject[\"format\"])\n            elif type(loggingObject[\"format\"]) == logging.Formatter:\n                formatter = loggingObject[\"format\"]\n            if loggingObject[\"file\"]:\n                fileHandler = logging.FileHandler(loggingObject[\"filename\"])\n                fileHandler.setFormatter(formatter)\n                self.logger.addHandler(fileHandler)\n            if loggingObject[\"stream\"]:\n                streamHandler = logging.StreamHandler()\n                streamHandler.setFormatter(formatter)\n                self.logger.addHandler(streamHandler)\n        if type(config) == dict: ## Supporting either default setup or passing a ConnectObject\n            config = config\n        elif type(config) == ConnectObject:\n            header = config.getConfigHeader()\n            config = config.getConfigObject()\n        self.connector = connector.AdobeRequest(\n            config=config,\n            header=header,\n            loggingEnabled=self.loggingEnabled,\n            logger=self.logger,\n        )\n        self.header = self.connector.header\n        self.header.update(**kwargs)\n        if kwargs.get('sandbox',None) is not None: ## supporting sandbox setup on class instanciation\n            self.sandbox = kwargs.get('sandbox')\n            self.connector.config[\"sandbox\"] = kwargs.get('sandbox')\n            self.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n            self.connector.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n        else:\n            self.sandbox = self.connector.config[\"sandbox\"]\n        # same endpoint than segmentation\n        self.endpoint = (\n            aepp.config.endpoints[\"global\"] + aepp.config.endpoints[\"mapping\"]\n        )\n        self.REFERENCE_MAPPING = {\"sourceType\": \"\", \"source\": \"\", \"destination\": \"\"}\n\n    def getXDMBatchConversions(\n        self,\n        dataSetId: str = None,\n        prop: str = None,\n        batchId: str = None,\n        status: str = None,\n        limit: int = 100,\n    ) -> dict:\n        \"\"\"\n        Returns all XDM conversions\n        Arguments:\n            dataSetId : OPTIONAL : Destination dataSet ID to filter for.\n            property : OPTIONAL : Filters for dataSetId, batchId and Status.\n            batchId : OPTIONAL : batchId Filter\n            status : OPTIONAL : status of the batch.\n            limit : OPTIONAL : number of results to return (default 100)\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getXDMBatchConversions\")\n        path = \"/xdmBatchConversions\"\n        params = {\"limit\": limit}\n        if dataSetId is not None:\n            params[\"destinationDatasetId\"] = dataSetId\n        if prop is not None:\n            params[\"property\"] = prop\n        if batchId is not None:\n            params[\"sourceBatchId\"] = batchId\n        if status is not None:\n            params[\"status\"] = status\n        res = self.connector.getData(self.endpoint + path, params=params)\n        return res\n\n    def getXDMBatchConversion(self, conversionId: str = None) -> dict:\n        \"\"\"\n        Returns XDM Conversion info.\n        Arguments:\n            conversionId : REQUIRED : Conversion ID to be returned\n        \"\"\"\n        if conversionId is None:\n            raise ValueError(\"Require a conversion ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getXDMBatchConversion\")\n        path = f\"/xdmBatchConversions/{conversionId}\"\n        res = self.connector.getData(self.endpoint + path)\n        return res\n\n    def getXDMBatchConversionActivities(self, conversionId: str = None) -> dict:\n        \"\"\"\n        Returns activities for a XDM Conversion ID.\n        Arguments:\n            conversionId : REQUIRED : Conversion ID for activities to be returned\n        \"\"\"\n        if conversionId is None:\n            raise ValueError(\"Require a conversion ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getXDMBatchConversionActivities\")\n        path = f\"/xdmBatchConversions/{conversionId}/activities\"\n        res = self.connector.getData(self.endpoint + path)\n        return res\n\n    def getXDMBatchConversionRequestActivities(\n        self, requestId: str = None, activityId: str = None\n    ) -> dict:\n        \"\"\"\n        Returns conversion activities for given request\n        Arguments:\n            requestId : REQUIRED : the request ID to look for\n            activityId : REQUIRED : the activity ID to look for\n        \"\"\"\n        if requestId is None:\n            raise ValueError(\"Require a request ID\")\n        if activityId is None:\n            raise ValueError(\"Require a activity ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getXDMBatchConversionRequestActivities\")\n        path = f\"/xdmBatchConversions/{requestId}/activities/{activityId}\"\n        res = self.connector.getData(self.endpoint + path + path)\n        return res\n\n    def createXDMConversion(\n        self, dataSetId: str = None, batchId: str = None, mappingId: str = None\n    ) -> dict:\n        \"\"\"\n        Create a XDM conversion request.\n        Arguments:\n            dataSetId : REQUIRED : destination dataSet ID\n            batchId : REQUIRED : Source Batch ID\n            mappingSetId : REQUIRED : Mapping ID to be used\n        \"\"\"\n        if dataSetId is None:\n            raise ValueError(\"Require a destination dataSet ID\")\n        if batchId is None:\n            raise ValueError(\"Require a source batch ID\")\n        if mappingId is None:\n            raise ValueError(\"Require a mapping ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createXDMConversion\")\n        path = \"/xdmBatchConversions\"\n        params = {\n            \"destinationDataSetId\": dataSetId,\n            \"sourceBatchId\": batchId,\n            \"mappingSetId\": mappingId,\n        }\n        res = self.connector.getData(self.endpoint + path, params=params)\n        return res\n\n    def copyMappingRules(\n        self, mapping: Union[dict, list] = None, tenantId: str = None\n    ) -> list:\n        \"\"\"\n        create a copy of the mapping based on the mapping information passed.\n        Argument:\n            mapping : REQUIRED : either the list of mapping or the dictionary returned from the getMappingSetMapping\n            tenantid : REQUIRED : in case tenant is present, replace the existing one with new one.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting copyMapping\")\n        if tenantId.startswith(\"_\") == False:\n            tenantId = f\"_{tenantId}\"\n        if mapping is None:\n            raise ValueError(\"Require a mapping object\")\n        if type(mapping) == list:\n            new_list = [\n                {\n                    \"sourceType\": map[\"sourceType\"],\n                    \"source\": map[\"source\"],\n                    \"destination\": re.sub(\n                        \"^_[\\w]+\\.\", f\"{tenantId}.\", map[\"destination\"]\n                    ),\n                }\n                for map in mapping\n            ]\n            return new_list\n        if type(mapping) == dict:\n            if \"mappings\" in mapping.keys():\n                mappings = mapping[\"mappings\"]\n                new_list = [\n                    {\n                        \"sourceType\": map[\"sourceType\"],\n                        \"source\": map[\"source\"],\n                        \"destination\": re.sub(\n                            \"^_[\\w]+\\.\", f\"{tenantId}.\", map[\"destination\"]\n                        ),\n                    }\n                    for map in mappings\n                ]\n                return new_list\n            else:\n                print(\"Couldn't find a mapping information to copy\")\n                return None\n\n    def cleanMappingRules(self, mapping: Union[dict, list] = None\n    ) -> list:\n        \"\"\"\n        create a clean copy of the mapping based on the mapping list information passed.\n        Argument:\n            mapping : REQUIRED : either the list of mapping or the dictionary returned from the getMappingSetMapping\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting copyMapping\")\n        if mapping is None:\n            raise ValueError(\"Require a mapping object\")\n        if type(mapping) == list:\n            new_list = [\n                {\n                    \"sourceType\": map[\"sourceType\"],\n                    \"source\": map[\"source\"],\n                    \"destination\":  map[\"destination\"]\n                }\n                for map in mapping\n            ]\n            return new_list\n        if type(mapping) == dict:\n            if \"mappings\" in mapping.keys():\n                mappings = mapping[\"mappings\"]\n                new_list = [\n                    {\n                        \"sourceType\": map[\"sourceType\"],\n                        \"source\": map[\"source\"],\n                        \"destination\": map[\"destination\"]\n                    }\n                    for map in mappings\n                ]\n                return new_list\n            else:\n                print(\"Couldn't find a mapping information to clean\")\n                return None\n\n    def getMappingSets(\n        self, name: str = None, prop: str = None, limit: int = 100\n    ) -> list:\n        \"\"\"\n        Returns all mapping sets for given IMS Org Id\n        Arguments:\n            name : OPTIONAL : Filtering by name\n            prop : OPTIONAL : property filter. Supported fields are: xdmSchema, status.\n                Example : prop=\"status==success\"\n            limit : OPTIONAL : number of result to retun. Default 100.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getMappingSets\")\n        params = {\"limit\": limit}\n        if name is not None:\n            params[\"name\"] = name\n        if prop is not None:\n            params[\"property\"] = prop\n        path = \"/mappingSets\"\n        res = self.connector.getData(self.endpoint + path, params=params)\n        data = res[\"data\"]\n        return data\n\n    def getMappingSuggestions(\n        self, dataSetId: str = None, batchId: str = None, excludeUnmapped: bool = True\n    ) -> dict:\n        \"\"\"\n        Returns non-persisted mapping set suggestion for review\n        Arguments:\n            dataSetId : OPTIONAL : Id of destination DataSet. Must be a DataSet with schema.\n            batchId : OPTIONAL : Id of source Batch.\n            excludeUnmapped : OPTIONAL : Exclude unmapped source attributes (default True)\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getMappingSuggestions\")\n        path = \"/mappingSets/suggestion\"\n        params = {\"excludeUnmapped\": excludeUnmapped}\n        if dataSetId is not None:\n            params[\"datasetId\"] = dataSetId\n        if batchId is not None:\n            params[\"batchId\"] = batchId\n        res = self.connector.getData(self.endpoint + path, params=params)\n        return res\n\n    def getMappingSet(\n            self, \n            mappingSetId: str = None,\n            save: bool = False,\n            saveMappingRules: bool = False, \n            mappingRulesOnly: bool = False,\n            **kwargs\n    ) -> dict:\n        \"\"\"\n        Get a specific mappingSet by its ID.\n        Argument:\n            mappingSetId : REQUIRED : mappingSet ID to be retrieved.\n            save : OPTIONAL : save your mapping set defintion in a JSON file.\n            saveMappingRules : OPTIONAL : save your mapping rules only in a JSON file\n            mappingRulesOnly : OPTIONAL : If set to True, return only the mapping rules.\n        optional kwargs:\n            encoding : possible to set encoding for the file.\n        \"\"\"\n        if mappingSetId is None:\n            raise ValueError(\"Require a mapping ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getMappingSet\")\n        path = f\"/mappingSets/{mappingSetId}\"\n        res = self.connector.getData(self.endpoint + path)\n        if save:\n            aepp.saveFile(\n                module=\"dataPrep\",\n                file=res,\n                filename=f\"mapping_{res['id']}\",\n                type_file=\"json\",\n                encoding=kwargs.get(\"encoding\", \"utf-8\"),\n            )\n        if saveMappingRules:\n            aepp.saveFile(\n                module=\"dataPrep\",\n                file=self.cleanMappingRules(res),\n                filename=f\"mapping_rules_{res['id']}\",\n                type_file=\"json\",\n                encoding=kwargs.get(\"encoding\", \"utf-8\"),\n            )\n        if mappingRulesOnly:\n            mappingRules = self.cleanMappingRules(res)\n            return mappingRules\n        return res\n\n    def deleteMappingSet(self, mappingSetId: str = None) -> dict:\n        \"\"\"\n        Delete a specific mappingSet by its ID.\n        Argument:\n            mappingSetId : REQUIRED : mappingSet ID to be deleted.\n        \"\"\"\n        if mappingSetId is None:\n            raise ValueError(\"Require a mapping ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteMappingSet\")\n        path = f\"/mappingSets/{mappingSetId}\"\n        res = self.connector.deleteData(self.endpoint + path)\n        return res\n\n    def createMappingSet(\n        self,\n        schemaId: str = None,\n        mappingList: list = None,\n        validate: bool = False,\n        verbose: bool = False,\n        mappingSet: dict = None,\n    ) -> dict:\n        \"\"\"\n        Create a mapping set.\n        Arguments:\n            schemaId : OPTIONAL : schemaId to map to.\n            mappingList: OPTIONAL : List of mapping to set.\n            validate : OPTIONAL : Validate the mapping.\n        if you want to provide a dictionary for mapping set creation, you can pass the following params:\n            mappingSet : REQUIRED : A dictionary that creates the mapping info.\n                see info on https://www.adobe.io/apis/experienceplatform/home/api-reference.html#/Mappings/createMappingSetUsingPOST\n            \n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createMappingSet\")\n        path = \"/mappingSets\"\n        params = {\"validate\": validate}\n        if (mappingSet is None or type(mappingSet) != dict) and (\n            schemaId is None and mappingList is None\n        ):\n            raise ValueError(\n                \"Require a dictionary as mapping set or some schema reference ID and a mapping list\"\n            )\n        if mappingSet is not None:\n            res = self.connector.postData(\n                self.endpoint + path, params=params, data=mappingSet, verbose=verbose\n            )\n        elif schemaId is not None and mappingList is not None:\n            obj = {\n                \"outputSchema\": {\n                    \"schemaRef\": {\n                        \"id\": schemaId,\n                        \"contentType\": \"application/vnd.adobe.xed-full+json;version=1\",\n                    }\n                },\n                \"mappings\": mappingList,\n            }\n            res = self.connector.postData(\n                self.endpoint + path, params=params, data=obj, verbose=verbose\n            )\n        return res\n\n    def updateMappingSet(\n        self, mappingSetId: str = None, mappingRules: list = None,outputSchema:dict=None,\n    ) -> dict:\n        \"\"\"\n        Update a specific Mapping set based on its Id.\n        Arguments:\n            mappingSetId : REQUIRED : mapping Id to be updated\n            mappingRules : REQUIRED : the list of different rule to map\n            outputSchema : OPTIONAL : If you wish to change the destination output schema. By default taking the same one.\n        \"\"\"\n        if mappingSetId is None:\n            raise ValueError(\"Require a mappingSet ID\")\n        if mappingRules is None:\n            raise ValueError(\"Require a list of mappings \")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting updateMappingSet\")\n        path = f\"/mappingSets/{mappingSetId}\"\n        if outputSchema is None:\n            currMapping = self.getMappingSet(mappingSetId)\n            outputSchema = {\n                \"schemaRef\" : currMapping.get('outputSchema',{}).get('schemaRef')\n            }\n        data = {\n            \"outputSchema\":outputSchema,\n            \"mappings\":mappingRules\n        }\n        res = self.connector.putData(self.endpoint + path, data=data)\n        return res\n\n    def getMappingSetMappings(self, mappingSetId: str = None) -> dict:\n        \"\"\"\n        Returns all mappings for a mapping set\n        Arguments:\n            mappingSetId : REQUIRED : the mappingSet ID to retrieved\n        \"\"\"\n        if mappingSetId is None:\n            raise ValueError(\"Require a mapping ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getMappingSetMappings\")\n        path = f\"/mappingSets/{mappingSetId}/mappings\"\n        res = self.connector.getData(self.endpoint + path)\n        return res\n\n    def createMappingSetMapping(\n        self, mappingSetId: str = None, mapping: dict = None, verbose: bool = False\n    ) -> dict:\n        \"\"\"\n        Create mappings for a mapping set\n        Arguments:\n            mappingSetId : REQUIRED : the mappingSet ID to attached the mapping\n            mapping : REQUIRED : a dictionary to define the new mapping.\n        \"\"\"\n        if mappingSetId is None:\n            raise ValueError(\"Require a mapping ID\")\n        if mapping is None or type(mapping) != dict:\n            raise Exception(\"Require a dictionary as mapping\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createMappingSetMapping\")\n        path = f\"/mappingSets/{mappingSetId}/mappings\"\n        res = self.connector.postData(\n            self.endpoint + path, data=mapping, verbose=verbose\n        )\n        return res\n\n    def getMappingSetMapping(\n        self, mappingSetId: str = None, mappingId: str = None\n    ) -> dict:\n        \"\"\"\n        Get a mapping from a mapping set.\n        Arguments:\n            mappingSetId : REQUIRED : The mappingSet ID\n            mappingId : REQUIRED : The specific Mapping\n        \"\"\"\n        if mappingSetId is None:\n            raise ValueError(\"Require a mappingSet ID\")\n        if mappingId is None:\n            raise ValueError(\"Require a mapping ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getMappingSetMapping\")\n        path = f\"/mappingSets/{mappingSetId}/mappings/{mappingId}\"\n        res = self.connector.getData(self.endpoint + path)\n        return res\n\n    def deleteMappingSetMapping(\n        self, mappingSetId: str = None, mappingId: str = None\n    ) -> dict:\n        \"\"\"\n        Delete a mapping in a mappingSet\n        Arguments:\n            mappingSetId : REQUIRED : The mappingSet ID\n            mappingId : REQUIRED : The specific Mapping\n        \"\"\"\n        if mappingSetId is None:\n            raise ValueError(\"Require a mappingSet ID\")\n        if mappingId is None:\n            raise ValueError(\"Require a mapping ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteMappingSetMapping\")\n        path = f\"/mappingSets/{mappingSetId}/mappings/{mappingId}\"\n        res = self.connector.deleteData(self.endpoint + path)\n        return res\n\n    def updateMappingSetMapping(\n        self, mappingSetId: str = None, mappingId: str = None, mapping: dict = None\n    ) -> dict:\n        \"\"\"\n        Update a mapping for a mappingSet (PUT method)\n        Arguments:\n            mappingSetId : REQUIRED : The mappingSet ID\n            mappingId : REQUIRED : The specific Mapping\n            mapping : REQUIRED : dictionary to update\n        \"\"\"\n        if mappingSetId is None:\n            raise ValueError(\"Require a mappingSet ID\")\n        if mappingId is None:\n            raise ValueError(\"Require a mapping ID\")\n        if mapping is None or type(mapping) != dict:\n            raise Exception(\"Require a dictionary as mapping\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting updateMappingSetMapping\")\n        path = f\"/mappingSets/{mappingSetId}/mappings/{mappingId}\"\n        res = self.connector.putData(self.endpoint + path, data=mapping)\n        return res\n\n    def previewDataOutput(self, data: dict = None, mappingSet: dict = None) -> dict:\n        \"\"\"\n        The data you want to run through as a preview, which will be transformed by the mapping sets within the body.\n        Arguments:\n            data : REQUIRED : A dictionary containing the data to test.\n            mappingSet : REQUIRED : The mappingSet to test.\n\n        Example:\n        {\n            \"data\": {\n                \"id\": 1234,\n                \"firstName\": \"Jim\",\n                \"lastName\": \"Seltzer\"\n            },\n            \"mappingSet\": {\n                \"outputSchema\": {\n                \"schemaRef\": {\n                    \"id\": \"https://ns.adobe.com/stardust/schemas/89abc189258b1cb1a816d8f2b2341a6d98000ed8f4008305\",\n                    \"contentType\": \"application/vnd.adobe.xed-full+json;version=1\"\n                }\n                },\n                \"mappings\": [\n                {\n                    \"sourceType\": \"ATTRIBUTE\",\n                    \"source\": \"id\",\n                    \"destination\": \"_id\",\n                    \"name\": \"id\",\n                    \"description\": \"Identifier field\"\n                },\n                {\n                    \"sourceType\": \"ATTRIBUTE\",\n                    \"source\": \"firstName\",\n                    \"destination\": \"person.name.firstName\"\n                },\n                {\n                    \"sourceType\": \"ATTRIBUTE\",\n                    \"source\": \"lastName\",\n                    \"destination\": \"person.name.lastName\"\n                }\n                ]\n            }\n        }\n        \"\"\"\n        if data is None:\n            raise ValueError(\"Require a dictionary that contains the data to be tested\")\n        if mappingSet is None:\n            raise ValueError(\"Require a dictionary that contains the mapping set\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting previewDataOutput\")\n        path = \"/mappingSets/preview\"\n        dataObject = {\"data\": data, \"mappingSet\": mappingSet}\n        res = self.connector.postData(self.endpoint + path, data=dataObject)\n        return res\n\n    def getMappingSetFunctions(\n        self,\n    ) -> list:\n        \"\"\"\n        Return list of mapping functions.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getMappingSetFunctions\")\n        path = \"/languages/el/functions\"\n        res = self.connector.getData(self.endpoint + path)\n        return res\n\n    def getMappingSetOperators(\n        self,\n    ) -> list:\n        \"\"\"\n        Return list of mapping operators.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getMappingSetOperators\")\n        path = \"/languages/el/operators\"\n        res = self.connector.getData(self.endpoint + path)\n        return res\n\n    def validateExpression(\n        self,\n        expression: str = None,\n        mappingSetId: str = None,\n        sampleData: str = None,\n        sampleDataType: str = None,\n    ) -> dict:\n        \"\"\"\n        Check if the expression that you have passed is valid.\n        Arguments:\n            expression : REQUIRED : the expression you are trying to validate.\n            mappingSetId : OPTIONAL : MappingSetId to integrate this expression.\n            sampleData : OPTIONAL : Sample Date to validate\n            sampleDataType : OPTIONAL : Data Type of your Sample data.\n        \"\"\"\n        if expression is None:\n            raise ValueError(\"Require an expression\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting validateExpression\")\n        path = \"/languages/el/validate\"\n        data = {\"expression\": expression}\n        if mappingSetId is not None:\n            data[\"mappingSetId\"] = mappingSetId\n        if sampleData is not None:\n            data[\"sampleData\"] = sampleData\n        if sampleDataType is not None:\n            data[\"sampleDataType\"] = sampleDataType\n        res = self.connector.postData(self.endpoint + path, data=data)\n        return res", ""]}
{"filename": "aepp/segmentation.py", "chunked_list": ["#  Copyright 2023 Adobe. All rights reserved.\n#  This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License. You may obtain a copy\n#  of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software distributed under\n#  the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n#  OF ANY KIND, either express or implied. See the License for the specific language\n#  governing permissions and limitations under the License.\n", "#  governing permissions and limitations under the License.\n\n# Internal Library\nimport aepp\nfrom aepp import connector\nimport time\nfrom concurrent import futures\nimport logging\nfrom typing import Union\nfrom copy import deepcopy", "from typing import Union\nfrom copy import deepcopy\nfrom .configs import ConnectObject\n\n\nclass Segmentation:\n    \"\"\"\n    A class containing methods to use on segmentation.\n    A complete documentation can be found here:\n    https://www.adobe.io/apis/experienceplatform/home/api-reference.html#!acpdr/swagger-specs/segmentation.yaml\n    \"\"\"\n\n    ## logging capability\n    loggingEnabled = False\n    logger = None\n    PLATFORM_AUDIENCE_DICT = {\n                    \"name\": \"People who ordered in the last 30 days\",\n                    \"profileInstanceId\": \"ups\",\n                    \"description\": \"This audience is generated to see people who ordered in the last 30 days.\",\n                    \"type\": \"SegmentDefinition\",\n                    \"expression\": {\n                        \"type\": \"PQL\",\n                        \"format\": \"pql/text\",\n                        \"value\": \"workAddress.country = \\\"US\\\"\"\n                    },\n                    \"schema\": {\n                        \"name\": \"_xdm.context.profile\"\n                    },\n                    \"labels\": [\n                        \"core/C1\"\n                    ],\n                    \"ttlInDays\": 60\n                }\n    EXTERNAL_AUDIENCE_DICT = {\n                    \"audienceId\": \"test-external-audience-id\",\n                    \"name\": \"externalSegment1\",\n                    \"namespace\": \"aam\",\n                    \"description\": \"This audience is generated to see people who ordered in the last 30 days.\",\n                    \"type\": \"ExternalSegment\",\n                    \"lifecycle\": \"published\",\n                    \"datasetId\": \"6254cf3c97f8e31b639fb14d\",\n                    \"labels\": [\n                        \"core/C1\"\n                    ],\n                    \"audienceMeta\": {\n                        \"segmentStatus\": \"ACTIVE\",\n                        \"AAMFolderId\": \"325813-testnew\"\n                    },\n                    \"linkedAudienceRef\": {\n                        \"flowId\": \"4685ea90-d2b6-11ec-9d64-0242ac120002\"\n                    }\n                }  \n\n    def __init__(\n        self,\n        config: Union[dict,ConnectObject] = aepp.config.config_object,\n        header: dict = aepp.config.header,\n        loggingObject: dict = None,\n        **kwargs,\n    ) -> None:\n        \"\"\"\n        Instanciate the segmentation API methods class-\n        Arguments:\n            loggingObject : OPTIONAL : logging object to log messages.\n            config : OPTIONAL : config object in the config module. (DO NOT MODIFY)\n            header : OPTIONAL : header object  in the config module. (DO NOT MODIFY)\n        \"\"\"\n        if loggingObject is not None and sorted(\n            [\"level\", \"stream\", \"format\", \"filename\", \"file\"]\n        ) == sorted(list(loggingObject.keys())):\n            self.loggingEnabled = True\n            self.logger = logging.getLogger(f\"{__name__}\")\n            self.logger.setLevel(loggingObject[\"level\"])\n            if type(loggingObject[\"format\"]) == str:\n                formatter = logging.Formatter(loggingObject[\"format\"])\n            elif type(loggingObject[\"format\"]) == logging.Formatter:\n                formatter = loggingObject[\"format\"]\n            if loggingObject[\"file\"]:\n                fileHandler = logging.FileHandler(loggingObject[\"filename\"])\n                fileHandler.setFormatter(formatter)\n                self.logger.addHandler(fileHandler)\n            if loggingObject[\"stream\"]:\n                streamHandler = logging.StreamHandler()\n                streamHandler.setFormatter(formatter)\n                self.logger.addHandler(streamHandler)\n        if type(config) == dict: ## Supporting either default setup or passing a ConnectObject\n            config = config\n        elif type(config) == ConnectObject:\n            header = config.getConfigHeader()\n            config = config.getConfigObject()\n        self.connector = connector.AdobeRequest(\n            config=config,\n            header=header,\n            loggingEnabled=self.loggingEnabled,\n            logger=self.logger,\n        )\n        self.header = self.connector.header\n        self.header.update(**kwargs)\n        if kwargs.get('sandbox',None) is not None: ## supporting sandbox setup on class instanciation\n            self.sandbox = kwargs.get('sandbox')\n            self.connector.config[\"sandbox\"] = kwargs.get('sandbox')\n            self.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n            self.connector.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n        else:\n            self.sandbox = self.connector.config[\"sandbox\"]\n        self.endpoint = (\n            aepp.config.endpoints[\"global\"] + aepp.config.endpoints[\"segmentation\"]\n        )\n        self.SCHEDULE_TEMPLATE = {\n            \"name\": \"profile-default\",\n            \"type\": \"batch_segmentation-OR-export\",\n            \"properties\": {\"segments\": [\"*\"]},\n            \"schedule\": \"0 0 1 * * ?\",\n            \"state\": \"inactive\",\n        }\n\n    def getResource(self,endpoint:str=None, params:dict=None, **kwargs)->dict:\n        \"\"\"\n        Abstract GET requests with header from the the connection.\n        Arguments:\n            endpoint : REQUIRED : the endpoint to use\n            params : OPTIONAL : the parameters to use in the GET requests\n        possible kwargs:\n            all kwargs are passed to the header\n        \"\"\"\n        if endpoint is None:\n            raise ValueError(\"Endpoint is required\")\n        if type(params) != dict:\n            raise TypeError(\"params should be a dictionary\")\n        parameters = {**params}\n        myPrivateHeader = deepcopy(self.header)\n        if kwargs is None:\n            for key in kwargs:\n                myPrivateHeader[key] = kwargs[key]\n        res = self.connector.getData(endpoint, headers=myPrivateHeader,params=parameters)\n        return res\n\n\n    def getSegments(self, onlyRealTime: bool = False, **kwargs) -> list:\n        \"\"\"\n        Return segment definitions in your experience platfom instance.\n        Arguments:\n            onlyRealTime : OPTIONAL : If you wish to retrieve only real time compatible segment. (default False)\n        Possible arguments:\n            - limit : number of segment returned per page\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getSegments\")\n        params = {\"limit\": kwargs.get(\"limit\", 100)}\n        if onlyRealTime:\n            params[\"evaluationInfo.continuous.enabled\"] = True\n        path = \"/segment/definitions\"\n        res = self.connector.getData(self.endpoint + path, headers=self.header)\n        if \"segments\" in res.keys():\n            data = res[\"segments\"]\n        else:\n            data = []\n        total_pages = res[\"page\"][\"totalPages\"]\n        if total_pages > 1:\n            nb_request = total_pages\n            max_workers = min((total_pages, 5))\n            list_parameters = [\n                {\"page\": str(x), **params} for x in range(1, total_pages + 1)\n            ]\n            urls = [self.endpoint + path for x in range(1, total_pages + 1)]\n            with futures.ThreadPoolExecutor(max_workers) as executor:\n                res = executor.map(\n                    lambda x, y: self.connector.getData(x, params=y),\n                    urls,\n                    list_parameters,\n                )\n            res = list(res)\n            append_data = [\n                val for sublist in [data[\"segments\"] for data in res] for val in sublist\n            ]  # flatten list of list\n            data = data + append_data\n        return data\n\n    def getSegment(self, segment_id: str = None) -> dict:\n        \"\"\"\n        Return a specific segment definition.\n        Argument:\n            segment_id : REQUIRED : Segment ID of the segment to be retrieved.\n        \"\"\"\n        if segment_id is None:\n            raise Exception(\"Expecting a segment ID to fetch the segment definition.\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getSegment\")\n        path = f\"/segment/definitions/{segment_id}\"\n        res = self.connector.getData(self.endpoint + path, headers=self.header)\n        return res\n\n    def createSegment(self, segment_data: dict = None) -> dict:\n        \"\"\"\n        Create a segment based on the information provided by the dictionary passed.\n        Argument :\n            segment_data : REQUIRED : Dictionary of the segment definition.\n                require in the segment_data: name, description, expression, schema, ttlInDays\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createSegment\")\n        path = \"/segment/definitions\"\n        if segment_data is None or type(segment_data) != dict:\n            raise Exception(\n                \"Expecting data as dictionary format to update the segment.\"\n            )\n        checks = \"name,description,expression,schema,ttlInDays\".split(\n            \",\"\n        )  # mandatory elements in segment definition\n        if len(set(checks) & set(segment_data.keys())) != len(checks):\n            raise Exception(\n                \"Segment data doesn't hold one or several mandatory fields:\\n\\\n                name, description, expression, schema, ttlInDays\"\n            )\n        res = self.connector.postData(\n            self.endpoint + path, data=segment_data, headers=self.header\n        )\n        return res\n\n    def deleteSegment(self, segment_id: str = None) -> dict:\n        \"\"\"\n        Delete a specific segment definition.\n        Argument:\n            segment_id : REQUIRED : Segment ID of the segment to be deleted.\n        \"\"\"\n        if segment_id is None:\n            raise Exception(\"Expecting a segment ID to delete the segment.\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteSegment\")\n        path = f\"/segment/definitions/{segment_id}\"\n        res = self.connector.deleteData(self.endpoint + path, headers=self.header)\n        return res\n\n    def updateSegment(self, segment_id: str = None, segment_data: dict = None) -> dict:\n        \"\"\"\n        Update the segment characteristics from the definition pass to that method.\n        Arguments:\n            segment_id : REQUIRED : id of the segment to be udpated.\n            segment_data : REQUIRED : Dictionary of the segment definition.\n                require in the segment_data: name, description, expression, schema, ttlInDays\n        \"\"\"\n        if segment_id is None:\n            raise Exception(\"Expecting a segment ID to update the segment.\")\n        elif segment_data is None or type(segment_data) != dict:\n            raise Exception(\n                \"Expecting data as dictionary format to update the segment.\"\n            )\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting updateSegment\")\n        path = f\"/segment/definitions/{segment_id}\"\n        checks = \"name,expression,schema,ttlInDays\".split(\n            \",\"\n        )  # mandatory elements in segment definition\n        if len(set(checks) & set(segment_data.keys())) != len(checks):\n            raise Exception(\n                \"Segment data doesn't hold one or several mandatory fields:\\n\\\n                name, description, expression, schema, ttlInDays\"\n            )\n        update = self.connector.postData(\n            self.endpoint + path, headers=self.header, data=segment_data\n        )\n        return update\n    \n    def getMultipleSegments(self,segmentIds:list=None)->dict:\n        \"\"\"\n        Retrieve multiple segments from a list of segment IDs.\n        Arguments:\n            segmentIds: REQUIRED : list of segment IDs\n        \"\"\"\n        if segmentIds is None:\n            raise Exception(\"Require a list of segment Ids\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getMultipleSegments with this list: {segmentIds}\")\n        path = \"/segment/definitions/bulk-get\"\n        res = self.connector.postData(self.endpoint + path,data=segmentIds)\n        results = res.get('results')\n        return results\n\n    def convertSegmentDef(self,name:str=None,expression:dict=None,description:str=None,schemaClass:str=\"_xdm.context.profile\",ttl:int=30,**kwargs)->dict:\n        \"\"\"\n        This endpoint converts a segment definition from pql/text to pql/json or from pql/json to pql/text.\n        Arguments:\n            name : REQUIRED : The name of the segment. It should be unique.\n            expression : REQUIRED : the expriession regarding the transformation.\n                A dictionary such as\n                {\n                    \"type\" : \"PQL\" (or \"ARL\"),\n                    \"format\" : \"pql/text\" (or \"pql/json\")\n                    \"value\" : \"your PQL expression\"\n                }\n            description : OPTIONAL : the description to be used\n            schemaClass : OPTIONAL :  the class ID to be used. (ex: default : \"_xdm.context.profile\")\n            ttl : OPTIONAL : Time to live per day (default 30)\n        possible kwargs:\n            additional kwargs will be used as parameter of the body\n        \"\"\"\n        if name is None:\n            raise Exception(\"Require a name\")\n        if expression is None and type(expression)!=dict:\n            raise Exception(\"Require a dictionary as expression\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting convertSegmentDef\")\n        path = \"/segment/conversion\"\n        data = {**kwargs}\n        data['name'] = name\n        data['imsOrgId'] = self.connector.config['org_id']\n        data['description'] = description\n        data['expression'] = expression\n        data['schema'] = {\n            \"name\" : schemaClass\n        }\n        data['ttlInDays'] = ttl\n        res = self.connector.postData(self.endpoint + path,data=data)\n        return res\n\n    def getExportJobs(self, limit: int = 1000, status: str = None) -> list:\n        \"\"\"\n        Retrieve a list of all export jobs.\n        Arguments:\n            limit : OPTIONAL : number of jobs to be returned (default 100)\n            status : OPTIONAL : status of the job (NEW, SUCCEEDED, FAILED)\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getExportJobs\")\n        path = \"/export/jobs\"\n        params = {\"limit\": limit}\n        if status is not None and status in [\"NEW\", \"SUCEEDED\", \"FAILED\"]:\n            params[\"status\"] = status\n        lastPage = False\n        data = []\n        while lastPage != True:\n            res = self.connector.getData(\n                self.endpoint + path, params=params, headers=self.header\n            )\n            data += res[\"records\"]\n            nextPage = res.get(\"link\", {}).get(\"next\", \"\")\n            if nextPage == \"\":\n                lastPage = True\n            else:\n                offset = nextPage.split(\"offset=\")[1].split(\"&\")[0]\n                params[\"offset\"] = offset\n        return data\n\n    def createExport(self, export_request: dict = None) -> dict:\n        \"\"\"\n        Create an exportJob\n        Arguments:\n            export_request : REQUIRED : number of jobs to be returned (default 100)\n            information on the structure of the request here: https://experienceleague.adobe.com/docs/experience-platform/segmentation/api/export-jobs.html?lang=en#get\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createExport\")\n        path = \"/export/jobs\"\n        if export_request is None:\n            raise Exception(\"Expected export data to specify segment to export.\")\n        res = self.connector.postData(\n            self.endpoint + path, data=export_request, headers=self.header\n        )\n        return res\n\n    def getExport(self, export_id: str = None) -> dict:\n        \"\"\"\n        Retrieve a specific export Job.\n        Arguments:\n            export_id : REQUIRED : Export Job to be retrieved.\n        \"\"\"\n        if export_id is None:\n            raise Exception(\"Expected a export_id\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getExport\")\n        path = f\"/export/jobs/{export_id}\"\n        res = self.connector.getData(self.endpoint + path, headers=self.header)\n        return res\n\n    def deleteExport(self, export_id: str = None) -> dict:\n        \"\"\"\n        Cancel or delete an export Job.\n        Arguments:\n            export_id : REQUIRED : Export Job to be deleted.\n        \"\"\"\n        if export_id is None:\n            raise Exception(\"Expected a export_id\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteExport\")\n        path = f\"/export/jobs/{export_id}\"\n        res = self.connector.deleteData(self.endpoint + path, headers=self.header)\n        return res\n\n    def searchNamespaces(\n        self,\n        query: str = None,\n        schema: str = \"_xdm.context.segmentdefinition\",\n        **kwargs,\n    ) -> dict:\n        \"\"\"\n        Return a list of search count results, queried across all namespaces.\n        Arguments:\n            query : REQUIRED : the search query.\n            schema : OPTIONAL : The schema class value associated with the search objects. (default _xdm.context.segmentdefinition)\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting searchNamespaces\")\n        path = \"/search/namespaces\"\n        if query is None:\n            raise Exception(\"Expected a query to search for.\")\n        params = {\"schema.name\": schema, \"s\": query}\n        self.header[\"x-ups-search-version\"] = \"1.0\"\n        res = self.connector.getData(\n            self.endpoint + path, headers=self.header, params=params\n        )\n        del self.header[\"x-ups-search-version\"]\n        return res\n\n    def searchEntities(\n        self,\n        query: str = None,\n        namespace: str = \"ECID\",\n        entityId: str = None,\n        schema: str = \"_xdm.context.segmentdefinition\",\n        **kwargs,\n    ) -> dict:\n        \"\"\"\n        Return the list of objects that are contained  within a namespace.\n        Arguments:\n            query : REQUIRED : the search query based on Lucene query syntax (ex: name:test) (https://learn.microsoft.com/en-us/azure/search/query-lucene-syntax)\n            schema : OPTIONAL : The schema class value associated with the search objects.(defaul _xdm.context.segmentdefinition)\n            namespace : OPTIONAL : The namespace you want to search within (default ECID)\n            entityId : OPTIONAL : The ID of the folder you want to search for external segments in\n        possible kwargs:\n            limit : maximum number of result per page. Max 50.\n            page : page to be retrieved (start at 0)\n            page_limit : maximum number of pages retrieved.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting searchEntity\")\n        path = \"/search/entities\"\n        if query is None:\n            raise Exception(\"Expected a query to search for.\")\n        limit = kwargs.get(\"limit\", 50)\n        page = kwargs.get(\"page\", 0)\n        page_limit = kwargs.get(\"page_limit\", 0)\n        self.header[\"x-ups-search-version\"] = \"1.0\"\n        params = {\n            \"schemaClass\": schema,\n            \"namespace\": namespace,\n            \"s\": query,\n            \"entityId\": entityId,\n            \"limit\": limit,\n            \"page\": page,\n        }\n        res = self.connector.getData(\n            self.endpoint + path, headers=self.header, params=params\n        )\n        data = res[\"entities\"]\n        curr_page = res[\"page\"][\"pageOffset\"]\n        total_pages = res[\"page\"][\"totalPages\"]\n        while curr_page <= page_limit - 1 or curr_page == total_pages:\n            res = self.connector.getData(\n                self.endpoint + path, headers=self.header, params=params\n            )\n            data += res[\"entities\"]\n            curr_page = res[\"page\"][\"pageOffset\"]\n            total_pages = res[\"page\"][\"totalPages\"]\n        del self.header[\"x-ups-search-version\"]\n        return data\n\n    def getSchedules(\n        self, limit: int = 100, n_results: Union[int, str] = \"inf\"\n    ) -> list:\n        \"\"\"\n        Return the list of scheduled segments.\n        Arguments:\n            limit : OPTIONAL : number of result per request (100 max)\n            n_results : OPTIONAL : Total of number of result to retrieve.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getSchedules\")\n        path = \"/config/schedules\"\n        params = {\"start\": 0}\n        lastPage = False\n        data = []\n        while lastPage != True:\n            res = self.connector.getData(\n                self.endpoint + path, params=params, headers=self.header\n            )\n            data += res.get(\"children\", [])\n            nextPage = res.get(\"_links\", {}).get(\"href\", \"\")\n            if nextPage == \"\" or len(data) > float(n_results):\n                lastPage = True\n            else:\n                params[\"start\"] += 1\n        return data\n\n    def createSchedule(self, schedule_data: dict = None) -> dict:\n        \"\"\"\n        Schedule a segment to run.\n        Arguments:\n            schedule_data : REQUIRED : Definition of the schedule.\n            Should contains name, type, properties, schedule.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createSchedule\")\n        path = \"/config/schedules\"\n        if schedule_data is None or type(schedule_data) != dict:\n            raise Exception(\n                \"Expected a dictionary data for setting the segment schedule.\"\n            )\n        min_requirements = \"name,type,properties,schedule\".split(\",\")\n        if len(set(min_requirements) & set(schedule_data.keys())) != len(\n            min_requirements\n        ):\n            raise Exception(\n                \"Missing one minimal requirements : name, type, properties, schedule\"\n            )\n        res = self.connector.postData(\n            self.endpoint + path, data=schedule_data, headers=self.header\n        )\n        return res\n\n    def getSchedule(self, scheduleId: str = None) -> dict:\n        \"\"\"\n        Get a specific schedule definition.\n        Argument:\n            scheduleId : REQUIRED : Segment ID to be retrieved.\n        \"\"\"\n        if scheduleId is None:\n            raise Exception(\"Expected a schedule_id\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getSchedule\")\n        path = f\"/config/schedules/{scheduleId}\"\n        res = self.connector.getData(self.endpoint + path, headers=self.header)\n        return res\n\n    def deleteSchedule(self, scheduleId: str = None) -> dict:\n        \"\"\"\n        Delete a specific schedule definition.\n        Argument:\n            scheduleId : REQUIRED : Segment ID to be deleted.\n        \"\"\"\n        if scheduleId is None:\n            raise Exception(\"Expected a schedule_id\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteSchedule\")\n        path = f\"/config/schedules/{scheduleId}\"\n        res = self.connector.deleteData(self.endpoint + path, headers=self.header)\n        return res\n\n    def updateSchedule(self, scheduleId: str = None, operations: list = None) -> dict:\n        \"\"\"\n        Update a schedule with the operation provided.\n        Arguments:\n            scheduleId : REQUIRED : the schedule ID to update\n            operations : REQUIRED : List of operations to realize\n                [\n                    {\n                    \"op\": \"add\",\n                    \"path\": \"/state\",\n                    \"value\": \"active\"\n                    }\n                ]\n        \"\"\"\n        if scheduleId is None:\n            raise ValueError(\"Require a schedule ID\")\n        if operations is None or type(operations) != list:\n            raise ValueError(\"Require a list of operation to run\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting updateSchedule\")\n        path = f\"/config/schedules/{scheduleId}\"\n        res = self.connector.patchData(self.endpoint + path, data=operations)\n        return res\n\n    def getJobs(\n        self,\n        name: str = None,\n        status: str = None,\n        limit: int = 100,\n        n_results: Union[str, int] = \"inf\",\n        **kwargs,\n    ) -> list:\n        \"\"\"\n        Returns the list of segment jobs.\n        Arguments:\n            name : OPTIONAL : Name of the snapshot\n            status : OPTIONAL : Status of the job (PROCESSING,SUCCEEDED)\n            limit : OPTIONAL : Amount of jobs to be retrieved per request (100 max)\n            n_results : OPTIONAL : How many total jobs do you want to retrieve.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getJobs\")\n        path = \"/segment/jobs\"\n        params = {\"snapshot.name\": name, \"status\": status, \"limit\": limit, \"start\": 0}\n        lastPage = False\n        data = []\n        while lastPage != True:\n            res = self.connector.getData(\n                self.endpoint + path, params=params, headers=self.header\n            )\n            data += res.get(\"children\", [])\n            nextPage = res.get(\"_links\", {}).get(\"href\", \"\")\n            if nextPage == \"\" or len(data) > float(n_results):\n                lastPage = True\n            else:\n                params[\"start\"] += 1\n        return data\n\n    def createJob(self, segmentIds: list = None) -> dict:\n        \"\"\"\n        Create a new job for a segment.\n        Argument:\n            segmentIds : REQUIRED : a list of segmentIds.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createJob\")\n        path = \"/segment/jobs\"\n        if segmentIds is None or type(segmentIds) != list:\n            raise Exception(\"Expecting a list of segment ID to run.\")\n        jobData = [{\"segmentId\": segId} for segId in segmentIds]\n        res = self.connector.postData(\n            self.endpoint + path, data=jobData, headers=self.header\n        )\n        return res\n\n    def getJob(self, job_id: str = None) -> dict:\n        \"\"\"\n        Retrieve a Segment job by ID.\n        Argument:\n            job_id: REQUIRED : The job ID to retrieve.\n        \"\"\"\n        if job_id is None:\n            raise ValueError(\"Require a job ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getJob\")\n        path = f\"/segment/jobs/{job_id}\"\n        res = self.connector.getData(self.endpoint + path, headers=self.header)\n        return res\n\n    def deleteJob(self, job_id: str = None) -> dict:\n        \"\"\"\n        deleteJob a Segment job by ID.\n        Argument:\n            job_id: REQUIRED : The job ID to delete.\n        \"\"\"\n        if job_id is None:\n            raise ValueError(\"Require a job ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getJob\")\n        path = f\"/segment/jobs/{job_id}\"\n        res = self.connector.deleteData(self.endpoint + path, headers=self.header)\n        return res\n\n    def createPreview(\n        self, pql: str = None, model: str = \"_xdm.context.profile\"\n    ) -> dict:\n        \"\"\"\n        Given a PQL expression genereate a preview of how much data there would be.\n        Arguments:\n            pql : REQUIRED : The PQL statement that would be your segment definition\n            model : OPTIONAL : XDM class the statement is based on. Default : _xdm.context.profile\n        \"\"\"\n        if pql is None:\n            ValueError(\"Require a PQL statement for creation\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createPreview\")\n        path = \"/preview\"\n        obj = {\n            \"predicateExpression\": pql,\n            \"predicateType\": \"pql/text\",\n            \"predicateModel\": model,\n            \"graphType\": \"pdg\",\n        }\n        res = self.connector.postData(self.endpoint + path, data=obj)\n        return res\n\n    def getPreview(self, previewId: str = None) -> dict:\n        \"\"\"\n        Retrieve the preview once it has been created by the createPreview method.\n        Arguments:\n            previewId : REQUIRED : The preview ID to used.\n        \"\"\"\n        if previewId is None:\n            raise Exception(\"require a preview ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getPreview\")\n        path = f\"/preview/{previewId}\"\n        res = self.connector.getData(self.endpoint + path)\n        return res\n\n    def deletePreview(self, previewId: str = None) -> dict:\n        \"\"\"\n        Delete the preview based on its ID.\n        Arguments:\n            previewId : REQUIRED : The preview ID to deleted.\n        \"\"\"\n        if previewId is None:\n            raise Exception(\"require a preview ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deletePreview\")\n        path = f\"/preview/{previewId}\"\n        res = self.connector.deleteData(self.endpoint + path)\n        return res\n\n    def getEstimate(self, previewId: str = None) -> dict:\n        \"\"\"\n        Based on the preview ID generated by createPreview, you can look at statistical information of a segment.\n        Arguments:\n            previewId : REQUIRED : The preview ID to used for estimation\n        \"\"\"\n        if previewId is None:\n            raise Exception(\"require a preview ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getEstimate\")\n        path = f\"/estimate/{previewId}\"\n        res = self.connector.getData(self.endpoint + path)\n        return res\n\n    def estimateExpression(\n        self, pql: str = None, model: str = \"_xdm.context.profile\", wait: int = 60\n    ) -> dict:\n        \"\"\"\n        This method is a combination of the createPreview and getEstimate method so you don't have to build a pipeline for it.\n        It automatically fetch the estimate based on the PQL statement passed. Run a loop every minute to fetch the result.\n        Arguments:\n            pql : REQUIRED : The PQL statement that would be your segment definition\n            model : OPTIONAL : XDM class the statement is based on. Default : _xdm.context.profile\n            wait : OPTIONAL : How many seconds to wait between 2 call to getEstimate when result are not ready. (default 60)\n        \"\"\"\n        if pql is None:\n            raise ValueError(\"Require a PQL expression\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting estimateExpression\")\n        preview = self.createPreview(pql=pql, model=model)\n        try:\n            previewId = preview[\"previewId\"]\n        except:\n            print(preview)\n            raise KeyError(\"Couldn't retrieve the previewId from the response\")\n        estimate = self.getEstimate(previewId)\n        while estimate[\"state\"] != \"RESULT_READY\" or estimate[\"state\"] != \"ERROR\":\n            time.sleep(60)\n            estimate = self.getEstimate(previewId)\n        return estimate\n    \n\n    def getAudiences(self,\n        limit:int=100,\n        metrics:bool=True,\n        name:str=None,\n        sort:str=None,\n        prop:str=None,\n        description:str=None,\n        **kwargs)->list:\n        \"\"\"\n        Get the audiences list.\n        Arguments:\n            name : OPTIONAL : Filter audiences that contains that string in the name, case unsensitive.\n            limit : OPTIONAL : The number of audiences to be returned by pages (default: 100)\n            sort : OPTIONAL : If you want to sort by a specific attribute (ex: \"updateTime:desc\")\n            prop : If you want to test a specific property of the result to filter the data.\n                    Ex: \"audienceId==mytestAudienceId\"\n            description : OPTIONAL : Filter audiences that contains that string in the description, case unsensitive.\n            with metrics : OPTIONAL : If metrics should be returned as well. Default true.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getAudiences\")\n        params = {\"limit\":limit,\"withMetrics\":metrics}\n        path = \"/audiences\"\n        if name is not None:\n            params['name'] = name\n        if sort is not None:\n            params['sort'] = sort\n        if prop is not None:\n            params['property'] = prop\n        if description is not None:\n            params['description'] = description\n        if kwargs.get('start',0) is not None:\n            params['start'] = kwargs.get('start')\n        res = self.connector.getData(self.endpoint+path, params=params)\n        data = res.get('children',[])\n        nextStart = res.get('_pages',{}).get('next',0)\n        while nextStart != 0:\n            params['start'] = nextStart\n            res = self.connector.getData(self.endpoint+path, params=params)\n            data += res.get('children',[])\n            nextStart = res.get('_pages',{}).get('next',0)\n        return data\n    \n    def getAudience(self,audienceId:str=None)->dict:\n        \"\"\"\n        Retrieve a specific audience id.\n        Arguments:\n            audienceId : REQUIRED : The audience ID to retrieve.\n        \"\"\"\n        if audienceId is None:\n            raise ValueError(\"Require an audience ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getAudience for audienceId: {audienceId}\")\n        path = f\"/audiences/{audienceId}\"\n        res = self.connector.getData(self.endpoint + path)\n        return res\n\n    def deleteAudience(self,audienceId:str=None)->str:\n        \"\"\"\n        Delete an audience based on its ID.\n        Argument:\n            audienceId : REQUIRED : The audience ID to delete\n        \"\"\"\n        if audienceId is None:\n            raise ValueError(\"Require an audience ID\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteAudience for audienceId: {audienceId}\")\n        path = f\"/audiences/{audienceId}\"\n        res = self.connector.deleteData(self.endpoint + path)\n        return res\n    \n    def createAudience(self,audienceObj:dict=None)->dict:\n        \"\"\"\n        Create an audience basde on the dictionary passed as argument.\n        Argument:\n            audienceObj : REQUIRED : Can be either one of the Platform Audience or External Audience\n                See constants EXTERNAL_AUDIENCE_DICT & PLATFORM_AUDIENCE_DICT  \n        \"\"\"\n        if audienceObj is None or type(audienceObj) != dict:\n            raise ValueError(\"Require an audience Object as dictionary\")\n        path = \"/audiences\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createAudience\")\n        res = self.connector.postData(self.endpoint + path, data=audienceObj)\n        return res\n\n    def patchAudience(self,audienceId:str=None,operations:list=None)->dict:\n        \"\"\"\n        PATCH an existing audience with some operation described in parameter.\n        Arguments:\n            audienceId : REQUIRED : The audience ID to patch\n            operations : REQUIRED : A list of operation to apply.\n                            Example: \n                            [\n                                {\n                                    \"op\": \"add\",\n                                    \"path\": \"/expression\",\n                                    \"value\": {\n                                    \"type\": \"PQL\",\n                                    \"format\": \"pql/text\",\n                                    \"value\": \"workAddress.country= \\\"US\\\"\"\n                                    }\n                                }\n                            ]\n        \"\"\"\n        if audienceId is None:\n            raise ValueError(\"Require an audience ID\")\n        if operations is None or type(operations) != list:\n            raise ValueError(\"Require a list of operations\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting patchAudience for audienceId: {audienceId}\")\n        path = f\"/audiences/{audienceId}\"\n        res = self.connector.patchData(self.endpoint + path,data=operations)\n        return res\n    \n    def putAudience(self,audienceId:str=None,audienceObj: dict = None)-> dict:\n        \"\"\"\n        Replace an existing definition with a new one, with the PUT method.\n        Arguments:\n            audienceId : REQUIRED : the audience ID to replace\n            audienceObj : REQUIRED : the new definition to use\n                see EXTERNAL_AUDIENCE_DICT & PLATFORM_AUDIENCE_DICT  \n        \"\"\"\n        if audienceId is None:\n            raise ValueError(\"Require an audience ID\")\n        if audienceObj is None or type(audienceObj) != dict:\n            raise ValueError(\"Require a new definition\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting putAudience for audienceId: {audienceId}\")\n        path = f\"/audiences/{audienceId}\"\n        res = self.connector.putData(self.endpoint + path,data=audienceObj)\n        return res", "    \n\n\n"]}
{"filename": "aepp/sensei.py", "chunked_list": ["#  Copyright 2023 Adobe. All rights reserved.\n#  This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License. You may obtain a copy\n#  of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software distributed under\n#  the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n#  OF ANY KIND, either express or implied. See the License for the specific language\n#  governing permissions and limitations under the License.\n", "#  governing permissions and limitations under the License.\n\n# internal library\nimport aepp\nfrom aepp import connector\nimport logging\nfrom copy import deepcopy\nfrom typing import Union\nfrom .configs import ConnectObject\n", "from .configs import ConnectObject\n\n\nclass Sensei:\n    \"\"\"\n    This module is based on the Sensei Machine Learning API from Adobe Experience Platform.\n    You can find more documentation on the endpoints here : https://www.adobe.io/apis/experienceplatform/home/api-reference.html#/\n    \"\"\"\n\n    # logging capability\n    loggingEnabled = False\n    logger = None\n\n    def __init__(\n        self,\n        config: Union[dict,ConnectObject] = aepp.config.config_object,\n        header: dict = aepp.config.header,\n        loggingObject: dict = None,\n        **kwargs,\n    ) -> None:\n        \"\"\"\n        Initialize the class with the config header used.\n        Arguments:\n            loggingObject : OPTIONAL : logging object to log messages.\n            config : OPTIONAL : config object in the config module.\n            header : OPTIONAL : header object  in the config module.\n        Additional kwargs will update the header.\n        \"\"\"\n        if loggingObject is not None and sorted(\n            [\"level\", \"stream\", \"format\", \"filename\", \"file\"]\n        ) == sorted(list(loggingObject.keys())):\n            self.loggingEnabled = True\n            self.logger = logging.getLogger(f\"{__name__}\")\n            self.logger.setLevel(loggingObject[\"level\"])\n            if type(loggingObject[\"format\"]) == str:\n                formatter = logging.Formatter(loggingObject[\"format\"])\n            elif type(loggingObject[\"format\"]) == logging.Formatter:\n                formatter = loggingObject[\"format\"]\n            if loggingObject[\"file\"]:\n                fileHandler = logging.FileHandler(loggingObject[\"filename\"])\n                fileHandler.setFormatter(formatter)\n                self.logger.addHandler(fileHandler)\n            if loggingObject[\"stream\"]:\n                streamHandler = logging.StreamHandler()\n                streamHandler.setFormatter(formatter)\n                self.logger.addHandler(streamHandler)\n        if type(config) == dict: ## Supporting either default setup or passing a ConnectObject\n            config = config\n        elif type(config) == ConnectObject:\n            header = config.getConfigHeader()\n            config = config.getConfigObject()\n        self.connector = connector.AdobeRequest(\n            config=config,\n            header=header,\n            loggingEnabled=self.loggingEnabled,\n            logger=self.logger,\n        )\n        self.header = self.connector.header\n        self.header[\n            \"Accept\"\n        ] = \"application/vnd.adobe.platform.sensei+json;profile=mlInstanceListing.v1.json\"\n        self.header.update(**kwargs)\n        if kwargs.get('sandbox',None) is not None: ## supporting sandbox setup on class instanciation\n            self.sandbox = kwargs.get('sandbox')\n            self.connector.config[\"sandbox\"] = kwargs.get('sandbox')\n            self.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n            self.connector.header.update({\"x-sandbox-name\":kwargs.get('sandbox')})\n        else:\n            self.sandbox = self.connector.config[\"sandbox\"]\n        self.endpoint = (\n            aepp.config.endpoints[\"global\"] + aepp.config.endpoints[\"sensei\"]\n        )\n\n    def getEngines(self, limit: int = 25, **kwargs) -> list:\n        \"\"\"\n        Return the list of all engines.\n        Arguments:\n            limit : OPTIONAL : number of element per requests\n        kwargs:\n            property : filtering, example value \"name==test.\"\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getEngines\")\n        path = \"/engines\"\n        params = {\"limit\": limit}\n        if kwargs.get(\"property\", False) != False:\n            params[\"property\"] = kwargs.get(\"property\", \"\")\n        res = self.connector.getData(\n            self.endpoint + path, headers=self.header, params=params\n        )\n        data = res[\"children\"]\n        return data\n\n    def getEngine(self, engineId: str = None) -> dict:\n        \"\"\"\n        return a specific engine information based on its id.\n        Arguments:\n            engineId : REQUIRED : the engineId to return.\n        \"\"\"\n        if engineId is None:\n            raise Exception(\"require an engineId parameter\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getEngine\")\n        path = f\"/engines/{engineId}\"\n        res = self.connector.getData(self.endpoint + path, headers=self.header)\n        return res\n\n    def getDockerRegistery(self) -> dict:\n        \"\"\"\n        Return the docker registery information.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getDockerRegistery\")\n        path = \"/engines/dockerRegistry\"\n        res = self.connector.getData(self.endpoint + path, headers=self.header)\n        return res\n\n    def deleteEngine(self, engineId: str = None) -> str:\n        \"\"\"\n        Delete an engine based on the id passed.\n        Arguments:\n            engineId : REQUIRED : Engine ID to be deleted.\n        \"\"\"\n        if engineId is None:\n            raise Exception(\"require an engineId parameter\")\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting deleteEngine\")\n        path = f\"/engines/{engineId}\"\n        res = self.connector.deleteData(self.endpoint + path, headers=self.header)\n        return res\n\n    def getMLinstances(self, limit: int = 25) -> list:\n        \"\"\"\n        Return a list of all of the ml instance\n        Arguments:\n            limit : OPTIONAL : number of elements retrieved.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting getMLinstances\")\n        path = \"/mlInstances\"\n        params = {\"limit\": limit}\n        res = self.connector.getData(\n            self.endpoint + path, headers=self.header, params=params\n        )\n        data = res[\"children\"]\n        return data\n\n    def createMLinstances(\n        self, name: str = None, engineId: str = None, description: str = None\n    ):\n        \"\"\"\n        Create a ML instance with the name and instanceId provided.\n        Arguments:\n            name : REQUIRED : name of the ML instance\n            engineId : REQUIRED : engine attached to the ML instance\n            description : OPTIONAL : description of the instance.\n        \"\"\"\n        if self.loggingEnabled:\n            self.logger.debug(f\"Starting createMLinstances\")\n        path = \"/mlInstances\"\n        privateHeader = deepcopy(self.header)\n        privateHeader[\n            \"Content\"\n        ] = \"application/vnd.adobe.platform.sensei+json;profile=mlInstanceListing.v1.json\"\n        if name is None and engineId is None:\n            raise Exception(\"Requires a name and an egineId\")\n        body = {\"name\": name, \"engineId\": engineId, \"description\": description}\n        res = self.connector.getData(\n            self.endpoint + path, headers=privateHeader, data=body\n        )\n        return res", ""]}
